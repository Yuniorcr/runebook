<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="">
    <body>
      <group id="">
        <trans-unit id="1485f3d0af50f7ad2c38bab6ab4b82f7cade74e8" translate="yes" xml:space="preserve">
          <source>The right to modify or destroy an object is always the privilege of the owner only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b02a1fae471a2cfa0b9f0f9afcb866f7eeb267" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized expression, which must yield an array value. The left-hand expression is evaluated and compared to each element of the array using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ALL&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if all comparisons yield true (including the case where the array has zero elements). The result is &amp;ldquo;false&amp;rdquo; if any false result is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0854056fb124d8ec388aaba4b2f113f43a992144" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized expression, which must yield an array value. The left-hand expression is evaluated and compared to each element of the array using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ANY&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any true result is obtained. The result is &amp;ldquo;false&amp;rdquo; if no true result is found (including the case where the array has zero elements).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cadd4592ac992256e9ca190e2ede2776b0f06bb" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized list of scalar expressions. The result is &amp;ldquo;true&amp;rdquo; if the left-hand expression's result is equal to any of the right-hand expressions. This is a shorthand notation for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6bece97382db0f9b6ad5060523f2f32e422503" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized list of scalar expressions. The result is &amp;ldquo;true&amp;rdquo; if the left-hand expression's result is unequal to all of the right-hand expressions. This is a shorthand notation for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4623e53b09512588ad13e7eaadc6e34f6d36d750" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ALL&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if all rows yield true (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if any false result is found. The result is NULL if no comparison with a subquery row returns false, and at least one comparison returns NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b47774fd6157f8ca176076b1ed18f995c2daef" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ANY&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any true result is obtained. The result is &amp;ldquo;false&amp;rdquo; if no true result is found (including the case where the subquery returns no rows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7873b5839bfc7065dc6edeb7940049a4cb53216" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result. The result of &lt;code&gt;IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any equal subquery row is found. The result is &amp;ldquo;false&amp;rdquo; if no equal row is found (including the case where the subquery returns no rows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca2d475edb7fe77a4b6be61177af0a4c222988e" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result. The result of &lt;code&gt;NOT IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if only unequal subquery rows are found (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if any equal row is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ffe49fd73a1dfeb0ff0a3cd27bc012700f7f66" translate="yes" xml:space="preserve">
          <source>The risk that is taken by using asynchronous commit is of data loss, not data corruption. If the database should crash, it will recover by replaying WAL up to the last record that was flushed. The database will therefore be restored to a self-consistent state, but any transactions that were not yet flushed to disk will not be reflected in that state. The net effect is therefore loss of the last few transactions. Because the transactions are replayed in commit order, no inconsistency can be introduced &amp;mdash; for example, if transaction B made changes relying on the effects of a previous transaction A, it is not possible for A's effects to be lost while B's effects are preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458aee8243a88af8890a3686268fbeeebdc768b4" translate="yes" xml:space="preserve">
          <source>The role attributes &lt;code&gt;LOGIN&lt;/code&gt;, &lt;code&gt;SUPERUSER&lt;/code&gt;, &lt;code&gt;CREATEDB&lt;/code&gt;, and &lt;code&gt;CREATEROLE&lt;/code&gt; can be thought of as special privileges, but they are never inherited as ordinary privileges on database objects are. You must actually &lt;code&gt;SET ROLE&lt;/code&gt; to a specific role having one of these attributes in order to make use of the attribute. Continuing the above example, we might choose to grant &lt;code&gt;CREATEDB&lt;/code&gt; and &lt;code&gt;CREATEROLE&lt;/code&gt; to the &lt;code&gt;admin&lt;/code&gt; role. Then a session connecting as role &lt;code&gt;joe&lt;/code&gt; would not have these privileges immediately, only after doing &lt;code&gt;SET ROLE admin&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc4f14a678d35107865a506875d403f1fabcef04" translate="yes" xml:space="preserve">
          <source>The role name of the user who will own the new database, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the default (namely, the user executing the command). To create a database owned by another role, you must be a direct or indirect member of that role, or be a superuser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0cd094fcb28a6d1c971a4fe5ea4b6668f0b2297" translate="yes" xml:space="preserve">
          <source>The role name of the user who will own the new schema. If omitted, defaults to the user executing the command. To create a schema owned by another role, you must be a direct or indirect member of that role, or be a superuser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="288659e152f65b17d46027cdd207a204fb13225f" translate="yes" xml:space="preserve">
          <source>The role used for the replication connection must have the &lt;code&gt;REPLICATION&lt;/code&gt; attribute (or be a superuser). Access for the role must be configured in &lt;code&gt;pg_hba.conf&lt;/code&gt; and it must have the &lt;code&gt;LOGIN&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7270c8298ccd5ab28e0386f721a4bd64642b81f5" translate="yes" xml:space="preserve">
          <source>The role(s) to which the policy applies. Multiple roles can be specified at one time. To apply the policy to all roles, use &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="672dc56056e4468fca330096a6f7988e99426d64" translate="yes" xml:space="preserve">
          <source>The role(s) to which the policy is to be applied. The default is &lt;code&gt;PUBLIC&lt;/code&gt;, which will apply the policy to all roles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da08283627fb6b277f73d5b0ddf0372ed6cb0f5d" translate="yes" xml:space="preserve">
          <source>The roles to which the policy is applied</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b502eae099c8f10d1ed4ef0c354669f63bce361" translate="yes" xml:space="preserve">
          <source>The roles to which this policy applies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd6a9c4a0e56d2f8f09c7b30b75a454cb6c1d08" translate="yes" xml:space="preserve">
          <source>The rows considered by a window function are those of the &amp;ldquo;virtual table&amp;rdquo; produced by the query's &lt;code&gt;FROM&lt;/code&gt; clause as filtered by its &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses if any. For example, a row removed because it does not meet the &lt;code&gt;WHERE&lt;/code&gt; condition is not seen by any window function. A query can contain multiple window functions that slice up the data in different ways using different &lt;code&gt;OVER&lt;/code&gt; clauses, but they all act on the same collection of rows defined by this virtual table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac9a42afd27bb82c7fefe7d8456c8e56005d3e20" translate="yes" xml:space="preserve">
          <source>The rows skipped by an &lt;code&gt;OFFSET&lt;/code&gt; clause still have to be computed inside the server; therefore a large &lt;code&gt;OFFSET&lt;/code&gt; might be inefficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c6595d74dd986e8e704f616ce70f02f89a3b6e5" translate="yes" xml:space="preserve">
          <source>The rule firing mechanism is also affected by the configuration variable &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt;, analogous to triggers as described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77cbd29a44e08d42c19c09374140fe6b3a2c7eb5" translate="yes" xml:space="preserve">
          <source>The rules file has the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20f26d0e3be07fc8411c53cf4fec028b4fb7ddc1" translate="yes" xml:space="preserve">
          <source>The rules given in the preceding sections will result in assignment of non-&lt;code&gt;unknown&lt;/code&gt; data types to all expressions in a SQL query, except for unspecified-type literals that appear as simple output columns of a &lt;code&gt;SELECT&lt;/code&gt; command. For example, in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a710b4d0128d22b5baa147d345de94a14b25c08a" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;1...2&lt;/code&gt;, or &lt;code&gt;1 .. 2&lt;/code&gt;, or &lt;code&gt;1..2&lt;/code&gt; (spaces around the range operator are ignored)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e201d82f084cc5d95195c10944ee93631d8df0" translate="yes" xml:space="preserve">
          <source>The same, and also reset any associated sequence generators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241b8d226e8b5f79ed0ec6888a0ce004af81b21c" translate="yes" xml:space="preserve">
          <source>The same, but counting only word occurrences with weight &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d2e57444e30e19980ec9c24adfc53e9305e592" translate="yes" xml:space="preserve">
          <source>The same, but only execute the function if column &lt;code&gt;balance&lt;/code&gt; is specified as a target in the &lt;code&gt;UPDATE&lt;/code&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="002437cb1427716a633526fb7913d4100317c440" translate="yes" xml:space="preserve">
          <source>The same, specified as a table constraint:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788d460ac0c5a82665dae9bd0fa72bfb74260b32" translate="yes" xml:space="preserve">
          <source>The same, using regular expression notation to consolidate the switches:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfae0e75e1b6288495d53b506d9a241bf9d03b6d" translate="yes" xml:space="preserve">
          <source>The same, when the column has a default expression that won't automatically cast to the new data type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d799562b98253554741c727e0742611d0f2a5b8b" translate="yes" xml:space="preserve">
          <source>The sample results shown on this page assume that the server parameter &lt;a href=&quot;runtime-config-client#GUC-BYTEA-OUTPUT&quot;&gt;&lt;code&gt;bytea_output&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;escape&lt;/code&gt; (the traditional PostgreSQL format).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63cecb1fda6e05d04ffb99e00faba23729910dbf" translate="yes" xml:space="preserve">
          <source>The savepoint to roll back to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237920c06713568a0627b8a6cf3c35b4a6fcf5f1" translate="yes" xml:space="preserve">
          <source>The scalar ordering operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, etc) do not make a lot of sense for any practical purpose but sorting. These operators first compare the first coordinates, and if those are equal, compare the second coordinates, etc. They exist mainly to support the b-tree index operator class for &lt;code&gt;cube&lt;/code&gt;, which can be useful for example if you would like a UNIQUE constraint on a &lt;code&gt;cube&lt;/code&gt; column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8365d330a7b8ee61b52ae905279178001855d43" translate="yes" xml:space="preserve">
          <source>The schema containing the &lt;code&gt;citext&lt;/code&gt; operators must be in the current &lt;code&gt;search_path&lt;/code&gt; (typically &lt;code&gt;public&lt;/code&gt;); if it is not, the normal case-sensitive &lt;code&gt;text&lt;/code&gt; operators will be invoked instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1b72adef26aba98ed5b9a11c3f8d9f992851abe" translate="yes" xml:space="preserve">
          <source>The schema definitions are not replicated, and the published tables must exist on the subscriber. Only regular tables may be the target of replication. For example, you can't replicate to a view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="459a237a85ce3b91cf8ef1e52361b976ab47c1f2" translate="yes" xml:space="preserve">
          <source>The schema in which the imported foreign tables will be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01865c073aef636c813a71a650ffa6b695ee5717" translate="yes" xml:space="preserve">
          <source>The schemes shown here assume that the values of a row's key column(s) never change, or at least do not change enough to require it to move to another partition. An &lt;code&gt;UPDATE&lt;/code&gt; that attempts to do that will fail because of the &lt;code&gt;CHECK&lt;/code&gt; constraints. If you need to handle such cases, you can put suitable update triggers on the child tables, but it makes management of the structure much more complicated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec9b55e40d83c1563492fc665bcf7be0f37fb815" translate="yes" xml:space="preserve">
          <source>The scripts can be run in any order and can be deleted once they have been run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5351b57ec30c67488f197082c674a1ac3697572e" translate="yes" xml:space="preserve">
          <source>The search filter to use when doing search+bind authentication. Occurrences of &lt;code&gt;$username&lt;/code&gt; will be replaced with the user name. This allows for more flexible search filters than &lt;code&gt;ldapsearchattribute&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc9e6cb9abd2e41c04bc258bc4b8a29867d6da64" translate="yes" xml:space="preserve">
          <source>The search path can be altered at run time. The command is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478354e0ca1e05b1455044d0dbe23d731c182378" translate="yes" xml:space="preserve">
          <source>The search path works in the same way for data type names, function names, and operator names as it does for table names. Data type and function names can be qualified in exactly the same way as table names. If you need to write a qualified operator name in an expression, there is a special provision: you must write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f585a0c61cda16f1f2f37af64c77ecb164389f" translate="yes" xml:space="preserve">
          <source>The second approach combines any authentication method for &lt;code&gt;hostssl&lt;/code&gt; entries with the verification of client certificates by setting the &lt;code&gt;clientcert&lt;/code&gt; authentication option to &lt;code&gt;verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt;. The former option only enforces that the certificate is valid, while the latter also ensures that the &lt;code&gt;cn&lt;/code&gt; (Common Name) in the certificate matches the user name or an applicable mapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e7e9d77036e0c9575b0fa838e7bb55bd546fa0a" translate="yes" xml:space="preserve">
          <source>The second argument must be a well formed XML document. In particular, it must have a single root node element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971af670862eab67d21e45dbeea285001e2a069e" translate="yes" xml:space="preserve">
          <source>The second example will store cities and their associated geographical location:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8fdfc2d4d4050aa9351fe7e549967c0e1502821" translate="yes" xml:space="preserve">
          <source>The second form changes the name of the database. Only the database owner or a superuser can rename a database; non-superuser owners must also have the &lt;code&gt;CREATEDB&lt;/code&gt; privilege. The current database cannot be renamed. (Connect to a different database if you need to do that.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f97cd14403d43a28906f958a63aa9be74a831f3" translate="yes" xml:space="preserve">
          <source>The second form is a PostgreSQL extension. It fills the columns from the left with as many values as are given, and the rest will be defaulted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="001f55ae6b12f7691ee493402996a3cedd18d43d" translate="yes" xml:space="preserve">
          <source>The second form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates an enumerated (enum) type, as described in &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;. Enum types take a list of quoted labels, each of which must be less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; bytes long (64 bytes in a standard PostgreSQL build). (It is possible to create an enumerated type with zero labels, but such a type cannot be used to hold values before at least one label is added using &lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9646c72014e3dc0cdbc889805cc625cb2e00d4a4" translate="yes" xml:space="preserve">
          <source>The second implementation of the rule system is a technique called &lt;em&gt;query rewriting&lt;/em&gt;. The &lt;em&gt;rewrite system&lt;/em&gt; is a module that exists between the &lt;em&gt;parser stage&lt;/em&gt; and the &lt;em&gt;planner/optimizer&lt;/em&gt;. This technique is still implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b82fe6094f17ae862d5ae179aa9cdfdad11af121" translate="yes" xml:space="preserve">
          <source>The second line is the command that would be invoked in restart mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e54d9500bd7199e013e0c26f4d1118e580aabf7" translate="yes" xml:space="preserve">
          <source>The second part of the module relies on representing Earth locations as values of type &lt;code&gt;point&lt;/code&gt;, in which the first component is taken to represent longitude in degrees, and the second component is taken to represent latitude in degrees. Points are taken as (longitude, latitude) and not vice versa because longitude is closer to the intuitive idea of x-axis and latitude to y-axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07476921b1bd87798420cb9dffdda71ef3f07ce3" translate="yes" xml:space="preserve">
          <source>The second variant changes the name of the role. Database superusers can rename any role. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can rename non-superuser roles. The current session user cannot be renamed. (Connect as a different user if you need to do that.) Because &lt;code&gt;MD5&lt;/code&gt;-encrypted passwords use the role name as cryptographic salt, renaming a role clears its password if the password is &lt;code&gt;MD5&lt;/code&gt;-encrypted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfe4da30b9c6bff8e95fbde2fcc03500be370613" translate="yes" xml:space="preserve">
          <source>The seconds field, including fractional parts (0 - 59&lt;a href=&quot;#ftn.id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;[7]&lt;/sup&gt;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663b58f51194288bd80b435fbc5e648d8e6f6580" translate="yes" xml:space="preserve">
          <source>The seconds field, including fractional parts, multiplied by 1 000 000; note that this includes full seconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d44e15dba826649cac46abaee1bc5cb23f259a3" translate="yes" xml:space="preserve">
          <source>The seconds field, including fractional parts, multiplied by 1000. Note that this includes full seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bfc04444cf0b5a28dd815138a4bbbe840cd72f0" translate="yes" xml:space="preserve">
          <source>The security label applied to this object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47689b397bbce6da7cf131cc329c56ad0b8b0d2" translate="yes" xml:space="preserve">
          <source>The security model of SELinux describes all the access control rules as relationships between a subject entity (typically, a client of the database) and an object entity (such as a database object), each of which is identified by a security label. If access to an unlabeled object is attempted, the object is treated as if it were assigned the label &lt;code&gt;unlabeled_t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230231accae0954bfa7e47d9f5e404dcd469b2c5" translate="yes" xml:space="preserve">
          <source>The security policy of SELinux also has rules to control whether or not particular accesses are logged. By default, access violations are logged, but allowed accesses are not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbcd4d113ca55d30a1adafc062bb48c13c7f8e98" translate="yes" xml:space="preserve">
          <source>The seed can also be set by invoking the function &lt;code&gt;setseed&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c3344ee525a48fbaf283fc79a5b884444be3dcb" translate="yes" xml:space="preserve">
          <source>The segment [a, b] contains the segment [c, d], that is, a &amp;lt;= c and b &amp;gt;= d.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0167ae8a0ef2744b5f058f32dbb8df42b67bb33e" translate="yes" xml:space="preserve">
          <source>The segment [a, b] is contained in [c, d], that is, a &amp;gt;= c and b &amp;lt;= d.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9dfe875337796db870c4bb2a262e2bbef3945b" translate="yes" xml:space="preserve">
          <source>The segments [a, b] and [c, d] overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b10711fce98e1c5fe5a4897a9961ed9ae2f37aef" translate="yes" xml:space="preserve">
          <source>The semantics of SQL/JSON path predicates and operators generally follow SQL. At the same time, to provide a most natural way of working with JSON data, SQL/JSON path syntax uses some of the JavaScript conventions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2f632c9b81511535163336539f86f918d83e9e" translate="yes" xml:space="preserve">
          <source>The semicolon (&lt;code&gt;;&lt;/code&gt;) terminates an SQL command. It cannot appear anywhere within a command, except within a string constant or quoted identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c68a3eca090a3377bf1a78fea499d56ec605109" translate="yes" xml:space="preserve">
          <source>The sequence created for a &lt;code&gt;serial&lt;/code&gt; column is automatically dropped when the owning column is dropped. You can drop the sequence without dropping the column, but this will force removal of the column default expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a5d93057bd5edff8daf4648c4c935388f9e10e" translate="yes" xml:space="preserve">
          <source>The sequence name can be schema-qualified if necessary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a359aa04dbc4531fddf8d09e8fef46d55e14f6" translate="yes" xml:space="preserve">
          <source>The sequence to be operated on by a sequence function is specified by a &lt;code&gt;regclass&lt;/code&gt; argument, which is simply the OID of the sequence in the &lt;code&gt;pg_class&lt;/code&gt; system catalog. You do not have to look up the OID by hand, however, since the &lt;code&gt;regclass&lt;/code&gt; data type's input converter will do the work for you. Just write the sequence name enclosed in single quotes so that it looks like a literal constant. For compatibility with the handling of ordinary SQL names, the string will be converted to lower case unless it contains double quotes around the sequence name. Thus:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7d18fda0e93393ee728bac05185520e2d92f5c" translate="yes" xml:space="preserve">
          <source>The server log might contain more information about an authentication failure than is reported to the client. If you are confused about the reason for a failure, check the server log.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca1254319f0477050eedb4dcb243dbc28231770" translate="yes" xml:space="preserve">
          <source>The server name must be unique within the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac56c0453261e732a23fed94e0a24c8f95cc0488" translate="yes" xml:space="preserve">
          <source>The server reads these files at server start and whenever the server configuration is reloaded. On Windows systems, they are also re-read whenever a new backend process is spawned for a new client connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d31219164213fd90b64aadc8577b6089ce02b9" translate="yes" xml:space="preserve">
          <source>The server sends an AuthenticationSASL message. It includes a list of SASL authentication mechanisms that the server can accept. This will be &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; and &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; if the server is built with SSL support, or else just the latter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b019b1a1b7d85dded861255aa6e59d8f9921d05a" translate="yes" xml:space="preserve">
          <source>The server will occasionally request the client to perform a flush and report the flush position to the server. This setting is in addition to that, to perform flushes more frequently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8da77a2b390601e3adff073821408d13cdbea6" translate="yes" xml:space="preserve">
          <source>The server's checkpointer process automatically performs a checkpoint every so often. A checkpoint is begun every &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt; seconds, or if &lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt; is about to be exceeded, whichever comes first. The default settings are 5 minutes and 1 GB, respectively. If no WAL has been written since the previous checkpoint, new checkpoints will be skipped even if &lt;code&gt;checkpoint_timeout&lt;/code&gt; has passed. (If WAL archiving is being used and you want to put a lower limit on how often files are archived in order to bound potential data loss, you should adjust the &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt; parameter rather than the checkpoint parameters.) It is also possible to force a checkpoint by using the SQL command &lt;code&gt;CHECKPOINT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c205218c3546e4b301b493a03547b46277844636" translate="yes" xml:space="preserve">
          <source>The server's version number as a string, for example &lt;code&gt;9.6.2&lt;/code&gt;, &lt;code&gt;10.1&lt;/code&gt; or &lt;code&gt;11beta1&lt;/code&gt;, and in numeric form, for example &lt;code&gt;90602&lt;/code&gt; or &lt;code&gt;100001&lt;/code&gt;. These are set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a84cc79fdbb16a887f43ceaad26726c6755ffe1" translate="yes" xml:space="preserve">
          <source>The session default transaction modes can also be set by setting the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-ISOLATION&quot;&gt;default_transaction_isolation&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-READ-ONLY&quot;&gt;default_transaction_read_only&lt;/a&gt;, and &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-DEFERRABLE&quot;&gt;default_transaction_deferrable&lt;/a&gt;. (In fact &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; is just a verbose equivalent for setting these variables with &lt;code&gt;SET&lt;/code&gt;.) This means the defaults can be set in the configuration file, via &lt;code&gt;ALTER DATABASE&lt;/code&gt;, etc. Consult &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6723e0bdad2077d09fd447f64653c3402fb21a9f" translate="yes" xml:space="preserve">
          <source>The session user identifier can be changed only if the initial session user (the &lt;em&gt;authenticated user&lt;/em&gt;) had the superuser privilege. Otherwise, the command is accepted only if it specifies the authenticated user name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="715d310203fd1767744b0e3abc3cbaadfd49947d" translate="yes" xml:space="preserve">
          <source>The session user identifier is initially set to be the (possibly authenticated) user name provided by the client. The current user identifier is normally equal to the session user identifier, but might change temporarily in the context of &lt;code&gt;SECURITY DEFINER&lt;/code&gt; functions and similar mechanisms; it can also be changed by &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;. The current user identifier is relevant for permission checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94dcf85932be3ca953bb5dbee89cd4f7713067fb" translate="yes" xml:space="preserve">
          <source>The set of database roles a given client connection can connect as is determined by the client authentication setup, as explained in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;. (Thus, a client is not limited to connect as the role matching its operating system user, just as a person's login name need not match his or her real name.) Since the role identity determines the set of privileges available to a connected client, it is important to carefully configure privileges when setting up a multiuser environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e7e3efb30616b981cfefa41268aa6951e3d5f2" translate="yes" xml:space="preserve">
          <source>The setting &lt;code&gt;RemoveIPC&lt;/code&gt; in &lt;code&gt;logind.conf&lt;/code&gt; controls whether IPC objects are removed when a user fully logs out. System users are exempt. This setting defaults to on in stock systemd, but some operating system distributions default it to off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64eba0ac674f39ed469aa292d2c2a8445eebc9f9" translate="yes" xml:space="preserve">
          <source>The setting of some parameters on the standby will need reconfiguration if they have been changed on the primary. For these parameters, the value on the standby must be equal to or greater than the value on the primary. Therefore, if you want to increase these values, you should do so on all standby servers first, before applying the changes to the primary server. Conversely, if you want to decrease these values, you should do so on the primary server first, before applying the changes to all standby servers. If these parameters are not set high enough then the standby will refuse to start. Higher values can then be supplied and the server restarted to begin recovery again. These parameters are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f66060d984a3d43717aaa1c8e7136685e2e6d1f" translate="yes" xml:space="preserve">
          <source>The shared lock table tracks locks on &lt;code&gt;max_locks_per_transaction&lt;/code&gt; * (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;) objects (e.g., tables); hence, no more than this many distinct objects can be locked at any one time. This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. This is &lt;em&gt;not&lt;/em&gt; the number of rows that can be locked; that value is unlimited. The default, 64, has historically proven sufficient, but you might need to raise this value if you have queries that touch many different tables in a single transaction, e.g. query of a parent table with many children. This parameter can only be set at server start.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8d27015cd393d0e4d2ed8b1d7004db3e56b61f" translate="yes" xml:space="preserve">
          <source>The shared memory size settings can be changed via the &lt;code&gt;sysctl&lt;/code&gt; interface. For example, to allow 16 GB:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068843c57f60fb86ac3cb60c430b5300612b2f9d" translate="yes" xml:space="preserve">
          <source>The shared predicate lock table tracks locks on &lt;code&gt;max_pred_locks_per_transaction&lt;/code&gt; * (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;) objects (e.g., tables); hence, no more than this many distinct objects can be locked at any one time. This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. This is &lt;em&gt;not&lt;/em&gt; the number of rows that can be locked; that value is unlimited. The default, 64, has generally been sufficient in testing, but you might need to raise this value if you have clients that touch many different tables in a single serializable transaction. This parameter can only be set at server start.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca5a87d53a78cc8149d60b5d1c35e814aa59a259" translate="yes" xml:space="preserve">
          <source>The shared secrets used when talking securely to the RADIUS server. This must have exactly the same value on the PostgreSQL and RADIUS servers. It is recommended that this be a string of at least 16 characters. This parameter is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e38019afd1ad1853e1d01481b88d4b91b8d05a" translate="yes" xml:space="preserve">
          <source>The sharp (&lt;code&gt;#&lt;/code&gt;) sign is a comment delimiter. It may appear at any position in a line. The rest of the line will be skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67cfcf8acce2ecc45db3a0f17045ee10928b08a1" translate="yes" xml:space="preserve">
          <source>The short procedure for configuring a standby server using this alternative method is as follows. For full details of each step, refer to previous sections as noted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968f59638db3803d09dafd7e362f7206431f6346" translate="yes" xml:space="preserve">
          <source>The simple comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; compare the lower bounds first, and only if those are equal, compare the upper bounds. These comparisons are not usually very useful for ranges, but are provided to allow B-tree indexes to be constructed on ranges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ea620de73d7bb2e034a3dc8ebd2dd0118f06f72" translate="yes" xml:space="preserve">
          <source>The simplest kind of extended statistics tracks &lt;em&gt;functional dependencies&lt;/em&gt;, a concept used in definitions of database normal forms. We say that column &lt;code&gt;b&lt;/code&gt; is functionally dependent on column &lt;code&gt;a&lt;/code&gt; if knowledge of the value of &lt;code&gt;a&lt;/code&gt; is sufficient to determine the value of &lt;code&gt;b&lt;/code&gt;, that is there are no two rows having the same value of &lt;code&gt;a&lt;/code&gt; but different values of &lt;code&gt;b&lt;/code&gt;. In a fully normalized database, functional dependencies should exist only on primary keys and superkeys. However, in practice many data sets are not fully normalized for various reasons; intentional denormalization for performance reasons is a common example. Even in a fully normalized database, there may be partial correlation between some columns, which can be expressed as partial functional dependency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="218e0e862d91c332c13bb63fca705baa68ee5396" translate="yes" xml:space="preserve">
          <source>The simplest kind of select list is &lt;code&gt;*&lt;/code&gt; which emits all columns that the table expression produces. Otherwise, a select list is a comma-separated list of value expressions (as defined in &lt;a href=&quot;sql-expressions&quot;&gt;Section 4.2&lt;/a&gt;). For instance, it could be a list of column names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ff410c0d68dcd6b5d1a3a14a5e05f946ef4e40" translate="yes" xml:space="preserve">
          <source>The simplest option for removing old data is to drop the partition that is no longer necessary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d938ffa1d7d07edb850b5b705fb8034d9885325" translate="yes" xml:space="preserve">
          <source>The size of the block range is determined at index creation time by the &lt;code&gt;pages_per_range&lt;/code&gt; storage parameter. The number of index entries will be equal to the size of the relation in pages divided by the selected value for &lt;code&gt;pages_per_range&lt;/code&gt;. Therefore, the smaller the number, the larger the index becomes (because of the need to store more index entries), but at the same time the summary data stored can be more precise and more data blocks can be skipped during an index scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6017b9e9e841e1ed3391e353ec7b6f77818cd5d" translate="yes" xml:space="preserve">
          <source>The slice syntaxes with omitted &lt;code&gt;lower-bound&lt;/code&gt; and/or &lt;code&gt;upper-bound&lt;/code&gt; can be used too, but only when updating an array value that is not NULL or zero-dimensional (otherwise, there is no existing subscript limit to substitute).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a06932e4c9d25d4fab3d4aa77750dbf6cafc0f" translate="yes" xml:space="preserve">
          <source>The slot type - &lt;code&gt;physical&lt;/code&gt; or &lt;code&gt;logical&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4042361f65f02965ea45d409682bd67eb2ab934d" translate="yes" xml:space="preserve">
          <source>The sole disadvantage of increasing &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; (and &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; along with it) is that the &lt;code&gt;pg_xact&lt;/code&gt; and &lt;code&gt;pg_commit_ts&lt;/code&gt; subdirectories of the database cluster will take more space, because it must store the commit status and (if &lt;code&gt;track_commit_timestamp&lt;/code&gt; is enabled) timestamp of all transactions back to the &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; horizon. The commit status uses two bits per transaction, so if &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; is set to its maximum allowed value of two billion, &lt;code&gt;pg_xact&lt;/code&gt; can be expected to grow to about half a gigabyte and &lt;code&gt;pg_commit_ts&lt;/code&gt; to about 20GB. If this is trivial compared to your total database size, setting &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; to its maximum allowed value is recommended. Otherwise, set it depending on what you are willing to allow for &lt;code&gt;pg_xact&lt;/code&gt; and &lt;code&gt;pg_commit_ts&lt;/code&gt; storage. (The default, 200 million transactions, translates to about 50MB of &lt;code&gt;pg_xact&lt;/code&gt; storage and about 2GB of &lt;code&gt;pg_commit_ts&lt;/code&gt; storage.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420d354e00f2d98f43f69fb5c85b3c9d2f0a5c6c" translate="yes" xml:space="preserve">
          <source>The sort expression(s) can be any expression that would be valid in the query's select list. An example is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af64fa9d73d05dafcf40b04a10bc43a2c675e4b9" translate="yes" xml:space="preserve">
          <source>The sort position of this enum value within its enum type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="267381ff52d7207cad90e1b1efb3d2ae56d6e149" translate="yes" xml:space="preserve">
          <source>The source directory &lt;code&gt;contrib/intarray/bench&lt;/code&gt; contains a benchmark test suite, which can be run against an installed PostgreSQL server. (It also requires &lt;code&gt;DBD::Pg&lt;/code&gt; to be installed.) To run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4b684dc4cf3d0e7f8017a75669ef677ed19f660" translate="yes" xml:space="preserve">
          <source>The source encoding name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b4632e063d85e50c766912ad7e51e33ef8bf318" translate="yes" xml:space="preserve">
          <source>The special &amp;ldquo;role&amp;rdquo; name &lt;code&gt;PUBLIC&lt;/code&gt; can be used to grant a privilege to every role on the system. Also, &amp;ldquo;group&amp;rdquo; roles can be set up to help manage privileges when there are many users of a database &amp;mdash; for details see &lt;a href=&quot;https://www.postgresql.org/docs/12/user-manag.html&quot;&gt;Chapter 21&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d534e247b3040487a992ce1f01908ab3c5c62964" translate="yes" xml:space="preserve">
          <source>The special entry &lt;code&gt;*&lt;/code&gt; matches any standby name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31bc549a6a2aaa2d8b0391bf2c83e80b6eb59358" translate="yes" xml:space="preserve">
          <source>The special field name &lt;code&gt;*&lt;/code&gt; means &amp;ldquo;all fields&amp;rdquo;, as further explained in &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="758ed933ac597fbff2a112b5d5781d2521256906" translate="yes" xml:space="preserve">
          <source>The special privileges of the object owner (i.e., the right to do &lt;code&gt;DROP&lt;/code&gt;, &lt;code&gt;GRANT&lt;/code&gt;, &lt;code&gt;REVOKE&lt;/code&gt;, etc.) are always implicit in being the owner, and cannot be granted or revoked. But the object owner can choose to revoke their own ordinary privileges, for example to make a table read-only for themselves as well as others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c644ef37e4f8fad5de2f6806820052ad171113ce" translate="yes" xml:space="preserve">
          <source>The special table function &lt;code&gt;UNNEST&lt;/code&gt; may be called with any number of array parameters, and it returns a corresponding number of columns, as if &lt;code&gt;UNNEST&lt;/code&gt; (&lt;a href=&quot;functions-array&quot;&gt;Section 9.18&lt;/a&gt;) had been called on each parameter separately and combined using the &lt;code&gt;ROWS FROM&lt;/code&gt; construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3760930d6be21baabcd516fd8aaa6bbd0e31deb" translate="yes" xml:space="preserve">
          <source>The special values &lt;code&gt;MINVALUE&lt;/code&gt; and &lt;code&gt;MAXVALUE&lt;/code&gt; may be used when creating a range partition to indicate that there is no lower or upper bound on the column's value. For example, a partition defined using &lt;code&gt;FROM (MINVALUE) TO (10)&lt;/code&gt; allows any values less than 10, and a partition defined using &lt;code&gt;FROM (10) TO (MAXVALUE)&lt;/code&gt; allows any values greater than or equal to 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e90fbaeae1d1655b1bb6f95cb13335bf4d3a214" translate="yes" xml:space="preserve">
          <source>The specially treated variables are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b586ed754bd73f7164a8d06b3ccf052091b7071" translate="yes" xml:space="preserve">
          <source>The specific data that a BRIN index will store, as well as the specific queries that the index will be able to satisfy, depend on the operator class selected for each column of the index. Data types having a linear sort order can have operator classes that store the minimum and maximum value within each block range, for instance; geometrical types might store the bounding box for all the objects in the block range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67370c9102fee266def76d5516bcf8df8f39414" translate="yes" xml:space="preserve">
          <source>The specific function that is referenced by a function call is determined using the following procedure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4491b1318b4f57536f43e332d74ca6d054454c5" translate="yes" xml:space="preserve">
          <source>The specific operator that is referenced by an operator expression is determined using the following procedure. Note that this procedure is indirectly affected by the precedence of the operators involved, since that will determine which sub-expressions are taken to be the inputs of which operators. See &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;Section 4.1.6&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf52c4d6cf2c8133df1aca73cde50bf658361fd0" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;index&lt;/code&gt; can be an integer, as well as an expression returning a single numeric value, which is automatically cast to integer. Zero index corresponds to the first array element. You can also use the &lt;code&gt;last&lt;/code&gt; keyword to denote the last array element, which is useful for handling arrays of unknown length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8859206cebb9c86d9bc85a5c793d72f97cbfcda7" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;role_name&lt;/code&gt; must be a role that the current session user is a member of. (If the session user is a superuser, any role can be selected.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd818a1af1c31122dbe5ccb86326656bebfdabf" translate="yes" xml:space="preserve">
          <source>The specified locale and encoding settings must match, or an error will be reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c30502cb792c5bd66e555818ae0268a7466dc40" translate="yes" xml:space="preserve">
          <source>The specified null string is sent by &lt;code&gt;COPY TO&lt;/code&gt; without adding any backslashes; conversely, &lt;code&gt;COPY FROM&lt;/code&gt; matches the input against the null string before removing backslashes. Therefore, a null string such as &lt;code&gt;\N&lt;/code&gt; cannot be confused with the actual data value &lt;code&gt;\N&lt;/code&gt; (which would be represented as &lt;code&gt;\\N&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d4785fdbe411a867de5dc30c6f6e2cd3e8ad8aa" translate="yes" xml:space="preserve">
          <source>The specified replication slot has to exist unless the option &lt;code&gt;-C&lt;/code&gt; is also used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe37bdbcd81870812798f7398d4fa3769b9383b0" translate="yes" xml:space="preserve">
          <source>The speed of the archiving command is unimportant as long as it can keep up with the average rate at which your server generates WAL data. Normal operation continues even if the archiving process falls a little behind. If archiving falls significantly behind, this will increase the amount of data that would be lost in the event of a disaster. It will also mean that the &lt;code&gt;pg_wal/&lt;/code&gt; directory will contain large numbers of not-yet-archived segment files, which could eventually exceed available disk space. You are advised to monitor the archiving process to ensure that it is working as you intend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c448049b38c97f5a095366eb9a582e60005694" translate="yes" xml:space="preserve">
          <source>The spi module provides several workable examples of using the &lt;a href=&quot;https://www.postgresql.org/docs/12/spi.html&quot;&gt;Server Programming Interface&lt;/a&gt; (SPI) and triggers. While these functions are of some value in their own right, they are even more useful as examples to modify for your own purposes. The functions are general enough to be used with any table, but you have to specify table and field names (as described below) while creating a trigger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d51509dfcf1b638bd0142f5ba7e99e05ff8361" translate="yes" xml:space="preserve">
          <source>The standard B-tree operators are also provided, for example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540592c3e626f7c31f8adb5673f9493bff1cdcb6" translate="yes" xml:space="preserve">
          <source>The standard PostgreSQL distribution does not include any Ispell configuration files. Dictionaries for a large number of languages are available from &lt;a href=&quot;https://www.cs.hmc.edu/~geoff/ispell.html&quot;&gt;Ispell&lt;/a&gt;. Also, some more modern dictionary file formats are supported &amp;mdash; &lt;a href=&quot;https://en.wikipedia.org/wiki/MySpell&quot;&gt;MySpell&lt;/a&gt; (OO &amp;lt; 2.0.1) and &lt;a href=&quot;https://sourceforge.net/projects/hunspell/&quot;&gt;Hunspell&lt;/a&gt; (OO &amp;gt;= 2.0.2). A large list of dictionaries is available on the &lt;a href=&quot;https://wiki.openoffice.org/wiki/Dictionaries&quot;&gt;OpenOffice Wiki&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31d1f8f49b866b6c41ce1d3be305d54cfca10f1" translate="yes" xml:space="preserve">
          <source>The standard allows transition tables to be used with column-specific &lt;code&gt;UPDATE&lt;/code&gt; triggers, but then the set of rows that should be visible in the transition tables depends on the trigger's column list. This is not currently implemented by PostgreSQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7abbb06bd2ac89072eb3b19d752092cab8a2a05f" translate="yes" xml:space="preserve">
          <source>The standard and predefined collations are in the schema &lt;code&gt;pg_catalog&lt;/code&gt;, like all predefined objects. User-defined collations should be created in user schemas. This also ensures that they are saved by &lt;code&gt;pg_dump&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4d54e7271038b160fc912ff3e59738441ec42e" translate="yes" xml:space="preserve">
          <source>The standard approach to doing case-insensitive matches in PostgreSQL has been to use the &lt;code&gt;lower&lt;/code&gt; function when comparing values, for example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a45d5bab8320954db0c2f93584f58e956d983a" translate="yes" xml:space="preserve">
          <source>The standard comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; are available for &lt;code&gt;jsonb&lt;/code&gt;, but not for &lt;code&gt;json&lt;/code&gt;. They follow the ordering rules for B-tree operations outlined at &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;Section 8.14.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aecb6846cb8fa061d2893b8cbe3329208b79f989" translate="yes" xml:space="preserve">
          <source>The standard form of &lt;code&gt;VACUUM&lt;/code&gt; removes dead row versions in tables and indexes and marks the space available for future reuse. However, it will not return the space to the operating system, except in the special case where one or more pages at the end of a table become entirely free and an exclusive table lock can be easily obtained. In contrast, &lt;code&gt;VACUUM FULL&lt;/code&gt; actively compacts tables by writing a complete new version of the table file with no dead space. This minimizes the size of the table, but can take a long time. It also requires extra disk space for the new copy of the table, until the operation completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a9df6af803f6fb88db88a2c8492bf422359cc7" translate="yes" xml:space="preserve">
          <source>The standard only allows one function to be dropped per command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5dc058e6d69517b035378cc0545a3ff6bbf59c9" translate="yes" xml:space="preserve">
          <source>The standard only allows one procedure to be dropped per command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d079640bb3afa14420ec7729af4881846a5851ac" translate="yes" xml:space="preserve">
          <source>The standard only allows one routine to be dropped per command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6f30578370e30868e083b5faa5f9ddb49a2e7ea" translate="yes" xml:space="preserve">
          <source>The standard requires parentheses around the subquery clause; in PostgreSQL, these parentheses are optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037c9f0273cfeaa62d235fa64430e2ec604be3e9" translate="yes" xml:space="preserve">
          <source>The standard's definition of the behavior of temporary tables is widely ignored. PostgreSQL's behavior on this point is similar to that of several other SQL databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d958124d33ada3ecaa4ecf5cd2414a7d80adeee5" translate="yes" xml:space="preserve">
          <source>The statement subforms and actions available for &lt;code&gt;ALTER MATERIALIZED VIEW&lt;/code&gt; are a subset of those available for &lt;code&gt;ALTER TABLE&lt;/code&gt;, and have the same meaning when used for materialized views. See the descriptions for &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a85ce8c175ffd31b8c2d56822ffccc6660fc62f" translate="yes" xml:space="preserve">
          <source>The statistics collected by &lt;code&gt;ANALYZE&lt;/code&gt; usually include a list of some of the most common values in each column and a histogram showing the approximate data distribution in each column. One or both of these can be omitted if &lt;code&gt;ANALYZE&lt;/code&gt; deems them uninteresting (for example, in a unique-key column, there are no common values) or if the column data type does not support the appropriate operators. There is more information about the statistics in &lt;a href=&quot;https://www.postgresql.org/docs/12/maintenance.html&quot;&gt;Chapter 24&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238068c46fb76fc5b6da5477e8f4ec22c3889848" translate="yes" xml:space="preserve">
          <source>The statistics collector is active during recovery. All scans, reads, blocks, index usage, etc., will be recorded normally on the standby. Replayed actions will not duplicate their effects on primary, so replaying an insert will not increment the Inserts column of pg_stat_user_tables. The stats file is deleted at the start of recovery, so stats from primary and standby will differ; this is considered a feature, not a bug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965711f627243ac89dbb9d9e575eab2acab52658" translate="yes" xml:space="preserve">
          <source>The statistics collector transmits the collected information to other PostgreSQL processes through temporary files. These files are stored in the directory named by the &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; parameter, &lt;code&gt;pg_stat_tmp&lt;/code&gt; by default. For better performance, &lt;code&gt;stats_temp_directory&lt;/code&gt; can be pointed at a RAM-based file system, decreasing physical I/O requirements. When the server shuts down cleanly, a permanent copy of the statistics data is stored in the &lt;code&gt;pg_stat&lt;/code&gt; subdirectory, so that statistics can be retained across server restarts. When recovery is performed at server start (e.g. after immediate shutdown, server crash, and point-in-time recovery), all statistics counters are reset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d31102b772c217f86df5c917a56d333df998b96" translate="yes" xml:space="preserve">
          <source>The statistics gathered by the module are made available via a view named &lt;code&gt;pg_stat_statements&lt;/code&gt;. This view contains one row for each distinct database ID, user ID and query ID (up to the maximum number of distinct statements that the module can track). The columns of the view are shown in &lt;a href=&quot;pgstatstatements#PGSTATSTATEMENTS-COLUMNS&quot;&gt;Table F.21&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d129f0558b07e424e594be75be7478f28f34b280" translate="yes" xml:space="preserve">
          <source>The stop point must be after the ending time of the base backup, i.e., the end time of &lt;code&gt;pg_stop_backup&lt;/code&gt;. You cannot use a base backup to recover to a time when that backup was in progress. (To recover to such a time, you must go back to your previous base backup and roll forward from there.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991a8e15374d6e812a4e43376053e637a59638d9" translate="yes" xml:space="preserve">
          <source>The stopword file format is the same as already explained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a67abf97180ecab3e7785607a17892200ca122a" translate="yes" xml:space="preserve">
          <source>The storage alignment requirement of the data type. If specified, it must be &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;int2&lt;/code&gt;, &lt;code&gt;int4&lt;/code&gt;, or &lt;code&gt;double&lt;/code&gt;; the default is &lt;code&gt;int4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb27d9289cba59d0dbea8d9a256bcf54f4d8f1d" translate="yes" xml:space="preserve">
          <source>The storage requirement for a short string (up to 126 bytes) is 1 byte plus the actual string, which includes the space padding in the case of &lt;code&gt;character&lt;/code&gt;. Longer strings have 4 bytes of overhead instead of 1. Long strings are compressed by the system automatically, so the physical requirement on disk might be less. Very long values are also stored in background tables so that they do not interfere with rapid access to shorter column values. In any case, the longest possible character string that can be stored is about 1 GB. (The maximum value that will be allowed for &lt;code&gt;n&lt;/code&gt; in the data type declaration is less than that. It wouldn't be useful to change this because with multibyte character encodings the number of characters and bytes can be quite different. If you desire to store long strings with no specific upper limit, use &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;character varying&lt;/code&gt; without a length specifier, rather than making up an arbitrary length limit.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d6814e5ec0e1d06f3de3ede9d15794bac11987" translate="yes" xml:space="preserve">
          <source>The storage strategy for the data type. If specified, must be &lt;code&gt;plain&lt;/code&gt;, &lt;code&gt;external&lt;/code&gt;, &lt;code&gt;extended&lt;/code&gt;, or &lt;code&gt;main&lt;/code&gt;; the default is &lt;code&gt;plain&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b76e63a79625e26440cca8d9a00f3887da24e61" translate="yes" xml:space="preserve">
          <source>The stream format is determined by the output plugin specified when the slot was created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19380cfa586d87fdf911b110ff6bf4d13369bdea" translate="yes" xml:space="preserve">
          <source>The string constant can be written using either regular SQL notation or dollar-quoting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84091e9e070956556635627e5454034e5e1ceadb" translate="yes" xml:space="preserve">
          <source>The string constant's text is passed to the input conversion routine for the type called &lt;code&gt;type&lt;/code&gt;. The result is a constant of the indicated type. The explicit type cast can be omitted if there is no ambiguity as to the type the constant must be (for example, when it is assigned directly to a table column), in which case it is automatically coerced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c916cd87a0dd50984ecec5d10546dad9c3284d3a" translate="yes" xml:space="preserve">
          <source>The string must start with a &lt;code&gt;P&lt;/code&gt;, and may include a &lt;code&gt;T&lt;/code&gt; that introduces the time-of-day units. The available unit abbreviations are given in &lt;a href=&quot;datatype-datetime#DATATYPE-INTERVAL-ISO8601-UNITS&quot;&gt;Table 8.16&lt;/a&gt;. Units may be omitted, and may be specified in any order, but units smaller than a day must appear after &lt;code&gt;T&lt;/code&gt;. In particular, the meaning of &lt;code&gt;M&lt;/code&gt; depends on whether it is before or after &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ac1d279bca8c92d106e249d73c9450bd51985a" translate="yes" xml:space="preserve">
          <source>The string used as &lt;code&gt;NAS Identifier&lt;/code&gt; in the RADIUS requests. This parameter can be used as a second parameter identifying for example which database user the user is attempting to authenticate as, which can be used for policy matching on the RADIUS server. If no identifier is specified, the default &lt;code&gt;postgresql&lt;/code&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ee7b9f09ddbdb9488305b75db66d9c52bca23d" translate="yes" xml:space="preserve">
          <source>The string value of an XML element is the concatenation, in document order, of all text nodes contained in that element and its descendants. The string value of an element with no descendant text nodes is an empty string (not &lt;code&gt;NULL&lt;/code&gt;). Any &lt;code&gt;xsi:nil&lt;/code&gt; attributes are ignored. Note that the whitespace-only &lt;code&gt;text()&lt;/code&gt; node between two non-text elements is preserved, and that leading whitespace on a &lt;code&gt;text()&lt;/code&gt; node is not flattened. The XPath 1.0 &lt;code&gt;string&lt;/code&gt; function may be consulted for the rules defining the string value of other XML node types and non-XML values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fec81f56bf595f634fb57f3910c670ede118c7c" translate="yes" xml:space="preserve">
          <source>The string-literal processor removes one level of backslashes, so that what arrives at the composite-value parser looks like &lt;code&gt;(&quot;\&quot;\\&quot;)&lt;/code&gt;. In turn, the string fed to the &lt;code&gt;text&lt;/code&gt; data type's input routine becomes &lt;code&gt;&quot;\&lt;/code&gt;. (If we were working with a data type whose input routine also treated backslashes specially, &lt;code&gt;bytea&lt;/code&gt; for example, we might need as many as eight backslashes in the command to get one backslash into the stored composite field.) Dollar quoting (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;Section 4.1.2.4&lt;/a&gt;) can be used to avoid the need to double backslashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b9c21921311be92ddd5f85cbd74e19f06bfbb6a" translate="yes" xml:space="preserve">
          <source>The structure &lt;code&gt;IndexAmRoutine&lt;/code&gt; is defined thus:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b7ec1adb20c9f7f9468502c9f11469bc8e03f67" translate="yes" xml:space="preserve">
          <source>The structure of a query plan is a tree of &lt;em&gt;plan nodes&lt;/em&gt;. Nodes at the bottom level of the tree are scan nodes: they return raw rows from a table. There are different types of scan nodes for different table access methods: sequential scans, index scans, and bitmap index scans. There are also non-table row sources, such as &lt;code&gt;VALUES&lt;/code&gt; clauses and set-returning functions in &lt;code&gt;FROM&lt;/code&gt;, which have their own scan node types. If the query requires joining, aggregation, sorting, or other operations on the raw rows, then there will be additional nodes above the scan nodes to perform these operations. Again, there is usually more than one possible way to do these operations, so different node types can appear here too. The output of &lt;code&gt;EXPLAIN&lt;/code&gt; has one line for each node in the plan tree, showing the basic node type plus the cost estimates that the planner made for the execution of that plan node. Additional lines might appear, indented from the node's summary line, to show additional properties of the node. The very first line (the summary line for the topmost node) has the estimated total execution cost for the plan; it is this number that the planner seeks to minimize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845e7bd65e68101aeef835121687192ee5165c8e" translate="yes" xml:space="preserve">
          <source>The sub-statements in &lt;code&gt;WITH&lt;/code&gt; are executed concurrently with each other and with the main query. Therefore, when using data-modifying statements in &lt;code&gt;WITH&lt;/code&gt;, the order in which the specified updates actually happen is unpredictable. All the statements are executed with the same &lt;em&gt;snapshot&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;), so they cannot &amp;ldquo;see&amp;rdquo; one another's effects on the target tables. This alleviates the effects of the unpredictability of the actual order of row updates, and means that &lt;code&gt;RETURNING&lt;/code&gt; data is the only way to communicate changes between different &lt;code&gt;WITH&lt;/code&gt; sub-statements and the main query. An example of this is that in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b11dad81d612edf5fd0a4215e04a5d2694b81901" translate="yes" xml:space="preserve">
          <source>The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9047f1ac499137a7641446b4435a2058e7165f8c" translate="yes" xml:space="preserve">
          <source>The subquery must return a single column. If the subquery's output column is of a non-array type, the resulting one-dimensional array will have an element for each row in the subquery result, with an element type matching that of the subquery's output column. If the subquery's output column is of an array type, the result will be an array of the same type but one higher dimension; in this case all the subquery rows must yield arrays of identical dimensionality, else the result would not be rectangular.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad9a65e976a88e8f391a32410934cda1367df45d" translate="yes" xml:space="preserve">
          <source>The subquery will generally only be executed long enough to determine whether at least one row is returned, not all the way to completion. It is unwise to write a subquery that has side effects (such as calling sequence functions); whether the side effects occur might be unpredictable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c9d90ab99dc33425ce7d63877e33bcb6f1a254" translate="yes" xml:space="preserve">
          <source>The subscriber also requires the &lt;code&gt;max_replication_slots&lt;/code&gt; to be set. In this case it should be set to at least the number of subscriptions that will be added to the subscriber. &lt;code&gt;max_logical_replication_workers&lt;/code&gt; must be set to at least the number of subscriptions, again plus some reserve for the table synchronization. Additionally the &lt;code&gt;max_worker_processes&lt;/code&gt; may need to be adjusted to accommodate for replication workers, at least (&lt;code&gt;max_logical_replication_workers&lt;/code&gt; + &lt;code&gt;1&lt;/code&gt;). Note that some extensions and parallel queries also take worker slots from &lt;code&gt;max_worker_processes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5061f785b5ca16b03e284f2d1ce17b7eeda1d830" translate="yes" xml:space="preserve">
          <source>The subscriber database behaves in the same way as any other PostgreSQL instance and can be used as a publisher for other databases by defining its own publications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e109de41793b3722661641499539600ee95867" translate="yes" xml:space="preserve">
          <source>The subscription apply process will run in the local database with the privileges of a superuser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb7abebeb2fd700c8b2ec617037c9667107f4c0" translate="yes" xml:space="preserve">
          <source>The subscription is added using &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt; and can be stopped/resumed at any time using the &lt;a href=&quot;sql-altersubscription&quot;&gt;ALTER SUBSCRIPTION&lt;/a&gt; command and removed using &lt;a href=&quot;sql-dropsubscription&quot;&gt;DROP SUBSCRIPTION&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121044a7fb76fda9e0fbc21177fe11d696a1b02d" translate="yes" xml:space="preserve">
          <source>The subscription represents a replication connection to the publisher. As such this command does not only add definitions in the local catalogs but also creates a replication slot on the publisher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48011fd4928d8a9744bee30b18454a7d53e6f680" translate="yes" xml:space="preserve">
          <source>The subscripts of an array value built with &lt;code&gt;ARRAY&lt;/code&gt; always begin with one. For more information about arrays, see &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2334c3c5a694ddeb266347a848900f44f0cab917" translate="yes" xml:space="preserve">
          <source>The summarizing structure is bound in size by &lt;code&gt;maintenance_work_mem&lt;/code&gt;. In order to ensure that there is no more than a 2% probability of failure to detect an inconsistency for each heap tuple that should be represented in the index, approximately 2 bytes of memory are needed per tuple. As less memory is made available per tuple, the probability of missing an inconsistency slowly increases. This approach limits the overhead of verification significantly, while only slightly reducing the probability of detecting a problem, especially for installations where verification is treated as a routine maintenance task. Any single absent or malformed tuple has a new opportunity to be detected with each new verification attempt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2efac8a5cca33663d7c228751b90df82bafbc8" translate="yes" xml:space="preserve">
          <source>The switch file &lt;code&gt;/var/lib/pgsql/backup_in_progress&lt;/code&gt; is created first, enabling archiving of completed WAL files to occur. After the backup the switch file is removed. Archived WAL files are then added to the backup so that both base backup and all required WAL files are part of the same tar file. Please remember to add error handling to your backup scripts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87700f6e1446d98115cf77b5305bf6c280312a5f" translate="yes" xml:space="preserve">
          <source>The symbol shown in the column &amp;ldquo;Condition Name&amp;rdquo; is the condition name to use in PL/pgSQL. Condition names can be written in either upper or lower case. (Note that PL/pgSQL does not recognize warning, as opposed to error, condition names; those are classes 00, 01, and 02.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2af0e19179d988e1c5bb09182f6b8329bf33d2" translate="yes" xml:space="preserve">
          <source>The synchronization workers are taken from the pool defined by &lt;code&gt;max_logical_replication_workers&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ff2f915045408cc48aad6178d8c49b4353ee6d4" translate="yes" xml:space="preserve">
          <source>The synchronous states of standby servers can be viewed using the &lt;code&gt;pg_stat_replication&lt;/code&gt; view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8f8b505ce05315e1a17e36787d4eec3e6ea7c76" translate="yes" xml:space="preserve">
          <source>The syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f181461d9c844d09a197734c97365af11fec6c2" translate="yes" xml:space="preserve">
          <source>The syntax for &lt;code&gt;CREATE TABLE&lt;/code&gt; allows the exact size of arrays to be specified, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="966dbee44492fe4c1ad689fb4503c9e542bc2d3e" translate="yes" xml:space="preserve">
          <source>The syntax for a function call is the name of a function (possibly qualified with a schema name), followed by its argument list enclosed in parentheses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9827946ae401eb6c51ab3afdb1c21f5055ada0b5" translate="yes" xml:space="preserve">
          <source>The syntax for ordered-set aggregates allows &lt;code&gt;VARIADIC&lt;/code&gt; to be specified for both the last direct parameter and the last aggregated (&lt;code&gt;WITHIN GROUP&lt;/code&gt;) parameter. However, the current implementation restricts use of &lt;code&gt;VARIADIC&lt;/code&gt; in two ways. First, ordered-set aggregates can only use &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt;, not other variadic array types. Second, if the last direct parameter is &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt;, then there can be only one aggregated parameter and it must also be &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt;. (In the representation used in the system catalogs, these two parameters are merged into a single &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; item, since &lt;code&gt;pg_proc&lt;/code&gt; cannot represent functions with more than one &lt;code&gt;VARIADIC&lt;/code&gt; parameter.) If the aggregate is a hypothetical-set aggregate, the direct arguments that match the &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; parameter are the hypothetical ones; any preceding parameters represent additional direct arguments that are not constrained to match the aggregated arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d86a8075f285a9e5f082a7c58f078a97fe87d56b" translate="yes" xml:space="preserve">
          <source>The syntax is comparable to &lt;code&gt;CREATE TABLE&lt;/code&gt;, except that only field names and types can be specified; no constraints (such as &lt;code&gt;NOT NULL&lt;/code&gt;) can presently be included. Note that the &lt;code&gt;AS&lt;/code&gt; keyword is essential; without it, the system will think a different kind of &lt;code&gt;CREATE TYPE&lt;/code&gt; command is meant, and you will get odd syntax errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c058b9d6546225c3baf16e3e4b8ff07bce7ea0" translate="yes" xml:space="preserve">
          <source>The syntax of constants for the numeric types is described in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;Section 4.1.2&lt;/a&gt;. The numeric types have a full set of corresponding arithmetic operators and functions. Refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt; for more information. The following sections describe the types in detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3602bbafe5a0054bbc62eb9c26f3d0a2eca852d1" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;&lt;code&gt;WHERE&lt;/code&gt; Clause&lt;/a&gt; is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8203a94af84f4e0e580fcba3501f0b24c27a5840" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;code&gt;CREATE INDEX&lt;/code&gt; command normally requires writing parentheses around index expressions, as shown in the second example. The parentheses can be omitted when the expression is just a function call, as in the first example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c241abd813b7161dcc7e86ad91e10959de152091" translate="yes" xml:space="preserve">
          <source>The syntax of this command is similar to that of the SQL &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; command. All options other than the data source/destination are as specified for &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;. Because of this, special parsing rules apply to the &lt;code&gt;\copy&lt;/code&gt; meta-command. Unlike most other meta-commands, the entire remainder of the line is always taken to be the arguments of &lt;code&gt;\copy&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8d680d5b62b13099c9e19bc923e563b07e6d19" translate="yes" xml:space="preserve">
          <source>The syntax used so far requires you to remember the order of the columns. An alternative syntax allows you to list the columns explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033030a62bda22a5de4a5aeea859f2505dc5e730" translate="yes" xml:space="preserve">
          <source>The syntax with &lt;code&gt;ORDER BY&lt;/code&gt; in the parameter list creates a special type of aggregate called an &lt;em&gt;ordered-set aggregate&lt;/em&gt;; or if &lt;code&gt;HYPOTHETICAL&lt;/code&gt; is specified, then a &lt;em&gt;hypothetical-set aggregate&lt;/em&gt; is created. These aggregates operate over groups of sorted values in order-dependent ways, so that specification of an input sort order is an essential part of a call. Also, they can have &lt;em&gt;direct&lt;/em&gt; arguments, which are arguments that are evaluated only once per aggregation rather than once per input row. Hypothetical-set aggregates are a subclass of ordered-set aggregates in which some of the direct arguments are required to match, in number and data types, the aggregated argument columns. This allows the values of those direct arguments to be added to the collection of aggregate-input rows as an additional &amp;ldquo;hypothetical&amp;rdquo; row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3670cc6e37bfe2baa6c265184cfb9070b0da0ca9" translate="yes" xml:space="preserve">
          <source>The syntaxes using &lt;code&gt;*&lt;/code&gt; are used for calling parameter-less aggregate functions as window functions, for example &lt;code&gt;count(*) OVER (PARTITION BY x ORDER BY y)&lt;/code&gt;. The asterisk (&lt;code&gt;*&lt;/code&gt;) is customarily not used for window-specific functions. Window-specific functions do not allow &lt;code&gt;DISTINCT&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; to be used within the function argument list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5413e5588ef7474b4153013c25aed37daf2b6ac4" translate="yes" xml:space="preserve">
          <source>The system catalog &lt;code&gt;pg_language&lt;/code&gt; (see &lt;a href=&quot;catalog-pg-language&quot;&gt;Section 51.29&lt;/a&gt;) records information about the currently installed languages. Also, the psql command &lt;code&gt;\dL&lt;/code&gt; lists the installed languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2583bf948cb2199416aaa963439f3392af0c4543" translate="yes" xml:space="preserve">
          <source>The system catalog cache code (and most catalog-munging code in general) assumes that the fixed-length portions of all system catalog tuples are in fact present, because it maps this C struct declaration onto them. Thus, all variable-length fields and nullable fields must be placed at the end, and they cannot be accessed as struct fields. For example, if you tried to set &lt;code&gt;pg_type&lt;/code&gt;.&lt;code&gt;typrelid&lt;/code&gt; to be NULL, it would fail when some piece of code tried to reference &lt;code&gt;typetup-&amp;gt;typrelid&lt;/code&gt; (or worse, &lt;code&gt;typetup-&amp;gt;typelem&lt;/code&gt;, because that follows &lt;code&gt;typrelid&lt;/code&gt;). This would result in random errors or even segmentation violations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb485f21372d37054b0b92886fc6889e8d0f2f48" translate="yes" xml:space="preserve">
          <source>The system catalog schema, &lt;code&gt;pg_catalog&lt;/code&gt;, is always searched, whether it is mentioned in the path or not. If it is mentioned in the path then it will be searched in the specified order. If &lt;code&gt;pg_catalog&lt;/code&gt; is not in the path then it will be searched &lt;em&gt;before&lt;/em&gt; searching any of the path items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dffb9af79cadde8378337d566688f00f092c9630" translate="yes" xml:space="preserve">
          <source>The system catalogs store information about which conversions, or &lt;em&gt;casts&lt;/em&gt;, exist between which data types, and how to perform those conversions. Additional casts can be added by the user with the &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt; command. (This is usually done in conjunction with defining new data types. The set of casts between built-in types has been carefully crafted and is best not altered.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94541a873b2d451108de2b46c0592e4902bdbb36" translate="yes" xml:space="preserve">
          <source>The system uses no more than &lt;code&gt;NAMEDATALEN&lt;/code&gt;-1 bytes of an identifier; longer names can be written in commands, but they will be truncated. By default, &lt;code&gt;NAMEDATALEN&lt;/code&gt; is 64 so the maximum identifier length is 63 bytes. If this limit is problematic, it can be raised by changing the &lt;code&gt;NAMEDATALEN&lt;/code&gt; constant in &lt;code&gt;src/include/pg_config_manual.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18aee9967e71bb22ca6c7ef97d956490785417e5" translate="yes" xml:space="preserve">
          <source>The system view &lt;a href=&quot;view-pg-file-settings&quot;&gt;&lt;code&gt;pg_file_settings&lt;/code&gt;&lt;/a&gt; can be helpful for pre-testing changes to the configuration files, or for diagnosing problems if a SIGHUP signal did not have the desired effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51af27f0b42d0a59cf04312463422fdaffc06293" translate="yes" xml:space="preserve">
          <source>The system view &lt;a href=&quot;view-pg-hba-file-rules&quot;&gt;&lt;code&gt;pg_hba_file_rules&lt;/code&gt;&lt;/a&gt; can be helpful for pre-testing changes to the &lt;code&gt;pg_hba.conf&lt;/code&gt; file, or for diagnosing problems if loading of the file did not have the desired effects. Rows in the view with non-null &lt;code&gt;error&lt;/code&gt; fields indicate problems in the corresponding lines of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d1a0c3c602b5e69816adbc6a5f72656d7deb220" translate="yes" xml:space="preserve">
          <source>The system-wide startup file is named &lt;code&gt;psqlrc&lt;/code&gt; and is sought in the installation's &amp;ldquo;system configuration&amp;rdquo; directory, which is most reliably identified by running &lt;code&gt;pg_config --sysconfdir&lt;/code&gt;. By default this directory will be &lt;code&gt;../etc/&lt;/code&gt; relative to the directory containing the PostgreSQL executables. The name of this directory can be set explicitly via the &lt;code&gt;PGSYSCONFDIR&lt;/code&gt; environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9987d6e81d602450ad224137a711661462f4308" translate="yes" xml:space="preserve">
          <source>The table also shows that PostgreSQL's Repeatable Read implementation does not allow phantom reads. Stricter behavior is permitted by the SQL standard: the four isolation levels only define which phenomena must not happen, not which phenomena &lt;em&gt;must&lt;/em&gt; happen. The behavior of the available isolation levels is detailed in the following subsections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="142b69e02a67de00ba841f641f5ef3fa34a277d2" translate="yes" xml:space="preserve">
          <source>The table definition above includes a primary key specification. This is useful to protect against accidentally importing the same information twice. The &lt;code&gt;COPY&lt;/code&gt; command commits all of the data it imports at one time, so any error will cause the entire import to fail. If you import a partial log file and later import the file again when it is complete, the primary key violation will cause the import to fail. Wait until the log is complete and closed before importing. This procedure will also protect against accidentally importing a partial line that hasn't been completely written, which would also cause &lt;code&gt;COPY&lt;/code&gt; to fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b15dacbb7afc519b6433f93ec4919614f65b399" translate="yes" xml:space="preserve">
          <source>The table is partitioned by explicitly listing which key values appear in each partition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b51488835cbb40ee5da1ee3d9a8f7864d4b57976" translate="yes" xml:space="preserve">
          <source>The table is partitioned by specifying a modulus and a remainder for each partition. Each partition will hold the rows for which the hash value of the partition key divided by the specified modulus will produce the specified remainder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5e839b9bae27b38d6af54b60ca56e0b347f0f2" translate="yes" xml:space="preserve">
          <source>The table is partitioned into &amp;ldquo;ranges&amp;rdquo; defined by a key column or set of columns, with no overlap between the ranges of values assigned to different partitions. For example, one might partition by date ranges, or by ranges of identifiers for particular business objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="292e8b677c187c4d68b1ebe250d22a32e9af8561" translate="yes" xml:space="preserve">
          <source>The table or index that the described column belongs to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d142b3cf8f5a90793004bbdd69de61322293bd63" translate="yes" xml:space="preserve">
          <source>The table referenced by a referential integrity constraint</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8191ca3a1df3ed6d1e85b59a92238d8c6f7d14" translate="yes" xml:space="preserve">
          <source>The table this column belongs to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75cfe910e753a5d9a7438e22a49cad2342942a50" translate="yes" xml:space="preserve">
          <source>The table this constraint is on; 0 if not a table constraint</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f088db11eed75527c26721e5e66e62e0678aeb6" translate="yes" xml:space="preserve">
          <source>The table this rule is for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac24dc8d3f1364ef3223d38811cd0f1cdfc7bc70" translate="yes" xml:space="preserve">
          <source>The table this trigger is on</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d2364aa6d119df4f431f30d6909fa91ae4a412" translate="yes" xml:space="preserve">
          <source>The table to which the policy applies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="539b9dae513896d5721c3d82785ae25ab4799ccf" translate="yes" xml:space="preserve">
          <source>The tables added to a publication that publishes &lt;code&gt;UPDATE&lt;/code&gt; and/or &lt;code&gt;DELETE&lt;/code&gt; operations must have &lt;code&gt;REPLICA IDENTITY&lt;/code&gt; defined. Otherwise those operations will be disallowed on those tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="367460ef7d1ca64d14464409850a0a51a7ab7dc7" translate="yes" xml:space="preserve">
          <source>The tables are matched between the publisher and the subscriber using the fully qualified table name. Replication to differently-named tables on the subscriber is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c0314798fd15f5ed903ef71976f9e615a0bb52" translate="yes" xml:space="preserve">
          <source>The tablespace associated with a database is used to store the system catalogs of that database. Furthermore, it is the default tablespace used for tables, indexes, and temporary files created within the database, if no &lt;code&gt;TABLESPACE&lt;/code&gt; clause is given and no other selection is specified by &lt;code&gt;default_tablespace&lt;/code&gt; or &lt;code&gt;temp_tablespaces&lt;/code&gt; (as appropriate). If a database is created without specifying a tablespace for it, it uses the same tablespace as the template database it is copied from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0a83e9744372d73f37f6c31fa32edd33e0f557" translate="yes" xml:space="preserve">
          <source>The tablespace in which this relation is stored. If zero, the database's default tablespace is implied. (Not meaningful if the relation has no on-disk file.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91ace69fa784c06e03e2d35b1b8ec1909d7a7501" translate="yes" xml:space="preserve">
          <source>The tablespace in which to create the index. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted, or &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; for indexes on temporary tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6945a89a0355036aac3b6ff63ff9fc68b1cb28a4" translate="yes" xml:space="preserve">
          <source>The tablespace to which the index will be moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fdf7a817dfba5e9f0aef01d7a04fe1bad9896f5" translate="yes" xml:space="preserve">
          <source>The tag, if any, of a dollar-quoted string follows the same rules as an unquoted identifier, except that it cannot contain a dollar sign. Tags are case sensitive, so &lt;code&gt;$tag$String content$tag$&lt;/code&gt; is correct, but &lt;code&gt;$TAG$String content$tag$&lt;/code&gt; is not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bef8aba7a1bcf650d04e76e3a3595346989e8039" translate="yes" xml:space="preserve">
          <source>The target column names can be listed in any order. If no list of column names is given at all, the default is all the columns of the table in their declared order; or the first &lt;code&gt;N&lt;/code&gt; column names, if there are only &lt;code&gt;N&lt;/code&gt; columns supplied by the &lt;code&gt;VALUES&lt;/code&gt; clause or &lt;code&gt;query&lt;/code&gt;. The values supplied by the &lt;code&gt;VALUES&lt;/code&gt; clause or &lt;code&gt;query&lt;/code&gt; are associated with the explicit or implicit column list left-to-right.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a52fa4d647d2a0e534fa04140c4a0531834e1437" translate="yes" xml:space="preserve">
          <source>The target function can be specified by name alone, or by name and arguments, for example &lt;code&gt;foo(integer, text)&lt;/code&gt;. The argument types must be given if there is more than one function of the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a83f3ee2747bb5a0ebf49f8f4cc7233f65fe3b6" translate="yes" xml:space="preserve">
          <source>The task of the &lt;em&gt;planner/optimizer&lt;/em&gt; is to create an optimal execution plan. A given SQL query (and hence, a query tree) can be actually executed in a wide variety of different ways, each of which will produce the same set of results. If it is computationally feasible, the query optimizer will examine each of these possible execution plans, ultimately selecting the execution plan that is expected to run the fastest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0cfcd2522974bd11b7e720b66ddba5e0dc99d8f" translate="yes" xml:space="preserve">
          <source>The technical difference between a &lt;code&gt;jsonb_ops&lt;/code&gt; and a &lt;code&gt;jsonb_path_ops&lt;/code&gt; GIN index is that the former creates independent index items for each key and value in the data, while the latter creates index items only for each value in the data. &lt;a href=&quot;#ftn.id-1.5.7.22.18.9.3&quot;&gt;&lt;sup id=&quot;id-1.5.7.22.18.9.3&quot;&gt;[6]&lt;/sup&gt;&lt;/a&gt; Basically, each &lt;code&gt;jsonb_path_ops&lt;/code&gt; index item is a hash of the value and the key(s) leading to it; for example to index &lt;code&gt;{&quot;foo&quot;: {&quot;bar&quot;: &quot;baz&quot;}}&lt;/code&gt;, a single index item would be created incorporating all three of &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt; into the hash value. Thus a containment query looking for this structure would result in an extremely specific index search; but there is no way at all to find out whether &lt;code&gt;foo&lt;/code&gt; appears as a key. On the other hand, a &lt;code&gt;jsonb_ops&lt;/code&gt; index would create three index items representing &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt; separately; then to do the containment query, it would look for rows containing all three of these items. While GIN indexes can perform such an AND search fairly efficiently, it will still be less specific and slower than the equivalent &lt;code&gt;jsonb_path_ops&lt;/code&gt; search, especially if there are a very large number of rows containing any single one of the three index items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8f7bc59665b224be12f558ca16a9e07627bb77" translate="yes" xml:space="preserve">
          <source>The temporary table will be dropped at the end of the current transaction block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e88ee252852e295414cf3850a24be66c227bee2" translate="yes" xml:space="preserve">
          <source>The temporary table will be dropped at the end of the current transaction block. When used on a partitioned table, this action drops its partitions and when used on tables with inheritance children, it drops the dependent children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="544789fd88fe85a89dc95a84868e683fa382498a" translate="yes" xml:space="preserve">
          <source>The term attribute is equivalent to column and is used for historical reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4a7c2d2771e24236d6f1bdd6761fd668754e8bc" translate="yes" xml:space="preserve">
          <source>The text representation of an &lt;code&gt;hstore&lt;/code&gt;, used for input and output, includes zero or more &lt;code&gt;key&lt;/code&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; pairs separated by commas. Some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a0a387ebcc73eb1a002f76f9873cf6168a1347" translate="yes" xml:space="preserve">
          <source>The text-search functionality in PostgreSQL can also be used to speed up full-document searches of XML data. The necessary preprocessing support is, however, not yet available in the PostgreSQL distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9535cead63cebae1ff29d54da604a76ade0e73e1" translate="yes" xml:space="preserve">
          <source>The textual label for this enum value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d79225bbaf1bc36cb45016180fd38042b31a872" translate="yes" xml:space="preserve">
          <source>The thesaurus dictionary &lt;code&gt;thesaurus_astro&lt;/code&gt; does know the phrase &lt;code&gt;supernovae stars&lt;/code&gt;, but &lt;code&gt;ts_lexize&lt;/code&gt; fails since it does not parse the input text but treats it as a single token. Use &lt;code&gt;plainto_tsquery&lt;/code&gt; or &lt;code&gt;to_tsvector&lt;/code&gt; to test thesaurus dictionaries, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="497ebaef7c7bb30921967269b6dd4bfd06472628" translate="yes" xml:space="preserve">
          <source>The thesaurus dictionary chooses the longest match if there are multiple phrases matching the input, and ties are broken by using the last definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6384b1615ea61227de680b163bce3c7f613d4849" translate="yes" xml:space="preserve">
          <source>The third form changes the owner of the database. To alter the owner, you must own the database and also be a direct or indirect member of the new owning role, and you must have the &lt;code&gt;CREATEDB&lt;/code&gt; privilege. (Note that superusers have all these privileges automatically.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3a4f1cf7c17f675b6c88c65b759e2c18503d10" translate="yes" xml:space="preserve">
          <source>The third form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates a new range type, as described in &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e5d7ec29a414875ddb7427a1366569e134347d" translate="yes" xml:space="preserve">
          <source>The third parameter being &lt;code&gt;false&lt;/code&gt; tells &lt;code&gt;pg_start_backup&lt;/code&gt; to initiate a non-exclusive base backup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43c4f141a3275bbc30bab46035e573f420cd4242" translate="yes" xml:space="preserve">
          <source>The third syntax was used before PostgreSQL version 9.6 and is still supported. It's the same as the first syntax with &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;num_sync&lt;/code&gt; equal to 1. For example, &lt;code&gt;FIRST 1 (s1, s2)&lt;/code&gt; and &lt;code&gt;s1, s2&lt;/code&gt; have the same meaning: either &lt;code&gt;s1&lt;/code&gt; or &lt;code&gt;s2&lt;/code&gt; is chosen as a synchronous standby.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bce8828bcc021e862db732b17b8f2b754b34f3cc" translate="yes" xml:space="preserve">
          <source>The third variant changes the name of the group. This is exactly equivalent to renaming the role with &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d943d4346301a5cf1de51eecfb3a352a414893" translate="yes" xml:space="preserve">
          <source>The time at which the cursor was declared</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec4185f356c4ef6086071a2e178362bf4f8c1b5e" translate="yes" xml:space="preserve">
          <source>The time at which the prepared statement was created</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0e8bb2f344559ea1d916061668ce3e9aa5b7836" translate="yes" xml:space="preserve">
          <source>The time zone 7 hours west from UTC (equivalent to PDT). Positive values are east from UTC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee80f641d8eab20953a3190cfb6422152c737dea" translate="yes" xml:space="preserve">
          <source>The time zone 8 hours west from UTC (equivalent to PST).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d03995667dbda87e63122260f5c6f6cb9fe649a" translate="yes" xml:space="preserve">
          <source>The time zone for Berkeley, California.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="668f3cdec134bede84a934a9af41142895f7b007" translate="yes" xml:space="preserve">
          <source>The time zone for Italy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ed4ff2c6ce4f9a9cd61b96f6374cf02812e246" translate="yes" xml:space="preserve">
          <source>The time zone offset from UTC, measured in seconds. Positive values correspond to time zones east of UTC, negative values to zones west of UTC. (Technically, PostgreSQL does not use UTC because leap seconds are not handled.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca5243d8e51420e24c77cdd1c3e577fee34053c" translate="yes" xml:space="preserve">
          <source>The time-of-day types are &lt;code&gt;time [ (p) ] without time zone&lt;/code&gt; and &lt;code&gt;time [ (p) ] with time zone&lt;/code&gt;. &lt;code&gt;time&lt;/code&gt; alone is equivalent to &lt;code&gt;time without time zone&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41de03730261b036dd783f63ba08317d9d3e641d" translate="yes" xml:space="preserve">
          <source>The timeout is measured from the time a command arrives at the server until it is completed by the server. In extended query protocol, the timeout starts running when any query-related message (Parse, Bind, Execute, Describe) arrives, and it is cancelled by completion of an Execute or Sync message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98b14f1fa1ca6a1d2cfd5fbd83b532ce899e731" translate="yes" xml:space="preserve">
          <source>The toast_tuple_target specifies the minimum tuple length required before we try to move long column values into TOAST tables, and is also the target length we try to reduce the length below once toasting begins. This only affects columns marked as either External or Extended and applies only to new tuples - there is no effect on existing rows. By default this parameter is set to allow at least 4 tuples per block, which with the default blocksize will be 2040 bytes. Valid values are between 128 bytes and the (blocksize - header), by default 8160 bytes. Changing this value may not be useful for very short or very long rows. Note that the default setting is often close to optimal, and it is possible that setting this parameter could have negative effects in some cases. This parameter cannot be set for TOAST tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="621d22a0cd204d89633ad09943ee84f1181db01e" translate="yes" xml:space="preserve">
          <source>The total number of columns in the index (duplicates &lt;code&gt;pg_class.relnatts&lt;/code&gt;); this number includes both key and included attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f560f36dfc9d943beeddde2257c0e1b305d7ee85" translate="yes" xml:space="preserve">
          <source>The transaction ID epoch is not actually stored anywhere in the database except in the field that is set by &lt;code&gt;pg_resetwal&lt;/code&gt;, so any value will work so far as the database itself is concerned. You might need to adjust this value to ensure that replication systems such as Slony-I and Skytools work correctly &amp;mdash; if so, an appropriate value should be obtainable from the state of the downstream replicated database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3634c8a4a4ce9f542309bb5a4cc86011569d07" translate="yes" xml:space="preserve">
          <source>The transaction access mode determines whether the transaction is read/write or read-only. Read/write is the default. When a transaction is read-only, the following SQL commands are disallowed: &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;COPY FROM&lt;/code&gt; if the table they would write to is not a temporary table; all &lt;code&gt;CREATE&lt;/code&gt;, &lt;code&gt;ALTER&lt;/code&gt;, and &lt;code&gt;DROP&lt;/code&gt; commands; &lt;code&gt;COMMENT&lt;/code&gt;, &lt;code&gt;GRANT&lt;/code&gt;, &lt;code&gt;REVOKE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;; and &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; and &lt;code&gt;EXECUTE&lt;/code&gt; if the command they would execute is among those listed. This is a high-level notion of read-only that does not prevent all writes to disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75f4c782782aa478238329da73889aa36680137b" translate="yes" xml:space="preserve">
          <source>The transaction identifier of the transaction that is to be committed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf987258f7d6ba8e2728a7ab480e418085360e38" translate="yes" xml:space="preserve">
          <source>The transaction identifier of the transaction that is to be rolled back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eeef0c349968aef779233f9f813d33249bc7a83" translate="yes" xml:space="preserve">
          <source>The transaction isolation level cannot be changed after the first query or data-modification statement (&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt;, or &lt;code&gt;COPY&lt;/code&gt;) of a transaction has been executed. See &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more information about transaction isolation and concurrency control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed3fff67b302c5509e4a3c68f6d878b34bcf063e" translate="yes" xml:space="preserve">
          <source>The transactional behavior of &lt;code&gt;RESET&lt;/code&gt; is the same as &lt;code&gt;SET&lt;/code&gt;: its effects will be undone by transaction rollback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75001c08db137e17c60a1922c998f38549cfd962" translate="yes" xml:space="preserve">
          <source>The translations from internal enum values to textual labels are kept in the system catalog &lt;a href=&quot;catalog-pg-enum&quot;&gt;&lt;code&gt;pg_enum&lt;/code&gt;&lt;/a&gt;. Querying this catalog directly can be useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d50a1ac1c4a79cbe553bfb51786402f941c2b3ba" translate="yes" xml:space="preserve">
          <source>The trigger can be specified to fire before the operation is attempted on a row (before constraints are checked and the &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; is attempted); or after the operation has completed (after constraints are checked and the &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; has completed); or instead of the operation (in the case of inserts, updates or deletes on a view). If the trigger fires before or instead of the event, the trigger can skip the operation for the current row, or change the row being inserted (for &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; operations only). If the trigger fires after the event, all changes, including the effects of other triggers, are &amp;ldquo;visible&amp;rdquo; to the trigger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360ddad9a8de88b17738a1bfb31175dc0ad50509" translate="yes" xml:space="preserve">
          <source>The trigger definition is the same as before. Note that each &lt;code&gt;IF&lt;/code&gt; test must exactly match the &lt;code&gt;CHECK&lt;/code&gt; constraint for its child table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a810fcfc0902003d265053e230960c8ff8fc873c" translate="yes" xml:space="preserve">
          <source>The trigger firing mechanism is also affected by the configuration variable &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt;. Simply enabled triggers (the default) will fire when the replication role is &amp;ldquo;origin&amp;rdquo; (the default) or &amp;ldquo;local&amp;rdquo;. Triggers configured as &lt;code&gt;ENABLE REPLICA&lt;/code&gt; will only fire if the session is in &amp;ldquo;replica&amp;rdquo; mode, and triggers configured as &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; will fire regardless of the current replication role.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f53bb9473c53f31ec2630d134ac2ab3b419880a" translate="yes" xml:space="preserve">
          <source>The trigger will only fire if at least one of the listed columns is mentioned as a target of the &lt;code&gt;UPDATE&lt;/code&gt; command or if one of the listed columns is a generated column that depends on a column that is the target of the &lt;code&gt;UPDATE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33dc8fc66a104f662e1e1ef39564cf253e0b3d0e" translate="yes" xml:space="preserve">
          <source>The two characters must be separated by whitespace, and any leading or trailing whitespace on a line is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e9af5cad39e06c0aff7fc7950d58905fea1d7b" translate="yes" xml:space="preserve">
          <source>The two common uses of the &lt;code&gt;COLLATE&lt;/code&gt; clause are overriding the sort order in an &lt;code&gt;ORDER BY&lt;/code&gt; clause, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a38d5de3cd4f9280a434f729b41435ab278e27" translate="yes" xml:space="preserve">
          <source>The two ranking functions currently available are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce8dc1c8a536536645752666f7fffe721ce60a13" translate="yes" xml:space="preserve">
          <source>The two-parameter form of &lt;code&gt;obj_description&lt;/code&gt; returns the comment for a database object specified by its OID and the name of the containing system catalog. For example, &lt;code&gt;obj_description(123456,'pg_class')&lt;/code&gt; would retrieve the comment for the table with OID 123456. The one-parameter form of &lt;code&gt;obj_description&lt;/code&gt; requires only the object OID. It is deprecated since there is no guarantee that OIDs are unique across different system catalogs; therefore, the wrong comment might be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4f339ae3cabb76936eb748863a60863a4f4f72e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;integer&lt;/code&gt; is the common choice, as it offers the best balance between range, storage size, and performance. The &lt;code&gt;smallint&lt;/code&gt; type is generally only used if disk space is at a premium. The &lt;code&gt;bigint&lt;/code&gt; type is designed to be used when the range of the &lt;code&gt;integer&lt;/code&gt; type is insufficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73f1593ff9d450e1b3a9d9ecf07b14639511ab2d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;numeric&lt;/code&gt; can store numbers with a very large number of digits. It is especially recommended for storing monetary amounts and other quantities where exactness is required. Calculations with &lt;code&gt;numeric&lt;/code&gt; values yield exact results where possible, e.g. addition, subtraction, multiplication. However, calculations on &lt;code&gt;numeric&lt;/code&gt; values are very slow compared to the integer types, or to the floating-point types described in the next section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793233ae84eec2944804278e0981414a3f21b17d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;time with time zone&lt;/code&gt; is defined by the SQL standard, but the definition exhibits properties which lead to questionable usefulness. In most cases, a combination of &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamp without time zone&lt;/code&gt;, and &lt;code&gt;timestamp with time zone&lt;/code&gt; should provide a complete range of date/time functionality required by any application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7b02ae1d94b05c4445fedeab1d5ea2204949c69" translate="yes" xml:space="preserve">
          <source>The type being created is an array; this specifies the type of the array elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec7ae5dcf41bac97c38ef83c552012b75a666d1" translate="yes" xml:space="preserve">
          <source>The type names &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;serial4&lt;/code&gt; are equivalent: both create &lt;code&gt;integer&lt;/code&gt; columns. The type names &lt;code&gt;bigserial&lt;/code&gt; and &lt;code&gt;serial8&lt;/code&gt; work the same way, except that they create a &lt;code&gt;bigint&lt;/code&gt; column. &lt;code&gt;bigserial&lt;/code&gt; should be used if you anticipate the use of more than 2&lt;sup&gt;31&lt;/sup&gt; identifiers over the lifetime of the table. The type names &lt;code&gt;smallserial&lt;/code&gt; and &lt;code&gt;serial2&lt;/code&gt; also work the same way, except that they create a &lt;code&gt;smallint&lt;/code&gt; column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe751081daba63125cfc111c4d7f7c5219b07dce" translate="yes" xml:space="preserve">
          <source>The type of a column is referenced by writing &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ea7f76717a65c02b1bddcb00950b7e9f4876d9" translate="yes" xml:space="preserve">
          <source>The type of a column is referenced by writing &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt;. Using this feature can sometimes help make a function independent of changes to the definition of a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ec982d03e7790491fadba1642490dfd8fdc55a" translate="yes" xml:space="preserve">
          <source>The type of a column is referenced by writing &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt;. Using this feature can sometimes help make a procedure independent of changes to the definition of a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e103307ad05526fdabd013a4e01ed05bfdbdb7" translate="yes" xml:space="preserve">
          <source>The type of event for which the backend is waiting, if any; otherwise NULL. Possible values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f9f096a38b6430fd5ddb4a740ecb24f54b601d1" translate="yes" xml:space="preserve">
          <source>The type of format conversion to use to produce the format specifier's output. The following types are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ddd9e551f2a05479f6513f5110e44168eae5ec3" translate="yes" xml:space="preserve">
          <source>The type of object to which this label applies, as text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0efbb84b508511a8c55e93462baf31f477709c2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;decimal&lt;/code&gt; and &lt;code&gt;numeric&lt;/code&gt; are equivalent. Both types are part of the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="929117e51025410290ad9a3ec11af66ca11a1c9b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt; store whole numbers, that is, numbers without fractional components, of various ranges. Attempts to store values outside of the allowed range will result in an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f88d1600c2fa8cf210ddde6767edf800fcc4b8ae" translate="yes" xml:space="preserve">
          <source>The unallocated space. New item identifiers are allocated from the start of this area, new items from the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6ac986319e3f5efca56837ce99d1572cef0217f" translate="yes" xml:space="preserve">
          <source>The underlying data type of the domain. This can include array specifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d964b1947580871a9afde80dd70168c2a16dc4" translate="yes" xml:space="preserve">
          <source>The union and difference operators will fail if the resulting range would need to contain two disjoint sub-ranges, as such a range cannot be represented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50b30c7a19cffa1de56e373435e89e8ef50ced95" translate="yes" xml:space="preserve">
          <source>The units kB, MB, GB and TB used by the functions &lt;code&gt;pg_size_pretty&lt;/code&gt; and &lt;code&gt;pg_size_bytes&lt;/code&gt; are defined using powers of 2 rather than powers of 10, so 1kB is 1024 bytes, 1MB is 1024&lt;sup&gt;2&lt;/sup&gt; = 1048576 bytes, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ae2c5b2eeaa2e69e79b5cb262b5458e41e3c91" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;=&amp;gt;&lt;/code&gt; as an operator name is deprecated. It may be disallowed altogether in a future release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c091c993d1f380ee067cec46b15b6ee688b73b" translate="yes" xml:space="preserve">
          <source>The use of explicit locking can increase the likelihood of &lt;em&gt;deadlocks&lt;/em&gt;, wherein two (or more) transactions each hold locks that the other wants. For example, if transaction 1 acquires an exclusive lock on table A and then tries to acquire an exclusive lock on table B, while transaction 2 has already exclusive-locked table B and now wants an exclusive lock on table A, then neither one can proceed. PostgreSQL automatically detects deadlock situations and resolves them by aborting one of the transactions involved, allowing the other(s) to complete. (Exactly which transaction will be aborted is difficult to predict and should not be relied upon.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f0b3f4b5acb7da25097931a18b8f5ac621923d3" translate="yes" xml:space="preserve">
          <source>The use of huge pages results in smaller page tables and less CPU time spent on memory management, increasing performance. For more details about using huge pages on Linux, see &lt;a href=&quot;kernel-resources#LINUX-HUGE-PAGES&quot;&gt;Section 18.4.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce63f397bb5d8284bad24ef82b2459f7b090249" translate="yes" xml:space="preserve">
          <source>The use of this option is obsolete; all command-line options for server processes can be specified directly on the &lt;code&gt;postgres&lt;/code&gt; command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09cf7166a8b226caae95159176b66ea236b91cf0" translate="yes" xml:space="preserve">
          <source>The user can select the commit mode of each transaction, so that it is possible to have both synchronous and asynchronous commit transactions running concurrently. This allows flexible trade-offs between performance and certainty of transaction durability. The commit mode is controlled by the user-settable parameter &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt;, which can be changed in any of the ways that a configuration parameter can be set. The mode used for any one transaction depends on the value of &lt;code&gt;synchronous_commit&lt;/code&gt; when transaction commit begins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fdb850f0b7e6f4f12d81d3a2ab809c8e564bba" translate="yes" xml:space="preserve">
          <source>The user must have &lt;code&gt;EXECUTE&lt;/code&gt; privilege on the procedure in order to be allowed to invoke it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c74ba756422b33951733fa9726163bde6e9f1367" translate="yes" xml:space="preserve">
          <source>The user must have &lt;code&gt;USAGE&lt;/code&gt; privilege for the procedural language, or must be a superuser if the language is untrusted. This is the same privilege requirement as for creating a function in the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7355b734bfbb693399b1f5be80a21fc683a4208f" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the domain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b67af9ba18fb81e51e55c777748aa943b2fa8e5" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the event trigger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba5a7708c66551701c5165cf7ba963ffe31406d" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the foreign server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e794753392792d29db630aab48374584b0d3cb46" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the foreign-data wrapper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9764aeef0fe4bb5d4f2272e77d6962230b353685" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the materialized view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b0e8f2639c9d0e1c0e8fa04963b62d2820b7705" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the publication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2288b9ac65364d46e00039d4c94aae751493c3c0" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d54654fb52ccc22d099e9d7662a28009ae6c974d" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the statistics object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c69e3a3d77712ec7eadabb2257570bc879c31fe4" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the subscription.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6566e54be9aa4e4a755e403ba928be2a78bd2f0e" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5465925abc46b022486e34924312d36ae3fb4555" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6eb245257eeab851862782e2a923bbc7e47c8d6" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead32115822b14f6c36ec30a49fc2050b45d7ff6" translate="yes" xml:space="preserve">
          <source>The user name to connect as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e907b500844d993a9893eddde6a23ad8e157309f" translate="yes" xml:space="preserve">
          <source>The user performing the lock on the view must have the corresponding privilege on the view. In addition the view's owner must have the relevant privileges on the underlying base relations, but the user performing the lock does not need any permissions on the underlying base relations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bfd48e694dd153c1235989f4fbd645fdacfec80" translate="yes" xml:space="preserve">
          <source>The user that creates the function becomes the owner of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96430e1e5477d00f6c76c64e1c8233d8001617e1" translate="yes" xml:space="preserve">
          <source>The user that creates the procedure becomes the owner of the procedure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa24870d0f9c850e93790c8855a7b4579bd41481" translate="yes" xml:space="preserve">
          <source>The user who defines a text search configuration becomes its owner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d4088ee84ecfa3f7d22aab37f998c942ea2998" translate="yes" xml:space="preserve">
          <source>The user who defines a text search dictionary becomes its owner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba174285d0ec0c6de6eab2554bacc234f431f1f5" translate="yes" xml:space="preserve">
          <source>The user who defines an operator class becomes its owner. Presently, the creating user must be a superuser. (This restriction is made because an erroneous operator class definition could confuse or even crash the server.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbdfed285f07a1cecc02c081ebab06c65c95b2f7" translate="yes" xml:space="preserve">
          <source>The user who defines an operator family becomes its owner. Presently, the creating user must be a superuser. (This restriction is made because an erroneous operator family definition could confuse or even crash the server.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a49e64af112af0fce66c24196c6a87dd37d8a41a" translate="yes" xml:space="preserve">
          <source>The user's client (frontend) application that wants to perform database operations. Client applications can be very diverse in nature: a client could be a text-oriented tool, a graphical application, a web server that accesses the database to display web pages, or a specialized database maintenance tool. Some client applications are supplied with the PostgreSQL distribution; most are developed by users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b80e8348cd40d70e9a3578f00476d222916ac1c" translate="yes" xml:space="preserve">
          <source>The user's personal startup file is named &lt;code&gt;.psqlrc&lt;/code&gt; and is sought in the invoking user's home directory. On Windows, which lacks such a concept, the personal startup file is named &lt;code&gt;%APPDATA%\postgresql\psqlrc.conf&lt;/code&gt;. The location of the user's startup file can be set explicitly via the &lt;code&gt;PSQLRC&lt;/code&gt; environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3920cf489a63459b72dde1b92f7b717a8e6b52fd" translate="yes" xml:space="preserve">
          <source>The user, database, and (client) host items remain the same for the life of the client connection, but the activity indicator changes. The activity can be &lt;code&gt;idle&lt;/code&gt; (i.e., waiting for a client command), &lt;code&gt;idle in transaction&lt;/code&gt; (waiting for client inside a &lt;code&gt;BEGIN&lt;/code&gt; block), or a command type name such as &lt;code&gt;SELECT&lt;/code&gt;. Also, &lt;code&gt;waiting&lt;/code&gt; is appended if the server process is presently waiting on a lock held by another session. In the above example we can infer that process 15606 is waiting for process 15610 to complete its transaction and thereby release some lock. (Process 15610 must be the blocker, because there is no other active session. In more complicated cases it would be necessary to look into the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view to determine who is blocking whom.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13392321669f2c3fc39fecf0f89fb41cca2076a4" translate="yes" xml:space="preserve">
          <source>The usual comparison operators are available, as shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06a88b4eddcbb8d26f5f678e56a78a9bd14190d1" translate="yes" xml:space="preserve">
          <source>The usual goal of routine vacuuming is to do standard &lt;code&gt;VACUUM&lt;/code&gt;s often enough to avoid needing &lt;code&gt;VACUUM FULL&lt;/code&gt;. The autovacuum daemon attempts to work this way, and in fact will never issue &lt;code&gt;VACUUM FULL&lt;/code&gt;. In this approach, the idea is not to keep tables at their minimum size, but to maintain steady-state usage of disk space: each table occupies space equivalent to its minimum size plus however much space gets used up between vacuumings. Although &lt;code&gt;VACUUM FULL&lt;/code&gt; can be used to shrink a table back to its minimum size and return the disk space to the operating system, there is not much point in this if the table will just grow again in the future. Thus, moderately-frequent standard &lt;code&gt;VACUUM&lt;/code&gt; runs are a better approach than infrequent &lt;code&gt;VACUUM FULL&lt;/code&gt; runs for maintaining heavily-updated tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8705eeb4c73510ec550152d0313d6eeffdb4ff7a" translate="yes" xml:space="preserve">
          <source>The usual interpretation of the &lt;code&gt;amproclefttype&lt;/code&gt; and &lt;code&gt;amprocrighttype&lt;/code&gt; fields is that they identify the left and right input types of the operator(s) that a particular support function supports. For some access methods these match the input data type(s) of the support function itself, for others not. There is a notion of &amp;ldquo;default&amp;rdquo; support functions for an index, which are those with &lt;code&gt;amproclefttype&lt;/code&gt; and &lt;code&gt;amprocrighttype&lt;/code&gt; both equal to the index operator class's &lt;code&gt;opcintype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="675415fe7638319c8a05abc3d9aab113c5086abb" translate="yes" xml:space="preserve">
          <source>The usual logical operators are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410b768bdab1d606d84345d16fb594b86774dec4" translate="yes" xml:space="preserve">
          <source>The utility command &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; can be used to start and shut down the &lt;code&gt;postgres&lt;/code&gt; server safely and comfortably.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="914a00521ee94634aa555f79070e426ade88941f" translate="yes" xml:space="preserve">
          <source>The value can range from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;10000000000&lt;/code&gt;. When &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, index scans are never skipped during &lt;code&gt;VACUUM&lt;/code&gt; cleanup. The default value is &lt;code&gt;0.1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82bae1585ba067ff6aabd9ec822fffc256ffef0f" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;dynamic_library_path&lt;/code&gt; must be a list of absolute directory paths separated by colons (or semi-colons on Windows). If a list element starts with the special string &lt;code&gt;$libdir&lt;/code&gt;, the compiled-in PostgreSQL package library directory is substituted for &lt;code&gt;$libdir&lt;/code&gt;; this is where the modules provided by the standard PostgreSQL distribution are installed. (Use &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; to find out the name of this directory.) For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ece96ce583cb594781fa18e96e90c23a241cb2" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;search_path&lt;/code&gt; must be a comma-separated list of schema names. Any name that is not an existing schema, or is a schema for which the user does not have &lt;code&gt;USAGE&lt;/code&gt; permission, is silently ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1885fd3acbde2dfc55224cb44032743ea0749cf2" translate="yes" xml:space="preserve">
          <source>The value is a list of names of tablespaces. When there is more than one name in the list, PostgreSQL chooses a random member of the list each time a temporary object is to be created; except that within a transaction, successively created temporary objects are placed in successive tablespaces from the list. If the selected element of the list is an empty string, PostgreSQL will automatically use the default tablespace of the current database instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c82c62699420580e0ce37ee3df7912c1dd98bf" translate="yes" xml:space="preserve">
          <source>The value is either the name of a tablespace, or an empty string to specify using the default tablespace of the current database. If the value does not match the name of any existing tablespace, PostgreSQL will automatically use the default tablespace of the current database. If a nondefault tablespace is specified, the user must have &lt;code&gt;CREATE&lt;/code&gt; privilege for it, or creation attempts will fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35739a3ab0eff8d38722337e2254ec6c774352ae" translate="yes" xml:space="preserve">
          <source>The value might be quoted and schema-qualified. If no collation is derived for the argument expression, then a null value is returned. If the argument is not of a collatable data type, then an error is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c36934ef87435e122aa28a1e5f5b7fbbf50ca7" translate="yes" xml:space="preserve">
          <source>The value of either of these directories that is appropriate for the installation can be found out using &lt;a href=&quot;app-pgconfig&quot;&gt;pg_config&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48b58f404c5ab41a010c449c8600d4f12fc88c78" translate="yes" xml:space="preserve">
          <source>The value of the last affected OID, as returned from an &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;\lo_import&lt;/code&gt; command. This variable is only guaranteed to be valid until after the result of the next SQL command has been displayed. PostgreSQL servers since version 12 do not support OID system columns anymore, thus LASTOID will always be 0 following &lt;code&gt;INSERT&lt;/code&gt; when targeting such servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c651921fd6703938e12fa970227922443e260428" translate="yes" xml:space="preserve">
          <source>The value of the psql variable &lt;code&gt;name&lt;/code&gt;. See the section &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cad357760c4befedd7f8fdaa593e68c359c8118" translate="yes" xml:space="preserve">
          <source>The value of the selected prompt variable is printed literally, except where a percent sign (&lt;code&gt;%&lt;/code&gt;) is encountered. Depending on the next character, certain other text is substituted instead. Defined substitutions are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c0a0ed9f32ba0a19ec5847f3fbe4958f014ea1" translate="yes" xml:space="preserve">
          <source>The value of this parameter overrides the &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; setting. The default value is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a4243c2cf710a88b014f758bc5617eddee2438a" translate="yes" xml:space="preserve">
          <source>The value to use for &lt;code&gt;old_version&lt;/code&gt; is determined by the extension's author, and might vary if there is more than one version of the old-style module that can be upgraded into an extension. For the standard additional modules supplied with pre-9.1 PostgreSQL, use &lt;code&gt;unpackaged&lt;/code&gt; for &lt;code&gt;old_version&lt;/code&gt; when updating a module to extension style.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29a25a9c8e901cbf1e213381b2fe324bdafd7520" translate="yes" xml:space="preserve">
          <source>The value to use for a template-specific option. If the value is not a simple identifier or number, it must be quoted (but you can always quote it, if you wish).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97aba03e4cf10e442611ec122abb257717947453" translate="yes" xml:space="preserve">
          <source>The values in each record are separated by the &lt;code&gt;DELIMITER&lt;/code&gt; character. If the value contains the delimiter character, the &lt;code&gt;QUOTE&lt;/code&gt; character, the &lt;code&gt;NULL&lt;/code&gt; string, a carriage return, or line feed character, then the whole value is prefixed and suffixed by the &lt;code&gt;QUOTE&lt;/code&gt; character, and any occurrence within the value of a &lt;code&gt;QUOTE&lt;/code&gt; character or the &lt;code&gt;ESCAPE&lt;/code&gt; character is preceded by the escape character. You can also use &lt;code&gt;FORCE_QUOTE&lt;/code&gt; to force quotes when outputting non-&lt;code&gt;NULL&lt;/code&gt; values in specific columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d03d5b23111b07a76c7aeb9df7ffb0e8eb87a7" translate="yes" xml:space="preserve">
          <source>The values stored in the free space map are not exact. They're rounded to precision of 1/256th of &lt;code&gt;BLCKSZ&lt;/code&gt; (32 bytes with default &lt;code&gt;BLCKSZ&lt;/code&gt;), and they're not kept fully up-to-date as tuples are inserted and updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6c08b4507fc75b276335a79d4dd41a78fcf9ac5" translate="yes" xml:space="preserve">
          <source>The variants to add and drop attributes are part of the SQL standard; the other variants are PostgreSQL extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90629b5d606371db9e2f9a38b9c003515b5bf970" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;\d&lt;/code&gt; commands accept a &lt;code&gt;pattern&lt;/code&gt; parameter to specify the object name(s) to be displayed. In the simplest case, a pattern is just the exact name of the object. The characters within a pattern are normally folded to lower case, just as in SQL names; for example, &lt;code&gt;\dt FOO&lt;/code&gt; will display the table named &lt;code&gt;foo&lt;/code&gt;. As in SQL names, placing double quotes around a pattern stops folding to lower case. Should you need to include an actual double quote character in a pattern, write it as a pair of double quotes within a double-quote sequence; again this is in accord with the rules for SQL quoted identifiers. For example, &lt;code&gt;\dt &quot;FOO&quot;&quot;BAR&quot;&lt;/code&gt; will display the table named &lt;code&gt;FOO&quot;BAR&lt;/code&gt; (not &lt;code&gt;foo&quot;bar&lt;/code&gt;). Unlike the normal rules for SQL names, you can put double quotes around just part of a pattern, for instance &lt;code&gt;\dt FOO&quot;FOO&quot;BAR&lt;/code&gt; will display the table named &lt;code&gt;fooFOObar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7768758b3213c172e932c01f8e8da70daa4ada7f" translate="yes" xml:space="preserve">
          <source>The various containment and existence operators, along with all other JSON operators and functions are documented in &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e179b7076409c4b105a612d7c9bb99b67e607cd" translate="yes" xml:space="preserve">
          <source>The verbatim query string submitted to declare this cursor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91cb72e2fa3dca24da98249febe148f7555e66ba" translate="yes" xml:space="preserve">
          <source>The version of the extension to install. This can be written as either an identifier or a string literal. The default version is whatever is specified in the extension's control file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f466ef09b06001ef2dbe51d7e047e29feba87d5" translate="yes" xml:space="preserve">
          <source>The vertical header, displayed as the leftmost column, contains the values found in column &lt;code&gt;colV&lt;/code&gt;, in the same order as in the query results, but with duplicates removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0adcabe9624ff122085bfba5e28081fdc88cd247" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_config&lt;/code&gt; describes the compile-time configuration parameters of the currently installed version of PostgreSQL. It is intended, for example, to be used by software packages that want to interface to PostgreSQL to facilitate finding the required header files and libraries. It provides the same basic information as the &lt;a href=&quot;app-pgconfig&quot;&gt;pg_config&lt;/a&gt; PostgreSQL client application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ea6b2cfb240aa2a36ba0270a0c6bfcfe867503" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_file_settings&lt;/code&gt; provides a summary of the contents of the server's configuration file(s). A row appears in this view for each &amp;ldquo;name = value&amp;rdquo; entry appearing in the files, with annotations indicating whether the value could be applied successfully. Additional row(s) may appear for problems not linked to a &amp;ldquo;name = value&amp;rdquo; entry, such as syntax errors in the files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d33a4b341777d328dc2c1f214857e8874dc6d9" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_group&lt;/code&gt; exists for backwards compatibility: it emulates a catalog that existed in PostgreSQL before version 8.1. It shows the names and members of all roles that are marked as not &lt;code&gt;rolcanlogin&lt;/code&gt;, which is an approximation to the set of roles that are being used as groups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dadc8f5b62fc6f506c2d65eb8b07e558e7c8b3f" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_hba_file_rules&lt;/code&gt; provides a summary of the contents of the client authentication configuration file, &lt;code&gt;pg_hba.conf&lt;/code&gt;. A row appears in this view for each non-empty, non-comment line in the file, with annotations indicating whether the rule could be applied successfully.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac1873f6d2161781d725af8550ac62cddd3ae8a" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_indexes&lt;/code&gt; provides access to useful information about each index in the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a5f88ab67e15b0fb81ed88eb1f6933ddc8f95f" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_locks&lt;/code&gt; provides access to information about the locks held by active processes within the database server. See &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more discussion of locking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042974f73615dd15fc09c5129e6b33aeeef53099" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_matviews&lt;/code&gt; provides access to useful information about each materialized view in the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f35ab0d9ea2df46d55f4f8845455de38e126b0e5" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_policies&lt;/code&gt; provides access to useful information about each row-level security policy in the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43d0e1b7a1af60f6a8bef0840cbf55e0cd1189ae" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_prepared_xacts&lt;/code&gt; displays information about transactions that are currently prepared for two-phase commit (see &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5890e8d1e9f41b0cd60cd417fec506b423153a1c" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_publication_tables&lt;/code&gt; provides information about the mapping between publications and the tables they contain. Unlike the underlying catalog &lt;code&gt;pg_publication_rel&lt;/code&gt;, this view expands publications defined as &lt;code&gt;FOR ALL TABLES&lt;/code&gt;, so for such publications there will be a row for each eligible table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f8a891f9c67ef2b6de308cc7563907a8fbe06b" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_roles&lt;/code&gt; provides access to information about database roles. This is simply a publicly readable view of &lt;a href=&quot;catalog-pg-authid&quot;&gt;&lt;code&gt;pg_authid&lt;/code&gt;&lt;/a&gt; that blanks out the password field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be02d2530abee0307e3d8c75ed7462d6006d37d5" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_rules&lt;/code&gt; provides access to useful information about query rewrite rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8abbf138d7583623930f0cc0e4290da9934bc84a" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_seclabels&lt;/code&gt; provides information about security labels. It as an easier-to-query version of the &lt;a href=&quot;catalog-pg-seclabel&quot;&gt;&lt;code&gt;pg_seclabel&lt;/code&gt;&lt;/a&gt; catalog.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9de8f57dd43c6ec5ae63346c8a1f92176c16d0d1" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_sequences&lt;/code&gt; provides access to useful information about each sequence in the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e4f3261aeb43d1f5668204f1fb62fa4677a0bd" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_settings&lt;/code&gt; provides access to run-time parameters of the server. It is essentially an alternative interface to the &lt;a href=&quot;sql-show&quot;&gt;SHOW&lt;/a&gt; and &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; commands. It also provides access to some facts about each parameter that are not directly available from &lt;code&gt;SHOW&lt;/code&gt;, such as minimum and maximum values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7729b5ec7977be5f90c3408f6cef81a593faa4de" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_shadow&lt;/code&gt; exists for backwards compatibility: it emulates a catalog that existed in PostgreSQL before version 8.1. It shows properties of all roles that are marked as &lt;code&gt;rolcanlogin&lt;/code&gt; in &lt;a href=&quot;catalog-pg-authid&quot;&gt;&lt;code&gt;pg_authid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15bc53a297402a714a0bba8855047689e420c4a" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_stats&lt;/code&gt; provides access to the information stored in the &lt;a href=&quot;catalog-pg-statistic&quot;&gt;&lt;code&gt;pg_statistic&lt;/code&gt;&lt;/a&gt; catalog. This view allows access only to rows of &lt;code&gt;pg_statistic&lt;/code&gt; that correspond to tables the user has permission to read, and therefore it is safe to allow public read access to this view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b10f73e0ee9172a27b8a2e39f5e546984d02189" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_stats_ext&lt;/code&gt; provides access to the information stored in the &lt;a href=&quot;catalog-pg-statistic-ext&quot;&gt;&lt;code&gt;pg_statistic_ext&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;catalog-pg-statistic-ext-data&quot;&gt;&lt;code&gt;pg_statistic_ext_data&lt;/code&gt;&lt;/a&gt; catalogs. This view allows access only to rows of &lt;code&gt;pg_statistic_ext&lt;/code&gt; and &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; that correspond to tables the user has permission to read, and therefore it is safe to allow public read access to this view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40e73d682038b4cca53135af313b3e16f3f20f0" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_tables&lt;/code&gt; provides access to useful information about each table in the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6619a281d707d2c59aad726e79eb743d37565afc" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; provides a list of time zone abbreviations that are currently recognized by the datetime input routines. The contents of this view change when the &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE-ABBREVIATIONS&quot;&gt;timezone_abbreviations&lt;/a&gt; run-time parameter is modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="779554f59d2b5af071b41b6375ef03ef95013941" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_timezone_names&lt;/code&gt; provides a list of time zone names that are recognized by &lt;code&gt;SET TIMEZONE&lt;/code&gt;, along with their associated abbreviations, UTC offsets, and daylight-savings status. (Technically, PostgreSQL does not use UTC because leap seconds are not handled.) Unlike the abbreviations shown in &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;&lt;code&gt;pg_timezone_abbrevs&lt;/code&gt;&lt;/a&gt;, many of these names imply a set of daylight-savings transition date rules. Therefore, the associated information changes across local DST boundaries. The displayed information is computed based on the current value of &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0accb8d532196eb116802aaa4d92096a1d624fec" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_user&lt;/code&gt; provides access to information about database users. This is simply a publicly readable view of &lt;a href=&quot;view-pg-shadow&quot;&gt;&lt;code&gt;pg_shadow&lt;/code&gt;&lt;/a&gt; that blanks out the password field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af556d749b255c75a83063bd94ae2fbcc5e7542" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_user_mappings&lt;/code&gt; provides access to information about user mappings. This is essentially a publicly readable view of &lt;a href=&quot;catalog-pg-user-mapping&quot;&gt;&lt;code&gt;pg_user_mapping&lt;/code&gt;&lt;/a&gt; that leaves out the options field if the user has no rights to use it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebac217e3082208e364c831d2d7b567e319b9c3e" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_views&lt;/code&gt; provides access to useful information about each view in the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4817256584c648c50b28a16cee721735c1a52c24" translate="yes" xml:space="preserve">
          <source>The view definition must not contain &lt;code&gt;WITH&lt;/code&gt;, &lt;code&gt;DISTINCT&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, &lt;code&gt;HAVING&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt;, or &lt;code&gt;OFFSET&lt;/code&gt; clauses at the top level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac73f4040a9b923ccad030c67910098b61fec109" translate="yes" xml:space="preserve">
          <source>The view definition must not contain set operations (&lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt; or &lt;code&gt;EXCEPT&lt;/code&gt;) at the top level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5066d83f9232becf3a59274519313c89ede3a33" translate="yes" xml:space="preserve">
          <source>The view must have exactly one entry in its &lt;code&gt;FROM&lt;/code&gt; list, which must be a table or another updatable view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf2ef9470f50663334ce73cc7c64a2829052725" translate="yes" xml:space="preserve">
          <source>The view's select list must not contain any aggregates, window functions or set-returning functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130532d5707af5b172a46c66162c216e956933cf" translate="yes" xml:space="preserve">
          <source>The visibility map stores two bits per heap page. The first bit, if set, indicates that the page is all-visible, or in other words that the page does not contain any tuples that need to be vacuumed. This information can also be used by &lt;a href=&quot;indexes-index-only-scans&quot;&gt;&lt;em&gt;index-only scans&lt;/em&gt;&lt;/a&gt; to answer queries using only the index tuple. The second bit, if set, means that all tuples on the page have been frozen. That means that even an anti-wraparound vacuum need not revisit the page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07214e8c015e87c0486ca72cfe80d8e537680c27" translate="yes" xml:space="preserve">
          <source>The web site of the Unicode Consortium.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0772ef278780058ef7ad6f8b7ba38fa2811ad4" translate="yes" xml:space="preserve">
          <source>The word &lt;code&gt;The&lt;/code&gt; was recognized by the &lt;code&gt;english_ispell&lt;/code&gt; dictionary as a stop word (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-STOPWORDS&quot;&gt;Section 12.6.1&lt;/a&gt;) and will not be indexed. The spaces are discarded too, since the configuration provides no dictionaries at all for them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59b558b7e67cfe3d7e609850ba39630cdfabc234" translate="yes" xml:space="preserve">
          <source>The words &lt;code&gt;INNER&lt;/code&gt; and &lt;code&gt;OUTER&lt;/code&gt; are optional in all forms. &lt;code&gt;INNER&lt;/code&gt; is the default; &lt;code&gt;LEFT&lt;/code&gt;, &lt;code&gt;RIGHT&lt;/code&gt;, and &lt;code&gt;FULL&lt;/code&gt; imply an outer join.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b4d99c273391963b8b35583f768d35f9926b320" translate="yes" xml:space="preserve">
          <source>The write-ahead log files are collected at the end of the backup. Therefore, it is necessary for the &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; parameter to be set high enough that the log is not removed before the end of the backup. If the log has been rotated when it's time to transfer it, the backup will fail and be unusable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba7564fc67dee171caeeb2fce7f2a0e6bd4739d4" translate="yes" xml:space="preserve">
          <source>The write-ahead log is streamed over a regular PostgreSQL connection and uses the replication protocol. The connection must be made with a superuser or a user having &lt;code&gt;REPLICATION&lt;/code&gt; permissions (see &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt;), and &lt;code&gt;pg_hba.conf&lt;/code&gt; must permit the replication connection. The server must also be configured with &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; set high enough to leave at least one session available for the stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432cd562d6efcb95d5dc25b8cd51ce86806b3431" translate="yes" xml:space="preserve">
          <source>The year field divided by 10</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e98cba09cda3a8f0612018162bdf75b308d8a647" translate="yes" xml:space="preserve">
          <source>The year field. Keep in mind there is no &lt;code&gt;0 AD&lt;/code&gt;, so subtracting &lt;code&gt;BC&lt;/code&gt; years from &lt;code&gt;AD&lt;/code&gt; years should be done with care.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3552e22363d1468b0aacd8c69df60173fa97d631" translate="yes" xml:space="preserve">
          <source>Then a second pass is performed to add tuples that were added while the first pass was running. This step is also done in a separate transaction for each index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de263736bca031472680a6589ed91b77cebda41e" translate="yes" xml:space="preserve">
          <source>Then create a foreign server using &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;. In this example we wish to connect to a PostgreSQL server on host &lt;code&gt;192.83.123.89&lt;/code&gt; listening on port &lt;code&gt;5432&lt;/code&gt;. The database to which the connection is made is named &lt;code&gt;foreign_db&lt;/code&gt; on the remote server:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9fba163e98528da53932bde9ceaf387982416c" translate="yes" xml:space="preserve">
          <source>Then create a foreign server:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e43083876c3094d12a2389b25dd099144327f495" translate="yes" xml:space="preserve">
          <source>Then create the necessary functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dddb885a6a2b1519c7054126c37d9c20d84517e" translate="yes" xml:space="preserve">
          <source>Then do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4426056bca332e6c166eaec6ccb98cd595443c37" translate="yes" xml:space="preserve">
          <source>Then give the snapshot identifier in a &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; command at the beginning of the newly opened transaction:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="099f3b7a79e1e05797463b8b9b3322c6caaa4e61" translate="yes" xml:space="preserve">
          <source>Then in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb8ef6dada9fbef1512f58ed41d1e67ec739a68" translate="yes" xml:space="preserve">
          <source>Then issue the tablespace creation command inside PostgreSQL:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f76343f97548fdfb798c00512768e705a5ee06" translate="yes" xml:space="preserve">
          <source>Then on the publisher database:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d6e3db28b5d51e7392c9e84a5178977bac26570" translate="yes" xml:space="preserve">
          <source>Then psql's &lt;code&gt;\dp&lt;/code&gt; command would show:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e40d95af0c8bcea8599638c011ae6dba5195ebe1" translate="yes" xml:space="preserve">
          <source>Then value &lt;code&gt;i&lt;/code&gt; between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; inclusive is drawn with probability: &lt;code&gt;f(i) - f(i + 1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="509703ffcaaed84d033fc9e94ce5a7937bf0da94" translate="yes" xml:space="preserve">
          <source>Then we create a GIN index to speed up the search:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c623faac8eaf06e9450b38faf671811be2f6e1f9" translate="yes" xml:space="preserve">
          <source>Then we no longer have access to the public schema without explicit qualification. There is nothing special about the public schema except that it exists by default. It can be dropped, too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d0e01998d1caf45906467ce09eb6d9f85a24392" translate="yes" xml:space="preserve">
          <source>Then we will get these results:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30348812ea695911ccd6ce73f8cff665d67bd9ad" translate="yes" xml:space="preserve">
          <source>Then you can use it in a &lt;code&gt;SELECT&lt;/code&gt; command, for instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c956d2a4c1c867a4aa753ae841035f68a38bb7b" translate="yes" xml:space="preserve">
          <source>Then you could name the files in the &lt;code&gt;conf.d&lt;/code&gt; directory like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c7647dc71f8f47d91ed549387e0af6d05b17ea" translate="yes" xml:space="preserve">
          <source>Then, create a symbolic link to it in &lt;code&gt;/etc/rc3.d&lt;/code&gt; as &lt;code&gt;S99postgresql&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e196180497775135006d17c14fe064e7b2203578" translate="yes" xml:space="preserve">
          <source>Then, sign the request with the key to create a root certificate authority (using the default OpenSSL configuration file location on Linux):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6f711b66bbac69a2f23c2445e625c076269156" translate="yes" xml:space="preserve">
          <source>There are a few restrictions on operator names, however:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e06308b22446d8ff8a3bec464184e0db33a1b8e3" translate="yes" xml:space="preserve">
          <source>There are a few restrictions on your choice of name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38ec4f8f8d1c9acce491ad6d51f28d3688ffbf6" translate="yes" xml:space="preserve">
          <source>There are a few solutions that do not fit into the above categories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2d4b5a4acbfddfda3fa8af2f47936fbae4e67b7" translate="yes" xml:space="preserve">
          <source>There are a few things to be careful about when adding trace macros to the C code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30225d755151e996e06d97ca5afb06ce57185f7a" translate="yes" xml:space="preserve">
          <source>There are a few things you need to do to simplify importing CSV log files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f7d5ba0c83b5c117ed409216f966f9d7eef72d" translate="yes" xml:space="preserve">
          <source>There are also additional types of conflict that can occur with Hot Standby. These conflicts are &lt;em&gt;hard conflicts&lt;/em&gt; in the sense that queries might need to be canceled and, in some cases, sessions disconnected to resolve them. The user is provided with several ways to handle these conflicts. Conflict cases include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="080fe8c96ab19e790a2ea0bd30b8130c9a87b676" translate="yes" xml:space="preserve">
          <source>There are also some built-in operator classes besides the default ones:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bbd8454471c92fa3e16174c667ec63b3cc9c3f" translate="yes" xml:space="preserve">
          <source>There are also some comparison predicates, as shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-PRED-TABLE&quot;&gt;Table 9.2&lt;/a&gt;. These behave much like operators, but have special syntax mandated by the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f3ba822c528ebdfeb9746d393a7742a7d6e349" translate="yes" xml:space="preserve">
          <source>There are cases in which the actual and estimated values won't match up well, but nothing is really wrong. One such case occurs when plan node execution is stopped short by a &lt;code&gt;LIMIT&lt;/code&gt; or similar effect. For example, in the &lt;code&gt;LIMIT&lt;/code&gt; query we used before,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626c9a7674dab9b044bc50641f2a4b064da217a4" translate="yes" xml:space="preserve">
          <source>There are certain operations that hold critical locks and should therefore complete as quickly as possible. Cost-based vacuum delays do not occur during such operations. Therefore it is possible that the cost accumulates far higher than the specified limit. To avoid uselessly long delays in such cases, the actual delay is calculated as &lt;code&gt;vacuum_cost_delay&lt;/code&gt; * &lt;code&gt;accumulated_balance&lt;/code&gt; / &lt;code&gt;vacuum_cost_limit&lt;/code&gt; with a maximum of &lt;code&gt;vacuum_cost_delay&lt;/code&gt; * 4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49623fffc3b27e386ddb0902bf870bdd64aa14c1" translate="yes" xml:space="preserve">
          <source>There are different kinds of privileges: &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;, &lt;code&gt;REFERENCES&lt;/code&gt;, &lt;code&gt;TRIGGER&lt;/code&gt;, &lt;code&gt;CREATE&lt;/code&gt;, &lt;code&gt;CONNECT&lt;/code&gt;, &lt;code&gt;TEMPORARY&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, and &lt;code&gt;USAGE&lt;/code&gt;. The privileges applicable to a particular object vary depending on the object's type (table, function, etc). More detail about the meanings of these privileges appears below. The following sections and chapters will also show you how these privileges are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4c8f7302f72ae7897c7273dc4e0796366f4575" translate="yes" xml:space="preserve">
          <source>There are examples in &lt;code&gt;refint.example&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74d4a0a2f4513529b90fbecc5989b2ddcb617e4" translate="yes" xml:space="preserve">
          <source>There are five forms of &lt;code&gt;CREATE TYPE&lt;/code&gt;, as shown in the syntax synopsis above. They respectively create a &lt;em&gt;composite type&lt;/em&gt;, an &lt;em&gt;enum type&lt;/em&gt;, a &lt;em&gt;range type&lt;/em&gt;, a &lt;em&gt;base type&lt;/em&gt;, or a &lt;em&gt;shell type&lt;/em&gt;. The first four of these are discussed in turn below. A shell type is simply a placeholder for a type to be defined later; it is created by issuing &lt;code&gt;CREATE TYPE&lt;/code&gt; with no parameters except for the type name. Shell types are needed as forward references when creating range types and base types, as discussed in those sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c0e123011cea9ffa5e9167dd8e734710858d21" translate="yes" xml:space="preserve">
          <source>There are five methods that an index operator class for GiST must provide, and four that are optional. Correctness of the index is ensured by proper implementation of the &lt;code&gt;same&lt;/code&gt;, &lt;code&gt;consistent&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; methods, while efficiency (size and speed) of the index will depend on the &lt;code&gt;penalty&lt;/code&gt; and &lt;code&gt;picksplit&lt;/code&gt; methods. Two optional methods are &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;decompress&lt;/code&gt;, which allow an index to have internal tree data of a different type than the data it indexes. The leaves are to be of the indexed data type, while the other tree nodes can be of any C struct (but you still have to follow PostgreSQL data type rules here, see about &lt;code&gt;varlena&lt;/code&gt; for variable sized data). If the tree's internal data type exists at the SQL level, the &lt;code&gt;STORAGE&lt;/code&gt; option of the &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; command can be used. The optional eighth method is &lt;code&gt;distance&lt;/code&gt;, which is needed if the operator class wishes to support ordered scans (nearest-neighbor searches). The optional ninth method &lt;code&gt;fetch&lt;/code&gt; is needed if the operator class wishes to support index-only scans, except when the &lt;code&gt;compress&lt;/code&gt; method is omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e9f9add6de4117c3f41e8f16d45114f4cd168c" translate="yes" xml:space="preserve">
          <source>There are five user-defined methods that an index operator class for SP-GiST must provide, and one is optional. All five mandatory methods follow the convention of accepting two &lt;code&gt;internal&lt;/code&gt; arguments, the first of which is a pointer to a C struct containing input values for the support method, while the second argument is a pointer to a C struct where output values must be placed. Four of the mandatory methods just return &lt;code&gt;void&lt;/code&gt;, since all their results appear in the output struct; but &lt;code&gt;leaf_consistent&lt;/code&gt; additionally returns a &lt;code&gt;boolean&lt;/code&gt; result. The methods must not modify any fields of their input structs. In all cases, the output struct is initialized to zeroes before calling the user-defined method. The optional sixth method &lt;code&gt;compress&lt;/code&gt; accepts datum to be indexed as the only argument and returns a value suitable for physical storage in a leaf tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa03941817da7215f34f7c4059988c3830f85876" translate="yes" xml:space="preserve">
          <source>There are four fundamental SQL constructs requiring distinct type conversion rules in the PostgreSQL parser:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af078d5f8f920b3bd3ff699db4f54f596acf2a85" translate="yes" xml:space="preserve">
          <source>There are four methods that an operator class for BRIN must provide:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc37bd22ec5c580834570b2476e6fe4f24b8403a" translate="yes" xml:space="preserve">
          <source>There are minor differences in the interpretation of regular expression patterns used in &lt;code&gt;like_regex&lt;/code&gt; filters, as described in &lt;a href=&quot;functions-json#JSONPATH-REGULAR-EXPRESSIONS&quot;&gt;Section 9.15.2.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d1e6b157368edb7a34c08bf06a60ee5f8744e9" translate="yes" xml:space="preserve">
          <source>There are not currently any commands that manipulate procedural language templates; to change the built-in information, a superuser must modify the table using ordinary &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;UPDATE&lt;/code&gt; commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b7b9a654dddbbbf44432092fdfff639afd65c3" translate="yes" xml:space="preserve">
          <source>There are parallel variants of these operators for both the &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;jsonb&lt;/code&gt; types. The field/element/path extraction operators return the same type as their left-hand input (either &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt;), except for those specified as returning &lt;code&gt;text&lt;/code&gt;, which coerce the value to text. The field/element/path extraction operators return NULL, rather than failing, if the JSON input does not have the right structure to match the request; for example if no such element exists. The field/element/path extraction operators that accept integer JSON array subscripts all support negative subscripting from the end of arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87d9a17505cfd4cb8b88d986ea842eb4469f8b6" translate="yes" xml:space="preserve">
          <source>There are several &lt;code&gt;substr&lt;/code&gt; functions, one of which takes types &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;integer&lt;/code&gt;. If called with a string constant of unspecified type, the system chooses the candidate function that accepts an argument of the preferred category &lt;code&gt;string&lt;/code&gt; (namely of type &lt;code&gt;text&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a86c45854efa996c6173d14634a86acbb0fae9b" translate="yes" xml:space="preserve">
          <source>There are several WAL-related configuration parameters that affect database performance. This section explains their use. Consult &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for general information about setting server configuration parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a47baf0edabbb7ab4de9adfe99efaea9932730" translate="yes" xml:space="preserve">
          <source>There are several caveats to be aware of when using this option. Only one index name can be specified, and the &lt;code&gt;CASCADE&lt;/code&gt; option is not supported. (Thus, an index that supports a &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint cannot be dropped this way.) Also, regular &lt;code&gt;DROP INDEX&lt;/code&gt; commands can be performed within a transaction block, but &lt;code&gt;DROP INDEX CONCURRENTLY&lt;/code&gt; cannot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91dcaac9ead3b10f651956a96badf0ae2f79aa1a" translate="yes" xml:space="preserve">
          <source>There are several common reasons the server might fail to start. Check the server's log file, or start it by hand (without redirecting standard output or standard error) and see what error messages appear. Below we explain some of the most common error messages in more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9adbaa62a8322d6f35b205f33d65aadeb73701d5" translate="yes" xml:space="preserve">
          <source>There are several configuration parameters that control the behavior of &lt;code&gt;auto_explain&lt;/code&gt;. Note that the default behavior is to do nothing, so you must set at least &lt;code&gt;auto_explain.log_min_duration&lt;/code&gt; if you want any results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f07db15d474ec8167b00bf77d56e7101e3f26c7" translate="yes" xml:space="preserve">
          <source>There are several distinct types of lockable objects: whole relations (e.g., tables), individual pages of relations, individual tuples of relations, transaction IDs (both virtual and permanent IDs), and general database objects (identified by class OID and object OID, in the same way as in &lt;code&gt;pg_description&lt;/code&gt; or &lt;code&gt;pg_depend&lt;/code&gt;). Also, the right to extend a relation is represented as a separate lockable object. Also, &amp;ldquo;advisory&amp;rdquo; locks can be taken on numbers that have user-defined meanings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114cb14410efa6f2de15cd3a5be68d31fc1e555a" translate="yes" xml:space="preserve">
          <source>There are several limitations of Hot Standby. These can and probably will be fixed in future releases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6c3965c75b70506035e1130db0d24734cc5245" translate="yes" xml:space="preserve">
          <source>There are several modifiers that can be put at the end of a non-star label in &lt;code&gt;lquery&lt;/code&gt; to make it match more than just the exact match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c65cdf0a50b535370cafd7a5d8814b1949feb7fa" translate="yes" xml:space="preserve">
          <source>There are several password-based authentication methods. These methods operate similarly but differ in how the users' passwords are stored on the server and how the password provided by a client is sent across the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82697895b0fc3864eed5346e0a502ff9ce90f8b6" translate="yes" xml:space="preserve">
          <source>There are several possible values of &lt;code&gt;context&lt;/code&gt;. In order of decreasing difficulty of changing the setting, they are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="412101ab8ec853191b9bda2fa3098ca1192d7103" translate="yes" xml:space="preserve">
          <source>There are several reasons why one might want to use schemas:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47ec670ad87a5a65f5d73f50b758515c8d78f032" translate="yes" xml:space="preserve">
          <source>There are several settings which can cause the query planner not to generate a parallel query plan under any circumstances. In order for any parallel query plans whatsoever to be generated, the following settings must be configured as indicated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a490c0d4b72a8988d006fa28baad623b333c2c3" translate="yes" xml:space="preserve">
          <source>There are several ways around this problem. One simple answer is to use &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; in sub-&lt;code&gt;SELECT&lt;/code&gt;s in row security policies. However, that requires granting &lt;code&gt;UPDATE&lt;/code&gt; privilege on the referenced table (here &lt;code&gt;users&lt;/code&gt;) to the affected users, which might be undesirable. (But another row security policy could be applied to prevent them from actually exercising that privilege; or the sub-&lt;code&gt;SELECT&lt;/code&gt; could be embedded into a security definer function.) Also, heavy concurrent use of row share locks on the referenced table could pose a performance problem, especially if updates of it are frequent. Another solution, practical if updates of the referenced table are infrequent, is to take an exclusive lock on the referenced table when updating it, so that no concurrent transactions could be examining old row values. Or one could just wait for all concurrent transactions to end after committing an update of the referenced table and before making changes that rely on the new security situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a65d46642b8ea0d625c08a9a29af3d8886f49e2" translate="yes" xml:space="preserve">
          <source>There are several ways to shut down the database server. You control the type of shutdown by sending different signals to the master &lt;code&gt;postgres&lt;/code&gt; process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2aaff5fcb38efacb1d58514b7509e951bb1187c" translate="yes" xml:space="preserve">
          <source>There are some basic assumptions that a btree operator family must satisfy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b521cdf532a9a953ad42c30cbfbc097cf6b1b08" translate="yes" xml:space="preserve">
          <source>There are three available prewarming methods. &lt;code&gt;prefetch&lt;/code&gt; issues asynchronous prefetch requests to the operating system, if this is supported, or throws an error otherwise. &lt;code&gt;read&lt;/code&gt; reads the requested range of blocks; unlike &lt;code&gt;prefetch&lt;/code&gt;, this is synchronous and supported on all platforms and builds, but may be slower. &lt;code&gt;buffer&lt;/code&gt; reads the requested range of blocks into the database buffer cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb805126a31ff8c55ee475c5fbc01109be8dd511" translate="yes" xml:space="preserve">
          <source>There are three kinds of &lt;em&gt;implicitly-typed constants&lt;/em&gt; in PostgreSQL: strings, bit strings, and numbers. Constants can also be specified with explicit types, which can enable more accurate representation and more efficient handling by the system. These alternatives are discussed in the following subsections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30766d90eb25e2981c2e600b788f88cc0665cda4" translate="yes" xml:space="preserve">
          <source>There are three possible syntaxes for an operator invocation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac1c9045fce554fb04868e602b7a9908c87947d" translate="yes" xml:space="preserve">
          <source>There are three separate approaches to pattern matching provided by PostgreSQL: the traditional SQL &lt;code&gt;LIKE&lt;/code&gt; operator, the more recent &lt;code&gt;SIMILAR TO&lt;/code&gt; operator (added in SQL:1999), and POSIX-style regular expressions. Aside from the basic &amp;ldquo;does this string match this pattern?&amp;rdquo; operators, functions are available to extract or replace matching substrings and to split a string at matching locations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c74bdd55156d3b2783c8a6fd237fe0bceb9cfeef" translate="yes" xml:space="preserve">
          <source>There are two approaches to enforce that users provide a certificate during login.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a8c876ced91bb81f55235d3d3af76552bcc675" translate="yes" xml:space="preserve">
          <source>There are two categories of limitation to keep in mind: the restriction from XQuery to XPath for the functions specified in the SQL standard, and the restriction of XPath to version 1.0 for both the standard and the PostgreSQL-specific functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45979291689bf78b7c41886076f2033f33bb0dc2" translate="yes" xml:space="preserve">
          <source>There are two columns containing the city name. This is correct because the lists of columns from the &lt;code&gt;weather&lt;/code&gt; and &lt;code&gt;cities&lt;/code&gt; tables are concatenated. In practice this is undesirable, though, so you will probably want to list the output columns explicitly rather than using &lt;code&gt;*&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65ab8b09fb62c8b1237a292bc36db36c5b33b77b" translate="yes" xml:space="preserve">
          <source>There are two commonly used internal WAL functions: &lt;code&gt;XLogInsertRecord&lt;/code&gt; and &lt;code&gt;XLogFlush&lt;/code&gt;. &lt;code&gt;XLogInsertRecord&lt;/code&gt; is used to place a new record into the WAL buffers in shared memory. If there is no space for the new record, &lt;code&gt;XLogInsertRecord&lt;/code&gt; will have to write (move to kernel cache) a few filled WAL buffers. This is undesirable because &lt;code&gt;XLogInsertRecord&lt;/code&gt; is used on every database low level modification (for example, row insertion) at a time when an exclusive lock is held on affected data pages, so the operation needs to be as fast as possible. What is worse, writing WAL buffers might also force the creation of a new log segment, which takes even more time. Normally, WAL buffers should be written and flushed by an &lt;code&gt;XLogFlush&lt;/code&gt; request, which is made, for the most part, at transaction commit time to ensure that transaction records are flushed to permanent storage. On systems with high log output, &lt;code&gt;XLogFlush&lt;/code&gt; requests might not occur often enough to prevent &lt;code&gt;XLogInsertRecord&lt;/code&gt; from having to do writes. On such systems one should increase the number of WAL buffers by modifying the &lt;a href=&quot;runtime-config-wal#GUC-WAL-BUFFERS&quot;&gt;wal_buffers&lt;/a&gt; parameter. When &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is set and the system is very busy, setting &lt;code&gt;wal_buffers&lt;/code&gt; higher will help smooth response times during the period immediately following each checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e556036ec4c364c079311c21d04103cf4c7118b6" translate="yes" xml:space="preserve">
          <source>There are two differences in the behavior of &lt;code&gt;string_to_array&lt;/code&gt; from pre-9.1 versions of PostgreSQL. First, it will return an empty (zero-element) array rather than NULL when the input string is of zero length. Second, if the delimiter string is NULL, the function splits the input into individual characters, rather than returning NULL as before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a38ac647b826e47337bf978dbd260eda2d37e47" translate="yes" xml:space="preserve">
          <source>There are two forms of the &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; command. In the first form, the user supplies just the name of the desired language, and the PostgreSQL server consults the &lt;a href=&quot;catalog-pg-pltemplate&quot;&gt;&lt;code&gt;pg_pltemplate&lt;/code&gt;&lt;/a&gt; system catalog to determine the correct parameters. In the second form, the user supplies the language parameters along with the language name. The second form can be used to create a language that is not defined in &lt;code&gt;pg_pltemplate&lt;/code&gt;, but this approach is considered obsolescent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9cc8590527e484357685c3a4d915bc501e931e5" translate="yes" xml:space="preserve">
          <source>There are two kinds of indexes that can be used to speed up full text searches. Note that indexes are not mandatory for full text searching, but in cases where a column is searched on a regular basis, an index is usually desirable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b78b765f97cf8944029e53f4ab00dc6de355959" translate="yes" xml:space="preserve">
          <source>There are two methods that an operator class for GIN must provide:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ebcfbeecc8c9e28432149890e115326d408ee9d" translate="yes" xml:space="preserve">
          <source>There are two other fixed-length character types in PostgreSQL, shown in &lt;a href=&quot;datatype-character#DATATYPE-CHARACTER-SPECIAL-TABLE&quot;&gt;Table 8.5&lt;/a&gt;. The &lt;code&gt;name&lt;/code&gt; type exists &lt;em&gt;only&lt;/em&gt; for the storage of identifiers in the internal system catalogs and is not intended for use by the general user. Its length is currently defined as 64 bytes (63 usable characters plus terminator) but should be referenced using the constant &lt;code&gt;NAMEDATALEN&lt;/code&gt; in &lt;code&gt;C&lt;/code&gt; source code. The length is set at compile time (and is therefore adjustable for special uses); the default maximum length might change in a future release. The type &lt;code&gt;&quot;char&quot;&lt;/code&gt; (note the quotes) is different from &lt;code&gt;char(1)&lt;/code&gt; in that it only uses one byte of storage. It is internally used in the system catalogs as a simplistic enumeration type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a65ab8661e9c6e6250372b71f3e4d52aadd8690" translate="yes" xml:space="preserve">
          <source>There are two restrictions, however, which make this method impractical, or at least inferior to the pg_dump method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb559c725c45849ac1890ba81d8ba70c6affbb84" translate="yes" xml:space="preserve">
          <source>There are two significant ways in which run times measured by &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; can deviate from normal execution of the same query. First, since no output rows are delivered to the client, network transmission costs and I/O conversion costs are not included. Second, the measurement overhead added by &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; can be significant, especially on machines with slow &lt;code&gt;gettimeofday()&lt;/code&gt; operating-system calls. You can use the &lt;a href=&quot;pgtesttiming&quot;&gt;pg_test_timing&lt;/a&gt; tool to measure the overhead of timing on your system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b4937b46d88bd048aae10c82ed3779adc47d2b" translate="yes" xml:space="preserve">
          <source>There are two special cases of bracket expressions: the bracket expressions &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; and &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; are constraints, matching empty strings at the beginning and end of a word respectively. A word is defined as a sequence of word characters that is neither preceded nor followed by word characters. A word character is an &lt;code&gt;alnum&lt;/code&gt; character (as defined by the POSIX character class described above) or an underscore. This is an extension, compatible with but not specified by POSIX 1003.2, and should be used with caution in software intended to be portable to other systems. The constraint escapes described below are usually preferable; they are no more standard, but are easier to type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33967632431b8aaf7d1ba8660310b5c4fbf05d2a" translate="yes" xml:space="preserve">
          <source>There are two variants of &lt;code&gt;VACUUM&lt;/code&gt;: standard &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;VACUUM FULL&lt;/code&gt;. &lt;code&gt;VACUUM FULL&lt;/code&gt; can reclaim more disk space but runs much more slowly. Also, the standard form of &lt;code&gt;VACUUM&lt;/code&gt; can run in parallel with production database operations. (Commands such as &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; will continue to function normally, though you will not be able to modify the definition of a table with commands such as &lt;code&gt;ALTER TABLE&lt;/code&gt; while it is being vacuumed.) &lt;code&gt;VACUUM FULL&lt;/code&gt; requires exclusive lock on the table it is working on, and therefore cannot be done in parallel with other use of the table. Generally, therefore, administrators should strive to use standard &lt;code&gt;VACUUM&lt;/code&gt; and avoid &lt;code&gt;VACUUM FULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082cbad2612b1a539364141256cd8c079fbdd04c" translate="yes" xml:space="preserve">
          <source>There are two ways to acquire an advisory lock in PostgreSQL: at session level or at transaction level. Once acquired at session level, an advisory lock is held until explicitly released or the session ends. Unlike standard lock requests, session-level advisory lock requests do not honor transaction semantics: a lock acquired during a transaction that is later rolled back will still be held following the rollback, and likewise an unlock is effective even if the calling transaction fails later. A lock can be acquired multiple times by its owning process; for each completed lock request there must be a corresponding unlock request before the lock is actually released. Transaction-level lock requests, on the other hand, behave more like regular lock requests: they are automatically released at the end of the transaction, and there is no explicit unlock operation. This behavior is often more convenient than the session-level behavior for short-term usage of an advisory lock. Session-level and transaction-level lock requests for the same advisory lock identifier will block each other in the expected way. If a session already holds a given advisory lock, additional requests by it will always succeed, even if other sessions are awaiting the lock; this statement is true regardless of whether the existing lock hold and new request are at session level or transaction level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d918b8ea922c6c6ee662eb9ab4cebb7da36eb443" translate="yes" xml:space="preserve">
          <source>There are two ways to define constraints: table constraints and column constraints. A column constraint is defined as part of a column definition. A table constraint definition is not tied to a particular column, and it can encompass more than one column. Every column constraint can also be written as a table constraint; a column constraint is only a notational convenience for use when the constraint only affects one column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3100ad6baa7faf64044c5fff315dddab6008581f" translate="yes" xml:space="preserve">
          <source>There are two ways to delete rows in a table using information contained in other tables in the database: using sub-selects, or specifying additional tables in the &lt;code&gt;USING&lt;/code&gt; clause. Which technique is more appropriate depends on the specific circumstances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d2cb602ac946da832fb98a751bc210a74312a33" translate="yes" xml:space="preserve">
          <source>There are two ways to modify a table using information contained in other tables in the database: using sub-selects, or specifying additional tables in the &lt;code&gt;FROM&lt;/code&gt; clause. Which technique is more appropriate depends on the specific circumstances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2e4ae09129d50722332a9a349176e58b93478a" translate="yes" xml:space="preserve">
          <source>There are various shortcut commands for &lt;code&gt;\pset&lt;/code&gt;. See &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\C&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\H&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, &lt;code&gt;\T&lt;/code&gt;, and &lt;code&gt;\x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d44242f8d38cae700147e3f10ad23b2c1671f8" translate="yes" xml:space="preserve">
          <source>There are various special syntax rules and behaviors associated with composite types in queries. These rules provide useful shortcuts, but can be confusing if you don't know the logic behind them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adeaa568e81b8c22d184926d9648a6a85b174068" translate="yes" xml:space="preserve">
          <source>There can be multiple &lt;code&gt;pg_basebackup&lt;/code&gt;s running at the same time, but it is better from a performance point of view to take only one backup, and copy the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241118165bea21fbe830bef68a27cbb0152bef40" translate="yes" xml:space="preserve">
          <source>There is a &amp;ldquo;simple&amp;rdquo; form of &lt;code&gt;CASE&lt;/code&gt; expression that is a variant of the general form above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a329b25f5c93a21ac5ea836673c784c6afc768a" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;CREATE COLLATION&lt;/code&gt; statement in the SQL standard, but it is limited to copying an existing collation. The syntax to create a new collation is a PostgreSQL extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c08b98f45942b4395776e7da22b84f7266e5c2" translate="yes" xml:space="preserve">
          <source>There is a catch if you try to use conditional rules for complex view updates: there &lt;em&gt;must&lt;/em&gt; be an unconditional &lt;code&gt;INSTEAD&lt;/code&gt; rule for each action you wish to allow on the view. If the rule is conditional, or is not &lt;code&gt;INSTEAD&lt;/code&gt;, then the system will still reject attempts to perform the update action, because it thinks it might end up trying to perform the action on the dummy table of the view in some cases. If you want to handle all the useful cases in conditional rules, add an unconditional &lt;code&gt;DO INSTEAD NOTHING&lt;/code&gt; rule to ensure that the system understands it will never be called on to update the dummy table. Then make the conditional rules non-&lt;code&gt;INSTEAD&lt;/code&gt;; in the cases where they are applied, they add to the default &lt;code&gt;INSTEAD NOTHING&lt;/code&gt; action. (This method does not currently work to support &lt;code&gt;RETURNING&lt;/code&gt; queries, however.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c21f127ac29ffa6b6d6cad86ad16cb8ebd82f4c7" translate="yes" xml:space="preserve">
          <source>There is a limit on how many columns a table can contain. Depending on the column types, it is between 250 and 1600. However, defining a table with anywhere near this many columns is highly unusual and often a questionable design.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f67c0e3cf6c026c3a97cec11f99b88526b93a6" translate="yes" xml:space="preserve">
          <source>There is a more general version of the FOLLOWED BY operator having the form &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is an integer standing for the difference between the positions of the matching lexemes. &lt;code&gt;&amp;lt;1&amp;gt;&lt;/code&gt; is the same as &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, while &lt;code&gt;&amp;lt;2&amp;gt;&lt;/code&gt; allows exactly one other lexeme to appear between the matches, and so on. The &lt;code&gt;phraseto_tsquery&lt;/code&gt; function makes use of this operator to construct a &lt;code&gt;tsquery&lt;/code&gt; that can match a multi-word phrase when some of the words are stop words. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98845715e9aff2aab5a7e45eba23b610067562bc" translate="yes" xml:space="preserve">
          <source>There is a possibility that a concurrent &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; on the row being moved will get a serialization failure error. Suppose session 1 is performing an &lt;code&gt;UPDATE&lt;/code&gt; on a partition key, and meanwhile a concurrent session 2 for which this row is visible performs an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operation on this row. In such case, session 2's &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; will detect the row movement and raise a serialization failure error (which always returns with an SQLSTATE code '40001'). Applications may wish to retry the transaction if this occurs. In the usual case where the table is not partitioned, or where there is no row movement, session 2 would have identified the newly updated row and carried out the &lt;code&gt;UPDATE&lt;/code&gt;/&lt;code&gt;DELETE&lt;/code&gt; on this new row version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fb3023d52c67871f97870f963ae3e2511e1afd" translate="yes" xml:space="preserve">
          <source>There is a queue that holds notifications that have been sent but not yet processed by all listening sessions. If this queue becomes full, transactions calling &lt;code&gt;NOTIFY&lt;/code&gt; will fail at commit. The queue is quite large (8GB in a standard installation) and should be sufficiently sized for almost every use case. However, no cleanup can take place if a session executes &lt;code&gt;LISTEN&lt;/code&gt; and then enters a transaction for a very long time. Once the queue is half full you will see warnings in the log file pointing you to the session that is preventing cleanup. In this case you should make sure that this session ends its current transaction so that cleanup can proceed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f864b552f926f474ffeb07a0a68232c7a34815b" translate="yes" xml:space="preserve">
          <source>There is a second kind of identifier: the &lt;em&gt;delimited identifier&lt;/em&gt; or &lt;em&gt;quoted identifier&lt;/em&gt;. It is formed by enclosing an arbitrary sequence of characters in double-quotes (&lt;code&gt;&quot;&lt;/code&gt;). A delimited identifier is always an identifier, never a key word. So &lt;code&gt;&quot;select&quot;&lt;/code&gt; could be used to refer to a column or table named &amp;ldquo;select&amp;rdquo;, whereas an unquoted &lt;code&gt;select&lt;/code&gt; would be taken as a key word and would therefore provoke a parse error when used where a table or column name is expected. The example can be written with quoted identifiers like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99e2749bbb2f806b8f89c17d420b1dde22c11b68" translate="yes" xml:space="preserve">
          <source>There is a second standard system database named &lt;code&gt;template0&lt;/code&gt;. This database contains the same data as the initial contents of &lt;code&gt;template1&lt;/code&gt;, that is, only the standard objects predefined by your version of PostgreSQL. &lt;code&gt;template0&lt;/code&gt; should never be changed after the database cluster has been initialized. By instructing &lt;code&gt;CREATE DATABASE&lt;/code&gt; to copy &lt;code&gt;template0&lt;/code&gt; instead of &lt;code&gt;template1&lt;/code&gt;, you can create a &amp;ldquo;virgin&amp;rdquo; user database that contains none of the site-local additions in &lt;code&gt;template1&lt;/code&gt;. This is particularly handy when restoring a &lt;code&gt;pg_dump&lt;/code&gt; dump: the dump script should be restored in a virgin database to ensure that one recreates the correct contents of the dumped database, without conflicting with objects that might have been added to &lt;code&gt;template1&lt;/code&gt; later on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4adb0689e8eca60cac4109882f9fd73f05b7582" translate="yes" xml:space="preserve">
          <source>There is a separate server process called the &lt;em&gt;background writer&lt;/em&gt;, whose function is to issue writes of &amp;ldquo;dirty&amp;rdquo; (new or modified) shared buffers. It writes shared buffers so server processes handling user queries seldom or never need to wait for a write to occur. However, the background writer does cause a net overall increase in I/O load, because while a repeatedly-dirtied page might otherwise be written only once per checkpoint interval, the background writer might write it several times as it is dirtied in the same interval. The parameters discussed in this subsection can be used to tune the behavior for local needs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90974f119b06bcf646bf0eec46102bc09a0eac90" translate="yes" xml:space="preserve">
          <source>There is a simple variable-substitution facility for script files. Variable names must consist of letters (including non-Latin letters), digits, and underscores. Variables can be set by the command-line &lt;code&gt;-D&lt;/code&gt; option, explained above, or by the meta commands explained below. In addition to any variables preset by &lt;code&gt;-D&lt;/code&gt; command-line options, there are a few variables that are preset automatically, listed in &lt;a href=&quot;pgbench#PGBENCH-AUTOMATIC-VARIABLES&quot;&gt;Table 257&lt;/a&gt;. A value specified for these variables using &lt;code&gt;-D&lt;/code&gt; takes precedence over the automatic presets. Once set, a variable's value can be inserted into a SQL command by writing &lt;code&gt;:&lt;/code&gt;&lt;code&gt;variablename&lt;/code&gt;. When running more than one client session, each session has its own set of variables. pgbench supports up to 255 variable uses in one statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b40deac5f431c882b47bcec560aceab88cb2ea" translate="yes" xml:space="preserve">
          <source>There is a strong connection between the XQuery language and XPath versions 2.0 and later: any expression that is syntactically valid and executes successfully in both produces the same result (with a minor exception for expressions containing numeric character references or predefined entity references, which XQuery replaces with the corresponding character while XPath leaves them alone). But there is no such connection between these languages and XPath 1.0; it was an earlier language and differs in many respects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c56c39bf47cf0690546e1095f601459a05ce75db" translate="yes" xml:space="preserve">
          <source>There is also a &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; parameter, which determines the placement of temporary tables and indexes, as well as temporary files that are used for purposes such as sorting large data sets. This can be a list of tablespace names, rather than only one, so that the load associated with temporary objects can be spread over multiple tablespaces. A random member of the list is picked each time a temporary object is to be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b9a64bc7c6fc9848f60613899f8c2ff0dc12dc" translate="yes" xml:space="preserve">
          <source>There is also a non-default GIN operator class &lt;code&gt;gin__int_ops&lt;/code&gt; supporting the same operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6db9a7a400632bced3a61ed8d0f591628a4c78" translate="yes" xml:space="preserve">
          <source>There is also a single-argument &lt;code&gt;to_timestamp&lt;/code&gt; function; see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-TABLE&quot;&gt;Table 9.31&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41669b255a0d94f06b45d60440ba0720ed574d46" translate="yes" xml:space="preserve">
          <source>There is also a two-parameter version of &lt;code&gt;xslt_process&lt;/code&gt; which does not pass any parameters to the transformation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ad78e13b5545fbac4993cd2573ccb0145f0260a" translate="yes" xml:space="preserve">
          <source>There is also an &lt;code&gt;include_if_exists&lt;/code&gt; directive, which acts the same as the &lt;code&gt;include&lt;/code&gt; directive, except when the referenced file does not exist or cannot be read. A regular &lt;code&gt;include&lt;/code&gt; will consider this an error condition, but &lt;code&gt;include_if_exists&lt;/code&gt; merely logs a message and continues processing the referencing configuration file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87e6a166488f605dc208dade3f60cf2f1017cef3" translate="yes" xml:space="preserve">
          <source>There is also an exception to the exception: I/O conversion casts from composite types to string types cannot be invoked using functional syntax, but must be written in explicit cast syntax (either &lt;code&gt;CAST&lt;/code&gt; or &lt;code&gt;::&lt;/code&gt; notation). This exception was added because after the introduction of automatically-provided I/O conversion casts, it was found too easy to accidentally invoke such a cast when a function or column reference was intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e49e8f0395261cca6c9bddfde366e5b44bc0fa" translate="yes" xml:space="preserve">
          <source>There is also an option to grant privileges on all objects of the same type within one or more schemas. This functionality is currently supported only for tables, sequences, functions, and procedures. &lt;code&gt;ALL TABLES&lt;/code&gt; also affects views and foreign tables, just like the specific-object &lt;code&gt;GRANT&lt;/code&gt; command. &lt;code&gt;ALL FUNCTIONS&lt;/code&gt; also affects aggregate and window functions, but not procedures, again just like the specific-object &lt;code&gt;GRANT&lt;/code&gt; command. Use &lt;code&gt;ALL ROUTINES&lt;/code&gt; to include procedures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a702bafff3c7f4c616d64a2b71bb4d856736202" translate="yes" xml:space="preserve">
          <source>There is also the prefix operator &lt;code&gt;^@&lt;/code&gt; and corresponding &lt;code&gt;starts_with&lt;/code&gt; function which covers cases when only searching by beginning of the string is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012b88356356711e33f301f2bb1596f7e0f835cc" translate="yes" xml:space="preserve">
          <source>There is an example in &lt;code&gt;autoinc.example&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93425455a73285f0e21d7315c96b601935f70ba0" translate="yes" xml:space="preserve">
          <source>There is an example in &lt;code&gt;insert_username.example&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b24fdd30442f553bc5891f105491e9f92bd108" translate="yes" xml:space="preserve">
          <source>There is an example in &lt;code&gt;moddatetime.example&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2b9c61965fcc66e74624ddfce72996d337e8786" translate="yes" xml:space="preserve">
          <source>There is an inherent ambiguity between octal character-entry escapes and back references, which is resolved by the following heuristics, as hinted at above. A leading zero always indicates an octal escape. A single non-zero digit, not followed by another digit, is always taken as a back reference. A multi-digit sequence not starting with a zero is taken as a back reference if it comes after a suitable subexpression (i.e., the number is in the legal range for a back reference), and otherwise is taken as octal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d4f42c096704e40b12586b5cb5d82cbdaf1b311" translate="yes" xml:space="preserve">
          <source>There is an optional second parameter of type &lt;code&gt;boolean&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, it specifies executing &lt;code&gt;pg_start_backup&lt;/code&gt; as quickly as possible. This forces an immediate checkpoint which will cause a spike in I/O operations, slowing any concurrently executing queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39681348944621b0cbdb87c4dd79d5e8a6ab1c87" translate="yes" xml:space="preserve">
          <source>There is another important concept associated with window functions: for each row, there is a set of rows within its partition called its &lt;em&gt;window frame&lt;/em&gt;. Some window functions act only on the rows of the window frame, rather than of the whole partition. By default, if &lt;code&gt;ORDER BY&lt;/code&gt; is supplied then the frame consists of all rows from the start of the partition up through the current row, plus any following rows that are equal to the current row according to the &lt;code&gt;ORDER BY&lt;/code&gt; clause. When &lt;code&gt;ORDER BY&lt;/code&gt; is omitted the default frame consists of all rows in the partition. &lt;a href=&quot;#ftn.id-1.4.5.6.9.5&quot;&gt;&lt;sup id=&quot;id-1.4.5.6.9.5&quot;&gt;[4]&lt;/sup&gt;&lt;/a&gt; Here is an example using &lt;code&gt;sum&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64034dc768225bc4dcced9797dcc3830def63396" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f28370d7fe3178c0f150cc0dec3299397ce3c2af" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER COLLATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7babd298f2e4c509f069c94f5602aeb995a6b57c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER CONVERSION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928fd572e35641041e67b18e6e748efce3723a8c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991bfb585377a575377a77fe428cfaf85a73d860" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER EVENT TRIGGER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d77ec038759f5fffa10b0b08001ebb09342372d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER GROUP&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb57388d9f735799eb7b9b89ff35e3d5ef151e31" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER LANGUAGE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1637168216f474c65041857a21d81b0e4a440e97" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER LARGE OBJECT&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345d872d60a75b2e0f9d89245157411db046f3d0" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER OPERATOR CLASS&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fcc86f4b1945452fb4d2e3306232b8ba831ba49" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc28991fbce6444e2838b4c5b330fc7e8b89d499" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER OPERATOR&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2506d4e215504a7cdfcb1194c2679242cc54a59e" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER SCHEMA&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2964377f745afad2429ec74b207708196b68d312" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER STATISTICS&lt;/code&gt; command in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3931d89739bf4a90fd967b4f0a43fada449313" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TABLESPACE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e24f943c01b48797aaba76a9060c58b771452dd4" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee71505e9ca52479c60dc800cccb5a32c56fe24" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d50e75d0db9753a5bb17ed4059457e195c3fbe78" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH PARSER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2e5183222d4bb5c821f92f235643d98359507e9" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH TEMPLATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e08ef635bc500a8ffe34e71b4cb60735a3f59c83" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ANALYZE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab267186c8c406bf12491cd64160dcb07b24078" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CLUSTER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29db8edfc564e2f37aa124a9094dedfa5dc75ca" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;COMMENT&lt;/code&gt; command in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51ffc421257a5e488b200464e2482e6c0cb494cc" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;COPY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1ea525f2af46d628097a5d99e04b04f3dea2225" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE DATABASE&lt;/code&gt; statement in the SQL standard. Databases are equivalent to catalogs, whose creation is implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1892a6f6e1f58d3b4418aa1f7caf04e29a8df179" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bd71c5d0a01b45b44b80fcee88ed4660e223ea1" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE GROUP&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39953cfa3881edf0f677e0b9a6a85f9dce8605d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE STATISTICS&lt;/code&gt; command in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="502eb254142165b2715d9eff63db5d89a608e2d7" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH CONFIGURATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609c741f2314d56bf655daef547dcb2a0644be82" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH DICTIONARY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41df83262dc2c3b270bf89a5b823f9c05295e631" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH PARSER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec4376bb5fb0542843f635e97909a4ca5d798c55" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH TEMPLATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb922403a157a64a60a934905fa24aa07814119" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DO&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="453ae3f4ad66d52b89a14781b63b1f82ed5a0eba" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP AGGREGATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec0e29fd940c929987502b958108c6376839288" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP CONVERSION&lt;/code&gt; statement in the SQL standard, but a &lt;code&gt;DROP TRANSLATION&lt;/code&gt; statement that goes along with the &lt;code&gt;CREATE TRANSLATION&lt;/code&gt; statement that is similar to the &lt;code&gt;CREATE CONVERSION&lt;/code&gt; statement in PostgreSQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb09b1464adf925f06c0292814700fb9b8091f6c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP DATABASE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c4c010988712d96dd1e79f98080f9432271062" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP EVENT TRIGGER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75623002e2b624abb982d948db215c1dd60a52cc" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP GROUP&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a5387a3bec15b9e950f163994562d5efac89f3" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP LANGUAGE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d30fcc924219aba17a45fb588c01476a1e9ff6" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP OPERATOR CLASS&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a4d8ad142bdd21f8d4bd8875a49f33849bf5d39" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP OPERATOR FAMILY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20b4d42336169eb36dbc8e0af63669368391995e" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP OPERATOR&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ab45de26ec7860503bcd3c1a242a1a6a072838" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP STATISTICS&lt;/code&gt; command in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33a3a716e771311567ab1607e35bf61106da647f" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH CONFIGURATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff33e4bc1ee2eee7f638d4f9ffce00160a3d8ec" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH DICTIONARY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f0a322ac87aa6f316366f64468b6a33b449141" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH PARSER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caba21772330bd3e8d6bc5c0114bed4813577256" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH TEMPLATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6a0d8e969d6d60c24413dee9ec35d4707051d7" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;EXPLAIN&lt;/code&gt; statement defined in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3188600a38497d7445251ce699c39dbe875e80ee" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;LISTEN&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89782cda07082f5c8f4d6514f108dab71bcfa4d2" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;LOCK TABLE&lt;/code&gt; in the SQL standard, which instead uses &lt;code&gt;SET TRANSACTION&lt;/code&gt; to specify concurrency levels on transactions. PostgreSQL supports that too; see &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f784f25d51430ade6f35b2e081075babec2e0fe" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;MOVE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a168bea72d9806503f40f80aa12982ca9fd8601" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;NOTIFY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1257ab0b3946084dffdd621f7db244f79c25f5" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;REINDEX&lt;/code&gt; command in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9129bb3a754d8cf06ba21c59dfcd6069ee5971c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;SECURITY LABEL&lt;/code&gt; command in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c399b535d16a105f07135d4035417088b1dcc4" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;UNLISTEN&lt;/code&gt; command in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a373be7f6f352e566798cf5a1903b201f8406b2" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;VACUUM&lt;/code&gt; statement in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaadde692acdf895866b856cf669a3d745361c1a" translate="yes" xml:space="preserve">
          <source>There is no alignment padding or any other extra data between fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9b8c9e107ad42ee0fad08dd8f24c67ee8d865a" translate="yes" xml:space="preserve">
          <source>There is no automatic way to verify that all of the &lt;code&gt;CHECK&lt;/code&gt; constraints are mutually exclusive. It is safer to create code that generates child tables and creates and/or modifies associated objects than to write each by hand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9b18acfad0da6c23024f7c2509d5457d17977e" translate="yes" xml:space="preserve">
          <source>There is no comparably easy way to determine a next OID that's beyond the largest one in the database, but fortunately it is not critical to get the next-OID setting right.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db36b67fac0c975746b2d641f8b3943a36d8046" translate="yes" xml:space="preserve">
          <source>There is no cross-checking of indexes against their heap relation during normal operation. Symptoms of heap corruption can be subtle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96dd49b9a313a343547338d49ed17c06a38c1a6" translate="yes" xml:space="preserve">
          <source>There is no dependent object; this type of entry is a signal that the system itself depends on the referenced object, and so that object must never be deleted. Entries of this type are created only by &lt;code&gt;initdb&lt;/code&gt;. The columns for the dependent object contain zeroes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70fc6506fe197311ab91bc28b3e88218eb7eab49" translate="yes" xml:space="preserve">
          <source>There is no general method of repairing problems that &lt;code&gt;amcheck&lt;/code&gt; detects. An explanation for the root cause of an invariant violation should be sought. &lt;a href=&quot;pageinspect&quot;&gt;pageinspect&lt;/a&gt; may play a useful role in diagnosing corruption that &lt;code&gt;amcheck&lt;/code&gt; detects. A &lt;code&gt;REINDEX&lt;/code&gt; may not be effective in repairing corruption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f84235bff819237a1da91e8e95c005f22d0298e2" translate="yes" xml:space="preserve">
          <source>There is no length limit on the input strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dbeb068f00ac522f4db315c80e9ac31689bfd87" translate="yes" xml:space="preserve">
          <source>There is no linguistic support, even for English. Regular expressions are not sufficient because they cannot easily handle derived words, e.g., &lt;code&gt;satisfies&lt;/code&gt; and &lt;code&gt;satisfy&lt;/code&gt;. You might miss documents that contain &lt;code&gt;satisfies&lt;/code&gt;, although you probably would like to find them when searching for &lt;code&gt;satisfy&lt;/code&gt;. It is possible to use &lt;code&gt;OR&lt;/code&gt; to search for multiple derived forms, but this is tedious and error-prone (some words can have several thousand derivatives).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e118a7d0adfb0e635c9d07f655d84a8ad88c12" translate="yes" xml:space="preserve">
          <source>There is no mechanism to enforce uniqueness of standby names. In case of duplicates one of the matching standbys will be considered as higher priority, though exactly which one is indeterminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6e31417005e5059c60745bca02997125074c26" translate="yes" xml:space="preserve">
          <source>There is no need to grant privileges to the owner of an object (usually the user that created it), as the owner has all privileges by default. (The owner could, however, choose to revoke some of their own privileges for safety.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ae1505daac493ace3132ae554c6ea20c2ba190" translate="yes" xml:space="preserve">
          <source>There is no performance difference among these three types, apart from increased storage space when using the blank-padded type, and a few extra CPU cycles to check the length when storing into a length-constrained column. While &lt;code&gt;character(n)&lt;/code&gt; has performance advantages in some other database systems, there is no such advantage in PostgreSQL; in fact &lt;code&gt;character(n)&lt;/code&gt; is usually the slowest of the three because of its additional storage costs. In most situations &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;character varying&lt;/code&gt; should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8afc4737cc902a7afc20e4910e033de6ddabdb93" translate="yes" xml:space="preserve">
          <source>There is no restriction regarding how many database users a given operating system user can correspond to, nor vice versa. Thus, entries in a map should be thought of as meaning &amp;ldquo;this operating system user is allowed to connect as this database user&amp;rdquo;, rather than implying that they are equivalent. The connection will be allowed if there is any map entry that pairs the user name obtained from the external authentication system with the database user name that the user has requested to connect as.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d6a72d9fa9097f88cd465d659b996359e6595c" translate="yes" xml:space="preserve">
          <source>There is no result row for the city of Hayward. This is because there is no matching entry in the &lt;code&gt;cities&lt;/code&gt; table for Hayward, so the join ignores the unmatched rows in the &lt;code&gt;weather&lt;/code&gt; table. We will see shortly how this can be fixed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb859432422d8124605fd6fa0a5ba7fbb347c338" translate="yes" xml:space="preserve">
          <source>There is no way to create an exclusion constraint spanning all partitions; it is only possible to constrain each leaf partition individually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b5bd62ec3737bfec14cadfb61679b8166c57b55" translate="yes" xml:space="preserve">
          <source>There is one row for each buffer in the shared cache. Unused buffers are shown with all fields null except &lt;code&gt;bufferid&lt;/code&gt;. Shared system catalogs are shown as belonging to database zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f45963e6e5833c88c83b3b4b867ec971de5358c8" translate="yes" xml:space="preserve">
          <source>There is only one &lt;code&gt;round&lt;/code&gt; function that takes two arguments; it takes a first argument of type &lt;code&gt;numeric&lt;/code&gt; and a second argument of type &lt;code&gt;integer&lt;/code&gt;. So the following query automatically converts the first argument of type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;numeric&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9159e4fda642d08346e94fb2d3ac2dbc99a478a" translate="yes" xml:space="preserve">
          <source>There is only one factorial operator (postfix &lt;code&gt;!&lt;/code&gt;) defined in the standard catalog, and it takes an argument of type &lt;code&gt;bigint&lt;/code&gt;. The scanner assigns an initial type of &lt;code&gt;integer&lt;/code&gt; to the argument in this query expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0c7153374d6f701aba32a67304ea000734d416" translate="yes" xml:space="preserve">
          <source>There is presently no security mechanism for viewing comments: any user connected to a database can see all the comments for objects in that database. For shared objects such as databases, roles, and tablespaces, comments are stored globally so any user connected to any database in the cluster can see all the comments for shared objects. Therefore, don't put security-critical information in comments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e848fe2ab9f9a42478fab56269c47dd1ce42078d" translate="yes" xml:space="preserve">
          <source>There is usually not much point in making more than one tablespace per logical file system, since you cannot control the location of individual files within a logical file system. However, PostgreSQL does not enforce any such limitation, and indeed it is not directly aware of the file system boundaries on your system. It just stores files in the directories you tell it to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d953cfaaf0252b15b02b8c9a112ebe99c8fa7d20" translate="yes" xml:space="preserve">
          <source>There must also be matching child-table constraints for all &lt;code&gt;CHECK&lt;/code&gt; constraints of the parent, except those marked non-inheritable (that is, created with &lt;code&gt;ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT&lt;/code&gt;) in the parent, which are ignored; all child-table constraints matched must not be marked non-inheritable. Currently &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, and &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints are not considered, but this might change in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d0ef1c54ee5da6f3a9bc0faf2941d2e26078541" translate="yes" xml:space="preserve">
          <source>There should be no extra overhead in the parser or executor if a query does not need implicit type conversion. That is, if a query is well-formed and the types already match, then the query should execute without spending extra time in the parser and without introducing unnecessary implicit conversion calls in the query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="934618c1781f2f0a9f6bb79bbcc267c826504412" translate="yes" xml:space="preserve">
          <source>There was formerly an &lt;code&gt;ALTER INDEX OWNER&lt;/code&gt; variant, but this is now ignored (with a warning). An index cannot have an owner different from its table's owner. Changing the table's owner automatically changes the index as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb82410dec70b2b3321bff0d1e9388c3bd8dfd33" translate="yes" xml:space="preserve">
          <source>There's no need to manually create indexes on unique columns; doing so would just duplicate the automatically-created index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd1c3102c4930b5f2a44ebfcda5a098872c67837" translate="yes" xml:space="preserve">
          <source>Thesauruses are used during indexing so any change in the thesaurus dictionary's parameters &lt;em&gt;requires&lt;/em&gt; reindexing. For most other dictionary types, small changes such as adding or removing stopwords does not force reindexing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f1ad8c9ce64bcda09c594082de2a500ef5cce09" translate="yes" xml:space="preserve">
          <source>These are actually just special cases of the general casting notations discussed next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ede3bb37d9693ab9536c9fcd48ebe3c46555fd8" translate="yes" xml:space="preserve">
          <source>These are good sources to start learning about various kinds of encoding systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a4a0666760118b211b5b7d0b41910720c832114" translate="yes" xml:space="preserve">
          <source>These are less likely to be problematic than &lt;code&gt;search_path&lt;/code&gt;, but can be handled with function &lt;code&gt;SET&lt;/code&gt; options if the need arises.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e09b98f630a14c95107bbc1d571768385072e6a7" translate="yes" xml:space="preserve">
          <source>These are some examples of valid numeric constants:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d394fc649569a5eeeb4c5600c0f12014850ba1f" translate="yes" xml:space="preserve">
          <source>These are the steps to perform an upgrade with pg_upgrade:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72a6870691351c5c2b87041a8d81f8e78b27456" translate="yes" xml:space="preserve">
          <source>These attributes inform the query optimizer about the behavior of the function. At most one choice can be specified. If none of these appear, &lt;code&gt;VOLATILE&lt;/code&gt; is the default assumption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85846f94f84f78007c888a90fb32598de3ea04f" translate="yes" xml:space="preserve">
          <source>These caches can typically be disabled; however, the method for doing this varies by operating system and drive type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484e4f03dd4a3ca589988330c2b61dd6c51084dd" translate="yes" xml:space="preserve">
          <source>These clauses alter attributes originally set by &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. For more information, see the &lt;code&gt;CREATE ROLE&lt;/code&gt; reference page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae13d4d630a34fa139e9046de2cb8f6bc13b3a42" translate="yes" xml:space="preserve">
          <source>These clauses define a role's ability to create databases. If &lt;code&gt;CREATEDB&lt;/code&gt; is specified, the role being defined will be allowed to create new databases. Specifying &lt;code&gt;NOCREATEDB&lt;/code&gt; will deny a role the ability to create databases. If not specified, &lt;code&gt;NOCREATEDB&lt;/code&gt; is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="236a4db02b1fa5b8bc065150c9e1f92cd0c2db65" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role &amp;ldquo;inherits&amp;rdquo; the privileges of roles it is a member of. A role with the &lt;code&gt;INHERIT&lt;/code&gt; attribute can automatically use whatever database privileges have been granted to all roles it is directly or indirectly a member of. Without &lt;code&gt;INHERIT&lt;/code&gt;, membership in another role only grants the ability to &lt;code&gt;SET ROLE&lt;/code&gt; to that other role; the privileges of the other role are only available after having done so. If not specified, &lt;code&gt;INHERIT&lt;/code&gt; is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f7e3712b4368e28fc6b45f7eab106b1e33840d" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role bypasses every row-level security (RLS) policy. &lt;code&gt;NOBYPASSRLS&lt;/code&gt; is the default. Note that pg_dump will set &lt;code&gt;row_security&lt;/code&gt; to &lt;code&gt;OFF&lt;/code&gt; by default, to ensure all contents of a table are dumped out. If the user running pg_dump does not have appropriate permissions, an error will be returned. The superuser and owner of the table being dumped always bypass RLS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdfb1f660e91b5c6f6fdf7bb5b01ee2031a6647b" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role is a replication role. A role must have this attribute (or be a superuser) in order to be able to connect to the server in replication mode (physical or logical replication) and in order to be able to create or drop replication slots. A role having the &lt;code&gt;REPLICATION&lt;/code&gt; attribute is a very highly privileged role, and should only be used on roles actually used for replication. If not specified, &lt;code&gt;NOREPLICATION&lt;/code&gt; is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93cac2364d542f963f918606f10bb473c25cf54c" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role is allowed to log in; that is, whether the role can be given as the initial session authorization name during client connection. A role having the &lt;code&gt;LOGIN&lt;/code&gt; attribute can be thought of as a user. Roles without this attribute are useful for managing database privileges, but are not users in the usual sense of the word. If not specified, &lt;code&gt;NOLOGIN&lt;/code&gt; is the default, except when &lt;code&gt;CREATE ROLE&lt;/code&gt; is invoked through its alternative spelling &lt;a href=&quot;sql-createuser&quot;&gt;CREATE USER&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181b83412fd4eddb3ac3029828e16b7a9b6b98ef" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role will be permitted to create new roles (that is, execute &lt;code&gt;CREATE ROLE&lt;/code&gt;). A role with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can also alter and drop other roles. If not specified, &lt;code&gt;NOCREATEROLE&lt;/code&gt; is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0e211b5e3eb630f6887dce4107cdd808855949" translate="yes" xml:space="preserve">
          <source>These clauses determine whether the new role is a &amp;ldquo;superuser&amp;rdquo;, who can override all access restrictions within the database. Superuser status is dangerous and should be used only when really needed. You must yourself be a superuser to create a new superuser. If not specified, &lt;code&gt;NOSUPERUSER&lt;/code&gt; is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a59cdbb5e799d0fed1a4aa2596214d1849fd5f" translate="yes" xml:space="preserve">
          <source>These clauses specify a foreign key constraint, which requires that a group of one or more columns of the new table must only contain values that match values in the referenced column(s) of some row of the referenced table. If the &lt;code&gt;refcolumn&lt;/code&gt; list is omitted, the primary key of the &lt;code&gt;reftable&lt;/code&gt; is used. The referenced columns must be the columns of a non-deferrable unique or primary key constraint in the referenced table. The user must have &lt;code&gt;REFERENCES&lt;/code&gt; permission on the referenced table (either the whole table, or the specific referenced columns). The addition of a foreign key constraint requires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock on the referenced table. Note that foreign key constraints cannot be defined between temporary tables and permanent tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="857c0ae8d220b45b3955f09362ef789a9a3402e5" translate="yes" xml:space="preserve">
          <source>These commands are defined in the SQL standard, except for the &lt;code&gt;DEFERRABLE&lt;/code&gt; transaction mode and the &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; form, which are PostgreSQL extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a3af7e0da0acbd34de05752f110be6e0e62942" translate="yes" xml:space="preserve">
          <source>These configuration parameters provide a crude method of influencing the query plans chosen by the query optimizer. If the default plan chosen by the optimizer for a particular query is not optimal, a &lt;em&gt;temporary&lt;/em&gt; solution is to use one of these configuration parameters to force the optimizer to choose a different plan. Better ways to improve the quality of the plans chosen by the optimizer include adjusting the planner cost constants (see &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;), running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; manually, increasing the value of the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration parameter, and increasing the amount of statistics collected for specific columns using &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b05ff9bc8f45601af490580b1cf57f630e4008" translate="yes" xml:space="preserve">
          <source>These cost-based decisions will be made at plan time, not execution time. This means that when prepared statements are in use, and a generic plan is used (see &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;), the values of the configuration parameters in effect at prepare time control the decisions, not the settings at execution time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd102e49cf8b96793cacdde24d32614ffb078540" translate="yes" xml:space="preserve">
          <source>These counts can be particularly valuable for filter conditions applied at join nodes. The &amp;ldquo;Rows Removed&amp;rdquo; line only appears when at least one scanned row, or potential join pair in the case of a join node, is rejected by the filter condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ee06a454af3afd2603bd1ff07db9463f13f34e" translate="yes" xml:space="preserve">
          <source>These examples show use of &lt;code&gt;position&lt;/code&gt; fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e22989ebfc8062e1b7b80c3eb7a3f32777c7de5c" translate="yes" xml:space="preserve">
          <source>These examples would all specify the same address. Upper and lower case is accepted for the digits &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt;. Output is always in the first of the forms shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef90197c0c87bcadf3fd64cda40bcfb6928639b3" translate="yes" xml:space="preserve">
          <source>These examples would all specify the same address. Upper and lower case is accepted for the digits &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt;. Output is always in the first of the forms shown. The last six input formats that are mentioned above are not part of any standard. To convert a traditional 48 bit MAC address in EUI-48 format to modified EUI-64 format to be included as the host portion of an IPv6 address, use &lt;code&gt;macaddr8_set7bit&lt;/code&gt; as shown:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="754aea8d14b67db99a02b25bbf6a65624166cf06" translate="yes" xml:space="preserve">
          <source>These fields only apply to &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;hostssl&lt;/code&gt;, and &lt;code&gt;hostnossl&lt;/code&gt; records.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72eddf11f12dc6025be9e6bc42deb5078bd81869" translate="yes" xml:space="preserve">
          <source>These forms alter the sequence that underlies an existing identity column. &lt;code&gt;sequence_option&lt;/code&gt; is an option supported by &lt;a href=&quot;sql-altersequence&quot;&gt;ALTER SEQUENCE&lt;/a&gt; such as &lt;code&gt;INCREMENT BY&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94eb82c63d8a50cb48f48fc67bdfcbfef03ff87e" translate="yes" xml:space="preserve">
          <source>These forms change whether a column is an identity column or change the generation attribute of an existing identity column. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41d9a5a685b55548689fcb598e8403262b9b305" translate="yes" xml:space="preserve">
          <source>These forms change whether a column is marked to allow null values or to reject null values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ec998a277e66396552c3ff5dd5565fd0687627" translate="yes" xml:space="preserve">
          <source>These forms change whether a domain is marked to allow NULL values or to reject NULL values. You can only &lt;code&gt;SET NOT NULL&lt;/code&gt; when the columns using the domain contain no null values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6fb1f760d0b7848e70cd0fa414aa5c5a55c2d88" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of event triggers. A disabled trigger is still known to the system, but is not executed when its triggering event occurs. See also &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed16a2682c252a84ef2e6b9d1135068b069708b2" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of rewrite rules belonging to the table. A disabled rule is still known to the system, but is not applied during query rewriting. The semantics are as for disabled/enabled triggers. This configuration is ignored for &lt;code&gt;ON SELECT&lt;/code&gt; rules, which are always applied in order to keep views working even if the current session is in a non-default replication role.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d1881ed192b61ccc8ca5381f7ecf2d5ccbebb4" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of trigger(s) belonging to the foreign table. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="537c2d5f6bf4afe4d0ece015a719f2c170c94088" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of trigger(s) belonging to the table. A disabled trigger is still known to the system, but is not executed when its triggering event occurs. For a deferred trigger, the enable status is checked when the event occurs, not when the trigger function is actually executed. One can disable or enable a single trigger specified by name, or all triggers on the table, or only user triggers (this option excludes internally generated constraint triggers such as those that are used to implement foreign key constraints or deferrable uniqueness and exclusion constraints). Disabling or enabling internally generated constraint triggers requires superuser privileges; it should be done with caution since of course the integrity of the constraint cannot be guaranteed if the triggers are not executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e52e37f61e3318ab7cf1d7a034b06767466f19cd" translate="yes" xml:space="preserve">
          <source>These forms control the application of row security policies belonging to the table when the user is the table owner. If enabled, row level security policies will be applied when the user is the table owner. If disabled (the default) then row level security will not be applied when the user is the table owner. See also &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b1a193cdfbb05ae9fcb8caf7ab280345bebc71" translate="yes" xml:space="preserve">
          <source>These forms control the application of row security policies belonging to the table. If enabled and no policies exist for the table, then a default-deny policy is applied. Note that policies can exist for a table even if row level security is disabled - in this case, the policies will NOT be applied and the policies will be ignored. See also &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ad545d11775ef6194d67bbd91b31263b043327" translate="yes" xml:space="preserve">
          <source>These forms set or remove the default value for a column. A view column's default value is substituted into any &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; command whose target is the view, before applying any rules or triggers for the view. The view's default will therefore take precedence over any default values from underlying relations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f96c4d1ee03fc069f57f93ee22ce31fb12871d" translate="yes" xml:space="preserve">
          <source>These forms set or remove the default value for a column. Default values only apply in subsequent &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; commands; they do not cause rows already in the table to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9f74070b70e1b37c8a8a55a2765bed5bb39ae4b" translate="yes" xml:space="preserve">
          <source>These forms set or remove the default value for a domain. Note that defaults only apply to subsequent &lt;code&gt;INSERT&lt;/code&gt; commands; they do not affect rows already in a table using the domain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1609442aa33410461ce94595a5363c37f09493d1" translate="yes" xml:space="preserve">
          <source>These functions are provided mostly for illustration purposes. You can create your own return types and functions based on the underlying &lt;code&gt;crosstab()&lt;/code&gt; function. There are two ways to do it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b71ab786c550ccb22b4bc0a42b2b14940119395f" translate="yes" xml:space="preserve">
          <source>These functions check whether a &lt;code&gt;text&lt;/code&gt; string is well-formed XML, returning a Boolean result. &lt;code&gt;xml_is_well_formed_document&lt;/code&gt; checks for a well-formed document, while &lt;code&gt;xml_is_well_formed_content&lt;/code&gt; checks for well-formed content. &lt;code&gt;xml_is_well_formed&lt;/code&gt; does the former if the &lt;a href=&quot;runtime-config-client#GUC-XMLOPTION&quot;&gt;xmloption&lt;/a&gt; configuration parameter is set to &lt;code&gt;DOCUMENT&lt;/code&gt;, or the latter if it is set to &lt;code&gt;CONTENT&lt;/code&gt;. This means that &lt;code&gt;xml_is_well_formed&lt;/code&gt; is useful for seeing whether a simple cast to type &lt;code&gt;xml&lt;/code&gt; will succeed, whereas the other two functions are useful for seeing whether the corresponding variants of &lt;code&gt;XMLPARSE&lt;/code&gt; will succeed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c60a18e52593260f76cbca36e7fdad5953d14de4" translate="yes" xml:space="preserve">
          <source>These functions evaluate the XPath query on the supplied document, and cast the result to the specified type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a3b49c368c625ddd8e1b267d172c4c23e85fb8" translate="yes" xml:space="preserve">
          <source>These functions only run a cipher over data; they don't have any advanced features of PGP encryption. Therefore they have some major problems:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e87e18038a41ce286dc1540ea6ddc6645f709cb" translate="yes" xml:space="preserve">
          <source>These functions wrap/unwrap binary data into PGP ASCII-armor format, which is basically Base64 with CRC and additional formatting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a69e2cf20fe43ca97cfd2d3152291de2a47cffbd" translate="yes" xml:space="preserve">
          <source>These instructions assume that your existing installation is under the &lt;code&gt;/usr/local/pgsql&lt;/code&gt; directory, and that the data area is in &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt;. Substitute your paths appropriately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c32652f01e68dc2b9e4e1795da20ec44b710efa" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on casts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea3c1233d30126b2b7a88c0987f5eda6383c5d4" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on conversions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd011ed971053a775e55c8199ea3272eca8d26f" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on policies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e707f7bc3e009a0e21e941c667a8cfc394f561" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on publications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c4da55bd25afdbc9c41ed6381881695d3bb025" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on subscriptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7609a430b2441baa8c916ed20ac5c190ce5d75" translate="yes" xml:space="preserve">
          <source>These messages are harmless and should be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c905ac1adcf65ee4d503774195629e18e03ce45" translate="yes" xml:space="preserve">
          <source>These numbers are current as of the last &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;ANALYZE&lt;/code&gt; on the table. The planner then fetches the actual current number of pages in the table (this is a cheap operation, not requiring a table scan). If that is different from &lt;code&gt;relpages&lt;/code&gt; then &lt;code&gt;reltuples&lt;/code&gt; is scaled accordingly to arrive at a current number-of-rows estimate. In the example above, the value of &lt;code&gt;relpages&lt;/code&gt; is up-to-date so the rows estimate is the same as &lt;code&gt;reltuples&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e10d3fa9498e1464949f282d6e93d894677beaed" translate="yes" xml:space="preserve">
          <source>These numbers are derived very straightforwardly. If you do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ceb62071b97b9d98e29565b51240d61862b6aa6" translate="yes" xml:space="preserve">
          <source>These operations are also possible using &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;. &lt;code&gt;ALTER INDEX&lt;/code&gt; is in fact just an alias for the forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; that apply to indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="545a0c8a716c900f9e4c80a9d1bee182bedf1b50" translate="yes" xml:space="preserve">
          <source>These operations are not as efficient as the SQL &lt;code&gt;COPY&lt;/code&gt; command with a file or program data source or destination, because all data must pass through the client/server connection. For large amounts of data the SQL command might be preferable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127d5c1d5ec611dd1c5cea591e059868fdcde0f9" translate="yes" xml:space="preserve">
          <source>These operators do not make a lot of sense for any practical purpose but sorting. These operators first compare (a) to (c), and if these are equal, compare (b) to (d). That results in reasonably good sorting in most cases, which is useful if you want to use ORDER BY with this type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0263a47917171f02351f77d8e8b63fd3b27641de" translate="yes" xml:space="preserve">
          <source>These option names are recognized case-insensitively. Any unspecified options receive these defaults:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae23616e05cfe7a713aa38934f0f1dc39a127ad" translate="yes" xml:space="preserve">
          <source>These options can be used to control the names used in SQL statements sent to the remote PostgreSQL server. These options are needed when a foreign table is created with names different from the underlying remote table's names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77fba085883250197e1d576feb3bfa1670ceb86" translate="yes" xml:space="preserve">
          <source>These options can only be specified for a foreign table or its columns, not in the options of the &lt;code&gt;file_fdw&lt;/code&gt; foreign-data wrapper, nor in the options of a server or user mapping using the wrapper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c89bc3ee002172b7e73344d78285229be1f391" translate="yes" xml:space="preserve">
          <source>These parameters (except the XPath strings) are just substituted into a plain SQL SELECT statement, so you have some flexibility &amp;mdash; the statement is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2aabd8f5a3412d7716945926dce543c9d86d614" translate="yes" xml:space="preserve">
          <source>These parameters can be set on any server that is to send replication data to one or more standby servers. The master is always a sending server, so these parameters must always be set on the master. The role and meaning of these parameters does not change after a standby becomes the master.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c34294a4db205be8e19649f7f900fbda851ca14" translate="yes" xml:space="preserve">
          <source>These parameters can be set on the master/primary server that is to send replication data to one or more standby servers. Note that in addition to these parameters, &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; must be set appropriately on the master server, and optionally WAL archiving can be enabled as well (see &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-ARCHIVING&quot;&gt;Section 19.5.3&lt;/a&gt;). The values of these parameters on standby servers are irrelevant, although you may wish to set them there in preparation for the possibility of a standby becoming the master.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d75398d82f486d5c040810e5532c3a355a6c99c" translate="yes" xml:space="preserve">
          <source>These parameters control server-wide statistics collection features. When statistics collection is enabled, the data that is produced can be accessed via the &lt;code&gt;pg_stat&lt;/code&gt; and &lt;code&gt;pg_statio&lt;/code&gt; family of system views. Refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/monitoring.html&quot;&gt;Chapter 27&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7058fa11283b8e308dc5c38fd60ebf25607e531" translate="yes" xml:space="preserve">
          <source>These parameters enable various debugging output to be emitted. When set, they print the resulting parse tree, the query rewriter output, or the execution plan for each executed query. These messages are emitted at &lt;code&gt;LOG&lt;/code&gt; message level, so by default they will appear in the server log but will not be sent to the client. You can change that by adjusting &lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt; and/or &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt;. These parameters are off by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1defee4ea46ba6aaadce70e43d5781b50b0c40a2" translate="yes" xml:space="preserve">
          <source>These parameters must be set in &lt;code&gt;postgresql.conf&lt;/code&gt;. Typical usage might be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c50b20efcdf41bd58d1a6d4948e28cfd164232" translate="yes" xml:space="preserve">
          <source>These popular data structures were originally developed for in-memory usage. In main memory, they are usually designed as a set of dynamically allocated nodes linked by pointers. This is not suitable for direct storing on disk, since these chains of pointers can be rather long which would require too many disk accesses. In contrast, disk-based data structures should have a high fanout to minimize I/O. The challenge addressed by SP-GiST is to map search tree nodes to disk pages in such a way that a search need access only a few disk pages, even if it traverses many nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="929fc5ec9668da12721d514b3f6bf4c331845b00" translate="yes" xml:space="preserve">
          <source>These represent the IEEE 754 special values &amp;ldquo;infinity&amp;rdquo;, &amp;ldquo;negative infinity&amp;rdquo;, and &amp;ldquo;not-a-number&amp;rdquo;, respectively. When writing these values as constants in an SQL command, you must put quotes around them, for example &lt;code&gt;UPDATE table SET x = '-Infinity'&lt;/code&gt;. On input, these strings are recognized in a case-insensitive manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1107e48978793d7f588abce7216f17e213bc711" translate="yes" xml:space="preserve">
          <source>These rules are very similar to those for writing field values in composite-type literals. See &lt;a href=&quot;rowtypes#ROWTYPES-IO-SYNTAX&quot;&gt;Section 8.16.6&lt;/a&gt; for additional commentary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4ab75f18b56a1736b944ffdb026f1b2a9cc643" translate="yes" xml:space="preserve">
          <source>These semaphore-related settings are read-only as far as &lt;code&gt;sysctl&lt;/code&gt; is concerned, but can be set in &lt;code&gt;/boot/loader.conf&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0eb1c6b354c2721dc2500c187dae9d22e4b37ec" translate="yes" xml:space="preserve">
          <source>These settings can be set from &lt;code&gt;postgresql.conf&lt;/code&gt;, or within a session via the &lt;code&gt;SET&lt;/code&gt; command. Any user is allowed to change their session-local value. Changes in &lt;code&gt;postgresql.conf&lt;/code&gt; will affect existing sessions only if no session-local value has been established with &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0adef7245cebc3b52bd4dfc1694701eadaec06f1" translate="yes" xml:space="preserve">
          <source>These settings can be set from &lt;code&gt;postgresql.conf&lt;/code&gt;, or within a session via the &lt;code&gt;SET&lt;/code&gt; command; but only superusers can change them via &lt;code&gt;SET&lt;/code&gt;. Changes in &lt;code&gt;postgresql.conf&lt;/code&gt; will affect existing sessions only if no session-local value has been established with &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a83e5497c48f3fadb734c9a42de145288252b14" translate="yes" xml:space="preserve">
          <source>These settings can only be applied when the server starts, so any change requires restarting the server. Values for these settings are typically stored in the &lt;code&gt;postgresql.conf&lt;/code&gt; file, or passed on the command line when starting the server. Of course, settings with any of the lower &lt;code&gt;context&lt;/code&gt; types can also be set at server start time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02aa5756831dee127ec65944b5fa10a7b3de8a8e" translate="yes" xml:space="preserve">
          <source>These settings cannot be changed directly; they reflect internally determined values. Some of them may be adjustable by rebuilding the server with different configuration options, or by changing options supplied to &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="317e80ee1851e3545ba5ed374350ee15698895fc" translate="yes" xml:space="preserve">
          <source>These settings control how process titles of server processes are modified. Process titles are typically viewed using programs like ps or, on Windows, Process Explorer. See &lt;a href=&quot;monitoring-ps&quot;&gt;Section 27.1&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c21f5b22d74359b34a233de933da88c1556b1754" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of a logical replication subscriber. Their values on the publisher are irrelevant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51ac309dd49de1c6d6c04c1c54a256fdaeb98b75" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of a standby server that is to receive replication data. Their values on the master server are irrelevant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40b8d037fb02f22e279e00bffd1ef98f7d8c44d" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of the &lt;em&gt;autovacuum&lt;/em&gt; feature. Refer to &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information. Note that many of these settings can be overridden on a per-table basis; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c9c05e7e68e0c9931d3c483fab276d6098720bf" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of the built-in &lt;em&gt;streaming replication&lt;/em&gt; feature (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;). Servers will be either a master or a standby server. Masters can send data, while standbys are always receivers of replicated data. When cascading replication (see &lt;a href=&quot;warm-standby#CASCADING-REPLICATION&quot;&gt;Section 26.2.7&lt;/a&gt;) is used, standby servers can also be senders, as well as receivers. Parameters are mainly for sending and standby servers, though some parameters have meaning only on the master server. Settings may vary across the cluster without problems if that is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="631081e51e8d0c56dfb2edd79daea765216e4764" translate="yes" xml:space="preserve">
          <source>These settings will cause postmaster child processes to run with the normal OOM score adjustment of zero, so that the OOM killer can still target them at need. You could use some other value for &lt;code&gt;PG_OOM_ADJUST_VALUE&lt;/code&gt; if you want the child processes to run with some other OOM score adjustment. (&lt;code&gt;PG_OOM_ADJUST_VALUE&lt;/code&gt; can also be omitted, in which case it defaults to zero.) If you do not set &lt;code&gt;PG_OOM_ADJUST_FILE&lt;/code&gt;, the child processes will run with the same OOM score adjustment as the postmaster, which is unwise since the whole point is to ensure that the postmaster has a preferential setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab15e9b47def86730e35b3c5c50e0dfe3f834aa" translate="yes" xml:space="preserve">
          <source>These specify what the prompts psql issues should look like. See &lt;a href=&quot;app-psql#APP-PSQL-PROMPTING&quot;&gt;Prompting&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6086ed3e7f06eab1a2070198d662f5b66b1e6406" translate="yes" xml:space="preserve">
          <source>These trigger functions automatically compute a &lt;code&gt;tsvector&lt;/code&gt; column from one or more textual columns, under the control of parameters specified in the &lt;code&gt;CREATE TRIGGER&lt;/code&gt; command. An example of their use is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b286f322440c12ea3e3c031f3d293b77ba6582" translate="yes" xml:space="preserve">
          <source>These two fields can be used as an alternative to the &lt;code&gt;IP-address&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;mask-length&lt;/code&gt; notation. Instead of specifying the mask length, the actual mask is specified in a separate column. For example, &lt;code&gt;255.0.0.0&lt;/code&gt; represents an IPv4 CIDR mask length of 8, and &lt;code&gt;255.255.255.255&lt;/code&gt; represents a CIDR mask length of 32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b912ce7211a3c9dfe25f2009d32879c2b4a7718a" translate="yes" xml:space="preserve">
          <source>These variables are set at program start-up to reflect psql's version, respectively as a verbose string, a short string (e.g., &lt;code&gt;9.6.2&lt;/code&gt;, &lt;code&gt;10.1&lt;/code&gt;, or &lt;code&gt;11beta1&lt;/code&gt;), and a number (e.g., &lt;code&gt;90602&lt;/code&gt; or &lt;code&gt;100001&lt;/code&gt;). They can be changed or unset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1888af9231d7dc7892d920d2796a7d30d3c432b" translate="yes" xml:space="preserve">
          <source>These will always return true or false, never a null value, even when the operand is null. A null input is treated as the logical value &amp;ldquo;unknown&amp;rdquo;. Notice that &lt;code&gt;IS UNKNOWN&lt;/code&gt; and &lt;code&gt;IS NOT UNKNOWN&lt;/code&gt; are effectively the same as &lt;code&gt;IS NULL&lt;/code&gt; and &lt;code&gt;IS NOT NULL&lt;/code&gt;, respectively, except that the input expression must be of Boolean type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb77a6f9b66e9a05805238727dad27ac972c149a" translate="yes" xml:space="preserve">
          <source>They are slow. As the amount of data is so small, this is the only way to make brute-forcing passwords hard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf2c8c3d26564b271cd3b0f3cc01f4bc594ad56e" translate="yes" xml:space="preserve">
          <source>They don't handle text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89bd6007244204d4a23986add99e11b8144bb68e" translate="yes" xml:space="preserve">
          <source>They don't provide any integrity checking, to see if the encrypted data was modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108af784f0fd778d605e66d5a415819131da0024" translate="yes" xml:space="preserve">
          <source>They expect that users manage all encryption parameters themselves, even IV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2039617625e55d628a5303153737be520c2636" translate="yes" xml:space="preserve">
          <source>They include the algorithm type in the result, so passwords hashed with different algorithms can co-exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e7dceb3b44e3013034907236242ebd62f58f0d" translate="yes" xml:space="preserve">
          <source>They provide no ordering (ranking) of search results, which makes them ineffective when thousands of matching documents are found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c267279c3829425820b5af53bc51b1aea00680d" translate="yes" xml:space="preserve">
          <source>They tend to be slow because there is no index support, so they must process all documents for every search.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc6b695f1b5d50d9c60b39def6c93072e73b0c7c" translate="yes" xml:space="preserve">
          <source>They use a random value, called the &lt;em&gt;salt&lt;/em&gt;, so that users having the same password will have different encrypted passwords. This is also an additional defense against reversing the algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e85a3bee9adadb9e25e77dec1600e19104320bfe" translate="yes" xml:space="preserve">
          <source>They use user key directly as cipher key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dbebd5ef75455c0a62f167f8fa030487ae4ceab" translate="yes" xml:space="preserve">
          <source>Things are more difficult if you need to recover from corruption of an index on a system table. In this case it's important for the system to not have used any of the suspect indexes itself. (Indeed, in this sort of scenario you might find that server processes are crashing immediately at start-up, due to reliance on the corrupted indexes.) To recover safely, the server must be started with the &lt;code&gt;-P&lt;/code&gt; option, which prevents it from using indexes for system catalog lookups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f7dee4533ea61962d64e3ad5a7fcf16ccab0dd" translate="yes" xml:space="preserve">
          <source>Third, turn on &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt;. For security reasons, the rules in &lt;code&gt;sepgsql-regtest&lt;/code&gt; are not enabled by default; the &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; parameter enables the rules needed to launch the regression tests. It can be turned on using the &lt;code&gt;setsebool&lt;/code&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a4d63f55e2492f2cd42b3a9fb86caa1ca5e84c" translate="yes" xml:space="preserve">
          <source>Third-party applications can be put into separate schemas so they do not collide with the names of other objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04297a9823a3a2086d546b9d671ec1f8ab29f655" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;WITH&lt;/code&gt; query will be folded, producing the same execution plan as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ca478547dc2e8fab1f8f6bfce576b001fe2285" translate="yes" xml:space="preserve">
          <source>This access control mechanism is independent of the one described in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7fa7bd259660d0cb8e1608dc878af198c41a3a" translate="yes" xml:space="preserve">
          <source>This acquires a row-level lock on the row with the specified account number. Then, the second transaction executes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf940ef6c18dd4ff1a92a3955dc9c9d23c16666" translate="yes" xml:space="preserve">
          <source>This allows further operations to be performed on the data before it is dropped. For example, this is often a useful time to back up the data using &lt;code&gt;COPY&lt;/code&gt;, pg_dump, or similar tools. It might also be a useful time to aggregate data into smaller formats, perform other data manipulations, or run reports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb6b13498a74131eab9c57b3090da36c9ec9b3f" translate="yes" xml:space="preserve">
          <source>This allows sequential scans of large tables to synchronize with each other, so that concurrent scans read the same block at about the same time and hence share the I/O workload. When this is enabled, a scan might start in the middle of the table and then &amp;ldquo;wrap around&amp;rdquo; the end to cover all rows, so as to synchronize with the activity of scans already in progress. This can result in unpredictable changes in the row ordering returned by queries that have no &lt;code&gt;ORDER BY&lt;/code&gt; clause. Setting this parameter to &lt;code&gt;off&lt;/code&gt; ensures the pre-8.3 behavior in which a sequential scan always starts from the beginning of the table. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="253b2ab3ed8967081995487ba9ee5b4826393d61" translate="yes" xml:space="preserve">
          <source>This and other array operators are further described in &lt;a href=&quot;functions-array&quot;&gt;Section 9.18&lt;/a&gt;. It can be accelerated by an appropriate index, as described in &lt;a href=&quot;indexes-types&quot;&gt;Section 11.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f7125f90456e96d69dc4420ff05c41c76b48ac" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses BSD Authentication to verify the password. BSD Authentication is used only to validate user name/password pairs. Therefore the user's role must already exist in the database before BSD Authentication can be used for authentication. The BSD Authentication framework is currently only available on OpenBSD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a95a1004ec8979c4ed272cc869cffc8b380262" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses LDAP as the password verification method. LDAP is used only to validate the user name/password pairs. Therefore the user must already exist in the database before LDAP can be used for authentication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14894f744e61a4d997e0bd55d2f4134698e24251" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses PAM (Pluggable Authentication Modules) as the authentication mechanism. The default PAM service name is &lt;code&gt;postgresql&lt;/code&gt;. PAM is used only to validate user name/password pairs and optionally the connected remote host name or IP address. Therefore the user must already exist in the database before PAM can be used for authentication. For more information about PAM, please read the &lt;a href=&quot;https://www.kernel.org/pub/linux/libs/pam/&quot;&gt;Linux-PAM Page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd397f0c1d27e7e6f24266e4663491230029a1f" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses RADIUS as the password verification method. RADIUS is used only to validate the user name/password pairs. Therefore the user must already exist in the database before RADIUS can be used for authentication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699ba79710348057cae6bc38a6f4967f7fef3d56" translate="yes" xml:space="preserve">
          <source>This authentication method uses SSL client certificates to perform authentication. It is therefore only available for SSL connections. When using this authentication method, the server will require that the client provide a valid, trusted certificate. No password prompt will be sent to the client. The &lt;code&gt;cn&lt;/code&gt; (Common Name) attribute of the certificate will be compared to the requested database user name, and if they match the login will be allowed. User name mapping can be used to allow &lt;code&gt;cn&lt;/code&gt; to be different from the database user name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ac6c0054ced8ebe81d0f1a02772b68633401dc6" translate="yes" xml:space="preserve">
          <source>This behavior is desirable since it allows searches to work for both the whole compound word and for components. Here is another instructive example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="286f6e80e06ffd51f385da7d2a7694b40cc44231" translate="yes" xml:space="preserve">
          <source>This can be convenient to be able to use operating-system-independent collation names in applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb2c31cd20a3afc74e461bc50ba20daffd3b134" translate="yes" xml:space="preserve">
          <source>This can be implemented quite efficiently by GiST indexes, but not by GIN indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c9965536e9eb1807b9625445e1dc9ee486d49c" translate="yes" xml:space="preserve">
          <source>This can be implemented quite efficiently by GiST indexes, but not by GIN indexes. It will usually beat the first formulation when only a small number of the closest matches is wanted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b19d203036cf7d45dfab0c4ad82ce10183e0940c" translate="yes" xml:space="preserve">
          <source>This can very quickly delete millions of records because it doesn't have to individually delete every record. Note however that the above command requires taking an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on the parent table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3706a06d88bffe054b5b4e9ba07c3a2f69517db" translate="yes" xml:space="preserve">
          <source>This catalog only contains tables known to the subscription after running either &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; or &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c00511a06e3429d3e3c63e91ce19e3a4e9397cad" translate="yes" xml:space="preserve">
          <source>This chapter explains the interface between the core PostgreSQL system and &lt;em&gt;table access methods&lt;/em&gt;, which manage the storage for tables. The core system knows little about these access methods beyond what is specified here, so it is possible to develop entirely new access method types by writing add-on code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bbb8116ccc75f5eb2a80776b0a4003df51db1c5" translate="yes" xml:space="preserve">
          <source>This chapter provides an overview of how to use SQL to perform simple operations. This tutorial is only intended to give you an introduction and is in no way a complete tutorial on SQL. Numerous books have been written on SQL, including &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#MELT93&quot;&gt;[melt93]&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#DATE97&quot;&gt;[date97]&lt;/a&gt;. You should be aware that some PostgreSQL language features are extensions to the standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4bef49f81ca7b2b6c1d960ddeae062fa5602386" translate="yes" xml:space="preserve">
          <source>This chapter will on occasion refer to examples found in &lt;a href=&quot;https://www.postgresql.org/docs/12/tutorial-sql.html&quot;&gt;Chapter 2&lt;/a&gt; to change or improve them, so it will be useful to have read that chapter. Some examples from this chapter can also be found in &lt;code&gt;advanced.sql&lt;/code&gt; in the tutorial directory. This file also contains some sample data to load, which is not repeated here. (Refer to &lt;a href=&quot;tutorial-sql-intro&quot;&gt;Section 2.1&lt;/a&gt; for how to use the file.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05316eb335b74f7f1d96b694767ed937c7a73d2" translate="yes" xml:space="preserve">
          <source>This clause allows selection of the tablespace in which the index associated with a &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, or &lt;code&gt;EXCLUDE&lt;/code&gt; constraint will be created. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted, or &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; if the table is temporary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a22b296ec30545018cebf2ee6b84bbc440b4d2a" translate="yes" xml:space="preserve">
          <source>This clause alters parameters originally set by &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt;. See there for more information. The allowed options are &lt;code&gt;slot_name&lt;/code&gt; and &lt;code&gt;synchronous_commit&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dde9dc06154fb93b57360e4813d2af30753235f" translate="yes" xml:space="preserve">
          <source>This clause alters publication parameters originally set by &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;. See there for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a47a54fa61280e2ffdfce9d2640b5d9bb858deb" translate="yes" xml:space="preserve">
          <source>This clause alters the connection property originally set by &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt;. See there for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2fcb8e278e1a72c6a053d69e9530239790d3c7" translate="yes" xml:space="preserve">
          <source>This clause creates the column as a &lt;em&gt;generated column&lt;/em&gt;. The column cannot be written to, and when read the result of the specified expression will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8eb7a6eec884310b19db2fe89fcdaa447cc6e8" translate="yes" xml:space="preserve">
          <source>This clause creates the column as an &lt;em&gt;identity column&lt;/em&gt;. It will have an implicit sequence attached to it and the column in new rows will automatically have values from the sequence assigned to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da05955831bd605d103f99ab7132a00a6b982439" translate="yes" xml:space="preserve">
          <source>This clause indicates whether the following relation name is for the before-image transition relation or the after-image transition relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deddf49266216fee17210941a2dbf2f328be5ca2" translate="yes" xml:space="preserve">
          <source>This clause is only intended for compatibility with nonstandard SQL databases. Its use is discouraged in new applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41393a74e45a6c0a80ff1bb273dd882f889e0a0f" translate="yes" xml:space="preserve">
          <source>This clause is only provided for compatibility with non-standard SQL databases. Its use is discouraged in new applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22cd0887432e6ccdc3a45b9fc77bdb8214571dbc" translate="yes" xml:space="preserve">
          <source>This clause is useful for example when copying values between tables. Writing &lt;code&gt;INSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM tbl1&lt;/code&gt; will copy from &lt;code&gt;tbl1&lt;/code&gt; all columns that are not identity columns in &lt;code&gt;tbl2&lt;/code&gt; while values for the identity columns in &lt;code&gt;tbl2&lt;/code&gt; will be generated by the sequences associated with &lt;code&gt;tbl2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4ccb1be36e739cedb50d44f85c522aa002c906" translate="yes" xml:space="preserve">
          <source>This clause specifies optional parameters for a publication. The following parameters are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ab7a0e0c831da17344263c723c33e3ad9e5583a" translate="yes" xml:space="preserve">
          <source>This clause specifies optional parameters for a subscription. The following parameters are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="501055417d1a99c1021f58bb4344fd42a1fc3dfa" translate="yes" xml:space="preserve">
          <source>This clause specifies optional parameters for a view; the following parameters are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e5726eff7272a0b43b9a8622a25a1a4b88715e" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for a table or index; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. For backward-compatibility the &lt;code&gt;WITH&lt;/code&gt; clause for a table can also include &lt;code&gt;OIDS=FALSE&lt;/code&gt; to specify that rows of the new table should not contain OIDs (object identifiers), &lt;code&gt;OIDS=TRUE&lt;/code&gt; is not supported anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e37f3a174a386383c959a305d30ae15361d5fa2" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for the new materialized view; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. All parameters supported for &lt;code&gt;CREATE TABLE&lt;/code&gt; are also supported for &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt;. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd2349edcbad3293d90a1b82afea4e43718f802" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for the new table; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. For backward-compatibility the &lt;code&gt;WITH&lt;/code&gt; clause for a table can also include &lt;code&gt;OIDS=FALSE&lt;/code&gt; to specify that rows of the new table should contain no OIDs (object identifiers), &lt;code&gt;OIDS=TRUE&lt;/code&gt; is not supported anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9cf336be30ceb53b3db8168b3e8c1bdee3f553" translate="yes" xml:space="preserve">
          <source>This clause specifies options for the new foreign-data wrapper. The allowed option names and values are specific to each foreign data wrapper and are validated using the foreign-data wrapper's validator function. Option names must be unique.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f504297f50fca952ddee9289f583252aaad16be" translate="yes" xml:space="preserve">
          <source>This clause specifies the options for the server. The options typically define the connection details of the server, but the actual names and values are dependent on the server's foreign-data wrapper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="553dd348cb64862c6f6c7f8e200b08ad63014f0b" translate="yes" xml:space="preserve">
          <source>This clause specifies the options of the user mapping. The options typically define the actual user name and password of the mapping. Option names must be unique. The allowed option names and values are specific to the server's foreign-data wrapper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36dc1042b746c18fc663603f39f06075d4e8bad1" translate="yes" xml:space="preserve">
          <source>This clause specifies the type of access method to define. Only &lt;code&gt;TABLE&lt;/code&gt; and &lt;code&gt;INDEX&lt;/code&gt; are supported at present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7c9f34db6e75577cfa3e83dbdc6bf919fff89f9" translate="yes" xml:space="preserve">
          <source>This clause specifies whether or not the data produced by the query should be copied into the new table. If not, only the table structure is copied. The default is to copy the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d31ed888cfee0dc08f120a78ae32fb1759c0983" translate="yes" xml:space="preserve">
          <source>This clause specifies whether or not the materialized view should be populated at creation time. If not, the materialized view will be flagged as unscannable and cannot be queried until &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dc6ac474993dbe5358c6881853df7fd2d4d9cd6" translate="yes" xml:space="preserve">
          <source>This column has a default expression or generation expression, in which case there will be a corresponding entry in the &lt;code&gt;pg_attrdef&lt;/code&gt; catalog that actually defines the expression. (Check &lt;code&gt;attgenerated&lt;/code&gt; to determine whether this is a default or a generation expression.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b7e0b12551b63f994a3beb30fdb6c9912fa294" translate="yes" xml:space="preserve">
          <source>This column has a one element array containing the value used when the column is entirely missing from the row, as happens when the column is added with a non-volatile &lt;code&gt;DEFAULT&lt;/code&gt; value after the row is created. The value is only used when &lt;code&gt;atthasmissing&lt;/code&gt; is true. If there is no value the column is null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ff62cc51341f34bf3df6fe15f16224e9f0ba2a" translate="yes" xml:space="preserve">
          <source>This column has a value which is used where the column is entirely missing from the row, as happens when a column is added with a non-volatile &lt;code&gt;DEFAULT&lt;/code&gt; value after the row is created. The actual value used is stored in the &lt;code&gt;attmissingval&lt;/code&gt; column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111e19fea7f4514da864aef92d2fd3831ac7425b" translate="yes" xml:space="preserve">
          <source>This column has been dropped and is no longer valid. A dropped column is still physically present in the table, but is ignored by the parser and so cannot be accessed via SQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b598ea81d21dfda8a3cd60afd34a658bae3f5740" translate="yes" xml:space="preserve">
          <source>This column is defined locally in the relation. Note that a column can be locally defined and inherited simultaneously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699529a66bde15ad8ad9a32706a761c81f8ea245" translate="yes" xml:space="preserve">
          <source>This command acquires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace2f59fb68bc1a8e1f61640a30167ef3925c24d" translate="yes" xml:space="preserve">
          <source>This command adds the &lt;code&gt;user.postgres&lt;/code&gt; project and sets the shared memory maximum for the &lt;code&gt;postgres&lt;/code&gt; user to 8GB, and takes effect the next time that user logs in, or when you restart PostgreSQL (not reload). The above assumes that PostgreSQL is run by the &lt;code&gt;postgres&lt;/code&gt; user in the &lt;code&gt;postgres&lt;/code&gt; group. No server reboot is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d0a3c8a461143dd6e79fdea4b574da1733f08aa" translate="yes" xml:space="preserve">
          <source>This command begins a new transaction block. If the isolation level, read/write mode, or deferrable mode is specified, the new transaction has those characteristics, as if &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; was executed. This is the same as the &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62d4740f8d77efc3fe73e95e0f13203063c98ef5" translate="yes" xml:space="preserve">
          <source>This command can't be used to set &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;, nor parameters that are not allowed in &lt;code&gt;postgresql.conf&lt;/code&gt; (e.g., &lt;a href=&quot;runtime-config-preset&quot;&gt;preset options&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e40f32b710aa4b5a2f3104aef12c4365c871f09" translate="yes" xml:space="preserve">
          <source>This command cannot be executed inside a transaction block. The prepared transaction is committed immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20b731d4b786265bb5e3ab49dc8d1a8760feab6b" translate="yes" xml:space="preserve">
          <source>This command cannot be executed inside a transaction block. The prepared transaction is rolled back immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a29d09c1029fd474b45e76bcdb5bbdf65bd3023" translate="yes" xml:space="preserve">
          <source>This command cannot be executed while connected to the target database. Thus, it might be more convenient to use the program &lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt; instead, which is a wrapper around this command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5d7b0191945449cf1438d09ec7519757af4913" translate="yes" xml:space="preserve">
          <source>This command complies with the behavior defined in the SQL standard, except for the limitation that, in PostgreSQL, it does not apply to &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints. Also, PostgreSQL checks non-deferrable uniqueness constraints immediately, not at end of statement as the standard would suggest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b34603e56b93d743e26d620fe567201bf5d5d62" translate="yes" xml:space="preserve">
          <source>This command conforms to the ISO/IEC 9075-9 (SQL/MED), except that the standard only allows one foreign table to be dropped per command, and apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1f85c735f1b71966f80b17247cbce182c5909a" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except for the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="468590b4d092b563617998d73f97b2171f1d8742" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the &lt;code&gt;FROM&lt;/code&gt; and &lt;code&gt;RETURNING&lt;/code&gt; clauses are PostgreSQL extensions, as is the ability to use &lt;code&gt;WITH&lt;/code&gt; with &lt;code&gt;UPDATE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf1546d77c97dbe67b0ddd8982d22b8e55974688" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the &lt;code&gt;USING&lt;/code&gt; and &lt;code&gt;RETURNING&lt;/code&gt; clauses are PostgreSQL extensions, as is the ability to use &lt;code&gt;WITH&lt;/code&gt; with &lt;code&gt;DELETE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681caf8270b9ecf7b205e0a60ad45b051b0e81dd" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the standard only allows one table to be dropped per command, and apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93af22491b168f8df3ca39363ea91881304542c1" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the standard only allows one view to be dropped per command, and apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b31cc3350023fe9b74a561a1da0159f92b17624" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, with these PostgreSQL extensions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dabcb37ca2e8b2f56629a8b0fd30a7a18fcbfc70" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard. The standard specifies that the key word &lt;code&gt;SAVEPOINT&lt;/code&gt; is mandatory, but PostgreSQL allows it to be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c4c1beba4d7959f48fbfa14fde82110587427a" translate="yes" xml:space="preserve">
          <source>This command displays the execution plan that the PostgreSQL planner generates for the supplied statement. The execution plan shows how the table(s) referenced by the statement will be scanned &amp;mdash; by plain sequential scan, index scan, etc. &amp;mdash; and if multiple tables are referenced, what join algorithms will be used to bring together the required rows from each input table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8488cb1889e76b5a66add5218ab2ee79544199b3" translate="yes" xml:space="preserve">
          <source>This command fetches and edits the definition of the named function or procedure, in the form of a &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; or &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; command. Editing is done in the same way as for &lt;code&gt;\edit&lt;/code&gt;. After the editor exits, the updated command waits in the query buffer; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf69a2b293c399676b07c902a79f2f6947b772dc" translate="yes" xml:space="preserve">
          <source>This command fetches and edits the definition of the named view, in the form of a &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; command. Editing is done in the same way as for &lt;code&gt;\edit&lt;/code&gt;. After the editor exits, the updated command waits in the query buffer; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de8b3b98128e1d7cfa1ced8632fee4a04f5b0692" translate="yes" xml:space="preserve">
          <source>This command fetches and shows the definition of the named function or procedure, in the form of a &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; or &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; command. The definition is printed to the current query output channel, as set by &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c81c5ecf842f5babd90a21465ed15920d3fbf2d" translate="yes" xml:space="preserve">
          <source>This command fetches and shows the definition of the named view, in the form of a &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; command. The definition is printed to the current query output channel, as set by &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd85d7e6ea3b73ffb02cb31a536b30a7bacab224" translate="yes" xml:space="preserve">
          <source>This command is a PostgreSQL extension present for historical reasons. &lt;code&gt;ROLLBACK&lt;/code&gt; is the equivalent standard SQL command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2845ceac7504cffef12e499b57f5339a71e8d823" translate="yes" xml:space="preserve">
          <source>This command is functionally similar to &lt;a href=&quot;sql-selectinto&quot;&gt;SELECT INTO&lt;/a&gt;, but it is preferred since it is less likely to be confused with other uses of the &lt;code&gt;SELECT INTO&lt;/code&gt; syntax. Furthermore, &lt;code&gt;CREATE TABLE AS&lt;/code&gt; offers a superset of the functionality offered by &lt;code&gt;SELECT INTO&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eebc2c2dfbb338f54847defda6bbbbd05da85aa" translate="yes" xml:space="preserve">
          <source>This command is identical to &lt;code&gt;\echo&lt;/code&gt; except that the output will be written to the query output channel, as set by &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b1eb8df7cef0a6e41f20fd61cbd76e26932fed" translate="yes" xml:space="preserve">
          <source>This command is similar to the corresponding command in the SQL standard, apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension. But note that much of the &lt;code&gt;CREATE TYPE&lt;/code&gt; command and the data type extension mechanisms in PostgreSQL differ from the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74399205e4f06569f7b7a41f319f8abd6da5004d" translate="yes" xml:space="preserve">
          <source>This command is unrelated to the SQL command &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="017757db6d9507e6b7436f7a9ae4e2248893c3e8" translate="yes" xml:space="preserve">
          <source>This command loads a shared library file into the PostgreSQL server's address space. If the file has been loaded already, the command does nothing. Shared library files that contain C functions are automatically loaded whenever one of their functions is called. Therefore, an explicit &lt;code&gt;LOAD&lt;/code&gt; is usually only needed to load a library that modifies the server's behavior through &amp;ldquo;hooks&amp;rdquo; rather than providing a set of functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fcb6c8246e8a6d76583723b04afe1b09a7d9c3" translate="yes" xml:space="preserve">
          <source>This command may be used to end SQL queries, taking the place of the terminating semicolon (&lt;code&gt;;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="677d2975d49fcc1351e4405fb4dd24f72ba0639a" translate="yes" xml:space="preserve">
          <source>This command must be used inside a transaction block. Use &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; to start one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b6b0df46bdea049004d95ff3514fc627c0bf758" translate="yes" xml:space="preserve">
          <source>This command must not be used when the server is running. &lt;code&gt;pg_resetwal&lt;/code&gt; will refuse to start up if it finds a server lock file in the data directory. If the server crashed then a lock file might have been left behind; in that case you can remove the lock file to allow &lt;code&gt;pg_resetwal&lt;/code&gt; to run. But before you do so, make doubly certain that there is no server process still alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71df21dcefbc6a0e13c7dad07c76dab173b26ca8" translate="yes" xml:space="preserve">
          <source>This command only alters the behavior of constraints within the current transaction. Issuing this outside of a transaction block emits a warning and otherwise has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd16c39418a0167a8c3018978b081238b82407a5" translate="yes" xml:space="preserve">
          <source>This command removes the procedural language &lt;code&gt;plsample&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a5e5db6761174aa48d67b3836a7c44b067d9bd" translate="yes" xml:space="preserve">
          <source>This command removes the square root function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8da0e72c154580e68779b6eda81a32e4cdad2c2" translate="yes" xml:space="preserve">
          <source>This command sets options affecting the output of query result tables. &lt;code&gt;option&lt;/code&gt; indicates which option is to be set. The semantics of &lt;code&gt;value&lt;/code&gt; vary depending on the selected option. For some options, omitting &lt;code&gt;value&lt;/code&gt; causes the option to be toggled or unset, as described under the particular option. If no such behavior is mentioned, then omitting &lt;code&gt;value&lt;/code&gt; just results in the current setting being displayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b80b7eaaaf7b41602e63f2f9f3e4efa523bee3" translate="yes" xml:space="preserve">
          <source>This command sets the current user identifier of the current SQL session to be &lt;code&gt;role_name&lt;/code&gt;. The role name can be written as either an identifier or a string literal. After &lt;code&gt;SET ROLE&lt;/code&gt;, permissions checking for SQL commands is carried out as though the named role were the one that had logged in originally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7712990490e001a7ee650bc9d46804ef39e8a64" translate="yes" xml:space="preserve">
          <source>This command sets the session user identifier and the current user identifier of the current SQL session to be &lt;code&gt;user_name&lt;/code&gt;. The user name can be written as either an identifier or a string literal. Using this command, it is possible, for example, to temporarily become an unprivileged user and later switch back to being a superuser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9ce1414108a89726b8871ae0b54d84b052aa18" translate="yes" xml:space="preserve">
          <source>This command will fail if any of &lt;code&gt;hstore&lt;/code&gt;'s objects are in use in the database, for example if any tables have columns of the &lt;code&gt;hstore&lt;/code&gt; type. Add the &lt;code&gt;CASCADE&lt;/code&gt; option to forcibly remove those dependent objects as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b862ff106f276a9375de8c6aab656803f7a4efb" translate="yes" xml:space="preserve">
          <source>This command will free storage associated with the materialized view &lt;code&gt;annual_statistics_basis&lt;/code&gt; and leave it in an unscannable state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9c73632173fe8b7637783ced8159d79d16ea65" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing indexes that reference the configuration in &lt;code&gt;to_tsvector&lt;/code&gt; calls. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such indexes along with the text search configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7e8e631e47d7a2498f014c562d775f4aa922d4" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing indexes that use operator classes within the family. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such indexes along with the operator family.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e344bd47bfc7344c009cae8df60f4f2d04ad7fee" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing indexes that use the operator class. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such indexes along with the operator class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a073ad25e0df8057b772f9939bb92486f83b429" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing text search configurations that use the dictionary. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such configurations along with the dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b8a535bcfac2a0dbcd407ddbfe551b50e04749" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing text search configurations that use the parser. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such configurations along with the parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9140e2324a0907c1e9782d65b5e3ea71a6d9655e" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing text search dictionaries that use the template. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such dictionaries along with the template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17f6112c2268ba0c9663f367e376afa3756d596b" translate="yes" xml:space="preserve">
          <source>This command will perform archiving when &lt;code&gt;/var/lib/pgsql/backup_in_progress&lt;/code&gt; exists, and otherwise silently return zero exit status (allowing PostgreSQL to recycle the unwanted WAL file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ffbb1ab36d371eef7c290033c779142e12ec33" translate="yes" xml:space="preserve">
          <source>This command will remove the index &lt;code&gt;title_idx&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2078fd2a1ddd7b0f72d80b8a3d0cc32c019e717f" translate="yes" xml:space="preserve">
          <source>This command will remove the materialized view called &lt;code&gt;order_summary&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a242c77a8ccd56ddace9304e1ec3ea12442c9d59" translate="yes" xml:space="preserve">
          <source>This command will remove the view called &lt;code&gt;kinds&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7ac7005486ff5a82c81e39d2a6985dcac07fb2" translate="yes" xml:space="preserve">
          <source>This command will replace the contents of the materialized view called &lt;code&gt;order_summary&lt;/code&gt; using the query from the materialized view's definition, and leave it in a scannable state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21fb41393a4eea96218c35f555df78b95eb06e38" translate="yes" xml:space="preserve">
          <source>This command will return a sample of 100 rows from the table &lt;code&gt;my_table&lt;/code&gt; (unless the table does not have 100 visible rows, in which case all its rows are returned).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01ae94e8662537ac6716b276145364c5f4fb1046" translate="yes" xml:space="preserve">
          <source>This command will return as large a sample of &lt;code&gt;my_table&lt;/code&gt; as it can read in 1 second (1000 milliseconds). Of course, if the whole table can be read in under 1 second, all its rows will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8973f1428f19cf5f51d43ae902ba0ec839e24687" translate="yes" xml:space="preserve">
          <source>This command will work independent of whether &lt;code&gt;foo&lt;/code&gt; is an aggregate, function, or procedure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac0fa233aac6a123e11329c2972c3833b6e69d2" translate="yes" xml:space="preserve">
          <source>This confirms there are 100 distinct combinations in the two columns, and all of them are about equally likely (1% frequency for each one). The base frequency is the frequency computed from per-column statistics, as if there were no multi-column statistics. Had there been any null values in either of the columns, this would be identified in the &lt;code&gt;nulls&lt;/code&gt; column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75759d2d2d52e1dc2865efa8cf2fb6090b3f128" translate="yes" xml:space="preserve">
          <source>This constant is a two-dimensional, 3-by-3 array consisting of three subarrays of integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d39be831b881f732286b6571d19294d43d84bf" translate="yes" xml:space="preserve">
          <source>This constraint is defined locally for the relation. It is a non-inheritable constraint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0fafaed69e2c50c035d4176a4d38521e63e5d6" translate="yes" xml:space="preserve">
          <source>This constraint is defined locally for the relation. Note that a constraint can be locally defined and inherited simultaneously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="677137c6fdb574fcaee9a2f495faececc7604ba8" translate="yes" xml:space="preserve">
          <source>This construct is similar to a &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; row comparison, but it does not yield null for null inputs. Instead, any null value is considered unequal to (distinct from) any non-null value, and any two nulls are considered equal (not distinct). Thus the result will either be true or false, never null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1020bde7bf73c7df63ce8acf0bfdb90bb93b7fcb" translate="yes" xml:space="preserve">
          <source>This construct is similar to a &lt;code&gt;=&lt;/code&gt; row comparison, but it does not yield null for null inputs. Instead, any null value is considered unequal to (distinct from) any non-null value, and any two nulls are considered equal (not distinct). Thus the result will always be either true or false, never null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33a306bcfd5b03d8e762816f623417a83fd23a93" translate="yes" xml:space="preserve">
          <source>This controls how many pages or tuples of a single relation can be predicate-locked before the lock is promoted to covering the whole relation. Values greater than or equal to zero mean an absolute limit, while negative values mean &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt; divided by the absolute value of this setting. The default is -2, which keeps the behavior from previous versions of PostgreSQL. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37486631dcaede39c55161d228505d69d73e3e22" translate="yes" xml:space="preserve">
          <source>This controls how many rows on a single page can be predicate-locked before the lock is promoted to covering the whole page. The default is 2. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a7a6bb04de3147a65fe3e69e114d351a95bdd3" translate="yes" xml:space="preserve">
          <source>This controls whether a quote mark can be represented by &lt;code&gt;\'&lt;/code&gt; in a string literal. The preferred, SQL-standard way to represent a quote mark is by doubling it (&lt;code&gt;''&lt;/code&gt;) but PostgreSQL has historically also accepted &lt;code&gt;\'&lt;/code&gt;. However, use of &lt;code&gt;\'&lt;/code&gt; creates security risks because in some client character set encodings, there are multibyte characters in which the last byte is numerically equivalent to ASCII &lt;code&gt;\&lt;/code&gt;. If client-side code does escaping incorrectly then a SQL-injection attack is possible. This risk can be prevented by making the server reject queries in which a quote mark appears to be escaped by a backslash. The allowed values of &lt;code&gt;backslash_quote&lt;/code&gt; are &lt;code&gt;on&lt;/code&gt; (allow &lt;code&gt;\'&lt;/code&gt; always), &lt;code&gt;off&lt;/code&gt; (reject always), and &lt;code&gt;safe_encoding&lt;/code&gt; (allow only if client encoding does not allow ASCII &lt;code&gt;\&lt;/code&gt; within a multibyte character). &lt;code&gt;safe_encoding&lt;/code&gt; is the default setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ccb11174fcbc5e0dcaecf5ce4057bc44c37e08" translate="yes" xml:space="preserve">
          <source>This controls whether ordinary string literals (&lt;code&gt;'...'&lt;/code&gt;) treat backslashes literally, as specified in the SQL standard. Beginning in PostgreSQL 9.1, the default is &lt;code&gt;on&lt;/code&gt; (prior releases defaulted to &lt;code&gt;off&lt;/code&gt;). Applications can check this parameter to determine how string literals will be processed. The presence of this parameter can also be taken as an indication that the escape string syntax (&lt;code&gt;E'...'&lt;/code&gt;) is supported. Escape string syntax (&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;Section 4.1.2.2&lt;/a&gt;) should be used if an application desires backslashes to be treated as escape characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04ce8a3710d0e73d6eb9a44e5b7e7596e3b6ada8" translate="yes" xml:space="preserve">
          <source>This controls whether the array input parser recognizes unquoted &lt;code&gt;NULL&lt;/code&gt; as specifying a null array element. By default, this is &lt;code&gt;on&lt;/code&gt;, allowing array values containing null values to be entered. However, PostgreSQL versions before 8.2 did not support null values in arrays, and therefore would treat &lt;code&gt;NULL&lt;/code&gt; as specifying a normal array element with the string value &amp;ldquo;NULL&amp;rdquo;. For backward compatibility with applications that require the old behavior, this variable can be turned &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a334bdaf5d7adfdeb7bdd6cc764b677eb1d1fc0d" translate="yes" xml:space="preserve">
          <source>This controls whether the constraint can be deferred. A constraint that is not deferrable will be checked immediately after every command. Checking of constraints that are deferrable can be postponed until the end of the transaction (using the &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt; command). &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; is the default. Currently, only &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, &lt;code&gt;EXCLUDE&lt;/code&gt;, and &lt;code&gt;REFERENCES&lt;/code&gt; (foreign key) constraints accept this clause. &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints are not deferrable. Note that deferrable constraints cannot be used as conflict arbitrators in an &lt;code&gt;INSERT&lt;/code&gt; statement that includes an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1918927d29af63f959f031de4a1383381d5530a7" translate="yes" xml:space="preserve">
          <source>This creates a security hazard when calling, via qualified name &lt;a href=&quot;#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup id=&quot;FUNC-QUALIFIED-SECURITY&quot;&gt;[10]&lt;/sup&gt;&lt;/a&gt;, a variadic function found in a schema that permits untrusted users to create objects. A malicious user can take control and execute arbitrary SQL functions as though you executed them. Substitute a call bearing the &lt;code&gt;VARIADIC&lt;/code&gt; keyword, which bypasses this hazard. Calls populating &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; parameters often have no equivalent formulation containing the &lt;code&gt;VARIADIC&lt;/code&gt; keyword. To issue those calls safely, the function's schema must permit only trusted users to create objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d12540189cdbd640895d38788f65f9fbba1d76fa" translate="yes" xml:space="preserve">
          <source>This creates a table named &lt;code&gt;my_first_table&lt;/code&gt; with two columns. The first column is named &lt;code&gt;first_column&lt;/code&gt; and has a data type of &lt;code&gt;text&lt;/code&gt;; the second column has the name &lt;code&gt;second_column&lt;/code&gt; and the type &lt;code&gt;integer&lt;/code&gt;. The table and column names follow the identifier syntax explained in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-IDENTIFIERS&quot;&gt;Section 4.1.1&lt;/a&gt;. The type names are usually also identifiers, but there are some exceptions. Note that the column list is comma-separated and surrounded by parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2df112a8a7b40124ef90c403fdef2c5ff1577746" translate="yes" xml:space="preserve">
          <source>This creates an availability hazard when calling, via qualified name&lt;a href=&quot;typeconv-func#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup&gt;[10]&lt;/sup&gt;&lt;/a&gt;, any function found in a schema that permits untrusted users to create objects. A malicious user can create a function with the name of an existing function, replicating that function's parameters and appending novel parameters having default values. This precludes new calls to the original function. To forestall this hazard, place functions in schemas that permit only trusted users to create objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd08e31876bb0659f97fc74e6e81b5de962b395" translate="yes" xml:space="preserve">
          <source>This creates registry entries used by the event viewer, under the default event source named &lt;code&gt;PostgreSQL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f685ce47d5796c5b17ed2dc2e9f2a95a1be4cb" translate="yes" xml:space="preserve">
          <source>This creates the scripts and compiles the C files containing user-defined functions and types. Then, to start the tutorial, do the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b31e3f2055cca38cc6b689ae9fad52cab29160" translate="yes" xml:space="preserve">
          <source>This design allows for both backwards-compatible header additions (add header extension chunks, or set low-order flag bits) and non-backwards-compatible changes (set high-order flag bits to signal such changes, and add supporting data to the extension area if needed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1507a2d26ed6cd13d8f06661be29be45050cd21" translate="yes" xml:space="preserve">
          <source>This dictionary template is used to create dictionaries that replace a word with a synonym. Phrases are not supported (use the thesaurus template (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-THESAURUS&quot;&gt;Section 12.6.4&lt;/a&gt;) for that). A synonym dictionary can be used to overcome linguistic problems, for example, to prevent an English stemmer dictionary from reducing the word &amp;ldquo;Paris&amp;rdquo; to &amp;ldquo;pari&amp;rdquo;. It is enough to have a &lt;code&gt;Paris paris&lt;/code&gt; line in the synonym dictionary and put it before the &lt;code&gt;english_stem&lt;/code&gt; dictionary. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfab7a227af58e60167bfee0ac87d5907b3ad3ee" translate="yes" xml:space="preserve">
          <source>This document answers frequently asked questions about SELinux. It focuses primarily on Fedora, but is not limited to Fedora.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f99dd7f4a8868a1752a291c897889c1028116d" translate="yes" xml:space="preserve">
          <source>This document provides a wide spectrum of knowledge to administer SELinux on your systems. It focuses primarily on Red Hat operating systems, but is not limited to them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d69a24fba08d14e58aa301ec18364f049dd9f435" translate="yes" xml:space="preserve">
          <source>This does not prevent cleanup of dead rows which have reached the age specified by &lt;code&gt;old_snapshot_threshold&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a33c8e067844a10adc4d1ec87dc8f9bed7f940" translate="yes" xml:space="preserve">
          <source>This does not work because &lt;code&gt;integer&lt;/code&gt; does not have an implicit cast to &lt;code&gt;text&lt;/code&gt;. An explicit cast will work, however:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a11325d581fd69da8d48499eb1dc3e0e55ab89" translate="yes" xml:space="preserve">
          <source>This equivalence between functional notation and field notation makes it possible to use functions on composite types to implement &amp;ldquo;computed fields&amp;rdquo;.   An application using the last query above wouldn't need to be directly aware that &lt;code&gt;somefunc&lt;/code&gt; isn't a real column of the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf34fbb91a15c4b2d08b406f2026ab198cd22a33" translate="yes" xml:space="preserve">
          <source>This evaluates query on document and wraps the result in XML tags. If the result is multivalued, the output will look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ced5262cfea0d7c224d2d14022b915ded0c9bb" translate="yes" xml:space="preserve">
          <source>This example creates a composite type and uses it in a function definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd20b024051cecf699f47d6601ef377cbbceb783" translate="yes" xml:space="preserve">
          <source>This example creates a large object type and uses it in a table definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81988155ae08cfd1bb03bda3f7e767cd1d1e7982" translate="yes" xml:space="preserve">
          <source>This example creates a range type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29a86563a51e3572dd14a9d9255eda3ebb2201cc" translate="yes" xml:space="preserve">
          <source>This example creates an enumerated type and uses it in a table definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e15c416b1eb4a6e0ac422253fe9d7c571e4e1d98" translate="yes" xml:space="preserve">
          <source>This example creates the &lt;code&gt;us_postal_code&lt;/code&gt; data type and then uses the type in a table definition. A regular expression test is used to verify that the value looks like a valid US postal code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824e6c2d218cfa4fc262bbf54ecefd33c7e0d65c" translate="yes" xml:space="preserve">
          <source>This example creates the base data type &lt;code&gt;box&lt;/code&gt; and then uses the type in a table definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="434cf5265b6621f51d3d3b20b1a695bea28ca57d" translate="yes" xml:space="preserve">
          <source>This example for Unix systems sets the locale to Swedish (&lt;code&gt;sv&lt;/code&gt;) as spoken in Sweden (&lt;code&gt;SE&lt;/code&gt;). Other possibilities might include &lt;code&gt;en_US&lt;/code&gt; (U.S. English) and &lt;code&gt;fr_CA&lt;/code&gt; (French Canadian). If more than one character set can be used for a locale then the specifications can take the form &lt;code&gt;language_territory.codeset&lt;/code&gt;. For example, &lt;code&gt;fr_BE.UTF-8&lt;/code&gt; represents the French language (fr) as spoken in Belgium (BE), with a UTF-8 character set encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2c48d8838d3c1575e17a1f1c1bf4b1c54be443" translate="yes" xml:space="preserve">
          <source>This example inserts into array columns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42fa4c592cce0c22be8f54fb9056c02e69ce0496" translate="yes" xml:space="preserve">
          <source>This example inserts some rows into table &lt;code&gt;films&lt;/code&gt; from a table &lt;code&gt;tmp_films&lt;/code&gt; with the same column layout as &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a463d9dae9db43b670ea9503d31a0e368fa4ee70" translate="yes" xml:space="preserve">
          <source>This example is equivalent to &lt;code&gt;FROM table1 AS alias_name&lt;/code&gt;. More interesting cases, which cannot be reduced to a plain join, arise when the subquery involves grouping or aggregation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be1a5f2f3b699d99e46d29b68340b721327b27dd" translate="yes" xml:space="preserve">
          <source>This example is, of course, oversimplified, but there's a lot of control possible in a transaction block through the use of savepoints. Moreover, &lt;code&gt;ROLLBACK TO&lt;/code&gt; is the only way to regain control of a transaction block that was put in aborted state by the system due to an error, short of rolling it back completely and starting again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7b74712a2cd7143b58e55978ebc0a1e029aad05" translate="yes" xml:space="preserve">
          <source>This example produces a set something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd0849ce5d2cb6e49bc1884469c044510632ded5" translate="yes" xml:space="preserve">
          <source>This example shows a session that performs verification of the 10 largest catalog indexes in the database &amp;ldquo;test&amp;rdquo;. Verification of the presence of heap tuples as index tuples is requested for the subset that are unique indexes. Since no error is raised, all indexes tested appear to be logically consistent. Naturally, this query could easily be changed to call &lt;code&gt;bt_index_check&lt;/code&gt; for every index in the database where verification is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52eaa3c393eb8836501cf0b71b2390cbd556c111" translate="yes" xml:space="preserve">
          <source>This example shows how to use a function in the &lt;code&gt;FROM&lt;/code&gt; clause, both with and without a column definition list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf001583d1938e7eac65338b42d5145eeba9d29" translate="yes" xml:space="preserve">
          <source>This example shows how to use a simple &lt;code&gt;WITH&lt;/code&gt; clause:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd1b1ae7add544b9cdd447e36bf84ceb80a1e127" translate="yes" xml:space="preserve">
          <source>This example uses &lt;code&gt;LATERAL&lt;/code&gt; to apply a set-returning function &lt;code&gt;get_product_names()&lt;/code&gt; for each row of the &lt;code&gt;manufacturers&lt;/code&gt; table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eba8d9892663515b6cc219ad20715d37c9c5396" translate="yes" xml:space="preserve">
          <source>This example uses &lt;code&gt;WITH RECURSIVE&lt;/code&gt; to find all subordinates (direct or indirect) of the employee Mary, and their level of indirectness, from a table that shows only direct subordinates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="625799a6daa4d3a32ad43aba61a387f19b4df04e" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;DEFAULT&lt;/code&gt; clause for the date columns rather than specifying a value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b1cc724cf1f567bbb040ff9e9078c758235297" translate="yes" xml:space="preserve">
          <source>This example uses the following data (also available in file &lt;code&gt;contrib/ltree/ltreetest.sql&lt;/code&gt; in the source distribution):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2eb1d66444608a417cb7a2c5c2fded452498b8" translate="yes" xml:space="preserve">
          <source>This example would remove all rows from tables &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;. The number of affected rows reported to the client would only include rows removed from &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="759fd9b05670f2874eee702f3df4de125c19d274" translate="yes" xml:space="preserve">
          <source>This example would use the standard Unicode collation in a nondeterministic way. In particular, this would allow strings in different normal forms to be compared correctly. More interesting examples make use of the ICU customization facilities explained above. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a370e5d62e07be8745753fc6bbcb3e1a1d2437da" translate="yes" xml:space="preserve">
          <source>This expanded version of the previous query shows the operator family each operator class belongs to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d891c30f21d694bab5f748d5f0b9dd9f8f629f4a" translate="yes" xml:space="preserve">
          <source>This expression returns the size of the track if it contains any segments with high heart rate values, or an empty sequence otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d9bda9d80ab3b41fb483157cc1a94532dbac7fb" translate="yes" xml:space="preserve">
          <source>This expression yields true when two time periods (defined by their endpoints) overlap, false when they do not overlap. The endpoints can be specified as pairs of dates, times, or time stamps; or as a date, time, or time stamp followed by an interval. When a pair of values is provided, either the start or the end can be written first; &lt;code&gt;OVERLAPS&lt;/code&gt; automatically takes the earlier value of the pair as the start. Each time period is considered to represent the half-open interval &lt;code&gt;start&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;time&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;end&lt;/code&gt;, unless &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are equal in which case it represents that single time instant. This means for instance that two time periods with only an endpoint in common do not overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c11b883111f39a35c0f589a7362884a445b2f9be" translate="yes" xml:space="preserve">
          <source>This extensibility should not be confused with the extensibility of the other standard search trees in terms of the data they can handle. For example, PostgreSQL supports extensible B-trees and hash indexes. That means that you can use PostgreSQL to build a B-tree or hash over any data type you want. But B-trees only support range predicates (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;), and hash indexes only support equality queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25249be2bc655571c6b319a5e05ab9bf57e7f0ce" translate="yes" xml:space="preserve">
          <source>This extension won't build at all unless the installation was configured with &lt;code&gt;--with-openssl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985d874d57f888d6b7d33a42c3b39fe6c5d40324" translate="yes" xml:space="preserve">
          <source>This failure occurs because PostgreSQL treats multiple &lt;code&gt;UNION&lt;/code&gt;s as a nest of pairwise operations; that is, this input is the same as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dea5b639461b36e0d899f8204fb2b765c1a0fb6" translate="yes" xml:space="preserve">
          <source>This feature is disabled by default for manually issued &lt;code&gt;VACUUM&lt;/code&gt; commands. To enable it, set the &lt;code&gt;vacuum_cost_delay&lt;/code&gt; variable to a nonzero value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7554d4b1db763d2db35742e4df9b2b6a631440fa" translate="yes" xml:space="preserve">
          <source>This feature is intended as a temporary measure until a complete solution is found. At that time, this option will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d4c1ac5e0b12c58cdf26713648d8dd1dfac571" translate="yes" xml:space="preserve">
          <source>This feature was designed to allow parameters not normally known to PostgreSQL to be added by add-on modules (such as procedural languages). This allows extension modules to be configured in the standard ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d9b959196517fcbab35a6da62247fb2b91ad04" translate="yes" xml:space="preserve">
          <source>This feature was shamelessly plagiarized from Bash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd0c7f9cb881f24c299dc7cd6acc6e93722283f" translate="yes" xml:space="preserve">
          <source>This feature was shamelessly plagiarized from tcsh.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="195725685743f0dba93fa9e927faaeac64a5e891" translate="yes" xml:space="preserve">
          <source>This field is not available in PostgreSQL releases prior to 8.3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6136f38c2e93a8910734e7b6cf3ef3cea4cdbf88" translate="yes" xml:space="preserve">
          <source>This field only applies to &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;hostssl&lt;/code&gt;, and &lt;code&gt;hostnossl&lt;/code&gt; records.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb02774d9e01b5ecb4a1f9ea9a8d0284469c4dd" translate="yes" xml:space="preserve">
          <source>This flag does not behave identically to the &lt;code&gt;-t&lt;/code&gt; flag of pg_dump. There is not currently any provision for wild-card matching in pg_restore, nor can you include a schema name within its &lt;code&gt;-t&lt;/code&gt;. And, while pg_dump's &lt;code&gt;-t&lt;/code&gt; flag will also dump subsidiary objects (such as indexes) of the selected table(s), pg_restore's &lt;code&gt;-t&lt;/code&gt; flag does not include such subsidiary objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238947e6bf1928a48d022f51eceab630f9f9ea68" translate="yes" xml:space="preserve">
          <source>This forces the checkpoint to be done as quickly as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69aa54921685a649b05a319351142e3198d02907" translate="yes" xml:space="preserve">
          <source>This form adds a new &lt;code&gt;PRIMARY KEY&lt;/code&gt; or &lt;code&gt;UNIQUE&lt;/code&gt; constraint to a table based on an existing unique index. All the columns of the index will be included in the constraint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba31c86d5c7be29caf3e323f522bf84c40b7fcf" translate="yes" xml:space="preserve">
          <source>This form adds a new attribute to a composite type, using the same syntax as &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0322ba886bea1157dcae5f05c22210a2d27f5b1" translate="yes" xml:space="preserve">
          <source>This form adds a new column to the foreign table, using the same syntax as &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;. Unlike the case when adding a column to a regular table, nothing happens to the underlying storage: this action simply declares that some new column is now accessible through the foreign table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c0b10fe4a25bd3c814ee981b4c421d53eaf37a" translate="yes" xml:space="preserve">
          <source>This form adds a new column to the table, using the same syntax as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. If &lt;code&gt;IF NOT EXISTS&lt;/code&gt; is specified and a column already exists with this name, no error is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ee63428230bf79c5e0942a3cc936820a6d5d6f" translate="yes" xml:space="preserve">
          <source>This form adds a new constraint to a domain using the same syntax as &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt;. When a new constraint is added to a domain, all columns using that domain will be checked against the newly added constraint. These checks can be suppressed by adding the new constraint using the &lt;code&gt;NOT VALID&lt;/code&gt; option; the constraint can later be made valid using &lt;code&gt;ALTER DOMAIN ... VALIDATE CONSTRAINT&lt;/code&gt;. Newly inserted or updated rows are always checked against all constraints, even those marked &lt;code&gt;NOT VALID&lt;/code&gt;. &lt;code&gt;NOT VALID&lt;/code&gt; is only accepted for &lt;code&gt;CHECK&lt;/code&gt; constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f1ef6b759daf52986e80a140fc1e8e6996a0c1e" translate="yes" xml:space="preserve">
          <source>This form adds a new constraint to a foreign table, using the same syntax as &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;. Currently only &lt;code&gt;CHECK&lt;/code&gt; constraints are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60c743b0f8a6b250501ac85a73828ca722af7185" translate="yes" xml:space="preserve">
          <source>This form adds a new constraint to a table using the same syntax as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, plus the option &lt;code&gt;NOT VALID&lt;/code&gt;, which is currently only allowed for foreign key and CHECK constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ce19ef3782b6ce0c5b9df7476cc0daa1dd41c54" translate="yes" xml:space="preserve">
          <source>This form adds a new value to an enum type. The new value's place in the enum's ordering can be specified as being &lt;code&gt;BEFORE&lt;/code&gt; or &lt;code&gt;AFTER&lt;/code&gt; one of the existing values. Otherwise, the new item is added at the end of the list of values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6cf59f2735afa1f2d995a149ad05a9eb1b35eb7" translate="yes" xml:space="preserve">
          <source>This form adds an existing object to the extension. This is mainly useful in extension update scripts. The object will subsequently be treated as a member of the extension; notably, it can only be dropped by dropping the extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595f54e5f3b774c232dc30ed51e46c90273688d9" translate="yes" xml:space="preserve">
          <source>This form adds the target foreign table as a new child of the specified parent table. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927ec7cd6b47cc568c9f6a02695b9db39fd050a7" translate="yes" xml:space="preserve">
          <source>This form adds the target table as a new child of the specified parent table. Subsequently, queries against the parent will include records of the target table. To be added as a child, the target table must already contain all the same columns as the parent (it could have additional columns, too). The columns must have matching data types, and if they have &lt;code&gt;NOT NULL&lt;/code&gt; constraints in the parent then they must also have &lt;code&gt;NOT NULL&lt;/code&gt; constraints in the child.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d346519cab151e59ba4d85ab858ae6233fa9d98e" translate="yes" xml:space="preserve">
          <source>This form alters the attributes of a constraint that was previously created. Currently only foreign key constraints may be altered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3d28a97b5f73f4ab63b75ff86f6835976075b5" translate="yes" xml:space="preserve">
          <source>This form attaches an existing table (which might itself be partitioned) as a partition of the target table. The table can be attached as a partition for specific values using &lt;code&gt;FOR VALUES&lt;/code&gt; or as a default partition by using &lt;code&gt;DEFAULT&lt;/code&gt;. For each index in the target table, a corresponding one will be created in the attached table; or, if an equivalent index already exists, it will be attached to the target table's index, as if &lt;code&gt;ALTER INDEX ATTACH PARTITION&lt;/code&gt; had been executed. Note that if the existing table is a foreign table, it is currently not allowed to attach the table as a partition of the target table if there are &lt;code&gt;UNIQUE&lt;/code&gt; indexes on the target table. (See also &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc3fb037ad7936c80f6f29d8637098894917452d" translate="yes" xml:space="preserve">
          <source>This form can be used to create the foreign table as partition of the given parent table with specified partition bound values. See the similar form of &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details. Note that it is currently not allowed to create the foreign table as a partition of the parent table if there are &lt;code&gt;UNIQUE&lt;/code&gt; indexes on the parent table. (See also &lt;a href=&quot;sql-altertable&quot;&gt;&lt;code&gt;ALTER TABLE ATTACH PARTITION&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c7c9cbd670ca1e7d92be433f5a08452d27c094" translate="yes" xml:space="preserve">
          <source>This form changes one or more index-method-specific storage parameters for the index. See &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; for details on the available parameters. Note that the index contents will not be modified immediately by this command; depending on the parameter you might need to rebuild the index with &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; to get the desired effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e33ac3b4ee94fcc601870b607686da66a411c8" translate="yes" xml:space="preserve">
          <source>This form changes one or more storage parameters for the table. See &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for details on the available parameters. Note that the table contents will not be modified immediately by this command; depending on the parameter you might need to rewrite the table to get the desired effects. That can be done with &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM FULL&lt;/a&gt;, &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; or one of the forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; that forces a table rewrite. For planner related parameters, changes will take effect from the next time the table is locked so currently executing queries will not be affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e83d3c0b4c77e2425087c239b0df05fcb0116826" translate="yes" xml:space="preserve">
          <source>This form changes the index's tablespace to the specified tablespace and moves the data file(s) associated with the index to the new tablespace. To change the tablespace of an index, you must own the index and have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new tablespace. All indexes in the current database in a tablespace can be moved by using the &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; form, which will lock all indexes to be moved and then move each one. This form also supports &lt;code&gt;OWNED BY&lt;/code&gt;, which will only move indexes owned by the roles specified. If the &lt;code&gt;NOWAIT&lt;/code&gt; option is specified then the command will fail if it is unable to acquire all of the locks required immediately. Note that system catalogs will not be moved by this command, use &lt;code&gt;ALTER DATABASE&lt;/code&gt; or explicit &lt;code&gt;ALTER INDEX&lt;/code&gt; invocations instead if desired. See also &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c55be56dbc86b6d6779191aa5c394d5588fe660" translate="yes" xml:space="preserve">
          <source>This form changes the information which is written to the write-ahead log to identify rows which are updated or deleted. This option has no effect except when logical replication is in use. &lt;code&gt;DEFAULT&lt;/code&gt; (the default for non-system tables) records the old values of the columns of the primary key, if any. &lt;code&gt;USING INDEX&lt;/code&gt; records the old values of the columns covered by the named index, which must be unique, not partial, not deferrable, and include only columns marked &lt;code&gt;NOT NULL&lt;/code&gt;. &lt;code&gt;FULL&lt;/code&gt; records the old values of all columns in the row. &lt;code&gt;NOTHING&lt;/code&gt; records no information about the old row. (This is the default for system tables.) In all cases, no old values are logged unless at least one of the columns that would be logged differs between the old and new versions of the row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5fd7a415ae62d2432d673453426bcca0e434c22" translate="yes" xml:space="preserve">
          <source>This form changes the name of a constraint on a domain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a34d134067f8057fdc7eb4bd8e2afb5eac929d2" translate="yes" xml:space="preserve">
          <source>This form changes the name of the domain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdaccc9f755620eea9c5a68106023cbc0c07f19d" translate="yes" xml:space="preserve">
          <source>This form changes the name of the type or the name of an individual attribute of a composite type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33709234ccf296c21440f70a857148d5d605167b" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the domain to the specified user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c8412b485a6292103c360edb753fe679de7f49" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the foreign table to the specified user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdda20046cb686daa61e8bfb091f3201cdd5da85" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the table, sequence, view, materialized view, or foreign table to the specified user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="367a0875855c27e375e704da43453b6a64108026" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6515faf0d6c7bfb31358723522828dadb55476f0" translate="yes" xml:space="preserve">
          <source>This form changes the schema of the domain. Any constraints associated with the domain are moved into the new schema as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ceb0679036b94c23ce3c3c3726ad7d1600fd754" translate="yes" xml:space="preserve">
          <source>This form changes the table from unlogged to logged or vice-versa (see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-UNLOGGED&quot;&gt;&lt;code&gt;UNLOGGED&lt;/code&gt;&lt;/a&gt;). It cannot be applied to a temporary table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413a825daa3f78a948f21b1ed732bd1afa98d9f3" translate="yes" xml:space="preserve">
          <source>This form changes the table's tablespace to the specified tablespace and moves the data file(s) associated with the table to the new tablespace. Indexes on the table, if any, are not moved; but they can be moved separately with additional &lt;code&gt;SET TABLESPACE&lt;/code&gt; commands. When applied to a partitioned table, nothing is moved, but any partitions created afterwards with &lt;code&gt;CREATE TABLE PARTITION OF&lt;/code&gt; will use that tablespace, unless the &lt;code&gt;TABLESPACE&lt;/code&gt; clause is used to override it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d606494af7f67be03bcb787fb49d4fbd5e3725e9" translate="yes" xml:space="preserve">
          <source>This form changes the type of a column of a foreign table. Again, this has no effect on any underlying storage: this action simply changes the type that PostgreSQL believes the column to have.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef90ca77493d55255faa9c05a6d21e673fa262d6" translate="yes" xml:space="preserve">
          <source>This form changes the type of a column of a table. Indexes and simple table constraints involving the column will be automatically converted to use the new column type by reparsing the originally supplied expression. The optional &lt;code&gt;COLLATE&lt;/code&gt; clause specifies a collation for the new column; if omitted, the collation is the default for the new column type. The optional &lt;code&gt;USING&lt;/code&gt; clause specifies how to compute the new column value from the old; if omitted, the default conversion is the same as an assignment cast from old data type to new. A &lt;code&gt;USING&lt;/code&gt; clause must be provided if there is no implicit or assignment cast from old to new type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90f5c12001436438a106ce1bcbc9026c77d9b2f" translate="yes" xml:space="preserve">
          <source>This form changes the type of an attribute of a composite type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4194cb65228a21c483f32a1d7544636b626b6d4" translate="yes" xml:space="preserve">
          <source>This form detaches specified partition of the target table. The detached partition continues to exist as a standalone table, but no longer has any ties to the table from which it was detached. Any indexes that were attached to the target table's indexes are detached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f649e2a380d4d6a7844e29c8bec08b60d14e121" translate="yes" xml:space="preserve">
          <source>This form dissociates a typed table from its type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41af815da8671345e4d0830589af85c8c9d1f4f9" translate="yes" xml:space="preserve">
          <source>This form drops a column from a foreign table. You will need to say &lt;code&gt;CASCADE&lt;/code&gt; if anything outside the table depends on the column; for example, views. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the column does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="132c35990a8f9ff6a2087c8c4db6bfe5bc0d3b7f" translate="yes" xml:space="preserve">
          <source>This form drops a column from a table. Indexes and table constraints involving the column will be automatically dropped as well. Multivariate statistics referencing the dropped column will also be removed if the removal of the column would cause the statistics to contain data for only a single column. You will need to say &lt;code&gt;CASCADE&lt;/code&gt; if anything outside the table depends on the column, for example, foreign key references or views. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the column does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630cbfc87f5704d127bcc228848ac6a6604a8fb0" translate="yes" xml:space="preserve">
          <source>This form drops an attribute from a composite type. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the attribute does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abbb33e28408b10284213af5010b6f9ed9616abd" translate="yes" xml:space="preserve">
          <source>This form drops constraints on a domain. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the constraint does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0562817256cba47f3678521e40341b9bb63428df" translate="yes" xml:space="preserve">
          <source>This form drops the specified constraint on a foreign table. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the constraint does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef5c32eb106661dab4fdce48beeb3716d53be331" translate="yes" xml:space="preserve">
          <source>This form drops the specified constraint on a table, along with any index underlying the constraint. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the constraint does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6075d1245dd08cd17ae12d300569e914c015d02" translate="yes" xml:space="preserve">
          <source>This form is not currently supported on partitioned tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62fef7209d0ef0917314ea35bb80cd3a32ecadf7" translate="yes" xml:space="preserve">
          <source>This form links the table to a composite type as though &lt;code&gt;CREATE TABLE OF&lt;/code&gt; had formed it. The table's list of column names and types must precisely match that of the composite type. The table must not inherit from any other table. These restrictions ensure that &lt;code&gt;CREATE TABLE OF&lt;/code&gt; would permit an equivalent table definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80c03819073116dcc932622328193f2e17ef52d2" translate="yes" xml:space="preserve">
          <source>This form marks as valid a constraint that was previously marked as &lt;code&gt;NOT VALID&lt;/code&gt;. No action is taken to verify the constraint, but future queries will assume that it holds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85cec438622a098483a45173b222a4d5cd019672" translate="yes" xml:space="preserve">
          <source>This form marks the index as dependent on the extension, such that if the extension is dropped, the index will automatically be dropped as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4faed3e54b7a44c7e7e8c551a8c0326f16df1512" translate="yes" xml:space="preserve">
          <source>This form moves the extension's objects into another schema. The extension has to be &lt;em&gt;relocatable&lt;/em&gt; for this command to succeed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d44749fe236086787bbeb370c7b120c56a308916" translate="yes" xml:space="preserve">
          <source>This form moves the foreign table into another schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="343fe32ad6664d950886e22df1f9e56f6f16399d" translate="yes" xml:space="preserve">
          <source>This form moves the table into another schema. Associated indexes, constraints, and sequences owned by table columns are moved as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a25f7c9422516454200b0986e93d0f9a7b1cd24" translate="yes" xml:space="preserve">
          <source>This form moves the type into another schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af28f23e1758f00a66bd13166257650c2c6c6e02" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;CREATE TRANSFORM&lt;/code&gt; is a PostgreSQL extension. There is a &lt;code&gt;CREATE TRANSFORM&lt;/code&gt; command in the SQL standard, but it is for adapting data types to client languages. That usage is not supported by PostgreSQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ab065126927246d3956d5f89c1fdf1ac5a9c01c" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;DROP TRANSFORM&lt;/code&gt; is a PostgreSQL extension. See &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff5cb48fe56e9b363be562d91784fed1316defb" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;json_object&lt;/code&gt; takes keys and values pairwise from two separate arrays. In all other respects it is identical to the one-argument form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e130ed2324ecc47cb96bb25ee04c4b0d13167363" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;ts_rewrite&lt;/code&gt; accepts a starting &lt;code&gt;query&lt;/code&gt; and a SQL &lt;code&gt;select&lt;/code&gt; command, which is given as a text string. The &lt;code&gt;select&lt;/code&gt; must yield two columns of &lt;code&gt;tsquery&lt;/code&gt; type. For each row of the &lt;code&gt;select&lt;/code&gt; result, occurrences of the first column value (the target) are replaced by the second column value (the substitute) within the current &lt;code&gt;query&lt;/code&gt; value. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d013efd17243813d551b63d4312494e00c1c1a6c" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;ts_rewrite&lt;/code&gt; simply applies a single rewrite rule: &lt;code&gt;target&lt;/code&gt; is replaced by &lt;code&gt;substitute&lt;/code&gt; wherever it appears in &lt;code&gt;query&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb31fbf716a310edf9d2b4049a82ade012c42087" translate="yes" xml:space="preserve">
          <source>This form of the &lt;code&gt;AS&lt;/code&gt; clause is used for dynamically loadable C language functions when the function name in the C language source code is not the same as the name of the SQL function. The string &lt;code&gt;obj_file&lt;/code&gt; is the name of the shared library file containing the compiled C function, and is interpreted as for the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command. The string &lt;code&gt;link_symbol&lt;/code&gt; is the function's link symbol, that is, the name of the function in the C language source code. If the link symbol is omitted, it is assumed to be the same as the name of the SQL function being defined. The C names of all functions must be different, so you must give overloaded C functions different C names (for example, use the argument types as part of the C names).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a04c3c78f722989a90da205ce8987d3f751510b" translate="yes" xml:space="preserve">
          <source>This form of the &lt;code&gt;AS&lt;/code&gt; clause is used for dynamically loadable C language procedures when the procedure name in the C language source code is not the same as the name of the SQL procedure. The string &lt;code&gt;obj_file&lt;/code&gt; is the name of the shared library file containing the compiled C procedure, and is interpreted as for the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command. The string &lt;code&gt;link_symbol&lt;/code&gt; is the procedure's link symbol, that is, the name of the procedure in the C language source code. If the link symbol is omitted, it is assumed to be the same as the name of the SQL procedure being defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d61def8f9ec3856b91d045805fea7f90a02d4de" translate="yes" xml:space="preserve">
          <source>This form of the command cannot be executed inside a transaction block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f50353be2bb5b567c08b62d433e3835ac63124" translate="yes" xml:space="preserve">
          <source>This form only executes the function if column &lt;code&gt;balance&lt;/code&gt; has in fact changed value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4473c42ad05dfd82fc106e9f90398e30bc2ce6b" translate="yes" xml:space="preserve">
          <source>This form removes a member object from the extension. This is mainly useful in extension update scripts. The object is not dropped, only disassociated from the extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eac856d748a6f647a905af09f04314ea23cd83c3" translate="yes" xml:space="preserve">
          <source>This form removes the most recently used &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; index specification from the table. This affects future cluster operations that don't specify an index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9adc8eb95719164761b79a5084426c7addf0749" translate="yes" xml:space="preserve">
          <source>This form removes the target foreign table from the list of children of the specified parent table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c78c98e24aa433ee20cbdef33df9ef970bae2bf" translate="yes" xml:space="preserve">
          <source>This form removes the target table from the list of children of the specified parent table. Queries against the parent table will no longer include records drawn from the target table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c86659bd33298dbeea55e29cf320d1c3d50f459" translate="yes" xml:space="preserve">
          <source>This form renames a value of an enum type. The value's place in the enum's ordering is not affected. An error will occur if the specified value is not present or the new name is already present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4bbf5050bebdaa653a528317e3e5511397a3bd9" translate="yes" xml:space="preserve">
          <source>This form resets one or more index-method-specific storage parameters to their defaults. As with &lt;code&gt;SET&lt;/code&gt;, a &lt;code&gt;REINDEX&lt;/code&gt; might be needed to update the index entirely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e49ca11d0f33e0a64657337a16309c7010218e7" translate="yes" xml:space="preserve">
          <source>This form resets one or more storage parameters to their defaults. As with &lt;code&gt;SET&lt;/code&gt;, a table rewrite might be needed to update the table entirely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d66d6fd49dacdab7eaf9fc3512115d0797c065d" translate="yes" xml:space="preserve">
          <source>This form selects the default index for future &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; operations. It does not actually re-cluster the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="518ddc9b662de15607142c00b06214f51c6fca69" translate="yes" xml:space="preserve">
          <source>This form sets or resets per-attribute options. Currently, the only defined per-attribute options are &lt;code&gt;n_distinct&lt;/code&gt; and &lt;code&gt;n_distinct_inherited&lt;/code&gt;, which override the number-of-distinct-values estimates made by subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. &lt;code&gt;n_distinct&lt;/code&gt; affects the statistics for the table itself, while &lt;code&gt;n_distinct_inherited&lt;/code&gt; affects the statistics gathered for the table plus its inheritance children. When set to a positive value, &lt;code&gt;ANALYZE&lt;/code&gt; will assume that the column contains exactly the specified number of distinct nonnull values. When set to a negative value, which must be greater than or equal to -1, &lt;code&gt;ANALYZE&lt;/code&gt; will assume that the number of distinct nonnull values in the column is linear in the size of the table; the exact count is to be computed by multiplying the estimated table size by the absolute value of the given number. For example, a value of -1 implies that all values in the column are distinct, while a value of -0.5 implies that each value appears twice on the average. This can be useful when the size of the table changes over time, since the multiplication by the number of rows in the table is not performed until query planning time. Specify a value of 0 to revert to estimating the number of distinct values normally. For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="895b894f198c38b8b568f74baad8144867fc06d4" translate="yes" xml:space="preserve">
          <source>This form sets or resets per-attribute options. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740f7c9cb8ed05218d4d039f1aa9f624d452a1af" translate="yes" xml:space="preserve">
          <source>This form sets the per-column statistics-gathering target for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations, though can be used only on index columns that are defined as an expression. Since expressions lack a unique name, we refer to them using the ordinal number of the index column. The target can be set in the range 0 to 10000; alternatively, set it to -1 to revert to using the system default statistics target (&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;). For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d5f18188deb36d3de2faca967992d3efc2b40a" translate="yes" xml:space="preserve">
          <source>This form sets the per-column statistics-gathering target for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6332f7067a3fb1b7b86c9dc56f927e587c384e78" translate="yes" xml:space="preserve">
          <source>This form sets the per-column statistics-gathering target for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. The target can be set in the range 0 to 10000; alternatively, set it to -1 to revert to using the system default statistics target (&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;). For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4211581d9cac601dcf30af9c236c2e568347e8dc" translate="yes" xml:space="preserve">
          <source>This form sets the storage mode for a column. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details. Note that the storage mode has no effect unless the table's foreign-data wrapper chooses to pay attention to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647ec6a7abe325c2f43beddebcddae6af6d3e9e1" translate="yes" xml:space="preserve">
          <source>This form sets the storage mode for a column. This controls whether this column is held inline or in a secondary TOAST table, and whether the data should be compressed or not. &lt;code&gt;PLAIN&lt;/code&gt; must be used for fixed-length values such as &lt;code&gt;integer&lt;/code&gt; and is inline, uncompressed. &lt;code&gt;MAIN&lt;/code&gt; is for inline, compressible data. &lt;code&gt;EXTERNAL&lt;/code&gt; is for external, uncompressed data, and &lt;code&gt;EXTENDED&lt;/code&gt; is for external, compressed data. &lt;code&gt;EXTENDED&lt;/code&gt; is the default for most data types that support non-&lt;code&gt;PLAIN&lt;/code&gt; storage. Use of &lt;code&gt;EXTERNAL&lt;/code&gt; will make substring operations on very large &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;bytea&lt;/code&gt; values run faster, at the penalty of increased storage space. Note that &lt;code&gt;SET STORAGE&lt;/code&gt; doesn't itself change anything in the table, it just sets the strategy to be pursued during future table updates. See &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e59ee7d655fea5f293a39645cf958df6f59eaa" translate="yes" xml:space="preserve">
          <source>This form updates the extension to a newer version. The extension must supply a suitable update script (or series of scripts) that can modify the currently-installed version into the requested version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54be61b37045a65ad5af5b24265bf2d2fe56613b" translate="yes" xml:space="preserve">
          <source>This form validates a constraint previously added as &lt;code&gt;NOT VALID&lt;/code&gt;, that is, it verifies that all values in table columns of the domain type satisfy the specified constraint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fae39d4d329b60aa027a709db925fb7a0b45aad" translate="yes" xml:space="preserve">
          <source>This form validates a foreign key or check constraint that was previously created as &lt;code&gt;NOT VALID&lt;/code&gt;, by scanning the table to ensure there are no rows for which the constraint is not satisfied. Nothing happens if the constraint is already marked valid. (See &lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;Notes&lt;/a&gt; below for an explanation of the usefulness of this command.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d527b3923e336e8d7e873c75f29f0a2a678c450" translate="yes" xml:space="preserve">
          <source>This format option is used for importing and exporting the Comma Separated Value (&lt;code&gt;CSV&lt;/code&gt;) file format used by many other programs, such as spreadsheets. Instead of the escaping rules used by PostgreSQL's standard text format, it produces and recognizes the common CSV escaping mechanism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="792a63854d692e136337a8efffc52744faba871f" translate="yes" xml:space="preserve">
          <source>This function accepts, but does not require, the VARIADIC keyword. It tolerates both integer and numeric arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384addc1a1dba581b09ffbc6f99227a9381c9da3" translate="yes" xml:space="preserve">
          <source>This function applies the XSL stylesheet to the document and returns the transformed result. The &lt;code&gt;paramlist&lt;/code&gt; is a list of parameter assignments to be used in the transformation, specified in the form &lt;code&gt;a=1,b=2&lt;/code&gt;. Note that the parameter parsing is very simple-minded: parameter values cannot contain commas!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee207b4a33861c6094ba8a46213a951afdbd72c" translate="yes" xml:space="preserve">
          <source>This function calculates the Levenshtein distance between two strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2569b9ec2f2f240b538364988cd2b660c7bc809" translate="yes" xml:space="preserve">
          <source>This function calculates the metaphone code of an input string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b833dadc47320ce5093b7875a4e223019bb7f287" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;cover density&lt;/em&gt; ranking for the given document vector and query, as described in Clarke, Cormack, and Tudhope's &quot;Relevance Ranking for One to Three Term Queries&quot; in the journal &quot;Information Processing and Management&quot;, 1999. Cover density is similar to &lt;code&gt;ts_rank&lt;/code&gt; ranking except that the proximity of matching lexemes to each other is taken into consideration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d7f3c8b4315f521db79931ac5b0419f7f02e44" translate="yes" xml:space="preserve">
          <source>This function generates a version 1 UUID but uses a random multicast MAC address instead of the real MAC address of the computer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d47dfa9e9b8d5b7fbb04b1e480b39cea1dce637" translate="yes" xml:space="preserve">
          <source>This function generates a version 1 UUID. This involves the MAC address of the computer and a time stamp. Note that UUIDs of this kind reveal the identity of the computer that created the identifier and the time at which it did so, which might make it unsuitable for certain security-sensitive applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0487e417e0c4d9dd43a18530572f4217e42f12de" translate="yes" xml:space="preserve">
          <source>This function generates a version 3 UUID in the given namespace using the specified input name. The namespace should be one of the special constants produced by the &lt;code&gt;uuid_ns_*()&lt;/code&gt; functions shown in &lt;a href=&quot;uuid-ossp#UUID-OSSP-CONSTANTS&quot;&gt;Table F.33&lt;/a&gt;. (It could be any UUID in theory.) The name is an identifier in the selected namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="815458cef4730e8a9276e3ff8e0d57eb7d786adf" translate="yes" xml:space="preserve">
          <source>This function generates a version 4 UUID, which is derived entirely from random numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e04d40259f3b4e398eaecf4565ce5668726dbd" translate="yes" xml:space="preserve">
          <source>This function generates a version 5 UUID, which works like a version 3 UUID except that SHA-1 is used as a hashing method. Version 5 should be preferred over version 3 because SHA-1 is thought to be more secure than MD5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a3bf72d056e543baff831854a2b9328ece5e35" translate="yes" xml:space="preserve">
          <source>This function is described in &lt;a href=&quot;functions-srf#FUNCTIONS-SRF-SUBSCRIPTS&quot;&gt;Table 9.62&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a6e7f01cec14b42f0b87924ed8025472ae1b3d" translate="yes" xml:space="preserve">
          <source>This function is really useful only if you have more than one trusted CA certificate in your server's certificate authority file, or if this CA has issued some intermediate certificate authority certificates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1d41d04bdf06be2e37d1f0ae8845458954a418" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;UPDATE&lt;/code&gt; privilege on the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39f1ca89945df262cf69293c102551266551425" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;SELECT&lt;/code&gt; privilege on the last used sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f01c920de003b371748d82ceb88ff4c45aff8e2" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;SELECT&lt;/code&gt; privilege on the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67164ea85a2954ef16cf5fcf220bb12c3b615043" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; privilege on the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e54a0efd46907c22c610b8b23cccd57e0bcbc37" translate="yes" xml:space="preserve">
          <source>This function requires lexeme positional information to perform its calculation. Therefore, it ignores any &amp;ldquo;stripped&amp;rdquo; lexemes in the &lt;code&gt;tsvector&lt;/code&gt;. If there are no unstripped lexemes in the input, the result will be zero. (See &lt;a href=&quot;textsearch-features#TEXTSEARCH-MANIPULATE-TSVECTOR&quot;&gt;Section 12.4.1&lt;/a&gt; for more information about the &lt;code&gt;strip&lt;/code&gt; function and positional information in &lt;code&gt;tsvector&lt;/code&gt;s.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1856db892a00b2e43b297b0dbc4109fce353620" translate="yes" xml:space="preserve">
          <source>This function returns a value that can be approximately understood as the greatest similarity between the first string and any substring of the second string. However, this function does not add padding to the boundaries of the extent. Thus, the number of additional characters present in the second string is not considered, except for the mismatched word boundaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45aa18780b259bc2744ab8ff0666ff85306321c0" translate="yes" xml:space="preserve">
          <source>This function returns multiple values separated by the specified separator, for example &lt;code&gt;Value 1,Value 2,Value 3&lt;/code&gt; if separator is &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a92a46b380193cb9c54f2eb12d510b84b0bf579e" translate="yes" xml:space="preserve">
          <source>This function returns the value of the specified field in the certificate subject, or NULL if the field is not present. Field names are string constants that are converted into ASN1 object identifiers using the OpenSSL object database. The following values are acceptable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50cb6130584a2ccc2fd56083455360b1df842976" translate="yes" xml:space="preserve">
          <source>This function should be called with the same arguments as the return attributes of &lt;code&gt;heap_page_items&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bf22c93b0d832b9656f660c278a124c39df4dd9" translate="yes" xml:space="preserve">
          <source>This function terminates backup mode and performs an automatic switch to the next WAL segment. The reason for the switch is to arrange for the last WAL segment written during the backup interval to be ready to archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aad428f96b8431576d3176be3a80d4e1c2a4447" translate="yes" xml:space="preserve">
          <source>This function will be called to initialize dynamic shared memory at the beginning of a parallel scan. &lt;em&gt;&lt;code&gt;target&lt;/code&gt;&lt;/em&gt; will point to at least the number of bytes previously returned by &lt;code&gt;amestimateparallelscan&lt;/code&gt;, and this function may use that amount of space to store whatever data it wishes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9031a619f108cfe873afc670225222a731f98ca3" translate="yes" xml:space="preserve">
          <source>This function's intention is to access a table &lt;code&gt;admin.pwds&lt;/code&gt;. But without the &lt;code&gt;SET&lt;/code&gt; clause, or with a &lt;code&gt;SET&lt;/code&gt; clause mentioning only &lt;code&gt;admin&lt;/code&gt;, the function could be subverted by creating a temporary table named &lt;code&gt;pwds&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74eda98e312717a7e3761e1be3fed4cfe413013a" translate="yes" xml:space="preserve">
          <source>This function, if implemented, will be called when a parallel index scan must be restarted. It should reset any shared state set up by &lt;code&gt;aminitparallelscan&lt;/code&gt; such that the scan will be restarted from the beginning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba0d2d4c762ce91e9a46761e7e3115cef1d26dc7" translate="yes" xml:space="preserve">
          <source>This group of commands implements nestable conditional blocks, similarly to &lt;code&gt;psql&lt;/code&gt;'s &lt;a href=&quot;app-psql#PSQL-METACOMMAND-IF&quot;&gt;&lt;code&gt;\if&lt;/code&gt; &lt;code&gt;expression&lt;/code&gt;&lt;/a&gt;. Conditional expressions are identical to those with &lt;code&gt;\set&lt;/code&gt;, with non-zero values interpreted as true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a86a1c85779a67bdb4c07c083dc8d1a736ba45ad" translate="yes" xml:space="preserve">
          <source>This group of commands implements nestable conditional blocks. A conditional block must begin with an &lt;code&gt;\if&lt;/code&gt; and end with an &lt;code&gt;\endif&lt;/code&gt;. In between there may be any number of &lt;code&gt;\elif&lt;/code&gt; clauses, which may optionally be followed by a single &lt;code&gt;\else&lt;/code&gt; clause. Ordinary queries and other types of backslash commands may (and usually do) appear between the commands forming a conditional block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b11efb2c7cb913b726605094c75fda2e8cad938" translate="yes" xml:space="preserve">
          <source>This happens because the system cannot decide which of the several possible &lt;code&gt;~&lt;/code&gt; operators should be preferred. We can help it out with an explicit cast:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1adefa35377cadd1c8a75aec2fb42a29f31a0dd0" translate="yes" xml:space="preserve">
          <source>This has the same effect as casting each expression to the array element type individually. For more on casting, see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;Section 4.2.9&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60511ea52748a75870fb82ff05a5c564394ceb2" translate="yes" xml:space="preserve">
          <source>This heuristic can be overridden, forcing the server to use either generic or custom plans, by setting &lt;code&gt;plan_cache_mode&lt;/code&gt; to &lt;code&gt;force_generic_plan&lt;/code&gt; or &lt;code&gt;force_custom_plan&lt;/code&gt; respectively. This setting is primarily useful if the generic plan's cost estimate is badly off for some reason, allowing it to be chosen even though its actual cost is much more than that of a custom plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ceb81116f5e1034358e4c68c702f99fa463a7e9" translate="yes" xml:space="preserve">
          <source>This implies that if a table is not otherwise vacuumed, autovacuum will be invoked on it approximately once every &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; minus &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; transactions. For tables that are regularly vacuumed for space reclamation purposes, this is of little importance. However, for static tables (including tables that receive inserts, but no updates or deletes), there is no need to vacuum for space reclamation, so it can be useful to try to maximize the interval between forced autovacuums on very large static tables. Obviously one can do this either by increasing &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; or decreasing &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="963c171b1310567729b0c667a3982a8159857c0a" translate="yes" xml:space="preserve">
          <source>This includes issues caused by the comparison rules of operating system collations changing. Comparisons of datums of a collatable type like &lt;code&gt;text&lt;/code&gt; must be immutable (just as all comparisons used for B-Tree index scans must be immutable), which implies that operating system collation rules must never change. Though rare, updates to operating system collation rules can cause these issues. More commonly, an inconsistency in the collation order between a master server and a standby server is implicated, possibly because the &lt;em&gt;major&lt;/em&gt; operating system version in use is inconsistent. Such inconsistencies will generally only arise on standby servers, and so can generally only be detected on standby servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a867951badfb08df8a9bb92137e4c1059d9fe31b" translate="yes" xml:space="preserve">
          <source>This indicates that the &lt;code&gt;postgres&lt;/code&gt; process has been terminated due to memory pressure. Although existing database connections will continue to function normally, no new connections will be accepted. To recover, PostgreSQL will need to be restarted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a372cfe5f8eb7d4853999840a603c1c28fd5394" translate="yes" xml:space="preserve">
          <source>This indicates that the most common combination of city and state is Washington in DC, with actual frequency (in the sample) about 0.35%. The base frequency of the combination (as computed from the simple per-column frequencies) is only 0.0027%, resulting in two orders of magnitude under-estimates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8fe534ccbaaf548c2b11e2912002e72aef917fa" translate="yes" xml:space="preserve">
          <source>This indicates that there are three combinations of columns that have 33178 distinct values: ZIP code and state; ZIP code and city; and ZIP code, city and state (the fact that they are all equal is expected given that ZIP code alone is unique in this table). On the other hand, the combination of city and state has only 27435 distinct values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1f09ba473095924730f620c845acdb222d24ff" translate="yes" xml:space="preserve">
          <source>This involves changes in the backend function API, which is written in the C programming language. Such changes affect code that references backend functions deep inside the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a4686c9a5bfa4e42613a92f3eda7d13c48363f" translate="yes" xml:space="preserve">
          <source>This is OK because the subquery is an independent computation that computes its own aggregate separately from what is happening in the outer query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dcf869a044613b3ca0ecf7baf516a8c7193977f" translate="yes" xml:space="preserve">
          <source>This is a &lt;code&gt;printf&lt;/code&gt;-style string that is output at the beginning of each log line. &lt;code&gt;%&lt;/code&gt; characters begin &amp;ldquo;escape sequences&amp;rdquo; that are replaced with status information as outlined below. Unrecognized escapes are ignored. Other characters are copied straight to the log line. Some escapes are only recognized by session processes, and will be treated as empty by background processes such as the main server process. Status information may be aligned either left or right by specifying a numeric literal after the % and before the option. A negative value will cause the status information to be padded on the right with spaces to give it a minimum width, whereas a positive value will pad on the left. Padding can be useful to aid human readability in log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;'%m [%p] '&lt;/code&gt; which logs a time stamp and the process ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9227695178f5037e0a0e506aca137b88f68d780" translate="yes" xml:space="preserve">
          <source>This is a Boolean option. If true, it specifies that values of the column should not be matched against the null string (that is, the table-level &lt;code&gt;null&lt;/code&gt; option). This has the same effect as listing the column in &lt;code&gt;COPY&lt;/code&gt;'s &lt;code&gt;FORCE_NOT_NULL&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0f72d78e70cfb965b94342147bb69a1649e537" translate="yes" xml:space="preserve">
          <source>This is a Boolean option. If true, it specifies that values of the column which match the null string are returned as &lt;code&gt;NULL&lt;/code&gt; even if the value is quoted. Without this option, only unquoted values matching the null string are returned as &lt;code&gt;NULL&lt;/code&gt;. This has the same effect as listing the column in &lt;code&gt;COPY&lt;/code&gt;'s &lt;code&gt;FORCE_NULL&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952c5f2574e0ab3c7c85d004636983a1260b99d7" translate="yes" xml:space="preserve">
          <source>This is a list of acronyms commonly used in the PostgreSQL documentation and in discussions about PostgreSQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e0bd441cd585968a19e4596d1d9617026fbc74" translate="yes" xml:space="preserve">
          <source>This is a noise word.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022e58efea267ae2631d535b60729a755677e2e4" translate="yes" xml:space="preserve">
          <source>This is a particularly efficient approach when there are few successful tests and many unsuccessful ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d2e6129737b2c23b111b25ce903c45a62a32f8" translate="yes" xml:space="preserve">
          <source>This is a sequence of three commands, one per line (although this is not required; more than one command can be on a line, and commands can usefully be split across lines).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450f019da352d6f44183cb5a8fe197731201523e" translate="yes" xml:space="preserve">
          <source>This is a shortcut for setting &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; at once. If you specify this, you cannot specify either of those parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768c3e272a14bb422425810cd204ed41f4ba6629" translate="yes" xml:space="preserve">
          <source>This is a wrapper for the above function that uses &lt;code&gt;,&lt;/code&gt; as the separator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c868d4182c583f463c71ff97e781747bf3a03c" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;\dp&lt;/code&gt; (&amp;ldquo;display privileges&amp;rdquo;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3bfb72cef070dc11f447b3386a7c2706bac36a5" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;\lo_list&lt;/code&gt;, which shows a list of large objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ba8cae4388de88507eba2b7275ccd60b950613" translate="yes" xml:space="preserve">
          <source>This is an array of &lt;code&gt;indnatts&lt;/code&gt; values that indicate which table columns this index indexes. For example a value of &lt;code&gt;1 3&lt;/code&gt; would mean that the first and the third table columns make up the index entries. Key columns come before non-key (included) columns. A zero in this array indicates that the corresponding index attribute is an expression over the table columns, rather than a simple column reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ae302c90a19a0498f7df9c475b24d33cb673e7" translate="yes" xml:space="preserve">
          <source>This is an array of &lt;code&gt;indnkeyatts&lt;/code&gt; values that store per-column flag bits. The meaning of the bits is defined by the index's access method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc49bd55fbc5bfa9dea1e28cd18c9a1ca88a7e4" translate="yes" xml:space="preserve">
          <source>This is an array of &lt;code&gt;partnatts&lt;/code&gt; values that indicate which table columns are part of the partition key. For example, a value of &lt;code&gt;1 3&lt;/code&gt; would mean that the first and the third table columns make up the partition key. A zero in this array indicates that the corresponding partition key column is an expression, rather than a simple column reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85cb6ef5ec65368f349e99d1c5b167fcd51b032f" translate="yes" xml:space="preserve">
          <source>This is an example of creating a bloom index:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e7b5364ece8bb74449b25a2f87fdcc6112556a" translate="yes" xml:space="preserve">
          <source>This is backward-compatible syntax for declaring a table &lt;code&gt;WITHOUT OIDS&lt;/code&gt;, creating a table &lt;code&gt;WITH OIDS&lt;/code&gt; is not supported anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53c81b1fcb044c5d18d73e6543204df53f672fe" translate="yes" xml:space="preserve">
          <source>This is because a restriction placed in the &lt;code&gt;ON&lt;/code&gt; clause is processed &lt;em&gt;before&lt;/em&gt; the join, while a restriction placed in the &lt;code&gt;WHERE&lt;/code&gt; clause is processed &lt;em&gt;after&lt;/em&gt; the join. That does not matter with inner joins, but it matters a lot with outer joins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e68e5962e0de07dffd697e9417724fccc9d63d" translate="yes" xml:space="preserve">
          <source>This is because if A had executed before B, B would have computed the sum 330, not 300, and similarly the other order would have resulted in a different sum computed by A.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b15f8961b465e16b950c107a03d87b532671ad" translate="yes" xml:space="preserve">
          <source>This is commonly used for analysis over hierarchical data; e.g. total salary by department, division, and company-wide total.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c19f8fd7239c9e470394caad32ebd804606ed7b1" translate="yes" xml:space="preserve">
          <source>This is effectively the same as setting the default to null. As a consequence, it is not an error to drop a default where one hadn't been defined, because the default is implicitly the null value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d31603eaa916aca8762159f8bda194ec5b5313c" translate="yes" xml:space="preserve">
          <source>This is equivalent to considering that the lower bound is &amp;ldquo;minus infinity&amp;rdquo;, or the upper bound is &amp;ldquo;plus infinity&amp;rdquo;, respectively. But note that these infinite values are never values of the range's element type, and can never be part of the range. (So there is no such thing as an inclusive infinite bound &amp;mdash; if you try to write one, it will automatically be converted to an exclusive bound.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b4366f2bb306ae39f6ae123b6e52ebbaf45e22" translate="yes" xml:space="preserve">
          <source>This is false for internal languages (such as SQL) and true for user-defined languages. Currently, pg_dump still uses this to determine which languages need to be dumped, but this might be replaced by a different mechanism in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="909703c85505cd16ac2e43cb68b897cd4647ad6b" translate="yes" xml:space="preserve">
          <source>This is identical to &lt;code&gt;dow&lt;/code&gt; except for Sunday. This matches the ISO 8601 day of the week numbering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="774c866f144b866c3887ecc3ab9eba1546c6554f" translate="yes" xml:space="preserve">
          <source>This is more useful if the expressions in the select list return varying results. For example, you could call a function this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f2d8c3b689196c5d8ec8d4f5df566ae69faf2b" translate="yes" xml:space="preserve">
          <source>This is needed to avoid syntactic ambiguity. An example is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c677b482c1d51ad6809dd70f3013fed740bc81c" translate="yes" xml:space="preserve">
          <source>This is not as efficient as a partial index on the &lt;code&gt;amount&lt;/code&gt; column would be, since the system has to scan the entire index. Yet, if there are relatively few unbilled orders, using this partial index just to find the unbilled orders could be a win.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d2d55c459297e19ddd1f07d0c1ebe65fd3794d" translate="yes" xml:space="preserve">
          <source>This is not especially useful since it has exactly the same result as the more conventional</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0322eac9bb3931b0da02327d4f96591febd87604" translate="yes" xml:space="preserve">
          <source>This is only a conceptual model. The join is usually performed in a more efficient manner than actually comparing each possible pair of rows, but this is invisible to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8169801d92724560db318d90118c63ada145ffc" translate="yes" xml:space="preserve">
          <source>This is quite a different problem: how to estimate the selectivity when the value is &lt;em&gt;not&lt;/em&gt; in the MCV list. The approach is to use the fact that the value is not in the list, combined with the knowledge of the frequencies for all of the MCVs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d520c606037b870becb6e588d6da7dff0960ba" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;digest()&lt;/code&gt; but the hash can only be recalculated knowing the key. This prevents the scenario of someone altering data and also changing the hash to match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53bd3331f309cfd6d8eeacec7a8068398ef70fcf" translate="yes" xml:space="preserve">
          <source>This is the &lt;em&gt;Fast Shutdown&lt;/em&gt; mode. The server disallows new connections and sends all existing server processes SIGTERM, which will cause them to abort their current transactions and exit promptly. It then waits for all server processes to exit and finally shuts down. If the server is in online backup mode, backup mode will be terminated, rendering the backup useless.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9519f8334dda9bed264446e6f4818cc6899e6c5a" translate="yes" xml:space="preserve">
          <source>This is the &lt;em&gt;Immediate Shutdown&lt;/em&gt; mode. The server will send SIGQUIT to all child processes and wait for them to terminate. If any do not terminate within 5 seconds, they will be sent SIGKILL. The master server process exits as soon as all child processes have exited, without doing normal database shutdown processing. This will lead to recovery (by replaying the WAL log) upon next start-up. This is recommended only in emergencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64dec29096a90e2ac7b66bae5da2edc5f6e90310" translate="yes" xml:space="preserve">
          <source>This is the &lt;em&gt;Smart Shutdown&lt;/em&gt; mode. After receiving SIGTERM, the server disallows new connections, but lets existing sessions end their work normally. It shuts down only after all of the sessions terminate. If the server is in online backup mode, it additionally waits until online backup mode is no longer active. While backup mode is active, new connections will still be allowed, but only to superusers (this exception allows a superuser to connect to terminate online backup mode). If the server is in recovery when a smart shutdown is requested, recovery and streaming replication will be stopped only after all regular sessions have terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92dd6728f5fbf932d72131603602b0280b7afbb6" translate="yes" xml:space="preserve">
          <source>This is the amount of time to wait on a lock before checking to see if there is a deadlock condition. The check for deadlock is relatively expensive, so the server doesn't run it every time it waits for a lock. We optimistically assume that deadlocks are not common in production applications and just wait on the lock for a while before checking for a deadlock. Increasing this value reduces the amount of time wasted in needless deadlock checks, but slows down reporting of real deadlock errors. If this value is specified without units, it is taken as milliseconds. The default is one second (&lt;code&gt;1s&lt;/code&gt;), which is probably about the smallest value you would want in practice. On a heavily loaded server you might want to raise it. Ideally the setting should exceed your typical transaction time, so as to improve the odds that a lock will be released before the waiter decides to check for deadlock. Only superusers can change this setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66c8088759f9087b738e1b70d1cf37c8a1aae852" translate="yes" xml:space="preserve">
          <source>This is the default format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce226ef1a13e0c7b419788ac5e73819bf180bcb" translate="yes" xml:space="preserve">
          <source>This is the generic &amp;ldquo;I couldn't find a server to talk to&amp;rdquo; failure. It looks like the above when TCP/IP communication is attempted. A common mistake is to forget to configure the server to allow TCP/IP connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a73a092e455b0519a284ead127b2916ee3a2346" translate="yes" xml:space="preserve">
          <source>This is the interval between updates to &lt;code&gt;autoprewarm.blocks&lt;/code&gt;. The default is 300 seconds. If set to 0, the file will not be dumped at regular intervals, but only when the server is shut down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a967763949218bdd201f81e3734208d5693135c" translate="yes" xml:space="preserve">
          <source>This is the most secure of the currently provided methods, but it is not supported by older client libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281ee2a6d6b295f0c605c272cbd3a317a0476533" translate="yes" xml:space="preserve">
          <source>This is the price one pays for extensibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49d24e044b41980e036610f5fc7a5e4be7955e6" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;pg_relpages(regclass)&lt;/code&gt;, except that the target relation is specified as TEXT. This function is kept because of backward-compatibility so far, and will be deprecated in some future release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64132a4b93c0dbcab91f77d1ac58e1693be7385b" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;pgstatindex(regclass)&lt;/code&gt;, except that the target index is specified as TEXT. This function is kept because of backward-compatibility so far, and will be deprecated in some future release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54441c2148265c644b6e2c6b5762a5242346cb3d" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;pgstattuple(regclass)&lt;/code&gt;, except that the target relation is specified as TEXT. This function is kept because of backward-compatibility so far, and will be deprecated in some future release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece1f9875ce6ffc21558f8024d23103c3c5eb710" translate="yes" xml:space="preserve">
          <source>This is the same example using normalized ranking:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b095631465e3260d63a74afe0d97ae2d96edf684" translate="yes" xml:space="preserve">
          <source>This is the same query as above, but we added a &lt;code&gt;LIMIT&lt;/code&gt; so that not all the rows need be retrieved, and the planner changed its mind about what to do. Notice that the total cost and row count of the Index Scan node are shown as if it were run to completion. However, the Limit node is expected to stop after retrieving only a fifth of those rows, so its total cost is only a fifth as much, and that's the actual estimated cost of the query. This plan is preferred over adding a Limit node to the previous plan because the Limit could not avoid paying the startup cost of the bitmap scan, so the total cost would be something over 25 units with that approach.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94cb90e2972cc12877867d7980fc980b09691ec3" translate="yes" xml:space="preserve">
          <source>This is transformed by the parser to effectively become:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a05aa8321906cf1c74f9a81ad06926d222bf1181" translate="yes" xml:space="preserve">
          <source>This is used to specify that the foreign-data wrapper should no longer have a handler function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0dd5b48b4b716a9453020ad47edd41a0fc5866a" translate="yes" xml:space="preserve">
          <source>This is used to specify that the foreign-data wrapper should no longer have a validator function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d30d7211e06d7778bc4cd17adf8c8ca724a370e3" translate="yes" xml:space="preserve">
          <source>This is what you are most likely to get if you succeed in contacting the server, but it does not want to talk to you. As the message suggests, the server refused the connection request because it found no matching entry in its &lt;code&gt;pg_hba.conf&lt;/code&gt; configuration file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa56032fee9f040556b310dd23691f09946834cc" translate="yes" xml:space="preserve">
          <source>This is wrong since it is not clear which child table the key value 200 belongs in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0515e31998ba6bb73d0ddae64599b98492334cc8" translate="yes" xml:space="preserve">
          <source>This is, subtract the null fraction from one for each of the relations, and divide by the maximum of the numbers of distinct values. The number of rows that the join is likely to emit is calculated as the cardinality of the Cartesian product of the two inputs, multiplied by the selectivity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f72ee86e21efe6631404a3bf422fe90ce0b7b5" translate="yes" xml:space="preserve">
          <source>This key word is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf5892ae182b1129c89233a93f9d2dff22e3a50" translate="yes" xml:space="preserve">
          <source>This keyword immediately precedes the declaration of one or two relation names that provide access to the transition relations of the triggering statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e080950e112255fe2f612123624be96d15f65967" translate="yes" xml:space="preserve">
          <source>This latter equivalence does not hold exactly when more than two tables appear, because &lt;code&gt;JOIN&lt;/code&gt; binds more tightly than comma. For example &lt;code&gt;FROM T1 CROSS JOIN T2 INNER JOIN T3 ON condition&lt;/code&gt; is not the same as &lt;code&gt;FROM T1, T2 INNER JOIN T3 ON condition&lt;/code&gt; because the &lt;code&gt;condition&lt;/code&gt; can reference &lt;code&gt;T1&lt;/code&gt; in the first case but not the second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4445598676898e3b5c713e7c5758010ce357bcd1" translate="yes" xml:space="preserve">
          <source>This level is different from Read Committed in that a query in a repeatable read transaction sees a snapshot as of the start of the first non-transaction-control statement in the &lt;em&gt;transaction&lt;/em&gt;, not as of the start of the current statement within the transaction. Thus, successive &lt;code&gt;SELECT&lt;/code&gt; commands within a &lt;em&gt;single&lt;/em&gt; transaction see the same data, i.e., they do not see changes made by other transactions that committed after their own transaction started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b43064679af2be0d9a41eca78e98514d704b879" translate="yes" xml:space="preserve">
          <source>This level of integrity protection using Serializable transactions does not yet extend to hot standby mode (&lt;a href=&quot;hot-standby&quot;&gt;Section 26.5&lt;/a&gt;). Because of that, those using hot standby may want to use Repeatable Read and explicit locking on the master.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81dc2dc08c39c5d2f9e3dd37d41f417f52e2a9fc" translate="yes" xml:space="preserve">
          <source>This limits the usefulness of the &lt;code&gt;passwordcheck&lt;/code&gt; module, because in that case it can only try to guess the password. For this reason, &lt;code&gt;passwordcheck&lt;/code&gt; is not recommended if your security requirements are high. It is more secure to use an external authentication method such as GSSAPI (see &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;) than to rely on passwords within the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a5e3d694aabd0836b4470958df1839ef5142811" translate="yes" xml:space="preserve">
          <source>This may be more intuitive if you are using &lt;code&gt;pg_ctl&lt;/code&gt; for starting and stopping the server (see &lt;a href=&quot;server-start&quot;&gt;Section 18.3&lt;/a&gt;), so that &lt;code&gt;pg_ctl&lt;/code&gt; would be the sole command you use for managing the database server instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa0eac4f1545a9ddc55a9ceb07c6c1edc0186f1" translate="yes" xml:space="preserve">
          <source>This means that the server was not started, or it was not started where &lt;code&gt;createdb&lt;/code&gt; expected it. Again, check the installation instructions or consult the administrator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ded18d2e27ab98a47b51417474a9c5eeb41e0e40" translate="yes" xml:space="preserve">
          <source>This mechanism prevents unencrypted data from being read from the drives if the drives or the entire computer is stolen. This does not protect against attacks while the file system is mounted, because when mounted, the operating system provides an unencrypted view of the data. However, to mount the file system, you need some way for the encryption key to be passed to the operating system, and sometimes the key is stored somewhere on the host that mounts the disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4541818976374d79642c0f93c22dbb7a713f72ad" translate="yes" xml:space="preserve">
          <source>This method consolidates information in the tree. Given a set of entries, this function generates a new index entry that represents all the given entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc385497c58aec7319cf4002de1bf0ca8c1d4cff" translate="yes" xml:space="preserve">
          <source>This method of upgrading can be performed using the built-in logical replication facilities as well as using external logical replication systems such as pglogical, Slony, Londiste, and Bucardo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82b2800cab107f6d05df0ae989ccbd67016a0ee1" translate="yes" xml:space="preserve">
          <source>This might cause zero, one, or many rows to be updated. It is not an error to attempt an update that does not match any rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264f830b811a6d6b8c58c36cb7fd806990f75f99" translate="yes" xml:space="preserve">
          <source>This might produce log output such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b493978753faced6c574bfe3060740f6644ad55e" translate="yes" xml:space="preserve">
          <source>This mode is provided for those who insist on it, but you are not necessarily encouraged to use it. In particular, if you mix SQL and meta-commands on a line the order of execution might not always be clear to the inexperienced user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9301bd35d933ed8044c02b82956382914754a7" translate="yes" xml:space="preserve">
          <source>This module implements a data type &lt;code&gt;cube&lt;/code&gt; for representing multidimensional cubes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e33606e025a4455156d4072de6e226ed4b94f7" translate="yes" xml:space="preserve">
          <source>This module implements a data type &lt;code&gt;ltree&lt;/code&gt; for representing labels of data stored in a hierarchical tree-like structure. Extensive facilities for searching through label trees are provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e72760dc721284c431bb3ba272b6dca3b540e0f1" translate="yes" xml:space="preserve">
          <source>This module implements a data type &lt;code&gt;seg&lt;/code&gt; for representing line segments, or floating point intervals. &lt;code&gt;seg&lt;/code&gt; can represent uncertainty in the interval endpoints, making it especially useful for representing laboratory measurements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd33542f64474fba94a46e6b605e9b2299f1bab" translate="yes" xml:space="preserve">
          <source>This module implements the &lt;code&gt;hstore&lt;/code&gt; data type for storing sets of key/value pairs within a single PostgreSQL value. This can be useful in various scenarios, such as rows with many attributes that are rarely examined, or semi-structured data. Keys and values are simply text strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0a2c458306a9179b18df224706a81701d0af82" translate="yes" xml:space="preserve">
          <source>This module integrates with SELinux to provide an additional layer of security checking above and beyond what is normally provided by PostgreSQL. From the perspective of SELinux, this module allows PostgreSQL to function as a user-space object manager. Each table or function access initiated by a DML query will be checked against the system security policy. This check is in addition to the usual SQL permissions checking performed by PostgreSQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269393947826c6d71fccaff13c4be9c80ca40682" translate="yes" xml:space="preserve">
          <source>This module is sponsored by Delta-Soft Ltd., Moscow, Russia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4056f705daa3e3fdd49196fac6596ba7b2aa2807" translate="yes" xml:space="preserve">
          <source>This module was inspired by Garrett A. Wollman's &lt;code&gt;isbn_issn&lt;/code&gt; code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="141bf6865546870a10c076189dfdbdeb9f73407a" translate="yes" xml:space="preserve">
          <source>This naming convention establishes a clear order in which these files will be loaded. This is important because only the last setting encountered for a particular parameter while the server is reading configuration files will be used. In this example, something set in &lt;code&gt;conf.d/02server.conf&lt;/code&gt; would override a value set in &lt;code&gt;conf.d/01memory.conf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833c4d41d72807ff8bff00dc171b711add76bff2" translate="yes" xml:space="preserve">
          <source>This node's LSN at which &lt;code&gt;remote_lsn&lt;/code&gt; has been replicated. Used to flush commit records before persisting data to disk when using asynchronous commits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="388063f0d1bc8c68724a848b5427707b09f5e0a2" translate="yes" xml:space="preserve">
          <source>This notation behaves differently depending on context; see &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff98e9774f8c6e6fad6dce4d14a177af4ff71408" translate="yes" xml:space="preserve">
          <source>This operator supports hash joins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c90e947b03275ac339cbaa9aa960fdd656aa3ae" translate="yes" xml:space="preserve">
          <source>This operator supports merge joins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033a065728054a33c7f38b0e616194e5c2c3aaa5" translate="yes" xml:space="preserve">
          <source>This option allows running &lt;code&gt;pg_dump -j&lt;/code&gt; against a pre-9.2 server, see the documentation of the &lt;code&gt;-j&lt;/code&gt; parameter for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67692a76bdedd175ae4ea2832082e8bfa1d20815" translate="yes" xml:space="preserve">
          <source>This option always affects transfer of the data directory. Transfer of WAL files is only affected if the collection method is &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b9c3dfa7b75f649757901e5e89c1862e7c3ada" translate="yes" xml:space="preserve">
          <source>This option can be set by any user. Because of that, the libraries that can be loaded are restricted to those appearing in the &lt;code&gt;plugins&lt;/code&gt; subdirectory of the installation's standard library directory. (It is the database administrator's responsibility to ensure that only &amp;ldquo;safe&amp;rdquo; libraries are installed there.) Entries in &lt;code&gt;local_preload_libraries&lt;/code&gt; can specify this directory explicitly, for example &lt;code&gt;$libdir/plugins/mylib&lt;/code&gt;, or just specify the library name &amp;mdash; &lt;code&gt;mylib&lt;/code&gt; would have the same effect as &lt;code&gt;$libdir/plugins/mylib&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a0fc1ca8b2fbb1af9a9d77b22b8df428dc16da8" translate="yes" xml:space="preserve">
          <source>This option can only be used in combination with one or more &lt;code&gt;-c&lt;/code&gt; and/or &lt;code&gt;-f&lt;/code&gt; options. It causes psql to issue a &lt;code&gt;BEGIN&lt;/code&gt; command before the first such option and a &lt;code&gt;COMMIT&lt;/code&gt; command after the last one, thereby wrapping all the commands into a single transaction. This ensures that either all the commands complete successfully, or no changes are applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4af26bb42d56efbdd77ea30d507197b50c1c0a6e" translate="yes" xml:space="preserve">
          <source>This option can only be used together with &lt;code&gt;-X stream&lt;/code&gt;. It causes the WAL streaming to use the specified replication slot. If the base backup is intended to be used as a streaming replication standby using replication slots, it should then use the same replication slot name in &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-SLOT-NAME&quot;&gt;primary_slot_name&lt;/a&gt;. That way, it is ensured that the server does not remove any necessary WAL data in the time between the end of the base backup and the start of streaming replication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dcf604d43dc6007ea78136bf7b33be7b4e62ae3" translate="yes" xml:space="preserve">
          <source>This option cannot be used to remove the support function altogether, since it must name a new support function. Use &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; if you need to do that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd8d44929298a4cbf2c87cec1c31093bc64b155b" translate="yes" xml:space="preserve">
          <source>This option causes &lt;code&gt;pg_receivewal&lt;/code&gt; to not force WAL data to be flushed to disk. This is faster, but means that a subsequent operating system crash can leave the WAL segments corrupt. Generally, this option is useful for testing but should not be used when doing WAL archiving on a production deployment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a83f03d78ff431f987c79d1993890ac0162fd03" translate="yes" xml:space="preserve">
          <source>This option causes creation of a replication slot named by the &lt;code&gt;--slot&lt;/code&gt; option before starting the backup. An error is raised if the slot already exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="019a3bff9bc43aecc3893ea645652e695f875fd1" translate="yes" xml:space="preserve">
          <source>This option controls the behavior of automatically updatable views. When this option is specified, &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands on the view will be checked to ensure that new rows satisfy the view-defining condition (that is, the new rows are checked to ensure that they are visible through the view). If they are not, the update will be rejected. If the &lt;code&gt;CHECK OPTION&lt;/code&gt; is not specified, &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands on the view are allowed to create rows that are not visible through the view. The following check options are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa12085b7bbeed5763de22cebaafe8cc79d4acb" translate="yes" xml:space="preserve">
          <source>This option controls whether &lt;code&gt;postgres_fdw&lt;/code&gt; allows foreign tables to be modified using &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; commands. It can be specified for a foreign table or a foreign server. A table-level option overrides a server-level option. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c306234b370cc56fe65c31871921559cfe86c86e" translate="yes" xml:space="preserve">
          <source>This option controls whether column &lt;code&gt;COLLATE&lt;/code&gt; options are included in the definitions of foreign tables imported from a foreign server. The default is &lt;code&gt;true&lt;/code&gt;. You might need to turn this off if the remote server has a different set of collation names than the local server does, which is likely to be the case if it's running on a different operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a2c7892fe0f505a8ed2a71e7d9d8917529e89f4" translate="yes" xml:space="preserve">
          <source>This option controls whether column &lt;code&gt;DEFAULT&lt;/code&gt; expressions are included in the definitions of foreign tables imported from a foreign server. The default is &lt;code&gt;false&lt;/code&gt;. If you enable this option, be wary of defaults that might get computed differently on the local server than they would be on the remote server; &lt;code&gt;nextval()&lt;/code&gt; is a common source of problems. The &lt;code&gt;IMPORT&lt;/code&gt; will fail altogether if an imported default expression uses a function or operator that does not exist locally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c777fcd8f37f1faf36e546a259bf3994c8ebf0b0" translate="yes" xml:space="preserve">
          <source>This option controls whether column &lt;code&gt;NOT NULL&lt;/code&gt; constraints are included in the definitions of foreign tables imported from a foreign server. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4534428c01b535724cfe3334dea2585c43336e1" translate="yes" xml:space="preserve">
          <source>This option disables the use of dollar quoting for function bodies, and forces them to be quoted using SQL standard string syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5b8577c4f91feed1cbbbf28c3713fcd0567f3a" translate="yes" xml:space="preserve">
          <source>This option dumps out the server's internal configuration variables, descriptions, and defaults in tab-delimited &lt;code&gt;COPY&lt;/code&gt; format. It is designed primarily for use by administration tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d1d4f9b39a2419e5e71963676b76de7092eb75" translate="yes" xml:space="preserve">
          <source>This option has no effect on &lt;code&gt;-N&lt;/code&gt;/&lt;code&gt;--exclude-schema&lt;/code&gt;, &lt;code&gt;-T&lt;/code&gt;/&lt;code&gt;--exclude-table&lt;/code&gt;, or &lt;code&gt;--exclude-table-data&lt;/code&gt;. An exclude pattern failing to match any objects is not considered an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44b5c0279373253dcf944caef48c35c814e3748e" translate="yes" xml:space="preserve">
          <source>This option has the same effect as the option of the same name in &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;. See the description there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e156f33e8e3c423b7dd6e39f40b8d2b97fdc7406" translate="yes" xml:space="preserve">
          <source>This option is a comma-separated list of names of PostgreSQL extensions that are installed, in compatible versions, on both the local and remote servers. Functions and operators that are immutable and belong to a listed extension will be considered shippable to the remote server. This option can only be specified for foreign servers, not per-table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd3ca03402c96b67aa550ad0869d48010fb66dab" translate="yes" xml:space="preserve">
          <source>This option is deprecated since it does not allow access to the full functionality of &lt;a href=&quot;runtime-config-connection#GUC-LISTEN-ADDRESSES&quot;&gt;listen_addresses&lt;/a&gt;. It's usually better to set &lt;code&gt;listen_addresses&lt;/code&gt; directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b68d58ae84a3ecac214be2012e7c336871134f8" translate="yes" xml:space="preserve">
          <source>This option is effective only when restoring directly into a database, not when producing SQL script output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968dc4a560c532375e657416e7cf0bbd50ef3170" translate="yes" xml:space="preserve">
          <source>This option is for debugging problems that cause a server process to die abnormally. The ordinary strategy in this situation is to notify all other server processes that they must terminate and then reinitialize the shared memory and semaphores. This is because an errant server process could have corrupted some shared state before terminating. This option specifies that &lt;code&gt;postgres&lt;/code&gt; will not reinitialize shared data structures. A knowledgeable system programmer can then use a debugger to examine shared memory and semaphore state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42927906afa65b972047e92608a8fe2f81b95297" translate="yes" xml:space="preserve">
          <source>This option is for debugging problems that cause a server process to die abnormally. The ordinary strategy in this situation is to notify all other server processes that they must terminate and then reinitialize the shared memory and semaphores. This is because an errant server process could have corrupted some shared state before terminating. This option specifies that &lt;code&gt;postgres&lt;/code&gt; will stop all other server processes by sending the signal &lt;code&gt;SIGSTOP&lt;/code&gt;, but will not cause them to terminate. This permits system programmers to collect core dumps from all server processes by hand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2fa6b1b1272f22fc7098675bb1c64f065394241" translate="yes" xml:space="preserve">
          <source>This option is for use by in-place upgrade utilities. Its use for other purposes is not recommended or supported. The behavior of the option may change in future releases without notice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efc4bf4d899439505edd24a5ec7b6f3018597535" translate="yes" xml:space="preserve">
          <source>This option is incompatible with &lt;code&gt;--synchronous&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4f9dc483d33770bfc633e073d626e91a285814" translate="yes" xml:space="preserve">
          <source>This option is like &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt;, but it describes the behavior of the moving-aggregate final function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae64748d4bfb71bb191824f72616015218279c62" translate="yes" xml:space="preserve">
          <source>This option is meant for other programs that interact with a server instance, such as &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt;, to query configuration parameter values. User-facing applications should instead use &lt;a href=&quot;sql-show&quot;&gt;SHOW&lt;/a&gt; or the &lt;code&gt;pg_settings&lt;/code&gt; view.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
