<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="90c655a8d399c68ec546283b401cd86c6d3da561" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; command conforms to the SQL standard, except that the &lt;code&gt;OPTIONS&lt;/code&gt; clause is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; のコマンド準拠していることを除き、SQL標準へ &lt;code&gt;OPTIONS&lt;/code&gt; 句はPostgreSQLの拡張です。</target>
        </trans-unit>
        <trans-unit id="e2a88d188f36cc114975839b521433281fe355dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN ROLE&lt;/code&gt; clause lists one or more existing roles to which the new role will be immediately added as a new member. (Note that there is no option to add the new role as an administrator; use a separate &lt;code&gt;GRANT&lt;/code&gt; command to do that.)</source>
          <target state="translated">&lt;code&gt;IN ROLE&lt;/code&gt; 句リスト1つまたは複数の新しい役割がすぐに新しいメンバーとして追加される既存の役割。 （新しい役割を管理者として追加するオプションはありません。別の &lt;code&gt;GRANT&lt;/code&gt; コマンドを使用して追加してください。）</target>
        </trans-unit>
        <trans-unit id="3b0c6bd082b9438730c44b123984d29738293313" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INHERIT&lt;/code&gt; attribute governs inheritance of grantable privileges (that is, access privileges for database objects and role memberships). It does not apply to the special role attributes set by &lt;code&gt;CREATE ROLE&lt;/code&gt; and &lt;code&gt;ALTER ROLE&lt;/code&gt;. For example, being a member of a role with &lt;code&gt;CREATEDB&lt;/code&gt; privilege does not immediately grant the ability to create databases, even if &lt;code&gt;INHERIT&lt;/code&gt; is set; it would be necessary to become that role via &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; before creating a database.</source>
          <target state="translated">&lt;code&gt;INHERIT&lt;/code&gt; の属性は、（データベース・オブジェクトとロール・メンバーシップのためのアクセス権限で）付与可能な権限の継承を管理します。 &lt;code&gt;CREATE ROLE&lt;/code&gt; および &lt;code&gt;ALTER ROLE&lt;/code&gt; によって設定される特別なロール属性には適用されません。たとえば、 &lt;code&gt;CREATEDB&lt;/code&gt; 権限を持つロールのメンバーであっても、 &lt;code&gt;INHERIT&lt;/code&gt; が設定されていても、データベースを作成する機能はすぐには付与されません。データベースを作成する前に、&lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;を介してその役割になる必要があります。</target>
        </trans-unit>
        <trans-unit id="11950124f137ab1b3b29d5312c33140b0085fa30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INHERIT&lt;/code&gt; attribute is the default for reasons of backwards compatibility: in prior releases of PostgreSQL, users always had access to all privileges of groups they were members of. However, &lt;code&gt;NOINHERIT&lt;/code&gt; provides a closer match to the semantics specified in the SQL standard.</source>
          <target state="translated">&lt;code&gt;INHERIT&lt;/code&gt; の属性は、後方互換性の理由のためにデフォルトで：PostgreSQLの以前のリリースでは、ユーザーは常に彼らはのメンバーだったグループのすべての権限へのアクセスを持っていました。ただし、 &lt;code&gt;NOINHERIT&lt;/code&gt; は、SQL標準で指定されているセマンティクスにより近い一致を提供します。</target>
        </trans-unit>
        <trans-unit id="d1a4f9690ce7e26c8924892aa7417c3dc21a3ae2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INSERT&lt;/code&gt; statement is used to populate a table with rows:</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; のステートメントは、行を持つ表を移入するために使用されます。</target>
        </trans-unit>
        <trans-unit id="bb164c110048f642f9967f6798e5f2daa48843e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INTERSECT&lt;/code&gt; clause has this general form:</source>
          <target state="translated">&lt;code&gt;INTERSECT&lt;/code&gt; の句は、この一般的な形式があります：</target>
        </trans-unit>
        <trans-unit id="b0af4aa2cff56983554b5dfd6aea4022d42a30a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INTERSECT&lt;/code&gt; operator computes the set intersection of the rows returned by the involved &lt;code&gt;SELECT&lt;/code&gt; statements. A row is in the intersection of two result sets if it appears in both result sets.</source>
          <target state="translated">&lt;code&gt;INTERSECT&lt;/code&gt; のオペレータが関与によって返される行の積集合を計算 &lt;code&gt;SELECT&lt;/code&gt; 文を。行が両方の結果セットに表示される場合、その行は2つの結果セットの交差部分にあります。</target>
        </trans-unit>
        <trans-unit id="3710966a5964edf86a5e94dad6ccef2f09e50690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ISBN&lt;/code&gt;, &lt;code&gt;ISMN&lt;/code&gt;, and &lt;code&gt;ISSN&lt;/code&gt; types will display the short version of the number (ISxN 10) whenever it's possible, and will show ISxN 13 format for numbers that do not fit in the short version. The &lt;code&gt;EAN13&lt;/code&gt;, &lt;code&gt;ISBN13&lt;/code&gt;, &lt;code&gt;ISMN13&lt;/code&gt; and &lt;code&gt;ISSN13&lt;/code&gt; types will always display the long version of the ISxN (EAN13).</source>
          <target state="translated">&lt;code&gt;ISBN&lt;/code&gt; 、 &lt;code&gt;ISMN&lt;/code&gt; 、および &lt;code&gt;ISSN&lt;/code&gt; の種類は、それが可能だ時はいつでも数（ISxN 10）のショートバージョンが表示され、短いバージョンに収まらない数値のISxN 13のフォーマットが表示されます。 &lt;code&gt;EAN13&lt;/code&gt; 、 &lt;code&gt;ISBN13&lt;/code&gt; 、 &lt;code&gt;ISMN13&lt;/code&gt; と &lt;code&gt;ISSN13&lt;/code&gt; タイプは常にISxN（EAN13）の長いバージョンが表示されます。</target>
        </trans-unit>
        <trans-unit id="7b1a2d9b3af27ec14ac83825b4e9390e81b28ab6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IntervalStyle&lt;/code&gt; parameter also affects the interpretation of ambiguous interval input. See &lt;a href=&quot;datatype-datetime#DATATYPE-INTERVAL-INPUT&quot;&gt;Section 8.5.4&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;IntervalStyle&lt;/code&gt; パラメータも曖昧な間隔入力の解釈に影響を与えます。詳細は、&lt;a href=&quot;datatype-datetime#DATATYPE-INTERVAL-INPUT&quot;&gt;8.5.4&lt;/a&gt;項を参照してください。</target>
        </trans-unit>
        <trans-unit id="3cb07a7b0b456e75c7d7fb8309d5a950ea4dfdb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LATERAL&lt;/code&gt; key word can precede a sub-&lt;code&gt;SELECT&lt;/code&gt;&lt;code&gt;FROM&lt;/code&gt; item. This allows the sub-&lt;code&gt;SELECT&lt;/code&gt; to refer to columns of &lt;code&gt;FROM&lt;/code&gt; items that appear before it in the &lt;code&gt;FROM&lt;/code&gt; list. (Without &lt;code&gt;LATERAL&lt;/code&gt;, each sub-&lt;code&gt;SELECT&lt;/code&gt; is evaluated independently and so cannot cross-reference any other &lt;code&gt;FROM&lt;/code&gt; item.)</source>
          <target state="translated">&lt;code&gt;LATERAL&lt;/code&gt; キーワードは、サブ先行することができる &lt;code&gt;SELECT&lt;/code&gt; を &lt;code&gt;FROM&lt;/code&gt; 項目。これにより、サブ &lt;code&gt;SELECT&lt;/code&gt; は &lt;code&gt;FROM&lt;/code&gt; リストの前にある &lt;code&gt;FROM&lt;/code&gt; アイテムの列を参照できます。（ &lt;code&gt;LATERAL&lt;/code&gt; がない場合、各サブ &lt;code&gt;SELECT&lt;/code&gt; は独立して評価されるため、他の &lt;code&gt;FROM&lt;/code&gt; 項目を相互参照することはできません。）</target>
        </trans-unit>
        <trans-unit id="0a14b782795f85302f04f02639a6c4f62ab4e062" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIKE&lt;/code&gt; clause can also be used to copy column definitions from views, foreign tables, or composite types. Inapplicable options (e.g., &lt;code&gt;INCLUDING INDEXES&lt;/code&gt; from a view) are ignored.</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; の句は、ビュー、外部テーブル、または複合型から列の定義をコピーするために使用することができます。適用できないオプション（たとえば、ビューの &lt;code&gt;INCLUDING INDEXES&lt;/code&gt; ）は無視されます。</target>
        </trans-unit>
        <trans-unit id="396ab12c5362824aaa283637f9c77c9a00f331f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIKE&lt;/code&gt; clause specifies a table from which the new table automatically copies all column names, their data types, and their not-null constraints.</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; の句は、すべての列名、そのデータ型、およびその非NULL制約自動的にコピー新しいテーブルするテーブルを指定します。</target>
        </trans-unit>
        <trans-unit id="572dfcd3f9f7897b067c547ebc46891efd6417fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIKE&lt;/code&gt; expression returns true if the &lt;code&gt;string&lt;/code&gt; matches the supplied &lt;code&gt;pattern&lt;/code&gt;. (As expected, the &lt;code&gt;NOT LIKE&lt;/code&gt; expression returns false if &lt;code&gt;LIKE&lt;/code&gt; returns true, and vice versa. An equivalent expression is &lt;code&gt;NOT (string LIKE pattern)&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; の場合、式はtrueを返し &lt;code&gt;string&lt;/code&gt; 提供されたマッチする &lt;code&gt;pattern&lt;/code&gt; 。（予想どおり、 &lt;code&gt;LIKE&lt;/code&gt; がtrueを返す場合、 &lt;code&gt;NOT LIKE&lt;/code&gt; 式はfalseを返します。その逆も同様です。同等の式は &lt;code&gt;NOT (string LIKE pattern)&lt;/code&gt; です。）</target>
        </trans-unit>
        <trans-unit id="258e69d1b09cf77569de7c47f8a8dba66e04bb7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIKE&lt;/code&gt; operator does pattern matching and is explained in &lt;a href=&quot;functions-matching&quot;&gt;Section 9.7&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; のオペレータは、パターンマッチングを行い、で説明されている&lt;a href=&quot;functions-matching&quot;&gt;セクション9.7&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7480e6b2427d5d0d2afbc0d3981cabf8d8c5a5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIMIT&lt;/code&gt; clause consists of two independent sub-clauses:</source>
          <target state="translated">&lt;code&gt;LIMIT&lt;/code&gt; の句は、2つの独立したサブ句で構成されています。</target>
        </trans-unit>
        <trans-unit id="5092a579b1157c3ece79f6e0b69fb148ae975b71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MATERIALIZED&lt;/code&gt; and &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; options of &lt;code&gt;WITH&lt;/code&gt; are extensions of the SQL standard.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; の &lt;code&gt;MATERIALIZED&lt;/code&gt; および &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; オプションは、SQL標準の拡張機能です。</target>
        </trans-unit>
        <trans-unit id="03c245095fff9e37994e71505cc2de7e6fbaeb07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MergeJoin&lt;/code&gt; node similarly demands the first row from its right subplan. Then it compares the two rows to see if they can be joined; if so, it returns a join row to its caller. On the next call, or immediately if it cannot join the current pair of inputs, it advances to the next row of one table or the other (depending on how the comparison came out), and again checks for a match. Eventually, one subplan or the other is exhausted, and the &lt;code&gt;MergeJoin&lt;/code&gt; node returns NULL to indicate that no more join rows can be formed.</source>
          <target state="translated">&lt;code&gt;MergeJoin&lt;/code&gt; のノードは、同様に、その右サブプランから最初の行を要求します。次に、2つの行を比較して、それらが結合できるかどうかを確認します。もしそうなら、それはその呼び出し元に結合行を返します。次の呼び出し時、または現在の入力のペアに参加できない場合はすぐに、（比較の結果に応じて）いずれかのテーブルの次の行に進み、再度一致をチェックします。最終的に、いずれかのサブプランが使い果たされ、 &lt;code&gt;MergeJoin&lt;/code&gt; ノードはNULLを返し、これ以上結合行を形成できないことを示します。</target>
        </trans-unit>
        <trans-unit id="50c96e90dd3ca2b2b4787fd18890dca99f28ab8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NONE&lt;/code&gt; and &lt;code&gt;RESET&lt;/code&gt; forms reset the current user identifier to be the current session user identifier. These forms can be executed by any user.</source>
          <target state="translated">&lt;code&gt;NONE&lt;/code&gt; および &lt;code&gt;RESET&lt;/code&gt; 形態は、現在のユーザ識別子が現在のセッションのユーザ識別子にリセット。これらのフォームは、どのユーザーでも実行できます。</target>
        </trans-unit>
        <trans-unit id="6b13dc16a3a4fce3da18ccb704fb39295955bdea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOT NULL&lt;/code&gt; constraint has an inverse: the &lt;code&gt;NULL&lt;/code&gt; constraint. This does not mean that the column must be null, which would surely be useless. Instead, this simply selects the default behavior that the column might be null. The &lt;code&gt;NULL&lt;/code&gt; constraint is not present in the SQL standard and should not be used in portable applications. (It was only added to PostgreSQL to be compatible with some other database systems.) Some users, however, like it because it makes it easy to toggle the constraint in a script file. For example, you could start with:</source>
          <target state="translated">&lt;code&gt;NOT NULL&lt;/code&gt; の制約が逆を持っています &lt;code&gt;NULL&lt;/code&gt; の制約を。これは、列がnullである必要があることを意味するものではありません。代わりに、これは列がnullになる可能性があるデフォルトの動作を選択するだけです。 &lt;code&gt;NULL&lt;/code&gt; の制約は標準SQLには存在せず、ポータブルアプリケーションでは使用しないでください。（他のいくつかのデータベースシステムと互換性を持たせるためにPostgreSQLに追加されただけです。）ただし、スクリプトファイルで制約を簡単に切り替えることができるため、一部のユーザーは気に入っています。たとえば、次のように開始できます。</target>
        </trans-unit>
        <trans-unit id="bea1d2c35460104bbb73410ce7cfdee6383ad73d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOTIFY&lt;/code&gt; command sends a notification event together with an optional &amp;ldquo;payload&amp;rdquo; string to each client application that has previously executed &lt;code&gt;LISTEN channel&lt;/code&gt; for the specified channel name in the current database. Notifications are visible to all users.</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; コマンドは、以前に実行した各クライアントアプリケーションにオプションの「ペイロード」の文字列と一緒に通知イベントを送信する &lt;code&gt;LISTEN channel&lt;/code&gt; 現在のデータベース内の指定されたチャンネル名を。通知はすべてのユーザーに表示されます。</target>
        </trans-unit>
        <trans-unit id="cc1aa8547d4f45a3a74ddce2ee6f66c1ad2e63b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NULL&lt;/code&gt; keyword is case-insensitive. Double-quote the &lt;code&gt;NULL&lt;/code&gt; to treat it as the ordinary string &amp;ldquo;NULL&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; のキーワードは大文字と小文字を区別しません。 &lt;code&gt;NULL&lt;/code&gt; を二重引用符で囲んで、通常の文字列「NULL」として扱います。</target>
        </trans-unit>
        <trans-unit id="962da68b59592e76d7efdc84ac1e5105db667c11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NULL&lt;/code&gt;&amp;ldquo;constraint&amp;rdquo; (actually a non-constraint) is a PostgreSQL extension to the SQL standard that is included for compatibility with some other database systems (and for symmetry with the &lt;code&gt;NOT NULL&lt;/code&gt; constraint). Since it is the default for any column, its presence is simply noise.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 「制約」（実際は非制約）は、他のいくつかのデータベースシステムとの互換性のために含まれ（ととの対称性のためにされたSQL標準に対するPostgreSQLの拡張です &lt;code&gt;NOT NULL&lt;/code&gt; 制約）。これはすべての列のデフォルトであるため、その存在は単なるノイズです。</target>
        </trans-unit>
        <trans-unit id="f89a70ab2187a4125b8af941eb48d2104a35aae4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NULLIF&lt;/code&gt; function returns a null value if &lt;code&gt;value1&lt;/code&gt; equals &lt;code&gt;value2&lt;/code&gt;; otherwise it returns &lt;code&gt;value1&lt;/code&gt;. This can be used to perform the inverse operation of the &lt;code&gt;COALESCE&lt;/code&gt; example given above:</source>
          <target state="translated">&lt;code&gt;NULLIF&lt;/code&gt; の場合、関数はNULL値を返す &lt;code&gt;value1&lt;/code&gt; 等しい &lt;code&gt;value2&lt;/code&gt; 。それ以外の場合は &lt;code&gt;value1&lt;/code&gt; を返します。これは、上記の &lt;code&gt;COALESCE&lt;/code&gt; の例の逆の操作を実行するために使用できます。</target>
        </trans-unit>
        <trans-unit id="01fdd1712e7b0454ab7f170cffda1945f0082b71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NULLS FIRST&lt;/code&gt; and &lt;code&gt;NULLS LAST&lt;/code&gt; options can be used to determine whether nulls appear before or after non-null values in the sort ordering. By default, null values sort as if larger than any non-null value; that is, &lt;code&gt;NULLS FIRST&lt;/code&gt; is the default for &lt;code&gt;DESC&lt;/code&gt; order, and &lt;code&gt;NULLS LAST&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;NULLS FIRST&lt;/code&gt; および &lt;code&gt;NULLS LAST&lt;/code&gt; オプションは、ヌルがソート順での非ヌル値の前または後に表示されるかどうかを決定するために使用することができます。デフォルトでは、null値は、null以外の値よりも大きいかのように並べ替えられます。つまり、 &lt;code&gt;NULLS FIRST&lt;/code&gt; が &lt;code&gt;DESC&lt;/code&gt; 順序のデフォルトであり、それ以外の場合は &lt;code&gt;NULLS LAST&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="db3f6d7975c35350055f22165f8267b483d36caa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ON COMMIT&lt;/code&gt; clause for temporary tables also resembles the SQL standard, but has some differences. If the &lt;code&gt;ON COMMIT&lt;/code&gt; clause is omitted, SQL specifies that the default behavior is &lt;code&gt;ON COMMIT DELETE ROWS&lt;/code&gt;. However, the default behavior in PostgreSQL is &lt;code&gt;ON COMMIT PRESERVE ROWS&lt;/code&gt;. The &lt;code&gt;ON COMMIT DROP&lt;/code&gt; option does not exist in SQL.</source>
          <target state="translated">一時テーブルの &lt;code&gt;ON COMMIT&lt;/code&gt; 句もSQL標準に似ていますが、いくつかの違いがあります。場合は &lt;code&gt;ON COMMIT&lt;/code&gt; 句が省略され、デフォルトの動作であることをSQLの指定 &lt;code&gt;ON COMMIT DELETE ROWS&lt;/code&gt; 。ただし、PostgreSQLのデフォルトの動作は &lt;code&gt;ON COMMIT PRESERVE ROWS&lt;/code&gt; です。 &lt;code&gt;ON COMMIT DROP&lt;/code&gt; オプションは、SQLに存在しません。</target>
        </trans-unit>
        <trans-unit id="472f32dda3820f4f49769a24b22c0964256b23e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ON&lt;/code&gt; clause is the most general kind of join condition: it takes a Boolean value expression of the same kind as is used in a &lt;code&gt;WHERE&lt;/code&gt; clause. A pair of rows from &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; match if the &lt;code&gt;ON&lt;/code&gt; expression evaluates to true.</source>
          <target state="translated">&lt;code&gt;ON&lt;/code&gt; の句は最も一般的な結合条件である：それはで使用されているのと同じ種類のブール値の式を取り &lt;code&gt;WHERE&lt;/code&gt; 句。 &lt;code&gt;ON&lt;/code&gt; 式がtrueと評価された場合、 &lt;code&gt;T1&lt;/code&gt; と &lt;code&gt;T2&lt;/code&gt; の行のペアが一致します。</target>
        </trans-unit>
        <trans-unit id="793025f43fd046d2375fc2d1347d2ad6be35fd9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPERATOR&lt;/code&gt; and &lt;code&gt;FUNCTION&lt;/code&gt; clauses can appear in any order.</source>
          <target state="translated">&lt;code&gt;OPERATOR&lt;/code&gt; と &lt;code&gt;FUNCTION&lt;/code&gt; 句は任意の順序で表示されます。</target>
        </trans-unit>
        <trans-unit id="fed146b628b9143aa8d465b9f6a969399e0078fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPERATOR&lt;/code&gt;, &lt;code&gt;FUNCTION&lt;/code&gt;, and &lt;code&gt;STORAGE&lt;/code&gt; clauses can appear in any order.</source>
          <target state="translated">&lt;code&gt;OPERATOR&lt;/code&gt; 、 &lt;code&gt;FUNCTION&lt;/code&gt; 、および &lt;code&gt;STORAGE&lt;/code&gt; の句は任意の順序で表示されます。</target>
        </trans-unit>
        <trans-unit id="f7408278e5a49c7a21e1d564882fc738063e8ed8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ORDER BY&lt;/code&gt; clause causes the result rows to be sorted according to the specified expression(s). If two rows are equal according to the leftmost expression, they are compared according to the next expression and so on. If they are equal according to all specified expressions, they are returned in an implementation-dependent order.</source>
          <target state="translated">&lt;code&gt;ORDER BY&lt;/code&gt; 句は、結果行が指定された式（複数可）に従ってソートされるようにします。2つの行が左端の式に従って等しい場合、それらは次の式に従って比較されます。指定されたすべての式に従って等しい場合、それらは実装依存の順序で返されます。</target>
        </trans-unit>
        <trans-unit id="b02f359cd58f3fe912dce4590fe56eb7fd3fc933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ORDER BY&lt;/code&gt; clause specifies the sort order:</source>
          <target state="translated">&lt;code&gt;ORDER BY&lt;/code&gt; 句はソート順を指定します。</target>
        </trans-unit>
        <trans-unit id="5c192bece45872266b8038f6a0a05d716d357e85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OWNED BY&lt;/code&gt; clause is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;OWNED BY&lt;/code&gt; の句はPostgreSQLの拡張です。</target>
        </trans-unit>
        <trans-unit id="bdc9e5eec52a1ba378bd2fb8274d7c97650e7deb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OWNED BY&lt;/code&gt; option causes the sequence to be associated with a specific table column, such that if that column (or its whole table) is dropped, the sequence will be automatically dropped as well. If specified, this association replaces any previously specified association for the sequence. The specified table must have the same owner and be in the same schema as the sequence. Specifying &lt;code&gt;OWNED BY NONE&lt;/code&gt; removes any existing association, making the sequence &amp;ldquo;free-standing&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;OWNED BY&lt;/code&gt; オプションは、配列がその列（またはそのテーブル全体）が落下した場合、シーケンスは自動的によくとしてドロップされるように、特定のテーブル列に関連付けさせます。指定した場合、この関連付けは、以前に指定したシーケンスの関連付けを置き換えます。指定されたテーブルは、所有者が同じで、シーケンスと同じスキーマにある必要があります。 &lt;code&gt;OWNED BY NONE&lt;/code&gt; を指定すると、既存の関連付けが削除され、シーケンスが「独立」になります。</target>
        </trans-unit>
        <trans-unit id="56fdd5a6277f3365172855b96f924d0b384fe495" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OWNED BY&lt;/code&gt; option causes the sequence to be associated with a specific table column, such that if that column (or its whole table) is dropped, the sequence will be automatically dropped as well. The specified table must have the same owner and be in the same schema as the sequence. &lt;code&gt;OWNED BY NONE&lt;/code&gt;, the default, specifies that there is no such association.</source>
          <target state="translated">&lt;code&gt;OWNED BY&lt;/code&gt; オプションは、配列がその列（またはそのテーブル全体）が落下した場合、シーケンスは自動的によくとしてドロップされるように、特定のテーブル列に関連付けさせます。指定されたテーブルは、所有者が同じで、シーケンスと同じスキーマにある必要があります。 &lt;code&gt;OWNED BY NONE&lt;/code&gt; （デフォルト）は、そのような関連付けがないことを指定します。</target>
        </trans-unit>
        <trans-unit id="6a2d7bf96f2a0b5a81febb7cc2f04c359a2ce962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PARSER&lt;/code&gt; and &lt;code&gt;COPY&lt;/code&gt; options are mutually exclusive, because when an existing configuration is copied, its parser selection is copied too.</source>
          <target state="translated">&lt;code&gt;PARSER&lt;/code&gt; と &lt;code&gt;COPY&lt;/code&gt; 既存の設定がコピーされたときに、そのパーサの選択があまりにもコピーされるためのオプションは、相互に排他的です。</target>
        </trans-unit>
        <trans-unit id="6ad47e1225da856fc1e4e1ae21e6437e7c3be2c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PARTITION BY&lt;/code&gt; clause groups the rows of the query into &lt;em&gt;partitions&lt;/em&gt;, which are processed separately by the window function. &lt;code&gt;PARTITION BY&lt;/code&gt; works similarly to a query-level &lt;code&gt;GROUP BY&lt;/code&gt; clause, except that its expressions are always just expressions and cannot be output-column names or numbers. Without &lt;code&gt;PARTITION BY&lt;/code&gt;, all rows produced by the query are treated as a single partition. The &lt;code&gt;ORDER BY&lt;/code&gt; clause determines the order in which the rows of a partition are processed by the window function. It works similarly to a query-level &lt;code&gt;ORDER BY&lt;/code&gt; clause, but likewise cannot use output-column names or numbers. Without &lt;code&gt;ORDER BY&lt;/code&gt;, rows are processed in an unspecified order.</source>
          <target state="translated">&lt;code&gt;PARTITION BY&lt;/code&gt; に句グループクエリの行&lt;em&gt;のパーティション&lt;/em&gt;窓関数によって別々に処理されています、。 &lt;code&gt;PARTITION BY&lt;/code&gt; はクエリレベルの &lt;code&gt;GROUP BY&lt;/code&gt; 句と同様に機能しますが、その式は常に単なる式であり、出力列の名前や数値にすることはできません。 &lt;code&gt;PARTITION BY&lt;/code&gt; がない場合、クエリによって生成されたすべての行は単一のパーティションとして扱われます。 &lt;code&gt;ORDER BY&lt;/code&gt; 句は、パーティションの行は窓関数で処理される順序を決定します。クエリレベルの &lt;code&gt;ORDER BY&lt;/code&gt; 句と同様に機能しますが、同様に出力列の名前や数値を使用できません。 &lt;code&gt;ORDER BY&lt;/code&gt; なし、行は不特定の順序で処理されます。</target>
        </trans-unit>
        <trans-unit id="3b20c2706e18115ac776637bd86595bd36306e04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PARTITION BY&lt;/code&gt; clause is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;PARTITION BY&lt;/code&gt; 句はPostgreSQLの拡張です。</target>
        </trans-unit>
        <trans-unit id="393ad05ac9e0d59452b4a8f8039dc3a261130b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PARTITION OF&lt;/code&gt; clause is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;PARTITION OF&lt;/code&gt; 句はPostgreSQLの拡張です。</target>
        </trans-unit>
        <trans-unit id="0614d6d969b75211746fef3527fa36c2e0bf9b1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PGDATA&lt;/code&gt; directory contains several subdirectories and control files, as shown in &lt;a href=&quot;storage-file-layout#PGDATA-CONTENTS-TABLE&quot;&gt;Table 68.1&lt;/a&gt;. In addition to these required items, the cluster configuration files &lt;code&gt;postgresql.conf&lt;/code&gt;, &lt;code&gt;pg_hba.conf&lt;/code&gt;, and &lt;code&gt;pg_ident.conf&lt;/code&gt; are traditionally stored in &lt;code&gt;PGDATA&lt;/code&gt;, although it is possible to place them elsewhere.</source>
          <target state="translated">&lt;code&gt;PGDATA&lt;/code&gt; に示すようにディレクトリには、いくつかのサブディレクトリと制御ファイルが含まれています&lt;a href=&quot;storage-file-layout#PGDATA-CONTENTS-TABLE&quot;&gt;。表68.1&lt;/a&gt;。これらの必須項目に加えて、クラスター構成ファイル &lt;code&gt;postgresql.conf&lt;/code&gt; 、 &lt;code&gt;pg_hba.conf&lt;/code&gt; 、および &lt;code&gt;pg_ident.conf&lt;/code&gt; は従来、 &lt;code&gt;PGDATA&lt;/code&gt; に格納されていますが、他の場所に配置することも可能です。</target>
        </trans-unit>
        <trans-unit id="c212a5664d9166a52f4030be9966cfbd740b8e20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PGTZ&lt;/code&gt; environment variable is used by libpq clients to send a &lt;code&gt;SET TIME ZONE&lt;/code&gt; command to the server upon connection.</source>
          <target state="translated">&lt;code&gt;PGTZ&lt;/code&gt; の環境変数を送信するためのlibpqクライアントによって使用された &lt;code&gt;SET TIME ZONE&lt;/code&gt; の接続時にサーバーにコマンドを。</target>
        </trans-unit>
        <trans-unit id="34a48a54277ef76ad5806acc41cf35d3fff139d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint specifies that a column or columns of a table can contain only unique (non-duplicate), nonnull values. Only one primary key can be specified for a table, whether as a column constraint or a table constraint.</source>
          <target state="translated">&lt;code&gt;PRIMARY KEY&lt;/code&gt; のテーブルの列または列が（非重複）のみのユニークな、非NULL値を含めることができないという制約が指定します。列制約またはテーブル制約として、テーブルに指定できる主キーは1つだけです。</target>
        </trans-unit>
        <trans-unit id="46186111e10cd3fae630f6ffd1000b220d009aad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Planning time&lt;/code&gt; shown by &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; is the time it took to generate the query plan from the parsed query and optimize it. It does not include parsing or rewriting.</source>
          <target state="translated">&lt;code&gt;Planning time&lt;/code&gt; によって示される &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; それが解析されたクエリからクエリプランを生成し、それを最適化するのにかかった時間です。解析や書き換えは含まれません。</target>
        </trans-unit>
        <trans-unit id="0d7e8e781faa2b1b8c5b786d22498b3437e1d217" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REASSIGN OWNED&lt;/code&gt; command does not affect any privileges granted to the &lt;code&gt;old_roles&lt;/code&gt; on objects that are not owned by them. Likewise, it does not affect default privileges created with &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt;. Use &lt;code&gt;DROP OWNED&lt;/code&gt; to revoke such privileges.</source>
          <target state="translated">&lt;code&gt;REASSIGN OWNED&lt;/code&gt; コマンドは、に付与された権限には影響しません &lt;code&gt;old_roles&lt;/code&gt; それらによって所有されていないオブジェクト上を。同様に、 &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; で作成されたデフォルトの権限には影響しません。そのような特権を取り消すには、 &lt;code&gt;DROP OWNED&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="ab1105a54870883f7696c90d586d2ea0eba9685c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REASSIGN OWNED&lt;/code&gt; command is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;REASSIGN OWNED&lt;/code&gt; コマンドは、PostgreSQLの拡張です。</target>
        </trans-unit>
        <trans-unit id="f532c71d7a7a8a330117caf1f3776cf4f07cbb57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REFERENCING&lt;/code&gt; option enables collection of &lt;em&gt;transition relations&lt;/em&gt;, which are row sets that include all of the rows inserted, deleted, or modified by the current SQL statement. This feature lets the trigger see a global view of what the statement did, not just one row at a time. This option is only allowed for an &lt;code&gt;AFTER&lt;/code&gt; trigger that is not a constraint trigger; also, if the trigger is an &lt;code&gt;UPDATE&lt;/code&gt; trigger, it must not specify a &lt;code&gt;column_name&lt;/code&gt; list. &lt;code&gt;OLD TABLE&lt;/code&gt; may only be specified once, and only for a trigger that can fire on &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt;; it creates a transition relation containing the &lt;em&gt;before-images&lt;/em&gt; of all rows updated or deleted by the statement. Similarly, &lt;code&gt;NEW TABLE&lt;/code&gt; may only be specified once, and only for a trigger that can fire on &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt;; it creates a transition relation containing the &lt;em&gt;after-images&lt;/em&gt; of all rows updated or inserted by the statement.</source>
          <target state="translated">&lt;code&gt;REFERENCING&lt;/code&gt; のオプションは、回収可能&lt;em&gt;遷移関係&lt;/em&gt;、挿入、削除、または現在のSQL文によって変更された行の全てを含む行セットです。この機能により、トリガーは、一度に1行だけでなく、ステートメントが行ったことの全体的なビューを確認できます。このオプションは、制約トリガーではない &lt;code&gt;AFTER&lt;/code&gt; トリガーに対してのみ許可されます。また、トリガーが &lt;code&gt;UPDATE&lt;/code&gt; トリガーの場合は、 &lt;code&gt;column_name&lt;/code&gt; リストを指定してはなりません。 &lt;code&gt;OLD TABLE&lt;/code&gt; は1回だけ指定でき、 &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; で起動できるトリガーに対してのみ指定できます。変更&lt;em&gt;前イメージ&lt;/em&gt;を含む遷移関係を作成し&lt;em&gt;ます&lt;/em&gt;ステートメントによって更新または削除されたすべての行の。同様に、 &lt;code&gt;NEW TABLE&lt;/code&gt; は1回だけ指定でき、 &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;INSERT&lt;/code&gt; で起動できるトリガーに対してのみ指定できます。ステートメントによって更新または挿入されたすべての行の変更&lt;em&gt;後イメージ&lt;/em&gt;を含む遷移関係を作成します。</target>
        </trans-unit>
        <trans-unit id="128c0fd3af0b907c660e6b2d23e97c6334b157b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RENAME&lt;/code&gt; form changes the name of the index. If the index is associated with a table constraint (either &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, or &lt;code&gt;EXCLUDE&lt;/code&gt;), the constraint is renamed as well. There is no effect on the stored data.</source>
          <target state="translated">&lt;code&gt;RENAME&lt;/code&gt; のフォームは、インデックスの名前を変更します。インデックスがテーブル制約（ &lt;code&gt;UNIQUE&lt;/code&gt; 、 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 、または &lt;code&gt;EXCLUDE&lt;/code&gt; ）に関連付けられている場合、制約も同様に名前変更されます。保存されているデータには影響しません。</target>
        </trans-unit>
        <trans-unit id="d3e19c1e234f0ed8c9c4710a3c3098a7ed897e2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RENAME&lt;/code&gt; forms change the name of a foreign table or the name of an individual column in a foreign table.</source>
          <target state="translated">&lt;code&gt;RENAME&lt;/code&gt; のフォームは、外部テーブルの名前または外部表内の個々の列の名前を変更します。</target>
        </trans-unit>
        <trans-unit id="f1e7a50326fd3c3ba151f96454fa2cb157ff1c85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RENAME&lt;/code&gt; forms change the name of a table (or an index, sequence, view, materialized view, or foreign table), the name of an individual column in a table, or the name of a constraint of the table. When renaming a constraint that has an underlying index, the index is renamed as well. There is no effect on the stored data.</source>
          <target state="translated">&lt;code&gt;RENAME&lt;/code&gt; の形態は、テーブルの名前（またはインデックス、シーケンス、ビュー、マテリアライズド・ビュー、または外部テーブル）、テーブル内の個々の列、またはテーブルの制約の名前の名前を変更します。基になるインデックスを持つ制約の名前を変更すると、インデックスの名前も変更されます。保存されているデータには影響しません。</target>
        </trans-unit>
        <trans-unit id="a9e363fe4d9083d2f665b243a400d5bf63d40f84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RETURNING&lt;/code&gt; clause is also very useful with &lt;code&gt;INSERT ... SELECT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RETURNING&lt;/code&gt; 句はまた、非常に便利です &lt;code&gt;INSERT ... SELECT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="622683abc0fee3cca0a4ff24efb6bac3bc69274b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REVOKE&lt;/code&gt; command revokes previously granted privileges from one or more roles. The key word &lt;code&gt;PUBLIC&lt;/code&gt; refers to the implicitly defined group of all roles.</source>
          <target state="translated">&lt;code&gt;REVOKE&lt;/code&gt; のコマンドは、以前に1つ以上のロールから権限を付与取り消します。キーワード &lt;code&gt;PUBLIC&lt;/code&gt; は、暗黙的に定義されたすべてのロールのグループを指します。</target>
        </trans-unit>
        <trans-unit id="a7eb06850162cc121e0dcb4f71d5d5cc238a6fa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ROLE&lt;/code&gt; clause lists one or more existing roles which are automatically added as members of the new role. (This in effect makes the new role a &amp;ldquo;group&amp;rdquo;.)</source>
          <target state="translated">&lt;code&gt;ROLE&lt;/code&gt; の句リスト1または自動的に新しい役割のメンバーとして追加され、より既存の役割。（これにより、新しい役割が「グループ」になります。）</target>
        </trans-unit>
        <trans-unit id="e90b140ccb8d754cc8582d110f40bb1462ca56ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ROW&lt;/code&gt; constructor syntax is usually easier to work with than the composite-literal syntax when writing composite values in SQL commands. In &lt;code&gt;ROW&lt;/code&gt;, individual field values are written the same way they would be written when not members of a composite.</source>
          <target state="translated">&lt;code&gt;ROW&lt;/code&gt; のコンストラクタの構文はSQLコマンドで複合値を書き込む際に、複合リテラル構文よりも持つ作品に通常より簡単です。では &lt;code&gt;ROW&lt;/code&gt; 、個々のフィールド値は、複合のないメンバー、彼らが書かれるのと同じ方法で書かれています。</target>
        </trans-unit>
        <trans-unit id="bc33402fa9910608d16738542893ffc3652dba40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ROW&lt;/code&gt; expression syntax can also be used to construct composite values. In most cases this is considerably simpler to use than the string-literal syntax since you don't have to worry about multiple layers of quoting. We already used this method above:</source>
          <target state="translated">&lt;code&gt;ROW&lt;/code&gt; の式構文も複合値を構築するために使用することができます。ほとんどの場合、これは文字列リテラル構文よりもはるかに簡単に使用できます。これは、引用の複数のレイヤーについて心配する必要がないためです。上記の方法はすでに使用しています。</target>
        </trans-unit>
        <trans-unit id="fec4fc51d12e7ec5b1c6011953c7d9a01518ad18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ROW&lt;/code&gt; expression syntax is discussed in more detail in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ROW&lt;/code&gt; の表現の構文はで詳しく説明されている&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;セクション4.2.13&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66771ec27e64ee38d7a73db993c4f98dda1eefb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SCROLL&lt;/code&gt; option should be specified when defining a cursor that will be used to fetch backwards. This is required by the SQL standard. However, for compatibility with earlier versions, PostgreSQL will allow backward fetches without &lt;code&gt;SCROLL&lt;/code&gt;, if the cursor's query plan is simple enough that no extra overhead is needed to support it. However, application developers are advised not to rely on using backward fetches from a cursor that has not been created with &lt;code&gt;SCROLL&lt;/code&gt;. If &lt;code&gt;NO SCROLL&lt;/code&gt; is specified, then backward fetches are disallowed in any case.</source>
          <target state="translated">&lt;code&gt;SCROLL&lt;/code&gt; の後方をフェッチするために使用されるカーソルを定義するときにオプションを指定する必要があります。これは、SQL標準で必須です。ただし、以前のバージョンとの互換性のために、PostgreSQLは、カーソルのクエリプランがそれをサポートするために追加のオーバーヘッドが必要ないほど単純である場合、 &lt;code&gt;SCROLL&lt;/code&gt; なしで後方フェッチを許可します。ただし、アプリケーション開発者は、 &lt;code&gt;SCROLL&lt;/code&gt; で作成されていないカーソルからの後方フェッチの使用に依存しないことをお勧めします。場合は &lt;code&gt;NO SCROLL&lt;/code&gt; が指定され、その後、後方フェッチは、どのような場合には禁止されています。</target>
        </trans-unit>
        <trans-unit id="7724f5cbcba172f246fa8b7c71da000b2776330f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; commands acquire a lock of this mode on the target table(s) (in addition to &lt;code&gt;ACCESS SHARE&lt;/code&gt; locks on any other tables that are referenced but not selected &lt;code&gt;FOR UPDATE/FOR SHARE&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; および &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; のコマンドは、（他にターゲットテーブル（単数または複数）にこのモードのロックを取得する &lt;code&gt;ACCESS SHARE&lt;/code&gt; 参照が、選択されていない他のテーブルのロック &lt;code&gt;FOR UPDATE/FOR SHARE&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e96e7802d4cb7db701f609eba9f870f4c8748bdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SELECT&lt;/code&gt; command acquires a lock of this mode on referenced tables. In general, any query that only &lt;em&gt;reads&lt;/em&gt; a table and does not modify it will acquire this lock mode.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; コマンドは、参照されるテーブルに対してこのモードのロックを取得します。一般に、テーブルを&lt;em&gt;読み取る&lt;/em&gt;だけで変更しないクエリは、このロックモードを取得します。</target>
        </trans-unit>
        <trans-unit id="3a31e8d24fd1e02295c813f049f933c4c7dd023e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SELECT&lt;/code&gt; list (between the key words &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;FROM&lt;/code&gt;) specifies expressions that form the output rows of the &lt;code&gt;SELECT&lt;/code&gt; statement. The expressions can (and usually do) refer to columns computed in the &lt;code&gt;FROM&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; リスト（キーワードの間には、 &lt;code&gt;SELECT&lt;/code&gt; と &lt;code&gt;FROM&lt;/code&gt; の出力行を形成指定式） &lt;code&gt;SELECT&lt;/code&gt; ステートメントを。式は、 &lt;code&gt;FROM&lt;/code&gt; 句で計算された列を参照できます（通常、参照します）。</target>
        </trans-unit>
        <trans-unit id="a1d3b2383acf67ec80d1e37ede72853554a335de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SELECT&lt;/code&gt; statement will return one tuple, even though the &lt;code&gt;nick&lt;/code&gt; column was set to &lt;code&gt;larry&lt;/code&gt; and the query was for &lt;code&gt;Larry&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; ステートメントはいても、1つのタプルを返します &lt;code&gt;nick&lt;/code&gt; 欄に設定された &lt;code&gt;larry&lt;/code&gt; とクエリがためだった &lt;code&gt;Larry&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f1ef68b6a727bfef21aefb3a5eb92e57da175a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SERIAL&lt;/code&gt; shorthand is discussed further in &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt;Section 8.1.4&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;SERIAL&lt;/code&gt; 速記はで詳しく説明され&lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt;、セクション8.1.4&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1a726476c5c9f5995fa747df038eaa20f04dca47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SESSION&lt;/code&gt; and &lt;code&gt;LOCAL&lt;/code&gt; modifiers act the same as for the regular &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; command.</source>
          <target state="translated">&lt;code&gt;SESSION&lt;/code&gt; および &lt;code&gt;LOCAL&lt;/code&gt; 修飾子は、通常の場合と同じ行動&lt;a href=&quot;sql-set&quot;&gt;のSET&lt;/a&gt;コマンド。</target>
        </trans-unit>
        <trans-unit id="9f2d0dd2017fb0dc1fe3da723f3e961e02aaf3eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET ROLE&lt;/code&gt; command always allows selecting any role that the original login role is directly or indirectly a member of. Thus, in the above example, it is not necessary to become &lt;code&gt;admin&lt;/code&gt; before becoming &lt;code&gt;wheel&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SET ROLE&lt;/code&gt; コマンドは、常に元のログイン役割は、直接的または間接的のメンバーであることをすべての役割を選択することができます。したがって、上記の例では、 &lt;code&gt;wheel&lt;/code&gt; になる前に &lt;code&gt;admin&lt;/code&gt; になる必要はありません。</target>
        </trans-unit>
        <trans-unit id="d850a29f519a30a60f848219dab3f598ebc95064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; command allows a new transaction to run with the same &lt;em&gt;snapshot&lt;/em&gt; as an existing transaction. The pre-existing transaction must have exported its snapshot with the &lt;code&gt;pg_export_snapshot&lt;/code&gt; function (see &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;Section 9.26.5&lt;/a&gt;). That function returns a snapshot identifier, which must be given to &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; to specify which snapshot is to be imported. The identifier must be written as a string literal in this command, for example &lt;code&gt;'000003A1-1'&lt;/code&gt;. &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; can only be executed at the start of a transaction, before the first query or data-modification statement (&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt;, or &lt;code&gt;COPY&lt;/code&gt;) of the transaction. Furthermore, the transaction must already be set to &lt;code&gt;SERIALIZABLE&lt;/code&gt; or &lt;code&gt;REPEATABLE READ&lt;/code&gt; isolation level (otherwise, the snapshot would be discarded immediately, since &lt;code&gt;READ COMMITTED&lt;/code&gt; mode takes a new snapshot for each command). If the importing transaction uses &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level, then the transaction that exported the snapshot must also use that isolation level. Also, a non-read-only serializable transaction cannot import a snapshot from a read-only transaction.</source>
          <target state="translated">&lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; のコマンドが同じで実行するために、新しいトランザクションができます&lt;em&gt;スナップショット&lt;/em&gt;既存のトランザクションとしてを。既存のトランザクションは、 &lt;code&gt;pg_export_snapshot&lt;/code&gt; 関数を使用してそのスナップショットをエクスポートしておく必要があります（&lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;項9.26.5を&lt;/a&gt;参照）。その関数はスナップショット識別子を返します。これは、インポートするスナップショットを指定するために &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; に指定する必要があります。このコマンドでは、識別子を文字列リテラルとして記述する必要があります（例： &lt;code&gt;'000003A1-1'&lt;/code&gt; )。 &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; は、トランザクションの開始時に、最初のクエリまたはデータ変更ステートメント（ &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; トランザクションの、 &lt;code&gt;DELETE&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;FETCH&lt;/code&gt; 、または &lt;code&gt;COPY&lt;/code&gt; ）。さらに、トランザクションはすでに &lt;code&gt;SERIALIZABLE&lt;/code&gt; または &lt;code&gt;REPEATABLE READ&lt;/code&gt; 分離レベルに設定されている必要があります（そうでない場合、 &lt;code&gt;READ COMMITTED&lt;/code&gt; モードはコマンドごとに新しいスナップショットを取るため、スナップショットはすぐに破棄されます）。インポートするトランザクションが &lt;code&gt;SERIALIZABLE&lt;/code&gt; 分離レベルを使用する場合、スナップショットをエクスポートしたトランザクションもその分離レベルを使用する必要があります。また、読み取り専用ではないシリアル化可能なトランザクションは、読み取り専用トランザクションからスナップショットをインポートできません。</target>
        </trans-unit>
        <trans-unit id="cc6c2a89c55f352db834e7ae3a14fa98c839cbdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET TRANSACTION&lt;/code&gt; command sets the characteristics of the current transaction. It has no effect on any subsequent transactions. &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; sets the default transaction characteristics for subsequent transactions of a session. These defaults can be overridden by &lt;code&gt;SET TRANSACTION&lt;/code&gt; for an individual transaction.</source>
          <target state="translated">&lt;code&gt;SET TRANSACTION&lt;/code&gt; コマンドは現在のトランザクションの特性を設定します。後続のトランザクションには影響しません。 &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; は、セッションの後続のトランザクションのデフォルトのトランザクション特性を設定します。これらのデフォルトは、個々のトランザクションの &lt;code&gt;SET TRANSACTION&lt;/code&gt; によってオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="6625f1cde96b5821cc50429e57aa65382ce3cbff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET&lt;/code&gt; clause causes the specified configuration parameter to be set to the specified value when the function is entered, and then restored to its prior value when the function exits. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;CREATE FUNCTION&lt;/code&gt; is executed as the value to be applied when the function is entered.</source>
          <target state="translated">&lt;code&gt;SET&lt;/code&gt; の句は、指定された構成パラメータが関数が入力されると、指定された値に設定され、その前の値場合、関数終了に復帰させます。 &lt;code&gt;SET FROM CURRENT&lt;/code&gt; は、関数の入力時に適用される値として、 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; の実行時に現在設定されているパラメーターの値を保存します。</target>
        </trans-unit>
        <trans-unit id="40cb501cbc3608b578aae96ed6d694a6c1181e14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET&lt;/code&gt; clause causes the specified configuration parameter to be set to the specified value when the procedure is entered, and then restored to its prior value when the procedure exits. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; is executed as the value to be applied when the procedure is entered.</source>
          <target state="translated">&lt;code&gt;SET&lt;/code&gt; の句は、指定された構成パラメータがプロシージャが入力されると、指定された値に設定され、その前の値場合の処理手順が終了に復帰させます。 &lt;code&gt;SET FROM CURRENT&lt;/code&gt; は、 &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; が実行されたときに現在のパラメーターの値を、プロシージャーの入力時に適用される値として保存します。</target>
        </trans-unit>
        <trans-unit id="2d4ac1bc1f3cd753f1587a3604ac6e4583d02fa2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET&lt;/code&gt; command changes run-time configuration parameters. Many of the run-time parameters listed in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; can be changed on-the-fly with &lt;code&gt;SET&lt;/code&gt;. (But some require superuser privileges to change, and others cannot be changed after server or session start.) &lt;code&gt;SET&lt;/code&gt; only affects the value used by the current session.</source>
          <target state="translated">&lt;code&gt;SET&lt;/code&gt; のコマンドは実行時設定パラメータを変更します。&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章に&lt;/a&gt;リストされているランタイムパラメータの多くは、 &lt;code&gt;SET&lt;/code&gt; を使用してオンザフライで変更できます。（ただし、変更するにはスーパーユーザー権限が必要なものもあれば、サーバーまたはセッションの開始後に変更できないものもあります。） &lt;code&gt;SET&lt;/code&gt; は現在のセッションで使用される値にのみ影響します。</target>
        </trans-unit>
        <trans-unit id="020c7ebd698e864a60548a6b3a70eb85bc868cc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SETOF&lt;/code&gt; modifier indicates that the function will return a set of items, rather than a single item.</source>
          <target state="translated">&lt;code&gt;SETOF&lt;/code&gt; の改質剤は、機能項目の集合ではなく、単一のアイテムを返すことを示しています。</target>
        </trans-unit>
        <trans-unit id="b5fb6cd6b15fe6f84ab20f8db329dfba5800e08d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SHOW&lt;/code&gt; command is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;SHOW&lt;/code&gt; のコマンドは、PostgreSQLの拡張です。</target>
        </trans-unit>
        <trans-unit id="3bda179acb0a4ef77b97eb421bed8ee9a254cd87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIGHUP&lt;/code&gt; signal will reload the server configuration files. It is also possible to send &lt;code&gt;SIGHUP&lt;/code&gt; to an individual server process, but that is usually not sensible.</source>
          <target state="translated">&lt;code&gt;SIGHUP&lt;/code&gt; の信号は、サーバの設定ファイルをリロードします。また、 &lt;code&gt;SIGHUP&lt;/code&gt; を個々のサーバープロセスに送信することもできますが、通常は賢明ではありません。</target>
        </trans-unit>
        <trans-unit id="dbdafa6a0951a5a4f8ae3d651aa4483d02aaf656" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIMILAR TO&lt;/code&gt; operator returns true or false depending on whether its pattern matches the given string. It is similar to &lt;code&gt;LIKE&lt;/code&gt;, except that it interprets the pattern using the SQL standard's definition of a regular expression. SQL regular expressions are a curious cross between &lt;code&gt;LIKE&lt;/code&gt; notation and common regular expression notation.</source>
          <target state="translated">&lt;code&gt;SIMILAR TO&lt;/code&gt; のそのパターンが与えられた文字列にマッチするかどうかに応じて、真または偽のオペレータに戻ります。 &lt;code&gt;LIKE&lt;/code&gt; に似ていますが、SQL標準の正規表現の定義を使用してパターンを解釈する点が異なります。SQL正規表現は、 &lt;code&gt;LIKE&lt;/code&gt; 表記と一般的な正規表現表記の奇妙なクロスです。</target>
        </trans-unit>
        <trans-unit id="0015ba66976ccc10a8545b59f15f445b21a50742" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SQL_ASCII&lt;/code&gt; setting behaves considerably differently from the other settings. When the server character set is &lt;code&gt;SQL_ASCII&lt;/code&gt;, the server interprets byte values 0-127 according to the ASCII standard, while byte values 128-255 are taken as uninterpreted characters. No encoding conversion will be done when the setting is &lt;code&gt;SQL_ASCII&lt;/code&gt;. Thus, this setting is not so much a declaration that a specific encoding is in use, as a declaration of ignorance about the encoding. In most cases, if you are working with any non-ASCII data, it is unwise to use the &lt;code&gt;SQL_ASCII&lt;/code&gt; setting because PostgreSQL will be unable to help you by converting or validating non-ASCII characters.</source>
          <target state="translated">&lt;code&gt;SQL_ASCII&lt;/code&gt; 他の設定とはかなり異なる振る舞いを設定します。サーバーの文字セットが &lt;code&gt;SQL_ASCII&lt;/code&gt; の場合、サーバーはバイト値0〜127をASCII標準に従って解釈し、バイト値128〜255は未解釈の文字として解釈されます。設定が &lt;code&gt;SQL_ASCII&lt;/code&gt; の場合、エンコード変換は行われません。したがって、この設定は、特定のエンコーディングが使用されているという宣言ではなく、エンコーディングに関する無知の宣言です。ほとんどの場合、ASCII以外のデータを使用している場合は、 &lt;code&gt;SQL_ASCII&lt;/code&gt; 設定を使用することは賢明ではありません。PostgreSQLは、ASCII以外の文字を変換または検証することによって支援できないからです。</target>
        </trans-unit>
        <trans-unit id="7d7d5e46d6c54b21b25eeef48c6ca4551b1f61a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SYSID&lt;/code&gt; clause is ignored, but is accepted for backwards compatibility.</source>
          <target state="translated">&lt;code&gt;SYSID&lt;/code&gt; の句は無視されますが、後方互換性のために受け入れられています。</target>
        </trans-unit>
        <trans-unit id="ba9a4c3ee7dd77407d80711565ddf84296946777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TABLESAMPLE&lt;/code&gt; clause is currently accepted only on regular tables and materialized views. According to the SQL standard it should be possible to apply it to any &lt;code&gt;FROM&lt;/code&gt; item.</source>
          <target state="translated">&lt;code&gt;TABLESAMPLE&lt;/code&gt; の句は、現在だけで通常のテーブルの上に受け入れられ、マテリアライズド・ビューをされています。SQL標準によると、それを任意の &lt;code&gt;FROM&lt;/code&gt; アイテムに適用できるはずです。</target>
        </trans-unit>
        <trans-unit id="3600170fb18cff60f53eb4ba51d9dce974f3e1f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRUSTED&lt;/code&gt; option and the support function name(s) are ignored if the server has an entry for the specified language name in &lt;code&gt;pg_pltemplate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TRUSTED&lt;/code&gt; サーバーで指定した言語名のエントリがある場合はオプションとサポート関数名は無視され &lt;code&gt;pg_pltemplate&lt;/code&gt; のを。</target>
        </trans-unit>
        <trans-unit id="53faeaca5564f551951f6575a18b776e07cb73f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNION&lt;/code&gt; clause has this general form:</source>
          <target state="translated">&lt;code&gt;UNION&lt;/code&gt; の句は、この一般的な形式があります：</target>
        </trans-unit>
        <trans-unit id="d37a98042f90333d3d9b66690fc343fe11354a51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNION&lt;/code&gt; operator computes the set union of the rows returned by the involved &lt;code&gt;SELECT&lt;/code&gt; statements. A row is in the set union of two result sets if it appears in at least one of the result sets. The two &lt;code&gt;SELECT&lt;/code&gt; statements that represent the direct operands of the &lt;code&gt;UNION&lt;/code&gt; must produce the same number of columns, and corresponding columns must be of compatible data types.</source>
          <target state="translated">&lt;code&gt;UNION&lt;/code&gt; のオペレータが関与によって返される行の和集合を計算 &lt;code&gt;SELECT&lt;/code&gt; 文を。行が結果セットの少なくとも1つに表示される場合、その行は2つの結果セットの和集合に含まれます。 &lt;code&gt;UNION&lt;/code&gt; の直接オペランドを表す2つの &lt;code&gt;SELECT&lt;/code&gt; ステートメントは、同じ数の列を生成する必要があり、対応する列は互換性のあるデータ型である必要があります。</target>
        </trans-unit>
        <trans-unit id="df2f42f8ff2203573828998bc521aa46717845dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNIQUE&lt;/code&gt; constraint specifies that a group of one or more columns of a table can contain only unique values. The behavior of the unique table constraint is the same as that for column constraints, with the additional capability to span multiple columns.</source>
          <target state="translated">&lt;code&gt;UNIQUE&lt;/code&gt; の制約の指定は、テーブルの1つまたは複数の列のグループが一意な値のみを含むことができること。一意のテーブル制約の動作は、列制約の場合と同じですが、複数の列にまたがる追加機能があります。</target>
        </trans-unit>
        <trans-unit id="440900ea1c49963507f35e80410def61bdfb2e10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USER&lt;/code&gt; clause is an obsolete spelling of the &lt;code&gt;ROLE&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;USER&lt;/code&gt; の句は、時代遅れの綴りである &lt;code&gt;ROLE&lt;/code&gt; の句。</target>
        </trans-unit>
        <trans-unit id="df5573cea50ffa4699b0e7de14e2efa40e40f614" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USING&lt;/code&gt; clause is a shorthand that allows you to take advantage of the specific situation where both sides of the join use the same name for the joining column(s). It takes a comma-separated list of the shared column names and forms a join condition that includes an equality comparison for each one. For example, joining &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; with &lt;code&gt;USING (a, b)&lt;/code&gt; produces the join condition &lt;code&gt;ON T1.a = T2.a AND T1.b = T2.b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;USING&lt;/code&gt; 句を使用すると、の双方が参加する列（複数可）に同じ名前を使用して参加し、特定の状況を利用することを可能にする簡略化したものです。これは、共有列名のコンマ区切りリストを受け取り、それぞれの等価比較を含む結合条件を形成します。たとえば、 &lt;code&gt;T1&lt;/code&gt; と &lt;code&gt;T2&lt;/code&gt; を &lt;code&gt;USING (a, b)&lt;/code&gt; で結合すると、結合条件 &lt;code&gt;ON T1.a = T2.a AND T1.b = T2.b&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="2dd69a2ff12f6e6b4d3bf9a9a6b47532dc2d1194" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USING&lt;/code&gt; expression for the policy. See &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; for details.</source>
          <target state="translated">ポリシーの &lt;code&gt;USING&lt;/code&gt; 式。詳細については、「&lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="0bbe3012f251c3e27b73557dcb624091be7838ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USING&lt;/code&gt; option of &lt;code&gt;SET DATA TYPE&lt;/code&gt; can actually specify any expression involving the old values of the row; that is, it can refer to other columns as well as the one being converted. This allows very general conversions to be done with the &lt;code&gt;SET DATA TYPE&lt;/code&gt; syntax. Because of this flexibility, the &lt;code&gt;USING&lt;/code&gt; expression is not applied to the column's default value (if any); the result might not be a constant expression as required for a default. This means that when there is no implicit or assignment cast from old to new type, &lt;code&gt;SET DATA TYPE&lt;/code&gt; might fail to convert the default even though a &lt;code&gt;USING&lt;/code&gt; clause is supplied. In such cases, drop the default with &lt;code&gt;DROP DEFAULT&lt;/code&gt;, perform the &lt;code&gt;ALTER TYPE&lt;/code&gt;, and then use &lt;code&gt;SET DEFAULT&lt;/code&gt; to add a suitable new default. Similar considerations apply to indexes and constraints involving the column.</source>
          <target state="translated">&lt;code&gt;SET DATA TYPE&lt;/code&gt; の &lt;code&gt;USING&lt;/code&gt; オプションは、実際には行の古い値を含む任意の式を指定できます。つまり、変換される列だけでなく他の列も参照できます。これにより、 &lt;code&gt;SET DATA TYPE&lt;/code&gt; 構文で非常に一般的な変換を行うことができます。この柔軟性のため、 &lt;code&gt;USING&lt;/code&gt; 式は列のデフォルト値（存在する場合）には適用されません。結果は、デフォルトに必要な定数式ではない可能性があります。つまり、古い型から新しい型への暗黙的または代入キャストがない場合、 &lt;code&gt;USING&lt;/code&gt; 句が指定されていても、 &lt;code&gt;SET DATA TYPE&lt;/code&gt; はデフォルトの変換に失敗する可能性があります。このような場合は、 &lt;code&gt;DROP DEFAULT&lt;/code&gt; を使用してデフォルトを削除してください。、 &lt;code&gt;ALTER TYPE&lt;/code&gt; を実行し、 &lt;code&gt;SET DEFAULT&lt;/code&gt; を使用して適切な新しいデフォルトを追加します。列に関連するインデックスと制約にも同様の考慮事項が適用されます。</target>
        </trans-unit>
        <trans-unit id="3ac72d27e393aaa10fa09ec0c99e41bf31ba8f68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VALID UNTIL&lt;/code&gt; clause defines an expiration time for a password only, not for the role &lt;em&gt;per se&lt;/em&gt;. In particular, the expiration time is not enforced when logging in using a non-password-based authentication method.</source>
          <target state="translated">&lt;code&gt;VALID UNTIL&lt;/code&gt; 句はのみではなく、役割のパスワードの有効期限を定義し&lt;em&gt;、それ自体が&lt;/em&gt;。特に、非パスワードベースの認証方法を使用してログインする場合、有効期限は強制されません。</target>
        </trans-unit>
        <trans-unit id="4254f4cbb5558ecbcabbf94985890347bc617c04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VALID UNTIL&lt;/code&gt; clause sets a date and time after which the role's password is no longer valid. If this clause is omitted the password will be valid for all time.</source>
          <target state="translated">&lt;code&gt;VALID UNTIL&lt;/code&gt; 句は、役割のパスワードが有効でなくなった後、日付と時刻を設定します。この句を省略すると、パスワードは常に有効になります。</target>
        </trans-unit>
        <trans-unit id="3c44efcbdf803edc09491650dc604f24489fb4e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH CHECK&lt;/code&gt; expression for the policy. See &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; for details.</source>
          <target state="translated">ポリシーの &lt;code&gt;WITH CHECK&lt;/code&gt; 式。詳細については、「&lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f909d6d352b763da5996539ec5a35b3e1508bd1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause allows you to specify one or more subqueries that can be referenced by name in the &lt;code&gt;DELETE&lt;/code&gt; query. See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; and &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; の句は、あなたが名前で参照することができる1つのまたは複数のサブクエリを指定することができます &lt;code&gt;DELETE&lt;/code&gt; クエリを。詳細については、&lt;a href=&quot;queries-with&quot;&gt;セクション7.8&lt;/a&gt;および&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c86cbf90270e40ca5022ce8fed26f2e4b7126438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause allows you to specify one or more subqueries that can be referenced by name in the &lt;code&gt;INSERT&lt;/code&gt; query. See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; and &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; の句は、あなたが名前で参照することができる1つのまたは複数のサブクエリを指定することを可能にする &lt;code&gt;INSERT&lt;/code&gt; クエリを。詳細については、&lt;a href=&quot;queries-with&quot;&gt;セクション7.8&lt;/a&gt;および&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6b5376c90f6e32eea66f4e1b2c109c7f56e3b3b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause allows you to specify one or more subqueries that can be referenced by name in the &lt;code&gt;UPDATE&lt;/code&gt; query. See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; and &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; の句は、あなたが名前で参照することができる1つのまたは複数のサブクエリを指定することを可能にする &lt;code&gt;UPDATE&lt;/code&gt; クエリを。詳細については、&lt;a href=&quot;queries-with&quot;&gt;セクション7.8&lt;/a&gt;および&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d36279616fce39b7667637feae639cf048d9729b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause allows you to specify one or more subqueries that can be referenced by name in the primary query. The subqueries effectively act as temporary tables or views for the duration of the primary query. Each subquery can be a &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;TABLE&lt;/code&gt;, &lt;code&gt;VALUES&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; statement. When writing a data-modifying statement (&lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt;) in &lt;code&gt;WITH&lt;/code&gt;, it is usual to include a &lt;code&gt;RETURNING&lt;/code&gt; clause. It is the output of &lt;code&gt;RETURNING&lt;/code&gt;, &lt;em&gt;not&lt;/em&gt; the underlying table that the statement modifies, that forms the temporary table that is read by the primary query. If &lt;code&gt;RETURNING&lt;/code&gt; is omitted, the statement is still executed, but it produces no output so it cannot be referenced as a table by the primary query.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; の句は、プライマリクエリで名前で参照することができる1つ以上のサブクエリを指定することができます。サブクエリは、プライマリクエリの期間中、一時的なテーブルまたはビューとして効果的に機能します。各サブクエリは、 &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;TABLE&lt;/code&gt; 、 &lt;code&gt;VALUES&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; ステートメントにすることができます。 &lt;code&gt;WITH&lt;/code&gt; でデータ変更ステートメント（ &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; ）を記述する場合、通常は &lt;code&gt;RETURNING&lt;/code&gt; 句を含めます。それはの出力である &lt;code&gt;RETURNING&lt;/code&gt; 、&lt;em&gt;ありません&lt;/em&gt;&lt;em&gt;&lt;/em&gt;ステートメントが変更する基になるテーブル。プライマリクエリによって読み取られる一時テーブルを形成します。場合 &lt;code&gt;RETURNING&lt;/code&gt; が省略され、文はまだ実行されているが、それは主クエリによってテーブルとして参照することはできませんので、それが出力を生成しません。</target>
        </trans-unit>
        <trans-unit id="dd82170932e06b9823fd64af1127b85442398023" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause can specify &lt;em&gt;storage parameters&lt;/em&gt; for tables, and for indexes associated with a &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, or &lt;code&gt;EXCLUDE&lt;/code&gt; constraint. Storage parameters for indexes are documented in &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt;. The storage parameters currently available for tables are listed below. For many of these parameters, as shown, there is an additional parameter with the same name prefixed with &lt;code&gt;toast.&lt;/code&gt;, which controls the behavior of the table's secondary TOAST table, if any (see &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; for more information about TOAST). If a table parameter value is set and the equivalent &lt;code&gt;toast.&lt;/code&gt; parameter is not, the TOAST table will use the table's parameter value. Specifying these parameters for partitioned tables is not supported, but you may specify them for individual leaf partitions.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 句を指定することができ&lt;em&gt;、記憶パラメータ&lt;/em&gt;テーブルの、および関連付けられたインデックスの &lt;code&gt;UNIQUE&lt;/code&gt; 、 &lt;code&gt;PRIMARY KEY&lt;/code&gt; を、または &lt;code&gt;EXCLUDE&lt;/code&gt; 制約。インデックスの格納パラメータは&lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEXに&lt;/a&gt;記載されています。現在テーブルで使用できるストレージパラメータを以下に示します。これらのパラメータの多くには、示されているように、同じ名前の &lt;code&gt;toast.&lt;/code&gt; 前に付いた追加のパラメータがあります。テーブルのセカンダリTOASTテーブルがある場合は、その動作を制御します（TOASTの詳細については、&lt;a href=&quot;storage-toast&quot;&gt;セクション68.2&lt;/a&gt;を参照してください）。テーブルパラメータ値が設定されており、同等の &lt;code&gt;toast.&lt;/code&gt; パラメータがそうでない場合、TOASTテーブルはテーブルのパラメータ値を使用します。パーティション分割テーブルにこれらのパラメーターを指定することはサポートされていませんが、個々のリーフパーティションに指定できます。</target>
        </trans-unit>
        <trans-unit id="59e61d24618bca5f4d5d76d9ae780c2dce93b6f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause is a PostgreSQL extension; storage parameters are not in the standard.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 句はPostgreSQLの拡張です。ストレージパラメータは標準にはありません。</target>
        </trans-unit>
        <trans-unit id="e9bfddf2848aa0b39782b5bc4bcc89ef2f85698a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\i&lt;/code&gt; command reads in commands from the specified file. &lt;code&gt;psql&lt;/code&gt;'s &lt;code&gt;-s&lt;/code&gt; option puts you in single step mode which pauses before sending each statement to the server. The commands used in this section are in the file &lt;code&gt;basics.sql&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\i&lt;/code&gt; コマンドは、指定したファイルからコマンドを読み込み。 &lt;code&gt;psql&lt;/code&gt; の &lt;code&gt;-s&lt;/code&gt; オプションを使用すると、各ステートメントをサーバーに送信する前に一時停止するシングルステップモードになります。このセクションで使用されるコマンドは、ファイル &lt;code&gt;basics.sql&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="d745a90b32000102fbaf10faab8dc20a84ca8bde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\if&lt;/code&gt; and &lt;code&gt;\elif&lt;/code&gt; commands read their argument(s) and evaluate them as a boolean expression. If the expression yields &lt;code&gt;true&lt;/code&gt; then processing continues normally; otherwise, lines are skipped until a matching &lt;code&gt;\elif&lt;/code&gt;, &lt;code&gt;\else&lt;/code&gt;, or &lt;code&gt;\endif&lt;/code&gt; is reached. Once an &lt;code&gt;\if&lt;/code&gt; or &lt;code&gt;\elif&lt;/code&gt; test has succeeded, the arguments of later &lt;code&gt;\elif&lt;/code&gt; commands in the same block are not evaluated but are treated as false. Lines following an &lt;code&gt;\else&lt;/code&gt; are processed only if no earlier matching &lt;code&gt;\if&lt;/code&gt; or &lt;code&gt;\elif&lt;/code&gt; succeeded.</source>
          <target state="translated">&lt;code&gt;\if&lt;/code&gt; と &lt;code&gt;\elif&lt;/code&gt; コマンドは引数（複数可）を読んで、ブール式としてそれらを評価します。式の結果が &lt;code&gt;true&lt;/code&gt; の場合、処理は通常どおり続行されます。それ以外の場合、一致する &lt;code&gt;\elif&lt;/code&gt; 、 &lt;code&gt;\else&lt;/code&gt; 、または &lt;code&gt;\endif&lt;/code&gt; に達するまで行はスキップされます。一度 &lt;code&gt;\if&lt;/code&gt; または &lt;code&gt;\elif&lt;/code&gt; テストが成功した、後の引数 &lt;code&gt;\elif&lt;/code&gt; 同じブロック内のコマンドが評価されるのではなく、偽として扱われます。 &lt;code&gt;\else&lt;/code&gt; 続く行は、以前に一致した &lt;code&gt;\if&lt;/code&gt; または &lt;code&gt;\elif&lt;/code&gt; 成功しなかった場合にのみ処理されます。</target>
        </trans-unit>
        <trans-unit id="ea3a007939b7e11bbba46ea6419ffc5cadf17bf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\ir&lt;/code&gt; command is similar to &lt;code&gt;\i&lt;/code&gt;, but resolves relative file names differently. When executing in interactive mode, the two commands behave identically. However, when invoked from a script, &lt;code&gt;\ir&lt;/code&gt; interprets file names relative to the directory in which the script is located, rather than the current working directory.</source>
          <target state="translated">&lt;code&gt;\ir&lt;/code&gt; コマンドは次のようにある &lt;code&gt;\i&lt;/code&gt; 、しかし異なった相対ファイル名を解決します。対話モードで実行する場合、2つのコマンドの動作は同じです。ただし、スクリプトから呼び出された場合、 &lt;code&gt;\ir&lt;/code&gt; は、現在の作業ディレクトリではなく、スクリプトが配置されているディレクトリに関連するファイル名を解釈します。</target>
        </trans-unit>
        <trans-unit id="169f5705e6b515a085e5b6da75e17e9f4dc2b9ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;age&lt;/code&gt; column measures the number of transactions from the cutoff XID to the current transaction's XID.</source>
          <target state="translated">&lt;code&gt;age&lt;/code&gt; 欄には、現在のトランザクションのXIDにカットオフXIDからのトランザクション数を測定します。</target>
        </trans-unit>
        <trans-unit id="525d0fc7bca054a06817564f9e4e716d7d8750a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alignment&lt;/code&gt; parameter specifies the storage alignment required for the data type. The allowed values equate to alignment on 1, 2, 4, or 8 byte boundaries. Note that variable-length types must have an alignment of at least 4, since they necessarily contain an &lt;code&gt;int4&lt;/code&gt; as their first component.</source>
          <target state="translated">&lt;code&gt;alignment&lt;/code&gt; パラメータは、データ・タイプに必要なストレージの配置を指定します。許可される値は、1、2、4、または8バイト境界での位置合わせに相当します。可変長型は、最初のコンポーネントとして &lt;code&gt;int4&lt;/code&gt; を必ず含むため、少なくとも4つの境界整列が必要であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="66ec02f3867429174e02872bcd9ba803a6ca7a3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amcheck&lt;/code&gt; module provides functions that allow you to verify the logical consistency of the structure of relations. If the structure appears to be valid, no error is raised.</source>
          <target state="translated">&lt;code&gt;amcheck&lt;/code&gt; のモジュールを使用すると、関係の構造の論理的な整合性を検証できるようにする機能を提供します。構造が有効であるように見えても、エラーは発生しません。</target>
        </trans-unit>
        <trans-unit id="04aff6c7be2111c7103649cab8f33b7af9c81d97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amcostestimate&lt;/code&gt; function is given information describing a possible index scan, including lists of WHERE and ORDER BY clauses that have been determined to be usable with the index. It must return estimates of the cost of accessing the index and the selectivity of the WHERE clauses (that is, the fraction of parent-table rows that will be retrieved during the index scan). For simple cases, nearly all the work of the cost estimator can be done by calling standard routines in the optimizer; the point of having an &lt;code&gt;amcostestimate&lt;/code&gt; function is to allow index access methods to provide index-type-specific knowledge, in case it is possible to improve on the standard estimates.</source>
          <target state="translated">&lt;code&gt;amcostestimate&lt;/code&gt; 関数は、インデックスで使用可能であると判定されたORDER BY句のリストを含む可能索引スキャンを記述する情報が、与えられています。インデックスにアクセスするコストの推定値とWHERE句の選択性（つまり、インデックススキャン中に取得される親テーブルの行の割合）を返す必要があります。単純なケースでは、コスト見積もりの​​ほぼすべての作業は、オプティマイザの標準ルーチンを呼び出すことで実行できます。 &lt;code&gt;amcostestimate&lt;/code&gt; 関数を持つことのポイントは、標準の見積もりを改善できる場合に備えて、インデックスアクセスメソッドがインデックスタイプ固有の知識を提供できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="6898a2ba9037019e5df24b6e547743d4cc59ddab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amgetbitmap&lt;/code&gt; function need only be provided if the access method supports &amp;ldquo;bitmap&amp;rdquo; index scans. If it doesn't, the &lt;code&gt;amgetbitmap&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct must be set to NULL.</source>
          <target state="translated">&lt;code&gt;amgetbitmap&lt;/code&gt; の機能の必要性は、場合にのみアクセス方法のサポート「のビットマップ」インデックススキャンを提供すること。そうでない場合は、 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 構造体の &lt;code&gt;amgetbitmap&lt;/code&gt; フィールドをNULLに設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="388cb503bc9fecd1c56c284bf2fd7e41a507c9b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amgettuple&lt;/code&gt; function has a &lt;code&gt;direction&lt;/code&gt; argument, which can be either &lt;code&gt;ForwardScanDirection&lt;/code&gt; (the normal case) or &lt;code&gt;BackwardScanDirection&lt;/code&gt;. If the first call after &lt;code&gt;amrescan&lt;/code&gt; specifies &lt;code&gt;BackwardScanDirection&lt;/code&gt;, then the set of matching index entries is to be scanned back-to-front rather than in the normal front-to-back direction, so &lt;code&gt;amgettuple&lt;/code&gt; must return the last matching tuple in the index, rather than the first one as it normally would. (This will only occur for access methods that set &lt;code&gt;amcanorder&lt;/code&gt; to true.) After the first call, &lt;code&gt;amgettuple&lt;/code&gt; must be prepared to advance the scan in either direction from the most recently returned entry. (But if &lt;code&gt;amcanbackward&lt;/code&gt; is false, all subsequent calls will have the same direction as the first one.)</source>
          <target state="translated">&lt;code&gt;amgettuple&lt;/code&gt; の機能は有している &lt;code&gt;direction&lt;/code&gt; のいずれかであることができる引数、 &lt;code&gt;ForwardScanDirection&lt;/code&gt; （通常の場合）または &lt;code&gt;BackwardScanDirection&lt;/code&gt; のを。 &lt;code&gt;amrescan&lt;/code&gt; の後の最初の呼び出しが &lt;code&gt;BackwardScanDirection&lt;/code&gt; を指定している場合、一致するインデックスエントリのセットは、通常の前から後ろの方向ではなく、後ろから前にスキャンされるため、 &lt;code&gt;amgettuple&lt;/code&gt; は、インデックスの最後に一致するタプルを返す必要があります。通常のように最初のものよりも。 （これは、 &lt;code&gt;amcanorder&lt;/code&gt; をtrueに設定するアクセスメソッドでのみ発生します。）最初の呼び出しの後、 &lt;code&gt;amgettuple&lt;/code&gt; 最後に返されたエントリからどちらかの方向にスキャンを進める準備をする必要があります。（ただし、 &lt;code&gt;amcanbackward&lt;/code&gt; がfalseの場合、後続のすべての呼び出しは最初の呼び出しと同じ方向になります。）</target>
        </trans-unit>
        <trans-unit id="a0f7a76e8330fc4bc94786133307659b91dcdc59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amgettuple&lt;/code&gt; function need only be provided if the access method supports &amp;ldquo;plain&amp;rdquo; index scans. If it doesn't, the &lt;code&gt;amgettuple&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct must be set to NULL.</source>
          <target state="translated">&lt;code&gt;amgettuple&lt;/code&gt; を関数必要が唯一の場合は、アクセス方法がサポートする「プレーン」インデックススキャンを提供すること。そうでない場合は、 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 構造体の &lt;code&gt;amgettuple&lt;/code&gt; フィールドをNULLに設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="cde20037ee1497cd6ab533acce975df0e8aa1224" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ammarkpos&lt;/code&gt; function need only be provided if the access method supports ordered scans. If it doesn't, the &lt;code&gt;ammarkpos&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct may be set to NULL.</source>
          <target state="translated">&lt;code&gt;ammarkpos&lt;/code&gt; のアクセス方法がサポートしてスキャンを注文した場合、機能の必要性にのみ提供されます。そうでない場合は、 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 構造体の &lt;code&gt;ammarkpos&lt;/code&gt; フィールドがNULLに設定されている可能性があります。</target>
        </trans-unit>
        <trans-unit id="ccdf26b3604c28eca91ce1c3b3a35a7a58b7e44e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amproperty&lt;/code&gt; method allows index access methods to override the default behavior of &lt;code&gt;pg_index_column_has_property&lt;/code&gt; and related functions. If the access method does not have any special behavior for index property inquiries, the &lt;code&gt;amproperty&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct can be set to NULL. Otherwise, the &lt;code&gt;amproperty&lt;/code&gt; method will be called with &lt;em&gt;&lt;code&gt;index_oid&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;attno&lt;/code&gt;&lt;/em&gt; both zero for &lt;code&gt;pg_indexam_has_property&lt;/code&gt; calls, or with &lt;em&gt;&lt;code&gt;index_oid&lt;/code&gt;&lt;/em&gt; valid and &lt;em&gt;&lt;code&gt;attno&lt;/code&gt;&lt;/em&gt; zero for &lt;code&gt;pg_index_has_property&lt;/code&gt; calls, or with &lt;em&gt;&lt;code&gt;index_oid&lt;/code&gt;&lt;/em&gt; valid and &lt;em&gt;&lt;code&gt;attno&lt;/code&gt;&lt;/em&gt; greater than zero for &lt;code&gt;pg_index_column_has_property&lt;/code&gt; calls. &lt;em&gt;&lt;code&gt;prop&lt;/code&gt;&lt;/em&gt; is an enum value identifying the property being tested, while &lt;em&gt;&lt;code&gt;propname&lt;/code&gt;&lt;/em&gt; is the original property name string. If the core code does not recognize the property name then &lt;em&gt;&lt;code&gt;prop&lt;/code&gt;&lt;/em&gt; is &lt;code&gt;AMPROP_UNKNOWN&lt;/code&gt;. Access methods can define custom property names by checking &lt;em&gt;&lt;code&gt;propname&lt;/code&gt;&lt;/em&gt; for a match (use &lt;code&gt;pg_strcasecmp&lt;/code&gt; to match, for consistency with the core code); for names known to the core code, it's better to inspect &lt;em&gt;&lt;code&gt;prop&lt;/code&gt;&lt;/em&gt;. If the &lt;code&gt;amproperty&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt; then it has determined the property test result: it must set &lt;code&gt;*res&lt;/code&gt; to the boolean value to return, or set &lt;code&gt;*isnull&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; to return a NULL. (Both of the referenced variables are initialized to &lt;code&gt;false&lt;/code&gt; before the call.) If the &lt;code&gt;amproperty&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt; then the core code will proceed with its normal logic for determining the property test result.</source>
          <target state="translated">&lt;code&gt;amproperty&lt;/code&gt; の方法は、インデックスアクセスメソッドは、デフォルトの動作無効にすることができます &lt;code&gt;pg_index_column_has_property&lt;/code&gt; および関連機能を。アクセス方法にインデックスプロパティの問い合わせに対する特別な動作がない場合は、 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 構造体の &lt;code&gt;amproperty&lt;/code&gt; フィールドをNULLに設定できます。それ以外の場合は、 &lt;code&gt;amproperty&lt;/code&gt; の方法は、と呼ばれます&lt;em&gt; &lt;code&gt;index_oid&lt;/code&gt; &lt;/em&gt;と&lt;em&gt; &lt;code&gt;attno&lt;/code&gt; &lt;/em&gt;ゼロの両方 &lt;code&gt;pg_indexam_has_property&lt;/code&gt; の呼び出し、またはと&lt;em&gt; &lt;code&gt;index_oid&lt;/code&gt; &lt;/em&gt;有効と&lt;em&gt; &lt;code&gt;attno&lt;/code&gt; &lt;/em&gt;ゼロ &lt;code&gt;pg_index_has_property&lt;/code&gt; の呼び出し、またはで&lt;em&gt; &lt;code&gt;index_oid&lt;/code&gt; &lt;/em&gt;有効と&lt;em&gt; &lt;code&gt;attno&lt;/code&gt; &lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; &lt;code&gt;pg_index_column_has_property&lt;/code&gt; 呼び出しでゼロより大きい。&lt;em&gt; &lt;code&gt;prop&lt;/code&gt; &lt;/em&gt;はテストされるプロパティを識別する列挙値で、&lt;em&gt; &lt;code&gt;propname&lt;/code&gt; &lt;/em&gt;は元のプロパティ名文字列です。コアコードがプロパティ名を認識しない場合、&lt;em&gt; &lt;code&gt;prop&lt;/code&gt; &lt;/em&gt;は &lt;code&gt;AMPROP_UNKNOWN&lt;/code&gt; です。アクセス方法は、&lt;em&gt; &lt;code&gt;propname&lt;/code&gt; &lt;/em&gt;で一致をチェックすることにより、カスタムプロパティ名を定義できます（コアコードとの一貫性を &lt;code&gt;pg_strcasecmp&lt;/code&gt; ために、pg_strcasecmpを使用して一致させます）。コアコードで知られている名前については、&lt;em&gt; &lt;code&gt;prop&lt;/code&gt; &lt;/em&gt;を検査することをお&lt;em&gt;勧めし&lt;/em&gt;ます。場合 &lt;code&gt;amproperty&lt;/code&gt; のメソッドが返す &lt;code&gt;true&lt;/code&gt; 、それは性試験の結果を決定した：それは設定する必要があります &lt;code&gt;*res&lt;/code&gt; 返すブール値に、または &lt;code&gt;*isnull&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定してNULLを返します。（参照される変数はどちらも、呼び出しの前に &lt;code&gt;false&lt;/code&gt; に初期化されます。） &lt;code&gt;amproperty&lt;/code&gt; メソッドが &lt;code&gt;false&lt;/code&gt; を返す場合、コアコードは、プロパティテスト結果を決定するための通常のロジックを続行します。</target>
        </trans-unit>
        <trans-unit id="ee6ce83ebaf748f648fd0330541075210e5894e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amrestrpos&lt;/code&gt; function need only be provided if the access method supports ordered scans. If it doesn't, the &lt;code&gt;amrestrpos&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct may be set to NULL.</source>
          <target state="translated">&lt;code&gt;amrestrpos&lt;/code&gt; のアクセス方法がサポートしてスキャンを注文した場合、この関数にのみ提供される必要があります。そうでない場合は、 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 構造体の &lt;code&gt;amrestrpos&lt;/code&gt; フィールドがNULLに設定されている可能性があります。</target>
        </trans-unit>
        <trans-unit id="fe809061c1f64f874371a0dcea9b46cff8a18bd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;application_name&lt;/code&gt; can be any string of less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; characters (64 characters in a standard build). It is typically set by an application upon connection to the server. The name will be displayed in the &lt;code&gt;pg_stat_activity&lt;/code&gt; view and included in CSV log entries. It can also be included in regular log entries via the &lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix&lt;/a&gt; parameter. Only printable ASCII characters may be used in the &lt;code&gt;application_name&lt;/code&gt; value. Other characters will be replaced with question marks (&lt;code&gt;?&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;application_name&lt;/code&gt; 以下のいずれかの文字列を指定でき &lt;code&gt;NAMEDATALEN&lt;/code&gt; 文字（標準ビルドで64文字）。通常、サーバーへの接続時にアプリケーションによって設定されます。名前は &lt;code&gt;pg_stat_activity&lt;/code&gt; ビューに表示され、CSVログエントリに含まれます。また、&lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix&lt;/a&gt;パラメータを介して通常のログエントリに含めることもできます。 &lt;code&gt;application_name&lt;/code&gt; 値には、印刷可能なASCII文字のみを使用できます。他の文字は疑問符（ &lt;code&gt;?&lt;/code&gt; ）に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="810ba7465a70771d2961f660e2ffe00a08ad7b7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function works for the types &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;, and &lt;code&gt;path&lt;/code&gt;. The &lt;code&gt;area&lt;/code&gt; function only works on the &lt;code&gt;path&lt;/code&gt; data type if the points in the &lt;code&gt;path&lt;/code&gt; are non-intersecting. For example, the &lt;code&gt;path&lt;/code&gt;&lt;code&gt;'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH&lt;/code&gt; will not work; however, the following visually identical &lt;code&gt;path&lt;/code&gt;&lt;code&gt;'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH&lt;/code&gt; will work. If the concept of an intersecting versus non-intersecting &lt;code&gt;path&lt;/code&gt; is confusing, draw both of the above &lt;code&gt;path&lt;/code&gt;s side by side on a piece of graph paper.</source>
          <target state="translated">&lt;code&gt;area&lt;/code&gt; 機能は、タイプのために働く &lt;code&gt;box&lt;/code&gt; 、 &lt;code&gt;circle&lt;/code&gt; 、および &lt;code&gt;path&lt;/code&gt; 。 &lt;code&gt;area&lt;/code&gt; 機能のみで動作 &lt;code&gt;path&lt;/code&gt; における点場合は、データタイプ &lt;code&gt;path&lt;/code&gt; 非交差です。たとえば、 &lt;code&gt;path&lt;/code&gt; &lt;code&gt;'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH&lt;/code&gt; は機能しません。ただし、次の視覚的に同一の &lt;code&gt;path&lt;/code&gt; &lt;code&gt;'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH&lt;/code&gt; が機能します。交差する &lt;code&gt;path&lt;/code&gt; と交差しないパスの概念がわかりにくい場合は、上記の両方の &lt;code&gt;path&lt;/code&gt; をグラフ用紙に並べて描きます。</target>
        </trans-unit>
        <trans-unit id="59f921ad3facaf5178eff030fa07dc7338005685" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asciidoc&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt;, &lt;code&gt;latex&lt;/code&gt;, &lt;code&gt;latex-longtable&lt;/code&gt;, and &lt;code&gt;troff-ms&lt;/code&gt; formats put out tables that are intended to be included in documents using the respective mark-up language. They are not complete documents! This might not be necessary in HTML, but in LaTeX you must have a complete document wrapper. The &lt;code&gt;latex&lt;/code&gt; format uses LaTeX's &lt;code&gt;tabular&lt;/code&gt; environment. The &lt;code&gt;latex-longtable&lt;/code&gt; format requires the LaTeX &lt;code&gt;longtable&lt;/code&gt; and &lt;code&gt;booktabs&lt;/code&gt; packages.</source>
          <target state="translated">&lt;code&gt;asciidoc&lt;/code&gt; 、 &lt;code&gt;html&lt;/code&gt; 、 &lt;code&gt;latex&lt;/code&gt; 、 &lt;code&gt;latex-longtable&lt;/code&gt; 、と &lt;code&gt;troff-ms&lt;/code&gt; フォーマットは、それぞれのマークアップ言語を使用して文書に含まれることが意図されているテーブルを出します。完全なドキュメントではありません！これはHTMLでは必要ないかもしれませんが、LaTeXでは完全なドキュメントラッパーが必要です。 &lt;code&gt;latex&lt;/code&gt; フォーマットは、ラテックスの使用 &lt;code&gt;tabular&lt;/code&gt; 環境を。 &lt;code&gt;latex-longtable&lt;/code&gt; フォーマットは、LaTeXの必要が &lt;code&gt;longtable&lt;/code&gt; と &lt;code&gt;booktabs&lt;/code&gt; パッケージ。</target>
        </trans-unit>
        <trans-unit id="f35bd0bda526ded9e0b91c584dead64c2d3ef9b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto_explain&lt;/code&gt; module provides a means for logging execution plans of slow statements automatically, without having to run &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; by hand. This is especially helpful for tracking down un-optimized queries in large applications.</source>
          <target state="translated">&lt;code&gt;auto_explain&lt;/code&gt; のモジュールは実行しなくても、自動的に遅い文の実行計画をロギングするための手段を提供&lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt;手で。これは、大規模なアプリケーションで最適化されていないクエリを追跡するのに特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="9f04194d1f661ec08cbef8138cc1ebad08b480fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bench.pl&lt;/code&gt; script has numerous options, which are displayed when it is run without any arguments.</source>
          <target state="translated">&lt;code&gt;bench.pl&lt;/code&gt; のスクリプトは、それが引数なしで実行されたときに表示されている多数のオプションがあります。</target>
        </trans-unit>
        <trans-unit id="5e37968903b5f952d43e00009d52dc6bb5a6d28b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binary&lt;/code&gt; file format consists of a file header, zero or more tuples containing the row data, and a file trailer. Headers and data are in network byte order.</source>
          <target state="translated">&lt;code&gt;binary&lt;/code&gt; ファイル形式はファイルヘッダ、行データを含むゼロ個以上のタプル、ファイルトレーラから成ります。ヘッダーとデータはネットワークバイト順です。</target>
        </trans-unit>
        <trans-unit id="5593a80ab4eb5986c84ab5663e69124cb8f2b569" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binary&lt;/code&gt; format option causes all data to be stored/read as binary format rather than as text. It is somewhat faster than the text and &lt;code&gt;CSV&lt;/code&gt; formats, but a binary-format file is less portable across machine architectures and PostgreSQL versions. Also, the binary format is very data type specific; for example it will not work to output binary data from a &lt;code&gt;smallint&lt;/code&gt; column and read it into an &lt;code&gt;integer&lt;/code&gt; column, even though that would work fine in text format.</source>
          <target state="translated">&lt;code&gt;binary&lt;/code&gt; 形式のオプションは、すべてのデータを記憶させる/バイナリ形式ではなくテキストとして読み取ります。テキスト形式や &lt;code&gt;CSV&lt;/code&gt; 形式よりも多少高速ですが、バイナリ形式のファイルは、マシンアーキテクチャやPostgreSQLバージョン間での移植性が低くなります。また、バイナリ形式は非常にデータ型固有です。たとえば、テキスト形式では問題なく機能しますが、 &lt;code&gt;smallint&lt;/code&gt; 列からバイナリデータを出力して &lt;code&gt;integer&lt;/code&gt; 列に読み取ることはできません。</target>
        </trans-unit>
        <trans-unit id="402f6e7dc47cea56b75bd8100479b08159b6b07c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bytea&lt;/code&gt; data type allows storage of binary strings; see &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-TABLE&quot;&gt;Table 8.6&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;bytea&lt;/code&gt; 型のデータ型はバイナリ列の保存を可能にします。&lt;a href=&quot;datatype-binary#DATATYPE-BINARY-TABLE&quot;&gt;表8.6を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6287927d29cc83d11891a4932630e624e03a0f93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bytea&lt;/code&gt; type supports two formats for input and output: &amp;ldquo;hex&amp;rdquo; format and PostgreSQL's historical &amp;ldquo;escape&amp;rdquo; format. Both of these are always accepted on input. The output format depends on the configuration parameter &lt;a href=&quot;runtime-config-client#GUC-BYTEA-OUTPUT&quot;&gt;bytea_output&lt;/a&gt;; the default is hex. (Note that the hex format was introduced in PostgreSQL 9.0; earlier versions and some tools don't understand it.)</source>
          <target state="translated">&lt;code&gt;bytea&lt;/code&gt; 型のタイプがサポートする入力と出力用の2つの形式：「進」形式とPostgreSQLの歴史的な「エスケープ」形式。これらは両方とも常に入力時に受け入れられます。出力形式は、構成パラメーター&lt;a href=&quot;runtime-config-client#GUC-BYTEA-OUTPUT&quot;&gt;bytea_output&lt;/a&gt;によって異なります。デフォルトは16進数です。 （16進数形式はPostgreSQL 9.0で導入されたことに注意してください。以前のバージョンと一部のツールでは16進数形式が理解できません。）</target>
        </trans-unit>
        <trans-unit id="e03633603ba240cb14fd9f2ba15fb155d7d2a20f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;category&lt;/code&gt; and &lt;code&gt;preferred&lt;/code&gt; parameters can be used to help control which implicit cast will be applied in ambiguous situations. Each data type belongs to a category named by a single ASCII character, and each type is either &amp;ldquo;preferred&amp;rdquo; or not within its category. The parser will prefer casting to preferred types (but only from other types within the same category) when this rule is helpful in resolving overloaded functions or operators. For more details see &lt;a href=&quot;https://www.postgresql.org/docs/12/typeconv.html&quot;&gt;Chapter 10&lt;/a&gt;. For types that have no implicit casts to or from any other types, it is sufficient to leave these settings at the defaults. However, for a group of related types that have implicit casts, it is often helpful to mark them all as belonging to a category and select one or two of the &amp;ldquo;most general&amp;rdquo; types as being preferred within the category. The &lt;code&gt;category&lt;/code&gt; parameter is especially useful when adding a user-defined type to an existing built-in category, such as the numeric or string types. However, it is also possible to create new entirely-user-defined type categories. Select any ASCII character other than an upper-case letter to name such a category.</source>
          <target state="translated">&lt;code&gt;category&lt;/code&gt; と &lt;code&gt;preferred&lt;/code&gt; パラメータは、暗黙的なキャストがあいまいな状況で適用されるヘルプコントロールに使用することができます。各データタイプは、単一のASCII文字で名前が付けられたカテゴリに属し、各タイプは「推奨」されるか、またはそのカテゴリ内にありません。パーサーは、このルールがオーバーロードされた関数または演算子の解決に役立つ場合、優先タイプ（ただし、同じカテゴリー内の他のタイプからのみ）へのキャストを優先します。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/typeconv.html&quot;&gt;第10章を&lt;/a&gt;参照してください。他のタイプとの間で暗黙的なキャストを行わないタイプの場合、これらの設定をデフォルトのままにしておくだけで十分です。ただし、暗黙のキャストを持つ関連するタイプのグループの場合、それらをすべてカテゴリに属する​​ものとしてマークし、「最も一般的な」タイプの1つまたは2つをカテゴリ内で優先するものとして選択すると便利です。 &lt;code&gt;category&lt;/code&gt; などの数値や文字列型などの既存の組み込みのカテゴリにユーザー定義型を追加する際のパラメータは、特に便利です。ただし、完全にユーザー定義の新しいタイプカテゴリを作成することもできます。大文字以外のASCII文字を選択して、そのようなカテゴリに名前を付けます。</target>
        </trans-unit>
        <trans-unit id="8d165445c71930fc47e32f1799f62450eb66b7c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char_length&lt;/code&gt; function is discussed in &lt;a href=&quot;functions-string&quot;&gt;Section 9.4&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;char_length&lt;/code&gt; 機能はで説明されて&lt;a href=&quot;functions-string&quot;&gt;9.4節&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="77163d06028806a119645154241f80d46c25a3ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;checksum&lt;/code&gt; field is the checksum stored in the page, which might be incorrect if the page is somehow corrupted. If data checksums are not enabled for this instance, then the value stored is meaningless.</source>
          <target state="translated">&lt;code&gt;checksum&lt;/code&gt; フィールドは、ページが何らかの形で破損している場合は正しくない可能性がありますページに保存されているチェックサム、です。このインスタンスでデータチェックサムが有効になっていない場合、保存される値は意味がありません。</target>
        </trans-unit>
        <trans-unit id="82779e6580b956b5bd325b957d4ac6fe2940b5b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;choose&lt;/code&gt; function can determine either that the new value matches one of the existing child nodes, or that a new child node must be added, or that the new value is inconsistent with the tuple prefix and so the inner tuple must be split to create a less restrictive prefix.</source>
          <target state="translated">&lt;code&gt;choose&lt;/code&gt; 新しい値が既存の子ノードのいずれかと一致すること、または新しい子ノードを追加しなければならないこと、または新しい値が作成するために分割する必要がありタプル接頭辞と内側タプルので矛盾していることのいずれかで決定することができる機能を制限の少ないプレフィックス。</target>
        </trans-unit>
        <trans-unit id="21462edf88e71a2a5abedaf79780415d3cc77658" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cidr&lt;/code&gt; type holds an IPv4 or IPv6 network specification. Input and output formats follow Classless Internet Domain Routing conventions. The format for specifying networks is &lt;code&gt;address/y&lt;/code&gt; where &lt;code&gt;address&lt;/code&gt; is the network represented as an IPv4 or IPv6 address, and &lt;code&gt;y&lt;/code&gt; is the number of bits in the netmask. If &lt;code&gt;y&lt;/code&gt; is omitted, it is calculated using assumptions from the older classful network numbering system, except it will be at least large enough to include all of the octets written in the input. It is an error to specify a network address that has bits set to the right of the specified netmask.</source>
          <target state="translated">&lt;code&gt;cidr&lt;/code&gt; タイプは、IPv4またはIPv6ネットワーク仕様を保持します。入力形式と出力形式は、クラスレスインターネットドメインルーティングの規則に従います。ネットワークを指定するための形式は &lt;code&gt;address/y&lt;/code&gt; &lt;code&gt;address&lt;/code&gt; IPv4またはIPv6アドレスとして表されるネットワークであり、 &lt;code&gt;y&lt;/code&gt; はネットマスクのビット数です。場合 &lt;code&gt;y&lt;/code&gt; 省略され、入力に書き込まれたオクテットの全てを含むように少なくとも十分な大きさであろう以外は、それは、古いクラスフルネットワークナンバリングシステムからの仮定を用いて計算されます。指定されたネットマスクの右側にビットが設定されているネットワークアドレスを指定すると、エラーになります。</target>
        </trans-unit>
        <trans-unit id="313dbc3735e1e6015db884f05770b0b3141b691a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;citext&lt;/code&gt; data type allows you to eliminate calls to &lt;code&gt;lower&lt;/code&gt; in SQL queries, and allows a primary key to be case-insensitive. &lt;code&gt;citext&lt;/code&gt; is locale-aware, just like &lt;code&gt;text&lt;/code&gt;, which means that the matching of upper case and lower case characters is dependent on the rules of the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; setting. Again, this behavior is identical to the use of &lt;code&gt;lower&lt;/code&gt; in queries. But because it's done transparently by the data type, you don't have to remember to do anything special in your queries.</source>
          <target state="translated">&lt;code&gt;citext&lt;/code&gt; データ型は、あなたがして通話を排除することを可能に &lt;code&gt;lower&lt;/code&gt; SQLクエリでは、と大文字と小文字を区別しないことにする主キーを可能にします。 &lt;code&gt;citext&lt;/code&gt; は、 &lt;code&gt;text&lt;/code&gt; と同じようにロケールに対応しています。つまり、大文字と小文字の一致は、データベースの &lt;code&gt;LC_CTYPE&lt;/code&gt; 設定のルールに依存します。この場合も、この動作はクエリでの &lt;code&gt;lower&lt;/code&gt; の使用と同じです。しかし、それはデータ型によって透過的に行われるため、クエリで特別なことを行うことを覚えておく必要はありません。</target>
        </trans-unit>
        <trans-unit id="fd87bdad25baf813522f25a71f5adc18488d42f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;citext&lt;/code&gt; module provides a case-insensitive character string type, &lt;code&gt;citext&lt;/code&gt;. Essentially, it internally calls &lt;code&gt;lower&lt;/code&gt; when comparing values. Otherwise, it behaves almost exactly like &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;citext&lt;/code&gt; のモジュールは、大文字と小文字を区別しない文字列型を提供 &lt;code&gt;citext&lt;/code&gt; を。本質的に、それは値を比較するとき、内部的に &lt;code&gt;lower&lt;/code&gt; 呼び出します。それ以外の場合は、 &lt;code&gt;text&lt;/code&gt; ほぼ同じように動作します。</target>
        </trans-unit>
        <trans-unit id="bfdaff8a345f235278633882be7cad6ce5741ba5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;clientcert&lt;/code&gt; authentication option is available for all authentication methods, but only in &lt;code&gt;pg_hba.conf&lt;/code&gt; lines specified as &lt;code&gt;hostssl&lt;/code&gt;. When &lt;code&gt;clientcert&lt;/code&gt; is not specified or is set to &lt;code&gt;no-verify&lt;/code&gt;, the server will still verify any presented client certificates against its CA file, if one is configured &amp;mdash; but it will not insist that a client certificate be presented.</source>
          <target state="translated">&lt;code&gt;clientcert&lt;/code&gt; の認証オプションは、すべての認証方法のために利用可能であるが、唯一で &lt;code&gt;pg_hba.conf&lt;/code&gt; よう指定した行 &lt;code&gt;hostssl&lt;/code&gt; 。 &lt;code&gt;clientcert&lt;/code&gt; が指定されていない場合、または &lt;code&gt;no-verify&lt;/code&gt; に設定されている場合、サーバーは提示されたクライアント証明書をCAファイルに対して検証します（設定されている場合）。ただし、クライアント証明書の提示を要求しません。</target>
        </trans-unit>
        <trans-unit id="8c87c5b4f9f4b1dd6255f18fc98a9e79dfa277fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;column_expression&lt;/code&gt; for a column is an XPath 1.0 expression that is evaluated for each row, with the current node from the &lt;code&gt;row_expression&lt;/code&gt; result as its context item, to find the value of the column. If no &lt;code&gt;column_expression&lt;/code&gt; is given, then the column name is used as an implicit path.</source>
          <target state="translated">列の &lt;code&gt;column_expression&lt;/code&gt; は、列の値を見つけるために、 &lt;code&gt;row_expression&lt;/code&gt; の結果の現在のノードをコンテキストアイテムとして使用して、各行に対して評価されるXPath 1.0式です。 &lt;code&gt;column_expression&lt;/code&gt; が指定されていない場合、列名が暗黙パスとして使用されます。</target>
        </trans-unit>
        <trans-unit id="ee6cd05e41a967e8fffae0ba56f38e3c8841aa41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combinefunc&lt;/code&gt; function may optionally be specified to allow the aggregate function to support partial aggregation. If provided, the &lt;code&gt;combinefunc&lt;/code&gt; must combine two &lt;code&gt;state_data_type&lt;/code&gt; values, each containing the result of aggregation over some subset of the input values, to produce a new &lt;code&gt;state_data_type&lt;/code&gt; that represents the result of aggregating over both sets of inputs. This function can be thought of as an &lt;code&gt;sfunc&lt;/code&gt;, where instead of acting upon an individual input row and adding it to the running aggregate state, it adds another aggregate state to the running state.</source>
          <target state="translated">オプションで、 &lt;code&gt;combinefunc&lt;/code&gt; 関数を指定して、集約関数が部分的な集約をサポートできるようにすることができます。指定した場合、 &lt;code&gt;combinefunc&lt;/code&gt; は2つの &lt;code&gt;state_data_type&lt;/code&gt; 値を結合し、それぞれに入力値の一部のサブセットの集計結果を &lt;code&gt;state_data_type&lt;/code&gt; 、両方の入力セットの集計結果を表す新しいstate_data_typeを生成する必要があります。この関数は &lt;code&gt;sfunc&lt;/code&gt; と考えることができます。個々の入力行に作用して実行中の集約状態に追加する代わりに、別の集約状態を実行中の状態に追加します。</target>
        </trans-unit>
        <trans-unit id="47761aa84c1d418aac8f5102d13fb4baaa2c9ec6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combinefunc&lt;/code&gt; must be declared as taking two arguments of the &lt;code&gt;state_data_type&lt;/code&gt; and returning a value of the &lt;code&gt;state_data_type&lt;/code&gt;. Optionally this function may be &amp;ldquo;strict&amp;rdquo;. In this case the function will not be called when either of the input states are null; the other state will be taken as the correct result.</source>
          <target state="translated">&lt;code&gt;combinefunc&lt;/code&gt; は、の二つの引数取るように宣言されなければならない &lt;code&gt;state_data_type&lt;/code&gt; しての値を返す &lt;code&gt;state_data_type&lt;/code&gt; 。必要に応じて、この関数は「厳格」にすることができます。この場合、いずれかの入力状態がnullの場合、関数は呼び出されません。他の状態は正しい結果と見なされます。</target>
        </trans-unit>
        <trans-unit id="09fe595cccceb2fd23743e43b5600a7fb060859e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;composite_value&lt;/code&gt;&lt;code&gt;.*&lt;/code&gt; syntax results in column expansion of this kind when it appears at the top level of a &lt;a href=&quot;queries-select-lists&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; output list&lt;/a&gt;, a &lt;a href=&quot;dml-returning&quot;&gt;&lt;code&gt;RETURNING&lt;/code&gt; list&lt;/a&gt; in &lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt;/&lt;code&gt;DELETE&lt;/code&gt;, a &lt;a href=&quot;queries-values&quot;&gt;&lt;code&gt;VALUES&lt;/code&gt; clause&lt;/a&gt;, or a &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;row constructor&lt;/a&gt;. In all other contexts (including when nested inside one of those constructs), attaching &lt;code&gt;.*&lt;/code&gt; to a composite value does not change the value, since it means &amp;ldquo;all columns&amp;rdquo; and so the same composite value is produced again. For example, if &lt;code&gt;somefunc()&lt;/code&gt; accepts a composite-valued argument, these queries are the same:</source>
          <target state="translated">&lt;code&gt;composite_value&lt;/code&gt; &lt;code&gt;.*&lt;/code&gt; この種のカラム膨張構文結果、それはの最上位に表示される&lt;a href=&quot;queries-select-lists&quot;&gt; &lt;code&gt;SELECT&lt;/code&gt; 出力リスト&lt;/a&gt;、&lt;a href=&quot;dml-returning&quot;&gt; &lt;code&gt;RETURNING&lt;/code&gt; リスト&lt;/a&gt;内の &lt;code&gt;INSERT&lt;/code&gt; / &lt;code&gt;UPDATE&lt;/code&gt; / &lt;code&gt;DELETE&lt;/code&gt; 、&lt;a href=&quot;queries-values&quot;&gt; &lt;code&gt;VALUES&lt;/code&gt; の句&lt;/a&gt;、又は&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;行コンストラクタ&lt;/a&gt;。他のすべてのコンテキスト（これらの構造の1つにネストされている場合を含む）では、 &lt;code&gt;.*&lt;/code&gt; を複合値に付加しても値は変更されません。これは、「すべての列」を意味し、同じ複合値が再び生成されるためです。たとえば、 &lt;code&gt;somefunc()&lt;/code&gt; が複合値の引数を受け入れる場合、これらのクエリは同じです。</target>
        </trans-unit>
        <trans-unit id="76f0da3cbd2adb16157bd1e6643bd7a0df3d22de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;concat&lt;/code&gt;, &lt;code&gt;concat_ws&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt; functions are variadic, so it is possible to pass the values to be concatenated or formatted as an array marked with the &lt;code&gt;VARIADIC&lt;/code&gt; keyword (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS&quot;&gt;Section 37.5.5&lt;/a&gt;). The array's elements are treated as if they were separate ordinary arguments to the function. If the variadic array argument is NULL, &lt;code&gt;concat&lt;/code&gt; and &lt;code&gt;concat_ws&lt;/code&gt; return NULL, but &lt;code&gt;format&lt;/code&gt; treats a NULL as a zero-element array.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; 、 &lt;code&gt;concat_ws&lt;/code&gt; 及び &lt;code&gt;format&lt;/code&gt; が付い配列として連結またはフォーマットされる値を渡すことができるような機能は、可変長である &lt;code&gt;VARIADIC&lt;/code&gt; の（参照キーワードの&lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS&quot;&gt;セクション37.5.5に&lt;/a&gt;）。配列の要素は、関数に対する個別の通常の引数であるかのように扱われます。可変個引数の引数がNULLの場合、 &lt;code&gt;concat&lt;/code&gt; および &lt;code&gt;concat_ws&lt;/code&gt; はNULLを返しますが、 &lt;code&gt;format&lt;/code&gt; はNULLをゼロ要素配列として扱います。</target>
        </trans-unit>
        <trans-unit id="a299b1850dd68d90e4960be66574857975c076da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connectby&lt;/code&gt; function is declared to return &lt;code&gt;setof record&lt;/code&gt;, so the actual names and types of the output columns must be defined in the &lt;code&gt;FROM&lt;/code&gt; clause of the calling &lt;code&gt;SELECT&lt;/code&gt; statement, for example:</source>
          <target state="translated">&lt;code&gt;connectby&lt;/code&gt; の機能を返すように宣言され &lt;code&gt;setof record&lt;/code&gt; 出力列の実際の名前と型が定義されなければならないので、 &lt;code&gt;FROM&lt;/code&gt; 呼び出しの句 &lt;code&gt;SELECT&lt;/code&gt; 例えば、声明：</target>
        </trans-unit>
        <trans-unit id="2da96468cede4a34e23f2e877f5cf905f10ef78c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connectby&lt;/code&gt; function produces a display of hierarchical data that is stored in a table. The table must have a key field that uniquely identifies rows, and a parent-key field that references the parent (if any) of each row. &lt;code&gt;connectby&lt;/code&gt; can display the sub-tree descending from any row.</source>
          <target state="translated">&lt;code&gt;connectby&lt;/code&gt; の関数は、テーブルに格納されている階層データの表示を生成します。テーブルには、行を一意に識別するキーフィールドと、各行の親（存在する場合）を参照する親キーフィールドが必要です。 &lt;code&gt;connectby&lt;/code&gt; は、任意の行から降順でサブツリーを表示できます。</target>
        </trans-unit>
        <trans-unit id="85d82cc59d92a5d0a18334cf90938c8ed88a3a9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;contrib&lt;/code&gt; section contains a number of extensions that provide transforms, which can serve as real-world examples.</source>
          <target state="translated">&lt;code&gt;contrib&lt;/code&gt; セクションは、実例としての役割を果たすことができます変換を、提供の拡張機能の数が含まれています。</target>
        </trans-unit>
        <trans-unit id="1ffcb414402375d1d42596e7d3c9b1593a173043" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows copied.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; コピーされた行の数です。</target>
        </trans-unit>
        <trans-unit id="af73b626e7353c20a6881d071978129473a029ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows deleted. Note that the number may be less than the number of rows that matched the &lt;code&gt;condition&lt;/code&gt; when deletes were suppressed by a &lt;code&gt;BEFORE DELETE&lt;/code&gt; trigger. If &lt;code&gt;count&lt;/code&gt; is 0, no rows were deleted by the query (this is not considered an error).</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 削除された行数です。この数は、 &lt;code&gt;BEFORE DELETE&lt;/code&gt; トリガーによって削除が抑制されたときの &lt;code&gt;condition&lt;/code&gt; に一致した行の数より少ない場合があることに注意してください。 &lt;code&gt;count&lt;/code&gt; が0の場合、クエリによって行は削除されませんでした（これはエラーとは見なされません）。</target>
        </trans-unit>
        <trans-unit id="429e699d049ecd7be74bd5a583ab136d3d21eca9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows fetched (possibly zero). Note that in psql, the command tag will not actually be displayed, since psql displays the fetched rows instead.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 行の数が（おそらくゼロ）フェッチされます。psqlではフェッチされた行が代わりに表示されるため、psqlではコマンドタグは実際には表示されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="7e0d4008484fc3a6fda992772be11542d78e11a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows inserted or updated. &lt;code&gt;oid&lt;/code&gt; is always 0 (it used to be the OID assigned to the inserted row if &lt;code&gt;count&lt;/code&gt; was exactly one and the target table was declared &lt;code&gt;WITH OIDS&lt;/code&gt; and 0 otherwise, but creating a table &lt;code&gt;WITH OIDS&lt;/code&gt; is not supported anymore).</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 挿入または更新された行数です。 &lt;code&gt;oid&lt;/code&gt; は常に0です（ &lt;code&gt;count&lt;/code&gt; が正確に1で、ターゲットテーブルが &lt;code&gt;WITH OIDS&lt;/code&gt; で宣言されている場合は、挿入された行に割り当てられていたOID 、それ以外の場合は0ですが、 &lt;code&gt;WITH OIDS&lt;/code&gt; でのテーブルの作成はサポートされなくなりました）。</target>
        </trans-unit>
        <trans-unit id="d59e6fa3805ce82c8f3b0c639019e005fef26c20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows that a &lt;code&gt;FETCH&lt;/code&gt; command with the same parameters would have returned (possibly zero).</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 行数です &lt;code&gt;FETCH&lt;/code&gt; 戻ってきたのと同じパラメータを指定してコマンドを（おそらくゼロ）。</target>
        </trans-unit>
        <trans-unit id="ffde14c1ea2e01417c3435708517261d052ddb1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows updated, including matched rows whose values did not change. Note that the number may be less than the number of rows that matched the &lt;code&gt;condition&lt;/code&gt; when updates were suppressed by a &lt;code&gt;BEFORE UPDATE&lt;/code&gt; trigger. If &lt;code&gt;count&lt;/code&gt; is 0, no rows were updated by the query (this is not considered an error).</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 、値が変化しなかったマッチ行を含む、更新された行数です。この数は、 &lt;code&gt;BEFORE UPDATE&lt;/code&gt; トリガーによって更新が抑制されたときに &lt;code&gt;condition&lt;/code&gt; に一致した行の数よりも少ない場合があることに注意してください。 &lt;code&gt;count&lt;/code&gt; が0の場合、クエリによって更新された行はありません（これはエラーとは見なされません）。</target>
        </trans-unit>
        <trans-unit id="1bd1175f717b500daf5cf94e2ae95b1e5dd562f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function is declared to return &lt;code&gt;setof record&lt;/code&gt;, so the actual names and types of the output columns must be defined in the &lt;code&gt;FROM&lt;/code&gt; clause of the calling &lt;code&gt;SELECT&lt;/code&gt; statement, for example:</source>
          <target state="translated">&lt;code&gt;crosstab&lt;/code&gt; 関数が返すように宣言され &lt;code&gt;setof record&lt;/code&gt; 出力列の実際の名前と型が定義されなければならないので、 &lt;code&gt;FROM&lt;/code&gt; 呼び出しの句 &lt;code&gt;SELECT&lt;/code&gt; 例えば、声明：</target>
        </trans-unit>
        <trans-unit id="d8aadf50544262136fa7d8c76d5edc945fb11396" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function is used to produce &amp;ldquo;pivot&amp;rdquo; displays, wherein data is listed across the page rather than down. For example, we might have data like</source>
          <target state="translated">&lt;code&gt;crosstab&lt;/code&gt; 関数は、データがページではなく、下を横切って表示されている、請求「ピボット」ディスプレイを生成するために使用されます。たとえば、次のようなデータがあるとします。</target>
        </trans-unit>
        <trans-unit id="9fc99faab5d994fa37274aca83e33cbe8ab82de4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function produces one output row for each consecutive group of input rows with the same &lt;code&gt;row_name&lt;/code&gt; value. It fills the output &lt;code&gt;value&lt;/code&gt; columns, left to right, with the &lt;code&gt;value&lt;/code&gt; fields from these rows. If there are fewer rows in a group than there are output &lt;code&gt;value&lt;/code&gt; columns, the extra output columns are filled with nulls; if there are more rows, the extra input rows are skipped.</source>
          <target state="translated">&lt;code&gt;crosstab&lt;/code&gt; 機能は同じで入力行の各連続グループに対して一つの出力列を生成 &lt;code&gt;row_name&lt;/code&gt; 値。出力 &lt;code&gt;value&lt;/code&gt; 列を左から右に、これらの行の &lt;code&gt;value&lt;/code&gt; フィールドで埋めます。グループ内の行の数が出力 &lt;code&gt;value&lt;/code&gt; 列の数よりも少ない場合、余分な出力列はnullで埋められます。さらに行がある場合、余分な入力行はスキップされます。</target>
        </trans-unit>
        <trans-unit id="fc54c6a3ee9f1815fead23a991ca1a3cbc31deef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function produces one output row for each consecutive group of input rows with the same &lt;code&gt;row_name&lt;/code&gt; value. The output &lt;code&gt;row_name&lt;/code&gt; column, plus any &amp;ldquo;extra&amp;rdquo; columns, are copied from the first row of the group. The output &lt;code&gt;value&lt;/code&gt; columns are filled with the &lt;code&gt;value&lt;/code&gt; fields from rows having matching &lt;code&gt;category&lt;/code&gt; values. If a row's &lt;code&gt;category&lt;/code&gt; does not match any output of the &lt;em&gt;&lt;code&gt;category_sql&lt;/code&gt;&lt;/em&gt; query, its &lt;code&gt;value&lt;/code&gt; is ignored. Output columns whose matching category is not present in any input row of the group are filled with nulls.</source>
          <target state="translated">&lt;code&gt;crosstab&lt;/code&gt; 機能は同じで入力行の各連続グループに対して一つの出力列を生成 &lt;code&gt;row_name&lt;/code&gt; 値。出力の &lt;code&gt;row_name&lt;/code&gt; 列と「追加の」列は、グループの最初の行からコピーされます。出力 &lt;code&gt;value&lt;/code&gt; 列には、一致する &lt;code&gt;category&lt;/code&gt; 値を持つ行の &lt;code&gt;value&lt;/code&gt; フィールドが入力されます。行の &lt;code&gt;category&lt;/code&gt; が&lt;em&gt; &lt;code&gt;category_sql&lt;/code&gt; &lt;/em&gt;クエリのどの出力とも一致しない場合、その &lt;code&gt;value&lt;/code&gt; は無視されます。一致するカテゴリーがグループのどの入力行にも存在しない出力列は、ヌルで埋められます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d30aa2f376a61f86fd4ea02ce6152e230c73fa37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function takes a text parameter that is a SQL query producing raw data formatted in the first way, and produces a table formatted in the second way.</source>
          <target state="translated">&lt;code&gt;crosstab&lt;/code&gt; 関数は、最初の方法でフォーマット生データを生成するSQLクエリでテキストパラメータを受け取り、そして第二の方法でフォーマットされた表を作成します。</target>
        </trans-unit>
        <trans-unit id="cf52a8ddea78696a7f9befff4ffbcb20d2c48c6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstabN&lt;/code&gt; functions are examples of how to set up custom wrappers for the general &lt;code&gt;crosstab&lt;/code&gt; function, so that you need not write out column names and types in the calling &lt;code&gt;SELECT&lt;/code&gt; query. The &lt;code&gt;tablefunc&lt;/code&gt; module includes &lt;code&gt;crosstab2&lt;/code&gt;, &lt;code&gt;crosstab3&lt;/code&gt;, and &lt;code&gt;crosstab4&lt;/code&gt;, whose output row types are defined as</source>
          <target state="translated">&lt;code&gt;crosstabN&lt;/code&gt; の機能は、一般的にカスタムラッパーの設定方法の一例であり、 &lt;code&gt;crosstab&lt;/code&gt; 、あなたが呼び出しに列名とタイプを書き出す必要はありませんのでこと、機能 &lt;code&gt;SELECT&lt;/code&gt; クエリ。 &lt;code&gt;tablefunc&lt;/code&gt; のモジュールは、 &lt;code&gt;crosstab2&lt;/code&gt; 、 &lt;code&gt;crosstab3&lt;/code&gt; 、及び &lt;code&gt;crosstab4&lt;/code&gt; その出力列型として定義されているが、</target>
        </trans-unit>
        <trans-unit id="54ac58ac577c46bd040592fa91e1a077c06d943c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cube&lt;/code&gt; module also provides a GiST index operator class for &lt;code&gt;cube&lt;/code&gt; values. A &lt;code&gt;cube&lt;/code&gt; GiST index can be used to search for values using the &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;@&lt;/code&gt; operators in &lt;code&gt;WHERE&lt;/code&gt; clauses.</source>
          <target state="translated">&lt;code&gt;cube&lt;/code&gt; モジュールはまたためのGiSTインデックス演算子クラス提供 &lt;code&gt;cube&lt;/code&gt; 値。 &lt;code&gt;cube&lt;/code&gt; GiSTインデックスを使用して値を検索するために使用することができる &lt;code&gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;@&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;lt;@&lt;/code&gt; 演算子で &lt;code&gt;WHERE&lt;/code&gt; 句。</target>
        </trans-unit>
        <trans-unit id="f843170ee2f9efd669c186bf546d0e5dd7a1284a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;date_part&lt;/code&gt; function is modeled on the traditional Ingres equivalent to the SQL-standard function &lt;code&gt;extract&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;date_part&lt;/code&gt; での機能は、SQL標準の機能と同等の伝統的なIngresをモデルにしている &lt;code&gt;extract&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c29b4371698f7a456bc5cd073d69c9abf2e592bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;earthdistance&lt;/code&gt; module provides two different approaches to calculating great circle distances on the surface of the Earth. The one described first depends on the &lt;code&gt;cube&lt;/code&gt; module (which &lt;em&gt;must&lt;/em&gt; be installed before &lt;code&gt;earthdistance&lt;/code&gt; can be installed). The second one is based on the built-in &lt;code&gt;point&lt;/code&gt; data type, using longitude and latitude for the coordinates.</source>
          <target state="translated">&lt;code&gt;earthdistance&lt;/code&gt; モジュールは、地球の表面上の大圏距離を計算する2つの異なるアプローチを提供します。最初に説明したものは、 &lt;code&gt;cube&lt;/code&gt; モジュールに依存します（ &lt;code&gt;earthdistance&lt;/code&gt; する前にインストールする&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます）。2つ目は、組み込みの &lt;code&gt;point&lt;/code&gt; データ型に基づいており、座標に経度と緯度を使用しています。</target>
        </trans-unit>
        <trans-unit id="a7890123059537fdc57582740cd61da006402b74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expression&lt;/code&gt; argument of an &lt;code&gt;\if&lt;/code&gt; or &lt;code&gt;\elif&lt;/code&gt; command is subject to variable interpolation and backquote expansion, just like any other backslash command argument. After that it is evaluated like the value of an on/off option variable. So a valid value is any unambiguous case-insensitive match for one of: &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;yes&lt;/code&gt;, &lt;code&gt;no&lt;/code&gt;. For example, &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;tR&lt;/code&gt; will all be considered to be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\if&lt;/code&gt; または &lt;code&gt;\elif&lt;/code&gt; コマンドの &lt;code&gt;expression&lt;/code&gt; 引数は、他のバックスラッシュコマンド引数と同様に、変数補間とバッククォート展開の対象になります。その後、オン/オフオプション変数の値のように評価されます。有効な値は以下のいずれかのために任意の明確な大文字と小文字を区別しないマッチングされるように： &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;false&lt;/code&gt; 、 &lt;code&gt;1&lt;/code&gt; 、 &lt;code&gt;0&lt;/code&gt; 、 &lt;code&gt;on&lt;/code&gt; 、 &lt;code&gt;off&lt;/code&gt; 、 &lt;code&gt;yes&lt;/code&gt; 、 &lt;code&gt;no&lt;/code&gt; 。たとえば、 &lt;code&gt;t&lt;/code&gt; 、 &lt;code&gt;T&lt;/code&gt; 、および &lt;code&gt;tR&lt;/code&gt; はすべて &lt;code&gt;true&lt;/code&gt; と見なされます。</target>
        </trans-unit>
        <trans-unit id="7490327a2b864afa9b5748785adec8119b5d2704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract&lt;/code&gt; function is primarily intended for computational processing. For formatting date/time values for display, see &lt;a href=&quot;functions-formatting&quot;&gt;Section 9.8&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;extract&lt;/code&gt; 機能は、主に演算処理するためのものです。日付/時刻値の表示形式については、&lt;a href=&quot;functions-formatting&quot;&gt;セクション9.8を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="8a9a9ab120adc12bc2db1bb30c3120ad00c0facd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract&lt;/code&gt; function retrieves subfields such as year or hour from date/time values. &lt;code&gt;source&lt;/code&gt; must be a value expression of type &lt;code&gt;timestamp&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, or &lt;code&gt;interval&lt;/code&gt;. (Expressions of type &lt;code&gt;date&lt;/code&gt; are cast to &lt;code&gt;timestamp&lt;/code&gt; and can therefore be used as well.) &lt;code&gt;field&lt;/code&gt; is an identifier or string that selects what field to extract from the source value. The &lt;code&gt;extract&lt;/code&gt; function returns values of type &lt;code&gt;double precision&lt;/code&gt;. The following are valid field names:</source>
          <target state="translated">&lt;code&gt;extract&lt;/code&gt; 、日付/時刻の値から年や時などの機能を取り出しサブフィールド。 &lt;code&gt;source&lt;/code&gt; は、タイプが &lt;code&gt;timestamp&lt;/code&gt; 、 &lt;code&gt;time&lt;/code&gt; 、または &lt;code&gt;interval&lt;/code&gt; の値式である必要があります。 （ &lt;code&gt;date&lt;/code&gt; タイプの式は &lt;code&gt;timestamp&lt;/code&gt; キャストされるため、使用することもできます。） &lt;code&gt;field&lt;/code&gt; は、ソース値から抽出するフィールドを選択する識別子または文字列です。 &lt;code&gt;extract&lt;/code&gt; 関数は、型の値を返し &lt;code&gt;double precision&lt;/code&gt; 。以下は有効なフィールド名です。</target>
        </trans-unit>
        <trans-unit id="d1a437c414eaca06c0d45719567f040e8a9a62f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file_fdw&lt;/code&gt; module provides the foreign-data wrapper &lt;code&gt;file_fdw&lt;/code&gt;, which can be used to access data files in the server's file system, or to execute programs on the server and read their output. The data file or program output must be in a format that can be read by &lt;code&gt;COPY FROM&lt;/code&gt;; see &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; for details. Access to data files is currently read-only.</source>
          <target state="translated">&lt;code&gt;file_fdw&lt;/code&gt; モジュールは外部データラッパの提供 &lt;code&gt;file_fdw&lt;/code&gt; サーバのファイルシステムにアクセス・データ・ファイルに使用することができ、またはサーバー上のプログラムを実行し、その出力を読み取ること。データファイルまたはプログラム出力は、 &lt;code&gt;COPY FROM&lt;/code&gt; で読み取れる形式である必要があります。詳細は&lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;をご覧ください。データファイルへのアクセスは現在読み取り専用です。</target>
        </trans-unit>
        <trans-unit id="dc48dad184d44a7c4859e34f48c4985dbe248e9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame_clause&lt;/code&gt; specifies the set of rows constituting the &lt;em&gt;window frame&lt;/em&gt;, which is a subset of the current partition, for those window functions that act on the frame instead of the whole partition. The set of rows in the frame can vary depending on which row is the current row. The frame can be specified in &lt;code&gt;RANGE&lt;/code&gt;, &lt;code&gt;ROWS&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode; in each case, it runs from the &lt;code&gt;frame_start&lt;/code&gt; to the &lt;code&gt;frame_end&lt;/code&gt;. If &lt;code&gt;frame_end&lt;/code&gt; is omitted, the end defaults to &lt;code&gt;CURRENT ROW&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;frame_clause&lt;/code&gt; を構成する行のセットを指定する&lt;em&gt;窓枠&lt;/em&gt;、これら窓関数のために、現在のパーティションのサブセットであり、全体ではなくパーティションのフレームに作用します。フレーム内の行のセットは、どの行が現在の行であるかによって異なります。フレームは &lt;code&gt;RANGE&lt;/code&gt; 、 &lt;code&gt;ROWS&lt;/code&gt; または &lt;code&gt;GROUPS&lt;/code&gt; モードで指定できます。それぞれの場合に、それが実行されますから &lt;code&gt;frame_start&lt;/code&gt; に &lt;code&gt;frame_end&lt;/code&gt; 。場合 &lt;code&gt;frame_end&lt;/code&gt; に省略され、最後のデフォルト値 &lt;code&gt;CURRENT ROW&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71d31c525333bb24cffbf41e507f2b1076452ef1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame_exclusion&lt;/code&gt; option allows rows around the current row to be excluded from the frame, even if they would be included according to the frame start and frame end options. &lt;code&gt;EXCLUDE CURRENT ROW&lt;/code&gt; excludes the current row from the frame. &lt;code&gt;EXCLUDE GROUP&lt;/code&gt; excludes the current row and its ordering peers from the frame. &lt;code&gt;EXCLUDE TIES&lt;/code&gt; excludes any peers of the current row from the frame, but not the current row itself. &lt;code&gt;EXCLUDE NO OTHERS&lt;/code&gt; simply specifies explicitly the default behavior of not excluding the current row or its peers.</source>
          <target state="translated">&lt;code&gt;frame_exclusion&lt;/code&gt; のオプションは、それらがフレーム開始およびフレーム終了オプションに応じて含まれることになる場合でも、現在の行の周りの行は、フレームから除外することができます。 &lt;code&gt;EXCLUDE CURRENT ROW&lt;/code&gt; は、現在の行をフレームから除外します。 &lt;code&gt;EXCLUDE GROUP&lt;/code&gt; は、現在の行とその順序付けピアをフレームから除外します。 &lt;code&gt;EXCLUDE TIES&lt;/code&gt; は、現在の行のピアをフレームから除外しますが、現在の行自体は除外しません。 &lt;code&gt;EXCLUDE NO OTHERS&lt;/code&gt; は、現在の行またはそのピアを除外しないというデフォルトの動作を明示的に指定するだけです。</target>
        </trans-unit>
        <trans-unit id="79c90a36b51a75ac7dbb48737a2d7af10a18b852" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;function_name&lt;/code&gt; function must have been previously defined using &lt;code&gt;CREATE FUNCTION&lt;/code&gt; and must be defined to accept the correct number of arguments (either one or two) of the indicated types.</source>
          <target state="translated">&lt;code&gt;function_name&lt;/code&gt; 機能は、以前に使用して定義されていなければならない &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 、指示タイプの正しい数の引数（1つまたは2つ）を受け入れるように定義されなければなりません。</target>
        </trans-unit>
        <trans-unit id="9897a44892259c96709c3ce90278ea27b2732f53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fuzzystrmatch&lt;/code&gt; module provides several functions to determine similarities and distance between strings.</source>
          <target state="translated">&lt;code&gt;fuzzystrmatch&lt;/code&gt; のモジュールは、文字列間の類似点との距離を決定するために、いくつかの機能を提供します。</target>
        </trans-unit>
        <trans-unit id="90731181621f8d5d3209f6554f81fdd98c3fb7ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fuzzystrmatch&lt;/code&gt; module provides two functions for working with Soundex codes:</source>
          <target state="translated">&lt;code&gt;fuzzystrmatch&lt;/code&gt; モジュールはSoundexのコードを操作するための2つの機能を提供します。</target>
        </trans-unit>
        <trans-unit id="a076afe3d48bfb5bc5090c4b36aa5c47d792bbb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hstore&lt;/code&gt; type, because of its intrinsic liberality, could contain a lot of different keys. Checking for valid keys is the task of the application. The following examples demonstrate several techniques for checking keys and obtaining statistics.</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; ののタイプは、理由はその固有気前の、異なるキーの多くを含めることができます。有効なキーを確認することは、アプリケーションのタスクです。次の例は、キーをチェックして統計を取得するためのいくつかの手法を示しています。</target>
        </trans-unit>
        <trans-unit id="aa50c73dc35b9d5466c5f124d66eb983ecec8b30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;idx_tup_read&lt;/code&gt; and &lt;code&gt;idx_tup_fetch&lt;/code&gt; counts can be different even without any use of bitmap scans, because &lt;code&gt;idx_tup_read&lt;/code&gt; counts index entries retrieved from the index while &lt;code&gt;idx_tup_fetch&lt;/code&gt; counts live rows fetched from the table. The latter will be less if any dead or not-yet-committed rows are fetched using the index, or if any heap fetches are avoided by means of an index-only scan.</source>
          <target state="translated">&lt;code&gt;idx_tup_read&lt;/code&gt; の値と &lt;code&gt;idx_tup_fetch&lt;/code&gt; ためカウントは、ビットマップスキャンのいずれかを使用することなく、異なる偶数であることができる &lt;code&gt;idx_tup_read&lt;/code&gt; の値つつカウントインデックスエントリがインデックスから取得 &lt;code&gt;idx_tup_fetch&lt;/code&gt; カウントライブ行がテーブルからフェッチされました。後者は、デッドを使用しているか、まだコミットされていない行がインデックスを使用してフェッチされる場合、またはヒープのみのフェッチがインデックスのみのスキャンによって回避される場合は少なくなります。</target>
        </trans-unit>
        <trans-unit id="105555b766284240eda53764bbf412df3e426218" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inet&lt;/code&gt; type holds an IPv4 or IPv6 host address, and optionally its subnet, all in one field. The subnet is represented by the number of network address bits present in the host address (the &amp;ldquo;netmask&amp;rdquo;). If the netmask is 32 and the address is IPv4, then the value does not indicate a subnet, only a single host. In IPv6, the address length is 128 bits, so 128 bits specify a unique host address. Note that if you want to accept only networks, you should use the &lt;code&gt;cidr&lt;/code&gt; type rather than &lt;code&gt;inet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet&lt;/code&gt; タイプは、すべてのフィールドに、IPv4またはIPv6ホストアドレスを保持し、必要に応じてそのサブネット。サブネットは、ホストアドレスに存在するネットワークアドレスビットの数（「ネットマスク」）で表されます。ネットマスクが32でアドレスがIPv4の場合、値はサブネットではなく単一のホストを示します。 IPv6では、アドレス長は128ビットであるため、128ビットは一意のホストアドレスを指定します。ネットワークのみを受け入れる場合は、 &lt;code&gt;inet&lt;/code&gt; ではなく &lt;code&gt;cidr&lt;/code&gt; タイプを使用する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1480b7e9f9737ecb46229fdd00be59d12607dc11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;initdb&lt;/code&gt; mode creates a new PostgreSQL database cluster, that is, a collection of databases that will be managed by a single server instance. This mode invokes the &lt;code&gt;initdb&lt;/code&gt; command. See &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; または &lt;code&gt;initdb&lt;/code&gt; のモードは、単一のサーバインスタンスによって管理されるデータベースの集合である新しいPostgreSQLデータベースクラスタを作成します。このモードは、 &lt;code&gt;initdb&lt;/code&gt; コマンドを呼び出します。詳細については、&lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ecc5e8a2b17fca84bdc393620a0520a109ffd200" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initdb-options&lt;/code&gt; should usually be surrounded by single or double quotes to ensure that they are passed through as a group.</source>
          <target state="translated">&lt;code&gt;initdb-options&lt;/code&gt; 、通常、1グループとして渡されることを保証するために、単一引用符または二重引用符で囲む必要があります。</target>
        </trans-unit>
        <trans-unit id="16d1ccc7e1029a4cfe055973c1a279885ae0a68a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;input_function&lt;/code&gt; converts the type's external textual representation to the internal representation used by the operators and functions defined for the type. &lt;code&gt;output_function&lt;/code&gt; performs the reverse transformation. The input function can be declared as taking one argument of type &lt;code&gt;cstring&lt;/code&gt;, or as taking three arguments of types &lt;code&gt;cstring&lt;/code&gt;, &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;. The first argument is the input text as a C string, the second argument is the type's own OID (except for array types, which instead receive their element type's OID), and the third is the &lt;code&gt;typmod&lt;/code&gt; of the destination column, if known (-1 will be passed if not). The input function must return a value of the data type itself. Usually, an input function should be declared STRICT; if it is not, it will be called with a NULL first parameter when reading a NULL input value. The function must still return NULL in this case, unless it raises an error. (This case is mainly meant to support domain input functions, which might need to reject NULL inputs.) The output function must be declared as taking one argument of the new data type. The output function must return type &lt;code&gt;cstring&lt;/code&gt;. Output functions are not invoked for NULL values.</source>
          <target state="translated">&lt;code&gt;input_function&lt;/code&gt; タイプに対して定義演算子および関数によって使用される内部表現のタイプの外部のテキスト表現を変換します。 &lt;code&gt;output_function&lt;/code&gt; は、逆変換を実行します。入力機能は、型の1つの引数取るように宣言することができます &lt;code&gt;cstring&lt;/code&gt; 、または種類の3つの引数を取るよう &lt;code&gt;cstring&lt;/code&gt; 、 &lt;code&gt;oid&lt;/code&gt; 、 &lt;code&gt;integer&lt;/code&gt; 。最初の引数はC文字列としての入力テキスト、2番目の引数は型自体のOID（配列型は例外で、代わりに要素型のOIDを受け取ります）、3番目は &lt;code&gt;typmod&lt;/code&gt; です既知の場合、宛先列の（知らない場合は-1が渡されます）。入力関数は、データ型自体の値を返す必要があります。通常、入力関数はSTRICTとして宣言する必要があります。そうでない場合は、NULL入力値を読み取るときにNULLの最初のパラメーターで呼び出されます。この場合、エラーが発生しない限り、関数はNULLを返す必要があります。 （このケースは、主にNULL入力を拒否する必要があるドメイン入力関数をサポートするためのものです。）出力関数は、新しいデータ型の1つの引数を取るように宣言する必要があります。出力関数は &lt;code&gt;cstring&lt;/code&gt; 型を返す必要があります。 NULL値の場合、出力関数は呼び出されません。</target>
        </trans-unit>
        <trans-unit id="9dd3f06b986fa431b874d54dd865659b27cfc58c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intagg&lt;/code&gt; module provides an integer aggregator and an enumerator. &lt;code&gt;intagg&lt;/code&gt; is now obsolete, because there are built-in functions that provide a superset of its capabilities. However, the module is still provided as a compatibility wrapper around the built-in functions.</source>
          <target state="translated">&lt;code&gt;intagg&lt;/code&gt; のモジュールは、整数アグリゲータと列挙子を提供します。その機能のスーパーセットを提供する組み込み関数があるため、 &lt;code&gt;intagg&lt;/code&gt; は廃止されました。ただし、モジュールは組み込み関数の互換性ラッパーとして引き続き提供されます。</target>
        </trans-unit>
        <trans-unit id="e5f078a6fe0cf9ef6c6e521625243e1894589ca0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intarray&lt;/code&gt; module provides a number of useful functions and operators for manipulating null-free arrays of integers. There is also support for indexed searches using some of the operators.</source>
          <target state="translated">&lt;code&gt;intarray&lt;/code&gt; モジュールは整数のヌルを含まない配列を操作するために有用な関数と演算子の数を提供します。一部の演算子を使用したインデックス付き検索のサポートもあります。</target>
        </trans-unit>
        <trans-unit id="5e20537f440b22c9608c2d38b191b83f09961384" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;internal&lt;/code&gt; pseudo-type is used to declare functions that are meant only to be called internally by the database system, and not by direct invocation in an SQL query. If a function has at least one &lt;code&gt;internal&lt;/code&gt;-type argument then it cannot be called from SQL. To preserve the type safety of this restriction it is important to follow this coding rule: do not create any function that is declared to return &lt;code&gt;internal&lt;/code&gt; unless it has at least one &lt;code&gt;internal&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;internal&lt;/code&gt; 擬似タイプは、SQLクエリで直接呼び出しによって、データベースシステムによって内部的に呼び出されることのみ意図されている機能ではなく、宣言するために使用されます。関数に少なくとも1つの &lt;code&gt;internal&lt;/code&gt; 型引数がある場合、SQLから呼び出すことはできません。この制限のタイプセーフを維持するには、次のコーディングルールに従うことが重要です。少なくとも1つの &lt;code&gt;internal&lt;/code&gt; 引数がない限り、 &lt;code&gt;internal&lt;/code&gt; を返すように宣言された関数を作成しないでください。</target>
        </trans-unit>
        <trans-unit id="23ef30a7477168386c4be2c94609fc89528b3dee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;interval&lt;/code&gt; type has an additional option, which is to restrict the set of stored fields by writing one of these phrases:</source>
          <target state="translated">&lt;code&gt;interval&lt;/code&gt; のタイプは、これらのフレーズの1を書くことによって保存されたフィールドのセットを制限することで、追加のオプションを持っています：</target>
        </trans-unit>
        <trans-unit id="1ae9c44664a456573cddd9031643c02edb22183c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isn&lt;/code&gt; module provides data types for the following international product numbering standards: EAN13, UPC, ISBN (books), ISMN (music), and ISSN (serials). Numbers are validated on input according to a hard-coded list of prefixes; this list of prefixes is also used to hyphenate numbers on output. Since new prefixes are assigned from time to time, the list of prefixes may be out of date. It is hoped that a future version of this module will obtained the prefix list from one or more tables that can be easily updated by users as needed; however, at present, the list can only be updated by modifying the source code and recompiling. Alternatively, prefix validation and hyphenation support may be dropped from a future version of this module.</source>
          <target state="translated">&lt;code&gt;isn&lt;/code&gt; EAN13、UPC、ISBN（図書）、ISMN（音楽）、およびISSN（雑誌）：モジュールは、次の国際的な製品番号標準のデータ型を提供します。数値は、ハードコーディングされたプレフィックスのリストに従って、入力時に検証されます。このプレフィックスのリストは、出力時に数字をハイフンでつなぐためにも使用されます。新しい接頭辞は時々割り当てられるため、接頭辞のリストは古くなる可能性があります。このモジュールの将来のバージョンでは、必要に応じてユーザーが簡単に更新できる1つ以上のテーブルからプレフィックスリストを取得することが望まれます。ただし、現時点では、ソースコードを変更して再コンパイルすることによってのみリストを更新できます。または、接頭辞の検証とハイフネーションのサポートは、このモジュールの将来のバージョンから削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="9815d1f84bba26cf75ea57db75cbb748c781beb2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isn&lt;/code&gt; module provides the following pairs of type casts:</source>
          <target state="translated">&lt;code&gt;isn&lt;/code&gt; モジュールは、型キャストの次のペアを提供します。</target>
        </trans-unit>
        <trans-unit id="1f3d136969e19c7266e1a9a82b8a9977ef2ab272" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isn&lt;/code&gt; module provides the standard comparison operators, plus B-tree and hash indexing support for all these data types. In addition there are several specialized functions; shown in &lt;a href=&quot;isn#ISN-FUNCTIONS&quot;&gt;Table F.12&lt;/a&gt;. In this table, &lt;code&gt;isn&lt;/code&gt; means any one of the module's data types.</source>
          <target state="translated">&lt;code&gt;isn&lt;/code&gt; モジュールは、標準的な比較演算子を提供し、プラスBツリーと、これらすべてのデータ型のハッシュインデックスサポート。さらに、いくつかの特殊な機能があります。&lt;a href=&quot;isn#ISN-FUNCTIONS&quot;&gt;表F.12に&lt;/a&gt;示す。この表で、 &lt;code&gt;isn&lt;/code&gt; はモジュールのデータ型のいずれかを意味します。</target>
        </trans-unit>
        <trans-unit id="ea0300aa881bba7f19acdd017cb9ddd3ccdf7dd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;jsonb&lt;/code&gt; data types accept &lt;em&gt;almost&lt;/em&gt; identical sets of values as input. The major practical difference is one of efficiency. The &lt;code&gt;json&lt;/code&gt; data type stores an exact copy of the input text, which processing functions must reparse on each execution; while &lt;code&gt;jsonb&lt;/code&gt; data is stored in a decomposed binary format that makes it slightly slower to input due to added conversion overhead, but significantly faster to process, since no reparsing is needed. &lt;code&gt;jsonb&lt;/code&gt; also supports indexing, which can be a significant advantage.</source>
          <target state="translated">&lt;code&gt;json&lt;/code&gt; と &lt;code&gt;jsonb&lt;/code&gt; データ型が受け入れる&lt;em&gt;ほぼ&lt;/em&gt;入力などの値の同じセット。主な実用的な違いは効率の1つです。 &lt;code&gt;json&lt;/code&gt; データ・タイプは、処理機能を実行するたびに再解析する必要があり、入力されたテキストの正確なコピーを格納します。一方、 &lt;code&gt;jsonb&lt;/code&gt; データは分解されたバイナリ形式で保存されるため、変換オーバーヘッドが追加されるため、入力は少し遅くなりますが、再解析が不要なため、処理は大幅に高速になります。 &lt;code&gt;jsonb&lt;/code&gt; はインデックス作成もサポートします。これは大きな利点になります。</target>
        </trans-unit>
        <trans-unit id="c18a0defa6788cb12c053fbf70d6cdb3c5a6ee90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;json_typeof&lt;/code&gt; function's &lt;code&gt;null&lt;/code&gt; return value should not be confused with a SQL NULL. While calling &lt;code&gt;json_typeof('null'::json)&lt;/code&gt; will return &lt;code&gt;null&lt;/code&gt;, calling &lt;code&gt;json_typeof(NULL::json)&lt;/code&gt; will return a SQL NULL.</source>
          <target state="translated">&lt;code&gt;json_typeof&lt;/code&gt; 機能の &lt;code&gt;null&lt;/code&gt; 戻り値がSQLのNULLと混同してはなりません。呼び出し中に &lt;code&gt;json_typeof('null'::json)&lt;/code&gt; を返します &lt;code&gt;null&lt;/code&gt; 呼び出して、 &lt;code&gt;json_typeof(NULL::json)&lt;/code&gt; SQLのNULLを返します。</target>
        </trans-unit>
        <trans-unit id="168cc05ce6845d58616f3f7646b54fd243f5124d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsonb_path_exists&lt;/code&gt;, &lt;code&gt;jsonb_path_match&lt;/code&gt;, &lt;code&gt;jsonb_path_query&lt;/code&gt;, &lt;code&gt;jsonb_path_query_array&lt;/code&gt;, and &lt;code&gt;jsonb_path_query_first&lt;/code&gt; functions have optional &lt;code&gt;vars&lt;/code&gt; and &lt;code&gt;silent&lt;/code&gt; arguments.</source>
          <target state="translated">&lt;code&gt;jsonb_path_exists&lt;/code&gt; 、 &lt;code&gt;jsonb_path_match&lt;/code&gt; 、 &lt;code&gt;jsonb_path_query&lt;/code&gt; 、 &lt;code&gt;jsonb_path_query_array&lt;/code&gt; 、および &lt;code&gt;jsonb_path_query_first&lt;/code&gt; 機能は、オプションの持っている &lt;code&gt;vars&lt;/code&gt; と &lt;code&gt;silent&lt;/code&gt; 引数を。</target>
        </trans-unit>
        <trans-unit id="772704f4d66d5faa09292e5f927a415dbd1364fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsonpath&lt;/code&gt; type implements support for the SQL/JSON path language in PostgreSQL to efficiently query JSON data. It provides a binary representation of the parsed SQL/JSON path expression that specifies the items to be retrieved by the path engine from the JSON data for further processing with the SQL/JSON query functions.</source>
          <target state="translated">&lt;code&gt;jsonpath&lt;/code&gt; のタイプの実装を効率的にクエリJSONデータへのPostgreSQLでSQL / JSONパス言語のサポート。 SQL / JSONクエリ関数でさらに処理するために、JSONデータからパスエンジンによって取得されるアイテムを指定する解析済みSQL / JSONパス式のバイナリ表現を提供します。</target>
        </trans-unit>
        <trans-unit id="2149f5c0dd4945e41bb0756947056ef98b639170" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;like_type&lt;/code&gt; parameter provides an alternative method for specifying the basic representation properties of a data type: copy them from some existing type. The values of &lt;code&gt;internallength&lt;/code&gt;, &lt;code&gt;passedbyvalue&lt;/code&gt;, &lt;code&gt;alignment&lt;/code&gt;, and &lt;code&gt;storage&lt;/code&gt; are copied from the named type. (It is possible, though usually undesirable, to override some of these values by specifying them along with the &lt;code&gt;LIKE&lt;/code&gt; clause.) Specifying representation this way is especially useful when the low-level implementation of the new type &amp;ldquo;piggybacks&amp;rdquo; on an existing type in some fashion.</source>
          <target state="translated">&lt;code&gt;like_type&lt;/code&gt; のパラメータは、データ型の基本表現プロパティを指定するための別の方法を提供し、いくつかの既存のタイプからそれらをコピーします。 &lt;code&gt;internallength&lt;/code&gt; 、 &lt;code&gt;passedbyvalue&lt;/code&gt; 、 &lt;code&gt;alignment&lt;/code&gt; 、および &lt;code&gt;storage&lt;/code&gt; の値は、名前付きの型からコピーされます。 （通常は望ましくありませんが、 &lt;code&gt;LIKE&lt;/code&gt; 句とともにこれらの値を指定することにより、これらの値の一部をオーバーライドすることができます。）この方法で表現を指定すると、新しいタイプの低レベルの実装が、いくつかのファッション。</target>
        </trans-unit>
        <trans-unit id="9d22eb5dee38146c30421a70885a4db31297786e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lo&lt;/code&gt; module allows fixing this by attaching a trigger to tables that contain LO reference columns. The trigger essentially just does a &lt;code&gt;lo_unlink&lt;/code&gt; whenever you delete or modify a value referencing a large object. When you use this trigger, you are assuming that there is only one database reference to any large object that is referenced in a trigger-controlled column!</source>
          <target state="translated">&lt;code&gt;lo&lt;/code&gt; モジュールは、LO参照列を含むテーブルにトリガを取り付けることによって、これを固定することができます。ラージオブジェクトを参照する値を削除または変更するたびに、トリガーは基本的に &lt;code&gt;lo_unlink&lt;/code&gt; を実行します。このトリガーを使用する場合、トリガー制御列で参照されるラージオブジェクトへのデータベース参照は1つだけであると想定しています。</target>
        </trans-unit>
        <trans-unit id="41e1b86fc89c1b3ca96870ada2d42cd830ee60fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lo&lt;/code&gt; module provides support for managing Large Objects (also called LOs or BLOBs). This includes a data type &lt;code&gt;lo&lt;/code&gt; and a trigger &lt;code&gt;lo_manage&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lo&lt;/code&gt; モジュール（これものLOまたはBLOBのと呼ばれる）ラージ・オブジェクトを管理するためのサポートを提供します。これには、データ型 &lt;code&gt;lo&lt;/code&gt; とトリガー &lt;code&gt;lo_manage&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="9b1213fb426cb2334040aa09e1426c55587c855d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lower-bound&lt;/code&gt; may be either a string that is valid input for the subtype, or empty to indicate no lower bound. Likewise, &lt;code&gt;upper-bound&lt;/code&gt; may be either a string that is valid input for the subtype, or empty to indicate no upper bound.</source>
          <target state="translated">&lt;code&gt;lower-bound&lt;/code&gt; サブタイプの有効な入力文字列のいずれかであり、または全く下限示すないこと空よいです。同様に、 &lt;code&gt;upper-bound&lt;/code&gt; は、サブタイプの有効な入力である文字列、または上限がないことを示す空の場合があります。</target>
        </trans-unit>
        <trans-unit id="3a4962a0009307ba6431284c97bb49876d7ddc17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lower&lt;/code&gt; and &lt;code&gt;upper&lt;/code&gt; functions return null if the range is empty or the requested bound is infinite. The &lt;code&gt;lower_inc&lt;/code&gt;, &lt;code&gt;upper_inc&lt;/code&gt;, &lt;code&gt;lower_inf&lt;/code&gt;, and &lt;code&gt;upper_inf&lt;/code&gt; functions all return false for an empty range.</source>
          <target state="translated">&lt;code&gt;lower&lt;/code&gt; 及び &lt;code&gt;upper&lt;/code&gt; 範囲が空であるか、または結合した要求された無限大の場合関数はNULLを返します。 &lt;code&gt;lower_inc&lt;/code&gt; 、 &lt;code&gt;upper_inc&lt;/code&gt; 、 &lt;code&gt;lower_inf&lt;/code&gt; 、および &lt;code&gt;upper_inf&lt;/code&gt; 空の範囲のための機能をすべてのリターンはfalse。</target>
        </trans-unit>
        <trans-unit id="7854ce56999a9ecbf4528c8d9ad238714a056945" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ltree&lt;/code&gt; module provides several data types:</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; はモジュールいくつかのデータ型を提供しています。</target>
        </trans-unit>
        <trans-unit id="4f5d05ac37c953266fc286bdc00b9352cf6192f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macaddr8&lt;/code&gt; type also supports the standard relational operators (&lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, etc.) for ordering, and the bitwise arithmetic operators (&lt;code&gt;~&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;) for NOT, AND and OR.</source>
          <target state="translated">&lt;code&gt;macaddr8&lt;/code&gt; のタイプも標準関係演算子（サポート &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、など）発注のため、およびビット単位の算術演算子（ &lt;code&gt;~&lt;/code&gt; 、 &lt;code&gt;&amp;amp;&lt;/code&gt; や &lt;code&gt;|&lt;/code&gt; ANDとOR、NOTのために）。</target>
        </trans-unit>
        <trans-unit id="ee970738f8a83aad38467525f7f37d7c159f8d4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macaddr8&lt;/code&gt; type stores MAC addresses in EUI-64 format, known for example from Ethernet card hardware addresses (although MAC addresses are used for other purposes as well). This type can accept both 6 and 8 byte length MAC addresses and stores them in 8 byte length format. MAC addresses given in 6 byte format will be stored in 8 byte length format with the 4th and 5th bytes set to FF and FE, respectively. Note that IPv6 uses a modified EUI-64 format where the 7th bit should be set to one after the conversion from EUI-48. The function &lt;code&gt;macaddr8_set7bit&lt;/code&gt; is provided to make this change. Generally speaking, any input which is comprised of pairs of hex digits (on byte boundaries), optionally separated consistently by one of &lt;code&gt;':'&lt;/code&gt;, &lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'.'&lt;/code&gt;, is accepted. The number of hex digits must be either 16 (8 bytes) or 12 (6 bytes). Leading and trailing whitespace is ignored. The following are examples of input formats that are accepted:</source>
          <target state="translated">&lt;code&gt;macaddr8&lt;/code&gt; イーサネットカードのハードウェアアドレスから、例えば公知のEUI-64フォーマットでタイプ格納MACアドレス（MACアドレスは、同様に他の目的に使用されているが）。このタイプは、6バイト長と8バイト長の両方のMACアドレスを受け入れ、それらを8バイト長の形式で保存できます。 6バイト形式で指定されたMACアドレスは、8バイト長形式で保存され、4番目と5番目のバイトはそれぞれFFとFEに設定されます。 IPv6は、EUI-48からの変換後に7番目のビットを1に設定する必要がある変更されたEUI-64形式を使用することに注意してください。この変更を行うために、関数 &lt;code&gt;macaddr8_set7bit&lt;/code&gt; が提供されています。一般的に言えば、16進数のペア（バイト境界上）で構成される入力で、オプションで一貫して &lt;code&gt;':'&lt;/code&gt; 、 &lt;code&gt;'-'&lt;/code&gt; 、または &lt;code&gt;'.'&lt;/code&gt; 、受け入れられます。16進数の数は、16（8バイト）または12（6バイト）でなければなりません。先頭と末尾の空白は無視されます。以下は、受け入れられる入力フォーマットの例です。</target>
        </trans-unit>
        <trans-unit id="c3d79930eaf5f7ce13b46f6856c277aea9ede8da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macaddr&lt;/code&gt; type also supports the standard relational operators (&lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, etc.) for lexicographical ordering, and the bitwise arithmetic operators (&lt;code&gt;~&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;) for NOT, AND and OR.</source>
          <target state="translated">&lt;code&gt;macaddr&lt;/code&gt; タイプも（標準関係演算子をサポートしています &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 辞書式順序付けのために、など）、およびビット単位の算術演算子（ &lt;code&gt;~&lt;/code&gt; 、 &lt;code&gt;&amp;amp;&lt;/code&gt; や &lt;code&gt;|&lt;/code&gt; ）NOTため、ANDとOR。</target>
        </trans-unit>
        <trans-unit id="6ebc662e3381183673c8582b7b95fb9aee6ddcc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macaddr&lt;/code&gt; type stores MAC addresses, known for example from Ethernet card hardware addresses (although MAC addresses are used for other purposes as well). Input is accepted in the following formats:</source>
          <target state="translated">&lt;code&gt;macaddr&lt;/code&gt; イーサネットカードのハードウェアアドレスから、例えば公知のタイプの格納MACアドレス（MACアドレスは、同様に他の目的に使用されているが）。入力は次の形式で受け入れられます。</target>
        </trans-unit>
        <trans-unit id="abb88e6f4baf5008ffda8309a1c86c82f34be1a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxlen&lt;/code&gt; parameter specifies the maximum number of digits allowed in an integer word. The default value is 6.</source>
          <target state="translated">&lt;code&gt;maxlen&lt;/code&gt; パラメータは、整数ワードの最大桁数を指定します。デフォルト値は6です。</target>
        </trans-unit>
        <trans-unit id="c0858eea09f10a0e5d0453c7f76531a7abbd443b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;md5&lt;/code&gt; method cannot be used with the &lt;a href=&quot;runtime-config-connection#GUC-DB-USER-NAMESPACE&quot;&gt;db_user_namespace&lt;/a&gt; feature.</source>
          <target state="translated">&lt;code&gt;md5&lt;/code&gt; 方法を一緒に使用することはできません&lt;a href=&quot;runtime-config-connection#GUC-DB-USER-NAMESPACE&quot;&gt;db_user_namespaceとする&lt;/a&gt;機能。</target>
        </trans-unit>
        <trans-unit id="b398ca59b1e24ecdf79b1f3151e58ecf006b28e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min()&lt;/code&gt; and &lt;code&gt;avg()&lt;/code&gt; aggregates are computed concurrently over all the input rows, so if any row has &lt;code&gt;employees&lt;/code&gt; equal to zero, the division-by-zero error will occur before there is any opportunity to test the result of &lt;code&gt;min()&lt;/code&gt;. Instead, use a &lt;code&gt;WHERE&lt;/code&gt; or &lt;code&gt;FILTER&lt;/code&gt; clause to prevent problematic input rows from reaching an aggregate function in the first place.</source>
          <target state="translated">&lt;code&gt;min()&lt;/code&gt; 及び &lt;code&gt;avg()&lt;/code&gt; 凝集体は、任意の行を有しそうである場合、すべての入力行にわたって同時に計算され &lt;code&gt;employees&lt;/code&gt; ゼロに等しい結果をテストするための任意の機会がある前に、ゼロ除算エラーが発生する &lt;code&gt;min()&lt;/code&gt; 。代わりに、 &lt;code&gt;WHERE&lt;/code&gt; 句または &lt;code&gt;FILTER&lt;/code&gt; 句を使用して、問題のある入力行が最初から集計関数に到達しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="6fa5889a0b42548324335d58d566964f3bd48031" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;money&lt;/code&gt; type stores a currency amount with a fixed fractional precision; see &lt;a href=&quot;datatype-money#DATATYPE-MONEY-TABLE&quot;&gt;Table 8.3&lt;/a&gt;. The fractional precision is determined by the database's &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt; setting. The range shown in the table assumes there are two fractional digits. Input is accepted in a variety of formats, including integer and floating-point literals, as well as typical currency formatting, such as &lt;code&gt;'$1,000.00'&lt;/code&gt;. Output is generally in the latter form but depends on the locale.</source>
          <target state="translated">&lt;code&gt;money&lt;/code&gt; 型は、固定された小数精度の通貨量を記憶します。&lt;a href=&quot;datatype-money#DATATYPE-MONEY-TABLE&quot;&gt;表8.3を&lt;/a&gt;参照してください。小数精度は、データベースの&lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt;設定によって決定されます。表に示されている範囲は、2つの小数桁があることを前提としています。入力は、整数リテラルおよび浮動小数点リテラルを含むさまざまな形式、および &lt;code&gt;'$1,000.00'&lt;/code&gt; などの一般的な通貨形式で受け入れられます。出力は通常後者の形式ですが、ロケールに依存します。</target>
        </trans-unit>
        <trans-unit id="591d71ee5e714d1d5bb09ebf8473fd24333cc869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;oid&lt;/code&gt; type is currently implemented as an unsigned four-byte integer. Therefore, it is not large enough to provide database-wide uniqueness in large databases, or even in large individual tables.</source>
          <target state="translated">&lt;code&gt;oid&lt;/code&gt; タイプは、現在符号なしの4バイト整数として実装されます。そのため、大規模なデータベースや、個々の大規模なテーブルでデータベース全体の一意性を提供するのに十分な大きさではありません。</target>
        </trans-unit>
        <trans-unit id="78dc4927f04eeaf9a8229a0fc622fc80f07cd7e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;oid&lt;/code&gt; type itself has few operations beyond comparison. It can be cast to integer, however, and then manipulated using the standard integer operators. (Beware of possible signed-versus-unsigned confusion if you do this.)</source>
          <target state="translated">&lt;code&gt;oid&lt;/code&gt; 型自体は、比較を超えて、いくつかの事業を展開しています。ただし、整数にキャストしてから、標準の整数演算子を使用して操作できます。 （これを行う場合は、符号付きと符号なしの混同の可能性に注意してください。）</target>
        </trans-unit>
        <trans-unit id="90126f847a19f26e444b96e74dbf5fc70037caf9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;open_&lt;/code&gt;* options also use &lt;code&gt;O_DIRECT&lt;/code&gt; if available. Not all of these choices are available on all platforms. The default is the first method in the above list that is supported by the platform, except that &lt;code&gt;fdatasync&lt;/code&gt; is the default on Linux. The default is not necessarily ideal; it might be necessary to change this setting or other aspects of your system configuration in order to create a crash-safe configuration or achieve optimal performance. These aspects are discussed in &lt;a href=&quot;wal-reliability&quot;&gt;Section 29.1&lt;/a&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">&lt;code&gt;open_&lt;/code&gt; *オプションも使用 &lt;code&gt;O_DIRECT&lt;/code&gt; を利用できます。これらの選択肢のすべてがすべてのプラットフォームで利用できるわけではありません。デフォルトは、 &lt;code&gt;fdatasync&lt;/code&gt; がLinuxのデフォルトであることを除いて、プラットフォームでサポートされている上記のリストの最初の方法です。デフォルトは必ずしも理想的ではありません。クラッシュセーフな構成を作成したり、最適なパフォーマンスを実現したりするには、この設定やシステム構成の他の側面を変更する必要がある場合があります。これらの側面については、&lt;a href=&quot;wal-reliability&quot;&gt;セクション29.1で&lt;/a&gt;説明します。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="1deebe3b08e139dca519f072e65bc0913b196cc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; should usually be surrounded by single or double quotes to ensure that they are passed through as a group.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 、通常、1グループとして渡されることを保証するために、単一引用符または二重引用符で囲む必要があります。</target>
        </trans-unit>
        <trans-unit id="e287f99758c3cdb10c1fc61789ee15a8d908a550" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pageinspect&lt;/code&gt; module provides functions that allow you to inspect the contents of database pages at a low level, which is useful for debugging purposes. All of these functions may be used only by superusers.</source>
          <target state="translated">&lt;code&gt;pageinspect&lt;/code&gt; のモジュールを使用すると、デバッグ目的のために有用である低レベルでデータベースページの内容を検査できるようにする機能を提供します。これらの関数はすべて、スーパーユーザーのみが使用できます。</target>
        </trans-unit>
        <trans-unit id="530a467c47cea19dd0c00ec1dbc483debfa27dbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;partition_bound_spec&lt;/code&gt; must correspond to the partitioning method and partition key of the parent table, and must not overlap with any existing partition of that parent. The form with &lt;code&gt;IN&lt;/code&gt; is used for list partitioning, the form with &lt;code&gt;FROM&lt;/code&gt; and &lt;code&gt;TO&lt;/code&gt; is used for range partitioning, and the form with &lt;code&gt;WITH&lt;/code&gt; is used for hash partitioning.</source>
          <target state="translated">&lt;code&gt;partition_bound_spec&lt;/code&gt; 親テーブルの分割方法及び分割キーに必須の対応、およびその親の任意の既存のパーティションと重複してはなりません。 &lt;code&gt;IN&lt;/code&gt; のあるフォームはリストのパーティション分割に使用され、 &lt;code&gt;FROM&lt;/code&gt; と &lt;code&gt;TO&lt;/code&gt; のあるフォームは範囲パーティション分割に使用され、 &lt;code&gt;WITH&lt;/code&gt; のあるフォームはハッシュパーティション分割に使用されます。</target>
        </trans-unit>
        <trans-unit id="321cdf6012708ec28d857a16216ddd141b4795b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passwordcheck&lt;/code&gt; module checks users' passwords whenever they are set with &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; or &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;. If a password is considered too weak, it will be rejected and the command will terminate with an error.</source>
          <target state="translated">&lt;code&gt;passwordcheck&lt;/code&gt; モジュールのチェックユーザのパスワードそれらがで設定されるたびに&lt;a href=&quot;sql-createrole&quot;&gt;、CREATE ROLE&lt;/a&gt;または&lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLEを&lt;/a&gt;。パスワードが弱すぎると見なされた場合、パスワードは拒否され、コマンドはエラーで終了します。</target>
        </trans-unit>
        <trans-unit id="86ab56758cab8beb34df6aa406664611103452cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;penalty&lt;/code&gt; function is crucial to good performance of the index. It'll get used at insertion time to determine which branch to follow when choosing where to add the new entry in the tree. At query time, the more balanced the index, the quicker the lookup.</source>
          <target state="translated">&lt;code&gt;penalty&lt;/code&gt; 関数は、指数の優れた性能に非常に重要です。挿入時に、ツリーの新しいエントリを追加する場所を選択するときにたどるブランチを決定するために使用されます。クエリ時に、インデックスのバランスが取れているほど、検索が速くなります。</target>
        </trans-unit>
        <trans-unit id="eca57d9a0482509128492e1b7deb298ac5bcf1be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_available_extension_versions&lt;/code&gt; view is read only.</source>
          <target state="translated">&lt;code&gt;pg_available_extension_versions&lt;/code&gt; のビューは読み取り専用です。</target>
        </trans-unit>
        <trans-unit id="e30cddb8256b97d7a85be6f99c4ef44cdaa252a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_available_extension_versions&lt;/code&gt; view lists the specific extension versions that are available for installation. See also the &lt;a href=&quot;catalog-pg-extension&quot;&gt;&lt;code&gt;pg_extension&lt;/code&gt;&lt;/a&gt; catalog, which shows the extensions currently installed.</source>
          <target state="translated">&lt;code&gt;pg_available_extension_versions&lt;/code&gt; はリストにインストール可能な特定の拡張バージョンを表示します。現在インストールされている拡張機能を示す&lt;a href=&quot;catalog-pg-extension&quot;&gt; &lt;code&gt;pg_extension&lt;/code&gt; &lt;/a&gt;カタログも参照してください。</target>
        </trans-unit>
        <trans-unit id="0e7d98e76ccc0a3eea34c953f9960047fdf4d011" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_available_extensions&lt;/code&gt; view is read only.</source>
          <target state="translated">&lt;code&gt;pg_available_extensions&lt;/code&gt; のビューは読み取り専用です。</target>
        </trans-unit>
        <trans-unit id="5019d9408165c6f3daf9b540d710ea624fb4f2a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_available_extensions&lt;/code&gt; view lists the extensions that are available for installation. See also the &lt;a href=&quot;catalog-pg-extension&quot;&gt;&lt;code&gt;pg_extension&lt;/code&gt;&lt;/a&gt; catalog, which shows the extensions currently installed.</source>
          <target state="translated">&lt;code&gt;pg_available_extensions&lt;/code&gt; はリストインストール可能な拡張子を表示します。現在インストールされている拡張機能を示す&lt;a href=&quot;catalog-pg-extension&quot;&gt; &lt;code&gt;pg_extension&lt;/code&gt; &lt;/a&gt;カタログも参照してください。</target>
        </trans-unit>
        <trans-unit id="23147896a0bb8cdf56e9c2215878569d76558769" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_buffercache&lt;/code&gt; module provides a means for examining what's happening in the shared buffer cache in real time.</source>
          <target state="translated">&lt;code&gt;pg_buffercache&lt;/code&gt; モジュールをリアルタイムで共有バッファキャッシュで何が起こっているかを調べるための手段を提供します。</target>
        </trans-unit>
        <trans-unit id="33f64b3a0516da571bdaabc8707c7cfc6382a6fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_constraint&lt;/code&gt; entry associated with the trigger, if any</source>
          <target state="translated">&lt;code&gt;pg_constraint&lt;/code&gt; のいずれかの場合には、トリガーに関連付けられたエントリ</target>
        </trans-unit>
        <trans-unit id="0a3b068150ce34aa7d8adbd51da299ff6a0e91b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_cursors&lt;/code&gt; view displays cursors created by any of these means. Cursors only exist for the duration of the transaction that defines them, unless they have been declared &lt;code&gt;WITH HOLD&lt;/code&gt;. Therefore non-holdable cursors are only present in the view until the end of their creating transaction.</source>
          <target state="translated">&lt;code&gt;pg_cursors&lt;/code&gt; は、これらの手段のいずれかによって作成されたディスプレイのカーソルを表示します。カーソルは、 &lt;code&gt;WITH HOLD&lt;/code&gt; と宣言されていない限り、それらを定義するトランザクションの間のみ存在します。したがって、非保持カーソルは、作成中のトランザクションが終了するまでビューにのみ存在します。</target>
        </trans-unit>
        <trans-unit id="769140bc4ff0be33d8261a2c2495473c9aa06419" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_cursors&lt;/code&gt; view is read only.</source>
          <target state="translated">&lt;code&gt;pg_cursors&lt;/code&gt; のビューは読み取り専用です。</target>
        </trans-unit>
        <trans-unit id="943080f1bca8bfb0a861af0a7366bc0f87ecea56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_cursors&lt;/code&gt; view lists the cursors that are currently available. Cursors can be defined in several ways:</source>
          <target state="translated">&lt;code&gt;pg_cursors&lt;/code&gt; は、リストの現在利用可能なカーソルを表示します。カーソルはいくつかの方法で定義できます。</target>
        </trans-unit>
        <trans-unit id="7f9e99ef77cc93d164810339140c3e9aee6dc96a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_enum&lt;/code&gt; catalog contains entries showing the values and labels for each enum type. The internal representation of a given enum value is actually the OID of its associated row in &lt;code&gt;pg_enum&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_enum&lt;/code&gt; のカタログは、各列挙型の値とラベルを示すエントリが含まれています。指定された列挙値の内部表現は、実際には &lt;code&gt;pg_enum&lt;/code&gt; の関連する行のOIDです。</target>
        </trans-unit>
        <trans-unit id="85db4109eb0a5caec74c9817c0a2aae5033501c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_freespacemap&lt;/code&gt; module provides a means for examining the free space map (FSM). It provides a function called &lt;code&gt;pg_freespace&lt;/code&gt;, or two overloaded functions, to be precise. The functions show the value recorded in the free space map for a given page, or for all pages in the relation.</source>
          <target state="translated">&lt;code&gt;pg_freespacemap&lt;/code&gt; ものモジュールは、空き領域マップ（FSM）を検査するための手段を提供します。正確には、 &lt;code&gt;pg_freespace&lt;/code&gt; と呼ばれる関数、または2つのオーバーロードされた関数を提供します。関数は、特定のページまたはリレーション内のすべてのページの空き領域マップに記録された値を示します。</target>
        </trans-unit>
        <trans-unit id="d26269fc6d836fb10263bde9dc1a6bf13ade8034" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_hba.conf&lt;/code&gt; file is read on start-up and when the main server process receives a SIGHUP signal. If you edit the file on an active system, you will need to signal the postmaster (using &lt;code&gt;pg_ctl reload&lt;/code&gt;, calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;, or using &lt;code&gt;kill -HUP&lt;/code&gt;) to make it re-read the file.</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; ののファイルが起動し、時にメインサーバプロセスがSIGHUP信号を受信した上で読み取られます。アクティブなシステムでファイルを編集する場合、（ &lt;code&gt;pg_ctl reload&lt;/code&gt; を使用 &lt;code&gt;kill -HUP&lt;/code&gt; か、SQL関数 &lt;code&gt;pg_reload_conf()&lt;/code&gt; を呼び出すか、またはkill -HUPを使用して）ポストマスターに信号を送り、ファイルを再読み取りさせる必要があります。</target>
        </trans-unit>
        <trans-unit id="04191b45aa50aed85c91e48e8294ab1b8975519d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ident.conf&lt;/code&gt; file is read on start-up and when the main server process receives a SIGHUP signal. If you edit the file on an active system, you will need to signal the postmaster (using &lt;code&gt;pg_ctl reload&lt;/code&gt;, calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;, or using &lt;code&gt;kill -HUP&lt;/code&gt;) to make it re-read the file.</source>
          <target state="translated">&lt;code&gt;pg_ident.conf&lt;/code&gt; ファイルが起動し、時にメインサーバプロセスがSIGHUP信号を受信した上で読み取られます。アクティブなシステムでファイルを編集する場合、（ &lt;code&gt;pg_ctl reload&lt;/code&gt; を使用 &lt;code&gt;kill -HUP&lt;/code&gt; か、SQL関数 &lt;code&gt;pg_reload_conf()&lt;/code&gt; を呼び出すか、またはkill -HUPを使用して）ポストマスターに信号を送り、ファイルを再読み取りさせる必要があります。</target>
        </trans-unit>
        <trans-unit id="27acedebfd1c20546e890a5790d75026d8a69e81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_locks&lt;/code&gt; view displays data from both the regular lock manager and the predicate lock manager, which are separate systems; in addition, the regular lock manager subdivides its locks into regular and &lt;em&gt;fast-path&lt;/em&gt; locks. This data is not guaranteed to be entirely consistent. When the view is queried, data on fast-path locks (with &lt;code&gt;fastpath&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt;) is gathered from each backend one at a time, without freezing the state of the entire lock manager, so it is possible for locks to be taken or released while information is gathered. Note, however, that these locks are known not to conflict with any other lock currently in place. After all backends have been queried for fast-path locks, the remainder of the regular lock manager is locked as a unit, and a consistent snapshot of all remaining locks is collected as an atomic action. After unlocking the regular lock manager, the predicate lock manager is similarly locked and all predicate locks are collected as an atomic action. Thus, with the exception of fast-path locks, each lock manager will deliver a consistent set of results, but as we do not lock both lock managers simultaneously, it is possible for locks to be taken or released after we interrogate the regular lock manager and before we interrogate the predicate lock manager.</source>
          <target state="translated">&lt;code&gt;pg_locks&lt;/code&gt; は別個のシステムである規則的なロック・マネージャと述語ロック・マネージャの両方からの表示データを、表示します。さらに、通常のロックマネージャーは、そのロックを通常のロックと&lt;em&gt;高速パス&lt;/em&gt;ロックに分割します。このデータが完全に一貫していることは保証されていません。ビューが照会されると、高速パスロックに関するデータ（ &lt;code&gt;fastpath&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; の場合)）は、各バックエンドから一度に1つずつ収集され、ロックマネージャー全体の状態を凍結しないため、情報の収集中にロックが取得または解放される可能性があります。ただし、これらのロックは、現在有効な他のロックと競合しないことがわかっていることに注意してください。すべてのバックエンドに高速パスロックのクエリが実行されると、通常のロックマネージャーの残りの部分が1つのユニットとしてロックされ、残りのすべてのロックの一貫したスナップショットがアトミックアクションとして収集されます。通常のロックマネージャーのロックを解除すると、述語ロックマネージャーも同様にロックされ、すべての述語ロックがアトミックアクションとして収集されます。したがって、高速パスロックを除いて、各ロックマネージャーは一貫した結果セットを提供しますが、両方のロックマネージャーを同時にロックしないため、通常のロックマネージャーに問い合わせた後、述語ロックマネージャーに問い合わせる前に、ロックが取得または解放される可能性があります。</target>
        </trans-unit>
        <trans-unit id="cc09426bbd89792d56d781e38f0585623a0a6b0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_lsn&lt;/code&gt; data type can be used to store LSN (Log Sequence Number) data which is a pointer to a location in the WAL. This type is a representation of &lt;code&gt;XLogRecPtr&lt;/code&gt; and an internal system type of PostgreSQL.</source>
          <target state="translated">&lt;code&gt;pg_lsn&lt;/code&gt; のデータ・タイプは、WALにおける位置へのポインタであるLSN（ログシーケンス番号）データを格納するために使用することができます。このタイプは、 &lt;code&gt;XLogRecPtr&lt;/code&gt; とPostgreSQLの内部システムタイプの表現です。</target>
        </trans-unit>
        <trans-unit id="2453f80583b015c097d94096a21e07fa08a7d653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_mcv_list_items&lt;/code&gt; function can be used like this:</source>
          <target state="translated">&lt;code&gt;pg_mcv_list_items&lt;/code&gt; の機能は次のように使用することができます。</target>
        </trans-unit>
        <trans-unit id="a0dd30f02c62fffd16e92aa745931812e6881ee7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_monitor&lt;/code&gt;, &lt;code&gt;pg_read_all_settings&lt;/code&gt;, &lt;code&gt;pg_read_all_stats&lt;/code&gt; and &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; roles are intended to allow administrators to easily configure a role for the purpose of monitoring the database server. They grant a set of common privileges allowing the role to read various useful configuration settings, statistics and other system information normally restricted to superusers.</source>
          <target state="translated">&lt;code&gt;pg_monitor&lt;/code&gt; 、 &lt;code&gt;pg_read_all_settings&lt;/code&gt; 、 &lt;code&gt;pg_read_all_stats&lt;/code&gt; と &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; 役割は、管理者が簡単にデータベースサーバを監視する目的のために役割を設定できるようにすることを意図しています。それらは、ロールがさまざまな有用な構成設定、統計、および通常スーパーユーザーに制限されているその他のシステム情報を読み取ることを可能にする一連の共通特権を付与します。</target>
        </trans-unit>
        <trans-unit id="a9d719c2beab0d60be72a57746a97a87438b5577" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_prepared_statements&lt;/code&gt; view displays all the prepared statements that are available in the current session. See &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; for more information about prepared statements.</source>
          <target state="translated">&lt;code&gt;pg_prepared_statements&lt;/code&gt; は、ディスプレイに、現在のセッションで使用可能なすべての準備された文を表示します。準備済みステートメントの詳細については、&lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6f0733b71ce39a3b0da7d8656a3e5bc9319c9957" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_prepared_statements&lt;/code&gt; view is read only.</source>
          <target state="translated">&lt;code&gt;pg_prepared_statements&lt;/code&gt; のビューは読み取り専用です。</target>
        </trans-unit>
        <trans-unit id="712cfe11a273eb23a78bfc37d1131dc7151bd1af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_prewarm&lt;/code&gt; module provides a convenient way to load relation data into either the operating system buffer cache or the PostgreSQL buffer cache. Prewarming can be performed manually using the &lt;code&gt;pg_prewarm&lt;/code&gt; function, or can be performed automatically by including &lt;code&gt;pg_prewarm&lt;/code&gt; in &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt;. In the latter case, the system will run a background worker which periodically records the contents of shared buffers in a file called &lt;code&gt;autoprewarm.blocks&lt;/code&gt; and will, using 2 background workers, reload those same blocks after a restart.</source>
          <target state="translated">&lt;code&gt;pg_prewarm&lt;/code&gt; のモジュールは、オペレーティング・システム・バッファ・キャッシュまたはPostgreSQLのバッファ・キャッシュのいずれかへの負荷関係データに便利な方法を提供します。事前ウォーミングは、 &lt;code&gt;pg_prewarm&lt;/code&gt; 関数を使用して手動で実行することも、&lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_librariesに&lt;/a&gt; &lt;code&gt;pg_prewarm&lt;/code&gt; を含めることで自動的に実行することもできます。後者の場合、システムは、 &lt;code&gt;autoprewarm.blocks&lt;/code&gt; というファイルに共有バッファーの内容を定期的に記録するバックグラウンドワーカーを実行し、2つのバックグラウンドワーカーを使用して、再起動後にこれらの同じブロックを再ロードします。</target>
        </trans-unit>
        <trans-unit id="ae5fc12234ea79efc44835461370ba2ea861b98c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_read_server_files&lt;/code&gt;, &lt;code&gt;pg_write_server_files&lt;/code&gt; and &lt;code&gt;pg_execute_server_program&lt;/code&gt; roles are intended to allow administrators to have trusted, but non-superuser, roles which are able to access files and run programs on the database server as the user the database runs as. As these roles are able to access any file on the server file system, they bypass all database-level permission checks when accessing files directly and they could be used to gain superuser-level access, therefore great care should be taken when granting these roles to users.</source>
          <target state="translated">&lt;code&gt;pg_read_server_files&lt;/code&gt; 、 &lt;code&gt;pg_write_server_files&lt;/code&gt; と &lt;code&gt;pg_execute_server_program&lt;/code&gt; の役割管理者が信頼していることができるように意図されていますが、ユーザーとしてデータベース・サーバー上のファイルにアクセスし、実行プログラムすることができます非スーパーユーザ、役割データベースの実行など。これらの役割はサーバーファイルシステム上の任意のファイルにアクセスできるため、ファイルに直接アクセスする場合はすべてのデータベースレベルの権限チェックをバイパスし、スーパーユーザーレベルのアクセス権を取得するために使用できるため、これらの役割を付与する場合は十分に注意する必要がありますユーザー。</target>
        </trans-unit>
        <trans-unit id="d4f7cb10a03b4cb92179c151a9345f858223dd84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_relation_filepath()&lt;/code&gt; function shows the entire path (relative to &lt;code&gt;PGDATA&lt;/code&gt;) of any relation. It is often useful as a substitute for remembering many of the above rules. But keep in mind that this function just gives the name of the first segment of the main fork of the relation &amp;mdash; you may need to append a segment number and/or &lt;code&gt;_fsm&lt;/code&gt;, &lt;code&gt;_vm&lt;/code&gt;, or &lt;code&gt;_init&lt;/code&gt; to find all the files associated with the relation.</source>
          <target state="translated">&lt;code&gt;pg_relation_filepath()&lt;/code&gt; 関数を示す（に相対パス全体 &lt;code&gt;PGDATA&lt;/code&gt; 任意関係）。多くの場合、上記のルールの多くを覚えておく代わりに役立ちます。ただし、この関数はリレーションのメインフォークの最初のセグメントの名前を与えるだけであることに注意してください。 &lt;code&gt;_vm&lt;/code&gt; に関連付けられているすべてのファイルを見つけるには、セグメント番号や &lt;code&gt;_fsm&lt;/code&gt; 、_vm、または &lt;code&gt;_init&lt;/code&gt; を追加する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="03e84c5eab2e8606b5c93d96958f3280a2a3feb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_replication_origin&lt;/code&gt; catalog contains all replication origins created. For more on replication origins see &lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_replication_origin&lt;/code&gt; のカタログが作成されたすべての複製起点を含んでいます。複製元の詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;第49章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="94519dfaf1a7e0c715cbe6d005de1e67132adafc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_replication_origin_status&lt;/code&gt; view contains information about how far replay for a certain origin has progressed. For more on replication origins see &lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_replication_origin_status&lt;/code&gt; のビューがはるかに進んでいる特定の起源のための再生方法に関する情報が含まれています。複製元の詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;第49章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6aff87cbf65850e431b7483477c97e1f7e57d54e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_replication_slots&lt;/code&gt; view provides a listing of all replication slots that currently exist on the database cluster, along with their current state.</source>
          <target state="translated">&lt;code&gt;pg_replication_slots&lt;/code&gt; のビューは現在、彼らの現在の状態と共に、データベースクラスタに存在するすべてのレプリケーション・スロットのリストを提供します。</target>
        </trans-unit>
        <trans-unit id="b0e21895d1c29cfa7bd5d292f490ca241b01ad9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_rules&lt;/code&gt; view excludes the &lt;code&gt;ON SELECT&lt;/code&gt; rules of views and materialized views; those can be seen in &lt;code&gt;pg_views&lt;/code&gt; and &lt;code&gt;pg_matviews&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_rules&lt;/code&gt; は除外表示 &lt;code&gt;ON SELECT&lt;/code&gt; は、ビュー規則およびマテリアライズド・ビュー。それらは &lt;code&gt;pg_views&lt;/code&gt; と &lt;code&gt;pg_matviews&lt;/code&gt; で見ることができます。</target>
        </trans-unit>
        <trans-unit id="b04c9372466f179b32ff250ffc0d648d21a6075f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_settings&lt;/code&gt; view cannot be inserted into or deleted from, but it can be updated. An &lt;code&gt;UPDATE&lt;/code&gt; applied to a row of &lt;code&gt;pg_settings&lt;/code&gt; is equivalent to executing the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; command on that named parameter. The change only affects the value used by the current session. If an &lt;code&gt;UPDATE&lt;/code&gt; is issued within a transaction that is later aborted, the effects of the &lt;code&gt;UPDATE&lt;/code&gt; command disappear when the transaction is rolled back. Once the surrounding transaction is committed, the effects will persist until the end of the session, unless overridden by another &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_settings&lt;/code&gt; のビューには挿入も削除しますが、更新することができますすることができません。 &lt;code&gt;UPDATE&lt;/code&gt; の行に適用 &lt;code&gt;pg_settings&lt;/code&gt; のは、実行したのと同じである&lt;a href=&quot;sql-set&quot;&gt;SETの&lt;/a&gt;その名前付きパラメータにコマンド。変更は、現在のセッションで使用されている値にのみ影響します。場合は &lt;code&gt;UPDATE&lt;/code&gt; が、後に中止されたトランザクション内で発行され、効果 &lt;code&gt;UPDATE&lt;/code&gt; コマンドは、トランザクションがロールバックされたときに消えます。周囲のトランザクションがコミットされると、別の &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;SET&lt;/code&gt; でオーバーライドされない限り、セッションの終わりまで効果が持続します。</target>
        </trans-unit>
        <trans-unit id="959ff59e7cb2ea926dc414727d1a287d75002cdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_signal_backend&lt;/code&gt; role is intended to allow administrators to enable trusted, but non-superuser, roles to send signals to other backends. Currently this role enables sending of signals for canceling a query on another backend or terminating its session. A user granted this role cannot however send signals to a backend owned by a superuser. See &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;Section 9.26.2&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_signal_backend&lt;/code&gt; の役割は、管理者が信頼可能にするためにできるようにすることを意図しているが、非スーパーユーザは、役割が他のバックエンドに信号を送信します。現在、この役割は、別のバックエンドでのクエリをキャンセルするか、そのセッションを終了するためのシグナルの送信を有効にします。ただし、この役割を付与されたユーザーは、スーパーユーザーが所有するバックエンドにシグナルを送信できません。&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;セクション9.26.2を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="364ec70800885a32c9b384791eb887b060833388" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_activity&lt;/code&gt; view will have one row per server process, showing information related to the current activity of that process.</source>
          <target state="translated">&lt;code&gt;pg_stat_activity&lt;/code&gt; ビューは、プロセスの現在の活動に関連した情報を示す、サーバプロセスごとに1つの行を有することになります。</target>
        </trans-unit>
        <trans-unit id="0d5cfe66d3c739cee322847b588c9d5b35df5eee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; view will contain one row for each index in the current database, showing statistics about accesses to that specific index. The &lt;code&gt;pg_stat_user_indexes&lt;/code&gt; and &lt;code&gt;pg_stat_sys_indexes&lt;/code&gt; views contain the same information, but filtered to only show user and system indexes respectively.</source>
          <target state="translated">&lt;code&gt;pg_stat_all_indexes&lt;/code&gt; のビューは、特定のインデックスへのアクセスに関する統計を示す、現在のデータベース内の各インデックスに対して1つの行を含むことになります。 &lt;code&gt;pg_stat_user_indexes&lt;/code&gt; と &lt;code&gt;pg_stat_sys_indexes&lt;/code&gt; ビューは、同じ情報を含むが、唯一それぞれユーザおよびシステムのインデックスを表示するように濾過しました。</target>
        </trans-unit>
        <trans-unit id="4915eaf62d5fac508cd463bbfeb67c5bc9a1f887" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_all_tables&lt;/code&gt; view will contain one row for each table in the current database (including TOAST tables), showing statistics about accesses to that specific table. The &lt;code&gt;pg_stat_user_tables&lt;/code&gt; and &lt;code&gt;pg_stat_sys_tables&lt;/code&gt; views contain the same information, but filtered to only show user and system tables respectively.</source>
          <target state="translated">&lt;code&gt;pg_stat_all_tables&lt;/code&gt; のビューは、特定のテーブルへのアクセスに関する統計を示し、（TOASTテーブルを含む）現在のデータベース内の各テーブルに対して1つの行を含むことになります。 &lt;code&gt;pg_stat_user_tables&lt;/code&gt; と &lt;code&gt;pg_stat_sys_tables&lt;/code&gt; ビューは、同じ情報を含むが、唯一のそれぞれのユーザとシステムテーブルを表示するために濾過しました。</target>
        </trans-unit>
        <trans-unit id="e920a84446b775991fa1eb14f7bc867a07c08969" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_archiver&lt;/code&gt; view will always have a single row, containing data about the archiver process of the cluster.</source>
          <target state="translated">&lt;code&gt;pg_stat_archiver&lt;/code&gt; のビューは常にクラスタのアーカイバ・プロセスに関するデータを含む、単一の行を有することになります。</target>
        </trans-unit>
        <trans-unit id="a1fdaad38e5659f088cd956997f18528cb8adec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_bgwriter&lt;/code&gt; view will always have a single row, containing global data for the cluster.</source>
          <target state="translated">&lt;code&gt;pg_stat_bgwriter&lt;/code&gt; のビューは常にクラスタのグローバルデータを含む、単一の行を有することになります。</target>
        </trans-unit>
        <trans-unit id="393da291bc9e23ea3e77a3450fa686048aaf2442" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_database&lt;/code&gt; view will contain one row for each database in the cluster, plus one for the shared objects, showing database-wide statistics.</source>
          <target state="translated">&lt;code&gt;pg_stat_database&lt;/code&gt; ビューは、データベース全体の統計を示す、クラスタ内の各データベースに対して1つの行を含む、プラス共有オブジェクトのための1つだろう。</target>
        </trans-unit>
        <trans-unit id="3c93e50dd3fc817fe9ad114869b45a8e9cc6f37d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; view will contain one row per database, showing database-wide statistics about query cancels occurring due to conflicts with recovery on standby servers. This view will only contain information on standby servers, since conflicts do not occur on master servers.</source>
          <target state="translated">&lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; が原因スタンバイサーバ上の回復との競合に発生したキャンセルするクエリについてのデータベース全体の統計情報を示す、データベースごとに1行が含まれています表示します。マスターサーバーでは競合が発生しないため、このビューにはスタンバイサーバーに関する情報のみが含まれます。</target>
        </trans-unit>
        <trans-unit id="9ca86aca5bdcd3b49612a77c80efa58451d60340" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_gssapi&lt;/code&gt; view will contain one row per backend, showing information about GSSAPI usage on this connection. It can be joined to &lt;code&gt;pg_stat_activity&lt;/code&gt; or &lt;code&gt;pg_stat_replication&lt;/code&gt; on the &lt;code&gt;pid&lt;/code&gt; column to get more details about the connection.</source>
          <target state="translated">&lt;code&gt;pg_stat_gssapi&lt;/code&gt; のビューは、この接続上でGSSAPIの使用状況に関する情報を示し、バックエンドごとに1行を含むことになります。これを &lt;code&gt;pid&lt;/code&gt; 列の &lt;code&gt;pg_stat_activity&lt;/code&gt; または &lt;code&gt;pg_stat_replication&lt;/code&gt; に結合して、接続に関する詳細を取得できます。</target>
        </trans-unit>
        <trans-unit id="1d861488085903be47118e7cb1eda5ee9716d20c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_replication&lt;/code&gt; view will contain one row per WAL sender process, showing statistics about replication to that sender's connected standby server. Only directly connected standbys are listed; no information is available about downstream standby servers.</source>
          <target state="translated">&lt;code&gt;pg_stat_replication&lt;/code&gt; のビューは、その送信者の接続スタンバイサーバへのレプリケーションに関する統計を示す、WAL送信者プロセスごとに1行が含まれます。直接接続されたスタンバイのみがリストされます。ダウンストリームスタンバイサーバーに関する情報はありません。</target>
        </trans-unit>
        <trans-unit id="4fc5431a476a7e29631b45416342385e30449578" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_ssl&lt;/code&gt; view will contain one row per backend or WAL sender process, showing statistics about SSL usage on this connection. It can be joined to &lt;code&gt;pg_stat_activity&lt;/code&gt; or &lt;code&gt;pg_stat_replication&lt;/code&gt; on the &lt;code&gt;pid&lt;/code&gt; column to get more details about the connection.</source>
          <target state="translated">&lt;code&gt;pg_stat_ssl&lt;/code&gt; のビューは、この接続上でSSLの使用状況に関する統計を示す、バックエンドまたはWAL送信者プロセスごとに1行が含まれます。これを &lt;code&gt;pid&lt;/code&gt; 列の &lt;code&gt;pg_stat_activity&lt;/code&gt; または &lt;code&gt;pg_stat_replication&lt;/code&gt; に結合して、接続に関する詳細を取得できます。</target>
        </trans-unit>
        <trans-unit id="daf211b37dbd6853dfd5eb7dd10c7c12b2c0042c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_statements&lt;/code&gt; module provides a means for tracking execution statistics of all SQL statements executed by a server.</source>
          <target state="translated">&lt;code&gt;pg_stat_statements&lt;/code&gt; ビューのモジュールは、サーバで実行されるすべてのSQL文の実行統計を追跡するための手段を提供します。</target>
        </trans-unit>
        <trans-unit id="98e909d7ac4e2a7927d69b3536cd3fab24324d97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_statements&lt;/code&gt; view is defined in terms of a function also named &lt;code&gt;pg_stat_statements&lt;/code&gt;. It is possible for clients to call the &lt;code&gt;pg_stat_statements&lt;/code&gt; function directly, and by specifying &lt;code&gt;showtext := false&lt;/code&gt; have query text be omitted (that is, the &lt;code&gt;OUT&lt;/code&gt; argument that corresponds to the view's &lt;code&gt;query&lt;/code&gt; column will return nulls). This feature is intended to support external tools that might wish to avoid the overhead of repeatedly retrieving query texts of indeterminate length. Such tools can instead cache the first query text observed for each entry themselves, since that is all &lt;code&gt;pg_stat_statements&lt;/code&gt; itself does, and then retrieve query texts only as needed. Since the server stores query texts in a file, this approach may reduce physical I/O for repeated examination of the &lt;code&gt;pg_stat_statements&lt;/code&gt; data.</source>
          <target state="translated">&lt;code&gt;pg_stat_statements&lt;/code&gt; ビューのビューは、指定された関数で定義されて &lt;code&gt;pg_stat_statements&lt;/code&gt; ビュー。クライアントが &lt;code&gt;pg_stat_statements&lt;/code&gt; 関数を直接呼び出し、 &lt;code&gt;showtext := false&lt;/code&gt; を指定することでクエリテキストを省略できます（つまり、ビューの &lt;code&gt;query&lt;/code&gt; 列に対応する &lt;code&gt;OUT&lt;/code&gt; 引数はnullを返します）。この機能は、長さが不定のクエリテキストを繰り返し取得するオーバーヘッドを回避したい外部ツールをサポートすることを目的としています。そのようなツールは、すべての &lt;code&gt;pg_stat_statements&lt;/code&gt; であるため、代わりに各エントリ自体で観察された最初のクエリテキストをキャッシュできます。それ自体が行い、必要に応じてのみクエリテキストを取得します。サーバーはクエリテキストをファイルに保存するため、このアプローチでは、 &lt;code&gt;pg_stat_statements&lt;/code&gt; データを繰り返し検査するための物理I / Oを削減できます。</target>
        </trans-unit>
        <trans-unit id="abb8ed00a27312be8d978730672b0b28bbcb5469" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_subscription&lt;/code&gt; view will contain one row per subscription for main worker (with null PID if the worker is not running), and additional rows for workers handling the initial data copy of the subscribed tables.</source>
          <target state="translated">&lt;code&gt;pg_stat_subscription&lt;/code&gt; の（労働者が実行されていない場合はnull PIDを持つ）ビューには、メインの労働者のためのサブスクリプションごとに1行が含まれます、初期データを扱う労働者のための追加の行は、サブスクライブテーブルのコピー。</target>
        </trans-unit>
        <trans-unit id="10b53f5c8cdaebaaf4ec10ef70cc41030a5f49c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_user_functions&lt;/code&gt; view will contain one row for each tracked function, showing statistics about executions of that function. The &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-FUNCTIONS&quot;&gt;track_functions&lt;/a&gt; parameter controls exactly which functions are tracked.</source>
          <target state="translated">&lt;code&gt;pg_stat_user_functions&lt;/code&gt; には、その関数の実行に関する統計を示す、各追跡機能のための一つの行を含むことになる表示します。&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-FUNCTIONS&quot;&gt;track_functions&lt;/a&gt;機能が追跡され、正確に制御するパラメータ。</target>
        </trans-unit>
        <trans-unit id="192cc2da4edef74cee3104eea30272179c17353c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_wal_receiver&lt;/code&gt; view will contain only one row, showing statistics about the WAL receiver from that receiver's connected server.</source>
          <target state="translated">&lt;code&gt;pg_stat_wal_receiver&lt;/code&gt; のビューは、その受信機の接続されているサーバからWAL受信機に関する統計を示す、1行しか含まれています。</target>
        </trans-unit>
        <trans-unit id="ccb7822cb6072c4067c2cc69eddb66f1fcb783d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statio_&lt;/code&gt; views are primarily useful to determine the effectiveness of the buffer cache. When the number of actual disk reads is much smaller than the number of buffer hits, then the cache is satisfying most read requests without invoking a kernel call. However, these statistics do not give the entire story: due to the way in which PostgreSQL handles disk I/O, data that is not in the PostgreSQL buffer cache might still reside in the kernel's I/O cache, and might therefore still be fetched without requiring a physical read. Users interested in obtaining more detailed information on PostgreSQL I/O behavior are advised to use the PostgreSQL statistics collector in combination with operating system utilities that allow insight into the kernel's handling of I/O.</source>
          <target state="translated">&lt;code&gt;pg_statio_&lt;/code&gt; のビューは、バッファ・キャッシュの有効性を決定するために、主に便利です。実際のディスク読み取りの数がバッファヒットの数よりもはるかに少ない場合、キャッシュはカーネルコールを呼び出さずにほとんどの読み取り要求を満たしています。ただし、これらの統計は全体を説明するものではありません。PostgreSQLがディスクI / Oを処理する方法のために、PostgreSQLバッファキャッシュにないデータは引き続きカーネルのI / Oキャッシュに存在する可能性があるため、引き続きフェッチされる可能性があります物理的な読み取りは必要ありません。 PostgreSQLのI / O動作に関するより詳細な情報の取得に関心のあるユーザーは、PostgreSQL統計コレクターをオペレーティングシステムのユーティリティと組み合わせて使用​​し、カーネルのI / Oの処理を洞察することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="4275ef4261b6d2382694080172180d4c6bb50fe7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statio_all_indexes&lt;/code&gt; view will contain one row for each index in the current database, showing statistics about I/O on that specific index. The &lt;code&gt;pg_statio_user_indexes&lt;/code&gt; and &lt;code&gt;pg_statio_sys_indexes&lt;/code&gt; views contain the same information, but filtered to only show user and system indexes respectively.</source>
          <target state="translated">&lt;code&gt;pg_statio_all_indexes&lt;/code&gt; は、その特定のインデックスにI / Oに関する統計を示す、現在のデータベース内の各インデックスに対して1つの行を含むことになる表示します。 &lt;code&gt;pg_statio_user_indexes&lt;/code&gt; と &lt;code&gt;pg_statio_sys_indexes&lt;/code&gt; ビューは、同じ情報を含むが、唯一それぞれユーザおよびシステムのインデックスを表示するように濾過しました。</target>
        </trans-unit>
        <trans-unit id="633f3d97ee7656ef624fbb5d36d3f8580d36168e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statio_all_sequences&lt;/code&gt; view will contain one row for each sequence in the current database, showing statistics about I/O on that specific sequence.</source>
          <target state="translated">&lt;code&gt;pg_statio_all_sequences&lt;/code&gt; は、その特定の配列にI / Oに関する統計を示す、現在のデータベース内の各列に対して1つの行を含むことになる表示します。</target>
        </trans-unit>
        <trans-unit id="c3f0cb49815d4460862c6bbe716f068280da5e1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statio_all_tables&lt;/code&gt; view will contain one row for each table in the current database (including TOAST tables), showing statistics about I/O on that specific table. The &lt;code&gt;pg_statio_user_tables&lt;/code&gt; and &lt;code&gt;pg_statio_sys_tables&lt;/code&gt; views contain the same information, but filtered to only show user and system tables respectively.</source>
          <target state="translated">&lt;code&gt;pg_statio_all_tables&lt;/code&gt; は、その特定のテーブルにI / Oに関する統計を示し、（TOASTテーブルを含む）現在のデータベース内の各テーブルに対して1つの行を含むことになる表示します。 &lt;code&gt;pg_statio_user_tables&lt;/code&gt; と &lt;code&gt;pg_statio_sys_tables&lt;/code&gt; ビューは、同じ情報を含むが、唯一のそれぞれのユーザとシステムテーブルを表示するために濾過しました。</target>
        </trans-unit>
        <trans-unit id="57e3b64868b02c0a85487789a181915c3308f04e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statistic_ext&lt;/code&gt; entry is filled in completely during &lt;code&gt;CREATE STATISTICS&lt;/code&gt;, but the actual statistical values are not computed then. Subsequent &lt;code&gt;ANALYZE&lt;/code&gt; commands compute the desired values and populate an entry in the &lt;a href=&quot;catalog-pg-statistic-ext-data&quot;&gt;&lt;code&gt;pg_statistic_ext_data&lt;/code&gt;&lt;/a&gt; catalog.</source>
          <target state="translated">&lt;code&gt;pg_statistic_ext&lt;/code&gt; エントリが完全に中に充填された &lt;code&gt;CREATE STATISTICS&lt;/code&gt; 、実際の統計値は、その後、計算されません。後続の &lt;code&gt;ANALYZE&lt;/code&gt; コマンドは目的の値を計算し、&lt;a href=&quot;catalog-pg-statistic-ext-data&quot;&gt; &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; &lt;/a&gt;カタログにエントリを入力します。</target>
        </trans-unit>
        <trans-unit id="4ab16db4ae44ab46362ea23499bbb4d24c58bacb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stop_backup&lt;/code&gt; will return one row with three values. The second of these fields should be written to a file named &lt;code&gt;backup_label&lt;/code&gt; in the root directory of the backup. The third field should be written to a file named &lt;code&gt;tablespace_map&lt;/code&gt; unless the field is empty. These files are vital to the backup working, and must be written without modification.</source>
          <target state="translated">&lt;code&gt;pg_stop_backup&lt;/code&gt; 三つの値と一列を返します。これらのフィールドの2番目は、バックアップのルートディレクトリにある &lt;code&gt;backup_label&lt;/code&gt; という名前のファイルに書き込む必要があります。 3番目のフィールドは、フィールドが空でない限り、 &lt;code&gt;tablespace_map&lt;/code&gt; という名前のファイルに書き込む必要があります。これらのファイルはバックアップの動作に不可欠であり、変更せずに書き込む必要があります。</target>
        </trans-unit>
        <trans-unit id="8ccb3d590fa85ee9247d7f4bf77a2f3efc4344c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_trgm&lt;/code&gt; module provides GiST and GIN index operator classes that allow you to create an index over a text column for the purpose of very fast similarity searches. These index types support the above-described similarity operators, and additionally support trigram-based index searches for &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;ILIKE&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt; queries. (These indexes do not support equality nor simple comparison operators, so you may need a regular B-tree index too.)</source>
          <target state="translated">&lt;code&gt;pg_trgm&lt;/code&gt; モジュールを使用すると、非常に高速な類似検索の目的のためのテキスト列の上にインデックスを作成することができるように、GiSTとGINインデックス演算子クラスを提供します。これらのインデックスタイプは、上記の類似性演算子をサポートし、さらに &lt;code&gt;LIKE&lt;/code&gt; 、 &lt;code&gt;ILIKE&lt;/code&gt; 、 &lt;code&gt;~&lt;/code&gt; および &lt;code&gt;~*&lt;/code&gt; クエリのトライグラムベースのインデックス検索をサポートします。（これらのインデックスは等値演算子も単純な比較演算子もサポートしていないため、通常のBツリーインデックスも必要になる場合があります。）</target>
        </trans-unit>
        <trans-unit id="fc7db08f494b7bd6b75737a77c0ee6584bbbf782" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_trgm&lt;/code&gt; module provides functions and operators for determining the similarity of alphanumeric text based on trigram matching, as well as index operator classes that support fast searching for similar strings.</source>
          <target state="translated">&lt;code&gt;pg_trgm&lt;/code&gt; モジュールは、トライグラムマッチングに基づいて英数字テキストの類似性を決定するための関数と演算子、および同様の文字列の高速検索をサポートするインデックス演算子クラスを提供します。</target>
        </trans-unit>
        <trans-unit id="0591f005154500c944add92ac3b7183691fb1ca4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_config&lt;/code&gt; catalog contains entries representing text search configurations. A configuration specifies a particular text search parser and a list of dictionaries to use for each of the parser's output token types. The parser is shown in the &lt;code&gt;pg_ts_config&lt;/code&gt; entry, but the token-to-dictionary mapping is defined by subsidiary entries in &lt;a href=&quot;catalog-pg-ts-config-map&quot;&gt;&lt;code&gt;pg_ts_config_map&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_ts_config&lt;/code&gt; のカタログは、テキスト検索設定を表すエントリが含まれています。構成では、特定のテキスト検索パーサーと、パーサーの各出力トークンタイプに使用する辞書のリストを指定します。パーサーは &lt;code&gt;pg_ts_config&lt;/code&gt; エントリに表示されますが、トークンから辞書へのマッピングは&lt;a href=&quot;catalog-pg-ts-config-map&quot;&gt; &lt;code&gt;pg_ts_config_map&lt;/code&gt; の&lt;/a&gt;補助的なエントリによって定義されます。</target>
        </trans-unit>
        <trans-unit id="ed3b9b0c162846ed7796c343a7cd6db3dce66f59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_config_map&lt;/code&gt; catalog contains entries showing which text search dictionaries should be consulted, and in what order, for each output token type of each text search configuration's parser.</source>
          <target state="translated">&lt;code&gt;pg_ts_config_map&lt;/code&gt; のカタログは、テキスト検索辞書は、各テキスト検索設定のパーサの各出力トークンタイプのために、相談し、どのような順序でされるべき示すエントリが含まれています。</target>
        </trans-unit>
        <trans-unit id="d1aa79ed96a9f64450a185ab7801c634f26ba881" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_dict&lt;/code&gt; catalog contains entries defining text search dictionaries. A dictionary depends on a text search template, which specifies all the implementation functions needed; the dictionary itself provides values for the user-settable parameters supported by the template. This division of labor allows dictionaries to be created by unprivileged users. The parameters are specified by a text string &lt;code&gt;dictinitoption&lt;/code&gt;, whose format and meaning vary depending on the template.</source>
          <target state="translated">&lt;code&gt;pg_ts_dict&lt;/code&gt; のカタログは、テキスト検索辞書を定義するエントリが含まれています。辞書は、必要なすべての実装機能を指定するテキスト検索テンプレートに依存しています。辞書自体は、テンプレートでサポートされているユーザー設定可能なパラメーターの値を提供します。この分業により、権限のないユーザーが辞書を作成できます。パラメータはテキスト文字列 &lt;code&gt;dictinitoption&lt;/code&gt; で指定されます。その形式と意味はテンプレートによって異なります。</target>
        </trans-unit>
        <trans-unit id="214cf3524f01d220fbc4c1ed75c24082b9d19637" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_parser&lt;/code&gt; catalog contains entries defining text search parsers. A parser is responsible for splitting input text into lexemes and assigning a token type to each lexeme. Since a parser must be implemented by C-language-level functions, creation of new parsers is restricted to database superusers.</source>
          <target state="translated">&lt;code&gt;pg_ts_parser&lt;/code&gt; のカタログは、テキスト検索パーサを定義するエントリが含まれています。パーサーは、入力テキストを語彙素に分割し、トークンタイプを各語彙素に割り当てます。パーサーはC言語レベルの関数で実装する必要があるため、新しいパーサーの作成はデータベースのスーパーユーザーに制限されています。</target>
        </trans-unit>
        <trans-unit id="cb87e8d8ef4d72f7f47347f20f99911a07cb666c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_template&lt;/code&gt; catalog contains entries defining text search templates. A template is the implementation skeleton for a class of text search dictionaries. Since a template must be implemented by C-language-level functions, creation of new templates is restricted to database superusers.</source>
          <target state="translated">&lt;code&gt;pg_ts_template&lt;/code&gt; のカタログは、テキスト検索テンプレートを定義するエントリが含まれています。テンプレートは、テキスト検索辞書のクラスの実装スケルトンです。テンプレートはC言語レベルの関数で実装する必要があるため、新しいテンプレートの作成はデータベースのスーパーユーザーに制限されています。</target>
        </trans-unit>
        <trans-unit id="98aec2c9411d89139f2d3f0f94ddaca8b8727976" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_visibility&lt;/code&gt; module provides a means for examining the visibility map (VM) and page-level visibility information of a table. It also provides functions to check the integrity of a visibility map and to force it to be rebuilt.</source>
          <target state="translated">&lt;code&gt;pg_visibility&lt;/code&gt; のモジュールは、可視性マップ（VM）とテーブルのページレベルの可視性情報を調べるための手段を提供します。また、可視性マップの整合性をチェックして強制的に再構築する機能も提供します。</target>
        </trans-unit>
        <trans-unit id="aebe4e3ccf987f601f3ce63d73da2ecfe326511d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pgcrypto&lt;/code&gt; module provides cryptographic functions for PostgreSQL.</source>
          <target state="translated">&lt;code&gt;pgcrypto&lt;/code&gt; のモジュールは、PostgreSQLの暗号化機能を提供します。</target>
        </trans-unit>
        <trans-unit id="7582806e57c12c2e0e98376d6a43f53ffd981a64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pgrowlocks&lt;/code&gt; module provides a function to show row locking information for a specified table.</source>
          <target state="translated">&lt;code&gt;pgrowlocks&lt;/code&gt; では用モジュールは、指定された表の行ロック情報を表示する機能を提供します。</target>
        </trans-unit>
        <trans-unit id="0aa04313fa7e95bfad5b3c29fac2331cea3b0811" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pgstattuple&lt;/code&gt; module provides various functions to obtain tuple-level statistics.</source>
          <target state="translated">&lt;code&gt;pgstattuple&lt;/code&gt; モジュールはタプルレベルの統計情報を取得するために、様々な機能を提供します。</target>
        </trans-unit>
        <trans-unit id="3550763c8f87c7c5071a2ae4590cbccf7d821554" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pid&lt;/code&gt; column can be joined to the &lt;code&gt;pid&lt;/code&gt; column of the &lt;a href=&quot;monitoring-stats#PG-STAT-ACTIVITY-VIEW&quot;&gt;&lt;code&gt;pg_stat_activity&lt;/code&gt;&lt;/a&gt; view to get more information on the session holding or awaiting each lock, for example</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 列がに接合することができる &lt;code&gt;pid&lt;/code&gt; の列&lt;a href=&quot;monitoring-stats#PG-STAT-ACTIVITY-VIEW&quot;&gt; &lt;code&gt;pg_stat_activity&lt;/code&gt; &lt;/a&gt;、例えば、各ロックを保持しているか、待ってセッションに関する詳細情報を取得するビュー</target>
        </trans-unit>
        <trans-unit id="1772c228a2ba486f02c419b09475ac82a8dda4c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;point&lt;/code&gt; type is an example of a PostgreSQL-specific data type.</source>
          <target state="translated">&lt;code&gt;point&lt;/code&gt; タイプは、PostgreSQL固有のデータ型の例です。</target>
        </trans-unit>
        <trans-unit id="6d33330f4a5a6a6e60ef800433563c926a762925" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;point&lt;/code&gt; type requires a coordinate pair as input, as shown here:</source>
          <target state="translated">次に示すように、 &lt;code&gt;point&lt;/code&gt; タイプには入力として座標ペアが必要です。</target>
        </trans-unit>
        <trans-unit id="5140039e3c9f8558e37b9c94c77a69208747ed9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres&lt;/code&gt; command can also be called in single-user mode. The primary use for this mode is during bootstrapping by &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;. Sometimes it is used for debugging or disaster recovery; note that running a single-user server is not truly suitable for debugging the server, since no realistic interprocess communication and locking will happen. When invoked in single-user mode from the shell, the user can enter queries and the results will be printed to the screen, but in a form that is more useful for developers than end users. In the single-user mode, the session user will be set to the user with ID 1, and implicit superuser powers are granted to this user. This user does not actually have to exist, so the single-user mode can be used to manually recover from certain kinds of accidental damage to the system catalogs.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; コマンドは、シングルユーザーモードで呼び出すことができます。このモードの主な用途は、&lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;によるブートストラップ中です。。デバッグや災害復旧に使用されることもあります。シングルユーザーサーバーを実行することは、サーバーのデバッグに真に適していません。現実的なプロセス間通信とロックが発生しないためです。シェルからシングルユーザーモードで呼び出されると、ユーザーはクエリを入力でき、結果は画面に出力されますが、エンドユーザーよりも開発者にとって便利な形式で表示されます。シングルユーザーモードでは、セッションユーザーはID 1のユーザーに設定され、暗黙的なスーパーユーザー権限がこのユーザーに付与されます。このユーザーは実際に存在する必要はないため、シングルユーザーモードを使用して、システムカタログへの特定の種類の偶発的な損傷から手動で回復できます。</target>
        </trans-unit>
        <trans-unit id="73edbc735e1da3f91be137ad83f38e16d0101877" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres&lt;/code&gt; database is also created when a database cluster is initialized. This database is meant as a default database for users and applications to connect to. It is simply a copy of &lt;code&gt;template1&lt;/code&gt; and can be dropped and recreated if necessary.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; データベースクラスタが初期化されるときに、データベースも作成されます。このデータベースは、ユーザーとアプリケーションが接続するためのデフォルトのデータベースとして意図されています。これは単に &lt;code&gt;template1&lt;/code&gt; のコピーであり、必要に応じて削除および再作成できます。</target>
        </trans-unit>
        <trans-unit id="6c82b8fca9884597f624dea1153620a237bd20b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres&lt;/code&gt; program also takes a number of other command-line options. For more information, see the &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; reference page and &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; プログラムは、他のコマンドラインオプションの数を取ります。詳細については、&lt;a href=&quot;app-postgres&quot;&gt;postgresの&lt;/a&gt;リファレンスページと&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7330a81519eca7bce15eddcdea10af1a633af88b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres&lt;/code&gt; server uses &lt;code&gt;SIGQUIT&lt;/code&gt; to tell subordinate server processes to terminate without normal cleanup. This signal &lt;em&gt;should not&lt;/em&gt; be used by users. It is also unwise to send &lt;code&gt;SIGKILL&lt;/code&gt; to a server process &amp;mdash; the main &lt;code&gt;postgres&lt;/code&gt; process will interpret this as a crash and will force all the sibling processes to quit as part of its standard crash-recovery procedure.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; サーバが使用しています &lt;code&gt;SIGQUIT&lt;/code&gt; を通常のクリーンアップせずに終了するには、下位サーバプロセスを伝えるために。この信号&lt;em&gt;は&lt;/em&gt;ユーザーが使用し&lt;em&gt;ない&lt;/em&gt;で&lt;em&gt;ください&lt;/em&gt;。 &lt;code&gt;SIGKILL&lt;/code&gt; をサーバープロセスに送信することも賢明ではありません。メインの &lt;code&gt;postgres&lt;/code&gt; プロセスはこれをクラッシュとして解釈し、すべての兄弟プロセスを標準のクラッシュ回復手順の一部として強制終了します。</target>
        </trans-unit>
        <trans-unit id="c92653f4d0fd5ea002d544c735e92bfa8e8c8314" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres_fdw&lt;/code&gt; module provides the foreign-data wrapper &lt;code&gt;postgres_fdw&lt;/code&gt;, which can be used to access data stored in external PostgreSQL servers.</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; のモジュールは外部データラッパを提供 &lt;code&gt;postgres_fdw&lt;/code&gt; 外部のPostgreSQLサーバに格納されたデータにアクセスするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="8e090ec42938a8e07ce95bbef3862c409a5d10ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgresql.conf&lt;/code&gt; file can also contain &lt;code&gt;include_dir&lt;/code&gt; directives, which specify an entire directory of configuration files to include. These look like</source>
          <target state="translated">&lt;code&gt;postgresql.conf&lt;/code&gt; ファイルには、 &lt;code&gt;include_dir&lt;/code&gt; ディレクティブも含めることができます。このディレクティブは、含める構成ファイルのディレクトリ全体を指定します。これらは次のようになります</target>
        </trans-unit>
        <trans-unit id="b3d5fb19af808b68f842086f75de8bd4758fc142" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;predicate&lt;/code&gt; allows you to specify an exclusion constraint on a subset of the table; internally this creates a partial index. Note that parentheses are required around the predicate.</source>
          <target state="translated">&lt;code&gt;predicate&lt;/code&gt; あなたがテーブルのサブセットに排他制約を指定することができます。内部的にこれは部分的なインデックスを作成します。述語の前後に括弧が必要であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1b637034a943affe6ee006c1f9d5b95a5ccbc7da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;psql&lt;/code&gt; program has a number of internal commands that are not SQL commands. They begin with the backslash character, &amp;ldquo;&lt;code&gt;\&lt;/code&gt;&amp;rdquo;. For example, you can get help on the syntax of various PostgreSQL SQL commands by typing:</source>
          <target state="translated">&lt;code&gt;psql&lt;/code&gt; プログラムは、SQLコマンドではありません内部コマンドの数を持っています。バックスラッシュ文字「 &lt;code&gt;\&lt;/code&gt; 」で始まります。たとえば、次のように入力すると、さまざまなPostgreSQL SQLコマンドの構文に関するヘルプを表示できます。</target>
        </trans-unit>
        <trans-unit id="2ce36c6cfc7d62a93cbf69277d65d4367aa5df13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quad_point_ops&lt;/code&gt;, &lt;code&gt;kd_point_ops&lt;/code&gt; and &lt;code&gt;poly_ops&lt;/code&gt; operator classes support the &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; ordering operator, which enables the k-nearest neighbor (&lt;code&gt;k-NN&lt;/code&gt;) search over indexed point or polygon data sets.</source>
          <target state="translated">&lt;code&gt;quad_point_ops&lt;/code&gt; 、 &lt;code&gt;kd_point_ops&lt;/code&gt; と &lt;code&gt;poly_ops&lt;/code&gt; オペレータクラスがサポートする &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; k近傍（可能順序演算子、 &lt;code&gt;k-NN&lt;/code&gt; ）インデックス付きの点やポリゴンデータセットを検索します。</target>
        </trans-unit>
        <trans-unit id="603e4354460ff268426362e0c3963c884ac4c1a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;random()&lt;/code&gt; function uses a simple linear congruential algorithm. It is fast but not suitable for cryptographic applications; see the &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; module for a more secure alternative. If &lt;code&gt;setseed()&lt;/code&gt; is called, the results of subsequent &lt;code&gt;random()&lt;/code&gt; calls in the current session are repeatable by re-issuing &lt;code&gt;setseed()&lt;/code&gt; with the same argument.</source>
          <target state="translated">&lt;code&gt;random()&lt;/code&gt; 関数は、合同アルゴリズム線形シンプルを使用しています。高速ですが、暗号化アプリケーションには適していません。より安全な代替策については、&lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt;モジュールを参照してください。 &lt;code&gt;setseed()&lt;/code&gt; が呼び出された場合、現在のセッションでの後続の &lt;code&gt;random()&lt;/code&gt; 呼び出しの結果は、同じ引数で &lt;code&gt;setseed()&lt;/code&gt; を再発行することで再現できます。</target>
        </trans-unit>
        <trans-unit id="0231cb3d8ce00a0c5b86b501f35685f87444ba0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;random&lt;/code&gt; function generates values using a uniform distribution, that is all the values are drawn within the specified range with equal probability. The &lt;code&gt;random_exponential&lt;/code&gt;, &lt;code&gt;random_gaussian&lt;/code&gt; and &lt;code&gt;random_zipfian&lt;/code&gt; functions require an additional double parameter which determines the precise shape of the distribution.</source>
          <target state="translated">&lt;code&gt;random&lt;/code&gt; 関数は、すべての値が等しい確率で指定された範囲内に描画された均一な分布を使用して値を生成します。 &lt;code&gt;random_exponential&lt;/code&gt; 、 &lt;code&gt;random_gaussian&lt;/code&gt; と &lt;code&gt;random_zipfian&lt;/code&gt; 機能は、分布の正確な形状を決定する追加の二重パラメータを必要とします。</target>
        </trans-unit>
        <trans-unit id="9c090601f4f464e87f2fbb4f8206fe29858dd81d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_match&lt;/code&gt; function returns a text array of captured substring(s) resulting from the first match of a POSIX regular expression pattern to a string. It has the syntax &lt;code&gt;regexp_match&lt;/code&gt;(&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). If there is no match, the result is &lt;code&gt;NULL&lt;/code&gt;. If a match is found, and the &lt;code&gt;pattern&lt;/code&gt; contains no parenthesized subexpressions, then the result is a single-element text array containing the substring matching the whole pattern. If a match is found, and the &lt;code&gt;pattern&lt;/code&gt; contains parenthesized subexpressions, then the result is a text array whose &lt;code&gt;n&lt;/code&gt;'th element is the substring matching the &lt;code&gt;n&lt;/code&gt;'th parenthesized subexpression of the &lt;code&gt;pattern&lt;/code&gt; (not counting &amp;ldquo;non-capturing&amp;rdquo; parentheses; see below for details). The &lt;code&gt;flags&lt;/code&gt; parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. Supported flags are described in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;regexp_match&lt;/code&gt; 機能は、キャプチャ文字列にPOSIX正規表現パターンの最初の一致に起因する（複数の）サブストリングのテキスト配列を返します。構文は &lt;code&gt;regexp_match&lt;/code&gt; （ &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;pattern&lt;/code&gt; [、 &lt;code&gt;flags&lt;/code&gt; ]）です。一致しない場合、結果は &lt;code&gt;NULL&lt;/code&gt; になります。一致が見つかり、 &lt;code&gt;pattern&lt;/code&gt; に括弧で囲まれた部分式が含まれていない場合、結果は、パターン全体に一致する部分文字列を含む単一要素のテキスト配列になります。一致が見つかり、 &lt;code&gt;pattern&lt;/code&gt; に括弧で囲まれた部分式が含まれる場合、結果は &lt;code&gt;n&lt;/code&gt; 番目の要素が &lt;code&gt;n&lt;/code&gt; に一致する部分文字列であるテキスト配列になります。括弧で囲まれた &lt;code&gt;pattern&lt;/code&gt; サブ式（「非キャプチャ」括弧は数えません。詳細は以下を参照してください）。 &lt;code&gt;flags&lt;/code&gt; パラメータは、関数の動作を変更するゼロ個以上の単一文字フラグを含むオプションのテキスト文字列です。サポートされるフラグについては、&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;表9.23で&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="91a9d1b88379c50aed0c3fa7f79c63d3f93f4473" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_matches&lt;/code&gt; function returns a set of text arrays of captured substring(s) resulting from matching a POSIX regular expression pattern to a string. It has the same syntax as &lt;code&gt;regexp_match&lt;/code&gt;. This function returns no rows if there is no match, one row if there is a match and the &lt;code&gt;g&lt;/code&gt; flag is not given, or &lt;code&gt;N&lt;/code&gt; rows if there are &lt;code&gt;N&lt;/code&gt; matches and the &lt;code&gt;g&lt;/code&gt; flag is given. Each returned row is a text array containing the whole matched substring or the substrings matching parenthesized subexpressions of the &lt;code&gt;pattern&lt;/code&gt;, just as described above for &lt;code&gt;regexp_match&lt;/code&gt;. &lt;code&gt;regexp_matches&lt;/code&gt; accepts all the flags shown in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;, plus the &lt;code&gt;g&lt;/code&gt; flag which commands it to return all matches, not just the first one.</source>
          <target state="translated">&lt;code&gt;regexp_matches&lt;/code&gt; は、戻り捕捉文字列にPOSIX正規表現パターンに一致するから生じる（単数または複数）をサブストリングの文字列のセットを機能します。構文は &lt;code&gt;regexp_match&lt;/code&gt; と同じです。一致がない場合が一致であるとする場合、この機能は、一つの行を行を戻さない &lt;code&gt;g&lt;/code&gt; フラグが与えられ、またはされていない &lt;code&gt;N&lt;/code&gt; 個ある場合の行は &lt;code&gt;N&lt;/code&gt; 一致すると &lt;code&gt;g&lt;/code&gt; フラグが指定されます。返された各行は、 &lt;code&gt;regexp_match&lt;/code&gt; について前述したように、一致した部分文字列全体、または &lt;code&gt;pattern&lt;/code&gt; 括弧で囲まれた部分式に一致する部分文字列を含むテキスト配列です。 &lt;code&gt;regexp_matches&lt;/code&gt; は、次に示すすべてのフラグを受け入れます&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;表9.23&lt;/a&gt;と、最初の一致だけでなく、すべての一致を返すように指示する &lt;code&gt;g&lt;/code&gt; フラグ。</target>
        </trans-unit>
        <trans-unit id="a1d960616f19511c8709605bafb8561fb42fd92d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_replace&lt;/code&gt; function provides substitution of new text for substrings that match POSIX regular expression patterns. It has the syntax &lt;code&gt;regexp_replace&lt;/code&gt;(&lt;code&gt;source&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt;, &lt;code&gt;replacement&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). The &lt;code&gt;source&lt;/code&gt; string is returned unchanged if there is no match to the &lt;code&gt;pattern&lt;/code&gt;. If there is a match, the &lt;code&gt;source&lt;/code&gt; string is returned with the &lt;code&gt;replacement&lt;/code&gt; string substituted for the matching substring. The &lt;code&gt;replacement&lt;/code&gt; string can contain &lt;code&gt;\&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is 1 through 9, to indicate that the source substring matching the &lt;code&gt;n&lt;/code&gt;'th parenthesized subexpression of the pattern should be inserted, and it can contain &lt;code&gt;\&amp;amp;&lt;/code&gt; to indicate that the substring matching the entire pattern should be inserted. Write &lt;code&gt;\\&lt;/code&gt; if you need to put a literal backslash in the replacement text. The &lt;code&gt;flags&lt;/code&gt; parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. Flag &lt;code&gt;i&lt;/code&gt; specifies case-insensitive matching, while flag &lt;code&gt;g&lt;/code&gt; specifies replacement of each matching substring rather than only the first one. Supported flags (though not &lt;code&gt;g&lt;/code&gt;) are described in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;regexp_replace&lt;/code&gt; 機能は、POSIX正規表現パターンに一致するサブストリングのための新しいテキストの置換を提供します。構文は &lt;code&gt;regexp_replace&lt;/code&gt; （ &lt;code&gt;source&lt;/code&gt; 、 &lt;code&gt;pattern&lt;/code&gt; 、 &lt;code&gt;replacement&lt;/code&gt; [、 &lt;code&gt;flags&lt;/code&gt; ]）です。 &lt;code&gt;source&lt;/code&gt; に一致するものがない場合は文字列がそのまま返される &lt;code&gt;pattern&lt;/code&gt; 。一致がある場合、 &lt;code&gt;source&lt;/code&gt; 文字列がで返される &lt;code&gt;replacement&lt;/code&gt; マッチングストリングを置換ストリング。 &lt;code&gt;replacement&lt;/code&gt; 文字列を含めることができます &lt;code&gt;\&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; は、 &lt;code&gt;n&lt;/code&gt; 個のは、パターンの &lt;code&gt;n&lt;/code&gt; 番目の括弧で囲まれた部分式に一致するソース部分文字列を挿入する必要があることを示す1〜9であり、パターン全体に一致する部分文字列を挿入する必要があることを示す &lt;code&gt;\&amp;amp;&lt;/code&gt; を含めることができます。書く &lt;code&gt;\\&lt;/code&gt; あなたは置換テキストにリテラルのバックスラッシュを配置する必要があります。 &lt;code&gt;flags&lt;/code&gt; パラメータは、関数の動作を変更するゼロ個以上の単一文字フラグを含むオプションのテキスト文字列です。フラグ &lt;code&gt;i&lt;/code&gt; は大文字と小文字を区別しないマッチングを指定し、フラグ &lt;code&gt;g&lt;/code&gt; は最初のサブストリングだけでなく、一致する各サブストリングの置換を指定します。サポートされているフラグ（ &lt;code&gt;g&lt;/code&gt; は&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;除く&lt;/a&gt;）を表9.23に示します。</target>
        </trans-unit>
        <trans-unit id="2c5dbc2991320b01f06b6978f16f854503224464" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_split_to_array&lt;/code&gt; function behaves the same as &lt;code&gt;regexp_split_to_table&lt;/code&gt;, except that &lt;code&gt;regexp_split_to_array&lt;/code&gt; returns its result as an array of &lt;code&gt;text&lt;/code&gt;. It has the syntax &lt;code&gt;regexp_split_to_array&lt;/code&gt;(&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). The parameters are the same as for &lt;code&gt;regexp_split_to_table&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;regexp_split_to_array&lt;/code&gt; 関数はと同じように動作 &lt;code&gt;regexp_split_to_table&lt;/code&gt; ことを除いて、 &lt;code&gt;regexp_split_to_array&lt;/code&gt; が配列としてその結果を返す &lt;code&gt;text&lt;/code&gt; 。構文は &lt;code&gt;regexp_split_to_array&lt;/code&gt; （ &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;pattern&lt;/code&gt; [、 &lt;code&gt;flags&lt;/code&gt; ]）です。パラメータは &lt;code&gt;regexp_split_to_table&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="8a5d6df08eb9f63de1570ffdc8142a19efaaf0c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_split_to_table&lt;/code&gt; function splits a string using a POSIX regular expression pattern as a delimiter. It has the syntax &lt;code&gt;regexp_split_to_table&lt;/code&gt;(&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). If there is no match to the &lt;code&gt;pattern&lt;/code&gt;, the function returns the &lt;code&gt;string&lt;/code&gt;. If there is at least one match, for each match it returns the text from the end of the last match (or the beginning of the string) to the beginning of the match. When there are no more matches, it returns the text from the end of the last match to the end of the string. The &lt;code&gt;flags&lt;/code&gt; parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. &lt;code&gt;regexp_split_to_table&lt;/code&gt; supports the flags described in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;regexp_split_to_table&lt;/code&gt; 機能は、区切り文字としてPOSIX正規表現パターンを使用して文字列を分割します。構文は &lt;code&gt;regexp_split_to_table&lt;/code&gt; （ &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;pattern&lt;/code&gt; [、 &lt;code&gt;flags&lt;/code&gt; ]）です。 &lt;code&gt;pattern&lt;/code&gt; に一致しない場合、関数は &lt;code&gt;string&lt;/code&gt; 返します。少なくとも1つの一致がある場合、一致ごとに、最後の一致の最後（または文字列の先頭）から一致の先頭までのテキストを返します。一致するものがなくなると、最後の一致の終わりから文字列の終わりまでのテキストを返します。 &lt;code&gt;flags&lt;/code&gt; パラメータは、関数の動作を変更するゼロ個以上の1文字のフラグを含むオプションのテキスト文字列です。 &lt;code&gt;regexp_split_to_table&lt;/code&gt; は、&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;表9.23で&lt;/a&gt;説明されているフラグをサポートしています。</target>
        </trans-unit>
        <trans-unit id="9e8de7218b8205a5ca7a11a8952394be28359d1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rejectlong&lt;/code&gt; parameter specifies whether an overlength integer should be truncated or ignored. If &lt;code&gt;rejectlong&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), the dictionary returns the first &lt;code&gt;maxlen&lt;/code&gt; digits of the integer. If &lt;code&gt;rejectlong&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the dictionary treats an overlength integer as a stop word, so that it will not be indexed. Note that this also means that such an integer cannot be searched for.</source>
          <target state="translated">&lt;code&gt;rejectlong&lt;/code&gt; 桁数を超える整数を切り詰めるか無視するかどうかのパラメータを指定します。もし &lt;code&gt;rejectlong&lt;/code&gt; がある &lt;code&gt;false&lt;/code&gt; （デフォルト）、辞書を返す最初 &lt;code&gt;maxlen&lt;/code&gt; 整数の桁数。もし &lt;code&gt;rejectlong&lt;/code&gt; がある &lt;code&gt;true&lt;/code&gt; それがインデックス化されないように、辞書扱いストップワードとして過剰長整数。これは、そのような整数を検索できないことも意味することに注意してください。</target>
        </trans-unit>
        <trans-unit id="5f7fc02f4398b9958b820fde1c0031fecdf666d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rows&lt;/code&gt; value is a little tricky because it is not the number of rows processed or scanned by the plan node, but rather the number emitted by the node. This is often less than the number scanned, as a result of filtering by any &lt;code&gt;WHERE&lt;/code&gt;-clause conditions that are being applied at the node. Ideally the top-level rows estimate will approximate the number of rows actually returned, updated, or deleted by the query.</source>
          <target state="translated">&lt;code&gt;rows&lt;/code&gt; が計画ノードによって処理またはスキャン行の数ではなく、ノードによって放出された番号ではないので、値は少しトリッキーです。これは、ノードで適用されている &lt;code&gt;WHERE&lt;/code&gt; 句の条件によるフィルタリングの結果として、スキャンされた数よりも少ないことがよくあります。理想的には、最上位の行の見積もりは、クエリによって実際に返された、更新された、または削除された行数とほぼ同じになります。</target>
        </trans-unit>
        <trans-unit id="32edd13f077af046b2b71b1ee64a9b61285ac864" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;seg&lt;/code&gt; module includes a GiST index operator class for &lt;code&gt;seg&lt;/code&gt; values. The operators supported by the GiST operator class are shown in &lt;a href=&quot;seg#SEG-GIST-OPERATORS&quot;&gt;Table F.28&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;seg&lt;/code&gt; モジュール用のGiSTインデックス演算子クラス含む &lt;code&gt;seg&lt;/code&gt; 値。GiST演算子クラスでサポートされる演算子を&lt;a href=&quot;seg#SEG-GIST-OPERATORS&quot;&gt;表F.28に&lt;/a&gt;示します。</target>
        </trans-unit>
        <trans-unit id="060f961f6a4bd265394e2d5e72b7544d4d3d9777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;session_user&lt;/code&gt; is normally the user who initiated the current database connection; but superusers can change this setting with &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt;. The &lt;code&gt;current_user&lt;/code&gt; is the user identifier that is applicable for permission checking. Normally it is equal to the session user, but it can be changed with &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;. It also changes during the execution of functions with the attribute &lt;code&gt;SECURITY DEFINER&lt;/code&gt;. In Unix parlance, the session user is the &amp;ldquo;real user&amp;rdquo; and the current user is the &amp;ldquo;effective user&amp;rdquo;. &lt;code&gt;current_role&lt;/code&gt; and &lt;code&gt;user&lt;/code&gt; are synonyms for &lt;code&gt;current_user&lt;/code&gt;. (The SQL standard draws a distinction between &lt;code&gt;current_role&lt;/code&gt; and &lt;code&gt;current_user&lt;/code&gt;, but PostgreSQL does not, since it unifies users and roles into a single kind of entity.)</source>
          <target state="translated">&lt;code&gt;session_user&lt;/code&gt; 通常、現在のデータベース接続を開始したユーザーです。ただし、スーパーユーザーは&lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATIONを使用&lt;/a&gt;してこの設定を変更できます。 &lt;code&gt;current_user&lt;/code&gt; 権限の検査に適用されるユーザ識別子です。通常はセッションユーザーと同じですが、&lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;で変更できます。また、属性 &lt;code&gt;SECURITY DEFINER&lt;/code&gt; を持つ関数の実行中にも変更されます。 Unixの用語では、セッションユーザーは「実際のユーザー」であり、現在のユーザーは「有効なユーザー」です。 &lt;code&gt;current_role&lt;/code&gt; と &lt;code&gt;user&lt;/code&gt; は、 &lt;code&gt;current_user&lt;/code&gt; の同義語です。 （SQL標準では、 &lt;code&gt;current_role&lt;/code&gt; を区別しています。と &lt;code&gt;current_user&lt;/code&gt; ですが、PostgreSQLはそうではありません。ユーザーとロールを単一の種類のエンティティに統合するためです。）</target>
        </trans-unit>
        <trans-unit id="2300a7ac4740013d2132caac3afdd183cf0cf9ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sestatus&lt;/code&gt; command allows you to check the status of SELinux. A typical display is:</source>
          <target state="translated">&lt;code&gt;sestatus&lt;/code&gt; のコマンドは、SELinuxのステータスを確認することができます。一般的な表示は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="8c1528675485f3ac22728a56ac6684f04d6015ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shutdown&lt;/code&gt; setting is useful to have the instance ready at the exact replay point desired. The instance will still be able to replay more WAL records (and in fact will have to replay WAL records since the last checkpoint next time it is started).</source>
          <target state="translated">&lt;code&gt;shutdown&lt;/code&gt; 設定は、所望の正確な再生時点でインスタンスの準備ができていることが有用です。インスタンスはさらに多くのWALレコードを再生できます（実際には、次回の起動時の最後のチェックポイント以降、WALレコードを再生する必要があります）。</target>
        </trans-unit>
        <trans-unit id="0dfff4474b03b711fe3d607009c52f929707603f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;simple&lt;/code&gt; dictionary template operates by converting the input token to lower case and checking it against a file of stop words. If it is found in the file then an empty array is returned, causing the token to be discarded. If not, the lower-cased form of the word is returned as the normalized lexeme. Alternatively, the dictionary can be configured to report non-stop-words as unrecognized, allowing them to be passed on to the next dictionary in the list.</source>
          <target state="translated">&lt;code&gt;simple&lt;/code&gt; 辞書テンプレートは小文字に入力トークンを変換し、ストップワードのファイルに対してそれをチェックすることによって動作します。ファイルで見つかった場合、空の配列が返され、トークンが破棄されます。そうでない場合、単語の小文字の形が正規化された語彙素として返されます。または、ストップワード以外の単語を認識できないものとして報告するように辞書を設定して、リスト内の次の辞書に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="261a0b38493fc85b48b40ee18eb66df54582ef51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;soundex&lt;/code&gt; function converts a string to its Soundex code. The &lt;code&gt;difference&lt;/code&gt; function converts two strings to their Soundex codes and then reports the number of matching code positions. Since Soundex codes have four characters, the result ranges from zero to four, with zero being no match and four being an exact match. (Thus, the function is misnamed &amp;mdash; &lt;code&gt;similarity&lt;/code&gt; would have been a better name.)</source>
          <target state="translated">&lt;code&gt;soundex&lt;/code&gt; 関数は、そののSoundexコードに文字列を変換します。 &lt;code&gt;difference&lt;/code&gt; 関数は、それらのSoundexコードに2つの文字列を変換して照合コード位置の数を報告します。 Soundexコードは4文字であるため、結果の範囲は0〜4で、0は一致なし、4は完全一致です。 （したがって、関数の名前は間違っています。 &lt;code&gt;similarity&lt;/code&gt; の方が適切な名前でした。）</target>
        </trans-unit>
        <trans-unit id="09ea80f1981124188490dc9028b6ab305b1bc451" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sql_standard&lt;/code&gt; style produces output that conforms to the SQL standard's specification for interval literal strings, if the interval value meets the standard's restrictions (either year-month only or day-time only, with no mixing of positive and negative components). Otherwise the output looks like a standard year-month literal string followed by a day-time literal string, with explicit signs added to disambiguate mixed-sign intervals.</source>
          <target state="translated">&lt;code&gt;sql_standard&lt;/code&gt; 間隔値（正と負の要素の無い混合しながら、唯一の唯一の年、月、日、時間のいずれか、）標準の制限を満たしている場合、スタイルは、間隔リテラル文字列のSQL標準の仕様に準拠していることを出力を生成します。それ以外の場合、出力は標準の年月リテラル文字列とそれに続く日時間リテラル文字列のようになり、混合符号の間隔を明確にするために明示的な符号が追加されます。</target>
        </trans-unit>
        <trans-unit id="7f1517c885d0f9ba998151ca37f036c0bd997847" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sslinfo&lt;/code&gt; module provides information about the SSL certificate that the current client provided when connecting to PostgreSQL. The module is useless (most functions will return NULL) if the current connection does not use SSL.</source>
          <target state="translated">&lt;code&gt;sslinfo&lt;/code&gt; のモジュールは、PostgreSQLに接続する際に現在のクライアントが提供するSSL証明書に関する情報を提供します。現在の接続でSSLが使用されていない場合、モジュールは役に立ちません（ほとんどの関数はNULLを返します）。</target>
        </trans-unit>
        <trans-unit id="0d9a65154d6a387434a029c400053d901ea5349c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;storage&lt;/code&gt; parameter allows selection of storage strategies for variable-length data types. (Only &lt;code&gt;plain&lt;/code&gt; is allowed for fixed-length types.) &lt;code&gt;plain&lt;/code&gt; specifies that data of the type will always be stored in-line and not compressed. &lt;code&gt;extended&lt;/code&gt; specifies that the system will first try to compress a long data value, and will move the value out of the main table row if it's still too long. &lt;code&gt;external&lt;/code&gt; allows the value to be moved out of the main table, but the system will not try to compress it. &lt;code&gt;main&lt;/code&gt; allows compression, but discourages moving the value out of the main table. (Data items with this storage strategy might still be moved out of the main table if there is no other way to make a row fit, but they will be kept in the main table preferentially over &lt;code&gt;extended&lt;/code&gt; and &lt;code&gt;external&lt;/code&gt; items.)</source>
          <target state="translated">&lt;code&gt;storage&lt;/code&gt; パラメータは、可変長データ型を格納する際の戦略を選択することができます。 （固定長の型には &lt;code&gt;plain&lt;/code&gt; のみが許可されます。） &lt;code&gt;plain&lt;/code&gt; は、そのタイプのデータが常にインラインで格納され、圧縮されないことを指定します。 &lt;code&gt;extended&lt;/code&gt; は、システムが長いデータ値を最初に圧縮しようとし、それがまだ長すぎる場合、値をメインテーブル行から移動することを指定します。 &lt;code&gt;external&lt;/code&gt; は、値をメインテーブルから移動できますが、システムはそれを圧縮しようとしません。 &lt;code&gt;main&lt;/code&gt; 圧縮を許可しますが、値をメインテーブルの外に移動しないようにします。（行をフィットさせる方法が他にない場合、このストレージ戦略のデータアイテムはメインテーブルから移動される可能性がありますが、 &lt;code&gt;extended&lt;/code&gt; アイテムおよび &lt;code&gt;external&lt;/code&gt; アイテムよりも優先的にメインテーブルに保持されます。）</target>
        </trans-unit>
        <trans-unit id="17d900c212bdba8eb8ed8106792c420e1bbe3e14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;substring&lt;/code&gt; function with three parameters provides extraction of a substring that matches an SQL regular expression pattern. The function can be written according to SQL99 syntax:</source>
          <target state="translated">&lt;code&gt;substring&lt;/code&gt; 三つのパラメータを持つ関数は、SQL正規表現パターンに一致するサブストリングの抽出を提供します。関数はSQL99構文に従って記述できます。</target>
        </trans-unit>
        <trans-unit id="07c583000c12edad2a23f1677f8c511b9802bf22" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;substring&lt;/code&gt; function with two parameters, &lt;code&gt;substring(string from pattern)&lt;/code&gt;, provides extraction of a substring that matches a POSIX regular expression pattern. It returns null if there is no match, otherwise the portion of the text that matched the pattern. But if the pattern contains any parentheses, the portion of the text that matched the first parenthesized subexpression (the one whose left parenthesis comes first) is returned. You can put parentheses around the whole expression if you want to use parentheses within it without triggering this exception. If you need parentheses in the pattern before the subexpression you want to extract, see the non-capturing parentheses described below.</source>
          <target state="translated">&lt;code&gt;substring&lt;/code&gt; 二つのパラメータを持つ関数、 &lt;code&gt;substring(string from pattern)&lt;/code&gt; 、POSIX正規表現パターンに一致するサブストリングの抽出を提供します。一致しない場合はnullを返し、それ以外の場合はパターンに一致したテキストの部分を返します。ただし、パターンに括弧が含まれている場合は、括弧で囲まれた最初の部分式（左括弧が最初に来る部分）に一致したテキストの部分が返されます。この例外をトリガーせずに式内で括弧を使用する場合は、式全体を括弧で囲むことができます。抽出する部分式の前のパターンに括弧が必要な場合は、以下で説明する非キャプチャ括弧を参照してください。</target>
        </trans-unit>
        <trans-unit id="3c6de727710530de8b72a4404a0cd48c771eb547" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;synonym&lt;/code&gt; template also has an optional parameter &lt;code&gt;CaseSensitive&lt;/code&gt;, which defaults to &lt;code&gt;false&lt;/code&gt;. When &lt;code&gt;CaseSensitive&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, words in the synonym file are folded to lower case, as are input tokens. When it is &lt;code&gt;true&lt;/code&gt;, words and tokens are not folded to lower case, but are compared as-is.</source>
          <target state="translated">&lt;code&gt;synonym&lt;/code&gt; テンプレートは、オプションのパラメータがある &lt;code&gt;CaseSensitive&lt;/code&gt; 、デフォルト &lt;code&gt;false&lt;/code&gt; 。ときに &lt;code&gt;CaseSensitive&lt;/code&gt; ある &lt;code&gt;false&lt;/code&gt; 、同義語ファイル内の単語をトークンとして入力され、小文字に折り畳まれます。 &lt;code&gt;true&lt;/code&gt; の場合、単語とトークンは小文字に変換されませんが、そのまま比較されます。</target>
        </trans-unit>
        <trans-unit id="c07e672b3264d398cb9ebee058a21feb90ad8f52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;table_len&lt;/code&gt; will always be greater than the sum of the &lt;code&gt;tuple_len&lt;/code&gt;, &lt;code&gt;dead_tuple_len&lt;/code&gt; and &lt;code&gt;free_space&lt;/code&gt;. The difference is accounted for by fixed page overhead, the per-page table of pointers to tuples, and padding to ensure that tuples are correctly aligned.</source>
          <target state="translated">&lt;code&gt;table_len&lt;/code&gt; はいつもの合計よりも大きくなります &lt;code&gt;tuple_len&lt;/code&gt; 、 &lt;code&gt;dead_tuple_len&lt;/code&gt; と &lt;code&gt;free_space&lt;/code&gt; 。違いは、固定ページのオーバーヘッド、タプルへのポインターのページごとのテーブル、およびタプルが正しく配置されるようにするためのパディングによって説明されます。</target>
        </trans-unit>
        <trans-unit id="b6f00658cdbd1a37668746a630df6795de40f40a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tablefunc&lt;/code&gt; module includes various functions that return tables (that is, multiple rows). These functions are useful both in their own right and as examples of how to write C functions that return multiple rows.</source>
          <target state="translated">&lt;code&gt;tablefunc&lt;/code&gt; のモジュールは、様々な機能、その戻りテーブル（ある、複数の行）を含みます。これらの関数は、それ自体としても、複数の行を返すC関数の記述例としても役立ちます。</target>
        </trans-unit>
        <trans-unit id="9cdf44adfa31acc1639b19ed48b2eb69211df790" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tablespace_name&lt;/code&gt; is the name of the tablespace in which the new materialized view is to be created. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted.</source>
          <target state="translated">&lt;code&gt;tablespace_name&lt;/code&gt; 新しいマテリアライズド・ビューが作成される表領域の名前です。指定しない場合、&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt;が参照されます。</target>
        </trans-unit>
        <trans-unit id="d2ab317f2006a81d25a82a98e87d5a85e8a273f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tablespace_name&lt;/code&gt; is the name of the tablespace in which the new table is to be created. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted, or &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; if the table is temporary.</source>
          <target state="translated">&lt;code&gt;tablespace_name&lt;/code&gt; 新しいテーブルが作成される表領域の名前です。指定しない場合、&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt;、またはテーブルが一時的な場合は&lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt;が参照されます。</target>
        </trans-unit>
        <trans-unit id="f686e75d0e393aa19100c981a93d00a43780aed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tablespace_name&lt;/code&gt; is the name of the tablespace in which the new table is to be created. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted, or &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; if the table is temporary. For partitioned tables, since no storage is required for the table itself, the tablespace specified overrides &lt;code&gt;default_tablespace&lt;/code&gt; as the default tablespace to use for any newly created partitions when no other tablespace is explicitly specified.</source>
          <target state="translated">&lt;code&gt;tablespace_name&lt;/code&gt; 新しいテーブルが作成される表領域の名前です。指定しない場合、&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt;、またはテーブルが一時的な場合は&lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt;が参照されます。パーティションテーブルの場合、テーブル自体にストレージは必要ないため、他のテーブルスペースが明示的に指定されていない場合、指定されたテーブルスペースは、新しく作成されたパーティションに使用するデフォルトのテーブルスペースとして &lt;code&gt;default_tablespace&lt;/code&gt; をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="0b4265a037b613093215c3a2b0f1964512919269" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tcn&lt;/code&gt; module provides a trigger function that notifies listeners of changes to any table on which it is attached. It must be used as an &lt;code&gt;AFTER&lt;/code&gt; trigger &lt;code&gt;FOR EACH ROW&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tcn&lt;/code&gt; モジュールは、それが結合している任意のテーブルに対する変更の通知リスナーことトリガ機能を提供します。これは、 &lt;code&gt;AFTER&lt;/code&gt; トリガー &lt;code&gt;FOR EACH ROW&lt;/code&gt; として使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="17aaa8650f37c6cdde06430e667abefb0767b412" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;to_char&lt;/code&gt; family of functions</source>
          <target state="translated">関数の &lt;code&gt;to_char&lt;/code&gt; ファミリー</target>
        </trans-unit>
        <trans-unit id="e895ae79ff8443b98ab632e79a7fde4140eb2a9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;to_regclass&lt;/code&gt;, &lt;code&gt;to_regproc&lt;/code&gt;, &lt;code&gt;to_regprocedure&lt;/code&gt;, &lt;code&gt;to_regoper&lt;/code&gt;, &lt;code&gt;to_regoperator&lt;/code&gt;, &lt;code&gt;to_regtype&lt;/code&gt;, &lt;code&gt;to_regnamespace&lt;/code&gt;, and &lt;code&gt;to_regrole&lt;/code&gt; functions translate relation, function, operator, type, schema, and role names (given as &lt;code&gt;text&lt;/code&gt;) to objects of type &lt;code&gt;regclass&lt;/code&gt;, &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;regprocedure&lt;/code&gt;, &lt;code&gt;regoper&lt;/code&gt;, &lt;code&gt;regoperator&lt;/code&gt;, &lt;code&gt;regtype&lt;/code&gt;, &lt;code&gt;regnamespace&lt;/code&gt;, and &lt;code&gt;regrole&lt;/code&gt; respectively. These functions differ from a cast from text in that they don't accept a numeric OID, and that they return null rather than throwing an error if the name is not found (or, for &lt;code&gt;to_regproc&lt;/code&gt; and &lt;code&gt;to_regoper&lt;/code&gt;, if the given name matches multiple objects).</source>
          <target state="translated">&lt;code&gt;to_regclass&lt;/code&gt; 、 &lt;code&gt;to_regproc&lt;/code&gt; 、 &lt;code&gt;to_regprocedure&lt;/code&gt; 、 &lt;code&gt;to_regoper&lt;/code&gt; 、 &lt;code&gt;to_regoperator&lt;/code&gt; 、 &lt;code&gt;to_regtype&lt;/code&gt; 、 &lt;code&gt;to_regnamespace&lt;/code&gt; 、及び &lt;code&gt;to_regrole&lt;/code&gt; 関数（として指定された関係、機能、操作者、タイプ、スキーマ、およびロール名翻訳 &lt;code&gt;text&lt;/code&gt; タイプのオブジェクトに） &lt;code&gt;regclass&lt;/code&gt; データ、 &lt;code&gt;regproc&lt;/code&gt; 、 &lt;code&gt;regprocedure&lt;/code&gt; 、 &lt;code&gt;regoper&lt;/code&gt; 、 &lt;code&gt;regoperator&lt;/code&gt; をを、 &lt;code&gt;regtype&lt;/code&gt; 、 &lt;code&gt;regnamespace&lt;/code&gt; 、および &lt;code&gt;regrole&lt;/code&gt; それぞれ。これらの関数は、テキストからのキャストとは異なり、数値のOIDを受け入れず、名前が見つからない場合（または、 &lt;code&gt;to_regproc&lt;/code&gt; および &lt;code&gt;to_regoper&lt;/code&gt; の場合、指定された名前が複数のオブジェクトに一致する場合はエラーをスローせずにnullを返します） ）。</target>
        </trans-unit>
        <trans-unit id="9bc966f611788c95433ef51cb7b635ecd99368eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;to_tsvector&lt;/code&gt; function internally calls a parser which breaks the document text into tokens and assigns a type to each token. For each token, a list of dictionaries (&lt;a href=&quot;textsearch-dictionaries&quot;&gt;Section 12.6&lt;/a&gt;) is consulted, where the list can vary depending on the token type. The first dictionary that &lt;em&gt;recognizes&lt;/em&gt; the token emits one or more normalized &lt;em&gt;lexemes&lt;/em&gt; to represent the token. For example, &lt;code&gt;rats&lt;/code&gt; became &lt;code&gt;rat&lt;/code&gt; because one of the dictionaries recognized that the word &lt;code&gt;rats&lt;/code&gt; is a plural form of &lt;code&gt;rat&lt;/code&gt;. Some words are recognized as &lt;em&gt;stop words&lt;/em&gt; (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-STOPWORDS&quot;&gt;Section 12.6.1&lt;/a&gt;), which causes them to be ignored since they occur too frequently to be useful in searching. In our example these are &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, and &lt;code&gt;it&lt;/code&gt;. If no dictionary in the list recognizes the token then it is also ignored. In this example that happened to the punctuation sign &lt;code&gt;-&lt;/code&gt; because there are in fact no dictionaries assigned for its token type (&lt;code&gt;Space symbols&lt;/code&gt;), meaning space tokens will never be indexed. The choices of parser, dictionaries and which types of tokens to index are determined by the selected text search configuration (&lt;a href=&quot;textsearch-configuration&quot;&gt;Section 12.7&lt;/a&gt;). It is possible to have many different configurations in the same database, and predefined configurations are available for various languages. In our example we used the default configuration &lt;code&gt;english&lt;/code&gt; for the English language.</source>
          <target state="translated">&lt;code&gt;to_tsvector&lt;/code&gt; の機能は、内部トークンに文書テキストを分割し、各トークンにタイプを割り当てパーサを呼び出します。トークンごとに、辞書のリスト（&lt;a href=&quot;textsearch-dictionaries&quot;&gt;セクション12.6&lt;/a&gt;）が参照されます。このリストは、トークンタイプによって異なる場合があります。トークンを&lt;em&gt;認識する&lt;/em&gt;最初の辞書は、トークンを表す1つ以上の正規化された&lt;em&gt;語彙素&lt;/em&gt;を出力します。例えば、 &lt;code&gt;rats&lt;/code&gt; なった &lt;code&gt;rat&lt;/code&gt; の辞書の一つは、単語と認識しているため &lt;code&gt;rats&lt;/code&gt; 複数形である &lt;code&gt;rat&lt;/code&gt; 。一部の単語は&lt;em&gt;ストップワード&lt;/em&gt;として認識され&lt;em&gt;ます&lt;/em&gt;（&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-STOPWORDS&quot;&gt;セクション12.6.1&lt;/a&gt;）、頻繁に発生して検索に役立たないため、無視されます。この例では &lt;code&gt;a&lt;/code&gt; これらはa、 &lt;code&gt;on&lt;/code&gt; 、および &lt;code&gt;it&lt;/code&gt; です。リスト内のどのディクショナリもトークンを認識しない場合、それも無視されます。句読点記号に起こったこの例では &lt;code&gt;-&lt;/code&gt; そのトークンタイプに割り当てられた辞書（実際には存在しないので、 &lt;code&gt;Space symbols&lt;/code&gt; ）、つまり宇宙トークンがインデックス化されることはありません。パーサー、ディクショナリ、およびインデックスを作成するトークンのタイプの選択は、選択したテキスト検索構成によって決定されます（&lt;a href=&quot;textsearch-configuration&quot;&gt;セクション12.7&lt;/a&gt;）。同じデータベースに多くの異なる構成を含めることが可能で、事前定義された構成はさまざまな言語で利用できます。この例では、英語にデフォルト設定の &lt;code&gt;english&lt;/code&gt; を使用しました。</target>
        </trans-unit>
        <trans-unit id="25a8b2b35ba5bb7ac691f2af5d9013c610a29764" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ts_lexize&lt;/code&gt; function expects a single &lt;em&gt;token&lt;/em&gt;, not text. Here is a case where this can be confusing:</source>
          <target state="translated">&lt;code&gt;ts_lexize&lt;/code&gt; の機能は、単一期待し&lt;em&gt;たトークン&lt;/em&gt;ではなく、テキスト。これが混乱を招く可能性があるケースを次に示します。</target>
        </trans-unit>
        <trans-unit id="414a4e254a9e67a84663f59263f88c95c42cfbfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ts_lexize&lt;/code&gt; function facilitates dictionary testing.</source>
          <target state="translated">&lt;code&gt;ts_lexize&lt;/code&gt; の機能は、辞書テストを容易にします。</target>
        </trans-unit>
        <trans-unit id="4acca59985cbdc80cca43fe97ac114ac2ea61d90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ts_rewrite&lt;/code&gt; family of functions search a given &lt;code&gt;tsquery&lt;/code&gt; for occurrences of a target subquery, and replace each occurrence with a substitute subquery. In essence this operation is a &lt;code&gt;tsquery&lt;/code&gt;-specific version of substring replacement. A target and substitute combination can be thought of as a &lt;em&gt;query rewrite rule&lt;/em&gt;. A collection of such rewrite rules can be a powerful search aid. For example, you can expand the search using synonyms (e.g., &lt;code&gt;new york&lt;/code&gt;, &lt;code&gt;big apple&lt;/code&gt;, &lt;code&gt;nyc&lt;/code&gt;, &lt;code&gt;gotham&lt;/code&gt;) or narrow the search to direct the user to some hot topic. There is some overlap in functionality between this feature and thesaurus dictionaries (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-THESAURUS&quot;&gt;Section 12.6.4&lt;/a&gt;). However, you can modify a set of rewrite rules on-the-fly without reindexing, whereas updating a thesaurus requires reindexing to be effective.</source>
          <target state="translated">&lt;code&gt;ts_rewrite&lt;/code&gt; ファミリの関数は、指定された検索 &lt;code&gt;tsquery&lt;/code&gt; ターゲットサブクエリの発生のために、そして代替サブクエリで各発生を置き換えます。本質的に、この操作は &lt;code&gt;tsquery&lt;/code&gt; 固有のバージョンのサブストリング置換です。ターゲットと代替の組み合わせは、&lt;em&gt;クエリ書き換えルール&lt;/em&gt;と考えることができます。このような書き換えルールのコレクションは、強力な検索の助けとなります。たとえば、同義語（例えば、使用して検索を広げることができます &lt;code&gt;new york&lt;/code&gt; 、 &lt;code&gt;big apple&lt;/code&gt; 、 &lt;code&gt;nyc&lt;/code&gt; 、 &lt;code&gt;gotham&lt;/code&gt; ）、またはいくつかのホットな話題にユーザーを導くため、検索を絞り込みます。この機能とシソーラス辞書（&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-THESAURUS&quot;&gt;12.6.4項&lt;/a&gt;）。ただし、インデックスを再作成せずに、オンザフライで一連の書き換えルールを変更できますが、シソーラスを更新するには、再インデックスを有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="f5ce57d748f7a336aa1b84fb89aaf298351d6555" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsm_system_rows&lt;/code&gt; module provides the table sampling method &lt;code&gt;SYSTEM_ROWS&lt;/code&gt;, which can be used in the &lt;code&gt;TABLESAMPLE&lt;/code&gt; clause of a &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command.</source>
          <target state="translated">&lt;code&gt;tsm_system_rows&lt;/code&gt; モジュール方式サンプリングテーブルを提供 &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; に使用することができ、 &lt;code&gt;TABLESAMPLE&lt;/code&gt; 用の句&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;コマンド。</target>
        </trans-unit>
        <trans-unit id="ec2660bd7bfa7364869659c121d8520debb99419" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsm_system_time&lt;/code&gt; module provides the table sampling method &lt;code&gt;SYSTEM_TIME&lt;/code&gt;, which can be used in the &lt;code&gt;TABLESAMPLE&lt;/code&gt; clause of a &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command.</source>
          <target state="translated">&lt;code&gt;tsm_system_time&lt;/code&gt; のモジュールは、テーブルサンプリング方式提供 &lt;code&gt;SYSTEM_TIME&lt;/code&gt; で使用することができ、 &lt;code&gt;TABLESAMPLE&lt;/code&gt; 用の句&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;コマンド。</target>
        </trans-unit>
        <trans-unit id="390aa178cbfa17e56fd10d81213ce2e7d202995c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsquery&lt;/code&gt; containment operators consider only the lexemes listed in the two queries, ignoring the combining operators.</source>
          <target state="translated">&lt;code&gt;tsquery&lt;/code&gt; 含有演算子は、組み合わせ演算子を無視して、2つのクエリに記載されている唯一の語彙素を考えます。</target>
        </trans-unit>
        <trans-unit id="d94003b7d5e3893485cdec1b88bc0aea54d3d7f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsvector&lt;/code&gt; concatenation operator returns a vector which combines the lexemes and positional information of the two vectors given as arguments. Positions and weight labels are retained during the concatenation. Positions appearing in the right-hand vector are offset by the largest position mentioned in the left-hand vector, so that the result is nearly equivalent to the result of performing &lt;code&gt;to_tsvector&lt;/code&gt; on the concatenation of the two original document strings. (The equivalence is not exact, because any stop-words removed from the end of the left-hand argument will not affect the result, whereas they would have affected the positions of the lexemes in the right-hand argument if textual concatenation were used.)</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; の連結演算子は、語彙素および引数として与えられた2つのベクトルの位置情報を組み合わせたベクトルを返します。位置とウェイトラベルは連結中に保持されます。右側のベクトルに現れる位置は、左側のベクトルで言及された最大の位置によってオフセットされるため、結果は、2つの元のドキュメント文字列の連結に対して &lt;code&gt;to_tsvector&lt;/code&gt; を実行した結果とほぼ同等です。 （左側の引数の末尾から削除されたストップワードは結果に影響を与えないため、同等性は正確ではありませんが、テキストの連結が使用された場合、右側の引数の語彙素の位置に影響します。 ）</target>
        </trans-unit>
        <trans-unit id="64e34183b8dfafa188cf43b0a5c4b0041a97f2d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unaccent()&lt;/code&gt; function removes accents (diacritic signs) from a given string. Basically, it's a wrapper around &lt;code&gt;unaccent&lt;/code&gt;-type dictionaries, but it can be used outside normal text search contexts.</source>
          <target state="translated">&lt;code&gt;unaccent()&lt;/code&gt; 関数は、指定された文字列からアクセント（発音区別符号符号）を除去します。基本的には、 &lt;code&gt;unaccent&lt;/code&gt; タイプの辞書のラッパーですが、通常のテキスト検索コンテキスト以外でも使用できます。</target>
        </trans-unit>
        <trans-unit id="fb54fa28d01791fcb6f7f658cdfdf7f9c3926fab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;lower&lt;/code&gt;, and &lt;code&gt;initcap&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;upper&lt;/code&gt; 、 &lt;code&gt;lower&lt;/code&gt; 、および &lt;code&gt;initcap&lt;/code&gt; 機能</target>
        </trans-unit>
        <trans-unit id="dae2537a13fb0c8fd0778a9239206e8184aecf1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uuid-ossp&lt;/code&gt; module provides functions to generate universally unique identifiers (UUIDs) using one of several standard algorithms. There are also functions to produce certain special UUID constants.</source>
          <target state="translated">&lt;code&gt;uuid-ossp&lt;/code&gt; モジュールは、いくつかの標準的なアルゴリズムのいずれかを使用して、汎用一意識別子（UUIDを）を生成する機能を提供します。特定の特別なUUID定数を生成する関数もあります。</target>
        </trans-unit>
        <trans-unit id="c33dc4b6b3f3d4e4e7276aab8066c7be89f11d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; must be a number. In general, the higher the number the more borders and lines the tables will have, but details depend on the particular format. In HTML format, this will translate directly into the &lt;code&gt;border=...&lt;/code&gt; attribute. In most other formats only values 0 (no border), 1 (internal dividing lines), and 2 (table frame) make sense, and values above 2 will be treated the same as &lt;code&gt;border = 2&lt;/code&gt;. The &lt;code&gt;latex&lt;/code&gt; and &lt;code&gt;latex-longtable&lt;/code&gt; formats additionally allow a value of 3 to add dividing lines between data rows.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 数字でなければなりません。一般に、数値が大きいほど、テーブルのボーダーとラインが多くなりますが、詳細は特定の形式によって異なります。 HTML形式では、これは &lt;code&gt;border=...&lt;/code&gt; 属性に直接変換されます。他のほとんどのフォーマットでは、値0（境界線なし）、1（内部分割線）、および2（表枠）のみが意味をなし、2を超える値は &lt;code&gt;border = 2&lt;/code&gt; と同じように扱われます。 &lt;code&gt;latex&lt;/code&gt; と &lt;code&gt;latex-longtable&lt;/code&gt; フォーマットはさらに、3の値は、データ行の間の行を分割する追加することを可能にします。</target>
        </trans-unit>
        <trans-unit id="2ed006ed7919dad8517461e6b9bbcdfb9261bd7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wait_event&lt;/code&gt; and &lt;code&gt;state&lt;/code&gt; columns are independent. If a backend is in the &lt;code&gt;active&lt;/code&gt; state, it may or may not be &lt;code&gt;waiting&lt;/code&gt; on some event. If the state is &lt;code&gt;active&lt;/code&gt; and &lt;code&gt;wait_event&lt;/code&gt; is non-null, it means that a query is being executed, but is being blocked somewhere in the system.</source>
          <target state="translated">&lt;code&gt;wait_event&lt;/code&gt; と &lt;code&gt;state&lt;/code&gt; の列が独立しています。バックエンドが &lt;code&gt;active&lt;/code&gt; 状態の場合、バックエンドは何らかのイベントを &lt;code&gt;waiting&lt;/code&gt; している場合と待機していない場合があります。状態が &lt;code&gt;active&lt;/code&gt; 、 &lt;code&gt;wait_event&lt;/code&gt; がnull以外の場合は、クエリが実行されているが、システムのどこかでブロックされていることを意味します。</target>
        </trans-unit>
        <trans-unit id="0125e5f4ec341f59b7fbf88d54a9be3ac7c60904" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml2&lt;/code&gt; module provides XPath querying and XSLT functionality.</source>
          <target state="translated">&lt;code&gt;xml2&lt;/code&gt; モジュールは、XPathクエリとXSLTの機能を提供します。</target>
        </trans-unit>
        <trans-unit id="b8ee7c238579a8efef3d1bbe76947df3fd98bf79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml&lt;/code&gt; data type can be used to store XML data. Its advantage over storing XML data in a &lt;code&gt;text&lt;/code&gt; field is that it checks the input values for well-formedness, and there are support functions to perform type-safe operations on it; see &lt;a href=&quot;functions-xml&quot;&gt;Section 9.14&lt;/a&gt;. Use of this data type requires the installation to have been built with &lt;code&gt;configure --with-libxml&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; データ型は、XMLデータを格納するために使用することができます。 XMLデータを &lt;code&gt;text&lt;/code&gt; フィールドに格納することに対する利点は、入力値が整形式かどうかをチェックし、タイプセーフな操作を実行するためのサポート関数があることです。&lt;a href=&quot;functions-xml&quot;&gt;セクション9.14を&lt;/a&gt;参照してください。このデータ型を使用するには、インストールが &lt;code&gt;configure --with-libxml&lt;/code&gt; でビルドされている必要があります。</target>
        </trans-unit>
        <trans-unit id="e872bad693cf86fd556718feb449776c1f39b558" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml&lt;/code&gt; data type is unusual in that it does not provide any comparison operators. This is because there is no well-defined and universally useful comparison algorithm for XML data. One consequence of this is that you cannot retrieve rows by comparing an &lt;code&gt;xml&lt;/code&gt; column against a search value. XML values should therefore typically be accompanied by a separate key field such as an ID. An alternative solution for comparing XML values is to convert them to character strings first, but note that character string comparison has little to do with a useful XML comparison method.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; データ型は、任意の比較演算子を提供していないということでは珍しいです。これは、XMLデータに対して明確に定義された、普遍的に有用な比較アルゴリズムがないためです。この1つの結果は、 &lt;code&gt;xml&lt;/code&gt; 列を検索値と比較して行を取得できないことです。したがって、XML値には通常、IDなどの個別のキーフィールドが付随する必要があります。 XML値を比較する別のソリューションは、最初に値を文字列に変換することですが、文字列の比較は、有用なXML比較方法とはほとんど関係がないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="59e179d52ab69f7b0f66292f2459b29798716de6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml&lt;/code&gt; type can store well-formed &amp;ldquo;documents&amp;rdquo;, as defined by the XML standard, as well as &amp;ldquo;content&amp;rdquo; fragments, which are defined by reference to the more permissive &lt;a href=&quot;https://www.w3.org/TR/2010/REC-xpath-datamodel-20101214/#DocumentNode&quot;&gt;&amp;ldquo;document node&amp;rdquo;&lt;/a&gt; of the XQuery and XPath data model. Roughly, this means that content fragments can have more than one top-level element or character node. The expression &lt;code&gt;xmlvalue IS DOCUMENT&lt;/code&gt; can be used to evaluate whether a particular &lt;code&gt;xml&lt;/code&gt; value is a full document or only a content fragment.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; タイプは、整形式XML規格で定義される「ドキュメント」、ならびにより寛容を参照することによって定義される「コンテンツ」断片、格納することができる&lt;a href=&quot;https://www.w3.org/TR/2010/REC-xpath-datamodel-20101214/#DocumentNode&quot;&gt;「文書ノード」&lt;/a&gt; XQueryおよびXPathデータモデルを。大まかに言うと、これはコンテンツフラグメントが複数のトップレベルの要素または文字ノードを持つことができることを意味します。式 &lt;code&gt;xmlvalue IS DOCUMENT&lt;/code&gt; を使用して、特定の &lt;code&gt;xml&lt;/code&gt; 値が完全なドキュメントであるか、コンテンツフラグメントのみであるかを評価できます。</target>
        </trans-unit>
        <trans-unit id="70fece117905c5ca56558a0c032db75b892af97c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml&lt;/code&gt; type does not validate input values against a document type declaration (DTD), even when the input value specifies a DTD. There is also currently no built-in support for validating against other XML schema languages such as XML Schema.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; タイプは、入力値がDTDを指定した場合でも、文書型定義（DTD）に対して検証入力値がありません。現在、XMLスキーマなどの他のXMLスキーマ言語に対して検証するための組み込みサポートもありません。</target>
        </trans-unit>
        <trans-unit id="1deef1e666f438cec77e8c3e2e2981fe717c4002" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlelement&lt;/code&gt; expression produces an XML element with the given name, attributes, and content.</source>
          <target state="translated">&lt;code&gt;xmlelement&lt;/code&gt; 式が与えられた名前、属性、およびコンテンツを持つXML要素を生成します。</target>
        </trans-unit>
        <trans-unit id="69f2f71a5ec8ec9b6b661345ad1ff563285eb198" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlforest&lt;/code&gt; expression produces an XML forest (sequence) of elements using the given names and content.</source>
          <target state="translated">&lt;code&gt;xmlforest&lt;/code&gt; 式は、与えられた名前とコンテンツを使用して要素のXMLフォレスト（シーケンス）を生成します。</target>
        </trans-unit>
        <trans-unit id="c704d359323afbae05aea7d4c253db38a9779402" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlpi&lt;/code&gt; expression creates an XML processing instruction. The content, if present, must not contain the character sequence &lt;code&gt;?&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;xmlpi&lt;/code&gt; 式は、XML処理命令を作成します。コンテンツには、存在する場合、文字シーケンス &lt;code&gt;?&amp;gt;&lt;/code&gt; を含めることはできません。</target>
        </trans-unit>
        <trans-unit id="483ff2aaee5c62e793871dd92a52c8a7e7cf4d6c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlroot&lt;/code&gt; expression alters the properties of the root node of an XML value. If a version is specified, it replaces the value in the root node's version declaration; if a standalone setting is specified, it replaces the value in the root node's standalone declaration.</source>
          <target state="translated">&lt;code&gt;xmlroot&lt;/code&gt; 発現は、XML値のルートノードの特性を変化させます。バージョンを指定すると、ルートノードのバージョン宣言の値が置き換えられます。スタンドアロン設定が指定されている場合は、ルートノードのスタンドアロン宣言の値を置き換えます。</target>
        </trans-unit>
        <trans-unit id="194749c8350686b704674839bea4fca3eca2b901" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmltable&lt;/code&gt; function produces a table based on the given XML value, an XPath filter to extract rows, and a set of column definitions.</source>
          <target state="translated">&lt;code&gt;xmltable&lt;/code&gt; 関数は、指定されたXML値、抽出行へのXPathフィルタ、および列定義のセットに基づいてテーブルを生成します。</target>
        </trans-unit>
        <trans-unit id="241345ed65eaa6c1efb430df3084f0d4151592bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xpath_table&lt;/code&gt; function assumes that the results of each XPath query might be multivalued, so the number of rows returned by the function may not be the same as the number of input documents. The first row returned contains the first result from each query, the second row the second result from each query. If one of the queries has fewer values than the others, null values will be returned instead.</source>
          <target state="translated">&lt;code&gt;xpath_table&lt;/code&gt; 関数は、関数によって返される行の数は、入力文書の数と同じでなくてもよいように、各XPathクエリの結果は、多値れるかもしれないことを仮定しています。返される最初の行には各クエリの最初の結果が含まれ、2番目の行には各クエリの2番目の結果が含まれます。クエリの1つが他のクエリよりも値が少ない場合、代わりにnull値が返されます。</target>
        </trans-unit>
        <trans-unit id="8f26d57e1c368d060299c1c81b28042f79fcca60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;||&lt;/code&gt; operator concatenates the elements at the top level of each of its operands. It does not operate recursively. For example, if both operands are objects with a common key field name, the value of the field in the result will just be the value from the right hand operand.</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt; 演算子は、各オペランドの最上位にある要素を連結します。再帰的には動作しません。たとえば、両方のオペランドが共通のキーフィールド名を持つオブジェクトである場合、結果のフィールドの値は、右側のオペランドの値になります。</target>
        </trans-unit>
        <trans-unit id="25839180048fba8f8f9437939d20a2f9e4fca2ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&amp;gt;&lt;/code&gt; operator can also be used in this way to efficiently retrieve the first few values sorted by a selected coordinate. For example, to get the first few cubes ordered by the first coordinate (lower left corner) ascending one could use the following query:</source>
          <target state="translated">&lt;code&gt;~&amp;gt;&lt;/code&gt; オペレータは、効率的に最初のいくつかの値が選択された座標でソート取得するために、このように使用することができます。たとえば、最初の座標（左下隅）を昇順に並べた最初のいくつかのキューブを取得するには、次のクエリを使用できます。</target>
        </trans-unit>
        <trans-unit id="809dd3cf23829e5aba0aac6f0c8cd829bcb11269" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;indexCorrelation&lt;/code&gt;&lt;/em&gt; should be set to the correlation (ranging between -1.0 and 1.0) between the index order and the table order. This is used to adjust the estimate for the cost of fetching rows from the parent table.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;indexCorrelation&lt;/code&gt; は&lt;/em&gt;インデックス順とテーブル順間（-1.0と1.0の間の範囲）の相関関係に設定されるべきです。これは、親テーブルから行をフェッチするコストの見積もりを調整するために使用されます。</target>
        </trans-unit>
        <trans-unit id="d81aee55a8d4dcdc2397573ababbf7924223c018" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;indexPages&lt;/code&gt;&lt;/em&gt; should be set to the number of leaf pages. This is used to estimate the number of workers for parallel index scan.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;indexPages&lt;/code&gt; は、&lt;/em&gt;リーフ・ページの数に設定する必要があります。これは、並列インデックススキャンのワーカー数を推定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="7685e1c43506ada1cffddeedf06115e445c9d085" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;indexSelectivity&lt;/code&gt;&lt;/em&gt; should be set to the estimated fraction of the parent table rows that will be retrieved during the index scan. In the case of a lossy query, this will typically be higher than the fraction of rows that actually pass the given qual conditions.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;indexSelectivity&lt;/code&gt; は、&lt;/em&gt;インデックススキャンの間に抽出される親テーブルの行の推定割合に設定する必要があります。非可逆クエリの場合、これは通常、指定された条件を実際に通過する行の割合よりも高くなります。</target>
        </trans-unit>
        <trans-unit id="ae5c470364e9e087f35c4b0de71e765afe691f23" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;iter_count&lt;/code&gt;&lt;/em&gt; parameter lets the user specify the iteration count, for algorithms that have one. The higher the count, the more time it takes to hash the password and therefore the more time to break it. Although with too high a count the time to calculate a hash may be several years &amp;mdash; which is somewhat impractical. If the &lt;em&gt;&lt;code&gt;iter_count&lt;/code&gt;&lt;/em&gt; parameter is omitted, the default iteration count is used. Allowed values for &lt;em&gt;&lt;code&gt;iter_count&lt;/code&gt;&lt;/em&gt; depend on the algorithm and are shown in &lt;a href=&quot;pgcrypto#PGCRYPTO-ICFC-TABLE&quot;&gt;Table F.17&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;iter_count&lt;/code&gt; &lt;/em&gt;パラメーターは、ユーザーがいずれかを持っているアルゴリズムのために、反復回数を指定することができます。カウントが高いほど、パスワードのハッシュに時間がかかるため、パスワードを解読するのに時間がかかります。カウントが高すぎる場合でも、ハッシュを計算するのに数年かかることがありますが、これはやや非現実的です。場合&lt;em&gt; &lt;code&gt;iter_count&lt;/code&gt; &lt;/em&gt;パラメータが省略され、デフォルトの繰り返し回数が使用されています。&lt;em&gt; &lt;code&gt;iter_count&lt;/code&gt; &lt;/em&gt;に使用できる値は&lt;em&gt;アルゴリズム&lt;/em&gt;によって異なり、&lt;a href=&quot;pgcrypto#PGCRYPTO-ICFC-TABLE&quot;&gt;表F.17に&lt;/a&gt;示されています。</target>
        </trans-unit>
        <trans-unit id="3b20f1e5072b09c8c12330c4cbb5380dc3c53e3d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;options&lt;/code&gt;&lt;/em&gt; parameter can contain option settings, as described below.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;options&lt;/code&gt; &lt;/em&gt;以下に説明するようにパラメータは、オプション設定を含めることができます。</target>
        </trans-unit>
        <trans-unit id="048387eb78e0888018ae5bf5cface4e6e6cf82bc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;sql&lt;/code&gt;&lt;/em&gt; parameter is a SQL statement that produces the source set of data. This statement must return one &lt;code&gt;row_name&lt;/code&gt; column, one &lt;code&gt;category&lt;/code&gt; column, and one &lt;code&gt;value&lt;/code&gt; column. &lt;em&gt;&lt;code&gt;N&lt;/code&gt;&lt;/em&gt; is an obsolete parameter, ignored if supplied (formerly this had to match the number of output value columns, but now that is determined by the calling query).</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;sql&lt;/code&gt; &lt;/em&gt;パラメータは、データのソースセットを生成するSQL文です。このステートメントは、1 つの &lt;code&gt;row_name&lt;/code&gt; 列、1つの &lt;code&gt;category&lt;/code&gt; 列、および1つの &lt;code&gt;value&lt;/code&gt; 列を返す必要があります。&lt;em&gt; &lt;code&gt;N&lt;/code&gt; &lt;/em&gt;は廃止されたパラメーターであり、指定されても無視されます（以前は出力値列の数と一致する必要がありましたが、現在は呼び出し元のクエリによって決定されます）。</target>
        </trans-unit>
        <trans-unit id="a58a0a84dc580d747afb8a21f647c284a9244868" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;type&lt;/code&gt;&lt;/em&gt; parameter specifies the hashing algorithm. The accepted types are: &lt;code&gt;des&lt;/code&gt;, &lt;code&gt;xdes&lt;/code&gt;, &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;bf&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;type&lt;/code&gt; &lt;/em&gt;パラメータは、ハッシュアルゴリズムを指定します。受け入れられるタイプは、 &lt;code&gt;des&lt;/code&gt; 、 &lt;code&gt;xdes&lt;/code&gt; 、 &lt;code&gt;md5&lt;/code&gt; および &lt;code&gt;bf&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="484484b19f7f2f2b36524197848aeb0d9d4987ca" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Julian Date&lt;/em&gt; system is another type of calendar, unrelated to the Julian calendar though it is confusingly named similarly to that calendar. The Julian Date system was invented by the French scholar Joseph Justus Scaliger (1540-1609) and probably takes its name from Scaliger's father, the Italian scholar Julius Caesar Scaliger (1484-1558). In the Julian Date system, each day has a sequential number, starting from JD 0 (which is sometimes called &lt;em&gt;the&lt;/em&gt; Julian Date). JD 0 corresponds to 1 January 4713 BC in the Julian calendar, or 24 November 4714 BC in the Gregorian calendar. Julian Date counting is most often used by astronomers for labeling their nightly observations, and therefore a date runs from noon UTC to the next noon UTC, rather than from midnight to midnight: JD 0 designates the 24 hours from noon UTC on 24 November 4714 BC to noon UTC on 25 November 4714 BC.</source>
          <target state="translated">&lt;em&gt;ユリウス日付の&lt;/em&gt;システムは、それが紛らわしいそのカレンダーと同様に名前が付けられてもユリウス暦とは無関係のカレンダーの別のタイプです。ユリウス日付システムは、フランスの学者ジョセフジャスタススカリジャー（1540-1609）によって発明され、おそらくその名前はスカリジャーの父親であるイタリアの学者ジュリアスシーザースカリガー（1484-1558）に由来します。ユリウス日システムでは、毎日、JD 0から始まる連番があります（これは&lt;em&gt;、&lt;/em&gt;ユリウス日）。 JD 0は、ユリウス暦の紀元前4713年1月1日、またはグレゴリオ暦の紀元前4714年11月24日に対応します。ユリウス日カウントは、天文学者が毎晩の観測にラベルを付けるために最も頻繁に使用されるため、日付は真夜中から真夜中ではなく、正午UTCから次の正午UTCまで続きます。JD0は、紀元前4714年11月24日の正午UTCから24時間を示します紀元前4714年11月25日の正午UTCに。</target>
        </trans-unit>
        <trans-unit id="c767ea884019c639904724de55aaea8a6ef4f2e1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Repeatable Read&lt;/em&gt; isolation level only sees data committed before the transaction began; it never sees either uncommitted data or changes committed during transaction execution by concurrent transactions. (However, the query does see the effects of previous updates executed within its own transaction, even though they are not yet committed.) This is a stronger guarantee than is required by the SQL standard for this isolation level, and prevents all of the phenomena described in &lt;a href=&quot;transaction-iso#MVCC-ISOLEVEL-TABLE&quot;&gt;Table 13.1&lt;/a&gt; except for serialization anomalies. As mentioned above, this is specifically allowed by the standard, which only describes the &lt;em&gt;minimum&lt;/em&gt; protections each isolation level must provide.</source>
          <target state="translated">&lt;em&gt;反復可能読み取り&lt;/em&gt;分離レベルは、トランザクションが開始される前にコミットされたデータを見ています。コミットされていないデータや、並行トランザクションによるトランザクション実行中にコミットされた変更は表示されません。（ただし、まだコミットされていない場合でも、クエリはそれ自体のトランザクション内で実行された以前の更新の影響を確認します。）これは、SQL規格でこの分離レベルに必要なものよりも強力な保証であり、すべての現象を防ぎます。シリアル化の異常を除いて、&lt;a href=&quot;transaction-iso#MVCC-ISOLEVEL-TABLE&quot;&gt;表13.1で&lt;/a&gt;説明されています。上記のように、これは標準で特に許可されており、各分離レベルが提供する必要のある&lt;em&gt;最小の&lt;/em&gt;保護のみを説明しています。</target>
        </trans-unit>
        <trans-unit id="f9cbb4655ce1c4dfa140be7dcae24f9bc53c423c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Serializable&lt;/em&gt; isolation level provides the strictest transaction isolation. This level emulates serial transaction execution for all committed transactions; as if transactions had been executed one after another, serially, rather than concurrently. However, like the Repeatable Read level, applications using this level must be prepared to retry transactions due to serialization failures. In fact, this isolation level works exactly the same as Repeatable Read except that it monitors for conditions which could make execution of a concurrent set of serializable transactions behave in a manner inconsistent with all possible serial (one at a time) executions of those transactions. This monitoring does not introduce any blocking beyond that present in repeatable read, but there is some overhead to the monitoring, and detection of the conditions which could cause a &lt;em&gt;serialization anomaly&lt;/em&gt; will trigger a &lt;em&gt;serialization failure&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;シリアライズ&lt;/em&gt;分離レベルは、最も厳密なトランザクション分離を提供します。このレベルは、コミットされたすべてのトランザクションのシリアルトランザクション実行をエミュレートします。トランザクションが同時にではなく、逐次的に、逐次実行されたかのように。ただし、反復可能読み取りレベルと同様に、このレベルを使用するアプリケーションは、シリアル化の失敗によりトランザクションを再試行できるように準備する必要があります。実際、この分離レベルは、直列化可能なトランザクションの並行セットの実行が、それらのトランザクションの可能なシリアル（一度に1つ）の実行と一貫しない方法で動作する可能性がある状況を監視することを除いて、反復可能読み取りとまったく同じように機能します。この監視では、繰り返し可能な読み取りに存在するものを超えるブロッキングは導入されませんが、監視と、原因となる可能性のある状態の検出にはある程度のオーバーヘッドがあります。&lt;em&gt;シリアル化の異常&lt;/em&gt;は、&lt;em&gt;シリアル化の失敗を引き起こし&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="f95abb4a8d7bbdd16928c9f5238fbb89514c9dcf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;collation derivation&lt;/em&gt; of an expression can be implicit or explicit. This distinction affects how collations are combined when multiple different collations appear in an expression. An explicit collation derivation occurs when a &lt;code&gt;COLLATE&lt;/code&gt; clause is used; all other collation derivations are implicit. When multiple collations need to be combined, for example in a function call, the following rules are used:</source>
          <target state="translated">式の&lt;em&gt;照合の派生&lt;/em&gt;は、暗黙的または明示的です。この区別は、式に複数の異なる照合が出現する場合の照合の組み合わせ方法に影響します。 &lt;code&gt;COLLATE&lt;/code&gt; 句を使用すると、明示的な照合の派生が発生します。他のすべての照合の派生は暗黙的です。関数呼び出しなどで複数の照合を組み合わせる必要がある場合は、次のルールが使用されます。</target>
        </trans-unit>
        <trans-unit id="1cf554eac84360c1dd91eed12720bf8c618bfb93" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;cost&lt;/em&gt; variables described in this section are measured on an arbitrary scale. Only their relative values matter, hence scaling them all up or down by the same factor will result in no change in the planner's choices. By default, these cost variables are based on the cost of sequential page fetches; that is, &lt;code&gt;seq_page_cost&lt;/code&gt; is conventionally set to &lt;code&gt;1.0&lt;/code&gt; and the other cost variables are set with reference to that. But you can use a different scale if you prefer, such as actual execution times in milliseconds on a particular machine.</source>
          <target state="translated">&lt;em&gt;コスト&lt;/em&gt;このセクションで説明変数が任意のスケールで測定されます。重要なのはそれらの相対値だけなので、それらをすべて同じ係数で拡大または縮小しても、プランナの選択は変わりません。デフォルトでは、これらのコスト変数は、順次ページフェッチのコストに基づいています。つまり、 &lt;code&gt;seq_page_cost&lt;/code&gt; は通常 &lt;code&gt;1.0&lt;/code&gt; に設定され、他のコスト変数はそれを参照して設定されます。ただし、特定のマシンでのミリ秒単位の実際の実行時間など、必要に応じて別のスケールを使用できます。</target>
        </trans-unit>
        <trans-unit id="bdab0ead2317e8987500975ac391b000a895f851" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;executor&lt;/em&gt; takes the plan created by the planner/optimizer and recursively processes it to extract the required set of rows. This is essentially a demand-pull pipeline mechanism. Each time a plan node is called, it must deliver one more row, or report that it is done delivering rows.</source>
          <target state="translated">&lt;em&gt;エグゼキュータは&lt;/em&gt;、プランナ/オプティマイザによって作成された計画を受け取り、再帰的に行の必要なセットを抽出するために、それを処理します。これは本質的にデマンドプルパイプラインメカニズムです。計画ノードが呼び出されるたびに、1つ以上の行を配信するか、行の配信が完了したことを報告する必要があります。</target>
        </trans-unit>
        <trans-unit id="060116e5a7301adb249c93dbfa36c11220a4c9e3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;join condition&lt;/em&gt; is specified in the &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;USING&lt;/code&gt; clause, or implicitly by the word &lt;code&gt;NATURAL&lt;/code&gt;. The join condition determines which rows from the two source tables are considered to &amp;ldquo;match&amp;rdquo;, as explained in detail below.</source>
          <target state="translated">&lt;em&gt;参加条件は&lt;/em&gt;で指定された &lt;code&gt;ON&lt;/code&gt; または &lt;code&gt;USING&lt;/code&gt; 単語によって暗黙的に句を、または &lt;code&gt;NATURAL&lt;/code&gt; 。以下で詳細に説明するように、結合条件は、2つのソーステーブルのどの行が「一致」すると見なされるかを決定します。</target>
        </trans-unit>
        <trans-unit id="e845d5a4041970d6090d5e417e410e4537e73642" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;lexer&lt;/em&gt; is defined in the file &lt;code&gt;scan.l&lt;/code&gt; and is responsible for recognizing &lt;em&gt;identifiers&lt;/em&gt;, the &lt;em&gt;SQL key words&lt;/em&gt; etc. For every key word or identifier that is found, a &lt;em&gt;token&lt;/em&gt; is generated and handed to the parser.</source>
          <target state="translated">&lt;em&gt;レクサーは&lt;/em&gt;、ファイルに定義されて &lt;code&gt;scan.l&lt;/code&gt; と認識するための責任がある&lt;em&gt;識別子を&lt;/em&gt;、&lt;em&gt;SQLキーワード&lt;/em&gt;発見されたすべてのキーワードや識別子の場合などは、&lt;em&gt;トークンが&lt;/em&gt;生成され、パーサーに渡されます。</target>
        </trans-unit>
        <trans-unit id="b14305d3078ee82aaf737dbdfa8a94d4d85285ca" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;minmax&lt;/em&gt; operator classes store the minimum and the maximum values appearing in the indexed column within the range. The &lt;em&gt;inclusion&lt;/em&gt; operator classes store a value which includes the values in the indexed column within the range.</source>
          <target state="translated">&lt;em&gt;MINMAX&lt;/em&gt;オペレータクラスが最小と範囲内で索引付けされた列に現れる極大値を格納します。&lt;em&gt;封入&lt;/em&gt;演算子クラスは、範囲内の索引付けされた列の値を含む値を格納します。</target>
        </trans-unit>
        <trans-unit id="4ba1c2981b2fbd2dd1eede149e275316be5425fc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;parser stage&lt;/em&gt; checks the query transmitted by the application program for correct syntax and creates a &lt;em&gt;query tree&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;パーサステージ&lt;/em&gt;チェックは、クエリが正しい構文用のアプリケーションプログラムによって送信され、作成し&lt;em&gt;たクエリツリーを&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="8d38c6ccc62204fc543f643ffbd579a373675e1c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;parser stage&lt;/em&gt; consists of two parts:</source>
          <target state="translated">&lt;em&gt;パーサステージは&lt;/em&gt; 2つの部分から成ります：</target>
        </trans-unit>
        <trans-unit id="c5bfac80be17dbbeff4a6cdab20060a18710ec0b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;parser&lt;/em&gt; defined in &lt;code&gt;gram.y&lt;/code&gt; and &lt;code&gt;scan.l&lt;/code&gt; is built using the Unix tools bison and flex.</source>
          <target state="translated">&lt;em&gt;パーサ&lt;/em&gt;で定義されて &lt;code&gt;gram.y&lt;/code&gt; と &lt;code&gt;scan.l&lt;/code&gt; はバイソンとフレックスUnixツールを使用して構築されています。</target>
        </trans-unit>
        <trans-unit id="99c46fa0bf1c41a332643fa4668a817dafffd6e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;planner/optimizer&lt;/em&gt; takes the (rewritten) query tree and creates a &lt;em&gt;query plan&lt;/em&gt; that will be the input to the &lt;em&gt;executor&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;プランナー/オプティマイザは、&lt;/em&gt;（書き換えられた）問い合わせツリーを受け取り、作成し&lt;em&gt;たクエリプラン&lt;/em&gt;に入力される&lt;em&gt;executorを&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f0bfc85eac5f506c4396fe64f83cd201f163702b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;rewrite system&lt;/em&gt; takes the query tree created by the parser stage and looks for any &lt;em&gt;rules&lt;/em&gt; (stored in the &lt;em&gt;system catalogs&lt;/em&gt;) to apply to the query tree. It performs the transformations given in the &lt;em&gt;rule bodies&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;書き換えシステムは&lt;/em&gt;任意のためのパーサステージとルックスで作成されたクエリツリーかかる&lt;em&gt;ルール&lt;/em&gt;（に保存されている&lt;em&gt;システムカタログを&lt;/em&gt;問い合わせツリーに適用します）。&lt;em&gt;ルール本体で&lt;/em&gt;指定された変換を実行します。</target>
        </trans-unit>
        <trans-unit id="daa9a547059ab18709c7d9a8b34e0eb273fde26d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;transformation process&lt;/em&gt; does modifications and augmentations to the data structures returned by the parser.</source>
          <target state="translated">&lt;em&gt;変換プロセスは、&lt;/em&gt;パーサによって返されたデータ構造に修正及びオーグメンテーションを行います。</target>
        </trans-unit>
        <trans-unit id="6005c8d6a8d942aa977decf6b60a95978aaf5aab" translate="yes" xml:space="preserve">
          <source>The API for constructing generic WAL records is defined in &lt;code&gt;access/generic_xlog.h&lt;/code&gt; and implemented in &lt;code&gt;access/transam/generic_xlog.c&lt;/code&gt;.</source>
          <target state="translated">一般的なWALレコードを作成するためのAPIは、 &lt;code&gt;access/generic_xlog.h&lt;/code&gt; で定義され、access / transam / generic_xlog.cに実装されてい &lt;code&gt;access/transam/generic_xlog.c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aaa78d1712bc527d8b8229b7cb39f829dcef0b7a" translate="yes" xml:space="preserve">
          <source>The B-tree operator family this entry sorts according to, if an ordering operator; zero if a search operator</source>
          <target state="translated">このエントリのB-tree演算子ファミリーは、順序付け演算子の場合はソートします。</target>
        </trans-unit>
        <trans-unit id="4717590c35f3a3113f7d473dbe7410d944c8d2f4" translate="yes" xml:space="preserve">
          <source>The BRIN interface has a high level of abstraction, requiring the access method implementer only to implement the semantics of the data type being accessed. The BRIN layer itself takes care of concurrency, logging and searching the index structure.</source>
          <target state="translated">BRINインタフェースは抽象度が高く、アクセス・メソッドの実装者は、アクセスされるデータ型のセマンティクスのみを実装する必要があります。BRIN層自体は、同時実行、ロギング、インデックス構造の検索を行います。</target>
        </trans-unit>
        <trans-unit id="12f1f91360cdc7254651ab3db114c105bbc973aa" translate="yes" xml:space="preserve">
          <source>The BRIN operator classes included in the standard distribution are documented in &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 67.1&lt;/a&gt;. For more information see &lt;a href=&quot;https://www.postgresql.org/docs/12/brin.html&quot;&gt;Chapter 67&lt;/a&gt;.</source>
          <target state="translated">標準配布に含まれるBRIN演算子クラスは、&lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;表67.1に&lt;/a&gt;記載されています。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/brin.html&quot;&gt;第67章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="05d73c5606dbc5d228281af7029fd60e51759995" translate="yes" xml:space="preserve">
          <source>The Double Metaphone system computes two &amp;ldquo;sounds like&amp;rdquo; strings for a given input string &amp;mdash; a &amp;ldquo;primary&amp;rdquo; and an &amp;ldquo;alternate&amp;rdquo;. In most cases they are the same, but for non-English names especially they can be a bit different, depending on pronunciation. These functions compute the primary and alternate codes:</source>
          <target state="translated">Double Metaphoneシステムは、特定の入力文字列に対して「プライマリ」と「代替」の2つの「サウンドのような」文字列を計算します。ほとんどの場合、それらは同じですが、英語以外の名前の場合、特に発音によっては少し異なる場合があります。これらの関数は、プライマリコードと代替コードを計算します。</target>
        </trans-unit>
        <trans-unit id="c8af7d6c825c894dd0eb03ecb26fae46fecd94c6" translate="yes" xml:space="preserve">
          <source>The Free Space Map is organized as a tree of FSM pages. The bottom level FSM pages store the free space available on each heap (or index) page, using one byte to represent each such page. The upper levels aggregate information from the lower levels.</source>
          <target state="translated">フリースペースマップは、FSM ページのツリーとして構成されています。最下層の FSM ページは、各ヒープ(またはインデックス)ページで利用可能な空き領域を格納し、各ページを表すために 1 バイトを使用します。上位レベルは下位レベルの情報を集約します。</target>
        </trans-unit>
        <trans-unit id="30fb294fef92ba7b2398333f6fd38e60940f0136" translate="yes" xml:space="preserve">
          <source>The GEQO module allows the PostgreSQL query optimizer to support large join queries effectively through non-exhaustive search.</source>
          <target state="translated">GEQOモジュールは、PostgreSQLの問い合わせオプティマイザが非網羅的な検索によって大規模な結合問い合わせを効果的にサポートすることを可能にします。</target>
        </trans-unit>
        <trans-unit id="9943a2120bd9e8c3e6721e67541600ca21fe96fa" translate="yes" xml:space="preserve">
          <source>The GEQO module approaches the query optimization problem as though it were the well-known traveling salesman problem (TSP). Possible query plans are encoded as integer strings. Each string represents the join order from one relation of the query to the next. For example, the join tree</source>
          <target state="translated">GEQOモジュールは、よく知られた巡回セールスマン問題(TSP)のように問い合わせ最適化問題にアプローチします。可能な問い合わせプランは整数の文字列としてエンコードされています。各文字列は、クエリのある関係から次の関係への結合順序を表します。例えば、結合木</target>
        </trans-unit>
        <trans-unit id="a13542c5aa9b5acc83ba91d19d31a9262ad99881" translate="yes" xml:space="preserve">
          <source>The GEQO planning process uses the standard planner code to generate plans for scans of individual relations. Then join plans are developed using the genetic approach. As shown above, each candidate join plan is represented by a sequence in which to join the base relations. In the initial stage, the GEQO code simply generates some possible join sequences at random. For each join sequence considered, the standard planner code is invoked to estimate the cost of performing the query using that join sequence. (For each step of the join sequence, all three possible join strategies are considered; and all the initially-determined relation scan plans are available. The estimated cost is the cheapest of these possibilities.) Join sequences with lower estimated cost are considered &amp;ldquo;more fit&amp;rdquo; than those with higher cost. The genetic algorithm discards the least fit candidates. Then new candidates are generated by combining genes of more-fit candidates &amp;mdash; that is, by using randomly-chosen portions of known low-cost join sequences to create new sequences for consideration. This process is repeated until a preset number of join sequences have been considered; then the best one found at any time during the search is used to generate the finished plan.</source>
          <target state="translated">GEQOの計画プロセスでは、標準の計画者コードを使用して、個々の関係のスキャンの計画を生成します。次に、遺伝的アプローチを使用して結合計画が作成されます。上記のように、各結合計画の候補は、基本関係を結合する順序で表されます。最初の段階では、GEQOコードは単にいくつかの可能な結合シーケンスをランダムに生成します。考慮される各結合シーケンスについて、標準のプランナーコードが呼び出され、その結合シーケンスを使用してクエリを実行するコストを見積もります。 （結合シーケンスの各ステップでは、3つの可能な結合戦略すべてが考慮されます。最初に決定されたすべての関係スキャンプランが利用可能です。推定コストは、これらの可能性の中で最も安価です。）推定コストが低い結合シーケンスは、「詳細コストが高いものよりもフィットします。遺伝的アルゴリズムは、最も適合度の低い候補を破棄します。次に、より適した候補の遺伝子を組み合わせて新しい候補を生成します。つまり、既知の低コストの結合シーケンスのランダムに選択された部分を使用して、検討用の新しいシーケンスを作成します。このプロセスは、事前設定された数の結合シーケンスが考慮されるまで繰り返されます。次に、検索中にいつでも見つかった最良のものを使用して、完成した計画を生成します。</target>
        </trans-unit>
        <trans-unit id="12d46a50018559dae87055222c8f226b8336aa38" translate="yes" xml:space="preserve">
          <source>The GIN implementation in PostgreSQL is primarily maintained by Teodor Sigaev and Oleg Bartunov. There is more information about GIN on their &lt;a href=&quot;http://www.sai.msu.su/~megera/wiki/Gin&quot;&gt;website&lt;/a&gt;.</source>
          <target state="translated">PostgreSQLのGIN実装は、主にTeodor SigaevとOleg Bartunovによって保守されています。彼らの&lt;a href=&quot;http://www.sai.msu.su/~megera/wiki/Gin&quot;&gt;ウェブサイトに&lt;/a&gt; GINに関する詳細情報があります。</target>
        </trans-unit>
        <trans-unit id="c2e1dce9027c2870a4be78df483750ab0dd368b7" translate="yes" xml:space="preserve">
          <source>The GIN interface has a high level of abstraction, requiring the access method implementer only to implement the semantics of the data type being accessed. The GIN layer itself takes care of concurrency, logging and searching the tree structure.</source>
          <target state="translated">GIN インターフェースは抽象度が高く、アクセスメソッドの実装者はアクセスされるデータ型のセマンティクスのみを実装する必要があります。GIN レイヤー自体は、同時実行、ロギング、ツリー構造の検索を行います。</target>
        </trans-unit>
        <trans-unit id="47e8892c842e09af9d1e34fe3c02e2f04b0f5d8f" translate="yes" xml:space="preserve">
          <source>The GNU Privacy Handbook.</source>
          <target state="translated">GNUプライバシーハンドブック。</target>
        </trans-unit>
        <trans-unit id="3d32f64c87806d58fdb89cae3ce39c10adecb6af" translate="yes" xml:space="preserve">
          <source>The High Precision Event Timer (HPET) is the preferred timer on systems where it's available and TSC is not accurate. The timer chip itself is programmable to allow up to 100 nanosecond resolution, but you may not see that much accuracy in your system clock.</source>
          <target state="translated">高精度イベントタイマー(HPET)は、使用可能でTSCが正確でないシステムで好まれるタイマーです。タイマーチップ自体は、最大100ナノ秒の分解能を可能にするようにプログラム可能ですが、システムクロックの精度はそれほど高くないかもしれません。</target>
        </trans-unit>
        <trans-unit id="db1ae3a20afea53927e5a775df1db6e7daba0537" translate="yes" xml:space="preserve">
          <source>The ISO 8601 week-numbering year that the date falls in (not applicable to intervals)</source>
          <target state="translated">日付が属するISO 8601の週番付年(間隔には適用されない</target>
        </trans-unit>
        <trans-unit id="a2f552c0c2f33843207363b12ed183813abd32ee" translate="yes" xml:space="preserve">
          <source>The Identification Protocol is not intended as an authorization or access control protocol.</source>
          <target state="translated">識別プロトコルは、認可またはアクセス制御プロトコルとして意図されたものではありません。</target>
        </trans-unit>
        <trans-unit id="34d3089a14d3fce4ff8f4421c9f8177fa0b6d74c" translate="yes" xml:space="preserve">
          <source>The Institute of Automatic Control at the University of Mining and Technology, in Freiberg, Germany, encountered some problems when it wanted to use PostgreSQL as the backend for a decision support knowledge based system for the maintenance of an electrical power grid. The DBMS needed to handle large join queries for the inference machine of the knowledge based system. The number of joins in these queries made using the normal query optimizer infeasible.</source>
          <target state="translated">ドイツのフライベルクにある鉱山工科大学の自動制御研究所では、電力網のメンテナンスのための意思決定支援知識ベースシステムのバックエンドとしてPostgreSQLを使用しようとした際に、いくつかの問題に遭遇しました。DBMSは、知識ベースのシステムの推論マシンのために大規模な結合クエリを処理する必要がありました。これらのクエリの結合数が多いため、通常のクエリオプティマイザを使用することができませんでした。</target>
        </trans-unit>
        <trans-unit id="aa9845a0dd3274b254c00b6f19f94269db7f2403" translate="yes" xml:space="preserve">
          <source>The Ispell dictionary template supports &lt;em&gt;morphological dictionaries&lt;/em&gt;, which can normalize many different linguistic forms of a word into the same lexeme. For example, an English Ispell dictionary can match all declensions and conjugations of the search term &lt;code&gt;bank&lt;/code&gt;, e.g., &lt;code&gt;banking&lt;/code&gt;, &lt;code&gt;banked&lt;/code&gt;, &lt;code&gt;banks&lt;/code&gt;, &lt;code&gt;banks'&lt;/code&gt;, and &lt;code&gt;bank's&lt;/code&gt;.</source>
          <target state="translated">Ispell辞書テンプレートは、&lt;em&gt;形態辞書を&lt;/em&gt;サポートしています。これは、単語のさまざまな言語形式を同じ語彙素に正規化できます。例えば、英語Ispellの辞書は、すべての曲用と検索語の活用一致させることができ &lt;code&gt;bank&lt;/code&gt; 、例えば、 &lt;code&gt;banking&lt;/code&gt; 、 &lt;code&gt;banked&lt;/code&gt; 、 &lt;code&gt;banks&lt;/code&gt; 、 &lt;code&gt;banks'&lt;/code&gt; 、および &lt;code&gt;bank's&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="282b226a01a92e56fbbd4540780287fee9277216" translate="yes" xml:space="preserve">
          <source>The Julian calendar was introduced by Julius Caesar in 45 BC. It was in common use in the Western world until the year 1582, when countries started changing to the Gregorian calendar. In the Julian calendar, the tropical year is approximated as 365 1/4 days = 365.25 days. This gives an error of about 1 day in 128 years.</source>
          <target state="translated">ユリウス暦は、紀元前45年にユリウス・シーザーによって導入されました。それは、各国がグレゴリオ暦に変更し始めた1582年まで、西欧世界で一般的に使用されていました。ユリウス暦では、熱帯の年は365 1/4日=365.25日と近似しています。これは128年で約1日の誤差を与えます。</target>
        </trans-unit>
        <trans-unit id="3cde8e59b22c9d6c409e59a264cd6d5133433aa8" translate="yes" xml:space="preserve">
          <source>The Locking Clause</source>
          <target state="translated">ロック条項</target>
        </trans-unit>
        <trans-unit id="3aaa9a5d10023ba2866dd37afda193155af0f247" translate="yes" xml:space="preserve">
          <source>The MCV list gives the planner more detailed information about the specific values that commonly appear in the table, as well as an upper bound on the selectivities of combinations of values that do not appear in the table, allowing it to generate better estimates in both cases.</source>
          <target state="translated">MCVリストは、表によく現れる特定の値についてのより詳細な情報と、表に現れない値の組み合わせの選択性の上限をプランナーに与え、両方のケースでより良い推定値を生成することを可能にします。</target>
        </trans-unit>
        <trans-unit id="55e485d087fdc5b4b841601869e3bb93e6bf3639" translate="yes" xml:space="preserve">
          <source>The MD5 Message-Digest Algorithm.</source>
          <target state="translated">MD5メッセージダイジェストアルゴリズム。</target>
        </trans-unit>
        <trans-unit id="2127ad6c429aa49a235fd761eacdf2db8d6f6769" translate="yes" xml:space="preserve">
          <source>The Nagios plugin check_pgsql will work, because the simple information it checks for exists. The check_postgres monitoring script will also work, though some reported values could give different or confusing results. For example, last vacuum time will not be maintained, since no vacuum occurs on the standby. Vacuums running on the primary do still send their changes to the standby.</source>
          <target state="translated">Nagiosプラグインcheck_pgsqlは、チェックする単純な情報が存在するので、動作します。check_postgresモニタリングスクリプトも動作しますが、いくつかの報告された値が異なったり、混乱を招く結果を与える可能性があります。例えば、スタンバイではバキュームが発生しないため、最後のバキューム時間は維持されません。プライマリ上で実行されているバキュームは、その変更をスタンバイに送信します。</target>
        </trans-unit>
        <trans-unit id="5e71865447d6bc9ea383afd7d76b7761f19aa1b6" translate="yes" xml:space="preserve">
          <source>The OID alias types do not completely follow transaction isolation rules. The planner also treats them as simple constants, which may result in sub-optimal planning.</source>
          <target state="translated">OIDエイリアス型は、トランザクション分離ルールに完全に従っていません。また、プランナはそれらを単純な定数として扱い、その結果、最適ではないプランニングになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="31161126282561c5d74d32ce529fddd65e0a76bd" translate="yes" xml:space="preserve">
          <source>The OID alias types have no operations of their own except for specialized input and output routines. These routines are able to accept and display symbolic names for system objects, rather than the raw numeric value that type &lt;code&gt;oid&lt;/code&gt; would use. The alias types allow simplified lookup of OID values for objects. For example, to examine the &lt;code&gt;pg_attribute&lt;/code&gt; rows related to a table &lt;code&gt;mytable&lt;/code&gt;, one could write:</source>
          <target state="translated">OIDエイリアス型には、特殊な入出力ルーチンを除いて、独自の操作はありません。これらのルーチンは、タイプ &lt;code&gt;oid&lt;/code&gt; が使用する生の数値ではなく、システムオブジェクトのシンボル名を受け入れて表示できます。エイリアスタイプを使用すると、オブジェクトのOID値を簡単に検索できます。たとえば、テーブル &lt;code&gt;mytable&lt;/code&gt; に関連する &lt;code&gt;pg_attribute&lt;/code&gt; 行を調べるには、次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="1f728998e1513edf5bb0f58e995427e26f8967db" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for the default partition of this partitioned table, or zero if this partitioned table does not have a default partition.</source>
          <target state="translated">このパーティションテーブルのデフォルトパーティションの &lt;code&gt;pg_class&lt;/code&gt; エントリのOID 、またはこのパーティションテーブルにデフォルトパーティションがない場合はゼロ。</target>
        </trans-unit>
        <trans-unit id="0e41c17d955ca3267fc3e0f5f9ba923e41ea0513" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for the table this index is for</source>
          <target state="translated">このインデックスが対象とするテーブルの &lt;code&gt;pg_class&lt;/code&gt; エントリのOID</target>
        </trans-unit>
        <trans-unit id="071dd0d457f9f27d9bee0d2e3ff6291a6f564862" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this index</source>
          <target state="translated">このインデックスの &lt;code&gt;pg_class&lt;/code&gt; エントリのOID</target>
        </trans-unit>
        <trans-unit id="f5a48c524de61d425315c3640ed2f8c5273484e3" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this partitioned table</source>
          <target state="translated">このパーティションテーブルの &lt;code&gt;pg_class&lt;/code&gt; エントリのOID</target>
        </trans-unit>
        <trans-unit id="eda438d49a92e642ba61a005c3405da4f9f1c62a" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this sequence</source>
          <target state="translated">このシーケンスの &lt;code&gt;pg_class&lt;/code&gt; エントリのOID</target>
        </trans-unit>
        <trans-unit id="303197c3c31b1c60eee9019793731af72e0dc006" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_ts_config&lt;/code&gt; entry owning this map entry</source>
          <target state="translated">このマップエントリを所有する &lt;code&gt;pg_ts_config&lt;/code&gt; エントリのOID</target>
        </trans-unit>
        <trans-unit id="f8bdb5895be29901070dfef3e22b4e60f7c2d267" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_type&lt;/code&gt; entry owning this enum value</source>
          <target state="translated">この列挙値を所有する &lt;code&gt;pg_type&lt;/code&gt; エントリのOID</target>
        </trans-unit>
        <trans-unit id="a977c33ead1b2b309c764b95248966dbf41f0217" translate="yes" xml:space="preserve">
          <source>The OID of the child table</source>
          <target state="translated">子テーブルのOID</target>
        </trans-unit>
        <trans-unit id="5ebd50be09b18866cd4d57833179194c831f037b" translate="yes" xml:space="preserve">
          <source>The OID of the data type that corresponds to this table's row type, if any (zero for indexes, which have no &lt;code&gt;pg_type&lt;/code&gt; entry)</source>
          <target state="translated">このテーブルの行タイプに対応するデータタイプのOID（ある場合）（ &lt;code&gt;pg_type&lt;/code&gt; エントリのないインデックスの場合はゼロ）</target>
        </trans-unit>
        <trans-unit id="b8b4662cb4e6288ca284849c4be148da66825b82" translate="yes" xml:space="preserve">
          <source>The OID of the database the dependent object is in, or zero for a shared object</source>
          <target state="translated">依存オブジェクトが存在するデータベースのOID、共有オブジェクトの場合はゼロ。</target>
        </trans-unit>
        <trans-unit id="898b60ec7f694b0fc006eda8e50f6b63d49620a6" translate="yes" xml:space="preserve">
          <source>The OID of the database the setting is applicable to, or zero if not database-specific</source>
          <target state="translated">設定が適用されるデータベースの OID。</target>
        </trans-unit>
        <trans-unit id="61af788beaa116f1b955c318390c380729eb624f" translate="yes" xml:space="preserve">
          <source>The OID of the database this slot is associated with, or null. Only logical slots have an associated database.</source>
          <target state="translated">このスロットが関連付けられているデータベースのOID、またはnullです。論理スロットのみが関連付けられたデータベースを持ちます。</target>
        </trans-unit>
        <trans-unit id="dffe34cbcb64c59bdcb3677d3a1fd7a1a7165871" translate="yes" xml:space="preserve">
          <source>The OID of the foreign server that contains this mapping</source>
          <target state="translated">このマッピングを含む外部サーバーの OID</target>
        </trans-unit>
        <trans-unit id="5048d68506cd122e63f767db512f5ebd84d67ed5" translate="yes" xml:space="preserve">
          <source>The OID of the function to use to perform this cast. Zero is stored if the cast method doesn't require a function.</source>
          <target state="translated">このキャストを実行するために使用する関数のOID。キャストメソッドが関数を必要としない場合はゼロが格納されます。</target>
        </trans-unit>
        <trans-unit id="59c37f70d3d21e1cf2530f6e69c1cd78c664862f" translate="yes" xml:space="preserve">
          <source>The OID of the function to use when converting output from the procedural language (e.g., return values) to the data type. Zero is stored if this operation is not supported.</source>
          <target state="translated">手続き言語からの出力(戻り値など)をデータ型に変換する際に使用する関数のOID。この操作がサポートされていない場合は0が格納されます。</target>
        </trans-unit>
        <trans-unit id="b438ec49041a86ff7da5085d6d696fab9858a564" translate="yes" xml:space="preserve">
          <source>The OID of the function to use when converting the data type for input to the procedural language (e.g., function parameters). Zero is stored if this operation is not supported.</source>
          <target state="translated">手続き言語への入力用データ型(関数パラメータなど)を変換する際に使用する関数のOID。この操作がサポートされていない場合は0が格納される。</target>
        </trans-unit>
        <trans-unit id="8427c56037bb672e3eaf5c784fadd5373d00c50d" translate="yes" xml:space="preserve">
          <source>The OID of the large object.</source>
          <target state="translated">ラージオブジェクトのOID。</target>
        </trans-unit>
        <trans-unit id="aa257a5cc909f035b6b365a8de79171496abef73" translate="yes" xml:space="preserve">
          <source>The OID of the namespace associated with this entry, or 0 if none</source>
          <target state="translated">このエントリに関連付けられた名前空間のOID。</target>
        </trans-unit>
        <trans-unit id="3c9f55892a56c80828f11ba8da0cec8b6667ea0f" translate="yes" xml:space="preserve">
          <source>The OID of the namespace for this object, if applicable; otherwise NULL.</source>
          <target state="translated">該当する場合は、このオブジェクトの名前空間の OID。</target>
        </trans-unit>
        <trans-unit id="6544239c27c8b98d678c4d86cd8cf2fb4a45d909" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this collation</source>
          <target state="translated">この照合を含むネームスペースの OID</target>
        </trans-unit>
        <trans-unit id="67632f7b86c5d28c986c07563f79e9f57ab7488a" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this configuration</source>
          <target state="translated">この構成を含むネームスペースの OID</target>
        </trans-unit>
        <trans-unit id="f78b68f0e0d540debab34518ee53138dd78afc9d" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this constraint</source>
          <target state="translated">この制約を含むネームスペースの OID。</target>
        </trans-unit>
        <trans-unit id="26651bac2ebe9b8df63182bb4f09e8b29d4375b5" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this conversion</source>
          <target state="translated">この変換を含む名前空間のOID</target>
        </trans-unit>
        <trans-unit id="58fcc7c98890e8c2834e53212732cd77ac260148" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this dictionary</source>
          <target state="translated">この辞書を含む名前空間の OID</target>
        </trans-unit>
        <trans-unit id="0ffa036dc5da9392b5ff92b8de19382988ae095b" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this function</source>
          <target state="translated">この関数を含むネームスペースの OID</target>
        </trans-unit>
        <trans-unit id="4836cfb15733aecb9038935daa22b144847fa0b0" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this operator</source>
          <target state="translated">この演算子を含むネームスペースの OID</target>
        </trans-unit>
        <trans-unit id="bd2956b2c54813a0f702f1bbd1860a3130d1cd13" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this parser</source>
          <target state="translated">このパーサを含むネームスペースの OID</target>
        </trans-unit>
        <trans-unit id="4fa4ff9a62cc6b391718b0f0a2fcbd7ba489a8a1" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this relation</source>
          <target state="translated">このリレーションを含むネームスペースの OID</target>
        </trans-unit>
        <trans-unit id="f3b00f8f6b6908679ca83ef8448db4669f9c3f2b" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this statistics object</source>
          <target state="translated">この統計情報オブジェクトを含むネームスペースの OID</target>
        </trans-unit>
        <trans-unit id="0eccd6202b6e25a82e3cb731c01941486b802fde" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this template</source>
          <target state="translated">このテンプレートを含むネームスペースの OID</target>
        </trans-unit>
        <trans-unit id="2ad5e85b9c67d0c9e6855e2f98983c857e3e9cc9" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this type</source>
          <target state="translated">この型を含む名前空間の OID</target>
        </trans-unit>
        <trans-unit id="4da576b45acb3f961f666fac031b8e0b7887d94a" translate="yes" xml:space="preserve">
          <source>The OID of the object this description pertains to</source>
          <target state="translated">この記述が対象とするオブジェクトの OID</target>
        </trans-unit>
        <trans-unit id="92fb8b43568522d54e99e8435ff353f995d4d31c" translate="yes" xml:space="preserve">
          <source>The OID of the object this security label pertains to</source>
          <target state="translated">このセキュリティラベルが属するオブジェクトの OID</target>
        </trans-unit>
        <trans-unit id="0002c6e72af222de4cb8c506a6f1bc7c20ab1dc4" translate="yes" xml:space="preserve">
          <source>The OID of the parent table</source>
          <target state="translated">親テーブルのOID</target>
        </trans-unit>
        <trans-unit id="d5ffd02286699ef3905e8a972c66ee4bb2835bfc" translate="yes" xml:space="preserve">
          <source>The OID of the role associated with this entry</source>
          <target state="translated">このエントリに関連付けられたロールのOID</target>
        </trans-unit>
        <trans-unit id="c0915654e58b310d5210b25d19abfd7806a843de" translate="yes" xml:space="preserve">
          <source>The OID of the role the setting is applicable to, or zero if not role-specific</source>
          <target state="translated">設定が適用されるロールのOID。</target>
        </trans-unit>
        <trans-unit id="c9f3ec9e29e6e5e35e198f85cfeb26802f0a6d99" translate="yes" xml:space="preserve">
          <source>The OID of the specific dependent object</source>
          <target state="translated">特定の依存オブジェクトのOID</target>
        </trans-unit>
        <trans-unit id="b9087659abb5a8df685a282e464694231a05c905" translate="yes" xml:space="preserve">
          <source>The OID of the specific object</source>
          <target state="translated">特定のオブジェクトのOID</target>
        </trans-unit>
        <trans-unit id="9442b82a85ff19f9d0307346795cdb1c1390d555" translate="yes" xml:space="preserve">
          <source>The OID of the specific referenced object</source>
          <target state="translated">特定の参照オブジェクトのOID</target>
        </trans-unit>
        <trans-unit id="3b6fda1c623aa2d59a074893167f643c66f63048" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the dependent object is in</source>
          <target state="translated">依存オブジェクトが存在するシステムカタログの OID</target>
        </trans-unit>
        <trans-unit id="45c628ea8dfbe9deffe2a6beca65b182150c549a" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the object is in</source>
          <target state="translated">オブジェクトが入っているシステムカタログのOID</target>
        </trans-unit>
        <trans-unit id="651df0c1a82da14b1a69c5c748c986ddebc8aa71" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the referenced object is in</source>
          <target state="translated">参照されているオブジェクトが存在するシステムカタログのOID</target>
        </trans-unit>
        <trans-unit id="b623975e8da0f35427faa44f2916bd8169911114" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the referenced object is in (must be a shared catalog)</source>
          <target state="translated">参照されるオブジェクトが存在するシステムカタログのOID(共有カタログでなければなりません</target>
        </trans-unit>
        <trans-unit id="d29abf904f17279c11d42dc4f5568269360fdcb9" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog this object appears in</source>
          <target state="translated">このオブジェクトが表示されているシステムカタログのOID</target>
        </trans-unit>
        <trans-unit id="067e884e18cd2aa571279cd559f882f0cf4ff2a1" translate="yes" xml:space="preserve">
          <source>The OID of the table containing this row. This column is particularly handy for queries that select from inheritance hierarchies (see &lt;a href=&quot;ddl-inherit&quot;&gt;Section 5.10&lt;/a&gt;), since without it, it's difficult to tell which individual table a row came from. The &lt;code&gt;tableoid&lt;/code&gt; can be joined against the &lt;code&gt;oid&lt;/code&gt; column of &lt;code&gt;pg_class&lt;/code&gt; to obtain the table name.</source>
          <target state="translated">この行を含むテーブルのOID。この列は、継承階層から選択するクエリ（&lt;a href=&quot;ddl-inherit&quot;&gt;セクション5.10を&lt;/a&gt;参照）で特に便利です。これがないと、行がどのテーブルからのものであるかを区別することが難しいためです。 &lt;code&gt;tableoid&lt;/code&gt; とは反対に接合することができる &lt;code&gt;oid&lt;/code&gt; のカラム &lt;code&gt;pg_class&lt;/code&gt; テーブル名を取得します。</target>
        </trans-unit>
        <trans-unit id="6a0b9e6d63b6cf8a833e5a7e3f6047bb0a93a945" translate="yes" xml:space="preserve">
          <source>The OID of the text search dictionary to consult</source>
          <target state="translated">参照するテキスト検索辞書のOID</target>
        </trans-unit>
        <trans-unit id="b6ba84785ad334e01b83ec445d3dda1ac4ac96bb" translate="yes" xml:space="preserve">
          <source>The OID of the text search parser for this configuration</source>
          <target state="translated">この設定のテキスト検索パーサの OID</target>
        </trans-unit>
        <trans-unit id="a117213bd13a98b62f97b549d2037dd5baede006" translate="yes" xml:space="preserve">
          <source>The OID of the text search template for this dictionary</source>
          <target state="translated">この辞書のテキスト検索テンプレートのOID</target>
        </trans-unit>
        <trans-unit id="58df61b40061f6a6618e8266483da7f989d95f26" translate="yes" xml:space="preserve">
          <source>The OIDs for &lt;code&gt;pg_enum&lt;/code&gt; rows follow a special rule: even-numbered OIDs are guaranteed to be ordered in the same way as the sort ordering of their enum type. That is, if two even OIDs belong to the same enum type, the smaller OID must have the smaller &lt;code&gt;enumsortorder&lt;/code&gt; value. Odd-numbered OID values need bear no relationship to the sort order. This rule allows the enum comparison routines to avoid catalog lookups in many common cases. The routines that create and alter enum types attempt to assign even OIDs to enum values whenever possible.</source>
          <target state="translated">&lt;code&gt;pg_enum&lt;/code&gt; 行のOID は特別な規則に従います。偶数のOIDは、列挙型の並べ替え順序と同じ方法で順序付けされることが保証されています。つまり、2つの偶数OIDが同じ列挙型に属している場合、OIDが小さいほど、 &lt;code&gt;enumsortorder&lt;/code&gt; 値も小さくなければなりません。奇数番号のOID値は、ソート順とは無関係である必要があります。このルールにより、enum比較ルーチンは、多くの一般的なケースでカタログ参照を回避できます。列挙型を作成および変更するルーチンは、可能な場合はいつでもOIDを列挙値に割り当てようとします。</target>
        </trans-unit>
        <trans-unit id="362f3646de7e2bebf05ad74a6325f7165ac1988c" translate="yes" xml:space="preserve">
          <source>The OpenSSL default order for &lt;code&gt;HIGH&lt;/code&gt; is problematic because it orders 3DES higher than AES128. This is wrong because 3DES offers less security than AES128, and it is also much slower. &lt;code&gt;+3DES&lt;/code&gt; reorders it after all other &lt;code&gt;HIGH&lt;/code&gt; and &lt;code&gt;MEDIUM&lt;/code&gt; ciphers.</source>
          <target state="translated">&lt;code&gt;HIGH&lt;/code&gt; のOpenSSLのデフォルトの順序は、AES128よりも3DES高いため、問題があります。3DESはAES128よりもセキュリティが低く、速度も非常に遅いため、これは誤りです。 &lt;code&gt;+3DES&lt;/code&gt; は、他のすべての &lt;code&gt;HIGH&lt;/code&gt; および &lt;code&gt;MEDIUM&lt;/code&gt; 暗号の後にそれを並べ替えます。</target>
        </trans-unit>
        <trans-unit id="b73c1bd60aad8104323371d01b1ec1a8338ede73" translate="yes" xml:space="preserve">
          <source>The Oversized-Attribute Storage Technique</source>
          <target state="translated">特大属性収納術</target>
        </trans-unit>
        <trans-unit id="e0b1bfcde4d47951e13640eda18c565a127fb8e6" translate="yes" xml:space="preserve">
          <source>The POSIX pattern language is described in much greater detail below.</source>
          <target state="translated">POSIXパターン言語については、以下に詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="153ece47c4d9b24a5da118c8706404d098e93a76" translate="yes" xml:space="preserve">
          <source>The PostgreSQL &lt;code&gt;xml&lt;/code&gt; data type can only hold a value in &lt;code&gt;DOCUMENT&lt;/code&gt; or &lt;code&gt;CONTENT&lt;/code&gt; form. An XQuery/XPath expression context item must be a single XML node or atomic value, but XPath 1.0 further restricts it to be only an XML node, and has no node type allowing &lt;code&gt;CONTENT&lt;/code&gt;. The upshot is that a well-formed &lt;code&gt;DOCUMENT&lt;/code&gt; is the only form of XML value that PostgreSQL can supply as an XPath context item.</source>
          <target state="translated">PostgreSQL &lt;code&gt;xml&lt;/code&gt; データ型は、 &lt;code&gt;DOCUMENT&lt;/code&gt; または &lt;code&gt;CONTENT&lt;/code&gt; 形式の値のみを保持できます。XQuery / XPath式のコンテキストアイテムは単一のXMLノードまたはアトミック値である必要がありますが、XPath 1.0ではさらに、XMLノードのみに制限され、 &lt;code&gt;CONTENT&lt;/code&gt; を許可するノードタイプがありません。結局のところ、整形式の &lt;code&gt;DOCUMENT&lt;/code&gt; は、PostgreSQLがXPathコンテキスト項目として提供できるXML値の唯一の形式であるということです。</target>
        </trans-unit>
        <trans-unit id="8019e62373b33be0ae1394da9ad186299d75d149" translate="yes" xml:space="preserve">
          <source>The PostgreSQL concept of tablespaces is not part of the standard. Hence, the clause &lt;code&gt;TABLESPACE&lt;/code&gt; is an extension.</source>
          <target state="translated">PostgreSQLのテーブルスペースの概念は、標準の一部ではありません。したがって、 &lt;code&gt;TABLESPACE&lt;/code&gt; 節は拡張です。</target>
        </trans-unit>
        <trans-unit id="36ca8d540410a034c5a8f32708649004d256e17f" translate="yes" xml:space="preserve">
          <source>The PostgreSQL concept of tablespaces is not part of the standard. Hence, the clauses &lt;code&gt;TABLESPACE&lt;/code&gt; and &lt;code&gt;USING INDEX TABLESPACE&lt;/code&gt; are extensions.</source>
          <target state="translated">PostgreSQLのテーブルスペースの概念は、標準の一部ではありません。したがって、句 &lt;code&gt;TABLESPACE&lt;/code&gt; および &lt;code&gt;USING INDEX TABLESPACE&lt;/code&gt; は拡張です。</target>
        </trans-unit>
        <trans-unit id="74677c1410d0f3c49eba1a7361732a37abea01cf" translate="yes" xml:space="preserve">
          <source>The PostgreSQL formatting functions provide a powerful set of tools for converting various data types (date/time, integer, floating point, numeric) to formatted strings and for converting from formatted strings to specific data types. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-TABLE&quot;&gt;Table 9.24&lt;/a&gt; lists them. These functions all follow a common calling convention: the first argument is the value to be formatted and the second argument is a template that defines the output or input format.</source>
          <target state="translated">PostgreSQLのフォーマット関数は、さまざまなデータ型（日付/時刻、整数、浮動小数点、数値）をフォーマットされた文字列に変換したり、フォーマットされた文字列から特定のデータ型に変換したりするための強力なツールセットを提供します。&lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-TABLE&quot;&gt;表9.24&lt;/a&gt;にそれらを示します。これらの関数はすべて共通の呼び出し規約に従います。最初の引数はフォーマットされる値で、2番目の引数は出力または入力フォーマットを定義するテンプレートです。</target>
        </trans-unit>
        <trans-unit id="477d95f901512677a235f7ee46a8f81ecd4001b6" translate="yes" xml:space="preserve">
          <source>The PostgreSQL operator catalog has several entries for the infix operator &lt;code&gt;&amp;lt;@&lt;/code&gt;, but the only two that could possibly accept an integer array on the left-hand side are array inclusion (&lt;code&gt;anyarray&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;anyarray&lt;/code&gt;) and range inclusion (&lt;code&gt;anyelement&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;anyrange&lt;/code&gt;). Since none of these polymorphic pseudo-types (see &lt;a href=&quot;datatype-pseudo&quot;&gt;Section 8.21&lt;/a&gt;) are considered preferred, the parser cannot resolve the ambiguity on that basis. However, &lt;a href=&quot;typeconv-oper#OP-RESOL-LAST-UNKNOWN&quot;&gt;Step 3.f&lt;/a&gt; tells it to assume that the unknown-type literal is of the same type as the other input, that is, integer array. Now only one of the two operators can match, so array inclusion is selected. (Had range inclusion been selected, we would have gotten an error, because the string does not have the right format to be a range literal.)</source>
          <target state="translated">PostgreSQL演算子カタログには、中置演算子 &lt;code&gt;&amp;lt;@&lt;/code&gt; のエントリがいくつかありますが、左側の整数配列を受け入れる可能性があるのは、配列の包含（ &lt;code&gt;anyarray&lt;/code&gt; &lt;code&gt;&amp;lt;@&lt;/code&gt; &lt;code&gt;anyarray&lt;/code&gt; ）と範囲の包含（ &lt;code&gt;anyelement&lt;/code&gt; &lt;code&gt;&amp;lt;@&lt;/code&gt; &lt;code&gt;anyrange&lt;/code&gt; ）の2つだけです。これらのポリモーフィックな疑似タイプ（&lt;a href=&quot;datatype-pseudo&quot;&gt;8.21節を&lt;/a&gt;参照）はどれも優先とは見なされないため、パーサーはあいまいさをそれに基づいて解決できません。ただし、&lt;a href=&quot;typeconv-oper#OP-RESOL-LAST-UNKNOWN&quot;&gt;ステップ3.f&lt;/a&gt;不明なタイプのリテラルが他の入力と同じタイプ、つまり整数配列であると想定するように指示します。これで、2つの演算子のうち1つだけが一致できるため、配列の包含が選択されます。（範囲の包含が選択されていると、文字列が範囲リテラルになる正しい形式を持たないため、エラーが発生します。）</target>
        </trans-unit>
        <trans-unit id="7623f7756c9bed57d74564163e6b686074d22548" translate="yes" xml:space="preserve">
          <source>The PostgreSQL operator catalog has several entries for the prefix operator &lt;code&gt;@&lt;/code&gt;, all of which implement absolute-value operations for various numeric data types. One of these entries is for type &lt;code&gt;float8&lt;/code&gt;, which is the preferred type in the numeric category. Therefore, PostgreSQL will use that entry when faced with an &lt;code&gt;unknown&lt;/code&gt; input:</source>
          <target state="translated">PostgreSQL演算子カタログには、プレフィックス演算子 &lt;code&gt;@&lt;/code&gt; のエントリがいくつかあります。これらのエントリはすべて、さまざまな数値データ型の絶対値演算を実装しています。これらのエントリの1つは、数値カテゴリで推奨される型である &lt;code&gt;float8&lt;/code&gt; 型用です。したがって、PostgreSQLは &lt;code&gt;unknown&lt;/code&gt; 入力に直面したときにそのエントリを使用します。</target>
        </trans-unit>
        <trans-unit id="0de6cec8150a5ca1beb884d1dae8f1be83758f61" translate="yes" xml:space="preserve">
          <source>The PostgreSQL query planner relies on statistical information about the contents of tables in order to generate good plans for queries. These statistics are gathered by the &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; command, which can be invoked by itself or as an optional step in &lt;code&gt;VACUUM&lt;/code&gt;. It is important to have reasonably accurate statistics, otherwise poor choices of plans might degrade database performance.</source>
          <target state="translated">PostgreSQLクエリプランナーは、クエリの適切なプランを生成するために、テーブルの内容に関する統計情報に依存しています。これらの統計は&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドによって収集されます。ANALYZEコマンドは、単独で、または &lt;code&gt;VACUUM&lt;/code&gt; のオプションのステップとして呼び出すことができます。適度に正確な統計を取得することが重要です。そうしないと、計画の選択が不十分なためにデータベースのパフォーマンスが低下する可能性があります。</target>
        </trans-unit>
        <trans-unit id="091f965ebb32941711ea5df90e349daf215494b9" translate="yes" xml:space="preserve">
          <source>The PostgreSQL rule system allows one to define an alternative action to be performed on insertions, updates, or deletions in database tables. Roughly speaking, a rule causes additional commands to be executed when a given command on a given table is executed. Alternatively, an &lt;code&gt;INSTEAD&lt;/code&gt; rule can replace a given command by another, or cause a command not to be executed at all. Rules are used to implement SQL views as well. It is important to realize that a rule is really a command transformation mechanism, or command macro. The transformation happens before the execution of the command starts. If you actually want an operation that fires independently for each physical row, you probably want to use a trigger, not a rule. More information about the rules system is in &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;.</source>
          <target state="translated">PostgreSQLルールシステムを使用すると、データベーステーブルの挿入、更新、または削除時に実行する代替アクションを定義できます。大まかに言えば、ルールは、特定のテーブルで特定のコマンドが実行されるときに追加のコマンドを実行させます。または、 &lt;code&gt;INSTEAD&lt;/code&gt; ルールは、特定のコマンドを別のコマンドで置き換えるか、コマンドをまったく実行しないようにすることができます。ルールは、SQLビューの実装にも使用されます。ルールは、実際にはコマンド変換メカニズム、つまりコマンドマクロであることを理解することが重要です。変換は、コマンドの実行が開始する前に行われます。物理的な行ごとに個別に起動する操作が実際に必要な場合は、ルールではなくトリガーを使用することをお勧めします。ルールシステムの詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;第40章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="10a690ef1ea7666469e6c355dbc334d6d1d70eb6" translate="yes" xml:space="preserve">
          <source>The PostgreSQL scanner/parser divides lexical elements into five fundamental categories: integers, non-integer numbers, strings, identifiers, and key words. Constants of most non-numeric types are first classified as strings. The SQL language definition allows specifying type names with strings, and this mechanism can be used in PostgreSQL to start the parser down the correct path. For example, the query:</source>
          <target state="translated">PostgreSQLスキャナ/パーサは、字句要素を整数、非整数、文字列、識別子、キーワードの5つの基本的なカテゴリに分類します。ほとんどの非数値型の定数は最初に文字列として分類されます。SQL言語の定義では、文字列で型名を指定することができ、PostgreSQLではこのメカニズムを使用してパーサを正しい経路で開始することができます。例えば、クエリ。</target>
        </trans-unit>
        <trans-unit id="b6aed6106f2d7424b2bbb821dba77f382392bc5d" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server can handle multiple concurrent connections from clients. To achieve this it starts (&amp;ldquo;forks&amp;rdquo;) a new process for each connection. From that point on, the client and the new server process communicate without intervention by the original &lt;code&gt;postgres&lt;/code&gt; process. Thus, the master server process is always running, waiting for client connections, whereas client and associated server processes come and go. (All of this is of course invisible to the user. We only mention it here for completeness.)</source>
          <target state="translated">PostgreSQLサーバーは、クライアントからの複数の同時接続を処理できます。これを実現するために、接続ごとに新しいプロセスを開始（「フォーク」）します。その時点から、クライアントと新しいサーバープロセスは、元の &lt;code&gt;postgres&lt;/code&gt; プロセスの介入なしに通信します。したがって、マスターサーバープロセスは常に実行され、クライアント接続を待機しますが、クライアントと関連するサーバープロセスは行き来します。 （もちろん、これらはすべてユーザーには見えません。ここでは、完全を期すためにのみ言及しています。）</target>
        </trans-unit>
        <trans-unit id="7af0f9ca01829c95b3c4cfa20671b04ccaa7a1b4" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server uses one process per connection so you should provide for at least as many processes as allowed connections, in addition to what you need for the rest of your system. This is usually not a problem but if you run several servers on one machine things might get tight.</source>
          <target state="translated">PostgreSQLサーバは1つの接続につき1つのプロセスを使用しますので、システムの残りの部分に必要な数に加えて、少なくとも許可された接続数だけのプロセスを用意しなければなりません。これは通常問題ではありませんが、1台のマシン上で複数のサーバを実行している場合、窮屈になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="929274b54effcc47ded1784455530166b7871347" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server will listen for both normal and GSSAPI-encrypted connections on the same TCP port, and will negotiate with any connecting client on whether to use GSSAPI for encryption (and for authentication). By default, this decision is up to the client (which means it can be downgraded by an attacker); see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt; about setting up the server to require the use of GSSAPI for some or all connections.</source>
          <target state="translated">PostgreSQLサーバーは、同じTCPポートで通常の接続とGSSAPIで暗号化された接続の両方をリッスンし、暗号化（および認証）にGSSAPIを使用するかどうかについて接続しているクライアントと交渉します。デフォルトでは、この決定はクライアント次第です（つまり、攻撃者によってダウングレードされる可能性があります）。一部またはすべての接続でGSSAPIの使用を要求するようにサーバーを設定する方法については、&lt;a href=&quot;auth-pg-hba-conf&quot;&gt;セクション20.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f4cf80f6b7604fb8b47859e4bbfb35130b5f3d5d" translate="yes" xml:space="preserve">
          <source>The PostgreSQL source distribution includes several examples of index methods implemented using GiST. The core system currently provides text search support (indexing for &lt;code&gt;tsvector&lt;/code&gt; and &lt;code&gt;tsquery&lt;/code&gt;) as well as R-Tree equivalent functionality for some of the built-in geometric data types (see &lt;code&gt;src/backend/access/gist/gistproc.c&lt;/code&gt;). The following &lt;code&gt;contrib&lt;/code&gt; modules also contain GiST operator classes:</source>
          <target state="translated">PostgreSQLソース配布には、GiSTを使用して実装されたインデックスメソッドのいくつかの例が含まれています。コアシステムは現在、テキスト検索サポート（ &lt;code&gt;tsvector&lt;/code&gt; および &lt;code&gt;tsquery&lt;/code&gt; のインデックス作成）と、一部の組み込みのジオメトリックデータタイプ（ &lt;code&gt;src/backend/access/gist/gistproc.c&lt;/code&gt; を参照）のRツリー同等の機能を提供しています。次の &lt;code&gt;contrib&lt;/code&gt; モジュールには、GiST演算子クラスも含まれています。</target>
        </trans-unit>
        <trans-unit id="f0456fd311416d751f4442303736e9783a5f29ea" translate="yes" xml:space="preserve">
          <source>The PostgreSQL source distribution includes several examples of index operator classes for SP-GiST, as described in &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 65.1&lt;/a&gt;. Look into &lt;code&gt;src/backend/access/spgist/&lt;/code&gt; and &lt;code&gt;src/backend/utils/adt/&lt;/code&gt; to see the code.</source>
          <target state="translated">PostgreSQLのソースディストリビューションには、&lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;表65.1&lt;/a&gt;に示すように、SP-GiSTのインデックス演算子クラスのいくつかの例が含まれています。見 &lt;code&gt;src/backend/access/spgist/&lt;/code&gt; および &lt;code&gt;src/backend/utils/adt/&lt;/code&gt; コードを表示します。</target>
        </trans-unit>
        <trans-unit id="da6bb87f4fbef7ca2cd7285a5ff15baca5680b91" translate="yes" xml:space="preserve">
          <source>The PostgreSQL type system contains a number of special-purpose entries that are collectively called &lt;em&gt;pseudo-types&lt;/em&gt;. A pseudo-type cannot be used as a column data type, but it can be used to declare a function's argument or result type. Each of the available pseudo-types is useful in situations where a function's behavior does not correspond to simply taking or returning a value of a specific SQL data type. &lt;a href=&quot;datatype-pseudo#DATATYPE-PSEUDOTYPES-TABLE&quot;&gt;Table 8.27&lt;/a&gt; lists the existing pseudo-types.</source>
          <target state="translated">PostgreSQLの型システムには、まとめて&lt;em&gt;疑似型&lt;/em&gt;と呼ばれる特別な目的のエントリがいくつか含まれてい&lt;em&gt;ます&lt;/em&gt;。疑似型は列のデータ型として使用できませんが、関数の引数または結果の型を宣言するために使用できます。使用可能な各疑似型は、関数の動作が特定のSQLデータ型の値を単に取得または返すことに対応していない状況で役立ちます。&lt;a href=&quot;datatype-pseudo#DATATYPE-PSEUDOTYPES-TABLE&quot;&gt;表8.27&lt;/a&gt;に、既存の疑似タイプを示します。</target>
        </trans-unit>
        <trans-unit id="3627ccc448cafae762325bbb25d1d00e8338b2f1" translate="yes" xml:space="preserve">
          <source>The PostgreSQL-specific functions &lt;code&gt;xpath()&lt;/code&gt; and &lt;code&gt;xpath_exists()&lt;/code&gt; query XML documents using the XPath language. PostgreSQL also provides XPath-only variants of the standard functions &lt;code&gt;XMLEXISTS&lt;/code&gt; and &lt;code&gt;XMLTABLE&lt;/code&gt;, which officially use the XQuery language. For all of these functions, PostgreSQL relies on the libxml2 library, which provides only XPath 1.0.</source>
          <target state="translated">PostgreSQL固有の関数 &lt;code&gt;xpath()&lt;/code&gt; および &lt;code&gt;xpath_exists()&lt;/code&gt; は、XPath言語を使用してXMLドキュメントをクエリします。 PostgreSQLは、XQuery言語を公式に使用する標準関数 &lt;code&gt;XMLEXISTS&lt;/code&gt; および &lt;code&gt;XMLTABLE&lt;/code&gt; の XPathのみのバリアントも提供します。これらすべての関数について、PostgreSQLはXPath 1.0のみを提供するlibxml2ライブラリに依存しています。</target>
        </trans-unit>
        <trans-unit id="efd965ec5103a44f1272738f66a9e9d5dd0aabd5" translate="yes" xml:space="preserve">
          <source>The ROW keyword is actually optional as long as you have more than one field in the expression, so these can be simplified to:</source>
          <target state="translated">ROWキーワードは、式の中に複数のフィールドがある限り、実際にはオプションですので、これらは簡略化できます。</target>
        </trans-unit>
        <trans-unit id="091f62aabb99c30a476910bd3ba420fa9f860db6" translate="yes" xml:space="preserve">
          <source>The Repeatable Read mode provides a rigorous guarantee that each transaction sees a completely stable view of the database. However, this view will not necessarily always be consistent with some serial (one at a time) execution of concurrent transactions of the same level. For example, even a read only transaction at this level may see a control record updated to show that a batch has been completed but &lt;em&gt;not&lt;/em&gt; see one of the detail records which is logically part of the batch because it read an earlier revision of the control record. Attempts to enforce business rules by transactions running at this isolation level are not likely to work correctly without careful use of explicit locks to block conflicting transactions.</source>
          <target state="translated">反復可能読み取りモードは、各トランザクションがデータベースの完全に安定したビューを見ることを厳密に保証します。ただし、このビューは、同じレベルの同時トランザクションのいくつかの（一度に1つの）逐次実行と常に一貫しているとは限りません。たとえば、このレベルの読み取り専用トランザクションでも、バッチが完了したことを示すように更新された制御レコードが表示されますが、制御レコードの以前のリビジョンを読み取ったため、論理的にバッチの一部である詳細レコードの1つは表示され&lt;em&gt;ません。&lt;/em&gt;。この分離レベルで実行されているトランザクションによってビジネスルールを適用しようとすると、競合するトランザクションをブロックする明示的なロックを注意深く使用しないと、正しく機能しない可能性があります。</target>
        </trans-unit>
        <trans-unit id="bebce75022660ba392e40784c2cdda41c615a64f" translate="yes" xml:space="preserve">
          <source>The SCRAM specification dictates that the password is also in UTF-8, and is processed with the &lt;em&gt;SASLprep&lt;/em&gt; algorithm. PostgreSQL, however, does not require UTF-8 to be used for the password. When a user's password is set, it is processed with SASLprep as if it was in UTF-8, regardless of the actual encoding used. However, if it is not a legal UTF-8 byte sequence, or it contains UTF-8 byte sequences that are prohibited by the SASLprep algorithm, the raw password will be used without SASLprep processing, instead of throwing an error. This allows the password to be normalized when it is in UTF-8, but still allows a non-UTF-8 password to be used, and doesn't require the system to know which encoding the password is in.</source>
          <target state="translated">SCRAM仕様では、パスワードもUTF-8であり、&lt;em&gt;SASLprep&lt;/em&gt;アルゴリズムで処理されることが&lt;em&gt;規定&lt;/em&gt;されて&lt;em&gt;い&lt;/em&gt;ます。ただし、PostgreSQLでは、パスワードにUTF-8を使用する必要はありません。ユーザーのパスワードが設定されると、実際に使用されているエンコードに関係なく、UTF-8であるかのようにSASLprepで処理されます。ただし、正当なUTF-8バイトシーケンスではない場合、またはSASLprepアルゴリズムで禁止されているUTF-8バイトシーケンスが含まれている場合、エラーをスローする代わりに、SASLprep処理なしで未加工パスワードが使用されます。これにより、UTF-8のパスワードを正規化できますが、UTF-8以外のパスワードを使用することもできます。また、システムがパスワードのエンコーディングを知っている必要はありません。</target>
        </trans-unit>
        <trans-unit id="0e7a1522eba0328b9be11871eb393a000b642ba7" translate="yes" xml:space="preserve">
          <source>The SP-GiST core can override the results of the operator class's &lt;code&gt;picksplit&lt;/code&gt; function when &lt;code&gt;picksplit&lt;/code&gt; fails to divide the supplied leaf values into at least two node categories. When this happens, the new inner tuple is created with multiple nodes that each have the same label (if any) that &lt;code&gt;picksplit&lt;/code&gt; gave to the one node it did use, and the leaf values are divided at random among these equivalent nodes. The &lt;code&gt;allTheSame&lt;/code&gt; flag is set on the inner tuple to warn the &lt;code&gt;choose&lt;/code&gt; and &lt;code&gt;inner_consistent&lt;/code&gt; functions that the tuple does not have the node set that they might otherwise expect.</source>
          <target state="translated">指定されたリーフ値を &lt;code&gt;picksplit&lt;/code&gt; が少なくとも2つのノードカテゴリに分割できない場合、SP-GiSTコアは演算子クラスの &lt;code&gt;picksplit&lt;/code&gt; 関数の結果をオーバーライドできます。これが発生した場合、新しい内部タプルは、 &lt;code&gt;picksplit&lt;/code&gt; が使用した1つのノードに与えた同じラベル（存在する場合）を持つ複数のノードで作成され、リーフ値はこれらの同等のノード間でランダムに分割されます。 &lt;code&gt;allTheSame&lt;/code&gt; のフラグは警告するために、内側のタプルに設定されている &lt;code&gt;choose&lt;/code&gt; と &lt;code&gt;inner_consistent&lt;/code&gt; タプルが、彼らはそう期待するかもしれないことをノードセットを持っていないという機能を。</target>
        </trans-unit>
        <trans-unit id="d1b14a46877d8df03142e17f562b21c36e25830b" translate="yes" xml:space="preserve">
          <source>The SP-GiST core code takes care of null entries. Although SP-GiST indexes do store entries for nulls in indexed columns, this is hidden from the index operator class code: no null index entries or search conditions will ever be passed to the operator class methods. (It is assumed that SP-GiST operators are strict and so cannot succeed for null values.) Null values are therefore not discussed further here.</source>
          <target state="translated">SP-GISTコアコードはヌルエントリの処理を行います。SP-GISTインデックスはインデックス化された列にヌルのためのエントリを格納しますが、これはインデックス演算子クラスのコードからは隠されています:ヌルのインデックスエントリや検索条件が演算子クラスのメソッドに渡されることはありません。(SP-GiST演算子は厳密であるため、ヌル値に対しては成功しないことが想定されています)。したがって、ヌル値についてはここでは説明しません。</target>
        </trans-unit>
        <trans-unit id="fe87973f3ef5a0d6b6662bce168960f63417cd65" translate="yes" xml:space="preserve">
          <source>The SQL &lt;code&gt;CASE&lt;/code&gt; expression is a generic conditional expression, similar to if/else statements in other programming languages:</source>
          <target state="translated">SQL &lt;code&gt;CASE&lt;/code&gt; 式は、他のプログラミング言語のif / elseステートメントに似た、一般的な条件式です。</target>
        </trans-unit>
        <trans-unit id="d48ab325670cd3e1aa8741d57a661891b103e0ac" translate="yes" xml:space="preserve">
          <source>The SQL command &lt;code&gt;SET TIME ZONE&lt;/code&gt; sets the time zone for the session. This is an alternative spelling of &lt;code&gt;SET TIMEZONE TO&lt;/code&gt; with a more SQL-spec-compatible syntax.</source>
          <target state="translated">SQLコマンド &lt;code&gt;SET TIME ZONE&lt;/code&gt; は、セッションのタイムゾーンを設定します。これは、SQL仕様互換の構文を使用した &lt;code&gt;SET TIMEZONE TO&lt;/code&gt; の代替スペルです。</target>
        </trans-unit>
        <trans-unit id="64de07c340bdb76d49ccd2451af6603ff373cc2b" translate="yes" xml:space="preserve">
          <source>The SQL declaration of the function must look like this:</source>
          <target state="translated">関数のSQL宣言は次のようにしてください。</target>
        </trans-unit>
        <trans-unit id="d7b4645499046b1f0731ca7d87e83bccfa0f031d" translate="yes" xml:space="preserve">
          <source>The SQL script will be written to the standard output. Use the &lt;code&gt;-f&lt;/code&gt;/&lt;code&gt;--file&lt;/code&gt; option or shell operators to redirect it into a file.</source>
          <target state="translated">SQLスクリプトが標準出力に書き込まれます。 &lt;code&gt;-f&lt;/code&gt; / &lt;code&gt;--file&lt;/code&gt; オプションまたはシェル演算子を使用して、ファイルにリダイレクトします。</target>
        </trans-unit>
        <trans-unit id="e638b08fc8b7ed4b2fdc056d0b48506d414e8ee3" translate="yes" xml:space="preserve">
          <source>The SQL specification requires row-wise comparison to return NULL if the result depends on comparing two NULL values or a NULL and a non-NULL. PostgreSQL does this only when comparing the results of two row constructors (as in &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.23.5&lt;/a&gt;) or comparing a row constructor to the output of a subquery (as in &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt;). In other contexts where two composite-type values are compared, two NULL field values are considered equal, and a NULL is considered larger than a non-NULL. This is necessary in order to have consistent sorting and indexing behavior for composite types.</source>
          <target state="translated">SQL仕様では、結果が2つのNULL値またはNULLと非NULLの比較に依存する場合、NULLを返すために行ごとの比較が必要です。PostgreSQLがこれを行うのは、2つの行コンストラクタの結果を比較する場合（&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;セクション9.23.5のように&lt;/a&gt;）または行コンストラクタをサブクエリの出力と比較するとき（&lt;a href=&quot;functions-subquery&quot;&gt;セクション9.22のように&lt;/a&gt;）だけです。2つの複合型値が比較される他のコンテキストでは、2つのNULLフィールド値は等しいと見なされ、NULLは非NULLよりも大きいと見なされます。これは、複合型のソートおよびインデックス付け動作に一貫性を持たせるために必要です。</target>
        </trans-unit>
        <trans-unit id="22ab3c86af000737aa210aeaf592af19c218233b" translate="yes" xml:space="preserve">
          <source>The SQL standard (not XQuery itself) attempts to cater for more variants of &amp;ldquo;newline&amp;rdquo; than POSIX does. The newline-sensitive matching options described above consider only ASCII NL (&lt;code&gt;\n&lt;/code&gt;) to be a newline, but SQL would have us treat CR (&lt;code&gt;\r&lt;/code&gt;), CRLF (&lt;code&gt;\r\n&lt;/code&gt;) (a Windows-style newline), and some Unicode-only characters like LINE SEPARATOR (U+2028) as newlines as well. Notably, &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;\s&lt;/code&gt; should count &lt;code&gt;\r\n&lt;/code&gt; as one character not two according to SQL.</source>
          <target state="translated">SQL標準（XQuery自体ではない）は、POSIXよりも多くの「改行」のバリアントに対応しようとします。上記の改行を区別するマッチングオプションでは、ASCII NL（ &lt;code&gt;\n&lt;/code&gt; ）のみを改行と見なしますが、SQLではCR（ &lt;code&gt;\r&lt;/code&gt; ）、CRLF（ &lt;code&gt;\r\n&lt;/code&gt; ）（Windowsスタイルの改行）、および改行としてのLINE SEPARATOR（U + 2028）などのUnicode専用文字。注目すべきは、 &lt;code&gt;.&lt;/code&gt; SQLによると、 &lt;code&gt;\s&lt;/code&gt; は &lt;code&gt;\r\n&lt;/code&gt; を2文字ではなく1文字としてカウントする必要があります。</target>
        </trans-unit>
        <trans-unit id="3ca979281ade8cf94abb51fcd1544322941db9bd" translate="yes" xml:space="preserve">
          <source>The SQL standard allows a &lt;code&gt;DEFAULT CHARACTER SET&lt;/code&gt; clause in &lt;code&gt;CREATE SCHEMA&lt;/code&gt;, as well as more subcommand types than are presently accepted by PostgreSQL.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;CREATE SCHEMA&lt;/code&gt; の &lt;code&gt;DEFAULT CHARACTER SET&lt;/code&gt; 句、および現在PostgreSQLで受け入れられているよりも多くのサブコマンドタイプを許可しています。</target>
        </trans-unit>
        <trans-unit id="a28253dba0b95d8667501243721aade5c4069637" translate="yes" xml:space="preserve">
          <source>The SQL standard allows cursors only in embedded SQL and in modules. PostgreSQL permits cursors to be used interactively.</source>
          <target state="translated">標準SQLでは、組み込みSQLとモジュール内でのみカーソルを使用することができます。PostgreSQLでは、カーソルを対話的に使用することができます。</target>
        </trans-unit>
        <trans-unit id="7005659d6b42749138703e7ef74f259a352e97f5" translate="yes" xml:space="preserve">
          <source>The SQL standard allows only &lt;code&gt;FROM&lt;/code&gt; preceding the cursor name; the option to use &lt;code&gt;IN&lt;/code&gt;, or to leave them out altogether, is an extension.</source>
          <target state="translated">SQL標準では、カーソル名の前に &lt;code&gt;FROM&lt;/code&gt; のみを許可しています。 &lt;code&gt;IN&lt;/code&gt; を使用するオプション、またはそれらを完全に省略するオプションは、拡張機能です。</target>
        </trans-unit>
        <trans-unit id="69a8fc7cc008eb25ed064f0d1fdca190a5bf8644" translate="yes" xml:space="preserve">
          <source>The SQL standard allows some other expressions to appear in place of the literal &lt;code&gt;user_name&lt;/code&gt;, but these options are not important in practice. PostgreSQL allows identifier syntax (&lt;code&gt;&quot;username&quot;&lt;/code&gt;), which SQL does not. SQL does not allow this command during a transaction; PostgreSQL does not make this restriction because there is no reason to. The &lt;code&gt;SESSION&lt;/code&gt; and &lt;code&gt;LOCAL&lt;/code&gt; modifiers are a PostgreSQL extension, as is the &lt;code&gt;RESET&lt;/code&gt; syntax.</source>
          <target state="translated">SQL標準では、他のいくつかの式をリテラル &lt;code&gt;user_name&lt;/code&gt; の代わりに使用できますが、これらのオプションは実際には重要ではありません。PostgreSQLでは識別子構文（ &lt;code&gt;&quot;username&quot;&lt;/code&gt; ）を使用できますが、SQLでは使用できません。SQLでは、トランザクション中にこのコマンドを使用できません。PostgreSQLには理由がないため、この制限はありません。 &lt;code&gt;SESSION&lt;/code&gt; および &lt;code&gt;LOCAL&lt;/code&gt; 修飾子はようで、PostgreSQLの拡張です &lt;code&gt;RESET&lt;/code&gt; の構文。</target>
        </trans-unit>
        <trans-unit id="b623e7f141c55510760b9b77e9eb99f9e4321e9e" translate="yes" xml:space="preserve">
          <source>The SQL standard also distinguishes between global and local temporary tables, where a local temporary table has a separate set of contents for each SQL module within each session, though its definition is still shared across sessions. Since PostgreSQL does not support SQL modules, this distinction is not relevant in PostgreSQL.</source>
          <target state="translated">SQL標準では、グローバルテンポラリテーブルとローカルテンポラリテーブルを区別しています。ローカルテンポラリテーブルは、各セッション内の各SQLモジュールに対して別々の内容のセットを持っていますが、その定義はセッション間で共有されています。PostgreSQLはSQLモジュールをサポートしていないので、PostgreSQLではこの区別は関係ありません。</target>
        </trans-unit>
        <trans-unit id="6f9fa0f99df0f3d6e4d172f087bbf08f499d13c0" translate="yes" xml:space="preserve">
          <source>The SQL standard and PostgreSQL-implemented transaction isolation levels are described in &lt;a href=&quot;transaction-iso#MVCC-ISOLEVEL-TABLE&quot;&gt;Table 13.1&lt;/a&gt;.</source>
          <target state="translated">SQL標準およびPostgreSQL実装のトランザクション分離レベルについては、&lt;a href=&quot;transaction-iso#MVCC-ISOLEVEL-TABLE&quot;&gt;表13.1で&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="e49f9cf60061c8b5fe47367c7175f7b9d12754fa" translate="yes" xml:space="preserve">
          <source>The SQL standard calls databases &amp;ldquo;catalogs&amp;rdquo;, but there is no difference in practice.</source>
          <target state="translated">SQL標準ではデータベースを「カタログ」と呼んでいますが、実際には違いはありません。</target>
        </trans-unit>
        <trans-unit id="f6b9dd41b616b1103c4995e9bab7f0a1474529d1" translate="yes" xml:space="preserve">
          <source>The SQL standard defines &lt;code&gt;DROP ROLE&lt;/code&gt;, but it allows only one role to be dropped at a time, and it specifies different privilege requirements than PostgreSQL uses.</source>
          <target state="translated">SQL標準では &lt;code&gt;DROP ROLE&lt;/code&gt; を定義していますが、一度に1つのロールのみを削除でき、PostgreSQLが使用するのとは異なる特権要件を指定しています。</target>
        </trans-unit>
        <trans-unit id="89dd410d4b1dc70cede977d3716ec82a83bd84ad" translate="yes" xml:space="preserve">
          <source>The SQL standard defines &lt;code&gt;FETCH&lt;/code&gt; for use in embedded SQL only. The variant of &lt;code&gt;FETCH&lt;/code&gt; described here returns the data as if it were a &lt;code&gt;SELECT&lt;/code&gt; result rather than placing it in host variables. Other than this point, &lt;code&gt;FETCH&lt;/code&gt; is fully upward-compatible with the SQL standard.</source>
          <target state="translated">SQL標準では、埋め込みSQLでのみ使用する &lt;code&gt;FETCH&lt;/code&gt; を定義しています。ここで説明する &lt;code&gt;FETCH&lt;/code&gt; のバリアントは、データをホスト変数に置くのではなく、 &lt;code&gt;SELECT&lt;/code&gt; 結果であるかのようにデータを返します。この点を &lt;code&gt;FETCH&lt;/code&gt; 、FETCHはSQL標準と完全に上位互換性があります。</target>
        </trans-unit>
        <trans-unit id="0433545c375e6f7a87b9a6951397354ec73ee790" translate="yes" xml:space="preserve">
          <source>The SQL standard defines a &lt;code&gt;RESPECT NULLS&lt;/code&gt; or &lt;code&gt;IGNORE NULLS&lt;/code&gt; option for &lt;code&gt;lead&lt;/code&gt;, &lt;code&gt;lag&lt;/code&gt;, &lt;code&gt;first_value&lt;/code&gt;, &lt;code&gt;last_value&lt;/code&gt;, and &lt;code&gt;nth_value&lt;/code&gt;. This is not implemented in PostgreSQL: the behavior is always the same as the standard's default, namely &lt;code&gt;RESPECT NULLS&lt;/code&gt;. Likewise, the standard's &lt;code&gt;FROM FIRST&lt;/code&gt; or &lt;code&gt;FROM LAST&lt;/code&gt; option for &lt;code&gt;nth_value&lt;/code&gt; is not implemented: only the default &lt;code&gt;FROM FIRST&lt;/code&gt; behavior is supported. (You can achieve the result of &lt;code&gt;FROM LAST&lt;/code&gt; by reversing the &lt;code&gt;ORDER BY&lt;/code&gt; ordering.)</source>
          <target state="translated">SQL標準では、 &lt;code&gt;lead&lt;/code&gt; 、 &lt;code&gt;lag&lt;/code&gt; 、 &lt;code&gt;first_value&lt;/code&gt; 、 &lt;code&gt;last_value&lt;/code&gt; 、および &lt;code&gt;nth_value&lt;/code&gt; に対して &lt;code&gt;RESPECT NULLS&lt;/code&gt; または &lt;code&gt;IGNORE NULLS&lt;/code&gt; オプションを定義しています。これはPostgreSQLには実装されていません。動作は常に標準のデフォルト、つまり &lt;code&gt;RESPECT NULLS&lt;/code&gt; と同じです。同様に、標準の &lt;code&gt;nth_value&lt;/code&gt; の &lt;code&gt;FROM FIRST&lt;/code&gt; または &lt;code&gt;FROM LAST&lt;/code&gt; オプションは実装されていません。デフォルトの &lt;code&gt;FROM FIRST&lt;/code&gt; 動作のみがサポートされています。 （ &lt;code&gt;ORDER BY&lt;/code&gt; の順序を逆にすることで &lt;code&gt;FROM LAST&lt;/code&gt; の結果を得ることができます。）</target>
        </trans-unit>
        <trans-unit id="fa458ed41634d193bea2fac0154b209dd0cf765a" translate="yes" xml:space="preserve">
          <source>The SQL standard defines a different binary string type, called &lt;code&gt;BLOB&lt;/code&gt; or &lt;code&gt;BINARY LARGE OBJECT&lt;/code&gt;. The input format is different from &lt;code&gt;bytea&lt;/code&gt;, but the provided functions and operators are mostly the same.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;BLOB&lt;/code&gt; または &lt;code&gt;BINARY LARGE OBJECT&lt;/code&gt; と呼ばれる別のバイナリ文字列型を定義しています。入力形式は &lt;code&gt;bytea&lt;/code&gt; とは異なりますが、提供される関数と演算子はほとんど同じです。</target>
        </trans-unit>
        <trans-unit id="a6502238836b3c1e6ea2cb2c05c9c3eff6b47428" translate="yes" xml:space="preserve">
          <source>The SQL standard defines four levels of transaction isolation. The most strict is Serializable, which is defined by the standard in a paragraph which says that any concurrent execution of a set of Serializable transactions is guaranteed to produce the same effect as running them one at a time in some order. The other three levels are defined in terms of phenomena, resulting from interaction between concurrent transactions, which must not occur at each level. The standard notes that due to the definition of Serializable, none of these phenomena are possible at that level. (This is hardly surprising -- if the effect of the transactions must be consistent with having been run one at a time, how could you see any phenomena caused by interactions?)</source>
          <target state="translated">SQL標準では、トランザクションの分離を4つのレベルで定義しています。最も厳密なのはSerializableで、Serializableトランザクションのセットの同時実行は、それらをある順序で一度に一つずつ実行したのと同じ効果をもたらすことが保証されているという段落で標準で定義されています。他の3つのレベルは、同時実行トランザクション間の相互作用から生じる現象の観点から定義されているが、各レベルでは発生してはならない。標準では、Serializableの定義により、そのレベルではこれらの現象のどれも可能ではないことに注意が必要である。トランザクションの効果が一度に1つずつ実行されたことと一致していなければならない場合、相互作用に起因する現象をどのようにして見ることができるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="e0bda65f48165dca64ab0bb74baf32b2635a1f88" translate="yes" xml:space="preserve">
          <source>The SQL standard defines one additional level, &lt;code&gt;READ UNCOMMITTED&lt;/code&gt;. In PostgreSQL &lt;code&gt;READ UNCOMMITTED&lt;/code&gt; is treated as &lt;code&gt;READ COMMITTED&lt;/code&gt;.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;READ UNCOMMITTED&lt;/code&gt; という 1つの追加レベルが定義されています。PostgreSQLでは、 &lt;code&gt;READ UNCOMMITTED&lt;/code&gt; は &lt;code&gt;READ COMMITTED&lt;/code&gt; として扱われます。</target>
        </trans-unit>
        <trans-unit id="4646156599f749581333cb75ad841c671d1c0b23" translate="yes" xml:space="preserve">
          <source>The SQL standard defines the concepts of users and roles, but it regards them as distinct concepts and leaves all commands defining users to be specified by each database implementation. In PostgreSQL we have chosen to unify users and roles into a single kind of entity. Roles therefore have many more optional attributes than they do in the standard.</source>
          <target state="translated">SQL標準ではユーザとロールの概念を定義していますが、それらを別個の概念とみなし、ユーザを定義するすべてのコマンドはデータベースの実装ごとに指定するようにしています。PostgreSQLでは、ユーザとロールを単一の種類の実体に統一することを選択しました。そのため、ロールは標準の属性よりも多くのオプション属性を持っています。</target>
        </trans-unit>
        <trans-unit id="0663b6424dd2f8b2135d82962a5208510f77e258" translate="yes" xml:space="preserve">
          <source>The SQL standard defines two &lt;em&gt;passing mechanisms&lt;/em&gt; that apply when passing an XML argument from SQL to an XML function or receiving a result: &lt;code&gt;BY REF&lt;/code&gt;, in which a particular XML value retains its node identity, and &lt;code&gt;BY VALUE&lt;/code&gt;, in which the content of the XML is passed but node identity is not preserved. A mechanism can be specified before a list of parameters, as the default mechanism for all of them, or after any parameter, to override the default.</source>
          <target state="translated">SQL標準では、SQLからXML関数にXML引数を渡すとき、または結果を受け取るときに適用される2つの&lt;em&gt;受け渡しメカニズム&lt;/em&gt;が定義されています &lt;code&gt;BY REF&lt;/code&gt; （特定のXML値がノードIDを保持する）と &lt;code&gt;BY VALUE&lt;/code&gt; （XMLのコンテンツが保持される）は渡されますが、ノードIDは保持されません。メカニズムは、パラメーターのリストの前、パラメーターのすべてのデフォルトメカニズムとして、またはパラメーターの後に指定して、デフォルトをオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="8be5477647682fea4652e9633a7fdf7ae02cb95d" translate="yes" xml:space="preserve">
          <source>The SQL standard differentiates &lt;code&gt;timestamp without time zone&lt;/code&gt; and &lt;code&gt;timestamp with time zone&lt;/code&gt; literals by the presence of a &amp;ldquo;+&amp;rdquo; or &amp;ldquo;-&amp;rdquo; symbol and time zone offset after the time. Hence, according to the standard,</source>
          <target state="translated">SQL標準では、 &lt;code&gt;timestamp with time zone&lt;/code&gt; &lt;code&gt;timestamp without time zone&lt;/code&gt; タイムスタンプとタイムゾーンリテラルのあるタイムスタンプを、「+」または「-」の記号の存在と、タイムゾーンオフセットの後に表示します。したがって、標準によれば、</target>
        </trans-unit>
        <trans-unit id="e664f1068d4185a0e2c4e6676631526d39744df1" translate="yes" xml:space="preserve">
          <source>The SQL standard includes a &lt;code&gt;DEALLOCATE&lt;/code&gt; statement, but it is only for use in embedded SQL.</source>
          <target state="translated">SQL標準には &lt;code&gt;DEALLOCATE&lt;/code&gt; 文が含まれていますが、これは埋め込みSQLでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="c90f74b3a15257d28d6e4bb3296f2c0e98aadae3" translate="yes" xml:space="preserve">
          <source>The SQL standard includes a &lt;code&gt;PREPARE&lt;/code&gt; statement, but it is only for use in embedded SQL. This version of the &lt;code&gt;PREPARE&lt;/code&gt; statement also uses a somewhat different syntax.</source>
          <target state="translated">SQL標準には &lt;code&gt;PREPARE&lt;/code&gt; ステートメントが含まれていますが、これは埋め込みSQLでのみ使用できます。このバージョンの &lt;code&gt;PREPARE&lt;/code&gt; ステートメントも、多少異なる構文を使用しています。</target>
        </trans-unit>
        <trans-unit id="fe224ee017c2bd35d24d44088347efdd2b498c3d" translate="yes" xml:space="preserve">
          <source>The SQL standard includes an &lt;code&gt;EXECUTE&lt;/code&gt; statement, but it is only for use in embedded SQL. This version of the &lt;code&gt;EXECUTE&lt;/code&gt; statement also uses a somewhat different syntax.</source>
          <target state="translated">SQL標準には &lt;code&gt;EXECUTE&lt;/code&gt; ステートメントが含まれていますが、これは埋め込みSQLでのみ使用できます。このバージョンの &lt;code&gt;EXECUTE&lt;/code&gt; ステートメントも、多少異なる構文を使用しています。</target>
        </trans-unit>
        <trans-unit id="3efa28b82e46f4409adc369dc8a870c8a673cbae" translate="yes" xml:space="preserve">
          <source>The SQL standard only makes provisions for cursors in embedded SQL. The PostgreSQL server does not implement an &lt;code&gt;OPEN&lt;/code&gt; statement for cursors; a cursor is considered to be open when it is declared. However, ECPG, the embedded SQL preprocessor for PostgreSQL, supports the standard SQL cursor conventions, including those involving &lt;code&gt;DECLARE&lt;/code&gt; and &lt;code&gt;OPEN&lt;/code&gt; statements.</source>
          <target state="translated">SQL標準では、埋め込みSQLのカーソルのみがプロビジョニングされます。PostgreSQLサーバーはカーソルの &lt;code&gt;OPEN&lt;/code&gt; ステートメントを実装していません。カーソルは宣言されたときに開いていると見なされます。ただし、PostgreSQLの埋め込みSQLプリプロセッサであるECPGは、 &lt;code&gt;DECLARE&lt;/code&gt; ステートメントや &lt;code&gt;OPEN&lt;/code&gt; ステートメントを含む標準SQLカーソル規則をサポートしています。</target>
        </trans-unit>
        <trans-unit id="27a77950710338562f963e53983e9db24c286f83" translate="yes" xml:space="preserve">
          <source>The SQL standard provides for a &lt;code&gt;USAGE&lt;/code&gt; privilege on other kinds of objects: character sets, collations, translations.</source>
          <target state="translated">SQL標準では、他の種類のオブジェクト（文字セット、照合順序、翻訳）に対する &lt;code&gt;USAGE&lt;/code&gt; 特権が提供されています。</target>
        </trans-unit>
        <trans-unit id="eee762b9a6787226a912a1d85c8be87d3dbf797a" translate="yes" xml:space="preserve">
          <source>The SQL standard requires commas between successive &lt;code&gt;transaction_modes&lt;/code&gt;, but for historical reasons PostgreSQL allows the commas to be omitted.</source>
          <target state="translated">SQL標準では、連続する &lt;code&gt;transaction_modes&lt;/code&gt; の間にカンマが必要ですが、歴史的な理由により、PostgreSQLではカンマを省略できます。</target>
        </trans-unit>
        <trans-unit id="0cdcd239c4d51fe5d06e09469371cb72d1e4c5cc" translate="yes" xml:space="preserve">
          <source>The SQL standard requires parentheses around the table name when writing &lt;code&gt;ONLY&lt;/code&gt;, for example &lt;code&gt;SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ...&lt;/code&gt;. PostgreSQL considers these parentheses to be optional.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;ONLY&lt;/code&gt; を書き込むときに、テーブル名を括弧で囲む必要があります。たとえば、 &lt;code&gt;SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ...&lt;/code&gt; 。PostgreSQLはこれらの括弧をオプションと見なします。</target>
        </trans-unit>
        <trans-unit id="9c327a647bb63bff5c4e11d3c2640afdd42ebe7e" translate="yes" xml:space="preserve">
          <source>The SQL standard requires that writing just &lt;code&gt;timestamp&lt;/code&gt; be equivalent to &lt;code&gt;timestamp without time zone&lt;/code&gt;, and PostgreSQL honors that behavior. &lt;code&gt;timestamptz&lt;/code&gt; is accepted as an abbreviation for &lt;code&gt;timestamp with time zone&lt;/code&gt;; this is a PostgreSQL extension.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;timestamp&lt;/code&gt; のみを書き込む &lt;code&gt;timestamp without time zone&lt;/code&gt; タイムスタンプと同等であることを要求し、PostgreSQLはその動作を尊重します。 &lt;code&gt;timestamptz&lt;/code&gt; は &lt;code&gt;timestamp with time zone&lt;/code&gt; 省略形として受け入れられます。これはPostgreSQLの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="b32d323a75124833c9180676bb48b77e9c8490b4" translate="yes" xml:space="preserve">
          <source>The SQL standard says that &lt;code&gt;CHECK&lt;/code&gt; column constraints can only refer to the column they apply to; only &lt;code&gt;CHECK&lt;/code&gt; table constraints can refer to multiple columns. PostgreSQL does not enforce this restriction; it treats column and table check constraints alike.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;CHECK&lt;/code&gt; 列制約は、それらが適用される列のみを参照できるとしています。複数の列を参照できるのは、 &lt;code&gt;CHECK&lt;/code&gt; テーブル制約のみです。PostgreSQLはこの制限を強制しません。列とテーブルのチェック制約を同じように扱います。</target>
        </trans-unit>
        <trans-unit id="17cd16f5bf5a8ca370f92a98424035c167fcaa79" translate="yes" xml:space="preserve">
          <source>The SQL standard says that it is implementation-dependent whether cursors are sensitive to concurrent updates of the underlying data by default. In PostgreSQL, cursors are insensitive by default, and can be made sensitive by specifying &lt;code&gt;FOR UPDATE&lt;/code&gt;. Other products may work differently.</source>
          <target state="translated">SQL標準では、デフォルトでカーソルが基礎となるデータの同時更新に敏感であるかどうかは、実装に依存するとしています。PostgreSQLでは、カーソルはデフォルトで無効であり、 &lt;code&gt;FOR UPDATE&lt;/code&gt; を指定することで有効にすることができます。他の製品は動作が異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="6c0e6c19202fe94a3734c19398394df433a6c622" translate="yes" xml:space="preserve">
          <source>The SQL standard says that table and domain constraints must have names that are unique across the schema containing the table or domain. PostgreSQL is laxer: it only requires constraint names to be unique across the constraints attached to a particular table or domain. However, this extra freedom does not exist for index-based constraints (&lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, and &lt;code&gt;EXCLUDE&lt;/code&gt; constraints), because the associated index is named the same as the constraint, and index names must be unique across all relations within the same schema.</source>
          <target state="translated">SQL標準では、テーブルとドメインの制約には、テーブルまたはドメインを含むスキーマ全体で一意の名前を付ける必要があると規定されています。PostgreSQLは緩いです。特定のテーブルまたはドメインに関連付けられている制約全体で一意である必要がある制約名のみです。ただし、この追加の自由度は、インデックスベースの制約（ &lt;code&gt;UNIQUE&lt;/code&gt; 、 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 、および &lt;code&gt;EXCLUDE&lt;/code&gt; 制約）には存在しません。関連付けられたインデックスには制約と同じ名前が付けられ、インデックス名は同じスキーマ内のすべての関係で一意である必要があるためです。</target>
        </trans-unit>
        <trans-unit id="5a79884799ecc17f7b669e9ed40107182ffe5aca" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; can only be specified if an identity column that is generated always exists. PostgreSQL allows the clause in any case and ignores it if it is not applicable.</source>
          <target state="translated">SQL標準では、生成されるID列が常に存在する場合にのみ、 &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; を指定できると規定されています。PostgreSQLはどのような場合でもこの句を許可し、該当しない場合は無視します。</target>
        </trans-unit>
        <trans-unit id="5b1e1c604541e0514a1f4ecda3cb5b97bda57985" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that the key word &lt;code&gt;SAVEPOINT&lt;/code&gt; is mandatory, but PostgreSQL and Oracle allow it to be omitted. SQL allows only &lt;code&gt;WORK&lt;/code&gt;, not &lt;code&gt;TRANSACTION&lt;/code&gt;, as a noise word after &lt;code&gt;ROLLBACK&lt;/code&gt;. Also, SQL has an optional clause &lt;code&gt;AND [ NO ] CHAIN&lt;/code&gt; which is not currently supported by PostgreSQL. Otherwise, this command conforms to the SQL standard.</source>
          <target state="translated">SQL標準では、キーワード &lt;code&gt;SAVEPOINT&lt;/code&gt; は必須であると指定されていますが、PostgreSQLとOracleでは省略可能です。SQLのみを可能に &lt;code&gt;WORK&lt;/code&gt; 、ない &lt;code&gt;TRANSACTION&lt;/code&gt; 後のノイズワードとして、 &lt;code&gt;ROLLBACK&lt;/code&gt; 。また、SQLにはオプションの句 &lt;code&gt;AND [ NO ] CHAIN&lt;/code&gt; ありますが、現在PostgreSQLではサポートされていません。それ以外の場合、このコマンドはSQL標準に準拠しています。</target>
        </trans-unit>
        <trans-unit id="4ef02d5b8713fad53d23c6b10f7669991c2a9427" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that the subcommands in &lt;code&gt;CREATE SCHEMA&lt;/code&gt; can appear in any order. The present PostgreSQL implementation does not handle all cases of forward references in subcommands; it might sometimes be necessary to reorder the subcommands in order to avoid forward references.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;CREATE SCHEMA&lt;/code&gt; のサブコマンドは任意の順序で指定できると規定されています。現在のPostgreSQL実装は、サブコマンドでの前方参照のすべてのケースを処理するわけではありません。前方参照を回避するために、サブコマンドを並べ替える必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="7b4258f023ecf83c293dc59266efcd9181140a14" translate="yes" xml:space="preserve">
          <source>The SQL standard states that &amp;ldquo;Within the definition of a &amp;lsquo;datetime literal&amp;rsquo;, the &amp;lsquo;datetime values&amp;rsquo; are constrained by the natural rules for dates and times according to the Gregorian calendar&amp;rdquo;. PostgreSQL follows the SQL standard's lead by counting dates exclusively in the Gregorian calendar, even for years before that calendar was in use. This rule is known as the &lt;em&gt;proleptic Gregorian calendar&lt;/em&gt;.</source>
          <target state="translated">SQL標準では、「 'datetimeリテラル'の定義内では、 'datetimeの値'はグレゴリオ暦による日付と時刻の自然な規則によって制約されています」と述べています。 PostgreSQLは、グレゴリオ暦でのみ日付をカウントすることにより、その暦が使用される前の年についても、SQL標準の先導に従っています。このルールは、前発性&lt;em&gt;グレゴリオ暦&lt;/em&gt;として知られています。</target>
        </trans-unit>
        <trans-unit id="d19cb60e6641fce6ca2d40fc0e7200daf402177c" translate="yes" xml:space="preserve">
          <source>The SQL standard uses &lt;code&gt;SELECT INTO&lt;/code&gt; to represent selecting values into scalar variables of a host program, rather than creating a new table. This indeed is the usage found in ECPG (see &lt;a href=&quot;https://www.postgresql.org/docs/12/ecpg.html&quot;&gt;Chapter 35&lt;/a&gt;) and PL/pgSQL (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql.html&quot;&gt;Chapter 42&lt;/a&gt;). The PostgreSQL usage of &lt;code&gt;SELECT INTO&lt;/code&gt; to represent table creation is historical. It is best to use &lt;code&gt;CREATE TABLE AS&lt;/code&gt; for this purpose in new code.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;SELECT INTO&lt;/code&gt; を使用して、新しいテーブルを作成するのではなく、ホストプログラムのスカラー変数への選択値を表します。これは確かに、ECPG（&lt;a href=&quot;https://www.postgresql.org/docs/12/ecpg.html&quot;&gt;第35章を&lt;/a&gt;参照）およびPL / pgSQL（&lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql.html&quot;&gt;第42章を&lt;/a&gt;参照）で見られる使用法です。テーブルの作成を表すための &lt;code&gt;SELECT INTO&lt;/code&gt; のPostgreSQLの使用は歴史的です。新しいコードでこの目的のために &lt;code&gt;CREATE TABLE AS&lt;/code&gt; を使用するのが最善です。</target>
        </trans-unit>
        <trans-unit id="7f96ecc2fb3538c905f725be2098ce0d65cd6679" translate="yes" xml:space="preserve">
          <source>The SQL syntax is not very consistent regarding what tokens identify commands and which are operands or parameters. The first few tokens are generally the command name, so in the above example we would usually speak of a &amp;ldquo;SELECT&amp;rdquo;, an &amp;ldquo;UPDATE&amp;rdquo;, and an &amp;ldquo;INSERT&amp;rdquo; command. But for instance the &lt;code&gt;UPDATE&lt;/code&gt; command always requires a &lt;code&gt;SET&lt;/code&gt; token to appear in a certain position, and this particular variation of &lt;code&gt;INSERT&lt;/code&gt; also requires a &lt;code&gt;VALUES&lt;/code&gt; in order to be complete. The precise syntax rules for each command are described in &lt;a href=&quot;index&quot;&gt;Part VI&lt;/a&gt;.</source>
          <target state="translated">SQL構文は、どのトークンがコマンドを識別し、どれがオペランドまたはパラメーターであるかに関して、あまり一貫性がありません。最初のいくつかのトークンは通常コマンド名であるため、上記の例では、通常、「SELECT」、「UPDATE」、および「INSERT」コマンドについて説明します。しかし、たとえば、 &lt;code&gt;UPDATE&lt;/code&gt; コマンドでは、常に特定の位置に &lt;code&gt;SET&lt;/code&gt; トークンを表示する必要があり、 &lt;code&gt;INSERT&lt;/code&gt; のこの特定のバリエーションも、完了するために &lt;code&gt;VALUES&lt;/code&gt; を必要とします。各コマンドの正確な構文規則は、&lt;a href=&quot;index&quot;&gt;パートVIで&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="bb05fc557b9719130cdacd9aa3c915a94bbdf061" translate="yes" xml:space="preserve">
          <source>The SQL/JSON standard borrows its definition for regular expressions from the &lt;code&gt;LIKE_REGEX&lt;/code&gt; operator, which in turn uses the XQuery standard. PostgreSQL does not currently support the &lt;code&gt;LIKE_REGEX&lt;/code&gt; operator. Therefore, the &lt;code&gt;like_regex&lt;/code&gt; filter is implemented using the POSIX regular expression engine described in &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt;. This leads to various minor discrepancies from standard SQL/JSON behavior, which are cataloged in &lt;a href=&quot;functions-matching#POSIX-VS-XQUERY&quot;&gt;Section 9.7.3.8&lt;/a&gt;. Note, however, that the flag-letter incompatibilities described there do not apply to SQL/JSON, as it translates the XQuery flag letters to match what the POSIX engine expects.</source>
          <target state="translated">SQL / JSON標準は、 &lt;code&gt;LIKE_REGEX&lt;/code&gt; 演算子から正規表現の定義を借用し、LIKE_REGEX演算子はXQuery標準を使用します。現在、PostgreSQLは &lt;code&gt;LIKE_REGEX&lt;/code&gt; 演算子をサポートしていません。したがって、 &lt;code&gt;like_regex&lt;/code&gt; フィルターは、&lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;セクション9.7.3で&lt;/a&gt;説明されているPOSIX正規表現エンジンを使用して実装されます。これにより、標準のSQL / JSON動作とのさまざまなマイナーな不一致が&lt;a href=&quot;functions-matching#POSIX-VS-XQUERY&quot;&gt;発生し&lt;/a&gt;ます。これは、セクション9.7.3.8でカタログ化されています。ただし、そこで説明されているフラグ文字の非互換性はSQL / JSONには適用されないことに注意してください。これは、XQueryフラグ文字を変換してPOSIXエンジンが期待するものと一致させるためです。</target>
        </trans-unit>
        <trans-unit id="2c1fd14d6c7b89183a3f90fd72282a55b3166126" translate="yes" xml:space="preserve">
          <source>The SQL:2008 standard includes a &lt;code&gt;TRUNCATE&lt;/code&gt; command with the syntax &lt;code&gt;TRUNCATE TABLE tablename&lt;/code&gt;. The clauses &lt;code&gt;CONTINUE IDENTITY&lt;/code&gt;/&lt;code&gt;RESTART IDENTITY&lt;/code&gt; also appear in that standard, but have slightly different though related meanings. Some of the concurrency behavior of this command is left implementation-defined by the standard, so the above notes should be considered and compared with other implementations if necessary.</source>
          <target state="translated">SQL：2008標準は、 &lt;code&gt;TRUNCATE&lt;/code&gt; の構文でコマンド &lt;code&gt;TRUNCATE TABLE tablename&lt;/code&gt; 。節 &lt;code&gt;CONTINUE IDENTITY&lt;/code&gt; / &lt;code&gt;RESTART IDENTITY&lt;/code&gt; もその規格に表示されますが、関連する意味は多少異なります。このコマンドの同時実行動作の一部は、標準で実装定義されているため、上記の注意事項を考慮し、必要に応じて他の実装と比較する必要があります。</target>
        </trans-unit>
        <trans-unit id="106deb17fc13475a8af50970b808cc1e2661d130" translate="yes" xml:space="preserve">
          <source>The Serializable transaction isolation level is not yet available in hot standby. (See &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt; and &lt;a href=&quot;applevel-consistency#SERIALIZABLE-CONSISTENCY&quot;&gt;Section 13.4.1&lt;/a&gt; for details.) An attempt to set a transaction to the serializable isolation level in hot standby mode will generate an error.</source>
          <target state="translated">シリアル化可能なトランザクション分離レベルは、ホットスタンバイではまだ使用できません。（参照&lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;13.2.3&lt;/a&gt;および&lt;a href=&quot;applevel-consistency#SERIALIZABLE-CONSISTENCY&quot;&gt;セクション13.4.1&lt;/a&gt;、ホットスタンバイモードでシリアライズ可能分離レベルにトランザクションを設定するための詳細については。）しようとすると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="66e4ba5dbccb413a9c06a219a5d2e98558807585" translate="yes" xml:space="preserve">
          <source>The Snowball dictionary template is based on a project by Martin Porter, inventor of the popular Porter's stemming algorithm for the English language. Snowball now provides stemming algorithms for many languages (see the &lt;a href=&quot;http://snowballstem.org/&quot;&gt;Snowball site&lt;/a&gt; for more information). Each algorithm understands how to reduce common variant forms of words to a base, or stem, spelling within its language. A Snowball dictionary requires a &lt;code&gt;language&lt;/code&gt; parameter to identify which stemmer to use, and optionally can specify a &lt;code&gt;stopword&lt;/code&gt; file name that gives a list of words to eliminate. (PostgreSQL's standard stopword lists are also provided by the Snowball project.) For example, there is a built-in definition equivalent to</source>
          <target state="translated">Snowball辞書テンプレートは、人気のあるポーターの英語のステミングアルゴリズムの発明者であるマーティンポーターによるプロジェクトに基づいています。 Snowballは現在、多くの言語用のステミングアルゴリズムを提供しています（詳細については、&lt;a href=&quot;http://snowballstem.org/&quot;&gt;Snowballサイト&lt;/a&gt;を参照してください）。各アルゴリズムは、一般的な異形の単語を、その言語内のベースまたはステムのスペルに減らす方法を理解しています。 Snowball辞書は、使用するステマーを識別するための &lt;code&gt;language&lt;/code&gt; パラメーターを必要とし、オプションで、除去する単語のリストを提供する &lt;code&gt;stopword&lt;/code&gt; ファイル名を指定できます。 （PostgreSQLの標準ストップワードリストもSnowballプロジェクトによって提供されています。）たとえば、以下に相当する組み込みの定義があります。</target>
        </trans-unit>
        <trans-unit id="13e42c2d23de5bce64e42840619341e599527d06" translate="yes" xml:space="preserve">
          <source>The Sort node shows the sort method used (in particular, whether the sort was in-memory or on-disk) and the amount of memory or disk space needed. The Hash node shows the number of hash buckets and batches as well as the peak amount of memory used for the hash table. (If the number of batches exceeds one, there will also be disk space usage involved, but that is not shown.)</source>
          <target state="translated">ソートノードは、使用されたソート方法(特に、ソートがインメモリかオンディスクか)と、必要とされるメモリまたはディスク容量を示します。Hashノードは、ハッシュバケットとバッチの数と、ハッシュテーブルに使用されたメモリのピーク量を示します。(バッチ数が1を超える場合は、ディスク容量の使用量も関係しますが、それは表示されません)。</target>
        </trans-unit>
        <trans-unit id="ffcd4e9238fc5943a8a630abc801447e679c88d8" translate="yes" xml:space="preserve">
          <source>The Soundex system is a method of matching similar-sounding names by converting them to the same code. It was initially used by the United States Census in 1880, 1900, and 1910. Note that Soundex is not very useful for non-English names.</source>
          <target state="translated">サウンドデックス方式とは、似たような響きの名前を同一符号に変換して照合する方法である。これは当初、1880年、1900年、1910年の米国国勢調査で使用されていました。Soundexは英語以外の名前にはあまり役に立たないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="30ad8964ef3e16d1b565ba3b7fd4ae7ed8f17e69" translate="yes" xml:space="preserve">
          <source>The TCP port the server listens on; 5432 by default. Note that the same port number is used for all IP addresses the server listens on. This parameter can only be set at server start.</source>
          <target state="translated">サーバが listen する TCP ポート。デフォルトでは 5432。サーバがリッスンするすべての IP アドレスに同じポート番号が使用されることに注意してください。このパラメータは、サーバの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="4a5c86c75e37eef9f48a99edd2521f09dbad0224" translate="yes" xml:space="preserve">
          <source>The TOAST management code is triggered only when a row value to be stored in a table is wider than &lt;code&gt;TOAST_TUPLE_THRESHOLD&lt;/code&gt; bytes (normally 2 kB). The TOAST code will compress and/or move field values out-of-line until the row value is shorter than &lt;code&gt;TOAST_TUPLE_TARGET&lt;/code&gt; bytes (also normally 2 kB, adjustable) or no more gains can be had. During an UPDATE operation, values of unchanged fields are normally preserved as-is; so an UPDATE of a row with out-of-line values incurs no TOAST costs if none of the out-of-line values change.</source>
          <target state="translated">TOAST管理コードは、テーブルに格納される行の値が &lt;code&gt;TOAST_TUPLE_THRESHOLD&lt;/code&gt; バイト（通常は2 kB）より大きい場合にのみトリガーされます。 TOASTコードは、行の値が &lt;code&gt;TOAST_TUPLE_TARGET&lt;/code&gt; バイト（通常は2 kB、調整可能）よりも短くなるか、それ以上の利益が得られなくなるまで、フィールド値を圧縮して行外に移動します。 UPDATE操作中、通常、変更されていないフィールドの値はそのまま保持されます。したがって、行外の値を含む行のUPDATEでは、行外の値が変更されない場合、TOASTコストは発生しません。</target>
        </trans-unit>
        <trans-unit id="2962f8d4658219a67247690e9e9ec2e5d8ddb34b" translate="yes" xml:space="preserve">
          <source>The TOAST management code recognizes four different strategies for storing TOAST-able columns on disk:</source>
          <target state="translated">TOAST管理コードは、ディスク上にTOAST可能なカラムを格納するための4つの異なる戦略を認識しています。</target>
        </trans-unit>
        <trans-unit id="a81c03b713c7e31311d0848c27a627beb8a79d13" translate="yes" xml:space="preserve">
          <source>The Time Stamp Counter (TSC) clock source is the most accurate one available on current generation CPUs. It's the preferred way to track the system time when it's supported by the operating system and the TSC clock is reliable. There are several ways that TSC can fail to provide an accurate timing source, making it unreliable. Older systems can have a TSC clock that varies based on the CPU temperature, making it unusable for timing. Trying to use TSC on some older multicore CPUs can give a reported time that's inconsistent among multiple cores. This can result in the time going backwards, a problem this program checks for. And even the newest systems can fail to provide accurate TSC timing with very aggressive power saving configurations.</source>
          <target state="translated">タイムスタンプカウンター(TSC)クロックソースは、現世代のCPUで利用可能な最も正確なものです。オペレーティングシステムがサポートしており、TSCクロックが信頼できる場合、システムの時間を追跡するのに適した方法です。TSCが正確なタイミングソースを提供できず、信頼性が低くなる方法はいくつかあります。古いシステムでは、CPU の温度に応じて TSC クロックが変化し、タイミングを取るのに使用できなくなることがあります。古いマルチコアCPUでTSCを使用しようとすると、複数のコア間で時間が不一致になることがあります。これは、このプログラムがチェックしている問題で、時間が逆行する可能性があります。また、最新のシステムであっても、非常に積極的な省電力構成では、正確なTSCタイミングを提供できないことがあります。</target>
        </trans-unit>
        <trans-unit id="42e64c3210927fbc153414d6d364fd7a502138f4" translate="yes" xml:space="preserve">
          <source>The URL scheme &lt;code&gt;ldaps&lt;/code&gt; chooses the LDAPS method for making LDAP connections over SSL, equivalent to using &lt;code&gt;ldapscheme=ldaps&lt;/code&gt;. To use encrypted LDAP connections using the &lt;code&gt;StartTLS&lt;/code&gt; operation, use the normal URL scheme &lt;code&gt;ldap&lt;/code&gt; and specify the &lt;code&gt;ldaptls&lt;/code&gt; option in addition to &lt;code&gt;ldapurl&lt;/code&gt;.</source>
          <target state="translated">URLスキーム &lt;code&gt;ldaps&lt;/code&gt; は、SSLを介してLDAP接続を確立するためにLDAPSメソッドを選択し &lt;code&gt;ldapscheme=ldaps&lt;/code&gt; 。これは、ldapscheme = ldapsを使用する場合と同じです。 &lt;code&gt;StartTLS&lt;/code&gt; 操作を使用して暗号化されたLDAP接続を使用するには、通常のURLスキーム &lt;code&gt;ldap&lt;/code&gt; を使用し、 &lt;code&gt;ldaptls&lt;/code&gt; に加えて &lt;code&gt;ldapurl&lt;/code&gt; オプションを指定します。</target>
        </trans-unit>
        <trans-unit id="7c6010c68a5af10d545c5e024dfa86cf3e81ff1d" translate="yes" xml:space="preserve">
          <source>The Unicode escape syntax works fully only when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;. When other server encodings are used, only code points in the ASCII range (up to &lt;code&gt;\u007F&lt;/code&gt;) can be specified. Both the 4-digit and the 8-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 8-digit form technically makes this unnecessary. (When surrogate pairs are used when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;, they are first combined into a single code point that is then encoded in UTF-8.)</source>
          <target state="translated">Unicodeエスケープ構文は、サーバーのエンコーディングが &lt;code&gt;UTF8&lt;/code&gt; の場合にのみ完全に機能します。他のサーバーエンコーディングが使用されている場合、ASCII範囲（最大 &lt;code&gt;\u007F&lt;/code&gt; ）のコードポイントのみを指定できます。 4桁と8桁の両方の形式を使用して、UTF-16サロゲートペアを指定し、U + FFFFより大きいコードポイントを持つ文字を構成できます。ただし、8桁の形式を使用できるため、技術的にこれは不要です。 （サーバーのエンコードが &lt;code&gt;UTF8&lt;/code&gt; のときにサロゲートペアが使用される場合、それらは最初に単一のコードポイントに結合され、次にUTF-8でエンコードされます。）</target>
        </trans-unit>
        <trans-unit id="9d177c404952bede8f8a850e0e6bf27fc770e815" translate="yes" xml:space="preserve">
          <source>The Unicode escape syntax works only when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;. When other server encodings are used, only code points in the ASCII range (up to &lt;code&gt;\007F&lt;/code&gt;) can be specified. Both the 4-digit and the 6-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 6-digit form technically makes this unnecessary. (Surrogate pairs are not stored directly, but combined into a single code point that is then encoded in UTF-8.)</source>
          <target state="translated">Unicodeエスケープ構文は、サーバーのエンコーディングが &lt;code&gt;UTF8&lt;/code&gt; の場合にのみ機能します。他のサーバーエンコーディングが使用されている場合、ASCII範囲（ &lt;code&gt;\007F&lt;/code&gt; ）のコードポイントのみを指定できます。 4桁と6桁の両方の形式を使用して、UTF-16サロゲートペアを指定し、U + FFFFより大きいコードポイントを持つ文字を構成できますが、6桁の形式を使用できるため、技術的にこれは不要です。 （サロゲートペアは直接格納されませんが、単一のコードポイントに結合され、UTF-8でエンコードされます。）</target>
        </trans-unit>
        <trans-unit id="7a66f8e165736e1d6137c7cb68f9f8d177bec3f5" translate="yes" xml:space="preserve">
          <source>The Unicode escape syntax works only when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;. When other server encodings are used, only code points in the ASCII range (up to &lt;code&gt;\007F&lt;/code&gt;) can be specified. Both the 4-digit and the 6-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 6-digit form technically makes this unnecessary. (When surrogate pairs are used when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;, they are first combined into a single code point that is then encoded in UTF-8.)</source>
          <target state="translated">Unicodeエスケープ構文は、サーバーのエンコーディングが &lt;code&gt;UTF8&lt;/code&gt; の場合にのみ機能します。他のサーバーエンコーディングが使用されている場合、ASCII範囲（ &lt;code&gt;\007F&lt;/code&gt; ）のコードポイントのみを指定できます。4桁と6桁の両方の形式を使用して、UTF-16サロゲートペアを指定し、U + FFFFより大きいコードポイントを持つ文字を構成できますが、6桁の形式を使用できるため、技術的にこれは不要です。（サーバーのエンコードが &lt;code&gt;UTF8&lt;/code&gt; のときにサロゲートペアが使用される場合、それらは最初に単一のコードポイントに結合され、次にUTF-8でエンコードされます。）</target>
        </trans-unit>
        <trans-unit id="9ece699458bd7501153fdfb1c5912141f3441417" translate="yes" xml:space="preserve">
          <source>The XPath-based functions support passing one parameter to serve as the XPath expression's context item, but do not support passing additional values to be available to the expression as named parameters.</source>
          <target state="translated">XPath ベースの関数は XPath 式のコンテキスト項目として機能するために 1 つのパラメータを渡すことをサポートしていますが、名前付きパラメータとして式に利用可能な追加の値を渡すことはサポートしていません。</target>
        </trans-unit>
        <trans-unit id="68d2d71e2fc0b0be97c31a2b21762a50375e3cf0" translate="yes" xml:space="preserve">
          <source>The ability of pg_dump and psql to write to or read from pipes makes it possible to dump a database directly from one server to another, for example:</source>
          <target state="translated">pg_dumpとpsqlがパイプへの書き込みやパイプからの読み込みを行う機能により、例えばあるサーバから別のサーバへ直接データベースをダンプすることが可能になります。</target>
        </trans-unit>
        <trans-unit id="fa4fd86ff72f122e1d8e3fdfa6f01d6588a00c68" translate="yes" xml:space="preserve">
          <source>The ability to create a composite type with zero attributes is a PostgreSQL-specific deviation from the standard (analogous to the same case in &lt;code&gt;CREATE TABLE&lt;/code&gt;).</source>
          <target state="translated">属性がゼロの複合型を作成する機能は、標準からのPostgreSQL固有の偏差です（ &lt;code&gt;CREATE TABLE&lt;/code&gt; の同じケースに類似しています）。</target>
        </trans-unit>
        <trans-unit id="adfc2f9948045f7d285be1359a7594bd62946d41" translate="yes" xml:space="preserve">
          <source>The ability to create like-named objects in different schemas complicates writing a query that references precisely the same objects every time. It also opens up the potential for users to change the behavior of other users' queries, maliciously or accidentally. Due to the prevalence of unqualified names in queries and their use in PostgreSQL internals, adding a schema to &lt;code&gt;search_path&lt;/code&gt; effectively trusts all users having &lt;code&gt;CREATE&lt;/code&gt; privilege on that schema. When you run an ordinary query, a malicious user able to create objects in a schema of your search path can take control and execute arbitrary SQL functions as though you executed them.</source>
          <target state="translated">異なるスキーマで同じ名前のオブジェクトを作成する機能は、毎回まったく同じオブジェクトを参照するクエリの記述を複雑にします。また、ユーザーが他のユーザーのクエリの動作を故意または偶然に変更する可能性を広げます。クエリ内の非修飾名の普及とPostgreSQL内部でのそれらの使用のため、スキーマを &lt;code&gt;search_path&lt;/code&gt; に追加すると、そのスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権を持つすべてのユーザーが効果的に信頼されます。通常のクエリを実行すると、検索パスのスキーマにオブジェクトを作成できる悪意のあるユーザーが、任意のSQL関数を制御して実行する可能性があります。</target>
        </trans-unit>
        <trans-unit id="b4ae0fec1e129dc1403f8e4a1f54de4512e5b908" translate="yes" xml:space="preserve">
          <source>The ability to fire triggers for &lt;code&gt;TRUNCATE&lt;/code&gt; is a PostgreSQL extension of the SQL standard, as is the ability to define statement-level triggers on views.</source>
          <target state="translated">&lt;code&gt;TRUNCATE&lt;/code&gt; のトリガーを起動する機能は、SQL標準のPostgreSQLの拡張機能であり、ビューにステートメントレベルのトリガーを定義する機能も同様です。</target>
        </trans-unit>
        <trans-unit id="b3edb8c451c19be6c183faaf56035a29e2c4b780" translate="yes" xml:space="preserve">
          <source>The ability to restore the database to a previous point in time creates some complexities that are akin to science-fiction stories about time travel and parallel universes. For example, in the original history of the database, suppose you dropped a critical table at 5:15PM on Tuesday evening, but didn't realize your mistake until Wednesday noon. Unfazed, you get out your backup, restore to the point-in-time 5:14PM Tuesday evening, and are up and running. In &lt;em&gt;this&lt;/em&gt; history of the database universe, you never dropped the table. But suppose you later realize this wasn't such a great idea, and would like to return to sometime Wednesday morning in the original history. You won't be able to if, while your database was up-and-running, it overwrote some of the WAL segment files that led up to the time you now wish you could get back to. Thus, to avoid this, you need to distinguish the series of WAL records generated after you've done a point-in-time recovery from those that were generated in the original database history.</source>
          <target state="translated">データベースを以前の時点に復元する機能は、タイムトラベルとパラレルユニバースに関するSFの話に似た複雑さを生み出します。たとえば、データベースの元の履歴で、火曜日の午後5時15分に重要なテーブルを削除したが、水曜日の正午まで間違いに気づかなかったとします。慌てずに、バックアップを取得し、火曜日の夕方の午後5時14分に復元して、稼働します。では&lt;em&gt;、この&lt;/em&gt;データベースユニバースの履歴では、テーブルを削除したことはありません。しかし、これがそれほど素晴らしいアイデアではなかったことに後で気づき、元の歴史の水曜日の朝のいつかに戻りたいとしましょう。データベースが稼働しているときに、元に戻すことができるようになるまでのWALセグメントファイルの一部が上書きされた場合は、これを行うことができません。したがって、これを回避するには、ポイントインタイムリカバリを実行した後に生成された一連のWALレコードを、元のデータベース履歴で生成されたものと区別する必要があります。</target>
        </trans-unit>
        <trans-unit id="e29767e86a52c901615b571a0d1b5b49dcfd5235" translate="yes" xml:space="preserve">
          <source>The ability to specify argument modes and names</source>
          <target state="translated">引数モードと名前を指定する機能</target>
        </trans-unit>
        <trans-unit id="f83cfa93265ba6bdf2c4af4154ac85132df7584f" translate="yes" xml:space="preserve">
          <source>The ability to specify both &lt;code&gt;DISTINCT&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt; in an aggregate function is a PostgreSQL extension.</source>
          <target state="translated">集約関数で &lt;code&gt;DISTINCT&lt;/code&gt; と &lt;code&gt;ORDER BY&lt;/code&gt; の両方を指定する機能は、PostgreSQLの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="36892c35402a71971c62f926cf33611f0095f448" translate="yes" xml:space="preserve">
          <source>The ability to specify multiple actions for a single trigger using &lt;code&gt;OR&lt;/code&gt; is a PostgreSQL extension of the SQL standard.</source>
          <target state="translated">&lt;code&gt;OR&lt;/code&gt; を使用して単一のトリガーに複数のアクションを指定する機能は、SQL標準のPostgreSQLの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="12f8b21071990877da6aa1b7a33a6ab04258d42b" translate="yes" xml:space="preserve">
          <source>The ability to temporarily enable or disable a trigger is provided by &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;, not by &lt;code&gt;ALTER TRIGGER&lt;/code&gt;, because &lt;code&gt;ALTER TRIGGER&lt;/code&gt; has no convenient way to express the option of enabling or disabling all of a table's triggers at once.</source>
          <target state="translated">一時的に有効またはトリガーを無効にする機能は、によって提供され&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;ないことで、 &lt;code&gt;ALTER TRIGGER&lt;/code&gt; ので、 &lt;code&gt;ALTER TRIGGER&lt;/code&gt; が有効か、一度にテーブルのトリガのすべてを無効にするオプションを表現する便利な方法を持っていません。</target>
        </trans-unit>
        <trans-unit id="181b9f5d513d598d56342cbdee6549b14a30572c" translate="yes" xml:space="preserve">
          <source>The ability to use indexes with &lt;code&gt;LIKE&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 句でインデックスを使用する機能</target>
        </trans-unit>
        <trans-unit id="cf1bad54aa29381ffc99e0cd6534801214045eea" translate="yes" xml:space="preserve">
          <source>The above are all simple text search examples. As mentioned before, full text search functionality includes the ability to do many more things: skip indexing certain words (stop words), process synonyms, and use sophisticated parsing, e.g., parse based on more than just white space. This functionality is controlled by &lt;em&gt;text search configurations&lt;/em&gt;. PostgreSQL comes with predefined configurations for many languages, and you can easily create your own configurations. (psql's &lt;code&gt;\dF&lt;/code&gt; command shows all available configurations.)</source>
          <target state="translated">上記はすべて単純なテキスト検索の例です。前述のように、全文検索機能には、特定の単語（ストップワード）のインデックス作成をスキップし、類義語を処理し、洗練された解析を使用する機能（たとえば、空白以外のものに基づく解析）が含まれます。この機能は、&lt;em&gt;テキスト検索構成&lt;/em&gt;によって制御され&lt;em&gt;ます&lt;/em&gt;。PostgreSQLには多くの言語用に事前定義された構成が付属しており、独自の構成を簡単に作成できます。（psqlの &lt;code&gt;\dF&lt;/code&gt; コマンドは、使用可能なすべての構成を表示します。）</target>
        </trans-unit>
        <trans-unit id="2c3e1167e52b923579b2a7fc4d461580b2f1f1dc" translate="yes" xml:space="preserve">
          <source>The above operations should be performed by an administrative user.</source>
          <target state="translated">上記の操作は管理者が行ってください。</target>
        </trans-unit>
        <trans-unit id="d0d28ebaf3e9bc7217eabce77d41a45e775db518" translate="yes" xml:space="preserve">
          <source>The above query only shows the rows from the inner query having &lt;code&gt;rank&lt;/code&gt; less than 3.</source>
          <target state="translated">上記のクエリでは、 &lt;code&gt;rank&lt;/code&gt; が3未満の内部クエリの行のみが表示されます。</target>
        </trans-unit>
        <trans-unit id="5129e9bc20e65e89b0d436aa6187d7cf918d1aeb" translate="yes" xml:space="preserve">
          <source>The above query using &lt;code&gt;int_array_enum&lt;/code&gt; produces the same results as</source>
          <target state="translated">上記の &lt;code&gt;int_array_enum&lt;/code&gt; を使用したクエリは、</target>
        </trans-unit>
        <trans-unit id="8107fdc88da76184415ef69e2ecad722706ac13d" translate="yes" xml:space="preserve">
          <source>The above rules associate greediness attributes not only with individual quantified atoms, but with branches and entire REs that contain quantified atoms. What that means is that the matching is done in such a way that the branch, or whole RE, matches the longest or shortest possible substring &lt;em&gt;as a whole&lt;/em&gt;. Once the length of the entire match is determined, the part of it that matches any particular subexpression is determined on the basis of the greediness attribute of that subexpression, with subexpressions starting earlier in the RE taking priority over ones starting later.</source>
          <target state="translated">上記のルールは、貪欲属性を個々の定量化された原子だけでなく、定量化された原子を含むブランチおよびRE全体にも関連付けます。どのような手段は、マッチングが支店、または全体のREは、最長または最短の部分文字列と一致するような方法で行われていることである&lt;em&gt;全体としての&lt;/em&gt;。一致全体の長さが決定されると、特定の部分式に一致する部分がその部分式の貪欲属性に基づいて決定され、部分式はREの前に開始され、後から開始される部分より優先されます。</target>
        </trans-unit>
        <trans-unit id="fe4e00a739ad370965c561bc4d7c298f0756e50c" translate="yes" xml:space="preserve">
          <source>The above skeleton is suitable for the case where no decompression is needed. (But, of course, omitting the method altogether is even easier, and is recommended in such cases.)</source>
          <target state="translated">上記のスケルトンは、減圧を必要としない場合に適しています。(もちろん、完全に省略した方がより簡単であり、そのような場合にはお勧めです)。</target>
        </trans-unit>
        <trans-unit id="6987a09f0b14c398190d54898784ad9944a48328" translate="yes" xml:space="preserve">
          <source>The above syntax has the drawback that you need to know the order of the columns in the table. To avoid this you can also list the columns explicitly. For example, both of the following commands have the same effect as the one above:</source>
          <target state="translated">上記の構文では、テーブル内のカラムの順序を知る必要があるという欠点があります。これを避けるために、列を明示的にリストアップすることもできます。例えば、以下のコマンドはどちらも上のコマンドと同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="d92b695ce2e1fc99e7debc111a49b6a3b4275271" translate="yes" xml:space="preserve">
          <source>The above transaction will insert both 3 and 4.</source>
          <target state="translated">上記の取引では、3と4の両方を挿入します。</target>
        </trans-unit>
        <trans-unit id="d3ded6bad4b3e8cb90f32aef7f2e2ce8e740539c" translate="yes" xml:space="preserve">
          <source>The above transaction will insert the values 1 and 3, but not 2.</source>
          <target state="translated">上記のトランザクションでは、値1と値3が挿入されますが、値2は挿入されません。</target>
        </trans-unit>
        <trans-unit id="dec9b433ac3e4e8910b0ae4310ac815b98eb482c" translate="yes" xml:space="preserve">
          <source>The above will start the replication process, which synchronizes the initial table contents of the tables &lt;code&gt;users&lt;/code&gt; and &lt;code&gt;departments&lt;/code&gt; and then starts replicating incremental changes to those tables.</source>
          <target state="translated">上記はレプリケーションプロセスを開始し、 &lt;code&gt;users&lt;/code&gt; と &lt;code&gt;departments&lt;/code&gt; のテーブルの初期テーブルコンテンツを同期してから、それらのテーブルへの増分変更のレプリケーションを開始します。</target>
        </trans-unit>
        <trans-unit id="4792ca68861299622c8a8489cae6e3ff6fc1e734" translate="yes" xml:space="preserve">
          <source>The access costs should include all disk and CPU costs associated with scanning the index itself, but &lt;em&gt;not&lt;/em&gt; the costs of retrieving or processing the parent-table rows that are identified by the index.</source>
          <target state="translated">アクセスコストには、インデックス自体のスキャンに関連するすべてのディスクとCPUのコストが含まれますが、インデックスによって識別される親テーブルの行の取得または処理のコストは含まれ&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="07883ad5be74942310a3c715c9a683e447816066" translate="yes" xml:space="preserve">
          <source>The access method can report that the index is &lt;em&gt;lossy&lt;/em&gt;, or requires rechecks, for a particular query. This implies that the index scan will return all the entries that pass the scan key, plus possibly additional entries that do not. The core system's index-scan machinery will then apply the index conditions again to the heap tuple to verify whether or not it really should be selected. If the recheck option is not specified, the index scan must return exactly the set of matching entries.</source>
          <target state="translated">アクセス方法は、特定のクエリに対してインデックスに&lt;em&gt;損失&lt;/em&gt;が&lt;em&gt;ある&lt;/em&gt;、または再チェックが必要であることを報告できます。これは、インデックススキャンがスキャンキーを渡すすべてのエントリに加えて、そうでない追加のエントリを返す可能性があることを意味します。コアシステムのインデックススキャン機構は、インデックス条件をヒープタプルに再度適用して、本当に選択する必要があるかどうかを確認します。再チェックオプションが指定されていない場合、インデックススキャンは、一致するエントリのセットを正確に返す必要があります。</target>
        </trans-unit>
        <trans-unit id="7463ace40ac0727457d3fd85331890fec1e03b44" translate="yes" xml:space="preserve">
          <source>The access method must identify any rows which might violate the unique constraint, but it is not an error for it to report false positives. This allows the check to be done without waiting for other transactions to finish; conflicts reported here are not treated as errors and will be rechecked later, by which time they may no longer be conflicts.</source>
          <target state="translated">アクセス・メソッドは一意性制約に違反する可能性のある行を識別しなければなりませんが、偽陽性を報告することはエラーではありません。これにより、他のトランザクションが終了するのを待たずにチェックを行うことができます。ここで報告された競合はエラーとしては扱われず、後で再チェックされます。</target>
        </trans-unit>
        <trans-unit id="3b57f7233950ac2f66da1f759e801ef6dd2f3764" translate="yes" xml:space="preserve">
          <source>The access method must support &lt;code&gt;amgettuple&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;Chapter 61&lt;/a&gt;); at present this means GIN cannot be used. Although it's allowed, there is little point in using B-tree or hash indexes with an exclusion constraint, because this does nothing that an ordinary unique constraint doesn't do better. So in practice the access method will always be GiST or SP-GiST.</source>
          <target state="translated">アクセス方法は &lt;code&gt;amgettuple&lt;/code&gt; をサポートする必要があります（&lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;第61章を&lt;/a&gt;参照）。現在、これはGINを使用できないことを意味します。これは許可されていますが、除外制約でBツリーまたはハッシュインデックスを使用してもほとんど意味がありません。これは、通常の一意の制約では改善されないためです。したがって、実際には、アクセス方法は常にGiSTまたはSP-GiSTになります。</target>
        </trans-unit>
        <trans-unit id="925d234c42527636b378041891a37fa8bc13f69a" translate="yes" xml:space="preserve">
          <source>The access method name must be unique within the database.</source>
          <target state="translated">アクセスメソッド名はデータベース内で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="269e5a0688390217e0c08f2b5f501b6e542e7ab1" translate="yes" xml:space="preserve">
          <source>The accumulated cost that will cause the vacuuming process to sleep. The default value is 200.</source>
          <target state="translated">バキューム処理をスリープ状態にする累積コスト。デフォルト値は200です。</target>
        </trans-unit>
        <trans-unit id="1dfce3d6c647c6b7a46c7536dcf8246e840a748e" translate="yes" xml:space="preserve">
          <source>The accumulating calendar error prompted Pope Gregory XIII to reform the calendar in accordance with instructions from the Council of Trent. In the Gregorian calendar, the tropical year is approximated as 365 + 97 / 400 days = 365.2425 days. Thus it takes approximately 3300 years for the tropical year to shift one day with respect to the Gregorian calendar.</source>
          <target state="translated">暦の誤りの蓄積は、教皇グレゴリオ13世に促され、トレント公会議の指示に基づいて暦を改正しました。グレゴリオ暦では、熱帯年は365+97/400日=365.2425日と近似しています。したがって、グレゴリオ暦では熱帯年が1日ずれるのに約3300年かかることになります。</target>
        </trans-unit>
        <trans-unit id="6e5a51f4541a92f0a7b8eafcdaec433dbe4bd0a9" translate="yes" xml:space="preserve">
          <source>The actions for identity columns (&lt;code&gt;ADD GENERATED&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt; etc., &lt;code&gt;DROP IDENTITY&lt;/code&gt;), as well as the actions &lt;code&gt;TRIGGER&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;OWNER&lt;/code&gt;, and &lt;code&gt;TABLESPACE&lt;/code&gt; never recurse to descendant tables; that is, they always act as though &lt;code&gt;ONLY&lt;/code&gt; were specified. Adding a constraint recurses only for &lt;code&gt;CHECK&lt;/code&gt; constraints that are not marked &lt;code&gt;NO INHERIT&lt;/code&gt;.</source>
          <target state="translated">ID列のアクション（ &lt;code&gt;ADD GENERATED&lt;/code&gt; 、 &lt;code&gt;SET&lt;/code&gt; など、 &lt;code&gt;DROP IDENTITY&lt;/code&gt; ）、およびアクション &lt;code&gt;TRIGGER&lt;/code&gt; 、 &lt;code&gt;CLUSTER&lt;/code&gt; 、 &lt;code&gt;OWNER&lt;/code&gt; 、および &lt;code&gt;TABLESPACE&lt;/code&gt; は、子孫テーブルに再帰することはありません。つまり、それらは常に指定されたものとして &lt;code&gt;ONLY&lt;/code&gt; 機能します。制約の追加は、 &lt;code&gt;NO INHERIT&lt;/code&gt; とマークされていない &lt;code&gt;CHECK&lt;/code&gt; 制約に対してのみ再帰します。</target>
        </trans-unit>
        <trans-unit id="909f7edd282ab8c888fdf2ed34039a5329b6ad7a" translate="yes" xml:space="preserve">
          <source>The actual choice here is mostly a matter of taste, constrained only by possible restrictions in client applications. Both methods support all possible values, although the hex encoding will be somewhat larger than the base64 encoding.</source>
          <target state="translated">ここでの実際の選択はほとんどが好みの問題であり、クライアントアプリケーションでの可能性のある制限によってのみ制約されます。どちらの方法もすべての可能な値をサポートしていますが、16進数のエンコーディングはbase64のエンコーディングよりも多少大きくなります。</target>
        </trans-unit>
        <trans-unit id="486a25c1f79db6232bfe3c602e8f3539de88dd46" translate="yes" xml:space="preserve">
          <source>The actual data types of the various &lt;code&gt;Datum&lt;/code&gt; values mentioned above vary depending on the operator class. The item values passed to &lt;code&gt;extractValue&lt;/code&gt; are always of the operator class's input type, and all key values must be of the class's &lt;code&gt;STORAGE&lt;/code&gt; type. The type of the &lt;code&gt;query&lt;/code&gt; argument passed to &lt;code&gt;extractQuery&lt;/code&gt;, &lt;code&gt;consistent&lt;/code&gt; and &lt;code&gt;triConsistent&lt;/code&gt; is whatever is the right-hand input type of the class member operator identified by the strategy number. This need not be the same as the indexed type, so long as key values of the correct type can be extracted from it. However, it is recommended that the SQL declarations of these three support functions use the opclass's indexed data type for the &lt;code&gt;query&lt;/code&gt; argument, even though the actual type might be something else depending on the operator.</source>
          <target state="translated">上記のさまざまな &lt;code&gt;Datum&lt;/code&gt; 値の実際のデータ型は、演算子クラスによって異なります。 &lt;code&gt;extractValue&lt;/code&gt; に渡されるアイテム値は常に演算子クラスの入力タイプであり、すべてのキー値はクラスの &lt;code&gt;STORAGE&lt;/code&gt; タイプである必要があります。 &lt;code&gt;extractQuery&lt;/code&gt; に渡される &lt;code&gt;query&lt;/code&gt; 引数のタイプ、 &lt;code&gt;consistent&lt;/code&gt; および &lt;code&gt;triConsistent&lt;/code&gt; 戦略番号で識別されるクラスメンバー演算子の右側の入力タイプは何でもかまいません。これは、正しいタイプのキー値を抽出できる限り、インデックス付きのタイプと同じである必要はありません。ただし、これら3つのサポート関数のSQL宣言では、演算子によっては実際の型が別の型である場合でも、 &lt;code&gt;query&lt;/code&gt; 引数にopclassのインデックス付きデータ型を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="941436b14f077228160b589974e7f72ed527cb34" translate="yes" xml:space="preserve">
          <source>The actual items themselves.</source>
          <target state="translated">実物そのもの。</target>
        </trans-unit>
        <trans-unit id="fffe8ba3b231865545aa8ca6fdb204ce35d44eac" translate="yes" xml:space="preserve">
          <source>The actual number of rows this query would select is 7000, but the &lt;code&gt;rows&lt;/code&gt; estimate is only approximate. If you try to duplicate this experiment, you will probably get a slightly different estimate; moreover, it can change after each &lt;code&gt;ANALYZE&lt;/code&gt; command, because the statistics produced by &lt;code&gt;ANALYZE&lt;/code&gt; are taken from a randomized sample of the table.</source>
          <target state="translated">このクエリが選択する実際の行数は7000ですが、推定 &lt;code&gt;rows&lt;/code&gt; 数は概算です。この実験を複製しようとすると、おそらく少し異なる見積もりが得られます。また、それぞれの後に変更することができ &lt;code&gt;ANALYZE&lt;/code&gt; によって生成された統計があるため、コマンド &lt;code&gt;ANALYZE&lt;/code&gt; テーブルの無作為サンプルから取られます。</target>
        </trans-unit>
        <trans-unit id="6d27af95eda9a00aefcefbbb3f7c08b95ed3e6d3" translate="yes" xml:space="preserve">
          <source>The actual output rows are computed using the &lt;code&gt;SELECT&lt;/code&gt; output expressions for each selected row or row group. (See &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; List&lt;/a&gt; below.)</source>
          <target state="translated">実際の出力行は、 &lt;code&gt;SELECT&lt;/code&gt; された行または行グループごとにSELECT出力式を使用して計算されます。（以下の&lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt; &lt;code&gt;SELECT&lt;/code&gt; リストを&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="747c207c89333b66eb66b4cfc2d12a9cf95c6535" translate="yes" xml:space="preserve">
          <source>The actual value of a parameter to the prepared statement. This must be an expression yielding a value that is compatible with the data type of this parameter, as was determined when the prepared statement was created.</source>
          <target state="translated">準備された文のパラメータの実際の値。これは、準備されたステートメントが作成されたときに決定されたように、このパラメータのデータ型と互換性のある値を生成する式でなければなりません。</target>
        </trans-unit>
        <trans-unit id="ac7f1235d4be6ac9ddfc264172bcdc008188f6f4" translate="yes" xml:space="preserve">
          <source>The added condition &lt;code&gt;stringu1 = 'xxx'&lt;/code&gt; reduces the output row count estimate, but not the cost because we still have to visit the same set of rows. Notice that the &lt;code&gt;stringu1&lt;/code&gt; clause cannot be applied as an index condition, since this index is only on the &lt;code&gt;unique1&lt;/code&gt; column. Instead it is applied as a filter on the rows retrieved by the index. Thus the cost has actually gone up slightly to reflect this extra checking.</source>
          <target state="translated">追加された条件 &lt;code&gt;stringu1 = 'xxx'&lt;/code&gt; は、出力行数の見積もりを削減しますが、同じ行のセットにアクセスする必要があるため、コストは削減されません。 &lt;code&gt;stringu1&lt;/code&gt; 句はインデックス条件として適用できないことに注意してください。これは、このインデックスが &lt;code&gt;unique1&lt;/code&gt; 列にのみ存在するためです。代わりに、インデックスによって取得された行のフィルターとして適用されます。したがって、この追加のチェックを反映するために、実際にはコストがわずかに上昇しています。</target>
        </trans-unit>
        <trans-unit id="0d6d3b7f07c64185ea468d2b62ff4270f9a83a5e" translate="yes" xml:space="preserve">
          <source>The additional &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; phase adds significant overhead: verification will typically take several times longer. However, there is no change to the relation-level locks acquired when &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is performed.</source>
          <target state="translated">追加&lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt;相は、かなりのオーバーヘッドが追加されます。検証は、一般的に長く、数回かかります。ただし、&lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt;検証の実行時に取得される関係レベルのロックに変更はありません。</target>
        </trans-unit>
        <trans-unit id="1ce4777382e2000ea7e60f8a7131343e38753550" translate="yes" xml:space="preserve">
          <source>The address (&lt;code&gt;LSN&lt;/code&gt;) of oldest WAL which still might be required by the consumer of this slot and thus won't be automatically removed during checkpoints. &lt;code&gt;NULL&lt;/code&gt; if the &lt;code&gt;LSN&lt;/code&gt; of this slot has never been reserved.</source>
          <target state="translated">最も古いWAL のアドレス（ &lt;code&gt;LSN&lt;/code&gt; ）。このスロットのコンシューマーがまだ必要とする可能性があるため、チェックポイント中に自動的に削除されません。このスロットの &lt;code&gt;LSN&lt;/code&gt; が予約されたことがない場合は &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="034439fc21dbd36a2802df824278cae81f75f88d" translate="yes" xml:space="preserve">
          <source>The address (&lt;code&gt;LSN&lt;/code&gt;) up to which the logical slot's consumer has confirmed receiving data. Data older than this is not available anymore. &lt;code&gt;NULL&lt;/code&gt; for physical slots.</source>
          <target state="translated">論理スロットのコンシューマーがデータの受信を確認したアドレス（ &lt;code&gt;LSN&lt;/code&gt; ）。これより古いデータはもう利用できません。物理スロットの場合は &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a0ec05d31abc58e50953bffde428d1c139a9fa7" translate="yes" xml:space="preserve">
          <source>The aggregate functions &lt;code&gt;array_agg&lt;/code&gt;, &lt;code&gt;json_agg&lt;/code&gt;, &lt;code&gt;jsonb_agg&lt;/code&gt;, &lt;code&gt;json_object_agg&lt;/code&gt;, &lt;code&gt;jsonb_object_agg&lt;/code&gt;, &lt;code&gt;string_agg&lt;/code&gt;, and &lt;code&gt;xmlagg&lt;/code&gt;, as well as similar user-defined aggregate functions, produce meaningfully different result values depending on the order of the input values. This ordering is unspecified by default, but can be controlled by writing an &lt;code&gt;ORDER BY&lt;/code&gt; clause within the aggregate call, as shown in &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;Section 4.2.7&lt;/a&gt;. Alternatively, supplying the input values from a sorted subquery will usually work. For example:</source>
          <target state="translated">集計関数 &lt;code&gt;array_agg&lt;/code&gt; 、 &lt;code&gt;json_agg&lt;/code&gt; 、 &lt;code&gt;jsonb_agg&lt;/code&gt; 、 &lt;code&gt;json_object_agg&lt;/code&gt; 、 &lt;code&gt;jsonb_object_agg&lt;/code&gt; 、 &lt;code&gt;string_agg&lt;/code&gt; 、および &lt;code&gt;xmlagg&lt;/code&gt; は、同様のユーザー定義集計関数と同様に、入力値の順序に応じて意味のある異なる結果値を生成します。この順序はデフォルトでは指定されていませんが、&lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;4.2.7項​​に&lt;/a&gt;示すように、集計呼び出し内で &lt;code&gt;ORDER BY&lt;/code&gt; 句を記述することで制御できます。あるいは、ソートされたサブクエリからの入力値の提供は通常は機能します。例えば：</target>
        </trans-unit>
        <trans-unit id="25a2a3e2d738bffa30059bdc53d46f7e3eca9a3f" translate="yes" xml:space="preserve">
          <source>The aggregator is an aggregate function &lt;code&gt;int_array_aggregate(integer)&lt;/code&gt; that produces an integer array containing exactly the integers it is fed. This is a wrapper around &lt;code&gt;array_agg&lt;/code&gt;, which does the same thing for any array type.</source>
          <target state="translated">アグリゲーターは、与えられた整数を正確に含む整数配列を生成する集約関数 &lt;code&gt;int_array_aggregate(integer)&lt;/code&gt; です。これは &lt;code&gt;array_agg&lt;/code&gt; のラッパーであり、どの配列タイプでも同じことを行います。</target>
        </trans-unit>
        <trans-unit id="424703d8d222e3285ae8821252bab5f244b1d269" translate="yes" xml:space="preserve">
          <source>The aim of WAL is to ensure that the log is written before database records are altered, but this can be subverted by disk drives that falsely report a successful write to the kernel, when in fact they have only cached the data and not yet stored it on the disk. A power failure in such a situation might lead to irrecoverable data corruption. Administrators should try to ensure that disks holding PostgreSQL's WAL log files do not make such false reports. (See &lt;a href=&quot;wal-reliability&quot;&gt;Section 29.1&lt;/a&gt;.)</source>
          <target state="translated">WALの目的は、データベースレコードが変更される前にログが確実に書き込まれるようにすることですが、実際にはデータをキャッシュし、まだ保存していない場合に、カーネルへの書き込みの成功を誤って報告するディスクドライブによってこれが破壊される可能性がありますディスク上。このような状況で電源障害が発生すると、回復不可能なデータ破損が発生する可能性があります。管理者は、PostgreSQLのWALログファイルを保持するディスクがそのような誤ったレポートを作成しないようにする必要があります。（&lt;a href=&quot;wal-reliability&quot;&gt;項29.1を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="f9e7ab5030dfc9ff217b5be87f2efd2576b52bbd" translate="yes" xml:space="preserve">
          <source>The algorithms in &lt;code&gt;crypt()&lt;/code&gt; differ from the usual MD5 or SHA1 hashing algorithms in the following respects:</source>
          <target state="translated">&lt;code&gt;crypt()&lt;/code&gt; のアルゴリズムは、通常のMD5またはSHA1ハッシュアルゴリズムと次の点で異なります。</target>
        </trans-unit>
        <trans-unit id="bb6ddacff228befd7481577e88b1910758787a46" translate="yes" xml:space="preserve">
          <source>The alias becomes the new name of the table reference so far as the current query is concerned &amp;mdash; it is not allowed to refer to the table by the original name elsewhere in the query. Thus, this is not valid:</source>
          <target state="translated">現在のクエリに関する限り、エイリアスはテーブル参照の新しい名前になります。クエリの他の場所で元の名前でテーブルを参照することはできません。したがって、これは無効です。</target>
        </trans-unit>
        <trans-unit id="5c707c122664d3415484ea0149341fcdfab44cfa" translate="yes" xml:space="preserve">
          <source>The allowed contents of a &lt;code&gt;RETURNING&lt;/code&gt; clause are the same as a &lt;code&gt;SELECT&lt;/code&gt; command's output list (see &lt;a href=&quot;queries-select-lists&quot;&gt;Section 7.3&lt;/a&gt;). It can contain column names of the command's target table, or value expressions using those columns. A common shorthand is &lt;code&gt;RETURNING *&lt;/code&gt;, which selects all columns of the target table in order.</source>
          <target state="translated">&lt;code&gt;RETURNING&lt;/code&gt; 句の許可される内容は、 &lt;code&gt;SELECT&lt;/code&gt; コマンドの出力リストと同じです（&lt;a href=&quot;queries-select-lists&quot;&gt;7.3節を&lt;/a&gt;参照）。コマンドのターゲットテーブルの列名、またはそれらの列を使用する値式を含めることができます。一般的な省略表現は &lt;code&gt;RETURNING *&lt;/code&gt; で、ターゲットテーブルのすべての列を順番に選択します。</target>
        </trans-unit>
        <trans-unit id="6fc27c228553cd704a3ef6963db1526d2404113f" translate="yes" xml:space="preserve">
          <source>The alternative archive file formats must be used with &lt;a href=&quot;app-pgrestore&quot;&gt;pg_restore&lt;/a&gt; to rebuild the database. They allow pg_restore to be selective about what is restored, or even to reorder the items prior to being restored. The archive file formats are designed to be portable across architectures.</source>
          <target state="translated">データベースを再構築するには、&lt;a href=&quot;app-pgrestore&quot;&gt;pg_restoreで&lt;/a&gt;代替アーカイブファイル形式を使用する必要があります。 pg_restoreは、復元するものを選択したり、復元する前にアイテムを並べ替えたりすることができます。アーカイブファイル形式は、アーキテクチャ間で移植できるように設計されています。</target>
        </trans-unit>
        <trans-unit id="30b730b12e2a6a8e73614c8aa5e3a5771cc3031c" translate="yes" xml:space="preserve">
          <source>The amount of information stored in &lt;code&gt;pg_statistic&lt;/code&gt; by &lt;code&gt;ANALYZE&lt;/code&gt;, in particular the maximum number of entries in the &lt;code&gt;most_common_vals&lt;/code&gt; and &lt;code&gt;histogram_bounds&lt;/code&gt; arrays for each column, can be set on a column-by-column basis using the &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; command, or globally by setting the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration variable. The default limit is presently 100 entries. Raising the limit might allow more accurate planner estimates to be made, particularly for columns with irregular data distributions, at the price of consuming more space in &lt;code&gt;pg_statistic&lt;/code&gt; and slightly more time to compute the estimates. Conversely, a lower limit might be sufficient for columns with simple data distributions.</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; によって &lt;code&gt;pg_statistic&lt;/code&gt; に保存される情報の量、特に各列の &lt;code&gt;most_common_vals&lt;/code&gt; と &lt;code&gt;histogram_bounds&lt;/code&gt; 配列のエントリの最大数は、 &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; コマンドを使用して列ごとに、またはグローバルに設定することによって設定できます&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;設定変数。デフォルトの制限は現在100エントリです。制限を上げると、 &lt;code&gt;pg_statistic&lt;/code&gt; でより多くのスペースを消費することを犠牲にして、特に不規則なデータ分布を持つ列に対して、より正確なプランナー推定が行われる可能性があります。見積もりを計算するのに少し時間がかかります。逆に、データ分布が単純な列の場合は、下限で十分な場合があります。</target>
        </trans-unit>
        <trans-unit id="0881173259f19f591f19be0dcc933c7ede671117" translate="yes" xml:space="preserve">
          <source>The amount of shared memory used for WAL data that has not yet been written to disk. The default setting of -1 selects a size equal to 1/32nd (about 3%) of &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but not less than &lt;code&gt;64kB&lt;/code&gt; nor more than the size of one WAL segment, typically &lt;code&gt;16MB&lt;/code&gt;. This value can be set manually if the automatic choice is too large or too small, but any positive value less than &lt;code&gt;32kB&lt;/code&gt; will be treated as &lt;code&gt;32kB&lt;/code&gt;. If this value is specified without units, it is taken as WAL blocks, that is &lt;code&gt;XLOG_BLCKSZ&lt;/code&gt; bytes, typically 8kB. This parameter can only be set at server start.</source>
          <target state="translated">ディスクにまだ書き込まれていないWALデータに使用される共有メモリの量。デフォルト設定の-1は、&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffersの1/32&lt;/a&gt;（約3％）に等しいサイズを選択しますが、 &lt;code&gt;64kB&lt;/code&gt; 以上、1つのWALセグメントのサイズ（通常は &lt;code&gt;16MB&lt;/code&gt; )以下を選択します。自動選択が大きすぎるか小さすぎる場合、この値は手動で設定できますが、 &lt;code&gt;32kB&lt;/code&gt; 未満の正の値は32kBとして扱われ &lt;code&gt;32kB&lt;/code&gt; 。この値が単位なしで指定されている場合、WALブロック、つまり &lt;code&gt;XLOG_BLCKSZ&lt;/code&gt; バイト、通常は8kBと見なされます。このパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="fb3e8e0a1884bdfed25b92caf4ca9464cbb400f7" translate="yes" xml:space="preserve">
          <source>The amount of time that the process will sleep when the cost limit has been exceeded. If this value is specified without units, it is taken as milliseconds. The default value is zero, which disables the cost-based vacuum delay feature. Positive values enable cost-based vacuuming.</source>
          <target state="translated">コストの上限を超えたときにプロセスがスリープする時間。この値が単位なしで指定された場合、ミリ秒として扱われます。デフォルト値はゼロで、コストベースのバキューム遅延機能は無効になります。正の値を指定すると、コストベースのバキュームが有効になります。</target>
        </trans-unit>
        <trans-unit id="398a780c0d81cf69e4ef47e3ad5d58413fde5194" translate="yes" xml:space="preserve">
          <source>The amount of time to delay just after a new server process is forked, before it conducts the authentication procedure. This is intended to give developers an opportunity to attach to the server process with a debugger to trace down misbehavior in authentication. If this value is specified without units, it is taken as seconds. A value of zero (the default) disables the delay. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">新しいサーバープロセスが分岐された直後に、認証手順が実行されるまでの遅延時間。これは、開発者がデバッガを使用してサーバープロセスに接続し、認証の不正な動作を追跡できるようにすることを目的としています。この値が単位なしで指定された場合、秒として取得されます。値0（デフォルト）は遅延を無効にします。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="eaa9e04a9a492e3d82c3eee69d98abd9fe97d974" translate="yes" xml:space="preserve">
          <source>The amount of time to delay when a new server process is started, after it conducts the authentication procedure. This is intended to give developers an opportunity to attach to the server process with a debugger. If this value is specified without units, it is taken as seconds. A value of zero (the default) disables the delay. This parameter cannot be changed after session start.</source>
          <target state="translated">新しいサーバプロセスが起動したときに、認証手続きを行った後に遅延させる時間を指定します。これは、開発者がデバッガを使ってサーバプロセスにアタッチする機会を与えることを目的としています。この値を単位なしで指定した場合は、秒として扱われます。0 (既定値)を指定すると、遅延は無効になります。このパラメータは、セッション開始後に変更することはできません。</target>
        </trans-unit>
        <trans-unit id="6eb708237d12cba546c559b2942241cf8b7e257d" translate="yes" xml:space="preserve">
          <source>The apply process on the subscriber database always runs with &lt;code&gt;session_replication_role&lt;/code&gt; set to &lt;code&gt;replica&lt;/code&gt;, which produces the usual effects on triggers and constraints.</source>
          <target state="translated">サブスクライバデータベースの適用プロセスは、常に &lt;code&gt;session_replication_role&lt;/code&gt; を &lt;code&gt;replica&lt;/code&gt; に設定して実行されます。これにより、トリガーと制約に通常の影響が生じます。</target>
        </trans-unit>
        <trans-unit id="7cc0c47ee6bb287c95c39ac65d501649b42f2391" translate="yes" xml:space="preserve">
          <source>The approach of lower-casing strings for comparison does not handle some Unicode special cases correctly, for example when one upper-case letter has two lower-case letter equivalents. Unicode distinguishes between &lt;em&gt;case mapping&lt;/em&gt; and &lt;em&gt;case folding&lt;/em&gt; for this reason. Use nondeterministic collations instead of &lt;code&gt;citext&lt;/code&gt; to handle that correctly.</source>
          <target state="translated">比較のための小文字の文字列のアプローチでは、たとえば1つの大文字に2つの小文字の同等物がある場合など、一部のUnicodeの特殊なケースが正しく処理されません。Unicodeは、このため、&lt;em&gt;大文字&lt;/em&gt;&lt;em&gt;小文字のマッピング&lt;/em&gt;と&lt;em&gt;フォールディング&lt;/em&gt;を区別します。これを正しく処理するには、 &lt;code&gt;citext&lt;/code&gt; の代わりに非決定的照合を使用します。</target>
        </trans-unit>
        <trans-unit id="6080666b4ca02e10aa81255d6daacddec5bda53b" translate="yes" xml:space="preserve">
          <source>The approximate average size (in bytes) of the aggregate's state value, when using moving-aggregate mode. This works the same as &lt;code&gt;state_data_size&lt;/code&gt;.</source>
          <target state="translated">移動集約モードを使用する場合の、集約の状態値のおおよその平均サイズ（バイト単位）。これは &lt;code&gt;state_data_size&lt;/code&gt; と同じように機能します。</target>
        </trans-unit>
        <trans-unit id="cd3a8a8bd1d1979e55b0fa66bfe45e8f15c71463" translate="yes" xml:space="preserve">
          <source>The approximate average size (in bytes) of the aggregate's state value. If this parameter is omitted or is zero, a default estimate is used based on the &lt;code&gt;state_data_type&lt;/code&gt;. The planner uses this value to estimate the memory required for a grouped aggregate query. The planner will consider using hash aggregation for such a query only if the hash table is estimated to fit in &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt;; therefore, large values of this parameter discourage use of hash aggregation.</source>
          <target state="translated">アグリゲートの状態値のおおよその平均サイズ（バイト単位）。このパラメーターが省略されるかゼロの場合、 &lt;code&gt;state_data_type&lt;/code&gt; に基づいてデフォルトの見積もりが使用されます。プランナーはこの値を使用して、グループ化された集計クエリに必要なメモリを見積もります。プランナーは、ハッシュテーブルが&lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt;に収まると推定される場合にのみ、そのようなクエリにハッシュ集約を使用することを検討します。したがって、このパラメーターの値が大きいと、ハッシュ集約を使用できなくなります。</target>
        </trans-unit>
        <trans-unit id="5bc1a8ecb6b5b4b69664dd591c46774534fc3e77" translate="yes" xml:space="preserve">
          <source>The approximation 365+97/400 is achieved by having 97 leap years every 400 years, using the following rules:</source>
          <target state="translated">近似365+97/400は、400年ごとに97のうるう年を持つことで、次のようなルールで達成されます。</target>
        </trans-unit>
        <trans-unit id="31a6736bfcac19a9525dbc2f1d3d326327c448b4" translate="yes" xml:space="preserve">
          <source>The archive command is only invoked on completed WAL segments. Hence, if your server generates only little WAL traffic (or has slack periods where it does so), there could be a long delay between the completion of a transaction and its safe recording in archive storage. To put a limit on how old unarchived data can be, you can set &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt; to force the server to switch to a new WAL segment file at least that often. Note that archived files that are archived early due to a forced switch are still the same length as completely full files. It is therefore unwise to set a very short &lt;code&gt;archive_timeout&lt;/code&gt; &amp;mdash; it will bloat your archive storage. &lt;code&gt;archive_timeout&lt;/code&gt; settings of a minute or so are usually reasonable.</source>
          <target state="translated">アーカイブコマンドは、完了したWALセグメントでのみ呼び出されます。したがって、サーバーが生成するWALトラフィックがほとんどない場合（またはそのようにスラック期間がある場合）、トランザクションの完了とアーカイブストレージへの安全な記録との間に長い遅延が生じる可能性があります。アーカイブされていない古いデータの保存期間を制限するには、&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt;を設定して、サーバーに少なくともその頻度で新しいWALセグメントファイルに強制的に切り替えさせます。強制切り替えのために早期にアーカイブされたアーカイブファイルは、完全に完全なファイルと同じ長さであることに注意してください。したがって、非常に短い &lt;code&gt;archive_timeout&lt;/code&gt; を設定することは賢明ではありません&amp;mdash;アーカイブストレージが肥大化します。通常、1分程度の &lt;code&gt;archive_timeout&lt;/code&gt; 設定が妥当です。</target>
        </trans-unit>
        <trans-unit id="4b5c4c289983b255b0c54296b2920b77c593a40a" translate="yes" xml:space="preserve">
          <source>The archive command should generally be designed to refuse to overwrite any pre-existing archive file. This is an important safety feature to preserve the integrity of your archive in case of administrator error (such as sending the output of two different servers to the same archive directory).</source>
          <target state="translated">archive コマンドは一般的に、既存のアーカイブファイルの上書きを拒否するように設計されているべきです。これは、管理者のエラーが発生した場合にアーカイブの整合性を維持するための重要な安全機能です (2 つの異なるサーバの出力を同じアーカイブディレクトリに送信するなど)。</target>
        </trans-unit>
        <trans-unit id="cf0db639e47353fbf356cd38ab714bab5a462b99" translate="yes" xml:space="preserve">
          <source>The archive command will be executed under the ownership of the same user that the PostgreSQL server is running as. Since the series of WAL files being archived contains effectively everything in your database, you will want to be sure that the archived data is protected from prying eyes; for example, archive into a directory that does not have group or world read access.</source>
          <target state="translated">アーカイブコマンドは、PostgreSQLサーバが実行しているのと同じユーザの所有下で実行されます。アーカイブされる一連のWALファイルは事実上データベース内のすべてのものを含んでいるので、アーカイブされたデータが盗み見から保護されていることを確認したいでしょう。</target>
        </trans-unit>
        <trans-unit id="c8f2b342beee7c3f52ad6834dd7e62ec7b49990d" translate="yes" xml:space="preserve">
          <source>The archive is a &lt;code&gt;tar&lt;/code&gt; archive.</source>
          <target state="translated">アーカイブは &lt;code&gt;tar&lt;/code&gt; アーカイブです。</target>
        </trans-unit>
        <trans-unit id="d5dd8d384e2ea3f19ced747049fc2fc3701b0b55" translate="yes" xml:space="preserve">
          <source>The archive is a directory archive.</source>
          <target state="translated">ディレクトリアーカイブになっています。</target>
        </trans-unit>
        <trans-unit id="055700e9693e4de21f0986775e962d50e33c74ee" translate="yes" xml:space="preserve">
          <source>The archive is in the custom format of pg_dump.</source>
          <target state="translated">アーカイブはpg_dumpのカスタムフォーマットです。</target>
        </trans-unit>
        <trans-unit id="eadab5c3d582261bf3c9c742fde723a5f27a622f" translate="yes" xml:space="preserve">
          <source>The argument is a pointer to a &lt;code&gt;GISTENTRY&lt;/code&gt; struct. On entry, its &lt;code&gt;key&lt;/code&gt; field contains a non-NULL leaf datum in compressed form. The return value is another &lt;code&gt;GISTENTRY&lt;/code&gt; struct, whose &lt;code&gt;key&lt;/code&gt; field contains the same datum in its original, uncompressed form. If the opclass's compress function does nothing for leaf entries, the &lt;code&gt;fetch&lt;/code&gt; method can return the argument as-is. Or, if the opclass does not have a compress function, the &lt;code&gt;fetch&lt;/code&gt; method can be omitted as well, since it would necessarily be a no-op.</source>
          <target state="translated">引数は &lt;code&gt;GISTENTRY&lt;/code&gt; 構造体へのポインタです。入力時、その &lt;code&gt;key&lt;/code&gt; フィールドには、圧縮された形式のNULL以外の葉データが含まれています。戻り値は別の &lt;code&gt;GISTENTRY&lt;/code&gt; 構造体であり、その &lt;code&gt;key&lt;/code&gt; フィールドには同じデータが元の非圧縮形式で含まれています。 opclassの圧縮関数がリーフエントリに対して何もしない場合、 &lt;code&gt;fetch&lt;/code&gt; メソッドは引数をそのまま返すことができます。または、opclassに圧縮関数がない場合は、 &lt;code&gt;fetch&lt;/code&gt; メソッドも省略できます。これは、必ずしも何もしないためです。</target>
        </trans-unit>
        <trans-unit id="dac840b1ef4656a9069d124658163a0da1612eba" translate="yes" xml:space="preserve">
          <source>The argument of &lt;code&gt;EXISTS&lt;/code&gt; is an arbitrary &lt;code&gt;SELECT&lt;/code&gt; statement, or &lt;em&gt;subquery&lt;/em&gt;. The subquery is evaluated to determine whether it returns any rows. If it returns at least one row, the result of &lt;code&gt;EXISTS&lt;/code&gt; is &amp;ldquo;true&amp;rdquo;; if the subquery returns no rows, the result of &lt;code&gt;EXISTS&lt;/code&gt; is &amp;ldquo;false&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;EXISTS&lt;/code&gt; の引数は、任意の &lt;code&gt;SELECT&lt;/code&gt; ステートメントまたは&lt;em&gt;サブクエリ&lt;/em&gt;です。サブクエリは、行を返すかどうかを判断するために評価されます。少なくとも1つの行を返す場合、 &lt;code&gt;EXISTS&lt;/code&gt; の結果は「true」です。サブクエリが行を返さない場合、 &lt;code&gt;EXISTS&lt;/code&gt; の結果は「false」になります。</target>
        </trans-unit>
        <trans-unit id="d6ba5cebe3465380bdcbb01333aff93c94b4f911" translate="yes" xml:space="preserve">
          <source>The arguments can appear in any order, not only the one shown above.</source>
          <target state="translated">引数は上記のものに限らず、任意の順番で出現することができます。</target>
        </trans-unit>
        <trans-unit id="e994da275c22b1ba01eba6c807a42b44a7a8c8c1" translate="yes" xml:space="preserve">
          <source>The arguments can optionally have names attached. See &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Section 4.3&lt;/a&gt; for details.</source>
          <target state="translated">引数にはオプションで名前を付けることができます。詳細については、&lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;セクション4.3&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bdbe896c9bc5e0129d6c42af254aeecec20136cc" translate="yes" xml:space="preserve">
          <source>The arguments of &lt;code&gt;\set&lt;/code&gt; are subject to the same substitution rules as with other commands. Thus you can construct interesting references such as &lt;code&gt;\set :foo 'something'&lt;/code&gt; and get &amp;ldquo;soft links&amp;rdquo; or &amp;ldquo;variable variables&amp;rdquo; of Perl or PHP fame, respectively. Unfortunately (or fortunately?), there is no way to do anything useful with these constructs. On the other hand, &lt;code&gt;\set bar :foo&lt;/code&gt; is a perfectly valid way to copy a variable.</source>
          <target state="translated">&lt;code&gt;\set&lt;/code&gt; の引数は、他のコマンドと同じ置換規則に従います。したがって、 &lt;code&gt;\set :foo 'something'&lt;/code&gt; などの興味深い参照を作成し、PerlまたはPHPの名声の「ソフトリンク」または「変数変数」をそれぞれ取得できます。残念ながら（または幸いなことに？）、これらの構成要素を使用して何かを行う方法はありません。一方、 &lt;code&gt;\set bar :foo&lt;/code&gt; は、変数をコピーするための完全に有効な方法です。</target>
        </trans-unit>
        <trans-unit id="2a1116027fc276cc8421c002135dbd224494828a" translate="yes" xml:space="preserve">
          <source>The arguments to the &lt;code&gt;distance&lt;/code&gt; function are identical to the arguments of the &lt;code&gt;consistent&lt;/code&gt; function.</source>
          <target state="translated">引数 &lt;code&gt;distance&lt;/code&gt; 関数は、引数のと同じです &lt;code&gt;consistent&lt;/code&gt; 機能。</target>
        </trans-unit>
        <trans-unit id="7770d5c449c9e31af54123c29733b7fdcc835b68" translate="yes" xml:space="preserve">
          <source>The arithmetic, bitwise, comparison and logical operators listed in &lt;a href=&quot;pgbench#PGBENCH-OPERATORS&quot;&gt;Table 258&lt;/a&gt; are built into pgbench and may be used in expressions appearing in &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt;&lt;code&gt;\set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pgbench#PGBENCH-OPERATORS&quot;&gt;表258に&lt;/a&gt;リストされている算術、ビットごと、比較、および論理演算子はpgbenchに組み込まれており、&lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt; &lt;code&gt;\set&lt;/code&gt; &lt;/a&gt;現れる式で使用できます。</target>
        </trans-unit>
        <trans-unit id="f99ae22a382dffdb58abe986f81d4d8fc31ff15a" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;scankeys&lt;/code&gt;, of length &lt;code&gt;nkeys&lt;/code&gt;, describes the index search condition(s). These conditions are combined with AND &amp;mdash; only index entries that satisfy all of them are interesting. (Note that &lt;code&gt;nkeys&lt;/code&gt; = 0 implies that all index entries satisfy the query.) Usually the consistent function only cares about the &lt;code&gt;sk_strategy&lt;/code&gt; and &lt;code&gt;sk_argument&lt;/code&gt; fields of each array entry, which respectively give the indexable operator and comparison value. In particular it is not necessary to check &lt;code&gt;sk_flags&lt;/code&gt; to see if the comparison value is NULL, because the SP-GiST core code will filter out such conditions. The array &lt;code&gt;orderbys&lt;/code&gt;, of length &lt;code&gt;norderbys&lt;/code&gt;, describes ordering operators (if any) in the same manner. &lt;code&gt;reconstructedValue&lt;/code&gt; is the value reconstructed for the parent tuple; it is &lt;code&gt;(Datum) 0&lt;/code&gt; at the root level or if the &lt;code&gt;inner_consistent&lt;/code&gt; function did not provide a value at the parent level. &lt;code&gt;reconstructedValue&lt;/code&gt; is always of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; type. &lt;code&gt;traversalValue&lt;/code&gt; is a pointer to any traverse data passed down from the previous call of &lt;code&gt;inner_consistent&lt;/code&gt; on the parent index tuple, or NULL at the root level. &lt;code&gt;traversalMemoryContext&lt;/code&gt; is the memory context in which to store output traverse values (see below). &lt;code&gt;level&lt;/code&gt; is the current inner tuple's level, starting at zero for the root level. &lt;code&gt;returnData&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if reconstructed data is required for this query; this will only be so if the &lt;code&gt;config&lt;/code&gt; function asserted &lt;code&gt;canReturnData&lt;/code&gt;. &lt;code&gt;allTheSame&lt;/code&gt; is true if the current inner tuple is marked &amp;ldquo;all-the-same&amp;rdquo;; in this case all the nodes have the same label (if any) and so either all or none of them match the query (see &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt;). &lt;code&gt;hasPrefix&lt;/code&gt; is true if the current inner tuple contains a prefix; if so, &lt;code&gt;prefixDatum&lt;/code&gt; is its value. &lt;code&gt;nNodes&lt;/code&gt; is the number of child nodes contained in the inner tuple, and &lt;code&gt;nodeLabels&lt;/code&gt; is an array of their label values, or NULL if the nodes do not have labels.</source>
          <target state="translated">長さが &lt;code&gt;nkeys&lt;/code&gt; の配列 &lt;code&gt;scankeys&lt;/code&gt; は、インデックス検索条件を記述します。これらの条件はANDと組み合わされます&amp;mdash;条件のすべてを満たすインデックスエントリのみが対象です。 （なお、 &lt;code&gt;nkeys&lt;/code&gt; = 0は、すべてのインデックスエントリは、クエリを満たすことを意味する。）通常、一貫した機能についてのみ心配 &lt;code&gt;sk_strategy&lt;/code&gt; と &lt;code&gt;sk_argument&lt;/code&gt; それぞれ割出し可能オペレータと比較値を与える各アレイ・エントリのフィールドを、。特に、SP-GiSTコアコードはそのような条件を除外するため、 &lt;code&gt;sk_flags&lt;/code&gt; をチェックして比較値がNULLかどうかを確認する必要はありません。配列 &lt;code&gt;orderbys&lt;/code&gt; 長の、 &lt;code&gt;norderbys&lt;/code&gt; は、演算子がある場合は、同じ方法で演算子を並べ替えます。 &lt;code&gt;reconstructedValue&lt;/code&gt; は、親タプルに対して再構築された値です。それは &lt;code&gt;(Datum) 0&lt;/code&gt; 場合は、ルートレベルまたは &lt;code&gt;inner_consistent&lt;/code&gt; 機能は、親レベルの値を提供しませんでした。 &lt;code&gt;reconstructedValue&lt;/code&gt; は常に &lt;code&gt;spgConfigOut&lt;/code&gt; です。 &lt;code&gt;leafType&lt;/code&gt; タイプ。 &lt;code&gt;traversalValue&lt;/code&gt; は、親インデックスタプルに対する &lt;code&gt;inner_consistent&lt;/code&gt; の前回の呼び出しから渡されたトラバースデータへのポインター、またはルートレベルのNULLです。 &lt;code&gt;traversalMemoryContext&lt;/code&gt; は、出力トラバース値を格納するメモリコンテキストです（以下を参照）。 &lt;code&gt;level&lt;/code&gt; ルートレベルのゼロから始まる、現在の内部タプルのレベルです。このクエリに再構築されたデータが必要な場合、 &lt;code&gt;returnData&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; です。これは、 &lt;code&gt;config&lt;/code&gt; 関数が &lt;code&gt;canReturnData&lt;/code&gt; をアサートした場合にのみ当てはまります。現在の内部タプルが「すべて同じ」とマークされている場合、 &lt;code&gt;allTheSame&lt;/code&gt; はtrueです。この場合、すべてのノードは同じラベル（存在する場合）を持つため、それらのすべてまたはいずれもクエリに一致しません（&lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;項65.4.3を&lt;/a&gt;参照）。現在の内部タプルにプレフィックスが含まれている場合、 &lt;code&gt;hasPrefix&lt;/code&gt; はtrueです。その場合、 &lt;code&gt;prefixDatum&lt;/code&gt; がその値です。 &lt;code&gt;nNodes&lt;/code&gt; は、内部タプルに含まれる子ノードの数であり、 &lt;code&gt;nodeLabels&lt;/code&gt; ラベル値の配列、またはノードにラベルがない場合はNULLです。</target>
        </trans-unit>
        <trans-unit id="b4cb45da91499c64a7e30418524dae4c6bc491fc" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;scankeys&lt;/code&gt;, of length &lt;code&gt;nkeys&lt;/code&gt;, describes the index search condition(s). These conditions are combined with AND &amp;mdash; only index entries that satisfy all of them satisfy the query. (Note that &lt;code&gt;nkeys&lt;/code&gt; = 0 implies that all index entries satisfy the query.) Usually the consistent function only cares about the &lt;code&gt;sk_strategy&lt;/code&gt; and &lt;code&gt;sk_argument&lt;/code&gt; fields of each array entry, which respectively give the indexable operator and comparison value. In particular it is not necessary to check &lt;code&gt;sk_flags&lt;/code&gt; to see if the comparison value is NULL, because the SP-GiST core code will filter out such conditions. The array &lt;code&gt;orderbys&lt;/code&gt;, of length &lt;code&gt;norderbys&lt;/code&gt;, describes the ordering operators in the same manner. &lt;code&gt;reconstructedValue&lt;/code&gt; is the value reconstructed for the parent tuple; it is &lt;code&gt;(Datum) 0&lt;/code&gt; at the root level or if the &lt;code&gt;inner_consistent&lt;/code&gt; function did not provide a value at the parent level. &lt;code&gt;reconstructedValue&lt;/code&gt; is always of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; type. &lt;code&gt;traversalValue&lt;/code&gt; is a pointer to any traverse data passed down from the previous call of &lt;code&gt;inner_consistent&lt;/code&gt; on the parent index tuple, or NULL at the root level. &lt;code&gt;level&lt;/code&gt; is the current leaf tuple's level, starting at zero for the root level. &lt;code&gt;returnData&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if reconstructed data is required for this query; this will only be so if the &lt;code&gt;config&lt;/code&gt; function asserted &lt;code&gt;canReturnData&lt;/code&gt;. &lt;code&gt;leafDatum&lt;/code&gt; is the key value of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; stored in the current leaf tuple.</source>
          <target state="translated">長さが &lt;code&gt;nkeys&lt;/code&gt; の配列 &lt;code&gt;scankeys&lt;/code&gt; は、インデックス検索条件を記述します。これらの条件はANDと組み合わされます。これらすべての条件を満たすインデックスエントリのみがクエリを満たします。 （なお、 &lt;code&gt;nkeys&lt;/code&gt; = 0は、すべてのインデックスエントリは、クエリを満たすことを意味する。）通常、一貫した機能についてのみ心配 &lt;code&gt;sk_strategy&lt;/code&gt; と &lt;code&gt;sk_argument&lt;/code&gt; それぞれ割出し可能オペレータと比較値を与える各アレイ・エントリのフィールドを、。特に、SP-GiSTコアコードはそのような条件を除外するため、 &lt;code&gt;sk_flags&lt;/code&gt; をチェックして比較値がNULLかどうかを確認する必要はありません。配列 &lt;code&gt;orderbys&lt;/code&gt; 長の、 &lt;code&gt;norderbys&lt;/code&gt; 、順序付け演算子を同じ方法で説明します。 &lt;code&gt;reconstructedValue&lt;/code&gt; は、親タプルに対して再構築された値です。それは &lt;code&gt;(Datum) 0&lt;/code&gt; 場合は、ルートレベルまたは &lt;code&gt;inner_consistent&lt;/code&gt; 機能は、親レベルの値を提供しませんでした。 &lt;code&gt;reconstructedValue&lt;/code&gt; は常に &lt;code&gt;spgConfigOut&lt;/code&gt; です。 &lt;code&gt;leafType&lt;/code&gt; タイプ。 &lt;code&gt;traversalValue&lt;/code&gt; は、親インデックスタプルに対する &lt;code&gt;inner_consistent&lt;/code&gt; の前回の呼び出しから渡されたトラバースデータへのポインター、またはルートレベルのNULLです。 &lt;code&gt;level&lt;/code&gt; は、現在のリーフタプルのレベルであり、ルートレベルのゼロから始まります。 &lt;code&gt;returnData&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; このクエリに再構築されたデータが必要な場合。これは、 &lt;code&gt;config&lt;/code&gt; 関数が &lt;code&gt;canReturnData&lt;/code&gt; をアサートした場合にのみ当てはまります。 &lt;code&gt;leafDatum&lt;/code&gt; は、キー値である &lt;code&gt;spgConfigOut&lt;/code&gt; 。現在の &lt;code&gt;leafType&lt;/code&gt; 格納されているleafType。</target>
        </trans-unit>
        <trans-unit id="e26f508cb31ef1599228fd2a799f7ebeb7c2026b" translate="yes" xml:space="preserve">
          <source>The array containment operators (&lt;code&gt;&amp;lt;@&lt;/code&gt; and &lt;code&gt;@&amp;gt;&lt;/code&gt;) consider one array to be contained in another one if each of its elements appears in the other one. Duplicates are not treated specially, thus &lt;code&gt;ARRAY[1]&lt;/code&gt; and &lt;code&gt;ARRAY[1,1]&lt;/code&gt; are each considered to contain the other.</source>
          <target state="translated">配列包含演算子（ &lt;code&gt;&amp;lt;@&lt;/code&gt; および &lt;code&gt;@&amp;gt;&lt;/code&gt; ）は、各要素が他の配列に出現する場合、1つの配列が別の配列に含まれていると見なします。重複は特別に処理されないため、 &lt;code&gt;ARRAY[1]&lt;/code&gt; と &lt;code&gt;ARRAY[1,1]&lt;/code&gt; はそれぞれ他方を含むと見なされます。</target>
        </trans-unit>
        <trans-unit id="a1ac56c0bce21554d688d27823930a835d434c12" translate="yes" xml:space="preserve">
          <source>The array ordering operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, etc) compare the array contents element-by-element, using the default B-tree comparison function for the element data type, and sort based on the first difference. In multidimensional arrays the elements are visited in row-major order (last subscript varies most rapidly). If the contents of two arrays are equal but the dimensionality is different, the first difference in the dimensionality information determines the sort order. (This is a change from versions of PostgreSQL prior to 8.2: older versions would claim that two arrays with the same contents were equal, even if the number of dimensions or subscript ranges were different.)</source>
          <target state="translated">配列順序付け演算子（ &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;=&lt;/code&gt; など）は、要素のデータ型のデフォルトのBツリー比較関数を使用して、配列の内容を要素ごとに比較し、最初の違いに基づいてソートします。多次元配列では、要素は行優先順でアクセスされます（最後の添え字は最も急速に変化します）。 2つの配列の内容は等しいが次元数が異なる場合、次元数情報の最初の違いがソート順を決定します。 （これは8.2より前のバージョンのPostgreSQLからの変更点です。古いバージョンでは、次元数または添え字範囲の数が異なっていても、同じ内容の2つの配列は等しいと主張していました。）</target>
        </trans-unit>
        <trans-unit id="46741e31bee949b907d3858dce5eac23fd4bcbdf" translate="yes" xml:space="preserve">
          <source>The array output routine will include explicit dimensions in its result only when there are one or more lower bounds different from one.</source>
          <target state="translated">配列出力ルーチンは、下界が1つ以上異なる場合にのみ、その結果に明示的な次元を含みます。</target>
        </trans-unit>
        <trans-unit id="145d4d2c0c7cafb8b7bd9116657b494c47b146d7" translate="yes" xml:space="preserve">
          <source>The array output routine will put double quotes around element values if they are empty strings, contain curly braces, delimiter characters, double quotes, backslashes, or white space, or match the word &lt;code&gt;NULL&lt;/code&gt;. Double quotes and backslashes embedded in element values will be backslash-escaped. For numeric data types it is safe to assume that double quotes will never appear, but for textual data types one should be prepared to cope with either the presence or absence of quotes.</source>
          <target state="translated">配列出力ルーチンは、要素の値が空の文字列である場合、中括弧、区切り文字、二重引用符、バックスラッシュ、または空白を含む場合、または単語 &lt;code&gt;NULL&lt;/code&gt; に一致する場合、要素値を二重引用符で囲みます。要素の値に埋め込まれた二重引用符とバックスラッシュは、バックスラッシュでエスケープされます。数値データ型の場合、二重引用符は表示されないと想定しても安全ですが、テキストデータ型の場合、引用符の有無に対処できるように準備しておく必要があります。</target>
        </trans-unit>
        <trans-unit id="103411c7faff9f23f3f96fc9d71ef919bccd0156" translate="yes" xml:space="preserve">
          <source>The array subscript numbers are written within square brackets. By default PostgreSQL uses a one-based numbering convention for arrays, that is, an array of &lt;code&gt;n&lt;/code&gt; elements starts with &lt;code&gt;array[1]&lt;/code&gt; and ends with &lt;code&gt;array[n]&lt;/code&gt;.</source>
          <target state="translated">配列の添え字番号は角括弧内に記述されます。デフォルトでは、PostgreSQLは配列に1ベースの番号付け規則を使用します。つまり、 &lt;code&gt;n&lt;/code&gt; 要素の配列は &lt;code&gt;array[1]&lt;/code&gt; で始まり、 &lt;code&gt;array[n]&lt;/code&gt; 終わります。</target>
        </trans-unit>
        <trans-unit id="d22d8bf767f7e2f65ff41f5dea0e4f13bccb5b56" translate="yes" xml:space="preserve">
          <source>The associated sort operator for a &lt;code&gt;MIN&lt;/code&gt;- or &lt;code&gt;MAX&lt;/code&gt;-like aggregate. This is just an operator name (possibly schema-qualified). The operator is assumed to have the same input data types as the aggregate (which must be a single-argument normal aggregate).</source>
          <target state="translated">&lt;code&gt;MIN&lt;/code&gt; または &lt;code&gt;MAX&lt;/code&gt; のような集約に関連付けられたソート演算子。これは単なる演算子名です（スキーマ修飾されている可能性があります）。演算子は、集約と同じ入力データ型（単一引数の通常の集約でなければならない）であると想定されています。</target>
        </trans-unit>
        <trans-unit id="daf89077b4ae20ed63b034eee053148490bd888b" translate="yes" xml:space="preserve">
          <source>The asterisk (&lt;code&gt;*&lt;/code&gt;) is used in some contexts to denote all the fields of a table row or composite value. It also has a special meaning when used as the argument of an aggregate function, namely that the aggregate does not require any explicit parameter.</source>
          <target state="translated">アスタリスク（ &lt;code&gt;*&lt;/code&gt; ）は、テーブルの行または複合値のすべてのフィールドを示すために、一部のコンテキストで使用されます。また、集約関数の引数として使用する場合は特別な意味があります。つまり、集約は明示的なパラメータを必要としません。</target>
        </trans-unit>
        <trans-unit id="a8f1751d17a34d74d41affe83afc62bf9926cd57" translate="yes" xml:space="preserve">
          <source>The autocommit-on mode is PostgreSQL's traditional behavior, but autocommit-off is closer to the SQL spec. If you prefer autocommit-off, you might wish to set it in the system-wide &lt;code&gt;psqlrc&lt;/code&gt; file or your &lt;code&gt;~/.psqlrc&lt;/code&gt; file.</source>
          <target state="translated">自動コミットオンモードはPostgreSQLの従来の動作ですが、自動コミットオフはSQL仕様により近くなっています。自動コミットオフを希望する場合は、システム全体の &lt;code&gt;psqlrc&lt;/code&gt; ファイルまたは &lt;code&gt;~/.psqlrc&lt;/code&gt; ファイルに設定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a786e81687748275f55ad70f3f5bbc00d402d949" translate="yes" xml:space="preserve">
          <source>The autovacuum daemon does not issue &lt;code&gt;ANALYZE&lt;/code&gt; commands for foreign tables, since it has no means of determining how often that might be useful. If your queries require statistics on foreign tables for proper planning, it's a good idea to run manually-managed &lt;code&gt;ANALYZE&lt;/code&gt; commands on those tables on a suitable schedule.</source>
          <target state="translated">autovacuumデーモンは、有用である可能性のある頻度を判別する手段がないため、外部テーブルに対して &lt;code&gt;ANALYZE&lt;/code&gt; コマンドを発行しません。クエリで適切な計画のために外部テーブルの統計が必要な場合は、それらのテーブルに対して手動で管理された &lt;code&gt;ANALYZE&lt;/code&gt; コマンドを適切なスケジュールで実行することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c3fb21098ee7138941d3ecbb7f53e34e6b514d65" translate="yes" xml:space="preserve">
          <source>The autovacuum daemon, if enabled, will automatically issue &lt;code&gt;ANALYZE&lt;/code&gt; commands whenever the content of a table has changed sufficiently. However, administrators might prefer to rely on manually-scheduled &lt;code&gt;ANALYZE&lt;/code&gt; operations, particularly if it is known that update activity on a table will not affect the statistics of &amp;ldquo;interesting&amp;rdquo; columns. The daemon schedules &lt;code&gt;ANALYZE&lt;/code&gt; strictly as a function of the number of rows inserted or updated; it has no knowledge of whether that will lead to meaningful statistical changes.</source>
          <target state="translated">自動バキュームデーモンが有効になっている場合、テーブルの内容が十分に変更されると、 &lt;code&gt;ANALYZE&lt;/code&gt; コマンドが自動的に発行されます。ただし、管理者は、特にテーブルの更新アクティビティが「興味深い」列の統計に影響しないことがわかっている場合は、手動でスケジュールされた &lt;code&gt;ANALYZE&lt;/code&gt; 操作に依存することを好むかもしれません。デーモンは &lt;code&gt;ANALYZE&lt;/code&gt; を厳密に、挿入または更新された行数の関数としてスケジュールします。それが意味のある統計的変化につながるかどうかについては知りません。</target>
        </trans-unit>
        <trans-unit id="252860c5ed0258d1ec21ceb8459b34f92032e663" translate="yes" xml:space="preserve">
          <source>The availability of the different password-based authentication methods depends on how a user's password on the server is encrypted (or hashed, more accurately). This is controlled by the configuration parameter &lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt; at the time the password is set. If a password was encrypted using the &lt;code&gt;scram-sha-256&lt;/code&gt; setting, then it can be used for the authentication methods &lt;code&gt;scram-sha-256&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; (but password transmission will be in plain text in the latter case). The authentication method specification &lt;code&gt;md5&lt;/code&gt; will automatically switch to using the &lt;code&gt;scram-sha-256&lt;/code&gt; method in this case, as explained above, so it will also work. If a password was encrypted using the &lt;code&gt;md5&lt;/code&gt; setting, then it can be used only for the &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; authentication method specifications (again, with the password transmitted in plain text in the latter case). (Previous PostgreSQL releases supported storing the password on the server in plain text. This is no longer possible.) To check the currently stored password hashes, see the system catalog &lt;code&gt;pg_authid&lt;/code&gt;.</source>
          <target state="translated">さまざまなパスワードベースの認証方法を使用できるかどうかは、サーバー上のユーザーのパスワードをどのように暗号化（またはハッシュ化）するかによって異なります。これは、パスワードの設定時に構成パラメーター&lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt;によって制御されます。パスワードが &lt;code&gt;scram-sha-256&lt;/code&gt; 設定を使用して暗号化されている場合、認証方法 &lt;code&gt;scram-sha-256&lt;/code&gt; と &lt;code&gt;password&lt;/code&gt; 使用できます（ただし、パスワードの送信は、後者の場合はプレーンテキストになります）。この場合、認証方法の指定 &lt;code&gt;md5&lt;/code&gt; は、上で説明したように &lt;code&gt;scram-sha-256&lt;/code&gt; 方法を使用するように自動的に切り替わるため、機能します。パスワードが &lt;code&gt;md5&lt;/code&gt; を使用して暗号化されている場合設定すると、 &lt;code&gt;md5&lt;/code&gt; および &lt;code&gt;password&lt;/code&gt; 認証方法の仕様でのみ使用できます（後者の場合も、パスワードはプレーンテキストで送信されます）。（以前のPostgreSQLリリースでは、サーバーへのパスワードのプレーンテキストでの保存がサポートされていました。これはできなくなりました。）現在保存されているパスワードハッシュを確認するには、システムカタログ &lt;code&gt;pg_authid&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="be4db45cb9d664398bfb8a833d78745c5f0e03cb" translate="yes" xml:space="preserve">
          <source>The available commands are:</source>
          <target state="translated">使用可能なコマンドは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="a8b4cfaf9660d8b419b38ef501d2e57aeb699d73" translate="yes" xml:space="preserve">
          <source>The available functions are shown in &lt;a href=&quot;ltree#LTREE-FUNC-TABLE&quot;&gt;Table F.14&lt;/a&gt;.</source>
          <target state="translated">利用可能な機能を&lt;a href=&quot;ltree#LTREE-FUNC-TABLE&quot;&gt;表F.14に&lt;/a&gt;示します。</target>
        </trans-unit>
        <trans-unit id="4cf27edb4ec77236cfb1d7851c53ced1470b1ae0" translate="yes" xml:space="preserve">
          <source>The available privileges are:</source>
          <target state="translated">利用可能な特典は</target>
        </trans-unit>
        <trans-unit id="b24cdea942d5e58d37185d11c8d0001459291bc6" translate="yes" xml:space="preserve">
          <source>The available sequence functions are:</source>
          <target state="translated">利用可能なシーケンス機能は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="1f54359e34884f0f14a7082c4b037dceb1040a71" translate="yes" xml:space="preserve">
          <source>The available transaction characteristics are the transaction isolation level, the transaction access mode (read/write or read-only), and the deferrable mode. In addition, a snapshot can be selected, though only for the current transaction, not as a session default.</source>
          <target state="translated">利用可能なトランザクション特性は、トランザクション分離レベル、トランザクショ ンアクセスモード(読み取り/書き込みまたは読み取り専用)、および遅延可能なモードである。さらに、セッションのデフォルトではなく、現在のトランザクショ ンに対してのみであるが、スナップショットを選択することができる。</target>
        </trans-unit>
        <trans-unit id="690838e9cb021af0a2b1acec6c3a93a7e08f1bb6" translate="yes" xml:space="preserve">
          <source>The average stored width, in bytes, of nonnull entries</source>
          <target state="translated">非ヌル項目の平均格納幅(バイト単位)。</target>
        </trans-unit>
        <trans-unit id="fde6e34822920c61d23e994603a609b1307667e3" translate="yes" xml:space="preserve">
          <source>The background writer is active during recovery and will perform restartpoints (similar to checkpoints on the primary) and normal block cleaning activities. This can include updates of the hint bit information stored on the standby server. The &lt;code&gt;CHECKPOINT&lt;/code&gt; command is accepted during recovery, though it performs a restartpoint rather than a new checkpoint.</source>
          <target state="translated">バックグラウンドライターはリカバリ中アクティブであり、再起動ポイント（プライマリのチェックポイントと同様）および通常のブロッククリーニングアクティビティを実行します。これには、スタンバイサーバーに格納されているヒントビット情報の更新が含まれます。 &lt;code&gt;CHECKPOINT&lt;/code&gt; のそれはリスタートではなく、新しいチェックポイントを実行しても、コマンドは、リカバリ中に受け入れられています。</target>
        </trans-unit>
        <trans-unit id="6a4770c7c3de3b5a6b683a55e8771f9ee1778b13" translate="yes" xml:space="preserve">
          <source>The backup history file is just a small text file. It contains the label string you gave to &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;, as well as the starting and ending times and WAL segments of the backup. If you used the label to identify the associated dump file, then the archived history file is enough to tell you which dump file to restore.</source>
          <target state="translated">バックアップ履歴ファイルは小さなテキストファイルです。これには、&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackupに指定し&lt;/a&gt;たラベル文字列、バックアップの開始時間と終了時間、およびWALセグメントが含まれています。ラベルを使用して関連するダンプファイルを識別した場合、アーカイブされた履歴ファイルは、どのダンプファイルを復元するかを通知するのに十分です。</target>
        </trans-unit>
        <trans-unit id="c801dce038f073674a8ac5aca2db97b365640813" translate="yes" xml:space="preserve">
          <source>The backup history file is not created in the database cluster backed up.</source>
          <target state="translated">バックアップしたデータベースクラスタにバックアップ履歴ファイルが作成されません。</target>
        </trans-unit>
        <trans-unit id="be7e03b230f28bb65cecb0388bcfd3f69ad98241" translate="yes" xml:space="preserve">
          <source>The backup is made over a regular PostgreSQL connection, and uses the replication protocol. The connection must be made with a superuser or a user having &lt;code&gt;REPLICATION&lt;/code&gt; permissions (see &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt;), and &lt;code&gt;pg_hba.conf&lt;/code&gt; must explicitly permit the replication connection. The server must also be configured with &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; set high enough to leave at least one session available for the backup and one for WAL streaming (if used).</source>
          <target state="translated">バックアップは通常のPostgreSQL接続を介して行われ、レプリケーションプロトコルを使用します。接続は、スーパーユーザーまたは &lt;code&gt;REPLICATION&lt;/code&gt; 権限（&lt;a href=&quot;role-attributes&quot;&gt;セクション21.2を&lt;/a&gt;参照）を持つユーザーを使用して行う必要があり、 &lt;code&gt;pg_hba.conf&lt;/code&gt; はレプリケーション接続を明示的に許可する必要があります。サーバーは、少なくとも1つのセッションをバックアップに、&lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;残りの&lt;/a&gt; 1つをWALストリーミング（使用する場合）に使用できるように、max_wal_sendersを十分に高く設定して構成する必要もあります。</target>
        </trans-unit>
        <trans-unit id="eee28f79bda7267e3e26bc973ac8a0442a749a1b" translate="yes" xml:space="preserve">
          <source>The backup label file includes the label string you gave to &lt;code&gt;pg_start_backup&lt;/code&gt;, as well as the time at which &lt;code&gt;pg_start_backup&lt;/code&gt; was run, and the name of the starting WAL file. In case of confusion it is therefore possible to look inside a backup file and determine exactly which backup session the dump file came from. The tablespace map file includes the symbolic link names as they exist in the directory &lt;code&gt;pg_tblspc/&lt;/code&gt; and the full path of each symbolic link. These files are not merely for your information; their presence and contents are critical to the proper operation of the system's recovery process.</source>
          <target state="translated">バックアップラベルファイルには、 &lt;code&gt;pg_start_backup&lt;/code&gt; に指定したラベル文字列、 &lt;code&gt;pg_start_backup&lt;/code&gt; が実行された時刻、および開始WALファイルの名前が含まれています。したがって、混乱した場合は、バックアップファイルの内部を調べて、ダンプファイルのバックアップセッションを正確に特定することができます。テーブルスペースマップファイルには、 &lt;code&gt;pg_tblspc/&lt;/code&gt; ディレクトリに存在するシンボリックリンク名と、各シンボリックリンクの絶対パスが含まれています。これらのファイルは単に情報を提供するものではありません。それらの存在と内容は、システムの回復プロセスの適切な操作に不可欠です。</target>
        </trans-unit>
        <trans-unit id="ec28fc3545975c7f203eb96bb815ab982f3d0305" translate="yes" xml:space="preserve">
          <source>The backup will include all files in the data directory and tablespaces, including the configuration files and any additional files placed in the directory by third parties, except certain temporary files managed by PostgreSQL. But only regular files and directories are copied, except that symbolic links used for tablespaces are preserved. Symbolic links pointing to certain directories known to PostgreSQL are copied as empty directories. Other symbolic links and special device files are skipped. See &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt; for the precise details.</source>
          <target state="translated">バックアップには、PostgreSQLが管理する特定の一時ファイルを除いて、データディレクトリとテーブルスペース内のすべてのファイルが含まれます。ただし、テーブルスペースに使用されるシンボリックリンクが保持されることを除いて、通常のファイルとディレクトリのみがコピーされます。PostgreSQLが認識している特定のディレクトリを指すシンボリックリンクは、空のディレクトリとしてコピーされます。他のシンボリックリンクと特別なデバイスファイルはスキップされます。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;セクション52.4&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5658ad1f6ce193a23633c994bf8ae4b8bb4bf57e" translate="yes" xml:space="preserve">
          <source>The base name of the shared object containing the output plugin this logical slot is using, or null for physical slots.</source>
          <target state="translated">この論理スロットが使用している出力プラグインを含む共有オブジェクトのベース名。</target>
        </trans-unit>
        <trans-unit id="01f76877be594c383342f8dd0d2d641fff88c4a5" translate="yes" xml:space="preserve">
          <source>The basic idea is to copy all file system-level changes from the source cluster to the target cluster:</source>
          <target state="translated">基本的な考え方は、すべてのファイルシステムレベルの変更をソースクラスタからターゲットクラスタにコピーすることです。</target>
        </trans-unit>
        <trans-unit id="19e50f37cd3ac57ef618ac5cb372c8487c7f1bd1" translate="yes" xml:space="preserve">
          <source>The basic value of &lt;code&gt;SELECT&lt;/code&gt; in &lt;code&gt;WITH&lt;/code&gt; is to break down complicated queries into simpler parts. An example is:</source>
          <target state="translated">基本値 &lt;code&gt;SELECT&lt;/code&gt; での &lt;code&gt;WITH&lt;/code&gt; は、単純な部分に複雑なクエリを打破することです。例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a2b5aa5c42d40515ef87930aadc0b43fe175a670" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;%&lt;/code&gt; is a bit complicated. It tries to match words rather than the entire label. For example &lt;code&gt;foo_bar%&lt;/code&gt; matches &lt;code&gt;foo_bar_baz&lt;/code&gt; but not &lt;code&gt;foo_barbaz&lt;/code&gt;. If combined with &lt;code&gt;*&lt;/code&gt;, prefix matching applies to each word separately, for example &lt;code&gt;foo_bar%*&lt;/code&gt; matches &lt;code&gt;foo1_bar2_baz&lt;/code&gt; but not &lt;code&gt;foo1_br2_baz&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; の動作は少し複雑です。ラベル全体ではなく、単語を一致させようとします。たとえば、 &lt;code&gt;foo_bar%&lt;/code&gt; は &lt;code&gt;foo_barbaz&lt;/code&gt; 一致し &lt;code&gt;foo_bar_baz&lt;/code&gt; が、foo_barbazとは一致しません。 &lt;code&gt;*&lt;/code&gt; と組み合わせると、プレフィックス一致は各単語に個別に適用されます。たとえば、 &lt;code&gt;foo_bar%*&lt;/code&gt; は &lt;code&gt;foo1_br2_baz&lt;/code&gt; 一致し &lt;code&gt;foo1_bar2_baz&lt;/code&gt; が、foo1_br2_bazとは一致しません。</target>
        </trans-unit>
        <trans-unit id="1e8f85d7de8ab2c8253e41f10bbddbd7196e58ed" translate="yes" xml:space="preserve">
          <source>The behavior of a custom text search configuration can easily become confusing. The functions described in this section are useful for testing text search objects. You can test a complete configuration, or test parsers and dictionaries separately.</source>
          <target state="translated">カスタムテキスト検索設定の動作は、簡単に混乱を招く可能性があります。このセクションで説明する機能は、テキスト検索オブジェクトをテストするのに便利です。完全な構成をテストすることも、パーサと辞書を別々にテストすることもできます。</target>
        </trans-unit>
        <trans-unit id="7b27c83984e819ed5cc108965dd1a811c9d23e12" translate="yes" xml:space="preserve">
          <source>The behavior of foreign keys can be finely tuned to your application. We will not go beyond this simple example in this tutorial, but just refer you to &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;Chapter 5&lt;/a&gt; for more information. Making correct use of foreign keys will definitely improve the quality of your database applications, so you are strongly encouraged to learn about them.</source>
          <target state="translated">外部キーの動作は、アプリケーションに合わせて微調整できます。このチュートリアルでは、この単純な例を超えることはしませんが、詳細については&lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;第5章を&lt;/a&gt;参照してください。外部キーを正しく使用すると、データベースアプリケーションの品質が確実に向上するため、それらについて学ぶことを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="296b0cebbabc7c8e4b2d8335b6fb9121ab843326" translate="yes" xml:space="preserve">
          <source>The behavior of temporary tables at the end of a transaction block can be controlled using &lt;code&gt;ON COMMIT&lt;/code&gt;. The three options are:</source>
          <target state="translated">トランザクションブロックの最後の一時テーブルの動作は、 &lt;code&gt;ON COMMIT&lt;/code&gt; を使用して制御できます。次の3つのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="80731f14bda7a7a22a0a9014398f2bbf94eee233" translate="yes" xml:space="preserve">
          <source>The behavior of the &lt;code&gt;-t&lt;/code&gt; switch is not entirely upward compatible with pre-8.2 PostgreSQL versions. Formerly, writing &lt;code&gt;-t tab&lt;/code&gt; would dump all tables named &lt;code&gt;tab&lt;/code&gt;, but now it just dumps whichever one is visible in your default search path. To get the old behavior you can write &lt;code&gt;-t '*.tab'&lt;/code&gt;. Also, you must write something like &lt;code&gt;-t sch.tab&lt;/code&gt; to select a table in a particular schema, rather than the old locution of &lt;code&gt;-n sch -t tab&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; スイッチの動作は、8.2より前のPostgreSQLバージョンと完全に上位互換ではありません。以前は、書き込み &lt;code&gt;-t tab&lt;/code&gt; 名前のすべてのテーブルのダンプしまう &lt;code&gt;tab&lt;/code&gt; 、今ではただ一つのデフォルトの検索パスに表示されている方ダンプします。古い動作を取得するには、 &lt;code&gt;-t '*.tab'&lt;/code&gt; と記述します。また、特定のスキーマのテーブルを選択するには、 &lt;code&gt;-n sch -t tab&lt;/code&gt; の古い位置ではなく、 &lt;code&gt;-t sch.tab&lt;/code&gt; のようなものを記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="6bad8faf22e7898fa3d14beb6bbfad8894c7e5cb" translate="yes" xml:space="preserve">
          <source>The behavior specified by the SQL standard is most closely approximated by giving users the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute, while roles are given the &lt;code&gt;INHERIT&lt;/code&gt; attribute.</source>
          <target state="translated">SQL標準で指定されている動作は、ユーザーに &lt;code&gt;NOINHERIT&lt;/code&gt; 属性を与えることで最も厳密に近似されていますが、ロールには &lt;code&gt;INHERIT&lt;/code&gt; 属性が与えられています。</target>
        </trans-unit>
        <trans-unit id="999fc3c54ee5c4c5f6f59e07c2e8f063ee92343a" translate="yes" xml:space="preserve">
          <source>The benefits will normally be worthwhile only when a table would otherwise be very large. The exact point at which a table will benefit from partitioning depends on the application, although a rule of thumb is that the size of the table should exceed the physical memory of the database server.</source>
          <target state="translated">通常、テーブルが非常に大きくなる場合にのみ、その利点は価値があります。テーブルがパーティショニングの恩恵を受ける正確なポイントはアプリケーションによって異なりますが、経験則としては、テーブルのサイズがデータベースサーバの物理メモリを超えるべきです。</target>
        </trans-unit>
        <trans-unit id="7e72906a1cbbbaa7de5bc80e5365aa82f11074fd" translate="yes" xml:space="preserve">
          <source>The best defense against deadlocks is generally to avoid them by being certain that all applications using a database acquire locks on multiple objects in a consistent order. In the example above, if both transactions had updated the rows in the same order, no deadlock would have occurred. One should also ensure that the first lock acquired on an object in a transaction is the most restrictive mode that will be needed for that object. If it is not feasible to verify this in advance, then deadlocks can be handled on-the-fly by retrying transactions that abort due to deadlocks.</source>
          <target state="translated">デッドロックに対する最善の防御策は、一般的に、データベースを使用するすべてのアプリケーションが、一貫した順序で複数のオブジェクトのロックを取得するようにすることで、デッドロックを回避することです。上の例では、両方のトランザクションが同じ順番で行を更新していればデッドロックは発生しなかったでしょう。また、あるトランザクションでオブジェクトに対して最初に取得したロックが、そのオブジェクトに必要とされる最も制限的なモードであることを確認する必要があります。これを事前に確認することが不可能な場合は、デッドロックのために中断するトランザクションを再試行することで、その場でデッドロックを処理することができます。</target>
        </trans-unit>
        <trans-unit id="d85f73754546926f4e2d17ccb6f522601d212cb5" translate="yes" xml:space="preserve">
          <source>The best solution for high availability is to ensure you keep as many synchronous standbys as requested. This can be achieved by naming multiple potential synchronous standbys using &lt;code&gt;synchronous_standby_names&lt;/code&gt;.</source>
          <target state="translated">高可用性のための最良のソリューションは、要求された数の同期スタンバイを確保することです。これは、使用して複数の潜在的な同期スタンバイを命名することによって達成することができる &lt;code&gt;synchronous_standby_names&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="e9ecf6d09480763021769b90c87994739dc69c88" translate="yes" xml:space="preserve">
          <source>The bitwise operators work only on integral data types, whereas the others are available for all numeric data types. The bitwise operators are also available for the bit string types &lt;code&gt;bit&lt;/code&gt; and &lt;code&gt;bit varying&lt;/code&gt;, as shown in &lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-OP-TABLE&quot;&gt;Table 9.14&lt;/a&gt;.</source>
          <target state="translated">ビット演算子は整数データ型でのみ機能しますが、その他はすべての数値データ型で使用できます。&lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-OP-TABLE&quot;&gt;表9.14に&lt;/a&gt;示すように、ビット演算子はビット文字列型 &lt;code&gt;bit&lt;/code&gt; および &lt;code&gt;bit varying&lt;/code&gt; にも使用できます。</target>
        </trans-unit>
        <trans-unit id="0bb544aef82eb5e331a1c83d14ba3f14981e458a" translate="yes" xml:space="preserve">
          <source>The built-in parser is named &lt;code&gt;pg_catalog.default&lt;/code&gt;. It recognizes 23 token types, shown in &lt;a href=&quot;textsearch-parsers#TEXTSEARCH-DEFAULT-PARSER&quot;&gt;Table 12.1&lt;/a&gt;.</source>
          <target state="translated">組み込みパーサーは &lt;code&gt;pg_catalog.default&lt;/code&gt; という名前です。&lt;a href=&quot;textsearch-parsers#TEXTSEARCH-DEFAULT-PARSER&quot;&gt;表12.1&lt;/a&gt;に示すように、23のトークンタイプを認識します。</target>
        </trans-unit>
        <trans-unit id="0849997236dc34c615a4c13089f2ec08456d374b" translate="yes" xml:space="preserve">
          <source>The built-in range types &lt;code&gt;int4range&lt;/code&gt;, &lt;code&gt;int8range&lt;/code&gt;, and &lt;code&gt;daterange&lt;/code&gt; all use a canonical form that includes the lower bound and excludes the upper bound; that is, &lt;code&gt;[)&lt;/code&gt;. User-defined range types can use other conventions, however.</source>
          <target state="translated">組み込みの範囲型 &lt;code&gt;int4range&lt;/code&gt; 、 &lt;code&gt;int8range&lt;/code&gt; 、および &lt;code&gt;daterange&lt;/code&gt; はすべて、下限を含み、上限を除外する正規形式を使用します。つまり、 &lt;code&gt;[)&lt;/code&gt; です。ただし、ユーザー定義の範囲タイプは他の規則を使用できます。</target>
        </trans-unit>
        <trans-unit id="2a312305dbd3d6563e32a6d1866cf9d94a8d3583" translate="yes" xml:space="preserve">
          <source>The built-in window functions are described in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt;. Other window functions can be added by the user. Also, any built-in or user-defined general-purpose or statistical aggregate can be used as a window function. (Ordered-set and hypothetical-set aggregates cannot presently be used as window functions.)</source>
          <target state="translated">組み込みのウ​​ィンドウ関数については、&lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;表9.60で&lt;/a&gt;説明します。ユーザーは他のウィンドウ機能を追加できます。また、組み込みまたはユーザー定義の汎用または統計集約をウィンドウ関数として使用できます。（現在、順序付き集合と仮説集合の集合はウィンドウ関数として使用できません。）</target>
        </trans-unit>
        <trans-unit id="1eb1519109d2d92138e97ee3336017e3e8180e57" translate="yes" xml:space="preserve">
          <source>The built-in window functions are listed in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt;. Note that these functions &lt;em&gt;must&lt;/em&gt; be invoked using window function syntax, i.e., an &lt;code&gt;OVER&lt;/code&gt; clause is required.</source>
          <target state="translated">組み込みのウ​​ィンドウ関数を&lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;表9.60に示し&lt;/a&gt;ます。これらの関数&lt;em&gt;は&lt;/em&gt;ウィンドウ関数構文を使用して呼び出す&lt;em&gt;必要&lt;/em&gt;があることに注意してください。つまり、 &lt;code&gt;OVER&lt;/code&gt; 句が必要です。</target>
        </trans-unit>
        <trans-unit id="0a15741ae39e976d65eb76bd158e7ef106ba0c6d" translate="yes" xml:space="preserve">
          <source>The call handler function, the inline handler function (if any), and the validator function (if any) must already exist if the server does not have an entry for the language in &lt;code&gt;pg_pltemplate&lt;/code&gt;. But when there is an entry, the functions need not already exist; they will be automatically defined if not present in the database. (This might result in &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; failing, if the shared library that implements the language is not available in the installation.)</source>
          <target state="translated">サーバーに &lt;code&gt;pg_pltemplate&lt;/code&gt; の言語のエントリがない場合、呼び出しハンドラ関数、インラインハンドラ関数（存在する場合）、およびバリデータ関数（存在する場合）はすでに存在している必要があります。ただし、エントリがある場合、関数はすでに存在している必要はありません。データベースに存在しない場合は、自動的に定義されます。（言語を実装する共有ライブラリがインストールで使用できない場合、これにより &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; が失敗する可能性があります。）</target>
        </trans-unit>
        <trans-unit id="8a84995528c0ec41b02f477f2f19723fd9aad88c" translate="yes" xml:space="preserve">
          <source>The calling &lt;code&gt;SELECT&lt;/code&gt; statement doesn't necessarily have to be just &lt;code&gt;SELECT *&lt;/code&gt; &amp;mdash; it can reference the output columns by name or join them to other tables. The function produces a virtual table with which you can perform any operation you wish (e.g. aggregation, joining, sorting etc). So we could also have:</source>
          <target state="translated">呼び出し側の &lt;code&gt;SELECT&lt;/code&gt; ステートメントは必ずしも &lt;code&gt;SELECT *&lt;/code&gt; である必要はありません。名前で出力列を参照したり、他のテーブルに結合したりできます。この関数は、任意の操作（たとえば、集計、結合、並べ替えなど）を実行できる仮想テーブルを生成します。したがって、次のようにすることもできます。</target>
        </trans-unit>
        <trans-unit id="35f5d39131b77dc8ba4b8e8bbcf6ab1ac892db18" translate="yes" xml:space="preserve">
          <source>The capabilities available for administrators to monitor and control the server often change and improve in each major release.</source>
          <target state="translated">管理者がサーバを監視・制御するために利用できる機能は、メジャーリリースのたびに変更・改善されることがよくあります。</target>
        </trans-unit>
        <trans-unit id="dcba21726e373c0ef3c1310c54912c4461e260b5" translate="yes" xml:space="preserve">
          <source>The cascading replication feature allows a standby server to accept replication connections and stream WAL records to other standbys, acting as a relay. This can be used to reduce the number of direct connections to the master and also to minimize inter-site bandwidth overheads.</source>
          <target state="translated">カスケードレプリケーション機能は、スタンバイサーバーがレプリケーション接続を受け入れ、リレーのように動作して他のスタンバイサーバーにWALレコードをストリーム配信することを可能にします。これは、マスターへの直接接続数を減らし、サイト間の帯域幅オーバーヘッドを最小限に抑えるために使用できます。</target>
        </trans-unit>
        <trans-unit id="2414745d3bf9d469e38eb6deaa116aeca4c295eb" translate="yes" xml:space="preserve">
          <source>The cast functions listed in &lt;code&gt;pg_cast&lt;/code&gt; must always take the cast source type as their first argument type, and return the cast destination type as their result type. A cast function can have up to three arguments. The second argument, if present, must be type &lt;code&gt;integer&lt;/code&gt;; it receives the type modifier associated with the destination type, or -1 if there is none. The third argument, if present, must be type &lt;code&gt;boolean&lt;/code&gt;; it receives &lt;code&gt;true&lt;/code&gt; if the cast is an explicit cast, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;pg_cast&lt;/code&gt; にリストされているキャスト関数は、常に最初の引数の型としてキャストソースタイプを受け取り、結果のタイプとしてキャスト宛先タイプを返す必要があります。キャスト関数は最大3つの引数を持つことができます。 2番目の引数がある場合、それは &lt;code&gt;integer&lt;/code&gt; 型でなければなりません。宛先タイプに関連付けられたタイプ修飾子を受け取ります。存在しない場合は-1を受け取ります。 3番目の引数が存在する場合、それは &lt;code&gt;boolean&lt;/code&gt; 型でなければなりません。キャストが明示的なキャストである場合は &lt;code&gt;true&lt;/code&gt; を受け取り、それ以外の場合は &lt;code&gt;false&lt;/code&gt; を受け取ります。</target>
        </trans-unit>
        <trans-unit id="fc5f1d64f67b0574d5ae7974d9bf0296a9ac950c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_aggregate&lt;/code&gt; stores information about aggregate functions. An aggregate function is a function that operates on a set of values (typically one column from each row that matches a query condition) and returns a single value computed from all these values. Typical aggregate functions are &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, and &lt;code&gt;max&lt;/code&gt;. Each entry in &lt;code&gt;pg_aggregate&lt;/code&gt; is an extension of an entry in &lt;code&gt;pg_proc&lt;/code&gt;. The &lt;code&gt;pg_proc&lt;/code&gt; entry carries the aggregate's name, input and output data types, and other information that is similar to ordinary functions.</source>
          <target state="translated">&lt;code&gt;pg_aggregate&lt;/code&gt; カタログは、集約関数に関する情報を格納します。集約関数は、一連の値（通常、クエリ条件に一致する各行の1つの列）を操作し、これらすべての値から計算された単一の値を返す関数です。一般的な集計関数は、 &lt;code&gt;sum&lt;/code&gt; 、 &lt;code&gt;count&lt;/code&gt; 、および &lt;code&gt;max&lt;/code&gt; です。各エントリ &lt;code&gt;pg_aggregate&lt;/code&gt; 内には、内のエントリの拡張である &lt;code&gt;pg_proc&lt;/code&gt; 。 &lt;code&gt;pg_proc&lt;/code&gt; エントリは、集合の通常の機能に似ている名前、入力および出力データタイプ、およびその他の情報を運びます。</target>
        </trans-unit>
        <trans-unit id="a29845311714d7d30ac211e7ed8230388dda9146" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_am&lt;/code&gt; stores information about relation access methods. There is one row for each access method supported by the system. Currently, only tables and indexes have access methods. The requirements for table and index access methods are discussed in detail in &lt;a href=&quot;tableam&quot;&gt;Chapter 60&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;Chapter 61&lt;/a&gt; respectively.</source>
          <target state="translated">&lt;code&gt;pg_am&lt;/code&gt; カタログはリレーションアクセスメソッドに関する情報を保存しています。システムがサポートするアクセス方式ごとに1つの行があります。現在、テーブルとインデックスのみがアクセス方法を持っています。テーブルとインデックスのアクセス方法の要件については、それぞれ&lt;a href=&quot;tableam&quot;&gt;第60 &lt;/a&gt;&lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;章&lt;/a&gt;と第61 章で詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="5bec1e44f2188ec347a755f0e3375dfd03dbafab" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_amop&lt;/code&gt; stores information about operators associated with access method operator families. There is one row for each operator that is a member of an operator family. A family member can be either a &lt;em&gt;search&lt;/em&gt; operator or an &lt;em&gt;ordering&lt;/em&gt; operator. An operator can appear in more than one family, but cannot appear in more than one search position nor more than one ordering position within a family. (It is allowed, though unlikely, for an operator to be used for both search and ordering purposes.)</source>
          <target state="translated">&lt;code&gt;pg_amop&lt;/code&gt; カタログには、アクセス方法演算子ファミリーに関連する演算子に関する情報が格納されています。オペレーター・ファミリーのメンバーであるオペレーターごとに1つの行があります。ファミリーメンバーは、&lt;em&gt;検索&lt;/em&gt;演算子または&lt;em&gt;順序付け&lt;/em&gt;演算子のいずれかになります。演算子は複数のファミリーに現れることができますが、ファミリー内の複数の検索位置または複数の順序付け位置に現れることはできません。（可能性は低いですが、演算子を検索と順序付けの両方の目的で使用することは許可されています。）</target>
        </trans-unit>
        <trans-unit id="7b26f7790ff6d1feb6dfed34e5224303ebaba082" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_amproc&lt;/code&gt; stores information about support functions associated with access method operator families. There is one row for each support function belonging to an operator family.</source>
          <target state="translated">&lt;code&gt;pg_amproc&lt;/code&gt; カタログには、アクセス方法演算子ファミリーに関連するサポート関数に関する情報が格納されています。演算子族に属するサポート関数ごとに1つの行があります。</target>
        </trans-unit>
        <trans-unit id="e1c43da8c1bc3b1aedcc6d0b4907170e6e551dad" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_attrdef&lt;/code&gt; stores column default values. The main information about columns is stored in &lt;a href=&quot;catalog-pg-attribute&quot;&gt;&lt;code&gt;pg_attribute&lt;/code&gt;&lt;/a&gt;. Only columns for which a default value has been explicitly set will have an entry here.</source>
          <target state="translated">&lt;code&gt;pg_attrdef&lt;/code&gt; カタログは列のデフォルト値を保存します。列に関する主な情報は&lt;a href=&quot;catalog-pg-attribute&quot;&gt; &lt;code&gt;pg_attribute&lt;/code&gt; に&lt;/a&gt;保存されます。ここには、デフォルト値が明示的に設定されている列のみにエントリがあります。</target>
        </trans-unit>
        <trans-unit id="418f63e0244ab894621f6561175c2bc70b572229" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_attribute&lt;/code&gt; stores information about table columns. There will be exactly one &lt;code&gt;pg_attribute&lt;/code&gt; row for every column in every table in the database. (There will also be attribute entries for indexes, and indeed all objects that have &lt;code&gt;pg_class&lt;/code&gt; entries.)</source>
          <target state="translated">&lt;code&gt;pg_attribute&lt;/code&gt; カタログはテーブルの列に関する情報を保存します。データベース内のすべてのテーブルのすべての列に対して1つの &lt;code&gt;pg_attribute&lt;/code&gt; 行があります。（インデックスの属性エントリもあり、実際に &lt;code&gt;pg_class&lt;/code&gt; エントリを持つすべてのオブジェクトがあります。）</target>
        </trans-unit>
        <trans-unit id="85bbce99b3a9fdd7e277ae10030b9970f56238bf" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_auth_members&lt;/code&gt; shows the membership relations between roles. Any non-circular set of relationships is allowed.</source>
          <target state="translated">&lt;code&gt;pg_auth_members&lt;/code&gt; カタログはロール間のメンバーシップ関係を示しています。非循環関係のセットは許可されます。</target>
        </trans-unit>
        <trans-unit id="c8154dc7e56592f09e48c6280c85b2550f6de4fa" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_authid&lt;/code&gt; contains information about database authorization identifiers (roles). A role subsumes the concepts of &amp;ldquo;users&amp;rdquo; and &amp;ldquo;groups&amp;rdquo;. A user is essentially just a role with the &lt;code&gt;rolcanlogin&lt;/code&gt; flag set. Any role (with or without &lt;code&gt;rolcanlogin&lt;/code&gt;) can have other roles as members; see &lt;a href=&quot;catalog-pg-auth-members&quot;&gt;&lt;code&gt;pg_auth_members&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_authid&lt;/code&gt; カタログには、データベース認証識別子（ロール）に関する情報が含まれています。ロールは、「ユーザー」と「グループ」の概念を包括します。ユーザーは基本的に、 &lt;code&gt;rolcanlogin&lt;/code&gt; フラグが設定された単なる役割です。すべてのロール（ &lt;code&gt;rolcanlogin&lt;/code&gt; の有無にかかわらず）は、メンバーとして他のロールを持つことができます。&lt;a href=&quot;catalog-pg-auth-members&quot;&gt; &lt;code&gt;pg_auth_members&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ec983a869f6c2ea34ce8826bbeff462247f967af" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_cast&lt;/code&gt; stores data type conversion paths, both built-in and user-defined.</source>
          <target state="translated">&lt;code&gt;pg_cast&lt;/code&gt; カタログは、組み込み型とユーザー定義の両方のデータ型変換パスを格納します。</target>
        </trans-unit>
        <trans-unit id="9d04631bf68325b8525e49c943e731abe3613af7" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_class&lt;/code&gt; catalogs tables and most everything else that has columns or is otherwise similar to a table. This includes indexes (but see also &lt;code&gt;pg_index&lt;/code&gt;), sequences (but see also &lt;code&gt;pg_sequence&lt;/code&gt;), views, materialized views, composite types, and TOAST tables; see &lt;code&gt;relkind&lt;/code&gt;. Below, when we mean all of these kinds of objects we speak of &amp;ldquo;relations&amp;rdquo;. Not all columns are meaningful for all relation types.</source>
          <target state="translated">カタログ &lt;code&gt;pg_class&lt;/code&gt; カタログ表および列を持っているか、テーブルとそれ以外似ている他のほとんどすべてのもの。これには、インデックス（ &lt;code&gt;pg_index&lt;/code&gt; も参照）、シーケンス（ &lt;code&gt;pg_sequence&lt;/code&gt; も参照）、ビュー、マテリアライズドビュー、複合型、およびTOASTテーブルが含まれます。 &lt;code&gt;relkind&lt;/code&gt; を参照してください。以下では、これらすべての種類のオブジェクトを意味する場合、「関係」について説明します。すべての列がすべての関係タイプにとって意味があるわけではありません。</target>
        </trans-unit>
        <trans-unit id="ce60dbecc80ee8b02722d2865bea98e5166433a6" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_collation&lt;/code&gt; describes the available collations, which are essentially mappings from an SQL name to operating system locale categories. See &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;pg_collation&lt;/code&gt; カタログは利用可能な照合を説明しています。これは基本的にSQL名からオペレーティングシステムのロケールカテゴリへのマッピングです。詳細は&lt;a href=&quot;collation&quot;&gt;項23.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b24facc60ba613b096ec1ffd9828eff85b641f58" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_constraint&lt;/code&gt; stores check, primary key, unique, foreign key, and exclusion constraints on tables. (Column constraints are not treated specially. Every column constraint is equivalent to some table constraint.) Not-null constraints are represented in the &lt;code&gt;pg_attribute&lt;/code&gt; catalog, not here.</source>
          <target state="translated">&lt;code&gt;pg_constraint&lt;/code&gt; カタログはチェック、主キー、一意、外部キー、およびテーブルの除外制約を保存します。（列制約は特別に扱われません。すべての列制約はいくつかのテーブル制約と同等です。）非null制約は、ここではなく &lt;code&gt;pg_attribute&lt;/code&gt; カタログで表されます。</target>
        </trans-unit>
        <trans-unit id="b1be34b922edf24e062d7f1ae068ab828f281a75" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_conversion&lt;/code&gt; describes encoding conversion functions. See &lt;a href=&quot;sql-createconversion&quot;&gt;CREATE CONVERSION&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;pg_conversion&lt;/code&gt; カタログはエンコーディング変換関数を説明しています。詳細については、&lt;a href=&quot;sql-createconversion&quot;&gt;CREATE CONVERSION&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7fa266de7304c33b5491fba7214040981ff64d51" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_database&lt;/code&gt; stores information about the available databases. Databases are created with the &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; command. Consult &lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for details about the meaning of some of the parameters.</source>
          <target state="translated">&lt;code&gt;pg_database&lt;/code&gt; カタログには、利用可能なデータベースに関する情報が格納されています。データベースは&lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;コマンドで作成されます。相談する&lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;第22章を&lt;/a&gt;いくつかのパラメータの詳細については。</target>
        </trans-unit>
        <trans-unit id="0eca146c013dcb962be7fbc89316ecc63d19d2b8" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_db_role_setting&lt;/code&gt; records the default values that have been set for run-time configuration variables, for each role and database combination.</source>
          <target state="translated">&lt;code&gt;pg_db_role_setting&lt;/code&gt; カタログは、ロールとデータベースの組み合わせごとに、ランタイム構成変数に設定されているデフォルト値を記録します。</target>
        </trans-unit>
        <trans-unit id="e6bd2b6528e4d970391e533c9ea2086c3fe18fc0" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_default_acl&lt;/code&gt; stores initial privileges to be assigned to newly created objects.</source>
          <target state="translated">&lt;code&gt;pg_default_acl&lt;/code&gt; カタログは、新しく作成されたオブジェクトに割り当てられる初期権限を保存します。</target>
        </trans-unit>
        <trans-unit id="fa08d6f7153471b38ae0793d338ba6ab5b3ad0bd" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_depend&lt;/code&gt; records the dependency relationships between database objects. This information allows &lt;code&gt;DROP&lt;/code&gt; commands to find which other objects must be dropped by &lt;code&gt;DROP CASCADE&lt;/code&gt; or prevent dropping in the &lt;code&gt;DROP RESTRICT&lt;/code&gt; case.</source>
          <target state="translated">&lt;code&gt;pg_depend&lt;/code&gt; カタログはデータベースオブジェクト間の依存関係を記録しています。この情報により、 &lt;code&gt;DROP&lt;/code&gt; コマンドは、 &lt;code&gt;DROP CASCADE&lt;/code&gt; によってドロップする必要がある他のオブジェクトを検出したり、 &lt;code&gt;DROP RESTRICT&lt;/code&gt; の場合にドロップを防止したりできます。</target>
        </trans-unit>
        <trans-unit id="ef59984dd4696772f2e8a7bbf2dcc9de1f2f041a" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_description&lt;/code&gt; stores optional descriptions (comments) for each database object. Descriptions can be manipulated with the &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; command and viewed with psql's &lt;code&gt;\d&lt;/code&gt; commands. Descriptions of many built-in system objects are provided in the initial contents of &lt;code&gt;pg_description&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_description&lt;/code&gt; カタログは、各データベースオブジェクトのオプションの説明（コメント）を格納します。説明は&lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt;コマンドで操作でき、psqlの &lt;code&gt;\d&lt;/code&gt; コマンドで表示できます。多くの組み込みシステムオブジェクトの説明は、 &lt;code&gt;pg_description&lt;/code&gt; の最初のコンテンツで提供されています。</target>
        </trans-unit>
        <trans-unit id="9f9198ecc665eb9bf0a1925898c8388b6df71db7" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_event_trigger&lt;/code&gt; stores event triggers. See &lt;a href=&quot;https://www.postgresql.org/docs/12/event-triggers.html&quot;&gt;Chapter 39&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;pg_event_trigger&lt;/code&gt; カタログはイベントトリガーを保存します。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/event-triggers.html&quot;&gt;第39章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="08e240a6b04efec03e383c5c2cbf6a0f5343f115" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_extension&lt;/code&gt; stores information about the installed extensions. See &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;Section 37.17&lt;/a&gt; for details about extensions.</source>
          <target state="translated">&lt;code&gt;pg_extension&lt;/code&gt; カタログには、インストールされている拡張機能に関する情報が格納されています。参照&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;セクション37.17を&lt;/a&gt;拡張の詳細については。</target>
        </trans-unit>
        <trans-unit id="60ec179e1854cef6ef5b48336a3d0be1aebd94a3" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_foreign_data_wrapper&lt;/code&gt; stores foreign-data wrapper definitions. A foreign-data wrapper is the mechanism by which external data, residing on foreign servers, is accessed.</source>
          <target state="translated">&lt;code&gt;pg_foreign_data_wrapper&lt;/code&gt; カタログは外部データラッパー定義を保存します。外部データラッパーは、外部サーバーにある外部データにアクセスするメカニズムです。</target>
        </trans-unit>
        <trans-unit id="14e59b5f4fd68c0de1f4d9757cb9140d56e66bca" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_foreign_server&lt;/code&gt; stores foreign server definitions. A foreign server describes a source of external data, such as a remote server. Foreign servers are accessed via foreign-data wrappers.</source>
          <target state="translated">&lt;code&gt;pg_foreign_server&lt;/code&gt; カタログは外部サーバー定義を保存します。外部サーバーは、リモートサーバーなどの外部データのソースを表します。外部サーバーは外部データラッパーを介してアクセスされます。</target>
        </trans-unit>
        <trans-unit id="51d82ed7d4c3db5d6e6e20d733bd83d0fb2db31f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_foreign_table&lt;/code&gt; contains auxiliary information about foreign tables. A foreign table is primarily represented by a &lt;code&gt;pg_class&lt;/code&gt; entry, just like a regular table. Its &lt;code&gt;pg_foreign_table&lt;/code&gt; entry contains the information that is pertinent only to foreign tables and not any other kind of relation.</source>
          <target state="translated">&lt;code&gt;pg_foreign_table&lt;/code&gt; カタログには、外部テーブルに関する補助情報が含まれています。外部テーブルは、通常のテーブルと同様に、主に &lt;code&gt;pg_class&lt;/code&gt; エントリによって表されます。その &lt;code&gt;pg_foreign_table&lt;/code&gt; エントリには、他の種類の関係ではなく、外部テーブルにのみ関連する情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="775fb259c9b9e32be3ed5d81afd596a58bfd39dd" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_index&lt;/code&gt; contains part of the information about indexes. The rest is mostly in &lt;code&gt;pg_class&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_index&lt;/code&gt; カタログには、インデックスに関する情報の一部が含まれています。残りは主に &lt;code&gt;pg_class&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="3a623a0b18b2ebaf8e83d5ac1d0d6cf3474af033" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_inherits&lt;/code&gt; records information about table inheritance hierarchies. There is one entry for each direct parent-child table relationship in the database. (Indirect inheritance can be determined by following chains of entries.)</source>
          <target state="translated">&lt;code&gt;pg_inherits&lt;/code&gt; カタログは、テーブルの継承階層に関する情報を記録しています。データベース内の直接の親子テーブルの関係ごとに1つのエントリがあります。（間接継承は、エントリのチェーンをたどることによって決定できます。）</target>
        </trans-unit>
        <trans-unit id="3ef3657b35ed0b4f238ec5987d2edc24285c1ce6" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_init_privs&lt;/code&gt; records information about the initial privileges of objects in the system. There is one entry for each object in the database which has a non-default (non-NULL) initial set of privileges.</source>
          <target state="translated">&lt;code&gt;pg_init_privs&lt;/code&gt; カタログは、システム内のオブジェクトの初期特権に関する情報を記録しています。データベース内の各オブジェクトには、デフォルト以外（NULL以外）の初期特権セットを持つ1つのエントリがあります。</target>
        </trans-unit>
        <trans-unit id="aed131707c511022c9597a108a69123aaaa06b71" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_language&lt;/code&gt; registers languages in which you can write functions or stored procedures. See &lt;a href=&quot;sql-createlanguage&quot;&gt;CREATE LANGUAGE&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/xplang.html&quot;&gt;Chapter 41&lt;/a&gt; for more information about language handlers.</source>
          <target state="translated">&lt;code&gt;pg_language&lt;/code&gt; カタログは、関数またはストアドプロシージャを記述できる言語を登録します。言語ハンドラの詳細については、&lt;a href=&quot;sql-createlanguage&quot;&gt;CREATE LANGUAGE&lt;/a&gt;および&lt;a href=&quot;https://www.postgresql.org/docs/12/xplang.html&quot;&gt;第41章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="bc853ae6dcab566bb8d51b6c3df6a48ca149be41" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_largeobject&lt;/code&gt; holds the data making up &amp;ldquo;large objects&amp;rdquo;. A large object is identified by an OID assigned when it is created. Each large object is broken into segments or &amp;ldquo;pages&amp;rdquo; small enough to be conveniently stored as rows in &lt;code&gt;pg_largeobject&lt;/code&gt;. The amount of data per page is defined to be &lt;code&gt;LOBLKSIZE&lt;/code&gt; (which is currently &lt;code&gt;BLCKSZ/4&lt;/code&gt;, or typically 2 kB).</source>
          <target state="translated">カタログ &lt;code&gt;pg_largeobject&lt;/code&gt; は「ラージオブジェクト」を構成するデータを保持しています。ラージオブジェクトは、作成時に割り当てられたOIDによって識別されます。各ラージオブジェクトは、 &lt;code&gt;pg_largeobject&lt;/code&gt; の行として便利に格納できるほど小さいセグメントまたは「ページ」に分割されます。ページあたりのデータ量は、 &lt;code&gt;LOBLKSIZE&lt;/code&gt; （現在は &lt;code&gt;BLCKSZ/4&lt;/code&gt; 、または通常は2 kB）と定義されています。</target>
        </trans-unit>
        <trans-unit id="637a0fff02f805fcd7f6572b41b759dc3d88c524" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_largeobject_metadata&lt;/code&gt; holds metadata associated with large objects. The actual large object data is stored in &lt;a href=&quot;catalog-pg-largeobject&quot;&gt;&lt;code&gt;pg_largeobject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">カタログ &lt;code&gt;pg_largeobject_metadata&lt;/code&gt; は、ラージオブジェクトに関連するメタデータを保持しています。実際のラージオブジェクトデータは&lt;a href=&quot;catalog-pg-largeobject&quot;&gt; &lt;code&gt;pg_largeobject&lt;/code&gt; に&lt;/a&gt;格納されます。</target>
        </trans-unit>
        <trans-unit id="1da9fb341c1eb2b89353bf65057bd43bdb97a022" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_namespace&lt;/code&gt; stores namespaces. A namespace is the structure underlying SQL schemas: each namespace can have a separate collection of relations, types, etc. without name conflicts.</source>
          <target state="translated">&lt;code&gt;pg_namespace&lt;/code&gt; カタログは名前空間を保存します。ネームスペースは、SQLスキーマの基礎となる構造です。各ネームスペースは、名前の競合なしに、関係、タイプなどの個別のコレクションを持つことができます。</target>
        </trans-unit>
        <trans-unit id="85e7a372d092106d4f08f9fcd3ea02828fcaa191" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_opclass&lt;/code&gt; defines index access method operator classes. Each operator class defines semantics for index columns of a particular data type and a particular index access method. An operator class essentially specifies that a particular operator family is applicable to a particular indexable column data type. The set of operators from the family that are actually usable with the indexed column are whichever ones accept the column's data type as their left-hand input.</source>
          <target state="translated">&lt;code&gt;pg_opclass&lt;/code&gt; カタログはインデックスアクセスメソッド演算子クラスを定義しています。各演算子クラスは、特定のデータ型のインデックス列と特定のインデックスアクセスメソッドのセマンティクスを定義します。演算子クラスは基本的に、特定の演算子ファミリーが特定のインデックス可能な列のデータ型に適用可能であることを指定します。インデックス付きの列で実際に使用できるファミリの演算子のセットは、左側の入力として列のデータ型を受け入れる演算子です。</target>
        </trans-unit>
        <trans-unit id="c87fca68633fb63db57e86d79fac7ce1b22101ea" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_operator&lt;/code&gt; stores information about operators. See &lt;a href=&quot;sql-createoperator&quot;&gt;CREATE OPERATOR&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/xoper.html&quot;&gt;Section 37.14&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;pg_operator&lt;/code&gt; カタログはオペレーターに関する情報を保存します。詳細については、&lt;a href=&quot;sql-createoperator&quot;&gt;CREATE OPERATOR&lt;/a&gt;および&lt;a href=&quot;https://www.postgresql.org/docs/12/xoper.html&quot;&gt;セクション37.14&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ae3fdeed75aa3ce97ce3c38ef12f91f3c508c158" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_opfamily&lt;/code&gt; defines operator families. Each operator family is a collection of operators and associated support routines that implement the semantics specified for a particular index access method. Furthermore, the operators in a family are all &amp;ldquo;compatible&amp;rdquo;, in a way that is specified by the access method. The operator family concept allows cross-data-type operators to be used with indexes and to be reasoned about using knowledge of access method semantics.</source>
          <target state="translated">&lt;code&gt;pg_opfamily&lt;/code&gt; カタログはオペレーターファミリーを定義します。各演算子ファミリは、特定のインデックスアクセスメソッドに指定されたセマンティクスを実装する演算子と関連するサポートルーチンのコレクションです。さらに、ファミリー内のオペレーターは、アクセス方法で指定されているように、すべて「互換性」があります。演算子族の概念により、クロスデータタイプの演算子をインデックスで使用し、アクセス方法のセマンティクスの知識を使用することを推論することができます。</target>
        </trans-unit>
        <trans-unit id="9f9d81d5db57fdf3722685cee5c72c0b7b266b01" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_partitioned_table&lt;/code&gt; stores information about how tables are partitioned.</source>
          <target state="translated">&lt;code&gt;pg_partitioned_table&lt;/code&gt; カタログはテーブルがどのように分割されるかについての情報を保存します。</target>
        </trans-unit>
        <trans-unit id="c4598dc8a02ea46018473ad3a155097abd3c7904" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_pltemplate&lt;/code&gt; stores &amp;ldquo;template&amp;rdquo; information for procedural languages. A template for a language allows the language to be created in a particular database by a simple &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; command, with no need to specify implementation details.</source>
          <target state="translated">&lt;code&gt;pg_pltemplate&lt;/code&gt; カタログには、手続き型言語の「テンプレート」情報が格納されています。言語のテンプレートを使用すると、実装の詳細を指定する必要なく、単純な &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; コマンドで特定のデータベースに言語を作成できます。</target>
        </trans-unit>
        <trans-unit id="38521eab8f4daa25e1c972502335611e746aa47f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_policy&lt;/code&gt; stores row level security policies for tables. A policy includes the kind of command that it applies to (possibly all commands), the roles that it applies to, the expression to be added as a security-barrier qualification to queries that include the table, and the expression to be added as a &lt;code&gt;WITH CHECK&lt;/code&gt; option for queries that attempt to add new records to the table.</source>
          <target state="translated">&lt;code&gt;pg_policy&lt;/code&gt; カタログはテーブルの行レベルのセキュリティポリシーを保存します。ポリシーには、適用されるコマンドの種類（場合によってはすべてのコマンド）、適用されるロール、テーブルを含むクエリにセキュリティバリア資格として追加される式、および追加される式が含まれます新しいレコードをテーブルに追加しようとするクエリの &lt;code&gt;WITH CHECK&lt;/code&gt; オプション。</target>
        </trans-unit>
        <trans-unit id="077da08d3639d4de1fea458f7cc6d9c77756beb9" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_proc&lt;/code&gt; stores information about functions, procedures, aggregate functions, and window functions (collectively also known as routines). See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;, &lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;pg_proc&lt;/code&gt; カタログは、関数、プロシージャ、集約関数、ウィンドウ関数（まとめてルーチンとも呼ばれます）に関する情報を格納します。詳細は、「&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION」&lt;/a&gt;、「&lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE」&lt;/a&gt;、および&lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;セクション37.3&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="0bfdad63a7f3f3f55487cbe48d50b5126f2fe14c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_publication&lt;/code&gt; contains all publications created in the database. For more on publications see &lt;a href=&quot;logical-replication-publication&quot;&gt;Section 30.1&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_publication&lt;/code&gt; カタログには、データベースで作成されたすべてのパブリケーションが含まれています。出版物の詳細については、&lt;a href=&quot;logical-replication-publication&quot;&gt;セクション30.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="221d9ab9d81b22114af5be8f658f635812a98821" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_publication_rel&lt;/code&gt; contains the mapping between relations and publications in the database. This is a many-to-many mapping. See also &lt;a href=&quot;view-pg-publication-tables&quot;&gt;Section 51.79&lt;/a&gt; for a more user-friendly view of this information.</source>
          <target state="translated">カタログ &lt;code&gt;pg_publication_rel&lt;/code&gt; には、データベース内の関係とパブリケーション間のマッピングが含まれています。これは多対多のマッピングです。この情報のより&lt;a href=&quot;view-pg-publication-tables&quot;&gt;わかり&lt;/a&gt;やすいビューについては、セクション51.79も参照してください。</target>
        </trans-unit>
        <trans-unit id="52875f38f647bef6fb760c4d6882bec8ce49439c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_range&lt;/code&gt; stores information about range types. This is in addition to the types' entries in &lt;a href=&quot;catalog-pg-type&quot;&gt;&lt;code&gt;pg_type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_range&lt;/code&gt; カタログは範囲タイプに関する情報を保存します。これは&lt;a href=&quot;catalog-pg-type&quot;&gt; &lt;code&gt;pg_type&lt;/code&gt; の&lt;/a&gt;タイプのエントリに追加されます。</target>
        </trans-unit>
        <trans-unit id="cc31d507f60721e880a15f8324203d061317541c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_rewrite&lt;/code&gt; stores rewrite rules for tables and views.</source>
          <target state="translated">&lt;code&gt;pg_rewrite&lt;/code&gt; カタログはテーブルとビューの書き換えルールを保存します。</target>
        </trans-unit>
        <trans-unit id="743cf387d8af7cd433c0ab8fa075de457723d7d5" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_seclabel&lt;/code&gt; stores security labels on database objects. Security labels can be manipulated with the &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; command. For an easier way to view security labels, see &lt;a href=&quot;view-pg-seclabels&quot;&gt;Section 51.84&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_seclabel&lt;/code&gt; カタログはデータベースオブジェクトのセキュリティラベルを保存します。セキュリティラベルは、&lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt;コマンドで操作できます。セキュリティラベルを表示する簡単な方法については、&lt;a href=&quot;view-pg-seclabels&quot;&gt;セクション51.84を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="06336f290aa5f875fbaac3ca8b83cb8674898645" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_sequence&lt;/code&gt; contains information about sequences. Some of the information about sequences, such as the name and the schema, is in &lt;code&gt;pg_class&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_sequence&lt;/code&gt; カタログには、シーケンスに関する情報が含まれています。名前やスキーマなど、シーケンスに関する情報の一部は &lt;code&gt;pg_class&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="98aafe9d92bd83fff00a553e40adb49ebd9fb0ff" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shdepend&lt;/code&gt; records the dependency relationships between database objects and shared objects, such as roles. This information allows PostgreSQL to ensure that those objects are unreferenced before attempting to delete them.</source>
          <target state="translated">カタログ &lt;code&gt;pg_shdepend&lt;/code&gt; は、データベースオブジェクトとロールなどの共有オブジェクト間の依存関係を記録します。この情報により、PostgreSQLは、それらのオブジェクトを削除する前に、それらのオブジェクトが参照されていないことを確認できます。</target>
        </trans-unit>
        <trans-unit id="707a904a0a65e47118a70277c90bf66e00682ea7" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shdescription&lt;/code&gt; stores optional descriptions (comments) for shared database objects. Descriptions can be manipulated with the &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; command and viewed with psql's &lt;code&gt;\d&lt;/code&gt; commands.</source>
          <target state="translated">&lt;code&gt;pg_shdescription&lt;/code&gt; カタログは、共有データベースオブジェクトのオプションの説明（コメント）を格納します。説明は&lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt;コマンドで操作でき、psqlの &lt;code&gt;\d&lt;/code&gt; コマンドで表示できます。</target>
        </trans-unit>
        <trans-unit id="bb1cad576af7b20a74691e7e84a0abf3918f82ca" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shseclabel&lt;/code&gt; stores security labels on shared database objects. Security labels can be manipulated with the &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; command. For an easier way to view security labels, see &lt;a href=&quot;view-pg-seclabels&quot;&gt;Section 51.84&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_shseclabel&lt;/code&gt; カタログは、共有データベースオブジェクトのセキュリティラベルを格納します。セキュリティラベルは、&lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt;コマンドで操作できます。セキュリティラベルを表示する簡単な方法については、&lt;a href=&quot;view-pg-seclabels&quot;&gt;セクション51.84を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d95048be51e3aac388b17358a36c3017066f7afd" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_statistic&lt;/code&gt; stores statistical data about the contents of the database. Entries are created by &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; and subsequently used by the query planner. Note that all the statistical data is inherently approximate, even assuming that it is up-to-date.</source>
          <target state="translated">&lt;code&gt;pg_statistic&lt;/code&gt; カタログには、データベースの内容に関する統計データが格納されています。エントリは&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;によって作成され、その後クエリプランナーによって使用されます。すべての統計データは、それが最新であると仮定しても、本質的に概算であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1a788b199242747f1e3ab3d464f7f212c88021b3" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_statistic_ext&lt;/code&gt; holds definitions of extended planner statistics. Each row in this catalog corresponds to a &lt;em&gt;statistics object&lt;/em&gt; created with &lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_statistic_ext&lt;/code&gt; カタログは拡張プランナー統計の定義を保持しています。このカタログの各行は、&lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICSで&lt;/a&gt;作成された&lt;em&gt;統計オブジェクトに&lt;/em&gt;対応してい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="efd7c967165399ed5a01a4ab9407cb379c75802f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; holds data for extended planner statistics defined in &lt;code&gt;pg_statistic_ext&lt;/code&gt;. Each row in this catalog corresponds to a &lt;em&gt;statistics object&lt;/em&gt; created with &lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_statistic_ext_data&lt;/code&gt; カタログは、 &lt;code&gt;pg_statistic_ext&lt;/code&gt; で定義された拡張プランナー統計のデータを保持します。このカタログの各行は、&lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICSで&lt;/a&gt;作成された&lt;em&gt;統計オブジェクトに&lt;/em&gt;対応してい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="c35fed25fc50b397d0a14fb9dcbeb17e75e6fe0f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_subscription&lt;/code&gt; contains all existing logical replication subscriptions. For more information about logical replication see &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_subscription&lt;/code&gt; カタログには、既存のすべての論理レプリケーションサブスクリプションが含まれています。論理複製の詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;第30章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3cdf4cde86fcb864fb5af90b023119fc34f2142d" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_subscription_rel&lt;/code&gt; contains the state for each replicated relation in each subscription. This is a many-to-many mapping.</source>
          <target state="translated">&lt;code&gt;pg_subscription_rel&lt;/code&gt; カタログには、各サブスクリプションの複製された各関係の状態が含まれています。これは多対多のマッピングです。</target>
        </trans-unit>
        <trans-unit id="c447f5488ab316d33bbd3ebcf5f5d8b7c31ae85d" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_tablespace&lt;/code&gt; stores information about the available tablespaces. Tables can be placed in particular tablespaces to aid administration of disk layout.</source>
          <target state="translated">&lt;code&gt;pg_tablespace&lt;/code&gt; カタログは、利用可能なテーブルスペースに関する情報を保存します。テーブルを特定のテーブルスペースに配置して、ディスクレイアウトの管理を支援できます。</target>
        </trans-unit>
        <trans-unit id="5fd8fed96cb099d0e2d39d4d04e6e7c47d74045e" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_transform&lt;/code&gt; stores information about transforms, which are a mechanism to adapt data types to procedural languages. See &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;pg_transform&lt;/code&gt; カタログは、データ型を手続き型言語に適合させるメカニズムである変換に関する情報を格納します。詳細については、&lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="75ce3dfcf04f9d1f1bc6bfe6a8a43c82175b0a72" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_trigger&lt;/code&gt; stores triggers on tables and views. See &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;pg_trigger&lt;/code&gt; カタログはテーブルとビューのトリガーを保存します。詳細については、&lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="392fc6d5e6430c985734db6f435318b9f05a7dd3" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_type&lt;/code&gt; stores information about data types. Base types and enum types (scalar types) are created with &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;, and domains with &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt;. A composite type is automatically created for each table in the database, to represent the row structure of the table. It is also possible to create composite types with &lt;code&gt;CREATE TYPE AS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_type&lt;/code&gt; カタログはデータ型に関する情報を保存します。基本型と列挙型（スカラー型）は&lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;で作成され、ドメインは&lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAINで&lt;/a&gt;作成されます。複合型は、テーブルの行構造を表すために、データベース内の各テーブルに対して自動的に作成されます。 &lt;code&gt;CREATE TYPE AS&lt;/code&gt; を使用して複合型を作成することもできます。</target>
        </trans-unit>
        <trans-unit id="6bc1e303fc4f7bb28411737b0ff9561def41771f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_user_mapping&lt;/code&gt; stores the mappings from local user to remote. Access to this catalog is restricted from normal users, use the view &lt;a href=&quot;view-pg-user-mappings&quot;&gt;&lt;code&gt;pg_user_mappings&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;pg_user_mapping&lt;/code&gt; カタログは、ローカルユーザーからリモートへのマッピングを保存します。このカタログへのアクセスは通常のユーザーから制限されています。代わりにビュー&lt;a href=&quot;view-pg-user-mappings&quot;&gt; &lt;code&gt;pg_user_mappings&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="60a544b25f1cc2eef0830902b29eb1826d7423c5" translate="yes" xml:space="preserve">
          <source>The category code (a single ASCII character) for this type. The default is &lt;code&gt;'U'&lt;/code&gt; for &amp;ldquo;user-defined type&amp;rdquo;. Other standard category codes can be found in &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.64&lt;/a&gt;. You may also choose other ASCII characters in order to create custom categories.</source>
          <target state="translated">このタイプのカテゴリコード（単一のASCII文字）。デフォルトは「ユーザー定義タイプ」の &lt;code&gt;'U'&lt;/code&gt; です。その他の標準カテゴリコードは、&lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;表51.64にあり&lt;/a&gt;ます。カスタムカテゴリを作成するために、他のASCII文字を選択することもできます。</target>
        </trans-unit>
        <trans-unit id="6e0699308172a4d35d3852cf096bcc7cdc0d6fc5" translate="yes" xml:space="preserve">
          <source>The category names translate into names of &lt;code&gt;initdb&lt;/code&gt; options to override the locale choice for a specific category. For instance, to set the locale to French Canadian, but use U.S. rules for formatting currency, use &lt;code&gt;initdb --locale=fr_CA --lc-monetary=en_US&lt;/code&gt;.</source>
          <target state="translated">カテゴリー名は、 &lt;code&gt;initdb&lt;/code&gt; オプションの名前に変換され、特定のカテゴリーのロケール選択をオーバーライドします。たとえば、ロケールをフランスカナダに設定し、通貨のフォーマットに米国のルールを使用するには、 &lt;code&gt;initdb --locale=fr_CA --lc-monetary=en_US&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="90aadd1f991be6c6a59649f2cf2279a49d630988" translate="yes" xml:space="preserve">
          <source>The century</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64714127e62379960f8b9dabad3b7dd16b967248" translate="yes" xml:space="preserve">
          <source>The character set encoding specified for the new database must be compatible with the chosen locale settings (&lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;). If the locale is &lt;code&gt;C&lt;/code&gt; (or equivalently &lt;code&gt;POSIX&lt;/code&gt;), then all encodings are allowed, but for other locale settings there is only one encoding that will work properly. (On Windows, however, UTF-8 encoding can be used with any locale.) &lt;code&gt;CREATE DATABASE&lt;/code&gt; will allow superusers to specify &lt;code&gt;SQL_ASCII&lt;/code&gt; encoding regardless of the locale settings, but this choice is deprecated and may result in misbehavior of character-string functions if data that is not encoding-compatible with the locale is stored in the database.</source>
          <target state="translated">新しいデータベースに指定する文字セットエンコーディングは、選択したロケール設定（ &lt;code&gt;LC_COLLATE&lt;/code&gt; および &lt;code&gt;LC_CTYPE&lt;/code&gt; ）と互換性がある必要があります。ロケールが &lt;code&gt;C&lt;/code&gt; （または同等の &lt;code&gt;POSIX&lt;/code&gt; ）の場合、すべてのエンコーディングが許可されますが、他のロケール設定では、正しく機能するエンコーディングは1つだけです。 （ただし、Windowsでは、UTF-8エンコーディングを任意のロケールで使用できます。） &lt;code&gt;CREATE DATABASE&lt;/code&gt; を使用すると、スーパーユーザーはロケール設定に関係なく &lt;code&gt;SQL_ASCII&lt;/code&gt; エンコーディングを指定できますが、この選択は非推奨であり、データの場合、文字列関数の誤動作を引き起こす可能性があります。ロケールとエンコード互換ではないものはデータベースに格納されます。</target>
        </trans-unit>
        <trans-unit id="89d6fa6368565c20d96f1143f8a41b5bdded6f20" translate="yes" xml:space="preserve">
          <source>The character set support in PostgreSQL allows you to store text in a variety of character sets (also called encodings), including single-byte character sets such as the ISO 8859 series and multiple-byte character sets such as EUC (Extended Unix Code), UTF-8, and Mule internal code. All supported character sets can be used transparently by clients, but a few are not supported for use within the server (that is, as a server-side encoding). The default character set is selected while initializing your PostgreSQL database cluster using &lt;code&gt;initdb&lt;/code&gt;. It can be overridden when you create a database, so you can have multiple databases each with a different character set.</source>
          <target state="translated">PostgreSQLの文字セットのサポートにより、ISO 8859シリーズなどのシングルバイト文字セットやEUC（Extended Unix Code）などのマルチバイト文字セットなど、さまざまな文字セット（エンコーディングとも呼ばれます）でテキストを保存できます。 UTF-8、およびMule内部コード。サポートされているすべての文字セットはクライアントから透過的に使用できますが、サーバー内での使用（つまり、サーバー側のエンコーディングとして）がサポートされていないものもあります。 &lt;code&gt;initdb&lt;/code&gt; を使用してPostgreSQLデータベースクラスターを初期化するときに、デフォルトの文字セットが選択されます。データベースを作成するときに上書きできるため、それぞれが異なる文字セットを持つ複数のデータベースを持つことができます。</target>
        </trans-unit>
        <trans-unit id="97fdcbffdcc8da09aa147a46393111714ca188e7" translate="yes" xml:space="preserve">
          <source>The character with the code zero cannot be in a string constant.</source>
          <target state="translated">コード0の文字は文字列定数には入れられません。</target>
        </trans-unit>
        <trans-unit id="1c743222d29807902173d80c9ab0c69944ad07be" translate="yes" xml:space="preserve">
          <source>The character with the indicated octal code is substituted.</source>
          <target state="translated">表示されている8進数コードの文字が置換されます。</target>
        </trans-unit>
        <trans-unit id="9883df04aca064376efa049e7f1ac203fe46e46b" translate="yes" xml:space="preserve">
          <source>The character-entry escapes are always taken as ordinary characters. For example, &lt;code&gt;\135&lt;/code&gt; is &lt;code&gt;]&lt;/code&gt; in ASCII, but &lt;code&gt;\135&lt;/code&gt; does not terminate a bracket expression.</source>
          <target state="translated">文字入力エスケープは常に通常の文字として扱われます。例えば、 &lt;code&gt;\135&lt;/code&gt; ある &lt;code&gt;]&lt;/code&gt; ASCIIではなく、 &lt;code&gt;\135&lt;/code&gt; ブラケット表現を終了しません。</target>
        </trans-unit>
        <trans-unit id="ef0e78b53fce5d8f9142725e8e0f3c5fa09a015f" translate="yes" xml:space="preserve">
          <source>The checkpoint requirement of flushing all dirty data pages to disk can cause a significant I/O load. For this reason, checkpoint activity is throttled so that I/O begins at checkpoint start and completes before the next checkpoint is due to start; this minimizes performance degradation during checkpoints.</source>
          <target state="translated">すべてのダーティデータページをディスクにフラッシュするというチェックポイントの要件は、大きなI/O負荷を引き起こす可能性があります。このため、チェックポイントのアクティビティは、チェックポイントの開始時にI/Oが開始され、次のチェックポイントが開始される前に完了するようにスロットルされており、チェックポイント中のパフォーマンス低下を最小限に抑えます。</target>
        </trans-unit>
        <trans-unit id="aea1ec4dfdbf684f4c49444bdb751e65ee9f5e89" translate="yes" xml:space="preserve">
          <source>The checksum computed with this function can be compared with the &lt;code&gt;checksum&lt;/code&gt; result field of the function &lt;code&gt;page_header&lt;/code&gt;. If data checksums are enabled for this instance, then the two values should be equal.</source>
          <target state="translated">この関数で計算された &lt;code&gt;checksum&lt;/code&gt; は、関数 &lt;code&gt;page_header&lt;/code&gt; のチェックサム結果フィールドと比較できます。このインスタンスでデータチェックサムが有効になっている場合、2つの値は等しいはずです。</target>
        </trans-unit>
        <trans-unit id="12cbfddc1d2244a2eb37d3e1009dc9d4f7140abc" translate="yes" xml:space="preserve">
          <source>The choice between GiST and GIN indexing depends on the relative performance characteristics of GiST and GIN, which are discussed elsewhere.</source>
          <target state="translated">GiSTとGINのインデキシングの選択は、GiSTとGINの相対的な性能特性に依存しますが、これは別の場所で議論されています。</target>
        </trans-unit>
        <trans-unit id="3567ccb40f1481d219e5951c92fe9f650cc7303e" translate="yes" xml:space="preserve">
          <source>The choice between these formats is up to the user. The first format is a proper XML document, which will be important in many applications. The second format tends to be more useful in the &lt;code&gt;cursor_to_xml&lt;/code&gt; function if the result values are to be reassembled into one document later on. The functions for producing XML content discussed above, in particular &lt;code&gt;xmlelement&lt;/code&gt;, can be used to alter the results to taste.</source>
          <target state="translated">これらの形式の選択はユーザー次第です。最初の形式は適切なXMLドキュメントであり、多くのアプリケーションで重要になります。2番目の形式は、結果の値を後で1つのドキュメントに再構成する場合、 &lt;code&gt;cursor_to_xml&lt;/code&gt; 関数でより役立つ傾向があります。上記のXMLコンテンツを生成するための関数、特に &lt;code&gt;xmlelement&lt;/code&gt; を使用して、結果を好みに応じて変更できます。</target>
        </trans-unit>
        <trans-unit id="2fcd6e12232fcafb17e4f9eed475f29ab9c942d0" translate="yes" xml:space="preserve">
          <source>The choice of how to partition a table should be made carefully as the performance of query planning and execution can be negatively affected by poor design.</source>
          <target state="translated">テーブルをどのように分割するかの選択は慎重に行う必要があります。</target>
        </trans-unit>
        <trans-unit id="eba68582494f00f7d7461ffee77aebc9a862ba45" translate="yes" xml:space="preserve">
          <source>The clause &lt;code&gt;CACHE cache&lt;/code&gt; enables sequence numbers to be preallocated and stored in memory for faster access. The minimum value is 1 (only one value can be generated at a time, i.e., no cache). If unspecified, the old cache value will be maintained.</source>
          <target state="translated">&lt;code&gt;CACHE cache&lt;/code&gt; 句を使用すると、シーケンス番号を事前に割り当ててメモリに格納し、アクセスを高速化できます。最小値は1です（一度に生成できる値は1つだけです。つまり、キャッシュはありません）。指定しない場合、古いキャッシュ値が維持されます。</target>
        </trans-unit>
        <trans-unit id="75a69760c05706a624428c520aa62a2819be2cc8" translate="yes" xml:space="preserve">
          <source>The clause &lt;code&gt;INCREMENT BY increment&lt;/code&gt; is optional. A positive value will make an ascending sequence, a negative one a descending sequence. If unspecified, the old increment value will be maintained.</source>
          <target state="translated">&lt;code&gt;INCREMENT BY increment&lt;/code&gt; 句はオプションです。正の値は昇順のシーケンスになり、負の値は降順のシーケンスになります。指定しない場合、古い増分値が維持されます。</target>
        </trans-unit>
        <trans-unit id="867e5349b79e57e50c69654c14c2d9c684ca93bc" translate="yes" xml:space="preserve">
          <source>The clauses &lt;code&gt;ALWAYS&lt;/code&gt; and &lt;code&gt;BY DEFAULT&lt;/code&gt; determine how the sequence value is given precedence over a user-specified value in an &lt;code&gt;INSERT&lt;/code&gt; statement. If &lt;code&gt;ALWAYS&lt;/code&gt; is specified, a user-specified value is only accepted if the &lt;code&gt;INSERT&lt;/code&gt; statement specifies &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt;. If &lt;code&gt;BY DEFAULT&lt;/code&gt; is specified, then the user-specified value takes precedence. See &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; for details. (In the &lt;code&gt;COPY&lt;/code&gt; command, user-specified values are always used regardless of this setting.)</source>
          <target state="translated">&lt;code&gt;ALWAYS&lt;/code&gt; 句と &lt;code&gt;BY DEFAULT&lt;/code&gt; 句は、 &lt;code&gt;INSERT&lt;/code&gt; 文でユーザーが指定した値よりもシーケンス値を優先させる方法を決定します。場合 &lt;code&gt;ALWAYS&lt;/code&gt; が指定されている場合、ユーザーが指定した値のみが受け入れられ &lt;code&gt;INSERT&lt;/code&gt; 文指定は &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; 。 &lt;code&gt;BY DEFAULT&lt;/code&gt; が指定されている場合、ユーザー指定の値が優先されます。詳細については、&lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;を参照してください。 （ &lt;code&gt;COPY&lt;/code&gt; コマンドでは、この設定に関係なく、ユーザー指定の値が常に使用されます。）</target>
        </trans-unit>
        <trans-unit id="234bcc40e3c1c6669b66cf6ee7882220428cd61f" translate="yes" xml:space="preserve">
          <source>The clauses &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt; are PostgreSQL-specific syntax, also used by MySQL. The SQL:2008 standard has introduced the clauses &lt;code&gt;OFFSET ... FETCH {FIRST|NEXT} ...&lt;/code&gt; for the same functionality, as shown above in &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt;. This syntax is also used by IBM DB2. (Applications written for Oracle frequently use a workaround involving the automatically generated &lt;code&gt;rownum&lt;/code&gt; column, which is not available in PostgreSQL, to implement the effects of these clauses.)</source>
          <target state="translated">&lt;code&gt;LIMIT&lt;/code&gt; および &lt;code&gt;OFFSET&lt;/code&gt; 句はPostgreSQL固有の構文で、MySQLでも使用されます。 SQL：2008標準では、上記の&lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt; &lt;code&gt;LIMIT&lt;/code&gt; &lt;/a&gt;句に示されているように、同じ機能に対して &lt;code&gt;OFFSET ... FETCH {FIRST|NEXT} ...&lt;/code&gt; 句が導入されています。この構文は、IBM DB2でも使用されます。 （Oracle用に作成されたアプリケーションは、PostgreSQLにはない自動生成された &lt;code&gt;rownum&lt;/code&gt; 列を含む回避策を頻繁に使用して、これらの句の効果を実装します。）</target>
        </trans-unit>
        <trans-unit id="54380a0f1c98e1a0a687fefef82dc949bcffc323" translate="yes" xml:space="preserve">
          <source>The client must be allowed to access all referenced tables and columns, even if they originated from views which were then expanded, so that we apply consistent access control rules independent of the manner in which the table contents are referenced.</source>
          <target state="translated">クライアントは、たとえそれらがビューから派生して展開されたものであっても、参照されるすべてのテーブルとカラムへのアクセスを許可しなければなりません。</target>
        </trans-unit>
        <trans-unit id="05fdc0ebe765756a24f5709f3f5f878e85b6fb9a" translate="yes" xml:space="preserve">
          <source>The client process can be any program that understands the PostgreSQL protocol described in &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;Chapter 52&lt;/a&gt;. Many clients are based on the C-language library libpq, but several independent implementations of the protocol exist, such as the Java JDBC driver.</source>
          <target state="translated">クライアントプロセスは、&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;第52章で&lt;/a&gt;説明するPostgreSQLプロトコルを理解する任意のプログラムにすることができます。多くのクライアントはC言語ライブラリlibpqに基づいていますが、Java JDBCドライバーなど、プロトコルのいくつかの独立した実装が存在します。</target>
        </trans-unit>
        <trans-unit id="14c663b89bef91d752e19ecca16e81b132b43904" translate="yes" xml:space="preserve">
          <source>The client responds by sending a SASLInitialResponse message, which indicates the chosen mechanism, &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; or &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt;. (A client is free to choose either mechanism, but for better security it should choose the channel-binding variant if it can support it.) In the Initial Client response field, the message contains the SCRAM &lt;code&gt;client-first-message&lt;/code&gt;. The &lt;code&gt;client-first-message&lt;/code&gt; also contains the channel binding type chosen by the client.</source>
          <target state="translated">クライアントは、選択されたメカニズムである &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; または &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; を示すSASLInitialResponseメッセージを送信して応答します。（クライアントはどちらのメカニズムも自由に選択できますが、より良いセキュリティのために、それがサポートできる場合はチャネルバインディングバリアントを選択する必要があります。）[初期クライアント応答]フィールドで、メッセージにはSCRAM &lt;code&gt;client-first-message&lt;/code&gt; が含まれます。 &lt;code&gt;client-first-message&lt;/code&gt; 、クライアントによって選択されたチャネルバインディングタイプを含みます。</target>
        </trans-unit>
        <trans-unit id="28e4175f56ce1936736eeadfb881155016ea4fed" translate="yes" xml:space="preserve">
          <source>The client selects one of the supported mechanisms from the list, and sends a SASLInitialResponse message to the server. The message includes the name of the selected mechanism, and an optional Initial Client Response, if the selected mechanism uses that.</source>
          <target state="translated">クライアントはリストからサポートされているメカニズムのひとつを選択し、 SASLInitialResponse メッセージをサーバーに送信します。メッセージには、選択したメカニズムの名前と、選択したメカニズムがそれを使用している場合は、オプションの初期クライアント・レスポンスが含まれます。</target>
        </trans-unit>
        <trans-unit id="229cec88eb4f3eac7279336f40b13a71ae9b84dd" translate="yes" xml:space="preserve">
          <source>The client sends an Execute message with a non-zero fetch count. See the discussion of the &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY&quot;&gt;extended query protocol&lt;/a&gt;. Since &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq.html&quot;&gt;libpq&lt;/a&gt; currently provides no way to send such a message, this can only occur when using a client that does not rely on libpq. If this is a frequent occurrence, it may be a good idea to set &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt; to zero in sessions where it is likely, so as to avoid generating query plans that may be suboptimal when run serially.</source>
          <target state="translated">クライアントは、ゼロ以外のフェッチカウントで実行メッセージを送信します。&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY&quot;&gt;拡張クエリプロトコルの&lt;/a&gt;説明を参照してください。以来&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq.html&quot;&gt;のlibpqは&lt;/a&gt;現在、Aメッセージを送信するための方法を提供していませんのlibpqに依存していないクライアントを使用している場合、これが唯一の発生する可能性があります。これが頻繁に発生する場合は、可能性のあるセッションで&lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt;をゼロに設定して、逐次実行すると最適ではないクエリプランが生成されないようにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2c8bc9da59ada6925c6ca4e1408b3caa10a534cd" translate="yes" xml:space="preserve">
          <source>The code block is treated as though it were the body of a function with no parameters, returning &lt;code&gt;void&lt;/code&gt;. It is parsed and executed a single time.</source>
          <target state="translated">コードブロックは、パラメーターのない関数の本体であるかのように扱われ、 &lt;code&gt;void&lt;/code&gt; を返します。解析と実行は1回です。</target>
        </trans-unit>
        <trans-unit id="312278044badf1f81c35c2b663c752edaa662f24" translate="yes" xml:space="preserve">
          <source>The collation assigned to a function or operator's combined input expressions is also considered to apply to the function or operator's result, if the function or operator delivers a result of a collatable data type. So, in</source>
          <target state="translated">関数または演算子の結合された入力式に割り当てられた照合は、関数または演算子が照合可能なデータ型の結果を提供する場合、関数または演算子の結果にも適用されると考えられます。そのため、以下のように</target>
        </trans-unit>
        <trans-unit id="07ad042e8eb9598587dcbb36503b3ffb45fa7270" translate="yes" xml:space="preserve">
          <source>The collation feature allows specifying the sort order and character classification behavior of data per-column, or even per-operation. This alleviates the restriction that the &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; settings of a database cannot be changed after its creation.</source>
          <target state="translated">照合機能を使用すると、列ごと、または操作ごとに、データの並べ替え順序と文字分類動作を指定できます。これにより、データベースの &lt;code&gt;LC_COLLATE&lt;/code&gt; および &lt;code&gt;LC_CTYPE&lt;/code&gt; 設定は作成後に変更できないという制限が緩和されます。</target>
        </trans-unit>
        <trans-unit id="6968224c63a84f2b924666a708e6eefcbe1a5fe3" translate="yes" xml:space="preserve">
          <source>The collation of an expression can be the &amp;ldquo;default&amp;rdquo; collation, which means the locale settings defined for the database. It is also possible for an expression's collation to be indeterminate. In such cases, ordering operations and other operations that need to know the collation will fail.</source>
          <target state="translated">式の照合順序は、「デフォルト」の照合順序にすることができます。これは、データベースに定義されたロケール設定を意味します。式の照合順序が不確定になる可能性もあります。そのような場合、順序付け操作および照合を知る必要がある他の操作は失敗します。</target>
        </trans-unit>
        <trans-unit id="8cbb0497a2d0489a87ba349c1f09ee8dec4f3fd5" translate="yes" xml:space="preserve">
          <source>The collation used to derive the statistics stored in the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;. For example, a histogram slot for a collatable column would show the collation that defines the sort order of the data. Zero for noncollatable data.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 番目の「スロット」に格納されている統計情報を取得するために使用される照合順序。たとえば、照合可能な列のヒストグラムスロットは、データのソート順を定義する照合を示します。照合不可能なデータの場合はゼロ。</target>
        </trans-unit>
        <trans-unit id="b4385bb7e15544b6f2f8d39c7296d888e4a8a5d9" translate="yes" xml:space="preserve">
          <source>The colon (&lt;code&gt;:&lt;/code&gt;) is used to select &amp;ldquo;slices&amp;rdquo; from arrays. (See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt;.) In certain SQL dialects (such as Embedded SQL), the colon is used to prefix variable names.</source>
          <target state="translated">コロン（ &lt;code&gt;:&lt;/code&gt; ）アレイからの「スライス」を選択するために使用されます。（&lt;a href=&quot;arrays&quot;&gt;セクション8.15を&lt;/a&gt;参照してください。）特定のSQL方言（Embedded SQLなど）では、コロンを使用して変数名にプレフィックスを付けます。</target>
        </trans-unit>
        <trans-unit id="b41c26c54c1ac62b21f77b8fd62d5d3012b96e24" translate="yes" xml:space="preserve">
          <source>The colon syntax for variables is standard SQL for embedded query languages, such as ECPG. The colon syntaxes for array slices and type casts are PostgreSQL extensions, which can sometimes conflict with the standard usage. The colon-quote syntax for escaping a variable's value as an SQL literal or identifier is a psql extension.</source>
          <target state="translated">変数のコロン構文は、ECPGなどの組み込み問い合わせ言語の標準SQLです。配列スライスと型キャストのコロン構文はPostgreSQLの拡張であり、標準的な使用法と衝突することがあります。変数の値をSQLリテラルや識別子としてエスケープするためのコロン・クォート構文はpsql拡張です。</target>
        </trans-unit>
        <trans-unit id="d094304df5c5c2f3f002a3a5f2b5b0282e855c32" translate="yes" xml:space="preserve">
          <source>The column data type that this operator class is for.</source>
          <target state="translated">この演算子クラスが対象とする列データ型。</target>
        </trans-unit>
        <trans-unit id="5a6fb4ccabc2a7663f993c4ebb4c744ff2affbac" translate="yes" xml:space="preserve">
          <source>The column default value, in &lt;code&gt;nodeToString()&lt;/code&gt; representation. Use &lt;code&gt;pg_get_expr(adbin, adrelid)&lt;/code&gt; to convert it to an SQL expression.</source>
          <target state="translated">&lt;code&gt;nodeToString()&lt;/code&gt; 表現での列のデフォルト値。使う &lt;code&gt;pg_get_expr(adbin, adrelid)&lt;/code&gt; SQL式に変換します。</target>
        </trans-unit>
        <trans-unit id="08368fd428556014aaea42a5338ea6c2743ad445" translate="yes" xml:space="preserve">
          <source>The column is allowed to contain null values. This is the default.</source>
          <target state="translated">列にはヌル値を含めることができます。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="5bb55967abb94c1ccc24a2441d33dbf806399e61" translate="yes" xml:space="preserve">
          <source>The column is not allowed to contain null values.</source>
          <target state="translated">列にヌル値を含めることはできません。</target>
        </trans-unit>
        <trans-unit id="8420d2c88df44919ff7832e5423eccf9e0e7b65d" translate="yes" xml:space="preserve">
          <source>The column name</source>
          <target state="translated">カラム名</target>
        </trans-unit>
        <trans-unit id="d9ec3849dbdc73ff83e6e2b53f90a20a6fb0948f" translate="yes" xml:space="preserve">
          <source>The column source table(s) must be &lt;code&gt;INNER&lt;/code&gt; or &lt;code&gt;LEFT&lt;/code&gt; joined to the &lt;code&gt;LATERAL&lt;/code&gt; item, else there would not be a well-defined set of rows from which to compute each set of rows for the &lt;code&gt;LATERAL&lt;/code&gt; item. Thus, although a construct such as &lt;code&gt;X RIGHT JOIN LATERAL Y&lt;/code&gt; is syntactically valid, it is not actually allowed for &lt;code&gt;Y&lt;/code&gt; to reference &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">列ソーステーブルは &lt;code&gt;LATERAL&lt;/code&gt; アイテムに結合された &lt;code&gt;INNER&lt;/code&gt; または &lt;code&gt;LEFT&lt;/code&gt; である必要があります。そうでない場合、 &lt;code&gt;LATERAL&lt;/code&gt; アイテムの行の各セットを計算するための明確に定義された行のセットはありません。ような構築物がこのように、 &lt;code&gt;X RIGHT JOIN LATERAL Y&lt;/code&gt; 構文的に有効であり、それは実際に許可されていない &lt;code&gt;Y&lt;/code&gt; 基準に &lt;code&gt;X&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e991f9b83115d7ba9de797ba7c6fd7f9b86d5e91" translate="yes" xml:space="preserve">
          <source>The columns names &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; are either the actual names of the columns of tables referenced in the &lt;code&gt;FROM&lt;/code&gt; clause, or the aliases given to them as explained in &lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;Section 7.2.1.2&lt;/a&gt;. The name space available in the select list is the same as in the &lt;code&gt;WHERE&lt;/code&gt; clause, unless grouping is used, in which case it is the same as in the &lt;code&gt;HAVING&lt;/code&gt; clause.</source>
          <target state="translated">列名 &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、および &lt;code&gt;c&lt;/code&gt; は、 &lt;code&gt;FROM&lt;/code&gt; 句で参照されるテーブルの列の実際の名前、または&lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;7.2.1.2項で&lt;/a&gt;説明されているように、それらに割り当てられたエイリアスです。グループ化が使用されない限り、選択リストで使用可能な名前空間は &lt;code&gt;WHERE&lt;/code&gt; 句と同じです。この場合、グループ化は &lt;code&gt;HAVING&lt;/code&gt; 句と同じです。</target>
        </trans-unit>
        <trans-unit id="4599d6eec1312706887ef09d2464d5545c627474" translate="yes" xml:space="preserve">
          <source>The combination of the return value of this function with the certificate serial number uniquely identifies the certificate.</source>
          <target state="translated">この関数の戻り値と証明書のシリアル番号の組み合わせは、証明書を一意に識別します。</target>
        </trans-unit>
        <trans-unit id="062e4ea98a9662fe6dca5fb34a40a037aa606eb5" translate="yes" xml:space="preserve">
          <source>The command</source>
          <target state="translated">コマンド</target>
        </trans-unit>
        <trans-unit id="fd4ecf316bcb95382c9ca99fb6834b4e0a4db40c" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt; can also be used to create a new collation from an existing collation, which can be useful to be able to use operating-system-independent collation names in applications, create compatibility names, or use an ICU-provided collation under a more readable name. For example:</source>
          <target state="translated">コマンド&lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt;を使用して、既存の照合から新しい照合を作成することもできます。これは、アプリケーションでオペレーティングシステムに依存しない照合名を使用したり、互換性名を作成したり、ICU提供の照合をより読みやすい名前。例えば：</target>
        </trans-unit>
        <trans-unit id="d977c35dcae77bd0de806a55a77621ba14612b62" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;ALTER PUBLICATION&lt;/code&gt; can change the attributes of a publication.</source>
          <target state="translated">コマンド &lt;code&gt;ALTER PUBLICATION&lt;/code&gt; は、パブリケーションの属性を変更できます。</target>
        </trans-unit>
        <trans-unit id="969778663757608a9ceb272b57ae37cfa06e3dd9" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;COMMIT&lt;/code&gt; conforms to the SQL standard. The form &lt;code&gt;COMMIT TRANSACTION&lt;/code&gt; is a PostgreSQL extension.</source>
          <target state="translated">コマンド &lt;code&gt;COMMIT&lt;/code&gt; は、SQL標準に準拠しています。 &lt;code&gt;COMMIT TRANSACTION&lt;/code&gt; という形式は、PostgreSQLの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="dbf0fa331f942a39e4739f4ed15c74b619e12d1b" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;CREATE DOMAIN&lt;/code&gt; conforms to the SQL standard.</source>
          <target state="translated">コマンド &lt;code&gt;CREATE DOMAIN&lt;/code&gt; は、SQL標準に準拠しています。</target>
        </trans-unit>
        <trans-unit id="c0e7572b18c65a9a6261e55f6991fd2f67f9ff3c" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;LOCK TABLE a, b;&lt;/code&gt; is equivalent to &lt;code&gt;LOCK TABLE a; LOCK TABLE b;&lt;/code&gt;. The tables are locked one-by-one in the order specified in the &lt;code&gt;LOCK TABLE&lt;/code&gt; command.</source>
          <target state="translated">コマンド &lt;code&gt;LOCK TABLE a, b;&lt;/code&gt; &lt;code&gt;LOCK TABLE a; LOCK TABLE b;&lt;/code&gt; と同等です。ロックテーブルb; 。テーブルは、 &lt;code&gt;LOCK TABLE&lt;/code&gt; コマンドで指定された順序で1つずつロックされます。</target>
        </trans-unit>
        <trans-unit id="bd29caedfd38b09e6ed21c78963ca39d6d0fdf15" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;ROLLBACK&lt;/code&gt; conforms to the SQL standard. The form &lt;code&gt;ROLLBACK TRANSACTION&lt;/code&gt; is a PostgreSQL extension.</source>
          <target state="translated">コマンド &lt;code&gt;ROLLBACK&lt;/code&gt; は、SQL標準に準拠しています。 &lt;code&gt;ROLLBACK TRANSACTION&lt;/code&gt; の形式はPostgreSQLの拡張です。</target>
        </trans-unit>
        <trans-unit id="14f45c2838c91f3d088f1dbeb531759099cc9619" translate="yes" xml:space="preserve">
          <source>The command does not actually have to prompt the user for a passphrase. It can read it from a file, obtain it from a keychain facility, or similar. It is up to the user to make sure the chosen mechanism is adequately secure.</source>
          <target state="translated">コマンドは実際にはパスフレーズの入力をユーザに求める必要はありません。ファイルから読み取るか、キーチェーン施設から取得するか、または同様の方法でパスフレーズを取得することができます。選択したメカニズムが十分に安全であることを確認するのはユーザ次第です。</target>
        </trans-unit>
        <trans-unit id="125f23e3bb7186ab7a646a52cf5bf9eca19bcc45" translate="yes" xml:space="preserve">
          <source>The command form &lt;code&gt;\d+&lt;/code&gt; is identical, except that more information is displayed: any comments associated with the columns of the table are shown, as is the presence of OIDs in the table, the view definition if the relation is a view, a non-default &lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt;replica identity&lt;/a&gt; setting.</source>
          <target state="translated">コマンドフォーム &lt;code&gt;\d+&lt;/code&gt; は同じですが、詳細情報が表示されます。テーブルの列に関連付けられているコメントが表示されます。テーブルにOIDが存在する場合、リレーションがビューの場合はビューの定義、デフォルトの&lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt;レプリカID&lt;/a&gt;設定。</target>
        </trans-unit>
        <trans-unit id="0916bd8daa5b51f8834876be91b7f972c2fe0c9c" translate="yes" xml:space="preserve">
          <source>The command identifier (starting at zero) within the inserting transaction.</source>
          <target state="translated">挿入トランザクション内のコマンド識別子(ゼロから始まる)。</target>
        </trans-unit>
        <trans-unit id="d1364d07c5f1725771640b150e94c42c6a8b2515" translate="yes" xml:space="preserve">
          <source>The command identifier within the deleting transaction, or zero.</source>
          <target state="translated">削除するトランザクション内のコマンド識別子、またはゼロ。</target>
        </trans-unit>
        <trans-unit id="4d0382226380f9ead190eb302a73c778dbdd6e8d" translate="yes" xml:space="preserve">
          <source>The command is currently rebuilding an index.</source>
          <target state="translated">コマンドは現在インデックスを再構築中です。</target>
        </trans-unit>
        <trans-unit id="bf18e6a22964c8d441f27d38a4a845cd36e9d7a8" translate="yes" xml:space="preserve">
          <source>The command is currently scanning the table using a sequential scan.</source>
          <target state="translated">コマンドは現在、シーケンシャル スキャンを使用してテーブルをスキャンしています。</target>
        </trans-unit>
        <trans-unit id="2d997222e2d809bc7ed01be5d82f30faa7501100" translate="yes" xml:space="preserve">
          <source>The command is currently swapping newly-built files into place.</source>
          <target state="translated">コマンドは現在、新しくビルドされたファイルを所定の場所にスワップしています。</target>
        </trans-unit>
        <trans-unit id="d36048945358a61f078040109a39866ba3017fd5" translate="yes" xml:space="preserve">
          <source>The command is performing final cleanup. When this phase is completed, &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; will end.</source>
          <target state="translated">コマンドは最終クリーンアップを実行しています。このフェーズが完了すると、 &lt;code&gt;CLUSTER&lt;/code&gt; または &lt;code&gt;VACUUM FULL&lt;/code&gt; が終了します。</target>
        </trans-unit>
        <trans-unit id="b779f0c2e033575cc8fc0dc14c755c01561f9ff6" translate="yes" xml:space="preserve">
          <source>The command is preparing to begin scanning the heap. This phase is expected to be very brief.</source>
          <target state="translated">コマンドはヒープのスキャンを開始する準備をしています。このフェーズは非常に短いと予想されます。</target>
        </trans-unit>
        <trans-unit id="00faacb1d010fe63608a96c43ef3a7084a48b136" translate="yes" xml:space="preserve">
          <source>The command must print the passphrase to the standard output and exit with code 0. In the parameter value, &lt;code&gt;%p&lt;/code&gt; is replaced by a prompt string. (Write &lt;code&gt;%%&lt;/code&gt; for a literal &lt;code&gt;%&lt;/code&gt;.) Note that the prompt string will probably contain whitespace, so be sure to quote adequately. A single newline is stripped from the end of the output if present.</source>
          <target state="translated">コマンドはパスフレーズを標準出力に出力し、コード0で終了する必要があります。パラメーター値では、 &lt;code&gt;%p&lt;/code&gt; はプロンプト文字列に置き換えられます。（リテラル &lt;code&gt;%&lt;/code&gt; の場合は &lt;code&gt;%%&lt;/code&gt; と記述します。）プロンプト文字列にはおそらく空白が含まれるため、適切に引用してください。存在する場合、出力の最後から単一の改行が削除されます。</target>
        </trans-unit>
        <trans-unit id="c98b53eebf8fcd4fa5340e65c4d477e99fd91e81" translate="yes" xml:space="preserve">
          <source>The command or commands that make up the rule action. Valid commands are &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;NOTIFY&lt;/code&gt;.</source>
          <target state="translated">ルールアクションを構成するコマンド。有効なコマンドは、 &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、または &lt;code&gt;NOTIFY&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8f5e5a53841d0cfd1aacf0accff8cefa2f5212ac" translate="yes" xml:space="preserve">
          <source>The command tag returned by &lt;code&gt;EXECUTE&lt;/code&gt; is that of the prepared statement, and not &lt;code&gt;EXECUTE&lt;/code&gt;.</source>
          <target state="translated">タグは、によって返さコマンド &lt;code&gt;EXECUTE&lt;/code&gt; は、準備された文のことではなく、 &lt;code&gt;EXECUTE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74ac6ad09ab58057a9fed1f64a26a788f3d3e326" translate="yes" xml:space="preserve">
          <source>The command that is running. Either &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt;.</source>
          <target state="translated">実行中のコマンド。 &lt;code&gt;CLUSTER&lt;/code&gt; または &lt;code&gt;VACUUM FULL&lt;/code&gt; のいずれか。</target>
        </trans-unit>
        <trans-unit id="a9850fa889a0eec791cad23100b9e331cd2aa4fc" translate="yes" xml:space="preserve">
          <source>The command that is running: &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;, or &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt;.</source>
          <target state="translated">実行中のコマンド： &lt;code&gt;CREATE INDEX&lt;/code&gt; 、 &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; 、 &lt;code&gt;REINDEX&lt;/code&gt; 、または &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="559d421f3432d35c3d9a8fb5131571d6eb8752e8" translate="yes" xml:space="preserve">
          <source>The command to which the policy applies. Valid options are &lt;code&gt;ALL&lt;/code&gt;, &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;. &lt;code&gt;ALL&lt;/code&gt; is the default. See below for specifics regarding how these are applied.</source>
          <target state="translated">ポリシーが適用されるコマンド。有効なオプションは、 &lt;code&gt;ALL&lt;/code&gt; 、 &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、および &lt;code&gt;DELETE&lt;/code&gt; です。 &lt;code&gt;ALL&lt;/code&gt; がデフォルトです。これらの適用方法の詳細については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="7852202b8a6003f108d83f18dfb4650d44b65813" translate="yes" xml:space="preserve">
          <source>The command type to which the policy is applied</source>
          <target state="translated">ポリシーを適用するコマンドタイプ</target>
        </trans-unit>
        <trans-unit id="6c49af8969ccfcd1693376760717e08595698aa9" translate="yes" xml:space="preserve">
          <source>The command type to which the policy is applied: &lt;code&gt;r&lt;/code&gt; for &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; for &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt; for &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt; for &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;*&lt;/code&gt; for all</source>
          <target state="translated">ポリシーが適用されるコマンドタイプ： &lt;code&gt;r&lt;/code&gt; は &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;w&lt;/code&gt; は &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;d&lt;/code&gt; は &lt;code&gt;DELETE&lt;/code&gt; 、または &lt;code&gt;*&lt;/code&gt; はすべて</target>
        </trans-unit>
        <trans-unit id="31a55b9a99200f37a1fc91d5f4fc188806cc57ad" translate="yes" xml:space="preserve">
          <source>The command's result is a textual description of the plan selected for the &lt;code&gt;statement&lt;/code&gt;, optionally annotated with execution statistics. &lt;a href=&quot;using-explain&quot;&gt;Section 14.1&lt;/a&gt; describes the information provided.</source>
          <target state="translated">コマンドの結果は、 &lt;code&gt;statement&lt;/code&gt; に対して選択されたプランのテキストによる説明であり、オプションで実行統計情報が注釈として付けられます。&lt;a href=&quot;using-explain&quot;&gt;セクション14.1&lt;/a&gt;では、提供される情報について説明します。</target>
        </trans-unit>
        <trans-unit id="40e0a2632f98d43624e2ba898ef7cc5bdd1cf8c1" translate="yes" xml:space="preserve">
          <source>The command-line history is stored in the file &lt;code&gt;~/.psql_history&lt;/code&gt;, or &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; on Windows.</source>
          <target state="translated">コマンドライン履歴は、ファイル &lt;code&gt;~/.psql_history&lt;/code&gt; 、またはWindowsでは &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; れます。</target>
        </trans-unit>
        <trans-unit id="f9e42c3efb15d8e677dc2308149404249d782207" translate="yes" xml:space="preserve">
          <source>The command-line-style arguments specified in &lt;code&gt;extra-options&lt;/code&gt; are passed to all server processes started by this &lt;code&gt;postgres&lt;/code&gt; process.</source>
          <target state="translated">&lt;code&gt;extra-options&lt;/code&gt; で指定されたコマンドラインスタイルの引数は、この &lt;code&gt;postgres&lt;/code&gt; プロセスによって開始されたすべてのサーバープロセスに渡されます。</target>
        </trans-unit>
        <trans-unit id="360d0f8394d720d22156d27a3f3ab0d50f8729e3" translate="yes" xml:space="preserve">
          <source>The commands &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;INSERT&lt;/code&gt; acquire this lock mode on the target table (in addition to &lt;code&gt;ACCESS SHARE&lt;/code&gt; locks on any other referenced tables). In general, this lock mode will be acquired by any command that &lt;em&gt;modifies data&lt;/em&gt; in a table.</source>
          <target state="translated">コマンド &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、および &lt;code&gt;INSERT&lt;/code&gt; は、（他の参照されるテーブルの &lt;code&gt;ACCESS SHARE&lt;/code&gt; ロックに加えて）ターゲットテーブルでこのロックモードを取得します。一般に、このロックモードは、テーブルの&lt;em&gt;データ&lt;/em&gt;を&lt;em&gt;変更する&lt;/em&gt;コマンドによって取得されます。</target>
        </trans-unit>
        <trans-unit id="b120614b8a1edecdcf4c676c85b59acab98338cc" translate="yes" xml:space="preserve">
          <source>The commutator of this operator.</source>
          <target state="translated">この演算子の整流子。</target>
        </trans-unit>
        <trans-unit id="f6803da73417ed20d6aa993c5529f00237b3f6a3" translate="yes" xml:space="preserve">
          <source>The compatibility notes of the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; command apply analogously to &lt;code&gt;REVOKE&lt;/code&gt;. The keyword &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; is required according to the standard, but PostgreSQL assumes &lt;code&gt;RESTRICT&lt;/code&gt; by default.</source>
          <target state="translated">互換性ノート&lt;a href=&quot;sql-grant&quot;&gt;のGRANT&lt;/a&gt;コマンドは、と同様に適用されます &lt;code&gt;REVOKE&lt;/code&gt; 。標準ではキーワード &lt;code&gt;RESTRICT&lt;/code&gt; または &lt;code&gt;CASCADE&lt;/code&gt; が必要ですが、PostgreSQL ではデフォルトで &lt;code&gt;RESTRICT&lt;/code&gt; が想定されています。</target>
        </trans-unit>
        <trans-unit id="40702de9ee6c2366268d72254909613dec0511c4" translate="yes" xml:space="preserve">
          <source>The complete lack of these facilities is usually manifested by an &amp;ldquo;Illegal system call&amp;rdquo; error upon server start. In that case there is no alternative but to reconfigure your kernel. PostgreSQL won't work without them. This situation is rare, however, among modern operating systems.</source>
          <target state="translated">これらの機能の完全な欠如は、通常、サーバー起動時の「不正なシステムコール」エラーによって明らかになります。その場合、カーネルを再構成する以外に方法はありません。PostgreSQLはそれらなしでは動作しません。ただし、最近のオペレーティングシステムでは、このような状況はまれです。</target>
        </trans-unit>
        <trans-unit id="8728921721ecf34d843d2d7d08bdc9c0ecc2f84b" translate="yes" xml:space="preserve">
          <source>The composite output routine will put double quotes around field values if they are empty strings or contain parentheses, commas, double quotes, backslashes, or white space. (Doing so for white space is not essential, but aids legibility.) Double quotes and backslashes embedded in field values will be doubled.</source>
          <target state="translated">複合出力ルーチンは、フィールド値が空の文字列であったり、括弧、カンマ、二重引用符、バックスラッシュ、または空白が含まれている場合には、フィールド値の周りに二重引用符を配置します。フィールド値に埋め込まれた二重引用符とバックスラッシュは二重になります。</target>
        </trans-unit>
        <trans-unit id="7b5e42f8ee02c00c89066a781bb2783e80203625" translate="yes" xml:space="preserve">
          <source>The compression technique used for either in-line or out-of-line compressed data is a fairly simple and very fast member of the LZ family of compression techniques. See &lt;code&gt;src/common/pg_lzcompress.c&lt;/code&gt; for the details.</source>
          <target state="translated">インラインまたはアウトオブラインの圧縮データに使用される圧縮技術は、LZファミリーの圧縮技術のかなり単純で非常に高速なメンバーです。詳細については &lt;code&gt;src/common/pg_lzcompress.c&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="74936e59660e5e1e74d04f83302b0b914fcee784" translate="yes" xml:space="preserve">
          <source>The concatenation operator allows a single element to be pushed onto the beginning or end of a one-dimensional array. It also accepts two &lt;code&gt;N&lt;/code&gt;-dimensional arrays, or an &lt;code&gt;N&lt;/code&gt;-dimensional and an &lt;code&gt;N+1&lt;/code&gt;-dimensional array.</source>
          <target state="translated">連結演算子を使用すると、1つの要素を1次元配列の先頭または末尾にプッシュできます。また、2つの受け入れ &lt;code&gt;N&lt;/code&gt; 次元アレイ、または &lt;code&gt;N&lt;/code&gt; 次元と &lt;code&gt;N+1&lt;/code&gt; 次元アレイ。</target>
        </trans-unit>
        <trans-unit id="5239ff4b58c91e7e13723e3163e22ecae35f6c6f" translate="yes" xml:space="preserve">
          <source>The condition &lt;code&gt;t1.hundred &amp;lt; t2.hundred&lt;/code&gt; can't be tested in the &lt;code&gt;tenk2_unique2&lt;/code&gt; index, so it's applied at the join node. This reduces the estimated output row count of the join node, but does not change either input scan.</source>
          <target state="translated">条件 &lt;code&gt;t1.hundred &amp;lt; t2.hundred&lt;/code&gt; は &lt;code&gt;tenk2_unique2&lt;/code&gt; インデックスでテストできないため、結合ノードで適用されます。これにより、結合ノードの推定出力行数が減少しますが、入力スキャンは変更されません。</target>
        </trans-unit>
        <trans-unit id="c068c3abe0f845f75d348f1e71b7501c9e85d719" translate="yes" xml:space="preserve">
          <source>The configuration file is reread whenever the main server process receives a SIGHUP signal; this signal is most easily sent by running &lt;code&gt;pg_ctl reload&lt;/code&gt; from the command line or by calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;. The main server process also propagates this signal to all currently running server processes, so that existing sessions also adopt the new values (this will happen after they complete any currently-executing client command). Alternatively, you can send the signal to a single server process directly. Some parameters can only be set at server start; any changes to their entries in the configuration file will be ignored until the server is restarted. Invalid parameter settings in the configuration file are likewise ignored (but logged) during SIGHUP processing.</source>
          <target state="translated">メインサーバープロセスがSIGHUPシグナルを受信するたびに、構成ファイルが再読み取りされます。このシグナルは、コマンドラインから &lt;code&gt;pg_ctl reload&lt;/code&gt; を実行するか、SQL関数 &lt;code&gt;pg_reload_conf()&lt;/code&gt; を呼び出すことによって最も簡単に送信されます。また、メインサーバープロセスはこの信号を現在実行中のすべてのサーバープロセスに伝達するため、既存のセッションも新しい値を採用します（これは、現在実行中のクライアントコマンドが完了した後に発生します）。または、シグナルを単一のサーバープロセスに直接送信することもできます。一部のパラメータはサーバーの起動時にのみ設定できます。構成ファイル内のエントリへの変更は、サーバーが再起動されるまで無視されます。同様に、構成ファイル内の無効なパラメーター設定は、SIGHUP処理中に無視されます（ただしログに記録されます）。</target>
        </trans-unit>
        <trans-unit id="b9dccd142849bf4c5f5639f61a51dab8e56e5d09" translate="yes" xml:space="preserve">
          <source>The configuration variable &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; determines whether JIT compilation is enabled or disabled. If it is enabled, the configuration variables &lt;a href=&quot;runtime-config-query#GUC-JIT-ABOVE-COST&quot;&gt;jit_above_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt;, and &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt; determine whether JIT compilation is performed for a query, and how much effort is spent doing so.</source>
          <target state="translated">構成変数&lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt;は、JITコンパイルを有効にするか無効にするかを決定します。有効になっている場合、設定変数&lt;a href=&quot;runtime-config-query#GUC-JIT-ABOVE-COST&quot;&gt;jit_above_cost&lt;/a&gt;、&lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt;、および&lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt;は、クエリに対してJITコンパイルが実行されるかどうか、および実行に費やされる労力を決定します。</target>
        </trans-unit>
        <trans-unit id="19797f9713f4025f6738d996f66f2f16f1bb3ee3" translate="yes" xml:space="preserve">
          <source>The connection must be to the same database used to create the slot.</source>
          <target state="translated">接続先は、スロットを作成するために使用したのと同じデータベースでなければなりません。</target>
        </trans-unit>
        <trans-unit id="cbc80489eb4bf174c233f6bbbaa42452b7d3d86f" translate="yes" xml:space="preserve">
          <source>The connection string should specify the host name (or address) of the sending server, as well as the port number if it is not the same as the standby server's default. Also specify a user name corresponding to a suitably-privileged role on the sending server (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-AUTHENTICATION&quot;&gt;Section 26.2.5.1&lt;/a&gt;). A password needs to be provided too, if the sender demands password authentication. It can be provided in the &lt;code&gt;primary_conninfo&lt;/code&gt; string, or in a separate &lt;code&gt;~/.pgpass&lt;/code&gt; file on the standby server (use &lt;code&gt;replication&lt;/code&gt; as the database name). Do not specify a database name in the &lt;code&gt;primary_conninfo&lt;/code&gt; string.</source>
          <target state="translated">接続文字列は、送信サーバーのホスト名（またはアドレス）と、スタンバイサーバーのデフォルトと異なる場合はポート番号を指定する必要があります。また、送信側サーバーの適切な特権を持つロールに対応するユーザー名を指定します（&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-AUTHENTICATION&quot;&gt;セクション26.2.5.1を&lt;/a&gt;参照）。送信者がパスワード認証を要求する場合、パスワードも提供する必要があります。これは、 &lt;code&gt;primary_conninfo&lt;/code&gt; 文字列、またはスタンバイサーバー上の別の &lt;code&gt;~/.pgpass&lt;/code&gt; ファイルで提供できます（データベース名として &lt;code&gt;replication&lt;/code&gt; を使用）。 &lt;code&gt;primary_conninfo&lt;/code&gt; 文字列にデータベース名を指定しないでください。</target>
        </trans-unit>
        <trans-unit id="31fcb6829f600da0b565f01362ffaf255feb5d94" translate="yes" xml:space="preserve">
          <source>The connection string to the publisher. For details see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt;.</source>
          <target state="translated">パブリッシャーへの接続文字列。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;セクション33.1.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="164c7293cd6f4e265338f6fb352f7b98d06266a8" translate="yes" xml:space="preserve">
          <source>The constraint expression for a partial index.</source>
          <target state="translated">部分インデックスの制約式。</target>
        </trans-unit>
        <trans-unit id="0a023003d324d129028d83c645a2d4429045b67a" translate="yes" xml:space="preserve">
          <source>The constraint will be checked immediately, so the table data must satisfy the constraint before it can be added.</source>
          <target state="translated">制約はすぐにチェックされるので、テーブルデータは制約を満たしていないと追加できません。</target>
        </trans-unit>
        <trans-unit id="f753df8000fdee9203aa2be3a2862eb377d770ad" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;(a, b)&lt;/code&gt; is normally recognized in expressions as a &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;row constructor&lt;/a&gt;. Within the &lt;code&gt;GROUP BY&lt;/code&gt; clause, this does not apply at the top levels of expressions, and &lt;code&gt;(a, b)&lt;/code&gt; is parsed as a list of expressions as described above. If for some reason you &lt;em&gt;need&lt;/em&gt; a row constructor in a grouping expression, use &lt;code&gt;ROW(a, b)&lt;/code&gt;.</source>
          <target state="translated">構文 &lt;code&gt;(a, b)&lt;/code&gt; は、通常、式では&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;行コンストラクター&lt;/a&gt;として認識されます。 &lt;code&gt;GROUP BY&lt;/code&gt; 句内では、これは式の最上位には適用されず、 &lt;code&gt;(a, b)&lt;/code&gt; は上記のように式のリストとして解析されます。何らかの理由でグループ化式で行コンストラクターが&lt;em&gt;必要な&lt;/em&gt;場合は、 &lt;code&gt;ROW(a, b)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="bdace32fdb5c0027816e247b4bd1b7fb7ff95259" translate="yes" xml:space="preserve">
          <source>The contents of tables and indexes are discussed further in &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;.</source>
          <target state="translated">テーブルとインデックスの内容については、&lt;a href=&quot;storage-page-layout&quot;&gt;セクション68.6で&lt;/a&gt;詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="38f47269fb5aeb6c838c026cdcf1f0ae2ecfc4fc" translate="yes" xml:space="preserve">
          <source>The contents of the WAL buffers are written out to disk at every transaction commit, so extremely large values are unlikely to provide a significant benefit. However, setting this value to at least a few megabytes can improve write performance on a busy server where many clients are committing at once. The auto-tuning selected by the default setting of -1 should give reasonable results in most cases.</source>
          <target state="translated">WALバッファの内容はトランザクションのコミットごとにディスクに書き出されるので、極端に大きな値を設定しても大きなメリットにはならないでしょう。しかし、この値を少なくとも数メガバイトに設定することで、多くのクライアントが一度にコミットするような忙しいサーバでは、書き込みパフォーマンスを向上させることができます。デフォルト設定の-1で選択されている自動調整は、ほとんどの場合でそれなりの結果をもたらすはずです。</target>
        </trans-unit>
        <trans-unit id="b1c6502d2f4ffe992973e02c33536a28b4746870" translate="yes" xml:space="preserve">
          <source>The contents of the directories &lt;code&gt;pg_dynshmem/&lt;/code&gt;, &lt;code&gt;pg_notify/&lt;/code&gt;, &lt;code&gt;pg_serial/&lt;/code&gt;, &lt;code&gt;pg_snapshots/&lt;/code&gt;, &lt;code&gt;pg_stat_tmp/&lt;/code&gt;, and &lt;code&gt;pg_subtrans/&lt;/code&gt; (but not the directories themselves) can be omitted from the backup as they will be initialized on postmaster startup. If &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; is set and is under the data directory then the contents of that directory can also be omitted.</source>
          <target state="translated">ディレクトリ &lt;code&gt;pg_dynshmem/&lt;/code&gt; 、 &lt;code&gt;pg_notify/&lt;/code&gt; 、 &lt;code&gt;pg_serial/&lt;/code&gt; 、 &lt;code&gt;pg_snapshots/&lt;/code&gt; 、 &lt;code&gt;pg_stat_tmp/&lt;/code&gt; 、および &lt;code&gt;pg_subtrans/&lt;/code&gt; （ディレクトリ自体ではなく）の内容は、ポストマスターの起動時に初期化されるため、バックアップから除外できます。場合&lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;をstats_temp_directoryが&lt;/a&gt;セットされ、データディレクトリの下にある、そのディレクトリの内容を省略することもできます。</target>
        </trans-unit>
        <trans-unit id="46e0411ab62d3d86cfefc61b32fd0a5818262ee5" translate="yes" xml:space="preserve">
          <source>The conversion rules presented here are not exactly those of the SQL standard, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-CASTS&quot;&gt;Section D.3.1.3&lt;/a&gt;.</source>
          <target state="translated">ここに示す変換ルールは、&lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-CASTS&quot;&gt;D.3.1.3項で&lt;/a&gt;説明したように、SQL標準のものとは厳密には異なります。</target>
        </trans-unit>
        <trans-unit id="93003637d33db2eb4895822b5caba9508ac9a024" translate="yes" xml:space="preserve">
          <source>The coordinates of an individual in the search space are represented by &lt;em&gt;chromosomes&lt;/em&gt;, in essence a set of character strings. A &lt;em&gt;gene&lt;/em&gt; is a subsection of a chromosome which encodes the value of a single parameter being optimized. Typical encodings for a gene could be &lt;em&gt;binary&lt;/em&gt; or &lt;em&gt;integer&lt;/em&gt;.</source>
          <target state="translated">サーチスペース内の個人の座標は、基本的には文字列のセットである&lt;em&gt;染色体&lt;/em&gt;によって表されます。&lt;em&gt;遺伝子は、&lt;/em&gt;最適化される単一のパラメータの値を符号化する染色体のサブセクションです。遺伝子の一般的なエンコーディングは、&lt;em&gt;バイナリ&lt;/em&gt;または&lt;em&gt;整数&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="862293286080d0a9f0113978ebf74556e90249fd" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the BRIN operator classes shown in &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 67.1&lt;/a&gt;.</source>
          <target state="translated">コアPostgreSQLディストリビューションには、&lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;表67.1に&lt;/a&gt;示すBRIN演算子クラスが含まれています。</target>
        </trans-unit>
        <trans-unit id="7243c976dc744d56b010e5d36a8288b88892f5dc" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GIN operator classes previously shown in &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 66.1&lt;/a&gt;. The following &lt;code&gt;contrib&lt;/code&gt; modules also contain GIN operator classes:</source>
          <target state="translated">コアPostgreSQLディストリビューションには、以前に&lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;表66.1に&lt;/a&gt;示したGIN演算子クラスが含まれています。次の &lt;code&gt;contrib&lt;/code&gt; モジュールには、GIN演算子クラスも含まれています。</target>
        </trans-unit>
        <trans-unit id="c2fbf40f11cf35a0a12e58dfa2d5f0d5377fea85" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GIN operator classes shown in &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 66.1&lt;/a&gt;. (Some of the optional modules described in &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Appendix F&lt;/a&gt; provide additional GIN operator classes.)</source>
          <target state="translated">コアPostgreSQLディストリビューションには、&lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;表66.1に&lt;/a&gt;示すGIN演算子クラスが含まれています。（&lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;付録Fで&lt;/a&gt;説明されている一部のオプションモジュールは、追加のGIN演算子クラスを提供します。）</target>
        </trans-unit>
        <trans-unit id="3d8a9d6f1f395ae01d0f93e48fe3bca4cc653cd4" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GiST operator classes shown in &lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 64.1&lt;/a&gt;. (Some of the optional modules described in &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Appendix F&lt;/a&gt; provide additional GiST operator classes.)</source>
          <target state="translated">コアPostgreSQLディストリビューションには、&lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;表64.1に&lt;/a&gt;示すGiST演算子クラスが含まれています。（&lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;付録Fで&lt;/a&gt;説明されている一部のオプションモジュールは、追加のGiST演算子クラスを提供します。）</target>
        </trans-unit>
        <trans-unit id="3d4f128e5e4ead669ae57136a3aca466199dcb9f" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the SP-GiST operator classes shown in &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 65.1&lt;/a&gt;.</source>
          <target state="translated">コアPostgreSQLディストリビューションには、&lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;表65.1に&lt;/a&gt;示すSP-GiST演算子クラスが含まれています。</target>
        </trans-unit>
        <trans-unit id="89a856912c9ac553c9e328fb462dc4a3dc3f226a" translate="yes" xml:space="preserve">
          <source>The core distribution includes support for two types of operator classes: minmax and inclusion. Operator class definitions using them are shipped for in-core data types as appropriate. Additional operator classes can be defined by the user for other data types using equivalent definitions, without having to write any source code; appropriate catalog entries being declared is enough. Note that assumptions about the semantics of operator strategies are embedded in the support functions' source code.</source>
          <target state="translated">コア・ディストリビューションには、minmaxとinclusionの2種類の演算子クラスがサポートされています。これらを使用する演算子クラスの定義は、必要に応じてコア内のデータ型に対して出荷されます。追加の演算子クラスは、ソースコードを書かなくても、同等の定義を使用して他のデータ型に対してユーザが定義することができます。演算子ストラテジーのセマンティクスに関する仮定は、サポート関数のソースコードに埋め込まれていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c6af74783e2e512b02fff35f8b9b1611ba92c8bc" translate="yes" xml:space="preserve">
          <source>The corresponding column will be filled with its default value.</source>
          <target state="translated">対応する列はデフォルト値で埋められます。</target>
        </trans-unit>
        <trans-unit id="39b1b5853e1b21f147904a21bac6120e0399eff4" translate="yes" xml:space="preserve">
          <source>The corresponding constraint in the parent partitioned table, if this is a constraint in a partition; else 0</source>
          <target state="translated">パーティション内の制約であれば、親パーティショニングされたテーブル内の対応する制約。</target>
        </trans-unit>
        <trans-unit id="e50bc6dd81573c8b84e401b93b09d0320c5165e6" translate="yes" xml:space="preserve">
          <source>The costs are measured in arbitrary units determined by the planner's cost parameters (see &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;). Traditional practice is to measure the costs in units of disk page fetches; that is, &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt; is conventionally set to &lt;code&gt;1.0&lt;/code&gt; and the other cost parameters are set relative to that. The examples in this section are run with the default cost parameters.</source>
          <target state="translated">コストは、プランナのコストパラメータによって決定される任意の単位で測定されます（&lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;セクション19.7.2を&lt;/a&gt;参照）。従来の方法では、ディスクページフェッチの単位でコストを測定していました。つまり、&lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;は通常 &lt;code&gt;1.0&lt;/code&gt; に設定され、他のコストパラメータはそれに関連して設定されます。このセクションの例は、デフォルトのコストパラメータを使用して実行されます。</target>
        </trans-unit>
        <trans-unit id="40a2e5c659fc82ea65929c45fcbdccd61dafc250" translate="yes" xml:space="preserve">
          <source>The creation of a publication does not start replication. It only defines a grouping and filtering logic for future subscribers.</source>
          <target state="translated">パブリケーションの作成はレプリケーションを開始しません。それは、将来のサブスクライバのためのグループ化とフィルタリング・ロジックを定義するだけです。</target>
        </trans-unit>
        <trans-unit id="3e98adbd0156fb7d426b89504f191dda4a555319" translate="yes" xml:space="preserve">
          <source>The creation of databases is a restricted operation. See &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt; for how to grant permission.</source>
          <target state="translated">データベースの作成は制限された操作です。許可を与える方法については&lt;a href=&quot;role-attributes&quot;&gt;項21.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1880291804157d355a896d197b0a52d8a09b04b7" translate="yes" xml:space="preserve">
          <source>The cube a contains the cube b.</source>
          <target state="translated">立方体aには立方体bが含まれています。</target>
        </trans-unit>
        <trans-unit id="375266423676b7d7beda6d0e513197403bfef8c1" translate="yes" xml:space="preserve">
          <source>The cube a is contained in the cube b.</source>
          <target state="translated">立方体aは立方体bに含まれています。</target>
        </trans-unit>
        <trans-unit id="b588f40bf468c3153645f14f27d51be8b21426c9" translate="yes" xml:space="preserve">
          <source>The cube a is greater than or equal to the cube b.</source>
          <target state="translated">立方体aは立方体b以上である。</target>
        </trans-unit>
        <trans-unit id="2f01cfa360b4f7c3692487eca6dd5b417fc389b3" translate="yes" xml:space="preserve">
          <source>The cube a is greater than the cube b.</source>
          <target state="translated">立方体aは立方体bよりも大きい。</target>
        </trans-unit>
        <trans-unit id="0e6cf54be6b186407704fdff88fc957131d4ed9b" translate="yes" xml:space="preserve">
          <source>The cube a is less than or equal to the cube b.</source>
          <target state="translated">立方体aは、立方体b以下である。</target>
        </trans-unit>
        <trans-unit id="f2d342ff49043cacce0129a759922d79461a11fa" translate="yes" xml:space="preserve">
          <source>The cube a is less than the cube b.</source>
          <target state="translated">立方体aは立方体bよりも小さい。</target>
        </trans-unit>
        <trans-unit id="4634367f6224780d287c24528a5fced1237e5fa1" translate="yes" xml:space="preserve">
          <source>The cube a is not equal to the cube b.</source>
          <target state="translated">立方体aと立方体bは等しくない。</target>
        </trans-unit>
        <trans-unit id="45987f656860bb4eb975fa1cd72ba43bc699f956" translate="yes" xml:space="preserve">
          <source>The cubes a and b are identical.</source>
          <target state="translated">立方体のaとbは同じです。</target>
        </trans-unit>
        <trans-unit id="9213cf52b8d8a10f6b7daa93550fc8c65e89e83d" translate="yes" xml:space="preserve">
          <source>The cubes a and b overlap.</source>
          <target state="translated">立方体のaとbが重なっている。</target>
        </trans-unit>
        <trans-unit id="1a1e2040f8ce058f3c38c6e6d3751c0a69992146" translate="yes" xml:space="preserve">
          <source>The current backend's &lt;code&gt;xmin&lt;/code&gt; horizon.</source>
          <target state="translated">現在のバックエンドの &lt;code&gt;xmin&lt;/code&gt; ホライズン。</target>
        </trans-unit>
        <trans-unit id="71bea49a2448467c39ae3d46b44b8328244be40c" translate="yes" xml:space="preserve">
          <source>The current client character set encoding. This is set every time you connect to a database (including program start-up), and when you change the encoding with &lt;code&gt;\encoding&lt;/code&gt;, but it can be changed or unset.</source>
          <target state="translated">現在のクライアントの文字セットエンコーディング。これは、データベースに接続するたびに（プログラムの起動を含む）、 &lt;code&gt;\encoding&lt;/code&gt; を使用してエンコードを変更するたびに設定されますが、変更または未設定にすることができます。</target>
        </trans-unit>
        <trans-unit id="0deea51724bf6c34acfe1425e13fc10373b6c41e" translate="yes" xml:space="preserve">
          <source>The current dimensions of any array value can be retrieved with the &lt;code&gt;array_dims&lt;/code&gt; function:</source>
          <target state="translated">任意の配列値の現在の次元は、 &lt;code&gt;array_dims&lt;/code&gt; 関数で取得できます。</target>
        </trans-unit>
        <trans-unit id="8c3a8302b74a0c1c2418c7953403859316142fae" translate="yes" xml:space="preserve">
          <source>The current effective value of the search path can be examined via the SQL function &lt;code&gt;current_schemas&lt;/code&gt; (see &lt;a href=&quot;functions-info&quot;&gt;Section 9.25&lt;/a&gt;). This is not quite the same as examining the value of &lt;code&gt;search_path&lt;/code&gt;, since &lt;code&gt;current_schemas&lt;/code&gt; shows how the items appearing in &lt;code&gt;search_path&lt;/code&gt; were resolved.</source>
          <target state="translated">検索パスの現在の有効値は、SQL関数 &lt;code&gt;current_schemas&lt;/code&gt; を使用して調べることができます（&lt;a href=&quot;functions-info&quot;&gt;セクション9.25を&lt;/a&gt;参照）。 &lt;code&gt;current_schemas&lt;/code&gt; は &lt;code&gt;search_path&lt;/code&gt; に現れる項目がどのように解決されたかを示すので、これは &lt;code&gt;search_path&lt;/code&gt; の値を調べることとはまったく同じではありません。</target>
        </trans-unit>
        <trans-unit id="588306ac744664bcce2285f16a927597e5d43ed4" translate="yes" xml:space="preserve">
          <source>The current implementation does not enforce the declared number of dimensions either. Arrays of a particular element type are all considered to be of the same type, regardless of size or number of dimensions. So, declaring the array size or number of dimensions in &lt;code&gt;CREATE TABLE&lt;/code&gt; is simply documentation; it does not affect run-time behavior.</source>
          <target state="translated">現在の実装では、宣言された次元数も強制されません。特定の要素タイプの配列は、サイズや次元数に関係なく、すべて同じタイプであると見なされます。そのため、 &lt;code&gt;CREATE TABLE&lt;/code&gt; で配列サイズまたは次元数を宣言することは、単なるドキュメントです。実行時の動作には影響しません。</target>
        </trans-unit>
        <trans-unit id="03a220364aef06c1bbc7f574a82ccaeced5bea27" translate="yes" xml:space="preserve">
          <source>The current implementation has significant limitations, and does not enforce mandatory access control for all actions. See &lt;a href=&quot;sepgsql#SEPGSQL-LIMITATIONS&quot;&gt;Section F.35.7&lt;/a&gt;.</source>
          <target state="translated">現在の実装には重大な制限があり、すべてのアクションに必須のアクセス制御を適用していません。&lt;a href=&quot;sepgsql#SEPGSQL-LIMITATIONS&quot;&gt;セクションF.35.7を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="25210d55190c9236b389899a74a7b5704fff78d4" translate="yes" xml:space="preserve">
          <source>The current implementation of &lt;code&gt;unaccent&lt;/code&gt; cannot be used as a normalizing dictionary for the &lt;code&gt;thesaurus&lt;/code&gt; dictionary.</source>
          <target state="translated">&lt;code&gt;unaccent&lt;/code&gt; の現在の実装は、 &lt;code&gt;thesaurus&lt;/code&gt; 辞書の正規化辞書として使用できません。</target>
        </trans-unit>
        <trans-unit id="ed96c59248b01f330729c6c44b2035a2f3097a16" translate="yes" xml:space="preserve">
          <source>The current limitations of PostgreSQL's text search features are:</source>
          <target state="translated">現在のPostgreSQLのテキスト検索機能の限界は、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="11ad6de9ae99189b133ed48695fe71e760901959" translate="yes" xml:space="preserve">
          <source>The cursor should be declared with the &lt;code&gt;SCROLL&lt;/code&gt; option if one intends to use any variants of &lt;code&gt;FETCH&lt;/code&gt; other than &lt;code&gt;FETCH NEXT&lt;/code&gt; or &lt;code&gt;FETCH FORWARD&lt;/code&gt; with a positive count. For simple queries PostgreSQL will allow backwards fetch from cursors not declared with &lt;code&gt;SCROLL&lt;/code&gt;, but this behavior is best not relied on. If the cursor is declared with &lt;code&gt;NO SCROLL&lt;/code&gt;, no backward fetches are allowed.</source>
          <target state="translated">カーソルを使用して宣言しなければならない &lt;code&gt;SCROLL&lt;/code&gt; の 1のいずれかのバリアントを使用しようとする場合のオプション &lt;code&gt;FETCH&lt;/code&gt; 以外の &lt;code&gt;FETCH NEXT&lt;/code&gt; または &lt;code&gt;FETCH FORWARD&lt;/code&gt; 正の数とします。単純なクエリの場合、PostgreSQLは &lt;code&gt;SCROLL&lt;/code&gt; で宣言されていないカーソルからの後方フェッチを許可しますが、この動作は依存しないのが最善です。カーソルが &lt;code&gt;NO SCROLL&lt;/code&gt; を指定して宣言されている場合、後方フェッチは許可されません。</target>
        </trans-unit>
        <trans-unit id="4f29dd59131cbd500833c5a80fec96f77393e7a4" translate="yes" xml:space="preserve">
          <source>The data distribution is very simple; there are only 100 distinct values in each column, uniformly distributed.</source>
          <target state="translated">データの分布は非常に単純で、各列には100個の異なる値が一様に分布しています。</target>
        </trans-unit>
        <trans-unit id="bf388f98f91dd65f88f15e7c3f1b408fc205654b" translate="yes" xml:space="preserve">
          <source>The data is prefixed with a block of random bytes. This is equivalent to using a random IV.</source>
          <target state="translated">データの前にはランダムバイトのブロックが付けられています。これは、ランダムIVを使用することに相当します。</target>
        </trans-unit>
        <trans-unit id="d53ba1352e33254f15d2784088350652d0fec89f" translate="yes" xml:space="preserve">
          <source>The data on the standby takes some time to arrive from the primary server so there will be a measurable delay between primary and standby. Running the same query nearly simultaneously on both primary and standby might therefore return differing results. We say that data on the standby is &lt;em&gt;eventually consistent&lt;/em&gt; with the primary. Once the commit record for a transaction is replayed on the standby, the changes made by that transaction will be visible to any new snapshots taken on the standby. Snapshots may be taken at the start of each query or at the start of each transaction, depending on the current transaction isolation level. For more details, see &lt;a href=&quot;transaction-iso&quot;&gt;Section 13.2&lt;/a&gt;.</source>
          <target state="translated">スタンバイのデータがプライマリサーバーから到着するまでに時間がかかるため、プライマリとスタンバイの間に測定可能な遅延が生じます。したがって、プライマリとスタンバイの両方で同じクエリをほぼ同時に実行すると、異なる結果が返される可能性があります。スタンバイ上のデータは、&lt;em&gt;最終的&lt;/em&gt;にはプライマリと&lt;em&gt;整合&lt;/em&gt;していると言えます。トランザクションのコミットレコードがスタンバイで再生されると、そのトランザクションによって行われた変更は、スタンバイで作成された新しいスナップショットに表示されます。現在のトランザクション分離レベルに応じて、各クエリの開始時または各トランザクションの開始時にスナップショットを取得できます。詳細については、&lt;a href=&quot;transaction-iso&quot;&gt;セクション13.2を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0b4139483f5abc1e06390b32222b164b98282561" translate="yes" xml:space="preserve">
          <source>The data section contains actual table data as well as large-object definitions. Post-data items consist of definitions of indexes, triggers, rules and constraints other than validated check constraints. Pre-data items consist of all other data definition items.</source>
          <target state="translated">データセクションには、実際のテーブルデータとラージオブジェクトの定義が含まれています。ポストデータ項目は、有効なチェック制約以外のインデックス、トリガ、ルール、制約の定義で構成されています。プレデータ項目は、他のすべてのデータ定義項目で構成されています。</target>
        </trans-unit>
        <trans-unit id="e6ca4b823a5f4163ec85e2bd3fdf29af04d8b385" translate="yes" xml:space="preserve">
          <source>The data section contains actual table data, large-object contents, and sequence values. Post-data items include definitions of indexes, triggers, rules, and constraints other than validated check constraints. Pre-data items include all other data definition items.</source>
          <target state="translated">データセクションには、実際のテーブルデータ、ラージオブジェクトの内容、シーケンス値が含まれます。ポストデータ項目には、有効なチェック制約以外のインデックス、トリガ、ルール、制約の定義が含まれます。プリデータ項目には、他のすべてのデータ定義項目が含まれます。</target>
        </trans-unit>
        <trans-unit id="b17b79d26641dd87ba0c23b6c9bc174faa3a8b61" translate="yes" xml:space="preserve">
          <source>The data type &lt;code&gt;uuid&lt;/code&gt; stores Universally Unique Identifiers (UUID) as defined by RFC 4122, ISO/IEC 9834-8:2005, and related standards. (Some systems refer to this data type as a globally unique identifier, or GUID, instead.) This identifier is a 128-bit quantity that is generated by an algorithm chosen to make it very unlikely that the same identifier will be generated by anyone else in the known universe using the same algorithm. Therefore, for distributed systems, these identifiers provide a better uniqueness guarantee than sequence generators, which are only unique within a single database.</source>
          <target state="translated">データ型 &lt;code&gt;uuid&lt;/code&gt; は、RFC 4122、ISO / IEC 9834-8：2005、および関連する標準で定義されているUniversally Unique Identifier（UUID）を格納します。 （一部のシステムでは、このデータ型をグローバル一意識別子（GUID）と呼びます。）この識別子は、同じ識別子が他の誰かによって生成される可能性を低くするように選択されたアルゴリズムによって生成される128ビットの数量です。同じアルゴリズムを使用して既知の宇宙で。したがって、分散システムの場合、これらの識別子は、単一のデータベース内でのみ一意であるシーケンスジェネレータよりも優れた一意性を保証します。</target>
        </trans-unit>
        <trans-unit id="9a349537e0ccabe90f0be4224865fb39a87fb38c" translate="yes" xml:space="preserve">
          <source>The data type actually stored in the index. Normally this is the same as the column data type, but some index methods (currently GiST, GIN and BRIN) allow it to be different. The &lt;code&gt;STORAGE&lt;/code&gt; clause must be omitted unless the index method allows a different type to be used. If the column &lt;code&gt;data_type&lt;/code&gt; is specified as &lt;code&gt;anyarray&lt;/code&gt;, the &lt;code&gt;storage_type&lt;/code&gt; can be declared as &lt;code&gt;anyelement&lt;/code&gt; to indicate that the index entries are members of the element type belonging to the actual array type that each particular index is created for.</source>
          <target state="translated">実際にインデックスに格納されるデータ型。通常、これは列のデータ型と同じですが、一部のインデックスメソッド（現在はGiST、GIN、およびBRIN）では、異なる値にすることができます。 &lt;code&gt;STORAGE&lt;/code&gt; のインデックスメソッドが異なるタイプを使用することができない限り、句を省略しなければなりません。列 &lt;code&gt;data_type&lt;/code&gt; が &lt;code&gt;anyarray&lt;/code&gt; として指定されている場合、 &lt;code&gt;storage_type&lt;/code&gt; を &lt;code&gt;anyelement&lt;/code&gt; として宣言して、インデックスエントリが、特定の各インデックスが作成される実際の配列タイプに属する要素タイプのメンバーであることを示すことができます。</target>
        </trans-unit>
        <trans-unit id="b3cf16533d2c33c2548b22d8bef5b9f8bd26fb43" translate="yes" xml:space="preserve">
          <source>The data type for the aggregate's state value, when using moving-aggregate mode.</source>
          <target state="translated">移動アグリゲートモードを使用している場合、アグリゲートの状態値のデータ型。</target>
        </trans-unit>
        <trans-unit id="450e47ffde369f976b7ab98b3a6e066768317211" translate="yes" xml:space="preserve">
          <source>The data type for the aggregate's state value.</source>
          <target state="translated">集約体の状態値のデータ型。</target>
        </trans-unit>
        <trans-unit id="a84accdb873accb8d045ec8f5d98450a1c8038e0" translate="yes" xml:space="preserve">
          <source>The data type of a function, procedure, or aggregate argument.</source>
          <target state="translated">関数、プロシージャ、または集合体の引数のデータ型。</target>
        </trans-unit>
        <trans-unit id="7678a7f2db2f20f82bdcd718575a886bbedb555c" translate="yes" xml:space="preserve">
          <source>The data type of a parameter to the prepared statement. If the data type of a particular parameter is unspecified or is specified as &lt;code&gt;unknown&lt;/code&gt;, it will be inferred from the context in which the parameter is first referenced. To refer to the parameters in the prepared statement itself, use &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc.</source>
          <target state="translated">準備済みステートメントへのパラメーターのデータ型。特定のパラメーターのデータ型が指定されてい &lt;code&gt;unknown&lt;/code&gt; 場合、またはunknownとして指定されている場合、パラメーターが最初に参照されたコンテキストから推測されます。準備されたステートメント自体のパラメーターを参照するには、 &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; などを使用します。</target>
        </trans-unit>
        <trans-unit id="97e7b1042480837c18e5146ff95fc1e9e9d4ce38" translate="yes" xml:space="preserve">
          <source>The data type of an output column in the &lt;code&gt;RETURNS TABLE&lt;/code&gt; syntax.</source>
          <target state="translated">&lt;code&gt;RETURNS TABLE&lt;/code&gt; 構文の出力列のデータ型。</target>
        </trans-unit>
        <trans-unit id="1f4da46a2e46ee99f93db576da8c6c70a740dbca" translate="yes" xml:space="preserve">
          <source>The data type of the attribute to add, or the new type of the attribute to alter.</source>
          <target state="translated">追加する属性のデータ型、または変更する属性の新しい型。</target>
        </trans-unit>
        <trans-unit id="643babd5ccd3dbc1eadd607ad51f52e3099e9220" translate="yes" xml:space="preserve">
          <source>The data type of the column. This can include array specifiers. For more information on the data types supported by PostgreSQL, refer to &lt;a href=&quot;datatype&quot;&gt;Chapter 8&lt;/a&gt;.</source>
          <target state="translated">列のデータ型。これには、配列指定子を含めることができます。PostgreSQLでサポートされているデータ型の詳細については、&lt;a href=&quot;datatype&quot;&gt;第8章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="00e2be0bf08b0f249705f534c771af62f659c534" translate="yes" xml:space="preserve">
          <source>The data type of the operator's left operand, if any. This option would be omitted for a left-unary operator.</source>
          <target state="translated">演算子の左オペランドがあれば、そのデータ型を指定します。左単項演算子の場合、このオプションは省略されます。</target>
        </trans-unit>
        <trans-unit id="3851b291352047da5cb8dab5436b1049af2b810b" translate="yes" xml:space="preserve">
          <source>The data type of the operator's left operand; write &lt;code&gt;NONE&lt;/code&gt; if the operator has no left operand.</source>
          <target state="translated">演算子の左オペランドのデータ型。演算子に左オペランドがない場合は、 &lt;code&gt;NONE&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="ccbd8cc94b9c8b592bbe8864eb6cc7e34df08235" translate="yes" xml:space="preserve">
          <source>The data type of the operator's right operand, if any. This option would be omitted for a right-unary operator.</source>
          <target state="translated">演算子の右オペランドがあれば、そのデータ型を指定します。このオプションは、右単項演算子の場合は省略されます。</target>
        </trans-unit>
        <trans-unit id="977b80839dcec0a264635f6fae2341cd4abe466d" translate="yes" xml:space="preserve">
          <source>The data type of the operator's right operand; write &lt;code&gt;NONE&lt;/code&gt; if the operator has no right operand.</source>
          <target state="translated">演算子の右側のオペランドのデータ型。演算子に右オペランドがない場合は、 &lt;code&gt;NONE&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="d1e6d9a6627f0f8541d4b2888407afff0ea3591c" translate="yes" xml:space="preserve">
          <source>The data type of this column</source>
          <target state="translated">この列のデータ型</target>
        </trans-unit>
        <trans-unit id="536b65adfc0c23a20e0043a6c217a813568358a2" translate="yes" xml:space="preserve">
          <source>The data type(s) of the function's arguments (optionally schema-qualified), if any.</source>
          <target state="translated">関数の引数のデータ型 (スキーマ修飾されたものがある場合は、オプションでスキーマ修飾されたもの)。</target>
        </trans-unit>
        <trans-unit id="c1899d531f40a6d2bc934ee7a1bdb436b5b33cc2" translate="yes" xml:space="preserve">
          <source>The data type(s) of the function's arguments (optionally schema-qualified), if any. The argument types can be base, composite, or domain types, or can reference the type of a table column.</source>
          <target state="translated">関数の引数のデータ型(スキーマ修飾されている場合は、オプションでスキーマ修飾されている)。引数の型は、ベース型、複合型、ドメイン型、またはテーブルカラムの型を参照することができます。</target>
        </trans-unit>
        <trans-unit id="0fa26cbbebcfa5ffa72e0fb66013b91729e1dbea" translate="yes" xml:space="preserve">
          <source>The data type(s) of the operator's arguments (optionally schema-qualified). Write &lt;code&gt;NONE&lt;/code&gt; for the missing argument of a prefix or postfix operator.</source>
          <target state="translated">オペレーターの引数のデータ型（オプションでスキーマ修飾）。前置演算子または後置演算子の欠落している引数に &lt;code&gt;NONE&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="f78d5722d424ec9c1eb5a72c627a144311353db1" translate="yes" xml:space="preserve">
          <source>The data type(s) of the procedure's arguments (optionally schema-qualified), if any.</source>
          <target state="translated">プロシージャの引数のデータ型(スキーマ修飾されている場合には、オプションでスキーマ修飾されている場合もあります)。</target>
        </trans-unit>
        <trans-unit id="cc4ed7c8f0edb91ee3802c9f1cbfdfe5d88cd95f" translate="yes" xml:space="preserve">
          <source>The data type(s) of the procedure's arguments (optionally schema-qualified), if any. The argument types can be base, composite, or domain types, or can reference the type of a table column.</source>
          <target state="translated">プロシージャの引数のデータ型(スキーマ修飾されている場合は、オプションでスキーマ修飾されています)。引数の型は、ベース型、複合型、ドメイン型、またはテーブルカラムの型を参照することができます。</target>
        </trans-unit>
        <trans-unit id="b13b1cfa55ac5025cb1667821c336a02f9958dc9" translate="yes" xml:space="preserve">
          <source>The data types &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; are inexact, variable-precision numeric types. On all currently supported platforms, these types are implementations of IEEE Standard 754 for Binary Floating-Point Arithmetic (single and double precision, respectively), to the extent that the underlying processor, operating system, and compiler support it.</source>
          <target state="translated">&lt;code&gt;real&lt;/code&gt; および &lt;code&gt;double precision&lt;/code&gt; のデータ型は、不正確な可変精度数値型です。現在サポートされているすべてのプラットフォームで、これらの型は、基になるプロセッサ、オペレーティングシステム、およびコンパイラがサポートする範囲で、2進浮動小数点演算（それぞれ単精度および倍精度）のIEEE標準754の実装です。</target>
        </trans-unit>
        <trans-unit id="95cc47952f3a5e2e5bea18ece63744adf6f3d52b" translate="yes" xml:space="preserve">
          <source>The data types &lt;code&gt;smallserial&lt;/code&gt;, &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;bigserial&lt;/code&gt; are not true types, but merely a notational convenience for creating unique identifier columns (similar to the &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; property supported by some other databases). In the current implementation, specifying:</source>
          <target state="translated">&lt;code&gt;smallserial&lt;/code&gt; 、 &lt;code&gt;serial&lt;/code&gt; 、および &lt;code&gt;bigserial&lt;/code&gt; のデータ型は真の型ではなく、一意の識別子列を作成するための表記上の便宜にすぎません（他のデータベースでサポートされている &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; プロパティと同様）。現在の実装では、以下を指定します：</target>
        </trans-unit>
        <trans-unit id="c1d4cee11581ccf46822d30574cc04ac170d447c" translate="yes" xml:space="preserve">
          <source>The data types of all the &lt;code&gt;result&lt;/code&gt; expressions must be convertible to a single output type. See &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt; for more details.</source>
          <target state="translated">すべての &lt;code&gt;result&lt;/code&gt; 式のデータ型は、単一の出力型に変換できる必要があります。詳細については、&lt;a href=&quot;typeconv-union-case&quot;&gt;セクション10.5&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="833950eaad4f091a792f16ed765cff996e89f49e" translate="yes" xml:space="preserve">
          <source>The data values are listed in the order in which the columns appear in the table, separated by commas. Usually, the data values will be literals (constants), but scalar expressions are also allowed.</source>
          <target state="translated">データ値は、カンマで区切られた表の列が現れる順にリストアップされています。通常、データ値はリテラル(定数)となりますが、スカラー表現も可能です。</target>
        </trans-unit>
        <trans-unit id="511f74682fefbedf40676929009d5d52bb81a56d" translate="yes" xml:space="preserve">
          <source>The data values are mapped in the same way as described for the function &lt;code&gt;xmlelement&lt;/code&gt; above.</source>
          <target state="translated">データ値は、上記の関数 &lt;code&gt;xmlelement&lt;/code&gt; で説明したのと同じ方法でマッピングされます。</target>
        </trans-unit>
        <trans-unit id="b3854c2d1d8f8304933b603d0d2fef62ed88a35f" translate="yes" xml:space="preserve">
          <source>The database activity of pg_dump is normally collected by the statistics collector. If this is undesirable, you can set parameter &lt;code&gt;track_counts&lt;/code&gt; to false via &lt;code&gt;PGOPTIONS&lt;/code&gt; or the &lt;code&gt;ALTER USER&lt;/code&gt; command.</source>
          <target state="translated">pg_dumpのデータベースアクティビティは、通常、統計コレクターによって収集されます。これが望ましくない場合は、 &lt;code&gt;PGOPTIONS&lt;/code&gt; または &lt;code&gt;ALTER USER&lt;/code&gt; コマンドを使用して、パラメーター &lt;code&gt;track_counts&lt;/code&gt; をfalseに設定できます。</target>
        </trans-unit>
        <trans-unit id="e78726feeb2c4690a432f23c59d13fb4ceea2509" translate="yes" xml:space="preserve">
          <source>The database named in the &lt;code&gt;-d&lt;/code&gt; switch can be any database existing in the cluster; pg_restore only uses it to issue the &lt;code&gt;CREATE DATABASE&lt;/code&gt; command for &lt;code&gt;mydb&lt;/code&gt;. With &lt;code&gt;-C&lt;/code&gt;, data is always restored into the database name that appears in the dump file.</source>
          <target state="translated">で指定されたデータベース &lt;code&gt;-d&lt;/code&gt; スイッチは、クラスタ内の既存の任意のデータベースにすることができます。pg_restoreは、 &lt;code&gt;mydb&lt;/code&gt; に対して &lt;code&gt;CREATE DATABASE&lt;/code&gt; コマンドを発行するためにのみ使用します。では &lt;code&gt;-C&lt;/code&gt; 、データは常にダンプ・ファイルに記述された名前のデータベースに復元されます。</target>
        </trans-unit>
        <trans-unit id="a7217998725cfcd7339a40affa714dc41a9f7779" translate="yes" xml:space="preserve">
          <source>The database schema and DDL commands are not replicated. The initial schema can be copied by hand using &lt;code&gt;pg_dump --schema-only&lt;/code&gt;. Subsequent schema changes would need to be kept in sync manually. (Note, however, that there is no need for the schemas to be absolutely the same on both sides.) Logical replication is robust when schema definitions change in a live database: When the schema is changed on the publisher and replicated data starts arriving at the subscriber but does not fit into the table schema, replication will error until the schema is updated. In many cases, intermittent errors can be avoided by applying additive schema changes to the subscriber first.</source>
          <target state="translated">データベーススキーマとDDLコマンドは複製されません。初期スキーマは &lt;code&gt;pg_dump --schema-only&lt;/code&gt; を使用して手動でコピーできます。その後のスキーマ変更は、手動で同期を保つ必要があります。 （ただし、スキーマが両側で完全に同じである必要はないことに注意してください。）ライブデータベースでスキーマ定義が変更された場合、論理レプリケーションは堅牢です。パブリッシャーでスキーマが変更され、複製されたデータが到着し始めたときサブスクライバーがテーブルスキーマに適合しない場合、スキーマが更新されるまでレプリケーションはエラーになります。多くの場合、最初にサブスクライバーに追加のスキーマ変更を適用することにより、断続的なエラーを回避できます。</target>
        </trans-unit>
        <trans-unit id="7126248724d0590ca70b478abc60308b632b1141" translate="yes" xml:space="preserve">
          <source>The database server &lt;em&gt;must&lt;/em&gt; be shut down in order to get a usable backup. Half-way measures such as disallowing all connections will &lt;em&gt;not&lt;/em&gt; work (in part because &lt;code&gt;tar&lt;/code&gt; and similar tools do not take an atomic snapshot of the state of the file system, but also because of internal buffering within the server). Information about stopping the server can be found in &lt;a href=&quot;server-shutdown&quot;&gt;Section 18.5&lt;/a&gt;. Needless to say, you also need to shut down the server before restoring the data.</source>
          <target state="translated">使用可能なバックアップを取得するには、データベースサーバーをシャットダウンする&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。すべての接続を許可しないなどの中間的な対策は機能し&lt;em&gt;ません&lt;/em&gt;（ &lt;code&gt;tar&lt;/code&gt; や類似のツールがファイルシステムの状態のアトミックスナップショットを取得しないため、サーバー内の内部バッファリングも原因です）。サーバーの停止に関する情報は&lt;a href=&quot;server-shutdown&quot;&gt;項18.5にあり&lt;/a&gt;ます。言うまでもなく、データを復元する前にサーバーをシャットダウンする必要もあります。</target>
        </trans-unit>
        <trans-unit id="c8210278fffa651db73498b44685083caea4837b" translate="yes" xml:space="preserve">
          <source>The database server host you are currently connected to. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">現在接続しているデータベースサーバーのホスト。これは、データベースに接続するたびに(プログラムの起動を含む)設定されますが、変更または解除することができます。</target>
        </trans-unit>
        <trans-unit id="4225ad89a733947e3891f6391650e080a1af4ac1" translate="yes" xml:space="preserve">
          <source>The database server port to which you are currently connected. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">現在接続しているデータベースサーバーのポート。これは、データベースに接続するたびに(プログラムの起動を含めて)設定されますが、変更したり、設定を解除したりすることができます。</target>
        </trans-unit>
        <trans-unit id="cc0f8108abc644f84f0071b412b2512b78ad2132" translate="yes" xml:space="preserve">
          <source>The database server's host name</source>
          <target state="translated">データベースサーバのホスト名</target>
        </trans-unit>
        <trans-unit id="a4b3d744975ee6b60121119bc335e231f7de4513" translate="yes" xml:space="preserve">
          <source>The database server's port number</source>
          <target state="translated">データベースサーバのポート番号</target>
        </trans-unit>
        <trans-unit id="cfe5c0809041f0c5dee1fdfbdf2f909905d7bde5" translate="yes" xml:space="preserve">
          <source>The database session user name. (The expansion of this value might change during a database session as the result of the command &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt;.)</source>
          <target state="translated">データベースセッションのユーザー名。（この値の拡張は、 &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; コマンドの結果として、データベースセッション中に変更される場合があります。）</target>
        </trans-unit>
        <trans-unit id="8854074f0a9f2884a73fba5bef5522aadc8c6fe8" translate="yes" xml:space="preserve">
          <source>The database to connect to. See the description of the actions for what this means in detail. This can be a libpq connection string; see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt; for more information. Defaults to user name.</source>
          <target state="translated">接続するデータベース。詳しくは、アクションの説明をご覧ください。これはlibpq接続文字列にすることができます。詳細は&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;項33.1.1&lt;/a&gt;を参照してください。デフォルトはユーザー名です。</target>
        </trans-unit>
        <trans-unit id="8142c603a5c381a14fdd730098342401f6c26eea" translate="yes" xml:space="preserve">
          <source>The database user you are currently connected as. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">現在接続しているデータベースユーザー。これは、データベースに接続するたびに(プログラムの起動を含めて)設定されますが、変更したり、設定を解除したりすることができます。</target>
        </trans-unit>
        <trans-unit id="b630a685a9f1e8cf73c559db8e767d96cc4b9662" translate="yes" xml:space="preserve">
          <source>The database you are trying to connect to does not exist. Note that if you do not specify a database name, it defaults to the database user name, which might or might not be the right thing.</source>
          <target state="translated">接続しようとしているデータベースが存在しません。データベース名を指定しないと、データベースのユーザー名がデフォルトで使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="fee1a6c055e42f40e71b91d8726649529647f66d" translate="yes" xml:space="preserve">
          <source>The datatype input function for type &lt;code&gt;boolean&lt;/code&gt; accepts these string representations for the &amp;ldquo;true&amp;rdquo; state:</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 型のデータ型入力関数は、「true」状態の次の文字列表現を受け入れます。</target>
        </trans-unit>
        <trans-unit id="ae4a7ff4b226f1bae5a99aaa421f3e1ec4a71979" translate="yes" xml:space="preserve">
          <source>The datatype output function for type &lt;code&gt;boolean&lt;/code&gt; always emits either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;f&lt;/code&gt;, as shown in &lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-EXAMPLE&quot;&gt;Example 8.2&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-EXAMPLE&quot;&gt;例8.2に&lt;/a&gt;示すように、 &lt;code&gt;boolean&lt;/code&gt; 型のデータ型出力関数は常に &lt;code&gt;t&lt;/code&gt; または &lt;code&gt;f&lt;/code&gt; のいずれかを発行します。</target>
        </trans-unit>
        <trans-unit id="7cfcef52fd742ca2a7d47081e6367dac502e36ab" translate="yes" xml:space="preserve">
          <source>The date/time style can be selected by the user using the &lt;code&gt;SET datestyle&lt;/code&gt; command, the &lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt; parameter in the &lt;code&gt;postgresql.conf&lt;/code&gt; configuration file, or the &lt;code&gt;PGDATESTYLE&lt;/code&gt; environment variable on the server or client.</source>
          <target state="translated">日付/時刻スタイルは、 &lt;code&gt;SET datestyle&lt;/code&gt; コマンド、 &lt;code&gt;postgresql.conf&lt;/code&gt; 構成ファイルの&lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt;パラメータ、またはサーバーまたはクライアントの &lt;code&gt;PGDATESTYLE&lt;/code&gt; 環境変数を使用して、ユーザーが選択できます。</target>
        </trans-unit>
        <trans-unit id="5d764ba10f260d8d4e8bfcd3a741fca678bd1d96" translate="yes" xml:space="preserve">
          <source>The day of the week as Monday (&lt;code&gt;1&lt;/code&gt;) to Sunday (&lt;code&gt;7&lt;/code&gt;)</source>
          <target state="translated">月曜日（ &lt;code&gt;1&lt;/code&gt; ）から日曜日（ &lt;code&gt;7&lt;/code&gt; ）までの曜日</target>
        </trans-unit>
        <trans-unit id="a891efc073ada13a5907f18625fe5fde82907c09" translate="yes" xml:space="preserve">
          <source>The day of the week as Sunday (&lt;code&gt;0&lt;/code&gt;) to Saturday (&lt;code&gt;6&lt;/code&gt;)</source>
          <target state="translated">日曜日（ &lt;code&gt;0&lt;/code&gt; ）から土曜日（ &lt;code&gt;6&lt;/code&gt; ）までの曜日</target>
        </trans-unit>
        <trans-unit id="9ca4eefed78bdde53eebbe05d44c2b02c01e2924" translate="yes" xml:space="preserve">
          <source>The day of the year (1 - 365/366)</source>
          <target state="translated">年の日(1~365/366)にちなんで</target>
        </trans-unit>
        <trans-unit id="d4a9223278a724eaae749c9ac28592e80acca20f" translate="yes" xml:space="preserve">
          <source>The decrypted data and the decryption key are present on the server for a brief time while it is being decrypted and communicated between the client and server. This presents a brief moment where the data and keys can be intercepted by someone with complete access to the database server, such as the system administrator.</source>
          <target state="translated">復号化されたデータと復号化キーは、クライアントとサーバの間で復号化されて通信されている間、短時間だけサーバ上に存在します。これは、システム管理者のようなデータベースサーバへの完全なアクセス権を持つ者が、データと鍵を傍受することができる短い時間を示しています。</target>
        </trans-unit>
        <trans-unit id="164046e431b6ca84db93b57b79867c4791c090cf" translate="yes" xml:space="preserve">
          <source>The default (and recommended) setting of &lt;a href=&quot;runtime-config-query#GUC-CONSTRAINT-EXCLUSION&quot;&gt;constraint_exclusion&lt;/a&gt; is neither &lt;code&gt;on&lt;/code&gt; nor &lt;code&gt;off&lt;/code&gt;, but an intermediate setting called &lt;code&gt;partition&lt;/code&gt;, which causes the technique to be applied only to queries that are likely to be working on inheritance partitioned tables. The &lt;code&gt;on&lt;/code&gt; setting causes the planner to examine &lt;code&gt;CHECK&lt;/code&gt; constraints in all queries, even simple ones that are unlikely to benefit.</source>
          <target state="translated">デフォルト設定（および推奨）&lt;a href=&quot;runtime-config-query#GUC-CONSTRAINT-EXCLUSION&quot;&gt;constraint_exclusionのは&lt;/a&gt;どちらもありません &lt;code&gt;on&lt;/code&gt; も &lt;code&gt;off&lt;/code&gt; 、しかしと呼ばれる中間設定 &lt;code&gt;partition&lt;/code&gt; 技術を引き起こし、唯一の継承は、テーブルをパーティションで作業する可能性があるクエリに適用されます。 &lt;code&gt;on&lt;/code&gt; 設定では、検討するプランナー原因 &lt;code&gt;CHECK&lt;/code&gt; すべてのクエリ内の制約、利益のためにそうであっても簡単なもの。</target>
        </trans-unit>
        <trans-unit id="1787e7e5cf03a442dbbaaa1d6af68edf6096b6e2" translate="yes" xml:space="preserve">
          <source>The default GIN operator class for &lt;code&gt;jsonb&lt;/code&gt; supports queries with top-level key-exists operators &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;?&amp;amp;&lt;/code&gt; and &lt;code&gt;?|&lt;/code&gt; operators and path/value-exists operator &lt;code&gt;@&amp;gt;&lt;/code&gt;. (For details of the semantics that these operators implement, see &lt;a href=&quot;functions-json#FUNCTIONS-JSONB-OP-TABLE&quot;&gt;Table 9.45&lt;/a&gt;.) An example of creating an index with this operator class is:</source>
          <target state="translated">&lt;code&gt;jsonb&lt;/code&gt; のデフォルトのGIN演算子クラスは、最上位のキー存在演算子を使用したクエリをサポートし &lt;code&gt;?&lt;/code&gt; 、 &lt;code&gt;?&amp;amp;&lt;/code&gt; および &lt;code&gt;?|&lt;/code&gt; 演算子とpath / value-exists演算子 &lt;code&gt;@&amp;gt;&lt;/code&gt; 。（これらの演算子が実装するセマンティクスの詳細については、&lt;a href=&quot;functions-json#FUNCTIONS-JSONB-OP-TABLE&quot;&gt;表9.45を&lt;/a&gt;参照してください。）この演算子クラスでインデックスを作成する例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="2eb60f012e323a27dd228ff40f13cdf0f9d72cff" translate="yes" xml:space="preserve">
          <source>The default IPC settings can be changed using the &lt;code&gt;sysctl&lt;/code&gt; or &lt;code&gt;loader&lt;/code&gt; interfaces. The following parameters can be set using &lt;code&gt;sysctl&lt;/code&gt;:</source>
          <target state="translated">デフォルトのIPC設定は、 &lt;code&gt;sysctl&lt;/code&gt; または &lt;code&gt;loader&lt;/code&gt; インターフェースを使用して変更できます。次のパラメータは、 &lt;code&gt;sysctl&lt;/code&gt; を使用して設定できます。</target>
        </trans-unit>
        <trans-unit id="0939858e47c24e25aea8221bd11aa7efd06e7d2d" translate="yes" xml:space="preserve">
          <source>The default TPC-B-like transaction test requires specific tables to be set up beforehand. pgbench should be invoked with the &lt;code&gt;-i&lt;/code&gt; (initialize) option to create and populate these tables. (When you are testing a custom script, you don't need this step, but will instead need to do whatever setup your test needs.) Initialization looks like:</source>
          <target state="translated">デフォルトのTPC-Bのようなトランザクションテストでは、事前に特定のテーブルを設定する必要があります。pgbenchは &lt;code&gt;-i&lt;/code&gt; （初期化）オプションを指定して起動し、これらのテーブルを作成してデータを入力する必要があります。（カスタムスクリプトをテストする場合、この手順は必要ありませんが、テストに必要なセットアップをすべて行う必要があります。）初期化は次のようになります。</target>
        </trans-unit>
        <trans-unit id="1cd3fc8c960efc439298488cea62fca507ea8c64" translate="yes" xml:space="preserve">
          <source>The default behavior for huge pages in PostgreSQL is to use them when possible and to fall back to normal pages when failing. To enforce the use of huge pages, you can set &lt;a href=&quot;runtime-config-resource#GUC-HUGE-PAGES&quot;&gt;huge_pages&lt;/a&gt; to &lt;code&gt;on&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. Note that with this setting PostgreSQL will fail to start if not enough huge pages are available.</source>
          <target state="translated">PostgreSQLの巨大なページのデフォルトの動作は、可能な場合はそれらを使用し、失敗した場合は通常のページにフォールバックすることです。巨大ページの使用を強制する &lt;code&gt;on&lt;/code&gt; は、 &lt;code&gt;postgresql.conf&lt;/code&gt; で&lt;a href=&quot;runtime-config-resource#GUC-HUGE-PAGES&quot;&gt;huge_pages&lt;/a&gt;をonに設定します。この設定では、十分な巨大ページが利用できない場合、PostgreSQLは起動に失敗することに注意してください。</target>
        </trans-unit>
        <trans-unit id="aaa5ded69b6418f38f6ec7a4670e3b4d29f7971b" translate="yes" xml:space="preserve">
          <source>The default behavior of recovery is to recover along the same timeline that was current when the base backup was taken. If you wish to recover into some child timeline (that is, you want to return to some state that was itself generated after a recovery attempt), you need to specify the target timeline ID in &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-TIMELINE&quot;&gt;recovery_target_timeline&lt;/a&gt;. You cannot recover into timelines that branched off earlier than the base backup.</source>
          <target state="translated">リカバリのデフォルトの動作は、ベースバックアップが作成されたときと同じタイムラインに沿ってリカバリすることです。あなたには、いくつかの子タイムライン（つまり、あなたは、それ自体が、回復の試みの後に生成されたいくつかの状態に戻したい）に回復したい場合は、ターゲットタイムラインのIDを指定する必要が&lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-TIMELINE&quot;&gt;recovery_target_timeline&lt;/a&gt;。ベースバックアップより前に分岐したタイムラインにリカバリすることはできません。</target>
        </trans-unit>
        <trans-unit id="3a7ad1055953cf587ab781a3bc1fc4c9129cc265" translate="yes" xml:space="preserve">
          <source>The default built-in transaction script (also invoked with &lt;code&gt;-b tpcb-like&lt;/code&gt;) issues seven commands per transaction over randomly chosen &lt;code&gt;aid&lt;/code&gt;, &lt;code&gt;tid&lt;/code&gt;, &lt;code&gt;bid&lt;/code&gt; and &lt;code&gt;delta&lt;/code&gt;. The scenario is inspired by the TPC-B benchmark, but is not actually TPC-B, hence the name.</source>
          <target state="translated">デフォルトの組み込みトランザクションスクリプト（これも &lt;code&gt;-b tpcb-like&lt;/code&gt; で呼び出されます）は、ランダムに選択された &lt;code&gt;aid&lt;/code&gt; 、 &lt;code&gt;tid&lt;/code&gt; 、 &lt;code&gt;bid&lt;/code&gt; および &lt;code&gt;delta&lt;/code&gt; に対してトランザクションごとに7つのコマンドを発行します。このシナリオはTPC-Bベンチマークに触発されていますが、実際にはTPC-Bではないため、この名前が付けられています。</target>
        </trans-unit>
        <trans-unit id="23125fde28fb9f59764dcf1b23a280a89053eb88" translate="yes" xml:space="preserve">
          <source>The default database privilege system allows database superusers to modify system catalogs using DML commands, and reference or modify toast tables. These operations are prohibited when &lt;code&gt;sepgsql&lt;/code&gt; is enabled.</source>
          <target state="translated">デフォルトのデータベース権限システムでは、データベーススーパーユーザーがDMLコマンドを使用してシステムカタログを変更したり、トーストテーブルを参照または変更したりできます。 &lt;code&gt;sepgsql&lt;/code&gt; が有効な場合、これらの操作は禁止されています。</target>
        </trans-unit>
        <trans-unit id="bc78e0117d012c08a955c11c85e0b86286d746a5" translate="yes" xml:space="preserve">
          <source>The default expression will be used in any insert operation that does not specify a value for the column. If a default value is defined for a particular column, it overrides any default associated with the domain. In turn, the domain default overrides any default value associated with the underlying data type.</source>
          <target state="translated">デフォルト式は、列の値を指定しない挿入操作で使用されます。デフォルト値が特定の列に定義されている場合、ドメインに関連付けられているすべてのデフォルト値が上書きされます。また、ドメインのデフォルトは、基礎となるデータ型に関連付けられているすべてのデフォルト値を上書きします。</target>
        </trans-unit>
        <trans-unit id="e924dec24aeaf46efa87502acfc94f6cc77685ce" translate="yes" xml:space="preserve">
          <source>The default expression will be used in any insert operation that does not specify a value for the column. If there is no default for a column, then the default is null.</source>
          <target state="translated">カラムの値を指定しない挿入操作では、デフォルト式が使用されます。カラムにデフォルトがない場合、デフォルトはnullとなります。</target>
        </trans-unit>
        <trans-unit id="5c475e2d48f46531de3913f26ad3045b4e6daa74" translate="yes" xml:space="preserve">
          <source>The default framing option is &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt;, which is the same as &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt;. With &lt;code&gt;ORDER BY&lt;/code&gt;, this sets the frame to be all rows from the partition start up through the current row's last &lt;code&gt;ORDER BY&lt;/code&gt; peer. Without &lt;code&gt;ORDER BY&lt;/code&gt;, this means all rows of the partition are included in the window frame, since all rows become peers of the current row.</source>
          <target state="translated">デフォルトのフレーミングオプションは &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt; で、これは &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt; と同じです。 &lt;code&gt;ORDER BY&lt;/code&gt; では、これにより、フレームは、パーティションの開始から現在の行の最後の &lt;code&gt;ORDER BY&lt;/code&gt; ピアまでのすべての行になるように設定されます。 &lt;code&gt;ORDER BY&lt;/code&gt; がない場合、すべての行が現在の行のピアになるため、パーティションのすべての行がウィンドウフレームに含まれます。</target>
        </trans-unit>
        <trans-unit id="ab9ba2008544bbedbbd493b6d70ae946d72bc7ec" translate="yes" xml:space="preserve">
          <source>The default framing option is &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt;, which is the same as &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt;; it sets the frame to be all rows from the partition start up through the current row's last &lt;em&gt;peer&lt;/em&gt; (a row that the window's &lt;code&gt;ORDER BY&lt;/code&gt; clause considers equivalent to the current row; all rows are peers if there is no &lt;code&gt;ORDER BY&lt;/code&gt;). In general, &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; means that the frame starts with the first row of the partition, and similarly &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; means that the frame ends with the last row of the partition, regardless of &lt;code&gt;RANGE&lt;/code&gt;, &lt;code&gt;ROWS&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode. In &lt;code&gt;ROWS&lt;/code&gt; mode, &lt;code&gt;CURRENT ROW&lt;/code&gt; means that the frame starts or ends with the current row; but in &lt;code&gt;RANGE&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode it means that the frame starts or ends with the current row's first or last peer in the &lt;code&gt;ORDER BY&lt;/code&gt; ordering. The &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;PRECEDING&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;FOLLOWING&lt;/code&gt; options vary in meaning depending on the frame mode. In &lt;code&gt;ROWS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; is an integer indicating that the frame starts or ends that many rows before or after the current row. In &lt;code&gt;GROUPS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; is an integer indicating that the frame starts or ends that many peer groups before or after the current row's peer group, where a &lt;em&gt;peer group&lt;/em&gt; is a group of rows that are equivalent according to the window's &lt;code&gt;ORDER BY&lt;/code&gt; clause. In &lt;code&gt;RANGE&lt;/code&gt; mode, use of an &lt;code&gt;offset&lt;/code&gt; option requires that there be exactly one &lt;code&gt;ORDER BY&lt;/code&gt; column in the window definition. Then the frame contains those rows whose ordering column value is no more than &lt;code&gt;offset&lt;/code&gt; less than (for &lt;code&gt;PRECEDING&lt;/code&gt;) or more than (for &lt;code&gt;FOLLOWING&lt;/code&gt;) the current row's ordering column value. In these cases the data type of the &lt;code&gt;offset&lt;/code&gt; expression depends on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an &lt;code&gt;interval&lt;/code&gt;. In all these cases, the value of the &lt;code&gt;offset&lt;/code&gt; must be non-null and non-negative. Also, while the &lt;code&gt;offset&lt;/code&gt; does not have to be a simple constant, it cannot contain variables, aggregate functions, or window functions.</source>
          <target state="translated">デフォルトのフレーミングオプションは &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt; で、これは &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt; と同じです。フレームを、パーティションの開始から現在の行の最後の&lt;em&gt;ピア&lt;/em&gt;（ウィンドウの &lt;code&gt;ORDER BY&lt;/code&gt; 句が現在の行と同等と見なす行）までのすべての行になるように設定します。すべての行は、 &lt;code&gt;ORDER BY&lt;/code&gt; がない場合はピアです。一般に、 &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; 手段フレームは、パーティションの最初の行から始まり、同様こと &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; の手段パーティションの最後の行とフレーム終了したこと、に関係なく &lt;code&gt;RANGE&lt;/code&gt; 、 &lt;code&gt;ROWS&lt;/code&gt; または &lt;code&gt;GROUPS&lt;/code&gt; モード。中 &lt;code&gt;ROWS&lt;/code&gt; モード、 &lt;code&gt;CURRENT ROW&lt;/code&gt; フレームが開始または現在の行で終わることを意味します。しかし、 &lt;code&gt;RANGE&lt;/code&gt; または &lt;code&gt;GROUPS&lt;/code&gt; モードでは、フレームは、 &lt;code&gt;ORDER BY&lt;/code&gt; 順序付けで現在の行の最初または最後のピアで開始または終了することを意味します。 &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;PRECEDING&lt;/code&gt; と &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;FOLLOWING&lt;/code&gt; オプションは、フレームモードによって意味が異なります。 &lt;code&gt;ROWS&lt;/code&gt; モード、 &lt;code&gt;offset&lt;/code&gt; そのフレームの開始または終了行数を現在の行の前または後にあることを示す整数です。 &lt;code&gt;GROUPS&lt;/code&gt; モード、 &lt;code&gt;offset&lt;/code&gt; フレームが現在の行のピアグループの前後にある多くのピアグループを開始または終了することを示す整数です。&lt;em&gt;ピアグループ&lt;/em&gt;は、ウィンドウの &lt;code&gt;ORDER BY&lt;/code&gt; 句に従って同等の行のグループです。では &lt;code&gt;RANGE&lt;/code&gt; のモードの使用 &lt;code&gt;offset&lt;/code&gt; オプションは、1つの存在であることを要求 &lt;code&gt;ORDER BY&lt;/code&gt; ウィンドウ定義内の列。次に、フレームには、順序付け列の値が現在の行の順序付け列値の &lt;code&gt;offset&lt;/code&gt; （ &lt;code&gt;PRECEDING&lt;/code&gt; の場合）以下（ &lt;code&gt;FOLLOWING&lt;/code&gt; の場合）以下の行が含まれます。これらの場合、 &lt;code&gt;offset&lt;/code&gt; データ型式は、順序付けする列のデータ型によって異なります。数値の順序付け列の場合、これは通常、順序付け列と同じタイプですが、日時順序付け列の場合は &lt;code&gt;interval&lt;/code&gt; です。これらのすべてのケースで、 &lt;code&gt;offset&lt;/code&gt; の値はnullでなく、負でない必要があります。また、 &lt;code&gt;offset&lt;/code&gt; は単純な定数である必要はありませんが、変数、集約関数、またはウィンドウ関数を含めることはできません。</target>
        </trans-unit>
        <trans-unit id="585bb809ddf49c27ccd679a2aefbbe26ae6b7fc7" translate="yes" xml:space="preserve">
          <source>The default is 1 on supported systems, otherwise 0. This value can be overridden for tables in a particular tablespace by setting the tablespace parameter of the same name (see &lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACE&lt;/a&gt;).</source>
          <target state="translated">サポートされているシステムでは、デフォルトは1です。それ以外の場合は0です。この名前は、同じ名前のテーブルスペースパラメータを設定することにより、特定のテーブルスペース内のテーブルに対してオーバーライドできます（&lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACEを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="e91abeb434a6ce9f069e1f28ad61aa04fc26c2bb" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;+&lt;/code&gt; on Unix systems (corresponding to the default editor &lt;code&gt;vi&lt;/code&gt;, and useful for many other common editors); but there is no default on Windows systems.</source>
          <target state="translated">UNIXシステムでは、デフォルトは &lt;code&gt;+&lt;/code&gt; です（デフォルトのエディター &lt;code&gt;vi&lt;/code&gt; に対応し、他の多くの一般的なエディターで役立ちます）。ただし、Windowsシステムにはデフォルトはありません。</target>
        </trans-unit>
        <trans-unit id="20bd35f00ae043441f0cf7d67ea091592c87a851" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;CONTENT&lt;/code&gt;, so all forms of XML data are allowed.</source>
          <target state="translated">デフォルトは &lt;code&gt;CONTENT&lt;/code&gt; であるため、すべての形式のXMLデータが許可されます。</target>
        </trans-unit>
        <trans-unit id="520d36bf5a7163373f8a236d77b263a2c0a04d44" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;TLSv1&lt;/code&gt;, mainly to support older versions of the OpenSSL library. You might want to set this to a higher value if all software components can support the newer protocol versions.</source>
          <target state="translated">デフォルトは &lt;code&gt;TLSv1&lt;/code&gt; で、主に古いバージョンのOpenSSLライブラリをサポートします。すべてのソフトウェアコンポーネントが新しいプロトコルバージョンをサポートできる場合は、これをより高い値に設定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="231c42f70ffe5e8ab4244e5bdc8f6dbabaa3b107" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;none&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">デフォルトは &lt;code&gt;none&lt;/code&gt; です。この設定を変更できるのはスーパーユーザーだけです。</target>
        </trans-unit>
        <trans-unit id="bd107bd07370addfaeb12f86e3bf6c56137f5dc1" translate="yes" xml:space="preserve">
          <source>The default is simple query protocol. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;Chapter 52&lt;/a&gt; for more information.)</source>
          <target state="translated">デフォルトは単純なクエリプロトコルです。（詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;第52章を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="c6f72dd6acfbb83ab51b40e408e5dc009e36a5da" translate="yes" xml:space="preserve">
          <source>The default maximum segment size is 32 MB, and the default maximum total size is 2097152 pages. A page is almost always 4096 bytes except in unusual kernel configurations with &amp;ldquo;huge pages&amp;rdquo; (use &lt;code&gt;getconf PAGE_SIZE&lt;/code&gt; to verify).</source>
          <target state="translated">デフォルトの最大セグメントサイズは32 MBで、デフォルトの最大合計サイズは2097152ページです。「巨大なページ」を備えた異常なカーネル構成を除いて、ページはほとんど常に4096バイトです（確認するには &lt;code&gt;getconf PAGE_SIZE&lt;/code&gt; を使用してください）。</target>
        </trans-unit>
        <trans-unit id="d525664dcf3bd05b109fdf34118093a16b891bcb" translate="yes" xml:space="preserve">
          <source>The default permissions are &lt;code&gt;0600&lt;/code&gt;, meaning only the server owner can read or write the log files. The other commonly useful setting is &lt;code&gt;0640&lt;/code&gt;, allowing members of the owner's group to read the files. Note however that to make use of such a setting, you'll need to alter &lt;a href=&quot;runtime-config-logging#GUC-LOG-DIRECTORY&quot;&gt;log_directory&lt;/a&gt; to store the files somewhere outside the cluster data directory. In any case, it's unwise to make the log files world-readable, since they might contain sensitive data.</source>
          <target state="translated">デフォルトの権限は &lt;code&gt;0600&lt;/code&gt; です。つまり、サーバーの所有者だけがログファイルを読み書きできます。その他の一般的に役立つ設定は &lt;code&gt;0640&lt;/code&gt; で、所有者のグループのメンバーがファイルを読み取ることができます。ただし、このような設定を利用するには、&lt;a href=&quot;runtime-config-logging#GUC-LOG-DIRECTORY&quot;&gt;log_directory&lt;/a&gt;を変更して、ファイルをクラスターデータディレクトリの外部のどこかに格納する必要があることに注意してください。いずれにせよ、ログファイルには機密データが含まれている可能性があるため、ログファイルを誰でも読み取り可能にすることは賢明ではありません。</target>
        </trans-unit>
        <trans-unit id="d2132a47fb8ed97625d8e6972b86c9c464704580" translate="yes" xml:space="preserve">
          <source>The default permissions are &lt;code&gt;0777&lt;/code&gt;, meaning anyone can connect. Reasonable alternatives are &lt;code&gt;0770&lt;/code&gt; (only user and group, see also &lt;code&gt;unix_socket_group&lt;/code&gt;) and &lt;code&gt;0700&lt;/code&gt; (only user). (Note that for a Unix-domain socket, only write permission matters, so there is no point in setting or revoking read or execute permissions.)</source>
          <target state="translated">デフォルトの許可は &lt;code&gt;0777&lt;/code&gt; で、誰でも接続できることを意味します。 &lt;code&gt;unix_socket_group&lt;/code&gt; な代替手段は &lt;code&gt;0770&lt;/code&gt; （ユーザーとグループのみ、unix_socket_groupも参照）と &lt;code&gt;0700&lt;/code&gt; （ユーザーのみ）です。（Unixドメインソケットの場合、書き込み権限のみが重要であるため、読み取り権限または実行権限を設定または取り消す意味はありません。）</target>
        </trans-unit>
        <trans-unit id="68b85b4979bd5c75a82926a217579dec94acad6f" translate="yes" xml:space="preserve">
          <source>The default roles are described in &lt;a href=&quot;default-roles#DEFAULT-ROLES-TABLE&quot;&gt;Table 21.1&lt;/a&gt;. Note that the specific permissions for each of the default roles may change in the future as additional capabilities are added. Administrators should monitor the release notes for changes.</source>
          <target state="translated">デフォルトの役割を&lt;a href=&quot;default-roles#DEFAULT-ROLES-TABLE&quot;&gt;表21.1に示し&lt;/a&gt;ます。機能が追加されると、デフォルトの各役割の特定の権限が将来変更される可能性があることに注意してください。管理者は、リリースノートの変更を監視する必要があります。</target>
        </trans-unit>
        <trans-unit id="252df4a98d09d9259c2e1911dffde240009cf803" translate="yes" xml:space="preserve">
          <source>The default set of collations provided by &lt;code&gt;libc&lt;/code&gt; map directly to the locales installed in the operating system, which can be listed using the command &lt;code&gt;locale -a&lt;/code&gt;. In case a &lt;code&gt;libc&lt;/code&gt; collation is needed that has different values for &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;, or if new locales are installed in the operating system after the database system was initialized, then a new collation may be created using the &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt; command. New operating system locales can also be imported en masse using the &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-COLLATION&quot;&gt;&lt;code&gt;pg_import_system_collations()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;libc&lt;/code&gt; によって提供されるデフォルトの照合のセットは、オペレーティングシステムにインストールされているロケールに直接マップされ &lt;code&gt;locale -a&lt;/code&gt; 。ロケールは、コマンドlocale -aを使用してリストできます。場合 &lt;code&gt;libc&lt;/code&gt; の照合は、異なる値を有することが必要である &lt;code&gt;LC_COLLATE&lt;/code&gt; と &lt;code&gt;LC_CTYPE&lt;/code&gt; データベースシステムが初期化された後に新しいロケールがオペレーティングシステムにインストールされている場合、または、新しい照合を使用して作成することができる&lt;a href=&quot;sql-createcollation&quot;&gt;COLLATIONのCREATE&lt;/a&gt;コマンドを。新しいオペレーティングシステムロケールは、&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-COLLATION&quot;&gt; &lt;code&gt;pg_import_system_collations()&lt;/code&gt; &lt;/a&gt;関数を使用してまとめてインポートすることもできます。</target>
        </trans-unit>
        <trans-unit id="1fa3c32f18b7a363e1e30df22bf5f90a31fa97a8" translate="yes" xml:space="preserve">
          <source>The default settings tend to suffice for normal installations. On HP-UX 10, the factory default for &lt;code&gt;SEMMNS&lt;/code&gt; is 128, which might be too low for larger database sites.</source>
          <target state="translated">通常のインストールでは、デフォルト設定で十分です。HP-UX 10では、 &lt;code&gt;SEMMNS&lt;/code&gt; の工場出荷時のデフォルトは128ですが、大規模なデータベースサイトには低すぎる可能性があります。</target>
        </trans-unit>
        <trans-unit id="44e22ca1caa169ea01c4c21799c6c36ccb13234f" translate="yes" xml:space="preserve">
          <source>The default tablespace for the database. Within this database, all tables for which &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltablespace&lt;/code&gt; is zero will be stored in this tablespace; in particular, all the non-shared system catalogs will be there.</source>
          <target state="translated">データベースのデフォルトのテーブルスペース。このデータベース内で、 &lt;code&gt;pg_class&lt;/code&gt; のすべてのテーブル。 &lt;code&gt;reltablespace&lt;/code&gt; is zeroは、このテーブルスペースに格納されます。特に、すべての非共有システムカタログが存在します。</target>
        </trans-unit>
        <trans-unit id="80289ade38539d0a5fbe52bfa6a8f6f1dac442e4" translate="yes" xml:space="preserve">
          <source>The default test scenario is also quite sensitive to how long it's been since the tables were initialized: accumulation of dead rows and dead space in the tables changes the results. To understand the results you must keep track of the total number of updates and when vacuuming happens. If autovacuum is enabled it can result in unpredictable changes in measured performance.</source>
          <target state="translated">デフォルトのテストシナリオは、テーブルが初期化されてからどれくらいの時間が経過しているかにも敏感です:テーブルにデッドローやデッドスペースが蓄積されると結果が変わります。結果を理解するためには、更新の総数とバキュームがいつ行われたかを追跡する必要があります。自動バキュームが有効になっている場合、測定されたパフォーマンスに予測できない変化をもたらす可能性があります。</target>
        </trans-unit>
        <trans-unit id="9132263848d1108e0d8602af59d87e147d73248d" translate="yes" xml:space="preserve">
          <source>The default thresholds and scale factors are taken from &lt;code&gt;postgresql.conf&lt;/code&gt;, but it is possible to override them (and many other autovacuum control parameters) on a per-table basis; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. If a setting has been changed via a table's storage parameters, that value is used when processing that table; otherwise the global settings are used. See &lt;a href=&quot;runtime-config-autovacuum&quot;&gt;Section 19.10&lt;/a&gt; for more details on the global settings.</source>
          <target state="translated">デフォルトのしきい値とスケール係数は &lt;code&gt;postgresql.conf&lt;/code&gt; から取得されますが、テーブルごとにそれら（および他の多くの自動バキューム制御パラメーター）をオーバーライドすることが可能です。詳細については、&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;ストレージパラメータ&lt;/a&gt;を参照してください。テーブルのストレージパラメータを介して設定が変更された場合、その値はそのテーブルを処理するときに使用されます。それ以外の場合は、グローバル設定が使用されます。参照&lt;a href=&quot;runtime-config-autovacuum&quot;&gt;セクション19.10を&lt;/a&gt;グローバル設定の詳細については。</target>
        </trans-unit>
        <trans-unit id="0424e3dc5096d9c8dbd34cb8d06e5315c54e045d" translate="yes" xml:space="preserve">
          <source>The default time zone is specified as a constant numeric offset from UTC. It is therefore impossible to adapt to daylight-saving time when doing date/time arithmetic across DST boundaries.</source>
          <target state="translated">デフォルトのタイムゾーンは、UTCからの一定の数値オフセットとして指定されます。そのため、DSTの境界を越えて日付/時刻の演算を行う際に、サマータイムに合わせることはできません。</target>
        </trans-unit>
        <trans-unit id="cfbfb39fe00c30f34ca2449d77325fd4667682f6" translate="yes" xml:space="preserve">
          <source>The default timing of the trigger. See the &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation for details of these constraint options. This can only be specified for constraint triggers.</source>
          <target state="translated">トリガーのデフォルトのタイミング。これらの制約オプションの詳細については、&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLEの&lt;/a&gt;ドキュメントを参照してください。これは、制約トリガーにのみ指定できます。</target>
        </trans-unit>
        <trans-unit id="d7cc14aa1c7871e1d91e9c6189dd189cdc4b1317" translate="yes" xml:space="preserve">
          <source>The default value can be an expression, which will be evaluated whenever the default value is inserted (&lt;em&gt;not&lt;/em&gt; when the table is created). A common example is for a &lt;code&gt;timestamp&lt;/code&gt; column to have a default of &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, so that it gets set to the time of row insertion. Another common example is generating a &amp;ldquo;serial number&amp;rdquo; for each row. In PostgreSQL this is typically done by something like:</source>
          <target state="translated">デフォルト値は式にすることが&lt;em&gt;でき&lt;/em&gt;、（テーブルの作成時では&lt;em&gt;なく）&lt;/em&gt;デフォルト値が挿入されるたびに評価されます。一般的な例は、 &lt;code&gt;timestamp&lt;/code&gt; 列にデフォルトの &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; を設定して、行が挿入された時刻に設定されるようにすることです。別の一般的な例は、各行の「シリアル番号」を生成することです。 PostgreSQLでは、これは通常次のような方法で行われます。</target>
        </trans-unit>
        <trans-unit id="0b0db30e831b0c9d520dd21139ba84ee034c9c6b" translate="yes" xml:space="preserve">
          <source>The default value for the data type. If this is omitted, the default is null.</source>
          <target state="translated">データ型のデフォルト値です。これを省略した場合、デフォルトはnullとなります。</target>
        </trans-unit>
        <trans-unit id="ee14fce3a3ca851f605a2ff7d5b6a51a01fb240b" translate="yes" xml:space="preserve">
          <source>The default value for this parameter is &lt;code&gt;&quot;$user&quot;, public&lt;/code&gt;. This setting supports shared use of a database (where no users have private schemas, and all share use of &lt;code&gt;public&lt;/code&gt;), private per-user schemas, and combinations of these. Other effects can be obtained by altering the default search path setting, either globally or per-user.</source>
          <target state="translated">このパラメーターのデフォルト値は &lt;code&gt;&quot;$user&quot;, public&lt;/code&gt; です。この設定は、データベースの共有使用（ユーザーがプライベートスキーマを持たず、すべてが &lt;code&gt;public&lt;/code&gt; の共有使用）、ユーザーごとのプライベートスキーマ、およびこれらの組み合わせをサポートします。他の効果は、デフォルトの検索パス設定をグローバルに、またはユーザーごとに変更することで得られます。</target>
        </trans-unit>
        <trans-unit id="85d16eca710f45efd17caf29c22cdac95ac6757a" translate="yes" xml:space="preserve">
          <source>The default value for this parameter is &lt;code&gt;'$libdir'&lt;/code&gt;. If the value is set to an empty string, the automatic path search is turned off.</source>
          <target state="translated">このパラメーターのデフォルト値は &lt;code&gt;'$libdir'&lt;/code&gt; です。値が空の文字列に設定されている場合、自動パス検索はオフになります。</target>
        </trans-unit>
        <trans-unit id="71d008eed3fec13080aed7c6d124a51c1f2df8b8" translate="yes" xml:space="preserve">
          <source>The default value is 2.</source>
          <target state="translated">デフォルト値は2です。</target>
        </trans-unit>
        <trans-unit id="d8e9c33db68a29a970a8558f211b5f4b07ef1edd" translate="yes" xml:space="preserve">
          <source>The default value is 4.</source>
          <target state="translated">デフォルト値は4です。</target>
        </trans-unit>
        <trans-unit id="ca161bfe7f68575f9b78d9b22cc20c4f61990ca6" translate="yes" xml:space="preserve">
          <source>The default value is an empty string, which results in all temporary objects being created in the default tablespace of the current database.</source>
          <target state="translated">デフォルト値は空の文字列で、現在のデータベースのデフォルトのテーブルスペースにすべてのテンポラリオブジェクトが作成されます。</target>
        </trans-unit>
        <trans-unit id="2dbc96deb9627171cbe40ca7523d55ca78505616" translate="yes" xml:space="preserve">
          <source>The default value is defined as the value that the parameter would have had, if no &lt;code&gt;SET&lt;/code&gt; had ever been issued for it in the current session. The actual source of this value might be a compiled-in default, the configuration file, command-line options, or per-database or per-user default settings. This is subtly different from defining it as &amp;ldquo;the value that the parameter had at session start&amp;rdquo;, because if the value came from the configuration file, it will be reset to whatever is specified by the configuration file now. See &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for details.</source>
          <target state="translated">デフォルト値は、現在のセッションで &lt;code&gt;SET&lt;/code&gt; が発行されていなかった場合のパラメータの値として定義されています。この値の実際のソースは、コンパイル済みのデフォルト、構成ファイル、コマンドラインオプション、またはデータベースごとまたはユーザーごとのデフォルト設定です。これは、「セッションの開始時にパラメーターが持っていた値」と定義することとは微妙に異なります。値が構成ファイルからのものである場合は、構成ファイルで指定されている値にリセットされるからです。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7169dc9a643791bfe51c929b266f11a33c289429" translate="yes" xml:space="preserve">
          <source>The default value is three connections. The value must be less than &lt;code&gt;max_connections&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">デフォルト値は3つの接続です。値は &lt;code&gt;max_connections&lt;/code&gt; より小さくなければなりません。このパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="72f22d9e98b0402b3ffa342734437db31335a193" translate="yes" xml:space="preserve">
          <source>The default value of this setting is the empty string, which disables the feature. It can be set to &lt;code&gt;all&lt;/code&gt; to check all records, or to a comma-separated list of resource managers to check only records originating from those resource managers. Currently, the supported resource managers are &lt;code&gt;heap&lt;/code&gt;, &lt;code&gt;heap2&lt;/code&gt;, &lt;code&gt;btree&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;gin&lt;/code&gt;, &lt;code&gt;gist&lt;/code&gt;, &lt;code&gt;sequence&lt;/code&gt;, &lt;code&gt;spgist&lt;/code&gt;, &lt;code&gt;brin&lt;/code&gt;, and &lt;code&gt;generic&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">この設定のデフォルト値は空の文字列で、この機能は無効になっています。 &lt;code&gt;all&lt;/code&gt; に設定してすべてのレコードをチェックするか、リソースマネージャーのコンマ区切りのリストに設定して、それらのリソースマネージャーから発信されたレコードのみをチェックすることができます。現在、サポートされているリソースマネージャは、 &lt;code&gt;heap&lt;/code&gt; 、 &lt;code&gt;heap2&lt;/code&gt; 、 &lt;code&gt;btree&lt;/code&gt; 、 &lt;code&gt;hash&lt;/code&gt; 、 &lt;code&gt;gin&lt;/code&gt; 、 &lt;code&gt;gist&lt;/code&gt; 、 &lt;code&gt;sequence&lt;/code&gt; 、 &lt;code&gt;spgist&lt;/code&gt; 、 &lt;code&gt;brin&lt;/code&gt; 、および &lt;code&gt;generic&lt;/code&gt; 。この設定を変更できるのはスーパーユーザーだけです。</target>
        </trans-unit>
        <trans-unit id="dd9068090248fdb711a8f2a412ca5077ebbda170" translate="yes" xml:space="preserve">
          <source>The defined collation of the column, or zero if the column is not of a collatable data type.</source>
          <target state="translated">列の定義された照合順序、または列が照合可能なデータ型でない場合はゼロ。</target>
        </trans-unit>
        <trans-unit id="b0e121be440089b477e6ea25c5d7cb8d2a246664" translate="yes" xml:space="preserve">
          <source>The definitions of the columns exposed by the view are shown in &lt;a href=&quot;pgbuffercache#PGBUFFERCACHE-COLUMNS&quot;&gt;Table F.15&lt;/a&gt;.</source>
          <target state="translated">ビューによって公開される列の定義を&lt;a href=&quot;pgbuffercache#PGBUFFERCACHE-COLUMNS&quot;&gt;表F.15に&lt;/a&gt;示します。</target>
        </trans-unit>
        <trans-unit id="a8c0177656a1475222b9e9f01f048f945368cb6d" translate="yes" xml:space="preserve">
          <source>The delay occurs once the database in recovery has reached a consistent state, until the standby is promoted or triggered. After that the standby will end recovery without further waiting.</source>
          <target state="translated">遅延は、回復中のデータベースが一貫した状態になると、スタンバイが昇格またはトリガされるまで発生します。その後、スタンバイはそれ以上待たずに回復を終了します。</target>
        </trans-unit>
        <trans-unit id="37c54600b84522926deb2fb64ab7c8c51ddae0fc" translate="yes" xml:space="preserve">
          <source>The delay occurs only on WAL records for transaction commits. Other records are replayed as quickly as possible, which is not a problem because MVCC visibility rules ensure their effects are not visible until the corresponding commit record is applied.</source>
          <target state="translated">遅延が発生するのは、トランザクションコミットの WAL レコードのみです。その他のレコードは可能な限り迅速に再生されますが、MVCC の可視化ルールにより、対応するコミットレコードが適用されるまでその効果が見えないようになっているため、これは問題ではありません。</target>
        </trans-unit>
        <trans-unit id="790720978a39aefa71d264470fa610449c099e01" translate="yes" xml:space="preserve">
          <source>The delimiter character to be used between values in arrays made of this type.</source>
          <target state="translated">この型で作られた配列の値の間に使用される区切り文字です。</target>
        </trans-unit>
        <trans-unit id="e3f72476c5f4c3f27d14849d70a712b70cac2da9" translate="yes" xml:space="preserve">
          <source>The dependent object can be dropped separately from the referenced object, and should be automatically dropped (regardless of &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; mode) if the referenced object is dropped. Example: a named constraint on a table is made auto-dependent on the table, so that it will go away if the table is dropped.</source>
          <target state="translated">依存オブジェクトは、参照オブジェクトとは別に削除できます。参照オブジェクトが削除されると、（ &lt;code&gt;RESTRICT&lt;/code&gt; または &lt;code&gt;CASCADE&lt;/code&gt; モードに関係なく）自動的に削除されます。例：テーブルの名前付き制約はテーブルに自動的に依存するため、テーブルが削除された場合、制約はなくなります。</target>
        </trans-unit>
        <trans-unit id="42b52b99ac2341cf62bd00d9b5e1bc3f8c4f0ef2" translate="yes" xml:space="preserve">
          <source>The dependent object is a member of the &lt;em&gt;extension&lt;/em&gt; that is the referenced object (see &lt;a href=&quot;catalog-pg-extension&quot;&gt;&lt;code&gt;pg_extension&lt;/code&gt;&lt;/a&gt;). The dependent object can be dropped only via &lt;code&gt;DROP EXTENSION&lt;/code&gt; on the referenced object. Functionally this dependency type acts the same as an &lt;code&gt;INTERNAL&lt;/code&gt; dependency, but it's kept separate for clarity and to simplify pg_dump.</source>
          <target state="translated">依存オブジェクトは、参照オブジェクトである&lt;em&gt;拡張機能の&lt;/em&gt;メンバーです（&lt;a href=&quot;catalog-pg-extension&quot;&gt; &lt;code&gt;pg_extension&lt;/code&gt; を&lt;/a&gt;参照）。依存オブジェクトは、参照オブジェクトの &lt;code&gt;DROP EXTENSION&lt;/code&gt; を介してのみ削除できます。機能的には、この依存関係タイプは &lt;code&gt;INTERNAL&lt;/code&gt; 依存関係と同じように機能しますが、明確にするため、およびpg_dumpを簡略化するために、別々に保持されています。</target>
        </trans-unit>
        <trans-unit id="bf57c8a0f5e570bb9686592bde8b3b28f101a435" translate="yes" xml:space="preserve">
          <source>The dependent object is not a member of the extension that is the referenced object (and so it should not be ignored by pg_dump), but it cannot function without the extension and should be auto-dropped if the extension is. The dependent object may be dropped on its own as well. Functionally this dependency type acts the same as an &lt;code&gt;AUTO&lt;/code&gt; dependency, but it's kept separate for clarity and to simplify pg_dump.</source>
          <target state="translated">依存オブジェクトは、参照オブジェクトである拡張機能のメンバーではありません（したがって、pg_dumpによって無視されるべきではありません）が、拡張機能なしで機能することはできず、拡張機能がある場合は自動的に削除されます。依存オブジェクトは、それ自体で削除される場合もあります。機能的には、この依存関係タイプは &lt;code&gt;AUTO&lt;/code&gt; 依存関係と同じように機能しますが、明確にするため、およびpg_dumpを簡略化するために、個別に保持されています。</target>
        </trans-unit>
        <trans-unit id="39aa74188fe1f062ac474926c65191d5babb5508" translate="yes" xml:space="preserve">
          <source>The dependent object was created as part of creation of the referenced object, and is really just a part of its internal implementation. A direct &lt;code&gt;DROP&lt;/code&gt; of the dependent object will be disallowed outright (we'll tell the user to issue a &lt;code&gt;DROP&lt;/code&gt; against the referenced object, instead). A &lt;code&gt;DROP&lt;/code&gt; of the referenced object will result in automatically dropping the dependent object whether &lt;code&gt;CASCADE&lt;/code&gt; is specified or not. If the dependent object has to be dropped due to a dependency on some other object being removed, its drop is converted to a drop of the referenced object, so that &lt;code&gt;NORMAL&lt;/code&gt; and &lt;code&gt;AUTO&lt;/code&gt; dependencies of the dependent object behave much like they were dependencies of the referenced object. Example: a view's &lt;code&gt;ON SELECT&lt;/code&gt; rule is made internally dependent on the view, preventing it from being dropped while the view remains. Dependencies of the rule (such as tables it refers to) act as if they were dependencies of the view.</source>
          <target state="translated">依存オブジェクトは、参照オブジェクトの作成の一部として作成されたものであり、実際にはその内部実装の一部にすぎません。依存オブジェクトの直接 &lt;code&gt;DROP&lt;/code&gt; は完全に禁止されます（代わりに、参照されたオブジェクトに対して &lt;code&gt;DROP&lt;/code&gt; を発行するようにユーザーに通知します）。 &lt;code&gt;DROP&lt;/code&gt; 参照オブジェクトのは、自動的にかどうかに依存するオブジェクトドロップをもたらす &lt;code&gt;CASCADE&lt;/code&gt; が指定され又はされていないが。他のオブジェクトへの依存関係が削除されたために依存オブジェクトを削除する必要がある場合、そのドロップは参照オブジェクトのドロップに変換されるため、 &lt;code&gt;NORMAL&lt;/code&gt; および &lt;code&gt;AUTO&lt;/code&gt; 依存オブジェクトの依存関係は、参照オブジェクトの依存関係とほとんど同じように動作します。例：ビューの &lt;code&gt;ON SELECT&lt;/code&gt; ルールは内部的にビューに依存しており、ビューが残っている間はドロップされません。ルールの依存関係（参照するテーブルなど）は、ビューの依存関係であるかのように動作します。</target>
        </trans-unit>
        <trans-unit id="6f08ad4e0433fd5acac3297aba03b2acf8ab1183" translate="yes" xml:space="preserve">
          <source>The dependent object was created as part of creation of the referenced object, and is really just a part of its internal implementation; however, unlike &lt;code&gt;INTERNAL&lt;/code&gt;, there is more than one such referenced object. The dependent object must not be dropped unless at least one of these referenced objects is dropped; if any one is, the dependent object should be dropped whether or not &lt;code&gt;CASCADE&lt;/code&gt; is specified. Also unlike &lt;code&gt;INTERNAL&lt;/code&gt;, a drop of some other object that the dependent object depends on does not result in automatic deletion of any partition-referenced object. Hence, if the drop does not cascade to at least one of these objects via some other path, it will be refused. (In most cases, the dependent object shares all its non-partition dependencies with at least one partition-referenced object, so that this restriction does not result in blocking any cascaded delete.) Primary and secondary partition dependencies behave identically except that the primary dependency is preferred for use in error messages; hence, a partition-dependent object should have one primary partition dependency and one or more secondary partition dependencies. Note that partition dependencies are made in addition to, not instead of, any dependencies the object would normally have. This simplifies &lt;code&gt;ATTACH/DETACH PARTITION&lt;/code&gt; operations: the partition dependencies need only be added or removed. Example: a child partitioned index is made partition-dependent on both the partition table it is on and the parent partitioned index, so that it goes away if either of those is dropped, but not otherwise. The dependency on the parent index is primary, so that if the user tries to drop the child partitioned index, the error message will suggest dropping the parent index instead (not the table).</source>
          <target state="translated">依存オブジェクトは、参照オブジェクトの作成の一部として作成されたものであり、実際には内部実装の一部にすぎません。ただし、 &lt;code&gt;INTERNAL&lt;/code&gt; とは異なり、そのような参照オブジェクトは複数存在します。これらの参照オブジェクトの少なくとも1つが削除されない限り、依存オブジェクトは削除しないでください。いずれかが存在する場合、 &lt;code&gt;CASCADE&lt;/code&gt; が指定されているかどうかに関係なく、依存オブジェクトを削除する必要があります。また、 &lt;code&gt;INTERNAL&lt;/code&gt; とは異なり、依存オブジェクトが依存する他のオブジェクトを削除しても、パーティション参照オブジェクトは自動的に削除されません。したがって、ドロップが他のパスを介してこれらのオブジェクトの少なくとも1つにカスケードされない場合、ドロップは拒否されます。 （ほとんどの場合、依存オブジェクトはすべての非パーティション依存関係を少なくとも1つのパーティション参照オブジェクトと共有するため、この制限によってカスケード削除がブロックされることはありません。）プライマリおよびセカンダリパーティションの依存関係は、プライマリ依存関係を除いて同じように動作します。エラーメッセージでの使用が推奨されます。したがって、パーティション依存オブジェクトには、1つのプライマリパーティション依存関係と1つ以上のセカンダリパーティション依存関係が必要です。パーティションの依存関係は、オブジェクトが通常持っている依存関係に追加されるのではなく、追加されることに注意してください。これにより、 &lt;code&gt;ATTACH/DETACH PARTITION&lt;/code&gt; 操作：パーティションの依存関係を追加または削除するだけです。例：子パーティションインデックスは、それが配置されているパーティションテーブルと親パーティションインデックスの両方にパーティション依存になるため、どちらかが削除された場合は削除されますが、それ以外の場合は削除されません。親インデックスへの依存関係は主なものであるため、ユーザーが子パーティションインデックスを削除しようとすると、エラーメッセージは代わりに（テーブルではなく）親インデックスを削除することを提案します。</target>
        </trans-unit>
        <trans-unit id="7ba979debfd87ef975dc568dd7e8792b4269670b" translate="yes" xml:space="preserve">
          <source>The desired new version of the extension. This can be written as either an identifier or a string literal. If not specified, &lt;code&gt;ALTER EXTENSION UPDATE&lt;/code&gt; attempts to update to whatever is shown as the default version in the extension's control file.</source>
          <target state="translated">拡張の目的の新しいバージョン。これは、識別子または文字列リテラルとして記述できます。指定されていない場合、 &lt;code&gt;ALTER EXTENSION UPDATE&lt;/code&gt; は、拡張機能の制御ファイルでデフォルトバージョンとして示されているものへの更新を試みます。</target>
        </trans-unit>
        <trans-unit id="fbd0e34ca3a19b97d0aeb9f0e2c89bbf73246c51" translate="yes" xml:space="preserve">
          <source>The destination encoding name.</source>
          <target state="translated">宛先のエンコード名。</target>
        </trans-unit>
        <trans-unit id="acbe64874af1481c3f0cac1a6029d7f03fb77273" translate="yes" xml:space="preserve">
          <source>The details of these commands are not important here; the important point is that there are several separate updates involved to accomplish this rather simple operation. Our bank's officers will want to be assured that either all these updates happen, or none of them happen. It would certainly not do for a system failure to result in Bob receiving $100.00 that was not debited from Alice. Nor would Alice long remain a happy customer if she was debited without Bob being credited. We need a guarantee that if something goes wrong partway through the operation, none of the steps executed so far will take effect. Grouping the updates into a &lt;em&gt;transaction&lt;/em&gt; gives us this guarantee. A transaction is said to be &lt;em&gt;atomic&lt;/em&gt;: from the point of view of other transactions, it either happens completely or not at all.</source>
          <target state="translated">これらのコマンドの詳細はここでは重要ではありません。重要な点は、このかなり単純な操作を実行するために、いくつかの個別の更新が含まれていることです。私たちの銀行の役員は、これらすべての更新が行われるか、またはどれも行われないことを保証する必要があります。システム障害が原因でボブがアリスから引き落とされなかった$ 100.00を受け取ることは確かにありません。アリスがボブにクレジットされずに引き落とされたとしても、アリスは長い間幸せな顧客であり続けるでしょう。操作の途中で問題が発生した場合、これまでに実行されたどのステップも有効にならないことを保証する必要があります。更新を&lt;em&gt;トランザクションに&lt;/em&gt;グループ化すると、この保証が得られます。トランザクションは&lt;em&gt;アトミックで&lt;/em&gt;あると言われています&lt;em&gt;&lt;/em&gt;：他のトランザクションの観点からは、完全に発生するか、まったく発生しないかのどちらかです。</target>
        </trans-unit>
        <trans-unit id="9e98ae374f333e238cb54e40ccd57bf293c2950f" translate="yes" xml:space="preserve">
          <source>The dictionary accepts two options:</source>
          <target state="translated">辞書は2つのオプションを受け付けます。</target>
        </trans-unit>
        <trans-unit id="a19f3de80263e9a6413003bf67d42fb29a4dfff8" translate="yes" xml:space="preserve">
          <source>The difference between enabling &lt;code&gt;log_duration&lt;/code&gt; and setting &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-STATEMENT&quot;&gt;log_min_duration_statement&lt;/a&gt; to zero is that exceeding &lt;code&gt;log_min_duration_statement&lt;/code&gt; forces the text of the query to be logged, but this option doesn't. Thus, if &lt;code&gt;log_duration&lt;/code&gt; is &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;log_min_duration_statement&lt;/code&gt; has a positive value, all durations are logged but the query text is included only for statements exceeding the threshold. This behavior can be useful for gathering statistics in high-load installations.</source>
          <target state="translated">有効違い &lt;code&gt;log_duration&lt;/code&gt; をして設定&lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-STATEMENT&quot;&gt;log_min_duration_statementを&lt;/a&gt;ゼロには超えていることである &lt;code&gt;log_min_duration_statement&lt;/code&gt; がログに記録されるクエリのテキストを強制的に、しかし、このオプションはありません。したがって、 &lt;code&gt;log_duration&lt;/code&gt; が &lt;code&gt;on&lt;/code&gt; 、 &lt;code&gt;log_min_duration_statement&lt;/code&gt; に正の値がある場合、すべての期間が記録されますが、クエリテキストは、しきい値を超えるステートメントに対してのみ含まれます。この動作は、高負荷のインストールで統計を収集するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="86d6a3829cada6f81d9cef342af0288f96d331f4" translate="yes" xml:space="preserve">
          <source>The difference is that the query against the summary table has to get only one row from the table, whereas the direct query against &lt;code&gt;one_to_many&lt;/code&gt; must index scan and fetch a row for each entry.</source>
          <target state="translated">違いは、サマリーテーブルに対するクエリはテーブルから行を1つだけ取得する必要があるのに対し、 &lt;code&gt;one_to_many&lt;/code&gt; に対する直接クエリはインデックススキャンを実行し、各エントリの行をフェッチする必要があることです。</target>
        </trans-unit>
        <trans-unit id="638327d505052c3c14e5ba331469e70ba93f8131" translate="yes" xml:space="preserve">
          <source>The differences highlighted here are not all of them. In XQuery and the 2.0 and later versions of XPath, there is an XPath 1.0 compatibility mode, and the W3C lists of &lt;a href=&quot;https://www.w3.org/TR/2010/REC-xpath-functions-20101214/#xpath1-compatibility&quot;&gt;function library changes&lt;/a&gt; and &lt;a href=&quot;https://www.w3.org/TR/xpath20/#id-backwards-compatibility&quot;&gt;language changes&lt;/a&gt; applied in that mode offer a more complete (but still not exhaustive) account of the differences. The compatibility mode cannot make the later languages exactly equivalent to XPath 1.0.</source>
          <target state="translated">ここで強調表示されている違いはそれらのすべてではありません。 XQueryと2.0以降のバージョンのXPathには、XPath 1.0互換モードがあり、そのモードで適用される&lt;a href=&quot;https://www.w3.org/TR/2010/REC-xpath-functions-20101214/#xpath1-compatibility&quot;&gt;関数ライブラリの変更&lt;/a&gt;と&lt;a href=&quot;https://www.w3.org/TR/xpath20/#id-backwards-compatibility&quot;&gt;言語の変更&lt;/a&gt;のW3Cリストは、違いのより完全な（しかし網羅的ではない）アカウントを提供します。互換モードでは、それ以降の言語をXPath 1.0とまったく同じにすることはできません。</target>
        </trans-unit>
        <trans-unit id="3e588858632409434bd776e63f92b5761c3db20c" translate="yes" xml:space="preserve">
          <source>The directory &lt;code&gt;$PGDATA/pg_tblspc&lt;/code&gt; contains symbolic links that point to each of the non-built-in tablespaces defined in the cluster. Although not recommended, it is possible to adjust the tablespace layout by hand by redefining these links. Under no circumstances perform this operation while the server is running. Note that in PostgreSQL 9.1 and earlier you will also need to update the &lt;code&gt;pg_tablespace&lt;/code&gt; catalog with the new locations. (If you do not, &lt;code&gt;pg_dump&lt;/code&gt; will continue to output the old tablespace locations.)</source>
          <target state="translated">ディレクトリ &lt;code&gt;$PGDATA/pg_tblspc&lt;/code&gt; は、クラスターで定義されている非組み込みの各テーブルスペースを指すシンボリックリンクが含まれています。お勧めしませんが、これらのリンクを再定義することにより、手動でテーブルスペースのレイアウトを調整することができます。サーバーが稼働している間は、この操作を実行しないでください。PostgreSQL 9.1以前では、 &lt;code&gt;pg_tablespace&lt;/code&gt; カタログも新しい場所で更新する必要があることに注意してください。（そうしないと、 &lt;code&gt;pg_dump&lt;/code&gt; は古いテーブルスペースの場所を出力し続けます。）</target>
        </trans-unit>
        <trans-unit id="48e3d4bb3b396fb8ccb3377c9877d054f3fd3eaa" translate="yes" xml:space="preserve">
          <source>The directory &lt;code&gt;src/test/locale&lt;/code&gt; in the source distribution contains a test suite for PostgreSQL's locale support.</source>
          <target state="translated">ソース配布のディレクトリ &lt;code&gt;src/test/locale&lt;/code&gt; には、PostgreSQLのロケールサポート用のテストスイートが含まれています。</target>
        </trans-unit>
        <trans-unit id="8f609b85a02a4ded47fa5c57a791418dd0d72112" translate="yes" xml:space="preserve">
          <source>The directory that will be used for the tablespace. The directory must exist (&lt;code&gt;CREATE TABLESPACE&lt;/code&gt; will not create it), should be empty, and must be owned by the PostgreSQL system user. The directory must be specified by an absolute path name.</source>
          <target state="translated">テーブルスペースに使用されるディレクトリ。ディレクトリは存在しなければならず（ &lt;code&gt;CREATE TABLESPACE&lt;/code&gt; はそれを作成しません）、空であり、PostgreSQLシステムユーザーが所有している必要があります。ディレクトリは絶対パス名で指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="0c9ae3d8cb40fd37366fec2ea07a50700e4c2316" translate="yes" xml:space="preserve">
          <source>The domain this constraint is on; 0 if not a domain constraint</source>
          <target state="translated">ドメイン制約でない場合は0。</target>
        </trans-unit>
        <trans-unit id="66141cd3e18bcdc88d4a038dfc634ffad3fa560d" translate="yes" xml:space="preserve">
          <source>The drawback of this procedure is that it depends on the integrity of the client: if the client machine is untrusted or compromised, an attacker could run just about any program on port 113 and return any user name they choose. This authentication method is therefore only appropriate for closed networks where each client machine is under tight control and where the database and system administrators operate in close contact. In other words, you must trust the machine running the ident server. Heed the warning:</source>
          <target state="translated">この手順の欠点は、クライアントの完全性に依存することです。クライアント・マシンが信頼されていなかったり、危殆化していたりすると、攻撃者はポート 113 であらゆるプログラムを実行し、任意のユーザ名を返すことができます。したがって、この認証方法は、各クライアントマシンが厳重に管理されており、データベースとシステム管理者が密接に連絡を取り合って動作しているクローズドネットワークにのみ適しています。言い換えれば、 ident サーバを実行しているマシンを信頼しなければなりません。警告に注意してください。</target>
        </trans-unit>
        <trans-unit id="13aa020c26befcd9c06640c85756679a7699e20c" translate="yes" xml:space="preserve">
          <source>The drawback of using locales other than &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt; in PostgreSQL is its performance impact. It slows character handling and prevents ordinary indexes from being used by &lt;code&gt;LIKE&lt;/code&gt;. For this reason use locales only if you actually need them.</source>
          <target state="translated">PostgreSQLで &lt;code&gt;C&lt;/code&gt; または &lt;code&gt;POSIX&lt;/code&gt; 以外のロケールを使用することの欠点は、パフォーマンスへの影響です。文字の処理が遅くなり、通常のインデックスが &lt;code&gt;LIKE&lt;/code&gt; で使用されなくなります。このため、実際に必要な場合にのみロケールを使用してください。</target>
        </trans-unit>
        <trans-unit id="ff3e6b54f5a69b71d88bd211c608fb1a58dc225c" translate="yes" xml:space="preserve">
          <source>The dump file produced by pg_dump does not contain the statistics used by the optimizer to make query planning decisions. Therefore, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; after restoring from a dump file to ensure optimal performance; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">pg_dumpによって生成されたダンプファイルには、クエリの計画を決定するためにオプティマイザが使用する統計が含まれていません。したがって、最適なパフォーマンスを確保するには、ダンプファイルから復元した後に &lt;code&gt;ANALYZE&lt;/code&gt; を実行するのが賢明です。詳細は、&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;セクション24.1.3&lt;/a&gt;および&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;セクション24.1.6&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7b92c28f4a6038b16d370463cb2b0c497c1536e4" translate="yes" xml:space="preserve">
          <source>The dump script should not be expected to run completely without errors. In particular, because the script will issue &lt;code&gt;CREATE ROLE&lt;/code&gt; for every role existing in the source cluster, it is certain to get a &amp;ldquo;role already exists&amp;rdquo; error for the bootstrap superuser, unless the destination cluster was initialized with a different bootstrap superuser name. This error is harmless and should be ignored. Use of the &lt;code&gt;--clean&lt;/code&gt; option is likely to produce additional harmless error messages about non-existent objects, although you can minimize those by adding &lt;code&gt;--if-exists&lt;/code&gt;.</source>
          <target state="translated">ダンプスクリプトは、エラーなしで完全に実行されることを期待すべきではありません。特に、スクリプトはソースクラスターに存在するすべての &lt;code&gt;CREATE ROLE&lt;/code&gt; に対してCREATE ROLEを発行するので、宛先クラスターが別のブートストラップスーパーユーザー名で初期化されていない限り、ブートストラップスーパーユーザーに対して「ロールはすでに存在します」エラーが発生します。このエラーは無害であるため、無視してください。 &lt;code&gt;--clean&lt;/code&gt; オプションを使用すると、存在しないオブジェクトに関する追加の無害なエラーメッセージが生成される可能性がありますが、 &lt;code&gt;--if-exists&lt;/code&gt; を追加することでそれらを最小限に抑えることができます。</target>
        </trans-unit>
        <trans-unit id="7f3181a66ca9fbe6427fab730ca21eb224bb5bb9" translate="yes" xml:space="preserve">
          <source>The dumps produced by pg_dump are relative to &lt;code&gt;template0&lt;/code&gt;. This means that any languages, procedures, etc. added via &lt;code&gt;template1&lt;/code&gt; will also be dumped by pg_dump. As a result, when restoring, if you are using a customized &lt;code&gt;template1&lt;/code&gt;, you must create the empty database from &lt;code&gt;template0&lt;/code&gt;, as in the example above.</source>
          <target state="translated">pg_dumpによって生成されるダンプは、 &lt;code&gt;template0&lt;/code&gt; に関連しています。これは、 &lt;code&gt;template1&lt;/code&gt; を介して追加された言語、手順などもpg_dumpによってダンプされることを意味します。その結果、カスタマイズされた &lt;code&gt;template1&lt;/code&gt; を使用している場合は、復元時に、上の例のように、 &lt;code&gt;template0&lt;/code&gt; から空のデータベースを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="7817fb8368f1c7b07f344d07c4746bc348201b26" translate="yes" xml:space="preserve">
          <source>The easiest way to perform a base backup is to use the &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; tool. It can create a base backup either as regular files or as a tar archive. If more flexibility than &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; can provide is required, you can also make a base backup using the low level API (see &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Section 25.3.3&lt;/a&gt;).</source>
          <target state="translated">ベースバックアップを実行する最も簡単な方法は、&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;ツールを使用することです。通常のファイルまたはtarアーカイブとしてベースバックアップを作成できます。&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;が提供できる以上の柔軟性が必要な場合は、低レベルAPIを使用してベースバックアップを作成することもできます（&lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;セクション25.3.3を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="29f1de90d9c685081e50b22b770744253403d7c5" translate="yes" xml:space="preserve">
          <source>The effect of this mechanism is that in the default configuration, triggers do not fire on replicas. This is useful because if a trigger is used on the origin to propagate data between tables, then the replication system will also replicate the propagated data, and the trigger should not fire a second time on the replica, because that would lead to duplication. However, if a trigger is used for another purpose such as creating external alerts, then it might be appropriate to set it to &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; so that it is also fired on replicas.</source>
          <target state="translated">このメカニズムの効果は、デフォルトの構成では、レプリカでトリガーが起動されないことです。トリガーがオリジンで使用されてテーブル間でデータを伝達する場合、複製システムは伝達されたデータもレプリケートし、複製でトリガーが2回発生しないようにする必要があるため、これは便利です。ただし、トリガーが外部アラートの作成などの別の目的で使用されている場合は、トリガーを &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; に設定して、レプリカでも起動されるようにするのが適切な場合があります。</target>
        </trans-unit>
        <trans-unit id="11f70bcfbdc794c385378840673cf0a249c54a0a" translate="yes" xml:space="preserve">
          <source>The effective maximum for &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; is 0.95 * &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt;; a setting higher than that will be capped to the maximum. A value higher than &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; wouldn't make sense because an anti-wraparound autovacuum would be triggered at that point anyway, and the 0.95 multiplier leaves some breathing room to run a manual &lt;code&gt;VACUUM&lt;/code&gt; before that happens. As a rule of thumb, &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; should be set to a value somewhat below &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt;, leaving enough gap so that a regularly scheduled &lt;code&gt;VACUUM&lt;/code&gt; or an autovacuum triggered by normal delete and update activity is run in that window. Setting it too close could lead to anti-wraparound autovacuums, even though the table was recently vacuumed to reclaim space, whereas lower values lead to more frequent aggressive vacuuming.</source>
          <target state="translated">&lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; の実効最大値は0.95 * &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; です。それより高い設定は最大に制限されます。 &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; より高い値は、とにかく折り返し防止autovacuumがその時点でトリガーされ、0.95乗数が発生する前に手動の &lt;code&gt;VACUUM&lt;/code&gt; を実行するための余地を残すため、意味がありません。経験則として、 &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; は &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; よりも少し低い値に設定し、定期的にスケジュールされた &lt;code&gt;VACUUM&lt;/code&gt; または、通常の削除および更新アクティビティによってトリガーされる自動バキュームがそのウィンドウで実行されます。設定が近すぎると、テーブルが最近バキュームされてスペースを再利用しているにもかかわらず、ラップアラウンドの自動バキュームが発生する可能性があります。値が小さいと、積極的なバキュームが頻繁に発生します。</target>
        </trans-unit>
        <trans-unit id="6acae8d5fe7431e883721a35bb83f27f6d33e399" translate="yes" xml:space="preserve">
          <source>The effective resolution of the sleep interval is platform-specific; 0.01 seconds is a common value. The sleep delay will be at least as long as specified. It might be longer depending on factors such as server load. In particular, &lt;code&gt;pg_sleep_until&lt;/code&gt; is not guaranteed to wake up exactly at the specified time, but it will not wake up any earlier.</source>
          <target state="translated">スリープ間隔の効果的な解決はプラットフォーム固有です。0.01秒が一般的な値です。スリープ遅延は、少なくとも指定された長さになります。サーバーの負荷などの要因によっては、それよりも長くなる場合があります。特に、 &lt;code&gt;pg_sleep_until&lt;/code&gt; は、指定された時間に正確に起動することが保証されていませんが、それ以前に起動することはありません。</target>
        </trans-unit>
        <trans-unit id="ca3e0b7947e98767e7bc3c70b05110c06d007fc6" translate="yes" xml:space="preserve">
          <source>The effects of &lt;code&gt;SET LOCAL&lt;/code&gt; last only till the end of the current transaction, whether committed or not. A special case is &lt;code&gt;SET&lt;/code&gt; followed by &lt;code&gt;SET LOCAL&lt;/code&gt; within a single transaction: the &lt;code&gt;SET LOCAL&lt;/code&gt; value will be seen until the end of the transaction, but afterwards (if the transaction is committed) the &lt;code&gt;SET&lt;/code&gt; value will take effect.</source>
          <target state="translated">&lt;code&gt;SET LOCAL&lt;/code&gt; の効果は、コミットされているかどうかに関係なく、現在のトランザクションが終了するまで有効です。特別なケースは、単一のトランザクション内で &lt;code&gt;SET&lt;/code&gt; の後に &lt;code&gt;SET LOCAL&lt;/code&gt; が続く場合です &lt;code&gt;SET LOCAL&lt;/code&gt; 値はトランザクションの終了まで表示されますが、その後（トランザクションがコミットされた場合） &lt;code&gt;SET&lt;/code&gt; 値が有効になります。</target>
        </trans-unit>
        <trans-unit id="1963e14d77518dfe80e47bfcd05e2429f11a8bde" translate="yes" xml:space="preserve">
          <source>The effects of &lt;code&gt;SET&lt;/code&gt; or &lt;code&gt;SET LOCAL&lt;/code&gt; are also canceled by rolling back to a savepoint that is earlier than the command.</source>
          <target state="translated">コマンドよりも前のセーブポイントにロールバックすることにより、 &lt;code&gt;SET&lt;/code&gt; または &lt;code&gt;SET LOCAL&lt;/code&gt; の効果もキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="005a74c57d93879fd436d69f089f03e96ff53b14" translate="yes" xml:space="preserve">
          <source>The elements of the &lt;code&gt;PARTITION BY&lt;/code&gt; list are interpreted in much the same fashion as elements of a &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;&lt;code&gt;GROUP BY&lt;/code&gt; Clause&lt;/a&gt;, except that they are always simple expressions and never the name or number of an output column. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regular &lt;code&gt;GROUP BY&lt;/code&gt; clause. They are allowed here because windowing occurs after grouping and aggregation.</source>
          <target state="translated">要素 &lt;code&gt;PARTITION BY&lt;/code&gt; リストはの要素とほとんど同じ方法で解釈され&lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt; &lt;code&gt;GROUP BY&lt;/code&gt; 句&lt;/a&gt;、彼らは常に単純な式と決して名または出力列の数であることを除いて、。別の違いは、これらの式には、通常の &lt;code&gt;GROUP BY&lt;/code&gt; 句では許可されない集約関数呼び出しを含めることができるということです。グループ化と集計の後にウィンドウ処理が行われるため、ここでは許可されます。</target>
        </trans-unit>
        <trans-unit id="bd51d8414173fa812e307883cf9daca455add1a4" translate="yes" xml:space="preserve">
          <source>The empty scalar sub-SELECT will produce a null value that is considered to be of the domain type, so no further constraint checking is applied to it, and the insertion will succeed.</source>
          <target state="translated">空のスカラsub-SELECTは、ドメイン型であると考えられるNULL値を生成するので、それ以上の制約チェックは適用されず、挿入は成功します。</target>
        </trans-unit>
        <trans-unit id="750129d09bd31bb5985c26e665018fb53719c8d3" translate="yes" xml:space="preserve">
          <source>The encoding and locale settings must match those of the template database, except when &lt;code&gt;template0&lt;/code&gt; is used as template. This is because other databases might contain data that does not match the specified encoding, or might contain indexes whose sort ordering is affected by &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;. Copying such data would result in a database that is corrupt according to the new settings. &lt;code&gt;template0&lt;/code&gt;, however, is known to not contain any data or indexes that would be affected.</source>
          <target state="translated">エンコーディングおよびロケール設定が場合を除いて、テンプレートデータベースのものと一致している必要があり &lt;code&gt;template0&lt;/code&gt; テンプレートとして使用されます。これは、他のデータベースに、指定されたエンコーディングと一致しないデータが含まれているか、ソート順が &lt;code&gt;LC_COLLATE&lt;/code&gt; および &lt;code&gt;LC_CTYPE&lt;/code&gt; の影響を受けるインデックスが含まれている可能性があるためです。このようなデータをコピーすると、新しい設定に従ってデータベースが破損します。ただし、 &lt;code&gt;template0&lt;/code&gt; には、影響を受けるデータやインデックスが含まれていないことがわかっています。</target>
        </trans-unit>
        <trans-unit id="06ebfe8f29152790c8c19069e09027b276e20d6f" translate="yes" xml:space="preserve">
          <source>The encoding for a database is stored in the system catalog &lt;code&gt;pg_database&lt;/code&gt;. You can see it by using the &lt;code&gt;psql&lt;/code&gt;&lt;code&gt;-l&lt;/code&gt; option or the &lt;code&gt;\l&lt;/code&gt; command.</source>
          <target state="translated">データベースのエンコーディングは、システムカタログ &lt;code&gt;pg_database&lt;/code&gt; に格納されています。これは、 &lt;code&gt;psql&lt;/code&gt; &lt;code&gt;-l&lt;/code&gt; オプションまたは &lt;code&gt;\l&lt;/code&gt; コマンドを使用して確認できます。</target>
        </trans-unit>
        <trans-unit id="7b548a79db3b694cdb5c78e7ae46892fe80152d6" translate="yes" xml:space="preserve">
          <source>The encryption vector used will only be cryptographically strong if PostgreSQL is built with support for OpenSSL. In other cases, the transmission to the RADIUS server should only be considered obfuscated, not secured, and external security measures should be applied if necessary.</source>
          <target state="translated">使用する暗号化ベクトルは、PostgreSQLがOpenSSLをサポートして構築されている場合に限り、暗号化に強いものとなります。それ以外の場合は、RADIUSサーバへの送信は難読化されているとしか考えられず、安全性は確保されておらず、必要に応じて外部のセキュリティ対策を施す必要があります。</target>
        </trans-unit>
        <trans-unit id="807f48853a85df34d9a80e7027652fd76ea8d1d2" translate="yes" xml:space="preserve">
          <source>The entries in the select list can be assigned names for subsequent processing, such as for use in an &lt;code&gt;ORDER BY&lt;/code&gt; clause or for display by the client application. For example:</source>
          <target state="translated">選択リストのエントリには、 &lt;code&gt;ORDER BY&lt;/code&gt; 句で使用したり、クライアントアプリケーションで表示したりするために、後続の処理のために名前を割り当てることができます。例えば：</target>
        </trans-unit>
        <trans-unit id="5ed44cca4375f0386d06f29a5cb471a7a637f589" translate="yes" xml:space="preserve">
          <source>The enumerator is a function &lt;code&gt;int_array_enum(integer[])&lt;/code&gt; that returns &lt;code&gt;setof integer&lt;/code&gt;. It is essentially the reverse operation of the aggregator: given an array of integers, expand it into a set of rows. This is a wrapper around &lt;code&gt;unnest&lt;/code&gt;, which does the same thing for any array type.</source>
          <target state="translated">列挙子は、 &lt;code&gt;setof integer&lt;/code&gt; を返す関数 &lt;code&gt;int_array_enum(integer[])&lt;/code&gt; です。これは、基本的にはアグリゲーターの逆の操作です。整数の配列を指定すると、それを一連の行に展開します。これは &lt;code&gt;unnest&lt;/code&gt; のラッパーであり、どの配列型でも同じことを行います。</target>
        </trans-unit>
        <trans-unit id="d14b9d4e54d6bcfb1eb32844ae2033e082cd8255" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PG_COLOR&lt;/code&gt; specifies whether to use color in diagnostics messages. Possible values are &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">環境変数 &lt;code&gt;PG_COLOR&lt;/code&gt; は、診断メッセージで色を使用するかどうかを指定します。可能な値は &lt;code&gt;always&lt;/code&gt; 、 &lt;code&gt;auto&lt;/code&gt; 、 &lt;code&gt;never&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0960a83450dbd1eaf41a4a82cb1e20f4eb07da46" translate="yes" xml:space="preserve">
          <source>The error code (see &lt;a href=&quot;errcodes-appendix&quot;&gt;Appendix A&lt;/a&gt;) associated with the last SQL query's failure, or &lt;code&gt;00000&lt;/code&gt; if it succeeded.</source>
          <target state="translated">最後のSQLクエリの失敗に関連するエラーコード（&lt;a href=&quot;errcodes-appendix&quot;&gt;付録Aを&lt;/a&gt;参照）、または成功した場合は &lt;code&gt;00000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18033404335da13276f24e2efbba0cea44bc2fa8" translate="yes" xml:space="preserve">
          <source>The error message contains a useful hint: if you do not want to bother deleting all the dependent objects individually, you can run:</source>
          <target state="translated">エラーメッセージには有用なヒントが含まれています。</target>
        </trans-unit>
        <trans-unit id="57829bc22f9a034fee876abab6cb834a1c2e8f4d" translate="yes" xml:space="preserve">
          <source>The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character.</source>
          <target state="translated">エスケープ文字は、16進数、プラス記号、シングルクォーテーション、ダブルクォーテーション、または空白文字以外の任意の単一の文字を指定できます。</target>
        </trans-unit>
        <trans-unit id="558d22a4e0d0e48723c35f2a0cfc8e75bf258ba8" translate="yes" xml:space="preserve">
          <source>The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character. Note that the escape character is written in single quotes, not double quotes.</source>
          <target state="translated">エスケープ文字は、16進数、プラス記号、単一引用符、二重引用符、空白文字以外の任意の単一文字にすることができます。エスケープ文字は、二重引用符ではなく単一引用符で書かれていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c319bbe8d3e052f0e1ded51a38eee81a844539cf" translate="yes" xml:space="preserve">
          <source>The escape-double-quote separators actually divide &lt;code&gt;substring&lt;/code&gt;'s pattern into three independent regular expressions; for example, a vertical bar (&lt;code&gt;|&lt;/code&gt;) in any of the three sections affects only that section. Also, the first and third of these regular expressions are defined to match the smallest possible amount of text, not the largest, when there is any ambiguity about how much of the data string matches which pattern. (In POSIX parlance, the first and third regular expressions are forced to be non-greedy.)</source>
          <target state="translated">エスケープと二重引用符の区切り文字は、実際には &lt;code&gt;substring&lt;/code&gt; のパターンを3つの独立した正規表現に分割します。たとえば、3つのセクションのいずれかにある縦棒（ &lt;code&gt;|&lt;/code&gt; ）は、そのセクションにのみ影響します。また、これらの正規表現の1番目と3番目は、データ文字列のどのパターンがどのパターンに一致するかについて曖昧な場合に、最大ではなく最小のテキスト量に一致するように定義されています。（POSIXの用語では、最初と3番目の正規表現は貪欲ではありません。）</target>
        </trans-unit>
        <trans-unit id="3b9ec713fc7d733ff3cae68659b4d4e80a25bebd" translate="yes" xml:space="preserve">
          <source>The essential difference between &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt; data types is that &lt;code&gt;inet&lt;/code&gt; accepts values with nonzero bits to the right of the netmask, whereas &lt;code&gt;cidr&lt;/code&gt; does not. For example, &lt;code&gt;192.168.0.1/24&lt;/code&gt; is valid for &lt;code&gt;inet&lt;/code&gt; but not for &lt;code&gt;cidr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet&lt;/code&gt; と &lt;code&gt;cidr&lt;/code&gt; のデータ型の本質的な違いは、 &lt;code&gt;inet&lt;/code&gt; はネットマスクの右側にゼロ以外のビットを持つ値を受け入れるのに対し、 &lt;code&gt;cidr&lt;/code&gt; は受け入れないということです。たとえば、 &lt;code&gt;192.168.0.1/24&lt;/code&gt; &lt;code&gt;cidr&lt;/code&gt; は &lt;code&gt;inet&lt;/code&gt; では有効ですが、cidrでは無効です。</target>
        </trans-unit>
        <trans-unit id="df18f95e8b31c041dbe1102915fb4ff49c1585b3" translate="yes" xml:space="preserve">
          <source>The essential semantics of an &lt;code&gt;in_range&lt;/code&gt; function depend on the two Boolean flag parameters. It should add or subtract &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;, then compare &lt;code&gt;val&lt;/code&gt; to the result, as follows:</source>
          <target state="translated">&lt;code&gt;in_range&lt;/code&gt; 関数の基本的なセマンティクスは、2つのブールフラグパラメーターに依存します。次のように、 &lt;code&gt;base&lt;/code&gt; と &lt;code&gt;offset&lt;/code&gt; を加算または減算してから、 &lt;code&gt;val&lt;/code&gt; と結果を比較します。</target>
        </trans-unit>
        <trans-unit id="e84d23798c1117bda45a63153c240c91e5736421" translate="yes" xml:space="preserve">
          <source>The estimate is as accurate as with the functional dependencies, mostly thanks to the table being fairly small and having a simple distribution with a low number of distinct values. Before looking at the second query, which was not handled by functional dependencies particularly well, let's inspect the MCV list a bit.</source>
          <target state="translated">推定値は、機能依存性の場合と同様に正確ですが、テーブルがかなり小さく、明瞭な値の数が少ない単純な分布を持っていることが主な要因です。2番目のクエリを見る前に、機能依存性によって特にうまく処理されなかった、MCVリストを少し調べてみましょう。</target>
        </trans-unit>
        <trans-unit id="e69083f44a757893f1ada1ae6b8cb9bd97b58e99" translate="yes" xml:space="preserve">
          <source>The estimated cost charged when vacuum modifies a block that was previously clean. It represents the extra I/O required to flush the dirty block out to disk again. The default value is 20.</source>
          <target state="translated">以前はクリーンだったブロックをバキュームで変更した場合に請求される概算コスト。これは、汚れたブロックを再びディスクに流すために必要な余分なI/Oを表します。デフォルト値は20です。</target>
        </trans-unit>
        <trans-unit id="ee2db52b19d2bfa03dc1ab623c01a2a1907e2459" translate="yes" xml:space="preserve">
          <source>The estimated cost for vacuuming a buffer found in the shared buffer cache. It represents the cost to lock the buffer pool, lookup the shared hash table and scan the content of the page. The default value is one.</source>
          <target state="translated">共有バッファキャッシュで見つかったバッファをバキュームするための推定コストです。バッファプールをロックし、共有ハッシュテーブルを検索し、ページの内容をスキャンするためのコストを表します。デフォルト値は 1 です。</target>
        </trans-unit>
        <trans-unit id="83ce27e1c08fee6790695cac6b8c3ef5bff725b5" translate="yes" xml:space="preserve">
          <source>The estimated cost for vacuuming a buffer that has to be read from disk. This represents the effort to lock the buffer pool, lookup the shared hash table, read the desired block in from the disk and scan its content. The default value is 10.</source>
          <target state="translated">ディスクから読み込まなければならないバッファをバキュームするための推定コスト。これは、バッファプールをロックし、共有ハッシュテーブルを検索し、ディスクから目的のブロックを読み込み、その内容をスキャンするための労力を表します。デフォルト値は10です。</target>
        </trans-unit>
        <trans-unit id="a717571e9b46bfa71ced49ce7ab5ad2053e90b7b" translate="yes" xml:space="preserve">
          <source>The event is one of &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;. Note that an &lt;code&gt;INSERT&lt;/code&gt; containing an &lt;code&gt;ON CONFLICT&lt;/code&gt; clause cannot be used on tables that have either &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; rules. Consider using an updatable view instead.</source>
          <target state="translated">イベントは、 &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、または &lt;code&gt;DELETE&lt;/code&gt; のいずれかです。そのノート &lt;code&gt;INSERT&lt;/code&gt; 含有 &lt;code&gt;ON CONFLICT&lt;/code&gt; 句は、いずれかの有するテーブルで使用することができない &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; ルール。代わりに更新可能なビューの使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="227dafe90d62bc0d6660bf9b763aa381e9cc9dfe" translate="yes" xml:space="preserve">
          <source>The exact values that are acceptable for the &lt;code&gt;locale&lt;/code&gt; clause in this command depend on the operating system. On Unix-like systems, the command &lt;code&gt;locale -a&lt;/code&gt; will show a list.</source>
          <target state="translated">このコマンドの &lt;code&gt;locale&lt;/code&gt; 句で許容される正確な値は、オペレーティングシステムによって異なります。Unixライクなシステムでは、コマンド &lt;code&gt;locale -a&lt;/code&gt; を実行するとリストが表示されます。</target>
        </trans-unit>
        <trans-unit id="1583bbd20b51e7ac63ce0bb194332cc2a7d7d470" translate="yes" xml:space="preserve">
          <source>The example above can be written using the simple &lt;code&gt;CASE&lt;/code&gt; syntax:</source>
          <target state="translated">上記の例は、単純な &lt;code&gt;CASE&lt;/code&gt; 構文を使用して記述できます。</target>
        </trans-unit>
        <trans-unit id="af8e2a351cf21a24426f9811e0f9ff471eeba69b" translate="yes" xml:space="preserve">
          <source>The example below shows a DTrace script for analyzing transaction counts in the system, as an alternative to snapshotting &lt;code&gt;pg_stat_database&lt;/code&gt; before and after a performance test:</source>
          <target state="translated">以下の例は、パフォーマンステストの前後に &lt;code&gt;pg_stat_database&lt;/code&gt; をスナップショットする代わりに、システムのトランザクション数を分析するためのDTraceスクリプトを示しています。</target>
        </trans-unit>
        <trans-unit id="f0d6977a3eaffb08d482eddd947f053b0bf9bd5c" translate="yes" xml:space="preserve">
          <source>The examples above only show &lt;code&gt;WITH&lt;/code&gt; being used with &lt;code&gt;SELECT&lt;/code&gt;, but it can be attached in the same way to &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;. In each case it effectively provides temporary table(s) that can be referred to in the main command.</source>
          <target state="translated">上記の例は、 &lt;code&gt;SELECT&lt;/code&gt; で使用される &lt;code&gt;WITH&lt;/code&gt; のみを示していますが、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、または &lt;code&gt;DELETE&lt;/code&gt; と同じ方法でアタッチできます。いずれの場合も、メインコマンドで参照できる一時テーブルを効果的に提供します。</target>
        </trans-unit>
        <trans-unit id="380cc7f137a8c15a1ad87e0fd8242117724c9f5a" translate="yes" xml:space="preserve">
          <source>The examples in the previous section illustrated full text matching using simple constant strings. This section shows how to search table data, optionally using indexes.</source>
          <target state="translated">前のセクションの例では、単純な定数文字列を使用した全文一致を説明しました。このセクションでは、テーブルデータを検索する方法を示します。</target>
        </trans-unit>
        <trans-unit id="b9b0afad9f26eddf93a4253af463b944d4205ce4" translate="yes" xml:space="preserve">
          <source>The examples shown below use tables in the PostgreSQL regression test database. The outputs shown are taken from version 8.3. The behavior of earlier (or later) versions might vary. Note also that since &lt;code&gt;ANALYZE&lt;/code&gt; uses random sampling while producing statistics, the results will change slightly after any new &lt;code&gt;ANALYZE&lt;/code&gt;.</source>
          <target state="translated">以下の例では、PostgreSQL回帰テストデータベースのテーブルを使用しています。表示される出力は、バージョン8.3から取得されます。以前（またはそれ以降）のバージョンの動作は異なる場合があります。 &lt;code&gt;ANALYZE&lt;/code&gt; は統計の生成中にランダムサンプリングを使用するため、新しい &lt;code&gt;ANALYZE&lt;/code&gt; を実行すると結果がわずかに変化することにも注意してください。</target>
        </trans-unit>
        <trans-unit id="c2367138a166c600af3d676a2ed6d45de33c069c" translate="yes" xml:space="preserve">
          <source>The examples use &lt;code&gt;EXPLAIN&lt;/code&gt;'s default &amp;ldquo;text&amp;rdquo; output format, which is compact and convenient for humans to read. If you want to feed &lt;code&gt;EXPLAIN&lt;/code&gt;'s output to a program for further analysis, you should use one of its machine-readable output formats (XML, JSON, or YAML) instead.</source>
          <target state="translated">例では、 &lt;code&gt;EXPLAIN&lt;/code&gt; のデフォルトの「テキスト」出力形式を使用しています。これはコンパクトで、人間が読むのに便利です。さらに分析するために &lt;code&gt;EXPLAIN&lt;/code&gt; の出力をプログラムにフィードする場合は、代わりにその機械可読出力形式（XML、JSON、またはYAML）のいずれかを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="d75f123f158a40ce2bca3268003c1deb66947f66" translate="yes" xml:space="preserve">
          <source>The exclusive backup method is deprecated and should be avoided. Prior to PostgreSQL 9.6, this was the only low-level method available, but it is now recommended that all users upgrade their scripts to use non-exclusive backups.</source>
          <target state="translated">排他的バックアップ方法は非推奨であり、避けるべきです。PostgreSQL 9.6以前では、これは唯一の低レベルの方法でしたが、現在では、すべてのユーザが非排他的バックアップを使用するようにスクリプトをアップグレードすることが推奨されています。</target>
        </trans-unit>
        <trans-unit id="bb6f1793100519508110d4857d8c27514367d631" translate="yes" xml:space="preserve">
          <source>The executor mechanism is used to evaluate all four basic SQL query types: &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;. For &lt;code&gt;SELECT&lt;/code&gt;, the top-level executor code only needs to send each row returned by the query plan tree off to the client. For &lt;code&gt;INSERT&lt;/code&gt;, each returned row is inserted into the target table specified for the &lt;code&gt;INSERT&lt;/code&gt;. This is done in a special top-level plan node called &lt;code&gt;ModifyTable&lt;/code&gt;. (A simple &lt;code&gt;INSERT ... VALUES&lt;/code&gt; command creates a trivial plan tree consisting of a single &lt;code&gt;Result&lt;/code&gt; node, which computes just one result row, and &lt;code&gt;ModifyTable&lt;/code&gt; above it to perform the insertion. But &lt;code&gt;INSERT ... SELECT&lt;/code&gt; can demand the full power of the executor mechanism.) For &lt;code&gt;UPDATE&lt;/code&gt;, the planner arranges that each computed row includes all the updated column values, plus the &lt;em&gt;TID&lt;/em&gt; (tuple ID, or row ID) of the original target row; this data is fed into a &lt;code&gt;ModifyTable&lt;/code&gt; node, which uses the information to create a new updated row and mark the old row deleted. For &lt;code&gt;DELETE&lt;/code&gt;, the only column that is actually returned by the plan is the TID, and the &lt;code&gt;ModifyTable&lt;/code&gt; node simply uses the TID to visit each target row and mark it deleted.</source>
          <target state="translated">エグゼキューターメカニズムは、 &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; の 4つの基本的なSQLクエリタイプすべてを評価するために使用されます。以下のために &lt;code&gt;SELECT&lt;/code&gt; 、トップレベルのエグゼキュータのコードは、クライアントにオフクエリプランツリーによって返される各行を送信する必要があります。ため &lt;code&gt;INSERT&lt;/code&gt; 、各返される行はのために指定されたターゲット表に挿入される &lt;code&gt;INSERT&lt;/code&gt; 。これは、 &lt;code&gt;ModifyTable&lt;/code&gt; と呼ばれる特別なトップレベルの計画ノードで行われます。 （単純な &lt;code&gt;INSERT ... VALUES&lt;/code&gt; コマンドは、1つの結果行のみを計算する単一の &lt;code&gt;Result&lt;/code&gt; ノードと &lt;code&gt;ModifyTable&lt;/code&gt; で構成される簡単な計画ツリーを作成しますその上で挿入を実行します。ただし、 &lt;code&gt;INSERT ... SELECT&lt;/code&gt; は、エグゼキュータメカニズムの全機能を要求する可能性があります &lt;code&gt;UPDATE&lt;/code&gt; 場合、プランナは、計算された各行に、更新されたすべての列の値と元のターゲット行の&lt;em&gt;TID&lt;/em&gt;（タプルID、または行ID）が含まれるように調整します。 ;このデータは、 &lt;code&gt;ModifyTable&lt;/code&gt; ノードにフィードされます。ModifyTableノードは、この情報を使用して、新しい更新された行を作成し、古い行を削除済みとしてマークします。ため &lt;code&gt;DELETE&lt;/code&gt; 、実際に計画によって返される唯一の列がTIDであり、そして &lt;code&gt;ModifyTable&lt;/code&gt; ノードは、単に、各対象行を訪問し、それを削除マークするTIDを使用します。</target>
        </trans-unit>
        <trans-unit id="4ce520996e20d2c06a7766155c3058caa75b4272" translate="yes" xml:space="preserve">
          <source>The executor recursively steps through the &lt;em&gt;plan tree&lt;/em&gt; and retrieves rows in the way represented by the plan. The executor makes use of the &lt;em&gt;storage system&lt;/em&gt; while scanning relations, performs &lt;em&gt;sorts&lt;/em&gt; and &lt;em&gt;joins&lt;/em&gt;, evaluates &lt;em&gt;qualifications&lt;/em&gt; and finally hands back the rows derived.</source>
          <target state="translated">executorは、&lt;em&gt;計画ツリー&lt;/em&gt;を再帰的にステップ実行し、&lt;em&gt;計画&lt;/em&gt;によって表される方法で行を取得します。executorは、関係のスキャン中に&lt;em&gt;ストレージシステム&lt;/em&gt;を利用し、並べ&lt;em&gt;替え&lt;/em&gt;と&lt;em&gt;結合を&lt;/em&gt;実行し、&lt;em&gt;資格&lt;/em&gt;を評価し、最後に派生行を返します。</target>
        </trans-unit>
        <trans-unit id="cf8658aa7a1382f233186544e10108cceaf18988" translate="yes" xml:space="preserve">
          <source>The existence of functional dependencies directly affects the accuracy of estimates in certain queries. If a query contains conditions on both the independent and the dependent column(s), the conditions on the dependent columns do not further reduce the result size; but without knowledge of the functional dependency, the query planner will assume that the conditions are independent, resulting in underestimating the result size.</source>
          <target state="translated">機能依存性の存在は、特定のクエリにおける推定精度に直接影響します。クエリが独立カラムと従属カラムの両方の条件を含んでいる場合、従属カラムの条件が結果サイズをさらに小さくすることはありませんが、機能依存性を知らないと、クエリプランナは条件が独立していると仮定してしまい、結果サイズを過小評価してしまいます。</target>
        </trans-unit>
        <trans-unit id="278c43dc066d35135921d352f59558e56072aaf4" translate="yes" xml:space="preserve">
          <source>The existing enum value that should be renamed. Like all enum literals, it needs to be quoted.</source>
          <target state="translated">名前を変更する既存の列挙型の値。すべてのenumリテラルと同様に、引用符で囲む必要があります。</target>
        </trans-unit>
        <trans-unit id="ec72bab01087d3968b75adfc77dfce97e7c1c187" translate="yes" xml:space="preserve">
          <source>The existing enum value that the new value should be added immediately before or after in the enum type's sort ordering. Like all enum literals, it needs to be quoted.</source>
          <target state="translated">既存の列挙型のソート順の直前または直後に新しい値を追加すべき列挙型の値。すべてのenumリテラルと同様に、引用符で囲まれている必要があります。</target>
        </trans-unit>
        <trans-unit id="288730aef18ef4aa044e0dc2a74d3a67ae251dbc" translate="yes" xml:space="preserve">
          <source>The expected parameter types for the prepared statement in the form of an array of &lt;code&gt;regtype&lt;/code&gt;. The OID corresponding to an element of this array can be obtained by casting the &lt;code&gt;regtype&lt;/code&gt; value to &lt;code&gt;oid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;regtype&lt;/code&gt; の配列の形式で準備されたステートメントに期待されるパラメータータイプ。この配列の要素に対応するOIDは、 &lt;code&gt;regtype&lt;/code&gt; 値を &lt;code&gt;oid&lt;/code&gt; にキャストすることで取得できます。</target>
        </trans-unit>
        <trans-unit id="6d73c415087d49efbf447ec5f41bf9143b5e43b5" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;IS DOCUMENT&lt;/code&gt; returns true if the argument XML value is a proper XML document, false if it is not (that is, it is a content fragment), or null if the argument is null. See &lt;a href=&quot;datatype-xml&quot;&gt;Section 8.13&lt;/a&gt; about the difference between documents and content fragments.</source>
          <target state="translated">式 &lt;code&gt;IS DOCUMENT&lt;/code&gt; は、引数XML値が適切なXMLドキュメントである場合はtrueを返し、そうでない場合（つまり、コンテンツフラグメントである場合）を返します。引数がnullの場合はnullを返します。ドキュメントとコンテンツフラグメントの違いについては、&lt;a href=&quot;datatype-xml&quot;&gt;セクション8.13を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d3f0f5215911482c31ec80c4c63789e99b22d5c9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;IS NOT DOCUMENT&lt;/code&gt; returns false if the argument XML value is a proper XML document, true if it is not (that is, it is a content fragment), or null if the argument is null.</source>
          <target state="translated">式 &lt;code&gt;IS NOT DOCUMENT&lt;/code&gt; は、引数XML値が適切なXMLドキュメントである場合はfalseを返し、そうでない場合（つまり、コンテンツフラグメントである場合）はtrueを返し、引数がnullの場合はnullを返します。</target>
        </trans-unit>
        <trans-unit id="2fefc72765ee0edb8389edc8b54df23ebd5b6c13" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;collation for&lt;/code&gt; returns the collation of the value that is passed to it. Example:</source>
          <target state="translated">式 &lt;code&gt;collation for&lt;/code&gt; は、渡された値の照合を返します。例：</target>
        </trans-unit>
        <trans-unit id="9cec711d90ae7214afb1e767819f2c01ba82f2bc" translate="yes" xml:space="preserve">
          <source>The expression added to the WITH CHECK qualifications for queries that attempt to add rows to this table</source>
          <target state="translated">このテーブルに行を追加しようとするクエリのWITH CHECK資格に追加された式</target>
        </trans-unit>
        <trans-unit id="fa02a0029d6349d8e6423a393d9fb0288905f902" translate="yes" xml:space="preserve">
          <source>The expression added to the security barrier qualifications for queries that this policy applies to</source>
          <target state="translated">このポリシーが適用されるクエリのセキュリティバリア資格に追加された表現</target>
        </trans-unit>
        <trans-unit id="239121cdfc5b45b387f1658717f60a67584813d6" translate="yes" xml:space="preserve">
          <source>The expression tree to be added to the WITH CHECK qualifications for queries that attempt to add rows to the table</source>
          <target state="translated">テーブルに行を追加しようとするクエリのWITH CHECK資格に追加される式ツリー</target>
        </trans-unit>
        <trans-unit id="710b7212dd7cdac519a9932cd2101a57cc49631a" translate="yes" xml:space="preserve">
          <source>The expression tree to be added to the security barrier qualifications for queries that use the table</source>
          <target state="translated">テーブルを使用するクエリのセキュリティバリア資格に追加される式ツリー</target>
        </trans-unit>
        <trans-unit id="d2c435961e2d1a2d5fc091620a3b53aedf1bc369" translate="yes" xml:space="preserve">
          <source>The expression used in the &lt;code&gt;WHERE&lt;/code&gt; clause can refer only to columns of the underlying table, but it can use all columns, not just the ones being indexed. Presently, subqueries and aggregate expressions are also forbidden in &lt;code&gt;WHERE&lt;/code&gt;. The same restrictions apply to index fields that are expressions.</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 句で使用される式は、基になるテーブルの列のみを参照できますが、インデックス付けされている列だけでなく、すべての列を使用できます。現在、サブクエリと集計式は &lt;code&gt;WHERE&lt;/code&gt; でも禁止されています。式であるインデックスフィールドにも同じ制限が適用されます。</target>
        </trans-unit>
        <trans-unit id="e44d27b215403bd620571252d0254bbcc4cec3b6" translate="yes" xml:space="preserve">
          <source>The expressions described in this section check properties of &lt;code&gt;xml&lt;/code&gt; values.</source>
          <target state="translated">このセクションで説明する式は、 &lt;code&gt;xml&lt;/code&gt; 値のプロパティをチェックします。</target>
        </trans-unit>
        <trans-unit id="56934ce6588045922ec59583c810f1cb0acd84a1" translate="yes" xml:space="preserve">
          <source>The extensions currently available for loading can be identified from the &lt;a href=&quot;view-pg-available-extensions&quot;&gt;&lt;code&gt;pg_available_extensions&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;view-pg-available-extension-versions&quot;&gt;&lt;code&gt;pg_available_extension_versions&lt;/code&gt;&lt;/a&gt; system views.</source>
          <target state="translated">現在ロード可能な拡張機能は、&lt;a href=&quot;view-pg-available-extensions&quot;&gt; &lt;code&gt;pg_available_extensions&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;view-pg-available-extension-versions&quot;&gt; &lt;code&gt;pg_available_extension_versions&lt;/code&gt; &lt;/a&gt;システムビューから識別できます。</target>
        </trans-unit>
        <trans-unit id="8afec2ee5b2d1b2e4a42a77922b5f5aca2fe0a53" translate="yes" xml:space="preserve">
          <source>The extensions for PL/Perl are called &lt;code&gt;jsonb_plperl&lt;/code&gt; and &lt;code&gt;jsonb_plperlu&lt;/code&gt;. If you use them, &lt;code&gt;jsonb&lt;/code&gt; values are mapped to Perl arrays, hashes, and scalars, as appropriate.</source>
          <target state="translated">PL / Perlの拡張機能は &lt;code&gt;jsonb_plperl&lt;/code&gt; および &lt;code&gt;jsonb_plperlu&lt;/code&gt; と呼ばれます。それらを使用する場合、 &lt;code&gt;jsonb&lt;/code&gt; 値は、必要に応じてPerl配列、ハッシュ、およびスカラーにマップされます。</target>
        </trans-unit>
        <trans-unit id="19e8b6e34d048aaf0ad16665bbe37cdf1acb53f4" translate="yes" xml:space="preserve">
          <source>The extensions for PL/Python are called &lt;code&gt;jsonb_plpythonu&lt;/code&gt;, &lt;code&gt;jsonb_plpython2u&lt;/code&gt;, and &lt;code&gt;jsonb_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;jsonb&lt;/code&gt; values are mapped to Python dictionaries, lists, and scalars, as appropriate.</source>
          <target state="translated">PL / Pythonの拡張機能は、 &lt;code&gt;jsonb_plpythonu&lt;/code&gt; 、 &lt;code&gt;jsonb_plpython2u&lt;/code&gt; 、および &lt;code&gt;jsonb_plpython3u&lt;/code&gt; と呼ばれます（PL / Pythonの命名規則については、&lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;セクション45.1&lt;/a&gt;を参照してください）。それらを使用する場合、 &lt;code&gt;jsonb&lt;/code&gt; 値は、必要に応じてPython辞書、リスト、スカラーにマップされます。</target>
        </trans-unit>
        <trans-unit id="75cf68d4493c1ff227589e69d7f36aa6187d6f32" translate="yes" xml:space="preserve">
          <source>The extent of analysis can be controlled by adjusting the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration variable, or on a column-by-column basis by setting the per-column statistics target with &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET STATISTICS&lt;/code&gt; (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;). The target value sets the maximum number of entries in the most-common-value list and the maximum number of bins in the histogram. The default target value is 100, but this can be adjusted up or down to trade off accuracy of planner estimates against the time taken for &lt;code&gt;ANALYZE&lt;/code&gt; and the amount of space occupied in &lt;code&gt;pg_statistic&lt;/code&gt;. In particular, setting the statistics target to zero disables collection of statistics for that column. It might be useful to do that for columns that are never used as part of the &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, or &lt;code&gt;ORDER BY&lt;/code&gt; clauses of queries, since the planner will have no use for statistics on such columns.</source>
          <target state="translated">分析の範囲は、&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;構成変数を調整することによって、または &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET STATISTICS&lt;/code&gt; 使用して列ごとの統計ターゲットを設定することによって列ごとに制御できます（&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLEを&lt;/a&gt;参照）。ターゲット値は、最も一般的な値のリストのエントリの最大数とヒストグラムのビンの最大数を設定します。デフォルトのターゲット値は100ですが、これを上下に調整して、 &lt;code&gt;ANALYZE&lt;/code&gt; にかかる時間と &lt;code&gt;pg_statistic&lt;/code&gt; で占有されているスペースの量に対するプランナー推定の精度をトレードオフできます。。特に、統計ターゲットをゼロに設定すると、その列の統計の収集が無効になります。クエリの &lt;code&gt;WHERE&lt;/code&gt; 、 &lt;code&gt;GROUP BY&lt;/code&gt; 、または &lt;code&gt;ORDER BY&lt;/code&gt; 句の一部として決して使用されない列については、プランナがそのような列の統計情報を使用しないため、これを行うと役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="4a1085020ce268691ef6285fd13220f59746e5a1" translate="yes" xml:space="preserve">
          <source>The external representation of an interval is formed using one or two floating-point numbers joined by the range operator (&lt;code&gt;..&lt;/code&gt; or &lt;code&gt;...&lt;/code&gt;). Alternatively, it can be specified as a center point plus or minus a deviation. Optional certainty indicators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;~&lt;/code&gt;) can be stored as well. (Certainty indicators are ignored by all the built-in operators, however.) &lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;Table F.26&lt;/a&gt; gives an overview of allowed representations; &lt;a href=&quot;seg#SEG-INPUT-EXAMPLES&quot;&gt;Table F.27&lt;/a&gt; shows some examples.</source>
          <target state="translated">間隔の外部表現は、範囲演算子（ &lt;code&gt;..&lt;/code&gt; または &lt;code&gt;...&lt;/code&gt; ）で結合された1つまたは2つの浮動小数点数を使用して形成されます。または、偏差を中心点としてプラスまたはマイナスとして指定することもできます。オプションの確実性インジケーター（ &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; または &lt;code&gt;~&lt;/code&gt; ）も保存できます。 （ただし、すべての組み込み演算子では確実性インジケータは無視されます。）&lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;表F.26に&lt;/a&gt;、許可される表現の概要を示します。&lt;a href=&quot;seg#SEG-INPUT-EXAMPLES&quot;&gt;表F.27に&lt;/a&gt;いくつかの例を示します。</target>
        </trans-unit>
        <trans-unit id="ae94f4d8ec241ec4efa4661c23c0573db1da2b96" translate="yes" xml:space="preserve">
          <source>The external text representation of a composite value consists of items that are interpreted according to the I/O conversion rules for the individual field types, plus decoration that indicates the composite structure. The decoration consists of parentheses (&lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt;) around the whole value, plus commas (&lt;code&gt;,&lt;/code&gt;) between adjacent items. Whitespace outside the parentheses is ignored, but within the parentheses it is considered part of the field value, and might or might not be significant depending on the input conversion rules for the field data type. For example, in:</source>
          <target state="translated">複合値の外部テキスト表現は、個々のフィールドタイプのI / O変換ルールに従って解釈されるアイテムと、複合構造を示す装飾で構成されます。装飾は、値全体を囲む括弧（ &lt;code&gt;(&lt;/code&gt; および &lt;code&gt;)&lt;/code&gt; ）と、隣接する項目間のコンマ（ &lt;code&gt;,&lt;/code&gt; ）で構成されます。括弧の外側の空白は無視されますが、括弧内はフィールド値の一部と見なされ、フィールドデータタイプの入力変換規則によっては、重要でない場合があります。たとえば、次の場所にあります。</target>
        </trans-unit>
        <trans-unit id="165e79d513851869bfa7df4f3e60a06eff8eadcf" translate="yes" xml:space="preserve">
          <source>The external text representation of an array value consists of items that are interpreted according to the I/O conversion rules for the array's element type, plus decoration that indicates the array structure. The decoration consists of curly braces (&lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;) around the array value plus delimiter characters between adjacent items. The delimiter character is usually a comma (&lt;code&gt;,&lt;/code&gt;) but can be something else: it is determined by the &lt;code&gt;typdelim&lt;/code&gt; setting for the array's element type. Among the standard data types provided in the PostgreSQL distribution, all use a comma, except for type &lt;code&gt;box&lt;/code&gt;, which uses a semicolon (&lt;code&gt;;&lt;/code&gt;). In a multidimensional array, each dimension (row, plane, cube, etc.) gets its own level of curly braces, and delimiters must be written between adjacent curly-braced entities of the same level.</source>
          <target state="translated">配列値の外部テキスト表現は、配列の要素タイプのI / O変換規則に従って解釈されるアイテムと、配列構造を示す装飾で構成されます。装飾は、配列値を囲む中括弧（ &lt;code&gt;{&lt;/code&gt; および &lt;code&gt;}&lt;/code&gt; ）と、隣接するアイテム間の区切り文字で構成されます。区切り文字は通常コンマ（ &lt;code&gt;,&lt;/code&gt; ）ですが、他の文字でもかまいません。これは、配列の要素タイプの &lt;code&gt;typdelim&lt;/code&gt; 設定によって決定されます。 PostgreSQLディストリビューションで提供される標準のデータ型のうち、セミコロン（ &lt;code&gt;;&lt;/code&gt; を使用する &lt;code&gt;box&lt;/code&gt; 型を除き、すべてコンマを使用します。）。多次元配列では、各次元（行、平面、立方体など）が独自のレベルの波括弧を取得し、同じレベルの隣接する波括弧エンティティ間に区切り文字を記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="6b72823d964b50e21e643394f5a86559900b575c" translate="yes" xml:space="preserve">
          <source>The external, user defined, name of a replication origin.</source>
          <target state="translated">レプリケーションオリジンの外部、ユーザー定義の名前。</target>
        </trans-unit>
        <trans-unit id="23e10c575081917649336c89f16d01777906e835" translate="yes" xml:space="preserve">
          <source>The fact that constraint exclusion uses &lt;code&gt;CHECK&lt;/code&gt; constraints, which makes it slow compared to partition pruning, can sometimes be used as an advantage: because constraints can be defined even on declaratively-partitioned tables, in addition to their internal partition bounds, constraint exclusion may be able to elide additional partitions from the query plan.</source>
          <target state="translated">制約の除外は &lt;code&gt;CHECK&lt;/code&gt; 制約を使用するため、パーティションのプルーニングに比べて遅くなりますが、利点として使用できる場合があります。内部パーティション境界に加えて、宣言的にパーティション分割されたテーブルでも制約を定義できるため、制約の除外はクエリプランから追加のパーティションを除外できます。</target>
        </trans-unit>
        <trans-unit id="19233032264a45feb14fbaa7d90f7412bf00d3b4" translate="yes" xml:space="preserve">
          <source>The factory default limit on open files is often set to &amp;ldquo;socially friendly&amp;rdquo; values that allow many users to coexist on a machine without using an inappropriate fraction of the system resources. If you run many servers on a machine this is perhaps what you want, but on dedicated servers you might want to raise this limit.</source>
          <target state="translated">オープンファイルの工場出荷時のデフォルト制限は、多くの場合、システムリソースの不適切な部分を使用せずに多くのユーザーがマシン上で共存できる「社交的」な値に設定されています。マシン上で多くのサーバーを実行する場合、これはおそらく必要なことですが、専用サーバーではこの制限を引き上げることができます。</target>
        </trans-unit>
        <trans-unit id="7eb210aea67c31ef1dbed7fd3eae3f43ab6220c6" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; is only honored in macOS 10.3.9 and later. If you are running a previous 10.3.x release, you must edit the file &lt;code&gt;/etc/rc&lt;/code&gt; and change the values in the following commands:</source>
          <target state="translated">&lt;code&gt;/etc/sysctl.conf&lt;/code&gt; ファイルは、macOS 10.3.9以降でのみ有効です。以前の10.3.xリリースを実行している場合は、ファイル &lt;code&gt;/etc/rc&lt;/code&gt; を編集して、次のコマンドの値を変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="84e9c854c59c60e0df39d55604e40742c14a3b04" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;scan.l&lt;/code&gt; is transformed to the C source file &lt;code&gt;scan.c&lt;/code&gt; using the program flex and &lt;code&gt;gram.y&lt;/code&gt; is transformed to &lt;code&gt;gram.c&lt;/code&gt; using bison. After these transformations have taken place a normal C compiler can be used to create the parser. Never make any changes to the generated C files as they will be overwritten the next time flex or bison is called.</source>
          <target state="translated">ファイル &lt;code&gt;scan.l&lt;/code&gt; はプログラムflexを使用してCソースファイル &lt;code&gt;scan.c&lt;/code&gt; に変換され、 &lt;code&gt;gram.y&lt;/code&gt; はbisonを使用して &lt;code&gt;gram.c&lt;/code&gt; に変換されます。これらの変換が行われた後、通常のCコンパイラを使用してパーサーを作成できます。生成されたCファイルは、次回flexまたはbisonが呼び出されたときに上書きされるため、変更しないでください。</target>
        </trans-unit>
        <trans-unit id="45d0800a2dc4458be5cbd179d0ad2c43301c7d89" translate="yes" xml:space="preserve">
          <source>The file header consists of 15 bytes of fixed fields, followed by a variable-length header extension area. The fixed fields are:</source>
          <target state="translated">ファイルヘッダーは15バイトの固定フィールドと、可変長のヘッダー拡張領域で構成されています。固定フィールドは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="08e8ce7451fee51ac789a7527b77201e50285954" translate="yes" xml:space="preserve">
          <source>The file name that will be used to store the history list. If unset, the file name is taken from the &lt;code&gt;PSQL_HISTORY&lt;/code&gt; environment variable. If that is not set either, the default is &lt;code&gt;~/.psql_history&lt;/code&gt;, or &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; on Windows. For example, putting:</source>
          <target state="translated">履歴リストの保存に使用されるファイル名。設定されていない場合、ファイル名は &lt;code&gt;PSQL_HISTORY&lt;/code&gt; 環境変数から取得されます。これも設定されていない場合、デフォルトは &lt;code&gt;~/.psql_history&lt;/code&gt; 、またはWindowsでは &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; です。たとえば、次のようにします。</target>
        </trans-unit>
        <trans-unit id="349919ea5386038c9255234a7dc46c1f159466f8" translate="yes" xml:space="preserve">
          <source>The file trailer consists of a 16-bit integer word containing -1. This is easily distinguished from a tuple's field-count word.</source>
          <target state="translated">ファイルトレーラは、-1を含む16ビットの整数ワードで構成されています。これはタプルのフィールドカウントワードと簡単に区別できます。</target>
        </trans-unit>
        <trans-unit id="80e18aa528aa991bd67d4fb018eb762c1dfd60ad" translate="yes" xml:space="preserve">
          <source>The fillfactor for a table is a percentage between 10 and 100. 100 (complete packing) is the default. When a smaller fillfactor is specified, &lt;code&gt;INSERT&lt;/code&gt; operations pack table pages only to the indicated percentage; the remaining space on each page is reserved for updating rows on that page. This gives &lt;code&gt;UPDATE&lt;/code&gt; a chance to place the updated copy of a row on the same page as the original, which is more efficient than placing it on a different page. For a table whose entries are never updated, complete packing is the best choice, but in heavily updated tables smaller fillfactors are appropriate. This parameter cannot be set for TOAST tables.</source>
          <target state="translated">テーブルのfillfactorは、10から100の間のパーセントです。100（完全なパッキング）がデフォルトです。より小さいfillfactorが指定されている場合、 &lt;code&gt;INSERT&lt;/code&gt; 操作は、指定されたパーセンテージにのみテーブルページをパックします。各ページの残りのスペースは、そのページの行を更新するために予約されています。これにより、 &lt;code&gt;UPDATE&lt;/code&gt; は行の更新されたコピーを元のページと同じページに配置する機会が得られます。これは、別のページに配置するよりも効率的です。エントリが決して更新されないテーブルの場合、完全なパッキングが最良の選択ですが、頻繁に更新されるテーブルでは、より小さいfillfactorsが適切です。このパラメーターはTOASTテーブルには設定できません。</target>
        </trans-unit>
        <trans-unit id="4a018942b6effccffd16cfc6cd2d9f3b5906ea0a" translate="yes" xml:space="preserve">
          <source>The fillfactor for an index is a percentage that determines how full the index method will try to pack index pages. For B-trees, leaf pages are filled to this percentage during initial index build, and also when extending the index at the right (adding new largest key values). If pages subsequently become completely full, they will be split, leading to gradual degradation in the index's efficiency. B-trees use a default fillfactor of 90, but any integer value from 10 to 100 can be selected. If the table is static then fillfactor 100 is best to minimize the index's physical size, but for heavily updated tables a smaller fillfactor is better to minimize the need for page splits. The other index methods use fillfactor in different but roughly analogous ways; the default fillfactor varies between methods.</source>
          <target state="translated">インデックスのフィルファクターは、インデックスメソッドがインデックスページをどれだけいっぱいに詰めようとするかを決定するパーセンテージです。B-木の場合、リーフページは、最初のインデックス構築時と、右端でインデックスを拡張するとき(新しい最大のキー値を追加するとき)に、このパーセンテージで埋められます。その後、ページが完全に一杯になった場合、それらのページは分割され、インデックスの効率は徐々に低下していきます。B-tree はデフ ォル ト の fillfactor 90 を用いていますが、10 ~ 100 の任意の整数値を選択することができます。テーブルが静的な場合は、インデックスの物理的なサイズを最小化するにはフィルファクタ100が最適ですが、更新の多いテーブルの場合は、ページ分割の必要性を最小化するにはフィルファクタを小さくした方が良いでしょう。他のインデックスメソッドは、異なる方法で fillfactor を使用していますが、ほぼ類似した方法で使用しています。</target>
        </trans-unit>
        <trans-unit id="5c29e42edd123c00869988ea11e4589bccf58ecb" translate="yes" xml:space="preserve">
          <source>The final section is the &amp;ldquo;special section&amp;rdquo; which can contain anything the access method wishes to store. For example, b-tree indexes store links to the page's left and right siblings, as well as some other data relevant to the index structure. Ordinary tables do not use a special section at all (indicated by setting &lt;code&gt;pd_special&lt;/code&gt; to equal the page size).</source>
          <target state="translated">最後のセクションは「特別なセクション」であり、アクセスメソッドが格納したいものをすべて含めることができます。たとえば、Bツリーインデックスには、ページの左兄弟と右兄弟へのリンクだけでなく、インデックス構造に関連するその他のデータも格納されます。通常のテーブルは特別なセクションをまったく使用しません（ページサイズと等しくなるように &lt;code&gt;pd_special&lt;/code&gt; を設定することで示されます）。</target>
        </trans-unit>
        <trans-unit id="02efe302dcd79b9e88f3a8473b49b8f9d4ac5123" translate="yes" xml:space="preserve">
          <source>The finished plan tree consists of sequential or index scans of the base relations, plus nested-loop, merge, or hash join nodes as needed, plus any auxiliary steps needed, such as sort nodes or aggregate-function calculation nodes. Most of these plan node types have the additional ability to do &lt;em&gt;selection&lt;/em&gt; (discarding rows that do not meet a specified Boolean condition) and &lt;em&gt;projection&lt;/em&gt; (computation of a derived column set based on given column values, that is, evaluation of scalar expressions where needed). One of the responsibilities of the planner is to attach selection conditions from the &lt;code&gt;WHERE&lt;/code&gt; clause and computation of required output expressions to the most appropriate nodes of the plan tree.</source>
          <target state="translated">完成したプランツリーは、基本リレーションの順次スキャンまたはインデックススキャン、さらに必要に応じてネストループ、マージ、またはハッシュ結合ノード、およびソートノードや集計関数計算ノードなどの必要な補助ステップで構成されます。これらのプランノードタイプのほとんどには、&lt;em&gt;選択&lt;/em&gt;（指定されたブール条件を満たさない行を破棄する）および&lt;em&gt;射影&lt;/em&gt;（特定の列値に基づく派生列セットの計算、つまり必要に応じたスカラー式の評価）を実行する追加機能があります。 。プランナーの責任の1つは、 &lt;code&gt;WHERE&lt;/code&gt; 句からの選択条件と必要な出力式の計算をプランツリーの最も適切なノードに付加することです。</target>
        </trans-unit>
        <trans-unit id="2f91a1368250aec82fa6c3ae45da03e945de99bb" translate="yes" xml:space="preserve">
          <source>The firing of triggers that are declared as &amp;ldquo;constraint triggers&amp;rdquo; is also controlled by this setting &amp;mdash; they fire at the same time that the associated constraint should be checked.</source>
          <target state="translated">「制約トリガー」として宣言されているトリガーの起動も、この設定によって制御されます。これらのトリガーは、関連する制約を確認すると同時に起動します。</target>
        </trans-unit>
        <trans-unit id="88e7caa4743ed2b44e88bb8540b5ed22e8f063f5" translate="yes" xml:space="preserve">
          <source>The first 24 bytes of each page consists of a page header (&lt;code&gt;PageHeaderData&lt;/code&gt;). Its format is detailed in &lt;a href=&quot;storage-page-layout#PAGEHEADERDATA-TABLE&quot;&gt;Table 68.3&lt;/a&gt;. The first field tracks the most recent WAL entry related to this page. The second field contains the page checksum if &lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;data checksums&lt;/a&gt; are enabled. Next is a 2-byte field containing flag bits. This is followed by three 2-byte integer fields (&lt;code&gt;pd_lower&lt;/code&gt;, &lt;code&gt;pd_upper&lt;/code&gt;, and &lt;code&gt;pd_special&lt;/code&gt;). These contain byte offsets from the page start to the start of unallocated space, to the end of unallocated space, and to the start of the special space. The next 2 bytes of the page header, &lt;code&gt;pd_pagesize_version&lt;/code&gt;, store both the page size and a version indicator. Beginning with PostgreSQL 8.3 the version number is 4; PostgreSQL 8.1 and 8.2 used version number 3; PostgreSQL 8.0 used version number 2; PostgreSQL 7.3 and 7.4 used version number 1; prior releases used version number 0. (The basic page layout and header format has not changed in most of these versions, but the layout of heap row headers has.) The page size is basically only present as a cross-check; there is no support for having more than one page size in an installation. The last field is a hint that shows whether pruning the page is likely to be profitable: it tracks the oldest un-pruned XMAX on the page.</source>
          <target state="translated">各ページの最初の24バイトは、ページヘッダー（ &lt;code&gt;PageHeaderData&lt;/code&gt; ）で構成されています。そのフォーマットの詳細を&lt;a href=&quot;storage-page-layout#PAGEHEADERDATA-TABLE&quot;&gt;表68.3に示し&lt;/a&gt;ます。最初のフィールドは、このページに関連する最新のWALエントリを追跡します。&lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;データチェックサム&lt;/a&gt;が有効な場合、2番目のフィールドにはページのチェックサムが含まれます。次は、フラグビットを含む2バイトのフィールドです。この後に、3つの2バイト整数フィールド（ &lt;code&gt;pd_lower&lt;/code&gt; 、 &lt;code&gt;pd_upper&lt;/code&gt; 、および &lt;code&gt;pd_special&lt;/code&gt; ）が続きます。これらには、ページの開始から未割り当てスペースの開始、未割り当てスペースの終了、および特殊スペースの開始までのバイトオフセットが含まれています。ページヘッダーの次の2バイト、 &lt;code&gt;pd_pagesize_version&lt;/code&gt; 、ページサイズとバージョンインジケーターの両方を保存します。 PostgreSQL 8.3以降、バージョン番号は4です。 PostgreSQL 8.1および8.2はバージョン番号3を使用しました。 PostgreSQL 8.0はバージョン番号2を使用しました。 PostgreSQL 7.3および7.4はバージョン番号1を使用しました。以前のリリースではバージョン番号0を使用していました（これらのバージョンのほとんどで基本的なページレイアウトとヘッダー形式は変更されていませんが、ヒープ行ヘッダーのレイアウトは変更されています）。ページサイズは基本的にクロスチェックとしてのみ存在します。インストールで複数のページサイズを使用することはサポートされていません。最後のフィールドは、ページのプルーニングが有益である可能性が高いかどうかを示すヒントです。これは、ページ上の最も古いプルーニングされていないXMAXを追跡します。</target>
        </trans-unit>
        <trans-unit id="146b5ed003ceae9188015f907676c66e37810a01" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;UPDATE&lt;/code&gt; statement successfully acquires a row-level lock on the specified row, so it succeeds in updating that row. However, the second &lt;code&gt;UPDATE&lt;/code&gt; statement finds that the row it is attempting to update has already been locked, so it waits for the transaction that acquired the lock to complete. Transaction two is now waiting on transaction one to complete before it continues execution. Now, transaction one executes:</source>
          <target state="translated">最初の &lt;code&gt;UPDATE&lt;/code&gt; ステートメントは、指定された行の行レベルのロックを正常に取得するため、その行の更新に成功します。ただし、2番目の &lt;code&gt;UPDATE&lt;/code&gt; ステートメントは、更新しようとしている行が既にロックされていることを検出したため、ロックを取得したトランザクションが完了するまで待機します。トランザクション2は、実行を続行する前にトランザクション1が完了するのを待機しています。ここで、トランザクション1が実行されます。</target>
        </trans-unit>
        <trans-unit id="5efcfda2d8c77b88473ca9337c42439a024d54ff" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;expression&lt;/code&gt; is computed, then compared to each of the &lt;code&gt;value&lt;/code&gt; expressions in the &lt;code&gt;WHEN&lt;/code&gt; clauses until one is found that is equal to it. If no match is found, the &lt;code&gt;result&lt;/code&gt; of the &lt;code&gt;ELSE&lt;/code&gt; clause (or a null value) is returned. This is similar to the &lt;code&gt;switch&lt;/code&gt; statement in C.</source>
          <target state="translated">最初の &lt;code&gt;expression&lt;/code&gt; が計算され、それと等しいものが見つかるまで、 &lt;code&gt;WHEN&lt;/code&gt; 句の各 &lt;code&gt;value&lt;/code&gt; 式と比較されます。一致するものが見つからない場合、 &lt;code&gt;ELSE&lt;/code&gt; 句の &lt;code&gt;result&lt;/code&gt; （またはnull値）が返されます。これは、Cの &lt;code&gt;switch&lt;/code&gt; ステートメントに似ています。</target>
        </trans-unit>
        <trans-unit id="db81095a43bec432038707d12a55f4ea232797fc" translate="yes" xml:space="preserve">
          <source>The first approach makes use of the &lt;code&gt;cert&lt;/code&gt; authentication method for &lt;code&gt;hostssl&lt;/code&gt; entries in &lt;code&gt;pg_hba.conf&lt;/code&gt;, such that the certificate itself is used for authentication while also providing ssl connection security. See &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt; for details. (It is not necessary to specify any &lt;code&gt;clientcert&lt;/code&gt; options explicitly when using the &lt;code&gt;cert&lt;/code&gt; authentication method.) In this case, the &lt;code&gt;cn&lt;/code&gt; (Common Name) provided in the certificate is checked against the user name or an applicable mapping.</source>
          <target state="translated">最初のアプローチは &lt;code&gt;pg_hba.conf&lt;/code&gt; の &lt;code&gt;hostssl&lt;/code&gt; エントリに &lt;code&gt;cert&lt;/code&gt; 認証方式を利用することで、証明書自体が認証に使用されると同時に、SSL接続のセキュリティも提供されます。詳細は&lt;a href=&quot;auth-cert&quot;&gt;項20.12&lt;/a&gt;を参照してください。 （ &lt;code&gt;cert&lt;/code&gt; 認証方式を使用する場合、 &lt;code&gt;clientcert&lt;/code&gt; オプションを明示的に指定する必要はありません。）この場合、証明書で提供される &lt;code&gt;cn&lt;/code&gt; （共通名）は、ユーザー名または適用可能なマッピングに対してチェックされます。</target>
        </trans-unit>
        <trans-unit id="44f0ace0e5a351af8867382fc6a4698f25099edc" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgChooseIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgChooseOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">最初の引数は、関数の入力データを含む &lt;code&gt;spgChooseIn&lt;/code&gt; C構造体へのポインターです。2番目の引数は &lt;code&gt;spgChooseOut&lt;/code&gt; C構造体へのポインターであり、関数は結果データを入力する必要があります。</target>
        </trans-unit>
        <trans-unit id="73a46dbd547b3476953fd0d40d226d75ab67a447" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgConfigIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgConfigOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">最初の引数は、関数の入力データを含む &lt;code&gt;spgConfigIn&lt;/code&gt; C構造体へのポインターです。2番目の引数は &lt;code&gt;spgConfigOut&lt;/code&gt; C構造体へのポインターであり、関数は結果データを入力する必要があります。</target>
        </trans-unit>
        <trans-unit id="b3d25ba584bb4c4acb9f3461e219135398ddc741" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgInnerConsistentIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgInnerConsistentOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">最初の引数は、関数の入力データを含む &lt;code&gt;spgInnerConsistentIn&lt;/code&gt; C構造体へのポインターです。2番目の引数は、関数が結果データで埋めなければならない &lt;code&gt;spgInnerConsistentOut&lt;/code&gt; C構造体へのポインターです。</target>
        </trans-unit>
        <trans-unit id="4b95190547cc0ff307d0a7948518c66223c69217" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgLeafConsistentIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgLeafConsistentOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">最初の引数は、関数の入力データを含む &lt;code&gt;spgLeafConsistentIn&lt;/code&gt; C構造体へのポインターです。2番目の引数は、関数が結果データで埋めなければならない &lt;code&gt;spgLeafConsistentOut&lt;/code&gt; C構造体へのポインターです。</target>
        </trans-unit>
        <trans-unit id="ca5853d09340bad3adb00c3e57ccca9e872f72bb" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgPickSplitIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgPickSplitOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">最初の引数は、関数の入力データを含む &lt;code&gt;spgPickSplitIn&lt;/code&gt; C構造体へのポインターです。2番目の引数は、関数が結果データで埋めなければならない &lt;code&gt;spgPickSplitOut&lt;/code&gt; C構造体へのポインターです。</target>
        </trans-unit>
        <trans-unit id="1f369dd1771752484284223f6c8b61724d963075" translate="yes" xml:space="preserve">
          <source>The first argument is the relation to be prewarmed. The second argument is the prewarming method to be used, as further discussed below; the third is the relation fork to be prewarmed, usually &lt;code&gt;main&lt;/code&gt;. The fourth argument is the first block number to prewarm (&lt;code&gt;NULL&lt;/code&gt; is accepted as a synonym for zero). The fifth argument is the last block number to prewarm (&lt;code&gt;NULL&lt;/code&gt; means prewarm through the last block in the relation). The return value is the number of blocks prewarmed.</source>
          <target state="translated">最初の引数は、事前に暖められる関係です。 2番目の引数は、以下でさらに説明するように、使用する予熱方法です。 3番目は、事前に暖められる関係フォークで、通常は &lt;code&gt;main&lt;/code&gt; です。 4番目の引数は、事前ウォームする最初のブロック番号です（ &lt;code&gt;NULL&lt;/code&gt; はゼロの同義語として受け入れられます）。 5番目の引数は、事前ウォームする最後のブロック番号です（ &lt;code&gt;NULL&lt;/code&gt; は、関係の最後のブロックまで事前ウォームすることを意味します）。戻り値は、予熱されたブロックの数です。</target>
        </trans-unit>
        <trans-unit id="cd29c1ca625357cd146a327c957cb4b92e5a317e" translate="yes" xml:space="preserve">
          <source>The first century starts at 0001-01-01 00:00:00 AD, although they did not know it at the time. This definition applies to all Gregorian calendar countries. There is no century number 0, you go from -1 century to 1 century. If you disagree with this, please write your complaint to: Pope, Cathedral Saint-Peter of Roma, Vatican.</source>
          <target state="translated">当時は知らなかったが、1世紀は西暦0001-01-01 00:00:00から始まる。この定義はすべてのグレゴリオ暦の国に適用されます。世紀番号0は存在せず、-1世紀から1世紀へと進みます。あなたがこれに同意しない場合は、あなたの苦情を書いてください。ローマ教皇、ローマ大聖堂サン=ペテル、バチカン</target>
        </trans-unit>
        <trans-unit id="256263538ce2e1f28734e2b2ed2dbaa9ee5222c8" translate="yes" xml:space="preserve">
          <source>The first certificate in &lt;code&gt;server.crt&lt;/code&gt; must be the server's certificate because it must match the server's private key. The certificates of &amp;ldquo;intermediate&amp;rdquo; certificate authorities can also be appended to the file. Doing this avoids the necessity of storing intermediate certificates on clients, assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions. This allows easier expiration of intermediate certificates.</source>
          <target state="translated">&lt;code&gt;server.crt&lt;/code&gt; の最初の証明書は、サーバーの秘密鍵と一致する必要があるため、サーバーの証明書でなければなりません。 「中間」認証局の証明書もファイルに追加できます。これにより、ルート証明書と中間証明書が &lt;code&gt;v3_ca&lt;/code&gt; 拡張で作成されたと想定して、中間証明書をクライアントに保存する必要がなくなります。これにより、中間証明書の有効期限が簡単になります。</target>
        </trans-unit>
        <trans-unit id="79f3996eda734e252b355fcb3237a8e729927963" translate="yes" xml:space="preserve">
          <source>The first element specifies that a schema with the same name as the current user is to be searched. If no such schema exists, the entry is ignored. The second element refers to the public schema that we have seen already.</source>
          <target state="translated">最初の要素は、現在のユーザと同じ名前のスキーマを検索することを指定します。そのようなスキーマが存在しない場合、エントリは無視されます。2番目の要素は、すでに見た公開スキーマを参照します。</target>
        </trans-unit>
        <trans-unit id="5dd1c81747f7da19e4955a86256d7b17a34ec6f9" translate="yes" xml:space="preserve">
          <source>The first example adds a time zone to a value that lacks it, and displays the value using the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The second example shifts the time stamp with time zone value to the specified time zone, and returns the value without a time zone. This allows storage and display of values different from the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The third example converts Tokyo time to Chicago time. Converting &lt;em&gt;time&lt;/em&gt; values to other time zones uses the currently active time zone rules since no date is supplied.</source>
          <target state="translated">最初の例では、タイムゾーンを欠落している値に追加し、現在の &lt;code&gt;TimeZone&lt;/code&gt; 設定を使用して値を表示します。2番目の例では、タイムゾーン値を含むタイムスタンプを指定されたタイムゾーンにシフトし、タイムゾーンなしの値を返します。これにより、現在の &lt;code&gt;TimeZone&lt;/code&gt; 設定とは異なる値を保存および表示できます。3番目の例は、東京時間をシカゴ時間に変換します。&lt;em&gt;時間&lt;/em&gt;値を他のタイムゾーンに変換するには、日付が指定されていないため、現在アクティブなタイムゾーンルールが使用されます。</target>
        </trans-unit>
        <trans-unit id="dd4f388d81712247b36f96199e31fe01ab0dcd8a" translate="yes" xml:space="preserve">
          <source>The first example omits &lt;code&gt;ROW&lt;/code&gt;, the second uses it; we could have done it either way.</source>
          <target state="translated">最初の例では &lt;code&gt;ROW&lt;/code&gt; を省略し、2番目の例ではROWを使用しています。どちらにしてもできたはずです。</target>
        </trans-unit>
        <trans-unit id="612c7d9435df3c5121ea73e09ab866021bad4c1b" translate="yes" xml:space="preserve">
          <source>The first example selects the ICU locale using a &amp;ldquo;language tag&amp;rdquo; per BCP 47. The second example uses the traditional ICU-specific locale syntax. The first style is preferred going forward, but it is not supported by older ICU versions.</source>
          <target state="translated">最初の例では、BCP 47の「言語タグ」を使用してICUロケールを選択します。2番目の例では、従来のICU固有のロケール構文を使用します。最初のスタイルは今後推奨されますが、古いICUバージョンではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="f1d60b8c5a21ae5115bceb8211e299ddf895cf0f" translate="yes" xml:space="preserve">
          <source>The first example shows how to spread a command over several lines of input. Notice the changing prompt:</source>
          <target state="translated">最初の例では、コマンドを数行の入力に分散させる方法を示しています。変化するプロンプトに注目してください。</target>
        </trans-unit>
        <trans-unit id="e43256b97dc53da480190315bac59bb3f0cada5f" translate="yes" xml:space="preserve">
          <source>The first form changes certain per-database settings. (See below for details.) Only the database owner or a superuser can change these settings.</source>
          <target state="translated">最初のフォームでは、データベースごとに特定の設定を変更します。(詳細は以下を参照してください。)これらの設定を変更できるのは、データベースの所有者またはスーパーユーザーのみです。</target>
        </trans-unit>
        <trans-unit id="da17ae59b4b9d415d049588fbe4c802a8a77a808" translate="yes" xml:space="preserve">
          <source>The first form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates a composite type. The composite type is specified by a list of attribute names and data types. An attribute's collation can be specified too, if its data type is collatable. A composite type is essentially the same as the row type of a table, but using &lt;code&gt;CREATE TYPE&lt;/code&gt; avoids the need to create an actual table when all that is wanted is to define a type. A stand-alone composite type is useful, for example, as the argument or return type of a function.</source>
          <target state="translated">&lt;code&gt;CREATE TYPE&lt;/code&gt; の最初の形式は、複合型を作成します。複合型は、属性名とデータ型のリストによって指定されます。データ型が照合可能な場合、属性の照合も指定できます。複合タイプは基本的にテーブルの行タイプと同じですが、 &lt;code&gt;CREATE TYPE&lt;/code&gt; を使用すると、タイプを定義するだけで実際のテーブルを作成する必要がなくなります。スタンドアロンの複合型は、たとえば、関数の引数または戻り値の型として役立ちます。</target>
        </trans-unit>
        <trans-unit id="a9da06ff6dbdef653da94da0ffaf44a0aef0024f" translate="yes" xml:space="preserve">
          <source>The first form of aggregate expression invokes the aggregate once for each input row. The second form is the same as the first, since &lt;code&gt;ALL&lt;/code&gt; is the default. The third form invokes the aggregate once for each distinct value of the expression (or distinct set of values, for multiple expressions) found in the input rows. The fourth form invokes the aggregate once for each input row; since no particular input value is specified, it is generally only useful for the &lt;code&gt;count(*)&lt;/code&gt; aggregate function. The last form is used with &lt;em&gt;ordered-set&lt;/em&gt; aggregate functions, which are described below.</source>
          <target state="translated">集約式の最初の形式は、入力行ごとに1回、集約を呼び出します。 &lt;code&gt;ALL&lt;/code&gt; がデフォルトであるため、2番目の形式は最初の形式と同じです。 3番目の形式は、入力行にある式の個別の値（または複数の式の場合は個別の値のセット）ごとに1回集計を呼び出します。 4番目の形式は、入力行ごとに1回集計を呼び出します。特定の入力値が指定されていないため、通常は &lt;code&gt;count(*)&lt;/code&gt; 集約関数に対してのみ役立ちます。最後の形式は、以下で説明する&lt;em&gt;順序付き&lt;/em&gt;集合関数で使用されます。</target>
        </trans-unit>
        <trans-unit id="c6c37d2c4cb9171a6fcf0c1214edbc6145fc4b4d" translate="yes" xml:space="preserve">
          <source>The first form of the &lt;code&gt;CREATE TYPE&lt;/code&gt; command, which creates a composite type, conforms to the SQL standard. The other forms are PostgreSQL extensions. The &lt;code&gt;CREATE TYPE&lt;/code&gt; statement in the SQL standard also defines other forms that are not implemented in PostgreSQL.</source>
          <target state="translated">複合タイプを作成する &lt;code&gt;CREATE TYPE&lt;/code&gt; コマンドの最初の形式は、SQL標準に準拠しています。他の形式はPostgreSQL拡張機能です。SQL標準の &lt;code&gt;CREATE TYPE&lt;/code&gt; ステートメントは、PostgreSQLに実装されていない他の形式も定義します。</target>
        </trans-unit>
        <trans-unit id="c38ff028812a13bb491adf5222d97dc3de42b820" translate="yes" xml:space="preserve">
          <source>The first line of an affix class is the header. Fields of an affix rules are listed after the header:</source>
          <target state="translated">アフィックスクラスの最初の行はヘッダーです。アフィックスルールのフィールドは、ヘッダーの後にリストアップされます。</target>
        </trans-unit>
        <trans-unit id="8e805cf56cf5d6631bb0160a0e06bad5df15b037" translate="yes" xml:space="preserve">
          <source>The first number in the &lt;code&gt;-L&lt;/code&gt; argument, 63333, is the port number of your end of the tunnel; it can be any unused port. (IANA reserves ports 49152 through 65535 for private use.) The second number, 5432, is the remote end of the tunnel: the port number your server is using. The name or IP address between the port numbers is the host with the database server you are going to connect to, as seen from the host you are logging in to, which is &lt;code&gt;foo.com&lt;/code&gt; in this example. In order to connect to the database server using this tunnel, you connect to port 63333 on the local machine:</source>
          <target state="translated">&lt;code&gt;-L&lt;/code&gt; 引数の最初の番号63333は、トンネルの終端のポート番号です。未使用のポートにすることができます。 （IANAはプライベート使用のためにポート49152から65535を予約しています。）2番目の番号5432は、トンネルのリモートエンドです。サーバーが使用しているポート番号です。ポート番号間の名前またはIPアドレスは、ログインするホスト（この例では &lt;code&gt;foo.com&lt;/code&gt; )から見て、接続するデータベースサーバーのホストです。このトンネルを使用してデータベースサーバーに接続するには、ローカルマシンのポート63333に接続します。</target>
        </trans-unit>
        <trans-unit id="3f99873fa941c47208f84d01e9069ef478e98de2" translate="yes" xml:space="preserve">
          <source>The first one worked using &lt;em&gt;row level&lt;/em&gt; processing and was implemented deep in the &lt;em&gt;executor&lt;/em&gt;. The rule system was called whenever an individual row had been accessed. This implementation was removed in 1995 when the last official release of the Berkeley Postgres project was transformed into Postgres95.</source>
          <target state="translated">最初のものは&lt;em&gt;行レベルの&lt;/em&gt;処理を使用して機能し、&lt;em&gt;エグゼキュータの&lt;/em&gt;奥深くに実装されました。ルールシステムは、個々の行がアクセスされるたびに呼び出されました。この実装は、Berkeley Postgresプロジェクトの最後の公式リリースがPostgres95に変換された1995年に削除されました。</target>
        </trans-unit>
        <trans-unit id="0fa18c39fe287e28bd5e7314fe8af5727d16d727" translate="yes" xml:space="preserve">
          <source>The first schema in the search path that exists is the default location for creating new objects. That is the reason that by default objects are created in the public schema. When objects are referenced in any other context without schema qualification (table modification, data modification, or query commands) the search path is traversed until a matching object is found. Therefore, in the default configuration, any unqualified access again can only refer to the public schema.</source>
          <target state="translated">検索パスの中で最初に存在するスキーマは、新しいオブジェクトを作成するためのデフォルトの場所です。これが、デフォルトでオブジェクトがパブリックスキーマで作成される理由です。オブジェクトがスキーマの修飾なしに他のコンテキストで参照された場合(テーブルの変更、データの変更、またはクエリコマンド)、検索パスは一致するオブジェクトが見つかるまでトラバースされます。したがって、デフォルトの構成では、修飾されていないアクセスが再びアクセスしても、パブリックスキーマのみを参照することができます。</target>
        </trans-unit>
        <trans-unit id="9f3413da7a0291a52f1a7dcc2b820079440b3c54" translate="yes" xml:space="preserve">
          <source>The first schema named in the search path is called the current schema. Aside from being the first schema searched, it is also the schema in which new tables will be created if the &lt;code&gt;CREATE TABLE&lt;/code&gt; command does not specify a schema name.</source>
          <target state="translated">検索パスで指定された最初のスキーマは、現在のスキーマと呼ばれます。最初に検索されるスキーマの他に、 &lt;code&gt;CREATE TABLE&lt;/code&gt; コマンドでスキーマ名が指定されていない場合に、新しいテーブルが作成されるスキーマでもあります。</target>
        </trans-unit>
        <trans-unit id="9d12bc7a9f0942909d34ace4bd41d7e184667d01" translate="yes" xml:space="preserve">
          <source>The first six lines report some of the most important parameter settings. The next line reports the number of transactions completed and intended (the latter being just the product of number of clients and number of transactions per client); these will be equal unless the run failed before completion. (In &lt;code&gt;-T&lt;/code&gt; mode, only the actual number of transactions is printed.) The last two lines report the number of transactions per second, figured with and without counting the time to start database sessions.</source>
          <target state="translated">最初の6行は、最も重要なパラメータ設定のいくつかを報告しています。次の行は、完了および意図されたトランザクションの数を報告します（後者は、クライアントの数とクライアントごとのトランザクションの数の積です）。完了する前に実行が失敗しない限り、これらは等しくなります。 （ &lt;code&gt;-T&lt;/code&gt; モードでは、実際のトランザクション数のみが出力されます。）最後の2行は、データベースセッションを開始する時間をカウントした場合とカウントしない場合の1秒あたりのトランザクション数を報告します。</target>
        </trans-unit>
        <trans-unit id="46861698534eb993d5363434e9d5cb2bd00b93d2" translate="yes" xml:space="preserve">
          <source>The first step is to generate an auxiliary table containing all the unique words in the documents:</source>
          <target state="translated">まず、文書に含まれるすべてのユニークな単語を含む補助テーブルを生成します。</target>
        </trans-unit>
        <trans-unit id="d440c66135f418ef7372813549a4be5ffe416b8b" translate="yes" xml:space="preserve">
          <source>The first test to see whether you can access the database server is to try to create a database. A running PostgreSQL server can manage many databases. Typically, a separate database is used for each project or for each user.</source>
          <target state="translated">データベースサーバにアクセスできるかどうかの最初のテストは、データベースを作成してみることです。実行中のPostgreSQLサーバは、多くのデータベースを管理することができます。一般的には、プロジェクトごと、あるいはユーザごとに別々のデータベースが使用されます。</target>
        </trans-unit>
        <trans-unit id="c00d09908f3f4ddbf657d8ad0f17eabf84136b00" translate="yes" xml:space="preserve">
          <source>The first three output columns come directly from the table &lt;code&gt;empsalary&lt;/code&gt;, and there is one output row for each row in the table. The fourth column represents an average taken across all the table rows that have the same &lt;code&gt;depname&lt;/code&gt; value as the current row. (This actually is the same function as the non-window &lt;code&gt;avg&lt;/code&gt; aggregate, but the &lt;code&gt;OVER&lt;/code&gt; clause causes it to be treated as a window function and computed across the window frame.)</source>
          <target state="translated">最初の3つの出力列は &lt;code&gt;empsalary&lt;/code&gt; テーブルから直接取得され、テーブルの各行に1つの出力行があります。 4番目の列は、現在の行と同じ &lt;code&gt;depname&lt;/code&gt; 値を持つすべてのテーブル行にわたって取られた平均を表します。 （これは実際には非ウィンドウの &lt;code&gt;avg&lt;/code&gt; 集計と同じ関数ですが、 &lt;code&gt;OVER&lt;/code&gt; 句を指定すると、ウィンドウ関数として扱われ、ウィンドウフレーム全体で計算されます。）</target>
        </trans-unit>
        <trans-unit id="c0413166d43e378dc8855747d05360346ec4b249" translate="yes" xml:space="preserve">
          <source>The first three parameters are inputs:</source>
          <target state="translated">最初の3つのパラメータは入力です。</target>
        </trans-unit>
        <trans-unit id="54956845c90a8b39103dc2ab8d6e4402b710d114" translate="yes" xml:space="preserve">
          <source>The first three variants change which tables are part of the publication. The &lt;code&gt;SET TABLE&lt;/code&gt; clause will replace the list of tables in the publication with the specified one. The &lt;code&gt;ADD TABLE&lt;/code&gt; and &lt;code&gt;DROP TABLE&lt;/code&gt; clauses will add and remove one or more tables from the publication. Note that adding tables to a publication that is already subscribed to will require a &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt; action on the subscribing side in order to become effective.</source>
          <target state="translated">最初の3つのバリアントは、パブリケーションの一部であるテーブルを変更します。 &lt;code&gt;SET TABLE&lt;/code&gt; 句は、指定されたものとパブリケーション内のテーブルのリストを置き換えます。 &lt;code&gt;ADD TABLE&lt;/code&gt; と &lt;code&gt;DROP TABLE&lt;/code&gt; 句は、出版から1つまたは複数のテーブルを追加および削除します。既にサブスクライブされているパブリケーションにテーブルを追加するには、サブスクライブする側で &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt; アクションを有効にする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="70d5b4450dbfd9e788e4338d7701eefa6a67f05f" translate="yes" xml:space="preserve">
          <source>The first trigger argument must be the name of the &lt;code&gt;tsvector&lt;/code&gt; column to be updated. The second argument specifies the text search configuration to be used to perform the conversion. For &lt;code&gt;tsvector_update_trigger&lt;/code&gt;, the configuration name is simply given as the second trigger argument. It must be schema-qualified as shown above, so that the trigger behavior will not change with changes in &lt;code&gt;search_path&lt;/code&gt;. For &lt;code&gt;tsvector_update_trigger_column&lt;/code&gt;, the second trigger argument is the name of another table column, which must be of type &lt;code&gt;regconfig&lt;/code&gt;. This allows a per-row selection of configuration to be made. The remaining argument(s) are the names of textual columns (of type &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, or &lt;code&gt;char&lt;/code&gt;). These will be included in the document in the order given. NULL values will be skipped (but the other columns will still be indexed).</source>
          <target state="translated">最初のトリガー引数は、更新する &lt;code&gt;tsvector&lt;/code&gt; 列の名前でなければなりません。 2番目の引数は、変換を実行するために使用されるテキスト検索構成を指定します。 &lt;code&gt;tsvector_update_trigger&lt;/code&gt; 、コンフィギュレーション名は、単純に第2のトリガ引数として指定されています。上記のようにスキーマ修飾する必要があります。これにより、 &lt;code&gt;search_path&lt;/code&gt; を変更してもトリガーの動作が変更されません。ため &lt;code&gt;tsvector_update_trigger_column&lt;/code&gt; 、第2のトリガ引数は、型のものでなければならない別のテーブルの列の名前である &lt;code&gt;regconfig&lt;/code&gt; 。これにより、構成を行ごとに選択できます。残りの引数は、テキスト列（タイプ &lt;code&gt;text&lt;/code&gt; 、 &lt;code&gt;varchar&lt;/code&gt; ）の名前です。、または &lt;code&gt;char&lt;/code&gt; ）。これらは、指定された順序でドキュメントに含まれます。NULL値はスキップされます（ただし、他の列には引き続きインデックスが付けられます）。</target>
        </trans-unit>
        <trans-unit id="01ce9912b77202e1b48ed397f2bfc3b3783947c2" translate="yes" xml:space="preserve">
          <source>The first two constraints should look familiar. The third one uses a new syntax. It is not attached to a particular column, instead it appears as a separate item in the comma-separated column list. Column definitions and these constraint definitions can be listed in mixed order.</source>
          <target state="translated">最初の2つの制約は見覚えがあるはずです。3番目の制約は新しい構文を使用しています。これは、特定の列には関連付けられず、代わりにカンマで区切られた列リストの別個の項目として表示されます。列定義とこれらの制約定義は、混在した順序でリストアップすることができます。</target>
        </trans-unit>
        <trans-unit id="2927557f90bef3d374c5198102a6e3ea28461171" translate="yes" xml:space="preserve">
          <source>The first two of these we saw already. The form &lt;code&gt;text&lt;/code&gt;&lt;code&gt;@@&lt;/code&gt;&lt;code&gt;tsquery&lt;/code&gt; is equivalent to &lt;code&gt;to_tsvector(x) @@ y&lt;/code&gt;. The form &lt;code&gt;text&lt;/code&gt;&lt;code&gt;@@&lt;/code&gt;&lt;code&gt;text&lt;/code&gt; is equivalent to &lt;code&gt;to_tsvector(x) @@ plainto_tsquery(y)&lt;/code&gt;.</source>
          <target state="translated">すでに見たこれらの最初の2つ。フォーム &lt;code&gt;text&lt;/code&gt; &lt;code&gt;@@&lt;/code&gt; &lt;code&gt;tsquery&lt;/code&gt; と等価である &lt;code&gt;to_tsvector(x) @@ y&lt;/code&gt; 。 &lt;code&gt;text&lt;/code&gt; &lt;code&gt;@@&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; という形式は、 &lt;code&gt;to_tsvector(x) @@ plainto_tsquery(y)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="cdaab7b9b529bcc8f6406321204002fe17ed4b88" translate="yes" xml:space="preserve">
          <source>The first two output columns are used for the current row's key and its parent row's key; they must match the type of the table's key field. The third output column is the depth in the tree and must be of type &lt;code&gt;integer&lt;/code&gt;. If a &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; parameter was given, the next output column is the branch display and must be of type &lt;code&gt;text&lt;/code&gt;. Finally, if an &lt;em&gt;&lt;code&gt;orderby_fld&lt;/code&gt;&lt;/em&gt; parameter was given, the last output column is a serial number, and must be of type &lt;code&gt;integer&lt;/code&gt;.</source>
          <target state="translated">最初の2つの出力列は、現在の行のキーとその親行のキーに使用されます。それらはテーブルのキーフィールドのタイプと一致する必要があります。 3番目の出力列はツリーの深さであり、 &lt;code&gt;integer&lt;/code&gt; 型でなければなりません。場合&lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; &lt;/em&gt;パラメータが与えられた、次の出力列には分岐表示され、タイプのものでなければならない &lt;code&gt;text&lt;/code&gt; 。最後に、&lt;em&gt; &lt;code&gt;orderby_fld&lt;/code&gt; &lt;/em&gt;パラメーターが指定された場合、最後の出力列はシリアル番号であり、 &lt;code&gt;integer&lt;/code&gt; 型でなければなりません。</target>
        </trans-unit>
        <trans-unit id="bf7215eea980a2a0bf86f75a412a5f3cd60fbcd5" translate="yes" xml:space="preserve">
          <source>The first two variants add users to a group or remove them from a group. (Any role can play the part of either a &amp;ldquo;user&amp;rdquo; or a &amp;ldquo;group&amp;rdquo; for this purpose.) These variants are effectively equivalent to granting or revoking membership in the role named as the &amp;ldquo;group&amp;rdquo;; so the preferred way to do this is to use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; or &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;.</source>
          <target state="translated">最初の2つのバリアントは、ユーザーをグループに追加するか、グループから削除します。 （どの役割も、この目的で「ユーザー」または「グループ」の役割を果たすことができます。）これらのバリアントは、「グループ」という名前の役割のメンバーシップを付与または取り消すことと実質的に同等です。そのため、これを行うには、&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;または&lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0b5e370e58213823b4126e17f4b6e7ad4cef2b17" translate="yes" xml:space="preserve">
          <source>The first variant of this command listed in the synopsis can change many of the role attributes that can be specified in &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. (All the possible attributes are covered, except that there are no options for adding or removing memberships; use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; for that.) Attributes not mentioned in the command retain their previous settings. Database superusers can change any of these settings for any role. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can change any of these settings, but only for non-superuser and non-replication roles. Ordinary roles can only change their own password.</source>
          <target state="translated">概要にリストされているこのコマンドの最初のバリアントは、&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;で指定できる多くのロール属性を変更できます。 （メンバーシップを追加または削除するオプションがないことを除いて、可能なすべての属性がカバーされています。そのためには&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;および&lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;を使用してください。）コマンドで言及されていない属性は以前の設定を保持します。データベースのスーパーユーザーは、任意のロールのこれらの設定を変更できます。 &lt;code&gt;CREATEROLE&lt;/code&gt; 特権を持つロールは、これらの設定のいずれかを変更できますが、非スーパーユーザーおよび非レプリケーションロールに対してのみです。通常のロールは、自分のパスワードのみを変更できます。</target>
        </trans-unit>
        <trans-unit id="25ae6ee44a0f0d836e1704c794f00aceb8d356c4" translate="yes" xml:space="preserve">
          <source>The five mandatory user-defined methods are:</source>
          <target state="translated">必須のユーザー定義メソッドは以下の5つです。</target>
        </trans-unit>
        <trans-unit id="72ce333d0c25ef1597b4fa8ad61ed91fb435220e" translate="yes" xml:space="preserve">
          <source>The following &amp;ldquo;parameters&amp;rdquo; are read-only, and are determined when PostgreSQL is compiled or when it is installed. As such, they have been excluded from the sample &lt;code&gt;postgresql.conf&lt;/code&gt; file. These options report various aspects of PostgreSQL behavior that might be of interest to certain applications, particularly administrative front-ends.</source>
          <target state="translated">次の「パラメータ」は読み取り専用であり、PostgreSQLのコンパイル時またはインストール時に決定されます。そのため、サンプルの &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルから除外されています。これらのオプションは、特定のアプリケーション、特に管理フロントエンドに関係する可能性があるPostgreSQLの動作のさまざまな側面を報告します。</target>
        </trans-unit>
        <trans-unit id="f94e73cd2b87aba8e9913a22c540c941db79c62c" translate="yes" xml:space="preserve">
          <source>The following SQL-compatible functions can also be used to obtain the current time value for the corresponding data type: &lt;code&gt;CURRENT_DATE&lt;/code&gt;, &lt;code&gt;CURRENT_TIME&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, &lt;code&gt;LOCALTIME&lt;/code&gt;, &lt;code&gt;LOCALTIMESTAMP&lt;/code&gt;. The latter four accept an optional subsecond precision specification. (See &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-CURRENT&quot;&gt;Section 9.9.4&lt;/a&gt;.) Note that these are SQL functions and are &lt;em&gt;not&lt;/em&gt; recognized in data input strings.</source>
          <target state="translated">次のSQL互換関数を使用して、対応するデータ型の現在の時刻値を取得することもできます： &lt;code&gt;CURRENT_DATE&lt;/code&gt; 、 &lt;code&gt;CURRENT_TIME&lt;/code&gt; 、 &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; 、 &lt;code&gt;LOCALTIME&lt;/code&gt; 、 &lt;code&gt;LOCALTIMESTAMP&lt;/code&gt; 。後者の4つは、オプションのサブ秒精度指定を受け入れます。（&lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-CURRENT&quot;&gt;項9.9.4を&lt;/a&gt;参照してください。）これらはSQL関数であり、データ入力文字列で&lt;em&gt;は&lt;/em&gt;認識され&lt;em&gt;ない&lt;/em&gt;ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="7345097a3373ddd38c8dbf7f484bcb7a83adcfc5" translate="yes" xml:space="preserve">
          <source>The following SQL-standard functions work on bit strings as well as character strings: &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;bit_length&lt;/code&gt;, &lt;code&gt;octet_length&lt;/code&gt;, &lt;code&gt;position&lt;/code&gt;, &lt;code&gt;substring&lt;/code&gt;, &lt;code&gt;overlay&lt;/code&gt;.</source>
          <target state="translated">次のSQL標準関数は、文字列だけでなくビット文字列でも機能します： &lt;code&gt;length&lt;/code&gt; 、 &lt;code&gt;bit_length&lt;/code&gt; 、 &lt;code&gt;octet_length&lt;/code&gt; 、 &lt;code&gt;position&lt;/code&gt; 、 &lt;code&gt;substring&lt;/code&gt; 、 &lt;code&gt;overlay&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
