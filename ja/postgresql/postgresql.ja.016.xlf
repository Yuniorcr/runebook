<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="9bd2c2e8eaa4afd48046645ba794fcbca53b28f4" translate="yes" xml:space="preserve">
          <source>The following additional options are available:</source>
          <target state="translated">以下の追加オプションをご用意しております。</target>
        </trans-unit>
        <trans-unit id="0f218f3efdde351da4f071874c06c4afe80e209d" translate="yes" xml:space="preserve">
          <source>The following are all valid &lt;code&gt;json&lt;/code&gt; (or &lt;code&gt;jsonb&lt;/code&gt;) expressions:</source>
          <target state="translated">以下はすべて有効な &lt;code&gt;json&lt;/code&gt; （または &lt;code&gt;jsonb&lt;/code&gt; ）式です。</target>
        </trans-unit>
        <trans-unit id="c039bfa9f08ddfc0a59acd61d84cddcf4b0d6ac9" translate="yes" xml:space="preserve">
          <source>The following caveats apply to constraint exclusion:</source>
          <target state="translated">制約の除外には、以下の注意事項が適用されます。</target>
        </trans-unit>
        <trans-unit id="ed89af6d7b571e68348aa46975289d8d36b6f9e9" translate="yes" xml:space="preserve">
          <source>The following caveats apply to partitioning implemented using inheritance:</source>
          <target state="translated">継承を用いて実装されたパーティショニングには、以下の注意事項が適用されます。</target>
        </trans-unit>
        <trans-unit id="29e533c6b217bf172992ac716839050a2d3fd0b7" translate="yes" xml:space="preserve">
          <source>The following command can be used to create an index on the &lt;code&gt;id&lt;/code&gt; column, as discussed:</source>
          <target state="translated">説明したように、次のコマンドを使用して &lt;code&gt;id&lt;/code&gt; 列にインデックスを作成できます。</target>
        </trans-unit>
        <trans-unit id="4545d07872378e0f1220b619c3281f607f171dfb" translate="yes" xml:space="preserve">
          <source>The following command defines a new operator, area-equality, for the data type &lt;code&gt;box&lt;/code&gt;:</source>
          <target state="translated">次のコマンドは、データ型 &lt;code&gt;box&lt;/code&gt; に新しい演算子area-equalityを定義します。</target>
        </trans-unit>
        <trans-unit id="55cc91b2b085f350c73a66cbdf6d3a5a0c4fb379" translate="yes" xml:space="preserve">
          <source>The following command-line options are available:</source>
          <target state="translated">以下のコマンドラインオプションが利用できます。</target>
        </trans-unit>
        <trans-unit id="8b5ca5337b558c5af015478dbbd74c89d07107d2" translate="yes" xml:space="preserve">
          <source>The following command-line options control the content and format of the output.</source>
          <target state="translated">以下のコマンドラインオプションは、出力の内容と形式を制御します。</target>
        </trans-unit>
        <trans-unit id="05475cf2eec87e97d8772a07ec18d9fdca7b5435" translate="yes" xml:space="preserve">
          <source>The following command-line options control the database connection parameters.</source>
          <target state="translated">以下のコマンドラインオプションは、データベース接続パラメータを制御します。</target>
        </trans-unit>
        <trans-unit id="220365fea8f99014f431d00f0ea052b58e2c1fcb" translate="yes" xml:space="preserve">
          <source>The following command-line options control the generation of the backup and the running of the program.</source>
          <target state="translated">以下のコマンドラインオプションは、バックアップの生成とプログラムの実行を制御します。</target>
        </trans-unit>
        <trans-unit id="a56b05f8e623fa43fb5bc9f1eeba6d4c3440d581" translate="yes" xml:space="preserve">
          <source>The following command-line options control the location and format of the output and other replication behavior:</source>
          <target state="translated">以下のコマンドラインオプションは、出力の場所とフォーマット、およびその他のレプリケーション動作を制御します。</target>
        </trans-unit>
        <trans-unit id="f449555e10b2046b1ccc209c3ef5b6dce0f90612" translate="yes" xml:space="preserve">
          <source>The following command-line options control the location and format of the output.</source>
          <target state="translated">以下のコマンドラインオプションは、出力の場所と形式を制御します。</target>
        </trans-unit>
        <trans-unit id="00a034b5b9d901cf6c0ba2052c558173c4b654b2" translate="yes" xml:space="preserve">
          <source>The following command-line options control the location and format of the output:</source>
          <target state="translated">以下のコマンドラインオプションは、出力の場所と形式を制御します。</target>
        </trans-unit>
        <trans-unit id="b90c14e70ab12e4fce9bec3bf939f8e3cd367938" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for GSSAPI:</source>
          <target state="translated">GSSAPIでは以下の設定オプションがサポートされています。</target>
        </trans-unit>
        <trans-unit id="46edfe1841a44936730cc915774b2516fbe1a78a" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for PAM:</source>
          <target state="translated">PAM では以下の設定オプションがサポートされています。</target>
        </trans-unit>
        <trans-unit id="514923f06896538a2f8d0943aa9139974686a363" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for RADIUS:</source>
          <target state="translated">RADIUSでは、以下の構成オプションがサポートされています。</target>
        </trans-unit>
        <trans-unit id="acf0b28821a566799fd52288a31f3e25a128c408" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for SSL certificate authentication:</source>
          <target state="translated">SSL 証明書認証では、以下の設定オプションがサポートされています。</target>
        </trans-unit>
        <trans-unit id="bad3bae7c6cb5e9156e0aafc4f4c4d5aa18bfd10" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for SSPI:</source>
          <target state="translated">以下の設定オプションは、SSPI でサポートされています。</target>
        </trans-unit>
        <trans-unit id="be704faf73a86cf08decb39d5cfdd09dedabb81b" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for ident:</source>
          <target state="translated">ident には以下の設定オプションがサポートされています。</target>
        </trans-unit>
        <trans-unit id="7fd3b16b14e5df4be73c034d0d0a8f2f793213cc" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for peer:</source>
          <target state="translated">ピアでは、以下の構成オプションがサポートされています。</target>
        </trans-unit>
        <trans-unit id="b2cc6138e97e8a814646a47d2cd6ecdb0c1d8d16" translate="yes" xml:space="preserve">
          <source>The following configuration options are used in both modes:</source>
          <target state="translated">どちらのモードでも、以下の設定オプションを使用します。</target>
        </trans-unit>
        <trans-unit id="82ae133d649ffad972068d98ba1e0a950ea94086" translate="yes" xml:space="preserve">
          <source>The following containment predicate uses the point syntax, while in fact the second argument is internally represented by a box. This syntax makes it unnecessary to define a separate point type and functions for (box,point) predicates.</source>
          <target state="translated">次の包含述語はポイント構文を使用していますが、実際には第 2 引数は内部的にボックスで表現されています。この構文により、(box,point)述語のために別個のポイント型や関数を定義する必要がありません。</target>
        </trans-unit>
        <trans-unit id="ab1f58c5086fb9d7dbb2dff29ebf934fc1fd38a7" translate="yes" xml:space="preserve">
          <source>The following example command &amp;ldquo;updates&amp;rdquo; the dictionary's definition without actually changing anything.</source>
          <target state="translated">次のコマンド例は、実際には何も変更せずに辞書の定義を「更新」します。</target>
        </trans-unit>
        <trans-unit id="5f20cbbdfc0e4abc07d317b7cde01bad2e3188ac" translate="yes" xml:space="preserve">
          <source>The following example command adds cross-data-type operators and support functions to an operator family that already contains B-tree operator classes for data types &lt;code&gt;int4&lt;/code&gt; and &lt;code&gt;int2&lt;/code&gt;.</source>
          <target state="translated">次のコマンド例では、データ型 &lt;code&gt;int4&lt;/code&gt; および &lt;code&gt;int2&lt;/code&gt; の Bツリー演算子クラスがすでに含まれている演算子族に、データ型間演算子とサポート関数を追加します。</target>
        </trans-unit>
        <trans-unit id="98ce952daa9dd539b9ae5ea67f8fc03311bc7883" translate="yes" xml:space="preserve">
          <source>The following example command changes the language option to &lt;code&gt;dutch&lt;/code&gt;, and removes the stopword option entirely.</source>
          <target state="translated">次のコマンド例は、言語オプションを &lt;code&gt;dutch&lt;/code&gt; に変更し、ストップワードオプションを完全に削除します。</target>
        </trans-unit>
        <trans-unit id="0690fd36226cece879c24f85e0b2a34e7740cb2a" translate="yes" xml:space="preserve">
          <source>The following example command changes the stopword list for a Snowball-based dictionary. Other parameters remain unchanged.</source>
          <target state="translated">次の例のコマンドは、Snowball ベースの辞書のストップワードリストを変更します。他のパラメータは変更されません。</target>
        </trans-unit>
        <trans-unit id="c6c6101649b45994a81cc07611f7c341ccfd2d4d" translate="yes" xml:space="preserve">
          <source>The following example command creates a Snowball-based dictionary with a nonstandard list of stop words.</source>
          <target state="translated">以下の例のコマンドは、標準ではない停止語のリストを持つスノーボールベースの辞書を作成します。</target>
        </trans-unit>
        <trans-unit id="0540cfecb071eb102ec89874893aeae6b2dac906" translate="yes" xml:space="preserve">
          <source>The following example command defines a GiST index operator class for the data type &lt;code&gt;_int4&lt;/code&gt; (array of &lt;code&gt;int4&lt;/code&gt;). See the &lt;a href=&quot;intarray&quot;&gt;intarray&lt;/a&gt; module for the complete example.</source>
          <target state="translated">次のコマンド例は、データ型のためのGiSTインデックス演算子クラスを定義 &lt;code&gt;_int4&lt;/code&gt; （配列 &lt;code&gt;int4&lt;/code&gt; ）。完全な例については、&lt;a href=&quot;intarray&quot;&gt;intarray&lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="ef3a1ce4208d975ebd37d2a046e1777755826724" translate="yes" xml:space="preserve">
          <source>The following example copies a table to the client using the vertical bar (&lt;code&gt;|&lt;/code&gt;) as the field delimiter:</source>
          <target state="translated">次の例では、フィールド区切り文字として縦棒（ &lt;code&gt;|&lt;/code&gt; ）を使用して、クライアントにテーブルをコピーします。</target>
        </trans-unit>
        <trans-unit id="0d013459769f3027ad75584e21efea2204848877" translate="yes" xml:space="preserve">
          <source>The following example illustrates how the &lt;code&gt;XMLNAMESPACES&lt;/code&gt; clause can be used to specify a list of namespaces used in the XML document as well as in the XPath expressions:</source>
          <target state="translated">次の例は、 &lt;code&gt;XMLNAMESPACES&lt;/code&gt; 句を使用して、XMLドキュメントとXPath式で使用される名前空間のリストを指定する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="8120020f967b896e9eb5f42600de6773abdc4c59" translate="yes" xml:space="preserve">
          <source>The following example puts the final account balance from the first query into variable &lt;code&gt;abalance&lt;/code&gt;, and fills variables &lt;code&gt;p_two&lt;/code&gt; and &lt;code&gt;p_three&lt;/code&gt; with integers from the third query. The result of the second query is discarded.</source>
          <target state="translated">次の例では、変数に最初のクエリからの最終的な勘定残高入れ &lt;code&gt;abalance&lt;/code&gt; を、変数がいっぱい &lt;code&gt;p_two&lt;/code&gt; と &lt;code&gt;p_three&lt;/code&gt; 第クエリから整数で。2番目のクエリの結果は破棄されます。</target>
        </trans-unit>
        <trans-unit id="4e0272043332c15e45fca8627b9940585ab0ce4a" translate="yes" xml:space="preserve">
          <source>The following example replaces the &lt;code&gt;english&lt;/code&gt; dictionary with the &lt;code&gt;swedish&lt;/code&gt; dictionary anywhere that &lt;code&gt;english&lt;/code&gt; is used within &lt;code&gt;my_config&lt;/code&gt;.</source>
          <target state="translated">次の例では、 &lt;code&gt;english&lt;/code&gt; 辞書を、 &lt;code&gt;my_config&lt;/code&gt; 内で &lt;code&gt;english&lt;/code&gt; が使用されている場所の &lt;code&gt;swedish&lt;/code&gt; 語の辞書に置き換えます。</target>
        </trans-unit>
        <trans-unit id="a86c39babfe81954fe9ebb108b217aea8248e655" translate="yes" xml:space="preserve">
          <source>The following example shows concatenation of multiple text() nodes, usage of the column name as XPath filter, and the treatment of whitespace, XML comments and processing instructions:</source>
          <target state="translated">次の例は、複数の text()ノードの連結、XPath フィルタとしてのカラム名の使用、空白の処理、XML コメント、処理命令を示しています。</target>
        </trans-unit>
        <trans-unit id="54642b031a2227e507d5a953bc0c97aa2f10ca2d" translate="yes" xml:space="preserve">
          <source>The following example shows how the security label of a table might be changed.</source>
          <target state="translated">次の例では、テーブルのセキュリティラベルを変更する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="b9d0858a7dd21e2c17fd7d8938ac8b2bda33b78f" translate="yes" xml:space="preserve">
          <source>The following example shows the result of estimating a &lt;code&gt;WHERE&lt;/code&gt; condition on the &lt;code&gt;a&lt;/code&gt; column:</source>
          <target state="translated">次の例は、列の &lt;code&gt;WHERE&lt;/code&gt; 条件を推定した結果を示して &lt;code&gt;a&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="04036b5b20e932a63bf10913615aab08c6e7f9bb" translate="yes" xml:space="preserve">
          <source>The following example traverses a table using a cursor:</source>
          <target state="translated">次の例は、カーソルを使用してテーブルをトラバースします。</target>
        </trans-unit>
        <trans-unit id="b0c8644502b27c5f09c1b2cd46083c907b3859da" translate="yes" xml:space="preserve">
          <source>The following examples will illustrate the usage of all three notations, using the following function definition:</source>
          <target state="translated">以下の例では、以下の関数定義を使用して、3つの表記法すべての使用法を説明します。</target>
        </trans-unit>
        <trans-unit id="ddc2a5eced86eee0d88b99c3c79c239f1015ae7c" translate="yes" xml:space="preserve">
          <source>The following functions allow direct testing of a text search parser.</source>
          <target state="translated">以下の関数では、テキスト検索パーサを直接テストすることができます。</target>
        </trans-unit>
        <trans-unit id="5e0070eaa8f2988c475085144814bd098c68e7d6" translate="yes" xml:space="preserve">
          <source>The following functions are available if libxslt is installed:</source>
          <target state="translated">libxslt がインストールされている場合、以下の機能が利用できます。</target>
        </trans-unit>
        <trans-unit id="6868f6a5c512b545d6b54882e8a5b465e4040e96" translate="yes" xml:space="preserve">
          <source>The following functions are available to delay execution of the server process:</source>
          <target state="translated">サーバプロセスの実行を遅らせるために、以下の機能を利用できます。</target>
        </trans-unit>
        <trans-unit id="7eaa7ab3c8107e57a840871a19a9fd7639ac2e60" translate="yes" xml:space="preserve">
          <source>The following functions map the contents of relational tables to XML values. They can be thought of as XML export functionality:</source>
          <target state="translated">以下の関数は、リレーショナルテーブルの内容をXML値にマッピングします。これらはXMLエクスポート機能と考えることができます。</target>
        </trans-unit>
        <trans-unit id="d99534b0054b1dbaf525bfa83dffbf3dceb4ed5a" translate="yes" xml:space="preserve">
          <source>The following functions produce XML data mappings and the corresponding XML Schema in one document (or forest), linked together. They can be useful where self-contained and self-describing results are wanted:</source>
          <target state="translated">以下の関数は、XMLデータのマッピングとそれに対応するXMLスキーマを、1つのドキュメント(あるいはフォレスト)の中にまとめてリンクしたものです。これらの関数は、自己完結型で自己記述的な結果が必要な場合に便利です。</target>
        </trans-unit>
        <trans-unit id="0717a340e1889a17503b962f24442ac075bb61f2" translate="yes" xml:space="preserve">
          <source>The following functions return XML Schema documents describing the mappings performed by the corresponding functions above:</source>
          <target state="translated">以下の関数は、上記の対応する関数によって実行されるマッピングを記述したXMLスキーマ文書を返す。</target>
        </trans-unit>
        <trans-unit id="87e9cfe2ae99c540eae639b3c0d4e7139991c05c" translate="yes" xml:space="preserve">
          <source>The following functions work on bit strings as well as binary strings: &lt;code&gt;get_bit&lt;/code&gt;, &lt;code&gt;set_bit&lt;/code&gt;. When working with a bit string, these functions number the first (leftmost) bit of the string as bit 0.</source>
          <target state="translated">次の関数は、ビット文字列とバイナリ文字列で機能します： &lt;code&gt;get_bit&lt;/code&gt; 、 &lt;code&gt;set_bit&lt;/code&gt; 。ビット文字列を処理する場合、これらの関数は文字列の最初（左端）のビットをビット0として番号付けします。</target>
        </trans-unit>
        <trans-unit id="f8888d531981405af8909029406e91231d32e3fc" translate="yes" xml:space="preserve">
          <source>The following is an equivalent way of accomplishing the same result:</source>
          <target state="translated">以下は、同じ結果を達成するための同等の方法です。</target>
        </trans-unit>
        <trans-unit id="f5156ec918109db1c50b00eba83d4a25d3045435" translate="yes" xml:space="preserve">
          <source>The following is divided into three subsections. Different options are used during database initialization and while running benchmarks, but some options are useful in both cases.</source>
          <target state="translated">以下、3つのサブセクションに分けて説明します。データベースの初期化中とベンチマーク実行中では異なるオプションが使用されますが、どちらの場合でも有用なオプションがあります。</target>
        </trans-unit>
        <trans-unit id="647af377018af1687ed8efb04b9618837aa7790d" translate="yes" xml:space="preserve">
          <source>The following is the same data, output in binary format. The data is shown after filtering through the Unix utility &lt;code&gt;od -c&lt;/code&gt;. The table has three columns; the first has type &lt;code&gt;char(2)&lt;/code&gt;, the second has type &lt;code&gt;text&lt;/code&gt;, and the third has type &lt;code&gt;integer&lt;/code&gt;. All the rows have a null value in the third column.</source>
          <target state="translated">以下は同じデータで、バイナリ形式で出力されます。データは、Unixユーティリティ &lt;code&gt;od -c&lt;/code&gt; でフィルタリングした後に表示されます。テーブルには3つの列があります。最初の型は &lt;code&gt;char(2)&lt;/code&gt; 型、2番目の型は &lt;code&gt;text&lt;/code&gt; 型、3番目の型は &lt;code&gt;integer&lt;/code&gt; 型です。すべての行の3列目にnull値があります。</target>
        </trans-unit>
        <trans-unit id="eda35f89f366a92b9c1f3ee20bc9ca7f81e63cc1" translate="yes" xml:space="preserve">
          <source>The following less trivial example writes the Russian word &amp;ldquo;slon&amp;rdquo; (elephant) in Cyrillic letters:</source>
          <target state="translated">次の簡単な例では、ロシア語の「slon」（象）をキリル文字で表記しています。</target>
        </trans-unit>
        <trans-unit id="189e345b5ef4ff87c793abeb8737dfccbc0f04c1" translate="yes" xml:space="preserve">
          <source>The following limitations apply to partitioned tables:</source>
          <target state="translated">パーティショニングされたテーブルには、以下の制限が適用されます。</target>
        </trans-unit>
        <trans-unit id="44e788f5edc12a91d7e7f317a229ad70f5f2729c" translate="yes" xml:space="preserve">
          <source>The following meta-commands are defined:</source>
          <target state="translated">以下のメタコマンドが定義されています。</target>
        </trans-unit>
        <trans-unit id="cd608061d746b035415cdac00c81458451b62316" translate="yes" xml:space="preserve">
          <source>The following methods for collecting the write-ahead logs are supported:</source>
          <target state="translated">書込みログの収集方法は、以下の方法がサポートされています。</target>
        </trans-unit>
        <trans-unit id="a56049877daf2d04bdadddbc86e9035f590ef7d4" translate="yes" xml:space="preserve">
          <source>The following non-standard approach used to be recommended in previous versions, and may still be useful in specific cases:</source>
          <target state="translated">以前のバージョンでは、以下のような非標準的なアプローチが推奨されていましたが、特定のケースではまだ有用な場合があります。</target>
        </trans-unit>
        <trans-unit id="8a441d0a9d0ce26e47c5d9596d3d57e320cb00a5" translate="yes" xml:space="preserve">
          <source>The following operations are always parallel restricted.</source>
          <target state="translated">以下の操作は常に並列制限されています。</target>
        </trans-unit>
        <trans-unit id="51e78db2119a951e7a8c9fc8a972d223a3355886" translate="yes" xml:space="preserve">
          <source>The following options are only needed when &lt;code&gt;pg_resetwal&lt;/code&gt; is unable to determine appropriate values by reading &lt;code&gt;pg_control&lt;/code&gt;. Safe values can be determined as described below. For values that take numeric arguments, hexadecimal values can be specified by using the prefix &lt;code&gt;0x&lt;/code&gt;.</source>
          <target state="translated">以下のオプションは、 &lt;code&gt;pg_resetwal&lt;/code&gt; が &lt;code&gt;pg_control&lt;/code&gt; を読み取って適切な値を決定できない場合にのみ必要です。安全値は以下のように決定できます。数値引数を取る値の場合、プレフィックス &lt;code&gt;0x&lt;/code&gt; を使用して16進値を指定できます。</target>
        </trans-unit>
        <trans-unit id="69bed63b9b9fa472f1bfef341fe738b22ca2d102" translate="yes" xml:space="preserve">
          <source>The following options are used in search+bind mode only:</source>
          <target state="translated">以下のオプションは、検索+バインドモードでのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="a727fc2f66779d9648449bd2ed769b9bf5969532" translate="yes" xml:space="preserve">
          <source>The following options are used in simple bind mode only:</source>
          <target state="translated">以下のオプションは、シンプルバインドモードでのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="537f6640d02bb24a88ec9d9b40defc6c0eca02e5" translate="yes" xml:space="preserve">
          <source>The following options further specify the recovery target, and affect what happens when the target is reached:</source>
          <target state="translated">以下のオプションは、回復目標をさらに指定し、目標に到達したときに何が起こるかに影響を与えます。</target>
        </trans-unit>
        <trans-unit id="7135a7643cb1d0d74cb2e4a970ae91d9faed5be8" translate="yes" xml:space="preserve">
          <source>The following options only apply to the single-user mode (see &lt;a href=&quot;app-postgres#APP-POSTGRES-SINGLE-USER&quot;&gt;Single-User Mode&lt;/a&gt;).</source>
          <target state="translated">次のオプションは、シングルユーザーモードにのみ適用されます（&lt;a href=&quot;app-postgres#APP-POSTGRES-SINGLE-USER&quot;&gt;シングルユーザーモードを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="4e806d19c35f4be356192bcaf56df7bac7d67cbd" translate="yes" xml:space="preserve">
          <source>The following parameters are intended for work on the PostgreSQL source code, and in some cases to assist with recovery of severely damaged databases. There should be no reason to use them on a production database. As such, they have been excluded from the sample &lt;code&gt;postgresql.conf&lt;/code&gt; file. Note that many of these parameters require special source compilation flags to work at all.</source>
          <target state="translated">以下のパラメーターは、PostgreSQLソースコードでの作業、および場合によっては、深刻な損傷を受けたデータベースの回復を支援することを目的としています。本番データベースで使用する理由はありません。そのため、これらはサンプルの &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルから除外されています。これらのパラメータの多くが機能するには、特別なソースコンパイルフラグが必要です。</target>
        </trans-unit>
        <trans-unit id="4026e02031547a37479fb9b05f84b97775d5fe92" translate="yes" xml:space="preserve">
          <source>The following query can be used to identify all collations in the current database that need to be refreshed and the objects that depend on them:</source>
          <target state="translated">以下のクエリを使用して、現在のデータベース内でリフレッシュが必要な照合順序と、それに依存するオブジェクトをすべて特定することができます。</target>
        </trans-unit>
        <trans-unit id="c0122a37523d76103f38f449cd343e0b060ab0d9" translate="yes" xml:space="preserve">
          <source>The following query shows all defined operator classes:</source>
          <target state="translated">次のクエリは、定義されたすべての演算子クラスを表示します。</target>
        </trans-unit>
        <trans-unit id="8cfe858c80303e50296d8f2a37810c84b510900d" translate="yes" xml:space="preserve">
          <source>The following resources contain additional information about genetic algorithms:</source>
          <target state="translated">以下のリソースには、遺伝的アルゴリズムに関する追加情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="327c23aaa47c9cad7b97d5d2a03e766b6d51df50" translate="yes" xml:space="preserve">
          <source>The following sections describe the authentication methods in more detail.</source>
          <target state="translated">以下では、認証方法について詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="aeb4c79f6ac510d43001882e836e62ac542ea4a4" translate="yes" xml:space="preserve">
          <source>The following sections describe the details of the select list, the table expression, and the sort specification. &lt;code&gt;WITH&lt;/code&gt; queries are treated last since they are an advanced feature.</source>
          <target state="translated">次のセクションでは、選択リスト、テーブル式、およびソート仕様の詳細について説明します。 &lt;code&gt;WITH&lt;/code&gt; クエリは高度な機能であるため、最後に処理されます。</target>
        </trans-unit>
        <trans-unit id="9d4ca436eba9354db1bd47061237b54b62f2b67c" translate="yes" xml:space="preserve">
          <source>The following special backslash sequences are recognized by &lt;code&gt;COPY FROM&lt;/code&gt;:</source>
          <target state="translated">次の特殊なバックスラッシュシーケンスは &lt;code&gt;COPY FROM&lt;/code&gt; によって認識されます。</target>
        </trans-unit>
        <trans-unit id="8f427c4f9638a34d3033435ec6c0132981a12871" translate="yes" xml:space="preserve">
          <source>The following steps occur in a concurrent reindex. Each step is run in a separate transaction. If there are multiple indexes to be rebuilt, then each step loops through all the indexes before moving to the next step.</source>
          <target state="translated">以下のステップは、同時再インデックスで発生します。各ステップは個別のトランザクションで実行されます。再構築するインデックスが複数ある場合、各ステップは次のステップに移る前にすべてのインデックスをループします。</target>
        </trans-unit>
        <trans-unit id="e32c87e22cead595c4cbd93a657097e6823f09e3" translate="yes" xml:space="preserve">
          <source>The following subsections describe the kinds of extended statistics that are currently supported.</source>
          <target state="translated">以下のサブセクションでは、現在サポートされている拡張統計の種類について説明します。</target>
        </trans-unit>
        <trans-unit id="542557b3d5f6134bfa542b4b0f72c63ee404d9ac" translate="yes" xml:space="preserve">
          <source>The following syntax was used before PostgreSQL version 7.3 and is still supported:</source>
          <target state="translated">以下の構文はPostgreSQLバージョン7.3以前に使用されていたもので、現在もサポートされています。</target>
        </trans-unit>
        <trans-unit id="cb4264d6fcf534ad0d711543bbbad940acfd384f" translate="yes" xml:space="preserve">
          <source>The following syntax was used before PostgreSQL version 9.0 and is still supported:</source>
          <target state="translated">以下の構文はPostgreSQLバージョン9.0以前に使用されていたもので、現在もサポートされています。</target>
        </trans-unit>
        <trans-unit id="7ffe77d533e655164667efaec733a8644752fd0c" translate="yes" xml:space="preserve">
          <source>The following table summarizes which types of triggers may be used on tables, views, and foreign tables:</source>
          <target state="translated">次の表は、テーブル、ビュー、および外部テーブルで使用できるトリガーの種類をまとめたものです。</target>
        </trans-unit>
        <trans-unit id="b9dedb03b6c7c1e94159053f8cafdd1b64ee1259" translate="yes" xml:space="preserve">
          <source>The following two examples are identical ways of sorting the individual results according to the contents of the second column (&lt;code&gt;name&lt;/code&gt;):</source>
          <target state="translated">次の2つの例は、2番目の列（ &lt;code&gt;name&lt;/code&gt; ）の内容に従って個々の結果をソートする同じ方法です。</target>
        </trans-unit>
        <trans-unit id="f82d287994dca1133e1c905ec21b4420d1348aaa" translate="yes" xml:space="preserve">
          <source>The following types (or spellings thereof) are specified by SQL: &lt;code&gt;bigint&lt;/code&gt;, &lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;bit varying&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;character varying&lt;/code&gt;, &lt;code&gt;character&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;double precision&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;decimal&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt; (with or without time zone), &lt;code&gt;timestamp&lt;/code&gt; (with or without time zone), &lt;code&gt;xml&lt;/code&gt;.</source>
          <target state="translated">次のタイプ（またはそのスペル）はSQLによって指定されています： &lt;code&gt;bigint&lt;/code&gt; 、 &lt;code&gt;bit&lt;/code&gt; 、 &lt;code&gt;bit varying&lt;/code&gt; 、 &lt;code&gt;boolean&lt;/code&gt; 、 &lt;code&gt;char&lt;/code&gt; 、 &lt;code&gt;character varying&lt;/code&gt; 、 &lt;code&gt;character&lt;/code&gt; 、 &lt;code&gt;varchar&lt;/code&gt; 、 &lt;code&gt;date&lt;/code&gt; 、 &lt;code&gt;double precision&lt;/code&gt; 、 &lt;code&gt;integer&lt;/code&gt; 、 &lt;code&gt;interval&lt;/code&gt; 、 &lt;code&gt;numeric&lt;/code&gt; 、 &lt;code&gt;decimal&lt;/code&gt; 、 &lt;code&gt;real&lt;/code&gt; 、 &lt;code&gt;smallint&lt;/code&gt; 、 &lt;code&gt;time&lt;/code&gt; （タイムゾーンの有無にかかわらず）、 &lt;code&gt;timestamp&lt;/code&gt; （タイムゾーンの有無にかかわらず）、 &lt;code&gt;xml&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="008f4840c9bbbc114acf97e5143a54c88f68912b" translate="yes" xml:space="preserve">
          <source>The following types of administration commands are not accepted during recovery mode:</source>
          <target state="translated">リカバリーモード中は、以下の種類の管理コマンドは受け付けられません。</target>
        </trans-unit>
        <trans-unit id="d4a4cbf72726623686906a4dfcab95be0271a53f" translate="yes" xml:space="preserve">
          <source>The following types of parallel-aware table scans are currently supported.</source>
          <target state="translated">現在、以下のタイプの並列対応テーブルスキャンがサポートされています。</target>
        </trans-unit>
        <trans-unit id="45ec767602366e0da0c6d60741f363eda41896e3" translate="yes" xml:space="preserve">
          <source>The foreign server to import from.</source>
          <target state="translated">インポート元の海外サーバー。</target>
        </trans-unit>
        <trans-unit id="fbe288bd62bdf2a35ec4994319ad86594322f65f" translate="yes" xml:space="preserve">
          <source>The foreign-data wrapper name must be unique within the database.</source>
          <target state="translated">外部データのラッパー名はデータベース内で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="128070d44af946b3f1ecf65ccd252fb06b8cf14f" translate="yes" xml:space="preserve">
          <source>The format of a psql command is the backslash, followed immediately by a command verb, then any arguments. The arguments are separated from the command verb and each other by any number of whitespace characters.</source>
          <target state="translated">psqlコマンドの形式は、バックスラッシュの後にコマンド動詞が続き、その後に引数が続きます。引数は、コマンド動詞から任意の数の空白文字で区切られています。</target>
        </trans-unit>
        <trans-unit id="7f3c7541e2c4fcc461ec02ccb2547741ee4be834" translate="yes" xml:space="preserve">
          <source>The format of the log is:</source>
          <target state="translated">ログの形式は</target>
        </trans-unit>
        <trans-unit id="c1adf1c1ec6d1279c3ae3b2793de10b99dbd36d4" translate="yes" xml:space="preserve">
          <source>The formatting function &lt;code&gt;to_char&lt;/code&gt; (see &lt;a href=&quot;functions-formatting&quot;&gt;Section 9.8&lt;/a&gt;) is also available as a more flexible way to format date/time output.</source>
          <target state="translated">日付/時刻出力をフォーマットするより柔軟な方法として、フォーマット関数 &lt;code&gt;to_char&lt;/code&gt; （&lt;a href=&quot;functions-formatting&quot;&gt;セクション9.8を&lt;/a&gt;参照）も使用できます。</target>
        </trans-unit>
        <trans-unit id="9ba5e32cb8a2291627c08e67bf1bfb6249955cd8" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;ADD&lt;/code&gt; (without &lt;code&gt;USING INDEX&lt;/code&gt;), &lt;code&gt;DROP [COLUMN]&lt;/code&gt;, &lt;code&gt;DROP IDENTITY&lt;/code&gt;, &lt;code&gt;RESTART&lt;/code&gt;, &lt;code&gt;SET DEFAULT&lt;/code&gt;, &lt;code&gt;SET DATA TYPE&lt;/code&gt; (without &lt;code&gt;USING&lt;/code&gt;), &lt;code&gt;SET GENERATED&lt;/code&gt;, and &lt;code&gt;SET sequence_option&lt;/code&gt; conform with the SQL standard. The other forms are PostgreSQL extensions of the SQL standard. Also, the ability to specify more than one manipulation in a single &lt;code&gt;ALTER TABLE&lt;/code&gt; command is an extension.</source>
          <target state="translated">&lt;code&gt;ADD&lt;/code&gt; （ &lt;code&gt;USING INDEX&lt;/code&gt; なし）、 &lt;code&gt;DROP [COLUMN]&lt;/code&gt; 、 &lt;code&gt;DROP IDENTITY&lt;/code&gt; 、 &lt;code&gt;RESTART&lt;/code&gt; 、 &lt;code&gt;SET DEFAULT&lt;/code&gt; 、 &lt;code&gt;SET DATA TYPE&lt;/code&gt; （ &lt;code&gt;USING&lt;/code&gt; なし）、 &lt;code&gt;SET GENERATED&lt;/code&gt; 、および &lt;code&gt;SET sequence_option&lt;/code&gt; の形式は、SQL標準に準拠しています。その他の形式は、SQL標準のPostgreSQL拡張機能です。また、単一の &lt;code&gt;ALTER TABLE&lt;/code&gt; コマンドで複数の操作を指定する機能は拡張機能です。</target>
        </trans-unit>
        <trans-unit id="60e0a26739b6392b783c8e0781017e51a86f2c82" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;DROP&lt;/code&gt;, and &lt;code&gt;SET DATA TYPE&lt;/code&gt; conform with the SQL standard. The other forms are PostgreSQL extensions of the SQL standard. Also, the ability to specify more than one manipulation in a single &lt;code&gt;ALTER FOREIGN TABLE&lt;/code&gt; command is an extension.</source>
          <target state="translated">フォーム &lt;code&gt;ADD&lt;/code&gt; 、 &lt;code&gt;DROP&lt;/code&gt; 、および &lt;code&gt;SET DATA TYPE&lt;/code&gt; は、SQL標準に準拠しています。その他の形式は、SQL標準のPostgreSQL拡張機能です。また、1つの &lt;code&gt;ALTER FOREIGN TABLE&lt;/code&gt; コマンドで複数の操作を指定する機能も拡張されています。</target>
        </trans-unit>
        <trans-unit id="ceb183e300587222b81cf3fc6aa4245c9a8136ea" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;NEXT&lt;/code&gt;, &lt;code&gt;PRIOR&lt;/code&gt;, &lt;code&gt;FIRST&lt;/code&gt;, &lt;code&gt;LAST&lt;/code&gt;, &lt;code&gt;ABSOLUTE&lt;/code&gt;, &lt;code&gt;RELATIVE&lt;/code&gt; fetch a single row after moving the cursor appropriately. If there is no such row, an empty result is returned, and the cursor is left positioned before the first row or after the last row as appropriate.</source>
          <target state="translated">&lt;code&gt;NEXT&lt;/code&gt; 、 &lt;code&gt;PRIOR&lt;/code&gt; 、 &lt;code&gt;FIRST&lt;/code&gt; 、 &lt;code&gt;LAST&lt;/code&gt; 、 &lt;code&gt;ABSOLUTE&lt;/code&gt; 、 &lt;code&gt;RELATIVE&lt;/code&gt; の形式は、カーソルを適切に移動した後に単一の行をフェッチします。そのような行がない場合、空の結果が返され、カーソルは必要に応じて最初の行の前または最後の行の後に置かれます。</target>
        </trans-unit>
        <trans-unit id="2588add0e86c17b12a1c6aa4f12342731ddacd9b" translate="yes" xml:space="preserve">
          <source>The forms using &lt;code&gt;FORWARD&lt;/code&gt; and &lt;code&gt;BACKWARD&lt;/code&gt; retrieve the indicated number of rows moving in the forward or backward direction, leaving the cursor positioned on the last-returned row (or after/before all rows, if the &lt;code&gt;count&lt;/code&gt; exceeds the number of rows available).</source>
          <target state="translated">&lt;code&gt;FORWARD&lt;/code&gt; と &lt;code&gt;BACKWARD&lt;/code&gt; を使用するフォームは、前方または後方に移動する指定された数の行を取得し、最後に返された行（または、 &lt;code&gt;count&lt;/code&gt; が使用可能な行数を超える場合はすべての行の前後）にカーソルを置きます。</target>
        </trans-unit>
        <trans-unit id="38a28d1e90b500392094fc0f5e04fc9e1934bc5b" translate="yes" xml:space="preserve">
          <source>The forms using &lt;code&gt;{&lt;/code&gt;&lt;code&gt;...&lt;/code&gt;&lt;code&gt;}&lt;/code&gt; are known as &lt;em&gt;bounds&lt;/em&gt;. The numbers &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; within a bound are unsigned decimal integers with permissible values from 0 to 255 inclusive.</source>
          <target state="translated">&lt;code&gt;{&lt;/code&gt; &lt;code&gt;...&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; を使用するフォームは、&lt;em&gt;境界と&lt;/em&gt;呼ばれ&lt;em&gt;ます&lt;/em&gt;。範囲内の数値 &lt;code&gt;m&lt;/code&gt; と &lt;code&gt;n&lt;/code&gt; は、0から255までの許容値を持つ符号なし10進整数です。</target>
        </trans-unit>
        <trans-unit id="35372a44df7778273e762917011aca61a01afe9f" translate="yes" xml:space="preserve">
          <source>The forward transition function for moving-aggregate mode is not allowed to return NULL as the new state value. If the inverse transition function returns NULL, this is taken as an indication that the inverse function cannot reverse the state calculation for this particular input, and so the aggregate calculation will be redone from scratch for the current frame starting position. This convention allows moving-aggregate mode to be used in situations where there are some infrequent cases that are impractical to reverse out of the running state value.</source>
          <target state="translated">移動アグリゲートモードの正転遷移関数は、新しい状態値として NULL を返すことはできません。逆遷移関数が NULL を返した場合は、逆関数がこの特定の入力の状態計算を逆にできないことを示しており、現在のフレーム開始位置のために一から集計計算をやり直すことになります。この規約により、実行中の状態値から逆算することが現実的ではないケースが稀にある場合に、移動アグリゲートモードを使用することができます。</target>
        </trans-unit>
        <trans-unit id="ab5226a0f4072d37673ee94afa6e18b7e80854c8" translate="yes" xml:space="preserve">
          <source>The fourth form changes the default tablespace of the database. Only the database owner or a superuser can do this; you must also have create privilege for the new tablespace. This command physically moves any tables or indexes in the database's old default tablespace to the new tablespace. The new default tablespace must be empty for this database, and no one can be connected to the database. Tables and indexes in non-default tablespaces are unaffected.</source>
          <target state="translated">4 番目のフォームでは、データベースのデフォルトのテーブルスペースを変更します。これは、データベース所有者またはスーパーユーザーのみが行うことができ、新しいテーブルスペースの作成権限を持っている必要があります。このコマンドは、データベースの古い既定のテーブル空間にあるテーブルまたはインデックスを新しいテーブル空間に物理的に移動します。新しい既定のテーブルスペースは、このデータベースでは空でなければならず、データベースには誰も接続できません。既定でないテーブルスペースのテーブルとインデックスは影響を受けません。</target>
        </trans-unit>
        <trans-unit id="36812cc6bb8478aaca401b63d7fbabaea11a3122" translate="yes" xml:space="preserve">
          <source>The fourth form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates a new base type (scalar type). To create a new base type, you must be a superuser. (This restriction is made because an erroneous type definition could confuse or even crash the server.)</source>
          <target state="translated">&lt;code&gt;CREATE TYPE&lt;/code&gt; の4番目の形式は、新しい基本型（スカラー型）を作成します。新しい基本タイプを作成するには、スーパーユーザーである必要があります。（この制限は、誤った型定義がサーバーを混乱させたり、場合によってはクラッシュさせる可能性があるためです。）</target>
        </trans-unit>
        <trans-unit id="9a5bc0cc22101b5b7b3dd6dc1462291809c736e9" translate="yes" xml:space="preserve">
          <source>The fourth variant of this command listed in the synopsis can change all of the publication properties specified in &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;. Properties not mentioned in the command retain their previous settings.</source>
          <target state="translated">概要にリストされているこのコマンドの4番目のバリアントは、&lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATIONで&lt;/a&gt;指定されたすべてのパブリケーションプロパティを変更できます。コマンドに記載されていないプロパティは、以前の設定を保持します。</target>
        </trans-unit>
        <trans-unit id="dea2017c78cbd95284b251ddbea3a7b1e10a923d" translate="yes" xml:space="preserve">
          <source>The fraction of the column's entries that are null</source>
          <target state="translated">カラムのエントリがヌルである割合</target>
        </trans-unit>
        <trans-unit id="44d7567a007c45862dffe28ca10785cde8529aa6" translate="yes" xml:space="preserve">
          <source>The full SQL type syntax is allowed for declaring a function's arguments and return value. However, parenthesized type modifiers (e.g., the precision field for type &lt;code&gt;numeric&lt;/code&gt;) are discarded by &lt;code&gt;CREATE FUNCTION&lt;/code&gt;. Thus for example &lt;code&gt;CREATE FUNCTION foo (varchar(10)) ...&lt;/code&gt; is exactly the same as &lt;code&gt;CREATE FUNCTION foo (varchar) ...&lt;/code&gt;.</source>
          <target state="translated">関数の引数と戻り値を宣言するには、完全なSQL型構文を使用できます。ただし、括弧で囲まれた型修飾子（たとえば、 &lt;code&gt;numeric&lt;/code&gt; 型の精度フィールド）は &lt;code&gt;CREATE FUNCTION&lt;/code&gt; によって破棄されます。したがって、たとえば &lt;code&gt;CREATE FUNCTION foo (varchar(10)) ...&lt;/code&gt; はCREATE FUNCTION foo（varchar）...とまったく同じ &lt;code&gt;CREATE FUNCTION foo (varchar) ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b36f659c83072f67d547396d3e51c25042456bdd" translate="yes" xml:space="preserve">
          <source>The full host name (with domain name) of the database server, or &lt;code&gt;[local]&lt;/code&gt; if the connection is over a Unix domain socket, or &lt;code&gt;[local:/dir/name]&lt;/code&gt;, if the Unix domain socket is not at the compiled in default location.</source>
          <target state="translated">データベースサーバーの完全なホスト名（ドメイン名付き）、または接続がUnixドメインソケットを介している場合は &lt;code&gt;[local]&lt;/code&gt; 、またはUnixドメインソケットがデフォルトでコンパイルされていない場合は &lt;code&gt;[local:/dir/name]&lt;/code&gt; ロケーション。</target>
        </trans-unit>
        <trans-unit id="51d56119fb00f5592b9aaa01b9f5e760e9ad4329" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;current_setting&lt;/code&gt; produces equivalent output; see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.26&lt;/a&gt;. Also, the &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; system view produces the same information.</source>
          <target state="translated">関数 &lt;code&gt;current_setting&lt;/code&gt; は同等の出力を生成します。&lt;a href=&quot;functions-admin&quot;&gt;セクション9.26を&lt;/a&gt;参照してください。また、&lt;a href=&quot;view-pg-settings&quot;&gt; &lt;code&gt;pg_settings&lt;/code&gt; &lt;/a&gt;システムビューでも同じ情報が生成されます。</target>
        </trans-unit>
        <trans-unit id="afa8c22afca8c86aa84834df3d7365a4c4ad70ab" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;current_setting&lt;/code&gt; yields the current value of the setting &lt;em&gt;&lt;code&gt;setting_name&lt;/code&gt;&lt;/em&gt;. It corresponds to the SQL command &lt;code&gt;SHOW&lt;/code&gt;. An example:</source>
          <target state="translated">関数 &lt;code&gt;current_setting&lt;/code&gt; は、設定&lt;em&gt; &lt;code&gt;setting_name&lt;/code&gt; の&lt;/em&gt;現在の値を生成します。これは、SQLコマンド &lt;code&gt;SHOW&lt;/code&gt; に対応しています。例：</target>
        </trans-unit>
        <trans-unit id="f6649ace670e65e10a1490b2ecf7a4829ee526f2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;date_trunc&lt;/code&gt; is conceptually similar to the &lt;code&gt;trunc&lt;/code&gt; function for numbers.</source>
          <target state="translated">関数 &lt;code&gt;date_trunc&lt;/code&gt; は、概念的には数値の &lt;code&gt;trunc&lt;/code&gt; 関数に似ています。</target>
        </trans-unit>
        <trans-unit id="246b10543803d9782a161a47909e8e612b910177" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;format&lt;/code&gt; produces output formatted according to a format string, in a style similar to the C function &lt;code&gt;sprintf&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;format&lt;/code&gt; は、C関数 &lt;code&gt;sprintf&lt;/code&gt; と同様のスタイルで、フォーマット文字列に従ってフォーマットされた出力を生成します。</target>
        </trans-unit>
        <trans-unit id="0f972d6e5c3f5f9e5c41c594a5f0d51dc8e13164" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;hstore_to_json&lt;/code&gt; is used when an &lt;code&gt;hstore&lt;/code&gt; value is cast to &lt;code&gt;json&lt;/code&gt;. Likewise, &lt;code&gt;hstore_to_jsonb&lt;/code&gt; is used when an &lt;code&gt;hstore&lt;/code&gt; value is cast to &lt;code&gt;jsonb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hstore_to_json&lt;/code&gt; 関数は、 &lt;code&gt;hstore&lt;/code&gt; 値が &lt;code&gt;json&lt;/code&gt; にキャストされるときに使用されます。同様に、 &lt;code&gt;hstore_to_jsonb&lt;/code&gt; は、 &lt;code&gt;hstore&lt;/code&gt; 値が &lt;code&gt;jsonb&lt;/code&gt; にキャストされるときに使用されます。</target>
        </trans-unit>
        <trans-unit id="3e40c0481379cfb3fb5e6423f9267d79ee88e237" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;pg_export_snapshot&lt;/code&gt; saves the current snapshot and returns a &lt;code&gt;text&lt;/code&gt; string identifying the snapshot. This string must be passed (outside the database) to clients that want to import the snapshot. The snapshot is available for import only until the end of the transaction that exported it. A transaction can export more than one snapshot, if needed. Note that doing so is only useful in &lt;code&gt;READ COMMITTED&lt;/code&gt; transactions, since in &lt;code&gt;REPEATABLE READ&lt;/code&gt; and higher isolation levels, transactions use the same snapshot throughout their lifetime. Once a transaction has exported any snapshots, it cannot be prepared with &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;.</source>
          <target state="translated">関数 &lt;code&gt;pg_export_snapshot&lt;/code&gt; は現在のスナップショットを保存し、スナップショットを識別する &lt;code&gt;text&lt;/code&gt; 文字列を返します。この文字列は、スナップショットをインポートするクライアントに（データベース外で）渡す必要があります。スナップショットは、それをエクスポートしたトランザクションが終了するまでの間のみインポートできます。トランザクションは、必要に応じて複数のスナップショットをエクスポートできます。 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 以上の分離レベルでは、トランザクションは存続期間を通じて同じスナップショットを使用するため、そうすることは &lt;code&gt;READ COMMITTED&lt;/code&gt; トランザクションでのみ役立つことに注意してください。トランザクションがスナップショットをエクスポートすると、&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTIONでは&lt;/a&gt;準備できません。</target>
        </trans-unit>
        <trans-unit id="9f7c2a78ba8dec8a097ba6554379141ee778a83d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;pg_notification_queue_usage&lt;/code&gt; returns the fraction of the queue that is currently occupied by pending notifications. See &lt;a href=&quot;functions-info&quot;&gt;Section 9.25&lt;/a&gt; for more information.</source>
          <target state="translated">関数 &lt;code&gt;pg_notification_queue_usage&lt;/code&gt; は、保留中の通知によって現在占有されているキューの割合を返します。詳細は&lt;a href=&quot;functions-info&quot;&gt;項9.25&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="082064f30064e38cacd08cc4cf5d96bae8c8c23d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;populate_record&lt;/code&gt; is actually declared with &lt;code&gt;anyelement&lt;/code&gt;, not &lt;code&gt;record&lt;/code&gt;, as its first argument, but it will reject non-record types with a run-time error.</source>
          <target state="translated">関数 &lt;code&gt;populate_record&lt;/code&gt; は、最初の引数として、 &lt;code&gt;record&lt;/code&gt; ではなく &lt;code&gt;anyelement&lt;/code&gt; で実際に宣言されますが、実行時エラーで非レコード型を拒否します。</target>
        </trans-unit>
        <trans-unit id="472db68032e87a9f5dc2308d607eed94d8936c47" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;set_config&lt;/code&gt; provides equivalent functionality; see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.26&lt;/a&gt;. Also, it is possible to UPDATE the &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; system view to perform the equivalent of &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;set_config&lt;/code&gt; は同等の機能を提供します。&lt;a href=&quot;functions-admin&quot;&gt;セクション9.26を&lt;/a&gt;参照してください。また、&lt;a href=&quot;view-pg-settings&quot;&gt; &lt;code&gt;pg_settings&lt;/code&gt; &lt;/a&gt;システムビューを更新して、 &lt;code&gt;SET&lt;/code&gt; と同等の機能を実行することもできます。</target>
        </trans-unit>
        <trans-unit id="1a0af8636b241010eb58f1e64ca4ece0dacf61bc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;setweight&lt;/code&gt; can be used to label the entries of a &lt;code&gt;tsvector&lt;/code&gt; with a given &lt;em&gt;weight&lt;/em&gt;, where a weight is one of the letters &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, or &lt;code&gt;D&lt;/code&gt;. This is typically used to mark entries coming from different parts of a document, such as title versus body. Later, this information can be used for ranking of search results.</source>
          <target state="translated">関数 &lt;code&gt;setweight&lt;/code&gt; を使用すると、 &lt;code&gt;tsvector&lt;/code&gt; のエントリに特定の&lt;em&gt;重みを&lt;/em&gt;付けることができます。重みは、 &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; 、または &lt;code&gt;D&lt;/code&gt; のいずれかの文字です。これは通常、タイトルと本文など、ドキュメントのさまざまな部分からのエントリをマークするために使用されます。後で、この情報は検索結果のランキングに使用できます。</target>
        </trans-unit>
        <trans-unit id="13cca378c8ae0fc168761a1769d0060a92e5808a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;timezone(zone, timestamp)&lt;/code&gt; is equivalent to the SQL-conforming construct &lt;code&gt;timestamp AT TIME ZONE zone&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;timezone(zone, timestamp)&lt;/code&gt; は、SQL準拠の構成要素 &lt;code&gt;timestamp AT TIME ZONE zone&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="6c2461207b12b5b4e196270e7b51786ac6ccae21" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;ts_debug&lt;/code&gt; allows easy testing of a text search configuration.</source>
          <target state="translated">関数 &lt;code&gt;ts_debug&lt;/code&gt; を使用すると、テキスト検索構成を簡単にテストできます。</target>
        </trans-unit>
        <trans-unit id="99af9ae29d7989fa85e4ac3a29989c54729ceea6" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;ts_stat&lt;/code&gt; is useful for checking your configuration and for finding stop-word candidates.</source>
          <target state="translated">関数 &lt;code&gt;ts_stat&lt;/code&gt; は、構成の確認やストップワード候補の検索に役立ちます。</target>
        </trans-unit>
        <trans-unit id="2e394c193235d538ba957624ee9cbb6815d37e36" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlagg&lt;/code&gt; is, unlike the other functions described here, an aggregate function. It concatenates the input values to the aggregate function call, much like &lt;code&gt;xmlconcat&lt;/code&gt; does, except that concatenation occurs across rows rather than across expressions in a single row. See &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt; for additional information about aggregate functions.</source>
          <target state="translated">関数 &lt;code&gt;xmlagg&lt;/code&gt; は、ここで説明する他の関数とは異なり、集約関数です。単一の行の式全体ではなく行全体で連結が行われることを除いて、 &lt;code&gt;xmlconcat&lt;/code&gt; と同様に、入力値を集約関数呼び出しに連結します。集計関数の詳細は、&lt;a href=&quot;functions-aggregate&quot;&gt;9.20&lt;/a&gt;項を参照してください。</target>
        </trans-unit>
        <trans-unit id="1f1fc89a699325691e39d0dd59e92400a699e36a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlcomment&lt;/code&gt; creates an XML value containing an XML comment with the specified text as content. The text cannot contain &amp;ldquo;&lt;code&gt;--&lt;/code&gt;&amp;rdquo; or end with a &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo; so that the resulting construct is a valid XML comment. If the argument is null, the result is null.</source>
          <target state="translated">関数 &lt;code&gt;xmlcomment&lt;/code&gt; は、指定されたテキストをコンテンツとして持つXMLコメントを含むXML値を作成します。結果の構成が有効なXMLコメントになるように、テキストに「 &lt;code&gt;--&lt;/code&gt; 」を含めたり、「 &lt;code&gt;-&lt;/code&gt; 」で終わることはできません。引数がnullの場合、結果はnullです。</target>
        </trans-unit>
        <trans-unit id="ebaef272546a7798627e85265fe680ca3031d61e" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlconcat&lt;/code&gt; concatenates a list of individual XML values to create a single value containing an XML content fragment. Null values are omitted; the result is only null if there are no nonnull arguments.</source>
          <target state="translated">関数 &lt;code&gt;xmlconcat&lt;/code&gt; は、個々のXML値のリストを連結して、XMLコンテンツフラグメントを含む単一の値を作成します。null値は省略されます。null以外の引数がない場合、結果はnullのみです。</target>
        </trans-unit>
        <trans-unit id="ef22fdb70040aafe9245779771954e498b2f3f6a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlexists&lt;/code&gt; evaluates an XPath 1.0 expression (the first argument), with the passed XML value as its context item. The function returns false if the result of that evaluation yields an empty node-set, true if it yields any other value. The function returns null if any argument is null. A nonnull value passed as the context item must be an XML document, not a content fragment or any non-XML value.</source>
          <target state="translated">関数 &lt;code&gt;xmlexists&lt;/code&gt; は、渡されたXML値をコンテキスト項目として使用して、XPath 1.0式（最初の引数）を評価します。その評価の結果が空のノードセットを生成する場合、関数はfalseを返し、他の値を生成する場合はtrueを返します。いずれかの引数がnullの場合、関数はnullを返します。コンテキストアイテムとして渡されるnull以外の値は、コンテンツフラグメントや非XML値ではなく、XMLドキュメントでなければなりません。</target>
        </trans-unit>
        <trans-unit id="837a957d18da91847b5357c6c3108da0982c435c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xpath&lt;/code&gt; evaluates the XPath 1.0 expression &lt;code&gt;xpath&lt;/code&gt; (a &lt;code&gt;text&lt;/code&gt; value) against the XML value &lt;code&gt;xml&lt;/code&gt;. It returns an array of XML values corresponding to the node-set produced by the XPath expression. If the XPath expression returns a scalar value rather than a node-set, a single-element array is returned.</source>
          <target state="translated">関数 &lt;code&gt;xpath&lt;/code&gt; は、XML値 &lt;code&gt;xml&lt;/code&gt; に対してXPath 1.0式 &lt;code&gt;xpath&lt;/code&gt; （ &lt;code&gt;text&lt;/code&gt; 値）を評価します。XPath式によって生成されたノードセットに対応するXML値の配列を返します。XPath式がノードセットではなくスカラー値を返す場合、単一要素の配列が返されます。</target>
        </trans-unit>
        <trans-unit id="49641632c456630ce0fe9561c2cd9fece93afa1f" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xpath_exists&lt;/code&gt; is a specialized form of the &lt;code&gt;xpath&lt;/code&gt; function. Instead of returning the individual XML values that satisfy the XPath 1.0 expression, this function returns a Boolean indicating whether the query was satisfied or not (specifically, whether it produced any value other than an empty node-set). This function is equivalent to the &lt;code&gt;XMLEXISTS&lt;/code&gt; predicate, except that it also offers support for a namespace mapping argument.</source>
          <target state="translated">関数 &lt;code&gt;xpath_exists&lt;/code&gt; は、 &lt;code&gt;xpath&lt;/code&gt; 関数の特殊な形式です。この関数は、XPath 1.0式を満たす個々のXML値を返す代わりに、クエリが満たされたかどうか（具体的には、空のノードセット以外の値が生成されたかどうか）を示すブール値を返します。この関数は、名前空間マッピング引数のサポートも提供することを除いて、 &lt;code&gt;XMLEXISTS&lt;/code&gt; 述語と同等です。</target>
        </trans-unit>
        <trans-unit id="5c574a36f3d0b3b9d8fd4793fb7a1aefa7712dc3" translate="yes" xml:space="preserve">
          <source>The function has no side effects. No information about the arguments is conveyed except via the return value. Any function that might throw an error depending on the values of its arguments is not leak-proof.</source>
          <target state="translated">この関数には副作用はありません。引数に関する情報は、戻り値を経由する以外には何も伝えられません。引数の値に依存してエラーを投げる可能性のある関数は、リークプルーフではありません。</target>
        </trans-unit>
        <trans-unit id="b27ab2a24cc42745c4233c190a0fd395e1a3a156" translate="yes" xml:space="preserve">
          <source>The function has to be used in a &lt;code&gt;FROM&lt;/code&gt; expression, with an &lt;code&gt;AS&lt;/code&gt; clause to specify the output columns; for example</source>
          <target state="translated">この関数は、出力列を指定する &lt;code&gt;AS&lt;/code&gt; 句とともに &lt;code&gt;FROM&lt;/code&gt; 式で使用する必要があります。例えば</target>
        </trans-unit>
        <trans-unit id="b6bc1caecad2cc53ec1c4c77402a0b8f9335155f" translate="yes" xml:space="preserve">
          <source>The function must have the following signature:</source>
          <target state="translated">関数は以下のシグネチャを持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="c9d3b3a8b1ce80dcb6ec1f9fb5fa0bcff0d4df0d" translate="yes" xml:space="preserve">
          <source>The function must return &lt;code&gt;true&lt;/code&gt; if the leaf tuple matches the query, or &lt;code&gt;false&lt;/code&gt; if not. In the &lt;code&gt;true&lt;/code&gt; case, if &lt;code&gt;returnData&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then &lt;code&gt;leafValue&lt;/code&gt; must be set to the value of &lt;code&gt;spgConfigIn&lt;/code&gt;.&lt;code&gt;attType&lt;/code&gt; type originally supplied to be indexed for this leaf tuple. Also, &lt;code&gt;recheck&lt;/code&gt; may be set to &lt;code&gt;true&lt;/code&gt; if the match is uncertain and so the operator(s) must be re-applied to the actual heap tuple to verify the match. If ordered search is performed, set &lt;code&gt;distances&lt;/code&gt; to an array of distance values according to &lt;code&gt;orderbys&lt;/code&gt; array. Leave it NULL otherwise. If at least one of returned distances is not exact, set &lt;code&gt;recheckDistances&lt;/code&gt; to true. In this case, the executor will calculate the exact distances after fetching the tuple from the heap, and will reorder the tuples if needed.</source>
          <target state="translated">リーフタプルがクエリと一致する場合、関数は &lt;code&gt;true&lt;/code&gt; を返し、一致しない場合は &lt;code&gt;false&lt;/code&gt; を返す必要があります。 &lt;code&gt;true&lt;/code&gt; 場合場合、 &lt;code&gt;returnData&lt;/code&gt; がある &lt;code&gt;true&lt;/code&gt; 次いで &lt;code&gt;leafValue&lt;/code&gt; は、の値に設定する必要があり &lt;code&gt;spgConfigIn&lt;/code&gt; 。 &lt;code&gt;attType&lt;/code&gt; にインデックスを付けるために最初に提供されたattTypeタイプ。また、一致が不確かな場合は、 &lt;code&gt;recheck&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定して、演算子を実際のヒープタプルに再適用して、一致を確認する必要があります。順序付けられた検索が行われた場合、設定され &lt;code&gt;distances&lt;/code&gt; に応じて距離値の配列への &lt;code&gt;orderbys&lt;/code&gt; アレイ。それ以外の場合はNULLのままにします。返された距離の少なくとも1つが正確でない場合は、 &lt;code&gt;recheckDistances&lt;/code&gt; をtrue に設定します。この場合、executorはヒープからタプルをフェッチした後に正確な距離を計算し、必要に応じてタプルを再配列します。</target>
        </trans-unit>
        <trans-unit id="dbb965af01f35df576ea93f5375cbc5d7cb5a800" translate="yes" xml:space="preserve">
          <source>The function names can be schema-qualified if necessary. Argument types are not given, since the argument list for each type of function is predetermined. All except the headline function are required.</source>
          <target state="translated">関数名は必要に応じてスキーマ修飾することができます。引数の種類は、関数の種類ごとの引数リストがあらかじめ決められているので、引数の種類は与えない。ヘッドライン関数以外は必須です。</target>
        </trans-unit>
        <trans-unit id="85e3b58b43bc6834c37e08716eb6be535f35e900" translate="yes" xml:space="preserve">
          <source>The function names can be schema-qualified if necessary. Argument types are not given, since the argument list for each type of function is predetermined. The lexize function is required, but the init function is optional.</source>
          <target state="translated">関数名は必要に応じてスキーマ修飾することができます。引数の種類は、関数の種類ごとの引数リストがあらかじめ決められているので、引数の種類は与えられません。lexize関数は必須ですが、init関数はオプションです。</target>
        </trans-unit>
        <trans-unit id="3e644e558fc444f59115fd62f759afc494438aeb" translate="yes" xml:space="preserve">
          <source>The function to be called</source>
          <target state="translated">呼び出される関数</target>
        </trans-unit>
        <trans-unit id="10c50baf8431e61e9cb02cb427556dde06fcb6c7" translate="yes" xml:space="preserve">
          <source>The function used to implement this operator.</source>
          <target state="translated">この演算子を実装するために使用される関数。</target>
        </trans-unit>
        <trans-unit id="0c214640ce9489d4916101b16e01715654ee3006" translate="yes" xml:space="preserve">
          <source>The function used to perform the cast. The function name can be schema-qualified. If it is not, the function will be looked up in the schema search path. The function's result data type must match the target type of the cast. Its arguments are discussed below. If no argument list is specified, the function name must be unique in its schema.</source>
          <target state="translated">キャストを実行するために使用される関数。関数名はスキーマ修飾名にすることができます。スキーマ修飾されていない場合、関数はスキーマ検索パスで検索されます。関数の結果データ型はキャストのターゲット型と一致しなければなりません。その引数については後述します。引数リストが指定されない場合、関数名はスキーマ内で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="4070b563f17e2132c89c11f1dad26e620d3d0a33" translate="yes" xml:space="preserve">
          <source>The function used to perform the conversion. The function name can be schema-qualified. If it is not, the function will be looked up in the path.</source>
          <target state="translated">変換を実行するために使用される関数。関数名はスキーマ修飾することができます。そうでない場合,関数はパスで検索されます。</target>
        </trans-unit>
        <trans-unit id="32829bac3c1c7822fdaafe64cfff6a892c8b38d6" translate="yes" xml:space="preserve">
          <source>The function will now execute with whatever search path is used by its caller.</source>
          <target state="translated">この関数は、呼び出し元で使用されている検索パスで実行されるようになりました。</target>
        </trans-unit>
        <trans-unit id="3887f28b4d8dd432ded2ac6b6e06e93d7b6fd604" translate="yes" xml:space="preserve">
          <source>The function's Boolean result value is significant only when &lt;code&gt;checkUnique&lt;/code&gt; is &lt;code&gt;UNIQUE_CHECK_PARTIAL&lt;/code&gt;. In this case a true result means the new entry is known unique, whereas false means it might be non-unique (and a deferred uniqueness check must be scheduled). For other cases a constant false result is recommended.</source>
          <target state="translated">関数のブール結果値は、 &lt;code&gt;checkUnique&lt;/code&gt; が &lt;code&gt;UNIQUE_CHECK_PARTIAL&lt;/code&gt; の場合にのみ意味があります。この場合、真の結果は新しいエントリが一意であることがわかっていることを意味し、偽はそれが一意ではない可能性があることを意味します（延期された一意性チェックをスケジュールする必要があります）。その他の場合は、一定の偽の結果が推奨されます。</target>
        </trans-unit>
        <trans-unit id="e1dfbee76245b05e9845e2733e79d53c030e40bb" translate="yes" xml:space="preserve">
          <source>The function-like syntax is in fact just a function call. When one of the two standard cast syntaxes is used to do a run-time conversion, it will internally invoke a registered function to perform the conversion. By convention, these conversion functions have the same name as their output type, and thus the &amp;ldquo;function-like syntax&amp;rdquo; is nothing more than a direct invocation of the underlying conversion function. Obviously, this is not something that a portable application should rely on. For further details see &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;.</source>
          <target state="translated">関数のような構文は、実際には単なる関数呼び出しです。 2つの標準キャスト構文の1つを使用してランタイム変換を行うと、登録された関数を内部的に呼び出して変換を実行します。慣例により、これらの変換関数の名前は出力タイプと同じであるため、「関数のような構文」は、基になる変換関数の直接の呼び出しにすぎません。明らかに、これは移植可能なアプリケーションが依存すべきものではありません。詳細は&lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1ff17dc219c0bcfbebd29717a230a4a214e2cbc8" translate="yes" xml:space="preserve">
          <source>The functionality provided by this module overlaps substantially with the functionality of the older &lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt; module. But &lt;code&gt;postgres_fdw&lt;/code&gt; provides more transparent and standards-compliant syntax for accessing remote tables, and can give better performance in many cases.</source>
          <target state="translated">このモジュールが提供する機能は、以前の&lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt;モジュールの機能と実質的に重複しています。しかし、 &lt;code&gt;postgres_fdw&lt;/code&gt; は、リモートテーブルにアクセスするためのより透過的で標準に準拠した構文を提供し、多くの場合により良いパフォーマンスを提供できます。</target>
        </trans-unit>
        <trans-unit id="31e36b0f324aa4e2e4f308d3f86f3d1cbe3d7e22" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;crypt()&lt;/code&gt; and &lt;code&gt;gen_salt()&lt;/code&gt; are specifically designed for hashing passwords. &lt;code&gt;crypt()&lt;/code&gt; does the hashing and &lt;code&gt;gen_salt()&lt;/code&gt; prepares algorithm parameters for it.</source>
          <target state="translated">関数 &lt;code&gt;crypt()&lt;/code&gt; および &lt;code&gt;gen_salt()&lt;/code&gt; は、パスワードのハッシュ用に特別に設計されています。 &lt;code&gt;crypt()&lt;/code&gt; はハッシュを行い、 &lt;code&gt;gen_salt()&lt;/code&gt; はそのためのアルゴリズムパラメータを準備します。</target>
        </trans-unit>
        <trans-unit id="459538ee1cd160dead602c42a37b3db46574d899" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;json[b]_populate_record&lt;/code&gt;, &lt;code&gt;json[b]_populate_recordset&lt;/code&gt;, &lt;code&gt;json[b]_to_record&lt;/code&gt; and &lt;code&gt;json[b]_to_recordset&lt;/code&gt; operate on a JSON object, or array of objects, and extract the values associated with keys whose names match column names of the output row type. Object fields that do not correspond to any output column name are ignored, and output columns that do not match any object field will be filled with nulls. To convert a JSON value to the SQL type of an output column, the following rules are applied in sequence:</source>
          <target state="translated">関数 &lt;code&gt;json[b]_populate_record&lt;/code&gt; 、 &lt;code&gt;json[b]_populate_recordset&lt;/code&gt; 、 &lt;code&gt;json[b]_to_record&lt;/code&gt; および &lt;code&gt;json[b]_to_recordset&lt;/code&gt; は、JSONオブジェクトまたはオブジェクトの配列を操作し、名前がの列名と一致するキーに関連付けられた値を抽出します出力行タイプ。どの出力列名にも対応しないオブジェクトフィールドは無視され、どのオブジェクトフィールドとも一致しない出力列はnullで埋められます。JSON値を出力列のSQLタイプに変換するには、次のルールが順番に適用されます。</target>
        </trans-unit>
        <trans-unit id="377b36f768957552b23e80bcd91c885aadb25355" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;lower_inc&lt;/code&gt; and &lt;code&gt;upper_inc&lt;/code&gt; test the inclusivity of the lower and upper bounds of a range value, respectively.</source>
          <target state="translated">関数 &lt;code&gt;lower_inc&lt;/code&gt; および &lt;code&gt;upper_inc&lt;/code&gt; は、それぞれ範囲値の下限および上限の包含性をテストします。</target>
        </trans-unit>
        <trans-unit id="f9b6f07f168f9bab47cb0d63914798ab55512000" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;lower_inf&lt;/code&gt; and &lt;code&gt;upper_inf&lt;/code&gt; test for infinite lower and upper bounds of a range, respectively.</source>
          <target state="translated">関数 &lt;code&gt;lower_inf&lt;/code&gt; と &lt;code&gt;upper_inf&lt;/code&gt; は、それぞれ範囲の無限の下限と上限をテストします。</target>
        </trans-unit>
        <trans-unit id="f703d74ff7244a4147930578a835fc919fa68d3e" translate="yes" xml:space="preserve">
          <source>The functions above that operate on tables or indexes accept a &lt;code&gt;regclass&lt;/code&gt; argument, which is simply the OID of the table or index in the &lt;code&gt;pg_class&lt;/code&gt; system catalog. You do not have to look up the OID by hand, however, since the &lt;code&gt;regclass&lt;/code&gt; data type's input converter will do the work for you. Just write the table name enclosed in single quotes so that it looks like a literal constant. For compatibility with the handling of ordinary SQL names, the string will be converted to lower case unless it contains double quotes around the table name.</source>
          <target state="translated">テーブルまたはインデックスを操作する上記の関数は、 &lt;code&gt;regclass&lt;/code&gt; 引数を受け入れます。これは、 &lt;code&gt;pg_class&lt;/code&gt; システムカタログ内のテーブルまたはインデックスのOIDです。ただし、 &lt;code&gt;regclass&lt;/code&gt; データ型の入力コンバーターが機能するため、OIDを手動で検索する必要はありません。リテラル定数のように見えるように、テーブル名を一重引用符で囲んでください。通常のSQL名の処理との互換性のために、文字列は、テーブル名の前後に二重引用符が含まれていない限り、小文字に変換されます。</target>
        </trans-unit>
        <trans-unit id="c0e923506f65e63b3dddbd22a7fb5e1606f3b604" translate="yes" xml:space="preserve">
          <source>The functions and function-like expressions described in this section operate on values of type &lt;code&gt;xml&lt;/code&gt;. See &lt;a href=&quot;datatype-xml&quot;&gt;Section 8.13&lt;/a&gt; for information about the &lt;code&gt;xml&lt;/code&gt; type. The function-like expressions &lt;code&gt;xmlparse&lt;/code&gt; and &lt;code&gt;xmlserialize&lt;/code&gt; for converting to and from type &lt;code&gt;xml&lt;/code&gt; are documented there, not in this section.</source>
          <target state="translated">このセクションで説明する関数と関数のような式は、 &lt;code&gt;xml&lt;/code&gt; 型の値を操作します。 &lt;code&gt;xml&lt;/code&gt; タイプについては、&lt;a href=&quot;datatype-xml&quot;&gt;8.13&lt;/a&gt;項を参照してください。 &lt;code&gt;xml&lt;/code&gt; 型との &lt;code&gt;xmlserialize&lt;/code&gt; で変換するための関数のような式 &lt;code&gt;xmlparse&lt;/code&gt; およびxmlserializeは、このセクションではなく、ドキュメント化されています。</target>
        </trans-unit>
        <trans-unit id="6ccb73aae614647b2269d26a350b909a44513b27" translate="yes" xml:space="preserve">
          <source>The functions described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP&quot;&gt;Section 9.26.3&lt;/a&gt;, &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL&quot;&gt;Section 9.26.4&lt;/a&gt;, and &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;Section 9.26.5&lt;/a&gt; are also relevant for replication.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP&quot;&gt;セクション9.26.3&lt;/a&gt;、&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL&quot;&gt;セクション9.26.4&lt;/a&gt;、および&lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;セクション9.26.5で&lt;/a&gt;説明されている関数は、レプリケーションにも関連しています。</target>
        </trans-unit>
        <trans-unit id="e464a1af28710d4a1fd7e811bd3d0475c5576752" translate="yes" xml:space="preserve">
          <source>The functions described in this section are used to control and monitor a PostgreSQL installation.</source>
          <target state="translated">このセクションで説明する関数は、PostgreSQLのインストールを制御・監視するために使用します。</target>
        </trans-unit>
        <trans-unit id="01945498ca90e6ae3cd1d1b921c28c9c72aead1f" translate="yes" xml:space="preserve">
          <source>The functions here implement the encryption part of the OpenPGP (RFC 4880) standard. Supported are both symmetric-key and public-key encryption.</source>
          <target state="translated">この関数は、OpenPGP (RFC 4880)規格の暗号化部分を実装しています。対称鍵暗号化と公開鍵暗号化の両方をサポートしています。</target>
        </trans-unit>
        <trans-unit id="122b22a585b5cb5a2901cc7acf3393bb3b507311" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-DEBUG-TABLE&quot;&gt;Table 9.43&lt;/a&gt; are listed separately because they are not usually used in everyday text searching operations. They are helpful for development and debugging of new text search configurations.</source>
          <target state="translated">&lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-DEBUG-TABLE&quot;&gt;表9.43&lt;/a&gt;の関数は、通常、日常のテキスト検索操作では使用されないため、個別にリストされています。新しいテキスト検索設定の開発とデバッグに役立ちます。</target>
        </trans-unit>
        <trans-unit id="60ec00f1a0d952540e42b411ff256f01a844ba9a" translate="yes" xml:space="preserve">
          <source>The functions listed in &lt;a href=&quot;pgbench#PGBENCH-FUNCTIONS&quot;&gt;Table 259&lt;/a&gt; are built into pgbench and may be used in expressions appearing in &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt;&lt;code&gt;\set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pgbench#PGBENCH-FUNCTIONS&quot;&gt;表259に&lt;/a&gt;リストされている関数はpgbenchに組み込まれており、&lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt; &lt;code&gt;\set&lt;/code&gt; &lt;/a&gt;現れる式で使用できます。</target>
        </trans-unit>
        <trans-unit id="1d976c2e21ce82fc5ee166341bd65f2f942d7585" translate="yes" xml:space="preserve">
          <source>The functions provided by the &lt;code&gt;intarray&lt;/code&gt; module are shown in &lt;a href=&quot;intarray#INTARRAY-FUNC-TABLE&quot;&gt;Table F.9&lt;/a&gt;, the operators in &lt;a href=&quot;intarray#INTARRAY-OP-TABLE&quot;&gt;Table F.10&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;intarray&lt;/code&gt; モジュールが提供する関数を&lt;a href=&quot;intarray#INTARRAY-FUNC-TABLE&quot;&gt;表F.9&lt;/a&gt;に、演算子を&lt;a href=&quot;intarray#INTARRAY-OP-TABLE&quot;&gt;表F.10に示し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="589cd253a59ec741e7593831b0243a0b8a47c194" translate="yes" xml:space="preserve">
          <source>The functions provided by the &lt;code&gt;pg_trgm&lt;/code&gt; module are shown in &lt;a href=&quot;pgtrgm#PGTRGM-FUNC-TABLE&quot;&gt;Table F.24&lt;/a&gt;, the operators in &lt;a href=&quot;pgtrgm#PGTRGM-OP-TABLE&quot;&gt;Table F.25&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_trgm&lt;/code&gt; モジュールによって提供される関数は、&lt;a href=&quot;pgtrgm#PGTRGM-OP-TABLE&quot;&gt;表F.25の&lt;/a&gt;演算子である表&lt;a href=&quot;pgtrgm#PGTRGM-FUNC-TABLE&quot;&gt;F.24&lt;/a&gt;に示されています。</target>
        </trans-unit>
        <trans-unit id="5afb7a5be90f1ea0d87d155bbd2bc796569625a1" translate="yes" xml:space="preserve">
          <source>The functions provided to manipulate advisory locks are described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS&quot;&gt;Section 9.26.10&lt;/a&gt;.</source>
          <target state="translated">勧告的ロックを操作するために提供されている関数は、&lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS&quot;&gt;項9.26.10で&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="29ef1c3ef042af3960555b6b81e0fa70ed4d457f" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;adminpack#FUNCTIONS-ADMINPACK-TABLE&quot;&gt;Table F.1&lt;/a&gt; provide write access to files on the machine hosting the server. (See also the functions in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.94&lt;/a&gt;, which provide read-only access.) Only files within the database cluster directory can be accessed, unless the user is a superuser or given one of the pg_read_server_files, or pg_write_server_files roles, as appropriate for the function, but either a relative or absolute path is allowable.</source>
          <target state="translated">&lt;a href=&quot;adminpack#FUNCTIONS-ADMINPACK-TABLE&quot;&gt;表F.1に&lt;/a&gt;示す関数は、サーバーをホストしているマシン上のファイルへの書き込みアクセスを提供します。 （読み取り専用アクセスを提供する&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.94&lt;/a&gt;の関数も参照してください。）ユーザーがスーパーユーザーであるか、関数に応じてpg_read_server_filesまたはpg_write_server_filesロールのいずれかが与えられていない限り、データベースクラスターディレクトリ内のファイルのみにアクセスできます。ですが、相対パスまたは絶対パスを使用できます。</target>
        </trans-unit>
        <trans-unit id="af557d79922e415d01771dc33cbf93a73edbe83c" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.84&lt;/a&gt; assist in making on-line backups. These functions cannot be executed during recovery (except non-exclusive &lt;code&gt;pg_start_backup&lt;/code&gt;, non-exclusive &lt;code&gt;pg_stop_backup&lt;/code&gt;, &lt;code&gt;pg_is_in_backup&lt;/code&gt;, &lt;code&gt;pg_backup_start_time&lt;/code&gt; and &lt;code&gt;pg_wal_lsn_diff&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;表9.84に&lt;/a&gt;示す関数は、オンラインバックアップの作成に役立ちます。これらの関数は、リカバリ中には実行できません（非排他的な &lt;code&gt;pg_start_backup&lt;/code&gt; 、非排他的な &lt;code&gt;pg_stop_backup&lt;/code&gt; 、 &lt;code&gt;pg_is_in_backup&lt;/code&gt; 、 &lt;code&gt;pg_backup_start_time&lt;/code&gt; 、および &lt;code&gt;pg_wal_lsn_diff&lt;/code&gt; を除く）。</target>
        </trans-unit>
        <trans-unit id="3f2948c9238f28bd4ff2bb40ce8791d0b13005bd" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBLOCATION&quot;&gt;Table 9.90&lt;/a&gt; assist in identifying the specific disk files associated with database objects.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBLOCATION&quot;&gt;表9.90に&lt;/a&gt;示す関数は、データベースオブジェクトに関連付けられた特定のディスクファイルを識別するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="3d92b50819e3d60d5191300256c8390d3bc20d24" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Table 9.89&lt;/a&gt; calculate the disk space usage of database objects.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;表9.89に&lt;/a&gt;示す関数は、データベースオブジェクトのディスク領域の使用量を計算します。</target>
        </trans-unit>
        <trans-unit id="596d61caa752f0c6f6982e0c8634c7eacfed18b6" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.94&lt;/a&gt; provide native access to files on the machine hosting the server. Only files within the database cluster directory and the &lt;code&gt;log_directory&lt;/code&gt; can be accessed unless the user is granted the role &lt;code&gt;pg_read_server_files&lt;/code&gt;. Use a relative path for files in the cluster directory, and a path matching the &lt;code&gt;log_directory&lt;/code&gt; configuration setting for log files.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;表9.94に&lt;/a&gt;示す関数は、サーバーをホストしているマシン上のファイルへのネイティブアクセスを提供します。ユーザーに &lt;code&gt;pg_read_server_files&lt;/code&gt; の役割が付与されていない限り、データベースクラスターディレクトリと &lt;code&gt;log_directory&lt;/code&gt; 内のファイルにのみアクセスできます。クラスターディレクトリ内のファイルには相対パスを使用し、ログファイルには &lt;code&gt;log_directory&lt;/code&gt; 構成設定と一致するパスを使用します。</target>
        </trans-unit>
        <trans-unit id="f3c73f231d92075fb0c71fc7740bf5175d685468" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;Table 9.83&lt;/a&gt; send control signals to other server processes. Use of these functions is restricted to superusers by default but access may be granted to others using &lt;code&gt;GRANT&lt;/code&gt;, with noted exceptions.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;表9.83に&lt;/a&gt;示す関数は、制御信号を他のサーバープロセスに送信します。これらの関数の使用は、デフォルトではスーパーユーザーに制限されていますが、注記された例外を除いて、 &lt;code&gt;GRANT&lt;/code&gt; を使用して他のユーザーにアクセスを許可できます。</target>
        </trans-unit>
        <trans-unit id="11868a349a93977f4f568672a07b5dec83a888d7" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS-TABLE&quot;&gt;Table 9.95&lt;/a&gt; manage advisory locks. For details about proper use of these functions, see &lt;a href=&quot;explicit-locking#ADVISORY-LOCKS&quot;&gt;Section 13.3.5&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS-TABLE&quot;&gt;表9.95に&lt;/a&gt;示す関数は、勧告的ロックを管理します。これらの関数の適切な使用の詳細については、&lt;a href=&quot;explicit-locking#ADVISORY-LOCKS&quot;&gt;セクション13.3.5を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ba997e6585ffd2ebf0df203e2718f49b87e3ad76" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.86&lt;/a&gt; control the progress of recovery. These functions may be executed only during recovery.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;表9.86に&lt;/a&gt;示す関数は、リカバリーの進行を制御します。これらの機能は、リカバリ中にのみ実行できます。</target>
        </trans-unit>
        <trans-unit id="8cf9851935069d5da8579d648493492e0773919e" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.85&lt;/a&gt; provide information about the current status of the standby. These functions may be executed both during recovery and in normal running.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;表9.85に&lt;/a&gt;示す関数は、スタンバイの現在のステータスに関する情報を提供します。これらの機能は、リカバリ中と通常の実行中の両方で実行できます。</target>
        </trans-unit>
        <trans-unit id="64ba5a0a32a32de29b727183748ebc1db30a8063" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION-TABLE&quot;&gt;Table 9.88&lt;/a&gt; are for controlling and interacting with replication features. See &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;, &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt; for information about the underlying features. Use of functions for replication origin is restricted to superusers. Use of functions for replication slot is restricted to superusers and users having &lt;code&gt;REPLICATION&lt;/code&gt; privilege.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION-TABLE&quot;&gt;表9.88に&lt;/a&gt;示す関数は、レプリケーション機能を制御および操作するためのものです。基礎となる機能については、&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;セクション26.2.5&lt;/a&gt;、&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;セクション26.2.6&lt;/a&gt;、および&lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;第49章を&lt;/a&gt;参照してください。複製元の関数の使用はスーパーユーザーに制限されています。複製スロットの関数の使用は、スーパーユーザーと &lt;code&gt;REPLICATION&lt;/code&gt; 特権を持つユーザーに制限されています。</target>
        </trans-unit>
        <trans-unit id="423b085ba2dc236f90217ee4b570443351039e1a" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-COMMIT-TIMESTAMP&quot;&gt;Table 9.76&lt;/a&gt; provide information about transactions that have been already committed. These functions mainly provide information about when the transactions were committed. They only provide useful data when &lt;a href=&quot;runtime-config-replication#GUC-TRACK-COMMIT-TIMESTAMP&quot;&gt;track_commit_timestamp&lt;/a&gt; configuration option is enabled and only for transactions that were committed after it was enabled.</source>
          <target state="translated">&lt;a href=&quot;functions-info#FUNCTIONS-COMMIT-TIMESTAMP&quot;&gt;表9.76に&lt;/a&gt;示す関数は、すでにコミットされているトランザクションに関する情報を提供します。これらの関数は、主にトランザクションがいつコミットされたかに関する情報を提供します。これらは、&lt;a href=&quot;runtime-config-replication#GUC-TRACK-COMMIT-TIMESTAMP&quot;&gt;track_commit_timestamp&lt;/a&gt;構成オプションが有効になっている場合、および有効にされた後にコミットされたトランザクションに対してのみ、有用なデータを提供します。</target>
        </trans-unit>
        <trans-unit id="6bfe1a4de569556a1d516d3985556b63d6f6146f" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-CONTROLDATA&quot;&gt;Table 9.77&lt;/a&gt; print information initialized during &lt;code&gt;initdb&lt;/code&gt;, such as the catalog version. They also show information about write-ahead logging and checkpoint processing. This information is cluster-wide, and not specific to any one database. They provide most of the same information, from the same source, as &lt;a href=&quot;app-pgcontroldata&quot;&gt;pg_controldata&lt;/a&gt;, although in a form better suited to SQL functions.</source>
          <target state="translated">&lt;a href=&quot;functions-info#FUNCTIONS-CONTROLDATA&quot;&gt;表9.77に&lt;/a&gt;示す関数は、カタログバージョンなど、 &lt;code&gt;initdb&lt;/code&gt; 中に初期化された情報を出力します。また、先行書き込みロギングとチェックポイント処理に関する情報も表示されます。この情報はクラスター全体にわたるものであり、特定のデータベースに固有のものではありません。それらは、&lt;a href=&quot;app-pgcontroldata&quot;&gt;pg_controldata&lt;/a&gt;と同じソースから同じ情報のほとんどを提供しますが、SQL関数により適した形式です。</target>
        </trans-unit>
        <trans-unit id="46311f3452a56adeb669710af158b1d331e3ba4e" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-INFO-COMMENT-TABLE&quot;&gt;Table 9.73&lt;/a&gt; extract comments previously stored with the &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; command. A null value is returned if no comment could be found for the specified parameters.</source>
          <target state="translated">&lt;a href=&quot;functions-info#FUNCTIONS-INFO-COMMENT-TABLE&quot;&gt;表9.73に&lt;/a&gt;示す関数は、&lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt;コマンドで以前に保存されたコメントを抽出します。指定されたパラメーターのコメントが見つからなかった場合は、NULL値が返されます。</target>
        </trans-unit>
        <trans-unit id="6f306d4b7a9229188bb697a19658366a35ce8588" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT&quot;&gt;Table 9.74&lt;/a&gt; provide server transaction information in an exportable form. The main use of these functions is to determine which transactions were committed between two snapshots.</source>
          <target state="translated">&lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT&quot;&gt;表9.74に&lt;/a&gt;示す関数は、サーバートランザクション情報をエクスポート可能な形式で提供します。これらの関数の主な用途は、2つのスナップショット間でコミットされたトランザクションを判別することです。</target>
        </trans-unit>
        <trans-unit id="9398f596a0390810b3e41d607c70ae410202516a" translate="yes" xml:space="preserve">
          <source>The functions verify various &lt;em&gt;invariants&lt;/em&gt; in the structure of the representation of particular relations. The correctness of the access method functions behind index scans and other important operations relies on these invariants always holding. For example, certain functions verify, among other things, that all B-Tree pages have items in &amp;ldquo;logical&amp;rdquo; order (e.g., for B-Tree indexes on &lt;code&gt;text&lt;/code&gt;, index tuples should be in collated lexical order). If that particular invariant somehow fails to hold, we can expect binary searches on the affected page to incorrectly guide index scans, resulting in wrong answers to SQL queries.</source>
          <target state="translated">関数は、特定の関係の表現の構造におけるさまざまな&lt;em&gt;不変条件&lt;/em&gt;を検証します。インデックススキャンやその他の重要な操作の背後にあるアクセス方法関数の正確性は、常に保持されているこれらの不変条件に依存しています。たとえば、特定の関数は、特に、すべてのBツリーページに「論理」順序のアイテムがあることを確認します（たとえば、 &lt;code&gt;text&lt;/code&gt; Bツリーインデックスの場合、インデックスタプルは照合された字句順である必要があります）。その特定の不変条件が何らかの理由で保持されない場合、影響を受けるページでのバイナリ検索がインデックススキャンを誤って導き、SQLクエリに対する誤った回答をもたらすことが予想されます。</target>
        </trans-unit>
        <trans-unit id="0d68a3d97b1b4428fbfcb9d0333819c6fcb3c2b0" translate="yes" xml:space="preserve">
          <source>The fundamental type of an XQuery/XPath expression, the &lt;code&gt;sequence&lt;/code&gt;, which can contain XML nodes, atomic values, or both, does not exist in XPath 1.0. A 1.0 expression can only produce a node-set (containing zero or more XML nodes), or a single atomic value.</source>
          <target state="translated">XQuery / XPath式の基本的なタイプである &lt;code&gt;sequence&lt;/code&gt; 、XMLノード、アトミック値、またはその両方を含むことができ、XPath 1.0には存在しません。1.0の式は、ノードセット（0個以上のXMLノードを含む）、または単一のアトミック値のみを生成できます。</target>
        </trans-unit>
        <trans-unit id="01481c12012dd36b33a9e59e6d02e28615f69f45" translate="yes" xml:space="preserve">
          <source>The general form of a recursive &lt;code&gt;WITH&lt;/code&gt; query is always a &lt;em&gt;non-recursive term&lt;/em&gt;, then &lt;code&gt;UNION&lt;/code&gt; (or &lt;code&gt;UNION ALL&lt;/code&gt;), then a &lt;em&gt;recursive term&lt;/em&gt;, where only the recursive term can contain a reference to the query's own output. Such a query is executed as follows:</source>
          <target state="translated">再帰的な &lt;code&gt;WITH&lt;/code&gt; クエリの一般的な形式は、常に&lt;em&gt;非再帰的な用語&lt;/em&gt;、次に &lt;code&gt;UNION&lt;/code&gt; （または &lt;code&gt;UNION ALL&lt;/code&gt; ）、次に&lt;em&gt;再帰的な用語です&lt;/em&gt;。この場合、再帰的な用語のみがクエリ自体の出力への参照を含むことができます。このようなクエリは次のように実行されます。</target>
        </trans-unit>
        <trans-unit id="8eee7d4e38c500df724907fbea7403f66500c981" translate="yes" xml:space="preserve">
          <source>The general format of the &lt;code&gt;pg_hba.conf&lt;/code&gt; file is a set of records, one per line. Blank lines are ignored, as is any text after the &lt;code&gt;#&lt;/code&gt; comment character. Records cannot be continued across lines. A record is made up of a number of fields which are separated by spaces and/or tabs. Fields can contain white space if the field value is double-quoted. Quoting one of the keywords in a database, user, or address field (e.g., &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;replication&lt;/code&gt;) makes the word lose its special meaning, and just match a database, user, or host with that name.</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; ファイルの一般的な形式は、1行に1つのレコードのセットです。 &lt;code&gt;#&lt;/code&gt; コメント文字の後のテキストと同様に、空白行は無視されます。レコードは行をまたがって継続することはできません。レコードは、スペースやタブで区切られたいくつかのフィールドで構成されています。フィールド値が二重引用符で囲まれている場合、フィールドに空白を含めることができます。データベース、ユーザー、またはアドレスフィールド（たとえば、 &lt;code&gt;all&lt;/code&gt; または &lt;code&gt;replication&lt;/code&gt; ）のキーワードの1つを引用すると、その単語の特別な意味がなくなり、データベース、ユーザー、またはホストがその名前と一致するだけになります。</target>
        </trans-unit>
        <trans-unit id="2ed177efb04faf95279eeefdbca2d0ce9a32d2a9" translate="yes" xml:space="preserve">
          <source>The general principle is that the contained object must match the containing object as to structure and data contents, possibly after discarding some non-matching array elements or object key/value pairs from the containing object. But remember that the order of array elements is not significant when doing a containment match, and duplicate array elements are effectively considered only once.</source>
          <target state="translated">一般的な原則は、含まれるオブジェクトは、構造とデータの内容に関して、含まれるオブジェクトと一致しなければならないということです。しかし、配列要素の順序は、格納物の一致を行う際には重要ではないことを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="ab5e9d694a644360b18b209b2a60b5fe2f2901b9" translate="yes" xml:space="preserve">
          <source>The general rule for configuring a list of dictionaries is to place first the most narrow, most specific dictionary, then the more general dictionaries, finishing with a very general dictionary, like a Snowball stemmer or &lt;code&gt;simple&lt;/code&gt;, which recognizes everything. For example, for an astronomy-specific search (&lt;code&gt;astro_en&lt;/code&gt; configuration) one could bind token type &lt;code&gt;asciiword&lt;/code&gt; (ASCII word) to a synonym dictionary of astronomical terms, a general English dictionary and a Snowball English stemmer:</source>
          <target state="translated">辞書のリストを構成するための一般的なルールは、最初に最も狭くて最も具体的な辞書を配置し、次により一般的な辞書を配置して、すべてを認識するSnowballステマーや &lt;code&gt;simple&lt;/code&gt; のような非常に一般的な辞書で終わります。たとえば、天文学固有の検索（ &lt;code&gt;astro_en&lt;/code&gt; 構成）の場合、トークンタイプの &lt;code&gt;asciiword&lt;/code&gt; （ASCIIワード）を、天文学用語の同義語辞書、一般的な英語辞書、Snowball英語ステマーにバインドできます。</target>
        </trans-unit>
        <trans-unit id="5f82a175fcf092449c33c188da71a078b0c24826" translate="yes" xml:space="preserve">
          <source>The generated array type's name is the scalar type's name with an underscore prepended. The array entry's other fields are filled from &lt;code&gt;BKI_ARRAY_DEFAULT(value)&lt;/code&gt; annotations in &lt;code&gt;pg_type.h&lt;/code&gt;, or if there isn't one, copied from the scalar type. (There's also a special case for &lt;code&gt;typalign&lt;/code&gt;.) Then the &lt;code&gt;typelem&lt;/code&gt; and &lt;code&gt;typarray&lt;/code&gt; fields of the two entries are set to cross-reference each other.</source>
          <target state="translated">生成される配列型の名前は、アンダースコアが前に付けられたスカラー型の名前です。配列エントリの他のフィールドは、 &lt;code&gt;pg_type.h&lt;/code&gt; の &lt;code&gt;BKI_ARRAY_DEFAULT(value)&lt;/code&gt; アノテーションから入力されます。アノテーションがない場合は、スカラー型からコピーされます。 （他にも特殊なケースがあります &lt;code&gt;typalign&lt;/code&gt; 。）次に &lt;code&gt;typelem&lt;/code&gt; と &lt;code&gt;typarray&lt;/code&gt; 2つのエントリのフィールドが互いに相互参照が設定されています。</target>
        </trans-unit>
        <trans-unit id="3eb30312d4c2f46733a2c8327c7814b6e7e52a77" translate="yes" xml:space="preserve">
          <source>The generated queries are executed in the order in which the rows are returned, and left-to-right within each row if there is more than one column. NULL fields are ignored. The generated queries are sent literally to the server for processing, so they cannot be psql meta-commands nor contain psql variable references. If any individual query fails, execution of the remaining queries continues unless &lt;code&gt;ON_ERROR_STOP&lt;/code&gt; is set. Execution of each query is subject to &lt;code&gt;ECHO&lt;/code&gt; processing. (Setting &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;queries&lt;/code&gt; is often advisable when using &lt;code&gt;\gexec&lt;/code&gt;.) Query logging, single-step mode, timing, and other query execution features apply to each generated query as well.</source>
          <target state="translated">生成されたクエリは、行が返される順序で実行され、列が複数ある場合は各行内で左から右に実行されます。 NULLフィールドは無視されます。生成されたクエリは文字通りサーバーに送信されて処理されるため、psqlメタコマンドにすることも、psql変数参照を含めることもできません。個々のクエリが失敗した場合、 &lt;code&gt;ON_ERROR_STOP&lt;/code&gt; が設定されていない限り、残りのクエリの実行が続行されます。各クエリの実行は、 &lt;code&gt;ECHO&lt;/code&gt; 処理の対象となります。 （ &lt;code&gt;\gexec&lt;/code&gt; を使用する場合、 &lt;code&gt;ECHO&lt;/code&gt; を &lt;code&gt;all&lt;/code&gt; または &lt;code&gt;queries&lt;/code&gt; 設定することをお勧めします。）クエリログ、シングルステップモード、タイミング、およびその他のクエリ実行機能は、生成された各クエリにも適用されます。</target>
        </trans-unit>
        <trans-unit id="b9932b57cc46c7c3eb3f68c8f986add5fa46c3a0" translate="yes" xml:space="preserve">
          <source>The generation expression can only use immutable functions and cannot use subqueries or reference anything other than the current row in any way.</source>
          <target state="translated">生成式は不変関数のみを使用することができ、サブクエリを使用したり、現在の行以外のものを参照したりすることはできません。</target>
        </trans-unit>
        <trans-unit id="491279f444aecfec04612928c73be9653a1967ca" translate="yes" xml:space="preserve">
          <source>The generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.</source>
          <target state="translated">生成式は、テーブル内の他の列を参照することはできますが、他の生成された列を参照することはできません。使用される関数や演算子はすべて不変でなければなりません。他のテーブルへの参照は許可されていません。</target>
        </trans-unit>
        <trans-unit id="107e72819959dbe843c78d42ff3ca5cede1b2e0f" translate="yes" xml:space="preserve">
          <source>The generic WAL redo function will acquire exclusive locks to buffers in the same order as they were registered. After redoing all changes, the locks will be released in the same order.</source>
          <target state="translated">一般的なWALのやり直し機能は、登録した順番通りにバッファに対して排他的なロックを取得します。すべての変更をやり直した後、同じ順番でロックが解除されます。</target>
        </trans-unit>
        <trans-unit id="82aaa212b0dcfe65dc390eb2bddcbdc50aeac8ad" translate="yes" xml:space="preserve">
          <source>The genetic algorithm (GA) is a heuristic optimization method which operates through randomized search. The set of possible solutions for the optimization problem is considered as a &lt;em&gt;population&lt;/em&gt; of &lt;em&gt;individuals&lt;/em&gt;. The degree of adaptation of an individual to its environment is specified by its &lt;em&gt;fitness&lt;/em&gt;.</source>
          <target state="translated">遺伝的アルゴリズム（GA）は、ランダム化された検索を通じて動作するヒューリスティックな最適化手法です。最適化問題の可能な解決策のセットは、&lt;em&gt;個人の&lt;/em&gt;&lt;em&gt;母集団&lt;/em&gt;と見なされます。個人の環境への適応の度合いは、その&lt;em&gt;適応度&lt;/em&gt;によって指定されます。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7ee74388f5d56affe1f244671fe03aad5cc5e12c" translate="yes" xml:space="preserve">
          <source>The genetic query optimizer (GEQO) is an algorithm that does query planning using heuristic searching. This reduces planning time for complex queries (those joining many relations), at the cost of producing plans that are sometimes inferior to those found by the normal exhaustive-search algorithm. For more information see &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;.</source>
          <target state="translated">遺伝的クエリオプティマイザー（GEQO）は、ヒューリスティック検索を使用してクエリ計画を行うアルゴリズムです。これにより、複雑なクエリ（多くのリレーションを結合するクエリ）の計画時間が短縮されますが、通常の全数検索アルゴリズムで見つかる計画よりも劣る計画が作成されることになります。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;第59章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="be4cf5614687e283544003825f41ef8216ea5370" translate="yes" xml:space="preserve">
          <source>The geometric types &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, and &lt;code&gt;circle&lt;/code&gt; have a large set of native support functions and operators, shown in &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-OP-TABLE&quot;&gt;Table 9.34&lt;/a&gt;, &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-FUNC-TABLE&quot;&gt;Table 9.35&lt;/a&gt;, and &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-CONV-TABLE&quot;&gt;Table 9.36&lt;/a&gt;.</source>
          <target state="translated">幾何学型 &lt;code&gt;point&lt;/code&gt; 、 &lt;code&gt;box&lt;/code&gt; 、 &lt;code&gt;lseg&lt;/code&gt; 、 &lt;code&gt;line&lt;/code&gt; 、 &lt;code&gt;path&lt;/code&gt; 、 &lt;code&gt;polygon&lt;/code&gt; 、および &lt;code&gt;circle&lt;/code&gt; には、&lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-OP-TABLE&quot;&gt;Table 9.34&lt;/a&gt;、&lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-FUNC-TABLE&quot;&gt;Table 9.35&lt;/a&gt;、および&lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-CONV-TABLE&quot;&gt;Table 9.36&lt;/a&gt;に示すネイティブサポート関数と演算子の大きなセットがあります。</target>
        </trans-unit>
        <trans-unit id="66e8935cc591dee18b7ed24a47a78f49e5afb1a3" translate="yes" xml:space="preserve">
          <source>The geometry of measurements is usually more complex than that of a point in a numeric continuum. A measurement is usually a segment of that continuum with somewhat fuzzy limits. The measurements come out as intervals because of uncertainty and randomness, as well as because the value being measured may naturally be an interval indicating some condition, such as the temperature range of stability of a protein.</source>
          <target state="translated">測定の幾何学的形状は、通常、数値連続体の点よりも複雑です。測定は、通常、ややあいまいな限界を持つ連続体のセグメントです。測定は、不確実性とランダム性のために、また、測定される値が当然のことながら、タンパク質の安定性の温度範囲など、何らかの条件を示す間隔である場合があるために、間隔として出てきます。</target>
        </trans-unit>
        <trans-unit id="443b3b682ab171a2c355d696fdc2acc186cfef4d" translate="yes" xml:space="preserve">
          <source>The given password is hashed using a String2Key (S2K) algorithm. This is rather similar to &lt;code&gt;crypt()&lt;/code&gt; algorithms &amp;mdash; purposefully slow and with random salt &amp;mdash; but it produces a full-length binary key.</source>
          <target state="translated">指定されたパスワードは、String2Key（S2K）アルゴリズムを使用してハッシュされます。これは &lt;code&gt;crypt()&lt;/code&gt; アルゴリズムに似ています&amp;mdash;意図的に遅く、ランダムなソルトを使用します&amp;mdash;が、完全長のバイナリキーを生成します。</target>
        </trans-unit>
        <trans-unit id="a0b9a6b33b61484344b41d8768ea944df1857641" translate="yes" xml:space="preserve">
          <source>The header extension area is envisioned to contain a sequence of self-identifying chunks. The flags field is not intended to tell readers what is in the extension area. Specific design of header extension contents is left for a later release.</source>
          <target state="translated">ヘッダ拡張領域は、自己識別可能な一連のチャンクを含むことを想定しています。フラグフィールドは、拡張領域に何があるかを読者に伝えることを意図していません。ヘッダ拡張内容の具体的な設計は後のリリースに委ねられています。</target>
        </trans-unit>
        <trans-unit id="6e01e0ce077bd1d9c99c3825e5edad48a491fa26" translate="yes" xml:space="preserve">
          <source>The horizontal header, displayed as the first row, contains the values found in column &lt;code&gt;colH&lt;/code&gt;, with duplicates removed. By default, these appear in the same order as in the query results. But if the optional &lt;code&gt;sortcolH&lt;/code&gt; argument is given, it identifies a column whose values must be integer numbers, and the values from &lt;code&gt;colH&lt;/code&gt; will appear in the horizontal header sorted according to the corresponding &lt;code&gt;sortcolH&lt;/code&gt; values.</source>
          <target state="translated">最初の行として表示される水平ヘッダーには、列 &lt;code&gt;colH&lt;/code&gt; で見つかった値が含まれ、重複が削除されています。デフォルトでは、これらはクエリ結果と同じ順序で表示されます。ただし、オプションの &lt;code&gt;sortcolH&lt;/code&gt; 引数が指定されている場合、それは値が整数でなければならない列を識別し、 &lt;code&gt;colH&lt;/code&gt; からの値は対応する &lt;code&gt;sortcolH&lt;/code&gt; 値に従ってソートされた水平ヘッダーに表示されます。</target>
        </trans-unit>
        <trans-unit id="323272ce1c2fce6128855defbc54368c470d5d34" translate="yes" xml:space="preserve">
          <source>The host name and port number of the primary, connection user name, and password are specified in the &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt;. The password can also be set in the &lt;code&gt;~/.pgpass&lt;/code&gt; file on the standby (specify &lt;code&gt;replication&lt;/code&gt; in the &lt;code&gt;database&lt;/code&gt; field). For example, if the primary is running on host IP &lt;code&gt;192.168.1.50&lt;/code&gt;, port &lt;code&gt;5432&lt;/code&gt;, the account name for replication is &lt;code&gt;foo&lt;/code&gt;, and the password is &lt;code&gt;foopass&lt;/code&gt;, the administrator can add the following line to the &lt;code&gt;postgresql.conf&lt;/code&gt; file on the standby:</source>
          <target state="translated">プライマリのホスト名とポート番号、接続ユーザー名、およびパスワードは、&lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfoで&lt;/a&gt;指定されます。パスワードは、スタンバイの &lt;code&gt;~/.pgpass&lt;/code&gt; ファイルでも設定できます（ &lt;code&gt;database&lt;/code&gt; フィールドで &lt;code&gt;replication&lt;/code&gt; を指定します）。たとえば、プライマリがホストIP &lt;code&gt;192.168.1.50&lt;/code&gt; 、ポート &lt;code&gt;5432&lt;/code&gt; で実行されており、レプリケーションのアカウント名が &lt;code&gt;foo&lt;/code&gt; で、パスワードが &lt;code&gt;foopass&lt;/code&gt; の場合、管理者は次の行をスタンバイの &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルに追加できます。</target>
        </trans-unit>
        <trans-unit id="41cfca1d0872f04d37ad8cb9cbf3834cb90f01db" translate="yes" xml:space="preserve">
          <source>The host name of the database server, truncated at the first dot, or &lt;code&gt;[local]&lt;/code&gt; if the connection is over a Unix domain socket.</source>
          <target state="translated">最初のドットで切り捨てられたデータベースサーバーのホスト名、または接続がUnixドメインソケットを介している場合は &lt;code&gt;[local]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b7649f0038242a26a0c621f7315d0b3f51c7304" translate="yes" xml:space="preserve">
          <source>The hour component of the time zone offset</source>
          <target state="translated">タイムゾーンオフセットの時間成分</target>
        </trans-unit>
        <trans-unit id="6ced8e552c81e4a5ec5eb0ba5039b71c87a5c484" translate="yes" xml:space="preserve">
          <source>The hour field (0 - 23)</source>
          <target state="translated">時間フィールド(0~23)</target>
        </trans-unit>
        <trans-unit id="842cd42d6043fc7261db6ee13e01b6e92f6c88ea" translate="yes" xml:space="preserve">
          <source>The i7-860 system measured runs the count query in 9.8 ms while the &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; version takes 16.6 ms, each processing just over 100,000 rows. That 6.8 ms difference means the timing overhead per row is 68 ns, about twice what pg_test_timing estimated it would be. Even that relatively small amount of overhead is making the fully timed count statement take almost 70% longer. On more substantial queries, the timing overhead would be less problematic.</source>
          <target state="translated">測定されたi7-860システムは9.8ミリ秒でカウントクエリを実行しますが、 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; バージョンは16.6ミリ秒かかり、各処理は100,000行をわずかに超えます。その6.8ミリ秒の差は、行ごとのタイミングオーバーヘッドが68 nsであることを意味し、pg_test_timingが見積もった値の約2倍です。オーバーヘッドが比較的小さい場合でも、完全に計時されたカウントステートメントはほぼ70％長くかかります。より実質的なクエリでは、タイミングのオーバーヘッドは問題にならないでしょう。</target>
        </trans-unit>
        <trans-unit id="fbf85920bba7cb75c10687cf6cd36aab7a7c9b2a" translate="yes" xml:space="preserve">
          <source>The idea behind this dump method is to generate a file with SQL commands that, when fed back to the server, will recreate the database in the same state as it was at the time of the dump. PostgreSQL provides the utility program &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; for this purpose. The basic usage of this command is:</source>
          <target state="translated">このダンプ方式の背後にある考え方は、サーバーにフィードバックされたときに、ダンプ時と同じ状態でデータベースを再作成するSQLコマンドを含むファイルを生成することです。PostgreSQLは、この目的のためにユーティリティプログラム&lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt;を提供しています。このコマンドの基本的な使用法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="6cf4bd1d2fa41d408b71387e9f46d7734f70e2c4" translate="yes" xml:space="preserve">
          <source>The ident authentication method works by obtaining the client's operating system user name from an ident server and using it as the allowed database user name (with an optional user name mapping). This is only supported on TCP/IP connections.</source>
          <target state="translated">この認証方法は、クライアントのオペレーティングシステムのユーザ名を ident サーバから取得し、それを許可されたデータベースのユーザ名として使用します (オプションでユーザ名のマッピングも可能です)。これは TCP/IP 接続でのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="75cef3c7a191b437000bac7046319a3652002a6f" translate="yes" xml:space="preserve">
          <source>The identifier of the prepared statement</source>
          <target state="translated">作成されたステートメントの識別子</target>
        </trans-unit>
        <trans-unit id="5814fec88046aa889ddca71e977eccd80834a133" translate="yes" xml:space="preserve">
          <source>The identity (transaction ID) of the deleting transaction, or zero for an undeleted row version. It is possible for this column to be nonzero in a visible row version. That usually indicates that the deleting transaction hasn't committed yet, or that an attempted deletion was rolled back.</source>
          <target state="translated">削除するトランザクションのID(トランザクションID)、または削除されていない行のバージョ ンの場合はゼロである。表示されている行のバージョンでは、この列が0以外の値になることもある。これは通常、削除するトランザクションがまだコミットされていないか、削除の試みがロールバックされたことを示す。</target>
        </trans-unit>
        <trans-unit id="7c52aeea0184eb0092fc19e054b01bbe20a261fc" translate="yes" xml:space="preserve">
          <source>The identity (transaction ID) of the inserting transaction for this row version. (A row version is an individual state of a row; each update of a row creates a new row version for the same logical row.)</source>
          <target state="translated">この行バージョンの挿入トランザクションの ID (トランザクション ID)。(行バージョンは、行の個々の状態です。行の各更新は、同じ論理行の新しい行バージョンを作成します)。</target>
        </trans-unit>
        <trans-unit id="61965181bc017854598b0845bd8393cd487f7cfb" translate="yes" xml:space="preserve">
          <source>The implementation does not resist &lt;a href=&quot;https://en.wikipedia.org/wiki/Side-channel_attack&quot;&gt;side-channel attacks&lt;/a&gt;. For example, the time required for a &lt;code&gt;pgcrypto&lt;/code&gt; decryption function to complete varies among ciphertexts of a given size.</source>
          <target state="translated">実装は&lt;a href=&quot;https://en.wikipedia.org/wiki/Side-channel_attack&quot;&gt;サイドチャネル攻撃に&lt;/a&gt;抵抗しません。たとえば、 &lt;code&gt;pgcrypto&lt;/code&gt; 復号化関数の完了に必要な時間は、所定のサイズの暗号文によって異なります。</target>
        </trans-unit>
        <trans-unit id="a096978b727394f0a665fb7212a971c3ee9889e1" translate="yes" xml:space="preserve">
          <source>The implemented SASL mechanisms at the moment are &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; and its variant with channel binding &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt;. They are described in detail in RFC 7677 and RFC 5802.</source>
          <target state="translated">現在実装されているSASLメカニズムは、 &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; と、チャネルバインディング &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; を備えたそのバリアントです。それらはRFC 7677およびRFC 5802で詳細に説明されています。</target>
        </trans-unit>
        <trans-unit id="3994c1cc646c4ef5a61a7d412fe3e39d9a284414" translate="yes" xml:space="preserve">
          <source>The index access costs should be computed using the parameters used by &lt;code&gt;src/backend/optimizer/path/costsize.c&lt;/code&gt;: a sequential disk block fetch has cost &lt;code&gt;seq_page_cost&lt;/code&gt;, a nonsequential fetch has cost &lt;code&gt;random_page_cost&lt;/code&gt;, and the cost of processing one index row should usually be taken as &lt;code&gt;cpu_index_tuple_cost&lt;/code&gt;. In addition, an appropriate multiple of &lt;code&gt;cpu_operator_cost&lt;/code&gt; should be charged for any comparison operators invoked during index processing (especially evaluation of the indexquals themselves).</source>
          <target state="translated">インデックスアクセスコストは、 &lt;code&gt;src/backend/optimizer/path/costsize.c&lt;/code&gt; で使用されるパラメーターを使用して計算する必要があります。シーケンシャルディスクブロックフェッチにはコスト &lt;code&gt;seq_page_cost&lt;/code&gt; があり、非シーケンシャルフェッチにはコスト &lt;code&gt;random_page_cost&lt;/code&gt; があり、1つのインデックス行を処理するコストは通常 &lt;code&gt;cpu_index_tuple_cost&lt;/code&gt; として取得されます。さらに、インデックスの処理中に呼び出される比較演算子（特に、indexquals自体の評価）に対して、cpu_operator_costの適切な倍数を &lt;code&gt;cpu_operator_cost&lt;/code&gt; 必要があります。</target>
        </trans-unit>
        <trans-unit id="6fef8227d6c9875a9adfc4cf6467a2aea1121c60" translate="yes" xml:space="preserve">
          <source>The index access path being considered. All fields except cost and selectivity values are valid.</source>
          <target state="translated">考慮されるインデックスアクセスパス。コストと選択性の値を除くすべてのフィールドが有効です。</target>
        </trans-unit>
        <trans-unit id="47ab406c0502c2ff0920580c5626f87c7d3ac514" translate="yes" xml:space="preserve">
          <source>The index automatically uses the collation of the underlying column. So a query of the form</source>
          <target state="translated">インデックスは自動的に基礎となるカラムの照合を使用します。そのため、次のような形式のクエリを実行します。</target>
        </trans-unit>
        <trans-unit id="d40d5a355329bb21744bf91012270d4b7eadd19f" translate="yes" xml:space="preserve">
          <source>The index cannot have expression columns nor be a partial index. Also, it must be a b-tree index with default sort ordering. These restrictions ensure that the index is equivalent to one that would be built by a regular &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; or &lt;code&gt;ADD UNIQUE&lt;/code&gt; command.</source>
          <target state="translated">インデックスに式列を含めることも、部分インデックスにすることもできません。また、デフォルトのソート順のBツリーインデックスである必要があります。これらの制限により、インデックスは通常の &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; コマンドまたは &lt;code&gt;ADD UNIQUE&lt;/code&gt; コマンドによって作成されるインデックスと同等になります。</target>
        </trans-unit>
        <trans-unit id="78493f3623537c9a38e59ae58540f722627b962f" translate="yes" xml:space="preserve">
          <source>The index construction and maintenance functions that an index access method must provide in &lt;code&gt;IndexAmRoutine&lt;/code&gt; are:</source>
          <target state="translated">インデックスアクセスメソッドが &lt;code&gt;IndexAmRoutine&lt;/code&gt; で提供する必要があるインデックス構築およびメンテナンス関数は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="3039446ce33001ce11d9ef4cc9e239f9e80ff013" translate="yes" xml:space="preserve">
          <source>The index is being built by the access method-specific code. In this phase, access methods that support progress reporting fill in their own progress data, and the subphase is indicated in this column. Typically, &lt;code&gt;blocks_total&lt;/code&gt; and &lt;code&gt;blocks_done&lt;/code&gt; will contain progress data, as well as potentially &lt;code&gt;tuples_total&lt;/code&gt; and &lt;code&gt;tuples_done&lt;/code&gt;.</source>
          <target state="translated">インデックスは、アクセス方法固有のコードによって構築されています。このフェーズでは、進行状況レポートをサポートするアクセスメソッドが独自の進行状況データを入力し、サブフェーズがこの列に示されます。典型的には、 &lt;code&gt;blocks_total&lt;/code&gt; と &lt;code&gt;blocks_done&lt;/code&gt; は、進捗データを含むことになる、ならびに潜在 &lt;code&gt;tuples_total&lt;/code&gt; と &lt;code&gt;tuples_done&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8974784c29c6386bf1253069fdf16bf07fbf780" translate="yes" xml:space="preserve">
          <source>The index is created with a signature length of 80 bits, with attributes i1 and i2 mapped to 2 bits, and attribute i3 mapped to 4 bits. We could have omitted the &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;col1&lt;/code&gt;, and &lt;code&gt;col2&lt;/code&gt; specifications since those have the default values.</source>
          <target state="translated">インデックスは、80ビットの署名長で作成され、属性i1およびi2は2ビットにマッピングされ、属性i3は4ビットにマッピングされます。 &lt;code&gt;length&lt;/code&gt; 、 &lt;code&gt;col1&lt;/code&gt; 、および &lt;code&gt;col2&lt;/code&gt; の指定にはデフォルト値があるため、これらを省略することもできます。</target>
        </trans-unit>
        <trans-unit id="f53b14842204c3afdf4a8da34fde71ed13d02632" translate="yes" xml:space="preserve">
          <source>The index method's strategy number for an operator associated with the operator class.</source>
          <target state="translated">演算子クラスに関連付けられた演算子のインデックスメソッドのストラテジー番号。</target>
        </trans-unit>
        <trans-unit id="62c3a3b1a4517180b23038b6d08f465908556b8b" translate="yes" xml:space="preserve">
          <source>The index method's strategy number for an operator associated with the operator family.</source>
          <target state="translated">演算子ファミリーに関連付けられた演算子のインデックスメソッドのストラテジー番号。</target>
        </trans-unit>
        <trans-unit id="4a128fb2d5e95c4a7976acace79bbc58b6fb276b" translate="yes" xml:space="preserve">
          <source>The index method's support function number for a function associated with the operator class.</source>
          <target state="translated">演算子クラスに関連付けられた関数のインデックスメソッドのサポート関数番号。</target>
        </trans-unit>
        <trans-unit id="8c74967c2b0a4ae3a48c94ba4d59d1361af52eba" translate="yes" xml:space="preserve">
          <source>The index method's support function number for a function associated with the operator family.</source>
          <target state="translated">演算子ファミリに関連付けられた関数のインデックスメソッドのサポート関数番号。</target>
        </trans-unit>
        <trans-unit id="dfbc9f2ec43f190a4f4b92d5261f2d63618ce86e" translate="yes" xml:space="preserve">
          <source>The index search works by extracting trigrams from the regular expression and then looking these up in the index. The more trigrams that can be extracted from the regular expression, the more effective the index search is. Unlike B-tree based searches, the search string need not be left-anchored.</source>
          <target state="translated">インデックス検索は、正規表現からトリグラムを抽出し、それらをインデックスで検索することで機能します。正規表現から抽出できるトリグラムが多ければ多いほど、インデックス検索はより効果的です。B-treeベースの検索とは異なり、検索文字列は左アンカーである必要はありません。</target>
        </trans-unit>
        <trans-unit id="76d1075d790db56a70c52b9e9529c4e67b5fd660" translate="yes" xml:space="preserve">
          <source>The index search works by extracting trigrams from the search string and then looking these up in the index. The more trigrams in the search string, the more effective the index search is. Unlike B-tree based searches, the search string need not be left-anchored.</source>
          <target state="translated">インデックス検索は、検索文字列からトリグラムを抽出し、インデックスで検索することで機能します。検索文字列に含まれるトリグラムの数が多ければ多いほど、インデックス検索はより効果的です。B-treeベースの検索とは異なり、検索文字列は左アンカーである必要はありません。</target>
        </trans-unit>
        <trans-unit id="2ef045e734746214c8ad4568acd243c24cf2fcf6" translate="yes" xml:space="preserve">
          <source>The index supporting a unique, primary key, referential integrity, or exclusion constraint</source>
          <target state="translated">一意、主キー、参照整合性、または除外制約をサポートするインデックス。</target>
        </trans-unit>
        <trans-unit id="b1f015828c180dda3ed4f3bdc55e0086cb7fcc71" translate="yes" xml:space="preserve">
          <source>The index supporting this constraint, if it's a unique, primary key, foreign key, or exclusion constraint; else 0</source>
          <target state="translated">この制約をサポートするインデックス、それが一意、主キー、外部キー、または除外制約の場合。</target>
        </trans-unit>
        <trans-unit id="6c3b8559bb8c83cd05e198719da39b30d3fb1043" translate="yes" xml:space="preserve">
          <source>The index type must support index-only scans. B-tree indexes always do. GiST and SP-GiST indexes support index-only scans for some operator classes but not others. Other index types have no support. The underlying requirement is that the index must physically store, or else be able to reconstruct, the original data value for each index entry. As a counterexample, GIN indexes cannot support index-only scans because each index entry typically holds only part of the original data value.</source>
          <target state="translated">インデックスタイプは、インデックスのみのスキャンをサポートしている必要があります。B-treeインデックスは常にサポートしています。GiST と SP-GIST インデックスは、いくつかの演算子クラスについてはインデックスのみのスキャンをサポートしますが、他の演算子クラスについてはサポートしません。他のインデックス・タイプはサポートしていません。基本的な要件は、インデックスが各インデックス項目の元のデータ値を物理的に保存しなければならないか、あるいは再構築できなければならないということです。逆の例として、GINインデックスはインデックスのみのスキャンをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="a6836c640c52510a0b02e594ca8bbfc9b8103067" translate="yes" xml:space="preserve">
          <source>The indicated database user name was not found.</source>
          <target state="translated">指定されたデータベースのユーザー名が見つかりませんでした。</target>
        </trans-unit>
        <trans-unit id="20e3988dff010547d05b25cba96f92a2ac547dbd" translate="yes" xml:space="preserve">
          <source>The individual elements of a &lt;code&gt;CUBE&lt;/code&gt; or &lt;code&gt;ROLLUP&lt;/code&gt; clause may be either individual expressions, or sublists of elements in parentheses. In the latter case, the sublists are treated as single units for the purposes of generating the individual grouping sets. For example:</source>
          <target state="translated">&lt;code&gt;CUBE&lt;/code&gt; 句または &lt;code&gt;ROLLUP&lt;/code&gt; 句の個々の要素は、個々の式、または括弧内の要素のサブリストのいずれかです。後者の場合、サブリストは、個々のグループ化セットを生成するために単一のユニットとして扱われます。例えば：</target>
        </trans-unit>
        <trans-unit id="478f53ba771627a25e2c5229ba6d54c52bd271c5" translate="yes" xml:space="preserve">
          <source>The individual tables can be added and removed dynamically using &lt;a href=&quot;sql-alterpublication&quot;&gt;ALTER PUBLICATION&lt;/a&gt;. Both the &lt;code&gt;ADD TABLE&lt;/code&gt; and &lt;code&gt;DROP TABLE&lt;/code&gt; operations are transactional; so the table will start or stop replicating at the correct snapshot once the transaction has committed.</source>
          <target state="translated">個々のテーブルは、&lt;a href=&quot;sql-alterpublication&quot;&gt;ALTER PUBLICATION&lt;/a&gt;を使用して動的に追加および削除できます。 &lt;code&gt;ADD TABLE&lt;/code&gt; 操作と &lt;code&gt;DROP TABLE&lt;/code&gt; 操作はどちらもトランザクションです。したがって、トランザクションがコミットされると、テーブルは正しいスナップショットで複製を開始または停止します。</target>
        </trans-unit>
        <trans-unit id="55f0b3e0f4002ca62cb368b92a46147d06514b6c" translate="yes" xml:space="preserve">
          <source>The information passed to the client for a notification event includes the notification channel name, the notifying session's server process PID, and the payload string, which is an empty string if it has not been specified.</source>
          <target state="translated">通知イベントのためにクライアントに渡される情報には、通知チャネル名、通知セッションのサーバプロセスPID、ペイロード文字列(指定されていない場合は空文字列)が含まれます。</target>
        </trans-unit>
        <trans-unit id="044f2cd515098f5f363f2857b2c2afc07209265a" translate="yes" xml:space="preserve">
          <source>The information schema (&lt;a href=&quot;https://www.postgresql.org/docs/12/information-schema.html&quot;&gt;Chapter 36&lt;/a&gt;) provides an alternative set of views which overlap the functionality of the system views. Since the information schema is SQL-standard whereas the views described here are PostgreSQL-specific, it's usually better to use the information schema if it provides all the information you need.</source>
          <target state="translated">情報スキーマ（&lt;a href=&quot;https://www.postgresql.org/docs/12/information-schema.html&quot;&gt;第36章&lt;/a&gt;）は、システムビューの機能と重複するビューの代替セットを提供します。ここで説明するビューはPostgreSQL固有であるのに対し、情報スキーマはSQL標準であるため、必要なすべての情報を提供する場合は通常、情報スキーマを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1f201ea8f38230c6e8acfb095bb89803ef41bb1b" translate="yes" xml:space="preserve">
          <source>The information to implement this module was collected from several sites, including:</source>
          <target state="translated">このモジュールを実装するための情報は、以下のようないくつかのサイトから収集しました。</target>
        </trans-unit>
        <trans-unit id="8ffbbc2df15378d40a94e42b70d5fb5af1458af3" translate="yes" xml:space="preserve">
          <source>The initial access privileges; see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for details</source>
          <target state="translated">最初のアクセス権限。詳細については、&lt;a href=&quot;ddl-priv&quot;&gt;セクション5.7&lt;/a&gt;を参照してください</target>
        </trans-unit>
        <trans-unit id="8a1054b1ac592ae44e2cf9b51ca38fb26634ef49" translate="yes" xml:space="preserve">
          <source>The initial data in existing subscribed tables are snapshotted and copied in a parallel instance of a special kind of apply process. This process will create its own temporary replication slot and copy the existing data. Once existing data is copied, the worker enters synchronization mode, which ensures that the table is brought up to a synchronized state with the main apply process by streaming any changes that happened during the initial data copy using standard logical replication. Once the synchronization is done, the control of the replication of the table is given back to the main apply process where the replication continues as normal.</source>
          <target state="translated">既存のサブスクライブされたテーブルの初期データは、特殊な種類の適用プロセスの並列インスタンスでスナップショットされ、コピーされます。このプロセスは、それ自身の一時的なレプリケーション スロットを作成し、既存のデータをコピーします。既存のデータがコピーされると、ワーカーは同期モードに入り、標準の論理レプリケーションを使用して初期データコピー中に起こった変更をストリーミングすることで、テーブルがメインの適用プロセスと同期した状態に持ち込まれることを保証します。同期が行われると、テーブルのレプリケーションの制御は、通常通りレプリケーションが継続されるメイン適用プロセスに戻されます。</target>
        </trans-unit>
        <trans-unit id="257568e0871ee2fb3ae1bd84f534adce4db0bec5" translate="yes" xml:space="preserve">
          <source>The initial setting for the state value, when using moving-aggregate mode. This works the same as &lt;code&gt;initial_condition&lt;/code&gt;.</source>
          <target state="translated">移動集約モードを使用する場合の状態値の初期設定。これは、 &lt;code&gt;initial_condition&lt;/code&gt; と同じように機能します。</target>
        </trans-unit>
        <trans-unit id="eb62c8458668a0689948660586a0f8259374a819" translate="yes" xml:space="preserve">
          <source>The initial setting for the state value. This must be a string constant in the form accepted for the data type &lt;code&gt;state_data_type&lt;/code&gt;. If not specified, the state value starts out null.</source>
          <target state="translated">状態値の初期設定。これは、データ型 &lt;code&gt;state_data_type&lt;/code&gt; で受け入れられる形式の文字列定数でなければなりません。指定しない場合、状態値はnullから始まります。</target>
        </trans-unit>
        <trans-unit id="d82c96a461d121c75c52d8ce64285a1d86e2ab14" translate="yes" xml:space="preserve">
          <source>The initial value of the transition state for moving-aggregate mode. This is a text field containing the initial value in its external string representation. If this field is null, the transition state value starts out null.</source>
          <target state="translated">移動アグリゲートモードの遷移状態の初期値。これは、外部文字列表現の初期値を含むテキストフィールドです。このフィールドがNULLの場合、遷移状態の値はNULLから始まります。</target>
        </trans-unit>
        <trans-unit id="dfef147dfd625c38da29727096d66edbe7450de5" translate="yes" xml:space="preserve">
          <source>The initial value of the transition state. This is a text field containing the initial value in its external string representation. If this field is null, the transition state value starts out null.</source>
          <target state="translated">遷移状態の初期値。これは、外部文字列表現の初期値を含むテキスト・フィールドです。このフィールドがNULLの場合、遷移状態の値はNULLから始まります。</target>
        </trans-unit>
        <trans-unit id="6e8d9c8e49727d756d0711797450f963975e284e" translate="yes" xml:space="preserve">
          <source>The initially assigned data type of a numeric constant is just a starting point for the type resolution algorithms. In most cases the constant will be automatically coerced to the most appropriate type depending on context. When necessary, you can force a numeric value to be interpreted as a specific data type by casting it. For example, you can force a numeric value to be treated as type &lt;code&gt;real&lt;/code&gt; (&lt;code&gt;float4&lt;/code&gt;) by writing:</source>
          <target state="translated">最初に割り当てられた数値定数のデータ型は、型解決アルゴリズムの開始点にすぎません。ほとんどの場合、定数はコンテキストに応じて自動的に最適な型に強制変換されます。必要に応じて、キャストすることにより、数値を特定のデータ型として解釈させることができます。たとえば、次のように記述することで、数値を強制 &lt;code&gt;real&lt;/code&gt; 型（ &lt;code&gt;float4&lt;/code&gt; ）として扱うことができます。</target>
        </trans-unit>
        <trans-unit id="f4532069877c3839fd18c7cafdf1b166d436f334" translate="yes" xml:space="preserve">
          <source>The inner &lt;code&gt;UNION&lt;/code&gt; is resolved as emitting type &lt;code&gt;text&lt;/code&gt;, according to the rules given above. Then the outer &lt;code&gt;UNION&lt;/code&gt; has inputs of types &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;integer&lt;/code&gt;, leading to the observed error. The problem can be fixed by ensuring that the leftmost &lt;code&gt;UNION&lt;/code&gt; has at least one input of the desired result type.</source>
          <target state="translated">内側の &lt;code&gt;UNION&lt;/code&gt; は、上記の規則に従って、型付き &lt;code&gt;text&lt;/code&gt; として解決されます。次に、外側の &lt;code&gt;UNION&lt;/code&gt; にはタイプ &lt;code&gt;text&lt;/code&gt; および &lt;code&gt;integer&lt;/code&gt; の入力があり、観測されたエラーが発生します。左端の &lt;code&gt;UNION&lt;/code&gt; に目的の結果タイプの入力が少なくとも1つあることを確認することで、問題を解決できます。</target>
        </trans-unit>
        <trans-unit id="752b1c95a1eae331cb7a120fbc2cbc7b360efa2f" translate="yes" xml:space="preserve">
          <source>The input for a range value must follow one of the following patterns:</source>
          <target state="translated">範囲値の入力は、以下のパターンのいずれかに従う必要があります。</target>
        </trans-unit>
        <trans-unit id="5db960d2928db992e514ea865af6ec0e73cf5806" translate="yes" xml:space="preserve">
          <source>The input format for this type is &lt;code&gt;address/y&lt;/code&gt; where &lt;code&gt;address&lt;/code&gt; is an IPv4 or IPv6 address and &lt;code&gt;y&lt;/code&gt; is the number of bits in the netmask. If the &lt;code&gt;/y&lt;/code&gt; portion is missing, the netmask is 32 for IPv4 and 128 for IPv6, so the value represents just a single host. On display, the &lt;code&gt;/y&lt;/code&gt; portion is suppressed if the netmask specifies a single host.</source>
          <target state="translated">このタイプの入力フォーマットは、 &lt;code&gt;address/y&lt;/code&gt; &lt;code&gt;address&lt;/code&gt; IPv4またはIPv6アドレスであり、 &lt;code&gt;y&lt;/code&gt; はネットマスクのビット数です。場合 &lt;code&gt;/y&lt;/code&gt; の部分が欠落している値は、単に単一のホストを表すように、ネットマスクは、IPv4の場合32およびIPv6の128です。表示では、ネットマスクが単一のホストを指定している場合、 &lt;code&gt;/y&lt;/code&gt; の部分は抑制されます。</target>
        </trans-unit>
        <trans-unit id="1496dddf6a6d3aece3a51059d08e155ea1323eea" translate="yes" xml:space="preserve">
          <source>The input/output syntax for the JSON data types is as specified in RFC 7159.</source>
          <target state="translated">JSON データ型の入出力構文は、RFC 7159 で規定されています。</target>
        </trans-unit>
        <trans-unit id="03aa7e8fbd88e7f3d34658426c4782d01d3a8689" translate="yes" xml:space="preserve">
          <source>The intended use of the &lt;code&gt;pause&lt;/code&gt; setting is to allow queries to be executed against the database to check if this recovery target is the most desirable point for recovery. The paused state can be resumed by using &lt;code&gt;pg_wal_replay_resume()&lt;/code&gt; (see &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.86&lt;/a&gt;), which then causes recovery to end. If this recovery target is not the desired stopping point, then shut down the server, change the recovery target settings to a later target and restart to continue recovery.</source>
          <target state="translated">&lt;code&gt;pause&lt;/code&gt; 設定の使用目的は、データベースに対してクエリを実行して、このリカバリターゲットがリカバリに最も望ましいポイントであるかどうかを確認できるようにすることです。一時停止状態は、 &lt;code&gt;pg_wal_replay_resume()&lt;/code&gt; （&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;表9.86を&lt;/a&gt;参照）を使用して再開できます。これにより、リカバリが終了します。このリカバリターゲットが目的の停止ポイントでない場合は、サーバーをシャットダウンし、リカバリターゲットの設定を新しいターゲットに変更し、再起動してリカバリを続行します。</target>
        </trans-unit>
        <trans-unit id="eae9a7b2978d9149a7d3a255f37f5ad888745278" translate="yes" xml:space="preserve">
          <source>The intended use of this setting is that logical replication systems set it to &lt;code&gt;replica&lt;/code&gt; when they are applying replicated changes. The effect of that will be that triggers and rules (that have not been altered from their default configuration) will not fire on the replica. See the &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; clauses &lt;code&gt;ENABLE TRIGGER&lt;/code&gt; and &lt;code&gt;ENABLE RULE&lt;/code&gt; for more information.</source>
          <target state="translated">この設定の使用目的は、論理的なレプリケーション・システムがそれを設定することである &lt;code&gt;replica&lt;/code&gt; 彼らは複製された変更を適用しているとき。その影響は、トリガーとルール（デフォルトの構成から変更されていないもの）がレプリカで起動されないことです。詳細については、&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;句の &lt;code&gt;ENABLE TRIGGER&lt;/code&gt; および &lt;code&gt;ENABLE RULE&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="e73e54c88ad65514d99a46ba805b5445c9c890d2" translate="yes" xml:space="preserve">
          <source>The intent of this feature is to allow administrators to reduce the I/O impact of these commands on concurrent database activity. There are many situations where it is not important that maintenance commands like &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;ANALYZE&lt;/code&gt; finish quickly; however, it is usually very important that these commands do not significantly interfere with the ability of the system to perform other database operations. Cost-based vacuum delay provides a way for administrators to achieve this.</source>
          <target state="translated">この機能の目的は、管理者が並行データベースアクティビティに対するこれらのコマンドのI / Oの影響を軽減できるようにすることです。 &lt;code&gt;VACUUM&lt;/code&gt; や &lt;code&gt;ANALYZE&lt;/code&gt; のようなメンテナンスコマンドが迅速に終了することが重要ではない状況はたくさんあります。ただし、これらのコマンドが他のデータベース操作を実行するシステムの機能を大幅に妨害しないことが通常は非常に重要です。コストベースのバキューム遅延は、管理者がこれを達成する方法を提供します。</target>
        </trans-unit>
        <trans-unit id="3ce7c282b1076520793e0399674bfd41329343fd" translate="yes" xml:space="preserve">
          <source>The intent of this feature is to allow debugging or performance-measurement libraries to be loaded into specific sessions without an explicit &lt;code&gt;LOAD&lt;/code&gt; command being given. For example, &lt;a href=&quot;auto-explain&quot;&gt;auto_explain&lt;/a&gt; could be enabled for all sessions under a given user name by setting this parameter with &lt;code&gt;ALTER ROLE SET&lt;/code&gt;. Also, this parameter can be changed without restarting the server (but changes only take effect when a new session is started), so it is easier to add new modules this way, even if they should apply to all sessions.</source>
          <target state="translated">この機能の目的は、明示的な &lt;code&gt;LOAD&lt;/code&gt; コマンドを指定しなくても、デバッグまたはパフォーマンス測定ライブラリを特定のセッションにロードできるようにすることです。たとえば、 &lt;code&gt;ALTER ROLE SET&lt;/code&gt; でこのパラメーターを設定することにより、特定のユーザー名の下のすべてのセッションで&lt;a href=&quot;auto-explain&quot;&gt;auto_explain&lt;/a&gt;を有効にすることができます。また、このパラメーターはサーバーを再起動せずに変更できます（ただし、変更は新しいセッションが開始されたときにのみ有効になるため）、すべてのセッションに適用する必要がある場合でも、この方法で新しいモジュールを追加する方が簡単です。</target>
        </trans-unit>
        <trans-unit id="a2719b729cd7a399352ec70d46ec3bef1938f299" translate="yes" xml:space="preserve">
          <source>The intent of this feature is to allow unprivileged users to load debugging or performance-measurement libraries into specific sessions without requiring an explicit &lt;code&gt;LOAD&lt;/code&gt; command. To that end, it would be typical to set this parameter using the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable on the client or by using &lt;code&gt;ALTER ROLE SET&lt;/code&gt;.</source>
          <target state="translated">この機能の目的は、特権を持たないユーザーが明示的な &lt;code&gt;LOAD&lt;/code&gt; コマンドを必要とせずに、デバッグまたはパフォーマンス測定ライブラリを特定のセッションにロードできるようにすることです。そのためには、クライアントの &lt;code&gt;PGOPTIONS&lt;/code&gt; 環境変数を使用するか、 &lt;code&gt;ALTER ROLE SET&lt;/code&gt; を使用して、このパラメーターを設定するのが一般的です。</target>
        </trans-unit>
        <trans-unit id="410143821cb3667d869f89c45a8792b1a3405b2c" translate="yes" xml:space="preserve">
          <source>The interface was changed in version 8.4, to reflect the new FSM implementation introduced in the same version.</source>
          <target state="translated">同バージョンで導入された新しいFSM実装を反映させるために、バージョン8.4でインターフェースが変更されました。</target>
        </trans-unit>
        <trans-unit id="2585564a6c8456926cf3442c468ac844142dcda1" translate="yes" xml:space="preserve">
          <source>The internal transaction ID type (&lt;code&gt;xid&lt;/code&gt;) is 32 bits wide and wraps around every 4 billion transactions. However, these functions export a 64-bit format that is extended with an &amp;ldquo;epoch&amp;rdquo; counter so it will not wrap around during the life of an installation. The data type used by these functions, &lt;code&gt;txid_snapshot&lt;/code&gt;, stores information about transaction ID visibility at a particular moment in time. Its components are described in &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT-PARTS&quot;&gt;Table 9.75&lt;/a&gt;.</source>
          <target state="translated">内部トランザクションIDタイプ（ &lt;code&gt;xid&lt;/code&gt; ）は32ビット幅で、40億トランザクションごとにラップされます。ただし、これらの関数は、「エポック」カウンターで拡張された64ビット形式をエクスポートするため、インストールの存続期間中にラップアラウンドしません。これらの関数で使用されるデータ型 &lt;code&gt;txid_snapshot&lt;/code&gt; は、特定の時点でのトランザクションIDの可視性に関する情報を格納します。そのコンポーネントについては、&lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT-PARTS&quot;&gt;表9.75で&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="ed88f1a587353da5320c94618461fa62d026126f" translate="yes" xml:space="preserve">
          <source>The inverse operation, producing a character string value from &lt;code&gt;xml&lt;/code&gt;, uses the function &lt;code&gt;xmlserialize&lt;/code&gt;:</source>
          <target state="translated">逆の操作では、 &lt;code&gt;xml&lt;/code&gt; から文字列値を生成し、関数 &lt;code&gt;xmlserialize&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="7d6e11429a0e8345e13107b3c0d526111bff86da" translate="yes" xml:space="preserve">
          <source>The isolation level of a transaction determines what data the transaction can see when other transactions are running concurrently:</source>
          <target state="translated">トランザクションの分離レベルは、他のトランザクションが同時に実行されているときに、そのトランザクションが見ることができるデータを決定します。</target>
        </trans-unit>
        <trans-unit id="e2ee987ab1ca440434d3e02dd908e8550d18dae5" translate="yes" xml:space="preserve">
          <source>The items themselves are stored in space allocated backwards from the end of unallocated space. The exact structure varies depending on what the table is to contain. Tables and sequences both use a structure named &lt;code&gt;HeapTupleHeaderData&lt;/code&gt;, described below.</source>
          <target state="translated">アイテム自体は、未割り当て領域の最後から後方に割り当てられた領域に格納されます。正確な構造は、テーブルに何を含めるかによって異なります。テーブルとシーケンスはどちらも、以下で説明する &lt;code&gt;HeapTupleHeaderData&lt;/code&gt; という名前の構造を使用します。</target>
        </trans-unit>
        <trans-unit id="e475eb2d988c6851551d574040f066c9556a439f" translate="yes" xml:space="preserve">
          <source>The join condition of an inner join can be written either in the &lt;code&gt;WHERE&lt;/code&gt; clause or in the &lt;code&gt;JOIN&lt;/code&gt; clause. For example, these table expressions are equivalent:</source>
          <target state="translated">内部結合の結合条件は、 &lt;code&gt;WHERE&lt;/code&gt; 句または &lt;code&gt;JOIN&lt;/code&gt; 句で記述できます。たとえば、次のテーブル式は同等です。</target>
        </trans-unit>
        <trans-unit id="61d61ab7e2b00d48bd33fdcfe38f2676100e3a4c" translate="yes" xml:space="preserve">
          <source>The join condition specified with &lt;code&gt;ON&lt;/code&gt; can also contain conditions that do not relate directly to the join. This can prove useful for some queries but needs to be thought out carefully. For example:</source>
          <target state="translated">&lt;code&gt;ON&lt;/code&gt; で指定された結合条件には、結合に直接関係しない条件を含めることもできます。これは、一部のクエリでは役立つ場合がありますが、慎重に検討する必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="3614aab2546a7b09e20ddc9fc01ce0160043ffc8" translate="yes" xml:space="preserve">
          <source>The join selectivity estimator function for this operator.</source>
          <target state="translated">この演算子の結合選択性推定関数。</target>
        </trans-unit>
        <trans-unit id="d643834432c9495e055ac02fd710963d0e899ceb" translate="yes" xml:space="preserve">
          <source>The join selectivity estimator function for this operator; write NONE to remove existing selectivity estimator.</source>
          <target state="translated">この演算子の結合選択性推定関数。</target>
        </trans-unit>
        <trans-unit id="e444824ca1c6f24ef2a354622bc8815bf038f6fd" translate="yes" xml:space="preserve">
          <source>The key and parent-key fields can be any data type, but they must be the same type. Note that the &lt;em&gt;&lt;code&gt;start_with&lt;/code&gt;&lt;/em&gt; value must be entered as a text string, regardless of the type of the key field.</source>
          <target state="translated">キーと親キーのフィールドは任意のデータ型にすることができますが、同じ型でなければなりません。&lt;em&gt; &lt;code&gt;start_with&lt;/code&gt; &lt;/em&gt;値は、キーフィールドのタイプに関係なく、テキスト文字列として入力する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5ed049b1b7aaa3ba51ad6c118d926aadc8da74a8" translate="yes" xml:space="preserve">
          <source>The key field(s) for the index are specified as column names, or alternatively as expressions written in parentheses. Multiple fields can be specified if the index method supports multicolumn indexes.</source>
          <target state="translated">インデックスのキーフィールドは、カラム名で指定するか、あるいは括弧内の式で指定します。インデックスメソッドがマルチカラムインデックスをサポートしている場合は、複数のフィールドを指定することができます。</target>
        </trans-unit>
        <trans-unit id="d640126eef92261555823243becabed1414b9599" translate="yes" xml:space="preserve">
          <source>The key part of a catalog header file is a C structure definition describing the layout of each row of the catalog. This begins with a &lt;code&gt;CATALOG&lt;/code&gt; macro, which so far as the C compiler is concerned is just shorthand for &lt;code&gt;typedef struct FormData_catalogname&lt;/code&gt;. Each field in the struct gives rise to a catalog column. Fields can be annotated using the BKI property macros described in &lt;code&gt;genbki.h&lt;/code&gt;, for example to define a default value for a field or mark it as nullable or not nullable. The &lt;code&gt;CATALOG&lt;/code&gt; line can also be annotated, with some other BKI property macros described in &lt;code&gt;genbki.h&lt;/code&gt;, to define other properties of the catalog as a whole, such as whether it is a shared relation.</source>
          <target state="translated">カタログヘッダーファイルの重要な部分は、カタログの各行のレイアウトを記述するC構造体の定義です。これは &lt;code&gt;CATALOG&lt;/code&gt; マクロで始まります。Cコンパイラに関する限り、Cマクロは &lt;code&gt;typedef struct FormData_catalogname&lt;/code&gt; の省略形です。構造体の各フィールドは、カタログ列を生成します。 &lt;code&gt;genbki.h&lt;/code&gt; で説明されているBKIプロパティマクロを使用してフィールドに注釈を付けることができます。たとえば、フィールドのデフォルト値を定義したり、フィールドをnull可能またはnull不可としてマークしたりできます。 &lt;code&gt;CATALOG&lt;/code&gt; ラインはまた、記載されるいくつかの他のBKI性マクロと、注釈を付けることができる &lt;code&gt;genbki.h&lt;/code&gt; 例えば、共有関係であるかどうかのように、全体としてカタログの他のプロパティを定義します。</target>
        </trans-unit>
        <trans-unit id="84768082ee997613deb3f74ec096a132ad1ca977" translate="yes" xml:space="preserve">
          <source>The key part of all this is to set up a recovery configuration that describes how you want to recover and how far the recovery should run. The one thing that you absolutely must specify is the &lt;code&gt;restore_command&lt;/code&gt;, which tells PostgreSQL how to retrieve archived WAL file segments. Like the &lt;code&gt;archive_command&lt;/code&gt;, this is a shell command string. It can contain &lt;code&gt;%f&lt;/code&gt;, which is replaced by the name of the desired log file, and &lt;code&gt;%p&lt;/code&gt;, which is replaced by the path name to copy the log file to. (The path name is relative to the current working directory, i.e., the cluster's data directory.) Write &lt;code&gt;%%&lt;/code&gt; if you need to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command. The simplest useful command is something like:</source>
          <target state="translated">これらすべての重要な部分は、どのように回復したいか、どの程度回復を実行する必要があるかを説明する回復構成をセットアップすることです。絶対に指定する必要があるのは、 &lt;code&gt;restore_command&lt;/code&gt; です。これは、アーカイブされたWALファイルセグメントを取得する方法をPostgreSQLに指示します。 &lt;code&gt;archive_command&lt;/code&gt; と同様に、これはシェルコマンド文字列です。これには、目的のログファイルの名前に置き換えられた &lt;code&gt;%f&lt;/code&gt; と、ログファイルのコピー先のパス名に置き換えられた &lt;code&gt;%p&lt;/code&gt; を含めることができます。 （パス名は、現在の作業ディレクトリ、つまりクラスターのデータディレクトリからの相対パスです。）コマンドに実際の &lt;code&gt;%&lt;/code&gt; 文字を埋め込む必要がある場合は、 &lt;code&gt;%%&lt;/code&gt; と記述します。最も簡単で便利なコマンドは次のようなものです。</target>
        </trans-unit>
        <trans-unit id="6ce0e2cb46720b77226f610a445bda26007f0b40" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;COLUMN&lt;/code&gt; is noise and can be omitted.</source>
          <target state="translated">キーワード &lt;code&gt;COLUMN&lt;/code&gt; はノイズであり、省略できます。</target>
        </trans-unit>
        <trans-unit id="5b5ac0f06c70f1fb5409349bf24004b2a55d2f18" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;EXTERNAL&lt;/code&gt; is allowed for SQL conformance, but it is optional since, unlike in SQL, this feature applies to all functions not only external ones.</source>
          <target state="translated">キーワード &lt;code&gt;EXTERNAL&lt;/code&gt; は、SQL準拠のために許可されていますが、SQLとは異なり、この機能は外部関数だけでなくすべての関数に適用されるため、オプションです。</target>
        </trans-unit>
        <trans-unit id="7b66b886be54f4dad1fc59336fb968283aedd583" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;EXTERNAL&lt;/code&gt; is allowed for SQL conformance, but it is optional since, unlike in SQL, this feature applies to all procedures not only external ones.</source>
          <target state="translated">キーワード &lt;code&gt;EXTERNAL&lt;/code&gt; は、SQL適合のために許可されていますが、SQLとは異なり、この機能は外部のプロシージャだけでなくすべてのプロシージャに適用されるため、オプションです。</target>
        </trans-unit>
        <trans-unit id="f14ab28890a5b7ef2546dae62a05463965282a2c" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;ILIKE&lt;/code&gt; can be used instead of &lt;code&gt;LIKE&lt;/code&gt; to make the match case-insensitive according to the active locale. This is not in the SQL standard but is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; の代わりにキーワード &lt;code&gt;ILIKE&lt;/code&gt; を使用して、アクティブなロケールに応じて一致の大文字と小文字を区別することができます。これはSQL標準にはありませんが、PostgreSQLの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="56bcc837725f3c99bfbefa9f4ad797df653bb446" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;PUBLIC&lt;/code&gt; indicates that the privileges are to be granted to all roles, including those that might be created later. &lt;code&gt;PUBLIC&lt;/code&gt; can be thought of as an implicitly defined group that always includes all roles. Any particular role will have the sum of privileges granted directly to it, privileges granted to any role it is presently a member of, and privileges granted to &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">キーワード &lt;code&gt;PUBLIC&lt;/code&gt; は、特権が、後で作成される可能性があるものも含めて、すべての役割に付与されることを示します。 &lt;code&gt;PUBLIC&lt;/code&gt; は、常にすべての役割を含む暗黙的に定義されたグループと考えることができます。特定のロールには、直接付与された特権、現在メンバーとなっているロールに付与された特権、および &lt;code&gt;PUBLIC&lt;/code&gt; に付与された特権の合計が含まれます。</target>
        </trans-unit>
        <trans-unit id="099dc57512200b2d79974967fc17d8da0e67f388" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;ROW&lt;/code&gt; is optional when there is more than one expression in the list.</source>
          <target state="translated">リストに複数の式がある場合、キーワード &lt;code&gt;ROW&lt;/code&gt; はオプションです。</target>
        </trans-unit>
        <trans-unit id="f75dcd3d9f2023dad0df5e4baecf4f11764e4ecf" translate="yes" xml:space="preserve">
          <source>The key words &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;INSENSITIVE&lt;/code&gt;, and &lt;code&gt;SCROLL&lt;/code&gt; can appear in any order.</source>
          <target state="translated">キーワード &lt;code&gt;BINARY&lt;/code&gt; 、 &lt;code&gt;INSENSITIVE&lt;/code&gt; 、および &lt;code&gt;SCROLL&lt;/code&gt; は任意の順序で使用できます。</target>
        </trans-unit>
        <trans-unit id="933ba0b83729a47d657b68dbaf9310c7b7c42eff" translate="yes" xml:space="preserve">
          <source>The key words &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; are the preferred (SQL-compliant) method for writing Boolean constants in SQL queries. But you can also use the string representations by following the generic string-literal constant syntax described in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;Section 4.1.2.7&lt;/a&gt;, for example &lt;code&gt;'yes'::boolean&lt;/code&gt;.</source>
          <target state="translated">キーワード &lt;code&gt;TRUE&lt;/code&gt; および &lt;code&gt;FALSE&lt;/code&gt; は、SQLクエリでブール定数を書き込むための推奨される（SQL準拠）メソッドです。しかし、&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;セクション4.1.2.7&lt;/a&gt;で説明されている一般的な文字列リテラル定数構文に従うことにより、文字列表現を使用することもできます（例： &lt;code&gt;'yes'::boolean&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="301ce5b56290e04645decb19cd60fcc9e64d775e" translate="yes" xml:space="preserve">
          <source>The keytab file is generated by the Kerberos software; see the Kerberos documentation for details. The following example is for MIT-compatible Kerberos 5 implementations:</source>
          <target state="translated">keytabファイルはKerberosソフトウェアによって生成されます。以下の例は、MIT互換のKerberos 5の実装のためのものです。</target>
        </trans-unit>
        <trans-unit id="77aaa5ebf06bbbd98db8e2f5ba28cce520375eb5" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;ANY&lt;/code&gt;, coupled with &lt;code&gt;num_sync&lt;/code&gt;, specifies a quorum-based synchronous replication and makes transaction commits wait until their WAL records are replicated to &lt;em&gt;at least&lt;/em&gt;&lt;code&gt;num_sync&lt;/code&gt; listed standbys. For example, a setting of &lt;code&gt;ANY 3 (s1, s2, s3, s4)&lt;/code&gt; will cause each commit to proceed as soon as at least any three standbys of &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt; reply.</source>
          <target state="translated">キーワード &lt;code&gt;ANY&lt;/code&gt; は、 &lt;code&gt;num_sync&lt;/code&gt; と組み合わせて、クォーラムベースの同期レプリケーションを指定し、トランザクションのコミットを、それらのWALレコードが&lt;em&gt;少なくとも&lt;/em&gt; &lt;code&gt;num_sync&lt;/code&gt; リストされたスタンバイに複製されるまで待機させます。例えば、設定 &lt;code&gt;ANY 3 (s1, s2, s3, s4)&lt;/code&gt; 、それぞれがすぐに少なくともいずれか3のスタンバイとして進めることにコミット原因となり &lt;code&gt;s1&lt;/code&gt; 、 &lt;code&gt;s2&lt;/code&gt; 、 &lt;code&gt;s3&lt;/code&gt; および &lt;code&gt;s4&lt;/code&gt; の返信。</target>
        </trans-unit>
        <trans-unit id="f98af4e22fce388807986209bcfe098613dae4c1" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;FIRST&lt;/code&gt;, coupled with &lt;code&gt;num_sync&lt;/code&gt;, specifies a priority-based synchronous replication and makes transaction commits wait until their WAL records are replicated to &lt;code&gt;num_sync&lt;/code&gt; synchronous standbys chosen based on their priorities. For example, a setting of &lt;code&gt;FIRST 3 (s1, s2, s3, s4)&lt;/code&gt; will cause each commit to wait for replies from three higher-priority standbys chosen from standby servers &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt;. The standbys whose names appear earlier in the list are given higher priority and will be considered as synchronous. Other standby servers appearing later in this list represent potential synchronous standbys. If any of the current synchronous standbys disconnects for whatever reason, it will be replaced immediately with the next-highest-priority standby. The keyword &lt;code&gt;FIRST&lt;/code&gt; is optional.</source>
          <target state="translated">キーワード &lt;code&gt;FIRST&lt;/code&gt; を &lt;code&gt;num_sync&lt;/code&gt; と組み合わせて使用すると、優先順位ベースの同期レプリケーションが指定され、WALレコードが優先順位に基づいて選択された &lt;code&gt;num_sync&lt;/code&gt; 同期スタンバイに複製されるまでトランザクションコミットが待機します。たとえば、 &lt;code&gt;FIRST 3 (s1, s2, s3, s4)&lt;/code&gt; は、各コミットが、スタンバイサーバー &lt;code&gt;s1&lt;/code&gt; 、 &lt;code&gt;s2&lt;/code&gt; 、 &lt;code&gt;s3&lt;/code&gt; 、および &lt;code&gt;s4&lt;/code&gt; から選択された3つの優先順位の高いスタンバイからの応答を待機します。。リストの最初の方に名前が表示されているスタンバイには、より高い優先順位が与えられ、同期と見なされます。このリストの後半にある他のスタンバイサーバーは、潜在的な同期スタンバイを表しています。現在の同期スタンバイのいずれかが何らかの理由で切断された場合、すぐに次に優先順位の高いスタンバイに置き換えられます。キーワード &lt;code&gt;FIRST&lt;/code&gt; はオプションです。</target>
        </trans-unit>
        <trans-unit id="c6753d4b26b83ec9737507aab616ad0a90dffe5e" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;STORED&lt;/code&gt; is required to signify that the column will be computed on write and will be stored on disk.</source>
          <target state="translated">キーワード &lt;code&gt;STORED&lt;/code&gt; は、列が書き込み時に計算され、ディスクに格納されることを示すために必要です。</target>
        </trans-unit>
        <trans-unit id="436779e1054adc0e89a0677ecb406409dda7f240" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;STORED&lt;/code&gt; is required to signify that the column will be computed on write. (The computed value will be presented to the foreign-data wrapper for storage and must be returned on reading.)</source>
          <target state="translated">列が書き込み時に計算されることを示すには、キーワード &lt;code&gt;STORED&lt;/code&gt; が必要です。（計算された値は、格納のために外部データラッパーに提示され、読み取り時に返される必要があります。）</target>
        </trans-unit>
        <trans-unit id="5edd7a55d1b24539fc9cfa0bcf24706822731dd3" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;STORED&lt;/code&gt; must be specified to choose the stored kind of generated column. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">保存された種類の生成された列を選択するには、キーワード &lt;code&gt;STORED&lt;/code&gt; を指定する必要があります。詳細については、&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e643395261c7f81c30fc2a4e61b7aaf97e975625" translate="yes" xml:space="preserve">
          <source>The label provider associated with this label.</source>
          <target state="translated">このラベルに関連付けられたラベルプロバイダ。</target>
        </trans-unit>
        <trans-unit id="468c79531b62d3d36755c25fe6c2c2d1c6c04f9c" translate="yes" xml:space="preserve">
          <source>The label provider determines whether a given label is valid and whether it is permissible to assign that label to a given object. The meaning of a given label is likewise at the discretion of the label provider. PostgreSQL places no restrictions on whether or how a label provider must interpret security labels; it merely provides a mechanism for storing them. In practice, this facility is intended to allow integration with label-based mandatory access control (MAC) systems such as SE-Linux. Such systems make all access control decisions based on object labels, rather than traditional discretionary access control (DAC) concepts such as users and groups.</source>
          <target state="translated">ラベル提供者は、与えられたラベルが有効であるかどうか、そしてそのラベルを与えられたオブジェクトに割り当てることが許されるかどうかを決定する。与えられたラベルの意味も同様に、ラベル提供者の裁量に委ねられています。PostgreSQLは、ラベルプロバイダがセキュリティラベルを解釈しなければならないかどうか、あるいはどのように解釈しなければならないかについての制限を設けていません。実際には、この機能はSE-Linuxのようなラベルベースの強制アクセス制御(MAC)システムとの統合を可能にすることを意図しています。このようなシステムでは、ユーザやグループなどの従来の裁量アクセス制御(DAC)の概念ではなく、オブジェクトラベルに基づいてすべてのアクセス制御の決定を行います。</target>
        </trans-unit>
        <trans-unit id="e2fab09475b65e9983ce79215513aca004922a64" translate="yes" xml:space="preserve">
          <source>The lag times reported in the &lt;code&gt;pg_stat_replication&lt;/code&gt; view are measurements of the time taken for recent WAL to be written, flushed and replayed and for the sender to know about it. These times represent the commit delay that was (or would have been) introduced by each synchronous commit level, if the remote server was configured as a synchronous standby. For an asynchronous standby, the &lt;code&gt;replay_lag&lt;/code&gt; column approximates the delay before recent transactions became visible to queries. If the standby server has entirely caught up with the sending server and there is no more WAL activity, the most recently measured lag times will continue to be displayed for a short time and then show NULL.</source>
          <target state="translated">&lt;code&gt;pg_stat_replication&lt;/code&gt; ビューで報告されるラグタイムは、最近のWALが書き込まれ、フラッシュされ、再生され、送信者がそれを知るのにかかる時間の測定値です。これらの時間は、リモートサーバーが同期スタンバイとして構成されている場合に、各同期コミットレベルによって導入された（または導入されたであろう）コミット遅延を表します。非同期スタンバイの場合、 &lt;code&gt;replay_lag&lt;/code&gt; 列は、最近のトランザクションがクエリに表示されるまでの遅延を概算します。スタンバイサーバーが送信サーバーに完全に追いついてWALアクティビティがなくなった場合、最後に測定されたラグタイムが短時間表示され続け、その後NULLが表示されます。</target>
        </trans-unit>
        <trans-unit id="bee0490b803b85b6819bd67e0eb5d37f8061673f" translate="yes" xml:space="preserve">
          <source>The largest statistics target among the columns being analyzed determines the number of table rows sampled to prepare the statistics. Increasing the target causes a proportional increase in the time and space needed to do &lt;code&gt;ANALYZE&lt;/code&gt;.</source>
          <target state="translated">分析される列の中で最大の統計ターゲットは、統計を準備するためにサンプリングされるテーブル行の数を決定します。ターゲットを増やすと、 &lt;code&gt;ANALYZE&lt;/code&gt; を実行するために必要な時間とスペースが比例して増加します。</target>
        </trans-unit>
        <trans-unit id="08ac6817284c2739892a594416144a19a2fc3c3b" translate="yes" xml:space="preserve">
          <source>The last example shows that the checks include whether namespaces are correctly matched.</source>
          <target state="translated">最後の例では、名前空間が正しくマッチしているかどうかのチェックが含まれていることを示しています。</target>
        </trans-unit>
        <trans-unit id="b141d1efe06f21d25a717b844dfa4141ae98f099" translate="yes" xml:space="preserve">
          <source>The last five parameters are pass-by-reference outputs:</source>
          <target state="translated">最後の5つのパラメータは、パスバイレファレンス出力です。</target>
        </trans-unit>
        <trans-unit id="640860dcca4728ae99db3adc4362cf72e26f4370" translate="yes" xml:space="preserve">
          <source>The last line could also be:</source>
          <target state="translated">最後の一行も可能性があります。</target>
        </trans-unit>
        <trans-unit id="a268591c13ee52793b16cb868a71b9f235920223" translate="yes" xml:space="preserve">
          <source>The last line is useful in verifying that the client is trying to connect to the right place. If there is in fact no server running there, the kernel error message will typically be either &lt;code&gt;Connection refused&lt;/code&gt; or &lt;code&gt;No such file or directory&lt;/code&gt;, as illustrated. (It is important to realize that &lt;code&gt;Connection refused&lt;/code&gt; in this context does &lt;em&gt;not&lt;/em&gt; mean that the server got your connection request and rejected it. That case will produce a different message, as shown in &lt;a href=&quot;client-authentication-problems&quot;&gt;Section 20.15&lt;/a&gt;.) Other error messages such as &lt;code&gt;Connection timed out&lt;/code&gt; might indicate more fundamental problems, like lack of network connectivity.</source>
          <target state="translated">最後の行は、クライアントが正しい場所に接続しようとしていることを確認するのに役立ちます。実際にサーバーが実行されていない場合、図に示す &lt;code&gt;No such file or directory&lt;/code&gt; に、カーネルエラーメッセージは通常、[ &lt;code&gt;Connection refused&lt;/code&gt; または[ そのようなファイルやディレクトリはありません]になります。 （このコンテキストで &lt;code&gt;Connection refused&lt;/code&gt; れても、サーバーが接続要求を受け取って拒否したことを意味するわけではありませ&lt;em&gt;ん&lt;/em&gt;。その場合は、&lt;a href=&quot;client-authentication-problems&quot;&gt;セクション20.15に&lt;/a&gt;示すように、別のメッセージが生成されます。） &lt;code&gt;Connection timed out&lt;/code&gt; などの他のエラーメッセージは、ネットワーク接続の欠如など、より根本的な問題を示します。</target>
        </trans-unit>
        <trans-unit id="cca952ade3d373926896de08f3f6cd0f1c245369" translate="yes" xml:space="preserve">
          <source>The last line printed out by &lt;code&gt;psql&lt;/code&gt; is the prompt, and it indicates that &lt;code&gt;psql&lt;/code&gt; is listening to you and that you can type SQL queries into a work space maintained by &lt;code&gt;psql&lt;/code&gt;. Try out these commands:</source>
          <target state="translated">&lt;code&gt;psql&lt;/code&gt; によって出力される最後の行はプロンプトです。これは、 &lt;code&gt;psql&lt;/code&gt; があなたの言うことを聞いていて、SQLクエリを &lt;code&gt;psql&lt;/code&gt; が管理するワークスペースに入力できることを示しています。次のコマンドを試してください：</target>
        </trans-unit>
        <trans-unit id="eb5a300b26673b4a75043297a6f146dcd49c5439" translate="yes" xml:space="preserve">
          <source>The last sequence value written to disk. If caching is used, this value can be greater than the last value handed out from the sequence. Null if the sequence has not been read from yet. Also, if the current user does not have &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;SELECT&lt;/code&gt; privilege on the sequence, the value is null.</source>
          <target state="translated">ディスクに書き込まれた最後のシーケンス値。キャッシングが使用されている場合、この値は、シーケンスから渡された最後の値よりも大きくなる可能性があります。シーケンスがまだ読み取られていない場合はnull。また、現在のユーザーがシーケンスに対する &lt;code&gt;USAGE&lt;/code&gt; または &lt;code&gt;SELECT&lt;/code&gt; 特権を持っていない場合、値はnullです。</target>
        </trans-unit>
        <trans-unit id="5fe313657b9f725a4a4c3652ad1d9e1c661ac0d8" translate="yes" xml:space="preserve">
          <source>The latter is syntactically valid, but it represents a call of a single-argument aggregate function with two &lt;code&gt;ORDER BY&lt;/code&gt; keys (the second one being rather useless since it's a constant).</source>
          <target state="translated">後者は構文的には有効ですが、2つの &lt;code&gt;ORDER BY&lt;/code&gt; キーを使用した単一引数の集約関数の呼び出しを表します（2番目の関数は定数であるため、あまり役に立ちません）。</target>
        </trans-unit>
        <trans-unit id="ec920275f2c822a2a5adceef23c754e25dadccba" translate="yes" xml:space="preserve">
          <source>The lax mode facilitates matching of a JSON document structure and path expression if the JSON data does not conform to the expected schema. If an operand does not match the requirements of a particular operation, it can be automatically wrapped as an SQL/JSON array or unwrapped by converting its elements into an SQL/JSON sequence before performing this operation. Besides, comparison operators automatically unwrap their operands in the lax mode, so you can compare SQL/JSON arrays out-of-the-box. An array of size 1 is considered equal to its sole element. Automatic unwrapping is not performed only when:</source>
          <target state="translated">ゆるいモードは、JSONデータが期待されるスキーマに準拠していない場合、JSON文書構造とパス式のマッチングを容易にします。オペランドが特定の操作の要件に一致しない場合、そのオペランドは自動的にSQL/JSON配列としてラップされるか、その操作を実行する前にその要素をSQL/JSONシーケンスに変換してアンラップすることができます。また、比較演算子は自動的に緩いモードでオペランドをアンラップするので、SQL/JSON配列をすぐに比較することができます。サイズ1の配列は、その唯一の要素と等しいとみなされます。自動アンラップは、以下の場合にのみ実行されるわけではありません。</target>
        </trans-unit>
        <trans-unit id="c52a670d06775855c2164b78f437c77c8a3136cd" translate="yes" xml:space="preserve">
          <source>The least downtime can be achieved by installing the new server in a different directory and running both the old and the new servers in parallel, on different ports. Then you can use something like:</source>
          <target state="translated">新しいサーバを別のディレクトリにインストールし、古いサーバと新しいサーバを別々のポートで並行して実行することで、ダウンタイムを最小限に抑えることができます。そうすれば、次のようなことができます。</target>
        </trans-unit>
        <trans-unit id="082fd8f2f5ff84b43f58645d6265cd8d6ba42c18" translate="yes" xml:space="preserve">
          <source>The left-hand side is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. Furthermore, the subquery cannot return more than one row. (If it returns zero rows, the result is taken to be null.) The left-hand side is evaluated and compared row-wise to the single subquery result row.</source>
          <target state="translated">&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;セクション4.2.13で&lt;/a&gt;説明されているように、左側は行コンストラクタです。右側は括弧で囲まれたサブクエリで、左側の行の式と同じ数の列を返す必要があります。さらに、サブクエリは複数の行を返すことはできません。 （ゼロ行を返す場合、結果はnullと見なされます。）左側が評価され、行ごとに単一のサブクエリ結果行と比較されます。</target>
        </trans-unit>
        <trans-unit id="f44070270517992cebfd8a7909698b4367aa0cae" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;ALL&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result, using the given &lt;code&gt;operator&lt;/code&gt;. The result of &lt;code&gt;ALL&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if the comparison returns true for all subquery rows (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if the comparison returns false for any subquery row. The result is NULL if no comparison with a subquery row returns false, and at least one comparison returns NULL.</source>
          <target state="translated">&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;セクション4.2.13で&lt;/a&gt;説明されているように、この形式の &lt;code&gt;ALL&lt;/code&gt; の左側は行コンストラクタです。右側は括弧で囲まれたサブクエリで、左側の行の式と同じ数の列を返す必要があります。左側の式が評価され、指定された &lt;code&gt;operator&lt;/code&gt; を使用して、サブクエリの結果の各行と行ごとに比較されます。 &lt;code&gt;ALL&lt;/code&gt; の結果は、すべてのサブクエリ行に対して比較がtrueを返す場合（サブクエリが行を返さない場合を含む）は「true」です。比較がサブクエリ行に対してfalseを返す場合、結果は「false」です。サブクエリ行との比較がfalseを返さず、少なくとも1つの比較がNULLを返す場合、結果はNULLです。</target>
        </trans-unit>
        <trans-unit id="3a495b6469d287a27574f63256e96477ed641f86" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;ANY&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result, using the given &lt;code&gt;operator&lt;/code&gt;. The result of &lt;code&gt;ANY&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if the comparison returns true for any subquery row. The result is &amp;ldquo;false&amp;rdquo; if the comparison returns false for every subquery row (including the case where the subquery returns no rows). The result is NULL if no comparison with a subquery row returns true, and at least one comparison returns NULL.</source>
          <target state="translated">&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;セクション4.2.13で&lt;/a&gt;説明されているように、この形式の &lt;code&gt;ANY&lt;/code&gt; の左側は行コンストラクタです。右側は括弧で囲まれたサブクエリで、左側の行の式と同じ数の列を返す必要があります。左側の式が評価され、指定された &lt;code&gt;operator&lt;/code&gt; を使用して、サブクエリの結果の各行と行ごとに比較されます。いずれかのサブクエリ行に対して比較がtrueを返した場合、 &lt;code&gt;ANY&lt;/code&gt; の結果は「true」です。比較がすべてのサブクエリ行に対してfalseを返す場合（サブクエリが行を返さない場合を含む）、結果は「false」です。サブクエリ行との比較がtrueを返さず、少なくとも1つの比較がNULLを返す場合、結果はNULLです。</target>
        </trans-unit>
        <trans-unit id="afdaf261917f03fc0c447e59e3d5a8be456d89c2" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;IN&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result. The result of &lt;code&gt;IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any equal subquery row is found. The result is &amp;ldquo;false&amp;rdquo; if no equal row is found (including the case where the subquery returns no rows).</source>
          <target state="translated">この &lt;code&gt;IN&lt;/code&gt; の形式の左側は、&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;セクション4.2.13で&lt;/a&gt;説明されている行コンストラクタです。右側は括弧で囲まれたサブクエリで、左側の行の式と同じ数の列を返す必要があります。左側の式が評価され、サブクエリの結果の各行と行ごとに比較されます。等しいサブクエリ行が見つかった場合、 &lt;code&gt;IN&lt;/code&gt; の結果は「true」です。等しい行が見つからない場合（サブクエリが行を返さない場合を含む）、結果は「false」になります。</target>
        </trans-unit>
        <trans-unit id="a1d433de59d411f27b86b3382eba3a1fea3e9e5d" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;NOT IN&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result. The result of &lt;code&gt;NOT IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if only unequal subquery rows are found (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if any equal row is found.</source>
          <target state="translated">&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;セクション4.2.13で&lt;/a&gt;説明されているように、この形式の &lt;code&gt;NOT IN&lt;/code&gt; の左側は行コンストラクタです。右側は括弧で囲まれたサブクエリで、左側の行の式と同じ数の列を返す必要があります。左側の式が評価され、サブクエリの結果の各行と行ごとに比較されます。等しくないサブクエリ行のみが見つかった場合（サブクエリが行を返さない場合を含む）、 &lt;code&gt;NOT IN&lt;/code&gt; の結果は「true」になります。等しい行が見つかった場合、結果は「false」です。</target>
        </trans-unit>
        <trans-unit id="4585d75ed76ee1f40b5daa39dfcad2d39fb7784d" translate="yes" xml:space="preserve">
          <source>The left-of/right-of/adjacent operators always return false when an empty range is involved; that is, an empty range is not considered to be either before or after any other range.</source>
          <target state="translated">left-of/right-of/adjacent演算子は、空の範囲が含まれている場合は常にfalseを返します。</target>
        </trans-unit>
        <trans-unit id="2f5d1e6e1b59ebb3b7a2ceefdc5f69123a880bd7" translate="yes" xml:space="preserve">
          <source>The length of a &lt;code&gt;tsvector&lt;/code&gt; (lexemes + positions) must be less than 1 megabyte</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; （語彙素+位置）の長さは1メガバイト未満でなければなりません</target>
        </trans-unit>
        <trans-unit id="72cf9ee51b093da890b7dcc27caaf482e19db7ab" translate="yes" xml:space="preserve">
          <source>The length of each lexeme must be less than 2K bytes</source>
          <target state="translated">各字句の長さは2Kバイト以下でなければなりません。</target>
        </trans-unit>
        <trans-unit id="07e3cb5f7b40e6d63b3d5d01d67980671a6f7bf1" translate="yes" xml:space="preserve">
          <source>The library file name is typically given as just a bare file name, which is sought in the server's library search path (set by &lt;a href=&quot;runtime-config-client#GUC-DYNAMIC-LIBRARY-PATH&quot;&gt;dynamic_library_path&lt;/a&gt;). Alternatively it can be given as a full path name. In either case the platform's standard shared library file name extension may be omitted. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-c.html#XFUNC-C-DYNLOAD&quot;&gt;Section 37.10.1&lt;/a&gt; for more information on this topic.</source>
          <target state="translated">ライブラリファイル名は通常、サーバーのライブラリ検索パス（&lt;a href=&quot;runtime-config-client#GUC-DYNAMIC-LIBRARY-PATH&quot;&gt;dynamic_library_pathで&lt;/a&gt;設定）で検索される、単なるファイル名として与えられます。または、フルパス名で指定することもできます。どちらの場合も、プラットフォームの標準共有ライブラリのファイル名拡張子は省略できます。このトピックの詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-c.html#XFUNC-C-DYNLOAD&quot;&gt;セクション37.10.1&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="eb9d5172bb2076ce6b62f3e5058e20954eddcb55" translate="yes" xml:space="preserve">
          <source>The libxml2 library does seem to always return node-sets to PostgreSQL with their members in the same relative order they had in the input document. Its documentation does not commit to this behavior, and an XPath 1.0 expression cannot control it.</source>
          <target state="translated">libxml2ライブラリは常にノードセットをPostgreSQLに返し、そのメンバを入力ドキュメントと同じ相対順序で返しているようです。ドキュメントではこの動作はコミットされておらず、XPath 1.0の式では制御できません。</target>
        </trans-unit>
        <trans-unit id="e92855a9b20ea0f884a230e63ef7768d88fd5352" translate="yes" xml:space="preserve">
          <source>The limitations of pg_restore are detailed below.</source>
          <target state="translated">pg_restoreの制限事項を以下に詳述します。</target>
        </trans-unit>
        <trans-unit id="87e598717783e82b1e191a7f90cf401c4ee0b779" translate="yes" xml:space="preserve">
          <source>The line number inside the current statement, starting from &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">現在のステートメント内の &lt;code&gt;1&lt;/code&gt; から始まる行番号。</target>
        </trans-unit>
        <trans-unit id="d10565a24d6154d743d122e032098869756ae365" translate="yes" xml:space="preserve">
          <source>The list below shows the available lock modes and the contexts in which they are used automatically by PostgreSQL. You can also acquire any of these locks explicitly with the command &lt;a href=&quot;sql-lock&quot;&gt;LOCK&lt;/a&gt;. Remember that all of these lock modes are table-level locks, even if the name contains the word &amp;ldquo;row&amp;rdquo;; the names of the lock modes are historical. To some extent the names reflect the typical usage of each lock mode &amp;mdash; but the semantics are all the same. The only real difference between one lock mode and another is the set of lock modes with which each conflicts (see &lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;Table 13.2&lt;/a&gt;). Two transactions cannot hold locks of conflicting modes on the same table at the same time. (However, a transaction never conflicts with itself. For example, it might acquire &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock and later acquire &lt;code&gt;ACCESS SHARE&lt;/code&gt; lock on the same table.) Non-conflicting lock modes can be held concurrently by many transactions. Notice in particular that some lock modes are self-conflicting (for example, an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock cannot be held by more than one transaction at a time) while others are not self-conflicting (for example, an &lt;code&gt;ACCESS SHARE&lt;/code&gt; lock can be held by multiple transactions).</source>
          <target state="translated">以下のリストは、使用可能なロックモードと、PostgreSQLによって自動的に使用されるコンテキストを示しています。コマンド&lt;a href=&quot;sql-lock&quot;&gt;LOCKを使用&lt;/a&gt;して、これらのロックを明示的に取得することもできます。名前に「行」という単語が含まれている場合でも、これらのロックモードはすべてテーブルレベルのロックであることを忘れないでください。ロックモードの名前は歴史的なものです。名前は、各ロックモードの一般的な使用法をある程度反映していますが、セマンティクスはすべて同じです。あるロックモードと別のロックモードの唯一の実際の違いは、それぞれが競合するロックモードのセットです（&lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;表13.2を&lt;/a&gt;参照）。 2つのトランザクションは、同じテーブル上で競合するモードのロックを同時に保持することはできません。 （ただし、トランザクションがそれ自体と競合することはありません。たとえば、 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; を取得する場合があります。ロックし、後で同じテーブルで &lt;code&gt;ACCESS SHARE&lt;/code&gt; ロックを取得します。）競合しないロックモードは、多くのトランザクションで同時に保持できます。特に、いくつかのロックモードは自己矛盾している（たとえば、 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; ロックは一度に複数のトランザクションで保持できない）一方で、他のモードは自己矛盾していない（たとえば、 &lt;code&gt;ACCESS SHARE&lt;/code&gt; ロックは複数のトランザクション）。</target>
        </trans-unit>
        <trans-unit id="4e69c1b0ac656b6b15e1946ebe2102bdb20487dd" translate="yes" xml:space="preserve">
          <source>The list of built-in functions is in &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. Other functions can be added by the user.</source>
          <target state="translated">組み込み関数のリストは&lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;第9章にあり&lt;/a&gt;ます。その他の機能はユーザーが追加できます。</target>
        </trans-unit>
        <trans-unit id="034ee84c98b899e3f08ab6a22f176f2b0b9c945d" translate="yes" xml:space="preserve">
          <source>The list of output expressions after &lt;code&gt;SELECT&lt;/code&gt; can be empty, producing a zero-column result table. This is not valid syntax according to the SQL standard. PostgreSQL allows it to be consistent with allowing zero-column tables. However, an empty list is not allowed when &lt;code&gt;DISTINCT&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 後の出力式のリストを空にして、ゼロ列の結果テーブルを作成できます。これは、SQL標準では有効な構文ではありません。PostgreSQLでは、ゼロ列テーブルの許可と一貫性を保つことができます。ただし、 &lt;code&gt;DISTINCT&lt;/code&gt; を使用する場合、空のリストは許可されません。</target>
        </trans-unit>
        <trans-unit id="8494c9c3de42f371358e2a2e5b1c91631cba7c4b" translate="yes" xml:space="preserve">
          <source>The listing file consists of a header and one line for each item, e.g.:</source>
          <target state="translated">リストファイルは、ヘッダと各項目の1行で構成されています。</target>
        </trans-unit>
        <trans-unit id="c073ed3743a7cc8517210053a4e46a167f30e3ab" translate="yes" xml:space="preserve">
          <source>The literal &lt;code&gt;1.2&lt;/code&gt; is of type &lt;code&gt;numeric&lt;/code&gt;, and the &lt;code&gt;integer&lt;/code&gt; value &lt;code&gt;1&lt;/code&gt; can be cast implicitly to &lt;code&gt;numeric&lt;/code&gt;, so that type is used.</source>
          <target state="translated">リテラル &lt;code&gt;1.2&lt;/code&gt; は &lt;code&gt;numeric&lt;/code&gt; 型であり、 &lt;code&gt;integer&lt;/code&gt; 値 &lt;code&gt;1&lt;/code&gt; は暗黙的に &lt;code&gt;numeric&lt;/code&gt; にキャストできるため、その型が使用されます。</target>
        </trans-unit>
        <trans-unit id="81389809d8e329e135cb6738d28db71cfa07fe84" translate="yes" xml:space="preserve">
          <source>The local shell command to execute to archive a completed WAL file segment. Any &lt;code&gt;%p&lt;/code&gt; in the string is replaced by the path name of the file to archive, and any &lt;code&gt;%f&lt;/code&gt; is replaced by only the file name. (The path name is relative to the working directory of the server, i.e., the cluster's data directory.) Use &lt;code&gt;%%&lt;/code&gt; to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command. It is important for the command to return a zero exit status only if it succeeds. For more information see &lt;a href=&quot;continuous-archiving#BACKUP-ARCHIVING-WAL&quot;&gt;Section 25.3.1&lt;/a&gt;.</source>
          <target state="translated">完了したWALファイルセグメントをアーカイブするために実行するローカルシェルコマンド。どれ &lt;code&gt;%p&lt;/code&gt; を文字列では、アーカイブへのファイルのパス名に置き換えられ、任意の &lt;code&gt;%f&lt;/code&gt; はファイル名のみに置き換えられています。 （パス名は、サーバーの作業ディレクトリ、つまりクラスターのデータディレクトリを基準にしています。） &lt;code&gt;%%&lt;/code&gt; を使用して、コマンドに実際の &lt;code&gt;%&lt;/code&gt; 文字を埋め込みます。コマンドは、成功した場合にのみゼロの終了ステータスを返すことが重要です。詳細については、&lt;a href=&quot;continuous-archiving#BACKUP-ARCHIVING-WAL&quot;&gt;セクション25.3.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0c6814fd70a4837bf3123c78d06664813ae5c2c3" translate="yes" xml:space="preserve">
          <source>The local shell command to execute to retrieve an archived segment of the WAL file series. This parameter is required for archive recovery, but optional for streaming replication. Any &lt;code&gt;%f&lt;/code&gt; in the string is replaced by the name of the file to retrieve from the archive, and any &lt;code&gt;%p&lt;/code&gt; is replaced by the copy destination path name on the server. (The path name is relative to the current working directory, i.e., the cluster's data directory.) Any &lt;code&gt;%r&lt;/code&gt; is replaced by the name of the file containing the last valid restart point. That is the earliest file that must be kept to allow a restore to be restartable, so this information can be used to truncate the archive to just the minimum required to support restarting from the current restore. &lt;code&gt;%r&lt;/code&gt; is typically only used by warm-standby configurations (see &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;). Write &lt;code&gt;%%&lt;/code&gt; to embed an actual &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">一連のWALファイルのアーカイブされたセグメントを取得するために実行するローカルシェルコマンド。このパラメーターは、アーカイブの回復には必須ですが、ストリーミングレプリケーションではオプションです。どれ &lt;code&gt;%f&lt;/code&gt; を文字列では、アーカイブから取得するために、ファイルの名前に置き換えられ、任意の &lt;code&gt;%p&lt;/code&gt; は、サーバー上のコピー先のパス名に置き換えられます。 （パス名は、現在の作業ディレクトリ（つまり、クラスターのデータディレクトリ）を基準にしています。） &lt;code&gt;%r&lt;/code&gt; は、最後の有効な再起動ポイントを含むファイルの名前に置き換えられます。これは、復元を再開できるようにするために保持する必要がある最も古いファイルなので、この情報を使用して、現在の復元からの再開をサポートするために必要な最小限の値までアーカイブを切り捨てることができます。 &lt;code&gt;%r&lt;/code&gt; 通常は、ウォームスタンバイ構成でのみ使用されます（&lt;a href=&quot;warm-standby&quot;&gt;セクション26.2を&lt;/a&gt;参照）。書き込みは &lt;code&gt;%%&lt;/code&gt; に実際埋め込む &lt;code&gt;%&lt;/code&gt; の文字を。</target>
        </trans-unit>
        <trans-unit id="1eefb4d9f04f196c0b255cf3b0eec2ac11926c27" translate="yes" xml:space="preserve">
          <source>The locale settings influence the following SQL features:</source>
          <target state="translated">ロケール設定は、以下のSQL機能に影響を与えます。</target>
        </trans-unit>
        <trans-unit id="7a32d4357c6c565a2645be6e8f5dcd4ff20db468" translate="yes" xml:space="preserve">
          <source>The location must be an existing, empty directory that is owned by the PostgreSQL operating system user. All objects subsequently created within the tablespace will be stored in files underneath this directory. The location must not be on removable or transient storage, as the cluster might fail to function if the tablespace is missing or lost.</source>
          <target state="translated">この場所は、PostgreSQLオペレーティングシステムユーザが所有する、既存の空のディレクトリでなければなりません。テーブル空間内に作成されたすべてのオブジェクトは、このディレクトリの下にあるファイルに格納されます。テーブルスペースがない場合や紛失した場合にクラスタが機能しなくなる可能性があるため、その場所はリムーバブルストレージや一時的なストレージ上にあってはなりません。</target>
        </trans-unit>
        <trans-unit id="b667dea533a6876f6f89e862e7e520ec6a41f7d3" translate="yes" xml:space="preserve">
          <source>The location of the history file can be set explicitly via the &lt;code&gt;HISTFILE&lt;/code&gt; psql variable or the &lt;code&gt;PSQL_HISTORY&lt;/code&gt; environment variable.</source>
          <target state="translated">履歴ファイルの場所は、 &lt;code&gt;HISTFILE&lt;/code&gt; psql変数または &lt;code&gt;PSQL_HISTORY&lt;/code&gt; 環境変数を介して明示的に設定できます。</target>
        </trans-unit>
        <trans-unit id="b9e8edabe8e574f621a1a9a4ab6a0372f27514c2" translate="yes" xml:space="preserve">
          <source>The lock mode specifies which locks this lock conflicts with. Lock modes are described in &lt;a href=&quot;explicit-locking&quot;&gt;Section 13.3&lt;/a&gt;.</source>
          <target state="translated">ロックモードは、このロックが競合するロックを指定します。ロックモードについては、&lt;a href=&quot;explicit-locking&quot;&gt;セクション13.3で&lt;/a&gt;説明します。</target>
        </trans-unit>
        <trans-unit id="11e9f2a01b63d9d65afbfe49635022cefcf4e76a" translate="yes" xml:space="preserve">
          <source>The locking clause has the general form</source>
          <target state="translated">ロック句は一般的な形式を持っています。</target>
        </trans-unit>
        <trans-unit id="91a41283b7fcf940c9ed38d5616364c7bd0504f5" translate="yes" xml:space="preserve">
          <source>The locking clauses cannot be used in contexts where returned rows cannot be clearly identified with individual table rows; for example they cannot be used with aggregation.</source>
          <target state="translated">ロック句は、返された行が個々のテーブル行と明確に識別できないようなコンテキストでは使用できません;例えば、それらは集約で使用することはできません。</target>
        </trans-unit>
        <trans-unit id="5be2e9c7a10ee3339b74248910b8189ec3602ecb" translate="yes" xml:space="preserve">
          <source>The logging collector is designed to never lose messages. This means that in case of extremely high load, server processes could be blocked while trying to send additional log messages when the collector has fallen behind. In contrast, syslog prefers to drop messages if it cannot write them, which means it may fail to log some messages in such cases but it will not block the rest of the system.</source>
          <target state="translated">ロギングコレクターはメッセージを決して失わないように設計されています。これは、非常に高い負荷の場合、コレクターが遅れたときに追加のログメッセージを送信しようとしている間に、サーバープロセスがブロックされる可能性があることを意味します。対照的に、syslog はメッセージを書くことができない場合にはメッセージを落とすことを好みます。</target>
        </trans-unit>
        <trans-unit id="e54879093a2f0566d1aa83e68c13d2dd946cc6fd" translate="yes" xml:space="preserve">
          <source>The logical replication apply process currently only fires row triggers, not statement triggers. The initial table synchronization, however, is implemented like a &lt;code&gt;COPY&lt;/code&gt; command and thus fires both row and statement triggers for &lt;code&gt;INSERT&lt;/code&gt;.</source>
          <target state="translated">論理レプリケーション適用プロセスは現在、ステートメントトリガーではなく、行トリガーのみを起動します。ただし、初期テーブル同期は &lt;code&gt;COPY&lt;/code&gt; コマンドのように実装されているため、 &lt;code&gt;INSERT&lt;/code&gt; の行トリガーとステートメントトリガーの両方を起動します。</target>
        </trans-unit>
        <trans-unit id="497c1b112de3cb7224f97eec3f477dda0c464f33" translate="yes" xml:space="preserve">
          <source>The lower bound of a range can be omitted, meaning that all points less than the upper bound are included in the range. Likewise, if the upper bound of the range is omitted, then all points greater than the lower bound are included in the range. If both lower and upper bounds are omitted, all values of the element type are considered to be in the range.</source>
          <target state="translated">範囲の下界は省略することができ、つまり、上界よりも小さい点はすべて範囲に含まれます。同様に、範囲の上界が省略されると、下界よりも大きいすべての点が範囲に含まれることを意味する。範囲の下界と上界の両方が省略された場合、その要素型のすべての値が範囲内に含まれているとみなされます。</target>
        </trans-unit>
        <trans-unit id="d2bb8fcfd48d2a42926444acc296752b10019e69" translate="yes" xml:space="preserve">
          <source>The machine used is an Intel Mobile Core i3.</source>
          <target state="translated">使用したマシンはIntel Mobile Core i3です。</target>
        </trans-unit>
        <trans-unit id="a9f59ce368a2e8f66b6b7f102badc5b6a6bb9471" translate="yes" xml:space="preserve">
          <source>The magic that makes the two loosely coupled servers work together is simply a &lt;code&gt;restore_command&lt;/code&gt; used on the standby that, when asked for the next WAL file, waits for it to become available from the primary. Normal recovery processing would request a file from the WAL archive, reporting failure if the file was unavailable. For standby processing it is normal for the next WAL file to be unavailable, so the standby must wait for it to appear. For files ending in &lt;code&gt;.history&lt;/code&gt; there is no need to wait, and a non-zero return code must be returned. A waiting &lt;code&gt;restore_command&lt;/code&gt; can be written as a custom script that loops after polling for the existence of the next WAL file. There must also be some way to trigger failover, which should interrupt the &lt;code&gt;restore_command&lt;/code&gt;, break the loop and return a file-not-found error to the standby server. This ends recovery and the standby will then come up as a normal server.</source>
          <target state="translated">2つの疎結合サーバーを連携させる魔法は、単にスタンバイで使用される &lt;code&gt;restore_command&lt;/code&gt; であり、次のWALファイルを要求されたときに、プライマリから使用可能になるのを待ちます。通常の回復処理では、WALアーカイブからファイルを要求し、ファイルが利用できない場合は失敗を報告します。スタンバイ処理の場合、次のWALファイルが使用できなくなるのは正常なため、スタンバイはそれが表示されるまで待機する必要があります。 &lt;code&gt;.history&lt;/code&gt; で終わるファイルの場合、待機する必要はなく、ゼロ以外の戻りコードを返す必要があります。待機中の &lt;code&gt;restore_command&lt;/code&gt; は、次のWALファイルの存在をポーリングした後にループするカスタムスクリプトとして作成できます。フェイルオーバーをトリガーする方法も必要です。 &lt;code&gt;restore_command&lt;/code&gt; 、ループを中断し、ファイルが見つからないというエラーをスタンバイサーバーに返します。これでリカバリが終了し、スタンバイが通常のサーバーとして起動します。</target>
        </trans-unit>
        <trans-unit id="ce18091b48e231b7d70d5b7f47f40d4962ad395e" translate="yes" xml:space="preserve">
          <source>The main advantage of using the MVCC model of concurrency control rather than locking is that in MVCC locks acquired for querying (reading) data do not conflict with locks acquired for writing data, and so reading never blocks writing and writing never blocks reading. PostgreSQL maintains this guarantee even when providing the strictest level of transaction isolation through the use of an innovative &lt;em&gt;Serializable Snapshot Isolation&lt;/em&gt; (SSI) level.</source>
          <target state="translated">ロックではなく同時実行制御のMVCCモデルを使用する主な利点は、MVCCでは、データのクエリ（読み取り）のために取得されたロックが、データの書き込みのために取得されたロックと競合しないため、読み取りが書き込みをブロックせず、書き込みが読み取りをブロックしないことです。PostgreSQLは、革新的な&lt;em&gt;Serializable Snapshot Isolation&lt;/em&gt;（SSI）レベルを使用して最も厳密なレベルのトランザクション分離を提供する場合でも、この保証を維持します。</target>
        </trans-unit>
        <trans-unit id="44c8536b44aa283079c384b9a03db01c74d90dd9" translate="yes" xml:space="preserve">
          <source>The main disadvantage of this approach is that searches must scan the list of pending entries in addition to searching the regular index, and so a large list of pending entries will slow searches significantly. Another disadvantage is that, while most updates are fast, an update that causes the pending list to become &amp;ldquo;too large&amp;rdquo; will incur an immediate cleanup cycle and thus be much slower than other updates. Proper use of autovacuum can minimize both of these problems.</source>
          <target state="translated">このアプローチの主な欠点は、通常のインデックスの検索に加えて、検索で保留中のエントリのリストをスキャンする必要があるため、保留中のエントリのリストが大きいと検索が大幅に遅くなることです。もう1つの欠点は、ほとんどの更新は高速ですが、保留リストが「大きすぎる」ようになる更新では、即時のクリーンアップサイクルが発生するため、他の更新よりもはるかに遅くなることです。自動バキュームを適切に使用すると、これらの問題の両方を最小限に抑えることができます。</target>
        </trans-unit>
        <trans-unit id="4ddd5b9589c157b509c992d47b1a2271d0f14677" translate="yes" xml:space="preserve">
          <source>The main limitation of the single-parameter form of &lt;code&gt;crosstab&lt;/code&gt; is that it treats all values in a group alike, inserting each value into the first available column. If you want the value columns to correspond to specific categories of data, and some groups might not have data for some of the categories, that doesn't work well. The two-parameter form of &lt;code&gt;crosstab&lt;/code&gt; handles this case by providing an explicit list of the categories corresponding to the output columns.</source>
          <target state="translated">単一パラメーター形式の &lt;code&gt;crosstab&lt;/code&gt; の主な制限は、グループ内のすべての値を同様に扱い、各値を最初の使用可能な列に挿入することです。値列をデータの特定のカテゴリに対応させたい場合、一部のグループには一部のカテゴリのデータがない可能性がありますが、これはうまく機能しません。2パラメータ形式の &lt;code&gt;crosstab&lt;/code&gt; は、出力列に対応するカテゴリの明示的なリストを提供することにより、このケースを処理します。</target>
        </trans-unit>
        <trans-unit id="778d9031e427ea1e84edd5ec78787ba6c076cbf5" translate="yes" xml:space="preserve">
          <source>The main purpose of this option is to allow taking a base backup when the server is out of free replication slots. Using replication slots is almost always preferred, because it prevents needed WAL from being removed by the server during the backup.</source>
          <target state="translated">このオプションの主な目的は、サーバに空きレプリケーションスロットがない場合にベースバックアップを取ることができるようにすることです。バックアップ中に必要なWALがサーバによって削除されるのを防ぐことができるので、レプリケーションスロットを使用することがほとんどの場合好ましいです。</target>
        </trans-unit>
        <trans-unit id="29caa328c42873be4b6687bd164a1f6cd134599f" translate="yes" xml:space="preserve">
          <source>The main reason for providing the option to specify multiple changes in a single &lt;code&gt;ALTER TABLE&lt;/code&gt; is that multiple table scans or rewrites can thereby be combined into a single pass over the table.</source>
          <target state="translated">単一の &lt;code&gt;ALTER TABLE&lt;/code&gt; で複数の変更を指定するオプションを提供する主な理由は、複数のテーブルスキャンまたは再書き込みをテーブル上で単一のパスに結合できるためです。</target>
        </trans-unit>
        <trans-unit id="cb4b3004c02ae1c44498a4d45ad098f017583f6e" translate="yes" xml:space="preserve">
          <source>The main reason not to use &lt;code&gt;FOR UPDATE&lt;/code&gt; with &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; is if you need the cursor to be scrollable, or to be insensitive to the subsequent updates (that is, continue to show the old data). If this is a requirement, pay close heed to the caveats shown above.</source>
          <target state="translated">未使用の主な理由 &lt;code&gt;FOR UPDATE&lt;/code&gt; と &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; あなたは（古いデータを表示し続ける、である）スクロールする、またはそれ以降の更新の影響を受けないようにカーソルが必要な場合です。これが要件である場合は、上記の警告に注意してください。</target>
        </trans-unit>
        <trans-unit id="4a8b7d5e4956ce1f0f4b5a2c51be8faff6d42ee8" translate="yes" xml:space="preserve">
          <source>The majority of the information defining an operator family is not in its &lt;code&gt;pg_opfamily&lt;/code&gt; row, but in the associated rows in &lt;a href=&quot;catalog-pg-amop&quot;&gt;&lt;code&gt;pg_amop&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;catalog-pg-amproc&quot;&gt;&lt;code&gt;pg_amproc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;catalog-pg-opclass&quot;&gt;&lt;code&gt;pg_opclass&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">演算子族を定義する情報の大部分は、その &lt;code&gt;pg_opfamily&lt;/code&gt; 行ではなく、&lt;a href=&quot;catalog-pg-amop&quot;&gt; &lt;code&gt;pg_amop&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;catalog-pg-amproc&quot;&gt; &lt;code&gt;pg_amproc&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;catalog-pg-opclass&quot;&gt; &lt;code&gt;pg_opclass&lt;/code&gt; の&lt;/a&gt;関連する行にあります。</target>
        </trans-unit>
        <trans-unit id="84e832e692fdd3f5ebc26e5d5addbf853c3e6115" translate="yes" xml:space="preserve">
          <source>The mandatory &lt;code&gt;COLUMNS&lt;/code&gt; clause specifies the list of columns in the output table. Each entry describes a single column. See the syntax summary above for the format. The column name and type are required; the path, default and nullability clauses are optional.</source>
          <target state="translated">必須の &lt;code&gt;COLUMNS&lt;/code&gt; 句は、出力テーブルの列のリストを指定します。各エントリは1つの列を示します。形式については、上記の構文の要約を参照してください。列の名前とタイプは必須です。パス、デフォルト、およびNULL可能句はオプションです。</target>
        </trans-unit>
        <trans-unit id="1ed034d07246f2d9a932c645c69a5fd7f25b6f13" translate="yes" xml:space="preserve">
          <source>The map is conservative in the sense that we make sure that whenever a bit is set, we know the condition is true, but if a bit is not set, it might or might not be true. Visibility map bits are only set by vacuum, but are cleared by any data-modifying operations on a page.</source>
          <target state="translated">このマップは、ビットがセットされているときはいつでも条件が真であることがわかるようにするという意味で保守的ですが、ビットがセットされていない場合は、真ではないかもしれないし、真ではないかもしれないということになります。可視性マップのビットは真空によってのみ設定されますが、ページ上でデータを変更する操作によってクリアされます。</target>
        </trans-unit>
        <trans-unit id="08696b64b531889519840be43314b0f033492f9a" translate="yes" xml:space="preserve">
          <source>The match distance in a &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; (FOLLOWED BY) &lt;code&gt;tsquery&lt;/code&gt; operator cannot be more than 16,384</source>
          <target state="translated">&lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; （FOLLOWED BY） &lt;code&gt;tsquery&lt;/code&gt; 演算子の一致距離は、16,384を超えることはできません</target>
        </trans-unit>
        <trans-unit id="0adc4fae7a170393939bebd8f752ad648c1e97c9" translate="yes" xml:space="preserve">
          <source>The matching code in the C module could then follow this skeleton:</source>
          <target state="translated">そして、Cモジュール内のマッチするコードは、このスケルトンに従うことができます。</target>
        </trans-unit>
        <trans-unit id="628cd5529e4eb158401ec35941dd337c440c275a" translate="yes" xml:space="preserve">
          <source>The maximum allowed precision when explicitly specified in the type declaration is 1000; &lt;code&gt;NUMERIC&lt;/code&gt; without a specified precision is subject to the limits described in &lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;Table 8.2&lt;/a&gt;.</source>
          <target state="translated">型宣言で明示的に指定された場合の最大許容精度は1000です。精度が指定されていない &lt;code&gt;NUMERIC&lt;/code&gt; には、&lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;表8.2で&lt;/a&gt;説明されている制限が適用されます。</target>
        </trans-unit>
        <trans-unit id="f276734cd29218873896bf82d393e1b3527b68e3" translate="yes" xml:space="preserve">
          <source>The maximum number of buffers that can be registered for a generic WAL record is &lt;code&gt;MAX_GENERIC_XLOG_PAGES&lt;/code&gt;. An error will be thrown if this limit is exceeded.</source>
          <target state="translated">一般的なWALレコードに登録できる最大バッファー数は &lt;code&gt;MAX_GENERIC_XLOG_PAGES&lt;/code&gt; です。この制限を超えると、エラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="62795c0abeb86c3cb2f44c4d31a9efa4ab1b021c" translate="yes" xml:space="preserve">
          <source>The maximum number of columns for a table is further reduced as the tuple being stored must fit in a single 8192-byte heap page. For example, excluding the tuple header, a tuple made up of 1600 &lt;code&gt;int&lt;/code&gt; columns would consume 6400 bytes and could be stored in a heap page, but a tuple of 1600 &lt;code&gt;bigint&lt;/code&gt; columns would consume 12800 bytes and would therefore not fit inside a heap page. Variable-length fields of types such as &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char&lt;/code&gt; can have their values stored out of line in the table's TOAST table when the values are large enough to require it. Only an 18-byte pointer must remain inside the tuple in the table's heap. For shorter length variable-length fields, either a 4-byte or 1-byte field header is used and the value is stored inside the heap tuple.</source>
          <target state="translated">格納されるタプルは単一の8192バイトのヒープページに収まる必要があるため、テーブルの最大列数はさらに減少します。たとえば、タプルヘッダーを除いて、1600 &lt;code&gt;int&lt;/code&gt; 列で構成されるタプルは6400バイトを消費し、ヒープページに格納できますが、1600 &lt;code&gt;bigint&lt;/code&gt; 列のタプルは12800バイトを消費するため、ヒープページ内に収まりません。 &lt;code&gt;text&lt;/code&gt; 、 &lt;code&gt;varchar&lt;/code&gt; 、 &lt;code&gt;char&lt;/code&gt; などのタイプの可変長フィールド値がそれを必要とするのに十分な大きさである場合、それらの値をテーブルのTOASTテーブルの行外に格納することができます。18バイトのポインタのみが、テーブルのヒープのタプル内に残っている必要があります。短い長さの可変長フィールドの場合、4バイトまたは1バイトのフィールドヘッダーが使用され、値はヒープタプル内に格納されます。</target>
        </trans-unit>
        <trans-unit id="5febb5cd9beb7e14dc02349a0fabc85e580c54fa" translate="yes" xml:space="preserve">
          <source>The maximum number of commands to store in the command history (default 500). If set to a negative value, no limit is applied.</source>
          <target state="translated">コマンド履歴に保存するコマンドの最大数(デフォルトは500)。負の値を設定した場合、制限は適用されません。</target>
        </trans-unit>
        <trans-unit id="db38918ed0ba22959c7e085e2da67d6ae9e85522" translate="yes" xml:space="preserve">
          <source>The maximum number of entries in the array fields can be controlled on a column-by-column basis using the &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; command, or globally by setting the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; run-time parameter.</source>
          <target state="translated">配列フィールドの最大エントリ数は、 &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; コマンドを使用して列ごとに制御するか、&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;ランタイムパラメータを設定してグローバルに制御できます。</target>
        </trans-unit>
        <trans-unit id="d3e538107920d935aeb7ce10873e4d969580a999" translate="yes" xml:space="preserve">
          <source>The maximum number of rows to return. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">返す行の最大数。詳細については、&lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt; &lt;code&gt;LIMIT&lt;/code&gt; 句を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="196f6ebe76be64ba3b271dddfbd4d6c8ae41617e" translate="yes" xml:space="preserve">
          <source>The maximum number of seconds to wait when attempting connection before returning that the server is not responding. Setting to 0 disables. The default is 3 seconds.</source>
          <target state="translated">接続を試みたときに、サーバーが応答していないことを返すまでの最大待機時間を指定します。0に設定すると無効になります。デフォルトは3秒です。</target>
        </trans-unit>
        <trans-unit id="3aa8188a6b3b3fb92b1108055edfe63bc9db8999" translate="yes" xml:space="preserve">
          <source>The maximum time that a table can go unvacuumed is two billion transactions minus the &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; value at the time of the last aggressive vacuum. If it were to go unvacuumed for longer than that, data loss could result. To ensure that this does not happen, autovacuum is invoked on any table that might contain unfrozen rows with XIDs older than the age specified by the configuration parameter &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt;. (This will happen even if autovacuum is disabled.)</source>
          <target state="translated">テーブルが非バキューム状態になる最大時間は、20億トランザクションから、最後のアグレッシブバキューム時の &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; 値を引いたものです。それよりも長い時間、真空引きを行わないと、データが失われる可能性があります。これが起こらないようにするには、構成パラメーター&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_ageで&lt;/a&gt;指定された経過日数よりも古いXIDを持つフリーズされていない行を含む可能性があるすべてのテーブルでautovacuumが呼び出されます。 （これは自動バキュームが無効になっていても発生します。）</target>
        </trans-unit>
        <trans-unit id="a2f6e9f6c92be1d6e4dbdfb81636d51c2482b4e7" translate="yes" xml:space="preserve">
          <source>The maximum transfer rate of data transferred from the server. Values are in kilobytes per second. Use a suffix of &lt;code&gt;M&lt;/code&gt; to indicate megabytes per second. A suffix of &lt;code&gt;k&lt;/code&gt; is also accepted, and has no effect. Valid values are between 32 kilobytes per second and 1024 megabytes per second.</source>
          <target state="translated">サーバーから転送されるデータの最大転送速度。値はキロバイト/秒です。メガバイト/秒を示すには、 &lt;code&gt;M&lt;/code&gt; のサフィックスを使用します。 &lt;code&gt;k&lt;/code&gt; のサフィックスも受け入れられ、効果はありません。有効な値は、毎秒32キロバイトから毎秒1024メガバイトです。</target>
        </trans-unit>
        <trans-unit id="aad15d96db29ca223b68ad77ebaeeab386249ae0" translate="yes" xml:space="preserve">
          <source>The meaning of the fields is as follows:</source>
          <target state="translated">フィールドの意味は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="cd3a4582b6d44983f8eaba4187d7e09c6429edc7" translate="yes" xml:space="preserve">
          <source>The meaning of this parameter, and its default value, changed in PostgreSQL 12; see &lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;Section 8.1.3&lt;/a&gt; for further discussion.</source>
          <target state="translated">このパラメーターの意味とそのデフォルト値はPostgreSQL 12で変更されました。詳細については、&lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;セクション8.1.3&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c7b63395362512b01d4281cff1f264dd9fa16bd8" translate="yes" xml:space="preserve">
          <source>The meanings of &lt;code&gt;PARALLEL SAFE&lt;/code&gt;, &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;, and &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; are the same as in &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;. An aggregate will not be considered for parallelization if it is marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; (which is the default!) or &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;. Note that the parallel-safety markings of the aggregate's support functions are not consulted by the planner, only the marking of the aggregate itself.</source>
          <target state="translated">&lt;code&gt;PARALLEL SAFE&lt;/code&gt; 、 &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; 、および &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; の意味は、&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTIONの場合&lt;/a&gt;と同じです。集約が &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; （デフォルトです！）または &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; とマークされている場合、集約は並列化の対象とは見なされません。アグリゲートのサポート機能の並列安全マーキングはプランナによって参照されず、アグリゲート自体のマーキングのみが参照されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d9104f9afa808fa94ea8a0bf0c8363adf4ab748e" translate="yes" xml:space="preserve">
          <source>The mechanism that converts &lt;code&gt;(+-)&lt;/code&gt; to regular ranges isn't completely accurate in determining the number of significant digits for the boundaries. For example, it adds an extra digit to the lower boundary if the resulting interval includes a power of ten:</source>
          <target state="translated">&lt;code&gt;(+-)&lt;/code&gt; を通常の範囲に変換するメカニズムは、境界の有効桁数を決定する際に完全には正確ではありません。たとえば、結果の間隔に10のべき乗が含まれている場合は、下限に余分な数字が追加されます。</target>
        </trans-unit>
        <trans-unit id="221c60f17786086e4d1d8637638f0c8d9f6223fa" translate="yes" xml:space="preserve">
          <source>The members of a group role can use the privileges of the role in two ways. First, every member of a group can explicitly do &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; to temporarily &amp;ldquo;become&amp;rdquo; the group role. In this state, the database session has access to the privileges of the group role rather than the original login role, and any database objects created are considered owned by the group role not the login role. Second, member roles that have the &lt;code&gt;INHERIT&lt;/code&gt; attribute automatically have use of the privileges of roles of which they are members, including any privileges inherited by those roles. As an example, suppose we have done:</source>
          <target state="translated">グループロールのメンバーは、2つの方法でロールの特権を使用できます。まず、グループのすべてのメンバーは、&lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;を明示的に実行して、一時的にグループの役割になることができます。この状態では、データベースセッションは元のログインロールではなくグループロールの権限にアクセスでき、作成されたデータベースオブジェクトは、ログインロールではなくグループロールが所有していると見なされます。第2に、 &lt;code&gt;INHERIT&lt;/code&gt; 属性を持つメンバーロールは、それらのロールによって継承された特権を含め、メンバーであるロールの特権を自動的に使用します。例として、次のようにしたとします。</target>
        </trans-unit>
        <trans-unit id="c531d86ffa3bb917e6ad2f8783d407b8d81b1be4" translate="yes" xml:space="preserve">
          <source>The mentioned transformations and compilations are normally done automatically using the &lt;em&gt;makefiles&lt;/em&gt; shipped with the PostgreSQL source distribution.</source>
          <target state="translated">上記の変換とコンパイルは、通常、PostgreSQLソース配布に同梱されている&lt;em&gt;makefile&lt;/em&gt;を使用して自動的に行われます。</target>
        </trans-unit>
        <trans-unit id="8cd29d65e9431541c4a7e3d8e7bf9c8ca5af8963" translate="yes" xml:space="preserve">
          <source>The message is encrypted with a symmetric key.</source>
          <target state="translated">メッセージは対称鍵で暗号化されます。</target>
        </trans-unit>
        <trans-unit id="bb36ba49fd3ad58b447d4a645799893632a3669c" translate="yes" xml:space="preserve">
          <source>The message is public-key encrypted, but the key ID has been removed. That means you will need to try all your secret keys on it to see which one decrypts it. &lt;code&gt;pgcrypto&lt;/code&gt; itself does not produce such messages.</source>
          <target state="translated">メッセージは公開鍵で暗号化されていますが、鍵IDは削除されています。つまり、すべての秘密鍵を試して、どれが復号するかを確認する必要があります。 &lt;code&gt;pgcrypto&lt;/code&gt; 自体はそのようなメッセージを生成しません。</target>
        </trans-unit>
        <trans-unit id="80b9ed75dbe3c0d3f0a0153cbc3b5f5a6c2e4216" translate="yes" xml:space="preserve">
          <source>The metasyntax forms described in &lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;Section 9.7.3.4&lt;/a&gt; do not exist in XQuery.</source>
          <target state="translated">&lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;セクション9.7.3.4で&lt;/a&gt;説明されているメタ構文フォームはXQueryには存在しません。</target>
        </trans-unit>
        <trans-unit id="5167d97b5af2d410349f4f14e2833acb2e09f087" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;ANY&lt;/code&gt; specifies a quorum-based synchronous replication and makes transaction commits wait until their WAL records are replicated to &lt;em&gt;at least&lt;/em&gt; the requested number of synchronous standbys in the list.</source>
          <target state="translated">メソッド &lt;code&gt;ANY&lt;/code&gt; は、クォーラムベースの同期レプリケーションを指定し、WALレコードが&lt;em&gt;少なくとも&lt;/em&gt;リスト内の要求された数の同期スタンバイに複製されるまでトランザクションコミットを待機させます。</target>
        </trans-unit>
        <trans-unit id="f49f419e2b9a22a4fc79b879fb7d7ed163340aa2" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;FIRST&lt;/code&gt; specifies a priority-based synchronous replication and makes transaction commits wait until their WAL records are replicated to the requested number of synchronous standbys chosen based on their priorities. The standbys whose names appear earlier in the list are given higher priority and will be considered as synchronous. Other standby servers appearing later in this list represent potential synchronous standbys. If any of the current synchronous standbys disconnects for whatever reason, it will be replaced immediately with the next-highest-priority standby.</source>
          <target state="translated">メソッド &lt;code&gt;FIRST&lt;/code&gt; は優先度ベースの同期レプリケーションを指定し、WALレコードが優先度に基づいて選択された同期スタンバイの要求された数に複製されるまでトランザクションコミットを待機させます。リストの最初の方に名前が表示されているスタンバイには、より高い優先順位が与えられ、同期と見なされます。このリストの後半にある他のスタンバイサーバーは、潜在的な同期スタンバイを表しています。現在の同期スタンバイのいずれかが何らかの理由で切断された場合、すぐに次に優先順位の高いスタンバイに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="3b4f76e9dc87199736499aa89b071e2462e85235" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;md5&lt;/code&gt; uses a custom less secure challenge-response mechanism. It prevents password sniffing and avoids storing passwords on the server in plain text but provides no protection if an attacker manages to steal the password hash from the server. Also, the MD5 hash algorithm is nowadays no longer considered secure against determined attacks.</source>
          <target state="translated">メソッド &lt;code&gt;md5&lt;/code&gt; は、カスタムの安全性の低いチャレンジ/レスポンスメカニズムを使用します。パスワードスニッフィングを防止し、パスワードをサーバーにプレーンテキストで保存することを回避しますが、攻撃者がサーバーからパスワードハッシュを盗んだ場合、保護は提供されません。また、現在、MD5ハッシュアルゴリズムは、決まった攻撃に対して安全であるとは見なされていません。</target>
        </trans-unit>
        <trans-unit id="bbe98735c0b460f287d0e1fc8bbe8558da46b394" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;password&lt;/code&gt; sends the password in clear-text and is therefore vulnerable to password &amp;ldquo;sniffing&amp;rdquo; attacks. It should always be avoided if possible. If the connection is protected by SSL encryption then &lt;code&gt;password&lt;/code&gt; can be used safely, though. (Though SSL certificate authentication might be a better choice if one is depending on using SSL).</source>
          <target state="translated">メソッド &lt;code&gt;password&lt;/code&gt; はパスワードを平文で送信するため、パスワードの「盗聴」攻撃に対して脆弱です。可能であれば常に回避する必要があります。ただし、接続がSSL暗号化によって保護されている場合は、 &lt;code&gt;password&lt;/code&gt; を安全に使用できます。（ただし、SSLの使用に依存している場合は、SSL証明書認証の方が適している場合があります）。</target>
        </trans-unit>
        <trans-unit id="c4e1d81897ac3ef5344a09ff3085827106ec9fad" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;scram-sha-256&lt;/code&gt; performs SCRAM-SHA-256 authentication, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7677&quot;&gt;RFC 7677&lt;/a&gt;. It is a challenge-response scheme that prevents password sniffing on untrusted connections and supports storing passwords on the server in a cryptographically hashed form that is thought to be secure.</source>
          <target state="translated">方法 &lt;code&gt;scram-sha-256&lt;/code&gt; を行うに記載されているようにSCRAM-SHA-256認証、&lt;a href=&quot;https://tools.ietf.org/html/rfc7677&quot;&gt;RFC 7677&lt;/a&gt;。これは、信頼できない接続でのパスワードスニッフィングを防止し、安全であると考えられる暗号学的にハッシュされた形式でサーバーにパスワードを保存することをサポートするチャレンジ/レスポンス方式です。</target>
        </trans-unit>
        <trans-unit id="4d38dbf255ad283e492b192c046e51eef7da09c0" translate="yes" xml:space="preserve">
          <source>The method a client application must use to detect notification events depends on which PostgreSQL application programming interface it uses. With the libpq library, the application issues &lt;code&gt;LISTEN&lt;/code&gt; as an ordinary SQL command, and then must periodically call the function &lt;code&gt;PQnotifies&lt;/code&gt; to find out whether any notification events have been received. Other interfaces such as libpgtcl provide higher-level methods for handling notify events; indeed, with libpgtcl the application programmer should not even issue &lt;code&gt;LISTEN&lt;/code&gt; or &lt;code&gt;UNLISTEN&lt;/code&gt; directly. See the documentation for the interface you are using for more details.</source>
          <target state="translated">クライアントアプリケーションが通知イベントを検出するために使用する必要がある方法は、使用するPostgreSQLアプリケーションプログラミングインターフェイスによって異なります。 libpqライブラリを使用すると、アプリケーションは通常のSQLコマンドとして &lt;code&gt;LISTEN&lt;/code&gt; を発行し、定期的に関数 &lt;code&gt;PQnotifies&lt;/code&gt; を呼び出して、通知イベントが受信されたかどうかを確認する必要があります。 libpgtclなどの他のインターフェースは、通知イベントを処理するための高レベルのメソッドを提供します。実際、libpgtclを使用すると、アプリケーションプログラマは &lt;code&gt;LISTEN&lt;/code&gt; または &lt;code&gt;UNLISTEN&lt;/code&gt; を直接発行することもできません。詳細については、使用しているインターフェースのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="820cf6d702543aba9dfe85b2f79f3d6774753e9a" translate="yes" xml:space="preserve">
          <source>The method described in this section has been obsoleted by the use of stored generated columns, as described in &lt;a href=&quot;textsearch-tables#TEXTSEARCH-TABLES-INDEX&quot;&gt;Section 12.2.2&lt;/a&gt;.</source>
          <target state="translated">このセクションで説明する方法は、&lt;a href=&quot;textsearch-tables#TEXTSEARCH-TABLES-INDEX&quot;&gt;セクション12.2.2で&lt;/a&gt;説明するように、格納された生成列を使用することで廃止されました。</target>
        </trans-unit>
        <trans-unit id="318a555813c808d85dcecb5209b3a3a236dc9ab5" translate="yes" xml:space="preserve">
          <source>The method for triggering failover is an important part of planning and design. One potential option is the &lt;code&gt;restore_command&lt;/code&gt; command. It is executed once for each WAL file, but the process running the &lt;code&gt;restore_command&lt;/code&gt; is created and dies for each file, so there is no daemon or server process, and signals or a signal handler cannot be used. Therefore, the &lt;code&gt;restore_command&lt;/code&gt; is not suitable to trigger failover. It is possible to use a simple timeout facility, especially if used in conjunction with a known &lt;code&gt;archive_timeout&lt;/code&gt; setting on the primary. However, this is somewhat error prone since a network problem or busy primary server might be sufficient to initiate failover. A notification mechanism such as the explicit creation of a trigger file is ideal, if this can be arranged.</source>
          <target state="translated">フェイルオーバーをトリガーする方法は、計画と設計の重要な部分です。可能なオプションの1つは、 &lt;code&gt;restore_command&lt;/code&gt; コマンドです。WALファイルごとに1回実行されますが、 &lt;code&gt;restore_command&lt;/code&gt; を実行するプロセスが作成され、ファイルごとに終了するため、デーモンまたはサーバープロセスがなく、シグナルまたはシグナルハンドラーを使用できません。したがって、 &lt;code&gt;restore_command&lt;/code&gt; はフェイルオーバーのトリガーには適していません。特に、既知の &lt;code&gt;archive_timeout&lt;/code&gt; と組み合わせて使用​​する場合は、単純なタイムアウト機能を使用できます。プライマリの設定。ただし、フェイルオーバーを開始するにはネットワークの問題またはビジーなプライマリサーバーで十分な場合があるため、これは多少エラーが発生しやすくなります。可能であれば、トリガーファイルの明示的な作成などの通知メカニズムが理想的です。</target>
        </trans-unit>
        <trans-unit id="9ecf9a698c1e522b9c1de1bf5af789211b8be7ed" translate="yes" xml:space="preserve">
          <source>The millennium</source>
          <target state="translated">千年紀</target>
        </trans-unit>
        <trans-unit id="d49286ea0d415b0aad37189b731269fb41a33f65" translate="yes" xml:space="preserve">
          <source>The minute component of the time zone offset</source>
          <target state="translated">タイムゾーンオフセットの分単位</target>
        </trans-unit>
        <trans-unit id="70c1dd6d1f4cd9d65c5ea9908ee66b76d8b0f4e4" translate="yes" xml:space="preserve">
          <source>The minutes field (0 - 59)</source>
          <target state="translated">議事録フィールド (0-59)</target>
        </trans-unit>
        <trans-unit id="f58bb99f67c9dd4fa543f324ba0a954d9aeea2c7" translate="yes" xml:space="preserve">
          <source>The missing positions 1,2,4 are because of stop words. Ranks calculated for documents with and without stop words are quite different:</source>
          <target state="translated">1,2,4の位置が欠けているのは、ストップワードのためです。ストップワードのある文書とない文書では、順位の計算にかなりの差があります。</target>
        </trans-unit>
        <trans-unit id="7efece902ce6baec1dac421e4950dc636bcb9bc8" translate="yes" xml:space="preserve">
          <source>The mixed notation combines positional and named notation. However, as already mentioned, named arguments cannot precede positional arguments. For example:</source>
          <target state="translated">混合記法は、位置引数と名前付き引数を組み合わせたものです。しかし、すでに述べたように、名前付き引数は位置引数に先行することはできません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="dfdfde6fd27332a6600ccf2d0ac2ce0c45f7420f" translate="yes" xml:space="preserve">
          <source>The mode of a function, procedure, or aggregate argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;ALTER EXTENSION&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">関数、プロシージャ、または集約引数のモード： &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;OUT&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、または &lt;code&gt;VARIADIC&lt;/code&gt; 。省略した場合、デフォルトは &lt;code&gt;IN&lt;/code&gt; です。関数のIDを決定するために必要なのは入力引数だけなので、 &lt;code&gt;ALTER EXTENSION&lt;/code&gt; は実際には &lt;code&gt;OUT&lt;/code&gt; 引数に注意を払わないことに注意してください。したがって、 &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、および &lt;code&gt;VARIADIC&lt;/code&gt; 引数をリストするだけで十分です。</target>
        </trans-unit>
        <trans-unit id="68b58e6626dcfa87dd99931a1610596ebfd41322" translate="yes" xml:space="preserve">
          <source>The mode of a function, procedure, or aggregate argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;COMMENT&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">関数、プロシージャ、または集約引数のモード： &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;OUT&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、または &lt;code&gt;VARIADIC&lt;/code&gt; 。省略した場合、デフォルトは &lt;code&gt;IN&lt;/code&gt; です。関数のIDを決定するために必要なのは入力引数だけなので、 &lt;code&gt;COMMENT&lt;/code&gt; は実際には &lt;code&gt;OUT&lt;/code&gt; 引数に注意を払わないことに注意してください。したがって、 &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、および &lt;code&gt;VARIADIC&lt;/code&gt; 引数をリストするだけで十分です。</target>
        </trans-unit>
        <trans-unit id="d48b93746498257a59bb7fe4e61442dbe73691fd" translate="yes" xml:space="preserve">
          <source>The mode of a function, procedure, or aggregate argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;SECURITY LABEL&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">関数、プロシージャ、または集約引数のモード： &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;OUT&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、または &lt;code&gt;VARIADIC&lt;/code&gt; 。省略した場合、デフォルトは &lt;code&gt;IN&lt;/code&gt; です。注意 &lt;code&gt;SECURITY LABEL&lt;/code&gt; 、実際に注意を払っていない &lt;code&gt;OUT&lt;/code&gt; の唯一の入力引数が関数の同一性を決定するために必要とされているので、引数を指定します。したがって、 &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、および &lt;code&gt;VARIADIC&lt;/code&gt; 引数をリストするだけで十分です。</target>
        </trans-unit>
        <trans-unit id="45f33dca690dafc673c0eaa64fba7b4d58d74383" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt; or &lt;code&gt;VARIADIC&lt;/code&gt;. (Aggregate functions do not support &lt;code&gt;OUT&lt;/code&gt; arguments.) If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Only the last argument can be marked &lt;code&gt;VARIADIC&lt;/code&gt;.</source>
          <target state="translated">引数のモード： &lt;code&gt;IN&lt;/code&gt; または &lt;code&gt;VARIADIC&lt;/code&gt; 。（集約関数は &lt;code&gt;OUT&lt;/code&gt; 引数をサポートしていません。）省略した場合、デフォルトは &lt;code&gt;IN&lt;/code&gt; です。最後の引数のみ &lt;code&gt;VARIADIC&lt;/code&gt; とマークできます。</target>
        </trans-unit>
        <trans-unit id="4568485f8330f08f8282bc3a9f4e6ab0835ae883" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt; or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;.</source>
          <target state="translated">引数のモード： &lt;code&gt;IN&lt;/code&gt; または &lt;code&gt;VARIADIC&lt;/code&gt; 。省略した場合、デフォルトは &lt;code&gt;IN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d77ba6d205a4cdad089faf693afa61d51e9631c2" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. (&lt;code&gt;OUT&lt;/code&gt; arguments are currently not supported for procedures. Use &lt;code&gt;INOUT&lt;/code&gt; instead.)</source>
          <target state="translated">引数のモード： &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、または &lt;code&gt;VARIADIC&lt;/code&gt; 。省略した場合、デフォルトは &lt;code&gt;IN&lt;/code&gt; です。（ &lt;code&gt;OUT&lt;/code&gt; 引数は現在、プロシージャではサポートされていません。代わりに &lt;code&gt;INOUT&lt;/code&gt; を使用してください。）</target>
        </trans-unit>
        <trans-unit id="38c566bf6c299177523daede4805416a31c75adc" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;ALTER FUNCTION&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">引数のモード： &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;OUT&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、または &lt;code&gt;VARIADIC&lt;/code&gt; 。省略した場合、デフォルトは &lt;code&gt;IN&lt;/code&gt; です。関数のIDを判別するために必要なのは入力引数だけなので、 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; は実際には &lt;code&gt;OUT&lt;/code&gt; 引数に注意を払わないことに注意してください。したがって、 &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、および &lt;code&gt;VARIADIC&lt;/code&gt; 引数をリストするだけで十分です。</target>
        </trans-unit>
        <trans-unit id="0c0698969a82046af9f337be0b0bf94de3d24ca9" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;DROP FUNCTION&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">引数のモード： &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;OUT&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、または &lt;code&gt;VARIADIC&lt;/code&gt; 。省略した場合、デフォルトは &lt;code&gt;IN&lt;/code&gt; です。関数のIDを決定するために必要なのは入力引数だけなので、 &lt;code&gt;DROP FUNCTION&lt;/code&gt; は実際には &lt;code&gt;OUT&lt;/code&gt; 引数に注意を払わないことに注意してください。したがって、 &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、および &lt;code&gt;VARIADIC&lt;/code&gt; 引数をリストするだけで十分です。</target>
        </trans-unit>
        <trans-unit id="6f4ca0b892fae54672225fff5e45afe9a23bd3fa" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Only &lt;code&gt;OUT&lt;/code&gt; arguments can follow a &lt;code&gt;VARIADIC&lt;/code&gt; one. Also, &lt;code&gt;OUT&lt;/code&gt; and &lt;code&gt;INOUT&lt;/code&gt; arguments cannot be used together with the &lt;code&gt;RETURNS TABLE&lt;/code&gt; notation.</source>
          <target state="translated">引数のモード： &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;OUT&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、または &lt;code&gt;VARIADIC&lt;/code&gt; 。省略した場合、デフォルトは &lt;code&gt;IN&lt;/code&gt; です。 &lt;code&gt;VARIADIC&lt;/code&gt; 引数の後に続くことができるのは &lt;code&gt;OUT&lt;/code&gt; 引数のみです。また、 &lt;code&gt;OUT&lt;/code&gt; および &lt;code&gt;INOUT&lt;/code&gt; 引数を &lt;code&gt;RETURNS TABLE&lt;/code&gt; 表記と一緒に使用することはできません。</target>
        </trans-unit>
        <trans-unit id="51a81b68008882e6907064e5a6c6b245cdf62054" translate="yes" xml:space="preserve">
          <source>The modification of data that is already in the database is referred to as updating. You can update individual rows, all the rows in a table, or a subset of all rows. Each column can be updated separately; the other columns are not affected.</source>
          <target state="translated">すでにデータベースにあるデータを変更することを更新といいます。個々の行、テーブル内のすべての行、またはすべての行のサブセットを更新することができます。各列は個別に更新することができ、他の列は影響を受けません。</target>
        </trans-unit>
        <trans-unit id="853b75e3f66e460231939e7956e83ee3b696375d" translate="yes" xml:space="preserve">
          <source>The module also provides a data type &lt;code&gt;lo&lt;/code&gt;, which is really just a domain of the &lt;code&gt;oid&lt;/code&gt; type. This is useful for differentiating database columns that hold large object references from those that are OIDs of other things. You don't have to use the &lt;code&gt;lo&lt;/code&gt; type to use the trigger, but it may be convenient to use it to keep track of which columns in your database represent large objects that you are managing with the trigger. It is also rumored that the ODBC driver gets confused if you don't use &lt;code&gt;lo&lt;/code&gt; for BLOB columns.</source>
          <target state="translated">このモジュールは、データ型 &lt;code&gt;lo&lt;/code&gt; も提供します。これは、実際には &lt;code&gt;oid&lt;/code&gt; 型のドメインにすぎません。これは、ラージオブジェクト参照を保持するデータベース列を、他のもののOIDであるものと区別するのに役立ちます。トリガーを使用するために &lt;code&gt;lo&lt;/code&gt; タイプを使用する必要はありませんが、トリガーを使用して管理している大きなオブジェクトをデータベースのどの列が表すかを追跡するために使用すると便利な場合があります。BLOB列に &lt;code&gt;lo&lt;/code&gt; を使用しないと、ODBCドライバーが混乱するという噂もあります。</target>
        </trans-unit>
        <trans-unit id="81ca0d62d96cb007036c4e8c71ad66419c59e2b5" translate="yes" xml:space="preserve">
          <source>The module must be loaded by adding &lt;code&gt;pg_stat_statements&lt;/code&gt; to &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;, because it requires additional shared memory. This means that a server restart is needed to add or remove the module.</source>
          <target state="translated">追加の共有メモリを必要とするため、モジュールは &lt;code&gt;postgresql.conf&lt;/code&gt; の&lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt;に &lt;code&gt;pg_stat_statements&lt;/code&gt; を追加してロードする必要があります。つまり、モジュールを追加または削除するには、サーバーを再起動する必要があります。</target>
        </trans-unit>
        <trans-unit id="d72e93f82e4421713f65eb6d758581a8fbe9cccf" translate="yes" xml:space="preserve">
          <source>The module provides a C function &lt;code&gt;pg_buffercache_pages&lt;/code&gt; that returns a set of records, plus a view &lt;code&gt;pg_buffercache&lt;/code&gt; that wraps the function for convenient use.</source>
          <target state="translated">このモジュールは、レコードのセットを返すC関数 &lt;code&gt;pg_buffercache_pages&lt;/code&gt; と、便利に使用できるように関数をラップするビュー &lt;code&gt;pg_buffercache&lt;/code&gt; を提供します。</target>
        </trans-unit>
        <trans-unit id="32a787e9d3c71749ae7c7075bc8cc6c86f32c2a0" translate="yes" xml:space="preserve">
          <source>The module provides no SQL-accessible functions. To use it, simply load it into the server. You can load it into an individual session:</source>
          <target state="translated">このモジュールは、SQLにアクセス可能な関数を提供しません。使用するには、サーバにロードするだけです。個々のセッションにロードすることができます。</target>
        </trans-unit>
        <trans-unit id="7b136900f1dbee2d882f7a554d2840c344beb60e" translate="yes" xml:space="preserve">
          <source>The module requires additional shared memory proportional to &lt;code&gt;pg_stat_statements.max&lt;/code&gt;. Note that this memory is consumed whenever the module is loaded, even if &lt;code&gt;pg_stat_statements.track&lt;/code&gt; is set to &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">モジュールには、 &lt;code&gt;pg_stat_statements.max&lt;/code&gt; に比例する追加の共有メモリが必要です。このメモリは、 &lt;code&gt;pg_stat_statements.track&lt;/code&gt; が &lt;code&gt;none&lt;/code&gt; に設定されている場合でも、モジュールがロードされるたびに消費されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="96530f50681b8674942f17d7870b9786b275bddf" translate="yes" xml:space="preserve">
          <source>The monitoring information about subscription is visible in &lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt;&lt;code&gt;pg_stat_subscription&lt;/code&gt;&lt;/a&gt;. This view contains one row for every subscription worker. A subscription can have zero or more active subscription workers depending on its state.</source>
          <target state="translated">サブスクリプションに関する監視情報は&lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt; &lt;code&gt;pg_stat_subscription&lt;/code&gt; に&lt;/a&gt;表示されます。このビューには、サブスクリプションワーカーごとに1つの行が含まれます。サブスクリプションは、その状態に応じて、0個以上のアクティブなサブスクリプションワーカーを持つことができます。</target>
        </trans-unit>
        <trans-unit id="e4f2efea26fbea2f4a0f53659ea7db3de7f00c25" translate="yes" xml:space="preserve">
          <source>The most common reason for conflict between standby queries and WAL replay is &amp;ldquo;early cleanup&amp;rdquo;. Normally, PostgreSQL allows cleanup of old row versions when there are no transactions that need to see them to ensure correct visibility of data according to MVCC rules. However, this rule can only be applied for transactions executing on the master. So it is possible that cleanup on the master will remove row versions that are still visible to a transaction on the standby.</source>
          <target state="translated">スタンバイクエリとWAL再生の競合の最も一般的な理由は、「早期クリーンアップ」です。通常、PostgreSQLでは、MVCCルールに従ってデータを正しく表示するためにそれらを表示する必要のあるトランザクションがない場合、古い行バージョンをクリーンアップできます。ただし、このルールは、マスターで実行されているトランザクションにのみ適用できます。そのため、マスターのクリーンアップにより、スタンバイのトランザクションでまだ表示されている行バージョンが削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="731bbf4edb90976573e528f87d62ab4f72b17368" translate="yes" xml:space="preserve">
          <source>The most critical part of the display is the estimated statement execution cost, which is the planner's guess at how long it will take to run the statement (measured in cost units that are arbitrary, but conventionally mean disk page fetches). Actually two numbers are shown: the start-up cost before the first row can be returned, and the total cost to return all the rows. For most queries the total cost is what matters, but in contexts such as a subquery in &lt;code&gt;EXISTS&lt;/code&gt;, the planner will choose the smallest start-up cost instead of the smallest total cost (since the executor will stop after getting one row, anyway). Also, if you limit the number of rows to return with a &lt;code&gt;LIMIT&lt;/code&gt; clause, the planner makes an appropriate interpolation between the endpoint costs to estimate which plan is really the cheapest.</source>
          <target state="translated">表示の最も重要な部分は、ステートメントの実行コストの見積もりです。これは、プランナーがステートメントの実行にかかる時間を推測したものです（任意のコスト単位で測定されますが、通常はディスクページのフェッチを意味します）。実際には2つの数値が表示されます。最初の行が返される前の開始コストと、すべての行を返すための合計コストです。ほとんどのクエリでは総コストが重要ですが、 &lt;code&gt;EXISTS&lt;/code&gt; のサブクエリなどのコンテキストでは、プランナは最小の総コストではなく最小の起動コストを選択します（とにかく、エグゼキュータは1行を取得すると停止するため）。また、返す行数を &lt;code&gt;LIMIT&lt;/code&gt; で制限した場合 節では、プランナーはエンドポイントのコストを適切に補間して、実際に最も安いプランを見積もります。</target>
        </trans-unit>
        <trans-unit id="413b816a60a8ce6de7ad09a5ffb4362dd48af1ec" translate="yes" xml:space="preserve">
          <source>The most fundamental way to set these parameters is to edit the file &lt;code&gt;postgresql.conf&lt;/code&gt;, which is normally kept in the data directory. A default copy is installed when the database cluster directory is initialized. An example of what this file might look like is:</source>
          <target state="translated">これらのパラメータを設定する最も基本的な方法は、通常データディレクトリに保存される &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルを編集することです。デフォルトのコピーは、データベースクラスターディレクトリが初期化されるときにインストールされます。このファイルの例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e306bed63f3a1d9eca423326fcf07e6b9edcc6b0" translate="yes" xml:space="preserve">
          <source>The most important disk monitoring task of a database administrator is to make sure the disk doesn't become full. A filled data disk will not result in data corruption, but it might prevent useful activity from occurring. If the disk holding the WAL files grows full, database server panic and consequent shutdown might occur.</source>
          <target state="translated">データベース管理者の最も重要なディスク監視作業は、ディスクが満杯にならないようにすることです。データディスクが一杯になってもデータが破損することはありませんが、有用なアクティビティの発生を妨げる可能性があります。WAL ファイルを保持しているディスクが一杯になると、データベースサーバーがパニックに陥り、結果としてシャットダウンが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="877dc37c3736494355fb75407dc41fe0e6f84483" translate="yes" xml:space="preserve">
          <source>The most interesting options are probably &lt;code&gt;compress-algo&lt;/code&gt; and &lt;code&gt;unicode-mode&lt;/code&gt;. The rest should have reasonable defaults.</source>
          <target state="translated">最も興味深いオプションは、おそらく &lt;code&gt;compress-algo&lt;/code&gt; と &lt;code&gt;unicode-mode&lt;/code&gt; です。残りは妥当なデフォルトでなければなりません。</target>
        </trans-unit>
        <trans-unit id="9a6d131c4243d30d96e0db292f1623b359a016fb" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a &lt;em&gt;planner support function&lt;/em&gt; to use for this function. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt; for details. You must be superuser to use this option.</source>
          <target state="translated">この&lt;em&gt;関数&lt;/em&gt;に使用する&lt;em&gt;プランナサポート関数&lt;/em&gt;の名前（オプションでスキーマ修飾）。詳細は&lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;項37.11&lt;/a&gt;を参照してください。このオプションを使用するには、スーパーユーザーである必要があります。</target>
        </trans-unit>
        <trans-unit id="14b6fcb4c63d755a00d7e0670d638ed746023a2d" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a domain to be created.</source>
          <target state="translated">作成されるドメインの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="38611bfc887263be7f78673bf7d9d5cdb57c578a" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a function that is an index method support function for the operator class.</source>
          <target state="translated">演算子クラスのインデックスメソッドサポート関数である関数の名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="5902522e953f867bcf2f16270ac0968cc20f9546" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a function that is an index method support function for the operator family. If no argument list is specified, the name must be unique in its schema.</source>
          <target state="translated">演算子ファミリのインデックスメソッドサポート関数である関数の名前(スキーマ修飾も可)。引数リストが指定されていない場合、その名前はスキーマ内で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d845c7a3b53e4177570415c0bc3bcd5b3195e4e2" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a sequence to be altered.</source>
          <target state="translated">変更するシーケンスの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="86f2ddbdf403f4ceac3ce1673bf568f23dd1ad99" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a sequence.</source>
          <target state="translated">シーケンスの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="ac3e3dd701383980ee625dc0305504430477533a" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a specific table or materialized view to vacuum. If the specified table is a partitioned table, all of its leaf partitions are vacuumed.</source>
          <target state="translated">バキュームする特定のテーブルまたはマテリアライズドビューの名前(スキーマ修飾も可)。指定したテーブルがパーティショニングされたテーブルの場合は、そのすべてのリーフパーティションがバキュームされます。</target>
        </trans-unit>
        <trans-unit id="53bb17c6184a24ee8382a2d75581d17a4a86859a" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a table to truncate. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is truncated. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are truncated. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">切り捨てるテーブルの名前（オプションでスキーマ修飾）。場合 &lt;code&gt;ONLY&lt;/code&gt; テーブル名の前に指定され、そのテーブルのみが切り捨てられます。 &lt;code&gt;ONLY&lt;/code&gt; が指定されていない場合、テーブルとそのすべての子孫テーブル（存在する場合）は切り捨てられます。オプションで、 &lt;code&gt;*&lt;/code&gt; をテーブル名の後に指定して、子孫テーブルが含まれることを明示的に示すことができます。</target>
        </trans-unit>
        <trans-unit id="2e64f1d6069ef5fc5ed6316b39d72b0e2b06f901" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a type to be created.</source>
          <target state="translated">作成される型の名前(スキーマ修飾も可)。</target>
        </trans-unit>
        <trans-unit id="f9bf344cdc87b1adaf5636fb2ebcad9f1ddba5b6" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a view to be created.</source>
          <target state="translated">作成するビューの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="b639552e986e941a3c10c2544ec995a239ffb6e3" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing &lt;code&gt;btree&lt;/code&gt; operator family that describes the sort ordering associated with an ordering operator.</source>
          <target state="translated">順序付け演算子に関連付けられた並べ替え順序を説明する既存の &lt;code&gt;btree&lt;/code&gt; 演算子族の名前（オプションでスキーマ修飾）。</target>
        </trans-unit>
        <trans-unit id="34900785f9149eeefbc60e92cda94ca173cd04e7" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing aggregate function.</source>
          <target state="translated">既存の集約関数の名前(スキーマ修飾も可)。</target>
        </trans-unit>
        <trans-unit id="578ce1660a308750d3e750170be95b160d2b4eaa" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing collation.</source>
          <target state="translated">既存の照合順序の名前(スキーマ修飾も可)。</target>
        </trans-unit>
        <trans-unit id="f41ad29e0b7f082d84fd62fd8cb20d2acca4d7fc" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing conversion.</source>
          <target state="translated">既存の変換の名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="3906d435eac2789ae790437fa866de097132bd5f" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing domain.</source>
          <target state="translated">既存のドメインの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="d79e2ff622e47d59db15f73c173411091fa8fabb" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing function. If no argument list is specified, the name must be unique in its schema.</source>
          <target state="translated">既存の関数の名前(スキーマ修飾も可)。引数リストが指定されていない場合は、その名前はスキーマ内で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="e19891aa77a7fd37f7b714112d5a229b9e2c2c1e" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing materialized view.</source>
          <target state="translated">既存のマテリアライズドビューの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="d3c124f08f1d17279d8902cee277b8d4f1a183ad" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing operator class.</source>
          <target state="translated">既存の演算子クラスの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="38e2880de321890fbbcce2e9729e127a62b40b76" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing operator family.</source>
          <target state="translated">既存の演算子ファミリーの名前(スキーマ修飾も可)。</target>
        </trans-unit>
        <trans-unit id="054a0dca285caf1e015006f488ef65a3eecedbf4" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing operator.</source>
          <target state="translated">既存の演算子の名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="77adb5998ee2e3aabde213dad5e54fd26872e3dc" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing procedure. If no argument list is specified, the name must be unique in its schema.</source>
          <target state="translated">既存のプロシージャの名前(オプションでスキーマ修飾)。引数リストが指定されていない場合、その名前はスキーマ内で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="f544776c8e3c1cef33633f466a66f32aea31c3fe" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table or view. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is scanned. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are scanned. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">既存のテーブルまたはビューの名前（オプションでスキーマ修飾）。場合 &lt;code&gt;ONLY&lt;/code&gt; テーブル名の前に指定され、そのテーブルのみがスキャンされます。 &lt;code&gt;ONLY&lt;/code&gt; が指定されていない場合、テーブルとそのすべての子孫テーブル（存在する場合）がスキャンされます。オプションで、 &lt;code&gt;*&lt;/code&gt; をテーブル名の後に指定して、子孫テーブルが含まれることを明示的に示すことができます。</target>
        </trans-unit>
        <trans-unit id="fed47b49b5a2826cdd529f07291a0b91365295e5" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table to alter. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is altered. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are altered. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">変更する既存のテーブルの名前（オプションでスキーマ修飾）。場合 &lt;code&gt;ONLY&lt;/code&gt; テーブル名の前に指定され、そのテーブルのみが変更されています。 &lt;code&gt;ONLY&lt;/code&gt; が指定されていない場合、テーブルとそのすべての子孫テーブル（存在する場合）が変更されます。オプションで、 &lt;code&gt;*&lt;/code&gt; をテーブル名の後に指定して、子孫テーブルが含まれることを明示的に示すことができます。</target>
        </trans-unit>
        <trans-unit id="9e39d635b5a89d3591bd7fd7ce4ecbe9ffd4c1d5" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table to lock. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is locked. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are locked. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">ロックする既存のテーブルの名前（オプションでスキーマ修飾）。もし &lt;code&gt;ONLY&lt;/code&gt; テーブルがロックされているだけで、テーブル名の前に指定されています。 &lt;code&gt;ONLY&lt;/code&gt; が指定されていない場合、テーブルとそのすべての子孫テーブル（存在する場合）がロックされます。オプションで、 &lt;code&gt;*&lt;/code&gt; をテーブル名の後に指定して、子孫テーブルが含まれることを明示的に示すことができます。</target>
        </trans-unit>
        <trans-unit id="7b428f5695f116b2abd1edd43a6b7f791e930f67" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table.</source>
          <target state="translated">既存のテーブルの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="d6bac31933d004e229772d4577bb5205aa40d1b4" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search configuration.</source>
          <target state="translated">既存のテキスト検索設定の名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="c30fa81fa2fa2992c5e25e7be26425ba28f70618" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search dictionary.</source>
          <target state="translated">既存のテキスト検索辞書の名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="6764c434bb1917335a8e7ae9bad93f1fcc49fc17" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search parser.</source>
          <target state="translated">既存のテキスト検索パーサの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="dcc71c03641d807db453dbb54b0a2fce72902867" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search template.</source>
          <target state="translated">既存のテキスト検索テンプレートの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="c07fc33a37601af59ca6761edf035f64fe688e76" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing view.</source>
          <target state="translated">既存のビューの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="5f3b87270ccb7b31876399c63171eeddc6c5acd0" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an index to remove.</source>
          <target state="translated">削除するインデックスの名前(スキーマ修飾も可)。</target>
        </trans-unit>
        <trans-unit id="4d1a15fbadbb463eba7072f8d97b36fff8e4db35" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an operator associated with the operator class.</source>
          <target state="translated">演算子クラスに関連付けられた演算子の名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="f55c07895028de262598e75436d631175b201a69" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an operator associated with the operator family.</source>
          <target state="translated">演算子ファミリーに関連付けられた演算子の名前 (オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="b2bd7b76dedcec38eb17eed38f1b959f8bd417a7" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the aggregate function to create.</source>
          <target state="translated">作成する集約関数の名前(スキーマ修飾も可)。</target>
        </trans-unit>
        <trans-unit id="a93a4bd4bc9034a1432f189ca88e837333dc130b" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the data type to remove.</source>
          <target state="translated">削除するデータ型の名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="985217a7a1fa0c3a567eb7244b6b8b146f2c7b30" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the foreign table to drop.</source>
          <target state="translated">ドロップする外部テーブルの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="c10f31992b2571e70d614bb2d060a79ba59a8a33" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the function to create.</source>
          <target state="translated">作成する関数の名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="83e9847814c3ba939cbc4f420e1c3c7c00a69552" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the materialized view to be created.</source>
          <target state="translated">作成されるマテリアライズされたビューの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="2255582209b1f3da815e53122bc13a8a7b84cf00" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the materialized view to refresh.</source>
          <target state="translated">更新するマテリアライズされたビューの名前(スキーマ修飾も可)。</target>
        </trans-unit>
        <trans-unit id="2db1fb74b2f868165f2c5564d755e2f43c24353f" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the materialized view to remove.</source>
          <target state="translated">削除するマテリアライズされたビューの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="9df0359ba8b94b06eb25b013152842f292a7b4df" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the procedure to create.</source>
          <target state="translated">作成するプロシージャの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="4cd07bcb956404ed169f912452a4480e70e115e4" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the procedure.</source>
          <target state="translated">プロシージャの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="2a4c2e1b22bdcbf405362b9ae17fa1fbce426df2" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the sequence to be created.</source>
          <target state="translated">作成するシーケンスの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="048a9ab4e359ce8b95a4959e9df97e30c4e65d60" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the statistics object to be altered.</source>
          <target state="translated">変更する統計オブジェクトの名前(スキーマ修飾も可)。</target>
        </trans-unit>
        <trans-unit id="f52881167770a0af5eb7409ca2185b9c04bac337" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the statistics object to be created.</source>
          <target state="translated">作成される統計オブジェクトの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="4b423cb4d9cc1b2bcdad9b8dd172fb72d89e4e2c" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the statistics object to drop.</source>
          <target state="translated">ドロップする統計オブジェクトの名前(スキーマ修飾も可)。</target>
        </trans-unit>
        <trans-unit id="b61d21dada065f46c4c7b2b7d604e26966040dc1" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table containing the column(s) the statistics are computed on.</source>
          <target state="translated">統計の計算対象となる列を含むテーブルの名前(スキーマで修飾されている場合もあります)。</target>
        </trans-unit>
        <trans-unit id="8defd757e6f0ae34c512e774b626ccf674726eab" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table for which the trigger is defined.</source>
          <target state="translated">トリガーが定義されているテーブルの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="4d5698a39cc31b5f7b88bdd408f67f5c7638f5d5" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table or view that the rule applies to.</source>
          <target state="translated">ルールが適用されるテーブルまたはビューの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="b756bc816e4bf98b49581640b12dbf571a3be447" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table or view the rule applies to.</source>
          <target state="translated">ルールが適用されるテーブルまたはビューの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="1babb726cd58996c0c81dade9eb62f3731eca7ef" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table that the policy is on.</source>
          <target state="translated">ポリシーが置かれているテーブルの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="66f5ae5d2b295f1ee2b970f57d5d9ecd6bf021d8" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table the policy applies to.</source>
          <target state="translated">ポリシーが適用されるテーブルの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="2163decbe5c6781dc3c30049b04dc6fe3b754ccd" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to be created.</source>
          <target state="translated">作成するテーブルの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="7faaacd9226a4e88c9e4c1c3c739210417e124ce" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to delete rows from. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, matching rows are deleted from the named table only. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, matching rows are also deleted from any tables inheriting from the named table. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">行を削除するテーブルの名前（オプションでスキーマ修飾）。場合 &lt;code&gt;ONLY&lt;/code&gt; テーブル名の前に指定され、一致する行のみを指定したテーブルから削除されます。 &lt;code&gt;ONLY&lt;/code&gt; が指定されていない場合、一致する行も名前付きテーブルから継承するテーブルから削除されます。オプションで、 &lt;code&gt;*&lt;/code&gt; をテーブル名の後に指定して、子孫テーブルが含まれることを明示的に示すことができます。</target>
        </trans-unit>
        <trans-unit id="2a919fb8f51d9d6b6757a121c98308d8b2e355a9" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to drop.</source>
          <target state="translated">ドロップするテーブルの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="805225c1106f83d7720b93b38e959f1241d2a307" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to update. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, matching rows are updated in the named table only. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, matching rows are also updated in any tables inheriting from the named table. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">更新するテーブルの名前（オプションでスキーマ修飾）。テーブル名の前に &lt;code&gt;ONLY&lt;/code&gt; が指定されている場合、一致する行は名前付きテーブルでのみ更新されます。 &lt;code&gt;ONLY&lt;/code&gt; が指定されていない場合、一致する行は、名前付きテーブルから継承するすべてのテーブルでも更新されます。オプションで、 &lt;code&gt;*&lt;/code&gt; をテーブル名の後に指定して、子孫テーブルが含まれることを明示的に示すことができます。</target>
        </trans-unit>
        <trans-unit id="56ec5e8966f4a00d4b5c2a7c99ee7bd04c931eab" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table, view, or foreign table the trigger is for.</source>
          <target state="translated">トリガーが対象とするテーブル、ビュー、または外部テーブルの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="72a54509c9fcd2a9291f8a3e62487b349d23e646" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the view to remove.</source>
          <target state="translated">削除するビューの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="359f50eaf29e3eca920ffd05f6355f20cb0c9f2e" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of a specific table to analyze. If omitted, all regular tables, partitioned tables, and materialized views in the current database are analyzed (but not foreign tables). If the specified table is a partitioned table, both the inheritance statistics of the partitioned table as a whole and statistics of the individual partitions are updated.</source>
          <target state="translated">解析する特定のテーブルの名前(スキーマ修飾されている場合もあります)。省略した場合、現在のデータベース内のすべての通常のテーブル、パーティショニングされたテーブル、マテリアライズされたビューが分析されます(外部テーブルは含まれません)。指定されたテーブルがパーティショニングされたテーブルの場合、パーティショニングされたテーブル全体の継承統計と個々のパーティションの統計の両方が更新されます。</target>
        </trans-unit>
        <trans-unit id="a0cd47e6e1a9ee5389b9c55e40402c5ad699bfc0" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of a table.</source>
          <target state="translated">テーブルの名前(スキーマ修飾されている可能性があります)。</target>
        </trans-unit>
        <trans-unit id="36578a59c82b2f2c476f7f18ac9898c7cebf4713" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing domain to alter.</source>
          <target state="translated">変更する既存ドメインの名前(スキーマ修飾の可能性があります)。</target>
        </trans-unit>
        <trans-unit id="c76b8e93831ffb6b044097c12ef94efed652a62a" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing foreign table to alter. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is altered. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are altered. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">変更する既存の外部テーブルの名前（おそらくスキーマ修飾）。場合 &lt;code&gt;ONLY&lt;/code&gt; テーブル名の前に指定され、そのテーブルのみが変更されています。 &lt;code&gt;ONLY&lt;/code&gt; が指定されていない場合、テーブルとそのすべての子孫テーブル（存在する場合）が変更されます。オプションで、 &lt;code&gt;*&lt;/code&gt; をテーブル名の後に指定して、子孫テーブルが含まれることを明示的に示すことができます。</target>
        </trans-unit>
        <trans-unit id="fc6c50c1390116c899b9f1d7b2719134752e51ac" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing index to alter.</source>
          <target state="translated">変更する既存のインデックスの名前(スキーマ修飾されている可能性があります)。</target>
        </trans-unit>
        <trans-unit id="f3966882870cfe613d0a8e73355b9179fb2c810a" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing type to alter.</source>
          <target state="translated">変更する既存の型の名前(スキーマ修飾されている可能性があります)。</target>
        </trans-unit>
        <trans-unit id="06da0274ecfe82f800f0ab5a5f38a984e49a92a1" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of the table to be indexed.</source>
          <target state="translated">インデックスを作成するテーブルの名前(スキーマ修飾されている可能性があります)。</target>
        </trans-unit>
        <trans-unit id="a158ac6caffff3f341ed81dff98d22b9af284fcf" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;test1_id_index&lt;/code&gt; can be chosen freely, but you should pick something that enables you to remember later what the index was for.</source>
          <target state="translated">&lt;code&gt;test1_id_index&lt;/code&gt; という名前は自由に選択できますが、後でインデックスの目的を思い出せる名前を選択する必要があります。</target>
        </trans-unit>
        <trans-unit id="27865390113cdcda66f400351749779a6e670188" translate="yes" xml:space="preserve">
          <source>The name can be any string of less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; characters (64 characters in a standard build). Only printable ASCII characters may be used in the &lt;code&gt;cluster_name&lt;/code&gt; value. Other characters will be replaced with question marks (&lt;code&gt;?&lt;/code&gt;). No name is shown if this parameter is set to the empty string &lt;code&gt;''&lt;/code&gt; (which is the default). This parameter can only be set at server start.</source>
          <target state="translated">名前は、 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 文字（標準ビルドでは64文字）未満の任意の文字列にすることができます。 &lt;code&gt;cluster_name&lt;/code&gt; 値では、印刷可能なASCII文字のみを使用できます。他の文字は疑問符（ &lt;code&gt;?&lt;/code&gt; ）に置き換えられます。このパラメーターが空の文字列 &lt;code&gt;''&lt;/code&gt; （デフォルト）に設定されている場合、名前は表示されません。このパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="0be2813c09731c2a742fdb24fc852c07e13e3ed7" translate="yes" xml:space="preserve">
          <source>The name of a &lt;code&gt;table_name&lt;/code&gt; column. Used to infer arbiter indexes. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format. &lt;code&gt;SELECT&lt;/code&gt; privilege on &lt;code&gt;index_column_name&lt;/code&gt; is required.</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; 列の名前。アービターインデックスを推測するために使用されます。 &lt;code&gt;CREATE INDEX&lt;/code&gt; 形式に従います。 &lt;code&gt;index_column_name&lt;/code&gt; に対する &lt;code&gt;SELECT&lt;/code&gt; 特権が必要です。</target>
        </trans-unit>
        <trans-unit id="347e4a2b8b46492f607cf8e79afee93d1d470e6b" translate="yes" xml:space="preserve">
          <source>The name of a b-tree operator class for the subtype.</source>
          <target state="translated">サブタイプのb-tree演算子クラスの名前。</target>
        </trans-unit>
        <trans-unit id="3e4c963309e1915e51f2989fadcd94d4d9264511" translate="yes" xml:space="preserve">
          <source>The name of a column in the new materialized view. If column names are not provided, they are taken from the output column names of the query.</source>
          <target state="translated">新しいマテリアライズされたビューのカラム名。カラム名を指定しない場合は、クエリの出力カラム名から取得します。</target>
        </trans-unit>
        <trans-unit id="38a996c1d10563af1a139319a2d1ffd30fc57281" translate="yes" xml:space="preserve">
          <source>The name of a column in the new table. If column names are not provided, they are taken from the output column names of the query.</source>
          <target state="translated">新しいテーブルのカラム名。カラム名が指定されていない場合は、クエリの出力カラム名から取得されます。</target>
        </trans-unit>
        <trans-unit id="88674d0aca3396b42507d5f644ff534993edea22" translate="yes" xml:space="preserve">
          <source>The name of a column in the table named by &lt;code&gt;table_name&lt;/code&gt;. The column name can be qualified with a subfield name or array subscript, if needed. (Inserting into only some fields of a composite column leaves the other fields null.) When referencing a column with &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt;, do not include the table's name in the specification of a target column. For example, &lt;code&gt;INSERT INTO table_name ... ON CONFLICT DO UPDATE SET table_name.col = 1&lt;/code&gt; is invalid (this follows the general behavior for &lt;code&gt;UPDATE&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; で指定されたテーブル内の列の名前。列名は、必要に応じて、サブフィールド名または配列添え字で修飾できます。 （複合列の一部のフィールドにのみ挿入すると、他のフィールドはnullのままになります。） &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; で列を参照するときは、ターゲット列の指定にテーブルの名前を含めないでください。たとえば、 &lt;code&gt;INSERT INTO table_name ... ON CONFLICT DO UPDATE SET table_name.col = 1&lt;/code&gt; は無効です（これは &lt;code&gt;UPDATE&lt;/code&gt; の一般的な動作に従います）。</target>
        </trans-unit>
        <trans-unit id="37965fca46dac2ae8978b3ba3784bd4c0e6d710a" translate="yes" xml:space="preserve">
          <source>The name of a column in the table named by &lt;code&gt;table_name&lt;/code&gt;. The column name can be qualified with a subfield name or array subscript, if needed. Do not include the table's name in the specification of a target column &amp;mdash; for example, &lt;code&gt;UPDATE table_name SET table_name.col = 1&lt;/code&gt; is invalid.</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; で指定されたテーブル内の列の名前。列名は、必要に応じて、サブフィールド名または配列添え字で修飾できます。ターゲット列の指定にテーブルの名前を含めないでください。たとえば、 &lt;code&gt;UPDATE table_name SET table_name.col = 1&lt;/code&gt; は無効です。</target>
        </trans-unit>
        <trans-unit id="43b0ac7767512f2c3828414a44343ffbdea05c48" translate="yes" xml:space="preserve">
          <source>The name of a column of the table.</source>
          <target state="translated">テーブルのカラム名。</target>
        </trans-unit>
        <trans-unit id="66eab6eba8b42b05c2deccc82d07f73f07802b19" translate="yes" xml:space="preserve">
          <source>The name of a column to be created in the new table.</source>
          <target state="translated">新しいテーブルに作成するカラムの名前。</target>
        </trans-unit>
        <trans-unit id="b107b21b5ebe28c88ce9e0df68fea5f76d67283a" translate="yes" xml:space="preserve">
          <source>The name of a database to create.</source>
          <target state="translated">作成するデータベースの名前。</target>
        </trans-unit>
        <trans-unit id="2836c4dd7800c0b2de8f3f3ed8ae3591f1a8fd6b" translate="yes" xml:space="preserve">
          <source>The name of a difference function for the subtype.</source>
          <target state="translated">サブタイプの差分関数の名前です。</target>
        </trans-unit>
        <trans-unit id="cc2b3b4a893c2c09d0bead8670c584d57f2b3d8a" translate="yes" xml:space="preserve">
          <source>The name of a function that converts an array of modifier(s) for the type into internal form.</source>
          <target state="translated">型の修飾子の配列を内部形式に変換する関数の名前です。</target>
        </trans-unit>
        <trans-unit id="9cfae7f4211e6fa9e0eeadb788b0238e1401f532" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's external binary form to its internal form.</source>
          <target state="translated">型の外部バイナリ形式から内部形式にデータを変換する関数の名前です。</target>
        </trans-unit>
        <trans-unit id="b8ec9150353430f953f8a2508fb1cc00d06ec3ad" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's external textual form to its internal form.</source>
          <target state="translated">型の外部テキスト形式から内部形式にデータを変換する関数の名前です。</target>
        </trans-unit>
        <trans-unit id="e45bf619f83208134b19be3fe39ffa394657e429" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's internal form to its external binary form.</source>
          <target state="translated">型の内部形式から外部バイナリ形式にデータを変換する関数の名前です。</target>
        </trans-unit>
        <trans-unit id="ec568fe6711779cbc4fe49c405863a46d77641d0" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's internal form to its external textual form.</source>
          <target state="translated">型の内部形式から外部テキスト形式にデータを変換する関数の名前です。</target>
        </trans-unit>
        <trans-unit id="a4232581838ec7343a99a8c7be95b2e49c198605" translate="yes" xml:space="preserve">
          <source>The name of a function that converts the internal form of the type's modifier(s) to external textual form.</source>
          <target state="translated">型の修飾子の内部形式を外部テキスト形式に変換する関数の名前です。</target>
        </trans-unit>
        <trans-unit id="4ebc5121bc2fa18e076b2f1de0b2de537a76ba61" translate="yes" xml:space="preserve">
          <source>The name of a function that performs statistical analysis for the data type.</source>
          <target state="translated">データ型の統計解析を行う関数の名前です。</target>
        </trans-unit>
        <trans-unit id="8693551fac54570d94fac46289d20bd3cbf6ee4e" translate="yes" xml:space="preserve">
          <source>The name of a function, procedure, or aggregate argument. Note that &lt;code&gt;ALTER EXTENSION&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">関数、プロシージャ、または集約引数の名前。関数のIDを決定するために必要なのは引数のデータ型だけなので、 &lt;code&gt;ALTER EXTENSION&lt;/code&gt; は実際には引数名に注意を払わないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="6fe30dcb3f4583c58770f03da94374abd82c96ab" translate="yes" xml:space="preserve">
          <source>The name of a function, procedure, or aggregate argument. Note that &lt;code&gt;COMMENT&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">関数、プロシージャ、または集約引数の名前。関数のIDを決定するために必要なのは引数のデータ型だけなので、 &lt;code&gt;COMMENT&lt;/code&gt; は実際には引数名に注意を払わないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="037ed7ab4666d9436acdd62556426330fa27de4d" translate="yes" xml:space="preserve">
          <source>The name of a function, procedure, or aggregate argument. Note that &lt;code&gt;SECURITY LABEL&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">関数、プロシージャ、または集約引数の名前。関数のIDを決定するために必要なのは引数のデータ型だけなので、 &lt;code&gt;SECURITY LABEL&lt;/code&gt; は実際には引数の名前に注意を払わないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="85d26a05a8c2a48486d4d983a4308017ec19fa06" translate="yes" xml:space="preserve">
          <source>The name of a role whose objects will be dropped, and whose privileges will be revoked.</source>
          <target state="translated">オブジェクトが削除され、その権限が取り消されるロールの名前です。</target>
        </trans-unit>
        <trans-unit id="2d651ee55d17fde141e789374afa64231439951d" translate="yes" xml:space="preserve">
          <source>The name of a role. The ownership of all the objects within the current database, and of all shared objects (databases, tablespaces), owned by this role will be reassigned to &lt;code&gt;new_role&lt;/code&gt;.</source>
          <target state="translated">役割の名前。現在のデータベース内のすべてのオブジェクトの所有権、およびこのロールが所有するすべての共有オブジェクト（データベース、テーブルスペース）の所有権は、 &lt;code&gt;new_role&lt;/code&gt; に再割り当てされます。</target>
        </trans-unit>
        <trans-unit id="a41f912a967bc6187a0ff565790395916fca2f2a" translate="yes" xml:space="preserve">
          <source>The name of a rule to create. This must be distinct from the name of any other rule for the same table. Multiple rules on the same table and same event type are applied in alphabetical name order.</source>
          <target state="translated">作成するルールの名前。これは、同じテーブルの他のルールの名前とは区別する必要があります。同じテーブルで同じイベントタイプの複数のルールは、アルファベット順に適用されます。</target>
        </trans-unit>
        <trans-unit id="16dbd653daa2713c731e96ec7016300d7b0623c9" translate="yes" xml:space="preserve">
          <source>The name of a run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page. In addition, there are a few parameters that can be shown but not set:</source>
          <target state="translated">実行時パラメータの名前。使用可能なパラメーターは、&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章&lt;/a&gt;と&lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt;リファレンスページに記載されています。さらに、表示されても設定されないいくつかのパラメーターがあります。</target>
        </trans-unit>
        <trans-unit id="fdb5b09a2e8ba40ee029ef0bb0deb2b715d29f64" translate="yes" xml:space="preserve">
          <source>The name of a schema to be created. If this is omitted, the &lt;code&gt;user_name&lt;/code&gt; is used as the schema name. The name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system schemas.</source>
          <target state="translated">作成するスキーマの名前。これを省略すると、 &lt;code&gt;user_name&lt;/code&gt; がスキーマ名として使用されます。この名前はシステムスキーマ用に予約されているため、名前を &lt;code&gt;pg_&lt;/code&gt; で始めることはできません。</target>
        </trans-unit>
        <trans-unit id="19552fb60b57524fdf3c4ba971f713deaf575934" translate="yes" xml:space="preserve">
          <source>The name of a schema.</source>
          <target state="translated">スキーマの名前です。</target>
        </trans-unit>
        <trans-unit id="bec37b1bb0aae7199fe140e94c49fd869d890cc2" translate="yes" xml:space="preserve">
          <source>The name of a specific column to analyze. Defaults to all columns.</source>
          <target state="translated">分析する特定のカラムの名前。デフォルトはすべてのカラムです。</target>
        </trans-unit>
        <trans-unit id="f4dd69da6250801b1a99f96f4fc7a1fc3fc7a5ca" translate="yes" xml:space="preserve">
          <source>The name of a specific column to analyze. Defaults to all columns. If a column list is specified, &lt;code&gt;ANALYZE&lt;/code&gt; must also be specified.</source>
          <target state="translated">分析する特定の列の名前。デフォルトはすべての列です。列リストを指定する場合は、 &lt;code&gt;ANALYZE&lt;/code&gt; も指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="4d277ce7dc1369544c960227202849bca34e3070" translate="yes" xml:space="preserve">
          <source>The name of a standby server for this purpose is the &lt;code&gt;application_name&lt;/code&gt; setting of the standby, as set in the standby's connection information. In case of a physical replication standby, this should be set in the &lt;code&gt;primary_conninfo&lt;/code&gt; setting; the default is the setting of &lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;cluster_name&lt;/a&gt; if set, else &lt;code&gt;walreceiver&lt;/code&gt;. For logical replication, this can be set in the connection information of the subscription, and it defaults to the subscription name. For other replication stream consumers, consult their documentation.</source>
          <target state="translated">この目的でのスタンバイサーバーの名前は、スタンバイの接続情報に設定されている、スタンバイの &lt;code&gt;application_name&lt;/code&gt; 設定です。物理レプリケーションスタンバイの場合、これは &lt;code&gt;primary_conninfo&lt;/code&gt; 設定で設定する必要があります。デフォルトは、設定されている場合は&lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;cluster_nameの&lt;/a&gt;設定、それ以外の場合は &lt;code&gt;walreceiver&lt;/code&gt; です。論理レプリケーションの場合、これはサブスクリプションの接続情報で設定でき、デフォルトでサブスクリプション名になります。その他のレプリケーションストリームコンシューマについては、ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="c8bcdb2c75dca6dff745c6b72d3eafa935add170" translate="yes" xml:space="preserve">
          <source>The name of a subscription to be dropped.</source>
          <target state="translated">落とす定期購読の名前です。</target>
        </trans-unit>
        <trans-unit id="10c04b3f0b50c7a796c21e054204f49c5305809f" translate="yes" xml:space="preserve">
          <source>The name of a subscription whose properties are to be altered.</source>
          <target state="translated">プロパティが変更されるサブスクリプションの名前。</target>
        </trans-unit>
        <trans-unit id="a917fa888db788a84ebf308d993302ba69b3956f" translate="yes" xml:space="preserve">
          <source>The name of a table column to be covered by the computed statistics. At least two column names must be given; the order of the column names is insignificant.</source>
          <target state="translated">計算された統計量の対象となる表の列の名前。少なくとも2つの列名を指定しなければなりません;列名の順序は重要ではありません。</target>
        </trans-unit>
        <trans-unit id="547022940eaa9d3307e6377842b21fffa3dea285" translate="yes" xml:space="preserve">
          <source>The name of a table storage parameter.</source>
          <target state="translated">テーブルストレージパラメータの名前です。</target>
        </trans-unit>
        <trans-unit id="25f3d061a48202d36e2eddaaf0e7e422750642c9" translate="yes" xml:space="preserve">
          <source>The name of a tablespace to be created. The name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system tablespaces.</source>
          <target state="translated">作成するテーブルスペースの名前。この名前はシステムテーブルスペース用に予約されているため、名前を &lt;code&gt;pg_&lt;/code&gt; で始めることはできません。</target>
        </trans-unit>
        <trans-unit id="f526639651b0458136ca498c2f2f2ac4fbd6800d" translate="yes" xml:space="preserve">
          <source>The name of a tablespace.</source>
          <target state="translated">テーブルスペースの名前。</target>
        </trans-unit>
        <trans-unit id="3f86890bb22a9b09c6fb6202e966b0cb90e86399" translate="yes" xml:space="preserve">
          <source>The name of a template-specific option to be set for this dictionary.</source>
          <target state="translated">この辞書に設定するテンプレート固有のオプションの名前。</target>
        </trans-unit>
        <trans-unit id="d2fc4bb5096ba459cde4afbb76fdac536da62aa5" translate="yes" xml:space="preserve">
          <source>The name of a text search dictionary to be consulted for the specified token type(s). If multiple dictionaries are listed, they are consulted in the specified order.</source>
          <target state="translated">指定されたトークンタイプに対して参照するテキスト検索辞書の名前。複数の辞書がリストアップされている場合は、指定された順番で参照されます。</target>
        </trans-unit>
        <trans-unit id="b2ade2843219f0c75eecbdfb9ad26e157949ac15" translate="yes" xml:space="preserve">
          <source>The name of a text search dictionary to be replaced in the mapping.</source>
          <target state="translated">マッピングで置き換えるテキスト検索辞書の名前。</target>
        </trans-unit>
        <trans-unit id="c2e4d9635ee5eae77abbb98d0d04f44a7382134a" translate="yes" xml:space="preserve">
          <source>The name of a text search dictionary to be substituted for &lt;code&gt;old_dictionary&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;old_dictionary&lt;/code&gt; の代わりに使用するテキスト検索辞書の名前。</target>
        </trans-unit>
        <trans-unit id="e536a7c03f29f8cbc17f3a583238f110ae4c9ca6" translate="yes" xml:space="preserve">
          <source>The name of a token type that is emitted by the configuration's parser.</source>
          <target state="translated">設定のパーサから出力されるトークン型の名前です。</target>
        </trans-unit>
        <trans-unit id="e42ab0f9b2f16ce7c6531f791e195b576f9b5e7b" translate="yes" xml:space="preserve">
          <source>The name of a variable used to filter events. This makes it possible to restrict the firing of the trigger to a subset of the cases in which it is supported. Currently the only supported &lt;code&gt;filter_variable&lt;/code&gt; is &lt;code&gt;TAG&lt;/code&gt;.</source>
          <target state="translated">イベントのフィルタリングに使用される変数の名前。これにより、トリガーの起動を、トリガーがサポートされるケースのサブセットに制限できます。現在サポートされている &lt;code&gt;filter_variable&lt;/code&gt; は &lt;code&gt;TAG&lt;/code&gt; のみです。</target>
        </trans-unit>
        <trans-unit id="cbbf80f6f4c468a122711e341fba3efb95ed9b4e" translate="yes" xml:space="preserve">
          <source>The name of an argument.</source>
          <target state="translated">引数の名前です。</target>
        </trans-unit>
        <trans-unit id="e982fa6e95b8aff320484711c377b6849476a259" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the aggregate function's identity.</source>
          <target state="translated">引数の名前。集約関数のIDを決定するために必要なのは引数のデータ型だけなので、 &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; は実際には引数名に注意を払わないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="56b0baceffec189e51468368e1573f50c02b2801" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;ALTER FUNCTION&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">引数の名前。関数のIDを決定するために必要なのは引数のデータ型だけなので、 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; は実際には引数名に注意を払わないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="da880762c1ed4640b76217347360561ae983a357" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the procedure's identity.</source>
          <target state="translated">引数の名前。プロシージャのIDを決定するために必要なのは引数のデータ型だけなので、 &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; は実際には引数名に注意を払わないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="0681d59ee9000bab536592eb7b8ddac88b06215c" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;DROP AGGREGATE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the aggregate function's identity.</source>
          <target state="translated">引数の名前。集約関数のIDを判別するために必要なのは引数のデータ型だけなので、 &lt;code&gt;DROP AGGREGATE&lt;/code&gt; は実際には引数名に注意を払わないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="5f97c790620d0347b2dc1f2b503ffe310415155c" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;DROP FUNCTION&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">引数の名前。関数のIDを決定するために必要なのは引数のデータ型だけなので、 &lt;code&gt;DROP FUNCTION&lt;/code&gt; は実際には引数名に注意を払わないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="75484c7635e6405e3d0e3238f7f514ab40e45aaa" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;DROP PROCEDURE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the procedure's identity.</source>
          <target state="translated">引数の名前。ことを注意 &lt;code&gt;DROP PROCEDURE&lt;/code&gt; は、唯一の引数のデータ型が手続きの同一性を決定するために必要ですので、実際に、引数名に注意を払っていません。</target>
        </trans-unit>
        <trans-unit id="6264b5b03c956e34b1a101cf23f2e7ebcfb44a8b" translate="yes" xml:space="preserve">
          <source>The name of an argument. Some languages (including SQL and PL/pgSQL) let you use the name in the function body. For other languages the name of an input argument is just extra documentation, so far as the function itself is concerned; but you can use input argument names when calling a function to improve readability (see &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Section 4.3&lt;/a&gt;). In any case, the name of an output argument is significant, because it defines the column name in the result row type. (If you omit the name for an output argument, the system will choose a default column name.)</source>
          <target state="translated">引数の名前。一部の言語（SQLおよびPL / pgSQLを含む）では、関数本体で名前を使用できます。他の言語の場合、関数自体に関する限り、入力引数の名前は単なる追加のドキュメントです。ただし、読みやすくするために関数を呼び出すときに入力引数名を使用できます（&lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;セクション4.3を&lt;/a&gt;参照）。いずれにせよ、出力引数の名前は、結果の行タイプで列名を定義するため、重要です。（出力引数の名前を省略すると、システムはデフォルトの列名を選択します。）</target>
        </trans-unit>
        <trans-unit id="375094d89a9e7c5813b8961536891f0759815217" translate="yes" xml:space="preserve">
          <source>The name of an argument. This is currently only useful for documentation purposes. If omitted, the argument has no name.</source>
          <target state="translated">引数の名前。これは現在のところ、文書化の目的でのみ有用です。省略された場合、引数には名前がありません。</target>
        </trans-unit>
        <trans-unit id="ed524d1ea7eb8aeebc2ae58ea9eeac500ae4de68" translate="yes" xml:space="preserve">
          <source>The name of an attribute (column) for the composite type.</source>
          <target state="translated">複合型の属性(列)の名前。</target>
        </trans-unit>
        <trans-unit id="6a17e927a8bc128615b789bf21656b4af0a59747" translate="yes" xml:space="preserve">
          <source>The name of an existing access method.</source>
          <target state="translated">既存のアクセスメソッドの名前です。</target>
        </trans-unit>
        <trans-unit id="ebcda1893633e936b520a2a0321ab231b1b0ba97" translate="yes" xml:space="preserve">
          <source>The name of an existing collation to be associated with a column of a composite type, or with a range type.</source>
          <target state="translated">複合型のカラム、または範囲型のカラムに関連付けられる既存の照合順序の名前。</target>
        </trans-unit>
        <trans-unit id="6a99a7164db5effbf0ea0eafd9c39dd9aa197443" translate="yes" xml:space="preserve">
          <source>The name of an existing collation to copy. The new collation will have the same properties as the existing one, but it will be an independent object.</source>
          <target state="translated">コピーする既存の照合順序の名前。新しい照合順序は既存のものと同じプロパティを持ちますが、独立したオブジェクトになります。</target>
        </trans-unit>
        <trans-unit id="af62875da4376911af8fd6633488eb76e3df9aa2" translate="yes" xml:space="preserve">
          <source>The name of an existing data type that the new type will have the same representation as. The values of &lt;code&gt;internallength&lt;/code&gt;, &lt;code&gt;passedbyvalue&lt;/code&gt;, &lt;code&gt;alignment&lt;/code&gt;, and &lt;code&gt;storage&lt;/code&gt; are copied from that type, unless overridden by explicit specification elsewhere in this &lt;code&gt;CREATE TYPE&lt;/code&gt; command.</source>
          <target state="translated">新しいタイプが同じ表現を持つ既存のデータタイプの名前。 &lt;code&gt;internallength&lt;/code&gt; 、 &lt;code&gt;passedbyvalue&lt;/code&gt; 、 &lt;code&gt;alignment&lt;/code&gt; 、および &lt;code&gt;storage&lt;/code&gt; の値は、この &lt;code&gt;CREATE TYPE&lt;/code&gt; コマンドのどこかで明示的に指定されてオーバーライドされない限り、そのタイプからコピーされます。</target>
        </trans-unit>
        <trans-unit id="269f93ea4a18405eca9d42f3c25429fa59f4bc3d" translate="yes" xml:space="preserve">
          <source>The name of an existing data type to become a column of the composite type.</source>
          <target state="translated">複合型のカラムになる既存のデータ型の名前。</target>
        </trans-unit>
        <trans-unit id="9a63f99fdd0bce011ca8d049908cd4539b298e7c" translate="yes" xml:space="preserve">
          <source>The name of an existing foreign server to use for the foreign table. For details on defining a server, see &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;.</source>
          <target state="translated">外部テーブルに使用する既存の外部サーバーの名前。サーバーの定義の詳細については、「&lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="f2454ed01e6d27ce51d6d152286d9f4044a0971f" translate="yes" xml:space="preserve">
          <source>The name of an existing foreign-data wrapper.</source>
          <target state="translated">既存の外部データラッパーの名前。</target>
        </trans-unit>
        <trans-unit id="215bb96ed8aefedc59bc2785aaa4809857f9f3b1" translate="yes" xml:space="preserve">
          <source>The name of an existing index.</source>
          <target state="translated">既存のインデックスの名前。</target>
        </trans-unit>
        <trans-unit id="dcfd6d7a1b6a134c08f28bb84b429370f63f9bf9" translate="yes" xml:space="preserve">
          <source>The name of an existing policy to alter.</source>
          <target state="translated">変更する既存のポリシーの名前です。</target>
        </trans-unit>
        <trans-unit id="d3e43edda0ed2c669ea64ea4de1cacab37227192" translate="yes" xml:space="preserve">
          <source>The name of an existing procedural language. For backward compatibility, the name can be enclosed by single quotes.</source>
          <target state="translated">既存の手続き型言語の名前。後方互換性のため、名前はシングルクォーテーションで囲むことができます。</target>
        </trans-unit>
        <trans-unit id="dbc811803ec9f6996f00764f5d9b3a696bbe0492" translate="yes" xml:space="preserve">
          <source>The name of an existing publication whose definition is to be altered.</source>
          <target state="translated">定義を変更する既存の出版物の名前。</target>
        </trans-unit>
        <trans-unit id="e43f43145062802662e910809c0dbf5106a36151" translate="yes" xml:space="preserve">
          <source>The name of an existing publication.</source>
          <target state="translated">既存の出版物の名前。</target>
        </trans-unit>
        <trans-unit id="51d243f6e89c7e39326aaa5f0f4dbaf017f84cd3" translate="yes" xml:space="preserve">
          <source>The name of an existing role of which the current role is a member. If &lt;code&gt;FOR ROLE&lt;/code&gt; is omitted, the current role is assumed.</source>
          <target state="translated">現在の役割がメンバーになっている既存の役割の名前。場合 &lt;code&gt;FOR ROLE&lt;/code&gt; 省略され、現在の役割が想定されます。</target>
        </trans-unit>
        <trans-unit id="55490c4e62932d1546a037c62cdff84638b0e3d3" translate="yes" xml:space="preserve">
          <source>The name of an existing role to grant or revoke privileges for. This parameter, and all the other parameters in &lt;code&gt;abbreviated_grant_or_revoke&lt;/code&gt;, act as described under &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; or &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;, except that one is setting permissions for a whole class of objects rather than specific named objects.</source>
          <target state="translated">権限を付与または取り消す既存のロールの名前。このパラメーター、および &lt;code&gt;abbreviated_grant_or_revoke&lt;/code&gt; の他のすべてのパラメーターは、&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;または&lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;で説明されているとおりに機能します。ただし、特定の名前付きオブジェクトではなく、オブジェクトのクラス全体にアクセス許可を設定します。</target>
        </trans-unit>
        <trans-unit id="c635ecbb1c53d1706cdab235bd6da7bb6c713113" translate="yes" xml:space="preserve">
          <source>The name of an existing rule to alter.</source>
          <target state="translated">変更する既存のルールの名前。</target>
        </trans-unit>
        <trans-unit id="313ea254effb62079628babb9fa1cbd9eaa5bbb0" translate="yes" xml:space="preserve">
          <source>The name of an existing schema.</source>
          <target state="translated">既存のスキーマの名前。</target>
        </trans-unit>
        <trans-unit id="cc48699243fdc0b302f46f2ff91dbd816b03aa4b" translate="yes" xml:space="preserve">
          <source>The name of an existing schema. If specified, the default privileges are altered for objects later created in that schema. If &lt;code&gt;IN SCHEMA&lt;/code&gt; is omitted, the global default privileges are altered. &lt;code&gt;IN SCHEMA&lt;/code&gt; is not allowed when using &lt;code&gt;ON SCHEMAS&lt;/code&gt; as schemas can't be nested.</source>
          <target state="translated">既存のスキーマの名前。指定した場合、そのスキーマで後で作成されるオブジェクトのデフォルト特権が変更されます。場合は &lt;code&gt;IN SCHEMA&lt;/code&gt; 省略され、グローバルなデフォルト権限が変更されています。 &lt;code&gt;ON SCHEMAS&lt;/code&gt; を使用する場合、スキーマはネストできないため、 &lt;code&gt;IN SCHEMA&lt;/code&gt; は許可されません。</target>
        </trans-unit>
        <trans-unit id="02ea513b553c81e6e8bfffc28bfc183407ce6f92" translate="yes" xml:space="preserve">
          <source>The name of an existing server for which the user mapping is to be created.</source>
          <target state="translated">ユーザー マッピングを作成する既存のサーバーの名前です。</target>
        </trans-unit>
        <trans-unit id="94ab6bc9007ffe24527bb571f8caf6972fd6e32c" translate="yes" xml:space="preserve">
          <source>The name of an existing server.</source>
          <target state="translated">既存のサーバーの名前です。</target>
        </trans-unit>
        <trans-unit id="7b99635b20ef9c6fbf704b3d5683df0c76ea50a5" translate="yes" xml:space="preserve">
          <source>The name of an existing tablespace.</source>
          <target state="translated">既存のテーブルスペースの名前。</target>
        </trans-unit>
        <trans-unit id="1fba9536f8e094817879340972f3fc186e59ac3a" translate="yes" xml:space="preserve">
          <source>The name of an existing text search configuration to copy.</source>
          <target state="translated">コピーする既存のテキスト検索設定の名前。</target>
        </trans-unit>
        <trans-unit id="e62d3905f77c5380a51ef346837f8bb973da087a" translate="yes" xml:space="preserve">
          <source>The name of an existing trigger to alter.</source>
          <target state="translated">変更する既存のトリガーの名前。</target>
        </trans-unit>
        <trans-unit id="39eaed243c343dcf7cbdeda1eb27256bd699e984" translate="yes" xml:space="preserve">
          <source>The name of an existing user that is mapped to foreign server. &lt;code&gt;CURRENT_USER&lt;/code&gt; and &lt;code&gt;USER&lt;/code&gt; match the name of the current user. When &lt;code&gt;PUBLIC&lt;/code&gt; is specified, a so-called public mapping is created that is used when no user-specific mapping is applicable.</source>
          <target state="translated">外部サーバーにマップされている既存のユーザーの名前。 &lt;code&gt;CURRENT_USER&lt;/code&gt; および &lt;code&gt;USER&lt;/code&gt; は、現在のユーザーの名前と一致します。とき &lt;code&gt;PUBLIC&lt;/code&gt; が指定されている、いわゆる公共のマッピングには、ユーザ固有のマッピングが適用されない場合に使用されているが作成されます。</target>
        </trans-unit>
        <trans-unit id="7ff3e30c52fed6a21d64c778f1c3cb5bfde69e2e" translate="yes" xml:space="preserve">
          <source>The name of an index-method-specific storage parameter.</source>
          <target state="translated">インデックス・メソッド固有のストレージ・パラメータの名前。</target>
        </trans-unit>
        <trans-unit id="094d120f87047ccaf9df626ee5c7800b9676897f" translate="yes" xml:space="preserve">
          <source>The name of an index-method-specific storage parameter. See &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-STORAGE-PARAMETERS&quot;&gt;Index Storage Parameters&lt;/a&gt; for details.</source>
          <target state="translated">インデックスメソッド固有の格納パラメーターの名前。詳細については、&lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-STORAGE-PARAMETERS&quot;&gt;インデックスストレージパラメータ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b4f0f37a4747ead833ac927d954e2f698dfd533d" translate="yes" xml:space="preserve">
          <source>The name of an index.</source>
          <target state="translated">インデックスの名前。</target>
        </trans-unit>
        <trans-unit id="905bf1ebfe51e20690887bb37e5649f46c622ebf" translate="yes" xml:space="preserve">
          <source>The name of an installed extension.</source>
          <target state="translated">インストールされている拡張機能の名前。</target>
        </trans-unit>
        <trans-unit id="31791bd4a497bca0b376ada0235a5c621eadda59" translate="yes" xml:space="preserve">
          <source>The name of an object to be added to or removed from the extension. Names of tables, aggregates, domains, foreign tables, functions, operators, operator classes, operator families, procedures, routines, sequences, text search objects, types, and views can be schema-qualified.</source>
          <target state="translated">拡張機能に追加または削除するオブジェクトの名前。テーブル、集約、ドメイン、外部テーブル、関数、演算子、演算子クラス、演算子ファミリー、プロシージャ、ルーチン、シーケンス、テキスト検索オブジェクト、型、およびビューの名前をスキーマ修飾することができます。</target>
        </trans-unit>
        <trans-unit id="649c7c5351f25263eb73a851a860d7f29c995641" translate="yes" xml:space="preserve">
          <source>The name of an open cursor to close.</source>
          <target state="translated">閉じるオープンカーソルの名前。</target>
        </trans-unit>
        <trans-unit id="8b92d299708f5e6b56970b9d25ff76f34c8756f5" translate="yes" xml:space="preserve">
          <source>The name of an operator class. See below for details.</source>
          <target state="translated">演算子クラスの名前です。詳細は以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="4bf28d916074af135f4ae230a1fccbd417f00476" translate="yes" xml:space="preserve">
          <source>The name of an output column in the &lt;code&gt;RETURNS TABLE&lt;/code&gt; syntax. This is effectively another way of declaring a named &lt;code&gt;OUT&lt;/code&gt; parameter, except that &lt;code&gt;RETURNS TABLE&lt;/code&gt; also implies &lt;code&gt;RETURNS SETOF&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RETURNS TABLE&lt;/code&gt; 構文の出力列の名前。これは事実上、名前付き &lt;code&gt;OUT&lt;/code&gt; パラメータを宣言するもう1つの方法ですが、 &lt;code&gt;RETURNS TABLE&lt;/code&gt; は &lt;code&gt;RETURNS SETOF&lt;/code&gt; も暗黙的に指定します。</target>
        </trans-unit>
        <trans-unit id="7860b7ca240f288c9e09edb9a6f18857751787c5" translate="yes" xml:space="preserve">
          <source>The name of next WAL segment file should be larger than any WAL segment file name currently existing in the directory &lt;code&gt;pg_wal&lt;/code&gt; under the data directory. These names are also in hexadecimal and have three parts. The first part is the &amp;ldquo;timeline ID&amp;rdquo; and should usually be kept the same. For example, if &lt;code&gt;00000001000000320000004A&lt;/code&gt; is the largest entry in &lt;code&gt;pg_wal&lt;/code&gt;, use &lt;code&gt;-l 00000001000000320000004B&lt;/code&gt; or higher.</source>
          <target state="translated">次のWALセグメントファイルの名前は、データディレクトリの下の &lt;code&gt;pg_wal&lt;/code&gt; ディレクトリに現在存在するWALセグメントファイル名よりも大きくする必要があります。これらの名前も16進数で、3つの部分に分かれています。最初の部分は「タイムラインID」であり、通常は同じに保つ必要があります。たとえば、 &lt;code&gt;00000001000000320000004A&lt;/code&gt; が &lt;code&gt;pg_wal&lt;/code&gt; の最大のエントリである場合、 &lt;code&gt;-l 00000001000000320000004B&lt;/code&gt; 以上を使用します。</target>
        </trans-unit>
        <trans-unit id="d8e7a2287904ed813d9d1d342dd594453e6a492a" translate="yes" xml:space="preserve">
          <source>The name of the access method to be created.</source>
          <target state="translated">作成するアクセスメソッドの名前です。</target>
        </trans-unit>
        <trans-unit id="a1d2d753926a3554219bc61e5340b3472157868a" translate="yes" xml:space="preserve">
          <source>The name of the attribute to add, alter, or drop.</source>
          <target state="translated">追加、変更、または削除する属性の名前。</target>
        </trans-unit>
        <trans-unit id="5c7d389a37d0c9ede9dd1bea0952aff86a55c92e" translate="yes" xml:space="preserve">
          <source>The name of the canonicalization function for the range type.</source>
          <target state="translated">範囲型の正規化関数の名前です。</target>
        </trans-unit>
        <trans-unit id="243c7e9e7dd348f6643caec550e3f500eb8cc280" translate="yes" xml:space="preserve">
          <source>The name of the collation to use for the index. By default, the index uses the collation declared for the column to be indexed or the result collation of the expression to be indexed. Indexes with non-default collations can be useful for queries that involve expressions using non-default collations.</source>
          <target state="translated">インデックスに使用する照合順序の名前。デフォルトでは、インデックスはインデックスを作成する列に対して宣言された照合順序、またはインデックスを作成する式の結果の照合順序を使用します。デフォルト以外の照合順序を持つインデックスは、デフォルト以外の照合順序を使用する式を含む問い合わせに便利です。</target>
        </trans-unit>
        <trans-unit id="77f1c321d574cf562cfe00eca4e768698060a618" translate="yes" xml:space="preserve">
          <source>The name of the collation. The collation name can be schema-qualified.</source>
          <target state="translated">照合の名前。照合順序の名前はスキーマで修飾することができます。</target>
        </trans-unit>
        <trans-unit id="ceb886814d1ec273ae0613d250c7095ff800d469" translate="yes" xml:space="preserve">
          <source>The name of the collation. The collation name can be schema-qualified. If it is not, the collation is defined in the current schema. The collation name must be unique within that schema. (The system catalogs can contain collations with the same name for other encodings, but these are ignored if the database encoding does not match.)</source>
          <target state="translated">照合の名前。照合順序の名前はスキーマで修飾することができます。スキーマ修飾されていない場合、照合順序は現在のスキーマで定義されます。照合順序名はスキーマ内で一意でなければなりません。(システムカタログには、他のエンコーディングと同じ名前の照合順序を含めることができますが、データベースのエンコーディングが一致しない場合は無視されます)</target>
        </trans-unit>
        <trans-unit id="9f63d4696a4bbfab6f19c7c4c3231039f6a920b8" translate="yes" xml:space="preserve">
          <source>The name of the conversion. The conversion name can be schema-qualified.</source>
          <target state="translated">変換の名前です。変換名はスキーマで修飾することができます。</target>
        </trans-unit>
        <trans-unit id="0a0e15e0eec7998677fce35d40af5b0838f2cb6f" translate="yes" xml:space="preserve">
          <source>The name of the conversion. The conversion name can be schema-qualified. If it is not, the conversion is defined in the current schema. The conversion name must be unique within a schema.</source>
          <target state="translated">変換の名前です。変換名はスキーマ修飾されていることがあります。そうでない場合、変換は現在のスキーマで定義されます。変換名はスキーマ内で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="c9574a7a1218329dadec3b5ae9047230517d66aa" translate="yes" xml:space="preserve">
          <source>The name of the current database.</source>
          <target state="translated">現在のデータベースの名前。</target>
        </trans-unit>
        <trans-unit id="1d7349ab2501bed854162775079bf683be5a7fac" translate="yes" xml:space="preserve">
          <source>The name of the cursor</source>
          <target state="translated">カーソルの名前</target>
        </trans-unit>
        <trans-unit id="b6d5b083913d1c8495981451aeb22d6a26cea7b8" translate="yes" xml:space="preserve">
          <source>The name of the cursor to be created.</source>
          <target state="translated">作成するカーソルの名前。</target>
        </trans-unit>
        <trans-unit id="88e407c8ddef33e57e58fe4ab21cafbf53e15168" translate="yes" xml:space="preserve">
          <source>The name of the cursor to use in a &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; condition. The row to be deleted is the one most recently fetched from this cursor. The cursor must be a non-grouping query on the &lt;code&gt;DELETE&lt;/code&gt;'s target table. Note that &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; cannot be specified together with a Boolean condition. See &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; for more information about using cursors with &lt;code&gt;WHERE CURRENT OF&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 条件で使用するカーソルの名前。削除する行は、このカーソルから最後にフェッチされた行です。カーソルは、 &lt;code&gt;DELETE&lt;/code&gt; のターゲットテーブルに対する非グループ化クエリである必要があります。 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; はブール条件と一緒に指定できないことに注意してください。 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; でのカーソルの使用の詳細については、&lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="38020942de5ae8771a5e3d0b598b6d0ab023caec" translate="yes" xml:space="preserve">
          <source>The name of the cursor to use in a &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; condition. The row to be updated is the one most recently fetched from this cursor. The cursor must be a non-grouping query on the &lt;code&gt;UPDATE&lt;/code&gt;'s target table. Note that &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; cannot be specified together with a Boolean condition. See &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; for more information about using cursors with &lt;code&gt;WHERE CURRENT OF&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 条件で使用するカーソルの名前。更新される行は、このカーソルから最後にフェッチされた行です。カーソルは、 &lt;code&gt;UPDATE&lt;/code&gt; のターゲットテーブルの非グループ化クエリである必要があります。 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; はブール条件と一緒に指定できないことに注意してください。 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; でのカーソルの使用の詳細については、&lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a37403f5a4aea39da3b7fe089d21ee355979a3e1" translate="yes" xml:space="preserve">
          <source>The name of the data type of the transform.</source>
          <target state="translated">トランスフォームのデータ型の名前。</target>
        </trans-unit>
        <trans-unit id="af7361a3be8ca4eab2c0f2265411cfd60f5af420" translate="yes" xml:space="preserve">
          <source>The name of the database the configuration variable should be set in.</source>
          <target state="translated">設定変数が設定されるべきデータベースの名前です。</target>
        </trans-unit>
        <trans-unit id="84b00afcd962f475515c1915126400e90b5a9818" translate="yes" xml:space="preserve">
          <source>The name of the database this slot is associated with, or null. Only logical slots have an associated database.</source>
          <target state="translated">このスロットが関連付けられているデータベースの名前、またはnullです。論理スロットのみが関連付けられたデータベースを持ちます。</target>
        </trans-unit>
        <trans-unit id="2a89c928e3a93a0e913b45ef5c9ea96a08977f60" translate="yes" xml:space="preserve">
          <source>The name of the database to remove.</source>
          <target state="translated">削除するデータベースの名前。</target>
        </trans-unit>
        <trans-unit id="0fd3bf3f6aa3e86ff6150d84d8e17149c266ae35" translate="yes" xml:space="preserve">
          <source>The name of the database whose attributes are to be altered.</source>
          <target state="translated">属性を変更するデータベースの名前です。</target>
        </trans-unit>
        <trans-unit id="0944e5dfd14965f192e2a8ef7a09d183046338d3" translate="yes" xml:space="preserve">
          <source>The name of the database you are currently connected to. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">現在接続しているデータベースの名前です。これは、データベースに接続するたびに(プログラムの起動を含む)設定されますが、変更したり、設定を解除したりすることができます。</target>
        </trans-unit>
        <trans-unit id="11232ebb2f1cf69c5f3c6cd470c6a4d13d479f8e" translate="yes" xml:space="preserve">
          <source>The name of the element type that the range type will represent ranges of.</source>
          <target state="translated">範囲型が範囲を表す要素型の名前です。</target>
        </trans-unit>
        <trans-unit id="2c439c06e3cc89c7e2b7094efdc072f8eaa5f405" translate="yes" xml:space="preserve">
          <source>The name of the end function for the parser.</source>
          <target state="translated">パーサーの終了関数の名前です。</target>
        </trans-unit>
        <trans-unit id="4682e028a8481b8dc70802bb5909c69f9733e336" translate="yes" xml:space="preserve">
          <source>The name of the event that triggers a call to the given function. See &lt;a href=&quot;https://www.postgresql.org/docs/12/event-trigger-definition.html&quot;&gt;Section 39.1&lt;/a&gt; for more information on event names.</source>
          <target state="translated">指定された関数の呼び出しをトリガーするイベントの名前。イベント名の詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/event-trigger-definition.html&quot;&gt;セクション39.1&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="28c26a8cf1a6172d4db73edd5254e5a34f8a5967" translate="yes" xml:space="preserve">
          <source>The name of the event trigger to remove.</source>
          <target state="translated">削除するイベントトリガーの名前。</target>
        </trans-unit>
        <trans-unit id="850574c01fb5268b0342a8b6bb42720569d55e9d" translate="yes" xml:space="preserve">
          <source>The name of the existing operator family to add this operator class to. If not specified, a family named the same as the operator class is used (creating it, if it doesn't already exist).</source>
          <target state="translated">この演算子クラスを追加する既存の演算子ファミリーの名前。指定しない場合は、演算子クラスと同じ名前のファミリが使用されます (既に存在しない場合は作成されます)。</target>
        </trans-unit>
        <trans-unit id="e1cc11f5fc0531b3a520c5755578268d661fb876" translate="yes" xml:space="preserve">
          <source>The name of the extension that the function is to depend on.</source>
          <target state="translated">関数が依存する拡張子の名前。</target>
        </trans-unit>
        <trans-unit id="6af23b7fd50d16bb7de156bad92b5bd09f67edbf" translate="yes" xml:space="preserve">
          <source>The name of the extension that the index is to depend on.</source>
          <target state="translated">インデックスが依存する拡張子の名前。</target>
        </trans-unit>
        <trans-unit id="dc831ae12120e6fd5fdd21a20fd1a1e7bd573e67" translate="yes" xml:space="preserve">
          <source>The name of the extension that the materialized view is to depend on.</source>
          <target state="translated">マテリアライズされたビューが依存する拡張子の名前です。</target>
        </trans-unit>
        <trans-unit id="4f55051df080e15b2a3119833fb2677544739012" translate="yes" xml:space="preserve">
          <source>The name of the extension that the procedure is to depend on.</source>
          <target state="translated">プロシージャが依存する拡張子の名前です。</target>
        </trans-unit>
        <trans-unit id="0a35573e050ab73e125502a3b5564abce7fd88f9" translate="yes" xml:space="preserve">
          <source>The name of the extension that the trigger is to depend on.</source>
          <target state="translated">トリガーが依存する拡張子の名前です。</target>
        </trans-unit>
        <trans-unit id="88e9cf7b26c10377ec9b042f69222e5d8682e8ed" translate="yes" xml:space="preserve">
          <source>The name of the extension to be installed. PostgreSQL will create the extension using details from the file &lt;code&gt;SHAREDIR/extension/&lt;/code&gt;&lt;code&gt;extension_name&lt;/code&gt;&lt;code&gt;.control&lt;/code&gt;.</source>
          <target state="translated">インストールする拡張機能の名前。PostgreSQLは、ファイル &lt;code&gt;SHAREDIR/extension/&lt;/code&gt; &lt;code&gt;extension_name&lt;/code&gt; &lt;code&gt;.control&lt;/code&gt; の詳細を使用して拡張機能を作成します。</target>
        </trans-unit>
        <trans-unit id="d6fa04f440c0a0fbd9ef5c8562fd34285144f5e9" translate="yes" xml:space="preserve">
          <source>The name of the final function called to compute the aggregate's result after all input rows have been traversed, when using moving-aggregate mode. This works the same as &lt;code&gt;ffunc&lt;/code&gt;, except that its first argument's type is &lt;code&gt;mstate_data_type&lt;/code&gt; and extra dummy arguments are specified by writing &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt;. The aggregate result type determined by &lt;code&gt;mffunc&lt;/code&gt; or &lt;code&gt;mstate_data_type&lt;/code&gt; must match that determined by the aggregate's regular implementation.</source>
          <target state="translated">移動集約モードを使用している場合に、すべての入力行をたどった後に集約の結果を計算するために呼び出される最後の関数の名前。これは &lt;code&gt;mstate_data_type&lt;/code&gt; と同じように &lt;code&gt;ffunc&lt;/code&gt; ますが、最初の引数のタイプがmstate_data_typeであり、追加の仮引数が &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt; を記述することによって指定される点が異なります。 &lt;code&gt;mffunc&lt;/code&gt; または &lt;code&gt;mstate_data_type&lt;/code&gt; によって決定される集約結果タイプは、集約の通常の実装によって決定されるものと一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="f5f06809f2c728bd2159e0f8d844d66eca27a10c" translate="yes" xml:space="preserve">
          <source>The name of the final function called to compute the aggregate's result after all input rows have been traversed. For a normal aggregate, this function must take a single argument of type &lt;code&gt;state_data_type&lt;/code&gt;. The return data type of the aggregate is defined as the return type of this function. If &lt;code&gt;ffunc&lt;/code&gt; is not specified, then the ending state value is used as the aggregate's result, and the return type is &lt;code&gt;state_data_type&lt;/code&gt;.</source>
          <target state="translated">すべての入力行をたどった後に集計の結果を計算するために呼び出される最後の関数の名前。通常の集約の場合、この関数はタイプ &lt;code&gt;state_data_type&lt;/code&gt; の単一の引数を取る必要があります。集計の戻りデータ型は、この関数の戻り型として定義されます。 &lt;code&gt;ffunc&lt;/code&gt; が指定されていない場合、終了状態の値が集計の結果として使用され、戻り値の型は &lt;code&gt;state_data_type&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="72c35b2edf9735176f859431671ff1f17e5d197c" translate="yes" xml:space="preserve">
          <source>The name of the foreign server to be created.</source>
          <target state="translated">作成する外部サーバーの名前です。</target>
        </trans-unit>
        <trans-unit id="c3a096f51b1b0afdadcf653b248a2d3f34aa4744" translate="yes" xml:space="preserve">
          <source>The name of the foreign-data wrapper that manages the server.</source>
          <target state="translated">サーバを管理する外部データラッパーの名前です。</target>
        </trans-unit>
        <trans-unit id="d54745f11f4179244c18fb9a79fb68702588d241" translate="yes" xml:space="preserve">
          <source>The name of the foreign-data wrapper to be created.</source>
          <target state="translated">作成する外部データラッパーの名前です。</target>
        </trans-unit>
        <trans-unit id="1fdbb3b7aa9f05df80cfbaca84874bb5ff3faf75" translate="yes" xml:space="preserve">
          <source>The name of the forward state transition function to be called for each input row in moving-aggregate mode. This is exactly like the regular transition function, except that its first argument and result are of type &lt;code&gt;mstate_data_type&lt;/code&gt;, which might be different from &lt;code&gt;state_data_type&lt;/code&gt;.</source>
          <target state="translated">移動集約モードで各入力行に対して呼び出される転送状態遷移関数の名前。これは通常の遷移関数とまったく同じですが、最初の引数と結果の型が &lt;code&gt;mstate_data_type&lt;/code&gt; であり、 &lt;code&gt;state_data_type&lt;/code&gt; とは異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="644a4d91bed7658870a145ab3141d930ef90e912" translate="yes" xml:space="preserve">
          <source>The name of the function for converting the type from the SQL environment to the language. It must take one argument of type &lt;code&gt;internal&lt;/code&gt; and return type &lt;code&gt;internal&lt;/code&gt;. The actual argument will be of the type for the transform, and the function should be coded as if it were. (But it is not allowed to declare an SQL-level function returning &lt;code&gt;internal&lt;/code&gt; without at least one argument of type &lt;code&gt;internal&lt;/code&gt;.) The actual return value will be something specific to the language implementation. If no argument list is specified, the function name must be unique in its schema.</source>
          <target state="translated">タイプをSQL環境から言語に変換する関数の名前。これは、タイプの一つの引数を取らなければならない &lt;code&gt;internal&lt;/code&gt; および戻り値の型が &lt;code&gt;internal&lt;/code&gt; 。実際の引数は変換のタイプであり、関数はあたかもそうであるかのようにコード化されるべきです。 （ただし、少なくとも1つの &lt;code&gt;internal&lt;/code&gt; 型の引数なしで &lt;code&gt;internal&lt;/code&gt; を返すSQLレベルの関数を宣言することはできません。）実際の戻り値は、言語の実装に固有の値になります。引数リストが指定されていない場合、関数名はそのスキーマ内で一意である必要があります。</target>
        </trans-unit>
        <trans-unit id="72f3b32f063bc50605b229238d27a5869c6aa7b9" translate="yes" xml:space="preserve">
          <source>The name of the function for converting the type from the language to the SQL environment. It must take one argument of type &lt;code&gt;internal&lt;/code&gt; and return the type that is the type for the transform. The actual argument value will be something specific to the language implementation. If no argument list is specified, the function name must be unique in its schema.</source>
          <target state="translated">型を言語からSQL環境に変換するための関数の名前。これは、 &lt;code&gt;internal&lt;/code&gt; 型の引数を1つ取り、変換の型である型を返す必要があります。実際の引数値は、言語の実装に固有の値になります。引数リストが指定されていない場合、関数名はそのスキーマ内で一意である必要があります。</target>
        </trans-unit>
        <trans-unit id="67cb877b3731a337b10795d0e7186566d6a3d1e1" translate="yes" xml:space="preserve">
          <source>The name of the get-next-token function for the parser.</source>
          <target state="translated">パーサのget-next-token関数の名前です。</target>
        </trans-unit>
        <trans-unit id="6d1ebf156ba07f5a77467c8ec4ff708f33b3fc16" translate="yes" xml:space="preserve">
          <source>The name of the group (role) to modify.</source>
          <target state="translated">変更するグループ(ロール)の名前。</target>
        </trans-unit>
        <trans-unit id="2ed53b580ba0bc8625e75a9560c3a6e88d077a4d" translate="yes" xml:space="preserve">
          <source>The name of the headline function for the parser (a function that summarizes a set of tokens).</source>
          <target state="translated">パーサのヘッドライン関数(トークンの集合を要約する関数)の名前です。</target>
        </trans-unit>
        <trans-unit id="a3a747073ce359aa3857b433256c5b13312b5a04" translate="yes" xml:space="preserve">
          <source>The name of the index access method the operator class is for.</source>
          <target state="translated">演算子クラスが使用するインデックスアクセスメソッドの名前。</target>
        </trans-unit>
        <trans-unit id="ed18a236c732efe90dba559278f7adbf5db0ca9c" translate="yes" xml:space="preserve">
          <source>The name of the index access method the operator family is for.</source>
          <target state="translated">演算子ファミリが使用するインデックスアクセスメソッドの名前。</target>
        </trans-unit>
        <trans-unit id="c45cc6bfca0d231f36cbda7b1370cd41ed1d67b6" translate="yes" xml:space="preserve">
          <source>The name of the index method this operator class is for.</source>
          <target state="translated">この演算子クラスのインデックスメソッドの名前。</target>
        </trans-unit>
        <trans-unit id="615794124cec123ffa046fc334d0b7cb274ccdc2" translate="yes" xml:space="preserve">
          <source>The name of the index method this operator family is for.</source>
          <target state="translated">この演算子ファミリが使用するインデックス・メソッドの名前。</target>
        </trans-unit>
        <trans-unit id="4bb90538453113f1fb57ae8f2d37c35f322febf6" translate="yes" xml:space="preserve">
          <source>The name of the index method to be used. Choices are &lt;code&gt;btree&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;gist&lt;/code&gt;, &lt;code&gt;spgist&lt;/code&gt;, &lt;code&gt;gin&lt;/code&gt;, and &lt;code&gt;brin&lt;/code&gt;. The default method is &lt;code&gt;btree&lt;/code&gt;.</source>
          <target state="translated">使用するインデックスメソッドの名前。選択肢は、 &lt;code&gt;btree&lt;/code&gt; 、 &lt;code&gt;hash&lt;/code&gt; 、 &lt;code&gt;gist&lt;/code&gt; 、 &lt;code&gt;spgist&lt;/code&gt; 、 &lt;code&gt;gin&lt;/code&gt; 、および &lt;code&gt;brin&lt;/code&gt; 。デフォルトのメソッドは &lt;code&gt;btree&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="bb830e2432e53c927391aeee88f93bb4667bcae4" translate="yes" xml:space="preserve">
          <source>The name of the index to be created. No schema name can be included here; the index is always created in the same schema as its parent table. If the name is omitted, PostgreSQL chooses a suitable name based on the parent table's name and the indexed column name(s).</source>
          <target state="translated">作成するインデックスの名前。インデックスは常に親テーブルと同じスキーマで作成されます。名前が省略された場合、PostgreSQLは親テーブルの名前とインデックス化された列名に基づいて適切な名前を選択します。</target>
        </trans-unit>
        <trans-unit id="a4663fb986b280170b92707494282c81c2899c4f" translate="yes" xml:space="preserve">
          <source>The name of the init function for the template.</source>
          <target state="translated">テンプレートのinit関数の名前です。</target>
        </trans-unit>
        <trans-unit id="f00fd5139904e6694b429785636163e14a782210" translate="yes" xml:space="preserve">
          <source>The name of the inverse state transition function to be used in moving-aggregate mode. This function has the same argument and result types as &lt;code&gt;msfunc&lt;/code&gt;, but it is used to remove a value from the current aggregate state, rather than add a value to it. The inverse transition function must have the same strictness attribute as the forward state transition function.</source>
          <target state="translated">移動集約モードで使用される逆状態遷移関数の名前。この関数の引数と結果の型は &lt;code&gt;msfunc&lt;/code&gt; と同じですが、値を追加するのではなく、現在の集計状態から値を削除するために使用されます。逆遷移関数には、順方向状態遷移関数と同じ厳密性属性が必要です。</target>
        </trans-unit>
        <trans-unit id="3d95c2fd2534c7b2ce3a1746cb2c27650d29fdc4" translate="yes" xml:space="preserve">
          <source>The name of the language of the transform.</source>
          <target state="translated">トランスフォームの言語名。</target>
        </trans-unit>
        <trans-unit id="26a3e76d4aff5006209caa326a5bf1517ad79006" translate="yes" xml:space="preserve">
          <source>The name of the language that the function is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g. &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="translated">関数を実装している言語の名前が。それはすることができ &lt;code&gt;sql&lt;/code&gt; 、 &lt;code&gt;c&lt;/code&gt; 、 &lt;code&gt;internal&lt;/code&gt; 、またはユーザ定義の手続き言語、例えばの名前 &lt;code&gt;plpgsql&lt;/code&gt; が。名前を単一引用符で囲むことは非推奨であり、大文字と小文字を一致させる必要があります。</target>
        </trans-unit>
        <trans-unit id="0b5713bc5c339abbdacc15961df416377c21c0e3" translate="yes" xml:space="preserve">
          <source>The name of the language that the procedure is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g. &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="translated">手順を実装している言語の名前が。それはすることができ &lt;code&gt;sql&lt;/code&gt; 、 &lt;code&gt;c&lt;/code&gt; 、 &lt;code&gt;internal&lt;/code&gt; 、またはユーザ定義の手続き言語、例えばの名前 &lt;code&gt;plpgsql&lt;/code&gt; が。名前を単一引用符で囲むことは非推奨であり、大文字と小文字を一致させる必要があります。</target>
        </trans-unit>
        <trans-unit id="86f56142098dd6b61f4dc395fb22e1f6084da31b" translate="yes" xml:space="preserve">
          <source>The name of the lexize function for the template.</source>
          <target state="translated">テンプレートの lexize 関数の名前です。</target>
        </trans-unit>
        <trans-unit id="78bf3c88f1577390b2b7639c878108066bdde80d" translate="yes" xml:space="preserve">
          <source>The name of the lextypes function for the parser (a function that returns information about the set of token types it produces).</source>
          <target state="translated">パーサの lextypes 関数の名前(生成するトークン型の集合に関する情報を返す関数)。</target>
        </trans-unit>
        <trans-unit id="99c5d2489b4f3028ca831f4f9b0e7e15704ecdca" translate="yes" xml:space="preserve">
          <source>The name of the new procedural language. The name must be unique among the languages in the database.</source>
          <target state="translated">新しい手続き言語の名前。この名前はデータベース内の言語の中で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="bf36b4ea435ecc1c1aaf6ed21ca9df2c4c0596b3" translate="yes" xml:space="preserve">
          <source>The name of the new publication.</source>
          <target state="translated">新刊の名前です。</target>
        </trans-unit>
        <trans-unit id="dc580686d337370d500fabd6d8d4233f2a645d1a" translate="yes" xml:space="preserve">
          <source>The name of the new role.</source>
          <target state="translated">新しい役割の名前です。</target>
        </trans-unit>
        <trans-unit id="9deb527e5d18a4a607e93b3c59b44924e3848af5" translate="yes" xml:space="preserve">
          <source>The name of the new subscription.</source>
          <target state="translated">新しいサブスクリプションの名前です。</target>
        </trans-unit>
        <trans-unit id="84ca9243f0b08a6130478bf4d0fddd3954c72484" translate="yes" xml:space="preserve">
          <source>The name of the object to be commented. Names of tables, aggregates, collations, conversions, domains, foreign tables, functions, indexes, operators, operator classes, operator families, procedures, routines, sequences, statistics, text search objects, types, and views can be schema-qualified. When commenting on a column, &lt;code&gt;relation_name&lt;/code&gt; must refer to a table, view, composite type, or foreign table.</source>
          <target state="translated">コメントするオブジェクトの名前。テーブル、集計、照合、変換、ドメイン、外部テーブル、関数、インデックス、演算子、演算子クラス、演算子ファミリ、プロシージャ、ルーチン、シーケンス、統計、テキスト検索オブジェクト、タイプ、およびビューの名前は、スキーマで修飾できます。列にコメントを付ける場合、 &lt;code&gt;relation_name&lt;/code&gt; はテーブル、ビュー、複合型、または外部テーブルを参照する必要があります。</target>
        </trans-unit>
        <trans-unit id="0ad7f76d8fb02cb1c406ee55180e013d61f5632a" translate="yes" xml:space="preserve">
          <source>The name of the object to be labeled. Names of tables, aggregates, domains, foreign tables, functions, procedures, routines, sequences, types, and views can be schema-qualified.</source>
          <target state="translated">ラベルを付けるオブジェクトの名前。テーブル、集約、ドメイン、外部テーブル、関数、プロシージャ、ルーチン、シーケンス、型、およびビューの名前をスキーマ修飾することができます。</target>
        </trans-unit>
        <trans-unit id="d73d0a54fa511d10e86523f09232c08b9e6d5db1" translate="yes" xml:space="preserve">
          <source>The name of the object to which this label applies, as text.</source>
          <target state="translated">このラベルが適用されるオブジェクトの名前をテキストで指定します。</target>
        </trans-unit>
        <trans-unit id="42c399b3a656097491cae7892f14f5784153a41c" translate="yes" xml:space="preserve">
          <source>The name of the operator class to be created. The name can be schema-qualified.</source>
          <target state="translated">作成する演算子クラスの名前。この名前はスキーマで修飾することができます。</target>
        </trans-unit>
        <trans-unit id="3c9b852f5483728a82051e673011a9205c74fef8" translate="yes" xml:space="preserve">
          <source>The name of the operator family to be created. The name can be schema-qualified.</source>
          <target state="translated">作成する演算子ファミリの名前。この名前はスキーマで修飾することができます。</target>
        </trans-unit>
        <trans-unit id="aa3dee6563b812e00d9ce856987f40752c4ba957" translate="yes" xml:space="preserve">
          <source>The name of the operator to be defined. See above for allowable characters. The name can be schema-qualified, for example &lt;code&gt;CREATE OPERATOR myschema.+ (...)&lt;/code&gt;. If not, then the operator is created in the current schema. Two operators in the same schema can have the same name if they operate on different data types. This is called &lt;em&gt;overloading&lt;/em&gt;.</source>
          <target state="translated">定義する演算子の名前。使用できる文字については、上記を参照してください。名前はスキーマで修飾できます &lt;code&gt;CREATE OPERATOR myschema.+ (...)&lt;/code&gt; 例：CREATE OPERATOR myschema。+（...））。そうでない場合、演算子は現在のスキーマに作成されます。同じスキーマ内の2つの演算子は、異なるデータ型を操作する場合、同じ名前を持つことができます。これは&lt;em&gt;オーバーロード&lt;/em&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="89042cdb5d6d0a5c95dd63eb06cd01f0a55a975c" translate="yes" xml:space="preserve">
          <source>The name of the policy</source>
          <target state="translated">ポリシー名</target>
        </trans-unit>
        <trans-unit id="b729bdecc076d261a6f2aa96bf01271915d37a2a" translate="yes" xml:space="preserve">
          <source>The name of the policy to be created. This must be distinct from the name of any other policy for the table.</source>
          <target state="translated">作成するポリシーの名前です。これは、そのテーブルの他のポリシーの名前とは区別されなければなりません。</target>
        </trans-unit>
        <trans-unit id="e268e30430f81e017c4a875eccb62cdf9b012871" translate="yes" xml:space="preserve">
          <source>The name of the policy to drop.</source>
          <target state="translated">ドロップするポリシーの名前です。</target>
        </trans-unit>
        <trans-unit id="e49a87c2d393345ad07affbe76b904f4fe401c81" translate="yes" xml:space="preserve">
          <source>The name of the prepared statement to deallocate.</source>
          <target state="translated">デアロケートするための準備されたステートメントの名前です。</target>
        </trans-unit>
        <trans-unit id="96c3920c719f442187d159c204dd3612ea686ae5" translate="yes" xml:space="preserve">
          <source>The name of the prepared statement to execute.</source>
          <target state="translated">実行する準備されたステートメントの名前です。</target>
        </trans-unit>
        <trans-unit id="655476f7c7223e1c8c574d3f749ecc5208b3f1a9" translate="yes" xml:space="preserve">
          <source>The name of the procedural language the code is written in. If omitted, the default is &lt;code&gt;plpgsql&lt;/code&gt;.</source>
          <target state="translated">コードが記述されている手続き言語の名前。省略した場合、デフォルトは &lt;code&gt;plpgsql&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="03668e7125b4437e3ffadf3e4e590be0e7efc658" translate="yes" xml:space="preserve">
          <source>The name of the provider with which this label is to be associated. The named provider must be loaded and must consent to the proposed labeling operation. If exactly one provider is loaded, the provider name may be omitted for brevity.</source>
          <target state="translated">このラベルが関連付けられるプロバイダの名前。指定されたプロバイダがロードされ、提案されたラベリング操作に同意しなければならない。プロバイダが1つだけロードされている場合は、簡潔にするためにプロバイダ名を省略してもよい。</target>
        </trans-unit>
        <trans-unit id="4982a7a5e8149f1e3c35391b81b9f53d77cb4f02" translate="yes" xml:space="preserve">
          <source>The name of the role that will be made the new owner of the affected objects.</source>
          <target state="translated">影響を受けるオブジェクトの新しい所有者となるロールの名前です。</target>
        </trans-unit>
        <trans-unit id="d91a150acbfef5a5067b673c038cee51df98a783" translate="yes" xml:space="preserve">
          <source>The name of the role to remove.</source>
          <target state="translated">削除するロールの名前。</target>
        </trans-unit>
        <trans-unit id="f2c76cbbaae9ad7b16ccf9e7e0922d982cd4547e" translate="yes" xml:space="preserve">
          <source>The name of the role whose attributes are to be altered.</source>
          <target state="translated">属性を変更するロールの名前です。</target>
        </trans-unit>
        <trans-unit id="a2cca4e02caca1d1f07a5556d0d3f7be637865d7" translate="yes" xml:space="preserve">
          <source>The name of the rule to drop.</source>
          <target state="translated">落とすルールの名前。</target>
        </trans-unit>
        <trans-unit id="fc701ae189d9b3d813db243f4da26ea0b33711ef" translate="yes" xml:space="preserve">
          <source>The name of the savepoint to destroy.</source>
          <target state="translated">破壊するセーブポイントの名前。</target>
        </trans-unit>
        <trans-unit id="4816861b05e3da72c531801eafbb94d541e0e94f" translate="yes" xml:space="preserve">
          <source>The name of the schema in which to install the extension's objects, given that the extension allows its contents to be relocated. The named schema must already exist. If not specified, and the extension's control file does not specify a schema either, the current default object creation schema is used.</source>
          <target state="translated">拡張モジュールのオブジェクトをインストールするスキーマの名前です。指定したスキーマは既に存在しなければなりません。指定されておらず、拡張モジュールのコントロールファイルがスキーマを指定していない場合は、現在のデフォルトのオブジェクト作成スキーマが使用されます。</target>
        </trans-unit>
        <trans-unit id="42eda784d25f0da5728fd9204f655f7fcdcb985b" translate="yes" xml:space="preserve">
          <source>The name of the schema to which the table will be moved.</source>
          <target state="translated">テーブルを移動させるスキーマの名前です。</target>
        </trans-unit>
        <trans-unit id="ac04d5a0b8ecbdd03c9da31af0a4b7d10ec89b66" translate="yes" xml:space="preserve">
          <source>The name of the source data type of the cast.</source>
          <target state="translated">キャストのソースデータ型の名前です。</target>
        </trans-unit>
        <trans-unit id="2294ddf1df955220bbac238988facccf0c6a0592" translate="yes" xml:space="preserve">
          <source>The name of the specific index, table, or database to be reindexed. Index and table names can be schema-qualified. Presently, &lt;code&gt;REINDEX DATABASE&lt;/code&gt; and &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; can only reindex the current database, so their parameter must match the current database's name.</source>
          <target state="translated">インデックスを再作成する特定のインデックス、テーブル、またはデータベースの名前。インデックス名とテーブル名はスキーマで修飾できます。現在、 &lt;code&gt;REINDEX DATABASE&lt;/code&gt; と &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; は現在のデータベースのインデックスのみを再作成できるため、それらのパラメーターは現在のデータベースの名前と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="1371535897b887a5106cddf678bff07e0c5f80a9" translate="yes" xml:space="preserve">
          <source>The name of the start function for the parser.</source>
          <target state="translated">パーサの開始関数の名前です。</target>
        </trans-unit>
        <trans-unit id="015f67e7eaa6c3588c5e9952c547a024ac10153d" translate="yes" xml:space="preserve">
          <source>The name of the state transition function to be called for each input row. For a normal &lt;code&gt;N&lt;/code&gt;-argument aggregate function, the &lt;code&gt;sfunc&lt;/code&gt; must take &lt;code&gt;N&lt;/code&gt;+1 arguments, the first being of type &lt;code&gt;state_data_type&lt;/code&gt; and the rest matching the declared input data type(s) of the aggregate. The function must return a value of type &lt;code&gt;state_data_type&lt;/code&gt;. This function takes the current state value and the current input data value(s), and returns the next state value.</source>
          <target state="translated">各入力行に対して呼び出される状態遷移関数の名前。通常の &lt;code&gt;N&lt;/code&gt; 引数の集約関数の場合、 &lt;code&gt;sfunc&lt;/code&gt; は &lt;code&gt;N&lt;/code&gt; +1引数を取る必要があります。最初の引数は &lt;code&gt;state_data_type&lt;/code&gt; 型で、残りは集約の宣言された入力データ型と一致します。関数は、 &lt;code&gt;state_data_type&lt;/code&gt; 型の値を返す必要があります。この関数は、現在の状態値と現在の入力データ値を受け取り、次の状態値を返します。</target>
        </trans-unit>
        <trans-unit id="98dfcac96a79ab8d2309606485d5d666ca4e2daa" translate="yes" xml:space="preserve">
          <source>The name of the table and column to update</source>
          <target state="translated">更新するテーブルとカラムの名前</target>
        </trans-unit>
        <trans-unit id="86a9a516ee162e483fd6f8fbe8dac2f83cc35633" translate="yes" xml:space="preserve">
          <source>The name of the table on which this trigger acts.</source>
          <target state="translated">このトリガが作用するテーブルの名前。</target>
        </trans-unit>
        <trans-unit id="df029c5f6289a56399018c193966351757b130e4" translate="yes" xml:space="preserve">
          <source>The name of the table to attach as a new partition or to detach from this table.</source>
          <target state="translated">新しいパーティションとしてアタッチするテーブル名、またはこのテーブルから切り離すテーブル名。</target>
        </trans-unit>
        <trans-unit id="910f7a94c4794ba13cd804620ae6f535c8697348" translate="yes" xml:space="preserve">
          <source>The name of the tablespace that will be associated with the new database, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the template database's tablespace. This tablespace will be the default tablespace used for objects created in this database. See &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; for more information.</source>
          <target state="translated">新しいデータベースに関連付けられるテーブルスペースの名前、またはテンプレートデータベースのテーブルスペースを使用する &lt;code&gt;DEFAULT&lt;/code&gt; 。このテーブルスペースは、このデータベースで作成されたオブジェクトに使用されるデフォルトのテーブルスペースになります。詳細については、&lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2adc75b40aac253d8d3fd83763a5999e795d523d" translate="yes" xml:space="preserve">
          <source>The name of the tablespace to which the table will be moved.</source>
          <target state="translated">テーブルが移動されるテーブル空間の名前。</target>
        </trans-unit>
        <trans-unit id="ed5faf3ddd011b5c76e052594331ee12feb17ee5" translate="yes" xml:space="preserve">
          <source>The name of the target data type of the cast.</source>
          <target state="translated">キャストの対象となるデータ型の名前です。</target>
        </trans-unit>
        <trans-unit id="f5d196df67f8715141577ca0dfa1d0026e0d7817" translate="yes" xml:space="preserve">
          <source>The name of the template from which to create the new database, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the default template (&lt;code&gt;template1&lt;/code&gt;).</source>
          <target state="translated">新しいデータベースを作成するためのテンプレートの名前、またはデフォルトのテンプレート（ &lt;code&gt;template1&lt;/code&gt; ）を使用するための &lt;code&gt;DEFAULT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38cd3261917960f8e539d80ae266a773e2ca894a" translate="yes" xml:space="preserve">
          <source>The name of the text search configuration to be created. The name can be schema-qualified.</source>
          <target state="translated">作成するテキスト検索設定の名前。この名前はスキーマで修飾することができます。</target>
        </trans-unit>
        <trans-unit id="7715676ee8a2df410a7d9b5d6a75ed5f4bbb933b" translate="yes" xml:space="preserve">
          <source>The name of the text search dictionary to be created. The name can be schema-qualified.</source>
          <target state="translated">作成するテキスト検索辞書の名前。この名前はスキーマで修飾することができます。</target>
        </trans-unit>
        <trans-unit id="08a42806dfcb8f125b19f0057086523042a36ad3" translate="yes" xml:space="preserve">
          <source>The name of the text search parser to be created. The name can be schema-qualified.</source>
          <target state="translated">作成するテキスト検索パーサの名前です。この名前はスキーマで修飾することができます。</target>
        </trans-unit>
        <trans-unit id="24ce45ce2160196c06edff30b966c8ad75ac789f" translate="yes" xml:space="preserve">
          <source>The name of the text search parser to use for this configuration.</source>
          <target state="translated">この設定に使用するテキスト検索パーサの名前。</target>
        </trans-unit>
        <trans-unit id="84cb2dc1f232e52ae9a92c0bb4186a0059e53aa7" translate="yes" xml:space="preserve">
          <source>The name of the text search template that will define the basic behavior of this dictionary.</source>
          <target state="translated">この辞書の基本的な動作を定義するテキスト検索テンプレートの名前。</target>
        </trans-unit>
        <trans-unit id="1584a807877a42990d603d823d759977f3901ddc" translate="yes" xml:space="preserve">
          <source>The name of the text search template to be created. The name can be schema-qualified.</source>
          <target state="translated">作成するテキスト検索テンプレートの名前。この名前はスキーマで修飾することができます。</target>
        </trans-unit>
        <trans-unit id="d0987d8df78c216eed09875fd5ebec69f27a40ed" translate="yes" xml:space="preserve">
          <source>The name of the trigger to remove.</source>
          <target state="translated">削除するトリガーの名前。</target>
        </trans-unit>
        <trans-unit id="afd08ce0efd0e1d1a3450afd63d3251269afcb61" translate="yes" xml:space="preserve">
          <source>The name of the user who will own the tablespace. If omitted, defaults to the user executing the command. Only superusers can create tablespaces, but they can assign ownership of tablespaces to non-superusers.</source>
          <target state="translated">テーブルスペースを所有するユーザの名前。省略した場合は、コマンドを実行したユーザーがデフォルトとなります。スーパーユーザのみが表領域を作成できますが、スーパーユーザ以外に表領域の所有権を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="1c1d8e2ccb4524cb644f6e39612aee840de9a90d" translate="yes" xml:space="preserve">
          <source>The name or IP addresses of the RADIUS servers to connect to. This parameter is required.</source>
          <target state="translated">接続先のRADIUSサーバーの名前またはIPアドレス。このパラメータは必須です。</target>
        </trans-unit>
        <trans-unit id="21389222271889edde6e7b3bd3c9fdd837bca670" translate="yes" xml:space="preserve">
          <source>The name parameter will be MD5-hashed, so the cleartext cannot be derived from the generated UUID. The generation of UUIDs by this method has no random or environment-dependent element and is therefore reproducible.</source>
          <target state="translated">nameパラメータはMD5ハッシュ化されるので、生成されたUUIDからクリアテキストを派生させることはできません。この方法によるUUIDの生成は、ランダムな要素や環境に依存する要素を持たないため、再現性があります。</target>
        </trans-unit>
        <trans-unit id="ee74a07e23c9dea72df5a27b777fb65b403c0393" translate="yes" xml:space="preserve">
          <source>The name stems from the fact that this table should not be readable by the public since it contains passwords. &lt;a href=&quot;view-pg-user&quot;&gt;&lt;code&gt;pg_user&lt;/code&gt;&lt;/a&gt; is a publicly readable view on &lt;code&gt;pg_shadow&lt;/code&gt; that blanks out the password field.</source>
          <target state="translated">この名前は、このテーブルにはパスワードが含まれているため、一般の人が読めるようにすべきではないという事実に由来しています。&lt;a href=&quot;view-pg-user&quot;&gt; &lt;code&gt;pg_user&lt;/code&gt; は&lt;/a&gt;上公に読める図である &lt;code&gt;pg_shadow&lt;/code&gt; システムパスワードフィールドをブランクにします。</target>
        </trans-unit>
        <trans-unit id="5d07e8a1b061fb282161f125ed44c357f0d17c75" translate="yes" xml:space="preserve">
          <source>The name to give the new trigger. This must be distinct from the name of any other trigger for the same table. The name cannot be schema-qualified &amp;mdash; the trigger inherits the schema of its table. For a constraint trigger, this is also the name to use when modifying the trigger's behavior using &lt;code&gt;SET CONSTRAINTS&lt;/code&gt;.</source>
          <target state="translated">新しいトリガーに付ける名前。これは、同じテーブルの他のトリガーの名前とは異なる必要があります。名前をスキーマで修飾することはできません&amp;mdash;トリガーはそのテーブルのスキーマを継承します。制約トリガーの場合、これは &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; を使用してトリガーの動作を変更するときに使用する名前でもあります。</target>
        </trans-unit>
        <trans-unit id="7b32b1efee504dab33e5254f802082429e271272" translate="yes" xml:space="preserve">
          <source>The name to give the new trigger. This name must be unique within the database.</source>
          <target state="translated">新しいトリガーを与える名前。この名前はデータベース内で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="11fed6031dec77608082f3fa5b2080d3486c35aa" translate="yes" xml:space="preserve">
          <source>The name to give to the new savepoint.</source>
          <target state="translated">新しいセーブポイントに与える名前。</target>
        </trans-unit>
        <trans-unit id="cf734951b344df7b211da487949af76d60fe726b" translate="yes" xml:space="preserve">
          <source>The names of opclasses and opfamilies are only unique within an access method, so they are represented by &lt;code&gt;access_method_name&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;object_name&lt;/code&gt;.</source>
          <target state="translated">opclassesおよびopfamiliesの名前は、アクセスメソッド内でのみ一意であるため、 &lt;code&gt;access_method_name&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;object_name&lt;/code&gt; で表されます。</target>
        </trans-unit>
        <trans-unit id="d60acc58684395b40a907774a02224d52b1340e7" translate="yes" xml:space="preserve">
          <source>The naming of output columns here is different from that done in the &lt;code&gt;FROM&lt;/code&gt; clause (see &lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;Section 7.2.1.2&lt;/a&gt;). It is possible to rename the same column twice, but the name assigned in the select list is the one that will be passed on.</source>
          <target state="translated">ここでの出力列の命名は、 &lt;code&gt;FROM&lt;/code&gt; 句で行われる命名とは異なります（&lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;セクション7.2.1.2を&lt;/a&gt;参照）。同じ列の名前を2回変更することは可能ですが、選択リストで割り当てられた名前が渡されます。</target>
        </trans-unit>
        <trans-unit id="8c0fc2cb480be9bb9c51a4bc9a223616db655fd1" translate="yes" xml:space="preserve">
          <source>The negator of this operator.</source>
          <target state="translated">この演算子の否定子。</target>
        </trans-unit>
        <trans-unit id="c48796461ad5a772c7e7652201b09a6a57e675ec" translate="yes" xml:space="preserve">
          <source>The new column is initially filled with whatever default value is given (null if you don't specify a &lt;code&gt;DEFAULT&lt;/code&gt; clause).</source>
          <target state="translated">新しい列には、デフォルト値が指定されていれば、最初はすべて入力されています（ &lt;code&gt;DEFAULT&lt;/code&gt; 句を指定しない場合はnull ）。</target>
        </trans-unit>
        <trans-unit id="99a5a709438ce00d416364163ad8901072e9ceb4" translate="yes" xml:space="preserve">
          <source>The new comment, written as a string literal; or &lt;code&gt;NULL&lt;/code&gt; to drop the comment.</source>
          <target state="translated">文字列リテラルとして書かれた新しいコメント。コメントを削除する場合は &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0eef4b2f503cdd8ca575c4d5c2db5edd06b1406" translate="yes" xml:space="preserve">
          <source>The new contents of the query buffer are then re-parsed according to the normal rules of psql, treating the whole buffer as a single line. Any complete queries are immediately executed; that is, if the query buffer contains or ends with a semicolon, everything up to that point is executed. Whatever remains will wait in the query buffer; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel it by clearing the query buffer. Treating the buffer as a single line primarily affects meta-commands: whatever is in the buffer after a meta-command will be taken as argument(s) to the meta-command, even if it spans multiple lines. (Thus you cannot make meta-command-using scripts this way. Use &lt;code&gt;\i&lt;/code&gt; for that.)</source>
          <target state="translated">クエリバッファーの新しい内容は、psqlの通常のルールに従って再解析され、バッファー全体が1行として扱われます。完全なクエリはすぐに実行されます。つまり、クエリバッファにセミコロンが含まれるかセミコロンで終わる場合、その時点までのすべてが実行されます。残っているものはクエリバッファで待機します。セミコロンまたは &lt;code&gt;\g&lt;/code&gt; を入力して送信するか、 &lt;code&gt;\r&lt;/code&gt; を入力してクエリバッファをクリアしてキャンセルします。バッファを単一行として扱うと、主にメタコマンドに影響します。メタコマンドの後のバッファにあるものは、たとえ複数行に渡っていても、メタコマンドの引数として扱われます。 （したがって、この方法でメタコマンドを使用するスクリプトを作成することはできません。 &lt;code&gt;\i&lt;/code&gt; を使用してください。）</target>
        </trans-unit>
        <trans-unit id="8c2269882cf52ae9f068a61edc3b778c3a536ff9" translate="yes" xml:space="preserve">
          <source>The new declaration of the tables would look like this:</source>
          <target state="translated">テーブルの新しい宣言は次のようになります。</target>
        </trans-unit>
        <trans-unit id="abb08cd78d70403e2ed01ba829b0b0e107ad79e1" translate="yes" xml:space="preserve">
          <source>The new default tablespace of the database.</source>
          <target state="translated">データベースの新しいデフォルトのテーブルスペース。</target>
        </trans-unit>
        <trans-unit id="bd696aa29e06c8bdaa37006c64334315b20f98b5" translate="yes" xml:space="preserve">
          <source>The new name for the constraint.</source>
          <target state="translated">制約の新しい名前。</target>
        </trans-unit>
        <trans-unit id="1897f67b69c5b7376acb8d806a5382da72697a70" translate="yes" xml:space="preserve">
          <source>The new name for the domain.</source>
          <target state="translated">ドメインの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="212f3ea5ee1a7012ae1ea00ecf4feddc77a325c7" translate="yes" xml:space="preserve">
          <source>The new name for the foreign server.</source>
          <target state="translated">海外サーバーの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="10044e9774ec8f7e4eeef4126404d9a4c8740bba" translate="yes" xml:space="preserve">
          <source>The new name for the foreign-data wrapper.</source>
          <target state="translated">外部データラッパーの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="c11d926987759462d0f175b4415bf3358d9ff337" translate="yes" xml:space="preserve">
          <source>The new name for the index.</source>
          <target state="translated">インデックスの新しい名前。</target>
        </trans-unit>
        <trans-unit id="33305417939d3b3756d6c5255331fe9d857743c1" translate="yes" xml:space="preserve">
          <source>The new name for the materialized view.</source>
          <target state="translated">マテリアライズされたビューの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="d0bd51a33ddf1dfa219e2e91d0e8c933e6563371" translate="yes" xml:space="preserve">
          <source>The new name for the policy.</source>
          <target state="translated">ポリシーの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="20931af42c3c5e46457e70a88b633cec676d6b34" translate="yes" xml:space="preserve">
          <source>The new name for the publication.</source>
          <target state="translated">出版物の新名称です。</target>
        </trans-unit>
        <trans-unit id="afd5b43d5185c06c93949d1324710b679e0f98bd" translate="yes" xml:space="preserve">
          <source>The new name for the rule.</source>
          <target state="translated">ルールの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="b48d77b2ef95f7c457090bcbbe943d0c70311b15" translate="yes" xml:space="preserve">
          <source>The new name for the sequence.</source>
          <target state="translated">シーケンスの新しい名前。</target>
        </trans-unit>
        <trans-unit id="fc2f67f3244cee265dae6b633cc864544be564aa" translate="yes" xml:space="preserve">
          <source>The new name for the statistics object.</source>
          <target state="translated">統計オブジェクトの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="5e567bc00743ec90ea48cd87ca4d4d39aaaf2a0e" translate="yes" xml:space="preserve">
          <source>The new name for the subscription.</source>
          <target state="translated">サブスクリプションの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="bb15ea9a2978ce58ebb2c54bd4908c64b61e3ec5" translate="yes" xml:space="preserve">
          <source>The new name for the trigger.</source>
          <target state="translated">トリガーの新しい名前。</target>
        </trans-unit>
        <trans-unit id="db155d6348c19b7d3227f389aca4111ed1c5bd26" translate="yes" xml:space="preserve">
          <source>The new name for the type.</source>
          <target state="translated">タイプの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="c523989c2e7068afb2501bed469e5428f5fdb7a8" translate="yes" xml:space="preserve">
          <source>The new name for the view.</source>
          <target state="translated">ビューの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="f2b9a6bf2f60ce509d60ec6a402dbd4fb867b9c2" translate="yes" xml:space="preserve">
          <source>The new name of the aggregate function.</source>
          <target state="translated">集計関数の新しい名前。</target>
        </trans-unit>
        <trans-unit id="aedc4948fc467788ca8aa2ca7751c93796b91571" translate="yes" xml:space="preserve">
          <source>The new name of the attribute to be renamed.</source>
          <target state="translated">名前を変更する属性の新しい名前。</target>
        </trans-unit>
        <trans-unit id="e113491ed22e052f8e080471ba08c58dedb8ea64" translate="yes" xml:space="preserve">
          <source>The new name of the collation.</source>
          <target state="translated">照合の新しい名前。</target>
        </trans-unit>
        <trans-unit id="4c4b7b49d6b58b2034ea06105277cd50556d40cb" translate="yes" xml:space="preserve">
          <source>The new name of the conversion.</source>
          <target state="translated">変換の新しい名前です。</target>
        </trans-unit>
        <trans-unit id="7bd49806ce97a6cf0ae2db0f7447c28e5ce8134f" translate="yes" xml:space="preserve">
          <source>The new name of the database.</source>
          <target state="translated">データベースの新しい名前。</target>
        </trans-unit>
        <trans-unit id="75a4aa01c626eb3410b405c18307300931670062" translate="yes" xml:space="preserve">
          <source>The new name of the event trigger.</source>
          <target state="translated">イベントトリガーの新しい名前。</target>
        </trans-unit>
        <trans-unit id="e4d75585a773a6cebff31b74551567f8918ab64f" translate="yes" xml:space="preserve">
          <source>The new name of the function.</source>
          <target state="translated">関数の新しい名前。</target>
        </trans-unit>
        <trans-unit id="2911d96c910b5a17b53eadc422fecbb845a71e4b" translate="yes" xml:space="preserve">
          <source>The new name of the group.</source>
          <target state="translated">グループの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="01ed3bb6171bf404a649ad2b2a5598d4f2218b1d" translate="yes" xml:space="preserve">
          <source>The new name of the language</source>
          <target state="translated">新しい言語の名前</target>
        </trans-unit>
        <trans-unit id="5629a006f70e9712f7f3f90081ef5ec794958fe9" translate="yes" xml:space="preserve">
          <source>The new name of the operator class.</source>
          <target state="translated">演算子クラスの新しい名前。</target>
        </trans-unit>
        <trans-unit id="cac8082223d146caa1279e011dcbd9499e966dea" translate="yes" xml:space="preserve">
          <source>The new name of the operator family.</source>
          <target state="translated">オペレータファミリーの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="b633cb5bdc25233c7a8bdbb49f3cdbe73d120c26" translate="yes" xml:space="preserve">
          <source>The new name of the procedure.</source>
          <target state="translated">プロシージャの新しい名前。</target>
        </trans-unit>
        <trans-unit id="3a9dddb1e76ff061e88bc3524aee453d2bee494e" translate="yes" xml:space="preserve">
          <source>The new name of the role.</source>
          <target state="translated">新しい役名です。</target>
        </trans-unit>
        <trans-unit id="2cf77fbb7b0d27045bc13b02630747a959116461" translate="yes" xml:space="preserve">
          <source>The new name of the schema. The new name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system schemas.</source>
          <target state="translated">スキーマの新しい名前。新しい名前を &lt;code&gt;pg_&lt;/code&gt; で始めることはできません。そのような名前はシステムスキーマ用に予約されているためです。</target>
        </trans-unit>
        <trans-unit id="a8efb3edcac41dbb05c4e401ddd6f8995c994227" translate="yes" xml:space="preserve">
          <source>The new name of the tablespace. The new name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system tablespaces.</source>
          <target state="translated">テーブルスペースの新しい名前。新しい名前を &lt;code&gt;pg_&lt;/code&gt; で始めることはできません。そのような名前はシステムテーブルスペース用に予約されているためです。</target>
        </trans-unit>
        <trans-unit id="5bc002f16673653b0690b28fc66ef20f059c3d17" translate="yes" xml:space="preserve">
          <source>The new name of the text search configuration.</source>
          <target state="translated">テキスト検索設定の新しい名前です。</target>
        </trans-unit>
        <trans-unit id="61d4e96018e9afca4b18c94ddcebcfce618c7e91" translate="yes" xml:space="preserve">
          <source>The new name of the text search dictionary.</source>
          <target state="translated">テキスト検索辞書の新名称。</target>
        </trans-unit>
        <trans-unit id="b0ee20d36931a187480bdf33645d746804cd8021" translate="yes" xml:space="preserve">
          <source>The new name of the text search parser.</source>
          <target state="translated">テキスト検索パーサの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="1aa4447ea683fc5f23d92a99564476e94e7ba4f8" translate="yes" xml:space="preserve">
          <source>The new name of the text search template.</source>
          <target state="translated">テキスト検索テンプレートの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="1cf431c1643a8759a28879f52b1cc3af8c233902" translate="yes" xml:space="preserve">
          <source>The new operator family is initially empty. It should be populated by issuing subsequent &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; commands to add contained operator classes, and optionally &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; commands to add &amp;ldquo;loose&amp;rdquo; operators and their corresponding support functions.</source>
          <target state="translated">新しい演算子族は最初は空です。後続の &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; コマンドを発行して含まれる演算子クラスを追加し、オプションで &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; コマンドを発行して「緩い」演算子とそれに対応するサポート関数を追加することで、データを入力する必要があります。</target>
        </trans-unit>
        <trans-unit id="f4c637105948973c0a153e08837179c7cca26481" translate="yes" xml:space="preserve">
          <source>The new owner of the aggregate function.</source>
          <target state="translated">集計関数の新しい所有者。</target>
        </trans-unit>
        <trans-unit id="6e427a5a254b743496752784773d8f681fc927a5" translate="yes" xml:space="preserve">
          <source>The new owner of the collation.</source>
          <target state="translated">コレーションの新しい所有者です。</target>
        </trans-unit>
        <trans-unit id="696c05a86f35e15f1b9049294a231e9c92db726b" translate="yes" xml:space="preserve">
          <source>The new owner of the conversion.</source>
          <target state="translated">転換の新オーナー。</target>
        </trans-unit>
        <trans-unit id="8c3476b50bc477a63585319a4ee66bd132d319a7" translate="yes" xml:space="preserve">
          <source>The new owner of the database.</source>
          <target state="translated">データベースの新しい所有者。</target>
        </trans-unit>
        <trans-unit id="d33f9460834c9ae8c6bbf2129c64d4ae9c681396" translate="yes" xml:space="preserve">
          <source>The new owner of the function. Note that if the function is marked &lt;code&gt;SECURITY DEFINER&lt;/code&gt;, it will subsequently execute as the new owner.</source>
          <target state="translated">関数の新しい所有者。関数が &lt;code&gt;SECURITY DEFINER&lt;/code&gt; とマークされている場合、その後、新しい所有者として実行されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="df4e6318da1bb722216c2b84ac2c4e660006a7bf" translate="yes" xml:space="preserve">
          <source>The new owner of the language</source>
          <target state="translated">言葉の新しい持ち主</target>
        </trans-unit>
        <trans-unit id="f528312a4f330c09f0db9a04fb7594d8a6881296" translate="yes" xml:space="preserve">
          <source>The new owner of the large object</source>
          <target state="translated">大きなオブジェクトの新しい所有者</target>
        </trans-unit>
        <trans-unit id="042ac141d75c40bbad49229676115d2c3f46dc44" translate="yes" xml:space="preserve">
          <source>The new owner of the operator class.</source>
          <target state="translated">演算子クラスの新しい所有者。</target>
        </trans-unit>
        <trans-unit id="690e510771eb7df59bdf5e81e98ce1c088ae0a0a" translate="yes" xml:space="preserve">
          <source>The new owner of the operator family.</source>
          <target state="translated">オペレーター一家の新オーナー。</target>
        </trans-unit>
        <trans-unit id="9786082232a6fabf8fef79154a67d7d246e8ac12" translate="yes" xml:space="preserve">
          <source>The new owner of the operator.</source>
          <target state="translated">運営者の新オーナー。</target>
        </trans-unit>
        <trans-unit id="3597f21e2766a9a6fcb13ac8067e53ff7ef13d45" translate="yes" xml:space="preserve">
          <source>The new owner of the procedure. Note that if the procedure is marked &lt;code&gt;SECURITY DEFINER&lt;/code&gt;, it will subsequently execute as the new owner.</source>
          <target state="translated">プロシージャの新しい所有者。プロシージャが &lt;code&gt;SECURITY DEFINER&lt;/code&gt; とマークされている場合、その後、新しい所有者として実行されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="69d41d917f1d5469eff45e378f228e62ac815b74" translate="yes" xml:space="preserve">
          <source>The new owner of the schema.</source>
          <target state="translated">スキーマの新しい所有者です。</target>
        </trans-unit>
        <trans-unit id="db70ea94e40096f71c45b13de8eea08d1af85b1d" translate="yes" xml:space="preserve">
          <source>The new owner of the tablespace.</source>
          <target state="translated">テーブルスペースの新しい所有者。</target>
        </trans-unit>
        <trans-unit id="e5c9278160aed343baae5e000f62f65dff7fc448" translate="yes" xml:space="preserve">
          <source>The new owner of the text search configuration.</source>
          <target state="translated">テキスト検索設定の新しい所有者です。</target>
        </trans-unit>
        <trans-unit id="aa73a2e5e347d201842eebdd89d547d089c6c8be" translate="yes" xml:space="preserve">
          <source>The new owner of the text search dictionary.</source>
          <target state="translated">テキスト検索辞書の新しい持ち主です。</target>
        </trans-unit>
        <trans-unit id="edb8e480bb54a06edf443d08eda6114457bafd19" translate="yes" xml:space="preserve">
          <source>The new role will automatically inherit privileges of roles it is a member of. This is the default.</source>
          <target state="translated">新しいロールは、それがメンバーであるロールの権限を自動的に継承します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="9a32a2a68f765041e1e9d89874f5db158ceae654" translate="yes" xml:space="preserve">
          <source>The new role will not automatically inherit privileges of roles it is a member of.</source>
          <target state="translated">新しいロールは、それがメンバーであるロールの権限を自動的に継承しません。</target>
        </trans-unit>
        <trans-unit id="9261c055206b3b24159966bd5e49b879f7e13689" translate="yes" xml:space="preserve">
          <source>The new schema for the aggregate function.</source>
          <target state="translated">集計機能の新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="4dc45ae2528649758dd2b3da76e3b1bde5aae0c1" translate="yes" xml:space="preserve">
          <source>The new schema for the collation.</source>
          <target state="translated">照合用の新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="fa5c853ff4ce0885678abb91184961581c7c86e8" translate="yes" xml:space="preserve">
          <source>The new schema for the conversion.</source>
          <target state="translated">変換のための新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="94f971cb399c2e27724257d01667804b12528aea" translate="yes" xml:space="preserve">
          <source>The new schema for the domain.</source>
          <target state="translated">ドメインの新しいスキーマ。</target>
        </trans-unit>
        <trans-unit id="ffcd3334bad17af07bda4b5f314843b54c035a01" translate="yes" xml:space="preserve">
          <source>The new schema for the extension.</source>
          <target state="translated">拡張機能の新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="892a2ed0bb951cfb6e7f263bc8da7d70f88d788a" translate="yes" xml:space="preserve">
          <source>The new schema for the function.</source>
          <target state="translated">関数の新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="f75cbb7e0424884c76eaf66a88fc00d8e62673a7" translate="yes" xml:space="preserve">
          <source>The new schema for the materialized view.</source>
          <target state="translated">マテリアライズされたビューの新しいスキーマ。</target>
        </trans-unit>
        <trans-unit id="f6752ffe51d8560507628fd3fa3becd8329772f1" translate="yes" xml:space="preserve">
          <source>The new schema for the operator class.</source>
          <target state="translated">演算子クラスの新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="91c91f016c0e190b6282eebefe2a49a89e2c716c" translate="yes" xml:space="preserve">
          <source>The new schema for the operator family.</source>
          <target state="translated">演算子ファミリの新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="a28f607105e64dc0674bab3c516a94057914430b" translate="yes" xml:space="preserve">
          <source>The new schema for the operator.</source>
          <target state="translated">演算子の新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="5b76b1ebef9ac79184347fc03689e8ad83b75ad3" translate="yes" xml:space="preserve">
          <source>The new schema for the procedure.</source>
          <target state="translated">プロシージャの新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="e1ef41d9bc55a3a445826b83357df117508b85c8" translate="yes" xml:space="preserve">
          <source>The new schema for the sequence.</source>
          <target state="translated">シーケンスの新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="051afa3d07978a274fc9c7a36c2e3cc09b60a787" translate="yes" xml:space="preserve">
          <source>The new schema for the statistics object.</source>
          <target state="translated">統計オブジェクトの新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="b33b53d7a11df09b3be2d48051dd92657dd5246a" translate="yes" xml:space="preserve">
          <source>The new schema for the text search configuration.</source>
          <target state="translated">テキスト検索設定のための新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="ef261ca400ba6b8c404f8ae1051c9ddf74db7470" translate="yes" xml:space="preserve">
          <source>The new schema for the text search dictionary.</source>
          <target state="translated">テキスト検索辞書の新しいスキーマ。</target>
        </trans-unit>
        <trans-unit id="6ee901249db3b5665acf6e566a8134c2dd5623bb" translate="yes" xml:space="preserve">
          <source>The new schema for the text search parser.</source>
          <target state="translated">テキスト検索パーサの新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="0a8618e7f7d0e904983cf7fb40badda672a564d7" translate="yes" xml:space="preserve">
          <source>The new schema for the text search template.</source>
          <target state="translated">テキスト検索テンプレートの新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="2dae7eeaa9912635729239a107cfdb2251e22f7c" translate="yes" xml:space="preserve">
          <source>The new schema for the type.</source>
          <target state="translated">型の新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="9da42308b2dd3741e38d355739234da9161529c8" translate="yes" xml:space="preserve">
          <source>The new schema for the view.</source>
          <target state="translated">ビューの新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="10efc2ba412402b38cf8661a03b9c2fa3f9344e1" translate="yes" xml:space="preserve">
          <source>The new security label, written as a string literal; or &lt;code&gt;NULL&lt;/code&gt; to drop the security label.</source>
          <target state="translated">文字列リテラルとして記述された新しいセキュリティラベル。または、セキュリティラベルを削除する場合は &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e179748e50d17a45a45be3da432d0626ce9f1871" translate="yes" xml:space="preserve">
          <source>The new server can now be safely started, and then any rsync'ed standby servers.</source>
          <target state="translated">これで新しいサーバを安全に起動し、rsync された待機サーバをすべて起動することができるようになりました。</target>
        </trans-unit>
        <trans-unit id="9cccbe82fdca6cb05f61febaafdcdbee82d07beb" translate="yes" xml:space="preserve">
          <source>The new user will be a superuser.</source>
          <target state="translated">新しいユーザーはスーパーユーザーになります。</target>
        </trans-unit>
        <trans-unit id="c54c521c104ba07a131d94a8006311919b30f264" translate="yes" xml:space="preserve">
          <source>The new user will be allowed to create databases.</source>
          <target state="translated">新しいユーザーがデータベースを作成することができるようになります。</target>
        </trans-unit>
        <trans-unit id="d45b0936a7b0d005278d7069b144bbda44325062" translate="yes" xml:space="preserve">
          <source>The new user will be allowed to create new roles (that is, this user will have &lt;code&gt;CREATEROLE&lt;/code&gt; privilege).</source>
          <target state="translated">新しいユーザーは新しいロールの作成を許可されます（つまり、このユーザーは &lt;code&gt;CREATEROLE&lt;/code&gt; 特権を持ちます）。</target>
        </trans-unit>
        <trans-unit id="f77c7b82b1f36620c7d5c97f31d6b3e8156045cd" translate="yes" xml:space="preserve">
          <source>The new user will be allowed to log in (that is, the user name can be used as the initial session user identifier). This is the default.</source>
          <target state="translated">新しいユーザーのログインが許可されます(つまり、ユーザー名を初期セッションのユーザー識別子として使用することができます)。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="20d6f51c275f9b74aaf81f7d6a5623641aaaf3e3" translate="yes" xml:space="preserve">
          <source>The new user will have the &lt;code&gt;REPLICATION&lt;/code&gt; privilege, which is described more fully in the documentation for &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;.</source>
          <target state="translated">新しいユーザーには &lt;code&gt;REPLICATION&lt;/code&gt; 権限が付与されます。これについては、&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLEの&lt;/a&gt;ドキュメントで詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="5ea6c8532360a87549f7c059f52122ef9c601695" translate="yes" xml:space="preserve">
          <source>The new user will not be a superuser. This is the default.</source>
          <target state="translated">新しいユーザーはスーパーユーザーにはなりません。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="72c465f76c8179666632ce0c6f15419c4133425d" translate="yes" xml:space="preserve">
          <source>The new user will not be allowed to create databases. This is the default.</source>
          <target state="translated">新しいユーザーはデータベースの作成を許可されません。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="32dd0b63f5a01c58c0731e9846c0b6a55a21f4f0" translate="yes" xml:space="preserve">
          <source>The new user will not be allowed to create new roles. This is the default.</source>
          <target state="translated">新しいユーザーが新しいロールを作成することはできません。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="87cc74c8ed55ae4e670446b51aab48e450dbc14b" translate="yes" xml:space="preserve">
          <source>The new user will not be allowed to log in. (A role without login privilege is still useful as a means of managing database permissions.)</source>
          <target state="translated">新しいユーザーにはログインが許可されません。(ログイン権限のないロールは、データベースの権限を管理する手段としてまだ有用です)。</target>
        </trans-unit>
        <trans-unit id="a13d7c8eff958866dd3c2de41dd7c33e5dff939b" translate="yes" xml:space="preserve">
          <source>The new user will not have the &lt;code&gt;REPLICATION&lt;/code&gt; privilege, which is described more fully in the documentation for &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;.</source>
          <target state="translated">新しいユーザーには &lt;code&gt;REPLICATION&lt;/code&gt; 特権がありません。これについては、&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLEの&lt;/a&gt;ドキュメントで詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="127849b8d3eea48eada06bb9a69ad7d49b073868" translate="yes" xml:space="preserve">
          <source>The new value for a table storage parameter. This might be a number or a word depending on the parameter.</source>
          <target state="translated">テーブルストレージパラメータの新しい値。これは、パラメータに応じて数値か単語になります。</target>
        </trans-unit>
        <trans-unit id="c290b36401426b8422b4d66e484cd2e82d3b87ce" translate="yes" xml:space="preserve">
          <source>The new value for an index-method-specific storage parameter. This might be a number or a word depending on the parameter.</source>
          <target state="translated">インデックス・メソッド固有のストレージ・パラメータの新しい値。これはパラメータに応じて数値か単語になります。</target>
        </trans-unit>
        <trans-unit id="c34da01d538b4bb95a9dcedad6f42505d9964bfa" translate="yes" xml:space="preserve">
          <source>The new value of the column</source>
          <target state="translated">カラムの新しい値</target>
        </trans-unit>
        <trans-unit id="9cc0b73abbe4bf474235a0a153fa246959f47339" translate="yes" xml:space="preserve">
          <source>The new value to be added to an enum type's list of values, or the new name to be given to an existing value. Like all enum literals, it needs to be quoted.</source>
          <target state="translated">列挙型の値のリストに追加される新しい値、または既存の値に与えられる新しい名前。すべての列挙型リテラルと同様に、引用符で囲まれている必要があります。</target>
        </trans-unit>
        <trans-unit id="3abd3f485b5c74bf1e64463613b4fb3d9ef53408" translate="yes" xml:space="preserve">
          <source>The new value to use for a template-specific option. If the equal sign and value are omitted, then any previous setting for the option is removed from the dictionary, allowing the default to be used.</source>
          <target state="translated">テンプレート固有のオプシ ョ ンに使用する新しい値。等号と値を省略した場合は、そのオプションに対する以前の設定はすべて辞書から削除され、デフォルトを使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="54266d9e3dff5c3d85bb17314ebcd06db8a0c4e2" translate="yes" xml:space="preserve">
          <source>The next example shows how to obtain the union of the tables &lt;code&gt;distributors&lt;/code&gt; and &lt;code&gt;actors&lt;/code&gt;, restricting the results to those that begin with the letter W in each table. Only distinct rows are wanted, so the key word &lt;code&gt;ALL&lt;/code&gt; is omitted.</source>
          <target state="translated">次の例は、 &lt;code&gt;distributors&lt;/code&gt; と &lt;code&gt;actors&lt;/code&gt; のテーブルの和集合を取得する方法を示し、結果を各テーブルの文字Wで始まるものに制限しています。個別の行のみが必要なので、キーワード &lt;code&gt;ALL&lt;/code&gt; は省略されます。</target>
        </trans-unit>
        <trans-unit id="0b983bad83edd443b7b8ce4de658661eaff249f8" translate="yes" xml:space="preserve">
          <source>The next step is to set the session to use the new configuration, which was created in the &lt;code&gt;public&lt;/code&gt; schema:</source>
          <target state="translated">次のステップは、 &lt;code&gt;public&lt;/code&gt; スキーマで作成された新しい構成を使用するようにセッションを設定することです。</target>
        </trans-unit>
        <trans-unit id="69b04f7d07fe975427e0f7bf99be4fe924c78cc6" translate="yes" xml:space="preserve">
          <source>The non-default GIN operator class &lt;code&gt;jsonb_path_ops&lt;/code&gt; supports indexing the &lt;code&gt;@&amp;gt;&lt;/code&gt; operator only. An example of creating an index with this operator class is:</source>
          <target state="translated">デフォルト以外のGIN演算子クラス &lt;code&gt;jsonb_path_ops&lt;/code&gt; は、 &lt;code&gt;@&amp;gt;&lt;/code&gt; 演算子のみのインデックス付けをサポートしています。この演算子クラスでインデックスを作成する例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="1d49459b2ff80f4c26bb14ba35712908d50a4f44" translate="yes" xml:space="preserve">
          <source>The normal PostgreSQL query optimizer performs a &lt;em&gt;near-exhaustive search&lt;/em&gt; over the space of alternative strategies. This algorithm, first introduced in IBM's System R database, produces a near-optimal join order, but can take an enormous amount of time and memory space when the number of joins in the query grows large. This makes the ordinary PostgreSQL query optimizer inappropriate for queries that join a large number of tables.</source>
          <target state="translated">通常のPostgreSQLクエリオプティマイザーは、代替戦略の領域に対して&lt;em&gt;ほぼ完全な検索&lt;/em&gt;を実行します。IBMのSystem Rデータベースで最初に導入されたこのアルゴリズムは、ほぼ最適な結合順序を生成しますが、クエリ内の結合の数が大きくなると、膨大な時間とメモリ領域を消費する可能性があります。これにより、通常のPostgreSQLクエリオプティマイザーは、多数のテーブルを結合するクエリには不適切になります。</target>
        </trans-unit>
        <trans-unit id="ddb0abe82fae0bb47141f78e86913e1352bb274e" translate="yes" xml:space="preserve">
          <source>The notations &lt;code&gt;varchar(n)&lt;/code&gt; and &lt;code&gt;char(n)&lt;/code&gt; are aliases for &lt;code&gt;character varying(n)&lt;/code&gt; and &lt;code&gt;character(n)&lt;/code&gt;, respectively. &lt;code&gt;character&lt;/code&gt; without length specifier is equivalent to &lt;code&gt;character(1)&lt;/code&gt;. If &lt;code&gt;character varying&lt;/code&gt; is used without length specifier, the type accepts strings of any size. The latter is a PostgreSQL extension.</source>
          <target state="translated">表記 &lt;code&gt;varchar(n)&lt;/code&gt; および &lt;code&gt;char(n)&lt;/code&gt; は、それぞれ &lt;code&gt;character varying(n)&lt;/code&gt; および &lt;code&gt;character(n)&lt;/code&gt; のエイリアスです。長さ指定子のない &lt;code&gt;character&lt;/code&gt; は、 &lt;code&gt;character(1)&lt;/code&gt; と同等です。 &lt;code&gt;character varying&lt;/code&gt; 指定が長さ指定子なしで使用される場合、型は任意のサイズの文字列を受け入れます。後者はPostgreSQLの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="fbc61286b42787c186b2be652915f7206bb4ed7e" translate="yes" xml:space="preserve">
          <source>The number of &lt;em&gt;key columns&lt;/em&gt; in the index, not counting any &lt;em&gt;included columns&lt;/em&gt;, which are merely stored and do not participate in the index semantics</source>
          <target state="translated">格納されているだけで、インデックスセマンティクスに参加していない、&lt;em&gt;含まれている列&lt;/em&gt;は数えない、インデックス内の&lt;em&gt;キー列&lt;/em&gt;の数&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="32236378278e06cdc1ed2783abcf03baa463efaf" translate="yes" xml:space="preserve">
          <source>The number of WAL segment files in &lt;code&gt;pg_wal&lt;/code&gt; directory depends on &lt;code&gt;min_wal_size&lt;/code&gt;, &lt;code&gt;max_wal_size&lt;/code&gt; and the amount of WAL generated in previous checkpoint cycles. When old log segment files are no longer needed, they are removed or recycled (that is, renamed to become future segments in the numbered sequence). If, due to a short-term peak of log output rate, &lt;code&gt;max_wal_size&lt;/code&gt; is exceeded, the unneeded segment files will be removed until the system gets back under this limit. Below that limit, the system recycles enough WAL files to cover the estimated need until the next checkpoint, and removes the rest. The estimate is based on a moving average of the number of WAL files used in previous checkpoint cycles. The moving average is increased immediately if the actual usage exceeds the estimate, so it accommodates peak usage rather than average usage to some extent. &lt;code&gt;min_wal_size&lt;/code&gt; puts a minimum on the amount of WAL files recycled for future usage; that much WAL is always recycled for future use, even if the system is idle and the WAL usage estimate suggests that little WAL is needed.</source>
          <target state="translated">&lt;code&gt;pg_wal&lt;/code&gt; ディレクトリ内のWALセグメントファイルの数は、 &lt;code&gt;min_wal_size&lt;/code&gt; 、 &lt;code&gt;max_wal_size&lt;/code&gt; 、および前のチェックポイントサイクルで生成されたWALの量に依存します。古いログセグメントファイルが不要になると、それらは削除またはリサイクルされます（つまり、番号が付けられたシーケンスの将来のセグメントになるように名前が変更されます）。ログ出力レートの短期間のピークにより、 &lt;code&gt;max_wal_size&lt;/code&gt; を超えると、システムがこの制限に戻るまで、不要なセグメントファイルが削除されます。この制限を下回ると、システムは、次のチェックポイントまでの推定必要量をカバーするのに十分なWALファイルをリサイクルし、残りを削除します。推定は、以前のチェックポイントサイクルで使用されたWALファイルの数の移動平均に基づいています。実際の使用量が見積もりを超えると、移動平均はすぐに増加するため、平均使用量ではなくピーク使用量にある程度対応できます。 &lt;code&gt;min_wal_size&lt;/code&gt; は、将来の使用のためにリサイクルされるWALファイルの量の最小値を設定します。その多くのWALは、システムがアイドル状態で、WAL使用量の見積もりからWALはほとんど必要ないことがわかっていても、将来の使用のために常にリサイクルされます。</target>
        </trans-unit>
        <trans-unit id="8748e9fef55cda632ea0102b0e063bbbb95c6586" translate="yes" xml:space="preserve">
          <source>The number of columns in partition key</source>
          <target state="translated">パーティションキーのカラム数</target>
        </trans-unit>
        <trans-unit id="edbeec849445e687cd12eea0389ae4b06b732e80" translate="yes" xml:space="preserve">
          <source>The number of direct ancestors this column has. A column with a nonzero number of ancestors cannot be dropped nor renamed.</source>
          <target state="translated">この列が持つ直接の先祖の数。先祖の数が0以外のカラムは、削除したり名前を変更したりすることはできません。</target>
        </trans-unit>
        <trans-unit id="d7208773dc180e0dd7b3e10265b4f310a20ba88e" translate="yes" xml:space="preserve">
          <source>The number of direct inheritance ancestors this constraint has. A constraint with a nonzero number of ancestors cannot be dropped nor renamed.</source>
          <target state="translated">この制約が持つ直接継承の先祖の数。祖先の数が0以外の制約は、削除したり名前を変更したりすることはできません。</target>
        </trans-unit>
        <trans-unit id="8301961997733ca48d253481eefaad3008a00674" translate="yes" xml:space="preserve">
          <source>The number of dirty buffers written in each round is based on the number of new buffers that have been needed by server processes during recent rounds. The average recent need is multiplied by &lt;code&gt;bgwriter_lru_multiplier&lt;/code&gt; to arrive at an estimate of the number of buffers that will be needed during the next round. Dirty buffers are written until there are that many clean, reusable buffers available. (However, no more than &lt;code&gt;bgwriter_lru_maxpages&lt;/code&gt; buffers will be written per round.) Thus, a setting of 1.0 represents a &amp;ldquo;just in time&amp;rdquo; policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">各ラウンドで書き込まれるダーティバッファーの数は、最近のラウンド中にサーバープロセスが必要とした新しいバッファーの数に基づいています。最近の平均の必要量に &lt;code&gt;bgwriter_lru_multiplier&lt;/code&gt; を掛けて、次のラウンドで必要になるバッファーの数の見積もりを導きます。ダーティバッファーは、クリーンで再利用可能なバッファーが利用可能になるまで書き込まれます。 （ただし、 &lt;code&gt;bgwriter_lru_maxpages&lt;/code&gt; 以下バッファはラウンドごとに書き込まれます。）したがって、1.0の設定は、必要と予測されるバッファの数を正確に書き込む「ジャストインタイム」ポリシーを表します。値が大きいと、需要の急増に対するある程度のクッションになりますが、値が小さいと、サーバープロセスが書き込みを意図的に行うことになります。デフォルトは2.0です。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="3d25f5401af5c842168f311144ea17e37058d652" translate="yes" xml:space="preserve">
          <source>The number of distinct nonnull data values in the column. A value greater than zero is the actual number of distinct values. A value less than zero is the negative of a multiplier for the number of rows in the table; for example, a column in which about 80% of the values are nonnull and each nonnull value appears about twice on average could be represented by &lt;code&gt;stadistinct&lt;/code&gt; = -0.4. A zero value means the number of distinct values is unknown.</source>
          <target state="translated">列内の個別の非nullデータ値の数。ゼロより大きい値は、個別の値の実際の数です。ゼロより小さい値は、テーブルの行数の乗数の負です。例えば、値の約80％が非NULLであり、それぞれ非NULL値を平均して二回について表示される列は、によって表すことができる &lt;code&gt;stadistinct&lt;/code&gt; = -0.4。ゼロの値は、異なる値の数が不明であることを意味します。</target>
        </trans-unit>
        <trans-unit id="8289805730489472578e3f27b2f1d288c0d7dec6" translate="yes" xml:space="preserve">
          <source>The number of iterations of the S2K algorithm to use. It must be a value between 1024 and 65011712, inclusive.</source>
          <target state="translated">使用するS2Kアルゴリズムの繰り返し回数を指定します.1024から65011712の間の値でなければなりません.</target>
        </trans-unit>
        <trans-unit id="9f0e73558363d09e86314a049abfbcf61eaf5cbd" translate="yes" xml:space="preserve">
          <source>The number of lexemes must be less than 2&lt;sup&gt;64&lt;/sup&gt;</source>
          <target state="translated">語彙素の数は2 &lt;sup&gt;64&lt;/sup&gt;未満でなければなりません&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d2adf53592a4a37e557ef19975d87459fecab27a" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to wait before reporting an authentication failure. The default is 0.</source>
          <target state="translated">認証失敗を報告するまでの待ち時間をミリ秒単位で指定します。既定値は 0 です。</target>
        </trans-unit>
        <trans-unit id="4848e62664c3602823768b8a292b1248da926aa5" translate="yes" xml:space="preserve">
          <source>The number of nodes (lexemes + operators) in a &lt;code&gt;tsquery&lt;/code&gt; must be less than 32,768</source>
          <target state="translated">&lt;code&gt;tsquery&lt;/code&gt; のノード（語彙素+演算子）の数は32,768未満である必要があります</target>
        </trans-unit>
        <trans-unit id="e36ab63c8c21311a28348db0c90c93619e02161d" translate="yes" xml:space="preserve">
          <source>The number of query cancels and the reason for them can be viewed using the &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; system view on the standby server. The &lt;code&gt;pg_stat_database&lt;/code&gt; system view also contains summary information.</source>
          <target state="translated">クエリのキャンセルの数とその理由は、スタンバイサーバーの &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; システムビューを使用して確認できます。 &lt;code&gt;pg_stat_database&lt;/code&gt; システムビューにも要約情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="9d730ed06cd7648c33a05712cd3d40df8021dd41" translate="yes" xml:space="preserve">
          <source>The number of repetitions of the index scan that should be factored into the cost estimates. This will typically be greater than one when considering a parameterized scan for use in the inside of a nestloop join. Note that the cost estimates should still be for just one scan; a larger &lt;em&gt;&lt;code&gt;loop_count&lt;/code&gt;&lt;/em&gt; means that it may be appropriate to allow for some caching effects across multiple scans.</source>
          <target state="translated">コストの見積もりに含める必要があるインデックススキャンの繰り返し数。ネストループ結合の内部で使用するためのパラメーター化されたスキャンを検討する場合、これは通常1より大きくなります。コストの見積もりは、まだ1回のスキャンである必要があります。&lt;em&gt; &lt;code&gt;loop_count&lt;/code&gt; &lt;/em&gt;が大きいほど、複数のスキャンにまたがるキャッシュ効果を考慮に入れることが適切な場合があります。</target>
        </trans-unit>
        <trans-unit id="166b286d18f619fbe9f6a3ea1bb840802689109b" translate="yes" xml:space="preserve">
          <source>The number of rows returned or affected by the last SQL query, or 0 if the query failed or did not report a row count.</source>
          <target state="translated">最後のSQLクエリによって返された、または影響を受けた行の数、またはクエリが失敗したか、行数が報告されなかった場合は0。</target>
        </trans-unit>
        <trans-unit id="1d69a3b171c0833334cc425ee7e0d762adec494e" translate="yes" xml:space="preserve">
          <source>The number of rows to skip before starting to return rows. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">行を返し始める前にスキップする行の数。詳細については、&lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt; &lt;code&gt;LIMIT&lt;/code&gt; 句を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="aade2c0dad75a39b57c1da4c3274b381a44640e8" translate="yes" xml:space="preserve">
          <source>The number of the ISO 8601 week-numbering week of the year. By definition, ISO weeks start on Mondays and the first week of a year contains January 4 of that year. In other words, the first Thursday of a year is in week 1 of that year.</source>
          <target state="translated">ISO 8601の週番付の1年の週の番号。定義により、ISOの週は月曜日から始まり、1年の第1週にはその年の1月4日が含まれています。言い換えれば、1年の最初の木曜日は、その年の第1週に含まれているということになります。</target>
        </trans-unit>
        <trans-unit id="4cb2d1007085e9fe567cf2f04104acbb29523d8d" translate="yes" xml:space="preserve">
          <source>The number of the column</source>
          <target state="translated">列の番号を表示します。</target>
        </trans-unit>
        <trans-unit id="17b9b1cbc38db2adfa96c6b3cafb442db5c59e27" translate="yes" xml:space="preserve">
          <source>The number of the column. Ordinary columns are numbered from 1 up. System columns, such as &lt;code&gt;ctid&lt;/code&gt;, have (arbitrary) negative numbers.</source>
          <target state="translated">列の番号。通常の列には、1から順に番号が付けられます。 &lt;code&gt;ctid&lt;/code&gt; などのシステム列には、（任意の）負の数があります。</target>
        </trans-unit>
        <trans-unit id="d5de13da859bcae07a08d4b002774933f9c4b34a" translate="yes" xml:space="preserve">
          <source>The number of the described column</source>
          <target state="translated">記載されている欄の番号</target>
        </trans-unit>
        <trans-unit id="8054a525924b0216f44b2c15796e49dd9491e9dd" translate="yes" xml:space="preserve">
          <source>The numbers provided by &lt;code&gt;BUFFERS&lt;/code&gt; help to identify which parts of the query are the most I/O-intensive.</source>
          <target state="translated">&lt;code&gt;BUFFERS&lt;/code&gt; によって提供される数値は、クエリのどの部分が最もI / O集中であるかを識別するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="c96b4217f4ff70cb5052589aed86a75a58ea381a" translate="yes" xml:space="preserve">
          <source>The obsolete options &lt;code&gt;SORT1&lt;/code&gt;, &lt;code&gt;SORT2&lt;/code&gt;, &lt;code&gt;LTCMP&lt;/code&gt;, and &lt;code&gt;GTCMP&lt;/code&gt; were formerly used to specify the names of sort operators associated with a merge-joinable operator. This is no longer necessary, since information about associated operators is found by looking at B-tree operator families instead. If one of these options is given, it is ignored except for implicitly setting &lt;code&gt;MERGES&lt;/code&gt; true.</source>
          <target state="translated">廃止されたオプション &lt;code&gt;SORT1&lt;/code&gt; 、 &lt;code&gt;SORT2&lt;/code&gt; 、 &lt;code&gt;LTCMP&lt;/code&gt; 、および &lt;code&gt;GTCMP&lt;/code&gt; は、以前は結合結合可能な演算子に関連付けられたソート演算子の名前を指定するために使用されていました。代わりに、関連する演算子に関する情報がBツリー演算子ファミリを調べることで見つかるので、これはもう必要ありません。これらのオプションのいずれかを指定すると、暗黙的に &lt;code&gt;MERGES&lt;/code&gt; が trueに設定されている場合を除いて、オプションは無視されます。</target>
        </trans-unit>
        <trans-unit id="c4bf61bc0ae75f599a4b04ad0336e82b98b0a3d1" translate="yes" xml:space="preserve">
          <source>The octet with decimal value 92 (backslash) is doubled in the output. Details are in &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-RESESC&quot;&gt;Table 8.8&lt;/a&gt;.</source>
          <target state="translated">10進数値92（バックスラッシュ）のオクテットは、出力で2倍になります。詳細を&lt;a href=&quot;datatype-binary#DATATYPE-BINARY-RESESC&quot;&gt;表8.8に示し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="51b42992b2dbbebe4441f992b139d475f2a6576d" translate="yes" xml:space="preserve">
          <source>The old indexes are dropped. The &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; session locks for the indexes and the table are released.</source>
          <target state="translated">古いインデックスは削除されます。インデックスとテーブルの &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; セッションロックが解放されます。</target>
        </trans-unit>
        <trans-unit id="aff5f1b14035796efdcabc3055a299cc4fcb8ba7" translate="yes" xml:space="preserve">
          <source>The old indexes have &lt;code&gt;pg_index.indisready&lt;/code&gt; switched to &amp;ldquo;false&amp;rdquo; to prevent any new tuple insertions, after waiting for running queries that might reference the old index to complete.</source>
          <target state="translated">古いインデックスを参照するクエリの実行が完了するのを待った後、新しいインデックスの挿入を防ぐために、古いインデックスは &lt;code&gt;pg_index.indisready&lt;/code&gt; を「false」に切り替えました。</target>
        </trans-unit>
        <trans-unit id="05be6eb32947b010e242b9b77a81ac45522407a1" translate="yes" xml:space="preserve">
          <source>The oldest transaction affecting the system catalogs that this slot needs the database to retain. &lt;code&gt;VACUUM&lt;/code&gt; cannot remove catalog tuples deleted by any later transaction.</source>
          <target state="translated">このスロットがデータベースを保持する必要があるシステムカタログに影響を与える最も古いトランザクション。 &lt;code&gt;VACUUM&lt;/code&gt; は、その後のトランザクションによって削除されたカタログタプルを削除できません。</target>
        </trans-unit>
        <trans-unit id="5faf9118a5f5509db65f9f3d1a55a7c88d7b4faa" translate="yes" xml:space="preserve">
          <source>The oldest transaction that this slot needs the database to retain. &lt;code&gt;VACUUM&lt;/code&gt; cannot remove tuples deleted by any later transaction.</source>
          <target state="translated">このスロットがデータベースを保持する必要がある最も古いトランザクション。 &lt;code&gt;VACUUM&lt;/code&gt; は、その後のトランザクションによって削除されたタプルを削除できません。</target>
        </trans-unit>
        <trans-unit id="f97ff854cd0196d6cae74ec459d42c99253ddda9" translate="yes" xml:space="preserve">
          <source>The only feature of AREs that is actually incompatible with POSIX EREs is that &lt;code&gt;\&lt;/code&gt; does not lose its special significance inside bracket expressions. All other ARE features use syntax which is illegal or has undefined or unspecified effects in POSIX EREs; the &lt;code&gt;***&lt;/code&gt; syntax of directors likewise is outside the POSIX syntax for both BREs and EREs.</source>
          <target state="translated">POSIX EREと実際に互換性がないAREの唯一の機能は、 &lt;code&gt;\&lt;/code&gt; が括弧式内の特別な意味を失わないことです。他のすべてのARE機能は、POSIX EREで違法または未定義または不特定の影響を持つ構文を使用します。同様に、ディレクターの &lt;code&gt;***&lt;/code&gt; 構文は、BREとEREの両方のPOSIX構文の外にあります。</target>
        </trans-unit>
        <trans-unit id="8a1895f6d1a24facb26fe1c49448d16cf40a3e4a" translate="yes" xml:space="preserve">
          <source>The only firm requirement for using NFS with PostgreSQL is that the file system is mounted using the &lt;code&gt;hard&lt;/code&gt; option. With the &lt;code&gt;hard&lt;/code&gt; option, processes can &amp;ldquo;hang&amp;rdquo; indefinitely if there are network problems, so this configuration will require a careful monitoring setup. The &lt;code&gt;soft&lt;/code&gt; option will interrupt system calls in case of network problems, but PostgreSQL will not repeat system calls interrupted in this way, so any such interruption will result in an I/O error being reported.</source>
          <target state="translated">PostgreSQLでNFSを使用するための唯一の確固たる要件は、ファイルシステムが &lt;code&gt;hard&lt;/code&gt; オプションを使用してマウントされていることです。 &lt;code&gt;hard&lt;/code&gt; ネットワークに問題がある場合は、この設定は注意深い監視のセットアップが必要になりますので、オプションで、プロセスは、無期限に「ハング」することができます。 &lt;code&gt;soft&lt;/code&gt; のオプションは、ネットワークの問題の場合のシステムコールを中断しますが、そのような中断が報告されているI / Oエラーになりますので、PostgreSQLは繰り返しませんシステムコールは、このように中断されます。</target>
        </trans-unit>
        <trans-unit id="a396e16c5e2752bf51d263513d40dc846694333b" translate="yes" xml:space="preserve">
          <source>The only parameter required by the &lt;code&gt;synonym&lt;/code&gt; template is &lt;code&gt;SYNONYMS&lt;/code&gt;, which is the base name of its configuration file &amp;mdash; &lt;code&gt;my_synonyms&lt;/code&gt; in the above example. The file's full name will be &lt;code&gt;$SHAREDIR/tsearch_data/my_synonyms.syn&lt;/code&gt; (where &lt;code&gt;$SHAREDIR&lt;/code&gt; means the PostgreSQL installation's shared-data directory). The file format is just one line per word to be substituted, with the word followed by its synonym, separated by white space. Blank lines and trailing spaces are ignored.</source>
          <target state="translated">&lt;code&gt;synonym&lt;/code&gt; テンプレートで必要な唯一のパラメーターは &lt;code&gt;SYNONYMS&lt;/code&gt; です。これは、その構成ファイルのベース名です- 上記の例では &lt;code&gt;my_synonyms&lt;/code&gt; です。ファイルのフルネームは &lt;code&gt;$SHAREDIR/tsearch_data/my_synonyms.syn&lt;/code&gt; （ &lt;code&gt;$SHAREDIR&lt;/code&gt; はPostgreSQLインストールの共有データディレクトリを意味します）。ファイル形式は、置換される単語ごとに1行だけで、単語の後には同義語が続き、空白で区切られます。空白行と末尾のスペースは無視されます。</target>
        </trans-unit>
        <trans-unit id="a030d7c4538742e2439ddd895553830f470ea35b" translate="yes" xml:space="preserve">
          <source>The operations that occur on both primary and standby servers are normal continuous archiving and recovery tasks. The only point of contact between the two database servers is the archive of WAL files that both share: primary writing to the archive, standby reading from the archive. Care must be taken to ensure that WAL archives from separate primary servers do not become mixed together or confused. The archive need not be large if it is only required for standby operation.</source>
          <target state="translated">プライマリサーバーとスタンバイサーバーの両方で発生する操作は、通常の継続的なアーカイブおよびリカバリタスクです。2つのデータベースサーバー間の唯一の接点は、両方が共有しているWALファイルのアーカイブです:アーカイブへのプライマリ書き込み、アーカイブからのスタンバイ読み込み。別々のプライマリサーバからの WAL アーカイブが混在したり、混同したりしないように注意しなければなりません。アーカイブは、待機動作のためだけに必要なものであれば、大きくする必要はありません。</target>
        </trans-unit>
        <trans-unit id="78a77532759d107a293f71b3071e91121689e001" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;!=&lt;/code&gt; is mapped to &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; on input, so these two names are always equivalent.</source>
          <target state="translated">演算子 &lt;code&gt;!=&lt;/code&gt; は入力時に &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; にマップされるため、これら2つの名前は常に同等です。</target>
        </trans-unit>
        <trans-unit id="7680d70684ff5657bfcc4e3b94f75e49715485f1" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;~~&lt;/code&gt; is equivalent to &lt;code&gt;LIKE&lt;/code&gt;, and &lt;code&gt;~~*&lt;/code&gt; corresponds to &lt;code&gt;ILIKE&lt;/code&gt;. There are also &lt;code&gt;!~~&lt;/code&gt; and &lt;code&gt;!~~*&lt;/code&gt; operators that represent &lt;code&gt;NOT LIKE&lt;/code&gt; and &lt;code&gt;NOT ILIKE&lt;/code&gt;, respectively. All of these operators are PostgreSQL-specific.</source>
          <target state="translated">演算子 &lt;code&gt;~~&lt;/code&gt; は &lt;code&gt;LIKE&lt;/code&gt; と同等であり、 &lt;code&gt;~~*&lt;/code&gt; は &lt;code&gt;ILIKE&lt;/code&gt; に対応します。また、それぞれ &lt;code&gt;NOT LIKE&lt;/code&gt; および &lt;code&gt;NOT ILIKE&lt;/code&gt; を表す &lt;code&gt;!~~&lt;/code&gt; および &lt;code&gt;!~~*&lt;/code&gt; 演算子もあります。これらの演算子はすべてPostgreSQL固有です。</target>
        </trans-unit>
        <trans-unit id="1d017a3795e4c2a850feefb2cba71cdbcd408d49" translate="yes" xml:space="preserve">
          <source>The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on the type &lt;code&gt;int4&lt;/code&gt; would use the &lt;code&gt;int4_ops&lt;/code&gt; class; this operator class includes comparison functions for values of type &lt;code&gt;int4&lt;/code&gt;. In practice the default operator class for the column's data type is usually sufficient. The main reason for having operator classes is that for some data types, there could be more than one meaningful index behavior. For example, we might want to sort a complex-number data type either by absolute value or by real part. We could do this by defining two operator classes for the data type and then selecting the proper class when making an index. The operator class determines the basic sort ordering (which can then be modified by adding sort options &lt;code&gt;COLLATE&lt;/code&gt;, &lt;code&gt;ASC&lt;/code&gt;/&lt;code&gt;DESC&lt;/code&gt; and/or &lt;code&gt;NULLS FIRST&lt;/code&gt;/&lt;code&gt;NULLS LAST&lt;/code&gt;).</source>
          <target state="translated">演算子クラスは、その列のインデックスで使用される演算子を識別します。例えば、型上のB-treeインデックス &lt;code&gt;int4&lt;/code&gt; 使用する &lt;code&gt;int4_ops&lt;/code&gt; クラスと、この演算子クラスには、 &lt;code&gt;int4&lt;/code&gt; 型の値の比較関数が含まれています。実際には、列のデータ型のデフォルトの演算子クラスで通常は十分です。演算子クラスがある主な理由は、一部のデータ型では、複数の意味のあるインデックス動作が存在する可能性があるためです。たとえば、絶対値または実部のいずれかで複素数データ型を並べ替えることができます。これを行うには、データ型に2つの演算子クラスを定義し、インデックスを作成するときに適切なクラスを選択します。演算子クラスは、基本的な並べ替え順序を決定します（並べ替えオプション &lt;code&gt;COLLATE&lt;/code&gt; 、 &lt;code&gt;ASC&lt;/code&gt; / &lt;code&gt;DESC&lt;/code&gt; および/または &lt;code&gt;NULLS FIRST&lt;/code&gt; / &lt;code&gt;NULLS LAST&lt;/code&gt; を追加することで変更できます）。</target>
        </trans-unit>
        <trans-unit id="79d3ccfc646e039879a5fc434785db86b4443933" translate="yes" xml:space="preserve">
          <source>The operator classes &lt;code&gt;text_pattern_ops&lt;/code&gt;, &lt;code&gt;varchar_pattern_ops&lt;/code&gt;, and &lt;code&gt;bpchar_pattern_ops&lt;/code&gt; support B-tree indexes on the types &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char&lt;/code&gt; respectively. The difference from the default operator classes is that the values are compared strictly character by character rather than according to the locale-specific collation rules. This makes these operator classes suitable for use by queries involving pattern matching expressions (&lt;code&gt;LIKE&lt;/code&gt; or POSIX regular expressions) when the database does not use the standard &amp;ldquo;C&amp;rdquo; locale. As an example, you might index a &lt;code&gt;varchar&lt;/code&gt; column like this:</source>
          <target state="translated">演算子クラス &lt;code&gt;text_pattern_ops&lt;/code&gt; 、 &lt;code&gt;varchar_pattern_ops&lt;/code&gt; 、および &lt;code&gt;bpchar_pattern_ops&lt;/code&gt; は、それぞれタイプ &lt;code&gt;text&lt;/code&gt; 、 &lt;code&gt;varchar&lt;/code&gt; 、および &lt;code&gt;char&lt;/code&gt; の Bツリーインデックスをサポートします。デフォルトの演算子クラスとの違いは、値がロケール固有の照合規則に従ってではなく、文字ごとに厳密に比較されることです。これにより、データベースが標準の「C」ロケールを使用しない場合、これらの演算子クラスは、パターンマッチング式（ &lt;code&gt;LIKE&lt;/code&gt; またはPOSIX正規表現）を含むクエリでの使用に適しています。例として、次のように &lt;code&gt;varchar&lt;/code&gt; 列にインデックスを付けることができます。</target>
        </trans-unit>
        <trans-unit id="33bad4a7b35adf68e8d48de054b950c2d1ec9c35" translate="yes" xml:space="preserve">
          <source>The operator family this entry is for</source>
          <target state="translated">このエントリが対象とするオペレータファミリ</target>
        </trans-unit>
        <trans-unit id="223e98e65916141080aa613ffd5f9982aa449061" translate="yes" xml:space="preserve">
          <source>The operator name is a sequence of up to &lt;code&gt;NAMEDATALEN&lt;/code&gt;-1 (63 by default) characters from the following list:</source>
          <target state="translated">オペレーター名は、以下のリストの &lt;code&gt;NAMEDATALEN&lt;/code&gt; -1（デフォルトでは63）文字までのシーケンスです。</target>
        </trans-unit>
        <trans-unit id="e93319af4ff4ab58e4fcfce194629f2f03f458a1" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;@&lt;/code&gt; are equivalent to PostgreSQL's built-in operators of the same names, except that they work only on integer arrays that do not contain nulls, while the built-in operators work for any array type. This restriction makes them faster than the built-in operators in many cases.</source>
          <target state="translated">演算子 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;@&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;lt;@&lt;/code&gt; は、NULLを含まない整数配列でのみ機能し、組み込み演算子は任意の配列型で機能することを除いて、同じ名前のPostgreSQLの組み込み演算子と同等です。この制限により、多くの場合、組み込み演算子よりも高速になります。</target>
        </trans-unit>
        <trans-unit id="a0d063cd8a5cd2a97ff1408a1433cc81fe5925af" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;&amp;lt;@&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; have analogues &lt;code&gt;^&amp;lt;@&lt;/code&gt;, &lt;code&gt;^@&amp;gt;&lt;/code&gt;, &lt;code&gt;^@&lt;/code&gt;, &lt;code&gt;^~&lt;/code&gt;, which are the same except they do not use indexes. These are useful only for testing purposes.</source>
          <target state="translated">演算子 &lt;code&gt;&amp;lt;@&lt;/code&gt; 、 &lt;code&gt;@&amp;gt;&lt;/code&gt; 、 &lt;code&gt;@&lt;/code&gt; 、 &lt;code&gt;~&lt;/code&gt; は類似の &lt;code&gt;^&amp;lt;@&lt;/code&gt; 、 &lt;code&gt;^@&amp;gt;&lt;/code&gt; 、 &lt;code&gt;^@&lt;/code&gt; 、 &lt;code&gt;^~&lt;/code&gt; 、インデックスを使用しないことを除いて同じです。これらは、テスト目的でのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="fbca8888a118f48ef45503ea9b2b65638278cb3a" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;AND&lt;/code&gt; and &lt;code&gt;OR&lt;/code&gt; are commutative, that is, you can switch the left and right operand without affecting the result. But see &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt; for more information about the order of evaluation of subexpressions.</source>
          <target state="translated">演算子 &lt;code&gt;AND&lt;/code&gt; および &lt;code&gt;OR&lt;/code&gt; は交換可能です。つまり、結果に影響を与えることなく、左と右のオペランドを切り替えることができます。ただし、部分式の評価順序の詳細については、&lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;セクション4.2.14&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="afda15b721563ddc4ee8a5707f908cf503dfae35" translate="yes" xml:space="preserve">
          <source>The operators provided by the &lt;code&gt;hstore&lt;/code&gt; module are shown in &lt;a href=&quot;hstore#HSTORE-OP-TABLE&quot;&gt;Table F.7&lt;/a&gt;, the functions in &lt;a href=&quot;hstore#HSTORE-FUNC-TABLE&quot;&gt;Table F.8&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; モジュールが提供する演算子を&lt;a href=&quot;hstore#HSTORE-OP-TABLE&quot;&gt;表F.7&lt;/a&gt;に、関数を&lt;a href=&quot;hstore#HSTORE-FUNC-TABLE&quot;&gt;表F.8に示し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="43de536c659d022d6659ab7d7ed96e1f9a44966b" translate="yes" xml:space="preserve">
          <source>The operators should not be defined by SQL functions. A SQL function is likely to be inlined into the calling query, which will prevent the optimizer from recognizing that the query matches an index.</source>
          <target state="translated">演算子はSQL関数で定義すべきではありません。SQL関数は呼び出したクエリの中にインライン化されている可能性が高く、オプティマイザがクエリがインデックスにマッチしていることを認識できなくなります。</target>
        </trans-unit>
        <trans-unit id="c7779f9394f3c14857d843cdc250d88697a649fe" translate="yes" xml:space="preserve">
          <source>The optimal value for this option depends on the hardware setup of the server, of the client, and of the network. Factors include the number of CPU cores and the disk setup. A good place to start is the number of CPU cores on the server, but values larger than that can also lead to faster restore times in many cases. Of course, values that are too high will lead to decreased performance because of thrashing.</source>
          <target state="translated">このオプションの最適値は、サーバ、クライアント、ネットワークのハードウェア設定に依存します。要因には、CPU コア数とディスクの設定が含まれます。サーバの CPU コア数から始めるのが良いでしょうが、これよりも大きい値を設定すると、多くの場合、リストア時間を短縮することができます。もちろん、高すぎる値はスラッシングのためにパフォーマンスの低下につながります。</target>
        </trans-unit>
        <trans-unit id="d0eb1545843db39f7e5b62a874b3d76a7289a03a" translate="yes" xml:space="preserve">
          <source>The optimizer can also use a B-tree index for queries involving the pattern matching operators &lt;code&gt;LIKE&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;&lt;em&gt;if&lt;/em&gt; the pattern is a constant and is anchored to the beginning of the string &amp;mdash; for example, &lt;code&gt;col LIKE 'foo%'&lt;/code&gt; or &lt;code&gt;col ~ '^foo'&lt;/code&gt;, but not &lt;code&gt;col LIKE '%bar'&lt;/code&gt;. However, if your database does not use the C locale you will need to create the index with a special operator class to support indexing of pattern-matching queries; see &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; below. It is also possible to use B-tree indexes for &lt;code&gt;ILIKE&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt;, but only if the pattern starts with non-alphabetic characters, i.e., characters that are not affected by upper/lower case conversion.</source>
          <target state="translated">パターンが定数で文字列の先頭にアンカーされている&lt;em&gt;場合&lt;/em&gt;、オプティマイザはパターンマッチング演算子 &lt;code&gt;LIKE&lt;/code&gt; および &lt;code&gt;~&lt;/code&gt; を含むクエリにBツリーインデックスを使用することもできます。たとえば、 &lt;code&gt;col LIKE 'foo%'&lt;/code&gt; または &lt;code&gt;col ~ '^foo'&lt;/code&gt; 、ただし &lt;code&gt;col LIKE '%bar'&lt;/code&gt; はありません。ただし、データベースでCロケールを使用しない場合は、パターンマッチングクエリのインデックス作成をサポートするために、特別な演算子クラスを使用してインデックスを作成する必要があります。以下の&lt;a href=&quot;indexes-opclass&quot;&gt;セクション11.10を&lt;/a&gt;参照してください。 &lt;code&gt;ILIKE&lt;/code&gt; および &lt;code&gt;~*&lt;/code&gt; Bツリーインデックスを使用することもできます。&lt;em&gt;&lt;/em&gt;、ただしパターンがアルファベット以外の文字、つまり大文字と小文字の変換の影響を受けない文字で始まる場合のみ。</target>
        </trans-unit>
        <trans-unit id="8627270becb595b05140641f72d8445a0f79aa4e" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;STORED&lt;/code&gt; is not standard but is also used by other SQL implementations. The SQL standard does not specify the storage of generated columns.</source>
          <target state="translated">オプション &lt;code&gt;STORED&lt;/code&gt; は標準ではありませんが、他のSQL実装でも使用されます。SQL標準では、生成された列のストレージは指定されていません。</target>
        </trans-unit>
        <trans-unit id="734d38a3ce131eec63febbaae7def3c5bde63bbb" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_basebackup doesn't connect to any particular database in the cluster, database name in the connection string will be ignored.</source>
          <target state="translated">このオプションは他のクライアントアプリケーションとの一貫性を &lt;code&gt;--dbname&lt;/code&gt; ために--dbnameと呼ばれますが、pg_basebackupはクラスター内の特定のデータベースに接続しないため、接続文字列のデータベース名は無視されます。</target>
        </trans-unit>
        <trans-unit id="0db5016ffe3da0ce1e6c9b806713d2a3baee1dd9" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_dumpall needs to connect to many databases, the database name in the connection string will be ignored. Use the &lt;code&gt;-l&lt;/code&gt; option to specify the name of the database used for the initial connection, which will dump global objects and discover what other databases should be dumped.</source>
          <target state="translated">このオプションは他のクライアントアプリケーションとの一貫性を &lt;code&gt;--dbname&lt;/code&gt; ために--dbnameと呼ばれますが、pg_dumpallは多くのデータベースに接続する必要があるため、接続文字列のデータベース名は無視されます。使用 &lt;code&gt;-l&lt;/code&gt; グローバルオブジェクトをダンプし、他のデータベースをダンプする必要があるものを発見する最初の接続に使用するデータベースの名前を指定するオプション。</target>
        </trans-unit>
        <trans-unit id="b6f402f5f677410d43632fdfdda39802e1f95c15" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_receivewal doesn't connect to any particular database in the cluster, database name in the connection string will be ignored.</source>
          <target state="translated">このオプションは他のクライアントアプリケーションとの一貫性を &lt;code&gt;--dbname&lt;/code&gt; ために--dbnameと呼ばれますが、pg_receivewalはクラスター内の特定のデータベースに接続しないため、接続文字列のデータベース名は無視されます。</target>
        </trans-unit>
        <trans-unit id="c7c64ec896dfd3c50e33366b062eb4c419c8b0b7" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;CYCLE&lt;/code&gt; key word can be used to enable the sequence to wrap around when the &lt;code&gt;maxvalue&lt;/code&gt; or &lt;code&gt;minvalue&lt;/code&gt; has been reached by an ascending or descending sequence respectively. If the limit is reached, the next number generated will be the &lt;code&gt;minvalue&lt;/code&gt; or &lt;code&gt;maxvalue&lt;/code&gt;, respectively.</source>
          <target state="translated">任意 &lt;code&gt;CYCLE&lt;/code&gt; のキー・ワードは、場合周りにラップする配列を可能にするために使用することができる &lt;code&gt;maxvalue&lt;/code&gt; または &lt;code&gt;minvalue&lt;/code&gt; 昇順またはそれぞれ降順によって到達されました。限界に達した場合、生成された次数があろう &lt;code&gt;minvalue&lt;/code&gt; または &lt;code&gt;maxvalue&lt;/code&gt; それぞれ。</target>
        </trans-unit>
        <trans-unit id="2bdec9ebdf4b00fd140bf7dd49f116ee6c5a4a50" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;GROUP BY&lt;/code&gt; clause has the general form</source>
          <target state="translated">オプションの &lt;code&gt;GROUP BY&lt;/code&gt; 句の一般的な形式</target>
        </trans-unit>
        <trans-unit id="9c06d7f3daaeb4524eeb820424e28a6752ac9545" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;HAVING&lt;/code&gt; clause has the general form</source>
          <target state="translated">オプションの &lt;code&gt;HAVING&lt;/code&gt; 句の一般的な形式</target>
        </trans-unit>
        <trans-unit id="e76a720d25d7bf8d3cf5b4abaa11a67203b026f7" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;INCLUDE&lt;/code&gt; clause specifies a list of columns which will be included in the index as &lt;em&gt;non-key&lt;/em&gt; columns. A non-key column cannot be used in an index scan search qualification, and it is disregarded for purposes of any uniqueness or exclusion constraint enforced by the index. However, an index-only scan can return the contents of non-key columns without having to visit the index's table, since they are available directly from the index entry. Thus, addition of non-key columns allows index-only scans to be used for queries that otherwise could not use them.</source>
          <target state="translated">オプションの &lt;code&gt;INCLUDE&lt;/code&gt; 句は、&lt;em&gt;非キー&lt;/em&gt;列としてインデックスに含まれる列のリストを指定します。非キー列は、インデックススキャンの検索条件では使用できません。また、インデックスによって実施される一意性または除外制約のために無視されます。ただし、インデックスのみのスキャンでは、インデックスエントリから直接使用できるため、インデックスのテーブルにアクセスしなくても、非キーカラムの内容を返すことができます。したがって、非キー列を追加すると、インデックスのみのスキャンを、他の方法では使用できなかったクエリに使用できます。</target>
        </trans-unit>
        <trans-unit id="2aa8e8dd6edbe127a1d3d92fe785e89d8eca0bac" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;INHERITS&lt;/code&gt; clause specifies a list of tables from which the new foreign table automatically inherits all columns. Parent tables can be plain tables or foreign tables. See the similar form of &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">オプションの &lt;code&gt;INHERITS&lt;/code&gt; 句は、新しい外部テーブルがすべての列を自動的に継承するテーブルのリストを指定します。親テーブルは、プレーンテーブルまたは外部テーブルにすることができます。詳細については、同様の形式の&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d357ec942143a3e86ce2ca9c6595bccf9733322e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;INHERITS&lt;/code&gt; clause specifies a list of tables from which the new table automatically inherits all columns. Parent tables can be plain tables or foreign tables.</source>
          <target state="translated">オプションの &lt;code&gt;INHERITS&lt;/code&gt; 句は、新しいテーブルがすべての列を自動的に継承するテーブルのリストを指定します。親テーブルは、プレーンテーブルまたは外部テーブルにすることができます。</target>
        </trans-unit>
        <trans-unit id="935c04d83e4414228c1da5a13e9997ce0d9aed17" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;LANGUAGE&lt;/code&gt; clause can be written either before or after the code block.</source>
          <target state="translated">オプションの &lt;code&gt;LANGUAGE&lt;/code&gt; 句は、コードブロックの前または後に記述できます。</target>
        </trans-unit>
        <trans-unit id="4b362bf605fea7a639d64d32d41debf1c9b97b1a" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;ON CONFLICT&lt;/code&gt; clause specifies an alternative action to raising a unique violation or exclusion constraint violation error. For each individual row proposed for insertion, either the insertion proceeds, or, if an &lt;em&gt;arbiter&lt;/em&gt; constraint or index specified by &lt;em&gt;&lt;code&gt;conflict_target&lt;/code&gt;&lt;/em&gt; is violated, the alternative &lt;em&gt;&lt;code&gt;conflict_action&lt;/code&gt;&lt;/em&gt; is taken. &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; simply avoids inserting a row as its alternative action. &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; updates the existing row that conflicts with the row proposed for insertion as its alternative action.</source>
          <target state="translated">オプションの &lt;code&gt;ON CONFLICT&lt;/code&gt; 句は、一意の違反または除外制約違反エラーを発生させる代替アクションを指定します。挿入が提案された個々の行ごとに、挿入が続行されるか、&lt;em&gt; &lt;code&gt;conflict_target&lt;/code&gt; &lt;/em&gt;で指定された&lt;em&gt;アービター&lt;/em&gt;制約またはインデックスに違反した場合は、代替の&lt;em&gt; &lt;code&gt;conflict_action&lt;/code&gt; &lt;/em&gt;が実行されます。 &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; は、代替アクションとして行を挿入することを単に回避します。 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; は、代替アクションとして挿入が提案された行と競合する既存の行を更新します。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5dd05dee5b8b79438a7ed8440a1b3f1d3a71ea3" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;ORDER BY&lt;/code&gt; clause has this general form:</source>
          <target state="translated">オプションの &lt;code&gt;ORDER BY&lt;/code&gt; 句の一般的な形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="7116353ef7e307ca01f79a625c49cbb834ed45dc" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;PARTITION BY&lt;/code&gt; clause specifies a strategy of partitioning the table. The table thus created is called a &lt;em&gt;partitioned&lt;/em&gt; table. The parenthesized list of columns or expressions forms the &lt;em&gt;partition key&lt;/em&gt; for the table. When using range or hash partitioning, the partition key can include multiple columns or expressions (up to 32, but this limit can be altered when building PostgreSQL), but for list partitioning, the partition key must consist of a single column or expression.</source>
          <target state="translated">オプションの &lt;code&gt;PARTITION BY&lt;/code&gt; 句は、テーブルを分割する方法を指定します。このようにして作成されたテーブルは、&lt;em&gt;パーティション&lt;/em&gt;テーブルと呼ば&lt;em&gt;れ&lt;/em&gt;ます。括弧で囲まれた列または式のリストは、テーブルの&lt;em&gt;パーティションキー&lt;/em&gt;を形成します。範囲またはハッシュパーティションを使用する場合、パーティションキーには複数の列または式を含めることができますが（最大32ですが、この制限はPostgreSQLの構築時に変更できます）、リストパーティションの場合、パーティションキーは単一の列または式で構成する必要があります。</target>
        </trans-unit>
        <trans-unit id="f6243054cea2c976be92eb3f4ea9df686539e824" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RECURSIVE&lt;/code&gt; modifier changes &lt;code&gt;WITH&lt;/code&gt; from a mere syntactic convenience into a feature that accomplishes things not otherwise possible in standard SQL. Using &lt;code&gt;RECURSIVE&lt;/code&gt;, a &lt;code&gt;WITH&lt;/code&gt; query can refer to its own output. A very simple example is this query to sum the integers from 1 through 100:</source>
          <target state="translated">オプションの &lt;code&gt;RECURSIVE&lt;/code&gt; 修飾子は、 &lt;code&gt;WITH&lt;/code&gt; を単なる構文上の便利さから、標準のSQLでは不可能なことを実行する機能に変更します。 &lt;code&gt;RECURSIVE&lt;/code&gt; を使用すると、 &lt;code&gt;WITH&lt;/code&gt; クエリは自身の出力を参照できます。非常に単純な例は、1から100までの整数を合計する次のクエリです。</target>
        </trans-unit>
        <trans-unit id="fadff698169cd4951ccc6a878ef428bb081f97f0" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;REPEATABLE&lt;/code&gt; clause specifies a &lt;code&gt;seed&lt;/code&gt; number or expression to use for generating random numbers within the sampling method. The seed value can be any non-null floating-point value. Two queries that specify the same seed and &lt;code&gt;argument&lt;/code&gt; values will select the same sample of the table, if the table has not been changed meanwhile. But different seed values will usually produce different samples. If &lt;code&gt;REPEATABLE&lt;/code&gt; is not given then a new random sample is selected for each query, based upon a system-generated seed. Note that some add-on sampling methods do not accept &lt;code&gt;REPEATABLE&lt;/code&gt;, and will always produce new samples on each use.</source>
          <target state="translated">オプションの &lt;code&gt;REPEATABLE&lt;/code&gt; 句は、サンプリング方法内で乱数を生成するために使用する &lt;code&gt;seed&lt;/code&gt; 番号または式を指定します。シード値には、null以外の任意の浮動小数点値を指定できます。その間にテーブルが変更されていない場合、同じシードと &lt;code&gt;argument&lt;/code&gt; 値を指定する2つのクエリは、テーブルの同じサンプルを選択します。ただし、シード値が異なると、通常は異なるサンプルが生成されます。 &lt;code&gt;REPEATABLE&lt;/code&gt; が指定されていない場合、システムで生成されたシードに基づいて、クエリごとに新しいランダムサンプルが選択されます。一部のアドオンサンプリングメソッドは &lt;code&gt;REPEATABLE&lt;/code&gt; を受け入れず、使用するたびに常に新しいサンプルを生成することに注意してください。</target>
        </trans-unit>
        <trans-unit id="8777d7f8d07792d4f3e98ee0b8208d63db9f0b46" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RETURNING&lt;/code&gt; clause causes &lt;code&gt;DELETE&lt;/code&gt; to compute and return value(s) based on each row actually deleted. Any expression using the table's columns, and/or columns of other tables mentioned in &lt;code&gt;USING&lt;/code&gt;, can be computed. The syntax of the &lt;code&gt;RETURNING&lt;/code&gt; list is identical to that of the output list of &lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">オプションの &lt;code&gt;RETURNING&lt;/code&gt; 句を使用すると、 &lt;code&gt;DELETE&lt;/code&gt; は実際に削除された各行に基づいて値を計算して返します。テーブルの列や &lt;code&gt;USING&lt;/code&gt; で言及された他のテーブルの列、あるいはその両方を使用する式はすべて計算できます。 &lt;code&gt;RETURNING&lt;/code&gt; リストの構文は、 &lt;code&gt;SELECT&lt;/code&gt; の出力リストの構文と同じです。</target>
        </trans-unit>
        <trans-unit id="3578c21272426a6d018e36dbe114df05af571e18" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RETURNING&lt;/code&gt; clause causes &lt;code&gt;INSERT&lt;/code&gt; to compute and return value(s) based on each row actually inserted (or updated, if an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause was used). This is primarily useful for obtaining values that were supplied by defaults, such as a serial sequence number. However, any expression using the table's columns is allowed. The syntax of the &lt;code&gt;RETURNING&lt;/code&gt; list is identical to that of the output list of &lt;code&gt;SELECT&lt;/code&gt;. Only rows that were successfully inserted or updated will be returned. For example, if a row was locked but not updated because an &lt;code&gt;ON CONFLICT DO UPDATE ... WHERE&lt;/code&gt; clause &lt;code&gt;condition&lt;/code&gt; was not satisfied, the row will not be returned.</source>
          <target state="translated">オプションの &lt;code&gt;RETURNING&lt;/code&gt; 句を使用すると、 &lt;code&gt;INSERT&lt;/code&gt; は実際に挿入された（または &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 句が使用された場合は更新された）各行に基づいて値を計算して返します。これは主に、シリアルシーケンス番号など、デフォルトで提供された値を取得するのに役立ちます。ただし、テーブルの列を使用する式は許可されます。 &lt;code&gt;RETURNING&lt;/code&gt; リストの構文は、 &lt;code&gt;SELECT&lt;/code&gt; の出力リストの構文と同じです。正常に挿入または更新された行のみが返されます。たとえば、 &lt;code&gt;ON CONFLICT DO UPDATE ... WHERE&lt;/code&gt; 句の &lt;code&gt;condition&lt;/code&gt; が満たされていないために行がロックされたが更新されなかった場合、行は返されません。</target>
        </trans-unit>
        <trans-unit id="26fec39eb66cc8ba300ea17034aad6e1ab719ea0" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RETURNING&lt;/code&gt; clause causes &lt;code&gt;UPDATE&lt;/code&gt; to compute and return value(s) based on each row actually updated. Any expression using the table's columns, and/or columns of other tables mentioned in &lt;code&gt;FROM&lt;/code&gt;, can be computed. The new (post-update) values of the table's columns are used. The syntax of the &lt;code&gt;RETURNING&lt;/code&gt; list is identical to that of the output list of &lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">オプションの &lt;code&gt;RETURNING&lt;/code&gt; 句を使用すると、 &lt;code&gt;UPDATE&lt;/code&gt; は実際に更新された各行に基づいて値を計算して返します。テーブルの列、および/または &lt;code&gt;FROM&lt;/code&gt; で言及された他のテーブルの列を使用する式はすべて計算できます。テーブルの列の新しい（更新後）値が使用されます。 &lt;code&gt;RETURNING&lt;/code&gt; リストの構文は、 &lt;code&gt;SELECT&lt;/code&gt; の出力リストの構文と同じです。</target>
        </trans-unit>
        <trans-unit id="7038a19db2dc16317b16f8d00a20421d7087db41" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WHERE&lt;/code&gt; clause has the general form</source>
          <target state="translated">オプションの &lt;code&gt;WHERE&lt;/code&gt; 句の一般的な形式</target>
        </trans-unit>
        <trans-unit id="7792c91023d2f01afcab3c87bb09f61e0ba95957" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses in the table expression specify a pipeline of successive transformations performed on the table derived in the &lt;code&gt;FROM&lt;/code&gt; clause. All these transformations produce a virtual table that provides the rows that are passed to the select list to compute the output rows of the query.</source>
          <target state="translated">テーブル式のオプションの &lt;code&gt;WHERE&lt;/code&gt; 、 &lt;code&gt;GROUP BY&lt;/code&gt; 、および &lt;code&gt;HAVING&lt;/code&gt; 句は、 &lt;code&gt;FROM&lt;/code&gt; 句で派生したテーブルで実行される連続する変換のパイプラインを指定します。これらの変換はすべて、クエリの出力行を計算するために選択リストに渡される行を提供する仮想テーブルを生成します。</target>
        </trans-unit>
        <trans-unit id="8a3824e49e923ca91de9f24e0e18785c61620d57" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WINDOW&lt;/code&gt; clause has the general form</source>
          <target state="translated">オプションの &lt;code&gt;WINDOW&lt;/code&gt; 句の一般的な形式</target>
        </trans-unit>
        <trans-unit id="0734bf4cc1224dac3864d0137b3f27ef1692d40c" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WITH&lt;/code&gt; clause specifies &lt;em&gt;storage parameters&lt;/em&gt; for the index. Each index method has its own set of allowed storage parameters. The B-tree, hash, GiST and SP-GiST index methods all accept this parameter:</source>
          <target state="translated">オプションの &lt;code&gt;WITH&lt;/code&gt; 句は、インデックスの&lt;em&gt;ストレージパラメータ&lt;/em&gt;を指定します。各インデックスメソッドには、許可されたストレージパラメータの独自のセットがあります。Bツリー、ハッシュ、GiSTおよびSP-GiSTインデックスメソッドはすべて、このパラメーターを受け入れます。</target>
        </trans-unit>
        <trans-unit id="058389bedd0ce52c16be7bfd9114242b91506b69" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;XMLNAMESPACES&lt;/code&gt; clause is a comma-separated list of namespaces. It specifies the XML namespaces used in the document and their aliases. A default namespace specification is not currently supported.</source>
          <target state="translated">オプションの &lt;code&gt;XMLNAMESPACES&lt;/code&gt; 句は、名前空間のコンマ区切りのリストです。ドキュメントで使用されるXML名前空間とそのエイリアスを指定します。デフォルトの名前空間仕様は現在サポートされていません。</target>
        </trans-unit>
        <trans-unit id="57ded7b498b198ec6bfc70d87458a99fd28a21d6" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;analyze_function&lt;/code&gt; performs type-specific statistics collection for columns of the data type. By default, &lt;code&gt;ANALYZE&lt;/code&gt; will attempt to gather statistics using the type's &amp;ldquo;equals&amp;rdquo; and &amp;ldquo;less-than&amp;rdquo; operators, if there is a default b-tree operator class for the type. For non-scalar types this behavior is likely to be unsuitable, so it can be overridden by specifying a custom analysis function. The analysis function must be declared to take a single argument of type &lt;code&gt;internal&lt;/code&gt;, and return a &lt;code&gt;boolean&lt;/code&gt; result. The detailed API for analysis functions appears in &lt;code&gt;src/include/commands/vacuum.h&lt;/code&gt;.</source>
          <target state="translated">オプションの &lt;code&gt;analyze_function&lt;/code&gt; は、データ型の列に対して型固有の統計収集を実行します。タイプにデフォルトのBツリー演算子クラスがある場合、 &lt;code&gt;ANALYZE&lt;/code&gt; はデフォルトで、タイプの「等しい」および「より小さい」演算子を使用して統計を収集しようとします。非スカラー型の場合、この動作は不適切である可能性が高いため、カスタム分析関数を指定することでオーバーライドできます。分析関数は、 &lt;code&gt;internal&lt;/code&gt; 型の単一の引数を取り、 &lt;code&gt;boolean&lt;/code&gt; 結果を返すように宣言する必要があります。分析関数の詳細なAPIは &lt;code&gt;src/include/commands/vacuum.h&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="7747a49a90a7a4edd6982d5e13265f6731caae73" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;canonical&lt;/code&gt; function must take one argument of the range type being defined, and return a value of the same type. This is used to convert range values to a canonical form, when applicable. See &lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;Section 8.17.8&lt;/a&gt; for more information. Creating a &lt;code&gt;canonical&lt;/code&gt; function is a bit tricky, since it must be defined before the range type can be declared. To do this, you must first create a shell type, which is a placeholder type that has no properties except a name and an owner. This is done by issuing the command &lt;code&gt;CREATE TYPE name&lt;/code&gt;, with no additional parameters. Then the function can be declared using the shell type as argument and result, and finally the range type can be declared using the same name. This automatically replaces the shell type entry with a valid range type.</source>
          <target state="translated">オプションの &lt;code&gt;canonical&lt;/code&gt; 関数は、定義されている範囲型の引数を1つ取り、同じ型の値を返す必要があります。これは、該当する場合、範囲値を標準形式に変換するために使用されます。詳細については、&lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;セクション8.17.8&lt;/a&gt;を参照してください。 &lt;code&gt;canonical&lt;/code&gt; 関数の作成は、範囲型を宣言する前に定義する必要があるため、少し注意が必要です。これを行うには、最初にシェルタイプを作成する必要があります。これは、名前と所有者以外のプロパティを持たないプレースホルダータイプです。これを行うには、コマンド &lt;code&gt;CREATE TYPE name&lt;/code&gt; を発行します。、追加のパラメーターなし。その後、引数と結果としてシェル型を使用して関数を宣言できます。最後に、同じ名前を使用して範囲型を宣言できます。これにより、シェルタイプエントリが有効な範囲タイプに自動的に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="e405c33bd06f9fd7d49a367fa9d3ceab7c5a9a0c" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;flag&lt;/code&gt; string may include one or more of the characters &lt;code&gt;i&lt;/code&gt; for case-insensitive match, &lt;code&gt;m&lt;/code&gt; to allow &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to match at newlines, &lt;code&gt;s&lt;/code&gt; to allow &lt;code&gt;.&lt;/code&gt; to match a newline, and &lt;code&gt;q&lt;/code&gt; to quote the whole pattern (reducing the behavior to a simple substring match).</source>
          <target state="translated">オプションの &lt;code&gt;flag&lt;/code&gt; 文字列は文字の一つ以上含むことができる &lt;code&gt;i&lt;/code&gt; 大文字と小文字を区別しない一致のために、 &lt;code&gt;m&lt;/code&gt; 可能にするために &lt;code&gt;^&lt;/code&gt; と &lt;code&gt;$&lt;/code&gt; は改行に一致するように、 &lt;code&gt;s&lt;/code&gt; は許可します &lt;code&gt;.&lt;/code&gt; 改行を照合するには &lt;code&gt;q&lt;/code&gt; を使用し、パターン全体を引用符で囲みます（動作を単純な部分文字列の一致に減らします）。</target>
        </trans-unit>
        <trans-unit id="6929038d2d7ee1cd89d49d3d8b27997b9126c9d2" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;frame_clause&lt;/code&gt; can be one of</source>
          <target state="translated">オプションの &lt;code&gt;frame_clause&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="1a0ad788554501dd9d4e6143a34e5057b31ec466" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;frame_clause&lt;/code&gt; defines the &lt;em&gt;window frame&lt;/em&gt; for window functions that depend on the frame (not all do). The window frame is a set of related rows for each row of the query (called the &lt;em&gt;current row&lt;/em&gt;). The &lt;code&gt;frame_clause&lt;/code&gt; can be one of</source>
          <target state="translated">オプションの &lt;code&gt;frame_clause&lt;/code&gt; は、&lt;em&gt;フレーム&lt;/em&gt;に依存する（すべてではない）ウィンドウ関数の&lt;em&gt;ウィンドウフレーム&lt;/em&gt;を定義し&lt;em&gt;ます&lt;/em&gt;。ウィンドウフレームは、クエリの各行（&lt;em&gt;現在の行&lt;/em&gt;と呼ばれる）の関連する行のセットです。 &lt;code&gt;frame_clause&lt;/code&gt; は、のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="78c603df9d8f5aec2127eee4c089f14a6a63935b" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;like_option&lt;/code&gt; clauses specify which additional properties of the original table to copy. Specifying &lt;code&gt;INCLUDING&lt;/code&gt; copies the property, specifying &lt;code&gt;EXCLUDING&lt;/code&gt; omits the property. &lt;code&gt;EXCLUDING&lt;/code&gt; is the default. If multiple specifications are made for the same kind of object, the last one is used. The available options are:</source>
          <target state="translated">オプションの &lt;code&gt;like_option&lt;/code&gt; 句は、コピーする元のテーブルの追加のプロパティを指定します。 &lt;code&gt;INCLUDING&lt;/code&gt; を指定するとプロパティがコピーされ、 &lt;code&gt;EXCLUDING&lt;/code&gt; を指定するとプロパティが省略されます。 &lt;code&gt;EXCLUDING&lt;/code&gt; がデフォルトです。同じ種類のオブジェクトに対して複数の指定が行われた場合、最後の指定が使用されます。使用可能なオプションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="3b1514641d42b559d683d1926252a8c2e4d381f2" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;receive_function&lt;/code&gt; converts the type's external binary representation to the internal representation. If this function is not supplied, the type cannot participate in binary input. The binary representation should be chosen to be cheap to convert to internal form, while being reasonably portable. (For example, the standard integer data types use network byte order as the external binary representation, while the internal representation is in the machine's native byte order.) The receive function should perform adequate checking to ensure that the value is valid. The receive function can be declared as taking one argument of type &lt;code&gt;internal&lt;/code&gt;, or as taking three arguments of types &lt;code&gt;internal&lt;/code&gt;, &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;. The first argument is a pointer to a &lt;code&gt;StringInfo&lt;/code&gt; buffer holding the received byte string; the optional arguments are the same as for the text input function. The receive function must return a value of the data type itself. Usually, a receive function should be declared STRICT; if it is not, it will be called with a NULL first parameter when reading a NULL input value. The function must still return NULL in this case, unless it raises an error. (This case is mainly meant to support domain receive functions, which might need to reject NULL inputs.) Similarly, the optional &lt;code&gt;send_function&lt;/code&gt; converts from the internal representation to the external binary representation. If this function is not supplied, the type cannot participate in binary output. The send function must be declared as taking one argument of the new data type. The send function must return type &lt;code&gt;bytea&lt;/code&gt;. Send functions are not invoked for NULL values.</source>
          <target state="translated">オプションの &lt;code&gt;receive_function&lt;/code&gt; は、型の外部バイナリ表現を内部表現に変換します。この関数が提供されていない場合、型はバイナリ入力に参加できません。バイナリ表現は、合理的に移植可能である一方で、内部形式への変換が安価であるように選択する必要があります。 （たとえば、標準の整数データ型は外部バイナリ表現としてネットワークバイトオーダーを使用しますが、内部表現はマシンのネイティブバイトオーダーです。）受信関数は適切なチェックを実行して、値が有効であることを確認する必要があります。 receive関数は、 &lt;code&gt;internal&lt;/code&gt; 型の引数を1つ取るか、 &lt;code&gt;internal&lt;/code&gt; 、 &lt;code&gt;oid&lt;/code&gt; 、 &lt;code&gt;integer&lt;/code&gt; 型の引数を3つ取ると宣言できます。。最初の引数は、受信したバイト文字列を保持する &lt;code&gt;StringInfo&lt;/code&gt; バッファへのポインタです。オプションの引数は、テキスト入力関数の場合と同じです。 receive関数は、データ型自体の値を返す必要があります。通常、受信関数はSTRICTとして宣言する必要があります。そうでない場合は、NULL入力値を読み取るときに、最初のパラメーターがNULLで呼び出されます。この場合、エラーが発生しない限り、関数はNULLを返す必要があります。 （この場合の主な目的は、NULL入力を拒否する必要があるドメイン受信関数をサポートすることです。）同様に、オプションの &lt;code&gt;send_function&lt;/code&gt; 内部表現から外部バイナリ表現に変換します。この関数が提供されない場合、型はバイナリ出力に参加できません。send関数は、新しいデータ型の1つの引数を取るように宣言する必要があります。send関数は、タイプ &lt;code&gt;bytea&lt;/code&gt; を返す必要があります。NULL値の場合、送信関数は呼び出されません。</target>
        </trans-unit>
        <trans-unit id="7d7acb9837f1f10a2e0445707407528f679ac86a" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;sequence_options&lt;/code&gt; clause can be used to override the options of the sequence. See &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; for details.</source>
          <target state="translated">オプションの &lt;code&gt;sequence_options&lt;/code&gt; 句を使用して、シーケンスのオプションを上書きできます。詳細については、&lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7bcdb21e727a9ca38cf42b2a6d25b5e2872506f6" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;subtype_diff&lt;/code&gt; function must take two values of the &lt;code&gt;subtype&lt;/code&gt; type as argument, and return a &lt;code&gt;double precision&lt;/code&gt; value representing the difference between the two given values. While this is optional, providing it allows much greater efficiency of GiST indexes on columns of the range type. See &lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;Section 8.17.8&lt;/a&gt; for more information.</source>
          <target state="translated">オプションの &lt;code&gt;subtype_diff&lt;/code&gt; 関数は、 &lt;code&gt;subtype&lt;/code&gt; 2つの値を引数として取り、指定された2つの値の差を表す &lt;code&gt;double precision&lt;/code&gt; 値を返す必要があります。これはオプションですが、範囲型の列でGiSTインデックスの効率を大幅に向上させることができます。詳細については、&lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;セクション8.17.8&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1325ceadd1cae01690d39e7c916f8ac8cf741797" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;type_modifier_input_function&lt;/code&gt; and &lt;code&gt;type_modifier_output_function&lt;/code&gt; are needed if the type supports modifiers, that is optional constraints attached to a type declaration, such as &lt;code&gt;char(5)&lt;/code&gt; or &lt;code&gt;numeric(30,2)&lt;/code&gt;. PostgreSQL allows user-defined types to take one or more simple constants or identifiers as modifiers. However, this information must be capable of being packed into a single non-negative integer value for storage in the system catalogs. The &lt;code&gt;type_modifier_input_function&lt;/code&gt; is passed the declared modifier(s) in the form of a &lt;code&gt;cstring&lt;/code&gt; array. It must check the values for validity (throwing an error if they are wrong), and if they are correct, return a single non-negative &lt;code&gt;integer&lt;/code&gt; value that will be stored as the column &amp;ldquo;typmod&amp;rdquo;. Type modifiers will be rejected if the type does not have a &lt;code&gt;type_modifier_input_function&lt;/code&gt;. The &lt;code&gt;type_modifier_output_function&lt;/code&gt; converts the internal integer typmod value back to the correct form for user display. It must return a &lt;code&gt;cstring&lt;/code&gt; value that is the exact string to append to the type name; for example &lt;code&gt;numeric&lt;/code&gt;'s function might return &lt;code&gt;(30,2)&lt;/code&gt;. It is allowed to omit the &lt;code&gt;type_modifier_output_function&lt;/code&gt;, in which case the default display format is just the stored typmod integer value enclosed in parentheses.</source>
          <target state="translated">オプションの &lt;code&gt;type_modifier_input_function&lt;/code&gt; および &lt;code&gt;type_modifier_output_function&lt;/code&gt; は、タイプが修飾子をサポートしている場合に必要です。これは、 &lt;code&gt;char(5)&lt;/code&gt; や &lt;code&gt;numeric(30,2)&lt;/code&gt; などのタイプ宣言に付加されたオプションの制約です。 PostgreSQLでは、ユーザー定義型で1つ以上の単純な定数または識別子を修飾子として使用できます。ただし、この情報は、システムカタログに格納するために、1つの負でない整数値にパックできる必要があります。 &lt;code&gt;type_modifier_input_function&lt;/code&gt; が渡されるの形で（S）修飾子宣言 &lt;code&gt;cstring&lt;/code&gt; アレイ。値の妥当性をチェックし（値が間違っている場合はエラーをスローする）、値が正しい場合は1つの負でない値を返す必要があります &lt;code&gt;integer&lt;/code&gt; 列「typmod」として格納される整数値。タイプに &lt;code&gt;type_modifier_input_function&lt;/code&gt; がない場合、タイプ修飾子は拒否されます。 &lt;code&gt;type_modifier_output_function&lt;/code&gt; は、ユーザ表示用の正しい形式に内部整数typmod値バックを変換します。タイプ名に追加する正確な文字列である &lt;code&gt;cstring&lt;/code&gt; 値を返す必要があります。たとえば、 &lt;code&gt;numeric&lt;/code&gt; の関数は &lt;code&gt;(30,2)&lt;/code&gt; を返す可能性があります。 &lt;code&gt;type_modifier_output_function&lt;/code&gt; を省略できます。その場合、デフォルトの表示形式は、括弧で囲まれた格納されたtypmod整数値のみです。</target>
        </trans-unit>
        <trans-unit id="af1ecc2cb7dfd4fb66fffd97bf916a5a132fb429" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;AS data_type&lt;/code&gt; changes the data type of the sequence. Valid types are &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt;.</source>
          <target state="translated">オプションの句 &lt;code&gt;AS data_type&lt;/code&gt; は、シーケンスのデータ型を変更します。有効なタイプは &lt;code&gt;smallint&lt;/code&gt; 、 &lt;code&gt;integer&lt;/code&gt; 、および &lt;code&gt;bigint&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a6491ae8d81a26646c521265ecd71bb3dba07346" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;AS data_type&lt;/code&gt; specifies the data type of the sequence. Valid types are &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt;. &lt;code&gt;bigint&lt;/code&gt; is the default. The data type determines the default minimum and maximum values of the sequence.</source>
          <target state="translated">オプションの句 &lt;code&gt;AS data_type&lt;/code&gt; は、シーケンスのデータ型を指定します。有効なタイプは &lt;code&gt;smallint&lt;/code&gt; 、 &lt;code&gt;integer&lt;/code&gt; 、および &lt;code&gt;bigint&lt;/code&gt; です。 &lt;code&gt;bigint&lt;/code&gt; がデフォルトです。データ型によって、シーケンスのデフォルトの最小値と最大値が決まります。</target>
        </trans-unit>
        <trans-unit id="4ef52006c6e494bfa443e060a826bdc36541e6b7" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;CACHE cache&lt;/code&gt; specifies how many sequence numbers are to be preallocated and stored in memory for faster access. The minimum value is 1 (only one value can be generated at a time, i.e., no cache), and this is also the default.</source>
          <target state="translated">オプションの句 &lt;code&gt;CACHE cache&lt;/code&gt; は、より高速なアクセスのために、事前に割り当てられ、メモリに格納されるシーケンス番号の数を指定します。最小値は1（一度に生成できる値は1つのみ、つまりキャッシュなし）で、これもデフォルトです。</target>
        </trans-unit>
        <trans-unit id="e1922af2324c94734b798d29c69dd1e6a8cd6788" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;INCREMENT BY increment&lt;/code&gt; specifies which value is added to the current sequence value to create a new value. A positive value will make an ascending sequence, a negative one a descending sequence. The default value is 1.</source>
          <target state="translated">オプションの &lt;code&gt;INCREMENT BY increment&lt;/code&gt; 句は、新しい値を作成するために現在のシーケンス値に追加される値を指定します。正の値は昇順のシーケンスになり、負の値は降順のシーケンスになります。デフォルト値は1です。</target>
        </trans-unit>
        <trans-unit id="129d57b7ace9b8671169f53fc01dbaf732d5dd2a" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; determines the maximum value for the sequence. If &lt;code&gt;NO MAXVALUE&lt;/code&gt; is specified, the defaults of the maximum value of the data type and -1 for ascending and descending sequences, respectively, will be used. If neither option is specified, the current maximum value will be maintained.</source>
          <target state="translated">オプションの句 &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; は、シーケンスの最大値を決定します。 &lt;code&gt;NO MAXVALUE&lt;/code&gt; が指定されている場合、データ型の最大値のデフォルトと昇順と降順の-1がそれぞれ使用されます。どちらのオプションも指定しない場合、現在の最大値が維持されます。</target>
        </trans-unit>
        <trans-unit id="636d2219bc9ef5ee8fa4e79b4cd4c563ed5f1551" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; determines the maximum value for the sequence. If this clause is not supplied or &lt;code&gt;NO MAXVALUE&lt;/code&gt; is specified, then default values will be used. The default for an ascending sequence is the maximum value of the data type. The default for a descending sequence is -1.</source>
          <target state="translated">オプションの句 &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; は、シーケンスの最大値を決定します。この句が指定されていない場合、または &lt;code&gt;NO MAXVALUE&lt;/code&gt; が指定されている場合は、デフォルト値が使用されます。昇順のデフォルトは、データ型の最大値です。降順のデフォルトは-1です。</target>
        </trans-unit>
        <trans-unit id="c5eb2614e0e305c391d790e5028cc9a0dac1d3fe" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MINVALUE minvalue&lt;/code&gt; determines the minimum value a sequence can generate. If &lt;code&gt;NO MINVALUE&lt;/code&gt; is specified, the defaults of 1 and the minimum value of the data type for ascending and descending sequences, respectively, will be used. If neither option is specified, the current minimum value will be maintained.</source>
          <target state="translated">オプションの句 &lt;code&gt;MINVALUE minvalue&lt;/code&gt; は、シーケンスが生成できる最小値を決定します。場合 &lt;code&gt;NO MINVALUE&lt;/code&gt; が指定され、1のデフォルトおよび配列を昇降するためのデータ・タイプの最小値は、それぞれ、使用されるであろう。どちらのオプションも指定しない場合、現在の最小値が維持されます。</target>
        </trans-unit>
        <trans-unit id="e9e2bcb7eb75a3afb340c5c1fc227a8406ff8640" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MINVALUE minvalue&lt;/code&gt; determines the minimum value a sequence can generate. If this clause is not supplied or &lt;code&gt;NO MINVALUE&lt;/code&gt; is specified, then defaults will be used. The default for an ascending sequence is 1. The default for a descending sequence is the minimum value of the data type.</source>
          <target state="translated">オプションの句 &lt;code&gt;MINVALUE minvalue&lt;/code&gt; は、シーケンスが生成できる最小値を決定します。この句が指定されていない場合、または &lt;code&gt;NO MINVALUE&lt;/code&gt; が指定されている場合は、デフォルトが使用されます。昇順シーケンスのデフォルトは1です。降順シーケンスのデフォルトは、データ型の最小値です。</target>
        </trans-unit>
        <trans-unit id="fcd2de5b18440bca469ca6adbeb6f5f5db2e6405" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;RESTART [ WITH restart ]&lt;/code&gt; changes the current value of the sequence. This is similar to calling the &lt;code&gt;setval&lt;/code&gt; function with &lt;code&gt;is_called&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt;: the specified value will be returned by the &lt;em&gt;next&lt;/em&gt; call of &lt;code&gt;nextval&lt;/code&gt;. Writing &lt;code&gt;RESTART&lt;/code&gt; with no &lt;code&gt;restart&lt;/code&gt; value is equivalent to supplying the start value that was recorded by &lt;code&gt;CREATE SEQUENCE&lt;/code&gt; or last set by &lt;code&gt;ALTER SEQUENCE START WITH&lt;/code&gt;.</source>
          <target state="translated">オプションの句 &lt;code&gt;RESTART [ WITH restart ]&lt;/code&gt; は、シーケンスの現在の値を変更します。これは、 &lt;code&gt;is_called&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; で &lt;code&gt;setval&lt;/code&gt; 関数を呼び出すのに似ています。指定された値は、 &lt;code&gt;nextval&lt;/code&gt; の&lt;em&gt;次の&lt;/em&gt;呼び出しによって返されます。 &lt;code&gt;restart&lt;/code&gt; 値なしで &lt;code&gt;RESTART&lt;/code&gt; を書き込むことは、 &lt;code&gt;CREATE SEQUENCE&lt;/code&gt; によって記録された、または最後に &lt;code&gt;ALTER SEQUENCE START WITH&lt;/code&gt; によって設定された開始値を提供することと同じです。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0fb28acc2fa41aa8ead28a09cd415f780a8cadf0" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;START WITH start&lt;/code&gt; allows the sequence to begin anywhere. The default starting value is &lt;code&gt;minvalue&lt;/code&gt; for ascending sequences and &lt;code&gt;maxvalue&lt;/code&gt; for descending ones.</source>
          <target state="translated">オプションの句 &lt;code&gt;START WITH start&lt;/code&gt; を使用すると、シーケンスをどこからでも開始できます。デフォルトの開始値は &lt;code&gt;minvalue&lt;/code&gt; 配列と、昇順のために &lt;code&gt;maxvalue&lt;/code&gt; ものを降順。</target>
        </trans-unit>
        <trans-unit id="eb785729e5f5d903e46bb6918c0a11aa04baffd1" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;START WITH start&lt;/code&gt; changes the recorded start value of the sequence. This has no effect on the &lt;em&gt;current&lt;/em&gt; sequence value; it simply sets the value that future &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; commands will use.</source>
          <target state="translated">オプションの句 &lt;code&gt;START WITH start&lt;/code&gt; は、シーケンスの記録された開始値を変更します。これは&lt;em&gt;現在の&lt;/em&gt;シーケンス値には影響しません。これは単に、将来の &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; コマンドが使用する値を設定するだけです。</target>
        </trans-unit>
        <trans-unit id="1713a9e1e99f66c0bcfe7df0c08c776ea8b0c311" translate="yes" xml:space="preserve">
          <source>The optional constraint clauses specify constraints (tests) that new or updated rows must satisfy for an insert or update operation to succeed. A constraint is an SQL object that helps define the set of valid values in the table in various ways.</source>
          <target state="translated">オプションの制約句は、新規または更新された行が挿入または更新操作を成功させるために満たす必要がある制約(テスト)を指定します。制約は、様々な方法でテーブル内の有効な値のセットを定義するのに役立つSQLオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="e18e0d61bcb7c9d71d791c91de29bb60405c83c7" translate="yes" xml:space="preserve">
          <source>The optional flag &lt;code&gt;PASSEDBYVALUE&lt;/code&gt; indicates that values of this data type are passed by value, rather than by reference. Types passed by value must be fixed-length, and their internal representation cannot be larger than the size of the &lt;code&gt;Datum&lt;/code&gt; type (4 bytes on some machines, 8 bytes on others).</source>
          <target state="translated">オプションのフラグ &lt;code&gt;PASSEDBYVALUE&lt;/code&gt; は、このデータ型の値が参照ではなく値によって渡されることを示します。値で渡される型は固定長である必要があり、その内部表現は &lt;code&gt;Datum&lt;/code&gt; 型のサイズ（一部のマシンでは4バイト、その他のマシンでは8バイト）を超えることはできません。</target>
        </trans-unit>
        <trans-unit id="96f5588e1c2e2855ea8548eee4502bfe5b21503f" translate="yes" xml:space="preserve">
          <source>The optional parameter &lt;code&gt;PATTERN&lt;/code&gt; can be the name of a text search object, optionally schema-qualified. If &lt;code&gt;PATTERN&lt;/code&gt; is omitted then information about all visible objects will be displayed. &lt;code&gt;PATTERN&lt;/code&gt; can be a regular expression and can provide &lt;em&gt;separate&lt;/em&gt; patterns for the schema and object names. The following examples illustrate this:</source>
          <target state="translated">オプションのパラメーター &lt;code&gt;PATTERN&lt;/code&gt; は、オプションでスキーマ修飾されたテキスト検索オブジェクトの名前にすることができます。 &lt;code&gt;PATTERN&lt;/code&gt; を省略した場合、すべての可視オブジェクトに関する情報が表示されます。 &lt;code&gt;PATTERN&lt;/code&gt; は正規表現にすることができ、スキーマとオブジェクト名に&lt;em&gt;個別の&lt;/em&gt;パターンを提供できます。次の例は、これを示しています。</target>
        </trans-unit>
        <trans-unit id="de01abc64ad555117df4d2eb14da2dc8395e780a" translate="yes" xml:space="preserve">
          <source>The optional third argument of the function is an array of namespace mappings. This array should be a two-dimensional &lt;code&gt;text&lt;/code&gt; array with the length of the second axis being equal to 2 (i.e., it should be an array of arrays, each of which consists of exactly 2 elements). The first element of each array entry is the namespace name (alias), the second the namespace URI. It is not required that aliases provided in this array be the same as those being used in the XML document itself (in other words, both in the XML document and in the &lt;code&gt;xpath&lt;/code&gt; function context, aliases are &lt;em&gt;local&lt;/em&gt;).</source>
          <target state="translated">関数のオプションの3番目の引数は、名前空間マッピングの配列です。この配列は、2番目の軸の長さが2に等しい2 次元の &lt;code&gt;text&lt;/code&gt; 配列である必要があります（つまり、それぞれがちょうど2つの要素で構成される配列の配列である必要があります）。各配列エントリの最初の要素は名前空間名（エイリアス）、2番目の要素は名前空間URIです。この配列で提供されるエイリアスが、XMLドキュメント自体で使用されているエイリアスと同じである必要はありません（つまり、XMLドキュメントと &lt;code&gt;xpath&lt;/code&gt; 関数コンテキストの両方で、エイリアスは&lt;em&gt;localです&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="f7c4a4f219f0aa64d3de98d0b070691b60ede2a2" translate="yes" xml:space="preserve">
          <source>The optional user-defined method is:</source>
          <target state="translated">オプションのユーザー定義メソッドは</target>
        </trans-unit>
        <trans-unit id="84a938a7941f222eb580e7e8263bbd7142209820" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;--docdir&lt;/code&gt;, &lt;code&gt;--pkgincludedir&lt;/code&gt;, &lt;code&gt;--localedir&lt;/code&gt;, &lt;code&gt;--mandir&lt;/code&gt;, &lt;code&gt;--sharedir&lt;/code&gt;, &lt;code&gt;--sysconfdir&lt;/code&gt;, &lt;code&gt;--cc&lt;/code&gt;, &lt;code&gt;--cppflags&lt;/code&gt;, &lt;code&gt;--cflags&lt;/code&gt;, &lt;code&gt;--cflags_sl&lt;/code&gt;, &lt;code&gt;--ldflags&lt;/code&gt;, &lt;code&gt;--ldflags_sl&lt;/code&gt;, and &lt;code&gt;--libs&lt;/code&gt; were added in PostgreSQL 8.1. The option &lt;code&gt;--htmldir&lt;/code&gt; was added in PostgreSQL 8.4. The option &lt;code&gt;--ldflags_ex&lt;/code&gt; was added in PostgreSQL 9.0.</source>
          <target state="translated">オプション &lt;code&gt;--docdir&lt;/code&gt; 、 &lt;code&gt;--pkgincludedir&lt;/code&gt; 、 &lt;code&gt;--localedir&lt;/code&gt; 、 &lt;code&gt;--mandir&lt;/code&gt; 、 &lt;code&gt;--sharedir&lt;/code&gt; 、 &lt;code&gt;--sysconfdir&lt;/code&gt; 、 &lt;code&gt;--cc&lt;/code&gt; 、 &lt;code&gt;--cppflags&lt;/code&gt; 、 &lt;code&gt;--cflags&lt;/code&gt; 、 &lt;code&gt;--cflags_sl&lt;/code&gt; 、 &lt;code&gt;--ldflags&lt;/code&gt; 、 &lt;code&gt;--ldflags_sl&lt;/code&gt; 、および &lt;code&gt;--libs&lt;/code&gt; はPostgreSQL 8.1で追加されました。オプション &lt;code&gt;--htmldir&lt;/code&gt; はPostgreSQL 8.4で追加されました。オプション &lt;code&gt;--ldflags_ex&lt;/code&gt; はPostgreSQL 9.0で追加されました。</target>
        </trans-unit>
        <trans-unit id="fabb800956bbdc09009ffd9f1b017eb0d6e1abef" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;-D&lt;/code&gt;, &lt;code&gt;-l&lt;/code&gt;, &lt;code&gt;-E&lt;/code&gt;, &lt;code&gt;-O&lt;/code&gt;, and &lt;code&gt;-T&lt;/code&gt; correspond to options of the underlying SQL command &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;; see there for more information about them.</source>
          <target state="translated">オプション &lt;code&gt;-D&lt;/code&gt; 、 &lt;code&gt;-l&lt;/code&gt; 、 &lt;code&gt;-E&lt;/code&gt; 、 &lt;code&gt;-O&lt;/code&gt; 、および &lt;code&gt;-T&lt;/code&gt; は、基礎となるSQLコマンド&lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASEの&lt;/a&gt;オプションに対応しています。それらについての詳細はそちらを参照してください。</target>
        </trans-unit>
        <trans-unit id="b59022ce6b09c2f629170565a77c3c19be85bd9c" translate="yes" xml:space="preserve">
          <source>The options can appear in any order.</source>
          <target state="translated">オプションは任意の順番で表示されます。</target>
        </trans-unit>
        <trans-unit id="83b4362928db8b9651a7b14a89534a668d30b89b" translate="yes" xml:space="preserve">
          <source>The options described here are used mainly for debugging purposes, and in some cases to assist with recovery of severely damaged databases. There should be no reason to use them in a production database setup. They are listed here only for use by PostgreSQL system developers. Furthermore, these options might change or be removed in a future release without notice.</source>
          <target state="translated">ここで説明したオプションは主にデバッグ目的で使用され、場合によっては深刻な損傷を受けたデータベースの復旧を支援するために使用されます。実運用のデータベースの設定でこれらを使用する理由はありません。これらのオプションは、PostgreSQLシステムの開発者が使用するためだけにここに記載されています。さらに、これらのオプションは将来のリリースで予告なしに変更されたり削除されたりするかもしれません。</target>
        </trans-unit>
        <trans-unit id="f8dd3a92af0a56bfda8d9752b838ef4b2d6a4df2" translate="yes" xml:space="preserve">
          <source>The order 3501 might be among the billed or unbilled orders.</source>
          <target state="translated">オーダー3501は、課金されたオーダーと課金されていないオーダーの中に含まれている可能性があります。</target>
        </trans-unit>
        <trans-unit id="abcd49a17f5a3270a489cdc6cf5f6ae4822bbd01" translate="yes" xml:space="preserve">
          <source>The order doesn't matter. It does not necessarily determine in which order the constraints are checked.</source>
          <target state="translated">順番は重要ではありません。制約がどの順番でチェックされるかは、必ずしも決定されません。</target>
        </trans-unit>
        <trans-unit id="4885441a3f0959533bfa66d30ac9b400042a2243" translate="yes" xml:space="preserve">
          <source>The order of evaluation of subexpressions is not defined. In particular, the inputs of an operator or function are not necessarily evaluated left-to-right or in any other fixed order.</source>
          <target state="translated">副式の評価の順序は定義されていません。特に、演算子や関数の入力は必ずしも左から右に評価されるわけではなく、その他の固定された順序で評価されるわけではありません。</target>
        </trans-unit>
        <trans-unit id="89519eed893d527079231a8a6443c77bf1a65103" translate="yes" xml:space="preserve">
          <source>The order of the pairs is not significant (and may not be reproduced on output). Whitespace between pairs or around the &lt;code&gt;=&amp;gt;&lt;/code&gt; sign is ignored. Double-quote keys and values that include whitespace, commas, &lt;code&gt;=&lt;/code&gt;s or &lt;code&gt;&amp;gt;&lt;/code&gt;s. To include a double quote or a backslash in a key or value, escape it with a backslash.</source>
          <target state="translated">ペアの順序は重要ではありません（出力時に再現されない場合があります）。ペア間または &lt;code&gt;=&amp;gt;&lt;/code&gt; 記号の前後の空白は無視されます。空白、カンマ、 &lt;code&gt;=&lt;/code&gt; sまたは &lt;code&gt;&amp;gt;&lt;/code&gt; s を含む二重引用符付きのキーと値。キーまたは値に二重引用符または円記号を含めるには、円記号でエスケープします。</target>
        </trans-unit>
        <trans-unit id="6a0d0d4551f2d45fd2b79524bceb16c2da137ff6" translate="yes" xml:space="preserve">
          <source>The ordering of the values in an enum type is the order in which the values were listed when the type was created. All standard comparison operators and related aggregate functions are supported for enums. For example:</source>
          <target state="translated">列挙型の値の順序は、型が作成されたときに値がリストされていた順序になります。すべての標準比較演算子と関連する集約関数は、列挙型でサポートされています。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="4a1c45805d8830616db8f03a352b425367265a0b" translate="yes" xml:space="preserve">
          <source>The ordinal number refers to the ordinal (left-to-right) position of the index column.</source>
          <target state="translated">序数とは、インデックス列の序数(左から右)の位置を指します。</target>
        </trans-unit>
        <trans-unit id="542906884bd50e7620583567769e2555be971b00" translate="yes" xml:space="preserve">
          <source>The ordinal number refers to the ordinal (left-to-right) position of the output column. This feature makes it possible to define an ordering on the basis of a column that does not have a unique name. This is never absolutely necessary because it is always possible to assign a name to an output column using the &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">序数は、出力列の序数（左から右）の位置を指します。この機能により、一意の名前を持たない列に基づいて順序を定義できます。 &lt;code&gt;AS&lt;/code&gt; 句を使用して出力列に名前を割り当てることが常に可能であるため、これは絶対に必要なわけではありません。</target>
        </trans-unit>
        <trans-unit id="b06b3bbd9847482f4b77272cbdd9dddfd2293b02" translate="yes" xml:space="preserve">
          <source>The ordinary qualified-column-name syntax &lt;code&gt;table_name&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;&lt;code&gt;column_name&lt;/code&gt; can be understood as applying &lt;a href=&quot;sql-expressions#FIELD-SELECTION&quot;&gt;field selection&lt;/a&gt; to the composite value of the table's current row. (For efficiency reasons, it's not actually implemented that way.)</source>
          <target state="translated">通常の修飾列名の構文 &lt;code&gt;table_name&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; &lt;code&gt;column_name&lt;/code&gt; は、&lt;a href=&quot;sql-expressions#FIELD-SELECTION&quot;&gt;フィールド選択&lt;/a&gt;をテーブルの現在の行の複合値に適用することとして理解できます。（効率上の理由から、実際にはそのように実装されていません。）</target>
        </trans-unit>
        <trans-unit id="26d29240df565151bc026ac25aff13ab3efc3c48" translate="yes" xml:space="preserve">
          <source>The origin node's LSN up to which data has been replicated.</source>
          <target state="translated">データがレプリケートされたオリジンノードのLSN。</target>
        </trans-unit>
        <trans-unit id="0c0890af1d3eba99328b2705ec2de494e2103157" translate="yes" xml:space="preserve">
          <source>The other clauses specify optional operator optimization clauses. Their meaning is detailed in &lt;a href=&quot;https://www.postgresql.org/docs/12/xoper-optimization.html&quot;&gt;Section 37.15&lt;/a&gt;.</source>
          <target state="translated">その他の句は、オプションの演算子最適化句を指定します。その意味については、&lt;a href=&quot;https://www.postgresql.org/docs/12/xoper-optimization.html&quot;&gt;セクション37.15で&lt;/a&gt;詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="968a2d78a8c8100f337e33a5ce08a9f2a42bbad9" translate="yes" xml:space="preserve">
          <source>The other locale categories can be changed whenever desired by setting the server configuration parameters that have the same name as the locale categories (see &lt;a href=&quot;runtime-config-client#RUNTIME-CONFIG-CLIENT-FORMAT&quot;&gt;Section 19.11.2&lt;/a&gt; for details). The values that are chosen by &lt;code&gt;initdb&lt;/code&gt; are actually only written into the configuration file &lt;code&gt;postgresql.conf&lt;/code&gt; to serve as defaults when the server is started. If you remove these assignments from &lt;code&gt;postgresql.conf&lt;/code&gt; then the server will inherit the settings from its execution environment.</source>
          <target state="translated">他のロケールカテゴリは、ロケールカテゴリと同じ名前のサーバー構成パラメータを設定することにより、いつでも変更できます（詳細については、&lt;a href=&quot;runtime-config-client#RUNTIME-CONFIG-CLIENT-FORMAT&quot;&gt;セクション19.11.2&lt;/a&gt;を参照してください）。 &lt;code&gt;initdb&lt;/code&gt; によって選択される値は、実際には、サーバーの起動時にデフォルトとして機能するように構成ファイル &lt;code&gt;postgresql.conf&lt;/code&gt; にのみ書き込まれます。これらの割り当てを &lt;code&gt;postgresql.conf&lt;/code&gt; から削除すると、サーバーはその実行環境から設定を継承します。</target>
        </trans-unit>
        <trans-unit id="4f628b39443abf4900d7c741215add2d55c377a2" translate="yes" xml:space="preserve">
          <source>The other required settings have default values that are sufficient for a basic setup.</source>
          <target state="translated">その他の必要な設定は、基本的な設定を行うのに十分な初期値が設定されています。</target>
        </trans-unit>
        <trans-unit id="37e3a8e885deb65cc32448cece3ed8b5de192c3e" translate="yes" xml:space="preserve">
          <source>The other three operators are defined in terms of &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; in the obvious way, and must act consistently with them.</source>
          <target state="translated">他の3つの演算子は &lt;code&gt;=&lt;/code&gt; と &lt;code&gt;&amp;lt;&lt;/code&gt; の観点から明白な方法で定義されており、それらと一貫して動作する必要があります。</target>
        </trans-unit>
        <trans-unit id="cca1af5395645eeb86ba526f8d241c5ba5b41b07" translate="yes" xml:space="preserve">
          <source>The output columns are described in &lt;a href=&quot;pgstattuple#PGSTATAPPROX-COLUMNS&quot;&gt;Table F.23&lt;/a&gt;.</source>
          <target state="translated">出力列については、&lt;a href=&quot;pgstattuple#PGSTATAPPROX-COLUMNS&quot;&gt;表F.23で&lt;/a&gt;説明します。</target>
        </trans-unit>
        <trans-unit id="2061781f2ae71dd3ed97908a6bff9dc965e50b4d" translate="yes" xml:space="preserve">
          <source>The output columns are described in &lt;a href=&quot;pgstattuple#PGSTATTUPLE-COLUMNS&quot;&gt;Table F.22&lt;/a&gt;.</source>
          <target state="translated">出力列については、&lt;a href=&quot;pgstattuple#PGSTATTUPLE-COLUMNS&quot;&gt;表F.22で&lt;/a&gt;説明します。</target>
        </trans-unit>
        <trans-unit id="a9d41f9345eb262fbbccef45f4cf925c1a6818ef" translate="yes" xml:space="preserve">
          <source>The output columns are:</source>
          <target state="translated">出力されるカラムは</target>
        </trans-unit>
        <trans-unit id="ddee20dbbcf56a7d470d5e18264fdb853ffab834" translate="yes" xml:space="preserve">
          <source>The output format of the date/time types can be set to one of the four styles ISO 8601, SQL (Ingres), traditional POSTGRES (Unix date format), or German. The default is the ISO format. (The SQL standard requires the use of the ISO 8601 format. The name of the &amp;ldquo;SQL&amp;rdquo; output format is a historical accident.) &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT-TABLE&quot;&gt;Table 8.14&lt;/a&gt; shows examples of each output style. The output of the &lt;code&gt;date&lt;/code&gt; and &lt;code&gt;time&lt;/code&gt; types is generally only the date or time part in accordance with the given examples. However, the POSTGRES style outputs date-only values in ISO format.</source>
          <target state="translated">日付/時刻型の出力形式は、ISO 8601、SQL（Ingres）、従来のPOSTGRES（Unix日付形式）、またはドイツ語の4つのスタイルのいずれかに設定できます。デフォルトはISO形式です。（SQL標準では、ISO 8601形式を使用する必要があります。「SQL」出力形式の名前は、偶発的な事故です。）&lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT-TABLE&quot;&gt;表8.14に&lt;/a&gt;、各出力スタイルの例を示します。 &lt;code&gt;date&lt;/code&gt; と &lt;code&gt;time&lt;/code&gt; タイプの出力は、通常、与えられた例に従って日付または時刻の部分のみです。ただし、POSTGRESスタイルは日付のみの値をISO形式で出力します。</target>
        </trans-unit>
        <trans-unit id="ca0d537c6aa930d0ccd3e11ab06cbea4823708c4" translate="yes" xml:space="preserve">
          <source>The output format of the interval type can be set to one of the four styles &lt;code&gt;sql_standard&lt;/code&gt;, &lt;code&gt;postgres&lt;/code&gt;, &lt;code&gt;postgres_verbose&lt;/code&gt;, or &lt;code&gt;iso_8601&lt;/code&gt;, using the command &lt;code&gt;SET intervalstyle&lt;/code&gt;. The default is the &lt;code&gt;postgres&lt;/code&gt; format. &lt;a href=&quot;datatype-datetime#INTERVAL-STYLE-OUTPUT-TABLE&quot;&gt;Table 8.18&lt;/a&gt; shows examples of each output style.</source>
          <target state="translated">間隔タイプの出力フォーマットは、コマンド &lt;code&gt;SET intervalstyle&lt;/code&gt; を使用して、 &lt;code&gt;sql_standard&lt;/code&gt; 、 &lt;code&gt;postgres&lt;/code&gt; 、 &lt;code&gt;postgres_verbose&lt;/code&gt; 、または &lt;code&gt;iso_8601&lt;/code&gt; の4つのスタイルのいずれかに設定できます。デフォルトは &lt;code&gt;postgres&lt;/code&gt; 形式です。&lt;a href=&quot;datatype-datetime#INTERVAL-STYLE-OUTPUT-TABLE&quot;&gt;表8.18に&lt;/a&gt;、各出力スタイルの例を示します。</target>
        </trans-unit>
        <trans-unit id="46e4d541f5041111722fb3ba79a2c654be039359" translate="yes" xml:space="preserve">
          <source>The output is a multiline string, with one line per node in the binary tree within the page. Only those nodes that are not zero are printed. The so-called &quot;next&quot; pointer, which points to the next slot to be returned from the page, is also printed.</source>
          <target state="translated">出力は複数行の文字列で、ページ内のバイナリツリーのノードごとに1行ずつ出力されます。ゼロではないノードのみが出力されます。ページから返される次のスロットを指す、いわゆる &quot;next&quot; ポインタも印刷されます。</target>
        </trans-unit>
        <trans-unit id="ad08831002285835cd9adfadf104f64de7aa0e5d" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;command&lt;/code&gt;, similar to ordinary &amp;ldquo;back-tick&amp;rdquo; substitution.</source>
          <target state="translated">&lt;code&gt;command&lt;/code&gt; の出力。通常の「バックティック」置換に似ています。</target>
        </trans-unit>
        <trans-unit id="f5a340fab5cd2f5c7335b7c6ceb29826d0789ea6" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;pg_config --configure&lt;/code&gt; contains shell quotation marks so arguments with spaces are represented correctly. Therefore, using &lt;code&gt;eval&lt;/code&gt; is required for proper results.</source>
          <target state="translated">&lt;code&gt;pg_config --configure&lt;/code&gt; の出力にはシェル引用符が含まれているため、スペースを含む引数は正しく表現されます。したがって、正しい結果を得るには &lt;code&gt;eval&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="6a81f92d4917ee9ed4622690e19a83d472fca1d6" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;iso_8601&lt;/code&gt; style matches the &amp;ldquo;format with designators&amp;rdquo; described in section 4.4.3.2 of the ISO 8601 standard.</source>
          <target state="translated">&lt;code&gt;iso_8601&lt;/code&gt; スタイルの出力は、ISO 8601規格のセクション4.4.3.2で説明されている「指定子付きのフォーマット」と一致します。</target>
        </trans-unit>
        <trans-unit id="2ff8c3f12c0cc1fd0eb9b2845008220be0844b33" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;postgres&lt;/code&gt; style matches the output of PostgreSQL releases prior to 8.4 when the &lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt; parameter was set to &lt;code&gt;ISO&lt;/code&gt;.</source>
          <target state="translated">出力 &lt;code&gt;postgres&lt;/code&gt; スタイルは、8.4以前のPostgreSQLのリリースの出力と一致する&lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;のDateStyleの&lt;/a&gt;パラメータに設定された &lt;code&gt;ISO&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="1546f3a4ad8e76189b8c8e44c823160ec87aa0b6" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;postgres_verbose&lt;/code&gt; style matches the output of PostgreSQL releases prior to 8.4 when the &lt;code&gt;DateStyle&lt;/code&gt; parameter was set to non-&lt;code&gt;ISO&lt;/code&gt; output.</source>
          <target state="translated">出力 &lt;code&gt;postgres_verbose&lt;/code&gt; スタイルは、いつのPostgreSQLの出力は、8.4以前のリリースと一致する &lt;code&gt;DateStyle&lt;/code&gt; パラメータが非に設定した &lt;code&gt;ISO&lt;/code&gt; の出力。</target>
        </trans-unit>
        <trans-unit id="c7adcbeb9a00e6f9f8d55d348527ceb949cebeb0" translate="yes" xml:space="preserve">
          <source>The output should be:</source>
          <target state="translated">出力されるはずです。</target>
        </trans-unit>
        <trans-unit id="7d18635316d58c0f1b2d1367a93ab0ee048d2342" translate="yes" xml:space="preserve">
          <source>The overall file layout is: open square bracket, one or more sets of curly braces each of which represents a catalog row, close square bracket. Write a comma after each closing curly brace.</source>
          <target state="translated">ファイル全体のレイアウトは次のようになります:開いた角括弧、1つ以上の中括弧のセット、それぞれがカタログの行を表し、閉じた角括弧。閉じた中括弧の後にはコンマを書きます。</target>
        </trans-unit>
        <trans-unit id="8de7f224fb0466b959b163b48657edcd9f526ad8" translate="yes" xml:space="preserve">
          <source>The owner of a foreign server can alter user mappings for that server for any user. Also, a user can alter a user mapping for their own user name if &lt;code&gt;USAGE&lt;/code&gt; privilege on the server has been granted to the user.</source>
          <target state="translated">外部サーバーの所有者は、任意のユーザーのそのサーバーのユーザーマッピングを変更できます。また、サーバーに対する &lt;code&gt;USAGE&lt;/code&gt; 特権がユーザーに付与されている場合、ユーザーは自分のユーザー名のユーザーマッピングを変更できます。</target>
        </trans-unit>
        <trans-unit id="70e088bcc4a224d8f310f80a737853c522321de9" translate="yes" xml:space="preserve">
          <source>The owner of a foreign server can create user mappings for that server for any user. Also, a user can create a user mapping for their own user name if &lt;code&gt;USAGE&lt;/code&gt; privilege on the server has been granted to the user.</source>
          <target state="translated">外部サーバーの所有者は、任意のユーザーのそのサーバーのユーザーマッピングを作成できます。また、サーバーに対する &lt;code&gt;USAGE&lt;/code&gt; 特権がユーザーに付与されている場合、ユーザーは自分のユーザー名のユーザーマッピングを作成できます。</target>
        </trans-unit>
        <trans-unit id="85f81248211a9e60d13a1c97f497ca0b1b6a21d0" translate="yes" xml:space="preserve">
          <source>The owner of a foreign server can drop user mappings for that server for any user. Also, a user can drop a user mapping for their own user name if &lt;code&gt;USAGE&lt;/code&gt; privilege on the server has been granted to the user.</source>
          <target state="translated">外部サーバーの所有者は、任意のユーザーのそのサーバーのユーザーマッピングを削除できます。また、サーバーに対する &lt;code&gt;USAGE&lt;/code&gt; 特権がユーザーに付与されている場合、ユーザーは自分のユーザー名のユーザーマッピングを削除できます。</target>
        </trans-unit>
        <trans-unit id="6963c00112713ecda93817baf7fc7475ab9e7155" translate="yes" xml:space="preserve">
          <source>The papal bull of February 1582 decreed that 10 days should be dropped from October 1582 so that 15 October should follow immediately after 4 October. This was observed in Italy, Poland, Portugal, and Spain. Other Catholic countries followed shortly after, but Protestant countries were reluctant to change, and the Greek Orthodox countries didn't change until the start of the 20th century. The reform was observed by Great Britain and its dominions (including what is now the USA) in 1752. Thus 2 September 1752 was followed by 14 September 1752. This is why Unix systems that have the &lt;code&gt;cal&lt;/code&gt; program produce the following:</source>
          <target state="translated">1582年2月の教皇牛は、1582年10月から10日を削除して、10月15日が10月4日の直後に続くようにすることを布告しました。これは、イタリア、ポーランド、ポルトガル、スペインで観察されました。他のカトリック諸国もその直後に続きましたが、プロテスタント諸国は変化することに消極的で、ギリシャ正教会の国々は20世紀の初めまで変化しませんでした。改革は1752年にイギリスとその領土（現在はアメリカを含む）によって観察されました。したがって、1752年9月2日の後に1752年9月14日が続きました。これが、 &lt;code&gt;cal&lt;/code&gt; プログラムを備えたUnixシステムが以下を生成する理由です。</target>
        </trans-unit>
        <trans-unit id="265188275c6e5e56d9f827410bd00598d6ffb2ea" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-ACTIVITIES&quot;&gt;track_activities&lt;/a&gt; enables monitoring of the current command being executed by any server process.</source>
          <target state="translated">パラメータ&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-ACTIVITIES&quot;&gt;track_activities&lt;/a&gt;は、サーバープロセスによって実行されている現在のコマンドの監視を有効にします。</target>
        </trans-unit>
        <trans-unit id="e1be1796cec7a4cb2472b6d31337e6a73b1f4697" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt; controls whether statistics are collected about table and index accesses.</source>
          <target state="translated">パラメータ&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt;は、テーブルおよびインデックスアクセスに関する統計を収集するかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="c3e68d3468b41bd94198c06d139a59af78cfd7be" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-FUNCTIONS&quot;&gt;track_functions&lt;/a&gt; enables tracking of usage of user-defined functions.</source>
          <target state="translated">パラメータ&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-FUNCTIONS&quot;&gt;track_functionsを&lt;/a&gt;使用すると、ユーザー定義関数の使用状況を追跡できます。</target>
        </trans-unit>
        <trans-unit id="8df18f4279a1a3adf31a5aebfa3bc87053f75fc7" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; enables monitoring of block read and write times.</source>
          <target state="translated">パラメータ&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timingを&lt;/a&gt;使用すると、ブロックの読み取り時間と書き込み時間を監視できます。</target>
        </trans-unit>
        <trans-unit id="d547546da964747acd19cdd9eb1f2bdf8c4f57e8" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;&lt;code&gt;nulls&lt;/code&gt;&lt;/em&gt; determines whether null values should be included in the output. If true, null values in columns are represented as:</source>
          <target state="translated">パラメータ&lt;em&gt; &lt;code&gt;nulls&lt;/code&gt; &lt;/em&gt;は、null値を出力に含めるかどうかを決定します。trueの場合、列のnull値は次のように表されます。</target>
        </trans-unit>
        <trans-unit id="0b194e705f492d2a9e697965a54eb7bc8ec38435" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;&lt;code&gt;targetns&lt;/code&gt;&lt;/em&gt; specifies the desired XML namespace of the result. If no particular namespace is wanted, an empty string should be passed.</source>
          <target state="translated">パラメータ&lt;em&gt; &lt;code&gt;targetns&lt;/code&gt; &lt;/em&gt;は、結果の目的のXML名前空間を指定します。特定の名前空間が不要な場合は、空の文字列を渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="9da16630f92a321b59e356eb1f16f45959c31e24" translate="yes" xml:space="preserve">
          <source>The parameter data type(s) of the function.</source>
          <target state="translated">関数のパラメータデータ型。</target>
        </trans-unit>
        <trans-unit id="5d10e331ebaa600753d0a6fe423faa9e38a0555a" translate="yes" xml:space="preserve">
          <source>The parameter is the name of a table. The result is a set of records, with one row for each locked row within the table. The output columns are shown in &lt;a href=&quot;pgrowlocks#PGROWLOCKS-COLUMNS&quot;&gt;Table F.20&lt;/a&gt;.</source>
          <target state="translated">パラメータはテーブルの名前です。結果は、テーブル内のロックされた行ごとに1行のレコードのセットです。出力列を&lt;a href=&quot;pgrowlocks#PGROWLOCKS-COLUMNS&quot;&gt;表F.20に&lt;/a&gt;示します。</target>
        </trans-unit>
        <trans-unit id="2c2a6968b73a82456119add43eff37f88e4a3336" translate="yes" xml:space="preserve">
          <source>The parameter name</source>
          <target state="translated">パラメータ名</target>
        </trans-unit>
        <trans-unit id="10634e221a9f53cda3c36547bc9c020dce985fe4" translate="yes" xml:space="preserve">
          <source>The parameter symbols used to replace constants in representative query texts start from the next number after the highest &lt;code&gt;$&lt;/code&gt;&lt;code&gt;n&lt;/code&gt; parameter in the original query text, or &lt;code&gt;$1&lt;/code&gt; if there was none. It's worth noting that in some cases there may be hidden parameter symbols that affect this numbering. For example, PL/pgSQL uses hidden parameter symbols to insert values of function local variables into queries, so that a PL/pgSQL statement like &lt;code&gt;SELECT i + 1 INTO j&lt;/code&gt; would have representative text like &lt;code&gt;SELECT i + $2&lt;/code&gt;.</source>
          <target state="translated">代表的なクエリテキストの定数を置き換えるために使用されるパラメーターシンボルは、元のクエリテキストの最も高い &lt;code&gt;$&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; パラメーターの後の次の番号から始まります。ない場合は &lt;code&gt;$1&lt;/code&gt; です。場合によっては、この番号に影響を与える非表示のパラメーターシンボルが存在する可能性があることに注意してください。たとえば、PL / pgSQLは非表示のパラメーターシンボルを使用して関数のローカル変数の値をクエリに挿入するため、 &lt;code&gt;SELECT i + 1 INTO j&lt;/code&gt; ようなPL / pgSQLステートメントは &lt;code&gt;SELECT i + $2&lt;/code&gt; ような代表的なテキストになります。</target>
        </trans-unit>
        <trans-unit id="61c677b727193bb37a9911ff1962107228c69d5b" translate="yes" xml:space="preserve">
          <source>The parameter value</source>
          <target state="translated">パラメータの値</target>
        </trans-unit>
        <trans-unit id="bbcaadaf51c94b64fefad474400e1f3834e2ed35" translate="yes" xml:space="preserve">
          <source>The parameters can appear in any order, not only that illustrated above, and most are optional. You must register two or more functions (using &lt;code&gt;CREATE FUNCTION&lt;/code&gt;) before defining the type. The support functions &lt;code&gt;input_function&lt;/code&gt; and &lt;code&gt;output_function&lt;/code&gt; are required, while the functions &lt;code&gt;receive_function&lt;/code&gt;, &lt;code&gt;send_function&lt;/code&gt;, &lt;code&gt;type_modifier_input_function&lt;/code&gt;, &lt;code&gt;type_modifier_output_function&lt;/code&gt; and &lt;code&gt;analyze_function&lt;/code&gt; are optional. Generally these functions have to be coded in C or another low-level language.</source>
          <target state="translated">パラメータは、上に示したものだけでなく、任意の順序で指定でき、ほとんどがオプションです。タイプを定義する前に、（ &lt;code&gt;CREATE FUNCTION&lt;/code&gt; を使用して）2つ以上の関数を登録する必要があります。サポート関数 &lt;code&gt;input_function&lt;/code&gt; および &lt;code&gt;output_function&lt;/code&gt; は必須ですが、関数 &lt;code&gt;receive_function&lt;/code&gt; 、 &lt;code&gt;send_function&lt;/code&gt; 、 &lt;code&gt;type_modifier_input_function&lt;/code&gt; 、 &lt;code&gt;type_modifier_output_function&lt;/code&gt; および &lt;code&gt;analyze_function&lt;/code&gt; はオプションです。一般に、これらの関数はCまたは別の低水準言語でコーディングする必要があります。</target>
        </trans-unit>
        <trans-unit id="35c28a20bb52660d5ea22014191009de5ae11925" translate="yes" xml:space="preserve">
          <source>The parameters for the &lt;code&gt;MOVE&lt;/code&gt; command are identical to those of the &lt;code&gt;FETCH&lt;/code&gt; command; refer to &lt;a href=&quot;sql-fetch&quot;&gt;FETCH&lt;/a&gt; for details on syntax and usage.</source>
          <target state="translated">&lt;code&gt;MOVE&lt;/code&gt; コマンドのパラメーターは、 &lt;code&gt;FETCH&lt;/code&gt; コマンドのパラメーターと同じです。構文と使用法の詳細については、&lt;a href=&quot;sql-fetch&quot;&gt;FETCH&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c486bfa67e493a85ca76bb0a5dfe71e780089bca" translate="yes" xml:space="preserve">
          <source>The parameters of &lt;code&gt;CREATE AGGREGATE&lt;/code&gt; can be written in any order, not just the order illustrated above.</source>
          <target state="translated">&lt;code&gt;CREATE AGGREGATE&lt;/code&gt; のパラメーターは、上記の順序だけでなく、任意の順序で書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="d0f868092f1804769e10c18a42faa0f07b1980df" translate="yes" xml:space="preserve">
          <source>The parameters representing table and field names are copied as-is into the SQL queries that &lt;code&gt;connectby&lt;/code&gt; generates internally. Therefore, include double quotes if the names are mixed-case or contain special characters. You may also need to schema-qualify the table name.</source>
          <target state="translated">テーブル名とフィールド名を表すパラメーターは、 &lt;code&gt;connectby&lt;/code&gt; が内部で生成するSQLクエリにそのままコピーされます。したがって、名前が大/小文字が混在している場合や特殊文字が含まれている場合は、二重引用符を含めてください。また、テーブル名をスキーマ修飾する必要がある場合もあります。</target>
        </trans-unit>
        <trans-unit id="7230bb5c0f71b8c1dd5a14e1c76f97c166b31063" translate="yes" xml:space="preserve">
          <source>The parentheses are required here to show that &lt;code&gt;compositecol&lt;/code&gt; is a column name not a table name, or that &lt;code&gt;mytable&lt;/code&gt; is a table name not a schema name in the second case.</source>
          <target state="translated">ここで括弧は、 &lt;code&gt;compositecol&lt;/code&gt; がテーブル名ではなく列名であること、または2番目のケースでは &lt;code&gt;mytable&lt;/code&gt; がスキーマ名ではなくテーブル名であることを示すために必要です。</target>
        </trans-unit>
        <trans-unit id="3872d508fa039522a5d3058284138f504197106f" translate="yes" xml:space="preserve">
          <source>The parentheses in the last example are required. See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt; for more about arrays.</source>
          <target state="translated">最後の例の括弧は必須です。配列の詳細については、&lt;a href=&quot;arrays&quot;&gt;セクション8.15&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ba38ce516ae1d7c833e7896243109df28d306a9d" translate="yes" xml:space="preserve">
          <source>The parentheses or brackets indicate whether the lower and upper bounds are exclusive or inclusive, as described previously. Notice that the final pattern is &lt;code&gt;empty&lt;/code&gt;, which represents an empty range (a range that contains no points).</source>
          <target state="translated">括弧または括弧は、前述のように、下限と上限が排他的であるか包含的であるかを示します。最終的なパターンは &lt;code&gt;empty&lt;/code&gt; であることに注意してください。これは、空の範囲（ポイントを含まない範囲）を表します。</target>
        </trans-unit>
        <trans-unit id="09b446449a4319a7ef9115b3be9989109d17ce7e" translate="yes" xml:space="preserve">
          <source>The parser has to check the query string (which arrives as plain text) for valid syntax. If the syntax is correct a &lt;em&gt;parse tree&lt;/em&gt; is built up and handed back; otherwise an error is returned. The parser and lexer are implemented using the well-known Unix tools bison and flex.</source>
          <target state="translated">パーサーは、有効な構文についてクエリ文字列（プレーンテキストとして到着）をチェックする必要があります。構文が正しい場合、&lt;em&gt;解析ツリー&lt;/em&gt;が作成されて返されます。そうでない場合、エラーが返されます。パーサーとレクサーは、有名なUnixツールのbisonとflexを使用して実装されています。</target>
        </trans-unit>
        <trans-unit id="6ff5674ed423bd0fd40e474001e355555798b1f1" translate="yes" xml:space="preserve">
          <source>The parser initially marks the constants as being of type &lt;code&gt;integer&lt;/code&gt; and &lt;code&gt;numeric&lt;/code&gt; respectively. There is no &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt; operator in the system catalogs, but there is a &lt;code&gt;numeric&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt; operator. The query will therefore succeed if a cast from &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;numeric&lt;/code&gt; is available and is marked &lt;code&gt;AS IMPLICIT&lt;/code&gt; &amp;mdash; which in fact it is. The parser will apply the implicit cast and resolve the query as if it had been written</source>
          <target state="translated">パーサーは最初に定数をそれぞれ &lt;code&gt;integer&lt;/code&gt; 型および &lt;code&gt;numeric&lt;/code&gt; 型としてマークします。システムカタログには &lt;code&gt;integer&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;numeric&lt;/code&gt; 演算子はありませんが、 &lt;code&gt;numeric&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;numeric&lt;/code&gt; 演算子はあります。したがって、 &lt;code&gt;integer&lt;/code&gt; から &lt;code&gt;numeric&lt;/code&gt; へのキャストが利用可能で、 &lt;code&gt;AS IMPLICIT&lt;/code&gt; とマークされている場合、クエリは成功します &amp;mdash;実際にはそうです。パーサーは暗黙のキャストを適用し、クエリが書き込まれたかのように解決します</target>
        </trans-unit>
        <trans-unit id="25f13c18d68a86fdbefd4291a356d75813cdb2e5" translate="yes" xml:space="preserve">
          <source>The parser is defined in the file &lt;code&gt;gram.y&lt;/code&gt; and consists of a set of &lt;em&gt;grammar rules&lt;/em&gt; and &lt;em&gt;actions&lt;/em&gt; that are executed whenever a rule is fired. The code of the actions (which is actually C code) is used to build up the parse tree.</source>
          <target state="translated">パーサーは &lt;code&gt;gram.y&lt;/code&gt; ファイルで定義され、一連の&lt;em&gt;文法規則&lt;/em&gt;と、規則が実行されるたびに実行される&lt;em&gt;アクション&lt;/em&gt;で構成されます。アクションのコード（実際にはCコード）は、解析ツリーを構築するために使用されます。</target>
        </trans-unit>
        <trans-unit id="1857339fc15ab225bd01ccd9d926ca70975b0fc9" translate="yes" xml:space="preserve">
          <source>The parser learns from the &lt;code&gt;pg_cast&lt;/code&gt; catalog that &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;varchar&lt;/code&gt; are binary-compatible, meaning that one can be passed to a function that accepts the other without doing any physical conversion. Therefore, no type conversion call is really inserted in this case.</source>
          <target state="translated">パーサーは &lt;code&gt;pg_cast&lt;/code&gt; カタログから、 &lt;code&gt;text&lt;/code&gt; と &lt;code&gt;varchar&lt;/code&gt; がバイナリ互換であることを学習します。つまり、物理変換を行わずに、一方を他方を受け入れる関数に渡すことができます。したがって、この場合、タイプ変換呼び出しは実際には挿入されません。</target>
        </trans-unit>
        <trans-unit id="0e756c19d42be08cb71cc09834d6f8f8f843f91e" translate="yes" xml:space="preserve">
          <source>The parser stage creates a parse tree using only fixed rules about the syntactic structure of SQL. It does not make any lookups in the system catalogs, so there is no possibility to understand the detailed semantics of the requested operations. After the parser completes, the &lt;em&gt;transformation process&lt;/em&gt; takes the tree handed back by the parser as input and does the semantic interpretation needed to understand which tables, functions, and operators are referenced by the query. The data structure that is built to represent this information is called the &lt;em&gt;query tree&lt;/em&gt;.</source>
          <target state="translated">パーサーステージは、SQLの構文構造に関する固定ルールのみを使用して解析ツリーを作成します。システムカタログでルックアップを行わないため、要求された操作の詳細なセマンティクスを理解することはできません。パーサーが完了すると、&lt;em&gt;変換プロセス&lt;/em&gt;は、パーサーから渡されたツリーを入力として受け取り、クエリによって参照されるテーブル、関数、および演算子を理解するために必要なセマンティック解釈を行います。この情報を表すために構築されたデータ構造は、&lt;em&gt;クエリツリー&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ebdbb42aa00d24e0d513d01a8c9b666b615ba1dd" translate="yes" xml:space="preserve">
          <source>The parser's notion of a &amp;ldquo;letter&amp;rdquo; is determined by the database's locale setting, specifically &lt;code&gt;lc_ctype&lt;/code&gt;. Words containing only the basic ASCII letters are reported as a separate token type, since it is sometimes useful to distinguish them. In most European languages, token types &lt;code&gt;word&lt;/code&gt; and &lt;code&gt;asciiword&lt;/code&gt; should be treated alike.</source>
          <target state="translated">パーサーの「文字」の概念は、データベースのロケール設定、特に &lt;code&gt;lc_ctype&lt;/code&gt; によって決まります。基本的なASCII文字のみを含む単語は、区別するのに役立つ場合があるため、別のトークンタイプとして報告されます。ほとんどのヨーロッパ言語では、トークンタイプ &lt;code&gt;word&lt;/code&gt; と &lt;code&gt;asciiword&lt;/code&gt; は同じように扱う必要があります。</target>
        </trans-unit>
        <trans-unit id="7a4e5a431eb644b141f3790b8cfbc5fd53514f52" translate="yes" xml:space="preserve">
          <source>The partial transaction isolation provided by Read Committed mode is adequate for many applications, and this mode is fast and simple to use; however, it is not sufficient for all cases. Applications that do complex queries and updates might require a more rigorously consistent view of the database than Read Committed mode provides.</source>
          <target state="translated">Read Committedモードで提供される部分的なトランザクションの分離は多くのアプリケーションに適しており、このモードは高速で使いやすいですが、すべての場合に十分ではありません。複雑なクエリや更新を行うアプリケーションでは、Read Committedモードが提供するよりも厳密に一貫したデータベースの表示が必要になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="eb9b101fa3ff04c41a301e2ea58c51b731736d02" translate="yes" xml:space="preserve">
          <source>The partition bound specification for a new partition. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details on the syntax of the same.</source>
          <target state="translated">新しいパーティションのパーティションバインド仕様。構文の詳細については、&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a843f1857d3445c37bfb25c214ac7c60e2eda3b2" translate="yes" xml:space="preserve">
          <source>The password is always stored encrypted in the system catalogs. The &lt;code&gt;ENCRYPTED&lt;/code&gt; keyword has no effect, but is accepted for backwards compatibility. The method of encryption is determined by the configuration parameter &lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt;. If the presented password string is already in MD5-encrypted or SCRAM-encrypted format, then it is stored as-is regardless of &lt;code&gt;password_encryption&lt;/code&gt; (since the system cannot decrypt the specified encrypted password string, to encrypt it in a different format). This allows reloading of encrypted passwords during dump/restore.</source>
          <target state="translated">パスワードは常にシステムカタログに暗号化されて保存されます。 &lt;code&gt;ENCRYPTED&lt;/code&gt; キーワードは効果がありませんが、後方互換性のために受け入れられています。暗号化の方法は、構成パラメーター&lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt;によって決定されます。提示されたパスワード文字列がすでにMD5暗号化またはSCRAM暗号化形式である場合、それは &lt;code&gt;password_encryption&lt;/code&gt; に関係なくそのまま保存されます（指定された暗号化パスワード文字列を復号化して別の形式で暗号化することはできないため）。これにより、ダンプ/復元中に暗号化されたパスワードをリロードできます。</target>
        </trans-unit>
        <trans-unit id="d6a56dd735da3ef3f125939acf3298322bea99f6" translate="yes" xml:space="preserve">
          <source>The path at your site might be different. Contact your site administrator or check the installation instructions to correct the situation.</source>
          <target state="translated">ご利用のサイトのパスが異なる場合があります。サイト管理者に連絡するか、インストール方法を確認して修正してください。</target>
        </trans-unit>
        <trans-unit id="ae4a259e6f096215a3bc76dbbbf4ab5a1fa7063f" translate="yes" xml:space="preserve">
          <source>The path expression contains &lt;code&gt;type()&lt;/code&gt; or &lt;code&gt;size()&lt;/code&gt; methods that return the type and the number of elements in the array, respectively.</source>
          <target state="translated">パス式には、配列のタイプと要素数をそれぞれ返す &lt;code&gt;type()&lt;/code&gt; または &lt;code&gt;size()&lt;/code&gt; メソッドが含まれています。</target>
        </trans-unit>
        <trans-unit id="665f879c5dd1bad744ce39b38be0ec7bfa475f6e" translate="yes" xml:space="preserve">
          <source>The path name of the input or output file. An input file name can be an absolute or relative path, but an output file name must be an absolute path. Windows users might need to use an &lt;code&gt;E''&lt;/code&gt; string and double any backslashes used in the path name.</source>
          <target state="translated">入力ファイルまたは出力ファイルのパス名。入力ファイル名は絶対パスまたは相対パスにすることができますが、出力ファイル名は絶対パスでなければなりません。Windowsユーザーは、 &lt;code&gt;E''&lt;/code&gt; 文字列を使用し、パス名に使用されるバックスラッシュを2倍にする必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="acfece2d4d4a40c54bd9f721a413e8f8e6ea9b4c" translate="yes" xml:space="preserve">
          <source>The pattern characters &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, and &lt;code&gt;G&lt;/code&gt; represent the sign, currency symbol, decimal point, and thousands separator characters defined by the current locale (see &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt; and &lt;a href=&quot;runtime-config-client#GUC-LC-NUMERIC&quot;&gt;lc_numeric&lt;/a&gt;). The pattern characters period and comma represent those exact characters, with the meanings of decimal point and thousands separator, regardless of locale.</source>
          <target state="translated">パターン文字 &lt;code&gt;S&lt;/code&gt; 、 &lt;code&gt;L&lt;/code&gt; 、 &lt;code&gt;D&lt;/code&gt; 、および &lt;code&gt;G&lt;/code&gt; は、現在のロケールで定義されている符号、通貨記号、小数点、および桁区切り記号を&lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;表し&lt;/a&gt;ます（lc_monetaryおよび&lt;a href=&quot;runtime-config-client#GUC-LC-NUMERIC&quot;&gt;lc_numericを&lt;/a&gt;参照）。パターン文字のピリオドとコンマは、ロケールに関係なく、小数点と3桁ごとの区切り記号の意味を持つそれらの正確な文字を表します。</target>
        </trans-unit>
        <trans-unit id="0f3ba6e11e445232d30834cd144281a86bebafa9" translate="yes" xml:space="preserve">
          <source>The pattern matching operators of all three kinds do not support nondeterministic collations. If required, apply a different collation to the expression to work around this limitation.</source>
          <target state="translated">3種類すべてのパターンマッチング演算子は、非決定的な照合をサポートしていません。必要であれば、この制限を回避するために、式に別の照合を適用してください。</target>
        </trans-unit>
        <trans-unit id="53ad7762f98479cbca28b8363660cbfe1cf95173" translate="yes" xml:space="preserve">
          <source>The payload of the notifications consists of the table name, a letter to indicate which type of operation was performed, and column name/value pairs for primary key columns. Each part is separated from the next by a comma. For ease of parsing using regular expressions, table and column names are always wrapped in double quotes, and data values are always wrapped in single quotes. Embedded quotes are doubled.</source>
          <target state="translated">通知のペイロードは、テーブル名、どのタイプの操作が実行されたかを示す文字、主キーカラムのカラム名/値のペアで構成される。各部分はカンマで区切られています。正規表現を使用した解析を容易にするために、テーブル名とカラム名は常に二重引用符で、データ値は常に一重引用符で囲まれています。埋め込み引用符は2倍になります。</target>
        </trans-unit>
        <trans-unit id="99b6bf90a9bb8e6d618127a1a2c46cd208469261" translate="yes" xml:space="preserve">
          <source>The peer authentication method works by obtaining the client's operating system user name from the kernel and using it as the allowed database user name (with optional user name mapping). This method is only supported on local connections.</source>
          <target state="translated">ピア認証方法は、クライアントのオペレーティングシステムのユーザ名をカーネルから取得し、それを許可されたデータベースのユーザ名として使用することで動作します (オプションのユーザ名マッピングを使用します)。この方法はローカル接続でのみサポートされます。</target>
        </trans-unit>
        <trans-unit id="919e0066d8303b60f8d9dce39383d269124b1827" translate="yes" xml:space="preserve">
          <source>The per-index statistics are particularly useful to determine which indexes are being used and how effective they are.</source>
          <target state="translated">特にインデックスあたりの統計は、どのインデックスが使われているのか、どの程度の効果があるのかを把握するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="2b32037bdcf53d4293fda5e00a43bb07b50f376a" translate="yes" xml:space="preserve">
          <source>The performance of an R-tree index can largely depend on the initial order of input values. It may be very helpful to sort the input table on the &lt;code&gt;seg&lt;/code&gt; column; see the script &lt;code&gt;sort-segments.pl&lt;/code&gt; for an example.</source>
          <target state="translated">Rツリーインデックスのパフォーマンスは、入力値の初期順序に大きく依存します。入力テーブルを &lt;code&gt;seg&lt;/code&gt; 列でソートすると非常に役立つ場合があります。例については、スクリプト &lt;code&gt;sort-segments.pl&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="794af340a68964153b03ef2b6d22753d285cf9d8" translate="yes" xml:space="preserve">
          <source>The period (&lt;code&gt;.&lt;/code&gt;) is used in numeric constants, and to separate schema, table, and column names.</source>
          <target state="translated">ピリオド（ &lt;code&gt;.&lt;/code&gt; ）は数値定数で使用され、スキーマ、テーブル、列の名前を区切るために使用されます。</target>
        </trans-unit>
        <trans-unit id="1dd06a0691afe3884d57662cd23df0c2e7cc6503" translate="yes" xml:space="preserve">
          <source>The pg_config utility prints configuration parameters of the currently installed version of PostgreSQL. It is intended, for example, to be used by software packages that want to interface to PostgreSQL to facilitate finding the required header files and libraries.</source>
          <target state="translated">pg_configユーティリティは、現在インストールされているバージョンのPostgreSQLの設定パラメータを表示します。これは例えば、必要なヘッダファイルやライブラリを見つけるのを容易にするためにPostgreSQLにインターフェースを提供したいソフトウェアパッケージが使用することを意図しています。</target>
        </trans-unit>
        <trans-unit id="38257de71aaf3c94498314a3023e95f97988a3ee" translate="yes" xml:space="preserve">
          <source>The phenomena which are prohibited at various levels are:</source>
          <target state="translated">様々なレベルで禁止されている現象は</target>
        </trans-unit>
        <trans-unit id="eb2bc77065c28244748a514edbbf72d360f29dfc" translate="yes" xml:space="preserve">
          <source>The physical location of the row version within its table. Note that although the &lt;code&gt;ctid&lt;/code&gt; can be used to locate the row version very quickly, a row's &lt;code&gt;ctid&lt;/code&gt; will change if it is updated or moved by &lt;code&gt;VACUUM FULL&lt;/code&gt;. Therefore &lt;code&gt;ctid&lt;/code&gt; is useless as a long-term row identifier. A primary key should be used to identify logical rows.</source>
          <target state="translated">テーブル内の行バージョンの物理的な場所。あることに注意してください &lt;code&gt;ctid&lt;/code&gt; 非常に迅速に行バージョンを見つけるために使用することができ、行の &lt;code&gt;ctid&lt;/code&gt; それが更新またはによって移動された場合に変更されます &lt;code&gt;VACUUM FULL&lt;/code&gt; 。したがって、 &lt;code&gt;ctid&lt;/code&gt; は長期的な行識別子としては役に立ちません。論理行を識別するには、主キーを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="ed43e04d92b420464b4279a7468ab8888b8672c6" translate="yes" xml:space="preserve">
          <source>The planner assumes that the two conditions are independent, so that the individual selectivities of the clauses can be multiplied together:</source>
          <target state="translated">プランナーは、2つの条件が独立していることを前提としているので、節の個々の選択性を掛け合わせることができます。</target>
        </trans-unit>
        <trans-unit id="5f8b19a5896d87add8af3e241d28d22aabc60ce5" translate="yes" xml:space="preserve">
          <source>The planner cannot automatically determine whether a user-defined function or aggregate is parallel safe, parallel restricted, or parallel unsafe, because this would require predicting every operation which the function could possibly perform. In general, this is equivalent to the Halting Problem and therefore impossible. Even for simple functions where it could conceivably be done, we do not try, since this would be expensive and error-prone. Instead, all user-defined functions are assumed to be parallel unsafe unless otherwise marked. When using &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; or &lt;a href=&quot;sql-alterfunction&quot;&gt;ALTER FUNCTION&lt;/a&gt;, markings can be set by specifying &lt;code&gt;PARALLEL SAFE&lt;/code&gt;, &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;, or &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; as appropriate. When using &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;, the &lt;code&gt;PARALLEL&lt;/code&gt; option can be specified with &lt;code&gt;SAFE&lt;/code&gt;, &lt;code&gt;RESTRICTED&lt;/code&gt;, or &lt;code&gt;UNSAFE&lt;/code&gt; as the corresponding value.</source>
          <target state="translated">関数が実行する可能性のあるすべての操作を予測する必要があるため、プランナは、ユーザー定義関数または集計が並列安全、並列制限、または並列安全でないかどうかを自動的に判断できません。一般に、これは停止問題と同等であり、したがって不可能です。実行できると思われる単純な関数であっても、コストがかかり、エラーが発生しやすいため、試さないでください。代わりに、特に明記されていない限り、すべてのユーザー定義関数は並列安全ではないと見なされます。&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;または&lt;a href=&quot;sql-alterfunction&quot;&gt;ALTER FUNCTION&lt;/a&gt;を使用する場合、 &lt;code&gt;PARALLEL SAFE&lt;/code&gt; 、 &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; 、または &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; を適切に指定することにより、マーキングを設定できます。使用する場合&lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;、 &lt;code&gt;PARALLEL&lt;/code&gt; オプションは、対応する値として &lt;code&gt;SAFE&lt;/code&gt; 、 &lt;code&gt;RESTRICTED&lt;/code&gt; 、または &lt;code&gt;UNSAFE&lt;/code&gt; を使用して指定できます。</target>
        </trans-unit>
        <trans-unit id="9b371bcb4f76e8388ab2f98830da7c42b56f6e59" translate="yes" xml:space="preserve">
          <source>The planner classifies operations involved in a query as either &lt;em&gt;parallel safe&lt;/em&gt;, &lt;em&gt;parallel restricted&lt;/em&gt;, or &lt;em&gt;parallel unsafe&lt;/em&gt;. A parallel safe operation is one which does not conflict with the use of parallel query. A parallel restricted operation is one which cannot be performed in a parallel worker, but which can be performed in the leader while parallel query is in use. Therefore, parallel restricted operations can never occur below a &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node, but can occur elsewhere in a plan which contains such a node. A parallel unsafe operation is one which cannot be performed while parallel query is in use, not even in the leader. When a query contains anything which is parallel unsafe, parallel query is completely disabled for that query.</source>
          <target state="translated">プランナは、クエリに関連する操作を、&lt;em&gt;並列安全&lt;/em&gt;、&lt;em&gt;並列制限&lt;/em&gt;、または&lt;em&gt;並列非安全の&lt;/em&gt;いずれかに分類します。並列安全操作は、並列クエリの使用と競合しない操作です。並列制限付き操作は、並列ワーカーでは実行できないが、並列クエリの使用中にリーダーで実行できる操作です。したがって、 &lt;code&gt;Gather&lt;/code&gt; または &lt;code&gt;Gather Merge&lt;/code&gt; の下では、並行して制限された操作が発生することはありません。ノードですが、そのようなノードを含むプランの他の場所で発生する可能性があります。並列の安全でない操作とは、並列クエリが使用されている間は実行できず、リーダーでさえ実行できない操作です。クエリに並列で安全でないものが含まれている場合、そのクエリの並列クエリは完全に無効になります。</target>
        </trans-unit>
        <trans-unit id="41ec537c1145f33dc399ea4d0d8e72c677f37799" translate="yes" xml:space="preserve">
          <source>The planner estimates the selectivity for each condition individually, arriving at the same 1% estimates as above. Then it assumes that the conditions are independent, and so it multiplies their selectivities, producing a final selectivity estimate of just 0.01%. This is a significant underestimate, as the actual number of rows matching the conditions (100) is two orders of magnitude higher.</source>
          <target state="translated">プランナーは,各条件についての選択率を個別に推定し,上記と同じ1%の推定値に到達する.そして、条件が独立していると仮定して、それらの選択率を掛け合わせ、最終的な選択率の推定値はわずか0.01%になります。条件にマッチする実際の行の数(100)は2桁高いので、これはかなりの過小評価です。</target>
        </trans-unit>
        <trans-unit id="12ef35e8963b60e1a1f66c8c5c86ede0e85c0b68" translate="yes" xml:space="preserve">
          <source>The planner examines the &lt;code&gt;WHERE&lt;/code&gt; clause condition and looks up the selectivity function for the operator &lt;code&gt;&amp;lt;&lt;/code&gt; in &lt;code&gt;pg_operator&lt;/code&gt;. This is held in the column &lt;code&gt;oprrest&lt;/code&gt;, and the entry in this case is &lt;code&gt;scalarltsel&lt;/code&gt;. The &lt;code&gt;scalarltsel&lt;/code&gt; function retrieves the histogram for &lt;code&gt;unique1&lt;/code&gt; from &lt;code&gt;pg_statistic&lt;/code&gt;. For manual queries it is more convenient to look in the simpler &lt;code&gt;pg_stats&lt;/code&gt; view:</source>
          <target state="translated">プランナーは調べ &lt;code&gt;WHERE&lt;/code&gt; オペレータのための選択機能アップ条項の条件とルックス &lt;code&gt;&amp;lt;&lt;/code&gt; 中 &lt;code&gt;pg_operator&lt;/code&gt; 。これは列 &lt;code&gt;oprrest&lt;/code&gt; に保持され、この場合のエントリは &lt;code&gt;scalarltsel&lt;/code&gt; です。 &lt;code&gt;scalarltsel&lt;/code&gt; の機能は、ヒストグラム取得 &lt;code&gt;unique1&lt;/code&gt; から &lt;code&gt;pg_statistic&lt;/code&gt; 。手動クエリの場合は、より単純な &lt;code&gt;pg_stats&lt;/code&gt; ビューを調べるほうが便利です。</target>
        </trans-unit>
        <trans-unit id="55eece76171cb5150093319bc0d23d3c3262a30e" translate="yes" xml:space="preserve">
          <source>The planner examines the condition and determines the selectivity of this clause to be 1%. By comparing this estimate and the actual number of rows, we see that the estimate is very accurate (in fact exact, as the table is very small). Changing the &lt;code&gt;WHERE&lt;/code&gt; condition to use the &lt;code&gt;b&lt;/code&gt; column, an identical plan is generated. But observe what happens if we apply the same condition on both columns, combining them with &lt;code&gt;AND&lt;/code&gt;:</source>
          <target state="translated">プランナーは条件を調べ、この句の選択性を1％と決定します。この見積もりと実際の行数を比較すると、見積もりが非常に正確であることがわかります（テーブルが非常に小さいため、実際には正確です）。 &lt;code&gt;b&lt;/code&gt; 列を使用するように &lt;code&gt;WHERE&lt;/code&gt; 条件を変更すると、同じプランが生成されます。しかし、両方の列に同じ条件を適用し、それらを &lt;code&gt;AND&lt;/code&gt; で結合するとどうなるかを観察します。</target>
        </trans-unit>
        <trans-unit id="ccbe97e96812fba17e36b64c7a8a14a6a5fc672b" translate="yes" xml:space="preserve">
          <source>The planner thinks (quite correctly) that this sample table is too small to bother with an index scan, so we have a plain sequential scan in which all the rows got rejected by the filter condition. But if we force an index scan to be used, we see:</source>
          <target state="translated">プランナーは、このサンプルテーブルが小さすぎてインデックススキャンを気にすることができないと(かなり正確に)考えているので、フィルタ条件によってすべての行が拒否されたプレーンなシーケンシャルスキャンを行います。しかし、インデックススキャンを強制的に使用すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="9e657fb9f6d61f80be4eb7b46475ad5f607f9e2a" translate="yes" xml:space="preserve">
          <source>The planner will consider satisfying an &lt;code&gt;ORDER BY&lt;/code&gt; specification either by scanning an available index that matches the specification, or by scanning the table in physical order and doing an explicit sort. For a query that requires scanning a large fraction of the table, an explicit sort is likely to be faster than using an index because it requires less disk I/O due to following a sequential access pattern. Indexes are more useful when only a few rows need be fetched. An important special case is &lt;code&gt;ORDER BY&lt;/code&gt; in combination with &lt;code&gt;LIMIT&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;: an explicit sort will have to process all the data to identify the first &lt;code&gt;n&lt;/code&gt; rows, but if there is an index matching the &lt;code&gt;ORDER BY&lt;/code&gt;, the first &lt;code&gt;n&lt;/code&gt; rows can be retrieved directly, without scanning the remainder at all.</source>
          <target state="translated">プランナーは、仕様に一致する使用可能なインデックスをスキャンするか、物理的な順序でテーブルをスキャンして明示的なソートを行うことにより、 &lt;code&gt;ORDER BY&lt;/code&gt; 仕様を満たすことを検討します。テーブルの大部分をスキャンする必要があるクエリの場合、シーケンシャルアクセスパターンに従うため、必要なディスクI / Oが少ないため、明示的なソートはインデックスを使用するよりも高速になる可能性があります。インデックスは、フェッチする必要があるのが数行のみの場合により便利です。重要な特殊なケースがある &lt;code&gt;ORDER BY&lt;/code&gt; と組み合わせて &lt;code&gt;LIMIT&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; は：明示的なソートは、最初に識別するために、すべてのデータを処理する必要があります &lt;code&gt;n&lt;/code&gt; 個の行を、しかし、屈折率整合がある場合は &lt;code&gt;ORDER BY&lt;/code&gt; 、最初 &lt;code&gt;n&lt;/code&gt; 行は、残りをまったくスキャンせずに直接取得できます。</target>
        </trans-unit>
        <trans-unit id="f13fe03a32c9bbc1e61cf84d9ac188afb139c0ce" translate="yes" xml:space="preserve">
          <source>The planner will merge sub-queries into upper queries if the resulting &lt;code&gt;FROM&lt;/code&gt; list would have no more than this many items. Smaller values reduce planning time but might yield inferior query plans. The default is eight. For more information see &lt;a href=&quot;explicit-joins&quot;&gt;Section 14.3&lt;/a&gt;.</source>
          <target state="translated">結果の &lt;code&gt;FROM&lt;/code&gt; リストにこれより多くのアイテムがない場合、プランナーはサブクエリを上位クエリにマージします。値が小さいほど計画時間は短縮されますが、クエリプランが低下する可能性があります。デフォルトは8です。詳細については、&lt;a href=&quot;explicit-joins&quot;&gt;セクション14.3を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7e54dd315c563119cab38a459210d1e25c17b541" translate="yes" xml:space="preserve">
          <source>The planner will rewrite explicit &lt;code&gt;JOIN&lt;/code&gt; constructs (except &lt;code&gt;FULL JOIN&lt;/code&gt;s) into lists of &lt;code&gt;FROM&lt;/code&gt; items whenever a list of no more than this many items would result. Smaller values reduce planning time but might yield inferior query plans.</source>
          <target state="translated">プランナは、明示的な &lt;code&gt;JOIN&lt;/code&gt; 構文（ &lt;code&gt;FULL JOIN&lt;/code&gt; を除く）を &lt;code&gt;FROM&lt;/code&gt; アイテムのリストに書き換えます。これにより、この数以下のアイテムのリストが生成されます。値が小さいほど計画時間は短縮されますが、クエリプランが低下する可能性があります。</target>
        </trans-unit>
        <trans-unit id="51459135e7da0626e3461453ee190521c7ca83f8" translate="yes" xml:space="preserve">
          <source>The planner's information about the query being processed.</source>
          <target state="translated">処理中のクエリに関するプランナーの情報です。</target>
        </trans-unit>
        <trans-unit id="1577e921445112f0dec558626039eff4a0e20d9e" translate="yes" xml:space="preserve">
          <source>The planner's search procedure actually works with data structures called &lt;em&gt;paths&lt;/em&gt;, which are simply cut-down representations of plans containing only as much information as the planner needs to make its decisions. After the cheapest path is determined, a full-fledged &lt;em&gt;plan tree&lt;/em&gt; is built to pass to the executor. This represents the desired execution plan in sufficient detail for the executor to run it. In the rest of this section we'll ignore the distinction between paths and plans.</source>
          <target state="translated">プランナーの検索手順は、実際には&lt;em&gt;パス&lt;/em&gt;と呼ばれるデータ構造で機能し&lt;em&gt;ます&lt;/em&gt;。これは、プランナーが決定を下すのに必要な情報だけを含むプランの単純な表現です。最も安いパスが決定された後、エグゼキュータに渡すための本格的な&lt;em&gt;計画ツリー&lt;/em&gt;が構築されます。これは、エグゼキューターがそれを実行するのに十分な詳細で、望ましい実行プランを表します。このセクションの残りの部分では、パスとプランの違いを無視します。</target>
        </trans-unit>
        <trans-unit id="4a55c4b471813d250b09c8e9cf01cec1bc297015" translate="yes" xml:space="preserve">
          <source>The planner/optimizer starts by generating plans for scanning each individual relation (table) used in the query. The possible plans are determined by the available indexes on each relation. There is always the possibility of performing a sequential scan on a relation, so a sequential scan plan is always created. Assume an index is defined on a relation (for example a B-tree index) and a query contains the restriction &lt;code&gt;relation.attribute OPR constant&lt;/code&gt;. If &lt;code&gt;relation.attribute&lt;/code&gt; happens to match the key of the B-tree index and &lt;code&gt;OPR&lt;/code&gt; is one of the operators listed in the index's &lt;em&gt;operator class&lt;/em&gt;, another plan is created using the B-tree index to scan the relation. If there are further indexes present and the restrictions in the query happen to match a key of an index, further plans will be considered. Index scan plans are also generated for indexes that have a sort ordering that can match the query's &lt;code&gt;ORDER BY&lt;/code&gt; clause (if any), or a sort ordering that might be useful for merge joining (see below).</source>
          <target state="translated">プランナー/オプティマイザーは、クエリで使用される個々のリレーション（テーブル）をスキャンするためのプランを生成することから始めます。可能なプランは、各関係で使用可能なインデックスによって決定されます。リレーションで順次スキャンを実行する可能性は常にあるため、順次スキャン計画が常に作成されます。インデックスがリレーション（Bツリーインデックスなど）で定義されており、クエリに制限 &lt;code&gt;relation.attribute OPR constant&lt;/code&gt; が含まれていると仮定します。場合 &lt;code&gt;relation.attribute&lt;/code&gt; B-treeインデックスのキーと一致するように起こり、 &lt;code&gt;OPR&lt;/code&gt; は、インデックスの中に記載されている事業者の一つである&lt;em&gt;演算子クラス&lt;/em&gt;、リレーションシップをスキャンするためにBツリーインデックスを使用して別のプランが作成されます。追加のインデックスが存在し、クエリの制限がインデックスのキーと一致する場合、追加のプランが検討されます。インデックススキャンプランは、クエリの &lt;code&gt;ORDER BY&lt;/code&gt; 句（存在する場合）に一致するソート順、またはマージ結合に役立つソート順（以下を参照）を持つインデックスに対しても生成されます。</target>
        </trans-unit>
        <trans-unit id="af6fcc949e29ec6b5395bb9895c598ac00851a39" translate="yes" xml:space="preserve">
          <source>The policy above implicitly provides a &lt;code&gt;WITH CHECK&lt;/code&gt; clause identical to its &lt;code&gt;USING&lt;/code&gt; clause, so that the constraint applies both to rows selected by a command (so a manager cannot &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; existing rows belonging to a different manager) and to rows modified by a command (so rows belonging to a different manager cannot be created via &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;).</source>
          <target state="translated">上記のポリシーは、 &lt;code&gt;USING&lt;/code&gt; 句と同じ &lt;code&gt;WITH CHECK&lt;/code&gt; 句を暗黙的に提供するため、コマンドによって選択された行（マネージャーが別のマネージャーに属する既存の行を &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、または &lt;code&gt;DELETE&lt;/code&gt; できない）と変更された行の両方に制約が適用されますコマンドによって（したがって、別のマネージャーに属する行は、 &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; を介して作成できません）。</target>
        </trans-unit>
        <trans-unit id="332f3ca0119d1ff928cc3032c43d7a8c6d076ef7" translate="yes" xml:space="preserve">
          <source>The port number at which the database server is listening.</source>
          <target state="translated">データベースサーバーがリッスンしているポート番号。</target>
        </trans-unit>
        <trans-unit id="3946be524d4d21ed59a4396709c558221452e965" translate="yes" xml:space="preserve">
          <source>The port number on the RADIUS servers to connect to. If no port is specified, the default port &lt;code&gt;1812&lt;/code&gt; will be used.</source>
          <target state="translated">接続するRADIUSサーバーのポート番号。ポートを指定しない場合、デフォルトのポート &lt;code&gt;1812&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="d78397caeb854681d204384441be23fbf5963377" translate="yes" xml:space="preserve">
          <source>The possible privileges are:</source>
          <target state="translated">考えられる特典は</target>
        </trans-unit>
        <trans-unit id="f40d6965a9bc397fb0c918307a4356333c6e9be1" translate="yes" xml:space="preserve">
          <source>The possible types of qualified join are:</source>
          <target state="translated">資格を持った人が参加することが可能なタイプは、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="150d329b119d4f11b9ac2cd02c8c0d218611bacb" translate="yes" xml:space="preserve">
          <source>The potential for bloat in non-B-tree indexes has not been well researched. It is a good idea to periodically monitor the index's physical size when using any non-B-tree index type.</source>
          <target state="translated">非B-treeインデックスにおける肥大化の可能性は、あまり研究されていません。非B-treeインデックスタイプを使用する場合は、定期的にインデックスの物理的なサイズを監視することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d757a72d029cfb4caba9e0b1db29785724f4d19a" translate="yes" xml:space="preserve">
          <source>The preceding statement is not true on Microsoft Windows: there, any changes in the &lt;code&gt;pg_hba.conf&lt;/code&gt; file are immediately applied by subsequent new connections.</source>
          <target state="translated">上記の説明はMicrosoft Windowsには当てはまりません &lt;code&gt;pg_hba.conf&lt;/code&gt; ファイルの変更は、その後の新しい接続によってすぐに適用されます。</target>
        </trans-unit>
        <trans-unit id="252c412e1c63dfae47e051caef322b62e83bb886" translate="yes" xml:space="preserve">
          <source>The precise rule that is applied in such cases is that an invalid timestamp that appears to fall within a jump-forward daylight savings transition is assigned the UTC offset that prevailed in the time zone just before the transition, while an ambiguous timestamp that could fall on either side of a jump-back transition is assigned the UTC offset that prevailed just after the transition. In most time zones this is equivalent to saying that &amp;ldquo;the standard-time interpretation is preferred when in doubt&amp;rdquo;.</source>
          <target state="translated">そのような場合に適用される正確なルールは、ジャンプフォワードフォワード夏時間移行に該当すると思われる無効なタイムスタンプには、移行直前のタイムゾーンで優勢だったUTCオフセットが割り当てられ、あいまいなタイムスタンプにはジャンプバック遷移のどちらの側にも、遷移の直後に適用されたUTCオフセットが割り当てられます。ほとんどのタイムゾーンでは、これは「疑わしい場合は標準時の解釈が好ましい」と言うことと同じです。</target>
        </trans-unit>
        <trans-unit id="28bfcc19c7bbea45feb0d0e7674c45c3d0b2a8ce" translate="yes" xml:space="preserve">
          <source>The precision must be positive, the scale zero or positive. Alternatively:</source>
          <target state="translated">精度は正でなければならず,目盛はゼロまたは正でなければなりません.あるいは</target>
        </trans-unit>
        <trans-unit id="3ffc8a93a54e6689bf8eb9af624f2ca2cef390c0" translate="yes" xml:space="preserve">
          <source>The predefined aggregate functions are described in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt;. Other aggregate functions can be added by the user.</source>
          <target state="translated">事前定義された集計関数については、&lt;a href=&quot;functions-aggregate&quot;&gt;セクション9.20で&lt;/a&gt;説明されています。ユーザーは他の集約関数を追加できます。</target>
        </trans-unit>
        <trans-unit id="85290651a145a4790c306bf3090be3ac088ff86f" translate="yes" xml:space="preserve">
          <source>The preferred key type is &amp;ldquo;DSA and Elgamal&amp;rdquo;.</source>
          <target state="translated">推奨される鍵タイプは「DSAおよびElgamal」です。</target>
        </trans-unit>
        <trans-unit id="9dcad895255c51069330af5d11a7861de5e972db" translate="yes" xml:space="preserve">
          <source>The preferred way of creating any of the standard procedural languages is just:</source>
          <target state="translated">標準的な手続き言語のいずれかを作成するための好ましい方法は、ただそれだけです。</target>
        </trans-unit>
        <trans-unit id="1d193e74c38ebc3f88cf6c96d5dc626c1a851ce8" translate="yes" xml:space="preserve">
          <source>The preferred way to add and remove members of roles that are being used as groups is to use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;.</source>
          <target state="translated">グループとして使用されているロールのメンバーを追加および削除するための推奨される方法は、&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;および&lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;を使用することです。</target>
        </trans-unit>
        <trans-unit id="56dfc8a10ef1e4c4eee74088145c35840ecca451" translate="yes" xml:space="preserve">
          <source>The prefixes used for hyphenation were also compiled from:</source>
          <target state="translated">ハイフネーションに使用される接頭辞もからコンパイルしました。</target>
        </trans-unit>
        <trans-unit id="21fd2dec3de8b8ad1e5f622c8c13eab56cd148d6" translate="yes" xml:space="preserve">
          <source>The presence of &lt;code&gt;HAVING&lt;/code&gt; turns a query into a grouped query even if there is no &lt;code&gt;GROUP BY&lt;/code&gt; clause. This is the same as what happens when the query contains aggregate functions but no &lt;code&gt;GROUP BY&lt;/code&gt; clause. All the selected rows are considered to form a single group, and the &lt;code&gt;SELECT&lt;/code&gt; list and &lt;code&gt;HAVING&lt;/code&gt; clause can only reference table columns from within aggregate functions. Such a query will emit a single row if the &lt;code&gt;HAVING&lt;/code&gt; condition is true, zero rows if it is not true.</source>
          <target state="translated">存在 &lt;code&gt;HAVING&lt;/code&gt; 全く存在しない場合でもターンにグループ化されたクエリにクエリを &lt;code&gt;GROUP BY&lt;/code&gt; 句。これは、クエリに集計関数が含まれているが &lt;code&gt;GROUP BY&lt;/code&gt; 句が含まれていない場合と同じです。選択されたすべての行は1つのグループを形成すると見なされ、 &lt;code&gt;SELECT&lt;/code&gt; リストと &lt;code&gt;HAVING&lt;/code&gt; 句は集計関数内からのみテーブル列を参照できます。このようなクエリは、 &lt;code&gt;HAVING&lt;/code&gt; 条件がtrueの場合は1行を出力し、trueでない場合は0行を出力します。</target>
        </trans-unit>
        <trans-unit id="48e01dab4eaf7172ed513c36aea408ac9dcff0a1" translate="yes" xml:space="preserve">
          <source>The previous example with &lt;code&gt;unique1 &amp;lt; 1000&lt;/code&gt; was an oversimplification of what &lt;code&gt;scalarltsel&lt;/code&gt; really does; now that we have seen an example of the use of MCVs, we can fill in some more detail. The example was correct as far as it went, because since &lt;code&gt;unique1&lt;/code&gt; is a unique column it has no MCVs (obviously, no value is any more common than any other value). For a non-unique column, there will normally be both a histogram and an MCV list, and &lt;em&gt;the histogram does not include the portion of the column population represented by the MCVs&lt;/em&gt;. We do things this way because it allows more precise estimation. In this situation &lt;code&gt;scalarltsel&lt;/code&gt; directly applies the condition (e.g., &amp;ldquo;&amp;lt; 1000&amp;rdquo;) to each value of the MCV list, and adds up the frequencies of the MCVs for which the condition is true. This gives an exact estimate of the selectivity within the portion of the table that is MCVs. The histogram is then used in the same way as above to estimate the selectivity in the portion of the table that is not MCVs, and then the two numbers are combined to estimate the overall selectivity. For example, consider</source>
          <target state="translated">&lt;code&gt;unique1 &amp;lt; 1000&lt;/code&gt; の前の例は、 &lt;code&gt;scalarltsel&lt;/code&gt; が実際に行うことの単純化しすぎでした。 MCVの使用例を見てきましたので、もう少し詳しく入力できます。 &lt;code&gt;unique1&lt;/code&gt; は一意の列であるため、MCVがないため（明らかに、他のどの値よりも一般的な値はありません）、この例は、それまでのところ正しいものでした。一意でない列の場合、通常はヒストグラムとMCVリストの両方が存在し、ヒストグラムにはMCVで&lt;em&gt;表される列の母集団の部分は含まれません&lt;/em&gt;。これにより、より正確な推定が可能になります。この状況では &lt;code&gt;scalarltsel&lt;/code&gt; 条件（たとえば、「&amp;lt;1000」）をMCVリストの各値に直接適用し、条件が真であるMCVの頻度を合計します。これにより、MCVであるテーブルの部分内の選択性の正確な見積もりが得られます。次に、ヒストグラムを上記と同じ方法で使用して、テーブルのMCVではない部分の選択性を推定し、2つの数値を組み合わせて全体的な選択性を推定します。たとえば、</target>
        </trans-unit>
        <trans-unit id="bb34259f0365c548655973db55e1cb8224129b77" translate="yes" xml:space="preserve">
          <source>The primary and standby server work together to provide this capability, though the servers are only loosely coupled. The primary server operates in continuous archiving mode, while each standby server operates in continuous recovery mode, reading the WAL files from the primary. No changes to the database tables are required to enable this capability, so it offers low administration overhead compared to some other replication solutions. This configuration also has relatively low performance impact on the primary server.</source>
          <target state="translated">プライマリサーバとスタンバイサーバはこの機能を提供するために連携していますが、サーバは疎結合でしかありません。プライマリ・サーバは連続アーカイブ・モードで動作し、各スタンバイ・サーバは連続リカバリ・モードで動作し、プライマリからWALファイルを読み込みます。この機能を有効にするためにデータベーステーブルを変更する必要がないため、他のレプリケーションソリューションと比較して管理オーバーヘッドが少なくて済みます。また、この構成では、プライマリサーバへのパフォーマンスへの影響も比較的少なくなります。</target>
        </trans-unit>
        <trans-unit id="0da66f61871c96b75f9ab923507bcc1a24b7f889" translate="yes" xml:space="preserve">
          <source>The primary and standby servers are in many ways loosely connected. Actions on the primary will have an effect on the standby. As a result, there is potential for negative interactions or conflicts between them. The easiest conflict to understand is performance: if a huge data load is taking place on the primary then this will generate a similar stream of WAL records on the standby, so standby queries may contend for system resources, such as I/O.</source>
          <target state="translated">プライマリサーバとスタンバイサーバは、多くの点で疎通しています。プライマリでのアクションは、スタンバイにも影響を与えます。その結果、両者の間に否定的な相互作用や競合が発生する可能性があります。プライマリで膨大なデータ負荷が発生している場合、スタンバイでも同様のWALレコードのストリームが生成されるため、スタンバイクエリはI/Oなどのシステムリソースを争う可能性があります。</target>
        </trans-unit>
        <trans-unit id="798c0c5f43fda644a454b46372f29e554497fa2e" translate="yes" xml:space="preserve">
          <source>The primary error message and associated SQLSTATE code for the most recent failed query in the current psql session, or an empty string and &lt;code&gt;00000&lt;/code&gt; if no error has occurred in the current session.</source>
          <target state="translated">現在のpsqlセッションで最後に失敗したクエリのプライマリエラーメッセージと関連するSQLSTATEコード、または現在のセッションでエラーが発生していない場合は空の文字列と &lt;code&gt;00000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ab145e1a33deb5fe3582f237dbec8cdd7e1d8ca" translate="yes" xml:space="preserve">
          <source>The primary goal of developing GIN indexes was to create support for highly scalable full-text search in PostgreSQL, and there are often situations when a full-text search returns a very large set of results. Moreover, this often happens when the query contains very frequent words, so that the large result set is not even useful. Since reading many tuples from the disk and sorting them could take a lot of time, this is unacceptable for production. (Note that the index search itself is very fast.)</source>
          <target state="translated">GINインデックスの開発の第一の目的は、PostgreSQLにおける高度にスケーラブルな全文検索のサポートを作成することでした。さらに、これは問い合わせに非常に頻繁に使われる単語が含まれている場合によく起こりますので、大きな結果セットは役に立たないことになります。ディスクから多くのタプルを読み込んでソートするには多くの時間がかかるので、これは本番では受け入れられません。(インデックス検索自体は非常に高速であることに注意してください)。</target>
        </trans-unit>
        <trans-unit id="6c7d00d06905a4bbc00c744c0f27a07f33dd5060" translate="yes" xml:space="preserve">
          <source>The primary key constraint should name a set of columns that is different from the set of columns named by any unique constraint defined for the same table. (Otherwise, the unique constraint is redundant and will be discarded.)</source>
          <target state="translated">主キー制約は、同じテーブルに対して定義された一意制約で指定された列のセットとは異なる列のセットを指定しなければなりません (そうでなければ、一意制約は冗長であり、破棄されます)。(そうでない場合、一意制約は冗長であり、破棄されます)。</target>
        </trans-unit>
        <trans-unit id="095c1f180ee69bf2f8a1425ef17c7371474cd375" translate="yes" xml:space="preserve">
          <source>The primary query and the &lt;code&gt;WITH&lt;/code&gt; queries are all (notionally) executed at the same time. This implies that the effects of a data-modifying statement in &lt;code&gt;WITH&lt;/code&gt; cannot be seen from other parts of the query, other than by reading its &lt;code&gt;RETURNING&lt;/code&gt; output. If two such data-modifying statements attempt to modify the same row, the results are unspecified.</source>
          <target state="translated">プライマリクエリと &lt;code&gt;WITH&lt;/code&gt; クエリは、すべて（概念的に）同時に実行されます。これは、 &lt;code&gt;RETURNING&lt;/code&gt; 出力を読み取る以外に、 &lt;code&gt;WITH&lt;/code&gt; のデータ変更ステートメントの影響をクエリの他の部分から確認できないことを意味します。このような2つのデータ変更ステートメントが同じ行を変更しようとした場合、結果は不定です。</target>
        </trans-unit>
        <trans-unit id="8ea3da5c410e9ce91a550f33e83dec4f1762b9fe" translate="yes" xml:space="preserve">
          <source>The privileges necessary to execute this command are left implementation-defined by the standard.</source>
          <target state="translated">このコマンドを実行するために必要な権限は、標準で実装が定義されています。</target>
        </trans-unit>
        <trans-unit id="3d054afefddca1f4fd0c80061650d8bf2f8607fd" translate="yes" xml:space="preserve">
          <source>The privileges required by other commands are listed on the reference page of the respective command.</source>
          <target state="translated">他のコマンドで必要な権限は、それぞれのコマンドの参照ページに記載されています。</target>
        </trans-unit>
        <trans-unit id="304d4014e67dda82fac817f06e9aef50bfd659e4" translate="yes" xml:space="preserve">
          <source>The privileges required to create a conversion might be changed in a future release.</source>
          <target state="translated">変換を作成するために必要な権限は、将来のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="1eb7e4f8bb27785f30b9b8a7055a803cd67b6df6" translate="yes" xml:space="preserve">
          <source>The privileges that have been granted for a particular object are displayed as a list of &lt;code&gt;aclitem&lt;/code&gt; entries, where each &lt;code&gt;aclitem&lt;/code&gt; describes the permissions of one grantee that have been granted by a particular grantor. For example, &lt;code&gt;calvin=r*w/hobbes&lt;/code&gt; specifies that the role &lt;code&gt;calvin&lt;/code&gt; has the privilege &lt;code&gt;SELECT&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;) with grant option (&lt;code&gt;*&lt;/code&gt;) as well as the non-grantable privilege &lt;code&gt;UPDATE&lt;/code&gt; (&lt;code&gt;w&lt;/code&gt;), both granted by the role &lt;code&gt;hobbes&lt;/code&gt;. If &lt;code&gt;calvin&lt;/code&gt; also has some privileges on the same object granted by a different grantor, those would appear as a separate &lt;code&gt;aclitem&lt;/code&gt; entry. An empty grantee field in an &lt;code&gt;aclitem&lt;/code&gt; stands for &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">特定のオブジェクトに対して付与された特権は、 &lt;code&gt;aclitem&lt;/code&gt; エントリーのリストとして表示されます。各 &lt;code&gt;aclitem&lt;/code&gt; は、特定の付与者によって付与された1人の被付与者の許可を記述します。たとえば、 &lt;code&gt;calvin=r*w/hobbes&lt;/code&gt; は、ロール &lt;code&gt;calvin&lt;/code&gt; が権限 &lt;code&gt;SELECT&lt;/code&gt; （ &lt;code&gt;r&lt;/code&gt; ）と付与オプション（ &lt;code&gt;*&lt;/code&gt; ）、および付与不可能な権限 &lt;code&gt;UPDATE&lt;/code&gt; （ &lt;code&gt;w&lt;/code&gt; ）を &lt;code&gt;hobbes&lt;/code&gt; 、どちらもロールhobbesによって付与されることを指定します。 &lt;code&gt;calvin&lt;/code&gt; が別の付与者によって付与された同じオブジェクトに対するいくつかの特権も持っている場合、それらは別個の &lt;code&gt;aclitem&lt;/code&gt; として表示されますエントリ。 &lt;code&gt;aclitem&lt;/code&gt; の空の被付与者フィールドは &lt;code&gt;PUBLIC&lt;/code&gt; を表します。</target>
        </trans-unit>
        <trans-unit id="146fa2f880a1a0967ddf597dd80c4df17c9e7c69" translate="yes" xml:space="preserve">
          <source>The procedural language code to be executed. This must be specified as a string literal, just as in &lt;code&gt;CREATE FUNCTION&lt;/code&gt;. Use of a dollar-quoted literal is recommended.</source>
          <target state="translated">実行される手続き言語コード。これは、 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; と同様に、文字列リテラルとして指定する必要があります。ドルで引用されたリテラルの使用をお勧めします。</target>
        </trans-unit>
        <trans-unit id="6f86ee50294a4a7a3fef4b5b2297c9c5402611ba" translate="yes" xml:space="preserve">
          <source>The procedural language to be used must already have been installed into the current database by means of &lt;code&gt;CREATE EXTENSION&lt;/code&gt;. &lt;code&gt;plpgsql&lt;/code&gt; is installed by default, but other languages are not.</source>
          <target state="translated">使用する手続き言語は、 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; によって現在のデータベースにすでにインストールされている必要があります。 &lt;code&gt;plpgsql&lt;/code&gt; はデフォルトでインストールされますが、他の言語はインストールされていません。</target>
        </trans-unit>
        <trans-unit id="eeffbbfe4a95a1cfc7af97774b63ebc4c95bcc67" translate="yes" xml:space="preserve">
          <source>The procedure for making a base backup using the low level APIs contains a few more steps than the &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; method, but is relatively simple. It is very important that these steps are executed in sequence, and that the success of a step is verified before proceeding to the next step.</source>
          <target state="translated">低レベルAPIを使用してベースバックアップを作成する手順には、&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;メソッドよりもいくつかの手順が含まれていますが、比較的簡単です。これらのステップが順番に実行され、次のステップに進む前にステップの成功が確認されることが非常に重要です。</target>
        </trans-unit>
        <trans-unit id="0cb38c62a0e05e7bd2148e42b61d27ee2ab30693" translate="yes" xml:space="preserve">
          <source>The procedure will now execute with whatever search path is used by its caller.</source>
          <target state="translated">このプロシージャは、その呼び出し元で使用される検索パスで実行されるようになりました。</target>
        </trans-unit>
        <trans-unit id="4b5bcbc092d024a0a7543e925fc016ccd66517c6" translate="yes" xml:space="preserve">
          <source>The process ID of the backend currently connected to.</source>
          <target state="translated">現在接続しているバックエンドのプロセスID。</target>
        </trans-unit>
        <trans-unit id="34795750bd1d44ec3bd68f7c69b56e729608c717" translate="yes" xml:space="preserve">
          <source>The process ID of the session using this slot if the slot is currently actively being used. &lt;code&gt;NULL&lt;/code&gt; if inactive.</source>
          <target state="translated">スロットが現在アクティブに使用されている場合、このスロットを使用するセッションのプロセスID。非アクティブの場合は &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32a4bb7cc46bcf50934800d5f3c98570d230e94a" translate="yes" xml:space="preserve">
          <source>The process for an exclusive backup is mostly the same as for a non-exclusive one, but it differs in a few key steps. This type of backup can only be taken on a primary and does not allow concurrent backups. Moreover, because it creates a backup label file, as described below, it can block automatic restart of the master server after a crash. On the other hand, the erroneous removal of this file from a backup or standby is a common mistake, which can result in serious data corruption. If it is necessary to use this method, the following steps may be used.</source>
          <target state="translated">排他的バックアップのプロセスは非排他的バックアップとほとんど同じですが、いくつかの重要なステップが異なります。このタイプのバックアップはプライマリ上でのみ実行でき、同時バックアップはできません。さらに、後述するようにバックアップラベルファイルを作成するため、クラッシュ後のマスターサーバの自動再起動をブロックすることができます。一方、バックアップやスタンバイからこのファイルを誤って削除してしまうことは、よくあるミスであり、深刻なデータの破損につながる可能性があります。どうしてもこの方法を使う必要がある場合は、以下の手順で行うことができます。</target>
        </trans-unit>
        <trans-unit id="6e312719075282712af63a4478358c161b9ce7c1" translate="yes" xml:space="preserve">
          <source>The process of retrieving or the command to retrieve data from a database is called a &lt;em&gt;query&lt;/em&gt;. In SQL the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command is used to specify queries. The general syntax of the &lt;code&gt;SELECT&lt;/code&gt; command is</source>
          <target state="translated">取得のプロセス、またはデータベースからデータを取得するコマンドは、&lt;em&gt;クエリ&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。SQLでは、&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;コマンドを使用してクエリを指定します。 &lt;code&gt;SELECT&lt;/code&gt; コマンドの一般的な構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b0bd352dde02b38bfa623807b29516cb539dd331" translate="yes" xml:space="preserve">
          <source>The program &lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt; is a wrapper program around this command, provided for convenience.</source>
          <target state="translated">&lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt;プログラムは、このコマンドのラッパープログラムであり、便宜上提供されています。</target>
        </trans-unit>
        <trans-unit id="3eff284be443ff432de37efc6563b33dc2f6e837" translate="yes" xml:space="preserve">
          <source>The prompts psql issues can be customized to your preference. The three variables &lt;code&gt;PROMPT1&lt;/code&gt;, &lt;code&gt;PROMPT2&lt;/code&gt;, and &lt;code&gt;PROMPT3&lt;/code&gt; contain strings and special escape sequences that describe the appearance of the prompt. Prompt 1 is the normal prompt that is issued when psql requests a new command. Prompt 2 is issued when more input is expected during command entry, for example because the command was not terminated with a semicolon or a quote was not closed. Prompt 3 is issued when you are running an SQL &lt;code&gt;COPY FROM STDIN&lt;/code&gt; command and you need to type in a row value on the terminal.</source>
          <target state="translated">プロンプトpsqlの問題は、好みに応じてカスタマイズできます。3つの変数 &lt;code&gt;PROMPT1&lt;/code&gt; 、 &lt;code&gt;PROMPT2&lt;/code&gt; 、および &lt;code&gt;PROMPT3&lt;/code&gt; には、プロンプトの外観を説明する文字列と特別なエスケープシーケンスが含まれています。プロンプト1は、psqlが新しいコマンドを要求したときに発行される通常のプロンプトです。プロンプト2は、コマンドがセミコロンで終了していない、または引用符が閉じられていないなどの理由で、コマンドの入力中にさらに入力が予想される場合に発行されます。プロンプト3は、SQL &lt;code&gt;COPY FROM STDIN&lt;/code&gt; コマンドを実行していて、端末で行の値を入力する必要がある場合に発行されます。</target>
        </trans-unit>
        <trans-unit id="0b52632ebba8d8fdc7d9a5f3df0121e320094037" translate="yes" xml:space="preserve">
          <source>The provided functions are shown in &lt;a href=&quot;earthdistance#EARTHDISTANCE-CUBE-FUNCTIONS&quot;&gt;Table F.5&lt;/a&gt;.</source>
          <target state="translated">提供されている関数を&lt;a href=&quot;earthdistance#EARTHDISTANCE-CUBE-FUNCTIONS&quot;&gt;表F.5に&lt;/a&gt;示します。</target>
        </trans-unit>
        <trans-unit id="5afa1f9b64bd52e3a56222e3e5d393c2eefea25a" translate="yes" xml:space="preserve">
          <source>The purpose is to limit the impact of pg_basebackup on the running server.</source>
          <target state="translated">この目的は、pg_basebackupが実行中のサーバに与える影響を制限することです。</target>
        </trans-unit>
        <trans-unit id="5073941a47e032b26bcb9d69507584568abea85b" translate="yes" xml:space="preserve">
          <source>The purpose of a &lt;code&gt;WINDOW&lt;/code&gt; clause is to specify the behavior of &lt;em&gt;window functions&lt;/em&gt; appearing in the query's &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; List&lt;/a&gt; or &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;. These functions can reference the &lt;code&gt;WINDOW&lt;/code&gt; clause entries by name in their &lt;code&gt;OVER&lt;/code&gt; clauses. A &lt;code&gt;WINDOW&lt;/code&gt; clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without any &lt;code&gt;WINDOW&lt;/code&gt; clause at all, since a window function call can specify its window definition directly in its &lt;code&gt;OVER&lt;/code&gt; clause. However, the &lt;code&gt;WINDOW&lt;/code&gt; clause saves typing when the same window definition is needed for more than one window function.</source>
          <target state="translated">&lt;code&gt;WINDOW&lt;/code&gt; 句の目的は、クエリの&lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt; &lt;code&gt;SELECT&lt;/code&gt; &lt;/a&gt;リストまたは&lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; &lt;/a&gt;句に&lt;em&gt;表示されるウィンドウ関数&lt;/em&gt;の動作を指定することです。これらの関数は、 &lt;code&gt;OVER&lt;/code&gt; 句の名前で &lt;code&gt;WINDOW&lt;/code&gt; 句のエントリを参照できます。 &lt;code&gt;WINDOW&lt;/code&gt; の句エントリは、しかし、どこでも参照する必要はありません。クエリで使用されていない場合は、単に無視されます。ウィンドウ関数呼び出しはそのウィンドウ定義を &lt;code&gt;OVER&lt;/code&gt; 句で直接指定できるため、 &lt;code&gt;WINDOW&lt;/code&gt; 句をまったく使用せずにウィンドウ関数を使用することが可能です。ただし、 &lt;code&gt;WINDOW&lt;/code&gt; 句は、同じウィンドウ定義が複数のウィンドウ関数に必要な場合の入力を節約します。</target>
        </trans-unit>
        <trans-unit id="7a79e1e6c48912d3a19f2334c5cde8a4adb3de10" translate="yes" xml:space="preserve">
          <source>The purpose of an index, of course, is to support scans for tuples matching an indexable &lt;code&gt;WHERE&lt;/code&gt; condition, often called a &lt;em&gt;qualifier&lt;/em&gt; or &lt;em&gt;scan key&lt;/em&gt;. The semantics of index scanning are described more fully in &lt;a href=&quot;index-scanning&quot;&gt;Section 61.3&lt;/a&gt;, below. An index access method can support &amp;ldquo;plain&amp;rdquo; index scans, &amp;ldquo;bitmap&amp;rdquo; index scans, or both. The scan-related functions that an index access method must or may provide are:</source>
          <target state="translated">もちろん、インデックスの目的は、多くの場合&lt;em&gt;修飾子&lt;/em&gt;または&lt;em&gt;スキャンキー&lt;/em&gt;と呼ばれる、インデックス付け可能な &lt;code&gt;WHERE&lt;/code&gt; 条件に一致するタプルのスキャンをサポートすることです。インデックススキャンのセマンティクスについては、以下の&lt;a href=&quot;index-scanning&quot;&gt;セクション61.3&lt;/a&gt;で詳しく説明します。索引アクセス方式は、「プレーン」索引スキャン、「ビットマップ」索引スキャン、またはその両方をサポートできます。インデックスアクセスメソッドが提供しなければならない、または提供する可能性があるスキャン関連の関数は次のとおりです。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="71dfcd4f15fca395ab847bf8654ecc1126908484" translate="yes" xml:space="preserve">
          <source>The quantifiers &lt;code&gt;{1,1}&lt;/code&gt; and &lt;code&gt;{1,1}?&lt;/code&gt; can be used to force greediness or non-greediness, respectively, on a subexpression or a whole RE. This is useful when you need the whole RE to have a greediness attribute different from what's deduced from its elements. As an example, suppose that we are trying to separate a string containing some digits into the digits and the parts before and after them. We might try to do that like this:</source>
          <target state="translated">数量詞 &lt;code&gt;{1,1}&lt;/code&gt; および &lt;code&gt;{1,1}?&lt;/code&gt; 部分式またはRE全体に対して、それぞれ貪欲または非貪欲を強制するために使用できます。これは、RE全体に、その要素から推定されるものとは異なる貪欲属性を持たせる必要がある場合に役立ちます。例として、いくつかの数字を含む文字列を、数字とその前後の部分に分離しようとしていると仮定します。このようにしようとするかもしれません：</target>
        </trans-unit>
        <trans-unit id="343b9e25e0029b4f349abf2c9eb3c709d6c9db46" translate="yes" xml:space="preserve">
          <source>The quarter of the year (1 - 4) that the date is in</source>
          <target state="translated">日付が入っている年の四半期(1~4)。</target>
        </trans-unit>
        <trans-unit id="5c024cf5d71d6d58e1719ea5b88c2edd0af4738d" translate="yes" xml:space="preserve">
          <source>The queried JSON data contain nested arrays. In this case, only the outermost array is unwrapped, while all the inner arrays remain unchanged. Thus, implicit unwrapping can only go one level down within each path evaluation step.</source>
          <target state="translated">クエリされたJSONデータには、入れ子になった配列が含まれています。この場合、一番外側の配列のみがアンラップされ、内側の配列はすべて変更されません。このように、暗黙のアンラップは、各パス評価ステップ内で1つのレベルだけ下に行くことができます。</target>
        </trans-unit>
        <trans-unit id="9ec83a60a4572c2a39f277feef2e26e14c05d5aa" translate="yes" xml:space="preserve">
          <source>The query above specifies that the &lt;code&gt;english&lt;/code&gt; configuration is to be used to parse and normalize the strings. Alternatively we could omit the configuration parameters:</source>
          <target state="translated">上記のクエリは、 &lt;code&gt;english&lt;/code&gt; 構成を使用して文字列を解析および正規化することを指定しています。あるいは、設定パラメーターを省略できます。</target>
        </trans-unit>
        <trans-unit id="755893eaea71f45690b0b8daa7c44ccecde3f16e" translate="yes" xml:space="preserve">
          <source>The query is running inside of another query that is already parallel. For example, if a function called by a parallel query issues an SQL query itself, that query will never use a parallel plan. This is a limitation of the current implementation, but it may not be desirable to remove this limitation, since it could result in a single query using a very large number of processes.</source>
          <target state="translated">そのクエリは、すでに並列化されている別のクエリの内部で実行されています。例えば、並列クエリによって呼び出された関数がSQLクエリ自体を発行した場合、そのクエリは決して並列プランを使用しません。これは現在の実装の制限ですが、1つのクエリで非常に多くのプロセスを使用することになる可能性があるため、この制限を取り除くことは望ましくないかもしれません。</target>
        </trans-unit>
        <trans-unit id="5a0a949650f6ba760f80fb27f318b51f13c26bd4" translate="yes" xml:space="preserve">
          <source>The query might be suspended during execution. In any situation in which the system thinks that partial or incremental execution might occur, no parallel plan is generated. For example, a cursor created using &lt;a href=&quot;sql-declare&quot;&gt;DECLARE CURSOR&lt;/a&gt; will never use a parallel plan. Similarly, a PL/pgSQL loop of the form &lt;code&gt;FOR x IN query LOOP .. END LOOP&lt;/code&gt; will never use a parallel plan, because the parallel query system is unable to verify that the code in the loop is safe to execute while parallel query is active.</source>
          <target state="translated">クエリは実行中に一時停止される可能性があります。部分的または増分的な実行が発生する可能性があるとシステムが判断する状況では、並列プランは生成されません。たとえば、&lt;a href=&quot;sql-declare&quot;&gt;DECLARE CURSOR&lt;/a&gt;を使用して作成されたカーソルは、並列プランを使用しません。同様に、 &lt;code&gt;FOR x IN query LOOP .. END LOOP&lt;/code&gt; という形式のPL / pgSQLループは、並列プランを使用しません。これは、並列クエリシステムが、並列クエリがアクティブな間、ループ内のコードが安全に実行されていることを確認できないためです。 。</target>
        </trans-unit>
        <trans-unit id="bdfa8875f3090d46606e95d96800e6f18174861f" translate="yes" xml:space="preserve">
          <source>The query must reference only columns stored in the index. For example, given an index on columns &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; of a table that also has a column &lt;code&gt;z&lt;/code&gt;, these queries could use index-only scans:</source>
          <target state="translated">クエリは、インデックスに格納されている列のみを参照する必要があります。たとえば、列 &lt;code&gt;z&lt;/code&gt; もあるテーブルの列 &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; のインデックスを指定すると、これらのクエリはインデックスのみのスキャンを使用できます。</target>
        </trans-unit>
        <trans-unit id="c50468726e4134a52ce71c84ac34c354a3e1b957" translate="yes" xml:space="preserve">
          <source>The query optimizer takes &lt;code&gt;LIMIT&lt;/code&gt; into account when generating query plans, so you are very likely to get different plans (yielding different row orders) depending on what you give for &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt;. Thus, using different &lt;code&gt;LIMIT&lt;/code&gt;/&lt;code&gt;OFFSET&lt;/code&gt; values to select different subsets of a query result &lt;em&gt;will give inconsistent results&lt;/em&gt; unless you enforce a predictable result ordering with &lt;code&gt;ORDER BY&lt;/code&gt;. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless &lt;code&gt;ORDER BY&lt;/code&gt; is used to constrain the order.</source>
          <target state="translated">クエリオプティマイザーはクエリプランを生成するときに &lt;code&gt;LIMIT&lt;/code&gt; を考慮に入れるため、 &lt;code&gt;LIMIT&lt;/code&gt; および &lt;code&gt;OFFSET&lt;/code&gt; に指定した内容に応じて、異なるプランを取得する（異なる行順序を生成する）可能性が非常に高くなります。したがって、異なる &lt;code&gt;LIMIT&lt;/code&gt; / &lt;code&gt;OFFSET&lt;/code&gt; 値を使用してクエリ結果の異なるサブセットを選択すると、 &lt;code&gt;ORDER BY&lt;/code&gt; で予測可能な結果の順序付けを適用しない限り&lt;em&gt;、一貫性のない&lt;/em&gt;結果&lt;em&gt;が得られ&lt;/em&gt;ます。これはバグではありません。これは、 &lt;code&gt;ORDER BY&lt;/code&gt; を使用して順序を制約しない限り、SQLが特定の順序でクエリの結果を提供することを約束しないという事実の本質的な結果です。</target>
        </trans-unit>
        <trans-unit id="9591ec91d27bd94fc1ed0042a9c68fc7e7f8799e" translate="yes" xml:space="preserve">
          <source>The query planner takes &lt;code&gt;LIMIT&lt;/code&gt; into account when generating a query plan, so you are very likely to get different plans (yielding different row orders) depending on what you use for &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt;. Thus, using different &lt;code&gt;LIMIT&lt;/code&gt;/&lt;code&gt;OFFSET&lt;/code&gt; values to select different subsets of a query result &lt;em&gt;will give inconsistent results&lt;/em&gt; unless you enforce a predictable result ordering with &lt;code&gt;ORDER BY&lt;/code&gt;. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless &lt;code&gt;ORDER BY&lt;/code&gt; is used to constrain the order.</source>
          <target state="translated">クエリプランナーは、クエリプランを生成するときに &lt;code&gt;LIMIT&lt;/code&gt; を考慮に入れるため、 &lt;code&gt;LIMIT&lt;/code&gt; と &lt;code&gt;OFFSET&lt;/code&gt; に何を使用するかに応じて、異なるプランを取得する（異なる行順序を生成する）可能性が高くなります。したがって、異なる &lt;code&gt;LIMIT&lt;/code&gt; / &lt;code&gt;OFFSET&lt;/code&gt; 値を使用してクエリ結果の異なるサブセットを選択すると、 &lt;code&gt;ORDER BY&lt;/code&gt; で予測可能な結果の順序付けを適用しない限り&lt;em&gt;、一貫性のない&lt;/em&gt;結果&lt;em&gt;が得られ&lt;/em&gt;ます。これはバグではありません。これは、 &lt;code&gt;ORDER BY&lt;/code&gt; を使用して順序を制約しない限り、SQLが特定の順序でクエリの結果を提供することを約束しないという事実の本質的な結果です。</target>
        </trans-unit>
        <trans-unit id="4af81e08bfabc175af6208808228c3292ec1d219" translate="yes" xml:space="preserve">
          <source>The query rewriter is discussed in some detail in &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;, so there is no need to cover it here. We will only point out that both the input and the output of the rewriter are query trees, that is, there is no change in the representation or level of semantic detail in the trees. Rewriting can be thought of as a form of macro expansion.</source>
          <target state="translated">クエリリライタについては&lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;第40章で&lt;/a&gt;詳細に説明しているため、ここで説明する必要はありません。リライターの入力と出力の両方がクエリツリーであること、つまり、ツリーのセマンティックディテールの表現またはレベルに変更がないことのみを指摘します。書き換えは、マクロ展開の一種と考えることができます。</target>
        </trans-unit>
        <trans-unit id="84cbe05d8623ccd8c2adba905f772e1af6572a6b" translate="yes" xml:space="preserve">
          <source>The query string submitted by the client to create this prepared statement. For prepared statements created via SQL, this is the &lt;code&gt;PREPARE&lt;/code&gt; statement submitted by the client. For prepared statements created via the frontend/backend protocol, this is the text of the prepared statement itself.</source>
          <target state="translated">この準備されたステートメントを作成するためにクライアントによって送信されたクエリ文字列。SQLを介して作成された準備済みステートメントの場合、これはクライアントによって送信された &lt;code&gt;PREPARE&lt;/code&gt; ステートメントです。フロントエンド/バックエンドプロトコルを介して作成された準備済みステートメントの場合、これは準備済みステートメント自体のテキストです。</target>
        </trans-unit>
        <trans-unit id="b1d53885b655d33f7ad2a2d0f4ca8ce4c9afa697" translate="yes" xml:space="preserve">
          <source>The query that is actually sent to the remote server for execution can be examined using &lt;code&gt;EXPLAIN VERBOSE&lt;/code&gt;.</source>
          <target state="translated">実際にリモートサーバーに送信されて実行されるクエリは、 &lt;code&gt;EXPLAIN VERBOSE&lt;/code&gt; を使用して調べることができます。</target>
        </trans-unit>
        <trans-unit id="bb7170c364ffc0983c042ed7b707bee01230d841" translate="yes" xml:space="preserve">
          <source>The query tree created by the transformation process is structurally similar to the raw parse tree in most places, but it has many differences in detail. For example, a &lt;code&gt;FuncCall&lt;/code&gt; node in the parse tree represents something that looks syntactically like a function call. This might be transformed to either a &lt;code&gt;FuncExpr&lt;/code&gt; or &lt;code&gt;Aggref&lt;/code&gt; node depending on whether the referenced name turns out to be an ordinary function or an aggregate function. Also, information about the actual data types of columns and expression results is added to the query tree.</source>
          <target state="translated">変換プロセスによって作成されたクエリツリーは、ほとんどの場所で生の解析ツリーと構造的に似ていますが、細部に多くの違いがあります。たとえば、解析ツリーの &lt;code&gt;FuncCall&lt;/code&gt; ノードは、構文的には関数呼び出しのように見えるものを表します。これは、参照された名前が通常の関数であるか集約関数であるかによって、 &lt;code&gt;FuncExpr&lt;/code&gt; または &lt;code&gt;Aggref&lt;/code&gt; ノードに変換される場合があります。また、列の実際のデータ型と式の結果に関する情報がクエリツリーに追加されます。</target>
        </trans-unit>
        <trans-unit id="85e8ce3a8f2eab045a32523ebad51fd65a628dc9" translate="yes" xml:space="preserve">
          <source>The query uses any function marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt;. Most system-defined functions are &lt;code&gt;PARALLEL SAFE&lt;/code&gt;, but user-defined functions are marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; by default. See the discussion of &lt;a href=&quot;parallel-safety&quot;&gt;Section 15.4&lt;/a&gt;.</source>
          <target state="translated">クエリは &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; とマークされた関数を使用します。ほとんどのシステム定義関数は &lt;code&gt;PARALLEL SAFE&lt;/code&gt; ですが、ユーザー定義関数はデフォルトで &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; とマークされています。&lt;a href=&quot;parallel-safety&quot;&gt;セクション15.4&lt;/a&gt;の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="ae584697a944b3092f1bdba0372976965b96c14e" translate="yes" xml:space="preserve">
          <source>The query writes any data or locks any database rows. If a query contains a data-modifying operation either at the top level or within a CTE, no parallel plans for that query will be generated. As an exception, the commands &lt;code&gt;CREATE TABLE ... AS&lt;/code&gt;, &lt;code&gt;SELECT INTO&lt;/code&gt;, and &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt; which create a new table and populate it can use a parallel plan.</source>
          <target state="translated">クエリは、データを書き込むか、データベース行をロックします。クエリに最上位レベルまたはCTE内のいずれかのデータ変更操作が含まれている場合、そのクエリの並列プランは生成されません。例外として、新しいテーブルを作成してデータを追加する &lt;code&gt;CREATE TABLE ... AS&lt;/code&gt; 、 &lt;code&gt;SELECT INTO&lt;/code&gt; 、および &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt; コマンドは、並列プランを使用できます。</target>
        </trans-unit>
        <trans-unit id="646431d95f05f7752d11dec325de9bca5192ab21" translate="yes" xml:space="preserve">
          <source>The radius of the Earth is obtained from the &lt;code&gt;earth()&lt;/code&gt; function. It is given in meters. But by changing this one function you can change the module to use some other units, or to use a different value of the radius that you feel is more appropriate.</source>
          <target state="translated">地球の半径は、 &lt;code&gt;earth()&lt;/code&gt; 関数から取得されます。それはメートルで与えられます。ただし、この1つの関数を変更することで、モジュールを変更して他の単位を使用したり、より適切と思われる別の半径の値を使用したりできます。</target>
        </trans-unit>
        <trans-unit id="33dd011e0a27c9e4a8da0750e328420ec5636341" translate="yes" xml:space="preserve">
          <source>The range type's &lt;code&gt;subtype&lt;/code&gt; can be any type with an associated b-tree operator class (to determine the ordering of values for the range type). Normally the subtype's default b-tree operator class is used to determine ordering; to use a non-default operator class, specify its name with &lt;code&gt;subtype_opclass&lt;/code&gt;. If the subtype is collatable, and you want to use a non-default collation in the range's ordering, specify the desired collation with the &lt;code&gt;collation&lt;/code&gt; option.</source>
          <target state="translated">範囲タイプの &lt;code&gt;subtype&lt;/code&gt; は、関連するbツリー演算子クラスを持つ任意のタイプにすることができます（範囲タイプの値の順序を決定するため）。通常、サブタイプのデフォルトのbツリー演算子クラスは、順序を決定するために使用されます。デフォルト以外の演算子クラスを使用するには、その名前を &lt;code&gt;subtype_opclass&lt;/code&gt; で指定します。サブタイプが照合可能であり、デフォルト以外の照合を範囲の順序で使用する場合は、 &lt;code&gt;collation&lt;/code&gt; オプションで目的の照合を指定します。</target>
        </trans-unit>
        <trans-unit id="45e371c3b97fa5eccf6d1070963f8eb35bb332f4" translate="yes" xml:space="preserve">
          <source>The rate is targeted by starting transactions along a Poisson-distributed schedule time line. The expected start time schedule moves forward based on when the client first started, not when the previous transaction ended. That approach means that when transactions go past their original scheduled end time, it is possible for later ones to catch up again.</source>
          <target state="translated">レートは、ポアソン分散されたスケジュールのタイムラインに沿ってトランザクションを開始することによって目標とされています。予想される開始時間のスケジュールは、前のトランザクションがいつ終了したかではなく、クライアントが最初に開始した時間に基づいて進みます。このアプローチは、トランザクションが元の予定された終了時間を過ぎても、後のトランザクションが再び追いつくことが可能であることを意味します。</target>
        </trans-unit>
        <trans-unit id="f993d6ebc7309b2d31242d61b21f2b56ac8f6a72" translate="yes" xml:space="preserve">
          <source>The reason for separating raw parsing from semantic analysis is that system catalog lookups can only be done within a transaction, and we do not wish to start a transaction immediately upon receiving a query string. The raw parsing stage is sufficient to identify the transaction control commands (&lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;ROLLBACK&lt;/code&gt;, etc), and these can then be correctly executed without any further analysis. Once we know that we are dealing with an actual query (such as &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;), it is okay to start a transaction if we're not already in one. Only then can the transformation process be invoked.</source>
          <target state="translated">生の解析とセマンティック分析を分離する理由は、システムカタログのルックアップはトランザクション内でのみ実行でき、クエリ文字列を受け取った直後にトランザクションを開始したくないためです。生の解析段階は、トランザクション制御コマンド（ &lt;code&gt;BEGIN&lt;/code&gt; 、 &lt;code&gt;ROLLBACK&lt;/code&gt; など）を識別するのに十分であり、これらをさらに分析せずに正しく実行できます。実際のクエリ（ &lt;code&gt;SELECT&lt;/code&gt; や &lt;code&gt;UPDATE&lt;/code&gt; など）を処理していることがわかったら、トランザクションがまだない場合は、トランザクションを開始してもかまいません。その後でのみ、変換プロセスを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="2555cbea73ebf259be548a413cb3f00d947e85ce" translate="yes" xml:space="preserve">
          <source>The reason that periodic vacuuming solves the problem is that &lt;code&gt;VACUUM&lt;/code&gt; will mark rows as &lt;em&gt;frozen&lt;/em&gt;, indicating that they were inserted by a transaction that committed sufficiently far in the past that the effects of the inserting transaction are certain to be visible to all current and future transactions. Normal XIDs are compared using modulo-2&lt;sup&gt;32&lt;/sup&gt; arithmetic. This means that for every normal XID, there are two billion XIDs that are &amp;ldquo;older&amp;rdquo; and two billion that are &amp;ldquo;newer&amp;rdquo;; another way to say it is that the normal XID space is circular with no endpoint. Therefore, once a row version has been created with a particular normal XID, the row version will appear to be &amp;ldquo;in the past&amp;rdquo; for the next two billion transactions, no matter which normal XID we are talking about. If the row version still exists after more than two billion transactions, it will suddenly appear to be in the future. To prevent this, PostgreSQL reserves a special XID, &lt;code&gt;FrozenTransactionId&lt;/code&gt;, which does not follow the normal XID comparison rules and is always considered older than every normal XID. Frozen row versions are treated as if the inserting XID were &lt;code&gt;FrozenTransactionId&lt;/code&gt;, so that they will appear to be &amp;ldquo;in the past&amp;rdquo; to all normal transactions regardless of wraparound issues, and so such row versions will be valid until deleted, no matter how long that is.</source>
          <target state="translated">定期的なバキューム処理が問題を解決する理由は、 &lt;code&gt;VACUUM&lt;/code&gt; が行を&lt;em&gt;凍結&lt;/em&gt;としてマークすることです。これは、過去に十分にコミットされたトランザクションによって行が挿入され、挿入トランザクションの影響が現在および将来のすべてのトランザクションで確実に認識されることを示します。 。通常のXIDはmodulo-2 &lt;sup&gt;32&lt;/sup&gt;を使用して比較されます&lt;sup&gt;&lt;/sup&gt;算術。つまり、通常のXIDごとに、20億個の「古い」XIDと20億個の「新しい」XIDがあります。別の言い方をすると、通常のXID空間はエンドポイントのない円形であるということです。したがって、特定の通常のXIDで行バージョンが作成されると、どの通常のXIDについて話しても、次の20億トランザクションの行バージョンは「過去」であるように見えます。 20億を超えるトランザクションの後で行バージョンがまだ存在する場合、それは突然将来的にあるように見えます。これを防ぐために、PostgreSQLは特別なXID &lt;code&gt;FrozenTransactionId&lt;/code&gt; を予約します。これは、通常のXID比較規則に従わず、常にすべての通常のXIDよりも古いと見なされます。凍結された行バージョンは、挿入するXIDが &lt;code&gt;FrozenTransactionId&lt;/code&gt; であるかのように扱われます。、つまり、ラップアラウンドの問題に関係なく、すべての通常のトランザクションに対して「過去」にあるように見えるため、そのような行のバージョンは、どれほど長くても、削除されるまで有効です。</target>
        </trans-unit>
        <trans-unit id="3e52350494447bb6f36961ad4e797bd18a9eb61e" translate="yes" xml:space="preserve">
          <source>The reason that single quotes must be doubled, as shown in &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt;, is that this is true for any string literal in a SQL command. The generic string-literal parser consumes the outermost single quotes and reduces any pair of single quotes to one data character. What the &lt;code&gt;bytea&lt;/code&gt; input function sees is just one single quote, which it treats as a plain data character. However, the &lt;code&gt;bytea&lt;/code&gt; input function treats backslashes as special, and the other behaviors shown in &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt; are implemented by that function.</source>
          <target state="translated">&lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;表8.7&lt;/a&gt;に示すように、単一引用符を二重にする必要があるのは、これがSQLコマンドの文字列リテラルに当てはまるためです。汎用文字列リテラルパーサーは、最も外側の単一引用符を使用し、単一引用符のペアを1つのデータ文字に減らします。何 &lt;code&gt;bytea&lt;/code&gt; 型の入力機能が見ると、それはプレーンなデータ文字として扱いますただ一つの引用です。ただし、 &lt;code&gt;bytea&lt;/code&gt; 入力関数はバックスラッシュを特別なものとして扱い、&lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;表8.7に&lt;/a&gt;示す他の動作はその関数によって実装されます。</target>
        </trans-unit>
        <trans-unit id="035f0c664448dfa923a884566e84523654a5a8a5" translate="yes" xml:space="preserve">
          <source>The recommended method for configuring shared memory in macOS is to create a file named &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, containing variable assignments such as:</source>
          <target state="translated">macOSで共有メモリを構成するための推奨される方法は、次のような変数の割り当てを含む &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; という名前のファイルを作成することです。</target>
        </trans-unit>
        <trans-unit id="b6faaba60ea4ceaac002ffa0497dd503d8d8e004" translate="yes" xml:space="preserve">
          <source>The recommended recovery method in such cases is to drop the index and try again to perform &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;. (Another possibility is to rebuild the index with &lt;code&gt;REINDEX INDEX CONCURRENTLY&lt;/code&gt;).</source>
          <target state="translated">このような場合に推奨される回復方法は、インデックスを削除してから、 &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; の実行を再試行することです。（別の可能性は &lt;code&gt;REINDEX INDEX CONCURRENTLY&lt;/code&gt; でインデックスを再構築することです）。</target>
        </trans-unit>
        <trans-unit id="65854068ac8d3288768569a456ffe6db4148ee2b" translate="yes" xml:space="preserve">
          <source>The recommended recovery method in such cases is to drop the invalid index and try again to perform &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt;. The concurrent index created during the processing has a name ending in the suffix &lt;code&gt;ccnew&lt;/code&gt;, or &lt;code&gt;ccold&lt;/code&gt; if it is an old index definition which we failed to drop. Invalid indexes can be dropped using &lt;code&gt;DROP INDEX&lt;/code&gt;, including invalid toast indexes.</source>
          <target state="translated">このような場合に推奨される回復方法は、無効なインデックスを削除してから、 &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; の実行を再試行することです。処理中に作成されたコンカレントインデックスの名前は、末尾が &lt;code&gt;ccnew&lt;/code&gt; で &lt;code&gt;ccold&lt;/code&gt; か、削除に失敗した古いインデックス定義の場合はccoldです。無効なトーストインデックスを含め、無効なインデックスは &lt;code&gt;DROP INDEX&lt;/code&gt; を使用して削除できます。</target>
        </trans-unit>
        <trans-unit id="dfc0dfd0875395d5ad4e9971dc3ba071b3c62b6b" translate="yes" xml:space="preserve">
          <source>The recommended syntax for referencing an ordered-set aggregate is to write &lt;code&gt;ORDER BY&lt;/code&gt; between the direct and aggregated argument specifications, in the same style as in &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;. However, it will also work to omit &lt;code&gt;ORDER BY&lt;/code&gt; and just run the direct and aggregated argument specifications into a single list. In this abbreviated form, if &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; was used in both the direct and aggregated argument lists, write &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; only once.</source>
          <target state="translated">順序付き集合集計を参照するための推奨構文は、直接引数と集計引数の指定の間に &lt;code&gt;ORDER BY&lt;/code&gt; を、&lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;と同じスタイルで記述することです。ただし、 &lt;code&gt;ORDER BY&lt;/code&gt; を省略して、直接および集約された引数指定を1つのリストに実行することもできます。この省略形で、 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; が直接引数リストと集約引数リストの両方で使用されている場合は、 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; を 1回だけ記述します。</target>
        </trans-unit>
        <trans-unit id="2c54b57bbcf06dd2c13692d0332c35778b6cad50" translate="yes" xml:space="preserve">
          <source>The recursive query evaluation algorithm produces its output in breadth-first search order. You can display the results in depth-first search order by making the outer query &lt;code&gt;ORDER BY&lt;/code&gt; a &amp;ldquo;path&amp;rdquo; column constructed in this way.</source>
          <target state="translated">再帰クエリ評価アルゴリズムは、幅優先の検索順序で出力を生成します。このように構築された「パス」列を外部クエリの &lt;code&gt;ORDER BY&lt;/code&gt; にすることで、結果を深さ優先の検索順序で表示できます。</target>
        </trans-unit>
        <trans-unit id="10c71ff4aa80650437aaee9d5a8e7f1f079dae18" translate="yes" xml:space="preserve">
          <source>The referenced object (which must be a role) is mentioned as the target of a dependent policy object.</source>
          <target state="translated">参照されるオブジェクト(役割でなければならない)は、従属ポリシーオブジェクトの対象として言及されています。</target>
        </trans-unit>
        <trans-unit id="c023a7885506a46d5cd80a1b95eea9a1b30194d8" translate="yes" xml:space="preserve">
          <source>The referenced object (which must be a role) is mentioned in the ACL (access control list, i.e., privileges list) of the dependent object. (A &lt;code&gt;SHARED_DEPENDENCY_ACL&lt;/code&gt; entry is not made for the owner of the object, since the owner will have a &lt;code&gt;SHARED_DEPENDENCY_OWNER&lt;/code&gt; entry anyway.)</source>
          <target state="translated">参照されるオブジェクト（役割である必要があります）は、依存オブジェクトのACL（アクセス制御リスト、つまり特権リスト）に記述されています。（所有者は &lt;code&gt;SHARED_DEPENDENCY_OWNER&lt;/code&gt; エントリを持っているため、オブジェクトの所有者に対して &lt;code&gt;SHARED_DEPENDENCY_ACL&lt;/code&gt; エントリは作成されません。）</target>
        </trans-unit>
        <trans-unit id="b0815ccf510952893128b6ac3763e885ed6f0544" translate="yes" xml:space="preserve">
          <source>The referenced object (which must be a role) is the owner of the dependent object.</source>
          <target state="translated">参照されるオブジェクト(ロールでなければなりません)は、従属オブジェクトの所有者です。</target>
        </trans-unit>
        <trans-unit id="a3a42d2bcdc41726ac7929beb724897943cebede" translate="yes" xml:space="preserve">
          <source>The regular expression flag letters defined by XQuery are related to but not the same as the option letters for POSIX (&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;). While the &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; options behave the same, others do not:</source>
          <target state="translated">XQueryによって定義された正規表現フラグ文字は、POSIXのオプション文字に関連していますが、同じではありません（&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;表9.23&lt;/a&gt;）。一方で &lt;code&gt;i&lt;/code&gt; と &lt;code&gt;q&lt;/code&gt; のオプションは同じように動作し、他の人はそうではありません。</target>
        </trans-unit>
        <trans-unit id="ba9e7d00d7dfab39d193126f7366a926fa396e54" translate="yes" xml:space="preserve">
          <source>The relevant files have to be installed into &lt;code&gt;$pkglibdir/bitcode/$extension/&lt;/code&gt; and a summary of them into &lt;code&gt;$pkglibdir/bitcode/$extension.index.bc&lt;/code&gt;, where &lt;code&gt;$pkglibdir&lt;/code&gt; is the directory returned by &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; and &lt;code&gt;$extension&lt;/code&gt; is the base name of the extension's shared library.</source>
          <target state="translated">関連するファイルをにインストールする必要があります &lt;code&gt;$pkglibdir/bitcode/$extension/&lt;/code&gt; へのそれらの概要と &lt;code&gt;$pkglibdir/bitcode/$extension.index.bc&lt;/code&gt; 、 &lt;code&gt;$pkglibdir&lt;/code&gt; で返されるディレクトリで &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; と &lt;code&gt;$extension&lt;/code&gt; あります拡張機能の共有ライブラリのベース名。</target>
        </trans-unit>
        <trans-unit id="6ba726b7abb409f8a48dfda787ffd9ea8e7624bd" translate="yes" xml:space="preserve">
          <source>The relevant settings can be changed in &lt;code&gt;/etc/system&lt;/code&gt;, for example:</source>
          <target state="translated">関連する設定は、 &lt;code&gt;/etc/system&lt;/code&gt; で変更できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="7fd56dd803d0f7d0e1d83485ba93a1ea518a48b4" translate="yes" xml:space="preserve">
          <source>The remaining defaults are quite generously sized, and usually do not require changes.</source>
          <target state="translated">残りのデフォルトはかなり余裕のあるサイズで、通常は変更を必要としません。</target>
        </trans-unit>
        <trans-unit id="e214a53b19603c5bd3de31f71ebb545b28127eb2" translate="yes" xml:space="preserve">
          <source>The remaining five input formats are not part of any standard.</source>
          <target state="translated">残りの5つの入力フォーマットは、どの規格にも属していません。</target>
        </trans-unit>
        <trans-unit id="a23206cc28b1e52f80477ca74330c7ee7d48a063" translate="yes" xml:space="preserve">
          <source>The remaining forms change the session default for a run-time configuration variable for a PostgreSQL database. Whenever a new session is subsequently started in that database, the specified value becomes the session default value. The database-specific default overrides whatever setting is present in &lt;code&gt;postgresql.conf&lt;/code&gt; or has been received from the &lt;code&gt;postgres&lt;/code&gt; command line. Only the database owner or a superuser can change the session defaults for a database. Certain variables cannot be set this way, or can only be set by a superuser.</source>
          <target state="translated">残りのフォームは、PostgreSQLデータベースのランタイム構成変数のセッションデフォルトを変更します。その後、そのデータベースで新しいセッションが開始されると、指定された値がセッションのデフォルト値になります。データベース固有のデフォルトは、 &lt;code&gt;postgresql.conf&lt;/code&gt; に存在する設定、または &lt;code&gt;postgres&lt;/code&gt; コマンドラインから受け取った設定を上書きします。データベースのセッションのデフォルトを変更できるのは、データベースの所有者またはスーパーユーザーだけです。特定の変数はこの方法で設定できないか、スーパーユーザーのみが設定できます。</target>
        </trans-unit>
        <trans-unit id="657f4dc87f97eb4fa07203598556b9c37fdd908d" translate="yes" xml:space="preserve">
          <source>The remaining locale categories can be changed later when the server is started. You can also use &lt;code&gt;--locale&lt;/code&gt; to set the default for all locale categories, including collation order and character set classes. All server locale values (&lt;code&gt;lc_*&lt;/code&gt;) can be displayed via &lt;code&gt;SHOW ALL&lt;/code&gt;. More details can be found in &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt;.</source>
          <target state="translated">残りのロケールカテゴリは、後でサーバーを起動したときに変更できます。 &lt;code&gt;--locale&lt;/code&gt; を使用して、照合順序や文字セットクラスなど、すべてのロケールカテゴリのデフォルトを設定することもできます。すべてのサーバーロケール値（ &lt;code&gt;lc_*&lt;/code&gt; ）は、 &lt;code&gt;SHOW ALL&lt;/code&gt; を使用して表示できます。詳細については、&lt;a href=&quot;locale&quot;&gt;セクション23.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="39583e46f87084afedd4c54635cee3575eddc6c6" translate="yes" xml:space="preserve">
          <source>The remaining variants change a role's session default for a configuration variable, either for all databases or, when the &lt;code&gt;IN DATABASE&lt;/code&gt; clause is specified, only for sessions in the named database. If &lt;code&gt;ALL&lt;/code&gt; is specified instead of a role name, this changes the setting for all roles. Using &lt;code&gt;ALL&lt;/code&gt; with &lt;code&gt;IN DATABASE&lt;/code&gt; is effectively the same as using the command &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt;.</source>
          <target state="translated">残りのバリアントは、すべてのデータベースについて、または &lt;code&gt;IN DATABASE&lt;/code&gt; 句が指定されている場合は、指定されたデータベース内のセッションについてのみ、構成変数のロールのセッションデフォルトを変更します。場合は &lt;code&gt;ALL&lt;/code&gt; がロール名の代わりに指定され、これは、すべての役割の設定を変更します。使い方 &lt;code&gt;ALL&lt;/code&gt; をし &lt;code&gt;IN DATABASE&lt;/code&gt; 効果的にコマンド使用するのと同じです &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5290f23dd3a823420c1c9cce7d4e8058bd8eb3fa" translate="yes" xml:space="preserve">
          <source>The remaining variants change the owner and the name of the publication.</source>
          <target state="translated">残りの亜種は、所有者と出版物の名前を変更します。</target>
        </trans-unit>
        <trans-unit id="fd818ebf2b83e4b29f88c818dcaf7941b628e1ea" translate="yes" xml:space="preserve">
          <source>The remote schema to import from. The specific meaning of a remote schema depends on the foreign data wrapper in use.</source>
          <target state="translated">インポート元のリモートスキーマ。リモートスキーマの特定の意味は、使用している外部データラッパーに依存します。</target>
        </trans-unit>
        <trans-unit id="c2f6cfebe2ad1dd2cbdde5a3b92b04d140d615ff" translate="yes" xml:space="preserve">
          <source>The remote transaction uses &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level when the local transaction has &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level; otherwise it uses &lt;code&gt;REPEATABLE READ&lt;/code&gt; isolation level. This choice ensures that if a query performs multiple table scans on the remote server, it will get snapshot-consistent results for all the scans. A consequence is that successive queries within a single transaction will see the same data from the remote server, even if concurrent updates are occurring on the remote server due to other activities. That behavior would be expected anyway if the local transaction uses &lt;code&gt;SERIALIZABLE&lt;/code&gt; or &lt;code&gt;REPEATABLE READ&lt;/code&gt; isolation level, but it might be surprising for a &lt;code&gt;READ COMMITTED&lt;/code&gt; local transaction. A future PostgreSQL release might modify these rules.</source>
          <target state="translated">ローカルトランザクションに &lt;code&gt;SERIALIZABLE&lt;/code&gt; 分離レベルがある場合、リモートトランザクションは &lt;code&gt;SERIALIZABLE&lt;/code&gt; 分離レベルを使用します。それ以外の場合は、 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 分離レベルを使用します。この選択により、クエリがリモートサーバーで複数のテーブルスキャンを実行する場合、すべてのスキャンでスナップショットの一貫した結果が得られます。その結果、他のアクティビティによってリモートサーバーで同時更新が発生している場合でも、単一のトランザクション内の連続したクエリでは、リモートサーバーから同じデータが表示されます。ローカルトランザクションが &lt;code&gt;SERIALIZABLE&lt;/code&gt; または &lt;code&gt;REPEATABLE READ&lt;/code&gt; 分離レベルを使用している場合、その動作はとにかく予想されますが、 &lt;code&gt;READ COMMITTED&lt;/code&gt; の場合は驚くかもしれません。ローカルトランザクション。将来のPostgreSQLリリースでは、これらのルールが変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="b784ef85aba666ab41976b71fec7b8c205701bef" translate="yes" xml:space="preserve">
          <source>The reported &lt;code&gt;index_size&lt;/code&gt; will normally correspond to one more page than is accounted for by &lt;code&gt;internal_pages + leaf_pages + empty_pages + deleted_pages&lt;/code&gt;, because it also includes the index's metapage.</source>
          <target state="translated">報告された &lt;code&gt;index_size&lt;/code&gt; は通常、インデックスのメタページも含まれているため、 &lt;code&gt;internal_pages + leaf_pages + empty_pages + deleted_pages&lt;/code&gt; で考慮されているよりも1つ多いページに対応します。</target>
        </trans-unit>
        <trans-unit id="55f0c215e7b27076f4a6dfbf779db270819931cc" translate="yes" xml:space="preserve">
          <source>The reported lag times are not predictions of how long it will take for the standby to catch up with the sending server assuming the current rate of replay. Such a system would show similar times while new WAL is being generated, but would differ when the sender becomes idle. In particular, when the standby has caught up completely, &lt;code&gt;pg_stat_replication&lt;/code&gt; shows the time taken to write, flush and replay the most recent reported WAL location rather than zero as some users might expect. This is consistent with the goal of measuring synchronous commit and transaction visibility delays for recent write transactions. To reduce confusion for users expecting a different model of lag, the lag columns revert to NULL after a short time on a fully replayed idle system. Monitoring systems should choose whether to represent this as missing data, zero or continue to display the last known value.</source>
          <target state="translated">報告された遅延時間は、現在の再生速度を想定して、スタンバイが送信サーバーに追いつくのにかかる時間の予測ではありません。このようなシステムは、新しいWALが生成されている間も同様の時間を示しますが、送信者がアイドルになると異なります。特に、スタンバイが完全に追いついたとき、 &lt;code&gt;pg_stat_replication&lt;/code&gt; は、一部のユーザーが予想するようなゼロではなく、最新の報告されたWALロケーションの書き込み、フラッシュ、および再生にかかる時間を示しています。これは、最近の書き込みトランザクションの同期コミットおよびトランザクション可視性遅延を測定するという目標と一致しています。ラグの異なるモデルを期待しているユーザーの混乱を減らすために、完全に再生されたアイドルシステムで少し時間が経過すると、ラグ列はNULLに戻ります。監視システムは、これを欠落データとして表すか、ゼロにするか、または最後の既知の値を表示し続けるかを選択する必要があります。</target>
        </trans-unit>
        <trans-unit id="a645551df2ec2063cbaae776527e78ce19d49632" translate="yes" xml:space="preserve">
          <source>The representative query texts are kept in an external disk file, and do not consume shared memory. Therefore, even very lengthy query texts can be stored successfully. However, if many long query texts are accumulated, the external file might grow unmanageably large. As a recovery method if that happens, &lt;code&gt;pg_stat_statements&lt;/code&gt; may choose to discard the query texts, whereupon all existing entries in the &lt;code&gt;pg_stat_statements&lt;/code&gt; view will show null &lt;code&gt;query&lt;/code&gt; fields, though the statistics associated with each &lt;code&gt;queryid&lt;/code&gt; are preserved. If this happens, consider reducing &lt;code&gt;pg_stat_statements.max&lt;/code&gt; to prevent recurrences.</source>
          <target state="translated">代表的なクエリテキストは外部ディスクファイルに保存され、共有メモリを消費しません。したがって、非常に長いクエリテキストでも正常に保存できます。ただし、多くの長いクエリテキストが蓄積されると、外部ファイルが管理できないほど大きくなる可能性があります。これが発生した場合の回復方法として、 &lt;code&gt;pg_stat_statements&lt;/code&gt; はクエリテキストを破棄することを選択できます。これにより、 &lt;code&gt;pg_stat_statements&lt;/code&gt; ビューの既存のエントリはすべてnull &lt;code&gt;query&lt;/code&gt; フィールドを表示しますが、各 &lt;code&gt;queryid&lt;/code&gt; 関連付けられた統計は保持されます。これが発生した場合は、 &lt;code&gt;pg_stat_statements.max&lt;/code&gt; を減らして再発を防止することを検討してください。</target>
        </trans-unit>
        <trans-unit id="0ec95cfaa7fde5c159e36da65695933b4d1251cc" translate="yes" xml:space="preserve">
          <source>The required &lt;code&gt;row_expression&lt;/code&gt; argument is an XPath 1.0 expression that is evaluated, passing the &lt;code&gt;document_expression&lt;/code&gt; as its context item, to obtain a set of XML nodes. These nodes are what &lt;code&gt;xmltable&lt;/code&gt; transforms into output rows. No rows will be produced if the &lt;code&gt;document_expression&lt;/code&gt; is null, nor if the &lt;code&gt;row_expression&lt;/code&gt; produces an empty node-set or any value other than a node-set.</source>
          <target state="translated">必要な &lt;code&gt;row_expression&lt;/code&gt; 引数は、XMLノードのセットを取得するために &lt;code&gt;document_expression&lt;/code&gt; をコンテキストアイテムとして渡して評価されるXPath 1.0式です。これらのノードは、 &lt;code&gt;xmltable&lt;/code&gt; が出力行に変換するものです。 &lt;code&gt;document_expression&lt;/code&gt; がnullの場合、 &lt;code&gt;row_expression&lt;/code&gt; が空のノードセットまたはノードセット以外の値を生成する場合、行は生成されません。</target>
        </trans-unit>
        <trans-unit id="b11399ca691e0ca5b399e8672e2715124cece495" translate="yes" xml:space="preserve">
          <source>The requirement to escape &lt;em&gt;non-printable&lt;/em&gt; octets varies depending on locale settings. In some instances you can get away with leaving them unescaped.</source>
          <target state="translated">&lt;em&gt;印刷不可能な&lt;/em&gt;オクテットをエスケープする要件は、ロケール設定によって異なります。場合によっては、エスケープせずにそのままにしておくことができます。</target>
        </trans-unit>
        <trans-unit id="b1fdcf794bda35b8905b9d7b4d4c5b307eaf0f21" translate="yes" xml:space="preserve">
          <source>The resolution can be done either by changing data on the subscriber so that it does not conflict with the incoming change or by skipping the transaction that conflicts with the existing data. The transaction can be skipped by calling the &lt;a href=&quot;functions-admin#PG-REPLICATION-ORIGIN-ADVANCE&quot;&gt;&lt;code&gt;pg_replication_origin_advance()&lt;/code&gt;&lt;/a&gt; function with a &lt;em&gt;&lt;code&gt;node_name&lt;/code&gt;&lt;/em&gt; corresponding to the subscription name, and a position. The current position of origins can be seen in the &lt;a href=&quot;view-pg-replication-origin-status&quot;&gt;&lt;code&gt;pg_replication_origin_status&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">解決は、受信した変更と競合しないようにサブスクライバーのデータを変更するか、既存のデータと競合するトランザクションをスキップすることによって実行できます。サブスクリプション名に対応する&lt;em&gt; &lt;code&gt;node_name&lt;/code&gt; &lt;/em&gt;と位置を指定して&lt;a href=&quot;functions-admin#PG-REPLICATION-ORIGIN-ADVANCE&quot;&gt; &lt;code&gt;pg_replication_origin_advance()&lt;/code&gt; &lt;/a&gt;関数を呼び出すことにより、トランザクションをスキップできます。起点の現在の位置は、&lt;a href=&quot;view-pg-replication-origin-status&quot;&gt; &lt;code&gt;pg_replication_origin_status&lt;/code&gt; &lt;/a&gt;システムビューで確認できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="723a98a8202cef2494a119e8677686ce411c0bb4" translate="yes" xml:space="preserve">
          <source>The response indicates that the large object received object ID 152801, which can be used to access the newly-created large object in the future. For the sake of readability, it is recommended to always associate a human-readable comment with every object. Both OIDs and comments can be viewed with the &lt;code&gt;\lo_list&lt;/code&gt; command.</source>
          <target state="translated">応答は、ラージオブジェクトがオブジェクトID 152801を受け取ったことを示します。これは、新しく作成されたラージオブジェクトに将来アクセスするために使用できます。読みやすくするために、常に人間が読めるコメントをすべてのオブジェクトに関連付けることをお勧めします。OIDとコメントの両方は、 &lt;code&gt;\lo_list&lt;/code&gt; コマンドで表示できます。</target>
        </trans-unit>
        <trans-unit id="2934d0e903001f7986e041f38eab1c8c1f288032" translate="yes" xml:space="preserve">
          <source>The restriction for the join is &lt;code&gt;t2.unique2 = t1.unique2&lt;/code&gt;. The operator is just our familiar &lt;code&gt;=&lt;/code&gt;, however the selectivity function is obtained from the &lt;code&gt;oprjoin&lt;/code&gt; column of &lt;code&gt;pg_operator&lt;/code&gt;, and is &lt;code&gt;eqjoinsel&lt;/code&gt;. &lt;code&gt;eqjoinsel&lt;/code&gt; looks up the statistical information for both &lt;code&gt;tenk2&lt;/code&gt; and &lt;code&gt;tenk1&lt;/code&gt;:</source>
          <target state="translated">結合の制限は &lt;code&gt;t2.unique2 = t1.unique2&lt;/code&gt; です。操作者は、私たちのよく知られている &lt;code&gt;=&lt;/code&gt; しかし、選択関数から得られる、 &lt;code&gt;oprjoin&lt;/code&gt; 用のカラム &lt;code&gt;pg_operator&lt;/code&gt; 、及びある &lt;code&gt;eqjoinsel&lt;/code&gt; 。 &lt;code&gt;eqjoinsel&lt;/code&gt; は &lt;code&gt;tenk2&lt;/code&gt; と &lt;code&gt;tenk1&lt;/code&gt; の両方の統計情報を検索します。</target>
        </trans-unit>
        <trans-unit id="42ea840e6963b1db2f144f830a72190a8a92d8a7" translate="yes" xml:space="preserve">
          <source>The restriction on &lt;code&gt;tenk1&lt;/code&gt;, &lt;code&gt;unique1 &amp;lt; 50&lt;/code&gt;, is evaluated before the nested-loop join. This is handled analogously to the previous range example. This time the value 50 falls into the first bucket of the &lt;code&gt;unique1&lt;/code&gt; histogram:</source>
          <target state="translated">上の制限 &lt;code&gt;tenk1&lt;/code&gt; 、 &lt;code&gt;unique1 &amp;lt; 50&lt;/code&gt; 、ネストされたループが参加する前に、評価されます。これは、前の範囲の例と同様に処理されます。今回は、値50が &lt;code&gt;unique1&lt;/code&gt; ヒストグラムの最初のバケットに分類されます。</target>
        </trans-unit>
        <trans-unit id="80154a0c17a7ca3699a207d67e1600353cb2e59b" translate="yes" xml:space="preserve">
          <source>The restriction selectivity estimator function for this operator.</source>
          <target state="translated">この演算子の制限選択性推定関数。</target>
        </trans-unit>
        <trans-unit id="c1e9d6876e675991a0158e89b5c587ee7ffe971a" translate="yes" xml:space="preserve">
          <source>The restriction selectivity estimator function for this operator; write NONE to remove existing selectivity estimator.</source>
          <target state="translated">この演算子の制限選択性推定関数;既存の選択性推定関数を削除するにはNONEを書く。</target>
        </trans-unit>
        <trans-unit id="e176f734fe6408fc6b88696f88ea896277748c08" translate="yes" xml:space="preserve">
          <source>The result is equivalent to replacing the target data directory with the source one. Only changed blocks from relation files are copied; all other files are copied in full, including configuration files. The advantage of pg_rewind over taking a new base backup, or tools like rsync, is that pg_rewind does not require reading through unchanged blocks in the cluster. This makes it a lot faster when the database is large and only a small fraction of blocks differ between the clusters.</source>
          <target state="translated">この結果は、ターゲットのデータディレクトリをソースのデータディレクトリに置き換えるのと同じです。リレーションファイルから変更されたブロックのみがコピーされ、他のすべてのファイルは設定ファイルを含めて完全にコピーされます。pg_rewindの利点は、新しいベースバックアップやrsyncのようなツールを使用するよりも、pg_rewindがクラスタ内の変更されていないブロックを読み込む必要がないことです。これにより、データベースが大規模で、クラスタ間でブロックのごく一部が異なるだけの場合には、非常に高速になります。</target>
        </trans-unit>
        <trans-unit id="71c257a34cf97f05e33ccd5803182c14ff7c7772" translate="yes" xml:space="preserve">
          <source>The result looks like &lt;code&gt;/CN=Somebody /C=Some country/O=Some organization&lt;/code&gt;.</source>
          <target state="translated">結果は &lt;code&gt;/CN=Somebody /C=Some country/O=Some organization&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="465e9b5b70493d1bded19fc1f9a4a0487651fc46" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;EXCEPT&lt;/code&gt; does not contain any duplicate rows unless the &lt;code&gt;ALL&lt;/code&gt; option is specified. With &lt;code&gt;ALL&lt;/code&gt;, a row that has &lt;code&gt;m&lt;/code&gt; duplicates in the left table and &lt;code&gt;n&lt;/code&gt; duplicates in the right table will appear max(&lt;code&gt;m&lt;/code&gt;-&lt;code&gt;n&lt;/code&gt;,0) times in the result set. &lt;code&gt;DISTINCT&lt;/code&gt; can be written to explicitly specify the default behavior of eliminating duplicate rows.</source>
          <target state="translated">&lt;code&gt;ALL&lt;/code&gt; オプションが指定されていない限り、 &lt;code&gt;EXCEPT&lt;/code&gt; の結果には重複行は含まれません。 &lt;code&gt;ALL&lt;/code&gt; 有する行 &lt;code&gt;m&lt;/code&gt; 左テーブルとで重複を &lt;code&gt;n&lt;/code&gt; 右側のテーブルに重複が最大（表示される &lt;code&gt;m&lt;/code&gt; - &lt;code&gt;n&lt;/code&gt; は結果セットの回数、0）。 &lt;code&gt;DISTINCT&lt;/code&gt; を記述して、重複行を排除するデフォルトの動作を明示的に指定できます。</target>
        </trans-unit>
        <trans-unit id="8e065829e339ca2263a957857644dcd1c568a754" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;INTERSECT&lt;/code&gt; does not contain any duplicate rows unless the &lt;code&gt;ALL&lt;/code&gt; option is specified. With &lt;code&gt;ALL&lt;/code&gt;, a row that has &lt;code&gt;m&lt;/code&gt; duplicates in the left table and &lt;code&gt;n&lt;/code&gt; duplicates in the right table will appear min(&lt;code&gt;m&lt;/code&gt;,&lt;code&gt;n&lt;/code&gt;) times in the result set. &lt;code&gt;DISTINCT&lt;/code&gt; can be written to explicitly specify the default behavior of eliminating duplicate rows.</source>
          <target state="translated">&lt;code&gt;ALL&lt;/code&gt; オプションを指定しない限り、 &lt;code&gt;INTERSECT&lt;/code&gt; の結果には重複行は含まれません。 &lt;code&gt;ALL&lt;/code&gt; 有する行 &lt;code&gt;m&lt;/code&gt; 左テーブルとで重複 &lt;code&gt;n&lt;/code&gt; 分（表示され、右表の重複を &lt;code&gt;m&lt;/code&gt; 、 &lt;code&gt;n&lt;/code&gt; は結果セット内の）回。 &lt;code&gt;DISTINCT&lt;/code&gt; を記述して、重複行を排除するデフォルトの動作を明示的に指定できます。</target>
        </trans-unit>
        <trans-unit id="2ef35ef4ee4e7ace61e6bdb22721c0932c911c40" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;UNION&lt;/code&gt; does not contain any duplicate rows unless the &lt;code&gt;ALL&lt;/code&gt; option is specified. &lt;code&gt;ALL&lt;/code&gt; prevents elimination of duplicates. (Therefore, &lt;code&gt;UNION ALL&lt;/code&gt; is usually significantly quicker than &lt;code&gt;UNION&lt;/code&gt;; use &lt;code&gt;ALL&lt;/code&gt; when you can.) &lt;code&gt;DISTINCT&lt;/code&gt; can be written to explicitly specify the default behavior of eliminating duplicate rows.</source>
          <target state="translated">&lt;code&gt;ALL&lt;/code&gt; オプションを指定しない限り、 &lt;code&gt;UNION&lt;/code&gt; の結果には重複行は含まれません。 &lt;code&gt;ALL&lt;/code&gt; は重複の排除を防止します。（したがって、 &lt;code&gt;UNION ALL&lt;/code&gt; は通常 &lt;code&gt;UNION&lt;/code&gt; よりも大幅に高速です。可能な場合は &lt;code&gt;ALL&lt;/code&gt; を使用してください。） &lt;code&gt;DISTINCT&lt;/code&gt; を記述して、重複行を排除するデフォルトの動作を明示的に指定できます。</target>
        </trans-unit>
        <trans-unit id="72402b7b0b331fd1b54d5308fde49885c6b05ef8" translate="yes" xml:space="preserve">
          <source>The result of a database content mapping looks like this:</source>
          <target state="translated">データベースのコンテンツマッピングの結果は次のようになります。</target>
        </trans-unit>
        <trans-unit id="5bf0f22088cf3019c1a1b1dbed662be7a69e9148" translate="yes" xml:space="preserve">
          <source>The result of a schema content mapping looks like this:</source>
          <target state="translated">スキーマのコンテンツマッピングの結果は次のようになります。</target>
        </trans-unit>
        <trans-unit id="31f7fafc96662c4abec5838f93938c08f12e39f5" translate="yes" xml:space="preserve">
          <source>The result of each path evaluation step can be processed by one or more &lt;code&gt;jsonpath&lt;/code&gt; operators and methods listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.15.2.3&lt;/a&gt;. Each method name must be preceded by a dot. For example, you can get an array size:</source>
          <target state="translated">各パス評価ステップの結果は、&lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;セクション9.15.2.3に&lt;/a&gt;リストされている1つ以上の &lt;code&gt;jsonpath&lt;/code&gt; オペレーターおよびメソッドによって処理できます。各メソッド名の前にはドットを付ける必要があります。たとえば、配列サイズを取得できます。</target>
        </trans-unit>
        <trans-unit id="2c39389298dad4176af2cd2f4f928038308a6b18" translate="yes" xml:space="preserve">
          <source>The result of successfully committing a group of transactions is inconsistent with all possible orderings of running those transactions one at a time.</source>
          <target state="translated">トランザクションのグループを正常にコミットした結果は、それらのトランザクションを一度に一つずつ実行するすべての可能な順序と矛盾しています。</target>
        </trans-unit>
        <trans-unit id="f90d6b2c73e8ea4c0551da0df475a8d425331eb2" translate="yes" xml:space="preserve">
          <source>The result of the &lt;code&gt;union&lt;/code&gt; function must be a value of the index's storage type, whatever that is (it might or might not be different from the indexed column's type). The &lt;code&gt;union&lt;/code&gt; function should return a pointer to newly &lt;code&gt;palloc()&lt;/code&gt;ed memory. You can't just return the input value as-is, even if there is no type change.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 関数の結果は、インデックスのストレージタイプの値である必要があります（それがインデックス付きの列のタイプと異なる場合と異なる場合があります）。 &lt;code&gt;union&lt;/code&gt; 機能が新しくへのポインタを返す必要があります &lt;code&gt;palloc()&lt;/code&gt; 編メモリ。タイプの変更がない場合でも、入力値をそのまま返すことはできません。</target>
        </trans-unit>
        <trans-unit id="b4a9c39c953a9312145a45ccbb983953c2e08ee1" translate="yes" xml:space="preserve">
          <source>The result of the previous two inserts looks like this:</source>
          <target state="translated">前の2つのインサートの結果はこんな感じです。</target>
        </trans-unit>
        <trans-unit id="b464f588a5c51e3217548207540b5bba236a02d5" translate="yes" xml:space="preserve">
          <source>The result returned by &lt;code&gt;setval&lt;/code&gt; is just the value of its second argument.</source>
          <target state="translated">&lt;code&gt;setval&lt;/code&gt; によって返される結果は、2番目の引数の値です。</target>
        </trans-unit>
        <trans-unit id="5675fc85ce2eab9d13414767f82a9b7b9d9a68bc" translate="yes" xml:space="preserve">
          <source>The resulting dump can be restored with psql:</source>
          <target state="translated">結果のダンプはpsqlでリストアできます。</target>
        </trans-unit>
        <trans-unit id="bd98dcbc013dfe386ef25cd013047250a70319f2" translate="yes" xml:space="preserve">
          <source>The results of the &lt;code&gt;in_range&lt;/code&gt; function must be consistent with the sort ordering imposed by the operator family. To be precise, given any fixed values of &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;sub&lt;/code&gt;, then:</source>
          <target state="translated">&lt;code&gt;in_range&lt;/code&gt; 関数の結果は、演算子族によって課されたソート順と一致している必要があります。正確には、 &lt;code&gt;offset&lt;/code&gt; および &lt;code&gt;sub&lt;/code&gt; の固定値を指定すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="09c3bbabf641766b5c1086657a825502c1601a40" translate="yes" xml:space="preserve">
          <source>The results of two queries can be combined using the set operations union, intersection, and difference. The syntax is</source>
          <target state="translated">2つのクエリの結果は、集合演算の union、intersection、および difference を使用して結合することができます。構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="6af5cccdc36b9ba47ebe00f94b9f0ae450f2173e" translate="yes" xml:space="preserve">
          <source>The return data type (optionally schema-qualified). The return type can be a base, composite, or domain type, or can reference the type of a table column. Depending on the implementation language it might also be allowed to specify &amp;ldquo;pseudo-types&amp;rdquo; such as &lt;code&gt;cstring&lt;/code&gt;. If the function is not supposed to return a value, specify &lt;code&gt;void&lt;/code&gt; as the return type.</source>
          <target state="translated">戻りデータ型（オプションでスキーマ修飾）。戻り値の型は、基本型、複合型、またはドメイン型であるか、テーブル列の型を参照できます。実装言語によっては、 &lt;code&gt;cstring&lt;/code&gt; などの「疑似タイプ」を指定することも許可される場合があります。関数が値を返すことが想定されていない場合は、戻り値の型として &lt;code&gt;void&lt;/code&gt; を指定します。</target>
        </trans-unit>
        <trans-unit id="68f515e9225e3a8bd926fdcf278047adb080a143" translate="yes" xml:space="preserve">
          <source>The return type of a cast function must be identical to or binary-coercible to the cast's target type.</source>
          <target state="translated">キャスト関数の戻り値の型は、キャストのターゲット型と同じか、バイナリ互換でなければなりません。</target>
        </trans-unit>
        <trans-unit id="e79b9ffc9a06ade0f94c181bff76d0c5e0055f02" translate="yes" xml:space="preserve">
          <source>The return type of each function is &lt;code&gt;xml&lt;/code&gt;.</source>
          <target state="translated">各関数の戻り値の型は &lt;code&gt;xml&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ae53d800dbf466337096571156e983ea2cef4a1a" translate="yes" xml:space="preserve">
          <source>The returned columns correspond to the fields in the &lt;code&gt;BrinMemTuple&lt;/code&gt; and &lt;code&gt;BrinValues&lt;/code&gt; structs. See &lt;code&gt;src/include/access/brin_tuple.h&lt;/code&gt; for details.</source>
          <target state="translated">返される列は、 &lt;code&gt;BrinMemTuple&lt;/code&gt; および &lt;code&gt;BrinValues&lt;/code&gt; 構造体のフィールドに対応しています。詳細については、 &lt;code&gt;src/include/access/brin_tuple.h&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="cbe5a0ea635cc6baf516f6e2eb370c36b529a917" translate="yes" xml:space="preserve">
          <source>The returned columns correspond to the fields in the &lt;code&gt;PageHeaderData&lt;/code&gt; struct. See &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt; for details.</source>
          <target state="translated">返される列は、 &lt;code&gt;PageHeaderData&lt;/code&gt; 構造体のフィールドに対応しています。詳細については、 &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="9ce8dcca026fdd1326a0feb6d5dcbe4fd79aa2a7" translate="yes" xml:space="preserve">
          <source>The rewriting forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; are not MVCC-safe. After a table rewrite, the table will appear empty to concurrent transactions, if they are using a snapshot taken before the rewrite occurred. See &lt;a href=&quot;mvcc-caveats&quot;&gt;Section 13.5&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;ALTER TABLE&lt;/code&gt; の書き換え形式はMVCCセーフではありません。テーブルの書き換え後、書き換えが発生する前に作成されたスナップショットを使用している場合、同時トランザクションではテーブルが空のように見えます。詳細については、&lt;a href=&quot;mvcc-caveats&quot;&gt;セクション13.5&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9dd9c3f397a07f60ffdbedaa5659c2ca90ab6d90" translate="yes" xml:space="preserve">
          <source>The right to drop an object, or to alter its definition in any way, is not treated as a grantable privilege; it is inherent in the owner, and cannot be granted or revoked. (However, a similar effect can be obtained by granting or revoking membership in the role that owns the object; see below.) The owner implicitly has all grant options for the object, too.</source>
          <target state="translated">オブジェクトを削除したり、その定義を変更したりする権利は、付与可能な特権としては扱われません。(ただし、オブジェクトを所有するロールのメンバーシップを付与または取り消すことで、同様の効果を得ることができます。)所有者も暗黙のうちに、オブジェクトのすべての付与オプションを持っています。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
