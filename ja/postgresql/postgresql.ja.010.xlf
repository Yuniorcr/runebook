<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="1fc1fe1aaf9532782aa2ed49cabaa7db59b86f4e" translate="yes" xml:space="preserve">
          <source>If waiting is disabled, the requested action is triggered, but there is no feedback about its success. In that case, the server log file or an external monitoring system would have to be used to check the progress and success of the operation.</source>
          <target state="translated">待機が無効になっている場合、要求されたアクションはトリガされますが、その成功に関するフィードバックはありません。その場合、サーバーのログファイルや外部監視システムを使用して操作の進捗と成功をチェックしなければなりません。</target>
        </trans-unit>
        <trans-unit id="7b03befc0afa9f43bd61408ea6224efc69f041cf" translate="yes" xml:space="preserve">
          <source>If we change the query's selectivity a bit, we might get a very different join plan:</source>
          <target state="translated">クエリの選択性を少し変えれば、まったく異なる結合プランが得られるかもしれません。</target>
        </trans-unit>
        <trans-unit id="3514492aa3ac15aedee53bae788660dc8e748122" translate="yes" xml:space="preserve">
          <source>If we continuously feed the series of WAL files to another machine that has been loaded with the same base backup file, we have a &lt;em&gt;warm standby&lt;/em&gt; system: at any point we can bring up the second machine and it will have a nearly-current copy of the database.</source>
          <target state="translated">同じ基本バックアップファイルがロードされている別のマシンに一連のWALファイルを継続的にフィードする場合、&lt;em&gt;ウォームスタンバイ&lt;/em&gt;システムがあります。いつでも2番目のマシンを起動でき、ほぼ最新のコピーが作成されます。データベース。</target>
        </trans-unit>
        <trans-unit id="a739f17951b6e075a348a61e8bb0affec3a10686" translate="yes" xml:space="preserve">
          <source>If we declared &lt;code&gt;cities&lt;/code&gt;.&lt;code&gt;name&lt;/code&gt; to be &lt;code&gt;UNIQUE&lt;/code&gt; or a &lt;code&gt;PRIMARY KEY&lt;/code&gt;, this would not stop the &lt;code&gt;capitals&lt;/code&gt; table from having rows with names duplicating rows in &lt;code&gt;cities&lt;/code&gt;. And those duplicate rows would by default show up in queries from &lt;code&gt;cities&lt;/code&gt;. In fact, by default &lt;code&gt;capitals&lt;/code&gt; would have no unique constraint at all, and so could contain multiple rows with the same name. You could add a unique constraint to &lt;code&gt;capitals&lt;/code&gt;, but this would not prevent duplication compared to &lt;code&gt;cities&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cities&lt;/code&gt; を宣言した場合。 &lt;code&gt;name&lt;/code&gt; を &lt;code&gt;UNIQUE&lt;/code&gt; または &lt;code&gt;PRIMARY KEY&lt;/code&gt; にする必要があります。これにより、 &lt;code&gt;capitals&lt;/code&gt; テーブルに名前の付いた行が &lt;code&gt;cities&lt;/code&gt; 行と重複するのを防ぐことはできません。そして、これらの重複する行は、デフォルトで &lt;code&gt;cities&lt;/code&gt; からのクエリに表示されます。実際、デフォルトでは、 &lt;code&gt;capitals&lt;/code&gt; は一意の制約がまったくないため、同じ名前の複数の行を含めることができます。 &lt;code&gt;capitals&lt;/code&gt; に一意の制約を追加することもできますが、 &lt;code&gt;cities&lt;/code&gt; と比較して重複を防ぐことはできません。</target>
        </trans-unit>
        <trans-unit id="347337a04b51d83bd4c64fbb8fed60949423b25a" translate="yes" xml:space="preserve">
          <source>If we wanted to know what city (or cities) that reading occurred in, we might try:</source>
          <target state="translated">もし、その読書がどの都市(または都市)で起こったのかを知りたいと思ったら、試してみるといいかもしれません。</target>
        </trans-unit>
        <trans-unit id="d101ff564aae9ba45b998f26d6b5819ae89be6cf" translate="yes" xml:space="preserve">
          <source>If we were to declare this index &lt;code&gt;UNIQUE&lt;/code&gt;, it would prevent creation of rows whose &lt;code&gt;col1&lt;/code&gt; values differ only in case, as well as rows whose &lt;code&gt;col1&lt;/code&gt; values are actually identical. Thus, indexes on expressions can be used to enforce constraints that are not definable as simple unique constraints.</source>
          <target state="translated">このインデックスを &lt;code&gt;UNIQUE&lt;/code&gt; と宣言すると、 &lt;code&gt;col1&lt;/code&gt; の値が大文字と小文字のみが異なる行や、 &lt;code&gt;col1&lt;/code&gt; の値が実際に同じ行が作成されなくなります。したがって、式のインデックスを使用して、単純な一意の制約として定義できない制約を適用できます。</target>
        </trans-unit>
        <trans-unit id="26385616d9682a5e8b9897f0b99ebecc8622b226" translate="yes" xml:space="preserve">
          <source>If what you desire is a one-time check against other rows at row insertion, rather than a continuously-maintained consistency guarantee, a custom &lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;trigger&lt;/a&gt; can be used to implement that. (This approach avoids the dump/reload problem because pg_dump does not reinstall triggers until after reloading data, so that the check will not be enforced during a dump/reload.)</source>
          <target state="translated">継続的に維持される一貫性の保証ではなく、行挿入時に他の行に対する1回限りのチェックが必要な場合は、カスタム&lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;トリガー&lt;/a&gt;を使用してそれを実装できます。（このアプローチでは、データの再読み込みが完了するまでpg_dumpがトリガーを再インストールしないため、ダンプ/再読み込みの問題が回避され、ダンプ/再読み込み中にチェックが強制されません。）</target>
        </trans-unit>
        <trans-unit id="1a14ecb62361bc225683313f20ed64062f67ccd0" translate="yes" xml:space="preserve">
          <source>If you already have, or suspect you have, orphaned large objects, see the &lt;a href=&quot;https://www.postgresql.org/docs/12/vacuumlo.html&quot;&gt;vacuumlo&lt;/a&gt; module to help you clean them up. It's a good idea to run vacuumlo occasionally as a back-stop to the &lt;code&gt;lo_manage&lt;/code&gt; trigger.</source>
          <target state="translated">孤立したラージオブジェクトをすでに持っているか、持っていると思われる場合は、&lt;a href=&quot;https://www.postgresql.org/docs/12/vacuumlo.html&quot;&gt;vacuumulo&lt;/a&gt;モジュールを参照して、それらをクリーンアップしてください。 &lt;code&gt;lo_manage&lt;/code&gt; トリガーへのバックストップとして時折vacuumloを実行することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f390f29503d5d3e24b107064bb2a33c6ee6ea964" translate="yes" xml:space="preserve">
          <source>If you are adding large amounts of data to an existing table, it might be a win to drop the indexes, load the table, and then recreate the indexes. Of course, the database performance for other users might suffer during the time the indexes are missing. One should also think twice before dropping a unique index, since the error checking afforded by the unique constraint will be lost while the index is missing.</source>
          <target state="translated">既存のテーブルに大量のデータを追加する場合は、インデックスを落としてテーブルをロードしてからインデックスを作り直すのが得策かもしれません。もちろん、インデックスがない間は他のユーザーのデータベースのパフォーマンスが低下するかもしれません。また、ユニークなインデックスを削除する前には、ユニークな制約によって与えられたエラーチェックがインデックスがない間に失われてしまうので、二度考えてみるべきです。</target>
        </trans-unit>
        <trans-unit id="f9e2dec1d154e8ddecdda1dfc7964b3ebcabb443" translate="yes" xml:space="preserve">
          <source>If you are installing PostgreSQL yourself, then refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt; for instructions on installation, and return to this guide when the installation is complete. Be sure to follow closely the section about setting up the appropriate environment variables.</source>
          <target state="translated">PostgreSQLを自分でインストールする場合は、&lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;第16章を&lt;/a&gt;参照してインストール手順を確認し、インストールが完了したらこのガイドに戻ってください。適切な環境変数の設定に関するセクションに必ず従ってください。</target>
        </trans-unit>
        <trans-unit id="deb64bee8b7a2efcbeba6cf8a6dff70e83085729" translate="yes" xml:space="preserve">
          <source>If you are loading a freshly created table, the fastest method is to create the table, bulk load the table's data using &lt;code&gt;COPY&lt;/code&gt;, then create any indexes needed for the table. Creating an index on pre-existing data is quicker than updating it incrementally as each row is loaded.</source>
          <target state="translated">新しく作成したテーブルをロードする場合、最速の方法はテーブルを作成し、 &lt;code&gt;COPY&lt;/code&gt; を使用してテーブルのデータを一括でロードしてから、テーブルに必要なインデックスを作成することです。既存のデータにインデックスを作成する方が、各行がロードされるときに増分的に更新するよりも高速です。</target>
        </trans-unit>
        <trans-unit id="d87d9e34c581612e87603daaced88774ab9fe111" translate="yes" xml:space="preserve">
          <source>If you are not planning to use prepared transactions, this parameter should be set to zero to prevent accidental creation of prepared transactions. If you are using prepared transactions, you will probably want &lt;code&gt;max_prepared_transactions&lt;/code&gt; to be at least as large as &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;, so that every session can have a prepared transaction pending.</source>
          <target state="translated">準備済みトランザクションを使用する予定がない場合は、このパラメーターをゼロに設定して、準備済みトランザクションが誤って作成されないようにする必要があります。準備済みトランザクションを使用している場合は、おそらく &lt;code&gt;max_prepared_transactions&lt;/code&gt; を少なくとも&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;と同じ大きさにして、すべてのセッションが準備済みトランザクションを保留できるようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="ca7f65648bc353887b727a182f8f612fdb9429de" translate="yes" xml:space="preserve">
          <source>If you are not sure whether PostgreSQL is already available or whether you can use it for your experimentation then you can install it yourself. Doing so is not hard and it can be a good exercise. PostgreSQL can be installed by any unprivileged user; no superuser (root) access is required.</source>
          <target state="translated">PostgreSQLがすでに利用可能かどうかわからない場合や、実験に使えるかどうかわからない場合は、自分でインストールすることができます。これは難しいことではありませんし、良い練習にもなります。PostgreSQLは権限のないユーザであれば誰でもインストールすることができます。</target>
        </trans-unit>
        <trans-unit id="6c854ded65666fb7e53665772a506fafbd718961" translate="yes" xml:space="preserve">
          <source>If you are running file-based log shipping (&quot;warm standby&quot;), you might need to wait until the next WAL file arrives, which could be as long as the &lt;code&gt;archive_timeout&lt;/code&gt; setting on the primary.</source>
          <target state="translated">ファイルベースのログ配布（「ウォームスタンバイ」）を実行している場合は、次のWALファイルが到着するまで待機する必要があります。これは、プライマリの &lt;code&gt;archive_timeout&lt;/code&gt; 設定と同じ長さになる場合があります。</target>
        </trans-unit>
        <trans-unit id="100df6210b436366664b5674494d353d329c78c1" translate="yes" xml:space="preserve">
          <source>If you are upgrading a pre-PostgreSQL 9.2 cluster that uses a configuration-file-only directory, you must pass the real data directory location to pg_upgrade, and pass the configuration directory location to the server, e.g. &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt;.</source>
          <target state="translated">設定ファイルのみのディレクトリを使用するPostgreSQL 9.2より前のクラスターをアップグレードする場合、実際のデータディレクトリの場所をpg_upgradeに渡し、設定ディレクトリの場所をサーバーに渡す必要があります（例： &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6433dfa1c8ec93408de2c79d0f13ec3cb038d812" translate="yes" xml:space="preserve">
          <source>If you are upgrading standby servers using methods outlined in section &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;Step 10&lt;/a&gt;, verify that the old standby servers are caught up by running pg_controldata against the old primary and standby clusters. Verify that the &amp;ldquo;Latest checkpoint location&amp;rdquo; values match in all clusters. (There will be a mismatch if old standby servers were shut down before the old primary or if the old standby servers are still running.) Also, change &lt;code&gt;wal_level&lt;/code&gt; to &lt;code&gt;replica&lt;/code&gt; in the &lt;code&gt;postgresql.conf&lt;/code&gt; file on the new primary cluster.</source>
          <target state="translated">セクション&lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;10&lt;/a&gt;で概説されている方法を使用してスタンバイサーバーをアップグレードする場合は、古いプライマリクラスターとスタンバイクラスターに対してpg_controldataを実行して、古いスタンバイサーバーが追いついていることを確認します。「最新のチェックポイントの場所」の値がすべてのクラスターで一致していることを確認します。（古いスタンバイサーバーが古いプライマリサーバーの前にシャットダウンされた場合、または古いスタンバイサーバーがまだ実行されている場合は、不一致になります。）また、新しいプライマリクラスターの &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルで &lt;code&gt;wal_level&lt;/code&gt; を &lt;code&gt;replica&lt;/code&gt; に変更します。</target>
        </trans-unit>
        <trans-unit id="4f73d78215cef8d2ef14222445477bdca411ef71" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;-X none&lt;/code&gt;, there is no guarantee that all WAL files required for the backup are archived at the end of backup.</source>
          <target state="translated">&lt;code&gt;-X none&lt;/code&gt; を使用している場合、バックアップに必要なすべてのWALファイルがバックアップの最後にアーカイブされる保証はありません。</target>
        </trans-unit>
        <trans-unit id="e87540bbfb46f5ca553285a02a78a4413f99dfe1" translate="yes" xml:space="preserve">
          <source>If you are using a version-specific installation directory, e.g. &lt;code&gt;/opt/PostgreSQL/12&lt;/code&gt;, you do not need to move the old cluster. The graphical installers all use version-specific installation directories.</source>
          <target state="translated">&lt;code&gt;/opt/PostgreSQL/12&lt;/code&gt; などのバージョン固有のインストールディレクトリを使用している場合は、古いクラスターを移動する必要はありません。グラフィカルインストーラはすべて、バージョン固有のインストールディレクトリを使用します。</target>
        </trans-unit>
        <trans-unit id="afb6b5bbb35f9c84113d155adac8b2ce50841366" translate="yes" xml:space="preserve">
          <source>If you are using manual &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;ANALYZE&lt;/code&gt; commands, don't forget that you need to run them on each child table individually. A command like:</source>
          <target state="translated">手動の &lt;code&gt;VACUUM&lt;/code&gt; または &lt;code&gt;ANALYZE&lt;/code&gt; コマンドを使用している場合は、各子テーブルで個別に実行する必要があることを忘れないでください。次のようなコマンド：</target>
        </trans-unit>
        <trans-unit id="657742cf08661b004524bce37cea4f60251b3473" translate="yes" xml:space="preserve">
          <source>If you believe a 90% cache rate is an incorrect assumption for your workload, you can increase random_page_cost to better reflect the true cost of random storage reads. Correspondingly, if your data is likely to be completely in cache, such as when the database is smaller than the total server memory, decreasing random_page_cost can be appropriate. Storage that has a low random read cost relative to sequential, e.g. solid-state drives, might also be better modeled with a lower value for random_page_cost.</source>
          <target state="translated">90%のキャッシュ率がワークロードの前提として正しくないと考えている場合、ランダムストレージの読み込みの真のコストをより良く反映するために random_page_cost を増加させることができます。これに対応して、データベースがサーバの総メモリよりも小さい場合など、データが完全にキャッシュされる可能性が高い場合は、random_page_costを減少させることが適切な場合があります。ソリッドステートドライブなど、シーケンシャルに比べてランダムリードコストが低いストレージは、random_page_costの値を下げてモデル化する方が良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="de352785d4d320deb71e5335924b75625cf49620" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;\set&lt;/code&gt; without a second argument, the variable is set to an empty-string value. To unset (i.e., delete) a variable, use the command &lt;code&gt;\unset&lt;/code&gt;. To show the values of all variables, call &lt;code&gt;\set&lt;/code&gt; without any argument.</source>
          <target state="translated">2番目の引数なしで &lt;code&gt;\set&lt;/code&gt; を呼び出すと、変数は空の文字列値に設定されます。変数を設定解除（削除）するには、コマンド &lt;code&gt;\unset&lt;/code&gt; 使用します。すべての変数の値を表示するには、引数なしで &lt;code&gt;\set&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="0259699cb6f3b30e1cd0e413c4e39248024e19a0" translate="yes" xml:space="preserve">
          <source>If you cannot free up additional space on the disk by deleting other things, you can move some of the database files to other file systems by making use of tablespaces. See &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Section 22.6&lt;/a&gt; for more information about that.</source>
          <target state="translated">他のものを削除してもディスク上の追加スペースを解放できない場合は、テーブルスペースを利用して、データベースファイルの一部を他のファイルシステムに移動できます。詳細については、&lt;a href=&quot;manage-ag-tablespaces&quot;&gt;セクション22.6&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a6b2ee409cca3f880cf89818705f66642823737c" translate="yes" xml:space="preserve">
          <source>If you cannot use &lt;code&gt;COPY&lt;/code&gt;, it might help to use &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; to create a prepared &lt;code&gt;INSERT&lt;/code&gt; statement, and then use &lt;code&gt;EXECUTE&lt;/code&gt; as many times as required. This avoids some of the overhead of repeatedly parsing and planning &lt;code&gt;INSERT&lt;/code&gt;. Different interfaces provide this facility in different ways; look for &amp;ldquo;prepared statements&amp;rdquo; in the interface documentation.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; を使用できない場合は、&lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;を使用して準備済み &lt;code&gt;INSERT&lt;/code&gt; ステートメントを作成し、 &lt;code&gt;EXECUTE&lt;/code&gt; を必要な回数だけ使用すると役立つ場合があります。これにより、 &lt;code&gt;INSERT&lt;/code&gt; を繰り返し解析および計画するオーバーヘッドの一部が回避されます。この機能は、インターフェイスごとに異なる方法で提供されます。インターフェイスのドキュメントで「準備されたステートメント」を探します。</target>
        </trans-unit>
        <trans-unit id="f74f5e82fb19007ba8087ea69c4af7c169641fbd" translate="yes" xml:space="preserve">
          <source>If you cannot, then better do crypto inside client application.</source>
          <target state="translated">できない場合は、クライアントアプリケーションの内部で暗号化を行うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c6938a67160fbaea3812e5c1afc009d637ef7fc7" translate="yes" xml:space="preserve">
          <source>If you declare a column as &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt;, the implicitly generated index is case-sensitive. So it's useless for case-insensitive searches, and it won't enforce uniqueness case-insensitively.</source>
          <target state="translated">列を &lt;code&gt;UNIQUE&lt;/code&gt; または &lt;code&gt;PRIMARY KEY&lt;/code&gt; として宣言する場合、暗黙的に生成されるインデックスでは大文字と小文字が区別されます。したがって、大文字と小文字を区別しない検索では役に立たず、大文字と小文字を区別せずに一意性を強制しません。</target>
        </trans-unit>
        <trans-unit id="bab8b24944cb37a1a0e9e93c41e90f5a2cb6ccb4" translate="yes" xml:space="preserve">
          <source>If you did &lt;em&gt;not&lt;/em&gt; start the new cluster, the old cluster was unmodified except that, when linking started, a &lt;code&gt;.old&lt;/code&gt; suffix was appended to &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt;. To reuse the old cluster, remove the &lt;code&gt;.old&lt;/code&gt; suffix from &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt;; you can then restart the old cluster.</source>
          <target state="translated">新しいクラスターを開始し&lt;em&gt;なかった&lt;/em&gt;場合、リンクの開始時に &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt; &lt;code&gt;.old&lt;/code&gt; サフィックスが追加されたことを除いて、古いクラスターは変更されていません。古いクラスターを再利用するには、 &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt; から &lt;code&gt;.old&lt;/code&gt; サフィックスを削除します。その後、古いクラスターを再起動できます。</target>
        </trans-unit>
        <trans-unit id="62b2adb362a08de49cfa1c83dea8a83d9bb2213c" translate="yes" xml:space="preserve">
          <source>If you did &lt;em&gt;not&lt;/em&gt; use link mode, do not have or do not want to use rsync, or want an easier solution, skip the instructions in this section and simply recreate the standby servers once pg_upgrade completes and the new primary is running.</source>
          <target state="translated">あなたがいなければ&lt;em&gt;いない&lt;/em&gt;リンクモードを使用し、持っていないかのrsyncを使用したくない、または容易に解決をしたい、このセクションの手順を省略し、単にpg_upgradeのは完了し、新しいプライマリが実行されている一度スタンバイサーバを再作成します。</target>
        </trans-unit>
        <trans-unit id="90981d7a01c90cf36de6cae3508f26abcc450f7b" translate="yes" xml:space="preserve">
          <source>If you did start the new cluster, it has written to shared files and it is unsafe to use the old cluster. The old cluster will need to be restored from backup in this case.</source>
          <target state="translated">新しいクラスタを起動した場合、共有ファイルに書き込まれており、古いクラスタを使用することは安全ではありません。この場合、古いクラスタをバックアップから復元する必要があります。</target>
        </trans-unit>
        <trans-unit id="47fd87d8debe284e9f481467ae1affc261e54ea8" translate="yes" xml:space="preserve">
          <source>If you do not like the output format for &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; values, try the functions &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;text&lt;/code&gt;, and &lt;code&gt;abbrev&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet&lt;/code&gt; または &lt;code&gt;cidr&lt;/code&gt; 値の出力形式が気に入らない場合は、関数 &lt;code&gt;host&lt;/code&gt; 、 &lt;code&gt;text&lt;/code&gt; 、および &lt;code&gt;abbrev&lt;/code&gt; を試してください。</target>
        </trans-unit>
        <trans-unit id="f96a8ec302a42bc03e998712a66f544972ee1509" translate="yes" xml:space="preserve">
          <source>If you do not succeed in adjusting the costs to be more appropriate, then you might have to resort to forcing index usage explicitly. You might also want to contact the PostgreSQL developers to examine the issue.</source>
          <target state="translated">コストをより適切なものに調整することに成功しない場合は、明示的にインデックスの使用を強制することに頼らざるを得ないかもしれません。また、PostgreSQLの開発者に問い合わせて検討してみるのも良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="b4cd7de986e411178ee91fc3fe47680a23518cd4" translate="yes" xml:space="preserve">
          <source>If you do not supply the database name then it will default to your user account name. You already discovered this scheme in the previous section using &lt;code&gt;createdb&lt;/code&gt;.</source>
          <target state="translated">データベース名を指定しない場合、デフォルトでユーザーアカウント名になります。このスキームは、前のセクションで &lt;code&gt;createdb&lt;/code&gt; を使用してすでに発見しています。</target>
        </trans-unit>
        <trans-unit id="be339a6a88d4d2b9b65bab603b8e3c0d2fd399fd" translate="yes" xml:space="preserve">
          <source>If you do not want to use your database anymore you can remove it. For example, if you are the owner (creator) of the database &lt;code&gt;mydb&lt;/code&gt;, you can destroy it using the following command:</source>
          <target state="translated">データベースを使用したくない場合は、データベースを削除できます。たとえば、データベース &lt;code&gt;mydb&lt;/code&gt; の所有者（作成者）であれば、次のコマンドを使用してデータベースを破棄できます。</target>
        </trans-unit>
        <trans-unit id="08e08381cd8f923213bb0bae5a2a61f673142186" translate="yes" xml:space="preserve">
          <source>If you don't have values for all the columns, you can omit some of them. In that case, the columns will be filled with their default values. For example:</source>
          <target state="translated">すべてのカラムに値がない場合は、いくつかのカラムを省略することができます。その場合、その列はデフォルト値で埋められます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="404e82d0a58303983c4b5022b612f1fb6248be48" translate="yes" xml:space="preserve">
          <source>If you drop and then recreate a function, the new function is not the same entity as the old; you will have to drop existing rules, views, triggers, etc. that refer to the old function. Use &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; to change a function definition without breaking objects that refer to the function. Also, &lt;code&gt;ALTER FUNCTION&lt;/code&gt; can be used to change most of the auxiliary properties of an existing function.</source>
          <target state="translated">関数を削除してから再作成すると、新しい関数は古い関数と同じエンティティではありません。古い関数を参照する既存のルール、ビュー、トリガーなどを削除する必要があります。 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; を使用して、関数を参照するオブジェクトを壊すことなく関数定義を変更します。また、 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; を使用して、既存の関数のほとんどの補助プロパティを変更できます。</target>
        </trans-unit>
        <trans-unit id="be307ca6bbc030429d0d787ca8543b0973b17c65" translate="yes" xml:space="preserve">
          <source>If you encounter problems starting &lt;code&gt;psql&lt;/code&gt; then go back to the previous section. The diagnostics of &lt;code&gt;createdb&lt;/code&gt; and &lt;code&gt;psql&lt;/code&gt; are similar, and if the former worked the latter should work as well.</source>
          <target state="translated">&lt;code&gt;psql&lt;/code&gt; の起動時に問題が発生した場合は、前のセクションに戻ってください。 &lt;code&gt;createdb&lt;/code&gt; と &lt;code&gt;psql&lt;/code&gt; の診断は似ており、前者が機能すれば後者も機能するはずです。</target>
        </trans-unit>
        <trans-unit id="b13cd3cf02514f3a86f3431f0fe84ad64d68a6f3" translate="yes" xml:space="preserve">
          <source>If you feel you need more introductory material, please visit the PostgreSQL &lt;a href=&quot;https://www.postgresql.org&quot;&gt;web site&lt;/a&gt; for links to more resources.</source>
          <target state="translated">さらに入門的な資料が必要だと思われる場合は、PostgreSQLの&lt;a href=&quot;https://www.postgresql.org&quot;&gt;Webサイトにアクセス&lt;/a&gt;して、その他のリソースへのリンクを確認してください。</target>
        </trans-unit>
        <trans-unit id="27223facca9dbba24447f51ca3cc46e2a4d4b2ed" translate="yes" xml:space="preserve">
          <source>If you get an &amp;ldquo;illegal system call&amp;rdquo; error, it is likely that shared memory or semaphores are not supported in your kernel at all. In that case your only option is to reconfigure the kernel to enable these features.</source>
          <target state="translated">「不正なシステムコール」エラーが発生した場合は、カーネルで共有メモリまたはセマフォがサポートされていない可能性があります。その場合、あなたの唯一の選択肢は、これらの機能を有効にするためにカーネルを再構成することです。</target>
        </trans-unit>
        <trans-unit id="7aa554ad85b0e28436475081421e4e00eaf4dd3c" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; turned off, any backslashes you write in literal string constants will need to be doubled. See &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_stringsを&lt;/a&gt;オフにしている場合は、リテラル文字列定数に書き込むバックスラッシュを2倍にする必要があります。詳細については、&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;セクション4.1.2.1&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f61cc65bca02db4eb1ea500b6eae076fd93f0491" translate="yes" xml:space="preserve">
          <source>If you have a dedicated database server with 1GB or more of RAM, a reasonable starting value for &lt;code&gt;shared_buffers&lt;/code&gt; is 25% of the memory in your system. There are some workloads where even larger settings for &lt;code&gt;shared_buffers&lt;/code&gt; are effective, but because PostgreSQL also relies on the operating system cache, it is unlikely that an allocation of more than 40% of RAM to &lt;code&gt;shared_buffers&lt;/code&gt; will work better than a smaller amount. Larger settings for &lt;code&gt;shared_buffers&lt;/code&gt; usually require a corresponding increase in &lt;code&gt;max_wal_size&lt;/code&gt;, in order to spread out the process of writing large quantities of new or changed data over a longer period of time.</source>
          <target state="translated">1 GB以上のRAMを備えた専用データベースサーバーがある場合、 &lt;code&gt;shared_buffers&lt;/code&gt; の適切な開始値は、システムのメモリの25％です。 &lt;code&gt;shared_buffers&lt;/code&gt; のさらに大きな設定が有効なワークロードもいくつかありますが、PostgreSQLもオペレーティングシステムのキャッシュに依存しているため、 &lt;code&gt;shared_buffers&lt;/code&gt; へのRAMの割り当てが40％を超えると、少ない量よりもうまく機能する可能性は低くなります。 &lt;code&gt;shared_buffers&lt;/code&gt; の設定を大きくするには、通常、新しいデータや変更されたデータを大量に書き込むプロセスを長期間にわたって分散させるために、対応する &lt;code&gt;max_wal_size&lt;/code&gt; の増加が必要です。</target>
        </trans-unit>
        <trans-unit id="5955ce4878872fc7d42a5cf4a3feceaf0ce085c2" translate="yes" xml:space="preserve">
          <source>If you have a table that contains both billed and unbilled orders, where the unbilled orders take up a small fraction of the total table and yet those are the most-accessed rows, you can improve performance by creating an index on just the unbilled rows. The command to create the index would look like this:</source>
          <target state="translated">請求済みの注文と請求されていない注文の両方を含むテーブルがあり、請求されていない注文がテーブル全体のごく一部を占めているにもかかわらず、最もアクセスの多い行である場合、請求されていない行だけにインデックスを作成することでパフォーマンスを向上させることができます。インデックスを作成するコマンドは次のようになります。</target>
        </trans-unit>
        <trans-unit id="3db868f1aa52b4182eabc5a6aaef64ca58b29be3" translate="yes" xml:space="preserve">
          <source>If you have a table whose entire contents are deleted on a periodic basis, consider doing it with &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; rather than using &lt;code&gt;DELETE&lt;/code&gt; followed by &lt;code&gt;VACUUM&lt;/code&gt;. &lt;code&gt;TRUNCATE&lt;/code&gt; removes the entire content of the table immediately, without requiring a subsequent &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; to reclaim the now-unused disk space. The disadvantage is that strict MVCC semantics are violated.</source>
          <target state="translated">内容全体が定期的に削除されるテーブルがある場合は、 &lt;code&gt;DELETE&lt;/code&gt; の後に &lt;code&gt;VACUUM&lt;/code&gt; を続けて使用するのではなく、&lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt;を使用してテーブルを実行することを検討してください。 &lt;code&gt;TRUNCATE&lt;/code&gt; は、テーブルの内容全体をすぐに削除します。現在使用されていないディスク領域を再利用するために後続の &lt;code&gt;VACUUM&lt;/code&gt; または &lt;code&gt;VACUUM FULL&lt;/code&gt; を要求する必要はありません。短所は、厳密なMVCCセマンティクスに違反することです。</target>
        </trans-unit>
        <trans-unit id="edada2f4a0ea8a1fe6f35435a51d724440a997b9" translate="yes" xml:space="preserve">
          <source>If you have a user account but it does not have the privileges required to create a database, you will see the following:</source>
          <target state="translated">ユーザーアカウントを持っていても、データベースを作成するのに必要な権限を持っていない場合は、以下のように表示されます。</target>
        </trans-unit>
        <trans-unit id="6e1ffd7834998be91b2b3ef3885c4c95ac1fca94" translate="yes" xml:space="preserve">
          <source>If you have an embedded SQL C source file named &lt;code&gt;prog1.pgc&lt;/code&gt;, you can create an executable program using the following sequence of commands:</source>
          <target state="translated">&lt;code&gt;prog1.pgc&lt;/code&gt; という名前の埋め込みSQL Cソースファイルがある場合、次の一連のコマンドを使用して実行可能プログラムを作成できます。</target>
        </trans-unit>
        <trans-unit id="3a617edae0e90918be65ecbfa41a4edb3f6fbb0d" translate="yes" xml:space="preserve">
          <source>If you have dug into the details of the file system layout of the database, you might be tempted to try to back up or restore only certain individual tables or databases from their respective files or directories. This will &lt;em&gt;not&lt;/em&gt; work because the information contained in these files is not usable without the commit log files, &lt;code&gt;pg_xact/*&lt;/code&gt;, which contain the commit status of all transactions. A table file is only usable with this information. Of course it is also impossible to restore only a table and the associated &lt;code&gt;pg_xact&lt;/code&gt; data because that would render all other tables in the database cluster useless. So file system backups only work for complete backup and restoration of an entire database cluster.</source>
          <target state="translated">データベースのファイルシステムレイアウトの詳細を調べた場合、特定の個別のテーブルまたはデータベースのみをそれぞれのファイルまたはディレクトリからバックアップまたは復元しようとする傾向があるかもしれません。これらのファイルに含まれる情報は、すべてのトランザクションのコミットステータスを含むコミットログファイル &lt;code&gt;pg_xact/*&lt;/code&gt; がないと使用できないため、これは機能し&lt;em&gt;ません&lt;/em&gt;。テーブルファイルは、この情報でのみ使用できます。もちろん、テーブルとそれに関連する &lt;code&gt;pg_xact&lt;/code&gt; データのみを復元することも不可能です。データベースクラスター内の他のすべてのテーブルが役に立たなくなるためです。そのため、ファイルシステムバックアップは、データベースクラスタ全体の完全なバックアップと復元に対してのみ機能します。</target>
        </trans-unit>
        <trans-unit id="b1fdfd0de9a85f5bba1c48c08c54c2308c8c0754" translate="yes" xml:space="preserve">
          <source>If you have not set up an external transaction manager to track prepared transactions and ensure they get closed out promptly, it is best to keep the prepared-transaction feature disabled by setting &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt; to zero. This will prevent accidental creation of prepared transactions that might then be forgotten and eventually cause problems.</source>
          <target state="translated">準備されたトランザクションを追跡するために外部トランザクションマネージャーを設定しておらず、それらがすぐに閉じられるようにする場合は、&lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;をゼロに設定して準備トランザクション機能を無効にしておくことをお勧めします。これにより、忘れられて最終的に問題が発生する可能性のある準備済みトランザクションが誤って作成されるのを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="4113594099b8ceaba5516ae6559f67b321dd3f1a" translate="yes" xml:space="preserve">
          <source>If you have pattern matching needs that go beyond this, consider writing a user-defined function in Perl or Tcl.</source>
          <target state="translated">これを超えるパターンマッチングのニーズがある場合は、Perl や Tcl でユーザー定義関数を書くことを検討してください。</target>
        </trans-unit>
        <trans-unit id="aedcf3e1663bdb52e36d3e2d02ae7396863fa330" translate="yes" xml:space="preserve">
          <source>If you have relocated &lt;code&gt;pg_wal&lt;/code&gt; outside the data directories, rsync must be run on those directories too.</source>
          <target state="translated">&lt;code&gt;pg_wal&lt;/code&gt; をデータディレクトリの外に移動した場合は、それらのディレクトリでもrsyncを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="a07426ce8ecfc80c9d7a4edfcb98cf0ba611138f" translate="yes" xml:space="preserve">
          <source>If you have tablespaces, you will need to run a similar rsync command for each tablespace directory, e.g.:</source>
          <target state="translated">テーブルスペースがある場合は、各テーブルスペースディレクトリに対して同様の rsync コマンドを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="74d92589027830b748d75a72665251c799371e5f" translate="yes" xml:space="preserve">
          <source>If you have the space to do so, copy the whole cluster data directory and any tablespaces to a temporary location in case you need them later. Note that this precaution will require that you have enough free space on your system to hold two copies of your existing database. If you do not have enough space, you should at least save the contents of the cluster's &lt;code&gt;pg_wal&lt;/code&gt; subdirectory, as it might contain logs which were not archived before the system went down.</source>
          <target state="translated">そのためのスペースがある場合は、後で必要になる場合に備えて、クラスターデータディレクトリ全体とすべてのテーブルスペースを一時的な場所にコピーします。この予防措置には、既存のデータベースの2つのコピーを保持するための十分な空きスペースがシステムに必要であることに注意してください。十分なスペースがない場合は、システムがダウンする前にアーカイブされなかったログが含まれている可能性があるため、少なくともクラスターの &lt;code&gt;pg_wal&lt;/code&gt; サブディレクトリの内容を保存する必要があります。</target>
        </trans-unit>
        <trans-unit id="c405c350a4bec28b591f01ed6531218b06904979" translate="yes" xml:space="preserve">
          <source>If you have to &amp;ldquo;hop&amp;rdquo; to the database server via some login host, one possible setup could look like this:</source>
          <target state="translated">ログインホストを介してデータベースサーバーに「ホップ」する必要がある場合、考えられる設定の1つは次のようになります。</target>
        </trans-unit>
        <trans-unit id="e1467a82f0f1d2aed2302c816a743bd03ff5d6fe" translate="yes" xml:space="preserve">
          <source>If you have turned off &lt;a href=&quot;runtime-config-logging#GUC-UPDATE-PROCESS-TITLE&quot;&gt;update_process_title&lt;/a&gt; then the activity indicator is not updated; the process title is set only once when a new process is launched. On some platforms this saves a measurable amount of per-command overhead; on others it's insignificant.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-logging#GUC-UPDATE-PROCESS-TITLE&quot;&gt;update_process_title&lt;/a&gt;をオフにした場合、アクティビティインジケーターは更新されません。プロセスのタイトルは、新しいプロセスが起動されたときに一度だけ設定されます。一部のプラットフォームでは、これにより、コマンドあたりのオーバーヘッドがかなり節約されます。他の人にはそれは取るに足らないです。</target>
        </trans-unit>
        <trans-unit id="cdc8af27dd93a99e3339ed60a27d59629c7d68fb" translate="yes" xml:space="preserve">
          <source>If you have unarchived WAL segment files that you saved in step 2, copy them into &lt;code&gt;pg_wal/&lt;/code&gt;. (It is best to copy them, not move them, so you still have the unmodified files if a problem occurs and you have to start over.)</source>
          <target state="translated">手順2で保存したアーカイブされていないWALセグメントファイルがある場合は、それらを &lt;code&gt;pg_wal/&lt;/code&gt; コピーします。（それらを移動するのではなく、コピーすることをお勧めします。そのため、問題が発生して最初からやり直す必要がある場合でも、変更されていないファイルが残っています。）</target>
        </trans-unit>
        <trans-unit id="f602421c44c7955b1682bc7b3fca54acb52d429c" translate="yes" xml:space="preserve">
          <source>If you modified &lt;code&gt;pg_hba.conf&lt;/code&gt;, restore its original settings. It might also be necessary to adjust other configuration files in the new cluster to match the old cluster, e.g. &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; を変更した場合は、元の設定に戻します。新しいクラスター内の他の構成ファイルを調整して、古いクラスターと一致させる必要がある場合もあります（例： &lt;code&gt;postgresql.conf&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="9316b03fae64e8c508527fbd0a6b640ef4256fda" translate="yes" xml:space="preserve">
          <source>If you modify files in &lt;code&gt;.../share/timezonesets/&lt;/code&gt;, it is up to you to make backups &amp;mdash; a normal database dump will not include this directory.</source>
          <target state="translated">&lt;code&gt;.../share/timezonesets/&lt;/code&gt; 内のファイルを変更する場合、バックアップを作成するかどうかはユーザー次第です。通常のデータベースダンプには、このディレクトリは含まれません。</target>
        </trans-unit>
        <trans-unit id="a80020f6d5771b4994b2b6087bde0a758b0dbcc3" translate="yes" xml:space="preserve">
          <source>If you need to modify a table that already exists, see &lt;a href=&quot;ddl-alter&quot;&gt;Section 5.6&lt;/a&gt; later in this chapter.</source>
          <target state="translated">すでに存在するテーブルを変更する必要がある場合は、この章の後半の&lt;a href=&quot;ddl-alter&quot;&gt;セクション5.6を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2efd34e960254e7fbc24d4c21228c55d47bceff1" translate="yes" xml:space="preserve">
          <source>If you need to re-create a standby server while transactions are waiting, make sure that the commands pg_start_backup() and pg_stop_backup() are run in a session with &lt;code&gt;synchronous_commit&lt;/code&gt; = &lt;code&gt;off&lt;/code&gt;, otherwise those requests will wait forever for the standby to appear.</source>
          <target state="translated">トランザクションの待機中にスタンバイサーバーを再作成する必要がある場合は、コマンドpg_start_backup（）およびpg_stop_backup（）が &lt;code&gt;synchronous_commit&lt;/code&gt; = &lt;code&gt;off&lt;/code&gt; のセッションで実行されることを確認してください。そうでない場合、これらのリクエストはスタンバイが表示されるまで永久に待機します。</target>
        </trans-unit>
        <trans-unit id="335eb5a28fe752ac43ab7d0bdb87c591351c3327" translate="yes" xml:space="preserve">
          <source>If you no longer need a table, you can remove it using the &lt;a href=&quot;sql-droptable&quot;&gt;DROP TABLE&lt;/a&gt; command. For example:</source>
          <target state="translated">テーブルが不要になった場合は、&lt;a href=&quot;sql-droptable&quot;&gt;DROP TABLE&lt;/a&gt;コマンドを使用して削除できます。例えば：</target>
        </trans-unit>
        <trans-unit id="4b094a7de4e477575e2b8864dd2a1871a2ac7be9" translate="yes" xml:space="preserve">
          <source>If you only need randomly-generated (version 4) UUIDs, consider using the &lt;code&gt;gen_random_uuid()&lt;/code&gt; function from the &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; module instead.</source>
          <target state="translated">ランダムに生成された（バージョン4）UUIDのみが必要な場合は、代わりに&lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt;モジュールの &lt;code&gt;gen_random_uuid()&lt;/code&gt; 関数を使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="c7ec64742024abd88ac376b90c1b4516681087ea" translate="yes" xml:space="preserve">
          <source>If you really cannot keep as many synchronous standbys as requested then you should decrease the number of synchronous standbys that transaction commits must wait for responses from in &lt;code&gt;synchronous_standby_names&lt;/code&gt; (or disable it) and reload the configuration file on the primary server.</source>
          <target state="translated">要求された数の同期スタンバイを本当に維持できない場合は、トランザクションコミットが &lt;code&gt;synchronous_standby_names&lt;/code&gt; での応答を待機する（または無効にする）必要がある同期スタンバイの数を減らし、プライマリサーバーで構成ファイルを再ロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="afb9b1746ef64ef43e1c6a611287b8838f8bab6f" translate="yes" xml:space="preserve">
          <source>If you really need to do something like that, you can either write a custom operator or add explicit casts to your query:</source>
          <target state="translated">どうしてもそのようなことが必要な場合は、カスタム演算子を書くか、クエリに明示的なキャストを追加します。</target>
        </trans-unit>
        <trans-unit id="4c6cec6fc682547181945340072f15c49a175a52" translate="yes" xml:space="preserve">
          <source>If you require exact storage and calculations (such as for monetary amounts), use the &lt;code&gt;numeric&lt;/code&gt; type instead.</source>
          <target state="translated">正確な保管と計算が必要な場合（金額など）は、代わりに &lt;code&gt;numeric&lt;/code&gt; タイプを使用してください。</target>
        </trans-unit>
        <trans-unit id="dda0ebbf2c21ed8ce369ceb9f7962ccab8e8d4c2" translate="yes" xml:space="preserve">
          <source>If you see a message similar to:</source>
          <target state="translated">似たようなメッセージが表示されたら</target>
        </trans-unit>
        <trans-unit id="5944bf42cb7e9bed827543dce0bb5da3eb25aaf4" translate="yes" xml:space="preserve">
          <source>If you select the &lt;code&gt;select-only&lt;/code&gt; built-in (also &lt;code&gt;-S&lt;/code&gt;), only the &lt;code&gt;SELECT&lt;/code&gt; is issued.</source>
          <target state="translated">あなたが選択した場合 &lt;code&gt;select-only&lt;/code&gt; ビルトイン（また &lt;code&gt;-S&lt;/code&gt; ）、唯一の &lt;code&gt;SELECT&lt;/code&gt; が発行されます。</target>
        </trans-unit>
        <trans-unit id="c440cbb3c75274ef5533f9dc20d09bc792bb4404" translate="yes" xml:space="preserve">
          <source>If you select the &lt;code&gt;simple-update&lt;/code&gt; built-in (also &lt;code&gt;-N&lt;/code&gt;), steps 4 and 5 aren't included in the transaction. This will avoid update contention on these tables, but it makes the test case even less like TPC-B.</source>
          <target state="translated">&lt;code&gt;simple-update&lt;/code&gt; ビルトイン（または &lt;code&gt;-N&lt;/code&gt; ）を選択した場合、ステップ4と5はトランザクションに含まれません。これにより、これらのテーブルでの更新の競合は回避されますが、テストケースがTPC-Bのようになります。</target>
        </trans-unit>
        <trans-unit id="2410e185ebe01d4bbafd07fc62d71b97897582e4" translate="yes" xml:space="preserve">
          <source>If you set a nonempty value for &lt;code&gt;log_line_prefix&lt;/code&gt;, you should usually make its last character be a space, to provide visual separation from the rest of the log line. A punctuation character can be used too.</source>
          <target state="translated">&lt;code&gt;log_line_prefix&lt;/code&gt; に空でない値を設定する場合は、通常、最後の文字をスペースにして、ログ行の残りの部分から視覚的に分離する必要があります。句読文字も使用できます。</target>
        </trans-unit>
        <trans-unit id="293043269744dfe0b2be9f58f146808d29c819d1" translate="yes" xml:space="preserve">
          <source>If you simply direct the stderr of &lt;code&gt;postgres&lt;/code&gt; into a file, you will have log output, but the only way to truncate the log file is to stop and restart the server. This might be acceptable if you are using PostgreSQL in a development environment, but few production servers would find this behavior acceptable.</source>
          <target state="translated">単に &lt;code&gt;postgres&lt;/code&gt; のstderrをファイルに送ると、ログが出力されますが、ログファイルを切り捨てる唯一の方法は、サーバーを停止して再起動することです。これは、開発環境でPostgreSQLを使用している場合は許容できるかもしれませんが、この動作を許容できると感じる運用サーバーはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="9ce920b3e4b27527a0945161fb81196b0962a822" translate="yes" xml:space="preserve">
          <source>If you simply write:</source>
          <target state="translated">単純に書けば</target>
        </trans-unit>
        <trans-unit id="86278d59973a9bff1da8685bc91d01d4bca2172c" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;code&gt;prefix&lt;/code&gt;, that string is prepended to the query's column names to create the variable names to use:</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; を指定すると、その文字列がクエリの列名の前に付加され、使用する変数名が作成されます。</target>
        </trans-unit>
        <trans-unit id="4293f633ad719b6229d97888e7c493efba01b4c4" translate="yes" xml:space="preserve">
          <source>If you specify a file name without escapes, you should plan to use a log rotation utility to avoid eventually filling the entire disk. In releases prior to 8.4, if no &lt;code&gt;%&lt;/code&gt; escapes were present, PostgreSQL would append the epoch of the new log file's creation time, but this is no longer the case.</source>
          <target state="translated">エスケープなしでファイル名を指定する場合は、ログローテーションユーティリティを使用して、最終的にディスク全体がいっぱいにならないようにする必要があります。8.4より前のリリースでは、 &lt;code&gt;%&lt;/code&gt; エスケープが存在しない場合、PostgreSQLは新しいログファイルの作成時刻のエポックを追加しますが、これは当てはまりません。</target>
        </trans-unit>
        <trans-unit id="cd2bed205787104a93fce03bc6421721af1bc122" translate="yes" xml:space="preserve">
          <source>If you specify columns, you probably have to escape the parentheses from the shell. (See examples below.)</source>
          <target state="translated">カラムを指定する場合は、おそらくシェルから括弧をエスケープする必要があると思います。(以下の例を参照してください)。</target>
        </trans-unit>
        <trans-unit id="c697983f7b5aa306c7f0f7a672c31b1b3cec3536" translate="yes" xml:space="preserve">
          <source>If you suspect corruption of an index on a user table, you can simply rebuild that index, or all indexes on the table, using &lt;code&gt;REINDEX INDEX&lt;/code&gt; or &lt;code&gt;REINDEX TABLE&lt;/code&gt;.</source>
          <target state="translated">ユーザーテーブルのインデックスの破損が疑われる場合は、 &lt;code&gt;REINDEX INDEX&lt;/code&gt; または &lt;code&gt;REINDEX TABLE&lt;/code&gt; を使用して、そのインデックスまたはテーブルのすべてのインデックスを再構築できます。</target>
        </trans-unit>
        <trans-unit id="634ba98da8d49a37a8349e78baa14c6e91b78095" translate="yes" xml:space="preserve">
          <source>If you use link mode, the upgrade will be much faster (no file copying) and use less disk space, but you will not be able to access your old cluster once you start the new cluster after the upgrade. Link mode also requires that the old and new cluster data directories be in the same file system. (Tablespaces and &lt;code&gt;pg_wal&lt;/code&gt; can be on different file systems.) Clone mode provides the same speed and disk space advantages but does not cause the old cluster to be unusable once the new cluster is started. Clone mode also requires that the old and new data directories be in the same file system. This mode is only available on certain operating systems and file systems.</source>
          <target state="translated">リンクモードを使用すると、アップグレードははるかに高速になり（ファイルのコピーなし）、使用するディスク領域が少なくなりますが、アップグレード後に新しいクラスターを起動すると、古いクラスターにアクセスできなくなります。リンクモードでは、古いクラスターデータディレクトリと新しいクラスターデータディレクトリが同じファイルシステムにある必要もあります。 （テーブルスペースと &lt;code&gt;pg_wal&lt;/code&gt; は異なるファイルシステム上にあってもかまいません。）クローンモードは同じ速度とディスクスペースの利点を提供しますが、新しいクラスターが起動すると古いクラスターが使用できなくなることはありません。また、クローンモードでは、古いデータディレクトリと新しいデータディレクトリが同じファイルシステムにある必要があります。このモードは、特定のオペレーティングシステムとファイルシステムでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="fe9e0a997d4a5f8ab6d05deb3608c7b48d1004eb" translate="yes" xml:space="preserve">
          <source>If you use streaming replication without file-based continuous archiving, the server might recycle old WAL segments before the standby has received them. If this occurs, the standby will need to be reinitialized from a new base backup. You can avoid this by setting &lt;code&gt;wal_keep_segments&lt;/code&gt; to a value large enough to ensure that WAL segments are not recycled too early, or by configuring a replication slot for the standby. If you set up a WAL archive that's accessible from the standby, these solutions are not required, since the standby can always use the archive to catch up provided it retains enough segments.</source>
          <target state="translated">ファイルベースの継続的アーカイブなしでストリーミングレプリケーションを使用する場合、スタンバイが受信する前にサーバーが古いWALセグメントをリサイクルする可能性があります。これが発生した場合は、スタンバイを新しいベースバックアップから再初期化する必要があります。これを回避するには、 &lt;code&gt;wal_keep_segments&lt;/code&gt; を十分に大きな値に設定して、WALセグメントが早くリサイクルされないようにするか、スタンバイ用のレプリケーションスロットを構成します。スタンバイからアクセス可能なWALアーカイブをセットアップする場合、スタンバイが十分なセグメントを保持している場合、スタンバイは常にアーカイブを使用して追いつくことができるため、これらのソリューションは必要ありません。</target>
        </trans-unit>
        <trans-unit id="410c6fd96b75590acd8e3654ea56e9babc9667ce" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;\o&lt;/code&gt; command to redirect your query output you might wish to use &lt;code&gt;\qecho&lt;/code&gt; instead of this command.</source>
          <target state="translated">&lt;code&gt;\o&lt;/code&gt; コマンドを使用してクエリ出力をリダイレクトする場合は、このコマンドの代わりに &lt;code&gt;\qecho&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="dacf2afd67d1d9e6693b9e34a44e3f31343f07b9" translate="yes" xml:space="preserve">
          <source>If you used link mode and have Streaming Replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;) or Log-Shipping (see &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;) standby servers, you can follow these steps to quickly upgrade them. You will not be running pg_upgrade on the standby servers, but rather rsync on the primary. Do not start any servers yet.</source>
          <target state="translated">リンクモードを使用していて、ストリーミングレプリケーション（&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;セクション26.2.5を&lt;/a&gt;参照）またはログ配布（&lt;a href=&quot;warm-standby&quot;&gt;セクション26.2を&lt;/a&gt;参照）スタンバイサーバーがある場合は、次の手順に従って、それらをすばやくアップグレードできます。スタンバイサーバーでpg_upgradeを実行するのではなく、プライマリサーバーでrsyncを実行します。まだサーバーを起動しないでください。</target>
        </trans-unit>
        <trans-unit id="46579b8a1d951df62d56dbc7236dffbdfa323aee" translate="yes" xml:space="preserve">
          <source>If you want an empty string rather than NULL, write double quotes:</source>
          <target state="translated">NULLではなく空文字列にしたい場合は、二重引用符で囲みます。</target>
        </trans-unit>
        <trans-unit id="e23816131f85edfcf8ebf4baf1b8f5a4f82e1a1c" translate="yes" xml:space="preserve">
          <source>If you want the digest as a hexadecimal string, use &lt;code&gt;encode()&lt;/code&gt; on the result. For example:</source>
          <target state="translated">16進数の文字列としてダイジェストが必要な場合は、結果に対して &lt;code&gt;encode()&lt;/code&gt; を使用します。例えば：</target>
        </trans-unit>
        <trans-unit id="c7212923c1936242a3a328b31eba624a84bab3c5" translate="yes" xml:space="preserve">
          <source>If you want the system to behave as if it had no locale support, use the special locale name &lt;code&gt;C&lt;/code&gt;, or equivalently &lt;code&gt;POSIX&lt;/code&gt;.</source>
          <target state="translated">システムがロケールをサポートしていないかのように動作させたい場合は、特別なロケール名 &lt;code&gt;C&lt;/code&gt; または同等の &lt;code&gt;POSIX&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="4f51609486b727fbe8393280c5551d1122917313" translate="yes" xml:space="preserve">
          <source>If you want to add a new method of making the data representation smaller, you must implement it in &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; and also teach &lt;code&gt;Catalog::ParseData()&lt;/code&gt; how to expand the data back into the full representation.</source>
          <target state="translated">あなたがデータ表現を小さくすることの新しい方法を追加したい場合は、それを実装する必要があります &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; ともティーチ &lt;code&gt;Catalog::ParseData()&lt;/code&gt; 完全な表現へのデータのバックを展開する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="7f058b6974f7c4fc1a4fda33213fb953c4c820d2" translate="yes" xml:space="preserve">
          <source>If you want to do complicated calculations with these types for anything important, especially if you rely on certain behavior in boundary cases (infinity, underflow), you should evaluate the implementation carefully.</source>
          <target state="translated">何か重要なことのためにこれらの型を使って複雑な計算をしたい場合、特に境界ケース(無限大、アンダーフロー)での特定の動作に依存している場合は、実装を慎重に評価する必要があります。</target>
        </trans-unit>
        <trans-unit id="f8d0dd9f6c3474fc520b6c68678cb5772392894d" translate="yes" xml:space="preserve">
          <source>If you want to have a double quote in the output you must precede it with a backslash, for example &lt;code&gt;'\&quot;YYYY Month\&quot;'&lt;/code&gt;. Backslashes are not otherwise special outside of double-quoted strings. Within a double-quoted string, a backslash causes the next character to be taken literally, whatever it is (but this has no special effect unless the next character is a double quote or another backslash).</source>
          <target state="translated">出力に二重引用符を含める場合は、その前にバックスラッシュを付ける必要があります（例： &lt;code&gt;'\&quot;YYYY Month\&quot;'&lt;/code&gt; 。バックスラッシュは、二重引用符で囲まれた文字列以外では特別なものではありません。二重引用符で囲まれた文字列内では、バックスラッシュによって次の文字が文字どおりに解釈されます（ただし、次の文字が二重引用符または別のバックスラッシュでない限り、これは特別な効果はありません）。</target>
        </trans-unit>
        <trans-unit id="b08912c8afafc035000c2b91395d4762ff623ba7" translate="yes" xml:space="preserve">
          <source>If you want to recover to some previous point in time (say, right before the junior DBA dropped your main transaction table), just specify the required &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;stopping point&lt;/a&gt;. You can specify the stop point, known as the &amp;ldquo;recovery target&amp;rdquo;, either by date/time, named restore point or by completion of a specific transaction ID. As of this writing only the date/time and named restore point options are very usable, since there are no tools to help you identify with any accuracy which transaction ID to use.</source>
          <target state="translated">以前のある時点（たとえば、ジュニアDBAがメイントランザクションテーブルを削除する直前）に回復する場合は、必要な&lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;停止ポイントを&lt;/a&gt;指定するだけです。日付/時刻、名前付きの復元ポイント、または特定のトランザクションIDの完了によって、「復元ターゲット」と呼ばれる停止ポイントを指定できます。これを書いている時点では、使用するトランザクションIDを正確に識別するためのツールがないため、日付/時刻と名前付き復元ポイントオプションのみが非常に便利です。</target>
        </trans-unit>
        <trans-unit id="f2799eac42b252d1fdead69c5594bb2d3a2059fa" translate="yes" xml:space="preserve">
          <source>If you want to run a parallel dump of a pre-9.2 server, you need to make sure that the database content doesn't change from between the time the master connects to the database until the last worker job has connected to the database. The easiest way to do this is to halt any data modifying processes (DDL and DML) accessing the database before starting the backup. You also need to specify the &lt;code&gt;--no-synchronized-snapshots&lt;/code&gt; parameter when running &lt;code&gt;pg_dump -j&lt;/code&gt; against a pre-9.2 PostgreSQL server.</source>
          <target state="translated">9.2より前のサーバーの並列ダンプを実行する場合は、マスターがデータベースに接続してから最後のワーカージョブがデータベースに接続するまでの間に、データベースの内容が変化しないことを確認する必要があります。これを行う最も簡単な方法は、バックアップを開始する前に、データベースにアクセスするデータ変更プロセス（DDLおよびDML）を停止することです。9.2より前のPostgreSQLサーバーに対して &lt;code&gt;pg_dump -j&lt;/code&gt; を実行する場合は、 &lt;code&gt;--no-synchronized-snapshots&lt;/code&gt; パラメーターも指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="1235d6c60bdf10ad9cf9d8bf29ece023d11255aa" translate="yes" xml:space="preserve">
          <source>If you want to see the lines on the screen as they are read you must set the variable &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="translated">行が読み取られたときに画面に表示されるようにするには、変数 &lt;code&gt;ECHO&lt;/code&gt; を &lt;code&gt;all&lt;/code&gt; に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="d777fa853e95af192514bf1aeb804e6308b39ad2" translate="yes" xml:space="preserve">
          <source>If you want to use link mode and you do not want your old cluster to be modified when the new cluster is started, consider using the clone mode. If that is not available, make a copy of the old cluster and upgrade that in link mode. To make a valid copy of the old cluster, use &lt;code&gt;rsync&lt;/code&gt; to create a dirty copy of the old cluster while the server is running, then shut down the old server and run &lt;code&gt;rsync --checksum&lt;/code&gt; again to update the copy with any changes to make it consistent. (&lt;code&gt;--checksum&lt;/code&gt; is necessary because &lt;code&gt;rsync&lt;/code&gt; only has file modification-time granularity of one second.) You might want to exclude some files, e.g. &lt;code&gt;postmaster.pid&lt;/code&gt;, as documented in &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Section 25.3.3&lt;/a&gt;. If your file system supports file system snapshots or copy-on-write file copies, you can use that to make a backup of the old cluster and tablespaces, though the snapshot and copies must be created simultaneously or while the database server is down.</source>
          <target state="translated">リンクモードを使用し、新しいクラスターの起動時に古いクラスターを変更したくない場合は、クローンモードの使用を検討してください。それが利用できない場合は、古いクラスターのコピーを作成し、リンクモードでアップグレードします。古いクラスターの有効なコピーを作成するには、サーバーの実行中に &lt;code&gt;rsync&lt;/code&gt; を使用して古いクラスターのダーティーコピーを作成し、古いサーバーをシャットダウンして &lt;code&gt;rsync --checksum&lt;/code&gt; を再度実行し、変更を加えてコピーを更新します。一貫した。 （ &lt;code&gt;--checksum&lt;/code&gt; があるため必要である &lt;code&gt;rsync&lt;/code&gt; は 1秒間だけのファイル更新時の細かさを持っています。）あなたは例えば、いくつかのファイルを除外したい場合があります &lt;code&gt;postmaster.pid&lt;/code&gt; に記載されているように、&lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;セクション25.3.3&lt;/a&gt;。ファイルシステムがファイルシステムスナップショットまたはコピーオンライトファイルコピーをサポートしている場合、それを使用して古いクラスターとテーブルスペースのバックアップを作成できますが、スナップショットとコピーは同時にまたはデータベースサーバーがダウンしているときに作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="548498a07974c2669fa7d265bb5ed01fd29f2726" translate="yes" xml:space="preserve">
          <source>If you want to use psql to connect to several servers of different major versions, it is recommended that you use the newest version of psql. Alternatively, you can keep around a copy of psql from each major version and be sure to use the version that matches the respective server. But in practice, this additional complication should not be necessary.</source>
          <target state="translated">psqlを使ってメジャーバージョンの異なる複数のサーバに接続したい場合は、最新バージョンのpsqlを使うことをお勧めします。あるいは、各メジャーバージョンのpsqlのコピーを持っておき、それぞれのサーバに合ったバージョンを使うようにしてもいいでしょう。しかし、実際には、このような追加の煩わしさは必要ないはずです。</target>
        </trans-unit>
        <trans-unit id="c83197bfbed6d42e302edf49770400c3bb7ffc90" translate="yes" xml:space="preserve">
          <source>If you want to use streaming replication, fill in &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; with a libpq connection string, including the host name (or IP address) and any additional details needed to connect to the primary server. If the primary needs a password for authentication, the password needs to be specified in &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; as well.</source>
          <target state="translated">ストリーミングレプリケーションを使用する場合は、プライマリサーバーへの接続に必要なホスト名（またはIPアドレス）とその他の詳細を含むlibpq接続文字列を&lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfoに入力&lt;/a&gt;します。プライマリで認証にパスワードが必要な場合は、パスワードを&lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt;でも指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="8304e11449eef667491dd46bf0e842007ab0620d" translate="yes" xml:space="preserve">
          <source>If you want to use streaming replication, set up authentication on the primary server to allow replication connections from the standby server(s); that is, create a role and provide a suitable entry or entries in &lt;code&gt;pg_hba.conf&lt;/code&gt; with the database field set to &lt;code&gt;replication&lt;/code&gt;. Also ensure &lt;code&gt;max_wal_senders&lt;/code&gt; is set to a sufficiently large value in the configuration file of the primary server. If replication slots will be used, ensure that &lt;code&gt;max_replication_slots&lt;/code&gt; is set sufficiently high as well.</source>
          <target state="translated">ストリーミングレプリケーションを使用する場合は、プライマリサーバーで認証を設定して、スタンバイサーバーからのレプリケーション接続を許可します。つまり、ロールを作成し、データベースフィールドを &lt;code&gt;replication&lt;/code&gt; に設定して、 &lt;code&gt;pg_hba.conf&lt;/code&gt; に適切なエントリを提供します。また、プライマリサーバーの構成ファイルで &lt;code&gt;max_wal_senders&lt;/code&gt; が十分に大きな値に設定されていることを確認してください。レプリケーションスロットを使用する場合は、 &lt;code&gt;max_replication_slots&lt;/code&gt; も十分に高く設定してください。</target>
        </trans-unit>
        <trans-unit id="d505643f0e154d892e49d0ce311315a8a63b86fd" translate="yes" xml:space="preserve">
          <source>If you wish to create a new superuser, you must connect as a superuser, not merely with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege. Being a superuser implies the ability to bypass all access permission checks within the database, so superuserdom should not be granted lightly.</source>
          <target state="translated">新しいスーパーユーザーを作成したい場合は、単に &lt;code&gt;CREATEROLE&lt;/code&gt; 特権ではなく、スーパーユーザーとして接続する必要があります。スーパーユーザーであるということは、データベース内のすべてのアクセス許可チェックをバイパスする機能を意味するため、スーパーユーザーを軽く許可するべきではありません。</target>
        </trans-unit>
        <trans-unit id="dba6f63305bb053e32c8873d900ab4a929146d0b" translate="yes" xml:space="preserve">
          <source>If you wish to drop a role for which the default privileges have been altered, it is necessary to reverse the changes in its default privileges or use &lt;code&gt;DROP OWNED BY&lt;/code&gt; to get rid of the default privileges entry for the role.</source>
          <target state="translated">デフォルトの権限が変更されたロールを削除する場合は、デフォルトの権限の変更を元に戻すか、 &lt;code&gt;DROP OWNED BY&lt;/code&gt; を使用してロールのデフォルトの権限エントリを削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="fe513e6fe150eda65f8a240b4c5ab71cf30d3ea3" translate="yes" xml:space="preserve">
          <source>If you wish to keep the configuration files elsewhere than the data directory, the &lt;code&gt;postgres&lt;/code&gt;&lt;code&gt;-D&lt;/code&gt; command-line option or &lt;code&gt;PGDATA&lt;/code&gt; environment variable must point to the directory containing the configuration files, and the &lt;code&gt;data_directory&lt;/code&gt; parameter must be set in &lt;code&gt;postgresql.conf&lt;/code&gt; (or on the command line) to show where the data directory is actually located. Notice that &lt;code&gt;data_directory&lt;/code&gt; overrides &lt;code&gt;-D&lt;/code&gt; and &lt;code&gt;PGDATA&lt;/code&gt; for the location of the data directory, but not for the location of the configuration files.</source>
          <target state="translated">構成ファイルをデータディレクトリ以外の場所に保持する場合は、 &lt;code&gt;postgres&lt;/code&gt; &lt;code&gt;-D&lt;/code&gt; コマンドラインオプションまたは &lt;code&gt;PGDATA&lt;/code&gt; 環境変数が構成ファイルを含むディレクトリを指している必要があり、 &lt;code&gt;data_directory&lt;/code&gt; パラメータを &lt;code&gt;postgresql.conf&lt;/code&gt; （またはコマンドライン）を使用して、データディレクトリが実際に配置されている場所を表示します。 &lt;code&gt;data_directory&lt;/code&gt; は、データディレクトリの場所では &lt;code&gt;-D&lt;/code&gt; および &lt;code&gt;PGDATA&lt;/code&gt; をオーバーライドしますが、構成ファイルの場所ではオーバーライドしないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="5e43ef9c20e530883e37f2ea188b5ba2ab7b89db" translate="yes" xml:space="preserve">
          <source>If you wish, you can specify the configuration file names and locations individually using the parameters &lt;code&gt;config_file&lt;/code&gt;, &lt;code&gt;hba_file&lt;/code&gt; and/or &lt;code&gt;ident_file&lt;/code&gt;. &lt;code&gt;config_file&lt;/code&gt; can only be specified on the &lt;code&gt;postgres&lt;/code&gt; command line, but the others can be set within the main configuration file. If all three parameters plus &lt;code&gt;data_directory&lt;/code&gt; are explicitly set, then it is not necessary to specify &lt;code&gt;-D&lt;/code&gt; or &lt;code&gt;PGDATA&lt;/code&gt;.</source>
          <target state="translated">ご希望の場合は、個別に設定ファイルの名前と場所のパラメータを使用して指定することができ &lt;code&gt;config_file&lt;/code&gt; 、 &lt;code&gt;hba_file&lt;/code&gt; および/または &lt;code&gt;ident_file&lt;/code&gt; を。 &lt;code&gt;config_file&lt;/code&gt; は &lt;code&gt;postgres&lt;/code&gt; コマンドラインでのみ指定できますが、その他はメインの構成ファイル内で設定できます。 3つのパラメーターと &lt;code&gt;data_directory&lt;/code&gt; のすべてが明示的に設定されている場合、 &lt;code&gt;-D&lt;/code&gt; または &lt;code&gt;PGDATA&lt;/code&gt; を指定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="32daceaa2cf366c2fe6d0715c4458443ee88a963" translate="yes" xml:space="preserve">
          <source>If you're setting up the standby server for high availability purposes, set up WAL archiving, connections and authentication like the primary server, because the standby server will work as a primary server after failover.</source>
          <target state="translated">高可用性を目的として待機サーバーを設定する場合は、フェイルオーバー後に待機サーバーがプライマリーサーバーとして動作するため、プライマリーサーバーと同様にWALアーカイブ、接続、認証を設定してください。</target>
        </trans-unit>
        <trans-unit id="c5ac9027a677c31c54f143f0fe38940b45904e3a" translate="yes" xml:space="preserve">
          <source>If you're using a WAL archive, its size can be minimized using the &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt; parameter to remove files that are no longer required by the standby server. The pg_archivecleanup utility is designed specifically to be used with &lt;code&gt;archive_cleanup_command&lt;/code&gt; in typical single-standby configurations, see &lt;a href=&quot;pgarchivecleanup&quot;&gt;pg_archivecleanup&lt;/a&gt;. Note however, that if you're using the archive for backup purposes, you need to retain files needed to recover from at least the latest base backup, even if they're no longer needed by the standby.</source>
          <target state="translated">WALアーカイブを使用している場合は、&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt;パラメータを使用してそのサイズを最小化し、スタンバイサーバーで不要になったファイルを削除できます。 pg_archivecleanupユーティリティは、典型的なシングルスタンバイ構成で &lt;code&gt;archive_cleanup_command&lt;/code&gt; と共に使用するように特別に設計されています&lt;a href=&quot;pgarchivecleanup&quot;&gt;。pg_archivecleanupを&lt;/a&gt;参照してください。ただし、アーカイブをバックアップの目的で使用している場合は、スタンバイで不要になった場合でも、少なくとも最新の基本バックアップからの復元に必要なファイルを保持する必要があります。</target>
        </trans-unit>
        <trans-unit id="eede8f4eab7ac7c7f42522f0f50f00f83f33b103" translate="yes" xml:space="preserve">
          <source>If your application needs to use other forms of partitioning not listed above, alternative methods such as inheritance and &lt;code&gt;UNION ALL&lt;/code&gt; views can be used instead. Such methods offer flexibility but do not have some of the performance benefits of built-in declarative partitioning.</source>
          <target state="translated">アプリケーションが上記にリストされていない他の形式のパーティショニングを使用する必要がある場合は、継承や &lt;code&gt;UNION ALL&lt;/code&gt; ビューなどの代替方法を代わりに使用できます。このようなメソッドは柔軟性を提供しますが、組み込みの宣言型パーティション分割のパフォーマンス上の利点はありません。</target>
        </trans-unit>
        <trans-unit id="693883e4d7e5062d3b1b4e420d1dcd21d56fe252" translate="yes" xml:space="preserve">
          <source>If your database cluster has any local additions to the &lt;code&gt;template1&lt;/code&gt; database, be careful to restore the output of pg_dump into a truly empty database; otherwise you are likely to get errors due to duplicate definitions of the added objects. To make an empty database without any local additions, copy from &lt;code&gt;template0&lt;/code&gt; not &lt;code&gt;template1&lt;/code&gt;, for example:</source>
          <target state="translated">データベースクラスターに &lt;code&gt;template1&lt;/code&gt; データベースへのローカルな追加がある場合、pg_dumpの出力を本当に空のデータベースに復元するように注意してください。そうしないと、追加されたオブジェクトの定義が重複しているためにエラーが発生する可能性があります。以下からのコピー、ローカルな追加せずに空のデータベースを作成するには &lt;code&gt;template0&lt;/code&gt; ない &lt;code&gt;template1&lt;/code&gt; を例えば、：</target>
        </trans-unit>
        <trans-unit id="bfe8c7a1e0073145cfd43127c90a639a57c975f4" translate="yes" xml:space="preserve">
          <source>If your database is spread across multiple file systems, there might not be any way to obtain exactly-simultaneous frozen snapshots of all the volumes. For example, if your data files and WAL log are on different disks, or if tablespaces are on different file systems, it might not be possible to use snapshot backup because the snapshots &lt;em&gt;must&lt;/em&gt; be simultaneous. Read your file system documentation very carefully before trusting the consistent-snapshot technique in such situations.</source>
          <target state="translated">データベースが複数のファイルシステムに分散している場合、すべてのボリュームの正確に同時に凍結されたスナップショットを取得する方法がない場合があります。たとえば、データファイルとWALログが異なるディスク上にある場合、またはテーブルスペースが異なるファイルシステム上にある場合、スナップショット&lt;em&gt;は&lt;/em&gt;同時で&lt;em&gt;なければならない&lt;/em&gt;ため、スナップショットバックアップを使用できない場合が&lt;em&gt;あり&lt;/em&gt;ます。このような状況でコンシステントスナップショット手法を信頼する前に、ファイルシステムのドキュメントをよく読んでください。</target>
        </trans-unit>
        <trans-unit id="89affde528d7a785d4590b760f08553f5fba2e5e" translate="yes" xml:space="preserve">
          <source>If your installation directory is not version-specific, e.g. &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, it is necessary to move the current PostgreSQL install directory so it does not interfere with the new PostgreSQL installation. Once the current PostgreSQL server is shut down, it is safe to rename the PostgreSQL installation directory; assuming the old directory is &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, you can do:</source>
          <target state="translated">&lt;code&gt;/usr/local/pgsql&lt;/code&gt; など、インストールディレクトリがバージョン固有でない場合は、現在のPostgreSQLインストールディレクトリを移動して、新しいPostgreSQLインストールの妨げにならないようにする必要があります。現在のPostgreSQLサーバーがシャットダウンしたら、PostgreSQLインストールディレクトリの名前を変更しても安全です。古いディレクトリが &lt;code&gt;/usr/local/pgsql&lt;/code&gt; であるとすると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="cd01544b621df2f2698aa331ec7e1d502c246c7e" translate="yes" xml:space="preserve">
          <source>If your installation has any local additions to the &lt;code&gt;template1&lt;/code&gt; database, be careful to load the output of pg_restore into a truly empty database; otherwise you are likely to get errors due to duplicate definitions of the added objects. To make an empty database without any local additions, copy from &lt;code&gt;template0&lt;/code&gt; not &lt;code&gt;template1&lt;/code&gt;, for example:</source>
          <target state="translated">ご使用のシステムに &lt;code&gt;template1&lt;/code&gt; データベースへのローカルな追加がある場合は、pg_restoreの出力を本当に空のデータベースにロードするように注意してください。そうしないと、追加されたオブジェクトの定義が重複しているためにエラーが発生する可能性があります。以下からのコピー、ローカルな追加せずに空のデータベースを作成するには &lt;code&gt;template0&lt;/code&gt; ない &lt;code&gt;template1&lt;/code&gt; を例えば、：</target>
        </trans-unit>
        <trans-unit id="fb5ad20ebf8b8594ba828c2e14073cc42a290699" translate="yes" xml:space="preserve">
          <source>If your needs go beyond the capabilities of these conditional expressions, you might want to consider writing a server-side function in a more expressive programming language.</source>
          <target state="translated">ニーズがこれらの条件式の機能を超えている場合は、より表現力の高いプログラミング言語でサーバーサイドの関数を書くことを検討してみてはいかがでしょうか。</target>
        </trans-unit>
        <trans-unit id="092f5bf3a3fbeb060b8f061dfe4479d40fe497ca" translate="yes" xml:space="preserve">
          <source>If your site administrator has not set things up in the default way, you might have some more work to do. For example, if the database server machine is a remote machine, you will need to set the &lt;code&gt;PGHOST&lt;/code&gt; environment variable to the name of the database server machine. The environment variable &lt;code&gt;PGPORT&lt;/code&gt; might also have to be set. The bottom line is this: if you try to start an application program and it complains that it cannot connect to the database, you should consult your site administrator or, if that is you, the documentation to make sure that your environment is properly set up. If you did not understand the preceding paragraph then read the next section.</source>
          <target state="translated">サイト管理者がデフォルトの方法で設定していない場合は、さらに作業が必要になる可能性があります。たとえば、データベースサーバーマシンがリモートマシンの場合、 &lt;code&gt;PGHOST&lt;/code&gt; 環境変数をデータベースサーバーマシンの名前に設定する必要があります。環境変数 &lt;code&gt;PGPORT&lt;/code&gt; も設定する必要がある場合があります。つまり、アプリケーションプログラムを起動しようとして、データベースに接続できないというメッセージが表示された場合は、サイト管理者に問い合わせるか、その場合はドキュメントを参照して、環境が適切に設定されていることを確認してください。 。前の段落を理解していない場合は、次のセクションを読んでください。</target>
        </trans-unit>
        <trans-unit id="0e26c0628db89c4d17246b09878aa1c2d36a0d98" translate="yes" xml:space="preserve">
          <source>If your system supports per-user disk quotas, then the database will naturally be subject to whatever quota is placed on the user the server runs as. Exceeding the quota will have the same bad effects as running out of disk space entirely.</source>
          <target state="translated">システムがユーザごとのディスククォータをサポートしている場合、データベースは当然のことながら、サーバを実行しているユーザに割り当てられたクォータの影響を受けることになります。クォータを超えてしまうと、ディスク容量を完全に使い果たしてしまうのと同じような悪影響があります。</target>
        </trans-unit>
        <trans-unit id="db517070c58b7073cbfea804db0649d1169a5342" translate="yes" xml:space="preserve">
          <source>If, after running &lt;code&gt;pg_upgrade&lt;/code&gt;, you wish to revert to the old cluster, there are several options:</source>
          <target state="translated">&lt;code&gt;pg_upgrade&lt;/code&gt; の実行後に古いクラスターに戻したい場合は、いくつかのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="1101febd9e8e65c65ae1f196aecd9bf8175188c4" translate="yes" xml:space="preserve">
          <source>If, partway through the transaction, we decide we do not want to commit (perhaps we just noticed that Alice's balance went negative), we can issue the command &lt;code&gt;ROLLBACK&lt;/code&gt; instead of &lt;code&gt;COMMIT&lt;/code&gt;, and all our updates so far will be canceled.</source>
          <target state="translated">トランザクションの途中でコミットしないことを決定した場合（おそらく、アリスの残高がマイナスになったことに気付いただけかもしれません）、 &lt;code&gt;COMMIT&lt;/code&gt; の代わりにコマンド &lt;code&gt;ROLLBACK&lt;/code&gt; を発行できます。これまでのすべての更新はキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="f5024d286e4914e76d806049ed9ed5a9adde6b60" translate="yes" xml:space="preserve">
          <source>Ignore system indexes when reading system tables (but still update the indexes when modifying the tables). This is useful when recovering from damaged system indexes. This parameter cannot be changed after session start.</source>
          <target state="translated">システムテーブルを読み込む際にシステムインデックスを無視します(ただし、テーブルを修正する際にはインデックスを更新します)。これは、破損したシステムインデックスから回復するときに便利です。このパラメータは、セッション開始後に変更することはできません。</target>
        </trans-unit>
        <trans-unit id="71db18d1300170d2010c351c48755c19862c8762" translate="yes" xml:space="preserve">
          <source>Ignore system indexes when reading system tables, but still update the indexes when modifying the tables. This is useful when recovering from damaged system indexes.</source>
          <target state="translated">システムテーブルの読み込み時にはシステムインデックスを無視しますが、テーブルの修正時にはインデックスを更新します。これは、破損したシステムインデックスから復旧するときに便利です。</target>
        </trans-unit>
        <trans-unit id="78fee1435d74666b84850cd5e82c18229351da5d" translate="yes" xml:space="preserve">
          <source>Ignored</source>
          <target state="translated">Ignored</target>
        </trans-unit>
        <trans-unit id="0bbd8cc216c54e73f7ea687a30b566c0b2c97cbb" translate="yes" xml:space="preserve">
          <source>Ignored for compatibility. Use of these keywords is deprecated; refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">互換性のために無視されます。これらのキーワードの使用は非推奨です。参照&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLEを&lt;/a&gt;詳細については。</target>
        </trans-unit>
        <trans-unit id="b3a3e33cda0750b99611590eb50e57574fe1fbbc" translate="yes" xml:space="preserve">
          <source>Ignored for conformance with the SQL standard.</source>
          <target state="translated">SQL標準への適合性のために無視されます。</target>
        </trans-unit>
        <trans-unit id="61522d42e0f29a20214f69c85ea7d7e480669670" translate="yes" xml:space="preserve">
          <source>Illustrations of how these different formats look can be seen in the &lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;Examples&lt;/a&gt; section.</source>
          <target state="translated">これらのさまざまな形式がどのように表示されるかを示す&lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;例&lt;/a&gt;は、例のセクションにあります。</target>
        </trans-unit>
        <trans-unit id="bf50e138c7fa8f736f41cea1cb795eaf265d80f2" translate="yes" xml:space="preserve">
          <source>Immediately after connecting as role &lt;code&gt;joe&lt;/code&gt;, a database session will have use of privileges granted directly to &lt;code&gt;joe&lt;/code&gt; plus any privileges granted to &lt;code&gt;admin&lt;/code&gt;, because &lt;code&gt;joe&lt;/code&gt;&amp;ldquo;inherits&amp;rdquo;&lt;code&gt;admin&lt;/code&gt;'s privileges. However, privileges granted to &lt;code&gt;wheel&lt;/code&gt; are not available, because even though &lt;code&gt;joe&lt;/code&gt; is indirectly a member of &lt;code&gt;wheel&lt;/code&gt;, the membership is via &lt;code&gt;admin&lt;/code&gt; which has the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute. After:</source>
          <target state="translated">&lt;code&gt;joe&lt;/code&gt; として接続した直後、データベースセッションでは、 &lt;code&gt;joe&lt;/code&gt; に直接付与された特権と &lt;code&gt;admin&lt;/code&gt; に付与されたすべての特権が使用されます。これは、 &lt;code&gt;joe&lt;/code&gt; が &lt;code&gt;admin&lt;/code&gt; の特権を「継承」しているためです。ただし、 &lt;code&gt;joe&lt;/code&gt; は間接的に &lt;code&gt;wheel&lt;/code&gt; のメンバーであるにもかかわらず、メンバーシップは &lt;code&gt;NOINHERIT&lt;/code&gt; 属性を持つ &lt;code&gt;admin&lt;/code&gt; を介しているため、 &lt;code&gt;wheel&lt;/code&gt; に付与された特権は使用できません。後：</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="23167d1539b634954643857fda589f9a1f99fc34" translate="yes" xml:space="preserve">
          <source>Implementation language or call interface of this function</source>
          <target state="translated">この関数の実装言語または呼び出しインターフェース</target>
        </trans-unit>
        <trans-unit id="261a75d84276a41b101b0b0b2ac4d845072c8241" translate="yes" xml:space="preserve">
          <source>Implicit conversions should never have surprising or unpredictable outcomes.</source>
          <target state="translated">暗黙の変換は、決して驚くべき結果や予測不可能な結果をもたらすべきではありません。</target>
        </trans-unit>
        <trans-unit id="4a78c79f95926318ef6fec9862a700583e71fbd0" translate="yes" xml:space="preserve">
          <source>Implicit unit of the parameter</source>
          <target state="translated">パラメータの暗黙の単位</target>
        </trans-unit>
        <trans-unit id="60fa0aba1042461c4c2f1fe75e803d3f36549dc2" translate="yes" xml:space="preserve">
          <source>Import only foreign tables matching one of the given table names. Other tables existing in the foreign schema will be ignored.</source>
          <target state="translated">指定されたテーブル名のいずれかに一致する外部テーブルのみをインポートします。外部スキーマに存在する他のテーブルは無視されます。</target>
        </trans-unit>
        <trans-unit id="2775c7ad42c3e8d71ae7e18124278fff473728e1" translate="yes" xml:space="preserve">
          <source>Import operating system collations</source>
          <target state="translated">オペレーティングシステムの照合順序のインポート</target>
        </trans-unit>
        <trans-unit id="bd09d7d5cbde0f6a55b8befe57d5d6baee4d6f2b" translate="yes" xml:space="preserve">
          <source>Import table definitions from a remote schema &lt;code&gt;foreign_films&lt;/code&gt; on server &lt;code&gt;film_server&lt;/code&gt;, creating the foreign tables in local schema &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">サーバー &lt;code&gt;film_server&lt;/code&gt; のリモートスキーマ &lt;code&gt;foreign_films&lt;/code&gt; からテーブル定義をインポートし、ローカルスキーマ &lt;code&gt;films&lt;/code&gt; 外部テーブルを作成します。</target>
        </trans-unit>
        <trans-unit id="4b6d6a30150a506f9b79caf45da5aecb76b0018e" translate="yes" xml:space="preserve">
          <source>Important</source>
          <target state="translated">Important</target>
        </trans-unit>
        <trans-unit id="40baa6b48d8c1dc060a4acaef47611a694c99ef3" translate="yes" xml:space="preserve">
          <source>Importing behavior can be customized with the following options (given in the &lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; command):</source>
          <target state="translated">インポート動作は、次のオプションでカスタマイズできます（ &lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; コマンドで指定）。</target>
        </trans-unit>
        <trans-unit id="6cdac824d2a40a7779c6dcbb8d843dee4847ebb5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;Table F.26&lt;/a&gt;, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;delta&lt;/code&gt; denote floating-point numbers. &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, but not &lt;code&gt;delta&lt;/code&gt;, can be preceded by a certainty indicator.</source>
          <target state="translated">で&lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;表F.26&lt;/a&gt;、 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;delta&lt;/code&gt; 表す浮動小数点数。 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; 、ただし &lt;code&gt;delta&lt;/code&gt; の前には、確実性インジケータを付けることができます。</target>
        </trans-unit>
        <trans-unit id="42729a410f5a9327e00095fef5d98f4dbb7419a2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;Table C.1&lt;/a&gt; in the column for PostgreSQL we classify as &amp;ldquo;non-reserved&amp;rdquo; those key words that are explicitly known to the parser but are allowed as column or table names. Some key words that are otherwise non-reserved cannot be used as function or data type names and are marked accordingly. (Most of these words represent built-in functions or data types with special syntax. The function or type is still available but it cannot be redefined by the user.) Labeled &amp;ldquo;reserved&amp;rdquo; are those tokens that are not allowed as column or table names. Some reserved key words are allowable as names for functions or data types; this is also shown in the table. If not so marked, a reserved key word is only allowed as an &amp;ldquo;AS&amp;rdquo; column label name.</source>
          <target state="translated">で&lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;表C.1&lt;/a&gt; PostgreSQLの列で、我々は明示的にパーサーに知られているが、列名やテーブル名として許可されている「非予約」これらのキーワードとして分類します。それ以外の場合は予約されていない一部のキーワードは、関数またはデータ型の名前として使用できず、それに応じてマークされます。 （これらの単語のほとんどは、特別な構文を持つ組み込み関数またはデータ型を表しています。関数または型は引き続き使用できますが、ユーザーが再定義することはできません。）ラベル付きの「予約済み」は、列またはテーブル名として許可されていないトークンです。一部の予約済みキーワードは、関数またはデータ型の名前として使用できます。これも表に示されています。マークされていない場合、予約キーワードは「AS」列のラベル名としてのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="5fee127e33ba4c6342d0b89b7e063498409c73cb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, automatically stop replication and exit with normal exit status 0 when receiving reaches the specified LSN. If specified when not in &lt;code&gt;--start&lt;/code&gt; mode, an error is raised.</source>
          <target state="translated">で &lt;code&gt;--start&lt;/code&gt; 正常終了ステータス0のモード、自動的に停止複製および出口到達指定LSNを受信した場合。 &lt;code&gt;--start&lt;/code&gt; モードでないときに指定すると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="3bfcd6bf2f68dc3b43c9cf872d41f5d653495d00" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, start replication from the given LSN. For details on the effect of this, see the documentation in &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;. Ignored in other modes.</source>
          <target state="translated">で &lt;code&gt;--start&lt;/code&gt; モードでは、与えられたLSNからレプリケーションを開始。この影響の詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;第48章&lt;/a&gt;および&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;セクション52.4の&lt;/a&gt;ドキュメントを参照してください。他のモードでは無視されます。</target>
        </trans-unit>
        <trans-unit id="12bbea7ca03f59c395276fdbf0ca262376507500" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, use the existing logical replication slot named &lt;code&gt;slot_name&lt;/code&gt;. In &lt;code&gt;--create-slot&lt;/code&gt; mode, create the slot with this name. In &lt;code&gt;--drop-slot&lt;/code&gt; mode, delete the slot with this name.</source>
          <target state="translated">で &lt;code&gt;--start&lt;/code&gt; モードでは、既存の論理複製スロットという名前の使用 &lt;code&gt;slot_name&lt;/code&gt; 。で &lt;code&gt;--create-slot&lt;/code&gt; モード、この名前のスロットを作成します。で &lt;code&gt;--drop-slot&lt;/code&gt; モード、この名前のスロットを削除します。</target>
        </trans-unit>
        <trans-unit id="18d7da29e783f36fa5dffa6644b2287183a78875" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;CSV&lt;/code&gt; format, all characters are significant. A quoted value surrounded by white space, or any characters other than &lt;code&gt;DELIMITER&lt;/code&gt;, will include those characters. This can cause errors if you import data from a system that pads &lt;code&gt;CSV&lt;/code&gt; lines with white space out to some fixed width. If such a situation arises you might need to preprocess the &lt;code&gt;CSV&lt;/code&gt; file to remove the trailing white space, before importing the data into PostgreSQL.</source>
          <target state="translated">&lt;code&gt;CSV&lt;/code&gt; 形式で、すべての文字が重要です。空白または &lt;code&gt;DELIMITER&lt;/code&gt; 以外の文字で囲まれた引用符付きの値には、それらの文字が含まれます。これにより、 &lt;code&gt;CSV&lt;/code&gt; 行に空白を埋め込んで固定幅にするシステムからデータをインポートすると、エラーが発生する可能性があります。このような状況が発生した場合、PostgreSQLにデータをインポートする前に、 &lt;code&gt;CSV&lt;/code&gt; ファイルを前処理して末尾の空白を削除する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="0153f75e36e8f0039d3aa08af5bcc40422e9783b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;FROM&lt;/code&gt; items, both the standard and PostgreSQL allow &lt;code&gt;AS&lt;/code&gt; to be omitted before an alias that is an unreserved keyword. But this is impractical for output column names, because of syntactic ambiguities.</source>
          <target state="translated">では &lt;code&gt;FROM&lt;/code&gt; アイテム、標準とPostgreSQLの両方ができるように &lt;code&gt;AS&lt;/code&gt; が予約されていないキーワードである別名の前に省略できるようになりました。しかし、構文のあいまいさのため、これは出力列名には非現実的です。</target>
        </trans-unit>
        <trans-unit id="0a49988bfaefe7a720bbc33d73d20e3ed846b39f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;GROUPS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; again must yield a non-null, non-negative integer, and the option means that the frame starts or ends the specified number of &lt;em&gt;peer groups&lt;/em&gt; before or after the current row's peer group, where a peer group is a set of rows that are equivalent in the &lt;code&gt;ORDER BY&lt;/code&gt; ordering. (There must be an &lt;code&gt;ORDER BY&lt;/code&gt; clause in the window definition to use &lt;code&gt;GROUPS&lt;/code&gt; mode.)</source>
          <target state="translated">&lt;code&gt;GROUPS&lt;/code&gt; モード、 &lt;code&gt;offset&lt;/code&gt; 再び非ヌル、非負整数であり、オプション手段を得なければならないフレームの開始または終了の指定された数の&lt;em&gt;ピアグループの&lt;/em&gt;ピアグループが現在の行のピアグループ、前または後 &lt;code&gt;ORDER BY&lt;/code&gt; 順序付けで同等の行のセット。 （ &lt;code&gt;GROUPS&lt;/code&gt; モードを使用するには、ウィンドウ定義に &lt;code&gt;ORDER BY&lt;/code&gt; 句が必要です。）</target>
        </trans-unit>
        <trans-unit id="948c542b2b357818bb888566376ebb0a4005a123" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;RANGE&lt;/code&gt; mode, these options require that the &lt;code&gt;ORDER BY&lt;/code&gt; clause specify exactly one column. The &lt;code&gt;offset&lt;/code&gt; specifies the maximum difference between the value of that column in the current row and its value in preceding or following rows of the frame. The data type of the &lt;code&gt;offset&lt;/code&gt; expression varies depending on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an &lt;code&gt;interval&lt;/code&gt;. For example, if the ordering column is of type &lt;code&gt;date&lt;/code&gt; or &lt;code&gt;timestamp&lt;/code&gt;, one could write &lt;code&gt;RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING&lt;/code&gt;. The &lt;code&gt;offset&lt;/code&gt; is still required to be non-null and non-negative, though the meaning of &amp;ldquo;non-negative&amp;rdquo; depends on its data type.</source>
          <target state="translated">では &lt;code&gt;RANGE&lt;/code&gt; のモードでは、これらのオプションがあることが必要です &lt;code&gt;ORDER BY&lt;/code&gt; 句は、正確に1列を指定します。 &lt;code&gt;offset&lt;/code&gt; を指定し、現在の行のその列の値とフレームの行の前又は後に、その値の最大差。データ・タイプ &lt;code&gt;offset&lt;/code&gt; 発現は順序付け列のデータ・タイプに応じて変化します。数値の順序付け列の場合、これは通常、順序付け列と同じタイプですが、日時順序付け列の場合は、 &lt;code&gt;interval&lt;/code&gt; です。たとえば、順序付け列のタイプが &lt;code&gt;date&lt;/code&gt; または &lt;code&gt;timestamp&lt;/code&gt; 場合、 &lt;code&gt;RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING&lt;/code&gt; 記述できます。の &lt;code&gt;offset&lt;/code&gt; 「非負」の意味はそのデータ型に依存しますが、オフセットは引き続き非nullおよび非負である必要があります。</target>
        </trans-unit>
        <trans-unit id="1408d5e7e21bd209b1b9bfad149903cd4485729a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;RANGE&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode, a &lt;code&gt;frame_start&lt;/code&gt; of &lt;code&gt;CURRENT ROW&lt;/code&gt; means the frame starts with the current row's first &lt;em&gt;peer&lt;/em&gt; row (a row that the window's &lt;code&gt;ORDER BY&lt;/code&gt; clause sorts as equivalent to the current row), while a &lt;code&gt;frame_end&lt;/code&gt; of &lt;code&gt;CURRENT ROW&lt;/code&gt; means the frame ends with the current row's last peer row. In &lt;code&gt;ROWS&lt;/code&gt; mode, &lt;code&gt;CURRENT ROW&lt;/code&gt; simply means the current row.</source>
          <target state="translated">&lt;code&gt;RANGE&lt;/code&gt; または &lt;code&gt;GROUPS&lt;/code&gt; モード、 &lt;code&gt;frame_start&lt;/code&gt; の &lt;code&gt;CURRENT ROW&lt;/code&gt; 現在の行の最初のフレームの開始を意味する&lt;em&gt;ピア&lt;/em&gt;行（行ウィンドウのその &lt;code&gt;ORDER BY&lt;/code&gt; 現在の行に相当するような句のソート）しながら &lt;code&gt;frame_end&lt;/code&gt; の &lt;code&gt;CURRENT ROW&lt;/code&gt; フレームの終了を意味します現在の行の最後のピア行。 &lt;code&gt;ROWS&lt;/code&gt; モード、 &lt;code&gt;CURRENT ROW&lt;/code&gt; 単に現在の行を意味します。</target>
        </trans-unit>
        <trans-unit id="30675f2bd0c7573e3e074baf89463cecdcac064e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ROWS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; must yield a non-null, non-negative integer, and the option means that the frame starts or ends the specified number of rows before or after the current row.</source>
          <target state="translated">&lt;code&gt;ROWS&lt;/code&gt; モード、 &lt;code&gt;offset&lt;/code&gt; 非ヌル、非負整数を得なければならず、オプション手段そのフレームの開始または終了の行の指定された数の以前または現在の行の後。</target>
        </trans-unit>
        <trans-unit id="8f056c7130dbabcd038c08071d28f6253ddeb0d1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;array_position&lt;/code&gt; and &lt;code&gt;array_positions&lt;/code&gt;, each array element is compared to the searched value using &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; semantics.</source>
          <target state="translated">&lt;code&gt;array_position&lt;/code&gt; と &lt;code&gt;array_positions&lt;/code&gt; 使用して検索値が、各アレイ要素が比較され、 &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; 意味論。</target>
        </trans-unit>
        <trans-unit id="58eb966bf75cf56a14e39b6e0b483088ba13994e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;array_position&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt; is returned if the value is not found.</source>
          <target state="translated">で &lt;code&gt;array_position&lt;/code&gt; 、 &lt;code&gt;NULL&lt;/code&gt; は値が見つからない場合に返されます。</target>
        </trans-unit>
        <trans-unit id="6fb1576a237f50776165c9127d1d61a80997b7ea" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;array_positions&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt; is returned only if the array is &lt;code&gt;NULL&lt;/code&gt;; if the value is not found in the array, an empty array is returned instead.</source>
          <target state="translated">&lt;code&gt;array_positions&lt;/code&gt; 、 &lt;code&gt;NULL&lt;/code&gt; は、アレイがある場合にのみ戻される &lt;code&gt;NULL&lt;/code&gt; 。値が配列で見つからない場合は、代わりに空の配列が返されます。</target>
        </trans-unit>
        <trans-unit id="42867f00aff6799a35548d7b4a45bb429b8b6f41" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;encrypt_iv&lt;/code&gt; and &lt;code&gt;decrypt_iv&lt;/code&gt;, the &lt;em&gt;&lt;code&gt;iv&lt;/code&gt;&lt;/em&gt; parameter is the initial value for the CBC mode; it is ignored for ECB. It is clipped or padded with zeroes if not exactly block size. It defaults to all zeroes in the functions without this parameter.</source>
          <target state="translated">&lt;code&gt;encrypt_iv&lt;/code&gt; と &lt;code&gt;decrypt_iv&lt;/code&gt; 、&lt;em&gt; &lt;code&gt;iv&lt;/code&gt; &lt;/em&gt;パラメータはCBCモードの初期値です。ECBでは無視されます。正確にブロックサイズでない場合は、クリップされるか、ゼロが埋め込まれます。このパラメーターのない関数では、デフォルトですべてゼロになります。</target>
        </trans-unit>
        <trans-unit id="74b9c4f74b2383573102ae88dc002c3f78bfc6aa" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;init&lt;/code&gt; mode, this option analogously specifies the location of the &lt;code&gt;initdb&lt;/code&gt; executable.</source>
          <target state="translated">で &lt;code&gt;init&lt;/code&gt; モードでは、このオプションは同様の場所を指定 &lt;code&gt;initdb&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="4b893445cf37926dce5c6e98df69fc0726a60722" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latex-longtable&lt;/code&gt; format, this controls the proportional width of each column containing a left-aligned data type. It is specified as a whitespace-separated list of values, e.g. &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt;. Unspecified output columns use the last specified value.</source>
          <target state="translated">&lt;code&gt;latex-longtable&lt;/code&gt; 左揃えデータタイプを含む各列の形式、この制御は、比例幅。空白で区切られた値のリストとして指定されます（例： &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt; )。未指定の出力列は、最後に指定された値を使用します。</target>
        </trans-unit>
        <trans-unit id="9860fa02b7dab9c5038f80534079df8148445840" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;logical&lt;/code&gt; level, the same information is logged as with &lt;code&gt;replica&lt;/code&gt;, plus information needed to allow extracting logical change sets from the WAL. Using a level of &lt;code&gt;logical&lt;/code&gt; will increase the WAL volume, particularly if many tables are configured for &lt;code&gt;REPLICA IDENTITY FULL&lt;/code&gt; and many &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; statements are executed.</source>
          <target state="translated">&lt;code&gt;logical&lt;/code&gt; レベル、同一の情報を有するように記録され &lt;code&gt;replica&lt;/code&gt; 、プラス情報がWALから論理変更セットを抽出できるようにする必要がありました。 &lt;code&gt;logical&lt;/code&gt; レベルを使用すると、特に多くのテーブルが &lt;code&gt;REPLICA IDENTITY FULL&lt;/code&gt; 用に構成され、多くの &lt;code&gt;UPDATE&lt;/code&gt; および &lt;code&gt;DELETE&lt;/code&gt; ステートメントが実行される場合に、WALボリュームが増加します。</target>
        </trans-unit>
        <trans-unit id="19415b9e6aa0d531e04e643500bbdc24d23674cf" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;minimal&lt;/code&gt; level, WAL-logging of some bulk operations can be safely skipped, which can make those operations much faster (see &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;Section 14.4.7&lt;/a&gt;). Operations in which this optimization can be applied include:</source>
          <target state="translated">では &lt;code&gt;minimal&lt;/code&gt; レベル、いくつかの一括操作のWAL-ログは安全にはるかに高速にこれらの操作を行うことができ、スキップすることができます（&lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;セクション14.4.7を&lt;/a&gt;）。この最適化を適用できる操作は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="61bcfc364ae05487e8e54b4d5f3e06b75ec150ff" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;psql&lt;/code&gt;, you will be greeted with the following message:</source>
          <target state="translated">で &lt;code&gt;psql&lt;/code&gt; を、次のメッセージで迎えられるでしょう。</target>
        </trans-unit>
        <trans-unit id="d81bf71ad3ee9adb26530d123722b695887e96a2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;string_to_array&lt;/code&gt;, if the delimiter parameter is NULL, each character in the input string will become a separate element in the resulting array. If the delimiter is an empty string, then the entire input string is returned as a one-element array. Otherwise the input string is split at each occurrence of the delimiter string.</source>
          <target state="translated">で &lt;code&gt;string_to_array&lt;/code&gt; デリミタパラメータがNULLの場合、入力文字列の各文字は、結果の配列内の別の要素となるであろう。区切り文字が空の文字列の場合、入力文字列全体が1要素の配列として返されます。それ以外の場合、入力文字列は、区切り文字列が出現するたびに分割されます。</target>
        </trans-unit>
        <trans-unit id="ecd995c62df4a3324cc5c0dfdf5609bb28cc962a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;string_to_array&lt;/code&gt;, if the null-string parameter is omitted or NULL, none of the substrings of the input will be replaced by NULL. In &lt;code&gt;array_to_string&lt;/code&gt;, if the null-string parameter is omitted or NULL, any null elements in the array are simply skipped and not represented in the output string.</source>
          <target state="translated">で &lt;code&gt;string_to_array&lt;/code&gt; ヌル文字列パラメータを省略またはNULLである場合、入力のサブストリングのいずれもNULLで置き換えられません。で &lt;code&gt;array_to_string&lt;/code&gt; ヌル文字列パラメータを省略するかnullの場合、アレイ内の任意のヌル要素は、単にスキップされ、出力文字列で表されていません。</target>
        </trans-unit>
        <trans-unit id="b1222507b269ef568691d0a9d753a3eda5a5d8e5" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_number&lt;/code&gt;, if non-data template patterns such as &lt;code&gt;L&lt;/code&gt; or &lt;code&gt;TH&lt;/code&gt; are used, the corresponding number of input characters are skipped, whether or not they match the template pattern, unless they are data characters (that is, digits, sign, decimal point, or comma). For example, &lt;code&gt;TH&lt;/code&gt; would skip two non-data characters.</source>
          <target state="translated">&lt;code&gt;to_number&lt;/code&gt; などの非データ・テンプレート・パターン場合、 &lt;code&gt;L&lt;/code&gt; または &lt;code&gt;TH&lt;/code&gt; が使用されている、入力文字の対応する数は、彼らがデータ文字（ある、数字、記号、小数点がある場合を除き、彼らは、テンプレートパターンに一致するか否か、スキップされます、またはカンマ）。たとえば、 &lt;code&gt;TH&lt;/code&gt; は2つの非データ文字をスキップします。</target>
        </trans-unit>
        <trans-unit id="da01a26180a4b78ca506a4e26d673346bc64efee" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, an ISO 8601 week-numbering date (as distinct from a Gregorian date) can be specified in one of two ways:</source>
          <target state="translated">&lt;code&gt;to_timestamp&lt;/code&gt; と &lt;code&gt;to_date&lt;/code&gt; 、（グレゴリオ日付異なる）ISO 8601週番号日付は、2つの方法のいずれかで指定することができます。</target>
        </trans-unit>
        <trans-unit id="f9d931e068d7388b5b9791ba73a39ccc4330b961" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, if the year format specification is less than four digits, e.g. &lt;code&gt;YYY&lt;/code&gt;, and the supplied year is less than four digits, the year will be adjusted to be nearest to the year 2020, e.g. &lt;code&gt;95&lt;/code&gt; becomes 1995.</source>
          <target state="translated">で &lt;code&gt;to_timestamp&lt;/code&gt; と &lt;code&gt;to_date&lt;/code&gt; 年フォーマット仕様は、以下4桁、例えばよりもされている場合、 &lt;code&gt;YYY&lt;/code&gt; 、および指定された年未満4桁で、今年は2020年に最も近くなるように調整され、例えば &lt;code&gt;95&lt;/code&gt; は 1995となります。</target>
        </trans-unit>
        <trans-unit id="4dcc47dcfb30c72df039620b4818cb5cae63885b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, the &lt;code&gt;CC&lt;/code&gt; (century) field is accepted but ignored if there is a &lt;code&gt;YYY&lt;/code&gt;, &lt;code&gt;YYYY&lt;/code&gt; or &lt;code&gt;Y,YYY&lt;/code&gt; field. If &lt;code&gt;CC&lt;/code&gt; is used with &lt;code&gt;YY&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt; then the result is computed as that year in the specified century. If the century is specified but the year is not, the first year of the century is assumed.</source>
          <target state="translated">で &lt;code&gt;to_timestamp&lt;/code&gt; と &lt;code&gt;to_date&lt;/code&gt; 、 &lt;code&gt;CC&lt;/code&gt; （世紀）フィールドは受け入れられますが存在する場合には無視され &lt;code&gt;YYY&lt;/code&gt; 、 &lt;code&gt;YYYY&lt;/code&gt; または &lt;code&gt;Y,YYY&lt;/code&gt; フィールド。 &lt;code&gt;CC&lt;/code&gt; が &lt;code&gt;YY&lt;/code&gt; または &lt;code&gt;Y&lt;/code&gt; と共に使用される場合、結果は指定された世紀のその年として計算されます。世紀が指定されているが年が指定されていない場合、世紀の最初の年が想定されます。</target>
        </trans-unit>
        <trans-unit id="34928f49bb5512bad729a0eba587c351c3b66a70" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, the &lt;code&gt;YYYY&lt;/code&gt; conversion has a restriction when processing years with more than 4 digits. You must use some non-digit character or template after &lt;code&gt;YYYY&lt;/code&gt;, otherwise the year is always interpreted as 4 digits. For example (with the year 20000): &lt;code&gt;to_date('200001131', 'YYYYMMDD')&lt;/code&gt; will be interpreted as a 4-digit year; instead use a non-digit separator after the year, like &lt;code&gt;to_date('20000-1131', 'YYYY-MMDD')&lt;/code&gt; or &lt;code&gt;to_date('20000Nov31', 'YYYYMonDD')&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;to_timestamp&lt;/code&gt; と &lt;code&gt;to_date&lt;/code&gt; 、 &lt;code&gt;YYYY&lt;/code&gt; の変換は4つの以上の桁で年間処理制限を有します。 &lt;code&gt;YYYY&lt;/code&gt; の後に数字以外の文字またはテンプレートを使用する必要があります。そうしないと、年は常に4桁として解釈されます。たとえば（年20000の場合）： &lt;code&gt;to_date('200001131', 'YYYYMMDD')&lt;/code&gt; は4桁の年として解釈されます。代わりに、 &lt;code&gt;to_date('20000-1131', 'YYYY-MMDD')&lt;/code&gt; または &lt;code&gt;to_date('20000Nov31', 'YYYYMonDD')&lt;/code&gt; ように、年の後に数字以外の区切り文字を使用してください。</target>
        </trans-unit>
        <trans-unit id="544ec57993b0d566b29bfdeb2a8cf47932beafef" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, weekday names or numbers (&lt;code&gt;DAY&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, and related field types) are accepted but are ignored for purposes of computing the result. The same is true for quarter (&lt;code&gt;Q&lt;/code&gt;) fields.</source>
          <target state="translated">&lt;code&gt;to_timestamp&lt;/code&gt; と &lt;code&gt;to_date&lt;/code&gt; 、曜日の名前または番号（ &lt;code&gt;DAY&lt;/code&gt; 、 &lt;code&gt;D&lt;/code&gt; 、および関連するフィールドタイプ）が受け入れられるが、結果を計算する目的のために無視されます。同じことが四半期（ &lt;code&gt;Q&lt;/code&gt; ）フィールドにも当てはまります。</target>
        </trans-unit>
        <trans-unit id="8902e096eb8211a3103ef8a03507a1e1c0b7839c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt;, millisecond (&lt;code&gt;MS&lt;/code&gt;) or microsecond (&lt;code&gt;US&lt;/code&gt;) fields are used as the seconds digits after the decimal point. For example &lt;code&gt;to_timestamp('12.3', 'SS.MS')&lt;/code&gt; is not 3 milliseconds, but 300, because the conversion treats it as 12 + 0.3 seconds. So, for the format &lt;code&gt;SS.MS&lt;/code&gt;, the input values &lt;code&gt;12.3&lt;/code&gt;, &lt;code&gt;12.30&lt;/code&gt;, and &lt;code&gt;12.300&lt;/code&gt; specify the same number of milliseconds. To get three milliseconds, one must write &lt;code&gt;12.003&lt;/code&gt;, which the conversion treats as 12 + 0.003 = 12.003 seconds.</source>
          <target state="translated">で &lt;code&gt;to_timestamp&lt;/code&gt; 、ミリ秒（ &lt;code&gt;MS&lt;/code&gt; ）またはマイクロ秒（ &lt;code&gt;US&lt;/code&gt; ）のフィールドは、小数点の後の秒桁として使用されています。たとえば、 &lt;code&gt;to_timestamp('12.3', 'SS.MS')&lt;/code&gt; は3ミリ秒ではなく300です。これは、変換で12 + 0.3秒として扱われるためです。だから、フォーマットのため &lt;code&gt;SS.MS&lt;/code&gt; 、入力値 &lt;code&gt;12.3&lt;/code&gt; 、 &lt;code&gt;12.30&lt;/code&gt; 、および &lt;code&gt;12.300&lt;/code&gt; は、ミリ秒単位の同じ数を指定します。 3ミリ秒を取得するには、 &lt;code&gt;12.003&lt;/code&gt; を書き込む必要があります。変換では、12 + 0.003 = 12.003秒として処理されます。</target>
        </trans-unit>
        <trans-unit id="64a9c48229747c676385712712a92e7a02f4a20e" translate="yes" xml:space="preserve">
          <source>In AREs, &lt;code&gt;\&lt;/code&gt; followed by an alphanumeric character is either an escape or an error, while in previous releases, it was just another way of writing the alphanumeric. This should not be much of a problem because there was no reason to write such a sequence in earlier releases.</source>
          <target state="translated">AREでは、 &lt;code&gt;\&lt;/code&gt; の後に英数字が続くものはエスケープまたはエラーのいずれかですが、以前のリリースでは、これは英数字を記述するもう1つの方法でした。以前のリリースではそのようなシーケンスを記述する理由がなかったため、これはそれほど問題にはなりません。</target>
        </trans-unit>
        <trans-unit id="9fd039b2f7ce31cb27cef33f4f533a9fac0c1fbd" translate="yes" xml:space="preserve">
          <source>In AREs, &lt;code&gt;\&lt;/code&gt; remains a special character within &lt;code&gt;[]&lt;/code&gt;, so a literal &lt;code&gt;\&lt;/code&gt; within a bracket expression must be written &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="translated">AREでは、 &lt;code&gt;\&lt;/code&gt; は &lt;code&gt;[]&lt;/code&gt; 内の特殊文字のままであるため、ブラケット式内のリテラル &lt;code&gt;\&lt;/code&gt; は &lt;code&gt;\\&lt;/code&gt; と記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="cb3ffc95899379ce4e17b50af19efa046a482415" translate="yes" xml:space="preserve">
          <source>In HTML format, this specifies attributes to be placed inside the &lt;code&gt;table&lt;/code&gt; tag. This could for example be &lt;code&gt;cellpadding&lt;/code&gt; or &lt;code&gt;bgcolor&lt;/code&gt;. Note that you probably don't want to specify &lt;code&gt;border&lt;/code&gt; here, as that is already taken care of by &lt;code&gt;\pset border&lt;/code&gt;. If no &lt;code&gt;value&lt;/code&gt; is given, the table attributes are unset.</source>
          <target state="translated">HTML形式では、 &lt;code&gt;table&lt;/code&gt; タグ内に配置する属性を指定します。たとえば、これは &lt;code&gt;cellpadding&lt;/code&gt; や &lt;code&gt;bgcolor&lt;/code&gt; です。 &lt;code&gt;\pset border&lt;/code&gt; によって既に処理されているので、おそらくここで &lt;code&gt;border&lt;/code&gt; を指定したくないことに注意してください。 &lt;code&gt;value&lt;/code&gt; を指定しない場合、テーブル属性は設定されません。</target>
        </trans-unit>
        <trans-unit id="814a324a3771e36f5c269dff83adcdc2f6482fa5" translate="yes" xml:space="preserve">
          <source>In Linux 2.4 and later, the default virtual memory behavior is not optimal for PostgreSQL. Because of the way that the kernel implements memory overcommit, the kernel might terminate the PostgreSQL postmaster (the master server process) if the memory demands of either PostgreSQL or another process cause the system to run out of virtual memory.</source>
          <target state="translated">Linux 2.4以降では、デフォルトの仮想メモリの動作はPostgreSQLに最適ではありません。カーネルがメモリオーバーコミットを実装する方法のため、PostgreSQLまたは他のプロセスのメモリ要求によりシステムが仮想メモリを使い果たした場合、カーネルはPostgreSQLのポストマスタ(マスタサーバプロセス)を終了させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="f9db993d9ed52b850a8119db5ab8d068b60a0509" translate="yes" xml:space="preserve">
          <source>In NetBSD 5.0 and later, IPC parameters can be adjusted using &lt;code&gt;sysctl&lt;/code&gt;, for example:</source>
          <target state="translated">NetBSD 5.0以降では、次のように &lt;code&gt;sysctl&lt;/code&gt; を使用してIPCパラメーターを調整できます。</target>
        </trans-unit>
        <trans-unit id="33cf5a32119e2012e85b594bd01ed746ff893ad5" translate="yes" xml:space="preserve">
          <source>In OpenBSD 3.3 and later, IPC parameters can be adjusted using &lt;code&gt;sysctl&lt;/code&gt;, for example:</source>
          <target state="translated">OpenBSD 3.3以降では、次のように &lt;code&gt;sysctl&lt;/code&gt; を使用してIPCパラメータを調整できます。</target>
        </trans-unit>
        <trans-unit id="d469c640f950b7673c7ae58a9ecc0f315265b7c1" translate="yes" xml:space="preserve">
          <source>In PostgreSQL releases prior to 9.0, large objects did not have access privileges and were, therefore, always readable and writable by all users. Setting this variable to &lt;code&gt;on&lt;/code&gt; disables the new privilege checks, for compatibility with prior releases. The default is &lt;code&gt;off&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">9.0より前のPostgreSQLリリースでは、ラージオブジェクトにはアクセス権限がなかったため、すべてのユーザーが常に読み取りと書き込みが可能でした。この変数を &lt;code&gt;on&lt;/code&gt; に設定すると、以前のリリースとの互換性のために、新しい特権チェックが無効になります。デフォルトは &lt;code&gt;off&lt;/code&gt; です。この設定を変更できるのはスーパーユーザーだけです。</target>
        </trans-unit>
        <trans-unit id="22cd8a67509e8ca7db080a3ecd0b854c45395a98" translate="yes" xml:space="preserve">
          <source>In PostgreSQL releases prior to 9.3, &lt;code&gt;commit_delay&lt;/code&gt; behaved differently and was much less effective: it affected only commits, rather than all WAL flushes, and waited for the entire configured delay even if the WAL flush was completed sooner. Beginning in PostgreSQL 9.3, the first process that becomes ready to flush waits for the configured interval, while subsequent processes wait only until the leader completes the flush operation.</source>
          <target state="translated">9.3より前のPostgreSQLリリースでは、 &lt;code&gt;commit_delay&lt;/code&gt; の動作が異なり、効果がはるかに低かった。すべてのWALフラッシュではなく、コミットのみに影響し、WALフラッシュがより早く完了した場合でも、設定された遅延全体を待機した。PostgreSQL 9.3以降、フラッシュの準備ができた最初のプロセスは、設定された間隔だけ待機しますが、後続のプロセスは、リーダーがフラッシュ操作を完了するまで待機します。</target>
        </trans-unit>
        <trans-unit id="b3a09d320c0eb1af5ebf6fc539b70645d7fbc828" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions 8.0 through 8.2, the effects of a &lt;code&gt;SET LOCAL&lt;/code&gt; would be canceled by releasing an earlier savepoint, or by successful exit from a PL/pgSQL exception block. This behavior has been changed because it was deemed unintuitive.</source>
          <target state="translated">PostgreSQLバージョン8.0〜8.2では、以前のセーブポイントを解放するか、PL / pgSQL例外ブロックを正常に終了することにより、 &lt;code&gt;SET LOCAL&lt;/code&gt; の影響が取り消されます。この動作は、直感的でないと見なされたため変更されました。</target>
        </trans-unit>
        <trans-unit id="a2a2f1f614c98ca12a5b32b40e076079264d9c76" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 7.3, it was customary to avoid creating a shell type at all, by replacing the functions' forward references to the type name with the placeholder pseudo-type &lt;code&gt;opaque&lt;/code&gt;. The &lt;code&gt;cstring&lt;/code&gt; arguments and results also had to be declared as &lt;code&gt;opaque&lt;/code&gt; before 7.3. To support loading of old dump files, &lt;code&gt;CREATE TYPE&lt;/code&gt; will accept I/O functions declared using &lt;code&gt;opaque&lt;/code&gt;, but it will issue a notice and change the function declarations to use the correct types.</source>
          <target state="translated">7.3より前のバージョンのPostgreSQLでは、型名への関数の前方参照をプレースホルダーの疑似型 &lt;code&gt;opaque&lt;/code&gt; に置き換えることで、シェル型の作成をまったく回避するのが慣習でした。 &lt;code&gt;cstring&lt;/code&gt; 引数と結果もとして宣言されなければならなかった &lt;code&gt;opaque&lt;/code&gt; 7.3の前に。古いダンプファイルのロードをサポートするために、 &lt;code&gt;CREATE TYPE&lt;/code&gt; は &lt;code&gt;opaque&lt;/code&gt; を使用して宣言されたI / O関数を受け入れますが、通知を発行し、関数の宣言を変更して正しい型を使用します。</target>
        </trans-unit>
        <trans-unit id="b355acb666b0ad4cd57d90f2927cbffb2b6ed9ef" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 7.3, it was necessary to declare handler functions as returning the placeholder type &lt;code&gt;opaque&lt;/code&gt;, rather than &lt;code&gt;language_handler&lt;/code&gt;. To support loading of old dump files, &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; will accept a function declared as returning &lt;code&gt;opaque&lt;/code&gt;, but it will issue a notice and change the function's declared return type to &lt;code&gt;language_handler&lt;/code&gt;.</source>
          <target state="translated">7.3より前のバージョンのPostgreSQLでは、ハンドラー関数を、 &lt;code&gt;language_handler&lt;/code&gt; ではなく、プレースホルダータイプ &lt;code&gt;opaque&lt;/code&gt; を返すものとして宣言する必要がありました。古いダンプファイルのロードをサポートするために、 &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; は &lt;code&gt;opaque&lt;/code&gt; を返すと宣言された関数を受け入れますが、通知を発行し、関数の宣言された戻り値の型を &lt;code&gt;language_handler&lt;/code&gt; に変更します。</target>
        </trans-unit>
        <trans-unit id="c16c4aa970c78b968d9f432a8088edb5d24051d5" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 7.3, it was necessary to declare trigger functions as returning the placeholder type &lt;code&gt;opaque&lt;/code&gt;, rather than &lt;code&gt;trigger&lt;/code&gt;. To support loading of old dump files, &lt;code&gt;CREATE TRIGGER&lt;/code&gt; will accept a function declared as returning &lt;code&gt;opaque&lt;/code&gt;, but it will issue a notice and change the function's declared return type to &lt;code&gt;trigger&lt;/code&gt;.</source>
          <target state="translated">7.3より前のバージョンのPostgreSQL では、 &lt;code&gt;trigger&lt;/code&gt; ではなく、プレースホルダー型 &lt;code&gt;opaque&lt;/code&gt; を返すようにトリガー関数を宣言する必要がありました。古いダンプファイルのロードをサポートするために、 &lt;code&gt;CREATE TRIGGER&lt;/code&gt; は &lt;code&gt;opaque&lt;/code&gt; を返すと宣言された関数を受け入れますが、通知を発行し、関数の宣言された戻り値の型を &lt;code&gt;trigger&lt;/code&gt; に変更します。</target>
        </trans-unit>
        <trans-unit id="3c68aa880bfe2dcd90559cbb12f6681d9282ddb1" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 9.4, freezing was implemented by actually replacing a row's insertion XID with &lt;code&gt;FrozenTransactionId&lt;/code&gt;, which was visible in the row's &lt;code&gt;xmin&lt;/code&gt; system column. Newer versions just set a flag bit, preserving the row's original &lt;code&gt;xmin&lt;/code&gt; for possible forensic use. However, rows with &lt;code&gt;xmin&lt;/code&gt; equal to &lt;code&gt;FrozenTransactionId&lt;/code&gt; (2) may still be found in databases pg_upgrade'd from pre-9.4 versions.</source>
          <target state="translated">9.4より前のバージョンのPostgreSQLでは、行の挿入XIDを行の &lt;code&gt;xmin&lt;/code&gt; システム列に表示されていた &lt;code&gt;FrozenTransactionId&lt;/code&gt; に実際に置き換えることにより、フリーズが実装されました。新しいバージョンでは、フラグビットを設定するだけで、行の元の &lt;code&gt;xmin&lt;/code&gt; を法医学的な使用のために保持します。ただし、 &lt;code&gt;xmin&lt;/code&gt; が &lt;code&gt;FrozenTransactionId&lt;/code&gt; （2）に等しい行は、9.4より前のバージョンからpg_upgradeされたデータベースでまだ見つかる可能性があります。</target>
        </trans-unit>
        <trans-unit id="eadad43cc831b2ff40334680f58601d4f7a10c43" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a reference to a table name (or alias) in a query is effectively a reference to the composite value of the table's current row. For example, if we had a table &lt;code&gt;inventory_item&lt;/code&gt; as shown &lt;a href=&quot;rowtypes#ROWTYPES-DECLARING&quot;&gt;above&lt;/a&gt;, we could write:</source>
          <target state="translated">PostgreSQLでは、クエリ内のテーブル名（またはエイリアス）への参照は、事実上、テーブルの現在の行の複合値への参照です。たとえば、&lt;a href=&quot;rowtypes#ROWTYPES-DECLARING&quot;&gt;上記の&lt;/a&gt;表の &lt;code&gt;inventory_item&lt;/code&gt; がある場合、次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="4a86fbee986217732dc6e120d53c8e8d4a6c9100" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a table can inherit from zero or more other tables, and a query can reference either all rows of a table or all rows of a table plus all of its descendant tables. The latter behavior is the default. For example, the following query finds the names of all cities, including state capitals, that are located at an altitude over 500 feet:</source>
          <target state="translated">PostgreSQLでは、テーブルは0個以上の他のテーブルを継承することができ、問い合わせはテーブルの全行を参照するか、テーブルの全行とその子孫テーブルの全行のいずれかを参照することができます。後者の動作がデフォルトです。例えば、以下のクエリは、州都を含む、標高500フィート以上の場所にあるすべての都市の名前を検索します。</target>
        </trans-unit>
        <trans-unit id="74efdce9636de27e76a8b8265ce6cb497dd89fdf" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a transaction is set up by surrounding the SQL commands of the transaction with &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;COMMIT&lt;/code&gt; commands. So our banking transaction would actually look like:</source>
          <target state="translated">PostgreSQLでは、トランザクションは、トランザクションのSQLコマンドを &lt;code&gt;BEGIN&lt;/code&gt; コマンドと &lt;code&gt;COMMIT&lt;/code&gt; コマンドで囲むことによって設定されます。したがって、銀行取引は実際には次のようになります。</target>
        </trans-unit>
        <trans-unit id="ba3eb2b425968ebc072af7dd5475bc71e9126bfd" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; of a row does not immediately remove the old version of the row. This approach is necessary to gain the benefits of multiversion concurrency control (MVCC, see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;): the row version must not be deleted while it is still potentially visible to other transactions. But eventually, an outdated or deleted row version is no longer of interest to any transaction. The space it occupies must then be reclaimed for reuse by new rows, to avoid unbounded growth of disk space requirements. This is done by running &lt;code&gt;VACUUM&lt;/code&gt;.</source>
          <target state="translated">PostgreSQLでは、行の &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; で古いバージョンの行がすぐに削除されるわけではありません。このアプローチは、マルチバージョン同時実行制御（MVCC、&lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;第13章を&lt;/a&gt;参照）の利点を得るのに必要です。行バージョンは、他のトランザクションから見えている間は削除しないでください。ただし、最終的には、古いバージョンまたは削除された行のバージョンは、どのトランザクションにとっても関心がなくなります。次に、ディスク領域の要件が無制限に増大するのを防ぐために、それが占める領域を再利用して新しい行で再利用する必要があります。これは &lt;code&gt;VACUUM&lt;/code&gt; を実行することによって行われます。</target>
        </trans-unit>
        <trans-unit id="bbda6fce7f63ccb95f1398e8c5c8a9c6bb83f492" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, you can request any of the four standard transaction isolation levels, but internally only three distinct isolation levels are implemented, i.e. PostgreSQL's Read Uncommitted mode behaves like Read Committed. This is because it is the only sensible way to map the standard isolation levels to PostgreSQL's multiversion concurrency control architecture.</source>
          <target state="translated">PostgreSQLでは、4つの標準トランザクション分離レベルのいずれかを要求することができますが、内部的には3つの異なる分離レベルしか実装されていません。これは、標準の分離レベルをPostgreSQLの多バージョン同時実行制御アーキテクチャにマッピングする唯一の賢明な方法だからです。</target>
        </trans-unit>
        <trans-unit id="759eb406805a5a1c000f22431f41b882c8790352" translate="yes" xml:space="preserve">
          <source>In SCRAM without channel binding, the server chooses a random number that is transmitted to the client to be mixed with the user-supplied password in the transmitted password hash. While this prevents the password hash from being successfully retransmitted in a later session, it does not prevent a fake server between the real server and client from passing through the server's random value and successfully authenticating.</source>
          <target state="translated">チャネルバインディングのないSCRAMでは、サーバはクライアントに送信される乱数を選択して、送信されるパスワードハッシュの中でユーザが提供したパスワードと混合します。これにより、後のセッションでパスワードハッシュが正常に再送されることを防ぐことができますが、本物のサーバとクライアントの間の偽サーバがサーバの乱数値を通過して認証に成功することを防ぐことはできません。</target>
        </trans-unit>
        <trans-unit id="bbe3d8277f59658a3be0c65846387947fe489961" translate="yes" xml:space="preserve">
          <source>In SQL:2006 and later, both directions of conversion between standard SQL data types and the XML Schema types are specified precisely. However, the rules are expressed using the types and semantics of XQuery/XPath, and have no direct application to the different data model of XPath 1.0.</source>
          <target state="translated">SQL:2006 以降では、標準 SQL データ型と XML スキーマ型の間の変換の両方向が正確に規定されています。ただし、このルールはXQuery/XPathの型とセマンティクスを使って表現されており、XPath 1.0の異なるデータモデルに直接適用されるものではありません。</target>
        </trans-unit>
        <trans-unit id="1cddd15d85853fd05a956af5b4c400072d8cd616" translate="yes" xml:space="preserve">
          <source>In Solaris 10 and later, and OpenSolaris, the default shared memory and semaphore settings are good enough for most PostgreSQL applications. Solaris now defaults to a &lt;code&gt;SHMMAX&lt;/code&gt; of one-quarter of system RAM. To further adjust this setting, use a project setting associated with the &lt;code&gt;postgres&lt;/code&gt; user. For example, run the following as &lt;code&gt;root&lt;/code&gt;:</source>
          <target state="translated">Solaris 10以降とOpenSolarisでは、デフォルトの共有メモリとセマフォの設定で、ほとんどのPostgreSQLアプリケーションに十分対応できます。 Solarisのデフォルトは、システムRAMの4分の1の &lt;code&gt;SHMMAX&lt;/code&gt; です。この設定をさらに調整するには、 &lt;code&gt;postgres&lt;/code&gt; ユーザーに関連付けられたプロジェクト設定を使用します。たとえば、 &lt;code&gt;root&lt;/code&gt; として以下を実行します。</target>
        </trans-unit>
        <trans-unit id="f2711fad286d67111c91bf5304258de9bff55609" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;BEFORE&lt;/code&gt; trigger, the &lt;code&gt;WHEN&lt;/code&gt; condition is evaluated just before the function is or would be executed, so using &lt;code&gt;WHEN&lt;/code&gt; is not materially different from testing the same condition at the beginning of the trigger function. Note in particular that the &lt;code&gt;NEW&lt;/code&gt; row seen by the condition is the current value, as possibly modified by earlier triggers. Also, a &lt;code&gt;BEFORE&lt;/code&gt; trigger's &lt;code&gt;WHEN&lt;/code&gt; condition is not allowed to examine the system columns of the &lt;code&gt;NEW&lt;/code&gt; row (such as &lt;code&gt;ctid&lt;/code&gt;), because those won't have been set yet.</source>
          <target state="translated">で &lt;code&gt;BEFORE&lt;/code&gt; トリガー、 &lt;code&gt;WHEN&lt;/code&gt; 条件は関数であるか、そう使用して実行される直前に評価される &lt;code&gt;WHEN&lt;/code&gt; トリガ機能の開始時に同じ条件をテストすると著しく異なりません。特に、条件によって表示される &lt;code&gt;NEW&lt;/code&gt; 行は現在の値であり、以前のトリガーによって変更された可能性があることに注意してください。また、 &lt;code&gt;BEFORE&lt;/code&gt; トリガーの &lt;code&gt;WHEN&lt;/code&gt; 条件では、まだ設定されていないため、 &lt;code&gt;NEW&lt;/code&gt; 行のシステム列（ &lt;code&gt;ctid&lt;/code&gt; など）を調べることはできません。</target>
        </trans-unit>
        <trans-unit id="9ce810944c17541339c741b40b793201537de044" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;DELETE&lt;/code&gt;, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the content of the deleted row. For example:</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; 、に利用可能なデータ &lt;code&gt;RETURNING&lt;/code&gt; は、削除された行の内容です。例えば：</target>
        </trans-unit>
        <trans-unit id="0d3bf14e9dc0493ac82721df4faae7ba81c88992" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;DROP FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support must be specified.</source>
          <target state="translated">&lt;code&gt;DROP FUNCTION&lt;/code&gt; 句、オペランド・データ・タイプ（複数可）機能をサポートすることを意図されている指定されなければなりません。</target>
        </trans-unit>
        <trans-unit id="85532f42163c3739d7f5a6244714ead077b8baea" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function (for B-tree comparison functions and hash functions) or the class's data type (for B-tree sort support functions and all functions in GiST, SP-GiST, GIN and BRIN operator classes). These defaults are correct, and so &lt;code&gt;op_type&lt;/code&gt; need not be specified in &lt;code&gt;FUNCTION&lt;/code&gt; clauses, except for the case of a B-tree sort support function that is meant to support cross-data-type comparisons.</source>
          <target state="translated">&lt;code&gt;FUNCTION&lt;/code&gt; 句、オペランド・データ・タイプ（複数可）関数をサポートすることを意図されている、のための（（Bツリー比較関数及びハッシュ関数の）関数の入力データ型（S）またはクラスのデータ・タイプと異なる場合Bツリーソートサポート関数およびGiST、SP-GiST、GIN、BRIN演算子クラスのすべての関数）。これらのデフォルトは正しいため、データ型間の比較をサポートするためのBツリーソートサポート関数の場合を除いて、 &lt;code&gt;FUNCTION&lt;/code&gt; 句で &lt;code&gt;op_type&lt;/code&gt; を指定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="6f9bb9a1e74c73e631d5463da369a9644506e4f0" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;SELECT&lt;/code&gt; command, these two policies are combined using &lt;code&gt;OR&lt;/code&gt;, with the net effect being that all rows can be selected. In other command types, only the second policy applies, so that the effects are the same as before.</source>
          <target state="translated">では &lt;code&gt;SELECT&lt;/code&gt; コマンドは、これら2つのポリシーを使用して結合されている &lt;code&gt;OR&lt;/code&gt; 、正味の効果は、すべての行を選択することができていると。他のコマンドタイプでは、2番目のポリシーのみが適用されるため、効果は以前と同じです。</target>
        </trans-unit>
        <trans-unit id="300ce212406203fa6b094fb383bde2b25f44a159" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;pg_hba.conf&lt;/code&gt; record specifying certificate authentication, the authentication option &lt;code&gt;clientcert&lt;/code&gt; is assumed to be &lt;code&gt;verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt;, and it cannot be turned off since a client certificate is necessary for this method. What the &lt;code&gt;cert&lt;/code&gt; method adds to the basic &lt;code&gt;clientcert&lt;/code&gt; certificate validity test is a check that the &lt;code&gt;cn&lt;/code&gt; attribute matches the database user name.</source>
          <target state="translated">証明書認証を指定する &lt;code&gt;pg_hba.conf&lt;/code&gt; レコードでは、認証オプション &lt;code&gt;clientcert&lt;/code&gt; は &lt;code&gt;verify-ca&lt;/code&gt; または &lt;code&gt;verify-full&lt;/code&gt; であると想定されており、このメソッドにはクライアント証明書が必要なのでオフにすることはできません。どのような &lt;code&gt;cert&lt;/code&gt; 方法は、基本的に追加 &lt;code&gt;clientcert&lt;/code&gt; 証明書の有効性をテストすると、そのチェックです &lt;code&gt;cn&lt;/code&gt; 属性は、データベースのユーザー名と一致します。</target>
        </trans-unit>
        <trans-unit id="f05e815aa51edd32e8f243de544f1a7fed6f4907" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;to_char&lt;/code&gt; output template string, there are certain patterns that are recognized and replaced with appropriately-formatted data based on the given value. Any text that is not a template pattern is simply copied verbatim. Similarly, in an input template string (for the other functions), template patterns identify the values to be supplied by the input data string. If there are characters in the template string that are not template patterns, the corresponding characters in the input data string are simply skipped over (whether or not they are equal to the template string characters).</source>
          <target state="translated">で &lt;code&gt;to_char&lt;/code&gt; 出力テンプレート文字列、認識及び所定の値に基づいて、適切にフォーマットされたデータで置き換えられる特定のパターンがあります。テンプレートパターンではないテキストは、そのままそのままコピーされます。同様に、（他の関数の）入力テンプレート文字列では、テンプレートパターンは入力データ文字列によって提供される値を識別します。テンプレートパターンではない文字がテンプレート文字列にある場合、入力データ文字列の対応する文字は（テンプレート文字列の文字と等しいかどうかに関係なく）単にスキップされます。</target>
        </trans-unit>
        <trans-unit id="78e3bba2064f9d9c2fee2733a54ca75d990eba66" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;hash join&lt;/em&gt; (without the &quot;parallel&quot; prefix), the inner side is executed in full by every cooperating process to build identical copies of the hash table. This may be inefficient if the hash table is large or the plan is expensive. In a &lt;em&gt;parallel hash join&lt;/em&gt;, the inner side is a &lt;em&gt;parallel hash&lt;/em&gt; that divides the work of building a shared hash table over the cooperating processes.</source>
          <target state="translated">&lt;em&gt;ハッシュジョイン&lt;/em&gt;（「平行」接頭辞なし）、内側には、ハッシュテーブルの同一のコピーを構築するためにすべての協働プロセスによって完全に実行されます。これは、ハッシュテーブルが大きい場合、または計画が高額な場合に非効率的です。&lt;em&gt;並列ハッシュジョイン&lt;/em&gt;、内部側は&lt;em&gt;並列ハッシュ&lt;/em&gt;協働プロセスを介して共有ハッシュテーブルを構築する作業を分割します。</target>
        </trans-unit>
        <trans-unit id="3480286d445961d6181c445c4ffd40322b928fd9" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;merge join&lt;/em&gt;, the inner side is always a non-parallel plan and therefore executed in full. This may be inefficient, especially if a sort must be performed, because the work and resulting data are duplicated in every cooperating process.</source>
          <target state="translated">&lt;em&gt;マージジョイン&lt;/em&gt;、内側が常に非平行平面であるため、完全に実行されます。これは、特にソートを実行する必要がある場合、作業と結果のデータがすべての協調プロセスで複製されるため、非効率的です。</target>
        </trans-unit>
        <trans-unit id="400e7c200fdc3546ddf00f5c7ed10cb2ab42e4c0" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;nested loop join&lt;/em&gt;, the inner side is always non-parallel. Although it is executed in full, this is efficient if the inner side is an index scan, because the outer tuples and thus the loops that look up values in the index are divided over the cooperating processes.</source>
          <target state="translated">&lt;em&gt;ネストされたループ結合&lt;/em&gt;、内側が常に非平行です。これは完全に実行されますが、内部がインデックススキャンの場合は効率的です。これは、外部タプル、つまりインデックス内の値を検索するループが協調プロセスに分割されるためです。</target>
        </trans-unit>
        <trans-unit id="dea6a7ade41e8f01fb686c080220d4159b567183" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel bitmap heap scan&lt;/em&gt;, one process is chosen as the leader. That process performs a scan of one or more indexes and builds a bitmap indicating which table blocks need to be visited. These blocks are then divided among the cooperating processes as in a parallel sequential scan. In other words, the heap scan is performed in parallel, but the underlying index scan is not.</source>
          <target state="translated">では&lt;em&gt;、並列ビットマップヒープスキャン&lt;/em&gt;、一つのプロセスは、リーダーとして選ばれます。そのプロセスは、1つ以上のインデックスのスキャンを実行し、どのテーブルブロックにアクセスする必要があるかを示すビットマップを作成します。これらのブロックは、並列順次スキャンの場合と同様に、連携するプロセス間で分割されます。つまり、ヒープスキャンは並列に実行されますが、基になるインデックススキャンは実行されません。</target>
        </trans-unit>
        <trans-unit id="8227deba10aefb19ed8caa11f69ff745de460ae7" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel index scan&lt;/em&gt; or &lt;em&gt;parallel index-only scan&lt;/em&gt;, the cooperating processes take turns reading data from the index. Currently, parallel index scans are supported only for btree indexes. Each process will claim a single index block and will scan and return all tuples referenced by that block; other process can at the same time be returning tuples from a different index block. The results of a parallel btree scan are returned in sorted order within each worker process.</source>
          <target state="translated">&lt;em&gt;並列索引スキャン&lt;/em&gt;または&lt;em&gt;並列インデックスのみスキャン&lt;/em&gt;、協働プロセスは、インデックスからデータを読み出す交代します。現在、並列インデックススキャンはbtreeインデックスでのみサポートされています。各プロセスは単一のインデックスブロックを要求し、そのブロックによって参照されるすべてのタプルをスキャンして返します。他のプロセスが同時に別のインデックスブロックからタプルを返す可能性があります。並列btreeスキャンの結果は、各ワーカープロセス内でソートされた順序で返されます。</target>
        </trans-unit>
        <trans-unit id="9434bbdc8aace98fbdb811c879672bca3c9b835e" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel sequential scan&lt;/em&gt;, the table's blocks will be divided among the cooperating processes. Blocks are handed out one at a time, so that access to the table remains sequential.</source>
          <target state="translated">&lt;em&gt;平行シーケンシャルスキャン&lt;/em&gt;、テーブルのブロックが協働プロセス間で分割されます。ブロックは一度に1つずつ配布されるため、テーブルへのアクセスは順次に行われます。</target>
        </trans-unit>
        <trans-unit id="f3fefb800e2db94c9c9a41bf996e2bc5c5260e63" translate="yes" xml:space="preserve">
          <source>In a B-tree leaf page, &lt;code&gt;ctid&lt;/code&gt; points to a heap tuple. In an internal page, the block number part of &lt;code&gt;ctid&lt;/code&gt; points to another page in the index itself, while the offset part (the second number) is ignored and is usually 1.</source>
          <target state="translated">Bツリーリーフページでは、 &lt;code&gt;ctid&lt;/code&gt; はヒープタプルを指します。内部ページでは、 &lt;code&gt;ctid&lt;/code&gt; のブロック番号部分はインデックス自体の別のページを指していますが、オフセット部分（2番目の番号）は無視され、通常は1です。</target>
        </trans-unit>
        <trans-unit id="d0a6087a10f85c3bb150e6308e3861061574aa67" translate="yes" xml:space="preserve">
          <source>In a concurrent index build, the index is actually entered into the system catalogs in one transaction, then two table scans occur in two more transactions. Before each table scan, the index build must wait for existing transactions that have modified the table to terminate. After the second scan, the index build must wait for any transactions that have a snapshot (see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;) predating the second scan to terminate. Then finally the index can be marked ready for use, and the &lt;code&gt;CREATE INDEX&lt;/code&gt; command terminates. Even then, however, the index may not be immediately usable for queries: in the worst case, it cannot be used as long as transactions exist that predate the start of the index build.</source>
          <target state="translated">並行インデックス作成では、インデックスは実際には1つのトランザクションでシステムカタログに入力され、次に2つのトランザクションで2つのテーブルスキャンが発生します。各テーブルスキャンの前に、インデックスビルドは、テーブルを変更した既存のトランザクションが終了するのを待つ必要があります。 2回目のスキャンの後、インデックスの作成は、2回目のスキャンが終了する前のスナップショット（&lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;第13章を&lt;/a&gt;参照）を持つトランザクションが終了するまで待機する必要があります。最後に、インデックスを使用できるようにマークを付けることができ、 &lt;code&gt;CREATE INDEX&lt;/code&gt; コマンドは終了します。ただし、その場合でも、インデックスはクエリですぐに使用できない場合があります。最悪の場合、インデックスの作成の開始より前のトランザクションが存在する限り、インデックスを使用できません。</target>
        </trans-unit>
        <trans-unit id="f4a542d58c1d654f7da71e85731698e5120795a1" translate="yes" xml:space="preserve">
          <source>In a default installation, none of the above parameters are set explicitly. Instead, the data directory is specified by the &lt;code&gt;-D&lt;/code&gt; command-line option or the &lt;code&gt;PGDATA&lt;/code&gt; environment variable, and the configuration files are all found within the data directory.</source>
          <target state="translated">デフォルトのインストールでは、上記のパラメーターは明示的に設定されていません。代わりに、データディレクトリは &lt;code&gt;-D&lt;/code&gt; コマンドラインオプションまたは &lt;code&gt;PGDATA&lt;/code&gt; 環境変数で指定され、構成ファイルはすべてデータディレクトリ内にあります。</target>
        </trans-unit>
        <trans-unit id="ade0e33e559fe0711e0dbe8eb460618e29475014" translate="yes" xml:space="preserve">
          <source>In a dropped column's &lt;code&gt;pg_attribute&lt;/code&gt; entry, &lt;code&gt;atttypid&lt;/code&gt; is reset to zero, but &lt;code&gt;attlen&lt;/code&gt; and the other fields copied from &lt;code&gt;pg_type&lt;/code&gt; are still valid. This arrangement is needed to cope with the situation where the dropped column's data type was later dropped, and so there is no &lt;code&gt;pg_type&lt;/code&gt; row anymore. &lt;code&gt;attlen&lt;/code&gt; and the other fields can be used to interpret the contents of a row of the table.</source>
          <target state="translated">ドロップされた列の &lt;code&gt;pg_attribute&lt;/code&gt; エントリでは、 &lt;code&gt;atttypid&lt;/code&gt; はゼロにリセットされますが、 &lt;code&gt;attlen&lt;/code&gt; と &lt;code&gt;pg_type&lt;/code&gt; からコピーされた他のフィールドは引き続き有効です。この配置は、ドロップされた列のデータ型が後でドロップされ、 &lt;code&gt;pg_type&lt;/code&gt; 行がなくなった状況に対処するために必要です。 &lt;code&gt;attlen&lt;/code&gt; およびその他のフィールドを使用して、テーブルの行の内容を解釈できます。</target>
        </trans-unit>
        <trans-unit id="919410546242ad36460212f72d578356bff6291e" translate="yes" xml:space="preserve">
          <source>In a literal that has been determined to be &lt;code&gt;timestamp without time zone&lt;/code&gt;, PostgreSQL will silently ignore any time zone indication. That is, the resulting value is derived from the date/time fields in the input value, and is not adjusted for time zone.</source>
          <target state="translated">&lt;code&gt;timestamp without time zone&lt;/code&gt; 判断されたリテラルでは、PostgreSQLはタイムゾーンの指示を黙って無視します。つまり、結果の値は入力値の日付/時刻フィールドから導出され、タイムゾーンに合わせて調整されません。</target>
        </trans-unit>
        <trans-unit id="fe8c5382c7df4fd888e297e6990fce336207e731" translate="yes" xml:space="preserve">
          <source>In a priority-based synchronous replication, the standbys whose names appear earlier in the list will be used as synchronous standbys. Standbys listed after these will take over the role of synchronous standby if one of current ones should fail.</source>
          <target state="translated">優先度ベースの同期レプリケーションでは、リストの前に名前が表示されているスタンバイが同期スタンバイとして使用されます。これらの後にリストアップされたスタンバイは、現在のスタンバイのいずれかに障害が発生した場合、同期スタンバイの役割を引き継ぎます。</target>
        </trans-unit>
        <trans-unit id="6be13ad3386e50cb4bfa2ce22e78dd04cec9a6ab" translate="yes" xml:space="preserve">
          <source>In a quorum-based synchronous replication, all the standbys appearing in the list will be used as candidates for synchronous standbys. Even if one of them should fail, the other standbys will keep performing the role of candidates of synchronous standby.</source>
          <target state="translated">クォーラムベースの同期レプリケーションでは、リストに表示されているすべてのスタンバイが同期スタンバイの候補として使用されます。そのうちの1つに障害が発生した場合でも、他のスタンバイは同期スタンバイの候補としての役割を果たし続けます。</target>
        </trans-unit>
        <trans-unit id="a6cdb6331798b6847433d71683fa652dae3c0858" translate="yes" xml:space="preserve">
          <source>In a rule for &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; on a view, you can add a &lt;code&gt;RETURNING&lt;/code&gt; clause that emits the view's columns. This clause will be used to compute the outputs if the rule is triggered by an &lt;code&gt;INSERT RETURNING&lt;/code&gt;, &lt;code&gt;UPDATE RETURNING&lt;/code&gt;, or &lt;code&gt;DELETE RETURNING&lt;/code&gt; command respectively. When the rule is triggered by a command without &lt;code&gt;RETURNING&lt;/code&gt;, the rule's &lt;code&gt;RETURNING&lt;/code&gt; clause will be ignored. The current implementation allows only unconditional &lt;code&gt;INSTEAD&lt;/code&gt; rules to contain &lt;code&gt;RETURNING&lt;/code&gt;; furthermore there can be at most one &lt;code&gt;RETURNING&lt;/code&gt; clause among all the rules for the same event. (This ensures that there is only one candidate &lt;code&gt;RETURNING&lt;/code&gt; clause to be used to compute the results.) &lt;code&gt;RETURNING&lt;/code&gt; queries on the view will be rejected if there is no &lt;code&gt;RETURNING&lt;/code&gt; clause in any available rule.</source>
          <target state="translated">ビューに対する &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、または &lt;code&gt;DELETE&lt;/code&gt; のルールでは、ビューの列を出力する &lt;code&gt;RETURNING&lt;/code&gt; 句を追加できます。ルールが &lt;code&gt;INSERT RETURNING&lt;/code&gt; 、 &lt;code&gt;UPDATE RETURNING&lt;/code&gt; 、または &lt;code&gt;DELETE RETURNING&lt;/code&gt; コマンドによってそれぞれトリガーされた場合、この句を使用して出力が計算されます。ルールが &lt;code&gt;RETURNING&lt;/code&gt; なしのコマンドによってトリガーされた場合、ルールの &lt;code&gt;RETURNING&lt;/code&gt; 句は無視されます。現在の実装では、無条件の &lt;code&gt;INSTEAD&lt;/code&gt; ルールのみに &lt;code&gt;RETURNING&lt;/code&gt; を含めることができます。さらに、最大で1つの &lt;code&gt;RETURNING&lt;/code&gt; 同じイベントのすべてのルールの中で句。（これにより、結果の計算に使用される &lt;code&gt;RETURNING&lt;/code&gt; 句の候補が1つだけあることが保証されます。）使用可能なルールに &lt;code&gt;RETURNING&lt;/code&gt; 句がない場合、ビューに対する &lt;code&gt;RETURNING&lt;/code&gt; クエリは拒否されます。</target>
        </trans-unit>
        <trans-unit id="b30170def17c750dae562bb19e988c5bae9da5a7" translate="yes" xml:space="preserve">
          <source>In a simple join query, such as:</source>
          <target state="translated">のような単純な結合クエリでは</target>
        </trans-unit>
        <trans-unit id="3e1f4464d1af94cd74998edaeff888eee6d91174" translate="yes" xml:space="preserve">
          <source>In a standby server that exists primarily for high availability, it's best to set the delay parameters relatively short, so that the server cannot fall far behind the primary due to delays caused by standby queries. However, if the standby server is meant for executing long-running queries, then a high or even infinite delay value may be preferable. Keep in mind however that a long-running query could cause other sessions on the standby server to not see recent changes on the primary, if it delays application of WAL records.</source>
          <target state="translated">主に高可用性を目的としたスタンバイサーバでは、スタンバイクエリによる遅延のためにサーバがプライマリよりも大きく遅れないように、遅延パラメータを比較的短く設定するのが最善です。しかし、スタンバイサーバが長期的なクエリの実行を目的としている場合は、遅延パラメータを高く設定したり、無限に設定したりすることが望ましいかもしれません。ただし、長時間実行されるクエリによってWALレコードの適用が遅れると、待機サーバ上の他のセッションがプライマリ上の最近の変更を表示しなくなる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0a9a7bd917eb1db2204b6427584eda8a4fd3adfe" translate="yes" xml:space="preserve">
          <source>In a table definition, default values are listed after the column data type. For example:</source>
          <target state="translated">テーブル定義では、デフォルト値は列データ型の後にリストされます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="ea0511eba225911c6d4bd1330fecc7bed6e9ecc3" translate="yes" xml:space="preserve">
          <source>In addition these settings can be preserved between reboots in the file &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;. Doing that is highly recommended.</source>
          <target state="translated">さらに、これらの設定は、ファイル &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; のリブート間で保持できます。そうすることを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="096299b269c3119f5fd70cea143f131c4bf07844" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;postgresql.conf&lt;/code&gt;, a PostgreSQL data directory contains a file &lt;code&gt;postgresql.auto.conf&lt;/code&gt;, which has the same format as &lt;code&gt;postgresql.conf&lt;/code&gt; but is intended to be edited automatically, not manually. This file holds settings provided through the &lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt; command. This file is read whenever &lt;code&gt;postgresql.conf&lt;/code&gt; is, and its settings take effect in the same way. Settings in &lt;code&gt;postgresql.auto.conf&lt;/code&gt; override those in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">加え &lt;code&gt;postgresql.conf&lt;/code&gt; の、PostgreSQLのデータディレクトリにはファイル含ま &lt;code&gt;postgresql.auto.conf&lt;/code&gt; と同じフォーマットを有する、 &lt;code&gt;postgresql.conf&lt;/code&gt; のではなく、手動で、自動的に編集されることが意図されます。このファイルには、&lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt;コマンドによって提供される設定が保持されます。このファイルは &lt;code&gt;postgresql.conf&lt;/code&gt; が読み込まれるたびに読み込まれ、その設定は同じ方法で有効になります。設定 &lt;code&gt;postgresql.auto.conf&lt;/code&gt; はのものより優先 &lt;code&gt;postgresql.conf&lt;/code&gt; のを。</target>
        </trans-unit>
        <trans-unit id="8b72ebbfc32b5c7dc9d476e5e61c36ae4f704bc0" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;public&lt;/code&gt; and user-created schemas, each database contains a &lt;code&gt;pg_catalog&lt;/code&gt; schema, which contains the system tables and all the built-in data types, functions, and operators. &lt;code&gt;pg_catalog&lt;/code&gt; is always effectively part of the search path. If it is not named explicitly in the path then it is implicitly searched &lt;em&gt;before&lt;/em&gt; searching the path's schemas. This ensures that built-in names will always be findable. However, you can explicitly place &lt;code&gt;pg_catalog&lt;/code&gt; at the end of your search path if you prefer to have user-defined names override built-in names.</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; スキーマとユーザー作成スキーマに加えて、各データベースには、システムテーブルとすべての組み込みデータ型、関数、および演算子を含む &lt;code&gt;pg_catalog&lt;/code&gt; スキーマが含まれています。 &lt;code&gt;pg_catalog&lt;/code&gt; は、事実上常に検索パスの一部です。パスで明示的に名前が付けられていない場合は、パスのスキーマを検索&lt;em&gt;する前に&lt;/em&gt;暗黙的に検索されます。これにより、組み込み名が常に検索可能になります。ただし、ユーザー定義の名前で組み込みの名前を上書きする場合は、 &lt;code&gt;pg_catalog&lt;/code&gt; を検索パスの最後に明示的に配置できます。</target>
        </trans-unit>
        <trans-unit id="f70bc34b6f3d01fe499b2933dfc1efba4688427d" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;standard_conforming_strings&lt;/code&gt;, the configuration parameters &lt;a href=&quot;runtime-config-compatible#GUC-ESCAPE-STRING-WARNING&quot;&gt;escape_string_warning&lt;/a&gt; and &lt;a href=&quot;runtime-config-compatible#GUC-BACKSLASH-QUOTE&quot;&gt;backslash_quote&lt;/a&gt; govern treatment of backslashes in string constants.</source>
          <target state="translated">加え &lt;code&gt;standard_conforming_strings&lt;/code&gt; は、構成パラメータ&lt;a href=&quot;runtime-config-compatible#GUC-ESCAPE-STRING-WARNING&quot;&gt;escape_string_warningを&lt;/a&gt;と&lt;a href=&quot;runtime-config-compatible#GUC-BACKSLASH-QUOTE&quot;&gt;backslash_quoteにより、&lt;/a&gt;文字列定数内のバックスラッシュの治療を支配します。</target>
        </trans-unit>
        <trans-unit id="ca198320ff48380e299bcbd7319925ded5a95535" translate="yes" xml:space="preserve">
          <source>In addition to individual parameter settings, the &lt;code&gt;postgresql.conf&lt;/code&gt; file can contain &lt;em&gt;include directives&lt;/em&gt;, which specify another file to read and process as if it were inserted into the configuration file at this point. This feature allows a configuration file to be divided into physically separate parts. Include directives simply look like:</source>
          <target state="translated">個々のパラメータ設定に加えて、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルには&lt;em&gt;includeディレクティブ&lt;/em&gt;を含めることができます。この&lt;em&gt;ディレクティブは&lt;/em&gt;、この時点で構成ファイルに挿入されたかのように、読み取りおよび処理する別のファイルを指定します。この機能により、構成ファイルを物理的に別々の部分に分割できます。インクルードディレクティブは次のようになります。</target>
        </trans-unit>
        <trans-unit id="e670e7bf52fa0455274db822ce4cd6907d528db9" translate="yes" xml:space="preserve">
          <source>In addition to ordinary numeric values, the &lt;code&gt;numeric&lt;/code&gt; type allows the special value &lt;code&gt;NaN&lt;/code&gt;, meaning &amp;ldquo;not-a-number&amp;rdquo;. Any operation on &lt;code&gt;NaN&lt;/code&gt; yields another &lt;code&gt;NaN&lt;/code&gt;. When writing this value as a constant in an SQL command, you must put quotes around it, for example &lt;code&gt;UPDATE table SET x = 'NaN'&lt;/code&gt;. On input, the string &lt;code&gt;NaN&lt;/code&gt; is recognized in a case-insensitive manner.</source>
          <target state="translated">通常の数値に加えて、 &lt;code&gt;numeric&lt;/code&gt; タイプは、「非数」を意味する特別な値 &lt;code&gt;NaN&lt;/code&gt; を許可します。 &lt;code&gt;NaN&lt;/code&gt; に対する操作は、別の &lt;code&gt;NaN&lt;/code&gt; を生成します。 SQLコマンドでこの値を定数として書き込む場合は、値を引用符で囲む必要があります（例： &lt;code&gt;UPDATE table SET x = 'NaN'&lt;/code&gt; 。入力では、文字列 &lt;code&gt;NaN&lt;/code&gt; は大文字と小文字を区別しない方法で認識されます。</target>
        </trans-unit>
        <trans-unit id="e4bbcc684e36efbca1c2d0b6de3932866401bc9a" translate="yes" xml:space="preserve">
          <source>In addition to ordinary numeric values, the floating-point types have several special values:</source>
          <target state="translated">浮動小数点型には、通常の数値に加えて、いくつかの特殊な値があります。</target>
        </trans-unit>
        <trans-unit id="19311d87cac186ad5be7afccb28d88535be2bd00" translate="yes" xml:space="preserve">
          <source>In addition to setting global defaults or attaching overrides at the database or role level, you can pass settings to PostgreSQL via shell facilities. Both the server and libpq client library accept parameter values via the shell.</source>
          <target state="translated">グローバルデフォルトの設定やデータベースやロールレベルでのオーバーライドの添付に加えて、シェル機能を使ってPostgreSQLに設定を渡すことができます。サーバとlibpqクライアントライブラリの両方とも、シェル経由でパラメータ値を受け取ることができます。</target>
        </trans-unit>
        <trans-unit id="a22166b5786a29ccaf8b6526c1e48730c5b76cde" translate="yes" xml:space="preserve">
          <source>In addition to simply finding the rows to be returned by a query, an index may be able to deliver them in a specific sorted order. This allows a query's &lt;code&gt;ORDER BY&lt;/code&gt; specification to be honored without a separate sorting step. Of the index types currently supported by PostgreSQL, only B-tree can produce sorted output &amp;mdash; the other index types return matching rows in an unspecified, implementation-dependent order.</source>
          <target state="translated">インデックスは、クエリによって返される行を単に見つけることに加えて、特定のソートされた順序でそれらを配信できる場合があります。これにより、クエリの &lt;code&gt;ORDER BY&lt;/code&gt; 仕様を、個別の並べ替え手順なしで使用できます。現在PostgreSQLでサポートされているインデックスタイプのうち、Bツリーのみがソートされた出力を生成できます。他のインデックスタイプは、指定された実装依存の順序で一致する行を返します。</target>
        </trans-unit>
        <trans-unit id="4ba1e6913eefc780040c670e81ceade68f518709" translate="yes" xml:space="preserve">
          <source>In addition to supporting ordinary index scans, some types of index may wish to support &lt;em&gt;parallel index scans&lt;/em&gt;, which allow multiple backends to cooperate in performing an index scan. The index access method should arrange things so that each cooperating process returns a subset of the tuples that would be performed by an ordinary, non-parallel index scan, but in such a way that the union of those subsets is equal to the set of tuples that would be returned by an ordinary, non-parallel index scan. Furthermore, while there need not be any global ordering of tuples returned by a parallel scan, the ordering of that subset of tuples returned within each cooperating backend must match the requested ordering. The following functions may be implemented to support parallel index scans:</source>
          <target state="translated">通常のインデックススキャンのサポートに加えて、一部のタイプのインデックスでは、複数のバックエンドが連携してインデックススキャンを実行できるようにする&lt;em&gt;並列インデックススキャンの&lt;/em&gt;サポートが必要になる場合があります。インデックスアクセスメソッドは、各協調プロセスが通常の非並列インデックススキャンによって実行されるタプルのサブセットを返すように、ただし、これらのサブセットの結合がタプルのセットと等しくなるように調整する必要があります。これは、通常の非並列インデックススキャンによって返されます。さらに、並列スキャンによって返されるタプルのグローバルな順序は必要ありませんが、各協調バックエンド内で返されるタプルのサブセットの順序は、要求された順序と一致する必要があります。並列インデックススキャンをサポートするために、次の関数を実装できます。</target>
        </trans-unit>
        <trans-unit id="2240e6efaaf6aaec400aa311d695b65a5cb9013d" translate="yes" xml:space="preserve">
          <source>In addition to table and row locks, page-level share/exclusive locks are used to control read/write access to table pages in the shared buffer pool. These locks are released immediately after a row is fetched or updated. Application developers normally need not be concerned with page-level locks, but they are mentioned here for completeness.</source>
          <target state="translated">テーブルと行のロックに加えて、ページレベルの共有/排他ロックは、共有バッファプール内のテーブルページへの読み書きアクセスを制御するために使用されます。これらのロックは、行がフェッチされたり更新されたりするとすぐに解除されます。アプリケーション開発者は通常、ページレベルのロックを気にする必要はありませんが、ここでは完全性を確保するために言及しています。</target>
        </trans-unit>
        <trans-unit id="87509ac7479eedd6c62071274770036abf56ee4c" translate="yes" xml:space="preserve">
          <source>In addition to table-level locks, there are row-level locks, which are listed as below with the contexts in which they are used automatically by PostgreSQL. See &lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;Table 13.3&lt;/a&gt; for a complete table of row-level lock conflicts. Note that a transaction can hold conflicting locks on the same row, even in different subtransactions; but other than that, two transactions can never hold conflicting locks on the same row. Row-level locks do not affect data querying; they block only &lt;em&gt;writers and lockers&lt;/em&gt; to the same row.</source>
          <target state="translated">テーブルレベルのロックに加えて、行レベルのロックがあります。これらは、PostgreSQLによって自動的に使用されるコンテキストとともに以下にリストされています。行レベルのロック競合の完全な表については、&lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;表13.3&lt;/a&gt;を参照してください。トランザクションは、異なるサブトランザクションであっても、同じ行で競合するロックを保持できることに注意してください。それ以外は、2つのトランザクションが同じ行に競合するロックを保持することはできません。行レベルのロックはデータのクエリに影響しません。同じ行の&lt;em&gt;ライターとロッカー&lt;/em&gt;のみをブロックします。</target>
        </trans-unit>
        <trans-unit id="eefa082a90a01551ee9f7be83fe0ecef6e330ce1" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;postgresql.conf&lt;/code&gt; file already mentioned, PostgreSQL uses two other manually-edited configuration files, which control client authentication (their use is discussed in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;). By default, all three configuration files are stored in the database cluster's data directory. The parameters described in this section allow the configuration files to be placed elsewhere. (Doing so can ease administration. In particular it is often easier to ensure that the configuration files are properly backed-up when they are kept separate.)</source>
          <target state="translated">PostgreSQLは、すでに述べた &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルに加えて、手動で編集された他の2つの構成ファイルを使用します。これらの構成ファイルは、クライアント認証を制御します（その使用については、&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;第20章&lt;/a&gt;で説明します）。デフォルトでは、3つの構成ファイルはすべてデータベースクラスタのデータディレクトリに保存されます。このセクションで説明するパラメーターを使用すると、構成ファイルを別の場所に配置できます。 （そうすることで、管理が容易になります。特に、構成ファイルが別々に保管されている場合は、構成ファイルが適切にバックアップされることを確認する方が簡単な場合があります。）</target>
        </trans-unit>
        <trans-unit id="06a5b24df3b5e27969bb36917a3a17ae8bb1189b" translate="yes" xml:space="preserve">
          <source>In addition to the SQL-standard &lt;a href=&quot;ddl-priv&quot;&gt;privilege system&lt;/a&gt; available through &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;, tables can have &lt;em&gt;row security policies&lt;/em&gt; that restrict, on a per-user basis, which rows can be returned by normal queries or inserted, updated, or deleted by data modification commands. This feature is also known as &lt;em&gt;Row-Level Security&lt;/em&gt;. By default, tables do not have any policies, so that if a user has access privileges to a table according to the SQL privilege system, all rows within it are equally available for querying or updating.</source>
          <target state="translated">&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;を介して利用できるSQL標準の&lt;a href=&quot;ddl-priv&quot;&gt;特権システムに&lt;/a&gt;加えて、テーブルには、ユーザーごとに、通常のクエリによって返される行、またはデータ変更コマンドによって挿入、更新、または削除できる行を制限する&lt;em&gt;行セキュリティポリシー&lt;/em&gt;を設定できます。この機能は、&lt;em&gt;行レベルのセキュリティ&lt;/em&gt;とも呼ばれます。デフォルトでは、テーブルにはポリシーがありません。そのため、ユーザーがSQL特権システムに従ってテーブルへのアクセス権を持っている場合、テーブル内のすべての行がクエリまたは更新に等しく利用できます。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58a68bf9280d646b1a85ebb074d2b6ecfecda3df" translate="yes" xml:space="preserve">
          <source>In addition to the format specifiers described above, the special sequence &lt;code&gt;%%&lt;/code&gt; may be used to output a literal &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">上記のフォーマット指定子に加えて、特殊なシーケンス &lt;code&gt;%%&lt;/code&gt; を使用して、リテラル &lt;code&gt;%&lt;/code&gt; 文字を出力できます。</target>
        </trans-unit>
        <trans-unit id="8bfea922b7478af1fb30846a7ffdd145169e7fe7" translate="yes" xml:space="preserve">
          <source>In addition to the functions listed in this section, there are a number of functions related to the statistics system that also provide system information. See &lt;a href=&quot;monitoring-stats#MONITORING-STATS-VIEWS&quot;&gt;Section 27.2.2&lt;/a&gt; for more information.</source>
          <target state="translated">このセクションにリストされている関数に加えて、システム情報も提供する統計システムに関連するいくつかの関数があります。詳細は&lt;a href=&quot;monitoring-stats#MONITORING-STATS-VIEWS&quot;&gt;項27.2.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2dc53d9aa025a55feab0c728607a475dd6480573" translate="yes" xml:space="preserve">
          <source>In addition to the generic lookup mechanisms, there is a special convention that &lt;code&gt;PGNSP&lt;/code&gt; is replaced by the OID of the &lt;code&gt;pg_catalog&lt;/code&gt; schema, and &lt;code&gt;PGUID&lt;/code&gt; is replaced by the OID of the bootstrap superuser role. These usages are somewhat historical but so far there hasn't been a need to generalize them.</source>
          <target state="translated">一般的な検索メカニズムに加えて、 &lt;code&gt;PGNSP&lt;/code&gt; は &lt;code&gt;pg_catalog&lt;/code&gt; スキーマのOIDに置き換えられ、 &lt;code&gt;PGUID&lt;/code&gt; はブートストラップスーパーユーザーロールのOIDに置き換えられるという特別な規則があります。これらの使用法は多少歴史的ですが、これまではそれらを一般化する必要はありませんでした。</target>
        </trans-unit>
        <trans-unit id="671caebf932d9cdddfa02cea4a21319996df3fc1" translate="yes" xml:space="preserve">
          <source>In addition to the main syntax described above, there are some special forms and miscellaneous syntactic facilities available.</source>
          <target state="translated">上述した主構文の他にも、特殊な形式や雑多な構文機能が用意されています。</target>
        </trans-unit>
        <trans-unit id="cfdcb8c233fbe99bb0dea34235cb119f257b9a78" translate="yes" xml:space="preserve">
          <source>In addition to the method-specific options listed below, there is one method-independent authentication option &lt;code&gt;clientcert&lt;/code&gt;, which can be specified in any &lt;code&gt;hostssl&lt;/code&gt; record. This option can be set to &lt;code&gt;verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt;. Both options require the client to present a valid (trusted) SSL certificate, while &lt;code&gt;verify-full&lt;/code&gt; additionally enforces that the &lt;code&gt;cn&lt;/code&gt; (Common Name) in the certificate matches the username or an applicable mapping. This behavior is similar to the &lt;code&gt;cert&lt;/code&gt; authentication method (see &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt;) but enables pairing the verification of client certificates with any authentication method that supports &lt;code&gt;hostssl&lt;/code&gt; entries.</source>
          <target state="translated">以下にリストするメソッド固有のオプションに加えて、メソッドに依存しない認証オプション &lt;code&gt;clientcert&lt;/code&gt; が1つあります。これは、任意の &lt;code&gt;hostssl&lt;/code&gt; レコードで指定できます。このオプションは、 &lt;code&gt;verify-ca&lt;/code&gt; または &lt;code&gt;verify-full&lt;/code&gt; に設定できます。どちらのオプションでも、クライアントは有効な（信頼できる）SSL証明書を提示する必要がありますが、 &lt;code&gt;verify-full&lt;/code&gt; はさらに、証明書の &lt;code&gt;cn&lt;/code&gt; （共通名）がユーザー名または適用可能なマッピングと一致することを強制します。この動作は、 &lt;code&gt;cert&lt;/code&gt; 認証方法（&lt;a href=&quot;auth-cert&quot;&gt;セクション20.12を&lt;/a&gt;参照）に似ていますが、クライアント証明書の検証と、 &lt;code&gt;hostssl&lt;/code&gt; をサポートする任意の認証方法を組み合わせることができます。 エントリ。</target>
        </trans-unit>
        <trans-unit id="ddf91010c34fa3b26374dd73b3df519e9da0fd2a" translate="yes" xml:space="preserve">
          <source>In addition to the operators shown in the table, the ordinary B-tree comparison operators (&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, etc) are defined for types &lt;code&gt;tsvector&lt;/code&gt; and &lt;code&gt;tsquery&lt;/code&gt;. These are not very useful for text searching but allow, for example, unique indexes to be built on columns of these types.</source>
          <target state="translated">表に示されている演算子に加えて、通常のBツリー比較演算子（ &lt;code&gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&lt;/code&gt; など）が &lt;code&gt;tsvector&lt;/code&gt; 型と &lt;code&gt;tsquery&lt;/code&gt; 型に対して定義されています。これらはテキスト検索にはあまり役立ちませんが、たとえば、これらのタイプの列に一意のインデックスを構築できます。</target>
        </trans-unit>
        <trans-unit id="31c46db92025ad200f49ee2517827b67ca69ce01" translate="yes" xml:space="preserve">
          <source>In addition to the socket file itself, which is named &lt;code&gt;.s.PGSQL.nnnn&lt;/code&gt; where &lt;code&gt;nnnn&lt;/code&gt; is the server's port number, an ordinary file named &lt;code&gt;.s.PGSQL.nnnn.lock&lt;/code&gt; will be created in each of the &lt;code&gt;unix_socket_directories&lt;/code&gt; directories. Neither file should ever be removed manually.</source>
          <target state="translated">命名されたソケットファイル自体に加えて、 &lt;code&gt;.s.PGSQL.nnnn&lt;/code&gt; &lt;code&gt;nnnn&lt;/code&gt; は名前の通常のファイルサーバのポート番号、ある &lt;code&gt;.s.PGSQL.nnnn.lock&lt;/code&gt; がそれぞれに作成されます &lt;code&gt;unix_socket_directories&lt;/code&gt; のディレクトリを。どちらのファイルも手動で削除しないでください。</target>
        </trans-unit>
        <trans-unit id="f961899526c4ec4b91a471972a05e3809476d8c4" translate="yes" xml:space="preserve">
          <source>In addition to the system catalogs, PostgreSQL provides a number of built-in views. Some system views provide convenient access to some commonly used queries on the system catalogs. Other views provide access to internal server state.</source>
          <target state="translated">システムカタログに加えて、PostgreSQLは多くの組み込みビューを提供しています。いくつかのシステムビューは、システムカタログ上で一般的に使用されるいくつかの問い合わせへの便利なアクセスを提供します。その他のビューは、サーバの内部状態へのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="3e99de7dbe2b503398057fb045bf3c995d4ba6e3" translate="yes" xml:space="preserve">
          <source>In addition to the timezone names and abbreviations, PostgreSQL will accept POSIX-style time zone specifications of the form &lt;code&gt;STD&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;STD&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt;&lt;code&gt;DST&lt;/code&gt;, where &lt;code&gt;STD&lt;/code&gt; is a zone abbreviation, &lt;code&gt;offset&lt;/code&gt; is a numeric offset in hours west from UTC, and &lt;code&gt;DST&lt;/code&gt; is an optional daylight-savings zone abbreviation, assumed to stand for one hour ahead of the given offset. For example, if &lt;code&gt;EST5EDT&lt;/code&gt; were not already a recognized zone name, it would be accepted and would be functionally equivalent to United States East Coast time. In this syntax, a zone abbreviation can be a string of letters, or an arbitrary string surrounded by angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;). When a daylight-savings zone abbreviation is present, it is assumed to be used according to the same daylight-savings transition rules used in the IANA time zone database's &lt;code&gt;posixrules&lt;/code&gt; entry. In a standard PostgreSQL installation, &lt;code&gt;posixrules&lt;/code&gt; is the same as &lt;code&gt;US/Eastern&lt;/code&gt;, so that POSIX-style time zone specifications follow USA daylight-savings rules. If needed, you can adjust this behavior by replacing the &lt;code&gt;posixrules&lt;/code&gt; file.</source>
          <target state="translated">タイムゾーン名と省略形に加えて、PostgreSQLは、 &lt;code&gt;STD&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; または &lt;code&gt;STD&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;DST&lt;/code&gt; の形式のPOSIXスタイルのタイムゾーン指定を受け入れます。ここで、 &lt;code&gt;STD&lt;/code&gt; はゾーンの省略形、 &lt;code&gt;offset&lt;/code&gt; はUTCからの西の時間での数値オフセット、 &lt;code&gt;DST&lt;/code&gt; はオプションの夏時間ゾーンの省略形。指定されたオフセットより1時間進んでいると見なされます。たとえば、 &lt;code&gt;EST5EDT&lt;/code&gt; がまだ認識されていないゾーン名である場合、それは受け入れられ、米国東海岸の時間と機能的に同等になります。この構文では、ゾーンの省略形は、文字列、または山括弧（ &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; )で囲まれた任意の文字列にすることができます。）。サマータイムゾーンの省略形が存在する場合、IANAタイムゾーンデータベースの &lt;code&gt;posixrules&lt;/code&gt; エントリで使用されているのと同じサマータイム移行ルールに従って使用されると想定されます。標準のPostgreSQLインストールでは、 &lt;code&gt;posixrules&lt;/code&gt; は &lt;code&gt;US/Eastern&lt;/code&gt; と同じであるため、POSIXスタイルのタイムゾーン指定は米国の夏時間規則に従います。必要に応じて、 &lt;code&gt;posixrules&lt;/code&gt; ファイルを置き換えることにより、この動作を調整できます。</target>
        </trans-unit>
        <trans-unit id="5639f9b8e3c76507298cdef9442456212dc91a3a" translate="yes" xml:space="preserve">
          <source>In addition to the typical B-tree search operators, &lt;code&gt;btree_gist&lt;/code&gt; also provides index support for &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; (&amp;ldquo;not equals&amp;rdquo;). This may be useful in combination with an &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;exclusion constraint&lt;/a&gt;, as described below.</source>
          <target state="translated">一般的なBツリー検索演算子に加えて、 &lt;code&gt;btree_gist&lt;/code&gt; は &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; （「等しくない」）のインデックスサポートも提供します。これは、以下で説明するように、&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;除外制約&lt;/a&gt;と組み合わせると便利です。</target>
        </trans-unit>
        <trans-unit id="b7456acfa95fcaf383cf25fda8119cc53ab8322a" translate="yes" xml:space="preserve">
          <source>In addition to the usual (&lt;em&gt;tight&lt;/em&gt;) RE syntax, in which all characters are significant, there is an &lt;em&gt;expanded&lt;/em&gt; syntax, available by specifying the embedded &lt;code&gt;x&lt;/code&gt; option. In the expanded syntax, white-space characters in the RE are ignored, as are all characters between a &lt;code&gt;#&lt;/code&gt; and the following newline (or the end of the RE). This permits paragraphing and commenting a complex RE. There are three exceptions to that basic rule:</source>
          <target state="translated">すべての文字が重要である通常の（&lt;em&gt;タイト&lt;/em&gt;）RE構文に加えて、埋め込まれた &lt;code&gt;x&lt;/code&gt; オプションを指定することで使用できる&lt;em&gt;拡張&lt;/em&gt;構文があります。拡張構文では、RE内の空白文字は無視され、 &lt;code&gt;#&lt;/code&gt; と次の改行の間（またはREの末尾）のすべての文字も無視されます。これにより、複雑なREをパラグラフ化してコメントを付けることができます。この基本ルールには3つの例外があります。</target>
        </trans-unit>
        <trans-unit id="da522f31f6ebf1b8a6e0efd3ead6600864945861" translate="yes" xml:space="preserve">
          <source>In addition to these facilities borrowed from &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;SIMILAR TO&lt;/code&gt; supports these pattern-matching metacharacters borrowed from POSIX regular expressions:</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; から借用したこれらの機能に加えて、 &lt;code&gt;SIMILAR TO&lt;/code&gt; は、POSIX正規表現から借用したこれらのパターンマッチングメタ文字をサポートします。</target>
        </trans-unit>
        <trans-unit id="d5ad168deb41cb8cd3104e11c297f4193822a79b" translate="yes" xml:space="preserve">
          <source>In addition to these functions, any built-in or user-defined general-purpose or statistical aggregate (i.e., not ordered-set or hypothetical-set aggregates) can be used as a window function; see &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt; for a list of the built-in aggregates. Aggregate functions act as window functions only when an &lt;code&gt;OVER&lt;/code&gt; clause follows the call; otherwise they act as non-window aggregates and return a single row for the entire set.</source>
          <target state="translated">これらの関数に加えて、組み込み関数またはユーザー定義の汎用または統計集合（つまり、順序集合または仮集合集合ではない）をウィンドウ関数として使用できます。組み込み集計のリストについては、&lt;a href=&quot;functions-aggregate&quot;&gt;9.20項を&lt;/a&gt;参照してください。集計関数は、 &lt;code&gt;OVER&lt;/code&gt; 句が呼び出しに続く場合にのみウィンドウ関数として機能します。それ以外の場合は、ウィンドウ以外の集計として機能し、セット全体の単一行を返します。</target>
        </trans-unit>
        <trans-unit id="3b254c4c7b10faf7e76791fc77c4b40ffb55a623" translate="yes" xml:space="preserve">
          <source>In addition to these functions, the SQL &lt;code&gt;OVERLAPS&lt;/code&gt; operator is supported:</source>
          <target state="translated">これらの関数に加えて、SQL &lt;code&gt;OVERLAPS&lt;/code&gt; 演算子がサポートされています。</target>
        </trans-unit>
        <trans-unit id="918debfa135a3ee3b32c08e005bfe3898a987217" translate="yes" xml:space="preserve">
          <source>In addition to this list, there are a number of constructs that can be classified as an expression but do not follow any general syntax rules. These generally have the semantics of a function or operator and are explained in the appropriate location in &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. An example is the &lt;code&gt;IS NULL&lt;/code&gt; clause.</source>
          <target state="translated">このリストに加えて、式として分類できるが、一般的な構文規則には従わない構成がいくつかあります。これらは通常、関数または演算子のセマンティクスを持ち、&lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;第9章の&lt;/a&gt;適切な場所で説明されています。例は、 &lt;code&gt;IS NULL&lt;/code&gt; 句です。</target>
        </trans-unit>
        <trans-unit id="1eea807026cd270d625f43d7ed3f99bcbf28a0f1" translate="yes" xml:space="preserve">
          <source>In addition, B-tree and hash indexes can be created for table columns of range types. For these index types, basically the only useful range operation is equality. There is a B-tree sort ordering defined for range values, with corresponding &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; operators, but the ordering is rather arbitrary and not usually useful in the real world. Range types' B-tree and hash support is primarily meant to allow sorting and hashing internally in queries, rather than creation of actual indexes.</source>
          <target state="translated">さらに、範囲型のテーブル列に対してBツリーインデックスとハッシュインデックスを作成できます。これらのインデックスタイプの場合、基本的に唯一有効な範囲演算は等式です。範囲値に対して定義されたBツリーソート順序があり、対応する &lt;code&gt;&amp;lt;&lt;/code&gt; および &lt;code&gt;&amp;gt;&lt;/code&gt; 演算子がありますが、順序はかなり恣意的であり、通常、現実の世界では役に立ちません。範囲型のBツリーとハッシュのサポートは、実際のインデックスを作成するのではなく、クエリの内部で並べ替えとハッシュを許可することを主な目的としています。</target>
        </trans-unit>
        <trans-unit id="ec168afc08cf14d67db79d5a556441966649b178" translate="yes" xml:space="preserve">
          <source>In addition, GIN must have a way to sort the key values stored in the index. The operator class can define the sort ordering by specifying a comparison method:</source>
          <target state="translated">さらに、GINはインデックスに格納されているキー値をソートする方法を持っていなければなりません。演算子クラスは比較方法を指定することでソート順を定義することができます。</target>
        </trans-unit>
        <trans-unit id="9f602065328e166c6745869bc0a8f779ad09a07b" translate="yes" xml:space="preserve">
          <source>In addition, PostgreSQL provides the &lt;code&gt;text&lt;/code&gt; type, which stores strings of any length. Although the type &lt;code&gt;text&lt;/code&gt; is not in the SQL standard, several other SQL database management systems have it as well.</source>
          <target state="translated">さらに、PostgreSQLは、任意の長さの文字列を格納する &lt;code&gt;text&lt;/code&gt; タイプを提供します。タイプ &lt;code&gt;text&lt;/code&gt; はSQL標準にはありませんが、他のいくつかのSQLデータベース管理システムにもあります。</target>
        </trans-unit>
        <trans-unit id="17853e1fa32c480ecb510d4ac68c8ac2c772dace" translate="yes" xml:space="preserve">
          <source>In addition, a &lt;code&gt;cube&lt;/code&gt; GiST index can be used to find nearest neighbors using the metric operators &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;#&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; in &lt;code&gt;ORDER BY&lt;/code&gt; clauses. For example, the nearest neighbor of the 3-D point (0.5, 0.5, 0.5) could be found efficiently with:</source>
          <target state="translated">さらに、 &lt;code&gt;cube&lt;/code&gt; GiSTインデックスを使用して、 &lt;code&gt;ORDER BY&lt;/code&gt; 句でメトリック演算子 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;#&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; を使用して最近傍を検索できます。たとえば、3次元点（0.5、0.5、0.5）の最も近い近傍は、次のようにして効率的に見つけることができます。</target>
        </trans-unit>
        <trans-unit id="cd5ace0daf0d94ba630977ad9ab486e9b148c9ae" translate="yes" xml:space="preserve">
          <source>In addition, any range type that is meant to be used with GiST or SP-GiST indexes should define a subtype difference, or &lt;code&gt;subtype_diff&lt;/code&gt;, function. (The index will still work without &lt;code&gt;subtype_diff&lt;/code&gt;, but it is likely to be considerably less efficient than if a difference function is provided.) The subtype difference function takes two input values of the subtype, and returns their difference (i.e., &lt;code&gt;X&lt;/code&gt; minus &lt;code&gt;Y&lt;/code&gt;) represented as a &lt;code&gt;float8&lt;/code&gt; value. In our example above, the function &lt;code&gt;float8mi&lt;/code&gt; that underlies the regular &lt;code&gt;float8&lt;/code&gt; minus operator can be used; but for any other subtype, some type conversion would be necessary. Some creative thought about how to represent differences as numbers might be needed, too. To the greatest extent possible, the &lt;code&gt;subtype_diff&lt;/code&gt; function should agree with the sort ordering implied by the selected operator class and collation; that is, its result should be positive whenever its first argument is greater than its second according to the sort ordering.</source>
          <target state="translated">さらに、GiSTまたはSP-GiSTインデックスで使用されることを意図した範囲タイプは、サブタイプの差、または &lt;code&gt;subtype_diff&lt;/code&gt; 関数を定義する必要があります。 （インデックスは &lt;code&gt;subtype_diff&lt;/code&gt; がなくても機能しますが、差分関数が提供されている場合よりも効率が大幅に低下する可能性があります。）サブタイプ差分関数は、サブタイプの2つの入力値を取り、それらの差分（つまり &lt;code&gt;X&lt;/code&gt; - &lt;code&gt;Y&lt;/code&gt; ）を返します。 &lt;code&gt;float8&lt;/code&gt; 値として表されます。この例では上記、機能 &lt;code&gt;float8mi&lt;/code&gt; 通常の根底に &lt;code&gt;float8&lt;/code&gt; 型をマイナス演算子を使用できます。ただし、他のサブタイプの場合、何らかのタイプ変換が必要になります。数値が必要になる場合があるので、違いを表現する方法についての創造的な考えも必要です。可能な限り、 &lt;code&gt;subtype_diff&lt;/code&gt; 関数は、選択した演算子クラスと照合順序が意味する並べ替え順序と一致する必要があります。つまり、ソート順序に従って、最初の引数が2番目の引数より大きい場合は常に、その結​​果は正になります。</target>
        </trans-unit>
        <trans-unit id="64cf011fc0c858e7c59c2382a3c5f7cd4046f0f4" translate="yes" xml:space="preserve">
          <source>In addition, it is possible to cast integral values to and from type &lt;code&gt;bit&lt;/code&gt;. Some examples:</source>
          <target state="translated">さらに、 &lt;code&gt;bit&lt;/code&gt; 型との間で整数値をキャストできます。いくつかの例：</target>
        </trans-unit>
        <trans-unit id="326abf040e9ce0b0f36784412502b6466458ab9f" translate="yes" xml:space="preserve">
          <source>In addition, the following functions are available to produce analogous mappings of entire schemas or the entire current database:</source>
          <target state="translated">さらに、スキーマ全体または現在のデータベース全体の類似マッピングを生成するために、以下の関数が利用可能です。</target>
        </trans-unit>
        <trans-unit id="63461f5526d594ea86f45b63caca8ffcfa146455" translate="yes" xml:space="preserve">
          <source>In addition, the system must not be running in single-user mode. Since the entire database system is running in single process in this situation, no background workers will be available.</source>
          <target state="translated">さらに、システムをシングルユーザーモードで実行してはいけません。この状況では、データベースシステム全体が単一プロセスで実行されているため、バックグラウンドワーカーは利用できません。</target>
        </trans-unit>
        <trans-unit id="860432a001dab9d2b568ed0f1f81316664226bda" translate="yes" xml:space="preserve">
          <source>In addition, the system view &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; can be used to view and change session-local values:</source>
          <target state="translated">さらに、システムビュー&lt;a href=&quot;view-pg-settings&quot;&gt; &lt;code&gt;pg_settings&lt;/code&gt; &lt;/a&gt;を使用して、セッションローカル値を表示および変更できます。</target>
        </trans-unit>
        <trans-unit id="22f9e194dfe6bf7349c8ee21bf8580964a36a952" translate="yes" xml:space="preserve">
          <source>In addition, triggers may be defined to fire for &lt;code&gt;TRUNCATE&lt;/code&gt;, though only &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt;.</source>
          <target state="translated">さらに、トリガーは、 &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; のみですが、 &lt;code&gt;TRUNCATE&lt;/code&gt; に対して起動するように定義できます。</target>
        </trans-unit>
        <trans-unit id="d4414e8f828cfe6654891bf2913265775446349f" translate="yes" xml:space="preserve">
          <source>In addition, when the data in the referenced columns is changed, certain actions are performed on the data in this table's columns. The &lt;code&gt;ON DELETE&lt;/code&gt; clause specifies the action to perform when a referenced row in the referenced table is being deleted. Likewise, the &lt;code&gt;ON UPDATE&lt;/code&gt; clause specifies the action to perform when a referenced column in the referenced table is being updated to a new value. If the row is updated, but the referenced column is not actually changed, no action is done. Referential actions other than the &lt;code&gt;NO ACTION&lt;/code&gt; check cannot be deferred, even if the constraint is declared deferrable. There are the following possible actions for each clause:</source>
          <target state="translated">さらに、参照される列のデータが変更されると、このテーブルの列のデータに対して特定のアクションが実行されます。 &lt;code&gt;ON DELETE&lt;/code&gt; 句は、参照されるテーブルで参照される行が削除されているときに実行するアクションを指定します。同様に、 &lt;code&gt;ON UPDATE&lt;/code&gt; 句は、参照されるテーブルの参照される列が新しい値に更新されるときに実行するアクションを指定します。行が更新されても、参照された列が実際には変更されていない場合、アクションは実行されません。 &lt;code&gt;NO ACTION&lt;/code&gt; チェック以外の参照アクションは、制約が延期可能であると宣言されていても延期できません。各句には、次の可能なアクションがあります。</target>
        </trans-unit>
        <trans-unit id="1b40467991cf35c44406fccb1f30c153b6ab6d3c" translate="yes" xml:space="preserve">
          <source>In addition, you can define your own range types; see &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; for more information.</source>
          <target state="translated">さらに、独自の範囲タイプを定義できます。詳細については、「&lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b2973b0fbaf7ec1930d4939e2d5982623781db68" translate="yes" xml:space="preserve">
          <source>In addition, you can find rows where the array has all values equal to 10000 with:</source>
          <target state="translated">さらに、配列のすべての値が10000に等しい行を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="0f950ca6f038e5a1c55d020b4e0e3f34ce9c10d7" translate="yes" xml:space="preserve">
          <source>In all binary operations on differently-dimensioned cubes, I assume the lower-dimensional one to be a Cartesian projection, i. e., having zeroes in place of coordinates omitted in the string representation. The above examples are equivalent to:</source>
          <target state="translated">次元の異なる立方体に対するすべての2値演算において、低次元のものをデカルト投影、すなわち文字列表現で省略された座標の代わりにゼロを持つものとする。上記の例は次のように等価である。</target>
        </trans-unit>
        <trans-unit id="c1f9a66372442ec0201db0ed9f98b148d01d359a" translate="yes" xml:space="preserve">
          <source>In all but the simplest applications, there are various combinations of indexes that might be useful, and the database developer must make trade-offs to decide which indexes to provide. Sometimes multicolumn indexes are best, but sometimes it's better to create separate indexes and rely on the index-combination feature. For example, if your workload includes a mix of queries that sometimes involve only column &lt;code&gt;x&lt;/code&gt;, sometimes only column &lt;code&gt;y&lt;/code&gt;, and sometimes both columns, you might choose to create two separate indexes on &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, relying on index combination to process the queries that use both columns. You could also create a multicolumn index on &lt;code&gt;(x, y)&lt;/code&gt;. This index would typically be more efficient than index combination for queries involving both columns, but as discussed in &lt;a href=&quot;indexes-multicolumn&quot;&gt;Section 11.3&lt;/a&gt;, it would be almost useless for queries involving only &lt;code&gt;y&lt;/code&gt;, so it should not be the only index. A combination of the multicolumn index and a separate index on &lt;code&gt;y&lt;/code&gt; would serve reasonably well. For queries involving only &lt;code&gt;x&lt;/code&gt;, the multicolumn index could be used, though it would be larger and hence slower than an index on &lt;code&gt;x&lt;/code&gt; alone. The last alternative is to create all three indexes, but this is probably only reasonable if the table is searched much more often than it is updated and all three types of query are common. If one of the types of query is much less common than the others, you'd probably settle for creating just the two indexes that best match the common types.</source>
          <target state="translated">最も単純なアプリケーションを除いて、役立つインデックスにはさまざまな組み合わせがあり、データベース開発者はトレードオフを行って、提供するインデックスを決定する必要があります。複数列のインデックスが最適な場合もありますが、個別のインデックスを作成し、インデックスの組み合わせ機能を利用する方が良い場合もあります。たとえば、ワークロードに、列 &lt;code&gt;x&lt;/code&gt; のみ、場合によっては列 &lt;code&gt;y&lt;/code&gt; のみ、場合によっては両方の列が関係するクエリが混在する場合、インデックスの組み合わせに依存するクエリを処理するために、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; に2つの別々のインデックスを作成することを選択できます。両方の列を使用します。 &lt;code&gt;(x, y)&lt;/code&gt; 複数列のインデックスを作成することもできます。このインデックスは通常、両方の列を含むクエリのインデックスの組み合わせよりも効率的ですが、&lt;a href=&quot;indexes-multicolumn&quot;&gt;セクション11.3&lt;/a&gt;で説明したように、 &lt;code&gt;y&lt;/code&gt; のみを含むクエリではほとんど役に立たないため、唯一のインデックスではありません。複数列のインデックスと &lt;code&gt;y&lt;/code&gt; の個別のインデックスの組み合わせは、適度に機能します。 &lt;code&gt;x&lt;/code&gt; のみを含むクエリの場合、マルチカラムインデックスを使用できますが、 &lt;code&gt;x&lt;/code&gt; のインデックスよりも大きいため、低速です。一人で。最後の選択肢は3つすべてのインデックスを作成することですが、これはおそらく、テーブルが更新されるよりもはるかに頻繁に検索され、3つのタイプのクエリすべてが共通である場合にのみ妥当です。クエリのタイプの1つが他のタイプよりも一般的でない場合は、一般的なタイプに最も一致する2つのインデックスのみを作成することで解決するでしょう。</target>
        </trans-unit>
        <trans-unit id="56df2ff3801249dc12f58c24112c401131ecca16" translate="yes" xml:space="preserve">
          <source>In all cases, a &lt;code&gt;pg_depend&lt;/code&gt; entry indicates that the referenced object cannot be dropped without also dropping the dependent object. However, there are several subflavors identified by &lt;code&gt;deptype&lt;/code&gt;:</source>
          <target state="translated">すべての場合において、 &lt;code&gt;pg_depend&lt;/code&gt; エントリは、参照されるオブジェクトを依存オブジェクトも削除せずに削除できないことを示します。しかし、で識別されるいくつかのsubflavorsがある &lt;code&gt;deptype&lt;/code&gt; は：</target>
        </trans-unit>
        <trans-unit id="05533c0a7856fcfbbc14bb309ca83a1575bf0034" translate="yes" xml:space="preserve">
          <source>In all cases, a &lt;code&gt;pg_shdepend&lt;/code&gt; entry indicates that the referenced object cannot be dropped without also dropping the dependent object. However, there are several subflavors identified by &lt;code&gt;deptype&lt;/code&gt;:</source>
          <target state="translated">すべての場合において、 &lt;code&gt;pg_shdepend&lt;/code&gt; エントリは、依存オブジェクトも削除せずに参照オブジェクトを削除できないことを示します。しかし、で識別されるいくつかのsubflavorsがある &lt;code&gt;deptype&lt;/code&gt; は：</target>
        </trans-unit>
        <trans-unit id="dbd9abe4557bc81e394c2c9fabde17d6899807f9" translate="yes" xml:space="preserve">
          <source>In all cases, the &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node will have exactly one child plan, which is the portion of the plan that will be executed in parallel. If the &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node is at the very top of the plan tree, then the entire query will execute in parallel. If it is somewhere else in the plan tree, then only the portion of the plan below it will run in parallel. In the example above, the query accesses only one table, so there is only one plan node other than the &lt;code&gt;Gather&lt;/code&gt; node itself; since that plan node is a child of the &lt;code&gt;Gather&lt;/code&gt; node, it will run in parallel.</source>
          <target state="translated">すべての場合において、 &lt;code&gt;Gather&lt;/code&gt; ノードまたは &lt;code&gt;Gather Merge&lt;/code&gt; ノードには、並列で実行されるプランの一部である子プランが1つだけあります。場合 &lt;code&gt;Gather&lt;/code&gt; や &lt;code&gt;Gather Merge&lt;/code&gt; ノードは、計画ツリーの最上部にある、その後、クエリ全体が並行して実行されます。プランツリーの別の場所にある場合は、その下のプランの部分のみが並列で実行されます。上記の例では、クエリは1つのテーブルのみにアクセスするため、 &lt;code&gt;Gather&lt;/code&gt; ノード自体以外の計画ノードは1つしかありません。その計画ノードは &lt;code&gt;Gather&lt;/code&gt; ノードの子であるため、並行して実行されます。</target>
        </trans-unit>
        <trans-unit id="d4cf1068a339ca5023c2d3ccdb75130df4a1abc8" translate="yes" xml:space="preserve">
          <source>In all cases, the UTC offset associated with a timestamp can be specified explicitly, using either a numeric UTC offset or a time zone abbreviation that corresponds to a fixed UTC offset. The rule just given applies only when it is necessary to infer a UTC offset for a time zone in which the offset varies.</source>
          <target state="translated">全ての場合において、タイムスタンプに関連付けられたUTCオフセットは、数値のUTCオフセットか、固定のUTCオフセットに対応するタイムゾーンの略語を使って、明示的に指定することができます。このルールは、オフセットが変化するタイムゾーンのUTCオフセットを推論する必要がある場合にのみ適用される。</target>
        </trans-unit>
        <trans-unit id="14ea16f2c03b44cd074521f1c44532d0da377b9a" translate="yes" xml:space="preserve">
          <source>In all cases, timezone names and abbreviations are recognized case-insensitively. (This is a change from PostgreSQL versions prior to 8.2, which were case-sensitive in some contexts but not others.)</source>
          <target state="translated">すべての場合において、タイムゾーン名と略語は大文字小文字を区別せずに認識されます。(これは、8.2以前のPostgreSQLのバージョンからの変更点です。)</target>
        </trans-unit>
        <trans-unit id="e488767cd28888258245f00283eb8b0744ce50a3" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;ADD FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function. For B-tree comparison functions and hash functions it is not necessary to specify &lt;code&gt;op_type&lt;/code&gt; since the function's input data type(s) are always the correct ones to use. For B-tree sort support functions and all functions in GiST, SP-GiST and GIN operator classes, it is necessary to specify the operand data type(s) the function is to be used with.</source>
          <target state="translated">で &lt;code&gt;ADD FUNCTION&lt;/code&gt; 関数の入力データ型（複数可）とは異なる場合句、オペランド・データ・タイプ（S）関数は、支持体に意図されます。 Bツリー比較関数とハッシュ関数の場合、関数の入力データ型は常に正しいものであるため、 &lt;code&gt;op_type&lt;/code&gt; を指定する必要はありません。 Bツリーソートサポート関数およびGiST、SP-GiST、GIN演算子クラスのすべての関数の場合、関数で使用するオペランドのデータ型を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="fe60e9f5f727af57aa7582cb64633b2e4aa0e193" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;AFTER&lt;/code&gt; trigger, the &lt;code&gt;WHEN&lt;/code&gt; condition is evaluated just after the row update occurs, and it determines whether an event is queued to fire the trigger at the end of statement. So when an &lt;code&gt;AFTER&lt;/code&gt; trigger's &lt;code&gt;WHEN&lt;/code&gt; condition does not return true, it is not necessary to queue an event nor to re-fetch the row at end of statement. This can result in significant speedups in statements that modify many rows, if the trigger only needs to be fired for a few of the rows.</source>
          <target state="translated">で &lt;code&gt;AFTER&lt;/code&gt; のトリガー、 &lt;code&gt;WHEN&lt;/code&gt; 条件は行の更新が発生した直後に評価し、そのイベントが文の終わりにトリガーを起動するためにキューイングされているか否かを判断します。したがって、 &lt;code&gt;AFTER&lt;/code&gt; トリガーの &lt;code&gt;WHEN&lt;/code&gt; 条件がtrueを返さない場合、イベントをキューに入れる必要も、ステートメントの最後に行を再フェッチする必要もありません。これにより、いくつかの行に対してのみトリガーを起動する必要がある場合、多くの行を変更するステートメントの速度が大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="14d94f7fbda5ba6b714c8d7012a6a4025037bb6e" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;INSERT&lt;/code&gt;, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the row as it was inserted. This is not so useful in trivial inserts, since it would just repeat the data provided by the client. But it can be very handy when relying on computed default values. For example, when using a &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt;&lt;code&gt;serial&lt;/code&gt;&lt;/a&gt; column to provide unique identifiers, &lt;code&gt;RETURNING&lt;/code&gt; can return the ID assigned to a new row:</source>
          <target state="translated">で &lt;code&gt;INSERT&lt;/code&gt; 、に利用可能なデータ &lt;code&gt;RETURNING&lt;/code&gt; は、それが挿入されたように行です。これは、クライアントから提供されたデータを繰り返すだけなので、簡単な挿入ではあまり役に立ちません。ただし、計算されたデフォルト値に依存している場合は非常に便利です。たとえば、&lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt; &lt;code&gt;serial&lt;/code&gt; &lt;/a&gt;列を使用して一意の識別子を提供する場合、 &lt;code&gt;RETURNING&lt;/code&gt; は新しい行に割り当てられたIDを返すことができます。</target>
        </trans-unit>
        <trans-unit id="1b88536e851b3251cb15ede193475eddbb40caec" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;OPERATOR&lt;/code&gt; clause, the operand data type(s) of the operator, or &lt;code&gt;NONE&lt;/code&gt; to signify a left-unary or right-unary operator. The operand data types can be omitted in the normal case where they are the same as the operator class's data type.</source>
          <target state="translated">で &lt;code&gt;OPERATOR&lt;/code&gt; の句、演算子のオペランド・データ・タイプ（複数可）、または &lt;code&gt;NONE&lt;/code&gt; 単項左または右単項演算子を意味します。オペランドのデータ型は、演算子クラスのデータ型と同じである通常の場合は省略できます。</target>
        </trans-unit>
        <trans-unit id="3136757e2f5b87e470c589e7ef9c299933261292" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;OPERATOR&lt;/code&gt; clause, the operand data type(s) of the operator, or &lt;code&gt;NONE&lt;/code&gt; to signify a left-unary or right-unary operator. Unlike the comparable syntax in &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt;, the operand data types must always be specified.</source>
          <target state="translated">で &lt;code&gt;OPERATOR&lt;/code&gt; の句、演算子のオペランド・データ・タイプ（複数可）、または &lt;code&gt;NONE&lt;/code&gt; 単項左または右単項演算子を意味します。 &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; の同等の構文とは異なり、オペランドのデータ型は常に指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="4f4865a4556be6b18a0efd231e79cc53e7a18167" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;UPDATE&lt;/code&gt;, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the new content of the modified row. For example:</source>
          <target state="translated">&lt;code&gt;UPDATE&lt;/code&gt; に利用可能なデータ &lt;code&gt;RETURNING&lt;/code&gt; は、変更された行の新しい内容です。例えば：</target>
        </trans-unit>
        <trans-unit id="a9d42b6946ae8752c916da7ef8c706a7f5db4d3a" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;amgetbitmap&lt;/code&gt; index scan, the access method does not keep an index pin on any of the returned tuples. Therefore it is only safe to use such scans with MVCC-compliant snapshots.</source>
          <target state="translated">で &lt;code&gt;amgetbitmap&lt;/code&gt; インデックス・スキャン、アクセスメソッドは返されるタプルのいずれかのインデックスピンを保持しません。したがって、MVCC準拠のスナップショットでこのようなスキャンを使用するのは安全です。</target>
        </trans-unit>
        <trans-unit id="565ae755fcf3f7ba63623b03ac7404b46ed4ecef" translate="yes" xml:space="preserve">
          <source>In an abstract sense, a running PostgreSQL system produces an indefinitely long sequence of WAL records. The system physically divides this sequence into WAL &lt;em&gt;segment files&lt;/em&gt;, which are normally 16MB apiece (although the segment size can be altered during initdb). The segment files are given numeric names that reflect their position in the abstract WAL sequence. When not using WAL archiving, the system normally creates just a few segment files and then &amp;ldquo;recycles&amp;rdquo; them by renaming no-longer-needed segment files to higher segment numbers. It's assumed that segment files whose contents precede the last checkpoint are no longer of interest and can be recycled.</source>
          <target state="translated">抽象的に言えば、実行中のPostgreSQLシステムは、無制限に長いWALレコードのシーケンスを生成します。システムはこのシーケンスを物理的にWAL &lt;em&gt;セグメントファイル&lt;/em&gt;に&lt;em&gt;分割します&lt;/em&gt;。WAL &lt;em&gt;セグメントファイル&lt;/em&gt;は通常、それぞれ16MBです（ただし、セグメントサイズはinitdb中に変更できます）。セグメントファイルには、抽象的なWALシーケンスでの位置を反映する数値名が付けられます。 WALアーカイブを使用しない場合、システムは通常、いくつかのセグメントファイルを作成し、不要になったセグメントファイルの名前を大きいセグメント番号に変更することで、それらを「リサイクル」します。内容が最後のチェックポイントの前にあるセグメントファイルは、不要になり、リサイクルできると想定されています。</target>
        </trans-unit>
        <trans-unit id="f8ac0a1e1d2b4929b34c74cce531be5f95182b00" translate="yes" xml:space="preserve">
          <source>In an exclusive backup, &lt;code&gt;pg_stop_backup&lt;/code&gt; removes the label file and, if it exists, the &lt;code&gt;tablespace_map&lt;/code&gt; file created by &lt;code&gt;pg_start_backup&lt;/code&gt;. In a non-exclusive backup, the contents of the &lt;code&gt;backup_label&lt;/code&gt; and &lt;code&gt;tablespace_map&lt;/code&gt; are returned in the result of the function, and should be written to files in the backup (and not in the data directory). There is an optional second parameter of type &lt;code&gt;boolean&lt;/code&gt;. If false, the &lt;code&gt;pg_stop_backup&lt;/code&gt; will return immediately after the backup is completed without waiting for WAL to be archived. This behavior is only useful for backup software which independently monitors WAL archiving. Otherwise, WAL required to make the backup consistent might be missing and make the backup useless. When this parameter is set to true, &lt;code&gt;pg_stop_backup&lt;/code&gt; will wait for WAL to be archived when archiving is enabled; on the standby, this means that it will wait only when &lt;code&gt;archive_mode = always&lt;/code&gt;. If write activity on the primary is low, it may be useful to run &lt;code&gt;pg_switch_wal&lt;/code&gt; on the primary in order to trigger an immediate segment switch.</source>
          <target state="translated">排他バックアップでは、 &lt;code&gt;pg_stop_backup&lt;/code&gt; はラベルファイルを削除し、存在する場合は &lt;code&gt;pg_start_backup&lt;/code&gt; によって作成された &lt;code&gt;tablespace_map&lt;/code&gt; ファイルを削除します。非排他バックアップでは、関数の結果として &lt;code&gt;backup_label&lt;/code&gt; および &lt;code&gt;tablespace_map&lt;/code&gt; の内容が返され、バックアップ内の（データディレクトリではなく）ファイルに書き込む必要があります。 &lt;code&gt;boolean&lt;/code&gt; 型のオプションの2番目のパラメーターがあります。 falseの場合、 &lt;code&gt;pg_stop_backup&lt;/code&gt; WALがアーカイブされるのを待たずに、バックアップが完了するとすぐに戻ります。この動作は、WALアーカイブを個別に監視するバックアップソフトウェアでのみ役立ちます。そうしないと、バックアップを整合させるために必要なWALが欠落して、バックアップが役に立たなくなる可能性があります。このパラメーターがtrueに設定されている場合、 &lt;code&gt;pg_stop_backup&lt;/code&gt; はアーカイブが有効になっているときにWALがアーカイブされるのを待ちます。スタンバイでは、これは &lt;code&gt;archive_mode = always&lt;/code&gt; 場合にのみ待機することを意味します。プライマリでの書き込みアクティビティが少ない場合、すぐにセグメントの切り替えをトリガーするために、プライマリで &lt;code&gt;pg_switch_wal&lt;/code&gt; を実行すると便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="e7db342c2003b24a0078e3f7501e15f251fcabd3" translate="yes" xml:space="preserve">
          <source>In an index scan, the index access method is responsible for regurgitating the TIDs of all the tuples it has been told about that match the &lt;em&gt;scan keys&lt;/em&gt;. The access method is &lt;em&gt;not&lt;/em&gt; involved in actually fetching those tuples from the index's parent table, nor in determining whether they pass the scan's visibility test or other conditions.</source>
          <target state="translated">インデックススキャンでは、インデックスアクセスメソッドは、&lt;em&gt;スキャンキー&lt;/em&gt;と一致することが通知されたすべてのタプルのTIDを逆流させる責任があり&lt;em&gt;ます&lt;/em&gt;。アクセス方法は、インデックスの親テーブルからこれらのタプルを実際にフェッチすることにも、スキャンの可視性テストやその他の条件に合格するかを決定することにも関与して&lt;em&gt;いません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f28fd11104e5b0da0e35b4fc535d8db587de4795" translate="yes" xml:space="preserve">
          <source>In an unmodified installation, the file &lt;code&gt;Default&lt;/code&gt; contains all the non-conflicting time zone abbreviations for most of the world. Additional files &lt;code&gt;Australia&lt;/code&gt; and &lt;code&gt;India&lt;/code&gt; are provided for those regions: these files first include the &lt;code&gt;Default&lt;/code&gt; file and then add or modify abbreviations as needed.</source>
          <target state="translated">変更されていないインストールでは、ファイル &lt;code&gt;Default&lt;/code&gt; に、ほとんどの世界で競合しないすべてのタイムゾーン省略形が含まれています。これらの地域には &lt;code&gt;Australia&lt;/code&gt; と &lt;code&gt;India&lt;/code&gt; 追加ファイルが用意されています。これらのファイルには最初に &lt;code&gt;Default&lt;/code&gt; ファイルが含まれており、必要に応じて略語を追加または変更します。</target>
        </trans-unit>
        <trans-unit id="6faf2b1db0e643ecf8d471d0c7a2c045089265e3" translate="yes" xml:space="preserve">
          <source>In any case, the distance to the end of the frame is limited by the distance to the end of the partition, so that for rows near the partition ends the frame might contain fewer rows than elsewhere.</source>
          <target state="translated">いずれにしても、フレームの端までの距離は、パーティションの端までの距離によって制限されるので、パーティションの端に近い行については、フレームは他の場所よりも少ない行を含んでいるかもしれません。</target>
        </trans-unit>
        <trans-unit id="25a8baad62a92191ed853f5bfffb689d16144b1a" translate="yes" xml:space="preserve">
          <source>In archive recovery or standby mode, the server periodically performs &lt;em&gt;restartpoints&lt;/em&gt;, which are similar to checkpoints in normal operation: the server forces all its state to disk, updates the &lt;code&gt;pg_control&lt;/code&gt; file to indicate that the already-processed WAL data need not be scanned again, and then recycles any old log segment files in the &lt;code&gt;pg_wal&lt;/code&gt; directory. Restartpoints can't be performed more frequently than checkpoints in the master because restartpoints can only be performed at checkpoint records. A restartpoint is triggered when a checkpoint record is reached if at least &lt;code&gt;checkpoint_timeout&lt;/code&gt; seconds have passed since the last restartpoint, or if WAL size is about to exceed &lt;code&gt;max_wal_size&lt;/code&gt;. However, because of limitations on when a restartpoint can be performed, &lt;code&gt;max_wal_size&lt;/code&gt; is often exceeded during recovery, by up to one checkpoint cycle's worth of WAL. (&lt;code&gt;max_wal_size&lt;/code&gt; is never a hard limit anyway, so you should always leave plenty of headroom to avoid running out of disk space.)</source>
          <target state="translated">アーカイブリカバリまたはスタンバイモードでは、サーバーは定期的に&lt;em&gt;restartpointsを&lt;/em&gt;実行し&lt;em&gt;ます&lt;/em&gt;。これは通常の操作のチェックポイントと同様です。サーバーはすべての状態をディスクに &lt;code&gt;pg_control&lt;/code&gt; し、pg_controlファイルを更新して、すでに処理されたWALデータを再度スキャンする必要がないことを示します。次に、 &lt;code&gt;pg_wal&lt;/code&gt; ディレクトリ内の古いログセグメントファイルをリサイクルします。リスタートポイントはチェックポイントレコードでのみ実行できるため、マスターのチェックポイントよりも頻繁にリスタートポイントを実行することはできません。最後のリスタート &lt;code&gt;checkpoint_timeout&lt;/code&gt; から少なくともcheckpoint_timeout秒が経過した場合、またはWALサイズが &lt;code&gt;max_wal_size&lt;/code&gt; を超えようとしている場合、チェックポイントレコードに到達すると、リスタートポイントがトリガーされます。ただし、リスタートポイントを実行できるタイミングに制限があるため、リカバリ中に &lt;code&gt;max_wal_size&lt;/code&gt; を超えることがよくあり、最大で1チェックポイントサイクルに相当するWALになります。（ &lt;code&gt;max_wal_size&lt;/code&gt; ても、max_wal_sizeがハードリミットになることはないため、ディスク領域が不足しないように、常に十分な余裕を残してください。）</target>
        </trans-unit>
        <trans-unit id="e983613b50e43472d70dff9ae2842d52027c35fe" translate="yes" xml:space="preserve">
          <source>In autocommit-off mode, you must explicitly abandon any failed transaction by entering &lt;code&gt;ABORT&lt;/code&gt; or &lt;code&gt;ROLLBACK&lt;/code&gt;. Also keep in mind that if you exit the session without committing, your work will be lost.</source>
          <target state="translated">自動コミットオフモードでは、 &lt;code&gt;ABORT&lt;/code&gt; または &lt;code&gt;ROLLBACK&lt;/code&gt; を入力して、失敗したトランザクションを明示的に破棄する必要があります。また、コミットせずにセッションを終了すると、作業が失われることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="b247fa1a8bf50d6b99053c3d0eeaa42c7ba06baa" translate="yes" xml:space="preserve">
          <source>In both cases, the current row of &lt;code&gt;inventory_item&lt;/code&gt; is passed to the function as a single composite-valued argument. Even though &lt;code&gt;.*&lt;/code&gt; does nothing in such cases, using it is good style, since it makes clear that a composite value is intended. In particular, the parser will consider &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;c.*&lt;/code&gt; to refer to a table name or alias, not to a column name, so that there is no ambiguity; whereas without &lt;code&gt;.*&lt;/code&gt;, it is not clear whether &lt;code&gt;c&lt;/code&gt; means a table name or a column name, and in fact the column-name interpretation will be preferred if there is a column named &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">どちらの場合も、 &lt;code&gt;inventory_item&lt;/code&gt; の現在の行は、単一の複合値引数として関数に渡されます。にもかかわらず &lt;code&gt;.*&lt;/code&gt; このような場合には何もしません、それは複合値が意図されていることを明らかにしているので、それを使用して、良いスタイルです。特に、パーサは検討する &lt;code&gt;c&lt;/code&gt; で &lt;code&gt;c.*&lt;/code&gt; テーブル名またはエイリアスに、いない列名を参照するために、あいまいがないのでこと。一方、 &lt;code&gt;.*&lt;/code&gt; がないと、 &lt;code&gt;c&lt;/code&gt; がテーブル名を意味するのか、列名を意味するのかは明確ではありません。実際、 &lt;code&gt;c&lt;/code&gt; という名前の列がある場合、列名の解釈が優先されます。</target>
        </trans-unit>
        <trans-unit id="f76739639f03e7f45a4a9297ea3a846e096a82c7" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">問題が発生した場合は、潜在的な問題とエラーメッセージについて、&lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;と&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;を参照してください。データベースサーバーはターゲットホストで実行されている必要があります。また、libpqフロントエンドライブラリによって使用されるデフォルトの接続設定と環境変数が適用されます。</target>
        </trans-unit>
        <trans-unit id="5db2bd59ec0063d8b571ff86647485295dec81a2" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">問題が発生した場合、潜在的な問題とエラーメッセージの説明については、&lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;および&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;を参照してください。データベースサーバーはターゲットホストで実行されている必要があります。また、libpqフロントエンドライブラリによって使用されるデフォルトの接続設定と環境変数が適用されます。</target>
        </trans-unit>
        <trans-unit id="9ba5e7fcf43f6a46fa23c849e18652c98a11d276" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">問題が発生した場合は、潜在的な問題とエラーメッセージについて、&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;と&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;を参照してください。データベースサーバーはターゲットホストで実行されている必要があります。また、libpqフロントエンドライブラリによって使用されるデフォルトの接続設定と環境変数が適用されます。</target>
        </trans-unit>
        <trans-unit id="6eaaf99e6c52738ae42a85a2ea51714fc0796916" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">問題が発生した場合は、&lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt;および&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;を参照して、潜在的な問題とエラーメッセージの説明を確認してください。データベースサーバーはターゲットホストで実行されている必要があります。また、libpqフロントエンドライブラリによって使用されるデフォルトの接続設定と環境変数が適用されます。</target>
        </trans-unit>
        <trans-unit id="94b403e1d0cfae4a4d06e5a4c5a48eb222d916e0" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">問題が発生した場合は、&lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;と&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;を参照して、潜在的な問題とエラーメッセージの説明を確認してください。データベースサーバーはターゲットホストで実行されている必要があります。また、libpqフロントエンドライブラリによって使用されるデフォルトの接続設定と環境変数が適用されます。</target>
        </trans-unit>
        <trans-unit id="e7c380013a6560b8ccf88c49ec21236d61ed865e" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">問題が発生した場合は、&lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt;と&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;で潜在的な問題とエラーメッセージの説明を参照してください。データベースサーバーはターゲットホストで実行されている必要があります。また、libpqフロントエンドライブラリによって使用されるデフォルトの接続設定と環境変数が適用されます。</target>
        </trans-unit>
        <trans-unit id="a390aa69b768b09463593395199c846120ecabb8" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">問題が発生した場合、潜在的な問題とエラーメッセージの説明については、&lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt;と&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;を参照してください。データベースサーバーはターゲットホストで実行されている必要があります。また、libpqフロントエンドライブラリによって使用されるデフォルトの接続設定と環境変数が適用されます。</target>
        </trans-unit>
        <trans-unit id="93f46ad3e6977f8b4097e1a0c73d806eccff9805" translate="yes" xml:space="preserve">
          <source>In cases where you are accessing single rows randomly within a table, the actual order of the data in the table is unimportant. However, if you tend to access some data more than others, and there is an index that groups them together, you will benefit from using &lt;code&gt;CLUSTER&lt;/code&gt;. If you are requesting a range of indexed values from a table, or a single indexed value that has multiple rows that match, &lt;code&gt;CLUSTER&lt;/code&gt; will help because once the index identifies the table page for the first row that matches, all other rows that match are probably already on the same table page, and so you save disk accesses and speed up the query.</source>
          <target state="translated">テーブル内の単一の行にランダムにアクセスする場合、テーブル内のデータの実際の順序は重要ではありません。ただし、一部のデータに他のデータよりもアクセスする傾向があり、それらをグループ化するインデックスがある場合は、 &lt;code&gt;CLUSTER&lt;/code&gt; を使用するとメリットがあります。あなたがテーブルからインデックスの値の範囲やマッチ、という複数の行保有する1つのインデックスの値を要求している場合は &lt;code&gt;CLUSTER&lt;/code&gt; が役立つのインデックスは、最初の行のテーブルページを識別したらので試合、他のすべての行に一致はおそらくあることすでに同じテーブルページ上にあるため、ディスクアクセスを節約し、クエリを高速化できます。</target>
        </trans-unit>
        <trans-unit id="74c2cf6ed852f4b751c92fd9888cb548968dc00d" translate="yes" xml:space="preserve">
          <source>In certain cases using advisory locking methods, especially in queries involving explicit ordering and &lt;code&gt;LIMIT&lt;/code&gt; clauses, care must be taken to control the locks acquired because of the order in which SQL expressions are evaluated. For example:</source>
          <target state="translated">アドバイザリロックメソッドを使用する特定の場合、特に明示的な順序付けと &lt;code&gt;LIMIT&lt;/code&gt; 句を含むクエリでは、SQL式が評価される順序のため、取得されるロックを制御するように注意する必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="c672c01926d5e97ed50c99a3d3247bc55643b756" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;CREATE TABLE AS&lt;/code&gt;, &lt;code&gt;SELECT INTO&lt;/code&gt; does not allow to specify properties like a table's access method with &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-METHOD&quot;&gt;&lt;code&gt;USING method&lt;/code&gt;&lt;/a&gt; or the table's tablespace with &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-TABLESPACE&quot;&gt;&lt;code&gt;TABLESPACE tablespace_name&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;sql-createtableas&quot;&gt;CREATE TABLE AS&lt;/a&gt; if necessary. Therefore, the default table access method is chosen for the new table. See &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;CREATE TABLE AS&lt;/code&gt; とは対照的に、 &lt;code&gt;SELECT INTO&lt;/code&gt; では、&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-METHOD&quot;&gt; &lt;code&gt;USING method&lt;/code&gt; &lt;/a&gt;使用したテーブルのアクセス方法や&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-TABLESPACE&quot;&gt; &lt;code&gt;TABLESPACE tablespace_name&lt;/code&gt; &lt;/a&gt;を使用したテーブルのテーブルスペースなどのプロパティを指定できません。必要に応じて&lt;a href=&quot;sql-createtableas&quot;&gt;CREATE TABLE ASを&lt;/a&gt;使用します。したがって、新しいテーブルにはデフォルトのテーブルアクセス方法が選択されます。詳細については、&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="61279093682c79c9f5568d5da222628b6973c973" translate="yes" xml:space="preserve">
          <source>In contrast to a &lt;code&gt;setval&lt;/code&gt; call, a &lt;code&gt;RESTART&lt;/code&gt; operation on a sequence is transactional and blocks concurrent transactions from obtaining numbers from the same sequence. If that's not the desired mode of operation, &lt;code&gt;setval&lt;/code&gt; should be used.</source>
          <target state="translated">&lt;code&gt;setval&lt;/code&gt; 呼び出しとは対照的に、シーケンスの &lt;code&gt;RESTART&lt;/code&gt; 操作はトランザクション対応であり、同時トランザクションが同じシーケンスから番号を取得するのをブロックします。それが望ましい動作モードでない場合は、 &lt;code&gt;setval&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c8047479f58f45c6933e1e0d8cbc566b58e46ed0" translate="yes" xml:space="preserve">
          <source>In database jargon, PostgreSQL uses a client/server model. A PostgreSQL session consists of the following cooperating processes (programs):</source>
          <target state="translated">データベースの専門用語では、PostgreSQLはクライアント/サーバモデルを使用します。PostgreSQLのセッションは以下の協力プロセス(プログラム)で構成されています。</target>
        </trans-unit>
        <trans-unit id="4ebcdbe0c3b4b06ac68e78641d8a5ee88bcf9f9b" translate="yes" xml:space="preserve">
          <source>In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. (Note that checkpoints, which are managed by a separate, dedicated auxiliary process, are unaffected.) The default value is 100 buffers. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">各ラウンドでは、バックグラウンドライターによって書き込まれるバッファーはこれだけです。これをゼロに設定すると、バックグラウンド書き込みが無効になります。（独立した専用の補助プロセスによって管理されるチェックポイントは影響を受けないことに注意してください。）デフォルト値は100バッファーです。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="ccd9c3c470f6cf3a148b1b2c45132bef7b97eb77" translate="yes" xml:space="preserve">
          <source>In either case the data to be encrypted is processed as follows:</source>
          <target state="translated">いずれの場合も、暗号化するデータは以下のように処理されます。</target>
        </trans-unit>
        <trans-unit id="306aa7e6b40f133245f13ca709da9e87be03e6ed" translate="yes" xml:space="preserve">
          <source>In either input mode, if you type a semicolon that is not just before or part of a command entry terminator, it is considered a command separator. When you do type a command entry terminator, the multiple statements you've entered will be executed as a single transaction.</source>
          <target state="translated">どちらの入力モードでも、コマンド入力のターミネータの直前または一部ではないセミコロンを入力した場合、それはコマンドの区切り文字とみなされます。コマンド入力のターミネータを入力した場合、入力した複数のステートメントは単一のトランザクションとして実行されます。</target>
        </trans-unit>
        <trans-unit id="52ebde367582fd620a8c225e745609692ba01e89" translate="yes" xml:space="preserve">
          <source>In either notation, parameters that have default values given in the function declaration need not be written in the call at all. But this is particularly useful in named notation, since any combination of parameters can be omitted; while in positional notation parameters can only be omitted from right to left.</source>
          <target state="translated">どちらの記法でも、関数宣言で与えられたデフォルト値を持つパラメータは、呼び出しの中に記述する必要はありません。しかし、これは名前付き記法の場合に特に便利です。 なぜなら、パラメータの任意の組み合わせを省略することができるからです。</target>
        </trans-unit>
        <trans-unit id="d831af293a1db32dece4f56906f01bbc94d110b4" translate="yes" xml:space="preserve">
          <source>In fact all the options that can be applied to a column description in &lt;code&gt;CREATE TABLE&lt;/code&gt; can be used here. Keep in mind however that the default value must satisfy the given constraints, or the &lt;code&gt;ADD&lt;/code&gt; will fail. Alternatively, you can add constraints later (see below) after you've filled in the new column correctly.</source>
          <target state="translated">実際、 &lt;code&gt;CREATE TABLE&lt;/code&gt; の列の説明に適用できるすべてのオプションをここで使用できます。ただし、デフォルト値は指定された制約を満たす必要があることに注意してください。そうしないと、 &lt;code&gt;ADD&lt;/code&gt; が失敗します。または、新しい列に正しく入力した後で、制約を追加することもできます（下記を参照）。</target>
        </trans-unit>
        <trans-unit id="5989a14e7d9d5d4126144b5b3e9ac84c1a4ebc4b" translate="yes" xml:space="preserve">
          <source>In file system terms, a database cluster is a single directory under which all data will be stored. We call this the &lt;em&gt;data directory&lt;/em&gt; or &lt;em&gt;data area&lt;/em&gt;. It is completely up to you where you choose to store your data. There is no default, although locations such as &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; or &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; are popular. To initialize a database cluster, use the command &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;, which is installed with PostgreSQL. The desired file system location of your database cluster is indicated by the &lt;code&gt;-D&lt;/code&gt; option, for example:</source>
          <target state="translated">ファイルシステムの用語では、データベースクラスターは、すべてのデータが格納される単一のディレクトリです。これを&lt;em&gt;データディレクトリ&lt;/em&gt;または&lt;em&gt;データ領域&lt;/em&gt;と呼びます。データの保存場所は完全にあなた次第です。デフォルトはありませんが、 &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; や &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; などの場所が一般的です。データベースクラスタを初期化するには、PostgreSQLとともにインストールされる&lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;コマンドを使用します。データベースクラスターの目的のファイルシステムの場所は、 &lt;code&gt;-D&lt;/code&gt; オプションで指定します。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="c6dec459ff41edebdbf286e5c7e7fa61bacc87ff" translate="yes" xml:space="preserve">
          <source>In general it is unsafe to access tables referenced in rebuild scripts until the rebuild scripts have run to completion; doing so could yield incorrect results or poor performance. Tables not referenced in rebuild scripts can be accessed immediately.</source>
          <target state="translated">一般的に、再構築スクリプトの実行が完了するまで、再構築スクリプトで参照されているテーブルにアクセスすることは安全ではありません。再構築スクリプトで参照されていないテーブルは、すぐにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="d3d408ce8d9c6617962a7ddfab014057b11931d1" translate="yes" xml:space="preserve">
          <source>In general the array &lt;code&gt;expression&lt;/code&gt; must be parenthesized, but the parentheses can be omitted when the expression to be subscripted is just a column reference or positional parameter. Also, multiple subscripts can be concatenated when the original array is multidimensional. For example:</source>
          <target state="translated">一般に、配列 &lt;code&gt;expression&lt;/code&gt; は括弧で囲む必要がありますが、添え字を付ける式が列参照または位置パラメーターだけの場合は括弧を省略できます。また、元の配列が多次元の場合、複数の添え字を連結できます。例えば：</target>
        </trans-unit>
        <trans-unit id="a233c74a23b1b0f950c13008071a2c4108299433" translate="yes" xml:space="preserve">
          <source>In general the row &lt;code&gt;expression&lt;/code&gt; must be parenthesized, but the parentheses can be omitted when the expression to be selected from is just a table reference or positional parameter. For example:</source>
          <target state="translated">一般に、行 &lt;code&gt;expression&lt;/code&gt; は括弧で囲む必要がありますが、選択する式がテーブル参照または位置パラメータだけの場合は括弧を省略できます。例えば：</target>
        </trans-unit>
        <trans-unit id="8c0b63d62e29b9c5a3a626356a3b517fe18e88f9" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;amcheck&lt;/code&gt; can only prove the presence of corruption; it cannot prove its absence.</source>
          <target state="translated">一般に、 &lt;code&gt;amcheck&lt;/code&gt; は破損の存在を証明することしかできません。それが存在しないことを証明することはできません。</target>
        </trans-unit>
        <trans-unit id="9e2bc9fd37cc10d6d4e2c0ce13c42250e4fbbee6" translate="yes" xml:space="preserve">
          <source>In general, a unique constraint is violated if there is more than one row in the table where the values of all of the columns included in the constraint are equal. However, two null values are never considered equal in this comparison. That means even in the presence of a unique constraint it is possible to store duplicate rows that contain a null value in at least one of the constrained columns. This behavior conforms to the SQL standard, but we have heard that other SQL databases might not follow this rule. So be careful when developing applications that are intended to be portable.</source>
          <target state="translated">一般的に、一意制約は、制約に含まれるすべての列の値が等しい表の行が1つ以上ある場合に違反します。しかし、この比較では、2つのヌル値が等しいとみなされることはありません。つまり、一意の制約が存在する場合でも、制約のある列の少なくとも1つにヌル値を含む重複した行を格納することが可能であることを意味します。この動作はSQL標準に準拠していますが、他のSQLデータベースではこのルールに従わない場合があると聞いています。そのため、移植性を目的としたアプリケーションを開発する際には注意が必要です。</target>
        </trans-unit>
        <trans-unit id="2348b93b2ef61033a339bed35843085ef2b630c2" translate="yes" xml:space="preserve">
          <source>In general, if a function is labeled as being safe when it is restricted or unsafe, or if it is labeled as being restricted when it is in fact unsafe, it may throw errors or produce wrong answers when used in a parallel query. C-language functions could in theory exhibit totally undefined behavior if mislabeled, since there is no way for the system to protect itself against arbitrary C code, but in most likely cases the result will be no worse than for any other function. If in doubt, it is probably best to label functions as &lt;code&gt;UNSAFE&lt;/code&gt;.</source>
          <target state="translated">一般に、制限付きまたは安全でないときに関数が安全であるとラベル付けされている場合、または実際に安全ではないときに関数が制限付きであるとラベル付けされている場合、並列クエリで使用すると、エラーがスローされるか、間違った回答が生成されることがあります。システムが任意のCコードからシステムを保護する方法がないため、C言語関数は理論上、誤ったラベルが付けられた場合、完全に未定義の動作を示す可能性がありますが、ほとんどの場合、他の関数よりも結果が悪くなることはありません。疑わしい場合は、関数に &lt;code&gt;UNSAFE&lt;/code&gt; のラベルを付けるのがおそらく最善です。</target>
        </trans-unit>
        <trans-unit id="a7edd5220f4e78ad60a17c1f93de6471bf8d5e1f" translate="yes" xml:space="preserve">
          <source>In general, if a table is grouped, columns that are not listed in &lt;code&gt;GROUP BY&lt;/code&gt; cannot be referenced except in aggregate expressions. An example with aggregate expressions is:</source>
          <target state="translated">一般に、テーブルがグループ化されている場合、 &lt;code&gt;GROUP BY&lt;/code&gt; にリストされていない列は、集計式以外では参照できません。集計式の例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d1c3c9f3417fc6beedd0acdb2d294853319e6a73" translate="yes" xml:space="preserve">
          <source>In general, log shipping between servers running different major PostgreSQL release levels is not possible. It is the policy of the PostgreSQL Global Development Group not to make changes to disk formats during minor release upgrades, so it is likely that running different minor release levels on primary and standby servers will work successfully. However, no formal support for that is offered and you are advised to keep primary and standby servers at the same release level as much as possible. When updating to a new minor release, the safest policy is to update the standby servers first &amp;mdash; a new minor release is more likely to be able to read WAL files from a previous minor release than vice versa.</source>
          <target state="translated">一般に、PostgreSQLの主要なリリースレベルが異なるサーバー間でログ配布を行うことはできません。 PostgreSQLグローバル開発グループのポリシーは、マイナーリリースのアップグレード中にディスクフォーマットを変更しないことです。そのため、プライマリサーバーとスタンバイサーバーで異なるマイナーリリースレベルを実行しても問題なく動作する可能性があります。ただし、そのための正式なサポートは提供されていません。プライマリサーバーとスタンバイサーバーをできるだけ同じリリースレベルに保つことをお勧めします。新しいマイナーリリースに更新する場合、最も安全なポリシーは、最初にスタンバイサーバーを更新することです。新しいマイナーリリースは、以前のマイナーリリースからWALファイルを読み取ることができる可能性が高く、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="379f9f035821f16216f7bd05e1c59664a2c062ce" translate="yes" xml:space="preserve">
          <source>In general, most applications should prefer to store JSON data as &lt;code&gt;jsonb&lt;/code&gt;, unless there are quite specialized needs, such as legacy assumptions about ordering of object keys.</source>
          <target state="translated">一般に、ほとんどのアプリケーションは、オブジェクトキーの順序付けに関する従来の前提など、特別なニーズがない限り、JSONデータを &lt;code&gt;jsonb&lt;/code&gt; として保存することを選択する必要があります。</target>
        </trans-unit>
        <trans-unit id="b5f07f22b350f8a6e38078060fd0e008a551cf3e" translate="yes" xml:space="preserve">
          <source>In general, refer to the documentation of a specific module for the recommended way to load that module.</source>
          <target state="translated">一般的には、そのモジュールをロードするための推奨される方法については、特定のモジュールのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="ee2e987300579f41179429fff2833d7671d0a6f4" translate="yes" xml:space="preserve">
          <source>In general, these operator classes will not outperform the equivalent standard B-tree index methods, and they lack one major feature of the standard B-tree code: the ability to enforce uniqueness. However, they are useful for GIN testing and as a base for developing other GIN operator classes. Also, for queries that test both a GIN-indexable column and a B-tree-indexable column, it might be more efficient to create a multicolumn GIN index that uses one of these operator classes than to create two separate indexes that would have to be combined via bitmap ANDing.</source>
          <target state="translated">一般的に、これらの演算子クラスは同等の標準B-treeインデックスメソッドを上回る性能を発揮することはなく、標準B-treeコードの主要な機能である一意性を強制する機能を欠いています。しかし、これらの演算子クラスはGINのテストや、他のGIN演算子クラスを開発するためのベースとして有用です。また、GINインデックス可能なカラムとB-treeインデックス可能なカラムの両方をテストするクエリの場合、ビットマップANDで結合しなければならない2つの別々のインデックスを作成するよりも、これらの演算子クラスのいずれかを使用する複数カラムのGINインデックスを作成した方が効率的かもしれません。</target>
        </trans-unit>
        <trans-unit id="d2aa893456da765ab903af76d8c63108ae26c6ce" translate="yes" xml:space="preserve">
          <source>In general, these operator classes will not outperform the equivalent standard B-tree index methods, and they lack one major feature of the standard B-tree code: the ability to enforce uniqueness. However, they provide some other features that are not available with a B-tree index, as described below. Also, these operator classes are useful when a multicolumn GiST index is needed, wherein some of the columns are of data types that are only indexable with GiST but other columns are just simple data types. Lastly, these operator classes are useful for GiST testing and as a base for developing other GiST operator classes.</source>
          <target state="translated">一般的に、これらの演算子クラスは、同等の標準 B-tree インデックスメソッドを凌駕することはなく、標準 B-tree コードの主要な機能の 1 つである一意性を強制する機能を欠いています。しかし、以下で説明するように、これらの演算子クラスは、B-tree インデックスでは利用できない他の機能を提供します。また、これらの演算子クラスは、複数列のGiSTインデックスが必要な場合に便利です。最後に、これらの演算子クラスは、GiSTのテストや他のGiST演算子クラスを開発するためのベースとして有用です。</target>
        </trans-unit>
        <trans-unit id="050ef9f5f9df87b4cced8b5539a1b041812d5f42" translate="yes" xml:space="preserve">
          <source>In large tables, performance will be poor unless there is an index on the parent-key field.</source>
          <target state="translated">大きなテーブルでは、親キーフィールドにインデックスがないとパフォーマンスが悪くなります。</target>
        </trans-unit>
        <trans-unit id="4765e35412cfd4a863f019aa0033f2c20c5f4705" translate="yes" xml:space="preserve">
          <source>In lieu of using replication slots, it is possible to prevent the removal of old WAL segments using &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt;, or by storing the segments in an archive using &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;. However, these methods often result in retaining more WAL segments than required, whereas replication slots retain only the number of segments known to be needed. An advantage of these methods is that they bound the space requirement for &lt;code&gt;pg_wal&lt;/code&gt;; there is currently no way to do this using replication slots.</source>
          <target state="translated">レプリケーションスロットを使用する代わりに、&lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt;を使用するか、&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;を使用してアーカイブにセグメントを格納することにより、古いWALセグメントが削除されないようにすることができます。ただし、これらの方法では、多くの場合、必要以上に多くのWALセグメントが保持されますが、複製スロットには、必要であることがわかっている数のセグメントのみが保持されます。これらのメソッドの利点は、それらが &lt;code&gt;pg_wal&lt;/code&gt; のスペース要件を制限することです。現在、複製スロットを使用してこれを行う方法はありません。</target>
        </trans-unit>
        <trans-unit id="84baf4a0766c72c5ea2542a507182c8520343dbe" translate="yes" xml:space="preserve">
          <source>In macOS 10.2 and earlier, instead edit these commands in the file &lt;code&gt;/System/Library/StartupItems/SystemTuning/SystemTuning&lt;/code&gt;.</source>
          <target state="translated">macOS 10.2以前では、代わりに &lt;code&gt;/System/Library/StartupItems/SystemTuning/SystemTuning&lt;/code&gt; ファイルでこれらのコマンドを編集します。</target>
        </trans-unit>
        <trans-unit id="6203855ca7fcb59eaeec22abadb1b2a4087a8203" translate="yes" xml:space="preserve">
          <source>In many practical situations, this assumption is usually satisfied; for example, there might be a GUI in the application that only allows selecting compatible city and ZIP code values to use in a query. But if that's not the case, functional dependencies may not be a viable option.</source>
          <target state="translated">多くの実用的な状況では、この仮定は通常満たされています。例えば、アプリケーションの中には、クエリで使用するために互換性のある都市や郵便番号の値のみを選択できるGUIがあるかもしれません。しかし、そうでない場合、機能的な依存関係は実行可能なオプションではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="4b1075485e703bf16e8ab73df82eb829ce78c033" translate="yes" xml:space="preserve">
          <source>In many situations, turning off &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; for noncritical transactions can provide much of the potential performance benefit of turning off &lt;code&gt;fsync&lt;/code&gt;, without the attendant risks of data corruption.</source>
          <target state="translated">多くの状況で、重要でないトランザクションの&lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;Synchronous_commit&lt;/a&gt;をオフにすると、データが破損するリスクを伴うことなく、 &lt;code&gt;fsync&lt;/code&gt; をオフにした場合のパフォーマンス上の利点の多くが得られます。</target>
        </trans-unit>
        <trans-unit id="194f1c0784b754fb38f29c78dc946b25933f09f6" translate="yes" xml:space="preserve">
          <source>In most cases &lt;code&gt;regexp_matches()&lt;/code&gt; should be used with the &lt;code&gt;g&lt;/code&gt; flag, since if you only want the first match, it's easier and more efficient to use &lt;code&gt;regexp_match()&lt;/code&gt;. However, &lt;code&gt;regexp_match()&lt;/code&gt; only exists in PostgreSQL version 10 and up. When working in older versions, a common trick is to place a &lt;code&gt;regexp_matches()&lt;/code&gt; call in a sub-select, for example:</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;regexp_matches()&lt;/code&gt; は &lt;code&gt;g&lt;/code&gt; フラグと一緒に使用する必要があります。最初の一致のみが必要な場合は、 &lt;code&gt;regexp_match()&lt;/code&gt; を使用する方が簡単で効率的です。ただし、 &lt;code&gt;regexp_match()&lt;/code&gt; はPostgreSQLバージョン10以降にのみ存在します。古いバージョンで作業する場合の一般的なトリックは、 &lt;code&gt;regexp_matches()&lt;/code&gt; 呼び出しを副選択に配置することです。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="d60a20da168de2a263b74b28aa44a9c52da8b217" translate="yes" xml:space="preserve">
          <source>In most cases a &lt;code&gt;DELETE&lt;/code&gt; command also needs to read data from columns in the relation that it is deleting from (e.g., in a &lt;code&gt;WHERE&lt;/code&gt; clause or a &lt;code&gt;RETURNING&lt;/code&gt; clause). In this case, &lt;code&gt;SELECT&lt;/code&gt; rights are also required on the relation, and the appropriate &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policies will be applied in addition to the &lt;code&gt;DELETE&lt;/code&gt; policies. Thus the user must have access to the row(s) being deleted through a &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy in addition to being granted permission to delete the row(s) via a &lt;code&gt;DELETE&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy.</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;DELETE&lt;/code&gt; コマンドは、削除元のリレーション（たとえば、 &lt;code&gt;WHERE&lt;/code&gt; 句または &lt;code&gt;RETURNING&lt;/code&gt; 句）の列からデータを読み取る必要もあります。この場合、リレーションに対して &lt;code&gt;SELECT&lt;/code&gt; 権限も必要であり、 &lt;code&gt;DELETE&lt;/code&gt; ポリシーに加えて適切な &lt;code&gt;SELECT&lt;/code&gt; または &lt;code&gt;ALL&lt;/code&gt; ポリシーが適用されます。したがって、ユーザーは、 &lt;code&gt;DELETE&lt;/code&gt; または &lt;code&gt;ALL&lt;/code&gt; ポリシーを介して行を削除する権限が付与されていることに加えて、 &lt;code&gt;SELECT&lt;/code&gt; または &lt;code&gt;ALL&lt;/code&gt; ポリシーを介して削除される行にアクセスできる必要があります。</target>
        </trans-unit>
        <trans-unit id="82c5561a0275adcd2a2a51ebef8a40a5f37109da" translate="yes" xml:space="preserve">
          <source>In most database designs the majority of columns should be marked not null.</source>
          <target state="translated">ほとんどのデータベース設計では、大部分のカラムはNULLではないとマークされるべきです。</target>
        </trans-unit>
        <trans-unit id="158c99420a44bba9aff343cb614d9616cbae7fa4" translate="yes" xml:space="preserve">
          <source>In most implementations of the &amp;ldquo;not-a-number&amp;rdquo; concept, &lt;code&gt;NaN&lt;/code&gt; is not considered equal to any other numeric value (including &lt;code&gt;NaN&lt;/code&gt;). In order to allow &lt;code&gt;numeric&lt;/code&gt; values to be sorted and used in tree-based indexes, PostgreSQL treats &lt;code&gt;NaN&lt;/code&gt; values as equal, and greater than all non-&lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">「非数」の概念のほとんどの実装では、 &lt;code&gt;NaN&lt;/code&gt; は他の数値（ &lt;code&gt;NaN&lt;/code&gt; を含む）と等しいとは見なされません。 &lt;code&gt;numeric&lt;/code&gt; をソートしてツリーベースのインデックスで使用できるようにするために、PostgreSQLは &lt;code&gt;NaN&lt;/code&gt; 値をすべての非 &lt;code&gt;NaN&lt;/code&gt; 値よりも大きく、等しいものとして扱います。</target>
        </trans-unit>
        <trans-unit id="cd61e39655eeef5b9bf240531ec53c538d27ed8e" translate="yes" xml:space="preserve">
          <source>In named notation, each argument's name is specified using &lt;code&gt;=&amp;gt;&lt;/code&gt; to separate it from the argument expression. For example:</source>
          <target state="translated">名前付き表記では、各引数の名前は &lt;code&gt;=&amp;gt;&lt;/code&gt; を使用して指定され、引数式と区別されます。例えば：</target>
        </trans-unit>
        <trans-unit id="3a49a039bda09447cda5b6ba6fb7b5f06a1662cb" translate="yes" xml:space="preserve">
          <source>In nearly all cases, you'll need some options to make a useful test. The most important options are &lt;code&gt;-c&lt;/code&gt; (number of clients), &lt;code&gt;-t&lt;/code&gt; (number of transactions), &lt;code&gt;-T&lt;/code&gt; (time limit), and &lt;code&gt;-f&lt;/code&gt; (specify a custom script file). See below for a full list.</source>
          <target state="translated">ほとんどすべての場合、有用なテストを行うにはいくつかのオプションが必要になります。最も重要なオプションは、 &lt;code&gt;-c&lt;/code&gt; （クライアント数）、- &lt;code&gt;-t&lt;/code&gt; （トランザクション数）、- &lt;code&gt;-T&lt;/code&gt; （時間制限）、および &lt;code&gt;-f&lt;/code&gt; （カスタムスクリプトファイルを指定）です。完全なリストについては、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="fac5d16972792c7bd805065c712c623a51151c8c" translate="yes" xml:space="preserve">
          <source>In none of these cases is there any provision for schema-qualification; all objects created during bootstrap are expected to be in the &lt;code&gt;pg_catalog&lt;/code&gt; schema.</source>
          <target state="translated">これらのいずれの場合も、スキーマ修飾の規定はありません。ブートストラップ中に作成されたすべてのオブジェクトは、 &lt;code&gt;pg_catalog&lt;/code&gt; スキーマにあることが期待されます。</target>
        </trans-unit>
        <trans-unit id="909fab97f09523721a77cc835152b274f406d63c" translate="yes" xml:space="preserve">
          <source>In normal (non-recovery) mode, if you issue &lt;code&gt;DROP USER&lt;/code&gt; or &lt;code&gt;DROP ROLE&lt;/code&gt; for a role with login capability while that user is still connected then nothing happens to the connected user - they remain connected. The user cannot reconnect however. This behavior applies in recovery also, so a &lt;code&gt;DROP USER&lt;/code&gt; on the primary does not disconnect that user on the standby.</source>
          <target state="translated">通常（非リカバリー）モードでは、そのユーザーがまだ接続しているときに、ログイン機能を持つ &lt;code&gt;DROP ROLE&lt;/code&gt; に対して &lt;code&gt;DROP USER&lt;/code&gt; またはDROP ROLEを発行すると、接続しているユーザーには何も起こりません-接続されたままです。ただし、ユーザーは再接続できません。この動作はリカバリにも適用されるため、プライマリの &lt;code&gt;DROP USER&lt;/code&gt; はスタンバイのそのユーザーを切断しません。</target>
        </trans-unit>
        <trans-unit id="b1729ae1f718e0b63bffb08ae3066f0eb0e77ca2" translate="yes" xml:space="preserve">
          <source>In normal operation, &amp;ldquo;read-only&amp;rdquo; transactions are allowed to use &lt;code&gt;LISTEN&lt;/code&gt; and &lt;code&gt;NOTIFY&lt;/code&gt;, so Hot Standby sessions operate under slightly tighter restrictions than ordinary read-only sessions. It is possible that some of these restrictions might be loosened in a future release.</source>
          <target state="translated">通常の操作では、「読み取り専用」トランザクションは &lt;code&gt;LISTEN&lt;/code&gt; および &lt;code&gt;NOTIFY&lt;/code&gt; を使用できます。そのため、ホットスタンバイセッションは、通常の読み取り専用セッションよりもわずかに厳しい制限の下で動作します。これらの制限の一部は、将来のリリースで緩和される可能性があります。</target>
        </trans-unit>
        <trans-unit id="d3560745e5e4a4c446630441931abacb2898af6f" translate="yes" xml:space="preserve">
          <source>In normal operation, psql provides a prompt with the name of the database to which psql is currently connected, followed by the string &lt;code&gt;=&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">通常の操作では、psqlは、psqlが現在接続されているデータベースの名前と、その後に文字列 &lt;code&gt;=&amp;gt;&lt;/code&gt; が続くプロンプトを提供します。例えば：</target>
        </trans-unit>
        <trans-unit id="cd286c2214fff2e0be18b3ddfb09dfdd0278ddbf" translate="yes" xml:space="preserve">
          <source>In older OpenBSD versions, you will need to build a custom kernel to change the IPC parameters. Make sure that the options &lt;code&gt;SYSVSHM&lt;/code&gt; and &lt;code&gt;SYSVSEM&lt;/code&gt; are enabled, too. (They are by default.) The following shows an example of how to set the various parameters in the kernel configuration file:</source>
          <target state="translated">古いOpenBSDバージョンでは、IPCパラメータを変更するためにカスタムカーネルを構築する必要があります。オプション &lt;code&gt;SYSVSHM&lt;/code&gt; および &lt;code&gt;SYSVSEM&lt;/code&gt; も有効になっていることを確認してください。（これらはデフォルトです。）以下は、カーネル構成ファイルでさまざまなパラメーターを設定する方法の例を示しています。</target>
        </trans-unit>
        <trans-unit id="43d5f374be9ab2b9f725372748b33884cde122b3" translate="yes" xml:space="preserve">
          <source>In older macOS versions, you will need to reboot to have changes in the shared memory parameters take effect. As of 10.5 it is possible to change all but &lt;code&gt;SHMMNI&lt;/code&gt; on the fly, using sysctl. But it's still best to set up your preferred values via &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, so that the values will be kept across reboots.</source>
          <target state="translated">古いバージョンのmacOSでは、共有メモリパラメータの変更を有効にするには、再起動する必要があります。10.5以降、sysctlを使用して、 &lt;code&gt;SHMMNI&lt;/code&gt; を除くすべてをその場で変更することができます。ただし、再起動後も値が保持されるように、/ &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; を介して優先値を設定するのが依然として最善です。</target>
        </trans-unit>
        <trans-unit id="882a1a9442374dfd65845651f73b92d43f44074e" translate="yes" xml:space="preserve">
          <source>In order for the tunnel setup to succeed you must be allowed to connect via &lt;code&gt;ssh&lt;/code&gt; as &lt;code&gt;joe@foo.com&lt;/code&gt;, just as if you had attempted to use &lt;code&gt;ssh&lt;/code&gt; to create a terminal session.</source>
          <target state="translated">トンネルのセットアップを成功させるには、 &lt;code&gt;ssh&lt;/code&gt; を使用してターミナルセッションを作成しようとした場合と同じように、 &lt;code&gt;ssh&lt;/code&gt; を介して &lt;code&gt;joe@foo.com&lt;/code&gt; として接続できる必要があります。</target>
        </trans-unit>
        <trans-unit id="d646fc6f64023e87f7f5096950ae7ce2f2e80423" translate="yes" xml:space="preserve">
          <source>In order to access any schema object, &lt;code&gt;db_schema:search&lt;/code&gt; permission is required on the containing schema. When an object is referenced without schema qualification, schemas on which this permission is not present will not be searched (just as if the user did not have &lt;code&gt;USAGE&lt;/code&gt; privilege on the schema). If an explicit schema qualification is present, an error will occur if the user does not have the requisite permission on the named schema.</source>
          <target state="translated">スキーマオブジェクトにアクセスするには、含まれているスキーマに対する &lt;code&gt;db_schema:search&lt;/code&gt; 権限が必要です。スキーマ修飾なしでオブジェクトが参照されると、この権限が存在しないスキーマは検索されません（ユーザーがスキーマに対する &lt;code&gt;USAGE&lt;/code&gt; 特権を持っていない場合と同様に）。明示的なスキーマ修飾が存在する場合、ユーザーが名前付きスキーマに対する必要な権限を持っていないとエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="233299fd5dfd7550c24147ba5661abe08d2d0d86" translate="yes" xml:space="preserve">
          <source>In order to allow the PostgreSQL query planner to make reasonably informed decisions when optimizing queries, the &lt;a href=&quot;catalog-pg-statistic&quot;&gt;&lt;code&gt;pg_statistic&lt;/code&gt;&lt;/a&gt; data should be up-to-date for all tables used in the query. Normally the &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;autovacuum daemon&lt;/a&gt; will take care of that automatically. But if a table has recently had substantial changes in its contents, you might need to do a manual &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; rather than wait for autovacuum to catch up with the changes.</source>
          <target state="translated">PostgreSQLクエリプランナーがクエリを最適化する際に十分な情報に基づいた決定を行えるようにするには、クエリで使用されるすべてのテーブルの&lt;a href=&quot;catalog-pg-statistic&quot;&gt; &lt;code&gt;pg_statistic&lt;/code&gt; &lt;/a&gt;データを最新にする必要があります。通常、&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;autovacuumデーモン&lt;/a&gt;が自動的に処理します。ただし、テーブルの内容が最近大幅に変更された場合は、autovacuumが変更に追いつくのを待つのではなく、手動で&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="5bbf891d4248cf5667df821377cc8cc7768e14e9" translate="yes" xml:space="preserve">
          <source>In order to be able to copy the initial table data, the role used for the replication connection must have the &lt;code&gt;SELECT&lt;/code&gt; privilege on a published table (or be a superuser).</source>
          <target state="translated">初期テーブルデータをコピーできるようにするには、レプリケーション接続に使用されるロールに、パブリッシュされたテーブルに対する &lt;code&gt;SELECT&lt;/code&gt; 権限が必要です（またはスーパーユーザーである必要があります）。</target>
        </trans-unit>
        <trans-unit id="fcaf64f5cce00b8df1baf8d751f9011467d9dba7" translate="yes" xml:space="preserve">
          <source>In order to bootstrap the database system, a freshly initialized system always contains one predefined role. This role is always a &amp;ldquo;superuser&amp;rdquo;, and by default (unless altered when running &lt;code&gt;initdb&lt;/code&gt;) it will have the same name as the operating system user that initialized the database cluster. Customarily, this role will be named &lt;code&gt;postgres&lt;/code&gt;. In order to create more roles you first have to connect as this initial role.</source>
          <target state="translated">データベースシステムをブートストラップするために、新しく初期化されたシステムには、常に1つの事前定義されたロールが含まれています。このロールは常に「スーパーユーザー」であり、デフォルトでは（ &lt;code&gt;initdb&lt;/code&gt; の実行時に変更されない限り）、データベースクラスターを初期化したオペレーティングシステムユーザーと同じ名前になります。通常、このロールの名前は &lt;code&gt;postgres&lt;/code&gt; になります。さらに多くのロールを作成するには、最初にこの初期ロールとして接続する必要があります。</target>
        </trans-unit>
        <trans-unit id="c0b6ace4aa733c9f867afeaddbd70b1a3a0b54f3" translate="yes" xml:space="preserve">
          <source>In order to calculate the union, intersection, or difference of two queries, the two queries must be &amp;ldquo;union compatible&amp;rdquo;, which means that they return the same number of columns and the corresponding columns have compatible data types, as described in &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt;.</source>
          <target state="translated">2つのクエリのユニオン、インターセクション、または差異を計算するには、2つのクエリが「ユニオン互換」である必要があります。これは、&lt;a href=&quot;typeconv-union-case&quot;&gt;10.5節で&lt;/a&gt;説明するように、同じ数の列を返し、対応する列に互換性のあるデータ型があることを意味します。</target>
        </trans-unit>
        <trans-unit id="4415b6dbba894170e74bcc6996dbfa1fb24cd8d1" translate="yes" xml:space="preserve">
          <source>In order to create a database, the PostgreSQL server must be up and running (see &lt;a href=&quot;server-start&quot;&gt;Section 18.3&lt;/a&gt;).</source>
          <target state="translated">データベースを作成するには、PostgreSQLサーバーが稼働している必要があります（&lt;a href=&quot;server-start&quot;&gt;セクション18.3を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="3f22ae189397eeb8d6d5706a9610e0f700d2bec8" translate="yes" xml:space="preserve">
          <source>In order to emulate a case-insensitive collation as closely as possible, there are &lt;code&gt;citext&lt;/code&gt;-specific versions of a number of string-processing operators and functions. So, for example, the regular expression operators &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt; exhibit the same behavior when applied to &lt;code&gt;citext&lt;/code&gt;: they both match case-insensitively. The same is true for &lt;code&gt;!~&lt;/code&gt; and &lt;code&gt;!~*&lt;/code&gt;, as well as for the &lt;code&gt;LIKE&lt;/code&gt; operators &lt;code&gt;~~&lt;/code&gt; and &lt;code&gt;~~*&lt;/code&gt;, and &lt;code&gt;!~~&lt;/code&gt; and &lt;code&gt;!~~*&lt;/code&gt;. If you'd like to match case-sensitively, you can cast the operator's arguments to &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">大文字と小文字を区別しない照合をできるだけ厳密にエミュレートするために、いくつかの文字列処理演算子と関数の &lt;code&gt;citext&lt;/code&gt; 固有のバージョンがあります。したがって、たとえば、正規表現演算子 &lt;code&gt;~&lt;/code&gt; と &lt;code&gt;~*&lt;/code&gt; は、 &lt;code&gt;citext&lt;/code&gt; に適用すると同じ動作を示します。どちらも大文字と小文字を区別せずに一致します。同じことが &lt;code&gt;!~&lt;/code&gt; と &lt;code&gt;!~*&lt;/code&gt; 、および &lt;code&gt;LIKE&lt;/code&gt; 演算子 &lt;code&gt;~~&lt;/code&gt; と &lt;code&gt;~~*&lt;/code&gt; 、および &lt;code&gt;!~~&lt;/code&gt; と &lt;code&gt;!~~*&lt;/code&gt; も当てはまります。大文字と小文字を区別して一致させたい場合は、演算子の引数を &lt;code&gt;text&lt;/code&gt; にキャストできます。</target>
        </trans-unit>
        <trans-unit id="13c4603c579f552910275f0bbcb4deae55ef3a7a" translate="yes" xml:space="preserve">
          <source>In order to function, this module must be loaded via &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">機能させるには、このモジュールを &lt;code&gt;postgresql.conf&lt;/code&gt; の&lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt;経由でロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="d81c2662b5a84aa8d5b82fab0b4d606e39ebda86" translate="yes" xml:space="preserve">
          <source>In order to measure the run-time cost of each node in the execution plan, the current implementation of &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; adds profiling overhead to query execution. As a result, running &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; on a query can sometimes take significantly longer than executing the query normally. The amount of overhead depends on the nature of the query, as well as the platform being used. The worst case occurs for plan nodes that in themselves require very little time per execution, and on machines that have relatively slow operating system calls for obtaining the time of day.</source>
          <target state="translated">実行プランの各ノードのランタイムコストを測定するために、 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; の現在の実装では、クエリ実行にプロファイリングオーバーヘッドが追加されます。その結果、クエリで &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; を実行すると、通常のクエリの実行よりも大幅に時間がかかる場合があります。オーバーヘッドの量は、クエリの性質、および使用されているプラ​​ットフォームによって異なります。最悪のケースは、実行ごとにほとんど時間を必要としない計画ノード、および時刻を取得するためのオペレーティングシステム呼び出しが比較的遅いマシンで発生します。</target>
        </trans-unit>
        <trans-unit id="8ef25cb15d96bc5ee47cb922c3476dbfcb096c17" translate="yes" xml:space="preserve">
          <source>In order to prevent this, the following applies to all built-in selectivity estimation functions. When planning a query, in order to be able to use stored statistics, the current user must either have &lt;code&gt;SELECT&lt;/code&gt; privilege on the table or the involved columns, or the operator used must be &lt;code&gt;LEAKPROOF&lt;/code&gt; (more accurately, the function that the operator is based on). If not, then the selectivity estimator will behave as if no statistics are available, and the planner will proceed with default or fall-back assumptions.</source>
          <target state="translated">これを防ぐために、以下はすべての組み込み選択性推定関数に適用されます。クエリを計画するとき、保存された統計を使用できるようにするには、現在のユーザーがテーブルまたは関連する列に対する &lt;code&gt;SELECT&lt;/code&gt; 権限を持っているか、使用する演算子が &lt;code&gt;LEAKPROOF&lt;/code&gt; （より正確には、演算子が基づいている関数）である必要があります）。そうでない場合、選択性推定器は統計が利用できないかのように動作し、プランナはデフォルトまたはフォールバックの仮定を続行します。</target>
        </trans-unit>
        <trans-unit id="6b9560d0a190cd0915dff71499a691135e350ab1" translate="yes" xml:space="preserve">
          <source>In ordinary usage, these parameters are set in &lt;code&gt;postgresql.conf&lt;/code&gt;, although superusers can alter them on-the-fly within their own sessions. Typical usage might be:</source>
          <target state="translated">通常の使用では、これらのパラメーターは &lt;code&gt;postgresql.conf&lt;/code&gt; で設定されますが、スーパーユーザーは自分のセッション内でオンザフライで変更できます。一般的な使用法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="70a9b455eedcd0013740b57c24d0da08e7b71441" translate="yes" xml:space="preserve">
          <source>In parameters that specify support function names, you can write a schema name if needed, for example &lt;code&gt;SFUNC = public.sum&lt;/code&gt;. Do not write argument types there, however &amp;mdash; the argument types of the support functions are determined from other parameters.</source>
          <target state="translated">サポート関数名を指定するパラメーターでは、必要に応じてスキーマ名を記述できます（例： &lt;code&gt;SFUNC = public.sum&lt;/code&gt; 。ただし、引数の型をそこに記述しないでください。サポート関数の引数の型は、他のパラメーターから決定されます。</target>
        </trans-unit>
        <trans-unit id="e6503b355c17e530acb3ce1cf1b630a12d5c662a" translate="yes" xml:space="preserve">
          <source>In particular, if there's an index on &lt;code&gt;key&lt;/code&gt;, it will probably be used to fetch just the rows having &lt;code&gt;key = 123&lt;/code&gt;. On the other hand, in</source>
          <target state="translated">特に、 &lt;code&gt;key&lt;/code&gt; にインデックスがある場合、それはおそらく &lt;code&gt;key = 123&lt;/code&gt; を持つ行だけをフェッチするために使用されます。一方、</target>
        </trans-unit>
        <trans-unit id="e4a5dbfbe9955b3dd014a081adfefb7a2337bd07" translate="yes" xml:space="preserve">
          <source>In particular, when a superuser chooses to &lt;code&gt;SET ROLE&lt;/code&gt; to a non-superuser role, they lose their superuser privileges.</source>
          <target state="translated">特に、スーパーユーザーがスーパーユーザー以外の役割に &lt;code&gt;SET ROLE&lt;/code&gt; を設定することを選択すると、スーパーユーザーの特権が失われます。</target>
        </trans-unit>
        <trans-unit id="cc733581aa12ac8119d8135b89e36cf1d9d3b31b" translate="yes" xml:space="preserve">
          <source>In practice one usually relies on the search path for operators, so as not to have to write anything so ugly as that.</source>
          <target state="translated">実際には、通常は演算子の検索パスに依存しているので、これほど醜いことを書く必要はありません。</target>
        </trans-unit>
        <trans-unit id="a48f8184fbeadfd296ca8b91bd2766492182e822" translate="yes" xml:space="preserve">
          <source>In practice the &lt;em&gt;&lt;code&gt;source_sql&lt;/code&gt;&lt;/em&gt; query should always specify &lt;code&gt;ORDER BY 1&lt;/code&gt; to ensure that values with the same &lt;code&gt;row_name&lt;/code&gt; are brought together. However, ordering of the categories within a group is not important. Also, it is essential to be sure that the order of the &lt;em&gt;&lt;code&gt;category_sql&lt;/code&gt;&lt;/em&gt; query's output matches the specified output column order.</source>
          <target state="translated">実際には、&lt;em&gt; &lt;code&gt;source_sql&lt;/code&gt; &lt;/em&gt;クエリは常に &lt;code&gt;ORDER BY 1&lt;/code&gt; を指定して、同じ &lt;code&gt;row_name&lt;/code&gt; の値が確実にまとめられるようにする必要があります。ただし、グループ内のカテゴリの順序は重要ではありません。また、&lt;em&gt; &lt;code&gt;category_sql&lt;/code&gt; &lt;/em&gt;クエリの出力の順序が、指定された出力列の順序と一致していることを確認することも重要です。</target>
        </trans-unit>
        <trans-unit id="1937c987be0e7b4e7465a2a7029e3f9255be3a60" translate="yes" xml:space="preserve">
          <source>In practice the SQL query should always specify &lt;code&gt;ORDER BY 1,2&lt;/code&gt; to ensure that the input rows are properly ordered, that is, values with the same &lt;code&gt;row_name&lt;/code&gt; are brought together and correctly ordered within the row. Notice that &lt;code&gt;crosstab&lt;/code&gt; itself does not pay any attention to the second column of the query result; it's just there to be ordered by, to control the order in which the third-column values appear across the page.</source>
          <target state="translated">実際には、SQLクエリは常に &lt;code&gt;ORDER BY 1,2&lt;/code&gt; を指定して、入力行が適切に順序付けられるようにする必要があります。つまり、同じ &lt;code&gt;row_name&lt;/code&gt; の値がまとめられ、行内で正しく順序付けされます。お知らせ &lt;code&gt;crosstab&lt;/code&gt; クエリ結果の2番目の列に注意を払っていない自分自身を。 3番目の列の値がページ全体に表示される順序を制御するために、順序付けされる場所があります。</target>
        </trans-unit>
        <trans-unit id="81fbb389dcb4a22896ff56ba2f6a26d52f9a0053" translate="yes" xml:space="preserve">
          <source>In practice, it might be best to check the newest child first, if most inserts go into that child. For simplicity, we have shown the trigger's tests in the same order as in other parts of this example.</source>
          <target state="translated">実際には、ほとんどの挿入がその子に入るのであれば、最初に新しい子をチェックするのがベストかもしれません。簡単にするために、この例の他の部分と同じ順番でトリガーのテストを表示しています。</target>
        </trans-unit>
        <trans-unit id="06e0b2a62cd9f4eb01f119bc558152c7a9b61c4c" translate="yes" xml:space="preserve">
          <source>In practice, these commands would be wrapped up in an extension.</source>
          <target state="translated">実際には、これらのコマンドは拡張機能に包まれています。</target>
        </trans-unit>
        <trans-unit id="79f48feff09a5e6beb49de65d5ed928eb6a28410" translate="yes" xml:space="preserve">
          <source>In principle, cross-references from one initial catalog row to another could be written just by writing the preassigned OID of the referenced row in the referencing field. However, that is against project policy, because it is error-prone, hard to read, and subject to breakage if a newly-assigned OID is renumbered. Therefore &lt;code&gt;genbki.pl&lt;/code&gt; provides mechanisms to write symbolic references instead. The rules are as follows:</source>
          <target state="translated">原則として、最初のカタログ行から別の行への相互参照は、参照されるフィールドの事前に割り当てられたOIDを参照フィールドに書き込むだけで書き込むことができます。ただし、エラーが発生しやすく、読みにくく、新しく割り当てられたOIDの番号が変更されると破損する可能性があるため、これはプロジェクトポリシーに違反します。したがって、 &lt;code&gt;genbki.pl&lt;/code&gt; は、代わりにシンボリック参照を書き込むメカニズムを提供します。ルールは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="760cef4da4decce6f6d9b7cb2f206b14f10f3fa4" translate="yes" xml:space="preserve">
          <source>In principle, index-only scans can be used with expression indexes. For example, given an index on &lt;code&gt;f(x)&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is a table column, it should be possible to execute</source>
          <target state="translated">原則として、インデックスのみのスキャンは式インデックスで使用できます。たとえば、 &lt;code&gt;x&lt;/code&gt; がテーブル列である &lt;code&gt;f(x)&lt;/code&gt; のインデックスを指定すると、次のように実行できるはずです。</target>
        </trans-unit>
        <trans-unit id="50939af3586cb58faf973e37d044bc572b91198e" translate="yes" xml:space="preserve">
          <source>In principle, one can use &lt;code&gt;to_tsquery&lt;/code&gt; if you quote the argument:</source>
          <target state="translated">原則として、引数を引用する場合は、 &lt;code&gt;to_tsquery&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="25c4a2a950655d8b26ffa359e0be687cbb7c81cd" translate="yes" xml:space="preserve">
          <source>In principle, we could do an index-only scan on this index to satisfy a query like</source>
          <target state="translated">原理的には、以下のようなクエリを満たすために、このインデックスに対してインデックスのみのスキャンを行うことができます。</target>
        </trans-unit>
        <trans-unit id="5a138e4bb79a7d66b0d4bfaffdffcdcbb5964acf" translate="yes" xml:space="preserve">
          <source>In prior releases of PostgreSQL, this was the default except for the &lt;code&gt;stop&lt;/code&gt; mode.</source>
          <target state="translated">PostgreSQLの以前のリリースでは、これは &lt;code&gt;stop&lt;/code&gt; モードを除いてデフォルトでした。</target>
        </trans-unit>
        <trans-unit id="75324ba26fc4965d2196117750a2a1059aac25a6" translate="yes" xml:space="preserve">
          <source>In prompt 1 normally &lt;code&gt;=&lt;/code&gt;, but &lt;code&gt;@&lt;/code&gt; if the session is in an inactive branch of a conditional block, or &lt;code&gt;^&lt;/code&gt; if in single-line mode, or &lt;code&gt;!&lt;/code&gt; if the session is disconnected from the database (which can happen if &lt;code&gt;\connect&lt;/code&gt; fails). In prompt 2 &lt;code&gt;%R&lt;/code&gt; is replaced by a character that depends on why psql expects more input: &lt;code&gt;-&lt;/code&gt; if the command simply wasn't terminated yet, but &lt;code&gt;*&lt;/code&gt; if there is an unfinished &lt;code&gt;/* ... */&lt;/code&gt; comment, a single quote if there is an unfinished quoted string, a double quote if there is an unfinished quoted identifier, a dollar sign if there is an unfinished dollar-quoted string, or &lt;code&gt;(&lt;/code&gt; if there is an unmatched left parenthesis. In prompt 3 &lt;code&gt;%R&lt;/code&gt; doesn't produce anything.</source>
          <target state="translated">プロンプト1では通常 &lt;code&gt;=&lt;/code&gt; ですが、セッションが条件付きブロックの非アクティブなブランチにある場合は &lt;code&gt;@&lt;/code&gt; 、単一行モードの場合は &lt;code&gt;^&lt;/code&gt; 、または &lt;code&gt;!&lt;/code&gt; セッションがデータベースから切断された場合（ &lt;code&gt;\connect&lt;/code&gt; が失敗した場合に発生する可能性があります）。 2プロンプトで &lt;code&gt;%R&lt;/code&gt; は：psqlのは、複数の入力を期待する理由に依存文字に置き換えられます &lt;code&gt;-&lt;/code&gt; コマンドは、単にまだ終了していなかった場合は、しかし、 &lt;code&gt;*&lt;/code&gt; 未完がある場合は &lt;code&gt;/* ... */&lt;/code&gt; コメント単一引用符であれば未完成の引用符付き文字列、未完成の引用符付き識別子がある場合は二重引用符、未完成のドル引用符付き文字列がある場合はドル記号、または &lt;code&gt;(&lt;/code&gt; 一致しない左括弧がある場合。プロンプト3では、 &lt;code&gt;%R&lt;/code&gt; は何も生成しません。</target>
        </trans-unit>
        <trans-unit id="d2a64129f0b1da1e51ed964ad4579c4ce899b50b" translate="yes" xml:space="preserve">
          <source>In releases prior to 9.6, this parameter also allowed the values &lt;code&gt;archive&lt;/code&gt; and &lt;code&gt;hot_standby&lt;/code&gt;. These are still accepted but mapped to &lt;code&gt;replica&lt;/code&gt;.</source>
          <target state="translated">9.6より前のリリースでは、このパラメーターは値 &lt;code&gt;archive&lt;/code&gt; および &lt;code&gt;hot_standby&lt;/code&gt; も許可していました。これらは引き続き受け入れられますが、 &lt;code&gt;replica&lt;/code&gt; マップされます。</target>
        </trans-unit>
        <trans-unit id="aa88d3807e10330acdc1940359127a25a966338d" translate="yes" xml:space="preserve">
          <source>In short then, the most general recipe for removing a role that has been used to own objects is:</source>
          <target state="translated">要するに、その後、オブジェクトを所有するために使用されている役割を削除するための最も一般的なレシピです。</target>
        </trans-unit>
        <trans-unit id="d436b991362b7fed721dd789926c009b129d872d" translate="yes" xml:space="preserve">
          <source>In short, this is the difference between abbreviations and full names: abbreviations represent a specific offset from UTC, whereas many of the full names imply a local daylight-savings time rule, and so have two possible UTC offsets. As an example, &lt;code&gt;2014-06-04 12:00 America/New_York&lt;/code&gt; represents noon local time in New York, which for this particular date was Eastern Daylight Time (UTC-4). So &lt;code&gt;2014-06-04 12:00 EDT&lt;/code&gt; specifies that same time instant. But &lt;code&gt;2014-06-04 12:00 EST&lt;/code&gt; specifies noon Eastern Standard Time (UTC-5), regardless of whether daylight savings was nominally in effect on that date.</source>
          <target state="translated">つまり、これは略語とフルネームの違いです。略語はUTCからの特定のオフセットを表しますが、フルネームの多くはローカルの夏時間規則を意味するため、2つのUTCオフセットが考えられます。例として、 &lt;code&gt;2014-06-04 12:00 America/New_York&lt;/code&gt; はニューヨークの正午の現地時間を表し、この特定の日付では東部夏時間（UTC-4）でした。したがって、 &lt;code&gt;2014-06-04 12:00 EDT&lt;/code&gt; は同じ時刻を指定しています。しかし、 &lt;code&gt;2014-06-04 12:00 EST&lt;/code&gt; は、夏時間が名目上有効であったかどうかに関係なく、正午の東部標準時（UTC-5）を指定します。</target>
        </trans-unit>
        <trans-unit id="6f11576d9f6f09df7ddccd8a08208061f234c7e9" translate="yes" xml:space="preserve">
          <source>In short, when an RE contains both greedy and non-greedy subexpressions, the total match length is either as long as possible or as short as possible, according to the attribute assigned to the whole RE. The attributes assigned to the subexpressions only affect how much of that match they are allowed to &amp;ldquo;eat&amp;rdquo; relative to each other.</source>
          <target state="translated">つまり、REに貪欲な部分式と貪欲でない部分式の両方が含まれている場合、RE全体に割り当てられている属性に応じて、一致の長さの合計は可能な限り長くなるか、できるだけ短くなります。部分式に割り当てられた属性は、それらが互いに対して相対的に「食べる」ことが許可されている一致の程度にのみ影響します。</target>
        </trans-unit>
        <trans-unit id="aee830ec2c7b69b7f24b10ee81fb051f88d3ea9e" translate="yes" xml:space="preserve">
          <source>In short, while an index-only scan is possible given the two fundamental requirements, it will be a win only if a significant fraction of the table's heap pages have their all-visible map bits set. But tables in which a large fraction of the rows are unchanging are common enough to make this type of scan very useful in practice.</source>
          <target state="translated">要するに、2つの基本的な要件を満たせばインデックスのみのスキャンは可能ですが、テーブルのヒープページのかなりの部分が全可視マップビットが設定されている場合にのみ有効になります。しかし、行の大部分が変更されていないテーブルは、このタイプのスキャンを実際に非常に有用にするのに十分に一般的です。</target>
        </trans-unit>
        <trans-unit id="81308d755ee35ef99db2fb46ff2f6ea4fdc54a8b" translate="yes" xml:space="preserve">
          <source>In simple cases, the concatenation operator discussed above is preferred over direct use of these functions. However, because the concatenation operator is overloaded to serve all three cases, there are situations where use of one of the functions is helpful to avoid ambiguity. For example consider:</source>
          <target state="translated">単純なケースでは、これらの関数を直接使用するよりも、上で説明した連結演算子を使用する方が好ましいです。しかし、連結演算子は3つのケースすべてに対応するためにオーバーロードされているため、曖昧さを避けるためには、いずれかの関数を使用することが有用な状況もあります。例えば、次のように考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="4e5a889e9ac805b7a61b2cef1759227b4c01dc82" translate="yes" xml:space="preserve">
          <source>In some cases &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; shows additional execution statistics beyond the plan node execution times and row counts. For example, Sort and Hash nodes provide extra information:</source>
          <target state="translated">&lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; は、計画ノードの実行時間と行数を超えた追加の実行統計を表示する場合があります。たとえば、SortノードとHashノードは追加情報を提供します。</target>
        </trans-unit>
        <trans-unit id="e8c81b00bcb69c8ee6819bdd31891ee097641a10" translate="yes" xml:space="preserve">
          <source>In some cases it is possible for a single SQL command to fire more than one kind of trigger. For instance an &lt;code&gt;INSERT&lt;/code&gt; with an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause may cause both insert and update operations, so it will fire both kinds of triggers as needed. The transition relations supplied to triggers are specific to their event type; thus an &lt;code&gt;INSERT&lt;/code&gt; trigger will see only the inserted rows, while an &lt;code&gt;UPDATE&lt;/code&gt; trigger will see only the updated rows.</source>
          <target state="translated">場合によっては、単一のSQLコマンドが複数の種類のトリガーを起動する可能性があります。たとえば、 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 句を指定した &lt;code&gt;INSERT&lt;/code&gt; は挿入操作と更新操作の両方を引き起こす可能性があるため、必要に応じて両方の種類のトリガーを起動します。トリガーに提供される遷移関係は、そのイベントタイプに固有です。したがって、 &lt;code&gt;INSERT&lt;/code&gt; トリガーは挿入された行のみを表示し、 &lt;code&gt;UPDATE&lt;/code&gt; トリガーは更新された行のみを表示します。</target>
        </trans-unit>
        <trans-unit id="200831069c2086edb298c7a6b5677910ac8d156b" translate="yes" xml:space="preserve">
          <source>In some cases it is useful to define table functions that can return different column sets depending on how they are invoked. To support this, the table function can be declared as returning the pseudo-type &lt;code&gt;record&lt;/code&gt;. When such a function is used in a query, the expected row structure must be specified in the query itself, so that the system can know how to parse and plan the query. This syntax looks like:</source>
          <target state="translated">呼び出される方法に応じて異なる列セットを返すことができるテーブル関数を定義すると便利な場合があります。これをサポートするために、疑似タイプの &lt;code&gt;record&lt;/code&gt; を返すように表関数を宣言できます。このような関数をクエリで使用する場合、システムはクエリを解析および計画する方法を認識できるように、予想される行構造をクエリ自体に指定する必要があります。この構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="6d89a4f32e25e9b6f4b0aae8fa4c3b33eb2b87fd" translate="yes" xml:space="preserve">
          <source>In some cases it might also be necessary to increase &lt;code&gt;SEMMAP&lt;/code&gt; to be at least on the order of &lt;code&gt;SEMMNS&lt;/code&gt;. If the system has this parameter (many do not), it defines the size of the semaphore resource map, in which each contiguous block of available semaphores needs an entry. When a semaphore set is freed it is either added to an existing entry that is adjacent to the freed block or it is registered under a new map entry. If the map is full, the freed semaphores get lost (until reboot). Fragmentation of the semaphore space could over time lead to fewer available semaphores than there should be.</source>
          <target state="translated">場合によっては、少なくとも &lt;code&gt;SEMMNS&lt;/code&gt; のオーダーになるように &lt;code&gt;SEMMAP&lt;/code&gt; を増やす必要がある場合もあります。システムにこのパラメータがある場合（多くの場合はありません）、セマフォリソースマップのサイズを定義します。使用可能なセマフォの連続する各ブロックにエントリが必要です。セマフォセットが解放されると、解放されたブロックに隣接する既存のエントリに追加されるか、新しいマップエントリの下に登録されます。マップがいっぱいの場合、解放されたセマフォは（再起動するまで）失われます。セマフォスペースの断片化により、時間の経過により、使用可能なセマフォが本来よりも少なくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="c2c835a0ebddfd298ae5463818241acfed988912" translate="yes" xml:space="preserve">
          <source>In some cases several distinct distributions are needed which don't correlate with each other and this is when implicit seed parameter comes in handy:</source>
          <target state="translated">場合によっては、互いに相関しないいくつかの異なる分布が必要な場合があり、このような場合に暗黙のシードパラメータが便利です。</target>
        </trans-unit>
        <trans-unit id="b659c8baf607682082fc2a028333f1abc817539f" translate="yes" xml:space="preserve">
          <source>In some cases the join style is easier to write or faster to execute than the sub-select style.</source>
          <target state="translated">場合によっては、結合スタイルの方がサブセレクトスタイルよりも書きやすく、実行が速いこともあります。</target>
        </trans-unit>
        <trans-unit id="cc280a2801256511a801ad6396d782aaf11a1fd5" translate="yes" xml:space="preserve">
          <source>In some cases the planner will prefer a &amp;ldquo;simple&amp;rdquo; index scan plan:</source>
          <target state="translated">場合によっては、プランナは「単純な」インデックススキャンプランを好むでしょう。</target>
        </trans-unit>
        <trans-unit id="0752bfbb1e8e2f35c9e16d26381cb349bc520d2f" translate="yes" xml:space="preserve">
          <source>In some cases you might wish to know which table a particular row originated from. There is a system column called &lt;code&gt;tableoid&lt;/code&gt; in each table which can tell you the originating table:</source>
          <target state="translated">場合によっては、特定の行がどのテーブルから発生したかを知りたいことがあります。各テーブルには &lt;code&gt;tableoid&lt;/code&gt; と呼ばれるシステム列があり、元のテーブルを確認できます。</target>
        </trans-unit>
        <trans-unit id="85aa180babf965f446d9b4ca6c81be1df71986fd" translate="yes" xml:space="preserve">
          <source>In some cases, a user will know that a given XPath query will return only a single result (perhaps a unique document identifier) &amp;mdash; if used alongside an XPath query returning multiple results, the single-valued result will appear only on the first row of the result. The solution to this is to use the key field as part of a join against a simpler XPath query. As an example:</source>
          <target state="translated">場合によっては、ユーザーは特定のXPathクエリが単一の結果（おそらく一意のドキュメント識別子）しか返さないことを知っています。複数の結果を返すXPathクエリと一緒に使用すると、単一値の結果は最初の行にのみ表示されます結果。これに対する解決策は、より単純なXPathクエリに対する結合の一部としてキーフィールドを使用することです。例として：</target>
        </trans-unit>
        <trans-unit id="ca377880ca6732de73ffe88d7d610d10f88a2a04" translate="yes" xml:space="preserve">
          <source>In some cases, an external storage product can be accessed either via NFS or a lower-level protocol such as iSCSI. In the latter case, the storage appears as a block device and any available file system can be created on it. That approach might relieve the DBA from having to deal with some of the idiosyncrasies of NFS, but of course the complexity of managing remote storage then happens at other levels.</source>
          <target state="translated">場合によっては、外部ストレージ製品は、NFS または iSCSI などの下位レベルのプロトコルを介してアクセスすることができます。後者の場合、ストレージはブロックデバイスとして表示され、利用可能なファイルシステムを作成することができます。このアプローチにより、DBAはNFSの特殊性に対処する必要がなくなるかもしれませんが、もちろんリモートストレージの管理の複雑さは他のレベルで発生します。</target>
        </trans-unit>
        <trans-unit id="4cdce5fe180ac016fd38728542336a4cccb6659d" translate="yes" xml:space="preserve">
          <source>In some cases, queries with visibly different texts might get merged into a single &lt;code&gt;pg_stat_statements&lt;/code&gt; entry. Normally this will happen only for semantically equivalent queries, but there is a small chance of hash collisions causing unrelated queries to be merged into one entry. (This cannot happen for queries belonging to different users or databases, however.)</source>
          <target state="translated">場合によっては、見かけ上異なるテキストを持つクエリが単一の &lt;code&gt;pg_stat_statements&lt;/code&gt; エントリにマージされることがあります。通常、これは意味的に同等のクエリでのみ発生しますが、ハッシュの衝突により、無関係なクエリが1つのエントリにマージされる可能性はわずかです。 （ただし、これは、異なるユーザーまたはデータベースに属するクエリでは発生しません。）</target>
        </trans-unit>
        <trans-unit id="3587765c2705ba8328ac5e625d50c99ae816e4fe" translate="yes" xml:space="preserve">
          <source>In some contexts it is important to be sure that row security is not being applied. For example, when taking a backup, it could be disastrous if row security silently caused some rows to be omitted from the backup. In such a situation, you can set the &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; configuration parameter to &lt;code&gt;off&lt;/code&gt;. This does not in itself bypass row security; what it does is throw an error if any query's results would get filtered by a policy. The reason for the error can then be investigated and fixed.</source>
          <target state="translated">状況によっては、行のセキュリティが適用されていないことを確認することが重要です。たとえば、バックアップを取るときに、行のセキュリティが原因で一部の行がバックアップから省略された場合、それは悲惨な結果になる可能性があります。このような状況では、&lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt;構成パラメーターを &lt;code&gt;off&lt;/code&gt; に設定できます。これ自体は行セキュリティをバイパスしません。クエリの結果がポリシーによってフィルターされる場合は、エラーがスローされます。その後、エラーの理由を調査して修正できます。</target>
        </trans-unit>
        <trans-unit id="b9ce77934cf9885a03a2ac3b7887461d3a1cb010" translate="yes" xml:space="preserve">
          <source>In some contexts, backslashes must be doubled compared to what is shown above, because the generic string-literal parser will also reduce pairs of backslashes to one data character; see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt;.</source>
          <target state="translated">一部のコンテキストでは、上に示したものと比較して、バックスラッシュを2倍にする必要があります。これは、汎用文字列リテラルパーサーがバックスラッシュのペアを1つのデータ文字に減らすためです。&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;4.1.2.1項を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ad2914b6fce7d3aa951198848f0bae1a566122fb" translate="yes" xml:space="preserve">
          <source>In some query plans, it is possible for a subplan node to be executed more than once. For example, the inner index scan will be executed once per outer row in the above nested-loop plan. In such cases, the &lt;code&gt;loops&lt;/code&gt; value reports the total number of executions of the node, and the actual time and rows values shown are averages per-execution. This is done to make the numbers comparable with the way that the cost estimates are shown. Multiply by the &lt;code&gt;loops&lt;/code&gt; value to get the total time actually spent in the node. In the above example, we spent a total of 0.220 milliseconds executing the index scans on &lt;code&gt;tenk2&lt;/code&gt;.</source>
          <target state="translated">一部のクエリプランでは、サブプランノードが複数回実行される可能性があります。たとえば、内部インデックススキャンは、上記のネストされたループプランの外部行ごとに1回実行されます。このような場合、 &lt;code&gt;loops&lt;/code&gt; 値はノードの合計実行数を報告し、表示される実際の時間と行の値は実行ごとの平均です。これは、コスト見積もりが表示される方法と比較できるようにするために行われます。 &lt;code&gt;loops&lt;/code&gt; 値を掛けて、ノードで実際に費やされた合計時間を取得します。上記の例では、 &lt;code&gt;tenk2&lt;/code&gt; でインデックススキャンを実行するのに合計0.220ミリ秒かかりました。</target>
        </trans-unit>
        <trans-unit id="225981494667f7eae039a8f3a624ead9ac2ba414" translate="yes" xml:space="preserve">
          <source>In some situations it is worthwhile to rebuild indexes periodically with the &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; command or a series of individual rebuilding steps.</source>
          <target state="translated">状況によっては、&lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt;コマンドまたは一連の個別の再構築ステップを使用して、定期的にインデックスを再構築する価値があります。</target>
        </trans-unit>
        <trans-unit id="c7e0f45ec00183e0785ecaf537d621d39641ace7" translate="yes" xml:space="preserve">
          <source>In some situations, examining each possible way in which a query can be executed would take an excessive amount of time and memory space. In particular, this occurs when executing queries involving large numbers of join operations. In order to determine a reasonable (not necessarily optimal) query plan in a reasonable amount of time, PostgreSQL uses a &lt;em&gt;Genetic Query Optimizer&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;) when the number of joins exceeds a threshold (see &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt;).</source>
          <target state="translated">状況によっては、クエリを実行する可能な方法をそれぞれ調査するために、過度の時間とメモリ領域が必要になる場合があります。特に、これは、多数の結合操作を含むクエリを実行するときに発生します。妥当な時間内に妥当な（必ずしも最適ではない）クエリプランを決定するために、結合の数がしきい値（&lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_thresholdを&lt;/a&gt;参照）を超えると、PostgreSQLは&lt;em&gt;Genetic Query Optimizer&lt;/em&gt;（&lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;第59章を&lt;/a&gt;参照）を使用します。</target>
        </trans-unit>
        <trans-unit id="b44a40fdd52559ad494c2c8c248a6de473d41182" translate="yes" xml:space="preserve">
          <source>In standby mode, the server continuously applies WAL received from the master server. The standby server can read WAL from a WAL archive (see &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt;) or directly from the master over a TCP connection (streaming replication). The standby server will also attempt to restore any WAL found in the standby cluster's &lt;code&gt;pg_wal&lt;/code&gt; directory. That typically happens after a server restart, when the standby replays again WAL that was streamed from the master before the restart, but you can also manually copy files to &lt;code&gt;pg_wal&lt;/code&gt; at any time to have them replayed.</source>
          <target state="translated">スタンバイモードでは、サーバーはマスターサーバーから受信したWALを継続的に適用します。スタンバイサーバーは、WALアーカイブ（&lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_commandを&lt;/a&gt;参照）から、またはTCP接続を介してマスターから直接（ストリーミングレプリケーション）WALを読み取ることができます。スタンバイサーバーは、スタンバイクラスターの &lt;code&gt;pg_wal&lt;/code&gt; ディレクトリにあるWALの復元も試みます。これは通常、サーバーの再起動後、再起動前にマスターからストリーミングされたWALがスタンバイで再度再生されるときに発生しますが、いつでも手動でファイルを &lt;code&gt;pg_wal&lt;/code&gt; に手動でコピーして再生することもできます。</target>
        </trans-unit>
        <trans-unit id="fe531d3ac4f289af249052c7bd344a8eccac974a" translate="yes" xml:space="preserve">
          <source>In strict SQL, &lt;code&gt;GROUP BY&lt;/code&gt; can only group by columns of the source table but PostgreSQL extends this to also allow &lt;code&gt;GROUP BY&lt;/code&gt; to group by columns in the select list. Grouping by value expressions instead of simple column names is also allowed.</source>
          <target state="translated">厳密なSQLでは、 &lt;code&gt;GROUP BY&lt;/code&gt; はソーステーブルの列でのみグループ化できますが、PostgreSQLはこれを拡張して、 &lt;code&gt;GROUP BY&lt;/code&gt; が選択リストの列でグループ化できるようにします。単純な列名の代わりに値式でグループ化することもできます。</target>
        </trans-unit>
        <trans-unit id="925d63461b4ad93eaf09cda8debcd8a2f6185160" translate="yes" xml:space="preserve">
          <source>In such a column, all entries must use the symbolic format except when writing &lt;code&gt;0&lt;/code&gt; for InvalidOid. (If the column is declared &lt;code&gt;regproc&lt;/code&gt;, you can optionally write &lt;code&gt;-&lt;/code&gt; instead of &lt;code&gt;0&lt;/code&gt;.) &lt;code&gt;genbki.pl&lt;/code&gt; will warn about unrecognized names.</source>
          <target state="translated">このような列では、InvalidOidに &lt;code&gt;0&lt;/code&gt; を書き込む場合を除いて、すべてのエントリでシンボリック形式を使用する必要があります。（カラムが宣言されている場合 &lt;code&gt;regproc&lt;/code&gt; 、必要に応じて書くことができます &lt;code&gt;-&lt;/code&gt; ではなく &lt;code&gt;0&lt;/code&gt; 。） &lt;code&gt;genbki.pl&lt;/code&gt; が認識されない名前について警告します。</target>
        </trans-unit>
        <trans-unit id="f44470ab677292f080ad629e5021dd422bb50329" translate="yes" xml:space="preserve">
          <source>In synchronous multimaster replication, each server can accept write requests, and modified data is transmitted from the original server to every other server before each transaction commits. Heavy write activity can cause excessive locking and commit delays, leading to poor performance. Read requests can be sent to any server. Some implementations use shared disk to reduce the communication overhead. Synchronous multimaster replication is best for mostly read workloads, though its big advantage is that any server can accept write requests &amp;mdash; there is no need to partition workloads between master and standby servers, and because the data changes are sent from one server to another, there is no problem with non-deterministic functions like &lt;code&gt;random()&lt;/code&gt;.</source>
          <target state="translated">同期マルチマスターレプリケーションでは、各サーバーは書き込み要求を受け入れることができ、変更されたデータは各トランザクションがコミットする前に元のサーバーから他のすべてのサーバーに送信されます。書き込みアクティビティが多いと、過度のロックとコミットの遅延が発生し、パフォーマンスが低下する可能性があります。読み取り要求は任意のサーバーに送信できます。一部の実装では、共有ディスクを使用して通信オーバーヘッドを削減しています。同期マルチマスターレプリケーションは、ほとんどの読み取りワークロードに最適ですが、その大きな利点は、任意のサーバーが書き込み要求を受け入れることができることです。マスターサーバーとスタンバイサーバーの間でワークロードを分割する必要がなく、データの変更がサーバー間で送信されるため、 &lt;code&gt;random()&lt;/code&gt; のような非決定的な関数では問題ありません。</target>
        </trans-unit>
        <trans-unit id="7c4b878fdf07a28c13f143cacc8a5bb3f8880019" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;.affix&lt;/code&gt; file every affix flag is described in the following format:</source>
          <target state="translated">で &lt;code&gt;.affix&lt;/code&gt; のファイルすべての接辞フラグは、次の形式で記述されています。</target>
        </trans-unit>
        <trans-unit id="08a1ad04eb220026fbfc94b398836d4cbc2cae8c" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;PRECEDING&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;FOLLOWING&lt;/code&gt; frame options, the &lt;code&gt;offset&lt;/code&gt; must be an expression not containing any variables, aggregate functions, or window functions. The meaning of the &lt;code&gt;offset&lt;/code&gt; depends on the frame mode:</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; &lt;code&gt;PRECEDING&lt;/code&gt; と &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;FOLLOWING&lt;/code&gt; フレームオプション、 &lt;code&gt;offset&lt;/code&gt; 任意の変数、集合関数、又はウィンドウ関数を含まない式でなければなりません。 &lt;code&gt;offset&lt;/code&gt; の意味は、フレームモードによって異なります。</target>
        </trans-unit>
        <trans-unit id="27bf78dd19410e50d81449e21eeb4a9c340ecbaa" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;prepared&lt;/code&gt; mode, pgbench reuses the parse analysis result starting from the second query iteration, so pgbench runs faster than in other modes.</source>
          <target state="translated">で &lt;code&gt;prepared&lt;/code&gt; モード、にpgbenchはこれにpgbench実行速く他のモードに比べて、2番目のクエリ反復から開始解析の解析結果を再利用します。</target>
        </trans-unit>
        <trans-unit id="7dd20a44a8914e7e3854e6b8cc2dd765d950b1b2" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;template0&lt;/code&gt; database, it could be useful to create collations whose encoding does not match the database encoding, since they could match the encodings of databases later cloned from &lt;code&gt;template0&lt;/code&gt;. This would currently have to be done manually.</source>
          <target state="translated">で &lt;code&gt;template0&lt;/code&gt; データベース、そのエンコーディング、彼らが後でからクローン化されたデータベースのエンコーディングと一致する可能性があるため、データベースのエンコーディングと一致しない照合順序を作成するために有用である可能性が &lt;code&gt;template0&lt;/code&gt; 。これは現在、手動で行う必要があります。</target>
        </trans-unit>
        <trans-unit id="ee7442c19df868ba3ec76972f6eb3be85838007a" translate="yes" xml:space="preserve">
          <source>In the ISO week-numbering system, it is possible for early-January dates to be part of the 52nd or 53rd week of the previous year, and for late-December dates to be part of the first week of the next year. For example, &lt;code&gt;2005-01-01&lt;/code&gt; is part of the 53rd week of year 2004, and &lt;code&gt;2006-01-01&lt;/code&gt; is part of the 52nd week of year 2005, while &lt;code&gt;2012-12-31&lt;/code&gt; is part of the first week of 2013. It's recommended to use the &lt;code&gt;isoyear&lt;/code&gt; field together with &lt;code&gt;week&lt;/code&gt; to get consistent results.</source>
          <target state="translated">ISO週番号システムでは、1月上旬の日付を前年の52週目または53週目の一部とし、12月下旬の日付を翌年の最初の週の一部とすることができます。たとえば、 &lt;code&gt;2005-01-01&lt;/code&gt; は2004年の第53週の一部であり、 &lt;code&gt;2006-01-01&lt;/code&gt; は2005年の第52週の一部であり、 &lt;code&gt;2012-12-31&lt;/code&gt; は2013年の第1週の一部です。一貫した結果を得るために、 &lt;code&gt;isoyear&lt;/code&gt; フィールドを &lt;code&gt;week&lt;/code&gt; と一緒に使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="e2cd521bd47287d9192e9d5c00cd5e2a6b143afe" translate="yes" xml:space="preserve">
          <source>In the PostgreSQL parser life is a bit more complicated. There are several different classes of tokens ranging from those that can never be used as an identifier to those that have absolutely no special status in the parser as compared to an ordinary identifier. (The latter is usually the case for functions specified by SQL.) Even reserved key words are not completely reserved in PostgreSQL, but can be used as column labels (for example, &lt;code&gt;SELECT 55 AS CHECK&lt;/code&gt;, even though &lt;code&gt;CHECK&lt;/code&gt; is a reserved key word).</source>
          <target state="translated">PostgreSQLのパーサーライフは少し複雑です。識別子として決して使用できないものから、通常の識別子と比較してパーサーで特別なステータスがまったくないものまで、トークンにはいくつかの異なるクラスがあります。 （後者は、通常、SQLで指定された関数の場合である。）であってもキーワードが完全にはPostgreSQLに予約されていない予約が、（例えば、列ラベルとして使用することができる &lt;code&gt;SELECT 55 AS CHECK&lt;/code&gt; にもかかわらず、 &lt;code&gt;CHECK&lt;/code&gt; 予約キー・ワードです） 。</target>
        </trans-unit>
        <trans-unit id="c06a771ae535ebcc1c02437d6d6edcaa369ff63e" translate="yes" xml:space="preserve">
          <source>In the SQL and POSTGRES styles, day appears before month if DMY field ordering has been specified, otherwise month appears before day. (See &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-INPUT&quot;&gt;Section 8.5.1&lt;/a&gt; for how this setting also affects interpretation of input values.) &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT2-TABLE&quot;&gt;Table 8.15&lt;/a&gt; shows examples.</source>
          <target state="translated">SQLおよびPOSTGRESスタイルでは、DMYフィールドの順序が指定されている場合、日は月の前に表示されます。それ以外の場合、月は日の前に表示されます。（この設定が入力値の解釈にどのように影響するかについては、&lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-INPUT&quot;&gt;8.5.1&lt;/a&gt;項を参照してください。）&lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT2-TABLE&quot;&gt;表8.15に&lt;/a&gt;例を示します。</target>
        </trans-unit>
        <trans-unit id="84b70dca4dd2a2a4e41665aeb47157cc98221d20" translate="yes" xml:space="preserve">
          <source>In the SQL standard, sequences only have a &lt;code&gt;USAGE&lt;/code&gt; privilege, which controls the use of the &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; expression, which is equivalent to the function &lt;code&gt;nextval&lt;/code&gt; in PostgreSQL. The sequence privileges &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; are PostgreSQL extensions. The application of the sequence &lt;code&gt;USAGE&lt;/code&gt; privilege to the &lt;code&gt;currval&lt;/code&gt; function is also a PostgreSQL extension (as is the function itself).</source>
          <target state="translated">SQL標準では、シーケンスには &lt;code&gt;USAGE&lt;/code&gt; 特権のみがあり、これは &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; 式の使用を制御します。これは、PostgreSQLの関数 &lt;code&gt;nextval&lt;/code&gt; と同等です。 &lt;code&gt;SELECT&lt;/code&gt; および &lt;code&gt;UPDATE&lt;/code&gt; のシーケンス権限は、PostgreSQLの拡張機能です。シーケンス &lt;code&gt;USAGE&lt;/code&gt; 特権を &lt;code&gt;currval&lt;/code&gt; 関数に適用することも、PostgreSQL関数の拡張です（関数自体と同様）。</target>
        </trans-unit>
        <trans-unit id="9660d94d0a1b58a81d974d699a1bce336010b697" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the notion of objects in the same schema being owned by different users does not exist. Moreover, some implementations do not allow you to create schemas that have a different name than their owner. In fact, the concepts of schema and user are nearly equivalent in a database system that implements only the basic schema support specified in the standard. Therefore, many users consider qualified names to really consist of &lt;code&gt;user_name.table_name&lt;/code&gt;. This is how PostgreSQL will effectively behave if you create a per-user schema for every user.</source>
          <target state="translated">SQL標準では、同じスキーマ内のオブジェクトが異なるユーザーによって所有されているという概念は存在しません。さらに、一部の実装では、所有者とは異なる名前のスキーマを作成できません。実際、スキーマとユーザーの概念は、標準で指定された基本的なスキーマサポートのみを実装するデータベースシステムではほぼ同等です。したがって、多くのユーザーは、修飾名が実際には &lt;code&gt;user_name.table_name&lt;/code&gt; で構成されていると見なします。これは、ユーザーごとにユーザーごとのスキーマを作成した場合に、PostgreSQLが効果的に動作する方法です。</target>
        </trans-unit>
        <trans-unit id="bce55523e60490fd9a9b255e77d45bae3da990ba" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the optional key word &lt;code&gt;AS&lt;/code&gt; can be omitted before an output column name whenever the new column name is a valid column name (that is, not the same as any reserved keyword). PostgreSQL is slightly more restrictive: &lt;code&gt;AS&lt;/code&gt; is required if the new column name matches any keyword at all, reserved or not. Recommended practice is to use &lt;code&gt;AS&lt;/code&gt; or double-quote output column names, to prevent any possible conflict against future keyword additions.</source>
          <target state="translated">SQL標準では、新しい列名が有効な列名である（つまり、予約済みキーワードと同じではない）場合、出力列名の前にオプションのキーワード &lt;code&gt;AS&lt;/code&gt; を省略できます。 PostgreSQLは少し制限的です。新しい列名が予約済みかどうかにかかわらず、キーワードに一致する場合は &lt;code&gt;AS&lt;/code&gt; が必要です。推奨される方法は、 &lt;code&gt;AS&lt;/code&gt; または二重引用符で囲まれた出力列名を使用して、将来のキーワードの追加との競合を防ぐことです。</target>
        </trans-unit>
        <trans-unit id="60fb33ea7714daeb182a1d8cf938445a4efd08dd" translate="yes" xml:space="preserve">
          <source>In the SQL standard, there is a clear distinction between users and roles, and users do not automatically inherit privileges while roles do. This behavior can be obtained in PostgreSQL by giving roles being used as SQL roles the &lt;code&gt;INHERIT&lt;/code&gt; attribute, while giving roles being used as SQL users the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute. However, PostgreSQL defaults to giving all roles the &lt;code&gt;INHERIT&lt;/code&gt; attribute, for backward compatibility with pre-8.1 releases in which users always had use of permissions granted to groups they were members of.</source>
          <target state="translated">SQL標準では、ユーザーとロールは明確に区別されており、ユーザーがロールを継承しているときに自動的に特権を継承することはありません。この動作は、SQLの役割として使用されている役割を与えることにより、PostgreSQLので得ることができる &lt;code&gt;INHERIT&lt;/code&gt; の SQLユーザーとして使用されている役割与えながら、属性を &lt;code&gt;NOINHERIT&lt;/code&gt; 属性を。ただし、PostgreSQLはデフォルトで、すべてのロールに &lt;code&gt;INHERIT&lt;/code&gt; 属性を付与します。これは、ユーザーがメンバーであるグループに付与された権限を常に使用できる8.1より前のリリースとの下位互換性のためです。</target>
        </trans-unit>
        <trans-unit id="4d55ecfda5316639c09ff6bb19e9602eb2f98338" translate="yes" xml:space="preserve">
          <source>In the SQL standard, there is one other transaction characteristic that can be set with these commands: the size of the diagnostics area. This concept is specific to embedded SQL, and therefore is not implemented in the PostgreSQL server.</source>
          <target state="translated">標準SQLでは、これらのコマンドで設定できるトランザクション特性として、診断領域のサイズがあります。この概念は組み込みSQLに特有のものであり、PostgreSQLサーバには実装されていません。</target>
        </trans-unit>
        <trans-unit id="ed36ad7d98cb4d8fee32b855fb6fed744837b0e0" translate="yes" xml:space="preserve">
          <source>In the SQL-92 standard, an &lt;code&gt;ORDER BY&lt;/code&gt; clause can only use output column names or numbers, while a &lt;code&gt;GROUP BY&lt;/code&gt; clause can only use expressions based on input column names. PostgreSQL extends each of these clauses to allow the other choice as well (but it uses the standard's interpretation if there is ambiguity). PostgreSQL also allows both clauses to specify arbitrary expressions. Note that names appearing in an expression will always be taken as input-column names, not as output-column names.</source>
          <target state="translated">SQL-92標準では、 &lt;code&gt;ORDER BY&lt;/code&gt; 句は出力列名または数値のみを使用できますが、 &lt;code&gt;GROUP BY&lt;/code&gt; 句は入力列名に基づく式のみを使用できます。 PostgreSQLはこれらの各句を拡張して、他の選択も可能にします（ただし、あいまいな場合は標準の解釈を使用します）。 PostgreSQLでは、両方の句で任意の式を指定することもできます。式に現れる名前は、常に出力列名としてではなく、入力列名として解釈されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b054bfec2bce610e705197d361e44d3c2768bb83" translate="yes" xml:space="preserve">
          <source>In the XQuery/XPath data model, a &lt;em&gt;document node&lt;/em&gt; can have either document form (i.e., exactly one top-level element, with only comments and processing instructions outside of it) or content form (with those constraints relaxed). Its equivalent in XPath 1.0, the &lt;em&gt;root node&lt;/em&gt;, can only be in document form. This is part of the reason an &lt;code&gt;xml&lt;/code&gt; value passed as the context item to any PostgreSQL XPath-based function must be in document form.</source>
          <target state="translated">XQuery / XPathデータモデルでは、&lt;em&gt;ドキュメントノード&lt;/em&gt;はドキュメントフォーム（つまり、コメントと処理命令のみが含まれる1つの最上位要素）またはコンテンツフォーム（制約が緩和されたもの）のいずれかを持つことができます。XPath 1.0での同等の&lt;em&gt;ルートノードは&lt;/em&gt;、ドキュメント形式にすることができ&lt;em&gt;ます&lt;/em&gt;。これは、PostgreSQL XPathベースの関数にコンテキスト項目として渡される &lt;code&gt;xml&lt;/code&gt; 値がドキュメント形式でなければならない理由の一部です。</target>
        </trans-unit>
        <trans-unit id="907c04147bb1d71b5f0459b5e753db080d794777" translate="yes" xml:space="preserve">
          <source>In the above example we would be creating a new partition each month, so it might be wise to write a script that generates the required DDL automatically.</source>
          <target state="translated">上記の例では、毎月新しいパーティションを作成しているので、必要なDDLを自動的に生成するスクリプトを書くのが賢明かもしれません。</target>
        </trans-unit>
        <trans-unit id="652407089ebdeac3fe06a048bf54ac1385a35fc9" translate="yes" xml:space="preserve">
          <source>In the above example, the new password isn't actually echoed when typed, but we show what was typed for clarity. As you see, the password is encrypted before it is sent to the client.</source>
          <target state="translated">上の例では、新しいパスワードが入力されても実際にはエコーされませんが、わかりやすくするために入力された内容を表示しています。ご覧のように、パスワードはクライアントに送信される前に暗号化されています。</target>
        </trans-unit>
        <trans-unit id="a28671e837ffe13c54dd539a74a6f7de604de65e" translate="yes" xml:space="preserve">
          <source>In the above output, the free space figures may not match the &lt;code&gt;pgstattuple&lt;/code&gt; output exactly, because the free space map gives us an exact figure, but is not guaranteed to be accurate to the byte.</source>
          <target state="translated">上記の出力では、フリースペースマップは正確な数値を提供しますが、バイトに対して正確であることが保証されていないため、フリースペースの数値は &lt;code&gt;pgstattuple&lt;/code&gt; の出力と正確に一致しない場合があります。</target>
        </trans-unit>
        <trans-unit id="cfee998fb713aa32e0b0a461f86fb14fa87aa018" translate="yes" xml:space="preserve">
          <source>In the above queries, the second form is dangerous because the &lt;code&gt;LIMIT&lt;/code&gt; is not guaranteed to be applied before the locking function is executed. This might cause some locks to be acquired that the application was not expecting, and hence would fail to release (until it ends the session). From the point of view of the application, such locks would be dangling, although still viewable in &lt;code&gt;pg_locks&lt;/code&gt;.</source>
          <target state="translated">上記のクエリでは、ロック関数が実行される前に &lt;code&gt;LIMIT&lt;/code&gt; が適用されることが保証されていないため、2番目の形式は危険です。これにより、アプリケーションが予期していなかったいくつかのロックが取得される可能性があり、そのため（セッションが終了するまで）解放に失敗します。アプリケーションの観点から見ると、このようなロックはぶら下がっていますが、 &lt;code&gt;pg_locks&lt;/code&gt; では引き続き表示されます。</target>
        </trans-unit>
        <trans-unit id="0422400fe004db1267465196296a34921629ca1c" translate="yes" xml:space="preserve">
          <source>In the above query, the arguments &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are specified positionally, while &lt;code&gt;uppercase&lt;/code&gt; is specified by name. In this example, that adds little except documentation. With a more complex function having numerous parameters that have default values, named or mixed notation can save a great deal of writing and reduce chances for error.</source>
          <target state="translated">上記のクエリでは、引数 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; は位置的に指定されてい &lt;code&gt;uppercase&lt;/code&gt; が、大文字は名前で指定されています。この例では、ドキュメント以外はほとんど追加されていません。デフォルト値を持つ多数のパラメーターを持つより複雑な関数を使用すると、名前付き表記または混合表記により、大量の書き込みを節約し、エラーの可能性を減らすことができます。</target>
        </trans-unit>
        <trans-unit id="12fe4f57925256d624bd6eb274cf2330b45da284" translate="yes" xml:space="preserve">
          <source>In the absence of fatal errors, pg_receivewal will run until terminated by the SIGINT signal (&lt;strong&gt;Control&lt;/strong&gt;+&lt;strong&gt;C&lt;/strong&gt;).</source>
          <target state="translated">致命的なエラーがない場合、pg_receivewalはSIGINTシグナル（&lt;strong&gt;Control&lt;/strong&gt; + &lt;strong&gt;C&lt;/strong&gt;）によって終了されるまで実行されます。</target>
        </trans-unit>
        <trans-unit id="e6c9650fa107be76e508c9f6a766e1575673cf8c" translate="yes" xml:space="preserve">
          <source>In the alternative format:</source>
          <target state="translated">代替フォーマットで</target>
        </trans-unit>
        <trans-unit id="c2e1ceee33301b36828cf2caae1f68eec137b740" translate="yes" xml:space="preserve">
          <source>In the case of a parallel dump, the snapshot name defined by this option is used rather than taking a new snapshot.</source>
          <target state="translated">並列ダンプの場合、新しいスナップショットを取るのではなく、このオプションで定義されたスナップショット名が使用されます。</target>
        </trans-unit>
        <trans-unit id="2a04ddae39deed0bb63ddc81c6701d5c2ad86b55" translate="yes" xml:space="preserve">
          <source>In the case of a partitioned table, updating a row might cause it to no longer satisfy the partition constraint of the containing partition. In that case, if there is some other partition in the partition tree for which this row satisfies its partition constraint, then the row is moved to that partition. If there is no such partition, an error will occur. Behind the scenes, the row movement is actually a &lt;code&gt;DELETE&lt;/code&gt; and &lt;code&gt;INSERT&lt;/code&gt; operation.</source>
          <target state="translated">パーティション化されたテーブルの場合、行を更新すると、それが含まれているパーティションのパーティション制約を満たさなくなる可能性があります。その場合、この行がそのパーティション制約を満たすパーティションツリーに他のパーティションがある場合、行はそのパーティションに移動されます。そのようなパーティションがない場合、エラーが発生します。舞台裏では、行の移動は実際には &lt;code&gt;DELETE&lt;/code&gt; および &lt;code&gt;INSERT&lt;/code&gt; 操作です。</target>
        </trans-unit>
        <trans-unit id="5544906e3d293a0a9ad12a92567f1204d11f1dd6" translate="yes" xml:space="preserve">
          <source>In the case of an exclusion constraint, &lt;code&gt;conkey&lt;/code&gt; is only useful for constraint elements that are simple column references. For other cases, a zero appears in &lt;code&gt;conkey&lt;/code&gt; and the associated index must be consulted to discover the expression that is constrained. (&lt;code&gt;conkey&lt;/code&gt; thus has the same contents as &lt;code&gt;pg_index&lt;/code&gt;.&lt;code&gt;indkey&lt;/code&gt; for the index.)</source>
          <target state="translated">除外制約の場合、 &lt;code&gt;conkey&lt;/code&gt; は単純な列参照である制約要素にのみ役立ちます。その他の場合、 &lt;code&gt;conkey&lt;/code&gt; にゼロが表示され、制約されている式を見つけるために関連するインデックスを調べる必要があります。（ &lt;code&gt;conkey&lt;/code&gt; は従って同様の内容を有する &lt;code&gt;pg_index&lt;/code&gt; 。 &lt;code&gt;indkey&lt;/code&gt; インデックスために）。</target>
        </trans-unit>
        <trans-unit id="e4fef774ebd3ff2e38db3236bd03a350ace1f35c" translate="yes" xml:space="preserve">
          <source>In the common case where you just want the whole matching substring or &lt;code&gt;NULL&lt;/code&gt; for no match, write something like</source>
          <target state="translated">一致する部分文字列全体または一致しない場合は &lt;code&gt;NULL&lt;/code&gt; が必要な一般的なケースでは、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="d8de3d9b49ffb3cc570c884fc7d3dde953f8a262" translate="yes" xml:space="preserve">
          <source>In the context of &lt;code&gt;INSERT&lt;/code&gt;, entries of a &lt;code&gt;VALUES&lt;/code&gt; list can be &lt;code&gt;DEFAULT&lt;/code&gt; to indicate that the column default should be used here instead of specifying a value:</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; のコンテキストでは、 &lt;code&gt;VALUES&lt;/code&gt; リストのエントリを &lt;code&gt;DEFAULT&lt;/code&gt; にして、値を指定する代わりに列のデフォルトをここで使用する必要があることを示すことができます。</target>
        </trans-unit>
        <trans-unit id="0a8a6bb89f9ea4433f27de55629e036adfed0508" translate="yes" xml:space="preserve">
          <source>In the current implementation, the fitness of each candidate join sequence is estimated by running the standard planner's join selection and cost estimation code from scratch. To the extent that different candidates use similar sub-sequences of joins, a great deal of work will be repeated. This could be made significantly faster by retaining cost estimates for sub-joins. The problem is to avoid expending unreasonable amounts of memory on retaining that state.</source>
          <target state="translated">現在の実装では、各候補の結合シーケンスの適合性は、標準プランナーの結合選択とコスト推定コードをスクラッチから実行することで推定されます。異なる候補が類似した部分結合列を使用する範囲では、多くの作業が繰り返されます。これは、部分結合のコスト見積もりを保持することで、大幅に高速化することができます。問題は、その状態を保持するために不合理な量のメモリを消費しないようにすることです。</target>
        </trans-unit>
        <trans-unit id="7b88d112fefbb18a9a94530a4a12e322eca2805d" translate="yes" xml:space="preserve">
          <source>In the default PostgreSQL configuration, the autovacuum daemon (see &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt;) takes care of automatic analyzing of tables when they are first loaded with data, and as they change throughout regular operation. When autovacuum is disabled, it is a good idea to run &lt;code&gt;ANALYZE&lt;/code&gt; periodically, or just after making major changes in the contents of a table. Accurate statistics will help the planner to choose the most appropriate query plan, and thereby improve the speed of query processing. A common strategy for read-mostly databases is to run &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; and &lt;code&gt;ANALYZE&lt;/code&gt; once a day during a low-usage time of day. (This will not be sufficient if there is heavy update activity.)</source>
          <target state="translated">デフォルトのPostgreSQL構成では、autovacuumデーモン（&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;セクション24.1.6を&lt;/a&gt;参照）は、テーブルに最初にデータがロードされたとき、および通常の操作を通じて変更されるときに、テーブルの自動分析を処理します。自動バキュームが無効になっている場合は、定期的に、またはテーブルの内容に大きな変更を加えた直後に &lt;code&gt;ANALYZE&lt;/code&gt; を実行することをお勧めします。正確な統計は、プランナが最も適切なクエリプランを選択するのに役立ち、クエリ処理の速度を向上させます。 read-mostlyデータベースの一般的な戦略は、1日1回、使用率の低い時間帯に&lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt;と &lt;code&gt;ANALYZE&lt;/code&gt; を実行することです。 （これは、大量の更新アクティビティがある場合は十分ではありません。）</target>
        </trans-unit>
        <trans-unit id="4ce2b63a8b5343bbf7125e0114e2a04ce0d2bde8" translate="yes" xml:space="preserve">
          <source>In the default setup this returns:</source>
          <target state="translated">デフォルトの設定では、この値が返されます。</target>
        </trans-unit>
        <trans-unit id="596bcd2b70e5eeabccdcbaf0d79d2c517c798e21" translate="yes" xml:space="preserve">
          <source>In the event of a binary upgrade, upward compatibility is maintained by having the new code recognize old-format data. This will entail a slight performance penalty when processing data that has not yet been modified by the new code. It is possible to force an upgrade of all values in a table column by doing an &lt;code&gt;UPDATE&lt;/code&gt; statement as follows:</source>
          <target state="translated">バイナリアップグレードの場合、新しいコードに古い形式のデータを認識させることにより、上位互換性が維持されます。これにより、新しいコードによってまだ変更されていないデータを処理するときに、パフォーマンスがわずかに低下します。次のように &lt;code&gt;UPDATE&lt;/code&gt; ステートメントを実行すると、テーブル列のすべての値を強制的にアップグレードできます。</target>
        </trans-unit>
        <trans-unit id="b3a7ad5f630b85b752ae07e66abff996aa3b1a24" translate="yes" xml:space="preserve">
          <source>In the event that an RE could match more than one substring of a given string, the RE matches the one starting earliest in the string. If the RE could match more than one substring starting at that point, either the longest possible match or the shortest possible match will be taken, depending on whether the RE is &lt;em&gt;greedy&lt;/em&gt; or &lt;em&gt;non-greedy&lt;/em&gt;.</source>
          <target state="translated">REが特定の文字列の複数の部分文字列に一致する可能性がある場合、REは文字列の最初の文字列に一致します。REは、その時点で始まるサブストリングつ以上一致することができれば、可能な最長一致もしくは最短一致のいずれかをREであるかどうかに応じて、取られる&lt;em&gt;貪欲&lt;/em&gt;または&lt;em&gt;非貪欲&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="474b9960977cbbea61dc4ac5b333f0b736c6264c" translate="yes" xml:space="preserve">
          <source>In the example above we see that the resulting &lt;code&gt;tsvector&lt;/code&gt; does not contain the words &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, or &lt;code&gt;it&lt;/code&gt;, the word &lt;code&gt;rats&lt;/code&gt; became &lt;code&gt;rat&lt;/code&gt;, and the punctuation sign &lt;code&gt;-&lt;/code&gt; was ignored.</source>
          <target state="translated">上記の例では、結果の &lt;code&gt;tsvector&lt;/code&gt; に &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;on&lt;/code&gt; 、または &lt;code&gt;it&lt;/code&gt; という単語が含まれておらず、 &lt;code&gt;rats&lt;/code&gt; という単語が &lt;code&gt;rat&lt;/code&gt; になり、句読記号 &lt;code&gt;-&lt;/code&gt; が無視されたことがわかります。</target>
        </trans-unit>
        <trans-unit id="200ce56337643046a5aa2dd5558bb50f57584421" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;WHERE&lt;/code&gt; clause is selecting rows by a column that is not grouped (the expression is only true for sales during the last four weeks), while the &lt;code&gt;HAVING&lt;/code&gt; clause restricts the output to groups with total gross sales over 5000. Note that the aggregate expressions do not necessarily need to be the same in all parts of the query.</source>
          <target state="translated">上記の例では、 &lt;code&gt;WHERE&lt;/code&gt; 句はグループ化されていない列によって行を選択しています（式は過去4週間の売上高にのみ当てはまります）が、 &lt;code&gt;HAVING&lt;/code&gt; 句は総売上高が5000を超えるグループに出力を制限します。集計式は必ずしもクエリのすべての部分で同じである必要はありません。</target>
        </trans-unit>
        <trans-unit id="31c0dc4f6c95bec1ccb804da7ba6806c38ecea92" translate="yes" xml:space="preserve">
          <source>In the example above, the working table has just a single row in each step, and it takes on the values from 1 through 100 in successive steps. In the 100th step, there is no output because of the &lt;code&gt;WHERE&lt;/code&gt; clause, and so the query terminates.</source>
          <target state="translated">上記の例では、作業テーブルには各ステップで1つの行しかなく、連続するステップで1から100までの値を取ります。 100番目のステップでは、 &lt;code&gt;WHERE&lt;/code&gt; 句のために出力がないため、クエリは終了します。</target>
        </trans-unit>
        <trans-unit id="652a8b18a910fe23a9af73c94ce5d441558f1e6b" translate="yes" xml:space="preserve">
          <source>In the examples above, the parser sees an integer array on one side of the concatenation operator, and a constant of undetermined type on the other. The heuristic it uses to resolve the constant's type is to assume it's of the same type as the operator's other input &amp;mdash; in this case, integer array. So the concatenation operator is presumed to represent &lt;code&gt;array_cat&lt;/code&gt;, not &lt;code&gt;array_append&lt;/code&gt;. When that's the wrong choice, it could be fixed by casting the constant to the array's element type; but explicit use of &lt;code&gt;array_append&lt;/code&gt; might be a preferable solution.</source>
          <target state="translated">上記の例では、パーサーは連結演算子の一方の側に整数配列を、もう一方の側に不定型の定数を認識しています。定数の型を解決するために使用するヒューリスティックは、定数が演算子の他の入力と同じ型（この場合は整数配列）であると想定することです。したがって、連結演算子は &lt;code&gt;array_cat&lt;/code&gt; ではなく &lt;code&gt;array_append&lt;/code&gt; を表すと想定されます。それが間違った選択である場合、定数を配列の要素型にキャストすることで修正できます。ただし、 &lt;code&gt;array_append&lt;/code&gt; を明示的に使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="cfb28c6ea0190f478c6d1ce0ce5ab123177f2281" translate="yes" xml:space="preserve">
          <source>In the examples above, the policy expressions consider only the current values in the row to be accessed or updated. This is the simplest and best-performing case; when possible, it's best to design row security applications to work this way. If it is necessary to consult other rows or other tables to make a policy decision, that can be accomplished using sub-&lt;code&gt;SELECT&lt;/code&gt;s, or functions that contain &lt;code&gt;SELECT&lt;/code&gt;s, in the policy expressions. Be aware however that such accesses can create race conditions that could allow information leakage if care is not taken. As an example, consider the following table design:</source>
          <target state="translated">上記の例では、ポリシー式は、行内の現在の値のみがアクセスまたは更新されると見なします。これは最も単純で最もパフォーマンスの高いケースです。可能であれば、この方法で機能するように行セキュリティアプリケーションを設計することをお勧めします。ポリシーの決定を行うために他の行または他のテーブルを調べる必要がある場合は、ポリシー式でサブ &lt;code&gt;SELECT&lt;/code&gt; または &lt;code&gt;SELECT&lt;/code&gt; を含む関数を使用して実行できます。ただし、このようなアクセスは競合状態を引き起こし、注意を怠ると情報漏えいを引き起こす可能性があることに注意してください。例として、次のテーブルデザインを考えます。</target>
        </trans-unit>
        <trans-unit id="2808c388963b5d35c9a7c014fc0aef8465d89479" translate="yes" xml:space="preserve">
          <source>In the examples that follow, we assume that you have created a database named &lt;code&gt;mydb&lt;/code&gt;, as described in the previous chapter, and have been able to start psql.</source>
          <target state="translated">次の例では、前の章で説明したように &lt;code&gt;mydb&lt;/code&gt; という名前のデータベースを作成し、psqlを起動できたと想定しています。</target>
        </trans-unit>
        <trans-unit id="4bb59306b891fbea63056e89cb36560d344851b8" translate="yes" xml:space="preserve">
          <source>In the first case, the RE as a whole is greedy because &lt;code&gt;Y*&lt;/code&gt; is greedy. It can match beginning at the &lt;code&gt;Y&lt;/code&gt;, and it matches the longest possible string starting there, i.e., &lt;code&gt;Y123&lt;/code&gt;. The output is the parenthesized part of that, or &lt;code&gt;123&lt;/code&gt;. In the second case, the RE as a whole is non-greedy because &lt;code&gt;Y*?&lt;/code&gt; is non-greedy. It can match beginning at the &lt;code&gt;Y&lt;/code&gt;, and it matches the shortest possible string starting there, i.e., &lt;code&gt;Y1&lt;/code&gt;. The subexpression &lt;code&gt;[0-9]{1,3}&lt;/code&gt; is greedy but it cannot change the decision as to the overall match length; so it is forced to match just &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">最初のケースでは、 &lt;code&gt;Y*&lt;/code&gt; は貪欲であるため、REは全体として貪欲です。 &lt;code&gt;Y&lt;/code&gt; から始まり、そこから始まる可能な限り長い文字列、つまり &lt;code&gt;Y123&lt;/code&gt; に一致します。出力は、括弧で囲まれた部分、つまり &lt;code&gt;123&lt;/code&gt; です。 2番目のケースでは、REは &lt;code&gt;Y*?&lt;/code&gt; ため、全体として貪欲ではありません。貪欲ではありません。 &lt;code&gt;Y&lt;/code&gt; から始まり、 &lt;code&gt;Y1&lt;/code&gt; から始まる可能な限り短い文字列に一致します。部分式 &lt;code&gt;[0-9]{1,3}&lt;/code&gt; は貪欲ですが、全体の一致の長さに関する決定を変更することはできません。したがって、 &lt;code&gt;1&lt;/code&gt; にのみ一致することが強制されます。</target>
        </trans-unit>
        <trans-unit id="0afff82ca92cc5d65344944313d08b5825c3e875" translate="yes" xml:space="preserve">
          <source>In the first place, &lt;em&gt;never&lt;/em&gt; believe any test that runs for only a few seconds. Use the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;-T&lt;/code&gt; option to make the run last at least a few minutes, so as to average out noise. In some cases you could need hours to get numbers that are reproducible. It's a good idea to try the test run a few times, to find out if your numbers are reproducible or not.</source>
          <target state="translated">まず第一に、&lt;em&gt;決して&lt;/em&gt;ほんの数秒間実行するすべてのテストを信じていません。 &lt;code&gt;-t&lt;/code&gt; または &lt;code&gt;-T&lt;/code&gt; オプションを使用して、実行を少なくとも数分持続させ、ノイズを平均化します。場合によっては、再現可能な数値を取得するのに数時間かかることがあります。数回テストを実行して、数値が再現可能かどうかを確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d312d02ebaa05f528de247ffd592135c96644932" translate="yes" xml:space="preserve">
          <source>In the first string, the set of trigrams is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rd &quot;}&lt;/code&gt;. In the second string, the ordered set of trigrams is &lt;code&gt;{&quot; t&quot;,&quot; tw&quot;,&quot;two&quot;,&quot;wo &quot;,&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt;. The most similar extent of an ordered set of trigrams in the second string is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;}&lt;/code&gt;, and the similarity is &lt;code&gt;0.8&lt;/code&gt;.</source>
          <target state="translated">最初の文字列では、トライグラムのセットは &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rd &quot;}&lt;/code&gt; です。 2番目の文字列では、順序付けられたトライグラムのセットは &lt;code&gt;{&quot; t&quot;,&quot; tw&quot;,&quot;two&quot;,&quot;wo &quot;,&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt; 。2番目の文字列内の順序付けられたトライグラムのセットの最も類似した範囲は &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;}&lt;/code&gt; であり、類似度は &lt;code&gt;0.8&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="56225072f8eae4ad3b64ee516719e58b357f9e0a" translate="yes" xml:space="preserve">
          <source>In the following explanation, a &lt;em&gt;byte&lt;/em&gt; is assumed to contain 8 bits. In addition, the term &lt;em&gt;item&lt;/em&gt; refers to an individual data value that is stored on a page. In a table, an item is a row; in an index, an item is an index entry.</source>
          <target state="translated">以下の説明では、1 &lt;em&gt;バイト&lt;/em&gt;は8ビットを含むと想定しています。さらに、&lt;em&gt;アイテム&lt;/em&gt;という用語は、ページに格納される個々のデータ値を指します。テーブルでは、アイテムは行です。インデックスでは、アイテムはインデックスエントリです。</target>
        </trans-unit>
        <trans-unit id="fe808d43052245254bcdc480fec58d6c194f111b" translate="yes" xml:space="preserve">
          <source>In the following sections we will cover each of the above listed items in more detail to give a better understanding of PostgreSQL's internal control and data structures.</source>
          <target state="translated">以下のセクションでは、PostgreSQLの内部制御とデータ構造をよりよく理解するために、上記の各項目をより詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="f022f75654e730419aa401f110023452d899d615" translate="yes" xml:space="preserve">
          <source>In the following we describe the implementation of a &lt;em&gt;genetic algorithm&lt;/em&gt; to solve the join ordering problem in a manner that is efficient for queries involving large numbers of joins.</source>
          <target state="translated">以下では、多数の結合を含むクエリに対して効率的な方法で結合順序の問題を解決するための&lt;em&gt;遺伝的アルゴリズムの&lt;/em&gt;実装について説明します。</target>
        </trans-unit>
        <trans-unit id="294ebe645001a682897e9beebf5caf16a1bf1ca5" translate="yes" xml:space="preserve">
          <source>In the general case where more than one field needs to be checked to recognize a cycle, use an array of rows. For example, if we needed to compare fields &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;:</source>
          <target state="translated">サイクルを認識するために複数のフィールドをチェックする必要がある一般的なケースでは、行の配列を使用します。たとえば、フィールド &lt;code&gt;f1&lt;/code&gt; と &lt;code&gt;f2&lt;/code&gt; を比較する必要がある場合：</target>
        </trans-unit>
        <trans-unit id="919090babfd7b1e0453e16ae1bb909dd12feef28" translate="yes" xml:space="preserve">
          <source>In the old syntax for &lt;code&gt;CREATE AGGREGATE&lt;/code&gt;, the input data type is specified by a &lt;code&gt;basetype&lt;/code&gt; parameter rather than being written next to the aggregate name. Note that this syntax allows only one input parameter. To define a zero-argument aggregate function with this syntax, specify the &lt;code&gt;basetype&lt;/code&gt; as &lt;code&gt;&quot;ANY&quot;&lt;/code&gt; (not &lt;code&gt;*&lt;/code&gt;). Ordered-set aggregates cannot be defined with the old syntax.</source>
          <target state="translated">&lt;code&gt;CREATE AGGREGATE&lt;/code&gt; の古い構文では、入力データ型は、集約名の横に書き込まれるのではなく、 &lt;code&gt;basetype&lt;/code&gt; パラメーターによって指定されます。この構文では1つの入力パラメーターしか使用できないことに注意してください。この構文で引数なしの集計関数を定義するには、 &lt;code&gt;basetype&lt;/code&gt; を（ &lt;code&gt;*&lt;/code&gt; ではなく） &lt;code&gt;&quot;ANY&quot;&lt;/code&gt; として指定します。順序付き集合の集計は、古い構文では定義できません。</target>
        </trans-unit>
        <trans-unit id="405922ab6e8351d0cf2aca13f11379b1afd63c78" translate="yes" xml:space="preserve">
          <source>In the previous chapter we have covered the basics of using SQL to store and access your data in PostgreSQL. We will now discuss some more advanced features of SQL that simplify management and prevent loss or corruption of your data. Finally, we will look at some PostgreSQL extensions.</source>
          <target state="translated">前の章では、SQLを使用してPostgreSQLにデータを保存し、アクセスするための基本を説明しました。ここでは、管理を簡素化し、データの損失や破損を防ぐためのSQLのより高度な機能について説明します。最後に、PostgreSQLの拡張機能について見ていきます。</target>
        </trans-unit>
        <trans-unit id="a8c0fa4c3a367177ef284ccecde1c150bc096697" translate="yes" xml:space="preserve">
          <source>In the previous example, we can apply the city name restriction in &lt;code&gt;WHERE&lt;/code&gt;, since it needs no aggregate. This is more efficient than adding the restriction to &lt;code&gt;HAVING&lt;/code&gt;, because we avoid doing the grouping and aggregate calculations for all rows that fail the &lt;code&gt;WHERE&lt;/code&gt; check.</source>
          <target state="translated">前の例では、集約が必要ないため、 &lt;code&gt;WHERE&lt;/code&gt; で都市名の制限を適用できます。これは、 &lt;code&gt;HAVING&lt;/code&gt; に制限を追加するよりも効率的です。これは、 &lt;code&gt;WHERE&lt;/code&gt; チェックに失敗したすべての行に対してグループ化と集計の計算を行わないためです。</target>
        </trans-unit>
        <trans-unit id="9f29ede0900e9fd39d495275c897cbd33557a707" translate="yes" xml:space="preserve">
          <source>In the previous sections we created tables without specifying any schema names. By default such tables (and other objects) are automatically put into a schema named &amp;ldquo;public&amp;rdquo;. Every new database contains such a schema. Thus, the following are equivalent:</source>
          <target state="translated">前のセクションでは、スキーマ名を指定せずにテーブルを作成しました。デフォルトでは、このようなテーブル（およびその他のオブジェクト）は自動的に「public」というスキーマに入れられます。すべての新しいデータベースには、そのようなスキーマが含まれています。したがって、以下は同等です。</target>
        </trans-unit>
        <trans-unit id="0e8d742b91769afdfb8fcfcc89d91cd8ba42839b" translate="yes" xml:space="preserve">
          <source>In the remote sessions opened by &lt;code&gt;postgres_fdw&lt;/code&gt;, the &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; parameter is set to just &lt;code&gt;pg_catalog&lt;/code&gt;, so that only built-in objects are visible without schema qualification. This is not an issue for queries generated by &lt;code&gt;postgres_fdw&lt;/code&gt; itself, because it always supplies such qualification. However, this can pose a hazard for functions that are executed on the remote server via triggers or rules on remote tables. For example, if a remote table is actually a view, any functions used in that view will be executed with the restricted search path. It is recommended to schema-qualify all names in such functions, or else attach &lt;code&gt;SET search_path&lt;/code&gt; options (see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;) to such functions to establish their expected search path environment.</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; によって開かれたリモートセッションでは、&lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt;パラメータが &lt;code&gt;pg_catalog&lt;/code&gt; だけに設定されているため、スキーマ修飾なしで組み込みオブジェクトのみが表示されます。これは常に &lt;code&gt;postgres_fdw&lt;/code&gt; 自体によって生成されるクエリの問題ではありません。なぜなら、このような修飾が常に提供されるためです。ただし、これは、リモートテーブルのトリガーまたはルールを介してリモートサーバーで実行される関数に危険をもたらす可能性があります。たとえば、リモートテーブルが実際にビューである場合、そのビューで使用されるすべての関数は、制限された検索パスで実行されます。そのような関数のすべての名前をスキーマ修飾するか、 &lt;code&gt;SET search_path&lt;/code&gt; オプションをアタッチすることをお勧めします（&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTIONを&lt;/a&gt;参照））そのような機能に期待される検索パス環境を確立する。</target>
        </trans-unit>
        <trans-unit id="251756f685410e433b657f5b30520cf41b101c14" translate="yes" xml:space="preserve">
          <source>In the same connection as before, issue the command:</source>
          <target state="translated">先ほどと同じ接続で、コマンドを発行します。</target>
        </trans-unit>
        <trans-unit id="9a85cd84a5c1ae886a05b3cc6a64ec7fb7c99a58" translate="yes" xml:space="preserve">
          <source>In the second form of &lt;code&gt;ALTER POLICY&lt;/code&gt;, the role list, &lt;code&gt;using_expression&lt;/code&gt;, and &lt;code&gt;check_expression&lt;/code&gt; are replaced independently if specified. When one of those clauses is omitted, the corresponding part of the policy is unchanged.</source>
          <target state="translated">&lt;code&gt;ALTER POLICY&lt;/code&gt; の 2番目の形式では、ロールリスト、 &lt;code&gt;using_expression&lt;/code&gt; 、および &lt;code&gt;check_expression&lt;/code&gt; が指定されている場合、個別に置き換えられます。これらの句のいずれかが省略された場合、ポリシーの対応する部分は変更されません。</target>
        </trans-unit>
        <trans-unit id="2c142401003467ed2967cc5251153e2a0bab24fa" translate="yes" xml:space="preserve">
          <source>In the second mode, which we will call the search+bind mode, the server first binds to the LDAP directory with a fixed user name and password, specified with &lt;code&gt;ldapbinddn&lt;/code&gt; and &lt;code&gt;ldapbindpasswd&lt;/code&gt;, and performs a search for the user trying to log in to the database. If no user and password is configured, an anonymous bind will be attempted to the directory. The search will be performed over the subtree at &lt;code&gt;ldapbasedn&lt;/code&gt;, and will try to do an exact match of the attribute specified in &lt;code&gt;ldapsearchattribute&lt;/code&gt;. Once the user has been found in this search, the server disconnects and re-binds to the directory as this user, using the password specified by the client, to verify that the login is correct. This mode is the same as that used by LDAP authentication schemes in other software, such as Apache &lt;code&gt;mod_authnz_ldap&lt;/code&gt; and &lt;code&gt;pam_ldap&lt;/code&gt;. This method allows for significantly more flexibility in where the user objects are located in the directory, but will cause two separate connections to the LDAP server to be made.</source>
          <target state="translated">検索+バインドモードと呼ばれる2番目のモードでは、サーバーは最初に、 &lt;code&gt;ldapbinddn&lt;/code&gt; および &lt;code&gt;ldapbindpasswd&lt;/code&gt; で指定された固定ユーザー名とパスワードを使用してLDAPディレクトリにバインドし、ログインしようとしているユーザーの検索を実行します。データベース。ユーザーとパスワードが設定されていない場合、匿名バインドがディレクトリに試行されます。検索は &lt;code&gt;ldapbasedn&lt;/code&gt; のサブツリーに対して実行され、 &lt;code&gt;ldapsearchattribute&lt;/code&gt; で指定された属性の完全一致を試みます。この検索で​​ユーザーが見つかると、サーバーは接続を切断し、クライアントが指定したパスワードを使用してこのユーザーとしてディレクトリに再バインドし、ログインが正しいことを確認します。このモードは、Apache &lt;code&gt;mod_authnz_ldap&lt;/code&gt; や &lt;code&gt;pam_ldap&lt;/code&gt; などの他のソフトウェアのLDAP認証方式で使用されるモードと同じです。この方法では、ユーザーオブジェクトをディレクトリに配置する際の柔軟性が大幅に向上しますが、LDAPサーバーへの2つの別々の接続が行われます。</target>
        </trans-unit>
        <trans-unit id="138833bfe13a3d8412530f69bb62c741e625ccde" translate="yes" xml:space="preserve">
          <source>In the second query, we could not have written &lt;code&gt;SELECT * FROM test1 GROUP BY x&lt;/code&gt;, because there is no single value for the column &lt;code&gt;y&lt;/code&gt; that could be associated with each group. The grouped-by columns can be referenced in the select list since they have a single value in each group.</source>
          <target state="translated">2番目のクエリでは、各グループに関連付けることができる列 &lt;code&gt;y&lt;/code&gt; の単一の値がないため、 &lt;code&gt;SELECT * FROM test1 GROUP BY x&lt;/code&gt; を書き込むことができませんでした。グループ化された列は、各グループに単一の値を持つため、選択リストで参照できます。</target>
        </trans-unit>
        <trans-unit id="a3f53fb06ae3c0e076406bae29678cb14017000e" translate="yes" xml:space="preserve">
          <source>In the standard, it is not necessary to issue &lt;code&gt;START TRANSACTION&lt;/code&gt; to start a transaction block: any SQL command implicitly begins a block. PostgreSQL's behavior can be seen as implicitly issuing a &lt;code&gt;COMMIT&lt;/code&gt; after each command that does not follow &lt;code&gt;START TRANSACTION&lt;/code&gt; (or &lt;code&gt;BEGIN&lt;/code&gt;), and it is therefore often called &amp;ldquo;autocommit&amp;rdquo;. Other relational database systems might offer an autocommit feature as a convenience.</source>
          <target state="translated">標準では、トランザクションブロックを開始するために &lt;code&gt;START TRANSACTION&lt;/code&gt; を発行する必要はありません。SQLコマンドは暗黙的にブロックを開始します。PostgreSQLの動作は、 &lt;code&gt;START TRANSACTION&lt;/code&gt; （または &lt;code&gt;BEGIN&lt;/code&gt; ）に続かない各コマンドの後に暗黙的に &lt;code&gt;COMMIT&lt;/code&gt; を発行するものと見なすことができるため、しばしば「自動コミット」と呼ばれます。他のリレーショナルデータベースシステムでは、便宜上、自動コミット機能が提供されている場合があります。</target>
        </trans-unit>
        <trans-unit id="127829a1cca08de1cd77d4d1d0c73fe0bf22ed39" translate="yes" xml:space="preserve">
          <source>In the standard, the &lt;code&gt;WITH [ NO ] DATA&lt;/code&gt; clause is required; in PostgreSQL it is optional.</source>
          <target state="translated">標準では、 &lt;code&gt;WITH [ NO ] DATA&lt;/code&gt; 句は必須です。PostgreSQLではオプションです。</target>
        </trans-unit>
        <trans-unit id="7f27aa8e0141e367b925aa8c528ef6250799f203" translate="yes" xml:space="preserve">
          <source>In the strict mode, the specified path must exactly match the structure of the queried JSON document to return an SQL/JSON item, so using this path expression will cause an error. To get the same result as in the lax mode, you have to explicitly unwrap the &lt;code&gt;segments&lt;/code&gt; array:</source>
          <target state="translated">厳密モードでは、SQL / JSONアイテムを返すには、指定されたパスがクエリされたJSONドキュメントの構造と正確に一致する必要があるため、このパス式を使用するとエラーが発生します。laxモードと同じ結果を得るには、 &lt;code&gt;segments&lt;/code&gt; 配列を明示的にアンラップする必要があります。</target>
        </trans-unit>
        <trans-unit id="351d4063e5553403441da5e92374ad1230527978" translate="yes" xml:space="preserve">
          <source>In the syntax of &lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt;, the keywords &lt;code&gt;FUNCTION&lt;/code&gt; and &lt;code&gt;PROCEDURE&lt;/code&gt; are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword &lt;code&gt;PROCEDURE&lt;/code&gt; here is historical and deprecated.</source>
          <target state="translated">&lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt; の構文では、キーワード &lt;code&gt;FUNCTION&lt;/code&gt; と &lt;code&gt;PROCEDURE&lt;/code&gt; は同等ですが、参照される関数は、いずれの場合もプロシージャではなく関数でなければなりません。ここでのキーワード &lt;code&gt;PROCEDURE&lt;/code&gt; の使用は歴史的なものであり、非推奨です。</target>
        </trans-unit>
        <trans-unit id="78472b8a63814954829d3aaff5becf4efc83edf2" translate="yes" xml:space="preserve">
          <source>In the syntax of &lt;code&gt;CREATE OPERATOR&lt;/code&gt;, the keywords &lt;code&gt;FUNCTION&lt;/code&gt; and &lt;code&gt;PROCEDURE&lt;/code&gt; are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword &lt;code&gt;PROCEDURE&lt;/code&gt; here is historical and deprecated.</source>
          <target state="translated">&lt;code&gt;CREATE OPERATOR&lt;/code&gt; の構文では、キーワード &lt;code&gt;FUNCTION&lt;/code&gt; と &lt;code&gt;PROCEDURE&lt;/code&gt; は同等ですが、参照される関数はいずれの場合もプロシージャではなく関数でなければなりません。ここでのキーワード &lt;code&gt;PROCEDURE&lt;/code&gt; の使用は歴史的なものであり、非推奨です。</target>
        </trans-unit>
        <trans-unit id="57ba8dd34e548ca54ffce2f60f391e867e594c9e" translate="yes" xml:space="preserve">
          <source>In the syntax of &lt;code&gt;CREATE TRIGGER&lt;/code&gt;, the keywords &lt;code&gt;FUNCTION&lt;/code&gt; and &lt;code&gt;PROCEDURE&lt;/code&gt; are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword &lt;code&gt;PROCEDURE&lt;/code&gt; here is historical and deprecated.</source>
          <target state="translated">&lt;code&gt;CREATE TRIGGER&lt;/code&gt; の構文では、キーワード &lt;code&gt;FUNCTION&lt;/code&gt; と &lt;code&gt;PROCEDURE&lt;/code&gt; は同等ですが、参照される関数は、いずれの場合もプロシージャではなく関数でなければなりません。ここでのキーワード &lt;code&gt;PROCEDURE&lt;/code&gt; の使用は歴史的なものであり、非推奨です。</target>
        </trans-unit>
        <trans-unit id="e9e4c8cc0471f863f66674a10b7573f32e28c279" translate="yes" xml:space="preserve">
          <source>In the text form of a range, an inclusive lower bound is represented by &amp;ldquo;&lt;code&gt;[&lt;/code&gt;&amp;rdquo; while an exclusive lower bound is represented by &amp;ldquo;&lt;code&gt;(&lt;/code&gt;&amp;rdquo;. Likewise, an inclusive upper bound is represented by &amp;ldquo;&lt;code&gt;]&lt;/code&gt;&amp;rdquo;, while an exclusive upper bound is represented by &amp;ldquo;&lt;code&gt;)&lt;/code&gt;&amp;rdquo;. (See &lt;a href=&quot;rangetypes#RANGETYPES-IO&quot;&gt;Section 8.17.5&lt;/a&gt; for more details.)</source>
          <target state="translated">テキスト形式の範囲では、包括的下限は「 &lt;code&gt;[&lt;/code&gt; 」で表され、排他的下限は「 &lt;code&gt;(&lt;/code&gt; 」で表されます。同様に、包括的上限は「 &lt;code&gt;]&lt;/code&gt; 」で表され、排他的上限は表されます「 &lt;code&gt;)&lt;/code&gt; 」。 （詳細については、&lt;a href=&quot;rangetypes#RANGETYPES-IO&quot;&gt;セクション8.17.5&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="87e71fe4fdbdcfebf301c0661fd38f3ccfa52a22" translate="yes" xml:space="preserve">
          <source>In the verbose input format, and in some fields of the more compact input formats, field values can have fractional parts; for example &lt;code&gt;'1.5 week'&lt;/code&gt; or &lt;code&gt;'01:02:03.45'&lt;/code&gt;. Such input is converted to the appropriate number of months, days, and seconds for storage. When this would result in a fractional number of months or days, the fraction is added to the lower-order fields using the conversion factors 1 month = 30 days and 1 day = 24 hours. For example, &lt;code&gt;'1.5 month'&lt;/code&gt; becomes 1 month and 15 days. Only seconds will ever be shown as fractional on output.</source>
          <target state="translated">詳細な入力形式、およびよりコンパクトな入力形式の一部のフィールドでは、フィールド値に小数部を含めることができます。たとえば、 &lt;code&gt;'1.5 week'&lt;/code&gt; または「 &lt;code&gt;'01:02:03.45'&lt;/code&gt; 。そのような入力は、ストレージのために適切な月、日、秒の数に変換されます。その結果、月または日が小数になる場合、1か月= 30日および1日= 24時間の変換係数を使用して、小数が下位フィールドに追加されます。たとえば、 &lt;code&gt;'1.5 month'&lt;/code&gt; は1か月と15日になります。出力では、秒のみが小数として表示されます。</target>
        </trans-unit>
        <trans-unit id="352c1b7bd2689ed0c741aae1f8598e4432b2e419" translate="yes" xml:space="preserve">
          <source>In the world of measurements, 6.50 is not the same as 6.5. It may sometimes be critically different. The experimenters usually write down (and publish) the digits they trust. 6.50 is actually a fuzzy interval contained within a bigger and even fuzzier interval, 6.5, with their center points being (probably) the only common feature they share. We definitely do not want such different data items to appear the same.</source>
          <target state="translated">計測の世界では、6.50と6.5では 批判的に違うこともあります。実験者は通常、信頼できる数字を書き留めて(公開して)います。6.50は、実際には、より大きく、さらにファジーな6.5の中に含まれるファジーな区間であり、それらの中心点が(おそらく)唯一の共通の特徴です。このような異なるデータ項目が同じように見えることは絶対に避けたいものです。</target>
        </trans-unit>
        <trans-unit id="d16185ffce558efd6646fae1f89738ca57d3dd9c" translate="yes" xml:space="preserve">
          <source>In these expressions, the desired time zone &lt;code&gt;zone&lt;/code&gt; can be specified either as a text string (e.g., &lt;code&gt;'America/Los_Angeles'&lt;/code&gt;) or as an interval (e.g., &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt;). In the text case, a time zone name can be specified in any of the ways described in &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt;.</source>
          <target state="translated">これらの式では、目的のタイムゾーン &lt;code&gt;zone&lt;/code&gt; をテキスト文字列（例： &lt;code&gt;'America/Los_Angeles'&lt;/code&gt; ）または間隔（例 &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt; ）として指定できます。テキストの場合、タイムゾーン名は、&lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;8.5.3項&lt;/a&gt;で説明されている方法のいずれかで指定できます。</target>
        </trans-unit>
        <trans-unit id="13d5bca14d2cfde080255e10973a28114214ea10" translate="yes" xml:space="preserve">
          <source>In this case the parser looks to see if there is an operator taking &lt;code&gt;text&lt;/code&gt; for both arguments. Since there is, it assumes that the second argument should be interpreted as type &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">この場合、パーサーは、両方の引数の &lt;code&gt;text&lt;/code&gt; を受け取る演算子があるかどうかを確認します。あるので、2番目の引数は &lt;code&gt;text&lt;/code&gt; 型として解釈されると想定しています。</target>
        </trans-unit>
        <trans-unit id="d2822670753f6c1107e46ff79d0892389494ad1a" translate="yes" xml:space="preserve">
          <source>In this case there is no MCV information for &lt;code&gt;unique2&lt;/code&gt; because all the values appear to be unique, so we use an algorithm that relies only on the number of distinct values for both relations together with their null fractions:</source>
          <target state="translated">この場合、すべての値が一意であるように見えるため、 &lt;code&gt;unique2&lt;/code&gt; のMCV情報はありません。そのため、両方のリレーションの個別の値の数とそれらのnull分数のみに依存するアルゴリズムを使用します。</target>
        </trans-unit>
        <trans-unit id="454dfb68a36b15232f0a47fef88c353fb8b457de" translate="yes" xml:space="preserve">
          <source>In this case there is no initial hint for which type to use, since no types are specified in the query. So, the parser looks for all candidate operators and finds that there are candidates accepting both string-category and bit-string-category inputs. Since string category is preferred when available, that category is selected, and then the preferred type for strings, &lt;code&gt;text&lt;/code&gt;, is used as the specific type to resolve the unknown-type literals as.</source>
          <target state="translated">この場合、クエリでタイプが指定されていないため、使用するタイプの初期ヒントはありません。したがって、パーサーはすべての候補演算子を探し、文字列カテゴリとビット文字列カテゴリの両方の入力を受け入れる候補があることを見つけます。利用可能な場合は文字列カテゴリが優先されるため、そのカテゴリが選択され、不明なタイプのリテラルを解決するための特定のタイプとして、文字列の優先タイプ &lt;code&gt;text&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="643fc82591ff3cc1a1f002cde4bff205b2405706" translate="yes" xml:space="preserve">
          <source>In this case, a regular user cannot reference &lt;code&gt;customer.credit&lt;/code&gt; directly, but a trusted procedure &lt;code&gt;show_credit&lt;/code&gt; allows the user to print the credit card numbers of customers with some of the digits masked out.</source>
          <target state="translated">この場合、通常のユーザーは &lt;code&gt;customer.credit&lt;/code&gt; を直接参照することはできませんが、信頼できるプロシージャ &lt;code&gt;show_credit&lt;/code&gt; を使用すると、一部の桁がマスクされた状態で顧客のクレジットカード番号を印刷できます。</target>
        </trans-unit>
        <trans-unit id="d737c289d22cb958cf827fb7f26271e5be10a1e7" translate="yes" xml:space="preserve">
          <source>In this case, a row of &lt;code&gt;capitals&lt;/code&gt;&lt;em&gt;inherits&lt;/em&gt; all columns (&lt;code&gt;name&lt;/code&gt;, &lt;code&gt;population&lt;/code&gt;, and &lt;code&gt;altitude&lt;/code&gt;) from its &lt;em&gt;parent&lt;/em&gt;, &lt;code&gt;cities&lt;/code&gt;. The type of the column &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;text&lt;/code&gt;, a native PostgreSQL type for variable length character strings. State capitals have an extra column, &lt;code&gt;state&lt;/code&gt;, that shows their state. In PostgreSQL, a table can inherit from zero or more other tables.</source>
          <target state="translated">この場合、 &lt;code&gt;capitals&lt;/code&gt; 行は、その&lt;em&gt;親&lt;/em&gt;である &lt;code&gt;cities&lt;/code&gt; からすべての列（ &lt;code&gt;name&lt;/code&gt; 、 &lt;code&gt;population&lt;/code&gt; 、 &lt;code&gt;altitude&lt;/code&gt; ）を&lt;em&gt;継承&lt;/em&gt;します。列 &lt;code&gt;name&lt;/code&gt; のタイプは &lt;code&gt;text&lt;/code&gt; であり、可変長文字列のネイティブPostgreSQLタイプです。州都には、 &lt;code&gt;state&lt;/code&gt; を示す追加の列stateがあります。PostgreSQLでは、テーブルは0個以上の他のテーブルから継承できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="613ba4c32d099503d94bd47a030a2a2ad44892dd" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;capitals&lt;/code&gt; table &lt;em&gt;inherits&lt;/em&gt; all the columns of its parent table, &lt;code&gt;cities&lt;/code&gt;. State capitals also have an extra column, &lt;code&gt;state&lt;/code&gt;, that shows their state.</source>
          <target state="translated">この場合、 &lt;code&gt;capitals&lt;/code&gt; テーブルは、その親テーブルである &lt;code&gt;cities&lt;/code&gt; すべての列を&lt;em&gt;継承&lt;/em&gt;します。州都には、 &lt;code&gt;state&lt;/code&gt; を示す追加の列stateもあります。</target>
        </trans-unit>
        <trans-unit id="af318a98fb799d225d9e923e2e4473ff3043a3f6" translate="yes" xml:space="preserve">
          <source>In this configuration, the sample &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; above takes 115.9 ms. That's 1061 ns of timing overhead, again a small multiple of what's measured directly by this utility. That much timing overhead means the actual query itself is only taking a tiny fraction of the accounted for time, most of it is being consumed in overhead instead. In this configuration, any &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; totals involving many timed operations would be inflated significantly by timing overhead.</source>
          <target state="translated">この構成では、上記のサンプル &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; は115.9ミリ秒かかります。これは1061 nsのタイミングオーバーヘッドであり、このユーティリティで直接測定されるものの数倍です。タイミングのオーバーヘッドが大きいということは、実際のクエリ自体が時間の一部を占めるだけであり、そのほとんどがオーバーヘッドで消費されていることを意味します。この構成では、多くの時限操作を含む &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; の合計は、タイミングオーバーヘッドによって大幅に増大します。</target>
        </trans-unit>
        <trans-unit id="abed36bdd05542db8e718c1091a76817a77d802e" translate="yes" xml:space="preserve">
          <source>In this example above we were allowed to switch from the larger MCS range &lt;code&gt;c1.c1023&lt;/code&gt; to the smaller range &lt;code&gt;c1.c4&lt;/code&gt;, but switching back was denied.</source>
          <target state="translated">上記の例では、より大きなMCS範囲 &lt;code&gt;c1.c1023&lt;/code&gt; からより小さな範囲 &lt;code&gt;c1.c4&lt;/code&gt; に切り替えることが許可されていましたが、元に戻すことは拒否されました。</target>
        </trans-unit>
        <trans-unit id="e7326012a121c41d2c47ed971d8505d7a7de76bf" translate="yes" xml:space="preserve">
          <source>In this example the Update node needs to consider three child tables as well as the originally-mentioned parent table. So there are four input scanning subplans, one per table. For clarity, the Update node is annotated to show the specific target tables that will be updated, in the same order as the corresponding subplans. (These annotations are new as of PostgreSQL 9.5; in prior versions the reader had to intuit the target tables by inspecting the subplans.)</source>
          <target state="translated">この例では、Updateノードは、最初に述べた親テーブルだけでなく、3つの子テーブルを考慮する必要があります。したがって、テーブルごとに1つずつ、4つの入力スキャンサブプランがあります。わかりやすくするために、Updateノードは、対応するサブプランと同じ順序で、更新される特定の対象テーブルを示すようにアノテーションされています(これらのアノテーションはPostgreSQL 9.5;から新しくなりました)。(これらの注釈はPostgreSQL 9.5から新しくなりました。以前のバージョンでは、読者はサブプランを調べて対象テーブルを直感的に理解する必要がありました。)</target>
        </trans-unit>
        <trans-unit id="90020459ceef361caea70168cdc85c26559a0eb6" translate="yes" xml:space="preserve">
          <source>In this example the join's output row count is the same as the product of the two scans' row counts, but that's not true in all cases because there can be additional &lt;code&gt;WHERE&lt;/code&gt; clauses that mention both tables and so can only be applied at the join point, not to either input scan. Here's an example:</source>
          <target state="translated">この例では、結合の出力行数は2つのスキャンの行数の積と同じですが、両方のテーブルを言及する追加の &lt;code&gt;WHERE&lt;/code&gt; 句があり、結合ポイントでのみ適用できるため、すべての場合に当てはまるわけではありません。、どちらのスキャンも入力しません。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="f68e5dbd48ccbde70e786ec3f6ee97430aeb6b1e" translate="yes" xml:space="preserve">
          <source>In this example, if &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;(none)&lt;/code&gt;, null is returned, otherwise the value of &lt;code&gt;value&lt;/code&gt; is returned.</source>
          <target state="translated">この例では、 &lt;code&gt;value&lt;/code&gt; が &lt;code&gt;(none)&lt;/code&gt; の場合はnullが返され、それ以外の場合はvalueの &lt;code&gt;value&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="6956c57a06842052520c448c372cfcf4ca7298a5" translate="yes" xml:space="preserve">
          <source>In this example, if four standby servers &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt; are running, the two standbys &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; will be chosen as synchronous standbys because their names appear early in the list of standby names. &lt;code&gt;s3&lt;/code&gt; is a potential synchronous standby and will take over the role of synchronous standby when either of &lt;code&gt;s1&lt;/code&gt; or &lt;code&gt;s2&lt;/code&gt; fails. &lt;code&gt;s4&lt;/code&gt; is an asynchronous standby since its name is not in the list.</source>
          <target state="translated">この例では、4つのスタンバイサーバー &lt;code&gt;s1&lt;/code&gt; 、 &lt;code&gt;s2&lt;/code&gt; 、 &lt;code&gt;s3&lt;/code&gt; 、および &lt;code&gt;s4&lt;/code&gt; が実行されている場合、2つのスタンバイ &lt;code&gt;s1&lt;/code&gt; および &lt;code&gt;s2&lt;/code&gt; が同期スタンバイとして選択されます。それらの名前がスタンバイ名のリストの最初に表示されるためです。 &lt;code&gt;s3&lt;/code&gt; は潜在的な同期スタンバイであり、 &lt;code&gt;s1&lt;/code&gt; または &lt;code&gt;s2&lt;/code&gt; のいずれかに障害が発生すると同期スタンバイの役割を引き継ぎます。 &lt;code&gt;s4&lt;/code&gt; はその名前がリストにないため、非同期スタンバイです。</target>
        </trans-unit>
        <trans-unit id="5ecb1dc9291b661bf70c843bbe812e41c22f83de" translate="yes" xml:space="preserve">
          <source>In this example, if four standby servers &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt; are running, transaction commits will wait for replies from at least any two standbys of &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt; and &lt;code&gt;s3&lt;/code&gt;. &lt;code&gt;s4&lt;/code&gt; is an asynchronous standby since its name is not in the list.</source>
          <target state="translated">この例では、4つのスタンバイサーバー &lt;code&gt;s1&lt;/code&gt; 、 &lt;code&gt;s2&lt;/code&gt; 、 &lt;code&gt;s3&lt;/code&gt; 、および &lt;code&gt;s4&lt;/code&gt; が実行されている場合、トランザクションコミットは、 &lt;code&gt;s1&lt;/code&gt; 、 &lt;code&gt;s2&lt;/code&gt; 、および &lt;code&gt;s3&lt;/code&gt; の少なくとも2つのスタンバイからの応答を待機します。 &lt;code&gt;s4&lt;/code&gt; はその名前がリストにないため、非同期スタンバイです。</target>
        </trans-unit>
        <trans-unit id="52a2cd0a65091e20d376dc71b4672a80c22c4d96" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;TEMPLATE template0&lt;/code&gt; clause is required if the specified locale is different from the one in &lt;code&gt;template1&lt;/code&gt;. (If it is not, then specifying the locale explicitly is redundant.)</source>
          <target state="translated">この例では、指定されたロケールが &lt;code&gt;template1&lt;/code&gt; のロケールと異なる場合、 &lt;code&gt;TEMPLATE template0&lt;/code&gt; 句が必要です。（そうでない場合、ロケールを明示的に指定することは冗長です。）</target>
        </trans-unit>
        <trans-unit id="8c5f7d8e9b592b4d5a3f718483f7acd727a00e09" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;len&lt;/code&gt; column is omitted and therefore it will have the default value:</source>
          <target state="translated">この例では、 &lt;code&gt;len&lt;/code&gt; 列は省略されているため、デフォルト値になります。</target>
        </trans-unit>
        <trans-unit id="3694c54d9cfcf70eda6933c152be42b7c937c601" translate="yes" xml:space="preserve">
          <source>In this example, the columns &lt;code&gt;product_id&lt;/code&gt;, &lt;code&gt;p.name&lt;/code&gt;, and &lt;code&gt;p.price&lt;/code&gt; must be in the &lt;code&gt;GROUP BY&lt;/code&gt; clause since they are referenced in the query select list (but see below). The column &lt;code&gt;s.units&lt;/code&gt; does not have to be in the &lt;code&gt;GROUP BY&lt;/code&gt; list since it is only used in an aggregate expression (&lt;code&gt;sum(...)&lt;/code&gt;), which represents the sales of a product. For each product, the query returns a summary row about all sales of the product.</source>
          <target state="translated">この例では、列 &lt;code&gt;product_id&lt;/code&gt; 、 &lt;code&gt;p.name&lt;/code&gt; 、および &lt;code&gt;p.price&lt;/code&gt; は、クエリ選択リストで参照されるため（ただし、以下を参照）、 &lt;code&gt;GROUP BY&lt;/code&gt; 句に含まれている必要があります。列 &lt;code&gt;s.units&lt;/code&gt; は、製品の売上を表す集計式（ &lt;code&gt;sum(...)&lt;/code&gt; ）でのみ使用されるため、 &lt;code&gt;GROUP BY&lt;/code&gt; リストにある必要はありません。クエリは製品ごとに、製品のすべての売上に関する要約行を返します。</target>
        </trans-unit>
        <trans-unit id="08a0e2d4d5bc94672e2506daf9e09dfe471fae09" translate="yes" xml:space="preserve">
          <source>In this example, the data type of the second parameter is not specified, so it is inferred from the context in which &lt;code&gt;$2&lt;/code&gt; is used.</source>
          <target state="translated">この例では、2番目のパラメーターのデータ型は指定されていないため、 &lt;code&gt;$2&lt;/code&gt; が使用されているコンテキストから推測されます。</target>
        </trans-unit>
        <trans-unit id="9ecac118ba12d038d39cec07567975d6d66efcef" translate="yes" xml:space="preserve">
          <source>In this example, the sort order isn't fully specified, and so you might get the San Francisco rows in either order. But you'd always get the results shown above if you do:</source>
          <target state="translated">この例では、ソート順は完全には指定されていないので、サンフランシスコの行はどちらの順番でも取得できるかもしれません。しかし、そうすると常に上記のような結果が得られます。</target>
        </trans-unit>
        <trans-unit id="afe2100b24dbf1294da5f781636d42d62e4bc563" translate="yes" xml:space="preserve">
          <source>In this example, the word &lt;code&gt;Brightest&lt;/code&gt; was recognized by the parser as an &lt;code&gt;ASCII word&lt;/code&gt; (alias &lt;code&gt;asciiword&lt;/code&gt;). For this token type the dictionary list is &lt;code&gt;english_ispell&lt;/code&gt; and &lt;code&gt;english_stem&lt;/code&gt;. The word was recognized by &lt;code&gt;english_ispell&lt;/code&gt;, which reduced it to the noun &lt;code&gt;bright&lt;/code&gt;. The word &lt;code&gt;supernovaes&lt;/code&gt; is unknown to the &lt;code&gt;english_ispell&lt;/code&gt; dictionary so it was passed to the next dictionary, and, fortunately, was recognized (in fact, &lt;code&gt;english_stem&lt;/code&gt; is a Snowball dictionary which recognizes everything; that is why it was placed at the end of the dictionary list).</source>
          <target state="translated">この例では、 &lt;code&gt;Brightest&lt;/code&gt; という単語がパーサーによって &lt;code&gt;ASCII word&lt;/code&gt; （別名 &lt;code&gt;asciiword&lt;/code&gt; ）として認識されました。このトークンタイプのディクショナリリストは、 &lt;code&gt;english_ispell&lt;/code&gt; および &lt;code&gt;english_stem&lt;/code&gt; です。この単語は &lt;code&gt;english_ispell&lt;/code&gt; によって認識され、名詞 &lt;code&gt;bright&lt;/code&gt; に減少しました。 &lt;code&gt;supernovaes&lt;/code&gt; という単語は、 &lt;code&gt;english_ispell&lt;/code&gt; 辞書では認識されていないため、次の辞書に渡され、幸いにも認識されました（実際、 &lt;code&gt;english_stem&lt;/code&gt; はすべてを認識するSnowball辞書です。そのため、辞書リストの最後に配置されました。 ）。</target>
        </trans-unit>
        <trans-unit id="3c50776020e0abdc78addf8fd7c7082700a16f21" translate="yes" xml:space="preserve">
          <source>In this example, transaction 82 was late, because its latency (6.173 ms) was over the 5 ms limit. The next two transactions were skipped, because they were already late before they were even started.</source>
          <target state="translated">この例では、トランザクション82のレイテンシ(6.173ミリ秒)が5ミリ秒の制限を超えていたため、トランザクション82は遅れていた。次の2つのトランザクションは、開始前にすでに遅れていたため、スキップされました。</target>
        </trans-unit>
        <trans-unit id="630dd124cc8b0f85590f44f07e341462147cb0a6" translate="yes" xml:space="preserve">
          <source>In this group of commands, the letters &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; stand for foreign table, index, materialized view, sequence, table, and view, respectively. You can specify any or all of these letters, in any order, to obtain a listing of objects of these types. For example, &lt;code&gt;\dit&lt;/code&gt; lists indexes and tables. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its physical size on disk and its associated description, if any. If &lt;code&gt;pattern&lt;/code&gt; is specified, only objects whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">このコマンドグループでは、文字 &lt;code&gt;E&lt;/code&gt; 、 &lt;code&gt;i&lt;/code&gt; 、 &lt;code&gt;m&lt;/code&gt; 、 &lt;code&gt;s&lt;/code&gt; 、 &lt;code&gt;t&lt;/code&gt; 、および &lt;code&gt;v&lt;/code&gt; は、それぞれ外部テーブル、インデックス、マテリアライズドビュー、シーケンス、テーブル、およびビューを表します。これらの文字の一部またはすべてを任意の順序で指定して、これらのタイプのオブジェクトのリストを取得できます。たとえば、 &lt;code&gt;\dit&lt;/code&gt; はインデックスとテーブルをリストします。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各オブジェクトは、ディスク上の物理サイズと関連する説明（ある場合）とともに一覧表示されます。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するオブジェクトのみがリストされます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。パターンまたは &lt;code&gt;S&lt;/code&gt; を指定します システムオブジェクトを含める修飾子。</target>
        </trans-unit>
        <trans-unit id="76a2e5dcbe213e98e1493b7e930a93660a65d1fc" translate="yes" xml:space="preserve">
          <source>In this module, the Earth is assumed to be perfectly spherical. (If that's too inaccurate for you, you might want to look at the &lt;a href=&quot;http://postgis.net/&quot;&gt;PostGIS&lt;/a&gt; project.)</source>
          <target state="translated">このモジュールでは、地球は完全に球形であると想定されています。 （それが不正確である場合は、&lt;a href=&quot;http://postgis.net/&quot;&gt;PostGIS&lt;/a&gt;プロジェクトを確認することをお勧めします。）</target>
        </trans-unit>
        <trans-unit id="fdbad3a8ee3be25a94e567ee2f1c55ff6b62875e" translate="yes" xml:space="preserve">
          <source>In this particular example, the correction from the MCV list is fairly small, because the column distribution is actually quite flat (the statistics showing these particular values as being more common than others are mostly due to sampling error). In a more typical case where some values are significantly more common than others, this complicated process gives a useful improvement in accuracy because the selectivity for the most common values is found exactly.</source>
          <target state="translated">この特定の例では,列の分布が実際には非常に平坦であるため,MCVリストからの補正はかなり小さい(これらの特定の値が他の値よりも一般的であることを示す統計量は,ほとんどがサンプリング誤差によるものです).いくつかの値が他の値よりも有意に一般的な場合、最も一般的な値の選択性が正確に見出されるので、この複雑なプロセスは精度の有用な向上をもたらします。</target>
        </trans-unit>
        <trans-unit id="35b50273596d3b9b0a5ab879d1dff2a027177930" translate="yes" xml:space="preserve">
          <source>In this plan, we have a nested-loop join node with two table scans as inputs, or children. The indentation of the node summary lines reflects the plan tree structure. The join's first, or &amp;ldquo;outer&amp;rdquo;, child is a bitmap scan similar to those we saw before. Its cost and row count are the same as we'd get from &lt;code&gt;SELECT ... WHERE unique1 &amp;lt; 10&lt;/code&gt; because we are applying the &lt;code&gt;WHERE&lt;/code&gt; clause &lt;code&gt;unique1 &amp;lt; 10&lt;/code&gt; at that node. The &lt;code&gt;t1.unique2 = t2.unique2&lt;/code&gt; clause is not relevant yet, so it doesn't affect the row count of the outer scan. The nested-loop join node will run its second, or &amp;ldquo;inner&amp;rdquo; child once for each row obtained from the outer child. Column values from the current outer row can be plugged into the inner scan; here, the &lt;code&gt;t1.unique2&lt;/code&gt; value from the outer row is available, so we get a plan and costs similar to what we saw above for a simple &lt;code&gt;SELECT ... WHERE t2.unique2 = constant&lt;/code&gt; case. (The estimated cost is actually a bit lower than what was seen above, as a result of caching that's expected to occur during the repeated index scans on &lt;code&gt;t2&lt;/code&gt;.) The costs of the loop node are then set on the basis of the cost of the outer scan, plus one repetition of the inner scan for each outer row (10 * 7.91, here), plus a little CPU time for join processing.</source>
          <target state="translated">この計画では、入力または子として2つのテーブルスキャンを持つネストループ結合ノードがあります。ノードサマリー行のインデントは、プランツリー構造を反映しています。結合の最初の「外部」子は、前に見たものと同様のビットマップスキャンです。そのノードで &lt;code&gt;WHERE&lt;/code&gt; 句 &lt;code&gt;unique1 &amp;lt; 10&lt;/code&gt; を適用しているので、そのコストと行数は &lt;code&gt;SELECT ... WHERE unique1 &amp;lt; 10&lt;/code&gt; から得られるものと同じです。 &lt;code&gt;t1.unique2 = t2.unique2&lt;/code&gt; それは外側のスキャンの行数に影響を与えないように句は、まだ関係ありません。ネストされたループ結合ノードは、外側の子から取得した行ごとに、2番目の「内側」の子を1回実行します。現在の外部行の列値を内部スキャンに組み込むことができます。ここでは、 &lt;code&gt;t1.unique2&lt;/code&gt; 外側の行の値を使用できるため、上記の単純な &lt;code&gt;SELECT ... WHERE t2.unique2 = constant&lt;/code&gt; 場合と同じような計画とコストが得られます。 （ &lt;code&gt;t2&lt;/code&gt; でのインデックススキャンの繰り返し中に予想されるキャッシュの結果として、実際の見積もりコストは上記の値よりも少し低くなっています。）次に、ループノードのコストは、コストのコストに基づいて設定されます。外部スキャン、および各外部行の内部スキャンの1回の繰り返し（ここでは10 * 7.91）、および結合処理のための少しのCPU時間。</target>
        </trans-unit>
        <trans-unit id="2a65ed7368072bf4eca944cd69c42b40f3442c1c" translate="yes" xml:space="preserve">
          <source>In this syntax, the &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; value is required by the standard to be a literal constant, a parameter, or a variable name; as a PostgreSQL extension, other expressions are allowed, but will generally need to be enclosed in parentheses to avoid ambiguity. If &lt;code&gt;count&lt;/code&gt; is omitted in a &lt;code&gt;FETCH&lt;/code&gt; clause, it defaults to 1. &lt;code&gt;ROW&lt;/code&gt; and &lt;code&gt;ROWS&lt;/code&gt; as well as &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;NEXT&lt;/code&gt; are noise words that don't influence the effects of these clauses. According to the standard, the &lt;code&gt;OFFSET&lt;/code&gt; clause must come before the &lt;code&gt;FETCH&lt;/code&gt; clause if both are present; but PostgreSQL is laxer and allows either order.</source>
          <target state="translated">この構文では、 &lt;code&gt;start&lt;/code&gt; 値または &lt;code&gt;count&lt;/code&gt; 値は、標準でリテラル定数、パラメーター、または変数名である必要があります。 PostgreSQLの拡張機能として、他の式を使用できますが、あいまいさを避けるために、通常は括弧で囲む必要があります。場合は &lt;code&gt;count&lt;/code&gt; で省略されている &lt;code&gt;FETCH&lt;/code&gt; 句、それ1.デフォルト &lt;code&gt;ROW&lt;/code&gt; および &lt;code&gt;ROWS&lt;/code&gt; だけでなく、 &lt;code&gt;FIRST&lt;/code&gt; と &lt;code&gt;NEXT&lt;/code&gt; は、これらの句の効果に影響しないノイズワードです。規格によると、両方が存在する場合、 &lt;code&gt;OFFSET&lt;/code&gt; 句は &lt;code&gt;FETCH&lt;/code&gt; 句の前に置く必要があります。しかし、PostgreSQLは緩いため、どちらの順序でも使用できます。</target>
        </trans-unit>
        <trans-unit id="6b9893e81c5b40e27434e52e7429139f563d867e" translate="yes" xml:space="preserve">
          <source>In this type of plan the table rows are fetched in index order, which makes them even more expensive to read, but there are so few that the extra cost of sorting the row locations is not worth it. You'll most often see this plan type for queries that fetch just a single row. It's also often used for queries that have an &lt;code&gt;ORDER BY&lt;/code&gt; condition that matches the index order, because then no extra sorting step is needed to satisfy the &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">このタイプのプランでは、テーブルの行がインデックス順にフェッチされるため、読み取りがさらに高価になりますが、行の場所をソートするための追加のコストは価値がありません。ほとんどの場合、単一の行のみをフェッチするクエリに対してこのプランタイプが表示されます。また、インデックスの順序に一致する &lt;code&gt;ORDER BY&lt;/code&gt; 条件を持つクエリにもよく使用されます。これは、 &lt;code&gt;ORDER BY&lt;/code&gt; を満たすために追加の並べ替え手順が必要ないためです。</target>
        </trans-unit>
        <trans-unit id="84eb5898e8d8ec4083399d85009281a59b8ba4c6" translate="yes" xml:space="preserve">
          <source>In versions prior to PostgreSQL 9.6, this flag matched only tables, not any other type of relation.</source>
          <target state="translated">PostgreSQL 9.6以前のバージョンでは、このフラグはテーブルのみにマッチし、他のタイプのリレーションにはマッチしませんでした。</target>
        </trans-unit>
        <trans-unit id="cccb2030fa433816cbfff6cfc31e7b85686eadc9" translate="yes" xml:space="preserve">
          <source>In writing your archive command, you should assume that the file names to be archived can be up to 64 characters long and can contain any combination of ASCII letters, digits, and dots. It is not necessary to preserve the original relative path (&lt;code&gt;%p&lt;/code&gt;) but it is necessary to preserve the file name (&lt;code&gt;%f&lt;/code&gt;).</source>
          <target state="translated">アーカイブコマンドを記述する場合、アーカイブするファイル名は最大64文字で、ASCII文字、数字、ドットの任意の組み合わせを含むことができると想定する必要があります。元の相対パス（ &lt;code&gt;%p&lt;/code&gt; ）を保持する必要はありませんが、ファイル名（ &lt;code&gt;%f&lt;/code&gt; ）を保持する必要があります。</target>
        </trans-unit>
        <trans-unit id="faddf9df2a3466cccf3377b581482849c1fd5256" translate="yes" xml:space="preserve">
          <source>Inaccurate time keeping can result in system instability. Test any change to the clock source very carefully. Operating system defaults are sometimes made to favor reliability over best accuracy. And if you are using a virtual machine, look into the recommended time sources compatible with it. Virtual hardware faces additional difficulties when emulating timers, and there are often per operating system settings suggested by vendors.</source>
          <target state="translated">不正確な時刻の保持は、システムを不安定にする可能性があります。クロックソースの変更は慎重にテストしてください。オペレーティングシステムのデフォルトは、最高の精度よりも信頼性を優先するように設定されていることがあります。また、仮想マシンを使用している場合は、そのマシンと互換性のある推奨された時間ソースを調べてください。仮想ハードウェアはタイマーをエミュレートする際にさらなる困難に直面し、ベンダーが推奨するオペレーティングシステムの設定が存在することがよくあります。</target>
        </trans-unit>
        <trans-unit id="b4bae0608aa0bb22c524d2d34a5bb2a1f5386f27" translate="yes" xml:space="preserve">
          <source>Incidentally, the &lt;code&gt;BEGIN&lt;/code&gt; key word is used for a different purpose in embedded SQL. You are advised to be careful about the transaction semantics when porting database applications.</source>
          <target state="translated">ちなみに、 &lt;code&gt;BEGIN&lt;/code&gt; キーワードは、埋め込みSQLでは別の目的で使用されます。データベースアプリケーションを移植するときは、トランザクションのセマンティクスに注意することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f56a8df3508e9ed5684baab06fa5e61cef26eebf" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;pg_trace.h&lt;/code&gt; if it is not already present in the module(s) containing the probe points, and insert &lt;code&gt;TRACE_POSTGRESQL&lt;/code&gt; probe macros at the desired locations in the source code</source>
          <target state="translated">&lt;code&gt;pg_trace.h&lt;/code&gt; がプローブポイントを含むモジュールにまだ存在していない場合はインクルードし、ソースコードの目的の場所に &lt;code&gt;TRACE_POSTGRESQL&lt;/code&gt; プローブマクロを挿入します。</target>
        </trans-unit>
        <trans-unit id="2d8b7df7f5c4b05fc8f7d8518fd909017b7c32d2" translate="yes" xml:space="preserve">
          <source>Include SQL commands to clean (drop) databases before recreating them. &lt;code&gt;DROP&lt;/code&gt; commands for roles and tablespaces are added as well.</source>
          <target state="translated">データベースを再作成する前にデータベースをクリーン（ドロップ）するSQLコマンドを含めます。ロールとテーブルスペースの &lt;code&gt;DROP&lt;/code&gt; コマンドも追加されます。</target>
        </trans-unit>
        <trans-unit id="15af567ab13e6ebab28e457206713f05e4dcc212" translate="yes" xml:space="preserve">
          <source>Include actual startup time and time spent in each node in the output. The overhead of repeatedly reading the system clock can slow down the query significantly on some systems, so it may be useful to set this parameter to &lt;code&gt;FALSE&lt;/code&gt; when only actual row counts, and not exact times, are needed. Run time of the entire statement is always measured, even when node-level timing is turned off with this option. This parameter may only be used when &lt;code&gt;ANALYZE&lt;/code&gt; is also enabled. It defaults to &lt;code&gt;TRUE&lt;/code&gt;.</source>
          <target state="translated">実際の起動時間と各ノードで費やされた時間を出力に含めます。一部のシステムでは、システムクロックを繰り返し読み取るオーバーヘッドによってクエリの速度が大幅に低下する可能性があるため、正確な時間ではなく実際の行数のみが必要な &lt;code&gt;FALSE&lt;/code&gt; 、このパラメーターをFALSEに設定すると便利です。このオプションでノードレベルのタイミングがオフになっている場合でも、ステートメント全体の実行時間は常に測定されます。このパラメーターは、 &lt;code&gt;ANALYZE&lt;/code&gt; も有効になっている場合にのみ使用できます。デフォルトは &lt;code&gt;TRUE&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="69fd997380e1370b3a2e3a89721390495f72294b" translate="yes" xml:space="preserve">
          <source>Include files or directories can be used to logically separate portions of the database configuration, rather than having a single large &lt;code&gt;postgresql.conf&lt;/code&gt; file. Consider a company that has two database servers, each with a different amount of memory. There are likely elements of the configuration both will share, for things such as logging. But memory-related parameters on the server will vary between the two. And there might be server specific customizations, too. One way to manage this situation is to break the custom configuration changes for your site into three files. You could add this to the end of your &lt;code&gt;postgresql.conf&lt;/code&gt; file to include them:</source>
          <target state="translated">インクルードファイルまたはディレクトリを使用すると、単一の大きな &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルを作成するのではなく、データベース構成の部分を論理的に分離できます。 2つのデータベースサーバーがあり、それぞれが異なるメモリ容量を備えている会社を考えてみます。ロギングなどのために、両方の構成要素が共有する可能性があります。ただし、サーバー上のメモリ関連のパラメーターは2つで異なります。また、サーバー固有のカスタマイズもあるかもしれません。この状況を管理する1つの方法は、サイトのカスタム構成の変更を3つのファイルに分割することです。これを &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルの最後に追加して、それらを含めることができます。</target>
        </trans-unit>
        <trans-unit id="47b7156430746d586783036a5e783795b65f9965" translate="yes" xml:space="preserve">
          <source>Include information on buffer usage. Specifically, include the number of shared blocks hit, read, dirtied, and written, the number of local blocks hit, read, dirtied, and written, and the number of temp blocks read and written. A &lt;em&gt;hit&lt;/em&gt; means that a read was avoided because the block was found already in cache when needed. Shared blocks contain data from regular tables and indexes; local blocks contain data from temporary tables and indexes; while temp blocks contain short-term working data used in sorts, hashes, Materialize plan nodes, and similar cases. The number of blocks &lt;em&gt;dirtied&lt;/em&gt; indicates the number of previously unmodified blocks that were changed by this query; while the number of blocks &lt;em&gt;written&lt;/em&gt; indicates the number of previously-dirtied blocks evicted from cache by this backend during query processing. The number of blocks shown for an upper-level node includes those used by all its child nodes. In text format, only non-zero values are printed. This parameter may only be used when &lt;code&gt;ANALYZE&lt;/code&gt; is also enabled. It defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">バッファーの使用に関する情報を含めます。具体的には、ヒット、読み取り、ダーティ、書き込みされた共有ブロックの数、ヒット、読み取り、ダーティ、書き込みされたローカルブロックの数、および読み書きされた一時ブロックの数を含めます。 Aは&lt;em&gt;ヒット&lt;/em&gt;、必要なときにブロックがすでにキャッシュ内に見つかったため、読み取りが回避されたことを意味します。共有ブロックには、通常のテーブルとインデックスからのデータが含まれています。ローカルブロックには、一時テーブルとインデックスからのデータが含まれます。一時ブロックには、ソート、ハッシュ、マテリアライズ計画ノードなどで使用される短期的な作業データが含まれています。&lt;em&gt;ダーティ&lt;/em&gt;になったブロックの数は、このクエリによって変更された、以前に変更されていないブロックの数を示します。&lt;em&gt;書き込まれた&lt;/em&gt;ブロックの数&lt;em&gt;&lt;/em&gt;クエリ処理中にこのバックエンドによってキャッシュから削除された、以前にダーティになったブロックの数を示します。上位レベルのノードに表示されるブロックの数には、そのすべての子ノードで使用されるブロックが含まれます。テキスト形式では、ゼロ以外の値のみが出力されます。このパラメーターは、 &lt;code&gt;ANALYZE&lt;/code&gt; も有効になっている場合にのみ使用できます。デフォルトは &lt;code&gt;FALSE&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5cf950011b674c52ed53fd1187206feef3854c98" translate="yes" xml:space="preserve">
          <source>Include information on configuration parameters. Specifically, include options affecting query planning with value different from the built-in default value. This parameter defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">構成パラメーターに関する情報を含めます。具体的には、組み込みのデフォルト値とは異なる値でクエリ計画に影響するオプションを含めます。このパラメーターのデフォルトは &lt;code&gt;FALSE&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="bd7df900c420c99916abebaeb86bc9b9487e3ff6" translate="yes" xml:space="preserve">
          <source>Include information on the estimated startup and total cost of each plan node, as well as the estimated number of rows and the estimated width of each row. This parameter defaults to &lt;code&gt;TRUE&lt;/code&gt;.</source>
          <target state="translated">各計画ノードの推定起動と合計コスト、および各行の推定行数と推定幅に関する情報を含めます。このパラメーターのデフォルトは &lt;code&gt;TRUE&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b5b5e034a15e397016c3928803cda54f49c8fb74" translate="yes" xml:space="preserve">
          <source>Include large objects in the dump. This is the default behavior except when &lt;code&gt;--schema&lt;/code&gt;, &lt;code&gt;--table&lt;/code&gt;, or &lt;code&gt;--schema-only&lt;/code&gt; is specified. The &lt;code&gt;-b&lt;/code&gt; switch is therefore only useful to add large objects to dumps where a specific schema or table has been requested. Note that blobs are considered data and therefore will be included when &lt;code&gt;--data-only&lt;/code&gt; is used, but not when &lt;code&gt;--schema-only&lt;/code&gt; is.</source>
          <target state="translated">大きなオブジェクトをダンプに含めます。 &lt;code&gt;--schema&lt;/code&gt; 、-- &lt;code&gt;--table&lt;/code&gt; 、または &lt;code&gt;--schema-only&lt;/code&gt; が指定されている場合を除いて、これはデフォルトの動作です。 &lt;code&gt;-b&lt;/code&gt; スイッチは、特定のスキーマまたはテーブルが要求されたダンプにラージ・オブジェクトを追加することが唯一有用です。ブロブは、データとみなされ、場合従って含まれることに留意されたい &lt;code&gt;--data-only&lt;/code&gt; 場合に使用されないが、 &lt;code&gt;--schema-only&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="08c7d11c8d4a8d10c948989b5a35951818754be1" translate="yes" xml:space="preserve">
          <source>Include summary information (e.g., totaled timing information) after the query plan. Summary information is included by default when &lt;code&gt;ANALYZE&lt;/code&gt; is used but otherwise is not included by default, but can be enabled using this option. Planning time in &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; includes the time required to fetch the plan from the cache and the time required for re-planning, if necessary.</source>
          <target state="translated">クエリプランの後に概要情報（たとえば、合計タイミング情報）を含めます。概要情報は、 &lt;code&gt;ANALYZE&lt;/code&gt; を使用するとデフォルトで含まれますが、それ以外の場合はデフォルトでは含まれませんが、このオプションを使用して有効にできます。 &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; の計画時間には、キャッシュから計画をフェッチするのに必要な時間と、必要に応じて再計画に必要な時間が含まれます。</target>
        </trans-unit>
        <trans-unit id="d2256e3896ead62f77d423e731b976ceab4c8935" translate="yes" xml:space="preserve">
          <source>Includes the required write-ahead log files (WAL files) in the backup. This will include all write-ahead logs generated during the backup. Unless the method &lt;code&gt;none&lt;/code&gt; is specified, it is possible to start a postmaster directly in the extracted directory without the need to consult the log archive, thus making this a completely standalone backup.</source>
          <target state="translated">必要な先行書き込みログファイル（WALファイル）をバックアップに含めます。これには、バックアップ中に生成されたすべての先行書き込みログが含まれます。メソッド &lt;code&gt;none&lt;/code&gt; が指定されていない限り、ログアーカイブを参照する必要なしに、抽出されたディレクトリでpostmasterを直接起動することができるため、これは完全にスタンドアロンのバックアップになります。</target>
        </trans-unit>
        <trans-unit id="bba52d333ab18b6249842b58dabb5827d455ee93" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;csvlog&lt;/code&gt; in the &lt;code&gt;log_destination&lt;/code&gt; list provides a convenient way to import log files into a database table. This option emits log lines in comma-separated-values (CSV) format, with these columns: time stamp with milliseconds, user name, database name, process ID, client host:port number, session ID, per-session line number, command tag, session start time, virtual transaction ID, regular transaction ID, error severity, SQLSTATE code, error message, error message detail, hint, internal query that led to the error (if any), character count of the error position therein, error context, user query that led to the error (if any and enabled by &lt;code&gt;log_min_error_statement&lt;/code&gt;), character count of the error position therein, location of the error in the PostgreSQL source code (if &lt;code&gt;log_error_verbosity&lt;/code&gt; is set to &lt;code&gt;verbose&lt;/code&gt;), and application name. Here is a sample table definition for storing CSV-format log output:</source>
          <target state="translated">&lt;code&gt;log_destination&lt;/code&gt; リストに &lt;code&gt;csvlog&lt;/code&gt; を含めると、ログファイルをデータベーステーブルにインポートするのに便利です。このオプションは、コンマ区切り値（CSV）形式でログ行を出力します。これらの列は、ミリ秒のタイムスタンプ、ユーザー名、データベース名、プロセスID、クライアントホスト：ポート番号、セッションID、セッションごとの行番号、コマンドです。タグ、セッション開始時間、仮想トランザクションID、通常のトランザクションID、エラーの重大度、SQLSTATEコード、エラーメッセージ、エラーメッセージの詳細、ヒント、エラーの原因となった内部クエリ（存在する場合）、その中のエラー位置の文字数、エラーコンテキスト、エラーの原因となったユーザークエリ（存在する場合、 &lt;code&gt;log_min_error_statement&lt;/code&gt; によって有効化されます））、その中のエラー位置の文字数、PostgreSQLソースコード内のエラーの場所（ &lt;code&gt;log_error_verbosity&lt;/code&gt; が &lt;code&gt;verbose&lt;/code&gt; に設定されている場合）、およびアプリケーション名。以下は、CSV形式のログ出力を格納するためのサンプルテーブル定義です。</target>
        </trans-unit>
        <trans-unit id="4c47c86c8d425f70d8b2151c0d809c6c1813e865" translate="yes" xml:space="preserve">
          <source>Increase &lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt; and &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt;; this reduces the frequency of checkpoints, but increases the storage requirements of &lt;code&gt;/pg_wal&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt;と&lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeoutを&lt;/a&gt;増やします。これはチェックポイントの頻度を減らしますが、 &lt;code&gt;/pg_wal&lt;/code&gt; のストレージ要件を増やします。</target>
        </trans-unit>
        <trans-unit id="491d088ee8f4f607e5e1e928bb9bf8875f9a361a" translate="yes" xml:space="preserve">
          <source>Increases the size of the cube by the specified radius &lt;code&gt;r&lt;/code&gt; in at least &lt;code&gt;n&lt;/code&gt; dimensions. If the radius is negative the cube is shrunk instead. All defined dimensions are changed by the radius &lt;code&gt;r&lt;/code&gt;. Lower-left coordinates are decreased by &lt;code&gt;r&lt;/code&gt; and upper-right coordinates are increased by &lt;code&gt;r&lt;/code&gt;. If a lower-left coordinate is increased to more than the corresponding upper-right coordinate (this can only happen when &lt;code&gt;r&lt;/code&gt; &amp;lt; 0) than both coordinates are set to their average. If &lt;code&gt;n&lt;/code&gt; is greater than the number of defined dimensions and the cube is being enlarged (&lt;code&gt;r&lt;/code&gt; &amp;gt; 0), then extra dimensions are added to make &lt;code&gt;n&lt;/code&gt; altogether; 0 is used as the initial value for the extra coordinates. This function is useful for creating bounding boxes around a point for searching for nearby points.</source>
          <target state="translated">立方体のサイズを、少なくとも &lt;code&gt;n&lt;/code&gt; 次元で指定された半径 &lt;code&gt;r&lt;/code&gt; だけ増やします。半径が負の場合、立方体は代わりに縮小されます。定義されたすべての寸法は、半径 &lt;code&gt;r&lt;/code&gt; によって変更されます。左下の座標は &lt;code&gt;r&lt;/code&gt; だけ減少し、右上の座標は &lt;code&gt;r&lt;/code&gt; だけ増加します。左下の座標が対応する右上の座標よりも大きくなると（ &lt;code&gt;r&lt;/code&gt; &amp;lt;0の場合にのみ発生します）、両方の座標が平均に設定されます。場合 &lt;code&gt;n&lt;/code&gt; 定義された次元の数よりも大きく、キューブが拡大されている（ &lt;code&gt;r&lt;/code&gt; &amp;gt; 0）、次いで余分寸法が作るために添加される &lt;code&gt;n&lt;/code&gt; 個完全に; 追加座標の初期値として0が使用されます。この関数は、近くのポイントを検索するためにポイントの周囲に境界ボックスを作成するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="f9c0442f572435bb8c34c7304c10e685fc7ac4b3" translate="yes" xml:space="preserve">
          <source>Increment an integer, making use of an argument name, in PL/pgSQL:</source>
          <target state="translated">PL/pgSQLでは、引数名を利用して整数をインクリメントします。</target>
        </trans-unit>
        <trans-unit id="d5e6a1521753325e1f10aefe90f61ed951c60b45" translate="yes" xml:space="preserve">
          <source>Increment the sales count of the salesperson who manages the account for Acme Corporation, and record the whole updated row along with current time in a log table:</source>
          <target state="translated">株式会社アクメのアカウントを管理する営業担当者の売上数を増加させ、更新された全行を現在時刻とともにログテーブルに記録します。</target>
        </trans-unit>
        <trans-unit id="016cda80a0391be204d7aeb8cae7ec5708da297f" translate="yes" xml:space="preserve">
          <source>Increment the sales count of the salesperson who manages the account for Acme Corporation, using the &lt;code&gt;FROM&lt;/code&gt; clause syntax:</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 句の構文を使用して、Acme Corporationのアカウントを管理する販売員の販売数を増やします。</target>
        </trans-unit>
        <trans-unit id="9a4352e3ce439f57ce839ae2217c61914bab2036" translate="yes" xml:space="preserve">
          <source>Increment value of the sequence</source>
          <target state="translated">シーケンスのインクリメント値</target>
        </trans-unit>
        <trans-unit id="0baba858aebf401bd8fc5997be9e51de35556b66" translate="yes" xml:space="preserve">
          <source>Independently of &lt;code&gt;max_wal_size&lt;/code&gt;, &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; + 1 most recent WAL files are kept at all times. Also, if WAL archiving is used, old segments can not be removed or recycled until they are archived. If WAL archiving cannot keep up with the pace that WAL is generated, or if &lt;code&gt;archive_command&lt;/code&gt; fails repeatedly, old WAL files will accumulate in &lt;code&gt;pg_wal&lt;/code&gt; until the situation is resolved. A slow or failed standby server that uses a replication slot will have the same effect (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;max_wal_size&lt;/code&gt; とは関係なく、&lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; + 1最新のWALファイルが常に保持されます。また、WALアーカイブが使用されている場合、古いセグメントはアーカイブされるまで削除またはリサイクルできません。 WALアーカイブがWALが生成されるペースに追いつかない場合、または &lt;code&gt;archive_command&lt;/code&gt; が繰り返し失敗する場合、状況が解決されるまで、古いWALファイルが &lt;code&gt;pg_wal&lt;/code&gt; に蓄積されます。レプリケーションスロットを使用する低速または&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;障害が&lt;/a&gt;発生したスタンバイサーバーでも同じ効果があります（セクション26.2.6を参照）。</target>
        </trans-unit>
        <trans-unit id="fc7301cd0f493014b9a0674c1f9a1816640cb05f" translate="yes" xml:space="preserve">
          <source>Index Access Method: Basic API Structure for Indexes</source>
          <target state="translated">インデックスのアクセス方法。インデックスの基本API構造</target>
        </trans-unit>
        <trans-unit id="f78511aae833dc82a57faebbdb5be9d2b811c5ba" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Access Method Functions</source>
          <target state="translated">インデックスアクセス方式 インデックスアクセス方式機能</target>
        </trans-unit>
        <trans-unit id="67844b6b086746a2175da308cd69b3a3322c8f8a" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Cost Estimation Functions</source>
          <target state="translated">インデックスアクセス方式。インデックスコスト推定関数</target>
        </trans-unit>
        <trans-unit id="ed0cf00558f5f3be604eab3a16ea9444c680fa41" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Locking Considerations</source>
          <target state="translated">インデックスアクセス方法。インデックスロックの考慮事項</target>
        </trans-unit>
        <trans-unit id="23bdd1e7799979f5184920ab721afb82ac1bc5bc" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Scanning</source>
          <target state="translated">インデックスアクセス方法 インデックススキャン</target>
        </trans-unit>
        <trans-unit id="1b3aa3923e02606cc47b91d3beb9e0be0fcf698b" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Uniqueness Checks</source>
          <target state="translated">インデックスのアクセス方法。インデックスの一意性チェック</target>
        </trans-unit>
        <trans-unit id="5ec145b22f866c8350ec8fde02299443b400da81" translate="yes" xml:space="preserve">
          <source>Index Storage Parameters</source>
          <target state="translated">インデックスストレージパラメータ</target>
        </trans-unit>
        <trans-unit id="4e09dcdaddb1a9558501d09366dc72f53b93938b" translate="yes" xml:space="preserve">
          <source>Index Types</source>
          <target state="translated">インデックスの種類</target>
        </trans-unit>
        <trans-unit id="f19762ba6cf5f18bb6bfea402f2aaa7605c7a6d9" translate="yes" xml:space="preserve">
          <source>Index access method operator class is for</source>
          <target state="translated">インデックスアクセスメソッド演算子クラスは</target>
        </trans-unit>
        <trans-unit id="aa270689b00c3b50db9d0d870a5d8e7c14e30f9d" translate="yes" xml:space="preserve">
          <source>Index access method operator family is for</source>
          <target state="translated">インデックスアクセスメソッド演算子ファミリは</target>
        </trans-unit>
        <trans-unit id="7f91618c60dc341c28ac1a80ab4b5e00b3b36fa4" translate="yes" xml:space="preserve">
          <source>Index access method specific data. Different methods store different data. Empty in ordinary tables.</source>
          <target state="translated">インデックスアクセス方式の特定のデータ。メソッドによって保存するデータが異なる 通常のテーブルでは空</target>
        </trans-unit>
        <trans-unit id="31a6a8a40d18f374bed6deff03fed3f43968a4d7" translate="yes" xml:space="preserve">
          <source>Index access methods must handle concurrent updates of the index by multiple processes. The core PostgreSQL system obtains &lt;code&gt;AccessShareLock&lt;/code&gt; on the index during an index scan, and &lt;code&gt;RowExclusiveLock&lt;/code&gt; when updating the index (including plain &lt;code&gt;VACUUM&lt;/code&gt;). Since these lock types do not conflict, the access method is responsible for handling any fine-grained locking it might need. An exclusive lock on the index as a whole will be taken only during index creation, destruction, or &lt;code&gt;REINDEX&lt;/code&gt;.</source>
          <target state="translated">インデックスアクセスメソッドは、複数のプロセスによるインデックスの同時更新を処理する必要があります。コアPostgreSQLシステムは、インデックススキャン中にインデックスの &lt;code&gt;AccessShareLock&lt;/code&gt; を取得し、インデックス（プレーンな &lt;code&gt;VACUUM&lt;/code&gt; を含む）を更新するときに &lt;code&gt;RowExclusiveLock&lt;/code&gt; を取得します。これらのロックタイプは競合しないため、アクセス方法は、必要になる可能性のある細かいロックの処理を担当します。インデックス全体の排他ロックは、インデックスの作成、破棄、または &lt;code&gt;REINDEX&lt;/code&gt; 中にのみ取得されます。</target>
        </trans-unit>
        <trans-unit id="411152cefe270170bdbd707fa7bb100f59936ac0" translate="yes" xml:space="preserve">
          <source>Index definition (a reconstructed &lt;code&gt;CREATE INDEX&lt;/code&gt; command)</source>
          <target state="translated">インデックス定義（再構築された &lt;code&gt;CREATE INDEX&lt;/code&gt; コマンド）</target>
        </trans-unit>
        <trans-unit id="fdde6507a698ff6040826cbe9781cf5e41a80789" translate="yes" xml:space="preserve">
          <source>Index expressions are relatively expensive to maintain, because the derived expression(s) must be computed for each row upon insertion and whenever it is updated. However, the index expressions are &lt;em&gt;not&lt;/em&gt; recomputed during an indexed search, since they are already stored in the index. In both examples above, the system sees the query as just &lt;code&gt;WHERE indexedcolumn = 'constant'&lt;/code&gt; and so the speed of the search is equivalent to any other simple index query. Thus, indexes on expressions are useful when retrieval speed is more important than insertion and update speed.</source>
          <target state="translated">インデックス式は、挿入時および更新時に行ごとに派生式を計算する必要があるため、維持するのに比較的コストがかかります。ただし、インデックス式はすでにインデックスに格納されているため、インデックス付き検索中に再計算され&lt;em&gt;ません&lt;/em&gt;。上記の両方の例で、システムはクエリを &lt;code&gt;WHERE indexedcolumn = 'constant'&lt;/code&gt; と見なすため、検索速度は他の単純なインデックスクエリと同等です。したがって、式のインデックスは、挿入と更新の速度よりも検索速度が重要な場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="137221474050ee597f18d1d2a9bf5cc8c57090b0" translate="yes" xml:space="preserve">
          <source>Index-Only Scans and Covering Indexes</source>
          <target state="translated">インデックスのみのスキャンとカバーリングインデックス</target>
        </trans-unit>
        <trans-unit id="fa0d50739fe1e6ebbc17d0c70d81ac62acbaf58d" translate="yes" xml:space="preserve">
          <source>Indexable Operators</source>
          <target state="translated">インデックス可能な演算子</target>
        </trans-unit>
        <trans-unit id="69a6a1b0f4ad606d0ae7c258868e72a29f0777ef" translate="yes" xml:space="preserve">
          <source>Indexed Data Type</source>
          <target state="translated">インデックス化されたデータ型</target>
        </trans-unit>
        <trans-unit id="f642ee196088372ea886186c6c617515599afd3f" translate="yes" xml:space="preserve">
          <source>Indexes</source>
          <target state="translated">Indexes</target>
        </trans-unit>
        <trans-unit id="0b07dd7c1e4d64ef5d5ba2561b6e35701b2906b6" translate="yes" xml:space="preserve">
          <source>Indexes and foreign key constraints apply to single tables and not to their inheritance children, hence they have some &lt;a href=&quot;ddl-inherit#DDL-INHERIT-CAVEATS&quot;&gt;caveats&lt;/a&gt; to be aware of.</source>
          <target state="translated">インデックスと外部キー制約は単一のテーブルに適用され、継承の子には適用されないため、&lt;a href=&quot;ddl-inherit#DDL-INHERIT-CAVEATS&quot;&gt;注意&lt;/a&gt;が必要です。</target>
        </trans-unit>
        <trans-unit id="e15643bd769ae7fcf2c35c27f2ab1732e1a9d5c1" translate="yes" xml:space="preserve">
          <source>Indexes can also be used to enforce uniqueness of a column's value, or the uniqueness of the combined values of more than one column.</source>
          <target state="translated">インデックスは、列の値の一意性や、複数の列の組み合わせ値の一意性を強制するために使用することもできます。</target>
        </trans-unit>
        <trans-unit id="94aa2c39061285d86804bbba30d7e52d694f4564" translate="yes" xml:space="preserve">
          <source>Indexes can also benefit &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; commands with search conditions. Indexes can moreover be used in join searches. Thus, an index defined on a column that is part of a join condition can also significantly speed up queries with joins.</source>
          <target state="translated">インデックスは、検索条件を備えた &lt;code&gt;UPDATE&lt;/code&gt; および &lt;code&gt;DELETE&lt;/code&gt; コマンドにも役立ちます。さらに、インデックスは結合検索で使用できます。したがって、結合条件の一部である列に定義されたインデックスも、結合を使用したクエリを大幅に高速化できます。</target>
        </trans-unit>
        <trans-unit id="68c16c2b91128e4f41955f5ff646c75a169f39bb" translate="yes" xml:space="preserve">
          <source>Indexes can be used by simple index scans, &amp;ldquo;bitmap&amp;rdquo; index scans, and the optimizer. In a bitmap scan the output of several indexes can be combined via AND or OR rules, so it is difficult to associate individual heap row fetches with specific indexes when a bitmap scan is used. Therefore, a bitmap scan increments the &lt;code&gt;pg_stat_all_indexes&lt;/code&gt;.&lt;code&gt;idx_tup_read&lt;/code&gt; count(s) for the index(es) it uses, and it increments the &lt;code&gt;pg_stat_all_tables&lt;/code&gt;.&lt;code&gt;idx_tup_fetch&lt;/code&gt; count for the table, but it does not affect &lt;code&gt;pg_stat_all_indexes&lt;/code&gt;.&lt;code&gt;idx_tup_fetch&lt;/code&gt;. The optimizer also accesses indexes to check for supplied constants whose values are outside the recorded range of the optimizer statistics because the optimizer statistics might be stale.</source>
          <target state="translated">インデックスは、単純なインデックススキャン、「ビットマップ」インデックススキャン、およびオプティマイザで使用できます。ビットマップスキャンでは、複数のインデックスの出力をANDまたはORルールで組み合わせることができるため、ビットマップスキャンを使用する場合、個々のヒープ行フェッチを特定のインデックスに関連付けることは困難です。したがって、ビットマップスキャンは &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; をインクリメントします。使用するインデックスの &lt;code&gt;idx_tup_read&lt;/code&gt; カウント、および &lt;code&gt;pg_stat_all_tables&lt;/code&gt; をインクリメントします。テーブルの &lt;code&gt;idx_tup_fetch&lt;/code&gt; 数。ただし、 &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; には影響しません。 &lt;code&gt;idx_tup_fetch&lt;/code&gt; 。オプティマイザ統計は古くなっている可能性があるため、オプティマイザはインデックスにアクセスして、オプティマイザ統計の記録された範囲外の値を持つ指定された定数をチェックします。</target>
        </trans-unit>
        <trans-unit id="fe87987c8ecb565fcb320eb91d374313994665e6" translate="yes" xml:space="preserve">
          <source>Indexes can even concatenate columns:</source>
          <target state="translated">インデックスは列を連結することもできます。</target>
        </trans-unit>
        <trans-unit id="8fee069b42975ecfc0bf523b8f7af8b0cf11b9bb" translate="yes" xml:space="preserve">
          <source>Indexes, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, &lt;code&gt;UNIQUE&lt;/code&gt;, and &lt;code&gt;EXCLUDE&lt;/code&gt; constraints on the original table will be created on the new table. Names for the new indexes and constraints are chosen according to the default rules, regardless of how the originals were named. (This behavior avoids possible duplicate-name failures for the new indexes.)</source>
          <target state="translated">元のテーブルのインデックス、 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 、 &lt;code&gt;UNIQUE&lt;/code&gt; 、および &lt;code&gt;EXCLUDE&lt;/code&gt; 制約は、新しいテーブルに作成されます。新しいインデックスと制約の名前は、元の名前の付け方に関係なく、デフォルトの規則に従って選択されます。（この動作により、新しいインデックスでの重複した名前の失敗の可能性が回避されます。）</target>
        </trans-unit>
        <trans-unit id="64accc47bb83e575341063f3658e1d1e7d2113e1" translate="yes" xml:space="preserve">
          <source>Indexing for &amp;ldquo;float ranges&amp;rdquo;</source>
          <target state="translated">「フロート範囲」のインデックス作成</target>
        </trans-unit>
        <trans-unit id="d165c70b9c7feb2704f3285d8d27cbb3a58c3a91" translate="yes" xml:space="preserve">
          <source>Indexing for multidimensional cubes</source>
          <target state="translated">多次元キューブのインデックス作成</target>
        </trans-unit>
        <trans-unit id="b91462559e819269659f845aa92e7f5041a36896" translate="yes" xml:space="preserve">
          <source>Indexing for tree-like structures</source>
          <target state="translated">木のような構造のための索引付け</target>
        </trans-unit>
        <trans-unit id="610e7a10148c311249b3bbd57cd9833a58b8714d" translate="yes" xml:space="preserve">
          <source>Indicates how the cast is performed. &lt;code&gt;f&lt;/code&gt; means that the function specified in the &lt;code&gt;castfunc&lt;/code&gt; field is used. &lt;code&gt;i&lt;/code&gt; means that the input/output functions are used. &lt;code&gt;b&lt;/code&gt; means that the types are binary-coercible, thus no conversion is required.</source>
          <target state="translated">キャストの実行方法を示します。 &lt;code&gt;f&lt;/code&gt; は、 &lt;code&gt;castfunc&lt;/code&gt; フィールドで指定された関数が使用されることを意味します。 &lt;code&gt;i&lt;/code&gt; は、入出力関数が使用されることを意味します。 &lt;code&gt;b&lt;/code&gt; は、型がバイナリ強制型であることを意味するため、変換は必要ありません。</target>
        </trans-unit>
        <trans-unit id="c8e4b2b3e4731dd79133b34f9f993d48a44e51e7" translate="yes" xml:space="preserve">
          <source>Indicates not to recurse creating indexes on partitions, if the table is partitioned. The default is to recurse.</source>
          <target state="translated">テーブルがパーティショニングされている場合、パーティション上にインデックスを作成しないことを示します。デフォルトは再帰することを示します。</target>
        </trans-unit>
        <trans-unit id="c934b82eb6dc908677ffc76af2256f04ecf84094" translate="yes" xml:space="preserve">
          <source>Indicates role to which this role will be added immediately as a new member. Multiple roles to which this role will be added as a member can be specified by writing multiple &lt;code&gt;-g&lt;/code&gt; switches.</source>
          <target state="translated">このロールが新しいメンバーとしてすぐに追加されるロールを示します。このロールをメンバーとして追加する複数のロールは、複数の &lt;code&gt;-g&lt;/code&gt; スイッチを記述することで指定できます。</target>
        </trans-unit>
        <trans-unit id="bba08c6b0be5e0b5de1c5dd077ea609cb92072f0" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">関数が任意の配列データ型を受け入れることを示します（&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="7a2f7fb68c39785b7c61d53497fe5cf5bd1568bd" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">関数が任意のデータ型を受け入れることを示します（&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="9f46df9b9c0db2bde38cb75f71fb9153783611d4" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any enum data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;).</source>
          <target state="translated">関数が任意のenumデータ型を受け入れることを示します（&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5&lt;/a&gt;および&lt;a href=&quot;datatype-enum&quot;&gt;セクション8.7を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="46bd42bb48f3fa999abde7cc36ebf5b6f5ac5c8d" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any input data type.</source>
          <target state="translated">関数が任意の入力データ型を受け入れることを示します。</target>
        </trans-unit>
        <trans-unit id="4e38b6c5ff227f9cc8a0278ba387f1ee54390caf" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any non-array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">関数が配列以外のデータ型を受け入れることを示します（&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="95d9465560cf78be64ef72d2e6367284edb5463f" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any range data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;).</source>
          <target state="translated">関数が任意の範囲のデータ型を受け入れることを示します（&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5&lt;/a&gt;および&lt;a href=&quot;rangetypes&quot;&gt;セクション8.17を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="99e158daaace8eac02a3ccf2b3b765596ccc91e4" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts or returns a null-terminated C string.</source>
          <target state="translated">関数がヌル文字で終端するC言語の文字列を受け付ける、または返すことを示します。</target>
        </trans-unit>
        <trans-unit id="54761c9282026639ec5c8540cc79ebf4ba11462a" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts or returns a server-internal data type.</source>
          <target state="translated">関数がサーバー内部のデータ型を受け入れるか、または返すことを示します。</target>
        </trans-unit>
        <trans-unit id="89dc9ca8b4db982fb593e3e44e25350b25d82bea" translate="yes" xml:space="preserve">
          <source>Indicates that a function returns no value.</source>
          <target state="translated">関数が値を返さないことを示します。</target>
        </trans-unit>
        <trans-unit id="7d75608f451e28beb0733c0d6c1c5d589e592ee3" translate="yes" xml:space="preserve">
          <source>Indicates that data retrieved from the cursor should be unaffected by updates to the table(s) underlying the cursor that occur after the cursor is created. In PostgreSQL, this is the default behavior; so this key word has no effect and is only accepted for compatibility with the SQL standard.</source>
          <target state="translated">カーソルから取得されたデータは、カーソルが作成された後に発生するカーソルの下にあるテーブルの更新の影響を受けないことを示します。PostgreSQLでは、これがデフォルトの動作です。したがって、このキーワードは何の効果もなく、SQL標準との互換性のためだけに受け入れられます。</target>
        </trans-unit>
        <trans-unit id="95cdb06015680fe563a8aa9dd541903933a11ad2" translate="yes" xml:space="preserve">
          <source>Indicates that the cast can be invoked implicitly in any context.</source>
          <target state="translated">どのようなコンテキストでも暗黙のうちにキャストを呼び出すことができることを示します。</target>
        </trans-unit>
        <trans-unit id="0390d2ebad5b8b8a226d9901a34d76e7770b71be" translate="yes" xml:space="preserve">
          <source>Indicates that the cast can be invoked implicitly in assignment contexts.</source>
          <target state="translated">代入コンテキストでキャストが暗黙的に呼び出されることを示します。</target>
        </trans-unit>
        <trans-unit id="3840502dacc9907db02fe8896c3bfeafcfa9e633" translate="yes" xml:space="preserve">
          <source>Indicates that the cast is an I/O conversion cast, performed by invoking the output function of the source data type, and passing the resulting string to the input function of the target data type.</source>
          <target state="translated">このキャストは,ソースデータ型の出力関数を呼び出して,結果の文字列をターゲットデータ型の入力関数に渡すことで実行されるI/O変換キャストであることを示します。</target>
        </trans-unit>
        <trans-unit id="01e358ef1ee49de64b80b741226b8d05654b1eb9" translate="yes" xml:space="preserve">
          <source>Indicates that the source type is binary-coercible to the target type, so no function is required to perform the cast.</source>
          <target state="translated">ソース型がターゲット型に対してバイナリ互換性があるため、キャストを実行するための関数が必要ないことを示します。</target>
        </trans-unit>
        <trans-unit id="4f0180a78d5a13ddfb20f673dc1c1a653a0dbf1c" translate="yes" xml:space="preserve">
          <source>Indicates this operator can support a hash join.</source>
          <target state="translated">この演算子がハッシュ結合をサポートしていることを示します。</target>
        </trans-unit>
        <trans-unit id="7f8be265aa5381d640f66bb0fbb51979d62652fa" translate="yes" xml:space="preserve">
          <source>Indicates this operator can support a merge join.</source>
          <target state="translated">この演算子がマージ結合をサポートしていることを示します。</target>
        </trans-unit>
        <trans-unit id="88982366e025d973d9fdcbf523cd379f45035c49" translate="yes" xml:space="preserve">
          <source>Indicates what contexts the cast can be invoked in. &lt;code&gt;e&lt;/code&gt; means only as an explicit cast (using &lt;code&gt;CAST&lt;/code&gt; or &lt;code&gt;::&lt;/code&gt; syntax). &lt;code&gt;a&lt;/code&gt; means implicitly in assignment to a target column, as well as explicitly. &lt;code&gt;i&lt;/code&gt; means implicitly in expressions, as well as the other cases.</source>
          <target state="translated">キャストを呼び出すことができるコンテキストを示します &lt;code&gt;e&lt;/code&gt; は、明示的なキャストとしてのみ（ &lt;code&gt;CAST&lt;/code&gt; または &lt;code&gt;::&lt;/code&gt; 構文を使用して）意味します。 &lt;code&gt;a&lt;/code&gt; は、ターゲット列への割り当てで暗黙的に、および明示的に意味します。 &lt;code&gt;i&lt;/code&gt; は、他の場合と同様に、式で暗黙的に意味します。</target>
        </trans-unit>
        <trans-unit id="e1335256027d947c4a5d7cbed371240e3fa5176d" translate="yes" xml:space="preserve">
          <source>Indirect TOAST pointers simply point at a non-indirect varlena value stored somewhere in memory. This case was originally created merely as a proof of concept, but it is currently used during logical decoding to avoid possibly having to create physical tuples exceeding 1 GB (as pulling all out-of-line field values into the tuple might do). The case is of limited use since the creator of the pointer datum is entirely responsible that the referenced data survives for as long as the pointer could exist, and there is no infrastructure to help with this.</source>
          <target state="translated">間接 TOAST ポインタは、メモリのどこかに保存されている非間接的な varlena 値を指すだけです。このケースはもともと概念の証明として作成されただけですが、現在は論理デコードの際に使用されており、1GBを超える物理的なタプルを作成しなければならない可能性を避けるために使用されています。ポインタデータムの作成者は、ポインタが存在する限り参照されるデータが存続することに完全に責任があるため、このケースの使用は限定的であり、これを支援するインフラストラクチャはありません。</target>
        </trans-unit>
        <trans-unit id="749d2a57690cd8938d324488d8b64d9826db075f" translate="yes" xml:space="preserve">
          <source>Individual leaf tuples and inner tuples must fit on a single index page (8kB by default). Therefore, when indexing values of variable-length data types, long values can only be supported by methods such as radix trees, in which each level of the tree includes a prefix that is short enough to fit on a page, and the final leaf level includes a suffix also short enough to fit on a page. The operator class should set &lt;code&gt;longValuesOK&lt;/code&gt; to true only if it is prepared to arrange for this to happen. Otherwise, the SP-GiST core will reject any request to index a value that is too large to fit on an index page.</source>
          <target state="translated">個々のリーフタプルと内部タプルは、単一のインデックスページに収まる必要があります（デフォルトでは8kB）。したがって、可変長データ型の値にインデックスを付ける場合、長い値は基数ツリーなどのメソッドでのみサポートできます。この場合、ツリーの各レベルには、ページに収まるほど短いプレフィックスと、最終的なリーフレベルが含まれます。ページに収まるほど短い接尾辞も含まれます。オペレータークラスは、これが発生するように準備する場合にのみ、 &lt;code&gt;longValuesOK&lt;/code&gt; をtrueに設定する必要があります。それ以外の場合、SP-GiSTコアは、インデックスページに収まらないほど大きな値のインデックスを作成する要求を拒否します。</target>
        </trans-unit>
        <trans-unit id="60182f316e9821f12c8e613a5f4a51ed0303f8be" translate="yes" xml:space="preserve">
          <source>Individual partitions are linked to the partitioned table with inheritance behind-the-scenes; however, it is not possible to use some of the generic features of inheritance (discussed below) with declaratively partitioned tables or their partitions. For example, a partition cannot have any parents other than the partitioned table it is a partition of, nor can a regular table inherit from a partitioned table making the latter its parent. That means partitioned tables and their partitions do not participate in inheritance with regular tables. Since a partition hierarchy consisting of the partitioned table and its partitions is still an inheritance hierarchy, all the normal rules of inheritance apply as described in &lt;a href=&quot;ddl-inherit&quot;&gt;Section 5.10&lt;/a&gt; with some exceptions, most notably:</source>
          <target state="translated">個々のパーティションは、舞台裏で継承されたパーティションテーブルにリンクされています。ただし、宣言的にパーティション分割されたテーブルまたはそのパーティションでは、継承の一般的な機能の一部（以下で説明）を使用することはできません。たとえば、パーティションはパーティションであるパー​​ティションテーブル以外の親を持つことはできません。また、通常のテーブルはパーティションテーブルから継承して後者を親にすることはできません。つまり、パーティションテーブルとそのパーティションは、通常のテーブルとの継承には参加しません。パーティション化されたテーブルとそのパーティションで構成されるパーティション階層は引き続き継承階層であるため、&lt;a href=&quot;ddl-inherit&quot;&gt;セクション5.10&lt;/a&gt;で説明されているように、いくつかの例外を除いて、すべての通常の継承ルールが適用されます。</target>
        </trans-unit>
        <trans-unit id="e8da164cdd479d1b5a117c145f315adf86e0bbc9" translate="yes" xml:space="preserve">
          <source>Individual state files in &lt;code&gt;pg_twophase&lt;/code&gt; are protected by CRC-32.</source>
          <target state="translated">&lt;code&gt;pg_twophase&lt;/code&gt; の個々の状態ファイルはCRC-32で保護されています。</target>
        </trans-unit>
        <trans-unit id="10dbe9c3ced898e42dd1884b1b4e3f1dc8f408e3" translate="yes" xml:space="preserve">
          <source>Inexact means that some values cannot be converted exactly to the internal format and are stored as approximations, so that storing and retrieving a value might show slight discrepancies. Managing these errors and how they propagate through calculations is the subject of an entire branch of mathematics and computer science and will not be discussed here, except for the following points:</source>
          <target state="translated">不正確とは、いくつかの値が内部フォーマットに正確に変換できず、近似値として保存されていることを意味し、値を保存したり取り出したりすると、わずかな不一致を示す可能性があります。これらの誤差を管理し、それらが計算を通してどのように伝搬するかは、数学とコンピュータサイエンスの一分野の主題であり、以下の点を除いて、ここでは説明しません。</target>
        </trans-unit>
        <trans-unit id="4d7d8b040e79c74720337a20e81bb860b0667a32" translate="yes" xml:space="preserve">
          <source>Infinite line</source>
          <target state="translated">無限線</target>
        </trans-unit>
        <trans-unit id="6f943c69647f371e6d494b5d1c35aba8e91e86d6" translate="yes" xml:space="preserve">
          <source>Information about text search configuration objects can be obtained in psql using a set of commands:</source>
          <target state="translated">テキスト検索設定オブジェクトに関する情報は、一連のコマンドを使用してpsqlで取得することができます。</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="40def20f80d8ba48037f621df42aa0343e15ee73" translate="yes" xml:space="preserve">
          <source>Inheritance does not automatically propagate data from &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;COPY&lt;/code&gt; commands to other tables in the inheritance hierarchy. In our example, the following &lt;code&gt;INSERT&lt;/code&gt; statement will fail:</source>
          <target state="translated">継承は、 &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;COPY&lt;/code&gt; コマンドからのデータを継承階層の他のテーブルに自動的に伝播しません。この例では、次の &lt;code&gt;INSERT&lt;/code&gt; ステートメントは失敗します。</target>
        </trans-unit>
        <trans-unit id="48cefe4735516b5da581e0949fa06f740d2b885b" translate="yes" xml:space="preserve">
          <source>Inheritance is a concept from object-oriented databases. It opens up interesting new possibilities of database design.</source>
          <target state="translated">継承はオブジェクト指向データベースからの概念です。それはデータベース設計の興味深い新しい可能性を開きます。</target>
        </trans-unit>
        <trans-unit id="ad5cfb3ab229a84f8bd5bd34780ce3d5e37a4e03" translate="yes" xml:space="preserve">
          <source>Inherited queries perform access permission checks on the parent table only. Thus, for example, granting &lt;code&gt;UPDATE&lt;/code&gt; permission on the &lt;code&gt;cities&lt;/code&gt; table implies permission to update rows in the &lt;code&gt;capitals&lt;/code&gt; table as well, when they are accessed through &lt;code&gt;cities&lt;/code&gt;. This preserves the appearance that the data is (also) in the parent table. But the &lt;code&gt;capitals&lt;/code&gt; table could not be updated directly without an additional grant. In a similar way, the parent table's row security policies (see &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt;) are applied to rows coming from child tables during an inherited query. A child table's policies, if any, are applied only when it is the table explicitly named in the query; and in that case, any policies attached to its parent(s) are ignored.</source>
          <target state="translated">継承されたクエリは、親テーブルに対してのみアクセス許可チェックを実行します。したがって、例えば、付与 &lt;code&gt;UPDATE&lt;/code&gt; の上の権限 &lt;code&gt;cities&lt;/code&gt; 表は、内の行を更新する権限を意味 &lt;code&gt;capitals&lt;/code&gt; それらを介してアクセスされたときに、同様のテーブルを &lt;code&gt;cities&lt;/code&gt; 。これにより、データが（また）親テーブルにあるように見えます。しかし、 &lt;code&gt;capitals&lt;/code&gt; 表は、追加の補助金なしでは直接更新できませんでした。同様に、親テーブルの行セキュリティポリシー（&lt;a href=&quot;ddl-rowsecurity&quot;&gt;セクション5.8を&lt;/a&gt;参照））は、継承されたクエリ中に子テーブルからの行に適用されます。子テーブルのポリシーがある場合は、それがクエリで明示的に指定されたテーブルである場合にのみ適用されます。その場合、その親に関連付けられているポリシーは無視されます。</target>
        </trans-unit>
        <trans-unit id="1f25aac16509c63c647e201e6dca9b42be580c36" translate="yes" xml:space="preserve">
          <source>Initialization Options</source>
          <target state="translated">初期化オプション</target>
        </trans-unit>
        <trans-unit id="02678e4e52eadddd5b615833652cf8428b2afe6a" translate="yes" xml:space="preserve">
          <source>Initialization option string for the template</source>
          <target state="translated">テンプレートの初期化オプション文字列</target>
        </trans-unit>
        <trans-unit id="6528a9644e65de4c79a52fdab1106b0b771a6d92" translate="yes" xml:space="preserve">
          <source>Initialize the new cluster using &lt;code&gt;initdb&lt;/code&gt;. Again, use compatible &lt;code&gt;initdb&lt;/code&gt; flags that match the old cluster. Many prebuilt installers do this step automatically. There is no need to start the new cluster.</source>
          <target state="translated">&lt;code&gt;initdb&lt;/code&gt; を使用して新しいクラスターを初期化します。この場合も、古いクラスターと一致する互換性のある &lt;code&gt;initdb&lt;/code&gt; フラグを使用します。多くのビルド済みインストーラーがこのステップを自動的に実行します。新しいクラスターを起動する必要はありません。</target>
        </trans-unit>
        <trans-unit id="2a5c551f4615e330d270ad5f3b0629fcdfcd3de2" translate="yes" xml:space="preserve">
          <source>Inner tuples are more complex, since they are branching points in the search tree. Each inner tuple contains a set of one or more &lt;em&gt;nodes&lt;/em&gt;, which represent groups of similar leaf values. A node contains a downlink that leads either to another, lower-level inner tuple, or to a short list of leaf tuples that all lie on the same index page. Each node normally has a &lt;em&gt;label&lt;/em&gt; that describes it; for example, in a radix tree the node label could be the next character of the string value. (Alternatively, an operator class can omit the node labels, if it works with a fixed set of nodes for all inner tuples; see &lt;a href=&quot;spgist-implementation#SPGIST-NULL-LABELS&quot;&gt;Section 65.4.2&lt;/a&gt;.) Optionally, an inner tuple can have a &lt;em&gt;prefix&lt;/em&gt; value that describes all its members. In a radix tree this could be the common prefix of the represented strings. The prefix value is not necessarily really a prefix, but can be any data needed by the operator class; for example, in a quad-tree it can store the central point that the four quadrants are measured with respect to. A quad-tree inner tuple would then also contain four nodes corresponding to the quadrants around this central point.</source>
          <target state="translated">内部タプルは検索ツリーの分岐点であるため、より複雑です。各内部タプルには、類似したリーフ値のグループを表す1つ以上の&lt;em&gt;ノードの&lt;/em&gt;セットが含まれています。ノードには、別の下位レベルの内部タプル、またはすべて同じインデックスページにあるリーフタプルの短いリストにつながるダウンリンクが含まれています。各ノードには通常、それを説明する&lt;em&gt;ラベル&lt;/em&gt;があります。たとえば、基数ツリーでは、ノードラベルを文字列値の次の文字にすることができます。 （または、すべての内部タプルのノードの固定セットで機能する場合、演算子クラスはノードラベルを省略できます。&lt;a href=&quot;spgist-implementation#SPGIST-NULL-LABELS&quot;&gt;セクション65.4.2を&lt;/a&gt;参照してください。）オプションで、内部タプルに&lt;em&gt;プレフィックスを付ける&lt;/em&gt;ことができ&lt;em&gt;ます。&lt;/em&gt;そのすべてのメンバーを説明する値。基数ツリーでは、これは表現された文字列の共通の接頭辞になる可能性があります。接頭辞の値は、必ずしも実際には接頭辞である必要はありませんが、演算子クラスに必要な任意のデータにすることができます。たとえば、四分木では、4つの象限が測定される中心点を保存できます。四分木の内部タプルには、この中心点の周囲の四分円に対応する4つのノードも含まれます。</target>
        </trans-unit>
        <trans-unit id="0029fb34c419096901cb17ee7f69f8d100b925e7" translate="yes" xml:space="preserve">
          <source>Input Ordering</source>
          <target state="translated">ご注文の入力</target>
        </trans-unit>
        <trans-unit id="c651bb8d20d59b648e5817a714d081c24490bd28" translate="yes" xml:space="preserve">
          <source>Input String</source>
          <target state="translated">入力文字列</target>
        </trans-unit>
        <trans-unit id="c42fb65381608e452debc58ec5ce5a7de90ede68" translate="yes" xml:space="preserve">
          <source>Input conversion function (binary format), or 0 if none</source>
          <target state="translated">入力変換機能(バイナリ形式)、ない場合は0</target>
        </trans-unit>
        <trans-unit id="6ede32a74b25d24d933316273b8d1a1c5b311742" translate="yes" xml:space="preserve">
          <source>Input conversion function (text format)</source>
          <target state="translated">入力変換機能(テキスト形式</target>
        </trans-unit>
        <trans-unit id="445431b172a9cb689a043786c27d77bc63ec81f4" translate="yes" xml:space="preserve">
          <source>Input data is interpreted according to &lt;code&gt;ENCODING&lt;/code&gt; option or the current client encoding, and output data is encoded in &lt;code&gt;ENCODING&lt;/code&gt; or the current client encoding, even if the data does not pass through the client but is read from or written to a file directly by the server.</source>
          <target state="translated">入力データは &lt;code&gt;ENCODING&lt;/code&gt; オプションまたは現在のクライアントエンコーディングに従って解釈され、出力データは、データがクライアントを通過せずにサーバーによってファイルから直接読み取られるかファイルに書き込まれる場合でも、 &lt;code&gt;ENCODING&lt;/code&gt; または現在のクライアントエンコーディングでエンコードされます。 。</target>
        </trans-unit>
        <trans-unit id="aa563adcb5d00e2fc3a73ea58d9fd1b265968174" translate="yes" xml:space="preserve">
          <source>Insert a distributor, or do nothing for rows proposed for insertion when an existing, excluded row (a row with a matching constrained column or columns after before row insert triggers fire) exists. Example assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column:</source>
          <target state="translated">ディストリビューターを挿入するか、既存の除外された行（行の挿入トリガーが起動する前に一致する制約列または列を持つ行）が存在する場合、挿入が提案された行に対して何もしません。例では、 &lt;code&gt;did&lt;/code&gt; 列に表示される値を制約する一意のインデックスが定義されていると想定しています。</target>
        </trans-unit>
        <trans-unit id="1b0022e72f294401989398fe077aa7293c9d0864" translate="yes" xml:space="preserve">
          <source>Insert a new tuple into an existing index. The &lt;code&gt;values&lt;/code&gt; and &lt;code&gt;isnull&lt;/code&gt; arrays give the key values to be indexed, and &lt;code&gt;heap_tid&lt;/code&gt; is the TID to be indexed. If the access method supports unique indexes (its &lt;code&gt;amcanunique&lt;/code&gt; flag is true) then &lt;code&gt;checkUnique&lt;/code&gt; indicates the type of uniqueness check to perform. This varies depending on whether the unique constraint is deferrable; see &lt;a href=&quot;index-unique-checks&quot;&gt;Section 61.5&lt;/a&gt; for details. Normally the access method only needs the &lt;code&gt;heapRelation&lt;/code&gt; parameter when performing uniqueness checking (since then it will have to look into the heap to verify tuple liveness).</source>
          <target state="translated">新しいタプルを既存のインデックスに挿入します。 &lt;code&gt;values&lt;/code&gt; と &lt;code&gt;isnull&lt;/code&gt; アレイは、インデックス付けされるキー値を与える、と &lt;code&gt;heap_tid&lt;/code&gt; が索引付けされるTIDです。アクセス方法が一意のインデックスをサポートしている場合（その &lt;code&gt;amcanunique&lt;/code&gt; フラグがtrue）、 &lt;code&gt;checkUnique&lt;/code&gt; は実行する一意性チェックのタイプを示します。これは、一意の制約を延期できるかどうかによって異なります。詳細は&lt;a href=&quot;index-unique-checks&quot;&gt;項61.5&lt;/a&gt;を参照してください。通常、アクセス方法は、一意性チェックを実行するときに &lt;code&gt;heapRelation&lt;/code&gt; パラメータのみを必要とします（それ以降は、タプルの活性を確認するためにヒープを調べる必要があるため）。</target>
        </trans-unit>
        <trans-unit id="0f674319e8780ea4807c4a4acfb9e949fb5f9a9e" translate="yes" xml:space="preserve">
          <source>Insert a single row into table &lt;code&gt;distributors&lt;/code&gt;, returning the sequence number generated by the &lt;code&gt;DEFAULT&lt;/code&gt; clause:</source>
          <target state="translated">単一行をテーブル &lt;code&gt;distributors&lt;/code&gt; に挿入し、 &lt;code&gt;DEFAULT&lt;/code&gt; 句によって生成されたシーケンス番号を返します。</target>
        </trans-unit>
        <trans-unit id="632c13df9b06de5c5de5b6f56617f6d898fc7280" translate="yes" xml:space="preserve">
          <source>Insert a single row into table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">テーブル &lt;code&gt;films&lt;/code&gt; 1行挿入します。</target>
        </trans-unit>
        <trans-unit id="3892df53992670e16381ba584272763bbe059b7e" translate="yes" xml:space="preserve">
          <source>Insert new distributor if possible; otherwise &lt;code&gt;DO NOTHING&lt;/code&gt;. Example assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column on a subset of rows where the &lt;code&gt;is_active&lt;/code&gt; Boolean column evaluates to &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">可能であれば新しいディストリビューターを挿入します。それ以外の場合は、 &lt;code&gt;DO NOTHING&lt;/code&gt; ないでください。例では、 &lt;code&gt;is_active&lt;/code&gt; ブール列が &lt;code&gt;true&lt;/code&gt; と評価される行のサブセットの &lt;code&gt;did&lt;/code&gt; 列に表示される値を制約する一意のインデックスが定義されていると想定しています。</target>
        </trans-unit>
        <trans-unit id="db80c622e1c5ed5095a7dd936600840392c749b3" translate="yes" xml:space="preserve">
          <source>Insert or update new distributors as appropriate. Assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column. Note that the special &lt;code&gt;excluded&lt;/code&gt; table is used to reference values originally proposed for insertion:</source>
          <target state="translated">必要に応じて、新しいディストリビューターを挿入または更新します。did 列に表示される値を制約する一意のインデックスが定義されていると仮定 &lt;code&gt;did&lt;/code&gt; ます。特別に &lt;code&gt;excluded&lt;/code&gt; テーブルは、最初に挿入が提案された値を参照するために使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="449538b0ed8e6f507ea1c64d35164fae0d826023" translate="yes" xml:space="preserve">
          <source>Insert or update new distributors as appropriate. Example assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column. &lt;code&gt;WHERE&lt;/code&gt; clause is used to limit the rows actually updated (any existing row not updated will still be locked, though):</source>
          <target state="translated">必要に応じて、新しいディストリビューターを挿入または更新します。例では、 &lt;code&gt;did&lt;/code&gt; 列に表示される値を制約する一意のインデックスが定義されていると想定しています。 &lt;code&gt;WHERE&lt;/code&gt; 句は、実際に更新される行を制限するために使用されます（ただし、更新されていない既存の行はロックされます）。</target>
        </trans-unit>
        <trans-unit id="ae6eaf6a32e43f0bf6ecef28e872215845bae1e6" translate="yes" xml:space="preserve">
          <source>Inserting</source>
          <target state="translated">Inserting</target>
        </trans-unit>
        <trans-unit id="0dd2b481ad724309af4e29174757be7f9ad67dd8" translate="yes" xml:space="preserve">
          <source>Inserting Data</source>
          <target state="translated">データの挿入</target>
        </trans-unit>
        <trans-unit id="a58e264f985643a8003e2d8ae2f19f1f44151747" translate="yes" xml:space="preserve">
          <source>Insertion into a GIN index can be slow due to the likelihood of many keys being inserted for each item. So, for bulk insertions into a table it is advisable to drop the GIN index and recreate it after finishing bulk insertion.</source>
          <target state="translated">GINインデックスへの挿入は、項目ごとに多くのキーが挿入される可能性があるため、挿入に時間がかかることがあります。そのため、テーブルへの一括挿入では、一括挿入を終えた後にGINインデックスを削除して再作成することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a514639c0e9db066f2ca50c5677c9c0ad2871adb" translate="yes" xml:space="preserve">
          <source>Inside the crosstab grid, for each distinct value &lt;code&gt;x&lt;/code&gt; of &lt;code&gt;colH&lt;/code&gt; and each distinct value &lt;code&gt;y&lt;/code&gt; of &lt;code&gt;colV&lt;/code&gt;, the cell located at the intersection &lt;code&gt;(x,y)&lt;/code&gt; contains the value of the &lt;code&gt;colD&lt;/code&gt; column in the query result row for which the value of &lt;code&gt;colH&lt;/code&gt; is &lt;code&gt;x&lt;/code&gt; and the value of &lt;code&gt;colV&lt;/code&gt; is &lt;code&gt;y&lt;/code&gt;. If there is no such row, the cell is empty. If there are multiple such rows, an error is reported.</source>
          <target state="translated">クロス集計グリッドの内側に、それぞれ異なる値のために &lt;code&gt;x&lt;/code&gt; の &lt;code&gt;colH&lt;/code&gt; それぞれ異なる値 &lt;code&gt;y&lt;/code&gt; の &lt;code&gt;colV&lt;/code&gt; 、交差点に位置するセル &lt;code&gt;(x,y)&lt;/code&gt; の値が含まれている &lt;code&gt;colD&lt;/code&gt; の値れるクエリ結果行の列 &lt;code&gt;colH&lt;/code&gt; があるの &lt;code&gt;x&lt;/code&gt; で、 &lt;code&gt;colV&lt;/code&gt; の値は &lt;code&gt;y&lt;/code&gt; です。そのような行がない場合、セルは空です。そのような行が複数ある場合、エラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="b00cb7892b66a87132bdd26b6401b8b521c81e40" translate="yes" xml:space="preserve">
          <source>Inspect the contents of the database to ensure you have recovered to the desired state. If not, return to step 1. If all is well, allow your users to connect by restoring &lt;code&gt;pg_hba.conf&lt;/code&gt; to normal.</source>
          <target state="translated">データベースの内容を調べて、目的の状態に回復したことを確認します。そうでない場合は、手順1に戻ります。問題がなければ、 &lt;code&gt;pg_hba.conf&lt;/code&gt; を通常の状態に戻して、ユーザーが接続できるようにします。</target>
        </trans-unit>
        <trans-unit id="bb93c6938a2011d934988eab5986d385a4c4d0be" translate="yes" xml:space="preserve">
          <source>Inspecting the MCV list is possible using &lt;code&gt;pg_mcv_list_items&lt;/code&gt; set-returning function.</source>
          <target state="translated">MCVリストの検査は、 &lt;code&gt;pg_mcv_list_items&lt;/code&gt; セットを返す関数を使用して可能です。</target>
        </trans-unit>
        <trans-unit id="ff17c423681bf713fcd55cb3b3eb644d120028a0" translate="yes" xml:space="preserve">
          <source>Inspired by the original &lt;code&gt;citext&lt;/code&gt; module by Donald Fraser.</source>
          <target state="translated">Donald Fraserによるオリジナルの &lt;code&gt;citext&lt;/code&gt; モジュールに触発されました。</target>
        </trans-unit>
        <trans-unit id="e2f807d3934f67c59236ce54638758a511971353" translate="yes" xml:space="preserve">
          <source>Install any custom shared object files (or DLLs) used by the old cluster into the new cluster, e.g. &lt;code&gt;pgcrypto.so&lt;/code&gt;, whether they are from &lt;code&gt;contrib&lt;/code&gt; or some other source. Do not install the schema definitions, e.g. &lt;code&gt;CREATE EXTENSION pgcrypto&lt;/code&gt;, because these will be upgraded from the old cluster. Also, any custom full text search files (dictionary, synonym, thesaurus, stop words) must also be copied to the new cluster.</source>
          <target state="translated">例えば、新しいクラスタに古いクラスタで使用される任意のカスタム共有オブジェクトファイル（またはDLL）をインストールする &lt;code&gt;pgcrypto.so&lt;/code&gt; どこからであるかどうか、 &lt;code&gt;contrib&lt;/code&gt; または他のソース。スキーマ定義、たとえば &lt;code&gt;CREATE EXTENSION pgcrypto&lt;/code&gt; はインストールしないでください。これらは古いクラスターからアップグレードされるためです。また、カスタムの全文検索ファイル（辞書、同義語、類義語辞典、ストップワード）も新しいクラスターにコピーする必要があります。</target>
        </trans-unit>
        <trans-unit id="34a5a70619c2c19e2c9702b13c9847e5c653791a" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;hstore&quot;&gt;hstore&lt;/a&gt; extension into the current database:</source>
          <target state="translated">&lt;a href=&quot;hstore&quot;&gt;hstore&lt;/a&gt;拡張機能を現在のデータベースにインストールします。</target>
        </trans-unit>
        <trans-unit id="04f7a627a6509f6c7b363a56555a0d35366acc62" translate="yes" xml:space="preserve">
          <source>Install the &lt;code&gt;postgres_fdw&lt;/code&gt; extension using &lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION&lt;/a&gt;を使用して &lt;code&gt;postgres_fdw&lt;/code&gt; 拡張をインストールします。</target>
        </trans-unit>
        <trans-unit id="9684579d3e7c9b1f5825f61e639d95625abccadc" translate="yes" xml:space="preserve">
          <source>Install the new server's binaries and support files. pg_upgrade is included in a default installation.</source>
          <target state="translated">新しいサーバのバイナリとサポートファイルをインストールします。</target>
        </trans-unit>
        <trans-unit id="cb2992c5a571b6edb98a5bf527c86c020a33e35d" translate="yes" xml:space="preserve">
          <source>Install the new version of PostgreSQL as outlined in &lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html&quot;&gt;Section 16.4&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html&quot;&gt;セクション16.4の&lt;/a&gt;説明に従って、新しいバージョンのPostgreSQLをインストールします。</target>
        </trans-unit>
        <trans-unit id="90075fb521dd4d59c46ee65abf78d28b40851d8c" translate="yes" xml:space="preserve">
          <source>Install the same custom shared object files on the new standbys that you installed in the new primary cluster.</source>
          <target state="translated">新しいプライマリクラスタにインストールしたのと同じカスタム共有オブジェクトファイルを新しいスタンバイにインストールします。</target>
        </trans-unit>
        <trans-unit id="00a4641a5ec01b91ac5755c29e1f7d10ca370b2e" translate="yes" xml:space="preserve">
          <source>Installing the &lt;code&gt;dict_int&lt;/code&gt; extension creates a text search template &lt;code&gt;intdict_template&lt;/code&gt; and a dictionary &lt;code&gt;intdict&lt;/code&gt; based on it, with the default parameters. You can alter the parameters, for example</source>
          <target state="translated">&lt;code&gt;dict_int&lt;/code&gt; 拡張機能をインストールすると、デフォルトのパラメーターを使用して、テキスト検索テンプレート &lt;code&gt;intdict_template&lt;/code&gt; とそれに基づく辞書 &lt;code&gt;intdict&lt;/code&gt; が作成されます。たとえば、パラメータを変更できます</target>
        </trans-unit>
        <trans-unit id="88a4b249e71fce074c62157e59fbc27119675b0b" translate="yes" xml:space="preserve">
          <source>Installing the &lt;code&gt;dict_xsyn&lt;/code&gt; extension creates a text search template &lt;code&gt;xsyn_template&lt;/code&gt; and a dictionary &lt;code&gt;xsyn&lt;/code&gt; based on it, with default parameters. You can alter the parameters, for example</source>
          <target state="translated">&lt;code&gt;dict_xsyn&lt;/code&gt; 拡張機能をインストールすると、テキスト検索テンプレート &lt;code&gt;xsyn_template&lt;/code&gt; と &lt;code&gt;xsyn&lt;/code&gt; 基づく辞書xsynが作成され、デフォルトのパラメーターが設定されます。たとえば、パラメータを変更できます</target>
        </trans-unit>
        <trans-unit id="cf52efd63633f939852f89750e72d737a7ef8451" translate="yes" xml:space="preserve">
          <source>Installing the &lt;code&gt;unaccent&lt;/code&gt; extension creates a text search template &lt;code&gt;unaccent&lt;/code&gt; and a dictionary &lt;code&gt;unaccent&lt;/code&gt; based on it. The &lt;code&gt;unaccent&lt;/code&gt; dictionary has the default parameter setting &lt;code&gt;RULES='unaccent'&lt;/code&gt;, which makes it immediately usable with the standard &lt;code&gt;unaccent.rules&lt;/code&gt; file. If you wish, you can alter the parameter, for example</source>
          <target state="translated">&lt;code&gt;unaccent&lt;/code&gt; 拡張機能をインストールすると、テキスト検索テンプレート &lt;code&gt;unaccent&lt;/code&gt; とそれに基づいた辞書 &lt;code&gt;unaccent&lt;/code&gt; が作成されます。 &lt;code&gt;unaccent&lt;/code&gt; 辞書は、デフォルトのパラメータ設定がある &lt;code&gt;RULES='unaccent'&lt;/code&gt; 標準で、それはすぐに使用可能になり、 &lt;code&gt;unaccent.rules&lt;/code&gt; ファイルを。必要に応じて、パラメータを変更できます。たとえば、</target>
        </trans-unit>
        <trans-unit id="5b4ebcd87748b86d7b51facd78d76e7b88a0adf7" translate="yes" xml:space="preserve">
          <source>Instead of an expression, &lt;code&gt;*&lt;/code&gt; can be written in the output list as a shorthand for all the columns of the selected rows. Also, you can write &lt;code&gt;table_name.*&lt;/code&gt; as a shorthand for the columns coming from just that table. In these cases it is not possible to specify new names with &lt;code&gt;AS&lt;/code&gt;; the output column names will be the same as the table columns' names.</source>
          <target state="translated">式の代わりに、 &lt;code&gt;*&lt;/code&gt; を選択した行のすべての列の省略形として出力リストに書き込むことができます。また、 &lt;code&gt;table_name.*&lt;/code&gt; を、そのテーブルからの列の省略形として書くこともできます。これらの場合、 &lt;code&gt;AS&lt;/code&gt; で新しい名前を指定することはできません。出力列の名前は、テーブルの列の名前と同じになります。</target>
        </trans-unit>
        <trans-unit id="a6521c09d55a0d983da28cb3b1223e411f459cda" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;amgettuple&lt;/code&gt;, an index scan can be done with &lt;code&gt;amgetbitmap&lt;/code&gt; to fetch all tuples in one call. This can be noticeably more efficient than &lt;code&gt;amgettuple&lt;/code&gt; because it allows avoiding lock/unlock cycles within the access method. In principle &lt;code&gt;amgetbitmap&lt;/code&gt; should have the same effects as repeated &lt;code&gt;amgettuple&lt;/code&gt; calls, but we impose several restrictions to simplify matters. First of all, &lt;code&gt;amgetbitmap&lt;/code&gt; returns all tuples at once and marking or restoring scan positions isn't supported. Secondly, the tuples are returned in a bitmap which doesn't have any specific ordering, which is why &lt;code&gt;amgetbitmap&lt;/code&gt; doesn't take a &lt;code&gt;direction&lt;/code&gt; argument. (Ordering operators will never be supplied for such a scan, either.) Also, there is no provision for index-only scans with &lt;code&gt;amgetbitmap&lt;/code&gt;, since there is no way to return the contents of index tuples. Finally, &lt;code&gt;amgetbitmap&lt;/code&gt; does not guarantee any locking of the returned tuples, with implications spelled out in &lt;a href=&quot;index-locking&quot;&gt;Section 61.4&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;amgettuple&lt;/code&gt; を使用する代わりに、 &lt;code&gt;amgetbitmap&lt;/code&gt; を使用してインデックススキャンを実行し、1回の呼び出しですべてのタプルをフェッチできます。これは、アクセス方法内のロック/ロック解除サイクルを回避できるため、 &lt;code&gt;amgettuple&lt;/code&gt; よりも著しく効率的です。原則として &lt;code&gt;amgetbitmap&lt;/code&gt; は &lt;code&gt;amgettuple&lt;/code&gt; を繰り返し呼び出すのと同じ効果がありますが、問題を単純化するためにいくつかの制限を課しています。まず、 &lt;code&gt;amgetbitmap&lt;/code&gt; はすべてのタプルを一度に返します。スキャン位置のマークまたは復元はサポートされていません。次に、タプルは特定の順序付けがないビットマップで返されます。これが、 &lt;code&gt;amgetbitmap&lt;/code&gt; が &lt;code&gt;direction&lt;/code&gt; とらない理由です。引数。（このようなスキャンでも順序付け演算子が提供されることはありません。）また、インデックスタプルの内容を返す方法がないため、 &lt;code&gt;amgetbitmap&lt;/code&gt; を使用したインデックスのみのスキャンには対応していません。最後に、 &lt;code&gt;amgetbitmap&lt;/code&gt; はで綴ら意味合いで、返されるタプルのいずれかのロックを保証するものではありません&lt;a href=&quot;index-locking&quot;&gt;、セクション61.4&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d79849f61d583b44d9d0fdc8025d98ffb5bbfd35" translate="yes" xml:space="preserve">
          <source>Instead of writing &lt;code&gt;ONLY&lt;/code&gt; before the table name, you can write &lt;code&gt;*&lt;/code&gt; after the table name to explicitly specify that descendant tables are included. There is no real reason to use this syntax any more, because searching descendant tables is now always the default behavior. However, it is supported for compatibility with older releases.</source>
          <target state="translated">テーブル名の前に &lt;code&gt;ONLY&lt;/code&gt; を記述する代わりに、テーブル名の後に &lt;code&gt;*&lt;/code&gt; を記述して、子孫テーブルが含まれることを明示的に指定できます。子孫テーブルの検索が常にデフォルトの動作になるため、この構文を使用する本当の理由はありません。ただし、以前のリリースとの互換性のためにサポートされています。</target>
        </trans-unit>
        <trans-unit id="4a1635249102b1ddea4769929b8a71df3f648e09" translate="yes" xml:space="preserve">
          <source>Institute of Electrical and Electronics Engineers</source>
          <target state="translated">電気電子学会</target>
        </trans-unit>
        <trans-unit id="e877a09ab092ea6de15878a42ea4226bbdc6693d" translate="yes" xml:space="preserve">
          <source>Integer bit mask indicating which arguments are not being included in the current grouping set</source>
          <target state="translated">現在のグループ化セットに含まれない引数を示す整数ビットマスク</target>
        </trans-unit>
        <trans-unit id="897c83dd3fcb5ef382c1b65917bd9be2f5323fd2" translate="yes" xml:space="preserve">
          <source>Inter-Process Communication</source>
          <target state="translated">プロセス間通信</target>
        </trans-unit>
        <trans-unit id="d85d227df828a06ee1ce26f9f247a35c482de85a" translate="yes" xml:space="preserve">
          <source>Interesting idea for picking passwords.</source>
          <target state="translated">パスワードを選ぶための興味深いアイデア。</target>
        </trans-unit>
        <trans-unit id="457737863c2801b7971002cd15c9223e0c9b404e" translate="yes" xml:space="preserve">
          <source>Interfacing with monitoring software to report errors</source>
          <target state="translated">エラーを報告するための監視ソフトウェアとのインターフェース</target>
        </trans-unit>
        <trans-unit id="bc34e531672634aab3b26d4017b45aa2bbc7b3db" translate="yes" xml:space="preserve">
          <source>Interfacing with other backup and recovery software</source>
          <target state="translated">他のバックアップおよびリカバリソフトウェアとの連携</target>
        </trans-unit>
        <trans-unit id="087813fa40caa10b888af01dbc97f7437b81b67d" translate="yes" xml:space="preserve">
          <source>Intermediate certificates that chain up to existing root certificates can also appear in the &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt; file if you wish to avoid storing them on clients (assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions). Certificate Revocation List (CRL) entries are also checked if the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL-CRL-FILE&quot;&gt;ssl_crl_file&lt;/a&gt; is set. (See &lt;a href=&quot;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&quot;&gt;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&lt;/a&gt; for diagrams showing SSL certificate usage.)</source>
          <target state="translated">既存のルート証明書にチェーンする中間証明書は、クライアントに保存しないようにしたい場合は、&lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt;ファイルにも表示できます（ルート証明書と中間証明書が &lt;code&gt;v3_ca&lt;/code&gt; 拡張で作成されたと想定）。証明書失効リスト（CRL）エントリも、パラメータ&lt;a href=&quot;runtime-config-connection#GUC-SSL-CRL-FILE&quot;&gt;ssl_crl_file&lt;/a&gt;が設定されている場合にチェックされます。 （SSL証明書の使用法を示す図については、&lt;a href=&quot;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&quot;&gt;http：//h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="a6ed083a1fd80d11b5474ab6a44b299da8513f67" translate="yes" xml:space="preserve">
          <source>Internal data structures such as &lt;code&gt;pg_xact&lt;/code&gt;, &lt;code&gt;pg_subtrans&lt;/code&gt;, &lt;code&gt;pg_multixact&lt;/code&gt;, &lt;code&gt;pg_serial&lt;/code&gt;, &lt;code&gt;pg_notify&lt;/code&gt;, &lt;code&gt;pg_stat&lt;/code&gt;, &lt;code&gt;pg_snapshots&lt;/code&gt; are not directly checksummed, nor are pages protected by full page writes. However, where such data structures are persistent, WAL records are written that allow recent changes to be accurately rebuilt at crash recovery and those WAL records are protected as discussed above.</source>
          <target state="translated">&lt;code&gt;pg_xact&lt;/code&gt; 、 &lt;code&gt;pg_subtrans&lt;/code&gt; 、 &lt;code&gt;pg_multixact&lt;/code&gt; 、 &lt;code&gt;pg_serial&lt;/code&gt; 、 &lt;code&gt;pg_notify&lt;/code&gt; 、 &lt;code&gt;pg_stat&lt;/code&gt; 、 &lt;code&gt;pg_snapshots&lt;/code&gt; などの内部データ構造は直接チェックサムされず、ページ全体の書き込みによってページが保護されません。ただし、このようなデータ構造が永続的である場合は、クラッシュリカバリ時に最近の変更を正確に再構築できるWALレコードが書き込まれ、これらのWALレコードは上記のように保護されます。</target>
        </trans-unit>
        <trans-unit id="210293c0eebe094c6cf4191095ebf7c83ba53d58" translate="yes" xml:space="preserve">
          <source>Internal hash code, computed from the statement's parse tree</source>
          <target state="translated">ステートメントの構文解析ツリーから計算される内部ハッシュコード</target>
        </trans-unit>
        <trans-unit id="e2daadb2e211983a80b38897bed9d140e91cd8e5" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;interval&lt;/code&gt; values are stored as months, days, and seconds. This is done because the number of days in a month varies, and a day can have 23 or 25 hours if a daylight savings time adjustment is involved. The months and days fields are integers while the seconds field can store fractions. Because intervals are usually created from constant strings or &lt;code&gt;timestamp&lt;/code&gt; subtraction, this storage method works well in most cases, but can cause unexpected results:</source>
          <target state="translated">内部的には、 &lt;code&gt;interval&lt;/code&gt; 値は月、日、秒として格納されます。これは、1か月の日数が異なり、夏時間が調整されている場合は1日が23時間または25時間になる可能性があるためです。月と日のフィールドは整数であり、秒のフィールドは分数を格納できます。間隔は通常、定数の文字列または &lt;code&gt;timestamp&lt;/code&gt; 減算から作成されるため、この格納方法はほとんどの場合うまく機能しますが、予期しない結果を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="95d68b94ef37a16fd1db6257f62457d5c440b435" translate="yes" xml:space="preserve">
          <source>Internally, a GIN index contains a B-tree index constructed over keys, where each key is an element of one or more indexed items (a member of an array, for example) and where each tuple in a leaf page contains either a pointer to a B-tree of heap pointers (a &amp;ldquo;posting tree&amp;rdquo;), or a simple list of heap pointers (a &amp;ldquo;posting list&amp;rdquo;) when the list is small enough to fit into a single index tuple along with the key value. &lt;a href=&quot;gin-implementation#GIN-INTERNALS-FIGURE&quot;&gt;Figure 66.1&lt;/a&gt; illustrates these components of a GIN index.</source>
          <target state="translated">内部的には、GINインデックスには、キー上に構築されたBツリーインデックスが含まれます。各キーは、1つ以上のインデックス付きアイテムの要素（たとえば、配列のメンバー）であり、リーフページの各タプルには、リストがキー値と共に単一のインデックスタプルに収まるほど小さい場合は、ヒープポインターのBツリー（「投稿ツリー」）、またはヒープポインターの単純なリスト（「投稿リスト」）。&lt;a href=&quot;gin-implementation#GIN-INTERNALS-FIGURE&quot;&gt;図66.1&lt;/a&gt;は、GINインデックスのこれらのコンポーネントを示しています。</target>
        </trans-unit>
        <trans-unit id="7c7cae0387037fdfc011139b31adb37771e499bb" translate="yes" xml:space="preserve">
          <source>Internally, all these types use the same representation (a 64-bit integer), and all are interchangeable. Multiple types are provided to control display formatting and to permit tighter validity checking of input that is supposed to denote one particular type of number.</source>
          <target state="translated">内部的には、これらの型はすべて同じ表現(64ビット整数)を使用し、すべて互換性があります。複数の型が用意されているのは、表示の書式を制御したり、ある特定のタイプの数値を表すことになっている入力の有効性をより厳密にチェックしたりするためです。</target>
        </trans-unit>
        <trans-unit id="801996043d0146904ef0a7b7426c0b0decab6e65" translate="yes" xml:space="preserve">
          <source>Internally, an LSN is a 64-bit integer, representing a byte position in the write-ahead log stream. It is printed as two hexadecimal numbers of up to 8 digits each, separated by a slash; for example, &lt;code&gt;16/B374D848&lt;/code&gt;. The &lt;code&gt;pg_lsn&lt;/code&gt; type supports the standard comparison operators, like &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. Two LSNs can be subtracted using the &lt;code&gt;-&lt;/code&gt; operator; the result is the number of bytes separating those write-ahead log locations.</source>
          <target state="translated">内部的には、LSNは64ビット整数であり、先読みログストリームのバイト位置を表します。スラッシュで区切られた、それぞれ最大8桁の2つの16進数として出力されます。たとえば、 &lt;code&gt;16/B374D848&lt;/code&gt; 。 &lt;code&gt;pg_lsn&lt;/code&gt; のタイプのような、標準的な比較演算子をサポートしています &lt;code&gt;=&lt;/code&gt; と &lt;code&gt;&amp;gt;&lt;/code&gt; 。 &lt;code&gt;-&lt;/code&gt; 演算子を使用すると、2つのLSNを減算できます。結果は、これらの先行書き込みログの場所を区切るバイト数です。</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="68baab823cf9c4d570311e278e9e088b97918aa9" translate="yes" xml:space="preserve">
          <source>Internals: BRIN Indexes</source>
          <target state="translated">内部の様子。BRINインデックス</target>
        </trans-unit>
        <trans-unit id="30d8bd593f993584038a1e0fe42a81f00b0963a3" translate="yes" xml:space="preserve">
          <source>Internals: Catalogs</source>
          <target state="translated">内部情報。カタログ</target>
        </trans-unit>
        <trans-unit id="3af4bd3be7009ecb5492dd21a7a43e553ce2cd0e" translate="yes" xml:space="preserve">
          <source>Internals: GIN Indexes</source>
          <target state="translated">内部情報 GINインデックス</target>
        </trans-unit>
        <trans-unit id="dc575f859035c87eddb3703eb9f32faa91a064d5" translate="yes" xml:space="preserve">
          <source>Internals: Genetic Query Optimizer</source>
          <target state="translated">内部。遺伝的クエリオプティマイザ</target>
        </trans-unit>
        <trans-unit id="2fdd0d171f1a82304db06140f5b0e0b132641e9d" translate="yes" xml:space="preserve">
          <source>Internals: GiST Indexes</source>
          <target state="translated">内部情報 GiSTインデックス</target>
        </trans-unit>
        <trans-unit id="3353317a88b7d0fe5733c291ee0c6066760bb027" translate="yes" xml:space="preserve">
          <source>Internals: Index Access Method</source>
          <target state="translated">内部的には インデックスアクセス方式</target>
        </trans-unit>
        <trans-unit id="2cfa78663fb409507ad30892f6c62ca88915c849" translate="yes" xml:space="preserve">
          <source>Internals: Physical Storage</source>
          <target state="translated">内部。物理ストレージ</target>
        </trans-unit>
        <trans-unit id="72bd21b653073da0193a18c2b147b4e07c551c2d" translate="yes" xml:space="preserve">
          <source>Internals: SP-GiST Indexes</source>
          <target state="translated">内部情報 SP-GISTインデックス</target>
        </trans-unit>
        <trans-unit id="9a4222dfc9fdc77f19f92dba6e20438075629f39" translate="yes" xml:space="preserve">
          <source>International Electrotechnical Commission</source>
          <target state="translated">国際電気標準会議</target>
        </trans-unit>
        <trans-unit id="efd83bf4b70a77811c228aa3f499876839b1a079" translate="yes" xml:space="preserve">
          <source>International Organization for Standardization</source>
          <target state="translated">国際標準化機構</target>
        </trans-unit>
        <trans-unit id="2bafd8d16b13f2565f9ae12e4063fa2d0cddcfb9" translate="yes" xml:space="preserve">
          <source>International Standard Book Numbers to be displayed in the new EAN13 display format</source>
          <target state="translated">国際標準図書番号が新しいEAN13表示形式で表示されるようになりました。</target>
        </trans-unit>
        <trans-unit id="08b688b4eb6cf112f11ba47bac6e099bfb8d453f" translate="yes" xml:space="preserve">
          <source>International Standard Book Numbers to be displayed in the old short display format</source>
          <target state="translated">国際標準図書の番号を旧短表示形式で表示するようにしました。</target>
        </trans-unit>
        <trans-unit id="ebb2e09bb43f37cc7a01fd763ee8d3845536f4c8" translate="yes" xml:space="preserve">
          <source>International Standard Music Numbers to be displayed in the new EAN13 display format</source>
          <target state="translated">新表示形式EAN13で表示される国際標準音楽番号</target>
        </trans-unit>
        <trans-unit id="ef34d5e58a9ceadea54e7a66e1ff9112f05b0da0" translate="yes" xml:space="preserve">
          <source>International Standard Music Numbers to be displayed in the old short display format</source>
          <target state="translated">国際標準音楽番号を旧短表示形式で表示するようにした</target>
        </trans-unit>
        <trans-unit id="8dd6340c1b5827c9a707b92916af32dcdcd785bc" translate="yes" xml:space="preserve">
          <source>International Standard Serial Number</source>
          <target state="translated">国際標準シリアル番号</target>
        </trans-unit>
        <trans-unit id="4e1c1c5e087cdba177b1e3d204777d49f8f64412" translate="yes" xml:space="preserve">
          <source>International Standard Serial Numbers to be displayed in the new EAN13 display format</source>
          <target state="translated">新しいEAN13表示形式で表示される国際標準シリアル番号</target>
        </trans-unit>
        <trans-unit id="105b56360755198078a6d52573dd0840458a5750" translate="yes" xml:space="preserve">
          <source>International Standard Serial Numbers to be displayed in the old short display format</source>
          <target state="translated">国際標準シリアル番号を旧ショートディスプレイ形式で表示するようにしました。</target>
        </trans-unit>
        <trans-unit id="15470fd033e12b800743519c6e594f7da0f4f0f0" translate="yes" xml:space="preserve">
          <source>Interpretation</source>
          <target state="translated">Interpretation</target>
        </trans-unit>
        <trans-unit id="8fa33d4271f21b38b9499a714668d1694939db92" translate="yes" xml:space="preserve">
          <source>Interpreting Results</source>
          <target state="translated">結果の解釈</target>
        </trans-unit>
        <trans-unit id="27d548cba7b30ac38c7cf5611fd348dac11ee53d" translate="yes" xml:space="preserve">
          <source>Interpreting the actual data can only be done with information obtained from other tables, mostly &lt;code&gt;pg_attribute&lt;/code&gt;. The key values needed to identify field locations are &lt;code&gt;attlen&lt;/code&gt; and &lt;code&gt;attalign&lt;/code&gt;. There is no way to directly get a particular attribute, except when there are only fixed width fields and no null values. All this trickery is wrapped up in the functions &lt;em&gt;heap_getattr&lt;/em&gt;, &lt;em&gt;fastgetattr&lt;/em&gt; and &lt;em&gt;heap_getsysattr&lt;/em&gt;.</source>
          <target state="translated">実際のデータの解釈は、他のテーブル、主に &lt;code&gt;pg_attribute&lt;/code&gt; から取得した情報でのみ実行できます。フィールドの場所を特定するために必要な主要な値は、 &lt;code&gt;attlen&lt;/code&gt; と &lt;code&gt;attalign&lt;/code&gt; です。固定幅フィールドのみがあり、null値がない場合を除いて、特定の属性を直接取得する方法はありません。このすべてのトリックは、関数&lt;em&gt;heap_getattr&lt;/em&gt;、&lt;em&gt;fastgetattr&lt;/em&gt;、および&lt;em&gt;heap_getsysattrに&lt;/em&gt;ラップされています。</target>
        </trans-unit>
        <trans-unit id="24238f9afeb08c45bbce6cbe5bfc823ad38ca9fd" translate="yes" xml:space="preserve">
          <source>Intersects?</source>
          <target state="translated">Intersects?</target>
        </trans-unit>
        <trans-unit id="4e15cd1f984843596070878cf276c50b3a281208" translate="yes" xml:space="preserve">
          <source>Interval from &lt;code&gt;x&lt;/code&gt; - &lt;code&gt;delta&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; + &lt;code&gt;delta&lt;/code&gt;</source>
          <target state="translated">間隔から &lt;code&gt;x&lt;/code&gt; - &lt;code&gt;delta&lt;/code&gt; に &lt;code&gt;x&lt;/code&gt; + &lt;code&gt;delta&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="264b54df84208c3c82823ada24d9901903b36609" translate="yes" xml:space="preserve">
          <source>Interval from &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; から &lt;code&gt;y&lt;/code&gt; までの間隔</target>
        </trans-unit>
        <trans-unit id="d6c942376df50e42c9c8ec0a3deb9eba3459225b" translate="yes" xml:space="preserve">
          <source>Interval values can also be written as ISO 8601 time intervals, using either the &amp;ldquo;format with designators&amp;rdquo; of the standard's section 4.4.3.2 or the &amp;ldquo;alternative format&amp;rdquo; of section 4.4.3.3. The format with designators looks like this:</source>
          <target state="translated">間隔の値は、規格のセクション4.4.3.2の「指定子付きのフォーマット」またはセクション4.4.3.3の「代替フォーマット」を使用して、ISO 8601時間間隔として書き込むこともできます。指定子付きのフォーマットは次のようになります。</target>
        </trans-unit>
        <trans-unit id="e96fd04cfd40c6866ae4fadc2523f325bbca5474" translate="yes" xml:space="preserve">
          <source>Intuitively, the larger the &lt;code&gt;parameter&lt;/code&gt;, the more frequently values close to &lt;code&gt;min&lt;/code&gt; are accessed, and the less frequently values close to &lt;code&gt;max&lt;/code&gt; are accessed. The closer to 0 &lt;code&gt;parameter&lt;/code&gt; is, the flatter (more uniform) the access distribution. A crude approximation of the distribution is that the most frequent 1% values in the range, close to &lt;code&gt;min&lt;/code&gt;, are drawn &lt;code&gt;parameter&lt;/code&gt;% of the time. The &lt;code&gt;parameter&lt;/code&gt; value must be strictly positive.</source>
          <target state="translated">直感的には、 &lt;code&gt;parameter&lt;/code&gt; が大きいほど、 &lt;code&gt;min&lt;/code&gt; に近い値にアクセスする頻度が高くなり、 &lt;code&gt;max&lt;/code&gt; に近い値にアクセスする頻度が少なくなります。 &lt;code&gt;parameter&lt;/code&gt; が0に近いほど、アクセス分布はよりフラット（より均一）になります。分布の大雑把な概算は、 &lt;code&gt;min&lt;/code&gt; に近い範囲で最も頻繁な1％の値が、時間の &lt;code&gt;parameter&lt;/code&gt; として描画されることです。 &lt;code&gt;parameter&lt;/code&gt; 値が厳密に正でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d4c4d2a44d0c1732fb4957da686a2c8c6fd4c621" translate="yes" xml:space="preserve">
          <source>Inverse transition function for moving-aggregate mode (zero if none)</source>
          <target state="translated">移動アグリゲートモードの逆遷移関数(ない場合はゼロ)</target>
        </trans-unit>
        <trans-unit id="28b7eaaae619dbbc89f335962aef4470def2f3e3" translate="yes" xml:space="preserve">
          <source>Invoke &lt;code&gt;VACUUM&lt;/code&gt; on the standard tables.</source>
          <target state="translated">標準テーブルで &lt;code&gt;VACUUM&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="3018fd4dab61ebc08a8223638bc64040a2d9e057" translate="yes" xml:space="preserve">
          <source>Is above (allows touching)?</source>
          <target state="translated">上記は(触れることができる)ですか?</target>
        </trans-unit>
        <trans-unit id="da6fc6925748c3c1aaf71338cad9d5f477a2383e" translate="yes" xml:space="preserve">
          <source>Is below (allows touching)?</source>
          <target state="translated">下は(触ることができる)ですか?</target>
        </trans-unit>
        <trans-unit id="ea56f04ac22e5eca73342cefd404d9c1b002af61" translate="yes" xml:space="preserve">
          <source>Is horizontal?</source>
          <target state="translated">横長なのかな?</target>
        </trans-unit>
        <trans-unit id="c9fe9c5adbc8c22895dcd6a5a3619390deb9964a" translate="yes" xml:space="preserve">
          <source>Is perpendicular?</source>
          <target state="translated">垂直なのか?</target>
        </trans-unit>
        <trans-unit id="fefaf9d6dfa31078880e5655df30026e38004358" translate="yes" xml:space="preserve">
          <source>Is strictly above?</source>
          <target state="translated">厳密には上ですか?</target>
        </trans-unit>
        <trans-unit id="a05cc4a278817fbe41225c1212990f7a42609499" translate="yes" xml:space="preserve">
          <source>Is strictly below?</source>
          <target state="translated">厳密には下なのかな?</target>
        </trans-unit>
        <trans-unit id="b70722f5747da5b37c94b2e21f108653a4a0d9d2" translate="yes" xml:space="preserve">
          <source>Is strictly left of?</source>
          <target state="translated">厳密には左かな?</target>
        </trans-unit>
        <trans-unit id="c41dadb911bf56e59cfeff92444afa779a0c9714" translate="yes" xml:space="preserve">
          <source>Is strictly right of?</source>
          <target state="translated">厳密には正しいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="0992b021bae889bee0f11abcbb95dee7929e73aa" translate="yes" xml:space="preserve">
          <source>Is the collation deterministic?</source>
          <target state="translated">照合は決定論的なのか?</target>
        </trans-unit>
        <trans-unit id="8a25c1b43d537dd1a7d2ddd1e8080433f5e3eacd" translate="yes" xml:space="preserve">
          <source>Is the constraint deferrable?</source>
          <target state="translated">制約は延期可能ですか?</target>
        </trans-unit>
        <trans-unit id="fef490f8fe9dee88c33c6a89d30667da1bd2fb9a" translate="yes" xml:space="preserve">
          <source>Is the constraint deferred by default?</source>
          <target state="translated">制約はデフォルトで延期されていますか?</target>
        </trans-unit>
        <trans-unit id="db516f5dadc3d5e25dea043648eeea3321f5ccdb" translate="yes" xml:space="preserve">
          <source>Is the page dirty?</source>
          <target state="translated">ページが汚い?</target>
        </trans-unit>
        <trans-unit id="7a5b28f2abec65dff2a005cef1bab93ce79757ac" translate="yes" xml:space="preserve">
          <source>Is the policy permissive or restrictive?</source>
          <target state="translated">ポリシーは寛容なのか、それとも制限的なのか?</target>
        </trans-unit>
        <trans-unit id="272dd553360faca6d08c14d4f1b40a013a88fc82" translate="yes" xml:space="preserve">
          <source>Is vertical?</source>
          <target state="translated">垂直なのか?</target>
        </trans-unit>
        <trans-unit id="04fa9226f0713bae8b60402f090506b8771675ec" translate="yes" xml:space="preserve">
          <source>Isolation Level</source>
          <target state="translated">絶縁レベル</target>
        </trans-unit>
        <trans-unit id="5ef461ce76cd9304ad8686fa89152e4b6011f931" translate="yes" xml:space="preserve">
          <source>Ispell dictionaries support splitting compound words; a useful feature. Notice that the affix file should specify a special flag using the &lt;code&gt;compoundwords controlled&lt;/code&gt; statement that marks dictionary words that can participate in compound formation:</source>
          <target state="translated">Ispell辞書は複合語の分割をサポートしています。便利な機能。接辞ファイルでは、複合語の形成に参加できる辞書の単語をマークする &lt;code&gt;compoundwords controlled&lt;/code&gt; ステートメントを使用して、特別なフラグを指定する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a44764c80f1ba0b240d3f5d527b95ad90a01a872" translate="yes" xml:space="preserve">
          <source>Ispell dictionaries usually recognize a limited set of words, so they should be followed by another broader dictionary; for example, a Snowball dictionary, which recognizes everything.</source>
          <target state="translated">Ispell辞書は通常、限られた単語のセットを認識するので、それに続いて別のより広い辞書を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="d78243d5b6a6182e6f2ddf831b4aabfb7caae3f0" translate="yes" xml:space="preserve">
          <source>Issues a verification prompt before doing anything destructive.</source>
          <target state="translated">破壊的なことをする前に検証プロンプトを発行します。</target>
        </trans-unit>
        <trans-unit id="f4c1344e1b107a94e97cb2d1c0387b09d48b1998" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;ABORT&lt;/code&gt; outside of a transaction block emits a warning and otherwise has no effect.</source>
          <target state="translated">トランザクションブロックの外部で &lt;code&gt;ABORT&lt;/code&gt; を発行すると警告が発せられ、それ以外の場合は効果がありません。</target>
        </trans-unit>
        <trans-unit id="51092034eb6099bfab57ce2cf44c57b972ed851c" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;BEGIN&lt;/code&gt; when already inside a transaction block will provoke a warning message. The state of the transaction is not affected. To nest transactions within a transaction block, use savepoints (see &lt;a href=&quot;sql-savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;).</source>
          <target state="translated">すでにトランザクションブロック内で &lt;code&gt;BEGIN&lt;/code&gt; を発行すると、警告メッセージが表示されます。トランザクションの状態は影響を受けません。トランザクションをトランザクションブロック内にネストするには、セーブポイントを使用します（&lt;a href=&quot;sql-savepoint&quot;&gt;SAVEPOINTを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="1c66e92badb172759ea8ab0365668fbc4bfcd29b" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;COMMIT&lt;/code&gt; when not inside a transaction does no harm, but it will provoke a warning message. &lt;code&gt;COMMIT AND CHAIN&lt;/code&gt; when not inside a transaction is an error.</source>
          <target state="translated">トランザクション内にないときに &lt;code&gt;COMMIT&lt;/code&gt; を発行しても害はありませんが、警告メッセージが表示されます。トランザクション内にない場合の &lt;code&gt;COMMIT AND CHAIN&lt;/code&gt; はエラーです。</target>
        </trans-unit>
        <trans-unit id="d8f2914a3de77623d7fcc2d76c1402e19f0682c2" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;END&lt;/code&gt; when not inside a transaction does no harm, but it will provoke a warning message.</source>
          <target state="translated">トランザクション内にないときに &lt;code&gt;END&lt;/code&gt; を発行しても害はありませんが、警告メッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="9a3f1f230232d57deb86f9d1d1a7e859eaa17234" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;ROLLBACK&lt;/code&gt; outside of a transaction block emits a warning and otherwise has no effect. &lt;code&gt;ROLLBACK AND CHAIN&lt;/code&gt; outside of a transaction block is an error.</source>
          <target state="translated">トランザクションブロックの外部で &lt;code&gt;ROLLBACK&lt;/code&gt; を発行すると警告が発行され、それ以外の場合は効果がありません。トランザクションブロック外の &lt;code&gt;ROLLBACK AND CHAIN&lt;/code&gt; はエラーです。</target>
        </trans-unit>
        <trans-unit id="1dd72b5f30a56642ade69ef87bd0dd32591ebc8c" translate="yes" xml:space="preserve">
          <source>It can be used as a top-level command or as a space-saving syntax variant in parts of complex queries. Only the &lt;code&gt;WITH&lt;/code&gt;, &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, &lt;code&gt;EXCEPT&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt;, &lt;code&gt;OFFSET&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt; and &lt;code&gt;FOR&lt;/code&gt; locking clauses can be used with &lt;code&gt;TABLE&lt;/code&gt;; the &lt;code&gt;WHERE&lt;/code&gt; clause and any form of aggregation cannot be used.</source>
          <target state="translated">最上位のコマンドとして、または複雑なクエリの一部で省スペースの構文バリアントとして使用できます。 &lt;code&gt;TABLE&lt;/code&gt; で使用できるのは、 &lt;code&gt;WITH&lt;/code&gt; 、 &lt;code&gt;UNION&lt;/code&gt; 、 &lt;code&gt;INTERSECT&lt;/code&gt; 、 &lt;code&gt;EXCEPT&lt;/code&gt; 、 &lt;code&gt;ORDER BY&lt;/code&gt; 、 &lt;code&gt;LIMIT&lt;/code&gt; 、 &lt;code&gt;OFFSET&lt;/code&gt; 、 &lt;code&gt;FETCH&lt;/code&gt; および &lt;code&gt;FOR&lt;/code&gt; ロック句のみです。 &lt;code&gt;WHERE&lt;/code&gt; 句および凝集の任意の形態を使用することができません。</target>
        </trans-unit>
        <trans-unit id="985845c593d43702ba4580f789c62a95ef3e445a" translate="yes" xml:space="preserve">
          <source>It can return 2 special key IDs:</source>
          <target state="translated">2つの特殊なキーIDを返すことができます。</target>
        </trans-unit>
        <trans-unit id="e06e730d80da388853db0ab9a33a7b2a082e1e65" translate="yes" xml:space="preserve">
          <source>It creates a replication-mode connection, so it is subject to the same constraints as &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;, plus those for logical replication (see &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;).</source>
          <target state="translated">レプリケーションモードの接続を作成するため、&lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;と同じ制約に加えて、論理レプリケーションの制約が適用されます（&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;第48章を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="ee4e1383f1e9f315e70a9d76f0a1946de5a791a1" translate="yes" xml:space="preserve">
          <source>It does not matter which order the opposite corners of a cube are entered in. The &lt;code&gt;cube&lt;/code&gt; functions automatically swap values if needed to create a uniform &amp;ldquo;lower left &amp;mdash; upper right&amp;rdquo; internal representation. When the corners coincide, &lt;code&gt;cube&lt;/code&gt; stores only one corner along with an &amp;ldquo;is point&amp;rdquo; flag to avoid wasting space.</source>
          <target state="translated">立方体の反対側の角が入力される順序は関係ありません。 &lt;code&gt;cube&lt;/code&gt; 関数は、均一な「左下-右上」の内部表現を作成する必要がある場合、値を自動的に入れ替えます。コーナーが一致する場合、 &lt;code&gt;cube&lt;/code&gt; はスペースを無駄にしないように、「is point」フラグとともにコーナーを1つだけ格納します。</target>
        </trans-unit>
        <trans-unit id="aeb260c8d10781feddd45ff6a16008fdceb285b4" translate="yes" xml:space="preserve">
          <source>It does so by first creating all possible &lt;em&gt;paths&lt;/em&gt; leading to the same result. For example if there is an index on a relation to be scanned, there are two paths for the scan. One possibility is a simple sequential scan and the other possibility is to use the index. Next the cost for the execution of each path is estimated and the cheapest path is chosen. The cheapest path is expanded into a complete plan that the executor can use.</source>
          <target state="translated">まず、同じ結果につながるすべての可能な&lt;em&gt;パスを&lt;/em&gt;作成し&lt;em&gt;ます&lt;/em&gt;。たとえば、スキャンするリレーションにインデックスがある場合、スキャンには2つのパスがあります。1つの可能性は単純な順次スキャンであり、もう1つの可能性はインデックスを使用することです。次に、各パスの実行コストが推定され、最も安価なパスが選択されます。最も安いパスは、エグゼキュータが使用できる完全なプランに拡張されます。</target>
        </trans-unit>
        <trans-unit id="22062c54b59724e3ba4ff79971e8d1516ebd1cef" translate="yes" xml:space="preserve">
          <source>It does this by skipping pages that have only visible tuples according to the visibility map (if a page has the corresponding VM bit set, then it is assumed to contain no dead tuples). For such pages, it derives the free space value from the free space map, and assumes that the rest of the space on the page is taken up by live tuples.</source>
          <target state="translated">これは、可視性マップに従って可視タプルのみを持つページをスキップすることによって行われます(ページに対応するVMビットがセットされている場合、デッドタプルは含まれていないと仮定されます)。そのようなページについては、空き領域マップから空き領域の値を導出し、ページ上の残りの領域がライブタプルによって占められていると仮定します。</target>
        </trans-unit>
        <trans-unit id="289bb6de0c119ae341fea7727f0ae465a6ffb7a2" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;not&lt;/em&gt; recommended that you override this behavior by changing the session-level settings of these parameters; that is likely to cause &lt;code&gt;postgres_fdw&lt;/code&gt; to malfunction.</source>
          <target state="translated">これらのパラメーターのセッションレベルの設定を変更して、この動作を上書きすることはお勧めし&lt;em&gt;ません&lt;/em&gt;。これにより、 &lt;code&gt;postgres_fdw&lt;/code&gt; が誤動作する可能性があります。</target>
        </trans-unit>
        <trans-unit id="1927f65da9f3267669c003e30b5762ebad0dc5a9" translate="yes" xml:space="preserve">
          <source>It is a good idea to save the database server's log output somewhere, rather than just discarding it via &lt;code&gt;/dev/null&lt;/code&gt;. The log output is invaluable when diagnosing problems. However, the log output tends to be voluminous (especially at higher debug levels) so you won't want to save it indefinitely. You need to &lt;em&gt;rotate&lt;/em&gt; the log files so that new log files are started and old ones removed after a reasonable period of time.</source>
          <target state="translated">データベースサーバーのログ出力を &lt;code&gt;/dev/null&lt;/code&gt; 経由で単に破棄するのではなく、どこかに保存することをお勧めします。ログ出力は、問題を診断する際に非常に役立ちます。ただし、ログ出力は（特に、より高いデバッグレベルで）膨大になる傾向があるため、無期限に保存する必要はありません。新しいログファイルが開始され、古いログファイルが妥当な期間後に削除される&lt;em&gt;ように&lt;/em&gt;、ログファイルを&lt;em&gt;ローテーション&lt;/em&gt;する必要があります。</target>
        </trans-unit>
        <trans-unit id="45d3adbb3df378f5fff436872f95f728d888325a" translate="yes" xml:space="preserve">
          <source>It is advantageous if the log is located on a different disk from the main database files. This can be achieved by moving the &lt;code&gt;pg_wal&lt;/code&gt; directory to another location (while the server is shut down, of course) and creating a symbolic link from the original location in the main data directory to the new location.</source>
          <target state="translated">ログがメインのデータベースファイルとは別のディスクにある場合に有利です。これは、 &lt;code&gt;pg_wal&lt;/code&gt; ディレクトリを別の場所に移動し（サーバーがシャットダウンしている間はもちろん）、メインデータディレクトリの元の場所から新しい場所へのシンボリックリンクを作成することで実現できます。</target>
        </trans-unit>
        <trans-unit id="25c2883a31f29210a79363008b59988d33c5a31b" translate="yes" xml:space="preserve">
          <source>It is advisable to set &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; to a reasonably large value (but not more than the amount of RAM you can dedicate to the &lt;code&gt;CLUSTER&lt;/code&gt; operation) before clustering.</source>
          <target state="translated">クラスタリングを行う前に、&lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;を適度に大きな値（ただし、 &lt;code&gt;CLUSTER&lt;/code&gt; 操作専用にできるRAMの容量以下）に設定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f4c2ed49f12a870b96cb954dbc625ee0c439a239" translate="yes" xml:space="preserve">
          <source>It is advisable to test your proposed archive command to ensure that it indeed does not overwrite an existing file, &lt;em&gt;and that it returns nonzero status in this case&lt;/em&gt;. The example command above for Unix ensures this by including a separate &lt;code&gt;test&lt;/code&gt; step. On some Unix platforms, &lt;code&gt;cp&lt;/code&gt; has switches such as &lt;code&gt;-i&lt;/code&gt; that can be used to do the same thing less verbosely, but you should not rely on these without verifying that the right exit status is returned. (In particular, GNU &lt;code&gt;cp&lt;/code&gt; will return status zero when &lt;code&gt;-i&lt;/code&gt; is used and the target file already exists, which is &lt;em&gt;not&lt;/em&gt; the desired behavior.)</source>
          <target state="translated">提案されたアーカイブコマンドをテストして、実際に既存のファイルを上書きしない&lt;em&gt;こと&lt;/em&gt;、&lt;em&gt;およびこの場合はゼロ以外のステータスを返す&lt;/em&gt;ことを確認することをお勧めします。上記のUnixのコマンド例では、個別の &lt;code&gt;test&lt;/code&gt; ステップを含めることでこれを保証しています。一部のUnixプラットフォームでは、 &lt;code&gt;cp&lt;/code&gt; には &lt;code&gt;-i&lt;/code&gt; などのスイッチがあり、同じことをより簡潔に行うことができますが、正しい終了ステータスが返されることを確認せずにこれらに依存することはできません。 （特に、GNU &lt;code&gt;cp&lt;/code&gt; は、 &lt;code&gt;-i&lt;/code&gt; が使用され、ターゲットファイルが既に存在する場合、ステータス0を返しますが、これは望ましい動作ではあり&lt;em&gt;ません&lt;/em&gt;。）</target>
        </trans-unit>
        <trans-unit id="5ccc1a490a09faccece314c281e5a4bacdabe99b" translate="yes" xml:space="preserve">
          <source>It is also important to consider the overhead of partitioning during query planning and execution. The query planner is generally able to handle partition hierarchies with up to a few thousand partitions fairly well, provided that typical queries allow the query planner to prune all but a small number of partitions. Planning times become longer and memory consumption becomes higher when more partitions remain after the planner performs partition pruning. This is particularly true for the &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; commands. Another reason to be concerned about having a large number of partitions is that the server's memory consumption may grow significantly over a period of time, especially if many sessions touch large numbers of partitions. That's because each partition requires its metadata to be loaded into the local memory of each session that touches it.</source>
          <target state="translated">クエリの計画と実行中にパーティション分割のオーバーヘッドを考慮することも重要です。一般的なクエリでクエリプランナーが少数のパーティションを除くすべてをプルーニングできる場合、クエリプランナーは通常、最大数千のパーティションを持つパーティション階層を適切に処理できます。プランナーがパーティションプルーニングを実行した後、さらに多くのパーティションが残っていると、計画時間が長くなり、メモリ消費が高くなります。これは特に &lt;code&gt;UPDATE&lt;/code&gt; と &lt;code&gt;DELETE&lt;/code&gt; に当てはまりますコマンド。多数のパーティションがあることを懸念するもう1つの理由は、特に多くのセッションが多数のパーティションにアクセスしている場合、サーバーのメモリ消費量が一定期間にわたって大幅に増加する可能性があることです。これは、各パーティションで、そのパーティションにアクセスする各セッションのローカルメモリにメタデータをロードする必要があるためです。</target>
        </trans-unit>
        <trans-unit id="b8a8c0ea8274eada7feb8d1cce002d08a07341cc" translate="yes" xml:space="preserve">
          <source>It is also possible to construct an array from the results of a subquery. In this form, the array constructor is written with the key word &lt;code&gt;ARRAY&lt;/code&gt; followed by a parenthesized (not bracketed) subquery. For example:</source>
          <target state="translated">サブクエリの結果から配列を作成することもできます。この形式では、配列コンストラクターはキーワード &lt;code&gt;ARRAY&lt;/code&gt; に続けて括弧で囲まれた（括弧で囲まれていない）サブクエリで記述されます。例えば：</target>
        </trans-unit>
        <trans-unit id="21db650c844a5c99fb809ce100bf6bab36b3a9c1" translate="yes" xml:space="preserve">
          <source>It is also possible to create a chain of trust that includes intermediate certificates:</source>
          <target state="translated">中間証明書を含む信頼の連鎖を作ることも可能です。</target>
        </trans-unit>
        <trans-unit id="1bbde7dfe5218957bc7115e4bb121f93797376d5" translate="yes" xml:space="preserve">
          <source>It is also possible to implement record-based log shipping using this alternative method, though this requires custom development, and changes will still only become visible to hot standby queries after a full WAL file has been shipped.</source>
          <target state="translated">また、この代替方法を使用して記録ベースのログ出荷を実装することも可能ですが、これにはカスタム開発が必要で、変更は完全なWALファイルが出荷された後にホットスタンバイクエリにのみ表示されます。</target>
        </trans-unit>
        <trans-unit id="a889ddd9646ac2e435b2d44d186929390a588c8e" translate="yes" xml:space="preserve">
          <source>It is also possible to insert the result of a query (which might be no rows, one row, or many rows):</source>
          <target state="translated">また、クエリの結果を挿入することも可能です(行がない、1行、または多くの行があるかもしれません)。</target>
        </trans-unit>
        <trans-unit id="23dc30a3752f1a0512f87d6b42f04212daedc525" translate="yes" xml:space="preserve">
          <source>It is also possible to make a backup while the server is stopped. In this case, you obviously cannot use &lt;code&gt;pg_start_backup&lt;/code&gt; or &lt;code&gt;pg_stop_backup&lt;/code&gt;, and you will therefore be left to your own devices to keep track of which backup is which and how far back the associated WAL files go. It is generally better to follow the continuous archiving procedure above.</source>
          <target state="translated">サーバーが停止しているときにバックアップを作成することもできます。この場合、明らかに &lt;code&gt;pg_start_backup&lt;/code&gt; または &lt;code&gt;pg_stop_backup&lt;/code&gt; を使用できないため、どのバックアップがどれで、関連するWALファイルがどこまで遡っているかを追跡するのは、自分のデバイスに任されます。通常は、上記の継続的なアーカイブ手順に従うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6383187f9793f49474de63c9c18fca5ed6c8c44d" translate="yes" xml:space="preserve">
          <source>It is also possible to pass a page to &lt;code&gt;bt_page_items&lt;/code&gt; as a &lt;code&gt;bytea&lt;/code&gt; value. A page image obtained with &lt;code&gt;get_raw_page&lt;/code&gt; should be passed as argument. So the last example could also be rewritten like this:</source>
          <target state="translated">また、ページを &lt;code&gt;bt_page_items&lt;/code&gt; に &lt;code&gt;bytea&lt;/code&gt; 値として渡すこともできます。 &lt;code&gt;get_raw_page&lt;/code&gt; で取得したページ画像を引数として渡す必要があります。したがって、最後の例は次のように書き換えることもできます。</target>
        </trans-unit>
        <trans-unit id="44f6da252a14d7892790fa503a4f493737f34471" translate="yes" xml:space="preserve">
          <source>It is also possible to specify a type cast using a function-like syntax:</source>
          <target state="translated">関数のような構文を使って型キャストを指定することも可能です。</target>
        </trans-unit>
        <trans-unit id="da0d70336d913c862f76912f7ff4b7d2cecbbfee" translate="yes" xml:space="preserve">
          <source>It is also possible to specify a type coercion using a function-like syntax:</source>
          <target state="translated">関数のような構文を使って型強制を指定することも可能です。</target>
        </trans-unit>
        <trans-unit id="6ce33e1d5683bd1e633283bcca0d2a1c2815c050" translate="yes" xml:space="preserve">
          <source>It is also possible to tie a session default to a specific database rather than to a role; see &lt;a href=&quot;sql-alterdatabase&quot;&gt;ALTER DATABASE&lt;/a&gt;. If there is a conflict, database-role-specific settings override role-specific ones, which in turn override database-specific ones.</source>
          <target state="translated">また、セッションのデフォルトをロールではなく特定のデータベースに関連付けることもできます。&lt;a href=&quot;sql-alterdatabase&quot;&gt;ALTER DATABASEを&lt;/a&gt;参照してください。競合がある場合は、データベースの役割固有の設定が役割固有の設定を上書きし、次にデータベース固有の設定が上書きされます。</target>
        </trans-unit>
        <trans-unit id="752073224562183bf86377a6f918beef1da4c653" translate="yes" xml:space="preserve">
          <source>It is also possible to tie a session default to a specific role rather than to a database; see &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;. Role-specific settings override database-specific ones if there is a conflict.</source>
          <target state="translated">セッションのデフォルトをデータベースではなく特定のロールに関連付けることもできます。&lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLEを&lt;/a&gt;参照してください。競合がある場合、ロール固有の設定はデータベース固有の設定を上書きします。</target>
        </trans-unit>
        <trans-unit id="c7b08ca18ddba24ea9814754a2d56bec9634faff" translate="yes" xml:space="preserve">
          <source>It is also possible to use arbitrary expressions in the &lt;code&gt;ORDER BY&lt;/code&gt; clause, including columns that do not appear in the &lt;code&gt;SELECT&lt;/code&gt; output list. Thus the following statement is valid:</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 出力リストに表示されない列を含む、 &lt;code&gt;ORDER BY&lt;/code&gt; 句で任意の式を使用することもできます。したがって、次のステートメントは有効です。</target>
        </trans-unit>
        <trans-unit id="f4e580c8b0c33e188baa71c64a617a90c70459e7" translate="yes" xml:space="preserve">
          <source>It is also possible to use logical replication methods to create a standby server with the updated version of PostgreSQL. This is possible because logical replication supports replication between different major versions of PostgreSQL. The standby can be on the same computer or a different computer. Once it has synced up with the master server (running the older version of PostgreSQL), you can switch masters and make the standby the master and shut down the older database instance. Such a switch-over results in only several seconds of downtime for an upgrade.</source>
          <target state="translated">また、論理レプリケーションの方法を使用して、更新されたバージョンのPostgreSQLで待機サーバを作成することも可能です。論理レプリケーションはPostgreSQLの異なるメジャーバージョン間のレプリケーションをサポートしているため、これが可能です。待機サーバは同じコンピュータ上にあっても、別のコンピュータ上にあっても構いません。マスタサーバ(古いバージョンのPostgreSQLを実行している)と同期したら、マスタを切り替えてスタンバイをマスタとし、古いデータベースインスタンスをシャットダウンすることができます。このような切り替えにより、アップグレードのためのダウンタイムは数秒で済みます。</target>
        </trans-unit>
        <trans-unit id="2f14f1cce0e64f81899ff66a139003d88acce025" translate="yes" xml:space="preserve">
          <source>It is an error to mix configuration options for simple bind with options for search+bind.</source>
          <target state="translated">シンプルバインドの設定オプションと検索+バインドのオプションが混在しているのはエラーです。</target>
        </trans-unit>
        <trans-unit id="8a93dfee21deef6822077b576885ec96bea313d5" translate="yes" xml:space="preserve">
          <source>It is best not to use SIGKILL to shut down the server. Doing so will prevent the server from releasing shared memory and semaphores. Furthermore, SIGKILL kills the &lt;code&gt;postgres&lt;/code&gt; process without letting it relay the signal to its subprocesses, so it might be necessary to kill the individual subprocesses by hand as well.</source>
          <target state="translated">SIGKILLを使用してサーバーをシャットダウンしないことをお勧めします。これを行うと、サーバーが共有メモリとセマフォを解放できなくなります。さらに、SIGKILLは &lt;code&gt;postgres&lt;/code&gt; プロセスを強制終了しますが、シグナルをサブプロセスに中継させないため、個々のサブプロセスも手動で強制終了する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="03425b40ae836e9eabd64694b0fe5bdd09ab82f4" translate="yes" xml:space="preserve">
          <source>It is best not to use parallelism when restoring from an archive made with this option, because pg_restore will not know exactly which partition(s) a given archive data item will load data into. This could result in inefficiency due to lock conflicts between parallel jobs, or perhaps even reload failures due to foreign key constraints being set up before all the relevant data is loaded.</source>
          <target state="translated">このオプションを使用して作成されたアーカイブからリストアする際には、並列処理を使用しない方が良いでしょう。なぜならば、pg_restoreは与えられたアーカイブデータ項目がどのパーティションにデータをロードするかを正確に把握していないからです。これは、並列ジョブ間でのロックの競合による非効率性や、すべての関連データがロードされる前に外部キー制約が設定されるためにリロードに失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="98e38adf41282f06a6bcba53d9fb2cad2cffe8b4" translate="yes" xml:space="preserve">
          <source>It is common for a client that executes &lt;code&gt;NOTIFY&lt;/code&gt; to be listening on the same notification channel itself. In that case it will get back a notification event, just like all the other listening sessions. Depending on the application logic, this could result in useless work, for example, reading a database table to find the same updates that that session just wrote out. It is possible to avoid such extra work by noticing whether the notifying session's server process PID (supplied in the notification event message) is the same as one's own session's PID (available from libpq). When they are the same, the notification event is one's own work bouncing back, and can be ignored.</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; を実行するクライアントが同じ通知チャネル自体をリッスンすることは一般的です。その場合、他のすべてのリスニングセッションと同様に、通知イベントが返されます。アプリケーションロジックによっては、データベーステーブルを読み取って、そのセッションが書き込んだのと同じ更新を見つけるなど、無駄な作業が発生する可能性があります。通知セッションのサーバープロセスPID（通知イベントメッセージで提供）が自分のセッションのPID（libpqから入手可能）と同じであるかどうかを通知することで、このような余分な作業を回避できます。それらが同じ場合、通知イベントは自分自身の跳ね返りであり、無視できます。</target>
        </trans-unit>
        <trans-unit id="c9caa8dc8a351442eebfc90a7900dd2df9e2e966" translate="yes" xml:space="preserve">
          <source>It is common to see slow queries running bad execution plans because multiple columns used in the query clauses are correlated. The planner normally assumes that multiple conditions are independent of each other, an assumption that does not hold when column values are correlated. Regular statistics, because of their per-individual-column nature, cannot capture any knowledge about cross-column correlation. However, PostgreSQL has the ability to compute &lt;em&gt;multivariate statistics&lt;/em&gt;, which can capture such information.</source>
          <target state="translated">クエリ句で使用されている複数の列が相互に関連付けられているため、遅いクエリで実行プランが正しく実行されないことがよくあります。通常、プランナは、複数の条件が互いに独立していると想定します。これは、列の値が相関している場合は成立しないという想定です。定期的な統計は、個々の列ごとの性質のため、列間の相関に関する知識をキャプチャできません。ただし、PostgreSQLには&lt;em&gt;多変量統計&lt;/em&gt;を計算する機能があり、そのような情報を取得できます。</target>
        </trans-unit>
        <trans-unit id="716e43860306866d146f9c899994b23176f3323e" translate="yes" xml:space="preserve">
          <source>It is difficult to formulate a general procedure for determining which indexes to create. There are a number of typical cases that have been shown in the examples throughout the previous sections. A good deal of experimentation is often necessary. The rest of this section gives some tips for that:</source>
          <target state="translated">どのインデックスを作成するかを決定するための一般的な手順を策定することは困難である。これまでのセクションを通して例示してきた典型的なケースがいくつかあります。多くの場合、多くの実験が必要となります。このセクションの残りの部分では、そのためのヒントをいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="8e2e75db678536414073cb564abf9bafb8f65d0c" translate="yes" xml:space="preserve">
          <source>It is easy to find your largest tables and indexes using this information:</source>
          <target state="translated">この情報を利用して、最大のテーブルやインデックスを簡単に見つけることができます。</target>
        </trans-unit>
        <trans-unit id="e1f4af27f8aaeea1d69cd838327e07079c59b331" translate="yes" xml:space="preserve">
          <source>It is encrypted using the public key and put into the session key packet.</source>
          <target state="translated">公開鍵を使って暗号化し、セッションキーパケットに入れます。</target>
        </trans-unit>
        <trans-unit id="c1facaa0d2b2d45958e470a68a811dfa56fbe0cc" translate="yes" xml:space="preserve">
          <source>It is especially fatal to use very small test data sets. While selecting 1000 out of 100000 rows could be a candidate for an index, selecting 1 out of 100 rows will hardly be, because the 100 rows probably fit within a single disk page, and there is no plan that can beat sequentially fetching 1 disk page.</source>
          <target state="translated">特に、非常に小さなテストデータセットを使用するのは致命的です。100000行のうち1000行を選択することはインデックスの候補になるかもしれませんが、100行のうち1行を選択することはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="19ad949d23432743231dc352c6a17b2b375d15f1" translate="yes" xml:space="preserve">
          <source>It is essential that the same parameters are passed in order to obtain matching XML data mappings and XML Schema documents.</source>
          <target state="translated">一致するXMLデータマッピングとXML Schemaドキュメントを取得するためには、同じパラメータを渡すことが不可欠です。</target>
        </trans-unit>
        <trans-unit id="3a50daa221b6ada829c86621c1e1031f8d10ee63" translate="yes" xml:space="preserve">
          <source>It is even possible for repeated executions of the same &lt;code&gt;LIMIT&lt;/code&gt; query to return different subsets of the rows of a table, if there is not an &lt;code&gt;ORDER BY&lt;/code&gt; to enforce selection of a deterministic subset. Again, this is not a bug; determinism of the results is simply not guaranteed in such a case.</source>
          <target state="translated">確定的なサブセットの選択を強制する &lt;code&gt;ORDER BY&lt;/code&gt; がない場合、同じ &lt;code&gt;LIMIT&lt;/code&gt; クエリを繰り返し実行して、テーブルの行の異なるサブセットを返すこともできます。繰り返しますが、これはバグではありません。このような場合、結果の確定性は保証されません。</target>
        </trans-unit>
        <trans-unit id="10042e013ab2c07aefb508d6fa86ca0af029f7db" translate="yes" xml:space="preserve">
          <source>It is frequently convenient to group users together to ease management of privileges: that way, privileges can be granted to, or revoked from, a group as a whole. In PostgreSQL this is done by creating a role that represents the group, and then granting &lt;em&gt;membership&lt;/em&gt; in the group role to individual user roles.</source>
          <target state="translated">特権の管理を容易にするためにユーザーをグループ化すると便利なことがよくあります。このようにして、グループ全体に特権を付与したり、グループから取り消したりすることができます。PostgreSQLでは、これはグループを表すロールを作成し、グループロールの&lt;em&gt;メンバーシップ&lt;/em&gt;を個々のユーザーロールに付与することで行われます。</target>
        </trans-unit>
        <trans-unit id="c7233cabce0e70bf9b6042d864213cd71aa539f4" translate="yes" xml:space="preserve">
          <source>It is generally recommended that the columns of a foreign table be declared with exactly the same data types, and collations if applicable, as the referenced columns of the remote table. Although &lt;code&gt;postgres_fdw&lt;/code&gt; is currently rather forgiving about performing data type conversions at need, surprising semantic anomalies may arise when types or collations do not match, due to the remote server interpreting &lt;code&gt;WHERE&lt;/code&gt; clauses slightly differently from the local server.</source>
          <target state="translated">一般に、外部テーブルの列は、リモートテーブルの参照される列とまったく同じデータ型、および該当する場合は照合順序で宣言することをお勧めします。が &lt;code&gt;postgres_fdw&lt;/code&gt; は現在、むしろ必要でデータ型変換を実行について寛容である種類や照合順序は、通訳リモートサーバによる一致しないとき、驚くべきセマンティック異常が発生する可能性のある句若干異なるローカルサーバから。 &lt;code&gt;WHERE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e59537e8306049dacf2891d27c403a8ccf0ae6a3" translate="yes" xml:space="preserve">
          <source>It is generally recommended to use &lt;code&gt;FOR UPDATE&lt;/code&gt; if the cursor is intended to be used with &lt;code&gt;UPDATE ... WHERE CURRENT OF&lt;/code&gt; or &lt;code&gt;DELETE ... WHERE CURRENT OF&lt;/code&gt;. Using &lt;code&gt;FOR UPDATE&lt;/code&gt; prevents other sessions from changing the rows between the time they are fetched and the time they are updated. Without &lt;code&gt;FOR UPDATE&lt;/code&gt;, a subsequent &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; command will have no effect if the row was changed since the cursor was created.</source>
          <target state="translated">カーソルを &lt;code&gt;UPDATE ... WHERE CURRENT OF&lt;/code&gt; または &lt;code&gt;DELETE ... WHERE CURRENT OF&lt;/code&gt; で使用する場合は、一般に &lt;code&gt;FOR UPDATE&lt;/code&gt; を使用することをお勧めします。 &lt;code&gt;FOR UPDATE&lt;/code&gt; を使用すると、他のセッションが行がフェッチされてから更新されるまでの間に行が変更されるのを防ぎます。 &lt;code&gt;FOR UPDATE&lt;/code&gt; がなければ、カーソルが作成されてから行が変更された場合、後続の &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; コマンドは効果がありません。</target>
        </trans-unit>
        <trans-unit id="a83872fa85fd0323d70dd24a91d302ff7029d1c0" translate="yes" xml:space="preserve">
          <source>It is good practice to create a role that has the &lt;code&gt;CREATEDB&lt;/code&gt; and &lt;code&gt;CREATEROLE&lt;/code&gt; privileges, but is not a superuser, and then use this role for all routine management of databases and roles. This approach avoids the dangers of operating as a superuser for tasks that do not really require it.</source>
          <target state="translated">&lt;code&gt;CREATEDB&lt;/code&gt; 特権と &lt;code&gt;CREATEROLE&lt;/code&gt; 特権を持っているがスーパーユーザーではないロールを作成し、データベースとロールのすべての日常的な管理にこのロールを使用することをお勧めします。このアプローチは、実際には必要としないタスクのスーパーユーザーとして操作する危険を回避します。</target>
        </trans-unit>
        <trans-unit id="de68fd3161d79a0dbb9addbaa913d55e1165d0a6" translate="yes" xml:space="preserve">
          <source>It is important for the command to return a zero exit status only if it succeeds. The command &lt;em&gt;will&lt;/em&gt; be asked for file names that are not present in the archive; it must return nonzero when so asked. Examples:</source>
          <target state="translated">コマンドは、成功した場合にのみゼロの終了ステータスを返すことが重要です。コマンド&lt;em&gt;は&lt;/em&gt;、アーカイブに存在しないファイル名を要求されます。要求された場合はゼロ以外を返す必要があります。例：</target>
        </trans-unit>
        <trans-unit id="cf6c5b8023371ed1577875e84b0b18cba96de2de" translate="yes" xml:space="preserve">
          <source>It is important that the &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; string not appear in any key values, else &lt;code&gt;connectby&lt;/code&gt; may incorrectly report an infinite-recursion error. Note that if &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; is not provided, a default value of &lt;code&gt;~&lt;/code&gt; is used for recursion detection purposes.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; &lt;/em&gt;文字列がどのキー値にも &lt;code&gt;connectby&lt;/code&gt; れていないことが重要です。&lt;em&gt;そうし&lt;/em&gt;ないと、connectbyが誤って無限再帰エラーを報告する可能性があります。&lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; &lt;/em&gt;が指定されていない場合、再帰検出の目的でデフォルト値 &lt;code&gt;~&lt;/code&gt; が使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b1ae60071a0616a68a075f0ef2a5eb0bf24ed27b" translate="yes" xml:space="preserve">
          <source>It is important that the administrator select appropriate settings for &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;. The best choices vary depending on business priorities. For example if the server is primarily tasked as a High Availability server, then you will want low delay settings, perhaps even zero, though that is a very aggressive setting. If the standby server is tasked as an additional server for decision support queries then it might be acceptable to set the maximum delay values to many hours, or even -1 which means wait forever for queries to complete.</source>
          <target state="translated">管理者が&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt;および&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delayの&lt;/a&gt;適切な設定を選択することが重要です。最適な選択肢は、ビジネスの優先順位によって異なります。たとえば、サーバーが主に高可用性サーバーとして機能している場合は、非常に積極的な設定ですが、遅延をできるだけ低く設定することをお勧めします。スタンバイサーバーが意思決定支援クエリの追加サーバーとして機能している場合は、最大遅延値を何時間にも設定できます。-1にしても、クエリが完了するまで永久に待機することになります。</target>
        </trans-unit>
        <trans-unit id="261ccf1229f9ce7bf8e5f6c3bd334b4a4c87db09" translate="yes" xml:space="preserve">
          <source>It is important that the archive command return zero exit status if and only if it succeeds. Upon getting a zero result, PostgreSQL will assume that the file has been successfully archived, and will remove or recycle it. However, a nonzero status tells PostgreSQL that the file was not archived; it will try again periodically until it succeeds.</source>
          <target state="translated">アーカイブコマンドが成功した場合にのみ、終了ステータスを0にすることが重要です。0の結果が得られた場合、PostgreSQLはファイルが正常にアーカイブされたものとみなし、ファイルを削除したりリサイクルしたりします。しかし、0以外の状態はPostgreSQLにファイルがアーカイブされていないことを伝えます。</target>
        </trans-unit>
        <trans-unit id="696e699e4bfd8bcf4f4c70ae89306a775c1076ba" translate="yes" xml:space="preserve">
          <source>It is important that the command return nonzero exit status on failure. The command &lt;em&gt;will&lt;/em&gt; be called requesting files that are not present in the archive; it must return nonzero when so asked. This is not an error condition. An exception is that if the command was terminated by a signal (other than SIGTERM, which is used as part of a database server shutdown) or an error by the shell (such as command not found), then recovery will abort and the server will not start up.</source>
          <target state="translated">失敗した場合、コマンドがゼロ以外の終了ステータスを返すことが重要です。コマンド&lt;em&gt;は&lt;/em&gt;、アーカイブに存在しないファイルを要求&lt;em&gt;する&lt;/em&gt;ために呼び出されます。要求された場合はゼロ以外を返す必要があります。これはエラー状態ではありません。例外は、コマンドがシグナル（データベースサーバーのシャットダウンの一部として使用されるSIGTERM以外）またはシェルによるエラー（コマンドが見つからないなど）によって終了した場合、リカバリは中止され、サーバーは起動しない。</target>
        </trans-unit>
        <trans-unit id="23edc6be4b94044ef5894353c32ee9e7375bcbf5" translate="yes" xml:space="preserve">
          <source>It is important to note that the ranking functions do not use any global information, so it is impossible to produce a fair normalization to 1% or 100% as sometimes desired. Normalization option 32 (&lt;code&gt;rank/(rank+1)&lt;/code&gt;) can be applied to scale all ranks into the range zero to one, but of course this is just a cosmetic change; it will not affect the ordering of the search results.</source>
          <target state="translated">ランキング関数はグローバル情報を使用しないため、必要に応じて1％または100％に公平に正規化することは不可能です。正規化オプション32（ &lt;code&gt;rank/(rank+1)&lt;/code&gt; ）を適用して、すべてのランクを0〜1の範囲にスケーリングできますが、これは単なる表面的な変更です。検索結果の順序には影響しません。</target>
        </trans-unit>
        <trans-unit id="9a6953b33213a41a821ecf81913686f5a307e4e2" translate="yes" xml:space="preserve">
          <source>It is important to store the server's stdout and stderr output somewhere, as shown above. It will help for auditing purposes and to diagnose problems. (See &lt;a href=&quot;logfile-maintenance&quot;&gt;Section 24.3&lt;/a&gt; for a more thorough discussion of log file handling.)</source>
          <target state="translated">上記のように、サーバーのstdoutおよびstderr出力をどこかに保存することが重要です。これは、監査の目的と問題の診断に役立ちます。（ログファイルの処理の詳細については、&lt;a href=&quot;logfile-maintenance&quot;&gt;セクション24.3&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="0c277ac6ce904cf376b200217f724f1a32321205" translate="yes" xml:space="preserve">
          <source>It is important to understand before studying &lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;Table C.1&lt;/a&gt; that the fact that a key word is not reserved in PostgreSQL does not mean that the feature related to the word is not implemented. Conversely, the presence of a key word does not indicate the existence of a feature.</source>
          <target state="translated">&lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;表C.1&lt;/a&gt;を学習する前に、キーワードがPostgreSQLで予約されていないということは、その単語に関連する機能が実装されていないことを意味しないことを理解することが重要です。逆に、キーワードの存在は機能の存在を示しません。</target>
        </trans-unit>
        <trans-unit id="2afb84d06182545308e408bb344e52041de5bb4d" translate="yes" xml:space="preserve">
          <source>It is important to understand that the &lt;code&gt;tsvector&lt;/code&gt; type itself does not perform any word normalization; it assumes the words it is given are normalized appropriately for the application. For example,</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; タイプ自体は単語の正規化を実行しないことを理解することが重要です。与えられた単語がアプリケーションに対して適切に正規化されていることを前提としています。例えば、</target>
        </trans-unit>
        <trans-unit id="2fc0b9aee575bb88d3b3c3db08a354cd3df94678" translate="yes" xml:space="preserve">
          <source>It is important to understand the interaction between aggregates and SQL's &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;HAVING&lt;/code&gt; clauses. The fundamental difference between &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;HAVING&lt;/code&gt; is this: &lt;code&gt;WHERE&lt;/code&gt; selects input rows before groups and aggregates are computed (thus, it controls which rows go into the aggregate computation), whereas &lt;code&gt;HAVING&lt;/code&gt; selects group rows after groups and aggregates are computed. Thus, the &lt;code&gt;WHERE&lt;/code&gt; clause must not contain aggregate functions; it makes no sense to try to use an aggregate to determine which rows will be inputs to the aggregates. On the other hand, the &lt;code&gt;HAVING&lt;/code&gt; clause always contains aggregate functions. (Strictly speaking, you are allowed to write a &lt;code&gt;HAVING&lt;/code&gt; clause that doesn't use aggregates, but it's seldom useful. The same condition could be used more efficiently at the &lt;code&gt;WHERE&lt;/code&gt; stage.)</source>
          <target state="translated">集計とSQLの &lt;code&gt;WHERE&lt;/code&gt; および &lt;code&gt;HAVING&lt;/code&gt; 句の間の相互作用を理解することが重要です。基本的な違い &lt;code&gt;WHERE&lt;/code&gt; と &lt;code&gt;HAVING&lt;/code&gt; ：本で &lt;code&gt;WHERE&lt;/code&gt; 基及び凝集の前に選択入力行は、（行が集約計算に入るこのように、コントロール）を計算しているのに対し、 &lt;code&gt;HAVING&lt;/code&gt; 基及び凝集後の選択グループ行が計算されます。したがって、 &lt;code&gt;WHERE&lt;/code&gt; 句に集計関数を含めることはできません。集計を使用して、どの行が集計への入力になるかを決定しても意味がありません。一方、 &lt;code&gt;HAVING&lt;/code&gt; 句には常に集計関数が含まれます。（厳密に言うと、集計を使用しない &lt;code&gt;HAVING&lt;/code&gt; 句を記述できますが、ほとんど役に立ちません。同じ条件を &lt;code&gt;WHERE&lt;/code&gt; ステージでより効率的に使用できます。）</target>
        </trans-unit>
        <trans-unit id="d6f798bec767ce149f1b4884b54e8874f501f623" translate="yes" xml:space="preserve">
          <source>It is legitimate to create a &lt;code&gt;pg_cast&lt;/code&gt; entry in which the source and target types are the same, if the associated function takes more than one argument. Such entries represent &amp;ldquo;length coercion functions&amp;rdquo; that coerce values of the type to be legal for a particular type modifier value.</source>
          <target state="translated">関連する関数が複数の引数を取る場合、ソースとターゲットのタイプが同じである &lt;code&gt;pg_cast&lt;/code&gt; エントリを作成することは正当です。そのようなエントリは、特定の型修飾子の値に対して正当な型の値を強制する「長さ強制関数」を表します。</target>
        </trans-unit>
        <trans-unit id="dbc1f490f7774fb666f596c4d1e1fe3642c52d33" translate="yes" xml:space="preserve">
          <source>It is likely that &lt;code&gt;pg_pltemplate&lt;/code&gt; will be removed in some future release of PostgreSQL, in favor of keeping this knowledge about procedural languages in their respective extension installation scripts.</source>
          <target state="translated">&lt;code&gt;pg_pltemplate&lt;/code&gt; は、将来のPostgreSQLのリリースで削除される可能性が高く、手続き型言語に関するこの知識をそれぞれの拡張インストールスクリプトで維持することを優先します。</target>
        </trans-unit>
        <trans-unit id="6bb4f0fbbfb491190c393dc7c8ea60757b692676" translate="yes" xml:space="preserve">
          <source>It is normally not necessary to create casts between user-defined types and the standard string types (&lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char(n)&lt;/code&gt;, as well as user-defined types that are defined to be in the string category). PostgreSQL provides automatic I/O conversion casts for that. The automatic casts to string types are treated as assignment casts, while the automatic casts from string types are explicit-only. You can override this behavior by declaring your own cast to replace an automatic cast, but usually the only reason to do so is if you want the conversion to be more easily invokable than the standard assignment-only or explicit-only setting. Another possible reason is that you want the conversion to behave differently from the type's I/O function; but that is sufficiently surprising that you should think twice about whether it's a good idea. (A small number of the built-in types do indeed have different behaviors for conversions, mostly because of requirements of the SQL standard.)</source>
          <target state="translated">通常、ユーザー定義型と標準の文字列型（ &lt;code&gt;text&lt;/code&gt; 、 &lt;code&gt;varchar&lt;/code&gt; 、および &lt;code&gt;char(n)&lt;/code&gt; の間のキャストを作成する必要はありません。、および文字列カテゴリに含まれるように定義されているユーザー定義型）。 PostgreSQLはそのための自動I / O変換キャストを提供します。文字列型への自動キャストは割り当てキャストとして扱われますが、文字列型からの自動キャストは明示的のみです。独自のキャストを宣言して自動キャストを置き換えることで、この動作をオーバーライドできますが、通常、これを行う唯一の理由は、標準の割り当て専用または明示専用の設定よりも変換を簡単に呼び出すことができるようにする場合です。考えられるもう1つの理由は、変換の動作をタイプのI / O関数とは異なるものにすることです。しかしそれは、それが良い考えかどうかについて二度考えるべきだというのは十分に驚くべきことです。 （実際には、少数の組み込み型では変換の動作が異なりますが、主にSQL標準の要件によるものです。）</target>
        </trans-unit>
        <trans-unit id="f92a52d7559ea7c6c8c28ba12e1fa17dfea96688" translate="yes" xml:space="preserve">
          <source>It is not allowed to combine &lt;code&gt;connect&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;enabled&lt;/code&gt;, &lt;code&gt;create_slot&lt;/code&gt;, or &lt;code&gt;copy_data&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; を &lt;code&gt;false&lt;/code&gt; に設定して &lt;code&gt;enabled&lt;/code&gt; 、 &lt;code&gt;create_slot&lt;/code&gt; 、または &lt;code&gt;copy_data&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定して組み合わせることはできません。</target>
        </trans-unit>
        <trans-unit id="072c5ad8d293ff2ada18ad71b639cc19ab727e57" translate="yes" xml:space="preserve">
          <source>It is not currently allowed to &lt;code&gt;PREPARE&lt;/code&gt; a transaction that has executed any operations involving temporary tables or the session's temporary namespace, created any cursors &lt;code&gt;WITH HOLD&lt;/code&gt;, or executed &lt;code&gt;LISTEN&lt;/code&gt;, &lt;code&gt;UNLISTEN&lt;/code&gt;, or &lt;code&gt;NOTIFY&lt;/code&gt;. Those features are too tightly tied to the current session to be useful in a transaction to be prepared.</source>
          <target state="translated">現在、一時テーブルまたはセッションの一時名前空間に関連する操作を実行したり、 &lt;code&gt;WITH HOLD&lt;/code&gt; カーソルを作成したり、 &lt;code&gt;LISTEN&lt;/code&gt; 、 &lt;code&gt;UNLISTEN&lt;/code&gt; 、または &lt;code&gt;NOTIFY&lt;/code&gt; を実行したトランザクションを &lt;code&gt;PREPARE&lt;/code&gt; することはできません。これらの機能は、現在のセッションに緊密に関連付けられているため、トランザクションを準備するのに役立ちません。</target>
        </trans-unit>
        <trans-unit id="683c463d18b1311e371770a1d3375c3bacddce8d" translate="yes" xml:space="preserve">
          <source>It is not important to which database you connect here since the script file created by pg_dumpall will contain the appropriate commands to create and connect to the saved databases. An exception is that if you specified &lt;code&gt;--clean&lt;/code&gt;, you must connect to the &lt;code&gt;postgres&lt;/code&gt; database initially; the script will attempt to drop other databases immediately, and that will fail for the database you are connected to.</source>
          <target state="translated">pg_dumpallによって作成されたスクリプトファイルには、保存されたデータベースを作成して接続するための適切なコマンドが含まれているため、ここで接続するデータベースは重要ではありません。例外として、-- &lt;code&gt;--clean&lt;/code&gt; を指定した場合、最初に &lt;code&gt;postgres&lt;/code&gt; データベースに接続する必要があります。スクリプトは他のデータベースをすぐに削除しようとし、接続しているデータベースでは失敗します。</target>
        </trans-unit>
        <trans-unit id="1b796566a4506096f72ab10f4b43942e3c90636a" translate="yes" xml:space="preserve">
          <source>It is not necessary to add the root certificate to &lt;code&gt;server.crt&lt;/code&gt;. Instead, clients must have the root certificate of the server's certificate chain.</source>
          <target state="translated">ルート証明書を &lt;code&gt;server.crt&lt;/code&gt; に追加する必要はありません。代わりに、クライアントはサーバーの証明書チェーンのルート証明書を持っている必要があります。</target>
        </trans-unit>
        <trans-unit id="c4d12fc72842b14e61904a6ec6e02667bd4e3ff1" translate="yes" xml:space="preserve">
          <source>It is not necessary to be concerned about the amount of time it takes to make a base backup. However, if you normally run the server with &lt;code&gt;full_page_writes&lt;/code&gt; disabled, you might notice a drop in performance while the backup runs since &lt;code&gt;full_page_writes&lt;/code&gt; is effectively forced on during backup mode.</source>
          <target state="translated">基本バックアップの作成にかかる時間を気にする必要はありません。ただし、 &lt;code&gt;full_page_writes&lt;/code&gt; を無効にしてサーバーを通常実行すると、バックアップモード中に &lt;code&gt;full_page_writes&lt;/code&gt; が事実上強制されるため、バックアップの実行中にパフォーマンスが低下する場合があります。</target>
        </trans-unit>
        <trans-unit id="aca7caa9402f8a163da6c6daa7fb30a56a74a363" translate="yes" xml:space="preserve">
          <source>It is not necessary to create table constraints describing partition boundary condition for partitions. Instead, partition constraints are generated implicitly from the partition bound specification whenever there is need to refer to them.</source>
          <target state="translated">パーティションの境界条件を記述したテーブル制約を作成する必要はありません。その代わりに、パーティション制約は、参照する必要がある場合には、パーティション境界仕様から暗黙的に生成されます。</target>
        </trans-unit>
        <trans-unit id="cf0a2da0ce7b363dca7ad51ebb38c128a6e8bc4b" translate="yes" xml:space="preserve">
          <source>It is not necessary to implement this function for access methods which do not support parallel scans or for which the number of additional bytes of storage required is zero.</source>
          <target state="translated">パラレルスキャンをサポートしていないアクセスメソッドや、必要なストレージの追加バイト数がゼロのアクセスメソッドには、この関数を実装する必要はありません。</target>
        </trans-unit>
        <trans-unit id="81e24e9944e94aaaad52d26039e5ac57f4d46637" translate="yes" xml:space="preserve">
          <source>It is not necessary to implement this function for access methods which do not support parallel scans or in cases where the shared memory space required needs no initialization.</source>
          <target state="translated">パラレルスキャンに対応していないアクセスメソッドや、必要な共有メモリ空間の初期化が不要な場合は、この関数を実装する必要はありません。</target>
        </trans-unit>
        <trans-unit id="57e901fbd76f488aaa546e02fcd890de2339da2b" translate="yes" xml:space="preserve">
          <source>It is not necessary to provide both of these functions. If one is not specified, the language-specific default behavior will be used if necessary. (To prevent a transformation in a certain direction from happening at all, you could also write a transform function that always errors out.)</source>
          <target state="translated">これらの機能を両方提供する必要はありません。どちらかが指定されていない場合は、必要に応じて言語固有のデフォルトの動作が使用されます。(特定の方向への変換が全く起こらないようにするには、常にエラーアウトするような変換関数を書くこともできます)。</target>
        </trans-unit>
        <trans-unit id="8c2adbe3f4bf051ef1858dcf0e81ceda3ba80d46" translate="yes" xml:space="preserve">
          <source>It is not necessary to replay the WAL entries all the way to the end. We could stop the replay at any point and have a consistent snapshot of the database as it was at that time. Thus, this technique supports &lt;em&gt;point-in-time recovery&lt;/em&gt;: it is possible to restore the database to its state at any time since your base backup was taken.</source>
          <target state="translated">WALエントリを最後まで再生する必要はありません。任意の時点で再生を停止し、その時点でのデータベースの一貫したスナップショットを取得できます。したがって、この手法は&lt;em&gt;ポイントインタイムリカバリを&lt;/em&gt;サポートします。ベースバックアップが作成されてから、いつでもデータベースをその状態に復元することが可能です。</target>
        </trans-unit>
        <trans-unit id="ff889e8c8e60f8ff7137e71a9bfef2608859eeae" translate="yes" xml:space="preserve">
          <source>It is not necessary to supply correct user name, password, or database name values to obtain the server status; however, if incorrect values are provided, the server will log a failed connection attempt.</source>
          <target state="translated">サーバーの状態を取得するために、正しいユーザー名、パスワード、データベース名の値を指定する必要はありませんが、間違った値を指定した場合、サーバーは接続の試みに失敗したことを記録します。</target>
        </trans-unit>
        <trans-unit id="594a9711ffec0cdfe29afe713704c6029ca7c0e7" translate="yes" xml:space="preserve">
          <source>It is not necessary to use the &lt;code&gt;sync&lt;/code&gt; mount option. The behavior of the &lt;code&gt;async&lt;/code&gt; option is sufficient, since PostgreSQL issues &lt;code&gt;fsync&lt;/code&gt; calls at appropriate times to flush the write caches. (This is analogous to how it works on a local file system.) However, it is strongly recommended to use the &lt;code&gt;sync&lt;/code&gt; export option on the NFS &lt;em&gt;server&lt;/em&gt; on systems where it exists (mainly Linux). Otherwise, an &lt;code&gt;fsync&lt;/code&gt; or equivalent on the NFS client is not actually guaranteed to reach permanent storage on the server, which could cause corruption similar to running with the parameter &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; off. The defaults of these mount and export options differ between vendors and versions, so it is recommended to check and perhaps specify them explicitly in any case to avoid any ambiguity.</source>
          <target state="translated">&lt;code&gt;sync&lt;/code&gt; マウントオプションを使用する必要はありません。PostgreSQL は書き込みキャッシュをフラッシュするために適切なタイミングで &lt;code&gt;fsync&lt;/code&gt; 呼び出しを発行するため、 &lt;code&gt;async&lt;/code&gt; オプションの動作で十分です。 （これはローカルファイルシステムでの動作に似ています。）ただし、 &lt;code&gt;sync&lt;/code&gt; エクスポートオプションが存在するシステム（主にLinux）のNFS &lt;em&gt;サーバー&lt;/em&gt;で同期エクスポートオプションを使用することを強くお勧めします。それ以外の場合、NFSクライアントの &lt;code&gt;fsync&lt;/code&gt; または同等のものは、サーバーの永続的なストレージに到達することが実際には保証されず、パラメーター&lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsyncを&lt;/a&gt;使用した実行と同様の破損を引き起こす可能性があります。&lt;em&gt;&lt;/em&gt;オフ。これらのマウントオプションとエクスポートオプションのデフォルトはベンダーとバージョンによって異なるため、あいまいさを避けるために、これらをチェックして、明示的に指定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c52dffeed651be2fa3f87bf20ee3f9a890f9417b" translate="yes" xml:space="preserve">
          <source>It is not possible to release a savepoint when the transaction is in an aborted state.</source>
          <target state="translated">トランザクションが中断された状態にある場合、セーブポイントを解放することはできません。</target>
        </trans-unit>
        <trans-unit id="bfd22308dc33a27874305473df207d131e6a6cc4" translate="yes" xml:space="preserve">
          <source>It is not possible to specify an operator's lexical precedence in &lt;code&gt;CREATE OPERATOR&lt;/code&gt;, because the parser's precedence behavior is hard-wired. See &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;Section 4.1.6&lt;/a&gt; for precedence details.</source>
          <target state="translated">パーサーの優先順位の動作はハードワイヤードであるため、 &lt;code&gt;CREATE OPERATOR&lt;/code&gt; で演算子の字句の優先順位を指定することはできません。参照してください&lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;セクション4.1.6を&lt;/a&gt;優先詳細については。</target>
        </trans-unit>
        <trans-unit id="623a5826c4c93a0ee1b0b35f75bc29bfa6d59c5f" translate="yes" xml:space="preserve">
          <source>It is not possible to turn a regular table into a partitioned table or vice versa. However, it is possible to add a regular or partitioned table containing data as a partition of a partitioned table, or remove a partition from a partitioned table turning it into a standalone table; see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; to learn more about the &lt;code&gt;ATTACH PARTITION&lt;/code&gt; and &lt;code&gt;DETACH PARTITION&lt;/code&gt; sub-commands.</source>
          <target state="translated">通常のテーブルをパーティションテーブルに、またはその逆に変換することはできません。ただし、データを含む通常のテーブルまたはパーティションテーブルをパーティションテーブルのパーティションとして追加したり、パーティションテーブルからパーティションを削除してスタンドアロンテーブルにしたりすることは可能です。 &lt;code&gt;ATTACH PARTITION&lt;/code&gt; および &lt;code&gt;DETACH PARTITION&lt;/code&gt; サブコマンドの詳細については、&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2662bc57686704e0177490490462c24f0b6b158d" translate="yes" xml:space="preserve">
          <source>It is often a good idea to also omit from the backup the files within the cluster's &lt;code&gt;pg_replslot/&lt;/code&gt; directory, so that replication slots that exist on the master do not become part of the backup. Otherwise, the subsequent use of the backup to create a standby may result in indefinite retention of WAL files on the standby, and possibly bloat on the master if hot standby feedback is enabled, because the clients that are using those replication slots will still be connecting to and updating the slots on the master, not the standby. Even if the backup is only intended for use in creating a new master, copying the replication slots isn't expected to be particularly useful, since the contents of those slots will likely be badly out of date by the time the new master comes on line.</source>
          <target state="translated">マスターに存在するレプリケーションスロットがバックアップの一部にならないように、クラスターの &lt;code&gt;pg_replslot/&lt;/code&gt; ディレクトリ内のファイルもバックアップから除外することをお勧めします。そうしないと、その後バックアップを使用してスタンバイを作成すると、スタンバイでWALファイルが無期限に保持され、ホットスタンバイフィードバックが有効になっている場合はマスターで膨らむ可能性があります。これらのレプリケーションスロットを使用しているクライアントが引き続き接続しているためです。スタンバイではなく、マスターのスロットに更新します。バックアップが新しいマスターの作成での使用のみを目的としている場合でも、レプリケーションスロットのコピーは、新しいマスターがオンラインになるまでにそれらのスロットの内容がかなり古くなっている可能性があるため、特に有用であるとは思われません。 。</target>
        </trans-unit>
        <trans-unit id="d49711f89af35705bbf2891f981f944c8b5260d9" translate="yes" xml:space="preserve">
          <source>It is often helpful to use dollar quoting (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;Section 4.1.2.4&lt;/a&gt;) to write the function definition string, rather than the normal single quote syntax. Without dollar quoting, any single quotes or backslashes in the function definition must be escaped by doubling them.</source>
          <target state="translated">通常の単一引用符構文ではなく、ドル引用符（&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;セクション4.1.2.4を&lt;/a&gt;参照）を使用して関数定義文字列を記述すると役立つことがよくあります。ドル引用符を使用しない場合、関数定義内の単一引用符またはバックスラッシュは、二重にしてエスケープする必要があります。</target>
        </trans-unit>
        <trans-unit id="070ae03385b0624216e0f28d18b1063fb9896a1e" translate="yes" xml:space="preserve">
          <source>It is often helpful to use dollar quoting (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;Section 4.1.2.4&lt;/a&gt;) to write the procedure definition string, rather than the normal single quote syntax. Without dollar quoting, any single quotes or backslashes in the procedure definition must be escaped by doubling them.</source>
          <target state="translated">通常の単一引用符構文ではなく、ドル引用符（&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;セクション4.1.2.4を&lt;/a&gt;参照）を使用してプロシージャ定義文字列を記述すると便利な場合があります。ドル引用符を使用しない場合、プロシージャ定義内の単一引用符またはバックスラッシュは、二重にしてエスケープする必要があります。</target>
        </trans-unit>
        <trans-unit id="1037cf4994d8c1ebf0e5d5f237e680d00560257d" translate="yes" xml:space="preserve">
          <source>It is often particularly handy to &lt;code&gt;LEFT JOIN&lt;/code&gt; to a &lt;code&gt;LATERAL&lt;/code&gt; subquery, so that source rows will appear in the result even if the &lt;code&gt;LATERAL&lt;/code&gt; subquery produces no rows for them. For example, if &lt;code&gt;get_product_names()&lt;/code&gt; returns the names of products made by a manufacturer, but some manufacturers in our table currently produce no products, we could find out which ones those are like this:</source>
          <target state="translated">&lt;code&gt;LATERAL&lt;/code&gt; サブクエリが行を生成しなくても、ソース行が結果に表示されるように、 &lt;code&gt;LATERAL&lt;/code&gt; サブクエリへの &lt;code&gt;LEFT JOIN&lt;/code&gt; は特に便利です。たとえば、 &lt;code&gt;get_product_names()&lt;/code&gt; が製造元によって製造された製品の名前を返し、テーブル内の一部の製造元が現在製品を製造していない場合、次のような製品を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="25dd81b9b45b03c00d03cc26e891361c1cfb5adf" translate="yes" xml:space="preserve">
          <source>It is often preferable to use unique index inference rather than naming a constraint directly using &lt;code&gt;ON CONFLICT ON CONSTRAINT&lt;/code&gt;&lt;code&gt;constraint_name&lt;/code&gt;. Inference will continue to work correctly when the underlying index is replaced by another more or less equivalent index in an overlapping way, for example when using &lt;code&gt;CREATE UNIQUE INDEX ... CONCURRENTLY&lt;/code&gt; before dropping the index being replaced.</source>
          <target state="translated">&lt;code&gt;ON CONFLICT ON CONSTRAINT&lt;/code&gt; &lt;code&gt;constraint_name&lt;/code&gt; を使用して制約に直接名前を付けるよりも、一意のインデックス推論を使用する方が望ましい場合がよくあります。たとえば、置き換えられるインデックスを削除する前に &lt;code&gt;CREATE UNIQUE INDEX ... CONCURRENTLY&lt;/code&gt; を使用する場合など、基礎となるインデックスがほぼ同等の別のインデックスに重複して置き換えられても、推論は引き続き正しく機能します。</target>
        </trans-unit>
        <trans-unit id="f0921a8a84d9d3343d74c19f7c3f5f4b06b1c95a" translate="yes" xml:space="preserve">
          <source>It is possible for a &lt;code&gt;SELECT&lt;/code&gt; command running at the &lt;code&gt;READ COMMITTED&lt;/code&gt; transaction isolation level and using &lt;code&gt;ORDER BY&lt;/code&gt; and a locking clause to return rows out of order. This is because &lt;code&gt;ORDER BY&lt;/code&gt; is applied first. The command sorts the result, but might then block trying to obtain a lock on one or more of the rows. Once the &lt;code&gt;SELECT&lt;/code&gt; unblocks, some of the ordering column values might have been modified, leading to those rows appearing to be out of order (though they are in order in terms of the original column values). This can be worked around at need by placing the &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt; clause in a sub-query, for example</source>
          <target state="translated">それが可能である &lt;code&gt;SELECT&lt;/code&gt; で動作コマンド &lt;code&gt;READ COMMITTED&lt;/code&gt; トランザクション分離レベルと使用 &lt;code&gt;ORDER BY&lt;/code&gt; 順序の列を返すために、ロック句。これは、 &lt;code&gt;ORDER BY&lt;/code&gt; が最初に適用されるためです。コマンドは結果をソートしますが、1つ以上の行でロックを取得しようとするとブロックされる可能性があります。一度 &lt;code&gt;SELECT&lt;/code&gt; ブロック解除、発注のいくつかの列の値は、順序（彼らは、元の列の値の面で順になっているが）外であるように見えるこれらの行につながる、変更された可能性があります。これは、 &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt; 句をサブクエリに配置することで、必要に応じて回避できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="312a8769f42a09f432ff89ed107b0b0a082956d5" translate="yes" xml:space="preserve">
          <source>It is possible for both the client and server to provide SSL certificates to each other. It takes some extra configuration on each side, but this provides stronger verification of identity than the mere use of passwords. It prevents a computer from pretending to be the server just long enough to read the password sent by the client. It also helps prevent &amp;ldquo;man in the middle&amp;rdquo; attacks where a computer between the client and server pretends to be the server and reads and passes all data between the client and server.</source>
          <target state="translated">クライアントとサーバーの両方が相互にSSL証明書を提供することが可能です。両側で追加の構成が必要ですが、これにより、単なるパスワードの使用よりも強力なID検証が提供されます。これは、クライアントが送信したパスワードを読み取るのに十分な長さのサーバーであるかのようにコンピュータが偽ることを防ぎます。また、クライアントとサーバーの間のコンピューターがサーバーになりすまし、クライアントとサーバーの間ですべてのデータを読み取って渡す &quot;中間者&quot;攻撃を防ぐのにも役立ちます。</target>
        </trans-unit>
        <trans-unit id="90f59c9a7c7c3d668eb0d91ba42953cad54439f7" translate="yes" xml:space="preserve">
          <source>It is possible for the &lt;code&gt;query&lt;/code&gt; (&lt;code&gt;SELECT&lt;/code&gt; statement) to also contain a &lt;code&gt;WITH&lt;/code&gt; clause. In such a case both sets of &lt;code&gt;with_query&lt;/code&gt; can be referenced within the &lt;code&gt;query&lt;/code&gt;, but the second one takes precedence since it is more closely nested.</source>
          <target state="translated">ことが可能である &lt;code&gt;query&lt;/code&gt; （ &lt;code&gt;SELECT&lt;/code&gt; 文の）も含まれて &lt;code&gt;WITH&lt;/code&gt; の句を。そのような場合、 &lt;code&gt;with_query&lt;/code&gt; の両方のセットを &lt;code&gt;query&lt;/code&gt; 内で参照できますが、2番目のセットはより密接にネストされているため、優先されます。</target>
        </trans-unit>
        <trans-unit id="db7d99e745d7786411f8e352570962f202386c2e" translate="yes" xml:space="preserve">
          <source>It is possible for the parser to produce overlapping tokens from the same piece of text. As an example, a hyphenated word will be reported both as the entire word and as each component:</source>
          <target state="translated">パーサは、同じテキストから重複するトークンを生成することができます。例えば、ハイフネーションされた単語は、単語全体と各構成要素の両方として報告されます。</target>
        </trans-unit>
        <trans-unit id="2357da6f1597b1c38d9b19b97f4eaf9ba4d3b605" translate="yes" xml:space="preserve">
          <source>It is possible that the replication delay between servers exceeds the value of this parameter, in which case no delay is added. Note that the delay is calculated between the WAL time stamp as written on master and the current time on the standby. Delays in transfer because of network lag or cascading replication configurations may reduce the actual wait time significantly. If the system clocks on master and standby are not synchronized, this may lead to recovery applying records earlier than expected; but that is not a major issue because useful settings of this parameter are much larger than typical time deviations between servers.</source>
          <target state="translated">サーバ間のレプリケーション遅延がこのパラメータの値を超える可能性がありますが、その場合は遅延は追加されません。遅延は、マスターに書き込まれたWALタイムスタンプとスタンバイの現在時刻との間で計算されることに注意してください。ネットワークラグやカスケード・レプリケーション構成による転送の遅延は、実際の待ち時間を大幅に短縮する可能性があります。マスタとスタンバイのシステムクロックが同期していない場合、これは予想よりも早くレコードを適用して回復することにつながる可能性がありますが、このパラメータの有用な設定はサーバー間の一般的な時間偏差よりもはるかに大きいため、これは大きな問題ではありません。</target>
        </trans-unit>
        <trans-unit id="f9e86aaa136a99713e8aa37be86f1493657e5f36" translate="yes" xml:space="preserve">
          <source>It is possible to access the two component numbers of a &lt;code&gt;point&lt;/code&gt; as though the point were an array with indexes 0 and 1. For example, if &lt;code&gt;t.p&lt;/code&gt; is a &lt;code&gt;point&lt;/code&gt; column then &lt;code&gt;SELECT p[0] FROM t&lt;/code&gt; retrieves the X coordinate and &lt;code&gt;UPDATE t SET p[1] = ...&lt;/code&gt; changes the Y coordinate. In the same way, a value of type &lt;code&gt;box&lt;/code&gt; or &lt;code&gt;lseg&lt;/code&gt; can be treated as an array of two &lt;code&gt;point&lt;/code&gt; values.</source>
          <target state="translated">ポイントがインデックス0および1の配列であるかのように、 &lt;code&gt;point&lt;/code&gt; 2つのコンポーネント番号にアクセスすることが可能です。たとえば、 &lt;code&gt;t.p&lt;/code&gt; が &lt;code&gt;point&lt;/code&gt; 列の場合、 &lt;code&gt;SELECT p[0] FROM t&lt;/code&gt; はX座標を取得し、 &lt;code&gt;UPDATE t SET p[1] = ...&lt;/code&gt; 取得します。p [1] = ... Y座標を変更します。同様に、 &lt;code&gt;box&lt;/code&gt; または &lt;code&gt;lseg&lt;/code&gt; 型の値は、2つの &lt;code&gt;point&lt;/code&gt; 値の配列として扱うことができます。</target>
        </trans-unit>
        <trans-unit id="7fd72ecc1dea1c97715f5cc99a51c3564620c9cb" translate="yes" xml:space="preserve">
          <source>It is possible to check the accuracy of the planner's estimates by using &lt;code&gt;EXPLAIN&lt;/code&gt;'s &lt;code&gt;ANALYZE&lt;/code&gt; option. With this option, &lt;code&gt;EXPLAIN&lt;/code&gt; actually executes the query, and then displays the true row counts and true run time accumulated within each plan node, along with the same estimates that a plain &lt;code&gt;EXPLAIN&lt;/code&gt; shows. For example, we might get a result like this:</source>
          <target state="translated">&lt;code&gt;EXPLAIN&lt;/code&gt; の &lt;code&gt;ANALYZE&lt;/code&gt; オプションを使用して、プランナの推定の精度をチェックすることができます。このオプションを &lt;code&gt;EXPLAIN&lt;/code&gt; すると、EXPLAINは実際にクエリを実行し、各プランノード内で累積された実際の行数と実際の実行時間を、単純な &lt;code&gt;EXPLAIN&lt;/code&gt; が示すのと同じ推定値とともに表示します。たとえば、次のような結果が得られます。</target>
        </trans-unit>
        <trans-unit id="ed45fb50f823ca992b140dff1d81be186a3aef4d" translate="yes" xml:space="preserve">
          <source>It is possible to control the query planner to some extent by using the explicit &lt;code&gt;JOIN&lt;/code&gt; syntax. To see why this matters, we first need some background.</source>
          <target state="translated">明示的な &lt;code&gt;JOIN&lt;/code&gt; 構文を使用すると、クエリプランナーをある程度制御できます。これがなぜ重要かを理解するには、まずいくつかの背景が必要です。</target>
        </trans-unit>
        <trans-unit id="21ffb53e2d68da0c7954b41e98f5975f4ecf8084" translate="yes" xml:space="preserve">
          <source>It is possible to create a foreign-data wrapper with no handler function, but foreign tables using such a wrapper can only be declared, not accessed.</source>
          <target state="translated">ハンドラ関数を持たない外部データラッパーを作成することも可能ですが、そのようなラッパーを使用した外部テーブルは宣言されるだけで、アクセスされることはありません。</target>
        </trans-unit>
        <trans-unit id="d5bd3763bfcd5993518d08a6fc8f19894d8b599a" translate="yes" xml:space="preserve">
          <source>It is possible to create additional template databases, and indeed one can copy any database in a cluster by specifying its name as the template for &lt;code&gt;CREATE DATABASE&lt;/code&gt;. It is important to understand, however, that this is not (yet) intended as a general-purpose &amp;ldquo;&lt;code&gt;COPY DATABASE&lt;/code&gt;&amp;rdquo; facility. The principal limitation is that no other sessions can be connected to the source database while it is being copied. &lt;code&gt;CREATE DATABASE&lt;/code&gt; will fail if any other connection exists when it starts; during the copy operation, new connections to the source database are prevented.</source>
          <target state="translated">追加のテンプレートデータベースを作成することが可能であり、実際に、その名前を &lt;code&gt;CREATE DATABASE&lt;/code&gt; のテンプレートとして指定することにより、クラスター内の任意のデータベースをコピーできます。ただし、これは（まだ）汎用の「 &lt;code&gt;COPY DATABASE&lt;/code&gt; 」機能としては意図されていないことを理解することが重要です。主な制限は、コピー中は他のセッションをソースデータベースに接続できないことです。開始時に他の接続が存在する場合、 &lt;code&gt;CREATE DATABASE&lt;/code&gt; は失敗します。コピー操作中は、ソースデータベースへの新しい接続が禁止されます。</target>
        </trans-unit>
        <trans-unit id="e68d9c04db6c0169a67f695c187f5caec6e9c6fb" translate="yes" xml:space="preserve">
          <source>It is possible to dispense with &lt;code&gt;SET TRANSACTION&lt;/code&gt; by instead specifying the desired &lt;code&gt;transaction_modes&lt;/code&gt; in &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;START TRANSACTION&lt;/code&gt;. But that option is not available for &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BEGIN&lt;/code&gt; または &lt;code&gt;START TRANSACTION&lt;/code&gt; で目的の &lt;code&gt;transaction_modes&lt;/code&gt; を指定することにより、 &lt;code&gt;SET TRANSACTION&lt;/code&gt; を省略できます。ただし、そのオプションは &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; では使用できません。</target>
        </trans-unit>
        <trans-unit id="c6a819090253f862f39b7dcfdb25432b06b91898" translate="yes" xml:space="preserve">
          <source>It is possible to do a full text search without an index. A simple query to print the &lt;code&gt;title&lt;/code&gt; of each row that contains the word &lt;code&gt;friend&lt;/code&gt; in its &lt;code&gt;body&lt;/code&gt; field is:</source>
          <target state="translated">インデックスなしで全文検索を行うことができます。印刷する単純なクエリ &lt;code&gt;title&lt;/code&gt; ワードが含まれ、各行の &lt;code&gt;friend&lt;/code&gt; その中に &lt;code&gt;body&lt;/code&gt; フィールドは以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="6f136c23eebfd4cd415f6012b712c4df1242fdcd" translate="yes" xml:space="preserve">
          <source>It is possible to have authentication without encryption overhead by using &lt;code&gt;NULL-SHA&lt;/code&gt; or &lt;code&gt;NULL-MD5&lt;/code&gt; ciphers. However, a man-in-the-middle could read and pass communications between client and server. Also, encryption overhead is minimal compared to the overhead of authentication. For these reasons NULL ciphers are not recommended.</source>
          <target state="translated">&lt;code&gt;NULL-SHA&lt;/code&gt; または &lt;code&gt;NULL-MD5&lt;/code&gt; 暗号を使用することにより、暗号化オーバーヘッドなしで認証を行うことが可能です。ただし、中間者がクライアントとサーバー間の通信を読み取って渡す可能性があります。また、暗号化のオーバーヘッドは、認証のオーバーヘッドと比較して最小限です。これらの理由により、NULL暗号は推奨されません。</target>
        </trans-unit>
        <trans-unit id="c3a0ba5698f2b4b4f4b4ee88ac329603107cde1d" translate="yes" xml:space="preserve">
          <source>It is possible to log to stderr without using the logging collector; the log messages will just go to wherever the server's stderr is directed. However, that method is only suitable for low log volumes, since it provides no convenient way to rotate log files. Also, on some platforms not using the logging collector can result in lost or garbled log output, because multiple processes writing concurrently to the same log file can overwrite each other's output.</source>
          <target state="translated">ロギングコレクターを使わずに標準エラーにログを記録することは可能です。しかし、この方法はログファイルを回転させる便利な方法を提供しないので、ログボリュームが少ない場合にのみ適しています。また、一部のプラットフォームでは、ロギングコレクターを使用しないと、ログ出力が失われたり、文字化けしたりすることがあります。</target>
        </trans-unit>
        <trans-unit id="36e9a78df914fad0648da0a65b3ec648ec904013" translate="yes" xml:space="preserve">
          <source>It is possible to nest dollar-quoted string constants by choosing different tags at each nesting level. This is most commonly used in writing function definitions. For example:</source>
          <target state="translated">各ネスティングレベルで異なるタグを選択することで、ドル引用符で囲まれた文字列定数をネスティングすることができます。これは、関数の定義を書く際に最もよく使われます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a0a345a5b07bad2c1307139346533842f66f7f85" translate="yes" xml:space="preserve">
          <source>It is possible to omit the &lt;code&gt;lower-bound&lt;/code&gt; and/or &lt;code&gt;upper-bound&lt;/code&gt; of a slice specifier; the missing bound is replaced by the lower or upper limit of the array's subscripts. For example:</source>
          <target state="translated">スライス指定子の &lt;code&gt;lower-bound&lt;/code&gt; および/または &lt;code&gt;upper-bound&lt;/code&gt; を省略することができます。欠落している境界は、配列の添え字の下限または上限に置き換えられます。例えば：</target>
        </trans-unit>
        <trans-unit id="0fbcc6e88bd4f468012c5b5e8934f903489fc504" translate="yes" xml:space="preserve">
          <source>It is possible to run &lt;code&gt;ANALYZE&lt;/code&gt; on specific tables and even just specific columns of a table, so the flexibility exists to update some statistics more frequently than others if your application requires it. In practice, however, it is usually best to just analyze the entire database, because it is a fast operation. &lt;code&gt;ANALYZE&lt;/code&gt; uses a statistically random sampling of the rows of a table rather than reading every single row.</source>
          <target state="translated">特定のテーブルおよびテーブルの特定の列でさえ &lt;code&gt;ANALYZE&lt;/code&gt; を実行することが可能であるため、アプリケーションで必要な場合に、一部の統計を他の統計よりも頻繁に更新する柔軟性があります。ただし、実際には高速な操作であるため、通常はデータベース全体を分析するのが最善です。 &lt;code&gt;ANALYZE&lt;/code&gt; は、すべての行を読み取るのではなく、テーブルの行の統計的にランダムなサンプリングを使用します。</target>
        </trans-unit>
        <trans-unit id="56b863d1457c5714b3cbf931bd78aab64ed29d7b" translate="yes" xml:space="preserve">
          <source>It is possible to set up more complex expression indexes wherein the configuration name is specified by another column, e.g.:</source>
          <target state="translated">設定名が別のカラムによって指定されるような、より複雑な式インデックスを設定することが可能である。</target>
        </trans-unit>
        <trans-unit id="ab7995c28ab9203226049f19e6325626835b07f5" translate="yes" xml:space="preserve">
          <source>It is possible to use PostgreSQL's backup facilities to produce standalone hot backups. These are backups that cannot be used for point-in-time recovery, yet are typically much faster to backup and restore than pg_dump dumps. (They are also much larger than pg_dump dumps, so in some cases the speed advantage might be negated.)</source>
          <target state="translated">PostgreSQLのバックアップ機能を使用してスタンドアロンのホットバックアップを作成することができます。これらはポイントインタイムリカバリには使用できないバックアップですが、一般的にはpg_dumpダンプよりもはるかに高速にバックアップとリストアを行うことができます(また、pg_dumpダンプよりもはるかに大きいので、場合によっては速度の優位性が否定されることもあります)。(これらのバックアップはpg_dumpダンプよりもはるかに大きいので、場合によっては速度の優位性が否定されることもあります)。</target>
        </trans-unit>
        <trans-unit id="793bdae387c6386aab767254ea0495efd0a0f102" translate="yes" xml:space="preserve">
          <source>It is possible to use SELinux's dynamic domain transition feature to switch the security label of the client process, the client domain, to a new context, if that is allowed by the security policy. The client domain needs the &lt;code&gt;setcurrent&lt;/code&gt; permission and also &lt;code&gt;dyntransition&lt;/code&gt; from the old to the new domain.</source>
          <target state="translated">セキュリティポリシーで許可されている場合、SELinuxの動的ドメイン移行機能を使用して、クライアントプロセスのセキュリティラベルであるクライアントドメインを新しいコンテキストに切り替えることができます。クライアントドメインには、 &lt;code&gt;setcurrent&lt;/code&gt; 権限と、古いドメインから新しいドメインへの &lt;code&gt;dyntransition&lt;/code&gt; 移行が必要です。</target>
        </trans-unit>
        <trans-unit id="fea64923e6a1c45508b51b78c6ed3fd042a235d3" translate="yes" xml:space="preserve">
          <source>It is possible to use SSH to encrypt the network connection between clients and a PostgreSQL server. Done properly, this provides an adequately secure network connection, even for non-SSL-capable clients.</source>
          <target state="translated">SSHを使用してクライアントとPostgreSQLサーバ間のネットワーク接続を暗号化することができます。これを適切に行うことで、SSL非対応のクライアントであっても、十分に安全なネットワーク接続を提供します。</target>
        </trans-unit>
        <trans-unit id="05887c55098593888d9b6548b102c0d07ee418cb" translate="yes" xml:space="preserve">
          <source>It is possible to use an NFS file system for storing the PostgreSQL data directory. PostgreSQL does nothing special for NFS file systems, meaning it assumes NFS behaves exactly like locally-connected drives. PostgreSQL does not use any functionality that is known to have nonstandard behavior on NFS, such as file locking.</source>
          <target state="translated">PostgreSQLのデータディレクトリを格納するためにNFSファイルシステムを使用することができます。PostgreSQLはNFSファイルシステムに対して特別なことは何もしません。つまり、NFSはローカルに接続されたドライブと全く同じように動作すると仮定しています。PostgreSQLは、ファイルロックなど、NFS上で非標準的な動作をすることが知られている機能を使用していません。</target>
        </trans-unit>
        <trans-unit id="d07d0d357ed59e4c40820ac16ee2111a412a9fe9" translate="yes" xml:space="preserve">
          <source>It is recommended that in a &lt;code&gt;UNIQUE_CHECK_EXISTING&lt;/code&gt; call, the access method further verify that the target row actually does have an existing entry in the index, and report error if not. This is a good idea because the index tuple values passed to &lt;code&gt;aminsert&lt;/code&gt; will have been recomputed. If the index definition involves functions that are not really immutable, we might be checking the wrong area of the index. Checking that the target row is found in the recheck verifies that we are scanning for the same tuple values as were used in the original insertion.</source>
          <target state="translated">&lt;code&gt;UNIQUE_CHECK_EXISTING&lt;/code&gt; 呼び出しでは、アクセス方法で、ターゲット行が実際にインデックスに既存のエントリを持っていることをさらに確認し、ない場合はエラーを報告することをお勧めします。 &lt;code&gt;aminsert&lt;/code&gt; に渡されたインデックスタプルの値は再計算されるため、これは良い考えです。インデックス定義に実際には不変ではない関数が含まれている場合、インデックスの間違った領域をチェックしている可能性があります。再チェックでターゲット行が見つかったことを確認すると、元の挿入で使用されたのと同じタプル値をスキャンしていることを確認できます。</target>
        </trans-unit>
        <trans-unit id="302398642319ebf3c5925fc78db8e53f6245f737" translate="yes" xml:space="preserve">
          <source>It is recommended that the file name used in &lt;code&gt;COPY&lt;/code&gt; always be specified as an absolute path. This is enforced by the server in the case of &lt;code&gt;COPY TO&lt;/code&gt;, but for &lt;code&gt;COPY FROM&lt;/code&gt; you do have the option of reading from a file specified by a relative path. The path will be interpreted relative to the working directory of the server process (normally the cluster's data directory), not the client's working directory.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; で使用するファイル名は、絶対パスで指定することをお勧めします。これは、 &lt;code&gt;COPY TO&lt;/code&gt; の場合にサーバーによって強制されますが、 &lt;code&gt;COPY FROM&lt;/code&gt; の場合、相対パスで指定されたファイルから読み取るオプションがあります。パスは、クライアントの作業ディレクトリではなく、サーバープロセスの作業ディレクトリ（通常はクラスターのデータディレクトリ）に関連して解釈されます。</target>
        </trans-unit>
        <trans-unit id="fc0e534ffa8e632dc4cfe7cd8ad98fc538520874" translate="yes" xml:space="preserve">
          <source>It is recommended that you use the pg_dump and pg_dumpall programs from the &lt;em&gt;newer&lt;/em&gt; version of PostgreSQL, to take advantage of enhancements that might have been made in these programs. Current releases of the dump programs can read data from any server version back to 7.0.</source>
          <target state="translated">&lt;em&gt;新しい&lt;/em&gt;バージョンのPostgreSQL のpg_dumpおよびpg_dumpallプログラムを使用して、これらのプログラムで行われた可能性のある拡張機能を利用することをお勧めします。ダンププログラムの現在のリリースでは、サーバーバージョン7.0からのデータを読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="580dc3a7b05e5fa4e5a6d4851ec4e93eeb1cdf02" translate="yes" xml:space="preserve">
          <source>It is safe to use &lt;code&gt;off&lt;/code&gt; for logical replication: If the subscriber loses transactions because of missing synchronization, the data will be resent from the publisher.</source>
          <target state="translated">論理レプリケーションには &lt;code&gt;off&lt;/code&gt; を使用しても安全です。同期が失われているためにサブスクライバーがトランザクションを失うと、データはパブリッシャーから再送信されます。</target>
        </trans-unit>
        <trans-unit id="70a88889b7d21af89f699959f3df667165202cd6" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that applications generating &lt;code&gt;COPY&lt;/code&gt; data convert data newlines and carriage returns to the &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; sequences respectively. At present it is possible to represent a data carriage return by a backslash and carriage return, and to represent a data newline by a backslash and newline. However, these representations might not be accepted in future releases. They are also highly vulnerable to corruption if the &lt;code&gt;COPY&lt;/code&gt; file is transferred across different machines (for example, from Unix to Windows or vice versa).</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; データを生成するアプリケーションでは、データの改行とキャリッジリターンをそれぞれ &lt;code&gt;\n&lt;/code&gt; および &lt;code&gt;\r&lt;/code&gt; シーケンスに変換することを強くお勧めします。現在、データキャリッジリターンをバックスラッシュとキャリッジリターンで表し、データの改行をバックスラッシュと改行で表すことができます。ただし、これらの表現は将来のリリースでは受け入れられなくなる可能性があります。また、 &lt;code&gt;COPY&lt;/code&gt; ファイルが異なるマシン間で転送された場合（たとえば、UnixからWindowsへ、またはその逆）、破損に対して非常に脆弱です。</target>
        </trans-unit>
        <trans-unit id="5d757720e64f735dd8e83c5c66b88db49094003f" translate="yes" xml:space="preserve">
          <source>It is typically used like this:</source>
          <target state="translated">一般的にはこのように使用されます。</target>
        </trans-unit>
        <trans-unit id="cb6eae65d1260158a9aaaa3278cf273df69fbee7" translate="yes" xml:space="preserve">
          <source>It is unwise to leave transactions in the prepared state for a long time. This will interfere with the ability of &lt;code&gt;VACUUM&lt;/code&gt; to reclaim storage, and in extreme cases could cause the database to shut down to prevent transaction ID wraparound (see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;). Keep in mind also that the transaction continues to hold whatever locks it held. The intended usage of the feature is that a prepared transaction will normally be committed or rolled back as soon as an external transaction manager has verified that other databases are also prepared to commit.</source>
          <target state="translated">トランザクションを準備された状態で長時間放置することは賢明ではありません。これは、ストレージを再利用する &lt;code&gt;VACUUM&lt;/code&gt; の機能に干渉し、極端な場合には、トランザクションIDの折り返しを防ぐためにデータベースをシャットダウンする可能性があります（&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;セクション24.1.5を&lt;/a&gt;参照）。また、トランザクションは、保持していたロックを保持し続けることにも注意してください。この機能の使用目的は、通常、準備されたトランザクションは、他のデータベースもコミットする準備ができていることを外部トランザクションマネージャが確認するとすぐにコミットまたはロールバックされることです。</target>
        </trans-unit>
        <trans-unit id="a307e2692a3d4dc03f3b0a5f0050741c926c9763" translate="yes" xml:space="preserve">
          <source>It is up to the database designer to define the channel names that will be used in a given database and what each one means. Commonly, the channel name is the same as the name of some table in the database, and the notify event essentially means, &amp;ldquo;I changed this table, take a look at it to see what's new&amp;rdquo;. But no such association is enforced by the &lt;code&gt;NOTIFY&lt;/code&gt; and &lt;code&gt;LISTEN&lt;/code&gt; commands. For example, a database designer could use several different channel names to signal different sorts of changes to a single table. Alternatively, the payload string could be used to differentiate various cases.</source>
          <target state="translated">特定のデータベースで使用されるチャネル名とそれぞれの意味を定義するのはデータベース設計者の責任です。一般的に、チャネル名はデータベース内のいくつかのテーブルの名前と同じであり、通知イベントは基本的に「このテーブルを変更しました。これを見て、新機能を確認してください」という意味です。しかし、そのような関連付けは &lt;code&gt;NOTIFY&lt;/code&gt; コマンドと &lt;code&gt;LISTEN&lt;/code&gt; コマンドによって強制されません。たとえば、データベース設計者は、いくつかの異なるチャネル名を使用して、1つのテーブルにさまざまな種類の変更を通知できます。あるいは、ペイロード文字列を使用して、さまざまなケースを区別できます。</target>
        </trans-unit>
        <trans-unit id="c8b6810a1ee6954d361d4c3ec546cf2001eccf7f" translate="yes" xml:space="preserve">
          <source>It is up to the specific dictionary how it treats stop words. For example, &lt;code&gt;ispell&lt;/code&gt; dictionaries first normalize words and then look at the list of stop words, while &lt;code&gt;Snowball&lt;/code&gt; stemmers first check the list of stop words. The reason for the different behavior is an attempt to decrease noise.</source>
          <target state="translated">ストップワードの処理方法は、特定の辞書によって異なります。たとえば、 &lt;code&gt;ispell&lt;/code&gt; 辞書は最初に単語を正規化してからストップワードのリストを確認し、 &lt;code&gt;Snowball&lt;/code&gt; ステマーは最初にストップワードのリストを確認します。動作が異なる理由は、ノイズを減らすためです。</target>
        </trans-unit>
        <trans-unit id="f04c713c711198819201fd61c74a6825a1ba7c14" translate="yes" xml:space="preserve">
          <source>It is usually wise to create the primary and standby servers so that they are as similar as possible, at least from the perspective of the database server. In particular, the path names associated with tablespaces will be passed across unmodified, so both primary and standby servers must have the same mount paths for tablespaces if that feature is used. Keep in mind that if &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; is executed on the primary, any new mount point needed for it must be created on the primary and all standby servers before the command is executed. Hardware need not be exactly the same, but experience shows that maintaining two identical systems is easier than maintaining two dissimilar ones over the lifetime of the application and system. In any case the hardware architecture must be the same &amp;mdash; shipping from, say, a 32-bit to a 64-bit system will not work.</source>
          <target state="translated">通常、少なくともデータベースサーバーの観点からは、プライマリサーバーとスタンバイサーバーをできるだけ似たものにすることをお勧めします。特に、テーブルスペースに関連付けられたパス名は変更されずに渡されるため、その機能を使用する場合、プライマリサーバーとスタンバイサーバーの両方がテーブルスペースに対して同じマウントパスを持っている必要があります。&lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACEの&lt;/a&gt;場合、がプライマリで実行されると、コマンドに必要なすべての新しいマウントポイントが、プライマリサーバーとすべてのスタンバイサーバーで作成される必要があります。ハードウェアは完全に同じである必要はありませんが、経験上、2つの同一のシステムを維持する方が、アプリケーションとシステムの存続期間にわたって2つの異なるシステムを維持するよりも簡単であることがわかっています。いずれの場合も、ハードウェアアーキテクチャは同じである必要があります。たとえば、32ビットシステムから64ビットシステムへの出荷は機能しません。</target>
        </trans-unit>
        <trans-unit id="2ca150da1f7706a6be21716f546b65e3672dbc4a" translate="yes" xml:space="preserve">
          <source>It is very difficult to avoid such problems, because of SQL's general assumption that a null value is a valid value of every data type. Best practice therefore is to design a domain's constraints so that a null value is allowed, and then to apply column &lt;code&gt;NOT NULL&lt;/code&gt; constraints to columns of the domain type as needed, rather than directly to the domain type.</source>
          <target state="translated">SQLでは一般的にnull値はすべてのデータ型の有効な値であると想定されているため、このような問題を回避することは非常に困難です。したがって、ベストプラクティスは、null値が許可されるようにドメインの制約を設計し、次に列の &lt;code&gt;NOT NULL&lt;/code&gt; 制約を、ドメインタイプに直接ではなく必要に応じてドメインタイプの列に適用することです。</target>
        </trans-unit>
        <trans-unit id="7ca67a8bc55b2440ee4642c5a3836e4f1be7ce5b" translate="yes" xml:space="preserve">
          <source>It is very difficult to enforce business rules regarding data integrity using Read Committed transactions because the view of the data is shifting with each statement, and even a single statement may not restrict itself to the statement's snapshot if a write conflict occurs.</source>
          <target state="translated">Read Committedトランザクションを使用してデータの整合性に関するビジネスルールを強制するのは、ステートメントごとにデータのビューがシフトしているため非常に困難であり、単一のステートメントであっても書き込み競合が発生した場合には、ステートメントのスナップショットに自分自身を制限することができない場合があります。</target>
        </trans-unit>
        <trans-unit id="c946419a4ac69d8f0e7011290f8155362fae2bbd" translate="yes" xml:space="preserve">
          <source>It is very easy to use pgbench to produce completely meaningless numbers. Here are some guidelines to help you get useful results.</source>
          <target state="translated">pgbenchを使って全く意味のない数字を出すのは非常に簡単です。ここでは、有用な結果を得るためのガイドラインをいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="8a18d874cf4b801c23ef52010af4733b69c843e7" translate="yes" xml:space="preserve">
          <source>It is very important that the access privileges for replication be set up so that only trusted users can read the WAL stream, because it is easy to extract privileged information from it. Standby servers must authenticate to the primary as a superuser or an account that has the &lt;code&gt;REPLICATION&lt;/code&gt; privilege. It is recommended to create a dedicated user account with &lt;code&gt;REPLICATION&lt;/code&gt; and &lt;code&gt;LOGIN&lt;/code&gt; privileges for replication. While &lt;code&gt;REPLICATION&lt;/code&gt; privilege gives very high permissions, it does not allow the user to modify any data on the primary system, which the &lt;code&gt;SUPERUSER&lt;/code&gt; privilege does.</source>
          <target state="translated">WALストリームから特権情報を簡単に抽出できるため、WALストリームを信頼できるユーザーだけが読み取ることができるように、複製のアクセス特権を設定することが非常に重要です。スタンバイサーバーは、スーパーユーザーまたは &lt;code&gt;REPLICATION&lt;/code&gt; 特権を持つアカウントとしてプライマリを認証する必要があります。レプリケーションには、 &lt;code&gt;REPLICATION&lt;/code&gt; および &lt;code&gt;LOGIN&lt;/code&gt; 特権を持つ専用ユーザーアカウントを作成することをお勧めします。一方で &lt;code&gt;REPLICATION&lt;/code&gt; 権限が非常に高い権限を与え、それはユーザーがプライマリシステム上のすべてのデータを変更することはできません &lt;code&gt;SUPERUSER&lt;/code&gt; 権限がありません。</target>
        </trans-unit>
        <trans-unit id="d630958bd06e172aebb494cef807db838ae776b4" translate="yes" xml:space="preserve">
          <source>It is very important to take care to avoid circular rules. For example, though each of the following two rule definitions are accepted by PostgreSQL, the &lt;code&gt;SELECT&lt;/code&gt; command would cause PostgreSQL to report an error because of recursive expansion of a rule:</source>
          <target state="translated">循環ルールを回避するように注意することは非常に重要です。たとえば、次の2つのルール定義はそれぞれPostgreSQLで受け入れられますが、 &lt;code&gt;SELECT&lt;/code&gt; コマンドを使用すると、ルールが再帰的に展開されるため、PostgreSQLでエラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="5a1a313f5514df92e2599108b061f0b4f0a8e02d" translate="yes" xml:space="preserve">
          <source>It is widely considered good style to qualify all column names in a join query, so that the query won't fail if a duplicate column name is later added to one of the tables.</source>
          <target state="translated">結合クエリですべてのカラム名を修飾することは、後にテーブルの1つに重複したカラム名が追加されてもクエリが失敗しないようにするために、広く良いスタイルと考えられています。</target>
        </trans-unit>
        <trans-unit id="906e585ddeae75bc90c0d2a785d10b4e23e5052c" translate="yes" xml:space="preserve">
          <source>It is wise to be conservative about marking casts as implicit. An overabundance of implicit casting paths can cause PostgreSQL to choose surprising interpretations of commands, or to be unable to resolve commands at all because there are multiple possible interpretations. A good rule of thumb is to make a cast implicitly invokable only for information-preserving transformations between types in the same general type category. For example, the cast from &lt;code&gt;int2&lt;/code&gt; to &lt;code&gt;int4&lt;/code&gt; can reasonably be implicit, but the cast from &lt;code&gt;float8&lt;/code&gt; to &lt;code&gt;int4&lt;/code&gt; should probably be assignment-only. Cross-type-category casts, such as &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;int4&lt;/code&gt;, are best made explicit-only.</source>
          <target state="translated">キャストを暗黙的なものとしてマークすることについては慎重に行うことをお勧めします。暗黙のキャストパスが多すぎると、PostgreSQLがコマンドの意外な解釈を選択したり、解釈が複数あるためにコマンドをまったく解決できなかったりする可能性があります。経験則としては、同じ一般的な型カテゴリ内の型間の情報を保持する変換に対してのみ、キャストを暗黙的に呼び出すことができます。例えば、キャストから &lt;code&gt;int2&lt;/code&gt; へ &lt;code&gt;int4&lt;/code&gt; 合理的、暗黙的なことができますが、よりキャスト &lt;code&gt;float8&lt;/code&gt; へ &lt;code&gt;int4&lt;/code&gt; 、おそらく代入のみでなければなりません。 &lt;code&gt;text&lt;/code&gt; から &lt;code&gt;int4&lt;/code&gt; へのようなタイプ間カテゴリのキャストは、明示的にのみ行うのが最適です。</target>
        </trans-unit>
        <trans-unit id="7c5b3068c21100601581e786ee86ca3a3f0b7637" translate="yes" xml:space="preserve">
          <source>It is your responsibility that the byte sequences you create, especially when using the octal or hexadecimal escapes, compose valid characters in the server character set encoding. When the server encoding is UTF-8, then the Unicode escapes or the alternative Unicode escape syntax, explained in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-UESCAPE&quot;&gt;Section 4.1.2.3&lt;/a&gt;, should be used instead. (The alternative would be doing the UTF-8 encoding by hand and writing out the bytes, which would be very cumbersome.)</source>
          <target state="translated">作成したバイトシーケンス、特に8進数または16進数のエスケープを使用する場合は、サーバーの文字セットエンコーディングで有効な文字を構成する必要があります。サーバーのエンコーディングがUTF-8の場合は、代わりにUnicodeエスケープまたは&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-UESCAPE&quot;&gt;4.1.2.3項&lt;/a&gt;で説明した代替のUnicodeエスケープ構文を使用する必要があります。（別の方法としては、UTF-8エンコードを手動で行い、バイトを書き出す方法があり、非常に煩雑になります。）</target>
        </trans-unit>
        <trans-unit id="7e498293987ea55fea8d5b2403c8c230700d8887" translate="yes" xml:space="preserve">
          <source>It makes your SQL statements verbose, and you always have to remember to use &lt;code&gt;lower&lt;/code&gt; on both the column and the query value.</source>
          <target state="translated">SQLステートメントが冗長になるため、常に列とクエリ値の両方で &lt;code&gt;lower&lt;/code&gt; を使用することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="ef32cc79ad6cb19406da947c5847a9365640d3e1" translate="yes" xml:space="preserve">
          <source>It may also be necessary to give the database server's operating system user permission to use huge pages by setting &lt;code&gt;vm.hugetlb_shm_group&lt;/code&gt; via sysctl, and/or give permission to lock memory with &lt;code&gt;ulimit -l&lt;/code&gt;.</source>
          <target state="translated">また、sysctlを介して &lt;code&gt;vm.hugetlb_shm_group&lt;/code&gt; を設定することにより、データベースサーバーのオペレーティングシステムユーザーに巨大なページを使用する権限を付与するか、 &lt;code&gt;ulimit -l&lt;/code&gt; でメモリをロックする権限を付与する必要があります。</target>
        </trans-unit>
        <trans-unit id="c230567f694e16c717ab914422a39d27766ee1c7" translate="yes" xml:space="preserve">
          <source>It may be advisable to avoid using type and table names that begin with underscore. While the server will change generated array type names to avoid collisions with user-given names, there is still risk of confusion, particularly with old client software that may assume that type names beginning with underscores always represent arrays.</source>
          <target state="translated">アンダースコアで始まる型名やテーブル名の使用は避けた方が良いでしょう。サーバは、ユーザが指定した名前との衝突を避けるために生成された配列の型名を変更しますが、特に古いクライアントソフトウェアでは、アンダースコアで始まる型名が常に配列を表していると思い込んでいる可能性があり、混乱を招く可能性があります。</target>
        </trans-unit>
        <trans-unit id="914462b7eb826c460762b58dc586f5544963cc18" translate="yes" xml:space="preserve">
          <source>It may be useful to adjust this size to control the granularity of WAL log shipping or archiving. Also, in databases with a high volume of WAL, the sheer number of WAL files per directory can become a performance and management problem. Increasing the WAL file size will reduce the number of WAL files.</source>
          <target state="translated">このサイズを調整して、WALログの出荷やアーカイブの粒度を制御すると便利かもしれません。また、WALの量が多いデータベースでは、ディレクトリあたりのWALファイルの数が膨大になると、パフォーマンスや管理上の問題になることがあります。WALファイルのサイズを大きくすることで、WALファイルの数を減らすことができます。</target>
        </trans-unit>
        <trans-unit id="7c0fb5b044b855badd9b796e550a5309d125f9a8" translate="yes" xml:space="preserve">
          <source>It might, however, be necessary to modify the global &lt;code&gt;ulimit&lt;/code&gt; information in &lt;code&gt;/etc/security/limits&lt;/code&gt;, as the default hard limits for file sizes (&lt;code&gt;fsize&lt;/code&gt;) and numbers of files (&lt;code&gt;nofiles&lt;/code&gt;) might be too low.</source>
          <target state="translated">しかし、世界的な修正が必要になる場合があります &lt;code&gt;ulimit&lt;/code&gt; 中の情報 &lt;code&gt;/etc/security/limits&lt;/code&gt; デフォルトとして、ファイルサイズ（ハードリミット &lt;code&gt;fsize&lt;/code&gt; ファイル（の）と数字 &lt;code&gt;nofiles&lt;/code&gt; 低すぎるかもしれません）。</target>
        </trans-unit>
        <trans-unit id="fff2052adc7cc9fd5e18f86ad66dfe1b9dfc242d" translate="yes" xml:space="preserve">
          <source>It should also be noted that the default WAL format is fairly bulky since it includes many disk page snapshots. These page snapshots are designed to support crash recovery, since we might need to fix partially-written disk pages. Depending on your system hardware and software, the risk of partial writes might be small enough to ignore, in which case you can significantly reduce the total volume of archived logs by turning off page snapshots using the &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; parameter. (Read the notes and warnings in &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;Chapter 29&lt;/a&gt; before you do so.) Turning off page snapshots does not prevent use of the logs for PITR operations. An area for future development is to compress archived WAL data by removing unnecessary page copies even when &lt;code&gt;full_page_writes&lt;/code&gt; is on. In the meantime, administrators might wish to reduce the number of page snapshots included in WAL by increasing the checkpoint interval parameters as much as feasible.</source>
          <target state="translated">また、デフォルトのWALフォーマットには多くのディスクページスナップショットが含まれているため、かなりサイズが大きいことにも注意してください。これらのページスナップショットは、部分的に書き込まれたディスクページを修正する必要がある場合があるため、クラッシュリカバリをサポートするように設計されています。システムのハードウェアとソフトウェアによっては、部分的な書き込みのリスクが無視できるほど小さい場合があります。その場合、&lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt;パラメータを使用してページのスナップショットをオフにすることで、アーカイブログの総量を大幅に減らすことができます。 （その前に、&lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;第29章の&lt;/a&gt;注意と警告をお読みください。）ページのスナップショットをオフにしても、PITR操作のログの使用が妨げられることはありません。今後の開発の領域は、 &lt;code&gt;full_page_writes&lt;/code&gt; の場合でも不要なページコピーを削除して、アーカイブされたWALデータを圧縮することですオンです。それまでの間、管理者は、チェックポイント間隔パラメーターを可能な限り大きくして、WALに含まれるページスナップショットの数を減らしたいと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="af922062ac86a130253f6b4fd50587d3a97630cd" translate="yes" xml:space="preserve">
          <source>It should be fairly clear why a btree index requires these laws to hold within a single data type: without them there is no ordering to arrange the keys with. Also, index searches using a comparison key of a different data type require comparisons to behave sanely across two data types. The extensions to three or more data types within a family are not strictly required by the btree index mechanism itself, but the planner relies on them for optimization purposes.</source>
          <target state="translated">btreeインデックスがこれらの法則を単一のデータ型内で保持する必要がある理由は、かなり明確になっているはずです。また、異なるデータ型の比較キーを使用したインデックス検索では、2つのデータ型の間で比較が正しく動作するようにする必要があります。ファミリ内の3つ以上のデータ型への拡張は、btreeインデックス機構自体が厳密に必要とするものではありませんが、プランナーは最適化のためにそれらに依存しています。</target>
        </trans-unit>
        <trans-unit id="e49813f2476bbea73d4ff66119d7d7387c964091" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;code&gt;pg_cast&lt;/code&gt; does not represent every type conversion that the system knows how to perform; only those that cannot be deduced from some generic rule. For example, casting between a domain and its base type is not explicitly represented in &lt;code&gt;pg_cast&lt;/code&gt;. Another important exception is that &amp;ldquo;automatic I/O conversion casts&amp;rdquo;, those performed using a data type's own I/O functions to convert to or from &lt;code&gt;text&lt;/code&gt; or other string types, are not explicitly represented in &lt;code&gt;pg_cast&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_cast&lt;/code&gt; は、システムが実行方法を知っているすべての型変換を表すわけではないことに注意してください。いくつかの一般的なルールから推定できないもののみ。たとえば、ドメインとその基本型の間のキャストは、 &lt;code&gt;pg_cast&lt;/code&gt; では明示的に表現されていません。もう1つの重要な例外は、「自動I / O変換キャスト」、つまりデータタイプ自体のI / O関数を使用して &lt;code&gt;text&lt;/code&gt; または他の文字列タイプとの間で変換を行うものであり、 &lt;code&gt;pg_cast&lt;/code&gt; では明示的に表されません。</target>
        </trans-unit>
        <trans-unit id="3f75a2b78a5f5649b3ab9e555457464dd4adddae" translate="yes" xml:space="preserve">
          <source>It should be noted that a check constraint is satisfied if the check expression evaluates to true or the null value. Since most expressions will evaluate to the null value if any operand is null, they will not prevent null values in the constrained columns. To ensure that a column does not contain null values, the not-null constraint described in the next section can be used.</source>
          <target state="translated">チェック制約は、チェック式が真またはヌル値に評価された場合に満たされることに注意する必要があります。ほとんどの式は、任意のオペランドがNULLであればNULL値に評価されるので、制約のある列にNULL値が含まれないようにすることはできません。列にNULL値が含まれないようにするには、次のセクションで説明する非NULL制約を使用することができます。</target>
        </trans-unit>
        <trans-unit id="02935ea4ceb5538c0d2002f169c21bb8e60788b3" translate="yes" xml:space="preserve">
          <source>It should be noted that database superusers can access all objects regardless of object privilege settings. This is comparable to the rights of &lt;code&gt;root&lt;/code&gt; in a Unix system. As with &lt;code&gt;root&lt;/code&gt;, it's unwise to operate as a superuser except when absolutely necessary.</source>
          <target state="translated">データベースのスーパーユーザーは、オブジェクトの権限設定に関係なく、すべてのオブジェクトにアクセスできることに注意してください。これは、Unixシステムの &lt;code&gt;root&lt;/code&gt; の権限に相当します。 &lt;code&gt;root&lt;/code&gt; と同様に、どうしても必要な場合を除いて、スーパーユーザーとして操作することは賢明ではありません。</target>
        </trans-unit>
        <trans-unit id="8c98ab8e1a3d8f36aae75d2304e7a94b266eaa6f" translate="yes" xml:space="preserve">
          <source>It should be noted that except for &lt;code&gt;count&lt;/code&gt;, these functions return a null value when no rows are selected. In particular, &lt;code&gt;sum&lt;/code&gt; of no rows returns null, not zero as one might expect, and &lt;code&gt;array_agg&lt;/code&gt; returns null rather than an empty array when there are no input rows. The &lt;code&gt;coalesce&lt;/code&gt; function can be used to substitute zero or an empty array for null when necessary.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; を除き、行が選択されていない場合、これらの関数はnull値を返すことに注意してください。特に、行がない場合の &lt;code&gt;sum&lt;/code&gt; は期待どおりにゼロではなくnullを返し、入力行がない場合、 &lt;code&gt;array_agg&lt;/code&gt; は空の配列ではなくnullを返します。 &lt;code&gt;coalesce&lt;/code&gt; 機能は代替ゼロまたはヌルのために空の配列に必要に使用することができます。</target>
        </trans-unit>
        <trans-unit id="fcddd727e8976d04c908eb345e29817691fb2925" translate="yes" xml:space="preserve">
          <source>It should be noted that log shipping is asynchronous, i.e., the WAL records are shipped after transaction commit. As a result, there is a window for data loss should the primary server suffer a catastrophic failure; transactions not yet shipped will be lost. The size of the data loss window in file-based log shipping can be limited by use of the &lt;code&gt;archive_timeout&lt;/code&gt; parameter, which can be set as low as a few seconds. However such a low setting will substantially increase the bandwidth required for file shipping. Streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;) allows a much smaller window of data loss.</source>
          <target state="translated">ログ配布は非同期であることに注意してください。つまり、WALレコードはトランザクションのコミット後に配布されます。その結果、プライマリサーバーで壊滅的な障害が発生した場合に、データが失われる可能性があります。まだ出荷されていないトランザクションは失われます。ファイルベースのログ配布でのデータ損失ウィンドウのサイズは、 &lt;code&gt;archive_timeout&lt;/code&gt; パラメータを使用して制限できます。このパラメータは、数秒に設定できます。ただし、このような低い設定では、ファイル配布に必要な帯域幅が大幅に増加します。ストリーミングレプリケーション（&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;セクション26.2.5を&lt;/a&gt;参照）では、データ損失のウィンドウをはるかに小さくできます。</target>
        </trans-unit>
        <trans-unit id="3defdb9a09006209e803808debdc569c264d27e7" translate="yes" xml:space="preserve">
          <source>It won't use an index, unless you create a functional index using &lt;code&gt;lower&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lower&lt;/code&gt; を使用して関数インデックスを作成しない限り、インデックスは使用されません。</target>
        </trans-unit>
        <trans-unit id="6b722c9c9f3f75689f42f0b53f218a01c48008e8" translate="yes" xml:space="preserve">
          <source>It would be better to instead create child tables as follows:</source>
          <target state="translated">代わりに以下のように子テーブルを作成した方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="b3751c875e52c61621661f1961d94164268c168e" translate="yes" xml:space="preserve">
          <source>It's a matter of taste.</source>
          <target state="translated">好みの問題です。</target>
        </trans-unit>
        <trans-unit id="6308fac37b6f916e6aaeedec4f54478b5685b89a" translate="yes" xml:space="preserve">
          <source>It's advisable to create &lt;code&gt;ndistinct&lt;/code&gt; statistics objects only on combinations of columns that are actually used for grouping, and for which misestimation of the number of groups is resulting in bad plans. Otherwise, the &lt;code&gt;ANALYZE&lt;/code&gt; cycles are just wasted.</source>
          <target state="translated">グループ化に実際に使用されている列の組み合わせでのみ &lt;code&gt;ndistinct&lt;/code&gt; 統計オブジェクトを作成することをお勧めします。そのため、グループ数の誤った推定が悪い計画につながります。そうしないと、 &lt;code&gt;ANALYZE&lt;/code&gt; サイクルが無駄になります。</target>
        </trans-unit>
        <trans-unit id="695d14c6506a71cfb6f8af1b5d18b963ae0d4f6f" translate="yes" xml:space="preserve">
          <source>It's advisable to create MCV statistics objects only on combinations of columns that are actually used in conditions together, and for which misestimation of the number of groups is resulting in bad plans. Otherwise, the &lt;code&gt;ANALYZE&lt;/code&gt; and planning cycles are just wasted.</source>
          <target state="translated">MCV統計オブジェクトは、実際に条件で一緒に使用されている列の組み合わせでのみ作成することをお勧めします。このため、グループ数の誤推定が原因で、計画が悪くなります。そうしないと、 &lt;code&gt;ANALYZE&lt;/code&gt; と計画のサイクルが無駄になります。</target>
        </trans-unit>
        <trans-unit id="26d8635c1af4731c90f7caf11c20fceefa695a0b" translate="yes" xml:space="preserve">
          <source>It's also permissible to attach &lt;code&gt;BKI_LOOKUP(encoding)&lt;/code&gt; to integer columns to reference character set encodings, which are not currently represented as catalog OIDs, but have a set of values known to &lt;code&gt;genbki.pl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BKI_LOOKUP(encoding)&lt;/code&gt; を整数列にアタッチして、現在カタログOIDとして表されていないが、 &lt;code&gt;genbki.pl&lt;/code&gt; に既知の値のセットを持つ文字セットエンコーディングを参照することもできます。</target>
        </trans-unit>
        <trans-unit id="42cd973aeb3dbef0c62ad2e81081d6f4bf4973db" translate="yes" xml:space="preserve">
          <source>It's also possible to select no escape character by writing &lt;code&gt;ESCAPE ''&lt;/code&gt;. This effectively disables the escape mechanism, which makes it impossible to turn off the special meaning of underscore and percent signs in the pattern.</source>
          <target state="translated">&lt;code&gt;ESCAPE ''&lt;/code&gt; と書くことで、エスケープ文字を選択しないこともできます。これにより、エスケープメカニズムが事実上無効になり、パターン内のアンダースコアとパーセント記号の特別な意味をオフにすることができなくなります。</target>
        </trans-unit>
        <trans-unit id="8646be546a98ef8ea063cb9eec163a8d4548ff24" translate="yes" xml:space="preserve">
          <source>It's essential that the data types and other properties of the columns declared in &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; match the actual remote table. Column names must match as well, unless you attach &lt;code&gt;column_name&lt;/code&gt; options to the individual columns to show how they are named in the remote table. In many cases, use of &lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMA&lt;/a&gt; is preferable to constructing foreign table definitions manually.</source>
          <target state="translated">&lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; で宣言された列のデータ型とその他のプロパティが実際のリモートテーブルと一致することが重要です。列名も一致する必要があります。ただし、 &lt;code&gt;column_name&lt;/code&gt; オプションを個々の列にアタッチして、リモートテーブルでの列の名前を示す場合を除きます。多くの場合、外部テーブル定義を手動で作成するよりも、&lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMAを&lt;/a&gt;使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a75f17e623d692c2b958fa72bc491d5871febb40" translate="yes" xml:space="preserve">
          <source>It's important to understand that the cost of an upper-level node includes the cost of all its child nodes. It's also important to realize that the cost only reflects things that the planner cares about. In particular, the cost does not consider the time spent transmitting result rows to the client, which could be an important factor in the real elapsed time; but the planner ignores it because it cannot change it by altering the plan. (Every correct plan will output the same row set, we trust.)</source>
          <target state="translated">上位ノードのコストには、その子ノードすべてのコストが含まれていることを理解することが重要です。また、コストはプランナが気にしていることを反映しているだけであることを理解することも重要です。これは実際の経過時間の重要な要素である可能性がありますが,プランナはプランを変更しても変更できないため,これを無視します.しかし,プランナーはプランを変更することで変更できないため,これを無視しています.</target>
        </trans-unit>
        <trans-unit id="7c3ed76ba22932f8e0061fba8fda8ba6c6509eab" translate="yes" xml:space="preserve">
          <source>It's possible to control the statements in a transaction in a more granular fashion through the use of &lt;em&gt;savepoints&lt;/em&gt;. Savepoints allow you to selectively discard parts of the transaction, while committing the rest. After defining a savepoint with &lt;code&gt;SAVEPOINT&lt;/code&gt;, you can if needed roll back to the savepoint with &lt;code&gt;ROLLBACK TO&lt;/code&gt;. All the transaction's database changes between defining the savepoint and rolling back to it are discarded, but changes earlier than the savepoint are kept.</source>
          <target state="translated">&lt;em&gt;セーブポイントを&lt;/em&gt;使用すると、トランザクション内のステートメントをより詳細に制御できます。セーブポイントを使用すると、トランザクションの一部を選択的に破棄し、残りをコミットすることができます。 &lt;code&gt;SAVEPOINT&lt;/code&gt; でセーブポイントを定義した後、必要に応じて &lt;code&gt;ROLLBACK TO&lt;/code&gt; でセーブポイントにロールバックできます。セーブポイントの定義からロールバックまでのトランザクションのデータベース変更はすべて破棄されますが、セーブポイントより前の変更は保持されます。</target>
        </trans-unit>
        <trans-unit id="af6b5757cbe3f9b4c6401b87c759f120734c17d1" translate="yes" xml:space="preserve">
          <source>It's recommended to run &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; before submitting catalog data patches. For convenience, you can simply change to &lt;code&gt;src/include/catalog/&lt;/code&gt; and run &lt;code&gt;make reformat-dat-files&lt;/code&gt;.</source>
          <target state="translated">実行することをお勧めします &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; をカタログデータのパッチを提出する前に。便宜上、単に &lt;code&gt;src/include/catalog/&lt;/code&gt; 変更して &lt;code&gt;make reformat-dat-files&lt;/code&gt; を実行するだけです。</target>
        </trans-unit>
        <trans-unit id="4f13f984e4f7daa459e845c3a4715f4638313970" translate="yes" xml:space="preserve">
          <source>It's wise to be conservative about adding non-key columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches.</source>
          <target state="translated">インデックスにキーではないカラム、特に幅の広いカラムを追加することは慎重に行うのが賢明です。インデックスのタプルがインデックスタイプで許可されている最大サイズを超えると、データの挿入に失敗します。いずれにしても、非キーカラムはインデックスのテーブルからデータを複製し、インデックスのサイズを肥大化させ、検索を遅らせる可能性があります。</target>
        </trans-unit>
        <trans-unit id="08237634e67b792c41b6dc72d01cf498506db594" translate="yes" xml:space="preserve">
          <source>It's wise to be conservative about adding non-key payload columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches. And remember that there is little point in including payload columns in an index unless the table changes slowly enough that an index-only scan is likely to not need to access the heap. If the heap tuple must be visited anyway, it costs nothing more to get the column's value from there. Other restrictions are that expressions are not currently supported as included columns, and that only B-tree and GiST indexes currently support included columns.</source>
          <target state="translated">インデックスにキー以外のペイロードカラム、特に幅の広いカラムを追加することは慎重に行うのが賢明です。インデックスのタプルがインデックスタイプで許可されている最大サイズを超えると、データの挿入に失敗します。いずれにしても、非キーカラムはインデックスのテーブルからデータを複製し、インデックスのサイズを肥大化させ、検索を遅らせる可能性があります。また、インデックスのみのスキャンでヒープにアクセスする必要がないほどテーブルの変化が遅い場合を除いては、インデックスにペイロードカラムを含めることにはほとんど意味がないことを覚えておいてください。ヒープタプルにアクセスしなければならないのであれば、そこからカラムの値を取得しても、それ以上のコストはかかりません。その他の制限事項としては、式は現在のところインクルードカラムとしてサポートされていないことと、現在のところインクルードカラムをサポートしているのはB-treeとGiSTインデックスのみであることが挙げられます。</target>
        </trans-unit>
        <trans-unit id="9682da0882fceeebec9d99753c1dc0306b85beab" translate="yes" xml:space="preserve">
          <source>It's worth noticing that the AND/OR/NOT operators mean something subtly different when they are within the arguments of a FOLLOWED BY operator than when they are not, because within FOLLOWED BY the exact position of the match is significant. For example, normally &lt;code&gt;!x&lt;/code&gt; matches only documents that do not contain &lt;code&gt;x&lt;/code&gt; anywhere. But &lt;code&gt;!x &amp;lt;-&amp;gt; y&lt;/code&gt; matches &lt;code&gt;y&lt;/code&gt; if it is not immediately after an &lt;code&gt;x&lt;/code&gt;; an occurrence of &lt;code&gt;x&lt;/code&gt; elsewhere in the document does not prevent a match. Another example is that &lt;code&gt;x &amp;amp; y&lt;/code&gt; normally only requires that &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; both appear somewhere in the document, but &lt;code&gt;(x &amp;amp; y) &amp;lt;-&amp;gt; z&lt;/code&gt; requires &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to match at the same place, immediately before a &lt;code&gt;z&lt;/code&gt;. Thus this query behaves differently from &lt;code&gt;x &amp;lt;-&amp;gt; z &amp;amp; y &amp;lt;-&amp;gt; z&lt;/code&gt;, which will match a document containing two separate sequences &lt;code&gt;x z&lt;/code&gt; and &lt;code&gt;y z&lt;/code&gt;. (This specific query is useless as written, since &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; could not match at the same place; but with more complex situations such as prefix-match patterns, a query of this form could be useful.)</source>
          <target state="translated">AND / OR / NOT演算子は、FOLLOWED BY演算子の引数内にある場合とそうでない場合とで微妙に異なる意味を持つことに注意してください。FOLLOWEDBY内では、一致の正確な位置が重要であるためです。たとえば、通常、 &lt;code&gt;!x&lt;/code&gt; は、 &lt;code&gt;x&lt;/code&gt; を含まないドキュメントのみに一致します。しかし &lt;code&gt;!x &amp;lt;-&amp;gt; y&lt;/code&gt; 一致する &lt;code&gt;y&lt;/code&gt; は、それがした直後でない場合は &lt;code&gt;x&lt;/code&gt; 、文書内の他の場所で &lt;code&gt;x&lt;/code&gt; が発生しても、一致は妨げられません。別の例として、 &lt;code&gt;x &amp;amp; y&lt;/code&gt; は通常、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方がドキュメントのどこかにあることだけを要求しますが、 &lt;code&gt;(x &amp;amp; y) &amp;lt;-&amp;gt; z&lt;/code&gt; は &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は、 &lt;code&gt;z&lt;/code&gt; の直前の同じ場所で一致します。したがって、このクエリの動作は &lt;code&gt;x &amp;lt;-&amp;gt; z &amp;amp; y &amp;lt;-&amp;gt; z&lt;/code&gt; とは異なります。これは、2つの別個のシーケンス &lt;code&gt;x z&lt;/code&gt; と &lt;code&gt;y z&lt;/code&gt; を含むドキュメントに一致します。 （この特定のクエリは、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が同じ場所で一致することができないため、記述されているようには役に立ちません。ただし、プレフィックス一致パターンなどのより複雑な状況では、この形式のクエリが役立つ場合があります。）</target>
        </trans-unit>
        <trans-unit id="ecdda59aea5ee67d7d854c969ccf7f4f4b4a4c54" translate="yes" xml:space="preserve">
          <source>Item</source>
          <target state="translated">Item</target>
        </trans-unit>
        <trans-unit id="036b57986556b399e1579aa78767ca4cf343c8b5" translate="yes" xml:space="preserve">
          <source>ItemIdData</source>
          <target state="translated">ItemIdData</target>
        </trans-unit>
        <trans-unit id="a2965a078eaef7ee13c972baa85b167370cde26a" translate="yes" xml:space="preserve">
          <source>ItemPointerData</source>
          <target state="translated">ItemPointerData</target>
        </trans-unit>
        <trans-unit id="44d25b5d1b6d98c7d090ca3609aca11ae2815fa0" translate="yes" xml:space="preserve">
          <source>Items</source>
          <target state="translated">Items</target>
        </trans-unit>
        <trans-unit id="40f7cf3bbd8b78d82db16eda601698d7597b9ba5" translate="yes" xml:space="preserve">
          <source>J.5. Style Guide</source>
          <target state="translated">J.5.スタイルガイド</target>
        </trans-unit>
        <trans-unit id="7685fa01b8b7b34ce179631444878fcbce78fa81" translate="yes" xml:space="preserve">
          <source>J2451187</source>
          <target state="translated">J2451187</target>
        </trans-unit>
        <trans-unit id="1f1062dcbb83b59e4f6f5cb50ef505afac199e0d" translate="yes" xml:space="preserve">
          <source>JDBC</source>
          <target state="translated">JDBC</target>
        </trans-unit>
        <trans-unit id="eb5d2f4a58038c71155ddcf3cea35dc3c6d34501" translate="yes" xml:space="preserve">
          <source>JIT</source>
          <target state="translated">JIT</target>
        </trans-unit>
        <trans-unit id="6a623f63efe8bb915b0cd81dd3786e0511e1c1a1" translate="yes" xml:space="preserve">
          <source>JIT compilation is beneficial primarily for long-running CPU-bound queries. Frequently these will be analytical queries. For short queries the added overhead of performing JIT compilation will often be higher than the time it can save.</source>
          <target state="translated">JITコンパイルは、主に長期的に実行されるCPUバウンドクエリのために有益です。多くの場合、これらのクエリは分析クエリになります。短いクエリでは、JIT コンパイルの実行によるオーバーヘッドの増加は、多くの場合、時間を節約するよりも高くなります。</target>
        </trans-unit>
        <trans-unit id="6f7646a5ebe2aff38f294e6e525f0ea1b56f8538" translate="yes" xml:space="preserve">
          <source>JOHAB</source>
          <target state="translated">JOHAB</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="c731d9e245778a9537fc026bc57fb4f455f28593" translate="yes" xml:space="preserve">
          <source>JSON Functions and Operators</source>
          <target state="translated">JSON関数と演算子</target>
        </trans-unit>
        <trans-unit id="95cc452498b3190abb79d4cdad349208be23c944" translate="yes" xml:space="preserve">
          <source>JSON Types</source>
          <target state="translated">JSONの種類</target>
        </trans-unit>
        <trans-unit id="f9bea7492dcebb5f109566d49e4bca935a7e0ff7" translate="yes" xml:space="preserve">
          <source>JSON Types: boolean</source>
          <target state="translated">JSON型:boolean</target>
        </trans-unit>
        <trans-unit id="22aff2decb9f95af65f4e2a85c938a9901c03229" translate="yes" xml:space="preserve">
          <source>JSON Types: null</source>
          <target state="translated">JSONの種類:null</target>
        </trans-unit>
        <trans-unit id="b89570edbe3781b5bd3ad2ae7d37f0bf110fdf05" translate="yes" xml:space="preserve">
          <source>JSON Types: number</source>
          <target state="translated">JSON型:数値</target>
        </trans-unit>
        <trans-unit id="205b72d84addc780073dacc96aedf0a7c5c2d3cc" translate="yes" xml:space="preserve">
          <source>JSON Types: string</source>
          <target state="translated">JSON型:文字列</target>
        </trans-unit>
        <trans-unit id="49c22c401963d3661a06e8b5108d657673586e05" translate="yes" xml:space="preserve">
          <source>JSON data is subject to the same concurrency-control considerations as any other data type when stored in a table. Although storing large documents is practicable, keep in mind that any update acquires a row-level lock on the whole row. Consider limiting JSON documents to a manageable size in order to decrease lock contention among updating transactions. Ideally, JSON documents should each represent an atomic datum that business rules dictate cannot reasonably be further subdivided into smaller datums that could be modified independently.</source>
          <target state="translated">JSON データは、テーブルに格納されている場合、他のデータ型と同じ同時実行制御の考慮事項に従います。大きなドキュメントを保存することは可能ですが、更新を行うと行全体の行レベルのロックを取得することに注意しましょう。更新トランザクション間のロックの競合を減らすために、JSON文書を管理可能なサイズに制限することを検討してください。理想的には、JSON文書はそれぞれが、ビジネスルールで規定されているアトミックなデータムを表すべきであり、独立して変更可能な小さなデータムに分割することは合理的に不可能です。</target>
        </trans-unit>
        <trans-unit id="062e2dcdb89d67da750325f5a32e496783b448b0" translate="yes" xml:space="preserve">
          <source>JSON data types are for storing JSON (JavaScript Object Notation) data, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC 7159&lt;/a&gt;. Such data can also be stored as &lt;code&gt;text&lt;/code&gt;, but the JSON data types have the advantage of enforcing that each stored value is valid according to the JSON rules. There are also assorted JSON-specific functions and operators available for data stored in these data types; see &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt;.</source>
          <target state="translated">JSONデータ型は、&lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC 7159で&lt;/a&gt;指定されている JSON（JavaScript Object Notation）データを格納するためのものです。このようなデータは &lt;code&gt;text&lt;/code&gt; として保存することもできますが、JSONデータ型には、保存された各値がJSONルールに従って有効であるという利点があります。これらのデータ型に格納されたデータに使用できるJSON固有の関数と演算子も各種あります。&lt;a href=&quot;functions-json&quot;&gt;セクション9.15を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1b285244e0c7fb77cf325258e945007dbcb0bd79" translate="yes" xml:space="preserve">
          <source>JSON objects are better suited than arrays for testing containment or existence when there are many keys or elements involved, because unlike arrays they are internally optimized for searching, and do not need to be searched linearly.</source>
          <target state="translated">JSON オブジェクトは配列とは異なり、内部的に検索用に最適化されており、直線的に検索される必要がないため、多くのキーや要素が含まれている場合の格納性や存在性のテストには配列よりも適しています。</target>
        </trans-unit>
        <trans-unit id="ff7a8b7bee4833026249925bb4a7e075a31995d4" translate="yes" xml:space="preserve">
          <source>JSON primitive type</source>
          <target state="translated">JSON基本型</target>
        </trans-unit>
        <trans-unit id="196dea5dbe3d820f7bdbd4775445b07993543c68" translate="yes" xml:space="preserve">
          <source>JSON query functions and operators pass the provided path expression to the &lt;em&gt;path engine&lt;/em&gt; for evaluation. If the expression matches the queried JSON data, the corresponding SQL/JSON item is returned. Path expressions are written in the SQL/JSON path language and can also include arithmetic expressions and functions. Query functions treat the provided expression as a text string, so it must be enclosed in single quotes.</source>
          <target state="translated">JSONクエリ関数と演算子は、提供されたパス式を評価のために&lt;em&gt;パスエンジン&lt;/em&gt;に渡します。式がクエリされたJSONデータと一致する場合、対応するSQL / JSONアイテムが返されます。パス式はSQL / JSONパス言語で記述され、算術式や関数を含めることもできます。クエリ関数は提供された式をテキスト文字列として扱うため、一重引用符で囲む必要があります。</target>
        </trans-unit>
        <trans-unit id="7af619b9c5342e6a889b85ca2cae08237b23f616" translate="yes" xml:space="preserve">
          <source>JSON: SQL/JSON Path Language</source>
          <target state="translated">JSON:SQL/JSONパス言語</target>
        </trans-unit>
        <trans-unit id="efed3690ea2243f5f1ac77cbb0987e5335440258" translate="yes" xml:space="preserve">
          <source>Jan</source>
          <target state="translated">Jan</target>
        </trans-unit>
        <trans-unit id="ebeb4b5ab2f3409935c06be07e3191bf0a5dc6cf" translate="yes" xml:space="preserve">
          <source>Jan-08-1999</source>
          <target state="translated">Jan-08-1999</target>
        </trans-unit>
        <trans-unit id="521a936bf91733c55274b55367cc8ed71292693f" translate="yes" xml:space="preserve">
          <source>Jan-08-99</source>
          <target state="translated">Jan-08-99</target>
        </trans-unit>
        <trans-unit id="7a22d73d336abd6281d4dd71080220a230cb79de" translate="yes" xml:space="preserve">
          <source>January</source>
          <target state="translated">January</target>
        </trans-unit>
        <trans-unit id="d6e52d181e7ba4487fe8643d957277cd1cbf82c7" translate="yes" xml:space="preserve">
          <source>January 18 in &lt;code&gt;MDY&lt;/code&gt; mode; rejected in other modes</source>
          <target state="translated">1月18日、 &lt;code&gt;MDY&lt;/code&gt; モード。他のモードでは拒否されました</target>
        </trans-unit>
        <trans-unit id="d1fb4cc8c23271615e96e586a4e1801c1ac84f25" translate="yes" xml:space="preserve">
          <source>January 2, 2003 in &lt;code&gt;MDY&lt;/code&gt; mode; February 1, 2003 in &lt;code&gt;DMY&lt;/code&gt; mode; February 3, 2001 in &lt;code&gt;YMD&lt;/code&gt; mode</source>
          <target state="translated">2003年1月2日、 &lt;code&gt;MDY&lt;/code&gt; モード。2003年2月1日、 &lt;code&gt;DMY&lt;/code&gt; モード。 &lt;code&gt;YMD&lt;/code&gt; モードの2001年2月3日</target>
        </trans-unit>
        <trans-unit id="397474e233d9068687b354fbdbc0b01176bcc2cc" translate="yes" xml:space="preserve">
          <source>January 8 in &lt;code&gt;MDY&lt;/code&gt; mode; August 1 in &lt;code&gt;DMY&lt;/code&gt; mode</source>
          <target state="translated">&lt;code&gt;MDY&lt;/code&gt; モードの1月8日。8月1日、 &lt;code&gt;DMY&lt;/code&gt; モード</target>
        </trans-unit>
        <trans-unit id="2391ee88b9183f9c31234260c9722e2d62c959b0" translate="yes" xml:space="preserve">
          <source>January 8 in &lt;code&gt;YMD&lt;/code&gt; mode, else error</source>
          <target state="translated">&lt;code&gt;YMD&lt;/code&gt; モードの1月8日、それ以外のエラー</target>
        </trans-unit>
        <trans-unit id="347ee622c39fd3015013d75c9106e7b8164231b7" translate="yes" xml:space="preserve">
          <source>January 8 in any mode</source>
          <target state="translated">どのモードでも1月8日</target>
        </trans-unit>
        <trans-unit id="682c812bf69e66e4c213bdbcc9a0930f43e82030" translate="yes" xml:space="preserve">
          <source>January 8, 1999</source>
          <target state="translated">1999年1月8日</target>
        </trans-unit>
        <trans-unit id="4444d015dc1b7e202a7ab992a769c820f60f9019" translate="yes" xml:space="preserve">
          <source>January 8, 99 BC</source>
          <target state="translated">紀元前99年1月8日</target>
        </trans-unit>
        <trans-unit id="07425bcd86481aaf19f3e5b4016da2c9f5e1cec4" translate="yes" xml:space="preserve">
          <source>January 8, except error in &lt;code&gt;YMD&lt;/code&gt; mode</source>
          <target state="translated">1月8日、 &lt;code&gt;YMD&lt;/code&gt; モードのエラーを除く</target>
        </trans-unit>
        <trans-unit id="9239c22d1d1c990ca8c206cb408b345a3ec8114c" translate="yes" xml:space="preserve">
          <source>Japanese</source>
          <target state="translated">Japanese</target>
        </trans-unit>
        <trans-unit id="21087b70eba36ef97c23b6fae1bc0502a8c7faff" translate="yes" xml:space="preserve">
          <source>Java Database Connectivity</source>
          <target state="translated">ジャワデータベース接続性</target>
        </trans-unit>
        <trans-unit id="94e850a9fa9f98700106bfba6b5849640ea65567" translate="yes" xml:space="preserve">
          <source>JavaScript Object Notation</source>
          <target state="translated">JavaScript オブジェクト記法</target>
        </trans-unit>
        <trans-unit id="66dc64282e7e424443c0ee036f6560a8429101fe" translate="yes" xml:space="preserve">
          <source>Jean-Luc Cooke Fortuna-based &lt;code&gt;/dev/random&lt;/code&gt; driver for Linux.</source>
          <target state="translated">Linux用のJean-Luc Cooke Fortunaベースの &lt;code&gt;/dev/random&lt;/code&gt; ドライバー。</target>
        </trans-unit>
        <trans-unit id="076e3b3dd165a68d5a1635c764f91d575d41e991" translate="yes" xml:space="preserve">
          <source>Joe Conway</source>
          <target state="translated">ジョー・コンウェイ</target>
        </trans-unit>
        <trans-unit id="36223c3c072f8f4857df7670837893beb8c9ab05" translate="yes" xml:space="preserve">
          <source>John Gray &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:jgray@azuli.co.uk&quot;&gt;jgray@azuli.co.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">ジョングレイ &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:jgray@azuli.co.uk&quot;&gt;jgray@azuli.co.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5253095e71e396147a5bb85865b313a4dfaabec4" translate="yes" xml:space="preserve">
          <source>Join queries of the kind seen thus far can also be written in this alternative form:</source>
          <target state="translated">これまでに見られた種類のジョインクエリは、この代替形式でも書くことができます。</target>
        </trans-unit>
        <trans-unit id="5d51427844afa7a67c043cae62a1e058c08bf8eb" translate="yes" xml:space="preserve">
          <source>Join selectivity estimation function for this operator</source>
          <target state="translated">この演算子の結合選択性推定関数</target>
        </trans-unit>
        <trans-unit id="60bbcdff104b8ef5971151f077f9a3a69bf41608" translate="yes" xml:space="preserve">
          <source>Joins of all types can be chained together, or nested: either or both &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; can be joined tables. Parentheses can be used around &lt;code&gt;JOIN&lt;/code&gt; clauses to control the join order. In the absence of parentheses, &lt;code&gt;JOIN&lt;/code&gt; clauses nest left-to-right.</source>
          <target state="translated">すべてのタイプの加入は、一緒に連鎖、または入れ子にすることができる。いずれかまたは両方 &lt;code&gt;T1&lt;/code&gt; と &lt;code&gt;T2&lt;/code&gt; は、テーブルを接合することができます。 &lt;code&gt;JOIN&lt;/code&gt; 句を括弧で囲んで、結合順序を制御できます。括弧がない場合、 &lt;code&gt;JOIN&lt;/code&gt; 句は左から右にネストします。</target>
        </trans-unit>
        <trans-unit id="b737558468d75ca55b2d9185c0b55eacaea627a0" translate="yes" xml:space="preserve">
          <source>Jul</source>
          <target state="translated">Jul</target>
        </trans-unit>
        <trans-unit id="a78c0406ce3eb63581cbacb7e7085ef4cbc36ad9" translate="yes" xml:space="preserve">
          <source>Julian Day (integer days since November 24, 4714 BC at midnight UTC)</source>
          <target state="translated">ユリウス日</target>
        </trans-unit>
        <trans-unit id="b597ea9fa797a2c2073652808359aeb10b763510" translate="yes" xml:space="preserve">
          <source>Julian date</source>
          <target state="translated">ユリウス日付</target>
        </trans-unit>
        <trans-unit id="df97a42549e5c0e1753b985126565531cc9f3c56" translate="yes" xml:space="preserve">
          <source>July</source>
          <target state="translated">July</target>
        </trans-unit>
        <trans-unit id="6d90df3be4d0d43b08e3fb47f55e09b5b06dae3e" translate="yes" xml:space="preserve">
          <source>Jun</source>
          <target state="translated">Jun</target>
        </trans-unit>
        <trans-unit id="a9db906761699b31567727716eaa6fd19ae5f5d5" translate="yes" xml:space="preserve">
          <source>June</source>
          <target state="translated">June</target>
        </trans-unit>
        <trans-unit id="7b1ddc607d5041d94adba7779845219a639a5e00" translate="yes" xml:space="preserve">
          <source>Just as in a non-parallel plan, the driving table may be joined to one or more other tables using a nested loop, hash join, or merge join. The inner side of the join may be any kind of non-parallel plan that is otherwise supported by the planner provided that it is safe to run within a parallel worker. Depending on the join type, the inner side may also be a parallel plan.</source>
          <target state="translated">非並列計画の場合と同様に、駆動テーブルは、入れ子ループ、ハッシュ結合、マージ結合を使用して、1つ以上の他のテーブルに結合することができます。ジョインの内側は、並列ワーカー内で実行しても安全であれば、プランナがサポートしている非並列プランであってもかまいません。ジョインのタイプによっては、内側が並列プランになることもあります。</target>
        </trans-unit>
        <trans-unit id="dce656c6d5efc6ceb90feb56120166673a499a99" translate="yes" xml:space="preserve">
          <source>Just as in a table, every output column of a &lt;code&gt;SELECT&lt;/code&gt; has a name. In a simple &lt;code&gt;SELECT&lt;/code&gt; this name is just used to label the column for display, but when the &lt;code&gt;SELECT&lt;/code&gt; is a sub-query of a larger query, the name is seen by the larger query as the column name of the virtual table produced by the sub-query. To specify the name to use for an output column, write &lt;code&gt;AS&lt;/code&gt;&lt;code&gt;output_name&lt;/code&gt; after the column's expression. (You can omit &lt;code&gt;AS&lt;/code&gt;, but only if the desired output name does not match any PostgreSQL keyword (see &lt;a href=&quot;sql-keywords-appendix&quot;&gt;Appendix C&lt;/a&gt;). For protection against possible future keyword additions, it is recommended that you always either write &lt;code&gt;AS&lt;/code&gt; or double-quote the output name.) If you do not specify a column name, a name is chosen automatically by PostgreSQL. If the column's expression is a simple column reference then the chosen name is the same as that column's name. In more complex cases a function or type name may be used, or the system may fall back on a generated name such as &lt;code&gt;?column?&lt;/code&gt;.</source>
          <target state="translated">テーブルと同じように、 &lt;code&gt;SELECT&lt;/code&gt; のすべての出力列には名前があります。単純な &lt;code&gt;SELECT&lt;/code&gt; では、この名前は表示用の列にラベルを付けるために使用されますが、 &lt;code&gt;SELECT&lt;/code&gt; がより大きなクエリのサブクエリである場合、その名前は、より大きなクエリによって、サブによって作成された仮想テーブルの列名として表示されます。 -query。出力列に使用する名前を指定するには、列の式の後に &lt;code&gt;AS&lt;/code&gt; &lt;code&gt;output_name&lt;/code&gt; を記述します。 （ &lt;code&gt;AS&lt;/code&gt; は省略できますが、必要な出力名がPostgreSQLキーワードに一致しない場合に限ります（&lt;a href=&quot;sql-keywords-appendix&quot;&gt;付録Cを&lt;/a&gt;参照）。将来のキーワードの追加を防ぐため、常に &lt;code&gt;AS&lt;/code&gt; を記述することをお勧めしますまたは出力名を二重引用符で囲みます。）列名を指定しない場合、名前はPostgreSQLによって自動的に選択されます。列の式が単純な列参照の場合、選択された名前はその列の名前と同じです。より複雑なケースでは、関数または型の名前が使用されるか、システムが &lt;code&gt;?column?&lt;/code&gt; などの生成された名前にフォールバックする場合があります。。</target>
        </trans-unit>
        <trans-unit id="643851cd97b3016db737a7445d565c8fa4d8baef" translate="yes" xml:space="preserve">
          <source>Just as with indexes, a foreign key constraint can be checked &amp;ldquo;in bulk&amp;rdquo; more efficiently than row-by-row. So it might be useful to drop foreign key constraints, load data, and re-create the constraints. Again, there is a trade-off between data load speed and loss of error checking while the constraint is missing.</source>
          <target state="translated">インデックスの場合と同様に、外部キー制約は、行単位よりも「一括」で効率的にチェックできます。したがって、外部キー制約を削除し、データをロードして、制約を再作成すると便利な場合があります。繰り返しになりますが、制約が欠落している間、データのロード速度とエラーチェックの喪失との間にはトレードオフがあります。</target>
        </trans-unit>
        <trans-unit id="22069315e577148c2b004f5dd6381d3b0deef8a4" translate="yes" xml:space="preserve">
          <source>Just-in-Time (JIT) compilation is the process of turning some form of interpreted program evaluation into a native program, and doing so at run time. For example, instead of using general-purpose code that can evaluate arbitrary SQL expressions to evaluate a particular SQL predicate like &lt;code&gt;WHERE a.col = 3&lt;/code&gt;, it is possible to generate a function that is specific to that expression and can be natively executed by the CPU, yielding a speedup.</source>
          <target state="translated">ジャストインタイム（JIT）コンパイルは、何らかの形式の解釈済みプログラム評価をネイティブプログラムに変換し、実行時に実行するプロセスです。たとえば、任意のSQL式を評価できる汎用コードを使用して &lt;code&gt;WHERE a.col = 3&lt;/code&gt; ような特定のSQL述語を評価する代わりに、その式に固有で関数によってネイティブに実行できる関数を生成できます。 CPU、スピードアップをもたらします。</target>
        </trans-unit>
        <trans-unit id="7af7e7edb636e51ba6b7f08c539611e4a0057634" translate="yes" xml:space="preserve">
          <source>Just-in-Time Compilation (JIT)</source>
          <target state="translated">ジャストインタイムコンパイル(JIT)</target>
        </trans-unit>
        <trans-unit id="299af5e109b0aae56134447e7dc2dcce5de37f34" translate="yes" xml:space="preserve">
          <source>Just-in-Time compilation</source>
          <target state="translated">ジャストインタイムコンパイル</target>
        </trans-unit>
        <trans-unit id="ffa7300d92e16f73d505ed4698fdd4e962ca51c4" translate="yes" xml:space="preserve">
          <source>KAME kame/sys/crypto</source>
          <target state="translated">KAME kame/sys/crypto</target>
        </trans-unit>
        <trans-unit id="6b88dae842421fa69ad059376e38f360417c6965" translate="yes" xml:space="preserve">
          <source>KOI8-R</source>
          <target state="translated">KOI8-R</target>
        </trans-unit>
        <trans-unit id="ad190609bef1a0712934b8949ffb7c06fbaa6862" translate="yes" xml:space="preserve">
          <source>KOI8-U</source>
          <target state="translated">KOI8-U</target>
        </trans-unit>
        <trans-unit id="8f29952f92109ac24c1d37762ea2beef09083c31" translate="yes" xml:space="preserve">
          <source>KaiGai Kohei &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:kaigai@ak.jp.nec.com&quot;&gt;kaigai@ak.jp.nec.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">KaiGai Kohei &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:kaigai@ak.jp.nec.com&quot;&gt;kaigai@ak.jp.nec.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0cd084d348b2278c1d6044754c142d3183367365" translate="yes" xml:space="preserve">
          <source>Keep in mind that all aggregate functions are evaluated before evaluating any &amp;ldquo;scalar&amp;rdquo; expressions in the &lt;code&gt;HAVING&lt;/code&gt; clause or &lt;code&gt;SELECT&lt;/code&gt; list. This means that, for example, a &lt;code&gt;CASE&lt;/code&gt; expression cannot be used to skip evaluation of an aggregate function; see &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;HAVING&lt;/code&gt; 句または &lt;code&gt;SELECT&lt;/code&gt; リスト内の「スカラー」式を評価する前に、すべての集約関数が評価されることに注意してください。つまり、たとえば、 &lt;code&gt;CASE&lt;/code&gt; 式を使用して集計関数の評価をスキップすることはできません。&lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;セクション4.2.14を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a262b9c7138e1926e93240d562f76b55145fd596" translate="yes" xml:space="preserve">
          <source>Keep in mind that because &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; actually runs the query, any side-effects will happen as usual, even though whatever results the query might output are discarded in favor of printing the &lt;code&gt;EXPLAIN&lt;/code&gt; data. If you want to analyze a data-modifying query without changing your tables, you can roll the command back afterwards, for example:</source>
          <target state="translated">&lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; が実際にクエリを実行するため、クエリが出力する可能性のある結果がすべて破棄されて &lt;code&gt;EXPLAIN&lt;/code&gt; データが出力される場合でも、副作用は通常どおり発生します。テーブルを変更せずにデータ変更クエリを分析する場合は、後でコマンドをロールバックできます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="66b96c146884aa3a6a00a301b320c6680d6f4464" translate="yes" xml:space="preserve">
          <source>Keep in mind that by default, a regular expression can match just part of a string. It's usually wise to use &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt;, as shown in the above example, to force the match to be to the entire system user name.</source>
          <target state="translated">デフォルトでは、正規表現は文字列の一部にのみ一致することに注意してください。上記の例に示すように、通常は &lt;code&gt;^&lt;/code&gt; と &lt;code&gt;$&lt;/code&gt; を使用して、システムのユーザー名全体との一致を強制するのが賢明です。</target>
        </trans-unit>
        <trans-unit id="c42b9dd519f94f2582e4a71f3f708e12c5a9653d" translate="yes" xml:space="preserve">
          <source>Keep in mind that it is important to specify the configuration name explicitly when creating &lt;code&gt;tsvector&lt;/code&gt; values inside triggers, so that the column's contents will not be affected by changes to &lt;code&gt;default_text_search_config&lt;/code&gt;. Failure to do this is likely to lead to problems such as search results changing after a dump and reload.</source>
          <target state="translated">トリガー内に &lt;code&gt;tsvector&lt;/code&gt; 値を作成するときは、構成名を明示的に指定して、列の内容が &lt;code&gt;default_text_search_config&lt;/code&gt; への変更の影響を受けないようにすることが重要です。これを怠ると、ダンプとリロード後に検索結果が変わるなどの問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f3ea22672b214f2b49222df5e8cffc5ea2a095eb" translate="yes" xml:space="preserve">
          <source>Keep in mind that setting up a partial index indicates that you know at least as much as the query planner knows, in particular you know when an index might be profitable. Forming this knowledge requires experience and understanding of how indexes in PostgreSQL work. In most cases, the advantage of a partial index over a regular index will be minimal.</source>
          <target state="translated">部分的なインデックスを設定するということは、少なくとも問い合わせプランナが知っていることと同じくらいのことを知っていることを意味します。この知識を身につけるには、PostgreSQLのインデックスがどのように動作するかについての経験と理解が必要です。ほとんどの場合、通常のインデックスよりも部分インデックスの方が有利なことはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="ef88fc4a4ab28c6433ccdb43fa109f84e6bdf441" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;hstore&lt;/code&gt; text format, when used for input, applies &lt;em&gt;before&lt;/em&gt; any required quoting or escaping. If you are passing an &lt;code&gt;hstore&lt;/code&gt; literal via a parameter, then no additional processing is needed. But if you're passing it as a quoted literal constant, then any single-quote characters and (depending on the setting of the &lt;code&gt;standard_conforming_strings&lt;/code&gt; configuration parameter) backslash characters need to be escaped correctly. See &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt; for more on the handling of string constants.</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; テキスト形式は、入力に使用さ&lt;em&gt;れる&lt;/em&gt;場合、必要な引用やエスケープの&lt;em&gt;前&lt;/em&gt;に適用されることに注意してください。パラメーターを介して &lt;code&gt;hstore&lt;/code&gt; リテラルを渡す場合、追加の処理は必要ありません。ただし、引用符で囲まれたリテラル定数として渡す場合は、単一引用符文字と（ &lt;code&gt;standard_conforming_strings&lt;/code&gt; 構成パラメーターの設定に応じて）バックスラッシュ文字を正しくエスケープする必要があります。文字列定数の処理の詳細については、&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;セクション4.1.2.1&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3f96958d65d9c021639ce27dbbdb3f614f469552" translate="yes" xml:space="preserve">
          <source>Keep in mind that the delay parameters are compared to the elapsed time since the WAL data was received by the standby server. Thus, the grace period allowed to any one query on the standby is never more than the delay parameter, and could be considerably less if the standby has already fallen behind as a result of waiting for previous queries to complete, or as a result of being unable to keep up with a heavy update load.</source>
          <target state="translated">遅延パラメータは、スタンバイサーバがWALデータを受信してからの経過時間と比較されることに注意してください。したがって、スタンバイ上の1つのクエリに許可される猶予期間は、遅延パラメータを超えることはなく、前のクエリが完了するのを待った結果、スタンバイがすでに遅れている場合や、重い更新負荷に追いつけなくなった結果、大幅に短くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="281e2d1f4654cd490bed6ab58e757285785a6b63" translate="yes" xml:space="preserve">
          <source>Keep in mind that the pattern argument of &lt;code&gt;like_regex&lt;/code&gt; is a JSON path string literal, written according to the rules given in &lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;Section 8.14.6&lt;/a&gt;. This means in particular that any backslashes you want to use in the regular expression must be doubled. For example, to match strings that contain only digits:</source>
          <target state="translated">&lt;code&gt;like_regex&lt;/code&gt; のパターン引数は、&lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;セクション8.14.6&lt;/a&gt;に記載されているルールに従って記述されたJSONパス文字列リテラルであることを覚えておいてください。これは特に、正規表現で使用したいバックスラッシュは二重にする必要があることを意味します。たとえば、数字のみを含む文字列を照合するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="752b636fa6947f13347177c43e220a338c0e1d06" translate="yes" xml:space="preserve">
          <source>Keep in mind that the statement is actually executed when the &lt;code&gt;ANALYZE&lt;/code&gt; option is used. Although &lt;code&gt;EXPLAIN&lt;/code&gt; will discard any output that a &lt;code&gt;SELECT&lt;/code&gt; would return, other side effects of the statement will happen as usual. If you wish to use &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; on an &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;CREATE TABLE AS&lt;/code&gt;, or &lt;code&gt;EXECUTE&lt;/code&gt; statement without letting the command affect your data, use this approach:</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; オプションを使用すると、ステートメントが実際に実行されることに注意してください。が &lt;code&gt;EXPLAIN&lt;/code&gt; ことを任意の出力破棄します &lt;code&gt;SELECT&lt;/code&gt; が戻ってくると、文の他の副作用は通常通り発生します。コマンドがデータに影響を与えずに、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、 &lt;code&gt;CREATE TABLE AS&lt;/code&gt; 、または &lt;code&gt;EXECUTE&lt;/code&gt; ステートメントで &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; を使用する場合は、次のアプローチを使用します。</target>
        </trans-unit>
        <trans-unit id="1a83b7d50233b6c01f2847bb1d523d1444438ed5" translate="yes" xml:space="preserve">
          <source>Keep the default. All users access the public schema implicitly. This simulates the situation where schemas are not available at all, giving a smooth transition from the non-schema-aware world. However, any user can issue arbitrary queries under the identity of any user not electing to protect itself individually. This pattern is acceptable only when the database has a single user or a few mutually-trusting users.</source>
          <target state="translated">デフォルトのままにします。すべてのユーザが暗黙のうちに公開スキーマにアクセスします。これにより、スキーマが全く利用できない状況をシミュレートし、スキーマを認識しない世界からのスムーズな移行を実現します。しかし、任意のユーザーは、自分自身を個別に保護することを選択していないユーザーのアイデンティティの下で、任意のクエリを発行することができます。このパターンは、データベースが単一のユーザまたは数人の相互に信頼できるユーザを持っている場合にのみ許容されます。</target>
        </trans-unit>
        <trans-unit id="01c357ee3905e2cb6c0488939e3efd4649d18496" translate="yes" xml:space="preserve">
          <source>Keep the partitioning constraints simple, else the planner may not be able to prove that child tables might not need to be visited. Use simple equality conditions for list partitioning, or simple range tests for range partitioning, as illustrated in the preceding examples. A good rule of thumb is that partitioning constraints should contain only comparisons of the partitioning column(s) to constants using B-tree-indexable operators, because only B-tree-indexable column(s) are allowed in the partition key.</source>
          <target state="translated">パーティショニングの制約を単純にしておかないと、プランナは子テーブルを訪問する必要がないかもしれないことを証明できないかもしれません。リスト・パーティショニングには単純な等質条件を使用し、範囲パーティショニングには単純な範囲テストを使用してください。経験則として、パーティショニング制約は、B-treeインデックス可能な演算子を使用した定数とパーティショニング列の比較のみを含むべきです。</target>
        </trans-unit>
        <trans-unit id="e2032a298b60ea58db844215a572d895ea523039" translate="yes" xml:space="preserve">
          <source>Kernels can also have system-wide limits on some resources.</source>
          <target state="translated">カーネルは、いくつかのリソースに対してシステム全体の制限を設けることもできます。</target>
        </trans-unit>
        <trans-unit id="59dfe7e6cfc40d95e215dd77804938b17f6c9f40" translate="yes" xml:space="preserve">
          <source>Key Word</source>
          <target state="translated">キーワード</target>
        </trans-unit>
        <trans-unit id="8e27223f630d5f11e0e66ca4d82327af33bd02f7" translate="yes" xml:space="preserve">
          <source>Key value of the row to start at</source>
          <target state="translated">開始する行のキー値</target>
        </trans-unit>
        <trans-unit id="fa701570481252ff476a0ecf4e2d51ece76ebca1" translate="yes" xml:space="preserve">
          <source>Key words and unquoted identifiers are case insensitive. Therefore:</source>
          <target state="translated">キーワードや引用符で囲まれていない識別子は大文字小文字を区別しません。したがって</target>
        </trans-unit>
        <trans-unit id="dec66c5bf0f7fe4cc038ac871def8eb1ac31c146" translate="yes" xml:space="preserve">
          <source>Korean</source>
          <target state="translated">Korean</target>
        </trans-unit>
        <trans-unit id="2ceaa9727ea6aa546bde8ab43842a8c79efd8f8d" translate="yes" xml:space="preserve">
          <source>Korean (Hangul)</source>
          <target state="translated">ハングル</target>
        </trans-unit>
        <trans-unit id="2bfe4366aec039158c13cdff560c53552a6ab2f8" translate="yes" xml:space="preserve">
          <source>LATIN1 with Euro and accents</source>
          <target state="translated">ユーロとアクセントのあるLATIN1</target>
        </trans-unit>
        <trans-unit id="a3f57123a6c2ff10f831d7d1652f96a64aa8ede6" translate="yes" xml:space="preserve">
          <source>LC_COLLATE for this database</source>
          <target state="translated">このデータベースのLC_COLLATE</target>
        </trans-unit>
        <trans-unit id="ccd2341e80cefe881c6b471888b83c35d3eedb65" translate="yes" xml:space="preserve">
          <source>LC_CTYPE for this database</source>
          <target state="translated">このデータベースの LC_CTYPE</target>
        </trans-unit>
        <trans-unit id="d8343c683ae1584c96390fa627005bc1bb0719cd" translate="yes" xml:space="preserve">
          <source>LDAP</source>
          <target state="translated">LDAP</target>
        </trans-unit>
        <trans-unit id="d11fef55a0f4f7f77f5a743808a9e2af4cfab644" translate="yes" xml:space="preserve">
          <source>LDAP Authentication</source>
          <target state="translated">LDAP認証</target>
        </trans-unit>
        <trans-unit id="3af0c4862ddb95641f4519deb20c9bd92b5a696b" translate="yes" xml:space="preserve">
          <source>LDAP URLs are currently only supported with OpenLDAP, not on Windows.</source>
          <target state="translated">LDAP URL は現在のところ OpenLDAP でのみサポートされており、Windows ではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="a78f006babbca44fb715e5663d9cdd5f718dd110" translate="yes" xml:space="preserve">
          <source>LDAP authentication can operate in two modes. In the first mode, which we will call the simple bind mode, the server will bind to the distinguished name constructed as &lt;code&gt;prefix&lt;/code&gt;&lt;code&gt;username&lt;/code&gt;&lt;code&gt;suffix&lt;/code&gt;. Typically, the &lt;code&gt;prefix&lt;/code&gt; parameter is used to specify &lt;code&gt;cn=&lt;/code&gt;, or &lt;code&gt;DOMAIN&lt;/code&gt;&lt;code&gt;\&lt;/code&gt; in an Active Directory environment. &lt;code&gt;suffix&lt;/code&gt; is used to specify the remaining part of the DN in a non-Active Directory environment.</source>
          <target state="translated">LDAP認証は2つのモードで動作できます。シンプルバインドモードと呼ばれる最初のモードでは、サーバーは、 &lt;code&gt;prefix&lt;/code&gt; &lt;code&gt;username&lt;/code&gt; &lt;code&gt;suffix&lt;/code&gt; として構築された識別名にバインドします。通常、 &lt;code&gt;prefix&lt;/code&gt; パラメータは、Active Directory環境で &lt;code&gt;cn=&lt;/code&gt; または &lt;code&gt;DOMAIN&lt;/code&gt; &lt;code&gt;\&lt;/code&gt; を指定するために使用されます。 &lt;code&gt;suffix&lt;/code&gt; は、非Active Directory環境でDNの残りの部分を指定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="9bd1b0f9c2859218ce1180337a2bd66b96113b2f" translate="yes" xml:space="preserve">
          <source>LIMIT and OFFSET</source>
          <target state="translated">リミットとオフセット</target>
        </trans-unit>
        <trans-unit id="9c6023564f6507b3ea5cad8e472da23961b9afbb" translate="yes" xml:space="preserve">
          <source>LISTEN</source>
          <target state="translated">LISTEN</target>
        </trans-unit>
        <trans-unit id="9814f182fea16d601141a37a9089918cd74f5452" translate="yes" xml:space="preserve">
          <source>LISTEN &amp;mdash; listen for a notification</source>
          <target state="translated">LISTEN &amp;mdash;通知を聞く</target>
        </trans-unit>
        <trans-unit id="8d0c622ff5ca1933ba98627381a4a7d1db679d31" translate="yes" xml:space="preserve">
          <source>LLVM has support for optimizing generated code. Some of the optimizations are cheap enough to be performed whenever JIT is used, while others are only beneficial for longer-running queries. See &lt;a href=&quot;https://llvm.org/docs/Passes.html#transform-passes&quot;&gt;https://llvm.org/docs/Passes.html#transform-passes&lt;/a&gt; for more details about optimizations.</source>
          <target state="translated">LLVMは、生成されたコードの最適化をサポートしています。最適化の中には、JITを使用するたびに実行できるほど安価なものもあれば、実行時間の長いクエリにのみ有益なものもあります。最適化の詳細については、&lt;a href=&quot;https://llvm.org/docs/Passes.html#transform-passes&quot;&gt;https：//llvm.org/docs/Passes.html#transform-passes&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="97eb8c80f7fd9d9f6120c3bffd79e5e23e575196" translate="yes" xml:space="preserve">
          <source>LOAD</source>
          <target state="translated">LOAD</target>
        </trans-unit>
        <trans-unit id="ca2a082afa739ad45f7209a3186244665643f398" translate="yes" xml:space="preserve">
          <source>LOAD &amp;mdash; load a shared library file</source>
          <target state="translated">LOAD &amp;mdash;共有ライブラリファイルをロードする</target>
        </trans-unit>
        <trans-unit id="c37eb4cb935a6017aaaaaab327837c7d9bbbc004" translate="yes" xml:space="preserve">
          <source>LOCK</source>
          <target state="translated">LOCK</target>
        </trans-unit>
        <trans-unit id="92d4fa824b1bf5ae650f5b90867eff13a3a5fe0a" translate="yes" xml:space="preserve">
          <source>LOCK &amp;mdash; lock a table</source>
          <target state="translated">LOCK &amp;mdash;テーブルをロックする</target>
        </trans-unit>
        <trans-unit id="6b4bea52cbee20f8507b76217f199114a117089e" translate="yes" xml:space="preserve">
          <source>LSN</source>
          <target state="translated">LSN</target>
        </trans-unit>
        <trans-unit id="d1fca76fb082d22a2d8e514d1b3ce5e3ce9aa851" translate="yes" xml:space="preserve">
          <source>LSN: next byte after last byte of WAL record for last change to this page</source>
          <target state="translated">LSN:このページへの最後の変更のためのWALレコードの最後のバイトの次のバイト</target>
        </trans-unit>
        <trans-unit id="f7d6ac021994cd293b3c94c2f6248d32ae9579b5" translate="yes" xml:space="preserve">
          <source>Lag times work automatically for physical replication. Logical decoding plugins may optionally emit tracking messages; if they do not, the tracking mechanism will simply display NULL lag.</source>
          <target state="translated">遅延時間は物理的なレプリケーションでは自動的に動作します。論理デコードプラグインはオプションでトラッキングメッセージを出力することができますが、出力しない場合、トラッキングメカニズムは単にNULLラグを表示します。</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="5e9465d239944a0fa40232e75aff84b43ba97385" translate="yes" xml:space="preserve">
          <source>Language of messages</source>
          <target state="translated">メッセージの言語</target>
        </trans-unit>
        <trans-unit id="ce146ba97ccf4a9eb00c4f7b7284970bf1503949" translate="yes" xml:space="preserve">
          <source>Large objects (see &lt;a href=&quot;https://www.postgresql.org/docs/12/largeobjects.html&quot;&gt;Chapter 34&lt;/a&gt;) are not replicated. There is no workaround for that, other than storing data in normal tables.</source>
          <target state="translated">ラージオブジェクト（&lt;a href=&quot;https://www.postgresql.org/docs/12/largeobjects.html&quot;&gt;第34章を&lt;/a&gt;参照）は複製されません。通常のテーブルにデータを保存する以外に、その回避策はありません。</target>
        </trans-unit>
        <trans-unit id="a24b3c46d4ed7dfe7397ec67ef490f12c7f2d62a" translate="yes" xml:space="preserve">
          <source>Last system OID in the database; useful particularly to pg_dump</source>
          <target state="translated">データベース内の最後のシステムOID。</target>
        </trans-unit>
        <trans-unit id="d8a8330f47a1d2121f7de4d246b07c539d85b887" translate="yes" xml:space="preserve">
          <source>Last time at which this table was analyzed by the autovacuum daemon</source>
          <target state="translated">このテーブルが自動バキュームデーモンによって解析された最後の時刻</target>
        </trans-unit>
        <trans-unit id="b5daedfbaeb26dce099e49150d7deba8ed7dd63c" translate="yes" xml:space="preserve">
          <source>Last time at which this table was manually analyzed</source>
          <target state="translated">このテーブルが手動で分析された最後の時間</target>
        </trans-unit>
        <trans-unit id="d21dc8edf16ccb5721e0bc05e599292ce8cd64c2" translate="yes" xml:space="preserve">
          <source>Last time at which this table was manually vacuumed (not counting &lt;code&gt;VACUUM FULL&lt;/code&gt;)</source>
          <target state="translated">このテーブルが手動でバキュームされた最後の時間（ &lt;code&gt;VACUUM FULL&lt;/code&gt; はカウントされません）</target>
        </trans-unit>
        <trans-unit id="32d602dc6c753beae99504e742b35637bae47172" translate="yes" xml:space="preserve">
          <source>Last time at which this table was vacuumed by the autovacuum daemon</source>
          <target state="translated">このテーブルが自動バキュームデーモンによってバキュームされた最後の時間</target>
        </trans-unit>
        <trans-unit id="a6160372ad225c352ec7ffd4f36cad1f43f752fb" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location already received and flushed to disk, the initial value of this field being the first log location used when WAL receiver is started</source>
          <target state="translated">最後に受信し、ディスクにフラッシュされた書込み先のログの位置で、このフィールドの初期値は WAL 受信機の起動時に最初に使用されるログの位置となる。</target>
        </trans-unit>
        <trans-unit id="6dd26aafa1fbdf96a846556c081c9e292557ed50" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location flushed to disk by this standby server</source>
          <target state="translated">このスタンバイ・サーバがディスクにフラッシュした最後の書き込み優先ログの場所</target>
        </trans-unit>
        <trans-unit id="3196ac97aabe6b93efdbd9d951f27185a4510ea9" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location received, the initial value of this field being 0</source>
          <target state="translated">最後に受信した書込み先のログの位置、このフィールドの初期値は0です。</target>
        </trans-unit>
        <trans-unit id="7fce43ad04e1c6ea844b5017a38c520afa802611" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location replayed into the database on this standby server</source>
          <target state="translated">最後に書き込まれたログの場所を、このスタンバイ・サーバのデータベースに再生します。</target>
        </trans-unit>
        <trans-unit id="0d3835b7f40d0e6e66b1e74e7de916b14d4f990d" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location reported to origin WAL sender</source>
          <target state="translated">送信元のWAL送信者に報告された最後の書込み先ログの場所</target>
        </trans-unit>
        <trans-unit id="ac1ae56d16c8b53cb449a2ee572fbfc684cbf5dd" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location sent on this connection</source>
          <target state="translated">この接続で送信された最後の書込み先ログの場所</target>
        </trans-unit>
        <trans-unit id="bafcffd5bbf934c91f7d04975d6317a745ba4820" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location written to disk by this standby server</source>
          <target state="translated">この待機サーバがディスクに書き込んだ最後の書込み先ログの場所</target>
        </trans-unit>
        <trans-unit id="ba538f112903a51c4fdd1a1494e1875649a225bb" translate="yes" xml:space="preserve">
          <source>Latin/Arabic</source>
          <target state="translated">Latin/Arabic</target>
        </trans-unit>
        <trans-unit id="fd84929c694afd8b1b6d7503f4f8e1b23aed9285" translate="yes" xml:space="preserve">
          <source>Latin/Cyrillic</source>
          <target state="translated">Latin/Cyrillic</target>
        </trans-unit>
        <trans-unit id="e688538b3f17f5cc30931971a729f9f8fe4c1bdd" translate="yes" xml:space="preserve">
          <source>Latin/Greek</source>
          <target state="translated">Latin/Greek</target>
        </trans-unit>
        <trans-unit id="daa3f6da7a3a4e4229771dc7d3d5e346a4582850" translate="yes" xml:space="preserve">
          <source>Latin/Hebrew</source>
          <target state="translated">Latin/Hebrew</target>
        </trans-unit>
        <trans-unit id="d494f73e6e88daa7f95e93345a91fc4c8dc4fb69" translate="yes" xml:space="preserve">
          <source>Launch the main autoprewarm worker. This will normally happen automatically, but is useful if automatic prewarm was not configured at server startup time and you wish to start up the worker at a later time.</source>
          <target state="translated">メインのautoprewarmワーカーを起動します。これは通常は自動的に行われますが、サーバー起動時に自動プリウォームが設定されておらず、後でワーカーを起動したい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="2c4136854685f9259aab343bbd1cc7a50348e3a5" translate="yes" xml:space="preserve">
          <source>Leaf page fragmentation</source>
          <target state="translated">リーフページの断片化</target>
        </trans-unit>
        <trans-unit id="5f877225069b04b69ebc49ed1c8ffc9db5e722b5" translate="yes" xml:space="preserve">
          <source>Leaf tuples of an SP-GiST tree contain values of the same data type as the indexed column. Leaf tuples at the root level will always contain the original indexed data value, but leaf tuples at lower levels might contain only a compressed representation, such as a suffix. In that case the operator class support functions must be able to reconstruct the original value using information accumulated from the inner tuples that are passed through to reach the leaf level.</source>
          <target state="translated">SP-GISTツリーのリーフタプルには、インデックス化された列と同じデータ型の値が含まれます。ルートレベルのリーフタプルは常に元のインデックス付きデータ値を含みますが、下位レベルのリーフタプルはサフィックスのような圧縮された表現のみを含む場合があります。その場合、演算子クラスのサポート関数は、リーフレベルに到達するために渡される内部タプルから蓄積された情報を使用して元の値を再構築することができなければなりません。</target>
        </trans-unit>
        <trans-unit id="9299c2aba089dc4590aa8606b111db26dae4554a" translate="yes" xml:space="preserve">
          <source>Left-hand input data type of associated operator</source>
          <target state="translated">関連演算子の左入力データ型</target>
        </trans-unit>
        <trans-unit id="ed906ae901de1e3195028f0570c5ad60b2810880" translate="yes" xml:space="preserve">
          <source>Left-hand input data type of operator</source>
          <target state="translated">演算子の左入力データ型</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="d8b851cee953f8d81c31ec69468e0ec20c2888c1" translate="yes" xml:space="preserve">
          <source>Length of aggregation interval (in seconds). May be used only with &lt;code&gt;-l&lt;/code&gt; option. With this option, the log contains per-interval summary data, as described below.</source>
          <target state="translated">集約間隔の長さ（秒単位）。 &lt;code&gt;-l&lt;/code&gt; オプションとのみ使用できます。このオプションを使用すると、以下に説明するように、ログには間隔ごとの要約データが含まれます。</target>
        </trans-unit>
        <trans-unit id="af6b0587a83fcd51886d616d3a32f3398d01980f" translate="yes" xml:space="preserve">
          <source>Length of binary string</source>
          <target state="translated">2進数文字列の長さ</target>
        </trans-unit>
        <trans-unit id="ccfe4a6f325c29c147887556a7714e5ddcdfe308" translate="yes" xml:space="preserve">
          <source>Length of each signature (index entry) in bits. It is rounded up to the nearest multiple of &lt;code&gt;16&lt;/code&gt;. The default is &lt;code&gt;80&lt;/code&gt; bits and the maximum is &lt;code&gt;4096&lt;/code&gt;.</source>
          <target state="translated">各署名（インデックスエントリ）の長さ（ビット単位）。最も近い &lt;code&gt;16&lt;/code&gt; の倍数に切り上げられます。デフォルトは &lt;code&gt;80&lt;/code&gt; ビットで、最大は &lt;code&gt;4096&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="12d4a8b76c20bac65c1a5a078f5f7a8e333266b4" translate="yes" xml:space="preserve">
          <source>Length or circumference</source>
          <target state="translated">長さまたは周囲</target>
        </trans-unit>
        <trans-unit id="9d6ed670f3c04a36b7689b66ca5b25c4d52af652" translate="yes" xml:space="preserve">
          <source>Less likely to cause problems is the minimum size for shared memory segments (&lt;code&gt;SHMMIN&lt;/code&gt;), which should be at most approximately 32 bytes for PostgreSQL (it is usually just 1). The maximum number of segments system-wide (&lt;code&gt;SHMMNI&lt;/code&gt;) or per-process (&lt;code&gt;SHMSEG&lt;/code&gt;) are unlikely to cause a problem unless your system has them set to zero.</source>
          <target state="translated">問題が発生する可能性が低いのは、共有メモリセグメントの最小サイズ（ &lt;code&gt;SHMMIN&lt;/code&gt; ）です。これは、PostgreSQLの場合は最大で約32バイト（通常は1）です。システム全体でセグメントの最大数（ &lt;code&gt;SHMMNI&lt;/code&gt; ）またはプロセスごと（ &lt;code&gt;SHMSEG&lt;/code&gt; ）の最大数は、システムでゼロに設定されていない限り、問題を引き起こす可能性は低いです。</target>
        </trans-unit>
        <trans-unit id="1d3d412a0852cc56c28ad0c2a1153229aa365b43" translate="yes" xml:space="preserve">
          <source>Less than</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f01a7dce204970734b2b2a327ee36987199e47f" translate="yes" xml:space="preserve">
          <source>Less-than operator</source>
          <target state="translated">オペレーター未満</target>
        </trans-unit>
        <trans-unit id="4576a6bc031e504cf481eb0d13f776e9d54832eb" translate="yes" xml:space="preserve">
          <source>Less-than-or-equal-to operator</source>
          <target state="translated">劣等演算子</target>
        </trans-unit>
        <trans-unit id="0ab7950f1f29b3334f76dd244ef5a7ba783b1b7f" translate="yes" xml:space="preserve">
          <source>Let's also assume you have a table storing orders of those products. We want to ensure that the orders table only contains orders of products that actually exist. So we define a foreign key constraint in the orders table that references the products table:</source>
          <target state="translated">また、これらの商品の注文を保存するテーブルがあるとします。注文テーブルには、実際に存在する製品の注文のみが含まれていることを確認したいとします。そこで、商品テーブルを参照する注文テーブルに外部キー制約を定義します。</target>
        </trans-unit>
        <trans-unit id="4bb0a1a761abe6883839cec3e71ca469d8a65b69" translate="yes" xml:space="preserve">
          <source>Let's assume you have filled the table with data and want to take a look at it:</source>
          <target state="translated">テーブルにデータを埋めたと仮定して、それを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="6bb447a9045c7cc0d5a93bdb00100d8f10c020e2" translate="yes" xml:space="preserve">
          <source>Let's consider a real-life astronomical example. We'll expand query &lt;code&gt;supernovae&lt;/code&gt; using table-driven rewriting rules:</source>
          <target state="translated">実際の天文学の例を考えてみましょう。テーブル駆動型の書き換えルールを使用して、クエリ &lt;code&gt;supernovae&lt;/code&gt; を拡張します。</target>
        </trans-unit>
        <trans-unit id="3450ae90635f5fd80bf01d11b0586d3e5b336518" translate="yes" xml:space="preserve">
          <source>Let's create two tables: A table &lt;code&gt;cities&lt;/code&gt; and a table &lt;code&gt;capitals&lt;/code&gt;. Naturally, capitals are also cities, so you want some way to show the capitals implicitly when you list all cities. If you're really clever you might invent some scheme like this:</source>
          <target state="translated">2つのテーブルを作成してみましょう。テーブルの &lt;code&gt;cities&lt;/code&gt; とテーブルの &lt;code&gt;capitals&lt;/code&gt; です。当然、首都は都市でもあるため、すべての都市をリストするときに暗黙的に首都を表示する方法が必要です。あなたが本当に賢いなら、あなたはこのようないくつかのスキームを発明するかもしれません：</target>
        </trans-unit>
        <trans-unit id="002106d5520b7ff0cea15ef411a279196063cbfa" translate="yes" xml:space="preserve">
          <source>Let's look at that command in detail. First is the key word &lt;code&gt;UPDATE&lt;/code&gt; followed by the table name. As usual, the table name can be schema-qualified, otherwise it is looked up in the path. Next is the key word &lt;code&gt;SET&lt;/code&gt; followed by the column name, an equal sign, and the new column value. The new column value can be any scalar expression, not just a constant. For example, if you want to raise the price of all products by 10% you could use:</source>
          <target state="translated">そのコマンドを詳しく見てみましょう。最初はキーワード &lt;code&gt;UPDATE&lt;/code&gt; で、その後にテーブル名が続きます。いつものように、テーブル名はスキーマで修飾できますが、そうでない場合はパスで検索されます。次はキーワード &lt;code&gt;SET&lt;/code&gt; で、その後に列名、等号、新しい列値が続きます。新しい列の値には、定数だけでなく、任意のスカラー式を使用できます。たとえば、すべての製品の価格を10％引き上げたい場合は、次のように使用できます。</target>
        </trans-unit>
        <trans-unit id="66b99b3611a0c2fdc7f95a1799fb3492cd67f4e6" translate="yes" xml:space="preserve">
          <source>Let's look at the query from &lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;Section 70.2.1&lt;/a&gt; again, but this time with a MCV list created on the same set of columns (be sure to drop the functional dependencies, to make sure the planner uses the newly created statistics).</source>
          <target state="translated">&lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;セクション70.2.1&lt;/a&gt;のクエリをもう一度見てみましょう。ただし、今回は同じ列のセットに作成されたMCVリストを使用します（機能の依存関係を削除して、プランナが新しく作成された統計を使用していることを確認してください）。</target>
        </trans-unit>
        <trans-unit id="1612ac24f2069dd66f65838fc7336fa0b28c41cb" translate="yes" xml:space="preserve">
          <source>Let's move on to an example with a range condition in its &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 句に範囲条件を含む例に進みましょう。</target>
        </trans-unit>
        <trans-unit id="e33f516fc6df811ac7dea3c6a71c77e25ecd5519" translate="yes" xml:space="preserve">
          <source>Let's start with a very simple query:</source>
          <target state="translated">まずはとても簡単なクエリから始めてみましょう。</target>
        </trans-unit>
        <trans-unit id="944a02000a7cd912b7786576975c692505293e37" translate="yes" xml:space="preserve">
          <source>Let's start with an example: suppose we are trying to build a data model for cities. Each state has many cities, but only one capital. We want to be able to quickly retrieve the capital city for any particular state. This can be done by creating two tables, one for state capitals and one for cities that are not capitals. However, what happens when we want to ask for data about a city, regardless of whether it is a capital or not? The inheritance feature can help to resolve this problem. We define the &lt;code&gt;capitals&lt;/code&gt; table so that it inherits from &lt;code&gt;cities&lt;/code&gt;:</source>
          <target state="translated">例から始めましょう。都市のデータモデルを構築しようとしていると仮定します。各州には多くの都市がありますが、首都は1つだけです。特定の州の首都をすばやく検索できるようにしたいと考えています。これは、2つのテーブルを作成することで実行できます。1つは州都、もう1つは首都ではない都市用です。しかし、都市であるかどうかに関係なく、都市に関するデータを要求したい場合はどうなりますか？継承機能は、この問題の解決に役立ちます。 &lt;code&gt;cities&lt;/code&gt; から継承するように、 &lt;code&gt;capitals&lt;/code&gt; 表を定義します。</target>
        </trans-unit>
        <trans-unit id="8936905c2cce98cf23701c4834f7f639d90f7b6d" translate="yes" xml:space="preserve">
          <source>Let's try joining two tables, using the columns we have been discussing:</source>
          <target state="translated">これまで説明してきたカラムを使って、2つのテーブルを結合してみましょう。</target>
        </trans-unit>
        <trans-unit id="fc56b91f6d327225a18362ab13575f562f30c691" translate="yes" xml:space="preserve">
          <source>Lexemes that have positions can further be labeled with a &lt;em&gt;weight&lt;/em&gt;, which can be &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, or &lt;code&gt;D&lt;/code&gt;. &lt;code&gt;D&lt;/code&gt; is the default and hence is not shown on output:</source>
          <target state="translated">位置を持つ語彙素は、さらに &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; 、または &lt;code&gt;D&lt;/code&gt; の&lt;em&gt;重み&lt;/em&gt;でラベル付けできます。 &lt;code&gt;D&lt;/code&gt; がデフォルトであるため、出力には表示されません。</target>
        </trans-unit>
        <trans-unit id="4de4e82a8494674ff2932d2f3ecffa7e7aa91c37" translate="yes" xml:space="preserve">
          <source>Lexical Structure</source>
          <target state="translated">語彙構造</target>
        </trans-unit>
        <trans-unit id="98b17490298c1db6b1bff4b00e76136ec7bbbbbf" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Comments</source>
          <target state="translated">語彙構造。コメント</target>
        </trans-unit>
        <trans-unit id="fba7d54766b9a41f8c00c3be52c20790571085f9" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Constants</source>
          <target state="translated">字句構造。定数</target>
        </trans-unit>
        <trans-unit id="0eb1a63288ed8a4eea2395df1dd364cf859d54a6" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Identifiers and Key Words</source>
          <target state="translated">語彙構造。識別子とキーワード</target>
        </trans-unit>
        <trans-unit id="195802f293c2f60e26c9b9d1cca1271d02591bfe" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Operator Precedence</source>
          <target state="translated">語彙構造。オペレータの優先順位</target>
        </trans-unit>
        <trans-unit id="f3025dccc066fa7289f006eb8ae5b580e53548c6" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Operators</source>
          <target state="translated">字句構造。オペレータ</target>
        </trans-unit>
        <trans-unit id="820a42a37bd5d5e7546df4a06a9fad64993321ea" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Special Characters</source>
          <target state="translated">語彙構造。特殊文字</target>
        </trans-unit>
        <trans-unit id="aa1c47b9be01b70fcc0a9ce52958782af56ce40a" translate="yes" xml:space="preserve">
          <source>Library API</source>
          <target state="translated">ライブラリAPI</target>
        </trans-unit>
        <trans-unit id="bc61796bcb48c2cc0906e22b19a382e56ac7241c" translate="yes" xml:space="preserve">
          <source>Licensed under the PostgreSQL License.</source>
          <target state="translated">PostgreSQLライセンスでライセンスされています。</target>
        </trans-unit>
        <trans-unit id="70e96422ed9935802e683689abf5ed30f10484c2" translate="yes" xml:space="preserve">
          <source>Lightweight Directory Access Protocol</source>
          <target state="translated">ライトウェイトディレクトリアクセスプロトコル</target>
        </trans-unit>
        <trans-unit id="706c7257274a3b242ba385122feaad6c90232d40" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;%/&lt;/code&gt;, but the output is &lt;code&gt;~&lt;/code&gt; (tilde) if the database is your default database.</source>
          <target state="translated">&lt;code&gt;%/&lt;/code&gt; に似ていますが、データベースがデフォルトデータベースの場合、出力は &lt;code&gt;~&lt;/code&gt; （チルド）です。</target>
        </trans-unit>
        <trans-unit id="01c5b4c11e3825cd811354418a5a2a2256d5f14a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--locale&lt;/code&gt;, but only sets the locale in the specified category.</source>
          <target state="translated">同様 &lt;code&gt;--locale&lt;/code&gt; が、唯一の指定されたカテゴリ内のロケールを設定します。</target>
        </trans-unit>
        <trans-unit id="7bcb9cac0fa5cedaf3e22ad3fe9503230b5e0b4b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;LIKE&lt;/code&gt;, the &lt;code&gt;SIMILAR TO&lt;/code&gt; operator succeeds only if its pattern matches the entire string; this is unlike common regular expression behavior where the pattern can match any part of the string. Also like &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;SIMILAR TO&lt;/code&gt; uses &lt;code&gt;_&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; as wildcard characters denoting any single character and any string, respectively (these are comparable to &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;.*&lt;/code&gt; in POSIX regular expressions).</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; と同様に、 &lt;code&gt;SIMILAR TO&lt;/code&gt; 演算子は、そのパターンが文字列全体と一致する場合にのみ成功します。これは、パターンが文字列の任意の部分に一致することができる一般的な正規表現の動作とは異なります。また、 &lt;code&gt;LIKE&lt;/code&gt; と同様に、 &lt;code&gt;SIMILAR TO&lt;/code&gt; は &lt;code&gt;_&lt;/code&gt; および &lt;code&gt;%&lt;/code&gt; をワイルドカード文字として使用し、それぞれ単一の文字と文字列を示します（これらはPOSIX正規表現の &lt;code&gt;.&lt;/code&gt; および &lt;code&gt;.*&lt;/code&gt; に相当します）。</target>
        </trans-unit>
        <trans-unit id="85a2ab4c0cd63cc27de88b6c0b7fbce75e30b6bf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;aggfinalmodify&lt;/code&gt;, but for the &lt;code&gt;aggmfinalfn&lt;/code&gt;</source>
          <target state="translated">同様 &lt;code&gt;aggfinalmodify&lt;/code&gt; 、しかしため &lt;code&gt;aggmfinalfn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="059422d409e873d3ec537d586c30c482c509b6ce" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;penalty&lt;/code&gt;, the &lt;code&gt;picksplit&lt;/code&gt; function is crucial to good performance of the index. Designing suitable &lt;code&gt;penalty&lt;/code&gt; and &lt;code&gt;picksplit&lt;/code&gt; implementations is where the challenge of implementing well-performing GiST indexes lies.</source>
          <target state="translated">&lt;code&gt;penalty&lt;/code&gt; と同様に、 &lt;code&gt;picksplit&lt;/code&gt; 関数はインデックスの良好なパフォーマンスに不可欠です。適切な &lt;code&gt;penalty&lt;/code&gt; と &lt;code&gt;picksplit&lt;/code&gt; 実装を設計することは、パフォーマンスの高いGiSTインデックスを実装するという課題があるところです。</target>
        </trans-unit>
        <trans-unit id="2af7b72fbf0a8ccd43a00ff740a0fef8b75c0395" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;pg_statistic&lt;/code&gt;, &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; should not be readable by the public, since the contents might be considered sensitive. (Example: most common combinations of values in columns might be quite interesting.) &lt;a href=&quot;view-pg-stats-ext&quot;&gt;&lt;code&gt;pg_stats_ext&lt;/code&gt;&lt;/a&gt; is a publicly readable view on &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; (after joining with &lt;code&gt;pg_statistic_ext&lt;/code&gt;) that only exposes information about those tables and columns that are readable by the current user.</source>
          <target state="translated">&lt;code&gt;pg_statistic&lt;/code&gt; と同様に、 &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; は、内容が機密であると見なされる可能性があるため、一般公開されるべきではありません。（例：列の値の最も一般的な組み合わせは非常に興味深いかもしれません。）&lt;a href=&quot;view-pg-stats-ext&quot;&gt; &lt;code&gt;pg_stats_ext&lt;/code&gt; &lt;/a&gt;は、 &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; のパブリックに読み取り可能なビューであり（ &lt;code&gt;pg_statistic_ext&lt;/code&gt; と結合した後）、現在のユーザーが読み取り可能なテーブルと列に関する情報のみを公開します。</target>
        </trans-unit>
        <trans-unit id="1e283f20748a53829b82b5760d76e1b1a5f034e9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;plainto_tsquery&lt;/code&gt;, the &lt;code&gt;phraseto_tsquery&lt;/code&gt; function will not recognize &lt;code&gt;tsquery&lt;/code&gt; operators, weight labels, or prefix-match labels in its input:</source>
          <target state="translated">&lt;code&gt;plainto_tsquery&lt;/code&gt; と同様に、 &lt;code&gt;phraseto_tsquery&lt;/code&gt; 関数は、入力の &lt;code&gt;tsquery&lt;/code&gt; 演算子、重みラベル、またはプレフィックス一致ラベルを認識しません。</target>
        </trans-unit>
        <trans-unit id="176fba135c7656c6b09a34f8083ee1cb69b4df0d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; but result omits &lt;code&gt;toptag&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; と同様ですが、結果からtoptagが省略され &lt;code&gt;toptag&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a092e16f9fe5baae3ebd61fa16eca90ce0ed31e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; but result omits both tags.</source>
          <target state="translated">同様 &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; が、両方のタグを省略なります。</target>
        </trans-unit>
        <trans-unit id="79231c4789ce70fc6a3cc412988cea4a45cfbcbb" translate="yes" xml:space="preserve">
          <source>Like GiST and SP-GiST, GIN can support many different user-defined indexing strategies, and the particular operators with which a GIN index can be used vary depending on the indexing strategy. As an example, the standard distribution of PostgreSQL includes a GIN operator class for arrays, which supports indexed queries using these operators:</source>
          <target state="translated">GiSTやSP-GISTと同様に、GINは多くの異なるユーザ定義のインデックス戦略をサポートすることができ、GINインデックスが使用できる特定の演算子はインデックス戦略によって異なります。例として、PostgreSQLの標準配布物には配列用のGIN演算子クラスが含まれており、これらの演算子を使用したインデックス付き問い合わせをサポートしています。</target>
        </trans-unit>
        <trans-unit id="cd7904080c36090327450bf7ffd681d3be365b14" translate="yes" xml:space="preserve">
          <source>Like GiST, SP-GiST is meant to allow the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert.</source>
          <target state="translated">GiSTと同様に、SP-GISTは、データベースの専門家ではなく、データ型のドメインの専門家によって、適切なアクセス方法を持つカスタムデータ型の開発を可能にすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="48b6f9b32591a18a649f1f0d5dc992087748dd36" translate="yes" xml:space="preserve">
          <source>Like GiST, SP-GiST supports &amp;ldquo;nearest-neighbor&amp;rdquo; searches. For SP-GiST operator classes that support distance ordering, the corresponding operator is specified in the &amp;ldquo;Ordering Operators&amp;rdquo; column in &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 65.1&lt;/a&gt;.</source>
          <target state="translated">GiSTと同様に、SP-GiSTは「最近傍」検索をサポートしています。距離の順序付けをサポートするSP-GiST演算子クラスの場合、対応する演算子は、&lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;表65.1の&lt;/a&gt;「順序付け演算子」列で指定されています。</target>
        </trans-unit>
        <trans-unit id="60e4d14adfb5f143c50beb7e0713788626061776" translate="yes" xml:space="preserve">
          <source>Like a &lt;code&gt;CASE&lt;/code&gt; expression, &lt;code&gt;COALESCE&lt;/code&gt; only evaluates the arguments that are needed to determine the result; that is, arguments to the right of the first non-null argument are not evaluated. This SQL-standard function provides capabilities similar to &lt;code&gt;NVL&lt;/code&gt; and &lt;code&gt;IFNULL&lt;/code&gt;, which are used in some other database systems.</source>
          <target state="translated">&lt;code&gt;CASE&lt;/code&gt; 式と同様に、 &lt;code&gt;COALESCE&lt;/code&gt; は結果を決定するために必要な引数のみを評価します。つまり、最初のnull以外の引数の右側にある引数は評価されません。このSQL標準関数は、他の一部のデータベースシステムで使用される &lt;code&gt;NVL&lt;/code&gt; および &lt;code&gt;IFNULL&lt;/code&gt; と同様の機能を提供します。</target>
        </trans-unit>
        <trans-unit id="1b49279f338ded2bdf03d1fe2fa28270882b8852" translate="yes" xml:space="preserve">
          <source>Like all locks in PostgreSQL, a complete list of advisory locks currently held by any session can be found in the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">PostgreSQLのすべてのロックと同様に、現在セッションで保持されているアドバイザリロックの完全なリストは、&lt;a href=&quot;view-pg-locks&quot;&gt; &lt;code&gt;pg_locks&lt;/code&gt; &lt;/a&gt;システムビューにあります。</target>
        </trans-unit>
        <trans-unit id="41cf9a59f49a59843cd96e23e78a1ccf6b90562d" translate="yes" xml:space="preserve">
          <source>Like all statement-logging options, this option can add significant overhead.</source>
          <target state="translated">すべてのステートメントロギングオプションと同様に、このオプションはかなりのオーバーヘッドを追加することができます。</target>
        </trans-unit>
        <trans-unit id="59c02f2aa97036dbf7f53371e80651c744767251" translate="yes" xml:space="preserve">
          <source>Like any other PostgreSQL client application, pg_dump will by default connect with the database user name that is equal to the current operating system user name. To override this, either specify the &lt;code&gt;-U&lt;/code&gt; option or set the environment variable &lt;code&gt;PGUSER&lt;/code&gt;. Remember that pg_dump connections are subject to the normal client authentication mechanisms (which are described in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;).</source>
          <target state="translated">他のPostgreSQLクライアントアプリケーションと同様に、pg_dumpはデフォルトで、現在のオペレーティングシステムのユーザー名と同じデータベースユーザー名で接続します。これをオーバーライドするには、 &lt;code&gt;-U&lt;/code&gt; オプションを指定するか、環境変数 &lt;code&gt;PGUSER&lt;/code&gt; を設定します。 pg_dump接続は、通常のクライアント認証メカニズム（&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;第20章で&lt;/a&gt;説明）の影響を受けることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c9db72f7082c44e13743d7b5d39d781324396c03" translate="yes" xml:space="preserve">
          <source>Like most other relational database products, PostgreSQL supports &lt;em&gt;aggregate functions&lt;/em&gt;. An aggregate function computes a single result from multiple input rows. For example, there are aggregates to compute the &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;avg&lt;/code&gt; (average), &lt;code&gt;max&lt;/code&gt; (maximum) and &lt;code&gt;min&lt;/code&gt; (minimum) over a set of rows.</source>
          <target state="translated">他のほとんどのリレーショナルデータベース製品と同様に、PostgreSQLは&lt;em&gt;集約関数を&lt;/em&gt;サポートしてい&lt;em&gt;ます&lt;/em&gt;。集約関数は、複数の入力行から単一の結果を計算します。たとえば、行のセットに対して &lt;code&gt;count&lt;/code&gt; 、 &lt;code&gt;sum&lt;/code&gt; 、 &lt;code&gt;avg&lt;/code&gt; （平均）、 &lt;code&gt;max&lt;/code&gt; （最大）、 &lt;code&gt;min&lt;/code&gt; （最小）を計算する集計があります。</target>
        </trans-unit>
        <trans-unit id="e7b37131745c0548a8d7bb256942b653bac4d0f2" translate="yes" xml:space="preserve">
          <source>Like the built-in &lt;code&gt;SYSTEM&lt;/code&gt; sampling method, &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; performs block-level sampling, so that the sample is not completely random but may be subject to clustering effects, especially if only a small number of rows are requested.</source>
          <target state="translated">組み込みの &lt;code&gt;SYSTEM&lt;/code&gt; サンプリング方法と同様に、 &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; はブロックレベルのサンプリングを実行するため、サンプルは完全にランダムではありませんが、特に少数の行のみが要求される場合は、クラスタリングの影響を受ける可能性があります。</target>
        </trans-unit>
        <trans-unit id="2764b8aec49f0a51f07f507803e713795f179f24" translate="yes" xml:space="preserve">
          <source>Like the built-in &lt;code&gt;SYSTEM&lt;/code&gt; sampling method, &lt;code&gt;SYSTEM_TIME&lt;/code&gt; performs block-level sampling, so that the sample is not completely random but may be subject to clustering effects, especially if only a small number of rows are selected.</source>
          <target state="translated">組み込みの &lt;code&gt;SYSTEM&lt;/code&gt; サンプリング方法と同様に、 &lt;code&gt;SYSTEM_TIME&lt;/code&gt; はブロックレベルのサンプリングを実行するため、サンプルは完全にランダムではありませんが、特に少数の行しか選択されていない場合、クラスタリングの影響を受ける可能性があります。</target>
        </trans-unit>
        <trans-unit id="0e207e275fe1f2f0794d071fcc2006657d41ca30" translate="yes" xml:space="preserve">
          <source>Likewise, if the output column is an array type and the JSON value is a JSON array, the elements of the JSON array are converted to elements of the output array by recursive application of these rules.</source>
          <target state="translated">同様に、出力カラムが配列型でJSON値がJSON配列の場合、これらのルールを再帰的に適用することで、JSON配列の要素が出力配列の要素に変換されます。</target>
        </trans-unit>
        <trans-unit id="c63c5f8682585854b3af24acfaa10cdf34814785" translate="yes" xml:space="preserve">
          <source>Likewise, it is the operator class's responsibility that inner tuples do not grow too large to fit on an index page; this limits the number of child nodes that can be used in one inner tuple, as well as the maximum size of a prefix value.</source>
          <target state="translated">同様に、内側のタプルがインデックスページに収まるように大きくなりすぎないようにするのは演算子クラスの責任です。</target>
        </trans-unit>
        <trans-unit id="55246b1bbd1c53d922bbe5662b502ad39d3e6a6a" translate="yes" xml:space="preserve">
          <source>Likewise, the current session's temporary-table schema, &lt;code&gt;pg_temp_nnn&lt;/code&gt;, is always searched if it exists. It can be explicitly listed in the path by using the alias &lt;code&gt;pg_temp&lt;/code&gt;. If it is not listed in the path then it is searched first (even before &lt;code&gt;pg_catalog&lt;/code&gt;). However, the temporary schema is only searched for relation (table, view, sequence, etc) and data type names. It is never searched for function or operator names.</source>
          <target state="translated">同様に、現在のセッションの一時テーブルスキーマ &lt;code&gt;pg_temp_nnn&lt;/code&gt; は、存在する場合は常に検索されます。エイリアス &lt;code&gt;pg_temp&lt;/code&gt; を使用して、パスに明示的にリストできます。パスにリストされていない場合は、最初に検索され &lt;code&gt;pg_catalog&lt;/code&gt; （pg_catalogの前でも）。ただし、一時スキーマは、リレーション（テーブル、ビュー、シーケンスなど）とデータ型名のみが検索されます。関数名や演算子名は検索されません。</target>
        </trans-unit>
        <trans-unit id="23e122f77e2123c0711252ea9a852e626bde8b4c" translate="yes" xml:space="preserve">
          <source>Likewise, while an aggregate final function is normally expected not to modify its input values, sometimes it is impractical to avoid modifying the transition-state argument. Such behavior must be declared using the &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt; parameter. The &lt;code&gt;READ_WRITE&lt;/code&gt; value indicates that the final function modifies the transition state in unspecified ways. This value prevents use of the aggregate as a window function, and it also prevents merging of transition states for aggregate calls that share the same input values and transition functions. The &lt;code&gt;SHAREABLE&lt;/code&gt; value indicates that the transition function cannot be applied after the final function, but multiple final-function calls can be performed on the ending transition state value. This value prevents use of the aggregate as a window function, but it allows merging of transition states. (That is, the optimization of interest here is not applying the same final function repeatedly, but applying different final functions to the same ending transition state value. This is allowed as long as none of the final functions are marked &lt;code&gt;READ_WRITE&lt;/code&gt;.)</source>
          <target state="translated">同様に、集約final関数は通常、その入力値を変更しないことが期待されていますが、遷移状態引数を変更しないようにすることは実際的でない場合があります。このような動作は、 &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt; パラメーターを使用して宣言する必要があります。 &lt;code&gt;READ_WRITE&lt;/code&gt; の値は、最終的な機能は、不特定の方法で遷移状態を修正することを示しています。この値は、ウィンドウ関数としての集約の使用を防ぎ、同じ入力値と遷移関数を共有する集約呼び出しの遷移状態のマージも防ぎます。 &lt;code&gt;SHAREABLE&lt;/code&gt; 値は、最終関数の後に遷移関数を適用できないことを示しますが、終了遷移状態値に対して複数の最終関数呼び出しを実行できます。この値は、ウィンドウ関数としての集約の使用を防ぎますが、遷移状態のマージを可能にします。（つまり、ここでの最適化は、同じ最終関数を繰り返し適用するのではなく、同じ最終遷移状態値に異なる最終関数を適用することです。これは、最終関数が &lt;code&gt;READ_WRITE&lt;/code&gt; とマークされていない限り許可されます。）</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="b47563cbfdd571c38564d5b781eea43887f5700d" translate="yes" xml:space="preserve">
          <source>Limits and compatibility notes for the &lt;code&gt;xml&lt;/code&gt; data type can be found in &lt;a href=&quot;xml-limits-conformance&quot;&gt;Section D.3&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; データ型の制限と互換性に関する注意事項は、&lt;a href=&quot;xml-limits-conformance&quot;&gt;セクションD.3にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="96d43f75faf24d1ca67c70ecd2f285a22f1af174" translate="yes" xml:space="preserve">
          <source>Line number of this rule in &lt;code&gt;pg_hba.conf&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; 内のこのルールの行番号</target>
        </trans-unit>
        <trans-unit id="958c1e90be0b1ef7a3ea1a3a2ab4b6c7d005a8b7" translate="yes" xml:space="preserve">
          <source>Line number within the configuration file the current value was set at (null for values set from sources other than configuration files, or when examined by a user who is neither a superuser or a member of &lt;code&gt;pg_read_all_settings&lt;/code&gt;).</source>
          <target state="translated">現在の値が設定された構成ファイル内の行番号（構成ファイル以外のソースから設定された値、またはスーパーユーザーでも &lt;code&gt;pg_read_all_settings&lt;/code&gt; のメンバーでもないユーザーによって検査された場合はnull）。</target>
        </trans-unit>
        <trans-unit id="5b8f36e71eca1491bb5a406fd952255ee2d3703e" translate="yes" xml:space="preserve">
          <source>Line number within the configuration file where the entry appears</source>
          <target state="translated">エントリが表示される設定ファイル内の行番号</target>
        </trans-unit>
        <trans-unit id="883c97e9c14ffbedf2267734a54bef543950a75e" translate="yes" xml:space="preserve">
          <source>Line segments are output using the first syntax.</source>
          <target state="translated">線分は、最初の構文を使用して出力されます。</target>
        </trans-unit>
        <trans-unit id="752729c6452eefd378564f7929186a93baad040b" translate="yes" xml:space="preserve">
          <source>Line segments are represented by pairs of points that are the endpoints of the segment. Values of type &lt;code&gt;lseg&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">ラインセグメントは、セグメントの端点であるポイントのペアで表されます。タイプ &lt;code&gt;lseg&lt;/code&gt; の値は、以下の構文のいずれかを使用して指定されます。</target>
        </trans-unit>
        <trans-unit id="16fbbc248c377444909f3461d6f0754204ffd781" translate="yes" xml:space="preserve">
          <source>Lines are represented by the linear equation &lt;code&gt;A&lt;/code&gt;x + &lt;code&gt;B&lt;/code&gt;y + &lt;code&gt;C&lt;/code&gt; = 0, where &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are not both zero. Values of type &lt;code&gt;line&lt;/code&gt; are input and output in the following form:</source>
          <target state="translated">線は、線形方程式 &lt;code&gt;A&lt;/code&gt; x + &lt;code&gt;B&lt;/code&gt; y + &lt;code&gt;C&lt;/code&gt; = 0で表されます。ここで、 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; は両方ともゼロではありません。タイプ &lt;code&gt;line&lt;/code&gt; の値は、次の形式で入力および出力されます。</target>
        </trans-unit>
        <trans-unit id="c8eb4d4a92219b0c43b53ed882184405007c09a3" translate="yes" xml:space="preserve">
          <source>Lines being skipped are parsed normally to identify queries and backslash commands, but queries are not sent to the server, and backslash commands other than conditionals (&lt;code&gt;\if&lt;/code&gt;, &lt;code&gt;\elif&lt;/code&gt;, &lt;code&gt;\else&lt;/code&gt;, &lt;code&gt;\endif&lt;/code&gt;) are ignored. Conditional commands are checked only for valid nesting. Variable references in skipped lines are not expanded, and backquote expansion is not performed either.</source>
          <target state="translated">スキップされた行は通常どおり解析され、クエリとバックスラッシュコマンドが識別されますが、クエリはサーバーに送信されず、条件（ &lt;code&gt;\if&lt;/code&gt; 、 &lt;code&gt;\elif&lt;/code&gt; 、 &lt;code&gt;\else&lt;/code&gt; 、 &lt;code&gt;\endif&lt;/code&gt; ）以外のバックスラッシュコマンドは無視されます。条件付きコマンドは、有効なネストについてのみチェックされます。スキップされた行の変数参照は展開されず、バッククォート展開も実行されません。</target>
        </trans-unit>
        <trans-unit id="292bae73b4b4a6866d3b72fe56f7981ef97aafd8" translate="yes" xml:space="preserve">
          <source>Lines in the file can be commented out, deleted, and reordered. For example:</source>
          <target state="translated">ファイル内の行は、コメントアウト、削除、並び替えが可能です。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="1a1f33913b1ca17a294498b513bfd39ae8063421" translate="yes" xml:space="preserve">
          <source>Linguistic - Ispell dictionaries try to reduce input words to a normalized form; stemmer dictionaries remove word endings</source>
          <target state="translated">言語学的-Ispell辞書は、入力された単語を正規化された形に縮小しようとします。</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="77cec0c3e9d8d25a57ec1badeff796c61ca86f12" translate="yes" xml:space="preserve">
          <source>List Partitioning</source>
          <target state="translated">リストパーティショニング</target>
        </trans-unit>
        <trans-unit id="0f3458dce5820aca7e890c4b2003d0e275648e05" translate="yes" xml:space="preserve">
          <source>List all available databases, then exit. Other non-connection options are ignored. This is similar to the meta-command &lt;code&gt;\list&lt;/code&gt;.</source>
          <target state="translated">使用可能なすべてのデータベースをリストしてから終了します。他の非接続オプションは無視されます。これは、メタコマンド &lt;code&gt;\list&lt;/code&gt; 似ています。</target>
        </trans-unit>
        <trans-unit id="4286624f672002892b2ca95ea48f927cd5f85422" translate="yes" xml:space="preserve">
          <source>List information about tables or indexes in a partition tree for a given partitioned table or partitioned index, with one row for each partition. Information provided includes the name of the partition, the name of its immediate parent, a boolean value telling if the partition is a leaf, and an integer telling its level in the hierarchy. The value of level begins at &lt;code&gt;0&lt;/code&gt; for the input table or index in its role as the root of the partition tree, &lt;code&gt;1&lt;/code&gt; for its partitions, &lt;code&gt;2&lt;/code&gt; for their partitions, and so on.</source>
          <target state="translated">特定のパーティションテーブルまたはパーティションインデックスのパーティションツリー内のテーブルまたはインデックスに関する情報を、パーティションごとに1行ずつリストします。提供される情報には、パーティションの名前、その直接の親の名前、パーティションがリーフであるかどうかを示すブール値、および階層内のレベルを示す整数が含まれます。levelの値は、パーティションツリーのルートとしての役割を持つ入力テーブルまたはインデックスの場合は &lt;code&gt;0&lt;/code&gt; 、パーティションの場合は &lt;code&gt;1&lt;/code&gt; 、パーティションの場合は &lt;code&gt;2&lt;/code&gt; から始まります。</target>
        </trans-unit>
        <trans-unit id="f561011cb33daf6ca735d20bdacd8bd7a77bc262" translate="yes" xml:space="preserve">
          <source>List of database name(s) to which this rule applies</source>
          <target state="translated">このルールが適用されるデータベース名のリスト</target>
        </trans-unit>
        <trans-unit id="c88853b59f7b2d53c0a2755574e42ba43712f76a" translate="yes" xml:space="preserve">
          <source>List of user and group name(s) to which this rule applies</source>
          <target state="translated">このルールが適用されるユーザー名とグループ名のリスト</target>
        </trans-unit>
        <trans-unit id="d7af7e299822395c971e66ef8de74b892601d575" translate="yes" xml:space="preserve">
          <source>List text search configurations (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">テキスト検索構成をリストします（詳細については &lt;code&gt;+&lt;/code&gt; を追加します）。</target>
        </trans-unit>
        <trans-unit id="75bf8723aef5bc601305334105eb67bae8708809" translate="yes" xml:space="preserve">
          <source>List text search dictionaries (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">テキスト検索辞書をリストします（詳細については &lt;code&gt;+&lt;/code&gt; を追加します）。</target>
        </trans-unit>
        <trans-unit id="f21d1140d1b1ac1f6965e01da259ebe5d03603ab" translate="yes" xml:space="preserve">
          <source>List text search parsers (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">テキスト検索パーサーをリストします（詳細は &lt;code&gt;+&lt;/code&gt; を追加してください）。</target>
        </trans-unit>
        <trans-unit id="a1e1b832b491c08ce8f5b18d1ec93b64f07d2462" translate="yes" xml:space="preserve">
          <source>List text search templates (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">テキスト検索テンプレートをリストします（詳細は &lt;code&gt;+&lt;/code&gt; を追加してください）。</target>
        </trans-unit>
        <trans-unit id="47ced8a7739926f8f4967c561a0debfd00799b0f" translate="yes" xml:space="preserve">
          <source>List the ancestor relations of the given partition, including the partition itself.</source>
          <target state="translated">与えられたパーティションの先祖関係をリストアップします。</target>
        </trans-unit>
        <trans-unit id="1202ae63c3dc8af04c25238d78d5139577abc684" translate="yes" xml:space="preserve">
          <source>List the contents of a directory. Restricted to superusers by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="translated">ディレクトリの内容を一覧表示します。デフォルトではスーパーユーザに制限されていますが、他のユーザがこの関数を実行するために EXECUTE を許可することができます。</target>
        </trans-unit>
        <trans-unit id="1b401449c4e0d240387a616d5ffbd4a726f02619" translate="yes" xml:space="preserve">
          <source>List the databases in the server and show their names, owners, character set encodings, and access privileges. If &lt;code&gt;pattern&lt;/code&gt; is specified, only databases whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, database sizes, default tablespaces, and descriptions are also displayed. (Size information is only available for databases that the current user can connect to.)</source>
          <target state="translated">サーバー内のデータベースを一覧表示し、それらの名前、所有者、文字セットエンコーディング、およびアクセス権を表示します。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するデータベースのみがリストされます。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、データベースサイズ、デフォルトのテーブルスペース、および説明も表示されます。（サイズ情報は、現在のユーザーが接続できるデータベースでのみ使用できます。）</target>
        </trans-unit>
        <trans-unit id="0247fd79dd91c3e0b751440d00b889937665ce82" translate="yes" xml:space="preserve">
          <source>List the log files in the &lt;code&gt;log_directory&lt;/code&gt; directory</source>
          <target state="translated">&lt;code&gt;log_directory&lt;/code&gt; ディレクトリー内のログ・ファイルをリストします</target>
        </trans-unit>
        <trans-unit id="38872979f824f8456260bf7fc7dc4180d1627b73" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the WAL archive status directory. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">WALアーカイブステータスディレクトリ内のファイルの名前、サイズ、最終変更時刻をリストします。アクセスは &lt;code&gt;pg_monitor&lt;/code&gt; ロールのメンバーに許可され、他の非スーパーユーザーロールに許可される場合があります。</target>
        </trans-unit>
        <trans-unit id="216f390c14edafdef1abb92a2e408162ca22c8d7" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the WAL directory. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">WALディレクトリ内のファイルの名前、サイズ、および最終変更時刻をリストします。アクセスは &lt;code&gt;pg_monitor&lt;/code&gt; ロールのメンバーに許可され、他の非スーパーユーザーロールに許可される場合があります。</target>
        </trans-unit>
        <trans-unit id="74056411fa2a679687b641cd39f5e9f62ea8d563" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the log directory. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">ログディレクトリ内のファイルの名前、サイズ、最終変更時刻をリストします。アクセスは &lt;code&gt;pg_monitor&lt;/code&gt; ロールのメンバーに許可され、他の非スーパーユーザーロールに許可される場合があります。</target>
        </trans-unit>
        <trans-unit id="26197e7b4127b303329ad5784e3d755d4742f8bd" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the temporary directory for &lt;em&gt;&lt;code&gt;tablespace&lt;/code&gt;&lt;/em&gt;. If &lt;em&gt;&lt;code&gt;tablespace&lt;/code&gt;&lt;/em&gt; is not provided, the &lt;code&gt;pg_default&lt;/code&gt; tablespace is used. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;tablespace&lt;/code&gt; の&lt;/em&gt;一時ディレクトリにあるファイルの名前、サイズ、最終変更時刻をリストし&lt;em&gt;ます&lt;/em&gt;。&lt;em&gt; &lt;code&gt;tablespace&lt;/code&gt; &lt;/em&gt;が提供されていない場合、 &lt;code&gt;pg_default&lt;/code&gt; テーブルスペースが使用されます。アクセスは &lt;code&gt;pg_monitor&lt;/code&gt; ロールのメンバーに許可され、他の非スーパーユーザーロールに許可される場合があります。</target>
        </trans-unit>
        <trans-unit id="6c759b89899d2c028e05b2457d4bdd0b88affd68" translate="yes" xml:space="preserve">
          <source>List the table of contents of the archive. The output of this operation can be used as input to the &lt;code&gt;-L&lt;/code&gt; option. Note that if filtering switches such as &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;-t&lt;/code&gt; are used with &lt;code&gt;-l&lt;/code&gt;, they will restrict the items listed.</source>
          <target state="translated">アーカイブの目次をリストします。この操作の出力は、 &lt;code&gt;-L&lt;/code&gt; オプションへの入力として使用できます。 &lt;code&gt;-n&lt;/code&gt; や &lt;code&gt;-t&lt;/code&gt; などのフィルタリングスイッチを &lt;code&gt;-l&lt;/code&gt; とともに使用すると、リストされる項目が制限されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c161fe12eda9cadc384d03d0ff29a932c7632490" translate="yes" xml:space="preserve">
          <source>Lists access methods. If &lt;code&gt;pattern&lt;/code&gt; is specified, only access methods whose names match the pattern are shown. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each access method is listed with its associated handler function and description.</source>
          <target state="translated">アクセス方法をリストします。 &lt;code&gt;pattern&lt;/code&gt; を指定した場合、名前がパターンに一致するアクセスメソッドのみが表示されます。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各アクセス方法は、関連するハンドラー関数と説明とともにリストされます。</target>
        </trans-unit>
        <trans-unit id="b5da05aa6b417885b162fa263cf878dfa1640338" translate="yes" xml:space="preserve">
          <source>Lists aggregate functions, together with their return type and the data types they operate on. If &lt;code&gt;pattern&lt;/code&gt; is specified, only aggregates whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">集計関数を、戻り値の型および関数が操作するデータ型とともにリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致する集約のみが表示されます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。システムオブジェクトを含めるには、パターンまたは &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。</target>
        </trans-unit>
        <trans-unit id="ba7e4d85e717101a207e6ece8fa5eae17728be95" translate="yes" xml:space="preserve">
          <source>Lists collations. If &lt;code&gt;pattern&lt;/code&gt; is specified, only collations whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each collation is listed with its associated description, if any. Note that only collations usable with the current database's encoding are shown, so the results may vary in different databases of the same installation.</source>
          <target state="translated">照合順序をリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致する照合のみがリストされます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。システムオブジェクトを含めるには、パターンまたは &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各照合は、関連する説明があればそれとともにリストされます。現在のデータベースのエンコーディングで使用できる照合順序のみが表示されるため、同じインストールの異なるデータベースでは結果が異なる場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6ed6b6d351ec0314d4901220593cc831623e426a" translate="yes" xml:space="preserve">
          <source>Lists conversions between character-set encodings. If &lt;code&gt;pattern&lt;/code&gt; is specified, only conversions whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated description.</source>
          <target state="translated">文字セットエンコーディング間の変換をリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致する変換のみがリストされます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。システムオブジェクトを含めるには、パターンまたは &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各オブジェクトは関連する説明とともにリストされます。</target>
        </trans-unit>
        <trans-unit id="b54152fa5b884f8f7bf428a2c5f3834496af64bd" translate="yes" xml:space="preserve">
          <source>Lists data types. If &lt;code&gt;pattern&lt;/code&gt; is specified, only types whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each type is listed with its internal name and size, its allowed values if it is an &lt;code&gt;enum&lt;/code&gt; type, and its associated permissions. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">データ型をリストします。場合は &lt;code&gt;pattern&lt;/code&gt; 指定され、そのパターンに名前が一致するだけのタイプが記載されています。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各タイプは、その内部名とサイズ、 &lt;code&gt;enum&lt;/code&gt; 型の場合は許可されている値、および関連する権限とともにリストされます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。システムオブジェクトを含めるには、パターンまたは &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。</target>
        </trans-unit>
        <trans-unit id="1ed12c82d91396faa77acdf69ded0ffcf5a493ea" translate="yes" xml:space="preserve">
          <source>Lists database roles. (Since the concepts of &amp;ldquo;users&amp;rdquo; and &amp;ldquo;groups&amp;rdquo; have been unified into &amp;ldquo;roles&amp;rdquo;, this command is now equivalent to &lt;code&gt;\dg&lt;/code&gt;.) By default, only user-created roles are shown; supply the &lt;code&gt;S&lt;/code&gt; modifier to include system roles. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those roles whose names match the pattern are listed. If the form &lt;code&gt;\du+&lt;/code&gt; is used, additional information is shown about each role; currently this adds the comment for each role.</source>
          <target state="translated">データベースロールを一覧表示します。 （「ユーザー」と「グループ」の概念が「ロール」に統合されたため、このコマンドは &lt;code&gt;\dg&lt;/code&gt; と同等になりました。）デフォルトでは、ユーザーが作成したロールのみが表示されます。システムロールを含めるには、 &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するロールのみがリストされます。 &lt;code&gt;\du+&lt;/code&gt; の形式を使用すると、各役割に関する追加情報が表示されます。現在、これは各ロールのコメントを追加しています。</target>
        </trans-unit>
        <trans-unit id="e29d00c4605108f4d7ba7d0a5a262d70885a0257" translate="yes" xml:space="preserve">
          <source>Lists database roles. (Since the concepts of &amp;ldquo;users&amp;rdquo; and &amp;ldquo;groups&amp;rdquo; have been unified into &amp;ldquo;roles&amp;rdquo;, this command is now equivalent to &lt;code&gt;\du&lt;/code&gt;.) By default, only user-created roles are shown; supply the &lt;code&gt;S&lt;/code&gt; modifier to include system roles. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those roles whose names match the pattern are listed. If the form &lt;code&gt;\dg+&lt;/code&gt; is used, additional information is shown about each role; currently this adds the comment for each role.</source>
          <target state="translated">データベースロールを一覧表示します。（「ユーザー」と「グループ」の概念が「役割」に統合されたため、このコマンドは &lt;code&gt;\du&lt;/code&gt; と同等になりました。）デフォルトでは、ユーザーが作成した役割のみが表示されます。システムロールを含めるには、 &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するロールのみがリストされます。 &lt;code&gt;\dg+&lt;/code&gt; の形式を使用すると、各ロールに関する追加情報が表示されます。現在、これは各ロールのコメントを追加しています。</target>
        </trans-unit>
        <trans-unit id="d0e3c51687d883f635b713be9df17a17913ec4be" translate="yes" xml:space="preserve">
          <source>Lists default access privilege settings. An entry is shown for each role (and schema, if applicable) for which the default privilege settings have been changed from the built-in defaults. If &lt;code&gt;pattern&lt;/code&gt; is specified, only entries whose role name or schema name matches the pattern are listed.</source>
          <target state="translated">デフォルトのアクセス権設定をリストします。組み込みのデフォルトからデフォルトの特権設定が変更されたロール（および該当する場合はスキーマ）ごとにエントリが表示されます。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、ロール名またはスキーマ名がパターンに一致するエントリーのみがリストされます。</target>
        </trans-unit>
        <trans-unit id="ee1fa4ed6c7126c1942282c2d9a97fd2fb17066c" translate="yes" xml:space="preserve">
          <source>Lists defined configuration settings. These settings can be role-specific, database-specific, or both. &lt;code&gt;role-pattern&lt;/code&gt; and &lt;code&gt;database-pattern&lt;/code&gt; are used to select specific roles and databases to list, respectively. If omitted, or if &lt;code&gt;*&lt;/code&gt; is specified, all settings are listed, including those not role-specific or database-specific, respectively.</source>
          <target state="translated">定義された構成設定をリストします。これらの設定は、ロール固有、データベース固有、またはその両方にすることができます。 &lt;code&gt;role-pattern&lt;/code&gt; と &lt;code&gt;database-pattern&lt;/code&gt; は、それぞれ特定のロールとデータベースを選択してリストするために使用されます。省略した場合、または &lt;code&gt;*&lt;/code&gt; を指定した場合は、それぞれロール固有またはデータベース固有ではないものを含め、すべての設定がリストされます。</target>
        </trans-unit>
        <trans-unit id="417307de73c4769c24d10a4a74f461c675665a71" translate="yes" xml:space="preserve">
          <source>Lists domains. If &lt;code&gt;pattern&lt;/code&gt; is specified, only domains whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated permissions and description.</source>
          <target state="translated">ドメインを一覧表示します。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するドメインのみが表示されます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。システムオブジェクトを含めるには、パターンまたは &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各オブジェクトは、関連する権限と説明とともに一覧表示されます。</target>
        </trans-unit>
        <trans-unit id="f274b8d8f8b448f365efc740c76106814f6e8672" translate="yes" xml:space="preserve">
          <source>Lists event triggers. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those event triggers whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated description.</source>
          <target state="translated">イベントトリガーを一覧表示します。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するイベントトリガーのみが一覧表示されます。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各オブジェクトは関連する説明とともにリストされます。</target>
        </trans-unit>
        <trans-unit id="e79aeba25c72ede19da97f86bce69c0ff45f55b7" translate="yes" xml:space="preserve">
          <source>Lists foreign servers (mnemonic: &amp;ldquo;external servers&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only those servers whose name matches the pattern are listed. If the form &lt;code&gt;\des+&lt;/code&gt; is used, a full description of each server is shown, including the server's access privileges, type, version, options, and description.</source>
          <target state="translated">外部サーバーをリストします（ニーモニック：「外部サーバー」）。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するサーバーのみがリストされます。 &lt;code&gt;\des+&lt;/code&gt; の形式を使用すると、サーバーのアクセス権、タイプ、バージョン、オプション、説明など、各サーバーの完全な説明が表示されます。</target>
        </trans-unit>
        <trans-unit id="78b8f146a38943cc21434e0badfc06780b279a22" translate="yes" xml:space="preserve">
          <source>Lists foreign tables (mnemonic: &amp;ldquo;external tables&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only entries whose table name or schema name matches the pattern are listed. If the form &lt;code&gt;\det+&lt;/code&gt; is used, generic options and the foreign table description are also displayed.</source>
          <target state="translated">外部テーブルをリストします（ニーモニック：「外部テーブル」）。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、テーブル名またはスキーマ名がパターンに一致するエントリのみがリストされます。 &lt;code&gt;\det+&lt;/code&gt; の形式を使用すると、一般的なオプションと外部テーブルの説明も表示されます。</target>
        </trans-unit>
        <trans-unit id="841607b805a28257bffdea756495ef2cb699e228" translate="yes" xml:space="preserve">
          <source>Lists foreign-data wrappers (mnemonic: &amp;ldquo;external wrappers&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only those foreign-data wrappers whose name matches the pattern are listed. If the form &lt;code&gt;\dew+&lt;/code&gt; is used, the access privileges, options, and description of the foreign-data wrapper are also shown.</source>
          <target state="translated">外部データラッパーを一覧表示します（ニーモニック：「外部ラッパー」）。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致する外部データラッパーのみがリストされます。 &lt;code&gt;\dew+&lt;/code&gt; の形式を使用する場合、外部データラッパーのアクセス権限、オプション、および説明も表示されます。</target>
        </trans-unit>
        <trans-unit id="c91d07a0e33c78c3a0a76bd7d8280b785bbd7664" translate="yes" xml:space="preserve">
          <source>Lists functions, together with their result data types, argument data types, and function types, which are classified as &amp;ldquo;agg&amp;rdquo; (aggregate), &amp;ldquo;normal&amp;rdquo;, &amp;ldquo;procedure&amp;rdquo;, &amp;ldquo;trigger&amp;rdquo;, or &amp;ldquo;window&amp;rdquo;. To display only functions of specific type(s), add the corresponding letters &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, or &lt;code&gt;w&lt;/code&gt; to the command. If &lt;code&gt;pattern&lt;/code&gt; is specified, only functions whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If the form &lt;code&gt;\df+&lt;/code&gt; is used, additional information about each function is shown, including volatility, parallel safety, owner, security classification, access privileges, language, source code and description.</source>
          <target state="translated">関数を、その結果のデータ型、引数のデータ型、および関数の型と共に一覧表示します。これらは、「agg」（集約）、「通常」、「プロシージャ」、「トリガー」、または「ウィンドウ」に分類されます。特定のタイプの関数のみを表示するには、対応する文字 &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;n&lt;/code&gt; 、 &lt;code&gt;p&lt;/code&gt; 、 &lt;code&gt;t&lt;/code&gt; 、または &lt;code&gt;w&lt;/code&gt; をコマンドに追加します。場合は &lt;code&gt;pattern&lt;/code&gt; 指定され、そのパターンに名前が一致する関数のみが表示されます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。システムオブジェクトを含めるには、パターンまたは &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。フォーム &lt;code&gt;\df+&lt;/code&gt; を使用すると、ボラティリティ、並列安全性、所有者、セキュリティ分類、アクセス権限、言語、ソースコード、説明など、各関数に関する追加情報が表示されます。</target>
        </trans-unit>
        <trans-unit id="24ae150e74e52548491a1b8532993c514778868d" translate="yes" xml:space="preserve">
          <source>Lists installed extensions. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those extensions whose names match the pattern are listed. If the form &lt;code&gt;\dx+&lt;/code&gt; is used, all the objects belonging to each matching extension are listed.</source>
          <target state="translated">インストールされている拡張機能をリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致する拡張子のみがリストされます。 &lt;code&gt;\dx+&lt;/code&gt; の形式を使用すると、一致する各拡張子に属するすべてのオブジェクトがリストされます。</target>
        </trans-unit>
        <trans-unit id="7b91d850ae0056bf60018b5ebefbaf56889e4bca" translate="yes" xml:space="preserve">
          <source>Lists operators with their operand and result types. If &lt;code&gt;pattern&lt;/code&gt; is specified, only operators whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, additional information about each operator is shown, currently just the name of the underlying function.</source>
          <target state="translated">演算子とそのオペランドおよび結果タイプをリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致する演算子のみがリストされます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。システムオブジェクトを含めるには、パターンまたは &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。コマンド名に &lt;code&gt;+&lt;/code&gt; が付加されている場合、各演算子に関する追加情報が表示されます。現在のところ、基礎となる関数の名前のみです。</target>
        </trans-unit>
        <trans-unit id="b6dce10f054bc4a066d94e91eb2653d58925f8ed" translate="yes" xml:space="preserve">
          <source>Lists partitioned relations. If &lt;code&gt;pattern&lt;/code&gt; is specified, only entries whose name matches the pattern are listed. The modifiers &lt;code&gt;t&lt;/code&gt; (tables) and &lt;code&gt;i&lt;/code&gt; (indexes) can be appended to the command, filtering the kind of relations to list. By default, partitioned tables and indexes are listed.</source>
          <target state="translated">分割された関係をリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するエントリのみがリストされます。修飾子 &lt;code&gt;t&lt;/code&gt; （テーブル）および &lt;code&gt;i&lt;/code&gt; （インデックス）をコマンドに追加して、リストする関係の種類をフィルタリングできます。デフォルトでは、パーティション分割されたテーブルとインデックスが一覧表示されます。</target>
        </trans-unit>
        <trans-unit id="6639ac93b6964b1629641d3ad0795ccf6bdb89e2" translate="yes" xml:space="preserve">
          <source>Lists procedural languages. If &lt;code&gt;pattern&lt;/code&gt; is specified, only languages whose names match the pattern are listed. By default, only user-created languages are shown; supply the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each language is listed with its call handler, validator, access privileges, and whether it is a system object.</source>
          <target state="translated">手続き言語をリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致する言語のみがリストされます。デフォルトでは、ユーザーが作成した言語のみが表示されます。システムオブジェクトを含めるには、 &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各言語は、そのコールハンドラ、バリデータ、アクセス権限、およびシステムオブジェクトかどうかとともに表示されます。</target>
        </trans-unit>
        <trans-unit id="d159d89b43261dc04712aa39d984b98a29983107" translate="yes" xml:space="preserve">
          <source>Lists replication publications. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those publications whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, the tables associated with each publication are shown as well.</source>
          <target state="translated">レプリケーションパブリケーションを一覧表示します。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するパブリケーションのみがリストされます。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各パブリケーションに関連付けられているテーブルも表示されます。</target>
        </trans-unit>
        <trans-unit id="5edfb1ad4f7a1bcdc13378e73525d95e092cfe45" translate="yes" xml:space="preserve">
          <source>Lists replication subscriptions. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those subscriptions whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, additional properties of the subscriptions are shown.</source>
          <target state="translated">レプリケーションサブスクリプションを一覧表示します。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するサブスクリプションのみがリストされます。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、サブスクリプションの追加のプロパティが表示されます。</target>
        </trans-unit>
        <trans-unit id="4fb239c1a080740cf10a3927b46a1262b5ea56d1" translate="yes" xml:space="preserve">
          <source>Lists schemas (namespaces). If &lt;code&gt;pattern&lt;/code&gt; is specified, only schemas whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated permissions and description, if any.</source>
          <target state="translated">スキーマ（名前空間）をリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するスキーマのみがリストされます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。システムオブジェクトを含めるには、パターンまたは &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各オブジェクトは、関連する権限と説明（ある場合）とともに一覧表示されます。</target>
        </trans-unit>
        <trans-unit id="aaa2ebfeff5215f2bad04d9af2cdf2d89c158023" translate="yes" xml:space="preserve">
          <source>Lists tables, views and sequences with their associated access privileges. If &lt;code&gt;pattern&lt;/code&gt; is specified, only tables, views and sequences whose names match the pattern are listed.</source>
          <target state="translated">テーブル、ビュー、シーケンスを、関連するアクセス権とともに一覧表示します。場合は &lt;code&gt;pattern&lt;/code&gt; 指定され、そのパターンに名前が一致するテーブルのみ、ビュー、シーケンスの一覧が表示されます。</target>
        </trans-unit>
        <trans-unit id="bb59616e451459bc316da05ad410acee2d59778b" translate="yes" xml:space="preserve">
          <source>Lists tables, views and sequences with their associated access privileges. If a &lt;code&gt;pattern&lt;/code&gt; is specified, only tables, views and sequences whose names match the pattern are listed.</source>
          <target state="translated">テーブル、ビュー、シーケンスを、関連するアクセス権とともに一覧表示します。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するテーブル、ビュー、シーケンスのみがリストされます。</target>
        </trans-unit>
        <trans-unit id="ef7de3f6c539d5dd5da460845cd3a63bfcafc2bd" translate="yes" xml:space="preserve">
          <source>Lists tablespaces. If &lt;code&gt;pattern&lt;/code&gt; is specified, only tablespaces whose names match the pattern are shown. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each tablespace is listed with its associated options, on-disk size, permissions and description.</source>
          <target state="translated">テーブルスペースを一覧表示します。場合は &lt;code&gt;pattern&lt;/code&gt; 指定され、そのパターンに名前が一致する専用表領域が表示されます。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各テーブルスペースは、関連するオプション、ディスク上のサイズ、権限、説明とともに一覧表示されます。</target>
        </trans-unit>
        <trans-unit id="762f36a63dc0b6ce665e3c2131b6edc15a3446da" translate="yes" xml:space="preserve">
          <source>Lists text search configurations. If &lt;code&gt;pattern&lt;/code&gt; is specified, only configurations whose names match the pattern are shown. If the form &lt;code&gt;\dF+&lt;/code&gt; is used, a full description of each configuration is shown, including the underlying text search parser and the dictionary list for each parser token type.</source>
          <target state="translated">テキスト検索構成をリストします。場合は &lt;code&gt;pattern&lt;/code&gt; 指定され、そのパターンに名前が一致する唯一の構成が示されています。 &lt;code&gt;\dF+&lt;/code&gt; の形式を使用すると、基になるテキスト検索パーサーや各パーサートークンタイプのディクショナリリストなど、各構成の完全な説明が表示されます。</target>
        </trans-unit>
        <trans-unit id="f6bb868ceb84c3b85646ce544e1a8e93f3c169f4" translate="yes" xml:space="preserve">
          <source>Lists text search dictionaries. If &lt;code&gt;pattern&lt;/code&gt; is specified, only dictionaries whose names match the pattern are shown. If the form &lt;code&gt;\dFd+&lt;/code&gt; is used, additional information is shown about each selected dictionary, including the underlying text search template and the option values.</source>
          <target state="translated">テキスト検索辞書をリストします。場合は &lt;code&gt;pattern&lt;/code&gt; 指定され、そのパターンに名前が一致するだけで辞書が表示されます。 &lt;code&gt;\dFd+&lt;/code&gt; の形式を使用すると、選択した各辞書について、基礎となるテキスト検索テンプレートやオプション値などの追加情報が表示されます。</target>
        </trans-unit>
        <trans-unit id="ba01d174c5c6cab6bd3b44d816241b168a44d553" translate="yes" xml:space="preserve">
          <source>Lists text search parsers. If &lt;code&gt;pattern&lt;/code&gt; is specified, only parsers whose names match the pattern are shown. If the form &lt;code&gt;\dFp+&lt;/code&gt; is used, a full description of each parser is shown, including the underlying functions and the list of recognized token types.</source>
          <target state="translated">テキスト検索パーサーをリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するパーサーのみが表示されます。 &lt;code&gt;\dFp+&lt;/code&gt; の形式を使用すると、基礎となる関数や認識されるトークンタイプのリストなど、各パーサーの完全な説明が表示されます。</target>
        </trans-unit>
        <trans-unit id="80703d2e971d1dc8cd3056fab4357086f4708060" translate="yes" xml:space="preserve">
          <source>Lists text search templates. If &lt;code&gt;pattern&lt;/code&gt; is specified, only templates whose names match the pattern are shown. If the form &lt;code&gt;\dFt+&lt;/code&gt; is used, additional information is shown about each template, including the underlying function names.</source>
          <target state="translated">テキスト検索テンプレートをリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するテンプレートのみが表示されます。 &lt;code&gt;\dFt+&lt;/code&gt; の形式を使用すると、基になる関数名など、各テンプレートに関する追加情報が表示されます。</target>
        </trans-unit>
        <trans-unit id="f0a40588516c3a8604348670da0a879303a508a1" translate="yes" xml:space="preserve">
          <source>Lists type casts. If &lt;code&gt;pattern&lt;/code&gt; is specified, only casts whose source or target types match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated description.</source>
          <target state="translated">型キャストをリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、ソースまたはターゲットのタイプがパターンに一致するキャストのみがリストされます。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各オブジェクトは関連する説明とともにリストされます。</target>
        </trans-unit>
        <trans-unit id="b23bce00d2c7c8d6375ab0cd2ad7f38f1f799075" translate="yes" xml:space="preserve">
          <source>Lists user mappings (mnemonic: &amp;ldquo;external users&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only those mappings whose user names match the pattern are listed. If the form &lt;code&gt;\deu+&lt;/code&gt; is used, additional information about each mapping is shown.</source>
          <target state="translated">ユーザーマッピングを一覧表示します（ニーモニック： &quot;外部ユーザー&quot;）。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、ユーザー名がパターンに一致するマッピングのみがリストされます。 &lt;code&gt;\deu+&lt;/code&gt; の形式を使用すると、各マッピングに関する追加情報が表示されます。</target>
        </trans-unit>
        <trans-unit id="fee8c64f75222b953355d11e92e46cafb863f042" translate="yes" xml:space="preserve">
          <source>Lists which transforms a call to the function should apply. Transforms convert between SQL types and language-specific data types; see &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;. Procedural language implementations usually have hardcoded knowledge of the built-in types, so those don't need to be listed here. If a procedural language implementation does not know how to handle a type and no transform is supplied, it will fall back to a default behavior for converting data types, but this depends on the implementation.</source>
          <target state="translated">関数の呼び出しを変換するリストが適用されます。変換は、SQL型と言語固有のデータ型の間で変換します。&lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORMを&lt;/a&gt;参照してください。手続き型言語の実装は、通常、組み込み型のハードコードされた知識を持っているため、ここにリストする必要はありません。手続き型言語の実装が型の処理方法を知らず、変換が提供されない場合、データ型を変換するためのデフォルトの動作にフォールバックしますが、これは実装によって異なります。</target>
        </trans-unit>
        <trans-unit id="c221c51fd4371df729302cc73086e8359e205a42" translate="yes" xml:space="preserve">
          <source>Lists which transforms a call to the procedure should apply. Transforms convert between SQL types and language-specific data types; see &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;. Procedural language implementations usually have hardcoded knowledge of the built-in types, so those don't need to be listed here. If a procedural language implementation does not know how to handle a type and no transform is supplied, it will fall back to a default behavior for converting data types, but this depends on the implementation.</source>
          <target state="translated">プロシージャの呼び出しを変換するリストが適用されます。変換は、SQL型と言語固有のデータ型の間で変換します。&lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORMを&lt;/a&gt;参照してください。手続き型言語の実装は、通常、組み込み型のハードコードされた知識を持っているため、ここにリストする必要はありません。手続き型言語の実装が型の処理方法を知らず、変換が提供されない場合、データ型を変換するためのデフォルトの動作にフォールバックしますが、これは実装によって異なります。</target>
        </trans-unit>
        <trans-unit id="0c4bdf42add57a2eabb9fb37aeb6c28158bad4b3" translate="yes" xml:space="preserve">
          <source>Literal &lt;code&gt;%&lt;/code&gt;</source>
          <target state="translated">リテラル &lt;code&gt;%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df214b5bbf763eb7922bad89d00442e94abbaf1f" translate="yes" xml:space="preserve">
          <source>Loading an extension essentially amounts to running the extension's script file. The script will typically create new SQL objects such as functions, data types, operators and index support methods. &lt;code&gt;CREATE EXTENSION&lt;/code&gt; additionally records the identities of all the created objects, so that they can be dropped again if &lt;code&gt;DROP EXTENSION&lt;/code&gt; is issued.</source>
          <target state="translated">拡張機能の読み込みは、基本的に拡張機能のスクリプトファイルを実行することと同じです。スクリプトは通常、関数、データ型、演算子、インデックスサポートメソッドなどの新しいSQLオブジェクトを作成します。 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; はさらに、作成されたすべてのオブジェクトのIDを記録します。これにより、 &lt;code&gt;DROP EXTENSION&lt;/code&gt; が発行された場合にそれらを再度ドロップできます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
