<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="5a4d553a940905a5b45f8f4a9271805f05936143" translate="yes" xml:space="preserve">
          <source>Force reindexdb to prompt for a password before connecting to a database.</source>
          <target state="translated">データベースに接続する前にパスワードを要求するように reindexdb を強制します。</target>
        </trans-unit>
        <trans-unit id="d704d18558a65a962929acf79610b9c10e0ea21f" translate="yes" xml:space="preserve">
          <source>Force switch to a new write-ahead log file (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</source>
          <target state="translated">新しい書き込み優先ログファイルに強制的に切り替えます (デフォルトではスーパーユーザに制限されていますが、他のユーザはこの関数を実行するために EXECUTE を許可することができます)</target>
        </trans-unit>
        <trans-unit id="ad34c2643c5ad08a3b8ba0b861d443b8a1146fd4" translate="yes" xml:space="preserve">
          <source>Force vacuumdb to prompt for a password before connecting to a database.</source>
          <target state="translated">データベースに接続する前に、vacuumdb にパスワードを要求するようにしました。</target>
        </trans-unit>
        <trans-unit id="ab1894a9915a1c5bdd4fa99a3c35aa7aef1f3043" translate="yes" xml:space="preserve">
          <source>Forces quoting to be used for all non-&lt;code&gt;NULL&lt;/code&gt; values in each specified column. &lt;code&gt;NULL&lt;/code&gt; output is never quoted. If &lt;code&gt;*&lt;/code&gt; is specified, non-&lt;code&gt;NULL&lt;/code&gt; values will be quoted in all columns. This option is allowed only in &lt;code&gt;COPY TO&lt;/code&gt;, and only when using &lt;code&gt;CSV&lt;/code&gt; format.</source>
          <target state="translated">指定された各列のすべての &lt;code&gt;NULL&lt;/code&gt; 以外の値に引用を強制的に使用します。 &lt;code&gt;NULL&lt;/code&gt; 出力は引用されません。場合は &lt;code&gt;*&lt;/code&gt; を指定すると、非 &lt;code&gt;NULL&lt;/code&gt; の値がすべての列に引用されます。このオプションは、 &lt;code&gt;COPY TO&lt;/code&gt; でのみ、および &lt;code&gt;CSV&lt;/code&gt; 形式を使用する場合にのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="e53ee207fccbc10bf771537429c8ceb105018b4c" translate="yes" xml:space="preserve">
          <source>Foreign Data</source>
          <target state="translated">海外データ</target>
        </trans-unit>
        <trans-unit id="60b698071b99433356500a6664686a79ff0c576f" translate="yes" xml:space="preserve">
          <source>Foreign data is accessed with help from a &lt;em&gt;foreign data wrapper&lt;/em&gt;. A foreign data wrapper is a library that can communicate with an external data source, hiding the details of connecting to the data source and obtaining data from it. There are some foreign data wrappers available as &lt;code&gt;contrib&lt;/code&gt; modules; see &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Appendix F&lt;/a&gt;. Other kinds of foreign data wrappers might be found as third party products. If none of the existing foreign data wrappers suit your needs, you can write your own; see &lt;a href=&quot;https://www.postgresql.org/docs/12/fdwhandler.html&quot;&gt;Chapter 56&lt;/a&gt;.</source>
          <target state="translated">外部データは、&lt;em&gt;外部データラッパーの&lt;/em&gt;助けを借りてアクセスされ&lt;em&gt;ます&lt;/em&gt;。外部データラッパーは、外部データソースと通信して、データソースへの接続およびデータソースからのデータの取得の詳細を隠すことができるライブラリです。 &lt;code&gt;contrib&lt;/code&gt; モジュールとして使用できる外部データラッパーがいくつかあります。&lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;付録Fを&lt;/a&gt;参照してください。他の種類の外部データラッパーは、サードパーティ製品として見つかる場合があります。既存の外部データラッパーがニーズに合わない場合は、独自に作成できます。&lt;a href=&quot;https://www.postgresql.org/docs/12/fdwhandler.html&quot;&gt;第56章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="94c0cd02df3f1a32213c26c15ceb6bc33046efb5" translate="yes" xml:space="preserve">
          <source>Foreign key deletion action code: &lt;code&gt;a&lt;/code&gt; = no action, &lt;code&gt;r&lt;/code&gt; = restrict, &lt;code&gt;c&lt;/code&gt; = cascade, &lt;code&gt;n&lt;/code&gt; = set null, &lt;code&gt;d&lt;/code&gt; = set default</source>
          <target state="translated">外部キー削除アクションコード： &lt;code&gt;a&lt;/code&gt; =アクションなし、 &lt;code&gt;r&lt;/code&gt; =制限、 &lt;code&gt;c&lt;/code&gt; =カスケード、 &lt;code&gt;n&lt;/code&gt; =ヌルに設定、 &lt;code&gt;d&lt;/code&gt; =デフォルトに設定</target>
        </trans-unit>
        <trans-unit id="67ed786663de0061ba336e549d3d7d184b09ab90" translate="yes" xml:space="preserve">
          <source>Foreign key match type: &lt;code&gt;f&lt;/code&gt; = full, &lt;code&gt;p&lt;/code&gt; = partial, &lt;code&gt;s&lt;/code&gt; = simple</source>
          <target state="translated">外部キー一致タイプ： &lt;code&gt;f&lt;/code&gt; =完全、 &lt;code&gt;p&lt;/code&gt; =部分的、 &lt;code&gt;s&lt;/code&gt; =単純</target>
        </trans-unit>
        <trans-unit id="f7223fe60c8520d1d8c5dd54e60a3a21d67aff2e" translate="yes" xml:space="preserve">
          <source>Foreign key update action code: &lt;code&gt;a&lt;/code&gt; = no action, &lt;code&gt;r&lt;/code&gt; = restrict, &lt;code&gt;c&lt;/code&gt; = cascade, &lt;code&gt;n&lt;/code&gt; = set null, &lt;code&gt;d&lt;/code&gt; = set default</source>
          <target state="translated">外部キー更新アクションコード： &lt;code&gt;a&lt;/code&gt; =アクションなし、 &lt;code&gt;r&lt;/code&gt; =制限、 &lt;code&gt;c&lt;/code&gt; =カスケード、 &lt;code&gt;n&lt;/code&gt; =ヌルに設定、 &lt;code&gt;d&lt;/code&gt; =デフォルトに設定</target>
        </trans-unit>
        <trans-unit id="65a5d0add327edf5ad461c0cb7f6054d85e3b0e7" translate="yes" xml:space="preserve">
          <source>Foreign server specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">「keyword = value」文字列としての外部サーバー固有のオプション</target>
        </trans-unit>
        <trans-unit id="b1b45f3e264a3f3e8e58872fe892f43e82136b90" translate="yes" xml:space="preserve">
          <source>Foreign table options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">「keyword = value」文字列としての外部テーブルオプション</target>
        </trans-unit>
        <trans-unit id="a914bd9dafd1ce6150ce31452c647084bd0851ab" translate="yes" xml:space="preserve">
          <source>Foreign tables (see &lt;a href=&quot;ddl-foreign-data&quot;&gt;Section 5.12&lt;/a&gt;) can also be part of inheritance hierarchies, either as parent or child tables, just as regular tables can be. If a foreign table is part of an inheritance hierarchy then any operations not supported by the foreign table are not supported on the whole hierarchy either.</source>
          <target state="translated">外部テーブル（&lt;a href=&quot;ddl-foreign-data&quot;&gt;セクション5.12を&lt;/a&gt;参照）も、通常のテーブルと同様に、親テーブルまたは子テーブルとして継承階層の一部にすることができます。外部テーブルが継承階層の一部である場合、外部テーブルでサポートされていない操作は階層全体でもサポートされません。</target>
        </trans-unit>
        <trans-unit id="f355c9e7f0aaa375694a97f071442929b8bef72d" translate="yes" xml:space="preserve">
          <source>Foreign tables are analyzed only when explicitly selected. Not all foreign data wrappers support &lt;code&gt;ANALYZE&lt;/code&gt;. If the table's wrapper does not support &lt;code&gt;ANALYZE&lt;/code&gt;, the command prints a warning and does nothing.</source>
          <target state="translated">外部テーブルは、明示的に選択された場合にのみ分析されます。すべての外部データラッパーが &lt;code&gt;ANALYZE&lt;/code&gt; をサポートするわけではありません。テーブルのラッパーが &lt;code&gt;ANALYZE&lt;/code&gt; をサポートしていない場合、コマンドは警告を出力して何もしません。</target>
        </trans-unit>
        <trans-unit id="114810936e2e203f850dfc30c1a7c22dda77dc02" translate="yes" xml:space="preserve">
          <source>Foreign tables can have generated columns. See &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; for details.</source>
          <target state="translated">外部テーブルは列を生成できます。詳細については、&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="85799ef6669eba496b7c90dd087afbef34699725" translate="yes" xml:space="preserve">
          <source>Foreign-data wrapper specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">「keyword = value」文字列としての外部データラッパー固有のオプション</target>
        </trans-unit>
        <trans-unit id="8340dbc9e3b7c8b79fc57d1ea821c4dd6ab2e45a" translate="yes" xml:space="preserve">
          <source>Fork number within the relation; see &lt;code&gt;include/common/relpath.h&lt;/code&gt;</source>
          <target state="translated">リレーション内のフォーク番号。 &lt;code&gt;include/common/relpath.h&lt;/code&gt; を参照してください</target>
        </trans-unit>
        <trans-unit id="bfff5fab0567decaa660bb51d870a4a558ade9bd" translate="yes" xml:space="preserve">
          <source>Form feed (ASCII 12)</source>
          <target state="translated">フォームフィード(ASCII 12</target>
        </trans-unit>
        <trans-unit id="2186cd568d6445c67ce20f9b2564241918cf9481" translate="yes" xml:space="preserve">
          <source>Format arguments according to a format string. This function is similar to the C function &lt;code&gt;sprintf&lt;/code&gt;. See &lt;a href=&quot;functions-string#FUNCTIONS-STRING-FORMAT&quot;&gt;Section 9.4.1&lt;/a&gt;.</source>
          <target state="translated">書式文字列に従って引数を書式設定します。この関数は、C関数 &lt;code&gt;sprintf&lt;/code&gt; に似ています。&lt;a href=&quot;functions-string#FUNCTIONS-STRING-FORMAT&quot;&gt;セクション9.4.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2f10703a114eeb65e11771dfbfc8cbc068e4d983" translate="yes" xml:space="preserve">
          <source>Format of the &lt;code&gt;.dict&lt;/code&gt; file is:</source>
          <target state="translated">&lt;code&gt;.dict&lt;/code&gt; ファイルの形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d32d1fc793b4203a324b693b7b245d9ad6dbbf1f" translate="yes" xml:space="preserve">
          <source>Format specifiers are introduced by a &lt;code&gt;%&lt;/code&gt; character and have the form</source>
          <target state="translated">書式指定子は &lt;code&gt;%&lt;/code&gt; 文字で始まり、次の形式になります。</target>
        </trans-unit>
        <trans-unit id="ac4e3c929fdec4f6080024051a0ba50e01f4af70" translate="yes" xml:space="preserve">
          <source>Formatting Functions</source>
          <target state="translated">書式設定機能</target>
        </trans-unit>
        <trans-unit id="27f02bbdc243505380802862dfc269e6f51a4b71" translate="yes" xml:space="preserve">
          <source>Formatting of currency amounts</source>
          <target state="translated">通貨金額の書式設定</target>
        </trans-unit>
        <trans-unit id="3117b3b2c7e85f24cb15daec9ea8d347a5a664b1" translate="yes" xml:space="preserve">
          <source>Formatting of dates and times</source>
          <target state="translated">日付と時間の書式設定</target>
        </trans-unit>
        <trans-unit id="860fd1b538482a0032ad8bac4633d0f2e1fcba7b" translate="yes" xml:space="preserve">
          <source>Formatting of numbers</source>
          <target state="translated">数字の書式設定</target>
        </trans-unit>
        <trans-unit id="6a1f6ab661d4c193244f17d409e7e72bd4d570ee" translate="yes" xml:space="preserve">
          <source>Fortunately, PostgreSQL has the ability to combine multiple indexes (including multiple uses of the same index) to handle cases that cannot be implemented by single index scans. The system can form &lt;code&gt;AND&lt;/code&gt; and &lt;code&gt;OR&lt;/code&gt; conditions across several index scans. For example, a query like &lt;code&gt;WHERE x = 42 OR x = 47 OR x = 53 OR x = 99&lt;/code&gt; could be broken down into four separate scans of an index on &lt;code&gt;x&lt;/code&gt;, each scan using one of the query clauses. The results of these scans are then ORed together to produce the result. Another example is that if we have separate indexes on &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, one possible implementation of a query like &lt;code&gt;WHERE x = 5 AND y = 6&lt;/code&gt; is to use each index with the appropriate query clause and then AND together the index results to identify the result rows.</source>
          <target state="translated">幸い、PostgreSQLは複数のインデックス（同じインデックスの複数の使用を含む）を組み合わせて、単一のインデックススキャンでは実装できないケースを処理する機能を備えています。システムは、複数のインデックススキャンにわたって &lt;code&gt;AND&lt;/code&gt; および &lt;code&gt;OR&lt;/code&gt; 条件を形成できます。たとえば、 &lt;code&gt;WHERE x = 42 OR x = 47 OR x = 53 OR x = 99&lt;/code&gt; ようなクエリは、 &lt;code&gt;x&lt;/code&gt; のインデックスの4つの個別のスキャンに分割でき、各スキャンはクエリ句の1つを使用します。これらのスキャンの結果はORされて結果が生成されます。別の例は、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; に個別のインデックスがある場合、 &lt;code&gt;WHERE x = 5 AND y = 6&lt;/code&gt; ようなクエリの可能な実装の1つです。 適切なクエリ句で各インデックスを使用し、インデックスの結果をANDで結合して、結果の行を特定します。</target>
        </trans-unit>
        <trans-unit id="7a4530052e4c5506e1ca3c7fe0019b4ab8ad7aeb" translate="yes" xml:space="preserve">
          <source>Forward transition function for moving-aggregate mode (zero if none)</source>
          <target state="translated">移動アグリゲートモードの順方向遷移機能(ない場合はゼロ</target>
        </trans-unit>
        <trans-unit id="f6bf4e66e6e60c9947bd8c75fee01c881afbe844" translate="yes" xml:space="preserve">
          <source>Fourth, verify your shell is operating in the &lt;code&gt;unconfined_t&lt;/code&gt; domain:</source>
          <target state="translated">4番目に、シェルが &lt;code&gt;unconfined_t&lt;/code&gt; ドメインで動作していることを確認します。</target>
        </trans-unit>
        <trans-unit id="3b72b0d434a6da3b7a140f72c4533ea003e1049d" translate="yes" xml:space="preserve">
          <source>Fraction of column entries that are null</source>
          <target state="translated">ヌルである列エントリの割合</target>
        </trans-unit>
        <trans-unit id="05336909662a05ee4c216375dd2926cd06ca7ff1" translate="yes" xml:space="preserve">
          <source>Free Space Map</source>
          <target state="translated">フリースペースマップ</target>
        </trans-unit>
        <trans-unit id="8d1442f2468898b3b97983d4c108633f0dd9704b" translate="yes" xml:space="preserve">
          <source>Free space</source>
          <target state="translated">フリースペース</target>
        </trans-unit>
        <trans-unit id="b845fdaff1bf49c014dff506cfa6bdc63dadd835" translate="yes" xml:space="preserve">
          <source>FreeBSD</source>
          <target state="translated">FreeBSD</target>
        </trans-unit>
        <trans-unit id="eba92e8cbbcf79124e18b38dc9296cb1e7b3c90c" translate="yes" xml:space="preserve">
          <source>FreeBSD also allows changing the time source on the fly, and it logs information about the timer selected during boot:</source>
          <target state="translated">FreeBSD では、その場で時間ソースを変更することもできますし、起動時に選択されたタイマーの情報をログに記録します。</target>
        </trans-unit>
        <trans-unit id="163ea5dad4eb636b98f8ad7f2021b2c2146c890b" translate="yes" xml:space="preserve">
          <source>FreeBSD libcrypt</source>
          <target state="translated">FreeBSD libcrypt</target>
        </trans-unit>
        <trans-unit id="28073e04cfc0b55e307bd7ab2f2fab043889d334" translate="yes" xml:space="preserve">
          <source>FreeBSD versions before 4.0 work like old OpenBSD (see below).</source>
          <target state="translated">4.0 以前の FreeBSD のバージョンは、古い OpenBSD (以下を参照)のように動作します。</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">よくある質問</target>
        </trans-unit>
        <trans-unit id="bbd6e32ee1326237814b697269b4368033d50d2f" translate="yes" xml:space="preserve">
          <source>Fri</source>
          <target state="translated">Fri</target>
        </trans-unit>
        <trans-unit id="d166e844a3f3f87149cc4f866eb998e9a751c72a" translate="yes" xml:space="preserve">
          <source>Friday</source>
          <target state="translated">Friday</target>
        </trans-unit>
        <trans-unit id="0092eefda9395145cd29888b2348888692bc90be" translate="yes" xml:space="preserve">
          <source>From PostgreSQL 11, adding a column with a constant default value no longer means that each row of the table needs to be updated when the &lt;code&gt;ALTER TABLE&lt;/code&gt; statement is executed. Instead, the default value will be returned the next time the row is accessed, and applied when the table is rewritten, making the &lt;code&gt;ALTER TABLE&lt;/code&gt; very fast even on large tables.</source>
          <target state="translated">PostgreSQL 11以降では、デフォルト値が一定の列を追加しても、 &lt;code&gt;ALTER TABLE&lt;/code&gt; ステートメントの実行時にテーブルの各行を更新する必要がなくなりました。代わりに、次に行にアクセスしたときにデフォルト値が返され、テーブルが書き換えられたときに適用されるため、大きなテーブルでも &lt;code&gt;ALTER TABLE&lt;/code&gt; が非常に高速になります。</target>
        </trans-unit>
        <trans-unit id="74866cf8a85ad43b25b0fa833b5c4a9e7721fc2f" translate="yes" xml:space="preserve">
          <source>From PostgreSQL 8.3 on, there is XML-related functionality based on the SQL/XML standard in the core server. That functionality covers XML syntax checking and XPath queries, which is what this module does, and more, but the API is not at all compatible. It is planned that this module will be removed in a future version of PostgreSQL in favor of the newer standard API, so you are encouraged to try converting your applications. If you find that some of the functionality of this module is not available in an adequate form with the newer API, please explain your issue to &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:pgsql-hackers@lists.postgresql.org&quot;&gt;pgsql-hackers@lists.postgresql.org&lt;/a&gt;&amp;gt;&lt;/code&gt; so that the deficiency can be addressed.</source>
          <target state="translated">PostgreSQL 8.3以降、コアサーバーにはSQL / XML標準に基づくXML関連の機能があります。この機能は、XML構文チェックとXPathクエリをカバーします。これは、このモジュールが行う機能などですが、APIにはまったく互換性がありません。このモジュールはPostgreSQLの将来のバージョンで削除され、新しい標準APIが採用される予定です。そのため、アプリケーションの変換を試すことをお勧めします。このモジュールの一部の機能が新しいAPIで適切な形式で利用できない場合は、問題を &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:pgsql-hackers@lists.postgresql.org&quot;&gt;pgsql-hackers@lists.postgresql.org&lt;/a&gt;&amp;gt;&lt;/code&gt; 説明して、欠陥に対処できるようにしてください。</target>
        </trans-unit>
        <trans-unit id="278d8abdb35f5b8d4b7f92c6d932b66d8fe44745" translate="yes" xml:space="preserve">
          <source>From experience, values in the thousands (e.g., 5000 &amp;mdash; 20000) work well.</source>
          <target state="translated">経験から、数千の値（5000〜20000など）が適切に機能します。</target>
        </trans-unit>
        <trans-unit id="a9f490fca8caa246230fe49e0dcc7c45a0810a07" translate="yes" xml:space="preserve">
          <source>From the point of view of the issuing session, &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; is not unlike a &lt;code&gt;ROLLBACK&lt;/code&gt; command: after executing it, there is no active current transaction, and the effects of the prepared transaction are no longer visible. (The effects will become visible again if the transaction is committed.)</source>
          <target state="translated">発行セッションの観点から見ると、 &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; は &lt;code&gt;ROLLBACK&lt;/code&gt; コマンドと同様です。実行後、アクティブな現在のトランザクションはなくなり、準備されたトランザクションの影響は見えなくなります。 （トランザクションがコミットされると、効果が再び見えるようになります。）</target>
        </trans-unit>
        <trans-unit id="2047a74f4a2930f4b44969e9f4cae7215400249e" translate="yes" xml:space="preserve">
          <source>Frontend code should not include any &lt;code&gt;pg_xxx.h&lt;/code&gt; catalog header file, as these files may contain C code that won't compile outside the backend. (Typically, that happens because these files also contain declarations for functions in &lt;code&gt;src/backend/catalog/&lt;/code&gt; files.) Instead, frontend code may include the corresponding generated &lt;code&gt;pg_xxx_d.h&lt;/code&gt; header, which will contain OID &lt;code&gt;#define&lt;/code&gt;s and any other data that might be of use on the client side. If you want macros or other code in a catalog header to be visible to frontend code, write &lt;code&gt;#ifdef EXPOSE_TO_CLIENT_CODE&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; around that section to instruct &lt;code&gt;genbki.pl&lt;/code&gt; to copy that section to the &lt;code&gt;pg_xxx_d.h&lt;/code&gt; header.</source>
          <target state="translated">フロントエンドコードには、 &lt;code&gt;pg_xxx.h&lt;/code&gt; カタログヘッダーファイルを含めないでください。これらのファイルには、バックエンド外でコンパイルできないCコードが含まれている可能性があるためです。（通常、これらのファイルには &lt;code&gt;src/backend/catalog/&lt;/code&gt; ファイル内の関数の宣言も含まれているために発生します。）その代わりに、フロントエンドコードには、対応する生成された &lt;code&gt;pg_xxx_d.h&lt;/code&gt; ヘッダーが含まれ、OID &lt;code&gt;#define&lt;/code&gt; とその他のデータが含まれますクライアント側で使用する。カタログヘッダー内のマクロまたは他のコードをしたい場合は、コード、書き込みフロントエンドに見えるようにする &lt;code&gt;#ifdef EXPOSE_TO_CLIENT_CODE&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; のを指示しにそのセクションの周り &lt;code&gt;genbki.pl&lt;/code&gt; にそのセクションをコピーし &lt;code&gt;pg_xxx_d.h&lt;/code&gt; ヘッダ。</target>
        </trans-unit>
        <trans-unit id="5342caa1027afd1b462e71637b0394a8eb14ac7b" translate="yes" xml:space="preserve">
          <source>Frontend/Backend Protocol</source>
          <target state="translated">フロントエンド/バックエンドプロトコル</target>
        </trans-unit>
        <trans-unit id="6b2e86b36efeac1ca193b435611b528921adc671" translate="yes" xml:space="preserve">
          <source>Full Text Search</source>
          <target state="translated">全文検索</target>
        </trans-unit>
        <trans-unit id="58bab05efd3bb13a137c704cfe50139caf2da01d" translate="yes" xml:space="preserve">
          <source>Full Text Searching (or just &lt;em&gt;text search&lt;/em&gt;) provides the capability to identify natural-language &lt;em&gt;documents&lt;/em&gt; that satisfy a &lt;em&gt;query&lt;/em&gt;, and optionally to sort them by relevance to the query. The most common type of search is to find all documents containing given &lt;em&gt;query terms&lt;/em&gt; and return them in order of their &lt;em&gt;similarity&lt;/em&gt; to the query. Notions of &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;similarity&lt;/code&gt; are very flexible and depend on the specific application. The simplest search considers &lt;code&gt;query&lt;/code&gt; as a set of words and &lt;code&gt;similarity&lt;/code&gt; as the frequency of query words in the document.</source>
          <target state="translated">全文検索（または単に&lt;em&gt;テキスト検索&lt;/em&gt;）は、&lt;em&gt;クエリ&lt;/em&gt;を満たす自然言語&lt;em&gt;ドキュメント&lt;/em&gt;を識別し、オプションで&lt;em&gt;クエリ&lt;/em&gt;との関連性によってそれらをソートする機能を提供します。最も一般的なタイプの検索は、指定された&lt;em&gt;クエリ用語&lt;/em&gt;を含むすべてのドキュメントを検索し、それらをクエリとの&lt;em&gt;類似性の&lt;/em&gt;順に返すことです。 &lt;code&gt;query&lt;/code&gt; と &lt;code&gt;similarity&lt;/code&gt; 概念は非常に柔軟で、特定のアプリケーションに依存します。最も単純な検索では、 &lt;code&gt;query&lt;/code&gt; を単語のセットと見なし、 &lt;code&gt;similarity&lt;/code&gt; をドキュメント内のクエリ単語の頻度と見なします。</target>
        </trans-unit>
        <trans-unit id="db82b334faa95ac9dd9f6513348aba4908da1917" translate="yes" xml:space="preserve">
          <source>Full knowledge of running transactions is required before snapshots can be taken. Transactions that use large numbers of subtransactions (currently greater than 64) will delay the start of read only connections until the completion of the longest running write transaction. If this situation occurs, explanatory messages will be sent to the server log.</source>
          <target state="translated">スナップショットを取得する前に、実行中のトランザクションを完全に把握しておく必要があります。多数のサブトランザクションを使用するトランザクション (現在は 64 より大きい)は、最も長く実行されている書き込みトランザクションが完了するまで、読み取り専用の接続の開始を遅延させます。このような状況が発生した場合、説明メッセージがサーバログに送信されます。</target>
        </trans-unit>
        <trans-unit id="0c4e89b5598c4c2f96620f236425e65a764b4e0c" translate="yes" xml:space="preserve">
          <source>Full path name of the configuration file</source>
          <target state="translated">設定ファイルのフルパス名</target>
        </trans-unit>
        <trans-unit id="f75d588686a67b50b8825a6ec9a2cd0fa788d6f1" translate="yes" xml:space="preserve">
          <source>Full text indexing allows documents to be &lt;em&gt;preprocessed&lt;/em&gt; and an index saved for later rapid searching. Preprocessing includes:</source>
          <target state="translated">全文索引付けにより、文書を&lt;em&gt;前処理&lt;/em&gt;し、後で迅速に検索できるように索引を保存できます。前処理には以下が含まれます。</target>
        </trans-unit>
        <trans-unit id="1e173192dc3f0eff1cb3f86ab840c4e44f26a1a2" translate="yes" xml:space="preserve">
          <source>Full text searching in PostgreSQL is based on the match operator &lt;code&gt;@@&lt;/code&gt;, which returns &lt;code&gt;true&lt;/code&gt; if a &lt;code&gt;tsvector&lt;/code&gt; (document) matches a &lt;code&gt;tsquery&lt;/code&gt; (query). It doesn't matter which data type is written first:</source>
          <target state="translated">PostgreSQLでの全文検索は、 &lt;code&gt;tsvector&lt;/code&gt; （ドキュメント）が &lt;code&gt;tsquery&lt;/code&gt; （クエリ）と一致する場合に &lt;code&gt;true&lt;/code&gt; を返す一致演算子 &lt;code&gt;@@&lt;/code&gt; に基づいています。どのデータ型が最初に書き込まれるかは関係ありません。</target>
        </trans-unit>
        <trans-unit id="31ad0600481ef9dcfec15d2c9583987bbeea5538" translate="yes" xml:space="preserve">
          <source>Full time zone name</source>
          <target state="translated">フルタイムゾーン名</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="199b395518a17474f39a98683e459c8710d22bf0" translate="yes" xml:space="preserve">
          <source>Function (degrees)</source>
          <target state="translated">機能(度)</target>
        </trans-unit>
        <trans-unit id="c4cdc4b98800828d365361d7093d5e13c470e528" translate="yes" xml:space="preserve">
          <source>Function (radians)</source>
          <target state="translated">関数(ラジアン)</target>
        </trans-unit>
        <trans-unit id="e3ebe4e72fe78109751ae6020102e21b46343c0b" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;concat_lower_or_upper&lt;/code&gt; has two mandatory parameters, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Additionally there is one optional parameter &lt;code&gt;uppercase&lt;/code&gt; which defaults to &lt;code&gt;false&lt;/code&gt;. The &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; inputs will be concatenated, and forced to either upper or lower case depending on the &lt;code&gt;uppercase&lt;/code&gt; parameter. The remaining details of this function definition are not important here (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend.html&quot;&gt;Chapter 37&lt;/a&gt; for more information).</source>
          <target state="translated">関数 &lt;code&gt;concat_lower_or_upper&lt;/code&gt; には、2つの必須パラメーター &lt;code&gt;a&lt;/code&gt; および &lt;code&gt;b&lt;/code&gt; があります。さらに、デフォルトで &lt;code&gt;false&lt;/code&gt; に設定されている &lt;code&gt;uppercase&lt;/code&gt; オプションパラメータが1つあります。 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; 入力が連結され、そしていずれかの大文字または小文字に応じに強制される &lt;code&gt;uppercase&lt;/code&gt; のパラメータ。この関数定義の残りの詳細はここでは重要ではありません（詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/extend.html&quot;&gt;第37章を&lt;/a&gt;参照してください）。</target>
        </trans-unit>
        <trans-unit id="a9485768ec808a8458b8061522775420e2a0d736" translate="yes" xml:space="preserve">
          <source>Function Calls in &lt;code&gt;FROM&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; での関数呼び出し</target>
        </trans-unit>
        <trans-unit id="5cd7aa6580361c1c90294750468e2a6e5d51165d" translate="yes" xml:space="preserve">
          <source>Function Security</source>
          <target state="translated">機能セキュリティ</target>
        </trans-unit>
        <trans-unit id="307d58da1cb5c708acf50f78b41a528827c81cf8" translate="yes" xml:space="preserve">
          <source>Function calls</source>
          <target state="translated">関数呼び出し</target>
        </trans-unit>
        <trans-unit id="8b07e5d5a0f30facf481faff6183bfd24366f034" translate="yes" xml:space="preserve">
          <source>Function calls can appear in the &lt;code&gt;FROM&lt;/code&gt; clause. (This is especially useful for functions that return result sets, but any function can be used.) This acts as though the function's output were created as a temporary table for the duration of this single &lt;code&gt;SELECT&lt;/code&gt; command. When the optional &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause is added to the function call, a new column is appended after all the function's output columns with numbering for each row.</source>
          <target state="translated">関数呼び出しは &lt;code&gt;FROM&lt;/code&gt; 句で使用できます。（これは、結果セットを返す関数に特に役立ちますが、任意の関数を使用できます。）これは、この単一の &lt;code&gt;SELECT&lt;/code&gt; コマンドの期間中、関数の出力が一時テーブルとして作成されたかのように機能します。オプションの &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 句を関数呼び出しに追加すると、すべての関数の出力列の後に、行ごとに番号が付けられた新しい列が追加されます。</target>
        </trans-unit>
        <trans-unit id="b4946fa700c9eda6e438f9d998236ae26798c94a" translate="yes" xml:space="preserve">
          <source>Function is a security definer (i.e., a &amp;ldquo;setuid&amp;rdquo; function)</source>
          <target state="translated">関数はセキュリティ定義者（つまり、「setuid」関数）です</target>
        </trans-unit>
        <trans-unit id="716c6238c1da557cf03815f10e855bae3322359c" translate="yes" xml:space="preserve">
          <source>Function returns a set (i.e., multiple values of the specified data type)</source>
          <target state="translated">この関数は、セット(すなわち、指定されたデータ型の複数の値)を返します。</target>
        </trans-unit>
        <trans-unit id="23fbe0cb5a01469d890d631e094cc17384405a30" translate="yes" xml:space="preserve">
          <source>Function returns null if any call argument is null. In that case the function won't actually be called at all. Functions that are not &amp;ldquo;strict&amp;rdquo; must be prepared to handle null inputs.</source>
          <target state="translated">いずれかの呼び出し引数がnullの場合、関数はnullを返します。その場合、関数は実際にはまったく呼び出されません。「厳密」ではない関数は、ヌル入力を処理できるように準備する必要があります。</target>
        </trans-unit>
        <trans-unit id="8fd90f4b1717187c9f3e3d19223db85d2f734625" translate="yes" xml:space="preserve">
          <source>Function that implements this operator</source>
          <target state="translated">この演算子を実装した関数</target>
        </trans-unit>
        <trans-unit id="3d160cc011b485e39a85d5d485371501ec7cfb5f" translate="yes" xml:space="preserve">
          <source>Function's local settings for run-time configuration variables</source>
          <target state="translated">実行時設定変数の関数のローカル設定</target>
        </trans-unit>
        <trans-unit id="72f655d0260fed163ce26bf8c073ff029ead93e0" translate="yes" xml:space="preserve">
          <source>Functional Dependencies</source>
          <target state="translated">機能的な依存関係</target>
        </trans-unit>
        <trans-unit id="5ff8dd38721f013a6f2f4a7b0736888d581a5d95" translate="yes" xml:space="preserve">
          <source>Functional dependencies are currently only applied when considering simple equality conditions that compare columns to constant values. They are not used to improve estimates for equality conditions comparing two columns or comparing a column to an expression, nor for range clauses, &lt;code&gt;LIKE&lt;/code&gt; or any other type of condition.</source>
          <target state="translated">現在、関数の依存関係は、列を定数値と比較する単純な等価条件を検討する場合にのみ適用されます。これらは、2つの列を比較したり、列を式と比較した等値条件や、範囲句、 &lt;code&gt;LIKE&lt;/code&gt; 、またはその他のタイプの条件の推定を改善するためには使用されません。</target>
        </trans-unit>
        <trans-unit id="c1d8fc0143ef31c2eddcaedc63b8975839dcb0a6" translate="yes" xml:space="preserve">
          <source>Functional dependency statistics</source>
          <target state="translated">機能依存性の統計</target>
        </trans-unit>
        <trans-unit id="66e4b5d56651ee62066b47e8179cf0572f0a44de" translate="yes" xml:space="preserve">
          <source>Functional dependency statistics, serialized as &lt;code&gt;pg_dependencies&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;pg_dependencies&lt;/code&gt; タイプとしてシリアル化された機能依存統計</target>
        </trans-unit>
        <trans-unit id="79fde2ac8490ff2b99ac9c9890e046fdff6e3659" translate="yes" xml:space="preserve">
          <source>Functionality</source>
          <target state="translated">Functionality</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="4bc6ed2a77aad7bfa2b82a40e38f2ba52fbf90bc" translate="yes" xml:space="preserve">
          <source>Functions &lt;code&gt;justify_days&lt;/code&gt; and &lt;code&gt;justify_hours&lt;/code&gt; are available for adjusting days and hours that overflow their normal ranges.</source>
          <target state="translated">関数 &lt;code&gt;justify_days&lt;/code&gt; と &lt;code&gt;justify_hours&lt;/code&gt; は、通常の範囲をオーバーフローする日と時間を調整するために使用できます。</target>
        </trans-unit>
        <trans-unit id="be003abde8f2ab71ad33e1cc06ea3dd303feedda" translate="yes" xml:space="preserve">
          <source>Functions and Operators</source>
          <target state="translated">機能と演算子</target>
        </trans-unit>
        <trans-unit id="c65bb1eea1a55d451d6926238ca1817228c00025" translate="yes" xml:space="preserve">
          <source>Functions and aggregates must be marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; if they write to the database, access sequences, change the transaction state even temporarily (e.g. a PL/pgSQL function which establishes an &lt;code&gt;EXCEPTION&lt;/code&gt; block to catch errors), or make persistent changes to settings. Similarly, functions must be marked &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; if they access temporary tables, client connection state, cursors, prepared statements, or miscellaneous backend-local state which the system cannot synchronize across workers. For example, &lt;code&gt;setseed&lt;/code&gt; and &lt;code&gt;random&lt;/code&gt; are parallel restricted for this last reason.</source>
          <target state="translated">関数と集約は、データベースへの書き込み、シーケンスへのアクセス、トランザクション状態の一時的な変更（例：エラーをキャッチするための &lt;code&gt;EXCEPTION&lt;/code&gt; ブロックを確立するPL / pgSQL関数）、または設定に永続的な変更を &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; 場合は、PARALLEL UNSAFEとマークする必要があります。同様に、関数が一時テーブル、クライアント接続状態、カーソル、準備されたステートメント、またはシステムがワーカー間で同期できないその他のバックエンドローカル状態にアクセスする場合は、関数を &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; とマークする必要があります。たとえば、この最後の理由により、 &lt;code&gt;setseed&lt;/code&gt; と &lt;code&gt;random&lt;/code&gt; は並行して制限されます。</target>
        </trans-unit>
        <trans-unit id="2fe9555fcfd38cd02c2b84229962727f96f4f2eb" translate="yes" xml:space="preserve">
          <source>Functions and most operators return &lt;code&gt;NULL&lt;/code&gt; on &lt;code&gt;NULL&lt;/code&gt; input.</source>
          <target state="translated">関数とほとんどの演算子は、 &lt;code&gt;NULL&lt;/code&gt; 入力で &lt;code&gt;NULL&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="0f265f85b070748c539b48bb2df1919c8d0132ab" translate="yes" xml:space="preserve">
          <source>Functions and operators that can be used in filter expressions are listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-FILTER-EX-TABLE&quot;&gt;Table 9.49&lt;/a&gt;. The path evaluation result to be filtered is denoted by the &lt;code&gt;@&lt;/code&gt; variable. To refer to a JSON element stored at a lower nesting level, add one or more accessor operators after &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">フィルター式で使用できる関数と演算子を&lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-FILTER-EX-TABLE&quot;&gt;表9.49に示し&lt;/a&gt;ます。フィルタリングされるパス評価結果は、 &lt;code&gt;@&lt;/code&gt; 変数で示されます。下位のネストレベルに格納されているJSON要素を参照するには、 &lt;code&gt;@&lt;/code&gt; の後に1つ以上のアクセサー演算子を追加します。</target>
        </trans-unit>
        <trans-unit id="898ae4ce80d1416da1e82be5528ff4ee3420d0cc" translate="yes" xml:space="preserve">
          <source>Functions are provided to support input in latitude and longitude (in degrees), to support output of latitude and longitude, to calculate the great circle distance between two points and to easily specify a bounding box usable for index searches.</source>
          <target state="translated">緯度経度(度)での入力支援、緯度経度の出力支援、2点間の大円距離の計算、インデックス検索に利用できる境界線を簡単に指定できる機能が用意されています。</target>
        </trans-unit>
        <trans-unit id="363d6f73b8773f17e3ee7b55c329af36a576dd3e" translate="yes" xml:space="preserve">
          <source>Functions coded in C (whether built-in or dynamically loaded) can be declared to accept or return any of these pseudo data types. It is up to the function author to ensure that the function will behave safely when a pseudo-type is used as an argument type.</source>
          <target state="translated">C言語でコーディングされた関数(組み込みでも動的にロードされたものでも)は、これらの疑似データ型のいずれかを受け入れたり返したりするように宣言することができます。疑似データ型が引数型として使用されている場合に、関数が安全に動作するかどうかは関数の作者次第です。</target>
        </trans-unit>
        <trans-unit id="357d435e84354e072901789e999d5e8184ddfdf6" translate="yes" xml:space="preserve">
          <source>Functions coded in procedural languages can use pseudo-types only as allowed by their implementation languages. At present most procedural languages forbid use of a pseudo-type as an argument type, and allow only &lt;code&gt;void&lt;/code&gt; and &lt;code&gt;record&lt;/code&gt; as a result type (plus &lt;code&gt;trigger&lt;/code&gt; or &lt;code&gt;event_trigger&lt;/code&gt; when the function is used as a trigger or event trigger). Some also support polymorphic functions using the types &lt;code&gt;anyelement&lt;/code&gt;, &lt;code&gt;anyarray&lt;/code&gt;, &lt;code&gt;anynonarray&lt;/code&gt;, &lt;code&gt;anyenum&lt;/code&gt;, and &lt;code&gt;anyrange&lt;/code&gt;.</source>
          <target state="translated">手続き型言語でコード化された関数は、実装言語で許可されている場合にのみ疑似型を使用できます。現在、ほとんどの手続き型言語は、引数型としての疑似型の使用を禁止し、結果型として &lt;code&gt;void&lt;/code&gt; と &lt;code&gt;record&lt;/code&gt; のみを許可しています（関数がトリガーまたはイベントトリガーとして使用されている場合は、 &lt;code&gt;trigger&lt;/code&gt; または &lt;code&gt;event_trigger&lt;/code&gt; ）。また、 &lt;code&gt;anyelement&lt;/code&gt; 、 &lt;code&gt;anyarray&lt;/code&gt; 、 &lt;code&gt;anynonarray&lt;/code&gt; 、 &lt;code&gt;anyenum&lt;/code&gt; 、および &lt;code&gt;anyrange&lt;/code&gt; のタイプを使用して多態性関数をサポートするものもあります。</target>
        </trans-unit>
        <trans-unit id="4a3e904c1371583b52ebdd3a3d3f52a9437f4a8d" translate="yes" xml:space="preserve">
          <source>Functions run inside the backend server process with the operating system permissions of the database server daemon. If the programming language used for the function allows unchecked memory accesses, it is possible to change the server's internal data structures. Hence, among many other things, such functions can circumvent any system access controls. Function languages that allow such access are considered &amp;ldquo;untrusted&amp;rdquo;, and PostgreSQL allows only superusers to create functions written in those languages.</source>
          <target state="translated">関数は、データベースサーバーデーモンのオペレーティングシステム権限でバックエンドサーバープロセス内で実行されます。関数に使用されているプログラミング言語でチェックされていないメモリアクセスが許可されている場合、サーバーの内部データ構造を変更することができます。したがって、他の多くの機能の中でも、このような機能はシステムのアクセス制御を回避できます。そのようなアクセスを許可する関数言語は「信頼できない」と見なされ、PostgreSQLはスーパーユーザーのみがそれらの言語で記述された関数を作成することを許可します。</target>
        </trans-unit>
        <trans-unit id="425b58ada88d6e2c4cd54b7ad94f94b6cfbbbdae" translate="yes" xml:space="preserve">
          <source>Functions should be labeled parallel unsafe if they modify any database state, or if they make changes to the transaction such as using sub-transactions, or if they access sequences or attempt to make persistent changes to settings (e.g. &lt;code&gt;setval&lt;/code&gt;). They should be labeled as parallel restricted if they access temporary tables, client connection state, cursors, prepared statements, or miscellaneous backend-local state which the system cannot synchronize in parallel mode (e.g. &lt;code&gt;setseed&lt;/code&gt; cannot be executed other than by the group leader because a change made by another process would not be reflected in the leader). In general, if a function is labeled as being safe when it is restricted or unsafe, or if it is labeled as being restricted when it is in fact unsafe, it may throw errors or produce wrong answers when used in a parallel query. C-language functions could in theory exhibit totally undefined behavior if mislabeled, since there is no way for the system to protect itself against arbitrary C code, but in most likely cases the result will be no worse than for any other function. If in doubt, functions should be labeled as &lt;code&gt;UNSAFE&lt;/code&gt;, which is the default.</source>
          <target state="translated">関数は、データベースの状態を変更する場合、サブトランザクションの使用などのトランザクションに変更を加える場合、またはシーケンスにアクセスしたり、設定（たとえば &lt;code&gt;setval&lt;/code&gt; ）に永続的な変更を加えようとする場合、並列安全でないとラベル付けする必要があります。一時テーブル、クライアント接続状態、カーソル、準備されたステートメント、またはシステムが並列モードで同期できないその他のバックエンドローカル状態（ &lt;code&gt;setseed&lt;/code&gt; など)にアクセスする場合、それらは並列制限付きとしてラベル付けする必要があります。別のプロセスによる変更はリーダーに反映されないため、グループリーダー以外は実行できません）。一般に、関数が制限付きまたは安全でないときに安全であるとラベル付けされている場合、または関数が実際には安全でないときに制限付きであるとラベル付けされている場合、並列クエリで使用するとエラーがスローされるか、間違った回答が生成されることがあります。システムが任意のCコードからシステムを保護する方法がないため、C言語関数は理論上、誤ってラベル付けされた場合、完全に未定義の動作を示す可能性がありますが、ほとんどの場合、結果は他の関数よりも悪くはありません。疑わしい場合は、関数に &lt;code&gt;UNSAFE&lt;/code&gt; というラベルを付ける必要があります。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="b84230860ab5761ae6c39a0cf038afa0e0d25690" translate="yes" xml:space="preserve">
          <source>Functions that display information about &lt;code&gt;PD_ALL_VISIBLE&lt;/code&gt; bits are much more costly than those that only consult the visibility map, because they must read the relation's data blocks rather than only the (much smaller) visibility map. Functions that check the relation's data blocks are similarly expensive.</source>
          <target state="translated">&lt;code&gt;PD_ALL_VISIBLE&lt;/code&gt; ビットに関する情報を表示する関数は、（はるかに小さい）可視性マップだけではなく、リレーションのデータブロックを読み取る必要があるため、可視性マップのみを参照する関数よりもはるかにコストがかかります。リレーションのデータブロックをチェックする関数も同様にコストがかかります。</target>
        </trans-unit>
        <trans-unit id="bdbee713b789a01d106896990329fe65f45aec42" translate="yes" xml:space="preserve">
          <source>Functions that have default values for parameters are considered to match any call that omits zero or more of the defaultable parameter positions. If more than one such function matches a call, the one appearing earliest in the search path is used. If there are two or more such functions in the same schema with identical parameter types in the non-defaulted positions (which is possible if they have different sets of defaultable parameters), the system will not be able to determine which to prefer, and so an &amp;ldquo;ambiguous function call&amp;rdquo; error will result if no better match to the call can be found.</source>
          <target state="translated">パラメータのデフォルト値を持つ関数は、デフォルト設定可能なパラメータ位置の0個以上を省略した呼び出しと一致すると見なされます。複数のそのような関数が呼び出しに一致する場合、検索パスで最初に出現する関数が使用されます。デフォルトではない位置に同じパラメータータイプを持つ同じスキーマにそのような関数が2つ以上ある場合（デフォルト設定可能なパラメーターのセットが異なる場合に可能です）、システムはどちらを優先するかを決定できません。 「あいまいな関数呼び出し」エラーは、呼び出しに一致するものが見つからない場合に発生します。</target>
        </trans-unit>
        <trans-unit id="968a1bb51fb8e88d31fbc6fa43c7108e8557e4b7" translate="yes" xml:space="preserve">
          <source>Functions that have different argument type lists will not be considered to conflict at creation time, but if defaults are provided they might conflict in use. For example, consider</source>
          <target state="translated">異なる引数型リストを持つ関数は、作成時には競合しないと考えられますが、デフォルトが提供されている場合は、使用時に競合する可能性があります。例えば、次のように考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="135becd421fd7ec3a1d11031f3897f120bbd244e" translate="yes" xml:space="preserve">
          <source>Functions, triggers and row-level security policies allow users to insert code into the backend server that other users might execute unintentionally. Hence, these mechanisms permit users to &amp;ldquo;Trojan horse&amp;rdquo; others with relative ease. The strongest protection is tight control over who can define objects. Where that is infeasible, write queries referring only to objects having trusted owners. Remove from &lt;code&gt;search_path&lt;/code&gt; the public schema and any other schemas that permit untrusted users to create objects.</source>
          <target state="translated">関数、トリガー、および行レベルのセキュリティポリシーにより、ユーザーは、他のユーザーが意図せずに実行する可能性があるコードをバックエンドサーバーに挿入できます。したがって、これらのメカニズムにより、ユーザーは比較的簡単に他のユーザーを「トロイの木馬」にすることができます。最も強力な保護は、オブジェクトを定義できるユーザーを厳密に制御することです。それが実行不可能な場合は、信頼できる所有者がいるオブジェクトのみを参照するクエリを記述します。信頼されていないユーザーがオブジェクトを作成できるようにするパブリックスキーマおよびその他のスキーマを &lt;code&gt;search_path&lt;/code&gt; から削除します。</target>
        </trans-unit>
        <trans-unit id="5108d609f3fb07622f5f3d1be40ac26ef2e0a0a8" translate="yes" xml:space="preserve">
          <source>Functions: Aggregate</source>
          <target state="translated">機能を提供しています。集計</target>
        </trans-unit>
        <trans-unit id="64682352d164f9b71b9cd241b5b867b131e9918f" translate="yes" xml:space="preserve">
          <source>Functions: Array</source>
          <target state="translated">関数です。配列</target>
        </trans-unit>
        <trans-unit id="a17a5cd5398272b5c3db6c42f415d4231dc9dd50" translate="yes" xml:space="preserve">
          <source>Functions: Binary String</source>
          <target state="translated">関数を使用しています。バイナリ文字列</target>
        </trans-unit>
        <trans-unit id="46e7b932a583771eba0b904ed9f4220de160a130" translate="yes" xml:space="preserve">
          <source>Functions: Bit String</source>
          <target state="translated">関数を使用しています。ビット文字列</target>
        </trans-unit>
        <trans-unit id="106e142aa5e330cde3a84b7b845817b28d2e9175" translate="yes" xml:space="preserve">
          <source>Functions: Data Type Formatting</source>
          <target state="translated">関数を使用しています。データ型の書式設定</target>
        </trans-unit>
        <trans-unit id="bfefb2129f2304220f19e00946bdffaabf6dc0e1" translate="yes" xml:space="preserve">
          <source>Functions: Date/Time</source>
          <target state="translated">機能を提供します。日付/時間</target>
        </trans-unit>
        <trans-unit id="9b63eb1b87b1e024896cd43589c27f090399d066" translate="yes" xml:space="preserve">
          <source>Functions: Geometric</source>
          <target state="translated">関数。幾何学的</target>
        </trans-unit>
        <trans-unit id="4d3dafd3b51e63a124d63c626067bce30229ab1f" translate="yes" xml:space="preserve">
          <source>Functions: JSON</source>
          <target state="translated">関数を使用しています。JSON</target>
        </trans-unit>
        <trans-unit id="9b518a3dc41009e3acee3808ac0e704f6b08a5f3" translate="yes" xml:space="preserve">
          <source>Functions: Mathematical</source>
          <target state="translated">関数。数学的</target>
        </trans-unit>
        <trans-unit id="a9c0c6a0475c27e5bdfe98492ed642ea26c29174" translate="yes" xml:space="preserve">
          <source>Functions: Network Address</source>
          <target state="translated">機能を紹介します。ネットワークアドレス</target>
        </trans-unit>
        <trans-unit id="a4976494155f4e6dade31fdc069e51f1a7d1ce69" translate="yes" xml:space="preserve">
          <source>Functions: Range</source>
          <target state="translated">機能を提供します。範囲</target>
        </trans-unit>
        <trans-unit id="b8fcb9bba13dc3a8cc6d595a39daf47631d430a4" translate="yes" xml:space="preserve">
          <source>Functions: Statistics Information</source>
          <target state="translated">機能を提供しています。統計情報</target>
        </trans-unit>
        <trans-unit id="d1ee22b179879e9f873763bb172d33f3017f840e" translate="yes" xml:space="preserve">
          <source>Functions: String</source>
          <target state="translated">関数を使用しています。文字列</target>
        </trans-unit>
        <trans-unit id="6843fcead53a6cf24daa8566fecd89162ab37e7f" translate="yes" xml:space="preserve">
          <source>Functions: System Administration</source>
          <target state="translated">機能をご紹介します。システム管理</target>
        </trans-unit>
        <trans-unit id="a388797fbe7fca428c186d9bd0e36003dc121806" translate="yes" xml:space="preserve">
          <source>Functions: System Information</source>
          <target state="translated">機能をご紹介します。システム情報</target>
        </trans-unit>
        <trans-unit id="6774bc067b00b4a898fa2d81854d9f8ccd1bb6e9" translate="yes" xml:space="preserve">
          <source>Functions: Text Search</source>
          <target state="translated">機能を紹介しています。テキスト検索</target>
        </trans-unit>
        <trans-unit id="1acb35ad39f3bcd2faf73955c2408efc740b8965" translate="yes" xml:space="preserve">
          <source>Functions: Window</source>
          <target state="translated">機能を提供しています。ウィンドウ</target>
        </trans-unit>
        <trans-unit id="4ea9b0534343b6662064e8e66df29f936486dcbe" translate="yes" xml:space="preserve">
          <source>Functions: XML</source>
          <target state="translated">関数を使用しています。XML</target>
        </trans-unit>
        <trans-unit id="be1881053687afed29c0ae862b5bb84c66f949f7" translate="yes" xml:space="preserve">
          <source>Further along the line of common sense, the fuzziness of the limits suggests that the use of traditional numeric data types leads to a certain loss of information. Consider this: your instrument reads 6.50, and you input this reading into the database. What do you get when you fetch it? Watch:</source>
          <target state="translated">さらに常識的に考えれば、限界値の曖昧さは、従来の数値データ型を使用することで情報の損失につながることを示唆しています。このことを考えてみましょう。あなたの計器が6.50を読み取り、この読み取り値をデータベースに入力しました。それを取得すると何が得られますか?見てください。</target>
        </trans-unit>
        <trans-unit id="e2310579f06e5c7b30a8aa96bc1d602f5e9203e6" translate="yes" xml:space="preserve">
          <source>Further assumptions are that the aggregate ignores null inputs, and that it delivers a null result if and only if there were no non-null inputs. Ordinarily, a data type's &lt;code&gt;&amp;lt;&lt;/code&gt; operator is the proper sort operator for &lt;code&gt;MIN&lt;/code&gt;, and &lt;code&gt;&amp;gt;&lt;/code&gt; is the proper sort operator for &lt;code&gt;MAX&lt;/code&gt;. Note that the optimization will never actually take effect unless the specified operator is the &amp;ldquo;less than&amp;rdquo; or &amp;ldquo;greater than&amp;rdquo; strategy member of a B-tree index operator class.</source>
          <target state="translated">さらに、アグリゲートはnull入力を無視し、null以外の入力がなかった場合にのみ、nullの結果を返すと想定しています。通常、データ型の &lt;code&gt;&amp;lt;&lt;/code&gt; 演算子は &lt;code&gt;MIN&lt;/code&gt; の適切なソート演算子であり、 &lt;code&gt;&amp;gt;&lt;/code&gt; は &lt;code&gt;MAX&lt;/code&gt; の適切なソート演算子です。指定された演算子がBツリーインデックス演算子クラスの「より小」または「より大」の戦略メンバーでない限り、最適化が実際に有効になることはありません。</target>
        </trans-unit>
        <trans-unit id="8e3fde8eb12ee9830b9efa317f6db1a2760019c3" translate="yes" xml:space="preserve">
          <source>Further details about the planner's use of statistics can be found in &lt;a href=&quot;https://www.postgresql.org/docs/12/planner-stats-details.html&quot;&gt;Chapter 70&lt;/a&gt;.</source>
          <target state="translated">プランナーによる統計の使用に関する詳細は、&lt;a href=&quot;https://www.postgresql.org/docs/12/planner-stats-details.html&quot;&gt;第70章に&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="80923ff08a3698b44c0358905326ad4315d1f3f8" translate="yes" xml:space="preserve">
          <source>Furthermore, although multiple sessions are guaranteed to allocate distinct sequence values, the values might be generated out of sequence when all the sessions are considered. For example, with a &lt;code&gt;cache&lt;/code&gt; setting of 10, session A might reserve values 1..10 and return &lt;code&gt;nextval&lt;/code&gt;=1, then session B might reserve values 11..20 and return &lt;code&gt;nextval&lt;/code&gt;=11 before session A has generated &lt;code&gt;nextval&lt;/code&gt;=2. Thus, with a &lt;code&gt;cache&lt;/code&gt; setting of one it is safe to assume that &lt;code&gt;nextval&lt;/code&gt; values are generated sequentially; with a &lt;code&gt;cache&lt;/code&gt; setting greater than one you should only assume that the &lt;code&gt;nextval&lt;/code&gt; values are all distinct, not that they are generated purely sequentially. Also, &lt;code&gt;last_value&lt;/code&gt; will reflect the latest value reserved by any session, whether or not it has yet been returned by &lt;code&gt;nextval&lt;/code&gt;.</source>
          <target state="translated">さらに、複数のセッションが個別のシーケンス値を割り当てることが保証されていますが、すべてのセッションが考慮されると、値がシーケンスから生成される場合があります。たとえば、 &lt;code&gt;cache&lt;/code&gt; 設定が10の場合、セッションAは値1..10を予約して &lt;code&gt;nextval&lt;/code&gt; = 1 を返し、セッションBは値11..20を予約して &lt;code&gt;nextval&lt;/code&gt; = 11 を返す前に、セッションAが &lt;code&gt;nextval&lt;/code&gt; = 2 を生成します。したがって、 &lt;code&gt;cache&lt;/code&gt; 設定が1の場合、 &lt;code&gt;nextval&lt;/code&gt; 値が順次生成されると想定しても安全です。 &lt;code&gt;cache&lt;/code&gt; 1より大きいを設定あなただけのことを想定する必要があり &lt;code&gt;nextval&lt;/code&gt; 値はすべて個別であり、純粋に連続して生成されるわけではありません。また、 &lt;code&gt;last_value&lt;/code&gt; それはまだで返されたかどうかを、任意のセッションによって予約最新の値を反映します &lt;code&gt;nextval&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="224c260c1b97921918028686f800ec2a753d6d99" translate="yes" xml:space="preserve">
          <source>Furthermore, if the result of an expression can be determined by evaluating only some parts of it, then other subexpressions might not be evaluated at all. For instance, if one wrote:</source>
          <target state="translated">さらに、ある式の一部だけを評価することで結果が決まる場合、他の副式は全く評価されないかもしれません。例えば、ある人が書いたとします。</target>
        </trans-unit>
        <trans-unit id="c76baa18e3a105ad25a2e47745a365c732d219e6" translate="yes" xml:space="preserve">
          <source>Furthermore, immediately before reporting a uniqueness violation according to the above rules, the access method must recheck the liveness of the row being inserted. If it is committed dead then no violation should be reported. (This case cannot occur during the ordinary scenario of inserting a row that's just been created by the current transaction. It can happen during &lt;code&gt;CREATE UNIQUE INDEX CONCURRENTLY&lt;/code&gt;, however.)</source>
          <target state="translated">さらに、上記の規則に従って一意性違反を報告する直前に、アクセス方法は挿入される行の活性を再確認する必要があります。死んでコミットされた場合、違反は報告されません。（このケースは、現在のトランザクションによって作成されたばかりの行を挿入する通常のシナリオでは発生しません。ただし、 &lt;code&gt;CREATE UNIQUE INDEX CONCURRENTLY&lt;/code&gt; で発生する可能性があります。）</target>
        </trans-unit>
        <trans-unit id="b247028066a34eb255cbd5a7c12a62f7ec515ba5" translate="yes" xml:space="preserve">
          <source>Furthermore, indexes for exclusion constraints cannot be reindexed concurrently. If such an index is named directly in this command, an error is raised. If a table or database with exclusion constraint indexes is reindexed concurrently, those indexes will be skipped. (It is possible to reindex such indexes without the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option.)</source>
          <target state="translated">さらに、除外制約のインデックスを同時に再インデックスすることはできません。このようなインデックスがこのコマンドで直接指定されている場合、エラーが発生します。除外制約インデックスを持つテーブルまたはデータベースが同時に再インデックス付けされる場合、それらのインデックスはスキップされます。（このようなインデックスは、 &lt;code&gt;CONCURRENTLY&lt;/code&gt; オプションなしで再インデックスすることができます。）</target>
        </trans-unit>
        <trans-unit id="ca37f367ca14421a51e0f4caacbc290fabee5387" translate="yes" xml:space="preserve">
          <source>Furthermore, the ordering is total; that is, for all non-null values &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">さらに、順序は合計です。つまり、すべての非null値 &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; の場合：</target>
        </trans-unit>
        <trans-unit id="403e23f7e975f56f502368918f62f79a68fb24a2" translate="yes" xml:space="preserve">
          <source>Furthermore, the output of &lt;code&gt;JOIN USING&lt;/code&gt; suppresses redundant columns: there is no need to print both of the matched columns, since they must have equal values. While &lt;code&gt;JOIN ON&lt;/code&gt; produces all columns from &lt;code&gt;T1&lt;/code&gt; followed by all columns from &lt;code&gt;T2&lt;/code&gt;, &lt;code&gt;JOIN USING&lt;/code&gt; produces one output column for each of the listed column pairs (in the listed order), followed by any remaining columns from &lt;code&gt;T1&lt;/code&gt;, followed by any remaining columns from &lt;code&gt;T2&lt;/code&gt;.</source>
          <target state="translated">さらに、 &lt;code&gt;JOIN USING&lt;/code&gt; の出力は冗長な列を抑制します。一致する列は同じ値でなければならないため、一致する両方の列を出力する必要はありません。ながら &lt;code&gt;JOIN ON&lt;/code&gt; 生成からすべての列 &lt;code&gt;T1&lt;/code&gt; はからすべての列が続く &lt;code&gt;T2&lt;/code&gt; 、 &lt;code&gt;JOIN USING&lt;/code&gt; から任意の残りの列が続く、（列挙された順序で）記載されている列の対ごとに1つの出力列を生成 &lt;code&gt;T1&lt;/code&gt; から任意の残りの列が続く、 &lt;code&gt;T2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e40a8533f467834ab1d55c9055f3d84061da31d" translate="yes" xml:space="preserve">
          <source>GEQO</source>
          <target state="translated">GEQO</target>
        </trans-unit>
        <trans-unit id="7c02cecaa08dd20b2878a0e9246d9afddbd1bfa9" translate="yes" xml:space="preserve">
          <source>GIN</source>
          <target state="translated">GIN</target>
        </trans-unit>
        <trans-unit id="ecc6a1db2685ccbd525e456602d8a531d64c012d" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Built-in Operator Classes</source>
          <target state="translated">GINインデックス。組込み演算子クラス</target>
        </trans-unit>
        <trans-unit id="df2283621762cf6fbe34492dd970bdc1a2fb8f2e" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Examples</source>
          <target state="translated">GINインデックス。例</target>
        </trans-unit>
        <trans-unit id="bcdb1f5984e5f5fc37ee2625a5e106b5ace38b47" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Extensibility</source>
          <target state="translated">GIN インデックス。拡張性</target>
        </trans-unit>
        <trans-unit id="1f6ebc2a0d191b466ed9b8d366b380c7d0d18de4" translate="yes" xml:space="preserve">
          <source>GIN Indexes: GIN Tips and Tricks</source>
          <target state="translated">GINのインデックス。GINのヒントとコツ</target>
        </trans-unit>
        <trans-unit id="79cd3f5e4f5e10454468404b67550cb2d0ff11bb" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Implementation</source>
          <target state="translated">GINインデックス。実装</target>
        </trans-unit>
        <trans-unit id="bac90b5d133adfb4770f3d94ae6faf770a933f01" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Limitations</source>
          <target state="translated">GINインデックス。制限事項</target>
        </trans-unit>
        <trans-unit id="ece4291bbc12d9bc7ed3dfad4dd491c4406b75fd" translate="yes" xml:space="preserve">
          <source>GIN and GiST Index Types</source>
          <target state="translated">GINとGiSTインデックスの種類</target>
        </trans-unit>
        <trans-unit id="838975c5a4d167bd2f6ce5e8ea900f60f03b2972" translate="yes" xml:space="preserve">
          <source>GIN assumes that indexable operators are strict. This means that &lt;code&gt;extractValue&lt;/code&gt; will not be called at all on a null item value (instead, a placeholder index entry is created automatically), and &lt;code&gt;extractQuery&lt;/code&gt; will not be called on a null query value either (instead, the query is presumed to be unsatisfiable). Note however that null key values contained within a non-null composite item or query value are supported.</source>
          <target state="translated">GINは、インデックス付け可能な演算子が厳密であることを前提としています。これは、nullアイテム値に対して &lt;code&gt;extractValue&lt;/code&gt; がまったく呼び出されず（代わりにプレースホルダーインデックスエントリが自動的に作成される）、nullクエリ値に対しても &lt;code&gt;extractQuery&lt;/code&gt; が呼び出されないことを意味します（代わりに、クエリが満たされていないと推定されます） 。ただし、null以外の複合アイテムまたはクエリ値に含まれるnullキー値はサポートされています。</target>
        </trans-unit>
        <trans-unit id="fe2b1de04947c2b348e8de70b6c2f63da721161b" translate="yes" xml:space="preserve">
          <source>GIN can support &amp;ldquo;partial match&amp;rdquo; queries, in which the query does not determine an exact match for one or more keys, but the possible matches fall within a reasonably narrow range of key values (within the key sorting order determined by the &lt;code&gt;compare&lt;/code&gt; support method). The &lt;code&gt;extractQuery&lt;/code&gt; method, instead of returning a key value to be matched exactly, returns a key value that is the lower bound of the range to be searched, and sets the &lt;code&gt;pmatch&lt;/code&gt; flag true. The key range is then scanned using the &lt;code&gt;comparePartial&lt;/code&gt; method. &lt;code&gt;comparePartial&lt;/code&gt; must return zero for a matching index key, less than zero for a non-match that is still within the range to be searched, or greater than zero if the index key is past the range that could match.</source>
          <target state="translated">GINは「部分一致」クエリをサポートできます。このクエリでは、1つまたは複数のキーの完全一致は決定されませんが、可能な一致はかなり狭い範囲のキー値に含まれます（ &lt;code&gt;compare&lt;/code&gt; サポートメソッドによって決定されるキーの並べ替え順序内））。 &lt;code&gt;extractQuery&lt;/code&gt; のは、代わりにキー値を戻す方法が正確に一致するように、下側検索する範囲の下限であるキー値を戻し、設定 &lt;code&gt;pmatch&lt;/code&gt; の真フラグ。次に、キー範囲が &lt;code&gt;comparePartial&lt;/code&gt; メソッドを使用してスキャンされます。 &lt;code&gt;comparePartial&lt;/code&gt; 一致するインデックスキーの場合はゼロを返し、検索対象の範囲内にまだある非一致の場合はゼロ未満、またはインデックスキーが一致する可能性のある範囲を超えている場合はゼロより大きい値を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="614db4420feca405f38d8b066253c12c8348900b" translate="yes" xml:space="preserve">
          <source>GIN index extracts statements of following form out of &lt;code&gt;jsonpath&lt;/code&gt;: &lt;code&gt;accessors_chain&lt;/code&gt; = &lt;code&gt;const&lt;/code&gt;. Accessors chain may consist of &lt;code&gt;.key&lt;/code&gt;, &lt;code&gt;[*]&lt;/code&gt;, and &lt;code&gt;[index]&lt;/code&gt; accessors. &lt;code&gt;jsonb_ops&lt;/code&gt; additionally supports &lt;code&gt;.*&lt;/code&gt; and &lt;code&gt;.**&lt;/code&gt; accessors.</source>
          <target state="translated">GINインデックスは、 &lt;code&gt;jsonpath&lt;/code&gt; から次の形式のステートメントを抽出します： &lt;code&gt;accessors_chain&lt;/code&gt; = &lt;code&gt;const&lt;/code&gt; 。アクセサチェーンは、 &lt;code&gt;.key&lt;/code&gt; 、 &lt;code&gt;[*]&lt;/code&gt; 、および &lt;code&gt;[index]&lt;/code&gt; アクセサで構成されます。 &lt;code&gt;jsonb_ops&lt;/code&gt; はさらに &lt;code&gt;.*&lt;/code&gt; および &lt;code&gt;.**&lt;/code&gt; アクセサーをサポートします。</target>
        </trans-unit>
        <trans-unit id="45189d146afca1631f2530069592ce2a3f6f8758" translate="yes" xml:space="preserve">
          <source>GIN indexes</source>
          <target state="translated">GINインデックス</target>
        </trans-unit>
        <trans-unit id="b1817ec41a2b97676aa792c5a571f79e3047197e" translate="yes" xml:space="preserve">
          <source>GIN indexes accept different parameters:</source>
          <target state="translated">GIN インデックスは異なるパラメータを受け入れます。</target>
        </trans-unit>
        <trans-unit id="9ae2afa12a8014fb0afa678aad4a0a6fdff0194f" translate="yes" xml:space="preserve">
          <source>GIN indexes are &amp;ldquo;inverted indexes&amp;rdquo; which are appropriate for data values that contain multiple component values, such as arrays. An inverted index contains a separate entry for each component value, and can efficiently handle queries that test for the presence of specific component values.</source>
          <target state="translated">GINインデックスは「逆インデックス」であり、配列などの複数のコンポーネント値を含むデータ値に適しています。転置インデックスには、各コンポーネント値の個別のエントリが含まれており、特定のコンポーネント値の存在をテストするクエリを効率的に処理できます。</target>
        </trans-unit>
        <trans-unit id="6e3602f0fe2770a2e803379f390135df1f58a159" translate="yes" xml:space="preserve">
          <source>GIN indexes are the preferred text search index type. As inverted indexes, they contain an index entry for each word (lexeme), with a compressed list of matching locations. Multi-word searches can find the first match, then use the index to remove rows that are lacking additional words. GIN indexes store only the words (lexemes) of &lt;code&gt;tsvector&lt;/code&gt; values, and not their weight labels. Thus a table row recheck is needed when using a query that involves weights.</source>
          <target state="translated">GINインデックスは、推奨されるテキスト検索インデックスタイプです。逆索引として、一致する位置の圧縮リストとともに、各単語（語彙素）の索引エントリが含まれます。複数単語の検索では、最初に一致するものを見つけてから、インデックスを使用して、単語が不足している行を削除できます。GINインデックスには、 &lt;code&gt;tsvector&lt;/code&gt; 値の単語（語彙素）のみが格納され、重みラベルは格納されません。したがって、重みを含むクエリを使用する場合は、テーブル行の再チェックが必要です。</target>
        </trans-unit>
        <trans-unit id="662e0bcd43903a7d3e17f00c272dcd79f02aa415" translate="yes" xml:space="preserve">
          <source>GIN indexes can be used to efficiently search for keys or key/value pairs occurring within a large number of &lt;code&gt;jsonb&lt;/code&gt; documents (datums). Two GIN &amp;ldquo;operator classes&amp;rdquo; are provided, offering different performance and flexibility trade-offs.</source>
          <target state="translated">GINインデックスは、多数の &lt;code&gt;jsonb&lt;/code&gt; ドキュメント（データ）内で発生するキーまたはキーと値のペアを効率的に検索するために使用できます。2つのGIN「演算子クラス」が提供され、さまざまなパフォーマンスと柔軟性のトレードオフが提供されます。</target>
        </trans-unit>
        <trans-unit id="680a142f22f16149f0a10d5733b44a15bfc9f906" translate="yes" xml:space="preserve">
          <source>GIN is generalized in the sense that the GIN access method code does not need to know the specific operations that it accelerates. Instead, it uses custom strategies defined for particular data types. The strategy defines how keys are extracted from indexed items and query conditions, and how to determine whether a row that contains some of the key values in a query actually satisfies the query.</source>
          <target state="translated">GINは一般化されており、GINアクセスメソッドのコードがアクセラレーションする特定の操作を知る必要がありません。その代わりに、特定のデータ型に対して定義されたカスタムストラテジーを使用します。ストラテジーは、インデックス化された項目とクエリ条件からキーがどのように抽出されるかを定義し、クエリ内のキー値の一部を含む行が実際にクエリを満たすかどうかを判断する方法を定義します。</target>
        </trans-unit>
        <trans-unit id="2d1d5b806ff667bfec2719e4c38322233f7a1f8b" translate="yes" xml:space="preserve">
          <source>GIN stands for Generalized Inverted Index. GIN is designed for handling cases where the items to be indexed are composite values, and the queries to be handled by the index need to search for element values that appear within the composite items. For example, the items could be documents, and the queries could be searches for documents containing specific words.</source>
          <target state="translated">GINはGeneralized Inverted Indexの略である。GINは、インデックス化する項目が複合値であり、インデックスが扱うクエリは、複合項目内に現れる要素値を検索する必要がある場合に対応するように設計されている。例えば、項目は文書であり、クエリは特定の単語を含む文書を検索することができる。</target>
        </trans-unit>
        <trans-unit id="823f6d975b918a4f4904609a69bccd4f6db0e016" translate="yes" xml:space="preserve">
          <source>GIN version number</source>
          <target state="translated">GINバージョン番号</target>
        </trans-unit>
        <trans-unit id="d84234ce9f95c2df9a9cb91648dc0629d7b55a78" translate="yes" xml:space="preserve">
          <source>GMT</source>
          <target state="translated">GMT</target>
        </trans-unit>
        <trans-unit id="46e5d5c005d767dc686d5fdb5278440482f67660" translate="yes" xml:space="preserve">
          <source>GRANT</source>
          <target state="translated">GRANT</target>
        </trans-unit>
        <trans-unit id="f96c309d7771b4500d22efff00cb264218c6cf3a" translate="yes" xml:space="preserve">
          <source>GRANT &amp;mdash; define access privileges</source>
          <target state="translated">GRANT &amp;mdash;アクセス権限を定義する</target>
        </trans-unit>
        <trans-unit id="50381ef340ee08d7a029c8e513ea2dc8126c9d21" translate="yes" xml:space="preserve">
          <source>GRANT on Database Objects</source>
          <target state="translated">データベースオブジェクトのGRANT</target>
        </trans-unit>
        <trans-unit id="040876dd6cec9809d1a84a48115c6451d11d511c" translate="yes" xml:space="preserve">
          <source>GRANT on Roles</source>
          <target state="translated">役割についてのGRANT</target>
        </trans-unit>
        <trans-unit id="18b63165da1ffe19e191b11267fd831d16b20629" translate="yes" xml:space="preserve">
          <source>GSSAPI</source>
          <target state="translated">GSSAPI</target>
        </trans-unit>
        <trans-unit id="6b3f2424f13149fada5347cf28d874ce4ce85971" translate="yes" xml:space="preserve">
          <source>GSSAPI Authentication</source>
          <target state="translated">GSSAPI認証</target>
        </trans-unit>
        <trans-unit id="3d0265dcf1697d6c2f5c259d07fa634b6fbdea24" translate="yes" xml:space="preserve">
          <source>GSSAPI is an industry-standard protocol for secure authentication defined in RFC 2743. PostgreSQL supports GSSAPI for use as either an encrypted, authenticated layer, or for authentication only. GSSAPI provides automatic authentication (single sign-on) for systems that support it. The authentication itself is secure. If GSSAPI encryption (see &lt;code&gt;hostgssenc&lt;/code&gt;) or SSL encryption are used, the data sent along the database connection will be encrypted; otherwise, it will not.</source>
          <target state="translated">GSSAPIは、RFC 2743で定義されている安全な認証のための業界標準プロトコルです。PostgreSQLは、GSSAPIをサポートしており、暗号化された認証済みレイヤーとして、または認証専用として使用できます。GSSAPIは、それをサポートするシステムに自動認証（シングルサインオン）を提供します。認証自体は安全です。GSSAPI暗号化（ &lt;code&gt;hostgssenc&lt;/code&gt; を参照）またはSSL暗号化が使用されている場合、データベース接続を介して送信されるデータは暗号化されます。そうでなければ、それはしません。</target>
        </trans-unit>
        <trans-unit id="9c340397893e38112dd6e1110b015089ffe980f8" translate="yes" xml:space="preserve">
          <source>GSSAPI support has to be enabled when PostgreSQL is built; see &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt; for more information.</source>
          <target state="translated">PostgreSQLのビルド時にGSSAPIサポートを有効にする必要があります。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;第16章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a65194631e53d423c8f7dc36b0337ca4d0af275f" translate="yes" xml:space="preserve">
          <source>GSSAPI-encrypted connections encrypt all data sent across the network, including queries and data returned. (No password is sent across the network.) The &lt;code&gt;pg_hba.conf&lt;/code&gt; file allows administrators to specify which hosts can use non-encrypted connections (&lt;code&gt;host&lt;/code&gt;) and which require GSSAPI-encrypted connections (&lt;code&gt;hostgssenc&lt;/code&gt;). Also, clients can specify that they connect to servers only on GSSAPI-encrypted connections (&lt;code&gt;gssencmode=require&lt;/code&gt;).</source>
          <target state="translated">GSSAPIで暗号化された接続は、クエリや返されたデータを含む、ネットワーク経由で送信されるすべてのデータを暗号化します。（ネットワークを介してパスワードは送信されません。） &lt;code&gt;pg_hba.conf&lt;/code&gt; ファイルを使用すると、管理者は非暗号化接続を使用できる &lt;code&gt;host&lt;/code&gt; （host）とGSSAPI暗号化接続を必要とするホスト（ &lt;code&gt;hostgssenc&lt;/code&gt; ）を指定できます。また、クライアントは、GSSAPIで暗号化された接続（ &lt;code&gt;gssencmode=require&lt;/code&gt; ）でのみサーバーに接続するように指定できます。</target>
        </trans-unit>
        <trans-unit id="5f4a781a866c82c10ec06cfdb99d578fac96f0a9" translate="yes" xml:space="preserve">
          <source>GUC</source>
          <target state="translated">GUC</target>
        </trans-unit>
        <trans-unit id="55d3b12a3edecf2084b5b37090f9f7a53387e200" translate="yes" xml:space="preserve">
          <source>Gaussian-distributed random integer in &lt;code&gt;[lb, ub]&lt;/code&gt;, see below</source>
          <target state="translated">&lt;code&gt;[lb, ub]&lt;/code&gt; ガウス分布ランダム整数、以下を参照</target>
        </trans-unit>
        <trans-unit id="ae313cc97f019cc02b5747068e2416db0beed99a" translate="yes" xml:space="preserve">
          <source>General Purpose</source>
          <target state="translated">一般目的</target>
        </trans-unit>
        <trans-unit id="3160665d714fc6d7b194361c56057ae8d2d10ef8" translate="yes" xml:space="preserve">
          <source>Generalized Inverted Index</source>
          <target state="translated">一般化反転指数</target>
        </trans-unit>
        <trans-unit id="aa5854e74a08fd00bcac0cc44c6f66a2c57b9442" translate="yes" xml:space="preserve">
          <source>Generalized Search Tree</source>
          <target state="translated">一般化された検索ツリー</target>
        </trans-unit>
        <trans-unit id="3e7c9f89ced37df1cb7e21ed93f1ae9c43e37c8c" translate="yes" xml:space="preserve">
          <source>Generally, any file system with POSIX semantics can be used for PostgreSQL. Users prefer different file systems for a variety of reasons, including vendor support, performance, and familiarity. Experience suggests that, all other things being equal, one should not expect major performance or behavior changes merely from switching file systems or making minor file system configuration changes.</source>
          <target state="translated">一般的に、POSIXセマンティクスを持つ任意のファイルシステムをPostgreSQLに使用することができます。ユーザが異なるファイルシステムを好む理由は、ベンダーのサポート、性能、親しみやすさなど様々な理由があります。経験上、他のすべてのことが同じであるにもかかわらず、ファイルシステムを切り替えたり、ファイルシステムの設定を少し変更したりしただけでは、大きな性能や動作の変化を期待すべきではないことが示唆されています。</target>
        </trans-unit>
        <trans-unit id="e4dfa0a05721faeacd6c28188e09916650d7ec35" translate="yes" xml:space="preserve">
          <source>Generally, the &lt;code&gt;EXPLAIN&lt;/code&gt; output will display details for every plan node which was generated by the query planner. However, there are cases where the executor is able to determine that certain nodes are not required; currently, the only node types to support this are the &lt;code&gt;Append&lt;/code&gt; and &lt;code&gt;MergeAppend&lt;/code&gt; nodes. These node types have the ability to discard subnodes which they are able to determine won't contain any records required by the query. It is possible to determine that nodes have been removed in this way by the presence of a &quot;Subplans Removed&quot; property in the &lt;code&gt;EXPLAIN&lt;/code&gt; output.</source>
          <target state="translated">通常、 &lt;code&gt;EXPLAIN&lt;/code&gt; 出力には、クエリプランナーによって生成されたすべてのプランノードの詳細が表示されます。ただし、特定のノードが不要であるとエグゼキューターが判断できる場合があります。現在、これをサポートする唯一のノードタイプは &lt;code&gt;Append&lt;/code&gt; ノードと &lt;code&gt;MergeAppend&lt;/code&gt; ノードです。これらのノードタイプには、クエリで必要なレコードが含まれていないと判断できるサブノードを破棄する機能があります。 &lt;code&gt;EXPLAIN&lt;/code&gt; 出力に「削除されたサブプラン」プロパティが存在することにより、ノードがこのように削除されたことを確認できます。</target>
        </trans-unit>
        <trans-unit id="affe2a15ea854fded86126b770c099c64d24c777" translate="yes" xml:space="preserve">
          <source>Generally, the system will enforce filter conditions imposed using security policies prior to qualifications that appear in user queries, in order to prevent inadvertent exposure of the protected data to user-defined functions which might not be trustworthy. However, functions and operators marked by the system (or the system administrator) as &lt;code&gt;LEAKPROOF&lt;/code&gt; may be evaluated before policy expressions, as they are assumed to be trustworthy.</source>
          <target state="translated">通常、システムは、ユーザーのクエリに表示される資格の前に、セキュリティポリシーを使用して課されるフィルター条件を適用し、信頼できない可能性のあるユーザー定義関数に保護されたデータが誤って公開されるのを防ぎます。ただし、システム（またはシステム管理者）によって &lt;code&gt;LEAKPROOF&lt;/code&gt; としてマークされた関数と演算子は、信頼できると見なされるため、ポリシー式の前に評価される場合があります。</target>
        </trans-unit>
        <trans-unit id="f3eac14aa88e73035cec53cd24d7892747e63a31" translate="yes" xml:space="preserve">
          <source>Generate a series comprising the given array's subscripts.</source>
          <target state="translated">指定された配列の添え字からなる系列を生成します。</target>
        </trans-unit>
        <trans-unit id="4a5175300e4854a10a7b94e474436e6a6e890471" translate="yes" xml:space="preserve">
          <source>Generate a series comprising the given array's subscripts. When &lt;em&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/em&gt; is true, the series is returned in reverse order.</source>
          <target state="translated">指定された配列の添え字で構成されるシリーズを生成します。とき&lt;em&gt; &lt;code&gt;reverse&lt;/code&gt; &lt;/em&gt;真である、シリーズは逆の順序で返されます。</target>
        </trans-unit>
        <trans-unit id="ad5fcb5a5c8eeebb88c26d2bf0bde7f9fa38281f" translate="yes" xml:space="preserve">
          <source>Generate a series of values, from &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt; with a step size of &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">一連の値を生成し&lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt;するために&lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt;のステップサイズと&lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5fb2cfb648fe3292c4f21944415cd71835246e3" translate="yes" xml:space="preserve">
          <source>Generate a series of values, from &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt; with a step size of one</source>
          <target state="translated">ステップサイズが1の&lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt;から&lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt;までの一連の値を生成します</target>
        </trans-unit>
        <trans-unit id="37f727cfa62167384e5f8947ef57078f0d482808" translate="yes" xml:space="preserve">
          <source>Generate data and load it into the standard tables, replacing any data already present.</source>
          <target state="translated">データを生成し、既に存在するデータを置き換えて標準テーブルにロードします。</target>
        </trans-unit>
        <trans-unit id="9dcf1fb2a5619d507a1603ea13343b634907fbb2" translate="yes" xml:space="preserve">
          <source>Generated Columns</source>
          <target state="translated">生成されたカラム</target>
        </trans-unit>
        <trans-unit id="75d723afc8209b9ad813733ed0d276b98f57a469" translate="yes" xml:space="preserve">
          <source>Generated columns are, conceptually, updated after &lt;code&gt;BEFORE&lt;/code&gt; triggers have run. Therefore, changes made to base columns in a &lt;code&gt;BEFORE&lt;/code&gt; trigger will be reflected in generated columns. But conversely, it is not allowed to access generated columns in &lt;code&gt;BEFORE&lt;/code&gt; triggers.</source>
          <target state="translated">生成された列は、概念的には、 &lt;code&gt;BEFORE&lt;/code&gt; トリガーの実行後に更新されます。したがって、 &lt;code&gt;BEFORE&lt;/code&gt; トリガーでベース列に加えられた変更は、生成された列に反映されます。ただし、逆に、 &lt;code&gt;BEFORE&lt;/code&gt; トリガーで生成された列にアクセスすることはできません。</target>
        </trans-unit>
        <trans-unit id="942c0fc170e0c5a1f9b1ae453e356f340b1b4ebb" translate="yes" xml:space="preserve">
          <source>Generated columns maintain access privileges separately from their underlying base columns. So, it is possible to arrange it so that a particular role can read from a generated column but not from the underlying base columns.</source>
          <target state="translated">生成されたカラムは、ベースとなるカラムとは別にアクセス権限を保持します。そのため、特定のロールが生成されたカラムからは読めるが、ベースとなるカラムからは読めないようにアレンジすることができます。</target>
        </trans-unit>
        <trans-unit id="7f0ef22f71ecfc740ab931db74f147c122ec3d69" translate="yes" xml:space="preserve">
          <source>Generates a great amount of debugging output for the &lt;code&gt;LISTEN&lt;/code&gt; and &lt;code&gt;NOTIFY&lt;/code&gt; commands. &lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt; or &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt; must be &lt;code&gt;DEBUG1&lt;/code&gt; or lower to send this output to the client or server logs, respectively.</source>
          <target state="translated">&lt;code&gt;LISTEN&lt;/code&gt; および &lt;code&gt;NOTIFY&lt;/code&gt; コマンドの大量のデバッグ出力を生成します。この出力をクライアントまたはサーバーのログに送信するには、&lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt;または&lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt;をそれぞれ &lt;code&gt;DEBUG1&lt;/code&gt; 以下にする必要があります。</target>
        </trans-unit>
        <trans-unit id="0c512aad043f38a5c410a9715731ea7ab925a02c" translate="yes" xml:space="preserve">
          <source>Generates a new random salt string for use in &lt;code&gt;crypt()&lt;/code&gt;. The salt string also tells &lt;code&gt;crypt()&lt;/code&gt; which algorithm to use.</source>
          <target state="translated">&lt;code&gt;crypt()&lt;/code&gt; で使用する新しいランダムなソルト文字列を生成します。また、salt文字列は、使用するアルゴリズムを &lt;code&gt;crypt()&lt;/code&gt; に通知します。</target>
        </trans-unit>
        <trans-unit id="2aed1c9095c07cc7e84b3424230f02a2d9b469cc" translate="yes" xml:space="preserve">
          <source>Generic Security Services Application Programming Interface</source>
          <target state="translated">ジェネリックセキュリティサービスアプリケーションプログラミングインタフェース</target>
        </trans-unit>
        <trans-unit id="8bc48767cdd05b47e355717259ca35db85925a08" translate="yes" xml:space="preserve">
          <source>Generic WAL Records</source>
          <target state="translated">ジェネリックWALレコード</target>
        </trans-unit>
        <trans-unit id="205b89cfc2a1a2269f79b2bc4ed00c40f5cec848" translate="yes" xml:space="preserve">
          <source>Generic WAL assumes that the pages to be modified have standard layout, and in particular that there is no useful data between &lt;code&gt;pd_lower&lt;/code&gt; and &lt;code&gt;pd_upper&lt;/code&gt;.</source>
          <target state="translated">ジェネリックWALは、変更されるページが標準のレイアウトであること、特に &lt;code&gt;pd_lower&lt;/code&gt; と &lt;code&gt;pd_upper&lt;/code&gt; の間に有用なデータがないことを前提としています。</target>
        </trans-unit>
        <trans-unit id="651fc79b97c554a5773cb00dd19d49f06b1a6de8" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer</source>
          <target state="translated">遺伝的クエリオプティマイザ</target>
        </trans-unit>
        <trans-unit id="285a459d41ebc8b40cc4e21eb5058c5046b9a518" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer: Further Reading</source>
          <target state="translated">遺伝的クエリオプティマイザ。さらなる読み物</target>
        </trans-unit>
        <trans-unit id="0fe3a114537a44f8bb8da3ae145d25fd674c9baa" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer: Genetic Algorithms</source>
          <target state="translated">遺伝的クエリオプティマイザ。遺伝的アルゴリズム</target>
        </trans-unit>
        <trans-unit id="a4b0f535ba1259d8c2e707ca90836a3a1579135e" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer: Genetic Query Optimization (GEQO) in PostgreSQL</source>
          <target state="translated">遺伝的クエリオプティマイザ。PostgreSQLでの遺伝的クエリ最適化 (GEQO)</target>
        </trans-unit>
        <trans-unit id="c07c10eab422b8e5a37b4814c23b452b246b27ed" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer: Query Handling as a Complex Optimization Problem</source>
          <target state="translated">遺伝的クエリオプティマイザ 複雑な最適化問題としてのクエリ処理</target>
        </trans-unit>
        <trans-unit id="59a79a1ee234d61d42db147aa7f797d2e6ec2302" translate="yes" xml:space="preserve">
          <source>Geometric Types</source>
          <target state="translated">幾何学的なタイプ</target>
        </trans-unit>
        <trans-unit id="1b872848d87aaa550340d8fe24c7f0a2a9ae8bcb" translate="yes" xml:space="preserve">
          <source>Geometric Types: box</source>
          <target state="translated">幾何学的なタイプ:ボックス</target>
        </trans-unit>
        <trans-unit id="92cdb69f3efb505ed8f65eafd9adff3faa140669" translate="yes" xml:space="preserve">
          <source>Geometric Types: circle</source>
          <target state="translated">幾何学的なタイプ:円</target>
        </trans-unit>
        <trans-unit id="b780ba45a62c07dae122a8391383dec51d0ae3fb" translate="yes" xml:space="preserve">
          <source>Geometric Types: line</source>
          <target state="translated">幾何学的なタイプ:線</target>
        </trans-unit>
        <trans-unit id="93e949ac77b5da81e10c0d00eb14e5b76ecbcd17" translate="yes" xml:space="preserve">
          <source>Geometric Types: lseg</source>
          <target state="translated">幾何学的タイプ:lseg</target>
        </trans-unit>
        <trans-unit id="70c8994901b16ea96046ff8cb3549fb5591cc7c5" translate="yes" xml:space="preserve">
          <source>Geometric Types: path</source>
          <target state="translated">幾何学的なタイプ:パス</target>
        </trans-unit>
        <trans-unit id="5971b419fcb4741dbee95edc6702d224da6e2f8b" translate="yes" xml:space="preserve">
          <source>Geometric Types: point</source>
          <target state="translated">幾何学的なタイプ:点</target>
        </trans-unit>
        <trans-unit id="a42b9eae0d25dcae6593b119b1ff920376ab3fdb" translate="yes" xml:space="preserve">
          <source>Geometric Types: polygon</source>
          <target state="translated">幾何学的なタイプ:ポリゴン</target>
        </trans-unit>
        <trans-unit id="c0f24750d757100bf5b4c2c76561499175630de1" translate="yes" xml:space="preserve">
          <source>Geometric data types represent two-dimensional spatial objects. &lt;a href=&quot;datatype-geometric#DATATYPE-GEO-TABLE&quot;&gt;Table 8.20&lt;/a&gt; shows the geometric types available in PostgreSQL.</source>
          <target state="translated">幾何データ型は、2次元の空間オブジェクトを表します。&lt;a href=&quot;datatype-geometric#DATATYPE-GEO-TABLE&quot;&gt;表8.20&lt;/a&gt;は、PostgreSQLで使用可能なジオメトリタイプを示しています。</target>
        </trans-unit>
        <trans-unit id="7694ba97cb7c18e18a22a41d6adc199509b697ef" translate="yes" xml:space="preserve">
          <source>Geometric types</source>
          <target state="translated">幾何学的なタイプ</target>
        </trans-unit>
        <trans-unit id="9ae1f34e04075cebb1033f14ff7dd7b2bf91177b" translate="yes" xml:space="preserve">
          <source>Geometric: #</source>
          <target state="translated">幾何学的な #</target>
        </trans-unit>
        <trans-unit id="541465ff2784b3862252a679a04558fbc655a79e" translate="yes" xml:space="preserve">
          <source>Geometric: ##</source>
          <target state="translated">幾何学的だ ##</target>
        </trans-unit>
        <trans-unit id="72e0052efc06dc944e06a8b63310fcb1f4bce4d7" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;amp;&amp;amp;</source>
          <target state="translated">幾何学的：&amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="c6f1767ec1ac7b1e533771c3bc6f2d157e3a0ffa" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;amp;&amp;gt;</source>
          <target state="translated">幾何学的：＆&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0efad1957c6995260f5c39d190b260d9567a113b" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;amp;&amp;lt;</source>
          <target state="translated">幾何学：＆&amp;lt;</target>
        </trans-unit>
        <trans-unit id="0f689675538b5b4ec110540ff41eb289d6bd6b43" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;amp;&amp;lt;|</source>
          <target state="translated">幾何学的：＆&amp;lt;|</target>
        </trans-unit>
        <trans-unit id="f1e472c7b332a52572d117379abc66949f9e31c1" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;gt;&amp;gt;</source>
          <target state="translated">幾何学的：&amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e6fb2a9acb2064c887124b6f5b0e4e754de5f5fc" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;gt;^</source>
          <target state="translated">幾何学的：&amp;gt; ^</target>
        </trans-unit>
        <trans-unit id="d77e84d344e830ae23e28900f46ab81224e68d7d" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;&amp;lt;</source>
          <target state="translated">幾何学的：&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="114e3e68bec04a11161b64f095fcabaa1b93c022" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;&amp;lt;|</source>
          <target state="translated">幾何学的：&amp;lt;&amp;lt; |</target>
        </trans-unit>
        <trans-unit id="3ebddf62e56d977cd85a67e8678d46b2782a23db" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;-&amp;gt;</source>
          <target state="translated">幾何学的：&amp;lt;-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f3447c8a88fb2334b8df577a95ce9dc8220f2dd2" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;@</source>
          <target state="translated">幾何学的：&amp;lt;@</target>
        </trans-unit>
        <trans-unit id="cce9525015da81ce4d350742ece1c53d96c3ca2b" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;^</source>
          <target state="translated">幾何学的：&amp;lt;^</target>
        </trans-unit>
        <trans-unit id="56a2009f06f5c74871588a05282ba0b39fb6ceeb" translate="yes" xml:space="preserve">
          <source>Geometric: *</source>
          <target state="translated">幾何学的な。*</target>
        </trans-unit>
        <trans-unit id="fa3ffad94fe9509b3b02c414cf9edaa0a2aba46e" translate="yes" xml:space="preserve">
          <source>Geometric: +</source>
          <target state="translated">幾何学的だ +</target>
        </trans-unit>
        <trans-unit id="356d9d70234e609b9b853b2369c157f70b7aebbe" translate="yes" xml:space="preserve">
          <source>Geometric: -</source>
          <target state="translated">幾何学的:-。</target>
        </trans-unit>
        <trans-unit id="2ffe2cc10b627cd354dfeb7422da5a985c240d62" translate="yes" xml:space="preserve">
          <source>Geometric: /</source>
          <target state="translated">幾何学的な。/</target>
        </trans-unit>
        <trans-unit id="1c2280f6c1d1edcd9860d33a2a8a075c691adc71" translate="yes" xml:space="preserve">
          <source>Geometric: ?#</source>
          <target state="translated">幾何学的:?</target>
        </trans-unit>
        <trans-unit id="12821b449935c6dc49b03d2b040482308099f146" translate="yes" xml:space="preserve">
          <source>Geometric: ?-</source>
          <target state="translated">幾何学的:?</target>
        </trans-unit>
        <trans-unit id="41659a241d6173118c63109b8d58f3b040547d38" translate="yes" xml:space="preserve">
          <source>Geometric: ?-|</source>
          <target state="translated">幾何学的:?-|</target>
        </trans-unit>
        <trans-unit id="d6f03fc9c9b0ab0563a28c6910f4a205a373dffb" translate="yes" xml:space="preserve">
          <source>Geometric: ?|</source>
          <target state="translated">幾何学的:?</target>
        </trans-unit>
        <trans-unit id="13e94b0d1073bd3bdfb91bcd5a193786583c973b" translate="yes" xml:space="preserve">
          <source>Geometric: ?||</source>
          <target state="translated">幾何学的:?</target>
        </trans-unit>
        <trans-unit id="9330c7f285f4544ce63cffaf12c739ac5f145ca1" translate="yes" xml:space="preserve">
          <source>Geometric: @&amp;gt;</source>
          <target state="translated">幾何学的：@&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5270f97dad19be61277e040028add99dc4c8a2f8" translate="yes" xml:space="preserve">
          <source>Geometric: @-@</source>
          <target state="translated">幾何学的な @-@</target>
        </trans-unit>
        <trans-unit id="28dfb9d3208de0df87974a869f843209287712a0" translate="yes" xml:space="preserve">
          <source>Geometric: @@</source>
          <target state="translated">幾何学的な @@</target>
        </trans-unit>
        <trans-unit id="b52a6568265c2c5d617423e6cf36665bbcecd5cd" translate="yes" xml:space="preserve">
          <source>Geometric: area</source>
          <target state="translated">幾何学的:面積</target>
        </trans-unit>
        <trans-unit id="93665e808ca1c14ef16cc6912cf6d87101aae4b0" translate="yes" xml:space="preserve">
          <source>Geometric: bound_box</source>
          <target state="translated">幾何学的:bound_box</target>
        </trans-unit>
        <trans-unit id="39d2105da034c7db21d98973af72a8064f606dda" translate="yes" xml:space="preserve">
          <source>Geometric: box</source>
          <target state="translated">幾何学的な:箱</target>
        </trans-unit>
        <trans-unit id="f403cd59f8511c55a29a5613deb6dc17553ae356" translate="yes" xml:space="preserve">
          <source>Geometric: center</source>
          <target state="translated">幾何学的な:中心</target>
        </trans-unit>
        <trans-unit id="e4f391fd63cca84c9f17c34aa7cc7e489332e1f7" translate="yes" xml:space="preserve">
          <source>Geometric: circle</source>
          <target state="translated">幾何学的:円</target>
        </trans-unit>
        <trans-unit id="e9d52c7012ac5f08fa191553229f86a574d2d1fe" translate="yes" xml:space="preserve">
          <source>Geometric: diameter</source>
          <target state="translated">幾何学的:直径</target>
        </trans-unit>
        <trans-unit id="eba387383e96b60f7dd8fc11f767b059ffe3a921" translate="yes" xml:space="preserve">
          <source>Geometric: height</source>
          <target state="translated">幾何学的:高さ</target>
        </trans-unit>
        <trans-unit id="dfc5959ea0a6181524e306d022dfcc8e49a1d83c" translate="yes" xml:space="preserve">
          <source>Geometric: isclosed</source>
          <target state="translated">幾何学的な:閉じられた</target>
        </trans-unit>
        <trans-unit id="7f81a6975db9a38b5af5931e1338ccf232987667" translate="yes" xml:space="preserve">
          <source>Geometric: isopen</source>
          <target state="translated">幾何学的:isopen</target>
        </trans-unit>
        <trans-unit id="a9a3900467aaca1b8a4c1362db68f305b19582ef" translate="yes" xml:space="preserve">
          <source>Geometric: length</source>
          <target state="translated">幾何学的:長さ</target>
        </trans-unit>
        <trans-unit id="1ba5f3a75b551d018972ef798eb335c100716e14" translate="yes" xml:space="preserve">
          <source>Geometric: line</source>
          <target state="translated">幾何学的な:線</target>
        </trans-unit>
        <trans-unit id="206f9fccbd7deb8bf02553e15b19fa03337233fd" translate="yes" xml:space="preserve">
          <source>Geometric: lseg</source>
          <target state="translated">幾何学的:lseg</target>
        </trans-unit>
        <trans-unit id="4d54cec15bcab56f2da1b1f390b73632b1dcbf4d" translate="yes" xml:space="preserve">
          <source>Geometric: npoints</source>
          <target state="translated">幾何学的:n点</target>
        </trans-unit>
        <trans-unit id="28645e62602ce8fec7218147e4987f407e8f9a72" translate="yes" xml:space="preserve">
          <source>Geometric: path</source>
          <target state="translated">幾何学的:パス</target>
        </trans-unit>
        <trans-unit id="45ec99c5c4e908e62ccff4e585500d723032cfdc" translate="yes" xml:space="preserve">
          <source>Geometric: pclose</source>
          <target state="translated">幾何学的:pclose</target>
        </trans-unit>
        <trans-unit id="507989896f0547d05a215ff9f295d24b17e091c7" translate="yes" xml:space="preserve">
          <source>Geometric: point</source>
          <target state="translated">幾何学的:点</target>
        </trans-unit>
        <trans-unit id="3ae9f6bad12ee8c28eb43284381811f2bae31846" translate="yes" xml:space="preserve">
          <source>Geometric: polygon</source>
          <target state="translated">幾何学的:多角形</target>
        </trans-unit>
        <trans-unit id="819b82ef2ad538d3fe48c1ae412245c21d9fd58a" translate="yes" xml:space="preserve">
          <source>Geometric: popen</source>
          <target state="translated">幾何学的:ポペン</target>
        </trans-unit>
        <trans-unit id="833a7938b28ff55bf890ede9562c88a3cf3616b2" translate="yes" xml:space="preserve">
          <source>Geometric: radius</source>
          <target state="translated">幾何学的:半径</target>
        </trans-unit>
        <trans-unit id="7f7868cefc6080ede3e7599ccdee8580f1c6391a" translate="yes" xml:space="preserve">
          <source>Geometric: width</source>
          <target state="translated">幾何学的:幅</target>
        </trans-unit>
        <trans-unit id="a3d7536af893973e797484588417b811fa49c9c9" translate="yes" xml:space="preserve">
          <source>Geometric: |&amp;amp;&amp;gt;</source>
          <target state="translated">幾何学的：|＆&amp;gt;</target>
        </trans-unit>
        <trans-unit id="dac5ddcfb396044c241822b103826072cea9122a" translate="yes" xml:space="preserve">
          <source>Geometric: |&amp;gt;&amp;gt;</source>
          <target state="translated">幾何学的：| &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e1ce90a64a5a3e719604091e787102d24302368f" translate="yes" xml:space="preserve">
          <source>Geometric: ~=</source>
          <target state="translated">幾何学的:~=。</target>
        </trans-unit>
        <trans-unit id="3764766959b2e2fca792b770cb84c07ab6ed354f" translate="yes" xml:space="preserve">
          <source>Germ&amp;aacute;n M&amp;eacute;ndez Bravo (Kronuz), 2004 - 2006</source>
          <target state="translated">Germ&amp;aacute;nM&amp;eacute;ndezBravo（Kronuz）、2004〜2006</target>
        </trans-unit>
        <trans-unit id="8435540f9357c0427826e02b4177ce363970db3c" translate="yes" xml:space="preserve">
          <source>German collation for Austria, default variant</source>
          <target state="translated">オーストリアのドイツ語照合順序、デフォルトのバリアント</target>
        </trans-unit>
        <trans-unit id="7510fc993536622c741a49aafa894361e7ab10a4" translate="yes" xml:space="preserve">
          <source>German collation with phone book collation type</source>
          <target state="translated">電話帳照合式のドイツ語照合</target>
        </trans-unit>
        <trans-unit id="564857758dc8e91c1f74d993f78de5567b5c7dfc" translate="yes" xml:space="preserve">
          <source>German collation, default variant</source>
          <target state="translated">ドイツ語照合、デフォルトのバリアント</target>
        </trans-unit>
        <trans-unit id="f27aff0cadc166c49cd93ee1187bf701f6029a5e" translate="yes" xml:space="preserve">
          <source>Get &lt;code&gt;n&lt;/code&gt;-th coordinate of cube (counting from 1).</source>
          <target state="translated">キューブの &lt;code&gt;n&lt;/code&gt; 番目の座標を取得します（1から数えます）。</target>
        </trans-unit>
        <trans-unit id="d35f795aa05a88fb426392aad122ef3b2bb082f7" translate="yes" xml:space="preserve">
          <source>Get &lt;code&gt;n&lt;/code&gt;-th coordinate of cube in following way: n = 2 * k - 1 means lower bound of &lt;code&gt;k&lt;/code&gt;-th dimension, n = 2 * k means upper bound of &lt;code&gt;k&lt;/code&gt;-th dimension. Negative &lt;code&gt;n&lt;/code&gt; denotes the inverse value of the corresponding positive coordinate. This operator is designed for KNN-GiST support.</source>
          <target state="translated">次の方法でキューブの &lt;code&gt;n&lt;/code&gt; 番目の座標を取得します。n= 2 * k-1は &lt;code&gt;k&lt;/code&gt; 番目の次元の下限を意味し、n = 2 * kは &lt;code&gt;k&lt;/code&gt; 番目の次元の上限を意味します。負の &lt;code&gt;n&lt;/code&gt; は、対応する正の座標の逆の値を示します。このオペレーターは、KNN-GiSTサポート用に設計されています。</target>
        </trans-unit>
        <trans-unit id="cc6f8c8aaf13b3fdd311883db3b903abaee70123" translate="yes" xml:space="preserve">
          <source>Get JSON array element (indexed from zero, negative integers count from the end)</source>
          <target state="translated">JSON配列の要素を取得します(インデックスは0から、負の整数は末尾から数えます)。</target>
        </trans-unit>
        <trans-unit id="96cd8c94d1b03053f959c0260a5693091dfb369e" translate="yes" xml:space="preserve">
          <source>Get JSON array element as &lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">JSON配列要素を &lt;code&gt;text&lt;/code&gt; として取得する</target>
        </trans-unit>
        <trans-unit id="cf31bd14e1935206dcfd63aadbd1872ba57dea93" translate="yes" xml:space="preserve">
          <source>Get JSON object at the specified path</source>
          <target state="translated">指定したパスのJSONオブジェクトを取得します。</target>
        </trans-unit>
        <trans-unit id="ef1cbd5cb305475720a9020825d5fd0aab442b3e" translate="yes" xml:space="preserve">
          <source>Get JSON object at the specified path as &lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">指定されたパスにあるJSONオブジェクトを &lt;code&gt;text&lt;/code&gt; として取得します</target>
        </trans-unit>
        <trans-unit id="25fd43d0d3f16339264c4b37b814115f9d3ce410" translate="yes" xml:space="preserve">
          <source>Get JSON object field as &lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">JSONオブジェクトフィールドを &lt;code&gt;text&lt;/code&gt; として取得する</target>
        </trans-unit>
        <trans-unit id="073ceb452af411396658b2179c607b15772b77b9" translate="yes" xml:space="preserve">
          <source>Get JSON object field by key</source>
          <target state="translated">キーによるJSONオブジェクトフィールドの取得</target>
        </trans-unit>
        <trans-unit id="a3c9485f60ac0e72f3350d75767b48ed6ff294ae" translate="yes" xml:space="preserve">
          <source>Get current write-ahead log flush location</source>
          <target state="translated">現在の書き込み優先ログのフラッシュ位置を取得します。</target>
        </trans-unit>
        <trans-unit id="ff5bd5ba7d4bd0b1adf164a5c3514a0cde09068d" translate="yes" xml:space="preserve">
          <source>Get current write-ahead log insert location</source>
          <target state="translated">現在の書き込み優先ログの挿入場所を取得します。</target>
        </trans-unit>
        <trans-unit id="6d563af8ba9dd62228b11fa7ee4de03e9c015df2" translate="yes" xml:space="preserve">
          <source>Get current write-ahead log write location</source>
          <target state="translated">現在の書き込み先ログの書き込み位置を取得</target>
        </trans-unit>
        <trans-unit id="6128ac644ecb365c2a1eeec7ff1509ae52372521" translate="yes" xml:space="preserve">
          <source>Get last write-ahead log location received and synced to disk by streaming replication. While streaming replication is in progress this will increase monotonically. If recovery has completed this will remain static at the value of the last WAL record received and synced to disk during recovery. If streaming replication is disabled, or if it has not yet started, the function returns NULL.</source>
          <target state="translated">ストリーミング・レプリケーションで受信し、ディスクに同期された最後の書込先ログの場所を取得します。ストリーミングレプリケーションが進行中の間は、これは単調増加します。リカバリが完了した場合、これは、リカバリ中に最後に受信してディスクに同期されたWALレコードの値で静的なままになります。ストリーミングレプリケーションが無効な場合、またはまだ開始していない場合、この関数は NULL を返す。</target>
        </trans-unit>
        <trans-unit id="76a64be22601bc127252c3868430ba6f7837c55b" translate="yes" xml:space="preserve">
          <source>Get last write-ahead log location replayed during recovery. If recovery is still in progress this will increase monotonically. If recovery has completed then this value will remain static at the value of the last WAL record applied during that recovery. When the server has been started normally without recovery the function returns NULL.</source>
          <target state="translated">リカバリー中に再生された最後の書込み先ログの場所を取得します。リカバリがまだ進行中の場合、この値は単調に増加します。リカバリが完了した場合、この値は、そのリカバリ中に適用された最後の WAL レコードの値に固定されたままになります。サーバがリカバリなしで正常に起動された場合、この関数は NULL を返す。</target>
        </trans-unit>
        <trans-unit id="406fdc630e83917e4241518be673ae1f0d8347d2" translate="yes" xml:space="preserve">
          <source>Get start time of an on-line exclusive backup in progress.</source>
          <target state="translated">オンラインでの排他的なバックアップの開始時間を取得します。</target>
        </trans-unit>
        <trans-unit id="dca6c016406c3b0ed8f48fe56cd9e3bf358bbd54" translate="yes" xml:space="preserve">
          <source>Get subfield (equivalent to &lt;code&gt;extract&lt;/code&gt;); see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt;</source>
          <target state="translated">サブフィールドを取得します（ &lt;code&gt;extract&lt;/code&gt; と同等）。&lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;セクション9.9.1を&lt;/a&gt;参照</target>
        </trans-unit>
        <trans-unit id="3152064f9ae3eb1ab6d172e1fe8f75ea161bdf61" translate="yes" xml:space="preserve">
          <source>Get subfield; see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt;</source>
          <target state="translated">サブフィールドを取得します。&lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;セクション9.9.1を&lt;/a&gt;参照</target>
        </trans-unit>
        <trans-unit id="4cfad13dc60760cc3b206a5a63697b11a532048c" translate="yes" xml:space="preserve">
          <source>Get time stamp of last transaction replayed during recovery. This is the time at which the commit or abort WAL record for that transaction was generated on the primary. If no transactions have been replayed during recovery, this function returns NULL. Otherwise, if recovery is still in progress this will increase monotonically. If recovery has completed then this value will remain static at the value of the last transaction applied during that recovery. When the server has been started normally without recovery the function returns NULL.</source>
          <target state="translated">リカバリ中に再生された最後のトランザクションのタイムスタンプを取得します。これは、そのトランザクションのコミットまたはアボートWALレコードがプライマリ上に生成された時刻です。リカバリ中にトランザクションが再生されなかった場合、この関数は NULL を返します。そうでない場合、リカバリがまだ進行中であれば、この値は単調に増加します。リカバリが完了した場合、この値は、そのリカバリ中に適用された最後のトランザクションの値で静的なままである。リカバリを行わずにサーバが正常に起動された場合、この関数は NULL を返す。</target>
        </trans-unit>
        <trans-unit id="2286e40b8a539e9f8b5d59de04327253f0b8e306" translate="yes" xml:space="preserve">
          <source>Gets all JSON items returned by JSON path for the specified JSON value and wraps result into an array.</source>
          <target state="translated">指定したJSON値のJSONパスで返されたJSON項目をすべて取得し、結果を配列にラップします。</target>
        </trans-unit>
        <trans-unit id="69ca4727f266434b20f8a8cff91f85228790e89c" translate="yes" xml:space="preserve">
          <source>Gets all JSON items returned by JSON path for the specified JSON value.</source>
          <target state="translated">指定したJSON値のJSONパスが返すJSON項目を全て取得します。</target>
        </trans-unit>
        <trans-unit id="f74211e2c2ac907544fec9e563a5484f2bc9bf8f" translate="yes" xml:space="preserve">
          <source>Gets the current status of the weak mode</source>
          <target state="translated">弱モードの現在の状態を取得します。</target>
        </trans-unit>
        <trans-unit id="ffe1d3bb8fb75103abea9d97f24675a5e6f74f12" translate="yes" xml:space="preserve">
          <source>Gets the first JSON item returned by JSON path for the specified JSON value. Returns &lt;code&gt;NULL&lt;/code&gt; on no results.</source>
          <target state="translated">指定されたJSON値のJSONパスによって返された最初のJSONアイテムを取得します。結果がない場合は &lt;code&gt;NULL&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="1ea0c334189a899d918625993b37ead61ecb3937" translate="yes" xml:space="preserve">
          <source>GiST</source>
          <target state="translated">GiST</target>
        </trans-unit>
        <trans-unit id="2c7e841b76f37f5f1283940a7342c797bb3bd024" translate="yes" xml:space="preserve">
          <source>GiST Development Site &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt;</source>
          <target state="translated">GiST開発サイト&lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="77dacc994e0a5c24fbb20b4e435e091dad5586f5" translate="yes" xml:space="preserve">
          <source>GiST Indexes: Built-in Operator Classes</source>
          <target state="translated">GiSTインデックス 組込み演算子クラス</target>
        </trans-unit>
        <trans-unit id="22165dcd40882c92f600bb8d95e394930c229760" translate="yes" xml:space="preserve">
          <source>GiST Indexes: Examples</source>
          <target state="translated">GiSTインデックス 例</target>
        </trans-unit>
        <trans-unit id="cd4fa206206b0d9b9a4a09e74cdc45a9b7bac6d5" translate="yes" xml:space="preserve">
          <source>GiST Indexes: Extensibility</source>
          <target state="translated">GiSTインデックス 拡張性</target>
        </trans-unit>
        <trans-unit id="1e6e31ed1dfc0534ae7fa938c637d58b4def631a" translate="yes" xml:space="preserve">
          <source>GiST Indexes: Implementation</source>
          <target state="translated">GiSTインデックス 実装</target>
        </trans-unit>
        <trans-unit id="494456433e65d5f6cf54c8e3f52f00d35404d83c" translate="yes" xml:space="preserve">
          <source>GiST and SP-GiST indexes can be created for table columns of range types. For instance, to create a GiST index:</source>
          <target state="translated">GiSTインデックスとSP-GISTインデックスは、範囲型のテーブル列に対して作成することができます。例えば、GiSTインデックスを作成するには</target>
        </trans-unit>
        <trans-unit id="49924620a95a816339f17d76ecc000e2cecd8a90" translate="yes" xml:space="preserve">
          <source>GiST index over &lt;code&gt;ltree&lt;/code&gt;: &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;@&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">以上のGiSTインデックス &lt;code&gt;ltree&lt;/code&gt; は： &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;@&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;@&lt;/code&gt; 、 &lt;code&gt;@&lt;/code&gt; 、 &lt;code&gt;~&lt;/code&gt; 、 &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17c380bccd59920d150dcf1776323ee944932357" translate="yes" xml:space="preserve">
          <source>GiST index over &lt;code&gt;ltree[]&lt;/code&gt;: &lt;code&gt;ltree[] &amp;lt;@ ltree&lt;/code&gt;, &lt;code&gt;ltree @&amp;gt; ltree[]&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">以上のGiSTインデックス &lt;code&gt;ltree[]&lt;/code&gt; ： &lt;code&gt;ltree[] &amp;lt;@ ltree&lt;/code&gt; 、 &lt;code&gt;ltree @&amp;gt; ltree[]&lt;/code&gt; 、 &lt;code&gt;@&lt;/code&gt; 、 &lt;code&gt;~&lt;/code&gt; 、 &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d319a311ddbbf36d4e1fdb2142c71c77f7a27e3" translate="yes" xml:space="preserve">
          <source>GiST indexes additionally accept this parameter:</source>
          <target state="translated">GiSTインデックスはこのパラメータを追加で受け付けることができます。</target>
        </trans-unit>
        <trans-unit id="fd10e71b27221cbba626117e71058b4d0b5d0794" translate="yes" xml:space="preserve">
          <source>GiST indexes are also capable of optimizing &amp;ldquo;nearest-neighbor&amp;rdquo; searches, such as</source>
          <target state="translated">GiSTインデックスは、次のような「最も近い」検索を最適化することもできます。</target>
        </trans-unit>
        <trans-unit id="52e06a8812b702e9e01b2b2a18cfa676aaed004f" translate="yes" xml:space="preserve">
          <source>GiST indexes are not a single kind of index, but rather an infrastructure within which many different indexing strategies can be implemented. Accordingly, the particular operators with which a GiST index can be used vary depending on the indexing strategy (the &lt;em&gt;operator class&lt;/em&gt;). As an example, the standard distribution of PostgreSQL includes GiST operator classes for several two-dimensional geometric data types, which support indexed queries using these operators:</source>
          <target state="translated">GiSTインデックスは、単一の種類のインデックスではなく、多くの異なるインデックス作成戦略を実装できるインフラストラクチャです。したがって、GiSTインデックスで使用できる特定の演算子は、インデックス作成戦略（&lt;em&gt;演算子クラス&lt;/em&gt;）によって異なります。例として、PostgreSQLの標準ディストリビューションには、いくつかの2次元ジオメトリックデータタイプのGiST演算子クラスが含まれており、これらの演算子を使用したインデックス付きクエリをサポートしています。</target>
        </trans-unit>
        <trans-unit id="8444450d765d03c90597419731d461339d26e37a" translate="yes" xml:space="preserve">
          <source>GiST stands for Generalized Search Tree. It is a balanced, tree-structured access method, that acts as a base template in which to implement arbitrary indexing schemes. B-trees, R-trees and many other indexing schemes can be implemented in GiST.</source>
          <target state="translated">GiSTはGeneralized Search Treeの略です。バランスのとれた木構造のアクセス方法であり、任意の索引付けスキームを実装するためのベーステンプレートとして機能します。B木、R木、その他多くの索引付け方式がGiSTで実装できます。</target>
        </trans-unit>
        <trans-unit id="5819778898df55e3a762f0c5728b457970d72cae" translate="yes" xml:space="preserve">
          <source>Git</source>
          <target state="translated">Git</target>
        </trans-unit>
        <trans-unit id="b0f44dac1f3500cf2c64a5e96b25bdc72296caa1" translate="yes" xml:space="preserve">
          <source>Give a role a non-default setting of the &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; parameter:</source>
          <target state="translated">役割に、&lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;パラメーターのデフォルト以外の設定を付与します。</target>
        </trans-unit>
        <trans-unit id="0d339f7ddc04ed38d6c4f1627fd17d7b3c263479" translate="yes" xml:space="preserve">
          <source>Give a role a non-default, database-specific setting of the &lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt; parameter:</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt;パラメータのデフォルトではないデータベース固有の設定をロールに付与します。</target>
        </trans-unit>
        <trans-unit id="657b05bd06e4a30ca8560408b6cca3b16ee24c04" translate="yes" xml:space="preserve">
          <source>Give a role the ability to create other roles and new databases:</source>
          <target state="translated">他の役割と新しいデータベースを作成する能力を与えます。</target>
        </trans-unit>
        <trans-unit id="7e461b397ac9e789e72233367d6e54d13bd1ea4f" translate="yes" xml:space="preserve">
          <source>Given an index entry &lt;code&gt;p&lt;/code&gt; and a query value &lt;code&gt;q&lt;/code&gt;, this function determines the index entry's &amp;ldquo;distance&amp;rdquo; from the query value. This function must be supplied if the operator class contains any ordering operators. A query using the ordering operator will be implemented by returning index entries with the smallest &amp;ldquo;distance&amp;rdquo; values first, so the results must be consistent with the operator's semantics. For a leaf index entry the result just represents the distance to the index entry; for an internal tree node, the result must be the smallest distance that any child entry could have.</source>
          <target state="translated">インデックスエントリ &lt;code&gt;p&lt;/code&gt; とクエリ値 &lt;code&gt;q&lt;/code&gt; が与えられると、この関数はクエリ値からインデックスエントリの「距離」を決定します。演算子クラスに順序付け演算子が含まれている場合、この関数を指定する必要があります。順序付け演算子を使用したクエリは、最小の「距離」値を持つインデックスエントリを最初に返すことで実装されるため、結果は演算子のセマンティクスと一致している必要があります。リーフインデックスエントリの場合、結果はインデックスエントリまでの距離を表します。内部ツリーノードの場合、結果は、子エントリが持つことができる最小距離でなければなりません。</target>
        </trans-unit>
        <trans-unit id="693396c0b50006bc8bf563a767c6df7376338535" translate="yes" xml:space="preserve">
          <source>Given an index entry &lt;code&gt;p&lt;/code&gt; and a query value &lt;code&gt;q&lt;/code&gt;, this function determines whether the index entry is &amp;ldquo;consistent&amp;rdquo; with the query; that is, could the predicate &amp;ldquo;&lt;code&gt;indexed_column&lt;/code&gt;&lt;code&gt;indexable_operator&lt;/code&gt;&lt;code&gt;q&lt;/code&gt;&amp;rdquo; be true for any row represented by the index entry? For a leaf index entry this is equivalent to testing the indexable condition, while for an internal tree node this determines whether it is necessary to scan the subtree of the index represented by the tree node. When the result is &lt;code&gt;true&lt;/code&gt;, a &lt;code&gt;recheck&lt;/code&gt; flag must also be returned. This indicates whether the predicate is certainly true or only possibly true. If &lt;code&gt;recheck&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; then the index has tested the predicate condition exactly, whereas if &lt;code&gt;recheck&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; the row is only a candidate match. In that case the system will automatically evaluate the &lt;code&gt;indexable_operator&lt;/code&gt; against the actual row value to see if it is really a match. This convention allows GiST to support both lossless and lossy index structures.</source>
          <target state="translated">インデックスエントリ &lt;code&gt;p&lt;/code&gt; とクエリ値 &lt;code&gt;q&lt;/code&gt; が与えられると、この関数はインデックスエントリがクエリと「整合性がある」かどうかを判断します。つまり、述語「 &lt;code&gt;indexed_column&lt;/code&gt; indexable_operator &lt;code&gt;q&lt;/code&gt; 」は、インデックスエントリによって表される任意の行に対してtrueになる &lt;code&gt;indexable_operator&lt;/code&gt; 性がありますか？リーフインデックスエントリの場合、これはインデックス可能な条件をテストすることと同じですが、内部ツリーノードの場合、これは、ツリーノードによって表されるインデックスのサブツリーをスキャンする必要があるかどうかを決定します。結果が &lt;code&gt;true&lt;/code&gt; の場合、 &lt;code&gt;recheck&lt;/code&gt; フラグも返す必要があります。これは、述語が確かに真であるか、おそらく真であるかを示します。 &lt;code&gt;recheck&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; の場合次に、インデックスは述語条件を正確にテストしましたが、 &lt;code&gt;recheck&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; の場合、行は候補の一致のみです。その場合、システムは実際の行の値に対して &lt;code&gt;indexable_operator&lt;/code&gt; を自動的に評価し、実際に一致するかどうかを確認します。この規則により、GiSTはロスレスとロッシーの両方のインデックス構造をサポートできます。</target>
        </trans-unit>
        <trans-unit id="e92d55ae3ac298e4b66632b1af221ac34e3be444" translate="yes" xml:space="preserve">
          <source>Given an index tuple and an indexed value, modifies the indicated attribute of the tuple so that it additionally represents the new value. If any modification was done to the tuple, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">インデックスタプルとインデックス付きの値を指定すると、タプルの指定された属性を変更して、新しい値を追加で表すようにします。タプルに変更が加えられた場合、 &lt;code&gt;true&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="769764fd5b04005314c3f8df7317ab69c5882b21" translate="yes" xml:space="preserve">
          <source>Given the cost of the plan, it is entirely reasonable that no JIT was used; the cost of JIT would have been bigger than the potential savings. Adjusting the cost limits will lead to JIT use:</source>
          <target state="translated">計画のコストを考えれば、JIT を使用しなかったのは完全に合理的であり、JIT のコストは潜在的な節約よりも大きかったであろう。コストの限界を調整することが、JITの利用につながる。</target>
        </trans-unit>
        <trans-unit id="37460509d9524c32ce3522fe588bb30e9b9a9e2c" translate="yes" xml:space="preserve">
          <source>Given the default configuration and only the first function existing, the first and second calls are insecure. Any user could intercept them by creating the second or third function. By matching the argument type exactly and using the &lt;code&gt;VARIADIC&lt;/code&gt; keyword, the third call is secure.</source>
          <target state="translated">デフォルトの構成と最初の関数のみが存在する場合、最初と2番目の呼び出しは安全ではありません。どのユーザーも、2番目または3番目の関数を作成することで、それらを傍受できます。引数の型を正確に照合し、 &lt;code&gt;VARIADIC&lt;/code&gt; キーワードを使用することにより、3番目の呼び出しは安全です。</target>
        </trans-unit>
        <trans-unit id="40af5c52e4886430e556bb2588adddc7f3345e29" translate="yes" xml:space="preserve">
          <source>Given the sample data from the PostgreSQL tutorial (see &lt;a href=&quot;tutorial-sql-intro&quot;&gt;Section 2.1&lt;/a&gt;), this returns:</source>
          <target state="translated">PostgreSQLチュートリアルからのサンプルデータ（&lt;a href=&quot;tutorial-sql-intro&quot;&gt;セクション2.1を&lt;/a&gt;参照）が与えられると、これは以下を返します。</target>
        </trans-unit>
        <trans-unit id="48862a4ac236aec67af11d9ca9afc2c469e5ae88" translate="yes" xml:space="preserve">
          <source>Gives syntax help on the specified SQL command. If &lt;code&gt;command&lt;/code&gt; is not specified, then psql will list all the commands for which syntax help is available. If &lt;code&gt;command&lt;/code&gt; is an asterisk (&lt;code&gt;*&lt;/code&gt;), then syntax help on all SQL commands is shown.</source>
          <target state="translated">指定されたSQLコマンドの構文ヘルプを提供します。 &lt;code&gt;command&lt;/code&gt; が指定されていない場合、psqlは構文ヘルプが利用可能なすべてのコマンドをリストします。場合は &lt;code&gt;command&lt;/code&gt; アスタリスク（ある &lt;code&gt;*&lt;/code&gt; ）は、すべてのSQLコマンドの構文ヘルプが表示されます。</target>
        </trans-unit>
        <trans-unit id="696e22e619af6c7115546ae99d980b04fd02c2c6" translate="yes" xml:space="preserve">
          <source>Gives the distance in statute miles between two points on the Earth's surface.</source>
          <target state="translated">地球表面上の2つの点間の距離を平方マイルで表示します。</target>
        </trans-unit>
        <trans-unit id="b2e72630d76d2483c8fcffc2dffd1c7c6a52ab67" translate="yes" xml:space="preserve">
          <source>Global transaction identifier that was assigned to the transaction</source>
          <target state="translated">トランザクションに割り当てられたグローバル・トランザクション識別子</target>
        </trans-unit>
        <trans-unit id="31e73c02a46d40c2d70edd740f19c8958fbb213c" translate="yes" xml:space="preserve">
          <source>Global validity checks require extra thought under non-serializable MVCC. For example, a banking application might wish to check that the sum of all credits in one table equals the sum of debits in another table, when both tables are being actively updated. Comparing the results of two successive &lt;code&gt;SELECT sum(...)&lt;/code&gt; commands will not work reliably in Read Committed mode, since the second query will likely include the results of transactions not counted by the first. Doing the two sums in a single repeatable read transaction will give an accurate picture of only the effects of transactions that committed before the repeatable read transaction started &amp;mdash; but one might legitimately wonder whether the answer is still relevant by the time it is delivered. If the repeatable read transaction itself applied some changes before trying to make the consistency check, the usefulness of the check becomes even more debatable, since now it includes some but not all post-transaction-start changes. In such cases a careful person might wish to lock all tables needed for the check, in order to get an indisputable picture of current reality. A &lt;code&gt;SHARE&lt;/code&gt; mode (or higher) lock guarantees that there are no uncommitted changes in the locked table, other than those of the current transaction.</source>
          <target state="translated">グローバル有効性チェックは、シリアライズ不可能なMVCCの下での追加の検討を必要とします。たとえば、銀行のアプリケーションでは、両方のテーブルがアクティブに更新されているときに、1つのテーブルのすべてのクレジットの合計が別のテーブルの借方の合計と等しいことを確認する場合があります。 2つの連続する &lt;code&gt;SELECT sum(...)&lt;/code&gt; の結果の比較2番目のクエリには最初のクエリではカウントされなかったトランザクションの結果が含まれる可能性が高いため、Read Committedモードではコマンドは確実に機能しません。単一の繰り返し可能な読み取りトランザクションで2つの合計を実行すると、繰り返し可能な読み取りトランザクションが開始する前にコミットされたトランザクションの影響のみが正確にわかります。ただし、回答が配信されるまでに適切であるかどうかは正当に疑問に思われるかもしれません。一貫性チェックを行う前に、繰り返し可能な読み取りトランザクション自体がいくつかの変更を適用した場合、トランザクション開始後の変更のすべてではなく一部が含まれるため、チェックの有用性はさらに議論の余地があります。そのような場合、注意深い人は、現在の現実の議論の余地のない絵を得るために、チェックに必要なすべてのテーブルをロックしたいと思うかもしれません。 &lt;code&gt;SHARE&lt;/code&gt; モード（またはそれ以上）ロックは、現在のトランザクションの変更以外に、ロックされたテーブルにコミットされていない変更がないことを保証します。</target>
        </trans-unit>
        <trans-unit id="4a647f902e0d765ea12195a96e4829f8b1e8aa9f" translate="yes" xml:space="preserve">
          <source>Good Practices</source>
          <target state="translated">グッドプラクティス</target>
        </trans-unit>
        <trans-unit id="3c09ec28f005ae7495ffdeada3d59d9447d92430" translate="yes" xml:space="preserve">
          <source>Good results will show most (&amp;gt;90%) individual timing calls take less than one microsecond. Average per loop overhead will be even lower, below 100 nanoseconds. This example from an Intel i7-860 system using a TSC clock source shows excellent performance:</source>
          <target state="translated">良い結果は、ほとんど（&amp;gt; 90％）の個別のタイミングコールに1マイクロ秒未満かかることを示しています。ループあたりの平均オーバーヘッドはさらに低くなり、100ナノ秒未満になります。TSCクロックソースを使用したIntel i7-860システムのこの例は、優れたパフォーマンスを示しています。</target>
        </trans-unit>
        <trans-unit id="01af961ffadccd5726ec885717dd08dd99e478cf" translate="yes" xml:space="preserve">
          <source>Grant SELECT privilege to everyone for all tables (and views) you subsequently create in schema &lt;code&gt;myschema&lt;/code&gt;, and allow role &lt;code&gt;webuser&lt;/code&gt; to INSERT into them too:</source>
          <target state="translated">スキーマ &lt;code&gt;myschema&lt;/code&gt; で後で作成するすべてのテーブル（およびビュー）に対するすべてのユーザーにSELECT権限を付与し、ロール &lt;code&gt;webuser&lt;/code&gt; がそれらにINSERT できるようにします。</target>
        </trans-unit>
        <trans-unit id="24617f7e457da3734cfeda27633b2aa731a9c9ef" translate="yes" xml:space="preserve">
          <source>Grant all available privileges to user &lt;code&gt;manuel&lt;/code&gt; on view &lt;code&gt;kinds&lt;/code&gt;:</source>
          <target state="translated">ビューの &lt;code&gt;kinds&lt;/code&gt; に関するすべての利用可能な権限をユーザー &lt;code&gt;manuel&lt;/code&gt; に付与します。</target>
        </trans-unit>
        <trans-unit id="6e182dc9d9691657bc39b554f5fd47996c873086" translate="yes" xml:space="preserve">
          <source>Grant all of the privileges available for the object's type. The &lt;code&gt;PRIVILEGES&lt;/code&gt; key word is optional in PostgreSQL, though it is required by strict SQL.</source>
          <target state="translated">オブジェクトのタイプに使用できるすべての権限を付与します。 &lt;code&gt;PRIVILEGES&lt;/code&gt; それは、厳密なSQLによって必要とされるが、キーワードが、PostgreSQLでは省略可能です。</target>
        </trans-unit>
        <trans-unit id="bb6ece16050b16e5f45fddd08ab0ab254c3c1353" translate="yes" xml:space="preserve">
          <source>Grant all privileges on all views in schema &lt;code&gt;public&lt;/code&gt; to role &lt;code&gt;webuser&lt;/code&gt;:</source>
          <target state="translated">スキーマ &lt;code&gt;public&lt;/code&gt; のすべてのビューに対するすべての権限をロール &lt;code&gt;webuser&lt;/code&gt; に付与します。</target>
        </trans-unit>
        <trans-unit id="269d15aac0905b9feb98dc13ab02754db1782270" translate="yes" xml:space="preserve">
          <source>Grant insert privilege to all users on table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">テーブル &lt;code&gt;films&lt;/code&gt; すべてのユーザーに挿入権限を付与します。</target>
        </trans-unit>
        <trans-unit id="ba27670ed37d6c78d0b14c4148d50cc7aab110fa" translate="yes" xml:space="preserve">
          <source>Grant membership in role &lt;code&gt;admins&lt;/code&gt; to user &lt;code&gt;joe&lt;/code&gt;:</source>
          <target state="translated">ロール &lt;code&gt;admins&lt;/code&gt; メンバーシップをユーザー &lt;code&gt;joe&lt;/code&gt; に付与します。</target>
        </trans-unit>
        <trans-unit id="1f88fd823ea9c3dd2200a42432c3efa9ef706298" translate="yes" xml:space="preserve">
          <source>Granting permission on a table does not automatically extend permissions to any sequences used by the table, including sequences tied to &lt;code&gt;SERIAL&lt;/code&gt; columns. Permissions on sequences must be set separately.</source>
          <target state="translated">テーブルに対する権限を付与しても、 &lt;code&gt;SERIAL&lt;/code&gt; 列に関連付けられたシーケンスを含め、テーブルで使用されるシーケンスへの権限は自動的に拡張されません。シーケンスの権限は個別に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="599294f23ef04a992bc69ba465066344c3c7cf34" translate="yes" xml:space="preserve">
          <source>Greater than</source>
          <target state="translated">グレーター</target>
        </trans-unit>
        <trans-unit id="e7c7faa35b86c7d8f2aa278406d57686d0e76cab" translate="yes" xml:space="preserve">
          <source>Greater-than operator</source>
          <target state="translated">グレーター・ザン・オペレーター</target>
        </trans-unit>
        <trans-unit id="1b0cd62dcaabb41d866e961c21030484cdf15a5a" translate="yes" xml:space="preserve">
          <source>Greater-than-or-equal-to operator</source>
          <target state="translated">等しくない演算子</target>
        </trans-unit>
        <trans-unit id="59d5f5b13f13f6d5e8e88a5a92e137f7d64b2954" translate="yes" xml:space="preserve">
          <source>Greek</source>
          <target state="translated">Greek</target>
        </trans-unit>
        <trans-unit id="fafd8001d43d87515ae86352c97c37616a4d6762" translate="yes" xml:space="preserve">
          <source>Greenwich Mean Time</source>
          <target state="translated">グリニッジ平均時</target>
        </trans-unit>
        <trans-unit id="6261b12bce7847fa9426739910b4246568401661" translate="yes" xml:space="preserve">
          <source>Gregorian years AD 1-99 can be entered by using 4 digits with leading zeros (e.g., &lt;code&gt;0099&lt;/code&gt; is AD 99).</source>
          <target state="translated">グレゴリオ暦の西暦1〜99年は、先頭にゼロを付けた4桁で入力できます（たとえば、 &lt;code&gt;0099&lt;/code&gt; は西暦99）。</target>
        </trans-unit>
        <trans-unit id="2b13ec9d057eee3b8bf047437042e0b54f1f6425" translate="yes" xml:space="preserve">
          <source>Grouping operations are used in conjunction with grouping sets (see &lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;Section 7.2.4&lt;/a&gt;) to distinguish result rows. The arguments to the &lt;code&gt;GROUPING&lt;/code&gt; operation are not actually evaluated, but they must match exactly expressions given in the &lt;code&gt;GROUP BY&lt;/code&gt; clause of the associated query level. Bits are assigned with the rightmost argument being the least-significant bit; each bit is 0 if the corresponding expression is included in the grouping criteria of the grouping set generating the result row, and 1 if it is not. For example:</source>
          <target state="translated">グループ化操作は、結果行を区別するためにグループ化セット（&lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;セクション7.2.4を&lt;/a&gt;参照）と組み合わせて使用​​されます。 &lt;code&gt;GROUPING&lt;/code&gt; 操作の引数は実際には評価されませんが、関連するクエリレベルの &lt;code&gt;GROUP BY&lt;/code&gt; 句で指定された式と正確に一致する必要があります。ビットは、右端の引数を最下位ビットとして割り当てられます。各行は、対応する式が結果行を生成するグループ化セットのグループ化基準に含まれている場合は0、含まれていない場合は1です。例えば：</target>
        </trans-unit>
        <trans-unit id="88d7c69cfe151f010dd11e55984fa5a2e4485f4b" translate="yes" xml:space="preserve">
          <source>Grouping without aggregate expressions effectively calculates the set of distinct values in a column. This can also be achieved using the &lt;code&gt;DISTINCT&lt;/code&gt; clause (see &lt;a href=&quot;queries-select-lists#QUERIES-DISTINCT&quot;&gt;Section 7.3.3&lt;/a&gt;).</source>
          <target state="translated">集約式なしでグループ化すると、列内の一連の個別の値が効果的に計算されます。これは、 &lt;code&gt;DISTINCT&lt;/code&gt; 句を使用して実現することもできます（&lt;a href=&quot;queries-select-lists#QUERIES-DISTINCT&quot;&gt;7.3.3項を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="b82d3603eb93c98eb825eb4e6b01ee350ff3fb6d" translate="yes" xml:space="preserve">
          <source>HASH version number</source>
          <target state="translated">HASHバージョン番号</target>
        </trans-unit>
        <trans-unit id="1cc155b76768b5b5fb2f3643a0744204e68a9ccc" translate="yes" xml:space="preserve">
          <source>HBA</source>
          <target state="translated">HBA</target>
        </trans-unit>
        <trans-unit id="0feddc013d3db0d214cc286a21a9e52cacbc17e4" translate="yes" xml:space="preserve">
          <source>HMAC: Keyed-Hashing for Message Authentication.</source>
          <target state="translated">HMAC。メッセージ認証のための鍵付きハッシュ。</target>
        </trans-unit>
        <trans-unit id="06833bde6c3138c525040c232dbadac4725bac88" translate="yes" xml:space="preserve">
          <source>HOT</source>
          <target state="translated">HOT</target>
        </trans-unit>
        <trans-unit id="c305ce22fa1ddad5ff6a9a241e6067a9f35cad67" translate="yes" xml:space="preserve">
          <source>HP-UX</source>
          <target state="translated">HP-UX</target>
        </trans-unit>
        <trans-unit id="61a2a1882fc631d64e7d30ef57cec31971ea2c09" translate="yes" xml:space="preserve">
          <source>Had there been MCV lists for the two columns, &lt;code&gt;eqjoinsel&lt;/code&gt; would have used direct comparison of the MCV lists to determine the join selectivity within the part of the column populations represented by the MCVs. The estimate for the remainder of the populations follows the same approach shown here.</source>
          <target state="translated">2つの列のMCVリストがあった場合、 &lt;code&gt;eqjoinsel&lt;/code&gt; はMCVリストの直接比較を使用して、MCVによって表される列の母集団の一部内の結合選択性を決定します。残りの母集団の推定は、ここで示したのと同じアプローチに従います。</target>
        </trans-unit>
        <trans-unit id="4bf7a6d465bc019e543ce8b66fbf5cd1235516a8" translate="yes" xml:space="preserve">
          <source>Had we not supplied values for all the subfields of the column, the remaining subfields would have been filled with null values.</source>
          <target state="translated">カラムのすべてのサブフィールドに値を与えなければ、残りのサブフィールドはヌル値で埋められていたでしょう。</target>
        </trans-unit>
        <trans-unit id="e0c8e4e26ef951b2d257ad48905d56d36c233bc8" translate="yes" xml:space="preserve">
          <source>Handling of Invalid or Ambiguous Timestamps</source>
          <target state="translated">無効または曖昧なタイムスタンプの処理</target>
        </trans-unit>
        <trans-unit id="56d01e9677df53b4a2c4ef118ff77a201dd06a2e" translate="yes" xml:space="preserve">
          <source>Has a replication origin been configured in the current session?</source>
          <target state="translated">現在のセッションでレプリケーションオリジンが構成されていますか?</target>
        </trans-unit>
        <trans-unit id="3127cc395c91e262a7a0864c40a7527573818c9c" translate="yes" xml:space="preserve">
          <source>Has the constraint been validated? Currently, can only be false for foreign keys and CHECK constraints</source>
          <target state="translated">制約は検証されていますか?現在のところ、外部キーとCHECK制約に対してのみfalseにすることができます。</target>
        </trans-unit>
        <trans-unit id="3dc36e4e0152a0239de102d530bd0c47b3d9e3a1" translate="yes" xml:space="preserve">
          <source>Hash Partitioning</source>
          <target state="translated">ハッシュ分割</target>
        </trans-unit>
        <trans-unit id="90507c1a5721f22f49292627451907b5c9b469f4" translate="yes" xml:space="preserve">
          <source>Hash functions &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;hash_murmur2&lt;/code&gt; and &lt;code&gt;hash_fnv1a&lt;/code&gt; accept an input value and an optional seed parameter. In case the seed isn't provided the value of &lt;code&gt;:default_seed&lt;/code&gt; is used, which is initialized randomly unless set by the command-line &lt;code&gt;-D&lt;/code&gt; option. Hash functions can be used to scatter the distribution of random functions such as &lt;code&gt;random_zipfian&lt;/code&gt; or &lt;code&gt;random_exponential&lt;/code&gt;. For instance, the following pgbench script simulates possible real world workload typical for social media and blogging platforms where few accounts generate excessive load:</source>
          <target state="translated">ハッシュ関数 &lt;code&gt;hash&lt;/code&gt; 、 &lt;code&gt;hash_murmur2&lt;/code&gt; および &lt;code&gt;hash_fnv1a&lt;/code&gt; は、入力値とオプションのシードパラメーターを受け入れます。シードが提供されていない場合、 &lt;code&gt;:default_seed&lt;/code&gt; の値が使用されます。これは、コマンドラインの &lt;code&gt;-D&lt;/code&gt; オプションで設定されない限り、ランダムに初期化されます。ハッシュ関数は、 &lt;code&gt;random_zipfian&lt;/code&gt; や &lt;code&gt;random_exponential&lt;/code&gt; などのランダム関数の分布を分散させるために使用できます。たとえば、次のpgbenchスクリプトは、ソーシャルメディアやブログプラットフォームに典型的な現実のワークロードをシミュレートし、アカウントが少ないと過度の負荷が発生します。</target>
        </trans-unit>
        <trans-unit id="cc1cfbcfc5781fb19f027f2126a6d7e099a4d8b1" translate="yes" xml:space="preserve">
          <source>Hash indexes</source>
          <target state="translated">ハッシュインデックス</target>
        </trans-unit>
        <trans-unit id="f9f75839548d1e6a1a51f586eb631d2c4a104ff8" translate="yes" xml:space="preserve">
          <source>Hash indexes can only handle simple equality comparisons. The query planner will consider using a hash index whenever an indexed column is involved in a comparison using the &lt;code&gt;=&lt;/code&gt; operator. The following command is used to create a hash index:</source>
          <target state="translated">ハッシュインデックスは、単純な等値比較のみを処理できます。クエリプランナーは、インデックス付きの列が &lt;code&gt;=&lt;/code&gt; 演算子を使用した比較に関与している場合は常に、ハッシュインデックスの使用を検討します。次のコマンドを使用して、ハッシュインデックスを作成します。</target>
        </trans-unit>
        <trans-unit id="ea4ccce2369daab1022355aaafd39217be056ac4" translate="yes" xml:space="preserve">
          <source>Hashes/sec</source>
          <target state="translated">Hashes/sec</target>
        </trans-unit>
        <trans-unit id="fa2065c836a17176e9e4314cc0f9ae6d0e4ea762" translate="yes" xml:space="preserve">
          <source>Having created this trigger, any change in &lt;code&gt;title&lt;/code&gt; or &lt;code&gt;body&lt;/code&gt; will automatically be reflected into &lt;code&gt;tsv&lt;/code&gt;, without the application having to worry about it.</source>
          <target state="translated">このトリガーを作成すると、 &lt;code&gt;title&lt;/code&gt; や &lt;code&gt;body&lt;/code&gt; 変更は、アプリケーションが心配することなく、自動的に &lt;code&gt;tsv&lt;/code&gt; に反映されます。</target>
        </trans-unit>
        <trans-unit id="349ced815f5c84c9f5228e606a1b7ba0c2ddee06" translate="yes" xml:space="preserve">
          <source>Having defined the types, we can use them to create tables:</source>
          <target state="translated">型を定義したので、それらを使ってテーブルを作成することができます。</target>
        </trans-unit>
        <trans-unit id="847116884ad55b09c96b3c4dc05ec99dcc5ec687" translate="yes" xml:space="preserve">
          <source>Header extension area length</source>
          <target state="translated">ヘッダー延長エリアの長さ</target>
        </trans-unit>
        <trans-unit id="e10aa6b979969f7c629b2451c2c2a904b3d450a7" translate="yes" xml:space="preserve">
          <source>Heap-Only Tuples</source>
          <target state="translated">ヒープのみのタプル</target>
        </trans-unit>
        <trans-unit id="348d00693e12bc983bd092677b90434b5a4d869e" translate="yes" xml:space="preserve">
          <source>Hebrew</source>
          <target state="translated">Hebrew</target>
        </trans-unit>
        <trans-unit id="0107076effd18727f0d6bde8cfc48a85171576c5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;*&lt;/code&gt; is a shorthand for &amp;ldquo;all columns&amp;rdquo;. &lt;a href=&quot;#ftn.id-1.4.4.6.2.10&quot;&gt;&lt;sup id=&quot;id-1.4.4.6.2.10&quot;&gt;[2]&lt;/sup&gt;&lt;/a&gt; So the same result would be had with:</source>
          <target state="translated">ここで &lt;code&gt;*&lt;/code&gt; は「すべての列」の省略形です。&lt;a href=&quot;#ftn.id-1.4.4.6.2.10&quot;&gt;&lt;sup id=&quot;id-1.4.4.6.2.10&quot;&gt;[2]&lt;/sup&gt;&lt;/a&gt;したがって、同じ結果が得られます。</target>
        </trans-unit>
        <trans-unit id="4c0298ee7318c32798634cdbf2dfdaaab57a634f" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;ANY&lt;/code&gt; can be considered either as introducing a subquery, or as being an aggregate function, if the subquery returns one row with a Boolean value. Thus the standard name cannot be given to these aggregates.</source>
          <target state="translated">ここで、 &lt;code&gt;ANY&lt;/code&gt; は、サブクエリを導入するもの、またはブール値を持つ1つの行をサブクエリが返す場合、集約関数と見なすことができます。したがって、これらの集合体に標準名を付けることはできません。</target>
        </trans-unit>
        <trans-unit id="fa4131a740f8662a6e1405a124ef5fe7cf873c01" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;expression&lt;/code&gt; is an arbitrary value expression that is evaluated for all rows. A set of rows for which all the expressions are equal are considered duplicates, and only the first row of the set is kept in the output. Note that the &amp;ldquo;first row&amp;rdquo; of a set is unpredictable unless the query is sorted on enough columns to guarantee a unique ordering of the rows arriving at the &lt;code&gt;DISTINCT&lt;/code&gt; filter. (&lt;code&gt;DISTINCT ON&lt;/code&gt; processing occurs after &lt;code&gt;ORDER BY&lt;/code&gt; sorting.)</source>
          <target state="translated">ここで &lt;code&gt;expression&lt;/code&gt; は、すべての行に対して評価される任意の値の式です。すべての式が等しい行のセットは重複と見なされ、セットの最初の行のみが出力に保持されます。 &lt;code&gt;DISTINCT&lt;/code&gt; フィルターに到達する行の一意の順序を保証するのに十分な列でクエリがソートされない限り、セットの「最初の行」は予測できないことに注意してください。（ &lt;code&gt;DISTINCT ON&lt;/code&gt; 処理は、 &lt;code&gt;ORDER BY&lt;/code&gt; ソート後に発生します。）</target>
        </trans-unit>
        <trans-unit id="32e70bf63bd6299c1b514b324e5813b6785f48fc" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;sum&lt;/code&gt; is an aggregate function that computes a single value over the entire group. More information about the available aggregate functions can be found in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt;.</source>
          <target state="translated">ここで &lt;code&gt;sum&lt;/code&gt; は、グループ全体で単一の値を計算する集約関数です。利用可能な集約関数の詳細については、&lt;a href=&quot;functions-aggregate&quot;&gt;セクション9.20を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c74e599f4f4cd10f806357bb4a577d879a636f92" translate="yes" xml:space="preserve">
          <source>Here again, the result row ordering might vary. You can ensure consistent results by using &lt;code&gt;DISTINCT&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt; together: &lt;a href=&quot;#ftn.id-1.4.4.6.6.7&quot;&gt;&lt;sup id=&quot;id-1.4.4.6.6.7&quot;&gt;[3]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">ここでも、結果の行の順序は異なる場合があります。 &lt;code&gt;DISTINCT&lt;/code&gt; と &lt;code&gt;ORDER BY&lt;/code&gt; を一緒に使用することで、一貫した結果を保証できます：&lt;a href=&quot;#ftn.id-1.4.4.6.6.7&quot;&gt;&lt;sup id=&quot;id-1.4.4.6.6.7&quot;&gt;[3]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9361fe781c0dc9515f2a15d806649d45978ad2ff" translate="yes" xml:space="preserve">
          <source>Here are a few more operating-system-specific suggestions. (In each case be sure to use the proper installation directory and user name where we show generic values.)</source>
          <target state="translated">ここでは、さらにいくつかのオペレーティングシステム固有の提案を紹介します。(いずれの場合も、一般的な値を表示する場合は、適切なインストールディレクトリとユーザ名を使用するようにしてください)。</target>
        </trans-unit>
        <trans-unit id="33c629349369b081c96a4709bd4c05ca3d526b68" translate="yes" xml:space="preserve">
          <source>Here are examples using &lt;code&gt;width&lt;/code&gt; fields and the &lt;code&gt;-&lt;/code&gt; flag:</source>
          <target state="translated">以下は、 &lt;code&gt;width&lt;/code&gt; フィールドと &lt;code&gt;-&lt;/code&gt; フラグの使用例です。</target>
        </trans-unit>
        <trans-unit id="7e1f296e08c37893cc7499c23d5ef526f191a997" translate="yes" xml:space="preserve">
          <source>Here are some example collations that might be created:</source>
          <target state="translated">ここでは、作成される可能性のある照合順序の例をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="794bf261c0ef6d9f03e6ee073f42ca9e62437531" translate="yes" xml:space="preserve">
          <source>Here are some examples for the Norwegian language:</source>
          <target state="translated">ノルウェー語の例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="aedfd7af6c8c45fb8ea4b749385a6c955d7ebd4b" translate="yes" xml:space="preserve">
          <source>Here are some examples of &lt;code&gt;WHERE&lt;/code&gt; clauses:</source>
          <target state="translated">次に、 &lt;code&gt;WHERE&lt;/code&gt; 句の例をいくつか示します。</target>
        </trans-unit>
        <trans-unit id="2b46ad535b1f1605c8d8b383d4b83d313d3c5c39" translate="yes" xml:space="preserve">
          <source>Here are some examples of full text search:</source>
          <target state="translated">全文検索の例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="59581a37d8149d77f6e2121b432ef3ab5471d652" translate="yes" xml:space="preserve">
          <source>Here are some examples of path matching:</source>
          <target state="translated">パスマッチングの例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="081304796cf08884f88e8e57322d960864d34d64" translate="yes" xml:space="preserve">
          <source>Here are some examples of the basic format conversions:</source>
          <target state="translated">基本的なフォーマット変換の例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="6671c9ef7af5c4291212558669b68a47697a4f97" translate="yes" xml:space="preserve">
          <source>Here are some examples of the proper syntax for inserting and updating composite columns. First, inserting or updating a whole column:</source>
          <target state="translated">ここでは、複合カラムの挿入と更新の適切な構文の例を紹介します。まず、列全体を挿入または更新します。</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">ここでは、いくつかの例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="cff6bd1f9746e782ec9405f845ffac129954f75a" translate="yes" xml:space="preserve">
          <source>Here are some suggestions about the easiest ways to perform common tasks when updating catalog data files.</source>
          <target state="translated">ここでは、カタログデータファイルを更新する際に一般的なタスクを実行する最も簡単な方法をいくつか提案します。</target>
        </trans-unit>
        <trans-unit id="8d395c7f381e1a472cda6f6e9e7b568dac052ead" translate="yes" xml:space="preserve">
          <source>Here are some trivial examples to help you get started. For more information and examples, see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt;.</source>
          <target state="translated">以下は、始めるのに役立つ簡単な例です。詳細と例については、&lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;セクション37.3を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="211fc895cd2c281ef748e752305609850c1006cd" translate="yes" xml:space="preserve">
          <source>Here are some usage examples:</source>
          <target state="translated">いくつかの使用例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="869c324dd483307e5d715a3f86abbbcd015bfd60" translate="yes" xml:space="preserve">
          <source>Here are two complete examples:</source>
          <target state="translated">ここでは、2つの完全な例を紹介します。</target>
        </trans-unit>
        <trans-unit id="461b806fbebb6f513c6608122e9ae50853cfb34f" translate="yes" xml:space="preserve">
          <source>Here are two simple examples of defining composite types:</source>
          <target state="translated">ここでは、複合型を定義する簡単な例を2つ紹介します。</target>
        </trans-unit>
        <trans-unit id="24ca8b33236bc0d0ef50e2dd43fb66e04162b483" translate="yes" xml:space="preserve">
          <source>Here is a complete example:</source>
          <target state="translated">ここに完全な例があります。</target>
        </trans-unit>
        <trans-unit id="879a2b3e6157baeae30fe41038c69a70091e7ab2" translate="yes" xml:space="preserve">
          <source>Here is a concatenation of two values of unspecified types:</source>
          <target state="translated">ここでは、不特定の型の2つの値を連結しています。</target>
        </trans-unit>
        <trans-unit id="cc7d83360ed38ff4e831e43a35b15e111bd3cccc" translate="yes" xml:space="preserve">
          <source>Here is a more complete example of bloom index definition and usage, as well as a comparison with equivalent btree indexes. The bloom index is considerably smaller than the btree index, and can perform better.</source>
          <target state="translated">ここでは、ブルームインデックスの定義と使用法、および同等のbtreeインデックスとの比較について、より完全な例を示します。bloom インデックスは btree インデックスよりもかなり小さく、より良い性能を発揮します。</target>
        </trans-unit>
        <trans-unit id="5f6e374336fa7e724d2419753cd63165e6b67b04" translate="yes" xml:space="preserve">
          <source>Here is a more complex example: &lt;code&gt;to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')&lt;/code&gt; is 15 hours, 12 minutes, and 2 seconds + 20 milliseconds + 1230 microseconds = 2.021230 seconds.</source>
          <target state="translated">これはより複雑な例です： &lt;code&gt;to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')&lt;/code&gt; is 15 hours、12 minutes、and 2 seconds + 20 milliseconds + 1230 microseconds = 2.021230 seconds 。</target>
        </trans-unit>
        <trans-unit id="4b2dfe5ad07694de5eeb1cdf20070a788ef8e7be" translate="yes" xml:space="preserve">
          <source>Here is a sample of data suitable for copying into a table from &lt;code&gt;STDIN&lt;/code&gt;:</source>
          <target state="translated">以下は、 &lt;code&gt;STDIN&lt;/code&gt; からテーブルにコピーするのに適したデータのサンプルです。</target>
        </trans-unit>
        <trans-unit id="ea724b816190320574ae29c6484ba706b02e562b" translate="yes" xml:space="preserve">
          <source>Here is a simple example:</source>
          <target state="translated">簡単な例を挙げてみます。</target>
        </trans-unit>
        <trans-unit id="79fce6a010075477b9d4f3d2b7d0892550a64ad8" translate="yes" xml:space="preserve">
          <source>Here is a snippet of a log file generated in a single-client run:</source>
          <target state="translated">以下はシングルクライアントの実行で生成されたログファイルのスニペットです。</target>
        </trans-unit>
        <trans-unit id="5a5fc7880a4ea236d1b3bb1d32e27412d9d31338" translate="yes" xml:space="preserve">
          <source>Here is a trivial example, just to show what the output looks like:</source>
          <target state="translated">ここでは、出力がどのように見えるかを示すために、些細な例を示します。</target>
        </trans-unit>
        <trans-unit id="196e7b38bd23094a34f08fd4e1d56d0de9737199" translate="yes" xml:space="preserve">
          <source>Here is an example for a search+bind configuration that uses &lt;code&gt;ldapsearchfilter&lt;/code&gt; instead of &lt;code&gt;ldapsearchattribute&lt;/code&gt; to allow authentication by user ID or email address:</source>
          <target state="translated">ここでの用途があること、検索+バインド設定のための一例である &lt;code&gt;ldapsearchfilter&lt;/code&gt; の代わりに &lt;code&gt;ldapsearchattribute&lt;/code&gt; ユーザーIDまたはメールアドレスによる認証を許可するには：</target>
        </trans-unit>
        <trans-unit id="adb407aa80bcb23407a6343cd3fb06a44aaa7159" translate="yes" xml:space="preserve">
          <source>Here is an example for a search+bind configuration that uses DNS SRV discovery to find the host name(s) and port(s) for the LDAP service for the domain name &lt;code&gt;example.net&lt;/code&gt;:</source>
          <target state="translated">DNS SRVディスカバリーを使用して、ドメイン名 &lt;code&gt;example.net&lt;/code&gt; の LDAPサービスのホスト名とポートを検索するsearch + bind構成の例を次に示します。</target>
        </trans-unit>
        <trans-unit id="8294bedf7f93c4debbc985ac5b71d91485ccb87a" translate="yes" xml:space="preserve">
          <source>Here is an example for a search+bind configuration:</source>
          <target state="translated">ここでは、検索とバインドの設定例を示します。</target>
        </trans-unit>
        <trans-unit id="b1012c91578d9866c1a1a935ccf5f74b1c398069" translate="yes" xml:space="preserve">
          <source>Here is an example for a simple-bind LDAP configuration:</source>
          <target state="translated">ここでは、シンプルバインドLDAPの設定例を示します。</target>
        </trans-unit>
        <trans-unit id="1e2a8eb0839de265c32ba8726c7fb8ce612f9ebc" translate="yes" xml:space="preserve">
          <source>Here is an example of a dictionary definition using the &lt;code&gt;simple&lt;/code&gt; template:</source>
          <target state="translated">以下は、 &lt;code&gt;simple&lt;/code&gt; テンプレートを使用した辞書定義の例です。</target>
        </trans-unit>
        <trans-unit id="d6c310d42c6ff4f581c1e303b9eef10bb403ca6c" translate="yes" xml:space="preserve">
          <source>Here is an example of a function with an ordinality column added:</source>
          <target state="translated">序列列を追加した関数の例を示します。</target>
        </trans-unit>
        <trans-unit id="39d9a1ec97da0de0b2ebe001d89411c194d0136a" translate="yes" xml:space="preserve">
          <source>Here is an example of a query plan for a query using an aggregate function:</source>
          <target state="translated">集計機能を利用した問い合わせプランの例です。</target>
        </trans-unit>
        <trans-unit id="f6d493babc38181bb9e797ebc36b6dee1ed42248" translate="yes" xml:space="preserve">
          <source>Here is an example of collecting functional-dependency statistics:</source>
          <target state="translated">ここでは、機能依存性の統計情報を収集する例を示します。</target>
        </trans-unit>
        <trans-unit id="d635cae1e0a20113dd837d7519806bc17d144c7b" translate="yes" xml:space="preserve">
          <source>Here is an example of creating a foreign table with &lt;code&gt;postgres_fdw&lt;/code&gt;. First install the extension:</source>
          <target state="translated">以下は &lt;code&gt;postgres_fdw&lt;/code&gt; で外部テーブルを作成する例です。最初に拡張機能をインストールします。</target>
        </trans-unit>
        <trans-unit id="a9d65bbbca8355ed90ddee51a853e323cb2c5356" translate="yes" xml:space="preserve">
          <source>Here is an example of how wait events can be viewed</source>
          <target state="translated">ここでは、待ちイベントの表示方法の例を示します。</target>
        </trans-unit>
        <trans-unit id="289e8ce361948510d7bea9298d834548d8a0bcac" translate="yes" xml:space="preserve">
          <source>Here is an example of selecting a sample of a table with &lt;code&gt;SYSTEM_ROWS&lt;/code&gt;. First install the extension:</source>
          <target state="translated">次に、 &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; を使用してテーブルのサンプルを選択する例を示します。最初に拡張機能をインストールします。</target>
        </trans-unit>
        <trans-unit id="a28a21ccc575549b0e4278f1befd6c3171d0c15c" translate="yes" xml:space="preserve">
          <source>Here is an example of selecting a sample of a table with &lt;code&gt;SYSTEM_TIME&lt;/code&gt;. First install the extension:</source>
          <target state="translated">次に、 &lt;code&gt;SYSTEM_TIME&lt;/code&gt; を使用してテーブルのサンプルを選択する例を示します。最初に拡張機能をインストールします。</target>
        </trans-unit>
        <trans-unit id="6c1b25585e57445c9a690160c1f6293b2c2334f6" translate="yes" xml:space="preserve">
          <source>Here is an example of using &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; to display the execution plan for a prepared query:</source>
          <target state="translated">&lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; を使用して準備済みクエリの実行プランを表示する例を次に示します。</target>
        </trans-unit>
        <trans-unit id="3d0353f1bd1f4e5d0cdada03e8194af993f90dd3" translate="yes" xml:space="preserve">
          <source>Here is an example showing how to initialize a fresh database cluster with &lt;code&gt;sepgsql&lt;/code&gt; functions and security labels installed. Adjust the paths shown as appropriate for your installation:</source>
          <target state="translated">次の例は、 &lt;code&gt;sepgsql&lt;/code&gt; 関数とセキュリティラベルをインストールして、新しいデータベースクラスタを初期化する方法を示しています。インストールに応じて、表示されているパスを調整します。</target>
        </trans-unit>
        <trans-unit id="f5681a46af83bb7c4af1228232eef4280217edbe" translate="yes" xml:space="preserve">
          <source>Here is an example showing how to insert the &lt;code&gt;unaccent&lt;/code&gt; dictionary into a text search configuration:</source>
          <target state="translated">以下は、 &lt;code&gt;unaccent&lt;/code&gt; 辞書をテキスト検索構成に挿入する方法を示す例です。</target>
        </trans-unit>
        <trans-unit id="740b499e9d1667a11938c2361c53f8d80be32b73" translate="yes" xml:space="preserve">
          <source>Here is an example showing the effects of &lt;code&gt;LIMIT&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;LIMIT&lt;/code&gt; の効果を示す例を次に示します。</target>
        </trans-unit>
        <trans-unit id="b663de54fe9a475edef4cab194ba9fd34363260e" translate="yes" xml:space="preserve">
          <source>Here is an example that selects only the ten highest-ranked matches:</source>
          <target state="translated">ここでは、上位10試合のみを選択する例を紹介します。</target>
        </trans-unit>
        <trans-unit id="df8103a128aa015d77a6739520d4e9345c77b089" translate="yes" xml:space="preserve">
          <source>Here is an example that shows how to compare each employee's salary with the average salary in his or her department:</source>
          <target state="translated">ここでは、社員一人一人の給与と、所属する部署の平均給与を比較した例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">ここでは一例を紹介します。</target>
        </trans-unit>
        <trans-unit id="b75486070871a14c2ef5c89ea4b7f39dda615103" translate="yes" xml:space="preserve">
          <source>Here is another example of resolving an operator with one known and one unknown input:</source>
          <target state="translated">ここでは、1つの既知の入力と1つの未知の入力を持つ演算子を解決する別の例を示します。</target>
        </trans-unit>
        <trans-unit id="862cabf7adcfd5c087659f8a55b3eecf121ea793" translate="yes" xml:space="preserve">
          <source>Here is another example: it calculates the total sales for each product (rather than the total sales of all products):</source>
          <target state="translated">ここにもう一つの例があります:それは各製品の売上高の合計を計算します(全製品の売上高の合計ではなく)。</target>
        </trans-unit>
        <trans-unit id="a6970b339f07dcc03e141391304c0d8752344244" translate="yes" xml:space="preserve">
          <source>Here is sample status output from pg_ctl:</source>
          <target state="translated">以下はpg_ctlから出力されるステータスのサンプルです。</target>
        </trans-unit>
        <trans-unit id="1352c501bf85911546ec6a7652f925835c799c63" translate="yes" xml:space="preserve">
          <source>Here is some example output:</source>
          <target state="translated">以下に出力例を示します。</target>
        </trans-unit>
        <trans-unit id="e962869eb6c37279a68d52de2ccf4f45b22a61bc" translate="yes" xml:space="preserve">
          <source>Here is the same plan with cost estimates suppressed:</source>
          <target state="translated">ここでは、費用の見積もりを抑えた同じプランをご紹介します。</target>
        </trans-unit>
        <trans-unit id="fabdc0d28afb5f0b655ec42a14587280ddf1ed63" translate="yes" xml:space="preserve">
          <source>Here is the same query, but in YAML format:</source>
          <target state="translated">以下は同じクエリですが、YAML形式です。</target>
        </trans-unit>
        <trans-unit id="760b794b45c32777224d4cbdefb3ac43472e24da" translate="yes" xml:space="preserve">
          <source>Here is the same query, with JSON output formatting:</source>
          <target state="translated">以下は同じクエリで、JSON出力のフォーマットを指定したものです。</target>
        </trans-unit>
        <trans-unit id="a12bd1a7adf1cd80938f005fb42c32962ebef7a7" translate="yes" xml:space="preserve">
          <source>Here is the same search+bind configuration written as a URL:</source>
          <target state="translated">ここでは、同じ検索+バインドの設定をURLとして記述しています。</target>
        </trans-unit>
        <trans-unit id="841d1a406c85c774b7e74eabd4886bcaf8000efc" translate="yes" xml:space="preserve">
          <source>Here it can be seen that column 1 (zip code) fully determines column 5 (city) so the coefficient is 1.0, while city only determines zip code about 42% of the time, meaning that there are many cities (58%) that are represented by more than a single ZIP code.</source>
          <target state="translated">ここでは、1列目(郵便番号)が5列目(都市)を完全に決定しているので、係数は1.0であるのに対し、都市は42%程度しか郵便番号を決定しておらず、1つ以上の郵便番号で表される都市が多い(58%)ことがわかります。</target>
        </trans-unit>
        <trans-unit id="0ae0c10bf978a8e41d20283c701cce10abe5e998" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;$1&lt;/code&gt; references the value of the first function argument whenever the function is invoked.</source>
          <target state="translated">ここで、 &lt;code&gt;$1&lt;/code&gt; は、関数が呼び出されるたびに最初の関数引数の値を参照します。</target>
        </trans-unit>
        <trans-unit id="e24bb102552ef59f6370ebf0e5c3297d839673d3" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;ONLY&lt;/code&gt; before &lt;code&gt;cities&lt;/code&gt; indicates that the query should be run over only the &lt;code&gt;cities&lt;/code&gt; table, and not tables below &lt;code&gt;cities&lt;/code&gt; in the inheritance hierarchy. Many of the commands that we have already discussed &amp;mdash; &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; &amp;mdash; support this &lt;code&gt;ONLY&lt;/code&gt; notation.</source>
          <target state="translated">ここで、 &lt;code&gt;cities&lt;/code&gt; 前 &lt;code&gt;ONLY&lt;/code&gt; は、クエリが &lt;code&gt;cities&lt;/code&gt; テーブルのみで実行され、継承階層の &lt;code&gt;cities&lt;/code&gt; 下のテーブルでは実行されないことを示しています。これまでに説明したコマンドの多く（ &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、および &lt;code&gt;DELETE&lt;/code&gt; )は、この表記 &lt;code&gt;ONLY&lt;/code&gt; サポートしています。</target>
        </trans-unit>
        <trans-unit id="c60ac8b55debcc4cd6f35118bfe06a2acf106ceb" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;ONLY&lt;/code&gt; keyword indicates that the query should apply only to &lt;code&gt;cities&lt;/code&gt;, and not any tables below &lt;code&gt;cities&lt;/code&gt; in the inheritance hierarchy. Many of the commands that we have already discussed &amp;mdash; &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; &amp;mdash; support the &lt;code&gt;ONLY&lt;/code&gt; keyword.</source>
          <target state="translated">ここで &lt;code&gt;ONLY&lt;/code&gt; キーワードは、クエリが &lt;code&gt;cities&lt;/code&gt; のみに適用され、継承階層の &lt;code&gt;cities&lt;/code&gt; 下のテーブルには適用されないことを示します。これまでに説明したコマンドの多く（ &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、および &lt;code&gt;DELETE&lt;/code&gt; )は、 &lt;code&gt;ONLY&lt;/code&gt; キーワードをサポートしています。</target>
        </trans-unit>
        <trans-unit id="180331b7141355384ecd89f79e056920df2b9440" translate="yes" xml:space="preserve">
          <source>Here the first field is a non-NULL empty string, the third is NULL.</source>
          <target state="translated">ここでは、最初のフィールドはNULLではない空の文字列で、3番目のフィールドはNULLです。</target>
        </trans-unit>
        <trans-unit id="5f5c637c8dd6f2e0bc8a363ff5737852d1e4d516" translate="yes" xml:space="preserve">
          <source>Here the planner has decided to use a two-step plan: the child plan node visits an index to find the locations of rows matching the index condition, and then the upper plan node actually fetches those rows from the table itself. Fetching rows separately is much more expensive than reading them sequentially, but because not all the pages of the table have to be visited, this is still cheaper than a sequential scan. (The reason for using two plan levels is that the upper plan node sorts the row locations identified by the index into physical order before reading them, to minimize the cost of separate fetches. The &amp;ldquo;bitmap&amp;rdquo; mentioned in the node names is the mechanism that does the sorting.)</source>
          <target state="translated">ここで、プランナーは2段階のプランを使用することを決定しました。子プランノードはインデックスにアクセスして、インデックス条件に一致する行の場所を見つけ、次に上位プランノードが実際にそれらの行をテーブル自体からフェッチします。行を個別にフェッチすることは、それらを順次に読み取るよりもはるかにコストがかかりますが、テーブルのすべてのページにアクセスする必要がないため、これは順次スキャンよりも安価です。 （2つのプランレベルを使用する理由は、上位のプランノードが、インデックスによって識別される行の場所を読み取る前に物理的な順序にソートして、個別のフェッチのコストを最小限に抑えるためです。ノード名で言及される「ビットマップ」は、ソートを行います。）</target>
        </trans-unit>
        <trans-unit id="09e8656c67ee501e993f2cabda72b9c29cefa0ac" translate="yes" xml:space="preserve">
          <source>Here the query's IP address is covered by the partial index. The following query cannot use the partial index, as it uses an IP address that is excluded from the index:</source>
          <target state="translated">ここでは、クエリのIPアドレスは部分インデックスによってカバーされています。次のクエリは、インデックスから除外されたIPアドレスを使用しているため、部分インデックスを使用することはできません。</target>
        </trans-unit>
        <trans-unit id="2ec31c843165653bc80fe695cd716d3b9ef2fc60" translate="yes" xml:space="preserve">
          <source>Here the sum is taken from the first (lowest) salary up through the current one, including any duplicates of the current one (notice the results for the duplicated salaries).</source>
          <target state="translated">ここでは、現在のものと重複するものも含めて、最初の(最低の)給料から現在のものまでの合計を取っています(重複する給料の結果に注意してください)。</target>
        </trans-unit>
        <trans-unit id="537366727b0a957f32d32f1d223a0385ada41099" translate="yes" xml:space="preserve">
          <source>Here the system has implicitly resolved the unknown-type literal as type &lt;code&gt;float8&lt;/code&gt; before applying the chosen operator. We can verify that &lt;code&gt;float8&lt;/code&gt; and not some other type was used:</source>
          <target state="translated">ここでは、選択された演算子を適用する前に、未知のタイプのリテラルがタイプ &lt;code&gt;float8&lt;/code&gt; として暗黙的に解決されています。他のタイプではなく &lt;code&gt;float8&lt;/code&gt; が使用されたことを確認できます。</target>
        </trans-unit>
        <trans-unit id="cf1e98ca0f0c927b9d08ba4561b2098f2af147e3" translate="yes" xml:space="preserve">
          <source>Here we can see that &lt;code&gt;tenk1&lt;/code&gt; contains 10000 rows, as do its indexes, but the indexes are (unsurprisingly) much smaller than the table.</source>
          <target state="translated">ここで、 &lt;code&gt;tenk1&lt;/code&gt; にはそのインデックスと同様に10000行が含まれていることがわかりますが、インデックスは（当然のことながら）テーブルよりもはるかに小さいです。</target>
        </trans-unit>
        <trans-unit id="d0eab29aaf89686f1fe2e4313a3e207759c193e4" translate="yes" xml:space="preserve">
          <source>Here we can see that the index returned one candidate row, which was then rejected by a recheck of the index condition. This happens because a GiST index is &amp;ldquo;lossy&amp;rdquo; for polygon containment tests: it actually returns the rows with polygons that overlap the target, and then we have to do the exact containment test on those rows.</source>
          <target state="translated">ここで、インデックスが1つの候補行を返し、インデックス条件の再チェックによって拒否されたことがわかります。これは、GiSTインデックスがポリゴンの包含テストで「不可逆」であるために発生します。実際には、ターゲットと重なるポリゴンを含む行が返され、それらの行に対して正確な包含テストを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="4d135a143a8ec460162e891ace4cc0562f7f0ea6" translate="yes" xml:space="preserve">
          <source>Here we give a short overview of the stages a query has to pass in order to obtain a result.</source>
          <target state="translated">ここでは、結果を得るためにクエリが通過しなければならない段階の概要を簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="bcbe633ffbd28597ca13c601e922e114369f31f0" translate="yes" xml:space="preserve">
          <source>Here we have relabeled the weather table as &lt;code&gt;W1&lt;/code&gt; and &lt;code&gt;W2&lt;/code&gt; to be able to distinguish the left and right side of the join. You can also use these kinds of aliases in other queries to save some typing, e.g.:</source>
          <target state="translated">ここでは、結合の左側と右側を区別できるように、天気表のラベルを &lt;code&gt;W1&lt;/code&gt; と &lt;code&gt;W2&lt;/code&gt; に変更しました。他のクエリでこれらの種類のエイリアスを使用して、いくつかの入力を節約することもできます。例：</target>
        </trans-unit>
        <trans-unit id="42307deb2832e0c7af756f3107b84bf8b2ea8057" translate="yes" xml:space="preserve">
          <source>Here we have used &lt;code&gt;setweight&lt;/code&gt; to label the source of each lexeme in the finished &lt;code&gt;tsvector&lt;/code&gt;, and then merged the labeled &lt;code&gt;tsvector&lt;/code&gt; values using the &lt;code&gt;tsvector&lt;/code&gt; concatenation operator &lt;code&gt;||&lt;/code&gt;. (&lt;a href=&quot;textsearch-features#TEXTSEARCH-MANIPULATE-TSVECTOR&quot;&gt;Section 12.4.1&lt;/a&gt; gives details about these operations.)</source>
          <target state="translated">ここでは、 &lt;code&gt;setweight&lt;/code&gt; を使用して、完成した &lt;code&gt;tsvector&lt;/code&gt; の各語彙素のソースにラベルを付け、次に &lt;code&gt;tsvector&lt;/code&gt; 連結演算子 &lt;code&gt;||&lt;/code&gt; を使用して、ラベル付けされた &lt;code&gt;tsvector&lt;/code&gt; 値をマージしました。。（&lt;a href=&quot;textsearch-features#TEXTSEARCH-MANIPULATE-TSVECTOR&quot;&gt;12.4.1項に&lt;/a&gt;、これらの操作の詳細を示します。）</target>
        </trans-unit>
        <trans-unit id="ebe0ff0a0f834e90a6235b06460f658da331e569" translate="yes" xml:space="preserve">
          <source>Here's a simple example of usage:</source>
          <target state="translated">簡単な使用例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="a00d1ad8972f6aee9ca962b7dd2f9cc873a842a4" translate="yes" xml:space="preserve">
          <source>Here's an annotated example of &lt;code&gt;lquery&lt;/code&gt;:</source>
          <target state="translated">次に、 &lt;code&gt;lquery&lt;/code&gt; の注釈付きの例を示します。</target>
        </trans-unit>
        <trans-unit id="d49be83bb6ef95a34484a28f1063c126af2cd0f3" translate="yes" xml:space="preserve">
          <source>Here's an example &lt;code&gt;ltxtquery&lt;/code&gt;:</source>
          <target state="translated">次に &lt;code&gt;ltxtquery&lt;/code&gt; の例を示します。</target>
        </trans-unit>
        <trans-unit id="48493c355bde53a50b460fe64d3981e1bf2c28dd" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;DictFile&lt;/code&gt;, &lt;code&gt;AffFile&lt;/code&gt;, and &lt;code&gt;StopWords&lt;/code&gt; specify the base names of the dictionary, affixes, and stop-words files. The stop-words file has the same format explained above for the &lt;code&gt;simple&lt;/code&gt; dictionary type. The format of the other files is not specified here but is available from the above-mentioned web sites.</source>
          <target state="translated">ここで、 &lt;code&gt;DictFile&lt;/code&gt; 、 &lt;code&gt;AffFile&lt;/code&gt; 、および &lt;code&gt;StopWords&lt;/code&gt; は、辞書、接辞、およびストップワードファイルのベース名を指定します。ストップワードファイルは、 &lt;code&gt;simple&lt;/code&gt; 辞書タイプについて上記で説明したものと同じ形式です。他のファイルのフォーマットはここでは指定されていませんが、上記のWebサイトから入手できます。</target>
        </trans-unit>
        <trans-unit id="a15f0741ab9f0607b3961ed00005a1407be190df" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;db_column:update&lt;/code&gt; will be checked for &lt;code&gt;t1.x&lt;/code&gt;, since it is being updated, &lt;code&gt;db_column:{select update}&lt;/code&gt; will be checked for &lt;code&gt;t1.y&lt;/code&gt;, since it is both updated and referenced, and &lt;code&gt;db_column:select&lt;/code&gt; will be checked for &lt;code&gt;t1.z&lt;/code&gt;, since it is only referenced. &lt;code&gt;db_table:{select update}&lt;/code&gt; will also be checked at the table level.</source>
          <target state="translated">ここで、 &lt;code&gt;db_column:update&lt;/code&gt; は &lt;code&gt;t1.x&lt;/code&gt; についてチェックされます。更新されているため、 &lt;code&gt;db_column:{select update}&lt;/code&gt; は &lt;code&gt;t1.y&lt;/code&gt; についてチェックされます。これは、更新と参照の両方が行われるためです &lt;code&gt;db_column:select&lt;/code&gt; は &lt;code&gt;t1.z&lt;/code&gt; についてチェックされます。.zは参照されるだけなので。 &lt;code&gt;db_table:{select update}&lt;/code&gt; もテーブルレベルでチェックされます。</target>
        </trans-unit>
        <trans-unit id="94323f34e2769fd6d8140ecf86916e1a4ffa6df9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;english&lt;/code&gt; is the base name of a file of stop words. The file's full name will be &lt;code&gt;$SHAREDIR/tsearch_data/english.stop&lt;/code&gt;, where &lt;code&gt;$SHAREDIR&lt;/code&gt; means the PostgreSQL installation's shared-data directory, often &lt;code&gt;/usr/local/share/postgresql&lt;/code&gt; (use &lt;code&gt;pg_config --sharedir&lt;/code&gt; to determine it if you're not sure). The file format is simply a list of words, one per line. Blank lines and trailing spaces are ignored, and upper case is folded to lower case, but no other processing is done on the file contents.</source>
          <target state="translated">ここで、 &lt;code&gt;english&lt;/code&gt; はストップワードのファイルのベース名です。ファイルのフルネームは &lt;code&gt;$SHAREDIR/tsearch_data/english.stop&lt;/code&gt; です。 &lt;code&gt;$SHAREDIR&lt;/code&gt; は、PostgreSQLインストールの共有データディレクトリを意味します。多くの場合、 &lt;code&gt;/usr/local/share/postgresql&lt;/code&gt; です（ &lt;code&gt;pg_config --sharedir&lt;/code&gt; を使用して、承知しました）。ファイル形式は、1行に1つの単語のリストです。空白行と末尾のスペースは無視され、大文字は小文字に変換されますが、ファイルの内容に対して他の処理は行われません。</target>
        </trans-unit>
        <trans-unit id="1c3b85c63ac80bdd86554daac13d878a06c56b22" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;expression&lt;/code&gt; represents any value expression that does not itself contain window function calls.</source>
          <target state="translated">ここで、 &lt;code&gt;expression&lt;/code&gt; は、それ自体がウィンドウ関数呼び出しを含まない任意の値式を表します。</target>
        </trans-unit>
        <trans-unit id="b22882051bae4c80aed43f53d018119709936657" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;key&lt;/code&gt; is an element in the index and &lt;code&gt;query&lt;/code&gt; the value being looked up in the index. The &lt;code&gt;StrategyNumber&lt;/code&gt; parameter indicates which operator of your operator class is being applied &amp;mdash; it matches one of the operator numbers in the &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; command.</source>
          <target state="translated">ここで、 &lt;code&gt;key&lt;/code&gt; はインデックスの要素であり、インデックスで &lt;code&gt;query&lt;/code&gt; いる値をクエリします。 &lt;code&gt;StrategyNumber&lt;/code&gt; のパラメータが適用されているあなたの演算子クラスのどのオペレータを示している-それはでオペレータ番号のいずれかに一致する &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; のコマンド。</target>
        </trans-unit>
        <trans-unit id="f689631caa32c4a22198886b0f15d59af75c4c1d" translate="yes" xml:space="preserve">
          <source>Here, all the input punctuation was discarded as being space symbols.</source>
          <target state="translated">ここでは、入力された句読点はすべてスペース記号として破棄されました。</target>
        </trans-unit>
        <trans-unit id="c2bea9418baff2dab8ad2f535eead313521a74b5" translate="yes" xml:space="preserve">
          <source>Here, condition has a format similar to the format of regular expressions. It can use groupings &lt;code&gt;[...]&lt;/code&gt; and &lt;code&gt;[^...]&lt;/code&gt;. For example, &lt;code&gt;[AEIOU]Y&lt;/code&gt; means that the last letter of the word is &lt;code&gt;&quot;y&quot;&lt;/code&gt; and the penultimate letter is &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;e&quot;&lt;/code&gt;, &lt;code&gt;&quot;i&quot;&lt;/code&gt;, &lt;code&gt;&quot;o&quot;&lt;/code&gt; or &lt;code&gt;&quot;u&quot;&lt;/code&gt;. &lt;code&gt;[^EY]&lt;/code&gt; means that the last letter is neither &lt;code&gt;&quot;e&quot;&lt;/code&gt; nor &lt;code&gt;&quot;y&quot;&lt;/code&gt;.</source>
          <target state="translated">ここで、条件の形式は正規表現の形式に似ています。グループ化 &lt;code&gt;[...]&lt;/code&gt; および &lt;code&gt;[^...]&lt;/code&gt; を使用できます。たとえば、 &lt;code&gt;[AEIOU]Y&lt;/code&gt; は、単語の最後の文字が &lt;code&gt;&quot;y&quot;&lt;/code&gt; で、最後から2番目の文字が &lt;code&gt;&quot;a&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;e&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;i&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;o&quot;&lt;/code&gt; または &lt;code&gt;&quot;u&quot;&lt;/code&gt; 意味します。 &lt;code&gt;[^EY]&lt;/code&gt; は、最後の文字が &lt;code&gt;&quot;e&quot;&lt;/code&gt; でも &lt;code&gt;&quot;y&quot;&lt;/code&gt; でもないことを意味します。</target>
        </trans-unit>
        <trans-unit id="00e7b43ee7c6b641274238949f463079d5bbf579" translate="yes" xml:space="preserve">
          <source>Here, materialization of the &lt;code&gt;WITH&lt;/code&gt; query ensures that &lt;code&gt;very_expensive_function&lt;/code&gt; is evaluated only once per table row, not twice.</source>
          <target state="translated">ここでは、 &lt;code&gt;WITH&lt;/code&gt; クエリの具体化により、 &lt;code&gt;very_expensive_function&lt;/code&gt; がテーブル行ごとに1回だけ評価され、2回評価されることはありません。</target>
        </trans-unit>
        <trans-unit id="eadb56d6708463f3d868c5af1a2244c7c4a3fed2" translate="yes" xml:space="preserve">
          <source>Here, since type &lt;code&gt;real&lt;/code&gt; cannot be implicitly cast to &lt;code&gt;integer&lt;/code&gt;, but &lt;code&gt;integer&lt;/code&gt; can be implicitly cast to &lt;code&gt;real&lt;/code&gt;, the union result type is resolved as &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">ここでは、タイプ &lt;code&gt;real&lt;/code&gt; は暗黙的に &lt;code&gt;integer&lt;/code&gt; にキャストできませんが、 &lt;code&gt;integer&lt;/code&gt; は暗黙的に &lt;code&gt;real&lt;/code&gt; にキャストできるため、共用体の結果タイプは &lt;code&gt;real&lt;/code&gt; として解決されます。</target>
        </trans-unit>
        <trans-unit id="cfec33c2243bfacb00b180b26c912c2de7a8aad2" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;uppercase&lt;/code&gt; parameter is omitted, so it receives its default value of &lt;code&gt;false&lt;/code&gt;, resulting in lower case output. In positional notation, arguments can be omitted from right to left so long as they have defaults.</source>
          <target state="translated">ここでは、 &lt;code&gt;uppercase&lt;/code&gt; パラメーターは省略されているため、デフォルト値の &lt;code&gt;false&lt;/code&gt; を受け取り、小文字で出力されます。位置表記では、デフォルトがある限り、引数は右から左に省略できます。</target>
        </trans-unit>
        <trans-unit id="c823dd873535ad7ccdb6e068431505db91bdcea6" translate="yes" xml:space="preserve">
          <source>Here, the planner has chosen to use a hash join, in which rows of one table are entered into an in-memory hash table, after which the other table is scanned and the hash table is probed for matches to each row. Again note how the indentation reflects the plan structure: the bitmap scan on &lt;code&gt;tenk1&lt;/code&gt; is the input to the Hash node, which constructs the hash table. That's then returned to the Hash Join node, which reads rows from its outer child plan and searches the hash table for each one.</source>
          <target state="translated">ここでは、プランナはハッシュ結合を使用することを選択しました。この場合、1つのテーブルの行がメモリ内のハッシュテーブルに入力され、その後、他のテーブルがスキャンされ、ハッシュテーブルで各行との一致が調べられます。ここでも、インデントがプランの構造を反映していることに注意してください &lt;code&gt;tenk1&lt;/code&gt; のビットマップスキャンは、ハッシュテーブルへの入力であるHashノードへの入力です。次に、ハッシュ結合ノードに返されます。このノードは、外部の子プランから行を読み取り、ハッシュテーブルから各行を検索します。</target>
        </trans-unit>
        <trans-unit id="5850a821f06c0b2f442ebe11558a575852c8aeb5" translate="yes" xml:space="preserve">
          <source>Here, the sequence &lt;code&gt;$q$[\t\r\n\v\\]$q$&lt;/code&gt; represents a dollar-quoted literal string &lt;code&gt;[\t\r\n\v\\]&lt;/code&gt;, which will be recognized when the function body is executed by PostgreSQL. But since the sequence does not match the outer dollar quoting delimiter &lt;code&gt;$function$&lt;/code&gt;, it is just some more characters within the constant so far as the outer string is concerned.</source>
          <target state="translated">ここで、シーケンス &lt;code&gt;$q$[\t\r\n\v\\]$q$&lt;/code&gt; は、ドルで引用されたリテラル文字列 &lt;code&gt;[\t\r\n\v\\]&lt;/code&gt; を表します。これは、関数本体がPostgreSQLによって実行されます。ただし、シーケンスは外側のドル引用符区切り文字 &lt;code&gt;$function$&lt;/code&gt; と一致しないため、外側の文字列に関する限り、定数内の文字が少しだけ増えます。</target>
        </trans-unit>
        <trans-unit id="e42cf0e074b0fa8e95e14f4ebb3e1b606554ddda" translate="yes" xml:space="preserve">
          <source>Here, the unknown-type literal &lt;code&gt;'b'&lt;/code&gt; will be resolved to type &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">ここでは、不明なタイプのリテラル &lt;code&gt;'b'&lt;/code&gt; はタイプ &lt;code&gt;text&lt;/code&gt; に解決されます。</target>
        </trans-unit>
        <trans-unit id="a1e31a79ba26a76d28a87c7ed0407b897f88b5e6" translate="yes" xml:space="preserve">
          <source>Here:</source>
          <target state="translated">Here:</target>
        </trans-unit>
        <trans-unit id="6789cbae03419b1c1cfba25dda2b2a3e23e7e4c6" translate="yes" xml:space="preserve">
          <source>Hex Representation</source>
          <target state="translated">16進数表現</target>
        </trans-unit>
        <trans-unit id="120e75d0d27169271eff5b30f1995d939cf69223" translate="yes" xml:space="preserve">
          <source>Hexadecimal digits are &lt;code&gt;0&lt;/code&gt;-&lt;code&gt;9&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;-&lt;code&gt;f&lt;/code&gt;, and &lt;code&gt;A&lt;/code&gt;-&lt;code&gt;F&lt;/code&gt;. Octal digits are &lt;code&gt;0&lt;/code&gt;-&lt;code&gt;7&lt;/code&gt;.</source>
          <target state="translated">16進数は、 &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;9&lt;/code&gt; 、- &lt;code&gt;f&lt;/code&gt; 、および &lt;code&gt;A&lt;/code&gt; - &lt;code&gt;F&lt;/code&gt; 。8進数は、 &lt;code&gt;0&lt;/code&gt; を - &lt;code&gt;7&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffcadc3bbf92f4882971ddc3bc8286e63dfa62c0" translate="yes" xml:space="preserve">
          <source>High Availability</source>
          <target state="translated">高可用性</target>
        </trans-unit>
        <trans-unit id="946223b4ede05fe838dc846e6faf0a89f88f0e1d" translate="yes" xml:space="preserve">
          <source>High Value</source>
          <target state="translated">高価値</target>
        </trans-unit>
        <trans-unit id="c23ab61c10027c96a9184ffc34b5fb7aecf016a1" translate="yes" xml:space="preserve">
          <source>Historically this module depended on the OSSP UUID library, which accounts for the module's name. While the OSSP UUID library can still be found at &lt;a href=&quot;http://www.ossp.org/pkg/lib/uuid/&quot;&gt;http://www.ossp.org/pkg/lib/uuid/&lt;/a&gt;, it is not well maintained, and is becoming increasingly difficult to port to newer platforms. &lt;code&gt;uuid-ossp&lt;/code&gt; can now be built without the OSSP library on some platforms. On FreeBSD, NetBSD, and some other BSD-derived platforms, suitable UUID creation functions are included in the core &lt;code&gt;libc&lt;/code&gt; library. On Linux, macOS, and some other platforms, suitable functions are provided in the &lt;code&gt;libuuid&lt;/code&gt; library, which originally came from the &lt;code&gt;e2fsprogs&lt;/code&gt; project (though on modern Linux it is considered part of &lt;code&gt;util-linux-ng&lt;/code&gt;). When invoking &lt;code&gt;configure&lt;/code&gt;, specify &lt;code&gt;--with-uuid=bsd&lt;/code&gt; to use the BSD functions, or &lt;code&gt;--with-uuid=e2fs&lt;/code&gt; to use &lt;code&gt;e2fsprogs&lt;/code&gt;' &lt;code&gt;libuuid&lt;/code&gt;, or &lt;code&gt;--with-uuid=ossp&lt;/code&gt; to use the OSSP UUID library. More than one of these libraries might be available on a particular machine, so &lt;code&gt;configure&lt;/code&gt; does not automatically choose one.</source>
          <target state="translated">歴史的にこのモジュールは、モジュールの名前を説明するOSSP UUIDライブラリに依存していました。 OSSP UUIDライブラリはまだ&lt;a href=&quot;http://www.ossp.org/pkg/lib/uuid/&quot;&gt;http://www.ossp.org/pkg/lib/uuid/にありますが&lt;/a&gt;、十分にメンテナンスされておらず、新しいプラットフォームへの移植がますます難しくなっています。一部のプラットフォームでは、 &lt;code&gt;uuid-ossp&lt;/code&gt; をOSSPライブラリなしでビルドできるようになりました。 FreeBSD、NetBSD、およびその他のBSD派生のプラットフォームでは、適切なUUID作成関数がコア &lt;code&gt;libc&lt;/code&gt; ライブラリに含まれています。 Linux、macOS、およびその他の一部のプラットフォームでは、適切な関数が &lt;code&gt;libuuid&lt;/code&gt; ライブラリで提供されます。これは、もともと &lt;code&gt;e2fsprogs&lt;/code&gt; プロジェクトからのものです（ただし、最近のLinuxでは &lt;code&gt;util-linux-ng&lt;/code&gt; の一部と見なされています））。呼び出すとき &lt;code&gt;configure&lt;/code&gt; 、指定 &lt;code&gt;--with-uuid=bsd&lt;/code&gt; 、BSD関数を使用するか、 &lt;code&gt;--with-uuid=e2fs&lt;/code&gt; 使用する &lt;code&gt;e2fsprogs&lt;/code&gt; の「 &lt;code&gt;libuuid&lt;/code&gt; 、または &lt;code&gt;--with-uuid=ossp&lt;/code&gt; OSSP UUIDライブラリを使用します。特定のマシンでこれらのライブラリが複数利用できる可能性があるため、 &lt;code&gt;configure&lt;/code&gt; が自動的に選択することはありません。</target>
        </trans-unit>
        <trans-unit id="b5584bf16896f3c913b27677d773698adc908eae" translate="yes" xml:space="preserve">
          <source>History of Units</source>
          <target state="translated">ユニットの歴史</target>
        </trans-unit>
        <trans-unit id="70f8bb9a8a5393ef080507a89e4b98d139000d65" translate="yes" xml:space="preserve">
          <source>Home</source>
          <target state="translated">Home</target>
        </trans-unit>
        <trans-unit id="3960ec4ca5fb5e5d8cdb2cc1c5121c003e426517" translate="yes" xml:space="preserve">
          <source>Host</source>
          <target state="translated">Host</target>
        </trans-unit>
        <trans-unit id="7e3d4d69eb95f3292122a5fea9416ed4cba36be3" translate="yes" xml:space="preserve">
          <source>Host name of the connected client, as reported by a reverse DNS lookup of &lt;code&gt;client_addr&lt;/code&gt;. This field will only be non-null for IP connections, and only when &lt;a href=&quot;runtime-config-logging#GUC-LOG-HOSTNAME&quot;&gt;log_hostname&lt;/a&gt; is enabled.</source>
          <target state="translated">接続されたクライアントのホスト名 &lt;code&gt;client_addr&lt;/code&gt; DNS逆引き参照で報告されます。このフィールドは、IP接続の場合、および&lt;a href=&quot;runtime-config-logging#GUC-LOG-HOSTNAME&quot;&gt;log_hostname&lt;/a&gt;が有効になっている場合にのみnull以外になります。</target>
        </trans-unit>
        <trans-unit id="67b082e00139eb65670882e9969e878f533f20b1" translate="yes" xml:space="preserve">
          <source>Host name or IP address, or one of &lt;code&gt;all&lt;/code&gt;, &lt;code&gt;samehost&lt;/code&gt;, or &lt;code&gt;samenet&lt;/code&gt;, or null for local connections</source>
          <target state="translated">ホスト名またはIPアドレス、または &lt;code&gt;all&lt;/code&gt; 、 &lt;code&gt;samehost&lt;/code&gt; 、または &lt;code&gt;samenet&lt;/code&gt; のいずれか、またはローカル接続の場合はnull</target>
        </trans-unit>
        <trans-unit id="3acb05d9b4db45ddd95be7a72351a5560907bba2" translate="yes" xml:space="preserve">
          <source>Host of the PostgreSQL instance this WAL receiver is connected to. This can be a host name, an IP address, or a directory path if the connection is via Unix socket. (The path case can be distinguished because it will always be an absolute path, beginning with &lt;code&gt;/&lt;/code&gt;.)</source>
          <target state="translated">このWALレシーバーが接続されているPostgreSQLインスタンスのホスト。これは、ホスト名、IPアドレス、または接続がUnixソケット経由の場合はディレクトリパスにすることができます。（パスの大文字小文字は、常に &lt;code&gt;/&lt;/code&gt; で始まる絶対パスであるため区別できます。）</target>
        </trans-unit>
        <trans-unit id="e716495d010a3dcebf55c7c74d98bdb385a76508" translate="yes" xml:space="preserve">
          <source>Host-Based Authentication</source>
          <target state="translated">ホストベース認証</target>
        </trans-unit>
        <trans-unit id="cc53b246d6c96fb218922a66ec6b6ca310bf3021" translate="yes" xml:space="preserve">
          <source>Hot Standby</source>
          <target state="translated">ホットスタンバイ</target>
        </trans-unit>
        <trans-unit id="d972243453928257bff4b6354fce98c1493ba542" translate="yes" xml:space="preserve">
          <source>Hot Standby feedback propagates upstream, whatever the cascaded arrangement.</source>
          <target state="translated">ホットスタンバイフィードバックは、カスケード配置がどのようなものであっても上流に伝搬します。</target>
        </trans-unit>
        <trans-unit id="5091beeb3be00f483925a2bb31c058bfcaaaeb31" translate="yes" xml:space="preserve">
          <source>Hot Standby is the term used to describe the ability to connect to the server and run read-only queries while the server is in archive recovery or standby mode. This is useful both for replication purposes and for restoring a backup to a desired state with great precision. The term Hot Standby also refers to the ability of the server to move from recovery through to normal operation while users continue running queries and/or keep their connections open.</source>
          <target state="translated">ホットスタンバイとは、サーバーがアーカイブリカバリーまたはスタンバイモードにある間に、サーバーに接続して読み取り専用のクエリを実行する機能を説明するために使用される用語です。これは、レプリケーションの目的でも、バックアップを希望の状態に高精度で復元する場合にも有用です。ホットスタンバイという用語は、ユーザーがクエリを実行し続けたり、接続を開いたままにしている間に、サーバーがリカバリから通常の操作に移行する能力を意味します。</target>
        </trans-unit>
        <trans-unit id="9e25a34e635a123f8958bbe26e7c4843278597fb" translate="yes" xml:space="preserve">
          <source>Hours</source>
          <target state="translated">Hours</target>
        </trans-unit>
        <trans-unit id="b8d371fd69de846ce0d56ec576287b8268a9b53e" translate="yes" xml:space="preserve">
          <source>How Connections Are Established</source>
          <target state="translated">コネクションの確立方法</target>
        </trans-unit>
        <trans-unit id="8cecc82d72d68f9151cb0901cfe40eeac15bfca6" translate="yes" xml:space="preserve">
          <source>How It Works</source>
          <target state="translated">どのように機能するか</target>
        </trans-unit>
        <trans-unit id="a41409a5166c5d74bdffdf63899f116578d1e299" translate="yes" xml:space="preserve">
          <source>How Parallel Query Works</source>
          <target state="translated">パラレルクエリの仕組み</target>
        </trans-unit>
        <trans-unit id="7604442ec6b924ac1f168d8f81e9b0b61679f4f6" translate="yes" xml:space="preserve">
          <source>How many concurrent connections can be made to this database. -1 (the default) means no limit.</source>
          <target state="translated">このデータベースへの同時接続数を指定します。-1 (デフォルト)は制限なしを意味します。</target>
        </trans-unit>
        <trans-unit id="d98f671ec6200c3b445e94f09f19857316dd290b" translate="yes" xml:space="preserve">
          <source>How many concurrent connections can be made to this database. -1 means no limit.</source>
          <target state="translated">このデータベースへの同時接続数を指定します。-1 は制限なしを意味します。</target>
        </trans-unit>
        <trans-unit id="e914be45633e81e1b35dd5a5a8544fdfa64c8d17" translate="yes" xml:space="preserve">
          <source>How much to compress. Higher levels compress smaller but are slower. 0 disables compression.</source>
          <target state="translated">どのくらい圧縮するか。レベルが高いほど圧縮量は小さくなりますが、速度は遅くなります。0は圧縮を無効にします。</target>
        </trans-unit>
        <trans-unit id="ef6f180b70cdcd17c60a982706ebbdc6fbb46234" translate="yes" xml:space="preserve">
          <source>How the planner determines the cardinality of &lt;code&gt;tenk1&lt;/code&gt; is covered in &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;, but is repeated here for completeness. The number of pages and rows is looked up in &lt;code&gt;pg_class&lt;/code&gt;:</source>
          <target state="translated">プランナが &lt;code&gt;tenk1&lt;/code&gt; のカーディナリティを決定する方法については、&lt;a href=&quot;planner-stats&quot;&gt;セクション14.2&lt;/a&gt;で説明していますが、完全を期すためにここで繰り返します。ページと行の数は &lt;code&gt;pg_class&lt;/code&gt; で検索されます。</target>
        </trans-unit>
        <trans-unit id="94ecf8c7f95f01155b7f0495cbc646415e78c1ae" translate="yes" xml:space="preserve">
          <source>How to choose a good password.</source>
          <target state="translated">良いパスワードの選び方。</target>
        </trans-unit>
        <trans-unit id="2ba82223beeb024535e1c4a0ddfd885368b08372" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;jsonb&lt;/code&gt; will preserve trailing fractional zeroes, as seen in this example, even though those are semantically insignificant for purposes such as equality checks.</source>
          <target state="translated">ただし、 &lt;code&gt;jsonb&lt;/code&gt; は、等価チェックなどの目的では意味的に重要ではない場合でも、この例に示すように、後続の小数部のゼロを保持します。</target>
        </trans-unit>
        <trans-unit id="483f78f78539b97c5a6d0e5895b7ea66709bc65e" translate="yes" xml:space="preserve">
          <source>However, a &lt;code&gt;TABLE&lt;/code&gt; function is different from the preceding examples, because it actually returns a &lt;em&gt;set&lt;/em&gt; of records, not just one record.</source>
          <target state="translated">ただし、 &lt;code&gt;TABLE&lt;/code&gt; 関数は、実際には1つのレコードだけでなく、&lt;em&gt;一連&lt;/em&gt;のレコードを返すため、前述の例とは異なります。</target>
        </trans-unit>
        <trans-unit id="5593eb449291b54fa57b6d536402c4a2c8454af7" translate="yes" xml:space="preserve">
          <source>However, a &lt;code&gt;WITH&lt;/code&gt; query can be marked &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; to remove this guarantee. In that case, the &lt;code&gt;WITH&lt;/code&gt; query can be folded into the primary query much as though it were a simple sub-&lt;code&gt;SELECT&lt;/code&gt; in the primary query's &lt;code&gt;FROM&lt;/code&gt; clause. This results in duplicate computations if the primary query refers to that &lt;code&gt;WITH&lt;/code&gt; query more than once; but if each such use requires only a few rows of the &lt;code&gt;WITH&lt;/code&gt; query's total output, &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; can provide a net savings by allowing the queries to be optimized jointly. &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; is ignored if it is attached to a &lt;code&gt;WITH&lt;/code&gt; query that is recursive or is not side-effect-free (i.e., is not a plain &lt;code&gt;SELECT&lt;/code&gt; containing no volatile functions).</source>
          <target state="translated">ただし、 &lt;code&gt;WITH&lt;/code&gt; クエリに &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; のマークを付けて、この保証を削除することができます。その場合、 &lt;code&gt;WITH&lt;/code&gt; クエリは、プライマリクエリの &lt;code&gt;FROM&lt;/code&gt; 句の単純なサブ &lt;code&gt;SELECT&lt;/code&gt; であるかのように、プライマリクエリに組み込むことができます。これにより、プライマリクエリがその &lt;code&gt;WITH&lt;/code&gt; クエリを複数回参照すると、計算が重複します。しかし、そのような使用ごとに &lt;code&gt;WITH&lt;/code&gt; クエリの合計出力の数行のみが必要な場合、 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; はクエリを一緒に最適化できるようにすることで、実質的に節約できます。 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; が &lt;code&gt;WITH&lt;/code&gt; にアタッチされている場合は無視されます再帰的または副作用のない（つまり、揮発性関数を含まない単純な &lt;code&gt;SELECT&lt;/code&gt; ではない）クエリ。</target>
        </trans-unit>
        <trans-unit id="b767ca4c454cedd41bdf2ff2cdb11395909dd8d9" translate="yes" xml:space="preserve">
          <source>However, buffering index build needs to call the &lt;code&gt;penalty&lt;/code&gt; function more often, which consumes some extra CPU resources. Also, the buffers used in the buffering build need temporary disk space, up to the size of the resulting index. Buffering can also influence the quality of the resulting index, in both positive and negative directions. That influence depends on various factors, like the distribution of the input data and the operator class implementation.</source>
          <target state="translated">ただし、バッファリングインデックスのビルドでは、 &lt;code&gt;penalty&lt;/code&gt; 関数をより頻繁に呼び出す必要があるため、余分なCPUリソースが消費されます。また、バッファリングビルドで使用されるバッファーには、結果のインデックスのサイズまでの一時的なディスク領域が必要です。バッファリングは、正と負の両方の方向で、結果のインデックスの品質にも影響を与える可能性があります。その影響は、入力データの分布や演算子クラスの実装など、さまざまな要因によって異なります。</target>
        </trans-unit>
        <trans-unit id="9ace55465d56f996227de2d5f96f6d4ae754cfc4" translate="yes" xml:space="preserve">
          <source>However, every year divisible by 100 is not a leap year.</source>
          <target state="translated">しかし、100で割った毎年の年はうるう年ではありません。</target>
        </trans-unit>
        <trans-unit id="792feefacc6fed97444972da0544bbf7d0187b3d" translate="yes" xml:space="preserve">
          <source>However, every year divisible by 400 is a leap year after all.</source>
          <target state="translated">しかし、400で割った年は、結局は閏年なんですよね。</target>
        </trans-unit>
        <trans-unit id="7f65ac3c6b4eb7f83cd55133554a3e43236a59b1" translate="yes" xml:space="preserve">
          <source>However, filtered forms in Microsoft Access generate queries that appear to use &lt;code&gt;expr = NULL&lt;/code&gt; to test for null values, so if you use that interface to access the database you might want to turn this option on. Since expressions of the form &lt;code&gt;expr = NULL&lt;/code&gt; always return the null value (using the SQL standard interpretation), they are not very useful and do not appear often in normal applications so this option does little harm in practice. But new users are frequently confused about the semantics of expressions involving null values, so this option is off by default.</source>
          <target state="translated">ただし、Microsoft Accessのフィルターされたフォームは、 &lt;code&gt;expr = NULL&lt;/code&gt; を使用してnull値をテストするように見えるクエリを生成するため、そのインターフェイスを使用してデータベースにアクセスする場合は、このオプションをオンにすることができます。 &lt;code&gt;expr = NULL&lt;/code&gt; の形式の式は常に（SQL標準解釈を使用して）null値を返すため、あまり役に立ちませんし、通常のアプリケーションではあまり表示されないため、このオプションは実際にはほとんど害を及ぼしません。ただし、新しいユーザーはnull値を含む式のセマンティクスについて混乱することが多いため、このオプションはデフォルトでオフになっています。</target>
        </trans-unit>
        <trans-unit id="27fc16525c2f3eccc5221bef3e492bce51567b8a" translate="yes" xml:space="preserve">
          <source>However, if a &lt;code&gt;WITH&lt;/code&gt; query is non-recursive and side-effect-free (that is, it is a &lt;code&gt;SELECT&lt;/code&gt; containing no volatile functions) then it can be folded into the parent query, allowing joint optimization of the two query levels. By default, this happens if the parent query references the &lt;code&gt;WITH&lt;/code&gt; query just once, but not if it references the &lt;code&gt;WITH&lt;/code&gt; query more than once. You can override that decision by specifying &lt;code&gt;MATERIALIZED&lt;/code&gt; to force separate calculation of the &lt;code&gt;WITH&lt;/code&gt; query, or by specifying &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; to force it to be merged into the parent query. The latter choice risks duplicate computation of the &lt;code&gt;WITH&lt;/code&gt; query, but it can still give a net savings if each usage of the &lt;code&gt;WITH&lt;/code&gt; query needs only a small part of the &lt;code&gt;WITH&lt;/code&gt; query's full output.</source>
          <target state="translated">ただし、 &lt;code&gt;WITH&lt;/code&gt; クエリが再帰的ではなく、副作用がない場合（つまり、揮発性関数を含まない &lt;code&gt;SELECT&lt;/code&gt; の場合）、親クエリに折りたたむことができるため、2つのクエリレベルを同時に最適化できます。デフォルトでは、これは親クエリが &lt;code&gt;WITH&lt;/code&gt; クエリを1回だけ参照する場合に発生しますが、 &lt;code&gt;WITH&lt;/code&gt; クエリを複数回参照する場合には発生しません。 &lt;code&gt;MATERIALIZED&lt;/code&gt; を指定して強制的に &lt;code&gt;WITH&lt;/code&gt; クエリを個別に計算するか、 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; を指定して強制的に親クエリにマージすることで、その決定を上書きできます。後者の選択は、 &lt;code&gt;WITH&lt;/code&gt; の重複計算のリスクがありますクエリを使用しますが、 &lt;code&gt;WITH&lt;/code&gt; クエリの使用ごとに、 &lt;code&gt;WITH&lt;/code&gt; クエリの完全な出力のごく一部しか必要としない場合でも、実質的に節約できます。</target>
        </trans-unit>
        <trans-unit id="057cccafbf2013b3d5aa591e41a10dbea6d97107" translate="yes" xml:space="preserve">
          <source>However, if the default value is volatile (e.g. &lt;code&gt;clock_timestamp()&lt;/code&gt;) each row will need to be updated with the value calculated at the time &lt;code&gt;ALTER TABLE&lt;/code&gt; is executed. To avoid a potentially lengthy update operation, particularly if you intend to fill the column with mostly nondefault values anyway, it may be preferable to add the column with no default, insert the correct values using &lt;code&gt;UPDATE&lt;/code&gt;, and then add any desired default as described below.</source>
          <target state="translated">ただし、デフォルト値が揮発性である場合（たとえば、 &lt;code&gt;clock_timestamp()&lt;/code&gt; ）、 &lt;code&gt;ALTER TABLE&lt;/code&gt; の実行時に計算された値で各行を更新する必要があります。特に更新操作が長くなる可能性があるのを避けるために、特に列をほとんどデフォルト以外の値で埋めようとする場合は、デフォルトなしで列を追加し、 &lt;code&gt;UPDATE&lt;/code&gt; を使用して正しい値を挿入してから、以下の説明に従って必要なデフォルトを追加することをお勧めします。 。</target>
        </trans-unit>
        <trans-unit id="fbbfd51a31cdab8f282fc85ab92999c7b1df44cb" translate="yes" xml:space="preserve">
          <source>However, it is not necessary to remove role memberships involving the role; &lt;code&gt;DROP ROLE&lt;/code&gt; automatically revokes any memberships of the target role in other roles, and of other roles in the target role. The other roles are not dropped nor otherwise affected.</source>
          <target state="translated">ただし、役割に関連する役割メンバーシップを削除する必要はありません。 &lt;code&gt;DROP ROLE&lt;/code&gt; は、他のロールのターゲットロールのメンバーシップ、およびターゲットロールのその他のロールのメンバーシップを自動的に取り消します。その他の役割は削除されず、影響も受けません。</target>
        </trans-unit>
        <trans-unit id="f99a4fe30aa35a7291430986cdc65efbff8dd39f" translate="yes" xml:space="preserve">
          <source>However, the above does not account for amortization of index reads across repeated index scans.</source>
          <target state="translated">しかし、上記は、繰り返されるインデックススキャンにまたがるインデックスリードの償却を考慮していない。</target>
        </trans-unit>
        <trans-unit id="8c28ea9e20c2e7864029d4301f424d9903192d30" translate="yes" xml:space="preserve">
          <source>However, the current implementation ignores any supplied array size limits, i.e., the behavior is the same as for arrays of unspecified length.</source>
          <target state="translated">しかし,現在の実装では,指定された配列サイズの制限は無視されます.</target>
        </trans-unit>
        <trans-unit id="e7668db05f29105ac82edf505ab55c50a37483ff" translate="yes" xml:space="preserve">
          <source>However, the first and second calls will prefer more-specific functions, if available:</source>
          <target state="translated">しかし、最初の呼び出しと2回目の呼び出しは、利用可能であれば、より特定の関数を好むでしょう。</target>
        </trans-unit>
        <trans-unit id="8dd49b73a6bd91b9638ef49c19702f4c5cff091d" translate="yes" xml:space="preserve">
          <source>However, the index can also be used in queries that do not involve &lt;code&gt;order_nr&lt;/code&gt; at all, e.g.:</source>
          <target state="translated">ただし、インデックスは、 &lt;code&gt;order_nr&lt;/code&gt; をまったく含まないクエリでも使用できます。例：</target>
        </trans-unit>
        <trans-unit id="a2b5348adbefd43e71711c0de0facb597d742b53" translate="yes" xml:space="preserve">
          <source>However, the index could not be used for queries like the following, because though the operator &lt;code&gt;?&lt;/code&gt; is indexable, it is not applied directly to the indexed column &lt;code&gt;jdoc&lt;/code&gt;:</source>
          <target state="translated">ただし、次のようなクエリにはインデックスを使用できません &lt;code&gt;?&lt;/code&gt; 索引付け可能であり、索引付けされた列 &lt;code&gt;jdoc&lt;/code&gt; に直接適用されません。</target>
        </trans-unit>
        <trans-unit id="30d62ecc57d7df5a78dd582f05557b7fb23c077b" translate="yes" xml:space="preserve">
          <source>However, the second query may give unexpected results if &lt;code&gt;salesmen&lt;/code&gt;.&lt;code&gt;id&lt;/code&gt; is not a unique key, whereas the first query is guaranteed to raise an error if there are multiple &lt;code&gt;id&lt;/code&gt; matches. Also, if there is no match for a particular &lt;code&gt;accounts&lt;/code&gt;.&lt;code&gt;sales_id&lt;/code&gt; entry, the first query will set the corresponding name fields to NULL, whereas the second query will not update that row at all.</source>
          <target state="translated">ただし、2番目のクエリでは、 &lt;code&gt;salesmen&lt;/code&gt; の場合に予期しない結果が生じる可能性があります。 &lt;code&gt;id&lt;/code&gt; は一意のキーではありませんが、最初のクエリでは、一致する &lt;code&gt;id&lt;/code&gt; が複数ある場合にエラーが発生することが保証されています。また、特定の &lt;code&gt;accounts&lt;/code&gt; 一致するものがない場合。 &lt;code&gt;sales_id&lt;/code&gt; エントリでは、最初のクエリは対応する名前フィールドをNULLに設定しますが、2番目のクエリはその行をまったく更新しません。</target>
        </trans-unit>
        <trans-unit id="ac0aa3ca3aadbd76b33daf42fe2d9f38b7a21341" translate="yes" xml:space="preserve">
          <source>However, this is not recommended. Floating point numbers should not be used to handle money due to the potential for rounding errors.</source>
          <target state="translated">ただし、これはお勧めできません。浮動小数点数は、丸め誤差が生じる可能性があるため、お金の取り扱いには使用しないでください。</target>
        </trans-unit>
        <trans-unit id="e7a5e278e5a670634fe4d0890f09f0f07f287151" translate="yes" xml:space="preserve">
          <source>However, this only works for types whose names are also valid as function names. For example, &lt;code&gt;double precision&lt;/code&gt; cannot be used this way, but the equivalent &lt;code&gt;float8&lt;/code&gt; can. Also, the names &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, and &lt;code&gt;timestamp&lt;/code&gt; can only be used in this fashion if they are double-quoted, because of syntactic conflicts. Therefore, the use of the function-like cast syntax leads to inconsistencies and should probably be avoided.</source>
          <target state="translated">ただし、これは名前が関数名としても有効な型に対してのみ機能します。たとえば、 &lt;code&gt;double precision&lt;/code&gt; はこの方法では使用できませんが、同等の &lt;code&gt;float8&lt;/code&gt; では使用できます。また、 &lt;code&gt;interval&lt;/code&gt; 、 &lt;code&gt;time&lt;/code&gt; 、および &lt;code&gt;timestamp&lt;/code&gt; の名前は、構文の競合のため、二重引用符で囲まれている場合にのみ、この方法で使用できます。したがって、関数のようなキャスト構文を使用すると矛盾が生じ、おそらく回避する必要があります。</target>
        </trans-unit>
        <trans-unit id="ab41e0a4da3a7de05a4b7068787924b0e3cb154d" translate="yes" xml:space="preserve">
          <source>However, this quickly becomes tedious for large arrays, and is not helpful if the size of the array is unknown. An alternative method is described in &lt;a href=&quot;functions-comparisons&quot;&gt;Section 9.23&lt;/a&gt;. The above query could be replaced by:</source>
          <target state="translated">ただし、これは大きな配列ではすぐに退屈になるため、配列のサイズが不明な場合は役に立ちません。代替方法については、&lt;a href=&quot;functions-comparisons&quot;&gt;セクション9.23で&lt;/a&gt;説明します。上記のクエリは次のように置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="49121f1f7d3b19887ff759c895c872e45fe0450d" translate="yes" xml:space="preserve">
          <source>However, unless a module is specifically designed to be used in this way by non-superusers, this is usually not the right setting to use. Look at &lt;a href=&quot;runtime-config-client#GUC-SESSION-PRELOAD-LIBRARIES&quot;&gt;session_preload_libraries&lt;/a&gt; instead.</source>
          <target state="translated">ただし、モジュールがスーパーユーザー以外のユーザーがこのように使用するように特別に設計されていない限り、これは通常、適切な設定ではありません。代わりに、&lt;a href=&quot;runtime-config-client#GUC-SESSION-PRELOAD-LIBRARIES&quot;&gt;session_preload_libraries&lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="f4744bf3a8101c9dd55ef2a04f348b62af8e9994" translate="yes" xml:space="preserve">
          <source>However, while the directory contents are secure, the default client authentication setup allows any local user to connect to the database and even become the database superuser. If you do not trust other local users, we recommend you use one of &lt;code&gt;initdb&lt;/code&gt;'s &lt;code&gt;-W&lt;/code&gt;, &lt;code&gt;--pwprompt&lt;/code&gt; or &lt;code&gt;--pwfile&lt;/code&gt; options to assign a password to the database superuser. Also, specify &lt;code&gt;-A md5&lt;/code&gt; or &lt;code&gt;-A password&lt;/code&gt; so that the default &lt;code&gt;trust&lt;/code&gt; authentication mode is not used; or modify the generated &lt;code&gt;pg_hba.conf&lt;/code&gt; file after running &lt;code&gt;initdb&lt;/code&gt;, but &lt;em&gt;before&lt;/em&gt; you start the server for the first time. (Other reasonable approaches include using &lt;code&gt;peer&lt;/code&gt; authentication or file system permissions to restrict connections. See &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt; for more information.)</source>
          <target state="translated">ただし、ディレクトリの内容は安全ですが、デフォルトのクライアント認証設定では、すべてのローカルユーザーがデータベースに接続して、データベースのスーパーユーザーになることさえできます。あなたが他のローカルユーザを信用しない場合、我々はあなたがのいずれかを使用をお勧めします &lt;code&gt;initdb&lt;/code&gt; のさん &lt;code&gt;-W&lt;/code&gt; 、 &lt;code&gt;--pwprompt&lt;/code&gt; または &lt;code&gt;--pwfile&lt;/code&gt; データベーススーパーユーザにパスワードを割り当てるオプションを。また、デフォルトの &lt;code&gt;trust&lt;/code&gt; 認証モードが使用されないように、 &lt;code&gt;-A md5&lt;/code&gt; または &lt;code&gt;-A password&lt;/code&gt; 指定します。または、 &lt;code&gt;initdb&lt;/code&gt; の実行後、ただし&lt;em&gt;前に&lt;/em&gt;、生成された &lt;code&gt;pg_hba.conf&lt;/code&gt; ファイルを変更します。&lt;em&gt;&lt;/em&gt;初めてサーバーを起動します。（他の適切なアプローチには、 &lt;code&gt;peer&lt;/code&gt; 認証またはファイルシステムのアクセス許可を使用して接続を制限することが含まれます。詳細は、&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;第20章を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="57ff938f130455fd7c5423b61feb93bb1fcef3bc" translate="yes" xml:space="preserve">
          <source>Huge pages are known as large pages on Windows. To use them, you need to assign the user right Lock Pages in Memory to the Windows user account that runs PostgreSQL. You can use Windows Group Policy tool (gpedit.msc) to assign the user right Lock Pages in Memory. To start the database server on the command prompt as a standalone process, not as a Windows service, the command prompt must be run as an administrator or User Access Control (UAC) must be disabled. When the UAC is enabled, the normal command prompt revokes the user right Lock Pages in Memory when started.</source>
          <target state="translated">巨大なページは、Windows上ではラージページとして知られています。それらを使用するには、PostgreSQLを実行しているWindowsユーザアカウントにユーザ権限のLock Pages in Memoryを割り当てる必要があります。Windowsのグループポリシーツール(gpedit.msc)を使用して、ユーザ権限のLock Pages in Memoryを割り当てることができます。コマンドプロンプトでデータベースサーバをWindowsサービスではなくスタンドアロンプロセスとして起動するには、コマンドプロンプトを管理者として実行するか、ユーザアクセス制御(UAC)を無効にする必要があります。UAC が有効になっている場合、通常のコマンド プロンプトでは、起動時にユーザーの権利である Lock Pages in Memory が取り消されます。</target>
        </trans-unit>
        <trans-unit id="d8bf3846fb1be35204cb20d765d7076251578e99" translate="yes" xml:space="preserve">
          <source>Hyphenated word part, all ASCII</source>
          <target state="translated">ハイフン付きの単語部分、すべてASCII</target>
        </trans-unit>
        <trans-unit id="8cdd097739f98ad844abd99f2945f21997a9eb1e" translate="yes" xml:space="preserve">
          <source>Hyphenated word part, all letters</source>
          <target state="translated">ハイフンで区切られた単語の部分、すべての文字</target>
        </trans-unit>
        <trans-unit id="e93c4156f46693ca03a7e7a80ab8d3ba346ec445" translate="yes" xml:space="preserve">
          <source>Hyphenated word part, letters and digits</source>
          <target state="translated">ハイフンで区切られた単語の部分、文字と数字</target>
        </trans-unit>
        <trans-unit id="5b3864b1f64d7c5d3d32b1aa431d4fc8168f5866" translate="yes" xml:space="preserve">
          <source>Hyphenated word, all ASCII</source>
          <target state="translated">ハイフン付きワード、すべてASCII</target>
        </trans-unit>
        <trans-unit id="913f77eb20ad8621544651272e4864006cc9a993" translate="yes" xml:space="preserve">
          <source>Hyphenated word, all letters</source>
          <target state="translated">ハイフン付きの単語、すべての文字</target>
        </trans-unit>
        <trans-unit id="f8a2b7bdb3666b53d93dd9a984de988e23d346eb" translate="yes" xml:space="preserve">
          <source>Hyphenated word, letters and digits</source>
          <target state="translated">ハイフン付きの単語、文字、数字</target>
        </trans-unit>
        <trans-unit id="b4d527f11debd0a7c15ff494a4d7c586833b355b" translate="yes" xml:space="preserve">
          <source>I believe this union:</source>
          <target state="translated">私はこの組合を信じています。</target>
        </trans-unit>
        <trans-unit id="778d85fd9d1cf9d0bbf34776934bafa267e37666" translate="yes" xml:space="preserve">
          <source>ICU &amp;ldquo;root&amp;rdquo; collation. Use this to get a reasonable language-agnostic sort order.</source>
          <target state="translated">ICUの「ルート」照合。これを使用して、言語に依存しない合理的な並べ替え順序を取得します。</target>
        </trans-unit>
        <trans-unit id="4186bb5b6042e95ce616f6bfea478c30a4a80a0a" translate="yes" xml:space="preserve">
          <source>ICU allows collations to be customized beyond the basic language+country set that is preloaded by &lt;code&gt;initdb&lt;/code&gt;. Users are encouraged to define their own collation objects that make use of these facilities to suit the sorting behavior to their requirements. See &lt;a href=&quot;http://userguide.icu-project.org/locale&quot;&gt;http://userguide.icu-project.org/locale&lt;/a&gt; and &lt;a href=&quot;http://userguide.icu-project.org/collation/api&quot;&gt;http://userguide.icu-project.org/collation/api&lt;/a&gt; for information on ICU locale naming. The set of acceptable names and attributes depends on the particular ICU version.</source>
          <target state="translated">ICUでは、 &lt;code&gt;initdb&lt;/code&gt; によってプリロードされた基本的な言語+国セットを超えて照合をカスタマイズできます。ユーザーは、これらの機能を利用して独自の照合オブジェクトを定義し、ソート動作を要件に適合させることをお勧めします。ICUロケールの命名については、&lt;a href=&quot;http://userguide.icu-project.org/collation/api&quot;&gt;http&lt;/a&gt;：&lt;a href=&quot;http://userguide.icu-project.org/locale&quot;&gt;//userguide.icu-project.org/locale&lt;/a&gt;およびhttp://userguide.icu-project.org/collat​​ion/apiを参照してください。受け入れ可能な名前と属性のセットは、特定のICUバージョンによって異なります。</target>
        </trans-unit>
        <trans-unit id="6f538ad1e5ea2537ef4ecc8ee6d246518b569e28" translate="yes" xml:space="preserve">
          <source>ICU?</source>
          <target state="translated">ICU?</target>
        </trans-unit>
        <trans-unit id="85ddc12eb726993ba7496e593b7b33905cb52428" translate="yes" xml:space="preserve">
          <source>ID of a role that has a member</source>
          <target state="translated">メンバーを持つロールのID</target>
        </trans-unit>
        <trans-unit id="5e2534334ba3879c3b535d5349da57994812e977" translate="yes" xml:space="preserve">
          <source>ID of a role that is a member of &lt;code&gt;roleid&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;roleid&lt;/code&gt; のメンバーであるロールのID</target>
        </trans-unit>
        <trans-unit id="b3334a0f3355b9fb358c2a763909308ff227db92" translate="yes" xml:space="preserve">
          <source>ID of role</source>
          <target state="translated">役割のID</target>
        </trans-unit>
        <trans-unit id="00ab5d608ce03301bac5fabc168033a98fb8425a" translate="yes" xml:space="preserve">
          <source>ID of the role that granted this membership</source>
          <target state="translated">このメンバーシップを付与したロールのID</target>
        </trans-unit>
        <trans-unit id="4acecf86a885801175aac9f839c4e27dfcd0bb71" translate="yes" xml:space="preserve">
          <source>ID of the transaction targeted by the lock, or null if the target is not a transaction ID</source>
          <target state="translated">ロックの対象となるトランザクションのID、または対象がトランザクションIDでない場合はNULL。</target>
        </trans-unit>
        <trans-unit id="4405588c83fcde9e77a297389a5a77edfc33fd81" translate="yes" xml:space="preserve">
          <source>ID of this group</source>
          <target state="translated">このグループのID</target>
        </trans-unit>
        <trans-unit id="364041630f947c82ae36797d2d8b4d8c51f1090b" translate="yes" xml:space="preserve">
          <source>ID of this user</source>
          <target state="translated">このユーザーのID</target>
        </trans-unit>
        <trans-unit id="efeddb9b2b9bc9d252eb880921c3b8b3f041d65a" translate="yes" xml:space="preserve">
          <source>ID, in the range 1..&lt;code&gt;shared_buffers&lt;/code&gt;</source>
          <target state="translated">ID、1 .. &lt;code&gt;shared_buffers&lt;/code&gt; の範囲</target>
        </trans-unit>
        <trans-unit id="fab9fa5af6726f4fbc7c7dbc87a28acfc40a63e9" translate="yes" xml:space="preserve">
          <source>IEC</source>
          <target state="translated">IEC</target>
        </trans-unit>
        <trans-unit id="91e003cabbbc52544795f505584d809fe4bf1cdc" translate="yes" xml:space="preserve">
          <source>IEEE</source>
          <target state="translated">IEEE</target>
        </trans-unit>
        <trans-unit id="44285b6e9ccd859327d44fd855fe1b27a08233b1" translate="yes" xml:space="preserve">
          <source>IEEE Std 802-2001 specifies the second shown form (with hyphens) as the canonical form for MAC addresses, and specifies the first form (with colons) as the bit-reversed notation, so that 08-00-2b-01-02-03 = 01:00:4D:08:04:0C. This convention is widely ignored nowadays, and it is relevant only for obsolete network protocols (such as Token Ring). PostgreSQL makes no provisions for bit reversal, and all accepted formats use the canonical LSB order.</source>
          <target state="translated">IEEE Std 802-2001では、MACアドレスの正規表現として第2の形式(ハイフン付き)を指定し、ビット反転表記として第1の形式(コロン付き)を指定しているため、08-00-2b-01-02-03=01:00:4D:08:04:0Cとなります。この規約は現在では広く無視されており、時代遅れのネットワークプロトコル(トークンリングなど)にのみ関係しています。PostgreSQLはビット反転の規定を設けておらず、すべての受け入れられている形式は正規のLSB順序を使用します。</target>
        </trans-unit>
        <trans-unit id="c6125697017457f602c07e148a748e8cb804d044" translate="yes" xml:space="preserve">
          <source>IEEE754 specifies that &lt;code&gt;NaN&lt;/code&gt; should not compare equal to any other floating-point value (including &lt;code&gt;NaN&lt;/code&gt;). In order to allow floating-point values to be sorted and used in tree-based indexes, PostgreSQL treats &lt;code&gt;NaN&lt;/code&gt; values as equal, and greater than all non-&lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">IEEE754は、 &lt;code&gt;NaN&lt;/code&gt; が他の浮動小数点値（ &lt;code&gt;NaN&lt;/code&gt; を含む）と比較してはならないことを規定しています。浮動小数点値をソートしてツリーベースのインデックスで使用できるようにするために、PostgreSQLは &lt;code&gt;NaN&lt;/code&gt; 値をすべての非 &lt;code&gt;NaN&lt;/code&gt; 値よりも大きく、等しいものとして扱います。</target>
        </trans-unit>
        <trans-unit id="0d3a231ed1c6dcab8fa35edd0bd127d0e5d21d84" translate="yes" xml:space="preserve">
          <source>IMPORT FOREIGN SCHEMA</source>
          <target state="translated">FOREIGN SCHEMAをインポート</target>
        </trans-unit>
        <trans-unit id="b8d5fc1f41eb794e02ccf1b51b842239e54448da" translate="yes" xml:space="preserve">
          <source>IMPORT FOREIGN SCHEMA &amp;mdash; import table definitions from a foreign server</source>
          <target state="translated">IMPORT FOREIGN SCHEMA &amp;mdash;外部サーバーからテーブル定義をインポートします</target>
        </trans-unit>
        <trans-unit id="c20ea07e32d25c072a65368c234d6f5a88f4521a" translate="yes" xml:space="preserve">
          <source>INSERT</source>
          <target state="translated">INSERT</target>
        </trans-unit>
        <trans-unit id="b42f874d7db1e2726d84a76cc0d5b0946a10b15b" translate="yes" xml:space="preserve">
          <source>INSERT &amp;mdash; create new rows in a table</source>
          <target state="translated">INSERT &amp;mdash;テーブルに新しい行を作成する</target>
        </trans-unit>
        <trans-unit id="48ef49cd856e5cecb996e0f1d379dbd5b56b7cb9" translate="yes" xml:space="preserve">
          <source>IP address mask, or null if not applicable</source>
          <target state="translated">IP アドレスのマスク、または該当しない場合は NULL</target>
        </trans-unit>
        <trans-unit id="998514d91724c3d88d4cab07518debfcd96862e2" translate="yes" xml:space="preserve">
          <source>IP address of the client connected to this WAL sender. If this field is null, it indicates that the client is connected via a Unix socket on the server machine.</source>
          <target state="translated">このWAL送信者に接続されているクライアントのIPアドレス。このフィールドがNULLの場合、クライアントがサーバマシン上のUnixソケットを介して接続されていることを示します。</target>
        </trans-unit>
        <trans-unit id="26ec3318a4493a39e748c88c589f3baeb8b0af15" translate="yes" xml:space="preserve">
          <source>IP address of the client connected to this backend</source>
          <target state="translated">このバックエンドに接続しているクライアントのIPアドレス</target>
        </trans-unit>
        <trans-unit id="4da843a738e5c670d4d958349979cce4c9e32eb3" translate="yes" xml:space="preserve">
          <source>IP address of the client connected to this backend. If this field is null, it indicates either that the client is connected via a Unix socket on the server machine or that this is an internal process such as autovacuum.</source>
          <target state="translated">このバックエンドに接続されているクライアントのIPアドレス。このフィールドがNULLの場合、クライアントがサーバマシンのUnixソケットを介して接続されているか、これがautovacuumのような内部プロセスであることを示します。</target>
        </trans-unit>
        <trans-unit id="f4aa7e6cdf843e01253be3fd2becaee731842f78" translate="yes" xml:space="preserve">
          <source>IPC</source>
          <target state="translated">IPC</target>
        </trans-unit>
        <trans-unit id="82c9856123dd418f4774d9eae5cdc6c13b4a17dd" translate="yes" xml:space="preserve">
          <source>IPC parameters can be set in the System Administration Manager (SAM) under Kernel Configuration &amp;rarr; Configurable Parameters. Choose Create A New Kernel when you're done.</source>
          <target state="translated">IPCパラメータは、システム管理マネージャ（SAM）の[カーネル構成]&amp;rarr;[構成可能パラメータ]で設定できます。完了したら、[新しいカーネルの作成]を選択します。</target>
        </trans-unit>
        <trans-unit id="ab288f3447cf3cc34399c5b2b5851efa6c3d80a4" translate="yes" xml:space="preserve">
          <source>IPv4 and IPv6 hosts and networks</source>
          <target state="translated">IPv4 および IPv6 ホストとネットワーク</target>
        </trans-unit>
        <trans-unit id="86de966d86cc975242ef8e4aaaa8450d6855f8c5" translate="yes" xml:space="preserve">
          <source>IPv4 and IPv6 networks</source>
          <target state="translated">IPv4およびIPv6ネットワーク</target>
        </trans-unit>
        <trans-unit id="570cca22ddf6e073a6dbd2cc896fd406204eb7b0" translate="yes" xml:space="preserve">
          <source>IPv4 or IPv6 host address</source>
          <target state="translated">IPv4 または IPv6 ホストアドレス</target>
        </trans-unit>
        <trans-unit id="c2e4edd4992d9d0688f940e8473197cf9ffe481e" translate="yes" xml:space="preserve">
          <source>IPv4 or IPv6 network address</source>
          <target state="translated">IPv4 または IPv6 ネットワークアドレス</target>
        </trans-unit>
        <trans-unit id="9d11567d01c59efb43ef67bb8206340e658f9d9d" translate="yes" xml:space="preserve">
          <source>ISBN &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISBN &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="bb9ab15de59e9d547e927c8c62069791df1e8268" translate="yes" xml:space="preserve">
          <source>ISBN &amp;lt;=&amp;gt; ISBN13</source>
          <target state="translated">ISBN &amp;lt;=&amp;gt; ISBN13</target>
        </trans-unit>
        <trans-unit id="a43d901bb73f40ccaba8783a1129360f50fba85d" translate="yes" xml:space="preserve">
          <source>ISBN13 &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISBN13 &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="4497b3ae9c75adbc043fd5847cc29356be8a5644" translate="yes" xml:space="preserve">
          <source>ISBN13, ISMN13, ISSN13 numbers are all EAN13 numbers.</source>
          <target state="translated">ISBN13、ISMN13、ISSN13の番号はすべてEAN13番号です。</target>
        </trans-unit>
        <trans-unit id="95889ddf7167ca49889a166a2e3858db51bb28d5" translate="yes" xml:space="preserve">
          <source>ISMN &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISMN &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="d9a94674870da708d9a2ffc2a85d2b1561319391" translate="yes" xml:space="preserve">
          <source>ISMN &amp;lt;=&amp;gt; ISMN13</source>
          <target state="translated">ISMN &amp;lt;=&amp;gt; ISMN13</target>
        </trans-unit>
        <trans-unit id="9f6fa2a3d8d31764fc531c626fb4ec439b13e49d" translate="yes" xml:space="preserve">
          <source>ISMN13 &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISMN13 &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="4f325d995b6d028ccc75771b1679537b623521c4" translate="yes" xml:space="preserve">
          <source>ISO</source>
          <target state="translated">ISO</target>
        </trans-unit>
        <trans-unit id="445867d9c88cb9ec795d4d1edb4358f7f32ed23d" translate="yes" xml:space="preserve">
          <source>ISO 8601</source>
          <target state="translated">ISO8601</target>
        </trans-unit>
        <trans-unit id="03b66feb77a5287d927a40831615b0a53c5c265e" translate="yes" xml:space="preserve">
          <source>ISO 8601 &amp;ldquo;alternative format&amp;rdquo;: same meaning as above</source>
          <target state="translated">ISO 8601「代替フォーマット」：上記と同じ意味</target>
        </trans-unit>
        <trans-unit id="347f83fd1ecbce8da8703c53ec0ee71401af00f9" translate="yes" xml:space="preserve">
          <source>ISO 8601 &amp;ldquo;format with designators&amp;rdquo;: same meaning as above</source>
          <target state="translated">ISO 8601「指定子付きのフォーマット」：上記と同じ意味</target>
        </trans-unit>
        <trans-unit id="249eb6740bd82a6c1db53f9cab25650c97a5d209" translate="yes" xml:space="preserve">
          <source>ISO 8601 day of the week, Monday (&lt;code&gt;1&lt;/code&gt;) to Sunday (&lt;code&gt;7&lt;/code&gt;)</source>
          <target state="translated">ISO 8601曜日、月曜日（ &lt;code&gt;1&lt;/code&gt; ）から日曜日（ &lt;code&gt;7&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="9d2092d27bf384f64eb368a2dfd612d31022bd2b" translate="yes" xml:space="preserve">
          <source>ISO 8601 specifies the use of uppercase letter &lt;code&gt;T&lt;/code&gt; to separate the date and time. PostgreSQL accepts that format on input, but on output it uses a space rather than &lt;code&gt;T&lt;/code&gt;, as shown above. This is for readability and for consistency with RFC 3339 as well as some other database systems.</source>
          <target state="translated">ISO 8601では、日付を区別するために大文字の &lt;code&gt;T&lt;/code&gt; を使用することを指定しています。PostgreSQLは入力でその形式を受け入れますが、出力では上記のように &lt;code&gt;T&lt;/code&gt; ではなくスペースを使用します。これは、読みやすさ、およびRFC 3339と他の一部のデータベースシステムとの整合性のためです。</target>
        </trans-unit>
        <trans-unit id="5e8d83297c37a8caa9129a785251aaffead6b3d8" translate="yes" xml:space="preserve">
          <source>ISO 8601 week-numbering year (4 or more digits)</source>
          <target state="translated">ISO 8601 週番付年号(4桁以上</target>
        </trans-unit>
        <trans-unit id="5113b76aa827aecd1b2fbeb19739776b2cdcbdb5" translate="yes" xml:space="preserve">
          <source>ISO 8601, SQL standard</source>
          <target state="translated">ISO 8601、SQL標準</target>
        </trans-unit>
        <trans-unit id="c4bb947ff5dc5345f70f6892f02bf85a04d4eb7d" translate="yes" xml:space="preserve">
          <source>ISO 8601; January 8 in any mode (recommended format)</source>
          <target state="translated">ISO 8601;1月8日の任意のモード(推奨フォーマット</target>
        </trans-unit>
        <trans-unit id="a83c80f67456b395aa2704158f1dc68957610271" translate="yes" xml:space="preserve">
          <source>ISO 8601; January 8, 1999 in any mode</source>
          <target state="translated">ISO 8601;1999年1月8日、任意のモードで</target>
        </trans-unit>
        <trans-unit id="b1922fbd22025577b8a5e43c812e096c3b9acffc" translate="yes" xml:space="preserve">
          <source>ISO 8859-1, ECMA 94</source>
          <target state="translated">ISO 8859-1、ECMA 94</target>
        </trans-unit>
        <trans-unit id="276d48941fbc0543fbb5ce642fe1dc3b05b9bb7d" translate="yes" xml:space="preserve">
          <source>ISO 8859-10, ECMA 144</source>
          <target state="translated">ISO 8859-10、ECMA 144</target>
        </trans-unit>
        <trans-unit id="b206da53a9051bf3226d71a6e114418f28766469" translate="yes" xml:space="preserve">
          <source>ISO 8859-13</source>
          <target state="translated">ISO 8859-13</target>
        </trans-unit>
        <trans-unit id="26424d0dadf461ca6901513d3dcfc085ec66b2c7" translate="yes" xml:space="preserve">
          <source>ISO 8859-14</source>
          <target state="translated">ISO 8859-14</target>
        </trans-unit>
        <trans-unit id="b292668cb49c44b020b58d7d79cd50329ab61aed" translate="yes" xml:space="preserve">
          <source>ISO 8859-15</source>
          <target state="translated">ISO 8859-15</target>
        </trans-unit>
        <trans-unit id="6a937cb9225885ed540430a532e08182311c8fb7" translate="yes" xml:space="preserve">
          <source>ISO 8859-16, ASRO SR 14111</source>
          <target state="translated">ISO 8859-16、ASRO SR 14111</target>
        </trans-unit>
        <trans-unit id="5f8eb67d9b294dc7fa2960e49427ec254bf78d3e" translate="yes" xml:space="preserve">
          <source>ISO 8859-2, ECMA 94</source>
          <target state="translated">ISO 8859-2、ECMA 94</target>
        </trans-unit>
        <trans-unit id="34bfa7b1e0970a505b7c18beda35ee12ae67b627" translate="yes" xml:space="preserve">
          <source>ISO 8859-3, ECMA 94</source>
          <target state="translated">ISO 8859-3、ECMA 94</target>
        </trans-unit>
        <trans-unit id="19f1d5efe10cfb525dac348f64f156d08531f5ba" translate="yes" xml:space="preserve">
          <source>ISO 8859-4, ECMA 94</source>
          <target state="translated">ISO 8859-4、ECMA 94</target>
        </trans-unit>
        <trans-unit id="958ae0517642b5a63a0ba42f16e7dba51f3f03b9" translate="yes" xml:space="preserve">
          <source>ISO 8859-5, ECMA 113</source>
          <target state="translated">ISO 8859-5、ECMA 113</target>
        </trans-unit>
        <trans-unit id="edc58fa1dfcc675f8f0e7cd9ba637022f963b9a5" translate="yes" xml:space="preserve">
          <source>ISO 8859-6, ECMA 114</source>
          <target state="translated">ISO 8859-6、ECMA 114</target>
        </trans-unit>
        <trans-unit id="ac642f9b939a7e25fc9c152794f7c55763fbe736" translate="yes" xml:space="preserve">
          <source>ISO 8859-7, ECMA 118</source>
          <target state="translated">ISO 8859-7、ECMA 118</target>
        </trans-unit>
        <trans-unit id="aafb9bf8d9a3dd18a9bc858aa3091007431a81fe" translate="yes" xml:space="preserve">
          <source>ISO 8859-8, ECMA 121</source>
          <target state="translated">ISO 8859-8、ECMA 121</target>
        </trans-unit>
        <trans-unit id="561419819864b8b7eafa254ff17c2c5838572d02" translate="yes" xml:space="preserve">
          <source>ISO 8859-9, ECMA 128</source>
          <target state="translated">ISO 8859-9、ECMA 128</target>
        </trans-unit>
        <trans-unit id="19fa6eb3258ffb4709ac1dfbba399d0753e7e88f" translate="yes" xml:space="preserve">
          <source>ISO-8601 offset for PST</source>
          <target state="translated">PSTのISO-8601オフセット</target>
        </trans-unit>
        <trans-unit id="d9bfc4c480632e7b109f99ac77c51a2a5260171b" translate="yes" xml:space="preserve">
          <source>ISSN</source>
          <target state="translated">ISSN</target>
        </trans-unit>
        <trans-unit id="3941c970e85e394c43837d5b44cc1bf0483f215f" translate="yes" xml:space="preserve">
          <source>ISSN &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISSN &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="a203140c0f91a7564ce62d86b204a626e15ee7d8" translate="yes" xml:space="preserve">
          <source>ISSN &amp;lt;=&amp;gt; ISSN13</source>
          <target state="translated">ISSN &amp;lt;=&amp;gt; ISSN13</target>
        </trans-unit>
        <trans-unit id="57b604002c866aad17fa814a63620ac73af4bf08" translate="yes" xml:space="preserve">
          <source>ISSN13 &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISSN13 &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="0a6d0a09ee6e1eec933513081c533fbe57cab3a4" translate="yes" xml:space="preserve">
          <source>Ident Authentication</source>
          <target state="translated">アイデンティティ認証</target>
        </trans-unit>
        <trans-unit id="06b6ace8ca3f18249e8ba4ea9090c0f34564ce1c" translate="yes" xml:space="preserve">
          <source>Identifier</source>
          <target state="translated">Identifier</target>
        </trans-unit>
        <trans-unit id="64ed35bcb9eba82bb5083c305000e3e8e174b736" translate="yes" xml:space="preserve">
          <source>Identifier of the large object that includes this page</source>
          <target state="translated">このページを含むラージオブジェクトの識別子</target>
        </trans-unit>
        <trans-unit id="d19347e41a5213caf5fbef640d085e03cc5288d2" translate="yes" xml:space="preserve">
          <source>Identifies a function taking or returning an unspecified row type.</source>
          <target state="translated">指定されていない行の型を取る、または返す関数を識別します。</target>
        </trans-unit>
        <trans-unit id="9f9c67a87f9e8c8e7cd1eee8d202259f233b1765" translate="yes" xml:space="preserve">
          <source>Identifies a not-yet-resolved type, e.g. of an undecorated string literal.</source>
          <target state="translated">未解決の文字列リテラルのような、装飾されていない文字列リテラルの未解決型を識別します。</target>
        </trans-unit>
        <trans-unit id="c7cbe1f08ac13359acc228819549de4cb50db912" translate="yes" xml:space="preserve">
          <source>Identifies a representation of DDL commands that is available to event triggers.</source>
          <target state="translated">イベントトリガーで利用可能なDDLコマンドの表現を識別します。</target>
        </trans-unit>
        <trans-unit id="c10498b4e600d39b28759a6ca1704d299a1166cc" translate="yes" xml:space="preserve">
          <source>Identifies the event for which this trigger fires</source>
          <target state="translated">このトリガーが発生するイベントを識別します。</target>
        </trans-unit>
        <trans-unit id="708e5b0969ad9b9e70cb24a115182be857e71a40" translate="yes" xml:space="preserve">
          <source>If 1, OIDs are included in the data; if 0, not. Oid system columns are not supported in PostgreSQL anymore, but the format still contains the indicator.</source>
          <target state="translated">1の場合、OIDがデータに含まれ、0の場合は含まれません。OIDシステムカラムはPostgreSQLではサポートされなくなりましたが、フォーマットにはまだインジケータが含まれています。</target>
        </trans-unit>
        <trans-unit id="bb8295c4be7fefd76f1788c97ecf7d786d2a81d6" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;cluster_name&lt;/a&gt; has been configured the cluster name will also be shown in &lt;code&gt;ps&lt;/code&gt; output:</source>
          <target state="translated">&lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;cluster_name&lt;/a&gt;が構成されている場合、クラスター名も &lt;code&gt;ps&lt;/code&gt; 出力に表示されます。</target>
        </trans-unit>
        <trans-unit id="8a629049c6dc481b39f88d9e65ac7e85ce3a796f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; is set to &lt;code&gt;off&lt;/code&gt;, or if no JIT implementation is available (for example because the server was compiled without &lt;code&gt;--with-llvm&lt;/code&gt;), JIT will not be performed, even if it would be beneficial based on the above criteria. Setting &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt; has effects at both plan and execution time.</source>
          <target state="translated">場合&lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;JITが&lt;/a&gt;に設定されている &lt;code&gt;off&lt;/code&gt; 、又は（サーバをせずにコンパイルされたため、例えば何JIT実装が利用できない場合 &lt;code&gt;--with-llvm&lt;/code&gt; ）、JITは、上記の基準に基づくことが有益である場合であっても、実行されません。&lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt;を &lt;code&gt;off&lt;/code&gt; に設定すると、計画時と実行時の両方に影響があります。</target>
        </trans-unit>
        <trans-unit id="9523a6aef92c0b8b469d3754e7282b8f5942c267" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt; is non-empty, this parameter also controls whether or not transaction commits will wait for their WAL records to be replicated to the standby server(s). When set to &lt;code&gt;on&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and flushed it to disk. This ensures the transaction will not be lost unless both the primary and all synchronous standbys suffer corruption of their database storage. When set to &lt;code&gt;remote_apply&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and applied it, so that it has become visible to queries on the standby(s). When set to &lt;code&gt;remote_write&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and written it out to their operating system. This setting is sufficient to ensure data preservation even if a standby instance of PostgreSQL were to crash, but not if the standby suffers an operating-system-level crash, since the data has not necessarily reached stable storage on the standby. Finally, the setting &lt;code&gt;local&lt;/code&gt; causes commits to wait for local flush to disk, but not for replication. This is not usually desirable when synchronous replication is in use, but is provided for completeness.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;Synchronous_standby_names&lt;/a&gt;が空でない場合、このパラメーターは、トランザクションコミットがWALレコードがスタンバイサーバーにレプリケートされるのを待つかどうかも制御します。 &lt;code&gt;on&lt;/code&gt; に設定すると、コミットは、現在の同期スタンバイからの応答がトランザクションのコミットレコードを受信して​​ディスクにフラッシュしたことを示すまで待機します。これにより、プライマリスタンバイとすべての同期スタンバイの両方でデータベースストレージが破損しない限り、トランザクションが失われることはありません。 &lt;code&gt;remote_apply&lt;/code&gt; に設定すると、コミットは、現在の同期スタンバイからの応答がトランザクションのコミットレコードを受信して​​適用したことを示すまで待機するため、スタンバイのクエリから見えるようになります。に設定した場合 &lt;code&gt;remote_write&lt;/code&gt; 、コミットは、現在の同期スタンバイからの応答がトランザクションのコミットレコードを受信し、それをオペレーティングシステムに書き込んだことを示すまで待機します。この設定は、PostgreSQLのスタンバイインスタンスがクラッシュした場合でもデータを確実に保持するには十分ですが、スタンバイでオペレーティングシステムレベルのクラッシュが発生した場合は、データがスタンバイの安定したストレージに到達するとは限らないためです。最後に、 &lt;code&gt;local&lt;/code&gt; に設定すると、コミットはディスクへのローカルフラッシュを待機しますが、レプリケーションは待機しません。これは通常、同期レプリケーションが使用されている場合は望ましくありませんが、完全を期すために提供されています。</target>
        </trans-unit>
        <trans-unit id="1a25dc46209d8ed1ade19ed10060c5c528c285e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;+&lt;/code&gt; is appended to the command name, the sum of the sizes of each relation's partitions is also displayed, along with the relation's description. If &lt;code&gt;n&lt;/code&gt; is combined with &lt;code&gt;+&lt;/code&gt;, two sizes are shown: one including the total size of directly-attached leaf partitions, and another showing the total size of all partitions, including indirectly attached sub-partitions.</source>
          <target state="translated">コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各関係のパーティションのサイズの合計も、関係の説明とともに表示されます。もし &lt;code&gt;n&lt;/code&gt; と結合される &lt;code&gt;+&lt;/code&gt; 、2つのサイズが示されている：直接接続リーフ・パーティションの合計サイズを含むものを、もう一つは間接的に結合サブパーティションを含むすべてのパーティションの合計サイズを示します。</target>
        </trans-unit>
        <trans-unit id="f1cb07ba733b8d98ef45c815d6dfcd5240fbfb93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;+&lt;/code&gt; is appended to the command name, then the output lines are numbered from 1.</source>
          <target state="translated">コマンド名に &lt;code&gt;+&lt;/code&gt; が付加されている場合、出力行には1から番号が付けられます。</target>
        </trans-unit>
        <trans-unit id="070b09cd2b09c6b749465149e9d2da178b70c1ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;+&lt;/code&gt; is appended to the command name, then the output lines are numbered, with the first line of the function body being line 1.</source>
          <target state="translated">コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、出力行には番号が付けられ、関数本体の最初の行は1行目です。</target>
        </trans-unit>
        <trans-unit id="2d52331f0d53378e8895c635840bb2a68f08d247" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--latency-limit&lt;/code&gt; is used together with &lt;code&gt;--rate&lt;/code&gt;, a transaction can lag behind so much that it is already over the latency limit when the previous transaction ends, because the latency is calculated from the scheduled start time. Such transactions are not sent to the server, but are skipped altogether and counted separately.</source>
          <target state="translated">&lt;code&gt;--latency-limit&lt;/code&gt; が &lt;code&gt;--rate&lt;/code&gt; と一緒に使用される場合、レイテンシはスケジュールされた開始時間から計算されるため、トランザクションは非常に遅れて、前のトランザクションが終了したときにすでにレイテンシ制限を超えている可能性があります。このようなトランザクションはサーバーに送信されませんが、完全にスキップされ、個別にカウントされます。</target>
        </trans-unit>
        <trans-unit id="5b7745b7624e7dd43bb242cb0d62e7379c97ee2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ALTER TYPE ... ADD VALUE&lt;/code&gt; (the form that adds a new value to an enum type) is executed inside a transaction block, the new value cannot be used until after the transaction has been committed.</source>
          <target state="translated">場合 &lt;code&gt;ALTER TYPE ... ADD VALUE&lt;/code&gt; （列挙型に新しい値を追加して、フォームが）トランザクションブロック内で実行され、新しい値は、トランザクションがコミットされた後まで使用することはできません。</target>
        </trans-unit>
        <trans-unit id="bb077bc49a16e30ee77115d9ffe115d963646660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AND CHAIN&lt;/code&gt; is specified, a new transaction is immediately started with the same transaction characteristics (see &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt;) as the just finished one. Otherwise, no new transaction is started.</source>
          <target state="translated">場合は &lt;code&gt;AND CHAIN&lt;/code&gt; 指定され、新しいトランザクションがすぐに（参照、同じトランザクション特性で開始された&lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTIONを&lt;/a&gt;終了したばかり一つとして）。それ以外の場合、新しいトランザクションは開始されません。</target>
        </trans-unit>
        <trans-unit id="d7c08e9bace5b5133ac34adca9a08f4fe042258e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;CALL&lt;/code&gt; is executed in a transaction block, then the called procedure cannot execute transaction control statements. Transaction control statements are only allowed if &lt;code&gt;CALL&lt;/code&gt; is executed in its own transaction.</source>
          <target state="translated">&lt;code&gt;CALL&lt;/code&gt; がトランザクションブロックで実行される場合、呼び出されたプロシージャはトランザクション制御ステートメントを実行できません。トランザクション制御ステートメントは、 &lt;code&gt;CALL&lt;/code&gt; が独自のトランザクションで実行される場合にのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="848ec5bbdc5b00e6cc3d9f1bcaa95b1dc8f6e6eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DEFAULT&lt;/code&gt; is specified, the table will be created as the default partition of the parent table. This option is not available for hash-partitioned tables. A partition key value not fitting into any other partition of the given parent will be routed to the default partition.</source>
          <target state="translated">場合は &lt;code&gt;DEFAULT&lt;/code&gt; が指定され、テーブルには、親テーブルのデフォルトのパーティションとして作成されます。このオプションは、ハッシュパーティションテーブルでは使用できません。指定された親の他のパーティションに適合しないパーティションキー値は、デフォルトパーティションにルーティングされます。</target>
        </trans-unit>
        <trans-unit id="e7358add8de8561a637a99b57db04968568623ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DISTINCT&lt;/code&gt; is specified in addition to an &lt;code&gt;order_by_clause&lt;/code&gt;, then all the &lt;code&gt;ORDER BY&lt;/code&gt; expressions must match regular arguments of the aggregate; that is, you cannot sort on an expression that is not included in the &lt;code&gt;DISTINCT&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;DISTINCT&lt;/code&gt; が &lt;code&gt;order_by_clause&lt;/code&gt; に加えて指定されている場合、すべての &lt;code&gt;ORDER BY&lt;/code&gt; 式は集計の通常の引数と一致する必要があります。つまり、 &lt;code&gt;DISTINCT&lt;/code&gt; リストに含まれていない式でソートすることはできません。</target>
        </trans-unit>
        <trans-unit id="30705d4f5de2e5919df753dbf707be6e61f46c94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DO&lt;/code&gt; is executed in a transaction block, then the procedure code cannot execute transaction control statements. Transaction control statements are only allowed if &lt;code&gt;DO&lt;/code&gt; is executed in its own transaction.</source>
          <target state="translated">&lt;code&gt;DO&lt;/code&gt; がトランザクションブロックで実行される場合、プロシージャコードはトランザクション制御ステートメントを実行できません。トランザクション制御ステートメントは、 &lt;code&gt;DO&lt;/code&gt; が独自のトランザクションで実行される場合にのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="df6a86ce0cd5c24d459324e69a0c7e3798125378" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DROP IDENTITY IF EXISTS&lt;/code&gt; is specified and the column is not an identity column, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">場合は &lt;code&gt;DROP IDENTITY IF EXISTS&lt;/code&gt; が指定され、列がID列ではありません、エラーがスローされません。この場合、代わりに通知が発行されます。</target>
        </trans-unit>
        <trans-unit id="895523ab1404bbeb5f8a66ec67423cf5c0e02e37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DROP ROLE&lt;/code&gt; is attempted while dependent objects still remain, it will issue messages identifying which objects need to be reassigned or dropped.</source>
          <target state="translated">場合は &lt;code&gt;DROP ROLE&lt;/code&gt; 試行された依存オブジェクトがまだ残っている間、それは再割り当てまたは削除する必要があるオブジェクトの識別メッセージを発行します。</target>
        </trans-unit>
        <trans-unit id="da529f5ed28015eb2651a4b68ada28ed62e240c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FILTER&lt;/code&gt; is specified, then only the input rows for which the &lt;code&gt;filter_clause&lt;/code&gt; evaluates to true are fed to the aggregate function; other rows are discarded. For example:</source>
          <target state="translated">&lt;code&gt;FILTER&lt;/code&gt; が指定されている場合、 &lt;code&gt;filter_clause&lt;/code&gt; がtrueと評価される入力行のみが集約関数に送られます。他の行は破棄されます。例えば：</target>
        </trans-unit>
        <trans-unit id="0bc024c5c56715620389a9f40a0a619b2dabf192" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FILTER&lt;/code&gt; is specified, then only the input rows for which the &lt;code&gt;filter_clause&lt;/code&gt; evaluates to true are fed to the window function; other rows are discarded. Only window functions that are aggregates accept a &lt;code&gt;FILTER&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;FILTER&lt;/code&gt; が指定されている場合、 &lt;code&gt;filter_clause&lt;/code&gt; がtrueと評価される入力行のみがウィンドウ関数に送られます。他の行は破棄されます。集計であるウィンドウ関数のみが &lt;code&gt;FILTER&lt;/code&gt; 句を受け入れます。</target>
        </trans-unit>
        <trans-unit id="cd9e1d53d5d6b7dacb647bc6b43f3a0bb2b3f3ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FINALFUNC_EXTRA&lt;/code&gt; is specified, then in addition to the final state value and any direct arguments, the final function receives extra NULL values corresponding to the aggregate's regular (aggregated) arguments. This is mainly useful to allow correct resolution of the aggregate result type when a polymorphic aggregate is being defined.</source>
          <target state="translated">&lt;code&gt;FINALFUNC_EXTRA&lt;/code&gt; が指定されている場合、最終的な状態値と直接の引数に加えて、最終的な関数は、集計の通常の（集計された）引数に対応する追加のNULL値を受け取ります。これは主に、ポリモーフィック集計が定義されているときに集計結果タイプを正しく解決するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="79c74fbef6be293db9ab06b3c7837e0fb4b62bf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FOR UPDATE&lt;/code&gt;, &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;FOR SHARE&lt;/code&gt; or &lt;code&gt;FOR KEY SHARE&lt;/code&gt; is specified, the &lt;code&gt;SELECT&lt;/code&gt; statement locks the selected rows against concurrent updates. (See &lt;a href=&quot;sql-select#SQL-FOR-UPDATE-SHARE&quot;&gt;The Locking Clause&lt;/a&gt; below.)</source>
          <target state="translated">場合は &lt;code&gt;FOR UPDATE&lt;/code&gt; 、 &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; 、 &lt;code&gt;FOR SHARE&lt;/code&gt; または &lt;code&gt;FOR KEY SHARE&lt;/code&gt; が指定され、 &lt;code&gt;SELECT&lt;/code&gt; ステートメントは、同時更新に対して選択された行をロックします。（下記&lt;a href=&quot;sql-select#SQL-FOR-UPDATE-SHARE&quot;&gt;のロック節を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="a805c0a50f5da5361e847219abae4a282083ebad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FX&lt;/code&gt; is specified, a separator in the template string matches exactly one character in the input string. But note that the input string character is not required to be the same as the separator from the template string. For example, &lt;code&gt;to_timestamp('2000/JUN', 'FXYYYY MON')&lt;/code&gt; works, but &lt;code&gt;to_timestamp('2000/JUN', 'FXYYYY&amp;nbsp;&amp;nbsp;MON')&lt;/code&gt; returns an error because the second space in the template string consumes the letter &lt;code&gt;J&lt;/code&gt; from the input string.</source>
          <target state="translated">&lt;code&gt;FX&lt;/code&gt; が指定されている場合、テンプレート文字列のセパレータは、入力文字列の1文字と正確に一致します。ただし、入力文字列の文字は、テンプレート文字列のセパレータと同じである必要はないことに注意してください。たとえば、 &lt;code&gt;to_timestamp('2000/JUN', 'FXYYYY MON')&lt;/code&gt; 機能しますが、 &lt;code&gt;to_timestamp('2000/JUN', 'FXYYYY&amp;nbsp;&amp;nbsp;MON')&lt;/code&gt; は、テンプレート文字列の2番目のスペースが入力から文字 &lt;code&gt;J&lt;/code&gt; を消費するため、エラーを返しますストリング。</target>
        </trans-unit>
        <trans-unit id="14af0e221ff15633d3dbc5822cb9a995fc47a018" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GENERIC_XLOG_FULL_IMAGE&lt;/code&gt; is not specified for a registered buffer, the generic WAL record contains a delta between the old and the new page images. This delta is based on byte-by-byte comparison. This is not very compact for the case of moving data within a page, and might be improved in the future.</source>
          <target state="translated">&lt;code&gt;GENERIC_XLOG_FULL_IMAGE&lt;/code&gt; が登録済みバッファーに指定されていない場合、汎用WALレコードには、古いページイメージと新しいページイメージの差分が含まれます。この差分は、バイトごとの比較に基づいています。これは、ページ内でデータを移動する場合にはあまりコンパクトではなく、将来的には改善される可能性があります。</target>
        </trans-unit>
        <trans-unit id="dd5c28224428244bd7b83410c113faa1c8237d3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GRANT OPTION FOR&lt;/code&gt; is specified, only the grant option for the privilege is revoked, not the privilege itself. Otherwise, both the privilege and the grant option are revoked.</source>
          <target state="translated">&lt;code&gt;GRANT OPTION FOR&lt;/code&gt; が指定されている場合、権限自体ではなく、権限の付与オプションのみが取り消されます。それ以外の場合は、特権と付与オプションの両方が取り消されます。</target>
        </trans-unit>
        <trans-unit id="f1dbb4a5b057fd9d80b4085324de683535f1772c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IF NOT EXISTS&lt;/code&gt; is specified, it is not an error if the type already contains the new value: a notice is issued but no other action is taken. Otherwise, an error will occur if the new value is already present.</source>
          <target state="translated">場合 &lt;code&gt;IF NOT EXISTS&lt;/code&gt; が指定されているタイプは、すでに新しい値が含まれている場合、それはエラーではありません：通知が発行されますが、他のアクションは取られません。そうでない場合、新しい値がすでに存在しているとエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="713b84661234cdebeb4eb076bfe7612a7ddb758e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NO CYCLE&lt;/code&gt; is specified, any calls to &lt;code&gt;nextval&lt;/code&gt; after the sequence has reached its maximum value will return an error. If neither &lt;code&gt;CYCLE&lt;/code&gt; or &lt;code&gt;NO CYCLE&lt;/code&gt; are specified, &lt;code&gt;NO CYCLE&lt;/code&gt; is the default.</source>
          <target state="translated">&lt;code&gt;NO CYCLE&lt;/code&gt; が指定されている場合、シーケンスが最大値に達した後に &lt;code&gt;nextval&lt;/code&gt; を呼び出すと、エラーが返されます。 &lt;code&gt;CYCLE&lt;/code&gt; も &lt;code&gt;NO CYCLE&lt;/code&gt; も指定されていない場合、 &lt;code&gt;NO CYCLE&lt;/code&gt; がデフォルトです。</target>
        </trans-unit>
        <trans-unit id="6bbdf1bb14119659019986a40e06a497bd2493a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NULLS LAST&lt;/code&gt; is specified, null values sort after all non-null values; if &lt;code&gt;NULLS FIRST&lt;/code&gt; is specified, null values sort before all non-null values. If neither is specified, the default behavior is &lt;code&gt;NULLS LAST&lt;/code&gt; when &lt;code&gt;ASC&lt;/code&gt; is specified or implied, and &lt;code&gt;NULLS FIRST&lt;/code&gt; when &lt;code&gt;DESC&lt;/code&gt; is specified (thus, the default is to act as though nulls are larger than non-nulls). When &lt;code&gt;USING&lt;/code&gt; is specified, the default nulls ordering depends on whether the operator is a less-than or greater-than operator.</source>
          <target state="translated">&lt;code&gt;NULLS LAST&lt;/code&gt; が指定されている場合、NULL値はすべての非NULL値の後にソートされます。 &lt;code&gt;NULLS FIRST&lt;/code&gt; が指定されている場合、NULL値はすべての非NULL値の前にソートされます。どちらも指定されていない場合、デフォルトの動作は、 &lt;code&gt;ASC&lt;/code&gt; が指定または暗黙指定されている場合は &lt;code&gt;NULLS LAST&lt;/code&gt; 、 &lt;code&gt;DESC&lt;/code&gt; が指定されている場合は &lt;code&gt;NULLS FIRST&lt;/code&gt; です（したがって、デフォルトでは、NULLは非NULLよりも大きいかのように動作します）。ときに &lt;code&gt;USING&lt;/code&gt; 指定され、デフォルトのヌル順序は、オペレータが少なく、より以上、よりオペレータであるかどうかに依存します。</target>
        </trans-unit>
        <trans-unit id="8fb56e2e9f0f01bd1fdfbdbf89ac20f3bbcae1c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PARTITION OF&lt;/code&gt; clause is specified then the table is created as a partition of &lt;code&gt;parent_table&lt;/code&gt; with specified bounds.</source>
          <target state="translated">場合 &lt;code&gt;PARTITION OF&lt;/code&gt; 句が指定されたテーブルは、のパーティションとして作成さ &lt;code&gt;parent_table&lt;/code&gt; 指定境界を持ちます。</target>
        </trans-unit>
        <trans-unit id="c7ee0e44f6b6bd7b6f554d708cd5b901ba47c152" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PRIMARY KEY&lt;/code&gt; is specified, and the index's columns are not already marked &lt;code&gt;NOT NULL&lt;/code&gt;, then this command will attempt to do &lt;code&gt;ALTER COLUMN SET NOT NULL&lt;/code&gt; against each such column. That requires a full table scan to verify the column(s) contain no nulls. In all other cases, this is a fast operation.</source>
          <target state="translated">場合 &lt;code&gt;PRIMARY KEY&lt;/code&gt; が指定され、インデックスの列がすでにマークされていない &lt;code&gt;NOT NULL&lt;/code&gt; を、このコマンドは何しようとします &lt;code&gt;ALTER COLUMN SET NOT NULL&lt;/code&gt; を、そのような各列に対して。列にnullが含まれていないことを確認するには、テーブル全体をスキャンする必要があります。他のすべての場合では、これは高速な操作です。</target>
        </trans-unit>
        <trans-unit id="ae2eae0b6691115fff0baa447860d3557c71a926" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RECURSIVE&lt;/code&gt; is specified, it allows a &lt;code&gt;SELECT&lt;/code&gt; subquery to reference itself by name. Such a subquery must have the form</source>
          <target state="translated">場合は &lt;code&gt;RECURSIVE&lt;/code&gt; が指定され、それが可能に &lt;code&gt;SELECT&lt;/code&gt; サブクエリが名前で自身を参照すること。このようなサブクエリは次の形式でなければなりません</target>
        </trans-unit>
        <trans-unit id="5c5e50c2f4aff13823fb6c53c60eb5ef4318ca54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SELECT DISTINCT&lt;/code&gt; is specified, all duplicate rows are removed from the result set (one row is kept from each group of duplicates). &lt;code&gt;SELECT ALL&lt;/code&gt; specifies the opposite: all rows are kept; that is the default.</source>
          <target state="translated">&lt;code&gt;SELECT DISTINCT&lt;/code&gt; が指定されている場合、すべての重複行が結果セットから削除されます（重複グループごとに1行が保持されます）。 &lt;code&gt;SELECT ALL&lt;/code&gt; は逆を指定します。すべての行が保持されます。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="04b3f6938761ce362c4ded325b6abaf0a88a5df2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SET LOCAL&lt;/code&gt; is used within a function that has a &lt;code&gt;SET&lt;/code&gt; option for the same variable (see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;), the effects of the &lt;code&gt;SET LOCAL&lt;/code&gt; command disappear at function exit; that is, the value in effect when the function was called is restored anyway. This allows &lt;code&gt;SET LOCAL&lt;/code&gt; to be used for dynamic or repeated changes of a parameter within a function, while still having the convenience of using the &lt;code&gt;SET&lt;/code&gt; option to save and restore the caller's value. However, a regular &lt;code&gt;SET&lt;/code&gt; command overrides any surrounding function's &lt;code&gt;SET&lt;/code&gt; option; its effects will persist unless rolled back.</source>
          <target state="translated">同じ変数に対して &lt;code&gt;SET&lt;/code&gt; オプションを持つ関数内で &lt;code&gt;SET LOCAL&lt;/code&gt; が使用される場合（&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTIONを&lt;/a&gt;参照）、 &lt;code&gt;SET LOCAL&lt;/code&gt; コマンドの効果は関数の終了時に消えます。つまり、関数が呼び出されたときに有効だった値が復元されます。これにより、 &lt;code&gt;SET LOCAL&lt;/code&gt; を関数内のパラメーターの動的な変更または繰り返しの変更に使用でき、 &lt;code&gt;SET&lt;/code&gt; オプションを使用して呼び出し元の値を保存および復元することができます。ただし、通常の &lt;code&gt;SET&lt;/code&gt; コマンドは、周囲の関数の &lt;code&gt;SET&lt;/code&gt; オプションをオーバーライドします。ロールバックしない限り、その効果は持続します。</target>
        </trans-unit>
        <trans-unit id="ec901162256017a1ee3d75cc5aa3a5194df885bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SET TRANSACTION&lt;/code&gt; is executed without a prior &lt;code&gt;START TRANSACTION&lt;/code&gt; or &lt;code&gt;BEGIN&lt;/code&gt;, it emits a warning and otherwise has no effect.</source>
          <target state="translated">場合 &lt;code&gt;SET TRANSACTION&lt;/code&gt; 前なしで実行されている &lt;code&gt;START TRANSACTION&lt;/code&gt; または &lt;code&gt;BEGIN&lt;/code&gt; 、それは警告を発し、さもなければ影響を及ぼしません。</target>
        </trans-unit>
        <trans-unit id="c679999524623fe277800e4000b75170afd22ce0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SET&lt;/code&gt; (or equivalently &lt;code&gt;SET SESSION&lt;/code&gt;) is issued within a transaction that is later aborted, the effects of the &lt;code&gt;SET&lt;/code&gt; command disappear when the transaction is rolled back. Once the surrounding transaction is committed, the effects will persist until the end of the session, unless overridden by another &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;SET&lt;/code&gt; （または同等の &lt;code&gt;SET SESSION&lt;/code&gt; が）後に中止されたトランザクション内で発行された、の影響 &lt;code&gt;SET&lt;/code&gt; のトランザクションがロールバックされたときにコマンドが消えます。周囲のトランザクションがコミットされると、別の &lt;code&gt;SET&lt;/code&gt; によってオーバーライドされない限り、セッションの最後まで効果が持続します。</target>
        </trans-unit>
        <trans-unit id="9705e1f00e76813c6d22bc3d6eab56b5d6ef9cd2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITH ADMIN OPTION&lt;/code&gt; is specified, the member can in turn grant membership in the role to others, and revoke membership in the role as well. Without the admin option, ordinary users cannot do that. A role is not considered to hold &lt;code&gt;WITH ADMIN OPTION&lt;/code&gt; on itself, but it may grant or revoke membership in itself from a database session where the session user matches the role. Database superusers can grant or revoke membership in any role to anyone. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can grant or revoke membership in any role that is not a superuser.</source>
          <target state="translated">場合は &lt;code&gt;WITH ADMIN OPTION&lt;/code&gt; 指定され、役割のメンバー缶順番に付与他者へのロールのメンバーシップ、およびREVOKEの会員にも。 adminオプションがないと、通常のユーザーはそれを行うことができません。ロールはそれ自体で &lt;code&gt;WITH ADMIN OPTION&lt;/code&gt; を保持するとは見なされませんが、セッションユーザーがロールと一致するデータベースセッションからそれ自体のメンバーシップを付与または取り消す場合があります。データベースのスーパーユーザーは、任意のロールのメンバーシップを誰にでも付与または取り消すことができます。 &lt;code&gt;CREATEROLE&lt;/code&gt; 特権を持つ役割は、スーパーユーザーではない任意の役割のメンバーシップを付与または取り消すことができます。</target>
        </trans-unit>
        <trans-unit id="abd80886f4a2be834b3e10dda7c9db6fa997569b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITH GRANT OPTION&lt;/code&gt; is specified, the recipient of the privilege can in turn grant it to others. Without a grant option, the recipient cannot do that. Grant options cannot be granted to &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WITH GRANT OPTION&lt;/code&gt; が指定されている場合、特権の受信者は次にそれを他のユーザーに付与できます。付与オプションがないと、受信者はそれを行うことができません。付与オプションを &lt;code&gt;PUBLIC&lt;/code&gt; に付与することはできません。</target>
        </trans-unit>
        <trans-unit id="9373b178281613a72e6b020f7636dc488a5f1d3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITH HOLD&lt;/code&gt; is specified and the transaction that created the cursor successfully commits, the cursor can continue to be accessed by subsequent transactions in the same session. (But if the creating transaction is aborted, the cursor is removed.) A cursor created with &lt;code&gt;WITH HOLD&lt;/code&gt; is closed when an explicit &lt;code&gt;CLOSE&lt;/code&gt; command is issued on it, or the session ends. In the current implementation, the rows represented by a held cursor are copied into a temporary file or memory area so that they remain available for subsequent transactions.</source>
          <target state="translated">場合 &lt;code&gt;WITH HOLD&lt;/code&gt; 指定し、カーソルを作成したトランザクションが正常にコミットされ、カーソルが同じセッションで、後続のトランザクションによってアクセスし続けることができます。（ただし、作成中のトランザクションが中止されると、カーソルは削除されます。） &lt;code&gt;WITH HOLD&lt;/code&gt; で作成されたカーソルは、明示的な &lt;code&gt;CLOSE&lt;/code&gt; コマンドが発行されるか、セッションが終了すると閉じられます。現在の実装では、保持されたカーソルで表される行が一時ファイルまたはメモリ領域にコピーされ、後続のトランザクションで引き続き使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="d9dde45619a2d3c398745c13026f768d6b6b6cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;\d&lt;/code&gt; is used without a &lt;code&gt;pattern&lt;/code&gt; argument, it is equivalent to &lt;code&gt;\dtvmsE&lt;/code&gt; which will show a list of all visible tables, views, materialized views, sequences and foreign tables. This is purely a convenience measure.</source>
          <target state="translated">場合は &lt;code&gt;\d&lt;/code&gt; せずに使用されている &lt;code&gt;pattern&lt;/code&gt; 引数、それは同等です &lt;code&gt;\dtvmsE&lt;/code&gt; すべての可視テーブルの一覧が表示されますされ、ビューは、ビュー、シーケンス、外部テーブルをマテリアライズド。これは純粋に便利な手段です。</target>
        </trans-unit>
        <trans-unit id="99696408eca3e79444094829903879dfb2c22cfc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;\pset columns&lt;/code&gt; is zero, controls the width for the &lt;code&gt;wrapped&lt;/code&gt; format and width for determining if wide output requires the pager or should be switched to the vertical format in expanded auto mode.</source>
          <target state="translated">場合は &lt;code&gt;\pset columns&lt;/code&gt; ゼロである、のための幅を制御 &lt;code&gt;wrapped&lt;/code&gt; 広い出力がページャを必要とするか、または拡張され、オートモードでの垂直フォーマットに切り替えるべきかどうかを決定するためのフォーマットと幅を。</target>
        </trans-unit>
        <trans-unit id="65d8ff6e4bb927882e0081eeca2677185a93d180" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;archive_mode&lt;/code&gt; is set to &lt;code&gt;on&lt;/code&gt;, the archiver is not enabled during recovery or standby mode. If the standby server is promoted, it will start archiving after the promotion, but will not archive any WAL it did not generate itself. To get a complete series of WAL files in the archive, you must ensure that all WAL is archived, before it reaches the standby. This is inherently true with file-based log shipping, as the standby can only restore files that are found in the archive, but not if streaming replication is enabled. When a server is not in recovery mode, there is no difference between &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;always&lt;/code&gt; modes.</source>
          <target state="translated">場合 &lt;code&gt;archive_mode&lt;/code&gt; に設定されている &lt;code&gt;on&lt;/code&gt; 、アーカイバは、リカバリまたはスタンバイモード時に有効になっていません。スタンバイサーバーが昇格されると、昇格後にアーカイブが開始されますが、それ自体が生成しなかったWALはアーカイブされません。アーカイブ内の完全な一連のWALファイルを取得するには、スタンバイに到達する前に、すべてのWALがアーカイブされていることを確認する必要があります。スタンバイはアーカイブで見つかったファイルのみを復元でき、ストリーミングレプリケーションが有効な場合は復元できないため、これはファイルベースのログ配布に本質的に当てはまります。サーバーがリカバリモードでない場合、 &lt;code&gt;on&lt;/code&gt; モードと &lt;code&gt;always&lt;/code&gt; モードの間に違いはありません。</target>
        </trans-unit>
        <trans-unit id="4c5e023785c0eaf8158798154829baaec24284f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filename&lt;/code&gt; is &lt;code&gt;-&lt;/code&gt; (hyphen), then standard input is read until an EOF indication or &lt;code&gt;\q&lt;/code&gt; meta-command. This can be used to intersperse interactive input with input from files. Note however that Readline is not used in this case (much as if &lt;code&gt;-n&lt;/code&gt; had been specified).</source>
          <target state="translated">場合 &lt;code&gt;filename&lt;/code&gt; ある &lt;code&gt;-&lt;/code&gt; （ハイフン）、標準入力はEOF指示またはまで読み取られる &lt;code&gt;\q&lt;/code&gt; メタコマンド。これは、対話型入力とファイルからの入力を混在させるために使用できます。ただし、この場合、Readlineは使用されません（ &lt;code&gt;-n&lt;/code&gt; が指定されている場合と同様）。</target>
        </trans-unit>
        <trans-unit id="a4833473639ec21367a52ecaec9a765427862e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filename&lt;/code&gt; is &lt;code&gt;-&lt;/code&gt; (hyphen), then standard input is read until an EOF indication or &lt;code&gt;\q&lt;/code&gt; meta-command. This can be used to intersperse interactive input with input from files. Note that Readline behavior will be used only if it is active at the outermost level.</source>
          <target state="translated">場合 &lt;code&gt;filename&lt;/code&gt; ある &lt;code&gt;-&lt;/code&gt; （ハイフン）、標準入力はEOF指示またはまで読み取られる &lt;code&gt;\q&lt;/code&gt; メタコマンド。これは、対話型入力とファイルからの入力を混在させるために使用できます。Readlineの動作は、最も外側のレベルでアクティブな場合にのみ使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5d8bdbf29f6ea734e4384d8cec6971a567637c07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filename&lt;/code&gt; is specified, the file is edited; after the editor exits, the file's content is copied into the current query buffer. If no &lt;code&gt;filename&lt;/code&gt; is given, the current query buffer is copied to a temporary file which is then edited in the same fashion. Or, if the current query buffer is empty, the most recently executed query is copied to a temporary file and edited in the same fashion.</source>
          <target state="translated">場合は &lt;code&gt;filename&lt;/code&gt; 指定され、このファイルが編集されます。エディタが終了すると、ファイルのコンテンツが現在のクエリバッファにコピーされます。 &lt;code&gt;filename&lt;/code&gt; が指定されていない場合、現在のクエリバッファは一時ファイルにコピーされ、同じ方法で編集されます。または、現在のクエリバッファが空の場合、最後に実行されたクエリが一時ファイルにコピーされ、同じ方法で編集されます。</target>
        </trans-unit>
        <trans-unit id="87b5fa64a8f2d20fd3cdbf376e8372ac5be9682f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;frame_end&lt;/code&gt; is omitted it defaults to &lt;code&gt;CURRENT ROW&lt;/code&gt;. Restrictions are that &lt;code&gt;frame_start&lt;/code&gt; cannot be &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt;, &lt;code&gt;frame_end&lt;/code&gt; cannot be &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt;, and the &lt;code&gt;frame_end&lt;/code&gt; choice cannot appear earlier in the above list of &lt;code&gt;frame_start&lt;/code&gt; and &lt;code&gt;frame_end&lt;/code&gt; options than the &lt;code&gt;frame_start&lt;/code&gt; choice does &amp;mdash; for example &lt;code&gt;RANGE BETWEEN CURRENT ROW AND offset PRECEDING&lt;/code&gt; is not allowed.</source>
          <target state="translated">場合 &lt;code&gt;frame_end&lt;/code&gt; にデフォルトは省略されている &lt;code&gt;CURRENT ROW&lt;/code&gt; 。制限事項は、そのある &lt;code&gt;frame_start&lt;/code&gt; をすることはできません &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; 、 &lt;code&gt;frame_end&lt;/code&gt; することはできません &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; 、および &lt;code&gt;frame_end&lt;/code&gt; 選択は、上記のリストで先に表示することはできません &lt;code&gt;frame_start&lt;/code&gt; と &lt;code&gt;frame_end&lt;/code&gt; よりもオプション &lt;code&gt;frame_start&lt;/code&gt; の選択肢がありません-たとえばための &lt;code&gt;RANGE BETWEEN CURRENT ROW AND offset PRECEDING&lt;/code&gt; 許可されていません。</target>
        </trans-unit>
        <trans-unit id="c1493aafac52b8fb4240f760d7718dc0ee8aca4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;genbki.pl&lt;/code&gt; needs to assign an OID to a catalog entry that does not have a manually-assigned OID, it will use a value in the range 10000&amp;mdash;11999. The server's OID counter is set to 12000 at the start of a bootstrap run. Thus objects created by regular SQL commands during the later phases of bootstrap, such as objects created while running the &lt;code&gt;information_schema.sql&lt;/code&gt; script, receive OIDs of 12000 or above.</source>
          <target state="translated">&lt;code&gt;genbki.pl&lt;/code&gt; が、手動で割り当てられたOIDを持たないカタログエントリにOIDを割り当てる必要がある場合、10000〜11999の範囲の値を使用します。サーバーのOIDカウンターは、ブートストラップ実行の開始時に12000に設定されます。したがって、 &lt;code&gt;information_schema.sql&lt;/code&gt; スクリプトの実行中に作成されたオブジェクトなど、ブートストラップの後の段階で通常のSQLコマンドによって作成されたオブジェクトは、12000以上のOIDを受け取ります。</target>
        </trans-unit>
        <trans-unit id="e8c7103cc04741a131a5ac6b2ff588f135e3ddcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hot_standby&lt;/code&gt; is &lt;code&gt;on&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt; (the default value) and there is a &lt;code&gt;standby.signal&lt;/code&gt; file present, the server will run in Hot Standby mode. However, it may take some time for Hot Standby connections to be allowed, because the server will not accept connections until it has completed sufficient recovery to provide a consistent state against which queries can run. During this period, clients that attempt to connect will be refused with an error message. To confirm the server has come up, either loop trying to connect from the application, or look for these messages in the server logs:</source>
          <target state="translated">場合 &lt;code&gt;hot_standby&lt;/code&gt; がある &lt;code&gt;on&lt;/code&gt; で &lt;code&gt;postgresql.conf&lt;/code&gt; （デフォルト値）とがあり &lt;code&gt;standby.signal&lt;/code&gt; ファイル存在は、サーバがホットスタンバイモードで実行されます。ただし、サーバーは、クエリを実行できる一貫した状態を提供するための十分な回復が完了するまで接続を受け入れないため、ホットスタンバイ接続が許可されるまでに時間がかかる場合があります。この間、接続を試みるクライアントは拒否され、エラーメッセージが表示されます。サーバーが起動したことを確認するには、ループしてアプリケーションから接続しようとするか、サーバーログで次のメッセージを探します。</target>
        </trans-unit>
        <trans-unit id="2c8e31ec3780ebc59dc482c2ca3c59c045a41221" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in_range&lt;/code&gt; with &lt;code&gt;less&lt;/code&gt; = true is false for some &lt;code&gt;val1&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt;, it must be false for every &lt;code&gt;val2&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;code&gt;val1&lt;/code&gt; with the same &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;in_range&lt;/code&gt; と &lt;code&gt;less&lt;/code&gt; =真は、いくつかのために偽の &lt;code&gt;val1&lt;/code&gt; と &lt;code&gt;base&lt;/code&gt; 、それはすべてのために偽でなければならない &lt;code&gt;val2&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;code&gt;val1&lt;/code&gt; と同じで &lt;code&gt;base&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="332193353c52bde38e0eb3c661ad221eb1be8b6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in_range&lt;/code&gt; with &lt;code&gt;less&lt;/code&gt; = true is false for some &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;base1&lt;/code&gt;, it must be false for every &lt;code&gt;base2&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;base1&lt;/code&gt; with the same &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;in_range&lt;/code&gt; と &lt;code&gt;less&lt;/code&gt; =真は、いくつかのために偽の &lt;code&gt;val&lt;/code&gt; と &lt;code&gt;base1&lt;/code&gt; 、それはすべてのために偽でなければなりません &lt;code&gt;base2&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;base1&lt;/code&gt; 同じで &lt;code&gt;val&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="aa930e16baff55aa31e6852a2b74660f8ec3544e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in_range&lt;/code&gt; with &lt;code&gt;less&lt;/code&gt; = true is true for some &lt;code&gt;val1&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt;, it must be true for every &lt;code&gt;val2&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;val1&lt;/code&gt; with the same &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;in_range&lt;/code&gt; と &lt;code&gt;less&lt;/code&gt; =真は、いくつかのために真である &lt;code&gt;val1&lt;/code&gt; と &lt;code&gt;base&lt;/code&gt; 、それはすべてのために真でなければならない &lt;code&gt;val2&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;val1&lt;/code&gt; と同じで &lt;code&gt;base&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="342ab2a9a17f2fb194989decac130f65bf2a3ab2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in_range&lt;/code&gt; with &lt;code&gt;less&lt;/code&gt; = true is true for some &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;base1&lt;/code&gt;, it must be true for every &lt;code&gt;base2&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;code&gt;base1&lt;/code&gt; with the same &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;in_range&lt;/code&gt; と &lt;code&gt;less&lt;/code&gt; =真は、いくつかのために真である &lt;code&gt;val&lt;/code&gt; と &lt;code&gt;base1&lt;/code&gt; 、それはすべてのために真でなければなりません &lt;code&gt;base2&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;code&gt;base1&lt;/code&gt; 同じで &lt;code&gt;val&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="e3506d1e84d2320597dc89468fa4fbfef68d52af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pager_min_lines&lt;/code&gt; is set to a number greater than the page height, the pager program will not be called unless there are at least this many lines of output to show. The default setting is 0.</source>
          <target state="translated">&lt;code&gt;pager_min_lines&lt;/code&gt; がページの高さよりも大きい数値に設定されている場合、少なくとも表示する出力の行数がなければ、ページャープログラムは呼び出されません。デフォルト設定は0です。</target>
        </trans-unit>
        <trans-unit id="ad57f5bc57449c70be03f78cafa8198c7fecd4a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pattern&lt;/code&gt; does not contain percent signs or underscores, then the pattern only represents the string itself; in that case &lt;code&gt;LIKE&lt;/code&gt; acts like the equals operator. An underscore (&lt;code&gt;_&lt;/code&gt;) in &lt;code&gt;pattern&lt;/code&gt; stands for (matches) any single character; a percent sign (&lt;code&gt;%&lt;/code&gt;) matches any sequence of zero or more characters.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; パーセント記号またはアンダースコアが含まれていない場合、パターンは文字列自体を表すだけです。その場合、 &lt;code&gt;LIKE&lt;/code&gt; は等号演算子のように機能します。 &lt;code&gt;pattern&lt;/code&gt; の下線（ &lt;code&gt;_&lt;/code&gt; ）は、任意の1文字を表します（一致します）。パーセント記号（ &lt;code&gt;%&lt;/code&gt; ）は、ゼロ個以上の文字のシーケンスと一致します。</target>
        </trans-unit>
        <trans-unit id="929282dbe9432a59498fc7de54e9f120a0c23fde" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pg_resetwal&lt;/code&gt; complains that it cannot determine valid data for &lt;code&gt;pg_control&lt;/code&gt;, you can force it to proceed anyway by specifying the &lt;code&gt;-f&lt;/code&gt; (force) option. In this case plausible values will be substituted for the missing data. Most of the fields can be expected to match, but manual assistance might be needed for the next OID, next transaction ID and epoch, next multitransaction ID and offset, and WAL starting location fields. These fields can be set using the options discussed below. If you are not able to determine correct values for all these fields, &lt;code&gt;-f&lt;/code&gt; can still be used, but the recovered database must be treated with even more suspicion than usual: an immediate dump and reload is imperative. &lt;em&gt;Do not&lt;/em&gt; execute any data-modifying operations in the database before you dump, as any such action is likely to make the corruption worse.</source>
          <target state="translated">場合 &lt;code&gt;pg_resetwal&lt;/code&gt; は、それがために有効なデータを判別できないと文句を言い &lt;code&gt;pg_control&lt;/code&gt; の、あなたが指定して、とにかく続行することを強制することができ &lt;code&gt;-f&lt;/code&gt; （強制）オプションを選択します。この場合、欠落データの代わりにもっともらしい値が使用されます。ほとんどのフィールドは一致すると予想できますが、次のOID、次のトランザクションIDとエポック、次のマルチトランザクションIDとオフセット、およびWAL開始場所フィールドについては、手動による支援が必要になる場合があります。これらのフィールドは、以下で説明するオプションを使用して設定できます。これらすべてのフィールドの正しい値を決定できない場合でも、 &lt;code&gt;-f&lt;/code&gt; を使用できますが、リカバリされたデータベースは、通常よりもさらに疑いを持って処理する必要があります。即時のダンプとリロードが不可欠です。&lt;em&gt;しない&lt;/em&gt; ダンプする前にデータベースでデータ変更操作を実行してください。そのようなアクションは破損をさらに悪化させる可能性があるためです。</target>
        </trans-unit>
        <trans-unit id="f13d0730a2d7549daf41a4dfb84c03f31c4b1319" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pg_upgrade&lt;/code&gt; aborted before linking started, the old cluster was unmodified; it can be restarted.</source>
          <target state="translated">リンクが開始する前に &lt;code&gt;pg_upgrade&lt;/code&gt; が中止された場合、古いクラスターは変更されていません。再起動できます。</target>
        </trans-unit>
        <trans-unit id="e188ae9422c6dffedeb340ab362e8934b4b3e43d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prokind&lt;/code&gt; indicates that the entry is for an aggregate function, there should be a matching row in &lt;code&gt;pg_aggregate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;prokind&lt;/code&gt; がエントリが集約関数用であることを示している場合、pg_aggregateに一致する行がある &lt;code&gt;pg_aggregate&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="32186644a8227bc9629078cb6964f294409c3b69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;synchronous_standby_names&lt;/code&gt; is empty, the settings &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;remote_apply&lt;/code&gt;, &lt;code&gt;remote_write&lt;/code&gt; and &lt;code&gt;local&lt;/code&gt; all provide the same synchronization level: transaction commits only wait for local flush to disk.</source>
          <target state="translated">場合 &lt;code&gt;synchronous_standby_names&lt;/code&gt; が空である、設定 &lt;code&gt;on&lt;/code&gt; 、 &lt;code&gt;remote_apply&lt;/code&gt; 、 &lt;code&gt;remote_write&lt;/code&gt; と &lt;code&gt;local&lt;/code&gt; すべて同じ同期レベルを提供：トランザクションのコミットは、ディスクへのローカルのフラッシュを待ちます。</target>
        </trans-unit>
        <trans-unit id="e17b6ba8e8e554c6fa5ecad07078e794222b7865" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typarray&lt;/code&gt; is not 0 then it identifies another row in &lt;code&gt;pg_type&lt;/code&gt;, which is the &amp;ldquo;true&amp;rdquo; array type having this type as element</source>
          <target state="translated">&lt;code&gt;typarray&lt;/code&gt; が0でない場合は、 &lt;code&gt;pg_type&lt;/code&gt; の別の行を識別します。これは、この型を要素として持つ「真の」配列型です</target>
        </trans-unit>
        <trans-unit id="1643f010e11a8ec209a76b1daf0df11fad85a094" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typdefaultbin&lt;/code&gt; is not null, it is the &lt;code&gt;nodeToString()&lt;/code&gt; representation of a default expression for the type. This is only used for domains.</source>
          <target state="translated">&lt;code&gt;typdefaultbin&lt;/code&gt; がnullでない場合、それは型のデフォルト式の &lt;code&gt;nodeToString()&lt;/code&gt; 表現です。これはドメインにのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="a098d6d2d4ed82c302d8bd246178fb2399080947" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typelem&lt;/code&gt; is not 0 then it identifies another row in &lt;code&gt;pg_type&lt;/code&gt;. The current type can then be subscripted like an array yielding values of type &lt;code&gt;typelem&lt;/code&gt;. A &amp;ldquo;true&amp;rdquo; array type is variable length (&lt;code&gt;typlen&lt;/code&gt; = -1), but some fixed-length (&lt;code&gt;typlen&lt;/code&gt; &amp;gt; 0) types also have nonzero &lt;code&gt;typelem&lt;/code&gt;, for example &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;point&lt;/code&gt;. If a fixed-length type has a &lt;code&gt;typelem&lt;/code&gt; then its internal representation must be some number of values of the &lt;code&gt;typelem&lt;/code&gt; data type with no other data. Variable-length array types have a header defined by the array subroutines.</source>
          <target state="translated">&lt;code&gt;typelem&lt;/code&gt; が0でない場合、それは &lt;code&gt;pg_type&lt;/code&gt; の別の行を識別します。次に、現在の型に、 &lt;code&gt;typelem&lt;/code&gt; 型の値を生成する配列のように添え字を付けることができます。 「真の」配列型は可変長（ &lt;code&gt;typlen&lt;/code&gt; = -1）ですが、一部の固定長（ &lt;code&gt;typlen&lt;/code&gt; &amp;gt; 0）型も、 &lt;code&gt;name&lt;/code&gt; や &lt;code&gt;point&lt;/code&gt; などのゼロ以外の &lt;code&gt;typelem&lt;/code&gt; を持っています。固定長型が持っている場合 &lt;code&gt;typelem&lt;/code&gt; その内部表現は、値のいくつかの数でなければなら &lt;code&gt;typelem&lt;/code&gt; ない他のデータとデータタイプ。可変長配列型には、配列サブルーチンによって定義されたヘッダーがあります。</target>
        </trans-unit>
        <trans-unit id="962e01512a43e6b662e513b46b2720b8eda2c536" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is specified it must be either &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt; which will enable or disable display of a locale-specific character to separate groups of digits to the left of the decimal marker. If &lt;code&gt;value&lt;/code&gt; is omitted the command toggles between regular and locale-specific numeric output.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; を指定する場合、 &lt;code&gt;on&lt;/code&gt; または &lt;code&gt;off&lt;/code&gt; にする必要があります。これにより、ロケール固有の文字の表示を有効または無効にして、小数点の左側の桁のグループを区切ることができます。場合 &lt;code&gt;value&lt;/code&gt; 、通常とロケール固有の数値出力間のコマンドトグルを省略しています。</target>
        </trans-unit>
        <trans-unit id="0ac5be223120c8314531a02347c6041d7cd668b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is specified it must be either &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt; which will enable or disable display of the table footer (the &lt;code&gt;(n rows)&lt;/code&gt; count). If &lt;code&gt;value&lt;/code&gt; is omitted the command toggles footer display on or off.</source>
          <target state="translated">場合は &lt;code&gt;value&lt;/code&gt; 指定されている、それはどちらかでなければならない &lt;code&gt;on&lt;/code&gt; または &lt;code&gt;off&lt;/code&gt; テーブルフッタ（の表示を有効または無効になる &lt;code&gt;(n rows)&lt;/code&gt; カウントを）。 &lt;code&gt;value&lt;/code&gt; が省略されている場合、コマンドはフッター表示のオンとオフを切り替えます。</target>
        </trans-unit>
        <trans-unit id="5cba26a9c2b6ebc7647fabad9eea11f281ddf193" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is specified it must be either &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt; which will enable or disable tuples-only mode. If &lt;code&gt;value&lt;/code&gt; is omitted the command toggles between regular and tuples-only output. Regular output includes extra information such as column headers, titles, and various footers. In tuples-only mode, only actual table data is shown.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; を指定する場合は、タプルのみのモードを有効または無効にする &lt;code&gt;on&lt;/code&gt; または &lt;code&gt;off&lt;/code&gt; にする必要があります。場合 &lt;code&gt;value&lt;/code&gt; 通常のタプルのみの出力間のコマンドトグルを省略しています。通常の出力には、列ヘッダー、タイトル、さまざまなフッターなどの追加情報が含まれます。タプルのみのモードでは、実際のテーブルデータのみが表示されます。</target>
        </trans-unit>
        <trans-unit id="6fae09f9e5152eceff65217f721d75ba03342e63" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is specified it must be either &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt;, which will enable or disable expanded mode, or &lt;code&gt;auto&lt;/code&gt;. If &lt;code&gt;value&lt;/code&gt; is omitted the command toggles between the on and off settings. When expanded mode is enabled, query results are displayed in two columns, with the column name on the left and the data on the right. This mode is useful if the data wouldn't fit on the screen in the normal &amp;ldquo;horizontal&amp;rdquo; mode. In the auto setting, the expanded mode is used whenever the query output has more than one column and is wider than the screen; otherwise, the regular mode is used. The auto setting is only effective in the aligned and wrapped formats. In other formats, it always behaves as if the expanded mode is off.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; を指定する場合は、拡張モードを有効または無効にする &lt;code&gt;on&lt;/code&gt; または &lt;code&gt;off&lt;/code&gt; 、または &lt;code&gt;auto&lt;/code&gt; のいずれかでなければなりません。場合 &lt;code&gt;value&lt;/code&gt; オンとオフの設定の間のコマンドトグルを省略しています。拡張モードが有効になっている場合、クエリ結果は2つの列に表示され、左側に列名、右側にデータが表示されます。このモードは、データが通常の「水平」モードで画面に収まらない場合に役立ちます。自動設定では、クエリ出力に複数の列があり、画面よりも幅が広い場合は常に拡張モードが使用されます。それ以外の場合は、通常モードが使用されます。 auto設定は、整列およびラップされたフォーマットでのみ有効です。他のフォーマットでは、常に拡張モードがオフであるかのように動作します。</target>
        </trans-unit>
        <trans-unit id="ca01598c7c349232ee9c2f60f218cecf6c2e9b2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is supplied, only occurrences having one of those weights are counted.</source>
          <target state="translated">&lt;code&gt;weights&lt;/code&gt; が指定されている場合、それらの重みの1つを持つオカレンスのみがカウントされます。</target>
        </trans-unit>
        <trans-unit id="2dc5f92abbdc131542b5a63d7715ef7b5720a0a1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;&lt;code&gt;do_detoast&lt;/code&gt;&lt;/em&gt; is &lt;code&gt;true&lt;/code&gt;, attribute that will be detoasted as needed. Default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合&lt;em&gt; &lt;code&gt;do_detoast&lt;/code&gt; が&lt;/em&gt;ある &lt;code&gt;true&lt;/code&gt; 必要に応じて、属性detoastedされています。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="9855c6593bb788e4a7fc1baab60a566fbf901f03" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;&lt;code&gt;tableforest&lt;/code&gt;&lt;/em&gt; is false, then the resulting XML document looks like this:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;tableforest&lt;/code&gt; &lt;/em&gt;がfalseの場合、結果のXMLドキュメントは次のようになります。</target>
        </trans-unit>
        <trans-unit id="c50916d42c87228c370dd43c14046f7ce4402cc5" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;&lt;code&gt;tableforest&lt;/code&gt;&lt;/em&gt; is true, the result is an XML content fragment that looks like this:</source>
          <target state="translated">場合&lt;em&gt; &lt;code&gt;tableforest&lt;/code&gt; が&lt;/em&gt; trueの場合、結果は次のようになりますことをXMLコンテンツフラグメントであります：</target>
        </trans-unit>
        <trans-unit id="a00e85c8c38a440ad71ba2067ec654d399028aa3" translate="yes" xml:space="preserve">
          <source>If BC has been specified, negate the year and add one for internal storage. (There is no year zero in the Gregorian calendar, so numerically 1 BC becomes year zero.)</source>
          <target state="translated">BCが指定されている場合は、年を否定して内部記憶用に1を追加します(グレゴリオ暦には0年はないので、数値的には1BCが0年になります)。(グレゴリオ暦にはゼロ年はないので、数値的には1BCがゼロ年になります)</target>
        </trans-unit>
        <trans-unit id="2a6677efb7a76da9c59cedae433efda4935b91f1" translate="yes" xml:space="preserve">
          <source>If BC was not specified, and if the year field was two digits in length, then adjust the year to four digits. If the field is less than 70, then add 2000, otherwise add 1900.</source>
          <target state="translated">BCが指定されておらず、年のフィールドが2桁の場合は、年を4桁に調整します。フィールドが70未満の場合は2000を追加し、そうでない場合は1900を追加します。</target>
        </trans-unit>
        <trans-unit id="a9b50e5581cb9a085c462f20b706e74a8924f7f1" translate="yes" xml:space="preserve">
          <source>If CSV-format output is enabled in &lt;code&gt;log_destination&lt;/code&gt;, &lt;code&gt;.csv&lt;/code&gt; will be appended to the timestamped log file name to create the file name for CSV-format output. (If &lt;code&gt;log_filename&lt;/code&gt; ends in &lt;code&gt;.log&lt;/code&gt;, the suffix is replaced instead.)</source>
          <target state="translated">CSV形式の出力が &lt;code&gt;log_destination&lt;/code&gt; で有効になっている場合、タイムスタンプ付きのログファイル名に &lt;code&gt;.csv&lt;/code&gt; が追加され、CSV形式の出力用のファイル名が作成されます。（ &lt;code&gt;log_filename&lt;/code&gt; が &lt;code&gt;.log&lt;/code&gt; で終わっている場合、代わりにサフィックスが置き換えられます。）</target>
        </trans-unit>
        <trans-unit id="debbd30b66af886f3ad4a4846dc7b2ee2e468eb1" translate="yes" xml:space="preserve">
          <source>If LLVM has the required functionality, emit the data needed to allow perf to profile functions generated by JIT. This writes out files to &lt;code&gt;$HOME/.debug/jit/&lt;/code&gt;; the user is responsible for performing cleanup when desired. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">LLVMに必要な機能がある場合、perfがJITによって生成された関数をプロファイルできるようにするために必要なデータを発行します。これにより、ファイルが &lt;code&gt;$HOME/.debug/jit/&lt;/code&gt; れます。ユーザーは、必要に応じてクリーンアップを実行する必要があります。デフォルト設定は &lt;code&gt;off&lt;/code&gt; です。このパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="ef3c317e4d741dc71490a33136e9ff9dc5428c13" translate="yes" xml:space="preserve">
          <source>If LLVM has the required functionality, register generated functions with GDB. This makes debugging easier. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">LLVMに必要な機能がある場合は、生成された関数をGDBに登録します。これにより、デバッグが容易になります。デフォルト設定は &lt;code&gt;off&lt;/code&gt; です。このパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="efe3f3026039f58c4fe8aa03beba8ad31146f904" translate="yes" xml:space="preserve">
          <source>If OIDs are included in the file, the OID field immediately follows the field-count word. It is a normal field except that it's not included in the field-count. Note that oid system columns are not supported in current versions of PostgreSQL.</source>
          <target state="translated">ファイルにOIDが含まれている場合、OIDフィールドはフィールドカウントの単語の直後に続きます。これは、フィールドカウントに含まれないことを除いて、通常のフィールドです。oidシステムカラムは現在のバージョンのPostgreSQLではサポートされていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="8e65f986646d4bd64aa08e3d223eb8fd14aab146" translate="yes" xml:space="preserve">
          <source>If PAM is set up to read &lt;code&gt;/etc/shadow&lt;/code&gt;, authentication will fail because the PostgreSQL server is started by a non-root user. However, this is not an issue when PAM is configured to use LDAP or other authentication methods.</source>
          <target state="translated">PAMが &lt;code&gt;/etc/shadow&lt;/code&gt; を読み取るように設定されている場合、PostgreSQLサーバーは非rootユーザーによって起動されるため、認証は失敗します。ただし、PAMがLDAPまたはその他の認証方法を使用するように構成されている場合、これは問題ではありません。</target>
        </trans-unit>
        <trans-unit id="415ce588e29ad070811b2db4490099f305d07266" translate="yes" xml:space="preserve">
          <source>If PostgreSQL itself is the cause of the system running out of memory, you can avoid the problem by changing your configuration. In some cases, it may help to lower memory-related configuration parameters, particularly &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;&lt;code&gt;shared_buffers&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;&lt;code&gt;work_mem&lt;/code&gt;&lt;/a&gt;. In other cases, the problem may be caused by allowing too many connections to the database server itself. In many cases, it may be better to reduce &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;&lt;code&gt;max_connections&lt;/code&gt;&lt;/a&gt; and instead make use of external connection-pooling software.</source>
          <target state="translated">PostgreSQL自体がシステムのメモリ不足の原因である場合は、構成を変更することで問題を回避できます。場合によっては、メモリ関連の構成パラメータ、特に&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt; &lt;code&gt;shared_buffers&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt; &lt;code&gt;work_mem&lt;/code&gt; を&lt;/a&gt;下げると役立つことがあります。他の場合では、データベースサーバー自体への接続が多すぎることが問題の原因である可能性があります。多くの場合、&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt; &lt;code&gt;max_connections&lt;/code&gt; &lt;/a&gt;を減らして、代わりに外部接続プーリングソフトウェアを使用する方が良い場合があります。</target>
        </trans-unit>
        <trans-unit id="ce5c2e1e6b44cb1c8622c0c5ffed0c31ab912017" translate="yes" xml:space="preserve">
          <source>If PostgreSQL was compiled with OpenLDAP as the LDAP client library, the &lt;code&gt;ldapserver&lt;/code&gt; setting may be omitted. In that case, a list of host names and ports is looked up via RFC 2782 DNS SRV records. The name &lt;code&gt;_ldap._tcp.DOMAIN&lt;/code&gt; is looked up, where &lt;code&gt;DOMAIN&lt;/code&gt; is extracted from &lt;code&gt;ldapbasedn&lt;/code&gt;.</source>
          <target state="translated">PostgreSQLがLDAPクライアントライブラリとしてOpenLDAPを使用してコンパイルされている場合、 &lt;code&gt;ldapserver&lt;/code&gt; 設定は省略できます。その場合、ホスト名とポートのリストはRFC 2782 DNS SRVレコードを介して検索されます。名前 &lt;code&gt;_ldap._tcp.DOMAIN&lt;/code&gt; が検索され、 &lt;code&gt;DOMAIN&lt;/code&gt; は &lt;code&gt;ldapbasedn&lt;/code&gt; から抽出されます。</target>
        </trans-unit>
        <trans-unit id="f92e62044fa208f984d06131f910dfb1c21e1338" translate="yes" xml:space="preserve">
          <source>If SELinux is disabled or not installed, you must set that product up first before installing this module.</source>
          <target state="translated">SELinux が無効になっているか、インストールされていない場合は、このモジュールをインストールする前に、その製品を最初にセットアップする必要があります。</target>
        </trans-unit>
        <trans-unit id="a9341d807a078bf8721a956d7df4d8eca09e01a0" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; command is executed while a base backup is being taken, and then the template database that the &lt;code&gt;CREATE DATABASE&lt;/code&gt; copied is modified while the base backup is still in progress, it is possible that recovery will cause those modifications to be propagated into the created database as well. This is of course undesirable. To avoid this risk, it is best not to modify any template databases while taking a base backup.</source>
          <target state="translated">場合は&lt;a href=&quot;sql-createdatabase&quot;&gt;、CREATE DATABASEの&lt;/a&gt;コマンドが実行されるベースのバックアップが取られているし、そのテンプレートデータベースながら &lt;code&gt;CREATE DATABASE&lt;/code&gt; ベースバックアップの進行中に変更されたコピーは、回復は、これらの変更はに伝播させることになる可能性がありますデータベースも作成しました。これはもちろん望ましくありません。このリスクを回避するために、ベースバックアップの実行中にテンプレートデータベースを変更しないことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="fa1de3a6861be1ec1b6ec90aa7e6b3e06531f1df" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DROP&lt;/code&gt; command lists multiple objects, &lt;code&gt;CASCADE&lt;/code&gt; is only required when there are dependencies outside the specified group. For example, when saying &lt;code&gt;DROP TABLE tab1, tab2&lt;/code&gt; the existence of a foreign key referencing &lt;code&gt;tab1&lt;/code&gt; from &lt;code&gt;tab2&lt;/code&gt; would not mean that &lt;code&gt;CASCADE&lt;/code&gt; is needed to succeed.</source>
          <target state="translated">場合は &lt;code&gt;DROP&lt;/code&gt; のコマンドリスト、複数のオブジェクト、 &lt;code&gt;CASCADE&lt;/code&gt; が指定されたグループ外の依存関係が存在する場合にのみ必要です。言ったときにたとえば、 &lt;code&gt;DROP TABLE tab1, tab2&lt;/code&gt; 参照する外部キーの存在 &lt;code&gt;tab1&lt;/code&gt; のをから &lt;code&gt;tab2&lt;/code&gt; という意味ではないだろう &lt;code&gt;CASCADE&lt;/code&gt; が成功するために必要とされています。</target>
        </trans-unit>
        <trans-unit id="92e1a30bd1d3658160c72094059d0371a401f9cd" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SET&lt;/code&gt; clause is attached to a function, then the effects of a &lt;code&gt;SET LOCAL&lt;/code&gt; command executed inside the function for the same variable are restricted to the function: the configuration parameter's prior value is still restored at function exit. However, an ordinary &lt;code&gt;SET&lt;/code&gt; command (without &lt;code&gt;LOCAL&lt;/code&gt;) overrides the &lt;code&gt;SET&lt;/code&gt; clause, much as it would do for a previous &lt;code&gt;SET LOCAL&lt;/code&gt; command: the effects of such a command will persist after function exit, unless the current transaction is rolled back.</source>
          <target state="translated">場合 &lt;code&gt;SET&lt;/code&gt; 句は機能に装着され、その後の効果 &lt;code&gt;SET LOCAL&lt;/code&gt; を同じ変数の関数の内部で実行したコマンドは、機能に制限されています：構成パラメータの前の値がまだ機能出口で復元されます。ただし、通常の &lt;code&gt;SET&lt;/code&gt; コマンド（ &lt;code&gt;LOCAL&lt;/code&gt; なし）は、以前の &lt;code&gt;SET LOCAL&lt;/code&gt; コマンドの場合と同様に、 &lt;code&gt;SET&lt;/code&gt; 句をオーバーライドします。このようなコマンドの影響は、現在のトランザクションがロールバックされない限り、関数の終了後も保持されます。</target>
        </trans-unit>
        <trans-unit id="9c0a79a4075f581261c7fcce27f70643bea75e21" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SET&lt;/code&gt; clause is attached to a procedure, then that procedure cannot execute transaction control statements (for example, &lt;code&gt;COMMIT&lt;/code&gt; and &lt;code&gt;ROLLBACK&lt;/code&gt;, depending on the language).</source>
          <target state="translated">場合 &lt;code&gt;SET&lt;/code&gt; の句が手順に取り付けられ、このプロシージャはトランザクション制御ステートメントを実行することができない（例えば、 &lt;code&gt;COMMIT&lt;/code&gt; と &lt;code&gt;ROLLBACK&lt;/code&gt; 、言語に依存します）。</target>
        </trans-unit>
        <trans-unit id="f0bddcb97ee43256f36e19dc04e898959e413d86" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SET&lt;/code&gt; clause is attached to a procedure, then the effects of a &lt;code&gt;SET LOCAL&lt;/code&gt; command executed inside the procedure for the same variable are restricted to the procedure: the configuration parameter's prior value is still restored at procedure exit. However, an ordinary &lt;code&gt;SET&lt;/code&gt; command (without &lt;code&gt;LOCAL&lt;/code&gt;) overrides the &lt;code&gt;SET&lt;/code&gt; clause, much as it would do for a previous &lt;code&gt;SET LOCAL&lt;/code&gt; command: the effects of such a command will persist after procedure exit, unless the current transaction is rolled back.</source>
          <target state="translated">場合 &lt;code&gt;SET&lt;/code&gt; 句が手続きに装着され、その後の影響 &lt;code&gt;SET LOCAL&lt;/code&gt; 同じ変数のための手順内部で実行したコマンドは、プロシージャに制限されている：設定パラメータの前の値は、まだ手続きの出口で復元されます。ただし、通常の &lt;code&gt;SET&lt;/code&gt; コマンド（ &lt;code&gt;LOCAL&lt;/code&gt; なし）は、以前の &lt;code&gt;SET LOCAL&lt;/code&gt; コマンドの場合と同様に、 &lt;code&gt;SET&lt;/code&gt; 句をオーバーライドします。このようなコマンドの影響は、現在のトランザクションがロールバックされない限り、プロシージャの終了後も保持されます。</target>
        </trans-unit>
        <trans-unit id="dc2402d507bf01ad0609465ee16a38cc42b24afe" translate="yes" xml:space="preserve">
          <source>If a check constraint, an internal representation of the expression. (It's recommended to use &lt;code&gt;pg_get_constraintdef()&lt;/code&gt; to extract the definition of a check constraint.)</source>
          <target state="translated">チェック制約の場合、式の内部表現。（チェック制約の定義を抽出するには、 &lt;code&gt;pg_get_constraintdef()&lt;/code&gt; を使用することをお勧めします。）</target>
        </trans-unit>
        <trans-unit id="f25b711856ae449f9c3d73dd4473185e384f4706" translate="yes" xml:space="preserve">
          <source>If a column in the parent table is an identity column, that property is not inherited. A column in the child table can be declared identity column if desired.</source>
          <target state="translated">親テーブルのカラムが ID カラムである場合、そのプロパティは継承されません。必要に応じて、子テーブルの列を ID 列として宣言することができます。</target>
        </trans-unit>
        <trans-unit id="c8c03e9dff51a371ecb3dbf0f3542cbc1ae0bd39" translate="yes" xml:space="preserve">
          <source>If a column list is specified, you only need &lt;code&gt;INSERT&lt;/code&gt; privilege on the listed columns. Similarly, when &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; is specified, you only need &lt;code&gt;UPDATE&lt;/code&gt; privilege on the column(s) that are listed to be updated. However, &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; also requires &lt;code&gt;SELECT&lt;/code&gt; privilege on any column whose values are read in the &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; expressions or &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">列リストが指定されている場合は、リストされた列に対する &lt;code&gt;INSERT&lt;/code&gt; 特権のみが必要です。同様に、 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; が指定されている場合は、更新対象としてリストされている列に対する &lt;code&gt;UPDATE&lt;/code&gt; 特権のみが必要です。ただし、 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; には、 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 式または &lt;code&gt;condition&lt;/code&gt; で値が読み取られる列に対する &lt;code&gt;SELECT&lt;/code&gt; 権限も必要です。</target>
        </trans-unit>
        <trans-unit id="6ae12c756d83d3fa84f0842896261c6e6de98fbd" translate="yes" xml:space="preserve">
          <source>If a column result is NULL, the corresponding variable is unset rather than being set.</source>
          <target state="translated">カラムの結果がNULLの場合、対応する変数はセットされるのではなくアンセットされます。</target>
        </trans-unit>
        <trans-unit id="cd07d38bba484cac13838ebc8d7dd08509069d67" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-XML value (limited to string, boolean, or double in XPath 1.0) and the column has a PostgreSQL type other than &lt;code&gt;xml&lt;/code&gt;, the column will be set as if by assigning the value's string representation to the PostgreSQL type. (If the value is a boolean, its string representation is taken to be &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; if the output column's type category is numeric, otherwise &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.)</source>
          <target state="translated">列のXPath式が非XML値（XPath 1.0では文字列、ブール値、またはdoubleに制限されている）を返し、列が &lt;code&gt;xml&lt;/code&gt; 以外のPostgreSQLタイプを持っている場合、列は値の文字列表現をPostgreSQLタイプ。（値がブール値の場合、出力列のタイプカテゴリが数値の場合、その文字列表現は &lt;code&gt;1&lt;/code&gt; または &lt;code&gt;0&lt;/code&gt; であると見なされ、それ以外の場合は &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; になります。）</target>
        </trans-unit>
        <trans-unit id="dd49d82e6f7364358b7e1308125e6548ff45efeb" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-empty set of XML nodes and the column's PostgreSQL type is &lt;code&gt;xml&lt;/code&gt;, the column will be assigned the expression result exactly, if it is of document or content form. &lt;a href=&quot;#ftn.id-1.5.8.19.7.5.14.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.19.7.5.14.2&quot;&gt;[8]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">列のXPath式が空ではないXMLノードのセットを返し、列のPostgreSQLタイプが &lt;code&gt;xml&lt;/code&gt; である場合、それがドキュメント形式またはコンテンツ形式の場合、列には式の結果が正確に割り当てられます。&lt;a href=&quot;#ftn.id-1.5.8.19.7.5.14.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.19.7.5.14.2&quot;&gt;[8]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2001ae15ca417e0e9b4706925c6ddabecd8102f7" translate="yes" xml:space="preserve">
          <source>If a conflicting row has been inserted by an as-yet-uncommitted transaction, the would-be inserter must wait to see if that transaction commits. If it rolls back then there is no conflict. If it commits without deleting the conflicting row again, there is a uniqueness violation. (In practice we just wait for the other transaction to end and then redo the visibility check in toto.)</source>
          <target state="translated">まだコミットされていないトランザクションによって競合する行が挿入された場合、そのトランザクションがコミットするかどうかを確認するために、挿入予定のサータは待たなければなりません。もしそれがロールバックした場合、競合はありません。もし、競合している行を再び削除せずにコミットした場合は、一意性の違反となります。(実際には、他のトランザクションが終了するのを待ってから、全体の可視性チェックをやり直します)。</target>
        </trans-unit>
        <trans-unit id="25c5a233f983a5a11d2f0ce26b28af3fbae3c56b" translate="yes" xml:space="preserve">
          <source>If a conflicting valid row has been deleted by the current transaction, it's okay. (In particular, since an UPDATE always deletes the old row version before inserting the new version, this will allow an UPDATE on a row without changing the key.)</source>
          <target state="translated">競合する有効な行が現在のトランザクションによって削除されていても問題ありません(特に、UPDATEは常に新しいバージョンを挿入する前に古い行のバージョンを削除するので、これによりキーを変更せずに行のUPDATEを行うことができます)。</target>
        </trans-unit>
        <trans-unit id="2370b745676126171b063e2e2d72095b349175fc" translate="yes" xml:space="preserve">
          <source>If a constraint is deferrable, this clause specifies the default time to check the constraint. If the constraint is &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt;, it is checked after each statement. This is the default. If the constraint is &lt;code&gt;INITIALLY DEFERRED&lt;/code&gt;, it is checked only at the end of the transaction. The constraint check time can be altered with the &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt; command.</source>
          <target state="translated">制約が延期可能な場合、この句は制約をチェックするデフォルトの時間を指定します。制約が &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt; の場合、各ステートメントの後でチェックされます。これがデフォルトです。制約が &lt;code&gt;INITIALLY DEFERRED&lt;/code&gt; の場合、トランザクションの終了時にのみチェックされます。制約チェック時間は、&lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt;コマンドで変更できます。</target>
        </trans-unit>
        <trans-unit id="45ddd1496c9c8970f749841790d5cc33a1ed958c" translate="yes" xml:space="preserve">
          <source>If a constraint name is provided then the index will be renamed to match the constraint name. Otherwise the constraint will be named the same as the index.</source>
          <target state="translated">制約名が指定された場合、インデックスは制約名と一致するように名前が変更されます。それ以外の場合は、制約はインデックスと同じ名前になります。</target>
        </trans-unit>
        <trans-unit id="516a948273fe630c2fd2d3bb4954b014ec3a728f" translate="yes" xml:space="preserve">
          <source>If a cursor is closed after a savepoint which is later rolled back, the &lt;code&gt;CLOSE&lt;/code&gt; is not rolled back; that is, the cursor remains closed.</source>
          <target state="translated">後でロールバックされるセーブポイントの後でカーソルが閉じられた場合、 &lt;code&gt;CLOSE&lt;/code&gt; はロールバックされません。つまり、カーソルは閉じたままです。</target>
        </trans-unit>
        <trans-unit id="0b8ad01bd9eefe5ae6504ee533b29e5940a9bbcc" translate="yes" xml:space="preserve">
          <source>If a different escape character than backslash is desired, it can be specified using the &lt;code&gt;UESCAPE&lt;/code&gt; clause after the string, for example:</source>
          <target state="translated">バックスラッシュとは異なるエスケープ文字が必要な場合は、文字列の後に &lt;code&gt;UESCAPE&lt;/code&gt; 句を使用して指定できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="8c0e309df60d6b04409ae8154560e144f149154e" translate="yes" xml:space="preserve">
          <source>If a dynamically loadable module needs to be opened and the file name specified in the &lt;code&gt;CREATE FUNCTION&lt;/code&gt; or &lt;code&gt;LOAD&lt;/code&gt; command does not have a directory component (i.e., the name does not contain a slash), the system will search this path for the required file.</source>
          <target state="translated">動的にロード可能なモジュールを開く必要があり、 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; または &lt;code&gt;LOAD&lt;/code&gt; コマンドで指定されたファイル名にディレクトリコンポーネントがない場合（つまり、名前にスラッシュが含まれていない場合）、システムはこのパスで必要なファイルを検索します。</target>
        </trans-unit>
        <trans-unit id="eead72d18dc8bb550762010fb49abdc92926fc22" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the equality operators for FK = FK comparisons</source>
          <target state="translated">外部キーの場合、FK=FK比較のための等値演算子のリスト</target>
        </trans-unit>
        <trans-unit id="f2557ac45b6d34f20af024d349a08e662002e006" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the equality operators for PK = FK comparisons</source>
          <target state="translated">外部キーの場合、PK=FK比較のための等質演算子のリスト</target>
        </trans-unit>
        <trans-unit id="65b7a7238de39c08afb78813e4651af5cc557847" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the equality operators for PK = PK comparisons</source>
          <target state="translated">外部キーの場合、PK=PK 比較のための等質演算子のリスト</target>
        </trans-unit>
        <trans-unit id="84b58f81bb95714e62ab14756a76120d62320f41" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the referenced columns</source>
          <target state="translated">外部キーの場合、参照される列のリスト</target>
        </trans-unit>
        <trans-unit id="7870e560cb55fb3708abcfcfa26fc2aa507576ee" translate="yes" xml:space="preserve">
          <source>If a foreign key, the referenced table; else 0</source>
          <target state="translated">外部キーの場合は、参照されているテーブル。</target>
        </trans-unit>
        <trans-unit id="302fc67ef061c10f65906072775cc6ba157a3bf8" translate="yes" xml:space="preserve">
          <source>If a fractional value is specified with a unit, it will be rounded to a multiple of the next smaller unit if there is one. For example, &lt;code&gt;30.1 GB&lt;/code&gt; will be converted to &lt;code&gt;30822 MB&lt;/code&gt; not &lt;code&gt;32319628902 B&lt;/code&gt;. If the parameter is of integer type, a final rounding to integer occurs after any units conversion.</source>
          <target state="translated">小数の値が単位で指定されている場合、小さければ、次に小さい単位の倍数に丸められます。たとえば、 &lt;code&gt;30.1 GB&lt;/code&gt; は &lt;code&gt;32319628902 B&lt;/code&gt; ではなく30822 &lt;code&gt;30822 MB&lt;/code&gt; 変換されます。パラメータが整数型の場合、整数への最終的な丸めは、単位変換後に行われます。</target>
        </trans-unit>
        <trans-unit id="16517351d5f6d1324d494a56b7cbc1349aadbd26" translate="yes" xml:space="preserve">
          <source>If a function executed within a parallel worker acquires locks which are not held by the leader, for example by querying a table not referenced in the query, those locks will be released at worker exit, not end of transaction. If you write a function which does this, and this behavior difference is important to you, mark such functions as &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; to ensure that they execute only in the leader.</source>
          <target state="translated">クエリで参照されていないテーブルをクエリするなどして、並列ワーカー内で実行される関数がリーダーによって保持されていないロックを取得した場合、それらのロックはトランザクションの終了ではなく、ワーカー出口で解放されます。これを実行する関数を作成し、この動作の違いが重要な場合は、そのような関数を &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; としてマークし、リーダーでのみ実行されるようにします。</target>
        </trans-unit>
        <trans-unit id="c08af80c4ec0b88bc818f2eba0deaa5cfe1fa698" translate="yes" xml:space="preserve">
          <source>If a function is declared &lt;code&gt;STRICT&lt;/code&gt; with a &lt;code&gt;VARIADIC&lt;/code&gt; argument, the strictness check tests that the variadic array &lt;em&gt;as a whole&lt;/em&gt; is non-null. The function will still be called if the array has null elements.</source>
          <target state="translated">関数が &lt;code&gt;VARIADIC&lt;/code&gt; 引数を &lt;code&gt;STRICT&lt;/code&gt; してSTRICTと宣言されている場合、厳密性チェックは、可変個配列&lt;em&gt;全体&lt;/em&gt;がnullでないことをテストします。配列にnull要素がある場合でも、関数は呼び出されます。</target>
        </trans-unit>
        <trans-unit id="3d9a8948caa2988125e4b727f3b2df8159e037f5" translate="yes" xml:space="preserve">
          <source>If a function is declared with a &lt;code&gt;VARIADIC&lt;/code&gt; array parameter, and the call does not use the &lt;code&gt;VARIADIC&lt;/code&gt; keyword, then the function is treated as if the array parameter were replaced by one or more occurrences of its element type, as needed to match the call. After such expansion the function might have effective argument types identical to some non-variadic function. In that case the function appearing earlier in the search path is used, or if the two functions are in the same schema, the non-variadic one is preferred.</source>
          <target state="translated">関数が &lt;code&gt;VARIADIC&lt;/code&gt; 配列パラメーターで宣言されており、呼び出しが &lt;code&gt;VARIADIC&lt;/code&gt; キーワードを使用していない場合、関数は、呼び出しに一致するように、必要に応じて、配列パラメーターがそのエレメントタイプの1つ以上のオカレンスで置き換えられたものとして扱われます。そのような拡張の後、関数はいくつかの非可変関数と同じ有効な引数型を持つかもしれません。その場合、検索パスの前にある関数が使用されます。または、2つの関数が同じスキーマにある場合は、非可変関数が優先されます。</target>
        </trans-unit>
        <trans-unit id="29873e6b07ca3d965e9bf60280fc04e4b50e061e" translate="yes" xml:space="preserve">
          <source>If a generic plan is in use, it will contain parameter symbols &lt;code&gt;$n&lt;/code&gt;, while a custom plan will have the supplied parameter values substituted into it.</source>
          <target state="translated">汎用プランが使用されている場合、それにはパラメーターシンボル &lt;code&gt;$n&lt;/code&gt; が含まれますが、カスタムプランには提供されたパラメーター値が代入されます。</target>
        </trans-unit>
        <trans-unit id="b9eddb833bc9b9e1959393e089ee3b45e63b93cb" translate="yes" xml:space="preserve">
          <source>If a host name is specified (anything that is not an IP address range or a special key word is treated as a host name), that name is compared with the result of a reverse name resolution of the client's IP address (e.g., reverse DNS lookup, if DNS is used). Host name comparisons are case insensitive. If there is a match, then a forward name resolution (e.g., forward DNS lookup) is performed on the host name to check whether any of the addresses it resolves to are equal to the client's IP address. If both directions match, then the entry is considered to match. (The host name that is used in &lt;code&gt;pg_hba.conf&lt;/code&gt; should be the one that address-to-name resolution of the client's IP address returns, otherwise the line won't be matched. Some host name databases allow associating an IP address with multiple host names, but the operating system will only return one host name when asked to resolve an IP address.)</source>
          <target state="translated">ホスト名が指定されている場合（IPアドレスの範囲または特別なキーワードではないものはすべてホスト名として扱われます）、その名前はクライアントのIPアドレスの逆名前解決の結果（たとえば、逆DNS）と比較されます。 DNSが使用されている場合、ルックアップ）。ホスト名の比較では、大文字と小文字は区別されません。一致する場合、ホスト名に対して前方名前解決（DNSの前方参照など）が実行され、解決されるアドレスのいずれかがクライアントのIPアドレスと等しいかどうかが確認されます。両方向が一致する場合、エントリは一致すると見なされます。 （ &lt;code&gt;pg_hba.conf&lt;/code&gt; で使用されるホスト名クライアントのIPアドレスのアドレスから名前への解決が返すものである必要があります。そうでない場合、行は一致しません。一部のホスト名データベースでは、IPアドレスを複数のホスト名に関連付けることができますが、オペレーティングシステムは、IPアドレスの解決を要求されたときに1つのホスト名のみを返します。</target>
        </trans-unit>
        <trans-unit id="29821b670fa593b8c5ed4db6b848a4180ea0c1c3" translate="yes" xml:space="preserve">
          <source>If a limit count is given, no more than that many rows will be returned (but possibly fewer, if the query itself yields fewer rows). &lt;code&gt;LIMIT ALL&lt;/code&gt; is the same as omitting the &lt;code&gt;LIMIT&lt;/code&gt; clause, as is &lt;code&gt;LIMIT&lt;/code&gt; with a NULL argument.</source>
          <target state="translated">制限カウントが指定されている場合、返される行数はその数にすぎません（ただし、クエリ自体が生成する行数が少ない場合は、それよりも少ない可能性があります）。 &lt;code&gt;LIMIT ALL&lt;/code&gt; は、NULL引数を持つ &lt;code&gt;LIMIT&lt;/code&gt; と同様に、 &lt;code&gt;LIMIT&lt;/code&gt; 句を省略した場合と同じです。</target>
        </trans-unit>
        <trans-unit id="2e0f012a9c847bea5735587a0a262fd8fc04fc30" translate="yes" xml:space="preserve">
          <source>If a line number is specified, psql will position the cursor on the specified line of the file or query buffer. Note that if a single all-digits argument is given, psql assumes it is a line number, not a file name.</source>
          <target state="translated">行番号が指定された場合、psqlはファイルまたはクエリバッファの指定された行にカーソルを配置します。1つの全桁の引数が与えられた場合、psqlはそれがファイル名ではなく行番号であると仮定することに注意してください。</target>
        </trans-unit>
        <trans-unit id="989ad942cdac74f48ff0f663910b668e0bfcd851" translate="yes" xml:space="preserve">
          <source>If a line number is specified, psql will position the cursor on the specified line of the function body. (Note that the function body typically does not begin on the first line of the file.)</source>
          <target state="translated">行番号が指定された場合、psqlは関数本体の指定された行にカーソルを配置します。(通常、関数本体はファイルの最初の行からは開始しないことに注意してください)。</target>
        </trans-unit>
        <trans-unit id="f28240e112ab05b43febc5915be398cc2c0ace7d" translate="yes" xml:space="preserve">
          <source>If a line number is specified, psql will position the cursor on the specified line of the view definition.</source>
          <target state="translated">行番号が指定された場合、psqlはビュー定義の指定された行にカーソルを配置します。</target>
        </trans-unit>
        <trans-unit id="e1603d0c375b802bfd8ff93da28473ffff6f9ce0" translate="yes" xml:space="preserve">
          <source>If a list of columns is specified, &lt;code&gt;COPY&lt;/code&gt; will only copy the data in the specified columns to or from the file. If there are any columns in the table that are not in the column list, &lt;code&gt;COPY FROM&lt;/code&gt; will insert the default values for those columns.</source>
          <target state="translated">列のリストが指定されている場合、 &lt;code&gt;COPY&lt;/code&gt; は指定された列のデータのみをファイルとの間でコピーします。列リストにない列がテーブルにある場合、 &lt;code&gt;COPY FROM&lt;/code&gt; はそれらの列のデフォルト値を挿入します。</target>
        </trans-unit>
        <trans-unit id="5d76d1bc7bed56c879e14e369962729e0bb7fe98" translate="yes" xml:space="preserve">
          <source>If a new child node must be added, set &lt;code&gt;resultType&lt;/code&gt; to &lt;code&gt;spgAddNode&lt;/code&gt;. Set &lt;code&gt;nodeLabel&lt;/code&gt; to the label to be used for the new node, and set &lt;code&gt;nodeN&lt;/code&gt; to the index (from zero) at which to insert the node in the node array. After the node has been added, the &lt;code&gt;choose&lt;/code&gt; function will be called again with the modified inner tuple; that call should result in an &lt;code&gt;spgMatchNode&lt;/code&gt; result.</source>
          <target state="translated">新しい子ノードを追加する必要がある場合は、 &lt;code&gt;resultType&lt;/code&gt; を &lt;code&gt;spgAddNode&lt;/code&gt; に設定します。セット &lt;code&gt;nodeLabel&lt;/code&gt; 新しいノードに使用されるラベル、及びセットに &lt;code&gt;nodeN&lt;/code&gt; インデックス（ゼロから）ノードアレイ内のノードを挿入するれます。ノードが追加された後、変更された内部タプルを使用して、 &lt;code&gt;choose&lt;/code&gt; 関数が再度呼び出されます。その呼び出しは &lt;code&gt;spgMatchNode&lt;/code&gt; の結果になるはずです。</target>
        </trans-unit>
        <trans-unit id="01753c01a634660c1afc91855a2bf3e6c0a24915" translate="yes" xml:space="preserve">
          <source>If a problem arises while rebuilding the indexes, such as a uniqueness violation in a unique index, the &lt;code&gt;REINDEX&lt;/code&gt; command will fail but leave behind an &amp;ldquo;invalid&amp;rdquo; new index in addition to the pre-existing one. This index will be ignored for querying purposes because it might be incomplete; however it will still consume update overhead. The psql &lt;code&gt;\d&lt;/code&gt; command will report such an index as &lt;code&gt;INVALID&lt;/code&gt;:</source>
          <target state="translated">一意のインデックスの一意性違反など、インデックスの再構築中に問題が発生した場合、 &lt;code&gt;REINDEX&lt;/code&gt; コマンドは失敗しますが、既存のインデックスに加えて「無効な」新しいインデックスが残ります。このインデックスは不完全な場合があるため、クエリの目的では無視されます。ただし、それでも更新オーバーヘッドが消費されます。 psql &lt;code&gt;\d&lt;/code&gt; コマンドは &lt;code&gt;INVALID&lt;/code&gt; のようなインデックスを報告します：</target>
        </trans-unit>
        <trans-unit id="fc2fcf347772c27798939c43c378ac44b8d079f9" translate="yes" xml:space="preserve">
          <source>If a problem arises while scanning the table, such as a deadlock or a uniqueness violation in a unique index, the &lt;code&gt;CREATE INDEX&lt;/code&gt; command will fail but leave behind an &amp;ldquo;invalid&amp;rdquo; index. This index will be ignored for querying purposes because it might be incomplete; however it will still consume update overhead. The psql &lt;code&gt;\d&lt;/code&gt; command will report such an index as &lt;code&gt;INVALID&lt;/code&gt;:</source>
          <target state="translated">テーブルのスキャン中に、デッドロックや一意のインデックスの一意性違反などの問題が発生した場合、 &lt;code&gt;CREATE INDEX&lt;/code&gt; コマンドは失敗しますが、「無効な」インデックスが残ります。このインデックスは不完全な場合があるため、クエリの目的では無視されます。ただし、それでも更新オーバーヘッドが消費されます。 psql &lt;code&gt;\d&lt;/code&gt; コマンドは &lt;code&gt;INVALID&lt;/code&gt; のようなインデックスを報告します：</target>
        </trans-unit>
        <trans-unit id="60b7f8c376b0c316858e3c03acae729e9e8e0bbd" translate="yes" xml:space="preserve">
          <source>If a problem like this arises, it may not affect each individual index that is ordered using an affected collation, simply because &lt;em&gt;indexed&lt;/em&gt; values might happen to have the same absolute ordering regardless of the behavioral inconsistency. See &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt; and &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt; for further details about how PostgreSQL uses operating system locales and collations.</source>
          <target state="translated">このような問題が発生した場合、影響を受ける照合を使用して順序付けされた個々のインデックスには影響しない可能性があります。これは、動作の不整合に関係なく、&lt;em&gt;インデックス付けされた&lt;/em&gt;値が同じ絶対順序になる場合があるためです。参照&lt;a href=&quot;locale&quot;&gt;セクション23.1&lt;/a&gt;と&lt;a href=&quot;collation&quot;&gt;セクション23.2を&lt;/a&gt; PostgreSQLは、オペレーティングシステムのロケールと照合順序を使用する方法についての詳細は。</target>
        </trans-unit>
        <trans-unit id="14159bc71155b473a106589680a4763fc75cdf28" translate="yes" xml:space="preserve">
          <source>If a query contains aggregate function calls, but no &lt;code&gt;GROUP BY&lt;/code&gt; clause, grouping still occurs: the result is a single group row (or perhaps no rows at all, if the single row is then eliminated by &lt;code&gt;HAVING&lt;/code&gt;). The same is true if it contains a &lt;code&gt;HAVING&lt;/code&gt; clause, even without any aggregate function calls or &lt;code&gt;GROUP BY&lt;/code&gt; clause.</source>
          <target state="translated">クエリに集計関数呼び出しが含まれているが &lt;code&gt;GROUP BY&lt;/code&gt; 句がない場合でも、グループ化は行われます。結果は単一のグループ行になります（または、 &lt;code&gt;HAVING&lt;/code&gt; によって単一の行が削除された場合、おそらく行がまったくありません）。集計関数呼び出しや &lt;code&gt;GROUP BY&lt;/code&gt; 句がなくても、 &lt;code&gt;HAVING&lt;/code&gt; 句が含まれている場合も同様です。</target>
        </trans-unit>
        <trans-unit id="7e2704031f22c0864166ff4a01e062f291652c11" translate="yes" xml:space="preserve">
          <source>If a query that is expected to do so does not produce a parallel plan, you can try reducing &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt; or &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_cost&lt;/a&gt;. Of course, this plan may turn out to be slower than the serial plan which the planner preferred, but this will not always be the case. If you don't get a parallel plan even with very small values of these settings (e.g. after setting them both to zero), there may be some reason why the query planner is unable to generate a parallel plan for your query. See &lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;Section 15.2&lt;/a&gt; and &lt;a href=&quot;parallel-safety&quot;&gt;Section 15.4&lt;/a&gt; for information on why this may be the case.</source>
          <target state="translated">そうすることが期待されているクエリで並列プランが生成されない場合は、&lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt;または&lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_costを&lt;/a&gt;減らしてみてください。もちろん、この計画は計画者が好んだシリアル計画よりも遅いことが判明するかもしれませんが、これは必ずしもそうではありません。これらの設定の値が非常に小さい場合でも（たとえば、両方をゼロに設定した後で）並列プランを取得できない場合は、クエリプランナーがクエリの並列プランを生成できない理由が考えられます。これが当てはまる理由については、&lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;セクション15.2&lt;/a&gt;および&lt;a href=&quot;parallel-safety&quot;&gt;セクション15.4&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d78bc381604777d833daa7f8a441adef31412d42" translate="yes" xml:space="preserve">
          <source>If a query's results do not fit on the screen, they are piped through this command. Typical values are &lt;code&gt;more&lt;/code&gt; or &lt;code&gt;less&lt;/code&gt;. Use of the pager can be disabled by setting &lt;code&gt;PSQL_PAGER&lt;/code&gt; or &lt;code&gt;PAGER&lt;/code&gt; to an empty string, or by adjusting the pager-related options of the &lt;code&gt;\pset&lt;/code&gt; command. These variables are examined in the order listed; the first that is set is used. If none of them is set, the default is to use &lt;code&gt;more&lt;/code&gt; on most platforms, but &lt;code&gt;less&lt;/code&gt; on Cygwin.</source>
          <target state="translated">クエリの結果が画面に収まらない場合は、このコマンドを介してパイプ処理されます。典型的な値は &lt;code&gt;more&lt;/code&gt; または &lt;code&gt;less&lt;/code&gt; 。 &lt;code&gt;PSQL_PAGER&lt;/code&gt; または &lt;code&gt;PAGER&lt;/code&gt; を空の文字列に設定するか、 &lt;code&gt;\pset&lt;/code&gt; コマンドのページャー関連オプションを調整することにより、ページャーの使用を無効にできます。これらの変数は、リストされている順序で検査されます。最初に設定されたものが使用されます。それらのいずれも設定されていない場合、デフォルトでは、ほとんどのプラットフォームで &lt;code&gt;more&lt;/code&gt; 使用されますが、Cygwin では &lt;code&gt;less&lt;/code&gt; れます。</target>
        </trans-unit>
        <trans-unit id="3a16d1e24e65d591a8270e12d2132334cb1a5266" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE AGGREGATE myschema.myagg ...&lt;/code&gt;) then the aggregate function is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">スキーマ名が指定されている場合（たとえば、 &lt;code&gt;CREATE AGGREGATE myschema.myagg ...&lt;/code&gt; ）、指定されたスキーマに集計関数が作成されます。それ以外の場合は、現在のスキーマに作成されます。</target>
        </trans-unit>
        <trans-unit id="9221069e2f8158080f0dab328adf9a4fc4ac50a4" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE DOMAIN myschema.mydomain ...&lt;/code&gt;) then the domain is created in the specified schema. Otherwise it is created in the current schema. The domain name must be unique among the types and domains existing in its schema.</source>
          <target state="translated">スキーマ名が指定されている場合（たとえば、 &lt;code&gt;CREATE DOMAIN myschema.mydomain ...&lt;/code&gt; ）、ドメインは指定されたスキーマに作成されます。それ以外の場合は、現在のスキーマに作成されます。ドメイン名は、スキーマに存在するタイプとドメイン間で一意である必要があります。</target>
        </trans-unit>
        <trans-unit id="2b01ea3ef0736036d56ce2802cb7af1e7ac1551f" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE FOREIGN TABLE myschema.mytable ...&lt;/code&gt;) then the table is created in the specified schema. Otherwise it is created in the current schema. The name of the foreign table must be distinct from the name of any other foreign table, table, sequence, index, view, or materialized view in the same schema.</source>
          <target state="translated">スキーマ名が指定されている場合（たとえば、 &lt;code&gt;CREATE FOREIGN TABLE myschema.mytable ...&lt;/code&gt; ）、テーブルは指定されたスキーマに作成されます。それ以外の場合は、現在のスキーマに作成されます。外部テーブルの名前は、同じスキーマ内の他の外部テーブル、テーブル、シーケンス、インデックス、ビュー、またはマテリアライズドビューの名前とは異なる必要があります。</target>
        </trans-unit>
        <trans-unit id="0017dfefecb7c7d878ccd99cec2c2243eb08f548" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE STATISTICS myschema.mystat ...&lt;/code&gt;) then the statistics object is created in the specified schema. Otherwise it is created in the current schema. The name of the statistics object must be distinct from the name of any other statistics object in the same schema.</source>
          <target state="translated">スキーマ名が指定されている場合（例： &lt;code&gt;CREATE STATISTICS myschema.mystat ...&lt;/code&gt; ）、指定したスキーマに統計オブジェクトが作成されます。それ以外の場合は、現在のスキーマに作成されます。統計オブジェクトの名前は、同じスキーマ内の他の統計オブジェクトの名前とは異なる必要があります。</target>
        </trans-unit>
        <trans-unit id="d358a0109b0b0aa95ca587460e4392925dac3d64" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE TABLE myschema.mytable ...&lt;/code&gt;) then the table is created in the specified schema. Otherwise it is created in the current schema. Temporary tables exist in a special schema, so a schema name cannot be given when creating a temporary table. The name of the table must be distinct from the name of any other table, sequence, index, view, or foreign table in the same schema.</source>
          <target state="translated">スキーマ名が指定されている場合（例： &lt;code&gt;CREATE TABLE myschema.mytable ...&lt;/code&gt; ）、指定されたスキーマにテーブルが作成されます。それ以外の場合は、現在のスキーマに作成されます。一時テーブルは特別なスキーマに存在するため、一時テーブルを作成するときにスキーマ名を指定することはできません。テーブルの名前は、同じスキーマ内の他のテーブル、シーケンス、インデックス、ビュー、または外部テーブルの名前とは異なる必要があります。</target>
        </trans-unit>
        <trans-unit id="93459b6de8914138c246c45451309801fa4eb75b" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE VIEW myschema.myview ...&lt;/code&gt;) then the view is created in the specified schema. Otherwise it is created in the current schema. Temporary views exist in a special schema, so a schema name cannot be given when creating a temporary view. The name of the view must be distinct from the name of any other view, table, sequence, index or foreign table in the same schema.</source>
          <target state="translated">スキーマ名が指定されている場合（たとえば、 &lt;code&gt;CREATE VIEW myschema.myview ...&lt;/code&gt; ）、ビューは指定されたスキーマに作成されます。それ以外の場合は、現在のスキーマに作成されます。一時ビューは特別なスキーマに存在するため、一時ビューを作成するときにスキーマ名を指定することはできません。ビューの名前は、同じスキーマ内の他のビュー、テーブル、シーケンス、インデックス、または外部テーブルの名前とは異なる必要があります。</target>
        </trans-unit>
        <trans-unit id="f45727194d879f2673b515b0704bca00c0cdc2be" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the operator class is created in the specified schema. Otherwise it is created in the current schema. Two operator classes in the same schema can have the same name only if they are for different index methods.</source>
          <target state="translated">スキーマ名が指定された場合は、指定されたスキーマに演算子クラスが作成されます。それ以外の場合は、現在のスキーマに作成されます。同じスキーマ内の2つの演算子クラスは、異なるインデックスメソッドのためのものである場合に限り、同じ名前を持つことができます。</target>
        </trans-unit>
        <trans-unit id="924ee280ad5b0efe3a03d3f74bd950473afe0d2b" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the operator family is created in the specified schema. Otherwise it is created in the current schema. Two operator families in the same schema can have the same name only if they are for different index methods.</source>
          <target state="translated">スキーマ名を指定すると、指定されたスキーマに演算子ファミリが作成されます。それ以外の場合は、現在のスキーマに作成されます。同じスキーマ内の2つの演算子ファミリーは、異なるインデックスメソッドの場合に限り、同じ名前を持つことができます。</target>
        </trans-unit>
        <trans-unit id="d43b98c46599ec5632b8b68a4c4aec5bc7c49e45" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the sequence is created in the specified schema. Otherwise it is created in the current schema. Temporary sequences exist in a special schema, so a schema name cannot be given when creating a temporary sequence. The sequence name must be distinct from the name of any other sequence, table, index, view, or foreign table in the same schema.</source>
          <target state="translated">スキーマ名を指定すると、指定したスキーマ内にシーケンスが作成されます。それ以外の場合は、現在のスキーマに作成されます。一時的なシーケンスは特別なスキーマに存在するため、一時的なシーケンスを作成する際にスキーマ名を指定することはできません。シーケンス名は、同じスキーマ内の他のシーケンス、テーブル、インデックス、ビュー、外部テーブルの名前とは区別されていなければなりません。</target>
        </trans-unit>
        <trans-unit id="d3a817f61150e098cf1b32f5797358f478896c39" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search configuration is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">スキーマ名が指定された場合、テキスト検索設定は指定されたスキーマに作成されます。そうでなければ、現在のスキーマに作成されます。</target>
        </trans-unit>
        <trans-unit id="6aa5bd7767ed3e5d5d615c990a382ab4eccb349b" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search dictionary is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">スキーマ名が指定された場合、テキスト検索辞書は指定されたスキーマに作成されます。それ以外の場合は、現在のスキーマに作成されます。</target>
        </trans-unit>
        <trans-unit id="3f275ed3d77d7d07fbadd2aeff95331926c88b60" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search parser is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">スキーマ名が指定された場合、テキスト検索パーサは指定されたスキーマに作成されます。それ以外の場合は、現在のスキーマに作成されます。</target>
        </trans-unit>
        <trans-unit id="c90f2803121a2139271a7f1f2ab6d88702071162" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search template is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">スキーマ名が指定された場合、テキスト検索テンプレートは指定されたスキーマに作成されます。それ以外の場合は、現在のスキーマに作成されます。</target>
        </trans-unit>
        <trans-unit id="3f1b270e2011c6de6a6609606ad6c64491399611" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the type is created in the specified schema. Otherwise it is created in the current schema. The type name must be distinct from the name of any existing type or domain in the same schema. (Because tables have associated data types, the type name must also be distinct from the name of any existing table in the same schema.)</source>
          <target state="translated">スキーマ名が指定された場合、その型は指定されたスキーマに作成されます。それ以外の場合は、現在のスキーマに作成されます。型名は、同じスキーマ内の既存の型名またはドメイン名とは区別して指定する必要があります(テーブルには関連するデータ型があるため、型名もまた、既存のテーブル名とは区別して指定する必要があります)。(テーブルには関連するデータ型があるため、型名も同じスキーマ内の既存のテーブル名とは区別する必要があります)。</target>
        </trans-unit>
        <trans-unit id="3270e8102f1d16bb2969879cc26ff629f7438593" translate="yes" xml:space="preserve">
          <source>If a schema name is included, then the function is created in the specified schema. Otherwise it is created in the current schema. The name of the new function must not match any existing function or procedure with the same input argument types in the same schema. However, functions and procedures of different argument types can share a name (this is called &lt;em&gt;overloading&lt;/em&gt;).</source>
          <target state="translated">スキーマ名が含まれている場合、関数は指定されたスキーマに作成されます。それ以外の場合は、現在のスキーマに作成されます。新しい関数の名前は、同じスキーマ内の同じ入力引数タイプを持つ既存の関数またはプロシージャと一致してはなりません。ただし、引数の型が異なる関数とプロシージャは名前を共有できます（これを&lt;em&gt;オーバーロード&lt;/em&gt;と呼びます）。</target>
        </trans-unit>
        <trans-unit id="fa9f9c34f552135ee16bf0e254ac4f8936e929d0" translate="yes" xml:space="preserve">
          <source>If a schema name is included, then the procedure is created in the specified schema. Otherwise it is created in the current schema. The name of the new procedure must not match any existing procedure or function with the same input argument types in the same schema. However, procedures and functions of different argument types can share a name (this is called &lt;em&gt;overloading&lt;/em&gt;).</source>
          <target state="translated">スキーマ名が含まれている場合、指定したスキーマにプロシージャが作成されます。それ以外の場合は、現在のスキーマに作成されます。新しいプロシージャの名前は、同じスキーマ内の同じ入力引数タイプを持つ既存のプロシージャまたは関数と一致してはなりません。ただし、異なる引数型のプロシージャと関数は名前を共有できます（これを&lt;em&gt;オーバーロード&lt;/em&gt;と呼びます）。</target>
        </trans-unit>
        <trans-unit id="dacc047d6b80f30af4e1b3c075ae268658bf910d" translate="yes" xml:space="preserve">
          <source>If a separate session key is requested, a new random key will be generated. Otherwise the S2K key will be used directly as the session key.</source>
          <target state="translated">別のセッション・キーが要求された場合、新しいランダム・キーが生成されます。それ以外の場合は、S2Kキーが直接セッションキーとして使用されます。</target>
        </trans-unit>
        <trans-unit id="5829673b8ac4bdf9ef5ccbb615c82963b07e7a46" translate="yes" xml:space="preserve">
          <source>If a sequence object has been created with default parameters, successive &lt;code&gt;nextval&lt;/code&gt; calls will return successive values beginning with 1. Other behaviors can be obtained by using special parameters in the &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; command; see its command reference page for more information.</source>
          <target state="translated">シーケンスオブジェクトがデフォルトのパラメーターで作成されている場合、 &lt;code&gt;nextval&lt;/code&gt; を連続して呼び出すと、1から始まる連続した値が返されます。その他の動作は、&lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt;コマンドで特別なパラメーターを使用して取得できます。詳細については、コマンドリファレンスページを参照してください。</target>
        </trans-unit>
        <trans-unit id="f45a6ad1ab211a977ca7a8e8006108f711740038" translate="yes" xml:space="preserve">
          <source>If a subscription is associated with a replication slot, then &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">サブスクリプションがレプリケーションスロットに関連付けられている場合、 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; はトランザクションブロック内では実行できません。</target>
        </trans-unit>
        <trans-unit id="4fefee0e29f8ef757e65c2ca97914e54656fff0f" translate="yes" xml:space="preserve">
          <source>If a superuser chooses to issue a &lt;code&gt;GRANT&lt;/code&gt; or &lt;code&gt;REVOKE&lt;/code&gt; command, the command is performed as though it were issued by the owner of the affected object. In particular, privileges granted via such a command will appear to have been granted by the object owner. (For role membership, the membership appears to have been granted by the containing role itself.)</source>
          <target state="translated">スーパーユーザーが &lt;code&gt;GRANT&lt;/code&gt; または &lt;code&gt;REVOKE&lt;/code&gt; コマンドの発行を選択した場合、コマンドは、影響を受けるオブジェクトの所有者によって発行されたかのように実行されます。特に、このようなコマンドを使用して付与された特権は、オブジェクトの所有者によって付与されたように見えます。（ロールメンバーシップの場合、メンバーシップは包含ロール自体によって付与されたようです。）</target>
        </trans-unit>
        <trans-unit id="bdba0ac2d184c2c84f2cf4f8d54b0cd35c6bae22" translate="yes" xml:space="preserve">
          <source>If a superuser chooses to issue a &lt;code&gt;GRANT&lt;/code&gt; or &lt;code&gt;REVOKE&lt;/code&gt; command, the command is performed as though it were issued by the owner of the affected object. Since all privileges ultimately come from the object owner (possibly indirectly via chains of grant options), it is possible for a superuser to revoke all privileges, but this might require use of &lt;code&gt;CASCADE&lt;/code&gt; as stated above.</source>
          <target state="translated">スーパーユーザーが &lt;code&gt;GRANT&lt;/code&gt; または &lt;code&gt;REVOKE&lt;/code&gt; コマンドの発行を選択した場合、コマンドは、影響を受けるオブジェクトの所有者によって発行されたかのように実行されます。すべての特権は最終的にオブジェクト所有者から（おそらく付与オプションのチェーンを介して間接的に）提供されるため、スーパーユーザーがすべての特権を取り消すことは可能ですが、これには上記の &lt;code&gt;CASCADE&lt;/code&gt; の使用が必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="3105c963db998b17d895e80efc90a4f3ec29f6b5" translate="yes" xml:space="preserve">
          <source>If a table constraint (including foreign keys, but not constraint triggers), list of the constrained columns</source>
          <target state="translated">テーブル制約(外部キーを含むが制約トリガーではない)の場合、制約列のリスト</target>
        </trans-unit>
        <trans-unit id="d9d8db43e6826c95f740877ac4ab55e53bc6727a" translate="yes" xml:space="preserve">
          <source>If a table has any descendant tables, it is not permitted to add, rename, or change the type of a column in the parent table without doing the same to the descendants. This ensures that the descendants always have columns matching the parent. Similarly, a &lt;code&gt;CHECK&lt;/code&gt; constraint cannot be renamed in the parent without also renaming it in all descendants, so that &lt;code&gt;CHECK&lt;/code&gt; constraints also match between the parent and its descendants. (That restriction does not apply to index-based constraints, however.) Also, because selecting from the parent also selects from its descendants, a constraint on the parent cannot be marked valid unless it is also marked valid for those descendants. In all of these cases, &lt;code&gt;ALTER TABLE ONLY&lt;/code&gt; will be rejected.</source>
          <target state="translated">テーブルに子孫テーブルがある場合、子孫に対して同じ操作を行わずに、親テーブルの列のタイプを追加、名前変更、または変更することはできません。これにより、子孫は常に親と一致する列を持つようになります。同様に、 &lt;code&gt;CHECK&lt;/code&gt; 制約は、すべての子孫で名前を変更しない限り、親で名前を変更することはできません。そのため、 &lt;code&gt;CHECK&lt;/code&gt; 制約は親とその子孫の間でも一致します。 （ただし、この制限はインデックスベースの制約には適用されません。）また、親から選択するとその子孫からも選択されるため、親の制約は、それらの子孫に対しても有効とマークされていない限り、有効とマークできません。これらすべてのケースで、 &lt;code&gt;ALTER TABLE ONLY&lt;/code&gt; は拒否されます。</target>
        </trans-unit>
        <trans-unit id="f72f4b4a7dd1cbe9511c2732830698755442a3ed" translate="yes" xml:space="preserve">
          <source>If a table has been grouped using &lt;code&gt;GROUP BY&lt;/code&gt;, but only certain groups are of interest, the &lt;code&gt;HAVING&lt;/code&gt; clause can be used, much like a &lt;code&gt;WHERE&lt;/code&gt; clause, to eliminate groups from the result. The syntax is:</source>
          <target state="translated">テーブルが &lt;code&gt;GROUP BY&lt;/code&gt; を使用してグループ化されているが、特定のグループのみが対象である場合、 &lt;code&gt;WHERE&lt;/code&gt; 句と同様に &lt;code&gt;HAVING&lt;/code&gt; 句を使用して、結果からグループを削除できます。構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="fd8b65709a6edce92f223fae042df5baecd19362" translate="yes" xml:space="preserve">
          <source>If a tablespace is relocated in this way, the symbolic links inside the main data directory are updated to point to the new location. So the new data directory is ready to be used for a new server instance with all tablespaces in the updated locations.</source>
          <target state="translated">このようにしてテーブルスペースが再配置されると、メインデータディレクトリ内のシンボリックリンクは新しい場所を指すように更新されます。つまり、新しいデータディレクトリは、すべてのテーブルスペースが更新された場所にある新しいサーバーインスタンスで使用する準備ができています。</target>
        </trans-unit>
        <trans-unit id="58895429ed60b7ffce3462e3dfc985d5ce11688f" translate="yes" xml:space="preserve">
          <source>If a transaction of this sort is going to change the data in the table, then it should use &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock mode instead of &lt;code&gt;SHARE&lt;/code&gt; mode. This ensures that only one transaction of this type runs at a time. Without this, a deadlock is possible: two transactions might both acquire &lt;code&gt;SHARE&lt;/code&gt; mode, and then be unable to also acquire &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode to actually perform their updates. (Note that a transaction's own locks never conflict, so a transaction can acquire &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode when it holds &lt;code&gt;SHARE&lt;/code&gt; mode &amp;mdash; but not if anyone else holds &lt;code&gt;SHARE&lt;/code&gt; mode.) To avoid deadlocks, make sure all transactions acquire locks on the same objects in the same order, and if multiple lock modes are involved for a single object, then transactions should always acquire the most restrictive mode first.</source>
          <target state="translated">この種の取引は、テーブル内のデータを変更しようとしている場合、それは使うべき &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; のロックモードの代わりに、 &lt;code&gt;SHARE&lt;/code&gt; のモードを。これにより、このタイプのトランザクションは一度に1つだけ実行されます。これがないと、デッドロックが発生する可能性があります。2つのトランザクションが両方とも &lt;code&gt;SHARE&lt;/code&gt; モードを取得し、 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; モードも取得して実際に更新を実行できない場合があります。 （トランザクション自体のロックは競合しないため、 &lt;code&gt;SHARE&lt;/code&gt; モードを保持している場合、トランザクションは &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; モードを取得できますが、他の誰かが &lt;code&gt;SHARE&lt;/code&gt; を保持している場合は取得できません。モード。）デッドロックを回避するには、すべてのトランザクションが同じオブジェクトに対して同じ順序でロックを取得するようにします。1つのオブジェクトに複数のロックモードが含まれる場合、トランザクションは常に最も制限的なモードを最初に取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="2d7eb85ea844d2ba5b981dae6af94a75b4526c2e" translate="yes" xml:space="preserve">
          <source>If a user does not have the required privilege on the table or columns, then in many cases the query will ultimately receive a permission-denied error, in which case this mechanism is invisible in practice. But if the user is reading from a security-barrier view, then the planner might wish to check the statistics of an underlying table that is otherwise inaccessible to the user. In that case, the operator should be leak-proof or the statistics will not be used. There is no direct feedback about that, except that the plan might be suboptimal. If one suspects that this is the case, one could try running the query as a more privileged user, to see if a different plan results.</source>
          <target state="translated">ユーザがテーブルやカラムに対して必要な権限を持っていない場合、多くの場合、クエリは最終的にパーミッション拒否エラーを受け取りますが、この場合、このメカニズムは実際には見えません。しかし、ユーザがセキュリティバリアビューから読み込んでいる場合、プランナは、ユーザがアクセスできない基礎となるテーブルの統計情報をチェックしたいと思うかもしれません。その場合、演算子は漏洩しないようにしなければならないし、統計情報は使用されません。計画が最適ではないかもしれないということを除いて、それについての直接的なフィードバックはありません。このようなことが疑われる場合は、より権限のあるユーザでクエリを実行してみて、異なるプランの結果が得られるかどうかを確認することができます。</target>
        </trans-unit>
        <trans-unit id="6dba31a67ed7f0ca43338760f7f94d591211dfb7" translate="yes" xml:space="preserve">
          <source>If a user holds a privilege with grant option and has granted it to other users then the privileges held by those other users are called dependent privileges. If the privilege or the grant option held by the first user is being revoked and dependent privileges exist, those dependent privileges are also revoked if &lt;code&gt;CASCADE&lt;/code&gt; is specified; if it is not, the revoke action will fail. This recursive revocation only affects privileges that were granted through a chain of users that is traceable to the user that is the subject of this &lt;code&gt;REVOKE&lt;/code&gt; command. Thus, the affected users might effectively keep the privilege if it was also granted through other users.</source>
          <target state="translated">ユーザーが付与オプションを使用して権限を保持し、それを他のユーザーに付与した場合、他のユーザーが保持する権限は依存権限と呼ばれます。最初のユーザーが保持している特権または付与オプションが取り消されており、従属特権が存在する場合、 &lt;code&gt;CASCADE&lt;/code&gt; が指定されていると、それらの従属特権も取り消されます。そうでない場合、取り消しアクションは失敗します。この再帰的な取り消しは、この &lt;code&gt;REVOKE&lt;/code&gt; コマンドの対象であるユーザーに追跡可能なユーザーのチェーンを通じて付与された特権にのみ影響します。したがって、影響を受けるユーザーは、他のユーザーからも特権が付与されている場合、その特権を効果的に保持する可能性があります。</target>
        </trans-unit>
        <trans-unit id="bd5f3c1cab021783ead43914fa444508c73ceec6" translate="yes" xml:space="preserve">
          <source>If a zero byte (&lt;code&gt;''&lt;/code&gt;), then not a generated column. Otherwise, &lt;code&gt;s&lt;/code&gt; = stored. (Other values might be added in the future.)</source>
          <target state="translated">ゼロバイト（ &lt;code&gt;''&lt;/code&gt; ）の場合、生成された列ではありません。それ以外の場合、 &lt;code&gt;s&lt;/code&gt; =保存されます。（将来、他の値が追加される可能性があります。）</target>
        </trans-unit>
        <trans-unit id="a7c2f91a2488ff29789b7c51189ebdab420b3b17" translate="yes" xml:space="preserve">
          <source>If a zero byte (&lt;code&gt;''&lt;/code&gt;), then not an identity column. Otherwise, &lt;code&gt;a&lt;/code&gt; = generated always, &lt;code&gt;d&lt;/code&gt; = generated by default.</source>
          <target state="translated">ゼロバイト（ &lt;code&gt;''&lt;/code&gt; ）の場合、ID列ではありません。それ以外の場合、 &lt;code&gt;a&lt;/code&gt; =常に生成され、 &lt;code&gt;d&lt;/code&gt; =デフォルトで生成されます。</target>
        </trans-unit>
        <trans-unit id="5de4b09ad9373970f4d3245c8e5f5878c7360739" translate="yes" xml:space="preserve">
          <source>If all inputs are of the same type, and it is not &lt;code&gt;unknown&lt;/code&gt;, resolve as that type.</source>
          <target state="translated">すべての入力が同じタイプで、 &lt;code&gt;unknown&lt;/code&gt; ではない場合は、そのタイプとして解決します。</target>
        </trans-unit>
        <trans-unit id="2f0d22550a877dd1e7a10ea59bd4e64873db9458" translate="yes" xml:space="preserve">
          <source>If all inputs are of type &lt;code&gt;unknown&lt;/code&gt;, resolve as type &lt;code&gt;text&lt;/code&gt; (the preferred type of the string category). Otherwise, &lt;code&gt;unknown&lt;/code&gt; inputs are ignored for the purposes of the remaining rules.</source>
          <target state="translated">すべての入力のタイプが &lt;code&gt;unknown&lt;/code&gt; の場合は、タイプ &lt;code&gt;text&lt;/code&gt; （文字列カテゴリの推奨されるタイプ）として解決します。それ以外の場合、残りのルールでは、 &lt;code&gt;unknown&lt;/code&gt; 入力は無視されます。</target>
        </trans-unit>
        <trans-unit id="aa6c40971fdf72080d58a6233c79f7c8dce2a255" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ORDER BY&lt;/code&gt; expression is a simple name that matches both an output column name and an input column name, &lt;code&gt;ORDER BY&lt;/code&gt; will interpret it as the output column name. This is the opposite of the choice that &lt;code&gt;GROUP BY&lt;/code&gt; will make in the same situation. This inconsistency is made to be compatible with the SQL standard.</source>
          <target state="translated">場合は &lt;code&gt;ORDER BY&lt;/code&gt; 式は出力列名と入力列名の両方に一致する単純な名前があり、 &lt;code&gt;ORDER BY&lt;/code&gt; は、出力列名として解釈されます。これは、 &lt;code&gt;GROUP BY&lt;/code&gt; が同じ状況で行う選択の逆です。この不整合は、SQL標準と互換性があるように作成されています。</target>
        </trans-unit>
        <trans-unit id="0ad7084c5cdd9f3be36397e8c9220c13ae237d6c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;existing_window_name&lt;/code&gt; is specified it must refer to an earlier entry in the &lt;code&gt;WINDOW&lt;/code&gt; list; the new window copies its partitioning clause from that entry, as well as its ordering clause if any. In this case the new window cannot specify its own &lt;code&gt;PARTITION BY&lt;/code&gt; clause, and it can specify &lt;code&gt;ORDER BY&lt;/code&gt; only if the copied window does not have one. The new window always uses its own frame clause; the copied window must not specify a frame clause.</source>
          <target state="translated">&lt;code&gt;existing_window_name&lt;/code&gt; を指定する場合は、 &lt;code&gt;WINDOW&lt;/code&gt; リストの前のエントリを参照する必要があります。新しいウィンドウは、そのエントリからパーティショニング句をコピーします。この場合、新しいウィンドウは独自の &lt;code&gt;PARTITION BY&lt;/code&gt; 句を指定できず、コピーされたウィンドウにない場合にのみ &lt;code&gt;ORDER BY&lt;/code&gt; を指定できます。新しいウィンドウは常に独自のフレーム句を使用します。コピーされたウィンドウはフレーム句を指定してはなりません。</target>
        </trans-unit>
        <trans-unit id="d9f4f0d891ac5ca27debdc2266324be50c274311" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;options&lt;/code&gt; string is specified it must consist of a comma-separated list of one or more &lt;code&gt;option&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; pairs. The available options are:</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 文字列を指定する場合は、1つ以上の &lt;code&gt;option&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; ペアのコンマ区切りのリストで構成する必要があります。使用可能なオプションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="7cd30de9bbf3f8180a703c4e2d6c583071ea1a34" translate="yes" xml:space="preserve">
          <source>If an OID that does not represent an existing object is passed as argument to one of the above functions, NULL is returned.</source>
          <target state="translated">上記のいずれかの関数の引数に、既存のオブジェクトを表さないOIDが渡された場合、NULLが返されます。</target>
        </trans-unit>
        <trans-unit id="ffc31d26a07681f5637a04d968a3f5e70276453d" translate="yes" xml:space="preserve">
          <source>If an aggregate supports moving-aggregate mode, it will improve calculation efficiency when the aggregate is used as a window function for a window with moving frame start (that is, a frame start mode other than &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt;). Conceptually, the forward transition function adds input values to the aggregate's state when they enter the window frame from the bottom, and the inverse transition function removes them again when they leave the frame at the top. So, when values are removed, they are always removed in the same order they were added. Whenever the inverse transition function is invoked, it will thus receive the earliest added but not yet removed argument value(s). The inverse transition function can assume that at least one row will remain in the current state after it removes the oldest row. (When this would not be the case, the window function mechanism simply starts a fresh aggregation, rather than using the inverse transition function.)</source>
          <target state="translated">集約が移動集約モードをサポートしている場合、集約が移動フレーム開始（つまり、 &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; 以外のフレーム開始モード）を持つウィンドウのウィンドウ関数として使用されると、計算効率が向上します。）。概念的には、順方向遷移関数は、下からウィンドウフレームに入るときに入力値を集約の状態に追加し、逆遷移関数は、フレームを上から離れると、それらを再び削除します。したがって、値が削除されると、それらは常に、追加されたのと同じ順序で削除されます。したがって、逆遷移関数が呼び出されるときはいつでも、最初に追加されたがまだ削除されていない引数値を受け取ります。逆遷移関数は、最も古い行を削除した後、少なくとも1つの行が現在の状態のままであると想定できます。 （これが当てはまらない場合、ウィンドウ関数メカニズムは、逆遷移関数を使用するのではなく、単に新しい集計を開始します。）</target>
        </trans-unit>
        <trans-unit id="3eaeb85716c71ac82a1780ada62bc3bcdfffa64e" translate="yes" xml:space="preserve">
          <source>If an arbitrary value expression is used in the select list, it conceptually adds a new virtual column to the returned table. The value expression is evaluated once for each result row, with the row's values substituted for any column references. But the expressions in the select list do not have to reference any columns in the table expression of the &lt;code&gt;FROM&lt;/code&gt; clause; they can be constant arithmetic expressions, for instance.</source>
          <target state="translated">選択リストで任意の値式が使用されている場合、概念的には、返されたテーブルに新しい仮想列が追加されます。値式は結果行ごとに1回評価され、行の値は列参照に置き換えられます。ただし、選択リストの式は、 &lt;code&gt;FROM&lt;/code&gt; 句のテーブル式の列を参照する必要はありません。たとえば、定数演算式にすることができます。</target>
        </trans-unit>
        <trans-unit id="80b1d5b3ba2fcc79e9cc1eabebb22c4a831065de" translate="yes" xml:space="preserve">
          <source>If an automatically updatable view contains a &lt;code&gt;WHERE&lt;/code&gt; condition, the condition restricts which rows of the base relation are available to be modified by &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; statements on the view. However, an &lt;code&gt;UPDATE&lt;/code&gt; is allowed to change a row so that it no longer satisfies the &lt;code&gt;WHERE&lt;/code&gt; condition, and thus is no longer visible through the view. Similarly, an &lt;code&gt;INSERT&lt;/code&gt; command can potentially insert base-relation rows that do not satisfy the &lt;code&gt;WHERE&lt;/code&gt; condition and thus are not visible through the view (&lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; may similarly affect an existing row not visible through the view). The &lt;code&gt;CHECK OPTION&lt;/code&gt; may be used to prevent &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands from creating such rows that are not visible through the view.</source>
          <target state="translated">自動的に更新可能なビューに &lt;code&gt;WHERE&lt;/code&gt; 条件が含まれている場合、この条件は、ビューの &lt;code&gt;UPDATE&lt;/code&gt; および &lt;code&gt;DELETE&lt;/code&gt; ステートメントで変更できる基本リレーションの行を制限します。ただし、 &lt;code&gt;UPDATE&lt;/code&gt; は行を変更できるため、 &lt;code&gt;WHERE&lt;/code&gt; 条件を満たさなくなり、ビューからは見えなくなります。同様に、 &lt;code&gt;INSERT&lt;/code&gt; コマンドは、 &lt;code&gt;WHERE&lt;/code&gt; 条件を満たさないためにビューからは見えない基本関係行を挿入する可能性があります（ &lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; は、ビューからは見えない既存の行にも同様に影響する可能性があります）。 &lt;code&gt;CHECK OPTION&lt;/code&gt; 防止するために使用することができる &lt;code&gt;INSERT&lt;/code&gt; と &lt;code&gt;UPDATE&lt;/code&gt; のビューを介して見えないような行を作成からコマンドを。</target>
        </trans-unit>
        <trans-unit id="2404db1fa7170a324c806fd815c2c382fbb3ff70" translate="yes" xml:space="preserve">
          <source>If an automatically updatable view is marked with the &lt;code&gt;security_barrier&lt;/code&gt; property then all the view's &lt;code&gt;WHERE&lt;/code&gt; conditions (and any conditions using operators which are marked as &lt;code&gt;LEAKPROOF&lt;/code&gt;) will always be evaluated before any conditions that a user of the view has added. See &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for full details. Note that, due to this, rows which are not ultimately returned (because they do not pass the user's &lt;code&gt;WHERE&lt;/code&gt; conditions) may still end up being locked. &lt;code&gt;EXPLAIN&lt;/code&gt; can be used to see which conditions are applied at the relation level (and therefore do not lock rows) and which are not.</source>
          <target state="translated">自動的に更新可能なビューが &lt;code&gt;security_barrier&lt;/code&gt; プロパティでマークされている場合、ビューのすべての &lt;code&gt;WHERE&lt;/code&gt; 条件（および &lt;code&gt;LEAKPROOF&lt;/code&gt; としてマークされている演算子を使用するすべての条件）は、ビューのユーザーが追加した条件の前に常に評価されます。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;セクション40.5&lt;/a&gt;を参照してください。このため、最終的に返されない行（ユーザーの &lt;code&gt;WHERE&lt;/code&gt; 条件を渡さないため）がロックされたままになる可能性があることに注意してください。 &lt;code&gt;EXPLAIN&lt;/code&gt; を使用して、関係レベルで適用されている（したがって、行をロックしない）条件と適用されていない条件を確認できます。</target>
        </trans-unit>
        <trans-unit id="5c5594932b933065e06b18f724dcf95bf8608f76" translate="yes" xml:space="preserve">
          <source>If an error in these files is detected at server start, the server will refuse to start. But if an error is detected during a configuration reload, the files are ignored and the old SSL configuration continues to be used. On Windows systems, if an error in these files is detected at backend start, that backend will be unable to establish an SSL connection. In all these cases, the error condition is reported in the server log.</source>
          <target state="translated">サーバの起動時にこれらのファイルのエラーが検出された場合、サーバは起動を拒否します。しかし、設定のリロード中にエラーが検出された場合、ファイルは無視され、古いSSL設定が引き続き使用されます。Windowsシステムでは、バックエンドの起動時にこれらのファイルのエラーが検出されると、バックエンドはSSL接続を確立できなくなります。これらの場合、エラー状態はサーバーログに報告されます。</target>
        </trans-unit>
        <trans-unit id="97b646bc602dad48858332961c1cd79032617933" translate="yes" xml:space="preserve">
          <source>If an error occurs while reading the time zone abbreviation set, no new value is applied and the old set is kept. If the error occurs while starting the database, startup fails.</source>
          <target state="translated">タイムゾーン略語セットの読み込み中にエラーが発生した場合、新しい値は適用されず、古いセットが保持されます。データベースの起動中にエラーが発生した場合、起動に失敗する。</target>
        </trans-unit>
        <trans-unit id="1de87c93627deeafcb3370199aca0fb5ecf8ffbd" translate="yes" xml:space="preserve">
          <source>If an error occurs while restoring the database schema, &lt;code&gt;pg_upgrade&lt;/code&gt; will exit and you will have to revert to the old cluster as outlined in &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REVERT&quot;&gt;Step 16&lt;/a&gt; below. To try &lt;code&gt;pg_upgrade&lt;/code&gt; again, you will need to modify the old cluster so the pg_upgrade schema restore succeeds. If the problem is a &lt;code&gt;contrib&lt;/code&gt; module, you might need to uninstall the &lt;code&gt;contrib&lt;/code&gt; module from the old cluster and install it in the new cluster after the upgrade, assuming the module is not being used to store user data.</source>
          <target state="translated">データベーススキーマの復元中にエラーが発生した場合、 &lt;code&gt;pg_upgrade&lt;/code&gt; は終了し、以下の&lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REVERT&quot;&gt;ステップ16で&lt;/a&gt;説明されているように、古いクラスターに戻す必要があります。 &lt;code&gt;pg_upgrade&lt;/code&gt; を再試行するには、pg_upgradeスキーマの復元が成功するように古いクラスターを変更する必要があります。問題が &lt;code&gt;contrib&lt;/code&gt; モジュールである場合、モジュールがユーザーデータの保存に使用されていないと想定して、古いクラスターから &lt;code&gt;contrib&lt;/code&gt; モジュールをアンインストールし、アップグレード後に新しいクラスターにインストールする必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="f87c733146ee0c8066dc39794ef31c58e51824d2" translate="yes" xml:space="preserve">
          <source>If an exclusion constraint, list of the per-column exclusion operators</source>
          <target state="translated">除外制約の場合、列ごとの除外演算子のリスト</target>
        </trans-unit>
        <trans-unit id="5e3f8c180f35468731cc99d8e63857d68ba52649" translate="yes" xml:space="preserve">
          <source>If an expression yields a value of a composite type (row type), then a specific field of the row can be extracted by writing</source>
          <target state="translated">式が複合型(行の型)の値を返す場合、行の特定のフィールドを抽出するには</target>
        </trans-unit>
        <trans-unit id="4ecdcd8e3d88016c98e66e3a3a5e3c60d566e607" translate="yes" xml:space="preserve">
          <source>If an expression yields a value of an array type, then a specific element of the array value can be extracted by writing</source>
          <target state="translated">式が配列型の値を返す場合、配列値の特定の要素は</target>
        </trans-unit>
        <trans-unit id="6de9a52dce84b15b69f729bccf651727ae858f41" translate="yes" xml:space="preserve">
          <source>If an index build fails with the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option, this index is left as &amp;ldquo;invalid&amp;rdquo;. Such indexes are useless but it can be convenient to use &lt;code&gt;REINDEX&lt;/code&gt; to rebuild them. Note that only &lt;code&gt;REINDEX INDEX&lt;/code&gt; is able to perform a concurrent build on an invalid index.</source>
          <target state="translated">&lt;code&gt;CONCURRENTLY&lt;/code&gt; オプションを使用してインデックスの作成が失敗した場合、このインデックスは「無効」のままになります。このようなインデックスは &lt;code&gt;REINDEX&lt;/code&gt; 、REINDEXを使用してインデックスを再構築すると便利です。 &lt;code&gt;REINDEX INDEX&lt;/code&gt; のみが無効なインデックスで並行ビルドを実行できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="2ce1cc9d13f2dd4c882f2d9159dd6b972278963b" translate="yes" xml:space="preserve">
          <source>If an option is specified that is valid, but not relevant to the selected operating mode, pg_ctl ignores it.</source>
          <target state="translated">有効なオプションが指定されているが、選択された動作モードには関係ない場合、pg_ctlはそれを無視します。</target>
        </trans-unit>
        <trans-unit id="af23873c246a8a5e4a8cad331942f631fec99b40" translate="yes" xml:space="preserve">
          <source>If an unquoted colon (&lt;code&gt;:&lt;/code&gt;) followed by a psql variable name appears within an argument, it is replaced by the variable's value, as described in &lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL Interpolation&lt;/a&gt;. The forms &lt;code&gt;:'variable_name'&lt;/code&gt; and &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; described there work as well. The &lt;code&gt;:{?variable_name}&lt;/code&gt; syntax allows testing whether a variable is defined. It is substituted by TRUE or FALSE. Escaping the colon with a backslash protects it from substitution.</source>
          <target state="translated">（引用符で囲まれていないが、コロン場合 &lt;code&gt;:&lt;/code&gt; ）psqlの変数名に続く引数の中に現れるで説明したように、それは、変数の値によって置き換えられる&lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL補間&lt;/a&gt;。そこに記述されている &lt;code&gt;:'variable_name'&lt;/code&gt; および &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; という形式も機能します。 &lt;code&gt;:{?variable_name}&lt;/code&gt; 構文は、変数が定義されているかどうかをテストすることができます。TRUEまたはFALSEに置き換えられます。コロンをバックスラッシュでエスケープすると、コロンが置換されなくなります。</target>
        </trans-unit>
        <trans-unit id="e21ea67d0d720310272c7536aaef9fbd409c780b" translate="yes" xml:space="preserve">
          <source>If an upstream standby server is promoted to become new master, downstream servers will continue to stream from the new master if &lt;code&gt;recovery_target_timeline&lt;/code&gt; is set to &lt;code&gt;'latest'&lt;/code&gt; (the default).</source>
          <target state="translated">アップストリームスタンバイサーバーが新しいマスターに昇格した場合、 &lt;code&gt;recovery_target_timeline&lt;/code&gt; が &lt;code&gt;'latest'&lt;/code&gt; （デフォルト）に設定されていれば、ダウンストリームサーバーは引き続き新しいマスターからストリーミングします。</target>
        </trans-unit>
        <trans-unit id="3bd7c108b9d4e211b151f51193b945c5454b1371" translate="yes" xml:space="preserve">
          <source>If any dimension is written as a slice, i.e., contains a colon, then all dimensions are treated as slices. Any dimension that has only a single number (no colon) is treated as being from 1 to the number specified. For example, &lt;code&gt;[2]&lt;/code&gt; is treated as &lt;code&gt;[1:2]&lt;/code&gt;, as in this example:</source>
          <target state="translated">ディメンションがスライスとして記述されている場合、つまりコロンが含まれている場合、すべてのディメンションはスライスとして扱われます。数値が1つしかない（コロンがない）ディメンションは、1から指定した数値までとして扱われます。たとえば、次の例のように、 &lt;code&gt;[2]&lt;/code&gt; は &lt;code&gt;[1:2]&lt;/code&gt; として扱われます。</target>
        </trans-unit>
        <trans-unit id="644d831a9e7d5bb7b9cf967c049a8eb98186cce0" translate="yes" xml:space="preserve">
          <source>If any input argument is of a domain type, treat it as being of the domain's base type for all subsequent steps. This ensures that domains act like their base types for purposes of ambiguous-function resolution.</source>
          <target state="translated">入力引数がドメイン型の場合、それ以降のすべてのステップでドメインのベース型として扱います。これにより、曖昧関数の解決のためにドメインがそのベース型と同じように動作することが保証されます。</target>
        </trans-unit>
        <trans-unit id="aa9d9b8570b39bd99c0391cf769b6b9a97f8cfdc" translate="yes" xml:space="preserve">
          <source>If any input argument is of a domain type, treat it as being of the domain's base type for all subsequent steps. This ensures that domains act like their base types for purposes of ambiguous-operator resolution.</source>
          <target state="translated">入力引数がドメイン型の場合、それ以降のすべてのステップでドメインのベース型として扱います。これにより、曖昧な演算子の解決のために、ドメインがそのベース型と同じように動作することが保証されます。</target>
        </trans-unit>
        <trans-unit id="f08ac7bfcc7896ec3ccba829e9cc32f16385e939" translate="yes" xml:space="preserve">
          <source>If any input arguments are &lt;code&gt;unknown&lt;/code&gt;, check the type categories accepted at those argument positions by the remaining candidates. At each position, select the &lt;code&gt;string&lt;/code&gt; category if any candidate accepts that category. (This bias towards string is appropriate since an unknown-type literal looks like a string.) Otherwise, if all the remaining candidates accept the same type category, select that category; otherwise fail because the correct choice cannot be deduced without more clues. Now discard candidates that do not accept the selected type category. Furthermore, if any candidate accepts a preferred type in that category, discard candidates that accept non-preferred types for that argument. Keep all candidates if none survive these tests. If only one candidate remains, use it; else continue to the next step.</source>
          <target state="translated">&lt;code&gt;unknown&lt;/code&gt; な入力引数がある場合は、残りの候補がそれらの引数位置で受け入れた型カテゴリーを確認してください。各位置で、 &lt;code&gt;string&lt;/code&gt; 選択します候補者がそのカテゴリを受け入れる場合、カテゴリ。（不明なタイプのリテラルはストリングのように見えるため、ストリングに対するこのバイアスは適切です。）それ以外の場合、残りのすべての候補が同じタイプのカテゴリーを受け入れる場合は、そのカテゴリーを選択します。それ以外の場合は、手がかりがなければ正しい選択を導き出すことができないため失敗します。次に、選択したタイプのカテゴリーを受け入れない候補を破棄します。さらに、候補がそのカテゴリの優先タイプを受け入れる場合、その引数の非優先タイプを受け入れる候補を破棄します。これらのテストに合格しなかった場合は、すべての候補者を保持します。候補が1つだけ残っている場合は、それを使用します。それ以外の場合は、次のステップに進みます。</target>
        </trans-unit>
        <trans-unit id="88a4eb3b7b2c17b935f14a3d49969dbb3c987944" translate="yes" xml:space="preserve">
          <source>If any input expression has an explicit collation derivation, then all explicitly derived collations among the input expressions must be the same, otherwise an error is raised. If any explicitly derived collation is present, that is the result of the collation combination.</source>
          <target state="translated">いずれかの入力式が明示的な照合の派生を持つ場合、入力式の中で明示的に派生した照合はすべて同じでなければならず、そうでない場合はエラーが発生します。明示的に導出された照合が存在する場合、それは照合の組み合わせの結果です。</target>
        </trans-unit>
        <trans-unit id="d5b589b0a29736a2c76abe777e082206c27d9542" translate="yes" xml:space="preserve">
          <source>If any input is of a domain type, treat it as being of the domain's base type for all subsequent steps. &lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[12]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">入力がドメインタイプである場合は、後続のすべてのステップでドメインの基本タイプとして入力を扱います。&lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[12]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="062ef5413f1971acdecb4ea39fded859da884ac5" translate="yes" xml:space="preserve">
          <source>If any of &lt;code&gt;GROUPING SETS&lt;/code&gt;, &lt;code&gt;ROLLUP&lt;/code&gt; or &lt;code&gt;CUBE&lt;/code&gt; are present as grouping elements, then the &lt;code&gt;GROUP BY&lt;/code&gt; clause as a whole defines some number of independent &lt;code&gt;grouping sets&lt;/code&gt;. The effect of this is equivalent to constructing a &lt;code&gt;UNION ALL&lt;/code&gt; between subqueries with the individual grouping sets as their &lt;code&gt;GROUP BY&lt;/code&gt; clauses. For further details on the handling of grouping sets see &lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;Section 7.2.4&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;GROUPING SETS&lt;/code&gt; 、 &lt;code&gt;ROLLUP&lt;/code&gt; 、または &lt;code&gt;CUBE&lt;/code&gt; のいずれかがグループ化要素として存在する場合、 &lt;code&gt;GROUP BY&lt;/code&gt; 句は全体として、いくつかの独立した &lt;code&gt;grouping sets&lt;/code&gt; を定義します。これの効果は、個々のグループ化セットを &lt;code&gt;GROUP BY&lt;/code&gt; 句として使用して、サブクエリ間に &lt;code&gt;UNION ALL&lt;/code&gt; を構築することと同じです。グループ化セットの処理の詳細については、&lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;セクション7.2.4を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ee7daf9476f8c0077c19fa91e9fc5b6d1dd5a0b5" translate="yes" xml:space="preserve">
          <source>If any of the child tables are foreign tables whose foreign data wrappers do not support &lt;code&gt;ANALYZE&lt;/code&gt;, those child tables are ignored while gathering inheritance statistics.</source>
          <target state="translated">子テーブルのいずれかが、外部データラッパーが &lt;code&gt;ANALYZE&lt;/code&gt; をサポートしない外部テーブルである場合、継承統計の収集中、それらの子テーブルは無視されます。</target>
        </trans-unit>
        <trans-unit id="5559a39fd47d326a14a46d78afa053af9afa62f6" translate="yes" xml:space="preserve">
          <source>If any of the columns of a table are TOAST-able, the table will have an associated TOAST table, whose OID is stored in the table's &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltoastrelid&lt;/code&gt; entry. On-disk TOASTed values are kept in the TOAST table, as described in more detail below.</source>
          <target state="translated">テーブルのいずれかの列がTOAST対応である場合、テーブルには関連するTOASTテーブルがあり、そのOIDはテーブルの &lt;code&gt;pg_class&lt;/code&gt; に保存されます。 &lt;code&gt;reltoastrelid&lt;/code&gt; エントリ。ディスク上でTOASTされた値は、以下で詳しく説明するように、TOASTテーブルに保持されます。</target>
        </trans-unit>
        <trans-unit id="cf49cd2bc67ee3c3481f1ffe2933861356e2738f" translate="yes" xml:space="preserve">
          <source>If any of the tables referenced by the view are temporary, the view is created as a temporary view (whether &lt;code&gt;TEMPORARY&lt;/code&gt; is specified or not).</source>
          <target state="translated">ビューによって参照されるテーブルのいずれかが一時的なものである場合、ビューは一時的なビューとして作成されます（ &lt;code&gt;TEMPORARY&lt;/code&gt; が指定されているかどうかに関係なく）。</target>
        </trans-unit>
        <trans-unit id="e74c2195dcb53833cfc91730aac90c474163ed9c" translate="yes" xml:space="preserve">
          <source>If any post-upgrade processing is required, pg_upgrade will issue warnings as it completes. It will also generate script files that must be run by the administrator. The script files will connect to each database that needs post-upgrade processing. Each script should be run using:</source>
          <target state="translated">アップグレード後の処理が必要な場合、pg_upgradeはそれが完了すると警告を発します。また、管理者が実行しなければならないスクリプトファイルも生成されます。このスクリプトファイルは、アップグレード後の処理が必要な各データベースに接続します。各スクリプトは、以下を使用して実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="800a2d135577a55dc7316ea712cf7f6d1165ae24" translate="yes" xml:space="preserve">
          <source>If archive storage size is a concern, you can use gzip to compress the archive files:</source>
          <target state="translated">アーカイブの保存サイズが気になる場合は、gzipを使ってアーカイブファイルを圧縮することができます。</target>
        </trans-unit>
        <trans-unit id="2e48896c1f0ace93b93a8656d8514a4835072596" translate="yes" xml:space="preserve">
          <source>If at all possible, &lt;em&gt;do not&lt;/em&gt; use &lt;code&gt;SIGKILL&lt;/code&gt; to kill the main &lt;code&gt;postgres&lt;/code&gt; server. Doing so will prevent &lt;code&gt;postgres&lt;/code&gt; from freeing the system resources (e.g., shared memory and semaphores) that it holds before terminating. This might cause problems for starting a fresh &lt;code&gt;postgres&lt;/code&gt; run.</source>
          <target state="translated">可能であれば、 &lt;code&gt;SIGKILL&lt;/code&gt; を使用してメインの &lt;code&gt;postgres&lt;/code&gt; サーバーを終了&lt;em&gt;しない&lt;/em&gt;で&lt;em&gt;ください&lt;/em&gt;。そうすることで、 &lt;code&gt;postgres&lt;/code&gt; が終了前に保持していたシステムリソース（共有メモリやセマフォなど）を解放できなくなります。これにより、新しい &lt;code&gt;postgres&lt;/code&gt; 実行を開始するときに問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ed12d9d5c43a1c95cedd4f159ed6ce3a1940c1ed" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;OFFSET&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt; appear, then &lt;code&gt;OFFSET&lt;/code&gt; rows are skipped before starting to count the &lt;code&gt;LIMIT&lt;/code&gt; rows that are returned.</source>
          <target state="translated">&lt;code&gt;OFFSET&lt;/code&gt; と &lt;code&gt;LIMIT&lt;/code&gt; の両方が表示される場合、返される &lt;code&gt;LIMIT&lt;/code&gt; 行のカウントを開始する前に、 &lt;code&gt;OFFSET&lt;/code&gt; 行がスキップされます。</target>
        </trans-unit>
        <trans-unit id="d1beaf85265bd8e8de4c00a803a4295f898d6a9d" translate="yes" xml:space="preserve">
          <source>If both standard input and standard output are a terminal, then psql sets the client encoding to &amp;ldquo;auto&amp;rdquo;, which will detect the appropriate client encoding from the locale settings (&lt;code&gt;LC_CTYPE&lt;/code&gt; environment variable on Unix systems). If this doesn't work out as expected, the client encoding can be overridden using the environment variable &lt;code&gt;PGCLIENTENCODING&lt;/code&gt;.</source>
          <target state="translated">標準入力と標準出力の両方がターミナルである場合、psqlはクライアントエンコーディングを「auto」に設定します。これにより、ロケール設定（UNIXシステムの &lt;code&gt;LC_CTYPE&lt;/code&gt; 環境変数）から適切なクライアントエンコーディングが検出されます。これが期待どおりに機能しない場合は、環境変数 &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; を使用してクライアントのエンコードをオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="124d332dfa6ef76e2334514ac990a431fc574564" translate="yes" xml:space="preserve">
          <source>If cascaded replication is in use the feedback is passed upstream until it eventually reaches the primary. Standbys make no other use of feedback they receive other than to pass upstream.</source>
          <target state="translated">カスケードレプリケーションを使用している場合、フィードバックは最終的にプライマリに到達するまで上流に渡されます。スタンバイは、受信したフィードバックをアップストリームに渡す以外には使用しません。</target>
        </trans-unit>
        <trans-unit id="21ad797b1873a315d3fc0d5c790db4d1476ce970" translate="yes" xml:space="preserve">
          <source>If case-independent matching is specified, the effect is much as if all case distinctions had vanished from the alphabet. When an alphabetic that exists in multiple cases appears as an ordinary character outside a bracket expression, it is effectively transformed into a bracket expression containing both cases, e.g., &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;[xX]&lt;/code&gt;. When it appears inside a bracket expression, all case counterparts of it are added to the bracket expression, e.g., &lt;code&gt;[x]&lt;/code&gt; becomes &lt;code&gt;[xX]&lt;/code&gt; and &lt;code&gt;[^x]&lt;/code&gt; becomes &lt;code&gt;[^xX]&lt;/code&gt;.</source>
          <target state="translated">大文字と小文字を区別しない一致が指定されている場合、効果はすべての大文字と小文字の区別がアルファベットから消えたかのようになります。複数のケースに存在するアルファベットがブラケット式の外の通常の文字として表示される場合、それは両方のケースを含むブラケット式に効果的に変換されます。たとえば、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;[xX]&lt;/code&gt; になります。括弧式の内側にある場合、対応するすべての大文字小文字が括弧式に追加されます。たとえば、 &lt;code&gt;[x]&lt;/code&gt; は &lt;code&gt;[xX]&lt;/code&gt; になり、 &lt;code&gt;[^x]&lt;/code&gt; は &lt;code&gt;[^xX]&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="cf258208ab5152d2c12b1e28ed793831fd7c461c" translate="yes" xml:space="preserve">
          <source>If column aliases are not supplied, then for a function returning a base data type, the column name is also the same as the function name. For a function returning a composite type, the result columns get the names of the individual attributes of the type.</source>
          <target state="translated">カラムのエイリアスが指定されていない場合、ベース・データ型を返す関数では、カラム名も関数名と同じになります。複合型を返す関数の場合、結果のカラムはその型の個々の属性の名前を取得します。</target>
        </trans-unit>
        <trans-unit id="6deaaf1ae6fdc8847b55dec525d8c4461d71750b" translate="yes" xml:space="preserve">
          <source>If consistent response time is more important than update speed, use of pending entries can be disabled by turning off the &lt;code&gt;fastupdate&lt;/code&gt; storage parameter for a GIN index. See &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; for details.</source>
          <target state="translated">更新速度よりも一貫した応答時間が重要な場合は、GINインデックスの &lt;code&gt;fastupdate&lt;/code&gt; ストレージパラメータをオフにすることで、保留中のエントリの使用を無効にできます。詳細については、&lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="41ef4d0c1740eb702f05dcbd27c8d877f11fcd3a" translate="yes" xml:space="preserve">
          <source>If csvlog is included in &lt;code&gt;log_destination&lt;/code&gt;, log entries are output in &amp;ldquo;comma separated value&amp;rdquo; (CSV) format, which is convenient for loading logs into programs. See &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-CSVLOG&quot;&gt;Section 19.8.4&lt;/a&gt; for details. &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt; must be enabled to generate CSV-format log output.</source>
          <target state="translated">csvlogがlog_destinationに含まれている &lt;code&gt;log_destination&lt;/code&gt; 、ログエントリは「カンマ区切り値」（CSV）形式で出力されます。これは、ログをプログラムにロードするのに便利です。詳細は&lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-CSVLOG&quot;&gt;項19.8.4&lt;/a&gt;を参照してください。CSV形式のログ出力を生成するには、&lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collectorを&lt;/a&gt;有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="ed1042acfa5d378be31e2b80e8d7ffc7bef64f8e" translate="yes" xml:space="preserve">
          <source>If data checksums are enabled, hint bit updates are always WAL-logged and this setting is ignored. You can use this setting to test how much extra WAL-logging would occur if your database had data checksums enabled.</source>
          <target state="translated">データチェックサムが有効な場合、ヒントビットの更新は常にWAL-loggingされ、この設定は無視されます。この設定を使用して、データベースがデータチェックサムを有効にしている場合に、どれだけ余分なWAL-loggingが発生するかをテストすることができます。</target>
        </trans-unit>
        <trans-unit id="cf0a4beca9338b9c149bc626eda6f48fc9e5c025" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;toptag&lt;/code&gt; or &lt;code&gt;itemtag&lt;/code&gt; is an empty string, the relevant tag is omitted.</source>
          <target state="translated">&lt;code&gt;toptag&lt;/code&gt; または &lt;code&gt;itemtag&lt;/code&gt; のいずれかが空の文字列の場合、関連するタグは省略されます。</target>
        </trans-unit>
        <trans-unit id="b92d15119505820507c6255b9360f73a82ee471e" translate="yes" xml:space="preserve">
          <source>If executed during recovery, the &lt;code&gt;CHECKPOINT&lt;/code&gt; command will force a restartpoint (see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;) rather than writing a new checkpoint.</source>
          <target state="translated">リカバリ中に &lt;code&gt;CHECKPOINT&lt;/code&gt; コマンドを実行すると、新しいチェックポイントを書き込むのではなく、強制的にリスタートポイント（&lt;a href=&quot;wal-configuration&quot;&gt;セクション29.4を&lt;/a&gt;参照）が作成されます。</target>
        </trans-unit>
        <trans-unit id="61ea49c86b3b55d886450b38a9cc42e4e9c69fce" translate="yes" xml:space="preserve">
          <source>If false then no one can connect to this database.</source>
          <target state="translated">falseの場合、誰もこのデータベースに接続できません。</target>
        </trans-unit>
        <trans-unit id="67f61dc72a1244f231103433b1246606e94298b4" translate="yes" xml:space="preserve">
          <source>If false then no one can connect to this database. The default is true, allowing connections (except as restricted by other mechanisms, such as &lt;code&gt;GRANT&lt;/code&gt;/&lt;code&gt;REVOKE CONNECT&lt;/code&gt;).</source>
          <target state="translated">falseの場合、誰もこのデータベースに接続できません。デフォルトはtrueで、接続を許可します（ &lt;code&gt;GRANT&lt;/code&gt; / &lt;code&gt;REVOKE CONNECT&lt;/code&gt; などの他のメカニズムによって制限されている場合を除く）。</target>
        </trans-unit>
        <trans-unit id="068609549b5f3904794ff7927c8befaac0ac4357" translate="yes" xml:space="preserve">
          <source>If false then no one can connect to this database. This is used to protect the &lt;code&gt;template0&lt;/code&gt; database from being altered.</source>
          <target state="translated">falseの場合、誰もこのデータベースに接続できません。これは、 &lt;code&gt;template0&lt;/code&gt; データベースが変更されないように保護するために使用されます。</target>
        </trans-unit>
        <trans-unit id="5279e693a4509d44588c8398060bdbb7e4662f3c" translate="yes" xml:space="preserve">
          <source>If false, the index is in process of being dropped, and should be ignored for all purposes (including HOT-safety decisions)</source>
          <target state="translated">虚偽の場合、インデックスは落下中であり、あらゆる目的(HOT-安全判断を含む)で無視されるべきである。</target>
        </trans-unit>
        <trans-unit id="024b18cb2d326ba0157f9b09e5a42b7967d00fb4" translate="yes" xml:space="preserve">
          <source>If fewer column aliases are specified than the actual table has columns, the remaining columns are not renamed. This syntax is especially useful for self-joins or subqueries.</source>
          <target state="translated">実際のテーブルに列があるよりも少ない列エイリアスが指定された場合、残りの列は名前が変更されません。この構文は、自己結合やサブクエリの場合に特に便利です。</target>
        </trans-unit>
        <trans-unit id="8ab96b15ba19344208a4881ae65df7268a6bcc7d" translate="yes" xml:space="preserve">
          <source>If for some reason autovacuum fails to clear old XIDs from a table, the system will begin to emit warning messages like this when the database's oldest XIDs reach ten million transactions from the wraparound point:</source>
          <target state="translated">何らかの理由でautovacuumがテーブルから古いXIDをクリアできなかった場合、データベースの最も古いXIDがラップアラウンドポイントから1,000万トランザクションに達すると、システムはこのような警告メッセージを発し始めます。</target>
        </trans-unit>
        <trans-unit id="80fa6f646b83284df410a911e1de501df6e5b069" translate="yes" xml:space="preserve">
          <source>If forcing index usage does use the index, then there are two possibilities: Either the system is right and using the index is indeed not appropriate, or the cost estimates of the query plans are not reflecting reality. So you should time your query with and without indexes. The &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; command can be useful here.</source>
          <target state="translated">インデックスの使用を強制してもインデックスが使用される場合は、2つの可能性があります。システムが正しく、インデックスの使用が実際に適切でないか、クエリプランのコスト見積もりが現実を反映していないかのいずれかです。したがって、インデックスを使用する場合と使用しない場合のクエリの時間を調整する必要があります。ここでは &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; コマンドが役立ちます。</target>
        </trans-unit>
        <trans-unit id="360561360313d63c949a4bb8b50e6444752b1851" translate="yes" xml:space="preserve">
          <source>If four or six digits and a year has already been read, then interpret as a time (&lt;code&gt;HHMM&lt;/code&gt; or &lt;code&gt;HHMMSS&lt;/code&gt;).</source>
          <target state="translated">4桁または6桁で年がすでに読み取られている場合は、時刻として解釈されます（ &lt;code&gt;HHMM&lt;/code&gt; または &lt;code&gt;HHMMSS&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="42c28f0a9935826074d643ae6e75e6be762517ad" translate="yes" xml:space="preserve">
          <source>If given, createuser will issue a prompt for the password of the new user. This is not necessary if you do not plan on using password authentication.</source>
          <target state="translated">指定された場合、createuser は新しいユーザーのパスワードのプロンプトを発行します。これは、パスワード認証を使用する予定がない場合には必要ありません。</target>
        </trans-unit>
        <trans-unit id="95adc82bd644fa7ad31393ac2f57ca7d35f902fd" translate="yes" xml:space="preserve">
          <source>If greater than zero, the estimated number of distinct values in the column. If less than zero, the negative of the number of distinct values divided by the number of rows. (The negated form is used when &lt;code&gt;ANALYZE&lt;/code&gt; believes that the number of distinct values is likely to increase as the table grows; the positive form is used when the column seems to have a fixed number of possible values.) For example, -1 indicates a unique column in which the number of distinct values is the same as the number of rows.</source>
          <target state="translated">ゼロより大きい場合、列内の個別値の推定数。ゼロ未満の場合、個別値の数を行数で割った負数。（ &lt;code&gt;ANALYZE&lt;/code&gt; がテーブルの増加に伴って異なる値の数が増える可能性があるとANALYZEが信じる場合に、否定形式が使用されます。列が可能な値の固定数を持っていると思われる場合、正の形式が使用されます。）たとえば、-1は、個別の値の数が行の数と同じである一意の列。</target>
        </trans-unit>
        <trans-unit id="b21def7d275563964950f72033030facdc8caa8d" translate="yes" xml:space="preserve">
          <source>If indexing numbers, we can remove some fractional digits to reduce the range of possible numbers, so for example &lt;em&gt;3.14&lt;/em&gt;159265359, &lt;em&gt;3.14&lt;/em&gt;15926, &lt;em&gt;3.14&lt;/em&gt; will be the same after normalization if only two digits are kept after the decimal point.</source>
          <target state="translated">数字のインデックスを作成した場合、我々は可能な数値の範囲を減らすために、いくつかの小数点以下の桁を削除することができますので、例えば&lt;em&gt;3.14&lt;/em&gt; 159265359、&lt;em&gt;3.14&lt;/em&gt; 15926、&lt;em&gt;3.14は&lt;/em&gt; 2桁のみが小数点以下に保持されている場合は、正規化後も同じになります。</target>
        </trans-unit>
        <trans-unit id="76133018bd86f9f10167401dc275f9ef001f11b2" translate="yes" xml:space="preserve">
          <source>If inverse partial newline-sensitive matching is specified, this affects &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; as with newline-sensitive matching, but not &lt;code&gt;.&lt;/code&gt; and bracket expressions. This isn't very useful but is provided for symmetry.</source>
          <target state="translated">部分的に改行を区別する逆マッチングが指定されている場合、これは、改行を区別するマッチングと同様に &lt;code&gt;^&lt;/code&gt; および &lt;code&gt;$&lt;/code&gt; に影響しますが、には影響しません &lt;code&gt;.&lt;/code&gt; とブラケット式。これはあまり役に立ちませんが、対称性のために提供されています。</target>
        </trans-unit>
        <trans-unit id="c82c509d031e15398bd7fe00861081d6405c8be4" translate="yes" xml:space="preserve">
          <source>If it turns out that the cost estimates are wrong, there are, again, two possibilities. The total cost is computed from the per-row costs of each plan node times the selectivity estimate of the plan node. The costs estimated for the plan nodes can be adjusted via run-time parameters (described in &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;). An inaccurate selectivity estimate is due to insufficient statistics. It might be possible to improve this by tuning the statistics-gathering parameters (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">コストの見積もりが間違っていることが判明した場合も、2つの可能性があります。合計コストは、各計画ノードの行ごとのコストに計画ノードの選択性推定を掛けたものから計算されます。計画ノードに対して見積もられたコストは、実行時パラメータを介して調整できます（&lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;セクション19.7.2で&lt;/a&gt;説明）。不正確な選択性推定は、統計が不十分なためです。統計収集パラメーターを調整することで、これを改善できる可能性があります（&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLEを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="18729ccb1c4146c8bab4ae3596759dabf5573ab7" translate="yes" xml:space="preserve">
          <source>If locale support doesn't work according to the explanation above, check that the locale support in your operating system is correctly configured. To check what locales are installed on your system, you can use the command &lt;code&gt;locale -a&lt;/code&gt; if your operating system provides it.</source>
          <target state="translated">上記の説明に従ってロケールサポートが機能しない場合は、オペレーティングシステムのロケールサポートが正しく構成されていることを確認してください。システムにインストールされているロケールを確認するには、オペレーティングシステムで提供されている場合は、コマンド &lt;code&gt;locale -a&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="742c773e01d7235a3ab536311ea18ceb446289e6" translate="yes" xml:space="preserve">
          <source>If making a backup, make sure that your database is not being updated. This does not affect the integrity of the backup, but the changed data would of course not be included. If necessary, edit the permissions in the file &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; (or equivalent) to disallow access from everyone except you. See &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt; for additional information on access control.</source>
          <target state="translated">バックアップを作成する場合は、データベースが更新されていないことを確認してください。これはバックアップの整合性には影響しませんが、変更されたデータはもちろん含まれません。必要に応じて、ファイル &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; （または同等のファイル）の権限を編集して、自分以外の全員からのアクセスを禁止します。アクセス制御の詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;第20章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c0a6e1d7bfcacfaf25b4fbb67794def2eb6d19f0" translate="yes" xml:space="preserve">
          <source>If more flexibility in copying the backup files is needed, a lower level process can be used for standalone hot backups as well. To prepare for low level standalone hot backups, make sure &lt;code&gt;wal_level&lt;/code&gt; is set to &lt;code&gt;replica&lt;/code&gt; or higher, &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt;, and set up an &lt;code&gt;archive_command&lt;/code&gt; that performs archiving only when a &lt;em&gt;switch file&lt;/em&gt; exists. For example:</source>
          <target state="translated">バックアップファイルをより柔軟にコピーする必要がある場合は、スタンドアロンのホットバックアップにも低レベルのプロセスを使用できます。低レベルのスタンドアロンホットバックアップを準備するには、 &lt;code&gt;wal_level&lt;/code&gt; を &lt;code&gt;replica&lt;/code&gt; 以上に設定し、 &lt;code&gt;archive_mode&lt;/code&gt; を &lt;code&gt;on&lt;/code&gt; に設定し、&lt;em&gt;スイッチファイル&lt;/em&gt;が存在する場合にのみアーカイブを実行する &lt;code&gt;archive_command&lt;/code&gt; を設定し&lt;em&gt;ます&lt;/em&gt;。例えば：</target>
        </trans-unit>
        <trans-unit id="b849cfa2234fdad4226b42e149aff052e2ec6ceb" translate="yes" xml:space="preserve">
          <source>If more than one flag bit is specified, the transformations are applied in the order listed.</source>
          <target state="translated">複数のフラグビットが指定された場合、変換はリストされた順に適用されます。</target>
        </trans-unit>
        <trans-unit id="b8368877f8014c70dc2f0a265b592212cfc0ddc8" translate="yes" xml:space="preserve">
          <source>If more than one leaf tuple is supplied, it is expected that the &lt;code&gt;picksplit&lt;/code&gt; function will classify them into more than one node; otherwise it is not possible to split the leaf tuples across multiple pages, which is the ultimate purpose of this operation. Therefore, if the &lt;code&gt;picksplit&lt;/code&gt; function ends up placing all the leaf tuples in the same node, the core SP-GiST code will override that decision and generate an inner tuple in which the leaf tuples are assigned at random to several identically-labeled nodes. Such a tuple is marked &lt;code&gt;allTheSame&lt;/code&gt; to signify that this has happened. The &lt;code&gt;choose&lt;/code&gt; and &lt;code&gt;inner_consistent&lt;/code&gt; functions must take suitable care with such inner tuples. See &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt; for more information.</source>
          <target state="translated">複数の &lt;code&gt;picksplit&lt;/code&gt; が指定されている場合、picksplit関数がそれらを複数のノードに分類すると予想されます。それ以外の場合、リーフタプルを複数のページに分割することはできません。これがこの操作の最終的な目的です。したがって、 &lt;code&gt;picksplit&lt;/code&gt; 関数がすべてのリーフタプルを同じノードに配置する場合、コアのSP-GiSTコードはその決定をオーバーライドし、リーフタプルが同じラベルの付いた複数のノードにランダムに割り当てられる内部タプルを生成します。このようなタプルには &lt;code&gt;allTheSame&lt;/code&gt; のマークが付けられ、これが発生したことを示します。 &lt;code&gt;choose&lt;/code&gt; と &lt;code&gt;inner_consistent&lt;/code&gt; 機能は、このような内部タプルで、適切な世話をする必要があります。&lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;セクション65.4.3を&lt;/a&gt;参照 詳細については。</target>
        </trans-unit>
        <trans-unit id="e1854b837fa3254f90682ac28255cbd702178269" translate="yes" xml:space="preserve">
          <source>If more than one option is given, the information is printed in that order, one item per line. If no options are given, all available information is printed, with labels.</source>
          <target state="translated">複数のオプションが与えられた場合、情報はその順番で印刷され、1 行に 1 つの項目が表示されます。オプションが与えられていない場合は、利用可能なすべての情報がラベル付きで印刷されます。</target>
        </trans-unit>
        <trans-unit id="f1a02345ba89ad66d10fbdabf34539cb6dd7d98c" translate="yes" xml:space="preserve">
          <source>If more than one table has a column of the same name, the table name must also be given, as in:</source>
          <target state="translated">のように、複数のテーブルに同じ名前のカラムがある場合は、テーブル名も指定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="dd5e9dbc9005fdf88d98048279bb5e957015fc29" translate="yes" xml:space="preserve">
          <source>If multiple CPUs are available in the database server, consider using pg_restore's &lt;code&gt;--jobs&lt;/code&gt; option. This allows concurrent data loading and index creation.</source>
          <target state="translated">データベースサーバーで複数のCPUが使用可能な場合は、pg_restoreの &lt;code&gt;--jobs&lt;/code&gt; オプションの使用を検討してください。これにより、データのロードとインデックスの同時作成が可能になります。</target>
        </trans-unit>
        <trans-unit id="87fac9519c05562bef87a4e35aa2a859278b1c40" translate="yes" xml:space="preserve">
          <source>If multiple grouping items are specified in a single &lt;code&gt;GROUP BY&lt;/code&gt; clause, then the final list of grouping sets is the cross product of the individual items. For example:</source>
          <target state="translated">1つの &lt;code&gt;GROUP BY&lt;/code&gt; 句で複数のグループ化項目が指定されている場合、グループ化セットの最終的なリストは、個々の項目の外積です。例えば：</target>
        </trans-unit>
        <trans-unit id="b80b5e3c45aa43e720ac77a6f9a3ef8d195c588d" translate="yes" xml:space="preserve">
          <source>If multiple savepoints have the same name, only the one that was most recently defined is released.</source>
          <target state="translated">複数のセーブポイントが同じ名前を持つ場合、最近定義されたものだけがリリースされます。</target>
        </trans-unit>
        <trans-unit id="9bb7ddb9b949ac875aa47f26b30ade97f88eab22" translate="yes" xml:space="preserve">
          <source>If multiple script files are specified, the averages are reported separately for each script file.</source>
          <target state="translated">複数のスクリプトファイルが指定された場合は、各スクリプトファイルごとに平均値が報告されます。</target>
        </trans-unit>
        <trans-unit id="e33be9af0afb6da142699266371977c598700dcd" translate="yes" xml:space="preserve">
          <source>If multiple triggers of the same kind are defined for the same event, they will be fired in alphabetical order by name.</source>
          <target state="translated">同じイベントに対して同じ種類の複数のトリガーが定義されている場合は、名前のアルファベット順で発行されます。</target>
        </trans-unit>
        <trans-unit id="65a4d92a17b0442c58eb3e977048325cf5830355" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;ALSO&lt;/code&gt; nor &lt;code&gt;INSTEAD&lt;/code&gt; is specified, &lt;code&gt;ALSO&lt;/code&gt; is the default.</source>
          <target state="translated">&lt;code&gt;ALSO&lt;/code&gt; も &lt;code&gt;INSTEAD&lt;/code&gt; も指定されていない場合、 &lt;code&gt;ALSO&lt;/code&gt; がデフォルトです。</target>
        </trans-unit>
        <trans-unit id="7e603a3b3a3e88af33582419d67e19ea60ef676f" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;FOR SEARCH&lt;/code&gt; nor &lt;code&gt;FOR ORDER BY&lt;/code&gt; is specified, &lt;code&gt;FOR SEARCH&lt;/code&gt; is the default.</source>
          <target state="translated">&lt;code&gt;FOR SEARCH&lt;/code&gt; も &lt;code&gt;FOR ORDER BY&lt;/code&gt; も指定されていない場合、 &lt;code&gt;FOR SEARCH&lt;/code&gt; がデフォルトです。</target>
        </trans-unit>
        <trans-unit id="5e9aa69e6e2804ffb3ebc122107e995dd5c9a00a" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;FOR TABLE&lt;/code&gt; nor &lt;code&gt;FOR ALL TABLES&lt;/code&gt; is specified, then the publication starts out with an empty set of tables. That is useful if tables are to be added later.</source>
          <target state="translated">&lt;code&gt;FOR TABLE&lt;/code&gt; も &lt;code&gt;FOR ALL TABLES&lt;/code&gt; も指定されていない場合、パブリケーションは空のテーブルセットで開始されます。これは、テーブルを後で追加する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="89d1b1553626d39b44b8a8db61a149cf8fdc3227" translate="yes" xml:space="preserve">
          <source>If newline-sensitive matching is specified, &lt;code&gt;.&lt;/code&gt; and bracket expressions using &lt;code&gt;^&lt;/code&gt; will never match the newline character (so that matches will never cross newlines unless the RE explicitly arranges it) and &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; will match the empty string after and before a newline respectively, in addition to matching at beginning and end of string respectively. But the ARE escapes &lt;code&gt;\A&lt;/code&gt; and &lt;code&gt;\Z&lt;/code&gt; continue to match beginning or end of string &lt;em&gt;only&lt;/em&gt;.</source>
          <target state="translated">改行を区別するマッチングが指定されている場合、 &lt;code&gt;.&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; を使用したブラケット式は、改行文字とは一致しません（REが明示的に配置しない限り、一致は改行と交差しません）。また、 &lt;code&gt;^&lt;/code&gt; と &lt;code&gt;$&lt;/code&gt; は、先頭と末尾の一致に加えて、改行の前後の空の文字列とそれぞれ一致します。それぞれ文字列の。ただし、AREエスケープ &lt;code&gt;\A&lt;/code&gt; および &lt;code&gt;\Z&lt;/code&gt; は、文字列の先頭または末尾&lt;em&gt;のみ&lt;/em&gt;に一致し続けます。</target>
        </trans-unit>
        <trans-unit id="eec0fa542613e1975aae2a48b92903dde3eacbb8" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;table_alias&lt;/code&gt; is specified, the function name is used as the table name; in the case of a &lt;code&gt;ROWS FROM()&lt;/code&gt; construct, the first function's name is used.</source>
          <target state="translated">&lt;code&gt;table_alias&lt;/code&gt; が指定されていない場合、関数名がテーブル名として使用されます。以下の場合には &lt;code&gt;ROWS FROM()&lt;/code&gt; 構築、最初の関数の名前が使用されます。</target>
        </trans-unit>
        <trans-unit id="5c82c2225e73852e8c357908e66b1d12e66520ab" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;weights&lt;/code&gt; are provided, then these defaults are used:</source>
          <target state="translated">&lt;code&gt;weights&lt;/code&gt; が指定されていない場合は、次のデフォルトが使用されます。</target>
        </trans-unit>
        <trans-unit id="0368275c8128ea23b2ee02837095ef288617003c" translate="yes" xml:space="preserve">
          <source>If no collation is explicitly specified, the database system either derives a collation from the columns involved in the expression, or it defaults to the default collation of the database if no column is involved in the expression.</source>
          <target state="translated">照合順序が明示的に指定されていない場合、データベースシステムは式に含まれる列から照合順序を導出するか、式に列が含まれていない場合はデータベースのデフォルトの照合順序をデフォルトにします。</target>
        </trans-unit>
        <trans-unit id="21307971878d081789f53c6ec3a32e0fa2a71500" translate="yes" xml:space="preserve">
          <source>If no default value is declared explicitly, the default value is the null value. This usually makes sense because a null value can be considered to represent unknown data.</source>
          <target state="translated">デフォルト値が明示的に宣言されていない場合、デフォルト値はNULL値となります。これは通常、NULL値が未知のデータを表すと考えられるため、意味のあることです。</target>
        </trans-unit>
        <trans-unit id="35149dcf4bfae750a59efc48da69e479e9799355" translate="yes" xml:space="preserve">
          <source>If no exact match is found, see if the function call appears to be a special type conversion request. This happens if the function call has just one argument and the function name is the same as the (internal) name of some data type. Furthermore, the function argument must be either an unknown-type literal, or a type that is binary-coercible to the named data type, or a type that could be converted to the named data type by applying that type's I/O functions (that is, the conversion is either to or from one of the standard string types). When these conditions are met, the function call is treated as a form of &lt;code&gt;CAST&lt;/code&gt; specification. &lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">完全に一致するものが見つからない場合は、関数呼び出しが特別な型変換要求であるかどうかを確認してください。これは、関数呼び出しの引数が1つだけで、関数名が一部のデータ型の（内部）名と同じ場合に発生します。さらに、関数の引数は、不明な型のリテラル、または名前付きデータ型にバイナリ強制変換できる型、またはその型のI / O関数を適用して名前付きデータ型に変換できる型（つまり、変換は、標準の文字列型の1つとの間で行われます。これらの条件が満たされると、関数呼び出しは &lt;code&gt;CAST&lt;/code&gt; 指定の形式として扱われます。&lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93b5e5aff6e0171effd161da742f968f9068eee6" translate="yes" xml:space="preserve">
          <source>If no explicit provision is made for a sign in &lt;code&gt;to_char()&lt;/code&gt;'s pattern, one column will be reserved for the sign, and it will be anchored to (appear just left of) the number. If &lt;code&gt;S&lt;/code&gt; appears just left of some &lt;code&gt;9&lt;/code&gt;'s, it will likewise be anchored to the number.</source>
          <target state="translated">&lt;code&gt;to_char()&lt;/code&gt; のパターンでサインが明示的に提供されていない場合、1つの列がサイン用に予約され、番号に固定されます（すぐ左に表示されます）。場合 &lt;code&gt;S&lt;/code&gt; は、単にいくつかの左に表示された &lt;code&gt;9&lt;/code&gt; さん、それは同様に、数に固定されます。</target>
        </trans-unit>
        <trans-unit id="6e409b417f72efc6d96ed16a0afc9bdc881a346a" translate="yes" xml:space="preserve">
          <source>If no function is specified, a blank &lt;code&gt;CREATE FUNCTION&lt;/code&gt; template is presented for editing.</source>
          <target state="translated">関数が指定されていない場合、空白の &lt;code&gt;CREATE FUNCTION&lt;/code&gt; テンプレートが編集用に表示されます。</target>
        </trans-unit>
        <trans-unit id="bfdbba53034a54f85542008e5a3f670d8b001aa1" translate="yes" xml:space="preserve">
          <source>If no lock mode is specified, then &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt;, the most restrictive mode, is used.</source>
          <target state="translated">ロックモードが指定されていない場合、最も制限的なモードである &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="e62fb9f6836054022a0013bdbc9afb997f69a82f" translate="yes" xml:space="preserve">
          <source>If no moving-aggregate implementation is supplied, the aggregate can still be used with moving frames, but PostgreSQL will recompute the whole aggregation whenever the start of the frame moves. Note that whether or not the aggregate supports moving-aggregate mode, PostgreSQL can handle a moving frame end without recalculation; this is done by continuing to add new values to the aggregate's state. This is why use of an aggregate as a window function requires that the final function be read-only: it must not damage the aggregate's state value, so that the aggregation can be continued even after an aggregate result value has been obtained for one set of frame boundaries.</source>
          <target state="translated">移動集約の実装が提供されていない場合、移動するフレームでも集約を使用することができますが、フレームの開始点が移動するたびにPostgreSQLは集約全体を再計算します。集約体が移動集約モードをサポートしているかどうかに関わらず、PostgreSQLは再計算を行わずに移動フレームの終了を扱うことができることに注意してください。これは、集合体の状態に新しい値を追加し続けることによって行われます。これが、集合体をウィンドウ関数として使用する場合、最終関数が読み取り専用であることを要求する理由です。</target>
        </trans-unit>
        <trans-unit id="f9d74d492594986bfbf1fc1386e105965c9b3fc3" translate="yes" xml:space="preserve">
          <source>If no output column name is specified using &lt;code&gt;AS&lt;/code&gt;, the system assigns a default column name. For simple column references, this is the name of the referenced column. For function calls, this is the name of the function. For complex expressions, the system will generate a generic name.</source>
          <target state="translated">&lt;code&gt;AS&lt;/code&gt; を使用して出力列名が指定されていない場合、システムはデフォルトの列名を割り当てます。単純な列参照の場合、これは参照される列の名前です。関数呼び出しの場合、これは関数の名前です。複雑な式の場合、システムは総称名を生成します。</target>
        </trans-unit>
        <trans-unit id="46eb45e8cda4a2fa8f3f15869002e910f361619b" translate="yes" xml:space="preserve">
          <source>If no role is specified, or the special user name &lt;code&gt;PUBLIC&lt;/code&gt; is used, then the policy applies to all users on the system. To allow all users to access only their own row in a &lt;code&gt;users&lt;/code&gt; table, a simple policy can be used:</source>
          <target state="translated">ロールが指定されていない場合、または特別なユーザー名 &lt;code&gt;PUBLIC&lt;/code&gt; が使用されている場合、ポリシーはシステム上のすべてのユーザーに適用されます。すべてのユーザーが &lt;code&gt;users&lt;/code&gt; テーブルの自分の行にのみアクセスできるようにするには、簡単なポリシーを使用できます。</target>
        </trans-unit>
        <trans-unit id="6d6b57e5927a5bed9026e109eaaf60a10bd5032f" translate="yes" xml:space="preserve">
          <source>If no synchronous standby names are specified here, then synchronous replication is not enabled and transaction commits will not wait for replication. This is the default configuration. Even when synchronous replication is enabled, individual transactions can be configured not to wait for replication by setting the &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; parameter to &lt;code&gt;local&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">ここで同期スタンバイ名が指定されていない場合、同期レプリケーションは有効にならず、トランザクションコミットはレプリケーションを待機しません。これがデフォルトの設定です。同期レプリケーションが有効な場合でも、&lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronized_commit&lt;/a&gt;パラメータを &lt;code&gt;local&lt;/code&gt; または &lt;code&gt;off&lt;/code&gt; に設定することで、個々のトランザクションがレプリケーションを待機しないように構成できます。</target>
        </trans-unit>
        <trans-unit id="b499f250be4863620a8af2772b67aa546566a3ec" translate="yes" xml:space="preserve">
          <source>If no table name is available, that is, when mapping a query or a cursor, the string &lt;code&gt;table&lt;/code&gt; is used in the first format, &lt;code&gt;row&lt;/code&gt; in the second format.</source>
          <target state="translated">使用可能なテーブル名がない場合、つまり、クエリまたはカーソルをマッピングする場合、文字列 &lt;code&gt;table&lt;/code&gt; は最初の形式で使用され、 &lt;code&gt;row&lt;/code&gt; は2番目の形式で使用されます。</target>
        </trans-unit>
        <trans-unit id="31cbf099df48b49708d8e3fe1c5398bc9eb2b4ff" translate="yes" xml:space="preserve">
          <source>If no tuples were deleted from the heap, B-tree indexes are still scanned at the &lt;code&gt;VACUUM&lt;/code&gt; cleanup stage when at least one of the following conditions is met: the index statistics are stale, or the index contains deleted pages that can be recycled during cleanup. Index statistics are considered to be stale if the number of newly inserted tuples exceeds the &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; fraction of the total number of heap tuples detected by the previous statistics collection. The total number of heap tuples is stored in the index meta-page. Note that the meta-page does not include this data until &lt;code&gt;VACUUM&lt;/code&gt; finds no dead tuples, so B-tree index scan at the cleanup stage can only be skipped if the second and subsequent &lt;code&gt;VACUUM&lt;/code&gt; cycles detect no dead tuples.</source>
          <target state="translated">ヒープからタプルが削除されなかった場合でも、次の条件の少なくとも1つが満たされた場合、 &lt;code&gt;VACUUM&lt;/code&gt; クリーンアップ段階でBツリーインデックスがスキャンされます。インデックス統計が古くなっている、またはインデックスに、クリーンアップ中にリサイクルできる削除済みページが含まれている。新しく挿入されたタプルの数が、前の統計コレクションによって検出された &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; の総数のvacuum_cleanup_index_scale_factorの割合を超える場合、インデックス統計は古くなったと見なされます。ヒープタプルの総数は、インデックスメタページに格納されます。 &lt;code&gt;VACUUM&lt;/code&gt; が無効なタプルを検出しない限り、メタページにはこのデータが含まれないことに注意してください。そのため、クリーンアップ段階でのBツリーインデックススキャンは、2番目以降の &lt;code&gt;VACUUM&lt;/code&gt; の場合にのみスキップできます。 サイクルはデッドタプルを検出しません。</target>
        </trans-unit>
        <trans-unit id="a50a96a1efd9e9515cc7402b6a1585dcf6707637" translate="yes" xml:space="preserve">
          <source>If no view is specified, a blank &lt;code&gt;CREATE VIEW&lt;/code&gt; template is presented for editing.</source>
          <target state="translated">ビューが指定されていない場合、空白の &lt;code&gt;CREATE VIEW&lt;/code&gt; テンプレートが編集用に表示されます。</target>
        </trans-unit>
        <trans-unit id="b168c695895a81115afb54900077dcd6394dd9a3" translate="yes" xml:space="preserve">
          <source>If not found, search an internal table to match the token as either a special string (e.g., &lt;code&gt;today&lt;/code&gt;), day (e.g., &lt;code&gt;Thursday&lt;/code&gt;), month (e.g., &lt;code&gt;January&lt;/code&gt;), or noise word (e.g., &lt;code&gt;at&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;).</source>
          <target state="translated">見つからない場合は、内部テーブルを検索して、トークンを特別な文字列（例： &lt;code&gt;today&lt;/code&gt; ）、日（例： &lt;code&gt;Thursday&lt;/code&gt; ）、月（例： &lt;code&gt;January&lt;/code&gt; ）、またはノイズワード（例： &lt;code&gt;at&lt;/code&gt; 、 &lt;code&gt;on&lt;/code&gt; ）として照合します。</target>
        </trans-unit>
        <trans-unit id="dc5b189453f6a7ea6efcd19711a7a024dd08877c" translate="yes" xml:space="preserve">
          <source>If not null, an error message indicating why this entry could not be applied</source>
          <target state="translated">nullでない場合は、このエントリが適用できなかった理由を示すエラーメッセージ。</target>
        </trans-unit>
        <trans-unit id="8da51845e78e415599c49039ce6e56d900436b63" translate="yes" xml:space="preserve">
          <source>If not null, an error message indicating why this line could not be processed</source>
          <target state="translated">null でない場合は、この行が処理できなかった理由を示すエラーメッセージ。</target>
        </trans-unit>
        <trans-unit id="96520540e7decec105d922c1561ef9f2b1d6ac9b" translate="yes" xml:space="preserve">
          <source>If on, any error will terminate the current session. By default, this is set to off, so that only FATAL errors will terminate the session.</source>
          <target state="translated">オンの場合、エラーがあれば現在のセッションを終了します。デフォルトでは、これはオフに設定されており、FATALエラーのみがセッションを終了するようになっています。</target>
        </trans-unit>
        <trans-unit id="22cc3fdc7c909051830d32f3a9f4757f2bc2a2b3" translate="yes" xml:space="preserve">
          <source>If on, emit WAL-related debugging output. This parameter is only available if the &lt;code&gt;WAL_DEBUG&lt;/code&gt; macro was defined when PostgreSQL was compiled.</source>
          <target state="translated">オンの場合、WAL関連のデバッグ出力を発行します。このパラメーターは、PostgreSQLのコンパイル時に &lt;code&gt;WAL_DEBUG&lt;/code&gt; マクロが定義されている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="ea0ac9e4d18cd146b0646e9f1eaaad11f3441b88" translate="yes" xml:space="preserve">
          <source>If on, emit information about lightweight lock usage. Lightweight locks are intended primarily to provide mutual exclusion of access to shared-memory data structures.</source>
          <target state="translated">オンの場合、軽量ロックの使用に関する情報を送信します。軽量ロックは、主に共有メモリデータ構造へのアクセスを相互に排除することを目的としています。</target>
        </trans-unit>
        <trans-unit id="108192b0a0e55fbd6c757081d9b7601d8b8f83e2" translate="yes" xml:space="preserve">
          <source>If on, emit information about lock usage. Information dumped includes the type of lock operation, the type of lock and the unique identifier of the object being locked or unlocked. Also included are bit masks for the lock types already granted on this object as well as for the lock types awaited on this object. For each lock type a count of the number of granted locks and waiting locks is also dumped as well as the totals. An example of the log file output is shown here:</source>
          <target state="translated">オンの場合、ロックの使用状況に関する情報を出力します。ダンプされる情報には、ロック操作のタイプ、ロックのタイプ、ロックまたはアンロックされているオブジェクトの一意の識別子が含まれます。また、このオブジェクトに既に付与されているロック・タイプと、このオブジェクトに待ち受けているロック・タイプのビット・マスクも含まれます。各ロック・タイプについて、付与されたロックと待機中のロックの数のカウントと合計がダンプされます。ログファイルの出力例を以下に示します。</target>
        </trans-unit>
        <trans-unit id="fb4d7f85e50d03eb97a6b576612fc80288cfa67e" translate="yes" xml:space="preserve">
          <source>If on, emit information about resource usage during sort operations. This parameter is only available if the &lt;code&gt;TRACE_SORT&lt;/code&gt; macro was defined when PostgreSQL was compiled. (However, &lt;code&gt;TRACE_SORT&lt;/code&gt; is currently defined by default.)</source>
          <target state="translated">オンの場合、ソート操作中にリソースの使用状況に関する情報を出力します。このパラメーターは、PostgreSQLのコンパイル時に &lt;code&gt;TRACE_SORT&lt;/code&gt; マクロが定義されている場合にのみ使用できます。（ただし、 &lt;code&gt;TRACE_SORT&lt;/code&gt; は現在デフォルトで定義されています。）</target>
        </trans-unit>
        <trans-unit id="2d6e32677420949906412ec403c3421f5aa432cd" translate="yes" xml:space="preserve">
          <source>If on, emit information about user lock usage. Output is the same as for &lt;code&gt;trace_locks&lt;/code&gt;, only for advisory locks.</source>
          <target state="translated">オンの場合、ユーザーロックの使用に関する情報を出力します。出力は &lt;code&gt;trace_locks&lt;/code&gt; の場合と同じですが、アドバイザリロックの場合のみです。</target>
        </trans-unit>
        <trans-unit id="aa31b9c1a7b9373a56b5ac2143c494c8a9df5d88" translate="yes" xml:space="preserve">
          <source>If one argument of a binary operator invocation is of the &lt;code&gt;unknown&lt;/code&gt; type and the other is of a domain type, next check to see if there is an operator accepting exactly the domain's base type on both sides; if so, use it.</source>
          <target state="translated">2項演算子呼び出しの1つの引数が &lt;code&gt;unknown&lt;/code&gt; タイプで、もう1つの引数がドメインタイプである場合、次に、両側でドメインの基本タイプを正確に受け入れる演算子があるかどうかを確認します。もしそうなら、それを使用してください。</target>
        </trans-unit>
        <trans-unit id="f194f32ef831d4b3157a47fd2652de25dffaf886" translate="yes" xml:space="preserve">
          <source>If one argument of a binary operator invocation is of the &lt;code&gt;unknown&lt;/code&gt; type, then assume it is the same type as the other argument for this check. Invocations involving two &lt;code&gt;unknown&lt;/code&gt; inputs, or a unary operator with an &lt;code&gt;unknown&lt;/code&gt; input, will never find a match at this step.</source>
          <target state="translated">2項演算子呼び出しの1つの引数が &lt;code&gt;unknown&lt;/code&gt; タイプである場合、このチェックのもう1つの引数と同じタイプであると想定します。2つの関わる呼び出し &lt;code&gt;unknown&lt;/code&gt; 入力、またはと単項演算子 &lt;code&gt;unknown&lt;/code&gt; 入力は、この段階で一致するものを見つけることはありません。</target>
        </trans-unit>
        <trans-unit id="b3677d43219ced3f6fdb380478ec70536347404f" translate="yes" xml:space="preserve">
          <source>If one explicitly casts a bit-string value to &lt;code&gt;bit(n)&lt;/code&gt;, it will be truncated or zero-padded on the right to be exactly &lt;code&gt;n&lt;/code&gt; bits, without raising an error. Similarly, if one explicitly casts a bit-string value to &lt;code&gt;bit varying(n)&lt;/code&gt;, it will be truncated on the right if it is more than &lt;code&gt;n&lt;/code&gt; bits.</source>
          <target state="translated">ビット文字列の値を明示的に &lt;code&gt;bit(n)&lt;/code&gt; にキャストすると、エラーが発生することなく、右側が切り捨てられるか、右側にゼロが埋め込まれ、正確に &lt;code&gt;n&lt;/code&gt; ビットになります。同様に、ビット文字列の値を明示的に &lt;code&gt;bit varying(n)&lt;/code&gt; にキャストする場合、 &lt;code&gt;n&lt;/code&gt; ビットを超えると、右側が切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="7d503789d22d34918cc5945f90261d6c003a05f3" translate="yes" xml:space="preserve">
          <source>If one explicitly casts a value to &lt;code&gt;character varying(n)&lt;/code&gt; or &lt;code&gt;character(n)&lt;/code&gt;, then an over-length value will be truncated to &lt;code&gt;n&lt;/code&gt; characters without raising an error. (This too is required by the SQL standard.)</source>
          <target state="translated">値を明示的に &lt;code&gt;character varying(n)&lt;/code&gt; または &lt;code&gt;character(n)&lt;/code&gt; にキャストすると、長すぎる値はエラーを発生させずに &lt;code&gt;n&lt;/code&gt; 文字に切り捨てられます。（これもSQL標準では必須です。）</target>
        </trans-unit>
        <trans-unit id="1de7610e41ebab1a246a8c49a8f76058b712b92e" translate="yes" xml:space="preserve">
          <source>If one of the list items is the special name &lt;code&gt;$user&lt;/code&gt;, then the schema having the name returned by &lt;code&gt;CURRENT_USER&lt;/code&gt; is substituted, if there is such a schema and the user has &lt;code&gt;USAGE&lt;/code&gt; permission for it. (If not, &lt;code&gt;$user&lt;/code&gt; is ignored.)</source>
          <target state="translated">リストアイテムの1つが特別な名前 &lt;code&gt;$user&lt;/code&gt; である場合、そのようなスキーマがあり、ユーザーがその &lt;code&gt;USAGE&lt;/code&gt; 権限を持っている場合、 &lt;code&gt;CURRENT_USER&lt;/code&gt; によって返された名前を持つスキーマに置き換えられます。（そうでない場合、 &lt;code&gt;$user&lt;/code&gt; は無視されます。）</target>
        </trans-unit>
        <trans-unit id="19441d8efa255c5a903fe7f3e4cb160f4e49f55a" translate="yes" xml:space="preserve">
          <source>If only the parser is specified, then the new text search configuration initially has no mappings from token types to dictionaries, and therefore will ignore all words. Subsequent &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; commands must be used to create mappings to make the configuration useful. Alternatively, an existing text search configuration can be copied.</source>
          <target state="translated">パーサーのみが指定されている場合、新しいテキスト検索構成には、最初はトークンタイプから辞書へのマッピングがないため、すべての単語が無視されます。後続の &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; コマンドを使用してマッピングを作成し、構成を有効にする必要があります。または、既存のテキスト検索構成をコピーすることもできます。</target>
        </trans-unit>
        <trans-unit id="c1317b8ae94e1b0f60e57dbb20e11b92a9f8c5a7" translate="yes" xml:space="preserve">
          <source>If partial newline-sensitive matching is specified, this affects &lt;code&gt;.&lt;/code&gt; and bracket expressions as with newline-sensitive matching, but not &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">部分的に改行を区別するマッチングが指定されている場合、これはに影響し &lt;code&gt;.&lt;/code&gt; 括弧式は、改行を区別するマッチングと同じですが、 &lt;code&gt;^&lt;/code&gt; および &lt;code&gt;$&lt;/code&gt; は使用しません。</target>
        </trans-unit>
        <trans-unit id="5535f2a09b6cea90f6f2421f76ccf57b35834ee5" translate="yes" xml:space="preserve">
          <source>If pg_checksums is aborted or killed while enabling or disabling checksums, the cluster's data checksum configuration remains unchanged, and pg_checksums can be re-run to perform the same operation.</source>
          <target state="translated">チェックサムを有効または無効にしている間にpg_checksumsが中止または終了した場合、クラスタのデータチェックサム設定は変更されず、同じ操作を実行するためにpg_checksumsを再実行することができます。</target>
        </trans-unit>
        <trans-unit id="329ffa5a3154cd15ee165233a8d448dbe8dc1875" translate="yes" xml:space="preserve">
          <source>If pg_rewind fails while processing, then the data folder of the target is likely not in a state that can be recovered. In such a case, taking a new fresh backup is recommended.</source>
          <target state="translated">処理中にpg_rewindが失敗した場合、ターゲットのデータフォルダは復旧できる状態ではない可能性が高いです。このような場合は、新たに新しいバックアップを取ることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="928868bbd3ab201faf3713aebe691a864c3216eb" translate="yes" xml:space="preserve">
          <source>If present, the operator class will become the default operator class for its data type. At most one operator class can be the default for a specific data type and index method.</source>
          <target state="translated">演算子クラスが存在する場合、その演算子クラスはそのデータ型のデフォルトの演算子クラスになります。特定のデータ型とインデックスメソッドのデフォルトは、最大で1つの演算子クラスになります。</target>
        </trans-unit>
        <trans-unit id="dce8d13840c91deea2eabbef36d881ff8d4820b8" translate="yes" xml:space="preserve">
          <source>If primary restarts while commits are waiting for acknowledgment, those waiting transactions will be marked fully committed once the primary database recovers. There is no way to be certain that all standbys have received all outstanding WAL data at time of the crash of the primary. Some transactions may not show as committed on the standby, even though they show as committed on the primary. The guarantee we offer is that the application will not receive explicit acknowledgment of the successful commit of a transaction until the WAL data is known to be safely received by all the synchronous standbys.</source>
          <target state="translated">コミットの確認待ち中にプライマリが再起動した場合、プライマリデータベースが回復すると、その待ち受けていたトランザクションは完全にコミットされたものとしてマークされます。プライマリがクラッシュした時点で、すべてのスタンバイがすべての未処理の WAL データを受信していることを保証する方法はありません。トランザクションによっては、プライマリ上ではコミットされていると表示されていても、スタンバイ上ではコミットされていると表示されない場合があります。我々が提供する保証は、WAL データがすべての同期スタンバイによって安全に受信されることが判明するまで、アプリケーションがトランザクションのコミットが成功したことを明示的に確認することはありません。</target>
        </trans-unit>
        <trans-unit id="cabf4b566b843e529d70b87d853fee3f06c7f4bf" translate="yes" xml:space="preserve">
          <source>If queries are simply broadcast unmodified, functions like &lt;code&gt;random()&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, and sequences can have different values on different servers. This is because each server operates independently, and because SQL queries are broadcast (and not actual modified rows). If this is unacceptable, either the middleware or the application must query such values from a single server and then use those values in write queries. Another option is to use this replication option with a traditional master-standby setup, i.e. data modification queries are sent only to the master and are propagated to the standby servers via master-standby replication, not by the replication middleware. Care must also be taken that all transactions either commit or abort on all servers, perhaps using two-phase commit (&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; and &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;). Pgpool-II and Continuent Tungsten are examples of this type of replication.</source>
          <target state="translated">クエリが単に変更されずにブロードキャストされる場合、 &lt;code&gt;random()&lt;/code&gt; 、 &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; などの関数、およびシーケンスは、サーバーごとに異なる値を持つことができます。これは、各サーバーが独立して動作し、SQLクエリがブロードキャストされるためです（実際に変更された行ではありません）。これが受け入れられない場合、ミドルウェアまたはアプリケーションのいずれかが、単一のサーバーからそのような値を照会し、それらの値を書き込み照会で使用する必要があります。別のオプションは、従来のマスタースタンバイセットアップでこのレプリケーションオプションを使用することです。つまり、データ変更クエリはマスターのみに送信され、レプリケーションミドルウェアではなくマスタースタンバイレプリケーションを介してスタンバイサーバーに伝達されます。また、おそらく2フェーズコミット（&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;および&lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;を使用）を使用して、すべてのトランザクションがすべてのサーバーでコミットまたはアボートするように注意する必要があります。）。Pgpool-IIとContinuent Tungstenは、このタイプのレプリケーションの例です。</target>
        </trans-unit>
        <trans-unit id="f63cea3b2db7baf929d271a8512ae9d2283784c6" translate="yes" xml:space="preserve">
          <source>If recovery finds corrupted WAL data, recovery will halt at that point and the server will not start. In such a case the recovery process could be re-run from the beginning, specifying a &amp;ldquo;recovery target&amp;rdquo; before the point of corruption so that recovery can complete normally. If recovery fails for an external reason, such as a system crash or if the WAL archive has become inaccessible, then the recovery can simply be restarted and it will restart almost from where it failed. Recovery restart works much like checkpointing in normal operation: the server periodically forces all its state to disk, and then updates the &lt;code&gt;pg_control&lt;/code&gt; file to indicate that the already-processed WAL data need not be scanned again.</source>
          <target state="translated">リカバリによって破損したWALデータが検出されると、その時点でリカバリが停止し、サーバーは起動しません。このような場合、回復プロセスを最初から再実行し、破損ポイントの前に「回復ターゲット」を指定して、回復が正常に完了するようにすることができます。システムクラッシュなどの外部の理由でリカバリが失敗した場合、またはWALアーカイブにアクセスできなくなった場合、リカバリを再起動するだけで、ほぼどこからでも再起動できます。リカバリの再起動は、通常の操作におけるチェックポイントのように機能します。サーバーは定期的にすべての状態をディスクに &lt;code&gt;pg_control&lt;/code&gt; し、pg_controlファイルを更新して、すでに処理されたWALデータを再度スキャンする必要がないことを示します。</target>
        </trans-unit>
        <trans-unit id="28dab788b6122ef3bd1cdbda4da4f94cd1b6e630" translate="yes" xml:space="preserve">
          <source>If restoring from backup, rename or delete the old installation directory if it is not version-specific. It is a good idea to rename the directory, rather than delete it, in case you have trouble and need to revert to it. Keep in mind the directory might consume significant disk space. To rename the directory, use a command like this:</source>
          <target state="translated">バックアップから復元する場合は、バージョン固有のものでない場合は、古いインストールディレクトリの名前を変更するか、削除してください。トラブルが発生して元に戻す必要がある場合に備えて、ディレクトリを削除するのではなく、名前を変更しておくと良いでしょう。ディレクトリがかなりのディスク容量を消費する可能性があることを覚えておいてください。ディレクトリの名前を変更するには、以下のようなコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="e309c571c391be62f34e7db7a0c0dec41e3362c4" translate="yes" xml:space="preserve">
          <source>If role can log in, this specifies how many concurrent connections the role can make. -1 (the default) means no limit. Note that only normal connections are counted towards this limit. Neither prepared transactions nor background worker connections are counted towards this limit.</source>
          <target state="translated">ロールがログインできる場合、ロールができる同時接続の数を指定します。-1(デフォルト)は制限なしを意味します。通常の接続のみがこの制限に向かってカウントされることに注意してください。準備されたトランザクションやバックグラウンドワーカーの接続は、この制限にはカウントされません。</target>
        </trans-unit>
        <trans-unit id="62496fbde4961b27e361cbfa11a352d993b40959" translate="yes" xml:space="preserve">
          <source>If row-level security is enabled for a table, but no applicable policies exist, a &amp;ldquo;default deny&amp;rdquo; policy is assumed, so that no rows will be visible or updatable.</source>
          <target state="translated">テーブルに対して行レベルのセキュリティが有効になっているが、適用可能なポリシーが存在しない場合、「デフォルトの拒否」ポリシーが想定され、行が表示されたり更新されたりすることはありません。</target>
        </trans-unit>
        <trans-unit id="fe157e3ff3573012872e8150157f95ab8031e531" translate="yes" xml:space="preserve">
          <source>If row-level security is enabled for the table, the relevant &lt;code&gt;SELECT&lt;/code&gt; policies will apply to &lt;code&gt;COPY table TO&lt;/code&gt; statements. Currently, &lt;code&gt;COPY FROM&lt;/code&gt; is not supported for tables with row-level security. Use equivalent &lt;code&gt;INSERT&lt;/code&gt; statements instead.</source>
          <target state="translated">テーブルに対して行レベルのセキュリティが有効になっている場合、関連する &lt;code&gt;SELECT&lt;/code&gt; ポリシーが &lt;code&gt;COPY table TO&lt;/code&gt; ステートメントに適用されます。現在、 &lt;code&gt;COPY FROM&lt;/code&gt; は、行レベルのセキュリティを備えたテーブルではサポートされていません。代わりに同等の &lt;code&gt;INSERT&lt;/code&gt; ステートメントを使用してください。</target>
        </trans-unit>
        <trans-unit id="a6aa638ed0fa1c0e796268aac030545b317ec979" translate="yes" xml:space="preserve">
          <source>If running in FreeBSD jails by enabling sysctl's &lt;code&gt;security.jail.sysvipc_allowed&lt;/code&gt;, postmasters running in different jails should be run by different operating system users. This improves security because it prevents non-root users from interfering with shared memory or semaphores in different jails, and it allows the PostgreSQL IPC cleanup code to function properly. (In FreeBSD 6.0 and later the IPC cleanup code does not properly detect processes in other jails, preventing the running of postmasters on the same port in different jails.)</source>
          <target state="translated">sysctlの &lt;code&gt;security.jail.sysvipc_allowed&lt;/code&gt; を有効にしてFreeBSD刑務所で実行している場合、異なる刑務所で実行しているポストマスターは、異なるオペレーティングシステムユーザーが実行する必要があります。 root以外のユーザーが異なるメモリ内の共有メモリやセマフォに干渉するのを防ぎ、PostgreSQL IPCクリーンアップコードが適切に機能するようになるため、これによりセキュリティが向上します。 （FreeBSD 6.0以降では、IPCクリーンアップコードは他のjailのプロセスを適切に検出しないため、異なるポートの同じポートでpostmasterが実行されません。）</target>
        </trans-unit>
        <trans-unit id="abdee92b42312c6177118cbed677697bf85b5620" translate="yes" xml:space="preserve">
          <source>If set to 0, the realm name from the authenticated user principal is stripped off before being passed through the user name mapping (&lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt;). This is discouraged and is primarily available for backwards compatibility, as it is not secure in multi-realm environments unless &lt;code&gt;krb_realm&lt;/code&gt; is also used. It is recommended to leave &lt;code&gt;include_realm&lt;/code&gt; set to the default (1) and to provide an explicit mapping in &lt;code&gt;pg_ident.conf&lt;/code&gt; to convert principal names to PostgreSQL user names.</source>
          <target state="translated">0に設定すると、認証されたユーザープリンシパルからのレルム名は、ユーザー名マッピング（&lt;a href=&quot;auth-username-maps&quot;&gt;セクション20.2&lt;/a&gt;）を通過する前に取り除かれます。これはお勧めできません &lt;code&gt;krb_realm&lt;/code&gt; も使用しない限り、マルチレルム環境では安全ではないため、主に下位互換性のために利用できます。 &lt;code&gt;include_realm&lt;/code&gt; をデフォルト（1）に設定した &lt;code&gt;pg_ident.conf&lt;/code&gt; し、プリンシパル名をPostgreSQLユーザー名に変換するためにpg_ident.confに明示的なマッピングを提供することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="752bcd0b9281c38894ddeb4c193f0b06ac531341" translate="yes" xml:space="preserve">
          <source>If set to 1 or less, sending an EOF character (usually &lt;strong&gt;Control&lt;/strong&gt;+&lt;strong&gt;D&lt;/strong&gt;) to an interactive session of psql will terminate the application. If set to a larger numeric value, that many consecutive EOF characters must be typed to make an interactive session terminate. If the variable is set to a non-numeric value, it is interpreted as 10. The default is 0.</source>
          <target state="translated">1以下に設定した場合、psqlのインタラクティブセッションにEOF文字（通常は&lt;strong&gt;Control&lt;/strong&gt; + &lt;strong&gt;D&lt;/strong&gt;）を送信すると、アプリケーションが終了します。より大きい数値に設定する場合、対話型セッションを終了させるには、その数の連続するEOF文字を入力する必要があります。変数が非数値に設定されている場合、10と解釈されます。デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="f150c6b9d3460dc605d8aac9efe72846ba7bd56d" translate="yes" xml:space="preserve">
          <source>If set to 1, the domain's SAM-compatible name (also known as the NetBIOS name) is used for the &lt;code&gt;include_realm&lt;/code&gt; option. This is the default. If set to 0, the true realm name from the Kerberos user principal name is used.</source>
          <target state="translated">1に設定すると、ドメインのSAM互換名（NetBIOS名とも呼ばれる）が &lt;code&gt;include_realm&lt;/code&gt; オプションに使用されます。これがデフォルトです。0に設定すると、Kerberosユーザープリンシパル名からの真のレルム名が使用されます。</target>
        </trans-unit>
        <trans-unit id="82302c2f8409896da1eb7439e9dc154b96d3a8b4" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;all&lt;/code&gt;, all nonempty input lines are printed to standard output as they are read. (This does not apply to lines read interactively.) To select this behavior on program start-up, use the switch &lt;code&gt;-a&lt;/code&gt;. If set to &lt;code&gt;queries&lt;/code&gt;, psql prints each query to standard output as it is sent to the server. The switch to select this behavior is &lt;code&gt;-e&lt;/code&gt;. If set to &lt;code&gt;errors&lt;/code&gt;, then only failed queries are displayed on standard error output. The switch for this behavior is &lt;code&gt;-b&lt;/code&gt;. If set to &lt;code&gt;none&lt;/code&gt; (the default), then no queries are displayed.</source>
          <target state="translated">&lt;code&gt;all&lt;/code&gt; に設定すると、空でないすべての入力行が読み取られたときに標準出力に出力されます。 （これは対話的に読み取られる行には適用されません。）プログラムの起動時にこの動作を選択するには、スイッチ &lt;code&gt;-a&lt;/code&gt; を使用します。 &lt;code&gt;queries&lt;/code&gt; に設定されている場合、psqlは各クエリをサーバーに送信するときに標準出力に出力します。この動作を選択するスイッチは &lt;code&gt;-e&lt;/code&gt; です。 &lt;code&gt;errors&lt;/code&gt; に設定すると、失敗したクエリのみが標準エラー出力に表示されます。この動作のスイッチは &lt;code&gt;-b&lt;/code&gt; です。 &lt;code&gt;none&lt;/code&gt; （デフォルト）に設定すると、クエリは表示されません。</target>
        </trans-unit>
        <trans-unit id="9981243abcd6bfa6b05982c27d6e7ff810b5e4a9" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;on&lt;/code&gt; (the default), this option causes WAL files to be recycled by renaming them, avoiding the need to create new ones. On COW file systems, it may be faster to create new ones, so the option is given to disable this behavior.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; （デフォルト）に設定した場合、このオプションはWALファイルの名前を変更することでリサイクルし、新しいファイルを作成する必要をなくします。COWファイルシステムでは、新しいファイルシステムを作成する方が高速な場合があるため、この動作を無効にするオプションが提供されています。</target>
        </trans-unit>
        <trans-unit id="813f1fb7e134b84c20368173806332413bb9e2ea" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;on&lt;/code&gt; (the default), this option causes new WAL files to be filled with zeroes. On some file systems, this ensures that space is allocated before we need to write WAL records. However, &lt;em&gt;Copy-On-Write&lt;/em&gt; (COW) file systems may not benefit from this technique, so the option is given to skip the unnecessary work. If set to &lt;code&gt;off&lt;/code&gt;, only the final byte is written when the file is created so that it has the expected size.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; （デフォルト）に設定すると、このオプションにより、新しいWALファイルがゼロで埋められます。一部のファイルシステムでは、これにより、WALレコードを書き込む前にスペースが割り当てられます。ただし、&lt;em&gt;Copy-On-Write&lt;/em&gt;（COW）ファイルシステムはこの手法の恩恵を受けない場合があるため、不要な作業をスキップするオプションが提供されています。 &lt;code&gt;off&lt;/code&gt; に設定すると、ファイルが作成されたときに最後のバイトのみが書き込まれるため、ファイルは予想されるサイズになります。</target>
        </trans-unit>
        <trans-unit id="0fba393e4d7deed9cb85ba465e5b27c9e3ab7dd3" translate="yes" xml:space="preserve">
          <source>If set to a non-existent library, JIT will not be available, but no error will be raised. This allows JIT support to be installed separately from the main PostgreSQL package.</source>
          <target state="translated">存在しないライブラリに設定した場合、JITは利用できませんが、エラーは発生しません。これにより、JITのサポートをPostgreSQLのメインパッケージとは別にインストールすることができます。</target>
        </trans-unit>
        <trans-unit id="b3b3af4f011e1d63d9b8223219828980a0583602" translate="yes" xml:space="preserve">
          <source>If set to on, PostgreSQL will instead report an error but continue to run so that the data flushing operation can be retried in a later checkpoint. Only set it to on after investigating the operating system's treatment of buffered data in case of write-back failure.</source>
          <target state="translated">onに設定した場合、PostgreSQLはエラーを報告しますが、後のチェックポイントでデータのフラッシュ処理を再実行できるように実行を続けます。書き込みが失敗した場合のオペレーティングシステムのバッファリングされたデータの扱いを調査した後にのみ、onに設定してください。</target>
        </trans-unit>
        <trans-unit id="7b7ecf1b7610990cb56a543c68a5259c46df2a63" translate="yes" xml:space="preserve">
          <source>If set, do not trace locks for tables below this OID. (use to avoid output on system tables)</source>
          <target state="translated">設定されている場合、このOID以下のテーブルのロックをトレースしません。(システムテーブルへの出力を避けるために使用)</target>
        </trans-unit>
        <trans-unit id="41deca852e6fe629c05086ec201225e618efe1c2" translate="yes" xml:space="preserve">
          <source>If set, dumps information about all current locks when a deadlock timeout occurs.</source>
          <target state="translated">設定すると、デッドロックのタイムアウトが発生したときに、現在のすべてのロックの情報をダンプします。</target>
        </trans-unit>
        <trans-unit id="18ea3580271535268c36ef5f8d3f6aa2461f7a29" translate="yes" xml:space="preserve">
          <source>If set, logs system resource usage statistics (memory and CPU) on various B-tree operations.</source>
          <target state="translated">設定されている場合、さまざまな B-tree 操作のシステムリソース使用統計 (メモリと CPU)をログに記録します。</target>
        </trans-unit>
        <trans-unit id="8cd44fecb272ef12a9372f7353f761fae8a5a0b8" translate="yes" xml:space="preserve">
          <source>If set, the name of the database to create, unless overridden on the command line.</source>
          <target state="translated">セットされている場合は、コマンドラインで上書きされない限り、作成するデータベースの名前。</target>
        </trans-unit>
        <trans-unit id="451271dfdfad4c754e04924937d10fe2728cec15" translate="yes" xml:space="preserve">
          <source>If several large tables all become eligible for vacuuming in a short amount of time, all autovacuum workers might become occupied with vacuuming those tables for a long period. This would result in other tables and databases not being vacuumed until a worker becomes available. There is no limit on how many workers might be in a single database, but workers do try to avoid repeating work that has already been done by other workers. Note that the number of running workers does not count towards &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; or &lt;a href=&quot;runtime-config-connection#GUC-SUPERUSER-RESERVED-CONNECTIONS&quot;&gt;superuser_reserved_connections&lt;/a&gt; limits.</source>
          <target state="translated">いくつかの大きなテーブルがすべて短時間でバキューム処理に適格になると、すべての自動バキュームワーカーがそれらのテーブルを長期間バキューム処理することに専念する可能性があります。これにより、ワーカーが使用可能になるまで、他のテーブルとデータベースがバキュームされなくなります。 1つのデータベースに含まれる可能性のあるワーカーの数に制限はありませんが、ワーカーは、他のワーカーによって既に実行されている作業を繰り返さないようにしています。実行中のワーカーの数は、&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;または&lt;a href=&quot;runtime-config-connection#GUC-SUPERUSER-RESERVED-CONNECTIONS&quot;&gt;superuser_reserved_connectionsの&lt;/a&gt;制限にはカウントされないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="0c0765d00a52dbd937ed1bff59efeb02a5ce2381" translate="yes" xml:space="preserve">
          <source>If simultaneous snapshots are not possible, one option is to shut down the database server long enough to establish all the frozen snapshots. Another option is to perform a continuous archiving base backup (&lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;Section 25.3.2&lt;/a&gt;) because such backups are immune to file system changes during the backup. This requires enabling continuous archiving just during the backup process; restore is done using continuous archive recovery (&lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;Section 25.3.4&lt;/a&gt;).</source>
          <target state="translated">同時スナップショットが不可能な場合、1つのオプションは、凍結されたすべてのスナップショットを確立するのに十分な時間データベースサーバーをシャットダウンすることです。別のオプションは、継続的なアーカイブベースバックアップ（&lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;セクション25.3.2&lt;/a&gt;）を実行することです。このようなバックアップは、バックアップ中のファイルシステムの変更の影響を受けないためです。これには、バックアッププロセス中のみ継続的なアーカイブを有効にする必要があります。復元は、継続的なアーカイブ回復を使用して行われます（&lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;セクション25.3.4&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7b56d1af18915d5bc67acc7e5f67cf1743ccd0db" translate="yes" xml:space="preserve">
          <source>If specific tables are named in a locking clause, then only rows coming from those tables are locked; any other tables used in the &lt;code&gt;SELECT&lt;/code&gt; are simply read as usual. A locking clause without a table list affects all tables used in the statement. If a locking clause is applied to a view or sub-query, it affects all tables used in the view or sub-query. However, these clauses do not apply to &lt;code&gt;WITH&lt;/code&gt; queries referenced by the primary query. If you want row locking to occur within a &lt;code&gt;WITH&lt;/code&gt; query, specify a locking clause within the &lt;code&gt;WITH&lt;/code&gt; query.</source>
          <target state="translated">特定のテーブルがロック句で指定されている場合、それらのテーブルからの行のみがロックされます。 &lt;code&gt;SELECT&lt;/code&gt; で使用される他のテーブルは、通常どおり単に読み取られます。テーブルリストのないロック句は、ステートメントで使用されるすべてのテーブルに影響します。ロック句がビューまたはサブクエリに適用される場合、それはビューまたはサブクエリで使用されるすべてのテーブルに影響します。ただし、これらの句は、プライマリクエリによって参照される &lt;code&gt;WITH&lt;/code&gt; クエリには適用されません。あなたが行ロックを内で発生する場合 &lt;code&gt;WITH&lt;/code&gt; クエリ、内ロック句を指定 &lt;code&gt;WITH&lt;/code&gt; のクエリ。</target>
        </trans-unit>
        <trans-unit id="beba3aa15b0f31c93cbfaa613e20da31b4d61852" translate="yes" xml:space="preserve">
          <source>If specified, the sequence object is created only for this session, and is automatically dropped on session exit. Existing permanent sequences with the same name are not visible (in this session) while the temporary sequence exists, unless they are referenced with schema-qualified names.</source>
          <target state="translated">指定した場合、シーケンスオブジェクトはこのセッションのためだけに作成され、セッション終了時に自動的に削除されます。同じ名前の既存のパーマネントシーケンスは、スキーマ修飾名で参照されていない限り、一時的なシーケンスが存在する間は(このセッションでは)表示されません。</target>
        </trans-unit>
        <trans-unit id="96e1f90a66af2b7d727620148bca6f42e74b9d62" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as a temporary table. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">指定した場合、テーブルは一時テーブルとして作成されます。詳細については、&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a93d62c01130cfe765292bae429e3354023ac5a8" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as a temporary table. Temporary tables are automatically dropped at the end of a session, or optionally at the end of the current transaction (see &lt;code&gt;ON COMMIT&lt;/code&gt; below). Existing permanent tables with the same name are not visible to the current session while the temporary table exists, unless they are referenced with schema-qualified names. Any indexes created on a temporary table are automatically temporary as well.</source>
          <target state="translated">指定した場合、テーブルは一時テーブルとして作成されます。一時テーブルは、セッションの終了時、またはオプションで現在のトランザクションの終了時に自動的に削除されます（下記の &lt;code&gt;ON COMMIT&lt;/code&gt; を参照）。同じ名前の既存の永続テーブルは、スキーマ修飾名で参照されない限り、一時テーブルが存在している間は現在のセッションから見えません。一時テーブルに作成されたインデックスも自動的に一時的です。</target>
        </trans-unit>
        <trans-unit id="e56b4bad12a19e93500049e2da8fe4abf56f18b0" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as an unlogged table. Data written to unlogged tables is not written to the write-ahead log (see &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;Chapter 29&lt;/a&gt;), which makes them considerably faster than ordinary tables. However, they are not crash-safe: an unlogged table is automatically truncated after a crash or unclean shutdown. The contents of an unlogged table are also not replicated to standby servers. Any indexes created on an unlogged table are automatically unlogged as well.</source>
          <target state="translated">指定した場合、テーブルはログなしのテーブルとして作成されます。ログに記録されていないテーブルに書き込まれたデータは、先行書き込みログ（&lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;第29章を&lt;/a&gt;参照）に書き込まれないため、通常のテーブルよりもかなり高速になります。ただし、それらはクラッシュセーフではありません。ログが記録されていないテーブルは、クラッシュまたは不適切なシャットダウンの後に自動的に切り捨てられます。ログに記録されていないテーブルの内容もスタンバイサーバーに複製されません。ログに記録されていないテーブルに作成されたインデックスも、自動的にログに記録されません。</target>
        </trans-unit>
        <trans-unit id="498ade4fa6d89cb5e928b12b79fbd85a2d4b6bc5" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as an unlogged table. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">指定した場合、テーブルはログなしのテーブルとして作成されます。詳細については、&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="55118ee1dbd9adb1bf85c53f18502dc86e8b6ddb" translate="yes" xml:space="preserve">
          <source>If specified, the view is created as a temporary view. Temporary views are automatically dropped at the end of the current session. Existing permanent relations with the same name are not visible to the current session while the temporary view exists, unless they are referenced with schema-qualified names.</source>
          <target state="translated">指定した場合、ビューは一時的なビューとして作成されます。一時的なビューは、現在のセッションの終了時に自動的に削除されます。同じ名前の既存の恒久的なリレーションは、スキーマ修飾名で参照されていない限り、一時ビューが存在する間、現在のセッションからは見えません。</target>
        </trans-unit>
        <trans-unit id="6b5dcbb0812dddc20d9371b9207b1cdb23e05524" translate="yes" xml:space="preserve">
          <source>If still not found, throw an error.</source>
          <target state="translated">それでも見つからない場合は、エラーをスローします。</target>
        </trans-unit>
        <trans-unit id="07af580d9fd90f0744560609d17c425a1c0582ea" translate="yes" xml:space="preserve">
          <source>If streaming replication is disabled, the paused state may continue indefinitely without problem. While streaming replication is in progress WAL records will continue to be received, which will eventually fill available disk space, depending upon the duration of the pause, the rate of WAL generation and available disk space.</source>
          <target state="translated">ストリーミングレプリケーションが無効になっている場合、一時停止状態は問題なく無期限に継続することができます。ストリーミングレプリケーションが進行している間、WALレコードは受信され続け、一時停止の期間、WALの生成速度、利用可能なディスク容量に応じて、最終的には利用可能なディスク容量が一杯になります。</target>
        </trans-unit>
        <trans-unit id="226224ac165619e504532207642e17cb378b9939" translate="yes" xml:space="preserve">
          <source>If syslog is ultimately logging to a text file, then the effect will be the same either way, and it is best to leave the setting on, since most syslog implementations either cannot handle large messages or would need to be specially configured to handle them. But if syslog is ultimately writing into some other medium, it might be necessary or more useful to keep messages logically together.</source>
          <target state="translated">syslogが最終的にテキストファイルにログを記録する場合、どちらの方法でも効果は同じで、ほとんどのsyslog実装は大きなメッセージを扱えないか、それらを扱うために特別に設定する必要があるので、設定をオンにしたままにしておくのが最善です。しかし、syslogが最終的に何か他の媒体に書き込む場合、メッセージを論理的に一緒に保持することが必要であるか、より有用であるかもしれません。</target>
        </trans-unit>
        <trans-unit id="0c9f61d1e280ce039975396a48eef3020a367753" translate="yes" xml:space="preserve">
          <source>If systemd is in use, some care must be taken that IPC resources (shared memory and semaphores) are not prematurely removed by the operating system. This is especially of concern when installing PostgreSQL from source. Users of distribution packages of PostgreSQL are less likely to be affected, as the &lt;code&gt;postgres&lt;/code&gt; user is then normally created as a system user.</source>
          <target state="translated">systemdを使用している場合は、IPCリソース（共有メモリとセマフォ）がオペレーティングシステムによって途中で削除されないように注意する必要があります。これは、PostgreSQLをソースからインストールする場合に特に問題になります。PostgreSQLの配布パッケージのユーザーは、通常 &lt;code&gt;postgres&lt;/code&gt; ユーザーがシステムユーザーとして作成されるため、影響を受ける可能性は低くなります。</target>
        </trans-unit>
        <trans-unit id="0cc78b460318c43d7e2a2ae058784201d032436a" translate="yes" xml:space="preserve">
          <source>If table is a partition (see &lt;code&gt;relispartition&lt;/code&gt;), internal representation of the partition bound</source>
          <target state="translated">テーブルがパーティションの場合（ &lt;code&gt;relispartition&lt;/code&gt; を参照）、バインドされたパーティションの内部表現</target>
        </trans-unit>
        <trans-unit id="2f2df2648f2943188802b9abf232f2ee4f995a24" translate="yes" xml:space="preserve">
          <source>If the &amp;ldquo;Access privileges&amp;rdquo; column is empty for a given object, it means the object has default privileges (that is, its privileges entry in the relevant system catalog is null). Default privileges always include all privileges for the owner, and can include some privileges for &lt;code&gt;PUBLIC&lt;/code&gt; depending on the object type, as explained above. The first &lt;code&gt;GRANT&lt;/code&gt; or &lt;code&gt;REVOKE&lt;/code&gt; on an object will instantiate the default privileges (producing, for example, &lt;code&gt;miriam=arwdDxt/miriam&lt;/code&gt;) and then modify them per the specified request. Similarly, entries are shown in &amp;ldquo;Column privileges&amp;rdquo; only for columns with nondefault privileges. (Note: for this purpose, &amp;ldquo;default privileges&amp;rdquo; always means the built-in default privileges for the object's type. An object whose privileges have been affected by an &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; command will always be shown with an explicit privilege entry that includes the effects of the &lt;code&gt;ALTER&lt;/code&gt;.)</source>
          <target state="translated">特定のオブジェクトの「アクセス権限」列が空の場合、そのオブジェクトにはデフォルトの権限があることを意味します（つまり、関連するシステムカタログの権限エントリはnullです）。デフォルトの権限には、常に所有者のすべての権限が含まれ、上で説明したように、オブジェクトタイプに応じて &lt;code&gt;PUBLIC&lt;/code&gt; の一部の権限を含めることができます。オブジェクトの最初の &lt;code&gt;GRANT&lt;/code&gt; または &lt;code&gt;REVOKE&lt;/code&gt; は、デフォルトの特権をインスタンス化します（たとえば、 &lt;code&gt;miriam=arwdDxt/miriam&lt;/code&gt; を生成します)）、指定されたリクエストごとに変更します。同様に、デフォルト以外の権限を持つ列についてのみ、「列の権限」にエントリが表示されます。（注：この目的のために、「デフォルト特権」は常にオブジェクトタイプの組み込みデフォルト特権を意味します &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; コマンドによって特権が影響を受けたオブジェクトは、影響を含む明示的な特権エントリとともに常に表示されます &lt;code&gt;ALTER&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="ef8285ef018dbe08eadaac46ca6f457ffb7737a0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--check&lt;/code&gt; option was used, the old cluster was unmodified; it can be restarted.</source>
          <target state="translated">場合 &lt;code&gt;--check&lt;/code&gt; オプションを使用した、古いクラスタはそのままでした。再起動できます。</target>
        </trans-unit>
        <trans-unit id="5231ab37a455b02818813f84dceafd365dc3d243" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--link&lt;/code&gt; option was &lt;em&gt;not&lt;/em&gt; used, the old cluster was unmodified; it can be restarted.</source>
          <target state="translated">場合 &lt;code&gt;--link&lt;/code&gt; オプションがして&lt;em&gt;いない&lt;/em&gt;使用し、古いクラスタはそのままでした。再起動できます。</target>
        </trans-unit>
        <trans-unit id="9eaa5641cd34b4f83c2c8d2f48ba3f445ae08243" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--link&lt;/code&gt; option was used, the data files might be shared between the old and new cluster:</source>
          <target state="translated">場合 &lt;code&gt;--link&lt;/code&gt; オプションを使用した、データファイルは古いものと新しいクラスタ間で共有されることがあります。</target>
        </trans-unit>
        <trans-unit id="e5bb770bf0c6c53be90a08f4aadc13d0d045351b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;DELETE&lt;/code&gt; command contains a &lt;code&gt;RETURNING&lt;/code&gt; clause, the result will be similar to that of a &lt;code&gt;SELECT&lt;/code&gt; statement containing the columns and values defined in the &lt;code&gt;RETURNING&lt;/code&gt; list, computed over the row(s) deleted by the command.</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; コマンドに &lt;code&gt;RETURNING&lt;/code&gt; 句が含まれている場合、結果は、コマンドによって削除された行に対して計算された、 &lt;code&gt;RETURNING&lt;/code&gt; リストで定義された列と値を含む &lt;code&gt;SELECT&lt;/code&gt; ステートメントの結果と同様になります。</target>
        </trans-unit>
        <trans-unit id="3edf0bee0b1a18174b6275c32dcc72778ff7f983" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GROUP BY&lt;/code&gt; clause is specified, or if there are aggregate function calls, the output is combined into groups of rows that match on one or more values, and the results of aggregate functions are computed. If the &lt;code&gt;HAVING&lt;/code&gt; clause is present, it eliminates groups that do not satisfy the given condition. (See &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;&lt;code&gt;GROUP BY&lt;/code&gt; Clause&lt;/a&gt; and &lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt;&lt;code&gt;HAVING&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">場合 &lt;code&gt;GROUP BY&lt;/code&gt; 句が指定された集計関数呼び出しがある場合、または、出力が1つまたは複数の値、および集約関数の結果に一致が計算されることが行のグループに結合されます。 &lt;code&gt;HAVING&lt;/code&gt; 句が存在する場合、指定された条件を満たさないグループは削除されます。（下記の&lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt; &lt;code&gt;GROUP BY&lt;/code&gt; 句&lt;/a&gt;と&lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt; &lt;code&gt;HAVING&lt;/code&gt; 句を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="e73996306e544b116d96395fc6c635fa64541db1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;INSERT&lt;/code&gt; command contains a &lt;code&gt;RETURNING&lt;/code&gt; clause, the result will be similar to that of a &lt;code&gt;SELECT&lt;/code&gt; statement containing the columns and values defined in the &lt;code&gt;RETURNING&lt;/code&gt; list, computed over the row(s) inserted or updated by the command.</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; コマンドに &lt;code&gt;RETURNING&lt;/code&gt; 句が含まれている場合、結果は、コマンドによって挿入または更新された行に対して計算された、 &lt;code&gt;RETURNING&lt;/code&gt; リストで定義された列と値を含む &lt;code&gt;SELECT&lt;/code&gt; ステートメントの結果と同様になります。</target>
        </trans-unit>
        <trans-unit id="0cef0ec98d8f962ff98a56a4b6b305bd357183c5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LIMIT&lt;/code&gt; (or &lt;code&gt;FETCH FIRST&lt;/code&gt;) or &lt;code&gt;OFFSET&lt;/code&gt; clause is specified, the &lt;code&gt;SELECT&lt;/code&gt; statement only returns a subset of the result rows. (See &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">場合 &lt;code&gt;LIMIT&lt;/code&gt; （または &lt;code&gt;FETCH FIRST&lt;/code&gt; ）または &lt;code&gt;OFFSET&lt;/code&gt; 句が指定され、 &lt;code&gt;SELECT&lt;/code&gt; 文は結果行の一部分のみを返します。（下記の&lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt; &lt;code&gt;LIMIT&lt;/code&gt; 句を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="72d3a656a8d2961c5ae7c07dee89a103497dda43" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ORDER BY&lt;/code&gt; clause is specified, the returned rows are sorted in the specified order. If &lt;code&gt;ORDER BY&lt;/code&gt; is not given, the rows are returned in whatever order the system finds fastest to produce. (See &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">場合は &lt;code&gt;ORDER BY&lt;/code&gt; 句が指定され、返される行は指定された順にソートされています。 &lt;code&gt;ORDER BY&lt;/code&gt; が指定されていない場合、行は、システムが生成するのが最も速いと判断した順序で返されます。（下記の&lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 句を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="fcc9caa8fd8396a40199c537204044cd80b03fd9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; command fails for any reason, it becomes a &lt;code&gt;ROLLBACK&lt;/code&gt;: the current transaction is canceled.</source>
          <target state="translated">場合は &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; のコマンドが何らかの理由で失敗し、それはなり &lt;code&gt;ROLLBACK&lt;/code&gt; ：現在のトランザクションがキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="049a6b3315aa2fcc9292bf280d3fbac8f17f8faa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PREPARE&lt;/code&gt; statement that created the statement specified some parameters, a compatible set of parameters must be passed to the &lt;code&gt;EXECUTE&lt;/code&gt; statement, or else an error is raised. Note that (unlike functions) prepared statements are not overloaded based on the type or number of their parameters; the name of a prepared statement must be unique within a database session.</source>
          <target state="translated">ステートメントを作成した &lt;code&gt;PREPARE&lt;/code&gt; ステートメントがいくつかのパラメーターを指定した場合、互換性のあるパラメーターのセットを &lt;code&gt;EXECUTE&lt;/code&gt; ステートメントに渡す必要があります。そうしないと、エラーが発生します。（関数とは異なり）準備されたステートメントは、パラメーターのタイプまたは数に基づいてオーバーロードされないことに注意してください。準備済みステートメントの名前は、データベースセッション内で一意である必要があります。</target>
        </trans-unit>
        <trans-unit id="4e671e1df94a35c63462372f63dbaab316b08304" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;UPDATE&lt;/code&gt; command contains a &lt;code&gt;RETURNING&lt;/code&gt; clause, the result will be similar to that of a &lt;code&gt;SELECT&lt;/code&gt; statement containing the columns and values defined in the &lt;code&gt;RETURNING&lt;/code&gt; list, computed over the row(s) updated by the command.</source>
          <target state="translated">&lt;code&gt;UPDATE&lt;/code&gt; コマンドに &lt;code&gt;RETURNING&lt;/code&gt; 句が含まれている場合、結果は、コマンドによって更新された行に対して計算された、 &lt;code&gt;RETURNING&lt;/code&gt; リストで定義された列と値を含む &lt;code&gt;SELECT&lt;/code&gt; ステートメントの結果と同様になります。</target>
        </trans-unit>
        <trans-unit id="e2d169320d1dac51b305dc4371af2fd872eb335a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WHERE&lt;/code&gt; clause is specified, all rows that do not satisfy the condition are eliminated from the output. (See &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;&lt;code&gt;WHERE&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">場合は &lt;code&gt;WHERE&lt;/code&gt; 句が指定され、条件を満たさないすべての行は出力から除外されています。（以下の&lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt; &lt;code&gt;WHERE&lt;/code&gt; 句を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="92b918e82e1dbdff8d47052fc332ee8551811a46" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause is specified, an additional column of type &lt;code&gt;bigint&lt;/code&gt; will be added to the function result columns. This column numbers the rows of the function result set, starting from 1. (This is a generalization of the SQL-standard syntax for &lt;code&gt;UNNEST ... WITH ORDINALITY&lt;/code&gt;.) By default, the ordinal column is called &lt;code&gt;ordinality&lt;/code&gt;, but a different column name can be assigned to it using an &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">場合 &lt;code&gt;WITH ORDINALITY&lt;/code&gt; の句が指定され、型の追加の列 &lt;code&gt;bigint&lt;/code&gt; 関数の結果の列に追加されます。この列番号関数の結果の行は1から始まるセット、（これがためにSQL標準構文を一般化したものである &lt;code&gt;UNNEST ... WITH ORDINALITY&lt;/code&gt; 。）デフォルトでは、序数の列が呼ばれた &lt;code&gt;ordinality&lt;/code&gt; が、異なるカラム名 &lt;code&gt;AS&lt;/code&gt; 句を使用してそれに割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="3a9a2b1e5b5de3befe9a4b97f742aa542e0145cb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;count&lt;/code&gt; expression evaluates to NULL, it is treated as &lt;code&gt;LIMIT ALL&lt;/code&gt;, i.e., no limit. If &lt;code&gt;start&lt;/code&gt; evaluates to NULL, it is treated the same as &lt;code&gt;OFFSET 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 式がNULLと評価された場合、それは &lt;code&gt;LIMIT ALL&lt;/code&gt; として扱われます。つまり、制限はありません。 &lt;code&gt;start&lt;/code&gt; がNULLと評価された場合、 &lt;code&gt;OFFSET 0&lt;/code&gt; と同じように扱われます。</target>
        </trans-unit>
        <trans-unit id="b469c74a0f6fb197601cf70011bbae3b5c0a8cbf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;dictionary&lt;/code&gt; argument is omitted, the text search dictionary named &lt;code&gt;unaccent&lt;/code&gt; and appearing in the same schema as the &lt;code&gt;unaccent()&lt;/code&gt; function itself is used.</source>
          <target state="translated">&lt;code&gt;dictionary&lt;/code&gt; 引数が省略された場合、 &lt;code&gt;unaccent&lt;/code&gt; という名前で &lt;code&gt;unaccent()&lt;/code&gt; 関数自体と同じスキーマにあるテキスト検索辞書が使用されます。</target>
        </trans-unit>
        <trans-unit id="8e92f2cba043fc31ab92cbc203c691c2c492c8d7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;expression&lt;/code&gt; is row-valued, then &lt;code&gt;IS NULL&lt;/code&gt; is true when the row expression itself is null or when all the row's fields are null, while &lt;code&gt;IS NOT NULL&lt;/code&gt; is true when the row expression itself is non-null and all the row's fields are non-null. Because of this behavior, &lt;code&gt;IS NULL&lt;/code&gt; and &lt;code&gt;IS NOT NULL&lt;/code&gt; do not always return inverse results for row-valued expressions; in particular, a row-valued expression that contains both null and non-null fields will return false for both tests. In some cases, it may be preferable to write &lt;code&gt;row&lt;/code&gt;&lt;code&gt;IS DISTINCT FROM NULL&lt;/code&gt; or &lt;code&gt;row&lt;/code&gt;&lt;code&gt;IS NOT DISTINCT FROM NULL&lt;/code&gt;, which will simply check whether the overall row value is null without any additional tests on the row fields.</source>
          <target state="translated">場合 &lt;code&gt;expression&lt;/code&gt; 行値である場合、 &lt;code&gt;IS NULL&lt;/code&gt; 行式自体がNULLまたはときながら、すべての行のフィールドは、nullのときに真である &lt;code&gt;IS NOT NULL&lt;/code&gt; は、行式自体が非nullで、すべての行のフィールドがあるときに真でありますnull以外。この動作のため、 &lt;code&gt;IS NULL&lt;/code&gt; および &lt;code&gt;IS NOT NULL&lt;/code&gt; は常に行値式の逆の結果を返すとは限りません。特に、nullとnon-nullの両方のフィールドを含む行値式は、両方のテストでfalseを返します。いくつかのケースでは、書き込みに好ましいかもしれない &lt;code&gt;row&lt;/code&gt; &lt;code&gt;IS DISTINCT FROM NULL&lt;/code&gt; または &lt;code&gt;row&lt;/code&gt; &lt;code&gt;IS NOT DISTINCT FROM NULL&lt;/code&gt; これは、行フィールドで追加のテストを行わなくても、行全体の値がnullかどうかを確認するだけです。</target>
        </trans-unit>
        <trans-unit id="8a9d5cf7323804505a12a8a728eb4b811573a010" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;system-username&lt;/code&gt; field starts with a slash (&lt;code&gt;/&lt;/code&gt;), the remainder of the field is treated as a regular expression. (See &lt;a href=&quot;functions-matching#POSIX-SYNTAX-DETAILS&quot;&gt;Section 9.7.3.1&lt;/a&gt; for details of PostgreSQL's regular expression syntax.) The regular expression can include a single capture, or parenthesized subexpression, which can then be referenced in the &lt;code&gt;database-username&lt;/code&gt; field as &lt;code&gt;\1&lt;/code&gt; (backslash-one). This allows the mapping of multiple user names in a single line, which is particularly useful for simple syntax substitutions. For example, these entries</source>
          <target state="translated">&lt;code&gt;system-username&lt;/code&gt; フィールドがスラッシュ（ &lt;code&gt;/&lt;/code&gt; ）で始まる場合、フィールドの残りの部分は正規表現として扱われます。（PostgreSQLの正規表現構文の詳細については、&lt;a href=&quot;functions-matching#POSIX-SYNTAX-DETAILS&quot;&gt;セクション9.7.3.1&lt;/a&gt;を参照してください。）正規表現には、単一のキャプチャ、または括弧で囲まれたサブ表現を含めることができ、 &lt;code&gt;database-username&lt;/code&gt; フィールドで &lt;code&gt;\1&lt;/code&gt; （バックスラッシュ1）として参照できます。これにより、複数のユーザー名を1行でマッピングできます。これは、単純な構文置換に特に役立ちます。たとえば、これらのエントリ</target>
        </trans-unit>
        <trans-unit id="482a504d7c75e328098ffe22edcbb1378a3f6faa" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;values&lt;/code&gt;&lt;/em&gt; arrays are specified, an &lt;em&gt;armor header&lt;/em&gt; is added to the armored format for each key/value pair. Both arrays must be single-dimensional, and they must be of the same length. The keys and values cannot contain any non-ASCII characters.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/em&gt;と&lt;em&gt; &lt;code&gt;values&lt;/code&gt; &lt;/em&gt;配列が指定されている場合、各キー/値のペアの&lt;em&gt;アーマー&lt;/em&gt;形式に&lt;em&gt;アーマーヘッダー&lt;/em&gt;が追加されます。両方の配列は1次元である必要があり、同じ長さである必要があります。キーと値に非ASCII文字を含めることはできません。</target>
        </trans-unit>
        <trans-unit id="7327537568cbffaa257fef6fbd8b81996eaef858" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;&lt;code&gt;silent&lt;/code&gt;&lt;/em&gt; argument is specified and has the &lt;code&gt;true&lt;/code&gt; value, these functions suppress the same errors as the &lt;code&gt;@?&lt;/code&gt; and &lt;code&gt;@@&lt;/code&gt; operators.</source>
          <target state="translated">場合は&lt;em&gt; &lt;code&gt;silent&lt;/code&gt; &lt;/em&gt;引数が指定されていている &lt;code&gt;true&lt;/code&gt; 値を、これらの機能は同じエラー抑制 &lt;code&gt;@?&lt;/code&gt; および &lt;code&gt;@@&lt;/code&gt; 演算子。</target>
        </trans-unit>
        <trans-unit id="ceede46190dd53d528fe2b583d1ccadb6cf588b2" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; argument is specified, it provides an object containing named variables to be substituted into a &lt;code&gt;jsonpath&lt;/code&gt; expression.</source>
          <target state="translated">場合&lt;em&gt; &lt;code&gt;vars&lt;/code&gt; の&lt;/em&gt;引数が指定され、それが代入されるという名前の変数を含むオブジェクトを提供 &lt;code&gt;jsonpath&lt;/code&gt; の表現を。</target>
        </trans-unit>
        <trans-unit id="a173c623ff67d4c364c8db6dbe6ae6c5c5c1b9dd" translate="yes" xml:space="preserve">
          <source>If the S2K key is to be used directly, then only S2K settings will be put into the session key packet. Otherwise the session key will be encrypted with the S2K key and put into the session key packet.</source>
          <target state="translated">S2K鍵を直接使用する場合は、S2Kの設定のみをセッション鍵パケットに入れます。そうでなければ、セッションキーはS2Kキーで暗号化されてセッションキーパケットに入れられます。</target>
        </trans-unit>
        <trans-unit id="cd334923ca7f6a61f76d5cc9802fe6d4f79f8249" translate="yes" xml:space="preserve">
          <source>If the Serializable transaction isolation level is used for all writes and for all reads which need a consistent view of the data, no other effort is required to ensure consistency. Software from other environments which is written to use serializable transactions to ensure consistency should &amp;ldquo;just work&amp;rdquo; in this regard in PostgreSQL.</source>
          <target state="translated">すべての書き込みと、データの一貫したビューを必要とするすべての読み取りにSerializableトランザクション分離レベルが使用されている場合、一貫性を確保するために他の作業は必要ありません。PostgreSQLでこの点に関して一貫性を保証するためにシリアライズ可能なトランザクションを使用するように作成された他の環境のソフトウェアは「そのまま動作する」はずです。</target>
        </trans-unit>
        <trans-unit id="b3a85d8941e78b61fa6dfe5e13735d5c695c638d" translate="yes" xml:space="preserve">
          <source>If the argument begins with &lt;code&gt;|&lt;/code&gt;, then the entire remainder of the line is taken to be the &lt;code&gt;command&lt;/code&gt; to execute, and neither variable interpolation nor backquote expansion are performed in it. The rest of the line is simply passed literally to the shell.</source>
          <target state="translated">引数が &lt;code&gt;|&lt;/code&gt; で始まる場合 の場合、行の残りの部分全体が実行する &lt;code&gt;command&lt;/code&gt; と見なされ、変数の補間もバッククォート展開も実行されません。行の残りの部分は、文字通りシェルに渡されます。</target>
        </trans-unit>
        <trans-unit id="c120a5d678ef79b9fdd905518c659ce62747d5d3" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;json_strip_nulls&lt;/code&gt; contains duplicate field names in any object, the result could be semantically somewhat different, depending on the order in which they occur. This is not an issue for &lt;code&gt;jsonb_strip_nulls&lt;/code&gt; since &lt;code&gt;jsonb&lt;/code&gt; values never have duplicate object field names.</source>
          <target state="translated">&lt;code&gt;json_strip_nulls&lt;/code&gt; の引数にオブジェクトの重複したフィールド名が含まれている場合、結果は、それらが発生する順序に応じて、意味的に多少異なる場合があります。これは問題になりません &lt;code&gt;jsonb_strip_nulls&lt;/code&gt; ので、 &lt;code&gt;jsonb&lt;/code&gt; 値が重複するオブジェクトフィールド名を持っていることはありません。</target>
        </trans-unit>
        <trans-unit id="da41d6b70ef3eb6374e923e599dfca0a856e8010" translate="yes" xml:space="preserve">
          <source>If the array expression yields a null array, the result of &lt;code&gt;ALL&lt;/code&gt; will be null. If the left-hand expression yields null, the result of &lt;code&gt;ALL&lt;/code&gt; is ordinarily null (though a non-strict comparison operator could possibly yield a different result). Also, if the right-hand array contains any null elements and no false comparison result is obtained, the result of &lt;code&gt;ALL&lt;/code&gt; will be null, not true (again, assuming a strict comparison operator). This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">配列式がnull配列を生成する場合、 &lt;code&gt;ALL&lt;/code&gt; の結果はnullになります。左側の式がnullを生成する場合、 &lt;code&gt;ALL&lt;/code&gt; の結果は通常nullになります（厳密でない比較演算子は異なる結果を生成する可能性があります）。また、右側の配列にnull要素が含まれていて、偽の比較結果が得られない場合、 &lt;code&gt;ALL&lt;/code&gt; の結果は真ではなくnullになります（ここでも、厳密な比較演算子を想定しています）。これは、NULL値のブール値の組み合わせに関するSQLの通常の規則に従っています。</target>
        </trans-unit>
        <trans-unit id="ae942e08ca17c439fb984995bab2b3f4a2ace54c" translate="yes" xml:space="preserve">
          <source>If the array expression yields a null array, the result of &lt;code&gt;ANY&lt;/code&gt; will be null. If the left-hand expression yields null, the result of &lt;code&gt;ANY&lt;/code&gt; is ordinarily null (though a non-strict comparison operator could possibly yield a different result). Also, if the right-hand array contains any null elements and no true comparison result is obtained, the result of &lt;code&gt;ANY&lt;/code&gt; will be null, not false (again, assuming a strict comparison operator). This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">配列式がnull配列を生成する場合、 &lt;code&gt;ANY&lt;/code&gt; の結果はnullになります。左側の式がnullを生成する場合、 &lt;code&gt;ANY&lt;/code&gt; の結果は通常nullです（厳密でない比較演算子は別の結果を生成する可能性があります）。また、右側の配列にnull要素が含まれ、真の比較結果が得られない場合、 &lt;code&gt;ANY&lt;/code&gt; の結果は偽ではなくnullになります（ここでも、厳密な比較演算子を想定しています）。これは、NULL値のブール値の組み合わせに関するSQLの通常の規則に従っています。</target>
        </trans-unit>
        <trans-unit id="f33f8fbf54f510b9f47b6952f447521e0e216bb8" translate="yes" xml:space="preserve">
          <source>If the backup process monitors and ensures that all WAL segment files required for the backup are successfully archived then the &lt;code&gt;wait_for_archive&lt;/code&gt; parameter (which defaults to true) can be set to false to have &lt;code&gt;pg_stop_backup&lt;/code&gt; return as soon as the stop backup record is written to the WAL. By default, &lt;code&gt;pg_stop_backup&lt;/code&gt; will wait until all WAL has been archived, which can take some time. This option must be used with caution: if WAL archiving is not monitored correctly then the backup might not include all of the WAL files and will therefore be incomplete and not able to be restored.</source>
          <target state="translated">バックアッププロセスが、バックアップに必要なすべてのWALセグメントファイルが正常にアーカイブされていることを監視および確認している場合、 &lt;code&gt;wait_for_archive&lt;/code&gt; パラメータ（デフォルトはtrue）をfalseに設定して、 &lt;code&gt;pg_stop_backup&lt;/code&gt; がバックアップの停止レコードがWALに書き込まれるとすぐに戻るようにすることができます。。デフォルトでは、 &lt;code&gt;pg_stop_backup&lt;/code&gt; はすべてのWALがアーカイブされるまで待機します。これには時間がかかる場合があります。このオプションは注意して使用する必要があります。WALアーカイブが正しく監視されていない場合、バックアップにすべてのWALファイルが含まれていない可能性があるため、不完全であり、復元できません。</target>
        </trans-unit>
        <trans-unit id="38dbd4a01a3f520d833ada1c842bc701e68bca1c" translate="yes" xml:space="preserve">
          <source>If the cast is marked &lt;code&gt;AS ASSIGNMENT&lt;/code&gt; then it can be invoked implicitly when assigning a value to a column of the target data type. For example, supposing that &lt;code&gt;foo.f1&lt;/code&gt; is a column of type &lt;code&gt;text&lt;/code&gt;, then:</source>
          <target state="translated">キャストが &lt;code&gt;AS ASSIGNMENT&lt;/code&gt; とマークされている場合、ターゲットデータ型の列に値を割り当てるときに暗黙的に呼び出すことができます。たとえば、 &lt;code&gt;foo.f1&lt;/code&gt; が &lt;code&gt;text&lt;/code&gt; 型の列であるとすると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="a854dcb7d27eca4b3717769b2da567eec36f84ca" translate="yes" xml:space="preserve">
          <source>If the cast is marked &lt;code&gt;AS IMPLICIT&lt;/code&gt; then it can be invoked implicitly in any context, whether assignment or internally in an expression. (We generally use the term &lt;em&gt;implicit cast&lt;/em&gt; to describe this kind of cast.) For example, consider this query:</source>
          <target state="translated">キャストが &lt;code&gt;AS IMPLICIT&lt;/code&gt; としてマークされている場合、割り当てでも式の内部でも、どのコンテキストでも暗黙的に呼び出すことができます。（通常、この種の&lt;em&gt;キャスト&lt;/em&gt;を説明するために&lt;em&gt;暗黙的キャスト&lt;/em&gt;という用語を使用します。）たとえば、次のクエリを考えてみます。</target>
        </trans-unit>
        <trans-unit id="61cd1b288599e699dce186b3244d616ce3ce9c86" translate="yes" xml:space="preserve">
          <source>If the catalog's &lt;code&gt;.h&lt;/code&gt; file specifies a default value for a column, and a data entry has that same value, &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; will omit it from the data file. This keeps the data representation compact.</source>
          <target state="translated">カタログの &lt;code&gt;.h&lt;/code&gt; ファイルが列のデフォルト値を指定し、データエントリがその同じ値を持っている場合、 &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; はデータファイルからそれを省略します。これにより、データ表現がコンパクトに保たれます。</target>
        </trans-unit>
        <trans-unit id="bae7f3745b8c55d9daa52727f8674ef5381e42f5" translate="yes" xml:space="preserve">
          <source>If the client character set is defined as &lt;code&gt;SQL_ASCII&lt;/code&gt;, encoding conversion is disabled, regardless of the server's character set. Just as for the server, use of &lt;code&gt;SQL_ASCII&lt;/code&gt; is unwise unless you are working with all-ASCII data.</source>
          <target state="translated">クライアントの文字セットが &lt;code&gt;SQL_ASCII&lt;/code&gt; として定義されている場合、サーバーの文字セットに関係なく、エンコーディング変換は無効になります。サーバーの場合と &lt;code&gt;SQL_ASCII&lt;/code&gt; 、すべてのASCIIデータを処理している場合を除き、SQL_ASCIIの使用は賢明ではありません。</target>
        </trans-unit>
        <trans-unit id="0c4deed9a95ca57073b155e9cb8a0f5097708705" translate="yes" xml:space="preserve">
          <source>If the command is written as &lt;code&gt;ALTER FOREIGN TABLE IF EXISTS ...&lt;/code&gt; and the foreign table does not exist, no error is thrown. A notice is issued in this case.</source>
          <target state="translated">コマンドが &lt;code&gt;ALTER FOREIGN TABLE IF EXISTS ...&lt;/code&gt; として記述されていて、外部テーブルが存在しない場合、エラーはスローされません。この場合、通知が発行されます。</target>
        </trans-unit>
        <trans-unit id="63d051a50066f7b8f700301bed696001489f1857" translate="yes" xml:space="preserve">
          <source>If the command returns a nonzero exit status then a warning log message will be written and the database will proceed to start up anyway. An exception is that if the command was terminated by a signal or an error by the shell (such as command not found), the database will not proceed with startup.</source>
          <target state="translated">コマンドがゼロ以外の終了ステータスを返した場合、警告ログメッセージが書き込まれ、データベースは起動に進みます。例外として、コマンドがシグナルやシェルによるエラー(コマンドが見つかりませんでしたなど)によって終了した場合、データベースは起動を続行しません。</target>
        </trans-unit>
        <trans-unit id="557bcc8e46db9e939ccd6eb079fcf5557fc3e866" translate="yes" xml:space="preserve">
          <source>If the command returns a nonzero exit status then a warning log message will be written. An exception is that if the command was terminated by a signal or an error by the shell (such as command not found), a fatal error will be raised.</source>
          <target state="translated">コマンドがゼロ以外の終了ステータスを返した場合、警告ログメッセージが書き込まれます。例外として、コマンドがシグナルやシェルのエラー (コマンドが見つからないなど)によって終了した場合は、致命的なエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="6a74eec2662a9cc1d1ed60748980c12a4bf53d33" translate="yes" xml:space="preserve">
          <source>If the commands themselves contain &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;COMMIT&lt;/code&gt;, or &lt;code&gt;ROLLBACK&lt;/code&gt;, this option will not have the desired effects. Also, if an individual command cannot be executed inside a transaction block, specifying this option will cause the whole transaction to fail.</source>
          <target state="translated">コマンド自体に &lt;code&gt;BEGIN&lt;/code&gt; 、 &lt;code&gt;COMMIT&lt;/code&gt; 、または &lt;code&gt;ROLLBACK&lt;/code&gt; が含まれている場合、このオプションは望ましい効果をもたらしません。また、トランザクションブロック内で個々のコマンドを実行できない場合、このオプションを指定すると、トランザクション全体が失敗します。</target>
        </trans-unit>
        <trans-unit id="02b4ea2a996ab5d0d7b4386241306a8c9bd92e8f" translate="yes" xml:space="preserve">
          <source>If the compared values are of a collatable data type, the appropriate collation OID will be passed to the comparison support function, using the standard &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; mechanism.</source>
          <target state="translated">比較された値が照合可能なデータ型である場合、適切な照合OIDが標準の &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; メカニズムを使用して比較サポート関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="29c5e362afd4a1ac0e7c03190fce4c0374d970bb" translate="yes" xml:space="preserve">
          <source>If the compress method is lossy for leaf entries, the operator class cannot support index-only scans, and must not define a &lt;code&gt;fetch&lt;/code&gt; function.</source>
          <target state="translated">リーフエントリに対して圧縮メソッドが不可逆的である場合、演算子クラスはインデックスのみのスキャンをサポートできず、 &lt;code&gt;fetch&lt;/code&gt; 関数を定義してはなりません。</target>
        </trans-unit>
        <trans-unit id="f7447741114d4403590357da345ba571953f8d76" translate="yes" xml:space="preserve">
          <source>If the configuration file contains syntax errors or invalid parameter names, the server will not attempt to apply any settings from it, and therefore all the &lt;code&gt;applied&lt;/code&gt; fields will read as false. In such a case there will be one or more rows with non-null &lt;code&gt;error&lt;/code&gt; fields indicating the problem(s). Otherwise, individual settings will be applied if possible. If an individual setting cannot be applied (e.g., invalid value, or the setting cannot be changed after server start) it will have an appropriate message in the &lt;code&gt;error&lt;/code&gt; field. Another way that an entry might have &lt;code&gt;applied&lt;/code&gt; = false is that it is overridden by a later entry for the same parameter name; this case is not considered an error so nothing appears in the &lt;code&gt;error&lt;/code&gt; field.</source>
          <target state="translated">構成ファイルに構文エラーまたは無効なパラメーター名が含まれている場合、サーバーはそこから設定を適用しようとしないため、 &lt;code&gt;applied&lt;/code&gt; すべてのフィールドはfalseとして読み取られます。そのような場合、問題を示すnull以外の &lt;code&gt;error&lt;/code&gt; フィールドを持つ1つ以上の行が存在します。それ以外の場合は、可能であれば個別の設定が適用されます。個別の設定を適用できない場合（無効な値、サーバーの起動後に設定を変更できない場合など）は、 &lt;code&gt;error&lt;/code&gt; フィールドに適切なメッセージが表示されます。エントリが &lt;code&gt;applied&lt;/code&gt; た別の方法= falseは、同じパラメータ名の後続のエントリによって上書きされることです。何もに表示されていないので、この場合はエラーとはみなされません &lt;code&gt;error&lt;/code&gt; フィールド。</target>
        </trans-unit>
        <trans-unit id="6846426f89420f86ff7e1053a00d20ad214d1c83" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; is &lt;code&gt;off&lt;/code&gt;, then PostgreSQL recognizes backslash escapes in both regular and escape string constants. However, as of PostgreSQL 9.1, the default is &lt;code&gt;on&lt;/code&gt;, meaning that backslash escapes are recognized only in escape string constants. This behavior is more standards-compliant, but might break applications which rely on the historical behavior, where backslash escapes were always recognized. As a workaround, you can set this parameter to &lt;code&gt;off&lt;/code&gt;, but it is better to migrate away from using backslash escapes. If you need to use a backslash escape to represent a special character, write the string constant with an &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">構成パラメーター&lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt;が &lt;code&gt;off&lt;/code&gt; の場合、PostgreSQLは通常の文字列定数とエスケープ文字列定数の両方でバックスラッシュエスケープを認識します。ただし、PostgreSQL 9.1以降、デフォルトは &lt;code&gt;on&lt;/code&gt; です。つまり、バックスラッシュエスケープは、エスケープ文字列定数でのみ認識されます。この動作は、より標準に準拠していますが、バックスラッシュエスケープが常に認識されていた履歴動作に依存するアプリケーションを壊す可能性があります。回避策として、このパラメーターを &lt;code&gt;off&lt;/code&gt; に設定できますが、バックスラッシュエスケープの使用から移行することをお勧めします。特殊文字を表すためにバックスラッシュエスケープを使用する必要がある場合は、 &lt;code&gt;E&lt;/code&gt; を使用して文字列定数を記述します。</target>
        </trans-unit>
        <trans-unit id="7e2bc2b10438374418a16365e82e01c5a0e70ba5" translate="yes" xml:space="preserve">
          <source>If the connection could not be made for any reason (e.g., insufficient privileges, server is not running on the targeted host, etc.), psql will return an error and terminate.</source>
          <target state="translated">何らかの理由で接続ができなかった場合(権限が足りない、サーバが対象のホストで実行されていないなど)、psqlはエラーを返して終了します。</target>
        </trans-unit>
        <trans-unit id="02930b22f9d6ca1f7733ab529d9a22a91b3fe5c0" translate="yes" xml:space="preserve">
          <source>If the connection is lost, or if it cannot be initially established, with a non-fatal error, pg_receivewal will retry the connection indefinitely, and reestablish streaming as soon as possible. To avoid this behavior, use the &lt;code&gt;-n&lt;/code&gt; parameter.</source>
          <target state="translated">接続が失われた場合、または最初に確立できない場合に致命的でないエラーが発生すると、pg_receivewalは接続を無期限に再試行し、できるだけ早くストリーミングを再確立します。この動作を回避するには、 &lt;code&gt;-n&lt;/code&gt; パラメータを使用します。</target>
        </trans-unit>
        <trans-unit id="1e7cb7e5b7e9cfa96c974efa30e7317e321f657f" translate="yes" xml:space="preserve">
          <source>If the conversion of a particular character is not possible &amp;mdash; suppose you chose &lt;code&gt;EUC_JP&lt;/code&gt; for the server and &lt;code&gt;LATIN1&lt;/code&gt; for the client, and some Japanese characters are returned that do not have a representation in &lt;code&gt;LATIN1&lt;/code&gt; &amp;mdash; an error is reported.</source>
          <target state="translated">特定の文字の変換ができない場合-あなたが選択したと仮定し &lt;code&gt;EUC_JP&lt;/code&gt; をサーバとするために &lt;code&gt;LATIN1&lt;/code&gt; クライアントのための、およびいくつかの日本語の文字は、での表現はありませんが返され &lt;code&gt;LATIN1&lt;/code&gt; を -エラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="5a6f84dd517ea12fd77c796a6737968d24f658ee" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is described instead.</source>
          <target state="translated">現在のクエリバッファが空の場合、代わりに最近送信されたクエリが記述されます。</target>
        </trans-unit>
        <trans-unit id="2c57feb4352b9d0e5fa18cf7867721a0200da9c9" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is re-executed instead.</source>
          <target state="translated">現在のクエリバッファが空の場合、最近送信されたクエリが代わりに再実行されます。</target>
        </trans-unit>
        <trans-unit id="b8dce5eee9d2655efdc5121439aeb8029c6a8bb6" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is re-executed instead. Except for that behavior, &lt;code&gt;\g&lt;/code&gt; without an argument is essentially equivalent to a semicolon. A &lt;code&gt;\g&lt;/code&gt; with argument is a &amp;ldquo;one-shot&amp;rdquo; alternative to the &lt;code&gt;\o&lt;/code&gt; command.</source>
          <target state="translated">現在のクエリバッファが空の場合、最後に送信されたクエリが代わりに再実行されます。その動作を除いて、引数なしの &lt;code&gt;\g&lt;/code&gt; は本質的にセミコロンと同等です。引数付きの &lt;code&gt;\g&lt;/code&gt; は、 &lt;code&gt;\o&lt;/code&gt; コマンドの「ワンショット」の代替手段です。</target>
        </trans-unit>
        <trans-unit id="9c1be77262ade382bd3daec36a4b4f5dfa260c3f" translate="yes" xml:space="preserve">
          <source>If the current table output format is unaligned, it is switched to aligned. If it is not unaligned, it is set to unaligned. This command is kept for backwards compatibility. See &lt;code&gt;\pset&lt;/code&gt; for a more general solution.</source>
          <target state="translated">現在のテーブル出力形式が整列されていない場合は、整列に切り替えられます。整列されていない場合は、整列されていません。このコマンドは、下位互換性のために残されています。より一般的な解決策については、 &lt;code&gt;\pset&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="e6fb10bfb27f2916d0fe2c64c42424fe0e7351c4" translate="yes" xml:space="preserve">
          <source>If the cursor's query includes &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt;, then returned rows are locked at the time they are first fetched, in the same way as for a regular &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command with these options. In addition, the returned rows will be the most up-to-date versions; therefore these options provide the equivalent of what the SQL standard calls a &amp;ldquo;sensitive cursor&amp;rdquo;. (Specifying &lt;code&gt;INSENSITIVE&lt;/code&gt; together with &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt; is an error.)</source>
          <target state="translated">カーソルのクエリに &lt;code&gt;FOR UPDATE&lt;/code&gt; または &lt;code&gt;FOR SHARE&lt;/code&gt; が含まれている場合、返された行は、これらのオプションを指定した通常の&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;コマンドの場合と同様に、最初にフェッチされたときにロックされます。また、返される行は最新バージョンになります。したがって、これらのオプションは、SQL標準が「センシティブカーソル」と呼ぶものと同等のものを提供します。 （ &lt;code&gt;INSENSITIVE&lt;/code&gt; を &lt;code&gt;FOR UPDATE&lt;/code&gt; または &lt;code&gt;FOR SHARE&lt;/code&gt; と一緒に指定するとエラーになります。）</target>
        </trans-unit>
        <trans-unit id="41b7137b15f53bed5b5687626dcf24e407280bf1" translate="yes" xml:space="preserve">
          <source>If the data directory allows group read access then certificate files may need to be located outside of the data directory in order to conform to the security requirements outlined above. Generally, group access is enabled to allow an unprivileged user to backup the database, and in that case the backup software will not be able to read the certificate files and will likely error.</source>
          <target state="translated">データ・ディレクトリがグループ・リード・アクセスを許可している場合、上記のセキュリティ要件を満たすために、証明書ファイルをデータ・ディレクトリの外に配置する必要があるかもしれません。一般的に、グループアクセスは、権限のないユーザがデータベースをバックアップするために有効になっており、その場合、バックアップソフトウェアは証明書ファイルを読み取ることができず、エラーになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a675fdbbcb3f3826a4060560a5255875fb5f5fae" translate="yes" xml:space="preserve">
          <source>If the database crashes during the risk window between an asynchronous commit and the writing of the transaction's WAL records, then changes made during that transaction &lt;em&gt;will&lt;/em&gt; be lost. The duration of the risk window is limited because a background process (the &amp;ldquo;WAL writer&amp;rdquo;) flushes unwritten WAL records to disk every &lt;a href=&quot;runtime-config-wal#GUC-WAL-WRITER-DELAY&quot;&gt;wal_writer_delay&lt;/a&gt; milliseconds. The actual maximum duration of the risk window is three times &lt;code&gt;wal_writer_delay&lt;/code&gt; because the WAL writer is designed to favor writing whole pages at a time during busy periods.</source>
          <target state="translated">非同期間のリスク・ウィンドウ中にデータベースがクラッシュしたコミットとトランザクションのWALレコードの書き込みした場合、そのトランザクション中に行われた変更&lt;em&gt;されます&lt;/em&gt;失われます。バックグラウンドプロセス（「WALライター」）が&lt;a href=&quot;runtime-config-wal#GUC-WAL-WRITER-DELAY&quot;&gt;wal_writer_delay&lt;/a&gt;ミリ秒ごとに未書き込みのWALレコードをディスクにフラッシュするため、リスクウィンドウの期間は制限されます。WALライターはビジー期間中に一度にページ全体を書き込むように設計されているため、リスクウィンドウの実際の最大期間は &lt;code&gt;wal_writer_delay&lt;/code&gt; の 3倍です。</target>
        </trans-unit>
        <trans-unit id="74cf7d60a58d8b38555b75db3e52ebabab25c716" translate="yes" xml:space="preserve">
          <source>If the distance function returns &lt;code&gt;*recheck = true&lt;/code&gt; for any leaf node, the original ordering operator's return type must be &lt;code&gt;float8&lt;/code&gt; or &lt;code&gt;float4&lt;/code&gt;, and the distance function's result values must be comparable to those of the original ordering operator, since the executor will sort using both distance function results and recalculated ordering-operator results. Otherwise, the distance function's result values can be any finite &lt;code&gt;float8&lt;/code&gt; values, so long as the relative order of the result values matches the order returned by the ordering operator. (Infinity and minus infinity are used internally to handle cases such as nulls, so it is not recommended that &lt;code&gt;distance&lt;/code&gt; functions return these values.)</source>
          <target state="translated">距離関数が任意のリーフノードで &lt;code&gt;*recheck = true&lt;/code&gt; を返す場合、元の順序付け演算子の戻り値の型は &lt;code&gt;float8&lt;/code&gt; または &lt;code&gt;float4&lt;/code&gt; である必要があり、距離関数の結果値は元の順序付け演算子の結果値と同等でなければなりません。距離関数の結果と再計算された順序演算子の結果。それ以外の場合、距離関数の結果値は、結果値の相対順序が順序付け演算子によって返される順序と一致する限り、任意の有限の &lt;code&gt;float8&lt;/code&gt; 値にすることができます。 （無限大とマイナス無限大はnullなどのケースを処理するために内部的に使用されるため、 &lt;code&gt;distance&lt;/code&gt; 関数がこれらの値を返すことはお勧めしません。）</target>
        </trans-unit>
        <trans-unit id="ad60be7600e8f04e894b95d59df12f985784fcd2" translate="yes" xml:space="preserve">
          <source>If the expression for any column is not of the correct data type, automatic type conversion will be attempted.</source>
          <target state="translated">いずれかの列の式が正しいデータ型でない場合、自動型変換が試みられます。</target>
        </trans-unit>
        <trans-unit id="fd093b6fb186aee51925fae308b6305eb633a2c9" translate="yes" xml:space="preserve">
          <source>If the extension specifies a &lt;code&gt;schema&lt;/code&gt; parameter in its control file, then that schema cannot be overridden with a &lt;code&gt;SCHEMA&lt;/code&gt; clause. Normally, an error will be raised if a &lt;code&gt;SCHEMA&lt;/code&gt; clause is given and it conflicts with the extension's &lt;code&gt;schema&lt;/code&gt; parameter. However, if the &lt;code&gt;CASCADE&lt;/code&gt; clause is also given, then &lt;code&gt;schema_name&lt;/code&gt; is ignored when it conflicts. The given &lt;code&gt;schema_name&lt;/code&gt; will be used for installation of any needed extensions that do not specify &lt;code&gt;schema&lt;/code&gt; in their control files.</source>
          <target state="translated">拡張機能が制御ファイルで &lt;code&gt;schema&lt;/code&gt; パラメータを指定している場合、そのスキーマは &lt;code&gt;SCHEMA&lt;/code&gt; 句でオーバーライドできません。通常、 &lt;code&gt;SCHEMA&lt;/code&gt; 句が指定され、拡張の &lt;code&gt;schema&lt;/code&gt; パラメータと競合する場合、エラーが発生します。ただし、 &lt;code&gt;CASCADE&lt;/code&gt; 句も指定されている場合、 &lt;code&gt;schema_name&lt;/code&gt; は競合しても無視されます。指定された &lt;code&gt;schema_name&lt;/code&gt; は、制御ファイルで &lt;code&gt;schema&lt;/code&gt; を指定しない必要な拡張機能のインストールに使用されます。</target>
        </trans-unit>
        <trans-unit id="a4e9fcc86b43f21a64730501e9eaf321852f905e" translate="yes" xml:space="preserve">
          <source>If the file name is not an absolute path, it is taken as relative to the directory containing the referencing configuration file. Inclusions can be nested.</source>
          <target state="translated">ファイル名が絶対パスでない場合は、参照する設定ファイルを含むディレクトリからの相対パスとして扱われます。インクルードは入れ子にすることができます。</target>
        </trans-unit>
        <trans-unit id="932910bcbd5980a518e91a591612aedc56d65e69" translate="yes" xml:space="preserve">
          <source>If the final function is declared &amp;ldquo;strict&amp;rdquo;, then it will not be called when the ending state value is null; instead a null result will be returned automatically. (Of course this is just the normal behavior of strict functions.) In any case the final function has the option of returning a null value. For example, the final function for &lt;code&gt;avg&lt;/code&gt; returns null when it sees there were zero input rows.</source>
          <target state="translated">最終関数が「厳密」に宣言されている場合、終了状態の値がnullのときは呼び出されません。代わりに、nullの結果が自動的に返されます。（もちろん、これは厳密な関数の通常の動作にすぎません。）いずれの場合も、最終関数にはnull値を返すオプションがあります。たとえば、 &lt;code&gt;avg&lt;/code&gt; の最後の関数は、入力行がゼロであることがわかるとnullを返します。</target>
        </trans-unit>
        <trans-unit id="6a7650c2a7562a29717aee3a080c7db1eba72918" translate="yes" xml:space="preserve">
          <source>If the first argument is an unquoted &lt;code&gt;-n&lt;/code&gt; the trailing newline is not written.</source>
          <target state="translated">最初の引数が引用符で囲まれていない &lt;code&gt;-n&lt;/code&gt; の場合、末尾の改行は書き込まれません。</target>
        </trans-unit>
        <trans-unit id="62fe782183ded831fa81846fd49b8967105614ff" translate="yes" xml:space="preserve">
          <source>If the function has been defined as returning the &lt;code&gt;record&lt;/code&gt; data type, then an alias or the key word &lt;code&gt;AS&lt;/code&gt; must be present, followed by a column definition list in the form &lt;code&gt;( column_name data_type [, ... ])&lt;/code&gt;. The column definition list must match the actual number and types of columns returned by the function.</source>
          <target state="translated">関数が &lt;code&gt;record&lt;/code&gt; データタイプを返すように定義されている場合、エイリアスまたはキーワード &lt;code&gt;AS&lt;/code&gt; が存在し、その後に &lt;code&gt;( column_name data_type [, ... ])&lt;/code&gt; という形式の列定義リストが続く必要があります。列定義リストは、関数によって返される列の実際の数とタイプと一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="dbc510e12f6154bfb8e0fdb71a70e5f4d7892b1d" translate="yes" xml:space="preserve">
          <source>If the function name is unique in its schema, it can be referred to without an argument list:</source>
          <target state="translated">関数名がスキーマ内で一意であれば、引数リストなしで参照することができます。</target>
        </trans-unit>
        <trans-unit id="02e65f28de3d6ebb00042e2e3e922f9485dd13f2" translate="yes" xml:space="preserve">
          <source>If the index AM wishes to cache data across successive index insertions within a SQL statement, it can allocate space in &lt;code&gt;indexInfo-&amp;gt;ii_Context&lt;/code&gt; and store a pointer to the data in &lt;code&gt;indexInfo-&amp;gt;ii_AmCache&lt;/code&gt; (which will be NULL initially).</source>
          <target state="translated">インデックスAMがSQLステートメント内の連続するインデックス挿入にわたってデータをキャッシュしたい場合は、 &lt;code&gt;indexInfo-&amp;gt;ii_Context&lt;/code&gt; にスペースを割り当て、データへのポインターを &lt;code&gt;indexInfo-&amp;gt;ii_AmCache&lt;/code&gt; （最初はNULLになる）に格納できます。</target>
        </trans-unit>
        <trans-unit id="65ff53fe7f3af3df2bf9787931d50cb513ad0685" translate="yes" xml:space="preserve">
          <source>If the index stores the original indexed data values (and not some lossy representation of them), it is useful to support &lt;a href=&quot;indexes-index-only-scans&quot;&gt;index-only scans&lt;/a&gt;, in which the index returns the actual data not just the TID of the heap tuple. This will only avoid I/O if the visibility map shows that the TID is on an all-visible page; else the heap tuple must be visited anyway to check MVCC visibility. But that is no concern of the access method's.</source>
          <target state="translated">インデックスが元のインデックス付きデータ値を格納している場合（それらの損失のある表現ではない）、&lt;a href=&quot;indexes-index-only-scans&quot;&gt;インデックスのみのスキャン&lt;/a&gt;をサポートすると便利です。この場合、インデックスはヒープタプルのTIDだけでなく実際のデータを返します。これにより、可視性マップがTIDがすべて可視のページ上にあることを示している場合にのみ、I / Oが回避されます。それ以外の場合は、MVCCの可視性を確認するためにヒープタプルにアクセスする必要があります。しかし、それはアクセス方法の問題ではありません。</target>
        </trans-unit>
        <trans-unit id="b10149280f25e55a72b1c339ba61c4a0b943ec93" translate="yes" xml:space="preserve">
          <source>If the index supports &lt;a href=&quot;indexes-index-only-scans&quot;&gt;index-only scans&lt;/a&gt; (i.e., &lt;code&gt;amcanreturn&lt;/code&gt; returns true for it), then on success the AM must also check &lt;code&gt;scan-&amp;gt;xs_want_itup&lt;/code&gt;, and if that is true it must return the originally indexed data for the index entry. The data can be returned in the form of an &lt;code&gt;IndexTuple&lt;/code&gt; pointer stored at &lt;code&gt;scan-&amp;gt;xs_itup&lt;/code&gt;, with tuple descriptor &lt;code&gt;scan-&amp;gt;xs_itupdesc&lt;/code&gt;; or in the form of a &lt;code&gt;HeapTuple&lt;/code&gt; pointer stored at &lt;code&gt;scan-&amp;gt;xs_hitup&lt;/code&gt;, with tuple descriptor &lt;code&gt;scan-&amp;gt;xs_hitupdesc&lt;/code&gt;. (The latter format should be used when reconstructing data that might possibly not fit into an &lt;code&gt;IndexTuple&lt;/code&gt;.) In either case, management of the data referenced by the pointer is the access method's responsibility. The data must remain good at least until the next &lt;code&gt;amgettuple&lt;/code&gt;, &lt;code&gt;amrescan&lt;/code&gt;, or &lt;code&gt;amendscan&lt;/code&gt; call for the scan.</source>
          <target state="translated">インデックスが&lt;a href=&quot;indexes-index-only-scans&quot;&gt;インデックスのみのスキャンを&lt;/a&gt;サポートしている場合（つまり、 &lt;code&gt;amcanreturn&lt;/code&gt; がtrueを返す場合）、成功した場合、AMは &lt;code&gt;scan-&amp;gt;xs_want_itup&lt;/code&gt; もチェックする必要があり、trueの場合は、インデックスエントリの元のインデックス付きデータを返す必要があります。データは、の形式で戻すことができる &lt;code&gt;IndexTuple&lt;/code&gt; ので保存ポインタ &lt;code&gt;scan-&amp;gt;xs_itup&lt;/code&gt; タプル記述子と、 &lt;code&gt;scan-&amp;gt;xs_itupdesc&lt;/code&gt; 。または &lt;code&gt;HeapTuple&lt;/code&gt; &lt;code&gt;scan-&amp;gt;xs_hitup&lt;/code&gt; 保存されたHeapTupleポインタの形式で、タプル記述子 &lt;code&gt;scan-&amp;gt;xs_hitupdesc&lt;/code&gt; を使用します。 （後者の形式は、 &lt;code&gt;IndexTuple&lt;/code&gt; に適合しない可能性のあるデータを再構築するときに使用する必要があります。）どちらの場合でも、ポインターによって参照されるデータの管理は、アクセスメソッドの責任です。データは、少なくとも次の &lt;code&gt;amgettuple&lt;/code&gt; 、 &lt;code&gt;amrescan&lt;/code&gt; 、または &lt;code&gt;amendscan&lt;/code&gt; がスキャンを呼び出すまで、良好な状態を維持する必要があります。</target>
        </trans-unit>
        <trans-unit id="5e5145a56a8fb3d00823c8f07c0c1ff1ea7857b4" translate="yes" xml:space="preserve">
          <source>If the indexed column is of a collatable data type, the index collation will be passed to all the support methods, using the standard &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; mechanism.</source>
          <target state="translated">インデックス付けされた列が照合可能なデータ型である場合、インデックス照合は、標準の &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; メカニズムを使用して、すべてのサポートメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="7d0af38ac011e98a3b87862ced9f4ed1d8303136" translate="yes" xml:space="preserve">
          <source>If the installation process completes without error, you can now start the server normally.</source>
          <target state="translated">エラーなくインストールが完了すれば、正常にサーバーを起動できるようになりました。</target>
        </trans-unit>
        <trans-unit id="801fad259abb36ce1c379ee710b758c893dc848e" translate="yes" xml:space="preserve">
          <source>If the internal structure of &lt;code&gt;box&lt;/code&gt; were an array of four &lt;code&gt;float4&lt;/code&gt; elements, we might instead use:</source>
          <target state="translated">&lt;code&gt;box&lt;/code&gt; の内部構造が4つの &lt;code&gt;float4&lt;/code&gt; 要素の配列である場合は、代わりに次を使用できます。</target>
        </trans-unit>
        <trans-unit id="e0cb06bd991e3803ab381ac962733573ec921a97" translate="yes" xml:space="preserve">
          <source>If the isolation level, read/write mode, or deferrable mode is specified, the new transaction has those characteristics, as if &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; was executed.</source>
          <target state="translated">分離レベル、読み取り/書き込みモード、または遅延可能モードが指定されている場合、新しいトランザクションは、&lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt;が実行されたかのようにそれらの特性を持ちます。</target>
        </trans-unit>
        <trans-unit id="635140eb0238daad7904445c051be894be230f98" translate="yes" xml:space="preserve">
          <source>If the item to retrieve is an element of an array, you have to unnest this array using the &lt;code&gt;[*]&lt;/code&gt; operator. For example, the following path will return location coordinates for all the available track segments:</source>
          <target state="translated">取得する項目が配列の要素である場合は、 &lt;code&gt;[*]&lt;/code&gt; 演算子を使用してこの配列をネスト解除する必要があります。たとえば、次のパスは、使用可能なすべてのトラックセグメントの位置座標を返します。</target>
        </trans-unit>
        <trans-unit id="97c86aa6976c29ec1d54566b16ef172364cf2f75" translate="yes" xml:space="preserve">
          <source>If the key is larger than the hash block size it will first be hashed and the result will be used as key.</source>
          <target state="translated">キーがハッシュブロックのサイズよりも大きい場合は、最初にハッシュ化され、その結果がキーとして使用されます。</target>
        </trans-unit>
        <trans-unit id="1aa8d866b0b556edb093be4c9a0ab389395324da" translate="yes" xml:space="preserve">
          <source>If the last path item is an object key, it will be created if it is absent and given the new value. If the last path item is an array index, if it is positive the item to set is found by counting from the left, and if negative by counting from the right - &lt;code&gt;-1&lt;/code&gt; designates the rightmost element, and so on. If the item is out of the range -array_length .. array_length -1, and create_missing is true, the new value is added at the beginning of the array if the item is negative, and at the end of the array if it is positive.</source>
          <target state="translated">最後のパス項目がオブジェクトキーである場合、それが存在せず、新しい値が与えられると作成されます。最後のパス項目が配列インデックスである場合、それが正である場合には、設定する項目は左から計数によって発見され、右から数えによる負場合- &lt;code&gt;-1&lt;/code&gt; 右端の要素を指定する、というように。項目が-array_length .. array_length -1の範囲外で、create_missingがtrueの場合、項目が負の場合は配列の先頭に、正の場合は配列の末尾に新しい値が追加されます。</target>
        </trans-unit>
        <trans-unit id="2188ba6147e78aaca8d5a46e0dc7277dd7c3324b" translate="yes" xml:space="preserve">
          <source>If the modifier &lt;code&gt;n&lt;/code&gt; (&amp;ldquo;nested&amp;rdquo;) is used, or a pattern is specified, then non-root partitioned relations are included, and a column is shown displaying the parent of each partitioned relation.</source>
          <target state="translated">修飾子 &lt;code&gt;n&lt;/code&gt; （「ネストされた」）が使用されているか、パターンが指定されている場合、非ルートの分割された関係が含まれ、各分割された関係の親を表示する列が表示されます。</target>
        </trans-unit>
        <trans-unit id="954bfa7fec82935e3cdcd8281374d6651335948e" translate="yes" xml:space="preserve">
          <source>If the new connection is successfully made, the previous connection is closed. If the connection attempt failed (wrong user name, access denied, etc.), the previous connection will only be kept if psql is in interactive mode. When executing a non-interactive script, processing will immediately stop with an error. This distinction was chosen as a user convenience against typos on the one hand, and a safety mechanism that scripts are not accidentally acting on the wrong database on the other hand.</source>
          <target state="translated">新しい接続が成功した場合、前の接続は閉じられます。接続の試みが失敗した場合(ユーザ名が間違っている、アクセスが拒否されたなど)、前の接続はpsqlが対話型モードの場合にのみ保持されます。非対話型スクリプトを実行すると、処理は直ちにエラーで停止します。この区別は、一方ではタイプミスに対するユーザの利便性、他方ではスクリプトが誤って間違ったデータベース上で動作しないようにするための安全機構として選ばれました。</target>
        </trans-unit>
        <trans-unit id="2a5e26aea388ddd76a8f217c381769165be706df" translate="yes" xml:space="preserve">
          <source>If the new partition is a foreign table, nothing is done to verify that all the rows in the foreign table obey the partition constraint. (See the discussion in &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; about constraints on the foreign table.)</source>
          <target state="translated">新しいパーティションが外部テーブルである場合、外部テーブルのすべての行がパーティション制約に従っていることを確認するための処理は行われません。（外部テーブルの制約については、&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLEの&lt;/a&gt;説明を参照してください。）</target>
        </trans-unit>
        <trans-unit id="f277321bdd9057205b2810a53bafd6facd91f266" translate="yes" xml:space="preserve">
          <source>If the new partition is a regular table, a full table scan is performed to check that existing rows in the table do not violate the partition constraint. It is possible to avoid this scan by adding a valid &lt;code&gt;CHECK&lt;/code&gt; constraint to the table that allows only rows satisfying the desired partition constraint before running this command. The &lt;code&gt;CHECK&lt;/code&gt; constraint will be used to determine that the table need not be scanned to validate the partition constraint. This does not work, however, if any of the partition keys is an expression and the partition does not accept &lt;code&gt;NULL&lt;/code&gt; values. If attaching a list partition that will not accept &lt;code&gt;NULL&lt;/code&gt; values, also add &lt;code&gt;NOT NULL&lt;/code&gt; constraint to the partition key column, unless it's an expression.</source>
          <target state="translated">新しいパーティションが通常のテーブルである場合、テーブル内の既存の行がパーティションの制約に違反していないことを確認するために、テーブル全体のスキャンが実行されます。このコマンドを実行する前に、目的のパーティション制約を満たす行のみを許可する有効な &lt;code&gt;CHECK&lt;/code&gt; 制約をテーブルに追加することで、このスキャンを回避できます。 &lt;code&gt;CHECK&lt;/code&gt; 制約は、テーブルがパーティション制約を検証するためにスキャンする必要がないことを決定するために使用されます。ただし、パーティションキーのいずれかが式であり、パーティションが &lt;code&gt;NULL&lt;/code&gt; 値を受け入れない場合、これは機能しません。 &lt;code&gt;NULL&lt;/code&gt; 値を受け入れないリストパーティションをアタッチする場合は、 &lt;code&gt;NOT NULL&lt;/code&gt; も追加します 式でない限り、パーティションキー列への制約。</target>
        </trans-unit>
        <trans-unit id="48a04ec2659d2ed3b669f8d3fed6c4aa6cc05212" translate="yes" xml:space="preserve">
          <source>If the new value is inconsistent with the tuple prefix, set &lt;code&gt;resultType&lt;/code&gt; to &lt;code&gt;spgSplitTuple&lt;/code&gt;. This action moves all the existing nodes into a new lower-level inner tuple, and replaces the existing inner tuple with a tuple having a single downlink pointing to the new lower-level inner tuple. Set &lt;code&gt;prefixHasPrefix&lt;/code&gt; to indicate whether the new upper tuple should have a prefix, and if so set &lt;code&gt;prefixPrefixDatum&lt;/code&gt; to the prefix value. This new prefix value must be sufficiently less restrictive than the original to accept the new value to be indexed. Set &lt;code&gt;prefixNNodes&lt;/code&gt; to the number of nodes needed in the new tuple, and set &lt;code&gt;prefixNodeLabels&lt;/code&gt; to a palloc'd array holding their labels, or to NULL if node labels are not required. Note that the total size of the new upper tuple must be no more than the total size of the tuple it is replacing; this constrains the lengths of the new prefix and new labels. Set &lt;code&gt;childNodeN&lt;/code&gt; to the index (from zero) of the node that will downlink to the new lower-level inner tuple. Set &lt;code&gt;postfixHasPrefix&lt;/code&gt; to indicate whether the new lower-level inner tuple should have a prefix, and if so set &lt;code&gt;postfixPrefixDatum&lt;/code&gt; to the prefix value. The combination of these two prefixes and the downlink node's label (if any) must have the same meaning as the original prefix, because there is no opportunity to alter the node labels that are moved to the new lower-level tuple, nor to change any child index entries. After the node has been split, the &lt;code&gt;choose&lt;/code&gt; function will be called again with the replacement inner tuple. That call may return an &lt;code&gt;spgAddNode&lt;/code&gt; result, if no suitable node was created by the &lt;code&gt;spgSplitTuple&lt;/code&gt; action. Eventually &lt;code&gt;choose&lt;/code&gt; must return &lt;code&gt;spgMatchNode&lt;/code&gt; to allow the insertion to descend to the next level.</source>
          <target state="translated">新しい値がタプルのプレフィックスと一致しない場合は、 &lt;code&gt;resultType&lt;/code&gt; を &lt;code&gt;spgSplitTuple&lt;/code&gt; に設定します。このアクションは、既存のすべてのノードを新しい下位レベルの内部タプルに移動し、既存の内部タプルを、新しい下位レベルの内部タプルを指す単一のダウンリンクを持つタプルに置き換えます。 &lt;code&gt;prefixHasPrefix&lt;/code&gt; を設定して、新しい上位タプルにプレフィックスを付ける必要があるかどうかを示し、必要な場合は、 &lt;code&gt;prefixPrefixDatum&lt;/code&gt; をプレフィックス値に設定します。この新しいプレフィックス値は、インデックス付けされる新しい値を受け入れるために、元のプレフィックス値よりも元の値よりも制限が十分に小さくなければなりません。セット &lt;code&gt;prefixNNodes&lt;/code&gt; 新しいタプルに必要なノード数に、設定 &lt;code&gt;prefixNodeLabels&lt;/code&gt; ラベルを保持するpallocされた配列、またはノードラベルが不要な場合はNULL。新しい上位タプルの合計サイズは、それが置き換えるタプルの合計サイズ以下でなければならないことに注意してください。これにより、新しいプレフィックスと新しいラベルの長さが制限されます。セット &lt;code&gt;childNodeN&lt;/code&gt; 新しい下位内側タプルへのダウンリンクするノードの（ゼロから）インデックス。 &lt;code&gt;postfixHasPrefix&lt;/code&gt; を設定して、新しい下位レベルの内部タプルに接頭辞を付ける必要があるかどうかを示し、必要な場合は &lt;code&gt;postfixPrefixDatum&lt;/code&gt; を設定します。接頭辞の値に。これらの2つのプレフィックスとダウンリンクノードのラベル（存在する場合）の組み合わせは、元のプレフィックスと同じ意味を持つ必要があります。これは、新しい下位レベルのタプルに移動されるノードラベルを変更したり、変更したりする機会がないためです。子インデックスエントリ。ノードが分割された後、 &lt;code&gt;choose&lt;/code&gt; した内部タプルを使用して選択関数が再度呼び出されます。 &lt;code&gt;spgSplitTuple&lt;/code&gt; アクションによって適切なノードが作成されなかった場合、その呼び出しは &lt;code&gt;spgAddNode&lt;/code&gt; 結果を返す可能性があります。最終的に &lt;code&gt;choose&lt;/code&gt; 返さなければなりません &lt;code&gt;spgMatchNode&lt;/code&gt; を挿入が次のレベルに降りることができるように。</target>
        </trans-unit>
        <trans-unit id="cad207ddb2eaf025fe9a90fd7f853c4606a19762" translate="yes" xml:space="preserve">
          <source>If the new value matches one of the existing child nodes, set &lt;code&gt;resultType&lt;/code&gt; to &lt;code&gt;spgMatchNode&lt;/code&gt;. Set &lt;code&gt;nodeN&lt;/code&gt; to the index (from zero) of that node in the node array. Set &lt;code&gt;levelAdd&lt;/code&gt; to the increment in &lt;code&gt;level&lt;/code&gt; caused by descending through that node, or leave it as zero if the operator class does not use levels. Set &lt;code&gt;restDatum&lt;/code&gt; to equal &lt;code&gt;leafDatum&lt;/code&gt; if the operator class does not modify datums from one level to the next, or otherwise set it to the modified value to be used as &lt;code&gt;leafDatum&lt;/code&gt; at the next level.</source>
          <target state="translated">新しい値が既存の子ノードのいずれかに一致する場合は、 &lt;code&gt;resultType&lt;/code&gt; を &lt;code&gt;spgMatchNode&lt;/code&gt; に設定します。 &lt;code&gt;nodeN&lt;/code&gt; を、ノード配列内のそのノードの（ゼロからの）インデックスに設定します。 &lt;code&gt;levelAdd&lt;/code&gt; を、そのノードを下降することによって生じる &lt;code&gt;level&lt;/code&gt; の増分に設定するか、演算子クラスがレベル​​を使用しない場合は、ゼロのままにします。セット &lt;code&gt;restDatum&lt;/code&gt; は等しい &lt;code&gt;leafDatum&lt;/code&gt; をオペレータクラスは、次の1つのレベルから基準点を変更しない場合、または他の方法として使用される変更された値に設定 &lt;code&gt;leafDatum&lt;/code&gt; 次のレベルで。</target>
        </trans-unit>
        <trans-unit id="b192c266d3e1a4a0032d805a8345acd4fec22c20" translate="yes" xml:space="preserve">
          <source>If the non-unknown inputs are not all of the same type category, fail.</source>
          <target state="translated">不明な入力がすべて同じタイプのカテゴリではない場合は失敗します。</target>
        </trans-unit>
        <trans-unit id="21b9de4f5d381ca1caadda7c1730c20093d98952" translate="yes" xml:space="preserve">
          <source>If the numeric token contains a colon (&lt;code&gt;:&lt;/code&gt;), this is a time string. Include all subsequent digits and colons.</source>
          <target state="translated">（数値トークンにコロンが含まれている場合 &lt;code&gt;:&lt;/code&gt; ）、これは時間の文字列です。後続のすべての数字とコロンを含めます。</target>
        </trans-unit>
        <trans-unit id="31a587270029792d925fa073ce1717b2b1a5ee50" translate="yes" xml:space="preserve">
          <source>If the numeric token contains a dash (&lt;code&gt;-&lt;/code&gt;), slash (&lt;code&gt;/&lt;/code&gt;), or two or more dots (&lt;code&gt;.&lt;/code&gt;), this is a date string which might have a text month. If a date token has already been seen, it is instead interpreted as a time zone name (e.g., &lt;code&gt;America/New_York&lt;/code&gt;).</source>
          <target state="translated">数値トークンにダッシュ（ &lt;code&gt;-&lt;/code&gt; ）、スラッシュ（ &lt;code&gt;/&lt;/code&gt; ）、または2つ以上のドット（ &lt;code&gt;.&lt;/code&gt; ）が含まれている場合、これはテキスト月を含む可能性がある日付ストリングです。日付トークンがすでに表示されている場合は、代わりにタイムゾーン名として解釈されます（たとえば、 &lt;code&gt;America/New_York&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2ee076bf4dbead171f4fb25426abca0b1193f6e2" translate="yes" xml:space="preserve">
          <source>If the operating system provides support for using multiple locales within a single program (&lt;code&gt;newlocale&lt;/code&gt; and related functions), or if support for ICU is configured, then when a database cluster is initialized, &lt;code&gt;initdb&lt;/code&gt; populates the system catalog &lt;code&gt;pg_collation&lt;/code&gt; with collations based on all the locales it finds in the operating system at the time.</source>
          <target state="translated">オペレーティングシステムが単一のプログラム内で複数のロケールを使用するためのサポート（ &lt;code&gt;newlocale&lt;/code&gt; および関連する機能）を提供する場合、またはICUのサポートが構成されている場合、データベースクラスターが初期化されると、 &lt;code&gt;initdb&lt;/code&gt; はシステムカタログ &lt;code&gt;pg_collation&lt;/code&gt; にすべてのロケールに基づいた照合順序を設定しますそれはその時オペレーティングシステムで見つけます。</target>
        </trans-unit>
        <trans-unit id="ac5399d971a7de7c9b73abf76e58c0bf1b2aae3d" translate="yes" xml:space="preserve">
          <source>If the operation does not complete within the timeout (see option &lt;code&gt;-t&lt;/code&gt;), then &lt;code&gt;pg_ctl&lt;/code&gt; exits with a nonzero exit status. But note that the operation might continue in the background and eventually succeed.</source>
          <target state="translated">操作がタイムアウト時間内に完了しない場合（オプション &lt;code&gt;-t&lt;/code&gt; を参照）、 &lt;code&gt;pg_ctl&lt;/code&gt; はゼロ以外の終了ステータスで終了します。ただし、操作はバックグラウンドで続行され、最終的には成功する場合があります。</target>
        </trans-unit>
        <trans-unit id="14ab0f7eed5fb08edbafe519f61a48bda6216b85" translate="yes" xml:space="preserve">
          <source>If the optional &lt;code&gt;NO CYCLE&lt;/code&gt; key word is specified, any calls to &lt;code&gt;nextval&lt;/code&gt; after the sequence has reached its maximum value will return an error. If neither &lt;code&gt;CYCLE&lt;/code&gt; or &lt;code&gt;NO CYCLE&lt;/code&gt; are specified, the old cycle behavior will be maintained.</source>
          <target state="translated">オプションの &lt;code&gt;NO CYCLE&lt;/code&gt; キーワードが指定されている場合、シーケンスが最大値に達した後に &lt;code&gt;nextval&lt;/code&gt; を呼び出すと、エラーが返されます。 &lt;code&gt;CYCLE&lt;/code&gt; も &lt;code&gt;NO CYCLE&lt;/code&gt; も指定されていない場合、古いサイクルの動作が維持されます。</target>
        </trans-unit>
        <trans-unit id="2dc933189fc3de8b16aa112ce975759af1f0b257" translate="yes" xml:space="preserve">
          <source>If the optional Boolean parameter &lt;code&gt;collatable&lt;/code&gt; is true, column definitions and expressions of the type may carry collation information through use of the &lt;code&gt;COLLATE&lt;/code&gt; clause. It is up to the implementations of the functions operating on the type to actually make use of the collation information; this does not happen automatically merely by marking the type collatable.</source>
          <target state="translated">オプションのブールパラメータ &lt;code&gt;collatable&lt;/code&gt; がtrueの場合、 &lt;code&gt;COLLATE&lt;/code&gt; 句を使用して、列の定義と型の式に照合情報を含めることができます。照合情報を実際に利用するのは、型で動作する関数の実装次第です。これは、タイプを照合可能としてマークするだけでは自動的には発生しません。</target>
        </trans-unit>
        <trans-unit id="bdfeb01a261949b7092b2cbd814cde7a65edc244" translate="yes" xml:space="preserve">
          <source>If the ordering of siblings of the same parent is important, include the &lt;em&gt;&lt;code&gt;orderby_fld&lt;/code&gt;&lt;/em&gt; parameter to specify which field to order siblings by. This field can be of any sortable data type. The output column list must include a final integer serial-number column, if and only if &lt;em&gt;&lt;code&gt;orderby_fld&lt;/code&gt;&lt;/em&gt; is specified.</source>
          <target state="translated">同じ親の兄弟の順序が重要な場合は、&lt;em&gt; &lt;code&gt;orderby_fld&lt;/code&gt; &lt;/em&gt;パラメーターを含めて、&lt;em&gt;兄弟を順序付ける&lt;/em&gt;フィールドを指定します。このフィールドは、任意の並べ替え可能なデータ型にすることができます。&lt;em&gt; &lt;code&gt;orderby_fld&lt;/code&gt; &lt;/em&gt;が指定されている場合にのみ、出力列リストに最終整数シリアル番号列を含める必要があります。</target>
        </trans-unit>
        <trans-unit id="3ed5ab7fc15ec983050d9cabedbfee6290fa8126" translate="yes" xml:space="preserve">
          <source>If the output column is a composite (row) type, and the JSON value is a JSON object, the fields of the object are converted to columns of the output row type by recursive application of these rules.</source>
          <target state="translated">出力列が複合(行)型で、JSON値がJSONオブジェクトの場合、これらのルールを再帰的に適用することで、オブジェクトのフィールドが出力行型の列に変換されます。</target>
        </trans-unit>
        <trans-unit id="c25ff23eb72be3bfb20da8609dc04d07dc26b478" translate="yes" xml:space="preserve">
          <source>If the output column is of type &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt;, the JSON value is just reproduced exactly.</source>
          <target state="translated">出力列のタイプが &lt;code&gt;json&lt;/code&gt; または &lt;code&gt;jsonb&lt;/code&gt; の場合、JSON値は正確に再現されます。</target>
        </trans-unit>
        <trans-unit id="50b9656459eac8e751efab8869d145ae99f220b8" translate="yes" xml:space="preserve">
          <source>If the password is encrypted with SCRAM-SHA-256, it has the format:</source>
          <target state="translated">パスワードがSCRAM-SHA-256で暗号化されている場合は、その形式になります。</target>
        </trans-unit>
        <trans-unit id="d0f9a0afdced3c84c5a56565915bd16c67d24a36" translate="yes" xml:space="preserve">
          <source>If the path expression returns an empty node-set (typically, when it does not match) for a given row, the column will be set to &lt;code&gt;NULL&lt;/code&gt;, unless a &lt;code&gt;default_expression&lt;/code&gt; is specified; then the value resulting from evaluating that expression is used.</source>
          <target state="translated">パス式が指定された行に対して空のノードセットを返す場合（通常、一致しない場合）、 &lt;code&gt;default_expression&lt;/code&gt; が指定されていない限り、列は &lt;code&gt;NULL&lt;/code&gt; に設定されます。次に、その式を評価した結果の値が使用されます。</target>
        </trans-unit>
        <trans-unit id="e0c947f55da31c1d5c1555adf98bd354dc366c84" translate="yes" xml:space="preserve">
          <source>If the primary is isolated from remaining standby servers you should fail over to the best candidate of those other remaining standby servers.</source>
          <target state="translated">プライマリが残りのスタンバイサーバから分離されている場合は、残りのスタンバイサーバの中で最も優れた候補にフェイルオーバーする必要があります。</target>
        </trans-unit>
        <trans-unit id="fa67ddcebd2151f0eb68edd839f12d39677af43a" translate="yes" xml:space="preserve">
          <source>If the primary server fails and the standby server becomes the new primary, and then the old primary restarts, you must have a mechanism for informing the old primary that it is no longer the primary. This is sometimes known as STONITH (Shoot The Other Node In The Head), which is necessary to avoid situations where both systems think they are the primary, which will lead to confusion and ultimately data loss.</source>
          <target state="translated">プライマリサーバが故障してスタンバイサーバが新しいプライマリになり、古いプライマリが再起動した場合、古いプライマリがプライマリではなくなったことを古いプライマリに知らせる仕組みが必要です。これは STONITH (Shoot The Other Node In The Head)と呼ばれることもありますが、両方のシステムが自分たちがプライマリだと思い込んでしまい、混乱を招き、最終的にはデータの損失につながるような状況を避けるために必要です。</target>
        </trans-unit>
        <trans-unit id="5ef10647b0698fbedd9383d4669217342caae5e0" translate="yes" xml:space="preserve">
          <source>If the primary server fails then the standby server should begin failover procedures.</source>
          <target state="translated">プライマリサーバに障害が発生した場合、スタンバイサーバはフェイルオーバー手順を開始する必要があります。</target>
        </trans-unit>
        <trans-unit id="3c8481924c3ba4dda86247ddbf4dd7292be6f835" translate="yes" xml:space="preserve">
          <source>If the private key is protected with a passphrase, the server will prompt for the passphrase and will not start until it has been entered. Using a passphrase by default disables the ability to change the server's SSL configuration without a server restart, but see &lt;a href=&quot;runtime-config-connection#GUC-SSL-PASSPHRASE-COMMAND-SUPPORTS-RELOAD&quot;&gt;ssl_passphrase_command_supports_reload&lt;/a&gt;. Furthermore, passphrase-protected private keys cannot be used at all on Windows.</source>
          <target state="translated">秘密鍵がパスフレーズで保護されている場合、サーバーはパスフレーズの入力を要求し、パスフレーズが入力されるまで起動しません。デフォルトでパスフレーズを使用すると、サーバーを再起動せずにサーバーのSSL構成を変更する機能が無効になりますが、&lt;a href=&quot;runtime-config-connection#GUC-SSL-PASSPHRASE-COMMAND-SUPPORTS-RELOAD&quot;&gt;ssl_passphrase_command_supports_reloadを&lt;/a&gt;参照してください。さらに、パスフレーズで保護された秘密鍵は、Windowsではまったく使用できません。</target>
        </trans-unit>
        <trans-unit id="48f80ecbcca6b903e77ef9cdbab43d62afcd07ee" translate="yes" xml:space="preserve">
          <source>If the procedure has any output parameters, then a result row will be returned, containing the values of those parameters.</source>
          <target state="translated">プロシージャに出力パラメータがある場合は、それらのパラメータの値を含む結果行が返されます。</target>
        </trans-unit>
        <trans-unit id="1290513a0720d5678ce9e07e692a24b4a58d5efd" translate="yes" xml:space="preserve">
          <source>If the products table is set up so that, say, &lt;code&gt;product_id&lt;/code&gt; is the primary key, then it would be enough to group by &lt;code&gt;product_id&lt;/code&gt; in the above example, since name and price would be &lt;em&gt;functionally dependent&lt;/em&gt; on the product ID, and so there would be no ambiguity about which name and price value to return for each product ID group.</source>
          <target state="translated">たとえば、 &lt;code&gt;product_id&lt;/code&gt; が主キーであるように製品テーブルが設定されている場合、名前と価格は&lt;em&gt;機能的&lt;/em&gt;に製品IDに&lt;em&gt;依存&lt;/em&gt;するため、上記の例では &lt;code&gt;product_id&lt;/code&gt; でグループ化するだけで十分です。各製品IDグループに対してどの名前と価格の値を返すかについてのあいまいさはありません。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e03a5d6f408539b4e08801b317931a00ecee94a9" translate="yes" xml:space="preserve">
          <source>If the query contains any window functions (see &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.21&lt;/a&gt; and &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;), these functions are evaluated after any grouping, aggregation, and &lt;code&gt;HAVING&lt;/code&gt; filtering is performed. That is, if the query uses any aggregates, &lt;code&gt;GROUP BY&lt;/code&gt;, or &lt;code&gt;HAVING&lt;/code&gt;, then the rows seen by the window functions are the group rows instead of the original table rows from &lt;code&gt;FROM&lt;/code&gt;/&lt;code&gt;WHERE&lt;/code&gt;.</source>
          <target state="translated">クエリにウィンドウ関数が含まれている場合（&lt;a href=&quot;tutorial-window&quot;&gt;セクション3.5&lt;/a&gt;、&lt;a href=&quot;functions-window&quot;&gt;セクション9.21&lt;/a&gt;、および&lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;セクション4.2.8を&lt;/a&gt;参照）、これらの関数は、グループ化、集計、および &lt;code&gt;HAVING&lt;/code&gt; フィルタリングが実行された後に評価されます。つまり、クエリで集計、 &lt;code&gt;GROUP BY&lt;/code&gt; 、または &lt;code&gt;HAVING&lt;/code&gt; が使用されている場合、ウィンドウ関数によって表示される行は、 &lt;code&gt;FROM&lt;/code&gt; / &lt;code&gt;WHERE&lt;/code&gt; からの元のテーブル行ではなく、グループ行です。</target>
        </trans-unit>
        <trans-unit id="e83ebc0874906fce6a1aa2d76fdc21590b6b98b1" translate="yes" xml:space="preserve">
          <source>If the query fails or does not return one row, no variables are changed.</source>
          <target state="translated">クエリが失敗した場合や、1行を返さなかった場合は、変数は変更されません。</target>
        </trans-unit>
        <trans-unit id="baf42f0acc3f09fcc4a0d0dd54cac78d65c286a5" translate="yes" xml:space="preserve">
          <source>If the query requires joining two or more relations, plans for joining relations are considered after all feasible plans have been found for scanning single relations. The three available join strategies are:</source>
          <target state="translated">クエリが2つ以上の関係を結合する必要がある場合、1つの関係をスキャンして実現可能なプランがすべて見つかった後で、関係を結合するプランが検討されます。利用可能な結合戦略は以下の3つです。</target>
        </trans-unit>
        <trans-unit id="2e9c3a0d6f1b6d02143aa6739bb627c7730a051b" translate="yes" xml:space="preserve">
          <source>If the query uses fewer than &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; relations, a near-exhaustive search is conducted to find the best join sequence. The planner preferentially considers joins between any two relations for which there exist a corresponding join clause in the &lt;code&gt;WHERE&lt;/code&gt; qualification (i.e., for which a restriction like &lt;code&gt;where rel1.attr1=rel2.attr2&lt;/code&gt; exists). Join pairs with no join clause are considered only when there is no other choice, that is, a particular relation has no available join clauses to any other relation. All possible plans are generated for every join pair considered by the planner, and the one that is (estimated to be) the cheapest is chosen.</source>
          <target state="translated">クエリが&lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt;よりも少ない関係を使用する場合は、ほぼ完全な検索が実行され、最適な結合シーケンスが検索されます。プランナは、 &lt;code&gt;WHERE&lt;/code&gt; 修飾に対応する結合句が存在する（つまり、 &lt;code&gt;where rel1.attr1=rel2.attr2&lt;/code&gt; が存在するような制限がある）2つの関係間の結合を優先的に検討します。結合句のない結合ペアは、他に選択肢がない場合、つまり、特定のリレーションに他のリレーションへの使用可能な結合句がない場合にのみ考慮されます。可能なプランはすべて、プランナによって検討されたすべての結合ペアに対して生成され、最も安い（推定される）ものが選択されます。</target>
        </trans-unit>
        <trans-unit id="fcb1910db08273fa485c28070ee9179ceccf3c73" translate="yes" xml:space="preserve">
          <source>If the referenced column(s) are changed frequently, it might be wise to add an index to the referencing column(s) so that referential actions associated with the foreign key constraint can be performed more efficiently.</source>
          <target state="translated">参照される列が頻繁に変更される場合は、外部キー制約に関連する参照アクションをより効率的に実行できるように、参照する列にインデックスを追加するのが賢明かもしれません。</target>
        </trans-unit>
        <trans-unit id="2e6cbc38cc65944231eb0e20f1c30488fbd5652a" translate="yes" xml:space="preserve">
          <source>If the role executing &lt;code&gt;GRANT&lt;/code&gt; holds the required privileges indirectly via more than one role membership path, it is unspecified which containing role will be recorded as having done the grant. In such cases it is best practice to use &lt;code&gt;SET ROLE&lt;/code&gt; to become the specific role you want to do the &lt;code&gt;GRANT&lt;/code&gt; as.</source>
          <target state="translated">&lt;code&gt;GRANT&lt;/code&gt; を実行するロールが複数のロールメンバーシップパスを介して間接的に必要な特権を保持する場合、どのロールが付与を実行したと記録されるかは指定されていません。そのような場合、 &lt;code&gt;SET ROLE&lt;/code&gt; を使用して、 &lt;code&gt;GRANT&lt;/code&gt; を実行する特定の役割になることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="24d9b80ef7c6da193a9a22333ae220223fd8b0ac" translate="yes" xml:space="preserve">
          <source>If the role executing &lt;code&gt;REVOKE&lt;/code&gt; holds privileges indirectly via more than one role membership path, it is unspecified which containing role will be used to perform the command. In such cases it is best practice to use &lt;code&gt;SET ROLE&lt;/code&gt; to become the specific role you want to do the &lt;code&gt;REVOKE&lt;/code&gt; as. Failure to do so might lead to revoking privileges other than the ones you intended, or not revoking anything at all.</source>
          <target state="translated">&lt;code&gt;REVOKE&lt;/code&gt; を実行するロールが複数のロールメンバーシップパスを介して間接的に特権を保持している場合、コマンドを実行するためにどのロールが使用されるかは指定されていません。そのような場合、 &lt;code&gt;SET ROLE&lt;/code&gt; を使用して、 &lt;code&gt;REVOKE&lt;/code&gt; を実行する特定の役割になることをお勧めします。そうしないと、意図した特権以外の特権が取り消されるか、まったく何も取り消されない可能性があります。</target>
        </trans-unit>
        <trans-unit id="9127d1a2bf0d40475f431a0daa0c09f299f8d847" translate="yes" xml:space="preserve">
          <source>If the same channel name is signaled multiple times from the same transaction with identical payload strings, the database server can decide to deliver a single notification only. On the other hand, notifications with distinct payload strings will always be delivered as distinct notifications. Similarly, notifications from different transactions will never get folded into one notification. Except for dropping later instances of duplicate notifications, &lt;code&gt;NOTIFY&lt;/code&gt; guarantees that notifications from the same transaction get delivered in the order they were sent. It is also guaranteed that messages from different transactions are delivered in the order in which the transactions committed.</source>
          <target state="translated">同一のペイロード文字列を使用して、同じトランザクションから同じチャネル名が複数回通知された場合、データベースサーバーは単一の通知のみを配信することを決定できます。一方、個別のペイロード文字列を持つ通知は、常に個別の通知として配信されます。同様に、異なるトランザクションからの通知が1つの通知にまとめられることはありません。重複する通知の &lt;code&gt;NOTIFY&lt;/code&gt; インスタンスをドロップすることを除いて、NOTIFYは、同じトランザクションからの通知が送信された順に配信されることを保証します。また、さまざまなトランザクションからのメッセージが、トランザクションがコミットされた順序で配信されることが保証されています。</target>
        </trans-unit>
        <trans-unit id="25d36a41307a4d14aa722349a681e2f2a7b7eb16" translate="yes" xml:space="preserve">
          <source>If the same column name exists in more than one parent table, an error is reported unless the data types of the columns match in each of the parent tables. If there is no conflict, then the duplicate columns are merged to form a single column in the new table. If the column name list of the new table contains a column name that is also inherited, the data type must likewise match the inherited column(s), and the column definitions are merged into one. If the new table explicitly specifies a default value for the column, this default overrides any defaults from inherited declarations of the column. Otherwise, any parents that specify default values for the column must all specify the same default, or an error will be reported.</source>
          <target state="translated">複数の親テーブルに同じ列名が存在する場合、各親テーブルで列のデータ型が一致しない限り、エラーが報告されます。競合がない場合は、重複した列がマージされて新しいテーブルの単一の列が形成されます。新しいテーブルのカラム名リストに継承されたカラム名が含まれている場合、データ型も継承されたカラムと一致しなければならず、カラム定義は1つにマージされます。新しいテーブルでカラムのデフォルト値が明示的に指定されている場合、このデフォルト値は継承されたカラムの宣言のデフォルト値を上書きします。そうでない場合は、カラムのデフォルト値を指定する親はすべて同じデフォルト値を指定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="52777f31338be443c8719518578a441085b3242b" translate="yes" xml:space="preserve">
          <source>If the scale of a value to be stored is greater than the declared scale of the column, the system will round the value to the specified number of fractional digits. Then, if the number of digits to the left of the decimal point exceeds the declared precision minus the declared scale, an error is raised.</source>
          <target state="translated">保存される値の縮尺が、その列の宣言された縮尺よりも大きい場合、システムは値を指定された小数点以下の桁数に丸めます。そして、小数点以下の桁数が宣言された精度から宣言されたスケールを差し引いた値を超える場合、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="02e920dfe841eca3127cd2deda87b1b0038bf35c" translate="yes" xml:space="preserve">
          <source>If the search path finds multiple functions of identical argument types, only the one appearing earliest in the path is considered. Functions of different argument types are considered on an equal footing regardless of search path position.</source>
          <target state="translated">検索パスが同一の引数型の関数を複数見つけた場合、パス内で最も早く出現した関数のみを考慮します。異なる引数型の関数は、検索パスの位置に関係なく同等に考慮されます。</target>
        </trans-unit>
        <trans-unit id="846c48a5a96c2f9f31d852fa93bd025a2ae37209" translate="yes" xml:space="preserve">
          <source>If the search path finds multiple operators with identical argument types, only the one appearing earliest in the path is considered. Operators with different argument types are considered on an equal footing regardless of search path position.</source>
          <target state="translated">検索パスが同一の引数型を持つ複数の演算子を見つけた場合、パス内で最も早く出現した演算子のみを考慮します。異なる引数型を持つ演算子は、検索パスの位置に関係なく、同等に扱われます。</target>
        </trans-unit>
        <trans-unit id="3c9b16d6feb91ed4af38eb28e886ad3416c7d722" translate="yes" xml:space="preserve">
          <source>If the session user is a database superuser, then a &lt;code&gt;#&lt;/code&gt;, otherwise a &lt;code&gt;&amp;gt;&lt;/code&gt;. (The expansion of this value might change during a database session as the result of the command &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt;.)</source>
          <target state="translated">セッションユーザーがデータベースのスーパーユーザーの場合は &lt;code&gt;#&lt;/code&gt; 、それ以外の場合は &lt;code&gt;&amp;gt;&lt;/code&gt; 。（この値の展開は、コマンド &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; の結果として、データベースセッション中に変更される場合があります。）</target>
        </trans-unit>
        <trans-unit id="21d4dfd38c56bb0f6178a7f714085ed7cf4b3207" translate="yes" xml:space="preserve">
          <source>If the specified table is a partitioned table, each row is routed to the appropriate partition and inserted into it. If the specified table is a partition, an error will occur if one of the input rows violates the partition constraint.</source>
          <target state="translated">指定されたテーブルがパーティショニングされたテーブルの場合,各行は適切なパーティションにルーティングされ,その中に挿入されます.指定されたテーブルがパーティションである場合、入力された行の一つがパーティション制約に違反するとエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="1b245f2cb2a99bf0f8cbbb31a4d055f1ead828c3" translate="yes" xml:space="preserve">
          <source>If the standard and predefined collations are not sufficient, users can create their own collation objects using the SQL command &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt;.</source>
          <target state="translated">標準および事前定義の照合が十分でない場合、ユーザーはSQLコマンド&lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt;を使用して独自の照合オブジェクトを作成できます。</target>
        </trans-unit>
        <trans-unit id="ae6c2a2f4f7ec1ece5d1140f847b0d38361211e2" translate="yes" xml:space="preserve">
          <source>If the standby is promoted to the master during online backup, the backup fails.</source>
          <target state="translated">オンラインバックアップ中にスタンバイがマスターに昇格した場合、バックアップは失敗します。</target>
        </trans-unit>
        <trans-unit id="170908acbec1d5cb0f56e23febc172e3426f4e91" translate="yes" xml:space="preserve">
          <source>If the standby server fails then no failover need take place. If the standby server can be restarted, even some time later, then the recovery process can also be restarted immediately, taking advantage of restartable recovery. If the standby server cannot be restarted, then a full new standby server instance should be created.</source>
          <target state="translated">待機サーバに障害が発生した場合は、フェイルオーバーを行う必要はありません。待機サーバが再起動可能であれば、再起動可能なリカバリの利点を利用して、リカバリプロセスも直ちに再起動することができる。待機サーバが再起動できない場合は、完全な新しい待機サーバのインスタンスを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="05b0c76b7db4a1477637a64b2d47050fce69810a" translate="yes" xml:space="preserve">
          <source>If the standby servers are still running, stop them now using the above instructions.</source>
          <target state="translated">待機サーバーがまだ稼働している場合は、上記の手順で停止させてください。</target>
        </trans-unit>
        <trans-unit id="6049edf261150bf348be6f8bb80514f565d9d8f9" translate="yes" xml:space="preserve">
          <source>If the state transition function is declared &amp;ldquo;strict&amp;rdquo;, then it cannot be called with null inputs. With such a transition function, aggregate execution behaves as follows. Rows with any null input values are ignored (the function is not called and the previous state value is retained). If the initial state value is null, then at the first row with all-nonnull input values, the first argument value replaces the state value, and the transition function is invoked at each subsequent row with all-nonnull input values. This is handy for implementing aggregates like &lt;code&gt;max&lt;/code&gt;. Note that this behavior is only available when &lt;code&gt;state_data_type&lt;/code&gt; is the same as the first &lt;code&gt;arg_data_type&lt;/code&gt;. When these types are different, you must supply a nonnull initial condition or use a nonstrict transition function.</source>
          <target state="translated">状態遷移関数が「厳密」に宣言されている場合、ヌル入力で呼び出すことはできません。このような遷移関数では、集計実行は次のように動作します。null入力値を持つ行は無視されます（関数は呼び出されず、以前の状態値が保持されます）。初期状態値がnullの場合、すべてnull以外の入力値を持つ最初の行で、最初の引数値が状態値を置き換え、すべてのnull以外の入力値を持つ後続の各行で遷移関数が呼び出されます。これは、 &lt;code&gt;max&lt;/code&gt; のような集計を実装するのに便利です。この動作は、 &lt;code&gt;state_data_type&lt;/code&gt; が最初の &lt;code&gt;arg_data_type&lt;/code&gt; と同じ場合にのみ使用できることに注意してください。。これらのタイプが異なる場合は、非ヌルの初期条件を指定するか、非厳密な遷移関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="b6d30b33fa764833043e35a291ca75c71eaca53e" translate="yes" xml:space="preserve">
          <source>If the state transition function is not strict, then it will be called unconditionally at each input row, and must deal with null inputs and null state values for itself. This allows the aggregate author to have full control over the aggregate's handling of null values.</source>
          <target state="translated">状態遷移関数が厳密でない場合は、各入力行で無条件に呼び出され、それ自身でヌル入力とヌル状態値を処理しなければなりません。これにより、集合体の作成者は、集合体によるヌル値の処理を完全に制御することができます。</target>
        </trans-unit>
        <trans-unit id="244bd5a12cbdca1f48ebb0a6febfdca5da532447" translate="yes" xml:space="preserve">
          <source>If the string is declared to be of type &lt;code&gt;varchar&lt;/code&gt;, as might be the case if it comes from a table, then the parser will try to convert it to become &lt;code&gt;text&lt;/code&gt;:</source>
          <target state="translated">文字列が &lt;code&gt;varchar&lt;/code&gt; 型であると宣言されている場合、それがテーブルからのものである場合のように、パーサーはそれを &lt;code&gt;text&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="2dcfcecbf90e5089ccafce06b4b0be1f8904c94c" translate="yes" xml:space="preserve">
          <source>If the subtype is considered to have discrete rather than continuous values, the &lt;code&gt;CREATE TYPE&lt;/code&gt; command should specify a &lt;code&gt;canonical&lt;/code&gt; function. The canonicalization function takes an input range value, and must return an equivalent range value that may have different bounds and formatting. The canonical output for two ranges that represent the same set of values, for example the integer ranges &lt;code&gt;[1, 7]&lt;/code&gt; and &lt;code&gt;[1, 8)&lt;/code&gt;, must be identical. It doesn't matter which representation you choose to be the canonical one, so long as two equivalent values with different formattings are always mapped to the same value with the same formatting. In addition to adjusting the inclusive/exclusive bounds format, a canonicalization function might round off boundary values, in case the desired step size is larger than what the subtype is capable of storing. For instance, a range type over &lt;code&gt;timestamp&lt;/code&gt; could be defined to have a step size of an hour, in which case the canonicalization function would need to round off bounds that weren't a multiple of an hour, or perhaps throw an error instead.</source>
          <target state="translated">サブタイプが連続値ではなく離散値であると見なされる場合、 &lt;code&gt;CREATE TYPE&lt;/code&gt; コマンドは &lt;code&gt;canonical&lt;/code&gt; 関数を指定する必要があります。正規化関数は入力範囲値を取り、異なる境界とフォーマットを持つ可能性のある同等の範囲値を返す必要があります。同じ値のセットを表す2つの範囲の標準出力。たとえば、整数範囲 &lt;code&gt;[1, 7]&lt;/code&gt; 1、7 ]および &lt;code&gt;[1, 8)&lt;/code&gt; 、同一でなければなりません。フォーマットが異なる2つの同等の値が常に同じフォーマットで同じ値にマッピングされている限り、どの表現を標準的なものとして選択するかは問題ではありません。包含/排他境界フォーマットを調整することに加えて、正規化関数は、希望のステップサイズがサブタイプが格納できるものより大きい場合、境界値を四捨五入する場合があります。たとえば、 &lt;code&gt;timestamp&lt;/code&gt; 上の範囲タイプは1時間のステップサイズを持つように定義できます。その場合、正規化関数は1時間の倍数ではない境界を丸めるか、代わりにエラーをスローする必要があります。</target>
        </trans-unit>
        <trans-unit id="417d560f70c3f29f36f195f746fd3ca8a01a2c42" translate="yes" xml:space="preserve">
          <source>If the system administrator for the server's machine cannot be trusted, it is necessary for the client to encrypt the data; this way, unencrypted data never appears on the database server. Data is encrypted on the client before being sent to the server, and database results have to be decrypted on the client before being used.</source>
          <target state="translated">サーバのマシンのシステム管理者が信頼できない場合は、クライアント側でデータを暗号化する必要があります。データはサーバに送信される前にクライアントで暗号化され、データベースの結果は使用される前にクライアントで復号化されなければなりません。</target>
        </trans-unit>
        <trans-unit id="2b3f5f95bd715dfe464206f06b66a58f56802c50" translate="yes" xml:space="preserve">
          <source>If the table as a whole is exclusive-locked by someone else, &lt;code&gt;pgrowlocks&lt;/code&gt; will be blocked.</source>
          <target state="translated">テーブル全体が他の &lt;code&gt;pgrowlocks&lt;/code&gt; によって排他ロックされている場合、pgrowlockはブロックされます。</target>
        </trans-unit>
        <trans-unit id="b50348338bc555a4ab7d45126bfb8dabd633e20f" translate="yes" xml:space="preserve">
          <source>If the table being analyzed has one or more children, &lt;code&gt;ANALYZE&lt;/code&gt; will gather statistics twice: once on the rows of the parent table only, and a second time on the rows of the parent table with all of its children. This second set of statistics is needed when planning queries that traverse the entire inheritance tree. The autovacuum daemon, however, will only consider inserts or updates on the parent table itself when deciding whether to trigger an automatic analyze for that table. If that table is rarely inserted into or updated, the inheritance statistics will not be up to date unless you run &lt;code&gt;ANALYZE&lt;/code&gt; manually.</source>
          <target state="translated">分析中のテーブルに1つ以上の子がある場合、 &lt;code&gt;ANALYZE&lt;/code&gt; は2回統計を収集します。1 回は親テーブルの行のみで、2回目はすべての子を持つ親テーブルの行でです。この2番目の統計セットは、継承ツリー全体を走査するクエリを計画するときに必要です。ただし、autovacuumデーモンは、親テーブル自体の挿入または更新のみを考慮して、そのテーブルの自動分析をトリガーするかどうかを決定します。そのテーブルがめったに挿入または更新されない場合、手動で &lt;code&gt;ANALYZE&lt;/code&gt; を実行しない限り、継承統計は最新の状態になりません。</target>
        </trans-unit>
        <trans-unit id="b96d4460f730e99ad2f5da4b8998b3d561a93287" translate="yes" xml:space="preserve">
          <source>If the table being analyzed is completely empty, &lt;code&gt;ANALYZE&lt;/code&gt; will not record new statistics for that table. Any existing statistics will be retained.</source>
          <target state="translated">分析中のテーブルが完全に空の場合、 &lt;code&gt;ANALYZE&lt;/code&gt; はそのテーブルの新しい統計を記録しません。既存の統計は保持されます。</target>
        </trans-unit>
        <trans-unit id="52dc63831209a4c7bb3899cf1fb2ddca1ef42d36" translate="yes" xml:space="preserve">
          <source>If the table is being scanned using an index, this is the OID of the index being used; otherwise, it is zero.</source>
          <target state="translated">テーブルがインデックスを使用してスキャンされている場合、これは使用されているインデックスのOIDです。</target>
        </trans-unit>
        <trans-unit id="9dfb9ffd9573334faeebb68db3d3df9b1f1f0724" translate="yes" xml:space="preserve">
          <source>If the token is an alphabetic string, match up with possible strings:</source>
          <target state="translated">トークンがアルファベット文字列の場合は、可能性のある文字列と一致させます。</target>
        </trans-unit>
        <trans-unit id="4f40be80901959628e05aea1c30e86478bf9dbb2" translate="yes" xml:space="preserve">
          <source>If the token is numeric only, then it is either a single field or an ISO 8601 concatenated date (e.g., &lt;code&gt;19990113&lt;/code&gt; for January 13, 1999) or time (e.g., &lt;code&gt;141516&lt;/code&gt; for 14:15:16).</source>
          <target state="translated">トークンが数値のみの場合、それは単一のフィールド、またはISO 8601連結日付（たとえば、1999年1月13日の場合は &lt;code&gt;19990113&lt;/code&gt; ）または時刻（たとえば、 &lt;code&gt;141516&lt;/code&gt; ：15：16の場合は141516）のいずれかです。</target>
        </trans-unit>
        <trans-unit id="003398a89e69d2198b671a9677907bb24f534582" translate="yes" xml:space="preserve">
          <source>If the token is three digits and a year has already been read, then interpret as day of year.</source>
          <target state="translated">トークンが3桁で、すでに年が読み込まれている場合は、年の日と解釈します。</target>
        </trans-unit>
        <trans-unit id="d3ac616dded1315bedadfd2b91efaa1cf49163f8" translate="yes" xml:space="preserve">
          <source>If the token starts with a plus (&lt;code&gt;+&lt;/code&gt;) or minus (&lt;code&gt;-&lt;/code&gt;), then it is either a numeric time zone or a special field.</source>
          <target state="translated">トークンがプラス（ &lt;code&gt;+&lt;/code&gt; ）またはマイナス（ &lt;code&gt;-&lt;/code&gt; ）で始まる場合、それは数値のタイムゾーンまたは特別なフィールドです。</target>
        </trans-unit>
        <trans-unit id="611739a43cf34a105bb65434365f4074cf8756df" translate="yes" xml:space="preserve">
          <source>If the transaction modified any run-time parameters with &lt;code&gt;SET&lt;/code&gt; (without the &lt;code&gt;LOCAL&lt;/code&gt; option), those effects persist after &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt;, and will not be affected by any later &lt;code&gt;COMMIT PREPARED&lt;/code&gt; or &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt;. Thus, in this one respect &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; acts more like &lt;code&gt;COMMIT&lt;/code&gt; than &lt;code&gt;ROLLBACK&lt;/code&gt;.</source>
          <target state="translated">トランザクションが &lt;code&gt;SET&lt;/code&gt; （ &lt;code&gt;LOCAL&lt;/code&gt; オプションなし）を使用して実行時パラメーターを変更した場合、それらの影響は &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; の後も持続し、その後の &lt;code&gt;COMMIT PREPARED&lt;/code&gt; または &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; の影響を受けません。したがって、この点で &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; は &lt;code&gt;ROLLBACK&lt;/code&gt; よりも &lt;code&gt;COMMIT&lt;/code&gt; のように機能します。</target>
        </trans-unit>
        <trans-unit id="07ad8422becd50d9414841f3815863dc01f955f6" translate="yes" xml:space="preserve">
          <source>If the type being ordered (&lt;code&gt;type1&lt;/code&gt;) is collatable, the appropriate collation OID will be passed to the &lt;code&gt;in_range&lt;/code&gt; function, using the standard PG_GET_COLLATION() mechanism.</source>
          <target state="translated">順序付けされるタイプ（ &lt;code&gt;type1&lt;/code&gt; ）が照合可能である場合、標準のPG_GET_COLLATION（）メカニズムを使用して、適切な照合OIDが &lt;code&gt;in_range&lt;/code&gt; 関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="0affc2c3fcf33ac8518f76b37e69d5d8764c5216" translate="yes" xml:space="preserve">
          <source>If the unique constraint is deferrable, there is additional complexity: we need to be able to insert an index entry for a new row, but defer any uniqueness-violation error until end of statement or even later. To avoid unnecessary repeat searches of the index, the index access method should do a preliminary uniqueness check during the initial insertion. If this shows that there is definitely no conflicting live tuple, we are done. Otherwise, we schedule a recheck to occur when it is time to enforce the constraint. If, at the time of the recheck, both the inserted tuple and some other tuple with the same key are live, then the error must be reported. (Note that for this purpose, &amp;ldquo;live&amp;rdquo; actually means &amp;ldquo;any tuple in the index entry's HOT chain is live&amp;rdquo;.) To implement this, the &lt;code&gt;aminsert&lt;/code&gt; function is passed a &lt;code&gt;checkUnique&lt;/code&gt; parameter having one of the following values:</source>
          <target state="translated">一意制約が延期可能である場合、さらに複雑になります。新しい行のインデックスエントリを挿入できるようにする必要がありますが、一意性違反エラーはステートメントの終わりまで、または後で延期する必要があります。インデックスの不要な繰り返し検索を回避するために、インデックスアクセスメソッドは、最初の挿入時に予備的な一意性チェックを行う必要があります。これにより、競合するライブタプルがないことが確実に示されれば、完了です。それ以外の場合は、制約を適用するときに再チェックが行われるようにスケジュールします。再チェック時に、挿入されたタプルと同じキーを持つ他のタプルの両方がライブである場合、エラーを報告する必要があります。 （この目的のために、「ライブ」は実際には「インデックスエントリのHOTチェーン内のすべてのタプルがライブである」ことを意味することに注意してください。）これを実装するには、 &lt;code&gt;aminsert&lt;/code&gt; 関数に &lt;code&gt;checkUnique&lt;/code&gt; 次のいずれかの値を持つcheckUniqueパラメータ：</target>
        </trans-unit>
        <trans-unit id="0ccba0a1dbc7e9db8732870253e268a51ede19e4" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;-&lt;/code&gt; (dash) is specified as target directory, the tar contents will be written to standard output, suitable for piping to for example gzip. This is only possible if the cluster has no additional tablespaces and WAL streaming is not used.</source>
          <target state="translated">値 &lt;code&gt;-&lt;/code&gt; （ダッシュ）がターゲットディレクトリとして指定されている場合、tarの内容は標準出力に書き込まれ、たとえばgzipへのパイピングに適しています。これは、クラスターに追加のテーブルスペースがなく、WALストリーミングが使用されていない場合にのみ可能です。</target>
        </trans-unit>
        <trans-unit id="444b2da78b5aef7c45b208ec5e7f996fc4602364" translate="yes" xml:space="preserve">
          <source>If the value is 1 (the default) or above, float values are output in shortest-precise format; see &lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;Section 8.1.3&lt;/a&gt;. The actual number of digits generated depends only on the value being output, not on the value of this parameter. At most 17 digits are required for &lt;code&gt;float8&lt;/code&gt; values, and 9 for &lt;code&gt;float4&lt;/code&gt; values. This format is both fast and precise, preserving the original binary float value exactly when correctly read. For historical compatibility, values up to 3 are permitted.</source>
          <target state="translated">値が1（デフォルト）以上の場合、float値は最短精度の形式で出力されます。&lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;セクション8.1.3を&lt;/a&gt;参照してください。生成される実際の桁数は、出力される値にのみ依存し、このパラメーターの値には依存しません。 &lt;code&gt;float8&lt;/code&gt; 値には最大17桁、 &lt;code&gt;float4&lt;/code&gt; 値には最大 9 桁が必要です。この形式は高速かつ正確であり、正しく読み取られたときに元のバイナリfloat値を正確に保持します。過去の互換性のために、3までの値が許可されています。</target>
        </trans-unit>
        <trans-unit id="a0cc84e480979f938d4633f92cd03d8f6fccf694" translate="yes" xml:space="preserve">
          <source>If the value is zero or negative, then the output is rounded to a given decimal precision. The precision used is the standard number of digits for the type (&lt;code&gt;FLT_DIG&lt;/code&gt; or &lt;code&gt;DBL_DIG&lt;/code&gt; as appropriate) reduced according to the value of this parameter. (For example, specifying -1 will cause &lt;code&gt;float4&lt;/code&gt; values to be output rounded to 5 significant digits, and &lt;code&gt;float8&lt;/code&gt; values rounded to 14 digits.) This format is slower and does not preserve all the bits of the binary float value, but may be more human-readable.</source>
          <target state="translated">値がゼロまたは負の場合、出力は指定された小数精度に丸められます。使用される精度は、このパラメーターの値に応じて削減されたタイプ（ &lt;code&gt;FLT_DIG&lt;/code&gt; または &lt;code&gt;DBL_DIG&lt;/code&gt; のいずれか適切なもの）の標準の桁数です。 （たとえば、-1を指定すると、 &lt;code&gt;float4&lt;/code&gt; 値は5桁の有効数字に丸められ、 &lt;code&gt;float8&lt;/code&gt; 値は14桁に丸められます。）この形式は低速で、バイナリfloat値のすべてのビットを保持しませんが、人間が読める。</target>
        </trans-unit>
        <trans-unit id="1bde8627196fca1b915cdbfcafe6a9bc91cc16ce" translate="yes" xml:space="preserve">
          <source>If the value written for an element is &lt;code&gt;NULL&lt;/code&gt; (in any case variant), the element is taken to be NULL. The presence of any quotes or backslashes disables this and allows the literal string value &amp;ldquo;NULL&amp;rdquo; to be entered. Also, for backward compatibility with pre-8.2 versions of PostgreSQL, the &lt;a href=&quot;runtime-config-compatible#GUC-ARRAY-NULLS&quot;&gt;array_nulls&lt;/a&gt; configuration parameter can be turned &lt;code&gt;off&lt;/code&gt; to suppress recognition of &lt;code&gt;NULL&lt;/code&gt; as a NULL.</source>
          <target state="translated">要素に書き込まれた値が &lt;code&gt;NULL&lt;/code&gt; の場合（どのような場合でも）、要素はNULLと見なされます。引用符やバックスラッシュがあると、これが無効になり、リテラル文字列値「NULL」を入力できます。また、8.2より前のバージョンのPostgreSQLとの下位互換性のために、&lt;a href=&quot;runtime-config-compatible#GUC-ARRAY-NULLS&quot;&gt;array_nulls&lt;/a&gt;構成パラメーターを &lt;code&gt;off&lt;/code&gt; して、NULL を &lt;code&gt;NULL&lt;/code&gt; として認識しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="c41c4c976de57b5cc72ea9d7bfdcc6564b8b256b" translate="yes" xml:space="preserve">
          <source>If the view is automatically updatable the system will convert any &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; statement on the view into the corresponding statement on the underlying base relation. &lt;code&gt;INSERT&lt;/code&gt; statements that have an &lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; clause are fully supported.</source>
          <target state="translated">ビューが自動的に更新可能な場合、システムはビューの &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、または &lt;code&gt;DELETE&lt;/code&gt; ステートメントを、基礎となる基本リレーションの対応するステートメントに変換します。 &lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; 句を含む &lt;code&gt;INSERT&lt;/code&gt; ステートメントは完全にサポートされています。</target>
        </trans-unit>
        <trans-unit id="650d690f75ae406d20b34e538980576f232072f4" translate="yes" xml:space="preserve">
          <source>If the width comes from a function argument, that argument is consumed before the argument that is used for the format specifier's value. If the width argument is negative, the result is left aligned (as if the &lt;code&gt;-&lt;/code&gt; flag had been specified) within a field of length &lt;code&gt;abs&lt;/code&gt;(&lt;code&gt;width&lt;/code&gt;).</source>
          <target state="translated">幅が関数引数に由来する場合、その引数は、フォーマット指定子の値に使用される引数の前に消費されます。width引数が負の場合、結果は（ &lt;code&gt;-&lt;/code&gt; フラグが指定された場合と同様に）長さ &lt;code&gt;abs&lt;/code&gt; （ &lt;code&gt;width&lt;/code&gt; ）のフィールド内で左揃えになります。</target>
        </trans-unit>
        <trans-unit id="ee835cdf2017b10d24cc5c26f6abffc684a96735" translate="yes" xml:space="preserve">
          <source>If there are both &lt;code&gt;unknown&lt;/code&gt; and known-type arguments, and all the known-type arguments have the same type, assume that the &lt;code&gt;unknown&lt;/code&gt; arguments are also of that type, and check which candidates can accept that type at the &lt;code&gt;unknown&lt;/code&gt;-argument positions. If exactly one candidate passes this test, use it. Otherwise, fail.</source>
          <target state="translated">両方がある場合は &lt;code&gt;unknown&lt;/code&gt; および既知の型の引数、およびすべての既知の型の引数は、同じ型を持っていることを前提とし &lt;code&gt;unknown&lt;/code&gt; 引数はまた、そのタイプのものであり、候補者にそのタイプ受け入れることができ、チェック &lt;code&gt;unknown&lt;/code&gt; -argument位置を。ちょうど1人の候補者がこのテストに合格した場合、それを使用します。そうでなければ、失敗します。</target>
        </trans-unit>
        <trans-unit id="13cac4b83f93f0a857eb5390b899f2b2b2cbf1c2" translate="yes" xml:space="preserve">
          <source>If there are conflicting non-default implicit collations among the input expressions, then the combination is deemed to have indeterminate collation. This is not an error condition unless the particular function being invoked requires knowledge of the collation it should apply. If it does, an error will be raised at run-time.</source>
          <target state="translated">入力式の中にデフォルト以外の暗黙の照合が競合する場合、その組み合わせは不確定な照合を持っているとみなされます。これは、呼び出される特定の関数が適用すべき照合の知識を必要としない限り、エラー条件ではありません。その場合、実行時にエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="28d65a2d08624ffa80deb6c7246a1682969ee379" translate="yes" xml:space="preserve">
          <source>If there are eight or six digits, and if no other date fields have been previously read, then interpret as a &amp;ldquo;concatenated date&amp;rdquo; (e.g., &lt;code&gt;19990118&lt;/code&gt; or &lt;code&gt;990118&lt;/code&gt;). The interpretation is &lt;code&gt;YYYYMMDD&lt;/code&gt; or &lt;code&gt;YYMMDD&lt;/code&gt;.</source>
          <target state="translated">8桁または6桁で、他の日付フィールドが以前に読み取られていない場合は、「連結日付」として解釈されます（たとえば、 &lt;code&gt;19990118&lt;/code&gt; または &lt;code&gt;990118&lt;/code&gt; ）。解釈は &lt;code&gt;YYYYMMDD&lt;/code&gt; または &lt;code&gt;YYMMDD&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="06c3232f6496ea373f86e0b58b23d8cc590947a5" translate="yes" xml:space="preserve">
          <source>If there are separate indexes on several of the columns referenced in &lt;code&gt;WHERE&lt;/code&gt;, the planner might choose to use an AND or OR combination of the indexes:</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; で参照されるいくつかの列に個別のインデックスがある場合、プランナはインデックスのANDまたはORの組み合わせを使用することを選択できます。</target>
        </trans-unit>
        <trans-unit id="99c2725fb0d24809952a5ff770d9ef79057a3c26" translate="yes" xml:space="preserve">
          <source>If there are triggers (&lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;Chapter 38&lt;/a&gt;) on the target table, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the row as modified by the triggers. Thus, inspecting columns computed by triggers is another common use-case for &lt;code&gt;RETURNING&lt;/code&gt;.</source>
          <target state="translated">ターゲット表にトリガー（&lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;第38章&lt;/a&gt;）がある場合、 &lt;code&gt;RETURNING&lt;/code&gt; で使用可能なデータは、トリガーによって変更された行です。したがって、トリガーによって計算された列の検査は、 &lt;code&gt;RETURNING&lt;/code&gt; のもう1つの一般的な使用例です。</target>
        </trans-unit>
        <trans-unit id="5b8c31e042fe2150c30030dae6c6269655420443" translate="yes" xml:space="preserve">
          <source>If there is a need to filter or group rows after the window calculations are performed, you can use a sub-select. For example:</source>
          <target state="translated">ウィンドウ計算が実行された後に、行をフィルタリングしたりグループ化したりする必要がある場合は、サブセレクトを使用することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="cffa77db1a4b360ae7233f9c0f0ce7a0bc209389" translate="yes" xml:space="preserve">
          <source>If there is a record with LSN exactly equal to &lt;code&gt;lsn&lt;/code&gt;, the record will be processed.</source>
          <target state="translated">LSNが &lt;code&gt;lsn&lt;/code&gt; と完全に等しいレコードがある場合、そのレコードが処理されます。</target>
        </trans-unit>
        <trans-unit id="83cce96057188d3a7386156bf2623596a5029da8" translate="yes" xml:space="preserve">
          <source>If there is an index and we use a query with an indexable &lt;code&gt;WHERE&lt;/code&gt; condition, &lt;code&gt;EXPLAIN&lt;/code&gt; might show a different plan:</source>
          <target state="translated">インデックスがあり、インデックス付け可能な &lt;code&gt;WHERE&lt;/code&gt; 条件でクエリを使用する場合、 &lt;code&gt;EXPLAIN&lt;/code&gt; は異なるプランを表示する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ed6480e8e6205c3cafadde0e83045f72ff5c9888" translate="yes" xml:space="preserve">
          <source>If there is more than one direct parent for a child table (multiple inheritance), this number tells the order in which the inherited columns are to be arranged. The count starts at 1.</source>
          <target state="translated">子テーブルの直接の親が複数ある場合(多重継承)、この数は継承された列を配置する順番を示します。カウントは 1 から始まります。</target>
        </trans-unit>
        <trans-unit id="b83d35fcbb1d8a1926cc7ad31b3e2d51f2485b81" translate="yes" xml:space="preserve">
          <source>If there is no setting named &lt;em&gt;&lt;code&gt;setting_name&lt;/code&gt;&lt;/em&gt;, &lt;code&gt;current_setting&lt;/code&gt; throws an error unless &lt;em&gt;&lt;code&gt;missing_ok&lt;/code&gt;&lt;/em&gt; is supplied and is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;setting_name&lt;/code&gt; &lt;/em&gt;という名前の設定がない場合、&lt;em&gt; &lt;code&gt;missing_ok&lt;/code&gt; &lt;/em&gt;が指定されていて &lt;code&gt;true&lt;/code&gt; でない限り、 &lt;code&gt;current_setting&lt;/code&gt; はエラーをスローします。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="993f6bab11125bc0a23a8d9c66d2ae0ec051d5b8" translate="yes" xml:space="preserve">
          <source>If there's a record with LSN exactly equal to &lt;code&gt;lsn&lt;/code&gt;, the record will be output.</source>
          <target state="translated">LSNが &lt;code&gt;lsn&lt;/code&gt; と完全に等しいレコードがある場合、そのレコードが出力されます。</target>
        </trans-unit>
        <trans-unit id="51e95a5e2098ab1866ec414690874be8c0926635" translate="yes" xml:space="preserve">
          <source>If these two fundamental requirements are met, then all the data values required by the query are available from the index, so an index-only scan is physically possible. But there is an additional requirement for any table scan in PostgreSQL: it must verify that each retrieved row be &amp;ldquo;visible&amp;rdquo; to the query's MVCC snapshot, as discussed in &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;. Visibility information is not stored in index entries, only in heap entries; so at first glance it would seem that every row retrieval would require a heap access anyway. And this is indeed the case, if the table row has been modified recently. However, for seldom-changing data there is a way around this problem. PostgreSQL tracks, for each page in a table's heap, whether all rows stored in that page are old enough to be visible to all current and future transactions. This information is stored in a bit in the table's &lt;em&gt;visibility map&lt;/em&gt;. An index-only scan, after finding a candidate index entry, checks the visibility map bit for the corresponding heap page. If it's set, the row is known visible and so the data can be returned with no further work. If it's not set, the heap entry must be visited to find out whether it's visible, so no performance advantage is gained over a standard index scan. Even in the successful case, this approach trades visibility map accesses for heap accesses; but since the visibility map is four orders of magnitude smaller than the heap it describes, far less physical I/O is needed to access it. In most situations the visibility map remains cached in memory all the time.</source>
          <target state="translated">これら2つの基本的な要件が満たされている場合、クエリで必要なすべてのデータ値がインデックスから取得できるため、物理的にインデックスのみのスキャンが可能です。ただし、PostgreSQLのテーブルスキャンには追加の要件があります。&lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;第13章で&lt;/a&gt;説明したように、取得した各行がクエリのMVCCスナップショットに「可視」であることを確認する必要があります。。可視性情報は、ヒープエントリにのみ保存され、インデックスエントリには保存されません。したがって、一見すると、すべての行の取得にはとにかくヒープアクセスが必要であるように見えます。そして、テーブルの行が最近変更された場合、これは確かに事実です。ただし、データをほとんど変更しない場合は、この問題を回避する方法があります。 PostgreSQLは、テーブルのヒープ内の各ページについて、そのページに格納されているすべての行が、現在および将来のすべてのトランザクションから見えるほど古いかどうかを追跡します。この情報は、テーブルの&lt;em&gt;可視性マップ&lt;/em&gt;のビットに格納され&lt;em&gt;ます&lt;/em&gt;。インデックスのみのスキャンは、候補インデックスエントリを見つけた後、対応するヒープページの可視性マップビットをチェックします。設定されている場合、行は可視であることがわかっているため、追加の作業なしでデータを返すことができます。設定されていない場合は、ヒープエントリにアクセスして、それが表示されているかどうかを確認する必要があるため、標準のインデックススキャンに比べてパフォーマンスは向上しません。成功した場合でも、このアプローチは可視性マップアクセスとヒープアクセスを交換します。しかし、可視性マップはそれが記述するヒープより4桁小さいため、それにアクセスするために必要な物理I / Oははるかに少なくなります。ほとんどの場合、可視性マップは常にメモリにキャッシュされたままです。</target>
        </trans-unit>
        <trans-unit id="c547d5a570870983467a7ef7a622b57db3de5cb6" translate="yes" xml:space="preserve">
          <source>If this clause is specified, then any values supplied for identity columns defined as &lt;code&gt;GENERATED BY DEFAULT&lt;/code&gt; are ignored and the default sequence-generated values are applied.</source>
          <target state="translated">この句が指定されている場合、 &lt;code&gt;GENERATED BY DEFAULT&lt;/code&gt; として定義されているID列に指定された値はすべて無視され、デフォルトのシーケンス生成値が適用されます。</target>
        </trans-unit>
        <trans-unit id="bc20641c7b7db884166e9f2d507911850e3a7612" translate="yes" xml:space="preserve">
          <source>If this file exists in the data directory, pg_ctl (in &lt;code&gt;restart&lt;/code&gt; mode) will pass the contents of the file as options to postgres, unless overridden by the &lt;code&gt;-o&lt;/code&gt; option. The contents of this file are also displayed in &lt;code&gt;status&lt;/code&gt; mode.</source>
          <target state="translated">このファイルがデータディレクトリに存在する場合、pg_ctl（ &lt;code&gt;restart&lt;/code&gt; モード）は、 &lt;code&gt;-o&lt;/code&gt; オプションで上書きされない限り、ファイルの内容をオプションとしてpostgresに渡します。このファイルの内容は、 &lt;code&gt;status&lt;/code&gt; モードでも表示されます。</target>
        </trans-unit>
        <trans-unit id="50767742cba8dcb6350d1c58ae8e0156ac5a9fe6" translate="yes" xml:space="preserve">
          <source>If this happens, you will see a kernel message that looks like this (consult your system documentation and configuration on where to look for such a message):</source>
          <target state="translated">このような場合、このようなカーネルメッセージが表示されます (このようなメッセージがどこにあるかについては、システムのドキュメントや設定を参照してください)。</target>
        </trans-unit>
        <trans-unit id="2441da5aa28be6dd0d7fce7180a9ead106be298e" translate="yes" xml:space="preserve">
          <source>If this is a composite type (see &lt;code&gt;typtype&lt;/code&gt;), then this column points to the &lt;code&gt;pg_class&lt;/code&gt; entry that defines the corresponding table. (For a free-standing composite type, the &lt;code&gt;pg_class&lt;/code&gt; entry doesn't really represent a table, but it is needed anyway for the type's &lt;code&gt;pg_attribute&lt;/code&gt; entries to link to.) Zero for non-composite types.</source>
          <target state="translated">これが複合型（ &lt;code&gt;typtype&lt;/code&gt; を参照）の場合、この列は対応するテーブルを定義する &lt;code&gt;pg_class&lt;/code&gt; エントリを指します。（独立型の複合型の場合、 &lt;code&gt;pg_class&lt;/code&gt; エントリは実際にはテーブルを表しませんが、いずれにしても、型の &lt;code&gt;pg_attribute&lt;/code&gt; エントリがリンクするために必要です。）非複合型の場合はゼロ。</target>
        </trans-unit>
        <trans-unit id="e7bc989c1a71dcf27e6c15912a9e239eb02b9ff1" translate="yes" xml:space="preserve">
          <source>If this is a domain (see &lt;code&gt;typtype&lt;/code&gt;), then &lt;code&gt;typbasetype&lt;/code&gt; identifies the type that this one is based on. Zero if this type is not a domain.</source>
          <target state="translated">これがドメインの場合（ &lt;code&gt;typtype&lt;/code&gt; を参照）、typbasetypeはこのドメインの &lt;code&gt;typbasetype&lt;/code&gt; となるタイプを識別します。このタイプがドメインでない場合はゼロ。</target>
        </trans-unit>
        <trans-unit id="69cd51fd1807ea0656502f0a70cd88e1db17db63" translate="yes" xml:space="preserve">
          <source>If this is a table or an index, the access method used (heap, B-tree, hash, etc.)</source>
          <target state="translated">これがテーブルやインデックスの場合は、使用したアクセス方法(ヒープ、Bツリー、ハッシュなど)。</target>
        </trans-unit>
        <trans-unit id="6657b3960fa7e0cd88d2aa8dcc3b355ae7df8c2d" translate="yes" xml:space="preserve">
          <source>If this is on, you should create users as &lt;code&gt;username@dbname&lt;/code&gt;. When &lt;code&gt;username&lt;/code&gt; is passed by a connecting client, &lt;code&gt;@&lt;/code&gt; and the database name are appended to the user name and that database-specific user name is looked up by the server. Note that when you create users with names containing &lt;code&gt;@&lt;/code&gt; within the SQL environment, you will need to quote the user name.</source>
          <target state="translated">これがオンの場合、ユーザーを &lt;code&gt;username@dbname&lt;/code&gt; として作成する必要があります。場合は &lt;code&gt;username&lt;/code&gt; 接続しているクライアントによって渡され、 &lt;code&gt;@&lt;/code&gt; とデータベース名、ユーザー名に付加され、そのデータベース固有のユーザー名は、サーバーによって検索されます。SQL環境で &lt;code&gt;@&lt;/code&gt; を含む名前のユーザーを作成する場合は、ユーザー名を引用符で囲む必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8483faa9a2017341557263992633a169be114a21" translate="yes" xml:space="preserve">
          <source>If this option is enabled along with &lt;code&gt;compat_realm&lt;/code&gt;, the user name from the Kerberos UPN is used for authentication. If it is disabled (the default), the SAM-compatible user name is used. By default, these two names are identical for new user accounts.</source>
          <target state="translated">このオプションを &lt;code&gt;compat_realm&lt;/code&gt; とともに有効にすると、Kerberos UPNからのユーザー名が認証に使用されます。無効（デフォルト）の場合、SAM互換のユーザー名が使用されます。デフォルトでは、これら2つの名前は新しいユーザーアカウントで同一です。</target>
        </trans-unit>
        <trans-unit id="371ee180f233c6aad73716af3849b71651b391c0" translate="yes" xml:space="preserve">
          <source>If this option is not specified and the server supports temporary replication slots (version 10 and later), then a temporary replication slot is automatically used for WAL streaming.</source>
          <target state="translated">このオプションが指定されておらず、サーバが一時的なレプリケーションスロット(バージョン10以降)をサポートしている場合、一時的なレプリケーションスロットが自動的にWALストリーミングに使用されます。</target>
        </trans-unit>
        <trans-unit id="2f8215b3963efef20de5d0e001e32b15d0b1fd74" translate="yes" xml:space="preserve">
          <source>If this parameter contains an &lt;code&gt;=&lt;/code&gt; sign or starts with a valid URI prefix (&lt;code&gt;postgresql://&lt;/code&gt; or &lt;code&gt;postgres://&lt;/code&gt;), it is treated as a &lt;em&gt;&lt;code&gt;conninfo&lt;/code&gt;&lt;/em&gt; string. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html&quot;&gt;Section 33.1&lt;/a&gt; for more information.</source>
          <target state="translated">このパラメーターに &lt;code&gt;=&lt;/code&gt; 記号が含まれている場合、または有効なURIプレフィックス（ &lt;code&gt;postgresql://&lt;/code&gt; または &lt;code&gt;postgres://&lt;/code&gt; ）で始まる場合、それは&lt;em&gt; &lt;code&gt;conninfo&lt;/code&gt; &lt;/em&gt;文字列として扱われます。詳細は&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html&quot;&gt;項33.1&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="eb980e2e2f9be562491c46b5659937146807845b" translate="yes" xml:space="preserve">
          <source>If this parameter contains an &lt;code&gt;=&lt;/code&gt; sign or starts with a valid URI prefix (&lt;code&gt;postgresql://&lt;/code&gt; or &lt;code&gt;postgres://&lt;/code&gt;), it is treated as a &lt;em&gt;&lt;code&gt;conninfo&lt;/code&gt;&lt;/em&gt; string. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt; for more information.</source>
          <target state="translated">このパラメーターに &lt;code&gt;=&lt;/code&gt; 記号が含まれている場合、または有効なURIプレフィックス（ &lt;code&gt;postgresql://&lt;/code&gt; または &lt;code&gt;postgres://&lt;/code&gt; ）で始まる場合、それは&lt;em&gt; &lt;code&gt;conninfo&lt;/code&gt; &lt;/em&gt;文字列として扱われます。詳細は&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;項33.1.1&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e5a94a371e1e757fb5a74a0f350e7a31fdc8b2c2" translate="yes" xml:space="preserve">
          <source>If this parameter is on, the PostgreSQL server will try to make sure that updates are physically written to disk, by issuing &lt;code&gt;fsync()&lt;/code&gt; system calls or various equivalent methods (see &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt;). This ensures that the database cluster can recover to a consistent state after an operating system or hardware crash.</source>
          <target state="translated">このパラメーターがオンの場合、PostgreSQLサーバーは、&lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;fsync &lt;/a&gt; &lt;code&gt;fsync()&lt;/code&gt; システムコールまたはさまざまな同等のメソッド（wal_sync_methodを参照）を発行することにより、更新が物理的にディスクに書き込まれるようにします。これにより、オペレーティングシステムまたはハードウェアのクラッシュ後に、データベースクラスターを一貫した状態に回復できます。</target>
        </trans-unit>
        <trans-unit id="fdad70218c14320d183b5258a94b057b0b9b82eb" translate="yes" xml:space="preserve">
          <source>If this produces no response then this step was successful and you can skip over the remainder of this section.</source>
          <target state="translated">これで応答がない場合は、このステップは成功したことになり、このセクションの残りの部分はスキップできます。</target>
        </trans-unit>
        <trans-unit id="3214ef4d2c8d678533f9cd4aff300140581f95e6" translate="yes" xml:space="preserve">
          <source>If this table is a partition, one cannot perform &lt;code&gt;DROP NOT NULL&lt;/code&gt; on a column if it is marked &lt;code&gt;NOT NULL&lt;/code&gt; in the parent table. To drop the &lt;code&gt;NOT NULL&lt;/code&gt; constraint from all the partitions, perform &lt;code&gt;DROP NOT NULL&lt;/code&gt; on the parent table. Even if there is no &lt;code&gt;NOT NULL&lt;/code&gt; constraint on the parent, such a constraint can still be added to individual partitions, if desired; that is, the children can disallow nulls even if the parent allows them, but not the other way around.</source>
          <target state="translated">このテーブルがパーティションの場合、親テーブルで &lt;code&gt;NOT NULL&lt;/code&gt; とマークされていると、列で &lt;code&gt;DROP NOT NULL&lt;/code&gt; を実行できません。すべてのパーティションから &lt;code&gt;NOT NULL&lt;/code&gt; 制約を削除するには、親テーブルで &lt;code&gt;DROP NOT NULL&lt;/code&gt; を実行します。親に &lt;code&gt;NOT NULL&lt;/code&gt; 制約がない場合でも、必要に応じて、そのような制約を個々のパーティションに追加できます。つまり、親はnullを許可しても、子はnullを禁止できますが、その逆はできません。</target>
        </trans-unit>
        <trans-unit id="8738e67f4faaa26be7e54ea9f241452e99abdc6a" translate="yes" xml:space="preserve">
          <source>If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.</source>
          <target state="translated">この値を単位なしで指定すると、ミリ秒として扱われます。ゼロ(デフォルト)を指定すると、タイムアウトは無効になります。</target>
        </trans-unit>
        <trans-unit id="f32c0180b724efe2a022fcb4332eb4cf7431bae9" translate="yes" xml:space="preserve">
          <source>If this value is specified without units, it is taken as minutes. A value of &lt;code&gt;-1&lt;/code&gt; (the default) disables this feature, effectively setting the snapshot age limit to infinity. This parameter can only be set at server start.</source>
          <target state="translated">この値を単位なしで指定した場合、分として扱われます。値 &lt;code&gt;-1&lt;/code&gt; （デフォルト）はこの機能を無効にし、スナップショットの経過時間制限を無限に効果的に設定します。このパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="a8ab1040fa10ec473399bfff4fa508c435a17bc0" translate="yes" xml:space="preserve">
          <source>If this variable is set to &lt;code&gt;ignorespace&lt;/code&gt;, lines which begin with a space are not entered into the history list. If set to a value of &lt;code&gt;ignoredups&lt;/code&gt;, lines matching the previous history line are not entered. A value of &lt;code&gt;ignoreboth&lt;/code&gt; combines the two options. If set to &lt;code&gt;none&lt;/code&gt; (the default), all lines read in interactive mode are saved on the history list.</source>
          <target state="translated">この変数が &lt;code&gt;ignorespace&lt;/code&gt; に設定されている場合、スペースで始まる行は履歴リストに入力されません。 &lt;code&gt;ignoredups&lt;/code&gt; 値に設定すると、前の履歴行に一致する行は入力されません。 &lt;code&gt;ignoreboth&lt;/code&gt; の値は、2つのオプションを組み合わせたものです。 &lt;code&gt;none&lt;/code&gt; （デフォルト）に設定すると、インタラクティブモードで読み込まれたすべての行が履歴リストに保存されます。</target>
        </trans-unit>
        <trans-unit id="7d49403e63b47e4513b7ffed0983ad8f1cca01fe" translate="yes" xml:space="preserve">
          <source>If this variable is set to &lt;code&gt;true&lt;/code&gt;, a table's access method details are not displayed. This is mainly useful for regression tests.</source>
          <target state="translated">この変数が &lt;code&gt;true&lt;/code&gt; に設定されている場合、テーブルのアクセス方法の詳細は表示されません。これは主に回帰テストに役立ちます。</target>
        </trans-unit>
        <trans-unit id="a5769546d2d4414640c8fa6c471f59d18a32f49e" translate="yes" xml:space="preserve">
          <source>If this variable is set to an integer value greater than zero, the results of &lt;code&gt;SELECT&lt;/code&gt; queries are fetched and displayed in groups of that many rows, rather than the default behavior of collecting the entire result set before display. Therefore only a limited amount of memory is used, regardless of the size of the result set. Settings of 100 to 1000 are commonly used when enabling this feature. Keep in mind that when using this feature, a query might fail after having already displayed some rows.</source>
          <target state="translated">この変数がゼロより大きい整数値に設定されている場合、 &lt;code&gt;SELECT&lt;/code&gt; クエリの結果はフェッチされ、表示前に結果セット全体を収集するデフォルトの動作ではなく、その数の行のグループで表示されます。したがって、結果セットのサイズに関係なく、限られた量のメモリのみが使用されます。この機能を有効にする場合、100〜1000の設定が一般的に使用されます。この機能を使用する場合、すでにいくつかの行を表示した後でクエリが失敗する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="76778bde620595af53b04af23a5daa5bc5441843" translate="yes" xml:space="preserve">
          <source>If three or more digits and no date fields have yet been found, interpret as a year (this forces yy-mm-dd ordering of the remaining date fields).</source>
          <target state="translated">3桁以上の数字で日付フィールドがまだ見つからない場合は、年と解釈します(これは残りの日付フィールドの順番を強制的にyy-mm-ddにします)。</target>
        </trans-unit>
        <trans-unit id="81e3a3432036cda1be2139bb1761dc976c1a75c5" translate="yes" xml:space="preserve">
          <source>If true this index has been chosen as &amp;ldquo;replica identity&amp;rdquo; using &lt;code&gt;ALTER TABLE ... REPLICA IDENTITY USING INDEX ...&lt;/code&gt;</source>
          <target state="translated">trueの場合、このインデックスは、 &lt;code&gt;ALTER TABLE ... REPLICA IDENTITY USING INDEX ...&lt;/code&gt; を使用して「レプリカID」として選択されています。</target>
        </trans-unit>
        <trans-unit id="fb3a87dcd25f91900b7d1fcaa4ea022c5ef4621a" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;DELETE&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">trueの場合、パブリケーション内のテーブルに対して &lt;code&gt;DELETE&lt;/code&gt; 操作が複製されます。</target>
        </trans-unit>
        <trans-unit id="31ebf4870608c0167855b7d0283c52cc09a7d931" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;INSERT&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">trueの場合、パブリケーション内のテーブルに対して &lt;code&gt;INSERT&lt;/code&gt; 操作が複製されます。</target>
        </trans-unit>
        <trans-unit id="16194e2fdde132d1c172f912b491836e60827cdc" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;TRUNCATE&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">trueの場合、パブリケーション内のテーブルに対して &lt;code&gt;TRUNCATE&lt;/code&gt; 操作が複製されます。</target>
        </trans-unit>
        <trans-unit id="1ad3497d81a37523e3d7068e040be2588a6f2a7f" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;UPDATE&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">trueの場合、パブリケーション内のテーブルに対して &lt;code&gt;UPDATE&lt;/code&gt; 操作が複製されます。</target>
        </trans-unit>
        <trans-unit id="ec6d4eb0a14744c8cf642983fb247ca8af2c665e" translate="yes" xml:space="preserve">
          <source>If true, queries must not use the index until the &lt;code&gt;xmin&lt;/code&gt; of this &lt;code&gt;pg_index&lt;/code&gt; row is below their &lt;code&gt;TransactionXmin&lt;/code&gt; event horizon, because the table may contain broken HOT chains with incompatible rows that they can see</source>
          <target state="translated">trueの場合、この &lt;code&gt;pg_index&lt;/code&gt; 行の &lt;code&gt;xmin&lt;/code&gt; が &lt;code&gt;TransactionXmin&lt;/code&gt; イベント期間より下になるまで、クエリはインデックスを使用してはなりません。これは、テーブルに、互換性のない行を含む壊れたHOTチェーンが含まれる可能性があるためです。</target>
        </trans-unit>
        <trans-unit id="e8ec7f29c2269b6f390b904f6368378dd35f78e8" translate="yes" xml:space="preserve">
          <source>If true, the index is currently ready for inserts. False means the index must be ignored by &lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt; operations.</source>
          <target state="translated">trueの場合、インデックスは現在挿入の準備ができています。Falseは、 &lt;code&gt;INSERT&lt;/code&gt; / &lt;code&gt;UPDATE&lt;/code&gt; 操作でインデックスを無視する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="6c0fcf74070493f9e01640902cbfc0c6b38f7360" translate="yes" xml:space="preserve">
          <source>If true, the index is currently valid for queries. False means the index is possibly incomplete: it must still be modified by &lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt; operations, but it cannot safely be used for queries. If it is unique, the uniqueness property is not guaranteed true either.</source>
          <target state="translated">trueの場合、インデックスは現在クエリに対して有効です。Falseは、インデックスが不完全である可能性があることを意味します &lt;code&gt;INSERT&lt;/code&gt; / &lt;code&gt;UPDATE&lt;/code&gt; 操作で変更する必要がありますが、クエリに安全に使用できません。一意である場合、一意性プロパティも真であるとは保証されません。</target>
        </trans-unit>
        <trans-unit id="ab6de0df41664d3b3675c49edb64211adc3a12b2" translate="yes" xml:space="preserve">
          <source>If true, the stats include inheritance child columns, not just the values in the specified relation</source>
          <target state="translated">true の場合、統計情報には、指定されたリレーションの値だけでなく、継承された子カラムも含まれます。</target>
        </trans-unit>
        <trans-unit id="ee7718b7881ae44cc98ca7be7fa2735272d5a098" translate="yes" xml:space="preserve">
          <source>If true, the subscription is enabled and should be replicating.</source>
          <target state="translated">true の場合、サブスクリプションが有効になっており、レプリケートされている必要があります。</target>
        </trans-unit>
        <trans-unit id="aa9a0941d117d4d0d6546de8ecf8d6c048b76081" translate="yes" xml:space="preserve">
          <source>If true, the table was last clustered on this index</source>
          <target state="translated">true の場合、テーブルがこのインデックスで最後にクラスタ化されたのは</target>
        </trans-unit>
        <trans-unit id="0629da4ff91f39f869bbe66ce6c66a0e0b5d1ffd" translate="yes" xml:space="preserve">
          <source>If true, the uniqueness check is enforced immediately on insertion (irrelevant if &lt;code&gt;indisunique&lt;/code&gt; is not true)</source>
          <target state="translated">trueの場合、挿入時にただちに一意性チェックが実行されます（ &lt;code&gt;indisunique&lt;/code&gt; がtrueでない場合は関係ありません）。</target>
        </trans-unit>
        <trans-unit id="588ebeeb8e4b96440c5bf3cc0c1bd5854026d4e7" translate="yes" xml:space="preserve">
          <source>If true, then this database can be cloned by any user with &lt;code&gt;CREATEDB&lt;/code&gt; privileges; if false (the default), then only superusers or the owner of the database can clone it.</source>
          <target state="translated">trueの場合、このデータベースは &lt;code&gt;CREATEDB&lt;/code&gt; 権限を持つ任意のユーザーが複製できます。false（デフォルト）の場合、スーパーユーザーまたはデータベースの所有者のみがクローンを作成できます。</target>
        </trans-unit>
        <trans-unit id="7d71cd9fec73126b99ae1f7d42db7f62a2b72e24" translate="yes" xml:space="preserve">
          <source>If true, then this database can be cloned by any user with &lt;code&gt;CREATEDB&lt;/code&gt; privileges; if false, then only superusers or the owner of the database can clone it.</source>
          <target state="translated">trueの場合、このデータベースは &lt;code&gt;CREATEDB&lt;/code&gt; 権限を持つ任意のユーザーが複製できます。falseの場合、スーパーユーザーまたはデータベースの所有者のみが複製できます。</target>
        </trans-unit>
        <trans-unit id="1accbb6daee5f69b5c0f42943992a092e4ba1074" translate="yes" xml:space="preserve">
          <source>If true, this index represents the primary key of the table (&lt;code&gt;indisunique&lt;/code&gt; should always be true when this is true)</source>
          <target state="translated">trueの場合、このインデックスはテーブルの主キーを表します（これがtrueの場合、 &lt;code&gt;indisunique&lt;/code&gt; は常にtrueである必要があります）</target>
        </trans-unit>
        <trans-unit id="0f6e2116d6074f49b9f7bdf86e12bdd873ed8149" translate="yes" xml:space="preserve">
          <source>If true, this index supports an exclusion constraint</source>
          <target state="translated">真の場合、このインデックスは除外制約をサポートします。</target>
        </trans-unit>
        <trans-unit id="eb9d897ba2f316e5badcbcf694b6980e5d7c7ad0" translate="yes" xml:space="preserve">
          <source>If true, this is a unique index</source>
          <target state="translated">true の場合、これは一意のインデックスです。</target>
        </trans-unit>
        <trans-unit id="6763aa747866133b7f56f2197fde582b044036d1" translate="yes" xml:space="preserve">
          <source>If true, this publication automatically includes all tables in the database, including any that will be created in the future.</source>
          <target state="translated">true の場合、この出版物には、将来作成されるテーブルも含めて、データベース内のすべてのテーブルが自動的に含まれます。</target>
        </trans-unit>
        <trans-unit id="2b4a0e4917a40fa5601228c6bffce7ba0283b004" translate="yes" xml:space="preserve">
          <source>If true, this row includes inheritance child columns, not just the values in the specified table</source>
          <target state="translated">true の場合、この行には、指定されたテーブルの値だけでなく、継承された子カラムも含まれます。</target>
        </trans-unit>
        <trans-unit id="b5af22ae5132cfdb3c63b86048053d7c0759cd52" translate="yes" xml:space="preserve">
          <source>If two such transactions concurrently try to change the balance of account 12345, we clearly want the second transaction to start with the updated version of the account's row. Because each command is affecting only a predetermined row, letting it see the updated version of the row does not create any troublesome inconsistency.</source>
          <target state="translated">このような2つのトランザクションが同時に12345口座の残高を変更しようとする場合、2番目のトランザクションは明らかにその口座の行の更新されたバージョンから開始したいと思います。それぞれのコマンドはあらかじめ決められた行にのみ影響を与えているので、行の更新されたバージョンを表示させても、面倒な矛盾は生じません。</target>
        </trans-unit>
        <trans-unit id="286da9748bbda59905be5dc346e8fae92aa0edfb" translate="yes" xml:space="preserve">
          <source>If untrusted users have access to a database that has not adopted a &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;secure schema usage pattern&lt;/a&gt;, begin your session by removing publicly-writable schemas from &lt;code&gt;search_path&lt;/code&gt;. One can add &lt;code&gt;options=-csearch_path=&lt;/code&gt; to the connection string or issue &lt;code&gt;SELECT pg_catalog.set_config('search_path', '', false)&lt;/code&gt; before other SQL commands. This consideration is not specific to psql; it applies to every interface for executing arbitrary SQL commands.</source>
          <target state="translated">信頼できないユーザーが、&lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;安全なスキーマ使用パターンを&lt;/a&gt;採用していないデータベースにアクセスできる場合は、 &lt;code&gt;search_path&lt;/code&gt; からパブリックに書き込み可能なスキーマを削除して、セッションを開始します。他のSQLコマンドの前に &lt;code&gt;SELECT pg_catalog.set_config('search_path', '', false)&lt;/code&gt; &lt;code&gt;options=-csearch_path=&lt;/code&gt; を接続文字列に追加するか、SELECT pg_catalog.set_config（ 'search_path'、 ''、false）を発行できます。この考慮事項は、psqlに固有のものではありません。これは、任意のSQLコマンドを実行するためのすべてのインターフェースに適用されます。</target>
        </trans-unit>
        <trans-unit id="768ed7df41fe42c9b25945d5dff896541bf55b4f" translate="yes" xml:space="preserve">
          <source>If untrusted users have access to a database that has not adopted a &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;secure schema usage pattern&lt;/a&gt;, do not run pgbench in that database. pgbench uses unqualified names and does not manipulate the search path.</source>
          <target state="translated">信頼できないユーザーが、&lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;安全なスキーマ使用パターンを&lt;/a&gt;採用していないデータベースにアクセスできる場合は、そのデータベースでpgbenchを実行しないでください。pgbenchは非修飾名を使用し、検索パスを操作しません。</target>
        </trans-unit>
        <trans-unit id="91d0d0478151e73c50542244d9425b00c1130633" translate="yes" xml:space="preserve">
          <source>If using WAL archiving or streaming replication, consider disabling them during the restore. To do that, set &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;wal_level&lt;/code&gt; to &lt;code&gt;minimal&lt;/code&gt;, and &lt;code&gt;max_wal_senders&lt;/code&gt; to zero before loading the dump. Afterwards, set them back to the right values and take a fresh base backup.</source>
          <target state="translated">WALアーカイブまたはストリーミングレプリケーションを使用している場合は、復元中にそれらを無効にすることを検討してください。これを行うには、ダンプをロードする前に、 &lt;code&gt;archive_mode&lt;/code&gt; を &lt;code&gt;off&lt;/code&gt; に、 &lt;code&gt;wal_level&lt;/code&gt; を &lt;code&gt;minimal&lt;/code&gt; に、 &lt;code&gt;max_wal_senders&lt;/code&gt; をゼロに設定します。その後、それらを正しい値に設定し直して、新しいベースバックアップを作成します。</target>
        </trans-unit>
        <trans-unit id="82f833ab3393a0e44827283b4406b6a15d35b9df" translate="yes" xml:space="preserve">
          <source>If using a pre-9.1 old server that is using a non-default Unix-domain socket directory or a default that differs from the default of the new cluster, set &lt;code&gt;PGHOST&lt;/code&gt; to point to the old server's socket location. (This is not relevant on Windows.)</source>
          <target state="translated">デフォルト以外のUnixドメインソケットディレクトリまたは新しいクラスターのデフォルトとは異なるデフォルトを使用している9.1より前の古いサーバーを使用している場合は、古いサーバーのソケットの場所を指すように &lt;code&gt;PGHOST&lt;/code&gt; を設定します。（これはWindowsでは関係ありません。）</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
