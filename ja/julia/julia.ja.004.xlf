<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="81f2145109807b12c478f9428b7d01692494e503" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_cb&lt;/code&gt;: An optional callback used to create the &lt;a href=&quot;#LibGit2.GitRemote&quot;&gt;&lt;code&gt;GitRemote&lt;/code&gt;&lt;/a&gt; before making the clone from it.</source>
          <target state="translated">&lt;code&gt;remote_cb&lt;/code&gt; ：&lt;a href=&quot;#LibGit2.GitRemote&quot;&gt; &lt;code&gt;GitRemote&lt;/code&gt; &lt;/a&gt;からクローンを作成する前にGitRemoteを作成するために使用されるオプションのコールバック。</target>
        </trans-unit>
        <trans-unit id="08210342f9819d0a52928951c3cf701a468f0a0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_cb_payload&lt;/code&gt;: The payload for the remote callback.</source>
          <target state="translated">&lt;code&gt;remote_cb_payload&lt;/code&gt; ：リモートコールバックのペイロード。</target>
        </trans-unit>
        <trans-unit id="0b84ddfb974082fe30d2fdbc1437b3f617f6a788" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remoteref_id&lt;/code&gt; is a low-level API which returns a &lt;code&gt;RRID&lt;/code&gt; object that wraps &lt;code&gt;whence&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; values of a remote reference.</source>
          <target state="translated">&lt;code&gt;remoteref_id&lt;/code&gt; は低レベルAPIであり、リモート参照の &lt;code&gt;whence&lt;/code&gt; 値と &lt;code&gt;id&lt;/code&gt; 値をラップする &lt;code&gt;RRID&lt;/code&gt; オブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="8507e85a94a6cd1cb8268156f73c57a12952c455" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt;: the URL of &lt;code&gt;remote&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt; ： &lt;code&gt;remote&lt;/code&gt; のURL 。</target>
        </trans-unit>
        <trans-unit id="af1618648ef5cfe8bc793d28a4d2646feb098771" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt;: the URL of &lt;code&gt;remote&lt;/code&gt;. If not specified, will be assumed based on the given name of &lt;code&gt;remote&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt; ： &lt;code&gt;remote&lt;/code&gt; のURL 。指定しない場合は、指定された &lt;code&gt;remote&lt;/code&gt; 名に基づいて想定されます。</target>
        </trans-unit>
        <trans-unit id="609e8e82126a8aeb5967ff81fbb3ef2aa24bd998" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rename_threshold&lt;/code&gt;: how similar two files must to consider one a rename of the other. This is an integer that sets the percentage similarity. The default is 50.</source>
          <target state="translated">&lt;code&gt;rename_threshold&lt;/code&gt; ：一方が他方の名前変更であると見なすために、類似した2つのファイルがどの程度必要か。これは、類似性の割合を設定する整数です。デフォルトは50です。</target>
        </trans-unit>
        <trans-unit id="e2a99cf9dace7b445312c1ed6b449e6eaff870cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repository_cb&lt;/code&gt;: An optional callback which will be used to create the &lt;em&gt;new&lt;/em&gt; repository into which the clone is made.</source>
          <target state="translated">&lt;code&gt;repository_cb&lt;/code&gt; ：クローンが作成される&lt;em&gt;新しい&lt;/em&gt;リポジトリを作成するために使用されるオプションのコールバック。</target>
        </trans-unit>
        <trans-unit id="69b143fd85b9454789782c1eb3c8d602eb3b9b29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repository_cb_payload&lt;/code&gt;: The payload for the repository callback.</source>
          <target state="translated">&lt;code&gt;repository_cb_payload&lt;/code&gt; ：リポジトリコールバックのペイロード。</target>
        </trans-unit>
        <trans-unit id="5023aea211818a0760fb42fd29ef6a5a0289aa0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repr&lt;/code&gt; returns the output of &lt;code&gt;show&lt;/code&gt; as a string.</source>
          <target state="translated">&lt;code&gt;repr&lt;/code&gt; は、 &lt;code&gt;show&lt;/code&gt; の出力を文字列として返します。</target>
        </trans-unit>
        <trans-unit id="7ff0db60e6e9b0f8032c3c60e6fb8dfbe0818b4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return x&lt;/code&gt; causes the enclosing function to exit early, passing the given value &lt;code&gt;x&lt;/code&gt; back to its caller. &lt;code&gt;return&lt;/code&gt; by itself with no value is equivalent to &lt;code&gt;return nothing&lt;/code&gt; (see &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;return x&lt;/code&gt; は、囲んでいる関数を早期に終了させ、指定された値 &lt;code&gt;x&lt;/code&gt; を呼び出し元に返します。 &lt;code&gt;return&lt;/code&gt; 値なしでそれ自体では同等です &lt;code&gt;return nothing&lt;/code&gt; （見えない&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="502272392029d8c1210ca8442ce973a51a80b2c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="45cec38c32f578811af123b4529c8927598f6954" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rewrite_notes_ref&lt;/code&gt;: name of the reference to notes to use to rewrite the commit notes as the rebase is finished.</source>
          <target state="translated">&lt;code&gt;rewrite_notes_ref&lt;/code&gt; ：リベースの完了時にコミットノートを書き換えるために使用するノートへの参照の名前。</target>
        </trans-unit>
        <trans-unit id="ee12f97ff2f79dfd78b89cda4ab0e281561a61af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;right_justify&lt;/code&gt; is the integer column which log metadata is right justified at. The default is zero (metadata goes on its own line).</source>
          <target state="translated">&lt;code&gt;right_justify&lt;/code&gt; は、ログメタデータが右揃えされる整数列です。デフォルトはゼロです（メタデータは独自の行に配置されます）。</target>
        </trans-unit>
        <trans-unit id="b331dc2677ed78e2b46e6f7e4f15579bf2430629" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; using this rounding mode is an alias for &lt;a href=&quot;#Base.ceil&quot;&gt;&lt;code&gt;ceil&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; この丸めモードを使用するには、の別名です&lt;a href=&quot;#Base.ceil&quot;&gt; &lt;code&gt;ceil&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b82694560cc17d932ed74b0e5a76969bf6a0851b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; using this rounding mode is an alias for &lt;a href=&quot;#Base.floor&quot;&gt;&lt;code&gt;floor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; この丸めモードを使用するには、の別名である&lt;a href=&quot;#Base.floor&quot;&gt; &lt;code&gt;floor&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6064aeb0303df233165e5be4f2a31b0e19b1991" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; using this rounding mode is an alias for &lt;a href=&quot;#Base.trunc&quot;&gt;&lt;code&gt;trunc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; この丸めモードを使用するには、の別名です&lt;a href=&quot;#Base.trunc&quot;&gt; &lt;code&gt;trunc&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e4f32289fec3fa365e6110d93226bbad2f67917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt; allows the &lt;code&gt;.&lt;/code&gt; modifier to match newlines.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; はを許可し &lt;code&gt;.&lt;/code&gt; 改行と一致する修飾子。</target>
        </trans-unit>
        <trans-unit id="f9a850a68210f1321a24f7f9f7751b659bc2b984" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sB&lt;/code&gt; has been tagged as a matrix that's (real) symmetric, so for later operations we might perform on it, such as eigenfactorization or computing matrix-vector products, efficiencies can be found by only referencing half of it. For example:</source>
          <target state="translated">&lt;code&gt;sB&lt;/code&gt; は（実際の）対称の行列としてタグ付けされているので、固有因子分解や行列-ベクトル積の計算など、後の操作で実行する可能性があるため、その半分を参照するだけで効率を確認できます。例えば：</target>
        </trans-unit>
        <trans-unit id="ccc484e194571496ce1eda5190c7d8120eefadd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scheme::AbstractString=&quot;&quot;&lt;/code&gt;: the URL scheme which identifies the protocol to be used. For HTTP use &quot;http&quot;, SSH use &quot;ssh&quot;, etc. When &lt;code&gt;scheme&lt;/code&gt; is not provided the output format will be &quot;ssh&quot; but using the scp-like syntax.</source>
          <target state="translated">&lt;code&gt;scheme::AbstractString=&quot;&quot;&lt;/code&gt; ：使用するプロトコルを識別するURLスキーム。以下のためのHTTPの使用「のhttp」などのSSHの使用「SSH」、 &lt;code&gt;scheme&lt;/code&gt; 出力形式は、「SSH」が、SCP-ような構文を使用することになります提供されていません。</target>
        </trans-unit>
        <trans-unit id="93b2806e781d6fca17b7143cb112498a0b664a1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scroll::Symbol=:na&lt;/code&gt;: If &lt;code&gt;:wrap&lt;/code&gt; then wrap the cursor around top and bottom, if :&lt;code&gt;nowrap&lt;/code&gt; do not wrap cursor</source>
          <target state="translated">&lt;code&gt;scroll::Symbol=:na&lt;/code&gt; &lt;code&gt;:wrap&lt;/code&gt; 場合、カーソルを上下にラップします &lt;code&gt;nowrap&lt;/code&gt; ：nowrapの場合、カーソルをラップしません。</target>
        </trans-unit>
        <trans-unit id="4b280689ba075d50a8bf44f6918ee06bdd7f1ee9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_head::Bool=true&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt;, after the branch creation finishes the branch head will be set as the HEAD of &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set_head::Bool=true&lt;/code&gt; 次の場合 &lt;code&gt;true&lt;/code&gt; の枝の作成が終了した後、ブランチヘッドはのHEADとして設定されます &lt;code&gt;repo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3cc61ed461b5dbaa13fd1fd838ddca4a2542572c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_zero_subnormals(true)&lt;/code&gt; can speed up some computations on some hardware. However, it can break identities such as &lt;code&gt;(x-y==0) == (x==y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set_zero_subnormals(true)&lt;/code&gt; は、一部のハードウェアで一部の計算を高速化できます。ただし、 &lt;code&gt;(x-y==0) == (x==y)&lt;/code&gt; などのIDが壊れる可能性があります。</target>
        </trans-unit>
        <trans-unit id="2c2e75ceadb77395d5345eca4bc8bc47dec72358" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shaxxx()&lt;/code&gt; takes &lt;code&gt;AbstractString&lt;/code&gt; and array-like objects (&lt;code&gt;NTuple&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt;) with elements of type &lt;code&gt;UInt8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shaxxx()&lt;/code&gt; は、 &lt;code&gt;UInt8&lt;/code&gt; 型の要素を持つ &lt;code&gt;AbstractString&lt;/code&gt; および配列のようなオブジェクト（ &lt;code&gt;NTuple&lt;/code&gt; および &lt;code&gt;Array&lt;/code&gt; ）を受け取ります。</target>
        </trans-unit>
        <trans-unit id="d4ec3df759f8c80bc7761d61c8e5aa7aa26b8f04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;show&lt;/code&gt;: a flag for which files to examine and in which order. The default is &lt;code&gt;Consts.STATUS_SHOW_INDEX_AND_WORKDIR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;show&lt;/code&gt; ：どのファイルをどの順序で調べるかを示すフラグ。デフォルトは &lt;code&gt;Consts.STATUS_SHOW_INDEX_AND_WORKDIR&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a32266a7567a6361fd0030ea46dc886158ce573e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;show_commit_oid_as_fallback&lt;/code&gt;: if no matching reference can be found which describes a commit, show the commit's &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; instead of throwing an error (the default behavior).</source>
          <target state="translated">&lt;code&gt;show_commit_oid_as_fallback&lt;/code&gt; ：コミットを説明する一致する参照が見つからない場合、エラーをスローする代わりにコミットの&lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;を表示します（デフォルトの動作）。</target>
        </trans-unit>
        <trans-unit id="321d9936b85b091cfbe32e4ed333aa1019f70153" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;show_limited&lt;/code&gt; limits the printing of large data structures to something which can fit on the screen by setting the &lt;code&gt;:limit&lt;/code&gt;&lt;code&gt;IOContext&lt;/code&gt; key during formatting.</source>
          <target state="translated">&lt;code&gt;show_limited&lt;/code&gt; は、フォーマット中に &lt;code&gt;:limit&lt;/code&gt; &lt;code&gt;IOContext&lt;/code&gt; キーを設定することにより、大きなデータ構造の出力を画面に収まるものに制限します。</target>
        </trans-unit>
        <trans-unit id="eb77d8781dd9b346f7972d289b6b8d6656b27a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sig::Signature=Signature(repo)&lt;/code&gt;: the tagger's signature.</source>
          <target state="translated">&lt;code&gt;sig::Signature=Signature(repo)&lt;/code&gt; ：タガーの署名。</target>
        </trans-unit>
        <trans-unit id="d753c86afdec45711bc5c02d99a4e474cd4a4e96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;similarity&lt;/code&gt;: Used to indicate if a file has been renamed or copied.</source>
          <target state="translated">&lt;code&gt;similarity&lt;/code&gt; ：ファイルが名前変更またはコピーされたかどうかを示すために使用されます。</target>
        </trans-unit>
        <trans-unit id="ff10e5c77568c1b5f3ae641f11c70c8c65f4ba74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size(A) == size(B) || throw(DimensionMismatch(&quot;Size of A not equal to size of B&quot;))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;size(A) == size(B) || throw(DimensionMismatch(&quot;Size of A not equal to size of B&quot;))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d10f869613b60c50f32f40c9033fbe46c6290e23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt;: the size of the item in bytes.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; ：バイト単位のアイテムのサイズ。</target>
        </trans-unit>
        <trans-unit id="5477a94f16fd95259abdf4ec79e87fa8ddde3d4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizehint&lt;/code&gt;: suggests a capacity of the buffer (&lt;code&gt;data&lt;/code&gt; must implement &lt;code&gt;sizehint!(data, size)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;sizehint&lt;/code&gt; ：バッファの容量を提案します（ &lt;code&gt;data&lt;/code&gt; は &lt;code&gt;sizehint!(data, size)&lt;/code&gt; 実装する必要があります）。</target>
        </trans-unit>
        <trans-unit id="e3b3de6bcf724e5eb7a7cd993fb64be110536dd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sortedby&lt;/code&gt; &amp;ndash; Controls the order in &lt;code&gt;:flat&lt;/code&gt; format. &lt;code&gt;:filefuncline&lt;/code&gt; (default) sorts by the source line, whereas &lt;code&gt;:count&lt;/code&gt; sorts in order of number of collected samples.</source>
          <target state="translated">&lt;code&gt;sortedby&lt;/code&gt; &amp;ndash; &lt;code&gt;:flat&lt;/code&gt; 形式で順序を制御します。 &lt;code&gt;:filefuncline&lt;/code&gt; （デフォルト）はソース行でソートしますが、 &lt;code&gt;:count&lt;/code&gt; は収集したサンプルの数でソートします。</target>
        </trans-unit>
        <trans-unit id="9ab7b3a3ab6403e446642819fa1d378711eeccfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sortslices&lt;/code&gt; extends naturally to higher dimensions. E.g., if &lt;code&gt;A&lt;/code&gt; is a a 2x2x2 array, &lt;code&gt;sortslices(A, dims=3)&lt;/code&gt; will sort slices within the 3rd dimension, passing the 2x2 slices &lt;code&gt;A[:, :, 1]&lt;/code&gt; and &lt;code&gt;A[:, :, 2]&lt;/code&gt; to the comparison function. Note that while there is no default order on higher-dimensional slices, you may use the &lt;code&gt;by&lt;/code&gt; or &lt;code&gt;lt&lt;/code&gt; keyword argument to specify such an order.</source>
          <target state="translated">&lt;code&gt;sortslices&lt;/code&gt; は自然に高次元に拡張されます。たとえば、 &lt;code&gt;A&lt;/code&gt; が2x2x2配列の場合、 &lt;code&gt;sortslices(A, dims=3)&lt;/code&gt; 、dims = 3）は3番目の次元内のスライスをソートし、2x2スライス &lt;code&gt;A[:, :, 1]&lt;/code&gt; および &lt;code&gt;A[:, :, 2]&lt;/code&gt; を比較関数に渡します。高次元のスライスにはデフォルトの順序はありませんが、 &lt;code&gt;by&lt;/code&gt; または &lt;code&gt;lt&lt;/code&gt; キーワード引数を使用してそのような順序を指定できます。</target>
        </trans-unit>
        <trans-unit id="4951048c7ac40b21df3d0f006898cdcb02270fbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spec&lt;/code&gt; is a textual specification: see &lt;a href=&quot;https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions&quot;&gt;the git docs&lt;/a&gt; for a full list.</source>
          <target state="translated">&lt;code&gt;spec&lt;/code&gt; はテキストによる仕様です。完全なリスト&lt;a href=&quot;https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions&quot;&gt;はgit docs&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4f04859a49c065ca19fcdcec7b6d599fc9662e04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sqrt(x)&lt;/code&gt;, &lt;code&gt;&amp;radic;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sqrt(x)&lt;/code&gt; 、 &lt;code&gt;&amp;radic;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1844a8d2cb0ff3056c35be76a61b67e6353a981b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sshflags&lt;/code&gt; &amp;ndash; flags to use in establishing the SSH connection</source>
          <target state="translated">&lt;code&gt;sshflags&lt;/code&gt; &amp;ndash; SSH接続の確立に使用するフラグ</target>
        </trans-unit>
        <trans-unit id="7a4e3e2ec23bd08e30d9fd3aad5785bb62849893" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sshflags&lt;/code&gt;: specifies additional ssh options, e.g. &lt;code&gt;sshflags=`-i /home/foo/bar.pem&lt;/code&gt;`</source>
          <target state="translated">&lt;code&gt;sshflags&lt;/code&gt; ：指定する追加のsshオプション、例えば &lt;code&gt;sshflags=`-i /home/foo/bar.pem&lt;/code&gt; `</target>
        </trans-unit>
        <trans-unit id="482b777392d5aea02672e566aeba40602b1e6b50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stable=true&lt;/code&gt;: enforce Unicode Versioning Stability</source>
          <target state="translated">&lt;code&gt;stable=true&lt;/code&gt; ：Unicodeバージョン管理の安定性を適用します</target>
        </trans-unit>
        <trans-unit id="a1d673d269bddb99403b4804cd814dccb535526a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_worker&lt;/code&gt; is an internal function which is the default entry point for worker processes connecting via TCP/IP. It sets up the process as a Julia cluster worker.</source>
          <target state="translated">&lt;code&gt;start_worker&lt;/code&gt; は、TCP / IPを介して接続するワーカープロセスのデフォルトのエントリポイントである内部関数です。Juliaクラスターワーカーとしてプロセスを設定します。</target>
        </trans-unit>
        <trans-unit id="0d39313a7b53c31deacd642a6f563eef785766ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startswith&lt;/code&gt; does not compile the anchoring into the regular expression, but instead passes the anchoring as &lt;code&gt;match_option&lt;/code&gt; to PCRE. If compile time is amortized, &lt;code&gt;occursin(r&quot;^...&quot;, s)&lt;/code&gt; is faster than &lt;code&gt;startswith(s, r&quot;...&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;startswith&lt;/code&gt; はアンカーを正規表現にコンパイルしませんが、代わりにアンカーを &lt;code&gt;match_option&lt;/code&gt; としてPCRE に渡します。コンパイル時間が償却される場合、 &lt;code&gt;occursin(r&quot;^...&quot;, s)&lt;/code&gt; は、 &lt;code&gt;startswith(s, r&quot;...&quot;)&lt;/code&gt; よりも高速です。</target>
        </trans-unit>
        <trans-unit id="15339811e6d33db9e7897efcdd503d8c3b49eea3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt;: One of &lt;code&gt;Consts.DELTA_STATUS&lt;/code&gt;, indicating whether the file has been added/modified/deleted.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; ： &lt;code&gt;Consts.DELTA_STATUS&lt;/code&gt; の 1つ。ファイルが追加/変更/削除されたかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="593409fff5972acd2d5fc66532b51e6073c0482a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt;: contains the status flags for the file, indicating if it is current, or has been changed in some way in the index or work tree.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; ：ファイルのステータスフラグが含まれ、ファイルが最新であるか、インデックスまたはワークツリーで何らかの方法で変更されているかを示します。</target>
        </trans-unit>
        <trans-unit id="7130447a57fb8968eccd9497b959129d184d5ebe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stop&lt;/code&gt; as a positional argument requires at least Julia 1.1.</source>
          <target state="translated">&lt;code&gt;stop&lt;/code&gt; 位置引数は少なくともJulia 1.1を必要とするため停止します。</target>
        </trans-unit>
        <trans-unit id="d0f59bf23005820bb215225956bc86d1eabe9e2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stop&lt;/code&gt; may be specified as either a positional or keyword argument.</source>
          <target state="translated">&lt;code&gt;stop&lt;/code&gt; は、位置引数またはキーワード引数のいずれかとして指定できます。</target>
        </trans-unit>
        <trans-unit id="e12b59a2409adf775bb3ba9ebdfd0542b9cb0251" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stream&lt;/code&gt; must be a &lt;code&gt;TTY&lt;/code&gt;, a &lt;code&gt;Pipe&lt;/code&gt;, or a socket.</source>
          <target state="translated">&lt;code&gt;stream&lt;/code&gt; は &lt;code&gt;TTY&lt;/code&gt; 、 &lt;code&gt;Pipe&lt;/code&gt; 、またはソケットでなければなりません。</target>
        </trans-unit>
        <trans-unit id="92d2aefd112ecb4c0e212056a16040530a1c9949" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; should usually not be defined directly. Instead, define a method &lt;code&gt;print(io::IO, x::MyType)&lt;/code&gt;. If &lt;code&gt;string(x)&lt;/code&gt; for a certain type needs to be highly efficient, then it may make sense to add a method to &lt;code&gt;string&lt;/code&gt; and define &lt;code&gt;print(io::IO, x::MyType) = print(io, string(x))&lt;/code&gt; to ensure the functions are consistent.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 通常、文字列は直接定義しないでください。代わりに、メソッド &lt;code&gt;print(io::IO, x::MyType)&lt;/code&gt; 定義します。場合 &lt;code&gt;string(x)&lt;/code&gt; 、特定のタイプのニーズのためには非常に効率的であるために、それはにメソッドを追加するために意味をなすことができる &lt;code&gt;string&lt;/code&gt; と定義 &lt;code&gt;print(io::IO, x::MyType) = print(io, string(x))&lt;/code&gt; 機能の一貫性を確保するため。</target>
        </trans-unit>
        <trans-unit id="3a0a1bd4f366a04445c7d0b5b5d4912e1e3e7619" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strings&lt;/code&gt; can be any iterable over elements &lt;code&gt;x&lt;/code&gt; which are convertible to strings via &lt;code&gt;print(io::IOBuffer, x)&lt;/code&gt;. &lt;code&gt;strings&lt;/code&gt; will be printed to &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strings&lt;/code&gt; は、 &lt;code&gt;print(io::IOBuffer, x)&lt;/code&gt; 介して文字列に変換可能な要素 &lt;code&gt;x&lt;/code&gt; を反復可能なものにすることができます。 &lt;code&gt;strings&lt;/code&gt; は &lt;code&gt;io&lt;/code&gt; に出力されます。</target>
        </trans-unit>
        <trans-unit id="03d10d2948fe43796bacbfe30f1e399090a85dee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stripcc=true&lt;/code&gt;: strip control characters; horizontal tabs and form feeds are converted to spaces; newlines are also converted to spaces unless a newline-conversion flag was specified</source>
          <target state="translated">&lt;code&gt;stripcc=true&lt;/code&gt; ：制御文字を削除します。水平タブとフォームフィードはスペースに変換されます。改行変換フラグが指定されていない限り、改行もスペースに変換されます</target>
        </trans-unit>
        <trans-unit id="348e9291c5b543afc5d72a87490213ecd8d4eb07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stripignore=true&lt;/code&gt;: strip Unicode's &quot;default ignorable&quot; characters (e.g. the soft hyphen or the left-to-right marker)</source>
          <target state="translated">&lt;code&gt;stripignore=true&lt;/code&gt; ：Unicodeの「デフォルトの無視可能な」文字を削除します（たとえば、ソフトハイフンまたは左から右へのマーカー）</target>
        </trans-unit>
        <trans-unit id="ea8af5006099bc8365d7c8c2016e824fc2c530ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stripmark=true&lt;/code&gt;: strip diacritical marks (e.g. accents)</source>
          <target state="translated">&lt;code&gt;stripmark=true&lt;/code&gt; ：分音記号（アクセントなど）を削除します</target>
        </trans-unit>
        <trans-unit id="152fe4fc303b0a193c1b742fe9f4ede9b98c674b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct T&lt;/code&gt; (including typedef to a struct)</source>
          <target state="translated">&lt;code&gt;struct T&lt;/code&gt; （構造体へのtypedefを含む）</target>
        </trans-unit>
        <trans-unit id="c56e50a4a868cc2df17e58d4812fe396996de54a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="ba2cc4e0e66a121d0318b71f9b1e31d8945e78e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt;s are immutable by default; an instance of one of these types cannot be modified after construction. Use &lt;a href=&quot;#mutable%20struct&quot;&gt;&lt;code&gt;mutable struct&lt;/code&gt;&lt;/a&gt; instead to declare a type whose instances can be modified.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; sはデフォルトでは不変です。これらのタイプのインスタンスは、作成後に変更できません。代わりに&lt;a href=&quot;#mutable%20struct&quot;&gt; &lt;code&gt;mutable struct&lt;/code&gt; &lt;/a&gt;を使用して、インスタンスを変更できる型を宣言してください。</target>
        </trans-unit>
        <trans-unit id="13e850a37abc68848cc3b254dc2d22440b355863" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;supertype operator&lt;/code&gt; (reverse of subtype operator)</source>
          <target state="translated">&lt;code&gt;supertype operator&lt;/code&gt; （サブタイプ演算子の逆）</target>
        </trans-unit>
        <trans-unit id="cc1fbbda24d7f513ea72de9ed041f7b7a1294c63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;supress_output::Bool=false&lt;/code&gt;: For testing. If true, menu will not be printed to console.</source>
          <target state="translated">&lt;code&gt;supress_output::Bool=false&lt;/code&gt; ：テスト用。trueの場合、メニューはコンソールに出力されません。</target>
        </trans-unit>
        <trans-unit id="865fee67603befce1b0155fd32588cd0eea3727b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svd!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt;, but modifies the arguments &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; in-place, instead of making copies.</source>
          <target state="translated">&lt;code&gt;svd!&lt;/code&gt; は&lt;a href=&quot;#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt;と同じですが、コピーを作成する代わりに、引数 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; を変更します。</target>
        </trans-unit>
        <trans-unit id="23f1a2a22493ae52966dc56d654ec748102e1aa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svd!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy.</source>
          <target state="translated">&lt;code&gt;svd!&lt;/code&gt; は&lt;a href=&quot;#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt;と同じですが、コピーを作成する代わりに入力 &lt;code&gt;A&lt;/code&gt; を上書きすることでスペースを節約します。</target>
        </trans-unit>
        <trans-unit id="26f8b179c1cd1baf106b501d9f23e6788334be4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take!&lt;/code&gt; - take a worker from the available pool (to be used for remote function execution)</source>
          <target state="translated">&lt;code&gt;take!&lt;/code&gt; -利用可能なプールからワーカーを取得します（リモート関数の実行に使用されます）</target>
        </trans-unit>
        <trans-unit id="a385216e2414d1ff7d0e710e07a4b2820a4c3d37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take!&lt;/code&gt; and &lt;code&gt;fetch&lt;/code&gt; (which retrieves but does not remove the value) on a closed channel successfully return any existing values until it is emptied. Continuing the above example:</source>
          <target state="translated">&lt;code&gt;take!&lt;/code&gt; 閉じたチャネルで &lt;code&gt;fetch&lt;/code&gt; （値を取得しますが、削除はしません）は、空になるまで既存の値を正常に返します。上記の例を続けます。</target>
        </trans-unit>
        <trans-unit id="f655219d63910b18e55d1c7b6d809270664f739b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target_directory&lt;/code&gt;: If not empty, checkout to this directory instead of the &lt;code&gt;workdir&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;target_directory&lt;/code&gt; ：空でない場合、 &lt;code&gt;workdir&lt;/code&gt; の代わりにこのディレクトリにチェックアウトします。</target>
        </trans-unit>
        <trans-unit id="73fa24ada0f915b08e5eb705950254ddb5149ac8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target_limit&lt;/code&gt;: the maximum number of files to compare with to look for renames. The default is 200.</source>
          <target state="translated">&lt;code&gt;target_limit&lt;/code&gt; ：名前変更を探すために比較するファイルの最大数。デフォルトは200です。</target>
        </trans-unit>
        <trans-unit id="8aa9f0c43ae05a2ce21f07a765041be8eb22e9f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task_local_storage&lt;/code&gt; manipulates a key-value store specific to the current task.</source>
          <target state="translated">&lt;code&gt;task_local_storage&lt;/code&gt; は、現在のタスクに固有のKey-Valueストアを操作します。</target>
        </trans-unit>
        <trans-unit id="918476307e3ca43e70bc1905ec5bcef98a16e9bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;their_label&lt;/code&gt;: In case of conflicts, the name of &quot;their&quot; side.</source>
          <target state="translated">&lt;code&gt;their_label&lt;/code&gt; ：競合する場合の「自分」の名前。</target>
        </trans-unit>
        <trans-unit id="6030193bdbe78c187e1658db0e709e4fa8490cd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology&lt;/code&gt;: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.</source>
          <target state="translated">&lt;code&gt;topology&lt;/code&gt; ：ワーカーが相互に接続する方法を指定します。接続されていないワーカー間でメッセージを送信すると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="afb214098cd0d7a7d60c3cf6760db696f2f4fcce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology=:all_to_all&lt;/code&gt;: All processes are connected to each other. The default.</source>
          <target state="translated">&lt;code&gt;topology=:all_to_all&lt;/code&gt; ：すべてのプロセスが相互に接続されています。デフォルト。</target>
        </trans-unit>
        <trans-unit id="88dec064b9bfcaf6a26453d2e661939ebc23d230" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology=:custom&lt;/code&gt;: The &lt;code&gt;launch&lt;/code&gt; method of the cluster manager specifies the connection topology via fields &lt;code&gt;ident&lt;/code&gt; and &lt;code&gt;connect_idents&lt;/code&gt; in &lt;code&gt;WorkerConfig&lt;/code&gt;. A worker with a cluster manager identity &lt;code&gt;ident&lt;/code&gt; will connect to all workers specified in &lt;code&gt;connect_idents&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;topology=:custom&lt;/code&gt; ： &lt;code&gt;launch&lt;/code&gt; クラスタマネージャの方法は、フィールドを経由して接続トポロジを指定する &lt;code&gt;ident&lt;/code&gt; と &lt;code&gt;connect_idents&lt;/code&gt; で &lt;code&gt;WorkerConfig&lt;/code&gt; 。クラスターマネージャーIDの &lt;code&gt;ident&lt;/code&gt; を持つワーカーは、 &lt;code&gt;connect_idents&lt;/code&gt; で指定されたすべてのワーカーに接続します。</target>
        </trans-unit>
        <trans-unit id="e2b734d8bcd640fb2c65bc20498e0e55564a7cf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology=:master_worker&lt;/code&gt;: Only the driver process, i.e. &lt;code&gt;pid&lt;/code&gt; 1 connects to the workers. The workers do not connect to each other.</source>
          <target state="translated">&lt;code&gt;topology=:master_worker&lt;/code&gt; ：ドライバープロセス、つまり &lt;code&gt;pid&lt;/code&gt; 1 のみがワーカーに接続します。ワーカーは互いに接続しません。</target>
        </trans-unit>
        <trans-unit id="2d9f7d8f681c6583e7676e7d6edc9308af158917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;track::AbstractString=&quot;&quot;&lt;/code&gt;: the name of the remote branch this new branch should track, if any. If empty (the default), no remote branch will be tracked.</source>
          <target state="translated">&lt;code&gt;track::AbstractString=&quot;&quot;&lt;/code&gt; ：この新しいブランチが追跡する必要があるリモートブランチの名前（ある場合）。空の場合（デフォルト）、リモートブランチは追跡されません。</target>
        </trans-unit>
        <trans-unit id="4e2130c7a7a9a101281bd18d3a385769f9600d03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trans&lt;/code&gt;/&lt;code&gt;tX&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;trans&lt;/code&gt;/&lt;code&gt;tX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14ddcb95a156c7bb55a2265603cd736316fe9393" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tree_id::GitHash = GitHash()&lt;/code&gt; is a git tree to use to create the commit, showing its ancestry and relationship with any other history. &lt;code&gt;tree&lt;/code&gt; must belong to &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tree_id::GitHash = GitHash()&lt;/code&gt; は、コミットの作成に使用するgitツリーであり、その祖先と他の履歴との関係を示します。 &lt;code&gt;tree&lt;/code&gt; は &lt;code&gt;repo&lt;/code&gt; 属している必要があります。</target>
        </trans-unit>
        <trans-unit id="c5eb7dc6b4355a5d1f4c868ec0c32021d4596579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; (1)</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; （1）</target>
        </trans-unit>
        <trans-unit id="0936c575e4a9bce1faa418b1592ef449dfc0490a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trunc(T, x)&lt;/code&gt; converts the result to type &lt;code&gt;T&lt;/code&gt;, throwing an &lt;code&gt;InexactError&lt;/code&gt; if the value is not representable.</source>
          <target state="translated">&lt;code&gt;trunc(T, x)&lt;/code&gt; は結果を &lt;code&gt;T&lt;/code&gt; 型に変換し、値が表現できない場合は &lt;code&gt;InexactError&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="7b21c9a0f1d3cee2b1f4d67453d1344f204a37a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trunc(x)&lt;/code&gt; returns the nearest integral value of the same type as &lt;code&gt;x&lt;/code&gt; whose absolute value is less than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trunc(x)&lt;/code&gt; 同じタイプの最も近い整数値を返し &lt;code&gt;x&lt;/code&gt; 絶対値未満又はに等しい &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbee0eec9b2e55430d527d6582dd8877f12bb7b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;truncate&lt;/code&gt;: truncates the buffer size to zero length.</source>
          <target state="translated">&lt;code&gt;truncate&lt;/code&gt; ：バッファサイズを長さゼロに切り捨てます。</target>
        </trans-unit>
        <trans-unit id="41b6e3b3fb48f326fbad1eec1eadf0a833f25b9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try/catch&lt;/code&gt; statements also allow the &lt;code&gt;Exception&lt;/code&gt; to be saved in a variable. The following contrived example calculates the square root of the second element of &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is indexable, otherwise assumes &lt;code&gt;x&lt;/code&gt; is a real number and returns its square root:</source>
          <target state="translated">&lt;code&gt;try/catch&lt;/code&gt; ステートメントでは、 &lt;code&gt;Exception&lt;/code&gt; を変数に保存することもできます。次の不自然な例は、 &lt;code&gt;x&lt;/code&gt; がインデックス可能な場合、 &lt;code&gt;x&lt;/code&gt; の2番目の要素の平方根を計算します。そうでない場合、 &lt;code&gt;x&lt;/code&gt; は実数であると想定し、その平方根を返します。</target>
        </trans-unit>
        <trans-unit id="c33b1b48f85121178c6189a83f36ae5a4de3a504" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="abd7dd9b12720a69f43edb81b0af4bb55b4e9603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ttl&lt;/code&gt;: Time-to-live of packets sent on the socket (default: &lt;code&gt;nothing&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ttl&lt;/code&gt; ：ソケットで送信されたパケットの存続時間（デフォルト： &lt;code&gt;nothing&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bbe2f11d5812292598ef7400b637ef93f999bc1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tunnel&lt;/code&gt; &amp;ndash; &lt;code&gt;true&lt;/code&gt; (use tunneling), &lt;code&gt;false&lt;/code&gt; (do not use tunneling), or &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; (use default for the manager)</source>
          <target state="translated">&lt;code&gt;tunnel&lt;/code&gt; &amp;ndash; &lt;code&gt;true&lt;/code&gt; （トンネリングを使用）、 &lt;code&gt;false&lt;/code&gt; （トンネリングを使用しない）、または&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;（マネージャーのデフォルトを使用）</target>
        </trans-unit>
        <trans-unit id="402b0271ddb14ba3adb678d7b893e14da34abca5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tunnel&lt;/code&gt;, &lt;code&gt;bind_addr&lt;/code&gt;, &lt;code&gt;sshflags&lt;/code&gt; and &lt;code&gt;max_parallel&lt;/code&gt; are used when a ssh tunnel is required to connect to the workers from the master process.</source>
          <target state="translated">&lt;code&gt;tunnel&lt;/code&gt; 、 &lt;code&gt;bind_addr&lt;/code&gt; 、 &lt;code&gt;sshflags&lt;/code&gt; および &lt;code&gt;max_parallel&lt;/code&gt; は、マスタープロセスからワーカーに接続するためにsshトンネルが必要な場合に使用されます。</target>
        </trans-unit>
        <trans-unit id="3ae98d30d6b9f87be7214d21f7b1f1658026f596" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tunnel&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt; then SSH tunneling will be used to connect to the worker from the master process. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tunnel&lt;/code&gt; ： &lt;code&gt;true&lt;/code&gt; の場合、マスタープロセスからワーカーに接続するためにSSHトンネリングが使用されます。デフォルトは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5fdfbb92ea4996a990fc0aedc71b8b96f842b098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unchecked::String=&quot;[ ]&quot;|&quot;⬚&quot;)&lt;/code&gt;: string to use for unchecked</source>
          <target state="translated">&lt;code&gt;unchecked::String=&quot;[ ]&quot;|&quot;⬚&quot;)&lt;/code&gt; ：未チェックに使用する文字列</target>
        </trans-unit>
        <trans-unit id="ae5641baee7f560f12b53646e74002ae2a7b0bf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;up_arrow::Char='^'|'&amp;uarr;'&lt;/code&gt;: character to use for up arrow</source>
          <target state="translated">&lt;code&gt;up_arrow::Char='^'|'&amp;uarr;'&lt;/code&gt; ：上矢印に使用する文字</target>
        </trans-unit>
        <trans-unit id="1286bd62882b2197d9326752a14abf249e35dcf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;update_fetchhead&lt;/code&gt;: whether to update the &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt;&lt;code&gt;FetchHead&lt;/code&gt;&lt;/a&gt; after the fetch. The default is to perform the update, which is the normal git behavior.</source>
          <target state="translated">&lt;code&gt;update_fetchhead&lt;/code&gt; ：フェッチ後に&lt;a href=&quot;#LibGit2.FetchHead&quot;&gt; &lt;code&gt;FetchHead&lt;/code&gt; &lt;/a&gt;を更新するかどうか。デフォルトでは、通常のgitの動作である更新を実行します。</target>
        </trans-unit>
        <trans-unit id="689158119264263de422838a5b03a631131c1362" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uplo&lt;/code&gt;/&lt;code&gt;ul&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;uplo&lt;/code&gt;/&lt;code&gt;ul&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab24710e9825de064a163f5ce94d79be47ade840" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;url&lt;/code&gt;: The URL of the fetch head.</source>
          <target state="translated">&lt;code&gt;url&lt;/code&gt; ：フェッチヘッドのURL。</target>
        </trans-unit>
        <trans-unit id="f442181197e49f968f2471275a5f012e278f3859" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;url&lt;/code&gt;: the URL of the proxy.</source>
          <target state="translated">&lt;code&gt;url&lt;/code&gt; ：プロキシのURL。</target>
        </trans-unit>
        <trans-unit id="19c4e769ed90cfd681ef1b310a2d6f9ad4296082" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;userdata&lt;/code&gt; is provided for custom cluster managers to store their own worker-specific information.</source>
          <target state="translated">&lt;code&gt;userdata&lt;/code&gt; は、カスタムクラスターマネージャーが独自のワーカー固有の情報を格納するために提供されます。</target>
        </trans-unit>
        <trans-unit id="d3b8331fceffede2316a7974124bb49b8eeb18b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;username::AbstractString=&quot;&quot;&lt;/code&gt;: the username to use in the output if provided.</source>
          <target state="translated">&lt;code&gt;username::AbstractString=&quot;&quot;&lt;/code&gt; ：提供されている場合に出力で使用するユーザー名。</target>
        </trans-unit>
        <trans-unit id="6c27371ad1b21bb51acb86107c58f827061ba3f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using Foo&lt;/code&gt; will load the module or package &lt;code&gt;Foo&lt;/code&gt; and make its &lt;a href=&quot;#export&quot;&gt;&lt;code&gt;export&lt;/code&gt;&lt;/a&gt;ed names available for direct use. Names can also be used via dot syntax (e.g. &lt;code&gt;Foo.foo&lt;/code&gt; to access the name &lt;code&gt;foo&lt;/code&gt;), whether they are &lt;code&gt;export&lt;/code&gt;ed or not. See the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;using Foo&lt;/code&gt; モジュールをロードするか、またはパッケージ化されます &lt;code&gt;Foo&lt;/code&gt; 、その作り&lt;a href=&quot;#export&quot;&gt; &lt;code&gt;export&lt;/code&gt; &lt;/a&gt;直接使用するためのED名が利用できます。名前は、 &lt;code&gt;export&lt;/code&gt; ているかどうかに関係なく、ドット構文を介して使用することもできます（たとえば、名前 &lt;code&gt;foo&lt;/code&gt; にアクセスするための &lt;code&gt;Foo.foo&lt;/code&gt; ）。詳細については、&lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;モジュール&lt;/a&gt;に関するマニュアルのセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="838b54a9eab8767958b3b80fdcf1e81d2fcffe22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="3e6a732011c1dc2660c4dbf3be189b6cbac8e5cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v&lt;/code&gt; now gets converted to the channel's type with &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;put!&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; &lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;put!&lt;/code&gt; としてチャネルのタイプに変換されるようになりました！と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="a66a7e6c62d3aec6a461aa958f979b8da4631830" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;verbose&lt;/code&gt;: print all additional information</source>
          <target state="translated">&lt;code&gt;verbose&lt;/code&gt; ：すべての追加情報を出力します</target>
        </trans-unit>
        <trans-unit id="38771c8d2e3b58102e803157f1021fdc77359ffa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;version&lt;/code&gt;: version of the struct in use, in case this changes later. For now, always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;version&lt;/code&gt; ：後で変更された場合に使用する構造体のバージョン。今のところ、常に &lt;code&gt;1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1609ac09d4613eb0a602a783024f2b37f908873d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vl&lt;/code&gt; is the lower bound of the window of eigenvalues to search for, and &lt;code&gt;vu&lt;/code&gt; is the upper bound.</source>
          <target state="translated">&lt;code&gt;vl&lt;/code&gt; は検索する固有値のウィンドウの下限で、 &lt;code&gt;vu&lt;/code&gt; は上限です。</target>
        </trans-unit>
        <trans-unit id="39634ab88344e26a6c4f7e1a95904a898f43f0de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; and &lt;code&gt;[[noreturn]]&lt;/code&gt; or &lt;code&gt;_Noreturn&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; および &lt;code&gt;[[noreturn]]&lt;/code&gt; または &lt;code&gt;_Noreturn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f798cc6e3986d2379a7244ce2f55decce5179fd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;when&lt;/code&gt;: a &lt;a href=&quot;#LibGit2.TimeStruct&quot;&gt;&lt;code&gt;TimeStruct&lt;/code&gt;&lt;/a&gt; indicating when the commit was authored/committed into the repository.</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; ：コミットがいつリポジトリに作成/コミットされた&lt;a href=&quot;#LibGit2.TimeStruct&quot;&gt; &lt;code&gt;TimeStruct&lt;/code&gt; &lt;/a&gt;示すTimeStruct。</target>
        </trans-unit>
        <trans-unit id="3719daed583548857eb7718a7ea0092ff6bffe3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;whence&lt;/code&gt; - refers to the node the remote reference was created from. Note that this is different from the node where the underlying object referred to actually exists. For example calling &lt;code&gt;RemoteChannel(2)&lt;/code&gt; from the master process would result in a &lt;code&gt;where&lt;/code&gt; value of 2 and a &lt;code&gt;whence&lt;/code&gt; value of 1.</source>
          <target state="translated">&lt;code&gt;whence&lt;/code&gt; -リモート参照の作成元のノードを指します。これは、参照される基になるオブジェクトが実際に存在するノードとは異なることに注意してください。たとえば、マスタープロセスから &lt;code&gt;RemoteChannel(2)&lt;/code&gt; を呼び出すと、 &lt;code&gt;where&lt;/code&gt; 値は2、 &lt;code&gt;whence&lt;/code&gt; 値は1になります。</target>
        </trans-unit>
        <trans-unit id="4feca933c79656bb4a1cc14d4c9d2c920ea65480" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt; - refers to the node where the underlying object/storage referred to by the reference actually exists.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; -参照によって参照される基になるオブジェクト/ストレージが実際に存在するノードを参照します。</target>
        </trans-unit>
        <trans-unit id="be931cf43d24dd627ab40ea349a9901fcb931b4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="551426be1e371b3925c0f4c041a102931aa878ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; loops repeatedly evaluate a conditional expression, and continue evaluating the body of the while loop as long as the expression remains true. If the condition expression is false when the while loop is first reached, the body is never evaluated.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; ループは条件式を繰り返し評価し、式がtrueである限り、whileループの本体の評価を続行します。whileループに最初に到達したときに条件式がfalseの場合、本体は評価されません。</target>
        </trans-unit>
        <trans-unit id="f18b5d8d4e26142e2aee4c1c2ade071ef4896235" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="9e0e55014bc39303400ae1fa6e711c88709191dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windows_hide::Bool&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt; (defaults to &lt;code&gt;false&lt;/code&gt;), then on Windows no new console window is displayed when the &lt;code&gt;Cmd&lt;/code&gt; is executed. This has no effect if a console is already open or on non-Windows systems.</source>
          <target state="translated">&lt;code&gt;windows_hide::Bool&lt;/code&gt; ： &lt;code&gt;true&lt;/code&gt; （デフォルトは &lt;code&gt;false&lt;/code&gt; ）の場合、Windowsでは、 &lt;code&gt;Cmd&lt;/code&gt; の実行時に新しいコンソールウィンドウは表示されません。これは、コンソールがすでに開いている場合、またはWindows以外のシステム上では効果がありません。</target>
        </trans-unit>
        <trans-unit id="dfac6550a56cdb5e20498842d2ca74d4884878f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windows_verbatim::Bool&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt; (defaults to &lt;code&gt;false&lt;/code&gt;), then on Windows the &lt;code&gt;Cmd&lt;/code&gt; will send a command-line string to the process with no quoting or escaping of arguments, even arguments containing spaces. (On Windows, arguments are sent to a program as a single &quot;command-line&quot; string, and programs are responsible for parsing it into arguments. By default, empty arguments and arguments with spaces or tabs are quoted with double quotes &lt;code&gt;&quot;&lt;/code&gt; in the command line, and &lt;code&gt;\&lt;/code&gt; or &lt;code&gt;&quot;&lt;/code&gt; are preceded by backslashes. &lt;code&gt;windows_verbatim=true&lt;/code&gt; is useful for launching programs that parse their command line in nonstandard ways.) Has no effect on non-Windows systems.</source>
          <target state="translated">&lt;code&gt;windows_verbatim::Bool&lt;/code&gt; ： &lt;code&gt;true&lt;/code&gt; （デフォルトは &lt;code&gt;false&lt;/code&gt; ）の場合、Windowsでは &lt;code&gt;Cmd&lt;/code&gt; はコマンドライン文字列をプロセスに送信し、引用符やエスケープなしで、スペースを含む引数も含めます。 （Windowsでは、引数は単一の「コマンドライン」文字列としてプログラムに送信され、プログラムはそれを引数に解析する必要があります。デフォルトでは、空の引数とスペースまたはタブを含む引数は、コマンド内で二重引用符 &lt;code&gt;&quot;&lt;/code&gt; で囲まれます行、および &lt;code&gt;\&lt;/code&gt; または &lt;code&gt;&quot;&lt;/code&gt; の前にはバックスラッシュが付きます &lt;code&gt;windows_verbatim=true&lt;/code&gt; は、非標準的な方法でコマンド行を解析するプログラムを起動するのに役立ちます。）Windows以外のシステムには影響しません。</target>
        </trans-unit>
        <trans-unit id="7b8aee3aafac635044e497c27a0514876ff35397" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;write(io, c)&lt;/code&gt;, in contrast, may emit an encoding depending on &lt;code&gt;typeof(c)&lt;/code&gt;, and &lt;code&gt;read(io, typeof(c))&lt;/code&gt; should read the same encoding as &lt;code&gt;write&lt;/code&gt;. New &lt;code&gt;AbstractChar&lt;/code&gt; types must provide their own implementations of &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;read&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;write(io, c)&lt;/code&gt; 対照的に、write（io、c）は &lt;code&gt;typeof(c)&lt;/code&gt; に応じてエンコーディングを出力し、 &lt;code&gt;read(io, typeof(c))&lt;/code&gt; は &lt;code&gt;write&lt;/code&gt; と同じエンコーディングを読み取る必要があります。新しい &lt;code&gt;AbstractChar&lt;/code&gt; 型は、 &lt;code&gt;write&lt;/code&gt; と &lt;code&gt;read&lt;/code&gt; 独自の実装を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="3fadd3731757e74adbe714a9fc3cde1b0f50d386" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x % T&lt;/code&gt; converts an integer &lt;code&gt;x&lt;/code&gt; to a value of integer type &lt;code&gt;T&lt;/code&gt; congruent to &lt;code&gt;x&lt;/code&gt; modulo &lt;code&gt;2^n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of bits in &lt;code&gt;T&lt;/code&gt;. In other words, the binary representation is truncated to fit.</source>
          <target state="translated">&lt;code&gt;x % T&lt;/code&gt; 、整数 &lt;code&gt;x&lt;/code&gt; を &lt;code&gt;2^n&lt;/code&gt; 法とする &lt;code&gt;x&lt;/code&gt; に一致する整数型 &lt;code&gt;T&lt;/code&gt; の値に変換します。ここで、 &lt;code&gt;n&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; のビット数です。言い換えると、バイナリ表現は、適合するように切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="90c41f1363237dda010ffbdcb1e50483f239fe01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x &amp;sdot; y&lt;/code&gt; (where &lt;code&gt;&amp;sdot;&lt;/code&gt; can be typed by tab-completing &lt;code&gt;\cdot&lt;/code&gt; in the REPL) is a synonym for &lt;code&gt;dot(x, y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x &amp;sdot; y&lt;/code&gt; （ &lt;code&gt;&amp;sdot;&lt;/code&gt; はタブ完了することで入力できる &lt;code&gt;\cdot&lt;/code&gt; REPLでは）の同義語である &lt;code&gt;dot(x, y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a73d00c797f625743ed5be89aa6859e0e140e7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x*2^n&lt;/code&gt; computed efficiently for integer values of &lt;code&gt;n&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x*2^n&lt;/code&gt; 整数値に対して効率的に計算されるx * 2 ^ &lt;code&gt;n&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1940ccb42a82ee4f57a9ef424ce506f2b4432f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a950a8c9e0c5cf38b19bf4e5268bb9ee46dfc69c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are identical</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は同じです</target>
        </trans-unit>
        <trans-unit id="ab3ac69532931e0ece805a61f4c297980ed1e736" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; may also be arrays of numbers, in which case &lt;code&gt;norm&lt;/code&gt; defaults to the usual &lt;code&gt;norm&lt;/code&gt; function in LinearAlgebra, but may be changed by passing a &lt;code&gt;norm::Function&lt;/code&gt; keyword argument. (For numbers, &lt;code&gt;norm&lt;/code&gt; is the same thing as &lt;code&gt;abs&lt;/code&gt;.) When &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are arrays, if &lt;code&gt;norm(x-y)&lt;/code&gt; is not finite (i.e. &lt;code&gt;&amp;plusmn;Inf&lt;/code&gt; or &lt;code&gt;NaN&lt;/code&gt;), the comparison falls back to checking whether all elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are approximately equal component-wise.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は数値の配列でもかまいません。その場合、 &lt;code&gt;norm&lt;/code&gt; はデフォルトでLinearAlgebraの通常の &lt;code&gt;norm&lt;/code&gt; 関数になりますが、 &lt;code&gt;norm::Function&lt;/code&gt; キーワード引数を渡すことで変更できます。 （数値の場合、 &lt;code&gt;norm&lt;/code&gt; は &lt;code&gt;abs&lt;/code&gt; と同じです。） &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; が配列の場合、 &lt;code&gt;norm(x-y)&lt;/code&gt; が有限でない場合（つまり、 &lt;code&gt;&amp;plusmn;Inf&lt;/code&gt; または &lt;code&gt;NaN&lt;/code&gt; ）、比較は、 &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; のすべての要素がコンポーネントごとにほぼ等しい。</target>
        </trans-unit>
        <trans-unit id="a48f8b3cde36a8ddf02a94dfeb998cab82856e48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; enables &quot;comment mode&quot;: whitespace is enabled except when escaped with &lt;code&gt;\&lt;/code&gt;, and &lt;code&gt;#&lt;/code&gt; is treated as starting a comment.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; は「コメントモード」を有効にします。 &lt;code&gt;\&lt;/code&gt; でエスケープした場合を除き、空白が有効になり、 &lt;code&gt;#&lt;/code&gt; はコメントの開始として扱われます。</target>
        </trans-unit>
        <trans-unit id="9b7e404002ef27b1a2197f45feec798673ffc690" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is a finite number</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; は有限数です</target>
        </trans-unit>
        <trans-unit id="c0524cd745ecc91f2a8a799e342f5f682c7f1d35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is infinite</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; は無限大</target>
        </trans-unit>
        <trans-unit id="47fb95081b3ce22a0b461fae81e21bbc77c62b2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is not a number</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; は数値ではありません</target>
        </trans-unit>
        <trans-unit id="64a786472b355da8522bfc59ef4c0762b67c585b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;||&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="54aac4fafe7a37588d94288478848558abaf1196" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~/.julia&lt;/code&gt; where &lt;code&gt;~&lt;/code&gt; is the user home as appropriate on the system;</source>
          <target state="translated">&lt;code&gt;~/.julia&lt;/code&gt; ここで &lt;code&gt;~&lt;/code&gt; は、システム上の適切なユーザーの家です。</target>
        </trans-unit>
        <trans-unit id="2df118c2fbb6c1d7ba0ff4dd87b88d00cf764a55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Before&lt;/em&gt; loading any code, make sure you're running Revise: say &lt;code&gt;using Revise&lt;/code&gt; or follow its documentation on configuring it to run automatically.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;コードをロードする&lt;em&gt;前に&lt;/em&gt;、Reviseを実行していることを確認してください。Revise &lt;code&gt;using Revise&lt;/code&gt; か、ドキュメントに従って自動的に実行するように構成する方法を説明します。</target>
        </trans-unit>
        <trans-unit id="743bea8b6e02264a01bcef3ea67aed3f0cad8650" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Creating&lt;/em&gt; log events is the concern of the module author who needs to decide where events are triggered and which information to include.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;ログイベントの&lt;em&gt;作成&lt;/em&gt;は、イベントがトリガーされる場所と含める情報を決定する必要があるモジュール&lt;em&gt;作成&lt;/em&gt;者の関心事です。</target>
        </trans-unit>
        <trans-unit id="b124a7e86891727331d73882ce0c24f7eaafd8ac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don't copy these examples!&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;これらの例をコピーしないでください！&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="71cf9402e58fc3879fb68f8afe68b31dae06eee0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Processing&lt;/em&gt; of log events &amp;mdash; that is, display, filtering, aggregation and recording &amp;mdash; is the concern of the application author who needs to bring multiple modules together into a cooperating application.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;ログイベントの&lt;em&gt;処理&lt;/em&gt;（つまり、表示、フィルタリング、集約、および記録）は、複数のモジュールを連携するアプリケーションにまとめる必要があるアプリケーション作成者の関心事です。</target>
        </trans-unit>
        <trans-unit id="7685c1fa95d4518c2af3eb032fd247fef3129095" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divide-and-conquer&lt;/em&gt; sort strategy.</source>
          <target state="translated">&lt;em&gt;分割統治&lt;/em&gt;ソート戦略。</target>
        </trans-unit>
        <trans-unit id="955d87cc46ecdddf5939b69f5d5e66211dd43025" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divide-and-conquer&lt;/em&gt;: sort strategy similar to &lt;a href=&quot;#Base.Sort.MergeSort&quot;&gt;&lt;code&gt;MergeSort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;divide-and-conquer&lt;/em&gt;：&lt;a href=&quot;#Base.Sort.MergeSort&quot;&gt; &lt;code&gt;MergeSort&lt;/code&gt; &lt;/a&gt;と同様のソート戦略。</target>
        </trans-unit>
        <trans-unit id="547c0f175b81af7715456826fa2ddb801ca75ea1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;good performance&lt;/em&gt; for large collections.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;大規模なコレクションに&lt;em&gt;適したパフォーマンス&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="76e3721332fa8c80267a6d025e92a7b31c647f77" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;iid&lt;/em&gt;, independently and identically distributed.</source>
          <target state="translated">&lt;em&gt;iid&lt;/em&gt;、独立して同一に分散。</target>
        </trans-unit>
        <trans-unit id="4eecbf6b8e99fcad79c0f04ad8ffa79c56d8a143" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;in-place&lt;/em&gt; in memory.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;メモリ&lt;em&gt;内のインプレース&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="53b7f08036597cd9367e51ae64cec4b72d17fb7f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;not in-place&lt;/em&gt; in memory.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;メモリ&lt;em&gt;内のインプレース&lt;/em&gt;で&lt;em&gt;はありません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="69d8a8fdc356b8320c038747a06bcc5697c84ab8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;not stable&lt;/em&gt;: does not preserve the ordering of elements which compare equal (e.g. &quot;a&quot; and &quot;A&quot; in a sort of letters which ignores case).</source>
          <target state="translated">&lt;em&gt;安定して&lt;/em&gt;いない：等しい要素の順序を保持しません（たとえば、大文字と小文字を無視する一種の文字の &quot;a&quot;と &quot;A&quot;）。</target>
        </trans-unit>
        <trans-unit id="bc0febd17aa71743548f98f48c43c546e1abfb04" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;quadratic performance&lt;/em&gt; in the number of elements to be sorted: it is well-suited to small collections but should not be used for large ones.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;ソートされる要素数の&lt;em&gt;2次パフォーマンス&lt;/em&gt;：小さなコレクションには適していますが、大きなコレクションには使用しないでください。</target>
        </trans-unit>
        <trans-unit id="a1491802554c00bcc7d066e787c837a325301ece" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;stable&lt;/em&gt;: preserves the ordering of elements which compare equal (e.g. &quot;a&quot; and &quot;A&quot; in a sort of letters which ignores case).</source>
          <target state="translated">&lt;em&gt;stable&lt;/em&gt;：等しいものを比較する要素の順序を保持&lt;em&gt;し&lt;/em&gt;ます（たとえば、大文字と小文字を無視する一種の文字の &quot;a&quot;と &quot;A&quot;）。</target>
        </trans-unit>
        <trans-unit id="47450e33687d2bd35b73c1a40f6abb2479676524" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A package directory&lt;/strong&gt; is a directory containing the source trees of a set of packages as subdirectories, and forms an &lt;em&gt;implicit environment&lt;/em&gt;. If &lt;code&gt;X&lt;/code&gt; is a subdirectory of a package directory and &lt;code&gt;X/src/X.jl&lt;/code&gt; exists, then the package &lt;code&gt;X&lt;/code&gt; is available in the package directory environment and &lt;code&gt;X/src/X.jl&lt;/code&gt; is the source file by which it is loaded.</source>
          <target state="translated">&lt;strong&gt;パッケージディレクトリ&lt;/strong&gt;は、一連のパッケージのソースツリーをサブディレクトリとして含むディレクトリであり、&lt;em&gt;暗黙的な環境&lt;/em&gt;を形成し&lt;em&gt;ます&lt;/em&gt;。場合 &lt;code&gt;X&lt;/code&gt; は、パッケージディレクトリのサブディレクトリで、 &lt;code&gt;X/src/X.jl&lt;/code&gt; 存在する場合、パッケージ &lt;code&gt;X&lt;/code&gt; は、パッケージディレクトリ環境で利用可能で、 &lt;code&gt;X/src/X.jl&lt;/code&gt; 、それがロードされることにより、ソースファイルです。</target>
        </trans-unit>
        <trans-unit id="ab6e1278144bfe85f8b9792c5068eed40f8bd5eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A project environment&lt;/strong&gt; is a directory with a project file and an optional manifest file, and forms an &lt;em&gt;explicit environement&lt;/em&gt;. The project file determines what the names and identities of the direct dependencies of a project are. The manifest file, if present, gives a complete dependency graph, including all direct and indirect dependencies, exact versions of each dependency, and sufficient information to locate and load the correct version.</source>
          <target state="translated">&lt;strong&gt;プロジェクト環境&lt;/strong&gt;は、プロジェクトファイルとオプションのマニフェストファイルを含むディレクトリであり、&lt;em&gt;明示的な環境&lt;/em&gt;を形成します。プロジェクトファイルは、プロジェクトの直接的な依存関係の名前とIDを決定します。マニフェストファイルが存在する場合、完全な依存関係グラフが提供されます。これには、すべての直接および間接の依存関係、各依存関係の正確なバージョン、および正しいバージョンを見つけて読み込むための十分な情報が含まれます。</target>
        </trans-unit>
        <trans-unit id="5dcf2f7a4986e6945bd060c2a9f0b685ebc4a479" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Automatic promotion for built-in arithmetic types and operators.&lt;/strong&gt; In most languages, built-in numeric types, when used as operands to arithmetic operators with infix syntax, such as &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;/&lt;/code&gt;, are automatically promoted to a common type to produce the expected results. C, Java, Perl, and Python, to name a few, all correctly compute the sum &lt;code&gt;1 + 1.5&lt;/code&gt; as the floating-point value &lt;code&gt;2.5&lt;/code&gt;, even though one of the operands to &lt;code&gt;+&lt;/code&gt; is an integer. These systems are convenient and designed carefully enough that they are generally all-but-invisible to the programmer: hardly anyone consciously thinks of this promotion taking place when writing such an expression, but compilers and interpreters must perform conversion before addition since integers and floating-point values cannot be added as-is. Complex rules for such automatic conversions are thus inevitably part of specifications and implementations for such languages.</source>
          <target state="translated">&lt;strong&gt;組み込みの算術型と演算子の自動昇格。&lt;/strong&gt;ほとんどの言語では、組み込み数値型は、 &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;/&lt;/code&gt; などのインフィックス構文を持つ算術演算子のオペランドとして使用される場合、期待される結果を生成するために自動的に共通の型に昇格されます。 C、Java、Perl、およびPythonを例にとると、オペランドの1つが &lt;code&gt;+&lt;/code&gt; であっても、合計 &lt;code&gt;1 + 1.5&lt;/code&gt; を浮動小数点値 &lt;code&gt;2.5&lt;/code&gt; として正しく計算します整数です。これらのシステムは便利で注意深く設計されているため、プログラマーにはほとんど見えません。このような式を書くときに、誰もこのプロモーションが行われていることを意識することはほとんどありません。ポイント値をそのまま追加することはできません。したがって、そのような自動変換の複雑なルールは、必然的にそのような言語の仕様と実装の一部になります。</target>
        </trans-unit>
        <trans-unit id="40672dddf16a6430318b3eb0b9096db189222d38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Brief description&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;簡単な説明&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="540bb8e1a8c92de3d9695826131a325154196169" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Broadcasting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Broadcasting&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f7d8aeead87b3699dcf3142b1e6dee864b1f9e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bypassing default machinery&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;デフォルトの機械をバイパスする&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c3f895628a42c1489009a0b0558d48806270adc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code inclusion:&lt;/strong&gt; e.g. &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt;. Inclusion allows you to split a single program across multiple source files. The expression &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; causes the contents of the file &lt;code&gt;source.jl&lt;/code&gt; to be evaluated in the global scope of the module where the &lt;code&gt;include&lt;/code&gt; call occurs. If &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; is called multiple times, &lt;code&gt;source.jl&lt;/code&gt; is evaluated multiple times. The included path, &lt;code&gt;source.jl&lt;/code&gt;, is interpreted relative to the file where the &lt;code&gt;include&lt;/code&gt; call occurs. This makes it simple to relocate a subtree of source files. In the REPL, included paths are interpreted relative to the current working directory, &lt;a href=&quot;../../base/file/index#Base.Filesystem.pwd&quot;&gt;&lt;code&gt;pwd()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;コードの包含：&lt;/strong&gt;例： &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; 。インクルージョンを使用すると、1つのプログラムを複数のソースファイルに分割できます。式 &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; により、ファイル &lt;code&gt;source.jl&lt;/code&gt; の内容が、 &lt;code&gt;include&lt;/code&gt; 呼び出しが発生するモジュールのグローバルスコープで評価されます。場合 &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; 、複数回呼び出され &lt;code&gt;source.jl&lt;/code&gt; 複数回評価されます。インクルードパス &lt;code&gt;source.jl&lt;/code&gt; は、 &lt;code&gt;include&lt;/code&gt; コールが発生するファイルに対して相対的に解釈されます。これにより、ソースファイルのサブツリーを簡単に再配置できます。 REPLでは、インクルードパスは現在の作業ディレクトリを基準にして解釈されます。&lt;a href=&quot;../../base/file/index#Base.Filesystem.pwd&quot;&gt; &lt;code&gt;pwd()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01b2956aa02b611eba1c44ae4666e386f9a69158" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conversion between linear and cartesian indices&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;線形インデックスとデカルトインデックス間の変換&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8981b2e89255132713afc6ec39691c7bdea5024d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cursor movement&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;カーソル移動&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f5b988cb89cb4ede6b56c1271511dfc59d67ac0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default definition&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;デフォルトの定義&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1c863333a531bcda45cde640d9c35956bb33378" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Editing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Editing&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c838c65ad1ba4b74d30de6df9d506f5e2b0ac9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Everything else&lt;/strong&gt;. Any other arguments.</source>
          <target state="translated">&lt;strong&gt;他のすべて&lt;/strong&gt;。その他の引数。</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c3d140c8e464f134cec3b0eebd38bf683f55d62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aec29b6e22750bc511d0ca82430cb4a126753e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="3c9102cd5f3ec81f62379dfb14e7e329a015e35f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extensions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Extensions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a9d05122489d09030ff3668a78437ee26a3f82b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;External links&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;外部リンク&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83e0b267355d0c11ea2a53fe10c727c43451c8c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Floating-point types:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;浮動小数点型：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a16a8e8a484df94b3401f2c14b02422be6ca3e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function argument&lt;/strong&gt;. Putting a function argument first permits the use of &lt;a href=&quot;../../base/base/index#do&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt; blocks for passing multiline anonymous functions.</source>
          <target state="translated">&lt;strong&gt;関数の引数&lt;/strong&gt;。関数の引数を最初に置くと、複数行の無名関数を渡すための&lt;a href=&quot;../../base/base/index#do&quot;&gt; &lt;code&gt;do&lt;/code&gt; &lt;/a&gt;ブロックの使用が許可されます。</target>
        </trans-unit>
        <trans-unit id="1ca787ea86b26829b090b38d91fb7a76042f2799" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Higher dimensional examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;高次元の例&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6a830a0dff55184e4ece6c75f5be5491d3d9702" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Higher dimensions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;高次元&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f0fb2b5df39867dacb9671eb2a360e55518f879f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I/O stream&lt;/strong&gt;. Specifying the &lt;code&gt;IO&lt;/code&gt; object first permits passing the function to functions such as &lt;a href=&quot;../../base/io-network/index#Base.sprint&quot;&gt;&lt;code&gt;sprint&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;sprint(show, x)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;I / Oストリーム&lt;/strong&gt;。特定 &lt;code&gt;IO&lt;/code&gt; などの関数に関数を渡すオブジェクト最初許可&lt;a href=&quot;../../base/io-network/index#Base.sprint&quot;&gt; &lt;code&gt;sprint&lt;/code&gt; &lt;/a&gt;、例えば &lt;code&gt;sprint(show, x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45650bbd2deb4cc345f368e53f1b5e765a99a0a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Implementation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Implementation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e6981e39179d49e3bc1edb6f6043ddc4d3a9c17e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important optional methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;重要なオプションの方法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="feaf5b204440e5d7b91a26fca33465989ee60de5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input being mutated&lt;/strong&gt;. For example, in &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt;&lt;code&gt;fill!(x, v)&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;x&lt;/code&gt; is the object being mutated and it appears before the value to be inserted into &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;変異する入力&lt;/strong&gt;。例えば、中&lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt; &lt;code&gt;fill!(x, v)&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;x&lt;/code&gt; オブジェクトが変異し、その値が挿入される前に、それが表示されている &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35035aa4af72e7ec2407cb311a13aa4b3f4086e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input not being mutated&lt;/strong&gt;. In &lt;code&gt;fill!(x, v)&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; being mutated and it comes after &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;入力は変化していません&lt;/strong&gt;。 &lt;code&gt;fill!(x, v)&lt;/code&gt; 、 &lt;code&gt;v&lt;/code&gt; がされて&lt;em&gt;いない&lt;/em&gt;変異されて、それが後に来る &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96c1aac8a2ffe99a6f68662d283f199e4c7902db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Integer types:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;整数型：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5b0deb4e2e9417b81879cdc846953811ed3197f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key&lt;/strong&gt;. For associative collections, this is the key of the key-value pair(s). For other indexed collections, this is the index.</source>
          <target state="translated">&lt;strong&gt;キー&lt;/strong&gt;。連想コレクションの場合、これはキーと値のペアのキーです。他のインデックス付きコレクションの場合、これはインデックスです。</target>
        </trans-unit>
        <trans-unit id="ff1552788ed9b7867471169f6f6e13e67ae56e49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keyword Arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;キーワード引数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6d1fbca2eaaca33fbedfae851b1718e81cb621c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keyword arguments&lt;/strong&gt;. In Julia keyword arguments have to come last anyway in function definitions; they're listed here for the sake of completeness.</source>
          <target state="translated">&lt;strong&gt;キーワード引数&lt;/strong&gt;。Juliaでは、キーワード引数は関数定義でとにかく最後に来る必要があります。完全を期すために、ここにリストされています。</target>
        </trans-unit>
        <trans-unit id="940941ba13fb5db6a5ccc6b2d81447af0218c6f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keywords&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Keywords&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="739565cef16139694d18e4e833e383d92f6229e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lather. Rinse. Repeat.&lt;/strong&gt; Explore ideas at the &lt;code&gt;julia&lt;/code&gt; command prompt. Save good ideas in &lt;code&gt;tst.jl&lt;/code&gt;. To execute &lt;code&gt;tst.jl&lt;/code&gt; after it has been changed, just &lt;code&gt;include&lt;/code&gt; it again.</source>
          <target state="translated">&lt;strong&gt;泡。リンス。繰り返す。&lt;/strong&gt; &lt;code&gt;julia&lt;/code&gt; コマンドプロンプトでアイデアを探索します。良いアイデアを &lt;code&gt;tst.jl&lt;/code&gt; に保存します。変更後の &lt;code&gt;tst.jl&lt;/code&gt; を実行するに &lt;code&gt;include&lt;/code&gt; 、再度インクルードするだけです。</target>
        </trans-unit>
        <trans-unit id="062ff7c1f91aac8affdefeef654af299368b137e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No automatic promotion.&lt;/strong&gt; This camp includes Ada and ML &amp;ndash; very &quot;strict&quot; statically typed languages. In these languages, every conversion must be explicitly specified by the programmer. Thus, the example expression &lt;code&gt;1 + 1.5&lt;/code&gt; would be a compilation error in both Ada and ML. Instead one must write &lt;code&gt;real(1) + 1.5&lt;/code&gt;, explicitly converting the integer &lt;code&gt;1&lt;/code&gt; to a floating-point value before performing addition. Explicit conversion everywhere is so inconvenient, however, that even Ada has some degree of automatic conversion: integer literals are promoted to the expected integer type automatically, and floating-point literals are similarly promoted to appropriate floating-point types.</source>
          <target state="translated">&lt;strong&gt;自動プロモーションはありません。&lt;/strong&gt;このキャンプには、AdaとML（非常に「厳密な」静的型付け言語）が含まれています。これらの言語では、すべての変換をプログラマーが明示的に指定する必要があります。したがって、例の式 &lt;code&gt;1 + 1.5&lt;/code&gt; は、AdaとMLの両方でコンパイルエラーになります。代わりに、 &lt;code&gt;real(1) + 1.5&lt;/code&gt; 記述して、加算を実行する前に整数 &lt;code&gt;1&lt;/code&gt; を浮動小数点値に明示的に変換する必要があります。あらゆる場所での明示的な変換は非常に不便ですが、Adaでもある程度の自動変換があります。整数リテラルは期待される整数型に自動的に昇格され、浮動小数点リテラルも同様に適切な浮動小数点型に昇格されます。</target>
        </trans-unit>
        <trans-unit id="19f000a09892ceb4a24beccfa194f3fb0e83a418" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non-traditional indices&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;非伝統的な指標&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3411b52319b78e51339257b20de47be2deece6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Due to the specifics of the &lt;code&gt;libgit2&lt;/code&gt; authentication procedure, when authentication fails, this function is called again without any indication whether authentication was successful or not. To avoid an infinite loop from repeatedly using the same faulty credentials, we will keep track of state using the payload.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;： &lt;code&gt;libgit2&lt;/code&gt; 認証手順の詳細により、認証が失敗すると、認証が成功したかどうかを示すことなく、この関数が再度呼び出されます。無限ループが同じ誤った資格情報を繰り返し使用しないようにするために、ペイロードを使用して状態を追跡します。</target>
        </trans-unit>
        <trans-unit id="9305d29fbc35afa9e63a3c399be778dee6ddefff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This section covers embedding Julia code in C on Unix-like operating systems. For doing this on Windows, please see the section following this.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このセクションでは、UnixライクなオペレーティングシステムでのJuliaコードのCへの埋め込みについて説明します。Windowsでこれを行うには、次のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="fbff1879231e49a20a9f4f3abc431b43d8a6387c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Optional methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;オプションの方法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9fb86f3d0dc24e6e4655476741634ef5c5d50df1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Package loading:&lt;/strong&gt; e.g. &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt;. The import mechanism allows you to load a package&amp;mdash;i.e. an independent, reusable collection of Julia code, wrapped in a module&amp;mdash;and makes the resulting module available by the name &lt;code&gt;X&lt;/code&gt; inside of the importing module. If the same &lt;code&gt;X&lt;/code&gt; package is imported multiple times in the same Julia session, it is only loaded the first time&amp;mdash;on subsequent imports, the importing module gets a reference to the same module. Note though, that &lt;code&gt;import X&lt;/code&gt; can load different packages in different contexts: &lt;code&gt;X&lt;/code&gt; can refer to one package named &lt;code&gt;X&lt;/code&gt; in the main project but potentially to different packages also named &lt;code&gt;X&lt;/code&gt; in each dependency. More on this below.</source>
          <target state="translated">&lt;strong&gt;パッケージの読み込み：&lt;/strong&gt;例 &lt;code&gt;import X&lt;/code&gt; または &lt;code&gt;using X&lt;/code&gt; 。インポートメカニズムにより、パッケージ（つまり、モジュールにラップされた、Juliaコードの独立した再利用可能なコレクション）をロードし、結果のモジュールをインポートモジュール内の名前 &lt;code&gt;X&lt;/code&gt; で利用できるようにすることができます。同じ &lt;code&gt;X&lt;/code&gt; パッケージが同じJuliaセッションで複数回インポートされた場合、最初にのみロードされます。後続のインポートでは、インポートモジュールは同じモジュールへの参照を取得します。 、そのかかわらず、注意 &lt;code&gt;import X&lt;/code&gt; 異なるコンテキストで異なるパッケージをロードすることができます： &lt;code&gt;X&lt;/code&gt; は、名前の一つのパッケージを参照することができます &lt;code&gt;X&lt;/code&gt; のメインプロジェクトではなく、潜在的にも名前の異なるパッケージに &lt;code&gt;X&lt;/code&gt; 各依存関係で。これについては、以下で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="fd7c146c235ccd96ea634cfca88f3355f9e6c234" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Program control&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;プログラム制御&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a191672dfe99327da9dff700b45c0a90a2ec39c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Put code under development in a temporary module.&lt;/strong&gt; Create a file, say &lt;code&gt;Tmp.jl&lt;/code&gt;, and include within it</source>
          <target state="translated">&lt;strong&gt;開発中のコードを一時モジュールに入れます。&lt;/strong&gt; &lt;code&gt;Tmp.jl&lt;/code&gt; というファイルを作成し、その中に含めます</target>
        </trans-unit>
        <trans-unit id="4eebb852c621ba2a07cde7c387d74387c1073db2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Put your test code in another file.&lt;/strong&gt; Create another file, say &lt;code&gt;tst.jl&lt;/code&gt;, which looks like</source>
          <target state="translated">&lt;strong&gt;テストコードを別のファイルに配置します。&lt;/strong&gt;次のような別のファイル、たとえば &lt;code&gt;tst.jl&lt;/code&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="261a3928dc6c3e62bad4f4dc9c5ff983868f3948" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See also&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;こちらもご覧ください&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76a6a8a34ed60528197f028d9fedecb6c66b4c1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;System Independent:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;システムに依存しない：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="212d71ac9a214ae43f2cb6533589aa526743d53d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;System-dependent:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;System-dependent:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="62fabcca68af5e84228e26aadaf1eb51caedddfe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The dependency graph&lt;/strong&gt; of a project directory is determined by the presence and contents of project files in the subdirectory of each package. The rules are:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;プロジェクトディレクトリ&lt;strong&gt;の依存関係グラフ&lt;/strong&gt;は、各パッケージのサブディレクトリにあるプロジェクトファイルの存在と内容によって決まります。ルールは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="35fd5fb379b76233f79b688e018757619277e941" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The dependency graph&lt;/strong&gt; of a project environment is determined by the contents of the manifest file, if present. If there is no manifest file, graph is empty. A manifest file contains a stanza for each of a project's direct or indirect dependencies. For each dependency, the file lists the package's UUID and a source tree hash or an explicit path to the source code. Consider the following example manifest file for &lt;code&gt;App&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;プロジェクト環境&lt;strong&gt;の依存関係グラフ&lt;/strong&gt;は、存在する場合、マニフェストファイルの内容によって決定されます。マニフェストファイルがない場合、グラフは空です。マニフェストファイルには、プロジェクトの直接的または間接的な依存関係のそれぞれに対するスタンザが含まれています。依存関係ごとに、ファイルにはパッケージのUUIDとソースツリーハッシュまたはソースコードへの明示的なパスがリストされます。 &lt;code&gt;App&lt;/code&gt; の次のマニフェストファイルの例を考えてみます。</target>
        </trans-unit>
        <trans-unit id="99a933b1a5fc31f0c493bc7563a8e1ef2ab60637" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The key point here is that Julia code is internally represented as a data structure that is accessible from the language itself.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ここでの要点は、Juliaコードは、言語自体からアクセス可能なデータ構造として内部的に表現されていることです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ec20ee36876b86777c4834a05d78e1ed0df59a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The paths map&lt;/strong&gt; in a package directory is simple: it maps subdirectory names to their corresponding entry-point paths. In other words, if the path to our example project directory is &lt;code&gt;/home/me/animals&lt;/code&gt; then the &lt;code&gt;paths&lt;/code&gt; map could be represented by this dictionary:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;パッケージディレクトリ内&lt;strong&gt;のパスマップ&lt;/strong&gt;は単純です。サブディレクトリ名を対応するエントリポイントパスにマップします。つまり、サンプルプロジェクトディレクトリへのパスが &lt;code&gt;/home/me/animals&lt;/code&gt; の場合、 &lt;code&gt;paths&lt;/code&gt; マップは次の辞書で表すことができます。</target>
        </trans-unit>
        <trans-unit id="7176439c445de46708b9fc3e70d97730d2317fd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The paths map&lt;/strong&gt; of a project environment is extracted from the manifest file. The path of a package &lt;code&gt;uuid&lt;/code&gt; named &lt;code&gt;X&lt;/code&gt; is determined by these rules (in order):</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;プロジェクト環境&lt;strong&gt;のパスマップ&lt;/strong&gt;は、マニフェストファイルから抽出されます。 &lt;code&gt;X&lt;/code&gt; という名前のパッケージ &lt;code&gt;uuid&lt;/code&gt; のパスは、次の規則によって（順番に）決定されます。</target>
        </trans-unit>
        <trans-unit id="d3d291e6a57a7e987da705641960c2e565ce87e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The roots map&lt;/strong&gt; is determined by examining the contents of the package directory to generate a list of all packages that exist. Additionally, a UUID will be assigned to each entry as follows: For a given package found inside the folder &lt;code&gt;X&lt;/code&gt;...</source>
          <target state="translated">&lt;strong&gt;ルートマップ&lt;/strong&gt;は、パッケージディレクトリの内容を調べて、存在するすべてのパッケージのリストを生成することによって決定されます。さらに、UUIDは次のように各エントリに割り当てられます。フォルダ &lt;code&gt;X&lt;/code&gt; 内にある特定のパッケージについて...</target>
        </trans-unit>
        <trans-unit id="cd6e60a191a6ba1c08e90279b391c492d145ca70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The roots map&lt;/strong&gt; of the environment is determined by the contents of the project file, specifically, its top-level &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;uuid&lt;/code&gt; entries and its &lt;code&gt;[deps]&lt;/code&gt; section (all optional). Consider the following example project file for the hypothetical application, &lt;code&gt;App&lt;/code&gt;, as described earlier:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;環境&lt;strong&gt;のルートマップ&lt;/strong&gt;は、プロジェクトファイルの内容、特にその最上位の &lt;code&gt;name&lt;/code&gt; と &lt;code&gt;uuid&lt;/code&gt; エントリ、およびその &lt;code&gt;[deps]&lt;/code&gt; セクション（すべてオプション）によって決定されます。前述の架空のアプリケーション &lt;code&gt;App&lt;/code&gt; の次のサンプルプロジェクトファイルを考えてみます。</target>
        </trans-unit>
        <trans-unit id="fda932e2af71b43d983578e7c22d5ddfec83e11d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type&lt;/strong&gt;. Passing a type typically means that the output will have the given type. In &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse(Int, &quot;1&quot;)&lt;/code&gt;&lt;/a&gt;, the type comes before the string to parse. There are many such examples where the type appears first, but it's useful to note that in &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read(io, String)&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;IO&lt;/code&gt; argument appears before the type, which is in keeping with the order outlined here.</source>
          <target state="translated">&lt;strong&gt;と入力し&lt;/strong&gt;ます。タイプを渡すことは、通常、出力が指定されたタイプになることを意味します。では&lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse(Int, &quot;1&quot;)&lt;/code&gt; &lt;/a&gt;の文字列を解析する前に、タイプが付属しています。タイプが最初に現れるそのような例はたくさんありますが、&lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read(io, String)&lt;/code&gt; &lt;/a&gt;では、 &lt;code&gt;IO&lt;/code&gt; 引数がタイプの前に表示されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="93eadc871861400a6078e0c61f3521be0b3a0f8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;. For associative collections, this is the value of the key-value pair(s). In cases like &lt;code&gt;fill!(x, v)&lt;/code&gt;, this is &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;値&lt;/strong&gt;。連想コレクションの場合、これはキーと値のペアの値です。 &lt;code&gt;fill!(x, v)&lt;/code&gt; ような場合、これは &lt;code&gt;v&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e5d0e0a9d5ca3af4a899d7c1e28f16c0a7bba6fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Varargs&lt;/strong&gt;. This refers to arguments that can be listed indefinitely at the end of a function call. For example, in &lt;code&gt;Matrix{T}(undef, dims)&lt;/code&gt;, the dimensions can be given as a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;Matrix{T}(undef, (1,2))&lt;/code&gt;, or as &lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt;&lt;code&gt;Vararg&lt;/code&gt;&lt;/a&gt;s, e.g. &lt;code&gt;Matrix{T}(undef, 1, 2)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Varargs&lt;/strong&gt;。これは、関数呼び出しの最後に無期限にリストできる引数を指します。たとえば、 &lt;code&gt;Matrix{T}(undef, dims)&lt;/code&gt; では、次元は&lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt;（例： &lt;code&gt;Matrix{T}(undef, (1,2))&lt;/code&gt; 、または&lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt; &lt;code&gt;Vararg&lt;/code&gt; &lt;/a&gt; s（例： &lt;code&gt;Matrix{T}(undef, 1, 2)&lt;/code&gt; ）として指定できます。 、1、2）。</target>
        </trans-unit>
        <trans-unit id="545631b4b295bbbbaed02465401d0864d0ba7cd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What code will this generate?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;これによりどのコードが生成されますか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3b9ef5ff046429380c724127c17394868104ef2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What happens next?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;次は何が起こる？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d0ff7b4939bf14804a87f9610d1e80a40b4a40b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[1]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[1]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b12835c0c0b2c5b88b2a8e731d5eb2b1969e8e6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[2]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[2]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a1a83d04dbd981bd8fe4ab619b42f958ca751fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH12]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH12]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b43d748a54903580e1f21b7242d8d7bb7c4a651a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_1]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_1]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a356e5ff840b60f1a7fd81a3055863d97b69c77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_2]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_2]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06b68ee69a50f3609b2ad16980f29687180123ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_3]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_3]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a85a3aeb27ca57bd4a8e009398c96aa33508ed10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_4]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_4]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddd2e496892d30147f2d48e88aa633252774dbf0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_5]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_5]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ddc74cbd626ac29e02b601b534c540a40ab5c0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_6]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_6]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e97166948a5a3dd11986acbec9fbe6e3cecc60a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AHR13]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AHR13]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65bccd8483458eb47f0cf100e59d18c925a72cfd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[B96]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[B96]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c87f94a30b3537fd21ece46a3be3dc64a62b55b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[BH83]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[BH83]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="11b1b49422b93ae8106416d25659e6c4a205faf3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Bischof1987]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Bischof1987]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="27d14e168d4fa4ad2378bdf18be346c186cebb91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Bunch1977]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Bunch1977]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a39f9cf2c50ef187780e440b9a6f2239b055ca1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Clarke61]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Clarke61]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6c9f7af37c9c1abf3d2cee7bcb7b4328414a23f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[H05]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[H05]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="86010be2d69f415c30df7072124ec31548c70f03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[KY88]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[KY88]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="95c6fae5f939df06b7b59cc5c966b9329d025d70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[S84]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[S84]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa6c947d8396f46ae50ccb15050b140acd93e682" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Schreiber1989]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Schreiber1989]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="274fa9920703743f7af11b5a3280a2a8b5492b20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[issue8859]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[issue8859]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="deb59e9858773588134a730e8495054b325e35ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;graph:&lt;/strong&gt;&lt;code&gt;context::UUID&lt;/code&gt; ⟶ &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;uuid::UUID&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;グラフ：&lt;/strong&gt; &lt;code&gt;context::UUID&lt;/code&gt; UUID⟶ &lt;code&gt;name::Symbol&lt;/code&gt; Symbol⟶uuid &lt;code&gt;uuid::UUID&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da29c13a3741ca50b24df3f7e215f047cc6fe3b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;malloc/free&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;malloc/free&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cc5e4770f37b853a29d3b06890d6a4abca810ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;paths:&lt;/strong&gt;&lt;code&gt;uuid::UUID&lt;/code&gt; &amp;times; &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;path::String&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;パス：&lt;/strong&gt; &lt;code&gt;uuid::UUID&lt;/code&gt; &amp;times; &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;path::String&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e060769be59aa948e668dd91db6570aedd04731c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;roots:&lt;/strong&gt;&lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;uuid::UUID&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;roots：&lt;/strong&gt; &lt;code&gt;name::Symbol&lt;/code&gt; Symbol⟶uuid &lt;code&gt;uuid::UUID&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec6dd4d3b2fc9b4797a8648dcfb6a94dffc781ff" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;4.0 &lt;i&gt;i&lt;/i&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;4.0 &lt;i&gt;i&lt;/i&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="4b5fcf2420327f83a4a6033c345a55bd47a95680" translate="yes" xml:space="preserve">
          <source>==()</source>
          <target state="translated">==()</target>
        </trans-unit>
        <trans-unit id="924d44730ffe4a504a8c5b50688254e4e4997e86" translate="yes" xml:space="preserve">
          <source>@__DIR__</source>
          <target state="translated">@__DIR__</target>
        </trans-unit>
        <trans-unit id="bd05d820a39cc57788c144db33dd9e5d64bc802d" translate="yes" xml:space="preserve">
          <source>@__FILE__</source>
          <target state="translated">@__FILE__</target>
        </trans-unit>
        <trans-unit id="0a7e2fb02c2ce1b02c47c60a07b07cab4fff90c0" translate="yes" xml:space="preserve">
          <source>@__LINE__</source>
          <target state="translated">@__LINE__</target>
        </trans-unit>
        <trans-unit id="cc0701eaddfdfad8a65ef41e959c8e4f27062811" translate="yes" xml:space="preserve">
          <source>@__MODULE__</source>
          <target state="translated">@__MODULE__</target>
        </trans-unit>
        <trans-unit id="0662c8864fe3f1ee3b1e0fb430b61c3e64455909" translate="yes" xml:space="preserve">
          <source>@allocated</source>
          <target state="translated">@allocated</target>
        </trans-unit>
        <trans-unit id="521dba9e02174468f68a0b805b470b64bd37b2ab" translate="yes" xml:space="preserve">
          <source>@assert</source>
          <target state="translated">@assert</target>
        </trans-unit>
        <trans-unit id="3b7c965e962f36eb0e6c472eea82392cdc514ade" translate="yes" xml:space="preserve">
          <source>@async</source>
          <target state="translated">@async</target>
        </trans-unit>
        <trans-unit id="e9bfca0d6780244df737a5f488a11f321a4e3e28" translate="yes" xml:space="preserve">
          <source>@b_str</source>
          <target state="translated">@b_str</target>
        </trans-unit>
        <trans-unit id="f0925e6a5b16433b144a470019c1c0dd5de55e2d" translate="yes" xml:space="preserve">
          <source>@boundscheck</source>
          <target state="translated">@boundscheck</target>
        </trans-unit>
        <trans-unit id="4c462c8f8efc0e427cbc1cf6bea236a9cc0c83e0" translate="yes" xml:space="preserve">
          <source>@cfunction</source>
          <target state="translated">@cfunction</target>
        </trans-unit>
        <trans-unit id="4edd1d89ba51e67e5cde36c993ecbd6d4257872d" translate="yes" xml:space="preserve">
          <source>@deprecate</source>
          <target state="translated">@deprecate</target>
        </trans-unit>
        <trans-unit id="c460a7d72a405ba1e96118402a7742091a82dc52" translate="yes" xml:space="preserve">
          <source>@elapsed</source>
          <target state="translated">@elapsed</target>
        </trans-unit>
        <trans-unit id="34bfbc0fb605f42aad89cbd346daff31c66f5b0e" translate="yes" xml:space="preserve">
          <source>@eval</source>
          <target state="translated">@eval</target>
        </trans-unit>
        <trans-unit id="0ce3f8c769d6a2e9b95a931f13c7916418581d1b" translate="yes" xml:space="preserve">
          <source>@generated</source>
          <target state="translated">@generated</target>
        </trans-unit>
        <trans-unit id="d7621df9275358d3c30a2cfd8844f4521261ee73" translate="yes" xml:space="preserve">
          <source>@gensym</source>
          <target state="translated">@gensym</target>
        </trans-unit>
        <trans-unit id="a443a35e19dcd1ec15e45404c7ffcdeb21fd2474" translate="yes" xml:space="preserve">
          <source>@goto</source>
          <target state="translated">@goto</target>
        </trans-unit>
        <trans-unit id="19d47413bcaa88444056e76c473085f6a1b72db9" translate="yes" xml:space="preserve">
          <source>@inbounds</source>
          <target state="translated">@inbounds</target>
        </trans-unit>
        <trans-unit id="b5cf25ca00c54f41be13cd9463b582cceefc51b6" translate="yes" xml:space="preserve">
          <source>@inline</source>
          <target state="translated">@inline</target>
        </trans-unit>
        <trans-unit id="8ca0acccfff73ec5f39bf9a76ceb21c3d72aa439" translate="yes" xml:space="preserve">
          <source>@isdefined</source>
          <target state="translated">@isdefined</target>
        </trans-unit>
        <trans-unit id="03c2e7fdb001cbf566801d52a83375cbdaa52bd5" translate="yes" xml:space="preserve">
          <source>@label</source>
          <target state="translated">@label</target>
        </trans-unit>
        <trans-unit id="4ea1201781ae986fc43d71514b609cb6e748d76c" translate="yes" xml:space="preserve">
          <source>@macroexpand</source>
          <target state="translated">@macroexpand</target>
        </trans-unit>
        <trans-unit id="1fd88e55d30c6edcea950811aea00f2ce4456bac" translate="yes" xml:space="preserve">
          <source>@macroexpand1</source>
          <target state="translated">@macroexpand1</target>
        </trans-unit>
        <trans-unit id="78b6dbe95bbae61a934cb6e904cb50533688efaf" translate="yes" xml:space="preserve">
          <source>@noinline</source>
          <target state="translated">@noinline</target>
        </trans-unit>
        <trans-unit id="a5325bbb0409334c7f59038d601431b5a3a33c33" translate="yes" xml:space="preserve">
          <source>@nospecialize</source>
          <target state="translated">@nospecialize</target>
        </trans-unit>
        <trans-unit id="cacd42ee4286c01451a0c3f4cbfa6028f915c0f9" translate="yes" xml:space="preserve">
          <source>@polly</source>
          <target state="translated">@polly</target>
        </trans-unit>
        <trans-unit id="4806d3609cdd2247d8453f645dee6710dc41ea0f" translate="yes" xml:space="preserve">
          <source>@propagate_inbounds</source>
          <target state="translated">@propagate_inbounds</target>
        </trans-unit>
        <trans-unit id="8d60f37515947a1cb20c28aea812b1fc5a9f5bf0" translate="yes" xml:space="preserve">
          <source>@pure</source>
          <target state="translated">@pure</target>
        </trans-unit>
        <trans-unit id="3a55093c30bbbe794bf8d402406d8fcf7a4d1310" translate="yes" xml:space="preserve">
          <source>@r_str</source>
          <target state="translated">@r_str</target>
        </trans-unit>
        <trans-unit id="5996760e14e5f71bfe6fa0d484bd050be2d81350" translate="yes" xml:space="preserve">
          <source>@raw_str</source>
          <target state="translated">@raw_str</target>
        </trans-unit>
        <trans-unit id="97cb7ca3c593693dc788600f2394549a69a72d68" translate="yes" xml:space="preserve">
          <source>@s_str</source>
          <target state="translated">@s_str</target>
        </trans-unit>
        <trans-unit id="0b2cd610c2ee6714f1bb72ef08e30cbecc00753b" translate="yes" xml:space="preserve">
          <source>@show</source>
          <target state="translated">@show</target>
        </trans-unit>
        <trans-unit id="74ed0e99c473ebedb95b8c861f075073cb57397f" translate="yes" xml:space="preserve">
          <source>@specialize</source>
          <target state="translated">@specialize</target>
        </trans-unit>
        <trans-unit id="151387036f429960867face2abcd91f32770c4e2" translate="yes" xml:space="preserve">
          <source>@static</source>
          <target state="translated">@static</target>
        </trans-unit>
        <trans-unit id="a68f475d88760f9b0feb2de9ebbfc91426a3b8f2" translate="yes" xml:space="preserve">
          <source>@sync</source>
          <target state="translated">@sync</target>
        </trans-unit>
        <trans-unit id="d38a8f83640ce0fff0b022161540cfdf0fb32550" translate="yes" xml:space="preserve">
          <source>@task</source>
          <target state="translated">@task</target>
        </trans-unit>
        <trans-unit id="aa18b4621d361b5a46f6036593dc03baa5cf1328" translate="yes" xml:space="preserve">
          <source>@threadcall</source>
          <target state="translated">@threadcall</target>
        </trans-unit>
        <trans-unit id="692eee2d0727b5f3f157c333231a8f4d656b6df0" translate="yes" xml:space="preserve">
          <source>@threadcall (Experimental)</source>
          <target state="translated">スレッドコール (実験)</target>
        </trans-unit>
        <trans-unit id="cd087251781047bb579dc74d06a058b6ba3920e2" translate="yes" xml:space="preserve">
          <source>@time</source>
          <target state="translated">@time</target>
        </trans-unit>
        <trans-unit id="8568facb0a4570662a512fe404e622e193f338a6" translate="yes" xml:space="preserve">
          <source>@timed</source>
          <target state="translated">@timed</target>
        </trans-unit>
        <trans-unit id="27b687fc74e91aa623c8e1b6ee200080f7df4707" translate="yes" xml:space="preserve">
          <source>@timev</source>
          <target state="translated">@timev</target>
        </trans-unit>
        <trans-unit id="805c0ec7ef38a1e449165679942f376bf2b79ddf" translate="yes" xml:space="preserve">
          <source>@v_str</source>
          <target state="translated">@v_str</target>
        </trans-unit>
        <trans-unit id="30bb2b68176ace645967cfe93607300e8069c9f2" translate="yes" xml:space="preserve">
          <source>@view</source>
          <target state="translated">@view</target>
        </trans-unit>
        <trans-unit id="c0636d48f28866f15bfbc1ee9241d4414596eec3" translate="yes" xml:space="preserve">
          <source>@views</source>
          <target state="translated">@views</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="ae3a173d257f68d7b3200b2390513b03472ff42a" translate="yes" xml:space="preserve">
          <source>A &quot;strided&quot; array is stored in memory with elements laid out in regular offsets such that an instance with a supported &lt;code&gt;isbits&lt;/code&gt; element type can be passed to external C and Fortran functions that expect this memory layout. Strided arrays must define a &lt;a href=&quot;../../base/arrays/index#Base.strides&quot;&gt;&lt;code&gt;strides(A)&lt;/code&gt;&lt;/a&gt; method that returns a tuple of &quot;strides&quot; for each dimension; a provided &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt;&lt;code&gt;stride(A,k)&lt;/code&gt;&lt;/a&gt; method accesses the &lt;code&gt;k&lt;/code&gt;th element within this tuple. Increasing the index of dimension &lt;code&gt;k&lt;/code&gt; by &lt;code&gt;1&lt;/code&gt; should increase the index &lt;code&gt;i&lt;/code&gt; of &lt;code&gt;getindex(A,i)&lt;/code&gt; by &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt;&lt;code&gt;stride(A,k)&lt;/code&gt;&lt;/a&gt;. If a pointer conversion method &lt;a href=&quot;../../base/c/index#Base.unsafe_convert&quot;&gt;&lt;code&gt;Base.unsafe_convert(Ptr{T}, A)&lt;/code&gt;&lt;/a&gt; is provided, the memory layout must correspond in the same way to these strides. &lt;code&gt;DenseArray&lt;/code&gt; is a very specific example of a strided array where the elements are arranged contiguously, thus it provides its subtypes with the appropriate definition of &lt;code&gt;strides&lt;/code&gt;. More concrete examples can be found within the &lt;a href=&quot;../interfaces/index#man-interface-strided-arrays-1&quot;&gt;interface guide for strided arrays&lt;/a&gt;. &lt;a href=&quot;../../base/arrays/index#Base.StridedVector&quot;&gt;&lt;code&gt;StridedVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt;&lt;code&gt;StridedMatrix&lt;/code&gt;&lt;/a&gt; are convenient aliases for many of the builtin array types that are considered strided arrays, allowing them to dispatch to select specialized implementations that call highly tuned and optimized BLAS and LAPACK functions using just the pointer and strides.</source>
          <target state="translated">サポートされている &lt;code&gt;isbits&lt;/code&gt; 要素タイプのインスタンスをこのメモリレイアウトを期待する外部CおよびFortran関数に渡すことができるように、「strided」配列はメモリに格納され、要素は通常のオフセットでレイアウトされます。ストライド配列は、各次元の「ストライド」のタプルを返すstrides &lt;a href=&quot;../../base/arrays/index#Base.strides&quot;&gt; &lt;code&gt;strides(A)&lt;/code&gt; &lt;/a&gt;メソッドを定義する必要があります。提供されている&lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt; &lt;code&gt;stride(A,k)&lt;/code&gt; &lt;/a&gt;メソッドは、このタプル内の &lt;code&gt;k&lt;/code&gt; 番目の要素にアクセスします。次元の指数増加 &lt;code&gt;k&lt;/code&gt; することによって &lt;code&gt;1&lt;/code&gt; は、インデックス増やす必要 &lt;code&gt;i&lt;/code&gt; はの &lt;code&gt;getindex(A,i)&lt;/code&gt; することによって&lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt; &lt;code&gt;stride(A,k)&lt;/code&gt; &lt;/a&gt;。ポインター変換メソッド&lt;a href=&quot;../../base/c/index#Base.unsafe_convert&quot;&gt; &lt;code&gt;Base.unsafe_convert(Ptr{T}, A)&lt;/code&gt; &lt;/a&gt;が提供されている場合、メモリレイアウトはこれらのストライドと同じように対応している必要があります。 &lt;code&gt;DenseArray&lt;/code&gt; は、要素が隣接して配置されるストライド配列の非常に具体的な例です。したがって、サブタイプに適切な &lt;code&gt;strides&lt;/code&gt; 定義を提供します。より具体的な例は&lt;a href=&quot;../interfaces/index#man-interface-strided-arrays-1&quot;&gt;、ストライド配列のインターフェイスガイドにあります&lt;/a&gt;。&lt;a href=&quot;../../base/arrays/index#Base.StridedVector&quot;&gt; &lt;code&gt;StridedVector&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; &lt;/a&gt;は、ストライド配列と見なされる多くの組み込み配列タイプの便利なエイリアスであり、ポインターとストライドだけを使用して高度に調整および最適化されたBLASおよびLAPACK関数を呼び出す特殊な実装を選択してディスパッチできます。</target>
        </trans-unit>
        <trans-unit id="87a6d45076b09098eb9df88807c997bb15e85369" translate="yes" xml:space="preserve">
          <source>A (all)</source>
          <target state="translated">A (すべて)</target>
        </trans-unit>
        <trans-unit id="9e0270f067c0a720b45c4eb9f114b3b4f763ba05" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#LibGit2.GitCommit&quot;&gt;&lt;code&gt;GitCommit&lt;/code&gt;&lt;/a&gt; will be peeled to a &lt;a href=&quot;#LibGit2.GitTree&quot;&gt;&lt;code&gt;GitTree&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">A &lt;a href=&quot;#LibGit2.GitCommit&quot;&gt; &lt;code&gt;GitCommit&lt;/code&gt; は&lt;/a&gt;に剥離されます&lt;a href=&quot;#LibGit2.GitTree&quot;&gt; &lt;code&gt;GitTree&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba75f83e672a51cdb25eeef228f835e8a4e0af8a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt;&lt;code&gt;UniformScaling&lt;/code&gt;&lt;/a&gt; operator represents a scalar times the identity operator, &lt;code&gt;&amp;lambda;*I&lt;/code&gt;. The identity operator &lt;code&gt;I&lt;/code&gt; is defined as a constant and is an instance of &lt;code&gt;UniformScaling&lt;/code&gt;. The size of these operators are generic and match the other matrix in the binary operations &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt;. For &lt;code&gt;A+I&lt;/code&gt; and &lt;code&gt;A-I&lt;/code&gt; this means that &lt;code&gt;A&lt;/code&gt; must be square. Multiplication with the identity operator &lt;code&gt;I&lt;/code&gt; is a noop (except for checking that the scaling factor is one) and therefore almost without overhead.</source>
          <target state="translated">A &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt; &lt;code&gt;UniformScaling&lt;/code&gt; の&lt;/a&gt;オペレータは、アイデンティティ演算子スカラー倍を表し、 &lt;code&gt;&amp;lambda;*I&lt;/code&gt; 。識別演算子 &lt;code&gt;I&lt;/code&gt; は定数として定義され、 &lt;code&gt;UniformScaling&lt;/code&gt; のインスタンスです。これらの演算子のサイズは一般的であり、二項演算&lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; および &lt;code&gt;\&lt;/code&gt; の他の行列と一致します。 &lt;code&gt;A+I&lt;/code&gt; と &lt;code&gt;A-I&lt;/code&gt; この手段は &lt;code&gt;A&lt;/code&gt; は正方でなければなりません。識別演算子 &lt;code&gt;I&lt;/code&gt; との乗算は何もしない（スケーリング係数が1であることを確認する場合を除く）ため、ほとんどオーバーヘッドがありません。</target>
        </trans-unit>
        <trans-unit id="c842dce0eb13d715db2132316b0c05a4d0e9a5e4" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; that sets the value of &lt;code&gt;Distributed.worker_timeout()&lt;/code&gt; (default: &lt;code&gt;60.0&lt;/code&gt;). This function gives the number of seconds a worker process will wait for a master process to establish a connection before dying.</source>
          <target state="translated">&lt;code&gt;Distributed.worker_timeout()&lt;/code&gt; の値を設定する&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;（デフォルト： &lt;code&gt;60.0&lt;/code&gt; ）。この関数は、ワーカープロセスがマスタープロセスが接続を確立するまで待機する秒数を指定します。</target>
        </trans-unit>
        <trans-unit id="f904b64ee325fb09a13719884cf4994b4a67dc0b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is in an open state initially. This means that it can be read from and written to freely via &lt;code&gt;take!&lt;/code&gt; and &lt;code&gt;put!&lt;/code&gt; calls. &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; closes a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;. On a closed &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;put!&lt;/code&gt; will fail. For example:</source>
          <target state="translated">A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;最初に開いた状態になっています。これは、 &lt;code&gt;take!&lt;/code&gt; を介して自由に読み書きできることを意味します！そして、 &lt;code&gt;put!&lt;/code&gt; 呼び出します。&lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; を&lt;/a&gt;閉じます。閉じた&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;に &lt;code&gt;put!&lt;/code&gt; 失敗します。例えば：</target>
        </trans-unit>
        <trans-unit id="8375d9780c1ae8c1682f81b0f7a6ce2515b39852" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is local to a process. Worker 2 cannot directly refer to a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; on worker 3 and vice-versa. A &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;, however, can put and take values across workers.</source>
          <target state="translated">A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;プロセスに対してローカルです。ワーカー2は、ワーカー3の&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;を直接参照することはできません。逆も同様です。A &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; は&lt;/a&gt;、しかし、置くと労働者間の値を取ることができます。</target>
        </trans-unit>
        <trans-unit id="fc8c6fb411b59b42a835d08f8b3cc960e82887e0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; can be thought of as a &lt;em&gt;handle&lt;/em&gt; to a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">A &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; は&lt;/a&gt;と考えることができます&lt;em&gt;ハンドル&lt;/em&gt;に&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17cfa5600f21f142fc6aae797119fcc13529b73c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; iterator of length &lt;code&gt;n&lt;/code&gt; whose elements exponentially increase at a rate in the interval &lt;code&gt;factor&lt;/code&gt; * (1 &amp;plusmn; &lt;code&gt;jitter&lt;/code&gt;). The first element is &lt;code&gt;first_delay&lt;/code&gt; and all elements are clamped to &lt;code&gt;max_delay&lt;/code&gt;.</source>
          <target state="translated">A &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;長さの反復子 &lt;code&gt;n&lt;/code&gt; 個の要素指数関数的間隔での速度で増加 &lt;code&gt;factor&lt;/code&gt; *（1つの&amp;plusmn; &lt;code&gt;jitter&lt;/code&gt; ）。最初の要素は &lt;code&gt;first_delay&lt;/code&gt; で、すべての要素は &lt;code&gt;max_delay&lt;/code&gt; に固定されています。</target>
        </trans-unit>
        <trans-unit id="7c79d61fbf339539f4166e2a7bfbe466aba53081" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;(:function, &quot;library&quot;)&lt;/code&gt; pair, which must be written as a literal constant,</source>
          <target state="translated">A &lt;code&gt;(:function, &quot;library&quot;)&lt;/code&gt; リテラル定数として書かれなければならない対、</target>
        </trans-unit>
        <trans-unit id="524fcaed9fa041013c206a6350ca0d844bfa68a7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;(name, library)&lt;/code&gt; function specification must be a constant expression. However, it is possible to use computed values as function names by staging through &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; as follows:</source>
          <target state="translated">&lt;code&gt;(name, library)&lt;/code&gt; 機能仕様は、定数式でなければなりません。ただし、次のように&lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;をステージングすることにより、計算された値を関数名として使用できます。</target>
        </trans-unit>
        <trans-unit id="d15e6f0f33d377d6237a8e9e56d281edb772d043" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;:&lt;/code&gt; character on either end of a column's header separator (the row containing &lt;code&gt;-&lt;/code&gt; characters) specifies whether the row is left-aligned, right-aligned, or (when &lt;code&gt;:&lt;/code&gt; appears on both ends) center-aligned. Providing no &lt;code&gt;:&lt;/code&gt; characters will default to right-aligning the column.</source>
          <target state="translated">&lt;code&gt;:&lt;/code&gt; 列のヘッダセパレータの両端に文字（含む行 &lt;code&gt;-&lt;/code&gt; 文字）行を右寄せ、または、左揃えにするかどうかを指定（場合 &lt;code&gt;:&lt;/code&gt; 両端に表示される）中央揃え。 &lt;code&gt;:&lt;/code&gt; を指定しないと、デフォルトで列が右揃えになります。</target>
        </trans-unit>
        <trans-unit id="d46ad2498166339bc8bbf3585924bc43d1e8d5c2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BufferStream&lt;/code&gt; is an in-memory &lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; which behaves like an &lt;code&gt;IO&lt;/code&gt;&amp;ndash;it is a stream which can be handled asynchronously.</source>
          <target state="translated">A &lt;code&gt;BufferStream&lt;/code&gt; はメモリ内で&lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt;のように動作 &lt;code&gt;IO&lt;/code&gt; -itは非同期に処理することができるストリームです。</target>
        </trans-unit>
        <trans-unit id="d1f408408afbccca18234c62817be522377e93f0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CartesianIndex&lt;/code&gt; is sometimes produced by &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt;, and always when iterating with an explicit &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">A &lt;code&gt;CartesianIndex&lt;/code&gt; は時々によって生成される&lt;a href=&quot;#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt;、常に明示的で反復する場合&lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d375921fbca2bf53253dd9c9c9cb98fe33f687c8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Channel&lt;/code&gt; can be used as an iterable object in a &lt;code&gt;for&lt;/code&gt; loop, in which case the loop runs as long as the &lt;code&gt;Channel&lt;/code&gt; has data or is open. The loop variable takes on all values added to the &lt;code&gt;Channel&lt;/code&gt;. The &lt;code&gt;for&lt;/code&gt; loop is terminated once the &lt;code&gt;Channel&lt;/code&gt; is closed and emptied.</source>
          <target state="translated">A &lt;code&gt;Channel&lt;/code&gt; で反復可能オブジェクトとして使用することができる &lt;code&gt;for&lt;/code&gt; 、ループが長いほど走行する場合には、ループ、 &lt;code&gt;Channel&lt;/code&gt; データを有しているか、開いています。ループ変数は、 &lt;code&gt;Channel&lt;/code&gt; に追加されたすべての値を取ります。 &lt;code&gt;for&lt;/code&gt; いったんループが終了される &lt;code&gt;Channel&lt;/code&gt; 閉じられ、空にされます。</target>
        </trans-unit>
        <trans-unit id="1464a151c99f208872dfcf6ce120c5e13267f23e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Char&lt;/code&gt; value represents a single character: it is just a 32-bit primitive type with a special literal representation and appropriate arithmetic behaviors, and which can be converted to a numeric value representing a &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_point&quot;&gt;Unicode code point&lt;/a&gt;. (Julia packages may define other subtypes of &lt;code&gt;AbstractChar&lt;/code&gt;, e.g. to optimize operations for other &lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding&quot;&gt;text encodings&lt;/a&gt;.) Here is how &lt;code&gt;Char&lt;/code&gt; values are input and shown:</source>
          <target state="translated">A &lt;code&gt;Char&lt;/code&gt; それは特別なリテラル表現と適当な演算動作をするだけの32ビットプリミティブ型であり、そしてそれは表す数値に変換することができる：値は、単一の文字を表す&lt;a href=&quot;https://en.wikipedia.org/wiki/Code_point&quot;&gt;Unicodeコードポイント&lt;/a&gt;。 （Juliaパッケージは、 &lt;code&gt;AbstractChar&lt;/code&gt; の他のサブタイプを定義する場合があります。たとえば、他の&lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding&quot;&gt;テキストエンコーディングの&lt;/a&gt;操作を最適化するためです。） &lt;code&gt;Char&lt;/code&gt; 値の入力方法と表示方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="29831ac830f246eb0b5dcfbe779b29bb30cb2979" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CompoundPeriod&lt;/code&gt; is useful for expressing time periods that are not a fixed multiple of smaller periods. For example, &quot;a year and a day&quot; is not a fixed number of days, but can be expressed using a &lt;code&gt;CompoundPeriod&lt;/code&gt;. In fact, a &lt;code&gt;CompoundPeriod&lt;/code&gt; is automatically generated by addition of different period types, e.g. &lt;code&gt;Year(1) + Day(1)&lt;/code&gt; produces a &lt;code&gt;CompoundPeriod&lt;/code&gt; result.</source>
          <target state="translated">A &lt;code&gt;CompoundPeriod&lt;/code&gt; は小さい周期の固定倍数でない時間帯を発現するために有用です。たとえば、「年と日」は一定の日数ではありませんが、 &lt;code&gt;CompoundPeriod&lt;/code&gt; を使用して表現できます。実際、 &lt;code&gt;CompoundPeriod&lt;/code&gt; は、異なる期間タイプを追加することで自動的に生成されます。たとえば、 &lt;code&gt;Year(1) + Day(1)&lt;/code&gt; は、 &lt;code&gt;CompoundPeriod&lt;/code&gt; の結果を生成します。</target>
        </trans-unit>
        <trans-unit id="013639aa4c9e00f4e19703e4c05f20b5824ce3b4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DataType&lt;/code&gt; may be abstract or concrete. If it is concrete, it has a specified size, storage layout, and (optionally) field names. Thus a primitive type is a &lt;code&gt;DataType&lt;/code&gt; with nonzero size, but no field names. A composite type is a &lt;code&gt;DataType&lt;/code&gt; that has field names or is empty (zero size).</source>
          <target state="translated">A &lt;code&gt;DataType&lt;/code&gt; 、抽象やコンクリートかもしれません。具体的な場合、サイズ、ストレージレイアウト、および（オプションで）フィールド名が指定されます。したがって、プリミティブ型はサイズがゼロではない &lt;code&gt;DataType&lt;/code&gt; ですが、フィールド名はありません。複合型は、フィールド名があるか、空（サイズがゼロ）の &lt;code&gt;DataType&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c0a8047ce7922366b0e1686ff32c1d95d34209f7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitCommit&lt;/code&gt; will be peeled to a &lt;code&gt;GitTree&lt;/code&gt;.</source>
          <target state="translated">A &lt;code&gt;GitCommit&lt;/code&gt; はに剥離されます &lt;code&gt;GitTree&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d18c2ea92257c3ec465776fe14e9a5ed1ec94622" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitRevWalker&lt;/code&gt;&lt;em&gt;walks&lt;/em&gt; through the &lt;em&gt;revisions&lt;/em&gt; (i.e. commits) of a git repository &lt;code&gt;repo&lt;/code&gt;. It is a collection of the commits in the repository, and supports iteration and calls to &lt;a href=&quot;#LibGit2.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LibGit2.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; (for instance, &lt;code&gt;count&lt;/code&gt; could be used to determine what percentage of commits in a repository were made by a certain author).</source>
          <target state="translated">A &lt;code&gt;GitRevWalker&lt;/code&gt; は&lt;em&gt;歩い&lt;/em&gt;て&lt;em&gt;リビジョン&lt;/em&gt;のgitリポジトリの（すなわちコミット） &lt;code&gt;repo&lt;/code&gt; 。これはリポジトリ内のコミットのコレクションであり、反復と&lt;a href=&quot;#LibGit2.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#LibGit2.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;呼び出しをサポートします（たとえば、特定の作成者がリポジトリ内のコミットの割合を決定するために &lt;code&gt;count&lt;/code&gt; を使用できます）。</target>
        </trans-unit>
        <trans-unit id="7218806e6e918d7a7efe224d0bbd25603b822749" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitTag&lt;/code&gt; will be peeled to the object it references.</source>
          <target state="translated">A &lt;code&gt;GitTag&lt;/code&gt; は、それが参照するオブジェクトに剥離されます。</target>
        </trans-unit>
        <trans-unit id="56db16f375b3ec2b4282d7f16a671aeb187ec450" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MIME&lt;/code&gt; object can be passed as the second argument to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt; to request output in that format.</source>
          <target state="translated">&lt;code&gt;MIME&lt;/code&gt; のオブジェクトは、第2の引数として渡すことができる&lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt;、そのフォーマットで要求出力します。</target>
        </trans-unit>
        <trans-unit id="64ab14f4b27b0ebae05bdd35cfc7b0f0829b66e2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MersenneTwister&lt;/code&gt; or &lt;code&gt;RandomDevice&lt;/code&gt; RNG can generate uniformly random numbers of the following types: &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int16&quot;&gt;&lt;code&gt;Int16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt32&quot;&gt;&lt;code&gt;UInt32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt64&quot;&gt;&lt;code&gt;UInt64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt;&lt;code&gt;Int128&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt128&quot;&gt;&lt;code&gt;UInt128&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; (or complex numbers of those types). Random floating point numbers are generated uniformly in $[0, 1)$. As &lt;code&gt;BigInt&lt;/code&gt; represents unbounded integers, the interval must be specified (e.g. &lt;code&gt;rand(big.(1:6))&lt;/code&gt;).</source>
          <target state="translated">A &lt;code&gt;MersenneTwister&lt;/code&gt; 又は &lt;code&gt;RandomDevice&lt;/code&gt; ：RNGは、以下のタイプの一様乱数を生成することができる&lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Core.Int16&quot;&gt; &lt;code&gt;Int16&lt;/code&gt; 型&lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt; &lt;code&gt;UInt16&lt;/code&gt; 型&lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Core.UInt32&quot;&gt; &lt;code&gt;UInt32&lt;/code&gt; 型&lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; 型&lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Core.UInt64&quot;&gt; &lt;code&gt;UInt64&lt;/code&gt; 型&lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt; &lt;code&gt;Int128&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Core.UInt128&quot;&gt; &lt;code&gt;UInt128&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;（または複素数それらのタイプの）。ランダムな浮動小数点数は$ [0、1）$に均一に生成されます。 &lt;code&gt;BigInt&lt;/code&gt; として無制限の整数を表す場合、間隔を指定する必要があります（例： &lt;code&gt;rand(big.(1:6))&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fcc156039502be223f5f3af68d44a563690ef471" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Module&lt;/code&gt; is a separate global variable workspace. See &lt;a href=&quot;#module&quot;&gt;&lt;code&gt;module&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">A &lt;code&gt;Module&lt;/code&gt; 別々のグローバル変数のワークスペースです。詳細については、&lt;a href=&quot;#module&quot;&gt; &lt;code&gt;module&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;モジュール&lt;/a&gt;に関するマニュアルのセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="fe27036120fb22dce22db3d877ea4b7e275e7b94" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NamedTuple&lt;/code&gt; type can be used as a constructor, accepting a single tuple argument. The constructed &lt;code&gt;NamedTuple&lt;/code&gt; type can be either a concrete type, with both parameters specified, or a type that specifies only field names:</source>
          <target state="translated">&lt;code&gt;NamedTuple&lt;/code&gt; のタイプは、単一のタプル引数を受け入れ、コンストラクタとして使用することができます。構築される &lt;code&gt;NamedTuple&lt;/code&gt; 型は、両方のパラメーターが指定された具象型、またはフィールド名のみを指定する型のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="ea99f7079d8791c0343a7307d5e653f1f644267c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Polar&lt;/code&gt; object will then display automatically using HTML in an environment that supports HTML display, but you can call &lt;code&gt;show&lt;/code&gt; manually to get HTML output if you want:</source>
          <target state="translated">A &lt;code&gt;Polar&lt;/code&gt; オブジェクトは、サポートのHTML表示その環境でHTMLを使用して自動的に表示されますが、あなたは呼び出すことができます &lt;code&gt;show&lt;/code&gt; したい場合は、GET HTML出力に手動：</target>
        </trans-unit>
        <trans-unit id="c3372e99dcae94f7a8aba1e912fc8ad984983e16" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;VersionNumber&lt;/code&gt; object describing which version of Julia is in use. For details see &lt;a href=&quot;../../manual/strings/index#man-version-number-literals-1&quot;&gt;Version Number Literals&lt;/a&gt;.</source>
          <target state="translated">Julia &lt;code&gt;VersionNumber&lt;/code&gt; バージョンが使用されているかを説明するVersionNumberオブジェクト。詳細については、&lt;a href=&quot;../../manual/strings/index#man-version-number-literals-1&quot;&gt;バージョン番号リテラルを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ac1b0b9643100f5709d747b0fa1193640db35af9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;do&lt;/code&gt; block, like any other inner function, can &quot;capture&quot; variables from its enclosing scope. For example, the variable &lt;code&gt;data&lt;/code&gt; in the above example of &lt;code&gt;open...do&lt;/code&gt; is captured from the outer scope. Captured variables can create performance challenges as discussed in &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;performance tips&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; その外側のスコープからのブロック、他の内部関数と同様に、できる「キャプチャ」変数。たとえば、上の &lt;code&gt;open...do&lt;/code&gt; 例の変数 &lt;code&gt;data&lt;/code&gt; は、外側のスコープから取得されます。キャプチャされた変数は、&lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;パフォーマンスのヒントで&lt;/a&gt;説明されているように、パフォーマンスの問題を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="13afa4d8f5eaeee48f3a15d19e444c7dc58d320a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop or comprehension iteration variable is always a new variable:</source>
          <target state="translated">A &lt;code&gt;for&lt;/code&gt; ループまたは理解反復変数は、常に新しい変数です。</target>
        </trans-unit>
        <trans-unit id="1cc87568b64210c7c32ecbee8a0599fd750c9777" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;group&lt;/code&gt; for the event, which is set to the base name of the file by default, without extension. This can be used to group messages into categories more finely than the log level (for example, all deprecation warnings have group &lt;code&gt;:depwarn&lt;/code&gt;), or into logical groupings across or within modules.</source>
          <target state="translated">イベントの &lt;code&gt;group&lt;/code&gt; 。拡張子なしで、デフォルトでファイルのベース名に設定されます。これを使用して、ログレベルよりも細かくメッセージをカテゴリにグループ化したり（たとえば、すべての非推奨警告にgroup &lt;code&gt;:depwarn&lt;/code&gt; がある）、モジュール全体またはモジュール内の論理グループにグループ化したりできます。</target>
        </trans-unit>
        <trans-unit id="236e91049303fa66d220cd5b5421a9050d83f949" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; statement allows intercepting errors (exceptions) thrown by &lt;a href=&quot;#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; so that program execution can continue. For example, the following code attempts to write a file, but warns the user and proceeds instead of terminating execution if the file cannot be written:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; ステートメントは、傍受のエラー（例外は）によってスロー可能に&lt;a href=&quot;#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt;、プログラムの実行を継続できるようにします。たとえば、次のコードはファイルへの書き込みを試みますが、ファイルに書き込めない場合は実行を終了する代わりに、ユーザーに警告して続行します。</target>
        </trans-unit>
        <trans-unit id="6f7e3d0cb44d68c0e786c74714c652c1e6239ca4" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;package&lt;/em&gt; is a source tree with a standard layout providing functionality that can be reused by other Julia projects. A package is loaded by &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt; statements. These statements also make the module named &lt;code&gt;X&lt;/code&gt;&amp;mdash;which results from loading the package code&amp;mdash;available within the module where the import statement occurs. The meaning of &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;import X&lt;/code&gt; is context-dependent: which &lt;code&gt;X&lt;/code&gt; package is loaded depends on what code the statement occurs in. Thus, handling of &lt;code&gt;import X&lt;/code&gt; happens in two stages: first, it determines &lt;strong&gt;what&lt;/strong&gt; package is defined to be &lt;code&gt;X&lt;/code&gt; in this context; second, it determines &lt;strong&gt;where&lt;/strong&gt; that particular &lt;code&gt;X&lt;/code&gt; package is found.</source>
          <target state="translated">&lt;em&gt;パッケージには、&lt;/em&gt;他のジュリア・プロジェクトで再利用することができ、標準的なレイアウト提供する機能を持つソースツリーです。パッケージは、 &lt;code&gt;import X&lt;/code&gt; または &lt;code&gt;using X&lt;/code&gt; ステートメントを使用してロードされます。これらのステートメントは、 &lt;code&gt;X&lt;/code&gt; という名前のモジュール（パッケージコードの読み込みの結果）も作成し、インポートステートメントが発生するモジュール内で使用できるようにします。意味 &lt;code&gt;X&lt;/code&gt; における &lt;code&gt;import X&lt;/code&gt; ：文脈依存である &lt;code&gt;X&lt;/code&gt; 文がで発生するどのようなコードに依存パッケージロードされているしたがって、の取り扱い。 &lt;code&gt;import X&lt;/code&gt; 二段階で起こる：最初に、決定&lt;strong&gt;するもの&lt;/strong&gt;パッケージがあることと定義されている &lt;code&gt;X&lt;/code&gt; この文脈では; 次に、特定の &lt;code&gt;X&lt;/code&gt; パッケージが&lt;strong&gt;どこに&lt;/strong&gt;あるかを判別します。</target>
        </trans-unit>
        <trans-unit id="0ea5ce3cb4556ddc297c6aeebda772ae9221423a" translate="yes" xml:space="preserve">
          <source>A C function declared to return &lt;code&gt;Cvoid&lt;/code&gt; will return the value &lt;code&gt;nothing&lt;/code&gt; in Julia.</source>
          <target state="translated">AC機能は、返すように宣言 &lt;code&gt;Cvoid&lt;/code&gt; を値の返しません &lt;code&gt;nothing&lt;/code&gt; ジュリアでは。</target>
        </trans-unit>
        <trans-unit id="def83ea9fa11b0a4be5ef6b08c5ce4257e5755ca" translate="yes" xml:space="preserve">
          <source>A C-style string composed of the native character type &lt;a href=&quot;#Base.Cchar&quot;&gt;&lt;code&gt;Cchar&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;Cstring&lt;/code&gt;s are NUL-terminated. For C-style strings composed of the native wide character type, see &lt;a href=&quot;#Base.Cwstring&quot;&gt;&lt;code&gt;Cwstring&lt;/code&gt;&lt;/a&gt;. For more information about string interopability with C, see the &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">ネイティブの文字タイプ&lt;a href=&quot;#Base.Cchar&quot;&gt; &lt;code&gt;Cchar&lt;/code&gt; で&lt;/a&gt;構成されるCスタイルの文字列。 &lt;code&gt;Cstring&lt;/code&gt; はNULで終了します。ネイティブワイド文字タイプで構成されるCスタイルの文字列については、&lt;a href=&quot;#Base.Cwstring&quot;&gt; &lt;code&gt;Cwstring&lt;/code&gt; を&lt;/a&gt;参照してください。Cとの文字列の相互運用性の詳細については、&lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;マニュアルを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ac0a9fe2ade0eb6e9c2e2cc4b61f726d6a965d9c" translate="yes" xml:space="preserve">
          <source>A C-style string composed of the native wide character type &lt;a href=&quot;#Base.Cwchar_t&quot;&gt;&lt;code&gt;Cwchar_t&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;Cwstring&lt;/code&gt;s are NUL-terminated. For C-style strings composed of the native character type, see &lt;a href=&quot;#Base.Cstring&quot;&gt;&lt;code&gt;Cstring&lt;/code&gt;&lt;/a&gt;. For more information about string interopability with C, see the &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">ネイティブワイド文字タイプ&lt;a href=&quot;#Base.Cwchar_t&quot;&gt; &lt;code&gt;Cwchar_t&lt;/code&gt; で&lt;/a&gt;構成されるCスタイルの文字列。 &lt;code&gt;Cwstring&lt;/code&gt; はNULで終了します。ネイティブ文字タイプで構成されるCスタイルの文字列については、&lt;a href=&quot;#Base.Cstring&quot;&gt; &lt;code&gt;Cstring&lt;/code&gt; を&lt;/a&gt;参照してください。 Cとの文字列の相互運用性の詳細については、&lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;マニュアルを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="023376b34dc0e6e575fb072d80744bfc1276423d" translate="yes" xml:space="preserve">
          <source>A Givens rotation linear operator. The fields &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt; represent the cosine and sine of the rotation angle, respectively. The &lt;code&gt;Givens&lt;/code&gt; type supports left multiplication &lt;code&gt;G*A&lt;/code&gt; and conjugated transpose right multiplication &lt;code&gt;A*G'&lt;/code&gt;. The type doesn't have a &lt;code&gt;size&lt;/code&gt; and can therefore be multiplied with matrices of arbitrary size as long as &lt;code&gt;i2&amp;lt;=size(A,2)&lt;/code&gt; for &lt;code&gt;G*A&lt;/code&gt; or &lt;code&gt;i2&amp;lt;=size(A,1)&lt;/code&gt; for &lt;code&gt;A*G'&lt;/code&gt;.</source>
          <target state="translated">ギブンズ回転線形演算子。フィールド &lt;code&gt;c&lt;/code&gt; と &lt;code&gt;s&lt;/code&gt; は、それぞれ回転角のコサインとサインを表します。 &lt;code&gt;Givens&lt;/code&gt; タイプの支持体は、乗算左 &lt;code&gt;G*A&lt;/code&gt; をし、転置右乗算共役 &lt;code&gt;A*G'&lt;/code&gt; 。タイプには &lt;code&gt;size&lt;/code&gt; がないため、 &lt;code&gt;G*A&lt;/code&gt; の &lt;code&gt;i2&amp;lt;=size(A,2)&lt;/code&gt; または &lt;code&gt;A*G'&lt;/code&gt; &lt;code&gt;i2&amp;lt;=size(A,1)&lt;/code&gt; である限り、任意のサイズの行列を乗算できます。</target>
        </trans-unit>
        <trans-unit id="c0f95cfdddef2f3b16bd0eaacf8c5ec7871a86e5" translate="yes" xml:space="preserve">
          <source>A Julia Function</source>
          <target state="translated">ジュリア関数</target>
        </trans-unit>
        <trans-unit id="338b907694ffa95225d1463f09b5454501424162" translate="yes" xml:space="preserve">
          <source>A Julia cluster has the following characteristics:</source>
          <target state="translated">ジュリアクラスターには以下のような特徴があります。</target>
        </trans-unit>
        <trans-unit id="afbb147573dcd49250e15c543ce261c2ed456757" translate="yes" xml:space="preserve">
          <source>A Julia script may contain any number of functions, and all definitions will be externally visible when the file is loaded. Function definitions can be loaded from files outside the current working directory.</source>
          <target state="translated">Julia スクリプトにはいくつでも関数を含めることができ、ファイルをロードするとすべての定義が外部に表示されます。関数の定義は、現在の作業ディレクトリ以外のファイルから読み込むことができます。</target>
        </trans-unit>
        <trans-unit id="ec5c0a21b198e35d9011cfccf1720c04200ccca0" translate="yes" xml:space="preserve">
          <source>A LibGit2 credential callback function which provides different credential acquisition functionality w.r.t. a connection protocol. The &lt;code&gt;payload_ptr&lt;/code&gt; is required to contain a &lt;code&gt;LibGit2.CredentialPayload&lt;/code&gt; object which will keep track of state and settings.</source>
          <target state="translated">接続プロトコルに対してさまざまな資格情報取得機能を提供するLibGit2資格情報コールバック関数。 &lt;code&gt;payload_ptr&lt;/code&gt; を含むように要求され &lt;code&gt;LibGit2.CredentialPayload&lt;/code&gt; の状態や設定を追跡するオブジェクトを。</target>
        </trans-unit>
        <trans-unit id="01a933ad46a5f5ec0c3c3e174d75cd08e0a9bf13" translate="yes" xml:space="preserve">
          <source>A LibGit2 representation of an array of strings. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_strarray&quot;&gt;&lt;code&gt;git_strarray&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">文字列の配列のLibGit2表現。&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_strarray&quot;&gt; &lt;code&gt;git_strarray&lt;/code&gt; &lt;/a&gt;構造体と一致します。</target>
        </trans-unit>
        <trans-unit id="eb6b4f3bedfc4889701c09c75dc083d1c8d58006" translate="yes" xml:space="preserve">
          <source>A QR matrix factorization stored in a compact blocked format, typically obtained from &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;. If $A$ is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix, then</source>
          <target state="translated">コンパクトなブロック形式で保存されたQR行列因数分解。通常、&lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt;から取得されます。$ A $が &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 行列の場合、</target>
        </trans-unit>
        <trans-unit id="a2bfddaee8ff7a44aec0ab4b2b1e184a0f187d2e" translate="yes" xml:space="preserve">
          <source>A QR matrix factorization stored in a packed format, typically obtained from &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;. If $A$ is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix, then</source>
          <target state="translated">パックされた形式で保存されたQR行列因数分解。通常、&lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt;から取得されます。$ A $が &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 行列の場合、</target>
        </trans-unit>
        <trans-unit id="c9925c571d2e1e694cc1d660f2d03ec4cf1ec057" translate="yes" xml:space="preserve">
          <source>A QR matrix factorization with column pivoting in a packed format, typically obtained from &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;. If $A$ is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix, then</source>
          <target state="translated">通常は&lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt;から取得される、パックされた形式で列ピボットを行うQR行列因数分解。$ A $が &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 行列の場合、</target>
        </trans-unit>
        <trans-unit id="028b2fd647f67d6a5b3b18c1e2a4be06ea973f76" translate="yes" xml:space="preserve">
          <source>A basic editor/REPL workflow</source>
          <target state="translated">基本的なエディタ/REPLのワークフロー</target>
        </trans-unit>
        <trans-unit id="3e270c005ba798894763e8eb54b974bf29e5d476" translate="yes" xml:space="preserve">
          <source>A buffered IO stream wrapping an OS file descriptor. Mostly used to represent files returned by &lt;a href=&quot;#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">OSファイル記述子をラップするバッファリングされたIOストリーム。主に&lt;a href=&quot;#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;によって返されるファイルを表すために使用されます。</target>
        </trans-unit>
        <trans-unit id="d6761a9dad52906730c7e2d2e824c87ab1ba9a0c" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt; returns a vector of &lt;code&gt;Union{Ptr{Nothing}, Base.InterpreterIP}&lt;/code&gt;, which may then be passed into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt; for translation:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; を&lt;/a&gt;呼び出すと、 &lt;code&gt;Union{Ptr{Nothing}, Base.InterpreterIP}&lt;/code&gt; ベクトルが返されます。これは、変換のために&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt;に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="783595edaa0cd8106f88e2687e628c9ad8922d54" translate="yes" xml:space="preserve">
          <source>A cartesian indexing style uses multiple integers/indices to describe the position in the array. For example, if &lt;code&gt;A&lt;/code&gt; were a &lt;code&gt;(2, 3, 4)&lt;/code&gt; custom matrix type with cartesian indexing, we could reference &lt;code&gt;A[2, 1, 3]&lt;/code&gt; and Julia would automatically convert this into the correct location in the underlying memory. See also &lt;a href=&quot;#Base.IndexLinear&quot;&gt;&lt;code&gt;IndexLinear&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">デカルトインデックススタイルでは、複数の整数/インデックスを使用して、配列内の位置を記述します。たとえば、 &lt;code&gt;A&lt;/code&gt; がデカルトインデックスを使用する &lt;code&gt;(2, 3, 4)&lt;/code&gt; カスタムマトリックスタイプの場合、 &lt;code&gt;A[2, 1, 3]&lt;/code&gt; 2、1、3 ]を参照すると、Juliaはこれを基になるメモリ内の正しい場所に自動的に変換します。&lt;a href=&quot;#Base.IndexLinear&quot;&gt; &lt;code&gt;IndexLinear&lt;/code&gt; &lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="9b670cf7ce6aa053516969f59beb26f75521a626" translate="yes" xml:space="preserve">
          <source>A channel can be visualized as a pipe, i.e., it has a write end and a read end :</source>
          <target state="translated">チャンネルはパイプとして視覚化することができます。</target>
        </trans-unit>
        <trans-unit id="cda0bd3645d716870c693b3b59018dd4924caf33" translate="yes" xml:space="preserve">
          <source>A classic example is the standard C library &lt;code&gt;qsort&lt;/code&gt; function, declared as:</source>
          <target state="translated">古典的な例は、 &lt;code&gt;qsort&lt;/code&gt; ように宣言された標準Cライブラリのqsort関数です。</target>
        </trans-unit>
        <trans-unit id="e90162b2f2534c5d2ad98ffd6060c363829dd8a7" translate="yes" xml:space="preserve">
          <source>A cluster spanning machines using the &lt;code&gt;--machine-file&lt;/code&gt; option. This uses a passwordless &lt;code&gt;ssh&lt;/code&gt; login to start Julia worker processes (from the same path as the current host) on the specified machines.</source>
          <target state="translated">&lt;code&gt;--machine-file&lt;/code&gt; オプションを使用したマシンにまたがるクラスター。これは、パスワードなしの &lt;code&gt;ssh&lt;/code&gt; ログインを使用して、指定されたマシン上で（現在のホストと同じパスから）Juliaワーカープロセスを開始します。</target>
        </trans-unit>
        <trans-unit id="7d02127d252ebd3948a9767c4487385c4243c197" translate="yes" xml:space="preserve">
          <source>A common pitfall when running external programs via a shell is that if a file name contains characters that are special to the shell, they may cause undesirable behavior. Suppose, for example, rather than &lt;code&gt;/etc/passwd&lt;/code&gt;, we wanted to sort the contents of the file &lt;code&gt;/Volumes/External HD/data.csv&lt;/code&gt;. Let's try it:</source>
          <target state="translated">シェルを介して外部プログラムを実行するときの一般的な落とし穴は、ファイル名にシェルに特有の文字が含まれている場合、望ましくない動作を引き起こす可能性があることです。たとえば、 &lt;code&gt;/etc/passwd&lt;/code&gt; ではなく、 &lt;code&gt;/Volumes/External HD/data.csv&lt;/code&gt; ファイルの内容をソートしたいとします。試してみよう：</target>
        </trans-unit>
        <trans-unit id="6454f39a38aef4a6a88d7b516cb03974038d7792" translate="yes" xml:space="preserve">
          <source>A common use of variables is giving names to specific, unchanging values. Such variables are only assigned once. This intent can be conveyed to the compiler using the &lt;a href=&quot;../../base/base/index#const&quot;&gt;&lt;code&gt;const&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">変数の一般的な用途は、特定の変化しない値に名前を付けることです。このような変数は一度だけ割り当てられます。この意図は、&lt;a href=&quot;../../base/base/index#const&quot;&gt; &lt;code&gt;const&lt;/code&gt; &lt;/a&gt;キーワードを使用してコンパイラに伝達できます。</target>
        </trans-unit>
        <trans-unit id="d3cb20f10d68d34ff29611ac3f50ba68dd4c4b99" translate="yes" xml:space="preserve">
          <source>A comprehensive overview of all documentable Julia syntax.</source>
          <target state="translated">ドキュメント化されたJuliaの構文の包括的な概要です。</target>
        </trans-unit>
        <trans-unit id="0d6d37f3dca8ed9b04613226e4330c5ab758e3f1" translate="yes" xml:space="preserve">
          <source>A concrete implementation of an &lt;code&gt;AbstractChannel&lt;/code&gt; (like &lt;code&gt;Channel&lt;/code&gt;), is required to implement &lt;code&gt;put!&lt;/code&gt;, &lt;code&gt;take!&lt;/code&gt;, &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;isready&lt;/code&gt; and &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;. The remote object referred to by a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; is stored in a &lt;code&gt;Channel{Any}(1)&lt;/code&gt;, i.e., a &lt;code&gt;Channel&lt;/code&gt; of size 1 capable of holding objects of &lt;code&gt;Any&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;put!&lt;/code&gt; を実装するには、 &lt;code&gt;AbstractChannel&lt;/code&gt; （ &lt;code&gt;Channel&lt;/code&gt; のような）の具体的な実装が必要です。、 &lt;code&gt;take!&lt;/code&gt; 、 &lt;code&gt;fetch&lt;/code&gt; 、 &lt;code&gt;isready&lt;/code&gt; 、&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;によって参照されるリモートオブジェクトは &lt;code&gt;Channel{Any}(1)&lt;/code&gt; 、つまり &lt;code&gt;Any&lt;/code&gt; タイプのオブジェクトを保持できるサイズ1の &lt;code&gt;Channel&lt;/code&gt; に格納されます。</target>
        </trans-unit>
        <trans-unit id="e6d94519717188d6531df826c6d7c056c25b4e04" translate="yes" xml:space="preserve">
          <source>A constructor is just like any other function in Julia in that its overall behavior is defined by the combined behavior of its methods. Accordingly, you can add functionality to a constructor by simply defining new methods. For example, let's say you want to add a constructor method for &lt;code&gt;Foo&lt;/code&gt; objects that takes only one argument and uses the given value for both the &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; fields. This is simple:</source>
          <target state="translated">コンストラクターは、その全体的な動作がそのメソッドの結合された動作によって定義されるという点で、Juliaの他の関数と同じです。したがって、新しいメソッドを定義するだけで、コンストラクタに機能を追加できます。たとえば、引数を1つだけ取り、 &lt;code&gt;bar&lt;/code&gt; フィールドと &lt;code&gt;baz&lt;/code&gt; フィールドの両方に指定された値を使用する &lt;code&gt;Foo&lt;/code&gt; オブジェクトのコンストラクタメソッドを追加するとします。これは簡単です：</target>
        </trans-unit>
        <trans-unit id="da756968deae2626766b76b59d785afc3e81b3a6" translate="yes" xml:space="preserve">
          <source>A convenience macro for writing &lt;a href=&quot;#Base.Multimedia.MIME&quot;&gt;&lt;code&gt;MIME&lt;/code&gt;&lt;/a&gt; types, typically used when adding methods to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;. For example the syntax &lt;code&gt;show(io::IO, ::MIME&quot;text/html&quot;, x::MyType) = ...&lt;/code&gt; could be used to define how to write an HTML representation of &lt;code&gt;MyType&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.Multimedia.MIME&quot;&gt; &lt;code&gt;MIME&lt;/code&gt; &lt;/a&gt;タイプを記述するための便利なマクロで、通常、&lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; に&lt;/a&gt;メソッドを追加するときに使用されます。たとえば、構文 &lt;code&gt;show(io::IO, ::MIME&quot;text/html&quot;, x::MyType) = ...&lt;/code&gt; を使用して、 &lt;code&gt;MyType&lt;/code&gt; の HTML表現を記述する方法を定義できます。</target>
        </trans-unit>
        <trans-unit id="ce500fee8f2cf895c4ff2e81b81207ab74479894" translate="yes" xml:space="preserve">
          <source>A correct way to define a method that accepts all arguments of type &lt;code&gt;Point{T}&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a subtype of &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; is:</source>
          <target state="translated">タイプのすべての引数を受け付ける方法を定義するための正しい方法 &lt;code&gt;Point{T}&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; は、のサブタイプである&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;されます。</target>
        </trans-unit>
        <trans-unit id="3fdea15c071a796482bb0cbad61dbe066b8e91d1" translate="yes" xml:space="preserve">
          <source>A curated list of useful learning resources to help new users get started can be found on the &lt;a href=&quot;https://julialang.org/learning/&quot;&gt;learning&lt;/a&gt; page of the main Julia web site.</source>
          <target state="translated">JuliaのメインWebサイトの&lt;a href=&quot;https://julialang.org/learning/&quot;&gt;学習&lt;/a&gt;ページに、新しいユーザーが使い始めるのに役立つ有用な学習リソースの精選されたリストがあります。</target>
        </trans-unit>
        <trans-unit id="f02f82182ef74a9efe3bec210a9632727895f0a5" translate="yes" xml:space="preserve">
          <source>A custom title for the box can be provided as a string (in double quotes) after the admonition type. If no title text is specified after the admonition type, then the title used will be the type of the block, i.e. &lt;code&gt;&quot;Note&quot;&lt;/code&gt; in the case of the &lt;code&gt;note&lt;/code&gt; admonition.</source>
          <target state="translated">ボックスのカスタムタイトルは、警告タイプの後に文字列として（二重引用符で）提供できます。警告タイプの後にタイトルテキストが指定されていない場合、使用されるタイトルはブロックのタイプになります。つまり、 &lt;code&gt;note&lt;/code&gt; 警告の場合は &lt;code&gt;&quot;Note&quot;&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="66ad883b8ebd4cb13361ac5dca2bf64c895374f2" translate="yes" xml:space="preserve">
          <source>A data buffer for exporting data from libgit2. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_buf&quot;&gt;&lt;code&gt;git_buf&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">libgit2からデータをエクスポートするためのデータバッファー。&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_buf&quot;&gt; &lt;code&gt;git_buf&lt;/code&gt; &lt;/a&gt;構造体と一致します。</target>
        </trans-unit>
        <trans-unit id="043f580a8a8cc9a9005c9d9892ccd32895f20dc0" translate="yes" xml:space="preserve">
          <source>A deprecated function internally performs a lookup in order to print a relevant warning only once. This extra lookup can cause a significant slowdown, so all uses of deprecated functions should be modified as suggested by the warnings.</source>
          <target state="translated">非推奨の関数は、関連する警告を一度だけ表示するために内部的にルックアップを実行します。この余分なルックアップは大幅な速度低下を引き起こす可能性があるので、非推奨関数のすべての使用法は、警告で示唆されているように修正しなければなりません。</target>
        </trans-unit>
        <trans-unit id="8caa8da69c3b3cb75cd1d014abbbf0696fbf4493" translate="yes" xml:space="preserve">
          <source>A directory path that indicates which project should be the initial active project. Setting this environment variable has the same effect as specifying the &lt;code&gt;--project&lt;/code&gt; start-up option, but &lt;code&gt;--project&lt;/code&gt; has higher precedence. If the variable is set to &lt;code&gt;@.&lt;/code&gt; then Julia tries to find a project directory that contains &lt;code&gt;Project.toml&lt;/code&gt; or &lt;code&gt;JuliaProject.toml&lt;/code&gt; file from the current directory and its parents. See also the chapter on &lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;Code Loading&lt;/a&gt;.</source>
          <target state="translated">どのプロジェクトを最初のアクティブプロジェクトにするかを示すディレクトリパス。この環境変数を設定すると、 &lt;code&gt;--project&lt;/code&gt; 起動オプションを指定した場合と同じ結果に &lt;code&gt;--project&lt;/code&gt; が、-projectの方が優先されます。変数が &lt;code&gt;@.&lt;/code&gt; 設定されている場合。次に、Juliaは、現在のディレクトリとその親から &lt;code&gt;Project.toml&lt;/code&gt; または &lt;code&gt;JuliaProject.toml&lt;/code&gt; ファイルを含むプロジェクトディレクトリを見つけようとします。&lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;コードのロード&lt;/a&gt;に関する章も参照してください。</target>
        </trans-unit>
        <trans-unit id="214eedeee1125bd3c3f68e94a3d499c9e468ec4a" translate="yes" xml:space="preserve">
          <source>A distributed memory, parallel for loop of the form :</source>
          <target state="translated">分散型メモリで、並列ループの形をしています。</target>
        </trans-unit>
        <trans-unit id="19754b4c8d91fdeebb8f2031c8dcc27614b27813" translate="yes" xml:space="preserve">
          <source>A document can be split up into different sections using headers. Headers use the following syntax:</source>
          <target state="translated">ドキュメントは、ヘッダを使って異なるセクションに分割することができます。ヘッダーは以下の構文を使用します。</target>
        </trans-unit>
        <trans-unit id="906831c5f1833fe1c6cead11729270eaa1e64820" translate="yes" xml:space="preserve">
          <source>A fast, unfair-scheduling version of &lt;code&gt;schedule(t, arg); yield()&lt;/code&gt; which immediately yields to &lt;code&gt;t&lt;/code&gt; before calling the scheduler.</source>
          <target state="translated">&lt;code&gt;schedule(t, arg); yield()&lt;/code&gt; の高速で不公平なバージョン。スケジューラを呼び出す前にすぐに &lt;code&gt;t&lt;/code&gt; に譲るyield（）。</target>
        </trans-unit>
        <trans-unit id="5b34dfa04ee74a34a9d1a9cbb45d550b2f88b889" translate="yes" xml:space="preserve">
          <source>A few general rules to note:</source>
          <target state="translated">注意すべき一般的なルールをいくつか。</target>
        </trans-unit>
        <trans-unit id="af07889865f77b7c4b96703878fe873de95ec344" translate="yes" xml:space="preserve">
          <source>A few other points to be aware of:</source>
          <target state="translated">他にもいくつか注意すべき点があります。</target>
        </trans-unit>
        <trans-unit id="60a8d349acf8be941cbc934da15ee121f8a78126" translate="yes" xml:space="preserve">
          <source>A few popular languages have singleton types, including Haskell, Scala and Ruby. In general usage, the term &quot;singleton type&quot; refers to a type whose only instance is a single value. This meaning applies to Julia's singleton types, but with that caveat that only type objects have singleton types.</source>
          <target state="translated">いくつかの一般的な言語には、Haskell、Scala、Rubyなどのシングルトン型があります。一般的な使用法では、「シングルトン型」という用語は、インスタンスが単一の値のみである型を指します。この意味はジュリアのシングルトン型にも当てはまりますが、型オブジェクトのみがシングルトン型を持つという注意点があります。</target>
        </trans-unit>
        <trans-unit id="00922cb6654b9fb1b8cc559d5766ed07010c9573" translate="yes" xml:space="preserve">
          <source>A few special expressions correspond to calls to functions with non-obvious names. These are:</source>
          <target state="translated">いくつかの特殊な式は、自明ではない名前の関数の呼び出しに対応しています。これらは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="df6e90fee529846cc6c25c991e16a7b9cfb908be" translate="yes" xml:space="preserve">
          <source>A file can also be preloaded on multiple processes at startup with the &lt;code&gt;-L&lt;/code&gt; flag, and a driver script can be used to drive the computation:</source>
          <target state="translated">&lt;code&gt;-L&lt;/code&gt; フラグを使用して、起動時にファイルを複数のプロセスにプリロードすることもでき、ドライバースクリプトを使用して計算を実行できます。</target>
        </trans-unit>
        <trans-unit id="bef6fc12def87705c0724012674763d06330988e" translate="yes" xml:space="preserve">
          <source>A full list of tab-completions can be found in the &lt;a href=&quot;../../manual/unicode-input/index#Unicode-Input-1&quot;&gt;Unicode Input&lt;/a&gt; section of the manual.</source>
          <target state="translated">タブ補完の完全なリストは、マニュアルの&lt;a href=&quot;../../manual/unicode-input/index#Unicode-Input-1&quot;&gt;Unicode入力&lt;/a&gt;セクションにあります。</target>
        </trans-unit>
        <trans-unit id="776e65341479516956a84c86603101c98f11aaf1" translate="yes" xml:space="preserve">
          <source>A full suite of parsing and formatting tests and examples is available in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/io.jl&quot;&gt;&lt;code&gt;stdlib/Dates/test/io.jl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">構文解析とフォーマットのテストと例の完全なスイートは、&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/io.jl&quot;&gt; &lt;code&gt;stdlib/Dates/test/io.jl&lt;/code&gt; にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="8d1efd2d920b71c04b3aea5f88fea207dff694c1" translate="yes" xml:space="preserve">
          <source>A function &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; to request the richest available multimedia display of a Julia object &lt;code&gt;x&lt;/code&gt; (with a plain-text fallback).</source>
          <target state="translated">Juliaオブジェクト &lt;code&gt;x&lt;/code&gt; の利用可能な最もリッチなマルチメディア表示を要求する関数&lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt;（プレーンテキストのフォールバック付き）。</target>
        </trans-unit>
        <trans-unit id="96f1b83c87e5168541a9af06566b09eb353921f1" translate="yes" xml:space="preserve">
          <source>A function is called using the traditional parenthesis syntax:</source>
          <target state="translated">関数は、従来の括弧構文を使用して呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d5d505a0f9d0a8bc085cb6ea8549229cd44ccf9a" translate="yes" xml:space="preserve">
          <source>A function name may be used alone in place of the tuple (just &lt;code&gt;:function&lt;/code&gt; or &lt;code&gt;&quot;function&quot;&lt;/code&gt;). In this case the name is resolved within the current process. This form can be used to call C library functions, functions in the Julia runtime, or functions in an application linked to Julia.</source>
          <target state="translated">関数名はタプルの代わりに単独で使用できます（ &lt;code&gt;:function&lt;/code&gt; または &lt;code&gt;&quot;function&quot;&lt;/code&gt; のみ）。この場合、名前は現在のプロセス内で解決されます。このフォームは、Cライブラリ関数、Juliaランタイムの関数、またはJuliaにリンクされたアプリケーションの関数を呼び出すために使用できます。</target>
        </trans-unit>
        <trans-unit id="59d50016e8809b20104597755ad0d300cddc21a6" translate="yes" xml:space="preserve">
          <source>A function signature:</source>
          <target state="translated">関数のシグネチャ。</target>
        </trans-unit>
        <trans-unit id="fe743a5fafb686fdaff2fd3950e5909b38ec521c" translate="yes" xml:space="preserve">
          <source>A function with a declared return type converts its return value to that type.</source>
          <target state="translated">宣言された戻り値型を持つ関数は、その戻り値をその型に変換します。</target>
        </trans-unit>
        <trans-unit id="25a045a60155304dcdc010c60b6dbf032ba437c0" translate="yes" xml:space="preserve">
          <source>A git object identifier, based on the sha-1 hash. It is a 20 byte string (40 hex digits) used to identify a &lt;code&gt;GitObject&lt;/code&gt; in a repository.</source>
          <target state="translated">sha-1ハッシュに基づくgitオブジェクト識別子。これは、リポジトリ内の &lt;code&gt;GitObject&lt;/code&gt; を識別するために使用される20バイトの文字列（40桁の16進数）です。</target>
        </trans-unit>
        <trans-unit id="2b9dac9baaf8e5d26caf82470268456378e7b354" translate="yes" xml:space="preserve">
          <source>A given &lt;code&gt;AbstractChar&lt;/code&gt; subtype may be capable of representing only a subset of Unicode, in which case conversion from an unsupported &lt;code&gt;UInt32&lt;/code&gt; value may throw an error. Conversely, the built-in &lt;a href=&quot;#Core.Char&quot;&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/a&gt; type represents a &lt;em&gt;superset&lt;/em&gt; of Unicode (in order to losslessly encode invalid byte streams), in which case conversion of a non-Unicode value &lt;em&gt;to&lt;/em&gt;&lt;code&gt;UInt32&lt;/code&gt; throws an error. The &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;isvalid&lt;/code&gt;&lt;/a&gt; function can be used to check which codepoints are representable in a given &lt;code&gt;AbstractChar&lt;/code&gt; type.</source>
          <target state="translated">特定の &lt;code&gt;AbstractChar&lt;/code&gt; サブタイプは、Unicodeのサブセットのみを表すことができる場合があります。その場合、サポートされていない &lt;code&gt;UInt32&lt;/code&gt; 値からの変換はエラーをスローする可能性があります。逆に、組み込みの&lt;a href=&quot;#Core.Char&quot;&gt; &lt;code&gt;Char&lt;/code&gt; &lt;/a&gt;型はUnicodeの&lt;em&gt;スーパーセット&lt;/em&gt;を表します（無効なバイトストリームを無損失でエンコードするため）。この場合、非Unicode値&lt;em&gt;を&lt;/em&gt; &lt;code&gt;UInt32&lt;/code&gt; に変換するとエラーがスローされます。&lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;isvalid&lt;/code&gt; &lt;/a&gt;関数は所与で表現されたコードポイントを確認するために使用することができる &lt;code&gt;AbstractChar&lt;/code&gt; のタイプ。</target>
        </trans-unit>
        <trans-unit id="04d95958adcacd4e7b4382e807134e41ec53c3fc" translate="yes" xml:space="preserve">
          <source>A global variable might have its value, and therefore its type, change at any point. This makes it difficult for the compiler to optimize code using global variables. Variables should be local, or passed as arguments to functions, whenever possible.</source>
          <target state="translated">グローバル変数の値、つまり型はいつでも変更される可能性があります。これにより、コンパイラがグローバル変数を使用したコードを最適化することが困難になります。変数は可能な限り、ローカル変数にするか、関数の引数として渡すべきです。</target>
        </trans-unit>
        <trans-unit id="e11090dc004521cb3583f54e041c822a584bd2f5" translate="yes" xml:space="preserve">
          <source>A great strength of Julia is that since the API is exposed synchronously even though the I/O is actually happening asynchronously, we didn't have to worry about callbacks or even making sure that the server gets to run. When we called &lt;code&gt;connect&lt;/code&gt; the current task waited for the connection to be established and only continued executing after that was done. In this pause, the server task resumed execution (because a connection request was now available), accepted the connection, printed the message and waited for the next client. Reading and writing works in the same way. To see this, consider the following simple echo server:</source>
          <target state="translated">Juliaの優れた点は、I / Oが実際には非同期で行われている場合でもAPIが同期的に公開されるため、コールバックについて心配したり、サーバーが実行できるようにする必要がなかったりすることです。 &lt;code&gt;connect&lt;/code&gt; を呼び出すと、現在のタスクは接続が確立されるのを待って、それが実行された後にのみ実行を続けました。この一時停止中に、サーバータスクは実行を再開し（接続要求が利用可能になったため）、接続を受け入れ、メッセージを出力し、次のクライアントを待機しました。読み書きは同じように機能します。これを確認するには、次の単純なエコーサーバーを検討してください。</target>
        </trans-unit>
        <trans-unit id="0a9e1db1edf203efc9535001b0c4d60d58c32400" translate="yes" xml:space="preserve">
          <source>A header line can contain any inline syntax in the same way as a paragraph can.</source>
          <target state="translated">ヘッダー行には、段落と同じようにインライン構文を含めることができます。</target>
        </trans-unit>
        <trans-unit id="a5bee9cb41ed39aedfa6d81eeafb7305d47a4fcb" translate="yes" xml:space="preserve">
          <source>A key part in defining an &lt;code&gt;AbstractArray&lt;/code&gt; subtype is &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;IndexStyle&lt;/code&gt;&lt;/a&gt;. Since indexing is such an important part of an array and often occurs in hot loops, it's important to make both indexing and indexed assignment as efficient as possible. Array data structures are typically defined in one of two ways: either it most efficiently accesses its elements using just one index (linear indexing) or it intrinsically accesses the elements with indices specified for every dimension. These two modalities are identified by Julia as &lt;code&gt;IndexLinear()&lt;/code&gt; and &lt;code&gt;IndexCartesian()&lt;/code&gt;. Converting a linear index to multiple indexing subscripts is typically very expensive, so this provides a traits-based mechanism to enable efficient generic code for all array types.</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; サブタイプを定義する上で重要なのは&lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt; &lt;code&gt;IndexStyle&lt;/code&gt; &lt;/a&gt;です。インデックス付けは配列の非常に重要な部分であり、多くの場合ホットループで発生するため、インデックス付けとインデックス付き割り当ての両方をできるだけ効率的にすることが重要です。配列データ構造は通常、次の2つの方法のいずれかで定義されます。1つのインデックス（線形インデックス）を使用して要素に最も効率的にアクセスするか、すべての次元に指定されたインデックスを持つ要素に本質的にアクセスします。これら2つのモダリティは、Juliaによって &lt;code&gt;IndexLinear()&lt;/code&gt; および &lt;code&gt;IndexCartesian()&lt;/code&gt; として識別されます。線形インデックスを複数のインデックスの添え字に変換することは、通常非常にコストがかかるため、特性ベースのメカニズムを提供して、すべての配列型に対して効率的な汎用コードを有効にします。</target>
        </trans-unit>
        <trans-unit id="3a023b19be8aa0bdde697959a3cb353c50c4a7e6" translate="yes" xml:space="preserve">
          <source>A linear index into the array &lt;code&gt;A&lt;/code&gt; can be converted to a &lt;code&gt;CartesianIndex&lt;/code&gt; for cartesian indexing with &lt;code&gt;CartesianIndices(A)[i]&lt;/code&gt; (see &lt;a href=&quot;../../base/arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;), and a set of &lt;code&gt;N&lt;/code&gt; cartesian indices can be converted to a linear index with &lt;code&gt;LinearIndices(A)[i_1, i_2, ..., i_N]&lt;/code&gt; (see &lt;a href=&quot;../../base/arrays/index#Base.LinearIndices&quot;&gt;&lt;code&gt;LinearIndices&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">アレイに線形インデックス &lt;code&gt;A&lt;/code&gt; は、に変換することができる &lt;code&gt;CartesianIndex&lt;/code&gt; と直交索引付け &lt;code&gt;CartesianIndices(A)[i]&lt;/code&gt; （参照&lt;a href=&quot;../../base/arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; を&lt;/a&gt;）、および一組の &lt;code&gt;N&lt;/code&gt; デカルトインデックスは線形インデックスに変換することができる &lt;code&gt;LinearIndices(A)[i_1, i_2, ..., i_N]&lt;/code&gt; （&lt;a href=&quot;../../base/arrays/index#Base.LinearIndices&quot;&gt; &lt;code&gt;LinearIndices&lt;/code&gt; を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="fba3600321961b41d61a445772a6a0bbc42feb66" translate="yes" xml:space="preserve">
          <source>A linear indexing style uses one integer to describe the position in the array (even if it's a multidimensional array) and column-major ordering is used to access the elements. For example, if &lt;code&gt;A&lt;/code&gt; were a &lt;code&gt;(2, 3)&lt;/code&gt; custom matrix type with linear indexing, and we referenced &lt;code&gt;A[5]&lt;/code&gt; (using linear style), this would be equivalent to referencing &lt;code&gt;A[1, 3]&lt;/code&gt; (since &lt;code&gt;2*1 + 3 = 5&lt;/code&gt;). See also &lt;a href=&quot;#Base.IndexCartesian&quot;&gt;&lt;code&gt;IndexCartesian&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">線形インデックススタイルは、1つの整数を使用して配列内の位置を記述し（多次元配列であっても）、要素にアクセスするために列優先順が使用されます。たとえば、 &lt;code&gt;A&lt;/code&gt; が線形インデックスを持つ &lt;code&gt;(2, 3)&lt;/code&gt; カスタムマトリックスタイプであり、 &lt;code&gt;A[5]&lt;/code&gt; を参照した場合（線形スタイルを使用）、これは &lt;code&gt;A[1, 3]&lt;/code&gt; を参照することと同等になります（ &lt;code&gt;2*1 + 3 = 5&lt;/code&gt; ）。&lt;a href=&quot;#Base.IndexCartesian&quot;&gt; &lt;code&gt;IndexCartesian&lt;/code&gt; &lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="60b78a78e322605d51a66eddac408816c2a8d70e" translate="yes" xml:space="preserve">
          <source>A literal tuple of input types</source>
          <target state="translated">入力型のリテラルタプル</target>
        </trans-unit>
        <trans-unit id="abd07e8344438c1637a18b8d088b307bacd1facc" translate="yes" xml:space="preserve">
          <source>A little further down, you see:</source>
          <target state="translated">もう少し下に行くと</target>
        </trans-unit>
        <trans-unit id="b734fc221d82e75922a1b3bf7185abae1cf63084" translate="yes" xml:space="preserve">
          <source>A local cluster specified with the &lt;code&gt;-p&lt;/code&gt; option as shown above.</source>
          <target state="translated">上記のように &lt;code&gt;-p&lt;/code&gt; オプションで指定されたローカルクラスター。</target>
        </trans-unit>
        <trans-unit id="b83cf191c90b25b0d5f433557856a4746d3a9017" translate="yes" xml:space="preserve">
          <source>A logger controls how log records are filtered and dispatched. When a log record is generated, the logger is the first piece of user configurable code which gets to inspect the record and decide what to do with it.</source>
          <target state="translated">ロガーは、ログ レコードがどのようにフィルタリングされ、ディスパッチされるかを制御します。ログレコードが生成されると、ロガーはユーザーが設定可能なコードの最初の部分であり、レコードを検査して、そのレコードをどうするかを決定します。</target>
        </trans-unit>
        <trans-unit id="042546047eaee48205b79c0943331492c9d777d2" translate="yes" xml:space="preserve">
          <source>A lot of the power and extensibility in Julia comes from a collection of informal interfaces. By extending a few specific methods to work for a custom type, objects of that type not only receive those functionalities, but they are also able to be used in other methods that are written to generically build upon those behaviors.</source>
          <target state="translated">Julia のパワーと拡張性の多くは、非公式なインターフェイスの集合から来ています。いくつかの特定のメソッドを拡張してカスタム型で動作するようにすることで、その型のオブジェクトはそれらの機能を受け取るだけでなく、それらの動作を一般的に構築するために書かれた他のメソッドでも使用することができます。</target>
        </trans-unit>
        <trans-unit id="cdda590f5cebd6037d45dcdc70b7f61af7141059" translate="yes" xml:space="preserve">
          <source>A low-level API which returns the backing &lt;code&gt;AbstractChannel&lt;/code&gt; for an &lt;code&gt;id&lt;/code&gt; returned by &lt;a href=&quot;#Distributed.remoteref_id&quot;&gt;&lt;code&gt;remoteref_id&lt;/code&gt;&lt;/a&gt;. The call is valid only on the node where the backing channel exists.</source>
          <target state="translated">&lt;a href=&quot;#Distributed.remoteref_id&quot;&gt; &lt;code&gt;remoteref_id&lt;/code&gt; &lt;/a&gt;によって返された &lt;code&gt;id&lt;/code&gt; バッキング &lt;code&gt;AbstractChannel&lt;/code&gt; を返す低レベルAPI 。呼び出しは、バッキングチャネルが存在するノードでのみ有効です。</target>
        </trans-unit>
        <trans-unit id="43d1ae4e08959da49eefb761652820ef46f3ee1d" translate="yes" xml:space="preserve">
          <source>A low-level API which, given a &lt;code&gt;IO&lt;/code&gt; connection or a &lt;code&gt;Worker&lt;/code&gt;, returns the &lt;code&gt;pid&lt;/code&gt; of the worker it is connected to. This is useful when writing custom &lt;a href=&quot;../serialization/index#Serialization.serialize&quot;&gt;&lt;code&gt;serialize&lt;/code&gt;&lt;/a&gt; methods for a type, which optimizes the data written out depending on the receiving process id.</source>
          <target state="translated">&lt;code&gt;IO&lt;/code&gt; 接続または &lt;code&gt;Worker&lt;/code&gt; を指定すると、接続先のワーカーの &lt;code&gt;pid&lt;/code&gt; を返す低レベルAPI 。これは、型のカスタム&lt;a href=&quot;../serialization/index#Serialization.serialize&quot;&gt; &lt;code&gt;serialize&lt;/code&gt; &lt;/a&gt;メソッドを記述するときに役立ちます。これは、受信プロセスIDに応じて、書き出されるデータを最適化します。</target>
        </trans-unit>
        <trans-unit id="ba795db29049d0891e980ecd11cc60ac3e97da8e" translate="yes" xml:space="preserve">
          <source>A machine specification is either a string &lt;code&gt;machine_spec&lt;/code&gt; or a tuple - &lt;code&gt;(machine_spec, count)&lt;/code&gt;.</source>
          <target state="translated">マシン仕様は、文字列 &lt;code&gt;machine_spec&lt;/code&gt; またはタプル- &lt;code&gt;(machine_spec, count)&lt;/code&gt; いずれかです。</target>
        </trans-unit>
        <trans-unit id="cd1f8848b8ea19b616dae75f53fa9e5a2b6e59a0" translate="yes" xml:space="preserve">
          <source>A macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute as a floating-point number.</source>
          <target state="translated">式を評価し、結果の値を破棄し、その代わりに実行に要した秒数を浮動小数点数として返すマクロ。</target>
        </trans-unit>
        <trans-unit id="eb3b3a4181a161e900f67d35ae07d34f42540d5c" translate="yes" xml:space="preserve">
          <source>A macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression. Note: the expression is evaluated inside a local function, instead of the current context, in order to eliminate the effects of compilation, however, there still may be some allocations due to JIT compilation. This also makes the results inconsistent with the &lt;code&gt;@time&lt;/code&gt; macros, which do not try to adjust for the effects of compilation.</source>
          <target state="translated">式を評価するマクロ。結果の値を破棄し、代わりに式の評価中に割り当てられた合計バイト数を返します。注：式は、コンパイルの影響を排除するために、現在のコンテキストではなくローカル関数内で評価されますが、JITコンパイルのために割り当てがまだ残っている場合があります。これはまた、コンパイルの影響を調整しようとしない &lt;code&gt;@time&lt;/code&gt; マクロと矛盾する結果になります。</target>
        </trans-unit>
        <trans-unit id="d8419a19f9c35dcf69afb6a224b11b1158512f81" translate="yes" xml:space="preserve">
          <source>A macro to execute an expression, and return the value of the expression, elapsed time, total bytes allocated, garbage collection time, and an object with various memory allocation counters.</source>
          <target state="translated">式を実行し、式の値、経過時間、割り当てられた総バイト数、ガベージコレクション時間、各種メモリ割り当てカウンタを持つオブジェクトを返すマクロです。</target>
        </trans-unit>
        <trans-unit id="ec81ff86af0859e961659a65c9fded1ce9fa3695" translate="yes" xml:space="preserve">
          <source>A macro to execute an expression, printing the time it took to execute, the number of allocations, and the total number of bytes its execution caused to be allocated, before returning the value of the expression.</source>
          <target state="translated">式を実行するためのマクロで、式の値を返す前に、式の実行にかかった時間、割り当て数、およびその実行によって割り当てられた総バイト数を表示します。</target>
        </trans-unit>
        <trans-unit id="f89e0c8d5e0780de8c8e7183eaddeb751b876c48" translate="yes" xml:space="preserve">
          <source>A macro to parallelize a for-loop to run with multiple threads. This spawns &lt;code&gt;nthreads()&lt;/code&gt; number of threads, splits the iteration space amongst them, and iterates in parallel. A barrier is placed at the end of the loop which waits for all the threads to finish execution, and the loop returns.</source>
          <target state="translated">forループを並列化して複数のスレッドで実行するマクロ。これにより、 &lt;code&gt;nthreads()&lt;/code&gt; 個のスレッドが生成され、反復スペースがスレッド間で分割され、並列に反復されます。ループの最後にバリアが配置され、すべてのスレッドが実行を完了するのを待って、ループが戻ります。</target>
        </trans-unit>
        <trans-unit id="4056e98728a50b1503d6d58ab30b4f400279b462" translate="yes" xml:space="preserve">
          <source>A memory address referring to data of type &lt;code&gt;T&lt;/code&gt;. However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; のデータを参照するメモリアドレス。ただし、メモリが実際に有効であること、または指定されたタイプのデータを実際に表していることは保証されません。</target>
        </trans-unit>
        <trans-unit id="95d230cf10af62aec1cf82bb28af648076032cf6" translate="yes" xml:space="preserve">
          <source>A message &lt;code&gt;id&lt;/code&gt; that is a unique, fixed identifier for the &lt;em&gt;source code statement&lt;/em&gt; where the logging macro appears. This identifier is designed to be fairly stable even if the source code of the file changes, as long as the logging statement itself remains the same.</source>
          <target state="translated">ログマクロが表示される&lt;em&gt;ソースコードステートメントの&lt;/em&gt;一意の固定識別子であるメッセージ &lt;code&gt;id&lt;/code&gt; 。この識別子は、ログステートメント自体が同じである限り、ファイルのソースコードが変更されてもかなり安定するように設計されています。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2750f8d62ad398e67307a20fbfa3a8d50bdd8b0e" translate="yes" xml:space="preserve">
          <source>A method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.</source>
          <target state="translated">必要な型シグネチャを持つメソッドが、指定された汎用関数には存在しません。あるいは、一意の最特定メソッドが存在しない。</target>
        </trans-unit>
        <trans-unit id="cb18ac1bbb6e9e8d32b3f5b781aaa128caf3d148" translate="yes" xml:space="preserve">
          <source>A more portable file would need to encode the word size &amp;ndash; 32 bit or 64 bit &amp;ndash; and endianness information in the header. In practice, consider encoding binary data using standard formats like HDF5 (which can be used with memory-mapping).</source>
          <target state="translated">よりポータブルなファイルでは、ワードサイズ（32ビットまたは64ビット）およびエンディアン情報をヘッダーにエンコードする必要があります。実際には、HDF5（メモリマッピングで使用できる）などの標準形式を使用してバイナリデータをエンコードすることを検討してください。</target>
        </trans-unit>
        <trans-unit id="d12bebeb20e9c7a91d427b124d0d24b749dfc69d" translate="yes" xml:space="preserve">
          <source>A natural extension to the iterated dispatch above is to add a layer to method selection that allows to dispatch on sets of types which are independent from the sets defined by the type hierarchy. We could construct such a set by writing out a &lt;code&gt;Union&lt;/code&gt; of the types in question, but then this set would not be extensible as &lt;code&gt;Union&lt;/code&gt;-types cannot be altered after creation. However, such an extensible set can be programmed with a design pattern often referred to as a &lt;a href=&quot;https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633&quot;&gt;&quot;Holy-trait&quot;&lt;/a&gt;.</source>
          <target state="translated">上記の反復ディスパッチの自然な拡張は、タイプ階層で定義されたセットから独立したタイプのセットでディスパッチできるようにするメソッド選択にレイヤーを追加することです。私たちは、書き出すことにより、このようなセットを構築することができ &lt;code&gt;Union&lt;/code&gt; 問題の種類のを、しかし、のように、このセットは拡張可能ではないでしょう &lt;code&gt;Union&lt;/code&gt; -typesは、作成後に変更することはできません。ただし、このような拡張可能なセットは、&lt;a href=&quot;https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633&quot;&gt;「聖特性」&lt;/a&gt;と呼ばれることが多い設計パターンでプログラムできます。</target>
        </trans-unit>
        <trans-unit id="1df2e0e7411bff84daf33858b6c998ccc3af6df2" translate="yes" xml:space="preserve">
          <source>A negative value returned from &lt;code&gt;f&lt;/code&gt; stops the tree walk. A positive value means that the entry will be skipped if &lt;code&gt;post&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; から返される負の値は、ツリーのウォークを停止します。正の値は、 &lt;code&gt;post&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; の場合にエントリがスキップされることを意味します。</target>
        </trans-unit>
        <trans-unit id="6eadc295d0ba924158738dd40574dc88fa55d3a0" translate="yes" xml:space="preserve">
          <source>A new local scope is introduced by most code blocks (see above &lt;a href=&quot;#man-scope-table-1&quot;&gt;table&lt;/a&gt; for a complete list). A local scope inherits all the variables from a parent local scope, both for reading and writing. Unlike global scopes, local scopes are not namespaces, thus variables in an inner scope cannot be retrieved from the parent scope through some sort of qualified access.</source>
          <target state="translated">新しいローカルスコープは、ほとんどのコードブロックによって導入されています（完全なリストについては、上記の&lt;a href=&quot;#man-scope-table-1&quot;&gt;表&lt;/a&gt;を参照してください）。ローカルスコープは、読み取りと書き込みの両方で、親ローカルスコープからすべての変数を継承します。グローバルスコープとは異なり、ローカルスコープは名前空間ではないため、内部スコープの変数は、何らかの修飾されたアクセスを通じて親スコープから取得できません。</target>
        </trans-unit>
        <trans-unit id="d714251afe7092bca2f3b7a144d31cf965234924" translate="yes" xml:space="preserve">
          <source>A not-a-number value of type &lt;a href=&quot;#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt;型の非数値。</target>
        </trans-unit>
        <trans-unit id="2193a2ca1ad4d9733b4b0300e7ecba88f3943810" translate="yes" xml:space="preserve">
          <source>A not-a-number value of type &lt;a href=&quot;#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;型の非数値。</target>
        </trans-unit>
        <trans-unit id="81968f8bb93ba2bc693aa91379d45e0967799536" translate="yes" xml:space="preserve">
          <source>A not-a-number value of type &lt;a href=&quot;#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;型の非数値。</target>
        </trans-unit>
        <trans-unit id="bf0553a64a83d6adf63b024a57032beb1f6f23e7" translate="yes" xml:space="preserve">
          <source>A one-dimensional &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt;&lt;code&gt;SharedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1次元の&lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt; &lt;code&gt;SharedArray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="763a944bd46fad5722e83f3b2781f484dab35fa0" translate="yes" xml:space="preserve">
          <source>A package can only be loaded once per Julia session. If you have run &lt;code&gt;import Example&lt;/code&gt; in the current Julia session, you will have to restart Julia and rerun &lt;code&gt;activate tutorial&lt;/code&gt; in the Pkg REPL. &lt;a href=&quot;https://github.com/timholy/Revise.jl/&quot;&gt;Revise.jl&lt;/a&gt; can make this process significantly more pleasant, but setting it up is beyond the scope of this guide.</source>
          <target state="translated">パッケージは、Juliaセッションごとに1回だけロードできます。現在のJuliaセッションで &lt;code&gt;import Example&lt;/code&gt; を実行した場合は、Juliaを再 &lt;code&gt;activate tutorial&lt;/code&gt; して、Pkg REPLのアクティブ化チュートリアルを再実行する必要があります。&lt;a href=&quot;https://github.com/timholy/Revise.jl/&quot;&gt;Revise.jl&lt;/a&gt;はこのプロセスを大幅に快適にすることができますが、設定はこのガイドの範囲を超えています。</target>
        </trans-unit>
        <trans-unit id="d8ea4ea99a9ccce09db2edcbcf21139124c0c674" translate="yes" xml:space="preserve">
          <source>A package with a project file but no explicit UUID can only be depended on by packages without project files since dummy UUIDs assigned to these packages are strictly internal.</source>
          <target state="translated">プロジェクトファイルを持っていて明示的な UUID を持たないパッケージは、 プロジェクトファイルを持たないパッケージにのみ依存することができます。</target>
        </trans-unit>
        <trans-unit id="74b114825488547a02a0f9d88544ac2cd2767c9b" translate="yes" xml:space="preserve">
          <source>A package with a project file cannot depend on one without a project file since packages with project files can only load packages in &lt;code&gt;graph&lt;/code&gt; and packages without project files do not appear in &lt;code&gt;graph&lt;/code&gt;.</source>
          <target state="translated">プロジェクトファイルを持つパッケージのみでパッケージを読み込むことができるので、プロジェクトファイルとパッケージは、プロジェクトファイルなしで1に依存することはできません &lt;code&gt;graph&lt;/code&gt; プロジェクトファイルなしとパッケージに表示されません &lt;code&gt;graph&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd75d89f707123dd68c78d210bdb2e047dca58d2" translate="yes" xml:space="preserve">
          <source>A package without a project file can depend on any top-level dependency, and since every package in a package directory is available at the top-level, it can import all packages in the environment.</source>
          <target state="translated">プロジェクトファイルを持たないパッケージは、トップレベルの依存関係に依存することができ、パッケージディレクトリ内のすべてのパッケージがトップレベルで利用可能なので、環境内のすべてのパッケージをインポートすることができます。</target>
        </trans-unit>
        <trans-unit id="b56c2cd76cad76c5809c4c87d958f6925a4c437f" translate="yes" xml:space="preserve">
          <source>A paragraph is a block of plain text, possibly containing any number of inline elements defined in the &lt;a href=&quot;#Inline-elements-1&quot;&gt;Inline elements&lt;/a&gt; section above, with one or more blank lines above and below it.</source>
          <target state="translated">段落はプレーンテキストのブロックであり、おそらく上記の&lt;a href=&quot;#Inline-elements-1&quot;&gt;インライン要素&lt;/a&gt;セクションで定義されたインライン要素をいくつでも含み、その上下に1行以上の空白行があります。</target>
        </trans-unit>
        <trans-unit id="83f9c9755a3a3b90210c6624d61e0b0a1f59e0fa" translate="yes" xml:space="preserve">
          <source>A particularly useful case of a &lt;code&gt;Union&lt;/code&gt; type is &lt;code&gt;Union{T, Nothing}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; can be any type and &lt;a href=&quot;../../base/base/index#Core.Nothing&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt; is the singleton type whose only instance is the object &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;. This pattern is the Julia equivalent of &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt;&lt;code&gt;Nullable&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;&lt;/a&gt; types in other languages. Declaring a function argument or a field as &lt;code&gt;Union{T, Nothing}&lt;/code&gt; allows setting it either to a value of type &lt;code&gt;T&lt;/code&gt;, or to &lt;code&gt;nothing&lt;/code&gt; to indicate that there is no value. See &lt;a href=&quot;../faq/index#faq-nothing-1&quot;&gt;this FAQ entry&lt;/a&gt; for more information.</source>
          <target state="translated">特に有用な場合 &lt;code&gt;Union&lt;/code&gt; タイプは &lt;code&gt;Union{T, Nothing}&lt;/code&gt; 、 &lt;code&gt;T&lt;/code&gt; は任意のタイプとすることができ、&lt;a href=&quot;../../base/base/index#Core.Nothing&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt;その唯一のインスタンスオブジェクトではないシングルトンタイプである&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;。このパターンは、他の言語の&lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt; &lt;code&gt;Nullable&lt;/code&gt; 、 &lt;code&gt;Option&lt;/code&gt; 、または &lt;code&gt;Maybe&lt;/code&gt; &lt;/a&gt;型のジュリア版です。関数の引数またはフィールドを &lt;code&gt;Union{T, Nothing}&lt;/code&gt; として宣言すると、タイプ &lt;code&gt;T&lt;/code&gt; の値に設定することも、値が &lt;code&gt;nothing&lt;/code&gt; ことを示すために何も設定しないこともできます。詳細については、&lt;a href=&quot;../faq/index#faq-nothing-1&quot;&gt;このFAQエントリ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c0f8b8ac2cfde0d10f30bb94c874c9e1f1def48e" translate="yes" xml:space="preserve">
          <source>A pointer to the data block</source>
          <target state="translated">データブロックへのポインタ</target>
        </trans-unit>
        <trans-unit id="6b9ee627484ba20558d37b2c66115f6d170670ea" translate="yes" xml:space="preserve">
          <source>A positive &lt;code&gt;Int&lt;/code&gt; that determines how much time the max-sum subroutine &lt;code&gt;MaxSum.maxsum()&lt;/code&gt; of the package dependency resolver will devote to attempting satisfying constraints before giving up: this value is by default &lt;code&gt;1&lt;/code&gt;, and larger values correspond to larger amounts of time.</source>
          <target state="translated">max-sumサブルーチンの時間を決定する正の &lt;code&gt;Int&lt;/code&gt; &lt;code&gt;MaxSum.maxsum()&lt;/code&gt; パッケージの依存関係リゾルバー MaxSum.maxsum（）が、あきらめる前に制約を満たすために費やす：この値はデフォルトで &lt;code&gt;1&lt;/code&gt; であり、値が大きい長くなります。</target>
        </trans-unit>
        <trans-unit id="30e83519d088c9c533da7a48902b81020f8078b5" translate="yes" xml:space="preserve">
          <source>A pre-computed &lt;code&gt;mean&lt;/code&gt; may be provided.</source>
          <target state="translated">事前に計算された &lt;code&gt;mean&lt;/code&gt; が提供れる場合があります。</target>
        </trans-unit>
        <trans-unit id="e2cb212a617bce583ce37ac7b92063a39d21aed2" translate="yes" xml:space="preserve">
          <source>A prefix &lt;code&gt;&amp;amp;&lt;/code&gt; is used on an argument to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to indicate that a pointer to a scalar argument should be passed instead of the scalar value itself (required for all Fortran function arguments, as noted above). The following example computes a dot product using a BLAS function.</source>
          <target state="translated">接頭辞 &lt;code&gt;&amp;amp;&lt;/code&gt; は、&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; の&lt;/a&gt;引数で使用され、スカラー値自体ではなく、スカラー引数へのポインターが渡されることを示します（上記のように、すべてのFortran関数引数に必要です）。次の例では、BLAS関数を使用して内積を計算します。</target>
        </trans-unit>
        <trans-unit id="1649f26efb9cb12037079805dd99e4da0fb754f9" translate="yes" xml:space="preserve">
          <source>A primitive type is a concrete type whose data consists of plain old bits. Classic examples of primitive types are integers and floating-point values. Unlike most languages, Julia lets you declare your own primitive types, rather than providing only a fixed set of built-in ones. In fact, the standard primitive types are all defined in the language itself:</source>
          <target state="translated">原始型とは、データが古いビットで構成された具体的な型のことです。原始型の古典的な例としては、整数と浮動小数点値があります。多くの言語とは異なり、Juliaでは組み込み型の固定されたセットだけを提供するのではなく、独自の原始型を宣言することができます。実際、標準的な原始型はすべてこの言語で定義されています。</target>
        </trans-unit>
        <trans-unit id="f4a9df194804c22a7662de8018248499081325a7" translate="yes" xml:space="preserve">
          <source>A project environment is determined by a directory containing a project file called &lt;code&gt;Project.toml&lt;/code&gt;, and optionally a manifest file called &lt;code&gt;Manifest.toml&lt;/code&gt;. These files may also be called &lt;code&gt;JuliaProject.toml&lt;/code&gt; and &lt;code&gt;JuliaManifest.toml&lt;/code&gt;, in which case &lt;code&gt;Project.toml&lt;/code&gt; and &lt;code&gt;Manifest.toml&lt;/code&gt; are ignored. This allows for coexistence with other tools that might consider files called &lt;code&gt;Project.toml&lt;/code&gt; and &lt;code&gt;Manifest.toml&lt;/code&gt; significant. For pure Julia projects, however, the names &lt;code&gt;Project.toml&lt;/code&gt; and &lt;code&gt;Manifest.toml&lt;/code&gt; are preferred.</source>
          <target state="translated">プロジェクト環境は、 &lt;code&gt;Project.toml&lt;/code&gt; というプロジェクトファイルと、オプションで &lt;code&gt;Manifest.toml&lt;/code&gt; というマニフェストファイルを含むディレクトリによって決定されます。これらのファイルは、 &lt;code&gt;JuliaProject.toml&lt;/code&gt; および &lt;code&gt;JuliaManifest.toml&lt;/code&gt; と呼ばれることもあります。この場合、 &lt;code&gt;Project.toml&lt;/code&gt; および &lt;code&gt;Manifest.toml&lt;/code&gt; は無視されます。これにより、 &lt;code&gt;Project.toml&lt;/code&gt; および &lt;code&gt;Manifest.toml&lt;/code&gt; というファイルを重要であると見なす可能性のある他のツールとの共存が可能になります。ただし、純粋なJuliaプロジェクトの場合は、 &lt;code&gt;Project.toml&lt;/code&gt; および &lt;code&gt;Manifest.toml&lt;/code&gt; という名前が推奨されます。</target>
        </trans-unit>
        <trans-unit id="69645bb907ec77da55ad793cb959dcc26c6879c9" translate="yes" xml:space="preserve">
          <source>A pure function can only depend on immutable information. This also means a &lt;code&gt;@pure&lt;/code&gt; function cannot use any global mutable state, including generic functions. Calls to generic functions depend on method tables which are mutable global state. Use with caution, incorrect &lt;code&gt;@pure&lt;/code&gt; annotation of a function may introduce hard to identify bugs. Double check for calls to generic functions.</source>
          <target state="translated">純関数は不変情報にのみ依存できます。これは、 &lt;code&gt;@pure&lt;/code&gt; 関数が、汎用関数を含むグローバルな可変状態を使用できないことも意味します。ジェネリック関数の呼び出しは、変更可能なグローバル状態であるメソッドテーブルに依存します。関数の不適切な &lt;code&gt;@pure&lt;/code&gt; アノテーションを使用すると、バグの特定が困難になる可能性があるため、注意して使用してください。ジェネリック関数の呼び出しを再確認してください。</target>
        </trans-unit>
        <trans-unit id="f6f0f859ed475e8984520389a632de12d979f1bf" translate="yes" xml:space="preserve">
          <source>A range &lt;code&gt;r&lt;/code&gt; where &lt;code&gt;r[i]&lt;/code&gt; produces values of type &lt;code&gt;T&lt;/code&gt; (in the second form, &lt;code&gt;T&lt;/code&gt; is deduced automatically), parameterized by a &lt;code&gt;ref&lt;/code&gt;erence value, a &lt;code&gt;step&lt;/code&gt;, and the &lt;code&gt;len&lt;/code&gt;gth. By default &lt;code&gt;ref&lt;/code&gt; is the starting value &lt;code&gt;r[1]&lt;/code&gt;, but alternatively you can supply it as the value of &lt;code&gt;r[offset]&lt;/code&gt; for some other index &lt;code&gt;1 &amp;lt;= offset &amp;lt;= len&lt;/code&gt;. In conjunction with &lt;code&gt;TwicePrecision&lt;/code&gt; this can be used to implement ranges that are free of roundoff error.</source>
          <target state="translated">範囲 &lt;code&gt;r&lt;/code&gt; &lt;code&gt;r[i]&lt;/code&gt; 式の値が生成さ &lt;code&gt;T&lt;/code&gt; （第2形態において、 &lt;code&gt;T&lt;/code&gt; は、によってパラメータ自動的に推定される）、 &lt;code&gt;ref&lt;/code&gt; レンス値、 &lt;code&gt;step&lt;/code&gt; 、及び &lt;code&gt;len&lt;/code&gt; GTHを。デフォルトでは、 &lt;code&gt;ref&lt;/code&gt; は開始値 &lt;code&gt;r[1]&lt;/code&gt; ですが、別の方法として、他のインデックス &lt;code&gt;1 &amp;lt;= offset &amp;lt;= len&lt;/code&gt; の &lt;code&gt;r[offset]&lt;/code&gt; 値として指定することもできます。 &lt;code&gt;TwicePrecision&lt;/code&gt; と組み合わせて使用すると、丸め誤差のない範囲を実装できます。</target>
        </trans-unit>
        <trans-unit id="c9b444cdaa1ec0c32645903217d293c523a2b655" translate="yes" xml:space="preserve">
          <source>A range parameterized by a &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;, filled with elements spaced by &lt;code&gt;1&lt;/code&gt; from &lt;code&gt;start&lt;/code&gt; until &lt;code&gt;stop&lt;/code&gt; is exceeded. The syntax &lt;code&gt;a:b&lt;/code&gt; with &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; both &lt;code&gt;Integer&lt;/code&gt;s creates a &lt;code&gt;UnitRange&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; の &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; でパラメーター化された範囲で、 &lt;code&gt;start&lt;/code&gt; から &lt;code&gt;stop&lt;/code&gt; を超えるまで &lt;code&gt;1&lt;/code&gt; の間隔を空けた要素で埋められます。構文 &lt;code&gt;a:b&lt;/code&gt; と &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; の両方の &lt;code&gt;Integer&lt;/code&gt; sは、 &lt;code&gt;UnitRange&lt;/code&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="f6f1f96e933c37623ad62bee872115dc2545ea76" translate="yes" xml:space="preserve">
          <source>A range with &lt;code&gt;len&lt;/code&gt; linearly spaced elements between its &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. The size of the spacing is controlled by &lt;code&gt;len&lt;/code&gt;, which must be an &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; の間に &lt;code&gt;len&lt;/code&gt; の線形間隔の要素がある範囲。間隔のサイズは &lt;code&gt;len&lt;/code&gt; によって制御されます。これは &lt;code&gt;Int&lt;/code&gt; でなければなりません。</target>
        </trans-unit>
        <trans-unit id="706e2d69e0228bb191f57826b2fe6dee1a0d2fd7" translate="yes" xml:space="preserve">
          <source>A related strategy exploits &lt;code&gt;promote&lt;/code&gt; to bring &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to a common type:</source>
          <target state="translated">関連する戦略のエクスプロイトは、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; を共通の型にすることを &lt;code&gt;promote&lt;/code&gt; します。</target>
        </trans-unit>
        <trans-unit id="1aacdb7c22de01fd91d580f3ce3c32f6aebf1795" translate="yes" xml:space="preserve">
          <source>A remote call returns a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; to its result. Remote calls return immediately; the process that made the call proceeds to its next operation while the remote call happens somewhere else. You can wait for a remote call to finish by calling &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the returned &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;, and you can obtain the full value of the result using &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">リモート呼び出しは、その結果に&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;を返します。リモート呼び出しはすぐに戻ります。呼び出しを行ったプロセスは次の操作に進みますが、リモート呼び出しは別の場所で行われます。返された&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;で&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;を呼び出すことにより、リモート呼び出しが完了するのを待つことができ、 &lt;code&gt;fetch&lt;/code&gt; を使用して結果の完全な値を取得できます。</target>
        </trans-unit>
        <trans-unit id="c718be7a47524e3c8c121a2838b8196bfca32d81" translate="yes" xml:space="preserve">
          <source>A return type can also be specified in the function declaration using the &lt;code&gt;::&lt;/code&gt; operator. This converts the return value to the specified type.</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; 演算子を使用して、関数宣言で戻り値の型を指定することもできます。これにより、戻り値が指定された型に変換されます。</target>
        </trans-unit>
        <trans-unit id="487eaf5a6ef062e68fb2638581518230a5bbf1cb" translate="yes" xml:space="preserve">
          <source>A return type of &lt;code&gt;Union{}&lt;/code&gt; means the function will not return i.e. C++11 &lt;code&gt;[[noreturn]]&lt;/code&gt; or C11 &lt;code&gt;_Noreturn&lt;/code&gt; (e.g. &lt;code&gt;jl_throw&lt;/code&gt; or &lt;code&gt;longjmp&lt;/code&gt;). Do not use this for functions that return no value (&lt;code&gt;void&lt;/code&gt;) but do return, use &lt;code&gt;Cvoid&lt;/code&gt; instead.</source>
          <target state="translated">戻り型の &lt;code&gt;Union{}&lt;/code&gt; は、関数がC ++ 11 &lt;code&gt;[[noreturn]]&lt;/code&gt; またはC11 &lt;code&gt;_Noreturn&lt;/code&gt; （例： &lt;code&gt;jl_throw&lt;/code&gt; または &lt;code&gt;longjmp&lt;/code&gt; ）を返さないことを意味します。値を返さない（ &lt;code&gt;void&lt;/code&gt; ）関数ではこれを使用せずに戻ります。代わりに &lt;code&gt;Cvoid&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="3d36c3c7861e0bdac1682c4b5f59e170ca861f5e" translate="yes" xml:space="preserve">
          <source>A rich language of types for constructing and describing objects, that can also optionally be used to make type declarations</source>
          <target state="translated">オブジェクトを構築・記述するための豊富な型の言語で、オプションで型宣言を行うこともできます。</target>
        </trans-unit>
        <trans-unit id="72264caef899e2b19ef0b87abaee4b3d2fbc99bb" translate="yes" xml:space="preserve">
          <source>A sampling profiler does not provide complete line-by-line coverage, because the backtraces occur at intervals (by default, 1 ms on Unix systems and 10 ms on Windows, although the actual scheduling is subject to operating system load). Moreover, as discussed further below, because samples are collected at a sparse subset of all execution points, the data collected by a sampling profiler is subject to statistical noise.</source>
          <target state="translated">サンプリング・プロファイラは、バックトレースが間隔をおいて行われるため、ライン・バイ・ラインの完全なカバレッジを提供することはできません(デフォルトでは、Unix システムでは 1 ms、Windows では 10 ms となっていますが、実際のスケジューリングはオペレーティング・システムの負荷に左右されます)。さらに、後述するように、サンプルはすべての実行ポイントの疎なサブセットで収集されるため、サンプリング・プロファイラによって収集されたデータは統計的なノイズの影響を受けます。</target>
        </trans-unit>
        <trans-unit id="1c43fdae247597897ddce375dd4bc720d67a5129" translate="yes" xml:space="preserve">
          <source>A scalar index. By default this includes:</source>
          <target state="translated">スカラーインデックス。デフォルトではこれが含まれます。</target>
        </trans-unit>
        <trans-unit id="b55191124d22706cdd504c425bc25474c70cfe4b" translate="yes" xml:space="preserve">
          <source>A shortened git object identifier, which can be used to identify a git object when it is unique, consisting of the initial &lt;code&gt;len&lt;/code&gt; hexadecimal digits of &lt;code&gt;hash&lt;/code&gt; (the remaining digits are ignored).</source>
          <target state="translated">&lt;code&gt;hash&lt;/code&gt; 最初の &lt;code&gt;len&lt;/code&gt; 16進数字で構成される、一意のgitオブジェクトを識別するために使用できる短縮されたgitオブジェクト識別子（残りの数字は無視されます）。</target>
        </trans-unit>
        <trans-unit id="077f5f2c61a2286cb303f8e0203873661f4fb602" translate="yes" xml:space="preserve">
          <source>A simple TCP example</source>
          <target state="translated">簡単なTCPの例</target>
        </trans-unit>
        <trans-unit id="a9e3389d4f0df30d0d029c511221cff89bde7e83" translate="yes" xml:space="preserve">
          <source>A simple example is an iterable sequence of square numbers with a defined length:</source>
          <target state="translated">簡単な例としては、定義された長さの正方数の反復可能な列があります。</target>
        </trans-unit>
        <trans-unit id="4f74541df487be036520d1a453fae53d9f7cabea" translate="yes" xml:space="preserve">
          <source>A simple use of this script is from the command line. Assuming that &lt;code&gt;julia-config.jl&lt;/code&gt; is located in &lt;code&gt;/usr/local/julia/share/julia&lt;/code&gt;, it can be invoked on the command line directly and takes any combination of 3 flags:</source>
          <target state="translated">このスクリプトの簡単な使い方は、コマンドラインからです。 &lt;code&gt;julia-config.jl&lt;/code&gt; が &lt;code&gt;/usr/local/julia/share/julia&lt;/code&gt; にあると仮定すると、コマンドラインから直接呼び出すことができ、3つのフラグの任意の組み合わせを取ります。</target>
        </trans-unit>
        <trans-unit id="fa70eb6573e06a90b5cea95755e1d5d87242bd36" translate="yes" xml:space="preserve">
          <source>A singleton of this type provides a hash table interface to environment variables.</source>
          <target state="translated">この型のシングルトンは、環境変数へのハッシュ・テーブル・インターフェースを提供します。</target>
        </trans-unit>
        <trans-unit id="742dc31813ae03b1c856e52c5abe6409c9fab8c0" translate="yes" xml:space="preserve">
          <source>A special syntax exists for broadcasting: &lt;code&gt;f.(args...)&lt;/code&gt; is equivalent to &lt;code&gt;broadcast(f, args...)&lt;/code&gt;, and nested &lt;code&gt;f.(g.(args...))&lt;/code&gt; calls are fused into a single broadcast loop.</source>
          <target state="translated">ブロードキャストには特別な構文が存在します &lt;code&gt;f.(args...)&lt;/code&gt; は &lt;code&gt;broadcast(f, args...)&lt;/code&gt; args ...）と同等であり、ネストされた &lt;code&gt;f.(g.(args...))&lt;/code&gt; 呼び出しは単一のブロードキャストループに融合されます。</target>
        </trans-unit>
        <trans-unit id="c0fbd3b8f6db43e593e0be31ea0f379f85f1e4ca" translate="yes" xml:space="preserve">
          <source>A stack of &quot;depot&quot; locations where the package manager, as well as Julia's code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. By default it includes:</source>
          <target state="translated">パッケージマネージャと Julia のコード読み込み機構が、パッケージレジストリ、インストール済みパッケージ、名前付き環境、レポクローン、キャッシュされたコンパイル済みパッケージイメージ、設定ファイルを探す「depot」の場所のスタックです。デフォルトでは以下のものが含まれています。</target>
        </trans-unit>
        <trans-unit id="83cbeda4e6c8af61ba213e9c4a7b5e87e7da5098" translate="yes" xml:space="preserve">
          <source>A strided array is a subtype of &lt;code&gt;AbstractArray&lt;/code&gt; whose entries are stored in memory with fixed strides. Provided the element type of the array is compatible with BLAS, a strided array can utilize BLAS and LAPACK routines for more efficient linear algebra routines. A typical example of a user-defined strided array is one that wraps a standard &lt;code&gt;Array&lt;/code&gt; with additional structure.</source>
          <target state="translated">ストライド配列は &lt;code&gt;AbstractArray&lt;/code&gt; のサブタイプであり、そのエントリは固定ストライドでメモリに格納されます。配列の要素タイプがBLASと互換性がある場合、ストライド配列はBLASおよびLAPACKルーチンを利用して、より効率的な線形代数ルーチンを実現できます。ユーザー定義のストライド配列の典型的な例は、標準の &lt;code&gt;Array&lt;/code&gt; を追加の構造でラップしたものです。</target>
        </trans-unit>
        <trans-unit id="1b1c35701525a8cf6b4348121d4ed856a675b22b" translate="yes" xml:space="preserve">
          <source>A string containing the build triple.</source>
          <target state="translated">ビルドトリプルを含む文字列。</target>
        </trans-unit>
        <trans-unit id="8f5d09501ae972f4c8432e623c2b5b34015798e0" translate="yes" xml:space="preserve">
          <source>A string containing the full path to the directory containing the &lt;code&gt;julia&lt;/code&gt; executable.</source>
          <target state="translated">&lt;code&gt;julia&lt;/code&gt; 実行可能ファイルを含むディレクトリへのフルパスを含む文字列。</target>
        </trans-unit>
        <trans-unit id="bfd4ca3ee2c70681a147013214927fa8b03d2dc0" translate="yes" xml:space="preserve">
          <source>A string containing the script name passed to Julia from the command line. Note that the script name remains unchanged from within included files. Alternatively see &lt;a href=&quot;../file/index#Base.@__FILE__&quot;&gt;&lt;code&gt;@__FILE__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">コマンドラインからJuliaに渡されたスクリプト名を含む文字列。インクルードされたファイル内からスクリプト名は変更されないことに注意してください。または、&lt;a href=&quot;../file/index#Base.@__FILE__&quot;&gt; &lt;code&gt;@__FILE__&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0797e0a3c7343edc1c5ee87f67440aa1e7a16452" translate="yes" xml:space="preserve">
          <source>A string giving the literal bit representation of a number.</source>
          <target state="translated">数値のリテラルビット表現を与える文字列。</target>
        </trans-unit>
        <trans-unit id="99fade2fd2012046282e2903a7ae0c96b265f5e9" translate="yes" xml:space="preserve">
          <source>A struct can also declare an abstract super type via &lt;code&gt;&amp;lt;:&lt;/code&gt; syntax:</source>
          <target state="translated">構造体は、 &lt;code&gt;&amp;lt;:&lt;/code&gt; 構文を介して抽象スーパータイプを宣言することもできます。</target>
        </trans-unit>
        <trans-unit id="d8c381a5b7c7400aeadc10868e02841473506c28" translate="yes" xml:space="preserve">
          <source>A successful invocation indicates that the request has been accepted for execution on the remote node.</source>
          <target state="translated">呼び出しが成功すると、リモートノード上での実行のためにリクエストが受け入れられたことを示します。</target>
        </trans-unit>
        <trans-unit id="62cc4725cdcde932b6f43e77c33829a7243aa044" translate="yes" xml:space="preserve">
          <source>A symbol in the current scope is not defined.</source>
          <target state="translated">現在のスコープ内のシンボルが定義されていません。</target>
        </trans-unit>
        <trans-unit id="c20565dfe8ced2501d963ee2eb2804c69c838706" translate="yes" xml:space="preserve">
          <source>A symbol representing the architecture of the build configuration.</source>
          <target state="translated">ビルド構成のアーキテクチャを表すシンボル。</target>
        </trans-unit>
        <trans-unit id="1630c742579320a925646310ce24a54343db4200" translate="yes" xml:space="preserve">
          <source>A symbol representing the name of the operating system, as returned by &lt;code&gt;uname&lt;/code&gt; of the build configuration.</source>
          <target state="translated">ビルド構成の &lt;code&gt;uname&lt;/code&gt; によって返される、オペレーティングシステムの名前を表すシンボル。</target>
        </trans-unit>
        <trans-unit id="55d0851ad9930d2d2a1ce1a82a1321a9316a97a9" translate="yes" xml:space="preserve">
          <source>A symbol representing the operator associativity can also be found by calling the built-in function &lt;code&gt;Base.operator_associativity&lt;/code&gt;:</source>
          <target state="translated">組み込み関数 &lt;code&gt;Base.operator_associativity&lt;/code&gt; を呼び出すことによって、演算子の関連付けを表すシンボルを見つけることもできます。</target>
        </trans-unit>
        <trans-unit id="31ca630f0d77e0cda110e0b86407ebc755d3a20f" translate="yes" xml:space="preserve">
          <source>A system call failed with an error code (in the &lt;code&gt;errno&lt;/code&gt; global variable).</source>
          <target state="translated">システムコールがエラーコード（ &lt;code&gt;errno&lt;/code&gt; グローバル変数内）で失敗しました。</target>
        </trans-unit>
        <trans-unit id="9449233a2f73e499e6bb945337a8062b4696d604" translate="yes" xml:space="preserve">
          <source>A task created explicitly by calling &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; is initially not known to the scheduler. This allows you to manage tasks manually using &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; if you wish. However, when such a task waits for an event, it still gets restarted automatically when the event happens, as you would expect. It is also possible to make the scheduler run a task whenever it can, without necessarily waiting for any events. This is done by calling &lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt;, or using the &lt;a href=&quot;../../base/parallel/index#Base.@async&quot;&gt;&lt;code&gt;@async&lt;/code&gt;&lt;/a&gt; macro (see &lt;a href=&quot;../parallel-computing/index#Parallel-Computing-1&quot;&gt;Parallel Computing&lt;/a&gt; for more details).</source>
          <target state="translated">&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;を呼び出すことによって明示的に作成されたタスクは、最初はスケジューラに認識されていません。これにより、必要に応じて&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;を使用してタスクを手動で管理できます。ただし、そのようなタスクがイベントを待機している場合でも、期待どおりに、イベントが発生すると自動的に再起動されます。また、必ずしもイベントを待つことなく、スケジューラーがタスクを実行できるようにすることも可能です。これは、呼び出して実行され&lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt;、または使用して&lt;a href=&quot;../../base/parallel/index#Base.@async&quot;&gt; &lt;code&gt;@async&lt;/code&gt; &lt;/a&gt;（参照マクロを&lt;a href=&quot;../parallel-computing/index#Parallel-Computing-1&quot;&gt;並列コンピューティング&lt;/a&gt;の詳細については）。</target>
        </trans-unit>
        <trans-unit id="98741cc98ee16d9ab3a998adf5789df91d6bd8b6" translate="yes" xml:space="preserve">
          <source>A thread-safe version of &lt;a href=&quot;#Base.Condition&quot;&gt;&lt;code&gt;Base.Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.Condition&quot;&gt; &lt;code&gt;Base.Condition&lt;/code&gt; の&lt;/a&gt;スレッドセーフバージョン。</target>
        </trans-unit>
        <trans-unit id="742c13a103d2480e968af031241292dc13ffa910" translate="yes" xml:space="preserve">
          <source>A tuple of input types. The input types must be written as a literal tuple, not a tuple-valued variable or expression.</source>
          <target state="translated">入力型のタプル。入力型は、タプル値を持つ変数や式ではなく、リテラルタプルとして書かれなければなりません。</target>
        </trans-unit>
        <trans-unit id="02ac3688690ac8c45320416c8e40058c167fb818" translate="yes" xml:space="preserve">
          <source>A two-dimensional &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt;&lt;code&gt;SharedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">2次元の&lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt; &lt;code&gt;SharedArray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2cae43ab9952736150051924872c889307cc7b33" translate="yes" xml:space="preserve">
          <source>A type assertion failure, or calling an intrinsic function with an incorrect argument type.</source>
          <target state="translated">型アサーションの失敗、または正しくない引数型で本質的な関数を呼び出した場合。</target>
        </trans-unit>
        <trans-unit id="6c65420499bd2ab6c38a5269a2949906fd25fe5c" translate="yes" xml:space="preserve">
          <source>A type representing a standard internet data format. &quot;MIME&quot; stands for &quot;Multipurpose Internet Mail Extensions&quot;, since the standard was originally used to describe multimedia attachments to email messages.</source>
          <target state="translated">インターネットの標準的なデータ形式を表すタイプ。&quot;MIME&quot; は &quot;Multipurpose Internet Mail Extensions&quot; の略で、元々は電子メールメッセージにマルチメディアの添付ファイルを記述するために使用されていた規格です。</target>
        </trans-unit>
        <trans-unit id="fa12877ef329dc75c9fda25bdec3c035fe723779" translate="yes" xml:space="preserve">
          <source>A type representing compound expressions in parsed julia code (ASTs). Each expression consists of a &lt;code&gt;head&lt;/code&gt;&lt;code&gt;Symbol&lt;/code&gt; identifying which kind of expression it is (e.g. a call, for loop, conditional statement, etc.), and subexpressions (e.g. the arguments of a call). The subexpressions are stored in a &lt;code&gt;Vector{Any}&lt;/code&gt; field called &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">解析されたジュリアコード（AST）の複合式を表す型。各式は、それがどのような種類の式であるかを示す &lt;code&gt;head&lt;/code&gt; &lt;code&gt;Symbol&lt;/code&gt; （たとえば、呼び出し、forループ、条件ステートメントなど）と部分式（たとえば、呼び出しの引数）で構成されます。部分式は &lt;code&gt;args&lt;/code&gt; と呼ばれる &lt;code&gt;Vector{Any}&lt;/code&gt; フィールドに格納されます。</target>
        </trans-unit>
        <trans-unit id="12166025929849592cdb9b904ad437a429f4da9f" translate="yes" xml:space="preserve">
          <source>A type union is a special abstract type which includes as objects all instances of any of its argument types, constructed using the special &lt;a href=&quot;../../base/base/index#Core.Union&quot;&gt;&lt;code&gt;Union&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">型共用体は、特殊な&lt;a href=&quot;../../base/base/index#Core.Union&quot;&gt; &lt;code&gt;Union&lt;/code&gt; &lt;/a&gt;キーワードを使用して構築された、その引数型のすべてのインスタンスをオブジェクトとして含む特殊な抽象型です。</target>
        </trans-unit>
        <trans-unit id="c659722eaa7a1851dcf2b15fa8b1da6d2c52b7b1" translate="yes" xml:space="preserve">
          <source>A type union is an abstract type which includes all instances of any of its argument types. The empty union &lt;a href=&quot;#Union%7B%7D&quot;&gt;&lt;code&gt;Union{}&lt;/code&gt;&lt;/a&gt; is the bottom type of Julia.</source>
          <target state="translated">型共用体は、任意の引数型のすべてのインスタンスを含む抽象型です。空の組合&lt;a href=&quot;#Union%7B%7D&quot;&gt; &lt;code&gt;Union{}&lt;/code&gt; &lt;/a&gt;はJuliaの最下位タイプです。</target>
        </trans-unit>
        <trans-unit id="78a19252283d099431e9543c48dcfeb2c0c70cdb" translate="yes" xml:space="preserve">
          <source>A type used for controlling the rounding mode of floating point operations (via &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt;&lt;code&gt;rounding&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;setrounding&lt;/code&gt; functions), or as optional arguments for rounding to the nearest integer (via the &lt;code&gt;round&lt;/code&gt; function).</source>
          <target state="translated">浮動小数点演算の丸めモードを制御するために使用されるタイプ（&lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt; &lt;code&gt;rounding&lt;/code&gt; &lt;/a&gt; / &lt;code&gt;setrounding&lt;/code&gt; 関数を介して）、または最も近い整数に丸めるためのオプションの引数として（ &lt;code&gt;round&lt;/code&gt; 関数を介して）使用されるタイプ。</target>
        </trans-unit>
        <trans-unit id="cce4e44b3212d47f6685805f453e4928d3ab1723" translate="yes" xml:space="preserve">
          <source>A type with no fields that is the type of &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;タイプであるフィールドのないタイプ。</target>
        </trans-unit>
        <trans-unit id="2c8120bb7a13d8189f767168488ba78dd50f96b4" translate="yes" xml:space="preserve">
          <source>A type with no fields whose singleton instance &lt;a href=&quot;#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; is used to represent missing values.</source>
          <target state="translated">シングルトンインスタンスが&lt;a href=&quot;#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;いるフィールドがないタイプは、欠落値を表すために使用されます。</target>
        </trans-unit>
        <trans-unit id="306e436a1878b67ebef890bd34b67f5c57414a92" translate="yes" xml:space="preserve">
          <source>A typical usage of such a pair of return values, however, extracts each value into a variable. Julia supports simple tuple &quot;destructuring&quot; that facilitates this:</source>
          <target state="translated">しかし、このような戻り値のペアの典型的な使用法は、それぞれの値を変数に抽出します。Julia はこれを容易にするシンプルなタプルの &quot;破壊&quot; をサポートしています。</target>
        </trans-unit>
        <trans-unit id="913d40733121bbdbb40702c29375806cce6f85d2" translate="yes" xml:space="preserve">
          <source>A union of types over all values of a type parameter. &lt;code&gt;UnionAll&lt;/code&gt; is used to describe parametric types where the values of some parameters are not known.</source>
          <target state="translated">型パラメーターのすべての値に対する型の和集合。 &lt;code&gt;UnionAll&lt;/code&gt; は、一部のパラメーターの値が不明なパラメトリックタイプを記述するために使用されます。</target>
        </trans-unit>
        <trans-unit id="a657ba8f21c293af12b12dfaacd8ec7d70ec5e5a" translate="yes" xml:space="preserve">
          <source>A useful tool for measuring performance is the &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt;&lt;code&gt;@time&lt;/code&gt;&lt;/a&gt; macro. We here repeat the example with the global variable above, but this time with the type annotation removed:</source>
          <target state="translated">パフォーマンスを測定するための便利なツールは、&lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt; &lt;code&gt;@time&lt;/code&gt; &lt;/a&gt;マクロです。ここでは、上記のグローバル変数を使用して例を繰り返しますが、今回は型注釈を削除しています。</target>
        </trans-unit>
        <trans-unit id="c5253993e5fc44814c87723bb62dfda7d99d25d2" translate="yes" xml:space="preserve">
          <source>A variable name can be &quot;reserved&quot; without assigning to it by declaring it as &lt;code&gt;global x&lt;/code&gt;. This prevents name conflicts for globals initialized after load time.</source>
          <target state="translated">変数名は、 &lt;code&gt;global x&lt;/code&gt; として宣言することにより、割り当てずに「予約」できます。これにより、ロード後に初期化されたグローバルの名前の競合が防止されます。</target>
        </trans-unit>
        <trans-unit id="7fd534d23374f6545f94032e172165c5e2ffe3bb" translate="yes" xml:space="preserve">
          <source>A variable referring to the last computed value, automatically set at the interactive prompt.</source>
          <target state="translated">最後に計算された値を参照する変数で、インタラクティブなプロンプトで自動的に設定されます。</target>
        </trans-unit>
        <trans-unit id="9301af4052e23061aeab00f8629595c8531efad3" translate="yes" xml:space="preserve">
          <source>A variable, in Julia, is a name associated (or bound) to a value. It's useful when you want to store a value (that you obtained after some math, for example) for later use. For example:</source>
          <target state="translated">ジュリアでは、変数とは、値に関連付けられた(またはバインドされた)名前のことです。これは、後で使用するために値を保存しておきたい場合に便利です(例えば、計算の後に得た値など)。例えば</target>
        </trans-unit>
        <trans-unit id="343ec2d984e66e00b3ae00539feb443a8166ee65" translate="yes" xml:space="preserve">
          <source>A variation on this approach, which avoids the appearance of type instability is to merge the &lt;code&gt;Int&lt;/code&gt; and &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; types into a single hybrid integer type, that internally changes representation when a result no longer fits into the size of a machine integer. While this superficially avoids type-instability at the level of Julia code, it just sweeps the problem under the rug by foisting all of the same difficulties onto the C code implementing this hybrid integer type. This approach &lt;em&gt;can&lt;/em&gt; be made to work and can even be made quite fast in many cases, but has several drawbacks. One problem is that the in-memory representation of integers and arrays of integers no longer match the natural representation used by C, Fortran and other languages with native machine integers. Thus, to interoperate with those languages, we would ultimately need to introduce native integer types anyway. Any unbounded representation of integers cannot have a fixed number of bits, and thus cannot be stored inline in an array with fixed-size slots &amp;ndash; large integer values will always require separate heap-allocated storage. And of course, no matter how clever a hybrid integer implementation one uses, there are always performance traps &amp;ndash; situations where performance degrades unexpectedly. Complex representation, lack of interoperability with C and Fortran, the inability to represent integer arrays without additional heap storage, and unpredictable performance characteristics make even the cleverest hybrid integer implementations a poor choice for high-performance numerical work.</source>
          <target state="translated">このアプローチのバリエーションは、型が不安定になることを&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;ために、 &lt;code&gt;Int&lt;/code&gt; 型とBigInt型を単一のハイブリッド整数型にマージし、結果がマシン整数のサイズに適合しなくなったときに内部で表現を変更することです。これは表面的にはJuliaコードのレベルで型の不安定性を回避しますが、このハイブリッド整数型を実装するCコードに同じ困難をすべて押し付けることによって、ラグの下で問題を一掃するだけです。このアプローチ&lt;em&gt;は&lt;/em&gt;動作するように作られ、多くの場合かなり高速にさえできますが、いくつかの欠点があります。 1つの問題は、整数のメモリ内表現と整数の配列が、ネイティブマシンの整数でC、Fortran、およびその他の言語で使用される自然な表現と一致しないことです。したがって、これらの言語と相互運用するには、最終的にネイティブ整数型を導入する必要があります。整数の制限のない表現は、固定ビット数を持つことができないため、固定サイズのスロットを持つ配列にインラインで格納することはできません。大きな整数値には、個別のヒープ割り当てストレージが常に必要です。そしてもちろん、ハイブリッド整数の実装がどれほど巧妙に使用されていても、常にパフォーマンストラップがあります。これは、パフォーマンスが予期せず低下する状況です。複雑な表現、CおよびFortranとの相互運用性の欠如、追加のヒープストレージなしで整数配列を表現できないこと、および予測できないパフォーマンス特性により、賢いハイブリッド整数の実装でさえ、高性能数値計算の不適切な選択になります。</target>
        </trans-unit>
        <trans-unit id="e58331c965191dacd80a8789c7e948a53ee2b04e" translate="yes" xml:space="preserve">
          <source>A very special macro is &lt;a href=&quot;../../base/base/index#Base.@generated&quot;&gt;&lt;code&gt;@generated&lt;/code&gt;&lt;/a&gt;, which allows you to define so-called &lt;em&gt;generated functions&lt;/em&gt;. These have the capability to generate specialized code depending on the types of their arguments with more flexibility and/or less code than what can be achieved with multiple dispatch. While macros work with expressions at parse time and cannot access the types of their inputs, a generated function gets expanded at a time when the types of the arguments are known, but the function is not yet compiled.</source>
          <target state="translated">非常に特殊なマクロは&lt;a href=&quot;../../base/base/index#Base.@generated&quot;&gt; &lt;code&gt;@generated&lt;/code&gt; で&lt;/a&gt;、これにより、いわゆる&lt;em&gt;生成された関数&lt;/em&gt;を定義できます。これらは、引数のタイプに応じて、複数のディスパッチで実現できるものよりも柔軟性やコードが少ない特殊なコードを生成する機能を備えています。マクロは解析時に式を処理し、入力のタイプにアクセスできませんが、生成された関数は、引数のタイプがわかっているときに展開されますが、関数はまだコンパイルされていません。</target>
        </trans-unit>
        <trans-unit id="141d8c5657b1c8b0553ace4a61596a7c1734a9a6" translate="yes" xml:space="preserve">
          <source>A wrapper type used in &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; to distinguish between the absence of a value (&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;) and the presence of a &lt;code&gt;nothing&lt;/code&gt; value (i.e. &lt;code&gt;Some(nothing)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; 使用されるラッパー型で、値の不在（&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;）と &lt;code&gt;nothing&lt;/code&gt; 値の存在（つまり &lt;code&gt;Some(nothing)&lt;/code&gt; ）を区別します。</target>
        </trans-unit>
        <trans-unit id="89c25a6e98b7d12432623429744aea6cf501424a" translate="yes" xml:space="preserve">
          <source>API reference</source>
          <target state="translated">エーピーアイさんしょう</target>
        </trans-unit>
        <trans-unit id="f6db2b825c2703e26c1c6b659f77956e578c5caf" translate="yes" xml:space="preserve">
          <source>ARGS</source>
          <target state="translated">ARGS</target>
        </trans-unit>
        <trans-unit id="a1df128dfacd3f460cbb61bb4087bb92287d3fcb" translate="yes" xml:space="preserve">
          <source>ARI</source>
          <target state="translated">ARI</target>
        </trans-unit>
        <trans-unit id="cade2543bf82eecb0447ba12066fcc5daa136208" translate="yes" xml:space="preserve">
          <source>ASCII characters and ASCII escapes produce a single byte.</source>
          <target state="translated">ASCII文字とASCIIエスケープは1バイトを生成します。</target>
        </trans-unit>
        <trans-unit id="20ab2d9088d2ab458d63ed3bd729fda9297db5a4" translate="yes" xml:space="preserve">
          <source>AV</source>
          <target state="translated">AV</target>
        </trans-unit>
        <trans-unit id="33a783add30fb01fc6df3bfeb87611c9fd6e0247" translate="yes" xml:space="preserve">
          <source>Abbr.</source>
          <target state="translated">Abbr.</target>
        </trans-unit>
        <trans-unit id="d634b593f2d04c176e6178cce99b9871b914261f" translate="yes" xml:space="preserve">
          <source>Above, it was pointed out that one can resolve ambiguities like</source>
          <target state="translated">のような曖昧さを解決できることが指摘されていました。</target>
        </trans-unit>
        <trans-unit id="444368fcd88ae8ee9706df79374d2260c8851efb" translate="yes" xml:space="preserve">
          <source>Abstract Arrays</source>
          <target state="translated">抽象的な配列</target>
        </trans-unit>
        <trans-unit id="afab87d7da169104e68739efdca076e3028a0b71" translate="yes" xml:space="preserve">
          <source>Abstract Types</source>
          <target state="translated">抽象的なタイプ</target>
        </trans-unit>
        <trans-unit id="3731303601cb9a5262dd9843918c4065a4b09ed2" translate="yes" xml:space="preserve">
          <source>Abstract containers and element types</source>
          <target state="translated">抽象的なコンテナと要素の種類</target>
        </trans-unit>
        <trans-unit id="b81afa6e965e7c1908221b1c01f57fb3e1ed309d" translate="yes" xml:space="preserve">
          <source>Abstract number types</source>
          <target state="translated">抽象的な番号タイプ</target>
        </trans-unit>
        <trans-unit id="203bf0ca60eba0b4df86ca193ff6564bf1f08046" translate="yes" xml:space="preserve">
          <source>Abstract supertype describing types that implement the synchronization primitives: &lt;a href=&quot;#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.trylock&quot;&gt;&lt;code&gt;trylock&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#Base.islocked&quot;&gt;&lt;code&gt;islocked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">同期プリミティブを実装タイプを記述する抽象スーパータイプ：&lt;a href=&quot;#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#Base.trylock&quot;&gt; &lt;code&gt;trylock&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt;、及び&lt;a href=&quot;#Base.islocked&quot;&gt; &lt;code&gt;islocked&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="161cfe5f22c6ec0c5c1636e00ae6b86b4dfab7b0" translate="yes" xml:space="preserve">
          <source>Abstract supertype for IP addresses. &lt;a href=&quot;#Sockets.IPv4&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Sockets.IPv6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; are subtypes of this.</source>
          <target state="translated">IPアドレスの抽象スーパータイプ。&lt;a href=&quot;#Sockets.IPv4&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#Sockets.IPv6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; &lt;/a&gt;はこのサブタイプです。</target>
        </trans-unit>
        <trans-unit id="7ec52c1e034eaa75fbf55c8ad047e12dee7c43d5" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all floating point numbers.</source>
          <target state="translated">すべての浮動小数点数の抽象的なスーパータイプ。</target>
        </trans-unit>
        <trans-unit id="d3c5cb7bbcaf4de0abc6af421aee06fd1805c5f7" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all integers.</source>
          <target state="translated">すべての整数の抽象的なスーパータイプ。</target>
        </trans-unit>
        <trans-unit id="c2307397eab7e7e325b924259a7acd689ce9202f" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all number types.</source>
          <target state="translated">すべての数値型の抽象的なスーパータイプ。</target>
        </trans-unit>
        <trans-unit id="8137ecd293ea0b9f148b79a2c5d9ef23135b11e0" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all real numbers.</source>
          <target state="translated">すべての実数の抽象的なスーパータイプ。</target>
        </trans-unit>
        <trans-unit id="5d4c24eb8dfef4792ccde0796267cae116c984c2" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all signed integers.</source>
          <target state="translated">すべての符号付き整数の抽象的な超型.</target>
        </trans-unit>
        <trans-unit id="98c1a75aa7f0d6a8990b451bf94db6a410025a03" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all unsigned integers.</source>
          <target state="translated">すべての符号なし整数の抽象的なスーパータイプ。</target>
        </trans-unit>
        <trans-unit id="93e4098f9689d748060c11ebe52324df10ec1351" translate="yes" xml:space="preserve">
          <source>Abstract supertype for rich display output devices. &lt;a href=&quot;#Base.Multimedia.TextDisplay&quot;&gt;&lt;code&gt;TextDisplay&lt;/code&gt;&lt;/a&gt; is a subtype of this.</source>
          <target state="translated">リッチディスプレイ出力デバイスの抽象スーパータイプ。&lt;a href=&quot;#Base.Multimedia.TextDisplay&quot;&gt; &lt;code&gt;TextDisplay&lt;/code&gt; &lt;/a&gt;はこのサブタイプです。</target>
        </trans-unit>
        <trans-unit id="76cd9a3f07be7d40989b1baf043119bf5df6066e" translate="yes" xml:space="preserve">
          <source>Abstract type of all functions.</source>
          <target state="translated">すべての関数の抽象型。</target>
        </trans-unit>
        <trans-unit id="84e429cc9f28682f2f27e8d636ad9613a3b2da6d" translate="yes" xml:space="preserve">
          <source>Abstract types are declared using the &lt;a href=&quot;../../base/base/index#abstract%20type&quot;&gt;&lt;code&gt;abstract type&lt;/code&gt;&lt;/a&gt; keyword. The general syntaxes for declaring an abstract type are:</source>
          <target state="translated">抽象型は、&lt;a href=&quot;../../base/base/index#abstract%20type&quot;&gt; &lt;code&gt;abstract type&lt;/code&gt; &lt;/a&gt;キーワードを使用して宣言されます。抽象型を宣言するための一般的な構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c58fec15e5232080566685f01231f0dc1e49a918" translate="yes" xml:space="preserve">
          <source>Abstract types cannot be instantiated, and serve only as nodes in the type graph, thereby describing sets of related concrete types: those concrete types which are their descendants. We begin with abstract types even though they have no instantiation because they are the backbone of the type system: they form the conceptual hierarchy which makes Julia's type system more than just a collection of object implementations.</source>
          <target state="translated">抽象型はインスタンス化することができず、型グラフのノードとしてしか機能せず、それによって関連する具象型の集合、つまりそれらの子孫である具象型を記述する。抽象型は型システムのバックボーンであり、ジュリアの型システムを単なるオブジェクト実装の集合以上のものにする概念的な階層を形成しているからです。</target>
        </trans-unit>
        <trans-unit id="99f8f0ef23e181287cd6d3022637085c03e3e6b8" translate="yes" xml:space="preserve">
          <source>AbstractDict</source>
          <target state="translated">AbstractDict</target>
        </trans-unit>
        <trans-unit id="c0458876d81208a95087a4de5e1caaa1d2000c99" translate="yes" xml:space="preserve">
          <source>AbstractDisplay &lt;code&gt;x&lt;/code&gt; using the topmost applicable display in the display stack, typically using the richest supported multimedia output for &lt;code&gt;x&lt;/code&gt;, with plain-text &lt;a href=&quot;#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; output as a fallback. The &lt;code&gt;display(d, x)&lt;/code&gt; variant attempts to display &lt;code&gt;x&lt;/code&gt; on the given display &lt;code&gt;d&lt;/code&gt; only, throwing a &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;d&lt;/code&gt; cannot display objects of this type.</source>
          <target state="translated">AbstractDisplay &lt;code&gt;x&lt;/code&gt; は、ディスプレイスタックの最上位の該当するディスプレイを使用します。通常、サポートされている最もリッチな &lt;code&gt;x&lt;/code&gt; のマルチメディア出力を使用し、フォールバックとしてプレーンテキストの&lt;a href=&quot;#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;出力を使用します。 &lt;code&gt;display(d, x)&lt;/code&gt; 表示に変異試行 &lt;code&gt;x&lt;/code&gt; 所与のディスプレイ上の &lt;code&gt;d&lt;/code&gt; 投げのみ、&lt;a href=&quot;../base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; の&lt;/a&gt;場合 &lt;code&gt;d&lt;/code&gt; 、このタイプのオブジェクトを表示することができません。</target>
        </trans-unit>
        <trans-unit id="7eaed6a73d55c164395b7a1a21e441cbb954faed" translate="yes" xml:space="preserve">
          <source>AbstractIrrational</source>
          <target state="translated">AbstractIrrational</target>
        </trans-unit>
        <trans-unit id="bf18f60e42cfb0779a9b4f7ddad8d2d330b3942c" translate="yes" xml:space="preserve">
          <source>AbstractLock</source>
          <target state="translated">AbstractLock</target>
        </trans-unit>
        <trans-unit id="b088bdfb0583418c7216120363be65d53cfb24c4" translate="yes" xml:space="preserve">
          <source>AbstractMatrix</source>
          <target state="translated">AbstractMatrix</target>
        </trans-unit>
        <trans-unit id="1a85fd0dbacd4a4cf6bcd5291fb7d75e1f9be36d" translate="yes" xml:space="preserve">
          <source>AbstractRange</source>
          <target state="translated">AbstractRange</target>
        </trans-unit>
        <trans-unit id="ce89d8527dc144fe8623087bd9235422a835ad7f" translate="yes" xml:space="preserve">
          <source>AbstractSet</source>
          <target state="translated">AbstractSet</target>
        </trans-unit>
        <trans-unit id="1d4be86b60074a8c81bb5c652c7352a1af4f56bd" translate="yes" xml:space="preserve">
          <source>AbstractUnitRange</source>
          <target state="translated">AbstractUnitRange</target>
        </trans-unit>
        <trans-unit id="69ac868610201e6a40f57ef6a33cac3933afa73e" translate="yes" xml:space="preserve">
          <source>AbstractVecOrMat</source>
          <target state="translated">AbstractVecOrMat</target>
        </trans-unit>
        <trans-unit id="6167adb4464ed99a679a24201ae93baff8fe87bb" translate="yes" xml:space="preserve">
          <source>AbstractVector</source>
          <target state="translated">AbstractVector</target>
        </trans-unit>
        <trans-unit id="ff33b5833701038044ed7a8bf95bb5da1639a716" translate="yes" xml:space="preserve">
          <source>Abusing this will corrupt the runtime system and cause undefined behavior:</source>
          <target state="translated">これを悪用するとランタイムシステムが破損し、定義されていない動作が発生します。</target>
        </trans-unit>
        <trans-unit id="1067d0a82d1d5a296a37f79af88170005dbcf1e6" translate="yes" xml:space="preserve">
          <source>Ac Current</source>
          <target state="translated">交流電流</target>
        </trans-unit>
        <trans-unit id="d1e31fbd4f9f4072d2446b9b7e8c1f20663d7c76" translate="yes" xml:space="preserve">
          <source>Accepts a connection on the given server and returns a connection to the client. An uninitialized client stream may be provided, in which case it will be used instead of creating a new stream.</source>
          <target state="translated">指定したサーバからの接続を受け付け、クライアントへの接続を返します。初期化されていないクライアントストリームが提供されることもありますが、その場合は新しいストリームを作成する代わりにそれが使用されます。</target>
        </trans-unit>
        <trans-unit id="5a231d65a330d9d9348434455d2fcc49d60050da" translate="yes" xml:space="preserve">
          <source>Access arrays in memory order, along columns</source>
          <target state="translated">列に沿ってメモリ順に配列にアクセス</target>
        </trans-unit>
        <trans-unit id="b34a6bc7b1bae42bda9d01ca1c470c5375ab7fb7" translate="yes" xml:space="preserve">
          <source>Accesses must have a stride pattern and cannot be &quot;gathers&quot; (random-index reads) or &quot;scatters&quot; (random-index writes).</source>
          <target state="translated">アクセスはストライドパターンを持っていなければならず、「ギャザー」(ランダムインデックスの読み取り)や「スキャッター」(ランダムインデックスの書き込み)はできません。</target>
        </trans-unit>
        <trans-unit id="04dff1094ca04d8d22abd4cb907396dab9a3d50f" translate="yes" xml:space="preserve">
          <source>Accessing Data through a Pointer</source>
          <target state="translated">ポインタを使ったデータへのアクセス</target>
        </trans-unit>
        <trans-unit id="4e0aa606654432d6afe63016328a7456acbf5548" translate="yes" xml:space="preserve">
          <source>Accessing Documentation</source>
          <target state="translated">ドキュメントへのアクセス</target>
        </trans-unit>
        <trans-unit id="5effc224ab155ff163fdf8204037715e80f5787f" translate="yes" xml:space="preserve">
          <source>Accessing Global Variables</source>
          <target state="translated">グローバル変数へのアクセス</target>
        </trans-unit>
        <trans-unit id="eece63f5b1a8127dcc472656346b5e65a1a16b4d" translate="yes" xml:space="preserve">
          <source>Accessing Returned Arrays</source>
          <target state="translated">返された配列へのアクセス</target>
        </trans-unit>
        <trans-unit id="94331919d037782e6104eb270ff9d9fb7da43903" translate="yes" xml:space="preserve">
          <source>Accessing the value associated with a name in a named tuple can be done using field access syntax, e.g. &lt;code&gt;x.a&lt;/code&gt;, or using &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;x[:a]&lt;/code&gt;. A tuple of the names can be obtained using &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt;, and a tuple of the values can be obtained using &lt;a href=&quot;../collections/index#Base.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">名前付きタプルの名前に関連付けられた値へのアクセスは、フィールドアクセス構文（ &lt;code&gt;x.a&lt;/code&gt; など）を使用するか、&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;x[:a]&lt;/code&gt; など）を使用して実行できます。名前のタプルは&lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;を使用して取得でき、値のタプルは値を使用して取得でき&lt;a href=&quot;../collections/index#Base.values&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e66b7f3723702c43ff6e0aa8ffbcb4594a04f89" translate="yes" xml:space="preserve">
          <source>Accessor Functions</source>
          <target state="translated">アクセッサー機能</target>
        </trans-unit>
        <trans-unit id="d2767f0a53b5589f58d10c2a600ba9c937b4860b" translate="yes" xml:space="preserve">
          <source>Accumulation and clearing</source>
          <target state="translated">蓄積とクリア</target>
        </trans-unit>
        <trans-unit id="8d4bc1e3633428932020325ab9038391aedb805b" translate="yes" xml:space="preserve">
          <source>Accurate natural logarithm of &lt;code&gt;1+x&lt;/code&gt;. Throws &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; arguments less than -1.</source>
          <target state="translated">&lt;code&gt;1+x&lt;/code&gt; の正確な自然対数。例外&lt;a href=&quot;../base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; は&lt;/a&gt;のために&lt;a href=&quot;../numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; -1未満の引数。</target>
        </trans-unit>
        <trans-unit id="daec25040f3792b222435be23467b3ab6876b7a5" translate="yes" xml:space="preserve">
          <source>Accurately compute $e^x-1$.</source>
          <target state="translated">e^x-1$を正確に計算します。</target>
        </trans-unit>
        <trans-unit id="11d200c26fa49e2ce4befb8e0cf46e14cd0db2d8" translate="yes" xml:space="preserve">
          <source>Acquire the &lt;code&gt;lock&lt;/code&gt; when it becomes available. If the lock is already locked by a different task/thread, wait for it to become available.</source>
          <target state="translated">使用可能になったときに &lt;code&gt;lock&lt;/code&gt; 取得します。ロックが別のタスク/スレッドによってすでにロックされている場合は、ロックが使用可能になるまで待ちます。</target>
        </trans-unit>
        <trans-unit id="111fa83b00bb4738853e63e06a10c68a0195c86f" translate="yes" xml:space="preserve">
          <source>Acquire the lock if it is available, and return &lt;code&gt;true&lt;/code&gt; if successful. If the lock is already locked by a different task/thread, return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">利用可能な場合はロックを取得し、成功した場合は &lt;code&gt;true&lt;/code&gt; を返します。ロックが別のタスク/スレッドによってすでにロックされている場合は、 &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="f2342ed0f0b229a0d03ed8168b59f19edf073636" translate="yes" xml:space="preserve">
          <source>Acute Angle</source>
          <target state="translated">急性角度</target>
        </trans-unit>
        <trans-unit id="4e210cb6cb9deed65bd9b851c840063ddc24f3fc" translate="yes" xml:space="preserve">
          <source>Add a &lt;a href=&quot;#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; to the scheduler's queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as &lt;a href=&quot;#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;をスケジューラのキューに追加します。これにより、タスクが&lt;a href=&quot;#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;などのブロック操作を実行しない限り、システムがアイドル状態のときにタスクが常に実行されます。</target>
        </trans-unit>
        <trans-unit id="ba7029093da6b4c90c7e27d2113f54b848408051" translate="yes" xml:space="preserve">
          <source>Add a &lt;em&gt;fetch&lt;/em&gt; refspec for the specified &lt;code&gt;rmt&lt;/code&gt;. This refspec will contain information about which branch(es) to fetch from.</source>
          <target state="translated">指定された &lt;code&gt;rmt&lt;/code&gt; の&lt;em&gt;フェッチ&lt;/em&gt; refspecを追加します。このrefspecには、どのブランチからフェッチするかに関する情報が含まれます。</target>
        </trans-unit>
        <trans-unit id="bc32e59f77d37df698d49af8f9d944b43a7af79c" translate="yes" xml:space="preserve">
          <source>Add a &lt;em&gt;push&lt;/em&gt; refspec for the specified &lt;code&gt;rmt&lt;/code&gt;. This refspec will contain information about which branch(es) to push to.</source>
          <target state="translated">指定された &lt;code&gt;rmt&lt;/code&gt; の&lt;em&gt;プッシュ&lt;/em&gt; refspecを追加します。このrefspecには、プッシュ先のブランチに関する情報が含まれます。</target>
        </trans-unit>
        <trans-unit id="7d2e4a20c94af16618f42a95303b58afe01cacad" translate="yes" xml:space="preserve">
          <source>Add a mark at the current position of stream &lt;code&gt;s&lt;/code&gt;. Return the marked position.</source>
          <target state="translated">ストリーム &lt;code&gt;s&lt;/code&gt; の現在の位置にマークを追加します。マークされた位置を返します。</target>
        </trans-unit>
        <trans-unit id="c81d1e9a4af83f24f843b4a0dd03ec8759d823af" translate="yes" xml:space="preserve">
          <source>Add all the files with paths specified by &lt;code&gt;files&lt;/code&gt; to the index &lt;code&gt;idx&lt;/code&gt; (or the index of the &lt;code&gt;repo&lt;/code&gt;). If the file already exists, the index entry will be updated. If the file does not exist already, it will be newly added into the index. &lt;code&gt;files&lt;/code&gt; may contain glob patterns which will be expanded and any matching files will be added (unless &lt;code&gt;INDEX_ADD_DISABLE_PATHSPEC_MATCH&lt;/code&gt; is set, see below). If a file has been ignored (in &lt;code&gt;.gitignore&lt;/code&gt; or in the config), it &lt;em&gt;will not&lt;/em&gt; be added, &lt;em&gt;unless&lt;/em&gt; it is already being tracked in the index, in which case it &lt;em&gt;will&lt;/em&gt; be updated. The keyword argument &lt;code&gt;flags&lt;/code&gt; is a set of bit-flags which control the behavior with respect to ignored files:</source>
          <target state="translated">で指定されたパスを持つすべてのファイルを追加し &lt;code&gt;files&lt;/code&gt; のインデックスに &lt;code&gt;idx&lt;/code&gt; （またはのインデックス &lt;code&gt;repo&lt;/code&gt; ）。ファイルが既に存在する場合、インデックスエントリが更新されます。ファイルがまだ存在しない場合は、新しくインデックスに追加されます。 &lt;code&gt;files&lt;/code&gt; は、展開され、一致するファイルが追加されるグロブパターンが含まれる場合があります（ &lt;code&gt;INDEX_ADD_DISABLE_PATHSPEC_MATCH&lt;/code&gt; が設定されていない限り、以下を参照してください）。ファイルが（では無視されている場合 &lt;code&gt;.gitignore&lt;/code&gt; または設定で）、それは&lt;em&gt;ありません&lt;/em&gt;、添加され&lt;em&gt;ない限り、&lt;/em&gt;それが既にそれが、その場合、インデックスに追跡されている&lt;em&gt;であろう&lt;/em&gt;更新されます。キーワード引数 &lt;code&gt;flags&lt;/code&gt; 無視されたファイルに関する動作を制御するビットフラグのセットです。</target>
        </trans-unit>
        <trans-unit id="f9859b5e151c0d4dccb9ba69eeb3e7174642b756" translate="yes" xml:space="preserve">
          <source>Add processes on remote machines via SSH. Requires &lt;code&gt;julia&lt;/code&gt; to be installed in the same location on each node, or to be available via a shared file system.</source>
          <target state="translated">SSH経由でリモートマシンにプロセスを追加します。必要 &lt;code&gt;julia&lt;/code&gt; 、各ノード上の同じ場所にインストールされる、または共有ファイル・システムを介して利用可能です。</target>
        </trans-unit>
        <trans-unit id="c93d7a95d43dad0a2e3566faa9380568c513bf49" translate="yes" xml:space="preserve">
          <source>Add the elements of &lt;code&gt;collection2&lt;/code&gt; to the end of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">要素の追加 &lt;code&gt;collection2&lt;/code&gt; の最後に &lt;code&gt;collection&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="8f60daef6009f4b56c282cccb45652345ff90737" translate="yes" xml:space="preserve">
          <source>Addition operator. &lt;code&gt;x+y+z+...&lt;/code&gt; calls this function with all arguments, i.e. &lt;code&gt;+(x, y, z, ...)&lt;/code&gt;.</source>
          <target state="translated">加算演算子。 &lt;code&gt;x+y+z+...&lt;/code&gt; は、この関数をすべての引数、つまり &lt;code&gt;+(x, y, z, ...)&lt;/code&gt; 呼び出します。</target>
        </trans-unit>
        <trans-unit id="23397c083849f8b996730f9a8baa14e28dc8e903" translate="yes" xml:space="preserve">
          <source>Additional examples and tests are available in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/adjusters.jl&quot;&gt;&lt;code&gt;stdlib/Dates/test/adjusters.jl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">追加の例とテストは&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/adjusters.jl&quot;&gt; &lt;code&gt;stdlib/Dates/test/adjusters.jl&lt;/code&gt; にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="685ef1698c6666c2bd0d492d0ee46828879da80d" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt; is not limited to arrays (see the function documentation), it also handles tuples and treats any argument that is not an array, tuple or &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref&lt;/code&gt;&lt;/a&gt; (except for &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr&lt;/code&gt;&lt;/a&gt;) as a &quot;scalar&quot;.</source>
          <target state="translated">さらに、&lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt;は配列に限定されず（関数のドキュメントを参照）、タプルも処理し、配列、タプル、または&lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr&lt;/code&gt; &lt;/a&gt;を除く）ではない引数を「スカラー」として扱います。</target>
        </trans-unit>
        <trans-unit id="7f79534c24bf8f2a16bd71a1b6a3a39a544a8226" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;../../base/math/index#Base.Math.sinpi&quot;&gt;&lt;code&gt;sinpi(x)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.Math.cospi&quot;&gt;&lt;code&gt;cospi(x)&lt;/code&gt;&lt;/a&gt; are provided for more accurate computations of &lt;code&gt;sin(pi*x)&lt;/code&gt; and &lt;code&gt;cos(pi*x)&lt;/code&gt; respectively.</source>
          <target state="translated">さらに、&lt;a href=&quot;../../base/math/index#Base.Math.sinpi&quot;&gt; &lt;code&gt;sinpi(x)&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../base/math/index#Base.Math.cospi&quot;&gt; &lt;code&gt;cospi(x)&lt;/code&gt; &lt;/a&gt;は、それぞれ &lt;code&gt;sin(pi*x)&lt;/code&gt; および &lt;code&gt;cos(pi*x)&lt;/code&gt; のより正確な計算のために提供されています。</target>
        </trans-unit>
        <trans-unit id="bf3a3f7bf5e98e1e5497ee4fe9676516a92be473" translate="yes" xml:space="preserve">
          <source>Additionally, code blocks can be enclosed using triple backticks with an optional &quot;language&quot; to specify how a block of code should be highlighted.</source>
          <target state="translated">さらに、コードブロックは、コードブロックがどのようにハイライトされるかを指定するために、オプションの &quot;language &quot;を使用して、トリプルバックティックを使用して囲むことができます。</target>
        </trans-unit>
        <trans-unit id="aa6d0dd52c8f973d7d02448858d93589ccb8e270" translate="yes" xml:space="preserve">
          <source>Additionally, full support for &lt;a href=&quot;../complex-and-rational-numbers/index#Complex-and-Rational-Numbers-1&quot;&gt;Complex and Rational Numbers&lt;/a&gt; is built on top of these primitive numeric types. All numeric types interoperate naturally without explicit casting, thanks to a flexible, user-extensible &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;type promotion system&lt;/a&gt;.</source>
          <target state="translated">さらに、&lt;a href=&quot;../complex-and-rational-numbers/index#Complex-and-Rational-Numbers-1&quot;&gt;複素数と有理数の&lt;/a&gt;完全なサポートは、これらのプリミティブ数値型の上に構築されています。すべての数値型は、柔軟でユーザーが拡張可能な&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;型プロモーションシステムの&lt;/a&gt;おかげで、明示的なキャストなしで自然に相互運用できます。</target>
        </trans-unit>
        <trans-unit id="ccda9828ec19af11c51796660b5ccb16a7d0e952" translate="yes" xml:space="preserve">
          <source>Additionally, normal and exponential distributions are implemented for some &lt;code&gt;AbstractFloat&lt;/code&gt; and &lt;code&gt;Complex&lt;/code&gt; types, see &lt;a href=&quot;#Base.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Random.randexp&quot;&gt;&lt;code&gt;randexp&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">さらに、いくつかの &lt;code&gt;AbstractFloat&lt;/code&gt; および &lt;code&gt;Complex&lt;/code&gt; タイプに対して正規分布および指数分布が実装されています。詳細については、&lt;a href=&quot;#Base.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#Random.randexp&quot;&gt; &lt;code&gt;randexp&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="99173595dabed80445cea4531dee6a385768b591" translate="yes" xml:space="preserve">
          <source>Additionally, parenthesized expressions can be used as coefficients to variables, implying multiplication of the expression by the variable:</source>
          <target state="translated">さらに、括弧で囲まれた式は、変数の係数として使用することができ、変数による式の乗算を意味します。</target>
        </trans-unit>
        <trans-unit id="fc43d556aa5aff0175b36169557918148740e7bb" translate="yes" xml:space="preserve">
          <source>Additionally, some exception types take one or more arguments that are used for error reporting:</source>
          <target state="translated">さらに、いくつかの例外型は、エラー報告に使用される1つ以上の引数を取ります。</target>
        </trans-unit>
        <trans-unit id="8af66c1813abced10595ff4db44c8598650f35a8" translate="yes" xml:space="preserve">
          <source>Additionally, to support the syntax &lt;code&gt;S[end]&lt;/code&gt;, we must define &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt;&lt;code&gt;lastindex&lt;/code&gt;&lt;/a&gt; to specify the last valid index. It is recommended to also define &lt;a href=&quot;../../base/collections/index#Base.firstindex&quot;&gt;&lt;code&gt;firstindex&lt;/code&gt;&lt;/a&gt; to specify the first valid index:</source>
          <target state="translated">さらに、構文 &lt;code&gt;S[end]&lt;/code&gt; をサポートするには、&lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt; &lt;code&gt;lastindex&lt;/code&gt; &lt;/a&gt;を定義して、最後の有効なインデックスを指定する必要があります。&lt;a href=&quot;../../base/collections/index#Base.firstindex&quot;&gt; &lt;code&gt;firstindex&lt;/code&gt; &lt;/a&gt;も定義して、最初の有効なインデックスを指定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0d6e9dda2992ae61bd194a5d6431ac6a6fc0e4af" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; each of which should be a documentable expression. This syntax is equivalent to</source>
          <target state="translated">docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; を &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; に追加します。それぞれをドキュメント化可能な式にする必要があります。この構文は次と同等です。</target>
        </trans-unit>
        <trans-unit id="8943e54e348b67270f56f401533e4c55795efd88" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to expression generated by expanding &lt;code&gt;@m expression&lt;/code&gt;. This allows for expressions decorated with &lt;code&gt;@inline&lt;/code&gt;, &lt;code&gt;@noinline&lt;/code&gt;, &lt;code&gt;@generated&lt;/code&gt;, or any other macro to be documented in the same way as undecorated expressions.</source>
          <target state="translated">&lt;code&gt;@m expression&lt;/code&gt; を展開して生成された式にdocstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; を追加します。これにより、 &lt;code&gt;@noinline&lt;/code&gt; &lt;code&gt;@inline&lt;/code&gt; 、@noinline、 &lt;code&gt;@generated&lt;/code&gt; 、またはその他のマクロで装飾された式を、装飾されていない式と同じ方法で文書化できます。</target>
        </trans-unit>
        <trans-unit id="c5cf536102070d30975cbdc29561f68968871a8c" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the &lt;code&gt;@m(::Any)&lt;/code&gt; macro definition.</source>
          <target state="translated">docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; を &lt;code&gt;@m(::Any)&lt;/code&gt; マクロ定義に追加します。</target>
        </trans-unit>
        <trans-unit id="84e25857657b333b201a4364df19960589319dca" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the &lt;code&gt;Binding&lt;/code&gt;s &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Binding&lt;/code&gt; s &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、および &lt;code&gt;c&lt;/code&gt; に docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="2f9a2f04c857c99469b4786ce6042e5c04d6c307" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the &lt;code&gt;Module&lt;/code&gt;&lt;code&gt;M&lt;/code&gt;. Adding the docstring above the &lt;code&gt;Module&lt;/code&gt; is the preferred syntax, however both are equivalent.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; &lt;code&gt;M&lt;/code&gt; に docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; を追加します。 &lt;code&gt;Module&lt;/code&gt; 上にdocstringを追加することをお勧めしますが、どちらも同等です。</target>
        </trans-unit>
        <trans-unit id="d607a4ba66a2defbbbd671ccd4f1fc3f1e66348d" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the function &lt;code&gt;f&lt;/code&gt;. The first version is the preferred syntax, however both are equivalent.</source>
          <target state="translated">docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; を関数 &lt;code&gt;f&lt;/code&gt; に追加します。最初のバージョンが推奨される構文ですが、どちらも同等です。</target>
        </trans-unit>
        <trans-unit id="015afea43fcf05b33dc7ee7ee68bca2953573884" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the macro named &lt;code&gt;@m&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@m&lt;/code&gt; という名前のマクロにdocstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="827af43a45abefcd341e6f719f9f401e5c730792" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the method &lt;code&gt;f(::Any)&lt;/code&gt;.</source>
          <target state="translated">docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; をメソッド &lt;code&gt;f(::Any)&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="c8df7e7a7df772447527b2f26ed82b0a9c8b23e3" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the value associated with &lt;code&gt;sym&lt;/code&gt;. Users should prefer documenting &lt;code&gt;sym&lt;/code&gt; at its definition.</source>
          <target state="translated">docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; を &lt;code&gt;sym&lt;/code&gt; に関連付けられた値に追加します。ユーザーは &lt;code&gt;sym&lt;/code&gt; をその定義で文書化することを好むはずです。</target>
        </trans-unit>
        <trans-unit id="7496f9703fbec9a9c078ee921645986d1520779f" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to two &lt;code&gt;Method&lt;/code&gt;s, namely &lt;code&gt;f(::Any)&lt;/code&gt; and &lt;code&gt;f(::Any, ::Any)&lt;/code&gt;.</source>
          <target state="translated">docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; を2つの &lt;code&gt;Method&lt;/code&gt; 、つまり &lt;code&gt;f(::Any)&lt;/code&gt; と &lt;code&gt;f(::Any, ::Any)&lt;/code&gt; 追加します。</target>
        </trans-unit>
        <trans-unit id="9c8aaa795c4bb3bd668d398ed223b6d5b98c3053" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;&quot;x&quot;&lt;/code&gt; to field &lt;code&gt;T.x&lt;/code&gt; and &lt;code&gt;&quot;y&quot;&lt;/code&gt; to field &lt;code&gt;T.y&lt;/code&gt;. Also applicable to &lt;code&gt;mutable struct&lt;/code&gt; types.</source>
          <target state="translated">docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; をタイプ &lt;code&gt;T&lt;/code&gt; に、 &lt;code&gt;&quot;x&quot;&lt;/code&gt; をフィールド &lt;code&gt;T.x&lt;/code&gt; 、 &lt;code&gt;&quot;y&quot;&lt;/code&gt; をフィールド &lt;code&gt;T.y&lt;/code&gt; 追加します。 &lt;code&gt;mutable struct&lt;/code&gt; 体型にも適用できます。</target>
        </trans-unit>
        <trans-unit id="509ef7b304e0d5048959f5a1e066b6245d575e62" translate="yes" xml:space="preserve">
          <source>Adds the docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to types &lt;code&gt;T1&lt;/code&gt;, &lt;code&gt;T2&lt;/code&gt;, and &lt;code&gt;T3&lt;/code&gt;.</source>
          <target state="translated">docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; をタイプ &lt;code&gt;T1&lt;/code&gt; 、 &lt;code&gt;T2&lt;/code&gt; 、および &lt;code&gt;T3&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="e9a51c66a638e61a03f3ba3bc6a5ae7966f901a4" translate="yes" xml:space="preserve">
          <source>Adjuster Functions</source>
          <target state="translated">アジャスター機能</target>
        </trans-unit>
        <trans-unit id="3ed15208c269239266d3575007709a349ee8dcb4" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; by iterating at most &lt;code&gt;limit&lt;/code&gt; iterations by &lt;code&gt;step&lt;/code&gt; increments until &lt;code&gt;func&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;func&lt;/code&gt; must take a single &lt;code&gt;TimeType&lt;/code&gt; argument and return a &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;same&lt;/code&gt; allows &lt;code&gt;dt&lt;/code&gt; to be considered in satisfying &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">調整するには、 &lt;code&gt;dt&lt;/code&gt; 最大で繰り返すことによって &lt;code&gt;limit&lt;/code&gt; により、反復 &lt;code&gt;step&lt;/code&gt; まで増加 &lt;code&gt;func&lt;/code&gt; 戻り &lt;code&gt;true&lt;/code&gt; 。 &lt;code&gt;func&lt;/code&gt; は単一の &lt;code&gt;TimeType&lt;/code&gt; 引数を取り、&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;を返す必要があります。 &lt;code&gt;same&lt;/code&gt; ことにより、 &lt;code&gt;func&lt;/code&gt; を満たすときに &lt;code&gt;dt&lt;/code&gt; を考慮することができます。</target>
        </trans-unit>
        <trans-unit id="542b7e7c2fd74f8d271308bdddf4ad37b5294110" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the Monday of its week.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; をその週の月曜日に調整します。</target>
        </trans-unit>
        <trans-unit id="ba3476b1421df6e3edaa8e17f787d5952e83be65" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the Sunday of its week.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; をその週の日曜日に調整します。</target>
        </trans-unit>
        <trans-unit id="3224cd68e5551ff4e3fc4fc6b2b947ffc7f24a64" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first &lt;code&gt;dow&lt;/code&gt; of its month. Alternatively, &lt;code&gt;of=Year&lt;/code&gt; will adjust to the first &lt;code&gt;dow&lt;/code&gt; of the year.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; をその月の最初の &lt;code&gt;dow&lt;/code&gt; に調整します。または、 &lt;code&gt;of=Year&lt;/code&gt; は年の最初の &lt;code&gt;dow&lt;/code&gt; に調整されます。</target>
        </trans-unit>
        <trans-unit id="85f046851c6e044a73b6195b73c28ea067eb7654" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first day of its month.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; をその月の最初の日に調整します。</target>
        </trans-unit>
        <trans-unit id="f4430fe642c3e3cf011a04583f6d0f8ce92cdee6" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first day of its quarter.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; をその四半期の最初の日に調整します。</target>
        </trans-unit>
        <trans-unit id="84bc65bd05f794b2297c4096e727f0dd2edbb9dd" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first day of its year.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; をその年の最初の日に調整します。</target>
        </trans-unit>
        <trans-unit id="2f0c9a334203505d658bff6209e3cc9cb72c986e" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last &lt;code&gt;dow&lt;/code&gt; of its month. Alternatively, &lt;code&gt;of=Year&lt;/code&gt; will adjust to the last &lt;code&gt;dow&lt;/code&gt; of the year.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; をその月の最後の &lt;code&gt;dow&lt;/code&gt; に調整します。または、 &lt;code&gt;of=Year&lt;/code&gt; はその年の最後の &lt;code&gt;dow&lt;/code&gt; に調整されます。</target>
        </trans-unit>
        <trans-unit id="78d3c49adba39ac1f401e060e547fe0cc0d6d99c" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last day of its month.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; をその月の最終日に調整します。</target>
        </trans-unit>
        <trans-unit id="64612df263c1926bf9efeecdbaf1b82e9cd07b8e" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last day of its quarter.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; をその四半期の最終日に調整します。</target>
        </trans-unit>
        <trans-unit id="91489c37594baa78e3476045075dafd7e9ef8e93" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last day of its year.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; をその年の最終日に調整します。</target>
        </trans-unit>
        <trans-unit id="f360011526f7451524f23fc8d46d352e948cc7d3" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the next day of week corresponding to &lt;code&gt;dow&lt;/code&gt; with &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt;. Setting &lt;code&gt;same=true&lt;/code&gt; allows the current &lt;code&gt;dt&lt;/code&gt; to be considered as the next &lt;code&gt;dow&lt;/code&gt;, allowing for no adjustment to occur.</source>
          <target state="translated">調整するには、 &lt;code&gt;dt&lt;/code&gt; に対応する週の次の日に &lt;code&gt;dow&lt;/code&gt; で &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt; 。 &lt;code&gt;same=true&lt;/code&gt; を設定すると、現在の &lt;code&gt;dt&lt;/code&gt; が次の &lt;code&gt;dow&lt;/code&gt; と見なされ、調整を行うことができなくなります。</target>
        </trans-unit>
        <trans-unit id="068372d2e011960d73021d80afa760372bcf985c" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the previous day of week corresponding to &lt;code&gt;dow&lt;/code&gt; with &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt;. Setting &lt;code&gt;same=true&lt;/code&gt; allows the current &lt;code&gt;dt&lt;/code&gt; to be considered as the previous &lt;code&gt;dow&lt;/code&gt;, allowing for no adjustment to occur.</source>
          <target state="translated">調整するには、 &lt;code&gt;dt&lt;/code&gt; に対応する週の前日に &lt;code&gt;dow&lt;/code&gt; で &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt; 。 &lt;code&gt;same=true&lt;/code&gt; を設定すると、現在の &lt;code&gt;dt&lt;/code&gt; が前の &lt;code&gt;dow&lt;/code&gt; と見なされ、調整を行うことができなくなります。</target>
        </trans-unit>
        <trans-unit id="59c3f81e00ff6162254f4463064f47b013b2418f" translate="yes" xml:space="preserve">
          <source>Admonitions</source>
          <target state="translated">Admonitions</target>
        </trans-unit>
        <trans-unit id="836a223dfb6110b2db06c9c781ddc336919a8a06" translate="yes" xml:space="preserve">
          <source>Admonitions, like most other toplevel elements, can contain other toplevel elements.</source>
          <target state="translated">戒めは、他のほとんどのトップレベル要素と同様に、他のトップレベル要素を含むことができます。</target>
        </trans-unit>
        <trans-unit id="b83b0b84935203a338ba6594cae9f540216d121e" translate="yes" xml:space="preserve">
          <source>Advance the iterator to obtain the next element. If no elements remain, &lt;code&gt;nothing&lt;/code&gt; should be returned. Otherwise, a 2-tuple of the next element and the new iteration state should be returned.</source>
          <target state="translated">イテレータを進めて、次の要素を取得します。要素が残っていない場合は、 &lt;code&gt;nothing&lt;/code&gt; も返されません。それ以外の場合は、次の要素の2タプルと新しい反復状態が返されます。</target>
        </trans-unit>
        <trans-unit id="4b6a7abaa616c69342aad0f3bc06d227b49b3cf3" translate="yes" xml:space="preserve">
          <source>Advance the stream &lt;code&gt;io&lt;/code&gt; such that the next-read character will be the first remaining for which &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. If the keyword argument &lt;code&gt;linecomment&lt;/code&gt; is specified, all characters from that character until the start of the next line are ignored.</source>
          <target state="translated">次の読み取り文字が、 &lt;code&gt;predicate&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; を返す最初の残りの文字になるようにストリーム &lt;code&gt;io&lt;/code&gt; を進めます。キーワード引数 &lt;code&gt;linecomment&lt;/code&gt; が指定されている場合、その文字から次の行の先頭までのすべての文字は無視されます。</target>
        </trans-unit>
        <trans-unit id="ec9c1eee60a6c8d412e86494c4538774b81ce815" translate="yes" xml:space="preserve">
          <source>Advanced Usage</source>
          <target state="translated">高度な使用法</target>
        </trans-unit>
        <trans-unit id="ff26be938424cf2d67217e2575645ca68557c533" translate="yes" xml:space="preserve">
          <source>Aerial Tramway</source>
          <target state="translated">路面電車</target>
        </trans-unit>
        <trans-unit id="c3753451b13262a44f9a5817e07e24e560603141" translate="yes" xml:space="preserve">
          <source>After a call like &lt;code&gt;x = 5; y = power_by_squaring(x, 4)&lt;/code&gt;, you would get the expected result: &lt;code&gt;x == 5 &amp;amp;&amp;amp; y == 625&lt;/code&gt;. However, now suppose that &lt;code&gt;*=&lt;/code&gt;, when used with matrices, instead mutated the left hand side. There would be two problems:</source>
          <target state="translated">&lt;code&gt;x = 5; y = power_by_squaring(x, 4)&lt;/code&gt; ような呼び出しの後; y = power_by_squaring（x、4）の場合、期待される結果が得られます： &lt;code&gt;x == 5 &amp;amp;&amp;amp; y == 625&lt;/code&gt; 。ただし、ここで &lt;code&gt;*=&lt;/code&gt; を行列と一緒に使用すると、代わりに左側が変更されたとします。2つの問題があります。</target>
        </trans-unit>
        <trans-unit id="db34be90d58adae735cb60ab04365869aa56065b" translate="yes" xml:space="preserve">
          <source>Airplane</source>
          <target state="translated">Airplane</target>
        </trans-unit>
        <trans-unit id="80135999396a20e42730a1c2e1dfae947e0952c1" translate="yes" xml:space="preserve">
          <source>Alarm Clock</source>
          <target state="translated">目覚まし時計</target>
        </trans-unit>
        <trans-unit id="4c76737983211c324879531ef47ac946ce297c2e" translate="yes" xml:space="preserve">
          <source>Alef Symbol / First Transfinite Cardinal</source>
          <target state="translated">アレフシンボル/第一トランスフィニットカーディナル</target>
        </trans-unit>
        <trans-unit id="f2f34a33d9ae0109b50986f6079e5b5b8422fa27" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;UndefInitializer()&lt;/code&gt;, which constructs an instance of the singleton type &lt;a href=&quot;#Core.UndefInitializer&quot;&gt;&lt;code&gt;UndefInitializer&lt;/code&gt;&lt;/a&gt;, used in array initialization to indicate the array-constructor-caller would like an uninitialized array.</source>
          <target state="translated">シングルトン型&lt;a href=&quot;#Core.UndefInitializer&quot;&gt; &lt;code&gt;UndefInitializer&lt;/code&gt; の&lt;/a&gt;インスタンスを構築する &lt;code&gt;UndefInitializer()&lt;/code&gt; のエイリアスは、配列の初期化で使用され、array-constructor-callerが初期化されていない配列を望んでいることを示します。</target>
        </trans-unit>
        <trans-unit id="38d75bc82e2c72130349f85ee2dea5673d201a42" translate="yes" xml:space="preserve">
          <source>Alien Monster</source>
          <target state="translated">エイリアンモンスター</target>
        </trans-unit>
        <trans-unit id="0c70d0069c9dc176b6060d55ab195149b38ec01a" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;export&lt;/code&gt;ed names (&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;), &lt;code&gt;MyModule.x&lt;/code&gt;, &lt;code&gt;MyModule.y&lt;/code&gt; and &lt;code&gt;MyModule.p&lt;/code&gt;</source>
          <target state="translated">すべての &lt;code&gt;export&lt;/code&gt; 名前（ &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; ）、 &lt;code&gt;MyModule.x&lt;/code&gt; 、 &lt;code&gt;MyModule.y&lt;/code&gt; 、および &lt;code&gt;MyModule.p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="91f95289d7bb9f459a113b14aa6caea6d6b0ee5b" translate="yes" xml:space="preserve">
          <source>All Equal To</source>
          <target state="translated">すべてに等しい</target>
        </trans-unit>
        <trans-unit id="59150af6415167841703220f4f97802416f10725" translate="yes" xml:space="preserve">
          <source>All I/O tasks, timers, REPL commands, etc are multiplexed onto a single OS thread via an event loop. A patched version of libuv (&lt;a href=&quot;http://docs.libuv.org/en/v1.x/&quot;&gt;http://docs.libuv.org/en/v1.x/&lt;/a&gt;) provides this functionality. Yield points provide for co-operatively scheduling multiple tasks onto the same OS thread. I/O tasks and timers yield implicitly while waiting for the event to occur. Calling &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/a&gt; explicitly allows for other tasks to be scheduled.</source>
          <target state="translated">すべてのI / Oタスク、タイマー、REPLコマンドなどは、イベントループを介して単一のOSスレッドに多重化されます。libuvのパッチバージョン（&lt;a href=&quot;http://docs.libuv.org/en/v1.x/&quot;&gt;http://docs.libuv.org/en/v1.x/&lt;/a&gt;）がこの機能を提供します。降伏点により、複数のタスクを同じOSスレッドに協調的にスケジュールできます。I / Oタスクとタイマーは、イベントの発生を待機している間、暗黙的に生成されます。&lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt; &lt;code&gt;yield&lt;/code&gt; を&lt;/a&gt;明示的に呼び出すと、他のタスクをスケジュールすることができます。</target>
        </trans-unit>
        <trans-unit id="e522896e2dfc730e2866839376a2a265314c5b2a" translate="yes" xml:space="preserve">
          <source>All Julia streams expose at least a &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method, taking the stream as their first argument, e.g.:</source>
          <target state="translated">すべてのJuliaストリームは、少なくとも&lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;メソッドと&lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;メソッドを公開し、ストリームを最初の引数として受け取ります。例：</target>
        </trans-unit>
        <trans-unit id="c6a6b81f53852c577455dd25f826592290abcb2e" translate="yes" xml:space="preserve">
          <source>All Objects</source>
          <target state="translated">すべてのオブジェクト</target>
        </trans-unit>
        <trans-unit id="b272413234229118c2015aaa68ca35bdb9c75799" translate="yes" xml:space="preserve">
          <source>All code in the REPL is evaluated in global scope, so a variable defined and assigned at top level will be a &lt;strong&gt;global&lt;/strong&gt; variable. Variables defined at top level scope inside modules are also global.</source>
          <target state="translated">REPLのすべてのコードはグローバルスコープで評価されるため、トップレベルで定義および割り当てられた変数は&lt;strong&gt;グローバル&lt;/strong&gt;変数になります。モジュール内の最上位スコープで定義された変数もグローバルです。</target>
        </trans-unit>
        <trans-unit id="d45486021b7cdd7677275ec32e5637b641c26f3c" translate="yes" xml:space="preserve">
          <source>All comma-separated expressions after &lt;code&gt;for&lt;/code&gt; are interpreted as ranges. Adding parentheses lets us add a third argument to &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; の後のすべてのコンマ区切りの式は、範囲として解釈されます。括弧を追加すると、&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; に&lt;/a&gt; 3番目の引数を追加できます。</target>
        </trans-unit>
        <trans-unit id="e1833bbb77ee3eab574ef8615d776277ec2b68aa" translate="yes" xml:space="preserve">
          <source>All connections are authenticated on both sides to ensure that only workers started by the master are allowed to connect to each other.</source>
          <target state="translated">すべての接続は双方で認証され、マスターによって開始されたワーカーのみがお互いに接続を許可されるようになっています。</target>
        </trans-unit>
        <trans-unit id="9ad5ec5b3a4aaf8bd9fb90db1fc3be44898322c8" translate="yes" xml:space="preserve">
          <source>All declared types (the &lt;code&gt;DataType&lt;/code&gt; variety) can be parameterized, with the same syntax in each case. We will discuss them in the following order: first, parametric composite types, then parametric abstract types, and finally parametric primitive types.</source>
          <target state="translated">すべての宣言された型（ &lt;code&gt;DataType&lt;/code&gt; の種類）は、いずれの場合も同じ構文でパラメーター化できます。最初にパラメトリック複合タイプ、次にパラメトリック抽象タイプ、最後にパラメトリックプリミティブタイプの順に説明します。</target>
        </trans-unit>
        <trans-unit id="d9c5dd854b32fb08dbc64da03bc88b2f5ca50052" translate="yes" xml:space="preserve">
          <source>All instances of some abstract types are by default considered &quot;sufficiently similar&quot; that a universal &lt;code&gt;convert&lt;/code&gt; definition is provided in Julia Base. For example, this definition states that it's valid to &lt;code&gt;convert&lt;/code&gt; any &lt;code&gt;Number&lt;/code&gt; type to any other by calling a 1-argument constructor:</source>
          <target state="translated">一部の抽象型のすべてのインスタンスは、デフォルトでは、Julia Baseで提供されている汎用 &lt;code&gt;convert&lt;/code&gt; 定義と「十分に類似」していると見なされます。たとえば、次の定義は、1つの引数のコンストラクターを呼び出すことにより &lt;code&gt;convert&lt;/code&gt; 任意の &lt;code&gt;Number&lt;/code&gt; 型を他の型に変換することが有効であることを示しています。</target>
        </trans-unit>
        <trans-unit id="40a2b8b6f65bf4cf79d2f004dafadcaa12f30e1e" translate="yes" xml:space="preserve">
          <source>All interface customization is done through the keyword only &lt;code&gt;TerminalMenus.config()&lt;/code&gt; function.</source>
          <target state="translated">すべてのインターフェイスのカスタマイズは、キーワードのみの &lt;code&gt;TerminalMenus.config()&lt;/code&gt; 関数を介して行われます。</target>
        </trans-unit>
        <trans-unit id="5e93c45e883f28df975e96b20e62c4d715867d52" translate="yes" xml:space="preserve">
          <source>All non-real parts of the diagonal will be ignored.</source>
          <target state="translated">対角線の実在しない部分はすべて無視されます。</target>
        </trans-unit>
        <trans-unit id="7f36c1fb18a59b1d9f547660c394427791f475ab" translate="yes" xml:space="preserve">
          <source>All of the logging macros &lt;code&gt;@debug&lt;/code&gt;, &lt;code&gt;@info&lt;/code&gt;, &lt;code&gt;@warn&lt;/code&gt; and &lt;code&gt;@error&lt;/code&gt; share common features that are described in detail in the documentation for the more general macro &lt;a href=&quot;#Base.CoreLogging.@logmsg&quot;&gt;&lt;code&gt;@logmsg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ロギングマクロ &lt;code&gt;@debug&lt;/code&gt; 、 &lt;code&gt;@info&lt;/code&gt; 、 &lt;code&gt;@warn&lt;/code&gt; 、および &lt;code&gt;@error&lt;/code&gt; はすべて、より一般的なマクロ&lt;a href=&quot;#Base.CoreLogging.@logmsg&quot;&gt; &lt;code&gt;@logmsg&lt;/code&gt; の&lt;/a&gt;ドキュメントで詳細に説明されている共通の機能を共有しています。</target>
        </trans-unit>
        <trans-unit id="97250d85e46e2f0063062a4fe00d04b5c8c86241" translate="yes" xml:space="preserve">
          <source>All operations on sparse matrices are carefully implemented to exploit the CSC data structure for performance, and to avoid expensive operations.</source>
          <target state="translated">疎な行列に対するすべての操作は,CSC データ構造を利用してパフォーマンスを向上させ,高価な操作を避けるために慎重に実装されています.</target>
        </trans-unit>
        <trans-unit id="d92bd72fff847012d04881678e278a18d2126812" translate="yes" xml:space="preserve">
          <source>All other combinations of arguments default to returning an &lt;code&gt;Array&lt;/code&gt;, but custom container types can define their own implementation and promotion-like rules to customize the result when they appear as arguments.</source>
          <target state="translated">他のすべての引数の組み合わせはデフォルトで &lt;code&gt;Array&lt;/code&gt; を返しますが、カスタムコンテナタイプは独自の実装とプロモーションのようなルールを定義して、引数として表示されるときの結果をカスタマイズできます。</target>
        </trans-unit>
        <trans-unit id="de25475b274a168126e2d504207af50116291e77" translate="yes" xml:space="preserve">
          <source>All processes can directly communicate with each other.</source>
          <target state="translated">すべてのプロセスは、お互いに直接通信することができます。</target>
        </trans-unit>
        <trans-unit id="7feddee30f64db86bbc24d86a29d550a804d3b31" translate="yes" xml:space="preserve">
          <source>All processes in a cluster share the same cookie which, by default, is a randomly generated string on the master process:</source>
          <target state="translated">クラスタ内のすべてのプロセスは同じクッキーを共有しますが、デフォルトではマスタープロセス上でランダムに生成された文字列です。</target>
        </trans-unit>
        <trans-unit id="ad59be0f62242de6d2f5d39eccfa83593fd9484b" translate="yes" xml:space="preserve">
          <source>All string types are subtypes of the abstract type &lt;code&gt;AbstractString&lt;/code&gt;, and external packages define additional &lt;code&gt;AbstractString&lt;/code&gt; subtypes (e.g. for other encodings). If you define a function expecting a string argument, you should declare the type as &lt;code&gt;AbstractString&lt;/code&gt; in order to accept any string type.</source>
          <target state="translated">すべての文字列型は抽象型 &lt;code&gt;AbstractString&lt;/code&gt; のサブタイプであり、外部パッケージは追加の &lt;code&gt;AbstractString&lt;/code&gt; サブタイプを定義します（他のエンコーディング用など）。文字列引数を期待する関数を定義する場合、文字列型を受け入れるために、その型を &lt;code&gt;AbstractString&lt;/code&gt; として宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="b0dc699cc676b22c3459d4cf16d1eaa2e5774729" translate="yes" xml:space="preserve">
          <source>All subtypes of &lt;code&gt;AbstractDateToken&lt;/code&gt; must define this method in order to be able to print a Date / DateTime object according to a &lt;code&gt;DateFormat&lt;/code&gt; containing that token.</source>
          <target state="translated">そのトークンを含む &lt;code&gt;DateFormat&lt;/code&gt; に従ってDate / DateTimeオブジェクトを出力できるようにするには、 &lt;code&gt;AbstractDateToken&lt;/code&gt; のすべてのサブタイプでこのメソッドを定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="1c882b6f017fe5d01060c9bf473577d13959404c" translate="yes" xml:space="preserve">
          <source>All the sorting and order related functions rely on a &quot;less than&quot; relation defining a total order on the values to be manipulated. The &lt;code&gt;isless&lt;/code&gt; function is invoked by default, but the relation can be specified via the &lt;code&gt;lt&lt;/code&gt; keyword.</source>
          <target state="translated">並べ替えと順序に関連するすべての関数は、操作する値の合計順序を定義する「より小」関係に依存しています。 &lt;code&gt;isless&lt;/code&gt; の機能はデフォルトで起動されたが、関係を介して指定することができる &lt;code&gt;lt&lt;/code&gt; キーワード。</target>
        </trans-unit>
        <trans-unit id="3c82535675951a4a1fb997658084e8ecb7b3e47f" translate="yes" xml:space="preserve">
          <source>All the standard trigonometric and hyperbolic functions are also defined:</source>
          <target state="translated">標準的な三角関数や双曲線関数もすべて定義されています。</target>
        </trans-unit>
        <trans-unit id="6670e96208b5b1af061bdf66066d2386e48cd71d" translate="yes" xml:space="preserve">
          <source>All workers in a cluster share the same &lt;a href=&quot;#man-cluster-cookie-1&quot;&gt;cookie&lt;/a&gt; as the master. When the cookie is unspecified, i.e, with the &lt;code&gt;--worker&lt;/code&gt; option, the worker tries to read it from its standard input. &lt;code&gt;LocalManager&lt;/code&gt; and &lt;code&gt;SSHManager&lt;/code&gt; both pass the cookie to newly launched workers via their standard inputs.</source>
          <target state="translated">クラスタ内のすべてのワーカーは、マスターと同じ&lt;a href=&quot;#man-cluster-cookie-1&quot;&gt;Cookie&lt;/a&gt;を共有します。Cookieが指定されていない場合、つまり &lt;code&gt;--worker&lt;/code&gt; オプションを使用している場合、ワーカーは標準入力からCookie を読み取ろうとします。 &lt;code&gt;LocalManager&lt;/code&gt; と &lt;code&gt;SSHManager&lt;/code&gt; はどちらも、標準入力を介してCookieを新しく起動したワーカーに渡します。</target>
        </trans-unit>
        <trans-unit id="cc1f71fefd88bfe7d7be3a2017ea32033d467364" translate="yes" xml:space="preserve">
          <source>Allocation of output container</source>
          <target state="translated">出力コンテナの割り当て</target>
        </trans-unit>
        <trans-unit id="dbd9853a9ad8ada702240986063881992112c9e5" translate="yes" xml:space="preserve">
          <source>Allowed Variable Names</source>
          <target state="translated">許可された変数名</target>
        </trans-unit>
        <trans-unit id="18ef6092b26e1508d93983ee74a79d58892de4c1" translate="yes" xml:space="preserve">
          <source>Almost Equal Or Equal To</source>
          <target state="translated">ほぼ同等</target>
        </trans-unit>
        <trans-unit id="1fbf3e4677335672b3087596163b48e552785b56" translate="yes" xml:space="preserve">
          <source>Almost Equal To</source>
          <target state="translated">にほぼ等しい</target>
        </trans-unit>
        <trans-unit id="7475fcee6d3c9395bedceacb414c243d6b969b91" translate="yes" xml:space="preserve">
          <source>Almost Equal To With Circumflex Accent</source>
          <target state="translated">ほぼイコールウィズサーカムフレックスアクセント</target>
        </trans-unit>
        <trans-unit id="2c35923911b4ba37311dbb677458e2c0adca9382" translate="yes" xml:space="preserve">
          <source>Alright, now that we have a better understanding of how generated functions work, let's use them to build some more advanced (and valid) functionality...</source>
          <target state="translated">さて、生成された関数がどのように動くのかをよりよく理解できたので、それを使ってより高度な (そして有効な)機能を構築してみましょう...</target>
        </trans-unit>
        <trans-unit id="c2ff920784db1defb83bee5378709d9aaacf2e45" translate="yes" xml:space="preserve">
          <source>Also notice the difference between &lt;code&gt;max.(a,b)&lt;/code&gt;, which &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt;s &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; elementwise over &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt;&lt;code&gt;maximum(a)&lt;/code&gt;&lt;/a&gt;, which finds the largest value within &lt;code&gt;a&lt;/code&gt;. The same relationship holds for &lt;code&gt;min.(a,b)&lt;/code&gt; and &lt;code&gt;minimum(a)&lt;/code&gt;.</source>
          <target state="translated">また、s &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;a&lt;/code&gt; および &lt;code&gt;b&lt;/code&gt; で要素ごとに&lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt; &lt;code&gt;max.(a,b)&lt;/code&gt; と、a内の最大値を見つける&lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt; &lt;code&gt;maximum(a)&lt;/code&gt; &lt;/a&gt;の違いにも注意し &lt;code&gt;a&lt;/code&gt; 。同じ関係が &lt;code&gt;min.(a,b)&lt;/code&gt; と &lt;code&gt;minimum(a)&lt;/code&gt; a）にも当てはまります。</target>
        </trans-unit>
        <trans-unit id="9c0081a46476345434d3719172fe53c135ada9e3" translate="yes" xml:space="preserve">
          <source>Also observe the significant distinction between &lt;code&gt;\xff&lt;/code&gt; and &lt;code&gt;\uff&lt;/code&gt;: the former escape sequence encodes the &lt;em&gt;byte 255&lt;/em&gt;, whereas the latter escape sequence represents the &lt;em&gt;code point 255&lt;/em&gt;, which is encoded as two bytes in UTF-8:</source>
          <target state="translated">また、有意な違いを観察する間 &lt;code&gt;\xff&lt;/code&gt; と &lt;code&gt;\uff&lt;/code&gt; ：前者のエスケープシーケンスは、コード&lt;em&gt;バイト255を&lt;/em&gt;後者のエスケープシーケンスを表すのに対し、&lt;em&gt;コードポイント255&lt;/em&gt; UTF-8で2バイトとして符号化されます：</target>
        </trans-unit>
        <trans-unit id="6bc9da3cb0ed97f96102bee03dd8744d00eda6b1" translate="yes" xml:space="preserve">
          <source>Also recommended is Bruce Dawson's &lt;a href=&quot;https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/&quot;&gt;series of blog posts on floating-point numbers&lt;/a&gt;.</source>
          <target state="translated">また&lt;a href=&quot;https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/&quot;&gt;、浮動小数点数に関する&lt;/a&gt; Bruce Dawsonの一連のブログ投稿もお勧めします。</target>
        </trans-unit>
        <trans-unit id="a4d960a868768098e1ba53fb3f2c0df8ab0a40a7" translate="yes" xml:space="preserve">
          <source>Also, &lt;em&gt;every&lt;/em&gt; binary operator supports a &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot version&lt;/a&gt; that can be applied to arrays (and combinations of arrays and scalars) in such &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;fused broadcasting operations&lt;/a&gt;, e.g. &lt;code&gt;z .== sin.(x .* y)&lt;/code&gt;.</source>
          <target state="translated">また、&lt;em&gt;すべての&lt;/em&gt;バイナリ演算子は、このような&lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;融合ブロードキャスト操作&lt;/a&gt;で配列（および配列とスカラーの組み合わせ）に適用できる&lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;ドットバージョン&lt;/a&gt;をサポートしています（例： &lt;code&gt;z .== sin.(x .* y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef09b3cc10de506de44d97115e3fd6f71c9ee1fa" translate="yes" xml:space="preserve">
          <source>Also, the function that arguments are splatted into need not be a varargs function (although it often is):</source>
          <target state="translated">また、引数がスプラットされる関数は varargs 関数である必要はありません (よくありますが)。</target>
        </trans-unit>
        <trans-unit id="a36cb69e8042fa50a20647f8ee8afd7f80876eda" translate="yes" xml:space="preserve">
          <source>Alternate syntax for open, where a string-based mode specifier is used instead of the five booleans. The values of &lt;code&gt;mode&lt;/code&gt; correspond to those from &lt;code&gt;fopen(3)&lt;/code&gt; or Perl &lt;code&gt;open&lt;/code&gt;, and are equivalent to setting the following boolean groups:</source>
          <target state="translated">5つのブール値の代わりに文字列ベースのモード指定子が使用される、openの代替構文。 &lt;code&gt;mode&lt;/code&gt; の値は、 &lt;code&gt;fopen(3)&lt;/code&gt; またはPerl &lt;code&gt;open&lt;/code&gt; の値に対応し、次のブールグループの設定と同等です。</target>
        </trans-unit>
        <trans-unit id="a084d20c27ad4b5e370e6e41af49a7a8b0bbbe9c" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;code&gt;using Module&lt;/code&gt; will import all exported &lt;code&gt;Module&lt;/code&gt; functions into the current namespace.</source>
          <target state="translated">または、 &lt;code&gt;using Module&lt;/code&gt; を使用すると、エクスポートされたすべての &lt;code&gt;Module&lt;/code&gt; 関数が現在の名前空間にインポートされます。</target>
        </trans-unit>
        <trans-unit id="cfd0514a347606051a7fccfba50cde275fcde17f" translate="yes" xml:space="preserve">
          <source>Alternatively, a sequence of pair arguments may be passed.</source>
          <target state="translated">あるいは、一連のペア引数を渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="05c4eee40518a92290ba5caa4623a48a40f59cc6" translate="yes" xml:space="preserve">
          <source>Alternatively, finer control and additional transformations may be be obtained by calling &lt;code&gt;Unicode.normalize(s; keywords...)&lt;/code&gt;, where any number of the following boolean keywords options (which all default to &lt;code&gt;false&lt;/code&gt; except for &lt;code&gt;compose&lt;/code&gt;) are specified:</source>
          <target state="translated">または、 &lt;code&gt;Unicode.normalize(s; keywords...)&lt;/code&gt; 呼び出すことにより、より細かい制御と追加の変換を取得できます。ここでは、次のブールキーワードオプション（ &lt;code&gt;compose&lt;/code&gt; を除いてすべてデフォルトで &lt;code&gt;false&lt;/code&gt; ）を指定します。</target>
        </trans-unit>
        <trans-unit id="010a2642adb5dc50cd6b75461c8c6c62daaeaa3c" translate="yes" xml:space="preserve">
          <source>Alternatively, for all methods but one you can insist that there is at least one element in the tuple:</source>
          <target state="translated">あるいは、1つのメソッド以外のすべてのメソッドについて、タプルに少なくとも1つの要素があることを主張することもできます。</target>
        </trans-unit>
        <trans-unit id="658838e4feeee97296786aaec18103d8deb93854" translate="yes" xml:space="preserve">
          <source>Alternatively, if you have already allocated the array you can generate a thin wrapper around its data:</source>
          <target state="translated">あるいは、すでに配列を確保している場合は、そのデータの周りに薄いラッパーを生成することもできます。</target>
        </trans-unit>
        <trans-unit id="09d124820084afee646f363e2b5b6737ae2fc063" translate="yes" xml:space="preserve">
          <source>Alternatively, look at the &lt;code&gt;embedding.c&lt;/code&gt; program in the Julia source tree in the &lt;code&gt;test/embedding/&lt;/code&gt; folder. The file &lt;code&gt;ui/repl.c&lt;/code&gt; program is another simple example of how to set &lt;code&gt;jl_options&lt;/code&gt; options while linking against &lt;code&gt;libjulia&lt;/code&gt;.</source>
          <target state="translated">または、 &lt;code&gt;test/embedding/&lt;/code&gt; フォルダーのJuliaソースツリーにある &lt;code&gt;embedding.c&lt;/code&gt; プログラムを確認します。ファイル &lt;code&gt;ui/repl.c&lt;/code&gt; プログラムは、 &lt;code&gt;libjulia&lt;/code&gt; にリンクするときに &lt;code&gt;jl_options&lt;/code&gt; オプションを設定する方法のもう1つの簡単な例です。</target>
        </trans-unit>
        <trans-unit id="138af7c8699b17e1331dd202694df9508d5db6a5" translate="yes" xml:space="preserve">
          <source>Although MATLAB users may find Julia's syntax familiar, Julia is not a MATLAB clone. There are major syntactic and functional differences. The following are some noteworthy differences that may trip up Julia users accustomed to MATLAB:</source>
          <target state="translated">MATLABユーザはJuliaの構文に見覚えがあるかもしれませんが、JuliaはMATLABのクローンではありません。構文的にも機能的にも大きな違いがあります。以下は、MATLABに慣れているJuliaのユーザを悩ませるような顕著な違いです。</target>
        </trans-unit>
        <trans-unit id="995141b8a0f9c91fdda45a6f5368f07495906a19" translate="yes" xml:space="preserve">
          <source>Although it is generally a good idea to return a fully initialized object from an inner constructor, it is possible to return incompletely initialized objects:</source>
          <target state="translated">内部コンストラクタから完全に初期化されたオブジェクトを返すのが一般的ですが、不完全に初期化されたオブジェクトを返すことも可能です。</target>
        </trans-unit>
        <trans-unit id="37777e78887373deee2eff18df3fa452fb79fe3f" translate="yes" xml:space="preserve">
          <source>Although it seems a simple concept, multiple dispatch on the types of values is perhaps the single most powerful and central feature of the Julia language. Core operations typically have dozens of methods:</source>
          <target state="translated">単純な概念のように見えますが、値の型に対する複数のディスパッチはおそらくJulia言語の最も強力で中心的な機能です。コアとなる操作には、一般的に数十個のメソッドがあります。</target>
        </trans-unit>
        <trans-unit id="29da1b638100965fc90d2d714395923c89f62871" translate="yes" xml:space="preserve">
          <source>Although one could, in principle, define methods for the &lt;code&gt;promote&lt;/code&gt; function directly, this would require many redundant definitions for all possible permutations of argument types. Instead, the behavior of &lt;code&gt;promote&lt;/code&gt; is defined in terms of an auxiliary function called &lt;a href=&quot;../../base/base/index#Base.promote_rule&quot;&gt;&lt;code&gt;promote_rule&lt;/code&gt;&lt;/a&gt;, which one can provide methods for. The &lt;code&gt;promote_rule&lt;/code&gt; function takes a pair of type objects and returns another type object, such that instances of the argument types will be promoted to the returned type. Thus, by defining the rule:</source>
          <target state="translated">原則として、 &lt;code&gt;promote&lt;/code&gt; 関数のメソッドを直接定義することもできますが、これには、引数タイプの可能なすべての順列に対して多くの冗長な定義が必要になります。代わりに、 &lt;code&gt;promote&lt;/code&gt; の動作は、メソッドを提供できる&lt;a href=&quot;../../base/base/index#Base.promote_rule&quot;&gt; &lt;code&gt;promote_rule&lt;/code&gt; &lt;/a&gt;と呼ばれる補助関数によって定義されます。 &lt;code&gt;promote_rule&lt;/code&gt; の関数は、引数の型のインスタンスが返される型に昇格されるように、タイプオブジェクトのペアを取り、別のタイプのオブジェクトを返します。したがって、ルールを定義することにより：</target>
        </trans-unit>
        <trans-unit id="b980acb1a668eb7b397d3aa918a20ac9dccd65cc" translate="yes" xml:space="preserve">
          <source>Although one sometimes speaks of dynamic languages as being &quot;typeless&quot;, they are definitely not: every object, whether primitive or user-defined, has a type. The lack of type declarations in most dynamic languages, however, means that one cannot instruct the compiler about the types of values, and often cannot explicitly talk about types at all. In static languages, on the other hand, while one can &amp;ndash; and usually must &amp;ndash; annotate types for the compiler, types exist only at compile time and cannot be manipulated or expressed at run time. In Julia, types are themselves run-time objects, and can also be used to convey information to the compiler.</source>
          <target state="translated">動的言語は「タイプレス」であると言われることもありますが、そうではありません。プリミティブであろうとユーザー定義であろうと、すべてのオブジェクトにはタイプがあります。ただし、ほとんどの動的言語では型宣言がないため、コンパイラーに値の型について指示することができず、型について明示的に話すことはできません。一方、静的言語では、コンパイラの型に注釈を付けることができ（通常は必須）、型はコンパイル時にのみ存在し、実行時に操作または表現することはできません。 Juliaでは、型自体がランタイムオブジェクトであり、コンパイラに情報を伝達するためにも使用できます。</target>
        </trans-unit>
        <trans-unit id="125f5076dabfcecbce55bdc53934ea25594cddd6" translate="yes" xml:space="preserve">
          <source>Although this seems innocent enough, the problem is that &lt;code&gt;0&lt;/code&gt; is an integer (of type &lt;code&gt;Int&lt;/code&gt;) and &lt;code&gt;x&lt;/code&gt; might be of any type. Thus, depending on the value of &lt;code&gt;x&lt;/code&gt;, this function might return a value of either of two types. This behavior is allowed, and may be desirable in some cases. But it can easily be fixed as follows:</source>
          <target state="translated">これは無実のように見えますが、問題は &lt;code&gt;0&lt;/code&gt; が整数（ &lt;code&gt;Int&lt;/code&gt; 型）であり、 &lt;code&gt;x&lt;/code&gt; が任意の型である可能性があることです。したがって、 &lt;code&gt;x&lt;/code&gt; の値に応じて、この関数は2つのタイプのいずれかの値を返す可能性があります。この動作は許可されており、場合によっては望ましいことがあります。ただし、次のように簡単に修正できます。</target>
        </trans-unit>
        <trans-unit id="0ec497a089c99ee5c6f04e61edfbbd31dd8344ae" translate="yes" xml:space="preserve">
          <source>Always gives the opposite answer as &lt;a href=&quot;../base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">常に反対の答えを&lt;a href=&quot;../base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt;として返します。</target>
        </trans-unit>
        <trans-unit id="d4fd498143f69490fe006adbf63236a973c15889" translate="yes" xml:space="preserve">
          <source>Always show the signature of a function at the top of the documentation, with a four-space indent so that it is printed as Julia code.</source>
          <target state="translated">関数のシグネチャは必ずドキュメントの先頭に表示してください。</target>
        </trans-unit>
        <trans-unit id="660916a9bd0a5e0c60196e069f980a7e1234e2f9" translate="yes" xml:space="preserve">
          <source>Amalgamation Or Coproduct</source>
          <target state="translated">併合または共同製品</target>
        </trans-unit>
        <trans-unit id="6ed272289e5ab5f2571a80ecd7c9ab3c53aaab06" translate="yes" xml:space="preserve">
          <source>Ambulance</source>
          <target state="translated">Ambulance</target>
        </trans-unit>
        <trans-unit id="6d1fa3121887df24f251a0892c85ff68056930fd" translate="yes" xml:space="preserve">
          <source>American Football</source>
          <target state="translated">アメリカンフットボール</target>
        </trans-unit>
        <trans-unit id="f035eead5c54745562ec49798968d1579aa5f09e" translate="yes" xml:space="preserve">
          <source>An 8-byte identifying header is written to the stream first. To avoid writing the header, construct a &lt;code&gt;Serializer&lt;/code&gt; and use it as the first argument to &lt;code&gt;serialize&lt;/code&gt; instead. See also &lt;a href=&quot;#Serialization.writeheader&quot;&gt;&lt;code&gt;Serialization.writeheader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">最初に8バイトの識別ヘッダーがストリームに書き込まれます。ヘッダを書き込まないようにするには、構築 &lt;code&gt;Serializer&lt;/code&gt; しての最初の引数として使用 &lt;code&gt;serialize&lt;/code&gt; 代わりに。&lt;a href=&quot;#Serialization.writeheader&quot;&gt; &lt;code&gt;Serialization.writeheader&lt;/code&gt; &lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="9f8eb9358e7cc36217bd2b82eb7c1c39f3757d67" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; that allows reading and performs writes by appending. Seeking and truncating are not supported. See &lt;a href=&quot;#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; for the available constructors. If &lt;code&gt;data&lt;/code&gt; is given, creates a &lt;code&gt;PipeBuffer&lt;/code&gt; to operate on a data vector, optionally specifying a size beyond which the underlying &lt;code&gt;Array&lt;/code&gt; may not be grown.</source>
          <target state="translated">追加によって読み取りを許可し、書き込みを実行する&lt;a href=&quot;#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt;。シークと切り捨てはサポートされていません。使用可能なコンストラクターについては、&lt;a href=&quot;#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt;を参照してください。場合 &lt;code&gt;data&lt;/code&gt; 与えられて、作成 &lt;code&gt;PipeBuffer&lt;/code&gt; を必要に応じて下地それを超えるサイズを指定する、データベクトル上で動作するように &lt;code&gt;Array&lt;/code&gt; 成長させることがないかもしれないが。</target>
        </trans-unit>
        <trans-unit id="46a38d582619a610af47f792a125ea49f7521df6" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt; is raised if all workers cannot be terminated before the requested &lt;code&gt;waitfor&lt;/code&gt; seconds.</source>
          <target state="translated">アン&lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; は、&lt;/a&gt;すべての労働者が要求する前に終了することができない場合にスローされる &lt;code&gt;waitfor&lt;/code&gt; 秒。</target>
        </trans-unit>
        <trans-unit id="1bb56954c25d718243d7106afdb56cc9d480c633" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AbstractRange&lt;/code&gt; giving the indices of the &lt;code&gt;k&lt;/code&gt;th diagonal of the matrix &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">AN &lt;code&gt;AbstractRange&lt;/code&gt; の指標を与える &lt;code&gt;k&lt;/code&gt; 番目の対角行列の &lt;code&gt;M&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="213f54bf4207eca3291be6421983a526dc7b3d7a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ArgumentError&lt;/code&gt; is thrown if &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values. Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the quantiles of non-missing values.</source>
          <target state="translated">アン &lt;code&gt;ArgumentError&lt;/code&gt; 場合にスローされる &lt;code&gt;itr&lt;/code&gt; 含まれている &lt;code&gt;NaN&lt;/code&gt; または&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;値を。&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;関数を使用して、 &lt;code&gt;missing&lt;/code&gt; エントリを省略し、欠落していない値の分位数を計算します。</target>
        </trans-unit>
        <trans-unit id="6168a5d96f0d40b398487557f6a06e26763f063a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ArgumentError&lt;/code&gt; is thrown if &lt;code&gt;v&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">アン &lt;code&gt;ArgumentError&lt;/code&gt; 場合にスローさ &lt;code&gt;v&lt;/code&gt; が含まれている &lt;code&gt;NaN&lt;/code&gt; または&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;値を。</target>
        </trans-unit>
        <trans-unit id="de0265152d952d723c42ab1da85aac224914443f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;N&lt;/code&gt; dimensional &lt;em&gt;strided&lt;/em&gt; array with elements of type &lt;code&gt;T&lt;/code&gt;. These arrays follow the &lt;a href=&quot;../../manual/interfaces/index#man-interface-strided-arrays-1&quot;&gt;strided array interface&lt;/a&gt;. If &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;StridedArray&lt;/code&gt;, then its elements are stored in memory with offsets, which may vary between dimensions but are constant within a dimension. For example, &lt;code&gt;A&lt;/code&gt; could have stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing &lt;code&gt;A&lt;/code&gt; along dimension &lt;code&gt;d&lt;/code&gt; jumps in memory by [&lt;code&gt;strides(A, d)&lt;/code&gt;] slots. Strided arrays are particularly important and useful because they can sometimes be passed directly as pointers to foreign language libraries like BLAS.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 次元の&lt;em&gt;ストライド&lt;/em&gt;型の要素を持つアレイ &lt;code&gt;T&lt;/code&gt; 。これらの配列は、&lt;a href=&quot;../../manual/interfaces/index#man-interface-strided-arrays-1&quot;&gt;ストライド配列インターフェースに&lt;/a&gt;従います。場合 &lt;code&gt;A&lt;/code&gt; がある &lt;code&gt;StridedArray&lt;/code&gt; 、その要素は、大きさの間で変化しなく寸法内で一定であることができるオフセットとメモリに格納されています。たとえば、 &lt;code&gt;A&lt;/code&gt; は次元1にストライド2を持ち、次元2にストライド3を持つことができます。次元 &lt;code&gt;d&lt;/code&gt; に沿って &lt;code&gt;A&lt;/code&gt; をインクリメントすると、[ &lt;code&gt;strides(A, d)&lt;/code&gt; ]スロットだけメモリ内でジャンプします。ストライド配列は、BLASなどの外国語ライブラリへのポインタとして直接渡される場合があるため、特に重要で便利です。</target>
        </trans-unit>
        <trans-unit id="aa4010002940515c72a60f1328742b5780fa5172" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;NTuple&lt;/code&gt; of &lt;code&gt;N&lt;/code&gt;&lt;code&gt;Int&lt;/code&gt;s used to represent the dimensions of an &lt;a href=&quot;#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">AN &lt;code&gt;NTuple&lt;/code&gt; の &lt;code&gt;N&lt;/code&gt; &lt;code&gt;Int&lt;/code&gt; Sはの寸法表すために使用&lt;a href=&quot;#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86ab7a7129a70bb02730939dd401c0c0cf3528b7" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;environment&lt;/em&gt; determines what &lt;code&gt;import X&lt;/code&gt; and &lt;code&gt;using X&lt;/code&gt; mean in various code contexts and what files these statements cause to be loaded. Julia understands two kinds of environments:</source>
          <target state="translated">&lt;em&gt;環境が&lt;/em&gt;決まり &lt;code&gt;import X&lt;/code&gt; と &lt;code&gt;using X&lt;/code&gt; ロードされるように、平均でさまざまなコードコンテキストをし、どのようなファイルこれらの文が引き起こします。ジュリアは2種類の環境を理解しています。</target>
        </trans-unit>
        <trans-unit id="d4692c48e17766970146c81604672bba8f6ba8a0" translate="yes" xml:space="preserve">
          <source>An HTML renderer would display this as: &lt;code&gt;Polar{Float64}&lt;/code&gt; complex number: 3.0</source>
          <target state="translated">HTMLレンダラーはこれを次のように表示します： &lt;code&gt;Polar{Float64}&lt;/code&gt; 複素数：3.0</target>
        </trans-unit>
        <trans-unit id="f5d640fb430f989eb8d86d4a923189e2c2ab6f36" translate="yes" xml:space="preserve">
          <source>An action signature (e.g. for committers, taggers, etc). Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt;&lt;code&gt;git_signature&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">アクションの署名（コミッター、タガーなど）。&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt; &lt;code&gt;git_signature&lt;/code&gt; &lt;/a&gt;構造体に一致します。</target>
        </trans-unit>
        <trans-unit id="831ca4165fd1236bfdc4d70ab9d199abd7cc83b7" translate="yes" xml:space="preserve">
          <source>An advanced example</source>
          <target state="translated">先進的な例</target>
        </trans-unit>
        <trans-unit id="d38eace5e9dd251808391417899bd07eb120ad72" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;Vector{StackFrame}&lt;/code&gt; provided for convenience; returned by calls to &lt;code&gt;stacktrace&lt;/code&gt;.</source>
          <target state="translated">便宜上提供された &lt;code&gt;Vector{StackFrame}&lt;/code&gt; のエイリアス。 &lt;code&gt;stacktrace&lt;/code&gt; の呼び出しによって返されます。</target>
        </trans-unit>
        <trans-unit id="90783e8e994e5b4a2ae87f94a62cbca8637e0361" translate="yes" xml:space="preserve">
          <source>An alternative is to create a &quot;view&quot; of the array, which is an array object (a &lt;code&gt;SubArray&lt;/code&gt;) that actually references the data of the original array in-place, without making a copy. (If you write to a view, it modifies the original array's data as well.) This can be done for individual slices by calling &lt;a href=&quot;../../base/arrays/index#Base.view&quot;&gt;&lt;code&gt;view&lt;/code&gt;&lt;/a&gt;, or more simply for a whole expression or block of code by putting &lt;a href=&quot;../../base/arrays/index#Base.@views&quot;&gt;&lt;code&gt;@views&lt;/code&gt;&lt;/a&gt; in front of that expression. For example:</source>
          <target state="translated">別の方法は、コピーを作成せずに元の配列のデータをインプレースで実際に参照する配列オブジェクト（ &lt;code&gt;SubArray&lt;/code&gt; ）である配列の「ビュー」を作成することです。（ビューに書き込むと、元の配列のデータも変更されます。）これは、&lt;a href=&quot;../../base/arrays/index#Base.view&quot;&gt; &lt;code&gt;view&lt;/code&gt; &lt;/a&gt;を呼び出すことで個々のスライスに対して行うことができます。より簡単には、式全体の前に&lt;a href=&quot;../../base/arrays/index#Base.@views&quot;&gt; &lt;code&gt;@views&lt;/code&gt; &lt;/a&gt;を置くことによって式またはコードのブロックに対して行うことができます。例えば：</target>
        </trans-unit>
        <trans-unit id="885d0eebcc9f4c68f23331045091c9a5f90ade43" translate="yes" xml:space="preserve">
          <source>An alternative to using hybrid integers or promoting to BigInts is to use saturating integer arithmetic, where adding to the largest integer value leaves it unchanged and likewise for subtracting from the smallest integer value. This is precisely what Matlab&amp;trade; does:</source>
          <target state="translated">ハイブリッド整数を使用するかBigIntsに昇格する代わりに、飽和整数演算を使用します。最大整数値に加算すると、不変のままになり、同様に最小整数値から減算されます。これは、正確にMatlab&amp;trade;が行うことです。</target>
        </trans-unit>
        <trans-unit id="91592a446374cc055177971cd79c3aca7e004b7f" translate="yes" xml:space="preserve">
          <source>An alternative way to invoke a macro over an array literal (or comprehension) is to juxtapose both without using parentheses. In this case, the array will be the only expression fed to the macro. The following syntax is equivalent (and different from &lt;code&gt;@name [a b] * v&lt;/code&gt;):</source>
          <target state="translated">配列リテラル（または内包表記）に対してマクロを呼び出す別の方法は、括弧を使用せずに両方を並置することです。この場合、配列はマクロに渡される唯一の式になります。次の構文は同等です（ &lt;code&gt;@name [a b] * v&lt;/code&gt; とは異なります）。</target>
        </trans-unit>
        <trans-unit id="f03a7e8903dd9860d01fd9cd12eaf55e1fc8996a" translate="yes" xml:space="preserve">
          <source>An analogous &quot;type-stability&quot; problem exists for variables used repeatedly within a function:</source>
          <target state="translated">関数内で繰り返し使用される変数には、類似の「型安定性」の問題が存在します。</target>
        </trans-unit>
        <trans-unit id="743741f9ed42719bff5265ccfe550c12e7459fce" translate="yes" xml:space="preserve">
          <source>An annotated git commit carries with it information about how it was looked up and why, so that rebase or merge operations have more information about the context of the commit. Conflict files contain information about the source/target branches in the merge which are conflicting, for instance. An annotated commit can refer to the tip of a remote branch, for instance when a &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt;&lt;code&gt;FetchHead&lt;/code&gt;&lt;/a&gt; is passed, or to a branch head described using &lt;code&gt;GitReference&lt;/code&gt;.</source>
          <target state="translated">注釈付きのgitコミットには、ルックアップの方法と理由に関する情報が含まれているため、リベースまたはマージ操作には、コミットのコンテキストに関する詳細情報が含まれます。競合ファイルには、たとえば競合しているマージのソース/ターゲットブランチに関する情報が含まれています。注釈付きコミットは、たとえば&lt;a href=&quot;#LibGit2.FetchHead&quot;&gt; &lt;code&gt;FetchHead&lt;/code&gt; &lt;/a&gt;が渡されたときなどのリモートブランチの先端、または &lt;code&gt;GitReference&lt;/code&gt; を使用して記述されたブランチヘッドを参照できます。</target>
        </trans-unit>
        <trans-unit id="0977e50dcc26db8fee5c84903315951fecb439bb" translate="yes" xml:space="preserve">
          <source>An anonymous function accepting multiple arguments can be written using the syntax &lt;code&gt;(x,y,z)-&amp;gt;2x+y-z&lt;/code&gt;. A zero-argument anonymous function is written as &lt;code&gt;()-&amp;gt;3&lt;/code&gt;. The idea of a function with no arguments may seem strange, but is useful for &quot;delaying&quot; a computation. In this usage, a block of code is wrapped in a zero-argument function, which is later invoked by calling it as &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">複数の引数を受け入れる無名関数は、構文 &lt;code&gt;(x,y,z)-&amp;gt;2x+y-z&lt;/code&gt; を使用して記述できます。引数なしの無名関数は &lt;code&gt;()-&amp;gt;3&lt;/code&gt; として記述されます。引数のない関数の考え方は奇妙に思えるかもしれませんが、計算を「遅らせる」のに役立ちます。この使用法では、コードのブロックはゼロ引数関数でラップされ、後で &lt;code&gt;f&lt;/code&gt; として呼び出すことによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="670132e18df0dbda4c7927cbfa1f5f772c1b879a" translate="yes" xml:space="preserve">
          <source>An array allowing for &lt;code&gt;missing&lt;/code&gt; values but which does not contain any such value can be converted back to an array which does not allow for missing values using &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;. If the array contains &lt;code&gt;missing&lt;/code&gt; values, a &lt;code&gt;MethodError&lt;/code&gt; is thrown during conversion</source>
          <target state="translated">&lt;code&gt;missing&lt;/code&gt; 値を許容するが、そのような値を含まない配列は、&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;を使用して欠損値を許容しない配列に変換し直すことができます。配列に &lt;code&gt;missing&lt;/code&gt; 値が含まれている場合、変換中に &lt;code&gt;MethodError&lt;/code&gt; がスローされます</target>
        </trans-unit>
        <trans-unit id="41ac00a0bf9a5b610ef1696b9ce7b1bd86b26f82" translate="yes" xml:space="preserve">
          <source>An array is a collection of objects stored in a multi-dimensional grid. In the most general case, an array may contain objects of type &lt;a href=&quot;../../base/base/index#Core.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt;. For most computational purposes, arrays should contain objects of a more specific type, such as &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">配列は、多次元グリッドに格納されているオブジェクトのコレクションです。最も一般的なケースでは、配列には&lt;a href=&quot;../../base/base/index#Core.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt;型のオブジェクトを含めることができます。ほとんどの計算目的では、配列には&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt;などのより具体的なタイプのオブジェクトを含める必要があります。</target>
        </trans-unit>
        <trans-unit id="4fe522b01ac3a23b4adab253f39d747e24150892" translate="yes" xml:space="preserve">
          <source>An array of paths for &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; statements to consider as project environments or package directories when loading code. It is populated based on the &lt;a href=&quot;../../manual/environment-variables/index#JULIA_LOAD_PATH-1&quot;&gt;&lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt;&lt;/a&gt; environment variable if set; otherwise it defaults to &lt;code&gt;[&quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt;. Entries starting with &lt;code&gt;@&lt;/code&gt; have special meanings:</source>
          <target state="translated">以下のためのパスの配列 &lt;code&gt;using&lt;/code&gt; して &lt;code&gt;import&lt;/code&gt; 文は、プロジェクトの環境やパッケージディレクトリコードをロードするよう検討します。設定されている場合は、&lt;a href=&quot;../../manual/environment-variables/index#JULIA_LOAD_PATH-1&quot;&gt; &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; &lt;/a&gt;環境変数に基づいて入力されます。それ以外の場合、デフォルトは &lt;code&gt;[&quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt; です。 &lt;code&gt;@&lt;/code&gt; で始まるエントリには特別な意味があります。</target>
        </trans-unit>
        <trans-unit id="cfcaca5094f1a9b10cd4725d7c73753c4f7c3e54" translate="yes" xml:space="preserve">
          <source>An array of scalar indices. This includes:</source>
          <target state="translated">スカラーインデックスの配列。これには以下のものが含まれます。</target>
        </trans-unit>
        <trans-unit id="81e3e729218c7a16f9993c281c977ad17183e8f6" translate="yes" xml:space="preserve">
          <source>An array of the command line arguments passed to Julia, as strings.</source>
          <target state="translated">Julia に文字列として渡されるコマンドライン引数の配列。</target>
        </trans-unit>
        <trans-unit id="a0af30d315d1e58152feb3e6efd0b431012c6b41" translate="yes" xml:space="preserve">
          <source>An array with a specific element type can be constructed using the syntax &lt;code&gt;T[A, B, C, ...]&lt;/code&gt;. This will construct a 1-d array with element type &lt;code&gt;T&lt;/code&gt;, initialized to contain elements &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, etc. For example, &lt;code&gt;Any[x, y, z]&lt;/code&gt; constructs a heterogeneous array that can contain any values.</source>
          <target state="translated">特定の要素タイプの配列は、構文 &lt;code&gt;T[A, B, C, ...]&lt;/code&gt; を使用して構築できます。これにより、要素タイプ &lt;code&gt;T&lt;/code&gt; の 1次元配列が構築され、要素 &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; などが含まれるように初期化されます。たとえば、 &lt;code&gt;Any[x, y, z]&lt;/code&gt; は、任意の値を含むことができる異種配列を構築します。</target>
        </trans-unit>
        <trans-unit id="d49e95020e020a9b4ba7b0d2bd91635b96ade391" translate="yes" xml:space="preserve">
          <source>An assert might be disabled at various optimization levels. Assert should therefore only be used as a debugging tool and not used for authentication verification (e.g., verifying passwords), nor should side effects needed for the function to work correctly be used inside of asserts.</source>
          <target state="translated">アサートは様々な最適化レベルで無効化される可能性があります。したがって、アサートはデバッグツールとしてのみ使用し、認証検証(パスワードの検証など)には使用しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="71e89ce9e3702ca0f3496a7358d3f83d3e141bca" translate="yes" xml:space="preserve">
          <source>An assignment introducing a variable used inside a function, type or macro definition need not come before its inner usage:</source>
          <target state="translated">関数、型、マクロ定義の内部で使用される変数を導入する代入は、その内部で使用される前に来る必要はありません。</target>
        </trans-unit>
        <trans-unit id="d60802623cdaa53cdbcd142bd02b31e05d1a86f4" translate="yes" xml:space="preserve">
          <source>An easy way to find out is to extract the body into another (regular) function:</source>
          <target state="translated">簡単に分かる方法は、別の(規則的な)機能に抽出することです。</target>
        </trans-unit>
        <trans-unit id="75ba7cfd59f985e2f5eac9d9bfbe0747c5db6475" translate="yes" xml:space="preserve">
          <source>An environment's graph is a multilevel map which assigns, for each &lt;code&gt;context&lt;/code&gt; UUID, a map from names to UUIDs, similar to the roots map but specific to that &lt;code&gt;context&lt;/code&gt;. When Julia sees &lt;code&gt;import X&lt;/code&gt; in the code of the package whose UUID is &lt;code&gt;context&lt;/code&gt;, it looks up the identity of &lt;code&gt;X&lt;/code&gt; as &lt;code&gt;graph[context][:X]&lt;/code&gt;. In particular, this means that &lt;code&gt;import X&lt;/code&gt; can refer to different packages depending on &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">環境のグラフはマルチレベルのマップで、各 &lt;code&gt;context&lt;/code&gt; UUIDに対して、ルートマップに似ていますが、その &lt;code&gt;context&lt;/code&gt; 固有の名前からUUIDへのマップを割り当てます。 Juliaは、UUIDが &lt;code&gt;context&lt;/code&gt; であるパッケージのコードで &lt;code&gt;import X&lt;/code&gt; を検出すると、 &lt;code&gt;X&lt;/code&gt; のIDを &lt;code&gt;graph[context][:X]&lt;/code&gt; として検索します。特に、これは、 &lt;code&gt;import X&lt;/code&gt; が &lt;code&gt;context&lt;/code&gt; 応じて異なるパッケージを参照できることを意味します。</target>
        </trans-unit>
        <trans-unit id="4e064b0051e803a86c003daf19461cf607e832da" translate="yes" xml:space="preserve">
          <source>An environment's roots map assigns package names to UUIDs for all the top-level dependencies that the environment makes available to the main project (i.e. the ones that can be loaded in &lt;code&gt;Main&lt;/code&gt;). When Julia encounters &lt;code&gt;import X&lt;/code&gt; in the main project, it looks up the identity of &lt;code&gt;X&lt;/code&gt; as &lt;code&gt;roots[:X]&lt;/code&gt;.</source>
          <target state="translated">環境のルートマップは、環境がメインプロジェクトで使用できるようにするすべてのトップレベルの依存関係（つまり、 &lt;code&gt;Main&lt;/code&gt; にロードできる依存関係）のUUIDにパッケージ名を割り当てます。Juliaがメインプロジェクトで &lt;code&gt;import X&lt;/code&gt; に遭遇すると、 &lt;code&gt;X&lt;/code&gt; のIDを &lt;code&gt;roots[:X]&lt;/code&gt; として検索します。</target>
        </trans-unit>
        <trans-unit id="5a6b075a0dfee676c2586ba796e8721ea7d846f5" translate="yes" xml:space="preserve">
          <source>An error occurred when running a module's &lt;code&gt;__init__&lt;/code&gt; function. The actual error thrown is available in the &lt;code&gt;.error&lt;/code&gt; field.</source>
          <target state="translated">モジュールの &lt;code&gt;__init__&lt;/code&gt; 関数の実行中にエラーが発生しました。スローされた実際のエラーは &lt;code&gt;.error&lt;/code&gt; フィールドで確認できます。</target>
        </trans-unit>
        <trans-unit id="f872e576e1623149d829361d58e2cd908722e2d7" translate="yes" xml:space="preserve">
          <source>An error occurred when trying to access &lt;code&gt;str&lt;/code&gt; at index &lt;code&gt;i&lt;/code&gt; that is not valid.</source>
          <target state="translated">無効なインデックス &lt;code&gt;i&lt;/code&gt; の &lt;code&gt;str&lt;/code&gt; にアクセスしようとしたときにエラーが発生しました。</target>
        </trans-unit>
        <trans-unit id="f33bd5b60514925c67cf1bcd27c0b818d1eaa51d" translate="yes" xml:space="preserve">
          <source>An error occurred while &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;ing, &lt;a href=&quot;#Base.require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;ing, or &lt;a href=&quot;#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; a file. The error specifics should be available in the &lt;code&gt;.error&lt;/code&gt; field.</source>
          <target state="translated">ファイルの取り込み、&lt;a href=&quot;#Base.require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt;中&lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt;エラーが発生しました。エラーの詳細は、 &lt;code&gt;.error&lt;/code&gt; フィールドで確認できます。</target>
        </trans-unit>
        <trans-unit id="07364c5431123506298c1f1b97819a8211a7dee0" translate="yes" xml:space="preserve">
          <source>An example of correct usage of &lt;code&gt;Val&lt;/code&gt; would be:</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; の正しい使用例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c493074be2f87d14f247d6f580604d1e79d5ee3a" translate="yes" xml:space="preserve">
          <source>An exception is raised if a global constant is requested to be cleared.</source>
          <target state="translated">グローバル定数のクリアが要求された場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="74b831638ce2bece413802b1ce5999bdb817b935" translate="yes" xml:space="preserve">
          <source>An explicit &lt;code&gt;global&lt;/code&gt; is needed to assign to a global variable:</source>
          <target state="translated">グローバル変数に割り当てるには、明示的 &lt;code&gt;global&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="fa929fb7568ac9e14759cbe89ba07ba8ca4d3c90" translate="yes" xml:space="preserve">
          <source>An expression wrapped in this manner is left alone by the macro expander and simply pasted into the output verbatim. Therefore it will be resolved in the macro call environment.</source>
          <target state="translated">このようにラップされた式は、マクロエキスパンダによって放置され、単にそのまま出力に貼り付けられます。したがって、マクロ呼び出し環境で解決されます。</target>
        </trans-unit>
        <trans-unit id="4f8ce9f561ef25fa8ebcdf84d21250bf4af4d01b" translate="yes" xml:space="preserve">
          <source>An immutable object might contain mutable objects, such as arrays, as fields. Those contained objects will remain mutable; only the fields of the immutable object itself cannot be changed to point to different objects.</source>
          <target state="translated">不変オブジェクトには、フィールドとして配列のような変異可能なオブジェクトが含まれている場合があります。不変オブジェクトのフィールドだけが異なるオブジェクトを指すように変更することはできません。</target>
        </trans-unit>
        <trans-unit id="a6b2f30177c22471afdf680fdefbc947052099b3" translate="yes" xml:space="preserve">
          <source>An implementation of an &lt;code&gt;AbstractWorkerPool&lt;/code&gt;. &lt;a href=&quot;#Distributed.remote&quot;&gt;&lt;code&gt;remote&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Distributed.remotecall_fetch-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt;&lt;code&gt;remotecall_fetch&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; (and other remote calls which execute functions remotely) benefit from caching the serialized/deserialized functions on the worker nodes, especially closures (which may capture large amounts of data).</source>
          <target state="translated">&lt;code&gt;AbstractWorkerPool&lt;/code&gt; の実装。&lt;a href=&quot;#Distributed.remote&quot;&gt; &lt;code&gt;remote&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#Distributed.remotecall_fetch-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt; &lt;code&gt;remotecall_fetch&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt;（およびリモートで関数を実行する他のリモート呼び出し）は、ワーカーノード、特にクロージャー（大量のデータをキャプチャする可能性がある）のシリアル化/非シリアル化関数をキャッシュすることでメリットを得ます。</target>
        </trans-unit>
        <trans-unit id="22b306a470a7687a028d866f374bb4a4513c3bca" translate="yes" xml:space="preserve">
          <source>An implementation of distributed memory parallel computing is provided by module &lt;code&gt;Distributed&lt;/code&gt; as part of the standard library shipped with Julia.</source>
          <target state="translated">分散メモリ並列計算の実装は、Juliaに付属する標準ライブラリの一部として、 &lt;code&gt;Distributed&lt;/code&gt; モジュールによって提供されます。</target>
        </trans-unit>
        <trans-unit id="d783ac603cd4b08c0d7cd2a76549bc1da1d2e64a" translate="yes" xml:space="preserve">
          <source>An important and powerful feature of Julia's type system is that it is parametric: types can take parameters, so that type declarations actually introduce a whole family of new types &amp;ndash; one for each possible combination of parameter values. There are many languages that support some version of &lt;a href=&quot;https://en.wikipedia.org/wiki/Generic_programming&quot;&gt;generic programming&lt;/a&gt;, wherein data structures and algorithms to manipulate them may be specified without specifying the exact types involved. For example, some form of generic programming exists in ML, Haskell, Ada, Eiffel, C++, Java, C#, F#, and Scala, just to name a few. Some of these languages support true parametric polymorphism (e.g. ML, Haskell, Scala), while others support ad-hoc, template-based styles of generic programming (e.g. C++, Java). With so many different varieties of generic programming and parametric types in various languages, we won't even attempt to compare Julia's parametric types to other languages, but will instead focus on explaining Julia's system in its own right. We will note, however, that because Julia is a dynamically typed language and doesn't need to make all type decisions at compile time, many traditional difficulties encountered in static parametric type systems can be relatively easily handled.</source>
          <target state="translated">Juliaの型システムの重要で強力な機能は、それがパラメトリックであることです。型はパラメーターを取ることができるため、型宣言は実際に新しい型のファミリー全体（パラメーター値の可能な組み合わせごとに1つ）を導入します。&lt;a href=&quot;https://en.wikipedia.org/wiki/Generic_programming&quot;&gt;一般的なプログラミングの&lt;/a&gt;いくつかのバージョンをサポートする多くの言語があります、データ構造とそれらを操作するアルゴリズムは、含まれる正確なタイプを指定せずに指定できます。たとえば、ML、Haskell、Ada、Eiffel、C ++、Java、C＃、F＃、Scalaには、いくつかの形式の汎用プログラミングが存在します。これらの言語の一部は真のパラメトリック多態性（ML、Haskell、Scalaなど）をサポートしていますが、他の言語はテンプレートベースの汎用プログラミング（C ++、Javaなど）をサポートしています。さまざまな言語での多種多様なジェネリックプログラミングとパラメトリックタイプがあるので、ジュリアのパラメトリックタイプを他の言語と比較することはせず、ジュリアのシステムの説明に重点を置きます。ただし、ジュリアは動的に型付けされた言語であり、コンパイル時にすべての型の決定を行う必要がないため、静的パラメトリックタイプのシステムで発生する多くの従来の問題は、比較的簡単に処理できます。</target>
        </trans-unit>
        <trans-unit id="a620af1ece25f934c185b8ddc35721eeb3f3fac2" translate="yes" xml:space="preserve">
          <source>An important point to note is that there is no loss in performance if the programmer relies on a function whose arguments are abstract types, because it is recompiled for each tuple of argument concrete types with which it is invoked. (There may be a performance issue, however, in the case of function arguments that are containers of abstract types; see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;.)</source>
          <target state="translated">注意すべき重要な点は、プログラマーが、引数が抽象型である関数に依存している場合、それが呼び出される引数具象型のタプルごとに再コンパイルされるため、パフォーマンスが低下しないことです。（ただし、抽象型のコンテナーである関数引数の場合、パフォーマンスの問題が発生する可能性があります。&lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;パフォーマンスのヒントを&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="8a07f992d12e5a1cbc667f425042e464cb426b62" translate="yes" xml:space="preserve">
          <source>An important thing to remember is that, once fetched, a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; will cache its value locally. Further &lt;code&gt;fetch&lt;/code&gt; calls do not entail a network hop. Once all referencing &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s have fetched, the remote stored value is deleted.</source>
          <target state="translated">覚えておくべき重要なことは、一度フェッチされると、&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;はその値をローカルにキャッシュするということです。それ以上の &lt;code&gt;fetch&lt;/code&gt; 呼び出しはネットワークホップを伴いません。参照しているすべての&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;がフェッチされると、リモートに保存された値は削除されます。</target>
        </trans-unit>
        <trans-unit id="4b9125cf95c1847e0bf4f4e8c480c3ff78274eac" translate="yes" xml:space="preserve">
          <source>An important use of abstract types is to provide default implementations for concrete types. To give a simple example, consider:</source>
          <target state="translated">抽象型の重要な使い方は、具象型のデフォルト実装を提供することです。簡単な例を挙げると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="46c08a285690627fd53df02bea8440f31cc7ca2d" translate="yes" xml:space="preserve">
          <source>An indexing operation into an &lt;code&gt;AbstractDict&lt;/code&gt; (&lt;code&gt;Dict&lt;/code&gt;) or &lt;code&gt;Set&lt;/code&gt; like object tried to access or delete a non-existent element.</source>
          <target state="translated">&lt;code&gt;AbstractDict&lt;/code&gt; （ &lt;code&gt;Dict&lt;/code&gt; ）または &lt;code&gt;Set&lt;/code&gt; likeオブジェクトへのインデックス操作で、存在しない要素にアクセスまたは削除しようとしました。</target>
        </trans-unit>
        <trans-unit id="c0ef57c4e27de9e0e08cd005dba316af8fe9863a" translate="yes" xml:space="preserve">
          <source>An indexing operation into an array, &lt;code&gt;a&lt;/code&gt;, tried to access an out-of-bounds element at index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">配列 &lt;code&gt;a&lt;/code&gt; へのインデックス操作で、インデックス &lt;code&gt;i&lt;/code&gt; の範囲外の要素にアクセスしようとしました。</target>
        </trans-unit>
        <trans-unit id="ba7dc87158f89283a983f53bb3f993c869462761" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Point{Float64}&lt;/code&gt; can be represented compactly and efficiently as an immediate pair of 64-bit values;</source>
          <target state="translated">&lt;code&gt;Point{Float64}&lt;/code&gt; のインスタンスは、64ビット値の直接のペアとしてコンパクトかつ効率的に表すことができます。</target>
        </trans-unit>
        <trans-unit id="81188cb690cdf51aa857fee109d4a9ecc33db0cb" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Point{Real}&lt;/code&gt; must be able to hold any pair of instances of &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt;. Since objects that are instances of &lt;code&gt;Real&lt;/code&gt; can be of arbitrary size and structure, in practice an instance of &lt;code&gt;Point{Real}&lt;/code&gt; must be represented as a pair of pointers to individually allocated &lt;code&gt;Real&lt;/code&gt; objects.</source>
          <target state="translated">インスタンス &lt;code&gt;Point{Real}&lt;/code&gt; のインスタンスの任意のペアを保持することができなければならない&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;Real&lt;/code&gt; のインスタンスであるオブジェクトは、任意のサイズと構造にすることができるため、実際には、 &lt;code&gt;Point{Real}&lt;/code&gt; インスタンスは、個別に割り当てられた &lt;code&gt;Real&lt;/code&gt; オブジェクトへのポインターのペアとして表す必要があります。</target>
        </trans-unit>
        <trans-unit id="d49ef831f7376a07158e43b82f759fbd73bc08a0" translate="yes" xml:space="preserve">
          <source>An issue that arises in more complex macros is that of &lt;a href=&quot;https://en.wikipedia.org/wiki/Hygienic_macro&quot;&gt;hygiene&lt;/a&gt;. In short, macros must ensure that the variables they introduce in their returned expressions do not accidentally clash with existing variables in the surrounding code they expand into. Conversely, the expressions that are passed into a macro as arguments are often &lt;em&gt;expected&lt;/em&gt; to evaluate in the context of the surrounding code, interacting with and modifying the existing variables. Another concern arises from the fact that a macro may be called in a different module from where it was defined. In this case we need to ensure that all global variables are resolved to the correct module. Julia already has a major advantage over languages with textual macro expansion (like C) in that it only needs to consider the returned expression. All the other variables (such as &lt;code&gt;msg&lt;/code&gt; in &lt;code&gt;@assert&lt;/code&gt; above) follow the &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;normal scoping block behavior&lt;/a&gt;.</source>
          <target state="translated">より複雑なマクロで発生する問題は、&lt;a href=&quot;https://en.wikipedia.org/wiki/Hygienic_macro&quot;&gt;衛生の問題&lt;/a&gt;です。つまり、マクロは、返された式に導入された変数が、展開先の周囲のコード内の既存の変数と誤って競合しないようにする必要があります。逆に、引数としてマクロに渡される式が&lt;em&gt;期待される&lt;/em&gt;ことが多い&lt;em&gt;&lt;/em&gt;周囲のコードのコンテキストで評価し、既存の変数と相互作用して変更します。別の懸念は、マクロがそれが定義された場所とは異なるモジュールで呼び出される可能性があるという事実から生じます。この場合、すべてのグローバル変数が正しいモジュールに解決されるようにする必要があります。 Juliaは、返された式を考慮するだけでよいという点で、テキストマクロ展開（Cなど）を備えた言語よりも優れています。 （例えば、他の全ての変数 &lt;code&gt;msg&lt;/code&gt; で &lt;code&gt;@assert&lt;/code&gt; 上記）が従う&lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;通常のスコープブロックの動作を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5758b288cd7216deea6832521aad4c2142aa23b0" translate="yes" xml:space="preserve">
          <source>An iterator that accesses each element of the array &lt;code&gt;A&lt;/code&gt;, returning &lt;code&gt;i =&amp;gt; x&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the index for the element and &lt;code&gt;x = A[i]&lt;/code&gt;. Identical to &lt;code&gt;pairs(A)&lt;/code&gt;, except that the style of index can be selected. Also similar to &lt;code&gt;enumerate(A)&lt;/code&gt;, except &lt;code&gt;i&lt;/code&gt; will be a valid index for &lt;code&gt;A&lt;/code&gt;, while &lt;code&gt;enumerate&lt;/code&gt; always counts from 1 regardless of the indices of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">配列 &lt;code&gt;A&lt;/code&gt; の各要素にアクセスする反復子 &lt;code&gt;i =&amp;gt; x&lt;/code&gt; 返します。ここで、 &lt;code&gt;i&lt;/code&gt; は要素のインデックスであり、 &lt;code&gt;x = A[i]&lt;/code&gt; です。インデックスのスタイルを選択できることを除いて、 &lt;code&gt;pairs(A)&lt;/code&gt; と同じです。 &lt;code&gt;enumerate(A)&lt;/code&gt; にも似ていますが、 &lt;code&gt;i&lt;/code&gt; が &lt;code&gt;A&lt;/code&gt; の有効なインデックスになるのに対し、 &lt;code&gt;enumerate&lt;/code&gt; は &lt;code&gt;A&lt;/code&gt; のインデックスに関係なく常に1からカウントされます。</target>
        </trans-unit>
        <trans-unit id="b7a506ba2a82dcb065490fadb0cc0de3162d7501" translate="yes" xml:space="preserve">
          <source>An iterator that counts forever, starting at &lt;code&gt;start&lt;/code&gt; and incrementing by &lt;code&gt;step&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; から始まり、 &lt;code&gt;step&lt;/code&gt; ずつ増加する、永久にカウントするイテレータ。</target>
        </trans-unit>
        <trans-unit id="48922b72538924c877a99f16d2a1501116dd1387" translate="yes" xml:space="preserve">
          <source>An iterator that cycles through &lt;code&gt;iter&lt;/code&gt; forever. If &lt;code&gt;iter&lt;/code&gt; is empty, so is &lt;code&gt;cycle(iter)&lt;/code&gt;.</source>
          <target state="translated">反復を永久に &lt;code&gt;iter&lt;/code&gt; 反復子。 &lt;code&gt;iter&lt;/code&gt; が空の場合、 &lt;code&gt;cycle(iter)&lt;/code&gt; も空になります。</target>
        </trans-unit>
        <trans-unit id="2529486fdd6052d642060ef494ef6207d50e0319" translate="yes" xml:space="preserve">
          <source>An iterator that generates all but the first &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter&lt;/code&gt; の最初の &lt;code&gt;n&lt;/code&gt; 個の要素を除くすべてを生成するイテレータ。</target>
        </trans-unit>
        <trans-unit id="225cd1fc20e6b5e9157d6660f2d5a16cf5eaa208" translate="yes" xml:space="preserve">
          <source>An iterator that generates at most the first &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter&lt;/code&gt; の最初の &lt;code&gt;n&lt;/code&gt; 個の要素を生成するイテレータ。</target>
        </trans-unit>
        <trans-unit id="0e73058facca13f8b20620aa03238c21f3f77bff" translate="yes" xml:space="preserve">
          <source>An iterator that generates the value &lt;code&gt;x&lt;/code&gt; forever. If &lt;code&gt;n&lt;/code&gt; is specified, generates &lt;code&gt;x&lt;/code&gt; that many times (equivalent to &lt;code&gt;take(repeated(x), n)&lt;/code&gt;).</source>
          <target state="translated">値 &lt;code&gt;x&lt;/code&gt; を永久に生成する反復子。 &lt;code&gt;n&lt;/code&gt; が指定されている場合、 &lt;code&gt;x&lt;/code&gt; を何度も生成し &lt;code&gt;take(repeated(x), n)&lt;/code&gt; と同じ）。</target>
        </trans-unit>
        <trans-unit id="36e9bbba550395bdb9417724cabe5c648e9c151a" translate="yes" xml:space="preserve">
          <source>An iterator that yields &lt;code&gt;(i, x)&lt;/code&gt; where &lt;code&gt;i&lt;/code&gt; is a counter starting at 1, and &lt;code&gt;x&lt;/code&gt; is the &lt;code&gt;i&lt;/code&gt;th value from the given iterator. It's useful when you need not only the values &lt;code&gt;x&lt;/code&gt; over which you are iterating, but also the number of iterations so far. Note that &lt;code&gt;i&lt;/code&gt; may not be valid for indexing &lt;code&gt;iter&lt;/code&gt;; it's also possible that &lt;code&gt;x != iter[i]&lt;/code&gt;, if &lt;code&gt;iter&lt;/code&gt; has indices that do not start at 1. See the &lt;code&gt;pairs(IndexLinear(), iter)&lt;/code&gt; method if you want to ensure that &lt;code&gt;i&lt;/code&gt; is an index.</source>
          <target state="translated">&lt;code&gt;(i, x)&lt;/code&gt; を生成する反復子。ここで、 &lt;code&gt;i&lt;/code&gt; は1から始まるカウンター、 &lt;code&gt;x&lt;/code&gt; は指定された反復子の &lt;code&gt;i&lt;/code&gt; 番目の値です。これは、反復する &lt;code&gt;x&lt;/code&gt; の値だけでなく、これまでの反復回数も必要な場合に役立ちます。注意 &lt;code&gt;i&lt;/code&gt; インデックスのために有効ではない可能性が &lt;code&gt;iter&lt;/code&gt; 。そのことも可能です &lt;code&gt;x != iter[i]&lt;/code&gt; 場合は、 &lt;code&gt;iter&lt;/code&gt; 1を参照してくださいでは始まらない指標がある &lt;code&gt;pairs(IndexLinear(), iter)&lt;/code&gt; あなたがいることを確実にしたい場合はこの方法を &lt;code&gt;i&lt;/code&gt; インデックスです。</target>
        </trans-unit>
        <trans-unit id="266c36edd3f7797ff58b1ca95649bcf6b5c4372b" translate="yes" xml:space="preserve">
          <source>An iterator that yields the same elements as &lt;code&gt;iter&lt;/code&gt;, but starting at the given &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter&lt;/code&gt; と同じ要素を生成するが、指定された &lt;code&gt;state&lt;/code&gt; から始まるイテレータ。</target>
        </trans-unit>
        <trans-unit id="5702ee8b32ef9343efe014a1fb61b5e64e3eeb50" translate="yes" xml:space="preserve">
          <source>An object of type &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt;&lt;code&gt;UniformScaling&lt;/code&gt;&lt;/a&gt;, representing an identity matrix of any size.</source>
          <target state="translated">任意のサイズの単位行列を表す&lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt; &lt;code&gt;UniformScaling&lt;/code&gt; &lt;/a&gt;型のオブジェクト。</target>
        </trans-unit>
        <trans-unit id="71c4c33f82250491a99ad21209540c93bfa32676" translate="yes" xml:space="preserve">
          <source>An object that represents an array of scalar indices and can be converted to such by &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt;&lt;code&gt;to_indices&lt;/code&gt;&lt;/a&gt;. By default this includes:</source>
          <target state="translated">スカラーインデックスの配列を表すオブジェクトで、&lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt; &lt;code&gt;to_indices&lt;/code&gt; &lt;/a&gt;によってそれに変換できます。デフォルトでは以下が含まれます：</target>
        </trans-unit>
        <trans-unit id="d4b6750cc125525c2ec2f6b1301138ae1f12a25d" translate="yes" xml:space="preserve">
          <source>An object that safely references data of type &lt;code&gt;T&lt;/code&gt;. This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the &lt;code&gt;Ref&lt;/code&gt; itself is referenced.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; のデータを安全に参照するオブジェクト。このタイプは、ジュリアが割り当てた正しいタイプの有効なメモリを指すことが保証されています。基になるデータは、 &lt;code&gt;Ref&lt;/code&gt; 自体が参照されている限り、ガベージコレクターによる解放から保護されます。</target>
        </trans-unit>
        <trans-unit id="89e56b05f03b0a54be4311a52e3844ad08220010" translate="yes" xml:space="preserve">
          <source>An object with an immutable type may be copied freely by the compiler since its immutability makes it impossible to programmatically distinguish between the original object and a copy.</source>
          <target state="translated">不変型を持つオブジェクトは、その不変性により、プログラム上で元のオブジェクトとコピーを区別することができないため、コンパイラによって自由にコピーすることができます。</target>
        </trans-unit>
        <trans-unit id="85eb57c0af1152d6c55f74e29c04701d2792e006" translate="yes" xml:space="preserve">
          <source>An operation allocated too much memory for either the system or the garbage collector to handle properly.</source>
          <target state="translated">システムまたはガベージコレクタが適切に処理するためにメモリを割り当てすぎた操作。</target>
        </trans-unit>
        <trans-unit id="51b16b4dd3a608065010ab050f1c044d587e4984" translate="yes" xml:space="preserve">
          <source>An operation tried to write to memory that is read-only.</source>
          <target state="translated">読み取り専用のメモリへの書き込みを試みました。</target>
        </trans-unit>
        <trans-unit id="0cdeff47b1133140cdc39aa6281a4193e4a3fd25" translate="yes" xml:space="preserve">
          <source>An optimized method for matrix-matrix operations is available</source>
          <target state="translated">行列-行列演算のために最適化された手法が利用可能です。</target>
        </trans-unit>
        <trans-unit id="0f3dca7e150e49f15f11e7561b432ec79e089bf1" translate="yes" xml:space="preserve">
          <source>An optimized method for matrix-scalar operations is available</source>
          <target state="translated">行列スカラ演算のための最適化された手法が利用可能です。</target>
        </trans-unit>
        <trans-unit id="061f7a534d622ec7d7b76381cb35a581642e8473" translate="yes" xml:space="preserve">
          <source>An optimized method for matrix-vector operations is available</source>
          <target state="translated">行列ベクトル演算のために最適化された手法が利用可能です</target>
        </trans-unit>
        <trans-unit id="1459d918f4690c46e6b424c4fc07b16a81bb1321" translate="yes" xml:space="preserve">
          <source>An optimized method to find all the characteristic values and/or vectors is available</source>
          <target state="translated">すべての特性値および/またはベクトルを見つけるための最適化された方法が利用可能です。</target>
        </trans-unit>
        <trans-unit id="cf356b7797f09dd430255cabba22e6b669b5778d" translate="yes" xml:space="preserve">
          <source>An optimized method to find the &lt;code&gt;il&lt;/code&gt;th through the &lt;code&gt;ih&lt;/code&gt;th characteristic values are available</source>
          <target state="translated">&lt;code&gt;il&lt;/code&gt; 番目から &lt;code&gt;ih&lt;/code&gt; 番目までの特性値を見つけるための最適化された方法が利用可能</target>
        </trans-unit>
        <trans-unit id="55662dcd806465abd15ea9ee92465cc49d4f4bb3" translate="yes" xml:space="preserve">
          <source>An optimized method to find the characteristic values in the interval [&lt;code&gt;vl&lt;/code&gt;, &lt;code&gt;vh&lt;/code&gt;] is available</source>
          <target state="translated">間隔[ &lt;code&gt;vl&lt;/code&gt; 、 &lt;code&gt;vh&lt;/code&gt; ] の特性値を見つけるための最適化された方法が利用可能です</target>
        </trans-unit>
        <trans-unit id="06771105d28cfe0fe650b94de200ff6d276e071c" translate="yes" xml:space="preserve">
          <source>An optimized method to find the characteristic vectors corresponding to the characteristic values &lt;code&gt;x=[x1, x2,...]&lt;/code&gt; is available</source>
          <target state="translated">特性値 &lt;code&gt;x=[x1, x2,...]&lt;/code&gt; 対応する特性ベクトルを見つけるための最適化された方法が利用可能です</target>
        </trans-unit>
        <trans-unit id="f0a93e7d7160ec681ea6d7e4c04a7926b5ad27e7" translate="yes" xml:space="preserve">
          <source>An ordered list may start from a number other than one, as in the second list of the above example, where it is numbered from five. As with unordered lists, ordered lists can contain nested toplevel elements.</source>
          <target state="translated">順序付きリストは、上記の例の 2 番目のリストのように、1 以外の番号から開始することができ、5 から番号が付けられています。順不同のリストと同様に、順不同のリストは入れ子になったトップレベル要素を含むことができます。</target>
        </trans-unit>
        <trans-unit id="03ca662d4f2c4b45816c66be6d31e3cf1480577f" translate="yes" xml:space="preserve">
          <source>An unsigned 64-bit integer (&lt;code&gt;uint64_t&lt;/code&gt;) that sets the maximum number of threads available to Julia. If &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; exceeds the number of available physical CPU cores, then the number of threads is set to the number of cores. If &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; is not positive or is not set, or if the number of CPU cores cannot be determined through system calls, then the number of threads is set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Juliaが使用できるスレッドの最大数を設定する符号なし64ビット整数（ &lt;code&gt;uint64_t&lt;/code&gt; ）。 &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; が使用可能な物理CPUコアの数を超える場合、スレッドの数はコアの数に設定されます。場合は &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; 正でないか、設定されていないか、CPUコアの数は、システムコールを介して決定することができない場合、スレッドの数は次のように設定されている &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d32b092601fd9ebd2ac1ea5cb15d47455e3d9c4d" translate="yes" xml:space="preserve">
          <source>An updating operator rebinds the variable on the left-hand side. As a result, the type of the variable may change.</source>
          <target state="translated">更新演算子は、左側の変数をリバインドします。その結果、変数の型が変わることがあります。</target>
        </trans-unit>
        <trans-unit id="8f8c77e7404ca30dcccf92c73c985f04a86420e7" translate="yes" xml:space="preserve">
          <source>Anchor</source>
          <target state="translated">Anchor</target>
        </trans-unit>
        <trans-unit id="e370a7226632723025763723f6dafd8d5d0d959c" translate="yes" xml:space="preserve">
          <source>And With Dot</source>
          <target state="translated">そして、ドットと一緒に</target>
        </trans-unit>
        <trans-unit id="fbef2e39e8fb91e6824e3edcfe418b3f32f423c2" translate="yes" xml:space="preserve">
          <source>And using that testset looks like:</source>
          <target state="translated">そして、そのテストセットを使用すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="1f5999305ceff8dd17e050846ba5e997ba6e59ae" translate="yes" xml:space="preserve">
          <source>Anger Symbol</source>
          <target state="translated">怒りのシンボル</target>
        </trans-unit>
        <trans-unit id="1fd70473fb3de634b409d4acaf49ffc1f90aae1f" translate="yes" xml:space="preserve">
          <source>Angle</source>
          <target state="translated">Angle</target>
        </trans-unit>
        <trans-unit id="b2a770be59cfda02ac18ae81ca3c69433ca33eac" translate="yes" xml:space="preserve">
          <source>Angle With S Inside</source>
          <target state="translated">内側のSとの角度</target>
        </trans-unit>
        <trans-unit id="2f17bd9fe54b168046c3599d1ee65207477b51c2" translate="yes" xml:space="preserve">
          <source>Angle With Underbar</source>
          <target state="translated">アンダーバーとの角度</target>
        </trans-unit>
        <trans-unit id="235bfce3d68318529750179e362f5eb792952c9e" translate="yes" xml:space="preserve">
          <source>Angry Face</source>
          <target state="translated">怒り顔</target>
        </trans-unit>
        <trans-unit id="5dcf9d8e34d0e0dc6accf2e555a98e501316d5eb" translate="yes" xml:space="preserve">
          <source>Angstrom Sign / Angstrom Unit</source>
          <target state="translated">アングストロームサイン/アングストロームユニット</target>
        </trans-unit>
        <trans-unit id="51cb7e1a070afb2a7be72806c484010b0b12881a" translate="yes" xml:space="preserve">
          <source>Anguished Face</source>
          <target state="translated">苦悩した顔</target>
        </trans-unit>
        <trans-unit id="0a391a1d197db6b3528b4037a38a99b886bf2ca2" translate="yes" xml:space="preserve">
          <source>Annotate a &lt;code&gt;for&lt;/code&gt; loop to allow the compiler to take extra liberties to allow loop re-ordering</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ループに注釈を付けて、コンパイラーが追加の自由を取り、ループの並べ替えを可能にする</target>
        </trans-unit>
        <trans-unit id="7c44ae2875c05d9e420a1ee94f547ea8d42d5f9f" translate="yes" xml:space="preserve">
          <source>Annotate values taken from untyped locations</source>
          <target state="translated">タイプされていない場所から取得した値をアノテーションする</target>
        </trans-unit>
        <trans-unit id="80abb045be1e210007d2a8998883d6f2947e4f8f" translate="yes" xml:space="preserve">
          <source>Annotates the expression &lt;code&gt;blk&lt;/code&gt; as a bounds checking block, allowing it to be elided by &lt;a href=&quot;#Base.@inbounds&quot;&gt;&lt;code&gt;@inbounds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">式 &lt;code&gt;blk&lt;/code&gt; に境界チェックブロックとして注釈を付け、&lt;a href=&quot;#Base.@inbounds&quot;&gt; &lt;code&gt;@inbounds&lt;/code&gt; &lt;/a&gt;によってブロックを省略できるようにします。</target>
        </trans-unit>
        <trans-unit id="6f497993755de46018a5ff1778be3f6bc999629d" translate="yes" xml:space="preserve">
          <source>Anonymous Functions</source>
          <target state="translated">匿名機能</target>
        </trans-unit>
        <trans-unit id="3f2245e0442788d1d0364df60f4a6e67754d3e89" translate="yes" xml:space="preserve">
          <source>Another common solution is to separate the reader and writer of the pipeline into separate &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s:</source>
          <target state="translated">別の一般的な解決策は、パイプラインのリーダーとライターを別々の&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;に分離することです。</target>
        </trans-unit>
        <trans-unit id="fcd743f506f81055a92cce92b547fdb1e7daceb8" translate="yes" xml:space="preserve">
          <source>Another helper type is currently available for other cases, &lt;code&gt;Random.SamplerTag&lt;/code&gt;, but is considered as internal API, and can break at any time without proper deprecations.</source>
          <target state="translated">現在、別のヘルパータイプである &lt;code&gt;Random.SamplerTag&lt;/code&gt; が利用可能ですが、内部APIと見なされ、適切に非推奨にすることなくいつでも中断できます。</target>
        </trans-unit>
        <trans-unit id="9b1d07d46031acec2c359f730da8bb2e51e75efb" translate="yes" xml:space="preserve">
          <source>Another non-standard version specification extension allows one to use a trailing &lt;code&gt;+&lt;/code&gt; to express an upper limit on build versions, e.g. &lt;code&gt;VERSION &amp;gt; v&quot;0.2-rc1+&quot;&lt;/code&gt; can be used to mean any version above &lt;code&gt;0.2-rc1&lt;/code&gt; and any of its builds: it will return &lt;code&gt;false&lt;/code&gt; for version &lt;code&gt;v&quot;0.2-rc1+win64&quot;&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;v&quot;0.2-rc2&quot;&lt;/code&gt;.</source>
          <target state="translated">もう1つの非標準バージョン仕様拡張により、末尾の &lt;code&gt;+&lt;/code&gt; を使用してビルドバージョンの上限を表すことができます。たとえば、 &lt;code&gt;VERSION &amp;gt; v&quot;0.2-rc1+&quot;&lt;/code&gt; は、 &lt;code&gt;0.2-rc1&lt;/code&gt; を超えるバージョンとそのビルドを意味します。戻ります &lt;code&gt;false&lt;/code&gt; バージョンのための &lt;code&gt;v&quot;0.2-rc1+win64&quot;&lt;/code&gt; と &lt;code&gt;true&lt;/code&gt; のための &lt;code&gt;v&quot;0.2-rc2&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f1f671807b09bc4fbe1759ebf099879c030bdbf" translate="yes" xml:space="preserve">
          <source>Another operation that applies to some types is &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt;&lt;code&gt;supertype&lt;/code&gt;&lt;/a&gt;, which reveals a type's supertype. Only declared types (&lt;code&gt;DataType&lt;/code&gt;) have unambiguous supertypes:</source>
          <target state="translated">いくつかのタイプに適用される別の操作がある&lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt; &lt;code&gt;supertype&lt;/code&gt; &lt;/a&gt;タイプのスーパータイプを明らかにし、。宣言された型（ &lt;code&gt;DataType&lt;/code&gt; ）のみに明確なスーパータイプがあります。</target>
        </trans-unit>
        <trans-unit id="937a3e6d6c5697202a728546d5a94531a97deb3c" translate="yes" xml:space="preserve">
          <source>Another possibility is the following, which could useful to adapt to cases where the parameter &lt;code&gt;T&lt;/code&gt; would need to be matched more narrowly:</source>
          <target state="translated">別の可能性は次のとおりです。これは、パラメーター &lt;code&gt;T&lt;/code&gt; をより厳密に一致させる必要がある場合に適応するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="934eafc149de740d97fce8516adf5aa645737af2" translate="yes" xml:space="preserve">
          <source>Another useful non-standard string literal is the byte-array string literal: &lt;code&gt;b&quot;...&quot;&lt;/code&gt;. This form lets you use string notation to express read only literal byte arrays &amp;ndash; i.e. arrays of &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; values. The type of those objects is &lt;code&gt;CodeUnits{UInt8, String}&lt;/code&gt;. The rules for byte array literals are the following:</source>
          <target state="translated">もう1つの便利な非標準の文字列リテラルは、バイト配列文字列リテラル： &lt;code&gt;b&quot;...&quot;&lt;/code&gt; です。この形式では、文字列表記を使用して、読み取り専用のリテラルバイト配列、つまり&lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt;値の配列を表すことができます。これらのオブジェクトのタイプは &lt;code&gt;CodeUnits{UInt8, String}&lt;/code&gt; です。バイト配列リテラルの規則は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="30b18c65665f6fdbc3c1e0c1e53afe0ef7b0746f" translate="yes" xml:space="preserve">
          <source>Another way to create a sparse array is to convert a dense array into a sparse array using the &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">スパース配列を作成する別の方法は、関数&lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt;を使用して密配列をスパース配列に変換することです。</target>
        </trans-unit>
        <trans-unit id="d71bbbddbab448cf2f4551f57f136f71cf39aeab" translate="yes" xml:space="preserve">
          <source>Another way to view expressions is with &lt;code&gt;Meta.show_sexpr&lt;/code&gt;, which displays the &lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;S-expression&lt;/a&gt; form of a given &lt;code&gt;Expr&lt;/code&gt;, which may look very familiar to users of Lisp. Here's an example illustrating the display on a nested &lt;code&gt;Expr&lt;/code&gt;:</source>
          <target state="translated">式を表示する別の方法は、 &lt;code&gt;Meta.show_sexpr&lt;/code&gt; を使用することです。これは、指定された &lt;code&gt;Expr&lt;/code&gt; の&lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;S式&lt;/a&gt;形式を表示します。これは、Lispのユーザーには非常に馴染みがあるようです。ネストされた &lt;code&gt;Expr&lt;/code&gt; での表示を示す例を次に示します。</target>
        </trans-unit>
        <trans-unit id="5468d9df43f9dcdfb8b8b349ce3a001cd05b665d" translate="yes" xml:space="preserve">
          <source>Another way, which used to be the only correct way before the advent of triangular dispatch in Julia v0.6, is:</source>
          <target state="translated">もう一つの方法は、Julia v0.6で三角ディスパッチが登場する前は、これが唯一の正しい方法でした。</target>
        </trans-unit>
        <trans-unit id="02cc2a69720bd8bf1661deb23018e16470c069da" translate="yes" xml:space="preserve">
          <source>Ant</source>
          <target state="translated">Ant</target>
        </trans-unit>
        <trans-unit id="e25592206c84c0ddd18d548ca6206d3d080aef04" translate="yes" xml:space="preserve">
          <source>Antenna With Bars</source>
          <target state="translated">バー付きアンテナ</target>
        </trans-unit>
        <trans-unit id="27823909809855dca3ee48ccda6c67818ef39511" translate="yes" xml:space="preserve">
          <source>Anticlockwise Contour Integral</source>
          <target state="translated">反時計回り等高線積分</target>
        </trans-unit>
        <trans-unit id="777a29798f3d057ac8c6bab9cead4b05d966905b" translate="yes" xml:space="preserve">
          <source>Anticlockwise Downwards And Upwards Open Circle Arrows</source>
          <target state="translated">反時計回りに下向きに、上向きに開いた円の矢印</target>
        </trans-unit>
        <trans-unit id="e5cdf19e981398168cc33d41c80123d3c30a5081" translate="yes" xml:space="preserve">
          <source>Anticlockwise Integration</source>
          <target state="translated">反時計回りの統合</target>
        </trans-unit>
        <trans-unit id="4ffeb49d53fc5643e555514643bbb1df4f049794" translate="yes" xml:space="preserve">
          <source>Anticlockwise Open Circle Arrow</source>
          <target state="translated">反時計回りのオープンサークル矢印</target>
        </trans-unit>
        <trans-unit id="a52271b2a7c6cb5d3c1c456396438c1ddb68a4f9" translate="yes" xml:space="preserve">
          <source>Anticlockwise Top Semicircle Arrow</source>
          <target state="translated">反時計回り上半円矢印</target>
        </trans-unit>
        <trans-unit id="b661ec502ce7eec63576ef6980de816514a82733" translate="yes" xml:space="preserve">
          <source>Any changes you make to the array values (e.g., &lt;code&gt;A[3] = 0&lt;/code&gt;) will also change the values on disk</source>
          <target state="translated">配列の値（ &lt;code&gt;A[3] = 0&lt;/code&gt; ）を変更すると、ディスク上の値も変更されます</target>
        </trans-unit>
        <trans-unit id="3c5cca19d4f5741a5bb3f294473a79e10b7adbb5" translate="yes" xml:space="preserve">
          <source>Any code that is performance critical or being benchmarked should be inside a function.</source>
          <target state="translated">パフォーマンスが重要なコードやベンチマークされているコードは、関数の中に入れてください。</target>
        </trans-unit>
        <trans-unit id="ba5b886162caf15daa7473ff8070c0f84e6be971" translate="yes" xml:space="preserve">
          <source>Any custom array of scalar indices that is a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; のサブタイプであるスカラーインデックスのカスタム配列</target>
        </trans-unit>
        <trans-unit id="2973d806e6f61582719d2e58b280fa916079cead" translate="yes" xml:space="preserve">
          <source>Any custom testset type (subtype of &lt;code&gt;AbstractTestSet&lt;/code&gt;) can be given and it will also be used for any nested &lt;code&gt;@testset&lt;/code&gt; invocations. The given options are only applied to the test set where they are given. The default test set type does not take any options.</source>
          <target state="translated">カスタムテストセットタイプ（ &lt;code&gt;AbstractTestSet&lt;/code&gt; のサブタイプ）を指定でき、ネストされた &lt;code&gt;@testset&lt;/code&gt; 呼び出しにも使用されます。指定されたオプションは、指定されたテストセットにのみ適用されます。デフォルトのテストセットタイプには、オプションはありません。</target>
        </trans-unit>
        <trans-unit id="31544d9a7acaba7c1156850319c97b90ce13cb9b" translate="yes" xml:space="preserve">
          <source>Any error stops &lt;code&gt;pmap&lt;/code&gt; from processing the remainder of the collection. To override this behavior you can specify an error handling function via argument &lt;code&gt;on_error&lt;/code&gt; which takes in a single argument, i.e., the exception. The function can stop the processing by rethrowing the error, or, to continue, return any value which is then returned inline with the results to the caller.</source>
          <target state="translated">エラーが発生すると、 &lt;code&gt;pmap&lt;/code&gt; は残りのコレクションを処理できなくなります。この動作をオーバーライドするには、単一の引数、つまり例外を &lt;code&gt;on_error&lt;/code&gt; 引数on_errorを介してエラー処理関数を指定できます。関数は、エラーを再スローすることで処理を停止するか、続行するには、結果と一緒に呼び出し元にインラインで返される任意の値を返すことができます。</target>
        </trans-unit>
        <trans-unit id="fc28c907456157bf36df33491d1dd60e94bbee1e" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;f&lt;/code&gt; are printed to &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; on the remote worker.</source>
          <target state="translated">スローされるすべての例外 &lt;code&gt;f&lt;/code&gt; がに印刷され&lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; の&lt;/a&gt;リモート作業員に。</target>
        </trans-unit>
        <trans-unit id="74b6431314c500d9367b1ee7e25039a738c25b54" translate="yes" xml:space="preserve">
          <source>Any keyword arguments passed to &lt;code&gt;eigen&lt;/code&gt; are passed through to the lower-level &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt;&lt;code&gt;eigen!&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;eigen&lt;/code&gt; に渡されるキーワード引数はすべて、下位レベルの&lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt; &lt;code&gt;eigen!&lt;/code&gt; &lt;/a&gt;渡されます。関数。</target>
        </trans-unit>
        <trans-unit id="409446f789565d016b86ac80357893528260dc10" translate="yes" xml:space="preserve">
          <source>Any number of expressions many be documented together in this way. This syntax can be useful when two functions are related, such as non-mutating and mutating versions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;f!&lt;/code&gt;.</source>
          <target state="translated">このようにして、任意の数の式をまとめて文書化できます。この構文は、非変更バージョンと変更バージョン &lt;code&gt;f&lt;/code&gt; および &lt;code&gt;f!&lt;/code&gt; などの2つの関数が関連している場合に役立ちます。。</target>
        </trans-unit>
        <trans-unit id="f23555229abe2136eae4796de9adb4981c0efa50" translate="yes" xml:space="preserve">
          <source>Any object that defines this function is iterable and can be used in the &lt;a href=&quot;../../base/collections/index#lib-collections-iteration-1&quot;&gt;many functions that rely upon iteration&lt;/a&gt;. It can also be used directly in a &lt;a href=&quot;../../base/base/index#for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop since the syntax:</source>
          <target state="translated">この関数を定義するオブジェクトは反復可能であり&lt;a href=&quot;../../base/collections/index#lib-collections-iteration-1&quot;&gt;、反復に依存する多くの関数で&lt;/a&gt;使用できます。次の構文なので、&lt;a href=&quot;../../base/base/index#for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt;ループで直接使用することもできます。</target>
        </trans-unit>
        <trans-unit id="14a4faaa9263f21666bc118177b8030fb0ebed4a" translate="yes" xml:space="preserve">
          <source>Any object that is not a type is not an instance of &lt;code&gt;Type&lt;/code&gt;:</source>
          <target state="translated">タイプではないオブジェクトは &lt;code&gt;Type&lt;/code&gt; のインスタンスではありません。</target>
        </trans-unit>
        <trans-unit id="5099776907c27052bfc78cf7373b0d68a21ec5f2" translate="yes" xml:space="preserve">
          <source>Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.</source>
          <target state="translated">エラーを投げる操作は、おそらく現在実装されていないと思われますので、バグとして投稿して解決するようにしてください。</target>
        </trans-unit>
        <trans-unit id="f91c503ff4942107fdfd3a5ddc75b8099dc08779" translate="yes" xml:space="preserve">
          <source>Any process with a reference to a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; can put and take items from the channel. Data is automatically sent to (or retrieved from) the process a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; is associated with.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt;への参照を持つすべてのプロセスは、チャネルからアイテムを配置および取得できます。データは、&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt;が関連付けられているプロセスに自動的に送信されます（またはプロセスから取得されます）。</target>
        </trans-unit>
        <trans-unit id="7c010ba08796a2114052ab863fb8a9d226c9dd13" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Backslash Bar</source>
          <target state="translated">Apl 機能記号バックスラッシュバー</target>
        </trans-unit>
        <trans-unit id="36d891e0ee22f437cc243dd2e9ea0702d961b80f" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Circle Stile</source>
          <target state="translated">Apl 機能シンボルサークル・スティル</target>
        </trans-unit>
        <trans-unit id="39c46b8ef7910ae74868b76b650aa07198ab578c" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol I-Beam</source>
          <target state="translated">Apl 機能シンボル I-Beam</target>
        </trans-unit>
        <trans-unit id="d0546025dd10b13f2435dc3fcaee9e017037a2e5" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Quad Question</source>
          <target state="translated">Apl機能シンボル クワッド問題</target>
        </trans-unit>
        <trans-unit id="4d565c437bb750fa8a1eb8171844a8039a97d351" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Quad Up Caret</source>
          <target state="translated">Apl 機能シンボル クワッドアップキャレット</target>
        </trans-unit>
        <trans-unit id="2b164c5aca8328b895ebe3a8c42bb636c6e38b33" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Slash Bar</source>
          <target state="translated">Apl 機能記号スラッシュバー</target>
        </trans-unit>
        <trans-unit id="259f6ae1ad06c26f4f50971a4ed64fd704fd9a77" translate="yes" xml:space="preserve">
          <source>Append &lt;code&gt;!&lt;/code&gt; to names of functions that modify their arguments</source>
          <target state="translated">追加 &lt;code&gt;!&lt;/code&gt; 引数を変更する関数の名前</target>
        </trans-unit>
        <trans-unit id="93f34880658a83722dbec3227ce96d931d512e39" translate="yes" xml:space="preserve">
          <source>Append an item &lt;code&gt;v&lt;/code&gt; to the channel &lt;code&gt;c&lt;/code&gt;. Blocks if the channel is full.</source>
          <target state="translated">アイテムの追加 &lt;code&gt;v&lt;/code&gt; チャネルに &lt;code&gt;c&lt;/code&gt; 。チャネルがいっぱいの場合はブロックします。</target>
        </trans-unit>
        <trans-unit id="b03f369e152e908d0c3e87c0759a78a3bbb83fd8" translate="yes" xml:space="preserve">
          <source>Applied to a function argument name, hints to the compiler that the method should not be specialized for different types of that argument, but instead to use precisely the declared type for each argument. This is only a hint for avoiding excess code generation. Can be applied to an argument within a formal argument list, or in the function body. When applied to an argument, the macro must wrap the entire argument expression. When used in a function body, the macro must occur in statement position and before any code.</source>
          <target state="translated">関数の引数名に適用され、メソッドがその引数の異なる型に特化するのではなく、各引数に対して正確に宣言された型を使用するようにコンパイラにヒントを与えます。これは、過剰なコード生成を避けるためのヒントに過ぎません。正式な引数リスト内、または関数本体内の引数に適用することができます。引数に適用する場合、マクロは引数式全体をラップする必要があります。関数ボディ内で使用する場合は、マクロは文の位置でコードの前に配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="8ab87eebb7a11b086ff8353783cc2be68600a9ff" translate="yes" xml:space="preserve">
          <source>Applied to a function or macro call, it evaluates the arguments to the specified call, and returns a tuple &lt;code&gt;(filename,line)&lt;/code&gt; giving the location for the method that would be called for those arguments. It calls out to the &lt;code&gt;functionloc&lt;/code&gt; function.</source>
          <target state="translated">関数またはマクロ呼び出しに適用されると、指定された呼び出しの引数を評価し、それらの引数に対して呼び出されるメソッドの場所を示すタプル &lt;code&gt;(filename,line)&lt;/code&gt; を返します。 &lt;code&gt;functionloc&lt;/code&gt; 関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="10b1d88dbbba24ca44bfc0cd98b524dd2c753624" translate="yes" xml:space="preserve">
          <source>Applied to a function or macro call, it evaluates the arguments to the specified call, and returns the &lt;code&gt;Method&lt;/code&gt; object for the method that would be called for those arguments. Applied to a variable, it returns the module in which the variable was bound. It calls out to the &lt;code&gt;which&lt;/code&gt; function.</source>
          <target state="translated">関数またはマクロの呼び出しに適用されると、指定された呼び出しの引数を評価し、それらの引数に対して呼び出される &lt;code&gt;Method&lt;/code&gt; オブジェクトを返します。変数に適用すると、変数がバインドされたモジュールが返されます。 &lt;code&gt;which&lt;/code&gt; 関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="bbb092978ae173971f51dbbabbad7be81b9e017d" translate="yes" xml:space="preserve">
          <source>Applies a function to the preceding argument. This allows for easy function chaining.</source>
          <target state="translated">前の引数に関数を適用します。これにより、関数を簡単に連結することができます。</target>
        </trans-unit>
        <trans-unit id="df9997f06ef19d21e85df7f2a8d3fde509d61f00" translate="yes" xml:space="preserve">
          <source>Apply function &lt;code&gt;f&lt;/code&gt; to each element(s) in &lt;code&gt;itrs&lt;/code&gt;, and then reduce the result using the binary function &lt;code&gt;op&lt;/code&gt;. If provided, &lt;code&gt;init&lt;/code&gt; must be a neutral element for &lt;code&gt;op&lt;/code&gt; that will be returned for empty collections. It is unspecified whether &lt;code&gt;init&lt;/code&gt; is used for non-empty collections. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">&lt;code&gt;itrs&lt;/code&gt; の各要素に関数 &lt;code&gt;f&lt;/code&gt; を適用し、バイナリ関数 &lt;code&gt;op&lt;/code&gt; を使用して結果を減らします。指定する場合、 &lt;code&gt;init&lt;/code&gt; は、空のコレクションに対して返される &lt;code&gt;op&lt;/code&gt; のニュートラルエレメントである必要があります。空でないコレクションに &lt;code&gt;init&lt;/code&gt; が使用されるかどうかは指定されていません。一般に、空のコレクションを処理するには &lt;code&gt;init&lt;/code&gt; を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="abde153c82249beeebbf8921343e0e5bfbfeae0c" translate="yes" xml:space="preserve">
          <source>Apply function &lt;code&gt;f&lt;/code&gt; to the git repository &lt;code&gt;repo&lt;/code&gt;, taking a &lt;a href=&quot;#LibGit2.snapshot&quot;&gt;&lt;code&gt;snapshot&lt;/code&gt;&lt;/a&gt; before applying &lt;code&gt;f&lt;/code&gt;. If an error occurs within &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;repo&lt;/code&gt; will be returned to its snapshot state using &lt;a href=&quot;#LibGit2.restore&quot;&gt;&lt;code&gt;restore&lt;/code&gt;&lt;/a&gt;. The error which occurred will be rethrown, but the state of &lt;code&gt;repo&lt;/code&gt; will not be corrupted.</source>
          <target state="translated">関数適用 &lt;code&gt;f&lt;/code&gt; は gitのリポジトリに &lt;code&gt;repo&lt;/code&gt; 取って、&lt;a href=&quot;#LibGit2.snapshot&quot;&gt; &lt;code&gt;snapshot&lt;/code&gt; &lt;/a&gt;適用する前に &lt;code&gt;f&lt;/code&gt; 。 &lt;code&gt;f&lt;/code&gt; 内でエラーが発生した場合、 &lt;code&gt;repo&lt;/code&gt; は&lt;a href=&quot;#LibGit2.restore&quot;&gt; &lt;code&gt;restore&lt;/code&gt; &lt;/a&gt;を使用してスナップショットの状態に戻ります。発生したエラーは再スローされますが、 &lt;code&gt;repo&lt;/code&gt; の状態は破損しません。</target>
        </trans-unit>
        <trans-unit id="0f3a1ca726a424329c0ade2ec9d0c7202e4993c0" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to each element of collection &lt;code&gt;itr&lt;/code&gt; and take the mean.</source>
          <target state="translated">関数適用 &lt;code&gt;f&lt;/code&gt; は、コレクションの各要素に &lt;code&gt;itr&lt;/code&gt; と平均値を取ります。</target>
        </trans-unit>
        <trans-unit id="3bc364f76459203bdb0d1fe7d66f3331843d77fb" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktemp(parent)&lt;/code&gt;&lt;/a&gt; and remove the temporary file upon completion.</source>
          <target state="translated">関数 &lt;code&gt;f&lt;/code&gt; を&lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktemp(parent)&lt;/code&gt; の&lt;/a&gt;結果に適用し、完了時に一時ファイルを削除します。</target>
        </trans-unit>
        <trans-unit id="5d833cb24f42c76580b0926f643d9e169ba73703" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt;&lt;/a&gt; and remove the temporary directory all of its contents upon completion.</source>
          <target state="translated">関数 &lt;code&gt;f&lt;/code&gt; を&lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt; &lt;/a&gt;の結果に適用し、完了時に一時ディレクトリの内容をすべて削除します。</target>
        </trans-unit>
        <trans-unit id="c30fb3d590d21605851a7bb8d8b8ee272dad26bb" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;code&gt;open(args...; kwargs...)&lt;/code&gt; and close the resulting file descriptor upon completion.</source>
          <target state="translated">関数 &lt;code&gt;f&lt;/code&gt; を &lt;code&gt;open(args...; kwargs...)&lt;/code&gt; の結果に適用し、完了時に結果のファイル記述子を閉じます。</target>
        </trans-unit>
        <trans-unit id="47f0920b156c6fa088e0adafa06695882e8a1ce9" translate="yes" xml:space="preserve">
          <source>Applying it to any other types of arguments will result in a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">それを他のタイプの引数に適用すると、&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;が発生します。</target>
        </trans-unit>
        <trans-unit id="7fea34195bef9eda50f65dd470da25827c0b940a" translate="yes" xml:space="preserve">
          <source>Approaches The Limit</source>
          <target state="translated">アプローチ ザ リミット</target>
        </trans-unit>
        <trans-unit id="36af3f4430ffa874f1e260736d3734767175bb17" translate="yes" xml:space="preserve">
          <source>Approximate floating point number &lt;code&gt;x&lt;/code&gt; as a &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; number with components of the given integer type. The result will differ from &lt;code&gt;x&lt;/code&gt; by no more than &lt;code&gt;tol&lt;/code&gt;.</source>
          <target state="translated">与えられた整数型のコンポーネントを持つ&lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;としての浮動小数点数 &lt;code&gt;x&lt;/code&gt; の概算。結果は &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;tol&lt;/code&gt; 以下の差になります。</target>
        </trans-unit>
        <trans-unit id="86cdef7d39fe1e6ca08d22290dae380c71b22482" translate="yes" xml:space="preserve">
          <source>Approximately But Not Actually Equal To</source>
          <target state="translated">とほぼ同じだが、実際には同じではない</target>
        </trans-unit>
        <trans-unit id="a398789ce28e88dc00a7a33731c788d8238f5ac2" translate="yes" xml:space="preserve">
          <source>Approximately Equal Or Equal To</source>
          <target state="translated">ほぼ同等または同等</target>
        </trans-unit>
        <trans-unit id="110d059e67ed3348bbc8fc7fc9a8a4830c0240e6" translate="yes" xml:space="preserve">
          <source>Approximately Equal To</source>
          <target state="translated">にほぼ等しい</target>
        </trans-unit>
        <trans-unit id="9d91d063fbecc40e31adb06a0bdab3785430bae5" translate="yes" xml:space="preserve">
          <source>Approximately Equal To Or The Image Of</source>
          <target state="translated">ほぼ同等またはそのイメージ</target>
        </trans-unit>
        <trans-unit id="3e026e6d2a8adcf8897cf07eecff80b0380f276d" translate="yes" xml:space="preserve">
          <source>Aquarius</source>
          <target state="translated">Aquarius</target>
        </trans-unit>
        <trans-unit id="d037d2935a703a621340fc357146d1188aae9fef" translate="yes" xml:space="preserve">
          <source>Arbitrary Precision Arithmetic</source>
          <target state="translated">任意精度演算</target>
        </trans-unit>
        <trans-unit id="ec0bee1bcca32dcc4d82f1af9b35b9a4e833d243" translate="yes" xml:space="preserve">
          <source>Arbitrary precision floating point number type.</source>
          <target state="translated">任意精度浮動小数点数型。</target>
        </trans-unit>
        <trans-unit id="f38bd661446c82eb63be7e7f1e9af6fa5a6cfaaa" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integer type.</source>
          <target state="translated">任意の精度の整数型。</target>
        </trans-unit>
        <trans-unit id="853a983f6b8abdb9ecba43da2ceda1641c9d519f" translate="yes" xml:space="preserve">
          <source>Arc</source>
          <target state="translated">Arc</target>
        </trans-unit>
        <trans-unit id="dbf6ae45c2a646ca9f7ecaf4480259128f85d936" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;waitfor&lt;/code&gt; specifies how long to wait for the workers to shut down:</source>
          <target state="translated">引数 &lt;code&gt;waitfor&lt;/code&gt; は、ワーカーがシャットダウンするまで待機する時間を指定します。</target>
        </trans-unit>
        <trans-unit id="0d26bcd474b23ab47569a6a1a0ca62a2c9eb9205" translate="yes" xml:space="preserve">
          <source>Argument Passing Behavior</source>
          <target state="translated">引数通過動作</target>
        </trans-unit>
        <trans-unit id="938cc4ebe6a5288bbfb1485b585ece93ff21a6fc" translate="yes" xml:space="preserve">
          <source>Argument destructuring</source>
          <target state="translated">引数の破壊</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="ccfbfffe30467d0556e9822f3a3009bcd6857e77" translate="yes" xml:space="preserve">
          <source>Arguments to be passed to the LLVM backend.</source>
          <target state="translated">LLVMバックエンドに渡す引数。</target>
        </trans-unit>
        <trans-unit id="f480e0686764de02407b1abe1545f3d34ae95935" translate="yes" xml:space="preserve">
          <source>Aries</source>
          <target state="translated">Aries</target>
        </trans-unit>
        <trans-unit id="6104f39ed22a2cd32e98536a3447a01c4b9f4781" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators</source>
          <target state="translated">算術演算子</target>
        </trans-unit>
        <trans-unit id="6ba961184ebd546b1a3177abda88c03934fb089a" translate="yes" xml:space="preserve">
          <source>Arithmetic on the &lt;code&gt;Ptr&lt;/code&gt; type in Julia (e.g. using &lt;code&gt;+&lt;/code&gt;) does not behave the same as C's pointer arithmetic. Adding an integer to a &lt;code&gt;Ptr&lt;/code&gt; in Julia always moves the pointer by some number of &lt;em&gt;bytes&lt;/em&gt;, not elements. This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers.</source>
          <target state="translated">Julia での &lt;code&gt;Ptr&lt;/code&gt; 型の演算（たとえば、 &lt;code&gt;+&lt;/code&gt; の使用）は、Cのポインター演算と同じように動作しません。Juliaで &lt;code&gt;Ptr&lt;/code&gt; に整数を追加すると、ポインターは常に要素ではなく、&lt;em&gt;バイト&lt;/em&gt;数だけ移動します。このように、ポインター演算から取得されるアドレス値は、ポインターの要素タイプに依存しません。</target>
        </trans-unit>
        <trans-unit id="1595977488274506444762a7d4b561a282b06666" translate="yes" xml:space="preserve">
          <source>Arithmetic operations on sparse matrices also work as they do on dense matrices. Indexing of, assignment into, and concatenation of sparse matrices work in the same way as dense matrices. Indexing operations, especially assignment, are expensive, when carried out one element at a time. In many cases it may be better to convert the sparse matrix into &lt;code&gt;(I,J,V)&lt;/code&gt; format using &lt;a href=&quot;#SparseArrays.findnz&quot;&gt;&lt;code&gt;findnz&lt;/code&gt;&lt;/a&gt;, manipulate the values or the structure in the dense vectors &lt;code&gt;(I,J,V)&lt;/code&gt;, and then reconstruct the sparse matrix.</source>
          <target state="translated">疎行列に対する算術演算も、密行列に対する場合と同様に機能します。疎行列の索引付け、代入、および連結は、密行列と同じように機能します。インデックス作成操作、特に割り当ては、一度に1つの要素を実行するとコストがかかります。多くの場合 &lt;code&gt;(I,J,V)&lt;/code&gt; &lt;a href=&quot;#SparseArrays.findnz&quot;&gt; &lt;code&gt;findnz&lt;/code&gt; &lt;/a&gt;を使用してスパース行列を（I、J、V）形式に変換し、密なベクトル &lt;code&gt;(I,J,V)&lt;/code&gt; の値または構造を操作してから、スパース行列を再構築する方が良い場合があります。</target>
        </trans-unit>
        <trans-unit id="6b6663a1569cf067a646e962adc2c809327f2a1d" translate="yes" xml:space="preserve">
          <source>Array and Vectorized Operators and Functions</source>
          <target state="translated">配列化およびベクトル化された演算子と関数</target>
        </trans-unit>
        <trans-unit id="272896e88f7076a29401b63fcba504c622f100cf" translate="yes" xml:space="preserve">
          <source>Array functions</source>
          <target state="translated">配列関数</target>
        </trans-unit>
        <trans-unit id="ec6e2a8a6e3331d091fde070355048d6a50fbdb0" translate="yes" xml:space="preserve">
          <source>Array traits</source>
          <target state="translated">配列形質</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="a0d486c491afc0a11a53591657e1748ec0e15c70" translate="yes" xml:space="preserve">
          <source>Arrays With Missing Values</source>
          <target state="translated">欠落した値を持つ配列</target>
        </trans-unit>
        <trans-unit id="14eed9a557bdf809c1d72ce7ef06aab3ac832f66" translate="yes" xml:space="preserve">
          <source>Arrays allowing for missing values can be constructed with the standard syntax. Use &lt;code&gt;Array{Union{Missing, T}}(missing, dims)&lt;/code&gt; to create arrays filled with missing values:</source>
          <target state="translated">欠損値を許容する配列は、標準の構文で構築できます。使用の &lt;code&gt;Array{Union{Missing, T}}(missing, dims)&lt;/code&gt; 欠損値で充填された配列を作成します。</target>
        </trans-unit>
        <trans-unit id="d5a5bd6d399fb4d5330301010e8df836c12ff36c" translate="yes" xml:space="preserve">
          <source>Arrays are stored contiguously in memory, lending themselves to CPU vectorization and fewer memory accesses due to caching. These are the same reasons that it is recommended to access arrays in column-major order (see above). Irregular access patterns and non-contiguous views can drastically slow down computations on arrays because of non-sequential memory access.</source>
          <target state="translated">配列はメモリ内に連続して格納されているため、CPUのベクトル化やキャッシュによるメモリアクセスが少なくなります。これらの理由から、配列へのアクセスはカラム・メジャー順で行うことが推奨されています(上記参照)。不規則なアクセスパターンや不連続なビューは、非連続なメモリアクセスのために、配列の計算を大幅に遅くする可能性があります。</target>
        </trans-unit>
        <trans-unit id="804cb53914986dde77e394241b65af0a2493a576" translate="yes" xml:space="preserve">
          <source>Arrays can be constructed and also concatenated using the following functions:</source>
          <target state="translated">配列は、以下の関数を使用して構築したり、連結したりすることができます。</target>
        </trans-unit>
        <trans-unit id="9a14bfc250b9401c09f27dc8758fb64c6d1849ec" translate="yes" xml:space="preserve">
          <source>Arrays can easily be sorted according to an arbitrary transformation of their values:</source>
          <target state="translated">配列は、その値の任意の変換に従って簡単に並べ替えることができます。</target>
        </trans-unit>
        <trans-unit id="aa747a7d1d6f608a0335baa21f343f3341f91936" translate="yes" xml:space="preserve">
          <source>Arrays containing missing values can be created like other arrays</source>
          <target state="translated">欠損値を含む配列は、他の配列と同様に作成することができます。</target>
        </trans-unit>
        <trans-unit id="ca4d2abddb6904030658a8e61f4450fbbd938fdf" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;CartesianIndex{N}&lt;/code&gt; (see below for more details)</source>
          <target state="translated">&lt;code&gt;CartesianIndex{N}&lt;/code&gt; 配列（詳細は以下を参照）</target>
        </trans-unit>
        <trans-unit id="075c9f606a29f390bc16b51c28be22f3d814f931" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;CartesianIndex{N}&lt;/code&gt; are also supported. They represent a collection of scalar indices that each span &lt;code&gt;N&lt;/code&gt; dimensions, enabling a form of indexing that is sometimes referred to as pointwise indexing. For example, it enables accessing the diagonal elements from the first &quot;page&quot; of &lt;code&gt;A&lt;/code&gt; from above:</source>
          <target state="translated">&lt;code&gt;CartesianIndex{N}&lt;/code&gt; 配列もサポートされています。それらは、それぞれが &lt;code&gt;N&lt;/code&gt; 次元にわたるスカラーインデックスのコレクションを表し、ポイントワイズインデックスとも呼ばれるインデックスの形式を有効にします。たとえば、上から &lt;code&gt;A&lt;/code&gt; の最初の「ページ」から対角要素にアクセスできるようにします。</target>
        </trans-unit>
        <trans-unit id="3d6407685d9a3a1c2957e4566ba6f78f8b15e030" translate="yes" xml:space="preserve">
          <source>Arrays of booleans, which select elements at their &lt;code&gt;true&lt;/code&gt; indices (see below for more details)</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; インデックスで要素を選択するブール値の配列（詳細は以下を参照）</target>
        </trans-unit>
        <trans-unit id="0969583730964394602b74ac92dacfa507bac99b" translate="yes" xml:space="preserve">
          <source>Arrays of parameters can be expressed with &lt;code&gt;NTuple&lt;/code&gt;:</source>
          <target state="translated">パラメータの配列は &lt;code&gt;NTuple&lt;/code&gt; で表現できます：</target>
        </trans-unit>
        <trans-unit id="7c5854ca021fe589728b87432b4e259d1c8248d3" translate="yes" xml:space="preserve">
          <source>Arrays of plain data types exhibit the same behavior.</source>
          <target state="translated">プレーンデータ型の配列も同じ動作をします。</target>
        </trans-unit>
        <trans-unit id="6f655e915f910f157fee32ed03ecdc2ad3b9d1df" translate="yes" xml:space="preserve">
          <source>Arrays of unknown size (C99-compliant variable length structs specified by &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;[0]&lt;/code&gt;) are not directly supported. Often the best way to deal with these is to deal with the byte offsets directly. For example, if a C library declared a proper string type and returned a pointer to it:</source>
          <target state="translated">サイズが不明な配列（ &lt;code&gt;[]&lt;/code&gt; または &lt;code&gt;[0]&lt;/code&gt; で指定されたC99準拠の可変長構造体）は直接サポートされていません。多くの場合、これらを処理する最良の方法は、バイトオフセットを直接処理することです。たとえば、Cライブラリが適切な文字列型を宣言し、それへのポインタを返した場合：</target>
        </trans-unit>
        <trans-unit id="0a4fe1e9982ed026b7b75e0b6640d07c49b347a1" translate="yes" xml:space="preserve">
          <source>Arrow Pointing Rightwards Then Curving Downwards</source>
          <target state="translated">矢印は右方向を指し、次に下向きにカーブしています。</target>
        </trans-unit>
        <trans-unit id="d5a8479391be26e8e773c26793b7bf6d542adbb0" translate="yes" xml:space="preserve">
          <source>Arrow Pointing Rightwards Then Curving Upwards</source>
          <target state="translated">矢印は右を指し、その後上向きにカーブします。</target>
        </trans-unit>
        <trans-unit id="56cbb3f16cd1ca93b5689f5cddec6758302ebb86" translate="yes" xml:space="preserve">
          <source>Arthur C. Clarke, &lt;em&gt;Profiles of the Future&lt;/em&gt; (1961): Clarke's Third Law.</source>
          <target state="translated">アーサーC.クラーク、&lt;em&gt;未来のプロファイル&lt;/em&gt;（1961）：クラークの第三法則。</target>
        </trans-unit>
        <trans-unit id="4be4b541c7c3be1117af5726c8607678780b96ca" translate="yes" xml:space="preserve">
          <source>Articulated Lorry</source>
          <target state="translated">多関節ローリー</target>
        </trans-unit>
        <trans-unit id="b1aa57e2147913434d8d33e99a2a302c3d412560" translate="yes" xml:space="preserve">
          <source>Artist Palette</source>
          <target state="translated">アーティストパレット</target>
        </trans-unit>
        <trans-unit id="b2b55172c20f3a3018d935f94f15f420d19dd799" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;missing&lt;/code&gt; is a normal Julia object, this propagation rule only works for functions which have opted in to implement this behavior. This can be achieved either via a specific method defined for arguments of type &lt;code&gt;Missing&lt;/code&gt;, or simply by accepting arguments of this type, and passing them to functions which propagate them (like standard operators). Packages should consider whether it makes sense to propagate missing values when defining new functions, and define methods appropriately if that is the case. Passing a &lt;code&gt;missing&lt;/code&gt; value to a function for which no method accepting arguments of type &lt;code&gt;Missing&lt;/code&gt; is defined throws a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;, just like for any other type.</source>
          <target state="translated">&lt;code&gt;missing&lt;/code&gt; 、通常のジュリアオブジェクトである、この伝播ルールは、この動作を実装するために選択している機能のために動作します。これは、 &lt;code&gt;Missing&lt;/code&gt; 型の引数に対して定義された特定のメソッドを介して、または単にこの型の引数を受け入れ、それらを伝播する関数（標準演算子など）に渡すことによって実現できます。パッケージは、新しい関数を定義するときに欠損値を伝達することが理にかなっているかどうかを検討し、そうである場合はメソッドを適切に定義する必要があります。 &lt;code&gt;Missing&lt;/code&gt; 型の引数を受け入れるメソッドが定義されていない関数に &lt;code&gt;missing&lt;/code&gt; 値を渡すと、他の型と同じように&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; が&lt;/a&gt;スローされます。</target>
        </trans-unit>
        <trans-unit id="6c7f12d083082a8b358b33648f5e922218bf6328" translate="yes" xml:space="preserve">
          <source>As Julia &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; values are represented according to the ISO 8601 standard, &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; was chosen as base (or &quot;rounding epoch&quot;) from which to begin the count of days (and milliseconds) used in rounding calculations. (Note that this differs slightly from Julia's internal representation of &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; s using Rata Die notation; but since the ISO 8601 standard is most visible to the end user, &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; was chosen as the rounding epoch instead of the &lt;code&gt;0000-12-31T00:00:00&lt;/code&gt; used internally to minimize confusion.)</source>
          <target state="translated">Julia &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; の&lt;/a&gt;値はISO 8601標準に従って表されるため、丸めに使用される日数（およびミリ秒）のカウントを開始する基準（または「丸めエポック」）として &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; が選択されました計算。（これは、Rata Die表記を使用したJuliaの&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;の内部表現とは少し異なりますが、ISO 8601規格はエンドユーザーに最も見やすいため、 &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; が丸めのエポックとして選択されました &lt;code&gt;0000-12-31T00:00:00&lt;/code&gt; は、混乱を最小限にするために内部的に使用されます。）</target>
        </trans-unit>
        <trans-unit id="018f199ee4bce38a37225bf7cf902f1a94cfebe8" translate="yes" xml:space="preserve">
          <source>As a bonus, all period arithmetic objects work directly with ranges:</source>
          <target state="translated">ボーナスとして、すべてのピリオドの算術オブジェクトは、範囲を直接使用して動作します。</target>
        </trans-unit>
        <trans-unit id="25d0293122d46f12e2772f00b98fe234a30f7099" translate="yes" xml:space="preserve">
          <source>As a complete but simple example, the following calls the &lt;code&gt;clock&lt;/code&gt; function from the standard C library:</source>
          <target state="translated">完全ではありますが単純な例として、以下は標準Cライブラリから &lt;code&gt;clock&lt;/code&gt; 関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="539ad19d9070448cc3bfdfe89f4f38e027fe5c6c" translate="yes" xml:space="preserve">
          <source>As a convenience, constructing a &lt;code&gt;CartesianIndices&lt;/code&gt; from an array makes a range of its indices.</source>
          <target state="translated">便宜上、配列から &lt;code&gt;CartesianIndices&lt;/code&gt; を構築すると、その範囲のインデックスが作成されます。</target>
        </trans-unit>
        <trans-unit id="0b5625230c61073f2e6e2ee043f6240a0a3c7016" translate="yes" xml:space="preserve">
          <source>As a general rule, the Base library uses the following order of arguments to functions, as applicable:</source>
          <target state="translated">原則として、Base ライブラリでは、関数への引数の順序は以下のようになっています。</target>
        </trans-unit>
        <trans-unit id="876317f2ed373be8c206ea71cf8b7c051cb11062" translate="yes" xml:space="preserve">
          <source>As a more complicated example, let's define our own toy N-dimensional sparse-like array type built on top of &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">より複雑な例として、&lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; の&lt;/a&gt;上に構築された独自のおもちゃのN次元のスパース状配列型を定義してみましょう。</target>
        </trans-unit>
        <trans-unit id="e8594cf6335bb7f066fe658c47ad7b64d5f8a844" translate="yes" xml:space="preserve">
          <source>As a more extended and complex example, consider running the following &quot;kernel&quot; in parallel:</source>
          <target state="translated">より拡張された複雑な例として、以下の「カーネル」を並列に実行することを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="2067a667a08ddb9964ef86bab532db4e31b7d596" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, the single-line &lt;code&gt;show&lt;/code&gt; method should print a valid Julia expression for creating the shown object. When this &lt;code&gt;show&lt;/code&gt; method contains infix operators, such as the multiplication operator (&lt;code&gt;*&lt;/code&gt;) in our single-line &lt;code&gt;show&lt;/code&gt; method for &lt;code&gt;Polar&lt;/code&gt; above, it may not parse correctly when printed as part of another object. To see this, consider the expression object (see &lt;a href=&quot;../metaprogramming/index#Program-representation-1&quot;&gt;Program representation&lt;/a&gt;) which takes the square of a specific instance of our &lt;code&gt;Polar&lt;/code&gt; type:</source>
          <target state="translated">経験則として、単一行の &lt;code&gt;show&lt;/code&gt; メソッドは、表示されたオブジェクトを作成するための有効なJulia式を出力する必要があります。この &lt;code&gt;show&lt;/code&gt; メソッドに上記の &lt;code&gt;Polar&lt;/code&gt; の単一行の &lt;code&gt;show&lt;/code&gt; メソッドの乗算演算子（ &lt;code&gt;*&lt;/code&gt; ）などのインフィックス演算子が含まれている場合、別のオブジェクトの一部として印刷すると、正しく解析されない場合があります。これを確認するには、 &lt;code&gt;Polar&lt;/code&gt; 型の特定のインスタンスの2乗をとる式オブジェクト（&lt;a href=&quot;../metaprogramming/index#Program-representation-1&quot;&gt;プログラム&lt;/a&gt;表現を参照）を考えます。</target>
        </trans-unit>
        <trans-unit id="37e79152e5cc53d02dd6543f1f031bc76326d65b" translate="yes" xml:space="preserve">
          <source>As a special case, all names defined in &lt;code&gt;Main&lt;/code&gt; are considered &quot;exported&quot;, since it is not idiomatic to explicitly export names from &lt;code&gt;Main&lt;/code&gt;.</source>
          <target state="translated">特殊なケースとして、で定義されたすべての名前 &lt;code&gt;Main&lt;/code&gt; 、明示的に名前をエクスポートする慣用ではないので、「エクスポート」と考えられている &lt;code&gt;Main&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ead86dd43c44d522a7884aedc1fd88eb5becf75" translate="yes" xml:space="preserve">
          <source>As a special case, functions can only be actually deep-copied if they are anonymous, otherwise they are just copied. The difference is only relevant in the case of closures, i.e. functions which may contain hidden internal references.</source>
          <target state="translated">特殊なケースとして、関数は無名の場合にのみ実際にディープコピーされますが、そうでない場合はただコピーされるだけです。この違いはクロージャの場合、つまり隠された内部参照を含む可能性のある関数の場合にのみ関係します。</target>
        </trans-unit>
        <trans-unit id="d76af4d473b8d2d40c642b61a1fbe0edf6927389" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;code&gt;x&lt;/code&gt; is an &lt;code&gt;AbstractString&lt;/code&gt; (for textual MIME types) or a &lt;code&gt;Vector{UInt8}&lt;/code&gt; (for binary MIME types), the &lt;code&gt;repr&lt;/code&gt; function assumes that &lt;code&gt;x&lt;/code&gt; is already in the requested &lt;code&gt;mime&lt;/code&gt; format and simply returns &lt;code&gt;x&lt;/code&gt;. This special case does not apply to the &lt;code&gt;&quot;text/plain&quot;&lt;/code&gt; MIME type. This is useful so that raw data can be passed to &lt;code&gt;display(m::MIME, x)&lt;/code&gt;.</source>
          <target state="translated">特殊なケースとして、 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;AbstractString&lt;/code&gt; （テキストMIMEタイプの場合）または &lt;code&gt;Vector{UInt8}&lt;/code&gt; （バイナリMIMEタイプの場合）の場合、 &lt;code&gt;repr&lt;/code&gt; 関数は &lt;code&gt;x&lt;/code&gt; がすでに要求された &lt;code&gt;mime&lt;/code&gt; 形式であると想定し、単に &lt;code&gt;x&lt;/code&gt; を返します。この特殊なケースは、 &lt;code&gt;&quot;text/plain&quot;&lt;/code&gt; MIMEタイプには適用されません。これは、生データを &lt;code&gt;display(m::MIME, x)&lt;/code&gt; 渡すために役立ちます。</target>
        </trans-unit>
        <trans-unit id="62d11f9f9e158c0b2c2708640ce2ac613943fd82" translate="yes" xml:space="preserve">
          <source>As a special part of this syntax, the &lt;code&gt;end&lt;/code&gt; keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the innermost array being indexed. Indexing syntax without the &lt;code&gt;end&lt;/code&gt; keyword is equivalent to a call to &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">この構文の特別な部分として、インデックスが付けられている最も内側の配列のサイズによって決定されるように、 &lt;code&gt;end&lt;/code&gt; キーワードを使用して、インデックスブラケット内の各次元の最後のインデックスを表すことができます。 &lt;code&gt;end&lt;/code&gt; キーワードなしのインデックス構文は、&lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; の&lt;/a&gt;呼び出しと同等です。</target>
        </trans-unit>
        <trans-unit id="5535efde9a5741aaf5f5e686571434213ecef6c2" translate="yes" xml:space="preserve">
          <source>As already elaborated in &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;The Julia REPL&lt;/a&gt;, Julia's REPL provides rich functionality that facilitates an efficient interactive workflow. Here are some tips that might further enhance your experience at the command line.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;Julia REPL&lt;/a&gt;ですでに詳しく述べたように、JuliaのREPLは、効率的なインタラクティブワークフローを促進する豊富な機能を提供します。コマンドラインでのエクスペリエンスをさらに向上させるヒントをいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="06e64cdbccd93a2d388ef16dd274049eaf25b515" translate="yes" xml:space="preserve">
          <source>As an alternative for very simple cases, it is possible to just create a global container of type &lt;code&gt;Vector{Any}&lt;/code&gt; and fetch the elements from that when necessary, or even to create one global variable per pointer using</source>
          <target state="translated">非常に単純なケースの代替策として、 &lt;code&gt;Vector{Any}&lt;/code&gt; 型のグローバルコンテナーを作成し、必要に応じてそこから要素をフェッチするか、または使用してポインターごとに1つのグローバル変数を作成することもできます。</target>
        </trans-unit>
        <trans-unit id="d6c52d7f67846f1ec223096b1fa72569e5539d74" translate="yes" xml:space="preserve">
          <source>As an assertion to help confirm that your program works the way you expect,</source>
          <target state="translated">あなたのプログラムが期待通りに動作することを確認するためのアサーションとして。</target>
        </trans-unit>
        <trans-unit id="18c9d397fe2fae6bb521c88b045f04eec75021c6" translate="yes" xml:space="preserve">
          <source>As an example let us see how the &lt;code&gt;LocalManager&lt;/code&gt;, the manager responsible for starting workers on the same host, is implemented:</source>
          <target state="translated">例として、同じホストでワーカーを開始する責任を負うマネージャーである &lt;code&gt;LocalManager&lt;/code&gt; がどのように実装されるかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="5ea2f3f22affe5b0503e1b98807df2e143d66e8a" translate="yes" xml:space="preserve">
          <source>As an example of a non-TCP/IP transport, an implementation may choose to use MPI, in which case &lt;code&gt;--worker&lt;/code&gt; must NOT be specified. Instead, newly launched workers should call &lt;code&gt;init_worker(cookie)&lt;/code&gt; before using any of the parallel constructs.</source>
          <target state="translated">非TCP / IPトランスポートの例として、実装はMPIの使用を選択できます。その場合、 &lt;code&gt;--worker&lt;/code&gt; 指定してはなりません。代わりに、新しく起動されたワーカーは、並列構造を使用する前に &lt;code&gt;init_worker(cookie)&lt;/code&gt; を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="8d94b4e364183ef3f6a858e77d060fb33ee15b1a" translate="yes" xml:space="preserve">
          <source>As an example, suppose a package directory has the following structure and content:</source>
          <target state="translated">例として、パッケージディレクトリが以下のような構造と内容を持っているとします。</target>
        </trans-unit>
        <trans-unit id="1237948f9e574bfd646187c2b196cb56c33c770b" translate="yes" xml:space="preserve">
          <source>As an example, suppose you wanted to define multiplication on symbols in a module:</source>
          <target state="translated">例として、モジュール内のシンボルに対する乗算を定義したいとします。</target>
        </trans-unit>
        <trans-unit id="59a193ac31c3261e6bf490ce9642a1cb05737a81" translate="yes" xml:space="preserve">
          <source>As an example, the builtin &lt;code&gt;AbstractRange&lt;/code&gt; objects use this machinery to optimize pieces of broadcasted expressions that can be eagerly evaluated purely in terms of the start, step, and length (or stop) instead of computing every single element. Just like all the other machinery, &lt;code&gt;broadcasted&lt;/code&gt; also computes and exposes the combined broadcast style of its arguments, so instead of specializing on &lt;code&gt;broadcasted(f, args...)&lt;/code&gt;, you can specialize on &lt;code&gt;broadcasted(::DestStyle, f, args...)&lt;/code&gt; for any combination of style, function, and arguments.</source>
          <target state="translated">例として、組み込みの &lt;code&gt;AbstractRange&lt;/code&gt; オブジェクトはこのメカニズムを使用して、すべての単一の要素を計算する代わりに、開始、ステップ、および長さ（または停止）の観点から純粋に熱心に評価できるブロードキャスト式の断片を最適化します。他のすべての機構と同様に、 &lt;code&gt;broadcasted&lt;/code&gt; も引数の結合ブロードキャストスタイルを計算して公開するため、 &lt;code&gt;broadcasted(f, args...)&lt;/code&gt; に特化する代わりに、 &lt;code&gt;broadcasted(::DestStyle, f, args...)&lt;/code&gt; スタイル、関数、および引数の任意の組み合わせ。</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">一例として。</target>
        </trans-unit>
        <trans-unit id="87ed434d0000a98d4576d846e0e095b93bb4582f" translate="yes" xml:space="preserve">
          <source>As an extension of this, in cases where the algorithm needs a copy of the input array, &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; is insufficient as the return value may alias the original input. Combining &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; (to make the output array) and &lt;a href=&quot;../../base/c/index#Base.copyto!&quot;&gt;&lt;code&gt;copyto!&lt;/code&gt;&lt;/a&gt; (to fill it with the input data) is a generic way to express the requirement for a mutable copy of the input argument:</source>
          <target state="translated">これの拡張として、アルゴリズムが入力配列のコピーを必要とする場合、戻り値が元の入力にエイリアスを付ける可能性があるため、&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;は不十分です。組み合わせると&lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt;（出力配列を作るために）と&lt;a href=&quot;../../base/c/index#Base.copyto!&quot;&gt; &lt;code&gt;copyto!&lt;/code&gt; &lt;/a&gt;（入力データを入力する）は、入力引数の変更可能なコピーの要件を表す一般的な方法です。</target>
        </trans-unit>
        <trans-unit id="f8ea3b19e7de523c7e9925d469ae1f1489b7d884" translate="yes" xml:space="preserve">
          <source>As another example, here is a function that doubles any numeric argument, but leaves expressions alone:</source>
          <target state="translated">別の例として、任意の数値引数を倍にしますが、式だけは残しておく関数を以下に示します。</target>
        </trans-unit>
        <trans-unit id="5a98ec0590a6653411278e5178b7dfd6cf089ca2" translate="yes" xml:space="preserve">
          <source>As calculations on floating-point values can be imprecise, you can perform approximate equality checks using either &lt;code&gt;@test a &amp;asymp; b&lt;/code&gt; (where &lt;code&gt;&amp;asymp;&lt;/code&gt;, typed via tab completion of &lt;code&gt;\approx&lt;/code&gt;, is the &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt; function) or use &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">浮動小数点値の計算が不正確なことができるように、あなたがいずれかを使用しておおよその等価性チェックを実行することができます &lt;code&gt;@test a &amp;asymp; b&lt;/code&gt; （どこ &lt;code&gt;&amp;asymp;&lt;/code&gt; のタブ補完を経て入力された、 &lt;code&gt;\approx&lt;/code&gt; 、ある&lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; の&lt;/a&gt;か、利用機能）&lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; &lt;/a&gt;直接。</target>
        </trans-unit>
        <trans-unit id="671cfcc401170439c76fc45750de84c7f63c05ee" translate="yes" xml:space="preserve">
          <source>As can be seen once again, a remote call onto the local node behaves just like a direct invocation. The call modifies local objects passed as arguments. In the remote invocation, it operates on a copy of the arguments.</source>
          <target state="translated">もう一度見てわかるように、ローカル・ノードへのリモート呼び出しは、直接呼び出しと同じように動作します。呼び出しは、引数として渡されたローカルオブジェクトを変更します。リモート呼び出しでは、引数のコピーを操作します。</target>
        </trans-unit>
        <trans-unit id="3cc0d715da9528bac336fc93fd62b1b74187bec5" translate="yes" xml:space="preserve">
          <source>As can be seen, &lt;code&gt;A&lt;/code&gt; is changed to the sorted array &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt;. Note that Julia knows how to convert an array into a &lt;code&gt;Ptr{Cdouble}&lt;/code&gt;, how to compute the size of a type in bytes (identical to C's &lt;code&gt;sizeof&lt;/code&gt; operator), and so on. For fun, try inserting a &lt;code&gt;println(&quot;mycompare($a, $b)&quot;)&lt;/code&gt; line into &lt;code&gt;mycompare&lt;/code&gt;, which will allow you to see the comparisons that &lt;code&gt;qsort&lt;/code&gt; is performing (and to verify that it is really calling the Julia function that you passed to it).</source>
          <target state="translated">見て分かるように、 &lt;code&gt;A&lt;/code&gt; はソートされた配列 &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt; 変更されます。 Juliaは、配列を &lt;code&gt;Ptr{Cdouble}&lt;/code&gt; に変換する方法、型のサイズをバイト単位で計算する方法（Cの &lt;code&gt;sizeof&lt;/code&gt; 演算子と同じ）などを知っていることに注意してください。面白くするには、 &lt;code&gt;println(&quot;mycompare($a, $b)&quot;)&lt;/code&gt; 行を &lt;code&gt;mycompare&lt;/code&gt; に挿入してみてください。これにより、 &lt;code&gt;qsort&lt;/code&gt; が実行している比較を確認できます（渡されたJulia関数が本当に呼び出されていることを確認できます）それに）。</target>
        </trans-unit>
        <trans-unit id="4b96915d6aea30f8cc88503d183daf83b43b1570" translate="yes" xml:space="preserve">
          <source>As can be seen, &lt;code&gt;put!&lt;/code&gt; on a locally owned &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; with the same object &lt;code&gt;v&lt;/code&gt; modifed between calls results in the same single object instance stored. As opposed to copies of &lt;code&gt;v&lt;/code&gt; being created when the node owning &lt;code&gt;rc&lt;/code&gt; is a different node.</source>
          <target state="translated">見てわかるように &lt;code&gt;put!&lt;/code&gt; ローカルで所有されている&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt;で、同じオブジェクトを &lt;code&gt;v&lt;/code&gt; 呼び出し間で変更すると、同じ単一のオブジェクトインスタンスが格納されます。 &lt;code&gt;rc&lt;/code&gt; を所有するノードが別のノードであるときに作成される &lt;code&gt;v&lt;/code&gt; のコピーとは対照的です。</target>
        </trans-unit>
        <trans-unit id="e253ba428da9355b11a09e17058388a067c23f87" translate="yes" xml:space="preserve">
          <source>As can be seen, global variable &lt;code&gt;A&lt;/code&gt; is defined on worker 2, but &lt;code&gt;B&lt;/code&gt; is captured as a local variable and hence a binding for &lt;code&gt;B&lt;/code&gt; does not exist on worker 2.</source>
          <target state="translated">ご覧のとおり、グローバル変数 &lt;code&gt;A&lt;/code&gt; はワーカー2で定義されていますが、 &lt;code&gt;B&lt;/code&gt; はローカル変数としてキャプチャされているため、 &lt;code&gt;B&lt;/code&gt; のバインディングはワーカー2に存在しません。</target>
        </trans-unit>
        <trans-unit id="76f93ab509f4540b19db8475dd078bd3d9ad56c4" translate="yes" xml:space="preserve">
          <source>As convenient as date-period arithmetic is, often the kinds of calculations needed on dates take on a &lt;em&gt;calendrical&lt;/em&gt; or &lt;em&gt;temporal&lt;/em&gt; nature rather than a fixed number of periods. Holidays are a perfect example; most follow rules such as &quot;Memorial Day = Last Monday of May&quot;, or &quot;Thanksgiving = 4th Thursday of November&quot;. These kinds of temporal expressions deal with rules relative to the calendar, like first or last of the month, next Tuesday, or the first and third Wednesdays, etc.</source>
          <target state="translated">日付と期間の計算と同じくらい便利ですが、多くの場合、日付に必要な種類の計算は、固定数の期間ではなく、&lt;em&gt;暦&lt;/em&gt;&lt;em&gt;的&lt;/em&gt;または&lt;em&gt;時間的な&lt;/em&gt;性質を帯びます。祝日は完璧な例です。ほとんどの場合、「記念日= 5月の最終月曜日」、「感謝祭= 11月の第4木曜日」などのルールに従います。これらの種類の時間表現は、月の最初または最後、次の火曜日、または第1および第3水曜日など、カレンダーに関連するルールを扱います。</target>
        </trans-unit>
        <trans-unit id="a1c026427d4e0f63d2dc15ae37577d2f94eafa8a" translate="yes" xml:space="preserve">
          <source>As expected we saw &quot;Hello World&quot; printed. So, let's actually analyze what happened behind the scenes. When we called &lt;code&gt;connect&lt;/code&gt;, we connect to the server we had just created. Meanwhile, the accept function returns a server-side connection to the newly created socket and prints &quot;Hello World&quot; to indicate that the connection was successful.</source>
          <target state="translated">予想通り、「Hello World」が印刷されました。それでは、舞台裏で何が起こったかを実際に分析してみましょう。 &lt;code&gt;connect&lt;/code&gt; を呼び出すと、作成したサーバーに接続します。一方、accept関数は、新しく作成されたソケットへのサーバー側接続を返し、接続が成功したことを示す「Hello World」を出力します。</target>
        </trans-unit>
        <trans-unit id="2bb0a271b40c54ec6b4884cb957952b84f3d4f5b" translate="yes" xml:space="preserve">
          <source>As for &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;SparseVector&lt;/code&gt; type can also contain explicitly stored zeros. (See &lt;a href=&quot;#man-csc-1&quot;&gt;Sparse Matrix Storage&lt;/a&gt;.).</source>
          <target state="translated">&lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC&lt;/code&gt; の&lt;/a&gt;場合と同様に、 &lt;code&gt;SparseVector&lt;/code&gt; タイプには明示的に格納されたゼロを含めることもできます。（&lt;a href=&quot;#man-csc-1&quot;&gt;スパースマトリックスストレージを&lt;/a&gt;参照してください）。</target>
        </trans-unit>
        <trans-unit id="fc146c2940c0c078ab8141567616fc6c9d0de40c" translate="yes" xml:space="preserve">
          <source>As for hexadecimal literals, binary and octal literals produce unsigned integer types. The size of the binary data item is the minimal needed size, if the leading digit of the literal is not &lt;code&gt;0&lt;/code&gt;. In the case of leading zeros, the size is determined by the minimal needed size for a literal, which has the same length but leading digit &lt;code&gt;1&lt;/code&gt;. That allows the user to control the size. Values which cannot be stored in &lt;code&gt;UInt128&lt;/code&gt; cannot be written as such literals.</source>
          <target state="translated">16進リテラルと同様に、2進および8進リテラルは符号なし整数型を生成します。リテラルの先頭の桁が &lt;code&gt;0&lt;/code&gt; でない場合、バイナリデータ項目のサイズは、必要な最小サイズです。先行ゼロの場合、サイズはリテラルに必要な最小サイズによって決定されます。リテラルは同じ長さで先頭桁が &lt;code&gt;1&lt;/code&gt; です。これにより、ユーザーはサイズを制御できます。 &lt;code&gt;UInt128&lt;/code&gt; に格納できない値は、そのようなリテラルとして書き込むことはできません。</target>
        </trans-unit>
        <trans-unit id="6db8bde5f510430fc099aa246b7efd8ae6ef4908" translate="yes" xml:space="preserve">
          <source>As for numeric arrays, choosing a non-stable default algorithm for array types for which the notion of a stable sort is meaningless (i.e. when two values comparing equal can not be distinguished) may make sense.</source>
          <target state="translated">数値配列については,安定ソートの概念が無意味な配列型(すなわち,等しい値を比較する2つの値が区別できない場合)に対して,安定しないデフォルトアルゴリズムを選択することは意味があるかもしれません.</target>
        </trans-unit>
        <trans-unit id="5657074766ca713487af1f45c8fe2527e89dae0c" translate="yes" xml:space="preserve">
          <source>As for single values, use &lt;a href=&quot;../../base/base/index#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt; to treat &lt;code&gt;missing&lt;/code&gt; values as equal to other &lt;code&gt;missing&lt;/code&gt; values but different from non-missing values</source>
          <target state="translated">単一の値については、&lt;a href=&quot;../../base/base/index#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; &lt;/a&gt;を使用して、 &lt;code&gt;missing&lt;/code&gt; 値を他の &lt;code&gt;missing&lt;/code&gt; 値と同等であるが欠損値以外とは異なるものとして扱います</target>
        </trans-unit>
        <trans-unit id="80909a25deba83e5c549936818feccfa43f85abd" translate="yes" xml:space="preserve">
          <source>As hinted above, one extremely useful feature of Julia is the capability to generate and manipulate Julia code within Julia itself. We have already seen one example of a function returning &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; objects: the &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; function, which takes a string of Julia code and returns the corresponding &lt;code&gt;Expr&lt;/code&gt;. A function can also take one or more &lt;code&gt;Expr&lt;/code&gt; objects as arguments, and return another &lt;code&gt;Expr&lt;/code&gt;. Here is a simple, motivating example:</source>
          <target state="translated">上で示唆したように、Juliaの非常に便利な機能の1つは、Julia自体の中でJuliaコードを生成および操作する機能です。&lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt;オブジェクトを返す関数の1つの例、つまり、Juliaコードの文字列を取り、対応する &lt;code&gt;Expr&lt;/code&gt; を返す&lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;関数を見てきました。関数は、1つ以上の &lt;code&gt;Expr&lt;/code&gt; オブジェクトを引数として取り、別の &lt;code&gt;Expr&lt;/code&gt; を返すこともできます。シンプルでやる気を起こさせる例を次に示します。</target>
        </trans-unit>
        <trans-unit id="0e3a8b594e44456d63d508da5257e974c3de310d" translate="yes" xml:space="preserve">
          <source>As illustrated in the above example each column of &lt;code&gt;|&lt;/code&gt; characters must be aligned vertically.</source>
          <target state="translated">上記の例に示すように、 &lt;code&gt;|&lt;/code&gt; の各列 文字は垂直方向に配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="51316c0f471c7aa15821993b2904c54c98f59dec" translate="yes" xml:space="preserve">
          <source>As in Java, strings are immutable: the value of an &lt;code&gt;AbstractString&lt;/code&gt; object cannot be changed. To construct a different string value, you construct a new string from parts of other strings.</source>
          <target state="translated">Javaと同様に、文字列は不変です &lt;code&gt;AbstractString&lt;/code&gt; オブジェクトの値は変更できません。別の文字列値を作成するには、他の文字列の一部から新しい文字列を作成します。</target>
        </trans-unit>
        <trans-unit id="972bb7e6b4d2b9c22f53c9f2f7dc30a1be414e25" translate="yes" xml:space="preserve">
          <source>As in the example above, we recommend following some simple conventions when writing documentation:</source>
          <target state="translated">上記の例のように、ドキュメントを書く際には、いくつかの簡単な規約に従うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="42eaaebd11c27f9b1c1515d18b277f999ad14b89" translate="yes" xml:space="preserve">
          <source>As it was mentioned &lt;code&gt;CodeUnits{UInt8,String}&lt;/code&gt; type behaves like read only array of &lt;code&gt;UInt8&lt;/code&gt; and if you need a standard vector you can convert it using &lt;code&gt;Vector{UInt8}&lt;/code&gt;:</source>
          <target state="translated">言及したように、 &lt;code&gt;CodeUnits{UInt8,String}&lt;/code&gt; 型は &lt;code&gt;UInt8&lt;/code&gt; の読み取り専用配列のように動作し、標準のベクターが必要な場合は、 &lt;code&gt;Vector{UInt8}&lt;/code&gt; を使用して変換できます。</target>
        </trans-unit>
        <trans-unit id="ba1acaea73293bc8197cce97bdfefcad05927f1a" translate="yes" xml:space="preserve">
          <source>As mentioned above, one can also define new display backends. For example, a module that can display PNG images in a window can register this capability with Julia, so that calling &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; on types with PNG representations will automatically display the image using the module's window.</source>
          <target state="translated">上記のように、新しいディスプレイバックエンドを定義することもできます。たとえば、PNG画像をウィンドウに表示できるモジュールは、この機能をJuliaに登録できるため、PNG表現を持つ型で&lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt;を呼び出すと、モジュールのウィンドウを使用して画像が自動的に表示されます。</target>
        </trans-unit>
        <trans-unit id="fb063e502e9f2dd374cf5645d0ea6281db87f213" translate="yes" xml:space="preserve">
          <source>As mentioned briefly in &lt;a href=&quot;../functions/index#man-functions-1&quot;&gt;Functions&lt;/a&gt;, optional arguments are implemented as syntax for multiple method definitions. For example, this definition:</source>
          <target state="translated">&lt;a href=&quot;../functions/index#man-functions-1&quot;&gt;関数&lt;/a&gt;で簡単に説明したように、オプションの引数は複数のメソッド定義の構文として実装されます。たとえば、この定義は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="191e5fd5542b028418c413dac2b44eaff01d364f" translate="yes" xml:space="preserve">
          <source>As of this writing, the valid Unicode code points are &lt;code&gt;U+00&lt;/code&gt; through &lt;code&gt;U+d7ff&lt;/code&gt; and &lt;code&gt;U+e000&lt;/code&gt; through &lt;code&gt;U+10ffff&lt;/code&gt;. These have not all been assigned intelligible meanings yet, nor are they necessarily interpretable by applications, but all of these values are considered to be valid Unicode characters.</source>
          <target state="translated">これを書いているように、有効なUnicodeコードポイントは &lt;code&gt;U+00&lt;/code&gt; を介して &lt;code&gt;U+d7ff&lt;/code&gt; と &lt;code&gt;U+e000&lt;/code&gt; を介して &lt;code&gt;U+10ffff&lt;/code&gt; 。これらのすべてにまだわかりやすい意味が割り当てられているわけではなく、必ずしもアプリケーションで解釈できるわけでもありませんが、これらの値はすべて有効なUnicode文字と見なされます。</target>
        </trans-unit>
        <trans-unit id="c64e98d3602dd7e8a13d28a764d202fba2aba952" translate="yes" xml:space="preserve">
          <source>As one can see here, &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt; simply returns true or false, indicating whether a match for the given regex occurs in the string. Commonly, however, one wants to know not just whether a string matched, but also &lt;em&gt;how&lt;/em&gt; it matched. To capture this information about a match, use the &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; function instead:</source>
          <target state="translated">ここに見られるように、&lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; &lt;/a&gt;単にtrueまたはfalseを返し、指定された正規表現との一致が文字列で発生するかどうかを示します。ただし、一般的には、文字列が一致したかどうかだけでなく、文字列が&lt;em&gt;どのよう&lt;/em&gt;に一致したかも知りたいと思っています。一致に関するこの情報を取得するには、代わりに&lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;関数を使用します。</target>
        </trans-unit>
        <trans-unit id="c4a14a67f1bf4cea327a2eb12b0f80f0eef678ff" translate="yes" xml:space="preserve">
          <source>As the error states, an immediate cause of an &lt;code&gt;UndefVarError&lt;/code&gt; on a remote node is that a binding by that name does not exist. Let us explore some of the possible causes.</source>
          <target state="translated">エラーが示す &lt;code&gt;UndefVarError&lt;/code&gt; に、リモートノードでのUndefVarErrorの直接の原因は、その名前によるバインディングが存在しないことです。考えられる原因のいくつかを調べてみましょう。</target>
        </trans-unit>
        <trans-unit id="1eb17e26ef0507943bf96943b437f10fc48bc317" translate="yes" xml:space="preserve">
          <source>As the example implies, the following command-line arguments to &lt;code&gt;julia&lt;/code&gt; are interpreted as command-line arguments to the program &lt;code&gt;script.jl&lt;/code&gt;, passed in the global constant &lt;code&gt;ARGS&lt;/code&gt;. The name of the script itself is passed in as the global &lt;code&gt;PROGRAM_FILE&lt;/code&gt;. Note that &lt;code&gt;ARGS&lt;/code&gt; is also set when a Julia expression is given using the &lt;code&gt;-e&lt;/code&gt; option on the command line (see the &lt;code&gt;julia&lt;/code&gt; help output below) but &lt;code&gt;PROGRAM_FILE&lt;/code&gt; will be empty. For example, to just print the arguments given to a script, you could do this:</source>
          <target state="translated">例が示すように、次のコマンドライン引数 &lt;code&gt;julia&lt;/code&gt; プログラムのコマンドライン引数として解釈され &lt;code&gt;script.jl&lt;/code&gt; グローバル定数が渡され、 &lt;code&gt;ARGS&lt;/code&gt; 。スクリプト自体の名前は、グローバル &lt;code&gt;PROGRAM_FILE&lt;/code&gt; として渡されます。注があること &lt;code&gt;ARGS&lt;/code&gt; ジュリア式を使用して与えられたときにも設定されている &lt;code&gt;-e&lt;/code&gt; コマンドラインでオプションを（参照 &lt;code&gt;julia&lt;/code&gt; 以下のヘルプ出力）が、 &lt;code&gt;PROGRAM_FILE&lt;/code&gt; は空になります。たとえば、スクリプトに与えられた引数を出力するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="981be6ff2cc90e0e705ac3383fc828a6dbdc7827" translate="yes" xml:space="preserve">
          <source>As this example shows, the element type of such arrays is &lt;code&gt;Union{Missing, T}&lt;/code&gt;, with &lt;code&gt;T&lt;/code&gt; the type of the non-missing values. This simply reflects the fact that array entries can be either of type &lt;code&gt;T&lt;/code&gt; (here, &lt;code&gt;Int64&lt;/code&gt;) or of type &lt;code&gt;Missing&lt;/code&gt;. This kind of array uses an efficient memory storage equivalent to an &lt;code&gt;Array{T}&lt;/code&gt; holding the actual values combined with an &lt;code&gt;Array{UInt8}&lt;/code&gt; indicating the type of the entry (i.e. whether it is &lt;code&gt;Missing&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;).</source>
          <target state="translated">この例が示すように、そのような配列の要素型は &lt;code&gt;Union{Missing, T}&lt;/code&gt; であり、 &lt;code&gt;T&lt;/code&gt; は非欠損値の型です。これは、配列エントリがタイプ &lt;code&gt;T&lt;/code&gt; （ここでは、 &lt;code&gt;Int64&lt;/code&gt; ）またはタイプ &lt;code&gt;Missing&lt;/code&gt; のいずれかになる可能性があるという事実を単に反映しています。アレイのこの種のに効率的なメモリ記憶等価物を使用し &lt;code&gt;Array{T}&lt;/code&gt; と組み合わせる実際の値保持 &lt;code&gt;Array{UInt8}&lt;/code&gt; （それがされているか否か、すなわち、エントリの種類を示す &lt;code&gt;Missing&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を）。</target>
        </trans-unit>
        <trans-unit id="c38e97b2426f385efa12439902693dc14bf8618f" translate="yes" xml:space="preserve">
          <source>As usual, the absolute value (&lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt;) of a complex number is its distance from zero. &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt;&lt;code&gt;abs2&lt;/code&gt;&lt;/a&gt; gives the square of the absolute value, and is of particular use for complex numbers since it avoids taking a square root. &lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/a&gt; returns the phase angle in radians (also known as the &lt;em&gt;argument&lt;/em&gt; or &lt;em&gt;arg&lt;/em&gt; function). The full gamut of other &lt;a href=&quot;../mathematical-operations/index#Elementary-Functions-1&quot;&gt;Elementary Functions&lt;/a&gt; is also defined for complex numbers:</source>
          <target state="translated">通常、複素数の絶対値（&lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt; &lt;code&gt;abs&lt;/code&gt; &lt;/a&gt;）はゼロからの距離です。&lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt; &lt;code&gt;abs2&lt;/code&gt; &lt;/a&gt;は絶対値の2乗を与え、平方根をとらないので複素数に特に役立ちます。&lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt; &lt;code&gt;angle&lt;/code&gt; &lt;/a&gt;は、位相角をラジアンで返します（&lt;em&gt;argument&lt;/em&gt;または&lt;em&gt;arg&lt;/em&gt;関数とも呼ばれます）。他の&lt;a href=&quot;../mathematical-operations/index#Elementary-Functions-1&quot;&gt;基本関数&lt;/a&gt;の全範囲も複素数に対して定義されています。</target>
        </trans-unit>
        <trans-unit id="b6a7588d6f9c25c0288fa6f4060bf2933853ea1a" translate="yes" xml:space="preserve">
          <source>As usual, the promotion system makes interactions with other numeric types effortless:</source>
          <target state="translated">いつものように、プロモーションシステムは他の数値型とのやりとりを楽にしてくれます。</target>
        </trans-unit>
        <trans-unit id="0ac972252ac8a4d2677fb97cc60dc48ab7bb4888" translate="yes" xml:space="preserve">
          <source>As usual, this does not bring &lt;code&gt;DummyModule&lt;/code&gt; into scope on any of the process, which requires &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;. Moreover, when &lt;code&gt;DummyModule&lt;/code&gt; is brought into scope on one process, it is not on any other:</source>
          <target state="translated">いつものように、これは &lt;code&gt;DummyModule&lt;/code&gt; をどのプロセスのスコープにも持ち込まず、 &lt;code&gt;using&lt;/code&gt; または &lt;code&gt;import&lt;/code&gt; が必要です。さらに、 &lt;code&gt;DummyModule&lt;/code&gt; が1つのプロセスのスコープに含まれる場合、他のプロセスには適用されません。</target>
        </trans-unit>
        <trans-unit id="f7ffd73a9506b0079b3703beb529178a185c5762" translate="yes" xml:space="preserve">
          <source>As we have seen in &lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code-1&quot;&gt;Calling C and Fortran Code&lt;/a&gt;, Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C#).</source>
          <target state="translated">&lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code-1&quot;&gt;Calling C and Fortran Code&lt;/a&gt;で見たように、Juliaには、Cで記述された関数を呼び出すためのシンプルで効率的な方法があります。これは、C / C ++ですべてを書き直す必要なく、Juliaコードをより大きなC / C ++プロジェクトに統合するために使用できます。 Juliaには、これを可能にするC APIがあります。ほとんどすべてのプログラミング言語にはC関数を呼び出す方法があるため、Julia C APIを使用して、さらに言語ブリッジを構築することもできます（たとえば、PythonまたはC＃からJuliaを呼び出す）。</target>
        </trans-unit>
        <trans-unit id="82c0a21a8d879f7a5c7272f023db6b90d1239835" translate="yes" xml:space="preserve">
          <source>As we have seen, Julia objects are represented in C as pointers. This raises the question of who is responsible for freeing these objects.</source>
          <target state="translated">これまで見てきたように、ジュリアのオブジェクトはC言語ではポインタとして表現されます。このことは、これらのオブジェクトを解放する責任は誰にあるのかという問題を提起しています。</target>
        </trans-unit>
        <trans-unit id="8632fecc892c2a5175874dd3d5957b71b599c90f" translate="yes" xml:space="preserve">
          <source>As we have seen, a typical parametric type has inner constructors that are called when type parameters are known; e.g. they apply to &lt;code&gt;Point{Int}&lt;/code&gt; but not to &lt;code&gt;Point&lt;/code&gt;. Optionally, outer constructors that determine type parameters automatically can be added, for example constructing a &lt;code&gt;Point{Int}&lt;/code&gt; from the call &lt;code&gt;Point(1,2)&lt;/code&gt;. Outer constructors call inner constructors to actually make instances. However, in some cases one would rather not provide inner constructors, so that specific type parameters cannot be requested manually.</source>
          <target state="translated">これまで見てきたように、典型的なパラメトリック型には、型パラメーターがわかっているときに呼び出される内部コンストラクターがあります。例えば、彼らはに適用する &lt;code&gt;Point{Int}&lt;/code&gt; なくする &lt;code&gt;Point&lt;/code&gt; 。オプションで、型パラメーターを自動的に決定する外部コンストラクターを追加できます。たとえば、呼び出し &lt;code&gt;Point(1,2)&lt;/code&gt; から &lt;code&gt;Point{Int}&lt;/code&gt; を作成します。外部コンストラクターは内部コンストラクターを呼び出して、実際にインスタンスを作成します。ただし、特定の型パラメーターを手動で要求できないように、内部コンストラクターを提供したくない場合もあります。</target>
        </trans-unit>
        <trans-unit id="92ef7f3ff78c47fd1600b930f6d1226b1a4419f4" translate="yes" xml:space="preserve">
          <source>As we have seen, such expressions support interpolation with &lt;code&gt;$&lt;/code&gt;. However, in some situations it is necessary to quote code &lt;em&gt;without&lt;/em&gt; performing interpolation. This kind of quoting does not yet have syntax, but is represented internally as an object of type &lt;code&gt;QuoteNode&lt;/code&gt;. The parser yields &lt;code&gt;QuoteNode&lt;/code&gt;s for simple quoted items like symbols:</source>
          <target state="translated">見てきたように、そのような式は &lt;code&gt;$&lt;/code&gt; による補間をサポートしています。ただし、状況によっては、補間&lt;em&gt;を&lt;/em&gt;実行&lt;em&gt;せずに&lt;/em&gt;コードを引用する必要があります。この種類の引用にはまだ構文はありませんが、内部的には &lt;code&gt;QuoteNode&lt;/code&gt; 型のオブジェクトとして表されます。パーサーは、記号のような単純な引用符で囲まれたアイテムの &lt;code&gt;QuoteNode&lt;/code&gt; を生成します。</target>
        </trans-unit>
        <trans-unit id="cfe3955e5cc39192c40411a547d67109141fbd1c" translate="yes" xml:space="preserve">
          <source>As we will see next, boxing is required to call Julia functions with specific arguments.</source>
          <target state="translated">次に見るように、特定の引数でJuliaの関数を呼び出すためにはBoxingが必要です。</target>
        </trans-unit>
        <trans-unit id="b53a534247af6d63db181fe8ad6536af06cae1ff" translate="yes" xml:space="preserve">
          <source>As well as information about the &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt;'s year and quarter:</source>
          <target state="translated">&lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt;の年と四半期に関する情報と同様に：</target>
        </trans-unit>
        <trans-unit id="834e03682d6f73b9df03b1d3810b4934cc9cc3a8" translate="yes" xml:space="preserve">
          <source>As well as other useful operations, such as finding eigenvalues or eigenvectors:</source>
          <target state="translated">固有値や固有ベクトルを求めるなど、他の有用な操作と同様に。</target>
        </trans-unit>
        <trans-unit id="ce2d2a88a78a8f4ae1b7b6c89e850d2a3f2b6a48" translate="yes" xml:space="preserve">
          <source>As with any &lt;code&gt;ccall&lt;/code&gt;, it is essential to get the argument signature exactly correct. Also, note that there is no compatibility layer that ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by &lt;code&gt;Core.Intrinsics&lt;/code&gt;.</source>
          <target state="translated">他の &lt;code&gt;ccall&lt;/code&gt; と同様に、引数の署名を正確に取得することが不可欠です。また、 &lt;code&gt;Core.Intrinsics&lt;/code&gt; によって公開されている同等のJulia関数とは異なり、組み込み関数が意味をなし、現在のターゲットで機能することを保証する互換性レイヤーがないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f496eca34c1af36fc9e6f49533f03b24b7584356" translate="yes" xml:space="preserve">
          <source>As with incomplete objects returned from constructors, if &lt;code&gt;complete_me&lt;/code&gt; or any of its callees try to access the &lt;code&gt;data&lt;/code&gt; field of the &lt;code&gt;Lazy&lt;/code&gt; object before it has been initialized, an error will be thrown immediately.</source>
          <target state="translated">コンストラクタから返される不完全なオブジェクトと同様に、 &lt;code&gt;complete_me&lt;/code&gt; またはその呼び出し先のいずれかが、初期化される前に &lt;code&gt;Lazy&lt;/code&gt; オブジェクトの &lt;code&gt;data&lt;/code&gt; フィールドにアクセスしようとすると、すぐにエラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="206e9628ecffc277c3db7c6ada272a26870edc0c" translate="yes" xml:space="preserve">
          <source>As with literals in the previous section, if literal backticks need to be written within double backticks use an even number greater than two. Note that if a single literal backtick needs to be included within $\LaTeX$ markup then two enclosing backticks is sufficient.</source>
          <target state="translated">前節のリテラルの場合と同様に、リテラルバックティックをダブルバックティックの中に書く必要がある場合は、2つ以上の偶数を使用してください。単一のリテラルバックティックが$LaTeX$マークアップの中に含まれる必要がある場合は、2つの囲みバックティックで十分であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="eb071802c875eedf2628f279f3c3aa261b7f9f4a" translate="yes" xml:space="preserve">
          <source>As with other streams, use &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; to disconnect the socket:</source>
          <target state="translated">他のストリームと同様に、&lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;を使用してソケットを切断します。</target>
        </trans-unit>
        <trans-unit id="4caebefb85f01f12aff5118bde420090e55936d8" translate="yes" xml:space="preserve">
          <source>As with variables, Unicode can also be used for function names:</source>
          <target state="translated">変数と同様に、関数名にも Unicode を使用することができます。</target>
        </trans-unit>
        <trans-unit id="f11a9dc367827aceb27fae5caffbfb8a44dc892b" translate="yes" xml:space="preserve">
          <source>As you can see in the examples, logging statements make no mention of where log events go or how they are processed. This is a key design feature that makes the system composable and natural for concurrent use. It does this by separating two different concerns:</source>
          <target state="translated">例を見ればわかるように、ロギングステートメントでは、ログイベントがどこに行くのか、どのように処理されるのかについては一切言及されていません。これは、システムをコンポーザブルで自然な形で同時使用できるようにするための重要な設計機能です。これは、2つの異なる懸念事項を分離することで実現しています。</target>
        </trans-unit>
        <trans-unit id="4b2d88632a2082abc54ba7d8928178e89f90f7d3" translate="yes" xml:space="preserve">
          <source>As you can see, for constructor calls with explicit type parameters, the arguments are converted to the implied field types: &lt;code&gt;Point{Int64}(1,2)&lt;/code&gt; works, but &lt;code&gt;Point{Int64}(1.0,2.5)&lt;/code&gt; raises an &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; when converting &lt;code&gt;2.5&lt;/code&gt; to &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;. When the type is implied by the arguments to the constructor call, as in &lt;code&gt;Point(1,2)&lt;/code&gt;, then the types of the arguments must agree &amp;ndash; otherwise the &lt;code&gt;T&lt;/code&gt; cannot be determined &amp;ndash; but any pair of real arguments with matching type may be given to the generic &lt;code&gt;Point&lt;/code&gt; constructor.</source>
          <target state="translated">：あなたが見ることができるように、明示的な型のパラメータを持つコンストラクタコールの場合、引数は暗黙のフィールドタイプに変換され &lt;code&gt;Point{Int64}(1,2)&lt;/code&gt; 動作しますが、 &lt;code&gt;Point{Int64}(1.0,2.5)&lt;/code&gt; 提起&lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; を&lt;/a&gt;変換する際に &lt;code&gt;2.5&lt;/code&gt; &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;Point(1,2)&lt;/code&gt; のように、コンストラクター呼び出しの引数によって型が暗黙指定されている場合、引数の型は一致する必要があります。そうでない場合、 &lt;code&gt;T&lt;/code&gt; を決定できません。ただし、型が一致する実引数のペアはすべて指定できます。ジェネリック &lt;code&gt;Point&lt;/code&gt; コンストラクターに。</target>
        </trans-unit>
        <trans-unit id="5461c0708bdec655ec8f2787ade84a59cba9a62f" translate="yes" xml:space="preserve">
          <source>As you can see, if the wrong number of elements are in the splatted container, then the function call will fail, just as it would if too many arguments were given explicitly.</source>
          <target state="translated">ご覧のように、間違った数の要素がスプラットされたコンテナにある場合、関数呼び出しは失敗します。</target>
        </trans-unit>
        <trans-unit id="e203af061ceae4264896923db832aa0fc04bb217" translate="yes" xml:space="preserve">
          <source>As you can see, in the first line we asked process 2 to construct a 2-by-2 random matrix, and in the second line we asked it to add 1 to it. The result of both calculations is available in the two futures, &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;. The &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; macro evaluates the expression in the second argument on the process specified by the first argument.</source>
          <target state="translated">ご覧のとおり、最初の行でプロセス2に2行2列のランダム行列を作成するように依頼し、2行目で1を追加するように依頼しました。両方の計算結果は、2つの先物 &lt;code&gt;r&lt;/code&gt; と &lt;code&gt;s&lt;/code&gt; で利用できます。&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt;マクロは、最初の引数で指定されたプロセス上の二番目の引数での発現を評価します。</target>
        </trans-unit>
        <trans-unit id="741e859119d8cfeca907f894902aa3d526d932dd" translate="yes" xml:space="preserve">
          <source>As you can see, the arguments must be precisely of type &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. Other numeric types, such as integers or 32-bit floating-point values, are not automatically converted to 64-bit floating-point, nor are strings parsed as numbers. Because &lt;code&gt;Float64&lt;/code&gt; is a concrete type and concrete types cannot be subclassed in Julia, such a definition can only be applied to arguments that are exactly of type &lt;code&gt;Float64&lt;/code&gt;. It may often be useful, however, to write more general methods where the declared parameter types are abstract:</source>
          <target state="translated">ご覧のとおり、引数は&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;型でなければなりません。整数や32ビット浮動小数点値などの他の数値型は、64ビット浮動小数点に自動的に変換されず、文字列は数値として解析されません。ので &lt;code&gt;Float64&lt;/code&gt; 、コンクリートの種類とコンクリートの型はジュリアにサブクラス化することはできませんで、このような定義は厳密に型の引数に適用することもできる &lt;code&gt;Float64&lt;/code&gt; 。ただし、宣言されたパラメーターの型が抽象的である、より一般的なメソッドを作成すると便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="359b67713bb818c1f3c296863f7d844ae4bb9a8a" translate="yes" xml:space="preserve">
          <source>As you can see, the second version, where we used an &lt;code&gt;Int&lt;/code&gt; literal, preserved the type of the input argument, while the first didn't. This is because e.g. &lt;code&gt;promote_type(Int, Float64) == Float64&lt;/code&gt;, and promotion happens with the multiplication. Similarly, &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; literals are less type disruptive than &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; literals, but more disruptive than &lt;code&gt;Int&lt;/code&gt;s:</source>
          <target state="translated">ご覧のとおり、 &lt;code&gt;Int&lt;/code&gt; リテラルを使用した2番目のバージョンでは入力引数の型が保持されていましたが、最初のバージョンでは保持されていませんでした。これは、たとえば、 &lt;code&gt;promote_type(Int, Float64) == Float64&lt;/code&gt; であり、乗算で昇格が行われるためです。同様に、&lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;リテラルは&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;リテラルよりもタイプの混乱は少ないですが、 &lt;code&gt;Int&lt;/code&gt; よりは混乱が多くなります。</target>
        </trans-unit>
        <trans-unit id="a10e4a732e45e67918d07e124985de66438f996f" translate="yes" xml:space="preserve">
          <source>As you can see, the space in the &lt;code&gt;path&lt;/code&gt; variable is appropriately escaped. But what if you &lt;em&gt;want&lt;/em&gt; to interpolate multiple words? In that case, just use an array (or any other iterable container):</source>
          <target state="translated">ご覧のとおり、 &lt;code&gt;path&lt;/code&gt; 変数のスペースは適切にエスケープされています。しかし、複数の単語を補間し&lt;em&gt;たい&lt;/em&gt;場合はどうでしょ&lt;em&gt;う&lt;/em&gt;か？その場合は、配列（またはその他の反復可能なコンテナー）を使用します。</target>
        </trans-unit>
        <trans-unit id="43e3dc387959de6b7b510dc6136369a6354233c2" translate="yes" xml:space="preserve">
          <source>As you can see, the type of the appended element must match the element type of the vector it is appended to, or else a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; is raised. In the following example, the method type parameter &lt;code&gt;T&lt;/code&gt; is used as the return value:</source>
          <target state="translated">ご覧のとおり、追加された要素のタイプは、追加先のベクターの要素タイプと一致する必要があります。一致しない場合、&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;が発生します。次の例では、メソッドタイプパラメータ &lt;code&gt;T&lt;/code&gt; が戻り値として使用されています。</target>
        </trans-unit>
        <trans-unit id="b29b566be209e38051caa728ad8f87323746dc77" translate="yes" xml:space="preserve">
          <source>As you could see, the reduction operator can be omitted if it is not needed. In that case, the loop executes asynchronously, i.e. it spawns independent tasks on all available workers and returns an array of &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; immediately without waiting for completion. The caller can wait for the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; completions at a later point by calling &lt;code&gt;fetch&lt;/code&gt; on them, or wait for completion at the end of the loop by prefixing it with &lt;a href=&quot;../../base/parallel/index#Base.@sync&quot;&gt;&lt;code&gt;@sync&lt;/code&gt;&lt;/a&gt;, like &lt;code&gt;@sync @distributed for&lt;/code&gt;.</source>
          <target state="translated">ご覧のとおり、不要な場合はリダクション演算子を省略できます。その場合、ループは非同期で実行されます。つまり、利用可能なすべてのワーカーで独立したタスクを生成し、完了を待たずにすぐに&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; の&lt;/a&gt;配列を返します。呼び出し元は、後で &lt;code&gt;fetch&lt;/code&gt; を呼び出して&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; の&lt;/a&gt;完了を待機するか、 &lt;code&gt;@sync @distributed for&lt;/code&gt; のように、ループの最後に&lt;a href=&quot;../../base/parallel/index#Base.@sync&quot;&gt; &lt;code&gt;@sync&lt;/code&gt; を&lt;/a&gt;付けて完了を待機することができます。</target>
        </trans-unit>
        <trans-unit id="f1a150349a442b853a138e3c1fe4e3f7948f68a2" translate="yes" xml:space="preserve">
          <source>As you may have realized, while memory associated with globals may be collected when they are reassigned on the master, no such action is taken on the workers as the bindings continue to be valid. &lt;code&gt;clear!&lt;/code&gt; can be used to manually reassign specific globals on remote nodes to &lt;code&gt;nothing&lt;/code&gt; once they are no longer required. This will release any memory associated with them as part of a regular garbage collection cycle.</source>
          <target state="translated">お気づきかもしれませんが、グローバルに関連付けられたメモリはマスターで再割り当てされるときに収集される可能性がありますが、バインディングが引き続き有効であるため、そのようなアクションはワーカーで実行されません。 &lt;code&gt;clear!&lt;/code&gt; リモートノードの特定のグローバルが不要になったら、手動で &lt;code&gt;nothing&lt;/code&gt; 割り当てないようにすることができます。これにより、通常のガベージコレクションサイクルの一部として、関連付けられているメモリが解放されます。</target>
        </trans-unit>
        <trans-unit id="dacd35c567b889475ef2a3c6c433ab70c5f4775a" translate="yes" xml:space="preserve">
          <source>Assign &lt;code&gt;x&lt;/code&gt; to a named field in &lt;code&gt;value&lt;/code&gt; of composite type. The &lt;code&gt;value&lt;/code&gt; must be mutable and &lt;code&gt;x&lt;/code&gt; must be a subtype of &lt;code&gt;fieldtype(typeof(value), name)&lt;/code&gt;. See also &lt;a href=&quot;#Base.setproperty!&quot;&gt;&lt;code&gt;setproperty!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">複合型の &lt;code&gt;value&lt;/code&gt; の名前付きフィールドに &lt;code&gt;x&lt;/code&gt; を割り当てます。 &lt;code&gt;value&lt;/code&gt; 変更可能でなければならず、 &lt;code&gt;x&lt;/code&gt; のサブタイプでなければならない &lt;code&gt;fieldtype(typeof(value), name)&lt;/code&gt; 。&lt;a href=&quot;#Base.setproperty!&quot;&gt; &lt;code&gt;setproperty!&lt;/code&gt; &lt;/a&gt;も参照してください！。</target>
        </trans-unit>
        <trans-unit id="31839985af6b213c58cad9bbfe8e7aebd2198424" translate="yes" xml:space="preserve">
          <source>Assign a value to a key in the current task's task-local storage.</source>
          <target state="translated">現在のタスクのタスクローカルストレージのキーに値を割り当てます。</target>
        </trans-unit>
        <trans-unit id="343021dcf6fd7efdb357d926be862e74219ddb49" translate="yes" xml:space="preserve">
          <source>Assigning &lt;code&gt;[]&lt;/code&gt; does not eliminate elements from a collection; instead use &lt;a href=&quot;../collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; を割り当てても、コレクションから要素が削除されるわけではありません。代わりに&lt;a href=&quot;../collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;を使用してください！。</target>
        </trans-unit>
        <trans-unit id="6144b75b7bde706b0577dc11bf2dc87a5f571732" translate="yes" xml:space="preserve">
          <source>Assigning &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt; does not create a copy of &lt;code&gt;b&lt;/code&gt;; instead use &lt;a href=&quot;#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.deepcopy&quot;&gt;&lt;code&gt;deepcopy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">割り当てに &lt;code&gt;b&lt;/code&gt; のコピーを作成しません &lt;code&gt;b&lt;/code&gt; は、代わりに、&lt;a href=&quot;#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#Base.deepcopy&quot;&gt; &lt;code&gt;deepcopy&lt;/code&gt; を&lt;/a&gt;使用してください。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07a6f2ac6ae10af3c874613ad299e2e22c70e6b5" translate="yes" xml:space="preserve">
          <source>Assigning numbers into &lt;code&gt;a&lt;/code&gt; will now convert them to &lt;code&gt;Float64&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; will be stored as a contiguous block of 64-bit floating-point values that can be manipulated efficiently.</source>
          <target state="translated">番号を割り当てる今にそれらを変換する &lt;code&gt;Float64&lt;/code&gt; と効率的に操作することができる64ビットの浮動小数点値の連続したブロックとして格納されます。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="335227cba10c33b5a2154427c17bb8a45448ea75" translate="yes" xml:space="preserve">
          <source>Assigning to a field of an object converts to the declared type of the field.</source>
          <target state="translated">オブジェクトのフィールドに代入すると、そのフィールドの宣言された型に変換されます。</target>
        </trans-unit>
        <trans-unit id="ea3c536f7d8386d0d34fa46bb187211a095b9597" translate="yes" xml:space="preserve">
          <source>Assigning to a variable with a declared type (e.g. &lt;code&gt;local x::T&lt;/code&gt;) converts to that type.</source>
          <target state="translated">宣言された型（たとえば、 &lt;code&gt;local x::T&lt;/code&gt; ）を持つ変数に割り当てると、その型に変換されます。</target>
        </trans-unit>
        <trans-unit id="4352a222d8d135ef7905c51dc5e73ca198e904f1" translate="yes" xml:space="preserve">
          <source>Assigning to an array converts to the array's element type.</source>
          <target state="translated">配列に代入すると、配列の要素型に変換されます。</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="caee9fcfeeacb92daf3a9dd06e9024b473eac387" translate="yes" xml:space="preserve">
          <source>Assignment at out-of-bounds indices does not grow a collection. If the collection is a &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt;&lt;code&gt;Vector&lt;/code&gt;&lt;/a&gt; it can instead be grown with &lt;a href=&quot;../collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/index#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">範囲外のインデックスでの割り当ては、コレクションを拡大しません。コレクションが&lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt; &lt;code&gt;Vector&lt;/code&gt; &lt;/a&gt;場合は、代わりに&lt;a href=&quot;../collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt;で拡張できます！または&lt;a href=&quot;../collections/index#Base.append!&quot;&gt; &lt;code&gt;append!&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cca9fba860c54e60aaec525df6854ad412b1850b" translate="yes" xml:space="preserve">
          <source>Assignment can operate on multiple variables in parallel, taking values from an iterable:</source>
          <target state="translated">代入は、複数の変数を並行して操作することができ、イテレータブルから値を取ることができます。</target>
        </trans-unit>
        <trans-unit id="729134453eca052fa22a956f1ac0e88899ca88fa" translate="yes" xml:space="preserve">
          <source>Assignment can operate on multiple variables in series, and will return the value of the right-hand-most expression:</source>
          <target state="translated">代入は複数の変数を直列に操作することができ、右端の式の値を返します。</target>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes" xml:space="preserve">
          <source>Assignments</source>
          <target state="translated">Assignments</target>
        </trans-unit>
        <trans-unit id="a997f01f100c5327776cf22824dbe2d9bd2208d2" translate="yes" xml:space="preserve">
          <source>Associate the lifetime of &lt;code&gt;chnl&lt;/code&gt; with a task. &lt;code&gt;Channel&lt;/code&gt;&lt;code&gt;chnl&lt;/code&gt; is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on &lt;code&gt;chnl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;chnl&lt;/code&gt; の存続期間をタスクに関連付けます。タスクが終了すると、 &lt;code&gt;Channel&lt;/code&gt; &lt;code&gt;chnl&lt;/code&gt; は自動的に閉じられます。タスクでキャッチされなかった例外は、 &lt;code&gt;chnl&lt;/code&gt; のすべてのウェイターに伝達されます。</target>
        </trans-unit>
        <trans-unit id="59f2aa2b1552b74e34281b33bf3cbb05f68d9bae" translate="yes" xml:space="preserve">
          <source>Associative collections (such as &lt;code&gt;Dict&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;) need to be re-hashed in &lt;code&gt;__init__&lt;/code&gt;. (In the future, a mechanism may be provided to register an initializer function.)</source>
          <target state="translated">連想コレクション（ &lt;code&gt;Dict&lt;/code&gt; や &lt;code&gt;Set&lt;/code&gt; など）は &lt;code&gt;__init__&lt;/code&gt; で再ハッシュする必要があります。（将来、イニシャライザ関数を登録するメカニズムが提供される可能性があります。）</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="31eabac4e8c06c32e7c19300707a41f9f210b6ee" translate="yes" xml:space="preserve">
          <source>Assuming no method more specific than the above is found, Julia next internally defines and compiles a method called &lt;code&gt;myplus&lt;/code&gt; specifically for two &lt;code&gt;Int&lt;/code&gt; arguments based on the generic function given above, i.e., it implicitly defines and compiles:</source>
          <target state="translated">上記より具体的なメソッドが見つからない場合、Juliaは次に、上記の汎用関数に基づいて2つの &lt;code&gt;Int&lt;/code&gt; 引数用に &lt;code&gt;myplus&lt;/code&gt; というメソッドを内部的に定義およびコンパイルします。つまり、暗黙的に定義およびコンパイルします。</target>
        </trans-unit>
        <trans-unit id="2717ba36a09eb99678b64bb90dc485e6b0a0d557" translate="yes" xml:space="preserve">
          <source>Asterisk Operator</source>
          <target state="translated">アスタリスク演算子</target>
        </trans-unit>
        <trans-unit id="07b5380b9f5c5fd84a32bc659548c9dfab4533bb" translate="yes" xml:space="preserve">
          <source>Astonished Face</source>
          <target state="translated">驚いた顔</target>
        </trans-unit>
        <trans-unit id="b66ee82704200b04b4798e66b6593db1b1b13374" translate="yes" xml:space="preserve">
          <source>Asymptotically Equal To</source>
          <target state="translated">に漸近的に等しい</target>
        </trans-unit>
        <trans-unit id="5245f726138014634759729b99de5b3247dde5eb" translate="yes" xml:space="preserve">
          <source>AsyncCondition</source>
          <target state="translated">AsyncCondition</target>
        </trans-unit>
        <trans-unit id="8eaa017d84f0d81a23063919ee4ccb624ecbac15" translate="yes" xml:space="preserve">
          <source>AsyncCondition()</source>
          <target state="translated">AsyncCondition()</target>
        </trans-unit>
        <trans-unit id="97d88f0cd43a7c5afba791559c54e8c7a9720c83" translate="yes" xml:space="preserve">
          <source>Asynchronous IO and concurrent synchronous writes</source>
          <target state="translated">非同期IOと同時同期書き込み</target>
        </trans-unit>
        <trans-unit id="d61dfe1b51eb0bad1bc9d8b0b12b232b76aa4667" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;-O3&lt;/code&gt;, the compiler &lt;em&gt;might&lt;/em&gt; automatically vectorize operations on such tuples. For example, the following program, when compiled with &lt;code&gt;julia -O3&lt;/code&gt; generates two SIMD addition instructions (&lt;code&gt;addps&lt;/code&gt;) on x86 systems:</source>
          <target state="translated">で &lt;code&gt;-O3&lt;/code&gt; 、コンパイラが&lt;em&gt;あります&lt;/em&gt;自動的に、そのようなタプルの操作をベクトル化します。たとえば、次のプログラムを &lt;code&gt;julia -O3&lt;/code&gt; でコンパイルすると、x86システムで2つのSIMD追加命令（ &lt;code&gt;addps&lt;/code&gt; ）が生成されます。</target>
        </trans-unit>
        <trans-unit id="eb9e6602f2f530b7763a4fc47a789b6bcda1d592" translate="yes" xml:space="preserve">
          <source>At a high-level, each environment conceptually defines three maps: roots, graph and paths. When resolving the meaning of &lt;code&gt;import X&lt;/code&gt;, the roots and graph maps are used to determine the identity of &lt;code&gt;X&lt;/code&gt;, while the paths map is used to locate the source code of &lt;code&gt;X&lt;/code&gt;. The specific roles of the three maps are:</source>
          <target state="translated">高レベルでは、各環境は3つのマップ（ルート、グラフ、パス）を概念的に定義します。 &lt;code&gt;import X&lt;/code&gt; の意味を解決するとき、ルートマップとグラフマップを使用して &lt;code&gt;X&lt;/code&gt; のIDを決定し、パスマップを使用して &lt;code&gt;X&lt;/code&gt; のソースコードを見つけます。 3つのマップの特定の役割は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="1f9ae804041641dde19215ce7dbf17a3259634a7" translate="yes" xml:space="preserve">
          <source>At first blush, this seems reasonable enough since 9223372036854775807 is much closer to 9223372036854775808 than -9223372036854775808 is and integers are still represented with a fixed size in a natural way that is compatible with C and Fortran. Saturated integer arithmetic, however, is deeply problematic. The first and most obvious issue is that this is not the way machine integer arithmetic works, so implementing saturated operations requires emitting instructions after each machine integer operation to check for underflow or overflow and replace the result with &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin(Int)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax(Int)&lt;/code&gt;&lt;/a&gt; as appropriate. This alone expands each integer operation from a single, fast instruction into half a dozen instructions, probably including branches. Ouch. But it gets worse &amp;ndash; saturating integer arithmetic isn't associative. Consider this Matlab computation:</source>
          <target state="translated">9223372036854775807は-9223372036854775808よりも9223372036854775808にはるかに近く、整数は依然としてCおよびFortranと互換性のある自然な方法で固定サイズで表されるため、最初は赤面して、これは十分に妥当と思われます。ただし、飽和整数演算は非常に問題があります。最初の最も明白な問題は、これがマシン整数演算の動作方法ではないことです。したがって、飽和演算を実装するには、各マシン整数演算の後に命令を&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin(Int)&lt;/code&gt; &lt;/a&gt;、アンダーフローまたはオーバーフローをチェックし、結果をtypemin（Int）または&lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax(Int)&lt;/code&gt; で&lt;/a&gt;置き換える必要があります。適切に。これだけで、各整数演算が単一の高速命令から、おそらく分岐を含む6命令に拡張されます。痛い。しかし、状況はさらに悪化します&amp;ndash;飽和整数演算は連想的ではありません。このMatlab計算を考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="557269c7906899330df530ce61ccdd6c30d22fca" translate="yes" xml:space="preserve">
          <source>At the base of this functionality is &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo&lt;/code&gt;&lt;/a&gt;, which will do the appropriate address resolution:</source>
          <target state="translated">この機能の基本は&lt;a href=&quot;../../stdlib/sockets/index#Sockets.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo&lt;/code&gt; &lt;/a&gt;で、適切なアドレス解決を行います。</target>
        </trans-unit>
        <trans-unit id="dc65621fc57dd780fd2d22a2ad965178ea5de343" translate="yes" xml:space="preserve">
          <source>At the top, the inferred return type of the function is shown as &lt;code&gt;Body::Float64&lt;/code&gt;. The next lines represent the body of &lt;code&gt;f&lt;/code&gt; in Julia's SSA IR form. The numbered boxes are labels and represent targets for jumps (via &lt;code&gt;goto&lt;/code&gt;) in your code. Looking at the body, you can see that the first thing that happens is that &lt;code&gt;pos&lt;/code&gt; is called and the return value has been inferred as the &lt;code&gt;Union&lt;/code&gt; type &lt;code&gt;UNION{FLOAT64, INT64}&lt;/code&gt; shown in uppercase since it is a non-concrete type. This means that we cannot know the exact return type of &lt;code&gt;pos&lt;/code&gt; based on the input types. However, the result of &lt;code&gt;y*x&lt;/code&gt;is a &lt;code&gt;Float64&lt;/code&gt; no matter if &lt;code&gt;y&lt;/code&gt; is a &lt;code&gt;Float64&lt;/code&gt; or &lt;code&gt;Int64&lt;/code&gt; The net result is that &lt;code&gt;f(x::Float64)&lt;/code&gt; will not be type-unstable in its output, even if some of the intermediate computations are type-unstable.</source>
          <target state="translated">上部には、関数の推定戻り値の型が &lt;code&gt;Body::Float64&lt;/code&gt; として示されています。次の行は、JuliaのSSA IR形式の &lt;code&gt;f&lt;/code&gt; の本体を表しています。番号付きのボックスはラベルであり、コード内の（ &lt;code&gt;goto&lt;/code&gt; を介した）ジャンプのターゲットを表します。本文を見ると、最初に起こるのは &lt;code&gt;pos&lt;/code&gt; が呼び出され、戻り値が非コンクリート型であるため、 &lt;code&gt;Union&lt;/code&gt; 型の &lt;code&gt;UNION{FLOAT64, INT64}&lt;/code&gt; が大文字で示されていると推測されていることがわかります。これは、入力タイプに基づいて &lt;code&gt;pos&lt;/code&gt; の正確な戻りタイプを知ることができないことを意味します。しかし、結果 &lt;code&gt;y*x&lt;/code&gt; されていない &lt;code&gt;Float64&lt;/code&gt; に関係なく、もし &lt;code&gt;y&lt;/code&gt; は &lt;code&gt;Float64&lt;/code&gt; または &lt;code&gt;Int64&lt;/code&gt; です。最終的な結果として、 &lt;code&gt;f(x::Float64)&lt;/code&gt; は、中間の計算の一部が型不安定であっても、その出力では型不安定ではありません。</target>
        </trans-unit>
        <trans-unit id="4b8bfb8cb1b051b835dbefff1b5c12822cd90431" translate="yes" xml:space="preserve">
          <source>At this point, the project should build and run.</source>
          <target state="translated">この時点で、プロジェクトをビルドして実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="11e4a73a06b9dee6071ddafa6ecf05d8154a9294" translate="yes" xml:space="preserve">
          <source>Athletic Shoe</source>
          <target state="translated">アスレチックシューズ</target>
        </trans-unit>
        <trans-unit id="f3fbd2fd9cc354420ab6c1b9170e0b29144a85e6" translate="yes" xml:space="preserve">
          <source>Atomic Operations</source>
          <target state="translated">原子操作</target>
        </trans-unit>
        <trans-unit id="ad3b6bf5f22249f1093a69cf5b097656cf10a2e0" translate="yes" xml:space="preserve">
          <source>Atomic objects can be accessed using the &lt;code&gt;[]&lt;/code&gt; notation:</source>
          <target state="translated">アトミックオブジェクトには、 &lt;code&gt;[]&lt;/code&gt; 表記を使用してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="33b48033c48155a217b1ebf999c90a4b598f3e71" translate="yes" xml:space="preserve">
          <source>Atomic operations use an &lt;code&gt;atomic_&lt;/code&gt; prefix, such as &lt;a href=&quot;#Base.Threads.atomic_add!&quot;&gt;&lt;code&gt;atomic_add!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.Threads.atomic_xchg!&quot;&gt;&lt;code&gt;atomic_xchg!&lt;/code&gt;&lt;/a&gt;, etc.</source>
          <target state="translated">アトミック操作は、&lt;a href=&quot;#Base.Threads.atomic_add!&quot;&gt; &lt;code&gt;atomic_add!&lt;/code&gt; &lt;/a&gt;などの &lt;code&gt;atomic_&lt;/code&gt; 接頭辞を使用します。、&lt;a href=&quot;#Base.Threads.atomic_xchg!&quot;&gt; &lt;code&gt;atomic_xchg!&lt;/code&gt; &lt;/a&gt;、など</target>
        </trans-unit>
        <trans-unit id="ad6e575d4f77e8328667d22e1296bcc529f4eb15" translate="yes" xml:space="preserve">
          <source>Atomically add &lt;code&gt;val&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">アトミック追加 &lt;code&gt;val&lt;/code&gt; に &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98b4786f90c42de0fa6575d5c8690c2d57540c23" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-and &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">原子的にビットごとに &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c59f0d3e8acb12180dbf858879145e09dbd4d31" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-nand (not-and) &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">アトミックビット単位-NAND（未と） &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49dfbe4ce1039803bba1e66c619d680aaacd0303" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-or &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">原子的にビット単位の論理和または &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="361657c422d3986bfb8673c88d09205f8b549983" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-xor (exclusive-or) &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">アトミックビット単位-XOR（排他的論理和） &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="720563406f6bfeb8b472dd6dd26fe3888437904c" translate="yes" xml:space="preserve">
          <source>Atomically compare-and-set &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">原子的に比較して設定する &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cea0404569a918b8e5d8c74ca2a23340344009b" translate="yes" xml:space="preserve">
          <source>Atomically compares the value in &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;cmp&lt;/code&gt;. If equal, write &lt;code&gt;newval&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. Otherwise, leaves &lt;code&gt;x&lt;/code&gt; unmodified. Returns the old value in &lt;code&gt;x&lt;/code&gt;. By comparing the returned value to &lt;code&gt;cmp&lt;/code&gt; (via &lt;code&gt;===&lt;/code&gt;) one knows whether &lt;code&gt;x&lt;/code&gt; was modified and now holds the new value &lt;code&gt;newval&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の値を &lt;code&gt;cmp&lt;/code&gt; と原子的に比較します。等しい場合、 &lt;code&gt;newval&lt;/code&gt; を &lt;code&gt;x&lt;/code&gt; に書き込みます。それ以外の場合、 &lt;code&gt;x&lt;/code&gt; は変更されません。 &lt;code&gt;x&lt;/code&gt; の古い値を返します。返された値を（ &lt;code&gt;===&lt;/code&gt; を介して） &lt;code&gt;cmp&lt;/code&gt; と比較することで、 &lt;code&gt;x&lt;/code&gt; が変更されたかどうかが &lt;code&gt;newval&lt;/code&gt; 、新しい値newvalが保持されます。</target>
        </trans-unit>
        <trans-unit id="db092cd5c9d8911e3a523593755743a6ba3ff929" translate="yes" xml:space="preserve">
          <source>Atomically exchange the value in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の値を原子的に交換する</target>
        </trans-unit>
        <trans-unit id="ede158726902e9e7c885034b5dc7b476eaa3f0cb" translate="yes" xml:space="preserve">
          <source>Atomically exchanges the value in &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;newval&lt;/code&gt;. Returns the &lt;strong&gt;old&lt;/strong&gt; value.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の値を原子的に &lt;code&gt;newval&lt;/code&gt; と交換します。&lt;strong&gt;古い&lt;/strong&gt;値を返します。</target>
        </trans-unit>
        <trans-unit id="c3d2e4b23d13f6bba7a47950035a93b86bb83a39" translate="yes" xml:space="preserve">
          <source>Atomically store the maximum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">アトミックの最大格納 &lt;code&gt;x&lt;/code&gt; 及び &lt;code&gt;val&lt;/code&gt; で &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df88790f08323bff2d950ce1c8f1b209a38e86ef" translate="yes" xml:space="preserve">
          <source>Atomically store the minimum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">アトミックの最小格納 &lt;code&gt;x&lt;/code&gt; 及び &lt;code&gt;val&lt;/code&gt; で &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="689e84464421ff470b8dc38055180d25d70684c4" translate="yes" xml:space="preserve">
          <source>Atomically subtract &lt;code&gt;val&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; から &lt;code&gt;val&lt;/code&gt; を原子的に減算</target>
        </trans-unit>
        <trans-unit id="9a5910ec96daddf32d8679bdc1681e3d2b896833" translate="yes" xml:space="preserve">
          <source>Attempt an automatic merge rebase of the current branch, from &lt;code&gt;upstream&lt;/code&gt; if provided, or otherwise from the upstream tracking branch. &lt;code&gt;newbase&lt;/code&gt; is the branch to rebase onto. By default this is &lt;code&gt;upstream&lt;/code&gt;.</source>
          <target state="translated">現在のブランチの自動マージリベースを試みる &lt;code&gt;upstream&lt;/code&gt; 、またはそうでなければ、上流側のトラッキングブランチから提供された場合。 &lt;code&gt;newbase&lt;/code&gt; はリベースするブランチです。デフォルトでは &lt;code&gt;upstream&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="67fbdff1fd74a3e2ffeba20e52cb54a817a837a9" translate="yes" xml:space="preserve">
          <source>Aubergine</source>
          <target state="translated">Aubergine</target>
        </trans-unit>
        <trans-unit id="237f5a2b8d61f639bee4e8b48edc5e86ef3821ad" translate="yes" xml:space="preserve">
          <source>Auto-conversion:</source>
          <target state="translated">Auto-conversion:</target>
        </trans-unit>
        <trans-unit id="83f8ababd899b8c0947ef4217c49ed91a00e554d" translate="yes" xml:space="preserve">
          <source>Automated Teller Machine</source>
          <target state="translated">自動テラー機</target>
        </trans-unit>
        <trans-unit id="d3ff4de6909c953084efbf3fcf51ba0455525196" translate="yes" xml:space="preserve">
          <source>Automatic generation of efficient, specialized code for different argument types</source>
          <target state="translated">異なる引数タイプに対応した効率的で特殊なコードの自動生成</target>
        </trans-unit>
        <trans-unit id="e3d0413f1114ca7420957b409369ba320c5e643a" translate="yes" xml:space="preserve">
          <source>Automobile</source>
          <target state="translated">Automobile</target>
        </trans-unit>
        <trans-unit id="c2381c9ae6de19786317e42c36cfe48f1d110cd4" translate="yes" xml:space="preserve">
          <source>Available for method extension</source>
          <target state="translated">メソッドの拡張に利用可能</target>
        </trans-unit>
        <trans-unit id="1913fba71b8ad5575c96582256e93730389a751d" translate="yes" xml:space="preserve">
          <source>Avoid changing the type of a variable</source>
          <target state="translated">変数の型を変更しないようにする</target>
        </trans-unit>
        <trans-unit id="491716d25d0cc5eef3fc083042b6cf3fb1c73628" translate="yes" xml:space="preserve">
          <source>Avoid confusion about whether something is an instance or a type</source>
          <target state="translated">インスタンスなのか型なのかの混乱を避ける</target>
        </trans-unit>
        <trans-unit id="f43c7e32c4f8af3884df62b42a58c3f06c2cb00b" translate="yes" xml:space="preserve">
          <source>Avoid containers with abstract type parameters</source>
          <target state="translated">抽象型のパラメータを持つコンテナを避ける</target>
        </trans-unit>
        <trans-unit id="a69832582d8c220962ec16f3f74807795126efb7" translate="yes" xml:space="preserve">
          <source>Avoid elaborate container types</source>
          <target state="translated">凝った容器の種類を避ける</target>
        </trans-unit>
        <trans-unit id="5a42b7935afc0b3ec5008a2229ca382f69673505" translate="yes" xml:space="preserve">
          <source>Avoid fields with abstract containers</source>
          <target state="translated">抽象的なコンテナを持つフィールドを避ける</target>
        </trans-unit>
        <trans-unit id="f619d134c2c6942d7932e906b9ce6c23d632cfef" translate="yes" xml:space="preserve">
          <source>Avoid fields with abstract type</source>
          <target state="translated">抽象型のフィールドを避ける</target>
        </trans-unit>
        <trans-unit id="ea9c797001a229bb0f7e2e5dcae3538ba2a55b2c" translate="yes" xml:space="preserve">
          <source>Avoid global variables</source>
          <target state="translated">グローバル変数を避ける</target>
        </trans-unit>
        <trans-unit id="03b73d63c4cb77f3bf8c6e423749bbf23c01ee5d" translate="yes" xml:space="preserve">
          <source>Avoid strange type &lt;code&gt;Union&lt;/code&gt;s</source>
          <target state="translated">奇妙なタイプ避け &lt;code&gt;Union&lt;/code&gt; 秒</target>
        </trans-unit>
        <trans-unit id="79292115b6e992f614cf724c1dfa9586d06bbe03" translate="yes" xml:space="preserve">
          <source>Avoid string interpolation for I/O</source>
          <target state="translated">I/Oのための文字列補間を避ける</target>
        </trans-unit>
        <trans-unit id="8a11c76e8b2bd9a028ae58c6c15b510f4680d17f" translate="yes" xml:space="preserve">
          <source>Avoid type piracy</source>
          <target state="translated">タイプの海賊版を避ける</target>
        </trans-unit>
        <trans-unit id="bf3ba609a722d28177b4a138e6e131e1148dc2ff" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary arrays. For example, instead of &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum([x,y,z])&lt;/code&gt;&lt;/a&gt; use &lt;code&gt;x+y+z&lt;/code&gt;.</source>
          <target state="translated">不要な配列は避けてください。たとえば、&lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum([x,y,z])&lt;/code&gt; &lt;/a&gt;代わりに &lt;code&gt;x+y+z&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="b9540041dc787b11f982141e4085503960ffd2c7" translate="yes" xml:space="preserve">
          <source>Avoid using floats for numeric literals in generic code when possible</source>
          <target state="translated">一般的なコードでは、可能な限り数値リテラルにフロートを使用しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="4802b2a45694be10a378fb271220844de2096707" translate="yes" xml:space="preserve">
          <source>Avoid using passwords in URLs. Unlike the credential objects, Julia is not able to securely zero or destroy the sensitive data after use and the password may remain in memory; possibly to be exposed by an uninitialized memory.</source>
          <target state="translated">URL でのパスワードの使用は避けてください。クレデンシャルオブジェクトとは異なり、Julia は使用後に機密データを安全にゼロにしたり破棄したりすることができず、パスワードはメモリ内に残る可能性があります;もしかしたら、初期化されていないメモリによって公開される可能性があります。</target>
        </trans-unit>
        <trans-unit id="2371521c12f038f3e299464707c70bda3ff3e6b1" translate="yes" xml:space="preserve">
          <source>Avoid writing overly-specific types</source>
          <target state="translated">特化しすぎたタイプを書かないようにする</target>
        </trans-unit>
        <trans-unit id="5073587ca8bbf875c2d3d248119f4effa8701deb" translate="yes" xml:space="preserve">
          <source>Avoiding Deadlock in Pipelines</source>
          <target state="translated">パイプラインのデッドロックの回避</target>
        </trans-unit>
        <trans-unit id="65b99874e3a064ddb84e4d624ff070c43bf412eb" translate="yes" xml:space="preserve">
          <source>Avoiding changing the value of global variables is considered by many to be a programming best-practice. Changing the value of a global variable can cause &quot;action at a distance&quot;, making the behavior of a program harder to reason about. This is why the scope blocks that introduce local scope require the &lt;code&gt;global&lt;/code&gt; keyword to declare the intent to modify a global variable.</source>
          <target state="translated">グローバル変数の値を変更しないことは、プログラミングのベストプラクティスであると多くの人が考えています。グローバル変数の値を変更すると、「離れた場所でのアクション」が発生し、プログラムの動作を推測することが難しくなります。これが、ローカルスコープを導入するスコープブロックがグローバル変数を変更する意図を宣言するために &lt;code&gt;global&lt;/code&gt; キーワードを必要とする理由です。</target>
        </trans-unit>
        <trans-unit id="5b00714b611fee1b5fd3b2b1cfc1708286a4e472" translate="yes" xml:space="preserve">
          <source>Avoiding globals</source>
          <target state="translated">グローバルの回避</target>
        </trans-unit>
        <trans-unit id="4e9ba62b391f99ca62e6bfebe5faa916e7ed0f96" translate="yes" xml:space="preserve">
          <source>Awad H. Al-Mohy and Nicholas J. Higham, &quot;Improved inverse scaling and squaring algorithms for the matrix logarithm&quot;, SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. &lt;a href=&quot;https://doi.org/10.1137/110852553&quot;&gt;doi:10.1137/110852553&lt;/a&gt;</source>
          <target state="translated">Awad H. Al-MohyおよびNicholas J. Higham、「行列対数の改善された逆スケーリングおよび二乗アルゴリズム」、SIAM Journal on Scientific Computing、34（4）、2012、C153-C169。&lt;a href=&quot;https://doi.org/10.1137/110852553&quot;&gt;doi：10.1137 / 110852553&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12401b9104fcd17aca879a9457a3f9b5a0090df6" translate="yes" xml:space="preserve">
          <source>Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, &quot;Computing the Fr&amp;eacute;chet derivative of the matrix logarithm and estimating the condition number&quot;, SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. &lt;a href=&quot;https://doi.org/10.1137/120885991&quot;&gt;doi:10.1137/120885991&lt;/a&gt;</source>
          <target state="translated">Awad H. Al-Mohy、Nicholas J. HighamおよびSamuel D. Relton、「行列対数のフレシェ微分の計算と条件数の推定」、SIAM Journal on Scientific Computing、35（4）、2013、C394-C410。&lt;a href=&quot;https://doi.org/10.1137/120885991&quot;&gt;doi：10.1137 / 120885991&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6dad1f19392ce0b096b44b01c81c76a664e7337c" translate="yes" xml:space="preserve">
          <source>B&amp;eacute;zout coefficients are &lt;em&gt;not&lt;/em&gt; uniquely defined. &lt;code&gt;gcdx&lt;/code&gt; returns the minimal B&amp;eacute;zout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are minimal in the sense that $|u| &amp;lt; |y/d|$ and $|v| &amp;lt; |x/d|$. Furthermore, the signs of &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are chosen so that &lt;code&gt;d&lt;/code&gt; is positive. For unsigned integers, the coefficients &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; might be near their &lt;code&gt;typemax&lt;/code&gt;, and the identity then holds only via the unsigned integers' modulo arithmetic.</source>
          <target state="translated">ベズー係数は一意に定義されて&lt;em&gt;いません&lt;/em&gt;。 &lt;code&gt;gcdx&lt;/code&gt; は、拡張ユークリッドアルゴリズムによって計算される最小ベズー係数を返します。 （参照：D. Knuth、TAoCP、2 / e、p。325、アルゴリズムX。）符号付き整数の場合、これらの係数 &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; は$ | u |の意味で最小です。 &amp;lt;| y / d | $および$ | v | &amp;lt;| x / d | $。さらに、 &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; の符号は、 &lt;code&gt;d&lt;/code&gt; が正になるように選択されます。符号なし整数の場合、係数 &lt;code&gt;u&lt;/code&gt; および &lt;code&gt;v&lt;/code&gt; はそれらの &lt;code&gt;typemax&lt;/code&gt; に近い可能性があり、その場合、同一性は符号なし整数のモジュロ演算を介してのみ保持されます。</target>
        </trans-unit>
        <trans-unit id="0f4d56d1e20778bf2e1052ecb3219509238fb660" translate="yes" xml:space="preserve">
          <source>BD</source>
          <target state="translated">BD</target>
        </trans-unit>
        <trans-unit id="2868e5c7bf03fbd81359d6f8be00b333b386ffca" translate="yes" xml:space="preserve">
          <source>BLAS Character Arguments</source>
          <target state="translated">BLAS文字引数</target>
        </trans-unit>
        <trans-unit id="e299ffe232555a867fe66272d999c06385ea8b66" translate="yes" xml:space="preserve">
          <source>BLAS Functions</source>
          <target state="translated">BLAS機能</target>
        </trans-unit>
        <trans-unit id="13c3d98d3a2445afc653d610809196ddb501f8c1" translate="yes" xml:space="preserve">
          <source>Baby</source>
          <target state="translated">Baby</target>
        </trans-unit>
        <trans-unit id="404344724dd01c5a65fcea59173146b18cd1b603" translate="yes" xml:space="preserve">
          <source>Baby Angel</source>
          <target state="translated">ベビーエンジェル</target>
        </trans-unit>
        <trans-unit id="8b580757a627745bff29a8f25e39330265bdc27b" translate="yes" xml:space="preserve">
          <source>Baby Bottle</source>
          <target state="translated">ベビーボトル</target>
        </trans-unit>
        <trans-unit id="459882191a5a45ebff1c155b876b56cf4eb8ef5e" translate="yes" xml:space="preserve">
          <source>Baby Chick</source>
          <target state="translated">ベビーチック</target>
        </trans-unit>
        <trans-unit id="1871c181df7f050df811e7ae71f7e0946094c40f" translate="yes" xml:space="preserve">
          <source>Baby Symbol</source>
          <target state="translated">ベビーシンボル</target>
        </trans-unit>
        <trans-unit id="2867999045ac5ccc323dde4dccea9a973b94383f" translate="yes" xml:space="preserve">
          <source>Back With Leftwards Arrow Above</source>
          <target state="translated">左向き矢印の上に戻る</target>
        </trans-unit>
        <trans-unit id="cc1f0103d6d9cbde7e99045cc49ad45fc083e009" translate="yes" xml:space="preserve">
          <source>Background and References</source>
          <target state="translated">背景と参考文献</target>
        </trans-unit>
        <trans-unit id="fc10601fec1e951e91f278b7b703a3337af22c80" translate="yes" xml:space="preserve">
          <source>Backslashes (&lt;code&gt;\&lt;/code&gt;) are escaped with a double-backslash (&lt;code&gt;&quot;\\&quot;&lt;/code&gt;). Non-printable characters are escaped either with their standard C escape codes, &lt;code&gt;&quot;\0&quot;&lt;/code&gt; for NUL (if unambiguous), unicode code point (&lt;code&gt;&quot;\u&quot;&lt;/code&gt; prefix) or hex (&lt;code&gt;&quot;\x&quot;&lt;/code&gt; prefix).</source>
          <target state="translated">バックスラッシュ（ &lt;code&gt;\&lt;/code&gt; ）は、二重バックスラッシュ（ &lt;code&gt;&quot;\\&quot;&lt;/code&gt; ）でエスケープされます。印刷不可能な文字は、標準のCエスケープコード、NULの &lt;code&gt;&quot;\0&quot;&lt;/code&gt; （あいまいでない場合）、Unicodeコードポイント（ &lt;code&gt;&quot;\u&quot;&lt;/code&gt; プレフィックス）、または16進数（ &lt;code&gt;&quot;\x&quot;&lt;/code&gt; プレフィックス）のいずれかでエスケープされます。</target>
        </trans-unit>
        <trans-unit id="6d4e3b07bbe1ccb3ac5b9922a337b1d4f919bc4f" translate="yes" xml:space="preserve">
          <source>Backspace, &lt;code&gt;^H&lt;/code&gt;</source>
          <target state="translated">バックスペース、 &lt;code&gt;^H&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6d84b04bcccd220267af9a3b46464c46ba45d26" translate="yes" xml:space="preserve">
          <source>Bactrian Camel</source>
          <target state="translated">バクトリアンキャメル</target>
        </trans-unit>
        <trans-unit id="447082b449cc1df13e5c0addef786ca50488ff0e" translate="yes" xml:space="preserve">
          <source>Baggage Claim</source>
          <target state="translated">バゲージクレーム</target>
        </trans-unit>
        <trans-unit id="ebd009a68817c4cc14d70f9ca5aa28ad5c4de62a" translate="yes" xml:space="preserve">
          <source>Balance the matrix &lt;code&gt;A&lt;/code&gt; before computing its eigensystem or Schur factorization. &lt;code&gt;job&lt;/code&gt; can be one of &lt;code&gt;N&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will not be permuted or scaled), &lt;code&gt;P&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will only be permuted), &lt;code&gt;S&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will only be scaled), or &lt;code&gt;B&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will be both permuted and scaled). Modifies &lt;code&gt;A&lt;/code&gt; in-place and returns &lt;code&gt;ilo&lt;/code&gt;, &lt;code&gt;ihi&lt;/code&gt;, and &lt;code&gt;scale&lt;/code&gt;. If permuting was turned on, &lt;code&gt;A[i,j] = 0&lt;/code&gt; if &lt;code&gt;j &amp;gt; i&lt;/code&gt; and &lt;code&gt;1 &amp;lt; j &amp;lt; ilo&lt;/code&gt; or &lt;code&gt;j &amp;gt; ihi&lt;/code&gt;. &lt;code&gt;scale&lt;/code&gt; contains information about the scaling/permutations performed.</source>
          <target state="translated">固有システムまたはSchur分解を計算 &lt;code&gt;A&lt;/code&gt; 前に、行列Aのバランスをとります。 &lt;code&gt;job&lt;/code&gt; は、 &lt;code&gt;N&lt;/code&gt; （ &lt;code&gt;A&lt;/code&gt; は置換またはスケーリングされない）、 &lt;code&gt;P&lt;/code&gt; （ &lt;code&gt;A&lt;/code&gt; は置換のみされる）、 &lt;code&gt;S&lt;/code&gt; （ &lt;code&gt;A&lt;/code&gt; はスケーリングのみされる）、または &lt;code&gt;B&lt;/code&gt; （ &lt;code&gt;A&lt;/code&gt; は置換およびスケーリングされる）のいずれかになります。修正 &lt;code&gt;A&lt;/code&gt; は、インプレースおよびリターンは &lt;code&gt;ilo&lt;/code&gt; 、 &lt;code&gt;ihi&lt;/code&gt; 、および &lt;code&gt;scale&lt;/code&gt; 。置換がオンになっている場合、 &lt;code&gt;j &amp;gt; i&lt;/code&gt; および &lt;code&gt;1 &amp;lt; j &amp;lt; ilo&lt;/code&gt; または &lt;code&gt;j &amp;gt; ihi&lt;/code&gt; 場合、 &lt;code&gt;A[i,j] = 0&lt;/code&gt; です。 &lt;code&gt;scale&lt;/code&gt; には、実行されたスケーリング/置換に関する情報が含まれます。</target>
        </trans-unit>
        <trans-unit id="64f241f5415d400e3d7d028f504e941ebbdb9386" translate="yes" xml:space="preserve">
          <source>Balloon</source>
          <target state="translated">Balloon</target>
        </trans-unit>
        <trans-unit id="a5ae768a2f5127a27b546388e40cac06994c9b36" translate="yes" xml:space="preserve">
          <source>Ballot Box With Check</source>
          <target state="translated">チェック付き投票箱</target>
        </trans-unit>
        <trans-unit id="fc6fae10db2bd0b625077d7c6d1b9a96925fd2b7" translate="yes" xml:space="preserve">
          <source>Banana</source>
          <target state="translated">Banana</target>
        </trans-unit>
        <trans-unit id="9e89988cc3fba2850fb19459e04e7b3325be4f84" translate="yes" xml:space="preserve">
          <source>Bank</source>
          <target state="translated">Bank</target>
        </trans-unit>
        <trans-unit id="ef4f81080d95142c3db9938d48a26e8efe95cd36" translate="yes" xml:space="preserve">
          <source>Banknote With Dollar Sign</source>
          <target state="translated">ドルのサインが付いた紙幣</target>
        </trans-unit>
        <trans-unit id="3177af01daaed29235d1e99ba9255338076b9f27" translate="yes" xml:space="preserve">
          <source>Banknote With Euro Sign</source>
          <target state="translated">ユーロのサインが付いた紙幣</target>
        </trans-unit>
        <trans-unit id="3a6546fb8ecf3af86528410e140549606f1d3249" translate="yes" xml:space="preserve">
          <source>Banknote With Pound Sign</source>
          <target state="translated">ポンドサイン入り紙幣</target>
        </trans-unit>
        <trans-unit id="63a28a516e785c09b112a71c85ad02804c64137a" translate="yes" xml:space="preserve">
          <source>Banknote With Yen Sign</source>
          <target state="translated">円記号入り紙幣</target>
        </trans-unit>
        <trans-unit id="75fe8df5591aba61913518914c1f05bdb42306e6" translate="yes" xml:space="preserve">
          <source>Bar Chart</source>
          <target state="translated">棒グラフ</target>
        </trans-unit>
        <trans-unit id="bddd12f808af35a2e999d9124c970232527e7e1d" translate="yes" xml:space="preserve">
          <source>Barber Pole</source>
          <target state="translated">バーバーポール</target>
        </trans-unit>
        <trans-unit id="077fe9c54ed5ed26fa547f4ded3ef9a9bb066d65" translate="yes" xml:space="preserve">
          <source>Base</source>
          <target state="translated">Base</target>
        </trans-unit>
        <trans-unit id="2aa4376a2de743967992b5357971a1c7721c03e3" translate="yes" xml:space="preserve">
          <source>Base Submodules</source>
          <target state="translated">ベースサブモジュール</target>
        </trans-unit>
        <trans-unit id="895c330ff6166a7f13701f8d9b78f313787269c8" translate="yes" xml:space="preserve">
          <source>Base64</source>
          <target state="translated">Base64</target>
        </trans-unit>
        <trans-unit id="ec2d7744c603baf507e66bf82835dfb6204656a8" translate="yes" xml:space="preserve">
          <source>Baseball</source>
          <target state="translated">Baseball</target>
        </trans-unit>
        <trans-unit id="bf046bc3c151c25669b6483d54157a9641394a6d" translate="yes" xml:space="preserve">
          <source>Based on this observation, we can conclude that if one of the operands is &lt;code&gt;true&lt;/code&gt; and the other &lt;code&gt;missing&lt;/code&gt;, we know that the result is &lt;code&gt;true&lt;/code&gt; in spite of the uncertainty about the actual value of one of the operands. If we had been able to observe the actual value of the second operand, it could only be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, and in both cases the result would be &lt;code&gt;true&lt;/code&gt;. Therefore, in this particular case, missingness does &lt;em&gt;not&lt;/em&gt; propagate</source>
          <target state="translated">この観察に基づいて、一方のオペランドが &lt;code&gt;true&lt;/code&gt; で他方が &lt;code&gt;missing&lt;/code&gt; している場合、一方のオペランドの実際の値に関する不確実性にもかかわらず、結果が &lt;code&gt;true&lt;/code&gt; であることがわかります。2番目のオペランドの実際の値を観察できた場合、それは &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; のみであり、どちらの場合も結果は &lt;code&gt;true&lt;/code&gt; になります。したがって、この特定のケースでは、欠落は伝播しませ&lt;em&gt;ん&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c01a71bb934cc266c2f79a70a4a484bfb32292d0" translate="yes" xml:space="preserve">
          <source>Basic Functions</source>
          <target state="translated">基本機能</target>
        </trans-unit>
        <trans-unit id="aeb63e6ce576503861f1c499cfdf84cff87567db" translate="yes" xml:space="preserve">
          <source>Basic Stream I/O</source>
          <target state="translated">基本ストリームI/O</target>
        </trans-unit>
        <trans-unit id="f9e89ba8027afc2d4c24183a1cbbfbb04137326a" translate="yes" xml:space="preserve">
          <source>Basic Unit Tests</source>
          <target state="translated">基本的なユニットテスト</target>
        </trans-unit>
        <trans-unit id="58c96a6812d6bac9777029dd40fb7e6afd5c8c94" translate="yes" xml:space="preserve">
          <source>Basic functions</source>
          <target state="translated">基本機能</target>
        </trans-unit>
        <trans-unit id="24be2e19e7e4671eaee4ac0a6f5a6a524bab3529" translate="yes" xml:space="preserve">
          <source>Basic tables can be written using the syntax described below. Note that markdown tables have limited features and cannot contain nested toplevel elements unlike other elements discussed above &amp;ndash; only inline elements are allowed. Tables must always contain a header row with column names. Cells cannot span multiple rows or columns of the table.</source>
          <target state="translated">基本的なテーブルは、以下で説明する構文を使用して記述できます。マークダウンテーブルの機能は制限されており、上記の他の要素とは異なり、ネストされたトップレベル要素を含めることはできません。インライン要素のみが許可されます。テーブルには、常に列名を含むヘッダー行が含まれている必要があります。セルは、テーブルの複数の行または列にまたがることはできません。</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">基本的な使い方</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="25cdb3adf0a06c600dd49fc47c73f5654e3fddf0" translate="yes" xml:space="preserve">
          <source>Basketball And Hoop</source>
          <target state="translated">バスケットボールとフープ</target>
        </trans-unit>
        <trans-unit id="a687b3ff7f182c39a1247454d3d7927ea0efa80d" translate="yes" xml:space="preserve">
          <source>Bath</source>
          <target state="translated">Bath</target>
        </trans-unit>
        <trans-unit id="24f0469ed67f7f88a5ef12c0cd27feac4f206fb4" translate="yes" xml:space="preserve">
          <source>Bathtub</source>
          <target state="translated">Bathtub</target>
        </trans-unit>
        <trans-unit id="4a9be042afe6257111a01c05b72af9f1f3015176" translate="yes" xml:space="preserve">
          <source>Battery</source>
          <target state="translated">Battery</target>
        </trans-unit>
        <trans-unit id="d363e26ebe520321aa01d471833fdb370bebd1b2" translate="yes" xml:space="preserve">
          <source>Be aware of when a macro could really be a function instead.</source>
          <target state="translated">マクロが本当に関数である可能性がある場合に注意してください。</target>
        </trans-unit>
        <trans-unit id="24c70535563b2fda1a64503b874c826edb8884cf" translate="yes" xml:space="preserve">
          <source>Be aware that this strategy has at least one major disadvantage: in many cases, it is not possible for users to further customize the behavior of &lt;code&gt;f&lt;/code&gt; by defining further specializations of your exported function &lt;code&gt;f&lt;/code&gt;. Instead, they have to define specializations for your internal methods &lt;code&gt;_fA&lt;/code&gt; and &lt;code&gt;_fB&lt;/code&gt;, and this blurs the lines between exported and internal methods.</source>
          <target state="translated">この戦略には少なくとも1つの大きな欠点があることに注意してください。多くの場合、エクスポートされた関数 &lt;code&gt;f&lt;/code&gt; の特殊化をさらに定義することによって、ユーザーが &lt;code&gt;f&lt;/code&gt; の動作をさらにカスタマイズすることは不可能です。代わりに、内部メソッド &lt;code&gt;_fA&lt;/code&gt; および &lt;code&gt;_fB&lt;/code&gt; の特殊化を定義する必要があります。これにより、エクスポートされたメソッドと内部メソッドの間の線がぼやけます。</target>
        </trans-unit>
        <trans-unit id="9beb1443ec7c795007b178f28f0ce7235335f46d" translate="yes" xml:space="preserve">
          <source>Be careful to ensure that a Julia reference to &lt;code&gt;x&lt;/code&gt; exists as long as the result of this function will be used. Accordingly, the argument &lt;code&gt;x&lt;/code&gt; to this function should never be an expression, only a variable name or field reference. For example, &lt;code&gt;x=a.b.c&lt;/code&gt; is acceptable, but &lt;code&gt;x=[a,b,c]&lt;/code&gt; is not.</source>
          <target state="translated">この関数の結果が使用される限り、 &lt;code&gt;x&lt;/code&gt; へのJulia参照が存在するように注意してください。したがって、この関数の引数 &lt;code&gt;x&lt;/code&gt; は式ではなく、変数名またはフィールド参照のみにする必要があります。たとえば、 &lt;code&gt;x=a.b.c&lt;/code&gt; は受け入れられますが、 &lt;code&gt;x=[a,b,c]&lt;/code&gt; は受け入れられません。</target>
        </trans-unit>
        <trans-unit id="5cb87858674ab3ef5b1beab58a7148fcb802f60e" translate="yes" xml:space="preserve">
          <source>Be careful with type equality</source>
          <target state="translated">タイプの平等性に注意</target>
        </trans-unit>
        <trans-unit id="8bfb6bdbe4ae64df10562422552d5b22da6f47fc" translate="yes" xml:space="preserve">
          <source>Beamed Eighth Notes / Barred Eighth Notes</source>
          <target state="translated">ビーム付き8分音符/バーレッド付き8分音符</target>
        </trans-unit>
        <trans-unit id="c8d8cb92fc4cef48d0b0c66441f7a0ef79489b94" translate="yes" xml:space="preserve">
          <source>Bear Face</source>
          <target state="translated">ベアフェイス</target>
        </trans-unit>
        <trans-unit id="aa8c1d8ab7be7fc9804d2a597a6630cb0b4cde3e" translate="yes" xml:space="preserve">
          <source>Beating Heart</source>
          <target state="translated">鼓動する心臓</target>
        </trans-unit>
        <trans-unit id="eaebe47425c9f545a41d705608612a34bef824ca" translate="yes" xml:space="preserve">
          <source>Because</source>
          <target state="translated">Because</target>
        </trans-unit>
        <trans-unit id="3b0620b59c6d57d025b388d048ef8892a00c82a2" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;a&lt;/code&gt; is a an array of abstract type &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt;, it must be able to hold any &lt;code&gt;Real&lt;/code&gt; value. Since &lt;code&gt;Real&lt;/code&gt; objects can be of arbitrary size and structure, &lt;code&gt;a&lt;/code&gt; must be represented as an array of pointers to individually allocated &lt;code&gt;Real&lt;/code&gt; objects. However, if we instead only allow numbers of the same type, e.g. &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, to be stored in &lt;code&gt;a&lt;/code&gt; these can be stored more efficiently:</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; は&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;の抽象型の配列であるため、任意の &lt;code&gt;Real&lt;/code&gt; 値を保持できなければなりません。 &lt;code&gt;Real&lt;/code&gt; オブジェクトは任意のサイズと構造に &lt;code&gt;a&lt;/code&gt; ことができるため、aは個別に割り当てられた &lt;code&gt;Real&lt;/code&gt; オブジェクトへのポインタの配列として表す必要があります。ただし、代わりに同じタイプの数値（&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;など）のみをに格納することを許可する場合 &lt;code&gt;a&lt;/code&gt; これらをより効率的に格納できます。</target>
        </trans-unit>
        <trans-unit id="9408c8b817a5e76474fc2023c5d1c8f64eadcc39" translate="yes" xml:space="preserve">
          <source>Because C doesn't support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish this within a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, you need to first encapsulate the value inside a &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref{T}&lt;/code&gt;&lt;/a&gt; of the appropriate type. When you pass this &lt;code&gt;Ref&lt;/code&gt; object as an argument, Julia will automatically pass a C pointer to the encapsulated data:</source>
          <target state="translated">Cは複数の戻り値をサポートしていないため、C関数は多くの場合、関数が変更するデータへのポインターを取得します。これを&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;内で実現するには、最初に適切なタイプの&lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref{T}&lt;/code&gt; &lt;/a&gt;内に値をカプセル化する必要があります。この &lt;code&gt;Ref&lt;/code&gt; オブジェクトを引数として渡すと、JuliaはCポインターをカプセル化されたデータに自動的に渡します。</target>
        </trans-unit>
        <trans-unit id="46c2c088cdd51f72db20e5f94b9c484cd07ee1a5" translate="yes" xml:space="preserve">
          <source>Because Julia's compiler is different from the interpreters used for languages like Python or R, you may find that Julia's performance is unintuitive at first. If you find that something is slow, we highly recommend reading through the &lt;a href=&quot;manual/performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt; section before trying anything else. Once you understand how Julia works, it's easy to write code that's nearly as fast as C.</source>
          <target state="translated">Juliaのコンパイラーは、PythonやRなどの言語で使用されるインタープリターとは異なるため、最初はJuliaのパフォーマンスが直感的でないことに気付く場合があります。何かが遅いと感じた場合は、何かを試す前に、&lt;a href=&quot;manual/performance-tips/index#man-performance-tips-1&quot;&gt;パフォーマンスのヒントの&lt;/a&gt;セクションを一読することを強くお勧めします。Juliaの仕組みを理解したら、Cとほぼ同じ速さのコードを簡単に作成できます。</target>
        </trans-unit>
        <trans-unit id="d57b0f43957e0dd94a3628a775697cb33089c39f" translate="yes" xml:space="preserve">
          <source>Because of these shared properties, these types are internally represented as instances of the same concept, &lt;code&gt;DataType&lt;/code&gt;, which is the type of any of these types:</source>
          <target state="translated">これらの共有プロパティのため、これらの型は内部的に同じ概念 &lt;code&gt;DataType&lt;/code&gt; のインスタンスとして表されます。これは、これらの型のいずれかの型です。</target>
        </trans-unit>
        <trans-unit id="42b7af0f4b58f310d2c30a12b918265991dec35c" translate="yes" xml:space="preserve">
          <source>Because of variable-length encodings, the number of characters in a string (given by &lt;code&gt;length(s)&lt;/code&gt;) is not always the same as the last index. If you iterate through the indices 1 through &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt;&lt;code&gt;lastindex(s)&lt;/code&gt;&lt;/a&gt; and index into &lt;code&gt;s&lt;/code&gt;, the sequence of characters returned when errors aren't thrown is the sequence of characters comprising the string &lt;code&gt;s&lt;/code&gt;. Thus we have the identity that &lt;code&gt;length(s) &amp;lt;= lastindex(s)&lt;/code&gt;, since each character in a string must have its own index. The following is an inefficient and verbose way to iterate through the characters of &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">可変長エンコーディングのため、文字列の &lt;code&gt;length(s)&lt;/code&gt; によって与えられる）は常に最後のインデックスと同じではありません。インデックス1から&lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt; &lt;code&gt;lastindex(s)&lt;/code&gt; &lt;/a&gt;まで繰り返し、インデックスを &lt;code&gt;s&lt;/code&gt; に入れると、エラーがスローされないときに返される文字シーケンスは、文字列 &lt;code&gt;s&lt;/code&gt; を構成する文字シーケンスになります。したがって、文字列内の各文字は独自のインデックスを持つ必要があるため、 &lt;code&gt;length(s) &amp;lt;= lastindex(s)&lt;/code&gt; であるというアイデンティティがあります。以下は、 &lt;code&gt;s&lt;/code&gt; の文字を反復する非効率的で冗長な方法です。</target>
        </trans-unit>
        <trans-unit id="757a38ed122bb8b64391606ad821806f34182e36" translate="yes" xml:space="preserve">
          <source>Because supporting generic programming is deemed more important than potential performance optimizations that can be achieved by other means (e.g., using explicit loops), operators like &lt;code&gt;+=&lt;/code&gt; and &lt;code&gt;*=&lt;/code&gt; work by rebinding new values.</source>
          <target state="translated">一般的なプログラミングのサポートは、他の方法（明示的なループの使用など）で実現できる潜在的なパフォーマンス最適化よりも重要であると考えられているため、 &lt;code&gt;+=&lt;/code&gt; や &lt;code&gt;*=&lt;/code&gt; などの演算子は、新しい値を再バインドすることで機能します。</target>
        </trans-unit>
        <trans-unit id="b50e23d2e501ab3f771dc2f5a71cc510c1b86367" translate="yes" xml:space="preserve">
          <source>Because the &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; types are stored as single &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; values, date parts or fields can be retrieved through accessor functions. The lowercase accessors return the field as an integer:</source>
          <target state="translated">&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;タイプは単一の&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;値として格納されるため、日付の部分またはフィールドは、アクセサー関数を介して取得できます。小文字のアクセサーはフィールドを整数として返します。</target>
        </trans-unit>
        <trans-unit id="bc4c89911afb2810477bab2fec0bf376b9a4f915" translate="yes" xml:space="preserve">
          <source>Because the compiler knows that integer addition and multiplication are associative and that multiplication distributes over addition &amp;ndash; neither of which is true of saturating arithmetic &amp;ndash; it can optimize the entire loop down to just a multiply and an add. Saturated arithmetic completely defeats this kind of optimization since associativity and distributivity can fail at each loop iteration, causing different outcomes depending on which iteration the failure occurs in. The compiler can unroll the loop, but it cannot algebraically reduce multiple operations into fewer equivalent operations.</source>
          <target state="translated">コンパイラーは整数の加算と乗算が連想的であり、乗算が加算に分配されることを知っているため（どちらも飽和算術には当てはまりません）、ループ全体を乗算と加算にまで最適化できます。連想性と分散性は各ループ反復で失敗し、失敗が発生した反復に応じて異なる結果を引き起こす可能性があるため、飽和演算はこの種の最適化を完全に無効にします。コンパイラはループを展開できますが、代数的に複数の操作をより少ない同等の操作に減らすことはできません。</target>
        </trans-unit>
        <trans-unit id="b3a8e98adc86bd54f822093e18075fecd0592176" translate="yes" xml:space="preserve">
          <source>Because the operator &lt;code&gt;^&lt;/code&gt; has higher precedence than &lt;code&gt;*&lt;/code&gt; (see &lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity-1&quot;&gt;Operator Precedence and Associativity&lt;/a&gt;), this output does not faithfully represent the expression &lt;code&gt;a ^ 2&lt;/code&gt; which should be equal to &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt;. To solve this issue, we must make a custom method for &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt;, which is called internally by the expression object when printing:</source>
          <target state="translated">演算子 &lt;code&gt;^&lt;/code&gt; は &lt;code&gt;*&lt;/code&gt; よりも優先順位が高いため（「&lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity-1&quot;&gt;演算子の優先順位と&lt;/a&gt;結合性」を参照）、この出力は &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt; 等しいはずの式 &lt;code&gt;a ^ 2&lt;/code&gt; を忠実に表していません。この問題を解決するには、 &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt; カスタムメソッドを作成する必要があります。これは、印刷時に式オブジェクトによって内部的に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="ae99b1d876ba3cfdc461cae08478806ff8d8ca63" translate="yes" xml:space="preserve">
          <source>Beer Mug</source>
          <target state="translated">ビールジョッキ</target>
        </trans-unit>
        <trans-unit id="5672f13a1da17dc7ad6970da457803cdfb5de94c" translate="yes" xml:space="preserve">
          <source>Before Julia 1.2 this signature was restricted to &lt;code&gt;f::Function&lt;/code&gt;.</source>
          <target state="translated">Julia 1.2以前は、このシグネチャは &lt;code&gt;f::Function&lt;/code&gt; に制限されていました。</target>
        </trans-unit>
        <trans-unit id="ebd25c6fc66535562035f061458e887115328bc8" translate="yes" xml:space="preserve">
          <source>Before running Julia set the environment variable &lt;code&gt;ENABLE_JITPROFILING&lt;/code&gt; to 1.</source>
          <target state="translated">Juliaを実行する前に、環境変数 &lt;code&gt;ENABLE_JITPROFILING&lt;/code&gt; を1に設定します。</target>
        </trans-unit>
        <trans-unit id="0dc928d36409cbb3c824f1591ba22fe5ec9e9dd8" translate="yes" xml:space="preserve">
          <source>Before the execution of the body of a &lt;code&gt;@testset&lt;/code&gt;, there is an implicit call to &lt;code&gt;Random.seed!(seed)&lt;/code&gt; where &lt;code&gt;seed&lt;/code&gt; is the current seed of the global RNG. Moreover, after the execution of the body, the state of the global RNG is restored to what it was before the &lt;code&gt;@testset&lt;/code&gt;. This is meant to ease reproducibility in case of failure, and to allow seamless re-arrangements of &lt;code&gt;@testset&lt;/code&gt;s regardless of their side-effect on the global RNG state.</source>
          <target state="translated">本体の実行前に &lt;code&gt;@testset&lt;/code&gt; 、への暗黙の呼び出しがあり &lt;code&gt;Random.seed!(seed)&lt;/code&gt; &lt;code&gt;seed&lt;/code&gt; グローバルRNGの現在の種子です。さらに、本体の実行後、グローバルRNGの状態は &lt;code&gt;@testset&lt;/code&gt; の前の状態に復元されます。これは、障害が発生した場合の再現性を容易にし、グローバルRNG状態への影響に関係なく &lt;code&gt;@testset&lt;/code&gt; のシームレスな再配置を可能にすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="e1451b7dd9bc69e125d61828d9b5cab1b14b61ea" translate="yes" xml:space="preserve">
          <source>Before the program terminates, it is strongly recommended to call &lt;code&gt;jl_atexit_hook&lt;/code&gt;. The above example program calls this before returning from &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">プログラムが終了する前に、 &lt;code&gt;jl_atexit_hook&lt;/code&gt; を呼び出すことを強くお勧めします。上記のプログラム例は、 &lt;code&gt;main&lt;/code&gt; から戻る前にこれを呼び出します。</target>
        </trans-unit>
        <trans-unit id="0b5e33825f4e17f1ad04b807863fc5ef1363c528" translate="yes" xml:space="preserve">
          <source>Behaves like a &lt;code&gt;Ptr{T}&lt;/code&gt; that can manage its memory via the Julia GC.</source>
          <target state="translated">Julia GCを介してメモリを管理できる &lt;code&gt;Ptr{T}&lt;/code&gt; ように動作します。</target>
        </trans-unit>
        <trans-unit id="e09863e9196cd18ccb74a5a4e0f5e83a34c2821d" translate="yes" xml:space="preserve">
          <source>Behaves like applying &lt;code&gt;n&lt;/code&gt; times &lt;code&gt;nextind&lt;/code&gt; for &lt;code&gt;n==1&lt;/code&gt;. The only difference is that if &lt;code&gt;n&lt;/code&gt; is so large that applying &lt;code&gt;nextind&lt;/code&gt; would reach &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; then each remaining iteration increases the returned value by &lt;code&gt;1&lt;/code&gt;. This means that in this case &lt;code&gt;nextind&lt;/code&gt; can return a value greater than &lt;code&gt;ncodeunits(str)+1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n==1&lt;/code&gt; に対して &lt;code&gt;nextind&lt;/code&gt; を &lt;code&gt;n&lt;/code&gt; 回適用するように動作します。唯一の違いは、 &lt;code&gt;n&lt;/code&gt; が非常に大きく、 &lt;code&gt;nextind&lt;/code&gt; を適用すると &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; に達する場合、残りの反復ごとに戻り値が &lt;code&gt;1&lt;/code&gt; ずつ増えることです。つまり、この場合、 &lt;code&gt;nextind&lt;/code&gt; は &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; より大きい値を返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="a2b1b1654cc55316ed5e2b35c84126cef980b48d" translate="yes" xml:space="preserve">
          <source>Behaves like applying &lt;code&gt;n&lt;/code&gt; times &lt;code&gt;prevind&lt;/code&gt; for &lt;code&gt;n==1&lt;/code&gt;. The only difference is that if &lt;code&gt;n&lt;/code&gt; is so large that applying &lt;code&gt;prevind&lt;/code&gt; would reach &lt;code&gt;0&lt;/code&gt; then each remaining iteration decreases the returned value by &lt;code&gt;1&lt;/code&gt;. This means that in this case &lt;code&gt;prevind&lt;/code&gt; can return a negative value.</source>
          <target state="translated">&lt;code&gt;n==1&lt;/code&gt; &lt;code&gt;prevind&lt;/code&gt; に &lt;code&gt;n&lt;/code&gt; 回適用するように動作します。唯一の違いは、 &lt;code&gt;n&lt;/code&gt; が大き &lt;code&gt;prevind&lt;/code&gt; を適用すると &lt;code&gt;0&lt;/code&gt; に到達する場合、残りの反復ごとに戻り値が &lt;code&gt;1&lt;/code&gt; ずつ減ることです。つまり、この場合、 &lt;code&gt;prevind&lt;/code&gt; は負の値を返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="d4198662a72fd519a4f968a74051bafac710dc07" translate="yes" xml:space="preserve">
          <source>Bell</source>
          <target state="translated">Bell</target>
        </trans-unit>
        <trans-unit id="bbab278669c1eda7fe0bdb1650c9fd25169b898f" translate="yes" xml:space="preserve">
          <source>Bell With Cancellation Stroke</source>
          <target state="translated">キャンセルストロークを持つベル</target>
        </trans-unit>
        <trans-unit id="94add7afb4e17fd6f1526d2edfd18924f6fd72ab" translate="yes" xml:space="preserve">
          <source>Below is an example where subnormals noticeably impact performance on some hardware:</source>
          <target state="translated">以下に、一部のハードウェアでサブノーマルが顕著にパフォーマンスに影響する例を示します。</target>
        </trans-unit>
        <trans-unit id="58c2a686d8a6b7d42c702706aa646004223a601b" translate="yes" xml:space="preserve">
          <source>Below we discuss particular challenges and some alternative ways to resolve such issues.</source>
          <target state="translated">以下では、特定の課題と、そのような課題を解決するためのいくつかの代替方法について説明します。</target>
        </trans-unit>
        <trans-unit id="e6be4001a8d2924783c806798a0e30c2803a6922" translate="yes" xml:space="preserve">
          <source>Bento Box</source>
          <target state="translated">弁当箱</target>
        </trans-unit>
        <trans-unit id="3f0f29bd74024b1bd9eec443c00d50257286a7db" translate="yes" xml:space="preserve">
          <source>Benzene Ring</source>
          <target state="translated">ベンゼン環</target>
        </trans-unit>
        <trans-unit id="c667600d6a843f35f26780da4256a01e9f67553a" translate="yes" xml:space="preserve">
          <source>Benzene Ring With Circle</source>
          <target state="translated">円が付いているベンゼン環</target>
        </trans-unit>
        <trans-unit id="79faabb26deabd43b3e790cb4753636cfebf2e58" translate="yes" xml:space="preserve">
          <source>Besides being used for the &lt;a href=&quot;../../base/constants/index#Base.VERSION&quot;&gt;&lt;code&gt;VERSION&lt;/code&gt;&lt;/a&gt; constant, &lt;code&gt;VersionNumber&lt;/code&gt; objects are widely used in the &lt;code&gt;Pkg&lt;/code&gt; module, to specify packages versions and their dependencies.</source>
          <target state="translated">&lt;a href=&quot;../../base/constants/index#Base.VERSION&quot;&gt; &lt;code&gt;VERSION&lt;/code&gt; &lt;/a&gt;定数に使用されるほかに、 &lt;code&gt;VersionNumber&lt;/code&gt; オブジェクトは &lt;code&gt;Pkg&lt;/code&gt; モジュールで広く使用され、パッケージのバージョンとその依存関係を指定します。</target>
        </trans-unit>
        <trans-unit id="4c077965afc4d3ad848734d7192dc33685665fb8" translate="yes" xml:space="preserve">
          <source>Bet Symbol / Second Transfinite Cardinal</source>
          <target state="translated">ベットシンボル/セカンドトランスフィニットカーディナル</target>
        </trans-unit>
        <trans-unit id="1b22feb0c0c13c69ebe6389111ff7312bd0c946b" translate="yes" xml:space="preserve">
          <source>Between</source>
          <target state="translated">Between</target>
        </trans-unit>
        <trans-unit id="4e83ab72f5680a7927bc2ee1770585b538110359" translate="yes" xml:space="preserve">
          <source>Bicycle</source>
          <target state="translated">Bicycle</target>
        </trans-unit>
        <trans-unit id="af44c67fc560bdac204e3457136721b15282deb9" translate="yes" xml:space="preserve">
          <source>Bicyclist</source>
          <target state="translated">Bicyclist</target>
        </trans-unit>
        <trans-unit id="ca17e7c02d8603afa7449be022da99c068361156" translate="yes" xml:space="preserve">
          <source>Bidiagonal</source>
          <target state="translated">Bidiagonal</target>
        </trans-unit>
        <trans-unit id="f0830adbb847a3826b894a8d2b1be1aa3648828e" translate="yes" xml:space="preserve">
          <source>BigFloats and BigInts</source>
          <target state="translated">ビッグフロートとビッグインッツ</target>
        </trans-unit>
        <trans-unit id="aacc2899433eb85e7a2394fe9113a636959564b2" translate="yes" xml:space="preserve">
          <source>Bikini</source>
          <target state="translated">Bikini</target>
        </trans-unit>
        <trans-unit id="aaaa53539dc3641fca1eac5e64bf0cba011ff6e3" translate="yes" xml:space="preserve">
          <source>Bilaterally permute &lt;code&gt;A&lt;/code&gt;, returning &lt;code&gt;PAQ&lt;/code&gt; (&lt;code&gt;A[p,q]&lt;/code&gt;). Column-permutation &lt;code&gt;q&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s column count (&lt;code&gt;length(q) == A.n&lt;/code&gt;). Row-permutation &lt;code&gt;p&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s row count (&lt;code&gt;length(p) == A.m&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; を双方向に並べ替え、 &lt;code&gt;PAQ&lt;/code&gt; を返します（ &lt;code&gt;A[p,q]&lt;/code&gt; ）。列置換 &lt;code&gt;q&lt;/code&gt; の長さは &lt;code&gt;A&lt;/code&gt; の列数と一致する必要があります（ &lt;code&gt;length(q) == A.n&lt;/code&gt; ）。行順列 &lt;code&gt;p&lt;/code&gt; の長さは &lt;code&gt;A&lt;/code&gt; の行数と一致する必要があります（ &lt;code&gt;length(p) == A.m&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="aa67c0c72b73769483142d524a72dd00b47e7280" translate="yes" xml:space="preserve">
          <source>Bilaterally permute &lt;code&gt;A&lt;/code&gt;, storing result &lt;code&gt;PAQ&lt;/code&gt; (&lt;code&gt;A[p,q]&lt;/code&gt;) in &lt;code&gt;X&lt;/code&gt;. Stores intermediate result &lt;code&gt;(AQ)^T&lt;/code&gt; (&lt;code&gt;transpose(A[:,q])&lt;/code&gt;) in optional argument &lt;code&gt;C&lt;/code&gt; if present. Requires that none of &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, and, if present, &lt;code&gt;C&lt;/code&gt; alias each other; to store result &lt;code&gt;PAQ&lt;/code&gt; back into &lt;code&gt;A&lt;/code&gt;, use the following method lacking &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; を双方向に並べ替え、結果 &lt;code&gt;PAQ&lt;/code&gt; （ &lt;code&gt;A[p,q]&lt;/code&gt; ）を &lt;code&gt;X&lt;/code&gt; に格納します。中間結果 &lt;code&gt;(AQ)^T&lt;/code&gt; （ &lt;code&gt;transpose(A[:,q])&lt;/code&gt; ）をオプションの引数 &lt;code&gt;C&lt;/code&gt; に格納します（存在する場合）。 &lt;code&gt;X&lt;/code&gt; 、 &lt;code&gt;A&lt;/code&gt; 、および存在する場合は &lt;code&gt;C&lt;/code&gt; のいずれも互いにエイリアスを設定しないことを要求します。結果の &lt;code&gt;PAQ&lt;/code&gt; を &lt;code&gt;A&lt;/code&gt; に戻すには、 &lt;code&gt;X&lt;/code&gt; がない次のメソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="9c4f1f960deffd3639bacc943d7beee3c049657a" translate="yes" xml:space="preserve">
          <source>Billiards</source>
          <target state="translated">Billiards</target>
        </trans-unit>
        <trans-unit id="6a9a9dae508a5a43298d0ecf022071a0f6818999" translate="yes" xml:space="preserve">
          <source>Binary (or unary) operators like &lt;code&gt;.+&lt;/code&gt; are handled with the same mechanism: they are equivalent to &lt;code&gt;broadcast&lt;/code&gt; calls and are fused with other nested &quot;dot&quot; calls. &lt;code&gt;X .+= Y&lt;/code&gt; etcetera is equivalent to &lt;code&gt;X .= X .+ Y&lt;/code&gt; and results in a fused in-place assignment; see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot operators&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.+&lt;/code&gt; ようなバイナリ（または単項）演算子は同じメカニズムで処理 &lt;code&gt;broadcast&lt;/code&gt; ます。これらはブロードキャスト呼び出しと同等であり、他のネストされた「ドット」呼び出しと融合されます。 &lt;code&gt;X .+= Y&lt;/code&gt; 等々は、と等価である &lt;code&gt;X .= X .+ Y&lt;/code&gt; 及び融合インプレース割り当てをもたらします。&lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;ドット演算子&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="a754b43c5cd6bc6c82c954daabe8d0dd0d9ab2bb" translate="yes" xml:space="preserve">
          <source>Binary and octal literals are also supported:</source>
          <target state="translated">2進リテラルと8進リテラルもサポートされています。</target>
        </trans-unit>
        <trans-unit id="f84a08f5fd91d8b683f66ada3a3f0d37dd8d9416" translate="yes" xml:space="preserve">
          <source>Binary arithmetic &amp;ndash; &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;</source>
          <target state="translated">バイナリ算術- - &lt;code&gt;-&lt;/code&gt; + 、 &lt;code&gt;+&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;/&lt;/code&gt; 、 &lt;code&gt;\&lt;/code&gt; 、 &lt;code&gt;^&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08e24dd0237ae9c6c248482e7cdae84d6dd71aee" translate="yes" xml:space="preserve">
          <source>Binary, octal, and hexadecimal literals may be signed by a &lt;code&gt;-&lt;/code&gt; immediately preceding the unsigned literal. They produce an unsigned integer of the same size as the unsigned literal would do, with the two's complement of the value:</source>
          <target state="translated">2進数、8進数、16進数のリテラルは、符号なしリテラルの直前に &lt;code&gt;-&lt;/code&gt; を付けることができます。これらは、値の2の補数を使用して、符号なしリテラルと同じサイズの符号なし整数を生成します。</target>
        </trans-unit>
        <trans-unit id="ccb7426c705bde96fa9acacc232348e6649fb196" translate="yes" xml:space="preserve">
          <source>Bind &lt;code&gt;socket&lt;/code&gt; to the given &lt;code&gt;host:port&lt;/code&gt;. Note that &lt;code&gt;0.0.0.0&lt;/code&gt; will listen on all devices.</source>
          <target state="translated">指定された &lt;code&gt;host:port&lt;/code&gt; に &lt;code&gt;socket&lt;/code&gt; をバインドします。 &lt;code&gt;0.0.0.0&lt;/code&gt; はすべてのデバイスでリッスンすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="fe7e2953e9474b2bd135241c7c997e4972287729" translate="yes" xml:space="preserve">
          <source>Bird</source>
          <target state="translated">Bird</target>
        </trans-unit>
        <trans-unit id="65c2eaa1dcfba5d5f9a0a3584ad5e6d8f7aef198" translate="yes" xml:space="preserve">
          <source>Birthday Cake</source>
          <target state="translated">バースデーケーキ</target>
        </trans-unit>
        <trans-unit id="93ea79c838264d2a1d87b4b0c60302c8a973255c" translate="yes" xml:space="preserve">
          <source>BitArray</source>
          <target state="translated">BitArray</target>
        </trans-unit>
        <trans-unit id="4b9bfa4acc76402f1ab1ef6ccdbff0077343e801" translate="yes" xml:space="preserve">
          <source>BitArray()</source>
          <target state="translated">BitArray()</target>
        </trans-unit>
        <trans-unit id="f8cd7716f7a5997d4efd153b8de6bda8ac575d3b" translate="yes" xml:space="preserve">
          <source>BitSet</source>
          <target state="translated">BitSet</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
