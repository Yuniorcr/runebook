<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="bd271b290661f2d2dcd371ac877e792e11b0ae4c" translate="yes" xml:space="preserve">
          <source>In place of the written syntax, the macro call is expanded at parse time to its returned result. This is equivalent to writing:</source>
          <target state="translated">書かれた構文の代わりに、マクロ呼び出しは解析時に展開され、その結果が返されます。これは書き込みと同等です。</target>
        </trans-unit>
        <trans-unit id="f1faf89b83d5028304b1044be098d4330cb094e6" translate="yes" xml:space="preserve">
          <source>In practice, especially when providing reusable functionality, one generally wraps &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function indicates them, propagating to the Julia caller as exceptions. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For example, the &lt;code&gt;getenv&lt;/code&gt; C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt;&lt;code&gt;env.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">実際には、特に再利用可能な機能を提供する場合、通常は、引数を設定し、CまたはFortran関数がそれらを示す方法でエラーをチェックするJulia関数で&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;をラップし、例外としてJulia呼び出し元に伝達します。CとFortranのAPIは、エラー状態をどのように示すかについてよく知られていないため、これは特に重要です。たとえば、 &lt;code&gt;getenv&lt;/code&gt; Cライブラリ関数は、次のJulia関数にラップされます。これは、&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt; &lt;code&gt;env.jl&lt;/code&gt; &lt;/a&gt;からの実際の定義を簡略化したバージョンです。</target>
        </trans-unit>
        <trans-unit id="804d748c80f6e79bb9e342f1f2304330f7eae29d" translate="yes" xml:space="preserve">
          <source>In principle, the Markdown parser itself can also be arbitrarily extended by packages, or an entirely custom flavour of Markdown can be used, but this should generally be unnecessary.</source>
          <target state="translated">原則として、Markdownパーサー自体はパッケージによって任意に拡張することができ、またはMarkdownの完全なカスタムフレーバーを使用することができますが、これは一般的には不要です。</target>
        </trans-unit>
        <trans-unit id="f1e4e6ce2511929e6de42c91eafd73bc415389d8" translate="yes" xml:space="preserve">
          <source>In short, it is an immutable dictionary that is a subclass of &lt;code&gt;IO&lt;/code&gt;. It supports standard dictionary operations such as &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, and can also be used as an I/O stream.</source>
          <target state="translated">つまり、 &lt;code&gt;IO&lt;/code&gt; のサブクラスである不変の辞書です。&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;などの標準の辞書操作をサポートし、I / Oストリームとしても使用できます。</target>
        </trans-unit>
        <trans-unit id="638b74bbfc0d77182896b29b38f7e41990e9ec77" translate="yes" xml:space="preserve">
          <source>In some applications, an alternative to zeroing subnormal numbers is to inject a tiny bit of noise. For example, instead of initializing &lt;code&gt;a&lt;/code&gt; with zeros, initialize it with:</source>
          <target state="translated">一部のアプリケーションでは、非正規数をゼロにする代わりに、ほんの少しのノイズを注入する方法があります。たとえば、 &lt;code&gt;a&lt;/code&gt; をゼロで初期化する代わりに、次のように初期化します。</target>
        </trans-unit>
        <trans-unit id="c0f7478a3f0be2e5b9c7e0905c13888f63fbab1a" translate="yes" xml:space="preserve">
          <source>In some applications, it is convenient to store explicit zero values in a &lt;code&gt;SparseMatrixCSC&lt;/code&gt;. These &lt;em&gt;are&lt;/em&gt; accepted by functions in &lt;code&gt;Base&lt;/code&gt; (but there is no guarantee that they will be preserved in mutating operations). Such explicitly stored zeros are treated as structural nonzeros by many routines. The &lt;a href=&quot;#SparseArrays.nnz&quot;&gt;&lt;code&gt;nnz&lt;/code&gt;&lt;/a&gt; function returns the number of elements explicitly stored in the sparse data structure, including structural nonzeros. In order to count the exact number of numerical nonzeros, use &lt;a href=&quot;../../base/collections/index#Base.count&quot;&gt;&lt;code&gt;count(!iszero, x)&lt;/code&gt;&lt;/a&gt;, which inspects every stored element of a sparse matrix. &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt;&lt;code&gt;dropzeros&lt;/code&gt;&lt;/a&gt;, and the in-place &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt;&lt;code&gt;dropzeros!&lt;/code&gt;&lt;/a&gt;, can be used to remove stored zeros from the sparse matrix.</source>
          <target state="translated">一部のアプリケーションでは、明示的なゼロ値を &lt;code&gt;SparseMatrixCSC&lt;/code&gt; に格納すると便利です。これら&lt;em&gt;は&lt;/em&gt; &lt;code&gt;Base&lt;/code&gt; の関数で受け入れられます（ただし、変更操作で保持される保証はありません）。このような明示的に格納されたゼロは、多くのルーチンで構造的非ゼロとして扱われます。&lt;a href=&quot;#SparseArrays.nnz&quot;&gt; &lt;code&gt;nnz&lt;/code&gt; &lt;/a&gt;関数は、構造の非ゼロ要素を含む、明示的にスパースなデータ構造に格納された要素の数を返します。非ゼロの数値の正確な数をカウントするには、&lt;a href=&quot;../../base/collections/index#Base.count&quot;&gt; &lt;code&gt;count(!iszero, x)&lt;/code&gt; &lt;/a&gt;使用します。これは、スパース行列のすべての格納された要素を検査します。&lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt; &lt;code&gt;dropzeros&lt;/code&gt; &lt;/a&gt;とインプレースの&lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt; &lt;code&gt;dropzeros!&lt;/code&gt; &lt;/a&gt;、スパース行列から格納されたゼロを削除するために使用できます。</target>
        </trans-unit>
        <trans-unit id="7200ec90f922f3162b688616528f07bbd46b3f3f" translate="yes" xml:space="preserve">
          <source>In some cases changing the value of a &lt;code&gt;const&lt;/code&gt; variable gives a warning instead of an error. However, this can produce unpredictable behavior or corrupt the state of your program, and so should be avoided. This feature is intended only for convenience during interactive use.</source>
          <target state="translated">場合によっては、 &lt;code&gt;const&lt;/code&gt; 変数の値を変更すると、エラーではなく警告が表示されます。ただし、これにより予測できない動作が発生したり、プログラムの状態が破損したりする可能性があるため、回避する必要があります。この機能は、インタラクティブな使用中の便宜のためにのみ意図されています。</target>
        </trans-unit>
        <trans-unit id="0bca4b7af7b2c3f590b22d6bdc9c439dda8d86d1" translate="yes" xml:space="preserve">
          <source>In some cases it might be convenient not to have to define &lt;code&gt;MyStyle&lt;/code&gt;, in which case you can leverage one of the general broadcast wrappers:</source>
          <target state="translated">&lt;code&gt;MyStyle&lt;/code&gt; を定義する必要がない方が便利な場合もあります。その場合は、一般的なブロードキャストラッパーの1つを利用できます。</target>
        </trans-unit>
        <trans-unit id="6f5f29a98f7076181fba48634a540b92f8996002" translate="yes" xml:space="preserve">
          <source>In some cases no reduction operator is needed, and we merely wish to apply a function to all integers in some range (or, more generally, to all elements in some collection). This is another useful operation called &lt;em&gt;parallel map&lt;/em&gt;, implemented in Julia as the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; function. For example, we could compute the singular values of several large random matrices in parallel as follows:</source>
          <target state="translated">場合によっては、縮約演算子が不要で、ある範囲のすべての整数（または、より一般的には、いくつかのコレクションのすべての要素）に関数を適用したいだけです。これは、Juliaで&lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt;関数として実装された、&lt;em&gt;並列マップ&lt;/em&gt;と呼ばれるもう1つの便利な操作です。たとえば、次のように、いくつかの大きなランダム行列の特異値を並列で計算できます。</target>
        </trans-unit>
        <trans-unit id="6de51e42bc98441adfec5061cc53937870969a7a" translate="yes" xml:space="preserve">
          <source>In some cases, for a given RNG type, generating an array of random values can be more efficient with a specialized method than by merely using the decoupling technique explained before. This is for example the case for &lt;code&gt;MersenneTwister&lt;/code&gt;, which natively writes random values in an array.</source>
          <target state="translated">場合によっては、特定のRNGタイプについて、ランダム値の配列を生成する方が、前に説明したデカップリングテクニックを単に使用するよりも、特殊な方法を使用する方が効率的です。これは、たとえば、ランダムな値を配列にネイティブに書き込む &lt;code&gt;MersenneTwister&lt;/code&gt; の場合などです。</target>
        </trans-unit>
        <trans-unit id="f953f89be50274569ebdd1d16dd1091ac2cf9f4a" translate="yes" xml:space="preserve">
          <source>In some cases, it is useful to adjust the behavior of &lt;code&gt;show&lt;/code&gt; methods depending on the context. This can be achieved via the &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; type, which allows passing contextual properties together with a wrapped IO stream. For example, we can build a shorter representation in our &lt;code&gt;show&lt;/code&gt; method when the &lt;code&gt;:compact&lt;/code&gt; property is set to &lt;code&gt;true&lt;/code&gt;, falling back to the long representation if the property is &lt;code&gt;false&lt;/code&gt; or absent:</source>
          <target state="translated">場合によっては、コンテキストに応じて &lt;code&gt;show&lt;/code&gt; メソッドの動作を調整すると便利です。これは、ラップされたIOストリームと共にコンテキストプロパティを渡すことができる&lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;タイプを介して実現できます。たとえば、 &lt;code&gt;:compact&lt;/code&gt; プロパティが &lt;code&gt;true&lt;/code&gt; に設定されている場合は、 &lt;code&gt;show&lt;/code&gt; メソッドで短い表現を作成し、プロパティが &lt;code&gt;false&lt;/code&gt; または存在しない場合は長い表現にフォールバックできます。</target>
        </trans-unit>
        <trans-unit id="ef681cb1496bc3731bd754661d5504701ec7c4ad" translate="yes" xml:space="preserve">
          <source>In some cases, whether one wants to generate only a handful of values or a large number of values will have an impact on the choice of algorithm. This is handled with the third parameter of the &lt;code&gt;Sampler&lt;/code&gt; constructor. Let's assume we defined two helper types for &lt;code&gt;Die&lt;/code&gt;, say &lt;code&gt;SamplerDie1&lt;/code&gt; which should be used to generate only few random values, and &lt;code&gt;SamplerDieMany&lt;/code&gt; for many values. We can use those types as follows:</source>
          <target state="translated">場合によっては、少数の値のみを生成するか、多数の値を生成するかが、アルゴリズムの選択に影響を与えます。これは、 &lt;code&gt;Sampler&lt;/code&gt; コンストラクターの3番目のパラメーターで処理されます。我々はのための2つのヘルパー種類定義されてと仮定しましょう &lt;code&gt;Die&lt;/code&gt; 、言う &lt;code&gt;SamplerDie1&lt;/code&gt; のみいくつかのランダムな値を生成するために使用されなければならない、と &lt;code&gt;SamplerDieMany&lt;/code&gt; を多くの値について。これらのタイプは次のように使用できます。</target>
        </trans-unit>
        <trans-unit id="793adcc5e6d1a8b0006e672f0871fab8bd1ee12e" translate="yes" xml:space="preserve">
          <source>In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the &lt;a href=&quot;#tools-1&quot;&gt;tools&lt;/a&gt; below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see &lt;a href=&quot;#Pre-allocating-outputs-1&quot;&gt;Pre-allocating outputs&lt;/a&gt;).</source>
          <target state="translated">状況によっては、関数がその操作の一部としてメモリを割り当てる必要があり、これにより上記の簡単な図が複雑になる場合があります。そのような場合は、以下の&lt;a href=&quot;#tools-1&quot;&gt;ツールの&lt;/a&gt;いずれかを使用して問題を診断するか、割り当てをアルゴリズムの側面から分離する関数のバージョンを作成することを検討してください（&lt;a href=&quot;#Pre-allocating-outputs-1&quot;&gt;出力の事前割り当てを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2a0f5f99ad11403dc52acb366ff631558f32f389" translate="yes" xml:space="preserve">
          <source>In step 2 below, edit &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; to change the source code, and &lt;code&gt;MyPkg/test/runtests.jl&lt;/code&gt; for the tests.</source>
          <target state="translated">以下のステップ2では、 &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; を編集してソースコードを変更し、 &lt;code&gt;MyPkg/test/runtests.jl&lt;/code&gt; をテスト用に変更します。</target>
        </trans-unit>
        <trans-unit id="18fa22072854af164b60f3647ea657dba3a66a38" translate="yes" xml:space="preserve">
          <source>In step 2 below, edit &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; to change the source code, and create any test file of your choosing.</source>
          <target state="translated">以下の手順2で、 &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; を編集してソースコードを変更し、任意のテストファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="4a0eaae9f72d9710fb65a9583dfc845568e81d5f" translate="yes" xml:space="preserve">
          <source>In such cases one should redesign the code to avoid the possibility of a race condition or use &lt;a href=&quot;https://docs.julialang.org/en/latest/base/multi-threading/#Synchronization-Primitives-1&quot;&gt;synchronization primitives&lt;/a&gt;.</source>
          <target state="translated">そのような場合、競合状態の可能性を回避するか、&lt;a href=&quot;https://docs.julialang.org/en/latest/base/multi-threading/#Synchronization-Primitives-1&quot;&gt;同期プリミティブを&lt;/a&gt;使用するようにコードを再設計する必要があります。</target>
        </trans-unit>
        <trans-unit id="2e9e71bba5509813057399a4f8d90c9c53704d76" translate="yes" xml:space="preserve">
          <source>In such cases, the result is always 1-d.</source>
          <target state="translated">このような場合、結果は必ず1-dとなります。</target>
        </trans-unit>
        <trans-unit id="c795388eedec3a869fe287bc8b5bbacb71a43dbd" translate="yes" xml:space="preserve">
          <source>In technical-computing languages, it is common to have &quot;vectorized&quot; versions of functions, which simply apply a given function &lt;code&gt;f(x)&lt;/code&gt; to each element of an array &lt;code&gt;A&lt;/code&gt; to yield a new array via &lt;code&gt;f(A)&lt;/code&gt;. This kind of syntax is convenient for data processing, but in other languages vectorization is also often required for performance: if loops are slow, the &quot;vectorized&quot; version of a function can call fast library code written in a low-level language. In Julia, vectorized functions are &lt;em&gt;not&lt;/em&gt; required for performance, and indeed it is often beneficial to write your own loops (see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;), but they can still be convenient. Therefore, &lt;em&gt;any&lt;/em&gt; Julia function &lt;code&gt;f&lt;/code&gt; can be applied elementwise to any array (or other collection) with the syntax &lt;code&gt;f.(A)&lt;/code&gt;. For example, &lt;code&gt;sin&lt;/code&gt; can be applied to all elements in the vector &lt;code&gt;A&lt;/code&gt; like so:</source>
          <target state="translated">テクニカルコンピューティング言語では、「ベクトル化」バージョンの関数を使用するのが一般的です。これは、特定の関数 &lt;code&gt;f(x)&lt;/code&gt; を配列 &lt;code&gt;A&lt;/code&gt; の各要素に適用して、 &lt;code&gt;f(A)&lt;/code&gt; を介して新しい配列を生成するだけです。この種の構文はデータ処理に便利ですが、他の言語ではパフォーマンスのためにベクトル化もしばしば必要です。ループが遅い場合、関数の「ベクトル化」バージョンは低レベル言語で記述された高速ライブラリコードを呼び出すことができます。 Juliaでは、ベクトル化された関数はパフォーマンスに必要あり&lt;em&gt;ません。&lt;/em&gt;実際に、独自のループを作成することはしばしば有益です（&lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;パフォーマンスのヒントを&lt;/a&gt;参照）。しかし、それらは依然として便利です。したがって、&lt;em&gt;任意の&lt;/em&gt;ジュリア関数 &lt;code&gt;f&lt;/code&gt; 構文 &lt;code&gt;f.(A)&lt;/code&gt; して、要素ごとに任意の配列（または他のコレクション）に適用できます。たとえば、 &lt;code&gt;sin&lt;/code&gt; はベクトル &lt;code&gt;A&lt;/code&gt; のすべての要素に次のように適用できます。</target>
        </trans-unit>
        <trans-unit id="1295513c71d65c30e7efa46afbaa35e5c9e76740" translate="yes" xml:space="preserve">
          <source>In terms of UNIX plumbing, what's happening here is that a single UNIX pipe object is created and written to by both &lt;code&gt;echo&lt;/code&gt; processes, and the other end of the pipe is read from by the &lt;code&gt;sort&lt;/code&gt; command.</source>
          <target state="translated">UNIXの配管に関して、ここで起こっていることは、単一のUNIXパイプオブジェクトが両方の &lt;code&gt;echo&lt;/code&gt; プロセスによって作成および書き込まれ、パイプのもう一方の端が &lt;code&gt;sort&lt;/code&gt; コマンドによって読み取られることです。</target>
        </trans-unit>
        <trans-unit id="bc29b396f06d90d9310efc41817564ce48560df4" translate="yes" xml:space="preserve">
          <source>In the Julia REPL and several other Julia editing environments, you can type many Unicode math symbols by typing the backslashed LaTeX symbol name followed by tab. For example, the variable name &lt;code&gt;&amp;delta;&lt;/code&gt; can be entered by typing &lt;code&gt;\delta&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;, or even &lt;code&gt;&amp;alpha;̂₂&lt;/code&gt; by &lt;code&gt;\alpha&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;-&lt;code&gt;\hat&lt;/code&gt;- &lt;em&gt;tab&lt;/em&gt;-&lt;code&gt;\_2&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;. (If you find a symbol somewhere, e.g. in someone else's code, that you don't know how to type, the REPL help will tell you: just type &lt;code&gt;?&lt;/code&gt; and then paste the symbol.)</source>
          <target state="translated">Julia REPLおよび他のいくつかのJulia編集環境では、バックスラッシュ付きのLaTeXシンボル名に続けてタブを入力することにより、多くのUnicode数学シンボルを入力できます。たとえば、変数名 &lt;code&gt;&amp;delta;&lt;/code&gt; は、タイピングで入力することができます &lt;code&gt;\delta&lt;/code&gt; - &lt;em&gt;タブ&lt;/em&gt;、あるいは &lt;code&gt;&amp;alpha;̂₂&lt;/code&gt; で &lt;code&gt;\alpha&lt;/code&gt; - &lt;em&gt;タブ&lt;/em&gt; - &lt;code&gt;\hat&lt;/code&gt; - &lt;em&gt;タブ&lt;/em&gt; - &lt;code&gt;\_2&lt;/code&gt; - &lt;em&gt;タブ&lt;/em&gt;。 （どこか他の人のコードなどで、タイプする方法がわからないシンボルを見つけた場合、REPLヘルプが教えてくれます： &lt;code&gt;?&lt;/code&gt; をタイプしてから、シンボルを貼り付けます。）</target>
        </trans-unit>
        <trans-unit id="7569c827c9a13b3faf85c9b20e363a3375ada161" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;@everywhere module Foo&lt;/code&gt; defined &lt;code&gt;Foo&lt;/code&gt; on all nodes. However the call to &lt;code&gt;Foo.foo()&lt;/code&gt; created a new global binding &lt;code&gt;gvar&lt;/code&gt; on the local node, but this was not found on node 2 resulting in an &lt;code&gt;UndefVarError&lt;/code&gt; error.</source>
          <target state="translated">上記の例では、 &lt;code&gt;@everywhere module Foo&lt;/code&gt; &lt;code&gt;Foo&lt;/code&gt; がすべてのノードでFooを定義しています。ただし、 &lt;code&gt;Foo.foo()&lt;/code&gt; の呼び出しにより、ローカルノードに新しいグローバルバインディング &lt;code&gt;gvar&lt;/code&gt; が作成されましたが、ノード2でこれが見つからなかったため、 &lt;code&gt;UndefVarError&lt;/code&gt; エラーが発生しました。</target>
        </trans-unit>
        <trans-unit id="4befd8beabfc58d36d63a701ccb0fcbe3c3991f4" translate="yes" xml:space="preserve">
          <source>In the absence of a type declaration with &lt;code&gt;::&lt;/code&gt;, the type of a method parameter is &lt;code&gt;Any&lt;/code&gt; by default, meaning that it is unconstrained since all values in Julia are instances of the abstract type &lt;code&gt;Any&lt;/code&gt;. Thus, we can define a catch-all method for &lt;code&gt;f&lt;/code&gt; like so:</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; による型宣言がない場合、メソッドパラメータの型はデフォルトで &lt;code&gt;Any&lt;/code&gt; になります。つまり、Juliaのすべての値は抽象型 &lt;code&gt;Any&lt;/code&gt; のインスタンスであるため、制約されません。したがって、 &lt;code&gt;f&lt;/code&gt; ようにfのキャッチオールメソッドを定義できます。</target>
        </trans-unit>
        <trans-unit id="14e6eb62fa9a3db0a4d3297fcd4c7b6e7504f490" translate="yes" xml:space="preserve">
          <source>In the assignment form, the body of the function must be a single expression, although it can be a compound expression (see &lt;a href=&quot;../control-flow/index#man-compound-expressions-1&quot;&gt;Compound Expressions&lt;/a&gt;). Short, simple function definitions are common in Julia. The short function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.</source>
          <target state="translated">代入式では、関数の本体は単一の式でなければなりませんが、複合式にすることもできます（&lt;a href=&quot;../control-flow/index#man-compound-expressions-1&quot;&gt;複合式を&lt;/a&gt;参照）。Juliaでは、短く単純な関数定義が一般的です。したがって、短い関数構文は非常に慣用的であり、タイピングと視覚ノイズの両方を大幅に削減します。</target>
        </trans-unit>
        <trans-unit id="8b4a822ba35b7b2a2b87214b87f56abe71bd6a7e" translate="yes" xml:space="preserve">
          <source>In the body of the generated function you only have access to the &lt;em&gt;types&lt;/em&gt; of the arguments &amp;ndash; not their values &amp;ndash; and any function that was defined &lt;em&gt;before&lt;/em&gt; the definition of the generated function.</source>
          <target state="translated">生成された関数の本体では、引数の&lt;em&gt;タイプ&lt;/em&gt;（値ではなく）と、生成された関数の定義&lt;em&gt;前&lt;/em&gt;に定義された関数にのみアクセスできます。</target>
        </trans-unit>
        <trans-unit id="d4f8a53fe3cbe9ccdbd0383d96fd01b1b384f1cc" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;Point&lt;/code&gt;, the type of &lt;code&gt;T&lt;/code&gt; is unambiguously implied if and only if the two arguments to &lt;code&gt;Point&lt;/code&gt; have the same type. When this isn't the case, the constructor will fail with a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;Point&lt;/code&gt; の場合、 &lt;code&gt;T&lt;/code&gt; の型は、 &lt;code&gt;Point&lt;/code&gt; への2つの引数が同じ型である場合に限り、明確に暗示されます。そうでない場合、コンストラクタは&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; で&lt;/a&gt;失敗します。</target>
        </trans-unit>
        <trans-unit id="8083b5b25cdad6fa0ec0e103815341575e54f6a2" translate="yes" xml:space="preserve">
          <source>In the case that the type of &lt;code&gt;a[1]&lt;/code&gt; is not known precisely, &lt;code&gt;x&lt;/code&gt; can be declared via &lt;code&gt;x = convert(Int32, a[1])::Int32&lt;/code&gt;. The use of the &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; function allows &lt;code&gt;a[1]&lt;/code&gt; to be any object convertible to an &lt;code&gt;Int32&lt;/code&gt; (such as &lt;code&gt;UInt8&lt;/code&gt;), thus increasing the genericity of the code by loosening the type requirement. Notice that &lt;code&gt;convert&lt;/code&gt; itself needs a type annotation in this context in order to achieve type stability. This is because the compiler cannot deduce the type of the return value of a function, even &lt;code&gt;convert&lt;/code&gt;, unless the types of all the function's arguments are known.</source>
          <target state="translated">&lt;code&gt;a[1]&lt;/code&gt; 型が正確にわからない場合、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;x = convert(Int32, a[1])::Int32&lt;/code&gt; 介して宣言できます。使用&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;機能を可能にする &lt;code&gt;a[1]&lt;/code&gt; に変換する任意のオブジェクトであること &lt;code&gt;Int32&lt;/code&gt; （例えば、 &lt;code&gt;UInt8&lt;/code&gt; こうして型要件を緩めることにより、コードの汎用性を増加させます）。型の安定性を実現するために、このコンテキストでは &lt;code&gt;convert&lt;/code&gt; 自体が型注釈を必要とすることに注意してください。これは、関数のすべての引数の型が既知でない限り、コンパイラは関数の戻り値の型を推測できず、たとえ &lt;code&gt;convert&lt;/code&gt; であってもできないためです。</target>
        </trans-unit>
        <trans-unit id="831b049ac64422357fdc2a1f1e12b98990a72d96" translate="yes" xml:space="preserve">
          <source>In the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced with the value bound to that symbol in the appropriate &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="translated">式のコンテキストでは、変数へのアクセスを示すために記号が使用されます。式が評価されると、シンボルは適切な&lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;スコープ&lt;/a&gt;でそのシンボルにバインドされた値に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="bb0ccf20285ac1f5e0c9e737c0f406f1f62a6d45" translate="yes" xml:space="preserve">
          <source>In the context of function definitions, the &lt;code&gt;...&lt;/code&gt; operator is used to combine many different arguments into a single argument. This use of &lt;code&gt;...&lt;/code&gt; for combining many different arguments into a single argument is called slurping:</source>
          <target state="translated">関数定義のコンテキストでは、 &lt;code&gt;...&lt;/code&gt; 演算子を使用して、さまざまな引数を1つの引数に結合します。多くの異なる引数を単一の引数に組み合わせるための &lt;code&gt;...&lt;/code&gt; のこの使用は、丸呑みと呼ばれます。</target>
        </trans-unit>
        <trans-unit id="93652cdf53268e5b525c9968aae662e21595f44e" translate="yes" xml:space="preserve">
          <source>In the end we will present Julia's approach to distributed and parallel computing. With scientific computing in mind, Julia natively implements interfaces to distribute a process across multiple cores or machines. Also we will mention useful external packages for distributed programming like &lt;code&gt;MPI.jl&lt;/code&gt; and &lt;code&gt;DistributedArrays.jl&lt;/code&gt;.</source>
          <target state="translated">最後に、分散および並列コンピューティングに対するジュリアのアプローチを紹介します。科学計算を念頭に置いて、Juliaはネイティブにインターフェースを実装して、複数のコアまたはマシンにプロセスを分散します。また、 &lt;code&gt;MPI.jl&lt;/code&gt; や &lt;code&gt;DistributedArrays.jl&lt;/code&gt; などの分散プログラミングに役立つ外部パッケージについても説明します。</target>
        </trans-unit>
        <trans-unit id="d323acfd53199deb66ce97dad2e67a0a4f124fda" translate="yes" xml:space="preserve">
          <source>In the event that a nested test set has no failures, as happened here, it will be hidden in the summary. If we do have a test failure, only the details for the failed test sets will be shown:</source>
          <target state="translated">ここで起こったように、入れ子になっているテストセットに失敗がなかった場合は、要約の中で非表示になります。テストに失敗した場合、失敗したテストセットの詳細のみが表示されます。</target>
        </trans-unit>
        <trans-unit id="381773d3ab62fd2b5a03a4a6a4af80e1db7c0e67" translate="yes" xml:space="preserve">
          <source>In the event that two modules provide non-standard string or command literals with the same name, it is possible to qualify the string or command literal with a module name. For instance, if both &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt; provide non-standard string literal &lt;code&gt;@x_str&lt;/code&gt;, then one can write &lt;code&gt;Foo.x&quot;literal&quot;&lt;/code&gt; or &lt;code&gt;Bar.x&quot;literal&quot;&lt;/code&gt; to disambiguate between the two.</source>
          <target state="translated">2つのモジュールが同じ名前の非標準の文字列またはコマンドリテラルを提供する場合、モジュール名で文字列またはコマンドリテラルを修飾することが可能です。たとえば、 &lt;code&gt;Foo&lt;/code&gt; と &lt;code&gt;Bar&lt;/code&gt; の両方が非標準の文字列リテラル &lt;code&gt;@x_str&lt;/code&gt; を提供する場合、 &lt;code&gt;Foo.x&quot;literal&quot;&lt;/code&gt; または &lt;code&gt;Bar.x&quot;literal&quot;&lt;/code&gt; を記述して、2つを区別できます。</target>
        </trans-unit>
        <trans-unit id="9a888754236863b7dc502d80ea92bd70226cbd16" translate="yes" xml:space="preserve">
          <source>In the example above, the code between &lt;code&gt;#=&lt;/code&gt; and &lt;code&gt;=#&lt;/code&gt; is run as a &lt;code&gt;bash&lt;/code&gt; script. Julia ignores this part since it is a multi-line comment for Julia. The Julia code after &lt;code&gt;=#&lt;/code&gt; is ignored by &lt;code&gt;bash&lt;/code&gt; since it stops parsing the file once it reaches to the &lt;code&gt;exec&lt;/code&gt; statement.</source>
          <target state="translated">上記の例では、 &lt;code&gt;#=&lt;/code&gt; と &lt;code&gt;=#&lt;/code&gt; の間のコードは &lt;code&gt;bash&lt;/code&gt; スクリプトとして実行されます。Juliaは複数行のコメントであるため、Juliaはこの部分を無視します。 &lt;code&gt;=#&lt;/code&gt; の後のJuliaコードは、 &lt;code&gt;exec&lt;/code&gt; ステートメントに到達するとファイルの解析を停止するため、 &lt;code&gt;bash&lt;/code&gt; によって無視されます。</target>
        </trans-unit>
        <trans-unit id="7fab8ccf3e309196934d3171621e67c5c348c19f" translate="yes" xml:space="preserve">
          <source>In the example below the in-range check for referencing element &lt;code&gt;i&lt;/code&gt; of array &lt;code&gt;A&lt;/code&gt; is skipped to improve performance.</source>
          <target state="translated">以下の例では、パフォーマンスを向上させるために、配列 &lt;code&gt;A&lt;/code&gt; の要素 &lt;code&gt;i&lt;/code&gt; を参照するための範囲内チェックはスキップされます。</target>
        </trans-unit>
        <trans-unit id="93579590b1d00912366971a9f1eaa55dfd5a9050" translate="yes" xml:space="preserve">
          <source>In the example manifest file above, to find the path of the first &lt;code&gt;Priv&lt;/code&gt; package&amp;mdash;the one with UUID &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt;&amp;mdash;Julia looks for its stanza in the manifest file, sees that it has a &lt;code&gt;path&lt;/code&gt; entry, looks at &lt;code&gt;deps/Priv&lt;/code&gt; relative to the &lt;code&gt;App&lt;/code&gt; project directory&amp;mdash;let's suppose the &lt;code&gt;App&lt;/code&gt; code lives in &lt;code&gt;/home/me/projects/App&lt;/code&gt;&amp;mdash;sees that &lt;code&gt;/home/me/projects/App/deps/Priv&lt;/code&gt; exists and therefore loads &lt;code&gt;Priv&lt;/code&gt; from there.</source>
          <target state="translated">上記のマニフェストファイルの例では、最初の &lt;code&gt;Priv&lt;/code&gt; パッケージ（UUIDが &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt; のパッケージ）のパスを見つけるために、Juliaがマニフェストファイルでスタンザを探し、 &lt;code&gt;path&lt;/code&gt; エントリがあることを確認します。で &lt;code&gt;deps/Priv&lt;/code&gt; に比べて &lt;code&gt;App&lt;/code&gt; プロジェクトディレクトリ-LETのは、仮定 &lt;code&gt;App&lt;/code&gt; でコード命を &lt;code&gt;/home/me/projects/App&lt;/code&gt; その-sees &lt;code&gt;/home/me/projects/App/deps/Priv&lt;/code&gt; 存在するため、ロード &lt;code&gt;Priv&lt;/code&gt; そこから。</target>
        </trans-unit>
        <trans-unit id="d5f7b0ad7d3e9a880bbfbe0e4c7c117bb4c01b0c" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt;, each &lt;code&gt;I_k&lt;/code&gt; may be a scalar index, an array of scalar indices, or an object that represents an array of scalar indices and can be converted to such by &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt;&lt;code&gt;to_indices&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">式 &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; では、各 &lt;code&gt;I_k&lt;/code&gt; は、スカラーインデックス、スカラーインデックスの配列、またはスカラーインデックスの配列を表すオブジェクトであり、&lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt; &lt;code&gt;to_indices&lt;/code&gt; &lt;/a&gt;によってそれに変換できます。</target>
        </trans-unit>
        <trans-unit id="fa27a03548fec1bfca9a5a7f95888f72d9a7ae58" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt;, the subexpression &lt;code&gt;b&lt;/code&gt; is only evaluated if &lt;code&gt;a&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">式では &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; 、部分式 &lt;code&gt;b&lt;/code&gt; 場合にのみ評価され評価さに &lt;code&gt;true&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bac07dea1e6da71dd93fed592d9cea2988762e4a" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;a || b&lt;/code&gt;, the subexpression &lt;code&gt;b&lt;/code&gt; is only evaluated if &lt;code&gt;a&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;a || b&lt;/code&gt; 、部分式 &lt;code&gt;b&lt;/code&gt; 場合にのみ評価され評価さに &lt;code&gt;false&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96db94e2ee75dc648cf0225c95d894886287a60b" translate="yes" xml:space="preserve">
          <source>In the first example, the return breaks out of &lt;code&gt;test1&lt;/code&gt; as soon as it hits an even number, so &lt;code&gt;test1([5,6,7])&lt;/code&gt; returns &lt;code&gt;12&lt;/code&gt;.</source>
          <target state="translated">最初の例では、戻り値が偶数に &lt;code&gt;test1([5,6,7])&lt;/code&gt; とすぐに &lt;code&gt;test1&lt;/code&gt; から抜け出すため、test1（[5,6,7]）は &lt;code&gt;12&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="3b8c088e43cc4d9778c3e9bd051248b7beb86cd4" translate="yes" xml:space="preserve">
          <source>In the first step, a handle to the Julia function &lt;code&gt;sqrt&lt;/code&gt; is retrieved by calling &lt;code&gt;jl_get_function&lt;/code&gt;. The first argument passed to &lt;code&gt;jl_get_function&lt;/code&gt; is a pointer to the &lt;code&gt;Base&lt;/code&gt; module in which &lt;code&gt;sqrt&lt;/code&gt; is defined. Then, the double value is boxed using &lt;code&gt;jl_box_float64&lt;/code&gt;. Finally, in the last step, the function is called using &lt;code&gt;jl_call1&lt;/code&gt;. &lt;code&gt;jl_call0&lt;/code&gt;, &lt;code&gt;jl_call2&lt;/code&gt;, and &lt;code&gt;jl_call3&lt;/code&gt; functions also exist, to conveniently handle different numbers of arguments. To pass more arguments, use &lt;code&gt;jl_call&lt;/code&gt;:</source>
          <target state="translated">最初のステップでは、 &lt;code&gt;jl_get_function&lt;/code&gt; を呼び出して、Julia関数 &lt;code&gt;sqrt&lt;/code&gt; のハンドルを取得します。 &lt;code&gt;jl_get_function&lt;/code&gt; に渡される最初の引数は、 &lt;code&gt;sqrt&lt;/code&gt; が定義されている &lt;code&gt;Base&lt;/code&gt; モジュールへのポインターです。次に、double値は &lt;code&gt;jl_box_float64&lt;/code&gt; を使用してボックス化されます。最後に、最後のステップで、関数は &lt;code&gt;jl_call1&lt;/code&gt; を使用して呼び出されます。 &lt;code&gt;jl_call0&lt;/code&gt; 、 &lt;code&gt;jl_call2&lt;/code&gt; 、および &lt;code&gt;jl_call3&lt;/code&gt; 関数も存在し、さまざまな数の引数を簡単に処理できます。さらに引数を渡すには、 &lt;code&gt;jl_call&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="7b958da57c917010bf3ef94ad88b96d1969aed7b" translate="yes" xml:space="preserve">
          <source>In the following REPL session:</source>
          <target state="translated">次のREPLセッションでは</target>
        </trans-unit>
        <trans-unit id="c8932c25606bd0610c3cdf0d60756b479ad881b6" translate="yes" xml:space="preserve">
          <source>In the following example we will use both &lt;code&gt;DistributedArrays.jl&lt;/code&gt; and &lt;code&gt;CuArrays.jl&lt;/code&gt; to distribute an array across multiple processes and call a generic function on it.</source>
          <target state="translated">次の例では、 &lt;code&gt;DistributedArrays.jl&lt;/code&gt; と &lt;code&gt;CuArrays.jl&lt;/code&gt; の両方を使用して、配列を複数のプロセスに分散し、その上でジェネリック関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="7ef78cc2f03187abe5d3245512be5e3c871b1647" translate="yes" xml:space="preserve">
          <source>In the following example we will use both &lt;code&gt;DistributedArrays.jl&lt;/code&gt; and &lt;code&gt;CuArrays.jl&lt;/code&gt; to distribute an array across multiple processes by first casting it through &lt;code&gt;distribute()&lt;/code&gt; and &lt;code&gt;CuArray()&lt;/code&gt;.</source>
          <target state="translated">次の例では、 &lt;code&gt;DistributedArrays.jl&lt;/code&gt; と &lt;code&gt;CuArrays.jl&lt;/code&gt; の両方を使用して、最初に &lt;code&gt;distribute()&lt;/code&gt; および &lt;code&gt;CuArray()&lt;/code&gt; でキャストすることにより、複数のプロセスに配列を分散します。</target>
        </trans-unit>
        <trans-unit id="eddb2dbc7e71b5027d64a28a0762a40add354815" translate="yes" xml:space="preserve">
          <source>In the following examples &lt;code&gt;&quot;...&quot;&lt;/code&gt; is used to illustrate an arbitrary docstring.</source>
          <target state="translated">次の例では、 &lt;code&gt;&quot;...&quot;&lt;/code&gt; を使用して任意のdocstringを示しています。</target>
        </trans-unit>
        <trans-unit id="89782f85382fa4913d7651a1e194d5e19db89926" translate="yes" xml:space="preserve">
          <source>In the following sections, we briefly go through a few techniques that can help make your Julia code run as fast as possible.</source>
          <target state="translated">以下のセクションでは、Juliaのコードをできるだけ高速に動作させるためのいくつかのテクニックを簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="04625a717e704769cefecb369eb2164fdede25ee" translate="yes" xml:space="preserve">
          <source>In the former case, the integers are widened to system word size and therefore the result is 128. In the latter case, no such widening happens and integer overflow results in -128.</source>
          <target state="translated">前者の場合、整数はシステムのワードサイズに拡張されているため、結果は 128 となります。後者の場合は、そのような拡張は行われず、整数のオーバーフローの結果は-128となります。</target>
        </trans-unit>
        <trans-unit id="459cd312cf19872b6f89a3fcbc8f7c42d8e4d02e" translate="yes" xml:space="preserve">
          <source>In the last example, a &lt;code&gt;Vector{Any}&lt;/code&gt; is produced; the reason is that &lt;code&gt;eltype(Die) == Any&lt;/code&gt;. The remedy is to define &lt;code&gt;Base.eltype(::Type{Die}) = Int&lt;/code&gt;.</source>
          <target state="translated">最後の例では、 &lt;code&gt;Vector{Any}&lt;/code&gt; が生成されます。その理由は、 &lt;code&gt;eltype(Die) == Any&lt;/code&gt; あるためです。解決策は、 &lt;code&gt;Base.eltype(::Type{Die}) = Int&lt;/code&gt; を定義することです。</target>
        </trans-unit>
        <trans-unit id="1cbf68db8681a41c42664645e9482a6f5917d216" translate="yes" xml:space="preserve">
          <source>In the latter case, the result type is &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; since &lt;code&gt;BigInt&lt;/code&gt; is the only type large enough to hold integers for arbitrary-precision integer arithmetic. Also note that one does not need to define both &lt;code&gt;promote_rule(::Type{A}, ::Type{B})&lt;/code&gt; and &lt;code&gt;promote_rule(::Type{B}, ::Type{A})&lt;/code&gt; &amp;ndash; the symmetry is implied by the way &lt;code&gt;promote_rule&lt;/code&gt; is used in the promotion process.</source>
          <target state="translated">後者の場合、結果の型は&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; に&lt;/a&gt;なります &lt;code&gt;BigInt&lt;/code&gt; は、任意精度の整数演算用の整数を保持するのに十分な大きさを持つ唯一の型だからです。また、 &lt;code&gt;promote_rule(::Type{A}, ::Type{B})&lt;/code&gt; と &lt;code&gt;promote_rule(::Type{B}, ::Type{A})&lt;/code&gt; 両方を定義する必要がないことに注意してください。対称性は、道の &lt;code&gt;promote_rule&lt;/code&gt; は、昇格プロセスで使用されています。</target>
        </trans-unit>
        <trans-unit id="898e17acc6c8cf82e0dc07003deafaedea5b3686" translate="yes" xml:space="preserve">
          <source>In these and other cases, you can get the result you want by choosing an &lt;em&gt;input type&lt;/em&gt; that conveys your willingness to accept an &lt;em&gt;output type&lt;/em&gt; in which the result can be represented:</source>
          <target state="translated">これらのケースやその他のケースでは、結果を表すことができる&lt;em&gt;出力タイプ&lt;/em&gt;を受け入れる意思を伝える&lt;em&gt;入力タイプ&lt;/em&gt;を選択することにより、必要な結果を得ることができます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0181a5895aa6ed6a57ecf3e1abb5400987bdae76" translate="yes" xml:space="preserve">
          <source>In these examples, &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt;, which has two fields. &lt;code&gt;b&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt;, which is a primitive bitstype with no fields at all. &lt;code&gt;ex&lt;/code&gt; is an &lt;a href=&quot;#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt;, which has one field.</source>
          <target state="translated">これらの例では、 &lt;code&gt;a&lt;/code&gt; は2つのフィールドを持つ&lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;です。 &lt;code&gt;b&lt;/code&gt; は &lt;code&gt;Int&lt;/code&gt; であり、フィールドをまったく持たないプリミティブビットタイプです。 &lt;code&gt;ex&lt;/code&gt; は1つのフィールドを持つ&lt;a href=&quot;#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="e95b83474ed0f82b1495ebdd8823b0e63d6666c2" translate="yes" xml:space="preserve">
          <source>In this and all following examples it is assumed that their top-level is a global scope with a clean workspace, for instance a newly started REPL.</source>
          <target state="translated">この例とそれに続くすべての例では、それらのトップレベルがクリーンなワークスペースを持つグローバル・スコープ、例えば新しく起動された REPL であると仮定しています。</target>
        </trans-unit>
        <trans-unit id="ffae775fe01ba274356f2a5f0bbbfa16bf832464" translate="yes" xml:space="preserve">
          <source>In this case &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; MUST be defined in the remote process. Note that &lt;code&gt;A&lt;/code&gt; is a global variable defined in the local workspace. Worker 2 does not have a variable called &lt;code&gt;A&lt;/code&gt; under &lt;code&gt;Main&lt;/code&gt;. The act of shipping the closure &lt;code&gt;()-&amp;gt;sum(A)&lt;/code&gt; to worker 2 results in &lt;code&gt;Main.A&lt;/code&gt; being defined on 2. &lt;code&gt;Main.A&lt;/code&gt; continues to exist on worker 2 even after the call &lt;code&gt;remotecall_fetch&lt;/code&gt; returns. Remote calls with embedded global references (under &lt;code&gt;Main&lt;/code&gt; module only) manage globals as follows:</source>
          <target state="translated">この場合、リモートプロセスで&lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; を&lt;/a&gt;定義する必要があります。 &lt;code&gt;A&lt;/code&gt; はローカルワークスペースで定義されたグローバル変数であることに注意してください。ワーカー2には、 &lt;code&gt;Main&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; 下にAという変数がありません。クロージャを出荷する行為は、 &lt;code&gt;()-&amp;gt;sum(A)&lt;/code&gt; で作業者に2つの結果 &lt;code&gt;Main.A&lt;/code&gt; は 2に定義され &lt;code&gt;Main.A&lt;/code&gt; にも通話後ワーカー2上に存在し続けて &lt;code&gt;remotecall_fetch&lt;/code&gt; に戻ります。グローバルリファレンスが埋め込まれたリモートコール（ &lt;code&gt;Main&lt;/code&gt; モジュールのみ）は、次のようにグローバルを管理します。</target>
        </trans-unit>
        <trans-unit id="0560676ee24f0b0b03f58f97d95e6f878eed22df" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;Vector{Any}(undef, n)&lt;/code&gt; is better. It is also more helpful to the compiler to annotate specific uses (e.g. &lt;code&gt;a[i]::Int&lt;/code&gt;) than to try to pack many alternatives into one type.</source>
          <target state="translated">この場合、 &lt;code&gt;Vector{Any}(undef, n)&lt;/code&gt; 方が適しています。また、多くの選択肢を1つの型に &lt;code&gt;a[i]::Int&lt;/code&gt; うとするよりも、コンパイラーが特定の用途（例：a [i] :: Int）に注釈を付ける方が便利です。</target>
        </trans-unit>
        <trans-unit id="e89af6907bd5ca30fed3e340c7ce252f260cfa01" translate="yes" xml:space="preserve">
          <source>In this case a tuple of values is spliced into a varargs call precisely where the variable number of arguments go. This need not be the case, however:</source>
          <target state="translated">この場合、値のタプルは可変数の引数がどこに行くのかを正確にvarargs呼び出しに接続されています。しかし、これはそうである必要はありません。</target>
        </trans-unit>
        <trans-unit id="567cd07e5f348036853e90930a72f1f415e7cf4a" translate="yes" xml:space="preserve">
          <source>In this case the final (empty) line before the closing &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; sets the indentation level.</source>
          <target state="translated">この場合、 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 閉じる前の最後の（空の）行がインデントレベルを設定します。</target>
        </trans-unit>
        <trans-unit id="192b075c1bd1fea405ec3cb3c290131367b6aebf" translate="yes" xml:space="preserve">
          <source>In this case, if we try to split up the work using a one-dimensional index, we are likely to run into trouble: if &lt;code&gt;q[i,j,t]&lt;/code&gt; is near the end of the block assigned to one worker and &lt;code&gt;q[i,j,t+1]&lt;/code&gt; is near the beginning of the block assigned to another, it's very likely that &lt;code&gt;q[i,j,t]&lt;/code&gt; will not be ready at the time it's needed for computing &lt;code&gt;q[i,j,t+1]&lt;/code&gt;. In such cases, one is better off chunking the array manually. Let's split along the second dimension. Define a function that returns the &lt;code&gt;(irange, jrange)&lt;/code&gt; indices assigned to this worker:</source>
          <target state="translated">この場合、1次元のインデックスを使用して作業を分割しようとすると、問題が発生する可能性があります &lt;code&gt;q[i,j,t]&lt;/code&gt; が1つのワーカーに割り当てられたブロックの終わり近くにあり、 &lt;code&gt;q[i,j,t+1]&lt;/code&gt; は、別のブロックに割り当てられたブロックの先頭近くにあります &lt;code&gt;q[i,j,t]&lt;/code&gt; は &lt;code&gt;q[i,j,t+1]&lt;/code&gt; 計算に必要なときに準備ができていない可能性が高いです。1]。そのような場合は、手動でアレイをチャンクする方が適切です。 2番目の次元に沿って分割しましょう。このワーカーに割り当てられた &lt;code&gt;(irange, jrange)&lt;/code&gt; インデックスを返す関数を定義します。</target>
        </trans-unit>
        <trans-unit id="b26744f8a00507231770f287451074d8e90f3846" translate="yes" xml:space="preserve">
          <source>In this case, the character &lt;code&gt;&amp;forall;&lt;/code&gt; is a three-byte character, so the indices 2 and 3 are invalid and the next character's index is 4; this next valid index can be computed by &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt;&lt;code&gt;nextind(s,1)&lt;/code&gt;&lt;/a&gt;, and the next index after that by &lt;code&gt;nextind(s,4)&lt;/code&gt; and so on.</source>
          <target state="translated">この場合、文字 &lt;code&gt;&amp;forall;&lt;/code&gt; は3バイト文字であるため、インデックス2および3は無効であり、次の文字のインデックスは4です。この次の有効なインデックスは&lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt; &lt;code&gt;nextind(s,1)&lt;/code&gt; &lt;/a&gt;で計算でき、その後の次のインデックスは &lt;code&gt;nextind(s,4)&lt;/code&gt; などで計算できます。</target>
        </trans-unit>
        <trans-unit id="e5db3b629f524d1fec7f4ffc91f2ae6bde25d1db" translate="yes" xml:space="preserve">
          <source>In this case, the speedup due to &lt;code&gt;@fastmath&lt;/code&gt; is a factor of about 3.7. This is unusually large &amp;ndash; in general, the speedup will be smaller. (In this particular example, the working set of the benchmark is small enough to fit into the L1 cache of the processor, so that memory access latency does not play a role, and computing time is dominated by CPU usage. In many real world programs this is not the case.) Also, in this case this optimization does not change the result &amp;ndash; in general, the result will be slightly different. In some cases, especially for numerically unstable algorithms, the result can be very different.</source>
          <target state="translated">この場合、 &lt;code&gt;@fastmath&lt;/code&gt; によるスピードアップは約3.7倍です。これは異常に大きい&amp;ndash;一般に、スピードアップは小さくなります。 （この特定の例では、ベンチマークのワーキングセットはプロセッサのL1キャッシュに収まるほど小さいので、メモリアクセスのレイテンシは役割を果たさず、計算時間はCPU使用率によって支配されます。多くの実際のプログラムではこれは当てはまりません。）また、この場合、この最適化によって結果が変わることはありません。通常、結果は少し異なります。場合によっては、特に数値的に不安定なアルゴリズムの場合、結果が大きく異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="6188940203c290544c44a0f6a7e7493e9e0ab89b" translate="yes" xml:space="preserve">
          <source>In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the MPI standards committee introduced a new set of communication mechanisms, collectively referred to as Remote Memory Access (RMA). The motivation for adding rma to the MPI standard was to facilitate one-sided communication patterns. For additional information on the latest MPI standard, see &lt;a href=&quot;https://mpi-forum.org/docs&quot;&gt;https://mpi-forum.org/docs&lt;/a&gt;.</source>
          <target state="translated">この文脈では、MPIはMPI-1標準を指します。 MPI-2から、MPI標準委員会は、リモートメモリアクセス（RMA）と総称される一連の新しい通信メカニズムを導入しました。 MPI標準にrmaを追加する動機は、片側通信パターンを容易にすることでした。最新のMPI標準の詳細については、&lt;a href=&quot;https://mpi-forum.org/docs&quot;&gt;https：//mpi-forum.org/docsを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="92a7a3f559dc2f0e3123bf1d2da5d1162f830e7c" translate="yes" xml:space="preserve">
          <source>In this example it is accomplished by defining &lt;code&gt;Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)&lt;/code&gt; to create the appropriate wrapped array. (Note that while &lt;code&gt;similar&lt;/code&gt; supports 1- and 2-argument forms, in most case you only need to specialize the 3-argument form.) For this to work it's important that &lt;code&gt;SparseArray&lt;/code&gt; is mutable (supports &lt;code&gt;setindex!&lt;/code&gt;). Defining &lt;code&gt;similar&lt;/code&gt;, &lt;code&gt;getindex&lt;/code&gt; and &lt;code&gt;setindex!&lt;/code&gt; for &lt;code&gt;SparseArray&lt;/code&gt; also makes it possible to &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; the array:</source>
          <target state="translated">この例では、適切なラップされた配列を作成するために &lt;code&gt;Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)&lt;/code&gt; を定義することで実現されます。 （ &lt;code&gt;similar&lt;/code&gt; は1引数フォームと2引数フォームをサポートしますが、ほとんどの場合、3引数フォームを特殊化するだけでよいことに注意してください。）これを機能させるには、 &lt;code&gt;SparseArray&lt;/code&gt; が変更可能であることが重要です（ &lt;code&gt;setindex!&lt;/code&gt; をサポートしています）。 &lt;code&gt;similar&lt;/code&gt; 、 &lt;code&gt;getindex&lt;/code&gt; およびsetindexの定義 &lt;code&gt;setindex!&lt;/code&gt; 以下のため &lt;code&gt;SparseArray&lt;/code&gt; もすることが可能となり&lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;の配列を：</target>
        </trans-unit>
        <trans-unit id="05a24eb92f7d5686dff145712d9c9981f290a66e" translate="yes" xml:space="preserve">
          <source>In this example the root cause exception (A) is first on the stack, with a further exception (B) following it. After exiting both catch blocks normally (i.e., without throwing a further exception) all exceptions are removed from the stack and are no longer accessible.</source>
          <target state="translated">この例では、根本原因の例外 (A)が最初にスタック上に置かれ、それに続いてさらに例外 (B)が置かれます。両方のキャッチブロックを正常に終了した後 (つまり、さらなる例外を投げずに)、すべての例外はスタックから削除され、アクセスできなくなります。</target>
        </trans-unit>
        <trans-unit id="4336cae1e8edd1087fd9411fb166bd6a222c2c06" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;A&lt;/code&gt; is a mutable container that contains one element, which can be set by &lt;code&gt;A[] = 1.0&lt;/code&gt; and retrieved with &lt;code&gt;A[]&lt;/code&gt;. All zero-dimensional arrays have the same size (&lt;code&gt;size(A) == ()&lt;/code&gt;), and length (&lt;code&gt;length(A) == 1&lt;/code&gt;). In particular, zero-dimensional arrays are not empty. If you find this unintuitive, here are some ideas that might help to understand Julia's definition.</source>
          <target state="translated">この例では、 &lt;code&gt;A&lt;/code&gt; は、で設定することができる一つの要素、含有変更可能な容器である &lt;code&gt;A[] = 1.0&lt;/code&gt; として検索された &lt;code&gt;A[]&lt;/code&gt; 。すべてのゼロ次元配列は同じサイズ（ &lt;code&gt;size(A) == ()&lt;/code&gt; ）、および長さ（ &lt;code&gt;length(A) == 1&lt;/code&gt; ）を持っています。特に、ゼロ次元配列は空ではありません。これが直感的でない場合は、ジュリアの定義を理解するのに役立つ可能性があるいくつかのアイデアを次に示します。</target>
        </trans-unit>
        <trans-unit id="6a0bf2dc540c812cb1923adeb5876321d55dbf26" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;N&lt;/code&gt; is passed as a parameter, so its &quot;value&quot; is known to the compiler. Essentially, &lt;code&gt;Val(T)&lt;/code&gt; works only when &lt;code&gt;T&lt;/code&gt; is either hard-coded/literal (&lt;code&gt;Val(3)&lt;/code&gt;) or already specified in the type-domain.</source>
          <target state="translated">この例では、 &lt;code&gt;N&lt;/code&gt; がパラメーターとして渡されるため、その「値」はコンパイラーに認識されます。基本的に、 &lt;code&gt;Val(T)&lt;/code&gt; は、 &lt;code&gt;T&lt;/code&gt; がハードコード/リテラル​​（ &lt;code&gt;Val(3)&lt;/code&gt; ）であるか、type-domainで既に指定されている場合にのみ機能します。</target>
        </trans-unit>
        <trans-unit id="92f4b81b4c3f20308317f94d5766f434fb02e58c" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;b&lt;/code&gt; is a runnable &lt;code&gt;Task&lt;/code&gt; that hasn't started yet.</source>
          <target state="translated">この例では、 &lt;code&gt;b&lt;/code&gt; はまだ開始されていない実行可能な &lt;code&gt;Task&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="9f7bc1ef4d38fd2e360681f2040c8ad0f73774eb" translate="yes" xml:space="preserve">
          <source>In this example, observe that the new definition for &lt;code&gt;newfun&lt;/code&gt; has been created, but can't be immediately called. The new global is immediately visible to the &lt;code&gt;tryeval&lt;/code&gt; function, so you could write &lt;code&gt;return newfun&lt;/code&gt; (without parentheses). But neither you, nor any of your callers, nor the functions they call, or etc. can call this new method definition!</source>
          <target state="translated">この例では、 &lt;code&gt;newfun&lt;/code&gt; の新しい定義が作成されていますが、すぐに呼び出すことができないことに注意してください。新しいグローバルは、 &lt;code&gt;tryeval&lt;/code&gt; 関数にすぐに表示されるため、 &lt;code&gt;return newfun&lt;/code&gt; （括弧なし）を記述できます。しかし、あなたもあなたの呼び出し元も、彼らが呼び出す関数なども、この新しいメソッド定義を呼び出すことはできません！</target>
        </trans-unit>
        <trans-unit id="f0f0d16b1aed858c0d51da9625d8755a2c35d48e" translate="yes" xml:space="preserve">
          <source>In this example, the remote which is being fetched from &lt;em&gt;does&lt;/em&gt; have a file called &lt;code&gt;our_file&lt;/code&gt; in its index, which is why we must reset.</source>
          <target state="translated">この例では、からフェッチされている遠隔は&lt;em&gt;ない&lt;/em&gt;というファイル持って &lt;code&gt;our_file&lt;/code&gt; 我々はリセットしなければならない理由でそのインデックスには、。</target>
        </trans-unit>
        <trans-unit id="a138591f083f547736d80bd3d40dd03ced901f2b" translate="yes" xml:space="preserve">
          <source>In this example, the task ran on pid 2, called from pid 1.</source>
          <target state="translated">この例では、タスクは pid 2 で実行され、pid 1 から呼び出されました。</target>
        </trans-unit>
        <trans-unit id="f39c0221e85d683a6f4024da4ca9271cf6b8c812" translate="yes" xml:space="preserve">
          <source>In this example, the tuple &lt;code&gt;(1,2,3)&lt;/code&gt; is interpolated as an expression into a conditional test:</source>
          <target state="translated">この例では、タプル &lt;code&gt;(1,2,3)&lt;/code&gt; が式として条件テストに挿入されます。</target>
        </trans-unit>
        <trans-unit id="a8e780cf12ef36b63b08a74c8c07d0b380150440" translate="yes" xml:space="preserve">
          <source>In this example, the value of variable &lt;code&gt;a&lt;/code&gt; is interpolated:</source>
          <target state="translated">この例では、変数 &lt;code&gt;a&lt;/code&gt; の値が補間されます。</target>
        </trans-unit>
        <trans-unit id="d77924d6298476fc4b219142016e1167310fe63c" translate="yes" xml:space="preserve">
          <source>In this example, we can see that the top level function called is in the file &lt;code&gt;event.jl&lt;/code&gt;. This is the function that runs the REPL when you launch Julia. If you examine line 97 of &lt;code&gt;REPL.jl&lt;/code&gt;, you'll see this is where the function &lt;code&gt;eval_user_input()&lt;/code&gt; is called. This is the function that evaluates what you type at the REPL, and since we're working interactively these functions were invoked when we entered &lt;code&gt;@profile myfunc()&lt;/code&gt;. The next line reflects actions taken in the &lt;a href=&quot;../../stdlib/profile/index#Profile.@profile&quot;&gt;&lt;code&gt;@profile&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">この例では、呼び出されたトップレベルの関数が &lt;code&gt;event.jl&lt;/code&gt; ファイルにあることがわかります。これは、Juliaを起動したときにREPLを実行する関数です。 &lt;code&gt;REPL.jl&lt;/code&gt; の 97行目を調べると、ここで関数 &lt;code&gt;eval_user_input()&lt;/code&gt; が呼び出されています。これは、REPLでの入力内容を評価する関数です。インタラクティブに作業しているため、これらの関数は &lt;code&gt;@profile myfunc()&lt;/code&gt; に入ったときに呼び出されました。次の行は、&lt;a href=&quot;../../stdlib/profile/index#Profile.@profile&quot;&gt; &lt;code&gt;@profile&lt;/code&gt; &lt;/a&gt;マクロで実行されたアクションを反映しています。</target>
        </trans-unit>
        <trans-unit id="4c91076ff3785f6e6c7acf1c7077368cdbb7151f" translate="yes" xml:space="preserve">
          <source>In this manner, Julia acts as its own &lt;a href=&quot;https://en.wikipedia.org/wiki/Preprocessor&quot;&gt;preprocessor&lt;/a&gt;, and allows code generation from inside the language. The above code could be written slightly more tersely using the &lt;code&gt;:&lt;/code&gt; prefix quoting form:</source>
          <target state="translated">このようにして、Juliaは独自の&lt;a href=&quot;https://en.wikipedia.org/wiki/Preprocessor&quot;&gt;プリプロセッサ&lt;/a&gt;として機能し、言語内からコードを生成できます。上記のコードは、 &lt;code&gt;:&lt;/code&gt; 接頭辞の引用形式を使用して少し簡潔に書くことができます。</target>
        </trans-unit>
        <trans-unit id="7bd6fc4b177020a8a663dcee2fb9c4c397754164" translate="yes" xml:space="preserve">
          <source>In this module we export the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; functions (with the keyword &lt;code&gt;export&lt;/code&gt;), and also have the non-exported function &lt;code&gt;p&lt;/code&gt;. There are several different ways to load the Module and its inner functions into the current workspace:</source>
          <target state="translated">このモジュールでは、 &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; 関数をエクスポートし（キーワード &lt;code&gt;export&lt;/code&gt; を使用）、エクスポートされていない関数 &lt;code&gt;p&lt;/code&gt; も使用します。モジュールとその内部関数を現在のワークスペースにロードするには、いくつかの方法があります。</target>
        </trans-unit>
        <trans-unit id="81fa363c46c4da719440f0a895d038cea7c0f22d" translate="yes" xml:space="preserve">
          <source>In this situation, use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to skip missing values</source>
          <target state="translated">この状況では、&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;関数を使用して欠損値をスキップします</target>
        </trans-unit>
        <trans-unit id="9db9e9e3387eacd52cbab3963439723e71f36736" translate="yes" xml:space="preserve">
          <source>In this style of definition, the code generation feature is essentially an optional optimization. The compiler will use it if convenient, but otherwise may choose to use the normal implementation instead. This style is preferred, since it allows the compiler to make more decisions and compile programs in more ways, and since normal code is more readable than code-generating code. However, which implementation is used depends on compiler implementation details, so it is essential for the two implementations to behave identically.</source>
          <target state="translated">このスタイルの定義では、コード生成機能は基本的にオプションの最適化です。コンパイラは便利な場合はこれを使用しますが、そうでない場合は通常の実装を使用することを選択することができます。このスタイルが好ましいのは、コンパイラがより多くの判断を下し、より多くの方法でプログラムをコンパイルできるようになることと、通常のコードの方がコード生成コードよりも読みやすいからです。しかし、どちらの実装を使用するかはコンパイラの実装の詳細に依存するので、2つの実装が同じように動作することが不可欠です。</target>
        </trans-unit>
        <trans-unit id="2472bd128ff5a0c2f02732fc91d35900b7540e31" translate="yes" xml:space="preserve">
          <source>In this toy example, the two methods are easy to distinguish and choose from. However, in a real program designing data movement might require more thought and likely some measurement. For example, if the first process needs matrix &lt;code&gt;A&lt;/code&gt; then the first method might be better. Or, if computing &lt;code&gt;A&lt;/code&gt; is expensive and only the current process has it, then moving it to another process might be unavoidable. Or, if the current process has very little to do between the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fetch(Bref)&lt;/code&gt;, it might be better to eliminate the parallelism altogether. Or imagine &lt;code&gt;rand(1000,1000)&lt;/code&gt; is replaced with a more expensive operation. Then it might make sense to add another &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; statement just for this step.</source>
          <target state="translated">このおもちゃの例では、2つの方法を簡単に区別して選択できます。ただし、実際のプログラムでは、データの移動を設計するために、より多くの検討が必要で、測定が必要になる可能性があります。たとえば、最初のプロセスが行列 &lt;code&gt;A&lt;/code&gt; を必要とする場合、最初の方法の方が良いかもしれません。または、 &lt;code&gt;A&lt;/code&gt; の計算にコストがかかり、現在のプロセスだけがそれを持っている場合、それを別のプロセスに移動することは避けられないかもしれません。または、現在のプロセスで&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;fetch(Bref)&lt;/code&gt; Bref）の間の処理がほとんどない場合は、並列処理を完全に排除することをお勧めします。または、 &lt;code&gt;rand(1000,1000)&lt;/code&gt; がより高価な演算に置き換えられることを想像してください。次に、このステップのためだけに別の&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt;ステートメントを追加することは意味があります。</target>
        </trans-unit>
        <trans-unit id="cf538f8e56ca0f93d90636a083c95bfe08cc9992" translate="yes" xml:space="preserve">
          <source>In this way a mesh network is established, wherein every worker is directly connected with every other worker.</source>
          <target state="translated">このようにして、すべてのワーカーが他のすべてのワーカーと直接接続されるメッシュネットワークが確立されます。</target>
        </trans-unit>
        <trans-unit id="77e752e41de1e6877a1adbe41bf7b76e4f16d104" translate="yes" xml:space="preserve">
          <source>In-memory representation of a file entry in the index. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_index_entry&quot;&gt;&lt;code&gt;git_index_entry&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">インデックス内のファイルエントリのメモリ内表現。&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_index_entry&quot;&gt; &lt;code&gt;git_index_entry&lt;/code&gt; &lt;/a&gt;構造体と一致します。</target>
        </trans-unit>
        <trans-unit id="06c7aeba98a0f145bac3596871ee20c6209a6fe5" translate="yes" xml:space="preserve">
          <source>In-place broadcasting can be supported by defining the appropriate &lt;code&gt;copyto!(dest, bc::Broadcasted)&lt;/code&gt; method. Because you might want to specialize either on &lt;code&gt;dest&lt;/code&gt; or the specific subtype of &lt;code&gt;bc&lt;/code&gt;, to avoid ambiguities between packages we recommend the following convention.</source>
          <target state="translated">インプレースブロードキャストは、適切な &lt;code&gt;copyto!(dest, bc::Broadcasted)&lt;/code&gt; メソッドを定義することでサポートできます。 &lt;code&gt;dest&lt;/code&gt; または &lt;code&gt;bc&lt;/code&gt; の特定のサブタイプに特化したい場合があるため、パッケージ間のあいまいさを回避するために、次の規則をお勧めします。</target>
        </trans-unit>
        <trans-unit id="bc665a97127feb38e6b15a0be58c4193afb4afe7" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;a href=&quot;#Random.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt;: randomly permute &lt;code&gt;v&lt;/code&gt; in-place, optionally supplying the random-number generator &lt;code&gt;rng&lt;/code&gt;.</source>
          <target state="translated">インプレースバージョンの&lt;a href=&quot;#Random.shuffle&quot;&gt; &lt;code&gt;shuffle&lt;/code&gt; &lt;/a&gt;：ランダムに &lt;code&gt;v&lt;/code&gt; インプレースを並べ替え、オプションで乱数ジェネレーター &lt;code&gt;rng&lt;/code&gt; を提供します。</target>
        </trans-unit>
        <trans-unit id="ceae787569f3577706adf60b6b428b09067c76dc" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;code&gt;reverse&lt;/code&gt;.</source>
          <target state="translated">インプレースバージョンの &lt;code&gt;reverse&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d77496985aa0ae694adc6f64d73e36e7d090fe55" translate="yes" xml:space="preserve">
          <source>Inbox Tray</source>
          <target state="translated">受信トレイ</target>
        </trans-unit>
        <trans-unit id="973cab0f46e932b28084ce2f784990fa4e35559b" translate="yes" xml:space="preserve">
          <source>Include a single one-line sentence describing what the function does or what the object represents after the simplified signature block. If needed, provide more details in a second paragraph, after a blank line.</source>
          <target state="translated">簡略化された署名ブロックの後に、関数が何をするのか、またはオブジェクトが何を表すのかを1行で記述してください。必要に応じて、空行の後の2段落目に詳細を記述してください。</target>
        </trans-unit>
        <trans-unit id="7962fdf356cdba272a5b5a5a58199f8e50948161" translate="yes" xml:space="preserve">
          <source>Include any code examples in an &lt;code&gt;# Examples&lt;/code&gt; section.</source>
          <target state="translated">&lt;code&gt;# Examples&lt;/code&gt; サンプルセクションにコード例を含めます。</target>
        </trans-unit>
        <trans-unit id="66cb3917171f2315e55b05172cef1568516a6218" translate="yes" xml:space="preserve">
          <source>Including the same code in different modules provides mixin-like behavior. One could use this to run the same code with different base definitions, for example testing code by running it with &quot;safe&quot; versions of some operators:</source>
          <target state="translated">異なるモジュールに同じコードを含めることで、ミックスインのような動作が可能になります。これを利用して、同じコードを異なるベース定義で実行することができます。例えば、いくつかの演算子の &quot;安全な &quot;バージョンで実行してコードをテストすることができます。</target>
        </trans-unit>
        <trans-unit id="3677c6602caed5b57fccc20b31958c9939eb0f57" translate="yes" xml:space="preserve">
          <source>Incoming Envelope</source>
          <target state="translated">着信用封筒</target>
        </trans-unit>
        <trans-unit id="1cebd71683222b1c7af41849d615c19b10f8b1ef" translate="yes" xml:space="preserve">
          <source>Incomplete Initialization</source>
          <target state="translated">不完全な初期化</target>
        </trans-unit>
        <trans-unit id="700503508878aea14fc71ea0dd89adddb349e058" translate="yes" xml:space="preserve">
          <source>Increases As</source>
          <target state="translated">として増加します。</target>
        </trans-unit>
        <trans-unit id="d12f1fabbb58a9af82666365bdf1d6e784f1a197" translate="yes" xml:space="preserve">
          <source>Increment</source>
          <target state="translated">Increment</target>
        </trans-unit>
        <trans-unit id="81769cec07065990cf97fe9de01e67d1dff5a01a" translate="yes" xml:space="preserve">
          <source>Incremental history search, described above</source>
          <target state="translated">前述のインクリメンタル履歴検索</target>
        </trans-unit>
        <trans-unit id="7777e9a1cc822589b38fa2cf3b16ff5bb4405461" translate="yes" xml:space="preserve">
          <source>IndexCartesian</source>
          <target state="translated">IndexCartesian</target>
        </trans-unit>
        <trans-unit id="0ad6144c812efd669c1e0522b10d3e8d01b0818e" translate="yes" xml:space="preserve">
          <source>IndexLinear</source>
          <target state="translated">IndexLinear</target>
        </trans-unit>
        <trans-unit id="5c7d3a57514b6cbb8c7494df1aa031252a9240c0" translate="yes" xml:space="preserve">
          <source>IndexStyle</source>
          <target state="translated">IndexStyle</target>
        </trans-unit>
        <trans-unit id="8b48578d3b12e1d393eb06b8ea5bee4e6f0ec92a" translate="yes" xml:space="preserve">
          <source>Indexable Collections</source>
          <target state="translated">インデックス可能なコレクション</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="0795ddb093e3d5dd1a985acb78a5e1baf2eef779" translate="yes" xml:space="preserve">
          <source>Indexing and assignment</source>
          <target state="translated">インデックスの作成と割り当て</target>
        </trans-unit>
        <trans-unit id="4274ea6199202594d8373033384d6bdb729f3196" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the insertion sort algorithm. Insertion sort traverses the collection one element at a time, inserting each element into its correct, sorted position in the output list.</source>
          <target state="translated">ソート関数が挿入ソートアルゴリズムを使用することを示します。挿入ソートは、コレクションを一度に1つの要素ずつ走査し、各要素を出力リストの正しいソートされた位置に挿入します。</target>
        </trans-unit>
        <trans-unit id="1a127225335e9d3a07a6be83a0e208ad31b15ede" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the merge sort algorithm. Merge sort divides the collection into subcollections and repeatedly merges them, sorting each subcollection at each step, until the entire collection has been recombined in sorted form.</source>
          <target state="translated">ソート関数がマージソートアルゴリズムを使用することを示します。マージソートは、コレクションをサブコレクションに分割し、各ステップで各サブコレクションをソートしながら、コレクション全体がソートされた形で再結合されるまで、それらを繰り返しマージします。</target>
        </trans-unit>
        <trans-unit id="f0d9438aae14ca6f51f78f417b7df01df9f079a5" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the partial quick sort algorithm. Partial quick sort returns the smallest &lt;code&gt;k&lt;/code&gt; elements sorted from smallest to largest, finding them and sorting them using &lt;a href=&quot;#Base.Sort.QuickSort&quot;&gt;&lt;code&gt;QuickSort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ソート関数が部分クイックソートアルゴリズムを使用することを示します。部分的なクイックソートは、最小から最大にソートされた最小の &lt;code&gt;k&lt;/code&gt; 要素を返し、それらを見つけて&lt;a href=&quot;#Base.Sort.QuickSort&quot;&gt; &lt;code&gt;QuickSort&lt;/code&gt; &lt;/a&gt;を使用してソートします。</target>
        </trans-unit>
        <trans-unit id="d5c75327b4e50aced7a786e9b2e8496c590cde6e" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the quick sort algorithm, which is &lt;em&gt;not&lt;/em&gt; stable.</source>
          <target state="translated">ソート関数が&lt;em&gt;、&lt;/em&gt;安定して&lt;em&gt;いない&lt;/em&gt;クイックソートアルゴリズムを使用する必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="a54eb733590aa2b40370b6fb359ea865b8d99e9b" translate="yes" xml:space="preserve">
          <source>Indicate whether &lt;code&gt;x&lt;/code&gt; is &lt;a href=&quot;#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; が&lt;a href=&quot;#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;いるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="efe98c42fb3d546aaef0cbe63f84a3ed426eef2d" translate="yes" xml:space="preserve">
          <source>Indicates a test that should pass but currently consistently fails. Tests that the expression &lt;code&gt;ex&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt; or causes an exception. Returns a &lt;code&gt;Broken&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if it does, or an &lt;code&gt;Error&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if the expression evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">合格する必要があるが現在は一貫して失敗するテストを示します。式 &lt;code&gt;ex&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; と評価されるか、例外が発生することをテストします。そうである場合は &lt;code&gt;Broken&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; 返し、式が &lt;code&gt;true&lt;/code&gt; と評価された場合は &lt;code&gt;Error&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="f58aeaea39a890601871a48e22cb88bfcd1c627a" translate="yes" xml:space="preserve">
          <source>Indicates problematic exit status of a process. When running commands or pipelines, this is thrown to indicate a nonzero exit code was returned (i.e. that the invoked process failed).</source>
          <target state="translated">プロセスの終了状態に問題があることを示します。コマンドやパイプラインを実行している場合、これはゼロではない終了コードが返されたことを示すためにスローされます (つまり、呼び出されたプロセスが失敗したことを示しています)。</target>
        </trans-unit>
        <trans-unit id="ff3a5eaf7321b1b596df1bcd003dbd2f9fcf89b1" translate="yes" xml:space="preserve">
          <source>Indices are of the same type as those returned by &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys(A)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs(A)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">インデックスは、&lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys(A)&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs(A)&lt;/code&gt; &lt;/a&gt;によって返されるものと同じタイプです。</target>
        </trans-unit>
        <trans-unit id="f9e9b57819d8a4759652850ab76b4d97192200f0" translate="yes" xml:space="preserve">
          <source>Indices may be omitted if the trailing dimensions that are not indexed into are all length one. In other words, trailing indices can be omitted only if there is only one possible value that those omitted indices could be for an in-bounds indexing expression. For example, a four-dimensional array with size &lt;code&gt;(3, 4, 2, 1)&lt;/code&gt; may be indexed with only three indices as the dimension that gets skipped (the fourth dimension) has length one. Note that linear indexing takes precedence over this rule.</source>
          <target state="translated">インデックスが付けられていない後続ディメンションがすべて長さ1である場合、インデックスは省略できます。言い換えると、後続のインデックスは、インバウンドインデックス式で省略可能なインデックスが可能な値が1つしかない場合にのみ省略できます。たとえば、サイズが &lt;code&gt;(3, 4, 2, 1)&lt;/code&gt; 3、4、2、1 ）の4次元配列は、スキップされる次元（4番目の次元）の長さが1であるため、3つのインデックスだけでインデックスを作成できます。線形インデックスはこのルールよりも優先されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a9eddea567bcc33c91213abd188cec156d2bbedc" translate="yes" xml:space="preserve">
          <source>Indices or keys are of the same type as those returned by &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys(A)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs(A)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">インデックスまたはキーは、&lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys(A)&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs(A)&lt;/code&gt; &lt;/a&gt;によって返されるものと同じタイプです。</target>
        </trans-unit>
        <trans-unit id="3e37e52d9d94ec6a75ede0c2186d1f73dd06e01f" translate="yes" xml:space="preserve">
          <source>Indirect Calls</source>
          <target state="translated">間接電話</target>
        </trans-unit>
        <trans-unit id="8b89285e1320e669387b56f7e30bddb1aefce498" translate="yes" xml:space="preserve">
          <source>Individual pointers returned by &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt; can be translated into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt;&lt;code&gt;StackTraces.StackFrame&lt;/code&gt;&lt;/a&gt; s by passing them into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.lookup&quot;&gt;&lt;code&gt;StackTraces.lookup&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt;によって返された個々のポインタは、それらを&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.lookup&quot;&gt; &lt;code&gt;StackTraces.lookup&lt;/code&gt; に&lt;/a&gt;渡すことによって&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt; &lt;code&gt;StackTraces.StackFrame&lt;/code&gt; &lt;/a&gt;に変換できます。</target>
        </trans-unit>
        <trans-unit id="f462554871703067824392ec24cc8ae7c200c6ce" translate="yes" xml:space="preserve">
          <source>Inevitably, one wants to write commands that aren't quite so simple, and it becomes necessary to use quotes. Here's a simple example of a Perl one-liner at a shell prompt:</source>
          <target state="translated">必然的に、それほど単純ではないコマンドを書きたくなり、引用符を使う必要が出てきます。ここでは、シェルプロンプトでのPerlのワンライナーの簡単な例を示します。</target>
        </trans-unit>
        <trans-unit id="b24e30d8c474981541dc914b04b492ae2c3460dd" translate="yes" xml:space="preserve">
          <source>Inexact equality comparison: &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;norm(x-y) &amp;lt;= max(atol, rtol*max(norm(x), norm(y)))&lt;/code&gt;. The default &lt;code&gt;atol&lt;/code&gt; is zero and the default &lt;code&gt;rtol&lt;/code&gt; depends on the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The keyword argument &lt;code&gt;nans&lt;/code&gt; determines whether or not NaN values are considered equal (defaults to false).</source>
          <target state="translated">不正確な等値比較： &lt;code&gt;norm(x-y) &amp;lt;= max(atol, rtol*max(norm(x), norm(y)))&lt;/code&gt; 場合は &lt;code&gt;true&lt;/code&gt; 。デフォルトの &lt;code&gt;atol&lt;/code&gt; はゼロで、デフォルトの &lt;code&gt;rtol&lt;/code&gt; は &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; のタイプに依存します。キーワード引数 &lt;code&gt;nans&lt;/code&gt; は、NaN値が等しいと見なされるかどうかを決定します（デフォルトはfalse）。</target>
        </trans-unit>
        <trans-unit id="a1d71ca242908209d7ea479076e7d5102e909486" translate="yes" xml:space="preserve">
          <source>Inf</source>
          <target state="translated">Inf</target>
        </trans-unit>
        <trans-unit id="3b4f77ed6217d60a7fd4f6a9b544f27db8d0b2a2" translate="yes" xml:space="preserve">
          <source>Inf16</source>
          <target state="translated">Inf16</target>
        </trans-unit>
        <trans-unit id="f32fd60229b61d38504c1b80cfc905d76eb231a4" translate="yes" xml:space="preserve">
          <source>Inf32</source>
          <target state="translated">Inf32</target>
        </trans-unit>
        <trans-unit id="13b9b86c9d296608a20ee6add58865dfa6405d7b" translate="yes" xml:space="preserve">
          <source>Inference on the generated function may be run at &lt;em&gt;any&lt;/em&gt; time, including while your code is attempting to observe or mutate this state.</source>
          <target state="translated">生成された関数の推論は、コードがこの状態を観察または変更しようとしている間を含め、&lt;em&gt;いつでも&lt;/em&gt;実行&lt;em&gt;でき&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="0219fd54bd5841008b18c414a5b2dea331bad1c5" translate="yes" xml:space="preserve">
          <source>Infinity</source>
          <target state="translated">Infinity</target>
        </trans-unit>
        <trans-unit id="c7144cf7afebc5115a987ddb86ab81776ccb312f" translate="yes" xml:space="preserve">
          <source>Information Desk Person</source>
          <target state="translated">インフォメーションデスク担当者</target>
        </trans-unit>
        <trans-unit id="ee1bf915e3a7b6dbf22c44b17ef750f99d415033" translate="yes" xml:space="preserve">
          <source>Information Source</source>
          <target state="translated">情報源</target>
        </trans-unit>
        <trans-unit id="1bcf6aaebaf6b2210eb3e22e29d6b1d78dde678a" translate="yes" xml:space="preserve">
          <source>Information about the datatype</source>
          <target state="translated">データ型に関する情報</target>
        </trans-unit>
        <trans-unit id="bc0f7289c05621e36794cb837d6af7d6579a4164" translate="yes" xml:space="preserve">
          <source>Information about the sizes of the array</source>
          <target state="translated">配列のサイズに関する情報</target>
        </trans-unit>
        <trans-unit id="2e1d962528e312390b3433d954b1b586fbe1d39c" translate="yes" xml:space="preserve">
          <source>Initialize &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;x = 1.0&lt;/code&gt;</source>
          <target state="translated">初期化は、 &lt;code&gt;x&lt;/code&gt; はと &lt;code&gt;x = 1.0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d24f12b12b26a182fb25787fca39632feae214b" translate="yes" xml:space="preserve">
          <source>Initialize with the first loop iteration, to &lt;code&gt;x = 1 / rand()&lt;/code&gt;, then loop &lt;code&gt;for i = 2:10&lt;/code&gt;</source>
          <target state="translated">最初のループ反復で初期化し、 &lt;code&gt;x = 1 / rand()&lt;/code&gt; にしてから &lt;code&gt;for i = 2:10&lt;/code&gt; ループします。</target>
        </trans-unit>
        <trans-unit id="e1daf596559638b5a2545966e4511677e06d2d3d" translate="yes" xml:space="preserve">
          <source>Initially &lt;code&gt;f(x)&lt;/code&gt; has one definition</source>
          <target state="translated">最初は &lt;code&gt;f(x)&lt;/code&gt; には1つの定義があります</target>
        </trans-unit>
        <trans-unit id="65a228b7147b9d8893c482dc6a5436ee38235915" translate="yes" xml:space="preserve">
          <source>Inline elements</source>
          <target state="translated">インライン要素</target>
        </trans-unit>
        <trans-unit id="45667ade36979348043d403d58a921b295a413f5" translate="yes" xml:space="preserve">
          <source>Inner Constructor Methods</source>
          <target state="translated">インナーコンストラクタメソッド</target>
        </trans-unit>
        <trans-unit id="5b1b953a0d0fba8d5b16a917eed0d32fa9a3dd01" translate="yes" xml:space="preserve">
          <source>Inner local scopes can, however, update variables in their parent scopes:</source>
          <target state="translated">しかし、内部のローカルスコープでは、親スコープの変数を更新することができます。</target>
        </trans-unit>
        <trans-unit id="8da1f19e44e7c32bb595b50d82bbd6ceb59679ad" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Capital Letters</source>
          <target state="translated">ラテン大文字の入力記号</target>
        </trans-unit>
        <trans-unit id="c3dacb4d5649dfd7003c41b511f2d5e28217bcec" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Letters</source>
          <target state="translated">ラテン文字の入力記号</target>
        </trans-unit>
        <trans-unit id="c56fdb4bd109b10836666b2146d13e58e8c262da" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Small Letters</source>
          <target state="translated">ラテン小文字の入力記号</target>
        </trans-unit>
        <trans-unit id="daa856648c7327c1e747ce6132f831c138ebed2c" translate="yes" xml:space="preserve">
          <source>Input Symbol For Numbers</source>
          <target state="translated">数字の入力記号</target>
        </trans-unit>
        <trans-unit id="393164c17095f31b175cd1b93cce56c3dedbfb1e" translate="yes" xml:space="preserve">
          <source>Input Symbol For Symbols</source>
          <target state="translated">シンボルの入力シンボル</target>
        </trans-unit>
        <trans-unit id="6ac623d9f5d1fbc2e0f23f9accfd989544cd258f" translate="yes" xml:space="preserve">
          <source>Insert a sequential-consistency memory fence</source>
          <target state="translated">シーケンシャル一貫性のあるメモリフェンスを挿入する</target>
        </trans-unit>
        <trans-unit id="811acf3875523c22a2281d416b5b4f8370319cc7" translate="yes" xml:space="preserve">
          <source>Insert an &lt;code&gt;item&lt;/code&gt; into &lt;code&gt;a&lt;/code&gt; at the given &lt;code&gt;index&lt;/code&gt;. &lt;code&gt;index&lt;/code&gt; is the index of &lt;code&gt;item&lt;/code&gt; in the resulting &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">挿入し &lt;code&gt;item&lt;/code&gt; に与えられた時 &lt;code&gt;index&lt;/code&gt; 。 &lt;code&gt;index&lt;/code&gt; は、結果の &lt;code&gt;a&lt;/code&gt; 内の &lt;code&gt;item&lt;/code&gt; のインデックスです。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="559e8d8937fda6b9aa5389a26a8c99a01c1659f4" translate="yes" xml:space="preserve">
          <source>Insert new line without executing it</source>
          <target state="translated">実行せずに改行を挿入</target>
        </trans-unit>
        <trans-unit id="db69c06d74ad468e37833a8eff3cd0b19f6c2cae" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; at the beginning of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;collection&lt;/code&gt; の先頭に1つ以上の &lt;code&gt;items&lt;/code&gt; を挿入します。</target>
        </trans-unit>
        <trans-unit id="e38ad6a771799a9a8891ef79be267ec402e8ceac" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; at the end of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;collection&lt;/code&gt; の最後に1つ以上の &lt;code&gt;items&lt;/code&gt; を挿入します。</target>
        </trans-unit>
        <trans-unit id="af1912a8c6dfd808836326783d91aa44bc473362" translate="yes" xml:space="preserve">
          <source>Insert the elements of &lt;code&gt;items&lt;/code&gt; to the beginning of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">要素を挿入 &lt;code&gt;items&lt;/code&gt; の先頭に。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eec80463f132fabaec00763dec1737d74a5ca8f8" translate="yes" xml:space="preserve">
          <source>Inserts a memory fence with sequentially-consistent ordering semantics. There are algorithms where this is needed, i.e. where an acquire/release ordering is insufficient.</source>
          <target state="translated">逐次的に整合性のある順序のセマンティクスを持つメモリフェンスを挿入する。これが必要とされるアルゴリズムがあります。</target>
        </trans-unit>
        <trans-unit id="3ea0f92c3d70dd355408c14ed7bbf0a9be4aeff9" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;kwargs&lt;/code&gt; will be a key-value iterator over a named tuple. Named tuples (as well as dictionaries with keys of &lt;code&gt;Symbol&lt;/code&gt;) can be passed as keyword arguments using a semicolon in a call, e.g. &lt;code&gt;f(x, z=1; kwargs...)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; の内部では、 &lt;code&gt;kwargs&lt;/code&gt; は名前付きタプルのキー値イテレーターになります。名前付きタプル（および &lt;code&gt;Symbol&lt;/code&gt; のキーを持つディクショナリ）は、呼び出しでセミコロンを使用してキーワード引数として渡すことができます &lt;code&gt;f(x, z=1; kwargs...)&lt;/code&gt; 例：f（x、z = 1; kwargs ...））。</target>
        </trans-unit>
        <trans-unit id="d505904dee884402cee2bfc93d1e5e6eac91aed0" translate="yes" xml:space="preserve">
          <source>Inside a function call, &lt;code&gt;f(a=b)&lt;/code&gt; passes &lt;code&gt;b&lt;/code&gt; as the value of keyword argument &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">関数呼び出しの中で、 &lt;code&gt;f(a=b)&lt;/code&gt; はキーワード引数 &lt;code&gt;a&lt;/code&gt; の値として &lt;code&gt;b&lt;/code&gt; を渡します。</target>
        </trans-unit>
        <trans-unit id="5c0628bcc3fe3dc7f18266ed4703a4ef8a1c7fc8" translate="yes" xml:space="preserve">
          <source>Inside a local scope a global variable can be assigned to by using the keyword &lt;a href=&quot;../../base/base/index#global&quot;&gt;&lt;code&gt;global&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">ローカルスコープ内では、キーワード&lt;a href=&quot;../../base/base/index#global&quot;&gt; &lt;code&gt;global&lt;/code&gt; &lt;/a&gt;を使用してグローバル変数を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="582d7159a5b73cf78ab92b918e0b2d46bdf1e604" translate="yes" xml:space="preserve">
          <source>Inside a local scope a variable can be forced to be a new local variable using the &lt;a href=&quot;../../base/base/index#local&quot;&gt;&lt;code&gt;local&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">ローカルスコープ内では、&lt;a href=&quot;../../base/base/index#local&quot;&gt; &lt;code&gt;local&lt;/code&gt; &lt;/a&gt;キーワードを使用して変数を強制的に新しいローカル変数にすることができます。</target>
        </trans-unit>
        <trans-unit id="49fad0a2de99eca8b6794c525262e6ccd85a1c70" translate="yes" xml:space="preserve">
          <source>Inside parentheses with commas, &lt;code&gt;(a=1,)&lt;/code&gt; constructs a &lt;a href=&quot;#Core.NamedTuple&quot;&gt;&lt;code&gt;NamedTuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">括弧の中にコンマを入れて &lt;code&gt;(a=1,)&lt;/code&gt; は&lt;a href=&quot;#Core.NamedTuple&quot;&gt; &lt;code&gt;NamedTuple&lt;/code&gt; を作成し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="456c6fe8fc3a9803d2d238636df3fddf2e8ebda8" translate="yes" xml:space="preserve">
          <source>Inspects the given UUID and returns its version (see &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122&quot;&gt;RFC 4122&lt;/a&gt;).</source>
          <target state="translated">指定されたUUIDを検査し、そのバージョンを返します（&lt;a href=&quot;https://www.ietf.org/rfc/rfc4122&quot;&gt;RFC 4122を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="4ff8674778688251123ee296e21a5f29ce889b67" translate="yes" xml:space="preserve">
          <source>Instances can be constructed from strings via &lt;a href=&quot;#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt;, or using the &lt;code&gt;big&lt;/code&gt; string literal.</source>
          <target state="translated">インスタンスは、&lt;a href=&quot;#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;を介して、または &lt;code&gt;big&lt;/code&gt; 文字列リテラルを使用して、文字列から構築できます。</target>
        </trans-unit>
        <trans-unit id="e2cd4547e98e69f493a2391724e35284eddfcf3f" translate="yes" xml:space="preserve">
          <source>Instead of calculating something or performing some action, you return a &lt;em&gt;quoted expression&lt;/em&gt; which, when evaluated, does what you want.</source>
          <target state="translated">何かを計算したり、何らかのアクションを実行したりする代わりに、評価されたときに必要なことを行う&lt;em&gt;引用符付きの式&lt;/em&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="e11074b6a3ddd4db91a1d67bb7c4e17f5cc3596e" translate="yes" xml:space="preserve">
          <source>Instead of directly sorting an array, you can compute a permutation of the array's indices that puts the array into sorted order:</source>
          <target state="translated">配列を直接ソートするのではなく,配列のインデックスの並べ替えを計算して,配列をソートされた順番に並べ替えることができます.</target>
        </trans-unit>
        <trans-unit id="d807ed905e686ec4c6c31127918a04393e4003ae" translate="yes" xml:space="preserve">
          <source>Instead of immediately running the command, backticks create a &lt;a href=&quot;../../base/base/index#Base.Cmd&quot;&gt;&lt;code&gt;Cmd&lt;/code&gt;&lt;/a&gt; object to represent the command. You can use this object to connect the command to others via pipes, &lt;a href=&quot;../../base/base/index#Base.run&quot;&gt;&lt;code&gt;run&lt;/code&gt;&lt;/a&gt; it, and &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; to it.</source>
          <target state="translated">コマンドをすぐに実行する代わりに、バッククォートはコマンドを表す&lt;a href=&quot;../../base/base/index#Base.Cmd&quot;&gt; &lt;code&gt;Cmd&lt;/code&gt; &lt;/a&gt;オブジェクトを作成します。このオブジェクトを使用して、パイプを介して他のユーザーにコマンドを接続し、&lt;a href=&quot;../../base/base/index#Base.run&quot;&gt; &lt;code&gt;run&lt;/code&gt; &lt;/a&gt;て、&lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;を行うことができます。</target>
        </trans-unit>
        <trans-unit id="78863694892c2019c43a79b283ebb340da799f84" translate="yes" xml:space="preserve">
          <source>Instead of loading a registered version of &lt;code&gt;Example&lt;/code&gt;, Julia will load the source code contained in &lt;code&gt;tutorial/dev/Example&lt;/code&gt;.</source>
          <target state="translated">Juliaは &lt;code&gt;Example&lt;/code&gt; の登録済みバージョンをロードする代わりに、 &lt;code&gt;tutorial/dev/Example&lt;/code&gt; に含まれているソースコードをロードします。</target>
        </trans-unit>
        <trans-unit id="80cddaa6c38b52b1b6910a5df7e62d1058e97067" translate="yes" xml:space="preserve">
          <source>Instead of performing some calculation or action, a generated function declaration returns a quoted expression which then forms the body for the method corresponding to the types of the arguments. When a generated function is called, the expression it returns is compiled and then run. To make this efficient, the result is usually cached. And to make this inferable, only a limited subset of the language is usable. Thus, generated functions provide a flexible way to move work from run time to compile time, at the expense of greater restrictions on allowed constructs.</source>
          <target state="translated">生成された関数宣言は、何らかの計算やアクションを実行する代わりに、引用符で囲まれた式を返し、それが引数の型に対応するメソッドのボディを形成します。生成された関数が呼び出されると、それが返す式がコンパイルされて実行されます。これを効率的にするために、結果は通常キャッシュされます。そして、これを推論可能にするために、言語の限られたサブセットのみが使用可能です。このように、生成された関数は、許可されたコンストラクタに対する制限が大きくなることを犠牲にしても、作業を実行時からコンパイル時に移動させる柔軟な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">代わりに</target>
        </trans-unit>
        <trans-unit id="a3a52a1be0f1de968cc5d8921a39676d67c34867" translate="yes" xml:space="preserve">
          <source>Instead, use a semicolon or insert a line break after &lt;code&gt;catch&lt;/code&gt;:</source>
          <target state="translated">代わりに、セミコロンを使用するか、 &lt;code&gt;catch&lt;/code&gt; の後に改行を挿入します。</target>
        </trans-unit>
        <trans-unit id="3f6b46a05cf7ae83de7f241a566b6dcab9f9f12b" translate="yes" xml:space="preserve">
          <source>Integer division (the &lt;code&gt;div&lt;/code&gt; function) has two exceptional cases: dividing by zero, and dividing the lowest negative number (&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt;) by -1. Both of these cases throw a &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt;&lt;code&gt;DivideError&lt;/code&gt;&lt;/a&gt;. The remainder and modulus functions (&lt;code&gt;rem&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt;) throw a &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt;&lt;code&gt;DivideError&lt;/code&gt;&lt;/a&gt; when their second argument is zero.</source>
          <target state="translated">整数除算（ &lt;code&gt;div&lt;/code&gt; 関数）には、2つの例外的なケースがあります。ゼロで除算する場合と、最小の負の数（&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt;）を-1で除算する場合です。これらのケースはどちらも&lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt; &lt;code&gt;DivideError&lt;/code&gt; を&lt;/a&gt;スローします。剰余関数とモジュラス関数（ &lt;code&gt;rem&lt;/code&gt; と &lt;code&gt;mod&lt;/code&gt; ）は、2番目の引数がゼロのときに&lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt; &lt;code&gt;DivideError&lt;/code&gt; を&lt;/a&gt;スローします。</target>
        </trans-unit>
        <trans-unit id="27477953a7f5629b70d1f8667b4ce5a95bd7d163" translate="yes" xml:space="preserve">
          <source>Integer division was attempted with a denominator value of 0.</source>
          <target state="translated">分母の値が 0 の整数除算が試みられました。</target>
        </trans-unit>
        <trans-unit id="44e36daccd6ac7a9f894c249dbe1f367783e4537" translate="yes" xml:space="preserve">
          <source>Integer square root: the largest integer &lt;code&gt;m&lt;/code&gt; such that &lt;code&gt;m*m &amp;lt;= n&lt;/code&gt;.</source>
          <target state="translated">平方根整数：最大整数 &lt;code&gt;m&lt;/code&gt; ように &lt;code&gt;m*m &amp;lt;= n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0f622cf48cf7d80bd106d7df1f3da91566c330d" translate="yes" xml:space="preserve">
          <source>Integer value N launches N additional local worker processes; &lt;code&gt;auto&lt;/code&gt; launches as many workers as the number of local CPU threads (logical cores)</source>
          <target state="translated">整数値Nは、N個の追加のローカルワーカープロセスを起動します。ローカルCPUスレッド（論理コア）の数と同じ数のワーカーを &lt;code&gt;auto&lt;/code&gt; 起動します</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="0be1ec1ce9bd8f5a453ecb566c11ab0a7c7144d0" translate="yes" xml:space="preserve">
          <source>Integers and Floating-Point Numbers</source>
          <target state="translated">整数と浮動小数点数</target>
        </trans-unit>
        <trans-unit id="cdcba026c96bc24c46aaded28b7a473dd9b651d8" translate="yes" xml:space="preserve">
          <source>Integers and floating-point values are the basic building blocks of arithmetic and computation. Built-in representations of such values are called numeric primitives, while representations of integers and floating-point numbers as immediate values in code are known as numeric literals. For example, &lt;code&gt;1&lt;/code&gt; is an integer literal, while &lt;code&gt;1.0&lt;/code&gt; is a floating-point literal; their binary in-memory representations as objects are numeric primitives.</source>
          <target state="translated">整数と浮動小数点値は、算術と計算の基本的な構成要素です。このような値の組み込み表現は数値プリミティブと呼ばれ、整数および浮動小数点数のコード内の即値としての表現は数値リテラルと呼ばれます。たとえば、 &lt;code&gt;1&lt;/code&gt; は整数リテラルですが、 &lt;code&gt;1.0&lt;/code&gt; は浮動小数点リテラルです。オブジェクトとしてのバイナリのインメモリ表現は数値プリミティブです。</target>
        </trans-unit>
        <trans-unit id="be404ce277aac9d3b9b27f0140b709ff517b7820" translate="yes" xml:space="preserve">
          <source>Integers are compared in the standard manner &amp;ndash; by comparison of bits. Floating-point numbers are compared according to the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;:</source>
          <target state="translated">整数は、ビットの比較によって、標準的な方法で比較されます。浮動小数点数は、&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754標準&lt;/a&gt;に従って比較されます。</target>
        </trans-unit>
        <trans-unit id="e3b59c9f1c26e320e172cac39695e68589e740a0" translate="yes" xml:space="preserve">
          <source>Integral</source>
          <target state="translated">Integral</target>
        </trans-unit>
        <trans-unit id="70680c64952b0114adcda3eb14a614e1841cd0c6" translate="yes" xml:space="preserve">
          <source>Integral Around A Point Operator</source>
          <target state="translated">点演算子周辺積分</target>
        </trans-unit>
        <trans-unit id="425335bd88e128f008b3f48181d1c27b517bcc72" translate="yes" xml:space="preserve">
          <source>Integral Average With Slash</source>
          <target state="translated">スラッシュ付き積分平均</target>
        </trans-unit>
        <trans-unit id="c6bac88caff6c11517b441d63dd4587857621bab" translate="yes" xml:space="preserve">
          <source>Integral With Double Stroke</source>
          <target state="translated">ダブルストロークのインテグラル</target>
        </trans-unit>
        <trans-unit id="18238ecc8130fd86a404d903215b4901fbd6604e" translate="yes" xml:space="preserve">
          <source>Integral With Intersection</source>
          <target state="translated">交差点との積分</target>
        </trans-unit>
        <trans-unit id="8a62b59c92abaaa075d87faf375d4d0d5e2fdc39" translate="yes" xml:space="preserve">
          <source>Integral With Overbar</source>
          <target state="translated">オーバーバーとの一体型</target>
        </trans-unit>
        <trans-unit id="08588fc154d2b615a7916934fe8e56ebda68acf8" translate="yes" xml:space="preserve">
          <source>Integral With Times Sign</source>
          <target state="translated">タイムズサインとの統合</target>
        </trans-unit>
        <trans-unit id="31ecf2a75d24fa7ec2a5569e3665d7f415d4db51" translate="yes" xml:space="preserve">
          <source>Integral With Underbar</source>
          <target state="translated">アンダーバーとの一体型</target>
        </trans-unit>
        <trans-unit id="23eafe62fdaca340d651a852cff8f87d44076b09" translate="yes" xml:space="preserve">
          <source>Integral With Union</source>
          <target state="translated">ユニオンとの統合</target>
        </trans-unit>
        <trans-unit id="2885cb42f64585560c85104eeedf86ba7e0ed77e" translate="yes" xml:space="preserve">
          <source>Intel's &lt;a href=&quot;https://software.intel.com/en-us/vtune&quot;&gt;VTune&amp;trade; Amplifier&lt;/a&gt; (&lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt; set to &lt;code&gt;1&lt;/code&gt; in the build configuration), or</source>
          <target state="translated">Intelの&lt;a href=&quot;https://software.intel.com/en-us/vtune&quot;&gt;VTune&amp;trade;アンプ&lt;/a&gt;（ビルド構成で &lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt; を &lt;code&gt;1&lt;/code&gt; に設定）、または</target>
        </trans-unit>
        <trans-unit id="207cb56e67212ece90d1329dc4b01521c8f13014" translate="yes" xml:space="preserve">
          <source>Interacting with the contents or methods of &lt;code&gt;Core.Compiler&lt;/code&gt; in any way.</source>
          <target state="translated">&lt;code&gt;Core.Compiler&lt;/code&gt; のコンテンツまたはメソッドとのやり取り。</target>
        </trans-unit>
        <trans-unit id="d4f66ae8b3da23aee8b514d4076de7a8e09b0b4e" translate="yes" xml:space="preserve">
          <source>Interactive Utilities</source>
          <target state="translated">インタラクティブなユーティリティ</target>
        </trans-unit>
        <trans-unit id="71fefc1d52a78f40748037e8a91fc8ea4f8e2578" translate="yes" xml:space="preserve">
          <source>Interactive mode; REPL runs and &lt;code&gt;isinteractive()&lt;/code&gt; is true</source>
          <target state="translated">インタラクティブモード。REPLが実行され、 &lt;code&gt;isinteractive()&lt;/code&gt; がtrueである</target>
        </trans-unit>
        <trans-unit id="0270e20982d6093d44ba136572cbf822d6290a5d" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_llvm</source>
          <target state="translated">InteractiveUtils.@code_llvm</target>
        </trans-unit>
        <trans-unit id="0309be470088530490561ff83d97b95071df357e" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_lowered</source>
          <target state="translated">InteractiveUtils.@code_lowered</target>
        </trans-unit>
        <trans-unit id="00a7a46c62638c2b2d4deb9dc4bd43a8d3c3582c" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_native</source>
          <target state="translated">InteractiveUtils.@code_native</target>
        </trans-unit>
        <trans-unit id="4fa27864c86ced13027d392baeedb020be6c560a" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_typed</source>
          <target state="translated">InteractiveUtils.@code_typed</target>
        </trans-unit>
        <trans-unit id="1e45473f814223dcb1c417d561e1870e1450bf83" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_warntype</source>
          <target state="translated">InteractiveUtils.@code_warntype</target>
        </trans-unit>
        <trans-unit id="eedef913d7842aa079f915bdbbb5f5e90c47c7f6" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@edit</source>
          <target state="translated">InteractiveUtils.@edit</target>
        </trans-unit>
        <trans-unit id="a6df5f45ac03e2c658d92e8736e88cafa5b98995" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@functionloc</source>
          <target state="translated">InteractiveUtils.@functionloc</target>
        </trans-unit>
        <trans-unit id="49e359f4c318b876f99ccb7d37f63e69deb2003d" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@less</source>
          <target state="translated">InteractiveUtils.@less</target>
        </trans-unit>
        <trans-unit id="6e359d1c5b33d4212df3c4f8c3762813890df9ae" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@which</source>
          <target state="translated">InteractiveUtils.@which</target>
        </trans-unit>
        <trans-unit id="2d50f6ed31622302ae5f5a5feebfb95f2c420a04" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.clipboard()</source>
          <target state="translated">InteractiveUtils.clipboard()</target>
        </trans-unit>
        <trans-unit id="c1ad553095bd7ae0c9db5b342934998a5be27479" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_llvm()</source>
          <target state="translated">InteractiveUtils.code_llvm()</target>
        </trans-unit>
        <trans-unit id="a70df8f6770abff941be7ee8196e397ae5bbd4b8" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_native()</source>
          <target state="translated">InteractiveUtils.code_native()</target>
        </trans-unit>
        <trans-unit id="f009b2e3c7cb61122f070c557fb9f4dcd1edf6db" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_warntype()</source>
          <target state="translated">InteractiveUtils.code_warntype()</target>
        </trans-unit>
        <trans-unit id="d4c1c9ee2ecb7996d780a0e5d5ccea921a53d56a" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.edit()</source>
          <target state="translated">InteractiveUtils.edit()</target>
        </trans-unit>
        <trans-unit id="424927890145616c60279ce930588fd54c4ac90e" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.less()</source>
          <target state="translated">InteractiveUtils.less()</target>
        </trans-unit>
        <trans-unit id="49eeeef411d4549f28b217525726cf46e51440cb" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.methodswith()</source>
          <target state="translated">InteractiveUtils.methodswith()</target>
        </trans-unit>
        <trans-unit id="59973fd047bc66e11de11bff485ff30fc8072b48" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.subtypes()</source>
          <target state="translated">InteractiveUtils.subtypes()</target>
        </trans-unit>
        <trans-unit id="8cc40b484c66058018a0b8c42f2ab741a2014154" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.varinfo()</source>
          <target state="translated">InteractiveUtils.varinfo()</target>
        </trans-unit>
        <trans-unit id="391d124220b1a9c25f8d3323e7bb133c849aadc9" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.versioninfo()</source>
          <target state="translated">InteractiveUtils.versioninfo()</target>
        </trans-unit>
        <trans-unit id="068a8966386d6f477f70dcc54b094caba48a03f4" translate="yes" xml:space="preserve">
          <source>Intercalate</source>
          <target state="translated">Intercalate</target>
        </trans-unit>
        <trans-unit id="a791af570ec4e5730c5e110c39b173c357ea4d3a" translate="yes" xml:space="preserve">
          <source>Interconverts between dense and sparse formats.</source>
          <target state="translated">密なフォーマットと疎なフォーマットを相互変換します。</target>
        </trans-unit>
        <trans-unit id="c3229f4e0f20d697072608271bc7f20c5b6d789f" translate="yes" xml:space="preserve">
          <source>Interface to BLAS subroutines.</source>
          <target state="translated">BLASのサブルーチンへのインターフェースです。</target>
        </trans-unit>
        <trans-unit id="bcdb1ff794ae28041f3196a504b6115b3dea810a" translate="yes" xml:space="preserve">
          <source>Interface to libc, the C standard library.</source>
          <target state="translated">C 標準ライブラリである libc へのインターフェイスです。</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="c2b213458be4f2f6fdec41d29483b814cba730b1" translate="yes" xml:space="preserve">
          <source>Interfaces to LAPACK subroutines.</source>
          <target state="translated">LAPACKサブルーチンへのインターフェースです。</target>
        </trans-unit>
        <trans-unit id="a514e8807ceddceeb9d1c2be8e83634758fea386" translate="yes" xml:space="preserve">
          <source>Interior Product</source>
          <target state="translated">インテリア製品</target>
        </trans-unit>
        <trans-unit id="0c4a9d0a55deb37d51d5b2b7f615f0874ed971d8" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;promote_type&lt;/code&gt; is used inside of &lt;code&gt;promote&lt;/code&gt; to determine what type argument values should be converted to for promotion. It can, however, be useful in its own right. The curious reader can read the code in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt;&lt;code&gt;promotion.jl&lt;/code&gt;&lt;/a&gt;, which defines the complete promotion mechanism in about 35 lines.</source>
          <target state="translated">内部的に、 &lt;code&gt;promote_type&lt;/code&gt; は &lt;code&gt;promote&lt;/code&gt; 内部で使用され、プロモートのためにどのタイプの引数値に変換する必要があるかを決定します。ただし、それ自体は有用です。好奇心のリーダーはでコード読み取ることができる&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt; &lt;code&gt;promotion.jl&lt;/code&gt; &lt;/a&gt;約35行で完全促進メカニズムを定義し、。</target>
        </trans-unit>
        <trans-unit id="818408de3c95448c6a4c8c7cc57f8a8c85a4002d" translate="yes" xml:space="preserve">
          <source>Internally, an &lt;code&gt;AbstractChar&lt;/code&gt; type may use a variety of encodings. Conversion via &lt;code&gt;codepoint(char)&lt;/code&gt; will not reveal this encoding because it always returns the Unicode value of the character. &lt;code&gt;print(io, c)&lt;/code&gt; of any &lt;code&gt;c::AbstractChar&lt;/code&gt; produces an encoding determined by &lt;code&gt;io&lt;/code&gt; (UTF-8 for all built-in &lt;code&gt;IO&lt;/code&gt; types), via conversion to &lt;code&gt;Char&lt;/code&gt; if necessary.</source>
          <target state="translated">内部的には、 &lt;code&gt;AbstractChar&lt;/code&gt; 型はさまざまなエンコーディングを使用できます。 &lt;code&gt;codepoint(char)&lt;/code&gt; による変換では、常に文字のUnicode値が返されるため、このエンコーディングは明らかになりません。任意の &lt;code&gt;c::AbstractChar&lt;/code&gt; &lt;code&gt;print(io, c)&lt;/code&gt; は、必要に応じて &lt;code&gt;Char&lt;/code&gt; への変換を介して、 &lt;code&gt;io&lt;/code&gt; （すべての組み込み &lt;code&gt;IO&lt;/code&gt; タイプの場合はUTF-8）によって決定されるエンコーディングを生成します。</target>
        </trans-unit>
        <trans-unit id="4952806e1eda6ad8d06e741bd80f1e6d3a2efafd" translate="yes" xml:space="preserve">
          <source>Internally, this code creates two implementations of the function: a generated one where the first block in &lt;code&gt;if @generated&lt;/code&gt; is used, and a normal one where the &lt;code&gt;else&lt;/code&gt; block is used. Inside the &lt;code&gt;then&lt;/code&gt; part of the &lt;code&gt;if @generated&lt;/code&gt; block, code has the same semantics as other generated functions: argument names refer to types, and the code should return an expression. Multiple &lt;code&gt;if @generated&lt;/code&gt; blocks may occur, in which case the generated implementation uses all of the &lt;code&gt;then&lt;/code&gt; blocks and the alternate implementation uses all of the &lt;code&gt;else&lt;/code&gt; blocks.</source>
          <target state="translated">内部的には、このコードは関数の2つの実装を作成します &lt;code&gt;if @generated&lt;/code&gt; 最初のブロックが使用される生成されたものと、 &lt;code&gt;else&lt;/code&gt; ブロックが使用される通常の実装です。 &lt;code&gt;if @generated&lt;/code&gt; ブロックの &lt;code&gt;then&lt;/code&gt; 部分内では、コードは他の生成された関数と同じセマンティクスを持っています。引数名は型を参照し、コードは式を返す必要があります。複数の &lt;code&gt;if @generated&lt;/code&gt; ブロックが発生する可能性があります。その場合、生成された実装はすべての &lt;code&gt;then&lt;/code&gt; ブロックを使用し、代替の実装はすべての &lt;code&gt;else&lt;/code&gt; ブロックを使用します。</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="48012c80f49c5c1a3bff1ed20d31a89b4f215742" translate="yes" xml:space="preserve">
          <source>Interpolating into an unquoted expression is not supported and will cause a compile-time error:</source>
          <target state="translated">引用符で囲まれていない式への補間はサポートされておらず、コンパイル時にエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="d67b7c5f52f05b37b77a64fd823fc76a0fce5a66" translate="yes" xml:space="preserve">
          <source>Interpret an iterable of key-value pairs as a named tuple, and perform a merge.</source>
          <target state="translated">キーと値のペアのイテレートブルを名前付きタプルとして解釈し、マージを実行します。</target>
        </trans-unit>
        <trans-unit id="cc53b2acfc42c6cf13c71d4c67ea40578eaaf1f7" translate="yes" xml:space="preserve">
          <source>Interpretation: accessing elements of poorly-typed arrays</source>
          <target state="translated">解釈:型付けの悪い配列の要素へのアクセス</target>
        </trans-unit>
        <trans-unit id="7894bb109218bbe3ea53cb08c360e18b2453f383" translate="yes" xml:space="preserve">
          <source>Interpretation: call to a type-unstable function &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">解釈：型が不安定な関数 &lt;code&gt;g&lt;/code&gt; の呼び出し。</target>
        </trans-unit>
        <trans-unit id="7784e3d882b6a7b4c22ed3b7f03fb99cea250d48" translate="yes" xml:space="preserve">
          <source>Interpretation: function with unstable return type</source>
          <target state="translated">解釈:不安定な戻り値の型を持つ関数</target>
        </trans-unit>
        <trans-unit id="9f71e4dd30d3efc21956f72596ba4278f8921c99" translate="yes" xml:space="preserve">
          <source>Interpretation: getting a field that is of non-leaf type. In this case, &lt;code&gt;ArrayContainer&lt;/code&gt; had a field &lt;code&gt;data::Array{T}&lt;/code&gt;. But &lt;code&gt;Array&lt;/code&gt; needs the dimension &lt;code&gt;N&lt;/code&gt;, too, to be a concrete type.</source>
          <target state="translated">解釈：非リーフタイプのフィールドを取得する。この場合、 &lt;code&gt;ArrayContainer&lt;/code&gt; にはフィールド &lt;code&gt;data::Array{T}&lt;/code&gt; 。しかし、 &lt;code&gt;Array&lt;/code&gt; も具象型であるためには次元 &lt;code&gt;N&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="f71c83c811d3e87825b69245ec2c0dff4c1686bd" translate="yes" xml:space="preserve">
          <source>Interpreting the output of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt;, like that of its cousins &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt;&lt;code&gt;@code_lowered&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt;&lt;code&gt;@code_typed&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt;&lt;code&gt;@code_llvm&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt;&lt;code&gt;@code_native&lt;/code&gt;&lt;/a&gt;, takes a little practice. Your code is being presented in form that has been heavily digested on its way to generating compiled machine code. Most of the expressions are annotated by a type, indicated by the &lt;code&gt;::T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; might be &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, for example). The most important characteristic of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt; is that non-concrete types are displayed in red; in the above example, such output is shown in uppercase.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt;の出力を、その従兄弟である&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt; &lt;code&gt;@code_lowered&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt; &lt;code&gt;@code_typed&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt; &lt;code&gt;@code_llvm&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt; &lt;code&gt;@code_native&lt;/code&gt; のように解釈する&lt;/a&gt;には、少し練習が必要です。あなたのコードは、コンパイルされたマシンコードを生成する途中で非常に分解された形で提示されています。ほとんどの式は、 &lt;code&gt;::T&lt;/code&gt; （ &lt;code&gt;T&lt;/code&gt; は&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;など）で示されるタイプによって注釈が付けられます。&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt;の最も重要な特性は、非コンクリートタイプが赤で表示されることです。上記の例では、そのような出力は大文字で示されています。</target>
        </trans-unit>
        <trans-unit id="cc939bea48b5a28296b21d2be9495aa8bccd0b19" translate="yes" xml:space="preserve">
          <source>Interrupt or cancel</source>
          <target state="translated">割り込みまたはキャンセル</target>
        </trans-unit>
        <trans-unit id="23165f09bcddd0acc011e45e34282dbbd91bd4cd" translate="yes" xml:space="preserve">
          <source>Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.</source>
          <target state="translated">指定されたワーカーで現在実行中のタスクを中断します。これは、ローカルマシンで Ctrl-C を押すのと同じです。引数が与えられない場合、すべてのワーカーが中断されます。</target>
        </trans-unit>
        <trans-unit id="658cc9a8a17acd75a5bc21930b12d446eea71552" translate="yes" xml:space="preserve">
          <source>Intersect all passed in sets and overwrite &lt;code&gt;s&lt;/code&gt; with the result. Maintain order with arrays.</source>
          <target state="translated">渡されたすべてのセットを交差させ、結果で &lt;code&gt;s&lt;/code&gt; を上書きします。配列で順序を維持します。</target>
        </trans-unit>
        <trans-unit id="d0f596ba112a353008597117b57b10b067fc620b" translate="yes" xml:space="preserve">
          <source>Intersection</source>
          <target state="translated">Intersection</target>
        </trans-unit>
        <trans-unit id="7d65fe6f634dc82a5910e500d111d1c2553d45ad" translate="yes" xml:space="preserve">
          <source>Intersection Beside And Joined With Intersection</source>
          <target state="translated">交差点の横にある交差点と交差点との接合部</target>
        </trans-unit>
        <trans-unit id="f70ced5527bc06ac0250ff3ce0c6433b4fc007ad" translate="yes" xml:space="preserve">
          <source>Intersection With Dot</source>
          <target state="translated">ドットとの交差点</target>
        </trans-unit>
        <trans-unit id="fea160380c26aea0a6f5cf6d33e5059a2528bb99" translate="yes" xml:space="preserve">
          <source>Intersection With Logical And</source>
          <target state="translated">論理的なものとの交差点</target>
        </trans-unit>
        <trans-unit id="8a447498c8a13bd62bc28a71db064abbbd2ce851" translate="yes" xml:space="preserve">
          <source>Intersection With Overbar</source>
          <target state="translated">オーバーバーとの交差点</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="95010e236dbeb1d0c89e9d5b6ed0ea0da0ed9572" translate="yes" xml:space="preserve">
          <source>Intuitively, this corresponds to the type of a function's arguments being a subtype of the function's signature (when the signature matches).</source>
          <target state="translated">直感的には、これは関数の引数の型が関数のシグネチャのサブタイプであることに対応します(シグネチャがマッチする場合)。</target>
        </trans-unit>
        <trans-unit id="f4bc4f6c3fe38fa1ef542295504817c8e94651bb" translate="yes" xml:space="preserve">
          <source>Inverse Bullet</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b80ae8599265e5e4df3c9c6eae5101a072d85a" translate="yes" xml:space="preserve">
          <source>Inverse White Circle</source>
          <target state="translated">インバースホワイトサークル</target>
        </trans-unit>
        <trans-unit id="f5c93f67585d1f2ce3d07fe77774efdd8e1c494a" translate="yes" xml:space="preserve">
          <source>Inverted Exclamation Mark</source>
          <target state="translated">逆さエクスクラメーションマーク</target>
        </trans-unit>
        <trans-unit id="8ed370a70ad4ba84f93ff72e14bb89b2e795837a" translate="yes" xml:space="preserve">
          <source>Inverted Lazy S</source>
          <target state="translated">反転レイジーS</target>
        </trans-unit>
        <trans-unit id="7e3bf2655c3d6132b1040ffc28240e0e2706a489" translate="yes" xml:space="preserve">
          <source>Inverted Ohm Sign / Mho</source>
          <target state="translated">反転したオーム記号/Mho</target>
        </trans-unit>
        <trans-unit id="77352625457aa55d3c246bb35487f40a40f194e5" translate="yes" xml:space="preserve">
          <source>Inverted Question Mark</source>
          <target state="translated">反転したクエスチョンマーク</target>
        </trans-unit>
        <trans-unit id="1dc2af95223d452f5604dae81acef5fd3a117e33" translate="yes" xml:space="preserve">
          <source>Invoke a method for the given generic function &lt;code&gt;f&lt;/code&gt; matching the specified types &lt;code&gt;argtypes&lt;/code&gt; on the specified arguments &lt;code&gt;args&lt;/code&gt; and passing the keyword arguments &lt;code&gt;kwargs&lt;/code&gt;. The arguments &lt;code&gt;args&lt;/code&gt; must conform with the specified types in &lt;code&gt;argtypes&lt;/code&gt;, i.e. conversion is not automatically performed. This method allows invoking a method other than the most specific matching method, which is useful when the behavior of a more general definition is explicitly needed (often as part of the implementation of a more specific method of the same function).</source>
          <target state="translated">指定された引数 &lt;code&gt;args&lt;/code&gt; の指定された型 &lt;code&gt;argtypes&lt;/code&gt; に一致し、キーワード引数 &lt;code&gt;kwargs&lt;/code&gt; を渡して、指定されたジェネリック関数 &lt;code&gt;f&lt;/code&gt; のメソッドを呼び出します。引数 &lt;code&gt;args&lt;/code&gt; は、 &lt;code&gt;argtypes&lt;/code&gt; で指定された型に準拠している必要があります。つまり、変換は自動的には実行されません。このメソッドを使用すると、最も具体的なマッチングメソッド以外のメソッドを呼び出すことができます。これは、より一般的な定義の動作が明示的に必要な場合に役立ちます（多くの場合、同じ関数のより具体的なメソッドの実装の一部として）。</target>
        </trans-unit>
        <trans-unit id="0fe30ecc758896527e5047bf5e1ab5207bc281f3" translate="yes" xml:space="preserve">
          <source>Irrational</source>
          <target state="translated">Irrational</target>
        </trans-unit>
        <trans-unit id="f21fa8512b05ce15e621a0c6aca735529c300b50" translate="yes" xml:space="preserve">
          <source>Issue 8859, &quot;Fix least squares&quot;, https://github.com/JuliaLang/julia/pull/8859</source>
          <target state="translated">問題8859、「最小二乗の修正」、https://github.com/JuliaLang/julia/pull/8859</target>
        </trans-unit>
        <trans-unit id="beadd95d62ed185b3348f8f407f354b8cc251415" translate="yes" xml:space="preserve">
          <source>It also makes writing exponential functions more elegant:</source>
          <target state="translated">指数関数の書き方もエレガントになります。</target>
        </trans-unit>
        <trans-unit id="f6ba82c6b32228a1dcbba192584fb70b95766cb3" translate="yes" xml:space="preserve">
          <source>It can be more efficient. Some structs can be packed efficiently into arrays, and in some cases the compiler is able to avoid allocating immutable objects entirely.</source>
          <target state="translated">より効率的にすることができます。構造体の中には、効率的に配列に詰め込むことができるものもあり、コンパイラによっては、不変オブジェクトの割り当てを完全に回避できる場合もあります。</target>
        </trans-unit>
        <trans-unit id="2138e5233860592eb48b0938be0063487a8c3bbe" translate="yes" xml:space="preserve">
          <source>It can happen that &lt;code&gt;Sampler(rng::AbstractRNG, ::S, ::Repetition)&lt;/code&gt; is already defined in the &lt;code&gt;Random&lt;/code&gt; module. It would then be possible to skip step 1) in practice (if one wants to specialize generation for this particular RNG type), but the corresponding &lt;code&gt;SamplerS&lt;/code&gt; type is considered as internal detail, and may be changed without warning.</source>
          <target state="translated">ことが起こる可能 &lt;code&gt;Sampler(rng::AbstractRNG, ::S, ::Repetition)&lt;/code&gt; 既に定義されている &lt;code&gt;Random&lt;/code&gt; モジュール。その後、実際には（この特定のRNGタイプの生成を特化したい場合）ステップ1）をスキップすることは可能ですが、対応する &lt;code&gt;SamplerS&lt;/code&gt; タイプは内部詳細と見なされ、警告なしに変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="b7db5f9d834448c3fd65f59044d31e02c3be0663" translate="yes" xml:space="preserve">
          <source>It can profile into Julia's core code and even (optionally) into C and Fortran libraries.</source>
          <target state="translated">ジュリアのコアコードにプロファイリングしたり、(オプションで)CやFortranライブラリにプロファイリングしたりすることができます。</target>
        </trans-unit>
        <trans-unit id="c10e801b8b0e3436ff2d170e31afdf3876bf67ea" translate="yes" xml:space="preserve">
          <source>It does not return.</source>
          <target state="translated">戻りません。</target>
        </trans-unit>
        <trans-unit id="62d668cd36ba8709a3dd4638a2eee6fedce824d7" translate="yes" xml:space="preserve">
          <source>It has a special compilation rule: a homogeneous tuple of &lt;code&gt;VecElement{T}&lt;/code&gt; maps to an LLVM &lt;code&gt;vector&lt;/code&gt; type when &lt;code&gt;T&lt;/code&gt; is a primitive bits type and the tuple length is in the set {2-6,8-10,16}.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; がプリミティブビットタイプであり、タプルの長さがセット{2-6,8-10,16}にある場合、 &lt;code&gt;VecElement{T}&lt;/code&gt; 同種タプルはLLVM &lt;code&gt;vector&lt;/code&gt; タイプにマップされます。</target>
        </trans-unit>
        <trans-unit id="35f1e7a71c8a1cc6e09f468c80045e4456b3f7b6" translate="yes" xml:space="preserve">
          <source>It has a toplevel &lt;code&gt;path&lt;/code&gt; entry, then &lt;code&gt;uuid&lt;/code&gt; will be mapped to that path, interpreted relative to the directory containing the project file.</source>
          <target state="translated">これにはトップレベルの &lt;code&gt;path&lt;/code&gt; エントリがあり、 &lt;code&gt;uuid&lt;/code&gt; はそのパスにマップされ、プロジェクトファイルを含むディレクトリに関連して解釈されます。</target>
        </trans-unit>
        <trans-unit id="5302402dcc63d9a0a8348f68814a706354ef52ba" translate="yes" xml:space="preserve">
          <source>It has access to a special locally existent function called &lt;a href=&quot;../../base/base/index#new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; that creates objects of the block's type.</source>
          <target state="translated">ブロックのタイプのオブジェクトを作成する&lt;a href=&quot;../../base/base/index#new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;と呼ばれるローカルに存在する特別な関数にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="3fbc8a317cac4fe1eddafff9a3cee6a2e600d5c8" translate="yes" xml:space="preserve">
          <source>It is also important to see how &lt;code&gt;@generated&lt;/code&gt; functions interact with method redefinition. Following the principle that a correct &lt;code&gt;@generated&lt;/code&gt; function must not observe any mutable state or cause any mutation of global state, we see the following behavior. Observe that the generated function &lt;em&gt;cannot&lt;/em&gt; call any method that was not defined prior to the &lt;em&gt;definition&lt;/em&gt; of the generated function itself.</source>
          <target state="translated">&lt;code&gt;@generated&lt;/code&gt; 関数がメソッドの再定義とどのように相互作用するかを確認することも重要です。正しい &lt;code&gt;@generated&lt;/code&gt; 関数が変更可能な状態を観察したり、グローバルな状態の変更を引き起こしたりしてはならないという原則に従って、次の動作が見られます。生成された関数は、生成された関数自体の定義の前に定義されていなかったメソッドを呼び出す&lt;em&gt;ことができないことに&lt;/em&gt;注意して&lt;em&gt;ください&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="acbe3463a0ccc2ec8908f82ece54174f7671b1ae" translate="yes" xml:space="preserve">
          <source>It is also important to understand the differences to ordinary scalars. Scalars are not mutable containers (even though they are iterable and define things like &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;getindex&lt;/code&gt;, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;1[] == 1&lt;/code&gt;). In particular, if &lt;code&gt;x = 0.0&lt;/code&gt; is defined as a scalar, it is an error to attempt to change its value via &lt;code&gt;x[] = 1.0&lt;/code&gt;. A scalar &lt;code&gt;x&lt;/code&gt; can be converted into a zero-dimensional array containing it via &lt;code&gt;fill(x)&lt;/code&gt;, and conversely, a zero-dimensional array &lt;code&gt;a&lt;/code&gt; can be converted to the contained scalar via &lt;code&gt;a[]&lt;/code&gt;. Another difference is that a scalar can participate in linear algebra operations such as &lt;code&gt;2 * rand(2,2)&lt;/code&gt;, but the analogous operation with a zero-dimensional array &lt;code&gt;fill(2) * rand(2,2)&lt;/code&gt; is an error.</source>
          <target state="translated">通常のスカラーとの違いを理解することも重要です。スカラーは変更可能なコンテナーではありません（反復可能であり、 &lt;code&gt;length&lt;/code&gt; 、 &lt;code&gt;getindex&lt;/code&gt; などの定義があります（&lt;em&gt;例：&lt;/em&gt; &lt;code&gt;1[] == 1&lt;/code&gt; ））。特に、 &lt;code&gt;x = 0.0&lt;/code&gt; がスカラーとして定義されている場合、 &lt;code&gt;x[] = 1.0&lt;/code&gt; 介してその値を変更しようとするとエラーになります。スカラー &lt;code&gt;x&lt;/code&gt; は、 &lt;code&gt;fill(x)&lt;/code&gt; を介してそれを含むゼロ次元配列に変換でき、逆に、ゼロ次元配列 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;a[]&lt;/code&gt; 介して含まれるスカラーに変換できます。もう1つの違いは、スカラーが &lt;code&gt;2 * rand(2,2)&lt;/code&gt; などの線形代数演算に参加できることです。ただし、ゼロ次元配列 &lt;code&gt;fill(2) * rand(2,2)&lt;/code&gt; した類似の操作はエラーです。</target>
        </trans-unit>
        <trans-unit id="a6aa34f5f096577fc826b15725104feebe319049" translate="yes" xml:space="preserve">
          <source>It is also often useful to allow iteration over a collection in &lt;em&gt;reverse order&lt;/em&gt; by iterating over &lt;a href=&quot;../../base/iterators/index#Base.Iterators.reverse&quot;&gt;&lt;code&gt;Iterators.reverse(iterator)&lt;/code&gt;&lt;/a&gt;. To actually support reverse-order iteration, however, an iterator type &lt;code&gt;T&lt;/code&gt; needs to implement &lt;code&gt;iterate&lt;/code&gt; for &lt;code&gt;Iterators.Reverse{T}&lt;/code&gt;. (Given &lt;code&gt;r::Iterators.Reverse{T}&lt;/code&gt;, the underling iterator of type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;r.itr&lt;/code&gt;.) In our &lt;code&gt;Squares&lt;/code&gt; example, we would implement &lt;code&gt;Iterators.Reverse{Squares}&lt;/code&gt; methods:</source>
          <target state="translated">&lt;a href=&quot;../../base/iterators/index#Base.Iterators.reverse&quot;&gt; &lt;code&gt;Iterators.reverse(iterator)&lt;/code&gt; を&lt;/a&gt;反復することにより、&lt;em&gt;逆の順序で&lt;/em&gt;コレクションを反復できるようにすることもしばしば役立ちます。実際には、逆の順序の反復をサポートするために、しかし、イテレータタイプ &lt;code&gt;T&lt;/code&gt; は、実装する必要が &lt;code&gt;iterate&lt;/code&gt; するため &lt;code&gt;Iterators.Reverse{T}&lt;/code&gt; 。（ &lt;code&gt;r::Iterators.Reverse{T}&lt;/code&gt; 場合、 &lt;code&gt;T&lt;/code&gt; 型の &lt;code&gt;r.itr&lt;/code&gt; イテレータはr.itrです。）この &lt;code&gt;Squares&lt;/code&gt; の例では、 &lt;code&gt;Iterators.Reverse{Squares}&lt;/code&gt; メソッドを実装します。</target>
        </trans-unit>
        <trans-unit id="3e1077394826061ef79c129bd16ea289c7d0ba39" translate="yes" xml:space="preserve">
          <source>It is also possible to apply boldface formatting by using &lt;code&gt;Base.text_colors[:bold]&lt;/code&gt; as a color. For instance, to print answers in boldface font, one can use the following as a &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Base.text_colors[:bold]&lt;/code&gt; を色として使用して、太字の書式を適用することもできます。たとえば、太字フォントで回答を印刷するには、以下を &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; として使用できます。</target>
        </trans-unit>
        <trans-unit id="b553bb959838778f24d5092568f001b6908e4f87" translate="yes" xml:space="preserve">
          <source>It is also possible to interact with a Julia REPL in the browser via &lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt;. See the package home for details.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt;を介してブラウザーでJulia REPLと対話することもできます。詳細については、パッケージのホームを参照してください。</target>
        </trans-unit>
        <trans-unit id="77f0d3358e54fed68167ad7e2f2668925a7d33bb" translate="yes" xml:space="preserve">
          <source>It is also worth emphasizing that functions should take arguments, instead of operating directly on global variables (aside from constants like &lt;a href=&quot;../../base/numbers/index#Base.MathConstants.pi&quot;&gt;&lt;code&gt;pi&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">また、関数は、グローバル変数（&lt;a href=&quot;../../base/numbers/index#Base.MathConstants.pi&quot;&gt; &lt;code&gt;pi&lt;/code&gt; &lt;/a&gt;などの定数を除く）を直接操作するのではなく、引数を取る必要があることを強調する価値もあります。</target>
        </trans-unit>
        <trans-unit id="af4f80c2a3eb6b9cc2e18a2eac5ff00feaaaca4a" translate="yes" xml:space="preserve">
          <source>It is better to avoid errors than to rely on catching them.</source>
          <target state="translated">キャッチボールに頼るよりも、ミスをしない方がいい。</target>
        </trans-unit>
        <trans-unit id="62c8e496514b2a89c93f19599f4b3b4a2fbaa739" translate="yes" xml:space="preserve">
          <source>It is convenient to have captures returned as an array so that one can use destructuring syntax to bind them to local variables:</source>
          <target state="translated">キャプチャを配列として返すと便利なので、デストラクチャリング構文を使ってローカル変数にバインドすることができます。</target>
        </trans-unit>
        <trans-unit id="d47b317b6ddbcdcb526b152229f01524e725a05a" translate="yes" xml:space="preserve">
          <source>It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code that works correctly on one system to fail or produce indeterminate results on a different system.</source>
          <target state="translated">宣言されたCの型とJuliaでの宣言を正確に一致させることが重要です。不整合があると、あるシステムでは正しく動作していたコードが失敗したり、別のシステムでは不確定な結果になったりすることがあります。</target>
        </trans-unit>
        <trans-unit id="fed6b1dba676362bbdda7d92763627e5b989669b" translate="yes" xml:space="preserve">
          <source>It is declared inside the block of a type declaration, rather than outside of it like normal methods.</source>
          <target state="translated">通常のメソッドのように型宣言の外側ではなく、型宣言のブロック内で宣言されます。</target>
        </trans-unit>
        <trans-unit id="be90e9f486db27a87a15823d4ded324a5b8722df" translate="yes" xml:space="preserve">
          <source>It is good practice to provide as few inner constructor methods as possible: only those taking all arguments explicitly and enforcing essential error checking and transformation. Additional convenience constructor methods, supplying default values or auxiliary transformations, should be provided as outer constructors that call the inner constructors to do the heavy lifting. This separation is typically quite natural.</source>
          <target state="translated">すべての引数を明示的に取り、本質的なエラーチェックと変換を強制するものだけを提供します。デフォルト値や補助的な変換を提供する便利なコンストラクタメソッドは、外側のコンストラクタとして提供し、内側のコンストラクタを呼び出して重い作業を行うようにします。この分離は一般的に非常に自然なことです。</target>
        </trans-unit>
        <trans-unit id="055af1e6d77e563e261b9cddc84477b0892ca389" translate="yes" xml:space="preserve">
          <source>It is good practice to use such special versions in comparisons (particularly, the trailing &lt;code&gt;-&lt;/code&gt; should always be used on upper bounds unless there's a good reason not to), but they must not be used as the actual version number of anything, as they are invalid in the semantic versioning scheme.</source>
          <target state="translated">比較ではこのような特別なバージョンを使用することをお勧めします（特に、後続の &lt;code&gt;-&lt;/code&gt; 正当な理由がない限り、常に上限で使用する必要があります）が、実際のバージョン番号として使用しないでください。セマンティックバージョニングスキームでは無効です。</target>
        </trans-unit>
        <trans-unit id="94f57801215f48bd353cec6fcbf15e2489fd5bd7" translate="yes" xml:space="preserve">
          <source>It is important to emphasize that macros receive their arguments as expressions, literals, or symbols. One way to explore macro arguments is to call the &lt;code&gt;show&lt;/code&gt; function within the macro body:</source>
          <target state="translated">マクロは引数を式、リテラル、またはシンボルとして受け取ることを強調することが重要です。マクロ引数を調べる1つの方法は、マクロ本体内で &lt;code&gt;show&lt;/code&gt; 関数を呼び出すことです。</target>
        </trans-unit>
        <trans-unit id="02a6b6b86295c683044f57772927ffaa28e3765b" translate="yes" xml:space="preserve">
          <source>It is important to note that &lt;em&gt;when&lt;/em&gt; an object is locally garbage collected depends on the size of the object and the current memory pressure in the system.</source>
          <target state="translated">オブジェクトがローカルでガベージコレクションされる&lt;em&gt;ときは&lt;/em&gt;、オブジェクトのサイズとシステム内の現在のメモリプレッシャーに依存すること&lt;em&gt;に&lt;/em&gt;注意してください。</target>
        </trans-unit>
        <trans-unit id="600388b971e8fe9fe40cf23408b11ce42cda8c10" translate="yes" xml:space="preserve">
          <source>It is in general impossible to predict which values will be old at runtime, so the write barrier must be inserted after all explicit stores. One notable exception is if the &lt;code&gt;parent&lt;/code&gt; object was just allocated and garbage collection was not run since then. Remember that most &lt;code&gt;jl_...&lt;/code&gt; functions can sometimes invoke garbage collection.</source>
          <target state="translated">実行時にどの値が古いかを予測することは一般に不可能であるため、すべての明示的なストアの後に書き込みバリアを挿入する必要があります。注目すべき例外の1つは、 &lt;code&gt;parent&lt;/code&gt; オブジェクトが割り当てられたばかりで、その後ガベージコレクションが実行されなかった場合です。ほとんどの &lt;code&gt;jl_...&lt;/code&gt; 関数はガベージコレクションを呼び出すことができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1e58853c75f92756885fe162715552efead15275" translate="yes" xml:space="preserve">
          <source>It is not permitted to modify the value of an immutable type.</source>
          <target state="translated">不変型の値を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="737fc29ba3e3878487296ae0904e3501ba8b3de3" translate="yes" xml:space="preserve">
          <source>It is not possible to violate the invariants provided by the type's constructors.</source>
          <target state="translated">型のコンストラクタが提供する不変量に違反することはできません。</target>
        </trans-unit>
        <trans-unit id="9c82744b33d4a8c920b021b98d324b0dd36c7c0d" translate="yes" xml:space="preserve">
          <source>It is often convenient to be able to write functions taking an arbitrary number of arguments. Such functions are traditionally known as &quot;varargs&quot; functions, which is short for &quot;variable number of arguments&quot;. You can define a varargs function by following the last argument with an ellipsis:</source>
          <target state="translated">任意の数の引数を取る関数を書けると便利なことがよくあります。このような関数は伝統的に &quot;varargs&quot; 関数として知られています。varargs 関数は、最後の引数の後に省略記号をつけることで定義できます。</target>
        </trans-unit>
        <trans-unit id="67322f4620eb4bffc38ad6db6fb50c1b9b16e04a" translate="yes" xml:space="preserve">
          <source>It is often convenient to work with data structures that may contain values of any type (arrays of type &lt;code&gt;Array{Any}&lt;/code&gt;). But, if you're using one of these structures and happen to know the type of an element, it helps to share this knowledge with the compiler:</source>
          <target state="translated">多くの場合、任意の型の値（ &lt;code&gt;Array{Any}&lt;/code&gt; 型の配列）を含む可能性のあるデータ構造を操作すると便利です。ただし、これらの構造のいずれかを使用していて、要素のタイプをたまたま知っている場合は、この知識をコンパイラーと共有すると役立ちます。</target>
        </trans-unit>
        <trans-unit id="284677cc407d046b65013c8fed718805f3d17cb7" translate="yes" xml:space="preserve">
          <source>It is possible to constrain the number of values passed as a variable argument; this will be discussed later in &lt;a href=&quot;../methods/index#Parametrically-constrained-Varargs-methods-1&quot;&gt;Parametrically-constrained Varargs methods&lt;/a&gt;.</source>
          <target state="translated">可変引数として渡される値の数を制限することが可能です。これについては、「&lt;a href=&quot;../methods/index#Parametrically-constrained-Varargs-methods-1&quot;&gt;パラメトリックに制約されたVarargsメソッド」で&lt;/a&gt;後で説明します。</target>
        </trans-unit>
        <trans-unit id="a70320747de27e26b4b70f213eeadabc7679b96a" translate="yes" xml:space="preserve">
          <source>It is possible to define a set of function methods such that there is no unique most specific method applicable to some combinations of arguments:</source>
          <target state="translated">いくつかの引数の組み合わせに適用されるユニークで最も特異なメソッドが存在しないような関数メソッドのセットを定義することが可能です。</target>
        </trans-unit>
        <trans-unit id="deea519c4200e4fe336ac8810c406887e0570f07" translate="yes" xml:space="preserve">
          <source>It is possible to pass Julia functions to native C functions that accept function pointer arguments. For example, to match C prototypes of the form:</source>
          <target state="translated">Julia の関数を、関数ポインタの引数を受け取るネイティブの C 関数に渡すことができます。例えば、形式のCのプロトタイプにマッチするように。</target>
        </trans-unit>
        <trans-unit id="b862a89ec67717dcb808d8174cdd3cd9cf5de933" translate="yes" xml:space="preserve">
          <source>It is possible to write definitions like the following:</source>
          <target state="translated">のように定義を書くことができます。</target>
        </trans-unit>
        <trans-unit id="079123703d5fe6500844bec9cf4fbeb95441a39c" translate="yes" xml:space="preserve">
          <source>It is recommended that subtypes &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; override the following method signature to provide more efficient implementations: &lt;code&gt;unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</source>
          <target state="translated">サブタイプ &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; は、次のメソッドシグネチャをオーバーライドして、より効率的な実装を提供することをお勧めします： &lt;code&gt;unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4972fa162a33587e78213cfd46e68a922aa11ce5" translate="yes" xml:space="preserve">
          <source>It is recommended that subtypes &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; override the following method signature to provide more efficient implementations: &lt;code&gt;unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</source>
          <target state="translated">サブタイプ &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; は、次のメソッドシグネチャをオーバーライドして、より効率的な実装を提供することをお勧めします： &lt;code&gt;unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e657552abcb773fba2d1c58477efeff3641733f" translate="yes" xml:space="preserve">
          <source>It is recommended that the disambiguating method be defined first, since otherwise the ambiguity exists, if transiently, until the more specific method is defined.</source>
          <target state="translated">そうしないと、より具体的な方法が定義されるまでの間、一時的であっても曖昧さが存在するため、曖昧さを解消する方法を最初に定義することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="3205262d1b20d05a3ec0c7f09158500e89b8710e" translate="yes" xml:space="preserve">
          <source>It is safe to execute iterations in arbitrary or overlapping order, with special consideration for reduction variables.</source>
          <target state="translated">還元変数を特別に考慮して、任意の順序や重複した順序で反復実行しても安全です。</target>
        </trans-unit>
        <trans-unit id="d10887452da1b7a8299e792daec58426383fc305" translate="yes" xml:space="preserve">
          <source>It is significant that like &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt;, the expressions before and after the &lt;code&gt;:&lt;/code&gt; are only evaluated if the condition expression evaluates to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, respectively:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; - &lt;code&gt;elseif&lt;/code&gt; - &lt;code&gt;else&lt;/code&gt; のように、条件式が &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; にそれぞれ評価される場合にのみ、 &lt;code&gt;:&lt;/code&gt; の前後の式が評価されることが重要です。</target>
        </trans-unit>
        <trans-unit id="6abc534e54f65480aad0f619aee6267faddc4174" translate="yes" xml:space="preserve">
          <source>It is sometimes convenient to terminate the repetition of a &lt;code&gt;while&lt;/code&gt; before the test condition is falsified or stop iterating in a &lt;code&gt;for&lt;/code&gt; loop before the end of the iterable object is reached. This can be accomplished with the &lt;code&gt;break&lt;/code&gt; keyword:</source>
          <target state="translated">反復可能なオブジェクトの終わりに達する前に、テスト条件が偽造される前に &lt;code&gt;while&lt;/code&gt; 繰り返しを終了するか、 &lt;code&gt;for&lt;/code&gt; ループで反復を停止すると便利な場合があります。これは、 &lt;code&gt;break&lt;/code&gt; キーワードを使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="20dfcec28a6dd8951f574998a3986a215e74fce8" translate="yes" xml:space="preserve">
          <source>It is sometimes helpful during module development to turn off incremental precompilation. The command line flag &lt;code&gt;--compiled-modules={yes|no}&lt;/code&gt; enables you to toggle module precompilation on and off. When Julia is started with &lt;code&gt;--compiled-modules=no&lt;/code&gt; the serialized modules in the compile cache are ignored when loading modules and module dependencies. &lt;code&gt;Base.compilecache&lt;/code&gt; can still be called manually. The state of this command line flag is passed to &lt;code&gt;Pkg.build&lt;/code&gt; to disable automatic precompilation triggering when installing, updating, and explicitly building packages.</source>
          <target state="translated">モジュール開発中に増分プリコンパイルをオフにすると役立つ場合があります。コマンドラインフラグ &lt;code&gt;--compiled-modules={yes|no}&lt;/code&gt; 使用すると、モジュールのプリコンパイルのオンとオフを切り替えることができます。 Juliaを &lt;code&gt;--compiled-modules=no&lt;/code&gt; で起動すると、モジュールとモジュールの依存関係をロードするときに、コンパイルキャッシュ内のシリアル化されたモジュールが無視されます。 &lt;code&gt;Base.compilecache&lt;/code&gt; は引き続き手動で呼び出すことができます。このコマンドラインフラグの状態は &lt;code&gt;Pkg.build&lt;/code&gt; に渡され、パッケージのインストール、更新、および明示的なビルド時の自動プリコンパイルトリガーを無効にします。</target>
        </trans-unit>
        <trans-unit id="94baf48d740dae1d64cb4dabcdca4ac61d569c1b" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to close (unload) a library so that it can be reloaded. For instance, when developing C code for use with Julia, one may need to compile, call the C code from Julia, then close the library, make an edit, recompile, and load in the new changes. One can either restart Julia or use the &lt;code&gt;Libdl&lt;/code&gt; functions to manage the library explicitly, such as:</source>
          <target state="translated">ライブラリを再ロードできるように、ライブラリを閉じ（アンロード）すると便利な場合があります。たとえば、Juliaで使用するCコードを開発する場合は、コンパイルしてJuliaからCコードを呼び出し、ライブラリを閉じ、編集を行い、再コンパイルして、新しい変更を読み込む必要があります。Juliaを再起動するか、 &lt;code&gt;Libdl&lt;/code&gt; 関数を使用してライブラリを明示的に管理できます。</target>
        </trans-unit>
        <trans-unit id="32e81dce90195c032e275e55f3bfa20c146074b3" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to perform element-by-element binary operations on arrays of different sizes, such as adding a vector to each column of a matrix. An inefficient way to do this would be to replicate the vector to the size of the matrix:</source>
          <target state="translated">異なるサイズの配列に対して,行列の各列にベクトルを追加するような,要素毎のバイナリ処理を行うことが有用な場合があります.非効率的な方法としては,行列のサイズに合わせてベクトルを複製することが挙げられます.</target>
        </trans-unit>
        <trans-unit id="58d81677369240f5f99e6de14b72f59ff777800d" translate="yes" xml:space="preserve">
          <source>It is to be noted that this is generally not an issue. It is something to be factored in only if the object is both being stored locally and modifed post the call. In such cases it may be appropriate to store a &lt;code&gt;deepcopy&lt;/code&gt; of the object.</source>
          <target state="translated">これは一般に問題ではないことに注意してください。これは、オブジェクトがローカルに保存されており、呼び出し後に変更されている場合にのみ考慮されます。そのような場合、オブジェクトの &lt;code&gt;deepcopy&lt;/code&gt; を保存するのが適切な場合があります。</target>
        </trans-unit>
        <trans-unit id="4930241b205d76b9c3d495f83abf296392db54b7" translate="yes" xml:space="preserve">
          <source>It is usually best to avoid capturing references to instances of internal metadata objects such as &lt;code&gt;Method&lt;/code&gt;, &lt;code&gt;MethodInstance&lt;/code&gt;, &lt;code&gt;MethodTable&lt;/code&gt;, &lt;code&gt;TypeMapLevel&lt;/code&gt;, &lt;code&gt;TypeMapEntry&lt;/code&gt; and fields of those objects, as this can confuse the serializer and may not lead to the outcome you desire. It is not necessarily an error to do this, but you simply need to be prepared that the system will try to copy some of these and to create a single unique instance of others.</source>
          <target state="translated">それは、次のような内部メタデータのインスタンスオブジェクトへの参照を取得する避けることが最善である &lt;code&gt;Method&lt;/code&gt; 、 &lt;code&gt;MethodInstance&lt;/code&gt; 、 &lt;code&gt;MethodTable&lt;/code&gt; 、 &lt;code&gt;TypeMapLevel&lt;/code&gt; 、 &lt;code&gt;TypeMapEntry&lt;/code&gt; これはシリアライザを混同することができますし、あなたが望む結果につながらない可能性があるため、それらのオブジェクトのフィールド。これを行うのは必ずしもエラーではありませんが、システムがこれらの一部をコピーして、他のインスタンスを1つだけ作成しようとする準備ができているだけです。</target>
        </trans-unit>
        <trans-unit id="b19a6924f8364edbfe868e5511ad36bcb64fff31" translate="yes" xml:space="preserve">
          <source>It is usually not much help to construct arrays like the following:</source>
          <target state="translated">以下のような配列を構築するのは、通常はあまり役に立たない。</target>
        </trans-unit>
        <trans-unit id="e4380a1b0acd2209a89981ccd04cfa0fd834aaba" translate="yes" xml:space="preserve">
          <source>It is very important that the called function does not call back into Julia, as it will segfault.</source>
          <target state="translated">呼び出された関数が Julia にコールバックしないようにすることは非常に重要です。</target>
        </trans-unit>
        <trans-unit id="805fdc406fb3dba1fb93a133c29b22878b4c87dc" translate="yes" xml:space="preserve">
          <source>It may take optional keyword arguments:</source>
          <target state="translated">オプションのキーワード引数を取ることができます。</target>
        </trans-unit>
        <trans-unit id="9d3c85b9245c7315a1b23d4e146f385ddcbfb243" translate="yes" xml:space="preserve">
          <source>It means that the type of the output is predictable from the types of the inputs. In particular, it means that the type of the output cannot vary depending on the &lt;em&gt;values&lt;/em&gt; of the inputs. The following code is &lt;em&gt;not&lt;/em&gt; type-stable:</source>
          <target state="translated">これは、出力のタイプが入力のタイプから予測可能であることを意味します。特に、入力の&lt;em&gt;値&lt;/em&gt;によって出力のタイプが変化しないことを意味します。次のコードは型安定ではあり&lt;em&gt;ません&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="c3b7dcbf1418595d94f20981812341bdb45796ab" translate="yes" xml:space="preserve">
          <source>It only makes sense to take ratios of integer values, so the parameter type &lt;code&gt;T&lt;/code&gt; is restricted to being a subtype of &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, and a ratio of integers represents a value on the real number line, so any &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; is an instance of the &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; abstraction.</source>
          <target state="translated">整数値の比率を取ることは意味があるだけなので、パラメータータイプ &lt;code&gt;T&lt;/code&gt; は&lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; の&lt;/a&gt;サブタイプに制限され、整数の比率は実数線上の値を表すため、&lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;はすべて&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;抽象化のインスタンスです。</target>
        </trans-unit>
        <trans-unit id="a692191dac5658d6e6f21b53ff80758c81d0148d" translate="yes" xml:space="preserve">
          <source>It provides a mutable wrapper around an iterator and its iteration state.</source>
          <target state="translated">これは、イテレータとその反復状態の周りのミューター可能なラッパーを提供します。</target>
        </trans-unit>
        <trans-unit id="75d07a5f3996139947136e92cd3660ed889424cf" translate="yes" xml:space="preserve">
          <source>It returns either an &lt;code&gt;Int&lt;/code&gt; or a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; depending on the value of its argument. Since Julia can't predict the return type of this function at compile-time, any computation that uses it will have to guard against both types possibly occurring, making generation of fast machine code difficult.</source>
          <target state="translated">引数の値に応じて、 &lt;code&gt;Int&lt;/code&gt; または&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; を&lt;/a&gt;返します。Juliaはコンパイル時にこの関数の戻り値の型を予測できないため、この関数を使用する計算では両方の型が発生しないようにする必要があり、高速マシンコードの生成が困難になります。</target>
        </trans-unit>
        <trans-unit id="e13bba493365e2c5b2e76f0ae39f91eaa1b27bd1" translate="yes" xml:space="preserve">
          <source>It should however be noted that the compiler is quite efficient at optimizing away the dead branches in code written as the &lt;code&gt;mynorm&lt;/code&gt; example.</source>
          <target state="translated">ただし、コンパイラーは、 &lt;code&gt;mynorm&lt;/code&gt; の例として記述されたコードの不要なブランチを最適化するのに非常に効率的であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="429ea7fe9a07243d9d929909311d0c5286ba8da0" translate="yes" xml:space="preserve">
          <source>It turns an iterator-like abstraction into a &lt;code&gt;Channel&lt;/code&gt;-like abstraction.</source>
          <target state="translated">イテレータのような抽象化を &lt;code&gt;Channel&lt;/code&gt; ような抽象化に変えます。</target>
        </trans-unit>
        <trans-unit id="85d168e5e85b9af5b4b41b997ebf680755497e13" translate="yes" xml:space="preserve">
          <source>It's a good idea to first run the code you intend to profile at least once (unless you want to profile Julia's JIT-compiler):</source>
          <target state="translated">(JuliaのJITコンパイラをプロファイリングしたい場合を除いて)プロファイリングするコードを最初に少なくとも一度は実行することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6aa7c46c7a469a8066f30e0a6330c5f7107a8c6d" translate="yes" xml:space="preserve">
          <source>It's also possible to add cross-references to other documented functions/methods/variables within the Julia documentation itself. For example:</source>
          <target state="translated">また、Julia のドキュメント自体の中に、他のドキュメント化された関数/メソッド/変数との相互参照を追加することも可能です。例えば</target>
        </trans-unit>
        <trans-unit id="d58241f9f697434c4e06081f155d61314cbdb71e" translate="yes" xml:space="preserve">
          <source>It's an iterator that mutates to become its own rest iterator whenever an item is produced.</source>
          <target state="translated">これは、アイテムが生成されるたびに変異して自分自身のレストイテレータになるイテレータです。</target>
        </trans-unit>
        <trans-unit id="4aa36d32a2c02cf6990c1d5d08f2ca5067ed910f" translate="yes" xml:space="preserve">
          <source>It's easiest to illustrate this with an example. We can declare a generated function &lt;code&gt;foo&lt;/code&gt; as</source>
          <target state="translated">これを例で説明するのが最も簡単です。生成された関数 &lt;code&gt;foo&lt;/code&gt; を次のように宣言できます。</target>
        </trans-unit>
        <trans-unit id="38dda39f4395bbec3e9a522986faf60e028082c7" translate="yes" xml:space="preserve">
          <source>It's good practice when using any language/date framework to be familiar with how date-period arithmetic is handled as there are some &lt;a href=&quot;https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/&quot;&gt;tricky issues&lt;/a&gt; to deal with (though much less so for day-precision types).</source>
          <target state="translated">言語/日付フレームワークを使用する場合は、扱いが&lt;a href=&quot;https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/&quot;&gt;難しい問題&lt;/a&gt;があるため、日付と期間の算術の処理方法に慣れることをお勧めします（ただし、日精度の型の場合はそうではありません）。</target>
        </trans-unit>
        <trans-unit id="0640f8fda4ec7bf5464b3cee97ae0f4dda5ee1e4" translate="yes" xml:space="preserve">
          <source>It's important to be aware of potentially dangerous situations such as concatenation of invalid UTF-8 strings. The resulting string may contain different characters than the input strings, and its number of characters may be lower than sum of numbers of characters of the concatenated strings, e.g.:</source>
          <target state="translated">無効なUTF-8文字列の連結など、潜在的に危険な状況に注意することが重要です。結果として得られる文字列には入力文字列とは異なる文字が含まれている可能性があり、その文字数は連結された文字列の文字数の合計よりも少ない可能性があります。</target>
        </trans-unit>
        <trans-unit id="3dbecc240e8c1b98fcd4c298d9a96ae72e276750" translate="yes" xml:space="preserve">
          <source>It's important to note that there's a very large assymmetry in the performance of these conversions. Converting a linear index to a set of cartesian indices requires dividing and taking the remainder, whereas going the other way is just multiplies and adds. In modern processors, integer division can be 10-50 times slower than multiplication. While some arrays &amp;mdash; like &lt;a href=&quot;../../base/arrays/index#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; itself &amp;mdash; are implemented using a linear chunk of memory and directly use a linear index in their implementations, other arrays &amp;mdash; like &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt; &amp;mdash; need the full set of cartesian indices to do their lookup (see &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;IndexStyle&lt;/code&gt;&lt;/a&gt; to introspect which is which). As such, when iterating over an entire array, it's much better to iterate over &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex(A)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;1:length(A)&lt;/code&gt;. Not only will the former be much faster in cases where &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;IndexCartesian&lt;/code&gt;, but it will also support OffsetArrays, too.</source>
          <target state="translated">これらの変換のパフォーマンスには非常に大きな非対称性があることに注意することが重要です。線形インデックスをデカルトインデックスのセットに変換するには、残りの部分を除算して取得する必要がありますが、逆の方法は乗算と加算だけです。最近のプロセッサでは、整数の除算は乗算より10〜50倍遅くなることがあります。&lt;a href=&quot;../../base/arrays/index#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt;自体のような一部の配列は、メモリの線形チャンクを使用して実装され、その実装では線形インデックスを直接使用しますが、&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.Diagonal&quot;&gt; &lt;code&gt;Diagonal&lt;/code&gt; &lt;/a&gt;などの他の配列は、ルックアップを実行するためにデカルトインデックスの完全なセットを必要とします（これをイントロ&lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt; &lt;code&gt;IndexStyle&lt;/code&gt; &lt;/a&gt;するにはIndexStyleを参照してください）どちらか）。したがって、配列全体を反復する場合は、代わりに&lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex(A)&lt;/code&gt; &lt;/a&gt;を反復する方がはるかに優れています。 &lt;code&gt;1:length(A)&lt;/code&gt; 。前者は &lt;code&gt;A&lt;/code&gt; が &lt;code&gt;IndexCartesian&lt;/code&gt; である場合にはるかに高速になるだけでなく、OffsetArrayもサポートします。</target>
        </trans-unit>
        <trans-unit id="53f0c889cfa216f7a561510a3ad57de629360e4b" translate="yes" xml:space="preserve">
          <source>It's now possible to get a sampler with &lt;code&gt;sp = Sampler(rng, die)&lt;/code&gt;, and use &lt;code&gt;sp&lt;/code&gt; instead of &lt;code&gt;die&lt;/code&gt; in any &lt;code&gt;rand&lt;/code&gt; call involving &lt;code&gt;rng&lt;/code&gt;. In the simplistic example above, &lt;code&gt;die&lt;/code&gt; doesn't need to be stored in &lt;code&gt;SamplerDie&lt;/code&gt; but this is often the case in practice.</source>
          <target state="translated">これは、とのサンプラーを取得できるようになりました &lt;code&gt;sp = Sampler(rng, die)&lt;/code&gt; 、および使用の &lt;code&gt;sp&lt;/code&gt; の代わりに、 &lt;code&gt;die&lt;/code&gt; いずれにおいても、 &lt;code&gt;rand&lt;/code&gt; 関与コール &lt;code&gt;rng&lt;/code&gt; 。上記の単純な例では、 &lt;code&gt;die&lt;/code&gt; を &lt;code&gt;SamplerDie&lt;/code&gt; に格納する必要はありませんが、実際にはそうであることがよくあります。</target>
        </trans-unit>
        <trans-unit id="435e5d30b709899a41a3dc97d975e671346837d6" translate="yes" xml:space="preserve">
          <source>It's quite instructive to compare the sheer amount code generated for a simple function</source>
          <target state="translated">単純な関数のために生成されたコードの量を比較するのは非常に有益です。</target>
        </trans-unit>
        <trans-unit id="485af6f7d5c0b66af203ac099b1bf7b0eba726ba" translate="yes" xml:space="preserve">
          <source>It's worth emphasizing that &lt;code&gt;localindices&lt;/code&gt; exists purely as a convenience, and you can partition work on the array among workers any way you wish. For a &lt;code&gt;SharedArray&lt;/code&gt;, all indices should be equally fast for each worker process.</source>
          <target state="translated">&lt;code&gt;localindices&lt;/code&gt; は純粋に便利なものとして存在し、アレイ上の作業をワーカー間で任意の方法で分割できることを強調する価値があります。 &lt;code&gt;SharedArray&lt;/code&gt; 、すべてのインデックスは、各ワーカー・プロセスにも同様に高速である必要があります。</target>
        </trans-unit>
        <trans-unit id="7d5d6404960db7e0b184fd1dfa040fb8f1124932" translate="yes" xml:space="preserve">
          <source>It's worth noting that it's extremely easy to mis-use parametric &quot;value&quot; types, including &lt;code&gt;Val&lt;/code&gt;; in unfavorable cases, you can easily end up making the performance of your code much &lt;em&gt;worse&lt;/em&gt;. In particular, you would never want to write actual code as illustrated above. For more information about the proper (and improper) uses of &lt;code&gt;Val&lt;/code&gt;, please read the more extensive discussion in &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;the performance tips&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; を含むパラメトリックな「値」型を誤用することが非常に簡単であることは注目に値します。不利な場合には、コードのパフォーマンスが大幅に&lt;em&gt;低下&lt;/em&gt;する可能性があります。特に、上記のように実際のコードを記述したくない場合があります。 &lt;code&gt;Val&lt;/code&gt; の適切な（および不適切な）使用方法の詳細については&lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;、パフォーマンスのヒントの&lt;/a&gt;より広範な議論をお読みください。</target>
        </trans-unit>
        <trans-unit id="3b9b0722d0d43e4d14ff92cca723a64b8e24e4f0" translate="yes" xml:space="preserve">
          <source>Italics</source>
          <target state="translated">Italics</target>
        </trans-unit>
        <trans-unit id="c218bb3261ced0b188316d903cb0484a6a43b61a" translate="yes" xml:space="preserve">
          <source>Iterable Collections</source>
          <target state="translated">反復可能なコレクション</target>
        </trans-unit>
        <trans-unit id="81a99e5d5fc07b72d6b1647c497a7c5192f69fad" translate="yes" xml:space="preserve">
          <source>Iterate over a collection &lt;code&gt;n&lt;/code&gt; elements at a time.</source>
          <target state="translated">一度に &lt;code&gt;n&lt;/code&gt; 個の要素のコレクションを反復処理します。</target>
        </trans-unit>
        <trans-unit id="7878c863963cb51356acf7ca3e8ea44be505a483" translate="yes" xml:space="preserve">
          <source>Iterated dispatch</source>
          <target state="translated">反復派遣</target>
        </trans-unit>
        <trans-unit id="42206b6c92650b3931037fd07719156176dc0314" translate="yes" xml:space="preserve">
          <source>Iterating over the &lt;code&gt;CartesianIndices&lt;/code&gt; of the &lt;code&gt;axes(::Broadcasted)&lt;/code&gt; and using indexing with the resulting &lt;code&gt;CartesianIndex&lt;/code&gt; object to compute the result.</source>
          <target state="translated">&lt;code&gt;axes(::Broadcasted)&lt;/code&gt; の &lt;code&gt;CartesianIndices&lt;/code&gt; を反復処理し、結果の &lt;code&gt;CartesianIndex&lt;/code&gt; オブジェクトでインデックスを使用して結果を計算します。</target>
        </trans-unit>
        <trans-unit id="a4979919b853dff1595ccf476a13a01680f6c472" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;F.S&lt;/code&gt;, &lt;code&gt;F.T&lt;/code&gt;, &lt;code&gt;F.Q&lt;/code&gt;, &lt;code&gt;F.Z&lt;/code&gt;, &lt;code&gt;F.&amp;alpha;&lt;/code&gt;, and &lt;code&gt;F.&amp;beta;&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、成分 &lt;code&gt;F.S&lt;/code&gt; 、 &lt;code&gt;F.T&lt;/code&gt; 、 &lt;code&gt;F.Q&lt;/code&gt; 、 &lt;code&gt;F.Z&lt;/code&gt; 、 &lt;code&gt;F.&amp;alpha;&lt;/code&gt; 、および &lt;code&gt;F.&amp;beta;&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="fc67e8a927f1aa6eff5ad47840e758df966f518f" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;F.T&lt;/code&gt;, &lt;code&gt;F.Z&lt;/code&gt;, and &lt;code&gt;F.values&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、コンポーネント &lt;code&gt;F.T&lt;/code&gt; 、 &lt;code&gt;F.Z&lt;/code&gt; 、および &lt;code&gt;F.values&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="f4d4ad8d2cf2c1ee9c60ddef640294bbac58cbc2" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;F.values&lt;/code&gt; and &lt;code&gt;F.vectors&lt;/code&gt;.</source>
          <target state="translated">分解を &lt;code&gt;F.values&lt;/code&gt; と、コンポーネントF.valuesと &lt;code&gt;F.vectors&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="86506020c8187a26d343a03489380c16723ff386" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;Q&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、コンポーネント &lt;code&gt;Q&lt;/code&gt; および &lt;code&gt;R&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="0eea487785d89d96fdac640a6604fc8fe54c944d" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;Q&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, and &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、コンポーネント &lt;code&gt;Q&lt;/code&gt; 、 &lt;code&gt;R&lt;/code&gt; 、および &lt;code&gt;p&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="cab411fc4fe9253bda3d235df40d5dfd6ef9668c" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;Q&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, and if extant &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、成分 &lt;code&gt;Q&lt;/code&gt; 、 &lt;code&gt;R&lt;/code&gt; 、および存在する場合は &lt;code&gt;p&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="b3b6360c2464673a0e4fb9b1ed45a041967155d6" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;S.D&lt;/code&gt;, &lt;code&gt;S.U&lt;/code&gt; or &lt;code&gt;S.L&lt;/code&gt; as appropriate given &lt;code&gt;S.uplo&lt;/code&gt;, and &lt;code&gt;S.p&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、必要に応じて &lt;code&gt;S.uplo&lt;/code&gt; と &lt;code&gt;S.p&lt;/code&gt; のコンポーネント &lt;code&gt;S.D&lt;/code&gt; 、 &lt;code&gt;S.U&lt;/code&gt; または &lt;code&gt;S.L&lt;/code&gt; れます。</target>
        </trans-unit>
        <trans-unit id="f77bd282f84af7bfe48cdf3c4e7e8dc8c570cc8e" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;S.L&lt;/code&gt; and &lt;code&gt;S.Q&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、コンポーネント &lt;code&gt;S.L&lt;/code&gt; および &lt;code&gt;S.Q&lt;/code&gt; 生成されます。</target>
        </trans-unit>
        <trans-unit id="89ebce396ac9da86f707ddc5cfcf6229ef6143e2" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, and &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、成分 &lt;code&gt;U&lt;/code&gt; 、 &lt;code&gt;S&lt;/code&gt; 、および &lt;code&gt;V&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="c715668f8440af4b021f6c74fa32fef39d559c06" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;Q&lt;/code&gt;, &lt;code&gt;D1&lt;/code&gt;, &lt;code&gt;D2&lt;/code&gt;, and &lt;code&gt;R0&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、成分 &lt;code&gt;U&lt;/code&gt; 、 &lt;code&gt;V&lt;/code&gt; 、 &lt;code&gt;Q&lt;/code&gt; 、 &lt;code&gt;D1&lt;/code&gt; 、 &lt;code&gt;D2&lt;/code&gt; 、および &lt;code&gt;R0&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="b09a0a43519ceb489793a2ede6c213029b86bdfc" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the factors &lt;code&gt;F.Q&lt;/code&gt; and &lt;code&gt;F.H&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、係数 &lt;code&gt;F.Q&lt;/code&gt; および &lt;code&gt;F.H&lt;/code&gt; 生成されます。</target>
        </trans-unit>
        <trans-unit id="f58aa126be8fea0928c97cbc1c2e33d08204701b" translate="yes" xml:space="preserve">
          <source>Iterating the factorization produces the components &lt;code&gt;F.L&lt;/code&gt;, &lt;code&gt;F.U&lt;/code&gt;, and &lt;code&gt;F.p&lt;/code&gt;.</source>
          <target state="translated">因数分解を繰り返すと、コンポーネント &lt;code&gt;F.L&lt;/code&gt; 、 &lt;code&gt;F.U&lt;/code&gt; 、および &lt;code&gt;F.p&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="ca49cf020b23404ede665f3ef9ef58b961aea893" translate="yes" xml:space="preserve">
          <source>Iteration over &lt;code&gt;NamedTuple&lt;/code&gt;s produces the &lt;em&gt;values&lt;/em&gt; without the names. (See example below.) To iterate over the name-value pairs, use the &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;NamedTuple&lt;/code&gt; の反復により、名前なしの&lt;em&gt;値が&lt;/em&gt;生成され&lt;em&gt;ます&lt;/em&gt;。（下の例を参照してください。）名前と値のペアを反復処理するには、&lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs&lt;/code&gt; &lt;/a&gt;関数を使用します。</target>
        </trans-unit>
        <trans-unit id="029d5196356372d794cb53808ecda6f8a64c6198" translate="yes" xml:space="preserve">
          <source>Iteration utilities</source>
          <target state="translated">イテレーションユーティリティ</target>
        </trans-unit>
        <trans-unit id="bc1f336bbebec9ed2484b3179ad56691be7b079d" translate="yes" xml:space="preserve">
          <source>IteratorEltype</source>
          <target state="translated">IteratorEltype</target>
        </trans-unit>
        <trans-unit id="762bcf9ad00a1c98c7dfe72f3f1da300a726ae97" translate="yes" xml:space="preserve">
          <source>IteratorSize</source>
          <target state="translated">IteratorSize</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="ade312c99a3f29ec263e6761dccc45de6d98af27" translate="yes" xml:space="preserve">
          <source>Iterators.Pairs</source>
          <target state="translated">Iterators.Pairs</target>
        </trans-unit>
        <trans-unit id="7f99860914bab93742ec0677d93601e7f754aab7" translate="yes" xml:space="preserve">
          <source>Iterators.Stateful</source>
          <target state="translated">Iterators.Stateful</target>
        </trans-unit>
        <trans-unit id="4b22c43fb78a467e966bea6e6bf82f640caa802a" translate="yes" xml:space="preserve">
          <source>Iterators.countfrom()</source>
          <target state="translated">Iterators.countfrom()</target>
        </trans-unit>
        <trans-unit id="6e9ea1a37868f81f1c387104af3ddce669dd91f6" translate="yes" xml:space="preserve">
          <source>Iterators.cycle()</source>
          <target state="translated">Iterators.cycle()</target>
        </trans-unit>
        <trans-unit id="15fc1b0f962745a0f7d6dddec1a5029f764fddf9" translate="yes" xml:space="preserve">
          <source>Iterators.drop()</source>
          <target state="translated">Iterators.drop()</target>
        </trans-unit>
        <trans-unit id="b622262f6019cdcf33dc40c2166a76e9968c2d6f" translate="yes" xml:space="preserve">
          <source>Iterators.enumerate()</source>
          <target state="translated">Iterators.enumerate()</target>
        </trans-unit>
        <trans-unit id="18c6e2577f1cb3f1df18e8349820ab2df102ed03" translate="yes" xml:space="preserve">
          <source>Iterators.filter()</source>
          <target state="translated">Iterators.filter()</target>
        </trans-unit>
        <trans-unit id="1c4406a3948ea47560dd3a48a99cedb41058481a" translate="yes" xml:space="preserve">
          <source>Iterators.flatten()</source>
          <target state="translated">Iterators.flatten()</target>
        </trans-unit>
        <trans-unit id="e6b2ae68200d1658f8b9b58b1bda15c7a94398ec" translate="yes" xml:space="preserve">
          <source>Iterators.partition()</source>
          <target state="translated">Iterators.partition()</target>
        </trans-unit>
        <trans-unit id="8d055b9ee1bc21393531304979f760c0dcaf8ed7" translate="yes" xml:space="preserve">
          <source>Iterators.product()</source>
          <target state="translated">Iterators.product()</target>
        </trans-unit>
        <trans-unit id="f82f74da2e638549fe42f2abf5e3d47275b9d6dc" translate="yes" xml:space="preserve">
          <source>Iterators.repeated()</source>
          <target state="translated">Iterators.repeated()</target>
        </trans-unit>
        <trans-unit id="d0a4aaf299b047ef88d9088cb3265b8c9ec460f8" translate="yes" xml:space="preserve">
          <source>Iterators.rest()</source>
          <target state="translated">Iterators.rest()</target>
        </trans-unit>
        <trans-unit id="78c5327cecfd4b16a167206d910e94f07f9e5a1d" translate="yes" xml:space="preserve">
          <source>Iterators.reverse()</source>
          <target state="translated">Iterators.reverse()</target>
        </trans-unit>
        <trans-unit id="1780ae66e17e617d0386e7c850f35f9a46563eec" translate="yes" xml:space="preserve">
          <source>Iterators.take()</source>
          <target state="translated">Iterators.take()</target>
        </trans-unit>
        <trans-unit id="38d733610a11317778f298c2adaafc9ed0e772f3" translate="yes" xml:space="preserve">
          <source>Iterators.zip()</source>
          <target state="translated">Iterators.zip()</target>
        </trans-unit>
        <trans-unit id="e5c9811ac9fab746e9ba97b16b953053ef624d64" translate="yes" xml:space="preserve">
          <source>IteratorsMD.CartesianIndex</source>
          <target state="translated">IteratorsMD.CartesianIndex</target>
        </trans-unit>
        <trans-unit id="dab2cf0daf838d270ad35eb4a74061238bf4a503" translate="yes" xml:space="preserve">
          <source>IteratorsMD.CartesianIndices</source>
          <target state="translated">IteratorsMD.CartesianIndices</target>
        </trans-unit>
        <trans-unit id="30ab5c44fe067198393909d62c86b0c386a162b7" translate="yes" xml:space="preserve">
          <source>Its second argument &lt;code&gt;args&lt;/code&gt; is an array of &lt;code&gt;jl_value_t*&lt;/code&gt; arguments and &lt;code&gt;nargs&lt;/code&gt; is the number of arguments.</source>
          <target state="translated">2番目の引数 &lt;code&gt;args&lt;/code&gt; は &lt;code&gt;jl_value_t*&lt;/code&gt; 引数の配列であり、 &lt;code&gt;nargs&lt;/code&gt; は引数の数です。</target>
        </trans-unit>
        <trans-unit id="286bb02d594ea15955d87681e8267067be410857" translate="yes" xml:space="preserve">
          <source>Izakaya Lantern</source>
          <target state="translated">居酒屋灯籠</target>
        </trans-unit>
        <trans-unit id="2f5fc08c12a2ccfd9c859b035ca12cb9526ce0af" translate="yes" xml:space="preserve">
          <source>J R Bunch and L Kaufman, Some stable methods for calculating inertia</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="831fdbe2f742b632acf268054e5932135a416335" translate="yes" xml:space="preserve">
          <source>Jack-O-Lantern</source>
          <target state="translated">Jack-O-Lantern</target>
        </trans-unit>
        <trans-unit id="efed3690ea2243f5f1ac77cbb0987e5335440258" translate="yes" xml:space="preserve">
          <source>Jan</source>
          <target state="translated">Jan</target>
        </trans-unit>
        <trans-unit id="7a22d73d336abd6281d4dd71080220a230cb79de" translate="yes" xml:space="preserve">
          <source>January</source>
          <target state="translated">January</target>
        </trans-unit>
        <trans-unit id="ad6d155a582ef676e9240bfd2300a9eb9553e4f3" translate="yes" xml:space="preserve">
          <source>Japanese Castle</source>
          <target state="translated">日本の城</target>
        </trans-unit>
        <trans-unit id="ed8bfe0cf71057039bd166fcb8a33ed47c1d1057" translate="yes" xml:space="preserve">
          <source>Japanese Dolls</source>
          <target state="translated">雛人形</target>
        </trans-unit>
        <trans-unit id="97302784bd85c6fc3ccdcadbac4da292edfbb8ba" translate="yes" xml:space="preserve">
          <source>Japanese Goblin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7263dbff30ade45b8568943da751abb88bf70826" translate="yes" xml:space="preserve">
          <source>Japanese Ogre</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="134fe6f595c84ed345de3ae0637be6654696bcaa" translate="yes" xml:space="preserve">
          <source>Japanese Post Office</source>
          <target state="translated">ゆうびんきょく</target>
        </trans-unit>
        <trans-unit id="0239b1f09d4f7c4b093fb50eb113f3c45f2d4d30" translate="yes" xml:space="preserve">
          <source>Japanese Symbol For Beginner</source>
          <target state="translated">初心者のための日本のシンボル</target>
        </trans-unit>
        <trans-unit id="d1e9767d8a0bd6d2bf67011d187d114cce67abb1" translate="yes" xml:space="preserve">
          <source>Jeans</source>
          <target state="translated">Jeans</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="76788f50771e86fe282c9d53f0b06082b3018e7d" translate="yes" xml:space="preserve">
          <source>Join an array of &lt;code&gt;strings&lt;/code&gt; into a single string, inserting the given delimiter between adjacent strings. If &lt;code&gt;last&lt;/code&gt; is given, it will be used instead of &lt;code&gt;delim&lt;/code&gt; between the last two strings. If &lt;code&gt;io&lt;/code&gt; is given, the result is written to &lt;code&gt;io&lt;/code&gt; rather than returned as as a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strings&lt;/code&gt; の配列を1つの文字列に結合し、隣接する文字列の間に指定の区切り文字を挿入します。場合は &lt;code&gt;last&lt;/code&gt; 指定され、それが代わりに使用されます &lt;code&gt;delim&lt;/code&gt; を最後の二つの文字列の間。場合は &lt;code&gt;io&lt;/code&gt; 付与され、その結果が書き込まれる &lt;code&gt;io&lt;/code&gt; としてではなくとして返さ &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0499501b2bb39022852369c1a09b6f3fb6fc16a6" translate="yes" xml:space="preserve">
          <source>Join path components into a full path. If some argument is an absolute path or (on Windows) has a drive specification that doesn't match the drive computed for the join of the preceding paths, then prior components are dropped.</source>
          <target state="translated">パスのコンポーネントをフルパスに結合します。引数の一部が絶対パスであったり、(Windowsでは)ドライブの指定が先行するパスの結合のために計算されたドライブと一致しない場合、先行するコンポーネントは削除されます。</target>
        </trans-unit>
        <trans-unit id="e64d664b335757ab1b0ed70dc6883a5f412be34b" translate="yes" xml:space="preserve">
          <source>Julia</source>
          <target state="translated">Julia</target>
        </trans-unit>
        <trans-unit id="34915350c4729155e12aa2a18e1437b46a254b8d" translate="yes" xml:space="preserve">
          <source>Julia 1.1</source>
          <target state="translated">ジュリア 1.1</target>
        </trans-unit>
        <trans-unit id="20d44d7c210bfc70cdc873c771c707c9f3303af5" translate="yes" xml:space="preserve">
          <source>Julia 1.2</source>
          <target state="translated">ジュリア 1.2</target>
        </trans-unit>
        <trans-unit id="8b642007f455f270d5f4ca8eeb353a9cd627fd87" translate="yes" xml:space="preserve">
          <source>Julia 1.2 Documentation</source>
          <target state="translated">Julia 1.2 ドキュメント</target>
        </trans-unit>
        <trans-unit id="858ca45563192af10cdc21c94e7d577c6f26612b" translate="yes" xml:space="preserve">
          <source>Julia Base Type</source>
          <target state="translated">ジュリアベースタイプ</target>
        </trans-unit>
        <trans-unit id="c3d7a86babfba0e54357fb2d1ed82f5bfe9ac6bf" translate="yes" xml:space="preserve">
          <source>Julia Base contains a range of functions and macros appropriate for performing scientific and numerical computing, but is also as broad as those of many general purpose programming languages. Additional functionality is available from a growing collection of available packages. Functions are grouped by topic below.</source>
          <target state="translated">Julia Baseには、科学的計算や数値計算を行うのに適した関数やマクロが含まれていますが、多くの汎用プログラミング言語と同じくらい幅広い機能を持っています。追加機能は、利用可能なパッケージのコレクションから利用することができます。関数は以下のトピックごとにグループ化されています。</target>
        </trans-unit>
        <trans-unit id="ecea329751a7da4bad931e777e922977157ad8f8" translate="yes" xml:space="preserve">
          <source>Julia Base uses this convention throughout and contains examples of functions with both copying and modifying forms (e.g., &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;), and others which are just modifying (e.g., &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.pop!&quot;&gt;&lt;code&gt;pop!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.splice!&quot;&gt;&lt;code&gt;splice!&lt;/code&gt;&lt;/a&gt;). It is typical for such functions to also return the modified array for convenience.</source>
          <target state="translated">ジュリアベースは全体でこの規則を使用してコピーし、フォームの変更の両方で機能の例が含まれています（例えば、&lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;し、&lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt;）、そしてちょうど変更されている他のもの（例えば、&lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/collections/index#Base.pop!&quot;&gt; &lt;code&gt;pop!&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/collections/index#Base.splice!&quot;&gt; &lt;code&gt;splice!&lt;/code&gt; &lt;/a&gt;）。このような関数は、便宜上、変更された配列も返すのが一般的です。</target>
        </trans-unit>
        <trans-unit id="7694e2fcb791d9c25c404da14cf2f301a28f48ea" translate="yes" xml:space="preserve">
          <source>Julia Coroutines (Green Threading)</source>
          <target state="translated">ジュリア・コルチン(緑のスレッディング</target>
        </trans-unit>
        <trans-unit id="79e749c34e72bbae64d0f791f7a71e619f74aae2" translate="yes" xml:space="preserve">
          <source>Julia GPU man pages</source>
          <target state="translated">ジュリアGPUマンページ</target>
        </trans-unit>
        <trans-unit id="a42ee146344a47614f0b605c9369dddac1347289" translate="yes" xml:space="preserve">
          <source>Julia Releases</source>
          <target state="translated">ジュリアのリリース</target>
        </trans-unit>
        <trans-unit id="8d8d2a4a743981227407130fd283bf2436f883ac" translate="yes" xml:space="preserve">
          <source>Julia aims to create an unprecedented combination of ease-of-use, power, and efficiency in a single language. In addition to the above, some advantages of Julia over comparable systems include:</source>
          <target state="translated">Juliaは、使いやすさ、パワー、効率性を単一言語で実現することを目指しています。上記に加えて、同等のシステムと比較した場合のJuliaの利点としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="05d11d59ee07392ef31079bd1e459ad76c3f824e" translate="yes" xml:space="preserve">
          <source>Julia allows an optional trailing comma when that comma does not change the meaning of code. This can cause confusion among R users when indexing into arrays. For example, &lt;code&gt;x[1,]&lt;/code&gt; in R would return the first row of a matrix; in Julia, however, the comma is ignored, so &lt;code&gt;x[1,] == x[1]&lt;/code&gt;, and will return the first element. To extract a row, be sure to use &lt;code&gt;:&lt;/code&gt;, as in &lt;code&gt;x[1,:]&lt;/code&gt;.</source>
          <target state="translated">Juliaは、コンマがコードの意味を変更しない場合、オプションの末尾のコンマを許可します。これにより、配列にインデックスを付けるときに、Rユーザー間で混乱が生じる可能性があります。たとえば、Rの &lt;code&gt;x[1,]&lt;/code&gt; は、行列の最初の行を返します。ただし、ジュリアでは、コンマは無視されるため、 &lt;code&gt;x[1,] == x[1]&lt;/code&gt; であり、最初の要素を返します。行を抽出するには、 &lt;code&gt;x[1,:]&lt;/code&gt; ように、必ず &lt;code&gt;:&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="c83ba6941f781ea6f95d544e9edf743cc32b5bdb" translate="yes" xml:space="preserve">
          <source>Julia also defines the types &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;UInt&lt;/code&gt;, which are aliases for the system's signed and unsigned native integer types respectively:</source>
          <target state="translated">Juliaは、 &lt;code&gt;Int&lt;/code&gt; および &lt;code&gt;UInt&lt;/code&gt; 型も定義します。これらは、それぞれシステムの符号付きおよび符号なしネイティブ整数型のエイリアスです。</target>
        </trans-unit>
        <trans-unit id="5b4f0844a2699d5ea273cd05f5a3f5753244a2f6" translate="yes" xml:space="preserve">
          <source>Julia also provides &lt;code&gt;*&lt;/code&gt; for string concatenation:</source>
          <target state="translated">Juliaは、文字列連結のための &lt;code&gt;*&lt;/code&gt; も提供しています。</target>
        </trans-unit>
        <trans-unit id="42a5af28aae285694adf3f30e69a77a9764131d7" translate="yes" xml:space="preserve">
          <source>Julia also provides the &lt;a href=&quot;../../base/numbers/index#Base.nextfloat&quot;&gt;&lt;code&gt;nextfloat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Base.prevfloat&quot;&gt;&lt;code&gt;prevfloat&lt;/code&gt;&lt;/a&gt; functions which return the next largest or smallest representable floating-point number to the argument respectively:</source>
          <target state="translated">Juliaは、次の最大または最小の表現可能な浮動小数点数をそれぞれ引数に返す、&lt;a href=&quot;../../base/numbers/index#Base.nextfloat&quot;&gt; &lt;code&gt;nextfloat&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../base/numbers/index#Base.prevfloat&quot;&gt; &lt;code&gt;prevfloat&lt;/code&gt; &lt;/a&gt;関数も提供します。</target>
        </trans-unit>
        <trans-unit id="06ed8be5c06d7dc93b6c0404ce3653f58e45b54f" translate="yes" xml:space="preserve">
          <source>Julia also supports &lt;a href=&quot;#man-multithreading-1&quot;&gt;experimental multi-threading&lt;/a&gt;, where execution is forked and an anonymous function is run across all threads. Known as the fork-join approach, parallel threads execute independently, and must ultimately be joined in Julia's main thread to allow serial execution to continue. Multi-threading is supported using the &lt;a href=&quot;../../base/multi-threading/index#lib-multithreading-1&quot;&gt;&lt;code&gt;Base.Threads&lt;/code&gt;&lt;/a&gt; module that is still considered experimental, as Julia is not yet fully thread-safe. In particular segfaults seem to occur during I/O operations and task switching. As an up-to-date reference, keep an eye on &lt;a href=&quot;https://github.com/JuliaLang/julia/issues?q=is%3Aopen+is%3Aissue+label%3Amultithreading&quot;&gt;the issue tracker&lt;/a&gt;. Multi-Threading should only be used if you take into consideration global variables, locks and atomics, all of which are explained later.</source>
          <target state="translated">Juliaは&lt;a href=&quot;#man-multithreading-1&quot;&gt;実験的なマルチスレッド化&lt;/a&gt;もサポートします。この場合、実行が分岐され、匿名関数がすべてのスレッドで実行されます。フォーク結合アプローチとして知られている並列スレッドは独立して実行され、最終的にジュリアのメインスレッドに結合して、シリアル実行を継続する必要があります。Juliaはまだ完全にスレッドセーフではないため、マルチスレッドは、まだ実験的と見なされている&lt;a href=&quot;../../base/multi-threading/index#lib-multithreading-1&quot;&gt; &lt;code&gt;Base.Threads&lt;/code&gt; &lt;/a&gt;モジュールを使用してサポートされます。特に、segfaultはI / O操作とタスクの切り替え中に発生するようです。最新のリファレンスとして&lt;a href=&quot;https://github.com/JuliaLang/julia/issues?q=is%3Aopen+is%3Aissue+label%3Amultithreading&quot;&gt;、課題トラッカーに&lt;/a&gt;注意してください。マルチスレッディングは、グローバル変数、ロック、およびアトミックを考慮する場合にのみ使用する必要があります。これらはすべて後で説明します。</target>
        </trans-unit>
        <trans-unit id="ab93a47c44a4029660cdea5a681e67f3452b925f" translate="yes" xml:space="preserve">
          <source>Julia and C can share array data without copying. The next example will show how this works.</source>
          <target state="translated">JuliaとCはコピーせずに配列データを共有することができます。次の例では、これがどのように動作するかを示します。</target>
        </trans-unit>
        <trans-unit id="989b4bbc6cbc89a53b5cc95fd259449cc83265cf" translate="yes" xml:space="preserve">
          <source>Julia and its package ecosystem includes tools that may help you diagnose problems and improve the performance of your code:</source>
          <target state="translated">Julia とそのパッケージのエコシステムには、問題を診断してコードのパフォーマンスを向上させるのに役立つツールが含まれています。</target>
        </trans-unit>
        <trans-unit id="bb6140d98b962ed45444f6097b48c1ab7b34b758" translate="yes" xml:space="preserve">
          <source>Julia applies the following order and associativity of operations, from highest precedence to lowest:</source>
          <target state="translated">ジュリアは、優先順位の高いものから低いものまで、次のような順序と連想性を適用します。</target>
        </trans-unit>
        <trans-unit id="79e54f86310ed0d0b6726cbc9118645ff3e41ba9" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas C/C++ arrays are row major ordered by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to C/C++ (see relevant section of &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;).</source>
          <target state="translated">Julia配列は列優先（Fortran順）ですが、C / C ++配列はデフォルトで行優先です。配列をループするときに最適なパフォーマンスを得るには、C / C ++に対してJuliaでループの順序を逆にする必要があります（「&lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;パフォーマンスのヒント&lt;/a&gt;」の関連セクションを参照）。</target>
        </trans-unit>
        <trans-unit id="101c9a575d6ee596869371a0022ecfe27370c862" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas NumPy arrays are row major (C-ordered) by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to NumPy (see relevant section of &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;).</source>
          <target state="translated">Julia配列は列優先（Fortran順）ですが、NumPy配列はデフォルトで行優先（C順）です。配列をループするときに最適なパフォーマンスを得るには、ループの順序をNumPyに対してJuliaで逆にする必要があります（&lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;パフォーマンスのヒントの&lt;/a&gt;関連セクションを参照）。</target>
        </trans-unit>
        <trans-unit id="4295a55355c53bb69700ac344333d3ad56193792" translate="yes" xml:space="preserve">
          <source>Julia arrays are indexed with square brackets, &lt;code&gt;A[i,j]&lt;/code&gt;.</source>
          <target state="translated">Julia配列は、角括弧 &lt;code&gt;A[i,j]&lt;/code&gt; インデックスが付けられます。</target>
        </trans-unit>
        <trans-unit id="6ee791aabb20af6c1bfdaa172e030af0dec26574" translate="yes" xml:space="preserve">
          <source>Julia arrays are indexed with square brackets, and can have more than one dimension &lt;code&gt;A[i,j]&lt;/code&gt;. This syntax is not just syntactic sugar for a reference to a pointer or address as in C/C++. See the Julia documentation for the syntax for array construction (it has changed between versions).</source>
          <target state="translated">Julia配列は角括弧でインデックスが付けられ、複数の次元 &lt;code&gt;A[i,j]&lt;/code&gt; 持つことができます。この構文は、C / C ++のように、ポインターまたはアドレスへの参照の単なる構文シュガーではありません。配列構築の構文については、Juliaのドキュメントを参照してください（バージョン間で変更されています）。</target>
        </trans-unit>
        <trans-unit id="4b072870337da75d87b7efdc10a5b80a2cf3a54d" translate="yes" xml:space="preserve">
          <source>Julia arrays are not copied when assigned to another variable. After &lt;code&gt;A = B&lt;/code&gt;, changing elements of &lt;code&gt;B&lt;/code&gt; will modify &lt;code&gt;A&lt;/code&gt; as well.</source>
          <target state="translated">Julia配列は、別の変数に割り当てられた場合はコピーされません。 &lt;code&gt;A = B&lt;/code&gt; 後、 &lt;code&gt;B&lt;/code&gt; の要素を変更すると、 &lt;code&gt;A&lt;/code&gt; も変更されます。</target>
        </trans-unit>
        <trans-unit id="ee983dec29328f6ef30dd7f19c04408b414cdba1" translate="yes" xml:space="preserve">
          <source>Julia arrays are not copied when assigned to another variable. After &lt;code&gt;A = B&lt;/code&gt;, changing elements of &lt;code&gt;B&lt;/code&gt; will modify &lt;code&gt;A&lt;/code&gt; as well. Updating operators like &lt;code&gt;+=&lt;/code&gt; do not operate in-place, they are equivalent to &lt;code&gt;A = A + B&lt;/code&gt; which rebinds the left-hand side to the result of the right-hand side expression.</source>
          <target state="translated">Julia配列は、別の変数に割り当てられた場合はコピーされません。 &lt;code&gt;A = B&lt;/code&gt; 後、 &lt;code&gt;B&lt;/code&gt; の要素を変更すると、 &lt;code&gt;A&lt;/code&gt; も変更されます。 &lt;code&gt;+=&lt;/code&gt; のような更新演算子はインプレースで動作せず、 &lt;code&gt;A = A + B&lt;/code&gt; と同等であり、左側を右側の式の結果に再バインドします。</target>
        </trans-unit>
        <trans-unit id="f8885b17b4a7f2b903bda15b50d42d46540e083d" translate="yes" xml:space="preserve">
          <source>Julia arrays are represented in C by the datatype &lt;code&gt;jl_array_t*&lt;/code&gt;. Basically, &lt;code&gt;jl_array_t&lt;/code&gt; is a struct that contains:</source>
          <target state="translated">Julia配列は、Cではデータ型 &lt;code&gt;jl_array_t*&lt;/code&gt; 表されます。基本的に、 &lt;code&gt;jl_array_t&lt;/code&gt; は以下を含む構造体です。</target>
        </trans-unit>
        <trans-unit id="f90d5ad1f221d4a17d6ad64fe11db8244636641f" translate="yes" xml:space="preserve">
          <source>Julia automatically inserts calls to the &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; function to convert each argument to the specified type. For example, the following call:</source>
          <target state="translated">Juliaは、&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt;関数への呼び出しを自動的に挿入して、各引数を指定された型に変換します。たとえば、次の呼び出し：</target>
        </trans-unit>
        <trans-unit id="94aa685212fa097b84259cd91052f6a151ab1143" translate="yes" xml:space="preserve">
          <source>Julia borrows backtick notation for commands from the shell, Perl, and Ruby. However, in Julia, writing</source>
          <target state="translated">Julia はシェル、Perl、Ruby のコマンドのバックティック記法を借用しています。しかし、Julia では</target>
        </trans-unit>
        <trans-unit id="1e4dcf624482d6017b9073977072d06f0c1e1383" translate="yes" xml:space="preserve">
          <source>Julia can be configured with a number of environment variables, set either in the usual way for each operating system, or in a portable way from within Julia. Supposing that you want to set the environment variable &lt;code&gt;JULIA_EDITOR&lt;/code&gt; to &lt;code&gt;vim&lt;/code&gt;, you can type &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;] = &quot;vim&quot;&lt;/code&gt; (for instance, in the REPL) to make this change on a case by case basis, or add the same to the user configuration file &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; in the user's home directory to have a permanent effect. The current value of the same environment variable can be determined by evaluating &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;]&lt;/code&gt;.</source>
          <target state="translated">Juliaは、オペレーティングシステムごとに通常の方法で設定するか、Julia内から移植可能な方法で設定する、いくつかの環境変数で構成できます。環境変数 &lt;code&gt;JULIA_EDITOR&lt;/code&gt; を &lt;code&gt;vim&lt;/code&gt; に設定する場合、 &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;] = &quot;vim&quot;&lt;/code&gt; （たとえば、REPLで）入力して、ケースバイケースでこの変更を行うか、または次のように追加します。ユーザーのホームディレクトリにあるユーザー設定ファイル &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; は永続的な効果を持ちます。同じ環境変数の現在の値は、 &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;]&lt;/code&gt; 評価することによって決定できます。</target>
        </trans-unit>
        <trans-unit id="25624934c68cd4d66c22470ba9dffff20f4e4703" translate="yes" xml:space="preserve">
          <source>Julia can be started in parallel mode with either the &lt;code&gt;-p&lt;/code&gt; or the &lt;code&gt;--machine-file&lt;/code&gt; options. &lt;code&gt;-p n&lt;/code&gt; will launch an additional &lt;code&gt;n&lt;/code&gt; worker processes, while &lt;code&gt;--machine-file file&lt;/code&gt; will launch a worker for each line in file &lt;code&gt;file&lt;/code&gt;. The machines defined in &lt;code&gt;file&lt;/code&gt; must be accessible via a password-less &lt;code&gt;ssh&lt;/code&gt; login, with Julia installed at the same location as the current host. Each machine definition takes the form &lt;code&gt;[count*][user@]host[:port] [bind_addr[:port]]&lt;/code&gt;. &lt;code&gt;user&lt;/code&gt; defaults to current user, &lt;code&gt;port&lt;/code&gt; to the standard ssh port. &lt;code&gt;count&lt;/code&gt; is the number of workers to spawn on the node, and defaults to 1. The optional &lt;code&gt;bind-to bind_addr[:port]&lt;/code&gt; specifies the IP address and port that other workers should use to connect to this worker.</source>
          <target state="translated">Juliaは、 &lt;code&gt;-p&lt;/code&gt; オプションまたは &lt;code&gt;--machine-file&lt;/code&gt; オプションを使用して並列モードで起動できます。 &lt;code&gt;-p n&lt;/code&gt; は追加の &lt;code&gt;n&lt;/code&gt; 個のワーカープロセスを起動し &lt;code&gt;--machine-file file&lt;/code&gt; が、-machine-file fileはファイルfileの各行のワーカーを起動し &lt;code&gt;file&lt;/code&gt; 。 &lt;code&gt;file&lt;/code&gt; 定義されたマシンは、現在のホストと同じ場所にJuliaをインストールし、パスワードなしの &lt;code&gt;ssh&lt;/code&gt; ログインでアクセスできる必要があります。各マシン定義は、 &lt;code&gt;[count*][user@]host[:port] [bind_addr[:port]]&lt;/code&gt; の形式を取ります。 &lt;code&gt;user&lt;/code&gt; デフォルトは現在のユーザー、 &lt;code&gt;port&lt;/code&gt; は標準のsshポートです。 &lt;code&gt;count&lt;/code&gt; ノードでスポーンするワーカーの数で、デフォルトは1です。オプションの &lt;code&gt;bind-to bind_addr[:port]&lt;/code&gt; は、他のワーカーがこのワーカーに接続するために使用する必要があるIPアドレスとポートを指定します。</target>
        </trans-unit>
        <trans-unit id="1aef7868e131aa3765142ca6c54c8fa0eb438e27" translate="yes" xml:space="preserve">
          <source>Julia can create substrings by indexing into strings. In R, strings must be converted into character vectors before creating substrings.</source>
          <target state="translated">Juliaは文字列にインデックスを付けることで部分文字列を作成することができます。Rでは、文字列は部分文字列を生成する前に文字ベクトルに変換されなければなりません。</target>
        </trans-unit>
        <trans-unit id="5f876f801dbf3de94a121a0fbe557fe7c2dabadb" translate="yes" xml:space="preserve">
          <source>Julia can run multiple commands in parallel:</source>
          <target state="translated">Juliaは複数のコマンドを並行して実行することができます。</target>
        </trans-unit>
        <trans-unit id="d72c9df952d8a93730d24273b050dd7a87c41b99" translate="yes" xml:space="preserve">
          <source>Julia cannot assign to the results of function calls on the left hand side of an assignment operation: you cannot write &lt;code&gt;diag(M) = fill(1, n)&lt;/code&gt;.</source>
          <target state="translated">Juliaは、割り当て操作の左側にある関数呼び出しの結果に割り当てることができません &lt;code&gt;diag(M) = fill(1, n)&lt;/code&gt; 書くことはできません。</target>
        </trans-unit>
        <trans-unit id="b9b5bf6c00b042abbcf8493eca58ab2e8c4ebfcf" translate="yes" xml:space="preserve">
          <source>Julia clusters are designed to be executed on already secured environments on infrastructure such as local laptops, departmental clusters, or even the cloud. This section covers network security requirements for the inbuilt &lt;code&gt;LocalManager&lt;/code&gt; and &lt;code&gt;SSHManager&lt;/code&gt;:</source>
          <target state="translated">Juliaクラスターは、ローカルラップトップ、部門別クラスター、さらにはクラウドなどのインフラストラクチャ上の既に保護された環境で実行されるように設計されています。このセクションでは、組み込みの &lt;code&gt;LocalManager&lt;/code&gt; および &lt;code&gt;SSHManager&lt;/code&gt; のネットワークセキュリティ要件について説明します。</target>
        </trans-unit>
        <trans-unit id="dbe512ceba50dc3b08408e0b7101fcd9582324dd" translate="yes" xml:space="preserve">
          <source>Julia code can throw exceptions. For example, consider:</source>
          <target state="translated">Julia のコードは例外を投げることができます。例えば、考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="d4d45a9c6d816f57f235a4b45d059535efea33d0" translate="yes" xml:space="preserve">
          <source>Julia comes with a full-featured interactive command-line REPL (read-eval-print loop) built into the &lt;code&gt;julia&lt;/code&gt; executable. In addition to allowing quick and easy evaluation of Julia statements, it has a searchable history, tab-completion, many helpful keybindings, and dedicated help and shell modes. The REPL can be started by simply calling &lt;code&gt;julia&lt;/code&gt; with no arguments or double-clicking on the executable:</source>
          <target state="translated">Juliaには、 &lt;code&gt;julia&lt;/code&gt; 実行可能ファイルに組み込まれた、フル機能のインタラクティブなコマンドラインREPL（read-eval-printループ）が付属しています。 Juliaステートメントの迅速かつ簡単な評価を可能にすることに加えて、検索可能な履歴、タブ補完、多くの便利なキーバインディング、専用ヘルプとシェルモードがあります。 REPLは、引数なしで &lt;code&gt;julia&lt;/code&gt; を呼び出すか、実行可能ファイルをダブルクリックすることで開始できます。</target>
        </trans-unit>
        <trans-unit id="04f431b0e99b100c80ed3b37854b8baa69220c9e" translate="yes" xml:space="preserve">
          <source>Julia compiles and uses its own copy of OpenBLAS, with threads currently capped at &lt;code&gt;8&lt;/code&gt; (or the number of your cores).</source>
          <target state="translated">JuliaはOpenBLASの独自のコピーをコンパイルして使用し、現在スレッド数は &lt;code&gt;8&lt;/code&gt; （またはコアの数）に制限されています。</target>
        </trans-unit>
        <trans-unit id="0463aec28ff8f6050169511f8bc7eb9f0e64fcdf" translate="yes" xml:space="preserve">
          <source>Julia constructs vectors using brackets. Julia's &lt;code&gt;[1, 2, 3]&lt;/code&gt; is the equivalent of R's &lt;code&gt;c(1, 2, 3)&lt;/code&gt;.</source>
          <target state="translated">ジュリアは角かっこを使用してベクトルを作成します。ジュリアの &lt;code&gt;[1, 2, 3]&lt;/code&gt; は、Rの &lt;code&gt;c(1, 2, 3)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="2c3022b87e47f6ac9e21545c147897ab28a7faa7" translate="yes" xml:space="preserve">
          <source>Julia discourages populating the main namespace with functions. Most statistical functionality for Julia is found in &lt;a href=&quot;https://pkg.julialang.org/&quot;&gt;packages&lt;/a&gt; under the &lt;a href=&quot;https://github.com/JuliaStats&quot;&gt;JuliaStats organization&lt;/a&gt;. For example:</source>
          <target state="translated">Juliaは、メインの名前空間に関数を設定することを推奨していません。Juliaのほとんどの統計機能は、&lt;a href=&quot;https://github.com/JuliaStats&quot;&gt;JuliaStats組織の&lt;/a&gt;&lt;a href=&quot;https://pkg.julialang.org/&quot;&gt;パッケージにあります&lt;/a&gt;。例えば：</target>
        </trans-unit>
        <trans-unit id="4d3373777de6110679b5b20361db329af8df4ef4" translate="yes" xml:space="preserve">
          <source>Julia discourages the use of semicolons to end statements. The results of statements are not automatically printed (except at the interactive prompt), and lines of code do not need to end with semicolons. &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt;&lt;code&gt;println&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt;&lt;code&gt;@printf&lt;/code&gt;&lt;/a&gt; can be used to print specific output.</source>
          <target state="translated">Juliaは、ステートメントを終了するためにセミコロンを使用しないようにしています。ステートメントの結果は自動的に出力されず（インタラクティブプロンプトを除く）、コード行がセミコロンで終了する必要はありません。&lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt; &lt;code&gt;println&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt; &lt;code&gt;@printf&lt;/code&gt; &lt;/a&gt;を使用して、特定の出力を印刷できます。</target>
        </trans-unit>
        <trans-unit id="04e059ffc127f6546f46c24be663b53bb5ca0e7a" translate="yes" xml:space="preserve">
          <source>Julia does not automatically grow arrays in an assignment statement. Whereas in MATLAB &lt;code&gt;a(4) = 3.2&lt;/code&gt; can create the array &lt;code&gt;a = [0 0 0 3.2]&lt;/code&gt; and &lt;code&gt;a(5) = 7&lt;/code&gt; can grow it into &lt;code&gt;a = [0 0 0 3.2 7]&lt;/code&gt;, the corresponding Julia statement &lt;code&gt;a[5] = 7&lt;/code&gt; throws an error if the length of &lt;code&gt;a&lt;/code&gt; is less than 5 or if this statement is the first use of the identifier &lt;code&gt;a&lt;/code&gt;. Julia has &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt;, which grow &lt;code&gt;Vector&lt;/code&gt;s much more efficiently than MATLAB's &lt;code&gt;a(end+1) = val&lt;/code&gt;.</source>
          <target state="translated">Juliaは、割り当てステートメントで配列を自動的に拡張しません。 MATLABでは &lt;code&gt;a(4) = 3.2&lt;/code&gt; は配列 &lt;code&gt;a = [0 0 0 3.2]&lt;/code&gt; を作成でき、 &lt;code&gt;a(5) = 7&lt;/code&gt; はそれを &lt;code&gt;a = [0 0 0 3.2 7]&lt;/code&gt; に拡張できますが、対応するJuliaステートメント &lt;code&gt;a[5] = 7&lt;/code&gt; は、 &lt;code&gt;a&lt;/code&gt; の長さが5未満の場合、またはこのステートメントが識別子 &lt;code&gt;a&lt;/code&gt; の最初の使用である場合にエラーをスローします。ジュリアが&lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt;そして&lt;a href=&quot;../../base/collections/index#Base.append!&quot;&gt; &lt;code&gt;append!&lt;/code&gt; &lt;/a&gt;、MATLABの &lt;code&gt;a(end+1) = val&lt;/code&gt; よりはるかに効率的に &lt;code&gt;Vector&lt;/code&gt; を拡張します。</target>
        </trans-unit>
        <trans-unit id="113852d54ae1eab98b745b5419ac194b68416265" translate="yes" xml:space="preserve">
          <source>Julia does not have an analog of MATLAB's &lt;code&gt;clear&lt;/code&gt; function; once a name is defined in a Julia session (technically, in module &lt;code&gt;Main&lt;/code&gt;), it is always present.</source>
          <target state="translated">Juliaには、MATLABの &lt;code&gt;clear&lt;/code&gt; 関数に類似するものはありません。名前がJuliaセッションで（技術的には &lt;code&gt;Main&lt;/code&gt; モジュールで）定義されると、常に存在します。</target>
        </trans-unit>
        <trans-unit id="976166bb189635ca72f2fa234ae3939afd751bdc" translate="yes" xml:space="preserve">
          <source>Julia does not provide &lt;code&gt;nrow&lt;/code&gt; and &lt;code&gt;ncol&lt;/code&gt;. Instead, use &lt;code&gt;size(M, 1)&lt;/code&gt; for &lt;code&gt;nrow(M)&lt;/code&gt; and &lt;code&gt;size(M, 2)&lt;/code&gt; for &lt;code&gt;ncol(M)&lt;/code&gt;.</source>
          <target state="translated">Juliaは &lt;code&gt;nrow&lt;/code&gt; と &lt;code&gt;ncol&lt;/code&gt; を提供していません。代わりに、 &lt;code&gt;nrow(M)&lt;/code&gt; には &lt;code&gt;size(M, 1)&lt;/code&gt; 、ncol（M）には &lt;code&gt;size(M, 2)&lt;/code&gt; を使用して &lt;code&gt;ncol(M)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9006bf61e6f8840d28990bf4b3458318711564d6" translate="yes" xml:space="preserve">
          <source>Julia does not require parentheses when writing &lt;code&gt;if&lt;/code&gt; statements or &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; loops: use &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; instead of &lt;code&gt;for (i in c(1, 2, 3))&lt;/code&gt; and &lt;code&gt;if i == 1&lt;/code&gt; instead of &lt;code&gt;if (i == 1)&lt;/code&gt;.</source>
          <target state="translated">Juliaは &lt;code&gt;if&lt;/code&gt; ステートメントまたは &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; ループを書くときに括弧を必要としません： &lt;code&gt;for (i in c(1, 2, 3))&lt;/code&gt; 代わりにfor &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; 使用し、 &lt;code&gt;if i == 1&lt;/code&gt; 代わりに &lt;code&gt;if (i == 1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef86462da92aecc95d832b0a401463ce19d89f34" translate="yes" xml:space="preserve">
          <source>Julia does not require parentheses when writing &lt;code&gt;if&lt;/code&gt; statements or &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; loops: use &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; instead of &lt;code&gt;for (int i=1; i &amp;lt;= 3; i++)&lt;/code&gt; and &lt;code&gt;if i == 1&lt;/code&gt; instead of &lt;code&gt;if (i == 1)&lt;/code&gt;.</source>
          <target state="translated">Juliaは &lt;code&gt;if&lt;/code&gt; ステートメントまたは &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; ループを書くときに括弧を必要としません： &lt;code&gt;for (int i=1; i &amp;lt;= 3; i++)&lt;/code&gt; ではなく &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; 使用し、 &lt;code&gt;if i == 1&lt;/code&gt; 代わりにif &lt;code&gt;if (i == 1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9dab151404329caee20c7d4f7fc1cfb9d014b7b4" translate="yes" xml:space="preserve">
          <source>Julia does not require the use of semicolons to end statements. The results of expressions are not automatically printed (except at the interactive prompt, i.e. the REPL), and lines of code do not need to end with semicolons. &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt;&lt;code&gt;println&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt;&lt;code&gt;@printf&lt;/code&gt;&lt;/a&gt; can be used to print specific output. In the REPL, &lt;code&gt;;&lt;/code&gt; can be used to suppress output. &lt;code&gt;;&lt;/code&gt; also has a different meaning within &lt;code&gt;[ ]&lt;/code&gt;, something to watch out for. &lt;code&gt;;&lt;/code&gt; can be used to separate expressions on a single line, but are not strictly necessary in many cases, and are more an aid to readability.</source>
          <target state="translated">ジュリアでは、ステートメントを終了するためにセミコロンを使用する必要はありません。式の結果は自動的に出力されません（インタラクティブプロンプト（REPL）を除く）。コード行はセミコロンで終了する必要はありません。&lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt; &lt;code&gt;println&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt; &lt;code&gt;@printf&lt;/code&gt; &lt;/a&gt;を使用して、特定の出力を印刷できます。 REPLでは &lt;code&gt;;&lt;/code&gt; 出力を抑制するために使用できます。 &lt;code&gt;;&lt;/code&gt; &lt;code&gt;[ ]&lt;/code&gt; 内でも別の意味があり、注意が必要です。 &lt;code&gt;;&lt;/code&gt; 1行で式を区切るために使用できますが、多くの場合厳密には必要ではなく、読みやすくするために役立ちます。</target>
        </trans-unit>
        <trans-unit id="3aeb7f64792ed5618bd5020762501e30791645d0" translate="yes" xml:space="preserve">
          <source>Julia does not support negative indices. In particular, the last element of a list or array is indexed with &lt;code&gt;end&lt;/code&gt; in Julia, not &lt;code&gt;-1&lt;/code&gt; as in Python.</source>
          <target state="translated">ジュリアは負のインデックスをサポートしていません。特に、リストや配列の最後の要素には、Pythonのように &lt;code&gt;-1&lt;/code&gt; ではなく、ジュリアで &lt;code&gt;end&lt;/code&gt; インデックスが付けられます。</target>
        </trans-unit>
        <trans-unit id="f5ece5c5877f48513873a461f405e2da3018d04a" translate="yes" xml:space="preserve">
          <source>Julia does not support the &lt;code&gt;NULL&lt;/code&gt; type. The closest equivalent is &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;, but it behaves like a scalar value rather than like a list. Use &lt;code&gt;x === nothing&lt;/code&gt; instead of &lt;code&gt;is.null(x)&lt;/code&gt;.</source>
          <target state="translated">Juliaは &lt;code&gt;NULL&lt;/code&gt; 型をサポートしていません。最も近いものは&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;ありませんが、リストのようではなくスカラー値のように動作します。 &lt;code&gt;is.null(x)&lt;/code&gt; の代わりに &lt;code&gt;x === nothing&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="2c5112c931f9c26dffeeec5c85f5a9032e0c2b42" translate="yes" xml:space="preserve">
          <source>Julia does not treat the numbers &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; as Booleans. You cannot write &lt;code&gt;if (1)&lt;/code&gt; in Julia, because &lt;code&gt;if&lt;/code&gt; statements accept only booleans. Instead, you can write &lt;code&gt;if true&lt;/code&gt;, &lt;code&gt;if Bool(1)&lt;/code&gt;, or &lt;code&gt;if 1==1&lt;/code&gt;.</source>
          <target state="translated">ジュリアは数値 &lt;code&gt;0&lt;/code&gt; と &lt;code&gt;1&lt;/code&gt; をブール値として扱いません。あなたは書くことができない &lt;code&gt;if (1)&lt;/code&gt; ので、ジュリアで &lt;code&gt;if&lt;/code&gt; 文が唯一のブール値を受け入れます。代わりに、あなたは書くことができます &lt;code&gt;if true&lt;/code&gt; 、 &lt;code&gt;if Bool(1)&lt;/code&gt; 、または &lt;code&gt;if 1==1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5d0ea94ce19e9b69c6095b45e92d65e847fbab5" translate="yes" xml:space="preserve">
          <source>Julia doesn't require parens around conditions in &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt;. Write:</source>
          <target state="translated">ジュリアは &lt;code&gt;if&lt;/code&gt; と &lt;code&gt;while&lt;/code&gt; の条件の周りに括弧を必要としません。書く：</target>
        </trans-unit>
        <trans-unit id="c7d384a3039a9f94436def1f2e231fafa1ebc407" translate="yes" xml:space="preserve">
          <source>Julia enables package developers and users to document functions, types and other objects easily via a built-in documentation system since Julia 0.4.</source>
          <target state="translated">Julia 0.4 以降、パッケージ開発者やユーザは、組み込みのドキュメントシステムを介して、関数や型、その他のオブジェクトを簡単にドキュメント化できるようになりました。</target>
        </trans-unit>
        <trans-unit id="a610a30b8a22b7162af81fa68a40648223fcdceb" translate="yes" xml:space="preserve">
          <source>Julia encourages users to write their own types, which are easier to use than S3 or S4 objects in R. Julia's multiple dispatch system means that &lt;code&gt;table(x::TypeA)&lt;/code&gt; and &lt;code&gt;table(x::TypeB)&lt;/code&gt; act like R's &lt;code&gt;table.TypeA(x)&lt;/code&gt; and &lt;code&gt;table.TypeB(x)&lt;/code&gt;.</source>
          <target state="translated">Juliaは、ユーザーが独自の型を作成することを推奨しています。これは、RのS3またはS4オブジェクトよりも使いやすいです &lt;code&gt;table.TypeA(x)&lt;/code&gt; の複数のディスパッチシステムは、 &lt;code&gt;table(x::TypeA)&lt;/code&gt; と &lt;code&gt;table(x::TypeB)&lt;/code&gt; がRのtable.TypeA（ x）と &lt;code&gt;table.TypeB(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93dbc5f2b7cd97919b61b2ba139686426c401f37" translate="yes" xml:space="preserve">
          <source>Julia evaluates default values of function arguments every time the method is invoked, unlike in Python where the default values are evaluated only once when the function is defined. For example, the function &lt;code&gt;f(x=rand()) = x&lt;/code&gt; returns a new random number every time it is invoked without argument. On the other hand, the function &lt;code&gt;g(x=[1,2]) = push!(x,3)&lt;/code&gt; returns &lt;code&gt;[1,2,3]&lt;/code&gt; every time it is called as &lt;code&gt;g()&lt;/code&gt;.</source>
          <target state="translated">Juliaは、関数が定義されるときにデフォルト値が一度だけ評価されるPythonとは異なり、メソッドが呼び出されるたびに関数引数のデフォルト値を評価します。たとえば、関数 &lt;code&gt;f(x=rand()) = x&lt;/code&gt; は、引数なしで呼び出されるたびに新しい乱数を返します。一方、関数 &lt;code&gt;g(x=[1,2]) = push!(x,3)&lt;/code&gt; は、 &lt;code&gt;g()&lt;/code&gt; として呼び出されるたびに &lt;code&gt;[1,2,3]&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="96712ad66b3fa51cd94fd25a53b3080e67ce2f4b" translate="yes" xml:space="preserve">
          <source>Julia features optional typing, multiple dispatch, and good performance, achieved using type inference and &lt;a href=&quot;https://en.wikipedia.org/wiki/Just-in-time_compilation&quot;&gt;just-in-time (JIT) compilation&lt;/a&gt;, implemented using &lt;a href=&quot;https://en.wikipedia.org/wiki/Low_Level_Virtual_Machine&quot;&gt;LLVM&lt;/a&gt;. It is multi-paradigm, combining features of imperative, functional, and object-oriented programming. Julia provides ease and expressiveness for high-level numerical computing, in the same way as languages such as R, MATLAB, and Python, but also supports general programming. To achieve this, Julia builds upon the lineage of mathematical programming languages, but also borrows much from popular dynamic languages, including &lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Perl_(programming_language)&quot;&gt;Perl&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Python_(programming_language)&quot;&gt;Python&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Lua_(programming_language)&quot;&gt;Lua&lt;/a&gt;, and &lt;a href=&quot;https://en.wikipedia.org/wiki/Ruby_(programming_language)&quot;&gt;Ruby&lt;/a&gt;.</source>
          <target state="translated">Juliaは、型推論と&lt;a href=&quot;https://en.wikipedia.org/wiki/Just-in-time_compilation&quot;&gt;ジャストインタイム（JIT）コンパイル&lt;/a&gt;を使用して実現される、オプションの型指定、複数ディスパッチ、および優れたパフォーマンスを特徴とし、&lt;a href=&quot;https://en.wikipedia.org/wiki/Low_Level_Virtual_Machine&quot;&gt;LLVM&lt;/a&gt;を使用して実装されます。これは、命令型、関数型、オブジェクト指向プログラミングの機能を組み合わせたマルチパラダイムです。 Juliaは、R、MATLAB、Pythonなどの言語と同じように、高水準の数値計算を簡単かつ表現力豊かに提供しますが、一般的なプログラミングもサポートしています。これを実現するために、ジュリアは数学的プログラミング言語の系統を基に構築されていますが、&lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt;、&lt;a href=&quot;https://en.wikipedia.org/wiki/Perl_(programming_language)&quot;&gt;Perl&lt;/a&gt;、&lt;a href=&quot;https://en.wikipedia.org/wiki/Python_(programming_language)&quot;&gt;Python&lt;/a&gt;、&lt;a href=&quot;https://en.wikipedia.org/wiki/Lua_(programming_language)&quot;&gt;Lua&lt;/a&gt;、&lt;a href=&quot;https://en.wikipedia.org/wiki/Ruby_(programming_language)&quot;&gt;Ruby&lt;/a&gt;などの一般的な動的言語からも多くを借りています。</target>
        </trans-unit>
        <trans-unit id="bc5383570d2537e5c864f51ec5fa00e7be9531d0" translate="yes" xml:space="preserve">
          <source>Julia fully supports Unicode characters and strings. As &lt;a href=&quot;#man-characters-1&quot;&gt;discussed above&lt;/a&gt;, in character literals, Unicode code points can be represented using Unicode &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\U&lt;/code&gt; escape sequences, as well as all the standard C escape sequences. These can likewise be used to write string literals:</source>
          <target state="translated">JuliaはUnicode文字と文字列を完全にサポートしています。&lt;a href=&quot;#man-characters-1&quot;&gt;上述した&lt;/a&gt;、文字リテラルでは、Unicodeコードポイントは、Unicode使用して表すことができる &lt;code&gt;\u&lt;/code&gt; と &lt;code&gt;\U&lt;/code&gt; エスケープシーケンス、ならびにすべての標準Cエスケープシーケンスを。同様に、これらを使用して文字列リテラルを書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="ddd78f6e5bc711118d9be3c491d9cc07a50a79b9" translate="yes" xml:space="preserve">
          <source>Julia function arguments follow a convention sometimes called &quot;pass-by-sharing&quot;, which means that values are not copied when they are passed to functions. Function arguments themselves act as new variable &lt;em&gt;bindings&lt;/em&gt; (new locations that can refer to values), but the values they refer to are identical to the passed values. Modifications to mutable values (such as &lt;code&gt;Array&lt;/code&gt;s) made within a function will be visible to the caller. This is the same behavior found in Scheme, most Lisps, Python, Ruby and Perl, among other dynamic languages.</source>
          <target state="translated">Juliaの関数の引数は、「共有渡し」と呼ばれることもある規則に従います。つまり、関数に渡されるときに値はコピーされません。関数の引数自体は新しい変数&lt;em&gt;バインディング&lt;/em&gt;（値を参照できる新しい場所）として機能しますが、それらが参照する値は渡された値と同じです。関数内で行われた変更可能な値（ &lt;code&gt;Array&lt;/code&gt; など）への変更は、呼び出し元に表示されます。これは、他の動的言語の中でも、Scheme、ほとんどのLisp、Python、Ruby、Perlで見られる動作と同じです。</target>
        </trans-unit>
        <trans-unit id="f080283d31381a5962b780da17f950587890e071" translate="yes" xml:space="preserve">
          <source>Julia has Perl-compatible regular expressions (regexes), as provided by the &lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt; library (a description of the syntax can be found &lt;a href=&quot;http://www.pcre.org/current/doc/html/pcre2syntax.html&quot;&gt;here&lt;/a&gt;). Regular expressions are related to strings in two ways: the obvious connection is that regular expressions are used to find regular patterns in strings; the other connection is that regular expressions are themselves input as strings, which are parsed into a state machine that can be used to efficiently search for patterns in strings. In Julia, regular expressions are input using non-standard string literals prefixed with various identifiers beginning with &lt;code&gt;r&lt;/code&gt;. The most basic regular expression literal without any options turned on just uses &lt;code&gt;r&quot;...&quot;&lt;/code&gt;:</source>
          <target state="translated">Juliaには、&lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt;ライブラリで提供されているように、Perl互換の正規表現（正規表現）があります（構文の説明は&lt;a href=&quot;http://www.pcre.org/current/doc/html/pcre2syntax.html&quot;&gt;こちらにあります&lt;/a&gt;）。正規表現は2つの方法で文字列に関連付けられています。明白な関係は、正規表現が文字列内の正規パターンを見つけるために使用されることです。もう1つの関係は、正規表現自体が文字列として入力され、文字列内のパターンを効率的に検索するために使用できる状態マシンに解析されることです。 Juliaでは、正規表現は、 &lt;code&gt;r&lt;/code&gt; で始まるさまざまな識別子が前に付いた非標準の文字列リテラルを使用して入力されます。オプションがオンになっていない最も基本的な正規表現リテラルは、 &lt;code&gt;r&quot;...&quot;&lt;/code&gt; 使用するだけです。</target>
        </trans-unit>
        <trans-unit id="1bf49a0edfd1fa830fafecd8986f8d037e52871d" translate="yes" xml:space="preserve">
          <source>Julia has a built-in data structure called a &lt;em&gt;tuple&lt;/em&gt; that is closely related to function arguments and return values. A tuple is a fixed-length container that can hold any values, but cannot be modified (it is &lt;em&gt;immutable&lt;/em&gt;). Tuples are constructed with commas and parentheses, and can be accessed via indexing:</source>
          <target state="translated">Juliaには、&lt;em&gt;タプル&lt;/em&gt;と呼ばれる組み込みのデータ構造があり、関数の引数と戻り値に密接に関連しています。タプルは、任意の値を保持できる固定長のコンテナーですが、変更できません（&lt;em&gt;不変です&lt;/em&gt;）。タプルはコンマと括弧で構成され、インデックスを介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="c552e8e0854f7810a14a1b85cee7a089274fe437" translate="yes" xml:space="preserve">
          <source>Julia has a rational number type to represent exact ratios of integers. Rationals are constructed using the &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt;&lt;code&gt;//&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">ジュリアには、整数の正確な比率を表す有理数型があります。有理数は&lt;a href=&quot;../../base/math/index#Base.://&quot;&gt; &lt;code&gt;//&lt;/code&gt; &lt;/a&gt;演算子を使用して構築されます</target>
        </trans-unit>
        <trans-unit id="b40bd35bfba54a15cc9852aeface053edb4835d0" translate="yes" xml:space="preserve">
          <source>Julia has a special &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot syntax&lt;/a&gt; that converts any scalar function into a &quot;vectorized&quot; function call, and any operator into a &quot;vectorized&quot; operator, with the special property that nested &quot;dot calls&quot; are &lt;em&gt;fusing&lt;/em&gt;: they are combined at the syntax level into a single loop, without allocating temporary arrays. If you use &lt;code&gt;.=&lt;/code&gt; and similar assignment operators, the result can also be stored in-place in a pre-allocated array (see above).</source>
          <target state="translated">Juliaには、スカラー関数を「ベクトル化された」関数呼び出しに変換する特別な&lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;ドット構文&lt;/a&gt;と、演算子が「ベクトル化された」演算子に変換される特別なプロパティがあり、ネストされた「ドット呼び出し」が&lt;em&gt;融合&lt;/em&gt;します。構文レベルで結合されます。一時配列を割り当てずに、単一のループ。 &lt;code&gt;.=&lt;/code&gt; および同様の代入演算子を使用する場合、結果は事前に割り当てられた配列にインプレースで格納することもできます（上記を参照）。</target>
        </trans-unit>
        <trans-unit id="d6c4ab07a2249226dfaeff8c414c6f4ecccc5db7" translate="yes" xml:space="preserve">
          <source>Julia has a specialized version of &lt;code&gt;ntuple&lt;/code&gt; that accepts a &lt;code&gt;Val{::Int}&lt;/code&gt; instance as the second parameter; by passing &lt;code&gt;N&lt;/code&gt; as a type-parameter, you make its &quot;value&quot; known to the compiler. Consequently, this version of &lt;code&gt;array3&lt;/code&gt; allows the compiler to predict the return type.</source>
          <target state="translated">Juliaには、2番目のパラメーターとして &lt;code&gt;Val{::Int}&lt;/code&gt; インスタンスを受け入れる &lt;code&gt;ntuple&lt;/code&gt; の特別バージョンがあります。型パラメーターとして &lt;code&gt;N&lt;/code&gt; を渡すことにより、その「値」をコンパイラーに認識させます。したがって、このバージョンの &lt;code&gt;array3&lt;/code&gt; を使用すると、コンパイラは戻り値の型を予測できます。</target>
        </trans-unit>
        <trans-unit id="dd0467e099e9e6d5ba4caf88a327947c41a492c3" translate="yes" xml:space="preserve">
          <source>Julia has a system for promoting arguments of mathematical operators to a common type, which has been mentioned in various other sections, including &lt;a href=&quot;../integers-and-floating-point-numbers/index#Integers-and-Floating-Point-Numbers-1&quot;&gt;Integers and Floating-Point Numbers&lt;/a&gt;, &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;, &lt;a href=&quot;../types/index#man-types-1&quot;&gt;Types&lt;/a&gt;, and &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;. In this section, we explain how this promotion system works, as well as how to extend it to new types and apply it to functions besides built-in mathematical operators. Traditionally, programming languages fall into two camps with respect to promotion of arithmetic arguments:</source>
          <target state="translated">Juliaには、数学演算子の引数を共通の型にプロモートするシステムがあります。これは、&lt;a href=&quot;../integers-and-floating-point-numbers/index#Integers-and-Floating-Point-Numbers-1&quot;&gt;整数と浮動小数点数&lt;/a&gt;、&lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;数学演算と初等関数&lt;/a&gt;、&lt;a href=&quot;../types/index#man-types-1&quot;&gt;タイプ&lt;/a&gt;、&lt;a href=&quot;../methods/index#Methods-1&quot;&gt;メソッド&lt;/a&gt;など、他のさまざまなセクションで説明されています。このセクションでは、この昇格システムがどのように機能するか、およびそれを新しいタイプに拡張して、組み込みの数学演算子以外の関数に適用する方法について説明します。伝統的に、プログラミング言語は算術引数の促進に関して2つの陣営に分類されます。</target>
        </trans-unit>
        <trans-unit id="3580c0f9206e567ece3500a7602b2f938ef0cdc5" translate="yes" xml:space="preserve">
          <source>Julia has an enumeration type, expressed using the macro &lt;code&gt;@enum(name, value1, value2, ...)&lt;/code&gt; For example: &lt;code&gt;@enum(Fruit, banana=1, apple, pear)&lt;/code&gt;</source>
          <target state="translated">Juliaには列挙型があり、マクロ &lt;code&gt;@enum(name, value1, value2, ...)&lt;/code&gt; を使用して表されます。例： &lt;code&gt;@enum(Fruit, banana=1, apple, pear)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e22281e2e9ddb304102a3e2035cc1b7d70261e86" translate="yes" xml:space="preserve">
          <source>Julia has an extensive, flexible API for sorting and interacting with already-sorted arrays of values. By default, Julia picks reasonable algorithms and sorts in standard ascending order:</source>
          <target state="translated">Juliaには、既にソートされた値の配列をソートして対話するための広範で柔軟なAPIが用意されています。デフォルトでは、Julia は合理的なアルゴリズムを選択し、標準的な昇順でソートします。</target>
        </trans-unit>
        <trans-unit id="bf9ed794914c3a1a76c39f0be8423b02c7aa0fa9" translate="yes" xml:space="preserve">
          <source>Julia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression, it is considered done; otherwise the input continues. One way to force an expression to continue is to wrap it in parentheses.</source>
          <target state="translated">ジュリアには行の続きの構文がありません:行の終わりに、これまでの入力が完全な式であれば、それは完了したとみなされ、そうでなければ入力は続きます。式を強制的に継続させる一つの方法は、式を括弧で囲むことです。</target>
        </trans-unit>
        <trans-unit id="6e3f85fe865aed948db80d8506da1145de6fdbbe" translate="yes" xml:space="preserve">
          <source>Julia has several functions that can mutate their arguments. For example, it has both &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ジュリアには、引数を変更できるいくつかの関数があります。たとえば、&lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt;両方があります。。</target>
        </trans-unit>
        <trans-unit id="dced25e0f1eb19647f27c26102392f9de718e8bc" translate="yes" xml:space="preserve">
          <source>Julia has support for sparse vectors and &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix&quot;&gt;sparse matrices&lt;/a&gt; in the &lt;code&gt;SparseArrays&lt;/code&gt; stdlib module. Sparse arrays are arrays that contain enough zeros that storing them in a special data structure leads to savings in space and execution time, compared to dense arrays.</source>
          <target state="translated">Juliaは、 &lt;code&gt;SparseArrays&lt;/code&gt; stdlibモジュールでスパースベクトルと&lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix&quot;&gt;スパース行列&lt;/a&gt;をサポートしています。疎配列は、特殊なデータ構造にそれらを格納するのに十分なゼロを含む配列であり、密配列と比較して、スペースと実行時間を節約できます。</target>
        </trans-unit>
        <trans-unit id="7e110deec010cf13200f416e320f962b03651cd3" translate="yes" xml:space="preserve">
          <source>Julia has true one-dimensional arrays. Column vectors are of size &lt;code&gt;N&lt;/code&gt;, not &lt;code&gt;Nx1&lt;/code&gt;. For example, &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt;&lt;code&gt;rand(N)&lt;/code&gt;&lt;/a&gt; makes a 1-dimensional array.</source>
          <target state="translated">ジュリアには真の1次元配列があります。列ベクトルは &lt;code&gt;Nx1&lt;/code&gt; ではなく、サイズ &lt;code&gt;N&lt;/code&gt; です。たとえば、&lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt; &lt;code&gt;rand(N)&lt;/code&gt; &lt;/a&gt;は1次元配列を作成します。</target>
        </trans-unit>
        <trans-unit id="0821ee6b098b6e9c3f3f70ea62ba30df9ae8eca8" translate="yes" xml:space="preserve">
          <source>Julia has two mechanisms for loading code:</source>
          <target state="translated">Juliaにはコードをロードするための2つのメカニズムがあります。</target>
        </trans-unit>
        <trans-unit id="c7c1de145d34e5e8002d957a023c35b25d8ff0be" translate="yes" xml:space="preserve">
          <source>Julia has two right-shift operators, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; performs an arithmetic shift, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; always performs a logical shift, unlike C/C++, where the meaning of &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; depends on the type of the value being shifted.</source>
          <target state="translated">ジュリアには、2つの右シフト演算子 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; があります。 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 行う算術シフトは、 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; いつもの意味C / C ++とは異なり、論理シフトを実行 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; がシフトされる値のタイプに依存します。</target>
        </trans-unit>
        <trans-unit id="a82ef00db4da7adcbac13bd1f8a38ec016519663" translate="yes" xml:space="preserve">
          <source>Julia identifiers and code excerpts should always appear between backticks &lt;code&gt;`&lt;/code&gt; to enable highlighting. Equations in the LaTeX syntax can be inserted between double backticks &lt;code&gt;``&lt;/code&gt;. Use Unicode characters rather than their LaTeX escape sequence, i.e. &lt;code&gt;``&amp;alpha; = 1``&lt;/code&gt; rather than &lt;code&gt;``\\alpha = 1``&lt;/code&gt;.</source>
          <target state="translated">ジュリア識別子とコードの抜粋は、常にバッククォートの間に表示されます &lt;code&gt;`&lt;/code&gt; ハイライト表示可能にします。LaTeX構文の方程式は、ダブルバッククォートの間に挿入できます &lt;code&gt;``&lt;/code&gt; 。LaTeXエスケープシーケンスではなくUnicode文字を使用します。つまり、 &lt;code&gt;``\\alpha = 1``&lt;/code&gt; ではなく &lt;code&gt;``&amp;alpha; = 1``&lt;/code&gt; 」です。</target>
        </trans-unit>
        <trans-unit id="556d3efaca190f2ea064a6e9ec15d293042ee9a4" translate="yes" xml:space="preserve">
          <source>Julia includes predefined types for both complex and rational numbers, and supports all the standard &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt; on them. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt; are defined so that operations on any combination of predefined numeric types, whether primitive or composite, behave as expected.</source>
          <target state="translated">Juliaには、複素数と有理数の両方に事前定義された型が含まれており、それらの標準的な&lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;数学演算と基本関数&lt;/a&gt;をすべてサポートしています。&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;変換と昇格&lt;/a&gt;は、プリミティブかコンポジットかに関係なく、事前定義された数値タイプの任意の組み合わせに対する操作が期待どおりに動作するように定義されています。</target>
        </trans-unit>
        <trans-unit id="7ddd4e3aafc825251162512ccf2a33928bb02903" translate="yes" xml:space="preserve">
          <source>Julia installation is straightforward, whether using precompiled binaries or compiling from source. Download and install Julia by following the instructions at &lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/&lt;/a&gt;.</source>
          <target state="translated">Juliaのインストールは、プリコンパイルされたバイナリを使用するか、ソースからコンパイルするかに関係なく、簡単です。&lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/&lt;/a&gt;の指示に従ってJuliaをダウンロードしてインストールします。</target>
        </trans-unit>
        <trans-unit id="ebd85d8192dfa3106e5516cbab7ad06e8387fb26" translate="yes" xml:space="preserve">
          <source>Julia is careful to distinguish scalars, vectors and matrices. In R, &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;c(1)&lt;/code&gt; are the same. In Julia, they cannot be used interchangeably.</source>
          <target state="translated">ジュリアはスカラー、ベクトル、行列を注意深く区別しています。Rでは、 &lt;code&gt;1&lt;/code&gt; と &lt;code&gt;c(1)&lt;/code&gt; は同じです。ジュリアでは、それらを交換して使用することはできません。</target>
        </trans-unit>
        <trans-unit id="b86e5dd8d3107ffdd2a0b40698efdff29052007c" translate="yes" xml:space="preserve">
          <source>Julia is eagerly evaluated and does not support R-style lazy evaluation. For most users, this means that there are very few unquoted expressions or column names.</source>
          <target state="translated">Julia は熱心に評価され、R スタイルの遅延評価をサポートしていません。ほとんどのユーザにとって、これは引用符で囲まれていない式やカラム名が非常に少ないことを意味します。</target>
        </trans-unit>
        <trans-unit id="3107ebb99f64b1456a558b1a35edcbfee43840dd" translate="yes" xml:space="preserve">
          <source>Julia is under rapid development and has an extensive test suite to verify functionality across multiple platforms. If you build Julia from source, you can run this test suite with &lt;code&gt;make test&lt;/code&gt;. In a binary install, you can run the test suite using &lt;code&gt;Base.runtests()&lt;/code&gt;.</source>
          <target state="translated">Juliaは急速に開発中であり、複数のプラットフォームにわたって機能を検証するための広範なテストスイートを備えています。ソースからJuliaをビルドする場合、このテストスイートを &lt;code&gt;make test&lt;/code&gt; で実行できます。バイナリインストールでは、 &lt;code&gt;Base.runtests()&lt;/code&gt; を使用してテストスイートを実行できます。</target>
        </trans-unit>
        <trans-unit id="9746bea5d9fab2c69edf57da506dab8c4cb797c1" translate="yes" xml:space="preserve">
          <source>Julia lacks the equivalent of R's &lt;code&gt;assign&lt;/code&gt; or &lt;code&gt;get&lt;/code&gt;.</source>
          <target state="translated">Juliaには、Rの &lt;code&gt;assign&lt;/code&gt; または &lt;code&gt;get&lt;/code&gt; に相当するものがありません。</target>
        </trans-unit>
        <trans-unit id="b0362643e3d8faddbbdc08525668acd4db05eb64" translate="yes" xml:space="preserve">
          <source>Julia macros operate on parsed expressions, rather than the text of the program, which allows them to perform sophisticated transformations of Julia code. Macro names start with the &lt;code&gt;@&lt;/code&gt; character, and have both a function-like syntax, &lt;code&gt;@mymacro(arg1, arg2, arg3)&lt;/code&gt;, and a statement-like syntax, &lt;code&gt;@mymacro arg1 arg2 arg3&lt;/code&gt;. The forms are interchangeable; the function-like form is particularly useful if the macro appears within another expression, and is often clearest. The statement-like form is often used to annotate blocks, as in the distributed &lt;code&gt;for&lt;/code&gt; construct: &lt;code&gt;@distributed for i in 1:n; #= body =#; end&lt;/code&gt;. Where the end of the macro construct may be unclear, use the function-like form.</source>
          <target state="translated">Juliaマクロは、プログラムのテキストではなく、解析された式を操作するため、Juliaコードの高度な変換を実行できます。マクロ名は &lt;code&gt;@&lt;/code&gt; 文字で始まり、関数のような構文 &lt;code&gt;@mymacro(arg1, arg2, arg3)&lt;/code&gt; とステートメントのような構文 &lt;code&gt;@mymacro arg1 arg2 arg3&lt;/code&gt; の両方を持っています。フォームは交換可能です。関数のような形式は、マクロが別の式内に出現する場合に特に便利で、多くの場合最も明確です。ステートメントのような形式は、distributed &lt;code&gt;for&lt;/code&gt; 構文のように、ブロックに注釈を付けるためによく使用されます。 &lt;code&gt;@distributed for i in 1:n; #= body =#; end&lt;/code&gt; 。マクロ構造の終わりが不明確な場合は、関数のような形式を使用してください。</target>
        </trans-unit>
        <trans-unit id="7722324abb1e33c9620fc5bb1dbd294982f5257b" translate="yes" xml:space="preserve">
          <source>Julia performs matrix transposition using the &lt;code&gt;transpose&lt;/code&gt; function and conjugated transposition using the &lt;code&gt;'&lt;/code&gt; operator or the &lt;code&gt;adjoint&lt;/code&gt; function. Julia's &lt;code&gt;transpose(A)&lt;/code&gt; is therefore equivalent to R's &lt;code&gt;t(A)&lt;/code&gt;. Additionally a non-recursive transpose in Julia is provided by the &lt;code&gt;permutedims&lt;/code&gt; function.</source>
          <target state="translated">Juliaは、 &lt;code&gt;transpose&lt;/code&gt; 関数を使用して行列転置を実行し、 &lt;code&gt;'&lt;/code&gt; 演算子または &lt;code&gt;adjoint&lt;/code&gt; 関数を使用して共役転置を実行します。したがって、Juliaの &lt;code&gt;transpose(A)&lt;/code&gt; は、Rの &lt;code&gt;t(A)&lt;/code&gt; と同等です。さらに、Juliaの非再帰的転置は、 &lt;code&gt;permutedims&lt;/code&gt; 関数によって提供されます。</target>
        </trans-unit>
        <trans-unit id="52ca89425115cf081b45ea4b026826f1b8b7932f" translate="yes" xml:space="preserve">
          <source>Julia provides &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt;, which gives the distance between &lt;code&gt;1.0&lt;/code&gt; and the next larger representable floating-point value:</source>
          <target state="translated">Juliaは&lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; を&lt;/a&gt;提供します。これは、 &lt;code&gt;1.0&lt;/code&gt; と次に大きい浮動小数点値との間の距離を示します。</target>
        </trans-unit>
        <trans-unit id="b5151abe259ad1efc62c73fed3cdaac381488d9a" translate="yes" xml:space="preserve">
          <source>Julia provides a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; mechanism for solving this problem. A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is a waitable first-in first-out queue which can have multiple tasks reading from and writing to it.</source>
          <target state="translated">Juliaは、この問題を解決するための&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;メカニズムを提供します。A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;待機可能な先入れ先出し待ち行列複数のタスクから読み取り、それに書き込むことができたです。</target>
        </trans-unit>
        <trans-unit id="8d6a50d7fd1b9d32a07f2f0f7b72bc0c75328556" translate="yes" xml:space="preserve">
          <source>Julia provides a broad range of primitive numeric types, and a full complement of arithmetic and bitwise operators as well as standard mathematical functions are defined over them. These map directly onto numeric types and operations that are natively supported on modern computers, thus allowing Julia to take full advantage of computational resources. Additionally, Julia provides software support for &lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt;, which can handle operations on numeric values that cannot be represented effectively in native hardware representations, but at the cost of relatively slower performance.</source>
          <target state="translated">Juliaは、幅広いプリミティブ数値型を提供し、算術演算子とビット単位演算子の完全な補完機能、および標準の数学関数がそれらに対して定義されています。これらは、現代のコンピューターでネイティブにサポートされている数値型と演算に直接マッピングされるため、ジュリアは計算リソースを最大限に活用できます。さらに、Juliaは&lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;Arbitrary Precision Arithmeticの&lt;/a&gt;ソフトウェアサポートを提供します。これにより、ネイティブハードウェア表現では効果的に表現できない数値の演算を処理できますが、パフォーマンスは比較的低下します。</target>
        </trans-unit>
        <trans-unit id="5e01948cafe564bc35cc3886e5615297521aba0b" translate="yes" xml:space="preserve">
          <source>Julia provides a complete collection of basic arithmetic and bitwise operators across all of its numeric primitive types, as well as providing portable, efficient implementations of a comprehensive collection of standard mathematical functions.</source>
          <target state="translated">Juliaは基本的な算術演算子とビット演算子の完全なコレクションを提供し、すべての数値プリミティブ型を網羅しています。</target>
        </trans-unit>
        <trans-unit id="123ae94e81e1f4b6a65e379d812783d382dbfd58" translate="yes" xml:space="preserve">
          <source>Julia provides a comprehensive collection of mathematical functions and operators. These mathematical operations are defined over as broad a class of numerical values as permit sensible definitions, including integers, floating-point numbers, rationals, and complex numbers, wherever such definitions make sense.</source>
          <target state="translated">Juliaは数学関数と演算子の包括的なコレクションを提供しています.これらの数学的操作は,整数,浮動小数点数,合理性,複素数など,理にかなった定義が可能な範囲で,数値の広いクラスにわたって定義されています.</target>
        </trans-unit>
        <trans-unit id="07cfc6f69cd91f9494ead12f841604f628160c20" translate="yes" xml:space="preserve">
          <source>Julia provides a reserved word &lt;code&gt;do&lt;/code&gt; for rewriting this code more clearly:</source>
          <target state="translated">Juliaは、このコードをより明確に書き換えるための予約語 &lt;code&gt;do&lt;/code&gt; を提供しています。</target>
        </trans-unit>
        <trans-unit id="eea9a879394b78dc7fcabf301d30239602afa073" translate="yes" xml:space="preserve">
          <source>Julia provides a rich interface to deal with streaming I/O objects such as terminals, pipes and TCP sockets. This interface, though asynchronous at the system level, is presented in a synchronous manner to the programmer and it is usually unnecessary to think about the underlying asynchronous operation. This is achieved by making heavy use of Julia cooperative threading (&lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;coroutine&lt;/a&gt;) functionality.</source>
          <target state="translated">Juliaは、ターミナル、パイプ、TCPソケットなどのストリーミングI / Oオブジェクトを処理するための豊富なインターフェイスを提供します。このインターフェイスは、システムレベルでは非同期ですが、同期的にプログラマに提示されるため、通常、基になる非同期操作について考える必要はありません。これは、Juliaの協調スレッド（&lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;コルーチン&lt;/a&gt;）機能を多用することで実現されます。</target>
        </trans-unit>
        <trans-unit id="abe3cae0b0fe31f45bb29933297244a39702e5dd" translate="yes" xml:space="preserve">
          <source>Julia provides a variety of control flow constructs:</source>
          <target state="translated">Juliaは様々な制御フロー構造を提供しています。</target>
        </trans-unit>
        <trans-unit id="379525ee528141070933df39d7ce42ca05dd4bf0" translate="yes" xml:space="preserve">
          <source>Julia provides additional functions to test numbers for special values, which can be useful in situations like hash key comparisons:</source>
          <target state="translated">Juliaは数値の特殊な値をテストするための関数を追加で提供しており、ハッシュキーの比較のような状況で有用です。</target>
        </trans-unit>
        <trans-unit id="e0540cb6db7126d29223e3d70501bf3d70244816" translate="yes" xml:space="preserve">
          <source>Julia provides an extremely flexible system for naming variables. Variable names are case-sensitive, and have no semantic meaning (that is, the language will not treat variables differently based on their names).</source>
          <target state="translated">Julia は変数の命名に非常に柔軟なシステムを提供しています。変数名は大文字と小文字を区別し、意味的な意味を持ちません (つまり、言語はその名前に基づいて変数を異なる扱いをしません)。</target>
        </trans-unit>
        <trans-unit id="eab744df916b515fec425ab1cfaf69348d24b932" translate="yes" xml:space="preserve">
          <source>Julia provides built-in, efficient functions to test for oddness and evenness called &lt;a href=&quot;../../base/numbers/index#Base.iseven&quot;&gt;&lt;code&gt;iseven&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Base.isodd&quot;&gt;&lt;code&gt;isodd&lt;/code&gt;&lt;/a&gt; so the above definitions should only be considered to be examples of scope, not efficient design.</source>
          <target state="translated">Juliaには、&lt;a href=&quot;../../base/numbers/index#Base.iseven&quot;&gt; &lt;code&gt;iseven&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/numbers/index#Base.isodd&quot;&gt; &lt;code&gt;isodd&lt;/code&gt; &lt;/a&gt;と呼ばれる奇数と偶数をテストするための組み込みの効率的な関数が用意されているため、上記の定義はスコープの例であり、効率的な設計ではありません。</target>
        </trans-unit>
        <trans-unit id="378329d878ac43129f252ba96bb3ab40b65f2250" translate="yes" xml:space="preserve">
          <source>Julia provides functions which return literal 0 and 1 corresponding to a specified type or the type of a given variable.</source>
          <target state="translated">Juliaは、指定された型や変数の型に対応するリテラル0と1を返す関数を提供しています。</target>
        </trans-unit>
        <trans-unit id="affb7609b4adcfecba8a7c2be6b8ababed17f3bf" translate="yes" xml:space="preserve">
          <source>Julia provides support for representing missing values in the statistical sense, that is for situations where no value is available for a variable in an observation, but a valid value theoretically exists. Missing values are represented via the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object, which is the singleton instance of the type &lt;a href=&quot;../../base/base/index#Base.Missing&quot;&gt;&lt;code&gt;Missing&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;missing&lt;/code&gt; is equivalent to &lt;a href=&quot;https://en.wikipedia.org/wiki/NULL_(SQL)&quot;&gt;&lt;code&gt;NULL&lt;/code&gt; in SQL&lt;/a&gt; and &lt;a href=&quot;https://cran.r-project.org/doc/manuals/r-release/R-lang.html#NA-handling&quot;&gt;&lt;code&gt;NA&lt;/code&gt; in R&lt;/a&gt;, and behaves like them in most situations.</source>
          <target state="translated">Juliaは、統計的な意味で欠損値を表すためのサポートを提供します。つまり、観測値の変数に使用できる値はないが、理論的には有効な値が存在する場合です。欠損値は、存在し&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;オブジェクトを介して表されます。これは、型&lt;a href=&quot;../../base/base/index#Base.Missing&quot;&gt; &lt;code&gt;Missing&lt;/code&gt; の&lt;/a&gt;シングルトンインスタンスです。 &lt;code&gt;missing&lt;/code&gt; は&lt;a href=&quot;https://en.wikipedia.org/wiki/NULL_(SQL)&quot;&gt;、SQLの&lt;/a&gt; &lt;code&gt;NULL&lt;/code&gt; および&lt;a href=&quot;https://cran.r-project.org/doc/manuals/r-release/R-lang.html#NA-handling&quot;&gt;Rの&lt;/a&gt; &lt;code&gt;NA&lt;/code&gt; と同等であり、ほとんどの状況でそれらのように動作します。</target>
        </trans-unit>
        <trans-unit id="105b1a0ce6d2b2d8bfa2faba37832a7982f4eb0d" translate="yes" xml:space="preserve">
          <source>Julia provides tuples and real hash tables, but not R-style lists. When returning multiple items, you should typically use a tuple or a named tuple: instead of &lt;code&gt;list(a = 1, b = 2)&lt;/code&gt;, use &lt;code&gt;(1, 2)&lt;/code&gt; or &lt;code&gt;(a=1, b=2)&lt;/code&gt;.</source>
          <target state="translated">Juliaはタプルと実際のハッシュテーブルを提供しますが、Rスタイルのリストは提供しません。複数のアイテムを返すとき、あなたは一般的に、タプルまたは名前付きタプルを使用する必要があります。代わりの &lt;code&gt;list(a = 1, b = 2)&lt;/code&gt; 、使用 &lt;code&gt;(1, 2)&lt;/code&gt; または &lt;code&gt;(a=1, b=2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12d6b550dc7735e370a3f8c010496abe63394b14" translate="yes" xml:space="preserve">
          <source>Julia provides two in-built cluster managers:</source>
          <target state="translated">Juliaには2つのクラスタマネージャが内蔵されています。</target>
        </trans-unit>
        <trans-unit id="c65c2e80d135867ac3b507bcd217f7ad2507c745" translate="yes" xml:space="preserve">
          <source>Julia requires &lt;code&gt;end&lt;/code&gt; to end a block. Unlike Python, Julia has no &lt;code&gt;pass&lt;/code&gt; keyword.</source>
          <target state="translated">ジュリアはブロックを終了するために &lt;code&gt;end&lt;/code&gt; を必要とします。Pythonとは異なり、Juliaには &lt;code&gt;pass&lt;/code&gt; キーワードがありません。</target>
        </trans-unit>
        <trans-unit id="42da913aac127180e179863fc35f1ca348a1d911" translate="yes" xml:space="preserve">
          <source>Julia should load our new code. Let's test it:</source>
          <target state="translated">ジュリアは新しいコードを ロードしてくれるはずだ テストしてみよう</target>
        </trans-unit>
        <trans-unit id="b7c7299bbee239f4f34ffd5f256e5fa27242ff3f" translate="yes" xml:space="preserve">
          <source>Julia supports accessing and modifying values &lt;em&gt;atomically&lt;/em&gt;, that is, in a thread-safe way to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition&quot;&gt;race conditions&lt;/a&gt;. A value (which must be of a primitive type) can be wrapped as &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.Atomic&quot;&gt;&lt;code&gt;Threads.Atomic&lt;/code&gt;&lt;/a&gt; to indicate it must be accessed in this way. Here we can see an example:</source>
          <target state="translated">Julia は、&lt;em&gt;アトミックに&lt;/em&gt;、つまり&lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition&quot;&gt;競合状態&lt;/a&gt;を回避するためのスレッドセーフな方法で、値へのアクセスと変更をサポートしています。値（プリミティブ型である必要があります）は、この方法でアクセスする必要があることを示すために&lt;a href=&quot;../../base/multi-threading/index#Base.Threads.Atomic&quot;&gt; &lt;code&gt;Threads.Atomic&lt;/code&gt; &lt;/a&gt;としてラップできます。ここで例を見ることができます：</target>
        </trans-unit>
        <trans-unit id="b32a099891e5d6d1de5f4e3ebb7913c9c9d83a6a" translate="yes" xml:space="preserve">
          <source>Julia supports federated package management, which means that multiple independent parties can maintain both public and private packages and registries of packages, and that projects can depend on a mix of public and private packages from different registries. Packages from various registries are installed and managed using a common set of tools and workflows. The &lt;code&gt;Pkg&lt;/code&gt; package manager that ships with Julia lets you install and manage your projects' dependencies. It assists in creating and manipulating project files (which describe what other projects that your project depends on), and manifest files (which snapshot exact versions of your project's complete dependency graph).</source>
          <target state="translated">Juliaはフェデレーションパッケージ管理をサポートしています。つまり、複数の独立した当事者がパブリックパッケージとプライベートパッケージの両方、およびパッケージのレジストリを維持でき、プロジェクトは、異なるレジストリのパブリックパッケージとプライベートパッケージの組み合わせに依存できます。さまざまなレジストリのパッケージは、共通のツールとワークフローのセットを使用してインストールおよび管理されます。 &lt;code&gt;Pkg&lt;/code&gt; ジュリアと船は、あなたのプロジェクトの依存関係をインストールし、管理することができますことをパッケージマネージャ。プロジェクトファイル（プロジェクトが依存する他のプロジェクトを記述する）とマニフェストファイル（プロジェクトの完全な依存関係グラフの正確なバージョンのスナップショット）の作成と操作を支援します。</target>
        </trans-unit>
        <trans-unit id="3e86dc9fbf230d572664966d4794a26de9273668" translate="yes" xml:space="preserve">
          <source>Julia supports parallel loops using the &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.@threads&quot;&gt;&lt;code&gt;Threads.@threads&lt;/code&gt;&lt;/a&gt; macro. This macro is affixed in front of a &lt;code&gt;for&lt;/code&gt; loop to indicate to Julia that the loop is a multi-threaded region:</source>
          <target state="translated">Juliaは、&lt;a href=&quot;../../base/multi-threading/index#Base.Threads.@threads&quot;&gt; &lt;code&gt;Threads.@threads&lt;/code&gt; &lt;/a&gt;マクロを使用して並列ループをサポートします。このマクロは &lt;code&gt;for&lt;/code&gt; ループの前に付けられ、ループがマルチスレッド領域であることをJuliaに示します。</target>
        </trans-unit>
        <trans-unit id="a5283fbcd3917bac5a655bc39180ded4c3af822e" translate="yes" xml:space="preserve">
          <source>Julia supports three forms of numerical conversion, which differ in their handling of inexact conversions.</source>
          <target state="translated">Juliaは3つの形式の数値変換をサポートしており、不正確な変換の扱いが異なります。</target>
        </trans-unit>
        <trans-unit id="ab0cbf25806d0b9c5fc2aa6aef5c6cef44171513" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scoping_vs._dynamic_scoping&quot;&gt;lexical scoping&lt;/a&gt;, meaning that a function's scope does not inherit from its caller's scope, but from the scope in which the function was defined. For example, in the following code the &lt;code&gt;x&lt;/code&gt; inside &lt;code&gt;foo&lt;/code&gt; refers to the &lt;code&gt;x&lt;/code&gt; in the global scope of its module &lt;code&gt;Bar&lt;/code&gt;:</source>
          <target state="translated">Juliaは&lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scoping_vs._dynamic_scoping&quot;&gt;字句スコープを&lt;/a&gt;使用します。つまり、関数のスコープは呼び出し元のスコープから継承されず、関数が定義されたスコープから継承されます。例えば、次のコードに &lt;code&gt;x&lt;/code&gt; 内部 &lt;code&gt;foo&lt;/code&gt; が指す &lt;code&gt;x&lt;/code&gt; そのモジュールのグローバルスコープの &lt;code&gt;Bar&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c3c73ac079b0c4f92a7cd6345869462d4c4c72df" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;code&gt;end&lt;/code&gt; to denote the end of conditional blocks, like &lt;code&gt;if&lt;/code&gt;, loop blocks, like &lt;code&gt;while&lt;/code&gt;/ &lt;code&gt;for&lt;/code&gt;, and functions. In lieu of the one-line &lt;code&gt;if ( cond ) statement&lt;/code&gt;, Julia allows statements of the form &lt;code&gt;if cond; statement; end&lt;/code&gt;, &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; and &lt;code&gt;!cond || statement&lt;/code&gt;. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt;, because of the operator precedence.</source>
          <target state="translated">Juliaは、 &lt;code&gt;if&lt;/code&gt; のような条件付きブロック、 &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; のようなループブロック、および関数の &lt;code&gt;end&lt;/code&gt; を示すためにendを使用します。 1行の &lt;code&gt;if ( cond ) statement&lt;/code&gt; 代わりに、Juliaは &lt;code&gt;if cond; statement; end&lt;/code&gt; の形式のステートメントを許可します。ステートメント; end、 &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; および &lt;code&gt;!cond || statement&lt;/code&gt; 。後の2つの構文の代入ステートメントは、演算子の優先順位のため、括弧で明示的にラップする必要があります &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt; 例：cond &amp;amp;&amp;amp;（x = value））。</target>
        </trans-unit>
        <trans-unit id="0cabc05bc6f900c3729476582490d063a944c3f3" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;code&gt;end&lt;/code&gt; to denote the end of conditional blocks, like &lt;code&gt;if&lt;/code&gt;, loop blocks, like &lt;code&gt;while&lt;/code&gt;/ &lt;code&gt;for&lt;/code&gt;, and functions. In lieu of the one-line &lt;code&gt;if ( cond ) statement&lt;/code&gt;, Julia allows statements of the form &lt;code&gt;if cond; statement; end&lt;/code&gt;, &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; and &lt;code&gt;!cond || statement&lt;/code&gt;. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt;.</source>
          <target state="translated">Juliaは、 &lt;code&gt;if&lt;/code&gt; のような条件付きブロック、 &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; のようなループブロック、および関数の &lt;code&gt;end&lt;/code&gt; を示すためにendを使用します。 1行の &lt;code&gt;if ( cond ) statement&lt;/code&gt; 代わりに、Juliaは &lt;code&gt;if cond; statement; end&lt;/code&gt; の形式のステートメントを許可します。ステートメント; end、 &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; および &lt;code&gt;!cond || statement&lt;/code&gt; 。後者の2つの構文の代入ステートメントは、括弧で明示的にラップする必要があります &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt; 例：cond &amp;amp;&amp;amp;（x = value））。</target>
        </trans-unit>
        <trans-unit id="c1da921baa95047321b954687696b91e15a78b61" translate="yes" xml:space="preserve">
          <source>Julia uses machine arithmetic for integer computations. This means that the range of &lt;code&gt;Int&lt;/code&gt; values is bounded and wraps around at either end so that adding, subtracting and multiplying integers can overflow or underflow, leading to some results that can be unsettling at first:</source>
          <target state="translated">Juliaは整数計算に機械演算を使用します。これは、 &lt;code&gt;Int&lt;/code&gt; 値の範囲が制限され、両端で折り返されるため、整数の加算、減算、乗算がオーバーフローまたはアンダーフローして、最初は不安定になる可能性がある結果が生じることを意味します。</target>
        </trans-unit>
        <trans-unit id="51011bd7d0e6585180df272ca646802fbeb44e3f" translate="yes" xml:space="preserve">
          <source>Julia uses the UTF-8 encoding by default, and support for new encodings can be added by packages. For example, the &lt;a href=&quot;https://github.com/JuliaStrings/LegacyStrings.jl&quot;&gt;LegacyStrings.jl&lt;/a&gt; package implements &lt;code&gt;UTF16String&lt;/code&gt; and &lt;code&gt;UTF32String&lt;/code&gt; types. Additional discussion of other encodings and how to implement support for them is beyond the scope of this document for the time being. For further discussion of UTF-8 encoding issues, see the section below on &lt;a href=&quot;#man-byte-array-literals-1&quot;&gt;byte array literals&lt;/a&gt;. The &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt;&lt;code&gt;transcode&lt;/code&gt;&lt;/a&gt; function is provided to convert data between the various UTF-xx encodings, primarily for working with external data and libraries.</source>
          <target state="translated">JuliaはデフォルトでUTF-8エンコーディングを使用し、新しいエンコーディングのサポートをパッケージで追加できます。たとえば、&lt;a href=&quot;https://github.com/JuliaStrings/LegacyStrings.jl&quot;&gt;LegacyStrings.jl&lt;/a&gt;パッケージは &lt;code&gt;UTF16String&lt;/code&gt; および &lt;code&gt;UTF32String&lt;/code&gt; タイプを実装します。他のエンコーディングとそれらのサポートを実装する方法の追加の説明は、当面このドキュメントの範囲を超えています。 UTF-8エンコーディングの問題の詳細については、&lt;a href=&quot;#man-byte-array-literals-1&quot;&gt;バイト配列リテラル&lt;/a&gt;に関する以下のセクションを参照してください。&lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt; &lt;code&gt;transcode&lt;/code&gt; &lt;/a&gt;機能は、主に外部のデータやライブラリを操作するための、様々なUTF-xxのエンコーディングの間でデータを変換するために設けられています。</target>
        </trans-unit>
        <trans-unit id="5e0e9c6a66c5fa559fda71e594a3ae5240a6637e" translate="yes" xml:space="preserve">
          <source>Julia uses the first of these that exists to try to load the public &lt;code&gt;Priv&lt;/code&gt; package from the file &lt;code&gt;packages/Priv/HDKrT/src/Priv.jl&lt;/code&gt; in the depot where it was found.</source>
          <target state="translated">Juliaは、存在する最初のファイルを &lt;code&gt;packages/Priv/HDKrT/src/Priv.jl&lt;/code&gt; して、見つかったデポのファイルpackages / Priv / HDKrT / src / Priv.jlからパブリック &lt;code&gt;Priv&lt;/code&gt; パッケージをロードしようとします。</target>
        </trans-unit>
        <trans-unit id="30edeef56ee9d985332259b8e62139e00973bd46" translate="yes" xml:space="preserve">
          <source>Julia uses your system's locale and language settings to determine which characters can be printed as-is and which must be output using the generic, escaped &lt;code&gt;\u&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; input forms. In addition to these Unicode escape forms, all of &lt;a href=&quot;https://en.wikipedia.org/wiki/C_syntax#Backslash_escapes&quot;&gt;C's traditional escaped input forms&lt;/a&gt; can also be used:</source>
          <target state="translated">Juliaはシステムのロケールと言語の設定を使用して、そのまま印刷できる文字と、汎用のエスケープされた &lt;code&gt;\u&lt;/code&gt; または &lt;code&gt;\U&lt;/code&gt; 入力フォームを使用して出力する必要がある文字を決定します。これらのUnicodeエスケープ形式に加えて、&lt;a href=&quot;https://en.wikipedia.org/wiki/C_syntax#Backslash_escapes&quot;&gt;Cの従来のエスケープされた入力形式&lt;/a&gt;もすべて使用できます。</target>
        </trans-unit>
        <trans-unit id="bd0dc71ebce3799f196e4c40689f527bedaa69fb" translate="yes" xml:space="preserve">
          <source>Julia values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller.</source>
          <target state="translated">ユリアの値は、関数に代入されたり渡されたりしてもコピーされません。関数が配列を変更した場合、その変更は呼び出し元に表示されます。</target>
        </trans-unit>
        <trans-unit id="7ac4008d58382151203baf7753fcd45089959029" translate="yes" xml:space="preserve">
          <source>Julia values are not copied when passed to a function. If a function modifies an array, the changes will be visible in the caller.</source>
          <target state="translated">ユリアの値は関数に渡されてもコピーされません。関数が配列を変更した場合、その変更は呼び出し元に表示されます。</target>
        </trans-unit>
        <trans-unit id="8837407288696b8f56b310a5e7e527268f191a69" translate="yes" xml:space="preserve">
          <source>Julia will even let you redefine built-in constants and functions if needed (although this is not recommended to avoid potential confusions):</source>
          <target state="translated">必要に応じて、Juliaは組み込みの定数や関数を再定義することもできます(ただし、混乱を避けるためにはこれは推奨されません)。</target>
        </trans-unit>
        <trans-unit id="bbfd1a84071c3afc3da5111c8fd03dbd6cb9cfcf" translate="yes" xml:space="preserve">
          <source>Julia workers must NOT be started with &lt;code&gt;--worker&lt;/code&gt;. Starting with &lt;code&gt;--worker&lt;/code&gt; will result in the newly launched workers defaulting to the TCP/IP socket transport implementation.</source>
          <target state="translated">Juliaワーカーは &lt;code&gt;--worker&lt;/code&gt; で始めてはいけません。 &lt;code&gt;--worker&lt;/code&gt; で始まると、新しく起動されたワーカーはデフォルトでTCP / IPソケットトランスポート実装になります。</target>
        </trans-unit>
        <trans-unit id="d2e71f463c75ed1f922e909db643a6a01be0bb01" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; takes the function first, then its arguments, unlike &lt;code&gt;lapply(&amp;lt;structure&amp;gt;, function, ...)&lt;/code&gt; in R. Similarly Julia's equivalent of &lt;code&gt;apply(X, MARGIN, FUN, ...)&lt;/code&gt; in R is &lt;a href=&quot;../../base/arrays/index#Base.mapslices&quot;&gt;&lt;code&gt;mapslices&lt;/code&gt;&lt;/a&gt; where the function is the first argument.</source>
          <target state="translated">Juliaの&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;は、 &lt;code&gt;lapply(&amp;lt;structure&amp;gt;, function, ...)&lt;/code&gt; とは異なり、最初に関数を受け取り、次に引数を受け取ります。同様に、Rの &lt;code&gt;apply(X, MARGIN, FUN, ...)&lt;/code&gt; に相当するJulia は、関数が&lt;a href=&quot;../../base/arrays/index#Base.mapslices&quot;&gt; &lt;code&gt;mapslices&lt;/code&gt; &lt;/a&gt;である最初の引数です。</target>
        </trans-unit>
        <trans-unit id="f5bb002ee0de69716a37fbfcd112bddd1aed44f5" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt;&lt;code&gt;maximum&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt;&lt;code&gt;minimum&lt;/code&gt;&lt;/a&gt; are different from their counterparts in R. They all accept an optional keyword argument &lt;code&gt;dims&lt;/code&gt;, which indicates the dimensions, over which the operation is carried out. For instance, let &lt;code&gt;A = [1 2; 3 4]&lt;/code&gt; in Julia and &lt;code&gt;B &amp;lt;- rbind(c(1,2),c(3,4))&lt;/code&gt; be the same matrix in R. Then &lt;code&gt;sum(A)&lt;/code&gt; gives the same result as &lt;code&gt;sum(B)&lt;/code&gt;, but &lt;code&gt;sum(A, dims=1)&lt;/code&gt; is a row vector containing the sum over each column and &lt;code&gt;sum(A, dims=2)&lt;/code&gt; is a column vector containing the sum over each row. This contrasts to the behavior of R, where separate &lt;code&gt;colSums(B)&lt;/code&gt; and &lt;code&gt;rowSums(B)&lt;/code&gt; functions provide these functionalities. If the &lt;code&gt;dims&lt;/code&gt; keyword argument is a vector, then it specifies all the dimensions over which the sum is performed, while retaining the dimensions of the summed array, e.g. &lt;code&gt;sum(A, dims=(1,2)) == hcat(10)&lt;/code&gt;. It should be noted that there is no error checking regarding the second argument.</source>
          <target state="translated">Juliaの&lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt; &lt;code&gt;maximum&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt; &lt;code&gt;minimum&lt;/code&gt; &lt;/a&gt;は、Rの対応するものとは異なります。これらはすべて、操作が実行される次元を示すオプションのキーワード引数 &lt;code&gt;dims&lt;/code&gt; を受け入れます。たとえば、 &lt;code&gt;A = [1 2; 3 4]&lt;/code&gt; ジュリアとで &lt;code&gt;B &amp;lt;- rbind(c(1,2),c(3,4))&lt;/code&gt; 次にR.で同じ行列である &lt;code&gt;sum(A)&lt;/code&gt; 同じ結果が得られる &lt;code&gt;sum(B)&lt;/code&gt; が、 &lt;code&gt;sum(A, dims=1)&lt;/code&gt; は各列の合計を含む行ベクトルで、 &lt;code&gt;sum(A, dims=2)&lt;/code&gt; は各行の合計を含む列ベクトルです。これは、Rの動作とは対照的です。 &lt;code&gt;colSums(B)&lt;/code&gt; および &lt;code&gt;rowSums(B)&lt;/code&gt; 関数は、これらの機能を提供します。 &lt;code&gt;dims&lt;/code&gt; キーワード引数がベクトルの場合、合計された配列の次元を保持しながら、合計が実行されるすべての次元を指定します。例： &lt;code&gt;sum(A, dims=(1,2)) == hcat(10)&lt;/code&gt; 。2番目の引数に関するエラーチェックはありません。</target>
        </trans-unit>
        <trans-unit id="fa67fe88be62afc80adeb10ce9e92a9b5f6f9cf4" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt; are the equivalent of &lt;code&gt;pmax&lt;/code&gt; and &lt;code&gt;pmin&lt;/code&gt; respectively in R, but both arguments need to have the same dimensions. While &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt;&lt;code&gt;maximum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt;&lt;code&gt;minimum&lt;/code&gt;&lt;/a&gt; replace &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; in R, there are important differences.</source>
          <target state="translated">Juliaの&lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/math/index#Base.min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt;は、それぞれRの &lt;code&gt;pmax&lt;/code&gt; と &lt;code&gt;pmin&lt;/code&gt; と同等ですが、両方の引数は同じ次元である必要があります。一方で&lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt; &lt;code&gt;maximum&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt; &lt;code&gt;minimum&lt;/code&gt; &lt;/a&gt;置き換える &lt;code&gt;max&lt;/code&gt; と &lt;code&gt;min&lt;/code&gt; Rで、重要な違いがあります。</target>
        </trans-unit>
        <trans-unit id="948bcc3b1298520e6e2ce90508494e37d41ff33b" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; is designed for the case where each function call does a large amount of work. In contrast, &lt;code&gt;@distributed for&lt;/code&gt; can handle situations where each iteration is tiny, perhaps merely summing two numbers. Only worker processes are used by both &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;@distributed for&lt;/code&gt; for the parallel computation. In case of &lt;code&gt;@distributed for&lt;/code&gt;, the final reduction is done on the calling process.</source>
          <target state="translated">Juliaの&lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt;は、各関数呼び出しが大量の作業を行う場合のために設計されています。対照的に、 &lt;code&gt;@distributed for&lt;/code&gt; は、各反復がごくわずかで、おそらく2つの数値を合計するだけの状況を処理できます。ワーカープロセスのみが、並列計算のために&lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;@distributed for&lt;/code&gt; 両方で使用されます。以下の場合 &lt;code&gt;@distributed for&lt;/code&gt; 、最終減速は呼び出し元のプロセスで行われます。</target>
        </trans-unit>
        <trans-unit id="1dee74c8ab40f9a1e425f6d177c82bc6b08fa25e" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diag&quot;&gt;&lt;code&gt;diag&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diagm&quot;&gt;&lt;code&gt;diagm&lt;/code&gt;&lt;/a&gt; are not like R's.</source>
          <target state="translated">ジュリアの&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diag&quot;&gt; &lt;code&gt;diag&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diagm&quot;&gt; &lt;code&gt;diagm&lt;/code&gt; &lt;/a&gt;は、Rのダイアグムとは異なります。</target>
        </trans-unit>
        <trans-unit id="05bb4ea25c67464af30f3b1789a99b7d0ce690d4" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt; returns singular values as a vector instead of as a dense diagonal matrix.</source>
          <target state="translated">Juliaの&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt;は、特異な値を密な対角行列ではなくベクトルとして返します。</target>
        </trans-unit>
        <trans-unit id="aa13bfca9375abd93cb6c7683cece63cd5fd2582" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;*&lt;/code&gt; operator can perform matrix multiplication, unlike in R. If &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are matrices, then &lt;code&gt;A * B&lt;/code&gt; denotes a matrix multiplication in Julia, equivalent to R's &lt;code&gt;A %*% B&lt;/code&gt;. In R, this same notation would perform an element-wise (Hadamard) product. To get the element-wise multiplication operation, you need to write &lt;code&gt;A .* B&lt;/code&gt; in Julia.</source>
          <target state="translated">Juliaの &lt;code&gt;*&lt;/code&gt; 演算子は、Rとは異なり、行列の乗算を実行できます &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; が行列の場合、 &lt;code&gt;A * B&lt;/code&gt; は、Rの &lt;code&gt;A %*% B&lt;/code&gt; に相当するJuliaの行列の乗算を示します。Rでは、この同じ表記は要素ごとの（アダマール）積を実行します。要素ごとの乗算演算を取得するには、Juliaで &lt;code&gt;A .* B&lt;/code&gt; と記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="eb6c182bb057e6aaee719738d353d529a33805be" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;-&amp;gt;&lt;/code&gt; creates an anonymous function, it does not access a member via a pointer.</source>
          <target state="translated">Juliaの &lt;code&gt;-&amp;gt;&lt;/code&gt; は無名関数を作成し、ポインターを介してメンバーにアクセスしません。</target>
        </trans-unit>
        <trans-unit id="0862128440ff742c36348e2d0db0ca8e8f8925ae" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;-&amp;gt;&lt;/code&gt; creates an anonymous function.</source>
          <target state="translated">Juliaの &lt;code&gt;-&amp;gt;&lt;/code&gt; は無名関数を作成します。</target>
        </trans-unit>
        <trans-unit id="5ae5cdad8a8956ce245f1722cb08571c8a10bd0f" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;Char&lt;/code&gt; type is 32 bits, which is not the same as the wide character type (&lt;code&gt;wchar_t&lt;/code&gt; or &lt;code&gt;wint_t&lt;/code&gt;) on all platforms.</source>
          <target state="translated">Juliaの &lt;code&gt;Char&lt;/code&gt; 型は32ビットであり、すべてのプラットフォームでワイド文字型（ &lt;code&gt;wchar_t&lt;/code&gt; または &lt;code&gt;wint_t&lt;/code&gt; ）と同じではありません。</target>
        </trans-unit>
        <trans-unit id="b385c4d6332873c3dcd00293c1c25f1adc3ec233" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;^&lt;/code&gt; is exponentiation (pow), not bitwise XOR as in C/C++ (use &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;, in Julia)</source>
          <target state="translated">ジュリアの &lt;code&gt;^&lt;/code&gt; は指数（pow）であり、C / C ++のようにビット単位のXORではありません（ジュリアでは&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; を&lt;/a&gt;使用します）</target>
        </trans-unit>
        <trans-unit id="b992e2bb2c187c81d565dd2576257e75a4ff2ac1" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, etc. blocks are terminated by the &lt;code&gt;end&lt;/code&gt; keyword. Indentation level is not significant as it is in Python.</source>
          <target state="translated">Juliaの &lt;code&gt;for&lt;/code&gt; 、 &lt;code&gt;if&lt;/code&gt; 、 &lt;code&gt;while&lt;/code&gt; などのブロックは、 &lt;code&gt;end&lt;/code&gt; キーワードで終了します。インデントレベルはPythonの場合のように重要ではありません。</target>
        </trans-unit>
        <trans-unit id="4a5e37d3fa53f0bf640b0dba96a1ab8faecfac9f" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;struct&lt;/code&gt;s do not support dynamically adding fields at runtime, unlike MATLAB's &lt;code&gt;class&lt;/code&gt;es. Instead, use a &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Juliaの &lt;code&gt;struct&lt;/code&gt; は、MATLABの &lt;code&gt;class&lt;/code&gt; es とは異なり、実行時にフィールドを動的に追加することをサポートしていません。代わりに、&lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="eb62051205cdc85bbd2ca3341a23ca3df8234a6b" translate="yes" xml:space="preserve">
          <source>Julia's REPL keybindings may be fully customized to a user's preferences by passing a dictionary to &lt;code&gt;REPL.setup_interface&lt;/code&gt;. The keys of this dictionary may be characters or strings. The key &lt;code&gt;'*'&lt;/code&gt; refers to the default action. Control plus character &lt;code&gt;x&lt;/code&gt; bindings are indicated with &lt;code&gt;&quot;^x&quot;&lt;/code&gt;. Meta plus &lt;code&gt;x&lt;/code&gt; can be written &lt;code&gt;&quot;\\Mx&quot;&lt;/code&gt;. The values of the custom keymap must be &lt;code&gt;nothing&lt;/code&gt; (indicating that the input should be ignored) or functions that accept the signature &lt;code&gt;(PromptState, AbstractREPL, Char)&lt;/code&gt;. The &lt;code&gt;REPL.setup_interface&lt;/code&gt; function must be called before the REPL is initialized, by registering the operation with &lt;a href=&quot;#Base.atreplinit&quot;&gt;&lt;code&gt;atreplinit&lt;/code&gt;&lt;/a&gt; . For example, to bind the up and down arrow keys to move through history without prefix search, one could put the following code in &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">JuliaのREPLキーバインドは、辞書を &lt;code&gt;REPL.setup_interface&lt;/code&gt; に渡すことにより、ユーザーの設定に完全にカスタマイズできます。この辞書のキーは文字または文字列です。キー &lt;code&gt;'*'&lt;/code&gt; はデフォルトのアクションを示します。コントロールと文字 &lt;code&gt;x&lt;/code&gt; バインディングは、 &lt;code&gt;&quot;^x&quot;&lt;/code&gt; 示されます。メタプラス &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;&quot;\\Mx&quot;&lt;/code&gt; と書くことができます。カスタムキーマップの値は、 &lt;code&gt;nothing&lt;/code&gt; （入力を無視する必要があることを示す）か、署名を受け入れる関数 &lt;code&gt;(PromptState, AbstractREPL, Char)&lt;/code&gt; なければなりません。 &lt;code&gt;REPL.setup_interface&lt;/code&gt; の REPLが初期化される前に、この関数は使用して操作を登録することで、呼び出されなければなりません&lt;a href=&quot;#Base.atreplinit&quot;&gt; &lt;code&gt;atreplinit&lt;/code&gt; &lt;/a&gt;。たとえば、上矢印キーと下矢印キーをバインドして、プレフィックス検索なしで履歴を移動するには、次のコードを &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="ff3f30910627d9bc09b7bdaeca1a62844f17b994" translate="yes" xml:space="preserve">
          <source>Julia's base library has a an internal &lt;code&gt;sub2ind&lt;/code&gt; function to calculate a linear index into an n-dimensional array, based on a set of n multilinear indices - in other words, to calculate the index &lt;code&gt;i&lt;/code&gt; that can be used to index into an array &lt;code&gt;A&lt;/code&gt; using &lt;code&gt;A[i]&lt;/code&gt;, instead of &lt;code&gt;A[x,y,z,...]&lt;/code&gt;. One possible implementation is the following:</source>
          <target state="translated">ジュリアの基本ライブラリは、内部有する &lt;code&gt;sub2ind&lt;/code&gt; のセットに基づいて、n次元アレイ、nは多重線形インデックスに線形指数を計算する機能を-インデックスを計算するために、換言すれば、 &lt;code&gt;i&lt;/code&gt; 配列へのインデックスに使用することができる &lt;code&gt;A&lt;/code&gt; 使用 &lt;code&gt;A[i]&lt;/code&gt; 、 &lt;code&gt;A[x,y,z,...]&lt;/code&gt; ではなく。可能な実装の1つは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a8c2555d21a070c01d642324e7f2023f9aae7e60" translate="yes" xml:space="preserve">
          <source>Julia's compiler specializes code for argument types at function boundaries, so in the original implementation it does not know the type of &lt;code&gt;a&lt;/code&gt; during the loop (since it is chosen randomly). Therefore the second version is generally faster since the inner loop can be recompiled as part of &lt;code&gt;fill_twos!&lt;/code&gt; for different types of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Juliaのコンパイラーは、関数の境界での引数型のコードを特殊化しているため、元の実装では、ループ中に &lt;code&gt;a&lt;/code&gt; の型がわかりません（ランダムに選択されるため）。したがって、2番目のバージョンは、内部ループを &lt;code&gt;fill_twos!&lt;/code&gt; 一部として再コンパイルできるため、一般的に高速です。さまざまなタイプのため。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="33f4b2b5366e275dc9d4f8493361eee0738216e2" translate="yes" xml:space="preserve">
          <source>Julia's implementation of message passing is different from other environments such as MPI &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;. Communication in Julia is generally &quot;one-sided&quot;, meaning that the programmer needs to explicitly manage only one process in a two-process operation. Furthermore, these operations typically do not look like &quot;message send&quot; and &quot;message receive&quot; but rather resemble higher-level operations like calls to user functions.</source>
          <target state="translated">Juliaのメッセージパッシングの実装は、MPI &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;などの他の環境とは異なります。 Juliaでの通信は、一般に「片側」です。つまり、プログラマーは、2つのプロセスの操作で1つのプロセスのみを明示的に管理する必要があります。さらに、これらの操作は通常「メッセージ送信」や「メッセージ受信」のようには見えませんが、ユーザー関数の呼び出しなどの高レベルの操作に似ています。</target>
        </trans-unit>
        <trans-unit id="2d95266cdef29852b478ae12f711e31b88ca02d5" translate="yes" xml:space="preserve">
          <source>Julia's internal indexing machinery will automatically (and invisibly) convert all indexing operations into the preferred style. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.</source>
          <target state="translated">Juliaの内部のインデックス作成機構は、すべてのインデックス作成操作を自動的に(そして目に見えないように)好みのスタイルに変換します。これにより、明示的なメソッドが提供されていない場合でも、ユーザは任意のインデキシングスタイルを使用して配列の要素にアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="63b1a2fb20181eebd075a05851e2cc85e0131235" translate="yes" xml:space="preserve">
          <source>Julia's macro expander solves these problems in the following way. First, variables within a macro result are classified as either local or global. A variable is considered local if it is assigned to (and not declared global), declared local, or used as a function argument name. Otherwise, it is considered global. Local variables are then renamed to be unique (using the &lt;a href=&quot;../../base/base/index#Base.gensym&quot;&gt;&lt;code&gt;gensym&lt;/code&gt;&lt;/a&gt; function, which generates new symbols), and global variables are resolved within the macro definition environment. Therefore both of the above concerns are handled; the macro's locals will not conflict with any user variables, and &lt;code&gt;time&lt;/code&gt; and &lt;code&gt;println&lt;/code&gt; will refer to the Julia Base definitions.</source>
          <target state="translated">Juliaのマクロエキスパンダーは、次の方法でこれらの問題を解決します。まず、マクロ結果内の変数は、ローカルまたはグローバルのいずれかに分類されます。変数が割り当てられている（グローバルとして宣言されていない）、ローカルとして宣言されている、または関数の引数名として使用されている場合、その変数はローカルと見なされます。それ以外の場合は、グローバルと見なされます。次に、ローカル変数の名前が一意になるように変更され（&lt;a href=&quot;../../base/base/index#Base.gensym&quot;&gt; &lt;code&gt;gensym&lt;/code&gt; &lt;/a&gt;関数を使用して新しいシンボルを生成します）、グローバル変数はマクロ定義環境内で解決されます。したがって、上記の懸念の両方が処理されます。マクロのローカル変数はユーザー変数と競合せず、 &lt;code&gt;time&lt;/code&gt; および &lt;code&gt;println&lt;/code&gt; はJulia Base定義を参照します。</target>
        </trans-unit>
        <trans-unit id="86edf724d95c13484ea1286ad4816e866d0db9af" translate="yes" xml:space="preserve">
          <source>Julia's markdown supports interpolation in a very similar way to basic string literals, with the difference that it will store the object itself in the Markdown tree (as opposed to converting it to a string). When the Markdown content is rendered the usual &lt;code&gt;show&lt;/code&gt; methods will be called, and these can be overridden as usual. This design allows the Markdown to be extended with arbitrarily complex features (such as references) without cluttering the basic syntax.</source>
          <target state="translated">Juliaのマークダウンは、基本的な文字列リテラルと非常によく似た方法で補間をサポートしますが、オブジェクト自体を（文字列に変換するのではなく）Markdownツリーに格納する点が異なります。Markdownコンテンツがレンダリングされると、通常の &lt;code&gt;show&lt;/code&gt; メソッドが呼び出され、これらは通常どおりオーバーライドできます。この設計により、Markdownは、基本的な構文を混乱させることなく、任意に複雑な機能（参照など）で拡張できます。</target>
        </trans-unit>
        <trans-unit id="0901cb4cceb0fa7182b9eca38ef424535bdbefb3" translate="yes" xml:space="preserve">
          <source>Julia's method polymorphism is one of its most powerful features, yet exploiting this power can pose design challenges. In particular, in more complex method hierarchies it is not uncommon for &lt;a href=&quot;#man-ambiguities-1&quot;&gt;ambiguities&lt;/a&gt; to arise.</source>
          <target state="translated">ジュリアのメソッドのポリモーフィズムは、その最も強力な機能の1つですが、この力を利用すると、設計上の課題が発生する可能性があります。特に、より複雑なメソッド階層では、&lt;a href=&quot;#man-ambiguities-1&quot;&gt;あいまいさ&lt;/a&gt;が発生することは珍しくありません。</target>
        </trans-unit>
        <trans-unit id="23f2c84d6fee04af47b767e6d6e002d54d481014" translate="yes" xml:space="preserve">
          <source>Julia's multidimensional arrays are stored in memory in column-major order. Here is some code that creates a 2D array and accesses its properties:</source>
          <target state="translated">ジュリアの多次元配列は、メモリにカラム・メジャー順に格納されます。ここでは、2次元配列を作成し、そのプロパティにアクセスするコードをいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="5f52e87d6645fc0ed7cad30b976ecccc50cc320e" translate="yes" xml:space="preserve">
          <source>Julia's parallel programming platform uses &lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;Tasks (aka Coroutines)&lt;/a&gt; to switch among multiple computations. To express an order of execution between lightweight threads communication primitives are necessary. Julia offers &lt;code&gt;Channel(func::Function, ctype=Any, csize=0, taskref=nothing)&lt;/code&gt; that creates a new task from &lt;code&gt;func&lt;/code&gt;, binds it to a new channel of type &lt;code&gt;ctype&lt;/code&gt; and size &lt;code&gt;csize&lt;/code&gt; and schedule the task. &lt;code&gt;Channels&lt;/code&gt; can serve as a way to communicate between tasks, as &lt;code&gt;Channel{T}(sz::Int)&lt;/code&gt; creates a buffered channel of type &lt;code&gt;T&lt;/code&gt; and size &lt;code&gt;sz&lt;/code&gt;. Whenever code performs a communication operation like &lt;code&gt;fetch&lt;/code&gt; or &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, the current task is suspended and a scheduler picks another task to run. A task is restarted when the event it is waiting for completes.</source>
          <target state="translated">Juliaの並列プログラミングプラットフォームは、&lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;タスク（別名コルーチン）&lt;/a&gt;を使用して複数の計算を切り替えます。軽量スレッド間の実行順序を表現するには、通信プリミティブが必要です。 Juliaは、 &lt;code&gt;func&lt;/code&gt; から新しいタスクを作成し、それをタイプ &lt;code&gt;ctype&lt;/code&gt; およびサイズ &lt;code&gt;csize&lt;/code&gt; の新しいチャネルにバインドしてタスクをスケジュールする &lt;code&gt;Channel(func::Function, ctype=Any, csize=0, taskref=nothing)&lt;/code&gt; を提供しています。 &lt;code&gt;Channels&lt;/code&gt; のように、タスク間で通信する方法として役立つことができる &lt;code&gt;Channel{T}(sz::Int)&lt;/code&gt; タイプの緩衝チャネル作成 &lt;code&gt;T&lt;/code&gt; およびサイズ &lt;code&gt;sz&lt;/code&gt; 。コードが &lt;code&gt;fetch&lt;/code&gt; や&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;、現在のタスクは一時停止され、スケジューラは実行する別のタスクを選択します。タスクは、待機しているイベントが完了すると再開されます。</target>
        </trans-unit>
        <trans-unit id="b466bf8ce3736bba15b2ecdae9872de461ea3a56" translate="yes" xml:space="preserve">
          <source>Julia's promotion system makes arithmetic operations on mixtures of argument types &quot;just work&quot; naturally and automatically. See &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt; for details of the promotion system.</source>
          <target state="translated">ジュリアの昇格システムは、引数の型の混合に対する算術演算を自然にそして自動的に「ただ働く」ようにします。参照&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;変換と振興を&lt;/a&gt;推進システムの詳細については。</target>
        </trans-unit>
        <trans-unit id="4c3a6166fa4f354bffc12e579d7219f7b110624c" translate="yes" xml:space="preserve">
          <source>Julia's single quotes enclose characters, not strings.</source>
          <target state="translated">ジュリアのシングルクォートは文字列ではなく文字を囲んでいます。</target>
        </trans-unit>
        <trans-unit id="5826232507a46053a3ad6eca3433bcfcdddedfd4" translate="yes" xml:space="preserve">
          <source>Julia's slice indexing includes the last element, unlike in Python. &lt;code&gt;a[2:3]&lt;/code&gt; in Julia is &lt;code&gt;a[1:3]&lt;/code&gt; in Python.</source>
          <target state="translated">Juliaのスライスインデックスには、Pythonとは異なり、最後の要素が含まれます。 &lt;code&gt;a[2:3]&lt;/code&gt; ジュリアでは、 &lt;code&gt;a[1:3]&lt;/code&gt; Pythonで。</target>
        </trans-unit>
        <trans-unit id="d3f2b1b2df721c7080cd008996870d53e3376216" translate="yes" xml:space="preserve">
          <source>Julia's type system is designed to be powerful and expressive, yet clear, intuitive and unobtrusive. Many Julia programmers may never feel the need to write code that explicitly uses types. Some kinds of programming, however, become clearer, simpler, faster and more robust with declared types.</source>
          <target state="translated">Julia の型システムは、パワフルで表現力がありながらも、明確で直感的で控えめな設計になっています。多くのJuliaプログラマは、明示的に型を使用するコードを書く必要性を感じないかもしれません。しかし、ある種のプログラミングでは、宣言された型を使うことで、より明確に、よりシンプルに、より速く、より堅牢になります。</target>
        </trans-unit>
        <trans-unit id="2601bca815fd3b23be75d3eb7a5f70824d2baba0" translate="yes" xml:space="preserve">
          <source>Julia's type system is dynamic, but gains some of the advantages of static type systems by making it possible to indicate that certain values are of specific types. This can be of great assistance in generating efficient code, but even more significantly, it allows method dispatch on the types of function arguments to be deeply integrated with the language. Method dispatch is explored in detail in &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;, but is rooted in the type system presented here.</source>
          <target state="translated">Juliaの型システムは動的ですが、特定の値が特定の型であることを示すことを可能にすることで、静的型システムのいくつかの利点を獲得します。これは効率的なコードの生成に非常に役立ちますが、さらに重要なことに、関数の引数の型に対するメソッドディスパッチを言語と深く統合することができます。メソッドのディスパッチについては、「&lt;a href=&quot;../methods/index#Methods-1&quot;&gt;メソッド」&lt;/a&gt;で詳しく説明していますが、ここで紹介する型システムに基づいています。</target>
        </trans-unit>
        <trans-unit id="060a807b9436918cd4c19176ffcd9bf4c0ffdec4" translate="yes" xml:space="preserve">
          <source>Julia's updating operators (e.g. &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, ...) are &lt;em&gt;not in-place&lt;/em&gt; whereas NumPy's are. This means &lt;code&gt;A = [1, 1]; B = A; B += [3, 3]&lt;/code&gt; doesn't change values in &lt;code&gt;A&lt;/code&gt;, it rather rebinds the name &lt;code&gt;B&lt;/code&gt; to the result of the right-hand side &lt;code&gt;B = B + 3&lt;/code&gt;, which is a new array. For in-place operation, use &lt;code&gt;B .+= 3&lt;/code&gt; (see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot operators&lt;/a&gt;), explicit loops, or &lt;code&gt;InplaceOps.jl&lt;/code&gt;.</source>
          <target state="translated">Juliaの更新演算子（例： &lt;code&gt;+=&lt;/code&gt; 、 &lt;code&gt;-=&lt;/code&gt; 、...）は&lt;em&gt;インプレースで&lt;/em&gt;はあり&lt;em&gt;ませんが&lt;/em&gt;、NumPy &lt;em&gt;はインプレース&lt;/em&gt;です。つまり、 &lt;code&gt;A = [1, 1]; B = A; B += [3, 3]&lt;/code&gt; は &lt;code&gt;A&lt;/code&gt; の値を変更せず、名前 &lt;code&gt;B&lt;/code&gt; を右側の &lt;code&gt;B = B + 3&lt;/code&gt; の結果に再バインドします。これは新しい配列です。インプレース操作の場合は、 &lt;code&gt;B .+= 3&lt;/code&gt; （&lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;ドット演算子&lt;/a&gt;も参照）、明示的なループ、または &lt;code&gt;InplaceOps.jl&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="29157447971e1b4b6b81d91fd76c285c2b275482" translate="yes" xml:space="preserve">
          <source>Julia, like most technical computing languages, provides a first-class array implementation. Most technical computing languages pay a lot of attention to their array implementation at the expense of other containers. Julia does not treat arrays in any special way. The array library is implemented almost completely in Julia itself, and derives its performance from the compiler, just like any other code written in Julia. As such, it's also possible to define custom array types by inheriting from &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;manual section on the AbstractArray interface&lt;/a&gt; for more details on implementing a custom array type.</source>
          <target state="translated">ジュリアは、ほとんどの技術計算言語と同様に、ファーストクラスの配列実装を提供します。ほとんどの技術計算言語は、他のコンテナーを犠牲にして、配列の実装に多くの注意を払っています。 Juliaは配列を特別な方法で扱いません。配列ライブラリはJulia自体にほぼ完全に実装されており、Juliaで作成された他のコードと同様に、そのパフォーマンスはコンパイラーから得られます。そのため、&lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt;から継承することにより、カスタム配列タイプを定義することもできます。カスタム配列型の実装の詳細については&lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;、AbstractArrayインターフェイス&lt;/a&gt;のマニュアルセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="88d1577dcc4f245ab6ce133765fe78bb8913aa7f" translate="yes" xml:space="preserve">
          <source>Jupiter</source>
          <target state="translated">Jupiter</target>
        </trans-unit>
        <trans-unit id="baa896b33786524acff2009a8d27bd6b3009cef2" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;^R&lt;/code&gt; is a reverse search, &lt;code&gt;^S&lt;/code&gt; is a forward search, with the prompt &lt;code&gt;(i-search)`':&lt;/code&gt;. The two may be used in conjunction with each other to move through the previous or next matching results, respectively.</source>
          <target state="translated">同じように &lt;code&gt;^R&lt;/code&gt; 逆探索で、 &lt;code&gt;^S&lt;/code&gt; プロンプトで前方検索、である &lt;code&gt;(i-search)`':&lt;/code&gt; 。2つを互いに組み合わせて使用​​して、前または次の一致結果を順に移動できます。</target>
        </trans-unit>
        <trans-unit id="9365c41bee7315e2eb3ab59d3b982ca7ca4bb4b9" translate="yes" xml:space="preserve">
          <source>Just as help mode is useful for quick access to documentation, another common task is to use the system shell to execute system commands. Just as &lt;code&gt;?&lt;/code&gt; entered help mode when at the beginning of the line, a semicolon (&lt;code&gt;;&lt;/code&gt;) will enter the shell mode. And it can be exited by pressing backspace at the beginning of the line.</source>
          <target state="translated">ヘルプモードがドキュメントへの迅速なアクセスに役立つのと同様に、別の一般的なタスクは、システムシェルを使用してシステムコマンドを実行することです。と同じように &lt;code&gt;?&lt;/code&gt; 行の先頭でセミコロン（ &lt;code&gt;;&lt;/code&gt; ）がシェルモードに入ると、ヘルプモードに入ります。そして、行の先頭でバックスペースを押すことで終了できます。</target>
        </trans-unit>
        <trans-unit id="e330a59e23d168a0ce147528d526c6c70e235165" translate="yes" xml:space="preserve">
          <source>Just as in &lt;a href=&quot;#man-array-indexing-1&quot;&gt;Indexing&lt;/a&gt;, the &lt;code&gt;end&lt;/code&gt; keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the array being assigned into. Indexed assignment syntax without the &lt;code&gt;end&lt;/code&gt; keyword is equivalent to a call to &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">ちょうどのように&lt;a href=&quot;#man-array-indexing-1&quot;&gt;索引付け&lt;/a&gt;、 &lt;code&gt;end&lt;/code&gt; に割り当てられている配列のサイズによって決定されるようなキーワードは、索引付け括弧内に各次元の最後のインデックスを表すために使用されてもよいです。 &lt;code&gt;end&lt;/code&gt; キーワードなしのインデックス付き割り当て構文は、&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;呼び出しと同等です。：</target>
        </trans-unit>
        <trans-unit id="129fdfb9651f86a9c5a6d204baf7fd51a6f897e9" translate="yes" xml:space="preserve">
          <source>Just as text output is performed by &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; and user-defined types can indicate their textual representation by overloading &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;, Julia provides a standardized mechanism for rich multimedia output (such as images, formatted text, or even audio and video), consisting of three parts:</source>
          <target state="translated">テキスト出力が&lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;によって実行され、ユーザー定義タイプが&lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt;をオーバーロードすることによってテキスト表現を示すことができるのと同様に、Juliaは3つの部分で構成されるリッチマルチメディア出力（画像、フォーマットされたテキスト、またはオーディオとビデオなど）のための標準化されたメカニズムを提供します：</target>
        </trans-unit>
        <trans-unit id="f31418705dc05a56f9681110f63d545eb15e8a22" translate="yes" xml:space="preserve">
          <source>Just as you can put subtype constraints on type parameters in type declarations (see &lt;a href=&quot;../types/index#Parametric-Types-1&quot;&gt;Parametric Types&lt;/a&gt;), you can also constrain type parameters of methods:</source>
          <target state="translated">型宣言の型パラメーターにサブタイプ制約を設定できるのと同じように（&lt;a href=&quot;../types/index#Parametric-Types-1&quot;&gt;パラメトリック型を&lt;/a&gt;参照）、メソッドの型パラメーターを制約することもできます。</target>
        </trans-unit>
        <trans-unit id="3a5b8319210d6e829092640e9c9931c8b6b93159" translate="yes" xml:space="preserve">
          <source>Just like condition expressions used in &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;elseif&lt;/code&gt; or the ternary operator, the operands of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; must be boolean values (&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;). Using a non-boolean value anywhere except for the last entry in a conditional chain is an error:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 、 &lt;code&gt;elseif&lt;/code&gt; 、または三項演算子で使用される条件式と同様に、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; または &lt;code&gt;||&lt;/code&gt; のオペランド ブール値（ &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; ）でなければなりません。条件チェーンの最後のエントリ以外の場所でブール値以外の値を使用すると、エラーになります。</target>
        </trans-unit>
        <trans-unit id="89b905a2ec6630efe24e67a128976a957febd0eb" translate="yes" xml:space="preserve">
          <source>Juxtaposed literal coefficient syntax may conflict with two numeric literal syntaxes: hexadecimal integer literals and engineering notation for floating-point literals. Here are some situations where syntactic conflicts arise:</source>
          <target state="translated">並置リテラル係数構文は、2つの数値リテラル構文(16進整数リテラルと浮動小数点リテラルの工学的表記法)と競合することがあります。ここでは、構文上の競合が発生する状況をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="9ec40672083b66df6ef7fbca9db99f5cc01dc9d5" translate="yes" xml:space="preserve">
          <source>Keep in mind that some Julia features are not currently supported by CUDAnative.jl &lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt; , especially some functions like &lt;code&gt;sin&lt;/code&gt; will need to be replaced with &lt;code&gt;CUDAnative.sin&lt;/code&gt;(cc: @maleadt).</source>
          <target state="translated">Juliaの一部の機能は現在CUDAnative.jl &lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;でサポートされていないことに注意してください。特に、 &lt;code&gt;sin&lt;/code&gt; などの一部の関数は &lt;code&gt;CUDAnative.sin&lt;/code&gt; （cc：@maleadt）で置き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="2f019ec46ab9548a295fae40fb32bbf280932bb8" translate="yes" xml:space="preserve">
          <source>Key bindings</source>
          <target state="translated">キーバインディング</target>
        </trans-unit>
        <trans-unit id="74018238351de8a4b5f41ef51f98e3f2c94d5837" translate="yes" xml:space="preserve">
          <source>KeyError</source>
          <target state="translated">KeyError</target>
        </trans-unit>
        <trans-unit id="23f6f8047d85e8db9b2a5eaadf76de7dfe565d74" translate="yes" xml:space="preserve">
          <source>Keybinding</source>
          <target state="translated">Keybinding</target>
        </trans-unit>
        <trans-unit id="59ba1e5a90c9cfee0b263032ac6574298fc3c42e" translate="yes" xml:space="preserve">
          <source>Keycap Ten</source>
          <target state="translated">キーキャップテン</target>
        </trans-unit>
        <trans-unit id="a3926e039fd753c472f6e172496fda0574369261" translate="yes" xml:space="preserve">
          <source>Keyword</source>
          <target state="translated">Keyword</target>
        </trans-unit>
        <trans-unit id="db32172db3cd21ae36313d815fba0dd39bd7127a" translate="yes" xml:space="preserve">
          <source>Keyword Arguments</source>
          <target state="translated">キーワード引数</target>
        </trans-unit>
        <trans-unit id="37a1398f40ad5a5758f3118ecb2e0028c1f656ac" translate="yes" xml:space="preserve">
          <source>Keyword argument &lt;code&gt;debuginfo&lt;/code&gt; may be one of &lt;code&gt;:source&lt;/code&gt; or &lt;code&gt;:none&lt;/code&gt; (default), to specify the verbosity of code comments.</source>
          <target state="translated">キーワード引数 &lt;code&gt;debuginfo&lt;/code&gt; は、コードコメントの詳細度を指定するために、 &lt;code&gt;:source&lt;/code&gt; または &lt;code&gt;:none&lt;/code&gt; （デフォルト）のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="4eec148d4683d6a5be8244fa8544e4bc73995042" translate="yes" xml:space="preserve">
          <source>Keyword argument &lt;code&gt;lazy=true|false&lt;/code&gt; only affects &lt;code&gt;topology&lt;/code&gt; option &lt;code&gt;:all_to_all&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, the cluster starts off with the master connected to all workers. Specific worker-worker connections are established at the first remote invocation between two workers. This helps in reducing initial resources allocated for intra-cluster communication. Connections are setup depending on the runtime requirements of a parallel program. Default value for &lt;code&gt;lazy&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">キーワード引数 &lt;code&gt;lazy=true|false&lt;/code&gt; は、 &lt;code&gt;topology&lt;/code&gt; オプション &lt;code&gt;:all_to_all&lt;/code&gt; にのみ影響します。場合は &lt;code&gt;true&lt;/code&gt; 、クラスタは、すべての労働者に接続されたマスタから始まり。2つのワーカー間の最初のリモート呼び出しで、特定のワーカー-ワーカー接続が確立されます。これにより、クラスター内通信に割り当てられる初期リソースを削減できます。接続は、並列プログラムのランタイム要件に応じて設定されます。 &lt;code&gt;lazy&lt;/code&gt; のデフォルト値は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a85841ebcc4fbb3f6bb0af53f5f74a1d1107441b" translate="yes" xml:space="preserve">
          <source>Keyword argument default values are evaluated only when necessary (when a corresponding keyword argument is not passed), and in left-to-right order. Therefore default expressions may refer to prior keyword arguments.</source>
          <target state="translated">キーワード引数のデフォルト値は、必要な場合にのみ(対応するキーワード引数が渡されていない場合)、左から右の順に評価されます。そのため、デフォルト式は、それ以前のキーワード引数を参照することがあります。</target>
        </trans-unit>
        <trans-unit id="cd222673b8a5eeb28c17fea40269820af080e4d5" translate="yes" xml:space="preserve">
          <source>Keyword arguments behave quite differently from ordinary positional arguments. In particular, they do not participate in method dispatch. Methods are dispatched based only on positional arguments, with keyword arguments processed after the matching method is identified.</source>
          <target state="translated">キーワード引数は、通常の位置引数とは全く異なる振る舞いをします。特に、キーワード引数はメソッドのディスパッチには参加しません。メソッドは位置引数のみに基づいてディスパッチされ、キーワード引数はマッチするメソッドが特定された後に処理されます。</target>
        </trans-unit>
        <trans-unit id="e1f80b2c92c551f95f3994cdc90a44e035d56013" translate="yes" xml:space="preserve">
          <source>Keyword arguments, if any, are passed through to &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">キーワード引数があれば、それが &lt;code&gt;f&lt;/code&gt; に渡されます。</target>
        </trans-unit>
        <trans-unit id="b8804a97595c6605af997f797488e9f7a887cea7" translate="yes" xml:space="preserve">
          <source>Keyword arguments:</source>
          <target state="translated">キーワード引数。</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="e42f478ffbc394a252424af959d3abd0a98e41e6" translate="yes" xml:space="preserve">
          <source>Keywords are also displayed in the suggested methods after &lt;code&gt;;&lt;/code&gt;, see below line where &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;keepempty&lt;/code&gt; are keyword arguments:</source>
          <target state="translated">キーワードは、提案されたメソッドの後にも表示され &lt;code&gt;;&lt;/code&gt; 、以下の行を参照してください。ここで、 &lt;code&gt;limit&lt;/code&gt; および &lt;code&gt;keepempty&lt;/code&gt; はキーワード引数です。</target>
        </trans-unit>
        <trans-unit id="924acc699e5835f0f13e0c55c14fdfbfa6ba40d8" translate="yes" xml:space="preserve">
          <source>Kimono</source>
          <target state="translated">Kimono</target>
        </trans-unit>
        <trans-unit id="4dbc43957024c86f07374b147dcca5a43c62318b" translate="yes" xml:space="preserve">
          <source>Kiss</source>
          <target state="translated">Kiss</target>
        </trans-unit>
        <trans-unit id="23d1162dbd548a5b7ebb3cb6c2092223a1165283" translate="yes" xml:space="preserve">
          <source>Kiss Mark</source>
          <target state="translated">キスマーク</target>
        </trans-unit>
        <trans-unit id="bc19b3dfb9379c314c1b8e3bb9dc5e6a2b26f09b" translate="yes" xml:space="preserve">
          <source>Kissing Cat Face With Closed Eyes</source>
          <target state="translated">目を閉じたままキスをする猫の顔</target>
        </trans-unit>
        <trans-unit id="b58aa4e85bf24740360e2d6b347305a564dca4a1" translate="yes" xml:space="preserve">
          <source>Kissing Face</source>
          <target state="translated">キス顔</target>
        </trans-unit>
        <trans-unit id="2fe6ec1bfe77e7354379b52c0bee899a96c21add" translate="yes" xml:space="preserve">
          <source>Kissing Face With Closed Eyes</source>
          <target state="translated">目を閉じたままのキス顔</target>
        </trans-unit>
        <trans-unit id="fcaff6a193904e107dc7d4aa4f3190493c405457" translate="yes" xml:space="preserve">
          <source>Kissing Face With Smiling Eyes</source>
          <target state="translated">笑顔でキスをする顔</target>
        </trans-unit>
        <trans-unit id="74ae77190d30e9483b1024a2bf19d64715a77757" translate="yes" xml:space="preserve">
          <source>Koala</source>
          <target state="translated">Koala</target>
        </trans-unit>
        <trans-unit id="9afe7e71a0cd3f5b45d3038779f47e6ab11c4a9d" translate="yes" xml:space="preserve">
          <source>Konstantinos Konstantinides and Kung Yao, &quot;Statistical analysis of effective singular values in matrix rank determination&quot;, IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. &lt;a href=&quot;https://doi.org/10.1109/29.1585&quot;&gt;doi:10.1109/29.1585&lt;/a&gt;</source>
          <target state="translated">Konstantinos KonstantinidesおよびKung Yao、「行列ランクの決定における有効な特異値の統計分析」、IEEE Transactions on Acoustics、Speech and Signal Processing、36（5）、1988、757-763。&lt;a href=&quot;https://doi.org/10.1109/29.1585&quot;&gt;doi：10.1109 / 29.1585&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4a94c6e095d242bfd65b4080bf588284c946f8c" translate="yes" xml:space="preserve">
          <source>Kronecker tensor product of two vectors or two matrices.</source>
          <target state="translated">2つのベクトルまたは2つの行列のクロネッカーテンソル積。</target>
        </trans-unit>
        <trans-unit id="cf9e7dcbce935737e3132c8567095e62b32e357d" translate="yes" xml:space="preserve">
          <source>LAPACK</source>
          <target state="translated">LAPACK</target>
        </trans-unit>
        <trans-unit id="d4e9710203cf5806e211a4382bda892c104cc46d" translate="yes" xml:space="preserve">
          <source>LAPACK Functions</source>
          <target state="translated">ラパック機能</target>
        </trans-unit>
        <trans-unit id="b4aff6bdb4998cc3553c7001845a94833e9f4e43" translate="yes" xml:space="preserve">
          <source>LDLt (see &lt;a href=&quot;#LinearAlgebra.ldlt&quot;&gt;&lt;code&gt;ldlt&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">LDLt（参照&lt;a href=&quot;#LinearAlgebra.ldlt&quot;&gt; &lt;code&gt;ldlt&lt;/code&gt; を&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="26214decf703290192f10270d6b0b515c7511762" translate="yes" xml:space="preserve">
          <source>LLVM Interface</source>
          <target state="translated">LLVMインタフェース</target>
        </trans-unit>
        <trans-unit id="f5f4f14ed2c38473c6c2d9123249c93ff3ece227" translate="yes" xml:space="preserve">
          <source>LOAD_PATH</source>
          <target state="translated">LOAD_PATH</target>
        </trans-unit>
        <trans-unit id="160e7ef90659bedaf209eec44edbbe3caf988121" translate="yes" xml:space="preserve">
          <source>LU (see &lt;a href=&quot;#LinearAlgebra.lu&quot;&gt;&lt;code&gt;lu&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">LU（&lt;a href=&quot;#LinearAlgebra.lu&quot;&gt; &lt;code&gt;lu&lt;/code&gt; を&lt;/a&gt;参照）</target>
        </trans-unit>
        <trans-unit id="23dbe335a346e4f78af48a087f0c1292440d8cc7" translate="yes" xml:space="preserve">
          <source>LU factorization</source>
          <target state="translated">LU因数分解</target>
        </trans-unit>
        <trans-unit id="a905567226043f1b393e816a77aec998343c78b4" translate="yes" xml:space="preserve">
          <source>LU factorization for &lt;a href=&quot;#LinearAlgebra.Tridiagonal&quot;&gt;&lt;code&gt;Tridiagonal&lt;/code&gt;&lt;/a&gt; matrices</source>
          <target state="translated">&lt;a href=&quot;#LinearAlgebra.Tridiagonal&quot;&gt; &lt;code&gt;Tridiagonal&lt;/code&gt; &lt;/a&gt;行列のLU分解</target>
        </trans-unit>
        <trans-unit id="366152a7d098555665a4453404d639ac8b476b7a" translate="yes" xml:space="preserve">
          <source>Labels a statement with the symbolic label &lt;code&gt;name&lt;/code&gt;. The label marks the end-point of an unconditional jump with &lt;a href=&quot;#Base.@goto&quot;&gt;&lt;code&gt;@goto name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ステートメントに記号ラベル &lt;code&gt;name&lt;/code&gt; ます。ラベルは、無条件ジャンプの終了点を&lt;a href=&quot;#Base.@goto&quot;&gt; &lt;code&gt;@goto name&lt;/code&gt; &lt;/a&gt;でマークします。</target>
        </trans-unit>
        <trans-unit id="ff8f52e27fbdf435514705d351e8d01e3dd57b73" translate="yes" xml:space="preserve">
          <source>Lady Beetle</source>
          <target state="translated">レディビートル</target>
        </trans-unit>
        <trans-unit id="4dee08e75e78fb7f2ea26537626acf062390bc00" translate="yes" xml:space="preserve">
          <source>Large $\LaTeX$ equations that do not fit inline within a paragraph may be written as display equations using a fenced code block with the &quot;language&quot; &lt;code&gt;math&lt;/code&gt; as in the example below.</source>
          <target state="translated">段落内にインラインで収まらない大きな$ \ LaTeX $方程式は、以下の例のように「言語」 &lt;code&gt;math&lt;/code&gt; を使用したフェンス付きコードブロックを使用して、表示方程式として記述できます。</target>
        </trans-unit>
        <trans-unit id="8f95211a940e3d08b42c29bbf9dbc496ccfe208b" translate="yes" xml:space="preserve">
          <source>Large Blue Circle</source>
          <target state="translated">大きなブルーの円</target>
        </trans-unit>
        <trans-unit id="68e7dfd86e1bad5177b243cce59909605d2d63ff" translate="yes" xml:space="preserve">
          <source>Large Blue Diamond</source>
          <target state="translated">大粒のブルーダイヤモンド</target>
        </trans-unit>
        <trans-unit id="1489faea46cdb0a914888faa83aaccbf1a1018b6" translate="yes" xml:space="preserve">
          <source>Large Circle</source>
          <target state="translated">ラージサークル</target>
        </trans-unit>
        <trans-unit id="47d39efcf737a8cb7cff31b45c3eae3b9768a070" translate="yes" xml:space="preserve">
          <source>Large Down Tack</source>
          <target state="translated">ラージダウンタック</target>
        </trans-unit>
        <trans-unit id="19d1a6d4bde006ab21ff3b1a9ce0c5b1f656efbe" translate="yes" xml:space="preserve">
          <source>Large Orange Diamond</source>
          <target state="translated">ラージオレンジダイヤモンド</target>
        </trans-unit>
        <trans-unit id="2be06620aa858eeb1cfd65e452ba545d7194c263" translate="yes" xml:space="preserve">
          <source>Large Red Circle</source>
          <target state="translated">大赤丸</target>
        </trans-unit>
        <trans-unit id="93780c9bf758bfc5b064c94682265b362eac13d6" translate="yes" xml:space="preserve">
          <source>Large Up Tack</source>
          <target state="translated">ラージアップタック</target>
        </trans-unit>
        <trans-unit id="c567cf1fe685a9b85ba876a5fdec9645963ce55b" translate="yes" xml:space="preserve">
          <source>Large modules can take several seconds to load because executing all of the statements in a module often involves compiling a large amount of code. Julia creates precompiled caches of the module to reduce this time.</source>
          <target state="translated">大規模なモジュールは、モジュール内のすべてのステートメントを実行すると大量のコードをコンパイルする必要があるため、ロードに数秒かかることがあります。Julia はこの時間を短縮するためにモジュールのコンパイル済みキャッシュを作成します。</target>
        </trans-unit>
        <trans-unit id="836cd86751bc175f6a1c3513d9545f0269900a32" translate="yes" xml:space="preserve">
          <source>Larger Than</source>
          <target state="translated">より大きい</target>
        </trans-unit>
        <trans-unit id="8fc4e576fc574f75bb7c600973def67858d8bb40" translate="yes" xml:space="preserve">
          <source>Larger Than Or Equal To</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d737eee8172d65bba64271f9c8b335b8b815d284" translate="yes" xml:space="preserve">
          <source>Larger integer literals that cannot be represented using only 32 bits but can be represented in 64 bits always create 64-bit integers, regardless of the system type:</source>
          <target state="translated">32 ビットだけでは表現できないが 64 ビットで表現できる大きな整数リテラルは、システムの型に関係なく常に 64 ビットの整数を作成します。</target>
        </trans-unit>
        <trans-unit id="2c5201c8ea16b6383c4f6c269ee86f7c5d37bb84" translate="yes" xml:space="preserve">
          <source>Largest integer less than or equal to &lt;code&gt;x/y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x/y&lt;/code&gt; 以下の最大の整数。</target>
        </trans-unit>
        <trans-unit id="45e54723a9bf0cd3ba0bd2155ce7b7bac5bfafd9" translate="yes" xml:space="preserve">
          <source>Largest value</source>
          <target state="translated">最大値</target>
        </trans-unit>
        <trans-unit id="af72fbc94064a4c9a0a644731e497dc5dc7beff9" translate="yes" xml:space="preserve">
          <source>Last Quarter Moon</source>
          <target state="translated">ラストクォータームーン</target>
        </trans-unit>
        <trans-unit id="4d7f319a09451056e084d65cad158f125e2020cc" translate="yes" xml:space="preserve">
          <source>Last Quarter Moon Symbol</source>
          <target state="translated">ラストクォータームーンのシンボル</target>
        </trans-unit>
        <trans-unit id="a7b4069351f71ce4f08da44121a5414042cbca4b" translate="yes" xml:space="preserve">
          <source>Last Quarter Moon With Face</source>
          <target state="translated">顔のある最後の四半期の月</target>
        </trans-unit>
        <trans-unit id="18cf37d7758974150aba5efc169a132701c98591" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter A With Ring Above / Latin Capital Letter A Ring</source>
          <target state="translated">ラテン文字の大文字のAとリングの上に/ラテン文字の大文字のAリング</target>
        </trans-unit>
        <trans-unit id="387186c7a8fff866e6fbacb8a7a99c078e963118" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Ae / Latin Capital Letter A E</source>
          <target state="translated">ラテン語の大文字 Ae/ラテン語の大文字 A E</target>
        </trans-unit>
        <trans-unit id="f2c0864bdd70eeadaffc0e4bf8122d6178ff53bb" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter D With Stroke / Latin Capital Letter D Bar</source>
          <target state="translated">ラテン語の大文字Dとストローク/ラテン語の大文字Dバー</target>
        </trans-unit>
        <trans-unit id="18ee11f5dfc96b5ea1e522af1744aced409d9ff1" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Eng</source>
          <target state="translated">ラテンキャピタルレターエンゲージ</target>
        </trans-unit>
        <trans-unit id="7e38029cb2d0c6ce87bf45f5170886022a280556" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Eth</source>
          <target state="translated">ラテンキャピタルレター エチオピア</target>
        </trans-unit>
        <trans-unit id="261b92b2c69498043ebd035666aae447dd5fc40c" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter L With Stroke / Latin Capital Letter L Slash</source>
          <target state="translated">ラテン語の大文字Lとストローク/ラテン語の大文字Lスラッシュ</target>
        </trans-unit>
        <trans-unit id="81f5aedd8e8fccac1ab8a6bc67c43be5b7c7e7f6" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter O With Stroke / Latin Capital Letter O Slash</source>
          <target state="translated">ラテン文字の大文字のOとストローク/ラテン文字の大文字のOスラッシュ</target>
        </trans-unit>
        <trans-unit id="3e1d1bce5c9a11240957721f8ef29a635e048ab3" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Thorn</source>
          <target state="translated">ラテンキャピタルレターソーン</target>
        </trans-unit>
        <trans-unit id="4b4cf2ef98d43801be6875ab83c9e3c993eddbbb" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Z With Stroke / Latin Capital Letter Z Bar</source>
          <target state="translated">ラテン語の大文字Zとストローク/ラテン語の大文字Zバー</target>
        </trans-unit>
        <trans-unit id="5ae3e818634045d7a9130d2b676f3527521e0150" translate="yes" xml:space="preserve">
          <source>Latin Capital Ligature Oe / Latin Capital Letter O E</source>
          <target state="translated">ラテンキャピタル リガチャー Oe/ラテンキャピタル レター O E</target>
        </trans-unit>
        <trans-unit id="957520bb4ae3c78ec831bd317cdfd85081025ee6" translate="yes" xml:space="preserve">
          <source>Latin Letter Alveolar Click / Latin Letter Pipe Double Bar</source>
          <target state="translated">ラテン文字歯槽骨クリック/ラテン文字パイプダブルバー</target>
        </trans-unit>
        <trans-unit id="43073b60cf8171df59d1497357356aa7115c7db3" translate="yes" xml:space="preserve">
          <source>Latin Letter Glottal Stop</source>
          <target state="translated">ラテン文字グロタールストップ</target>
        </trans-unit>
        <trans-unit id="fc36244b6362ae3e3d6d20e2d335c02a7af88997" translate="yes" xml:space="preserve">
          <source>Latin Letter Inverted Glottal Stop</source>
          <target state="translated">ラテン文字反転グロタールストップ</target>
        </trans-unit>
        <trans-unit id="680f41038e731ff5fdc7bf24ce99313a70d99990" translate="yes" xml:space="preserve">
          <source>Latin Letter Pharyngeal Voiced Fricative / Latin Letter Reversed Glottal Stop</source>
          <target state="translated">ラテン文字の咽頭ヴォイスド・フリカティヴ/ラテン文字の逆口唇ストップ</target>
        </trans-unit>
        <trans-unit id="7e9e2bfa072cd28ac12f89b807c22a2d9b6b5f07" translate="yes" xml:space="preserve">
          <source>Latin Small Letter A With Ring Above / Latin Small Letter A Ring</source>
          <target state="translated">ラテン語の小さな文字Aの上にリングが付いている/ラテン語の小さな文字Aリング</target>
        </trans-unit>
        <trans-unit id="aeaa4f1f1687667c2f5fc22a10bca6a0268c7e52" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Ae / Latin Small Letter A E</source>
          <target state="translated">ラテン語のスモールレターAe/ラテン語のスモールレターA E</target>
        </trans-unit>
        <trans-unit id="bd81bee974151364620b17177c4955612e0e03fa" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Closed Omega</source>
          <target state="translated">ラテンスモールレター クローズドオメガ</target>
        </trans-unit>
        <trans-unit id="c4abfd40c74b3eb74040658788c6847cb7128777" translate="yes" xml:space="preserve">
          <source>Latin Small Letter D With Stroke / Latin Small Letter D Bar</source>
          <target state="translated">ラテン語のスモールレターDとストローク/ラテン語のスモールレターDバー</target>
        </trans-unit>
        <trans-unit id="79664c84e38ddc705c095d22df17f6ba110cb657" translate="yes" xml:space="preserve">
          <source>Latin Small Letter D With Tail / Latin Small Letter D Retroflex Hook</source>
          <target state="translated">ラテンスモールレターD テール付き/ラテンスモールレターD レトロフレックスフック</target>
        </trans-unit>
        <trans-unit id="0bae965510de34e4507ca1c9f6442e6f063065a8" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Dezh Digraph / Latin Small Letter D Yogh</source>
          <target state="translated">ラテン語の小文字Dezh Digraph/ラテン語の小文字D Yogh</target>
        </trans-unit>
        <trans-unit id="93c7ebd3f43b49c98f8c0737391432699e082aa6" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Dotless I</source>
          <target state="translated">ラテン語の小文字ドットレスI</target>
        </trans-unit>
        <trans-unit id="0639f709a04d29a7d92f491504f4b15becbc375e" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Dotless J</source>
          <target state="translated">ラテンスモールレタードットレスJ</target>
        </trans-unit>
        <trans-unit id="cf365327a81aadb5e405df4d0f48b32472c24b2e" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Eng</source>
          <target state="translated">ラテン語のスモールレターエンゲージ</target>
        </trans-unit>
        <trans-unit id="93c2ec38cecdf8e443b85db5de563a216ffd9d34" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Esh</source>
          <target state="translated">ラテン語の小文字エッシュ</target>
        </trans-unit>
        <trans-unit id="2e8a26241b482f37e00adb250b979246ca85beea" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Eth</source>
          <target state="translated">ラテン語の小さな文字 エチオピア語</target>
        </trans-unit>
        <trans-unit id="40104027bfc2f3a58be7509f94be97c17e39f2f9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Ezh / Latin Small Letter Yogh</source>
          <target state="translated">ラテン語の小文字Ezh/ラテン語の小文字Yogh</target>
        </trans-unit>
        <trans-unit id="f9e515806fd1b60b14e5fc8f3af7f90ac6e9364a" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Gamma</source>
          <target state="translated">ラテン語の小文字ガンマ</target>
        </trans-unit>
        <trans-unit id="97085caf81a24ef927fdc386fc6b04e27e1f72b9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter H With Stroke / Latin Small Letter H Bar</source>
          <target state="translated">ラテン語の小さな文字Hとストローク/ラテン語の小さな文字Hバー</target>
        </trans-unit>
        <trans-unit id="399d282443390fef914db664bba2883747b928af" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Hv / Latin Small Letter H V</source>
          <target state="translated">ラテン語のスモールレターHv/ラテン語のスモールレターH V</target>
        </trans-unit>
        <trans-unit id="2422e4f11c03b366715aa80ec860fc60eae0c461" translate="yes" xml:space="preserve">
          <source>Latin Small Letter L With Belt / Latin Small Letter L Belt</source>
          <target state="translated">ベルト付きラテンスモールレターL/ラテンスモールレターLベルト</target>
        </trans-unit>
        <trans-unit id="82d31c79255d3b522eb37fa11b7bb67ebf6d75a1" translate="yes" xml:space="preserve">
          <source>Latin Small Letter L With Retroflex Hook / Latin Small Letter L Retroflex Hook</source>
          <target state="translated">ラテンスモールレターL レトロフレックスフック付き/ラテンスモールレターL レトロフレックスフック</target>
        </trans-unit>
        <trans-unit id="432e37bd3e31540f66f1af3dfdcfd97516ca52f9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter L With Stroke / Latin Small Letter L Slash</source>
          <target state="translated">ラテン語のスモールレターLとストローク/ラテン語のスモールレターLスラッシュ</target>
        </trans-unit>
        <trans-unit id="c6dc1b09cb591ac95922c661ff9481278d4d2de7" translate="yes" xml:space="preserve">
          <source>Latin Small Letter M With Hook / Latin Small Letter M Hook</source>
          <target state="translated">ラテンスモールレターM フック付き/ラテンスモールレターM フック</target>
        </trans-unit>
        <trans-unit id="0218525707cb4bb564235a036cc2842ec67b0748" translate="yes" xml:space="preserve">
          <source>Latin Small Letter N With Left Hook / Latin Small Letter N Hook</source>
          <target state="translated">左フック付きラテンスモールレターN/ラテンスモールレターNフック</target>
        </trans-unit>
        <trans-unit id="b20690f24cf5bf99ca0c7018eee110ebe0e15a04" translate="yes" xml:space="preserve">
          <source>Latin Small Letter N With Long Right Leg</source>
          <target state="translated">ラテン語の小さな文字Nと長い右足</target>
        </trans-unit>
        <trans-unit id="31ec66aaa00a79d775f1c857d59f5c7a74247d09" translate="yes" xml:space="preserve">
          <source>Latin Small Letter N With Retroflex Hook / Latin Small Letter N Retroflex Hook</source>
          <target state="translated">ラテンスモールレターN ウィズ レトロフレックスフック/ラテンスモールレターN レトロフレックスフック</target>
        </trans-unit>
        <trans-unit id="7874ede875d3c7ae94e73df07ed062477861ae44" translate="yes" xml:space="preserve">
          <source>Latin Small Letter O With Stroke / Latin Small Letter O Slash</source>
          <target state="translated">ラテン語のスモールレターOとストローク/ラテン語のスモールレターOスラッシュ</target>
        </trans-unit>
        <trans-unit id="07add9523a52497c0c262c0382ad46de39eb16bd" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Open O</source>
          <target state="translated">ラテン語の小文字オープンオー</target>
        </trans-unit>
        <trans-unit id="1b7b0f5e96e58726dfbb7a30f8602204b9a71f82" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Phi</source>
          <target state="translated">ラテン語の小さな文字ファイ</target>
        </trans-unit>
        <trans-unit id="ff12afa374c372c8fc23589cff50c4ee6f2f6cde" translate="yes" xml:space="preserve">
          <source>Latin Small Letter R With Fishhook / Latin Small Letter Fishhook R</source>
          <target state="translated">フィッシュフック付きラテンスモールレターR/ラテンスモールレターフィッシュフックR</target>
        </trans-unit>
        <trans-unit id="591234998559d2fb9e34782769a6a85e552ca14a" translate="yes" xml:space="preserve">
          <source>Latin Small Letter R With Long Leg</source>
          <target state="translated">ラテン語の小さな文字Rと長い足</target>
        </trans-unit>
        <trans-unit id="c1a50f7f5584c407c2b721281ea3abe4e34d13d4" translate="yes" xml:space="preserve">
          <source>Latin Small Letter R With Tail / Latin Small Letter R Hook</source>
          <target state="translated">ラテンスモールレターR ウィズ テール/ラテンスモールレターRフック</target>
        </trans-unit>
        <trans-unit id="ef19cd34955161980d339367d254aafdd02b4cb7" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Rams Horn / Latin Small Letter Baby Gamma</source>
          <target state="translated">ラテンスモールレター ラムズホーン/ラテンスモールレター ベビーガンマ</target>
        </trans-unit>
        <trans-unit id="bf1d74257f1f62e2e52e3dc8b76fe85f6a2c3e96" translate="yes" xml:space="preserve">
          <source>Latin Small Letter S With Hook / Latin Small Letter S Hook</source>
          <target state="translated">ラテン語のスモールレターS フック付き/ラテン語のスモールレターS フック</target>
        </trans-unit>
        <trans-unit id="f17b9219c1288784e62e066762b90b3f1e0e55a8" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Schwa</source>
          <target state="translated">ラテン語のスモールレターシュワ</target>
        </trans-unit>
        <trans-unit id="19e904077d5fb0771a0c4bf22aebcb8d18879d02" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Sharp S</source>
          <target state="translated">ラテン語の小文字シャープS</target>
        </trans-unit>
        <trans-unit id="4e3c130c920943099dd727660677e4cfb89ea723" translate="yes" xml:space="preserve">
          <source>Latin Small Letter T With Retroflex Hook / Latin Small Letter T Retroflex Hook</source>
          <target state="translated">ラテンスモールレターT(レトロフレックスフック付き)/ラテンスモールレターTレトロフレックスフック</target>
        </trans-unit>
        <trans-unit id="b4aa5dce4f194d4f86cea8db7ef720a452c10472" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Tesh Digraph / Latin Small Letter T Esh</source>
          <target state="translated">ラテン語の小文字Teshディグラフ/ラテン語の小文字T Esh</target>
        </trans-unit>
        <trans-unit id="9a88a6a40f3264cff644fc36d6ea39b7e80dee4b" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Thorn</source>
          <target state="translated">ラテン語の小文字のとげ</target>
        </trans-unit>
        <trans-unit id="206fdfa3558c503d9e843533aa39ca8750c5100a" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned A</source>
          <target state="translated">ラテン語の小さな文字がAになった</target>
        </trans-unit>
        <trans-unit id="44391e675633f27178e360e38182fb1c89dcc786" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned Alpha / Latin Small Letter Turned Script A</source>
          <target state="translated">ラテン語の小文字がアルファになった/ラテン語の小文字がスクリプトAになった</target>
        </trans-unit>
        <trans-unit id="a45dfaa69d6b3db6daa54b07a19c0a16bc93f9c4" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned H</source>
          <target state="translated">ラテン語の小さな文字がHになった</target>
        </trans-unit>
        <trans-unit id="d0a8378f24aaa4a7fd08ad76eab02d85f9db34c3" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned K</source>
          <target state="translated">ラテン語の小字ターンK</target>
        </trans-unit>
        <trans-unit id="f60605b6d90f4154d38bac9031c2a73d3e7fb2fd" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned M</source>
          <target state="translated">ラテン系小文字ターンドM</target>
        </trans-unit>
        <trans-unit id="80870744996553dd1a355c5c68035612071c93d5" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned M With Long Leg</source>
          <target state="translated">ラテンの小さな手紙は長い足でMを回した</target>
        </trans-unit>
        <trans-unit id="4e330127b9bd74c3ac0ed39785e51192a2a6804b" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned R</source>
          <target state="translated">ラテン語の小さな文字がRになった</target>
        </trans-unit>
        <trans-unit id="7f2283c2045b7461f57d11ba1b67518361b943d3" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned R With Hook / Latin Small Letter Turned R Hook</source>
          <target state="translated">ラテン語の小さな手紙はフック付きのRを回した/ラテン語の小さな手紙はRフックを回した</target>
        </trans-unit>
        <trans-unit id="78ca75233c25b210f82d0fa683b1e829340273d9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned R With Long Leg</source>
          <target state="translated">ラテン語の小さな文字は、長い足でRを回した</target>
        </trans-unit>
        <trans-unit id="b693ad995bba90f1295c3eb3fa51e43c784b64eb" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned T</source>
          <target state="translated">ラテン語の小さな文字がT字になった</target>
        </trans-unit>
        <trans-unit id="5209a0d49366580ead3e1dad9d6ff2475775f51f" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned V</source>
          <target state="translated">ラテン語の小さな文字がV字になった</target>
        </trans-unit>
        <trans-unit id="450f985cc65d78122edf815571e08094f13be358" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned W</source>
          <target state="translated">ラテン語の小文字ターンドW</target>
        </trans-unit>
        <trans-unit id="d4b68356f1e5f3312b5bc8059eb8f75757a7c22d" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned Y</source>
          <target state="translated">ラテン語の小さな文字を回したY</target>
        </trans-unit>
        <trans-unit id="1c50afa8247e2b596bb5484c0bdf31af4356cb8d" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Upsilon</source>
          <target state="translated">ラテン語の小文字アップシロン</target>
        </trans-unit>
        <trans-unit id="cf80e9e2586cd62109287c1d07560fe914a80d16" translate="yes" xml:space="preserve">
          <source>Latin Small Letter V With Hook / Latin Small Letter Script V</source>
          <target state="translated">フック付きラテンスモールレターV/ラテンスモールレタースクリプトV</target>
        </trans-unit>
        <trans-unit id="6a5f81b7b582dc216e4c1f24b62d26cf5af68967" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Z With Retroflex Hook / Latin Small Letter Z Retroflex Hook</source>
          <target state="translated">ラテンスモールレターZ レトロフレックスフック付き/ラテンスモールレターZ レトロフレックスフック</target>
        </trans-unit>
        <trans-unit id="e2c17f6ce613463c3e30d1a4aed82bceb3d0bf26" translate="yes" xml:space="preserve">
          <source>Latin Small Ligature Oe / Latin Small Letter O E</source>
          <target state="translated">ラテンスモールリガチャーOe/ラテンスモールレターO E</target>
        </trans-unit>
        <trans-unit id="ab095c443113e11acf431c2bb30a86ce8ce57bb6" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter A</source>
          <target state="translated">ラテン語の下付き小文字A</target>
        </trans-unit>
        <trans-unit id="fff77fcf01dc719ec1ab77e81e213e93b8d0115a" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter E</source>
          <target state="translated">ラテン語の添え字小文字E</target>
        </trans-unit>
        <trans-unit id="363c386941760c298d65628800930f8354b1c700" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter H</source>
          <target state="translated">ラテン語の添え字小文字H</target>
        </trans-unit>
        <trans-unit id="982401be038720a241d1e68deecf4cf7746b55ab" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter I</source>
          <target state="translated">ラテン語の添え字小文字I</target>
        </trans-unit>
        <trans-unit id="f36b34411ebc69050abaa08db12014b29b018b19" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter J</source>
          <target state="translated">ラテン語の下付き小文字J</target>
        </trans-unit>
        <trans-unit id="5d9192cce944b6338e9e19cf0e5aff75bc6458e0" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter K</source>
          <target state="translated">ラテン語の添え字小文字K</target>
        </trans-unit>
        <trans-unit id="98e7def8db7a6c66ec697114dd36225f86e432d0" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter L</source>
          <target state="translated">ラテン語の下付き小文字L</target>
        </trans-unit>
        <trans-unit id="c88fe2a6e8d4931c9b29a2de9c39672213e2a09e" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter M</source>
          <target state="translated">ラテン語の添え字小文字M</target>
        </trans-unit>
        <trans-unit id="09020dd38fd21fc2f0e9c9b2f5cd4719b876181a" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter N</source>
          <target state="translated">ラテン語の添え字小文字N</target>
        </trans-unit>
        <trans-unit id="bf874a171794f22663d7decf77255804ee48a4b5" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter O</source>
          <target state="translated">ラテン語の添え字小文字O</target>
        </trans-unit>
        <trans-unit id="2f2d68aab8bef5631b7658f2f25cb157fe1312d8" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter P</source>
          <target state="translated">ラテン語の添え字小文字P</target>
        </trans-unit>
        <trans-unit id="6ae5998c63d2b847c715037212f1596e577e11d8" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter R</source>
          <target state="translated">ラテン語の下付き小文字R</target>
        </trans-unit>
        <trans-unit id="cbfb24f449387bbaf3bab5247af9c1ad7c5a2e87" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter S</source>
          <target state="translated">ラテン語の下付き小文字S</target>
        </trans-unit>
        <trans-unit id="54984068e00469db35d3a41626ebb9a634073396" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter Schwa</source>
          <target state="translated">ラテン語の下付き小字シュワ</target>
        </trans-unit>
        <trans-unit id="24e9ea8cb7bc17431bfd5069bebcda4cd2e0d7f4" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter T</source>
          <target state="translated">ラテン語の下付き小文字T</target>
        </trans-unit>
        <trans-unit id="c11091f07852038d224bf6a198262288070ac4af" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter U</source>
          <target state="translated">ラテン語の下付き小文字U</target>
        </trans-unit>
        <trans-unit id="59e0fc501529d38b3e42a1402845967ae6868b9c" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter V</source>
          <target state="translated">ラテン語の下付き小文字V</target>
        </trans-unit>
        <trans-unit id="87def54837d4f750a3ac2cc91c670222eecf573b" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter X</source>
          <target state="translated">ラテン語の下付き小文字X</target>
        </trans-unit>
        <trans-unit id="96f66def5d4a8c399dd4712422d81130f5b17cc9" translate="yes" xml:space="preserve">
          <source>Launches worker processes via the specified cluster manager.</source>
          <target state="translated">指定されたクラスタマネージャを介してワーカープロセスを起動します。</target>
        </trans-unit>
        <trans-unit id="230ffdc98fdacb0f873a14dccabfdda12422305b" translate="yes" xml:space="preserve">
          <source>Launches workers using the in-built &lt;code&gt;LocalManager&lt;/code&gt; which only launches workers on the local host. This can be used to take advantage of multiple cores. &lt;code&gt;addprocs(4)&lt;/code&gt; will add 4 processes on the local machine. If &lt;code&gt;restrict&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, binding is restricted to &lt;code&gt;127.0.0.1&lt;/code&gt;. Keyword args &lt;code&gt;dir&lt;/code&gt;, &lt;code&gt;exename&lt;/code&gt;, &lt;code&gt;exeflags&lt;/code&gt;, &lt;code&gt;topology&lt;/code&gt;, &lt;code&gt;lazy&lt;/code&gt; and &lt;code&gt;enable_threaded_blas&lt;/code&gt; have the same effect as documented for &lt;code&gt;addprocs(machines)&lt;/code&gt;.</source>
          <target state="translated">ローカルホストでのみワーカーを起動する組み込みの &lt;code&gt;LocalManager&lt;/code&gt; を使用してワーカーを起動します。これは、複数のコアを利用するために使用できます。 &lt;code&gt;addprocs(4)&lt;/code&gt; は、ローカルマシンに4つのプロセスを追加します。場合は &lt;code&gt;restrict&lt;/code&gt; され &lt;code&gt;true&lt;/code&gt; 、結合はに制限されている &lt;code&gt;127.0.0.1&lt;/code&gt; 。キーワードargs &lt;code&gt;dir&lt;/code&gt; 、 &lt;code&gt;exename&lt;/code&gt; 、 &lt;code&gt;exeflags&lt;/code&gt; 、 &lt;code&gt;topology&lt;/code&gt; 、 &lt;code&gt;lazy&lt;/code&gt; および &lt;code&gt;enable_threaded_blas&lt;/code&gt; は、 &lt;code&gt;addprocs(machines)&lt;/code&gt; で説明されているのと同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="5651fa0fd68350a3db0e0ce46acc644a6f99f032" translate="yes" xml:space="preserve">
          <source>Lazy adjoint (conjugate transposition) (also postfix &lt;code&gt;'&lt;/code&gt;). Note that &lt;code&gt;adjoint&lt;/code&gt; is applied recursively to elements.</source>
          <target state="translated">遅延随伴（共役転置）（後置 &lt;code&gt;'&lt;/code&gt; も）。 &lt;code&gt;adjoint&lt;/code&gt; は要素に再帰的に適用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4dabe105e2961d8642efb76e1ebd7539fca5122b" translate="yes" xml:space="preserve">
          <source>Lazy transpose. Mutating the returned object should appropriately mutate &lt;code&gt;A&lt;/code&gt;. Often, but not always, yields &lt;code&gt;Transpose(A)&lt;/code&gt;, where &lt;code&gt;Transpose&lt;/code&gt; is a lazy transpose wrapper. Note that this operation is recursive.</source>
          <target state="translated">遅延転置。返されたオブジェクトを変更すると、 &lt;code&gt;A&lt;/code&gt; が適切に変更されます。常にではありませんが、しばしば &lt;code&gt;Transpose(A)&lt;/code&gt; が生成されます。ここで、 &lt;code&gt;Transpose&lt;/code&gt; は遅延転置ラッパーです。この操作は再帰的であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="52790bab6c96ca4ca79f6c9dcbc5f04f90742a02" translate="yes" xml:space="preserve">
          <source>Lazy wrapper type for a transpose view of the underlying linear algebra object, usually an &lt;code&gt;AbstractVector&lt;/code&gt;/&lt;code&gt;AbstractMatrix&lt;/code&gt;, but also some &lt;code&gt;Factorization&lt;/code&gt;, for instance. Usually, the &lt;code&gt;Transpose&lt;/code&gt; constructor should not be called directly, use &lt;a href=&quot;#Base.transpose&quot;&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/a&gt; instead. To materialize the view use &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">基になる線形代数オブジェクトの転置ビューのレイジーラッパータイプ。通常は &lt;code&gt;AbstractVector&lt;/code&gt; / &lt;code&gt;AbstractMatrix&lt;/code&gt; ですが、たとえば、いくつかの &lt;code&gt;Factorization&lt;/code&gt; もあります。通常、 &lt;code&gt;Transpose&lt;/code&gt; コンストラクターを直接呼び出すことはできません。代わりに&lt;a href=&quot;#Base.transpose&quot;&gt; &lt;code&gt;transpose&lt;/code&gt; を&lt;/a&gt;使用してください。ビューを具体化するには、&lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="ea87c3f92c6c2a81bda14868b1fa3651e1788be6" translate="yes" xml:space="preserve">
          <source>Lazy wrapper type for an adjoint view of the underlying linear algebra object, usually an &lt;code&gt;AbstractVector&lt;/code&gt;/&lt;code&gt;AbstractMatrix&lt;/code&gt;, but also some &lt;code&gt;Factorization&lt;/code&gt;, for instance. Usually, the &lt;code&gt;Adjoint&lt;/code&gt; constructor should not be called directly, use &lt;a href=&quot;#Base.adjoint&quot;&gt;&lt;code&gt;adjoint&lt;/code&gt;&lt;/a&gt; instead. To materialize the view use &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">基になる線形代数オブジェクトの随伴ビューのレイジーラッパータイプ。通常は &lt;code&gt;AbstractVector&lt;/code&gt; / &lt;code&gt;AbstractMatrix&lt;/code&gt; ですが、たとえば、いくつかの &lt;code&gt;Factorization&lt;/code&gt; もあります。通常、 &lt;code&gt;Adjoint&lt;/code&gt; コンストラクタは直接呼び出さないでください。代わりに&lt;a href=&quot;#Base.adjoint&quot;&gt; &lt;code&gt;adjoint&lt;/code&gt; を&lt;/a&gt;使用してください。ビューを具体化するには、&lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="c31303ce475bc8493699e997a666b0db70d41d90" translate="yes" xml:space="preserve">
          <source>Leaf Fluttering In Wind</source>
          <target state="translated">風になびく葉っぱ</target>
        </trans-unit>
        <trans-unit id="22d214839b787ba0cbf83b35c8637e398eb00b60" translate="yes" xml:space="preserve">
          <source>Least common (non-negative) multiple.</source>
          <target state="translated">最小公倍数(非負)。</target>
        </trans-unit>
        <trans-unit id="1aa2f31ee7ccbdf2fc8c6c567cdca2fb29dac2a6" translate="yes" xml:space="preserve">
          <source>Ledger</source>
          <target state="translated">Ledger</target>
        </trans-unit>
        <trans-unit id="8ae1c34bd37fad49cc5f8e02da648a78e89c3ed8" translate="yes" xml:space="preserve">
          <source>Left</source>
          <target state="translated">Left</target>
        </trans-unit>
        <trans-unit id="75d0899e95136f2da4eac284be2b987384e5c533" translate="yes" xml:space="preserve">
          <source>Left Arrow With Circled Plus</source>
          <target state="translated">左矢印に加えて丸で囲んだ</target>
        </trans-unit>
        <trans-unit id="72aee17ac3f066d41059e365fe7ffff8c87f2b40" translate="yes" xml:space="preserve">
          <source>Left Arrow With Small Circle</source>
          <target state="translated">小さな円で左矢印</target>
        </trans-unit>
        <trans-unit id="e4186034491319e4fea56b94c110018858b681a3" translate="yes" xml:space="preserve">
          <source>Left Barb Down Right Barb Down Harpoon</source>
          <target state="translated">左バーブダウン 右バーブダウン ハープーン</target>
        </trans-unit>
        <trans-unit id="ae21e1eb75451dd870d85a61a1cfa6bc8df2ba78" translate="yes" xml:space="preserve">
          <source>Left Barb Down Right Barb Up Harpoon</source>
          <target state="translated">左バーブダウン 右バーブアップ ハープーン</target>
        </trans-unit>
        <trans-unit id="bcae4f39e04c712debc4107f48695498ba926272" translate="yes" xml:space="preserve">
          <source>Left Barb Up Right Barb Down Harpoon</source>
          <target state="translated">左バーブアップ 右バーブダウン ハープーン</target>
        </trans-unit>
        <trans-unit id="f15664f5c11100645f7ec0fc503d10e242c811c4" translate="yes" xml:space="preserve">
          <source>Left Barb Up Right Barb Up Harpoon</source>
          <target state="translated">左バーブアップ 右バーブアップ ハープーン</target>
        </trans-unit>
        <trans-unit id="a3c4bf704acbb06ce3404e8185007c7d40dd50dc" translate="yes" xml:space="preserve">
          <source>Left Ceiling</source>
          <target state="translated">左天井</target>
        </trans-unit>
        <trans-unit id="72a9f53c8c863fcc58b749c2d802910b9dd69204" translate="yes" xml:space="preserve">
          <source>Left Double Quotation Mark / Double Turned Comma Quotation Mark</source>
          <target state="translated">左二重引用符/二重反転コンマ引用符</target>
        </trans-unit>
        <trans-unit id="33ab45e60f973d03d477e320c9c21d10102209f2" translate="yes" xml:space="preserve">
          <source>Left Floor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acdcba05803275d77a8ff9d944d257c2f355cc32" translate="yes" xml:space="preserve">
          <source>Left Half Black Circle</source>
          <target state="translated">左半分黒丸</target>
        </trans-unit>
        <trans-unit id="98f2260c432833cdcda74a0d3fd1bcf7149895fd" translate="yes" xml:space="preserve">
          <source>Left Half Block</source>
          <target state="translated">左ハーフブロック</target>
        </trans-unit>
        <trans-unit id="b2d1cb4617e2395b9bcddfaba836b4ff2e6e68a3" translate="yes" xml:space="preserve">
          <source>Left Luggage</source>
          <target state="translated">左の荷物</target>
        </trans-unit>
        <trans-unit id="6fc8b4239d1345e60f61ab6561b7d80a0e196edc" translate="yes" xml:space="preserve">
          <source>Left Normal Factor Semidirect Product</source>
          <target state="translated">左法線因子半間接積</target>
        </trans-unit>
        <trans-unit id="a759ee17e030c9538e681ee56e56b5128b9fcd58" translate="yes" xml:space="preserve">
          <source>Left Outer Join</source>
          <target state="translated">左外結合</target>
        </trans-unit>
        <trans-unit id="bea5ba9ebfbff15c8175b8c30772408ad172251f" translate="yes" xml:space="preserve">
          <source>Left Right Arrow</source>
          <target state="translated">左右矢印</target>
        </trans-unit>
        <trans-unit id="92b57eec514e84ae8d71456c14f7cff82b10a548" translate="yes" xml:space="preserve">
          <source>Left Right Arrow Through Small Circle</source>
          <target state="translated">小さな円を通って左右矢印</target>
        </trans-unit>
        <trans-unit id="8f9b98c29f15c9b6eaf2eadce9578f5dc5b96041" translate="yes" xml:space="preserve">
          <source>Left Right Arrow With Double Vertical Stroke</source>
          <target state="translated">ダブル垂直ストロークの左右矢印</target>
        </trans-unit>
        <trans-unit id="09fe21e697a5fa104980be3384a847b808e4d81a" translate="yes" xml:space="preserve">
          <source>Left Right Arrow With Stroke</source>
          <target state="translated">ストローク付き左右矢印</target>
        </trans-unit>
        <trans-unit id="c3c516b47151666dadcf1dd0a1b3b7ab23f3f3ab" translate="yes" xml:space="preserve">
          <source>Left Right Arrow With Vertical Stroke</source>
          <target state="translated">垂直方向のストロークを持つ左右矢印</target>
        </trans-unit>
        <trans-unit id="4f5213e5966d1dc7812d67e6434bf47c9574b0b4" translate="yes" xml:space="preserve">
          <source>Left Right Double Arrow</source>
          <target state="translated">左右二重矢印</target>
        </trans-unit>
        <trans-unit id="83ed63f2653f9ec7aef827c095dc0fd80a9657f8" translate="yes" xml:space="preserve">
          <source>Left Right Double Arrow With Stroke</source>
          <target state="translated">ストローク付き左右二重矢印</target>
        </trans-unit>
        <trans-unit id="a2ff1377f747643672f8858987628f93747b7eb2" translate="yes" xml:space="preserve">
          <source>Left Right Double Arrow With Vertical Stroke</source>
          <target state="translated">垂直方向のストロークを持つ左右の二重矢印</target>
        </trans-unit>
        <trans-unit id="172365e73cff74845a1277eb1fb198684eed94bd" translate="yes" xml:space="preserve">
          <source>Left Right Open-Headed Arrow</source>
          <target state="translated">左 右 開頭矢印</target>
        </trans-unit>
        <trans-unit id="8055689a32aa93576b189b393a7f7e70b68fbc3d" translate="yes" xml:space="preserve">
          <source>Left Right Wave Arrow</source>
          <target state="translated">左右波矢印</target>
        </trans-unit>
        <trans-unit id="37d876c1c2c475cd47f27703a88e7f2f9166fd62" translate="yes" xml:space="preserve">
          <source>Left Semidirect Product</source>
          <target state="translated">左半間接製品</target>
        </trans-unit>
        <trans-unit id="62324b102cc4b4bf016fb9203c38bec07856133a" translate="yes" xml:space="preserve">
          <source>Left Single Quotation Mark / Single Turned Comma Quotation Mark</source>
          <target state="translated">左シングル引用符/シングルターンコンマ引用符</target>
        </trans-unit>
        <trans-unit id="19e4168df09f34516f6fddcc4e445fc021594bcb" translate="yes" xml:space="preserve">
          <source>Left Square Bracket Lower Corner</source>
          <target state="translated">左角ブラケット下コーナー</target>
        </trans-unit>
        <trans-unit id="ac1fd430a7759464f468517dfa51418639f0abf8" translate="yes" xml:space="preserve">
          <source>Left Tack</source>
          <target state="translated">左タック</target>
        </trans-unit>
        <trans-unit id="07241f21177a787dd3313c67746b03f50c2d9592" translate="yes" xml:space="preserve">
          <source>Left Triangle Beside Vertical Bar</source>
          <target state="translated">垂直バーの横にある左の三角形</target>
        </trans-unit>
        <trans-unit id="3b3a0479d1df49711a0b5dda01c8a9f250ee53e9" translate="yes" xml:space="preserve">
          <source>Left Triangle Beside Vertical Bar + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">垂直バーの横にある左の三角形+ロングソリダスオーバーレイ/ノンスペーシングロングスラッシュオーバーレイの組み合わせ</target>
        </trans-unit>
        <trans-unit id="24f6c1c79f67d997809b3110481aa58d9f740e6a" translate="yes" xml:space="preserve">
          <source>Left Vertical Box Line</source>
          <target state="translated">左の縦長のボックスライン</target>
        </trans-unit>
        <trans-unit id="e2e904284d118de6f14c002567a428193497055e" translate="yes" xml:space="preserve">
          <source>Left arrow, &lt;code&gt;^B&lt;/code&gt;</source>
          <target state="translated">左矢印、 &lt;code&gt;^B&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43c75bdc1fa38ddb43ed3abfdf3e4dda383f45ac" translate="yes" xml:space="preserve">
          <source>Left bit shift operator, &lt;code&gt;B &amp;lt;&amp;lt; n&lt;/code&gt;. For &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, the result is &lt;code&gt;B&lt;/code&gt; with elements shifted &lt;code&gt;n&lt;/code&gt; positions backwards, filling with &lt;code&gt;false&lt;/code&gt; values. If &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, elements are shifted forwards. Equivalent to &lt;code&gt;B &amp;gt;&amp;gt; -n&lt;/code&gt;.</source>
          <target state="translated">左ビットシフト演算子、 &lt;code&gt;B &amp;lt;&amp;lt; n&lt;/code&gt; 。以下のために &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; 、結果は &lt;code&gt;B&lt;/code&gt; の要素とがシフト &lt;code&gt;n&lt;/code&gt; の充填、後方位置を &lt;code&gt;false&lt;/code&gt; の値。 &lt;code&gt;n &amp;lt; 0&lt;/code&gt; 場合、要素は前方にシフトされます。同等の &lt;code&gt;B &amp;gt;&amp;gt; -n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="700db7c2e4663e2dc271d4c36173f17b6c63b025" translate="yes" xml:space="preserve">
          <source>Left bit shift operator, &lt;code&gt;x &amp;lt;&amp;lt; n&lt;/code&gt;. For &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, the result is &lt;code&gt;x&lt;/code&gt; shifted left by &lt;code&gt;n&lt;/code&gt; bits, filling with &lt;code&gt;0&lt;/code&gt;s. This is equivalent to &lt;code&gt;x * 2^n&lt;/code&gt;. For &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, this is equivalent to &lt;code&gt;x &amp;gt;&amp;gt; -n&lt;/code&gt;.</source>
          <target state="translated">左ビットシフト演算子、 &lt;code&gt;x &amp;lt;&amp;lt; n&lt;/code&gt; 。以下のために &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; 、結果は &lt;code&gt;x&lt;/code&gt; 左シフト &lt;code&gt;n&lt;/code&gt; の充填、ビット &lt;code&gt;0&lt;/code&gt; 秒。これは &lt;code&gt;x * 2^n&lt;/code&gt; と同等です。以下のため &lt;code&gt;n &amp;lt; 0&lt;/code&gt; 、これはと等価である &lt;code&gt;x &amp;gt;&amp;gt; -n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47e029a3c897df6f4c0de3d067011451de3151f3" translate="yes" xml:space="preserve">
          <source>Left division operator: multiplication of &lt;code&gt;y&lt;/code&gt; by the inverse of &lt;code&gt;x&lt;/code&gt; on the left. Gives floating-point results for integer arguments.</source>
          <target state="translated">左除算演算子：左側の &lt;code&gt;x&lt;/code&gt; の逆数による &lt;code&gt;y&lt;/code&gt; の乗算。整数の引数に対して浮動小数点の結果を返します。</target>
        </trans-unit>
        <trans-unit id="5ddde4aec1f53e97b5a1f34009e407e1cb187578" translate="yes" xml:space="preserve">
          <source>Left-Pointing Magnifying Glass</source>
          <target state="translated">左向き拡大鏡</target>
        </trans-unit>
        <trans-unit id="35088a4f27322015e328e0637be16cff0df478d9" translate="yes" xml:space="preserve">
          <source>Left-rotate matrix &lt;code&gt;A&lt;/code&gt; 90 degrees counterclockwise an integer &lt;code&gt;k&lt;/code&gt; number of times. If &lt;code&gt;k&lt;/code&gt; is a multiple of four (including zero), this is equivalent to a &lt;code&gt;copy&lt;/code&gt;.</source>
          <target state="translated">左回転行列 &lt;code&gt;A&lt;/code&gt; を反時計回りに90度整数 &lt;code&gt;k&lt;/code&gt; 回回転させます。場合 &lt;code&gt;k&lt;/code&gt; は（ゼロを含む）4の倍数であり、これは、と等価である &lt;code&gt;copy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af413d32c0aefe9e0a6c5345832116ac3819cfc9" translate="yes" xml:space="preserve">
          <source>Left&lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;</source>
          <target state="translated">Left&lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b0da9967a31e27b91c5f79f61cda48210161da5" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow / Left Arrow</source>
          <target state="translated">左矢印/左矢印</target>
        </trans-unit>
        <trans-unit id="bb62e777d053b849a3960927799605c68d6f5eca" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Above Almost Equal To</source>
          <target state="translated">左方向の矢印の上にほぼ等しく</target>
        </trans-unit>
        <trans-unit id="c453288b80fc56c56e06ba24b30f84f5dac9e172" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Above Reverse Almost Equal To</source>
          <target state="translated">左方向の矢印の上にリバースとほぼ同じ</target>
        </trans-unit>
        <trans-unit id="c80976998c602bbf7e0960e57864b997e7fa3170" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Above Reverse Tilde Operator</source>
          <target state="translated">左方向の矢印の上に逆ティルデ演算子</target>
        </trans-unit>
        <trans-unit id="b339bc529a24441191ee0d608b29a79c5db84b52" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow From Bar / Left Arrow From Bar</source>
          <target state="translated">バーからの左矢印/バーからの左矢印</target>
        </trans-unit>
        <trans-unit id="1e84d429549228a5c098aec3446031d7ead6505a" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow From Bar To Black Diamond</source>
          <target state="translated">バーからブラックダイヤモンドへの左向き矢印</target>
        </trans-unit>
        <trans-unit id="3b47b1dfc544dad6abdaf2ebcb4206c54487efc5" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Over Rightwards Arrow / Left Arrow Over Right Arrow</source>
          <target state="translated">右矢印の上に左矢印/右矢印の上に左矢印</target>
        </trans-unit>
        <trans-unit id="ae9989b5442d5772a5dadc97fcf089e63cd8bb1f" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Through X</source>
          <target state="translated">Xを通した左方向の矢印</target>
        </trans-unit>
        <trans-unit id="ae63102c5c00038eb021088d9b27a739caf11f6e" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow To Bar / Left Arrow To Bar</source>
          <target state="translated">バーへの左矢印/バーへの左矢印</target>
        </trans-unit>
        <trans-unit id="ba54e194d48c6e6846ca63e167eaa511daf10b83" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow To Bar Over Rightwards Arrow To Bar / Left Arrow To Bar Over Right Arrow To Bar</source>
          <target state="translated">バーへの右矢印バー/バーへの左矢印バーへの左矢印バーへの右矢印バーへの右矢印の上にバーへの左矢印</target>
        </trans-unit>
        <trans-unit id="352323837c59795cd0e83f313a7f1aad09357b67" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow To Black Diamond</source>
          <target state="translated">ブラックダイヤモンドへの左矢印</target>
        </trans-unit>
        <trans-unit id="0dbfe3aca18f61d6f1a6e05b8ae3c26d1725c775" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Dotted Stem</source>
          <target state="translated">点線の茎が付いている左向きの矢印</target>
        </trans-unit>
        <trans-unit id="b5f4b7ef2746d70757e6dc984fb3961f86960c29" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Double Vertical Stroke</source>
          <target state="translated">二重の垂直方向のストロークを持つ左向きの矢印</target>
        </trans-unit>
        <trans-unit id="42e353d97e79c0c1b091dc7d9378f532aaef3b3d" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Hook / Left Arrow With Hook</source>
          <target state="translated">フック付き左矢印/フック付き左矢印</target>
        </trans-unit>
        <trans-unit id="023d9a3502015dcd3b3f76fa14c946cbbc2d6f32" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Loop / Left Arrow With Loop</source>
          <target state="translated">ループが付いている左方向の矢印/ループが付いている左矢印</target>
        </trans-unit>
        <trans-unit id="9e22f7f96528d90c3397d6b157c1fdc2594ea742" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Plus Below</source>
          <target state="translated">プラスの下にある左方向の矢印</target>
        </trans-unit>
        <trans-unit id="cc480573c42bb17cb0e2940abfedd3c8ea38e8ea" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Stroke / Left Arrow With Stroke</source>
          <target state="translated">ストローク付き左矢印/ストローク付き左矢印</target>
        </trans-unit>
        <trans-unit id="52d1604edf7ef87df0bdda8c2b40df8871c49a60" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Tail / Left Arrow With Tail</source>
          <target state="translated">テール付き左矢印/テール付き左矢印</target>
        </trans-unit>
        <trans-unit id="88f9604cfadba8964cc29be77251abe676f9051a" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Tail With Double Vertical Stroke</source>
          <target state="translated">二重の垂直ストロークを持つ尾を持つ左向きの矢印</target>
        </trans-unit>
        <trans-unit id="390234b436d1a22d91a1f9368ac90420d25a50f9" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Tail With Vertical Stroke</source>
          <target state="translated">テールと垂直ストロークを持つ左向きの矢印</target>
        </trans-unit>
        <trans-unit id="11ebeb1eafd67ffeeffad131d7ac82c3b52085be" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Vertical Stroke</source>
          <target state="translated">垂直方向のストロークを持つ左方向の矢印</target>
        </trans-unit>
        <trans-unit id="c87c24a3eb1d8323b9fa96777c93ec260174835d" translate="yes" xml:space="preserve">
          <source>Leftwards Black Arrow</source>
          <target state="translated">左上のブラックアロー</target>
        </trans-unit>
        <trans-unit id="33cfca8919d0753ef59ada74348c2a4c4b3bf344" translate="yes" xml:space="preserve">
          <source>Leftwards Dashed Arrow / Left Dashed Arrow</source>
          <target state="translated">左方向破線矢印/左方向破線矢印</target>
        </trans-unit>
        <trans-unit id="8a19ba0a75d89ee68704a7ebb90ffd71f1e1b278" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow / Left Double Arrow</source>
          <target state="translated">左向きダブルアロー/左ダブルアロー</target>
        </trans-unit>
        <trans-unit id="60c9a06f1f5b3ab83b89088f525d893f40459a8e" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow From Bar</source>
          <target state="translated">バーから左方向に二重矢印</target>
        </trans-unit>
        <trans-unit id="0d8615420d5ad768b1f26184a0a7a40704148a7d" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow With Stroke / Left Double Arrow With Stroke</source>
          <target state="translated">ストロークとストローク/ストロークと左ダブルアローと左方向の二重矢印</target>
        </trans-unit>
        <trans-unit id="4f6b99ebd5ed363e088c4f88602ef903b8e06f64" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow With Vertical Stroke</source>
          <target state="translated">垂直方向のストロークを持つ左方向の二重矢印</target>
        </trans-unit>
        <trans-unit id="4f794063524482bcc21c38eae616ca798ede37a8" translate="yes" xml:space="preserve">
          <source>Leftwards Double Dash Arrow</source>
          <target state="translated">左向きダブルダッシュ矢印</target>
        </trans-unit>
        <trans-unit id="39e96a986704f562e46fbf1d03e4f9e54add9f77" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon Over Rightwards Harpoon / Left Harpoon Over Right Harpoon</source>
          <target state="translated">左寄せハープーンオーバー右寄せハープーン/左寄せハープーンオーバー右寄せハープーン</target>
        </trans-unit>
        <trans-unit id="690c48df2218ae792864eaf9456cf6955b424427" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down Above Rightwards Harpoon With Barb Down</source>
          <target state="translated">上の下のバーブを持つ左方向の銛 右方向の銛 下のバーブを持つ右方向の銛</target>
        </trans-unit>
        <trans-unit id="2a8c5adb9efda04b9d2fabf980287f590ba155e5" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down Below Long Dash</source>
          <target state="translated">ロングダッシュの下にバーブを下げた左回りの銛</target>
        </trans-unit>
        <trans-unit id="d60c5396df85f38cca433173bdcae8dd56a90b18" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down From Bar</source>
          <target state="translated">バーブをバーから下にした左向きのハープーン</target>
        </trans-unit>
        <trans-unit id="93c5200b6461e9ba3314eb9a0b244de1ac0949de" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down To Bar</source>
          <target state="translated">左向きハープーン ウィズ バーブ ダウン トゥ バー</target>
        </trans-unit>
        <trans-unit id="b6d93e8905d73cadcac079a3790b467b97f9e3ec" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Downwards / Left Harpoon With Barb Down</source>
          <target state="translated">Leftwards Harpoon With Barb Downwards/Left Harpoon With Barb Down Down</target>
        </trans-unit>
        <trans-unit id="662b3d2cbb862798f1987f0dd2c11e4c77a5182f" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up Above Leftwards Harpoon With Barb Down</source>
          <target state="translated">上のバーブを持つ左方向の銛 上のバーブを持つ左方向の銛 下のバーブを持つ左方向の銛</target>
        </trans-unit>
        <trans-unit id="b0567c46db77bd91abd63923235b4420e5bd82e5" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up Above Long Dash</source>
          <target state="translated">ロングダッシュの上にバーブを上げた左回りの銛</target>
        </trans-unit>
        <trans-unit id="0084ef3852a19447620ab7c0dfc2d2b12aeeb77d" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up Above Rightwards Harpoon With Barb Up</source>
          <target state="translated">左向きの銛とバーブを上にした右向きの銛とバーブを上にした右向きの銛</target>
        </trans-unit>
        <trans-unit id="730216336dfd2e32435830075fdb2df0dfaa397f" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up From Bar</source>
          <target state="translated">バーブからバーブアップした左向きハープーン</target>
        </trans-unit>
        <trans-unit id="4cbc38b13463300c356dd264e992f7457f26d5f3" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up To Bar</source>
          <target state="translated">左向きハープーン ウィズ バーブ アップ トゥ バー</target>
        </trans-unit>
        <trans-unit id="42c26ac6b35b0c13895bf055d9cecb545b0ec09a" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Upwards / Left Harpoon With Barb Up</source>
          <target state="translated">レフトワーズ ハープーン ウィズ バーブ アップワード/レフト ハープーン ウィズ バーブ アップワード</target>
        </trans-unit>
        <trans-unit id="5439409c437a7e20e57d117b3dc53bfc59be5b1e" translate="yes" xml:space="preserve">
          <source>Leftwards Open-Headed Arrow</source>
          <target state="translated">左開き矢印</target>
        </trans-unit>
        <trans-unit id="fb802d31c4d84700fe501788c56f0616bde89895" translate="yes" xml:space="preserve">
          <source>Leftwards Paired Arrows / Left Paired Arrows</source>
          <target state="translated">左向きペアリングアロー/左向きペアリングアロー</target>
        </trans-unit>
        <trans-unit id="1e30b6357af1b8210adc5e8500513f1780a44b86" translate="yes" xml:space="preserve">
          <source>Leftwards Quadruple Arrow</source>
          <target state="translated">左向き四重矢印</target>
        </trans-unit>
        <trans-unit id="e990b5a5a1b8966a349729643a9904c9a464f8f2" translate="yes" xml:space="preserve">
          <source>Leftwards Squiggle Arrow / Left Squiggle Arrow</source>
          <target state="translated">左向きスクイグルアロー/左スクイグルアロー</target>
        </trans-unit>
        <trans-unit id="40ef7c42edfad6e4a2b0c741f7a2e57b2d0a3d17" translate="yes" xml:space="preserve">
          <source>Leftwards Triple Arrow / Left Triple Arrow</source>
          <target state="translated">左向きトリプルアロー/左向きトリプルアロー</target>
        </trans-unit>
        <trans-unit id="e443b0f54a32ffe38d3c2940e3150615527deb02" translate="yes" xml:space="preserve">
          <source>Leftwards Triple Dash Arrow</source>
          <target state="translated">左上トリプルダッシュアロー</target>
        </trans-unit>
        <trans-unit id="0e6ace611eb46c42c60ebf869526d6d80107ee54" translate="yes" xml:space="preserve">
          <source>Leftwards Two Headed Arrow / Left Two Headed Arrow</source>
          <target state="translated">左向き二頭立て矢印/左向き二頭立て矢印</target>
        </trans-unit>
        <trans-unit id="73e956493780be5029f93be5ee242950d63a7b37" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow From Bar</source>
          <target state="translated">バーからの左方向の双頭の矢印</target>
        </trans-unit>
        <trans-unit id="c8fe728344df16251ef3411400150ba0b2c50044" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Double Vertical Stroke</source>
          <target state="translated">二重の垂直ストロークを持つ左方向の双頭の矢</target>
        </trans-unit>
        <trans-unit id="19a7c2f943c6a266d93318b4faccd25877a453bc" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Tail</source>
          <target state="translated">左方双頭矢</target>
        </trans-unit>
        <trans-unit id="fad45cb4bffed0212e02a7dd5b2b9636aeff862a" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Tail With Double Vertical Stroke</source>
          <target state="translated">二重の垂直ストロークを持つ尾を持つ左方の双頭の矢</target>
        </trans-unit>
        <trans-unit id="5354b323327ab9574144f2502eac42843f5fcc1b" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Tail With Vertical Stroke</source>
          <target state="translated">左方の垂直ストロークと尾を持つ両頭の矢</target>
        </trans-unit>
        <trans-unit id="be95b8e9e0c8c9337712cb0f314c9ab2a05f3613" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Vertical Stroke</source>
          <target state="translated">垂直方向のストロークを持つ左方向の双頭の矢</target>
        </trans-unit>
        <trans-unit id="43f10f58eb0471f466412a154b6c2de8a4b85793" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Triple Dash Arrow</source>
          <target state="translated">左方二頭身三連ダッシュアロー</target>
        </trans-unit>
        <trans-unit id="54be3ecc08f6dfc79a630a29d3be179ecc6e1de9" translate="yes" xml:space="preserve">
          <source>Leftwards Wave Arrow / Left Wave Arrow</source>
          <target state="translated">左方向のウェーブアロー/左方向のウェーブアロー</target>
        </trans-unit>
        <trans-unit id="a8988dc4aff78fbf3d6dec72ae6a15340f71c39b" translate="yes" xml:space="preserve">
          <source>Leftwards White Arrow / White Left Arrow</source>
          <target state="translated">左上がりの白矢印/左上がりの白矢印</target>
        </trans-unit>
        <trans-unit id="53789e63c0a26b06f6ee3389f57916b3259c1e85" translate="yes" xml:space="preserve">
          <source>Legend:</source>
          <target state="translated">Legend:</target>
        </trans-unit>
        <trans-unit id="4459b791a680572873dc2cf033487dc21edfcb9c" translate="yes" xml:space="preserve">
          <source>Lemon</source>
          <target state="translated">Lemon</target>
        </trans-unit>
        <trans-unit id="cfaf50ac3721461bd3a2d27ef5f35e144901fbb6" translate="yes" xml:space="preserve">
          <source>Leo</source>
          <target state="translated">Leo</target>
        </trans-unit>
        <trans-unit id="3ee924e59f48f89881e4cde275cb373a5ca3ccb1" translate="yes" xml:space="preserve">
          <source>Leopard</source>
          <target state="translated">Leopard</target>
        </trans-unit>
        <trans-unit id="2b515baec988fd996a77420ccdf808df339479aa" translate="yes" xml:space="preserve">
          <source>Less-Than Above Double-Line Equal Above Greater-Than</source>
          <target state="translated">二重線上の以下 同等の上 大きい以上</target>
        </trans-unit>
        <trans-unit id="5132ce6dbd42eef8696f2795c98fbde608c55ddc" translate="yes" xml:space="preserve">
          <source>Less-Than Above Greater-Than Above Double-Line Equal</source>
          <target state="translated">上記以下 大以上 ダブルライン イコール</target>
        </trans-unit>
        <trans-unit id="0996bf12be96a0c9cfd35d9c3d1cd4d7ae0dc489" translate="yes" xml:space="preserve">
          <source>Less-Than Above Similar Above Greater-Than</source>
          <target state="translated">以下 上記 似たようなもの 上記 大規模なもの</target>
        </trans-unit>
        <trans-unit id="f47dca757b69c3cbb5c4318a3148b185aa51ad59" translate="yes" xml:space="preserve">
          <source>Less-Than Above Similar Or Equal</source>
          <target state="translated">類似または同等以下</target>
        </trans-unit>
        <trans-unit id="d46f5f3bf1beaa31682309e60c70c4c4589a153d" translate="yes" xml:space="preserve">
          <source>Less-Than Above Slanted Equal Above Greater-Than Above Slanted Equal</source>
          <target state="translated">斜め上の等倍以下 斜め上の等倍以上 斜め上の等倍以上</target>
        </trans-unit>
        <trans-unit id="713b9a189c39738ac2705479504dc75c64634c14" translate="yes" xml:space="preserve">
          <source>Less-Than And Not Approximate</source>
          <target state="translated">以下であり、近似ではない</target>
        </trans-unit>
        <trans-unit id="2796bb948b259786fd87ad28f516271749c20d52" translate="yes" xml:space="preserve">
          <source>Less-Than And Single-Line Not Equal To</source>
          <target state="translated">以下と単線は同じではありません。</target>
        </trans-unit>
        <trans-unit id="709360d5eb9bea213909aadcf59a29aa892cbe75" translate="yes" xml:space="preserve">
          <source>Less-Than But Not Equal To / Less Than But Not Equal To</source>
          <target state="translated">未満であるが、同等ではない/未満であるが、同等ではない</target>
        </trans-unit>
        <trans-unit id="e453412818d96e7a4f420ee26bac5ea434246d68" translate="yes" xml:space="preserve">
          <source>Less-Than But Not Equal To / Less Than But Not Equal To + Variation Selector-1</source>
          <target state="translated">等しくないが等しい以下/等しくないが等しい以下+バリエーションセレクタ-1</target>
        </trans-unit>
        <trans-unit id="2f4b9cde7d599f1fdfcdcd2d149da1761281cf59" translate="yes" xml:space="preserve">
          <source>Less-Than But Not Equivalent To / Less Than But Not Equivalent To</source>
          <target state="translated">以下であるが同等ではない/以下であるが同等ではない</target>
        </trans-unit>
        <trans-unit id="d47b00bfbef46bd9077401979c412c7c9f4f06db" translate="yes" xml:space="preserve">
          <source>Less-Than Closed By Curve</source>
          <target state="translated">曲線で閉じる以下</target>
        </trans-unit>
        <trans-unit id="e9bc15ca0894be74c91d83dd7307ed3d4d198f47" translate="yes" xml:space="preserve">
          <source>Less-Than Closed By Curve Above Slanted Equal</source>
          <target state="translated">斜め上のカーブで閉じられた以下のもの 同等</target>
        </trans-unit>
        <trans-unit id="22c4db9e780b7f321b3a098f0b550b5d05360802" translate="yes" xml:space="preserve">
          <source>Less-Than Equal To Or Greater-Than / Less Than Equal To Or Greater Than</source>
          <target state="translated">等しくないまたは大きいより小さい/等しいまたは大きいより小さいより大きいより小さい</target>
        </trans-unit>
        <trans-unit id="125980c6753f24cfef91a7aee66e7177aefa9911" translate="yes" xml:space="preserve">
          <source>Less-Than Or Approximate</source>
          <target state="translated">以下または近似</target>
        </trans-unit>
        <trans-unit id="c6b5679738cc00d2db14ba6a2056c401ded59619" translate="yes" xml:space="preserve">
          <source>Less-Than Or Equal To / Less Than Or Equal To</source>
          <target state="translated">以下または同等以下/以下または同等以下</target>
        </trans-unit>
        <trans-unit id="35d27cfb30206b75fdeb27b601c10d1aad047c85" translate="yes" xml:space="preserve">
          <source>Less-Than Or Equivalent To / Less Than Or Equivalent To</source>
          <target state="translated">以下又は同等以下/以下又は同等以下</target>
        </trans-unit>
        <trans-unit id="b9b477ee81eb35999da4d54deb44ce4b860fe5f0" translate="yes" xml:space="preserve">
          <source>Less-Than Or Greater-Than / Less Than Or Greater Than</source>
          <target state="translated">以下の場合は、以下の場合は、以下の場合は、以下の場合は、以下の場合は、以下の場合は、以上の場合は</target>
        </trans-unit>
        <trans-unit id="cfd32ee1a60232f0de86d5e566782496b87faa45" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To</source>
          <target state="translated">以下または斜めに等しい</target>
        </trans-unit>
        <trans-unit id="c2210b5afd5a3271bd637771d340007b9651af50" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">長尺ソリッドスオーバーレイ/ノンスペーシング長尺スラッシュオーバーレイを組み合わせたものと同等以下または斜め</target>
        </trans-unit>
        <trans-unit id="a5250f1e7fd00d514cf7de98b151fff6e960ca41" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To With Dot Above</source>
          <target state="translated">上記のドットを持つことに等しい以下または傾斜</target>
        </trans-unit>
        <trans-unit id="08ee594bef0f1ebfc9a347365790474b8aa06aae" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To With Dot Above Right</source>
          <target state="translated">右上のドットを持つことに等しい以下または傾斜した</target>
        </trans-unit>
        <trans-unit id="6028a8d9f280a98196c48a63aa608f95a5002030" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To With Dot Inside</source>
          <target state="translated">ドットの内側にあるものと同等以下または傾斜したもの</target>
        </trans-unit>
        <trans-unit id="a654d5c89ef59a82d905f082b763c64619e9d053" translate="yes" xml:space="preserve">
          <source>Less-Than Over Equal To / Less Than Over Equal To</source>
          <target state="translated">等価以上/等価以上未満</target>
        </trans-unit>
        <trans-unit id="3cd5d177f863b189035a69ddc7dc355152c827d7" translate="yes" xml:space="preserve">
          <source>Less-Than With Circle Inside</source>
          <target state="translated">内側に円を入れた状態でのレスタン</target>
        </trans-unit>
        <trans-unit id="f5f82e2a0d06ff7d257c2989f80e7e63fdfcc406" translate="yes" xml:space="preserve">
          <source>Less-Than With Dot / Less Than With Dot</source>
          <target state="translated">ドット付き以下/ドット付き以下</target>
        </trans-unit>
        <trans-unit id="e8d2d29dc34fdea25f29dead5f22ec63a8a158fd" translate="yes" xml:space="preserve">
          <source>Less-Than With Question Mark Above</source>
          <target state="translated">上記の疑問符が付いている以下</target>
        </trans-unit>
        <trans-unit id="98215ce56f609905c57ffcaa9fd368bd9a664b9f" translate="yes" xml:space="preserve">
          <source>Less-than comparison operator. Falls back to &lt;a href=&quot;../base/index#Base.isless&quot;&gt;&lt;code&gt;isless&lt;/code&gt;&lt;/a&gt;. Because of the behavior of floating-point NaN values, this operator implements a partial order.</source>
          <target state="translated">小なり比較演算子。滝の裏&lt;a href=&quot;../base/index#Base.isless&quot;&gt; &lt;code&gt;isless&lt;/code&gt; &lt;/a&gt;。浮動小数点NaN値の動作のため、この演算子は半順序を実装します。</target>
        </trans-unit>
        <trans-unit id="6b17017e386fc2cfd407cedbcefdc1a56529ec61" translate="yes" xml:space="preserve">
          <source>Less-than-or-equals comparison operator. Falls back to &lt;code&gt;(x &amp;lt; y) | (x == y)&lt;/code&gt;.</source>
          <target state="translated">より小さいか等しい比較演算子。 &lt;code&gt;(x &amp;lt; y) | (x == y)&lt;/code&gt; 戻る| （x == y）。</target>
        </trans-unit>
        <trans-unit id="7223264dca9d07a87ce4ee4c3f4c203febf05b3c" translate="yes" xml:space="preserve">
          <source>Let Blocks</source>
          <target state="translated">ブロック</target>
        </trans-unit>
        <trans-unit id="7a4b5aa264a12a56a65beda1765bedfd0c0c5b4a" translate="yes" xml:space="preserve">
          <source>Let us explore the low level construct &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; to understand how task switching works. &lt;code&gt;yieldto(task,value)&lt;/code&gt; suspends the current task, switches to the specified &lt;code&gt;task&lt;/code&gt;, and causes that task's last &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; call to return the specified &lt;code&gt;value&lt;/code&gt;. Notice that &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; is the only operation required to use task-style control flow; instead of calling and returning we are always just switching to a different task. This is why this feature is also called &quot;symmetric coroutines&quot;; each task is switched to and from using the same mechanism.</source>
          <target state="translated">タスクの切り替えがどのように機能するかを理解するために、低レベルの構造体&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;を探索しましょう。 &lt;code&gt;yieldto(task,value)&lt;/code&gt; は、現在のタスクを中断し、指定された &lt;code&gt;task&lt;/code&gt; に切り替え、そのタスクの最後の&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;呼び出しで指定された &lt;code&gt;value&lt;/code&gt; を返します。タスク形式の制御フローを使用するために必要な操作は、&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;だけであることに注意してください。呼び出して戻るのではなく、常に別のタスクに切り替えるだけです。これが、この機能が「対称コルーチン」とも呼ばれる理由です。各タスクは、同じメカニズムを使用して切り替えられます。</target>
        </trans-unit>
        <trans-unit id="67246c5c8735d7e8441000a86e3cb7192688e453" translate="yes" xml:space="preserve">
          <source>Let us illustrate this principle with the logical &quot;or&quot; operator &lt;code&gt;|&lt;/code&gt;. Following the rules of boolean logic, if one of the operands is &lt;code&gt;true&lt;/code&gt;, the value of the other operand does not have an influence on the result, which will always be &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">この原理を論理的な「or」演算子で説明しましょう &lt;code&gt;|&lt;/code&gt; 。ブール論理の規則に従って、一方のオペランドが &lt;code&gt;true&lt;/code&gt; の場合、もう一方のオペランドの値は結果に影響を与えません。これは常に &lt;code&gt;true&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="5989117a8f456835a0f1be3863e508fbd507b1e1" translate="yes" xml:space="preserve">
          <source>Let us operate on this array simultaneously using 4 threads. We'll have each thread write its thread ID into each location.</source>
          <target state="translated">この配列を4つのスレッドを使って同時に操作してみましょう。各スレッドにはそれぞれの場所にスレッドIDを書き込ませます。</target>
        </trans-unit>
        <trans-unit id="6183c7c4afe71ef5b8231a90fffb2c5978fa45fa" translate="yes" xml:space="preserve">
          <source>Let's consider some of the abstract types that make up Julia's numerical hierarchy:</source>
          <target state="translated">ジュリアの数値階層を構成する抽象型のいくつかを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="01a2c551d7b29ee2d56fdf88a3feffacdd9828c3" translate="yes" xml:space="preserve">
          <source>Let's define a producer task, which produces values via the &lt;code&gt;put!&lt;/code&gt; call. To consume values, we need to schedule the producer to run in a new task. A special &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; constructor which accepts a 1-arg function as an argument can be used to run a task bound to a channel. We can then &lt;code&gt;take!&lt;/code&gt; values repeatedly from the channel object:</source>
          <target state="translated">&lt;code&gt;put!&lt;/code&gt; を介して値を生成するプロデューサータスクを定義しましょう。コール。値を消費するには、新しいタスクで実行するようにプロデューサーをスケジュールする必要があります。引数として1引数の関数を受け入れる特別な&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;コンストラクターを使用して、チャネルにバインドされたタスクを実行できます。その後、私たちは &lt;code&gt;take!&lt;/code&gt; ことができます！チャネルオブジェクトの値を繰り返し：</target>
        </trans-unit>
        <trans-unit id="9df15ca83d0947dbf1751a612bf2340b275f4ac4" translate="yes" xml:space="preserve">
          <source>Let's first discuss the two positional arguments, and later the keyword arguments:</source>
          <target state="translated">まず、2つの位置引数、そして後にキーワード引数について説明しましょう。</target>
        </trans-unit>
        <trans-unit id="6418114a78265d3efb7f605d5f750649435cf8a7" translate="yes" xml:space="preserve">
          <source>Let's jump right in with a simple example involving TCP sockets. This functionality is in a standard library package called &lt;code&gt;Sockets&lt;/code&gt;. Let's first create a simple server:</source>
          <target state="translated">TCPソケットに関する簡単な例を見てみましょう。この機能は、 &lt;code&gt;Sockets&lt;/code&gt; と呼ばれる標準ライブラリパッケージに含まれています。まず簡単なサーバーを作成しましょう：</target>
        </trans-unit>
        <trans-unit id="1122c34c203c69e459bc638ef4ea480a5b8130e2" translate="yes" xml:space="preserve">
          <source>Let's say you want to create an &lt;code&gt;N&lt;/code&gt;-dimensional array that has size 3 along each axis. Such arrays can be created like this:</source>
          <target state="translated">各軸に沿ってサイズ3の &lt;code&gt;N&lt;/code&gt; 次元配列を作成するとします。このような配列は次のように作成できます。</target>
        </trans-unit>
        <trans-unit id="8748cf620bf48795063bf239466aafbea94faee0" translate="yes" xml:space="preserve">
          <source>Let's set up a new environment so we may experiment. To set the active environment, use &lt;code&gt;activate&lt;/code&gt;:</source>
          <target state="translated">実験できるように、新しい環境をセットアップしましょう。アクティブな環境を設定するには、 &lt;code&gt;activate&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="71ba98ed632749544ae49e36ff83983c01e402b0" translate="yes" xml:space="preserve">
          <source>Let's take the following example: we implement a &lt;code&gt;Die&lt;/code&gt; type, with a variable number &lt;code&gt;n&lt;/code&gt; of sides, numbered from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;n&lt;/code&gt;. We want &lt;code&gt;rand(Die)&lt;/code&gt; to produce a die with a random number of up to 20 sides (and at least 4):</source>
          <target state="translated">次の例を見てみましょう &lt;code&gt;1&lt;/code&gt; から &lt;code&gt;n&lt;/code&gt; までの番号が付けられた、側面の数 &lt;code&gt;n&lt;/code&gt; が可変の &lt;code&gt;Die&lt;/code&gt; タイプを実装します。私たちは望ん &lt;code&gt;rand(Die)&lt;/code&gt; 20本の辺（少なくとも4）までの乱数を持つ金型を生産します：</target>
        </trans-unit>
        <trans-unit id="f3530d6febbeb3af1b1c75ff5864143019e5c7e9" translate="yes" xml:space="preserve">
          <source>Let's try it out. First we modify the file at &lt;code&gt;tutorial/dev/Example/src/Example.jl&lt;/code&gt; and add a simple function:</source>
          <target state="translated">試してみましょう。まず、 &lt;code&gt;tutorial/dev/Example/src/Example.jl&lt;/code&gt; にあるファイルを変更し、簡単な関数を追加します。</target>
        </trans-unit>
        <trans-unit id="d9f3d5d59e7aa3d7e910a3c03fcdc92c22584287" translate="yes" xml:space="preserve">
          <source>Let's try this out. Starting with &lt;code&gt;julia -p n&lt;/code&gt; provides &lt;code&gt;n&lt;/code&gt; worker processes on the local machine. Generally it makes sense for &lt;code&gt;n&lt;/code&gt; to equal the number of CPU threads (logical cores) on the machine. Note that the &lt;code&gt;-p&lt;/code&gt; argument implicitly loads module &lt;code&gt;Distributed&lt;/code&gt;.</source>
          <target state="translated">これを試してみましょう。 &lt;code&gt;julia -p n&lt;/code&gt; 始まると、ローカルマシンに &lt;code&gt;n&lt;/code&gt; 個のワーカープロセスが提供されます。一般に、 &lt;code&gt;n&lt;/code&gt; がマシン上のCPUスレッド（論理コア）の数と等しいことは理にかなっています。 &lt;code&gt;-p&lt;/code&gt; 引数は、モジュール &lt;code&gt;Distributed&lt;/code&gt; を暗黙的にロードすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b446a4746adc500fc9039decd4f98dd1f28494be" translate="yes" xml:space="preserve">
          <source>Let's verify there are 4 threads at our disposal.</source>
          <target state="translated">自由に4つのスレッドがあることを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="a857063978f61fa4bd1f41b325d1aa75b04e9d5e" translate="yes" xml:space="preserve">
          <source>Let's work a simple example using our native threads. Let us create an array of zeros:</source>
          <target state="translated">ネイティブスレッドを使って簡単な例を作ってみましょう。ゼロの配列を作ってみましょう。</target>
        </trans-unit>
        <trans-unit id="01ca76f755ba1afdf88a6b78abbe4839783a3a4d" translate="yes" xml:space="preserve">
          <source>Let's work with a simple test case:</source>
          <target state="translated">簡単なテストケースを使って作業してみましょう。</target>
        </trans-unit>
        <trans-unit id="ee8556898b2b9f9b2564fd6a9f4e2eeba1821894" translate="yes" xml:space="preserve">
          <source>LibGit2</source>
          <target state="translated">LibGit2</target>
        </trans-unit>
        <trans-unit id="76b53f15ef89ba2bfb2e2f62f34201129332b916" translate="yes" xml:space="preserve">
          <source>Libc</source>
          <target state="translated">Libc</target>
        </trans-unit>
        <trans-unit id="60368a5f4bc52be83598e88566f2089a47f21a35" translate="yes" xml:space="preserve">
          <source>Libc.FormatMessage()</source>
          <target state="translated">Libc.FormatMessage()</target>
        </trans-unit>
        <trans-unit id="41585a339c2503f89fb1f9aa92fdc8fb9adcdd4d" translate="yes" xml:space="preserve">
          <source>Libc.GetLastError()</source>
          <target state="translated">Libc.GetLastError()</target>
        </trans-unit>
        <trans-unit id="a85a19153d65e87480d301d0383428f7125ed99b" translate="yes" xml:space="preserve">
          <source>Libc.RawFD</source>
          <target state="translated">Libc.RawFD</target>
        </trans-unit>
        <trans-unit id="b9d6e139e984d53b5bcde695421e487faedd7c51" translate="yes" xml:space="preserve">
          <source>Libc.TmStruct</source>
          <target state="translated">Libc.TmStruct</target>
        </trans-unit>
        <trans-unit id="bc871e61e3ca821c6cfe4accdd2d8e0693a588e4" translate="yes" xml:space="preserve">
          <source>Libc.calloc()</source>
          <target state="translated">Libc.calloc()</target>
        </trans-unit>
        <trans-unit id="1f4d269c85f0cdd9201cbed97992b84adebdf595" translate="yes" xml:space="preserve">
          <source>Libc.errno()</source>
          <target state="translated">Libc.errno()</target>
        </trans-unit>
        <trans-unit id="0848e3c16acc14bb2ec577b598d650c18e77b315" translate="yes" xml:space="preserve">
          <source>Libc.flush_cstdio()</source>
          <target state="translated">Libc.flush_cstdio()</target>
        </trans-unit>
        <trans-unit id="3ce556c3b59d7aa2c3af19ecb0b6877f650470df" translate="yes" xml:space="preserve">
          <source>Libc.free()</source>
          <target state="translated">Libc.free()</target>
        </trans-unit>
        <trans-unit id="b0704af4d5eaf445364159bc7d46c36ac0dd99b9" translate="yes" xml:space="preserve">
          <source>Libc.gethostname()</source>
          <target state="translated">Libc.gethostname()</target>
        </trans-unit>
        <trans-unit id="34f021f7afa28bfc40d0c964b655d57537eeeb56" translate="yes" xml:space="preserve">
          <source>Libc.getpid()</source>
          <target state="translated">Libc.getpid()</target>
        </trans-unit>
        <trans-unit id="b3ae4ddcce36b5e6214d98b8603cc79d72f7795f" translate="yes" xml:space="preserve">
          <source>Libc.malloc()</source>
          <target state="translated">Libc.malloc()</target>
        </trans-unit>
        <trans-unit id="755d16743ca50b746f3e9f832dc2d5638fe7b1d4" translate="yes" xml:space="preserve">
          <source>Libc.realloc()</source>
          <target state="translated">Libc.realloc()</target>
        </trans-unit>
        <trans-unit id="189c473490df982a84b81ce12725d8d1b054705a" translate="yes" xml:space="preserve">
          <source>Libc.strerror()</source>
          <target state="translated">Libc.strerror()</target>
        </trans-unit>
        <trans-unit id="9c2a2e1ec6af2d38549c677ba7248e856a349879" translate="yes" xml:space="preserve">
          <source>Libc.strftime()</source>
          <target state="translated">Libc.strftime()</target>
        </trans-unit>
        <trans-unit id="291439a5e7bded77e555ba7822b85155ea0e9ab9" translate="yes" xml:space="preserve">
          <source>Libc.strptime()</source>
          <target state="translated">Libc.strptime()</target>
        </trans-unit>
        <trans-unit id="50e854ed1dcc836eb5e225047ee11442a2f80cd3" translate="yes" xml:space="preserve">
          <source>Libc.systemsleep()</source>
          <target state="translated">Libc.systemsleep()</target>
        </trans-unit>
        <trans-unit id="81d6424efbc87c9c17b0813b0c148152bd3c2475" translate="yes" xml:space="preserve">
          <source>Libc.time()</source>
          <target state="translated">Libc.time()</target>
        </trans-unit>
        <trans-unit id="f9ac7f64b772b55f84e761baea56c702c55005b2" translate="yes" xml:space="preserve">
          <source>Libdl.RTLD_NOW</source>
          <target state="translated">Libdl.RTLD_NOW</target>
        </trans-unit>
        <trans-unit id="754e38c44e40a9e9cb516d0f693c9b5afa0d7ec7" translate="yes" xml:space="preserve">
          <source>Libdl.dlclose()</source>
          <target state="translated">Libdl.dlclose()</target>
        </trans-unit>
        <trans-unit id="b20c01d11dde97a5fa90df2ec685adbcf15207ab" translate="yes" xml:space="preserve">
          <source>Libdl.dlext</source>
          <target state="translated">Libdl.dlext</target>
        </trans-unit>
        <trans-unit id="bbe848e2a374e3e28b9be1468210bde354760df9" translate="yes" xml:space="preserve">
          <source>Libdl.dlopen()</source>
          <target state="translated">Libdl.dlopen()</target>
        </trans-unit>
        <trans-unit id="bc44712bf06d7cde2930672cea24ac5283dc04d2" translate="yes" xml:space="preserve">
          <source>Libdl.dlopen_e()</source>
          <target state="translated">Libdl.dlopen_e()</target>
        </trans-unit>
        <trans-unit id="f76c025cd327748a8ae48ab21c1d0d6937ee6cf3" translate="yes" xml:space="preserve">
          <source>Libdl.dlsym()</source>
          <target state="translated">Libdl.dlsym()</target>
        </trans-unit>
        <trans-unit id="ddc83875e28b579f9ad7f02bee458a0c03e115cf" translate="yes" xml:space="preserve">
          <source>Libdl.dlsym_e()</source>
          <target state="translated">Libdl.dlsym_e()</target>
        </trans-unit>
        <trans-unit id="e5858af9f095388c617c420aefd6c16e0594c3bf" translate="yes" xml:space="preserve">
          <source>Libdl.find_library()</source>
          <target state="translated">Libdl.find_library()</target>
        </trans-unit>
        <trans-unit id="cb8e2b307865af7fc3116bd1827bf102132b7b87" translate="yes" xml:space="preserve">
          <source>Libra</source>
          <target state="translated">Libra</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MITライセンスに基づいてライセンスされています。</target>
        </trans-unit>
        <trans-unit id="8a1bb5e870bb9b77202596bab439b6db423dbba2" translate="yes" xml:space="preserve">
          <source>Light Rail</source>
          <target state="translated">ライトレール</target>
        </trans-unit>
        <trans-unit id="4944819e2ca85d61a3c9e24619e3eb246b5a52a9" translate="yes" xml:space="preserve">
          <source>Light Shade</source>
          <target state="translated">ライトシェード</target>
        </trans-unit>
        <trans-unit id="9921ca32d9a43716da2c222cd03f37ec5fd109a5" translate="yes" xml:space="preserve">
          <source>Lightweight &quot;green&quot; threading (&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;coroutines&lt;/a&gt;)</source>
          <target state="translated">軽量の「グリーン」スレッディング（&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;コルーチン&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="8a26ac5926eeae89368f7fb44a40e4b026751c42" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt;, but store the result of &lt;code&gt;broadcast(f, As...)&lt;/code&gt; in the &lt;code&gt;dest&lt;/code&gt; array. Note that &lt;code&gt;dest&lt;/code&gt; is only used to store the result, and does not supply arguments to &lt;code&gt;f&lt;/code&gt; unless it is also listed in the &lt;code&gt;As&lt;/code&gt;, as in &lt;code&gt;broadcast!(f, A, A, B)&lt;/code&gt; to perform &lt;code&gt;A[:] = broadcast(f, A, B)&lt;/code&gt;.</source>
          <target state="translated">以下のような&lt;a href=&quot;#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt;が、結果格納 &lt;code&gt;broadcast(f, As...)&lt;/code&gt; に &lt;code&gt;dest&lt;/code&gt; 配列。そのノート &lt;code&gt;dest&lt;/code&gt; が結果だけを格納するために使用され、且つに引数を供給しない &lt;code&gt;f&lt;/code&gt; それはまたにリストされていない限り &lt;code&gt;As&lt;/code&gt; のように、 &lt;code&gt;broadcast!(f, A, A, B)&lt;/code&gt; 実行する &lt;code&gt;A[:] = broadcast(f, A, B)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1bc834338e49af8951a520f98a93394195b34a0" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt;&lt;code&gt;uperm&lt;/code&gt;&lt;/a&gt; but gets the permissions for people who neither own the file nor are a member of the group owning the file</source>
          <target state="translated">同様&lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt; &lt;code&gt;uperm&lt;/code&gt; &lt;/a&gt;が、どちらもファイルを所有することも、ファイルを所有するグループのメンバーである人々のための権限を取得します</target>
        </trans-unit>
        <trans-unit id="52da4e2a0d663a1dbba38c505be636c82ff3a124" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt;&lt;code&gt;uperm&lt;/code&gt;&lt;/a&gt; but gets the permissions of the group owning the file.</source>
          <target state="translated">同様&lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt; &lt;code&gt;uperm&lt;/code&gt; &lt;/a&gt;が、ファイルを所有するグループのアクセス権を取得します。</target>
        </trans-unit>
        <trans-unit id="55b69ac4b886c93cd981119d2156a08505ea6f20" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Sort.partialsortperm&quot;&gt;&lt;code&gt;partialsortperm&lt;/code&gt;&lt;/a&gt;, but accepts a preallocated index vector &lt;code&gt;ix&lt;/code&gt;. If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), &lt;code&gt;ix&lt;/code&gt; is initialized to contain the values &lt;code&gt;1:length(ix)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.Sort.partialsortperm&quot;&gt; &lt;code&gt;partialsortperm&lt;/code&gt; &lt;/a&gt;に似ていますが、事前に割り当てられたインデックスベクトル &lt;code&gt;ix&lt;/code&gt; を受け入れます。場合は &lt;code&gt;initialized&lt;/code&gt; ある &lt;code&gt;false&lt;/code&gt; （デフォルト）、 &lt;code&gt;ix&lt;/code&gt; 値格納するように初期化された &lt;code&gt;1:length(ix)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="529e4e84127591bc458006a7c31028da87258a93" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.asyncmap&quot;&gt;&lt;code&gt;asyncmap&lt;/code&gt;&lt;/a&gt;, but stores output in &lt;code&gt;results&lt;/code&gt; rather than returning a collection.</source>
          <target state="translated">同様&lt;a href=&quot;#Base.asyncmap&quot;&gt; &lt;code&gt;asyncmap&lt;/code&gt; &lt;/a&gt;ではなく、店舗の出力 &lt;code&gt;results&lt;/code&gt; ではなく、コレクションを返します。</target>
        </trans-unit>
        <trans-unit id="06d62bd10c05ce2bf6e378f3ac0cebfd0dc1f43e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;, except reads code from the given string rather than from a file.</source>
          <target state="translated">&lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt;と同様ですが、ファイルからではなく、指定された文字列からコードを読み取ります。</target>
        </trans-unit>
        <trans-unit id="33fc1f575b86086215aa1689af4abbedb592d014" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, but stores the result in &lt;code&gt;destination&lt;/code&gt; rather than a new collection. &lt;code&gt;destination&lt;/code&gt; must be at least as large as the first collection.</source>
          <target state="translated">&lt;a href=&quot;#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;に似ていますが、結果を新しいコレクションではなく &lt;code&gt;destination&lt;/code&gt; 保存します。 &lt;code&gt;destination&lt;/code&gt; は、少なくとも最初のコレクションと同じ大きさでなければなりません。</target>
        </trans-unit>
        <trans-unit id="9053e0f6dd39d888ac2c2e819878de129f87dfec" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapreduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed left associativity, as in &lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldl&lt;/code&gt;&lt;/a&gt;. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">同様&lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapreduce&lt;/code&gt; &lt;/a&gt;、しかし、のように保証する左結合性、と&lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldl&lt;/code&gt; の&lt;/a&gt;。指定すると、キーワード引数 &lt;code&gt;init&lt;/code&gt; が1回だけ使用されます。一般に、空のコレクションを処理するには &lt;code&gt;init&lt;/code&gt; を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="ffe977f18117519aca83d726747101ffed876b72" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapreduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed right associativity, as in &lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldr&lt;/code&gt;&lt;/a&gt;. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">&lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapreduce&lt;/code&gt; &lt;/a&gt;と似ていますが、&lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldr&lt;/code&gt; の&lt;/a&gt;ように正しい結合性が保証されています。指定すると、キーワード引数 &lt;code&gt;init&lt;/code&gt; が1回だけ使用されます。一般に、空のコレクションを処理するには &lt;code&gt;init&lt;/code&gt; を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="9d8eaa8363c2e7fc8a90587868e4968a125caadc" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt;, but returns either a value of the requested type, or &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; if the string does not contain a valid number.</source>
          <target state="translated">&lt;a href=&quot;#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;に似ていますが、リクエストされたタイプの値を返すか、文字列に有効な数値が含まれていない場合は&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;返しません。</target>
        </trans-unit>
        <trans-unit id="51eaec3c8abd237c8d9e9bba6cf07e3a4cb08010" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.permute!-Tuple%7BAny,AbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt;&lt;code&gt;permute!&lt;/code&gt;&lt;/a&gt;, but the inverse of the given permutation is applied.</source>
          <target state="translated">以下のように&lt;a href=&quot;#Base.permute!-Tuple%7BAny,AbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt; &lt;code&gt;permute!&lt;/code&gt; &lt;/a&gt;、ただし指定された順列の逆が適用されます。</target>
        </trans-unit>
        <trans-unit id="4756a006313f096261885c0ef2037e8fe0a50c17" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.redirect_stdout&quot;&gt;&lt;code&gt;redirect_stdout&lt;/code&gt;&lt;/a&gt;, but for &lt;a href=&quot;#Base.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.redirect_stdout&quot;&gt; &lt;code&gt;redirect_stdout&lt;/code&gt; &lt;/a&gt;に似ていますが、&lt;a href=&quot;#Base.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f085d340882a97bb66329f21bdf7b61cf3ba9878" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.redirect_stdout&quot;&gt;&lt;code&gt;redirect_stdout&lt;/code&gt;&lt;/a&gt;, but for &lt;a href=&quot;#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;. Note that the order of the return tuple is still &lt;code&gt;(rd, wr)&lt;/code&gt;, i.e. data to be read from &lt;a href=&quot;#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; may be written to &lt;code&gt;wr&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.redirect_stdout&quot;&gt; &lt;code&gt;redirect_stdout&lt;/code&gt; &lt;/a&gt;に似ていますが、&lt;a href=&quot;#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;です。戻りタプルの順序はまだ &lt;code&gt;(rd, wr)&lt;/code&gt; であることに注意してください。つまり、&lt;a href=&quot;#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;から読み取るデータは &lt;code&gt;wr&lt;/code&gt; に書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="5f5dd7f815a4d7bf1a89e4740bb5b8ac9a464da9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed left associativity. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">&lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;と同様ですが、左結合性が保証されています。指定すると、キーワード引数 &lt;code&gt;init&lt;/code&gt; が1回だけ使用されます。一般に、空のコレクションを処理するには &lt;code&gt;init&lt;/code&gt; を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="024595a61bd923552b757965d3ba72515fa95986" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed right associativity. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">&lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;と同様ですが、正しい結合性が保証されています。指定すると、キーワード引数 &lt;code&gt;init&lt;/code&gt; が1回だけ使用されます。一般に、空のコレクションを処理するには &lt;code&gt;init&lt;/code&gt; を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="1ef0876ab486f437b72ce65e44751d3b6dbccac7" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.sortperm&quot;&gt;&lt;code&gt;sortperm&lt;/code&gt;&lt;/a&gt;, but accepts a preallocated index vector &lt;code&gt;ix&lt;/code&gt;. If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), &lt;code&gt;ix&lt;/code&gt; is initialized to contain the values &lt;code&gt;1:length(v)&lt;/code&gt;.</source>
          <target state="translated">同様&lt;a href=&quot;#Base.sortperm&quot;&gt; &lt;code&gt;sortperm&lt;/code&gt; &lt;/a&gt;が、事前に割り当てられたインデックスベクトル受け入れ &lt;code&gt;ix&lt;/code&gt; 。場合は &lt;code&gt;initialized&lt;/code&gt; ある &lt;code&gt;false&lt;/code&gt; （デフォルト）、 &lt;code&gt;ix&lt;/code&gt; 値格納するように初期化された &lt;code&gt;1:length(v)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08026f6d5cc67e6a499233d241ca672fd865f4fa" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt;, but for symbolic links gets the info for the link itself rather than the file it refers to. This function must be called on a file path rather than a file object or a file descriptor.</source>
          <target state="translated">&lt;a href=&quot;#Base.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;に似ていますが、シンボリックリンクの場合、参照するファイルではなく、リンク自体の情報を取得します。この関数は、ファイルオブジェクトやファイル記述子ではなく、ファイルパスで呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="b3086501e29c75ea565e72a0019576b980b02fe5" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Random.randsubseq&quot;&gt;&lt;code&gt;randsubseq&lt;/code&gt;&lt;/a&gt;, but the results are stored in &lt;code&gt;S&lt;/code&gt; (which is resized as needed).</source>
          <target state="translated">&lt;a href=&quot;#Random.randsubseq&quot;&gt; &lt;code&gt;randsubseq&lt;/code&gt; &lt;/a&gt;と同様ですが、結果は &lt;code&gt;S&lt;/code&gt; に格納されます（Sは必要に応じてサイズ変更されます）。</target>
        </trans-unit>
        <trans-unit id="eb969f16d7c8b092d782534c60f5aa57438f02b4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Statistics.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;, but may overwrite the input vector.</source>
          <target state="translated">&lt;a href=&quot;#Statistics.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt;に似ていますが、入力ベクトルを上書きする可能性があります。</target>
        </trans-unit>
        <trans-unit id="c740cd8f4daa963edb800319e0b46fdd4c9b8a9e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, but returns a view into the parent array &lt;code&gt;A&lt;/code&gt; with the given indices instead of making a copy. Calling &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; on the returned &lt;code&gt;SubArray&lt;/code&gt; computes the indices to the parent array on the fly without checking bounds.</source>
          <target state="translated">&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;と同様ですが、コピーを作成する代わりに、指定されたインデックスを持つ親配列 &lt;code&gt;A&lt;/code&gt; にビューを返します。&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;またはsetindexを呼び出す&lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;返された &lt;code&gt;SubArray&lt;/code&gt; では、境界をチェックせずに、その場で親配列のインデックスを計算します。</target>
        </trans-unit>
        <trans-unit id="a4ecbe47eb2e0c87296b762b01d3e9398f50b6c5" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, but returns a view into the parent string &lt;code&gt;s&lt;/code&gt; within range &lt;code&gt;i:j&lt;/code&gt; or &lt;code&gt;r&lt;/code&gt; respectively instead of making a copy.</source>
          <target state="translated">&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;と同様ですが、コピーを作成する代わりに、範囲 &lt;code&gt;i:j&lt;/code&gt; または &lt;code&gt;r&lt;/code&gt; 内の親文字列 &lt;code&gt;s&lt;/code&gt; にそれぞれビューを返します。</target>
        </trans-unit>
        <trans-unit id="807404638eb67f1a49cc813e53a998bea5df9d33" translate="yes" xml:space="preserve">
          <source>Like C and Java, but unlike most dynamic languages, Julia has a first-class type for representing a single character, called &lt;a href=&quot;../../base/strings/index#Core.AbstractChar&quot;&gt;&lt;code&gt;AbstractChar&lt;/code&gt;&lt;/a&gt;. The built-in &lt;a href=&quot;../../base/strings/index#Core.Char&quot;&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/a&gt; subtype of &lt;code&gt;AbstractChar&lt;/code&gt; is a 32-bit primitive type that can represent any Unicode character (and which is based on the UTF-8 encoding).</source>
          <target state="translated">CやJavaと同様ですが、ほとんどの動的言語とは異なり、Juliaには、&lt;a href=&quot;../../base/strings/index#Core.AbstractChar&quot;&gt; &lt;code&gt;AbstractChar&lt;/code&gt; &lt;/a&gt;と呼ばれる単一の文字を表すためのファーストクラスの型があります。 &lt;code&gt;AbstractChar&lt;/code&gt; の組み込み&lt;a href=&quot;../../base/strings/index#Core.Char&quot;&gt; &lt;code&gt;Char&lt;/code&gt; &lt;/a&gt;サブタイプは、任意のUnicode文字を表すことができる32ビットのプリミティブ型です（UTF-8エンコーディングに基づいています）。</target>
        </trans-unit>
        <trans-unit id="b144d1ab3b4daafe713dd1906d84dd6576675e14" translate="yes" xml:space="preserve">
          <source>Like ccall, all of these arguments will be evaluated at compile-time, when the containing method is defined.</source>
          <target state="translated">ccall と同様に、これらの引数はすべて、含まれるメソッドが定義されたときにコンパイル時に評価されます。</target>
        </trans-unit>
        <trans-unit id="d14af23f7b07876d0e17dec387b3e911da07b564" translate="yes" xml:space="preserve">
          <source>Like many languages, Julia does not always allow operations on vectors of different lengths, unlike R where the vectors only need to share a common index range. For example, &lt;code&gt;c(1, 2, 3, 4) + c(1, 2)&lt;/code&gt; is valid R but the equivalent &lt;code&gt;[1, 2, 3, 4] + [1, 2]&lt;/code&gt; will throw an error in Julia.</source>
          <target state="translated">多くの言語と同様に、ジュリアは、ベクトルが共通のインデックス範囲を共有するだけでよいRとは異なり、異なる長さのベクトルでの操作を常に許可するわけではありません。たとえば、 &lt;code&gt;c(1, 2, 3, 4) + c(1, 2)&lt;/code&gt; は有効なRですが、同等の &lt;code&gt;[1, 2, 3, 4] + [1, 2]&lt;/code&gt; はJuliaでエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="76129ab650b5177af08ad48252475d8daddeec47" translate="yes" xml:space="preserve">
          <source>Like many other environments, Julia has an &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; function, which takes a filename and returns an &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt;&lt;code&gt;IOStream&lt;/code&gt;&lt;/a&gt; object that you can use to read and write things from the file. For example, if we have a file, &lt;code&gt;hello.txt&lt;/code&gt;, whose contents are &lt;code&gt;Hello, World!&lt;/code&gt;:</source>
          <target state="translated">他の多くの環境と同様に、Juliaには&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;関数があり、ファイル名を受け取り、ファイルからの読み取りと書き込みに使用できる&lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt; &lt;code&gt;IOStream&lt;/code&gt; &lt;/a&gt;オブジェクトを返します。たとえば、 &lt;code&gt;hello.txt&lt;/code&gt; というファイルがあり、その内容が &lt;code&gt;Hello, World!&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1f57deb1de610f6542b69d3ee454e00aa561ce8c" translate="yes" xml:space="preserve">
          <source>Like non-standard string literals, non-standard command literals exist using a prefixed variant of the command literal syntax. The command literal &lt;code&gt;custom`literal`&lt;/code&gt; is parsed as &lt;code&gt;@custom_cmd &quot;literal&quot;&lt;/code&gt;. Julia itself does not contain any non-standard command literals, but packages can make use of this syntax. Aside from the different syntax and the &lt;code&gt;_cmd&lt;/code&gt; suffix instead of the &lt;code&gt;_str&lt;/code&gt; suffix, non-standard command literals behave exactly like non-standard string literals.</source>
          <target state="translated">非標準の文字列リテラルと同様に、非標準のコマンドリテラルは、コマンドリテラル構文の接頭辞付きのバリアントを使用して存在します。コマンドリテラル &lt;code&gt;custom`literal`&lt;/code&gt; は &lt;code&gt;@custom_cmd &quot;literal&quot;&lt;/code&gt; として解析されます。Julia自体には非標準のコマンドリテラルは含まれていませんが、パッケージはこの構文を利用できます。異なる構文と、 &lt;code&gt;_cmd&lt;/code&gt; サフィックスではなく_cmdサフィックスを &lt;code&gt;_str&lt;/code&gt; 、非標準のコマンドリテラルは、非標準の文字列リテラルとまったく同じように動作します。</target>
        </trans-unit>
        <trans-unit id="ca04337635b1b8ca769f7475dd5bb9a710a07316" translate="yes" xml:space="preserve">
          <source>Like remote references, shared arrays are also dependent on garbage collection on the creating node to release references from all participating workers. Code which creates many short lived shared array objects would benefit from explicitly finalizing these objects as soon as possible. This results in both memory and file handles mapping the shared segment being released sooner.</source>
          <target state="translated">リモート参照と同様に、共有配列もまた、参加しているすべてのワーカーから参照を解放するために、作成ノードのガベージコレクションに依存しています。短期間で多くの共有配列オブジェクトを作成するコードでは、これらのオブジェクトをできるだけ早く明示的に最終化することが有益です。これにより、共有セグメントをマッピングするメモリとファイルハンドルの両方がより早く解放されます。</target>
        </trans-unit>
        <trans-unit id="bc02118fe44dfd1db0138406f1b30a59afe69954" translate="yes" xml:space="preserve">
          <source>Likewise, the global variable &lt;code&gt;Base.SYSCONFDIR&lt;/code&gt; determines a relative path to the configuration file directory. Then Julia searches for a &lt;code&gt;startup.jl&lt;/code&gt; file at</source>
          <target state="translated">同様に、グローバル変数 &lt;code&gt;Base.SYSCONFDIR&lt;/code&gt; は、構成ファイルディレクトリへの相対パスを決定します。次に、Juliaは、 &lt;code&gt;startup.jl&lt;/code&gt; ファイルを次の場所で検索します。</target>
        </trans-unit>
        <trans-unit id="40654ee5f02852c7196e6e2f00f07fee2fb0ef03" translate="yes" xml:space="preserve">
          <source>Limit usage of CPU features up to &lt;code&gt;&amp;lt;target&amp;gt;&lt;/code&gt;; set to &lt;code&gt;help&lt;/code&gt; to see the available options</source>
          <target state="translated">CPU機能の使用を &lt;code&gt;&amp;lt;target&amp;gt;&lt;/code&gt; までに制限します。利用可能なオプションを確認する &lt;code&gt;help&lt;/code&gt; に設定します</target>
        </trans-unit>
        <trans-unit id="8d96ce8bb4e79cb43743b90921151985b53e510c" translate="yes" xml:space="preserve">
          <source>LinRange</source>
          <target state="translated">LinRange</target>
        </trans-unit>
        <trans-unit id="d937e9c2df56b1e58e5b8819252e720563fa79ea" translate="yes" xml:space="preserve">
          <source>Line 3 of &lt;code&gt;myfunc&lt;/code&gt; contains the call to &lt;code&gt;maximum&lt;/code&gt;, and there were 28 (out of 80) backtraces taken here. Below that, you can see the specific places in &lt;code&gt;base/reduce.jl&lt;/code&gt; that carry out the time-consuming operations in the &lt;code&gt;maximum&lt;/code&gt; function for this type of input data.</source>
          <target state="translated">3行目 &lt;code&gt;myfunc&lt;/code&gt; 関数はへの呼び出しが含まれ &lt;code&gt;maximum&lt;/code&gt; 、そしてここで撮影したバックトレース（80のうちの）28がありました。その下に、このタイプの入力データの &lt;code&gt;maximum&lt;/code&gt; 関数で時間のかかる操作を実行する &lt;code&gt;base/reduce.jl&lt;/code&gt; の特定の場所が表示されます。</target>
        </trans-unit>
        <trans-unit id="677b9ff91279f2c92df14e8f98feaaad0ff02671" translate="yes" xml:space="preserve">
          <source>Line Integration Not Including The Pole</source>
          <target state="translated">ポールを含まないライン統合</target>
        </trans-unit>
        <trans-unit id="aa862b80ca648d32974899a07b490c840367365f" translate="yes" xml:space="preserve">
          <source>Line Integration With Rectangular Path Around Pole</source>
          <target state="translated">ポールの周りに長方形の経路を持つ線の統合</target>
        </trans-unit>
        <trans-unit id="cd235d8e390a116750618564e9fef4ddd8d815c0" translate="yes" xml:space="preserve">
          <source>Line Integration With Semicircular Path Around Pole</source>
          <target state="translated">極付近の半円経路を用いた線積分</target>
        </trans-unit>
        <trans-unit id="fcb739908d0a50031f680d3b4fffc6749c4002d3" translate="yes" xml:space="preserve">
          <source>Linear Algebra</source>
          <target state="translated">線形代数</target>
        </trans-unit>
        <trans-unit id="3ab90484838b94648400b6fcaea9c0833f594271" translate="yes" xml:space="preserve">
          <source>Linear algebra functions in Julia are largely implemented by calling functions from &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK&lt;/a&gt;. Sparse factorizations call functions from &lt;a href=&quot;http://faculty.cse.tamu.edu/davis/suitesparse.html&quot;&gt;SuiteSparse&lt;/a&gt;.</source>
          <target state="translated">Juliaの線形代数関数は、主に&lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK&lt;/a&gt;から関数を呼び出すことによって実装されます。スパース分解は&lt;a href=&quot;http://faculty.cse.tamu.edu/davis/suitesparse.html&quot;&gt;SuiteSparse&lt;/a&gt;から関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="d1c65bd6bdbd1cc3a07c925c8d1f63a9ef479713" translate="yes" xml:space="preserve">
          <source>Linear index to cartesian index conversion exploits the fact that a &lt;code&gt;CartesianIndices&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt; and can be indexed linearly:</source>
          <target state="translated">線形インデックスからデカルトインデックスへの変換は、 &lt;code&gt;CartesianIndices&lt;/code&gt; が &lt;code&gt;AbstractArray&lt;/code&gt; であり、線形にインデックスを付けることができるという事実を利用しています。</target>
        </trans-unit>
        <trans-unit id="c1c4acc4812d010d9f4c5b8b2c947ad6bf3a9bbc" translate="yes" xml:space="preserve">
          <source>Linear indexing</source>
          <target state="translated">リニアインデックス</target>
        </trans-unit>
        <trans-unit id="a4c16b0102a66cf314085c9fb0015204063e6fd3" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Adjoint</source>
          <target state="translated">LinearAlgebra.Adjoint</target>
        </trans-unit>
        <trans-unit id="f15dbf32eea38f12565a79b8c505de8f87a92ec9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS</source>
          <target state="translated">LinearAlgebra.BLAS</target>
        </trans-unit>
        <trans-unit id="e45107bca3f2265e5d9c85ca1c9fec27cc17de1c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.asum()</source>
          <target state="translated">LinearAlgebra.BLAS.asum()</target>
        </trans-unit>
        <trans-unit id="0372d64ede3f868ef8099f9d2d0ba0d26301cae5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.blascopy!()</source>
          <target state="translated">LinearAlgebra.BLAS.blascopy!()</target>
        </trans-unit>
        <trans-unit id="d13717e84d8e032e30650fc47582fb7cd32b85c2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.dotc()</source>
          <target state="translated">LinearAlgebra.BLAS.dotc()</target>
        </trans-unit>
        <trans-unit id="80b561d6fb654a4f5dbc4d039a743babeb78f05a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.dotu()</source>
          <target state="translated">LinearAlgebra.BLAS.dotu()</target>
        </trans-unit>
        <trans-unit id="182543675c48dfba38aa5478d8ce3279d26d4ef4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gbmv!()</source>
          <target state="translated">LinearAlgebra.BLAS.gbmv!()</target>
        </trans-unit>
        <trans-unit id="6cec9f631b39a94bb3001b07c15c7364aacddbae" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gbmv()</source>
          <target state="translated">LinearAlgebra.BLAS.gbmv()</target>
        </trans-unit>
        <trans-unit id="59202f7fad0ff0f17101364487458d9228718112" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemm!()</source>
          <target state="translated">LinearAlgebra.BLAS.gemm!()</target>
        </trans-unit>
        <trans-unit id="a90dea0e894e7db5d100f0da8dd99eb55becb11a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemm()</source>
          <target state="translated">LinearAlgebra.BLAS.gemm()</target>
        </trans-unit>
        <trans-unit id="9c43130d6006aefdd06d70d7199a76e138e6d41f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemv!()</source>
          <target state="translated">LinearAlgebra.BLAS.gemv!()</target>
        </trans-unit>
        <trans-unit id="9e7d057213847eff9fcee5278de6f9c65c129248" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemv()</source>
          <target state="translated">LinearAlgebra.BLAS.gemv()</target>
        </trans-unit>
        <trans-unit id="7de983e341dd493a6005bdeccd16b2008abe1b4c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.ger!()</source>
          <target state="translated">LinearAlgebra.BLAS.ger!()</target>
        </trans-unit>
        <trans-unit id="c508786b30abc595e3c001798b77caf3e83ceab1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.her!()</source>
          <target state="translated">LinearAlgebra.BLAS.her!()</target>
        </trans-unit>
        <trans-unit id="01f3abbc9926c6680a10dada97213576f68220e4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.herk!()</source>
          <target state="translated">LinearAlgebra.BLAS.herk!()</target>
        </trans-unit>
        <trans-unit id="7ca416ce67850358cd75772ae19bf13edb1e3145" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.herk()</source>
          <target state="translated">LinearAlgebra.BLAS.herk()</target>
        </trans-unit>
        <trans-unit id="ae660954410680fe7bf17073b8a5a13e3d858105" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.iamax()</source>
          <target state="translated">LinearAlgebra.BLAS.iamax()</target>
        </trans-unit>
        <trans-unit id="cd1a2671bbd0fd5d0123954f4b697032be1e635c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.nrm2()</source>
          <target state="translated">LinearAlgebra.BLAS.nrm2()</target>
        </trans-unit>
        <trans-unit id="e90dcf81b0d3bcd42a1f41c82cba29bfcb9a2dc1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.sbmv!()</source>
          <target state="translated">LinearAlgebra.BLAS.sbmv!()</target>
        </trans-unit>
        <trans-unit id="726229488f087bf6f4b29c015474123c38acb7e3" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.sbmv()</source>
          <target state="translated">LinearAlgebra.BLAS.sbmv()</target>
        </trans-unit>
        <trans-unit id="e38b1b5860121c691bed2ff0a82bb4bddb43aeda" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.scal!()</source>
          <target state="translated">LinearAlgebra.BLAS.scal!()</target>
        </trans-unit>
        <trans-unit id="4a5ae3b0e35b9b56d0ca4f544caed75fc4410c97" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.scal()</source>
          <target state="translated">LinearAlgebra.BLAS.scal()</target>
        </trans-unit>
        <trans-unit id="bd2ae45b248f17f2163a416ae8b1b8f316599548" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.set_num_threads()</source>
          <target state="translated">LinearAlgebra.BLAS.set_num_threads()</target>
        </trans-unit>
        <trans-unit id="0ee907ef539363efacff8c904278837def446859" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symm!()</source>
          <target state="translated">LinearAlgebra.BLAS.symm!()</target>
        </trans-unit>
        <trans-unit id="2ca89af9829c4450e1da15d694b423f02feaf2fc" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symm()</source>
          <target state="translated">LinearAlgebra.BLAS.symm()</target>
        </trans-unit>
        <trans-unit id="c4ff899252dc161c59c729ece50db7c6e510be1f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symv!()</source>
          <target state="translated">LinearAlgebra.BLAS.symv!()</target>
        </trans-unit>
        <trans-unit id="c3f814d8d8c968ce7e35bf9e0c795e7503d54b00" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symv()</source>
          <target state="translated">LinearAlgebra.BLAS.symv()</target>
        </trans-unit>
        <trans-unit id="5668a0235a5cc16113ef6c829d5f4f3cb946eb77" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.syr!()</source>
          <target state="translated">LinearAlgebra.BLAS.syr!()</target>
        </trans-unit>
        <trans-unit id="0ea3ba86e685fafe1804ca06ce2cc0aa30792e4d" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.syrk!()</source>
          <target state="translated">LinearAlgebra.BLAS.syrk!()</target>
        </trans-unit>
        <trans-unit id="2910b73b192710f5034193e1b67ded6bb10699b0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.syrk()</source>
          <target state="translated">LinearAlgebra.BLAS.syrk()</target>
        </trans-unit>
        <trans-unit id="c657c078868b4b49e269336d3ff46af071f8fa01" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmm!()</source>
          <target state="translated">LinearAlgebra.BLAS.trmm!()</target>
        </trans-unit>
        <trans-unit id="04b9bf86a921535849558977a38bc7efdcdd3272" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmm()</source>
          <target state="translated">LinearAlgebra.BLAS.trmm()</target>
        </trans-unit>
        <trans-unit id="9d8cb1ea03abc954f9254445e2db3781f49756de" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmv!()</source>
          <target state="translated">LinearAlgebra.BLAS.trmv!()</target>
        </trans-unit>
        <trans-unit id="72558d3ed3ecbb2cf81ea6ad3401440af8b8f050" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmv()</source>
          <target state="translated">LinearAlgebra.BLAS.trmv()</target>
        </trans-unit>
        <trans-unit id="218cea369dcdb92ba6f1e8b45bda62d05efdb29f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsm!()</source>
          <target state="translated">LinearAlgebra.BLAS.trsm!()</target>
        </trans-unit>
        <trans-unit id="05197b08bc46d65744a62e5816cecfcc72ef9983" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsm()</source>
          <target state="translated">LinearAlgebra.BLAS.trsm()</target>
        </trans-unit>
        <trans-unit id="a147ea56a9e55d82d2590cd764be5c11a28ac42c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsv!()</source>
          <target state="translated">LinearAlgebra.BLAS.trsv!()</target>
        </trans-unit>
        <trans-unit id="3205efa3be1bef6bfc936054e89c97d514d48dc9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsv()</source>
          <target state="translated">LinearAlgebra.BLAS.trsv()</target>
        </trans-unit>
        <trans-unit id="6364f45353271734da7f68207b58b49b90c519aa" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Bidiagonal</source>
          <target state="translated">LinearAlgebra.Bidiagonal</target>
        </trans-unit>
        <trans-unit id="b0cf658cc297affd7bac8f29cb18f8d5898c988a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Diagonal</source>
          <target state="translated">LinearAlgebra.Diagonal</target>
        </trans-unit>
        <trans-unit id="1b39c6247cb769989ac9ddbddb50b7a2c7340d63" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Givens</source>
          <target state="translated">LinearAlgebra.Givens</target>
        </trans-unit>
        <trans-unit id="202cd7384296c88f891bea55496b32195e848e3c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Hermitian</source>
          <target state="translated">LinearAlgebra.Hermitian</target>
        </trans-unit>
        <trans-unit id="79fc319c7c269772fed2f361672bd676a3520fae" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.I</source>
          <target state="translated">LinearAlgebra.I</target>
        </trans-unit>
        <trans-unit id="2a1626ced0dce6995c5f58e8d3def911fe7d751f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK</source>
          <target state="translated">LinearAlgebra.LAPACK</target>
        </trans-unit>
        <trans-unit id="6952bafd874a0b24bee2d594a25adae4924e4368" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.bdsdc!()</source>
          <target state="translated">LinearAlgebra.LAPACK.bdsdc!()</target>
        </trans-unit>
        <trans-unit id="8d0c6a0d204bac9380f45220c8b25a01fbcacfc6" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.bdsqr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.bdsqr!()</target>
        </trans-unit>
        <trans-unit id="21f727539d33d03dc8b986b7ecf7ebc53925b185" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gbtrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gbtrf!()</target>
        </trans-unit>
        <trans-unit id="2bb72a67df1d100e66f590117e79a6b1fe23456f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gbtrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gbtrs!()</target>
        </trans-unit>
        <trans-unit id="042b17e7fbbcced06624b5d18cecc1aa4880dfbf" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gebak!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gebak!()</target>
        </trans-unit>
        <trans-unit id="5d6511493ba85c27c966c3e62df9148d39254215" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gebal!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gebal!()</target>
        </trans-unit>
        <trans-unit id="3f829c89a9fa98bb138c195dfc567bcd88556869" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gebrd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gebrd!()</target>
        </trans-unit>
        <trans-unit id="7b9eae4d91dc7949a3ab26f80620c6913329a279" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gecon!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gecon!()</target>
        </trans-unit>
        <trans-unit id="bb09b2b974d5f60b025547cb0fa46b9c45f6eabf" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gees!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gees!()</target>
        </trans-unit>
        <trans-unit id="4adfdd0d27bb95b254d684fb07bba4182c2a0a10" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geev!()</target>
        </trans-unit>
        <trans-unit id="f5fc1d59d033c8ca0452a21a055c7e9b2cdc3409" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geevx!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geevx!()</target>
        </trans-unit>
        <trans-unit id="4162f14b7f241061ff814adad6bc4880eae0e215" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gehrd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gehrd!()</target>
        </trans-unit>
        <trans-unit id="8e52c2ea87a7196909af8b847322a690fcef6a4f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gelqf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gelqf!()</target>
        </trans-unit>
        <trans-unit id="b7bb54e5159886ceee34f20483cdbbf42f4c1539" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gels!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gels!()</target>
        </trans-unit>
        <trans-unit id="7f10b1dc3cf7af9a395a67850e24907c94936d00" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gelsd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gelsd!()</target>
        </trans-unit>
        <trans-unit id="80af9020ee1658e044f9880edaa420f6156e7344" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gelsy!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gelsy!()</target>
        </trans-unit>
        <trans-unit id="0287631b489ed93feb1a00a1ebe340392e903cd8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gemqrt!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gemqrt!()</target>
        </trans-unit>
        <trans-unit id="756fb9e8e80236b54ccbf1725c3d3d72fe14d0a7" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqlf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqlf!()</target>
        </trans-unit>
        <trans-unit id="0fa233b136691bcd50a971792940b70a927e194d" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqp3!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqp3!()</target>
        </trans-unit>
        <trans-unit id="965cf80f5d69f9b2fe0863a82cdd4b368ed4eba1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqrf!()</target>
        </trans-unit>
        <trans-unit id="47893a6fd6bd1458706a0673e1d64d54be6d20ec" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqrt!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqrt!()</target>
        </trans-unit>
        <trans-unit id="94f19bfcd3971a4989d673487abd3bd487d293d1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqrt3!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqrt3!()</target>
        </trans-unit>
        <trans-unit id="19ff37cfcf822fda7f988e77f92c195943446d8b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gerqf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gerqf!()</target>
        </trans-unit>
        <trans-unit id="c47fe5b7f34f49ec65d1767c07d0c357d6c12e20" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesdd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesdd!()</target>
        </trans-unit>
        <trans-unit id="5abf4ebce7739a88e07c58cc2ab150c8e79b9a6f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesv!()</target>
        </trans-unit>
        <trans-unit id="f900ac3ce3ebbd4997a5abaafa85072405326271" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesvd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesvd!()</target>
        </trans-unit>
        <trans-unit id="3a69b9c0d56562dd7ea697ae7f5eea3c3217e8c4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesvx!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesvx!()</target>
        </trans-unit>
        <trans-unit id="997ad4b85fe561bd14fecda4a9185c9be5de7367" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.getrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.getrf!()</target>
        </trans-unit>
        <trans-unit id="d93427849097672e5ca2dd0b81aead36db3bffe6" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.getri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.getri!()</target>
        </trans-unit>
        <trans-unit id="46614120fda23ffee34b46ef06a4d2717d89fb72" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.getrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.getrs!()</target>
        </trans-unit>
        <trans-unit id="3d14f5edf2f52561c8b1cfcc015d4eefd5e8344a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gges!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gges!()</target>
        </trans-unit>
        <trans-unit id="7a73e7bdeb2ad0938d68fd93e6f27345108ba8b1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ggev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ggev!()</target>
        </trans-unit>
        <trans-unit id="3ae17e2685021efceba3fcfa226528ce1e41d6a9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gglse!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gglse!()</target>
        </trans-unit>
        <trans-unit id="3100382b56a5f6703f1da34614842b2f9fd9e2ad" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ggsvd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ggsvd!()</target>
        </trans-unit>
        <trans-unit id="61dfaab553dd3ccfaacf89bcaa2704beb947b945" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ggsvd3!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ggsvd3!()</target>
        </trans-unit>
        <trans-unit id="db05e9a4a5c735805bf40092dca7033de637b064" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gtsv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gtsv!()</target>
        </trans-unit>
        <trans-unit id="9b6b3e96efd10abaf039016da8b07d6fdefa2dac" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gttrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gttrf!()</target>
        </trans-unit>
        <trans-unit id="7d5b231fee9480951dc3ad4ba6239425f9a1a69e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gttrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gttrs!()</target>
        </trans-unit>
        <trans-unit id="56b45916f3c5b6ccae7d5897efff708c77670fe9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hesv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hesv!()</target>
        </trans-unit>
        <trans-unit id="1dd5d2c561afecfbda18ff5f8f3e44ea02e6d2fc" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hetrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hetrf!()</target>
        </trans-unit>
        <trans-unit id="cf6a921b989ce1adbf03be52e76504708a3db4ac" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hetri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hetri!()</target>
        </trans-unit>
        <trans-unit id="a535b2e2552fdefb2e31ef5cf705c68b406e0e4e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hetrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hetrs!()</target>
        </trans-unit>
        <trans-unit id="3c7e4832c831bf40fdec955ad64e7df4981b628e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orghr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orghr!()</target>
        </trans-unit>
        <trans-unit id="9afd9979936c6db6319fad409953eb23f579d5ca" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orglq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orglq!()</target>
        </trans-unit>
        <trans-unit id="72fc39a42e1ba3ec988e4e34aca8961c7d4dd43b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orgql!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orgql!()</target>
        </trans-unit>
        <trans-unit id="3f36d991b78dd60e8ba960e3ddf5db19bd097fb8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orgqr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orgqr!()</target>
        </trans-unit>
        <trans-unit id="18eb3015f314ddb831889efa958dd72893b66864" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orgrq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orgrq!()</target>
        </trans-unit>
        <trans-unit id="ee585149aad96671646932b1d3634278142c13f9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormlq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormlq!()</target>
        </trans-unit>
        <trans-unit id="bdfbc8d40444d8bafd90c67f455d3b34e73228cf" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormql!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormql!()</target>
        </trans-unit>
        <trans-unit id="1087b8488a465127e32826863adc779bd9d1327c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormqr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormqr!()</target>
        </trans-unit>
        <trans-unit id="a2fb188b73bde57195bb1d824030a4ed0bbd608b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormrq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormrq!()</target>
        </trans-unit>
        <trans-unit id="ffa8283f30595d57d465f23f206871d42b88b987" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormrz!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormrz!()</target>
        </trans-unit>
        <trans-unit id="c7253e7d1bd1dce84f707a9c7bb94c23529af18b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.posv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.posv!()</target>
        </trans-unit>
        <trans-unit id="9686f05e5f67aa477b854f99ab98169e47b19084" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.potrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.potrf!()</target>
        </trans-unit>
        <trans-unit id="a162ea4f7602eae7842c83604fa469aeb77c3bfd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.potri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.potri!()</target>
        </trans-unit>
        <trans-unit id="22fdc042984e65bbd42e11f87af366faeef74622" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.potrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.potrs!()</target>
        </trans-unit>
        <trans-unit id="2e152451a9c97ebf916e592216ff01087a6982bd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.pstrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.pstrf!()</target>
        </trans-unit>
        <trans-unit id="9a048d5b8589397c46ecf7dd3a023271382559b0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ptsv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ptsv!()</target>
        </trans-unit>
        <trans-unit id="6bd4c3257dbbd4280e5dfb016628a7275adf1a33" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.pttrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.pttrf!()</target>
        </trans-unit>
        <trans-unit id="959a9d0a79a973f313fff6fc55c623c797c6c7f7" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.pttrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.pttrs!()</target>
        </trans-unit>
        <trans-unit id="6d7e0b67347ba1e8b9a711859117ac575684e8e1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stebz!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stebz!()</target>
        </trans-unit>
        <trans-unit id="e4c4102de134bdf1c8c27920913760be8971f8a2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stegr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stegr!()</target>
        </trans-unit>
        <trans-unit id="09e672928c1ecc7dda3783503f4b5dded92b9673" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stein!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stein!()</target>
        </trans-unit>
        <trans-unit id="eace3492602beabe1f2ab7981e7d9209cfc2204c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stev!()</target>
        </trans-unit>
        <trans-unit id="66d07521e84ded0664c8e6d24cb062cfa0abf44c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.syconv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.syconv!()</target>
        </trans-unit>
        <trans-unit id="e37c017154e2c1fa3c47a038f981c9a2f9b128ad" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.syev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.syev!()</target>
        </trans-unit>
        <trans-unit id="371acb573fdc2cfe58acc84371e930aa7f66f883" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.syevr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.syevr!()</target>
        </trans-unit>
        <trans-unit id="4489b4eba27fe6a94403f8fc257631ee4a85b0d1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sygvd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sygvd!()</target>
        </trans-unit>
        <trans-unit id="f6128668d243c8ac355a7d5c46c06adfedbfe0c0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sysv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sysv!()</target>
        </trans-unit>
        <trans-unit id="022ac6bcea134ce5fe3a89f3bf4383107b51b2a0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sytrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sytrf!()</target>
        </trans-unit>
        <trans-unit id="a8bb80be7fdb78fb2ac23b9a1ad4b26eace9add4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sytri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sytri!()</target>
        </trans-unit>
        <trans-unit id="9d2a23098c970b0a82d03a2a452ca8118a4c74c0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sytrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sytrs!()</target>
        </trans-unit>
        <trans-unit id="83c634bcfc2f6365a7a5ab5dac799d6cefa5dae1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.tgsen!()</source>
          <target state="translated">LinearAlgebra.LAPACK.tgsen!()</target>
        </trans-unit>
        <trans-unit id="b190b8b87f953db3f01614e0cef9f46ab8ddef6c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trcon!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trcon!()</target>
        </trans-unit>
        <trans-unit id="81c93a5fe65faa5e18e25557226f1e29499c9834" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trevc!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trevc!()</target>
        </trans-unit>
        <trans-unit id="0fde83f3dc9a18889586b82aefe631e75f1ca0a5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trexc!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trexc!()</target>
        </trans-unit>
        <trans-unit id="e0a6fb5f31ac808c6c4c2d58c9bd3c8bf4547c3c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trrfs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trrfs!()</target>
        </trans-unit>
        <trans-unit id="b4a63b08edea3206f96883f52f887e335290d30c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trsen!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trsen!()</target>
        </trans-unit>
        <trans-unit id="0981f544b1017b88401f0c0d727a8512e3a16911" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trsyl!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trsyl!()</target>
        </trans-unit>
        <trans-unit id="0dd13d83537af1986304c93341975314e0a3cb92" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trtri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trtri!()</target>
        </trans-unit>
        <trans-unit id="6ace8e21c229caf81f057c6691dc06ea1d7feacb" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trtrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trtrs!()</target>
        </trans-unit>
        <trans-unit id="9f4a95aa5cd6a48d65dcce0dfbc0c2104db08ddb" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.tzrzf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.tzrzf!()</target>
        </trans-unit>
        <trans-unit id="8dc3928b7aacf4bc69fb8fb480397c2bd0754291" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LowerTriangular</source>
          <target state="translated">LinearAlgebra.LowerTriangular</target>
        </trans-unit>
        <trans-unit id="d296a34551600570579f05eb52f68d858500b6d0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.PosDefException</source>
          <target state="translated">LinearAlgebra.PosDefException</target>
        </trans-unit>
        <trans-unit id="1a5ee969e2fda57a234091ffc7169bb0717b4b55" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.QR</source>
          <target state="translated">LinearAlgebra.QR</target>
        </trans-unit>
        <trans-unit id="f252432902b3e7d2b6f5a1f541fab2b2b837e497" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.QRCompactWY</source>
          <target state="translated">LinearAlgebra.QRCompactWY</target>
        </trans-unit>
        <trans-unit id="f69a9de928f655bcff2c3bb620374afc9c7adc36" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.QRPivoted</source>
          <target state="translated">LinearAlgebra.QRPivoted</target>
        </trans-unit>
        <trans-unit id="91c43501578d11cc7b806496b694bc7fb0798c40" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.SingularException</source>
          <target state="translated">LinearAlgebra.SingularException</target>
        </trans-unit>
        <trans-unit id="21fa708b4606d3744276dbdb6504d1d33fb0880d" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.SymTridiagonal</source>
          <target state="translated">LinearAlgebra.SymTridiagonal</target>
        </trans-unit>
        <trans-unit id="c49662dfefa654d140f37c4f501e68d902dc9896" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Symmetric</source>
          <target state="translated">LinearAlgebra.Symmetric</target>
        </trans-unit>
        <trans-unit id="0b7bcff88afd509726e928a1da4371d5aad48e96" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Transpose</source>
          <target state="translated">LinearAlgebra.Transpose</target>
        </trans-unit>
        <trans-unit id="2f6e7904ca2d80d08fecb44ff694e5529ca8a0d2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Tridiagonal</source>
          <target state="translated">LinearAlgebra.Tridiagonal</target>
        </trans-unit>
        <trans-unit id="bcd3cd958cfc2292b170f7eb25170c03f9af2ed5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UniformScaling</source>
          <target state="translated">LinearAlgebra.UniformScaling</target>
        </trans-unit>
        <trans-unit id="5441959246e16a93a832c57343376624fe880467" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UnitLowerTriangular</source>
          <target state="translated">LinearAlgebra.UnitLowerTriangular</target>
        </trans-unit>
        <trans-unit id="828cc10c694c730e1acddbbb4fe2c09ed2dca433" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UnitUpperTriangular</source>
          <target state="translated">LinearAlgebra.UnitUpperTriangular</target>
        </trans-unit>
        <trans-unit id="fa757c0838038ffc2a6e801a13ed5a7b6a193380" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UpperTriangular</source>
          <target state="translated">LinearAlgebra.UpperTriangular</target>
        </trans-unit>
        <trans-unit id="738beaba8ed2df6f31a673ee2db8f7e43295d515" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.adjoint!()</source>
          <target state="translated">LinearAlgebra.adjoint!()</target>
        </trans-unit>
        <trans-unit id="9920d50dc92a459847aa3353d4531d0f64c48729" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.axpy!()</source>
          <target state="translated">LinearAlgebra.axpy!()</target>
        </trans-unit>
        <trans-unit id="8382532f0eba26f9bafb22dc5faa9989630741b4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.bunchkaufman!()</source>
          <target state="translated">LinearAlgebra.bunchkaufman!()</target>
        </trans-unit>
        <trans-unit id="f1ff255591a788d659f39c668b504aff71f28694" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.bunchkaufman()</source>
          <target state="translated">LinearAlgebra.bunchkaufman()</target>
        </trans-unit>
        <trans-unit id="49b3835122bf27c1a5c23bc1f6af4df7016dfd20" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.checksquare()</source>
          <target state="translated">LinearAlgebra.checksquare()</target>
        </trans-unit>
        <trans-unit id="f296f09ff80bdc588b439135e7b625bce1f0d744" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cholesky!()</source>
          <target state="translated">LinearAlgebra.cholesky!()</target>
        </trans-unit>
        <trans-unit id="2614d615a16d87a3a50db7af9f3788e4b71855b0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cholesky()</source>
          <target state="translated">LinearAlgebra.cholesky()</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
