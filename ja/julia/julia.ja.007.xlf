<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="9cf1660ad8de659f871c4cde9fc066e87eb4f30f" translate="yes" xml:space="preserve">
          <source>For an iterator or collection that has keys and values, return an iterator over the values. This function simply returns its argument by default, since the elements of a general iterator are normally considered its &quot;values&quot;.</source>
          <target state="translated">キーと値を持つイテレータまたはコレクションに対して、値の上のイテレータを返します。一般的なイテレータの要素は通常その &quot;値 &quot;とみなされるので、この関数は単にデフォルトでその引数を返します。</target>
        </trans-unit>
        <trans-unit id="95a50cf1c996d77537f503b2b0ab2ae143d3ab0c" translate="yes" xml:space="preserve">
          <source>For an out-of-place version, see &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt;&lt;code&gt;dropzeros&lt;/code&gt;&lt;/a&gt;. For algorithmic information, see &lt;code&gt;fkeep!&lt;/code&gt;.</source>
          <target state="translated">アウトオブプレースバージョンについては、&lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt; &lt;code&gt;dropzeros&lt;/code&gt; を&lt;/a&gt;参照してください。アルゴリズム情報については、 &lt;code&gt;fkeep!&lt;/code&gt; を参照してください。。</target>
        </trans-unit>
        <trans-unit id="d9698467f9f9a26107005e5cc7d8c52ec73e6fba" translate="yes" xml:space="preserve">
          <source>For an overview of why functions like &lt;a href=&quot;../../base/math/index#Base.Math.hypot&quot;&gt;&lt;code&gt;hypot&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/math/index#Base.expm1&quot;&gt;&lt;code&gt;expm1&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/math/index#Base.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; are necessary and useful, see John D. Cook's excellent pair of blog posts on the subject: &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/&quot;&gt;expm1, log1p, erfc&lt;/a&gt;, and &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/&quot;&gt;hypot&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/math/index#Base.Math.hypot&quot;&gt; &lt;code&gt;hypot&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/math/index#Base.expm1&quot;&gt; &lt;code&gt;expm1&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../../base/math/index#Base.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; の&lt;/a&gt;ような関数が必要かつ有用である理由の概要については、John D. Cookの件名に関する優れたブログ投稿の&lt;a href=&quot;https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/&quot;&gt;expm1、log1p、erfc&lt;/a&gt;、および&lt;a href=&quot;https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/&quot;&gt;hypotを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d80c08b4c206c014a1c8f4dd0759aa7c625fa2a" translate="yes" xml:space="preserve">
          <source>For any iterable container &lt;code&gt;A&lt;/code&gt; (including arrays of any dimension) of numbers (or any element type for which &lt;code&gt;norm&lt;/code&gt; is defined), compute the &lt;code&gt;p&lt;/code&gt;-norm (defaulting to &lt;code&gt;p=2&lt;/code&gt;) as if &lt;code&gt;A&lt;/code&gt; were a vector of the corresponding length.</source>
          <target state="translated">数値（または &lt;code&gt;norm&lt;/code&gt; が定義されている要素タイプ）の反復可能なコンテナ &lt;code&gt;A&lt;/code&gt; （任意の次元の配列を含む）の場合、 &lt;code&gt;A&lt;/code&gt; が対応する長さのベクトルであるかのように &lt;code&gt;p&lt;/code&gt; -norm（デフォルトは &lt;code&gt;p=2&lt;/code&gt; ）を計算します。</target>
        </trans-unit>
        <trans-unit id="a3a03065c6c3f77db333198b92d9783df8912cc7" translate="yes" xml:space="preserve">
          <source>For any iterable containers &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; (including arrays of any dimension) of numbers (or any element type for which &lt;code&gt;dot&lt;/code&gt; is defined), compute the dot product (or inner product or scalar product), i.e. the sum of &lt;code&gt;dot(x[i],y[i])&lt;/code&gt;, as if they were vectors.</source>
          <target state="translated">数値（または &lt;code&gt;dot&lt;/code&gt; が定義されている要素タイプ）の反復可能なコンテナ &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; （任意の次元の配列を含む）について、ドット積（または内積またはスカラー積）、つまり &lt;code&gt;dot(x[i],y[i])&lt;/code&gt; 、まるでベクトルのように。</target>
        </trans-unit>
        <trans-unit id="9861c33db5cb32a638bd7ed95113f331a3454eb4" translate="yes" xml:space="preserve">
          <source>For any keywords that are not specified, the current settings from &lt;code&gt;cmd&lt;/code&gt; are used. Normally, to create a &lt;code&gt;Cmd&lt;/code&gt; object in the first place, one uses backticks, e.g.</source>
          <target state="translated">指定されていないキーワードについては、 &lt;code&gt;cmd&lt;/code&gt; の現在の設定が使用されます。通常、最初に &lt;code&gt;Cmd&lt;/code&gt; オブジェクトを作成するには、バッククォートを使用します。たとえば、</target>
        </trans-unit>
        <trans-unit id="85d14ad6a0f26364153773489f0db13bfaafa53f" translate="yes" xml:space="preserve">
          <source>For arrays with conventional indexing (indices start at 1), or any multidimensional array, linear indices range from 1 to &lt;code&gt;length(A)&lt;/code&gt;. However, for &lt;code&gt;AbstractVector&lt;/code&gt;s linear indices are &lt;code&gt;axes(A, 1)&lt;/code&gt;, and therefore do not start at 1 for vectors with unconventional indexing.</source>
          <target state="translated">従来のインデックス付けされた配列（インデックスは1から始まります）または多次元配列の場合、線形インデックスの範囲は1から &lt;code&gt;length(A)&lt;/code&gt; です。ただし、 &lt;code&gt;AbstractVector&lt;/code&gt; の場合、線形インデックスは &lt;code&gt;axes(A, 1)&lt;/code&gt; であるため、型破りなインデックスを持つベクトルの場合、1から始まりません。</target>
        </trans-unit>
        <trans-unit id="81f6c2e801b1d9455cd3aa8ac3e88e840497dca8" translate="yes" xml:space="preserve">
          <source>For arrays, returns a string of size and type info, e.g. &lt;code&gt;10-element Array{Int64,1}&lt;/code&gt;.</source>
          <target state="translated">配列の場合、サイズとタイプの情報の文字列を返します（例： &lt;code&gt;10-element Array{Int64,1}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06562c8550b5e93a013f75fd29118d4c0694a02a" translate="yes" xml:space="preserve">
          <source>For arrays, this function requires at least Julia 1.2.</source>
          <target state="translated">配列の場合、この関数は最低でもJulia 1.2が必要です。</target>
        </trans-unit>
        <trans-unit id="d3e36f74f84aea73dce8e8117a1733e018408eb9" translate="yes" xml:space="preserve">
          <source>For bits types this means that the bit pattern of a value once set will never change and that value is the identity of a bits type.</source>
          <target state="translated">ビット型の場合、これは、一度設定された値のビットパターンが変更されないことを意味し、その値がビット型のアイデンティティとなります。</target>
        </trans-unit>
        <trans-unit id="7aee08c8ffda1f859a18b6cbf5bd4f3be6da6c3e" translate="yes" xml:space="preserve">
          <source>For cartesian to linear index conversion, see &lt;a href=&quot;#Base.LinearIndices&quot;&gt;&lt;code&gt;LinearIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">デカルトから線形インデックスへの変換については、&lt;a href=&quot;#Base.LinearIndices&quot;&gt; &lt;code&gt;LinearIndices&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c8b30defdf847f67d42803fa30f31344e75b07b3" translate="yes" xml:space="preserve">
          <source>For code points less than &lt;code&gt;\u80&lt;/code&gt;, it happens that the UTF-8 encoding of each code point is just the single byte produced by the corresponding &lt;code&gt;\x&lt;/code&gt; escape, so the distinction can safely be ignored. For the escapes &lt;code&gt;\x80&lt;/code&gt; through &lt;code&gt;\xff&lt;/code&gt; as compared to &lt;code&gt;\u80&lt;/code&gt; through &lt;code&gt;\uff&lt;/code&gt;, however, there is a major difference: the former escapes all encode single bytes, which &amp;ndash; unless followed by very specific continuation bytes &amp;ndash; do not form valid UTF-8 data, whereas the latter escapes all represent Unicode code points with two-byte encodings.</source>
          <target state="translated">&lt;code&gt;\u80&lt;/code&gt; 未満のコードポイントの場合、各コードポイントのUTF-8エンコーディングは対応する &lt;code&gt;\x&lt;/code&gt; エスケープによって生成された1バイトだけなので、区別は無視しても問題ありません。エスケープのために &lt;code&gt;\x80&lt;/code&gt; 経由 &lt;code&gt;\xff&lt;/code&gt; と比較して、 &lt;code&gt;\u80&lt;/code&gt; 通じ &lt;code&gt;\uff&lt;/code&gt; 、しかし、大きな違いがあります：旧エスケープは、すべてのエンコードシングルバイト、 -非常に特定の継続が続いていない限りは、バイト-有効なUTF-8を形成しません一方、後者のエスケープはすべて、2バイトエンコーディングのUnicodeコードポイントを表します。</target>
        </trans-unit>
        <trans-unit id="7990f7d8e420dec5f948426ee0deb5045c50fdaa" translate="yes" xml:space="preserve">
          <source>For composite types, this means that the identity of the values of its fields will never change. When the fields are bits types, that means their bits will never change, for fields whose values are mutable types like arrays, that means the fields will always refer to the same mutable value even though that mutable value's content may itself be modified.</source>
          <target state="translated">複合型の場合、これはそのフィールドの値の同一性が決して変わらないことを意味します。フィールドがビット型である場合、これはそのビットが変更されないことを意味し、値が配列のような変異型であるフィールドについては、その変異型の内容自体が変更されても、フィールドは常に同じ変異型の値を参照することを意味します。</target>
        </trans-unit>
        <trans-unit id="03316709b23be1fe05fb3b1026fde6353f45ac08" translate="yes" xml:space="preserve">
          <source>For consistency across Julia, the call site should always pass a &lt;code&gt;Val&lt;/code&gt;&lt;em&gt;instance&lt;/em&gt; rather than using a &lt;em&gt;type&lt;/em&gt;, i.e., use &lt;code&gt;foo(Val(:bar))&lt;/code&gt; rather than &lt;code&gt;foo(Val{:bar})&lt;/code&gt;.</source>
          <target state="translated">Julia全体で一貫性を保つため、呼び出しサイトは&lt;em&gt;type&lt;/em&gt;を使用するのではなく、常に &lt;code&gt;Val&lt;/code&gt; &lt;em&gt;インスタンスを&lt;/em&gt;渡す必要があり&lt;em&gt;ます&lt;/em&gt;。つまり、 &lt;code&gt;foo(Val{:bar})&lt;/code&gt; ではなく &lt;code&gt;foo(Val(:bar))&lt;/code&gt; を使用します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d9ce2fe390265769939ee6ced6c2028220d4701" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;p&lt;/code&gt; may be a type instead of a value: &lt;code&gt;ceil(dt, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;ceil(dt, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">便宜上、 &lt;code&gt;p&lt;/code&gt; は値の代わりにタイプにすることができます &lt;code&gt;ceil(dt, Dates.Hour)&lt;/code&gt; は &lt;code&gt;ceil(dt, Dates.Hour(1))&lt;/code&gt; ショートカットです。</target>
        </trans-unit>
        <trans-unit id="89f749ab9e4eefe9228d7474faa98982038d612a" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;p&lt;/code&gt; may be a type instead of a value: &lt;code&gt;floor(dt, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;floor(dt, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">便宜上、 &lt;code&gt;p&lt;/code&gt; は値ではなくタイプにすることができます &lt;code&gt;floor(dt, Dates.Hour)&lt;/code&gt; は、 &lt;code&gt;floor(dt, Dates.Hour(1))&lt;/code&gt; ショートカットです。</target>
        </trans-unit>
        <trans-unit id="ba5445c2e02b549b16ba3decf8b6cd4aeb77578a" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;p&lt;/code&gt; may be a type instead of a value: &lt;code&gt;round(dt, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;round(dt, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">便宜上、 &lt;code&gt;p&lt;/code&gt; は値ではなくタイプにすることができます &lt;code&gt;round(dt, Dates.Hour)&lt;/code&gt; は、 &lt;code&gt;round(dt, Dates.Hour(1))&lt;/code&gt; ショートカットです。</target>
        </trans-unit>
        <trans-unit id="628a74984a13bf54fa3097a1ff489c44e499c284" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;precision&lt;/code&gt; may be a type instead of a value: &lt;code&gt;ceil(x, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;ceil(x, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">便宜上、 &lt;code&gt;precision&lt;/code&gt; は値ではなく型の場合があります &lt;code&gt;ceil(x, Dates.Hour)&lt;/code&gt; は &lt;code&gt;ceil(x, Dates.Hour(1))&lt;/code&gt; ショートカットです。</target>
        </trans-unit>
        <trans-unit id="43f856c7ece595cf56ae5fb16a5157cda0b0b39e" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;precision&lt;/code&gt; may be a type instead of a value: &lt;code&gt;floor(x, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;floor(x, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">便宜上、 &lt;code&gt;precision&lt;/code&gt; は値ではなくタイプの場合があります &lt;code&gt;floor(x, Dates.Hour)&lt;/code&gt; は、 &lt;code&gt;floor(x, Dates.Hour(1))&lt;/code&gt; ショートカットです。</target>
        </trans-unit>
        <trans-unit id="752ad3a1bbf71154ca789079220fccfae5f42c78" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;precision&lt;/code&gt; may be a type instead of a value: &lt;code&gt;round(x, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;round(x, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">便宜上、 &lt;code&gt;precision&lt;/code&gt; は値の代わりにタイプにすることができます &lt;code&gt;round(x, Dates.Hour)&lt;/code&gt; は、 &lt;code&gt;round(x, Dates.Hour(1))&lt;/code&gt; ショートカットです。</target>
        </trans-unit>
        <trans-unit id="337e0be4946ed3262678abe0f2e935f04104f98b" translate="yes" xml:space="preserve">
          <source>For direct C++ interfacing, see the &lt;a href=&quot;https://github.com/Keno/Cxx.jl&quot;&gt;Cxx&lt;/a&gt; package. For tools to create C++ bindings, see the &lt;a href=&quot;https://github.com/JuliaInterop/CxxWrap.jl&quot;&gt;CxxWrap&lt;/a&gt; package.</source>
          <target state="translated">直接のC ++インターフェースについては、&lt;a href=&quot;https://github.com/Keno/Cxx.jl&quot;&gt;Cxx&lt;/a&gt;パッケージを参照してください。C ++バインディングを作成するツールについては、&lt;a href=&quot;https://github.com/JuliaInterop/CxxWrap.jl&quot;&gt;CxxWrap&lt;/a&gt;パッケージを参照してください。</target>
        </trans-unit>
        <trans-unit id="1e618742c8a5d9129a1258dfbf5438a2e4a87773" translate="yes" xml:space="preserve">
          <source>For each pair &lt;code&gt;old=&amp;gt;new&lt;/code&gt; in &lt;code&gt;old_new&lt;/code&gt;, replace all occurrences of &lt;code&gt;old&lt;/code&gt; in collection &lt;code&gt;A&lt;/code&gt; by &lt;code&gt;new&lt;/code&gt;. Equality is determined using &lt;a href=&quot;../base/index#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;count&lt;/code&gt; is specified, then replace at most &lt;code&gt;count&lt;/code&gt; occurrences in total. See also &lt;a href=&quot;#Base.replace-Tuple%7BAny,Vararg%7BPair,N%7D%20where%20N%7D&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">各ペアについて &lt;code&gt;old=&amp;gt;new&lt;/code&gt; で &lt;code&gt;old_new&lt;/code&gt; 、のすべての出現置き換える &lt;code&gt;old&lt;/code&gt; 収集中で &lt;code&gt;A&lt;/code&gt; によって &lt;code&gt;new&lt;/code&gt; 。等価は&lt;a href=&quot;../base/index#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; &lt;/a&gt;を使用して決定されます。 &lt;code&gt;count&lt;/code&gt; が指定されている場合、合計で最大 &lt;code&gt;count&lt;/code&gt; 個のオカレンスを置き換えます。&lt;a href=&quot;#Base.replace-Tuple%7BAny,Vararg%7BPair,N%7D%20where%20N%7D&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="ffd384e9075d866940b3029eb6057da7ada0b04b" translate="yes" xml:space="preserve">
          <source>For ease of understanding, the examples throughout this chapter show full data structures for roots, graph and paths. However, Julia's package loading code does not explicitly create these. Instead, it lazily computes only as much of each structure as it needs to load a given package.</source>
          <target state="translated">理解を容易にするために、この章全体の例では、ルート、グラフ、パスの完全なデータ構造を示しています。しかし、Julia のパッケージ・ロード・コードはこれらを明示的に作成しません。その代わりに、与えられたパッケージをロードするのに必要な分だけ、各構造体の計算を怠りなく行います。</target>
        </trans-unit>
        <trans-unit id="04e18da25adbbde93578f1eb2fa5f41635ed03eb" translate="yes" xml:space="preserve">
          <source>For empty collections, providing &lt;code&gt;init&lt;/code&gt; will be necessary, except for some special cases (e.g. when &lt;code&gt;op&lt;/code&gt; is one of &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;) when Julia can determine the neutral element of &lt;code&gt;op&lt;/code&gt;.</source>
          <target state="translated">空のコレクションの場合、ジュリアが &lt;code&gt;op&lt;/code&gt; の中立要素を決定できるいくつかの特殊なケース（たとえば、 &lt;code&gt;op&lt;/code&gt; が &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;max&lt;/code&gt; 、 &lt;code&gt;min&lt;/code&gt; 、 &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; のいずれかである場合）を除いて、 &lt;code&gt;init&lt;/code&gt; を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="4f7a1238b1ac319ac9db6a4c619c8de57eb47bad" translate="yes" xml:space="preserve">
          <source>For even more extensive documentation of the history of, rationale for, and issues with floating-point numbers, as well as discussion of many other topics in numerical computing, see the &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/&quot;&gt;collected writings&lt;/a&gt; of &lt;a href=&quot;https://en.wikipedia.org/wiki/William_Kahan&quot;&gt;William Kahan&lt;/a&gt;, commonly known as the &quot;Father of Floating-Point&quot;. Of particular interest may be &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html&quot;&gt;An Interview with the Old Man of Floating-Point&lt;/a&gt;.</source>
          <target state="translated">浮動小数点数の歴史、理論的根拠、および問題に関するさらに広範なドキュメント、および数値計算におけるその他の多くのトピックの説明については、一般に「浮動小数点の父」として知られる、&lt;a href=&quot;https://en.wikipedia.org/wiki/William_Kahan&quot;&gt;ウィリアム・カーハンの&lt;/a&gt;&lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/&quot;&gt;収集した資料&lt;/a&gt;を参照してください。ポイント&quot;。特に興味深いのは&lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html&quot;&gt;、浮動小数点の老人へのインタビュー&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="b77b25aae44912586606895a221d1e45b8c25f37" translate="yes" xml:space="preserve">
          <source>For every incoming logical connection with a worker, &lt;code&gt;Base.process_messages(rd::IO, wr::IO)()&lt;/code&gt; must be called. This launches a new task that handles reading and writing of messages from/to the worker represented by the &lt;code&gt;IO&lt;/code&gt; objects.</source>
          <target state="translated">ワーカーとのすべての着信論理接続について、 &lt;code&gt;Base.process_messages(rd::IO, wr::IO)()&lt;/code&gt; 呼び出す必要があります。これにより、 &lt;code&gt;IO&lt;/code&gt; オブジェクトで表されるワーカーとの間のメッセージの読み取りと書き込みを処理する新しいタスクが起動します。</target>
        </trans-unit>
        <trans-unit id="b85b3e1a00e44270cd850d12b0754ab94e579430" translate="yes" xml:space="preserve">
          <source>For every worker launched, the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; method must add a &lt;code&gt;WorkerConfig&lt;/code&gt; object (with appropriate fields initialized) to &lt;code&gt;launched&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt;されたすべてのワーカーについて、起動メソッドは、 &lt;code&gt;WorkerConfig&lt;/code&gt; オブジェクト（適切なフィールドが初期化されている）を &lt;code&gt;launched&lt;/code&gt; 追加する必要があります</target>
        </trans-unit>
        <trans-unit id="17c1669fdd5a30442a1d111e532e0e0ca62fed47" translate="yes" xml:space="preserve">
          <source>For example in order to fix &lt;code&gt;findfirst&lt;/code&gt; example above one needs to have a separate copy of &lt;code&gt;rx&lt;/code&gt; variable for each thread:</source>
          <target state="translated">たとえば、上記の &lt;code&gt;findfirst&lt;/code&gt; の例を修正するには、スレッドごとに &lt;code&gt;rx&lt;/code&gt; 変数の個別のコピーが必要です。</target>
        </trans-unit>
        <trans-unit id="08186eb20e073535d04d3ee1bc374db09694e868" translate="yes" xml:space="preserve">
          <source>For example in the following docstring a variable &lt;code&gt;a&lt;/code&gt; is defined and the expected result, as printed in a Julia REPL, appears afterwards:</source>
          <target state="translated">たとえば、次のdocstringでは、変数 &lt;code&gt;a&lt;/code&gt; が定義されており、Julia REPLに出力された期待される結果が後で表示されます。</target>
        </trans-unit>
        <trans-unit id="b50ac335cd803909aabb34c2ac8aa635fe70764b" translate="yes" xml:space="preserve">
          <source>For example you should write</source>
          <target state="translated">例えば、次のように書きます。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="d30d6b6735d4ff4914afad9079e3d2da944acfc0" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;@static Sys.iswindows() ? foo : bar&lt;/code&gt; will evaluate &lt;code&gt;Sys.iswindows()&lt;/code&gt; and insert either &lt;code&gt;foo&lt;/code&gt; or &lt;code&gt;bar&lt;/code&gt; into the expression. This is useful in cases where a construct would be invalid on other platforms, such as a &lt;code&gt;ccall&lt;/code&gt; to a non-existent function. &lt;code&gt;@static if Sys.isapple() foo end&lt;/code&gt; and &lt;code&gt;@static foo &amp;lt;&amp;amp;&amp;amp;,||&amp;gt; bar&lt;/code&gt; are also valid syntax.</source>
          <target state="translated">たとえば、 &lt;code&gt;@static Sys.iswindows() ? foo : bar&lt;/code&gt; は &lt;code&gt;Sys.iswindows()&lt;/code&gt; を評価し、 &lt;code&gt;foo&lt;/code&gt; または &lt;code&gt;bar&lt;/code&gt; を式に挿入します。これは、存在しない関数への &lt;code&gt;ccall&lt;/code&gt; など、他のプラットフォームでは構成が無効になる場合に役立ちます。 &lt;code&gt;@static if Sys.isapple() foo end&lt;/code&gt; および &lt;code&gt;@static foo &amp;lt;&amp;amp;&amp;amp;,||&amp;gt; bar&lt;/code&gt; も有効な構文です。</target>
        </trans-unit>
        <trans-unit id="ebd8456aa0b38dfe42ed79277e4c1654dd3d60d1" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt;, will return a reference to a channel of type &lt;code&gt;Int&lt;/code&gt; and size 10 on &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">例えば、 &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt; 、タイプのチャネルを参照戻ります &lt;code&gt;Int&lt;/code&gt; に及びサイズ10 &lt;code&gt;pid&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96ff3ffca8d84a68fdc5320415ea0dc59a9a8872" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt;, will return a reference to a channel of type &lt;code&gt;Int&lt;/code&gt; and size 10. The channel exists on worker &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt; 、タイプ &lt;code&gt;Int&lt;/code&gt; およびサイズ10のチャネルへの参照を返します。チャネルはワーカー &lt;code&gt;pid&lt;/code&gt; に存在します。</target>
        </trans-unit>
        <trans-unit id="4891a83f30d6618f43c5e0d97b64d34ca2b73c56" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;similar(1:10, 1, 4)&lt;/code&gt; returns an uninitialized &lt;code&gt;Array{Int,2}&lt;/code&gt; since ranges are neither mutable nor support 2 dimensions:</source>
          <target state="translated">たとえば、 &lt;code&gt;similar(1:10, 1, 4)&lt;/code&gt; は、初期化されていない &lt;code&gt;Array{Int,2}&lt;/code&gt; 返します。これは、範囲が変更可能でもなく、2次元をサポートしていないためです。</target>
        </trans-unit>
        <trans-unit id="9440a60be9ec094e973482fb911a180f54e935ef" translate="yes" xml:space="preserve">
          <source>For example, Beowulf clusters are supported via a custom cluster manager implemented in the package &lt;code&gt;ClusterManagers.jl&lt;/code&gt;.</source>
          <target state="translated">たとえば、Beowulfクラスターは、 &lt;code&gt;ClusterManagers.jl&lt;/code&gt; パッケージに実装されたカスタムクラスターマネージャーを介してサポートされます。</target>
        </trans-unit>
        <trans-unit id="c68e3216a6f7acab7967abd7cf08e2c4de403780" translate="yes" xml:space="preserve">
          <source>For example, NFKC corresponds to the options &lt;code&gt;compose=true, compat=true, stable=true&lt;/code&gt;.</source>
          <target state="translated">たとえば、NFKCはオプション &lt;code&gt;compose=true, compat=true, stable=true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4599895ae8d119fa4cbac0f0c56af45c7eba0c70" translate="yes" xml:space="preserve">
          <source>For example, a Linux installation with a Julia executable located at &lt;code&gt;/bin/julia&lt;/code&gt;, a &lt;code&gt;DATAROOTDIR&lt;/code&gt; of &lt;code&gt;../share&lt;/code&gt;, and a &lt;code&gt;SYSCONFDIR&lt;/code&gt; of &lt;code&gt;../etc&lt;/code&gt; will have &lt;code&gt;JULIA_BINDIR&lt;/code&gt; set to &lt;code&gt;/bin&lt;/code&gt;, a source-file search path of</source>
          <target state="translated">例えば、ジュリアとLinuxのインストールが実行可能に位置 &lt;code&gt;/bin/julia&lt;/code&gt; 、 &lt;code&gt;DATAROOTDIR&lt;/code&gt; の &lt;code&gt;../share&lt;/code&gt; 、および &lt;code&gt;SYSCONFDIR&lt;/code&gt; の &lt;code&gt;../etc&lt;/code&gt; があります &lt;code&gt;JULIA_BINDIR&lt;/code&gt; のにセットを &lt;code&gt;/bin&lt;/code&gt; に、のソース・ファイルの検索パス</target>
        </trans-unit>
        <trans-unit id="cb227b31f00d820f5d9d05405c8ad07604ce912a" translate="yes" xml:space="preserve">
          <source>For example, a recursive factorial routine could be defined like this:</source>
          <target state="translated">例えば、再帰的な階乗ルーチンは次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="a3ee27750c0b683e5c90895147928cfd59e22a42" translate="yes" xml:space="preserve">
          <source>For example, consider a function &lt;code&gt;plot&lt;/code&gt; that plots a line. This function might have many options, for controlling line style, width, color, and so on. If it accepts keyword arguments, a possible call might look like &lt;code&gt;plot(x, y, width=2)&lt;/code&gt;, where we have chosen to specify only line width. Notice that this serves two purposes. The call is easier to read, since we can label an argument with its meaning. It also becomes possible to pass any subset of a large number of arguments, in any order.</source>
          <target state="translated">たとえば、線をプロットする関数 &lt;code&gt;plot&lt;/code&gt; について考えます。この関数には、線のスタイル、幅、色などを制御するための多くのオプションがあります。キーワード引数を受け入れる場合、可能な呼び出しは &lt;code&gt;plot(x, y, width=2)&lt;/code&gt; ようになります。ここでは、線幅のみを指定することを選択しています。これには2つの目的があることに注意してください。引数にその意味のラベルを付けることができるので、呼び出しは読みやすくなります。また、多数の引数のサブセットを任意の順序で渡すことが可能になります。</target>
        </trans-unit>
        <trans-unit id="02796f85acf393569f8f018e6f896c1698a7ba0c" translate="yes" xml:space="preserve">
          <source>For example, consider the following definitions of a function &lt;code&gt;addone&lt;/code&gt; that returns one plus its argument:</source>
          <target state="translated">たとえば、1とその引数を返す関数 &lt;code&gt;addone&lt;/code&gt; の次の定義を考えてみます。</target>
        </trans-unit>
        <trans-unit id="8379ff1b045b6b8381b0fc1dcbd698daf2ddf0cf" translate="yes" xml:space="preserve">
          <source>For example, here is how we can guarantee that an opened file is closed:</source>
          <target state="translated">例えば、開かれたファイルが閉じられていることを保証する方法を以下に示します。</target>
        </trans-unit>
        <trans-unit id="49582067d66dec7b465ad077603d8140735bdbe0" translate="yes" xml:space="preserve">
          <source>For example, if you define a &lt;code&gt;MyImage&lt;/code&gt; type and know how to write it to a PNG file, you could define a function &lt;code&gt;show(io, ::MIME&quot;image/png&quot;, x::MyImage) = ...&lt;/code&gt; to allow your images to be displayed on any PNG-capable &lt;code&gt;AbstractDisplay&lt;/code&gt; (such as IJulia). As usual, be sure to &lt;code&gt;import Base.show&lt;/code&gt; in order to add new methods to the built-in Julia function &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;MyImage&lt;/code&gt; タイプを定義し、それをPNGファイルに書き込む方法を知っている場合、関数 &lt;code&gt;show(io, ::MIME&quot;image/png&quot;, x::MyImage) = ...&lt;/code&gt; を定義して、 PNG対応の &lt;code&gt;AbstractDisplay&lt;/code&gt; （IJuliaなど）に表示される画像。いつものように、組み込みのJulia関数 &lt;code&gt;show&lt;/code&gt; に新しいメソッドを追加するには、必ず &lt;code&gt;import Base.show&lt;/code&gt; をインポートしてください。</target>
        </trans-unit>
        <trans-unit id="2da1e2276f1c5c558883dab8cb5596d1bc2a1628" translate="yes" xml:space="preserve">
          <source>For example, say we define a type that stores a vector along with an accurate representation of its sum:</source>
          <target state="translated">例えば、ベクトルを格納し、その和を正確に表現する型を定義したとします。</target>
        </trans-unit>
        <trans-unit id="e2cfd2a7e3ca6e4481d092c3fbc0442d5a4ab757" translate="yes" xml:space="preserve">
          <source>For example, suppose one wants to declare a type that holds a pair of real numbers, subject to the constraint that the first number is not greater than the second one. One could declare it like this:</source>
          <target state="translated">例えば、実数のペアを保持する型を宣言したいとしますが、1つ目の数値が2つ目の数値より大きくないという制約があるとします。このように宣言することができます。</target>
        </trans-unit>
        <trans-unit id="79225a639e81658b4de8b5567b3dea63ac5abb4f" translate="yes" xml:space="preserve">
          <source>For example, suppose we want to check our new function &lt;code&gt;foo(x)&lt;/code&gt; works as expected:</source>
          <target state="translated">たとえば、新しい関数 &lt;code&gt;foo(x)&lt;/code&gt; が期待どおりに機能することを確認するとします。</target>
        </trans-unit>
        <trans-unit id="7eda6e477d1dd1d46e2cafc4f54477c6b2bb0e6a" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sqrt&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; functions can be composed like this:</source>
          <target state="translated">たとえば、 &lt;code&gt;sqrt&lt;/code&gt; 関数と &lt;code&gt;+&lt;/code&gt; 関数は次のように構成できます。</target>
        </trans-unit>
        <trans-unit id="5ae23a1c15837ee5f1ee5c9f54f1ec5adaf7300a" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sqrt&lt;/code&gt; function throws a &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; if applied to a negative real value:</source>
          <target state="translated">たとえば、 &lt;code&gt;sqrt&lt;/code&gt; 関数を負の実数値に適用すると、&lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; が&lt;/a&gt;スローされます。</target>
        </trans-unit>
        <trans-unit id="41fbcb24e42e9f837587084b7759fc106d92d27c" translate="yes" xml:space="preserve">
          <source>For example, the following code</source>
          <target state="translated">例えば、以下のコード</target>
        </trans-unit>
        <trans-unit id="df53f88b87089b5c188eb151fc2371ed97e5a8bd" translate="yes" xml:space="preserve">
          <source>For example, the following code will not work as intended:</source>
          <target state="translated">例えば、以下のコードは意図した通りには動作しません。</target>
        </trans-unit>
        <trans-unit id="dd2a7ac9bf39edcb33138e7083aee6d2163bed39" translate="yes" xml:space="preserve">
          <source>For example, the following definition supports the negation of ranges:</source>
          <target state="translated">例えば、以下の定義は範囲の否定をサポートしています。</target>
        </trans-unit>
        <trans-unit id="ebd9e6f4328ccf3da34436709427cc4b4eaab0c0" translate="yes" xml:space="preserve">
          <source>For example, the following regex has all three flags turned on:</source>
          <target state="translated">例えば、以下の正規表現では、3つのフラグがすべてオンになっています。</target>
        </trans-unit>
        <trans-unit id="f984e5cb891417962d09962040b3dc32bb1ac27e" translate="yes" xml:space="preserve">
          <source>For example, the following would cause the &lt;code&gt;for&lt;/code&gt; loop to wait for more data:</source>
          <target state="translated">たとえば、次の場合、 &lt;code&gt;for&lt;/code&gt; ループはさらにデータを待機します。</target>
        </trans-unit>
        <trans-unit id="f4ca40c2a3ba9787690378fb5f2aab689eee1052" translate="yes" xml:space="preserve">
          <source>For example, to read a simple byte array, we could do:</source>
          <target state="translated">例えば、単純なバイト配列を読み込むには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="8878c21d4c3068d1cd94e841b14239269912a492" translate="yes" xml:space="preserve">
          <source>For example, trying to dispatch on the element-type of an array will often run into ambiguous situations. Instead, commonly code will dispatch first on the container type, then recurse down to a more specific method based on eltype. In most cases, the algorithms lend themselves conveniently to this hierarchical approach, while in other cases, this rigor must be resolved manually. This dispatching branching can be observed, for example, in the logic to sum two matrices:</source>
          <target state="translated">例えば、配列の要素型でディスパッチしようとすると、曖昧な状況に陥ることがよくあります。その代わりに、一般的なコードでは、最初にコンテナ型に基づいてディスパッチし、その後、eltypeに基づいてより具体的なメソッドへと再帰することになります。ほとんどの場合、アルゴリズムはこのような階層的なアプローチに便利に対応していますが、他のケースではこの厳密さを手動で解決しなければなりません。このディスパッチ分岐は、例えば、2つの行列を合計するロジックで観察することができます。</target>
        </trans-unit>
        <trans-unit id="b2c13e0b4d2254aa0c6b075c4f699f03e1e4085d" translate="yes" xml:space="preserve">
          <source>For example, two vectors &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; of the same length can be written as two columns of tab-delimited text to &lt;code&gt;f&lt;/code&gt; by either &lt;code&gt;writedlm(f, [x y])&lt;/code&gt; or by &lt;code&gt;writedlm(f, zip(x, y))&lt;/code&gt;.</source>
          <target state="translated">たとえば、同じ長さの2つのベクトル &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は、 &lt;code&gt;writedlm(f, [x y])&lt;/code&gt; または &lt;code&gt;writedlm(f, zip(x, y))&lt;/code&gt; いずれかによって、タブ区切りテキストの2つの列として &lt;code&gt;f&lt;/code&gt; に書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="20b7a39286391fad09a5ff705ae3bda829227952" translate="yes" xml:space="preserve">
          <source>For example, when reading all of the output from a command, call &lt;code&gt;read(out, String)&lt;/code&gt;, not &lt;code&gt;wait(process)&lt;/code&gt;, since the former will actively consume all of the data written by the process, whereas the latter will attempt to store the data in the kernel's buffers while waiting for a reader to be connected.</source>
          <target state="translated">たとえば、コマンドからすべての出力を読み取る場合は、 &lt;code&gt;wait(process)&lt;/code&gt; ではなく &lt;code&gt;read(out, String)&lt;/code&gt; 呼び出します。前者はプロセスによって書き込まれたすべてのデータをアクティブに消費し、後者はプロセスに保存しようとするためです。リーダーが接続されるのを待っている間のカーネルのバッファ内のデータ。</target>
        </trans-unit>
        <trans-unit id="5029745bd6486130a24ba078811879e64132c558" translate="yes" xml:space="preserve">
          <source>For example, you can define a type that stores the coefficients of a polynomial, but behaves like a function evaluating the polynomial:</source>
          <target state="translated">例えば、多項式の係数を格納し、多項式を評価する関数のように振る舞う型を定義することができます。</target>
        </trans-unit>
        <trans-unit id="67f058df3da112643c2b0a1dfa02199be4e0057b" translate="yes" xml:space="preserve">
          <source>For example, you might look up the function via &lt;code&gt;dlsym&lt;/code&gt;, then cache it in a shared reference for that session. For example:</source>
          <target state="translated">たとえば、関数を &lt;code&gt;dlsym&lt;/code&gt; で検索し、そのセッションの共有参照にキャッシュすることができます。例えば：</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="77957bacdf57512b4372bd5a4e3fd7ed75c7e36e" translate="yes" xml:space="preserve">
          <source>For expert drivers and additional information, see &lt;code&gt;permute!&lt;/code&gt;.</source>
          <target state="translated">エキスパートドライバーと追加情報については、 &lt;code&gt;permute!&lt;/code&gt; 参照してください。。</target>
        </trans-unit>
        <trans-unit id="023517bc66d9d3e180b498d61c21e401d08d2db9" translate="yes" xml:space="preserve">
          <source>For file dependencies, a change is determined by examining whether the modification time (mtime) of each file loaded by &lt;code&gt;include&lt;/code&gt; or added explicitly by &lt;code&gt;include_dependency&lt;/code&gt; is unchanged, or equal to the modification time truncated to the nearest second (to accommodate systems that can't copy mtime with sub-second accuracy). It also takes into account whether the path to the file chosen by the search logic in &lt;code&gt;require&lt;/code&gt; matches the path that had created the precompile file. It also takes into account the set of dependencies already loaded into the current process and won't recompile those modules, even if their files change or disappear, in order to avoid creating incompatibilities between the running system and the precompile cache.</source>
          <target state="translated">ファイルの依存関係の場合、変更は、 &lt;code&gt;include&lt;/code&gt; によってロードされた、または &lt;code&gt;include_dependency&lt;/code&gt; によって明示的に追加された各ファイルの変更時間（mtime）が変更されていないか、変更時間と最も近い秒に切り捨てられたか（システムに対応できないため） 1秒未満の精度でmtimeをコピーします）。また、 &lt;code&gt;require&lt;/code&gt; で検索ロジックによって選択されたファイルへのパスが、プリコンパイルファイルを作成したパスと一致するかどうかも考慮します。また、実行中のシステムとプリコンパイルキャッシュの間の非互換性の作成を回避するために、現在のプロセスに既に読み込まれている依存関係のセットを考慮し、ファイルが変更または消失した場合でも、それらのモジュールを再コンパイルしません。</target>
        </trans-unit>
        <trans-unit id="66dd55e20f602bb211d9c7813d2f9f0ed6928fe9" translate="yes" xml:space="preserve">
          <source>For fixed-size integer types less than 128 bits, &lt;code&gt;widen&lt;/code&gt; will return a type with twice the number of bits.</source>
          <target state="translated">128ビット未満の固定サイズの整数型の場合、 &lt;code&gt;widen&lt;/code&gt; はビット数の2倍の型を返します。</target>
        </trans-unit>
        <trans-unit id="517d5d95b2398e36f4828f9d104f02ccf187deee" translate="yes" xml:space="preserve">
          <source>For functions &lt;code&gt;f(x)&lt;/code&gt;, &lt;code&gt;f(x) = x&lt;/code&gt; defines a new function constant &lt;code&gt;f&lt;/code&gt;, or adds a new method to &lt;code&gt;f&lt;/code&gt; if &lt;code&gt;f&lt;/code&gt; is already defined; this usage is equivalent to &lt;code&gt;function f(x); x; end&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;f(x)&lt;/code&gt; の場合、 &lt;code&gt;f(x) = x&lt;/code&gt; は新しい関数定数 &lt;code&gt;f&lt;/code&gt; を定義するか、 &lt;code&gt;f&lt;/code&gt; がすでに定義されている場合は新しいメソッドを &lt;code&gt;f&lt;/code&gt; に追加します。この使用法は &lt;code&gt;function f(x); x; end&lt;/code&gt; と同等です。バツ; 終わり。</target>
        </trans-unit>
        <trans-unit id="6a6abe0e3a65b8ed9f51c340da311967dd300c9c" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw add&lt;/code&gt; instruction.</source>
          <target state="translated">詳細については、LLVMの &lt;code&gt;atomicrmw add&lt;/code&gt; 命令を参照してください。</target>
        </trans-unit>
        <trans-unit id="a0322dcf17161d23047710cc59f3f8e235c18a53" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw and&lt;/code&gt; instruction.</source>
          <target state="translated">詳細については、LLVMの &lt;code&gt;atomicrmw and&lt;/code&gt; 命令を参照してください。</target>
        </trans-unit>
        <trans-unit id="e5b561d9fc0067e467e9e9fcee46e3023283cf28" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw max&lt;/code&gt; instruction.</source>
          <target state="translated">詳細については、LLVMの &lt;code&gt;atomicrmw max&lt;/code&gt; 命令を参照してください。</target>
        </trans-unit>
        <trans-unit id="eab5683b8c3c9bc6117f8a69b4da87aa9632a8fb" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw min&lt;/code&gt; instruction.</source>
          <target state="translated">詳細については、LLVMの &lt;code&gt;atomicrmw min&lt;/code&gt; 命令を参照してください。</target>
        </trans-unit>
        <trans-unit id="7b7e08b7890af600321c511f13a806cd3559bcfa" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw nand&lt;/code&gt; instruction.</source>
          <target state="translated">詳細については、LLVMの &lt;code&gt;atomicrmw nand&lt;/code&gt; 命令を参照してください。</target>
        </trans-unit>
        <trans-unit id="7b8dd1c376a179e2ba56074f5563e776f17ef9ec" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw or&lt;/code&gt; instruction.</source>
          <target state="translated">詳細については、LLVMの &lt;code&gt;atomicrmw or&lt;/code&gt; 命令を参照してください。</target>
        </trans-unit>
        <trans-unit id="48c1004b7dffe90355657654366824768f35001b" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw sub&lt;/code&gt; instruction.</source>
          <target state="translated">詳細については、LLVMの &lt;code&gt;atomicrmw sub&lt;/code&gt; 命令を参照してください。</target>
        </trans-unit>
        <trans-unit id="192e95dde72a6e68d2db267b6ee138cf37555d73" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw xchg&lt;/code&gt; instruction.</source>
          <target state="translated">詳細については、LLVMの &lt;code&gt;atomicrmw xchg&lt;/code&gt; 命令を参照してください。</target>
        </trans-unit>
        <trans-unit id="5e4b67df501ae8428fb22d5e33af878bfbea1ef9" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw xor&lt;/code&gt; instruction.</source>
          <target state="translated">詳細については、LLVMの &lt;code&gt;atomicrmw xor&lt;/code&gt; 命令を参照してください。</target>
        </trans-unit>
        <trans-unit id="7ee314d2ce6ee192109b08f74bbfd48cbb0e5cbc" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;cmpxchg&lt;/code&gt; instruction.</source>
          <target state="translated">詳細については、LLVMの &lt;code&gt;cmpxchg&lt;/code&gt; 命令を参照してください。</target>
        </trans-unit>
        <trans-unit id="a7755edb4519e4536a6271c13a954434e48a3388" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;fence&lt;/code&gt; instruction.</source>
          <target state="translated">詳細については、LLVMの &lt;code&gt;fence&lt;/code&gt; 命令を参照してください。</target>
        </trans-unit>
        <trans-unit id="592e1ef0cc917b2ef533393d9872f216dc5c373c" translate="yes" xml:space="preserve">
          <source>For further discussion of how these non-finite floating-point values are ordered with respect to each other and other floats, see &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;Numeric Comparisons&lt;/a&gt;. By the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;, these floating-point values are the results of certain arithmetic operations:</source>
          <target state="translated">これらの非有限の浮動小数点値が互いに、および他の浮動小数点に対してどのように順序付けられるかについての詳細は、&lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;数値比較を&lt;/a&gt;参照してください。&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754標準&lt;/a&gt;により、これらの浮動小数点値は特定の算術演算の結果です。</target>
        </trans-unit>
        <trans-unit id="f6a5e306e2388b19948e17b05f28ec9cf0f8d86c" translate="yes" xml:space="preserve">
          <source>For general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvalue calculation. The &lt;code&gt;permute&lt;/code&gt;, &lt;code&gt;scale&lt;/code&gt;, and &lt;code&gt;sortby&lt;/code&gt; keywords are the same as for &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt;&lt;code&gt;eigen!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一般的な非対称行列の場合、固有値を計算する前に行列のバランスを指定することができます。 &lt;code&gt;permute&lt;/code&gt; 、 &lt;code&gt;scale&lt;/code&gt; 、および &lt;code&gt;sortby&lt;/code&gt; キーワードはと同じである&lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt; &lt;code&gt;eigen!&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a3464000c64f9602c239ac8ef54cb51f0375c94" translate="yes" xml:space="preserve">
          <source>For general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option &lt;code&gt;permute=true&lt;/code&gt; permutes the matrix to become closer to upper triangular, and &lt;code&gt;scale=true&lt;/code&gt; scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is &lt;code&gt;true&lt;/code&gt; for both options.</source>
          <target state="translated">一般的な非対称行列の場合、固有ベクトル計算の前に行列のバランスを指定することができます。オプション &lt;code&gt;permute=true&lt;/code&gt; は行列を上三角に近づけるように並べ替え、 &lt;code&gt;scale=true&lt;/code&gt; は行列を対角要素でスケーリングして、行と列のノルムをより等しくします。両方のオプションのデフォルトは &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="97272f75bb7bf420f1c0e8253e48bdca2d0549a3" translate="yes" xml:space="preserve">
          <source>For general square matrices, &lt;code&gt;A = A*B&lt;/code&gt; cannot be implemented without temporary storage: &lt;code&gt;A[1,1]&lt;/code&gt; gets computed and stored on the left hand side before you're done using it on the right hand side.</source>
          <target state="translated">一般的な正方行列の場合、 &lt;code&gt;A = A*B&lt;/code&gt; は一時的なストレージなしでは実装できません &lt;code&gt;A[1,1]&lt;/code&gt; は、右側で使用する前に左側で計算されて保存されます。</target>
        </trans-unit>
        <trans-unit id="935a8c2e4f251a5770a2bb608ecff08833dd9c32" translate="yes" xml:space="preserve">
          <source>For global variables, only the bindings are captured in a closure, not the data. &lt;code&gt;let&lt;/code&gt; blocks can be used to capture global data.</source>
          <target state="translated">グローバル変数の場合、バインディングではデータではなくバインディングのみがキャプチャされます。 &lt;code&gt;let&lt;/code&gt; ブロックを使用してグローバルデータをキャプチャできます。</target>
        </trans-unit>
        <trans-unit id="e5b2b73939c9dca143b01d277fa950512fdcf9e4" translate="yes" xml:space="preserve">
          <source>For implementing primitive operations, such as addition, we use the &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt; function to compute the desired output type. (As before, we saw this at work in the &lt;code&gt;promote&lt;/code&gt; call in the call to &lt;code&gt;+&lt;/code&gt;).</source>
          <target state="translated">加算などの基本操作を実装するために、&lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt;関数を使用して目的の出力タイプを計算します。（以前のように、これは &lt;code&gt;+&lt;/code&gt; への呼び出しの &lt;code&gt;promote&lt;/code&gt; 呼び出しで機能していることがわかりました）。</target>
        </trans-unit>
        <trans-unit id="9bbc05f37cbd2b5498a3ab3a593a156112a8c55d" translate="yes" xml:space="preserve">
          <source>For instance, consider this C routine that uses AVX intrinsics:</source>
          <target state="translated">例えば、AVX の内部構造を使用する次の C ルーチンを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="58f3adf26ef93227d12186ad90763f386c1243e3" translate="yes" xml:space="preserve">
          <source>For inverting dense ill-conditioned matrices in a least-squares sense, &lt;code&gt;rtol = sqrt(eps(real(float(one(eltype(M))))))&lt;/code&gt; is recommended.</source>
          <target state="translated">最小二乗の意味で密な悪条件の行列を反転するには、 &lt;code&gt;rtol = sqrt(eps(real(float(one(eltype(M))))))&lt;/code&gt; をお勧めします。</target>
        </trans-unit>
        <trans-unit id="3476b291492f6f31f8c69709d348f023db79ecb7" translate="yes" xml:space="preserve">
          <source>For many problems, it is not necessary to think about tasks directly. However, they can be used to wait for multiple events at the same time, which provides for &lt;em&gt;dynamic scheduling&lt;/em&gt;. In dynamic scheduling, a program decides what to compute or where to compute it based on when other jobs finish. This is needed for unpredictable or unbalanced workloads, where we want to assign more work to processes only when they finish their current tasks.</source>
          <target state="translated">多くの問題では、タスクについて直接考える必要はありません。ただし、これらを使用して、同時に複数のイベントを待機することができ&lt;em&gt;ます&lt;/em&gt;。これにより、&lt;em&gt;動的スケジューリングが可能になります&lt;/em&gt;。動的スケジューリングでは、プログラムは、他のジョブがいつ終了するかに基づいて、何を計算するか、またはどこに計算するかを決定します。これは、プロセスが現在のタスクを完了したときにのみ、より多くの作業をプロセスに割り当てたい、予測不能または不均衡なワークロードに必要です。</target>
        </trans-unit>
        <trans-unit id="7f0ae2a2524af9d24fc01426df34e4e2c47f07b3" translate="yes" xml:space="preserve">
          <source>For many types, forming new objects by binding their field values together is all that is ever needed to create instances. However, in some cases more functionality is required when creating composite objects. Sometimes invariants must be enforced, either by checking arguments or by transforming them. &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29&quot;&gt;Recursive data structures&lt;/a&gt;, especially those that may be self-referential, often cannot be constructed cleanly without first being created in an incomplete state and then altered programmatically to be made whole, as a separate step from object creation. Sometimes, it's just convenient to be able to construct objects with fewer or different types of parameters than they have fields. Julia's system for object construction addresses all of these cases and more.</source>
          <target state="translated">多くのタイプでは、フィールド値をバインドして新しいオブジェクトを形成するだけで、インスタンスを作成できます。ただし、複合オブジェクトを作成するときに、より多くの機能が必要になる場合があります。不変条件は、引数をチェックするか、引数を変換することによって、強制する必要がある場合があります。&lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29&quot;&gt;再帰的データ構造&lt;/a&gt;、特に自己参照型のデータ構造は、オブジェクトの作成とは別のステップとして、最初に不完全な状態で作成し、プログラムで変更して全体を作成しないと、きれいに構築できないことがよくあります。場合によっては、フィールドよりも少ないまたは異なるタイプのパラメーターでオブジェクトを作成できると便利なことがあります。ジュリアのオブジェクト構築システムは、これらすべてのケースに対処します。</target>
        </trans-unit>
        <trans-unit id="c3ab9fc4f4873966145fee9c6ac1a9124f310742" translate="yes" xml:space="preserve">
          <source>For matrices &lt;code&gt;M&lt;/code&gt; with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values greater than &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; where &lt;code&gt;&amp;sigma;₁&lt;/code&gt; is the largest singular value of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">浮動小数点要素をもつ行列 &lt;code&gt;M&lt;/code&gt; の場合、 &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; より大きい特異値のみを反転することにより疑似逆行列を計算すると便利です。ここで、 &lt;code&gt;&amp;sigma;₁&lt;/code&gt; は &lt;code&gt;M&lt;/code&gt; の最大特異値です。</target>
        </trans-unit>
        <trans-unit id="ac6da235d612ded03083200d47fe1ab7d98c9b79" translate="yes" xml:space="preserve">
          <source>For more complex functions on matrices, it may be necessary to compute the expected return type for a more complex sequence of operations. This is often performed by the following steps:</source>
          <target state="translated">行列上のより複雑な関数の場合,より複雑な操作のシーケンスに対して期待される戻り値の型を計算する必要があるかもしれません.これは多くの場合、以下の手順で実行されます。</target>
        </trans-unit>
        <trans-unit id="4017330d0c6b8db2f9072cd10c06aafbef3ef320" translate="yes" xml:space="preserve">
          <source>For more details on how to pass callbacks to C libraries, see this &lt;a href=&quot;https://julialang.org/blog/2013/05/callback&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">Cライブラリにコールバックを渡す方法の詳細については、この&lt;a href=&quot;https://julialang.org/blog/2013/05/callback&quot;&gt;ブログ投稿を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f4e7422368e9880e43d73e7cf711179bdaf3a6a3" translate="yes" xml:space="preserve">
          <source>For more details regarding code loading, see the manual sections on &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../../manual/parallel-computing/index#code-availability-1&quot;&gt;parallel computing&lt;/a&gt;.</source>
          <target state="translated">コードの読み込みの詳細については、&lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;モジュール&lt;/a&gt;と&lt;a href=&quot;../../manual/parallel-computing/index#code-availability-1&quot;&gt;並列計算&lt;/a&gt;に関するマニュアルセクションをご覧ください。</target>
        </trans-unit>
        <trans-unit id="825f5736599d7832ed10460cda99264a6faea4e6" translate="yes" xml:space="preserve">
          <source>For more information about stylistic conventions, see the &lt;a href=&quot;../style-guide/index#Style-Guide-1&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="translated">文体規則の詳細については、「&lt;a href=&quot;../style-guide/index#Style-Guide-1&quot;&gt;スタイルガイド」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="29a5a734cc9600ff863c3e949c6ca0cd3d61e836" translate="yes" xml:space="preserve">
          <source>For more information, please see the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#calling-conventions&quot;&gt;LLVM Language Reference&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;http://llvm.org/docs/LangRef.html#calling-conventions&quot;&gt;LLVM言語リファレンス&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e94367c7326944c925932ccd75ddf09b0dc2a2ca" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;#footnote-issue8859&quot;&gt;[issue8859]&lt;/a&gt;, &lt;a href=&quot;#footnote-B96&quot;&gt;[B96]&lt;/a&gt;, &lt;a href=&quot;#footnote-S84&quot;&gt;[S84]&lt;/a&gt;, &lt;a href=&quot;#footnote-KY88&quot;&gt;[KY88]&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;#footnote-issue8859&quot;&gt;[issue8859]&lt;/a&gt;、&lt;a href=&quot;#footnote-B96&quot;&gt;[B96]&lt;/a&gt;、&lt;a href=&quot;#footnote-S84&quot;&gt;[S84]&lt;/a&gt;、&lt;a href=&quot;#footnote-KY88&quot;&gt;[KY88]を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78c9da6d7f9a8088ccb6c5228fbbc41a8fd90ece" translate="yes" xml:space="preserve">
          <source>For more serious benchmarking, consider the &lt;a href=&quot;https://github.com/JuliaCI/BenchmarkTools.jl&quot;&gt;BenchmarkTools.jl&lt;/a&gt; package which among other things evaluates the function multiple times in order to reduce noise.</source>
          <target state="translated">より深刻なベンチマークについては、特にノイズを減らすために関数を複数回評価する&lt;a href=&quot;https://github.com/JuliaCI/BenchmarkTools.jl&quot;&gt;BenchmarkTools.jl&lt;/a&gt;パッケージを検討してください。</target>
        </trans-unit>
        <trans-unit id="88557b99f2da7edd1312dcf73383bf3fd839d0cf" translate="yes" xml:space="preserve">
          <source>For most user-defined types, it is better practice to require programmers to supply the expected types to constructor functions explicitly, but sometimes, especially for numeric problems, it can be convenient to do promotion automatically.</source>
          <target state="translated">ほとんどのユーザ定義型については、プログラマがコンストラクタ関数に期待される型を明示的に提供することを要求するのが良い方法ですが、特に数値問題の場合には、自動的に昇格させた方が便利な場合もあります。</target>
        </trans-unit>
        <trans-unit id="ceb4f91d41747de4680e86cde1985bd3bfc38e4e" translate="yes" xml:space="preserve">
          <source>For multiple collection arguments, apply &lt;code&gt;f&lt;/code&gt; elementwise.</source>
          <target state="translated">複数のコレクション引数の場合、 &lt;code&gt;f&lt;/code&gt; を要素ごとに適用します。</target>
        </trans-unit>
        <trans-unit id="ea75a21c84d373ef04e66eb8c0a6a1bc5cc64258" translate="yes" xml:space="preserve">
          <source>For newcomers to multi-threading and parallel computing it can be useful to first appreciate the different levels of parallelism offered by Julia. We can divide them in three main categories :</source>
          <target state="translated">マルチスレッドや並列計算を初めて体験する人にとって、Julia が提供するさまざまなレベルの並列性をまず理解することは有益です。これらを3つの主要なカテゴリに分けることができます。</target>
        </trans-unit>
        <trans-unit id="ac8a874fecbfe223b7adee365914ddd8f5f53622" translate="yes" xml:space="preserve">
          <source>For non-numeric values, and for fewer or more than two arguments, the function &lt;code&gt;f&lt;/code&gt; remains undefined, and applying it will still result in a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">数値以外の値、および引数が3つ以下の場合、関数 &lt;code&gt;f&lt;/code&gt; は未定義のままであり、関数を適用しても&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; になり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="235d743e9d754b970eea4778b2f329bcad575d20" translate="yes" xml:space="preserve">
          <source>For numbers, return $\left( |x|^p \right)^{1/p}$.</source>
          <target state="translated">数字の場合は、$\left(|x|^p \right)^{1/p}$を返します。</target>
        </trans-unit>
        <trans-unit id="00b6eae180d5b268722ff406a9cc534055692e79" translate="yes" xml:space="preserve">
          <source>For numbers, return $\left( |x|^p \right)^{1/p}$. This is equivalent to &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">数値の場合、$ \ left（| x | ^ p \ right）^ {1 / p} $を返します。これは&lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; &lt;/a&gt;と同等です。</target>
        </trans-unit>
        <trans-unit id="d4f585a8f761ded66238973d0a20da01f3603d93" translate="yes" xml:space="preserve">
          <source>For one argument, this is the angle in radians between the positive &lt;em&gt;x&lt;/em&gt;-axis and the point (1, &lt;em&gt;y&lt;/em&gt;), returning a value in the interval $[-\pi/2, \pi/2]$.</source>
          <target state="translated">1つの引数の場合、これは正の&lt;em&gt;x&lt;/em&gt;軸と点（1、&lt;em&gt;y&lt;/em&gt;）の間のラジアン単位の角度であり、$ [-\ pi / 2、\ pi / 2] $の間隔で値を返します。</target>
        </trans-unit>
        <trans-unit id="cbe3a2c9ed0456d9a3ed109f08314c90a9a6e71e" translate="yes" xml:space="preserve">
          <source>For other types, &lt;code&gt;isequal&lt;/code&gt; defaults to calling &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;, so if you want to define equality for your own types then you only need to add a &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; method. If you define your own equality function, you should probably define a corresponding &lt;a href=&quot;../../base/base/index#Base.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt; method to ensure that &lt;code&gt;isequal(x,y)&lt;/code&gt; implies &lt;code&gt;hash(x) == hash(y)&lt;/code&gt;.</source>
          <target state="translated">他のタイプの場合、デフォルトでは &lt;code&gt;isequal&lt;/code&gt; は&lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt;を呼び出すため、独自のタイプの等価性を定義する場合は、&lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt;メソッドを追加するだけで済みます。独自の等価関数を定義する場合は、対応する&lt;a href=&quot;../../base/base/index#Base.hash&quot;&gt; &lt;code&gt;hash&lt;/code&gt; &lt;/a&gt;メソッドを定義して、 &lt;code&gt;isequal(x,y)&lt;/code&gt; が &lt;code&gt;hash(x) == hash(y)&lt;/code&gt; 意味することを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="3c2f4b9050307c80e2b4e5b109845a6af03029a8" translate="yes" xml:space="preserve">
          <source>For real or complex floating-point values, if an &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; is not specified, &lt;code&gt;rtol&lt;/code&gt; defaults to the square root of &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the type of &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;, whichever is bigger (least precise). This corresponds to requiring equality of about half of the significand digits. Otherwise, e.g. for integer arguments or if an &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; is supplied, &lt;code&gt;rtol&lt;/code&gt; defaults to zero.</source>
          <target state="translated">実数または複素数の浮動小数点値の場合、 &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; が指定されていないと、 &lt;code&gt;rtol&lt;/code&gt; はデフォルトで &lt;code&gt;x&lt;/code&gt; または &lt;code&gt;y&lt;/code&gt; のタイプの&lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt;の平方根のどちらか大きい方（正確度が低い方）になります。これは、有効数字の約半分の同等性を要求することに対応します。それ以外の場合、たとえば整数引数の場合、または &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; が指定されている場合、 &lt;code&gt;rtol&lt;/code&gt; はデフォルトでゼロになります。</target>
        </trans-unit>
        <trans-unit id="d58b65ff0e6e435abbaf14887e067d0c31d3520b" translate="yes" xml:space="preserve">
          <source>For reasons of length the results are not shown here, but you may wish to try this yourself. Because the type is fully-specified in the first case, the compiler doesn't need to generate any code to resolve the type at run-time. This results in shorter and faster code.</source>
          <target state="translated">長くなるのでここでは結果を示しませんが、ご自身で試してみてはいかがでしょうか。最初のケースでは型が完全に指定されているため、コンパイラは実行時に型を解決するコードを生成する必要がありません。その結果、コードが短く、速くなります。</target>
        </trans-unit>
        <trans-unit id="6fc874bd7cd4d5b9abffad50a8cc5e9ee8fcd173" translate="yes" xml:space="preserve">
          <source>For rectangular &lt;code&gt;A&lt;/code&gt; the result is the minimum-norm least squares solution computed by a pivoted QR factorization of &lt;code&gt;A&lt;/code&gt; and a rank estimate of &lt;code&gt;A&lt;/code&gt; based on the R factor.</source>
          <target state="translated">長方形のための &lt;code&gt;A&lt;/code&gt; の結果は、枢支QR因数分解することによって計算された最小ノルム最小二乗解である &lt;code&gt;A&lt;/code&gt; とのランク推定値 &lt;code&gt;A&lt;/code&gt; Rファクタに基づきます。</target>
        </trans-unit>
        <trans-unit id="912d3fe9f2697c548ca0705aab244457023707b1" translate="yes" xml:space="preserve">
          <source>For simple functions, it is often clearer to mention the role of the arguments directly in the description of the function's purpose. An argument list would only repeat information already provided elsewhere. However, providing an argument list can be a good idea for complex functions with many arguments (in particular keyword arguments). In that case, insert it after the general description of the function, under an &lt;code&gt;# Arguments&lt;/code&gt; header, with one &lt;code&gt;-&lt;/code&gt; bullet for each argument. The list should mention the types and default values (if any) of the arguments:</source>
          <target state="translated">単純な関数の場合、関数の目的の説明で引数の役割を直接説明する方が明確な場合がよくあります。引数リストは、他の場所ですでに提供されている情報のみを繰り返します。ただし、引数リストを提供することは、多くの引数（特にキーワード引数）を含む複雑な関数の場合に適しています。その場合は、関数の一般的な説明の後に、 &lt;code&gt;# Arguments&lt;/code&gt; ヘッダーの下に、引数ごとに1つ &lt;code&gt;-&lt;/code&gt; 箇条書きを挿入します。リストには、引数のタイプとデフォルト値（ある場合）を記載する必要があります。</target>
        </trans-unit>
        <trans-unit id="1ea7196a777e8e9b741754a756a982ecdc4df126" translate="yes" xml:space="preserve">
          <source>For simple index types, it defers to the unexported &lt;code&gt;Base.to_index(A, i)&lt;/code&gt; to process each index &lt;code&gt;i&lt;/code&gt;. While this internal function is not intended to be called directly, &lt;code&gt;Base.to_index&lt;/code&gt; may be extended by custom array or index types to provide custom indexing behaviors.</source>
          <target state="translated">単純なインデックスタイプの場合、各インデックス &lt;code&gt;i&lt;/code&gt; を処理するために、エクスポートされていない &lt;code&gt;Base.to_index(A, i)&lt;/code&gt; に従います。この内部関数は直接呼び出されることを意図していませんが、 &lt;code&gt;Base.to_index&lt;/code&gt; はカスタム配列またはカスタムインデックスタイプによって拡張され、カスタムインデックス動作を提供します。</target>
        </trans-unit>
        <trans-unit id="53b19a276cd1b474618ba84687e1e90b947ee82e" translate="yes" xml:space="preserve">
          <source>For situations where a value &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; exists only sometimes, the &lt;code&gt;Union{T, Nothing}&lt;/code&gt; type can be used for function arguments, object fields and array element types as the equivalent of &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt;&lt;code&gt;Nullable&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;&lt;/a&gt; in other languages. If the value itself can be &lt;code&gt;nothing&lt;/code&gt; (notably, when &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Any&lt;/code&gt;), the &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; type is more appropriate since &lt;code&gt;x == nothing&lt;/code&gt; then indicates the absence of a value, and &lt;code&gt;x == Some(nothing)&lt;/code&gt; indicates the presence of a value equal to &lt;code&gt;nothing&lt;/code&gt;. The &lt;a href=&quot;../../base/base/index#Base.something&quot;&gt;&lt;code&gt;something&lt;/code&gt;&lt;/a&gt; function allows unwrapping &lt;code&gt;Some&lt;/code&gt; objects and using a default value instead of &lt;code&gt;nothing&lt;/code&gt; arguments. Note that the compiler is able to generate efficient code when working with &lt;code&gt;Union{T, Nothing}&lt;/code&gt; arguments or fields.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; の値 &lt;code&gt;x&lt;/code&gt; がたまにしか存在しない状況では、 &lt;code&gt;Union{T, Nothing}&lt;/code&gt; タイプを関数の引数、オブジェクトフィールド、および配列要素タイプに、他の言語の&lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt; &lt;code&gt;Nullable&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;Option&lt;/code&gt; または &lt;code&gt;Maybe&lt;/code&gt; に相当するものとして使用できます。値自体が &lt;code&gt;nothing&lt;/code&gt; 場合（特に &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Any&lt;/code&gt; の場合）は、 &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; タイプの方が適切です。これは、 &lt;code&gt;x == nothing&lt;/code&gt; 値がないことを示し、 &lt;code&gt;x == Some(nothing)&lt;/code&gt; に等しい値の存在を示して &lt;code&gt;nothing&lt;/code&gt; 。&lt;a href=&quot;../../base/base/index#Base.something&quot;&gt; &lt;code&gt;something&lt;/code&gt; &lt;/a&gt;関数は、 &lt;code&gt;Some&lt;/code&gt; オブジェクトのラップを解除し、引数 &lt;code&gt;nothing&lt;/code&gt; 代わりにデフォルト値を使用できます。コンパイラは、 &lt;code&gt;Union{T, Nothing}&lt;/code&gt; 引数またはフィールドを操作するときに効率的なコードを生成できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="43a7de4a7810165537aadc6250e15a8a55f9a88d" translate="yes" xml:space="preserve">
          <source>For some types which &quot;wrap&quot; other values, the constructor may wrap its argument inside a new object even if it is already of the requested type. For example &lt;code&gt;Some(x)&lt;/code&gt; wraps &lt;code&gt;x&lt;/code&gt; to indicate that a value is present (in a context where the result might be a &lt;code&gt;Some&lt;/code&gt; or &lt;code&gt;nothing&lt;/code&gt;). However, &lt;code&gt;x&lt;/code&gt; itself might be the object &lt;code&gt;Some(y)&lt;/code&gt;, in which case the result is &lt;code&gt;Some(Some(y))&lt;/code&gt;, with two levels of wrapping. &lt;code&gt;convert(Some, x)&lt;/code&gt;, on the other hand, would just return &lt;code&gt;x&lt;/code&gt; since it is already a &lt;code&gt;Some&lt;/code&gt;.</source>
          <target state="translated">他の値を「ラップ」するタイプの場合、コンストラクターは、要求されたタイプであっても、その引数を新しいオブジェクト内にラップする場合があります。たとえば、 &lt;code&gt;Some(x)&lt;/code&gt; は &lt;code&gt;x&lt;/code&gt; をラップして、値が存在することを示します（結果が &lt;code&gt;Some&lt;/code&gt; または &lt;code&gt;nothing&lt;/code&gt; 可能性があるコンテキスト内）。ただし、 &lt;code&gt;x&lt;/code&gt; 自体がオブジェクト &lt;code&gt;Some(y)&lt;/code&gt; である場合があります。その場合、結果は &lt;code&gt;Some(Some(y))&lt;/code&gt; になり、2つのレベルのラッピングが行われます。一方、 &lt;code&gt;convert(Some, x)&lt;/code&gt; 、すでに &lt;code&gt;Some&lt;/code&gt; であるため、 &lt;code&gt;x&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="47046f98397f6383243a7899dc2654cd12e6fb38" translate="yes" xml:space="preserve">
          <source>For some types, the machinery to &quot;fuse&quot; operations across nested levels of broadcasting is not available or could be done more efficiently incrementally. In such cases, you may need or want to evaluate &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; as if it had been written &lt;code&gt;broadcast(*, x, broadcast(+, x, 1))&lt;/code&gt;, where the inner operation is evaluated before tackling the outer operation. This sort of eager operation is directly supported by a bit of indirection; instead of directly constructing &lt;code&gt;Broadcasted&lt;/code&gt; objects, Julia lowers the fused expression &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; to &lt;code&gt;Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1))&lt;/code&gt;. Now, by default, &lt;code&gt;broadcasted&lt;/code&gt; just calls the &lt;code&gt;Broadcasted&lt;/code&gt; constructor to create the lazy representation of the fused expression tree, but you can choose to override it for a particular combination of function and arguments.</source>
          <target state="translated">一部のタイプでは、ネストされたレベルのブロードキャスト全体で操作を「融合」するメカニズムが利用できないか、段階的に効率的に実行できます。このような場合、 &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; をBroadcast &lt;code&gt;broadcast(*, x, broadcast(+, x, 1))&lt;/code&gt; と記述した場合と同様に評価する必要があるか、または評価する必要があります。外部操作。この種の熱心な操作は、少しの間接参照によって直接サポートされています。Juliaは &lt;code&gt;Broadcasted&lt;/code&gt; オブジェクトを直接作成する代わりに、融合式 &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; を &lt;code&gt;Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1))&lt;/code&gt; 下げます。さて、デフォルトでは、 &lt;code&gt;broadcasted&lt;/code&gt; だけで呼び出す &lt;code&gt;Broadcasted&lt;/code&gt; 融合式ツリーの遅延表現を作成するコンストラクター。ただし、関数と引数の特定の組み合わせに対してそれをオーバーライドすることを選択できます。</target>
        </trans-unit>
        <trans-unit id="08e1dce6d1b843106b2d04dbdc79c4bf75d54149" translate="yes" xml:space="preserve">
          <source>For specializing broadcast on custom types, see</source>
          <target state="translated">カスタムタイプに特化した放送については</target>
        </trans-unit>
        <trans-unit id="063287ad264bebc20a42dfa1890ff52805f2bb2c" translate="yes" xml:space="preserve">
          <source>For string arguments (&lt;code&gt;char*&lt;/code&gt;) the Julia type should be &lt;code&gt;Cstring&lt;/code&gt; (if NUL- terminated data is expected) or either &lt;code&gt;Ptr{Cchar}&lt;/code&gt; or &lt;code&gt;Ptr{UInt8}&lt;/code&gt; otherwise (these two pointer types have the same effect), as described above, not &lt;code&gt;String&lt;/code&gt;. Similarly, for array arguments (&lt;code&gt;T[]&lt;/code&gt; or &lt;code&gt;T*&lt;/code&gt;), the Julia type should again be &lt;code&gt;Ptr{T}&lt;/code&gt;, not &lt;code&gt;Vector{T}&lt;/code&gt;.</source>
          <target state="translated">文字列引数（ &lt;code&gt;char*&lt;/code&gt; ）の場合、ジュリア型は &lt;code&gt;Cstring&lt;/code&gt; （NULで終了するデータが必要な場合）または &lt;code&gt;Ptr{Cchar}&lt;/code&gt; または &lt;code&gt;Ptr{UInt8}&lt;/code&gt; なければなりません（これらの2つのポインター型は同じ効果があります）。 &lt;code&gt;String&lt;/code&gt; 。同様に、配列引数（ &lt;code&gt;T[]&lt;/code&gt; または &lt;code&gt;T*&lt;/code&gt; ）の場合も、Julia型は &lt;code&gt;Vector{T}&lt;/code&gt; ではなく &lt;code&gt;Ptr{T}&lt;/code&gt; である必要があります。</target>
        </trans-unit>
        <trans-unit id="1b3d0b51e2ef5e244357843af21db4dc2c7dfc01" translate="yes" xml:space="preserve">
          <source>For symmetric or Hermitian &lt;code&gt;A&lt;/code&gt;, an eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, otherwise the scaling and squaring algorithm (see &lt;a href=&quot;#footnote-H05&quot;&gt;[H05]&lt;/a&gt;) is chosen.</source>
          <target state="translated">対称またはエルミート &lt;code&gt;A&lt;/code&gt; の場合、&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）が使用されます。それ以外の場合は、スケーリングおよび二乗アルゴリズム（&lt;a href=&quot;#footnote-H05&quot;&gt;[H05]を&lt;/a&gt;参照）が選択されます。</target>
        </trans-unit>
        <trans-unit id="f6c4a6da96174312b12bb84f60f8bf72388ffeca" translate="yes" xml:space="preserve">
          <source>For text I/O, use the &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;show&lt;/code&gt; methods, depending on your needs (see the documentation for these two methods for a detailed discussion of the difference between them):</source>
          <target state="translated">テキストI / Oの場合は、必要に応じて、&lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;メソッドまたは &lt;code&gt;show&lt;/code&gt; メソッドを使用します（これらの2つのメソッドの違いについての詳細は、これらのメソッドのドキュメントを参照してください）。</target>
        </trans-unit>
        <trans-unit id="205743ce47116c17ca0d1d16d7b760bea8f341c7" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;Squares&lt;/code&gt; iterable above, we can easily compute the &lt;code&gt;i&lt;/code&gt;th element of the sequence by squaring it. We can expose this as an indexing expression &lt;code&gt;S[i]&lt;/code&gt;. To opt into this behavior, &lt;code&gt;Squares&lt;/code&gt; simply needs to define &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">上記の反復可能な &lt;code&gt;Squares&lt;/code&gt; の場合、シーケンスの &lt;code&gt;i&lt;/code&gt; 番目の要素を2乗することで簡単に計算できます。これをインデックス式 &lt;code&gt;S[i]&lt;/code&gt; として公開できます。この動作にオプトインするには、 &lt;code&gt;Squares&lt;/code&gt; は単に&lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="b61259c05b4f470d8af9ec6b5659050e33e9f420" translate="yes" xml:space="preserve">
          <source>For the day of week of &lt;code&gt;dt&lt;/code&gt;, return the total number of that day of the week in &lt;code&gt;dt&lt;/code&gt;'s month. Returns 4 or 5. Useful in temporal expressions for specifying the last day of a week in a month by including &lt;code&gt;dayofweekofmonth(dt) == daysofweekinmonth(dt)&lt;/code&gt; in the adjuster function.</source>
          <target state="translated">曜日について &lt;code&gt;dt&lt;/code&gt; が、週のその日の合計数を返す &lt;code&gt;dt&lt;/code&gt; の月を。4または5を返します。調整器関数に &lt;code&gt;dayofweekofmonth(dt) == daysofweekinmonth(dt)&lt;/code&gt; を含めることにより、月の最後の曜日を指定するための時間式で役立ちます。</target>
        </trans-unit>
        <trans-unit id="fe652373fcfd70aa4cf5d9a9c42f569d7f7beb45" translate="yes" xml:space="preserve">
          <source>For the day of week of &lt;code&gt;dt&lt;/code&gt;, return which number it is in &lt;code&gt;dt&lt;/code&gt;'s month. So if the day of the week of &lt;code&gt;dt&lt;/code&gt; is Monday, then &lt;code&gt;1 = First Monday of the month, 2 = Second Monday of the month, etc.&lt;/code&gt; In the range 1:5.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; の曜日について、 &lt;code&gt;dt&lt;/code&gt; の月の何番目かを返します。したがって、 &lt;code&gt;dt&lt;/code&gt; の曜日が月曜日の場合、 &lt;code&gt;1 = First Monday of the month, 2 = Second Monday of the month, etc.&lt;/code&gt; なります。範囲は1：5です。</target>
        </trans-unit>
        <trans-unit id="652922b94585bcd03eb665e42d71bab0709ffc65" translate="yes" xml:space="preserve">
          <source>For the default constructor, exactly one argument must be supplied for each field:</source>
          <target state="translated">デフォルトのコンストラクタでは、各フィールドに対して正確に 1 つの引数を与えなければなりません。</target>
        </trans-unit>
        <trans-unit id="56d79b9ca82aa7547916a2539b58ed4630995e94" translate="yes" xml:space="preserve">
          <source>For the remaining keyword arguments, see the documentation of &lt;a href=&quot;#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">残りのキーワード引数については、&lt;a href=&quot;#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt;のドキュメントを参照してください。。</target>
        </trans-unit>
        <trans-unit id="b23a97c3c42b32c810ec362860430dab0f399881" translate="yes" xml:space="preserve">
          <source>For the same reason, contrary to logical operators presented above, the short-circuiting boolean operators &lt;a href=&quot;../../base/math/index#&amp;amp;&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;||&lt;/code&gt; do not allow for &lt;code&gt;missing&lt;/code&gt; values in situations where the value of the operand determines whether the next operand is evaluated or not. For example</source>
          <target state="translated">同じ理由で、上記の論理演算子とは対照的に、短絡ブール演算子&lt;a href=&quot;../../base/math/index#&amp;amp;&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/a&gt;および &lt;code&gt;||&lt;/code&gt; オペランドの値によって次のオペランドが評価されるかどうかが決まる状況では、 &lt;code&gt;missing&lt;/code&gt; 値を許容しないでください。例えば</target>
        </trans-unit>
        <trans-unit id="f6f2cb638bdf85d316fe3667be12ad3cf8fd1cb2" translate="yes" xml:space="preserve">
          <source>For the very common pattern usage pattern of</source>
          <target state="translated">のごく一般的なパターンの使用パターンについては</target>
        </trans-unit>
        <trans-unit id="abe66bccf2edc923b8619fe03afd5d016c3843ac" translate="yes" xml:space="preserve">
          <source>For these reasons, it's recommended that you try using the built-in sampling profiler before considering any alternatives.</source>
          <target state="translated">これらの理由から、他の方法を検討する前に、内蔵のサンプリング・プロファイラを使用してみることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="61eee68fc84c521e01e74ee4b3cb32a8a20b7707" translate="yes" xml:space="preserve">
          <source>For translating a C argument list to Julia:</source>
          <target state="translated">Cの引数リストをJuliaに翻訳するためのものです。</target>
        </trans-unit>
        <trans-unit id="0c8fe98556d87eebbe139565ad2035f5a8376ab0" translate="yes" xml:space="preserve">
          <source>For translating a C return type to Julia:</source>
          <target state="translated">Cの戻り値の型をJuliaに変換するためのものです。</target>
        </trans-unit>
        <trans-unit id="f089947163c1743d34e858e0290c83835145a36d" translate="yes" xml:space="preserve">
          <source>For two arguments, this is the angle in radians between the positive &lt;em&gt;x&lt;/em&gt;-axis and the point (&lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;), returning a value in the interval $[-\pi, \pi]$. This corresponds to a standard &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt;&lt;code&gt;atan2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">2つの引数の場合、これは正の&lt;em&gt;x&lt;/em&gt;軸と点（&lt;em&gt;x&lt;/em&gt;、&lt;em&gt;y&lt;/em&gt;）の間のラジアン単位の角度であり、$ [-\ pi、\ pi] $の間隔で値を返します。これは標準の&lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt; &lt;code&gt;atan2&lt;/code&gt; &lt;/a&gt;関数に対応します。</target>
        </trans-unit>
        <trans-unit id="8784f2a51d06748e116c26d584683c6da35029e2" translate="yes" xml:space="preserve">
          <source>For unbuffered channels returns &lt;code&gt;true&lt;/code&gt; if there are tasks waiting on a &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt;&lt;code&gt;put!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">バッファリングされていないチャネルの場合、&lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt; &lt;code&gt;put!&lt;/code&gt; &lt;/a&gt;待機しているタスクが &lt;code&gt;true&lt;/code&gt; 場合はtrueを返します。。</target>
        </trans-unit>
        <trans-unit id="dcf07feef0790c851bc6f0a6f8cbac38791a64b9" translate="yes" xml:space="preserve">
          <source>For unbuffered channels, blocks until a &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt;&lt;code&gt;put!&lt;/code&gt;&lt;/a&gt; is performed by a different task.</source>
          <target state="translated">バッファリングされていないチャネルの場合、&lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt; &lt;code&gt;put!&lt;/code&gt; &lt;/a&gt;までブロックします！別のタスクによって実行されます。</target>
        </trans-unit>
        <trans-unit id="84b0a200921412bb65f21b5bb7c59da76c4bbed1" translate="yes" xml:space="preserve">
          <source>For unbuffered channels, blocks until a &lt;a href=&quot;#Base.take!-Tuple%7BChannel%7D&quot;&gt;&lt;code&gt;take!&lt;/code&gt;&lt;/a&gt; is performed by a different task.</source>
          <target state="translated">バッファリングされていないチャンネルの場合、&lt;a href=&quot;#Base.take!-Tuple%7BChannel%7D&quot;&gt; &lt;code&gt;take!&lt;/code&gt; &lt;/a&gt;までブロックします！別のタスクによって実行されます。</target>
        </trans-unit>
        <trans-unit id="b5d88c03e115fa0e1f0ae726ca69a5946e7b8f3d" translate="yes" xml:space="preserve">
          <source>For variable &lt;code&gt;a&lt;/code&gt; and expression &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a = b&lt;/code&gt; makes &lt;code&gt;a&lt;/code&gt; refer to the value of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">変数の &lt;code&gt;a&lt;/code&gt; 及び式 &lt;code&gt;b&lt;/code&gt; 、 &lt;code&gt;a = b&lt;/code&gt; 行うの値を参照して &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a2988c23bad5d1f4419c0c3331b505d6761bfd4" translate="yes" xml:space="preserve">
          <source>For when a capture doesn't match, instead of a substring, &lt;code&gt;m.captures&lt;/code&gt; contains &lt;code&gt;nothing&lt;/code&gt; in that position, and &lt;code&gt;m.offsets&lt;/code&gt; has a zero offset (recall that indices in Julia are 1-based, so a zero offset into a string is invalid). Here is a pair of somewhat contrived examples:</source>
          <target state="translated">キャプチャが一致しない場合、サブストリングの代わりに、 &lt;code&gt;m.captures&lt;/code&gt; にはその位置に &lt;code&gt;nothing&lt;/code&gt; 含まれず、 &lt;code&gt;m.offsets&lt;/code&gt; にはゼロオフセットがあります（Juliaのインデックスは1ベースであるため、文字列へのゼロオフセットは無効）。これは、多少工夫された例のペアです。</target>
        </trans-unit>
        <trans-unit id="cdc4b17a13e956b864dfd62e85ad672e28429820" translate="yes" xml:space="preserve">
          <source>Force a GC run</source>
          <target state="translated">強制的にGCラン</target>
        </trans-unit>
        <trans-unit id="5eb175b9460612a847c5831f8d611666f7e129b1" translate="yes" xml:space="preserve">
          <source>Forces</source>
          <target state="translated">Forces</target>
        </trans-unit>
        <trans-unit id="08bb485a70c09a4b008d8b79ee39bee0f080480a" translate="yes" xml:space="preserve">
          <source>Forces synchronization between the in-memory version of a memory-mapped &lt;code&gt;Array&lt;/code&gt; or &lt;a href=&quot;../../base/arrays/index#Base.BitArray&quot;&gt;&lt;code&gt;BitArray&lt;/code&gt;&lt;/a&gt; and the on-disk version.</source>
          <target state="translated">メモリマップされた &lt;code&gt;Array&lt;/code&gt; または&lt;a href=&quot;../../base/arrays/index#Base.BitArray&quot;&gt; &lt;code&gt;BitArray&lt;/code&gt; の&lt;/a&gt;メモリ内バージョンとディスク上のバージョン間の同期を強制します。</target>
        </trans-unit>
        <trans-unit id="a4b44623e8c8994cfd237bbb5a20500862bde2d9" translate="yes" xml:space="preserve">
          <source>Fork And Knife</source>
          <target state="translated">フォークとナイフ</target>
        </trans-unit>
        <trans-unit id="cac22bd0e8a69bd849b7be8d79bbdfbf8b44d9d5" translate="yes" xml:space="preserve">
          <source>Forking</source>
          <target state="translated">Forking</target>
        </trans-unit>
        <trans-unit id="050d7641601e8d3bdebb15e95cb05f81983e6de8" translate="yes" xml:space="preserve">
          <source>Format the &lt;code&gt;tok&lt;/code&gt; token from &lt;code&gt;dt&lt;/code&gt; and write it to &lt;code&gt;io&lt;/code&gt;. The formatting can be based on &lt;code&gt;locale&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; から &lt;code&gt;tok&lt;/code&gt; トークンをフォーマットして、 &lt;code&gt;io&lt;/code&gt; に書き込みます。書式は &lt;code&gt;locale&lt;/code&gt; に基づくことができます。</target>
        </trans-unit>
        <trans-unit id="5449b0de438e10172cfa72d13dabc8ee40d61810" translate="yes" xml:space="preserve">
          <source>Fortran compilers &lt;em&gt;may&lt;/em&gt; also add other hidden arguments for pointers, assumed-shape (&lt;code&gt;:&lt;/code&gt;) and assumed-size (&lt;code&gt;*&lt;/code&gt;) arrays. Such behaviour can be avoided by using &lt;code&gt;ISO_C_BINDING&lt;/code&gt; and including &lt;code&gt;bind(c)&lt;/code&gt; in the definition of the subroutine, which is strongly recommended for interoperable code. In this case there will be no hidden arguments, at the cost of some language features (e.g. only &lt;code&gt;character(len=1)&lt;/code&gt; will be permitted to pass strings).</source>
          <target state="translated">Fortranコンパイラが&lt;em&gt;できる&lt;/em&gt;（また、ポインタのために他の隠された引数を追加し、形状仮定 &lt;code&gt;:&lt;/code&gt; ）と想定サイズ（ &lt;code&gt;*&lt;/code&gt; ）アレイ。このような動作は、 &lt;code&gt;ISO_C_BINDING&lt;/code&gt; を使用し、サブルーチンの定義に &lt;code&gt;bind(c)&lt;/code&gt; を含めることで回避できます。これは、相互運用可能なコードで強く推奨されます。この場合、一部の言語機能を犠牲にして、隠された引数はありません（たとえば、 &lt;code&gt;character(len=1)&lt;/code&gt; 列を渡すことができるのは、文字（len = 1）のみです）。</target>
        </trans-unit>
        <trans-unit id="a0484116def6ba2539f3b9f9921bd8b4ba22a4aa" translate="yes" xml:space="preserve">
          <source>Fortran name</source>
          <target state="translated">フォートラン名</target>
        </trans-unit>
        <trans-unit id="16c35d1374b93a7d00d34b68d3e6ad6a2c21c760" translate="yes" xml:space="preserve">
          <source>Fortunately, many useful parallel computations do not require data movement. A common example is a Monte Carlo simulation, where multiple processes can handle independent simulation trials simultaneously. We can use &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; to flip coins on two processes. First, write the following function in &lt;code&gt;count_heads.jl&lt;/code&gt;:</source>
          <target state="translated">幸い、多くの有用な並列計算では、データの移動は必要ありません。一般的な例はモンテカルロシミュレーションで、複数のプロセスが独立したシミュレーションの試行を同時に処理できます。&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt;を使用して、2つのプロセスでコインを裏返すことができます。まず、 &lt;code&gt;count_heads.jl&lt;/code&gt; に次の関数を記述します。</target>
        </trans-unit>
        <trans-unit id="5dd1ed1b5512a22fba4de952e82beaad9990da5b" translate="yes" xml:space="preserve">
          <source>Forward delete one character (when buffer has text)</source>
          <target state="translated">1文字の前方削除(バッファにテキストがある場合)</target>
        </trans-unit>
        <trans-unit id="d2bd5de8c2484ca6755e34f338af3268021c0a12" translate="yes" xml:space="preserve">
          <source>Forward delete the next word</source>
          <target state="translated">次の単語を前方に削除します。</target>
        </trans-unit>
        <trans-unit id="a187c3285151f39c70caaf5e477c6e87663d3ef4" translate="yes" xml:space="preserve">
          <source>Fountain</source>
          <target state="translated">Fountain</target>
        </trans-unit>
        <trans-unit id="4ab98d03a72763b8222b6d8722ded7966bf98d76" translate="yes" xml:space="preserve">
          <source>Four Leaf Clover</source>
          <target state="translated">四つ葉のクローバー</target>
        </trans-unit>
        <trans-unit id="2b13f83d35f7fc73ce97c8b26bfe724907153aae" translate="yes" xml:space="preserve">
          <source>Four-Per-Em Space</source>
          <target state="translated">四人乗り空間</target>
        </trans-unit>
        <trans-unit id="73c09759c4507af6948adebc3787e93351d4acda" translate="yes" xml:space="preserve">
          <source>Fourth Root</source>
          <target state="translated">第四根</target>
        </trans-unit>
        <trans-unit id="c54d686ebd31bf6296f3ac8e3de5cdba7b0fe495" translate="yes" xml:space="preserve">
          <source>Fraction Numerator One</source>
          <target state="translated">分数分子1</target>
        </trans-unit>
        <trans-unit id="9f62f41c6fc2c6a6ef7e8630ebef06bc253ed2e9" translate="yes" xml:space="preserve">
          <source>Fractions</source>
          <target state="translated">Fractions</target>
        </trans-unit>
        <trans-unit id="1a4eb1bfc4ceb4284f084ca37c8edbaed934f05c" translate="yes" xml:space="preserve">
          <source>Free and open source (&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/LICENSE.md&quot;&gt;MIT licensed&lt;/a&gt;)</source>
          <target state="translated">フリーでオープンソース（&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/LICENSE.md&quot;&gt;MITライセンス&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="d150e0aaee05d4d7cee80412f889a1b8c7404089" translate="yes" xml:space="preserve">
          <source>French Fries</source>
          <target state="translated">フレンチフライ</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">よくある質問</target>
        </trans-unit>
        <trans-unit id="2e42fd5fd57e2eddb93e306ecceb863efd070156" translate="yes" xml:space="preserve">
          <source>Fried Shrimp</source>
          <target state="translated">エビフライ</target>
        </trans-unit>
        <trans-unit id="d25d30098e10e7246e59352c44263a5bb1531117" translate="yes" xml:space="preserve">
          <source>Frog Face</source>
          <target state="translated">カエルの顔</target>
        </trans-unit>
        <trans-unit id="ec026c33022b335b80bd8f0e64407b39229b2c88" translate="yes" xml:space="preserve">
          <source>From the caller's perspective, this is identical to a regular function; in fact, you don't have to know whether you're calling a regular or generated function. Let's see how &lt;code&gt;foo&lt;/code&gt; behaves:</source>
          <target state="translated">呼び出し側から見ると、これは通常の関数と同じです。実際、通常の関数を呼び出しているのか、生成された関数を呼び出しているのかを知る必要はありません。 &lt;code&gt;foo&lt;/code&gt; の動作を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="ca77e2b5e973595e2f2f608f9805266ed582b1b8" translate="yes" xml:space="preserve">
          <source>From these definitions, one obtains the following behavior:</source>
          <target state="translated">これらの定義から、次のような動作が得られます。</target>
        </trans-unit>
        <trans-unit id="b422184537e8dbfbffe465f2c662481e754378a9" translate="yes" xml:space="preserve">
          <source>Front-Facing Baby Chick</source>
          <target state="translated">前向きベビーヒヨコ</target>
        </trans-unit>
        <trans-unit id="6d0c809a561642fe04a663534c34c6a988c1f63d" translate="yes" xml:space="preserve">
          <source>Frown</source>
          <target state="translated">Frown</target>
        </trans-unit>
        <trans-unit id="fb52dd543cda4930bef0a7aed25ec2307f4f2ed5" translate="yes" xml:space="preserve">
          <source>Frowning Face With Open Mouth</source>
          <target state="translated">開いた口でしかめっ面</target>
        </trans-unit>
        <trans-unit id="3b8ae9bdd856b92028c18db46fbc39d04889c711" translate="yes" xml:space="preserve">
          <source>Fuel Pump</source>
          <target state="translated">燃料ポンプ</target>
        </trans-unit>
        <trans-unit id="1dc013b6064daee6213fd09ae3d5ea49df1bdb94" translate="yes" xml:space="preserve">
          <source>Full Block</source>
          <target state="translated">フルブロック</target>
        </trans-unit>
        <trans-unit id="91e2750218473c3715d4640558a3e864dd2b4c5e" translate="yes" xml:space="preserve">
          <source>Full Moon Symbol</source>
          <target state="translated">満月のシンボル</target>
        </trans-unit>
        <trans-unit id="32a64f880ba20480782d9f08062e23749801ebec" translate="yes" xml:space="preserve">
          <source>Full Moon With Face</source>
          <target state="translated">顔のある満月</target>
        </trans-unit>
        <trans-unit id="11342457efd18f569b992724d11b3a2d8832ce4b" translate="yes" xml:space="preserve">
          <source>Full Outer Join</source>
          <target state="translated">フルアウタージョイン</target>
        </trans-unit>
        <trans-unit id="db63acc70bb8aace65207096c8aa56a922c0d72f" translate="yes" xml:space="preserve">
          <source>Fully implemented by:</source>
          <target state="translated">によって完全に実装されています。</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="95054001cf3f6f293128fbac88deaae7d22cc115" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;abmult&lt;/code&gt; returns a function &lt;code&gt;f&lt;/code&gt; that multiplies its argument by the absolute value of &lt;code&gt;r&lt;/code&gt;. The inner function assigned to &lt;code&gt;f&lt;/code&gt; is called a &quot;closure&quot;. Inner functions are also used by the language for &lt;code&gt;do&lt;/code&gt;-blocks and for generator expressions.</source>
          <target state="translated">関数 &lt;code&gt;abmult&lt;/code&gt; は、引数に &lt;code&gt;r&lt;/code&gt; の絶対値を乗算する関数 &lt;code&gt;f&lt;/code&gt; を返します。 &lt;code&gt;f&lt;/code&gt; に割り当てられた内部関数は「クロージャ」と呼ばれます。内部関数は、言語によって &lt;code&gt;do&lt;/code&gt; ブロックおよびジェネレータ式にも使用されます。</target>
        </trans-unit>
        <trans-unit id="7697b6877e6664e26745e5f66999b4cfefbd165c" translate="yes" xml:space="preserve">
          <source>Function body starting with &lt;code&gt;Body::UNION{T1,T2})&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Body::UNION{T1,T2})&lt;/code&gt; 始まる関数本体</target>
        </trans-unit>
        <trans-unit id="aa0b7e8266dfec8d33dbc09471974455072b6005" translate="yes" xml:space="preserve">
          <source>Function chaining (sometimes called &quot;piping&quot; or &quot;using a pipe&quot; to send data to a subsequent function) is when you apply a function to the previous function's output:</source>
          <target state="translated">関数チェーニング(&quot;パイピング &quot;や &quot;パイプを使って後続の関数にデータを送る &quot;と呼ばれることもあります)とは、前の関数の出力に関数を適用することです。</target>
        </trans-unit>
        <trans-unit id="f28a100a083f8e25a3bc12e6db11fea904564f3f" translate="yes" xml:space="preserve">
          <source>Function composition and piping</source>
          <target state="translated">機能構成と配管</target>
        </trans-unit>
        <trans-unit id="faa5a28142e8b8d79608d822a7ee2fc012117fa0" translate="yes" xml:space="preserve">
          <source>Function composition is when you combine functions together and apply the resulting composition to arguments. You use the function composition operator (&lt;code&gt;∘&lt;/code&gt;) to compose the functions, so &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; is the same as &lt;code&gt;f(g(args...))&lt;/code&gt;.</source>
          <target state="translated">関数構成とは、関数を組み合わせて、結果の構成を引数に適用することです。関数構成演算子（ &lt;code&gt;∘&lt;/code&gt; ）を使用して関数を作成するため、 &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; は &lt;code&gt;f(g(args...))&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="be8cbdb67375da79abe2b0143f8eebcc7cb99416" translate="yes" xml:space="preserve">
          <source>Function parameters can also be used to constrain the number of arguments that may be supplied to a &quot;varargs&quot; function (&lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt;). The notation &lt;code&gt;Vararg{T,N}&lt;/code&gt; is used to indicate such a constraint. For example:</source>
          <target state="translated">関数パラメーターを使用して、「varargs」関数（&lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs関数&lt;/a&gt;）に提供できる引数の数を制限することもできます。そのような制約を示すために表記 &lt;code&gt;Vararg{T,N}&lt;/code&gt; が使用されます。例えば：</target>
        </trans-unit>
        <trans-unit id="c748f42ec833ed8f7d97105f385770153e5f3a88" translate="yes" xml:space="preserve">
          <source>Function sets &lt;code&gt;+refs/*:refs/*&lt;/code&gt; refspecs and &lt;code&gt;mirror&lt;/code&gt; flag for remote reference.</source>
          <target state="translated">関数は、リモート参照用に &lt;code&gt;+refs/*:refs/*&lt;/code&gt; refspecsと &lt;code&gt;mirror&lt;/code&gt; フラグを設定します。</target>
        </trans-unit>
        <trans-unit id="ea4be7f77276f932f73d95ac11b41c01bca27493" translate="yes" xml:space="preserve">
          <source>Function-like objects</source>
          <target state="translated">関数のようなオブジェクト</target>
        </trans-unit>
        <trans-unit id="79fde2ac8490ff2b99ac9c9890e046fdff6e3659" translate="yes" xml:space="preserve">
          <source>Functionality</source>
          <target state="translated">Functionality</target>
        </trans-unit>
        <trans-unit id="eddb44c7165ef5eabc1df07ca23331299f12c1fa" translate="yes" xml:space="preserve">
          <source>Functionality for base-64 encoded strings and IO.</source>
          <target state="translated">ベース64でエンコードされた文字列とIOのための機能。</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="53a4e15f59ddb4061325c79602aaccdf7b922b54" translate="yes" xml:space="preserve">
          <source>Functions &amp;amp; Methods</source>
          <target state="translated">関数とメソッド</target>
        </trans-unit>
        <trans-unit id="c13326dfc431675363c3f3a461ddb4d2e5748e9f" translate="yes" xml:space="preserve">
          <source>Functions &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.rmprocs&quot;&gt;&lt;code&gt;rmprocs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.workers&quot;&gt;&lt;code&gt;workers&lt;/code&gt;&lt;/a&gt;, and others are available as a programmatic means of adding, removing and querying the processes in a cluster.</source>
          <target state="translated">関数&lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../stdlib/distributed/index#Distributed.rmprocs&quot;&gt; &lt;code&gt;rmprocs&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../stdlib/distributed/index#Distributed.workers&quot;&gt; &lt;code&gt;workers&lt;/code&gt; &lt;/a&gt;、および他のクラスタの処理を追加、削除、および照会のプログラム手段として利用可能です。</target>
        </trans-unit>
        <trans-unit id="0ff075e5c1729ce32f2f5738fecab65d263b0838" translate="yes" xml:space="preserve">
          <source>Functions &lt;code&gt;any&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; also follow the rules of three-valued logic, returning &lt;code&gt;missing&lt;/code&gt; when the result cannot be determined</source>
          <target state="translated">関数 &lt;code&gt;any&lt;/code&gt; も &lt;code&gt;all&lt;/code&gt; も3値論理の規則に従い、結果を判別できない場合に &lt;code&gt;missing&lt;/code&gt; 値を返します</target>
        </trans-unit>
        <trans-unit id="a7372df3a40ed071a29722d4bc6498e66d76a5da" translate="yes" xml:space="preserve">
          <source>Functions and Methods</source>
          <target state="translated">機能と方法</target>
        </trans-unit>
        <trans-unit id="7bb375b3fcf2e8e9d0dbcd433eb2746123db60e5" translate="yes" xml:space="preserve">
          <source>Functions are defined with the &lt;code&gt;function&lt;/code&gt; keyword:</source>
          <target state="translated">関数は &lt;code&gt;function&lt;/code&gt; キーワードで定義されます：</target>
        </trans-unit>
        <trans-unit id="55e8c66bfd9e6c0e9dfa04cb544f8bb30a80231b" translate="yes" xml:space="preserve">
          <source>Functions in Julia are &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_citizen&quot;&gt;first-class objects&lt;/a&gt;: they can be assigned to variables, and called using the standard function call syntax from the variable they have been assigned to. They can be used as arguments, and they can be returned as values. They can also be created anonymously, without being given a name, using either of these syntaxes:</source>
          <target state="translated">Juliaの関数は、&lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_citizen&quot;&gt;ファーストクラスのオブジェクトです&lt;/a&gt;。変数に割り当てることができ、割り当てられている変数から標準の関数呼び出し構文を使用して呼び出すことができます。これらは引数として使用でき、値として返すことができます。次の構文のいずれかを使用して、名前を付けずに匿名で作成することもできます。</target>
        </trans-unit>
        <trans-unit id="c04e52a6c310e2a4baade48d1f42fd88819eec1a" translate="yes" xml:space="preserve">
          <source>Functions in Julia can be combined by composing or piping (chaining) them together.</source>
          <target state="translated">Julia の関数は、それらを合成したり、パイピング(連結)したりすることで組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="ceeb1ec49508dede84853cbb0f013b3decdfa56c" translate="yes" xml:space="preserve">
          <source>Functions in Julia may have multiple implementations, known as methods. While it's good practice for generic functions to have a single purpose, Julia allows methods to be documented individually if necessary. In general, only the most generic method should be documented, or even the function itself (i.e. the object created without any methods by &lt;code&gt;function bar end&lt;/code&gt;). Specific methods should only be documented if their behaviour differs from the more generic ones. In any case, they should not repeat the information provided elsewhere. For example:</source>
          <target state="translated">Juliaの関数には、メソッドと呼ばれる複数の実装がある場合があります。ジェネリック関数が単一の目的を持つことは良い習慣ですが、ジュリアでは、必要に応じてメソッドを個別に文書化することができます。一般的に、最も一般的なメソッド、または関数自体（つまり、 &lt;code&gt;function bar end&lt;/code&gt; によってメソッドなしで作成されたオブジェクト）だけを文書化する必要があります。特定のメソッドは、その動作がより一般的なものと異なる場合にのみ文書化する必要があります。いずれにせよ、彼らは他の場所で提供された情報を繰り返すべきではありません。例えば：</target>
        </trans-unit>
        <trans-unit id="820b3bd7ddec6937c4e242be1bbe2ab057c0ac78" translate="yes" xml:space="preserve">
          <source>Functions in Julia return values from their last expression or the &lt;code&gt;return&lt;/code&gt; keyword instead of listing the names of variables to return in the function definition (see &lt;a href=&quot;../functions/index#The-return-Keyword-1&quot;&gt;The return Keyword&lt;/a&gt; for details).</source>
          <target state="translated">Julia の関数は、関数定義で返す変数の名前をリストする代わりに、最後の式または &lt;code&gt;return&lt;/code&gt; キーワードから値を返します（詳細については&lt;a href=&quot;../functions/index#The-return-Keyword-1&quot;&gt;、returnキーワード&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="a59fb02f015778c14d39ec5b1bcf732d30a76ac1" translate="yes" xml:space="preserve">
          <source>Functions in Julia return values from their last expression(s) or the &lt;code&gt;return&lt;/code&gt; keyword. Multiple values can be returned from functions and assigned as tuples, e.g. &lt;code&gt;(a, b) = myfunction()&lt;/code&gt; or &lt;code&gt;a, b = myfunction()&lt;/code&gt;, instead of having to pass pointers to values as one would have to do in C/C++ (i.e. &lt;code&gt;a = myfunction(&amp;amp;b)&lt;/code&gt;.</source>
          <target state="translated">Juliaの関数は、最後の式または &lt;code&gt;return&lt;/code&gt; キーワードから値を返します。複数の値を関数から返し、タプルとして割り当てることができます。例： &lt;code&gt;(a, b) = myfunction()&lt;/code&gt; または &lt;code&gt;a, b = myfunction()&lt;/code&gt; 、C / C ++で行う必要があるように値へのポインターを渡す必要はありません（つまり &lt;code&gt;a = myfunction(&amp;amp;b)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a55840c344c2be9d92831007662fa28bbfaafd80" translate="yes" xml:space="preserve">
          <source>Functions like &lt;code&gt;strange_twos&lt;/code&gt; occur when dealing with data of uncertain type, for example data loaded from an input file that might contain either integers, floats, strings, or something else.</source>
          <target state="translated">&lt;code&gt;strange_twos&lt;/code&gt; のような関数は、たとえば、整数、浮動小数点数、文字列などを含む可能性のある入力ファイルからロードされたデータなど、不確実なタイプのデータを処理するときに発生します。</target>
        </trans-unit>
        <trans-unit id="7b33eb7808d1f3eaa212ba1f622374dd77c823c6" translate="yes" xml:space="preserve">
          <source>Functions on &lt;code&gt;Expr&lt;/code&gt;essions</source>
          <target state="translated">上の機能 &lt;code&gt;Expr&lt;/code&gt; essions</target>
        </trans-unit>
        <trans-unit id="8b8603c397ef929230aa5c590ebf0c5ec135d545" translate="yes" xml:space="preserve">
          <source>Functions pertaining to probability distributions are provided by the &lt;a href=&quot;https://github.com/JuliaStats/Distributions.jl&quot;&gt;Distributions package&lt;/a&gt;.</source>
          <target state="translated">確率分布に関連する関数は、&lt;a href=&quot;https://github.com/JuliaStats/Distributions.jl&quot;&gt;Distributionsパッケージ&lt;/a&gt;によって提供されます。</target>
        </trans-unit>
        <trans-unit id="07740f0b9c92a3b6637549532f0dfc491685de70" translate="yes" xml:space="preserve">
          <source>Functions that write to their arguments have names that end in &lt;code&gt;!&lt;/code&gt;. These are sometimes called &quot;mutating&quot; or &quot;in-place&quot; functions because they are intended to produce changes in their arguments after the function is called, not just return a value.</source>
          <target state="translated">引数に書き込む関数の名前は &lt;code&gt;!&lt;/code&gt; で終わります。。これらは、単に値を返すだけでなく、関数が呼び出された後に引数を変更することを目的としているため、「変更」または「インプレース」関数と呼ばれることもあります。</target>
        </trans-unit>
        <trans-unit id="9cba6354edf31323e29d861220b894beb53b62d4" translate="yes" xml:space="preserve">
          <source>Functions with keyword arguments are defined using a semicolon in the signature:</source>
          <target state="translated">キーワード引数を持つ関数は、シグネチャでセミコロンを使用して定義されます。</target>
        </trans-unit>
        <trans-unit id="bafd4b54282745a2bed1442852b73f4b3189a77a" translate="yes" xml:space="preserve">
          <source>Further Reading</source>
          <target state="translated">続きを読む</target>
        </trans-unit>
        <trans-unit id="0132f20ae5d3a74b84246e40987da84635bfd3d0" translate="yes" xml:space="preserve">
          <source>Furthermore, &quot;dotted&quot; updating operators like &lt;code&gt;a .+= b&lt;/code&gt; (or &lt;code&gt;@. a += b&lt;/code&gt;) are parsed as &lt;code&gt;a .= a .+ b&lt;/code&gt;, where &lt;code&gt;.=&lt;/code&gt; is a fused &lt;em&gt;in-place&lt;/em&gt; assignment operation (see the &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot syntax documentation&lt;/a&gt;).</source>
          <target state="translated">また、同様に更新演算子を&quot;点線&quot; &lt;code&gt;a .+= b&lt;/code&gt; （又は &lt;code&gt;@. a += b&lt;/code&gt; ）として解析される &lt;code&gt;a .= a .+ b&lt;/code&gt; 、ここ &lt;code&gt;.=&lt;/code&gt; で融合された&lt;em&gt;インプレース&lt;/em&gt;割り当て動作（参照&lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;ドット構文ドキュメントを&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9d0dab03985e67ddbff313bf737b40f319ace224" translate="yes" xml:space="preserve">
          <source>Furthermore, the iterable object splatted into a function call need not be a tuple:</source>
          <target state="translated">さらに、関数呼び出しにスプラットされる反復可能なオブジェクトはタプルである必要はありません。</target>
        </trans-unit>
        <trans-unit id="0e833ac5a09d0da4e04120e7544830f8a65151fd" translate="yes" xml:space="preserve">
          <source>G. W. Stewart, &quot;Rank Degeneracy&quot;, SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. &lt;a href=&quot;http://epubs.siam.org/doi/abs/10.1137/0905030&quot;&gt;doi:10.1137/0905030&lt;/a&gt;</source>
          <target state="translated">GW Stewart、「Rank Degeneeracy」、SIAM Journal on Scientific and Statistical Computing、5（2）、1984、403-413。&lt;a href=&quot;http://epubs.siam.org/doi/abs/10.1137/0905030&quot;&gt;doi：10.1137 / 0905030&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="99a3e18460e703b6b52b26b4155c66c3e3ba24bc" translate="yes" xml:space="preserve">
          <source>GC</source>
          <target state="translated">GC</target>
        </trans-unit>
        <trans-unit id="153d4c166a2f860e5ac33c697533af00d178259a" translate="yes" xml:space="preserve">
          <source>GC.@preserve</source>
          <target state="translated">GC.@preserve</target>
        </trans-unit>
        <trans-unit id="3897445415fe5ec5c17d947d2f396ecb73cfab7e" translate="yes" xml:space="preserve">
          <source>GC.enable()</source>
          <target state="translated">GC.enable()</target>
        </trans-unit>
        <trans-unit id="f7f51a07b89aa04e176b4dce9ba6e667279a4cac" translate="yes" xml:space="preserve">
          <source>GC.gc()</source>
          <target state="translated">GC.gc()</target>
        </trans-unit>
        <trans-unit id="dd04fdce0b5db2163f133667347720589a61611d" translate="yes" xml:space="preserve">
          <source>GMP.BigInt</source>
          <target state="translated">GMP.BigInt</target>
        </trans-unit>
        <trans-unit id="ec181f943ce9eb84bc41a51f14f715a4b73d4e15" translate="yes" xml:space="preserve">
          <source>GMP.BigInt()</source>
          <target state="translated">GMP.BigInt()</target>
        </trans-unit>
        <trans-unit id="1f1b07ba1d3f58af4c465921af5b16d96fd0bc35" translate="yes" xml:space="preserve">
          <source>GT</source>
          <target state="translated">GT</target>
        </trans-unit>
        <trans-unit id="f3b1d13cf7d8da8c19344c722b6886a02e91434d" translate="yes" xml:space="preserve">
          <source>Game Die</source>
          <target state="translated">ゲームは死ぬ</target>
        </trans-unit>
        <trans-unit id="23e043a9ee4de0e7b0c73093401aa0bca44ab49b" translate="yes" xml:space="preserve">
          <source>Garbage Collection Safety</source>
          <target state="translated">ごみ収集の安全性</target>
        </trans-unit>
        <trans-unit id="d6d5b4be825ce665265510009390d4b69a148c2b" translate="yes" xml:space="preserve">
          <source>Garbage-collection handle for the return value from &lt;code&gt;@cfunction&lt;/code&gt; when the first argument is annotated with '$'. Like all &lt;code&gt;cfunction&lt;/code&gt; handles, it should be passed to &lt;code&gt;ccall&lt;/code&gt; as a &lt;code&gt;Ptr{Cvoid}&lt;/code&gt;, and will be converted automatically at the call site to the appropriate type.</source>
          <target state="translated">最初の引数に「$」の注釈が付けられているときの &lt;code&gt;@cfunction&lt;/code&gt; からの戻り値のガベージコレクションハンドル。すべての &lt;code&gt;cfunction&lt;/code&gt; ハンドルと同様に、これは &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; として &lt;code&gt;ccall&lt;/code&gt; に渡す必要があり、呼び出しサイトで適切な型に自動的に変換されます。</target>
        </trans-unit>
        <trans-unit id="dbb8c00bae5bbda144f1736a9cba2314230cbae3" translate="yes" xml:space="preserve">
          <source>Gem Stone</source>
          <target state="translated">ジェムストーン</target>
        </trans-unit>
        <trans-unit id="ddba2c9277cd909b2d4fac91a3cc754a462c7a90" translate="yes" xml:space="preserve">
          <source>Gemini</source>
          <target state="translated">Gemini</target>
        </trans-unit>
        <trans-unit id="9203a7a738516ae214b4ae47d8b7fd816429f200" translate="yes" xml:space="preserve">
          <source>General Collections</source>
          <target state="translated">一般的なコレクション</target>
        </trans-unit>
        <trans-unit id="b87cf666cc00e115fb18674c6deb84af8b517c7f" translate="yes" xml:space="preserve">
          <source>General I/O</source>
          <target state="translated">一般的なI/O</target>
        </trans-unit>
        <trans-unit id="4979599c738b7850931480557307563f3cf52a2f" translate="yes" xml:space="preserve">
          <source>General Number Functions and Constants</source>
          <target state="translated">一般的な数関数と定数</target>
        </trans-unit>
        <trans-unit id="6b7059d9b81b1f245d958405a414e29373725e72" translate="yes" xml:space="preserve">
          <source>General escaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">従来のCおよびUnicodeエスケープシーケンスの一般的なエスケープ。最初の形式はエスケープされた文字列を返し、2番目の形式は結果を &lt;code&gt;io&lt;/code&gt; に出力します。</target>
        </trans-unit>
        <trans-unit id="4e9dfb96c25a921933f55dcf7822775fb8e071eb" translate="yes" xml:space="preserve">
          <source>General exceptions can be raised using the functions:</source>
          <target state="translated">一般的な例外は、関数を使用して発生させることができます。</target>
        </trans-unit>
        <trans-unit id="aa8e53d9ebff9d0979fd39b344364382458a81b6" translate="yes" xml:space="preserve">
          <source>General non-square</source>
          <target state="translated">一般的な非正方形</target>
        </trans-unit>
        <trans-unit id="07891976324532c807b79ec56fda0fc0b9da6708" translate="yes" xml:space="preserve">
          <source>General square</source>
          <target state="translated">一般的な正方形</target>
        </trans-unit>
        <trans-unit id="1d3f6af2e9c4d5b2ed46f9e07478d485ceb20715" translate="yes" xml:space="preserve">
          <source>General unescaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">従来のCおよびUnicodeのエスケープシーケンスの一般的なエスケープ解除。最初の形式はエスケープされた文字列を返し、2番目の形式は結果を &lt;code&gt;io&lt;/code&gt; に出力します。</target>
        </trans-unit>
        <trans-unit id="d0285ea21d10ed4a7913ad2a66cb346f95bc9d78" translate="yes" xml:space="preserve">
          <source>Generalized SVD</source>
          <target state="translated">一般化SVD</target>
        </trans-unit>
        <trans-unit id="4d85331d4948d0ae34d7f8f8e070efd57ba16e64" translate="yes" xml:space="preserve">
          <source>Generalized linear models are provided by the &lt;a href=&quot;https://github.com/JuliaStats/GLM.jl&quot;&gt;GLM package&lt;/a&gt;.</source>
          <target state="translated">一般化線形モデルは、&lt;a href=&quot;https://github.com/JuliaStats/GLM.jl&quot;&gt;GLMパッケージ&lt;/a&gt;によって提供されます。</target>
        </trans-unit>
        <trans-unit id="5ad14a691ce38a290bae999d447b8c703f49ef6b" translate="yes" xml:space="preserve">
          <source>Generally, new types should implement &lt;a href=&quot;#Base.:&amp;lt;&quot;&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/a&gt; instead of this function, and rely on the fallback definition &lt;code&gt;&amp;gt;(x, y) = y &amp;lt; x&lt;/code&gt;.</source>
          <target state="translated">一般に、新しい型はこの関数の代わりに&lt;a href=&quot;#Base.:&amp;lt;&quot;&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;/a&gt;を実装し、フォールバック定義 &lt;code&gt;&amp;gt;(x, y) = y &amp;lt; x&lt;/code&gt; 依存する必要があります。</target>
        </trans-unit>
        <trans-unit id="f33a08ad09d1f8b477ee12ea78ff5b8bbea276a6" translate="yes" xml:space="preserve">
          <source>Generate a &lt;code&gt;BitArray&lt;/code&gt; of random boolean values.</source>
          <target state="translated">ランダムなブール値の &lt;code&gt;BitArray&lt;/code&gt; を生成します。</target>
        </trans-unit>
        <trans-unit id="fd53bfe967151037d3aab623a3c39dc68a9e6a07" translate="yes" xml:space="preserve">
          <source>Generate a C-callable function pointer from the Julia function &lt;code&gt;callable&lt;/code&gt; for the given type signature. To pass the return value to a &lt;code&gt;ccall&lt;/code&gt;, use the argument type &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; in the signature.</source>
          <target state="translated">指定された型シグネチャのJulia関数 &lt;code&gt;callable&lt;/code&gt; からC呼び出し可能関数ポインターを生成します。戻り値を &lt;code&gt;ccall&lt;/code&gt; に渡すには、シグニチャーで引数タイプ &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="41e2ff826d751563b9e50313fe308bc12b868933" translate="yes" xml:space="preserve">
          <source>Generate a normally-distributed random number of type &lt;code&gt;T&lt;/code&gt; with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The &lt;code&gt;Base&lt;/code&gt; module currently provides an implementation for the types &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (the default), and their &lt;a href=&quot;../../base/numbers/index#Base.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt; counterparts. When the type argument is complex, the values are drawn from the circularly symmetric complex normal distribution.</source>
          <target state="translated">平均が0で標準偏差が1の &lt;code&gt;T&lt;/code&gt; 型の正規分布の乱数を生成します。オプションで、正規分布の乱数の配列を生成します。 &lt;code&gt;Base&lt;/code&gt; モジュールは、現在のタイプの実装を提供&lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;（デフォルト）、およびそれらの&lt;a href=&quot;../../base/numbers/index#Base.Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; &lt;/a&gt;対応を。型引数が複素数の場合、値は円対称の複素正規分布から取得されます。</target>
        </trans-unit>
        <trans-unit id="d735a31a4d0a7d19a36da47899d779f788bda4b7" translate="yes" xml:space="preserve">
          <source>Generate a random number of type &lt;code&gt;T&lt;/code&gt; according to the exponential distribution with scale 1. Optionally generate an array of such random numbers. The &lt;code&gt;Base&lt;/code&gt; module currently provides an implementation for the types &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (the default).</source>
          <target state="translated">スケール1の指数分布に従って、タイプ &lt;code&gt;T&lt;/code&gt; の乱数を生成します。オプションで、そのような乱数の配列を生成します。 &lt;code&gt;Base&lt;/code&gt; モジュールは、現在のタイプの実装を提供&lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;（デフォルト）。</target>
        </trans-unit>
        <trans-unit id="0fd80a1d3f890e93d6b1dc16c37a28152669461b" translate="yes" xml:space="preserve">
          <source>Generate a temporary file path. This function only returns a path; no file is created. The path is likely to be unique, but this cannot be guaranteed.</source>
          <target state="translated">一時的なファイルパスを生成します。この関数はパスを返すだけで、ファイルは生成されません。パスは一意である可能性が高いですが、これを保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="3e42af03cf7e4fa9b19d5375dcdec38dc109c9bc" translate="yes" xml:space="preserve">
          <source>Generated functions</source>
          <target state="translated">生成された関数</target>
        </trans-unit>
        <trans-unit id="40080cfd55d586fc4f5401be4bb1834fea88976c" translate="yes" xml:space="preserve">
          <source>Generated functions can achieve high efficiency at run time, but come with a compile time cost: a new function body must be generated for every combination of concrete argument types. Typically, Julia is able to compile &quot;generic&quot; versions of functions that will work for any arguments, but with generated functions this is impossible. This means that programs making heavy use of generated functions might be impossible to statically compile.</source>
          <target state="translated">生成された関数は実行時に高い効率性を得ることができますが、コンパイル時にコストがかかります:具体的な引数型の組み合わせごとに新しい関数本体を生成しなければなりません。通常、Juliaはどのような引数に対しても動作する「一般的な」バージョンの関数をコンパイルすることができますが、生成された関数ではこれが不可能です。つまり、生成された関数を多用するプログラムは静的にコンパイルできない可能性があります。</target>
        </trans-unit>
        <trans-unit id="503406d41ab4e8215a281c0d73cf5e1840925953" translate="yes" xml:space="preserve">
          <source>Generated functions must not &lt;em&gt;mutate&lt;/em&gt; or &lt;em&gt;observe&lt;/em&gt; any non-constant global state (including, for example, IO, locks, non-local dictionaries, or using &lt;a href=&quot;../../base/base/index#Base.hasmethod&quot;&gt;&lt;code&gt;hasmethod&lt;/code&gt;&lt;/a&gt;). This means they can only read global constants, and cannot have any side effects. In other words, they must be completely pure. Due to an implementation limitation, this also means that they currently cannot define a closure or generator.</source>
          <target state="translated">生成された関数は、してはならない&lt;em&gt;突然変異&lt;/em&gt;又は&lt;em&gt;観察&lt;/em&gt;任意の非定数グローバル（例えば、IO、ロック、非ローカル辞書を含む、又は使用状態&lt;a href=&quot;../../base/base/index#Base.hasmethod&quot;&gt; &lt;code&gt;hasmethod&lt;/code&gt; を&lt;/a&gt;）。つまり、グローバル定数のみを読み取ることができ、副作用はありません。つまり、完全に純粋でなければなりません。実装上の制限により、これは現在、クロージャーまたはジェネレーターを定義できないことも意味します。</target>
        </trans-unit>
        <trans-unit id="3ef0ab87b9316844c35d99faef219c9c7322d80c" translate="yes" xml:space="preserve">
          <source>Generated values can be filtered using the &lt;code&gt;if&lt;/code&gt; keyword:</source>
          <target state="translated">生成された値は、 &lt;code&gt;if&lt;/code&gt; キーワードを使用してフィルタリングできます。</target>
        </trans-unit>
        <trans-unit id="43a3b60a1f43668fa7df03ea6999eb9005534d03" translate="yes" xml:space="preserve">
          <source>Generates a copy of &lt;code&gt;A&lt;/code&gt; and removes stored numerical zeros from that copy, optionally trimming excess space from the result's &lt;code&gt;rowval&lt;/code&gt; and &lt;code&gt;nzval&lt;/code&gt; arrays when &lt;code&gt;trim&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; のコピーを生成し、そのコピーから保存されている数値のゼロを削除します。オプションで、 &lt;code&gt;trim&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、結果の &lt;code&gt;rowval&lt;/code&gt; および &lt;code&gt;nzval&lt;/code&gt; 配列から余分なスペースを削除します。</target>
        </trans-unit>
        <trans-unit id="aa8200a561dd1fd6d9a2571a09a8c0833fd591d2" translate="yes" xml:space="preserve">
          <source>Generates a copy of &lt;code&gt;x&lt;/code&gt; and removes numerical zeros from that copy, optionally trimming excess space from the result's &lt;code&gt;nzind&lt;/code&gt; and &lt;code&gt;nzval&lt;/code&gt; arrays when &lt;code&gt;trim&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; のコピーを生成し、そのコピーから数値のゼロを削除します。オプションで、 &lt;code&gt;trim&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、結果の &lt;code&gt;nzind&lt;/code&gt; および &lt;code&gt;nzval&lt;/code&gt; 配列から余分なスペースを削除します。</target>
        </trans-unit>
        <trans-unit id="1d35e347a9e9f11c97762e02cb3817fdf6492b95" translate="yes" xml:space="preserve">
          <source>Generates a gensym symbol for a variable. For example, &lt;code&gt;@gensym x y&lt;/code&gt; is transformed into &lt;code&gt;x = gensym(&quot;x&quot;); y = gensym(&quot;y&quot;)&lt;/code&gt;.</source>
          <target state="translated">変数のgensymシンボルを生成します。たとえば、 &lt;code&gt;@gensym x y&lt;/code&gt; は &lt;code&gt;x = gensym(&quot;x&quot;); y = gensym(&quot;y&quot;)&lt;/code&gt; 変換されます。y = gensym（ &quot;y&quot;）。</target>
        </trans-unit>
        <trans-unit id="82624d1ced08378811cc12e5b9bb3247c76bde71" translate="yes" xml:space="preserve">
          <source>Generates a symbol which will not conflict with other variable names.</source>
          <target state="translated">他の変数名と競合しないシンボルを生成します。</target>
        </trans-unit>
        <trans-unit id="6493dacd8d9340030628eff5048e31c32e36106f" translate="yes" xml:space="preserve">
          <source>Generates a version 1 (time-based) universally unique identifier (UUID), as specified by RFC 4122. Note that the Node ID is randomly generated (does not identify the host) according to section 4.5 of the RFC.</source>
          <target state="translated">RFC 4122 で規定されているように、バージョン 1 (時間ベース)の普遍的にユニークな識別子 (UUID)を生成します。ノードIDはRFCのセクション4.5に従ってランダムに生成される(ホストを識別しない)ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="5c0ffbf6fa6cd08065c3fd1e20d39e7262ac9916" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random or pseudo-random) universally unique identifier (UUID), as specified by RFC 4122.</source>
          <target state="translated">RFC 4122で規定されているように、バージョン4(ランダムまたは擬似ランダム)の普遍的にユニークな識別子(UUID)を生成します。</target>
        </trans-unit>
        <trans-unit id="6864e40d6120ff94e92379a41401cda33ec26eb1" translate="yes" xml:space="preserve">
          <source>Generates a version 5 (namespace and domain-based) universally unique identifier (UUID), as specified by RFC 4122.</source>
          <target state="translated">RFC 4122で規定されているように、バージョン5(名前空間およびドメインベース)の普遍的に一意な識別子(UUID)を生成します。</target>
        </trans-unit>
        <trans-unit id="31ad5eda3014502203f1f1c9f4f8ad8b0addc8bb" translate="yes" xml:space="preserve">
          <source>Generating random values of custom types</source>
          <target state="translated">カスタム型のランダム値の生成</target>
        </trans-unit>
        <trans-unit id="ea6d79a7c35cdb9d37f8d907393ca6d0663b71e9" translate="yes" xml:space="preserve">
          <source>Generating values for an &lt;code&gt;AbstractFloat&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;AbstractFloat&lt;/code&gt; タイプの値の生成</target>
        </trans-unit>
        <trans-unit id="79059f17dfecc212b29a403a6fe768eae1bb1610" translate="yes" xml:space="preserve">
          <source>Generating values from a collection</source>
          <target state="translated">コレクションから値を生成する</target>
        </trans-unit>
        <trans-unit id="5f32399dda528ab0f4979390ae10b103edb83e67" translate="yes" xml:space="preserve">
          <source>Generating values from a type</source>
          <target state="translated">型からの値の生成</target>
        </trans-unit>
        <trans-unit id="217dffa188c85186f3dde4d07c906c09c058f848" translate="yes" xml:space="preserve">
          <source>Generator Expressions</source>
          <target state="translated">ジェネレータ式</target>
        </trans-unit>
        <trans-unit id="111436dce43eef86f4f13a06226e540548b10b69" translate="yes" xml:space="preserve">
          <source>Generators (creation and seeding)</source>
          <target state="translated">ジェネレーター(作成・播種</target>
        </trans-unit>
        <trans-unit id="ab25cfdc66be945181ae90276749fb192703ddc0" translate="yes" xml:space="preserve">
          <source>Generators are implemented via inner functions. Just like inner functions used elsewhere in the language, variables from the enclosing scope can be &quot;captured&quot; in the inner function. For example, &lt;code&gt;sum(p[i] - q[i] for i=1:n)&lt;/code&gt; captures the three variables &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; from the enclosing scope. Captured variables can present performance challenges; see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;performance tips&lt;/a&gt;.</source>
          <target state="translated">ジェネレーターは内部関数を介して実装されます。言語の他の場所で使用されている内部関数と同様に、外側のスコープからの変数は、内部関数で「キャプチャ」できます。たとえば、 &lt;code&gt;sum(p[i] - q[i] for i=1:n)&lt;/code&gt; は、3つの変数 &lt;code&gt;p&lt;/code&gt; 、 &lt;code&gt;q&lt;/code&gt; 、および &lt;code&gt;n&lt;/code&gt; を外側のスコープからキャプチャします。キャプチャされた変数は、パフォーマンスの問題を引き起こす可能性があります。&lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;パフォーマンスのヒントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="83082f46072d254fd933bf6e78414552f2b12960" translate="yes" xml:space="preserve">
          <source>Generic Functions</source>
          <target state="translated">汎用関数</target>
        </trans-unit>
        <trans-unit id="2654c4b9018fcc37437c59923d4ac1eabf19c850" translate="yes" xml:space="preserve">
          <source>Generic equality operator. Falls back to &lt;a href=&quot;../base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt;. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding. For collections, &lt;code&gt;==&lt;/code&gt; is generally called recursively on all contents, though other properties (like the shape for arrays) may also be taken into account.</source>
          <target state="translated">ジェネリック等価演算子。&lt;a href=&quot;../base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; に&lt;/a&gt;フォールバックします。インスタンスが表す抽象値に基づいて、等しいという概念を持つすべての型に対して実装する必要があります。たとえば、すべての数値型は、型を無視して数値で比較されます。文字列は、エンコーディングを無視して、文字のシーケンスとして比較されます。コレクションの場合、 &lt;code&gt;==&lt;/code&gt; は一般にすべてのコンテンツで再帰的に呼び出されますが、他のプロパティ（配列の形状など）も考慮される場合があります。</target>
        </trans-unit>
        <trans-unit id="a247769c311d71434e7dbab7ffa2c58b32221569" translate="yes" xml:space="preserve">
          <source>Generic error type. The error message, in the &lt;code&gt;.msg&lt;/code&gt; field, may provide more specific details.</source>
          <target state="translated">一般的なエラーの種類。 &lt;code&gt;.msg&lt;/code&gt; フィールドのエラーメッセージは、より具体的な詳細を提供する場合があります。</target>
        </trans-unit>
        <trans-unit id="0a2cbe8ef5a6182effacad0728af04d3466e9419" translate="yes" xml:space="preserve">
          <source>Generically sized uniform scaling operator defined as a scalar times the identity operator, &lt;code&gt;&amp;lambda;*I&lt;/code&gt;. See also &lt;a href=&quot;#LinearAlgebra.I&quot;&gt;&lt;code&gt;I&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一般的なサイズの均一スケーリング演算子は、スカラーと単位演算子 &lt;code&gt;&amp;lambda;*I&lt;/code&gt; の積として定義されます。&lt;a href=&quot;#LinearAlgebra.I&quot;&gt; &lt;code&gt;I&lt;/code&gt; &lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="e7021447d5c6f5d07882ea34fcf74ffd494b65a7" translate="yes" xml:space="preserve">
          <source>Geometric Proportion</source>
          <target state="translated">幾何学的比例</target>
        </trans-unit>
        <trans-unit id="e505f741dc44890868c87aa48f3d8916c6fb0128" translate="yes" xml:space="preserve">
          <source>Geometrically Equal To</source>
          <target state="translated">幾何学的に等しい</target>
        </trans-unit>
        <trans-unit id="f64b845181c47fc7995221a47eaadce47af6bcc8" translate="yes" xml:space="preserve">
          <source>Geometrically Equivalent To</source>
          <target state="translated">幾何学的には</target>
        </trans-unit>
        <trans-unit id="30404c5812bd3cd0bc1e26c11cfbb33861e4d141" translate="yes" xml:space="preserve">
          <source>Geometrically Equivalent To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">幾何学的に等価なものと+ロングソリッドスオーバーレイ/ノンスペーシングロングスラッシュオーバーレイの組み合わせ</target>
        </trans-unit>
        <trans-unit id="ea2ac5cf7c4e856204e6a41aeaaa0b3dd4ef2ab5" translate="yes" xml:space="preserve">
          <source>Get Julia's process ID.</source>
          <target state="translated">ジュリアのプロセスIDを</target>
        </trans-unit>
        <trans-unit id="76117157c574ac5727a236f6277b1450a47c5f21" translate="yes" xml:space="preserve">
          <source>Get a backtrace object for the current program point.</source>
          <target state="translated">現在のプログラムポイントのバックトレースオブジェクトを取得します。</target>
        </trans-unit>
        <trans-unit id="6245e1b22dd874707de430f7178865b9a33deacf" translate="yes" xml:space="preserve">
          <source>Get a hash value for &lt;code&gt;x&lt;/code&gt; based on object identity. &lt;code&gt;objectid(x)==objectid(y)&lt;/code&gt; if &lt;code&gt;x === y&lt;/code&gt;.</source>
          <target state="translated">オブジェクトIDに基づいて &lt;code&gt;x&lt;/code&gt; のハッシュ値を取得します。 &lt;code&gt;objectid(x)==objectid(y)&lt;/code&gt; ( &lt;code&gt;x === y&lt;/code&gt; 場合）。</target>
        </trans-unit>
        <trans-unit id="594cb8bf35cce2c570e740ff46837e8b661e81ff" translate="yes" xml:space="preserve">
          <source>Get a list of all reference names in the &lt;code&gt;repo&lt;/code&gt; repository.</source>
          <target state="translated">内のすべての参照名のリストを取得 &lt;code&gt;repo&lt;/code&gt; リポジトリを。</target>
        </trans-unit>
        <trans-unit id="edea7d0cabb9a933daebe03151b03bacc57f2132" translate="yes" xml:space="preserve">
          <source>Get a list of all tags in the git repository &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">gitのリポジトリ内のすべてのタグのリストを取得 &lt;code&gt;repo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c83b8077da01523efd9ec95df9552f34eef56509" translate="yes" xml:space="preserve">
          <source>Get a module's enclosing &lt;code&gt;Module&lt;/code&gt;. &lt;code&gt;Main&lt;/code&gt; is its own parent.</source>
          <target state="translated">モジュールを囲む &lt;code&gt;Module&lt;/code&gt; を取得します。 &lt;code&gt;Main&lt;/code&gt; はそれ自身の親です。</target>
        </trans-unit>
        <trans-unit id="91aa8a1066c0cf259f10453272965a98317015dc" translate="yes" xml:space="preserve">
          <source>Get a string consisting of the first &lt;code&gt;n&lt;/code&gt; characters of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; の最初の &lt;code&gt;n&lt;/code&gt; 文字で構成される文字列を取得します。</target>
        </trans-unit>
        <trans-unit id="a14f2cfc2cb6c1c852e03fd6e4a706f0a47df06c" translate="yes" xml:space="preserve">
          <source>Get a string consisting of the last &lt;code&gt;n&lt;/code&gt; characters of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; の最後の &lt;code&gt;n&lt;/code&gt; 文字で構成される文字列を取得します。</target>
        </trans-unit>
        <trans-unit id="3372d98da97932978011accfa92cc350dd85fc43" translate="yes" xml:space="preserve">
          <source>Get a tuple or a vector of the properties (&lt;code&gt;x.property&lt;/code&gt;) of an object &lt;code&gt;x&lt;/code&gt;. This is typically the same as &lt;a href=&quot;#Base.fieldnames&quot;&gt;&lt;code&gt;fieldnames(typeof(x))&lt;/code&gt;&lt;/a&gt;, but types that overload &lt;a href=&quot;#Base.getproperty&quot;&gt;&lt;code&gt;getproperty&lt;/code&gt;&lt;/a&gt; should generally overload &lt;code&gt;propertynames&lt;/code&gt; as well to get the properties of an instance of the type.</source>
          <target state="translated">オブジェクト &lt;code&gt;x&lt;/code&gt; のプロパティ（ &lt;code&gt;x.property&lt;/code&gt; ）のタプルまたはベクトルを取得します。これは、典型的には同じである&lt;a href=&quot;#Base.fieldnames&quot;&gt; &lt;code&gt;fieldnames(typeof(x))&lt;/code&gt; &lt;/a&gt;が、過負荷ことタイプ&lt;a href=&quot;#Base.getproperty&quot;&gt; &lt;code&gt;getproperty&lt;/code&gt; &lt;/a&gt;、一般的に過負荷べき &lt;code&gt;propertynames&lt;/code&gt; のタイプのインスタンスのプロパティを取得するだけでなく。</target>
        </trans-unit>
        <trans-unit id="42f453edc0370fb274422ead5407c2776b31db1f" translate="yes" xml:space="preserve">
          <source>Get a tuple with the names of the fields of a &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DataType&lt;/code&gt; のフィールドの名前を含むタプルを取得します。</target>
        </trans-unit>
        <trans-unit id="d530106390fd810b016b6212bad35ad44f20a8f4" translate="yes" xml:space="preserve">
          <source>Get an IP address of the local machine of the specified type. Throws if no addresses of the specified type are available.</source>
          <target state="translated">指定された型のローカルマシンのIPアドレスを取得します。指定された型のアドレスがない場合にスローされます。</target>
        </trans-unit>
        <trans-unit id="7cad9add4d27400ccccd1e83a0b5fe65f627675d" translate="yes" xml:space="preserve">
          <source>Get an IP address of the local machine, preferring IPv4 over IPv6. Throws if no addresses are available.</source>
          <target state="translated">ローカルマシンのIPアドレスを取得します。利用可能なアドレスがない場合にスローされます。</target>
        </trans-unit>
        <trans-unit id="d1b1f967961007a8e3404abb4f0fb2c9b3d00448" translate="yes" xml:space="preserve">
          <source>Get an array of the names exported by a &lt;code&gt;Module&lt;/code&gt;, excluding deprecated names. If &lt;code&gt;all&lt;/code&gt; is true, then the list also includes non-exported names defined in the module, deprecated names, and compiler-generated names. If &lt;code&gt;imported&lt;/code&gt; is true, then names explicitly imported from other modules are also included.</source>
          <target state="translated">非推奨の名前を除いて、 &lt;code&gt;Module&lt;/code&gt; によってエクスポートされた名前の配列を取得します。 &lt;code&gt;all&lt;/code&gt; がtrueの場合、リストには、モジュールで定義されたエクスポートされていない名前、廃止された名前、コンパイラによって生成された名前も含まれます。場合は &lt;code&gt;imported&lt;/code&gt; 真である場合、明示的に他のモジュールからインポートの名前も含まれています。</target>
        </trans-unit>
        <trans-unit id="171cab21a362e3fe558e803f2cb2a0d2a8e62a11" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;Module&lt;/code&gt; of the toplevel eval, which is the &lt;code&gt;Module&lt;/code&gt; code is currently being read from.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; コードが現在読み取られている最上位evalの &lt;code&gt;Module&lt;/code&gt; を取得します。</target>
        </trans-unit>
        <trans-unit id="7881586bad23ccbb959e0086fba3cebe29d398b8" translate="yes" xml:space="preserve">
          <source>Get the &lt;em&gt;fetch&lt;/em&gt; refspecs for the specified &lt;code&gt;rmt&lt;/code&gt;. These refspecs contain information about which branch(es) to fetch from.</source>
          <target state="translated">ゲット&lt;em&gt;フェッチ&lt;/em&gt;指定されたためrefspecs &lt;code&gt;rmt&lt;/code&gt; 。これらのrefspecには、どのブランチからフェッチするかに関する情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="f2abefd55e48cb868afd9b2bbc8365ad10b4fa4f" translate="yes" xml:space="preserve">
          <source>Get the &lt;em&gt;push&lt;/em&gt; refspecs for the specified &lt;code&gt;rmt&lt;/code&gt;. These refspecs contain information about which branch(es) to push to.</source>
          <target state="translated">指定された &lt;code&gt;rmt&lt;/code&gt; の&lt;em&gt;プッシュ&lt;/em&gt;参照仕様を取得します。これらのrefspecには、プッシュ先のブランチに関する情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="0ec8068370cc3ffbb8329c71ce1fa5a1af831971" translate="yes" xml:space="preserve">
          <source>Get the ID number of the current thread of execution. The master thread has ID &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">現在の実行スレッドのID番号を取得します。マスタースレッドのIDは &lt;code&gt;1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="899b97d6f0cff7934c3aa84ef79f50d77403aeb3" translate="yes" xml:space="preserve">
          <source>Get the IP address and port of the remote endpoint that the given socket is connected to. Valid only for connected TCP sockets.</source>
          <target state="translated">指定したソケットが接続されているリモートエンドポイントの IP アドレスとポートを取得します。接続されているTCPソケットに対してのみ有効です。</target>
        </trans-unit>
        <trans-unit id="b30337efd6e1ddf333502df0ba154f1bbe883302" translate="yes" xml:space="preserve">
          <source>Get the IP address and port that the given socket is bound to.</source>
          <target state="translated">指定したソケットがバインドされているIPアドレスとポートを取得します。</target>
        </trans-unit>
        <trans-unit id="ae34bdec6f00934e072471fe83b1ec1bb0253d9e" translate="yes" xml:space="preserve">
          <source>Get the IP addresses of the local machine of the specified type.</source>
          <target state="translated">指定したタイプのローカルマシンのIPアドレスを取得します。</target>
        </trans-unit>
        <trans-unit id="80e3f3bd81b00cd5fdff2163bfb439bea6bf2f6a" translate="yes" xml:space="preserve">
          <source>Get the IPv4 addresses of the local machine.</source>
          <target state="translated">ローカルマシンのIPv4アドレスを取得します。</target>
        </trans-unit>
        <trans-unit id="fc0c58665e06f4bcac50a3a051a380e40687f694" translate="yes" xml:space="preserve">
          <source>Get the additive identity element for the type of &lt;code&gt;x&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt; can also specify the type itself).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; のタイプの追加のアイデンティティー要素を取得します（ &lt;code&gt;x&lt;/code&gt; はタイプ自体も指定できます）。</target>
        </trans-unit>
        <trans-unit id="13d05d3446c1b045371ca3c580a406fe6efa3a85" translate="yes" xml:space="preserve">
          <source>Get the backtrace of the current exception, for use within &lt;code&gt;catch&lt;/code&gt; blocks.</source>
          <target state="translated">現在の例外のバックトレースを取得し、 &lt;code&gt;catch&lt;/code&gt; ブロック内で使用します。</target>
        </trans-unit>
        <trans-unit id="d0b515694c2e31069f75a4341701ebdddc0dbcfa" translate="yes" xml:space="preserve">
          <source>Get the child process ID, if it still exists.</source>
          <target state="translated">子プロセスIDを取得します。</target>
        </trans-unit>
        <trans-unit id="b7046c13174456af8138867bb2456e8e9106c14f" translate="yes" xml:space="preserve">
          <source>Get the concrete type of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の具象型を取得します。</target>
        </trans-unit>
        <trans-unit id="47ebb15e57ce473b474a7f913ff4aa9d19236677" translate="yes" xml:space="preserve">
          <source>Get the current floating point rounding mode for type &lt;code&gt;T&lt;/code&gt;, controlling the rounding of basic arithmetic functions (&lt;a href=&quot;../math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;a href=&quot;../math/index#Base.:/&quot;&gt;&lt;code&gt;/&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;sqrt&lt;/code&gt;) and type conversion.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; の現在の浮動小数点丸めモードを取得し、基本的な算術関数（&lt;a href=&quot;../math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、&lt;a href=&quot;../math/index#Base.:/&quot;&gt; &lt;code&gt;/&lt;/code&gt; &lt;/a&gt;および &lt;code&gt;sqrt&lt;/code&gt; ）の丸めとタイプ変換を制御します。</target>
        </trans-unit>
        <trans-unit id="054e0f64d6af85ef39cd5689d518feb6140528b2" translate="yes" xml:space="preserve">
          <source>Get the current position of a stream.</source>
          <target state="translated">ストリームの現在位置を取得します。</target>
        </trans-unit>
        <trans-unit id="7d101e5841a77867eef23ee238263d38f724a6f3" translate="yes" xml:space="preserve">
          <source>Get the current working directory.</source>
          <target state="translated">現在の作業ディレクトリを取得します。</target>
        </trans-unit>
        <trans-unit id="b150736a9f570c696c7e152a5f442d80d1bfe707" translate="yes" xml:space="preserve">
          <source>Get the currently running &lt;a href=&quot;#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在実行中の&lt;a href=&quot;#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;取得します。</target>
        </trans-unit>
        <trans-unit id="307991aa1f7f375be076c27a6b5e16a8e43f1f24" translate="yes" xml:space="preserve">
          <source>Get the directory part of a path. Trailing characters ('/' or '\') in the path are counted as part of the path.</source>
          <target state="translated">パスのディレクトリ部分を取得します。パス内の末尾の文字 ('/' または '\')は、パスの一部としてカウントされます。</target>
        </trans-unit>
        <trans-unit id="15803f5611fdfd7a4570ea4b6299230e231b89c3" translate="yes" xml:space="preserve">
          <source>Get the exponent of a normalized floating-point number.</source>
          <target state="translated">正規化された浮動小数点数の指数を取得します。</target>
        </trans-unit>
        <trans-unit id="428d1e51e8fd8658370395752d8d28b03956207a" translate="yes" xml:space="preserve">
          <source>Get the fetch URL of a remote git repository.</source>
          <target state="translated">リモートの git リポジトリのフェッチ URL を取得します。</target>
        </trans-unit>
        <trans-unit id="6395adf311f39b7041b3bc31800f3ac3ac69f04a" translate="yes" xml:space="preserve">
          <source>Get the file name part of a path.</source>
          <target state="translated">パスのファイル名部分を取得します。</target>
        </trans-unit>
        <trans-unit id="45d031a98e3d7988439346e5f12753ad44f6564c" translate="yes" xml:space="preserve">
          <source>Get the first element of an iterable collection. Return the start point of an &lt;a href=&quot;#Base.AbstractRange&quot;&gt;&lt;code&gt;AbstractRange&lt;/code&gt;&lt;/a&gt; even if it is empty.</source>
          <target state="translated">反復可能なコレクションの最初の要素を取得します。空の場合でも、&lt;a href=&quot;#Base.AbstractRange&quot;&gt; &lt;code&gt;AbstractRange&lt;/code&gt; の&lt;/a&gt;開始点を返します。</target>
        </trans-unit>
        <trans-unit id="803a6a556ee1107f53d846bba76956752d4f95be" translate="yes" xml:space="preserve">
          <source>Get the fully-qualified name of a module as a tuple of symbols. For example,</source>
          <target state="translated">モジュールの完全修飾名をシンボルのタプルとして取得します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="9fe2dd6fafde9402b9bebe656d7e76ff3412ff6a" translate="yes" xml:space="preserve">
          <source>Get the git object to which &lt;code&gt;te&lt;/code&gt; refers and return it as its actual type (the type &lt;a href=&quot;#LibGit2.entrytype&quot;&gt;&lt;code&gt;entrytype&lt;/code&gt;&lt;/a&gt; would show), for instance a &lt;code&gt;GitBlob&lt;/code&gt; or &lt;code&gt;GitTag&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;te&lt;/code&gt; が参照するgitオブジェクトを取得し、それを実際のタイプ（&lt;a href=&quot;#LibGit2.entrytype&quot;&gt; &lt;code&gt;entrytype&lt;/code&gt; &lt;/a&gt;のタイプで示される）として &lt;code&gt;GitTag&lt;/code&gt; ます。たとえば、 &lt;code&gt;GitBlob&lt;/code&gt; またはGitTagです。</target>
        </trans-unit>
        <trans-unit id="353f9fc88dc058135091370ad6a5d9c59fcfda6e" translate="yes" xml:space="preserve">
          <source>Get the id of the current process.</source>
          <target state="translated">現在のプロセスの ID を取得します。</target>
        </trans-unit>
        <trans-unit id="4e1a5fc780c8cf7e7bc238f6885dd2ba9bd5e31b" translate="yes" xml:space="preserve">
          <source>Get the key type of an dictionary type. Behaves similarly to &lt;a href=&quot;#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">辞書タイプのキータイプを取得します。&lt;a href=&quot;#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt;と同様に動作します。</target>
        </trans-unit>
        <trans-unit id="7db9e0d4b309f243e7497e360f841540e11cc1fa" translate="yes" xml:space="preserve">
          <source>Get the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling &lt;a href=&quot;#Base.lastindex&quot;&gt;&lt;code&gt;lastindex&lt;/code&gt;&lt;/a&gt; to get the last index. Return the end point of an &lt;a href=&quot;#Base.AbstractRange&quot;&gt;&lt;code&gt;AbstractRange&lt;/code&gt;&lt;/a&gt; even if it is empty.</source>
          <target state="translated">O（1）時間で計算できる場合、順序付けられたコレクションの最後の要素を取得します。これを行うには、&lt;a href=&quot;#Base.lastindex&quot;&gt; &lt;code&gt;lastindex&lt;/code&gt; &lt;/a&gt;を呼び出して最後のインデックスを取得します。空の場合でも、&lt;a href=&quot;#Base.AbstractRange&quot;&gt; &lt;code&gt;AbstractRange&lt;/code&gt; の&lt;/a&gt;終点を返します。</target>
        </trans-unit>
        <trans-unit id="acd04aae132c80a71e1f513a908b2702371aa23c" translate="yes" xml:space="preserve">
          <source>Get the local machine's host name.</source>
          <target state="translated">ローカルマシンのホスト名を取得します。</target>
        </trans-unit>
        <trans-unit id="7880b6703d5b76a9fbb2e0506acfbba24be95f11" translate="yes" xml:space="preserve">
          <source>Get the memory address of a Julia object as a &lt;code&gt;Ptr&lt;/code&gt;. The existence of the resulting &lt;code&gt;Ptr&lt;/code&gt; will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the &lt;code&gt;Ptr&lt;/code&gt; will be used.</source>
          <target state="translated">Juliaオブジェクトのメモリアドレスを &lt;code&gt;Ptr&lt;/code&gt; として取得します。結果としての存在 &lt;code&gt;Ptr&lt;/code&gt; 、オブジェクトの遺跡があること全体の時間のために参照することを保証しなければならないので、ガベージコレクションからオブジェクトを保護しません &lt;code&gt;Ptr&lt;/code&gt; 使用されます。</target>
        </trans-unit>
        <trans-unit id="563766b2618b2d015ed0e9c3d29a5e7becea72bb" translate="yes" xml:space="preserve">
          <source>Get the name of a (potentially &lt;code&gt;UnionAll&lt;/code&gt;-wrapped) &lt;code&gt;DataType&lt;/code&gt; (without its parent module) as a symbol.</source>
          <target state="translated">（潜在的に &lt;code&gt;UnionAll&lt;/code&gt; でラップされた） &lt;code&gt;DataType&lt;/code&gt; の名前（親モジュールなし）をシンボルとして取得します。</target>
        </trans-unit>
        <trans-unit id="52de91388eb956065955884b6eac39cce6e61088" translate="yes" xml:space="preserve">
          <source>Get the name of a &lt;code&gt;Module&lt;/code&gt; as a &lt;a href=&quot;#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; の名前を&lt;a href=&quot;#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt;として取得します。</target>
        </trans-unit>
        <trans-unit id="d8a8ebbac78211cc23fd2af9d0c3c21bb5d703fa" translate="yes" xml:space="preserve">
          <source>Get the name of a generic &lt;code&gt;Function&lt;/code&gt; as a symbol, or &lt;code&gt;:anonymous&lt;/code&gt;.</source>
          <target state="translated">汎用 &lt;code&gt;Function&lt;/code&gt; 名前をシンボルとして、または &lt;code&gt;:anonymous&lt;/code&gt; として取得します。</target>
        </trans-unit>
        <trans-unit id="b5308e8edde6c7f90f89dc8b80d1be8f9e4aed1b" translate="yes" xml:space="preserve">
          <source>Get the name of a remote repository, for instance &lt;code&gt;&quot;origin&quot;&lt;/code&gt;. If the remote is anonymous (see &lt;a href=&quot;#LibGit2.GitRemoteAnon&quot;&gt;&lt;code&gt;GitRemoteAnon&lt;/code&gt;&lt;/a&gt;) the name will be an empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">リモートリポジトリの名前を取得します（例： &lt;code&gt;&quot;origin&quot;&lt;/code&gt; )。リモートが匿名の場合（&lt;a href=&quot;#LibGit2.GitRemoteAnon&quot;&gt; &lt;code&gt;GitRemoteAnon&lt;/code&gt; を&lt;/a&gt;参照）、名前は空の文字列 &lt;code&gt;&quot;&quot;&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="d9cf8794c830b5b5477bd4dd5127e438a0a336f9" translate="yes" xml:space="preserve">
          <source>Get the name of field &lt;code&gt;i&lt;/code&gt; of a &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">フィールドの名前を取得し &lt;code&gt;i&lt;/code&gt; の &lt;code&gt;DataType&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f05b4e05331b196f379ecdeee8aa391e63dd1631" translate="yes" xml:space="preserve">
          <source>Get the native address of an array or string, optionally at a given location &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">配列または文字列のネイティブアドレスを取得し &lt;code&gt;index&lt;/code&gt; 。オプションで、指定された場所のインデックスにあります。</target>
        </trans-unit>
        <trans-unit id="67e6a2296c5e9b9545d8ce6e5fe670e01fcb2193" translate="yes" xml:space="preserve">
          <source>Get the number of available processes.</source>
          <target state="translated">利用可能なプロセス数を取得します。</target>
        </trans-unit>
        <trans-unit id="6c54bfd12378fd187e6fdf88c8f9a891fd352b8a" translate="yes" xml:space="preserve">
          <source>Get the number of available worker processes. This is one less than &lt;a href=&quot;#Distributed.nprocs&quot;&gt;&lt;code&gt;nprocs()&lt;/code&gt;&lt;/a&gt;. Equal to &lt;code&gt;nprocs()&lt;/code&gt; if &lt;code&gt;nprocs() == 1&lt;/code&gt;.</source>
          <target state="translated">利用可能なワーカープロセスの数を取得します。これは&lt;a href=&quot;#Distributed.nprocs&quot;&gt; &lt;code&gt;nprocs()&lt;/code&gt; &lt;/a&gt;よりも1つ少ない値です。 &lt;code&gt;nprocs() == 1&lt;/code&gt; 場合、 &lt;code&gt;nprocs()&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="9d316efb69571072b7b698b64013b0df989b23e2" translate="yes" xml:space="preserve">
          <source>Get the number of fields in the given object.</source>
          <target state="translated">与えられたオブジェクトのフィールド数を取得します。</target>
        </trans-unit>
        <trans-unit id="a93c91e8128e4c3c8ef281740f30c00304272fd2" translate="yes" xml:space="preserve">
          <source>Get the number of fields that an instance of the given type would have. An error is thrown if the type is too abstract to determine this.</source>
          <target state="translated">与えられた型のインスタンスが持つであろうフィールドの数を取得します。型が抽象的すぎて決定できない場合はエラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="d3677eab3b97fd3c65939b3bc5a15f59d44d4af9" translate="yes" xml:space="preserve">
          <source>Get the number of threads available to the Julia process. This is the inclusive upper bound on &lt;code&gt;threadid()&lt;/code&gt;.</source>
          <target state="translated">Juliaプロセスで使用可能なスレッドの数を取得します。これは &lt;code&gt;threadid()&lt;/code&gt; の包括的な上限です。</target>
        </trans-unit>
        <trans-unit id="3b55f78480b3149c80bfc50e1a7d85e6fa50c73b" translate="yes" xml:space="preserve">
          <source>Get the permissions of the owner of the file as a bitfield of</source>
          <target state="translated">のビットフィールドとしてファイルの所有者のパーミッションを取得します。</target>
        </trans-unit>
        <trans-unit id="c5f291709146a9a504c67d3dc2b280d4f865a715" translate="yes" xml:space="preserve">
          <source>Get the precision (in bits) currently used for &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; arithmetic.</source>
          <target state="translated">&lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;演算で現在使用されている精度（ビット単位）を取得します。</target>
        </trans-unit>
        <trans-unit id="3ec48750990030ca792131bcde102c3d937ba66e" translate="yes" xml:space="preserve">
          <source>Get the precision of a floating point number, as defined by the effective number of bits in the mantissa.</source>
          <target state="translated">浮動小数点数の精度を取得します。</target>
        </trans-unit>
        <trans-unit id="13a1d9961dcbce8522f507a9d605791c91380396" translate="yes" xml:space="preserve">
          <source>Get the process title. On some systems, will always return an empty string.</source>
          <target state="translated">プロセスのタイトルを取得します。いくつかのシステムでは、常に空の文字列を返します。</target>
        </trans-unit>
        <trans-unit id="8d97afd1ec5aab5d2f47ff664bcaf7b5f14afb9a" translate="yes" xml:space="preserve">
          <source>Get the stack of exceptions currently being handled. For nested catch blocks there may be more than one current exception in which case the most recently thrown exception is last in the stack. The stack is returned as a Vector of &lt;code&gt;(exception,backtrace)&lt;/code&gt; pairs, or a Vector of exceptions if &lt;code&gt;include_bt&lt;/code&gt; is false.</source>
          <target state="translated">現在処理されている例外のスタックを取得します。ネストされたcatchブロックの場合、現在の例外が複数存在する場合があります。その場合、最後にスローされた例外はスタックの最後です。スタックは &lt;code&gt;(exception,backtrace)&lt;/code&gt; ペアのベクターとして、または &lt;code&gt;include_bt&lt;/code&gt; がfalseの場合は例外のベクターとして返されます。</target>
        </trans-unit>
        <trans-unit id="857485ff0b5ba0b2460dd06bb700b67ed684fb9b" translate="yes" xml:space="preserve">
          <source>Get the stage number of &lt;code&gt;ie&lt;/code&gt;. The stage number &lt;code&gt;0&lt;/code&gt; represents the current state of the working tree, but other numbers can be used in the case of a merge conflict. In such a case, the various stage numbers on an &lt;code&gt;IndexEntry&lt;/code&gt; describe which side(s) of the conflict the current state of the file belongs to. Stage &lt;code&gt;0&lt;/code&gt; is the state before the attempted merge, stage &lt;code&gt;1&lt;/code&gt; is the changes which have been made locally, stages &lt;code&gt;2&lt;/code&gt; and larger are for changes from other branches (for instance, in the case of a multi-branch &quot;octopus&quot; merge, stages &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, and &lt;code&gt;4&lt;/code&gt; might be used).</source>
          <target state="translated">&lt;code&gt;ie&lt;/code&gt; のステージ番号を取得します。ステージ番号 &lt;code&gt;0&lt;/code&gt; は作業ツリーの現在の状態を表しますが、マージの競合が発生した場合は他の番号を使用できます。このような場合、 &lt;code&gt;IndexEntry&lt;/code&gt; のさまざまなステージ番号は、ファイルの現在の状態が競合のどちら側に属しているかを示します。ステージ &lt;code&gt;0&lt;/code&gt; はマージ前の状態、ステージ &lt;code&gt;1&lt;/code&gt; はローカルで行われた変更、ステージ &lt;code&gt;2&lt;/code&gt; 以上は他のブランチからの変更用です（たとえば、マルチブランチの「タコ」マージの場合、ステージ &lt;code&gt;2&lt;/code&gt; 、 &lt;code&gt;3&lt;/code&gt; 、および &lt;code&gt;4&lt;/code&gt; が使用される場合があります）。</target>
        </trans-unit>
        <trans-unit id="129f24b071e084dab9af722a0959ecf2337e059d" translate="yes" xml:space="preserve">
          <source>Get the step size of an &lt;a href=&quot;#Base.AbstractRange&quot;&gt;&lt;code&gt;AbstractRange&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;#Base.AbstractRange&quot;&gt; &lt;code&gt;AbstractRange&lt;/code&gt; &lt;/a&gt;オブジェクトのステップサイズを取得します。</target>
        </trans-unit>
        <trans-unit id="8858aa789b8a95e917ca5b8edf3cb4cfb4672953" translate="yes" xml:space="preserve">
          <source>Get the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.</source>
          <target state="translated">かなり高い(一般的にはマイクロ秒)分解能で、エポックからのシステム時間を秒単位で取得します。</target>
        </trans-unit>
        <trans-unit id="95239b12c16c016f41ece1f43f66824450caaa42" translate="yes" xml:space="preserve">
          <source>Get the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.</source>
          <target state="translated">ナノ秒単位で時間を取得します。0に対応する時間は未定義で、5.8年ごとにラップします。</target>
        </trans-unit>
        <trans-unit id="b24f1d764ec96114bfff224327fcd8d0d0abdd31" translate="yes" xml:space="preserve">
          <source>Get the total free memory in RAM in kilobytes.</source>
          <target state="translated">RAM の空きメモリの合計をキロバイト単位で取得します。</target>
        </trans-unit>
        <trans-unit id="d5e4ce0e0a7ea7ef86f926adb946a71d925d5beb" translate="yes" xml:space="preserve">
          <source>Get the total memory in RAM (including that which is currently used) in kilobytes.</source>
          <target state="translated">RAM内のメモリ(現在使用されているものを含む)の合計をキロバイト単位で取得します。</target>
        </trans-unit>
        <trans-unit id="e98e2a89d68b00f3fd77d6a63a6d2c70dc724cf3" translate="yes" xml:space="preserve">
          <source>Get the value of the C library's &lt;code&gt;errno&lt;/code&gt;. If an argument is specified, it is used to set the value of &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">Cライブラリの &lt;code&gt;errno&lt;/code&gt; の値を取得します。引数が指定されている場合、それを使用して &lt;code&gt;errno&lt;/code&gt; の値を設定します。</target>
        </trans-unit>
        <trans-unit id="c2268d21fbee620aaff052e88aa0c0825d399931" translate="yes" xml:space="preserve">
          <source>Get the value type of an dictionary type. Behaves similarly to &lt;a href=&quot;#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">辞書型の値型を取得します。&lt;a href=&quot;#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt;と同様に動作します。</target>
        </trans-unit>
        <trans-unit id="9d8ca9fec9f5e29ac3cbc1f3abc652c135b52ec1" translate="yes" xml:space="preserve">
          <source>Get the vector of processes mapping the shared array.</source>
          <target state="translated">共有配列をマッピングしたプロセスのベクトルを取得します。</target>
        </trans-unit>
        <trans-unit id="db2afe93edd474fc522d8c7d75cb7a001e5b61fe" translate="yes" xml:space="preserve">
          <source>Gets all of the IP addresses of the &lt;code&gt;host&lt;/code&gt;. Uses the operating system's underlying &lt;code&gt;getaddrinfo&lt;/code&gt; implementation, which may do a DNS lookup.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; すべてのIPアドレスを取得します。オペレーティングシステムの基盤となる &lt;code&gt;getaddrinfo&lt;/code&gt; 実装を使用します。DNSルックアップを実行できます。</target>
        </trans-unit>
        <trans-unit id="a284592991f22190fd532a8317fc543ce797cfe4" translate="yes" xml:space="preserve">
          <source>Gets the first IP address of the &lt;code&gt;host&lt;/code&gt; of the specified &lt;code&gt;IPAddr&lt;/code&gt; type. Uses the operating system's underlying getaddrinfo implementation, which may do a DNS lookup.</source>
          <target state="translated">指定された &lt;code&gt;IPAddr&lt;/code&gt; タイプの &lt;code&gt;host&lt;/code&gt; 最初のIPアドレスを取得します。オペレーティングシステムの基盤となるgetaddrinfo実装を使用します。DNSルックアップを実行できます。</target>
        </trans-unit>
        <trans-unit id="a7f3acf6ca590093170d5ddc3c9107d6f1324074" translate="yes" xml:space="preserve">
          <source>Getting Around</source>
          <target state="translated">移動手段</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">はじめに</target>
        </trans-unit>
        <trans-unit id="04ccf152a8a13833ef0a70fb0a973a671f0ea746" translate="yes" xml:space="preserve">
          <source>Getting the hygiene rules correct can be a formidable challenge. Before using a macro, you might want to consider whether a function closure would be sufficient. Another useful strategy is to defer as much work as possible to runtime. For example, many macros simply wrap their arguments in a &lt;code&gt;QuoteNode&lt;/code&gt; or other similar &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt;. Some examples of this include &lt;code&gt;@task body&lt;/code&gt; which simply returns &lt;code&gt;schedule(Task(() -&amp;gt; $body))&lt;/code&gt;, and &lt;code&gt;@eval expr&lt;/code&gt;, which simply returns &lt;code&gt;eval(QuoteNode(expr))&lt;/code&gt;.</source>
          <target state="translated">衛生規則を正しくすることは、手ごわい課題です。マクロを使用する前に、関数のクロージャで十分かどうかを検討する必要があります。もう1つの便利な戦略は、できるだけ多くの作業を実行時まで延期することです。たとえば、多くのマクロは、単に引数を &lt;code&gt;QuoteNode&lt;/code&gt; または他の同様の&lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; に&lt;/a&gt;ラップします。これのいくつかの例としては、 &lt;code&gt;@task body&lt;/code&gt; 単に返す &lt;code&gt;schedule(Task(() -&amp;gt; $body))&lt;/code&gt; 、および &lt;code&gt;@eval expr&lt;/code&gt; 単に返し、 &lt;code&gt;eval(QuoteNode(expr))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf44c9857b696454c5ef1ca708da5e3ee8a0b24a" translate="yes" xml:space="preserve">
          <source>Ghost</source>
          <target state="translated">Ghost</target>
        </trans-unit>
        <trans-unit id="4a4c89342a61073746cb0be5c482a4f233f70856" translate="yes" xml:space="preserve">
          <source>Gimel Symbol / Third Transfinite Cardinal</source>
          <target state="translated">ギメルシンボル/第三トランスフィニットカーディナル</target>
        </trans-unit>
        <trans-unit id="29fb58174b748291968c938f5144e432d7a05bc1" translate="yes" xml:space="preserve">
          <source>Girl</source>
          <target state="translated">Girl</target>
        </trans-unit>
        <trans-unit id="585f3a3c7ecf6be9b08fcb5c41bd3f7b4064386b" translate="yes" xml:space="preserve">
          <source>Give a hint to the compiler that this function is worth inlining.</source>
          <target state="translated">この関数がインライン化する価値があるというヒントをコンパイラに与えます。</target>
        </trans-unit>
        <trans-unit id="f9f77d5a362582fb87b0f06e19b1b57c8b1806c3" translate="yes" xml:space="preserve">
          <source>Give the number of columns needed to print a character.</source>
          <target state="translated">文字を印刷するのに必要な列数を与えます。</target>
        </trans-unit>
        <trans-unit id="d66cd5d2057c5b56255474647800cbbea7c7ec15" translate="yes" xml:space="preserve">
          <source>Give the number of columns needed to print a string.</source>
          <target state="translated">文字列を印刷するのに必要な列数を与えます。</target>
        </trans-unit>
        <trans-unit id="990b49394e3cec090496333dd6dda71ca867283b" translate="yes" xml:space="preserve">
          <source>Given a &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;-like function &lt;code&gt;writefunc&lt;/code&gt;, which takes an I/O stream as its first argument, &lt;code&gt;base64encode(writefunc, args...)&lt;/code&gt; calls &lt;code&gt;writefunc&lt;/code&gt; to write &lt;code&gt;args...&lt;/code&gt; to a base64-encoded string, and returns the string. &lt;code&gt;base64encode(args...)&lt;/code&gt; is equivalent to &lt;code&gt;base64encode(write, args...)&lt;/code&gt;: it converts its arguments into bytes using the standard &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; functions and returns the base64-encoded string.</source>
          <target state="translated">最初の引数としてI / Oストリームを &lt;code&gt;writefunc&lt;/code&gt; する&lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;ような関数writefuncを指定すると、 &lt;code&gt;base64encode(writefunc, args...)&lt;/code&gt; は &lt;code&gt;writefunc&lt;/code&gt; を呼び出して、 &lt;code&gt;args...&lt;/code&gt; をbase64でエンコードされた文字列に書き込み、文字列を返します。 &lt;code&gt;base64encode(args...)&lt;/code&gt; は &lt;code&gt;base64encode(write, args...)&lt;/code&gt; args ...）と同等です。標準の&lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;関数を使用して引数をバイトに変換し、base64でエンコードされた文字列を返します。</target>
        </trans-unit>
        <trans-unit id="f3d33bb8ba673cca2a309308e1c04181d32a390f" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;Ptr{T}&lt;/code&gt;, the contents of type &lt;code&gt;T&lt;/code&gt; can generally be copied from the referenced memory into a Julia object using &lt;code&gt;unsafe_load(ptr, [index])&lt;/code&gt;. The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar to the behavior of &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; (e.g. &lt;code&gt;[]&lt;/code&gt; access syntax).</source>
          <target state="translated">所与 &lt;code&gt;Ptr{T}&lt;/code&gt; 、型の内容 &lt;code&gt;T&lt;/code&gt; は、一般に使用ジュリアオブジェクトに参照されるメモリからコピーすることができる &lt;code&gt;unsafe_load(ptr, [index])&lt;/code&gt; 。 index引数はオプションであり（デフォルトは1）、1ベースのインデックス付けのJulia規約に従います。この関数は、意図的に&lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;およびsetindexの動作に似ています&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;（例えば &lt;code&gt;[]&lt;/code&gt; アクセス構文）。</target>
        </trans-unit>
        <trans-unit id="9276b00b5b100003171aa4d1b53dddc58e924e43" translate="yes" xml:space="preserve">
          <source>Given a collection type &lt;code&gt;S&lt;/code&gt;, it's currently assumed that if &lt;code&gt;rand(::S)&lt;/code&gt; is defined, an object of type &lt;code&gt;eltype(S)&lt;/code&gt; will be produced. In order to define random generation out of objects of type &lt;code&gt;S&lt;/code&gt;, the following method can be defined: &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt;. Here, &lt;code&gt;sp&lt;/code&gt; simply wraps an object of type &lt;code&gt;S&lt;/code&gt;, which can be accessed via &lt;code&gt;sp[]&lt;/code&gt;. Continuing the &lt;code&gt;Die&lt;/code&gt; example, we want now to define &lt;code&gt;rand(d::Die)&lt;/code&gt; to produce an &lt;code&gt;Int&lt;/code&gt; corresponding to one of &lt;code&gt;d&lt;/code&gt;'s sides:</source>
          <target state="translated">コレクションタイプ &lt;code&gt;S&lt;/code&gt; が与えられた場合、現在、 &lt;code&gt;rand(::S)&lt;/code&gt; が定義されている場合、タイプ &lt;code&gt;eltype(S)&lt;/code&gt; のオブジェクトが生成されると想定されています。タイプ &lt;code&gt;S&lt;/code&gt; のオブジェクトからランダム生成を定義するには、次のメソッドを定義できます： &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt; 。ここで、 &lt;code&gt;sp&lt;/code&gt; は単純に &lt;code&gt;S&lt;/code&gt; 型のオブジェクトをラップします。これは、 &lt;code&gt;sp[]&lt;/code&gt; 介してアクセスできます。 &lt;code&gt;Die&lt;/code&gt; の例を続けて、今度は &lt;code&gt;rand(d::Die)&lt;/code&gt; を定義して、 &lt;code&gt;d&lt;/code&gt; の側面の1つに対応する &lt;code&gt;Int&lt;/code&gt; を生成します。</target>
        </trans-unit>
        <trans-unit id="c4f1730c953eabcee66d16110ac2417f817ee88b" translate="yes" xml:space="preserve">
          <source>Given a dictionary &lt;code&gt;D&lt;/code&gt;, the syntax &lt;code&gt;D[x]&lt;/code&gt; returns the value of key &lt;code&gt;x&lt;/code&gt; (if it exists) or throws an error, and &lt;code&gt;D[x] = y&lt;/code&gt; stores the key-value pair &lt;code&gt;x =&amp;gt; y&lt;/code&gt; in &lt;code&gt;D&lt;/code&gt; (replacing any existing value for the key &lt;code&gt;x&lt;/code&gt;). Multiple arguments to &lt;code&gt;D[...]&lt;/code&gt; are converted to tuples; for example, the syntax &lt;code&gt;D[x,y]&lt;/code&gt; is equivalent to &lt;code&gt;D[(x,y)]&lt;/code&gt;, i.e. it refers to the value keyed by the tuple &lt;code&gt;(x,y)&lt;/code&gt;.</source>
          <target state="translated">辞書 &lt;code&gt;D&lt;/code&gt; が与えられると、構文 &lt;code&gt;D[x]&lt;/code&gt; はキー &lt;code&gt;x&lt;/code&gt; （存在する場合）の値を返すか、エラーをスローし、 &lt;code&gt;D[x] = y&lt;/code&gt; はキーと値のペア &lt;code&gt;x =&amp;gt; y&lt;/code&gt; を &lt;code&gt;D&lt;/code&gt; に格納します（既存のすべてのキー &lt;code&gt;x&lt;/code&gt; の値）。 &lt;code&gt;D[...]&lt;/code&gt; への複数の引数はタプルに変換されます。たとえば、構文 &lt;code&gt;D[x,y]&lt;/code&gt; は &lt;code&gt;D[(x,y)]&lt;/code&gt; と同等です。つまり、タプル &lt;code&gt;(x,y)&lt;/code&gt; によってキー設定された値を参照します。</target>
        </trans-unit>
        <trans-unit id="6aeb65e7ccb967c9455ef2f486079851e21e2b6b" translate="yes" xml:space="preserve">
          <source>Given a pointer to an execution context (usually generated by a call to &lt;code&gt;backtrace&lt;/code&gt;), looks up stack frame context information. Returns an array of frame information for all functions inlined at that point, innermost function first.</source>
          <target state="translated">実行コンテキストへのポインタ（通常は &lt;code&gt;backtrace&lt;/code&gt; の呼び出しによって生成されます）を指定すると、スタックフレームコンテキスト情報を検索します。その時点でインライン化されたすべての関数のフレーム情報の配列を返します。最も内側の関数が最初です。</target>
        </trans-unit>
        <trans-unit id="fcada796f1c4aca1cfb31ae96c64d212e649ecf0" translate="yes" xml:space="preserve">
          <source>Given a predicate function &lt;code&gt;flt&lt;/code&gt; and an iterable object &lt;code&gt;itr&lt;/code&gt;, return an iterable object which upon iteration yields the elements &lt;code&gt;x&lt;/code&gt; of &lt;code&gt;itr&lt;/code&gt; that satisfy &lt;code&gt;flt(x)&lt;/code&gt;. The order of the original iterator is preserved.</source>
          <target state="translated">述語関数所与 &lt;code&gt;flt&lt;/code&gt; および反復可能オブジェクト &lt;code&gt;itr&lt;/code&gt; 、反復時に素子が得られる反復可能オブジェクトを返す &lt;code&gt;x&lt;/code&gt; はの &lt;code&gt;itr&lt;/code&gt; 満足すること &lt;code&gt;flt(x)&lt;/code&gt; 。元のイテレーターの順序は保持されます。</target>
        </trans-unit>
        <trans-unit id="c16f746a1658b9d1859c84c436dc50bdb9fe0a85" translate="yes" xml:space="preserve">
          <source>Given a previous profiling run, determine who called a particular function. Supplying the filename (and optionally, range of line numbers over which the function is defined) allows you to disambiguate an overloaded method. The returned value is a vector containing a count of the number of calls and line information about the caller. One can optionally supply backtrace &lt;code&gt;data&lt;/code&gt; obtained from &lt;a href=&quot;#Profile.retrieve&quot;&gt;&lt;code&gt;retrieve&lt;/code&gt;&lt;/a&gt;; otherwise, the current internal profile buffer is used.</source>
          <target state="translated">以前のプロファイリング実行を前提として、特定の関数を呼び出したユーザーを特定します。ファイル名（およびオプションで、関数が定義されている行番号の範囲）を指定すると、オーバーロードされたメソッドを明確にすることができます。戻り値は、呼び出し回数のカウントと呼び出し元に関する回線情報を含むベクトルです。オプションで、&lt;a href=&quot;#Profile.retrieve&quot;&gt; &lt;code&gt;retrieve&lt;/code&gt; &lt;/a&gt;から取得したバックトレース &lt;code&gt;data&lt;/code&gt; 提供できます。それ以外の場合は、現在の内部プロファイルバッファが使用されます。</target>
        </trans-unit>
        <trans-unit id="67104b7201b61b9623c8478911e24c6cfc8b97bc" translate="yes" xml:space="preserve">
          <source>Given a single iterable argument, constructs a &lt;a href=&quot;#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt; whose key-value pairs are taken from 2-tuples &lt;code&gt;(key,value)&lt;/code&gt; generated by the argument.</source>
          <target state="translated">単一の反復可能な引数を指定すると、引数によって生成された2つのタプル &lt;code&gt;(key,value)&lt;/code&gt; からキーと値のペアが取得される&lt;a href=&quot;#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; &lt;/a&gt;を作成します。</target>
        </trans-unit>
        <trans-unit id="a19217b165ec900e8bae935104c81bb7e032d599" translate="yes" xml:space="preserve">
          <source>Given a starting value, construct a range either by length or from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;stop&lt;/code&gt;, optionally with a given step (defaults to 1, a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt;). One of &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;stop&lt;/code&gt; is required. If &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, and &lt;code&gt;step&lt;/code&gt; are all specified, they must agree.</source>
          <target state="translated">開始値を指定して、長さまたは &lt;code&gt;start&lt;/code&gt; から &lt;code&gt;stop&lt;/code&gt; の範囲で、オプションで特定のステップ（デフォルトは1、&lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt; &lt;code&gt;UnitRange&lt;/code&gt; &lt;/a&gt;）で範囲を構築します。一つ &lt;code&gt;length&lt;/code&gt; や &lt;code&gt;stop&lt;/code&gt; 必要とされます。場合は &lt;code&gt;length&lt;/code&gt; 、 &lt;code&gt;stop&lt;/code&gt; 、および &lt;code&gt;step&lt;/code&gt; 、すべて指定されている、彼らが同意しなければなりません。</target>
        </trans-unit>
        <trans-unit id="e6bf5e1364f77d196c7b9a51bb62bde8f133bcde" translate="yes" xml:space="preserve">
          <source>Given a string or array &lt;code&gt;s&lt;/code&gt; of ASCII codes for a sequence of hexadecimal digits, returns a &lt;code&gt;Vector{UInt8}&lt;/code&gt; of bytes corresponding to the binary representation: each successive pair of hexadecimal digits in &lt;code&gt;s&lt;/code&gt; gives the value of one byte in the return vector.</source>
          <target state="translated">文字列または配列所与 &lt;code&gt;s&lt;/code&gt; 16進数のシーケンスのためのASCIIコードの、戻り &lt;code&gt;Vector{UInt8}&lt;/code&gt; バイナリ表現に対応するバイトを：に16進数の各連続対 &lt;code&gt;s&lt;/code&gt; 回帰ベクトルに1バイトの値を与えます。</target>
        </trans-unit>
        <trans-unit id="8d6a85425c1e72a27deafaba610d488a3457e0f2" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;T&lt;/code&gt;, it's currently assumed that if &lt;code&gt;rand(T)&lt;/code&gt; is defined, an object of type &lt;code&gt;T&lt;/code&gt; will be produced. In order to define random generation of values of type &lt;code&gt;T&lt;/code&gt;, the following method can be defined: &lt;code&gt;rand(rng::AbstractRNG, ::Random.SamplerType{T})&lt;/code&gt; (this should return what &lt;code&gt;rand(rng, T)&lt;/code&gt; is expected to return).</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; の場合、現在、 &lt;code&gt;rand(T)&lt;/code&gt; が定義されている場合、タイプ &lt;code&gt;T&lt;/code&gt; のオブジェクトが生成されると想定されています。 &lt;code&gt;T&lt;/code&gt; 型の値のランダムな生成を定義するために、次のメソッドを定義できます： &lt;code&gt;rand(rng::AbstractRNG, ::Random.SamplerType{T})&lt;/code&gt; （これ &lt;code&gt;rand(rng, T)&lt;/code&gt; が返すと予想されるものが返されます） ）。</target>
        </trans-unit>
        <trans-unit id="60e4af8cc8de60ffb69850d252bdcd98ee3d2bfa" translate="yes" xml:space="preserve">
          <source>Given an AbstractArray &lt;code&gt;A&lt;/code&gt;, create a view &lt;code&gt;B&lt;/code&gt; such that the dimensions appear to be permuted. Similar to &lt;code&gt;permutedims&lt;/code&gt;, except that no copying occurs (&lt;code&gt;B&lt;/code&gt; shares storage with &lt;code&gt;A&lt;/code&gt;).</source>
          <target state="translated">AbstractArray &lt;code&gt;A&lt;/code&gt; を指定して、次元が並べ替えられているように見えるビュー &lt;code&gt;B&lt;/code&gt; を作成します。 &lt;code&gt;permutedims&lt;/code&gt; と同様ですが、コピーは行われません（ &lt;code&gt;B&lt;/code&gt; は &lt;code&gt;A&lt;/code&gt; とストレージを共有します）。</target>
        </trans-unit>
        <trans-unit id="2273302d369651afdbde86cc33fa4cfcb401046e" translate="yes" xml:space="preserve">
          <source>Given an expression object, one can cause Julia to evaluate (execute) it at global scope using &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">式オブジェクトを指定すると、&lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;を使用してJuliaにグローバルスコープで式を評価（実行）させることができます。</target>
        </trans-unit>
        <trans-unit id="6bcc48e1bcaa064479ac3ce6a9aad0b807686849" translate="yes" xml:space="preserve">
          <source>Given an index &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;reverse(v)&lt;/code&gt;, return the corresponding index in &lt;code&gt;v&lt;/code&gt; so that &lt;code&gt;v[reverseind(v,i)] == reverse(v)[i]&lt;/code&gt;. (This can be nontrivial in cases where &lt;code&gt;v&lt;/code&gt; contains non-ASCII characters.)</source>
          <target state="translated">インデックス指定された &lt;code&gt;i&lt;/code&gt; がに &lt;code&gt;reverse(v)&lt;/code&gt; に対応するインデックスを返す &lt;code&gt;v&lt;/code&gt; ように &lt;code&gt;v[reverseind(v,i)] == reverse(v)[i]&lt;/code&gt; 。（ &lt;code&gt;v&lt;/code&gt; に非ASCII文字が含まれている場合、これは重要なことです。）</target>
        </trans-unit>
        <trans-unit id="214692258e5d3f03bf0e19a0c7bce6fe690232a0" translate="yes" xml:space="preserve">
          <source>Given an iterator &lt;code&gt;itr&lt;/code&gt;, then &lt;code&gt;reverse(itr)&lt;/code&gt; is an iterator over the same collection but in the reverse order.</source>
          <target state="translated">イテレータ &lt;code&gt;itr&lt;/code&gt; を指定すると、 &lt;code&gt;reverse(itr)&lt;/code&gt; は同じコレクションのイテレータですが、逆の順序になります。</target>
        </trans-unit>
        <trans-unit id="089e5e83e8607aed09695c30f3dd1c60f5798574" translate="yes" xml:space="preserve">
          <source>Given an iterator that yields iterators, return an iterator that yields the elements of those iterators. Put differently, the elements of the argument iterator are concatenated.</source>
          <target state="translated">イテレータを生成するイテレータが与えられると、それらのイテレータの要素を生成するイテレータを返します。言い換えれば、引数のイテレータの要素は連結されます。</target>
        </trans-unit>
        <trans-unit id="3c9b417cfac83aea8a69f80d6bc8cf9a41f8a58a" translate="yes" xml:space="preserve">
          <source>Given such a declaration, for each choice of &lt;code&gt;T&lt;/code&gt;, we have &lt;code&gt;Point{T}&lt;/code&gt; as a subtype of &lt;code&gt;Pointy{T}&lt;/code&gt;:</source>
          <target state="translated">各選択のために、このようなA宣言所与 &lt;code&gt;T&lt;/code&gt; 、我々は &lt;code&gt;Point{T}&lt;/code&gt; のサブタイプとして &lt;code&gt;Pointy{T}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d716647091cd161029df5d10c16015ae51186d66" translate="yes" xml:space="preserve">
          <source>Given the git configuration file containing:</source>
          <target state="translated">を含むgit設定ファイルを与えます。</target>
        </trans-unit>
        <trans-unit id="915ac53cd4c78783b139cec5dd22b4b42ed2b99a" translate="yes" xml:space="preserve">
          <source>Given the statement &lt;code&gt;using Foo&lt;/code&gt;, the system consults an internal table of top-level modules to look for one named &lt;code&gt;Foo&lt;/code&gt;. If the module does not exist, the system attempts to &lt;code&gt;require(:Foo)&lt;/code&gt;, which typically results in loading code from an installed package.</source>
          <target state="translated">&lt;code&gt;using Foo&lt;/code&gt; を使用したステートメントが与えられると、システムはトップレベルモジュールの内部テーブルを調べて、 &lt;code&gt;Foo&lt;/code&gt; という名前のモジュールを探します。モジュールが存在しない場合、システムは &lt;code&gt;require(:Foo)&lt;/code&gt; を試行します。これにより、通常、インストールされたパッケージからコードがロードされます。</target>
        </trans-unit>
        <trans-unit id="06fe662af1da02e3f2ea7cf7081d137d14c1ea88" translate="yes" xml:space="preserve">
          <source>Given the type of an iterator, return one of the following values:</source>
          <target state="translated">イテレータの型を指定すると、以下のいずれかの値を返します。</target>
        </trans-unit>
        <trans-unit id="712fa051470c666b0b3c1cf4e1eb3b5cdf800a89" translate="yes" xml:space="preserve">
          <source>Given this dependency &lt;code&gt;graph&lt;/code&gt;, when Julia sees &lt;code&gt;import Priv&lt;/code&gt; in the &lt;code&gt;Pub&lt;/code&gt; package&amp;mdash;which has UUID &lt;code&gt;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&lt;/code&gt;&amp;mdash;it looks up:</source>
          <target state="translated">この依存関係 &lt;code&gt;graph&lt;/code&gt; で、Juliaが &lt;code&gt;Pub&lt;/code&gt; パッケージの &lt;code&gt;import Priv&lt;/code&gt; （UUID &lt;code&gt;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&lt;/code&gt; を含む)を確認すると、次のように検索されます。</target>
        </trans-unit>
        <trans-unit id="617b3c70bd8eb4654d1000dde442b1913a3d57c6" translate="yes" xml:space="preserve">
          <source>Given this roots map, in &lt;code&gt;App&lt;/code&gt;'s code the statement &lt;code&gt;import Priv&lt;/code&gt; will cause Julia to look up &lt;code&gt;roots[:Priv]&lt;/code&gt;, which yields &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt;, the UUID of the &lt;code&gt;Priv&lt;/code&gt; package that is to be loaded in that context. This UUID identifies which &lt;code&gt;Priv&lt;/code&gt; package to load and use when the main application evaluates &lt;code&gt;import Priv&lt;/code&gt;.</source>
          <target state="translated">この根はで、マップを考えると &lt;code&gt;App&lt;/code&gt; のコードステートメント &lt;code&gt;import Priv&lt;/code&gt; ルックアップするためにジュリアが発生します &lt;code&gt;roots[:Priv]&lt;/code&gt; もたらし、 &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt; 、のUUID &lt;code&gt;Priv&lt;/code&gt; にロードするパッケージをそのコンテキスト。このUUIDは、メインアプリケーションが &lt;code&gt;import Priv&lt;/code&gt; 評価するときにロードして使用する &lt;code&gt;Priv&lt;/code&gt; パッケージを識別します。</target>
        </trans-unit>
        <trans-unit id="b509e583621052cb07bc486839dfdb1f16ed86dc" translate="yes" xml:space="preserve">
          <source>Global Scope</source>
          <target state="translated">グローバルスコープ</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes" xml:space="preserve">
          <source>Global Variables</source>
          <target state="translated">グローバル変数</target>
        </trans-unit>
        <trans-unit id="40501a9e5007169fb629c5387c4f8fb6e999c42d" translate="yes" xml:space="preserve">
          <source>Global constants are declared as constants on remote nodes too.</source>
          <target state="translated">グローバル定数は、リモートノード上でも定数として宣言されます。</target>
        </trans-unit>
        <trans-unit id="389f13ca82ff7a2453bc65e6b170fb5bce0e7be4" translate="yes" xml:space="preserve">
          <source>Global counters (for example, for attempting to uniquely identify objects). Consider the following code snippet:</source>
          <target state="translated">グローバルカウンタ(例えば、オブジェクトを一意に識別しようとする場合など)。次のコードスニペットを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="9f22cff33a2ca414f07ad83aad20cf6de8acaeaf" translate="yes" xml:space="preserve">
          <source>Global variable referring to the standard error stream.</source>
          <target state="translated">標準エラーストリームを参照するグローバル変数。</target>
        </trans-unit>
        <trans-unit id="9aa21a682323865a22d83920da0f441d6c030675" translate="yes" xml:space="preserve">
          <source>Global variable referring to the standard input stream.</source>
          <target state="translated">標準入力ストリームを参照するグローバル変数。</target>
        </trans-unit>
        <trans-unit id="51d6faf5f0e0e6c01ea9efaf0aad4dbd11c26673" translate="yes" xml:space="preserve">
          <source>Global variable referring to the standard out stream.</source>
          <target state="translated">標準アウトストリームを参照するグローバル変数。</target>
        </trans-unit>
        <trans-unit id="70ae8e14e7d7a8122e7468fd602556f9b4388301" translate="yes" xml:space="preserve">
          <source>Global variables</source>
          <target state="translated">グローバル変数</target>
        </trans-unit>
        <trans-unit id="7d6e1e2bd4cbe556d039d09149551410bf54cb41" translate="yes" xml:space="preserve">
          <source>Global variables exported by native libraries can be accessed by name using the &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt;&lt;code&gt;cglobal&lt;/code&gt;&lt;/a&gt; function. The arguments to &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt;&lt;code&gt;cglobal&lt;/code&gt;&lt;/a&gt; are a symbol specification identical to that used by &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, and a type describing the value stored in the variable:</source>
          <target state="translated">ネイティブライブラリによってエクスポートされたグローバル変数には、&lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt; &lt;code&gt;cglobal&lt;/code&gt; &lt;/a&gt;関数を使用して名前でアクセスできます。引数&lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt; &lt;code&gt;cglobal&lt;/code&gt; &lt;/a&gt;によって使用されるものと同一のシンボル指定され&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;、変数に格納された値を記述するタイプ：</target>
        </trans-unit>
        <trans-unit id="d02d943210f33ec6146b40f17e3a1be495a87492" translate="yes" xml:space="preserve">
          <source>Globals are re-sent to a destination worker only in the context of a remote call, and then only if its value has changed. Also, the cluster does not synchronize global bindings across nodes. For example:</source>
          <target state="translated">グローバルが宛先ワーカーに再送信されるのは、リモート呼び出しのコンテキストでのみで、その値が変更された場合のみです。また、クラスタはノード間のグローバルバインディングを同期しません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="fb02a2aa39a487184ec2e48cce6d9541aa570f94" translate="yes" xml:space="preserve">
          <source>Globals under modules other than &lt;code&gt;Main&lt;/code&gt; are not serialized by value to the remote node. Only a reference is sent. Functions which create global bindings (except under &lt;code&gt;Main&lt;/code&gt;) may cause an &lt;code&gt;UndefVarError&lt;/code&gt; to be thrown later.</source>
          <target state="translated">&lt;code&gt;Main&lt;/code&gt; 以外のモジュールの下のグローバルは、値によってリモートノードにシリアル化されません。参照のみが送信されます。グローバルバインディングを作成する関数（ &lt;code&gt;Main&lt;/code&gt; の下を除く）は、 &lt;code&gt;UndefVarError&lt;/code&gt; をスローする場合があります。</target>
        </trans-unit>
        <trans-unit id="acd336be94f1ee162a48e523127d9e5b06609fb8" translate="yes" xml:space="preserve">
          <source>Globe With Meridians</source>
          <target state="translated">子午線を持つ地球儀</target>
        </trans-unit>
        <trans-unit id="bf6d33bf807dc90549a0d0bac64e3cc4b4bb46ed" translate="yes" xml:space="preserve">
          <source>Glowing Star</source>
          <target state="translated">グローイングスター</target>
        </trans-unit>
        <trans-unit id="0e3f5fc25846b7ffc7fbf7ea4a19522f60c6c683" translate="yes" xml:space="preserve">
          <source>Goat</source>
          <target state="translated">Goat</target>
        </trans-unit>
        <trans-unit id="dab8916b317afa94c1e7d2eb18cfc9628289063b" translate="yes" xml:space="preserve">
          <source>Good performance, approaching that of statically-compiled languages like C</source>
          <target state="translated">C言語のような静的にコンパイルされた言語に近い性能を持つ</target>
        </trans-unit>
        <trans-unit id="85116c6b5a5273ba053319524800267c175695d4" translate="yes" xml:space="preserve">
          <source>Graduation Cap</source>
          <target state="translated">卒業キャップ</target>
        </trans-unit>
        <trans-unit id="0de47448267ba383673ef343ee1313af6fa63b74" translate="yes" xml:space="preserve">
          <source>Grapes</source>
          <target state="translated">Grapes</target>
        </trans-unit>
        <trans-unit id="2ef67b67ccfcf902b5da0d871f7bce811117ba2c" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Double-Line Equal Above Less-Than</source>
          <target state="translated">二重線の上の大きい以上 同等の上の小さい以下</target>
        </trans-unit>
        <trans-unit id="5bf36d0687ba161c1ddd5ae9a710ac6b84c65e73" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Less-Than Above Double-Line Equal</source>
          <target state="translated">大至上 大至下 大至上 ダブルライン イコール</target>
        </trans-unit>
        <trans-unit id="cda9caba673dd1973f8c7d113746b0e633f4f938" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Similar Above Less-Than</source>
          <target state="translated">大規模以上 上記 似たようなもの 上記 似たようなもの 以下</target>
        </trans-unit>
        <trans-unit id="3a03ecfc7255d8cacd17931a2c17d195720afbd9" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Similar Or Equal</source>
          <target state="translated">類似または同等以上</target>
        </trans-unit>
        <trans-unit id="eed03df20a091917ea38ceacb7e9c2b67e0f9bb2" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Slanted Equal Above Less-Than Above Slanted Equal</source>
          <target state="translated">斜め上の大以上 斜め上の等倍以上 斜め上の等倍未満 斜め上の等倍以上</target>
        </trans-unit>
        <trans-unit id="ec6a31bc7051547d44e2c612da8aa15b61e41be6" translate="yes" xml:space="preserve">
          <source>Greater-Than And Not Approximate</source>
          <target state="translated">大なり小なり</target>
        </trans-unit>
        <trans-unit id="852f9d0047fa29fbc8fb2cb24463f569deef89ef" translate="yes" xml:space="preserve">
          <source>Greater-Than And Single-Line Not Equal To</source>
          <target state="translated">グレーター以上のものと単線のものは同じではありません。</target>
        </trans-unit>
        <trans-unit id="52afc7afef44a974f7bc9b05b1e17bf964f408a0" translate="yes" xml:space="preserve">
          <source>Greater-Than Beside Less-Than</source>
          <target state="translated">大なり小なり</target>
        </trans-unit>
        <trans-unit id="8002394d4a4c3c62e2b6ebf6a841410b987f3fe3" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equal To / Greater Than But Not Equal To</source>
          <target state="translated">Greater-Than But Not Equal To/Greater Than But Not Equal To</target>
        </trans-unit>
        <trans-unit id="9f51323c1f1f2bd6fed8b0133087b13833db9603" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equal To / Greater Than But Not Equal To + Variation Selector-1</source>
          <target state="translated">より大きいが等しくない/より大きいが等しくない+変形セレクタ-1</target>
        </trans-unit>
        <trans-unit id="a9e5efe496a2b31f56957d4e597885897f8e0eb9" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equivalent To / Greater Than But Not Equivalent To</source>
          <target state="translated">グレーター・ザン・バット・ノット・イコール・ツー/グレーター・ザン・バット・ノット・イコール・ツー</target>
        </trans-unit>
        <trans-unit id="98eff7a1e60f594f0f81d4c3e83cbf5209423bb1" translate="yes" xml:space="preserve">
          <source>Greater-Than Closed By Curve</source>
          <target state="translated">曲線で閉じられたグレーター・ハン</target>
        </trans-unit>
        <trans-unit id="099b37f93e6b34dbfa7c526c5fa3f13b59c30374" translate="yes" xml:space="preserve">
          <source>Greater-Than Closed By Curve Above Slanted Equal</source>
          <target state="translated">傾斜したイコール上の曲線によって閉じられた大-中</target>
        </trans-unit>
        <trans-unit id="bb2d6f56b2861cf6b4d17b1cfddecb19b41dd882" translate="yes" xml:space="preserve">
          <source>Greater-Than Equal To Or Less-Than / Greater Than Equal To Or Less Than</source>
          <target state="translated">等しくても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても</target>
        </trans-unit>
        <trans-unit id="1f9f324edcdf276db2fba93d474c1d37dd1409bf" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Approximate</source>
          <target state="translated">大なり小なり</target>
        </trans-unit>
        <trans-unit id="816b73122f7826a76fc5a27a59be585ac1c20c8e" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Equal To / Greater Than Or Equal To</source>
          <target state="translated">グレーター・ザン・イコール・トゥ/グレーター・ザン・イコール・トゥ</target>
        </trans-unit>
        <trans-unit id="22f6cd5ba77c22771ae0dcb6dec580b58470b15f" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Equivalent To / Greater Than Or Equivalent To</source>
          <target state="translated">大規模以上または同等のもの/大規模以上または同等のもの</target>
        </trans-unit>
        <trans-unit id="da7070ff7fe0d357657567e892ae9e792dd0711c" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Less-Than / Greater Than Or Less Than</source>
          <target state="translated">大なり小なり/大なり小なり</target>
        </trans-unit>
        <trans-unit id="fc2308a37940cf5145837f4b055616cdf8ed8663" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To</source>
          <target state="translated">大至上または斜行に等しい</target>
        </trans-unit>
        <trans-unit id="fc0db4bdca25b60daf5c07123869e9c3373f86d1" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">長尺スラッシュオーバーレイ/非スペーシング長尺スラッシュオーバーレイを組み合わせて、長尺ソリダスオーバーレイと同等以上の大きさまたは斜めにします。</target>
        </trans-unit>
        <trans-unit id="3d2877fe16bd8c1aff6ca20742e54d7c40adcfb5" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Above</source>
          <target state="translated">上のドットを持つことに等しい Greater-Than または斜めに</target>
        </trans-unit>
        <trans-unit id="5b85b82c5dfec29b3e76371a3c759b7b564d0dcc" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Above Left</source>
          <target state="translated">左の上のドットを持つことに等しい Greater-Than または斜めの</target>
        </trans-unit>
        <trans-unit id="324053698d665835c3c8543b9475493cada464ce" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Inside</source>
          <target state="translated">ドットの内側にあるものと同等以上の大きさまたは傾斜</target>
        </trans-unit>
        <trans-unit id="eaf2aeee67af979dcb4bf973f1c28801c9b3c428" translate="yes" xml:space="preserve">
          <source>Greater-Than Over Equal To / Greater Than Over Equal To</source>
          <target state="translated">等価以上/等価以上の大いなるもの</target>
        </trans-unit>
        <trans-unit id="88e04ffb7bbd7b8b561e5e62dab6aaf4e8ec7d4c" translate="yes" xml:space="preserve">
          <source>Greater-Than Overlapping Less-Than</source>
          <target state="translated">大至上 重複 小至上</target>
        </trans-unit>
        <trans-unit id="7eb5603be44b831a023cfdcd22f839b5f6f5bded" translate="yes" xml:space="preserve">
          <source>Greater-Than With Circle Inside</source>
          <target state="translated">内側に円を入れたグレーター・ハン</target>
        </trans-unit>
        <trans-unit id="f158072571829726fe84a7ad0ce7a50ef1ab0879" translate="yes" xml:space="preserve">
          <source>Greater-Than With Dot / Greater Than With Dot</source>
          <target state="translated">グレーター・タン・ウィズ・ドット/グレーター・タン・ウィズ・ドット</target>
        </trans-unit>
        <trans-unit id="209f35de5184bc36aa0d1b903151a9fc65c6ba61" translate="yes" xml:space="preserve">
          <source>Greater-Than With Question Mark Above</source>
          <target state="translated">上記のクエスチョンマークが付いているグレーター・ハン</target>
        </trans-unit>
        <trans-unit id="1bd3d8bbe04802c889994d907ddead65a92d7cca" translate="yes" xml:space="preserve">
          <source>Greater-than comparison operator. Falls back to &lt;code&gt;y &amp;lt; x&lt;/code&gt;.</source>
          <target state="translated">大なり比較演算子。 &lt;code&gt;y &amp;lt; x&lt;/code&gt; フォールバックします。</target>
        </trans-unit>
        <trans-unit id="ed9b75dd8da9fbc05fe433d4046e50ff253af5b8" translate="yes" xml:space="preserve">
          <source>Greater-than-or-equals comparison operator. Falls back to &lt;code&gt;y &amp;lt;= x&lt;/code&gt;.</source>
          <target state="translated">より大きいか等しい比較演算子。 &lt;code&gt;y &amp;lt;= x&lt;/code&gt; フォールバックします。</target>
        </trans-unit>
        <trans-unit id="c889dfd5914acacbd51c9ee1f6424d7475f18ba9" translate="yes" xml:space="preserve">
          <source>Greatest common (positive) divisor (or zero if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero).</source>
          <target state="translated">最大公約数（正）の除数（ &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が両方ともゼロの場合はゼロ）。</target>
        </trans-unit>
        <trans-unit id="3c137f18236c59d67effecc9926b91bc4e6c388c" translate="yes" xml:space="preserve">
          <source>Greek Beta Symbol / Greek Small Letter Curled Beta</source>
          <target state="translated">ギリシャ語のベータ記号/ギリシャ語の小さな文字は、ベータをカールさせた</target>
        </trans-unit>
        <trans-unit id="c90a544a84e41b0027e35535de12e9412929c3b9" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Alpha</source>
          <target state="translated">ギリシャ文字アルファ</target>
        </trans-unit>
        <trans-unit id="034c000ae09a7efb7dcd09b84c993f24a59b651a" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Beta</source>
          <target state="translated">ギリシャ資本の手紙ベータ</target>
        </trans-unit>
        <trans-unit id="d91481b132bdcebe4f898c637891a19c7e0d2807" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Chi</source>
          <target state="translated">ギリシアの大文字カイ</target>
        </trans-unit>
        <trans-unit id="3e715476cf54a47fc160c1f17257b6e0b611dcf0" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Delta</source>
          <target state="translated">ギリシャ資本の手紙デルタ</target>
        </trans-unit>
        <trans-unit id="e7b36e8f2dc5d428f4c0fbae5314c79d701290b8" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Epsilon</source>
          <target state="translated">ギリシャの大文字イプシロン</target>
        </trans-unit>
        <trans-unit id="9632923c81e91309b0197e9f6256e5ddc583b3f1" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Eta</source>
          <target state="translated">ギリシャ語の大文字イータ</target>
        </trans-unit>
        <trans-unit id="b63912e4ec51d609e069730c367de176e6e9799e" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Gamma</source>
          <target state="translated">ギリシャ資本の手紙ガンマ</target>
        </trans-unit>
        <trans-unit id="003ecb167b62284b9bb24641dd3e450774ffb206" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Iota</source>
          <target state="translated">ギリシャ文字イオタ</target>
        </trans-unit>
        <trans-unit id="97e0c3c41b2cd617ba1f3aefc97784af90e81883" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Kappa</source>
          <target state="translated">ギリシャ文字のカッパ</target>
        </trans-unit>
        <trans-unit id="8766675df925b8c25168f5080a3ffb3054a6bbf7" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Lamda / Greek Capital Letter Lambda</source>
          <target state="translated">ギリシャ語の大文字ラムダ/ギリシャ語の大文字ラムダ</target>
        </trans-unit>
        <trans-unit id="93f0db4c50dab02a7cf643e0e6463e461b78350b" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Mu</source>
          <target state="translated">ギリシア語の大文字ミュー</target>
        </trans-unit>
        <trans-unit id="c5ff86b57695b2194281052f49d3a518561ee43b" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Nu</source>
          <target state="translated">ギリシア文字ヌ</target>
        </trans-unit>
        <trans-unit id="8d3af0cfd66c1c551b9d25df70d96ca3b3e41655" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Omega</source>
          <target state="translated">ギリシャ文字オメガ</target>
        </trans-unit>
        <trans-unit id="60cb22c8a7263835043a1bf3e2390a30ccb009da" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Omicron</source>
          <target state="translated">ギリシア文字オミクロン</target>
        </trans-unit>
        <trans-unit id="9ef46dcc225d47def0f7ae271f6bce8a9447782c" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Phi</source>
          <target state="translated">ギリシャ文字のファイ</target>
        </trans-unit>
        <trans-unit id="bdfd940817a68024f4561b28e37abe5c6aa8ae33" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Pi</source>
          <target state="translated">ギリシア文字パイ</target>
        </trans-unit>
        <trans-unit id="9eb135fdc0eb8f41676f0233eced63bfb63b8d29" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Psi</source>
          <target state="translated">ギリシアの大文字プシ</target>
        </trans-unit>
        <trans-unit id="42581daba465402bb427e86f725e50cbf13c5589" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Rho</source>
          <target state="translated">ギリシャ語の大文字ロー</target>
        </trans-unit>
        <trans-unit id="9ba5f4b3b8d0114e4ebb66c0c247b421553311c0" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Sigma</source>
          <target state="translated">ギリシャ語の大文字シグマ</target>
        </trans-unit>
        <trans-unit id="ce15c49fc86bc080b59dcc6c6f912a5f65fcea89" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Tau</source>
          <target state="translated">ギリシャ語の大文字タウ</target>
        </trans-unit>
        <trans-unit id="c53695a8df7adbb8087dbbf3f92d38bad6c54a97" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Theta</source>
          <target state="translated">ギリシャ語の大文字シータ</target>
        </trans-unit>
        <trans-unit id="e5671b238dc9a21dfba521fd40bfb114bae616b4" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Upsilon</source>
          <target state="translated">ギリシャの大文字アップシロン</target>
        </trans-unit>
        <trans-unit id="7ee18055cc5ff646350aabb8125c5079d084ebc7" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Xi</source>
          <target state="translated">ギリシャの首都の文字Xi</target>
        </trans-unit>
        <trans-unit id="ff11a198311aac30e2248ebcb8edaa9900afa1c4" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Zeta</source>
          <target state="translated">ギリシャ語の大文字ゼータ</target>
        </trans-unit>
        <trans-unit id="75f6796d9ad54779470705290e7c7602d7a845bd" translate="yes" xml:space="preserve">
          <source>Greek Capital Theta Symbol</source>
          <target state="translated">ギリシャ資本シータのシンボル</target>
        </trans-unit>
        <trans-unit id="533978fb12373ffa98e45e16bb2525fdaa4ff4dc" translate="yes" xml:space="preserve">
          <source>Greek Kappa Symbol / Greek Small Letter Script Kappa</source>
          <target state="translated">ギリシャ語のカッパのシンボル/ギリシャ語の小文字スクリプトカッパ</target>
        </trans-unit>
        <trans-unit id="098ec4a81c9f38263e62700b20a2a6894858fb2e" translate="yes" xml:space="preserve">
          <source>Greek Letter Archaic Koppa</source>
          <target state="translated">ギリシャ文字のアルカイックコッパ</target>
        </trans-unit>
        <trans-unit id="c2ec8b8cfe62422b5013f3acdd510642f682d268" translate="yes" xml:space="preserve">
          <source>Greek Letter Digamma / Greek Capital Letter Digamma</source>
          <target state="translated">ギリシャ文字Digamma/ギリシャ文字Digamma</target>
        </trans-unit>
        <trans-unit id="ced5a29435b2a381da90865a6dc27f1b51bd0151" translate="yes" xml:space="preserve">
          <source>Greek Letter Koppa / Greek Capital Letter Koppa</source>
          <target state="translated">ギリシャ語の手紙コッパ/ギリシャ語の大文字コッパ</target>
        </trans-unit>
        <trans-unit id="b1fd4e84b1e13403c9fa5cc0de48f63d1cf94bc6" translate="yes" xml:space="preserve">
          <source>Greek Letter Sampi / Greek Capital Letter Sampi</source>
          <target state="translated">ギリシャ文字のサンピ/ギリシャ文字のサンピ</target>
        </trans-unit>
        <trans-unit id="6736119dd29a2f705206a98b22de530d1dcccd83" translate="yes" xml:space="preserve">
          <source>Greek Letter Stigma / Greek Capital Letter Stigma</source>
          <target state="translated">ギリシャ文字のスティグマ/ギリシャ文字のスティグマ</target>
        </trans-unit>
        <trans-unit id="ea7aa3ec425217aedfab9d34ef40b0b566351176" translate="yes" xml:space="preserve">
          <source>Greek Lunate Epsilon Symbol</source>
          <target state="translated">ギリシャのルナートイプシロンのシンボル</target>
        </trans-unit>
        <trans-unit id="dfaadea9364a20060c114ea92b3c24b30e9e1221" translate="yes" xml:space="preserve">
          <source>Greek Phi Symbol / Greek Small Letter Script Phi</source>
          <target state="translated">ギリシャ語のファイのシンボル/ギリシャ語の小さな文字スクリプトファイ</target>
        </trans-unit>
        <trans-unit id="0ae051b71680a4d39d72cb02f855a3c712e5bd2c" translate="yes" xml:space="preserve">
          <source>Greek Pi Symbol / Greek Small Letter Omega Pi</source>
          <target state="translated">ギリシャ語の円周率記号/ギリシャ語の小さな文字オメガパイ</target>
        </trans-unit>
        <trans-unit id="f50bb1d13ed32ec906d7d6aaaaee29e7aa027d22" translate="yes" xml:space="preserve">
          <source>Greek Reversed Lunate Epsilon Symbol</source>
          <target state="translated">ギリシア語逆月星ε記号</target>
        </trans-unit>
        <trans-unit id="ac07b5056a85d49adcf70f2b544a74ea6ecf6dce" translate="yes" xml:space="preserve">
          <source>Greek Rho Symbol / Greek Small Letter Tailed Rho</source>
          <target state="translated">ギリシャ語のRhoシンボル/ギリシャ語の小文字の尾のRho</target>
        </trans-unit>
        <trans-unit id="448dc00d610b9b19fb08a7c7e6eb0a55f13d0a5d" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Alpha</source>
          <target state="translated">ギリシャ語の小文字アルファ</target>
        </trans-unit>
        <trans-unit id="71d9bba39729f37db08ecc6cfd07622c292a3bcb" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Archaic Koppa</source>
          <target state="translated">ギリシャ語小文字アルカイックコッパ</target>
        </trans-unit>
        <trans-unit id="c2455c0fc133c1c49b746a40bf7fe8a2f613a4de" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Beta</source>
          <target state="translated">ギリシャ語の小文字ベータ</target>
        </trans-unit>
        <trans-unit id="5f8706d38c341d4055ab40dfb27748f213e0fc49" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Chi</source>
          <target state="translated">ギリシャ語の小文字カイ</target>
        </trans-unit>
        <trans-unit id="4dcd438cdc63b711ea794ef765006ad5a6535bd8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Delta</source>
          <target state="translated">ギリシャ語の小文字デルタ</target>
        </trans-unit>
        <trans-unit id="970eba5f1fd0ce763d594cfcc46caddd4212150e" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Digamma</source>
          <target state="translated">ギリシャ語の小文字ディガンマ</target>
        </trans-unit>
        <trans-unit id="37cc4f8ed3f230c47dc11c83e4de12cf526a1b20" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Epsilon</source>
          <target state="translated">ギリシャ語の小さな文字イプシロン</target>
        </trans-unit>
        <trans-unit id="7ccbcb67c9381630a226a3b3c4b28371605f0d5a" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Eta</source>
          <target state="translated">ギリシャ語の小文字イータ</target>
        </trans-unit>
        <trans-unit id="c074819760ca3f5bfb2e80f9147ad5e5b56ba096" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Final Sigma</source>
          <target state="translated">グリークスモールレター ファイナルシグマ</target>
        </trans-unit>
        <trans-unit id="46c3a6f8bc0a7d2d96bb1cd2543a7109d5b60cf2" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Gamma</source>
          <target state="translated">ギリシャの小さな文字ガンマ</target>
        </trans-unit>
        <trans-unit id="4643eab845743a762892a109cabf22bfe96da620" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Iota</source>
          <target state="translated">ギリシャ語の小文字イオタ</target>
        </trans-unit>
        <trans-unit id="3e9ea92015aac67d0b73db674b1ba4dee8fe5484" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Kappa</source>
          <target state="translated">ギリシアの小文字カッパ</target>
        </trans-unit>
        <trans-unit id="c67601530cb0f970279b136a8b536cfe4717bcd6" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Koppa</source>
          <target state="translated">ギリシャ語の小文字コッパ</target>
        </trans-unit>
        <trans-unit id="8c54eb8dc3ac289b41335f3dc67e6533bf270a57" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Lamda / Greek Small Letter Lambda</source>
          <target state="translated">ギリシャ語の小さな文字ラムダ/ギリシャ語の小さな文字ラムダ</target>
        </trans-unit>
        <trans-unit id="7149178e5cd2592e10a36e0a107bc1c794d4f411" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Mu</source>
          <target state="translated">ギリシア語の小文字ミュー</target>
        </trans-unit>
        <trans-unit id="e9b48a4ac754761a9dfd350adeabe5d343e5cb8f" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Nu</source>
          <target state="translated">ギリシャ語の小さな文字ヌ</target>
        </trans-unit>
        <trans-unit id="be2da964640e6e3a6c6130c2c98b0cae86bc9a01" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Omega</source>
          <target state="translated">ギリシャ語の小さな文字 オメガ</target>
        </trans-unit>
        <trans-unit id="039c14215303437a5f755bf47c77fbf3d49255e3" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Omicron</source>
          <target state="translated">ギリシャ語の小文字オミクロン</target>
        </trans-unit>
        <trans-unit id="b844f337c63e69f41e1119e2ae91153b90ab2b4d" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Phi</source>
          <target state="translated">ギリシャ語の小さな文字ファイ</target>
        </trans-unit>
        <trans-unit id="95d050ef9ff90d9125fe852cf7d1543f2ce7e841" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Pi</source>
          <target state="translated">ギリシア語の小文字パイ</target>
        </trans-unit>
        <trans-unit id="55e311ff6199f4bde7e5d73ace711e07be007a2f" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Psi</source>
          <target state="translated">ギリシャ語の小さな文字のプシ</target>
        </trans-unit>
        <trans-unit id="5af5bfd009ec9591a9cb29dfcc2932dec54d6ca8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Rho</source>
          <target state="translated">ギリシャ語の小さな文字Rho</target>
        </trans-unit>
        <trans-unit id="85d8bb7b244cafeb1ab811a9df619d45d2234ea6" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Sampi</source>
          <target state="translated">ギリシャの小さな手紙サンピ</target>
        </trans-unit>
        <trans-unit id="3ec2ed80a66bc81ead34ee55592a6ea7debfff4e" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Sigma</source>
          <target state="translated">ギリシャの小さな文字シグマ</target>
        </trans-unit>
        <trans-unit id="cc430dcce9d526f42ad9a59b54895c602c6380d3" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Stigma</source>
          <target state="translated">ギリシア語の小文字のスティグマ</target>
        </trans-unit>
        <trans-unit id="7c2c0c82fe6e748bf9ed49a1f4249b9e89ebb0b8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Tau</source>
          <target state="translated">ギリシャ語の小さな文字タウ</target>
        </trans-unit>
        <trans-unit id="b13a88433f3cb99d5c62955aca5de95fbd232103" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Theta</source>
          <target state="translated">ギリシャ語の小さな文字シータ</target>
        </trans-unit>
        <trans-unit id="cad5938bde69f48a48d99f9b129d82f0acd5468b" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Upsilon</source>
          <target state="translated">ギリシャ語の小さな文字アップシロン</target>
        </trans-unit>
        <trans-unit id="0761f90b7168a502798811085d1367b5eca5af17" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Xi</source>
          <target state="translated">ギリシャ語の小さな文字Xi</target>
        </trans-unit>
        <trans-unit id="40428b11afaf575da445431ab7ceb811220b9167" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Zeta</source>
          <target state="translated">ギリシャ語の小さな文字ゼータ</target>
        </trans-unit>
        <trans-unit id="e32107e3b0620ecf09ddae3fe8f4666208d97040" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Beta</source>
          <target state="translated">ギリシャ語の添え字小文字ベータ</target>
        </trans-unit>
        <trans-unit id="90a01f237c5981615d18499c4360233abc532e89" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Chi</source>
          <target state="translated">ギリシャ語の添え字小字カイ</target>
        </trans-unit>
        <trans-unit id="e6642d28d8aeb11d500775a8447736e31c6678cc" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Gamma</source>
          <target state="translated">ギリシャ語の下付き小文字ガンマ</target>
        </trans-unit>
        <trans-unit id="8b5afd737dfb2072bb758ab79fe8cc816442c922" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Phi</source>
          <target state="translated">ギリシャ語の添え字小文字ファイ</target>
        </trans-unit>
        <trans-unit id="655a658031f914446d83820f4d7947b16f05e79e" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Rho</source>
          <target state="translated">ギリシャ語の添え字小文字Rho</target>
        </trans-unit>
        <trans-unit id="be9f5ea4e76fd688fd62b7dd791af4a7ebcdb5c7" translate="yes" xml:space="preserve">
          <source>Greek Theta Symbol / Greek Small Letter Script Theta</source>
          <target state="translated">ギリシャ語のシータ記号/ギリシャ語の小さな文字スクリプトシータ</target>
        </trans-unit>
        <trans-unit id="0dc9b81e7212e0baffe967cdd9d850d4352c89f1" translate="yes" xml:space="preserve">
          <source>Green Apple</source>
          <target state="translated">グリーンアップル</target>
        </trans-unit>
        <trans-unit id="6c0c3305620db430350f7c25edbf10ced1e1274b" translate="yes" xml:space="preserve">
          <source>Green Book</source>
          <target state="translated">グリーンブック</target>
        </trans-unit>
        <trans-unit id="6c50119d5c6855e408d9ec2a52bd79546e4c4107" translate="yes" xml:space="preserve">
          <source>Green Heart</source>
          <target state="translated">グリーンハート</target>
        </trans-unit>
        <trans-unit id="91feac528389c2b95c6eef06c801f2624c19116d" translate="yes" xml:space="preserve">
          <source>Grimacing Face</source>
          <target state="translated">グリムフェイス</target>
        </trans-unit>
        <trans-unit id="3f363dede90226435cbc0dd5d44650f61adbd5cf" translate="yes" xml:space="preserve">
          <source>Grinning Cat Face With Smiling Eyes</source>
          <target state="translated">笑顔の目でニヤニヤ猫の顔</target>
        </trans-unit>
        <trans-unit id="c001d488999b87437147a6834a4b4dff1427af59" translate="yes" xml:space="preserve">
          <source>Grinning Face</source>
          <target state="translated">ニヤニヤ顔</target>
        </trans-unit>
        <trans-unit id="5f9c06d040ed5ced638db3bf446959a48d2a6ba5" translate="yes" xml:space="preserve">
          <source>Grinning Face With Smiling Eyes</source>
          <target state="translated">笑顔の目でニヤニヤ顔</target>
        </trans-unit>
        <trans-unit id="7005b30f708630da7d596e53a5163b84350bd829" translate="yes" xml:space="preserve">
          <source>Grisu.print_shortest()</source>
          <target state="translated">Grisu.print_shortest()</target>
        </trans-unit>
        <trans-unit id="d511874702f7c7ad5ec3b4943a9badded191c85c" translate="yes" xml:space="preserve">
          <source>Growing Heart</source>
          <target state="translated">成長する心</target>
        </trans-unit>
        <trans-unit id="0fa148c7a4ec811ec41fa2cc8e9473dfc48a9226" translate="yes" xml:space="preserve">
          <source>Guardsman</source>
          <target state="translated">Guardsman</target>
        </trans-unit>
        <trans-unit id="94af6c4088103e96d349b87fe76774686b86faa5" translate="yes" xml:space="preserve">
          <source>Guitar</source>
          <target state="translated">Guitar</target>
        </trans-unit>
        <trans-unit id="f089f13a04cfc6546c94da2f6580d6c4eed769fc" translate="yes" xml:space="preserve">
          <source>HE</source>
          <target state="translated">HE</target>
        </trans-unit>
        <trans-unit id="9018ffc109466fc760171905d2397039bc111ebf" translate="yes" xml:space="preserve">
          <source>Had we tried to do the addition without the atomic tag, we might have gotten the wrong answer due to a race condition. An example of what would happen if we didn't avoid the race:</source>
          <target state="translated">原子タグを使わずに足し算をしようとしていたら、競合条件のために間違った答えが出ていたかもしれません。競合を回避しなかった場合の例。</target>
        </trans-unit>
        <trans-unit id="de960a40df3284e207ad1c9fee37b3f036f0b2a2" translate="yes" xml:space="preserve">
          <source>Hair Space</source>
          <target state="translated">ヘアスペース</target>
        </trans-unit>
        <trans-unit id="2c7a078f496901b9f8903cc399fa79c1c3ab6b95" translate="yes" xml:space="preserve">
          <source>Haircut</source>
          <target state="translated">Haircut</target>
        </trans-unit>
        <trans-unit id="4a11632b50147a0502c9dc634f5c6e0c06ffab6b" translate="yes" xml:space="preserve">
          <source>Half-precision floating-point numbers are also supported (&lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;), but they are implemented in software and use &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; for calculations.</source>
          <target state="translated">半精度浮動小数点数もサポートされていますが（&lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt;）、ソフトウェアで実装され、計算に&lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="94c92dceffd55b3ed538a942cce80806cce37fe1" translate="yes" xml:space="preserve">
          <source>Hamburger</source>
          <target state="translated">Hamburger</target>
        </trans-unit>
        <trans-unit id="ab7b8ea47eadf93146c012e72a5ea673322853aa" translate="yes" xml:space="preserve">
          <source>Hammer</source>
          <target state="translated">Hammer</target>
        </trans-unit>
        <trans-unit id="3bff32cf99bd14d58869cbb0d7d31e1bec45d891" translate="yes" xml:space="preserve">
          <source>Hamster Face</source>
          <target state="translated">ハムスターの顔</target>
        </trans-unit>
        <trans-unit id="3d3f4dc94e3e321e028a018fa9cae5ff030ce957" translate="yes" xml:space="preserve">
          <source>Handbag</source>
          <target state="translated">Handbag</target>
        </trans-unit>
        <trans-unit id="fffe7d81b4e3e0d9952aa6caa3fd530df68b775c" translate="yes" xml:space="preserve">
          <source>Handle a log event</source>
          <target state="translated">ログイベントの処理</target>
        </trans-unit>
        <trans-unit id="e30eba0eb24c7a8fac8f9c3ba83240b293b51b33" translate="yes" xml:space="preserve">
          <source>Handle excess argument diversity in the caller</source>
          <target state="translated">呼び出し元での過剰な引数の多様性の処理</target>
        </trans-unit>
        <trans-unit id="10a3cb0df00f1fa97a3cb63486616c5cf79959d9" translate="yes" xml:space="preserve">
          <source>Handling Operating System Variation</source>
          <target state="translated">オペレーティングシステムの変化への対応</target>
        </trans-unit>
        <trans-unit id="67509204a791b926a290df40bb29deed545a4fe9" translate="yes" xml:space="preserve">
          <source>Happy Person Raising One Hand</source>
          <target state="translated">幸せな人が片手を上げる</target>
        </trans-unit>
        <trans-unit id="31f205e87d98bf7472c8354a4586dfc7173d7021" translate="yes" xml:space="preserve">
          <source>Hatching Chick</source>
          <target state="translated">ひよこの孵化</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="6ef295c2897db61289ad0eb0b8171326ec851011" translate="yes" xml:space="preserve">
          <source>Headphone</source>
          <target state="translated">Headphone</target>
        </trans-unit>
        <trans-unit id="83fbe44a9f704c02d2d76ee1fa5c115010ff9d8c" translate="yes" xml:space="preserve">
          <source>Hear-No-Evil Monkey</source>
          <target state="translated">ヒア・ノー・エビル・モンキー</target>
        </trans-unit>
        <trans-unit id="2edafb06cf3a183a503a1615f5b8c4da86990553" translate="yes" xml:space="preserve">
          <source>Heart Decoration</source>
          <target state="translated">ハートのデコレーション</target>
        </trans-unit>
        <trans-unit id="53648eedc9bfa102fd53ca957c856f7e0d9a2a2f" translate="yes" xml:space="preserve">
          <source>Heart With Arrow</source>
          <target state="translated">アローのあるハート</target>
        </trans-unit>
        <trans-unit id="5461f091ddf4a776ade53602bfcdef544a0feb57" translate="yes" xml:space="preserve">
          <source>Heart With Ribbon</source>
          <target state="translated">リボン付きハート</target>
        </trans-unit>
        <trans-unit id="fde3248d8454a04a4138dae1e5a31ab1432bdb78" translate="yes" xml:space="preserve">
          <source>Heavy Black Heart</source>
          <target state="translated">ヘビーブラックハート</target>
        </trans-unit>
        <trans-unit id="662b2b0a5e62dab41b3f6deba4867bbd60a35b8f" translate="yes" xml:space="preserve">
          <source>Heavy Check Mark</source>
          <target state="translated">ヘビーチェックマーク</target>
        </trans-unit>
        <trans-unit id="9ae6c1b9f7bdda7ce9eec6a4c6ee5efca7c871a5" translate="yes" xml:space="preserve">
          <source>Heavy Division Sign</source>
          <target state="translated">ヘビーディビジョンサイン</target>
        </trans-unit>
        <trans-unit id="7706e6c735cc207b9267e0979a8dbeb69e5229a0" translate="yes" xml:space="preserve">
          <source>Heavy Dollar Sign</source>
          <target state="translated">ヘビーダラーサイン</target>
        </trans-unit>
        <trans-unit id="93e9c9786874a2de0cddf3ee5e7766e4ea031dca" translate="yes" xml:space="preserve">
          <source>Heavy Exclamation Mark Symbol</source>
          <target state="translated">ヘビーエクスクラメーションマーク記号</target>
        </trans-unit>
        <trans-unit id="78800e7776274c794a8d095ff4c2c73221dbbbae" translate="yes" xml:space="preserve">
          <source>Heavy Large Circle</source>
          <target state="translated">ヘビーラージサークル</target>
        </trans-unit>
        <trans-unit id="980c6d0d2733f3166210e842cefb858e063c0d91" translate="yes" xml:space="preserve">
          <source>Heavy Minus Sign</source>
          <target state="translated">ヘビーマイナス記号</target>
        </trans-unit>
        <trans-unit id="778bd00186fa7e144e55b7635e11bf1326888ddd" translate="yes" xml:space="preserve">
          <source>Heavy Multiplication X</source>
          <target state="translated">重い掛け算X</target>
        </trans-unit>
        <trans-unit id="f686b15ee80bdb7a610f665e9bb567ee7025d65c" translate="yes" xml:space="preserve">
          <source>Heavy Plus Sign</source>
          <target state="translated">ヘビープラスサイン</target>
        </trans-unit>
        <trans-unit id="75c1e5a632008728c5938fd7cc30c147bf32b6b5" translate="yes" xml:space="preserve">
          <source>Heavy Teardrop-Spoked Asterisk</source>
          <target state="translated">ヘビーティアドロップスモークアスタリスク</target>
        </trans-unit>
        <trans-unit id="fda201fd52a223f4da8ab6d74bf72a21faeaf60b" translate="yes" xml:space="preserve">
          <source>Helicopter</source>
          <target state="translated">Helicopter</target>
        </trans-unit>
        <trans-unit id="ae573d0f71ca2ef898057a3a11aeabc86f4048c4" translate="yes" xml:space="preserve">
          <source>Help mode</source>
          <target state="translated">ヘルプモード</target>
        </trans-unit>
        <trans-unit id="5941c1bf985d2850f77798f46b591f5bf1a7198a" translate="yes" xml:space="preserve">
          <source>Help mode can be exited by pressing backspace at the beginning of the line.</source>
          <target state="translated">ヘルプモードは、行頭のバックスペースを押すことで解除することができます。</target>
        </trans-unit>
        <trans-unit id="8882ebfc5a29fddc8a80eb230261926f56fd8d5e" translate="yes" xml:space="preserve">
          <source>Herb</source>
          <target state="translated">Herb</target>
        </trans-unit>
        <trans-unit id="bb934b9ceeaa4e54809a9838dfa1ed2cabf6522e" translate="yes" xml:space="preserve">
          <source>Here &quot;inline&quot; refers to elements that can be found within blocks of text, i.e. paragraphs. These include the following elements.</source>
          <target state="translated">ここで、「インライン」とは、テキストのブロック内、すなわち段落内に存在する要素を指す。これには、以下の要素が含まれます。</target>
        </trans-unit>
        <trans-unit id="0aaf5b43ce3bf447f656063f8ac61c46b777eefc" translate="yes" xml:space="preserve">
          <source>Here Enter was pressed again so that Julia would read the newline. Now, as you can see from this example, &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; takes the data to write as its second argument, while &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; takes the type of the data to be read as the second argument.</source>
          <target state="translated">ここでEnterキーがもう一度押されたため、ジュリアは改行を読みました。この例からわかるように、&lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;は書き込むデータを2番目の引数として受け取り、&lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;は読み取るデータのタイプを2番目の引数として受け取ります。</target>
        </trans-unit>
        <trans-unit id="77b8367f53858f5da92aefb29bb20f4abb25843a" translate="yes" xml:space="preserve">
          <source>Here are some examples to demonstrate which type of arrays are strided and which are not:</source>
          <target state="translated">ここでは、どのタイプの配列がストライドされていて、どのタイプの配列がストライドされていないかを示す例を示します。</target>
        </trans-unit>
        <trans-unit id="3b3a2127d824649ba6d32ad8be94f9ae3c5dba0e" translate="yes" xml:space="preserve">
          <source>Here are some examples with bitwise operators:</source>
          <target state="translated">ビット演算子を使った例を紹介します。</target>
        </trans-unit>
        <trans-unit id="c2d9b5adfe6cd0f32ce45f61d872c609d6e0a4ff" translate="yes" xml:space="preserve">
          <source>Here are some simple examples using arithmetic operators:</source>
          <target state="translated">算術演算子を使った簡単な例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="f5ba1cb3713902ae4550268fb70da7530b34b57c" translate="yes" xml:space="preserve">
          <source>Here are some simple examples:</source>
          <target state="translated">簡単な例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="d3d30b41b93723417b3a0eda16323a2baedc0a7c" translate="yes" xml:space="preserve">
          <source>Here are some tips for working with Julia efficiently.</source>
          <target state="translated">ジュリアと効率よく仕事をするためのコツをご紹介します。</target>
        </trans-unit>
        <trans-unit id="4b9dc1697c31ccdd9965aa0170dd226712f2cb14" translate="yes" xml:space="preserve">
          <source>Here each iteration applies &lt;code&gt;f&lt;/code&gt; to a randomly-chosen sample from a vector &lt;code&gt;a&lt;/code&gt; shared by all processes.</source>
          <target state="translated">ここで、各反復は、すべてのプロセスで共有されるベクトル &lt;code&gt;a&lt;/code&gt; からランダムに選択されたサンプルに &lt;code&gt;f&lt;/code&gt; を適用します。</target>
        </trans-unit>
        <trans-unit id="a76feb46cab9b567bf7483afc7491ed744f3c054" translate="yes" xml:space="preserve">
          <source>Here is a corresponding roots structure, represented as a dictionary:</source>
          <target state="translated">ここでは、対応する根の構造を辞書で表しています。</target>
        </trans-unit>
        <trans-unit id="86a5b746f6fe4ea8f489a225c69f586c3ee94b4f" translate="yes" xml:space="preserve">
          <source>Here is a more complex example, still using Markdown:</source>
          <target state="translated">ここでは、Markdownを使用した、より複雑な例を示します。</target>
        </trans-unit>
        <trans-unit id="32a32a63972b7e15e6bc1e1399ca59536eaf91cf" translate="yes" xml:space="preserve">
          <source>Here is a related case in which the expected behaviour is not necessarily obvious: What happens when we round to the nearest &lt;code&gt;P(2)&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a &lt;a href=&quot;#Dates.Period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; type? In some cases (specifically, when &lt;code&gt;P &amp;lt;: Dates.TimePeriod&lt;/code&gt;) the answer is clear:</source>
          <target state="translated">予想される動作が必ずしも明白ではない、関連するケースを次に示します。最も近い &lt;code&gt;P(2)&lt;/code&gt; に丸めるとどうなりますか。ここで、 &lt;code&gt;P&lt;/code&gt; は&lt;a href=&quot;#Dates.Period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt;タイプです。場合によっては（具体的には、 &lt;code&gt;P &amp;lt;: Dates.TimePeriod&lt;/code&gt; ）、答えは明確です。</target>
        </trans-unit>
        <trans-unit id="cbc1a6d954403affcd824e28b3f149fcba6203f0" translate="yes" xml:space="preserve">
          <source>Here is a representation of a possible paths map for our example &lt;code&gt;App&lt;/code&gt; project environment, as provided in the Manifest given above for the dependency graph, after searching the local file system:</source>
          <target state="translated">ローカルファイルシステムを検索した後の、依存関係グラフの上記のマニフェストで提供されている、 &lt;code&gt;App&lt;/code&gt; プロジェクト環境の例の可能なパスマップを次に示します。</target>
        </trans-unit>
        <trans-unit id="62b973b3d8599e23c2d9da9c0813b08faed1d7f5" translate="yes" xml:space="preserve">
          <source>Here is a second example wrapping the corresponding destructor:</source>
          <target state="translated">ここでは、対応するデストラクタをラップする2つ目の例を示します。</target>
        </trans-unit>
        <trans-unit id="383164a53efb4be492fb1a747035c59b715f139a" translate="yes" xml:space="preserve">
          <source>Here is a simple example of a C wrapper that returns a &lt;code&gt;Ptr&lt;/code&gt; type:</source>
          <target state="translated">以下は、 &lt;code&gt;Ptr&lt;/code&gt; 型を返すCラッパーの簡単な例です。</target>
        </trans-unit>
        <trans-unit id="fd4023e74c6b03e666e958ff6141359ac199b811" translate="yes" xml:space="preserve">
          <source>Here is a simplified definition of Julia's &lt;a href=&quot;../../base/base/index#Base.@assert&quot;&gt;&lt;code&gt;@assert&lt;/code&gt;&lt;/a&gt; macro:</source>
          <target state="translated">Juliaの&lt;a href=&quot;../../base/base/index#Base.@assert&quot;&gt; &lt;code&gt;@assert&lt;/code&gt; &lt;/a&gt;マクロの簡単な定義を次に示します。</target>
        </trans-unit>
        <trans-unit id="e40b5507bd00f53ac4347d820f9aea2085f1e997" translate="yes" xml:space="preserve">
          <source>Here is a slightly more complex example that discovers the local machine's hostname:</source>
          <target state="translated">ここでは、ローカルマシンのホスト名を検出する、もう少し複雑な例を示します。</target>
        </trans-unit>
        <trans-unit id="c20460c3bed82c94ed3787e3dfe27ae7c3b31699" translate="yes" xml:space="preserve">
          <source>Here is a third example passing Julia arrays:</source>
          <target state="translated">ここでは、Julia の配列を渡す 3 番目の例を示します。</target>
        </trans-unit>
        <trans-unit id="d610a40401dd7269ef98b9bc1fb559f31c643ca5" translate="yes" xml:space="preserve">
          <source>Here is an even more complex multi-stage producer-consumer example:</source>
          <target state="translated">ここでは、さらに複雑な多段式の生産者と消費者の例を紹介します。</target>
        </trans-unit>
        <trans-unit id="166759fbb289c37473d7a6b4b102bc98c71ab976" translate="yes" xml:space="preserve">
          <source>Here is an example of a &quot;compound function&quot; that should really be written as multiple definitions:</source>
          <target state="translated">ここでは、本当は複数の定義として記述すべき「複合関数」の例を示します。</target>
        </trans-unit>
        <trans-unit id="dff5c26dbc80f0776c11c28a5633445af4d9d175" translate="yes" xml:space="preserve">
          <source>Here is an example with all three kinds of markup. This program first calculates the finite difference of a one-dimensional array, and then evaluates the L2-norm of the result:</source>
          <target state="translated">ここでは,3種類のマークアップを用いた例を示します.このプログラムは,まず1次元配列の有限差分を計算し,その結果のL2ノルムを評価します.</target>
        </trans-unit>
        <trans-unit id="f97cb2973176feb8f941a5117a88dd7fad7d8ec1" translate="yes" xml:space="preserve">
          <source>Here is an example with both &lt;code&gt;@inbounds&lt;/code&gt; and &lt;code&gt;@simd&lt;/code&gt; markup (we here use &lt;code&gt;@noinline&lt;/code&gt; to prevent the optimizer from trying to be too clever and defeat our benchmark):</source>
          <target state="translated">&lt;code&gt;@inbounds&lt;/code&gt; と &lt;code&gt;@simd&lt;/code&gt; の両方のマークアップの例を次に示します（ここでは、オプティマイザーが &lt;code&gt;@noinline&lt;/code&gt; すぎてベンチマークを無効にしようとするのを防ぐために@noinlineを使用しています）。</target>
        </trans-unit>
        <trans-unit id="87f18e8d7ee1b76e68d3166f552e8d656c81958f" translate="yes" xml:space="preserve">
          <source>Here is an extraordinarily simple macro:</source>
          <target state="translated">非常にシンプルなマクロです。</target>
        </trans-unit>
        <trans-unit id="7afc02096736fcb4c01a0c6afaea2e90973eb75e" translate="yes" xml:space="preserve">
          <source>Here is the correct code template for returning the element-type &lt;code&gt;T&lt;/code&gt; of any arbitrary subtype of &lt;code&gt;AbstractArray&lt;/code&gt;:</source>
          <target state="translated">以下は、 &lt;code&gt;AbstractArray&lt;/code&gt; の任意のサブタイプの要素タイプ &lt;code&gt;T&lt;/code&gt; を返すための正しいコードテンプレートです。</target>
        </trans-unit>
        <trans-unit id="5f4fdb43158ce32a870e863c53f180f3aa098a57" translate="yes" xml:space="preserve">
          <source>Here is the corresponding graph structure, represented as a dictionary:</source>
          <target state="translated">ここでは、対応するグラフ構造を辞書で表しています。</target>
        </trans-unit>
        <trans-unit id="f9b6eba975c84af5ac0af3798604d9ad36108359" translate="yes" xml:space="preserve">
          <source>Here module &lt;code&gt;Parent&lt;/code&gt; contains a submodule &lt;code&gt;Utils&lt;/code&gt;, and code in &lt;code&gt;Parent&lt;/code&gt; wants the contents of &lt;code&gt;Utils&lt;/code&gt; to be visible. This is done by starting the &lt;code&gt;using&lt;/code&gt; path with a period. Adding more leading periods moves up additional levels in the module hierarchy. For example &lt;code&gt;using ..Utils&lt;/code&gt; would look for &lt;code&gt;Utils&lt;/code&gt; in &lt;code&gt;Parent&lt;/code&gt;'s enclosing module rather than in &lt;code&gt;Parent&lt;/code&gt; itself.</source>
          <target state="translated">ここでは、モジュール &lt;code&gt;Parent&lt;/code&gt; サブモジュールが含ま &lt;code&gt;Utils&lt;/code&gt; のを、とのコード &lt;code&gt;Parent&lt;/code&gt; 内容望ん &lt;code&gt;Utils&lt;/code&gt; のが見えるようにします。これは、 &lt;code&gt;using&lt;/code&gt; パスをピリオドで開始することによって行われます。先行期間を追加すると、モジュール階層のレベルが上がります。たとえば &lt;code&gt;using ..Utils&lt;/code&gt; 探します &lt;code&gt;Utils&lt;/code&gt; の中で &lt;code&gt;Parent&lt;/code&gt; 「というよりも、モジュールを囲むよ &lt;code&gt;Parent&lt;/code&gt; そのもの。</target>
        </trans-unit>
        <trans-unit id="cf5b1250aa2128de01974785ca5a0cd9b855ebd1" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;1:5&lt;/code&gt; is a range object, representing the sequence of numbers 1, 2, 3, 4, 5. The &lt;code&gt;for&lt;/code&gt; loop iterates through these values, assigning each one in turn to the variable &lt;code&gt;i&lt;/code&gt;. One rather important distinction between the previous &lt;code&gt;while&lt;/code&gt; loop form and the &lt;code&gt;for&lt;/code&gt; loop form is the scope during which the variable is visible. If the variable &lt;code&gt;i&lt;/code&gt; has not been introduced in another scope, in the &lt;code&gt;for&lt;/code&gt; loop form, it is visible only inside of the &lt;code&gt;for&lt;/code&gt; loop, and not outside/afterwards. You'll either need a new interactive session instance or a different variable name to test this:</source>
          <target state="translated">ここで &lt;code&gt;1:5&lt;/code&gt; には、番号1の配列を示し、範囲オブジェクトで2、3、4、5 &lt;code&gt;for&lt;/code&gt; 変数に順番にそれぞれを割り当て、これらの値をループ反復 &lt;code&gt;i&lt;/code&gt; 。以前の &lt;code&gt;while&lt;/code&gt; ループ形式と &lt;code&gt;for&lt;/code&gt; ループ形式のかなり重要な違いの1つは、変数が表示されるスコープです。変数 &lt;code&gt;i&lt;/code&gt; が別のスコープで導入されていない場合、 &lt;code&gt;for&lt;/code&gt; ループ形式では、 &lt;code&gt;for&lt;/code&gt; ループの内部でのみ表示され、外部/以降では表示されません。これをテストするには、新しいインタラクティブセッションインスタンスまたは別の変数名が必要です。</target>
        </trans-unit>
        <trans-unit id="052893fe9e50a40443ea78d54cd3b33cb280eb4e" translate="yes" xml:space="preserve">
          <source>Here the call &lt;code&gt;g(2.0, 3.0)&lt;/code&gt; could be handled by either the &lt;code&gt;g(Float64, Any)&lt;/code&gt; or the &lt;code&gt;g(Any, Float64)&lt;/code&gt; method, and neither is more specific than the other. In such cases, Julia raises a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; rather than arbitrarily picking a method. You can avoid method ambiguities by specifying an appropriate method for the intersection case:</source>
          <target state="translated">ここで、 &lt;code&gt;g(2.0, 3.0)&lt;/code&gt; の呼び出しは、 &lt;code&gt;g(Float64, Any)&lt;/code&gt; または &lt;code&gt;g(Any, Float64)&lt;/code&gt; メソッドのいずれかで処理でき、どちらも特定のものではありません。このような場合、Juliaは任意にメソッドを選択するのではなく、&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;を発生させます。交差のケースに適切なメソッドを指定することで、メソッドのあいまいさを回避できます。</target>
        </trans-unit>
        <trans-unit id="373c14d6a8445cd3c00b580baccefb5fd3f3d12c" translate="yes" xml:space="preserve">
          <source>Here the first number is printed after a delay of two seconds, then the following numbers are printed quickly.</source>
          <target state="translated">ここでは、最初の番号が2秒の遅延の後に印刷され、その後、次の番号が素早く印刷されます。</target>
        </trans-unit>
        <trans-unit id="f3418902a4f242b518d4d5f42412b650db9149b7" translate="yes" xml:space="preserve">
          <source>Here the user expression &lt;code&gt;ex&lt;/code&gt; is a call to &lt;code&gt;time&lt;/code&gt;, but not the same &lt;code&gt;time&lt;/code&gt; function that the macro uses. It clearly refers to &lt;code&gt;MyModule.time&lt;/code&gt;. Therefore we must arrange for the code in &lt;code&gt;ex&lt;/code&gt; to be resolved in the macro call environment. This is done by &quot;escaping&quot; the expression with &lt;a href=&quot;../../base/base/index#Base.esc&quot;&gt;&lt;code&gt;esc&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">ここで、ユーザー式 &lt;code&gt;ex&lt;/code&gt; は &lt;code&gt;time&lt;/code&gt; の呼び出しですが、マクロが使用するのと同じ &lt;code&gt;time&lt;/code&gt; 関数ではありません。 &lt;code&gt;MyModule.time&lt;/code&gt; を明確に参照しています。したがって、マクロ呼び出し環境で &lt;code&gt;ex&lt;/code&gt; のコードが解決されるようにする必要があります。これは、&lt;a href=&quot;../../base/base/index#Base.esc&quot;&gt; &lt;code&gt;esc&lt;/code&gt; で&lt;/a&gt;式を「エスケープ」することによって行われます。</target>
        </trans-unit>
        <trans-unit id="319de09db8b0ceed706c2722ad8c4f12c486b513" translate="yes" xml:space="preserve">
          <source>Here the zero-argument constructor method calls the single-argument constructor method, which in turn calls the automatically provided two-argument constructor method. For reasons that will become clear very shortly, additional constructor methods declared as normal methods like this are called &lt;em&gt;outer&lt;/em&gt; constructor methods. Outer constructor methods can only ever create a new instance by calling another constructor method, such as the automatically provided default ones.</source>
          <target state="translated">ここでは、引数のないコンストラクターメソッドが単一引数のコンストラクターメソッドを呼び出し、次に、引数が自動的に提供される2つの引数のコンストラクターメソッドを呼び出します。すぐに明らかになる理由により、このような通常のメソッドとして宣言された追加のコンストラクターメソッドは、&lt;em&gt;外部&lt;/em&gt;コンストラクターメソッドと呼ばれます。外部コンストラクタメソッドは、自動的に提供されるデフォルトのコンストラクタなど、別のコンストラクタメソッドを呼び出すことによってのみ新しいインスタンスを作成できます。</target>
        </trans-unit>
        <trans-unit id="754489125a9dd659e2690c5c486d5c6350ca9a2b" translate="yes" xml:space="preserve">
          <source>Here we create and store two closures that return variable &lt;code&gt;i&lt;/code&gt;. However, it is always the same variable &lt;code&gt;i&lt;/code&gt;, so the two closures behave identically. We can use &lt;code&gt;let&lt;/code&gt; to create a new binding for &lt;code&gt;i&lt;/code&gt;:</source>
          <target state="translated">ここでは、変数 &lt;code&gt;i&lt;/code&gt; を返す2つのクロージャーを作成して保存します。ただし、これは常に同じ変数 &lt;code&gt;i&lt;/code&gt; であるため、2つのクロージャは同じように動作します。 &lt;code&gt;let&lt;/code&gt; を使用して、 &lt;code&gt;i&lt;/code&gt; の新しいバインディングを作成できます。</target>
        </trans-unit>
        <trans-unit id="f311d723a18a177fef2791eca3f472638877d565" translate="yes" xml:space="preserve">
          <source>Here we created a function &lt;code&gt;change_array!&lt;/code&gt;, that assigns &lt;code&gt;5&lt;/code&gt; to the first element of the passed array (bound to &lt;code&gt;x&lt;/code&gt; at the call site, and bound to &lt;code&gt;A&lt;/code&gt; within the function). Notice that, after the function call, &lt;code&gt;x&lt;/code&gt; is still bound to the same array, but the content of that array changed: the variables &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; were distinct bindings referring to the same mutable &lt;code&gt;Array&lt;/code&gt; object.</source>
          <target state="translated">ここでは、関数 &lt;code&gt;change_array!&lt;/code&gt; を作成しました。、渡された配列の最初の要素に &lt;code&gt;5&lt;/code&gt; を割り当てます（呼び出しサイトで &lt;code&gt;x&lt;/code&gt; にバインドされ、関数内で &lt;code&gt;A&lt;/code&gt; にバインドされます）。関数呼び出しの後も、 &lt;code&gt;x&lt;/code&gt; は同じ配列にバインドされていますが、その配列の内容は変更されています。変数 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;x&lt;/code&gt; は、同じ可変の &lt;code&gt;Array&lt;/code&gt; オブジェクトを参照する別個のバインディングでした。</target>
        </trans-unit>
        <trans-unit id="97836fe829ccf3f620529d58616382e12cd6d98d" translate="yes" xml:space="preserve">
          <source>Here we have created a type &lt;code&gt;BitVector&lt;/code&gt; which has no parameters, but where the element-type is still fully specified, with &lt;code&gt;T&lt;/code&gt; equal to &lt;code&gt;Bool&lt;/code&gt;!</source>
          <target state="translated">ここでは、パラメーターのないタイプ &lt;code&gt;BitVector&lt;/code&gt; を作成しましたが、要素タイプはまだ完全に指定されており、 &lt;code&gt;T&lt;/code&gt; は &lt;code&gt;Bool&lt;/code&gt; に等しくなっています。</target>
        </trans-unit>
        <trans-unit id="2b9af6aad35623f9ee689638f54770ed7633fd26" translate="yes" xml:space="preserve">
          <source>Here's a brief example:</source>
          <target state="translated">簡単な例を挙げてみましょう。</target>
        </trans-unit>
        <trans-unit id="e0b11719421310c6cc4a896b044019316b57f70b" translate="yes" xml:space="preserve">
          <source>Here's a simple example of running an external program:</source>
          <target state="translated">ここでは、外部プログラムを実行する簡単な例を紹介します。</target>
        </trans-unit>
        <trans-unit id="20a6acaa904201f8599df8ef13450aeef27c5681" translate="yes" xml:space="preserve">
          <source>Here, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in the &lt;code&gt;do ... end&lt;/code&gt; block. After your function exits, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; will make sure that the stream is properly closed, regardless of whether your function exited normally or threw an exception. (The &lt;code&gt;try/finally&lt;/code&gt; construct will be described in &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;Control Flow&lt;/a&gt;.)</source>
          <target state="translated">ここでは、&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; は&lt;/a&gt;最初にファイルを書き込み用に開き、次に結果の出力ストリームを &lt;code&gt;do ... end&lt;/code&gt; ブロックで定義した無名関数に渡します。関数が終了した後、&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;は、関数が正常に終了したか例外をスローしたかに関係なく、ストリームが適切に閉じられていることを確認します。（ &lt;code&gt;try/finally&lt;/code&gt; コンストラクトについては、&lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;制御フロー&lt;/a&gt;で説明します。）</target>
        </trans-unit>
        <trans-unit id="7a90ca3f6b58f2547fca94266c1813296e387071" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(2, 3)&lt;/code&gt; is a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;(2, 3)&lt;/code&gt; は&lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="5216371c7d0926d72d95ff987a3d80e32321d1dd" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;count&lt;/code&gt; finds the number of commits along the walk with a certain &lt;code&gt;GitHash&lt;/code&gt;. Since the &lt;code&gt;GitHash&lt;/code&gt; is unique to a commit, &lt;code&gt;cnt&lt;/code&gt; will be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;count&lt;/code&gt; は、特定の &lt;code&gt;GitHash&lt;/code&gt; でのウォークに沿ったコミットの数を見つけます。以来 &lt;code&gt;GitHash&lt;/code&gt; がコミットに一意である、 &lt;code&gt;cnt&lt;/code&gt; なります &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2161ca87d055525464e4a5b1fd21109ca2813404" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;map&lt;/code&gt; visits each commit using the &lt;code&gt;GitRevWalker&lt;/code&gt; and finds its &lt;code&gt;GitHash&lt;/code&gt;.</source>
          <target state="translated">ここでは、 &lt;code&gt;map&lt;/code&gt; 訪問は、それぞれ使用してコミット &lt;code&gt;GitRevWalker&lt;/code&gt; をし、その見つけ &lt;code&gt;GitHash&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="290a784ce45faad752be9227fb340601f3f76ead" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;sp.data&lt;/code&gt; refers to the second parameter in the call to the &lt;code&gt;SamplerSimple&lt;/code&gt; constructor (in this case equal to &lt;code&gt;Sampler(rng, 1:die.nsides, r)&lt;/code&gt;), while the &lt;code&gt;Die&lt;/code&gt; object can be accessed via &lt;code&gt;sp[]&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;sp.data&lt;/code&gt; は &lt;code&gt;SamplerSimple&lt;/code&gt; コンストラクターへの呼び出しの2番目のパラメーター（この場合は &lt;code&gt;Sampler(rng, 1:die.nsides, r)&lt;/code&gt; 参照し、 &lt;code&gt;Die&lt;/code&gt; オブジェクトは &lt;code&gt;sp[]&lt;/code&gt; 介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="e6537ead3e178965ea266058307a50f1c2fbf640" translate="yes" xml:space="preserve">
          <source>Here, Julia was able to detect that &lt;code&gt;B&lt;/code&gt; is in fact symmetric, and used a more appropriate factorization. Often it's possible to write more efficient code for a matrix that is known to have certain properties e.g. it is symmetric, or tridiagonal. Julia provides some special types so that you can &quot;tag&quot; matrices as having these properties. For instance:</source>
          <target state="translated">ここで、ジュリアは &lt;code&gt;B&lt;/code&gt; が実際に対称であることを検出でき、より適切な因数分解を使用しました。多くの場合、特定のプロパティを持っていることが知られているマトリックスに対してより効率的なコードを書くことが可能です。Juliaはいくつかの特別なタイプを提供して、マトリックスにこれらのプロパティを持つものとして「タグ付け」できるようにします。例えば：</target>
        </trans-unit>
        <trans-unit id="c40867232cf6016f6f8e42d642627bb64b253d86" translate="yes" xml:space="preserve">
          <source>Here, the evaluation of an expression object causes a value to be assigned to the global variable &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">ここでは、式オブジェクトの評価により、グローバル変数 &lt;code&gt;x&lt;/code&gt; に値が割り当てられます。</target>
        </trans-unit>
        <trans-unit id="c4e6a3f428f565fb6b0000baaea7b4aa785dbcfc" translate="yes" xml:space="preserve">
          <source>Here, the input &lt;code&gt;p&lt;/code&gt; is declared to be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, meaning that the memory that &lt;code&gt;p&lt;/code&gt; points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, but it is convertible using &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; and therefore can be used in the same (covariant) context of the input argument to a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;. A pointer to memory allocated by Julia must be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, to ensure that the memory address pointed to is valid and that Julia's garbage collector manages the chunk of memory pointed to correctly. Therefore, the &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; declaration allows pointers managed by C or Julia to be used.</source>
          <target state="translated">ここで、入力 &lt;code&gt;p&lt;/code&gt; は &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; 型として宣言されています。これは、 &lt;code&gt;p&lt;/code&gt; が指すメモリがJuliaまたはCによって管理される可能性があることを意味します。Cによって割り当てられたメモリへのポインタは、 &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt; 型である必要がありますが、&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt;を使用して変換できるため、&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;への入力引数と同じ（共変）コンテキストで使用できます。Juliaによって割り当てられたメモリへのポインタは &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; 型である必要があります。これは、ポイントされたメモリアドレスが有効であり、Juliaのガベージコレクタがポイントされたメモリのチャンクを正しく管理していることを確認します。したがって、 &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; 宣言により、CまたはJuliaによって管理されるポインターを使用できます。</target>
        </trans-unit>
        <trans-unit id="1ab09345f1dd2caf08c8b3f5ca36d5682164ea59" translate="yes" xml:space="preserve">
          <source>Here, the option &lt;code&gt;--math-mode=ieee&lt;/code&gt; disables the &lt;code&gt;@fastmath&lt;/code&gt; macro, so that we can compare results.</source>
          <target state="translated">ここで、オプション &lt;code&gt;--math-mode=ieee&lt;/code&gt; は &lt;code&gt;@fastmath&lt;/code&gt; マクロを無効にし、結果を比較できるようにします。</target>
        </trans-unit>
        <trans-unit id="6cbc6c9a872faab52c966ca377e3e05b9b758b19" translate="yes" xml:space="preserve">
          <source>Here, the total produced by &lt;code&gt;sum&lt;/code&gt; is passed to the &lt;code&gt;sqrt&lt;/code&gt; function. The equivalent composition would be:</source>
          <target state="translated">ここでは、 &lt;code&gt;sum&lt;/code&gt; によって生成された合計が関数 &lt;code&gt;sqrt&lt;/code&gt; に渡されます。同等の構成は次のようになります。</target>
        </trans-unit>
        <trans-unit id="eab8445a2aa7f75fce1fbdd298d4317a2e164c25" translate="yes" xml:space="preserve">
          <source>Here, we happened to know that the first element of &lt;code&gt;a&lt;/code&gt; would be an &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;. Making an annotation like this has the added benefit that it will raise a run-time error if the value is not of the expected type, potentially catching certain bugs earlier.</source>
          <target state="translated">ここで、&lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt;も &lt;code&gt;a&lt;/code&gt; の最初の要素がInt32であることがわかりました。このようなアノテーションを作成すると、値が予期したタイプではない場合にランタイムエラーが発生し、特定のバグを早期に検出できるという追加の利点があります。</target>
        </trans-unit>
        <trans-unit id="3b5f47a75f954e4b2fddf51e62aa2e1f9d263c7c" translate="yes" xml:space="preserve">
          <source>Here, we want &lt;code&gt;t0&lt;/code&gt;, &lt;code&gt;t1&lt;/code&gt;, and &lt;code&gt;val&lt;/code&gt; to be private temporary variables, and we want &lt;code&gt;time&lt;/code&gt; to refer to the &lt;code&gt;time&lt;/code&gt; function in Julia Base, not to any &lt;code&gt;time&lt;/code&gt; variable the user might have (the same applies to &lt;code&gt;println&lt;/code&gt;). Imagine the problems that could occur if the user expression &lt;code&gt;ex&lt;/code&gt; also contained assignments to a variable called &lt;code&gt;t0&lt;/code&gt;, or defined its own &lt;code&gt;time&lt;/code&gt; variable. We might get errors, or mysteriously incorrect behavior.</source>
          <target state="translated">ここでは、 &lt;code&gt;t0&lt;/code&gt; 、 &lt;code&gt;t1&lt;/code&gt; 、および &lt;code&gt;val&lt;/code&gt; をプライベートな一時変数にし、ユーザーが持つ可能性のある &lt;code&gt;time&lt;/code&gt; 変数ではなく、Julia Baseの &lt;code&gt;time&lt;/code&gt; 関数を参照する &lt;code&gt;time&lt;/code&gt; を求めます（ &lt;code&gt;println&lt;/code&gt; にも同じことが当てはまります）。ユーザー式 &lt;code&gt;ex&lt;/code&gt; に &lt;code&gt;t0&lt;/code&gt; と呼ばれる変数への割り当てが含まれているか、独自の &lt;code&gt;time&lt;/code&gt; 変数が定義されている場合に発生する可能性がある問題を想像してください。エラーや不思議な不正確な動作が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="94fb6a6428243b8c36b29add8e81342285442dea" translate="yes" xml:space="preserve">
          <source>Here, we've added a custom constructor function so that it can take arguments of different &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; types and promote them to a common type (see &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt; and &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt;). (Of course, we would have to define lots of other methods, too, to make it act like a &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;one&lt;/code&gt;, &lt;code&gt;zero&lt;/code&gt;, promotion rules and so on.) By default, instances of this type display rather simply, with information about the type name and the field values, as e.g. &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt;.</source>
          <target state="translated">ここでは、異なる&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;型の引数を取り、それらを共通の型に昇格できるように、カスタムコンストラクター関数を追加しました（&lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;コンストラクター&lt;/a&gt;と&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;変換および昇格を&lt;/a&gt;参照）。 （もちろん、他の多くのメソッドも定義して、&lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; の&lt;/a&gt;ように機能させる必要があります（例： &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;one&lt;/code&gt; 、 &lt;code&gt;zero&lt;/code&gt; 、プロモーションルールなど）。デフォルトでは、このタイプのインスタンスはかなり単純に表示されます。 、タイプ名およびフィールド値に関する情報を、例えば、などの &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a8c4e9914a1889e98efb20fcf34b5a7f7c01253" translate="yes" xml:space="preserve">
          <source>Here, you've created the same problem all over again: the compiler can't guess what &lt;code&gt;n&lt;/code&gt; is, so it doesn't know the &lt;em&gt;type&lt;/em&gt; of &lt;code&gt;Val(n)&lt;/code&gt;. Attempting to use &lt;code&gt;Val&lt;/code&gt;, but doing so incorrectly, can easily make performance &lt;em&gt;worse&lt;/em&gt; in many situations. (Only in situations where you're effectively combining &lt;code&gt;Val&lt;/code&gt; with the function-barrier trick, to make the kernel function more efficient, should code like the above be used.)</source>
          <target state="translated">ここでは、同じ問題を繰り返し作成しました。コンパイラーは &lt;code&gt;n&lt;/code&gt; が何であるかを推測できないため、 &lt;code&gt;Val(n)&lt;/code&gt; の&lt;em&gt;タイプ&lt;/em&gt;を認識していません。 &lt;code&gt;Val&lt;/code&gt; を使用しようとすると、それを誤って行うと、多くの状況でパフォーマンスが&lt;em&gt;低下&lt;/em&gt;しやすくなります。（ &lt;code&gt;Val&lt;/code&gt; を関数バリアトリックと効果的に組み合わせる状況でのみ、カーネル関数をより効率的にするには、上記のようなコードを使用する必要があります。）&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c7628673517938376c201f828128315e60314655" translate="yes" xml:space="preserve">
          <source>Hermitian Conjugate Matrix</source>
          <target state="translated">エルミトス共役行列</target>
        </trans-unit>
        <trans-unit id="7426047f57253430c62cd4ed4e8350b30626acf7" translate="yes" xml:space="preserve">
          <source>Hermitian matrix</source>
          <target state="translated">仙人行列</target>
        </trans-unit>
        <trans-unit id="10678e1b00011a887c8ed10343c313db680c592e" translate="yes" xml:space="preserve">
          <source>Hessenberg decomposition</source>
          <target state="translated">ヘッセンベルク分解</target>
        </trans-unit>
        <trans-unit id="18dcd84b08d39e78997dcf4fc69cbfdf65766429" translate="yes" xml:space="preserve">
          <source>Hex bytes (&lt;code&gt;\x&lt;/code&gt; with 1-2 trailing hex digits)</source>
          <target state="translated">16進バイト（1から2桁の16進数が続く &lt;code&gt;\x&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="5829ae1ed6f556d7c22293c127a375905a4cde38" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point literals are also valid, but only as &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values, with &lt;code&gt;p&lt;/code&gt; preceding the base-2 exponent:</source>
          <target state="translated">16進浮動小数点リテラルも有効ですが、&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;値としてのみ、 &lt;code&gt;p&lt;/code&gt; が 2を底とする指数の前にあります。</target>
        </trans-unit>
        <trans-unit id="566a781a74cd1186e4a86a913b9dfbcd8a9760f5" translate="yes" xml:space="preserve">
          <source>Hibiscus</source>
          <target state="translated">Hibiscus</target>
        </trans-unit>
        <trans-unit id="590d79aff0a27abac1599349b9f60e654406e4f9" translate="yes" xml:space="preserve">
          <source>High Brightness Symbol</source>
          <target state="translated">高輝度シンボル</target>
        </trans-unit>
        <trans-unit id="5c42b554d600e8a00d6d46015f5546b8d19934a3" translate="yes" xml:space="preserve">
          <source>High Voltage Sign</source>
          <target state="translated">高電圧記号</target>
        </trans-unit>
        <trans-unit id="ab1b93cb46a149db7c34f14c047358adef0d1f47" translate="yes" xml:space="preserve">
          <source>High-Heeled Shoe</source>
          <target state="translated">ハイヒールの靴</target>
        </trans-unit>
        <trans-unit id="22cda4a90e394a1d9c3ad940b9369d0797179dd6" translate="yes" xml:space="preserve">
          <source>High-Level Embedding</source>
          <target state="translated">ハイレベルエンベッディング</target>
        </trans-unit>
        <trans-unit id="772ba23e35e2b9a933b76e30398f7eb414430f46" translate="yes" xml:space="preserve">
          <source>High-Level Embedding on Windows with Visual Studio</source>
          <target state="translated">Visual Studioを使ったWindowsでの高レベルエンベッディング</target>
        </trans-unit>
        <trans-unit id="9f567cb6bf549d8f1f72a7aad5d5c25bc17a082a" translate="yes" xml:space="preserve">
          <source>High-Speed Train</source>
          <target state="translated">高速列車</target>
        </trans-unit>
        <trans-unit id="00e1cd5d9c96d48229c7017e30357cb8a8d1334d" translate="yes" xml:space="preserve">
          <source>High-Speed Train With Bullet Nose</source>
          <target state="translated">弾丸の鼻が付いている高速列車</target>
        </trans-unit>
        <trans-unit id="1b2be27c3b5a49f7125a227298d591cb7aea55af" translate="yes" xml:space="preserve">
          <source>High-level libraries like &lt;a href=&quot;https://github.com/JuliaComputing/ArrayFire.jl&quot;&gt;ArrayFire.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/GPUArrays.jl&quot;&gt;GPUArrays.jl&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/JuliaComputing/ArrayFire.jl&quot;&gt;ArrayFire.jl&lt;/a&gt;や&lt;a href=&quot;https://github.com/JuliaGPU/GPUArrays.jl&quot;&gt;GPUArrays.jl&lt;/a&gt;などの高レベルライブラリ</target>
        </trans-unit>
        <trans-unit id="7e0b3549b5782921269587cd589e55b82058b718" translate="yes" xml:space="preserve">
          <source>High-level vendor-specific abstractions like &lt;a href=&quot;https://github.com/JuliaGPU/CuArrays.jl&quot;&gt;CuArrays.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/CLArrays.jl&quot;&gt;CLArrays.jl&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/JuliaGPU/CuArrays.jl&quot;&gt;CuArrays.jl&lt;/a&gt;や&lt;a href=&quot;https://github.com/JuliaGPU/CLArrays.jl&quot;&gt;CLArrays.jl&lt;/a&gt;などのベンダー固有の高レベルの抽象化</target>
        </trans-unit>
        <trans-unit id="cef2d62c8136407d7a5910b738c2a4954d1ff380" translate="yes" xml:space="preserve">
          <source>Hocho</source>
          <target state="translated">Hocho</target>
        </trans-unit>
        <trans-unit id="1183df425fd69adfff4afc7c4b9f794b3027f62e" translate="yes" xml:space="preserve">
          <source>Hold up: why macros?</source>
          <target state="translated">待ってください:なぜマクロなのですか?</target>
        </trans-unit>
        <trans-unit id="a19d1b5e13bc5eadd5512a5657629c48486fc2aa" translate="yes" xml:space="preserve">
          <source>Holds a reference to an object of type &lt;code&gt;T&lt;/code&gt;, ensuring that it is only accessed atomically, i.e. in a thread-safe manner.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; のオブジェクトへの参照を保持し、それがアトミックに、つまりスレッドセーフな方法でのみアクセスされることを保証します。</target>
        </trans-unit>
        <trans-unit id="6d4b2c4793516d9999da8f3caabfcc7a3164599f" translate="yes" xml:space="preserve">
          <source>Home, &lt;code&gt;^A&lt;/code&gt;</source>
          <target state="translated">ホーム、 &lt;code&gt;^A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85d163149ee6c8d4bb4972a8d9d62f2349badb11" translate="yes" xml:space="preserve">
          <source>Homothetic</source>
          <target state="translated">Homothetic</target>
        </trans-unit>
        <trans-unit id="642aac9525060b37b0f7470d6f6c49db706b03d9" translate="yes" xml:space="preserve">
          <source>Honey Pot</source>
          <target state="translated">ハニーポット</target>
        </trans-unit>
        <trans-unit id="a643db335a306154edebc33a5e2763a380d1411b" translate="yes" xml:space="preserve">
          <source>Honeybee</source>
          <target state="translated">Honeybee</target>
        </trans-unit>
        <trans-unit id="79734fdcfe66d25a072a5769ba821cd7967d89f5" translate="yes" xml:space="preserve">
          <source>Hooking into the &lt;code&gt;Random&lt;/code&gt; API</source>
          <target state="translated">&lt;code&gt;Random&lt;/code&gt; API へのフック</target>
        </trans-unit>
        <trans-unit id="a938072797969a150ccb7384d30e3585d81c5ec0" translate="yes" xml:space="preserve">
          <source>Horizontal Black Hexagon</source>
          <target state="translated">横型黒六角</target>
        </trans-unit>
        <trans-unit id="9d0c97d942673d5e711ab71b642cc25b6f24a2b9" translate="yes" xml:space="preserve">
          <source>Horizontal Ellipsis</source>
          <target state="translated">水平方向のエリプシス</target>
        </trans-unit>
        <trans-unit id="3627a44f223e474759956cf47448b20612b0d19a" translate="yes" xml:space="preserve">
          <source>Horizontal Traffic Light</source>
          <target state="translated">水平方向の信号機</target>
        </trans-unit>
        <trans-unit id="b7e611daf03b332b5f4ec9209097868ee372b256" translate="yes" xml:space="preserve">
          <source>Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.</source>
          <target state="translated">1回の呼び出しで水平と垂直の連結を行います。この関数はブロック行列構文のために呼び出されます。第1引数には、各ブロック行で連結する引数の数を指定します。</target>
        </trans-unit>
        <trans-unit id="f26372d5f0aca43e155e7d006ab50ec72ec57fe2" translate="yes" xml:space="preserve">
          <source>Horizontal rules</source>
          <target state="translated">水平方向のルール</target>
        </trans-unit>
        <trans-unit id="26dfe8116b93ced6cfca858f375d23f1489d3207" translate="yes" xml:space="preserve">
          <source>Horse</source>
          <target state="translated">Horse</target>
        </trans-unit>
        <trans-unit id="4a166dcec39a913a939b3a42f695d1c218fcaebb" translate="yes" xml:space="preserve">
          <source>Horse Face</source>
          <target state="translated">馬の顔</target>
        </trans-unit>
        <trans-unit id="8f21624d2501467ee4a054c705bd995e4b73ebab" translate="yes" xml:space="preserve">
          <source>Horse Racing</source>
          <target state="translated">競馬</target>
        </trans-unit>
        <trans-unit id="dbb927867e102f755c1433b1f25539bafdd7268b" translate="yes" xml:space="preserve">
          <source>Hospital</source>
          <target state="translated">Hospital</target>
        </trans-unit>
        <trans-unit id="ef97c144078e1020e0c1fdf8b383ff06d12e8270" translate="yes" xml:space="preserve">
          <source>Hot Beverage</source>
          <target state="translated">ホット飲料</target>
        </trans-unit>
        <trans-unit id="cb506dd41a005a6fcc0d4c18104ce66e01d7afa8" translate="yes" xml:space="preserve">
          <source>Hot Springs</source>
          <target state="translated">熱水泉</target>
        </trans-unit>
        <trans-unit id="9c4ba7d047eb56093b34e5dc3e51e5fcc74603f4" translate="yes" xml:space="preserve">
          <source>Hotel</source>
          <target state="translated">Hotel</target>
        </trans-unit>
        <trans-unit id="fcc1b57017e3ac9f33e4e51068baf64a23795adf" translate="yes" xml:space="preserve">
          <source>Hourglass</source>
          <target state="translated">Hourglass</target>
        </trans-unit>
        <trans-unit id="bf7a0304247679d7272f0a79f9d388f130597fd4" translate="yes" xml:space="preserve">
          <source>Hourglass With Flowing Sand</source>
          <target state="translated">流れる砂と砂時計</target>
        </trans-unit>
        <trans-unit id="dc8745ba30beefa5d028f85ba9b11599a2ac8d7e" translate="yes" xml:space="preserve">
          <source>House</source>
          <target state="translated">House</target>
        </trans-unit>
        <trans-unit id="b6ac911209d87615e6f295e017b36c332cd3b878" translate="yes" xml:space="preserve">
          <source>House Building</source>
          <target state="translated">家づくり</target>
        </trans-unit>
        <trans-unit id="b07df507eb5fd0e4b6c36328d58c64ebcc7b5d32" translate="yes" xml:space="preserve">
          <source>House With Garden</source>
          <target state="translated">庭のある家</target>
        </trans-unit>
        <trans-unit id="eefa8d28bdac822ea112d7e5259409579ba61c80" translate="yes" xml:space="preserve">
          <source>How can I modify the declaration of a type in my session?</source>
          <target state="translated">セッションで型の宣言を修正するにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="515d85b9b31cb430ad4b0705dfed0fd34c859e1a" translate="yes" xml:space="preserve">
          <source>How did the file name get quoted? Julia knows that &lt;code&gt;file&lt;/code&gt; is meant to be interpolated as a single argument, so it quotes the word for you. Actually, that is not quite accurate: the value of &lt;code&gt;file&lt;/code&gt; is never interpreted by a shell, so there's no need for actual quoting; the quotes are inserted only for presentation to the user. This will even work if you interpolate a value as part of a shell word:</source>
          <target state="translated">ファイル名はどのように引用されましたか？ジュリアは、 &lt;code&gt;file&lt;/code&gt; が単一の引数として補間されることを意図していることを知っているため、単語を引用します。値：実際に、それは非常に正確ではない &lt;code&gt;file&lt;/code&gt; 、シェルによって解釈されることはありませんので、実際の引用のための必要はありません。引用符は、ユーザーに提示するためにのみ挿入されます。これは、シェルワードの一部として値を補間する場合でも機能します。</target>
        </trans-unit>
        <trans-unit id="7554712c2d173a82ff8ff4725649f94b899a6cab" translate="yes" xml:space="preserve">
          <source>How do I catch CTRL-C in a script?</source>
          <target state="translated">スクリプトでCTRL-Cをキャッチするには?</target>
        </trans-unit>
        <trans-unit id="2a65d886539b09798da7278037976d95b79a6f2f" translate="yes" xml:space="preserve">
          <source>How do I check if the current file is being run as the main script?</source>
          <target state="translated">現在のファイルがメインスクリプトとして実行されているかどうかを確認するには?</target>
        </trans-unit>
        <trans-unit id="07f058f4bf96d455fe968f2d1e89bd25936e7928" translate="yes" xml:space="preserve">
          <source>How do I delete an object in memory?</source>
          <target state="translated">メモリ内のオブジェクトを削除するには?</target>
        </trans-unit>
        <trans-unit id="b215618760cff9b8483504445b91edb71bee5871" translate="yes" xml:space="preserve">
          <source>How do I pass options to &lt;code&gt;julia&lt;/code&gt; using &lt;code&gt;#!/usr/bin/env&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;#!/usr/bin/env&lt;/code&gt; を使用して &lt;code&gt;julia&lt;/code&gt; にオプションを渡すにはどうすればよいですか？</target>
        </trans-unit>
        <trans-unit id="eb9157ff1fb18352038c8a12eae2a15bbdb246dd" translate="yes" xml:space="preserve">
          <source>How does &quot;null&quot;, &quot;nothingness&quot; or &quot;missingness&quot; work in Julia?</source>
          <target state="translated">ジュリアの中で「ヌル」「無」「欠落」はどのように働くのでしょうか?</target>
        </trans-unit>
        <trans-unit id="fd885280d6cbd9f996932c72e9d360397c1bf016" translate="yes" xml:space="preserve">
          <source>How does one construct a &lt;code&gt;Point&lt;/code&gt; object? It is possible to define custom constructors for composite types, which will be discussed in detail in &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt;, but in the absence of any special constructor declarations, there are two default ways of creating new composite objects, one in which the type parameters are explicitly given and the other in which they are implied by the arguments to the object constructor.</source>
          <target state="translated">どのようにして &lt;code&gt;Point&lt;/code&gt; オブジェクトを構築しますか？複合型のカスタムコンストラクターを定義することは可能です。これについては、&lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;コンストラクター&lt;/a&gt;で詳しく説明しますが、特別なコンストラクター宣言がない場合、新しい複合オブジェクトを作成するデフォルトの方法が2つあり、1つは型パラメーターが明示的に指定されます。もう1つは、オブジェクトコンストラクターへの引数によって暗黙指定されます。</target>
        </trans-unit>
        <trans-unit id="06e308a7a0638232b6f09929d443c3620a3b020e" translate="yes" xml:space="preserve">
          <source>How these arguments are initialized depends on the &quot;outer&quot; function; here, &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; will sequentially set &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, calling the anonymous function on each, just as would happen in the syntax &lt;code&gt;map(func, [A, B, C])&lt;/code&gt;.</source>
          <target state="translated">これらの引数の初期化方法は、「外部」関数によって異なります。ここで、&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;は、構文 &lt;code&gt;map(func, [A, B, C])&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; を順次 &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; に設定し、それぞれに対して無名関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="eaf97b67896b3cc13483847a79f98eac92d8c7ad" translate="yes" xml:space="preserve">
          <source>How you use this information is up to you. Obviously, it would be far and away best to fix &lt;code&gt;pos&lt;/code&gt; to be type-stable: if you did so, all of the variables in &lt;code&gt;f&lt;/code&gt; would be concrete, and its performance would be optimal. However, there are circumstances where this kind of &lt;em&gt;ephemeral&lt;/em&gt; type instability might not matter too much: for example, if &lt;code&gt;pos&lt;/code&gt; is never used in isolation, the fact that &lt;code&gt;f&lt;/code&gt;'s output is type-stable (for &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; inputs) will shield later code from the propagating effects of type instability. This is particularly relevant in cases where fixing the type instability is difficult or impossible. In such cases, the tips above (e.g., adding type annotations and/or breaking up functions) are your best tools to contain the &quot;damage&quot; from type instability. Also, note that even Julia Base has functions that are type unstable. For example, the function &lt;code&gt;findfirst&lt;/code&gt; returns the index into an array where a key is found, or &lt;code&gt;nothing&lt;/code&gt; if it is not found, a clear type instability. In order to make it easier to find the type instabilities that are likely to be important, &lt;code&gt;Union&lt;/code&gt;s containing either &lt;code&gt;missing&lt;/code&gt; or &lt;code&gt;nothing&lt;/code&gt; are color highlighted in yellow, instead of red.</source>
          <target state="translated">この情報の使い方はあなた次第です。明らかに、 &lt;code&gt;pos&lt;/code&gt; を型安定に修正するのがはるかに最善です。そうすると、 &lt;code&gt;f&lt;/code&gt; のすべての変数が具象になり、そのパフォーマンスが最適になります。ただし、この種の&lt;em&gt;一時的な&lt;/em&gt;型の不安定性がそれほど問題にならない状況もあります。たとえば、 &lt;code&gt;pos&lt;/code&gt; が単独で使用されない場合、 &lt;code&gt;f&lt;/code&gt; の出力は型が安定しているという事実（&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; の場合)&lt;/a&gt;入力）は、型の不安定性の伝播する影響から後のコードを保護します。これは、型の不安定性を修正することが困難または不可能である場合に特に関係があります。そのような場合、上記のヒント（たとえば、型注釈の追加や関数の分割）は、型の不安定性による「損傷」を抑えるための最良のツールです。また、Julia Baseにも不安定型の関数があることに注意してください。たとえば、関数 &lt;code&gt;findfirst&lt;/code&gt; は、キーが見つかった配列のインデックスを返すか、キーが見つから &lt;code&gt;nothing&lt;/code&gt; 場合は何もない、明確な型の不安定性を返します。重要である可能性が高い型の不安定性を見つけやすくするために、 &lt;code&gt;Union&lt;/code&gt; には &lt;code&gt;missing&lt;/code&gt; か、 &lt;code&gt;nothing&lt;/code&gt; 含まれていない 赤ではなく黄色でハイライトされた色です。</target>
        </trans-unit>
        <trans-unit id="042ec23eb15357af1265112d56deb61892b131f1" translate="yes" xml:space="preserve">
          <source>However one should keep in mind, that macro dispatch is based on the types of AST that are handed to the macro, not the types that the AST evaluates to at runtime:</source>
          <target state="translated">しかし、マクロのディスパッチは、実行時にASTが評価する型ではなく、マクロに渡されるASTの型に基づいていることを覚えておく必要があります。</target>
        </trans-unit>
        <trans-unit id="ec8145ef611e8eb6adb7aa2875037ca9cf5cb809" translate="yes" xml:space="preserve">
          <source>However, all the information we need for the loop is embedded in the type information of the arguments. Thus, we can utilize generated functions to move the iteration to compile-time; in compiler parlance, we use generated functions to manually unroll the loop. The body becomes almost identical, but instead of calculating the linear index, we build up an &lt;em&gt;expression&lt;/em&gt; that calculates the index:</source>
          <target state="translated">ただし、ループに必要なすべての情報は、引数の型情報に埋め込まれています。したがって、生成された関数を使用して、反復をコンパイル時に移動できます。コンパイラ用語では、生成された関数を使用して手動でループを展開します。本体はほぼ同一になりますが、線形インデックスを計算する代わりに、インデックスを計算する&lt;em&gt;式&lt;/em&gt;を作成します。</target>
        </trans-unit>
        <trans-unit id="42e7ab564618248599a98b48397f91d9696cc5fd" translate="yes" xml:space="preserve">
          <source>However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading. The next section discusses how to use indirect calls to efficiently accomplish a similar effect.</source>
          <target state="translated">しかし、これを行うと非常に遅くなり、メモリをリークすることになるので、通常はこれを避けて読み続けるべきです。次のセクションでは、同様の効果を効率的に得るために間接的な呼び出しを使用する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="1f4c1ec1ac04c3b7530d92971ca6fe0a67c59d9d" translate="yes" xml:space="preserve">
          <source>However, for mutable objects the warning is printed as expected:</source>
          <target state="translated">しかし、変異可能なオブジェクトの場合は、期待通りに警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="2b94a9c2374adeaf4e451f1d8f8dbbec3cf93bf0" translate="yes" xml:space="preserve">
          <source>However, future calls to &lt;code&gt;tryeval&lt;/code&gt; will continue to see the definition of &lt;code&gt;newfun&lt;/code&gt; as it was &lt;em&gt;at the previous statement at the REPL&lt;/em&gt;, and thus before that call to &lt;code&gt;tryeval&lt;/code&gt;.</source>
          <target state="translated">ただし、今後の &lt;code&gt;tryeval&lt;/code&gt; の呼び出し&lt;em&gt;では、REPLの前のステートメント&lt;/em&gt;、つまり &lt;code&gt;tryeval&lt;/code&gt; の呼び出しの前と同じように&lt;em&gt;、引き続き&lt;/em&gt; &lt;code&gt;newfun&lt;/code&gt; の定義が表示されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96a28d68e1fc2327784959f0995bfa65f1bc559d" translate="yes" xml:space="preserve">
          <source>However, if needed you can specialize on any or all of these arguments. The final argument &lt;code&gt;bc&lt;/code&gt; is a lazy representation of a (potentially fused) broadcast operation, a &lt;code&gt;Broadcasted&lt;/code&gt; object. For these purposes, the most important fields of the wrapper are &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt;, describing the function and argument list, respectively. Note that the argument list can &amp;mdash; and often does &amp;mdash; include other nested &lt;code&gt;Broadcasted&lt;/code&gt; wrappers.</source>
          <target state="translated">ただし、必要に応じて、これらの引数の一部またはすべてに特化できます。最後の引数 &lt;code&gt;bc&lt;/code&gt; は、（潜在的に融合された）ブロードキャスト操作である &lt;code&gt;Broadcasted&lt;/code&gt; オブジェクトの遅延表現です。これらの目的のために、ラッパーの最も重要なフィールドは &lt;code&gt;f&lt;/code&gt; と &lt;code&gt;args&lt;/code&gt; であり、それぞれ関数と引数リストを記述します。引数リストには、他のネストされた &lt;code&gt;Broadcasted&lt;/code&gt; ラッパーを含めることができます（多くの場合、含める）ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a1a03264a4e905ebd619a9b03ec0d4363bf201f9" translate="yes" xml:space="preserve">
          <source>However, if you try to redefine a built-in constant or function already in use, Julia will give you an error:</source>
          <target state="translated">しかし、すでに使用されている組み込みの定数や関数を再定義しようとすると、Juliaはエラーを出します。</target>
        </trans-unit>
        <trans-unit id="b612aa5b83e1e5e4f183ec87a4a8051d812c4982" translate="yes" xml:space="preserve">
          <source>However, it is not hard to construct cases where this will fail:</source>
          <target state="translated">しかし、これで失敗するケースを構築することは難しくありません。</target>
        </trans-unit>
        <trans-unit id="f588e867dce1639bbbc3e181485bd13a34f96de5" translate="yes" xml:space="preserve">
          <source>However, it is occasionally useful to reuse an existing local variable as the iteration variable. This can be done conveniently by adding the keyword &lt;code&gt;outer&lt;/code&gt;:</source>
          <target state="translated">ただし、既存のローカル変数を反復変数として再利用すると便利な場合があります。これは、キーワード &lt;code&gt;outer&lt;/code&gt; を追加することで簡単に実行できます。</target>
        </trans-unit>
        <trans-unit id="b3fc16da92345edab485c9b8587412c5e7cbbb69" translate="yes" xml:space="preserve">
          <source>However, it's still possible, for instance, to send a &lt;code&gt;MyType&lt;/code&gt; to a process which has loaded &lt;code&gt;DummyModule&lt;/code&gt; even if it's not in scope:</source>
          <target state="translated">ただし、たとえば、スコープ内にない場合でも、 &lt;code&gt;DummyModule&lt;/code&gt; をロードしたプロセスに &lt;code&gt;MyType&lt;/code&gt; を送信することは可能です。</target>
        </trans-unit>
        <trans-unit id="0206b7f024c599046b1522c22d104a0f2b4ea5b8" translate="yes" xml:space="preserve">
          <source>However, making use of such techniques can be surprisingly subtle. For example, it would be of no help if you called &lt;code&gt;array3&lt;/code&gt; from a function like this:</source>
          <target state="translated">ただし、そのような技術を利用することは驚くほど微妙な場合があります。たとえば、次のような関数から &lt;code&gt;array3&lt;/code&gt; を呼び出しても役に立たないでしょう。</target>
        </trans-unit>
        <trans-unit id="1ad09b70c7675ac7974cd81421e0b196fa34837e" translate="yes" xml:space="preserve">
          <source>However, other similar calls still don't work:</source>
          <target state="translated">しかし、他の似たような通話はまだうまくいきません。</target>
        </trans-unit>
        <trans-unit id="d6c01a830ee4c6c4b08c6d0fd04973c57ba502a5" translate="yes" xml:space="preserve">
          <source>However, since the automatic vectorization cannot be relied upon, future use will mostly be via libraries that use &lt;code&gt;llvmcall&lt;/code&gt;.</source>
          <target state="translated">ただし、自動ベクトル化は信頼できないため、今後の使用は主に &lt;code&gt;llvmcall&lt;/code&gt; を使用するライブラリを介して行われます。</target>
        </trans-unit>
        <trans-unit id="0a9c9e751e43cb6eaac4e5372d46543dc59ec370" translate="yes" xml:space="preserve">
          <source>However, since this is slightly cumbersome, there are several convenience methods provided. For example, we could have written the above as:</source>
          <target state="translated">ただし、やや面倒なので、いくつかの便利な方法が用意されています。例えば、上記のように書くことができました。</target>
        </trans-unit>
        <trans-unit id="4963644e11f9a07fc917ac8319ecfbd548bbe63b" translate="yes" xml:space="preserve">
          <source>However, some modules contain submodules, which means you sometimes need to access a non-top-level module. There are two ways to do this. The first is to use an absolute path, for example &lt;code&gt;using Base.Sort&lt;/code&gt;. The second is to use a relative path, which makes it easier to import submodules of the current module or any of its enclosing modules:</source>
          <target state="translated">ただし、一部のモジュールにはサブモジュールが含まれているため、最上位以外のモジュールにアクセスする必要がある場合があります。これを行うには2つの方法があります。1つ目は、 &lt;code&gt;using Base.Sort&lt;/code&gt; などの絶対パスを使用することです。2つ目は、相対パスを使用することです。これにより、現在のモジュールのサブモジュールまたはそれを含むモジュールのインポートが容易になります。</target>
        </trans-unit>
        <trans-unit id="788054e244adc6c2716171e1c63990c4810a9000" translate="yes" xml:space="preserve">
          <source>However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument to a function is a capital letter: &lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt;.</source>
          <target state="translated">ただし、関数の引数が大文字の場合など、最初の文字を大文字にしておくと意味がある場合があります。size &lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="734c2f5135f1e869aae040511570811afbc769c7" translate="yes" xml:space="preserve">
          <source>However, the outer &lt;code&gt;quote&lt;/code&gt; expression is able to interpolate values inside the &lt;code&gt;$&lt;/code&gt; in the inner quote. This is done with multiple &lt;code&gt;$&lt;/code&gt;s:</source>
          <target state="translated">ただし、外側の &lt;code&gt;quote&lt;/code&gt; 式は、内側の引用の &lt;code&gt;$&lt;/code&gt; 内の値を補間できます。これは複数の &lt;code&gt;$&lt;/code&gt; で行われます：</target>
        </trans-unit>
        <trans-unit id="a78965b80768b2188b4d959fddb093f72b6aa627" translate="yes" xml:space="preserve">
          <source>However, there are cases where you may need to declare different versions of the outer function for different element types or types of the &lt;code&gt;AbstractVector&lt;/code&gt; of the field &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;MySimpleContainer&lt;/code&gt;. You could do it like this:</source>
          <target state="translated">しかし、あなたは別の要素タイプまたはタイプのために外側の関数の異なるバージョンを宣言する必要があるかもしれない場合がある &lt;code&gt;AbstractVector&lt;/code&gt; フィールドの &lt;code&gt;a&lt;/code&gt; で &lt;code&gt;MySimpleContainer&lt;/code&gt; は。あなたはこのようにすることができます：</target>
        </trans-unit>
        <trans-unit id="3975391f531616484a0e31ee77d8e0e00f61fa9e" translate="yes" xml:space="preserve">
          <source>However, there are three key differences:</source>
          <target state="translated">しかし、主に3つの違いがあります。</target>
        </trans-unit>
        <trans-unit id="f5c45c8616fbe8c99fd70a67651ffd25fb8f16b8" translate="yes" xml:space="preserve">
          <source>However, this is &lt;em&gt;not&lt;/em&gt; recommended. Instead, use the more efficient &lt;code&gt;complex&lt;/code&gt; function to construct a complex value directly from its real and imaginary parts:</source>
          <target state="translated">ただし、これはお勧め&lt;em&gt;できません&lt;/em&gt;。代わりに、より効率的 &lt;code&gt;complex&lt;/code&gt; 関数を使用して、実数部と虚数部から直接複素数値を作成します。</target>
        </trans-unit>
        <trans-unit id="a2261e024bded1ce38fa0b00996da87c5f69ba9d" translate="yes" xml:space="preserve">
          <source>However, type promotion between the primitive types above and &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; is not automatic and must be explicitly stated.</source>
          <target state="translated">しかし、プリミティブ型以上との間のタイプのプロモーション&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;自動ではなく、明示的に指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="a17c41ad2e8a1887210e57ce0ca80b0a2e7e175c" translate="yes" xml:space="preserve">
          <source>However, we don't do this for a good reason: wrapping the &lt;code&gt;expr&lt;/code&gt; in a new scope block (the anonymous function) also slightly changes the meaning of the expression (the scope of any variables in it), while we want &lt;code&gt;@time&lt;/code&gt; to be usable with minimum impact on the wrapped code.</source>
          <target state="translated">しかし、我々は正当な理由のためにこれをしない：ラップ &lt;code&gt;expr&lt;/code&gt; 私たちが望む一方で、新たなスコープブロック（匿名関数）にも多少、表現（その中の任意の変数のスコープ）の意味を変更 &lt;code&gt;@time&lt;/code&gt; へラップされたコードへの影響を最小限に抑えて使用できます。</target>
        </trans-unit>
        <trans-unit id="0b0f70feaa3a28d45e6f3a13fc1f48acf2f37d7c" translate="yes" xml:space="preserve">
          <source>However, while the type layout must be known statically to compute the intended C ABI, the static parameters of the function are considered to be part of this static environment. The static parameters of the function may be used as type parameters in the call signature, as long as they don't affect the layout of the type. For example, &lt;code&gt;f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)&lt;/code&gt; is valid, since &lt;code&gt;Ptr&lt;/code&gt; is always a word-size primitive type. But, &lt;code&gt;g(x::T) where {T} = ccall(:notvalid, T, (T,), x)&lt;/code&gt; is not valid, since the type layout of &lt;code&gt;T&lt;/code&gt; is not known statically.</source>
          <target state="translated">ただし、目的のC ABIを計算するには、型のレイアウトを静的に把握する必要がありますが、関数の静的パラメーターはこの静的環境の一部と見なされます。関数の静的パラメーターは、型のレイアウトに影響を与えない限り、呼び出し署名の型パラメーターとして使用できます。たとえば、 &lt;code&gt;Ptr&lt;/code&gt; は常にワードサイズのプリミティブ型であるため &lt;code&gt;f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)&lt;/code&gt; であるf（x :: T）は有効です。しかし、 &lt;code&gt;g(x::T) where {T} = ccall(:notvalid, T, (T,), x)&lt;/code&gt; の種類レイアウトので、有効でない &lt;code&gt;T&lt;/code&gt; が静的に知られていません。</target>
        </trans-unit>
        <trans-unit id="50d668f1d842d230950802dd8f5eb4d3254c4568" translate="yes" xml:space="preserve">
          <source>Hundred Points Symbol</source>
          <target state="translated">百点シンボル</target>
        </trans-unit>
        <trans-unit id="fdd59db74c581af271b7941aa03e44ed5fe0b191" translate="yes" xml:space="preserve">
          <source>Hushed Face</source>
          <target state="translated">ハッシュドフェイス</target>
        </trans-unit>
        <trans-unit id="37906f8372f8c377be7b1e328309d3c4f609ea59" translate="yes" xml:space="preserve">
          <source>Hygiene</source>
          <target state="translated">Hygiene</target>
        </trans-unit>
        <trans-unit id="9dfda2b4e8d2ebd709351cb5956b33e0e4ffe363" translate="yes" xml:space="preserve">
          <source>Hyndman, R.J and Fan, Y. (1996) &quot;Sample Quantiles in Statistical Packages&quot;, &lt;em&gt;The American Statistician&lt;/em&gt;, Vol. 50, No. 4, pp. 361-365</source>
          <target state="translated">Hyndman、RJ and Fan、Y.（1996） &quot;Sample Quantiles in Statistical Packages&quot;、&lt;em&gt;The American Statistician&lt;/em&gt;、Vol。50、No. 4、pp。361-365</target>
        </trans-unit>
        <trans-unit id="cde96ad42b76d0bdd741afbb558f7a3b372bce7e" translate="yes" xml:space="preserve">
          <source>I (interval)</source>
          <target state="translated">私（間隔）</target>
        </trans-unit>
        <trans-unit id="1f1b2f73366cab7e556f4c5764548bfeee9e55d4" translate="yes" xml:space="preserve">
          <source>I passed an argument &lt;code&gt;x&lt;/code&gt; to a function, modified it inside that function, but on the outside, the variable &lt;code&gt;x&lt;/code&gt; is still unchanged. Why?</source>
          <target state="translated">引数 &lt;code&gt;x&lt;/code&gt; を関数に渡し、関数内で変更しましたが、外側では、変数 &lt;code&gt;x&lt;/code&gt; はまだ変更されていません。どうして？</target>
        </trans-unit>
        <trans-unit id="f6d15c9cfe8c2c69adbb304be5e27663dff93f96" translate="yes" xml:space="preserve">
          <source>I.e. the value returned by &lt;code&gt;codeunit(s, i)&lt;/code&gt; is of the type returned by &lt;code&gt;codeunit(s)&lt;/code&gt;.</source>
          <target state="translated">すなわちによって返される値 &lt;code&gt;codeunit(s, i)&lt;/code&gt; によって返されたタイプのものである &lt;code&gt;codeunit(s)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cf18e3da9119216f8e328e30538193a84b6a06e" translate="yes" xml:space="preserve">
          <source>I/O and Network</source>
          <target state="translated">I/Oとネットワーク</target>
        </trans-unit>
        <trans-unit id="f202b270f0bf2c3423308846f107faa93c51a606" translate="yes" xml:space="preserve">
          <source>ID of the device that contains the file</source>
          <target state="translated">ファイルを格納しているデバイスのID</target>
        </trans-unit>
        <trans-unit id="f9c4d94c8313e5f3e388b78d066d32450a104438" translate="yes" xml:space="preserve">
          <source>IO Output Contextual Properties</source>
          <target state="translated">IO出力コンテキストプロパティ</target>
        </trans-unit>
        <trans-unit id="197f5eacc88f8f1df449bfc2c0077d2d00ba82c7" translate="yes" xml:space="preserve">
          <source>IO redirection can be accomplished by passing keyword arguments &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, and &lt;code&gt;stderr&lt;/code&gt; to the &lt;code&gt;pipeline&lt;/code&gt; function:</source>
          <target state="translated">IOリダイレクトは、キーワード引数 &lt;code&gt;stdin&lt;/code&gt; 、 &lt;code&gt;stdout&lt;/code&gt; 、および &lt;code&gt;stderr&lt;/code&gt; を &lt;code&gt;pipeline&lt;/code&gt; 関数に渡すことで実現できます。</target>
        </trans-unit>
        <trans-unit id="01d2fc4baf23050afed6538bf5b3afda200aec20" translate="yes" xml:space="preserve">
          <source>IOBuffer</source>
          <target state="translated">IOBuffer</target>
        </trans-unit>
        <trans-unit id="1e240958856813e40093848d027d47dc30e4009a" translate="yes" xml:space="preserve">
          <source>IOContext</source>
          <target state="translated">IOContext</target>
        </trans-unit>
        <trans-unit id="29093ff8b21b1b330d3e6699a2ad82a180dd947e" translate="yes" xml:space="preserve">
          <source>IOContext()</source>
          <target state="translated">IOContext()</target>
        </trans-unit>
        <trans-unit id="3afa239559b1455a86cd4aafab53cb6dd69792c0" translate="yes" xml:space="preserve">
          <source>IOStream</source>
          <target state="translated">IOStream</target>
        </trans-unit>
        <trans-unit id="8d31d2211f88e51d4dac04058ee63fd1f5837600" translate="yes" xml:space="preserve">
          <source>Ice Cream</source>
          <target state="translated">アイスクリーム</target>
        </trans-unit>
        <trans-unit id="2b3a1ae210dbbbf1609a9fd75685f6380218b075" translate="yes" xml:space="preserve">
          <source>IdDict</source>
          <target state="translated">IdDict</target>
        </trans-unit>
        <trans-unit id="898cecd14809e1e6d2d6a1ad03f40fe8f8898ff9" translate="yes" xml:space="preserve">
          <source>Identical To</source>
          <target state="translated">同一の</target>
        </trans-unit>
        <trans-unit id="c539ce4823e892243cf1d72e5cda29852ab1bb48" translate="yes" xml:space="preserve">
          <source>Identical To And Slanted Parallel</source>
          <target state="translated">同一のものと斜めの平行</target>
        </trans-unit>
        <trans-unit id="44763ae8a5457dbe6219995560f8ceac0b654107" translate="yes" xml:space="preserve">
          <source>Identical With Dot Above</source>
          <target state="translated">上のドットと同一</target>
        </trans-unit>
        <trans-unit id="49f0f00de3919e6aa513f490a486fcbae4d4df50" translate="yes" xml:space="preserve">
          <source>If $n$ is negative, then it is defined in terms of the identity</source>
          <target state="translated">n$ が負の場合、それは同一人物である</target>
        </trans-unit>
        <trans-unit id="4ed2889e692f7a726f27cb34a6abbc329da52fe8" translate="yes" xml:space="preserve">
          <source>If $n$ is non-negative, then it is the number of ways to choose &lt;code&gt;k&lt;/code&gt; out of &lt;code&gt;n&lt;/code&gt; items:</source>
          <target state="translated">$ n $が負でない場合は、 &lt;code&gt;n&lt;/code&gt; 個のアイテムから &lt;code&gt;k&lt;/code&gt; 個を選択する方法の数です。</target>
        </trans-unit>
        <trans-unit id="21a045b4d60526617fd3c07b9d46739e69a41cdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no negative real eigenvalue, compute the principal matrix logarithm of &lt;code&gt;A&lt;/code&gt;, i.e. the unique matrix $X$ such that $e^X = A$ and $-\pi &amp;lt; Im(\lambda) &amp;lt; \pi$ for all the eigenvalues $\lambda$ of $X$. If &lt;code&gt;A&lt;/code&gt; has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.</source>
          <target state="translated">場合 &lt;code&gt;A&lt;/code&gt; は何の負の実固有値を持っていない、の主要な行列対数計算 &lt;code&gt;A&lt;/code&gt; を、すなわちユニークな行列$ X $ように$電子^ X = A $と$ - \パイ&amp;lt;イム（\ラムダ）すべてについて&amp;lt;\パイ$ $ X $の固有値$ \ lambda $。 &lt;code&gt;A&lt;/code&gt; に非正の固有値がある場合、可能な限り非主行列関数が返されます。</target>
        </trans-unit>
        <trans-unit id="7259d98627a04b894a1123257649b9b0e506f9f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no negative real eigenvalues, compute the principal matrix square root of &lt;code&gt;A&lt;/code&gt;, that is the unique matrix $X$ with eigenvalues having positive real part such that $X^2 = A$. Otherwise, a nonprincipal square root is returned.</source>
          <target state="translated">場合 &lt;code&gt;A&lt;/code&gt; は負の実固有値を有していない、の主行列平方根計算 &lt;code&gt;A&lt;/code&gt; の固有値は、$ X ^ 2 = A $その正の実数部分を有するユニークな行列$ X $です。それ以外の場合は、非主平方根が返されます。</target>
        </trans-unit>
        <trans-unit id="19b01775b8b82ce68d3f6a6f522f474a638dda03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the cosine. Otherwise, the cosine is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）を使用して余弦が計算されます。それ以外の場合、余弦は &lt;code&gt;exp&lt;/code&gt; を呼び出すことによって決定されます。</target>
        </trans-unit>
        <trans-unit id="acf6a44af56176e5053aa08ad7d4eea1a7727bea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_1&quot;&gt;[AH16_1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）を使用して逆余弦が計算されます。それ以外の場合、逆余弦は &lt;code&gt;log&lt;/code&gt; と &lt;code&gt;sqrt&lt;/code&gt; を使用して決定されます。この関数を計算するために使用される理論と対数公式については、&lt;a href=&quot;#footnote-AH16_1&quot;&gt;[AH16_1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="bbfce79aa807e6b2cb49ddfffb2847f191045922" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_2&quot;&gt;[AH16_2]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）を使用して逆正弦が計算されます。それ以外の場合、逆正弦は &lt;code&gt;log&lt;/code&gt; と &lt;code&gt;sqrt&lt;/code&gt; を使用して決定されます。この関数を計算するために使用される理論と対数公式については、&lt;a href=&quot;#footnote-AH16_2&quot;&gt;[AH16_2]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2646487106f321c98004368d4fc3670f47b0a86e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using &lt;code&gt;log&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_3&quot;&gt;[AH16_3]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）を使用して逆正接が計算されます。それ以外の場合、逆正接は &lt;code&gt;log&lt;/code&gt; を使用して決定されます。この関数の計算に使用される理論と対数公式については、&lt;a href=&quot;#footnote-AH16_3&quot;&gt;[AH16_3]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="317ce8e704df5d75a6762d7ee94cb8590a0eeb84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the sine. Otherwise, the sine is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）を使用して正弦を計算します。それ以外の場合、正弦は &lt;code&gt;exp&lt;/code&gt; を呼び出すことによって決定されます。</target>
        </trans-unit>
        <trans-unit id="8f03ca25824d588274952404db5eb47ba9feeba8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the square root. Otherwise, the square root is determined by means of the Bj&amp;ouml;rck-Hammarling method &lt;a href=&quot;#footnote-BH83&quot;&gt;[BH83]&lt;/a&gt;, which computes the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) and then the complex square root of the triangular factor.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）を使用して平方根が計算されます。それ以外の場合、平方根は、Bj&amp;ouml;rck-Hammarling法&lt;a href=&quot;#footnote-BH83&quot;&gt;[BH83]&lt;/a&gt;によって決定されます。これは、複素Schur形式（&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt;）を計算してから、三角因子の複素平方根を計算します。</target>
        </trans-unit>
        <trans-unit id="da6d9fe794edc15bdf1db668291afd8d8cb893d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the tangent. Otherwise, the tangent is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）を使用してタンジェントが計算されます。それ以外の場合、接線は &lt;code&gt;exp&lt;/code&gt; を呼び出すことによって決定されます。</target>
        </trans-unit>
        <trans-unit id="e82ebcef54c304de01d1461f11b56325e46b2234" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, if &lt;code&gt;A&lt;/code&gt; is triangular an improved version of the inverse scaling and squaring method is employed (see &lt;a href=&quot;#footnote-AH12&quot;&gt;[AH12]&lt;/a&gt; and &lt;a href=&quot;#footnote-AHR13&quot;&gt;[AHR13]&lt;/a&gt;). For general matrices, the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) is computed and the triangular algorithm is used on the triangular factor.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）が使用されます &lt;code&gt;A&lt;/code&gt; が三角形の場合、逆スケーリングおよび二乗法の改良版が採用されます（&lt;a href=&quot;#footnote-AH12&quot;&gt;[AH12]&lt;/a&gt;および&lt;a href=&quot;#footnote-AHR13&quot;&gt;[AHR13]を&lt;/a&gt;参照）。一般的な行列の場合、複素Schur形式（&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt;）が計算され、三角係数に三角アルゴリズムが使用されます。</target>
        </trans-unit>
        <trans-unit id="31effe06eb8010b919cfa614d0573384a4c26bdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DataType&lt;/code&gt;&lt;code&gt;T&lt;/code&gt; does not have a specific size, an error is thrown.</source>
          <target state="translated">&lt;code&gt;DataType&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; に特定のサイズがない場合、エラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="70ac2f54db074364d37a4067713ee52ebafa3e4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;I_1&lt;/code&gt; is changed to a two-dimensional matrix, then &lt;code&gt;X&lt;/code&gt; becomes an &lt;code&gt;n+1&lt;/code&gt;-dimensional array of shape &lt;code&gt;(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))&lt;/code&gt;. The matrix adds a dimension.</source>
          <target state="translated">場合 &lt;code&gt;I_1&lt;/code&gt; が 2次元マトリクス状に変更され、その後、 &lt;code&gt;X&lt;/code&gt; は、となる &lt;code&gt;n+1&lt;/code&gt; の形状の次元アレイ &lt;code&gt;(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))&lt;/code&gt; 。マトリックスは次元を追加します。</target>
        </trans-unit>
        <trans-unit id="20d018b41d67fa72dfd3dd7eab414a34042d26fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Any&lt;/code&gt;, then the memory is assumed to contain a reference to a Julia object (a &lt;code&gt;jl_value_t*&lt;/code&gt;), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia's garbage collector. If the &lt;code&gt;Ptr&lt;/code&gt; itself is actually a &lt;code&gt;jl_value_t*&lt;/code&gt;, it can be converted back to a Julia object reference by &lt;a href=&quot;../../base/c/index#Base.unsafe_pointer_to_objref&quot;&gt;&lt;code&gt;unsafe_pointer_to_objref(ptr)&lt;/code&gt;&lt;/a&gt;. (Julia values &lt;code&gt;v&lt;/code&gt; can be converted to &lt;code&gt;jl_value_t*&lt;/code&gt; pointers, as &lt;code&gt;Ptr{Cvoid}&lt;/code&gt;, by calling &lt;a href=&quot;../../base/c/index#Base.pointer_from_objref&quot;&gt;&lt;code&gt;pointer_from_objref(v)&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Any&lt;/code&gt; の場合、メモリにはJuliaオブジェクト（ &lt;code&gt;jl_value_t*&lt;/code&gt; ）への参照が含まれていると見なされ、結果はこのオブジェクトへの参照となり、オブジェクトはコピーされません。この場合、メモリが早期に解放されないように、オブジェクトがガベージコレクターに常に表示されるように注意する必要があります（ポインターはカウントされませんが、新しい参照はカウントされます）。オブジェクトがJuliaによって最初に割り当てられなかった場合、新しいオブジェクトはJuliaのガベージコレクターによってファイナライズされないことに注意してください。場合 &lt;code&gt;Ptr&lt;/code&gt; 自体は実際には &lt;code&gt;jl_value_t*&lt;/code&gt; 、それによってジュリアオブジェクト参照に変換バックすることができる&lt;a href=&quot;../../base/c/index#Base.unsafe_pointer_to_objref&quot;&gt; &lt;code&gt;unsafe_pointer_to_objref(ptr)&lt;/code&gt; &lt;/a&gt;。 （ジュリア値 &lt;code&gt;v&lt;/code&gt; &lt;a href=&quot;../../base/c/index#Base.pointer_from_objref&quot;&gt; &lt;code&gt;pointer_from_objref(v)&lt;/code&gt; を&lt;/a&gt;呼び出すことにより、 &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; として &lt;code&gt;jl_value_t*&lt;/code&gt; ポインターに変換できます。</target>
        </trans-unit>
        <trans-unit id="51788d4fcfdfd4d39c958952b0bc0324310a6a5f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../numbers/index#Core.AbstractFloat&quot;&gt;&lt;code&gt;AbstractFloat&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; type, then it will return the closest value to &lt;code&gt;x&lt;/code&gt; representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; がある&lt;a href=&quot;../numbers/index#Core.AbstractFloat&quot;&gt; &lt;code&gt;AbstractFloat&lt;/code&gt; &lt;/a&gt;又は&lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;タイプ、それは最も近い値を返す &lt;code&gt;x&lt;/code&gt; によって表現 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dedc994cd3fc0835ff4382a890fe92f16cb71d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a collection type and &lt;code&gt;x&lt;/code&gt; a collection, the result of &lt;code&gt;convert(T, x)&lt;/code&gt; may alias all or part of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、コレクション型であり、 &lt;code&gt;x&lt;/code&gt; は、コレクションの結果 &lt;code&gt;convert(T, x)&lt;/code&gt; 得る全てのエイリアスまたは一部 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca5b35227b72b028ed45253536f1af95a0b6efba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a floating-point type, the result is the nearest representable value, which could be positive or negative infinity.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、浮動小数点型であり、結果は正または負の無限大とすることができる最も近い表現可能な値です。</target>
        </trans-unit>
        <trans-unit id="4201a0a82cce066dea7c824bdf90b57c195e9972" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a numeric type, the result is an array of that type, with any non-numeric elements as &lt;code&gt;NaN&lt;/code&gt; for floating-point types, or zero. Other useful values of &lt;code&gt;T&lt;/code&gt; include &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;AbstractString&lt;/code&gt;, and &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; が数値型で、結果は、のような任意の非数値要素とその型の配列であり、 &lt;code&gt;NaN&lt;/code&gt; の浮動小数点型のために、またはゼロ。 &lt;code&gt;T&lt;/code&gt; の他の有用な値には、 &lt;code&gt;String&lt;/code&gt; 、 &lt;code&gt;AbstractString&lt;/code&gt; 、 &lt;code&gt;Any&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="69fee994b4c0ef137b6453b3ceac4a68a22fb0fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; type, an &lt;a href=&quot;#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; will be raised if &lt;code&gt;x&lt;/code&gt; is not representable by &lt;code&gt;T&lt;/code&gt;, for example if &lt;code&gt;x&lt;/code&gt; is not integer-valued, or is outside the range supported by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、ある&lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt;型、&lt;a href=&quot;#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; の&lt;/a&gt;場合に発生する &lt;code&gt;x&lt;/code&gt; で表現ない &lt;code&gt;T&lt;/code&gt; 場合、例えば、 &lt;code&gt;x&lt;/code&gt; 整数値でないか、によってサポートされる範囲外である &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c36ac776e4be839ff56e17825105904e00568128" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integer type, an &lt;code&gt;InexactError&lt;/code&gt; is raised if &lt;code&gt;x&lt;/code&gt; is not representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は整数型であり、 &lt;code&gt;InexactError&lt;/code&gt; があれば上昇し &lt;code&gt;x&lt;/code&gt; によって表現ない &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7762b87399cdbea094b67bb56bb79bce4032130" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X/Project.toml&lt;/code&gt; exists and but does &lt;em&gt;not&lt;/em&gt; have a top-level UUID entry, &lt;code&gt;uuid&lt;/code&gt; is a dummy UUID generated by hashing the canonical (real) path to &lt;code&gt;X/Project.toml&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;X/Project.toml&lt;/code&gt; が存在し、最上位のUUIDエントリが&lt;em&gt;ない&lt;/em&gt;場合、 &lt;code&gt;uuid&lt;/code&gt; は &lt;code&gt;X/Project.toml&lt;/code&gt; への正規の（実際の）パスをハッシュすることによって生成されるダミーのUUID です。</target>
        </trans-unit>
        <trans-unit id="57feda5962ebeb025a02c2fc5115db7f5ee74658" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X/Project.toml&lt;/code&gt; exists and has a &lt;code&gt;uuid&lt;/code&gt; entry, then &lt;code&gt;uuid&lt;/code&gt; is that value.</source>
          <target state="translated">場合 &lt;code&gt;X/Project.toml&lt;/code&gt; が存在し、持っている &lt;code&gt;uuid&lt;/code&gt; エントリを、次いで、 &lt;code&gt;uuid&lt;/code&gt; 、その値です。</target>
        </trans-unit>
        <trans-unit id="6feb00535e98202cbe0e255e2cd1a8e59544d667" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, at most one &lt;code&gt;read&lt;/code&gt; call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the &lt;code&gt;all&lt;/code&gt; option.</source>
          <target state="translated">場合は &lt;code&gt;all&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; （デフォルト）エラーまたはファイルの終わりが発生するまで、この関数は、要求されたすべてのバイトを読み取ろうと繰り返しブロックします。場合は &lt;code&gt;all&lt;/code&gt; ある &lt;code&gt;false&lt;/code&gt; 、最大で1つ &lt;code&gt;read&lt;/code&gt; 呼び出しが行われ、返されるデータの量は、デバイスに依存しています。すべてのストリームタイプが &lt;code&gt;all&lt;/code&gt; オプションをサポートしているわけではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="7b3a53d050caeb89134ca9bb80d1091ff36a0cf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is a power of 2 or 10, &lt;a href=&quot;#Base.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; should be used, as these will typically be faster and more accurate. For example,</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; が2または10の累乗である場合、&lt;a href=&quot;#Base.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#Base.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt;を使用する必要があります。これらは通常、より高速で正確です。例えば、</target>
        </trans-unit>
        <trans-unit id="89b9fac160344d84b2e97547e3cbb9b2dd975a11" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;batch_size&lt;/code&gt; is specified, the collection is processed in batch mode. &lt;code&gt;f&lt;/code&gt; must then be a function that must accept a &lt;code&gt;Vector&lt;/code&gt; of argument tuples and must return a vector of results. The input vector will have a length of &lt;code&gt;batch_size&lt;/code&gt; or less.</source>
          <target state="translated">場合 &lt;code&gt;batch_size&lt;/code&gt; 指定され、コレクションは、バッチモードで処理されます。 &lt;code&gt;f&lt;/code&gt; は、引数タプルの &lt;code&gt;Vector&lt;/code&gt; を受け入れ、結果のベクターを返す必要がある関数である必要があります。入力ベクトルの長さは、 &lt;code&gt;batch_size&lt;/code&gt; 以下になります。</target>
        </trans-unit>
        <trans-unit id="f2467dc77e236fb9b24d515beabeb30ab9b34314" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dims&lt;/code&gt; is a tuple, the order of the dimensions in &lt;code&gt;dims&lt;/code&gt; is relevant and specifies the linear order of the slices. E.g., if &lt;code&gt;A&lt;/code&gt; is three dimensional and &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;(1, 2)&lt;/code&gt;, the orderings of the first two dimensions are re-arranged such such that the slices (of the remaining third dimension) are sorted. If &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;(2, 1)&lt;/code&gt; instead, the same slices will be taken, but the result order will be row-major instead.</source>
          <target state="translated">場合は &lt;code&gt;dims&lt;/code&gt; タプルで、内寸法の順序 &lt;code&gt;dims&lt;/code&gt; 関連性があるとスライスの線形順序を指定します。たとえば、 &lt;code&gt;A&lt;/code&gt; が3次元で &lt;code&gt;dims&lt;/code&gt; が &lt;code&gt;(1, 2)&lt;/code&gt; 場合、最初の2次元の順序は、（残りの3次元の）スライスが並べ替えられるように再配置されます。代わりに &lt;code&gt;dims&lt;/code&gt; が &lt;code&gt;(2, 1)&lt;/code&gt; 2、1）の場合、同じスライスが取得されますが、結果の順序は行優先になります。</target>
        </trans-unit>
        <trans-unit id="74fad15bfd2101b3b16f9ea74a15c93af724d1dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dlm&lt;/code&gt; is omitted, it defaults to &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">場合 &lt;code&gt;dlm&lt;/code&gt; に省略され、それがデフォルト&lt;a href=&quot;#Base.Unicode.isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d7429e0d71b847a07568d302028712dbaf31f03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;factorize&lt;/code&gt; is called on a Hermitian positive-definite matrix, for instance, then &lt;code&gt;factorize&lt;/code&gt; will return a Cholesky factorization.</source>
          <target state="translated">たとえば、エルミート正定行列で &lt;code&gt;factorize&lt;/code&gt; が呼び出された場合、 &lt;code&gt;factorize&lt;/code&gt; はコレスキー分解を返します。</target>
        </trans-unit>
        <trans-unit id="b7c73e768a4a1fc2665ff51aa066980c89d3ec1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;follow_symlinks=false&lt;/code&gt;, and &lt;code&gt;src&lt;/code&gt; is a symbolic link, &lt;code&gt;dst&lt;/code&gt; will be created as a symbolic link. If &lt;code&gt;follow_symlinks=true&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; is a symbolic link, &lt;code&gt;dst&lt;/code&gt; will be a copy of the file or directory &lt;code&gt;src&lt;/code&gt; refers to. Return &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;follow_symlinks=false&lt;/code&gt; 、および &lt;code&gt;src&lt;/code&gt; がシンボリックリンクで、 &lt;code&gt;dst&lt;/code&gt; シンボリックリンクとして作成されます。場合 &lt;code&gt;follow_symlinks=true&lt;/code&gt; と &lt;code&gt;src&lt;/code&gt; がシンボリックリンクで、 &lt;code&gt;dst&lt;/code&gt; ファイルやディレクトリのコピーとなります &lt;code&gt;src&lt;/code&gt; はを指します。 &lt;code&gt;dst&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="0fefe7c70552bb288eba8725570e0711eb9913bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;full = false&lt;/code&gt; (default), a &quot;thin&quot; SVD is returned. For a $M \times N$ matrix &lt;code&gt;A&lt;/code&gt;, in the full factorization &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;M \times M&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;N \times N&lt;/code&gt;, while in the thin factorization &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;M \times K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;N \times K&lt;/code&gt;, where &lt;code&gt;K = \min(M,N)&lt;/code&gt; is the number of singular values.</source>
          <target state="translated">場合は &lt;code&gt;full = false&lt;/code&gt; （デフォルト）、「薄い」SVDが返されます。$ M \ times N $行列 &lt;code&gt;A&lt;/code&gt; の場合、完全分解では &lt;code&gt;U&lt;/code&gt; は &lt;code&gt;M \times M&lt;/code&gt; あり、 &lt;code&gt;V&lt;/code&gt; は &lt;code&gt;N \times N&lt;/code&gt; ですが、薄い分解では &lt;code&gt;U&lt;/code&gt; は &lt;code&gt;M \times K&lt;/code&gt; あり、 &lt;code&gt;V&lt;/code&gt; は &lt;code&gt;N \times K&lt;/code&gt; 。ここで、 &lt;code&gt;K = \min(M,N)&lt;/code&gt; は特異値の数です。</target>
        </trans-unit>
        <trans-unit id="e7087620ad88bc806c680dac427ffd57a67879dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fussy_sqrt&lt;/code&gt; is called with a negative value from another function, instead of trying to continue execution of the calling function, it returns immediately, displaying the error message in the interactive session:</source>
          <target state="translated">&lt;code&gt;fussy_sqrt&lt;/code&gt; が別の関数から負の値で呼び出された場合、呼び出し側の関数の実行を続行しようとせずに、すぐに戻り、対話型セッションでエラーメッセージを表示します。</target>
        </trans-unit>
        <trans-unit id="c19e0b85728fe9481b7abf51cbb032dc0e45287a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;generated&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the returned &lt;code&gt;CodeInfo&lt;/code&gt; instances will correspond to fallback implementations. An error is thrown if no fallback implementation exists. If &lt;code&gt;generated&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, these &lt;code&gt;CodeInfo&lt;/code&gt; instances will correspond to the method bodies yielded by expanding the generators.</source>
          <target state="translated">場合は &lt;code&gt;generated&lt;/code&gt; ある &lt;code&gt;false&lt;/code&gt; 、返さ &lt;code&gt;CodeInfo&lt;/code&gt; のインスタンスは、実装をフォールバックに対応します。フォールバック実装が存在しない場合、エラーがスローされます。場合に &lt;code&gt;generated&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、これら &lt;code&gt;CodeInfo&lt;/code&gt; のインスタンスは、発電機を拡張することによって得られたメソッド本体に対応することになります。</target>
        </trans-unit>
        <trans-unit id="3b5b7e505ab23a5d0aa601628f61af1433ebc0f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;header&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the first row of data will be read as header and the tuple &lt;code&gt;(data_cells, header_cells)&lt;/code&gt; is returned instead of only &lt;code&gt;data_cells&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、データの最初の行がヘッダーとして読み取られ &lt;code&gt;(data_cells, header_cells)&lt;/code&gt; &lt;code&gt;data_cells&lt;/code&gt; だけではなく、タプル（data_cells、header_cells）が返されます。</target>
        </trans-unit>
        <trans-unit id="c950181a2a1658a2e38c89bd49475efe3e66e317" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding code unit &lt;code&gt;i&lt;/code&gt; is part of. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return &lt;code&gt;i&lt;/code&gt;; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, rewind until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to 0 or &lt;code&gt;ncodeunits(s)+1&lt;/code&gt; return &lt;code&gt;i&lt;/code&gt;. In all other cases throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; が &lt;code&gt;s&lt;/code&gt; の境界内にある場合、エンコーディングコードユニット &lt;code&gt;i&lt;/code&gt; が含まれる文字の開始のインデックスを返します。言い換えれば、 &lt;code&gt;i&lt;/code&gt; キャラクタのスタートで、返す &lt;code&gt;i&lt;/code&gt; 。 &lt;code&gt;i&lt;/code&gt; が文字の先頭でない場合は、文字の先頭まで巻き戻し、そのインデックスを返します。場合 &lt;code&gt;i&lt;/code&gt; は 0又はに等しい &lt;code&gt;ncodeunits(s)+1&lt;/code&gt; リターン &lt;code&gt;i&lt;/code&gt; 。その他の場合はすべて &lt;code&gt;BoundsError&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="ed8634de2b332fe1583659d48b66208896196beb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding starts after index &lt;code&gt;i&lt;/code&gt;. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return the start of the next character; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, move forward until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;0&lt;/code&gt; return &lt;code&gt;1&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is in bounds but greater or equal to &lt;code&gt;lastindex(str)&lt;/code&gt; return &lt;code&gt;ncodeunits(str)+1&lt;/code&gt;. Otherwise throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; が &lt;code&gt;s&lt;/code&gt; の境界内にある場合、インデックス &lt;code&gt;i&lt;/code&gt; の後にエンコーディングが始まる文字の開始のインデックスを返します。つまり、 &lt;code&gt;i&lt;/code&gt; が文字の先頭の場合、次の文字の先頭を返します。 &lt;code&gt;i&lt;/code&gt; が文字の先頭でない場合は、文字の先頭まで進み、そのインデックスを返します。 &lt;code&gt;i&lt;/code&gt; が &lt;code&gt;0&lt;/code&gt; の場合は &lt;code&gt;1&lt;/code&gt; を返します。もし &lt;code&gt;i&lt;/code&gt; が境界内にあるが、大きいかまたは等しい &lt;code&gt;lastindex(str)&lt;/code&gt; リターン &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; 。それ以外の場合は &lt;code&gt;BoundsError&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="5bcc465fac95b41229c6fb79ecf0d3dab69e75e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding starts before index &lt;code&gt;i&lt;/code&gt;. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return the start of the previous character; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, rewind until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;1&lt;/code&gt; return &lt;code&gt;0&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; return &lt;code&gt;lastindex(str)&lt;/code&gt;. Otherwise throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; が &lt;code&gt;s&lt;/code&gt; の境界内にある場合、インデックス &lt;code&gt;i&lt;/code&gt; の前にエンコードが始まる文字の開始のインデックスを返します。つまり、 &lt;code&gt;i&lt;/code&gt; が文字の先頭の場合、前の文字の先頭を返します。 &lt;code&gt;i&lt;/code&gt; が文字の先頭でない場合は、文字の先頭まで巻き戻し、そのインデックスを返します。 &lt;code&gt;i&lt;/code&gt; が &lt;code&gt;1&lt;/code&gt; に等しい場合は &lt;code&gt;0&lt;/code&gt; を返します。場合は &lt;code&gt;i&lt;/code&gt; に等しい &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; リターン &lt;code&gt;lastindex(str)&lt;/code&gt; 。それ以外の場合は &lt;code&gt;BoundsError&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="3cfff02ba2ab7ab8f47553333086d7d3b017d4eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;io&lt;/code&gt; is not specified, &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; are used to connect.</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; が指定されていない場合、 &lt;code&gt;host&lt;/code&gt; と &lt;code&gt;port&lt;/code&gt; が接続に使用されます。</target>
        </trans-unit>
        <trans-unit id="675d2f45d06133423691ac8939a36ff3793bfbd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;io&lt;/code&gt; is specified, it is used to read host/port information. A Julia worker prints out its bind address and port at startup. This allows Julia workers to listen on any free port available instead of requiring worker ports to be configured manually.</source>
          <target state="translated">場合は &lt;code&gt;io&lt;/code&gt; 指定され、ホスト/ポート情報を読み取るために使用されます。Juliaワーカーは、起動時にバインドアドレスとポートを出力します。これにより、Juliaワーカーは、ワーカーポートを手動で構成する必要がなく、使用可能な空きポートをリッスンできます。</target>
        </trans-unit>
        <trans-unit id="23c03ff245d9cf669803a913ec063d9d852e916b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;irange&lt;/code&gt; is not &lt;code&gt;1:n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the dimension of &lt;code&gt;A&lt;/code&gt;, then the returned factorization will be a &lt;em&gt;truncated&lt;/em&gt; factorization.</source>
          <target state="translated">&lt;code&gt;irange&lt;/code&gt; が &lt;code&gt;1:n&lt;/code&gt; ではない場合（ &lt;code&gt;n&lt;/code&gt; は &lt;code&gt;A&lt;/code&gt; の次元）、返される因数分解は&lt;em&gt;切り捨てられた&lt;/em&gt;因数分解になります。</target>
        </trans-unit>
        <trans-unit id="33bb6515a9488e11cd97387cfe2fdf0354f00b17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isless(x, y)&lt;/code&gt; is defined, then so is &lt;code&gt;isless(y, x)&lt;/code&gt; and &lt;code&gt;isequal(x, y)&lt;/code&gt;, and exactly one of those three yields &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;isless(x, y)&lt;/code&gt; 定義され、そのようになる &lt;code&gt;isless(y, x)&lt;/code&gt; と &lt;code&gt;isequal(x, y)&lt;/code&gt; 、及びこれら3つの収率の正確に一つの &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27bcd4132639e391333ba702df2bbfcfeb96c942" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if &lt;code&gt;itr&lt;/code&gt; contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the median of non-missing values.</source>
          <target state="translated">場合 &lt;code&gt;itr&lt;/code&gt; 含まれている &lt;code&gt;NaN&lt;/code&gt; または&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;値を、結果もある &lt;code&gt;NaN&lt;/code&gt; または &lt;code&gt;missing&lt;/code&gt; （ &lt;code&gt;missing&lt;/code&gt; 場合は優先されます &lt;code&gt;itr&lt;/code&gt; 両方が含まれています）。&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;関数を使用して、 &lt;code&gt;missing&lt;/code&gt; エントリを省略し、欠落していない値の中央値を計算します。</target>
        </trans-unit>
        <trans-unit id="c3e083f5fc9364992337e03964ee084acea5fae6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the mean of non-missing values.</source>
          <target state="translated">場合 &lt;code&gt;itr&lt;/code&gt; 含ま &lt;code&gt;NaN&lt;/code&gt; または&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;た値を、結果でもある &lt;code&gt;NaN&lt;/code&gt; または &lt;code&gt;missing&lt;/code&gt; （ &lt;code&gt;missing&lt;/code&gt; 配列の両方が含まれている場合に優先）。&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;関数を使用して、 &lt;code&gt;missing&lt;/code&gt; エントリを省略し、欠落していない値の平均を計算します。</target>
        </trans-unit>
        <trans-unit id="6474b35658d7c26eeead842892ada1aea0d886f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions, and &lt;code&gt;m&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;itr&lt;/code&gt; ある &lt;code&gt;AbstractArray&lt;/code&gt; 、 &lt;code&gt;dims&lt;/code&gt; 寸法上の標準偏差を計算するために設けることができ、 &lt;code&gt;m&lt;/code&gt; は、各ディメンションの手段を含んでいてもよい &lt;code&gt;itr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51822a7fae2f9177cdbe8acba291b2ecbdaf5a84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions, and &lt;code&gt;means&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;itr&lt;/code&gt; ある &lt;code&gt;AbstractArray&lt;/code&gt; 、 &lt;code&gt;dims&lt;/code&gt; 寸法上の標準偏差を計算するために提供することができ、及び &lt;code&gt;means&lt;/code&gt; 、各ディメンションの手段を含んでいてもよい &lt;code&gt;itr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="faf5ec759432f757b892cc486fe0509d46288036" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions, and &lt;code&gt;m&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;itr&lt;/code&gt; ある &lt;code&gt;AbstractArray&lt;/code&gt; 、 &lt;code&gt;dims&lt;/code&gt; 寸法上の分散を計算するために設けることができ、 &lt;code&gt;m&lt;/code&gt; は、各ディメンションの手段を含んでいてもよい &lt;code&gt;itr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37d953297aa88c0f3bc07a3115b3b34627aebd03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions, and &lt;code&gt;mean&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;itr&lt;/code&gt; ある &lt;code&gt;AbstractArray&lt;/code&gt; 、 &lt;code&gt;dims&lt;/code&gt; 寸法上の分散を計算するために設けることができ、 &lt;code&gt;mean&lt;/code&gt; 、各次元のための手段を含んでいてもよい &lt;code&gt;itr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c5a74c045541a90c529fb0859ca2583588298de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;step&lt;/code&gt; is not, the step size will be computed automatically such that there are &lt;code&gt;length&lt;/code&gt; linearly spaced elements in the range (a &lt;a href=&quot;../collections/index#Base.LinRange&quot;&gt;&lt;code&gt;LinRange&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">場合 &lt;code&gt;length&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; 設けられている &lt;code&gt;step&lt;/code&gt; ない、ステップサイズがあることを自動的にように計算される &lt;code&gt;length&lt;/code&gt; 直線範囲（に離間要素&lt;a href=&quot;../collections/index#Base.LinRange&quot;&gt; &lt;code&gt;LinRange&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0677161ec30784ce49b4b8aeda531d688c559665" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pids&lt;/code&gt; is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, &lt;code&gt;localindices&lt;/code&gt; and &lt;code&gt;indexpids&lt;/code&gt; will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.</source>
          <target state="translated">場合 &lt;code&gt;pids&lt;/code&gt; 指定されていないままにする、共有配列は、マスターを含む、現在のホスト上のすべてのプロセス間でマッピングされます。ただし、 &lt;code&gt;localindices&lt;/code&gt; と &lt;code&gt;indexpids&lt;/code&gt; はワーカープロセスのみを参照します。これにより、作業分散コードは、マスタープロセスがドライバーとして機能する実際の計算にワーカーを使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="39265b02d633cf948cee760fccd02e8e4c595e22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;quotes&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, columns enclosed within double-quote (&quot;) characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote. Specifying &lt;code&gt;dims&lt;/code&gt; as a tuple of the expected rows and columns (including header, if any) may speed up reading of large files. If &lt;code&gt;comments&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, lines beginning with &lt;code&gt;comment_char&lt;/code&gt; and text following &lt;code&gt;comment_char&lt;/code&gt; in any line are ignored.</source>
          <target state="translated">場合は &lt;code&gt;quotes&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、列は二重引用符で囲まれた（ &quot;）文字は、新しい行と列の区切り文字を含むように許可されている。二重引用符を引用し、フィールド内の別の二重引用符でエスケープする必要があります。指定 &lt;code&gt;dims&lt;/code&gt; 予想されるのタプルとして（ヘッダを含め、もしあれば）の行と列は、大きなファイルの読み込みスピードアップすることがあります。場合 &lt;code&gt;comments&lt;/code&gt; あり &lt;code&gt;true&lt;/code&gt; で始まる行、 &lt;code&gt;comment_char&lt;/code&gt; およびテキスト次 &lt;code&gt;comment_char&lt;/code&gt; 任意の行では無視されます。</target>
        </trans-unit>
        <trans-unit id="072d5e68fa14ef444211e0638bdf60961c940d9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reuseaddr=true&lt;/code&gt;, multiple threads or processes can bind to the same address without error if they all set &lt;code&gt;reuseaddr=true&lt;/code&gt;, but only the last to bind will receive any traffic.</source>
          <target state="translated">場合 &lt;code&gt;reuseaddr=true&lt;/code&gt; 彼らはすべて設定されている場合は、複数のスレッドやプロセスがエラーなしで同じアドレスにバインドすることができ &lt;code&gt;reuseaddr=true&lt;/code&gt; が、バインドにのみ、最後には、すべてのトラフィックを受信します。</target>
        </trans-unit>
        <trans-unit id="5dd9d0433c4fe181d962946c85904ec68a57d1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rook&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, rook pivoting is used. If &lt;code&gt;rook&lt;/code&gt; is false, rook pivoting is not used.</source>
          <target state="translated">場合は &lt;code&gt;rook&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、ルークのピボットが使用されています。 &lt;code&gt;rook&lt;/code&gt; がfalseの場合、rookピボットは使用されません。</target>
        </trans-unit>
        <trans-unit id="3686d47af71436aa8068aa094e6acfdb577abbc8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipblanks&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, blank lines in the input will be ignored.</source>
          <target state="translated">&lt;code&gt;skipblanks&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、入力の空白行は無視されます。</target>
        </trans-unit>
        <trans-unit id="a5a873983f34f90f6f3366d1e91c3b5438a1e6c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;step&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;length&lt;/code&gt; is not, the overall range length will be computed automatically such that the elements are &lt;code&gt;step&lt;/code&gt; spaced (a &lt;a href=&quot;../collections/index#Base.StepRange&quot;&gt;&lt;code&gt;StepRange&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">場合 &lt;code&gt;step&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; 設けられている &lt;code&gt;length&lt;/code&gt; ではなく、全体的な範囲の長さは要素があることを自動的にように計算する &lt;code&gt;step&lt;/code&gt; 離間（&lt;a href=&quot;../collections/index#Base.StepRange&quot;&gt; &lt;code&gt;StepRange&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c1a52fdda97e9a9edb8d40a32fdbba7468a954c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is an abstract type, then the method that would be called by &lt;code&gt;invoke&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;types&lt;/code&gt; が抽象タイプの場合、 &lt;code&gt;invoke&lt;/code&gt; によって呼び出されるメソッドが返されます。</target>
        </trans-unit>
        <trans-unit id="f58b04b4e4485017440ce0c5de7416ee07070fe9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, returns an array of methods whose types match.</source>
          <target state="translated">&lt;code&gt;types&lt;/code&gt; が指定されている場合、タイプが一致するメソッドの配列を返します。</target>
        </trans-unit>
        <trans-unit id="b3892fb415986ed95819205d489e6d5bbab6470a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use_mmap&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the file specified by &lt;code&gt;source&lt;/code&gt; is memory mapped for potential speedups. Default is &lt;code&gt;true&lt;/code&gt; except on Windows. On Windows, you may want to specify &lt;code&gt;true&lt;/code&gt; if the file is large, and is only read once and not written to.</source>
          <target state="translated">場合 &lt;code&gt;use_mmap&lt;/code&gt; がある &lt;code&gt;true&lt;/code&gt; 、で指定されたファイル &lt;code&gt;source&lt;/code&gt; 潜在的なスピードアップのためにマップされたメモリです。Windowsを除き、デフォルトは &lt;code&gt;true&lt;/code&gt; です。Windowsでは、ファイルが大きく、一度だけ読み取られ、書き込まれない場合は、 &lt;code&gt;true&lt;/code&gt; を指定できます。</target>
        </trans-unit>
        <trans-unit id="5645668108ab9880ec8d6ff07db8800e64be268c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;wait&lt;/code&gt; is false, the process runs asynchronously. You can later wait for it and check its exit status by calling &lt;code&gt;success&lt;/code&gt; on the returned process object.</source>
          <target state="translated">場合は &lt;code&gt;wait&lt;/code&gt; 偽で、プロセスが非同期的に実行されます。後でそれを待って、返されたプロセスオブジェクトで &lt;code&gt;success&lt;/code&gt; を呼び出すことにより、その終了ステータスを確認できます。</target>
        </trans-unit>
        <trans-unit id="4328d82bb88eefa0e600962ab951d3053ce804f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a number, this is essentially the same as &lt;code&gt;one(x)/x&lt;/code&gt;, but for some types &lt;code&gt;inv(x)&lt;/code&gt; may be slightly more efficient.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; が数値の場合、これは基本的に &lt;code&gt;one(x)/x&lt;/code&gt; と同じですが、一部のタイプでは &lt;code&gt;inv(x)&lt;/code&gt; の方がわずかに効率的です。</target>
        </trans-unit>
        <trans-unit id="5d6e97018433ee560ec26ad905f78e6763128a42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a type, return a &quot;larger&quot; type, defined so that arithmetic operations &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; are guaranteed not to overflow nor lose precision for any combination of values that type &lt;code&gt;x&lt;/code&gt; can hold.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; がタイプの場合、算術演算 &lt;code&gt;+&lt;/code&gt; および &lt;code&gt;-&lt;/code&gt; がオーバーフローしたり、タイプ &lt;code&gt;x&lt;/code&gt; が保持できる値の組み合わせの精度が失われないことが保証されるように定義された「より大きい」タイプを返します。</target>
        </trans-unit>
        <trans-unit id="88ba7ee31764ff507d81e94f6a3b385c0be71e42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a value, it is converted to &lt;code&gt;widen(typeof(x))&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; 値であり、ために変換される &lt;code&gt;widen(typeof(x))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a828e6b72bb380836af54de218be15aa9ebea9db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an object reference, all elements will refer to the same object. &lt;code&gt;fill(Foo(), dims)&lt;/code&gt; will return an array filled with the result of evaluating &lt;code&gt;Foo()&lt;/code&gt; once.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; がオブジェクト参照の場合、すべての要素は同じオブジェクトを参照します。 &lt;code&gt;fill(Foo(), dims)&lt;/code&gt; は、 &lt;code&gt;Foo()&lt;/code&gt; を 1回評価した結果で満たされた配列を返します。</target>
        </trans-unit>
        <trans-unit id="db317e66581e31b148fb1c68097906f9ec9dcecb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not an &lt;code&gt;AbstractArray&lt;/code&gt; but it supports &lt;code&gt;axes&lt;/code&gt;, indexing, and its type supports &lt;code&gt;ndims&lt;/code&gt;, then &lt;code&gt;broadcastable(::typeof(x))&lt;/code&gt; may be implemented to just return itself. Further, if &lt;code&gt;x&lt;/code&gt; defines its own &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt;&lt;code&gt;BroadcastStyle&lt;/code&gt;&lt;/a&gt;, then it must define its &lt;code&gt;broadcastable&lt;/code&gt; method to return itself for the custom style to have any effect.</source>
          <target state="translated">場合は &lt;code&gt;x&lt;/code&gt; ない &lt;code&gt;AbstractArray&lt;/code&gt; が、それはサポート &lt;code&gt;axes&lt;/code&gt; 、インデックス、およびそのタイプのサポートの &lt;code&gt;ndims&lt;/code&gt; を、そして &lt;code&gt;broadcastable(::typeof(x))&lt;/code&gt; 、単に自分自身を返すように実装することができます。さらに、 &lt;code&gt;x&lt;/code&gt; が独自の&lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt; &lt;code&gt;BroadcastStyle&lt;/code&gt; を&lt;/a&gt;定義している場合、カスタムスタイルが効果を発揮するためには、xが &lt;code&gt;broadcastable&lt;/code&gt; メソッドを定義して自身を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="ead093ec45b992f54a438f256340d7b0a0ef7df6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; supports iteration, the returned value should have the same &lt;code&gt;axes&lt;/code&gt; and indexing behaviors as &lt;code&gt;collect(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; が反復をサポートしている場合、戻り値は &lt;code&gt;collect(x)&lt;/code&gt; と同じ &lt;code&gt;axes&lt;/code&gt; とインデックスの動作を持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="9eb6d4efdb2a84932dc930c8197ad4f7fad62394" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt; literal (e.g. &lt;code&gt;2&lt;/code&gt; in &lt;code&gt;x^2&lt;/code&gt; or &lt;code&gt;-3&lt;/code&gt; in &lt;code&gt;x^-3&lt;/code&gt;), the Julia code &lt;code&gt;x^y&lt;/code&gt; is transformed by the compiler to &lt;code&gt;Base.literal_pow(^, x, Val(y))&lt;/code&gt;, to enable compile-time specialization on the value of the exponent. (As a default fallback we have &lt;code&gt;Base.literal_pow(^, x, Val(y)) = ^(x,y)&lt;/code&gt;, where usually &lt;code&gt;^ == Base.^&lt;/code&gt; unless &lt;code&gt;^&lt;/code&gt; has been defined in the calling namespace.)</source>
          <target state="translated">場合 &lt;code&gt;y&lt;/code&gt; がある &lt;code&gt;Int&lt;/code&gt; リテラル（例えば &lt;code&gt;2&lt;/code&gt; で &lt;code&gt;x^2&lt;/code&gt; 又は &lt;code&gt;-3&lt;/code&gt; で &lt;code&gt;x^-3&lt;/code&gt; ）、ジュリア・コード &lt;code&gt;x^y&lt;/code&gt; にコンパイラによって変換さ &lt;code&gt;Base.literal_pow(^, x, Val(y))&lt;/code&gt; に指数の値でコンパイル時の特殊化を有効にします。 （デフォルトはフォールバックとして、我々が持っている &lt;code&gt;Base.literal_pow(^, x, Val(y)) = ^(x,y)&lt;/code&gt; 、どこ通常 &lt;code&gt;^ == Base.^&lt;/code&gt; ない限り、 &lt;code&gt;^&lt;/code&gt; が呼び出す名前空間で定義されています。）</target>
        </trans-unit>
        <trans-unit id="4030642b9b0fac77c474cfa27dc2012de7dca7c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;yes&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values (&quot;denormals&quot;). Otherwise, floating-point operations are permitted (but not required) to convert subnormal inputs or outputs to zero. Returns &lt;code&gt;true&lt;/code&gt; unless &lt;code&gt;yes==true&lt;/code&gt; but the hardware does not support zeroing of subnormal numbers.</source>
          <target state="translated">&lt;code&gt;yes&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; の場合、後続の浮動小数点演算は、非正規値（「非正規」）に対するIEEE演算の規則に従います。それ以外の場合、非正規の入力または出力をゼロに変換するために浮動小数点演算が許可されます（必須ではありません）。 &lt;code&gt;yes==true&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; でない限りtrueを返しますが、ハードウェアは非正規数のゼロ化をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="4fe82c65bb97ee33e80659528026f81237a00185" translate="yes" xml:space="preserve">
          <source>If Julia were a language that made more liberal use of ASCII characters, the slurping operator might have been written as &lt;code&gt;&amp;lt;-...&lt;/code&gt; instead of &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">JuliaがASCII文字をより自由に使用する言語である場合、丸呑み演算子は &lt;code&gt;&amp;lt;-...&lt;/code&gt; ではなく&amp;lt;-...と記述されている可能性があり &lt;code&gt;...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c31aabb66505776aad35d90bd36db4dbf2d1b9d" translate="yes" xml:space="preserve">
          <source>If Julia were a language that made more liberal use of ASCII characters, the splatting operator might have been written as &lt;code&gt;...-&amp;gt;&lt;/code&gt; instead of &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">JuliaがASCII文字をより自由に使用する言語であった場合、スプラッティング演算子は &lt;code&gt;...&lt;/code&gt; ではなく &lt;code&gt;...-&amp;gt;&lt;/code&gt; と記述されている可能性があります。</target>
        </trans-unit>
        <trans-unit id="60a92e91dcf7c91c0849e69c5ad346e21b345fcf" translate="yes" xml:space="preserve">
          <source>If [&lt;code&gt;vl&lt;/code&gt;, &lt;code&gt;vu&lt;/code&gt;] does not contain all eigenvalues of &lt;code&gt;A&lt;/code&gt;, then the returned factorization will be a &lt;em&gt;truncated&lt;/em&gt; factorization.</source>
          <target state="translated">[ &lt;code&gt;vl&lt;/code&gt; 、 &lt;code&gt;vu&lt;/code&gt; ]に &lt;code&gt;A&lt;/code&gt; のすべての固有値が含まれていない場合、返される因数分解は&lt;em&gt;切り捨て&lt;/em&gt;因数分解になります。</target>
        </trans-unit>
        <trans-unit id="730dc1af168d94eefd1482151f83529bc44df580" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is empty, readers (on a &lt;code&gt;take!&lt;/code&gt; call) will block until data is available.</source>
          <target state="translated">&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;が空の場合、（ &lt;code&gt;take!&lt;/code&gt; コールで）リーダーはデータが利用可能になるまでブロックします。</target>
        </trans-unit>
        <trans-unit id="84662f0c325b992dd59906d92d27342a4c4aeef8" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is full, writers (on a &lt;code&gt;put!&lt;/code&gt; call) will block until space becomes available.</source>
          <target state="translated">場合は&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;いっぱいある、（上の作家 &lt;code&gt;put!&lt;/code&gt; スペースが利用可能になるまでコール）がブロックされます。</target>
        </trans-unit>
        <trans-unit id="800a9b7d396fd78b7b6ed22445dc02985ff5d965" translate="yes" xml:space="preserve">
          <source>If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of &lt;code&gt;VecElement&lt;/code&gt; that naturally maps to the SIMD type. Specifically:</source>
          <target state="translated">C / C ++ルーチンに引数または戻り値がネイティブSIMDタイプである場合、対応するJuliaタイプは、当然SIMDタイプにマップされる &lt;code&gt;VecElement&lt;/code&gt; の同種のタプルです。具体的には：</target>
        </trans-unit>
        <trans-unit id="c33b9c9ad9c6bea2ac47b4bed7df57b3ce4b628b" translate="yes" xml:space="preserve">
          <source>If a Julia function returns an array, the return value of &lt;code&gt;jl_eval_string&lt;/code&gt; and &lt;code&gt;jl_call&lt;/code&gt; can be cast to a &lt;code&gt;jl_array_t*&lt;/code&gt;:</source>
          <target state="translated">Julia関数が配列を返す場合、 &lt;code&gt;jl_eval_string&lt;/code&gt; および &lt;code&gt;jl_call&lt;/code&gt; の戻り値は &lt;code&gt;jl_array_t*&lt;/code&gt; キャストできます。</target>
        </trans-unit>
        <trans-unit id="da26aec502d267a61bc582bb3d104bf1101787e9" translate="yes" xml:space="preserve">
          <source>If a composite type is declared with &lt;code&gt;mutable struct&lt;/code&gt; instead of &lt;code&gt;struct&lt;/code&gt;, then instances of it can be modified:</source>
          <target state="translated">複合型を用いて宣言された場合に &lt;code&gt;mutable struct&lt;/code&gt; の代わりに &lt;code&gt;struct&lt;/code&gt; 、それのその後のインスタンスを修正することができます。</target>
        </trans-unit>
        <trans-unit id="4c7983e304a903c4c76a6412696125933d637b1a" translate="yes" xml:space="preserve">
          <source>If a function name requires multiple words, consider whether it might represent more than one concept and might be better split into pieces.</source>
          <target state="translated">関数名に複数の単語が必要な場合は、それが複数の概念を表すかどうかを検討し、分割した方が良いかどうかを検討してください。</target>
        </trans-unit>
        <trans-unit id="38936f146450cf1d3ca2236e47484dcaa49c5476" translate="yes" xml:space="preserve">
          <source>If a keyword argument is not assigned a default value in the method definition, then it is &lt;em&gt;required&lt;/em&gt;: an &lt;a href=&quot;../../base/base/index#Core.UndefKeywordError&quot;&gt;&lt;code&gt;UndefKeywordError&lt;/code&gt;&lt;/a&gt; exception will be thrown if the caller does not assign it a value:</source>
          <target state="translated">キーワード引数にメソッド定義でデフォルト値が割り当てられていない場合は、それが&lt;em&gt;必要です&lt;/em&gt;。呼び出し側が値を割り当てない場合は、&lt;a href=&quot;../../base/base/index#Core.UndefKeywordError&quot;&gt; &lt;code&gt;UndefKeywordError&lt;/code&gt; &lt;/a&gt;例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="605fe15674b1485baef4edc3c0b585f43273c96f" translate="yes" xml:space="preserve">
          <source>If a name is qualified (e.g. &lt;code&gt;Base.sin&lt;/code&gt;), then it can be accessed even if it is not exported. This is often useful when debugging. It can also have methods added to it by using the qualified name as the function name. However, due to syntactic ambiguities that arise, if you wish to add methods to a function in a different module whose name contains only symbols, such as an operator, &lt;code&gt;Base.+&lt;/code&gt; for example, you must use &lt;code&gt;Base.:+&lt;/code&gt; to refer to it. If the operator is more than one character in length you must surround it in brackets, such as: &lt;code&gt;Base.:(==)&lt;/code&gt;.</source>
          <target state="translated">名前が修飾されている場合（ &lt;code&gt;Base.sin&lt;/code&gt; など）、エクスポートされていなくてもアクセスできます。これは多くの場合、デバッグ時に役立ちます。修飾名を関数名として使用して、メソッドを追加することもできます。ただし、発生する構文のあいまいさのため、演算子、たとえば &lt;code&gt;Base.+&lt;/code&gt; などの名前にシンボルのみが含まれる別のモジュールの関数にメソッドを追加する場合は、Base。：+を使用して &lt;code&gt;Base.:+&lt;/code&gt; を参照する必要があります。。演算子の長さが複数の場合は、 &lt;code&gt;Base.:(==)&lt;/code&gt; . :( ==）のように、演算子を角かっこで囲む必要があります。</target>
        </trans-unit>
        <trans-unit id="906babc709733bae3d983752e96904e9364b6d02" translate="yes" xml:space="preserve">
          <source>If a number doesn't have an exact floating-point representation, it must be rounded to an appropriate representable value. However, the manner in which this rounding is done can be changed if required according to the rounding modes presented in the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;.</source>
          <target state="translated">数値に正確な浮動小数点表現がない場合は、適切な表現可能な値に丸める必要があります。ただし、この丸めが行われる方法は、&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754標準で&lt;/a&gt;提示されている丸めモードに従って、必要に応じて変更できます。</target>
        </trans-unit>
        <trans-unit id="b6c6ec423ec9e7ccad324608060715dc6c4297ac" translate="yes" xml:space="preserve">
          <source>If a package subdirectory has a project file, then the graph entry for its UUID is the &lt;code&gt;[deps]&lt;/code&gt; map of the project file, which is considered to be empty if the section is absent.</source>
          <target state="translated">パッケージのサブディレクトリにプロジェクトファイルがある場合、そのUUIDのグラフエントリはプロジェクトファイルの &lt;code&gt;[deps]&lt;/code&gt; マップであり、セクションがない場合は空であると見なされます。</target>
        </trans-unit>
        <trans-unit id="b858ef46784b4025474ecb1ef203d57b534b42bf" translate="yes" xml:space="preserve">
          <source>If a package subdirectory has no project file, then it is omitted from graph and import statements in its code are treated as top-level, the same as the main project and REPL.</source>
          <target state="translated">パッケージのサブディレクトリにプロジェクトファイルがない場合は、グラフから省略され、そのコード内のインポート文は、メインプロジェクトやREPLと同じトップレベルとして扱われます。</target>
        </trans-unit>
        <trans-unit id="2f45dbf01a0d76d1b423a11e7134b517f4cc2734" translate="yes" xml:space="preserve">
          <source>If a regular expression does match, the value returned by &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; is a &lt;code&gt;RegexMatch&lt;/code&gt; object. These objects record how the expression matches, including the substring that the pattern matches and any captured substrings, if there are any. This example only captures the portion of the substring that matches, but perhaps we want to capture any non-blank text after the comment character. We could do the following:</source>
          <target state="translated">正規表現が一致する場合、によって返される値&lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;ある &lt;code&gt;RegexMatch&lt;/code&gt; オブジェクト。これらのオブジェクトは、パターンが一致する部分文字列、およびキャプチャされた部分文字列（ある場合）を含め、式がどのように一致するかを記録します。この例では、一致する部分文字列の部分のみをキャプチャしますが、コメント文字の後の空白以外のテキストをキャプチャしたい場合があります。次のことができます。</target>
        </trans-unit>
        <trans-unit id="5e6085fa6af3d4081b0dc16abe2813cbe1633ab2" translate="yes" xml:space="preserve">
          <source>If a second argument &lt;code&gt;val&lt;/code&gt; is provided, it will be passed to the task (via the return value of &lt;a href=&quot;#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;) when it runs again. If &lt;code&gt;error&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the value is raised as an exception in the woken task.</source>
          <target state="translated">2番目の引数 &lt;code&gt;val&lt;/code&gt; が指定されている場合、再度実行すると、タスクに（&lt;a href=&quot;#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;の戻り値を介して）渡されます。 &lt;code&gt;error&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、起こされたタスクの例外として値が発生します。</target>
        </trans-unit>
        <trans-unit id="bad86ee27c201caed09e850508017b392f709911" translate="yes" xml:space="preserve">
          <source>If a test fails consistently it can be changed to use the &lt;code&gt;@test_broken&lt;/code&gt; macro. This will denote the test as &lt;code&gt;Broken&lt;/code&gt; if the test continues to fail and alerts the user via an &lt;code&gt;Error&lt;/code&gt; if the test succeeds.</source>
          <target state="translated">テストが一貫して失敗する場合は、 &lt;code&gt;@test_broken&lt;/code&gt; マクロを使用するように変更できます。これは、テストが失敗し続ける場合はテストが &lt;code&gt;Broken&lt;/code&gt; ことを示し、テストが成功した場合は &lt;code&gt;Error&lt;/code&gt; を介してユーザーに警告します。</target>
        </trans-unit>
        <trans-unit id="f4acf383897e60ec242acf14416a5081e1af3573" translate="yes" xml:space="preserve">
          <source>If a tuple of keyword argument names &lt;code&gt;kwnames&lt;/code&gt; is provided, this also checks whether the method of &lt;code&gt;f&lt;/code&gt; matching &lt;code&gt;t&lt;/code&gt; has the given keyword argument names. If the matching method accepts a variable number of keyword arguments, e.g. with &lt;code&gt;kwargs...&lt;/code&gt;, any names given in &lt;code&gt;kwnames&lt;/code&gt; are considered valid. Otherwise the provided names must be a subset of the method's keyword arguments.</source>
          <target state="translated">キーワード引数名 &lt;code&gt;kwnames&lt;/code&gt; のタプルが指定されている場合、これは、 &lt;code&gt;t&lt;/code&gt; に一致する &lt;code&gt;f&lt;/code&gt; のメソッドに指定されたキーワード引数名​​があるかどうかもチェックします。一致するメソッドが可変数のキーワード引数を受け入れる場合（例： &lt;code&gt;kwargs...&lt;/code&gt; 、 &lt;code&gt;kwnames&lt;/code&gt; で指定された名前はすべて有効と見なされます。それ以外の場合、提供される名前はメソッドのキーワード引数のサブセットでなければなりません。</target>
        </trans-unit>
        <trans-unit id="3df6568badc4d30be904f3a616a563af8fd77a0a" translate="yes" xml:space="preserve">
          <source>If a type is defined as a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access. See the &lt;a href=&quot;../arrays/index#man-multi-dim-arrays-1&quot;&gt;arrays manual page&lt;/a&gt; and the &lt;a href=&quot;../../base/arrays/index#lib-arrays-1&quot;&gt;Julia Base section&lt;/a&gt; for more supported methods.</source>
          <target state="translated">タイプが &lt;code&gt;AbstractArray&lt;/code&gt; のサブタイプとして定義されている場合、そのタイプは、単一要素のアクセスに基づいて構築された反復や多次元インデックス作成など、非常に多くの豊富な動作のセットを継承します。サポートされているメソッドの詳細については、&lt;a href=&quot;../arrays/index#man-multi-dim-arrays-1&quot;&gt;アレイのマニュアルページ&lt;/a&gt;と&lt;a href=&quot;../../base/arrays/index#lib-arrays-1&quot;&gt;Julia Baseセクション&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="72a8103071abaea7ac2a617ea71042865eddd171" translate="yes" xml:space="preserve">
          <source>If a type is effectively an enumeration, it should be defined as a single (ideally immutable struct or primitive) type, with the enumeration values being instances of it. Constructors and conversions can check whether values are valid. This design is preferred over making the enumeration an abstract type, with the &quot;values&quot; as subtypes.</source>
          <target state="translated">型が事実上の列挙である場合,それは単一の(理想的には不変な構造体またはプリミティブ)型として定義され,列挙値はそのインスタンスとなります。コンストラクタや変換は,値が有効かどうかをチェックすることができます。この設計は、列挙を抽象型とし、「値」をサブ型とするよりも優先されます。</target>
        </trans-unit>
        <trans-unit id="22206d1a9cff4ea1aad87ee3f387a4a25003f12d" translate="yes" xml:space="preserve">
          <source>If a user is presented with a credential prompt they can abort the prompt by typing &lt;code&gt;^D&lt;/code&gt; (pressing the control key together with the &lt;code&gt;d&lt;/code&gt; key).</source>
          <target state="translated">ユーザーに資格情報プロンプトが表示された場合、 &lt;code&gt;^D&lt;/code&gt; 入力して（Ctrlキーを押しながら &lt;code&gt;d&lt;/code&gt; キーを押す）、プロンプトを中止できます。</target>
        </trans-unit>
        <trans-unit id="ebb7b0aa6b2c808bffa6df77883dc4cf4f4f7ece" translate="yes" xml:space="preserve">
          <source>If a worker pool is not specified, all available workers, i.e., the default worker pool is used.</source>
          <target state="translated">ワーカープールが指定されていない場合、利用可能なすべてのワーカー、すなわちデフォルトのワーカープールが使用されます。</target>
        </trans-unit>
        <trans-unit id="ec5bfd99caef655cee76ea6c587f7690d264c4bb" translate="yes" xml:space="preserve">
          <source>If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</source>
          <target state="translated">すべてのデータが数値の場合、結果は数値配列となります。いくつかの要素が数値として解析できない場合は、数値と文字列の異種配列が返されます。</target>
        </trans-unit>
        <trans-unit id="9ac5a121e4737af42e151921b98260446a6d1fe7" translate="yes" xml:space="preserve">
          <source>If all indices &lt;code&gt;I_k&lt;/code&gt; are integers, then the value in location &lt;code&gt;I_1, I_2, ..., I_n&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value of &lt;code&gt;X&lt;/code&gt;, &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;ing to the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;A&lt;/code&gt; if necessary.</source>
          <target state="translated">すべてのインデックス場合 &lt;code&gt;I_k&lt;/code&gt; 整数であり、その後、位置の値 &lt;code&gt;I_1, I_2, ..., I_n&lt;/code&gt; の &lt;code&gt;A&lt;/code&gt; は、の値で上書きされた &lt;code&gt;X&lt;/code&gt; 、&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;にINGの&lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt;の &lt;code&gt;A&lt;/code&gt; 必要に応じ。</target>
        </trans-unit>
        <trans-unit id="16c375c96eb496fe31b2274a71fede0f6283f232" translate="yes" xml:space="preserve">
          <source>If all indices &lt;code&gt;I_k&lt;/code&gt; are vectors, for example, then the shape of &lt;code&gt;X&lt;/code&gt; would be &lt;code&gt;(length(I_1), length(I_2), ..., length(I_n))&lt;/code&gt;, with location &lt;code&gt;i_1, i_2, ..., i_n&lt;/code&gt; of &lt;code&gt;X&lt;/code&gt; containing the value &lt;code&gt;A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]&lt;/code&gt;.</source>
          <target state="translated">すべてのインデックス場合 &lt;code&gt;I_k&lt;/code&gt; ベクトルであり、例えば、その後の形状 &lt;code&gt;X&lt;/code&gt; はであろう &lt;code&gt;(length(I_1), length(I_2), ..., length(I_n))&lt;/code&gt; 位置と、 &lt;code&gt;i_1, i_2, ..., i_n&lt;/code&gt; の &lt;code&gt;X&lt;/code&gt; 値を含む &lt;code&gt;A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7329bd9dbc66827b90f349500e9813dc3f4dd6b" translate="yes" xml:space="preserve">
          <source>If all the arguments are scalars or zero-dimensional arrays, it returns an unwrapped scalar.</source>
          <target state="translated">すべての引数がスカラまたは0次元配列の場合、ラップされていないスカラを返します。</target>
        </trans-unit>
        <trans-unit id="947c4d2702167c0b010760802f3c8902ac7ef2b7" translate="yes" xml:space="preserve">
          <source>If all the indices are scalars, then the result &lt;code&gt;X&lt;/code&gt; is a single element from the array &lt;code&gt;A&lt;/code&gt;. Otherwise, &lt;code&gt;X&lt;/code&gt; is an array with the same number of dimensions as the sum of the dimensionalities of all the indices.</source>
          <target state="translated">すべてのインデックスがスカラーの場合、結果 &lt;code&gt;X&lt;/code&gt; は配列 &lt;code&gt;A&lt;/code&gt; の単一の要素になります。それ以外の場合、 &lt;code&gt;X&lt;/code&gt; は、すべてのインデックスの次元数の合計と同じ次元数の配列です。</target>
        </trans-unit>
        <trans-unit id="3044600e4ff9e45b323c2058f952d5b48a41642d" translate="yes" xml:space="preserve">
          <source>If all these checks pass, the message and key&amp;ndash;value pairs are evaluated in full and passed to the current logger via the &lt;a href=&quot;#Base.CoreLogging.handle_message&quot;&gt;&lt;code&gt;Logging.handle_message&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;handle_message()&lt;/code&gt; may perform additional filtering as required and display the event to the screen, save it to a file, etc.</source>
          <target state="translated">これらすべてのチェックに合格すると、メッセージとキーと値のペアが完全に評価され、&lt;a href=&quot;#Base.CoreLogging.handle_message&quot;&gt; &lt;code&gt;Logging.handle_message&lt;/code&gt; &lt;/a&gt;関数を介して現在のロガーに渡されます。 &lt;code&gt;handle_message()&lt;/code&gt; は、必要に応じて追加のフィルタリングを実行し、イベントを画面に表示したり、ファイルに保存したりできます。</target>
        </trans-unit>
        <trans-unit id="bec4431d05d00195da3b5ef4209465d15c43707c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;init&lt;/code&gt; function of the type &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; is specified, it is called on all the participating workers.</source>
          <target state="translated">場合 &lt;code&gt;init&lt;/code&gt; タイプの機能 &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; 指定され、それがすべての参加労働者と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="3b65b9c692ce6d8deffe1b518910973b66bdfe66" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;init&lt;/code&gt; function, of signature &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt;, is specified, it is called on all the participating workers. You can specify that each worker runs the &lt;code&gt;init&lt;/code&gt; function on a distinct portion of the array, thereby parallelizing initialization.</source>
          <target state="translated">場合 &lt;code&gt;init&lt;/code&gt; 署名の機能、 &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; 、指定され、それがすべての参加労働者と呼ばれています。各ワーカーが配列の異なる部分で &lt;code&gt;init&lt;/code&gt; 関数を実行するように指定して、初期化を並列化できます。</target>
        </trans-unit>
        <trans-unit id="dcd6328c4dd12bc549abfb594d444224ffd4160c" translate="yes" xml:space="preserve">
          <source>If an array of eltype &lt;code&gt;Ptr{T}&lt;/code&gt; is passed as a &lt;code&gt;Ptr{Ptr{T}}&lt;/code&gt; argument, &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; will attempt to first make a null-terminated copy of the array with each element replaced by its &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; version. This allows, for example, passing an &lt;code&gt;argv&lt;/code&gt; pointer array of type &lt;code&gt;Vector{String}&lt;/code&gt; to an argument of type &lt;code&gt;Ptr{Ptr{Cchar}}&lt;/code&gt;.</source>
          <target state="translated">eltypeのアレイ場合 &lt;code&gt;Ptr{T}&lt;/code&gt; ように渡される &lt;code&gt;Ptr{Ptr{T}}&lt;/code&gt; 引数、&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; は&lt;/a&gt;そのによって置き換え各要素と最初にするために、アレイのヌル終了コピーを試みる&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; の&lt;/a&gt;バージョン。これにより、たとえば、 &lt;code&gt;Vector{String}&lt;/code&gt; 型の &lt;code&gt;argv&lt;/code&gt; ポインター配列を &lt;code&gt;Ptr{Ptr{Cchar}}&lt;/code&gt; 型の引数に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="8aa768f627a40c9d0913fe21e857ab82ce9b4abc" translate="yes" xml:space="preserve">
          <source>If any conflicts arise which cannot be automatically resolved, the rebase will abort, leaving the repository and working tree in its original state, and the function will throw a &lt;code&gt;GitError&lt;/code&gt;. This is roughly equivalent to the following command line statement:</source>
          <target state="translated">自動的に解決できない競合が発生した場合、リベースは中止され、リポジトリと作業ツリーは元の状態のままになり、関数は &lt;code&gt;GitError&lt;/code&gt; をスローします。これは、次のコマンドラインステートメントとほぼ同じです。</target>
        </trans-unit>
        <trans-unit id="d387af77f5db6a955f974f865de51228d37bd15f" translate="yes" xml:space="preserve">
          <source>If any index &lt;code&gt;I_k&lt;/code&gt; selects more than one location, then the right hand side &lt;code&gt;X&lt;/code&gt; must be an array with the same shape as the result of indexing &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; or a vector with the same number of elements. The value in location &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt;, converting if necessary. The element-wise assignment operator &lt;code&gt;.=&lt;/code&gt; may be used to &lt;a href=&quot;#Broadcasting-1&quot;&gt;broadcast&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; across the selected locations:</source>
          <target state="translated">インデックス &lt;code&gt;I_k&lt;/code&gt; が複数の場所を選択する場合、右側の &lt;code&gt;X&lt;/code&gt; は、 &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; のインデックス付けの結果と同じ形状の配列、または同じ数の要素を持つベクトルでなければなりません。。位置の値 &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; の &lt;code&gt;A&lt;/code&gt; は、値で上書きされる &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt; 、必要に応じて変換します。要素ごとの代入演算子 &lt;code&gt;.=&lt;/code&gt; を使用して、選択した場所全体に &lt;code&gt;X&lt;/code&gt; を&lt;a href=&quot;#Broadcasting-1&quot;&gt;ブロードキャスト&lt;/a&gt;できます。</target>
        </trans-unit>
        <trans-unit id="a2dae61ea17ea95a5a6582831ba526a24537cb67" translate="yes" xml:space="preserve">
          <source>If any inner constructor method is defined, no default constructor method is provided: it is presumed that you have supplied yourself with all the inner constructors you need. The default constructor is equivalent to writing your own inner constructor method that takes all of the object's fields as parameters (constrained to be of the correct type, if the corresponding field has a type), and passes them to &lt;code&gt;new&lt;/code&gt;, returning the resulting object:</source>
          <target state="translated">内部コンストラクターメソッドが定義されている場合、デフォルトのコンストラクターメソッドは提供されません。必要な内部コンストラクターがすべて提供されていると想定されます。デフォルトのコンストラクターは、オブジェクトのすべてのフィールドをパラメーターとして受け取り（対応するフィールドに型がある場合は、正しい型になるように制約されます）、独自の内部コンストラクターメソッドを作成してそれらを &lt;code&gt;new&lt;/code&gt; に渡し、結果のオブジェクトを返すのと同じです。</target>
        </trans-unit>
        <trans-unit id="e9dbb4d7bac298e185fc7fe07e57c374bc123283" translate="yes" xml:space="preserve">
          <source>If any of these result in success, the path to the source code entry point will be either that result, the relative path from that result plus &lt;code&gt;src/X.jl&lt;/code&gt;; otherwise, there is no path mapping for &lt;code&gt;uuid&lt;/code&gt;. When loading &lt;code&gt;X&lt;/code&gt;, if no source code path is found, the lookup will fail, and the user may be prompted to install the appropriate package version or to take other corrective action (e.g. declaring &lt;code&gt;X&lt;/code&gt; as a dependency).</source>
          <target state="translated">これらのいずれかが成功した場合、ソースコードエントリポイントへのパスは、その結果、その結果からの相対パス、および &lt;code&gt;src/X.jl&lt;/code&gt; のいずれかになります。それ以外の場合、 &lt;code&gt;uuid&lt;/code&gt; のパスマッピングはありません。 &lt;code&gt;X&lt;/code&gt; の読み込み時にソースコードパスが見つからない場合、検索は失敗し、適切なパッケージバージョンをインストールするか、他の修正アクション（ &lt;code&gt;X&lt;/code&gt; を依存関係として宣言するなど）を実行するように求められる場合があります。</target>
        </trans-unit>
        <trans-unit id="4ddf1789b0cb07d74b04fcfdb8b7aef3cf09d72f" translate="yes" xml:space="preserve">
          <source>If array contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the standard deviation of non-missing values.</source>
          <target state="translated">アレイが含まれている場合 &lt;code&gt;NaN&lt;/code&gt; または&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;た値を、結果でもある &lt;code&gt;NaN&lt;/code&gt; または &lt;code&gt;missing&lt;/code&gt; （ &lt;code&gt;missing&lt;/code&gt; 配列の両方が含まれている場合に優先）。&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;関数を使用して、 &lt;code&gt;missing&lt;/code&gt; エントリを省略し、欠落していない値の標準偏差を計算します。</target>
        </trans-unit>
        <trans-unit id="3a6293b5e98855a8ee42f2bca1bebc73fa339517" translate="yes" xml:space="preserve">
          <source>If array contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the variance of non-missing values.</source>
          <target state="translated">アレイが含まれている場合 &lt;code&gt;NaN&lt;/code&gt; または&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;た値を、結果でもある &lt;code&gt;NaN&lt;/code&gt; または &lt;code&gt;missing&lt;/code&gt; （ &lt;code&gt;missing&lt;/code&gt; 配列の両方が含まれている場合に優先）。&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;関数を使用して、 &lt;code&gt;missing&lt;/code&gt; エントリを省略し、欠落していない値の分散を計算します。</target>
        </trans-unit>
        <trans-unit id="38e45e26639753f801787edbbd58523b34871d79" translate="yes" xml:space="preserve">
          <source>If at least one argument is a tuple and all others are scalars or zero-dimensional arrays, it returns a tuple.</source>
          <target state="translated">少なくとも1つの引数がタプルで、他のすべての引数がスカラか0次元配列である場合、タプルを返します。</target>
        </trans-unit>
        <trans-unit id="186a2528019c2b28f2ac036bd36737c001f4c334" translate="yes" xml:space="preserve">
          <source>If called with the optional &lt;code&gt;stream&lt;/code&gt; argument, then returns &lt;code&gt;stream&lt;/code&gt; itself.</source>
          <target state="translated">オプションの &lt;code&gt;stream&lt;/code&gt; 引数を指定して呼び出された場合、 &lt;code&gt;stream&lt;/code&gt; 自体を返します。</target>
        </trans-unit>
        <trans-unit id="c2dc6a2dba2346f86620a63b3cfed83cd90e27f4" translate="yes" xml:space="preserve">
          <source>If captured variables are used in a performance-critical section of the code, then the following tips help ensure that their use is performant. First, if it is known that a captured variable does not change its type, then this can be declared explicitly with a type annotation (on the variable, not the right-hand side):</source>
          <target state="translated">キャプチャされた変数がコードのパフォーマンスが重要な部分で使用される場合、以下のヒントは、その使用がパフォーマンスの高いものであることを保証するのに役立ちます。まず、キャプチャされた変数がその型を変更しないことがわかっている場合、型アノテーションを使って明示的に宣言することができます(右辺ではなく変数の上で)。</target>
        </trans-unit>
        <trans-unit id="1a5d4d133718a06af974dc91ca305c022dd4e098" translate="yes" xml:space="preserve">
          <source>If field types are specified, the arguments are converted. Otherwise the types of the arguments are used directly.</source>
          <target state="translated">フィールド型が指定されている場合、引数は変換されます。それ以外の場合は、引数の型が直接使用されます。</target>
        </trans-unit>
        <trans-unit id="8f773999b3dbcf00b06936dfadd297798081b077" translate="yes" xml:space="preserve">
          <source>If instead you want to specialize on the destination type &lt;code&gt;DestType&lt;/code&gt; without specializing on &lt;code&gt;DestStyle&lt;/code&gt;, then you should define a method with the following signature:</source>
          <target state="translated">あなたが先の型に特化したい場合は代わりに &lt;code&gt;DestType&lt;/code&gt; に特化せず &lt;code&gt;DestStyle&lt;/code&gt; 、その後、次のシグネチャを持つメソッドを定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="861e841404a73546cfbc58b3413de786fc3740a2" translate="yes" xml:space="preserve">
          <source>If it does not have a project file, it can import any top-level package&amp;mdash;i.e. the same packages that can be loaded in &lt;code&gt;Main&lt;/code&gt; or the REPL.</source>
          <target state="translated">プロジェクトファイルがない場合は、トップレベルのパッケージ、つまり &lt;code&gt;Main&lt;/code&gt; またはREPLにロードできる同じパッケージをインポートできます。</target>
        </trans-unit>
        <trans-unit id="4cdc37b95e5e03c0daf7e3854e30ae2e06ab2fbd" translate="yes" xml:space="preserve">
          <source>If it has a &lt;code&gt;git-tree-sha1&lt;/code&gt; entry, compute a deterministic hash function of &lt;code&gt;uuid&lt;/code&gt; and &lt;code&gt;git-tree-sha1&lt;/code&gt;&amp;mdash;call it &lt;code&gt;slug&lt;/code&gt;&amp;mdash;and look for a directory named &lt;code&gt;packages/X/$slug&lt;/code&gt; in each directory in the Julia &lt;code&gt;DEPOT_PATH&lt;/code&gt; global array. Use the first such directory that exists.</source>
          <target state="translated">&lt;code&gt;git-tree-sha1&lt;/code&gt; エントリがある場合は、 &lt;code&gt;uuid&lt;/code&gt; と &lt;code&gt;git-tree-sha1&lt;/code&gt; の確定的ハッシュ関数を計算します&amp;mdash; &lt;code&gt;slug&lt;/code&gt; と呼びます&amp;mdash; Julia &lt;code&gt;DEPOT_PATH&lt;/code&gt; グローバル配列の各ディレクトリで &lt;code&gt;packages/X/$slug&lt;/code&gt; という名前のディレクトリを探します。存在する最初のそのようなディレクトリを使用します。</target>
        </trans-unit>
        <trans-unit id="cd1241924f2c661cd879945fa2b395e0b0c5bf1c" translate="yes" xml:space="preserve">
          <source>If it has a &lt;code&gt;path&lt;/code&gt; entry, use that path (relative to the directory containing the manifest file).</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; エントリがある場合は、そのパスを使用します（マニフェストファイルを含むディレクトリからの相対パス）。</target>
        </trans-unit>
        <trans-unit id="ecfbca60e91ee74286b0eaf619c2ce8c59e2470c" translate="yes" xml:space="preserve">
          <source>If it has a project file, it can only import those packages which are identified in the &lt;code&gt;[deps]&lt;/code&gt; section of the project file.</source>
          <target state="translated">プロジェクトファイルがある場合、プロジェクトファイルの &lt;code&gt;[deps]&lt;/code&gt; セクションで識別されるパッケージのみをインポートできます。</target>
        </trans-unit>
        <trans-unit id="d73050aa6cb9e92d8510b86ef26b845581d55552" translate="yes" xml:space="preserve">
          <source>If it is required to hold the pointer to a variable between functions (or block scopes), then it is not possible to use &lt;code&gt;JL_GC_PUSH*&lt;/code&gt;. In this case, it is necessary to create and keep a reference to the variable in the Julia global scope. One simple way to accomplish this is to use a global &lt;code&gt;IdDict&lt;/code&gt; that will hold the references, avoiding deallocation by the GC. However, this method will only work properly with mutable types.</source>
          <target state="translated">関数間（またはブロックスコープ）の変数へのポインターを保持する必要がある場合は、 &lt;code&gt;JL_GC_PUSH*&lt;/code&gt; を使用することはできません。この場合、Juliaグローバルスコープで変数への参照を作成して保持する必要があります。これを行う簡単な方法の1つは、GCによる割り当て解除を回避し、参照を保持するグローバル &lt;code&gt;IdDict&lt;/code&gt; を使用することです。ただし、このメソッドは変更可能な型でのみ正しく機能します。</target>
        </trans-unit>
        <trans-unit id="473e682023e21d67484bab11333a56f6e24d4e3e" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;jl_gc_collect()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_PRINT&lt;/code&gt;, then counts for the number of calls to &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; and &lt;code&gt;maybe_collect()&lt;/code&gt; are printed.</source>
          <target state="translated">&lt;code&gt;jl_gc_collect()&lt;/code&gt; が呼び出されたのが &lt;code&gt;n&lt;/code&gt; 回目であり、 &lt;code&gt;n&lt;/code&gt; が &lt;code&gt;$JULIA_GC_ALLOC_PRINT&lt;/code&gt; で表される算術シーケンスに属している場合、 &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; および &lt;code&gt;maybe_collect()&lt;/code&gt; の呼び出し回数のカウントが出力されます。</target>
        </trans-unit>
        <trans-unit id="130d982e40fa648e81bf69006602371d8efc3765" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_POOL&lt;/code&gt;, then garbage collection is forced.</source>
          <target state="translated">それはだ場合 &lt;code&gt;n&lt;/code&gt; という回目 &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; と呼ばれる、とされている &lt;code&gt;n&lt;/code&gt; によって表される数列に属し &lt;code&gt;$JULIA_GC_ALLOC_POOL&lt;/code&gt; 、その後、ガベージコレクションを強制されます。</target>
        </trans-unit>
        <trans-unit id="40d1d12e4aea313c12b9b3da68ad08e9a0d521e5" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;maybe_collect()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_OTHER&lt;/code&gt;, then garbage collection is forced.</source>
          <target state="translated">&lt;code&gt;maybe_collect()&lt;/code&gt; が呼び出されたのが &lt;code&gt;n&lt;/code&gt; 回目で、 &lt;code&gt;n&lt;/code&gt; が &lt;code&gt;$JULIA_GC_ALLOC_OTHER&lt;/code&gt; で表される算術シーケンスに属している場合、ガベージコレクションが強制されます。</target>
        </trans-unit>
        <trans-unit id="74f9655f12c7f5e7ed84cb6e935e104ba2688d1a" translate="yes" xml:space="preserve">
          <source>If keyword &lt;code&gt;supertypes&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, also return arguments with a parent type of &lt;code&gt;typ&lt;/code&gt;, excluding type &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">キーワード &lt;code&gt;supertypes&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、タイプ &lt;code&gt;Any&lt;/code&gt; を除く、親タイプ &lt;code&gt;typ&lt;/code&gt; の引数も返します。</target>
        </trans-unit>
        <trans-unit id="bc696527340f0e0e085e98638a1e2d12825b4024" translate="yes" xml:space="preserve">
          <source>If memory usage is your concern, you can always replace objects with ones that consume less memory. For example, if &lt;code&gt;A&lt;/code&gt; is a gigabyte-sized array that you no longer need, you can free the memory with &lt;code&gt;A = nothing&lt;/code&gt;. The memory will be released the next time the garbage collector runs; you can force this to happen with &lt;a href=&quot;../../base/base/index#Base.GC.gc&quot;&gt;&lt;code&gt;gc()&lt;/code&gt;&lt;/a&gt;. Moreover, an attempt to use &lt;code&gt;A&lt;/code&gt; will likely result in an error, because most methods are not defined on type &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">メモリ使用量が気になる場合は、いつでもオブジェクトをより少ないメモリを消費するオブジェクトに置き換えることができます。たとえば、 &lt;code&gt;A&lt;/code&gt; が不要になったギガバイトサイズの配列である場合、 &lt;code&gt;A = nothing&lt;/code&gt; メモリを解放できます。メモリは、次にガベージコレクタが実行されるときに解放されます。これを&lt;a href=&quot;../../base/base/index#Base.GC.gc&quot;&gt; &lt;code&gt;gc()&lt;/code&gt; &lt;/a&gt;で強制的に実行できます。さらに、ほとんどのメソッドはタイプ &lt;code&gt;Nothing&lt;/code&gt; で定義されていないため、 &lt;code&gt;A&lt;/code&gt; を使用しようとするとエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="5d311a5ead70c39f70d69a25fb13adf9b0a2959d" translate="yes" xml:space="preserve">
          <source>If much of your run time is spent executing a particular line of code, this line will show up frequently in the set of all backtraces. In other words, the &quot;cost&quot; of a given line&amp;ndash;or really, the cost of the sequence of function calls up to and including this line&amp;ndash;is proportional to how often it appears in the set of all backtraces.</source>
          <target state="translated">実行時間の多くが特定のコード行の実行に費やされている場合、この行はすべてのバックトレースのセットで頻繁に表示されます。つまり、特定の行の「コスト」、または実際には、この行までの一連の関数呼び出しのコストは、すべてのバックトレースのセットに出現する頻度に比例します。</target>
        </trans-unit>
        <trans-unit id="99791a8f1a9660eaeaa9f5b9e831b943f3ed9006" translate="yes" xml:space="preserve">
          <source>If needed, the sorting algorithm can be chosen:</source>
          <target state="translated">必要に応じて、ソートアルゴリズムを選択することができます。</target>
        </trans-unit>
        <trans-unit id="4223679e9c9b3c609f6bfb56a1e1db206adba7ec" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;type&lt;/code&gt; argument is specified, the default is &lt;code&gt;Vector{UInt8}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 引数が指定されていない場合、デフォルトは &lt;code&gt;Vector{UInt8}&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="dfa8e1861fd13b4e706313c90dcab6ea83fe0c35" translate="yes" xml:space="preserve">
          <source>If no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to &lt;a href=&quot;#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">引数が渡されない場合、タスクは未定義の期間ブロックします。タスクは、&lt;a href=&quot;#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; の&lt;/a&gt;明示的な呼び出しによってのみ再開できます。</target>
        </trans-unit>
        <trans-unit id="aa0a9f892d2c7e314c83b4254ca8ced8f31ecd25" translate="yes" xml:space="preserve">
          <source>If no custom testset type is given it defaults to creating a &lt;code&gt;DefaultTestSet&lt;/code&gt;. &lt;code&gt;DefaultTestSet&lt;/code&gt; records all the results and, if there are any &lt;code&gt;Fail&lt;/code&gt;s or &lt;code&gt;Error&lt;/code&gt;s, throws an exception at the end of the top-level (non-nested) test set, along with a summary of the test results.</source>
          <target state="translated">カスタムテストセットタイプが指定されていない場合、デフォルトで &lt;code&gt;DefaultTestSet&lt;/code&gt; が作成されます。 &lt;code&gt;DefaultTestSet&lt;/code&gt; はすべての結果を記録し、 &lt;code&gt;Fail&lt;/code&gt; または &lt;code&gt;Error&lt;/code&gt; がある場合は、テスト結果の概要とともに、トップレベル（ネストされていない）テストセットの最後に例外をスローします。</target>
        </trans-unit>
        <trans-unit id="1e0f744d0d8245436d7c2b792319d69a40debe40" translate="yes" xml:space="preserve">
          <source>If possible, &lt;code&gt;one(x)&lt;/code&gt; returns a value of the same type as &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;one(T)&lt;/code&gt; returns a value of type &lt;code&gt;T&lt;/code&gt;. However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless. In that case, &lt;code&gt;one(x)&lt;/code&gt; should return an identity value of the same precision (and shape, for matrices) as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">可能な場合、 &lt;code&gt;one(x)&lt;/code&gt; 同じタイプの値を返し &lt;code&gt;x&lt;/code&gt; 、及び &lt;code&gt;one(T)&lt;/code&gt; 式の値を返し &lt;code&gt;T&lt;/code&gt; を。ただし、乗法的恒等式は無次元でなければならないため、これは、次元のある量（日数などの時間）を表すタイプの場合には当てはまらない可能性があります。その場合、 &lt;code&gt;one(x)&lt;/code&gt; として（マトリクスおよび形状）アイデンティティ同じ精度の値を返す必要があり &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe767ad4883ee037996d5cf486b48b4286df5e71" translate="yes" xml:space="preserve">
          <source>If set to a string that starts with the case-insensitive substring &lt;code&gt;&quot;infinite&quot;&lt;/code&gt;, then spinning threads never sleep. Otherwise, &lt;code&gt;$JULIA_THREAD_SLEEP_THRESHOLD&lt;/code&gt; is interpreted as an unsigned 64-bit integer (&lt;code&gt;uint64_t&lt;/code&gt;) and gives, in nanoseconds, the amount of time after which spinning threads should sleep.</source>
          <target state="translated">大文字と小文字を区別しない部分文字列 &lt;code&gt;&quot;infinite&quot;&lt;/code&gt; で始まる文字列に設定すると、回転しているスレッドがスリープ状態になることはありません。それ以外の場合、 &lt;code&gt;$JULIA_THREAD_SLEEP_THRESHOLD&lt;/code&gt; は符号なし64ビット整数（ &lt;code&gt;uint64_t&lt;/code&gt; ）として解釈され、スピンしているスレッドがスリープするまでの時間をナノ秒単位で示します。</target>
        </trans-unit>
        <trans-unit id="20e80c59100f13ca7e73369cbf1cacf7e59c1aa3" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then Julia's thread policy is consistent with running on a dedicated machine: the master thread is on proc 0, and threads are affinitized. Otherwise, Julia lets the operating system handle thread policy.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 以外の値に設定すると、Juliaのスレッドポリシーは専用マシンでの実行と一致します。マスタースレッドはproc 0にあり、スレッドはアフィニティ化されます。それ以外の場合、Juliaはオペレーティングシステムにスレッドポリシーを処理させます。</target>
        </trans-unit>
        <trans-unit id="f40c9b9b4bbc428bc99a8f3b50c7542418d6c605" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the Julia garbage collector never performs &quot;quick sweeps&quot; of memory.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 以外の値に設定すると、Juliaガベージコレクターはメモリの「クイックスイープ」を実行しません。</target>
        </trans-unit>
        <trans-unit id="eb0219b86b58bf1246d63c4e45daa90f20eb81c3" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the Julia garbage collector will wait for a debugger to attach instead of aborting whenever there's a critical error.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 以外の値に設定した場合、Juliaガベージコレクターは、重大なエラーが発生するたびに中止するのではなく、デバッガーが接続するのを待ちます。</target>
        </trans-unit>
        <trans-unit id="1ba30fe7de8eb6c5eb6e36c3ca16b929b1d23810" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the compiler will create and register an event listener for just-in-time (JIT) profiling.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 以外の値に設定すると、コンパイラーはジャストインタイム（JIT）プロファイリング用のイベントリスナーを作成して登録します。</target>
        </trans-unit>
        <trans-unit id="3b0cd4807865348218a8157872f2d19ba8cef0a0" translate="yes" xml:space="preserve">
          <source>If set, then Julia prints detailed information about the cache in the loading process of &lt;a href=&quot;../../base/base/index#Base.require&quot;&gt;&lt;code&gt;Base.require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">設定されている場合、Juliaは&lt;a href=&quot;../../base/base/index#Base.require&quot;&gt; &lt;code&gt;Base.require&lt;/code&gt; の&lt;/a&gt;ロードプロセスでキャッシュに関する詳細情報を出力します。</target>
        </trans-unit>
        <trans-unit id="31ed13caeaa2adf17adcff6b38e069bb43cc30cf" translate="yes" xml:space="preserve">
          <source>If set, these environment variables take strings that optionally start with the character &lt;code&gt;'r'&lt;/code&gt;, followed by a string interpolation of a colon-separated list of three signed 64-bit integers (&lt;code&gt;int64_t&lt;/code&gt;). This triple of integers &lt;code&gt;a:b:c&lt;/code&gt; represents the arithmetic sequence &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;a + b&lt;/code&gt;, &lt;code&gt;a + 2*b&lt;/code&gt;, ... &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">設定されている場合、これらの環境変数は、オプションで文字 &lt;code&gt;'r'&lt;/code&gt; で始まり、その後にコロンで区切られた3つの符号付き64ビット整数のリストの文字列補間（ &lt;code&gt;int64_t&lt;/code&gt; ）が続く文字列を取ります。この整数の3つ &lt;code&gt;a:b:c&lt;/code&gt; は、算術シーケンス &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;a + b&lt;/code&gt; 、 &lt;code&gt;a + 2*b&lt;/code&gt; 、... &lt;code&gt;c&lt;/code&gt; を表します。</target>
        </trans-unit>
        <trans-unit id="24ec6755ec5d15a629cdab4809712a90cbd8c460" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; environment variable is already set, its old value will be prepended with &lt;code&gt;/foo/bar&lt;/code&gt;. On the other hand, if &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; is not set, then it will be set to &lt;code&gt;/foo/bar:&lt;/code&gt; which will have the effect of prepending &lt;code&gt;/foo/bar&lt;/code&gt; to the default depot path. If &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; is set to the empty string, it expands to an empty &lt;code&gt;DEPOT_PATH&lt;/code&gt; array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty depot path via the environment variable. If you want the default depot path, either unset the environment variable or if it must have a value, set it to the string &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; の環境変数がすでに設定され、その古い値が前に付加されます &lt;code&gt;/foo/bar&lt;/code&gt; 。一方、 &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; が設定されていない場合は、 &lt;code&gt;/foo/bar:&lt;/code&gt; に設定されます。これにより、 &lt;code&gt;/foo/bar&lt;/code&gt; がデフォルトのデポパスの前に追加されます。 &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; が空の文字列に設定されている場合、空の &lt;code&gt;DEPOT_PATH&lt;/code&gt; に展開されますアレイ。つまり、空の文字列は、空の文字列の1要素の配列ではなく、0要素の配列として解釈されます。この動作は、環境変数を介して空のデポパスを設定できるようにするために選択されました。デフォルトデポのパスをしたい場合は、環境変数の設定を解除するか、値を持たなければならないのいずれかの場合、文字列に設定 &lt;code&gt;:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="951a284bb764079dcd311388a60d7dc6fdec988b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_DIR&lt;/code&gt; environment variable hasn't been setup, add it using the System panel before starting Visual Studio. The &lt;code&gt;bin&lt;/code&gt; folder under JULIA_DIR should be on the system PATH.</source>
          <target state="translated">&lt;code&gt;JULIA_DIR&lt;/code&gt; 環境変数が設定されていない場合は、Visual Studioを起動する前に、システムパネルを使用して追加してください。JULIA_DIRの下の &lt;code&gt;bin&lt;/code&gt; フォルダーは、システムPATH上にある必要があります。</target>
        </trans-unit>
        <trans-unit id="17b0935fee49a1bcd1eec16c0060a0a58dff07ff" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; environment variable is already set, its old value will be prepended with &lt;code&gt;/foo/bar&lt;/code&gt;. On the other hand, if &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; is not set, then it will be set to &lt;code&gt;/foo/bar:&lt;/code&gt; which will expand to a &lt;code&gt;LOAD_PATH&lt;/code&gt; value of &lt;code&gt;[&quot;/foo/bar&quot;, &quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt;. If &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; is set to the empty string, it expands to an empty &lt;code&gt;LOAD_PATH&lt;/code&gt; array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty load path via the environment variable. If you want the default load path, either unset the environment variable or if it must have a value, set it to the string &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; の環境変数がすでに設定され、その古い値が前に付加されます &lt;code&gt;/foo/bar&lt;/code&gt; 。一方、 &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; が設定されていない場合は、 &lt;code&gt;/foo/bar:&lt;/code&gt; に設定され、 &lt;code&gt;[&quot;/foo/bar&quot;, &quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt; &lt;code&gt;LOAD_PATH&lt;/code&gt; 値に展開されます。 &quot;@stdlib&quot;]。 &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; が空の文字列に設定されている場合、空の &lt;code&gt;LOAD_PATH&lt;/code&gt; に展開されますアレイ。つまり、空の文字列は、空の文字列の1要素の配列ではなく、0要素の配列として解釈されます。この動作は、環境変数を介して空のロードパスを設定できるように選択されています。デフォルトロードパスをしたい、どちらかそれは価値を持たなければならない場合は、環境変数の設定を解除または場合は、文字列に設定 &lt;code&gt;:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c31f515fa1981bd1d01e28ffd032994e4003fc1e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;digits&lt;/code&gt; keyword argument is provided, it rounds to the specified number of digits after the decimal place (or before if negative), in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;digits&lt;/code&gt; キーワード引数が提供され、それがベースで、小数点以下の位の後（または負の場合は前）に指定した桁数に丸め &lt;code&gt;base&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f504c38da450ab2719c1e9cd12d8dd34afd33e92" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;optimize&lt;/code&gt; keyword is unset, the code will be shown before LLVM optimizations. All metadata and dbg.* calls are removed from the printed bitcode. For the full IR, set the &lt;code&gt;raw&lt;/code&gt; keyword to true. To dump the entire module that encapsulates the function (with declarations), set the &lt;code&gt;dump_module&lt;/code&gt; keyword to true. Keyword argument &lt;code&gt;debuginfo&lt;/code&gt; may be one of source (default) or none, to specify the verbosity of code comments.</source>
          <target state="translated">&lt;code&gt;optimize&lt;/code&gt; キーワードが設定されていない場合、コードはLLVM最適化の前に表示されます。すべてのメタデータとdbg。*呼び出しは、出力されたビットコードから削除されます。完全なIRの場合、 &lt;code&gt;raw&lt;/code&gt; キーワードをtrueに設定します。関数（宣言付き）をカプセル化するモジュール全体をダンプするには、 &lt;code&gt;dump_module&lt;/code&gt; キーワードをtrueに設定します。キーワード引数 &lt;code&gt;debuginfo&lt;/code&gt; は、ソース（デフォルト）またはnoneのいずれかで、コードコメントの詳細度を指定します。</target>
        </trans-unit>
        <trans-unit id="383ecf21766e01ab864dfe9bc7ce841c588d3356" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sigdigits&lt;/code&gt; keyword argument is provided, it rounds to the specified number of significant digits, in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;sigdigits&lt;/code&gt; キーワード引数が提供され、それがベースで、指定した有効桁数に丸め &lt;code&gt;base&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cee1b7494eb88d56f5f87336c27b832a3eac177f" translate="yes" xml:space="preserve">
          <source>If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using &lt;code&gt;p::Ptr{gsl_permutation}&lt;/code&gt; for the method signature of the wrapper and similarly in the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; is also acceptable.</source>
          <target state="translated">CラッパーがJuliaが管理するメモリーへのポインターをユーザーに渡すことを決して期待しない場合は、ラッパーのメソッドシグニチャーに &lt;code&gt;p::Ptr{gsl_permutation}&lt;/code&gt; を使用し、同様に&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;でも使用できます。</target>
        </trans-unit>
        <trans-unit id="e69c1bb25c07d7be2be84b2aa57348cae51e4053" translate="yes" xml:space="preserve">
          <source>If the above example source is saved in the file &lt;code&gt;embed_example.c&lt;/code&gt;, then the following command will compile it into a running program on Linux and Windows (MSYS2 environment), or if on OS/X, then substitute &lt;code&gt;clang&lt;/code&gt; for &lt;code&gt;gcc&lt;/code&gt;.:</source>
          <target state="translated">上記のサンプルソースがファイル &lt;code&gt;embed_example.c&lt;/code&gt; に保存されている場合、次のコマンドはLinuxおよびWindows（MSYS2環境）で実行中のプログラムにコンパイルするか、OS / Xの場合は &lt;code&gt;gcc&lt;/code&gt; を &lt;code&gt;clang&lt;/code&gt; に置き換えます。</target>
        </trans-unit>
        <trans-unit id="9e156941127d94f84d815e5639eaa0e64bcbc457" translate="yes" xml:space="preserve">
          <source>If the above is not the case and the project file has a corresponding manifest file and the manifest contains a stanza matching &lt;code&gt;uuid&lt;/code&gt; then:</source>
          <target state="translated">上記が当てはまらず、プロジェクトファイルに対応するマニフェストファイルがあり、マニフェストに &lt;code&gt;uuid&lt;/code&gt; に一致するスタンザが含まれている場合：</target>
        </trans-unit>
        <trans-unit id="9f8fd643e0107bc4fc2c8bed2be168d68373f53a" translate="yes" xml:space="preserve">
          <source>If the alias is documented and not the real definition then the docsystem (&lt;code&gt;?&lt;/code&gt; mode) will not return the docstring attached to the alias when the real definition is searched for.</source>
          <target state="translated">実際の定義ではなくエイリアスが文書化されている場合、docsystem（ &lt;code&gt;?&lt;/code&gt; モード）は、実際の定義が検索されたときにエイリアスに添付されたdocstringを返しません。</target>
        </trans-unit>
        <trans-unit id="f3fd8dba5118a65c9f036f4528fd62b5f0cc2628" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;Future&lt;/code&gt; is owned by a different node, this call will block to wait for the answer. It is recommended to wait for &lt;code&gt;rr&lt;/code&gt; in a separate task instead or to use a local &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; as a proxy:</source>
          <target state="translated">引数 &lt;code&gt;Future&lt;/code&gt; が別のノードによって所有されている場合、この呼び出しはブロックされて応答を待ちます。代わりに別のタスクで &lt;code&gt;rr&lt;/code&gt; を待つか、ローカル&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;をプロキシとして使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5145bb0b73803c7679be17ccbd9728f2cf20e73d" translate="yes" xml:space="preserve">
          <source>If the condition could not be evaluated because an exception was thrown, which occurs in this case because &lt;code&gt;length&lt;/code&gt; is not defined for symbols, an &lt;code&gt;Error&lt;/code&gt; object is returned and an exception is thrown:</source>
          <target state="translated">例外がスローされたために条件を評価できなかった場合（この場合、シンボルに &lt;code&gt;length&lt;/code&gt; が定義されていないために発生します）、 &lt;code&gt;Error&lt;/code&gt; オブジェクトが返され、例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="e94faa3d332e304494043498c5a9abf524bed6e4" translate="yes" xml:space="preserve">
          <source>If the condition expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the corresponding block is evaluated; otherwise the condition expression &lt;code&gt;x &amp;gt; y&lt;/code&gt; is evaluated, and if it is &lt;code&gt;true&lt;/code&gt;, the corresponding block is evaluated; if neither expression is true, the &lt;code&gt;else&lt;/code&gt; block is evaluated. Here it is in action:</source>
          <target state="translated">条件式 &lt;code&gt;x &amp;lt; y&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、対応するブロックが評価されます。そうでない場合、条件式 &lt;code&gt;x &amp;gt; y&lt;/code&gt; が評価され、それが &lt;code&gt;true&lt;/code&gt; の場合、対応するブロックが評価されます。どちらの式もtrueでない場合、 &lt;code&gt;else&lt;/code&gt; ブロックが評価されます。ここでそれは動作しています：</target>
        </trans-unit>
        <trans-unit id="e00b24f52421478ecff61089fe0cac3ea509a829" translate="yes" xml:space="preserve">
          <source>If the condition expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true, then the corresponding block is evaluated; otherwise the condition expression &lt;code&gt;x &amp;gt; y&lt;/code&gt; is evaluated, and if it is true, the corresponding block is evaluated; if neither expression is true, the &lt;code&gt;else&lt;/code&gt; block is evaluated. The &lt;code&gt;elseif&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks are optional, and as many &lt;code&gt;elseif&lt;/code&gt; blocks as desired can be used.</source>
          <target state="translated">条件式 &lt;code&gt;x &amp;lt; y&lt;/code&gt; がtrueの場合、対応するブロックが評価されます。それ以外の場合、条件式 &lt;code&gt;x &amp;gt; y&lt;/code&gt; が評価され、trueの場合、対応するブロックが評価されます。どちらの式もtrueでない場合、 &lt;code&gt;else&lt;/code&gt; ブロックが評価されます。 &lt;code&gt;elseif&lt;/code&gt; と &lt;code&gt;else&lt;/code&gt; のブロックは、オプション、および多くのようです &lt;code&gt;elseif&lt;/code&gt; を必要に応じてブロックを使用することができます。</target>
        </trans-unit>
        <trans-unit id="03e22d8ef38f6c3785531b2aa7d1787777d83c8c" translate="yes" xml:space="preserve">
          <source>If the condition is false, then a &lt;code&gt;Fail&lt;/code&gt; is returned and an exception is thrown:</source>
          <target state="translated">条件がfalseの場合、 &lt;code&gt;Fail&lt;/code&gt; が返され、例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="6b3bbdbb81ff4f33d7f44d969bf8034d1606bc1e" translate="yes" xml:space="preserve">
          <source>If the condition is true, a &lt;code&gt;Pass&lt;/code&gt; is returned:</source>
          <target state="translated">条件が真の場合、 &lt;code&gt;Pass&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="cc2105b7ae7cdead96d8521e45a1f5d3d101c4e9" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true, the entire ternary operator expression evaluates to the string &lt;code&gt;&quot;less than&quot;&lt;/code&gt; and otherwise it evaluates to the string &lt;code&gt;&quot;not less than&quot;&lt;/code&gt;. The original three-way example requires chaining multiple uses of the ternary operator together:</source>
          <target state="translated">式があれば &lt;code&gt;x &amp;lt; y&lt;/code&gt; 真であり、文字列に全体の三オペレータ発現評価する &lt;code&gt;&quot;less than&quot;&lt;/code&gt; と、それ以外の場合は文字列に評価 &lt;code&gt;&quot;not less than&quot;&lt;/code&gt; 。元の3方向の例では、3項演算子の複数の使用をチェーン化する必要があります。</target>
        </trans-unit>
        <trans-unit id="c1992d697b66c6b6347599acbdb8e5fdb9a6621c" translate="yes" xml:space="preserve">
          <source>If the first argument is a single integer &lt;code&gt;n&lt;/code&gt;, then all block rows are assumed to have &lt;code&gt;n&lt;/code&gt; block columns.</source>
          <target state="translated">最初の引数が単一の整数 &lt;code&gt;n&lt;/code&gt; の場合、すべてのブロック行は &lt;code&gt;n&lt;/code&gt; 個のブロック列を持っていると見なされます。</target>
        </trans-unit>
        <trans-unit id="39c79a9397806971d24321842119edaddb016dad" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;false&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;true&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">入力に&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;値が含まれている場合、すべての非欠損値が &lt;code&gt;false&lt;/code&gt; の場合（または、入力に &lt;code&gt;true&lt;/code&gt; 値が含まれていない場合）は、&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3つの値のロジック&lt;/a&gt;に従って、 &lt;code&gt;missing&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="5db00182f423a4757b1d59390942e088eaf24587" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;true&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;false&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">入力に&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;値が含まれている場合、&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3つの値のロジック&lt;/a&gt;に従って、欠損値以外の値がすべて &lt;code&gt;true&lt;/code&gt; の場合（または、入力に &lt;code&gt;false&lt;/code&gt; 値が含まれていない場合）は、 &lt;code&gt;missing&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="8eeb9c03396e664e28a99fc47d48774045eb6d62" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;false&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;true&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">入力に&lt;a href=&quot;base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;値が含まれている場合、すべての非欠損値が &lt;code&gt;false&lt;/code&gt; の場合（または、入力に &lt;code&gt;true&lt;/code&gt; 値が含まれていない場合）は、&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3つの値のロジック&lt;/a&gt;に従って、 &lt;code&gt;missing&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="2728419995e95b64eb82cdbd209797e56617a7a2" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;true&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;false&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">入力に&lt;a href=&quot;base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;値が含まれている場合、&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3つの値のロジック&lt;/a&gt;に従って、欠損値以外の値がすべて &lt;code&gt;true&lt;/code&gt; の場合（または、入力に &lt;code&gt;false&lt;/code&gt; 値が含まれていない場合）は、 &lt;code&gt;missing&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="43376b031124803be76025ed520e15accd07f21d" translate="yes" xml:space="preserve">
          <source>If the julia program needs to access symbols from the main executable, it may be necessary to add &lt;code&gt;-Wl,--export-dynamic&lt;/code&gt; linker flag at compile time on Linux in addition to the ones generated by &lt;code&gt;julia-config.jl&lt;/code&gt; described below. This is not necessary when compiling a shared library.</source>
          <target state="translated">juliaプログラムがメインの実行可能ファイルからシンボルにアクセスする必要がある場合は、以下で説明する &lt;code&gt;julia-config.jl&lt;/code&gt; によって生成されるものに加えて、Linuxでのコンパイル時に &lt;code&gt;-Wl,--export-dynamic&lt;/code&gt; リンカーフラグを追加する必要がある場合があります。共有ライブラリをコンパイルする場合、これは必要ありません。</target>
        </trans-unit>
        <trans-unit id="a36bc8b8e7c85e66ed4f1f189a3aca52b1c00920" translate="yes" xml:space="preserve">
          <source>If the keyword argument &lt;code&gt;parallel&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;peakflops&lt;/code&gt; is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument &lt;code&gt;n&lt;/code&gt; still refers to the size of the problem that is solved on each processor.</source>
          <target state="translated">キーワード引数 &lt;code&gt;parallel&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; に設定されている場合、 &lt;code&gt;peakflops&lt;/code&gt; はすべてのワーカープロセッサーで並列に実行されます。並列コンピュータ全体のフロップレートが返されます。並列実行の場合、使用されるBLASスレッドは1つだけです。引数 &lt;code&gt;n&lt;/code&gt; は、各プロセッサで解決される問題のサイズを引き続き参照します。</target>
        </trans-unit>
        <trans-unit id="8e60aaeb2ffed3f0c824ded63844d08244a81e67" translate="yes" xml:space="preserve">
          <source>If the last component of a path contains a dot, split the path into everything before the dot and everything including and after the dot. Otherwise, return a tuple of the argument unmodified and the empty string.</source>
          <target state="translated">パスの最後の構成要素にドットが含まれている場合、パスをドットの前の全てとドットを含む全てとドットの後の全てに分割します。そうでない場合は、引数の変更されていないタプルと空の文字列を返します。</target>
        </trans-unit>
        <trans-unit id="474f41b19a8b8b1c73bfdf0eee429dd261cef652" translate="yes" xml:space="preserve">
          <source>If the library cannot be found, this method throws an error, unless the keyword argument &lt;code&gt;throw_error&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;, in which case this method returns &lt;code&gt;nothing&lt;/code&gt;.</source>
          <target state="translated">ライブラリが見つからない場合、キーワード引数 &lt;code&gt;throw_error&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; に設定されていない限り、このメソッドはエラーをスローします。この場合、このメソッドは &lt;code&gt;nothing&lt;/code&gt; 返しません。</target>
        </trans-unit>
        <trans-unit id="87fd4485b83cceeff36ce0886165792add3d72c0" translate="yes" xml:space="preserve">
          <source>If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal situation and terminates. This timeout can be controlled via environment variable &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt;. The value of &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; on the master process specifies the number of seconds a newly launched worker waits for connection establishment.</source>
          <target state="translated">マスタープロセスが60.0秒以内に新しく起動されたワーカーとの接続を確立できない場合、ワーカーはそれを致命的な状況として扱い、終了します。このタイムアウトは、環境変数 &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; を介して制御できます。マスタープロセスの &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; の値は、新しく起動されたワーカーが接続の確立を待機する秒数を指定します。</target>
        </trans-unit>
        <trans-unit id="1862e9ef97d71a1468775f4ed8202c8fd632c055" translate="yes" xml:space="preserve">
          <source>If the memory is already owned by Julia, or is an &lt;code&gt;isbits&lt;/code&gt; type, and is known to be non-null:</source>
          <target state="translated">メモリがJuliaによって既に所有されているか、 &lt;code&gt;isbits&lt;/code&gt; タイプであり、nullでないことがわかっている場合：</target>
        </trans-unit>
        <trans-unit id="da0b487002a4f8f988224bf9329d865f41bc0778" translate="yes" xml:space="preserve">
          <source>If the memory is owned by C:</source>
          <target state="translated">メモリがCのものであれば</target>
        </trans-unit>
        <trans-unit id="f1a7911f936ea8810a1eaa7a8869f8e6799d2d65" translate="yes" xml:space="preserve">
          <source>If the numerator and denominator of a rational have common factors, they are reduced to lowest terms such that the denominator is non-negative:</source>
          <target state="translated">有理数の分子と分母が共通因子を持つ場合、分母が非負になるように最低項に還元されます。</target>
        </trans-unit>
        <trans-unit id="0a769d477ab736aacb751c850c5686d3d0e58a61" translate="yes" xml:space="preserve">
          <source>If the optional vector of eigenvalues &lt;code&gt;eigvals&lt;/code&gt; is specified, &lt;code&gt;eigvecs&lt;/code&gt; returns the specific corresponding eigenvectors.</source>
          <target state="translated">固有値 &lt;code&gt;eigvals&lt;/code&gt; のオプションのベクトルが指定されている場合、 &lt;code&gt;eigvecs&lt;/code&gt; は特定の対応する固有ベクトルを返します。</target>
        </trans-unit>
        <trans-unit id="0f4dba4502da69dc32bb858b6da003d9801f45e4" translate="yes" xml:space="preserve">
          <source>If the pointer of interest is a plain-data array (primitive type or immutable struct), the function &lt;code&gt;unsafe_wrap(Array, ptr,dims, own = false)&lt;/code&gt; may be more useful. The final parameter should be true if Julia should &quot;take ownership&quot; of the underlying buffer and call &lt;code&gt;free(ptr)&lt;/code&gt; when the returned &lt;code&gt;Array&lt;/code&gt; object is finalized. If the &lt;code&gt;own&lt;/code&gt; parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.</source>
          <target state="translated">対象のポインターがプレーンデータ配列（プリミティブ型または不変の構造体）である場合、関数 &lt;code&gt;unsafe_wrap(Array, ptr,dims, own = false)&lt;/code&gt; 方が便利な場合があります。Juliaが基になるバッファーの「所有権を取得」し、返された &lt;code&gt;Array&lt;/code&gt; オブジェクトがファイナライズされるときに &lt;code&gt;free(ptr)&lt;/code&gt; を呼び出す必要がある場合、最後のパラメーターはtrueである必要があります。場合は &lt;code&gt;own&lt;/code&gt; パラメータを省略またはfalseているすべてのアクセスが完了するまで、呼び出し側が存在し、バッファの遺骨を確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="0a512e781dfe335955a62e8e7a271098861da5ec" translate="yes" xml:space="preserve">
          <source>If the project file in the directory matches &lt;code&gt;uuid&lt;/code&gt; and name &lt;code&gt;X&lt;/code&gt;, then either:</source>
          <target state="translated">ディレクトリ内のプロジェクトファイルが &lt;code&gt;uuid&lt;/code&gt; および名前 &lt;code&gt;X&lt;/code&gt; と一致する場合、次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="bf4eb78a003bcabdcd8e4f19b55a5c4f0ed307f6" translate="yes" xml:space="preserve">
          <source>If the regular expression does not match the given string, &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; &amp;ndash; a special value that does not print anything at the interactive prompt. Other than not printing, it is a completely normal value and you can test for it programmatically:</source>
          <target state="translated">正規表現が指定された文字列と&lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;しない場合、matchは&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;返しません。対話型プロンプトでは何も出力しない特別な値です。印刷しないことを除いて、これは完全に通常の値であり、プログラムでテストできます。</target>
        </trans-unit>
        <trans-unit id="ee4c72df00bad1d261a873768e4600ba229c34af" translate="yes" xml:space="preserve">
          <source>If the type were declared &lt;code&gt;mutable&lt;/code&gt;, you could reach in and directly change the field values to violate this invariant. Of course, messing around with an object's internals uninvited is bad practice. You (or someone else) can also provide additional outer constructor methods at any later point, but once a type is declared, there is no way to add more inner constructor methods. Since outer constructor methods can only create objects by calling other constructor methods, ultimately, some inner constructor must be called to create an object. This guarantees that all objects of the declared type must come into existence by a call to one of the inner constructor methods provided with the type, thereby giving some degree of enforcement of a type's invariants.</source>
          <target state="translated">型が &lt;code&gt;mutable&lt;/code&gt; と宣言されている場合は、フィールド値にアクセスして直接変更し、この不変条件に違反する可能性があります。もちろん、招待されていないオブジェクトの内部をいじるのは悪い習慣です。あなた（または他の誰か）は後から追加の外部コンストラクターメソッドを提供することもできますが、型が宣言されると、内部コンストラクターメソッドを追加する方法はありません。外部コンストラクターメソッドは他のコンストラクターメソッドを呼び出すことによってのみオブジェクトを作成できるため、最終的には、オブジェクトを作成するためにいくつかの内部コンストラクターを呼び出す必要があります。これにより、宣言された型のすべてのオブジェクトが、その型で提供される内部コンストラクターメソッドの1つを呼び出すことによって必ず存在するようになり、型の不変条件がある程度適用されます。</target>
        </trans-unit>
        <trans-unit id="01f0d92fa173f69330393a510ea1e6b5d8ca8533" translate="yes" xml:space="preserve">
          <source>If the value of the environment variable begins with the character &lt;code&gt;'r'&lt;/code&gt;, then the interval between garbage collection events is randomized.</source>
          <target state="translated">環境変数の値が文字 &lt;code&gt;'r'&lt;/code&gt; で始まる場合、ガベージコレクションイベントの間隔はランダム化されます。</target>
        </trans-unit>
        <trans-unit id="820aaeab0441978d6dfdcb42b5456e2d42286bc7" translate="yes" xml:space="preserve">
          <source>If the variable is immutable, then it needs to be wrapped in an equivalent mutable container or, preferably, in a &lt;code&gt;RefValue{Any}&lt;/code&gt; before it is pushed to &lt;code&gt;IdDict&lt;/code&gt;. In this approach, the container has to be created or filled in via C code using, for example, the function &lt;code&gt;jl_new_struct&lt;/code&gt;. If the container is created by &lt;code&gt;jl_call*&lt;/code&gt;, then you will need to reload the pointer to be used in C code.</source>
          <target state="translated">変数が不変の場合、それを &lt;code&gt;IdDict&lt;/code&gt; にプッシュする前に、同等の可変コンテナー、またはできれ &lt;code&gt;RefValue{Any}&lt;/code&gt; にラップする必要があります。このアプローチでは、コンテナーは、たとえば関数 &lt;code&gt;jl_new_struct&lt;/code&gt; を使用して、Cコードを介して作成または入力する必要があります。コンテナーが &lt;code&gt;jl_call*&lt;/code&gt; によって作成された場合、Cコードで使用されるポインターを再ロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="fdaae9a23c5ac63bef99dbd5a31ebb51593f593b" translate="yes" xml:space="preserve">
          <source>If these default definitions are not wanted, modules can be defined using the keyword &lt;a href=&quot;../../base/base/index#baremodule&quot;&gt;&lt;code&gt;baremodule&lt;/code&gt;&lt;/a&gt; instead (note: &lt;code&gt;Core&lt;/code&gt; is still imported, as per above). In terms of &lt;code&gt;baremodule&lt;/code&gt;, a standard &lt;code&gt;module&lt;/code&gt; looks like this:</source>
          <target state="translated">これらのデフォルト定義が&lt;a href=&quot;../../base/base/index#baremodule&quot;&gt; &lt;code&gt;baremodule&lt;/code&gt; &lt;/a&gt;場合は、代わりにキーワードbaremoduleを使用してモジュールを定義できます（注：上記のように、 &lt;code&gt;Core&lt;/code&gt; は引き続きインポートされます）。 &lt;code&gt;baremodule&lt;/code&gt; に関しては、標準 &lt;code&gt;module&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="c97bc8058490cb5b35c86c1a7b0a8b4a5dcbea0d" translate="yes" xml:space="preserve">
          <source>If this example were rewritten to use a &lt;code&gt;for&lt;/code&gt; keyword for each variable, then the output would be different: the second and fourth values would contain &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">この例が各変数に &lt;code&gt;for&lt;/code&gt; キーワードを使用するように書き直された場合、出力は異なります。2番目と4番目の値には &lt;code&gt;0&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="38daf5829da47e0525cef7ca98a723264df0b06d" translate="yes" xml:space="preserve">
          <source>If this file refers to a device, the ID of the device it refers to</source>
          <target state="translated">このファイルがデバイスを参照している場合は、参照しているデバイスのID</target>
        </trans-unit>
        <trans-unit id="0d9cafaaf4c7067eb590c8bf606a63edc65e8a80" translate="yes" xml:space="preserve">
          <source>If this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.</source>
          <target state="translated">これが以前に取得した再帰的なロックであれば、内部カウンタをデクリメントしてすぐに戻ります。</target>
        </trans-unit>
        <trans-unit id="63b7f441c98451c302d3c2456a6e97efda6509d1" translate="yes" xml:space="preserve">
          <source>If this is all extremely confusing, try reading &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;&quot;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets&quot;&lt;/a&gt;. It's an excellent introduction to Unicode and UTF-8, and may help alleviate some confusion regarding the matter.</source>
          <target state="translated">これがすべて非常に混乱する場合は、&lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;「すべてのソフトウェア開発者の絶対最小&lt;/a&gt;値は絶対に、確実にUnicodeと文字セットについて知っておく必要がある」を読んでみてください。これは、UnicodeとUTF-8の優れた入門書であり、この問題に関する混乱を軽減するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="3b40c130d40171e44a3b89ef397dcc6ac5ad60b6" translate="yes" xml:space="preserve">
          <source>If unspecified, &lt;code&gt;rmprocs&lt;/code&gt; will wait until all requested &lt;code&gt;pids&lt;/code&gt; are removed.</source>
          <target state="translated">指定しない場合、 &lt;code&gt;rmprocs&lt;/code&gt; は要求されたすべての &lt;code&gt;pids&lt;/code&gt; が削除されるまで待機します。</target>
        </trans-unit>
        <trans-unit id="7a6ee4e75683acdd450d6763b02459999f504699" translate="yes" xml:space="preserve">
          <source>If we also wanted to test the debug messages, these need to be enabled with the &lt;code&gt;min_level&lt;/code&gt; keyword:</source>
          <target state="translated">デバッグメッセージもテストする場合は、 &lt;code&gt;min_level&lt;/code&gt; キーワードを使用してこれらを有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="61986d68f0f6799ea1176f1c31636a4efe0c3579" translate="yes" xml:space="preserve">
          <source>If we create &lt;code&gt;SharedArray&lt;/code&gt;s and time these functions, we get the following results (with &lt;code&gt;julia -p 4&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;SharedArray&lt;/code&gt; を作成してこれらの関数の時間を計測すると、次の結果が得られます（ &lt;code&gt;julia -p 4&lt;/code&gt; を使用）。</target>
        </trans-unit>
        <trans-unit id="a1227c57ad13fa72c3a7892e71df86ffd4baf6f1" translate="yes" xml:space="preserve">
          <source>If we expect that evaluating an expression &lt;em&gt;should&lt;/em&gt; throw an exception, then we can use &lt;code&gt;@test_throws&lt;/code&gt; to check that this occurs:</source>
          <target state="translated">式を評価すると例外&lt;em&gt;が&lt;/em&gt;スローされると予想される場合は、 &lt;code&gt;@test_throws&lt;/code&gt; を使用して、これが発生することを確認できます。</target>
        </trans-unit>
        <trans-unit id="0245cafc71ed8d5f923ae289b03588ae96f1d3b5" translate="yes" xml:space="preserve">
          <source>If we instead pass &lt;code&gt;x&lt;/code&gt; as an argument to the function it no longer allocates memory (the allocation reported below is due to running the &lt;code&gt;@time&lt;/code&gt; macro in global scope) and is significantly faster after the first call:</source>
          <target state="translated">代わりに &lt;code&gt;x&lt;/code&gt; を関数の引数として渡すと、メモリは割り当てられなくなり（以下に報告されている割り当てはグローバルスコープで &lt;code&gt;@time&lt;/code&gt; マクロを実行したことが原因です）、最初の呼び出し後の速度が大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="ad5a88256f096da52ec6c3ef7cb82d3f97728f34" translate="yes" xml:space="preserve">
          <source>If we want it to display instead as &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt;, we would define the following method to print the object to a given output object &lt;code&gt;io&lt;/code&gt; (representing a file, terminal, buffer, etcetera; see &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams-1&quot;&gt;Networking and Streams&lt;/a&gt;):</source>
          <target state="translated">代わりに &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt; として表示する場合は、次のメソッドを定義して、オブジェクトを特定の出力オブジェクト &lt;code&gt;io&lt;/code&gt; （ファイル、端末、バッファーなどを表す）に出力します。&lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams-1&quot;&gt;ネットワーキングとストリームを&lt;/a&gt;参照してください）。</target>
        </trans-unit>
        <trans-unit id="a3d5a08a0cd3e04540689d3b049bf572b10229ab" translate="yes" xml:space="preserve">
          <source>If you apply &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt;&lt;code&gt;supertype&lt;/code&gt;&lt;/a&gt; to other type objects (or non-type objects), a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; is raised:</source>
          <target state="translated">あなたが適用された場合は&lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt; &lt;code&gt;supertype&lt;/code&gt; &lt;/a&gt;他のタイプのオブジェクト（または非型オブジェクト）に、&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; が&lt;/a&gt;提起されています。</target>
        </trans-unit>
        <trans-unit id="a311e1352bca4f5ac56973ae4e9111089c7fd93d" translate="yes" xml:space="preserve">
          <source>If you are defining a method &quot;cascade&quot; that supplies defaults, be careful about dropping any arguments that correspond to potential defaults. For example, suppose you're writing a digital filtering algorithm and you have a method that handles the edges of the signal by applying padding:</source>
          <target state="translated">デフォルトを提供するメソッド「カスケード」を定義している場合、潜在的なデフォルトに対応する引数を削除することに注意してください。例えば、デジタルフィルタリングアルゴリズムを書いていて、パディングを適用して信号のエッジを処理するメソッドがあるとします。</target>
        </trans-unit>
        <trans-unit id="1ec45be5f3cad18e0598bb550f7ab8781aa51939" translate="yes" xml:space="preserve">
          <source>If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize &lt;code&gt;axes&lt;/code&gt;. You should also specialize &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; so that the &lt;code&gt;dims&lt;/code&gt; argument (ordinarily a &lt;code&gt;Dims&lt;/code&gt; size-tuple) can accept &lt;code&gt;AbstractUnitRange&lt;/code&gt; objects, perhaps range-types &lt;code&gt;Ind&lt;/code&gt; of your own design. For more information, see &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;Arrays with custom indices&lt;/a&gt;.</source>
          <target state="translated">従来とは異なるインデックス付けを可能にする配列タイプ（1以外のインデックスで始まるインデックス）を定義している場合は、 &lt;code&gt;axes&lt;/code&gt; を特殊化する必要があります。 &lt;code&gt;dims&lt;/code&gt; 引数（通常は &lt;code&gt;Dims&lt;/code&gt; のサイズタプル）が &lt;code&gt;AbstractUnitRange&lt;/code&gt; オブジェクト（おそらく、独自の設計の範囲型 &lt;code&gt;Ind&lt;/code&gt; ）を受け入れることができるように、&lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt;ものを特殊化する必要もあります。詳細については、「&lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;カスタムインデックスを持つ配列」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e74f29b3463d83a18c14379e83918c00f3cf63aa" translate="yes" xml:space="preserve">
          <source>If you are ever stuck, you can ask &lt;code&gt;Pkg&lt;/code&gt; for help:</source>
          <target state="translated">行き詰まっている場合は、 &lt;code&gt;Pkg&lt;/code&gt; に助けを求めることができます。</target>
        </trans-unit>
        <trans-unit id="8735c4e810f6e4e3ffda27e1b3f1ab39f60104c6" translate="yes" xml:space="preserve">
          <source>If you are using the Julia C API from a language that supports exceptions (e.g. Python, C#, C++), it makes sense to wrap each call into &lt;code&gt;libjulia&lt;/code&gt; with a function that checks whether an exception was thrown, and then rethrows the exception in the host language.</source>
          <target state="translated">例外をサポートする言語（Python、C＃、C ++など）からJulia C APIを使用している場合は、各呼び出しを &lt;code&gt;libjulia&lt;/code&gt; にラップして、例外がスローされたかどうかをチェックし、例外をホスト言語。</target>
        </trans-unit>
        <trans-unit id="9d33189460471265e09a2493a0c7846b4727b27d" translate="yes" xml:space="preserve">
          <source>If you call it in an interactive session without assigning the return value anywhere, you will see the tuple returned:</source>
          <target state="translated">戻り値をどこにも代入せずに対話型セッションで呼び出すと、返されたタプルが表示されます。</target>
        </trans-unit>
        <trans-unit id="757e93c7d7c03576f2e8bdb2961d5a609265324d" translate="yes" xml:space="preserve">
          <source>If you define both styles of indexing for your &lt;code&gt;AbstractArray&lt;/code&gt;, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; creates an iterator whose type depends on the setting of this trait.</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; に両方のインデックススタイルを定義すると、このトレイトを使用して、最もパフォーマンスの高いインデックススタイルを選択できます。一部のメソッドは、入力でこの特性をチェックし、最も効率的なアクセスパターンに応じて異なるアルゴリズムにディスパッチします。特に、&lt;a href=&quot;#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt;はタイプがこのトレイトの設定に依存するイテレータを作成します。</target>
        </trans-unit>
        <trans-unit id="0561f634340ef3ef5927debe41e5dcc4c8cce30a" translate="yes" xml:space="preserve">
          <source>If you examine the contents of &lt;code&gt;hello.txt&lt;/code&gt; at this point, you will notice that it is empty; nothing has actually been written to disk yet. This is because the &lt;code&gt;IOStream&lt;/code&gt; must be closed before the write is actually flushed to disk:</source>
          <target state="translated">この時点で &lt;code&gt;hello.txt&lt;/code&gt; の内容を確認すると、内容が空であることがわかります。実際にはまだ何もディスクに書き込まれていません。これは、書き込みが実際にディスクにフラッシュされる前に &lt;code&gt;IOStream&lt;/code&gt; を閉じる必要があるためです。</target>
        </trans-unit>
        <trans-unit id="4eaa143836add2b691eb62610bcaeb5c4d609829" translate="yes" xml:space="preserve">
          <source>If you have a type that uses a native pointer:</source>
          <target state="translated">ネイティブポインタを使用する型を持っている場合。</target>
        </trans-unit>
        <trans-unit id="aaf9e1541b4bdb0c52c8f375b573b49db90dd938" translate="yes" xml:space="preserve">
          <source>If you have code that you want executed whenever Julia is run, you can put it in &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">Juliaを実行するたびに実行するコードがある場合は、それを &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; 配置できます。</target>
        </trans-unit>
        <trans-unit id="c6993e56b8a3ed1437873eaf20d58be9dd8dc4fb" translate="yes" xml:space="preserve">
          <source>If you have data in CSC format from a different application or library, and wish to import it in Julia, make sure that you use 1-based indexing. The row indices in every column need to be sorted. If your &lt;code&gt;SparseMatrixCSC&lt;/code&gt; object contains unsorted row indices, one quick way to sort them is by doing a double transpose.</source>
          <target state="translated">別のアプリケーションまたはライブラリからCSC形式のデータがあり、それをJuliaにインポートする場合は、1から始まるインデックスを使用してください。すべての列の行インデックスをソートする必要があります。 &lt;code&gt;SparseMatrixCSC&lt;/code&gt; オブジェクトに並べ替えられていない行インデックスが含まれている場合、それらを並べ替える1つの簡単な方法は、二重転置を行うことです。</target>
        </trans-unit>
        <trans-unit id="be1012643129d3902e3bcc736a2f09368b135cc7" translate="yes" xml:space="preserve">
          <source>If you interpolate an array as part of a shell word, Julia emulates the shell's &lt;code&gt;{a,b,c}&lt;/code&gt; argument generation:</source>
          <target state="translated">シェルワードの一部として配列を補間する場合、ジュリアはシェルの &lt;code&gt;{a,b,c}&lt;/code&gt; 引数生成をエミュレートします。</target>
        </trans-unit>
        <trans-unit id="66c0ea7806057d283c6cb2263bc03f2b5f51cca2" translate="yes" xml:space="preserve">
          <source>If you know that a module is &lt;em&gt;not&lt;/em&gt; safe to precompile your module (for example, for one of the reasons described below), you should put &lt;code&gt;__precompile__(false)&lt;/code&gt; in the module file (typically placed at the top). This will cause &lt;code&gt;Base.compilecache&lt;/code&gt; to throw an error, and will cause &lt;code&gt;using&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; to load it directly into the current process and skip the precompile and caching. This also thereby prevents the module from being imported by any other precompiled module.</source>
          <target state="translated">モジュールがモジュールをプリコンパイルするのに安全で&lt;em&gt;ない&lt;/em&gt;ことがわかっている場合（たとえば、以下に説明する理由の1 &lt;code&gt;__precompile__(false)&lt;/code&gt; ）、__ precompile __（false）をモジュールファイル（通常は上部に配置）に配置する必要があります。これにより、 &lt;code&gt;Base.compilecache&lt;/code&gt; がエラーをスローし、/ &lt;code&gt;import&lt;/code&gt; を &lt;code&gt;using&lt;/code&gt; して現在のプロセスに直接ロードし、プリコンパイルとキャッシュをスキップします。これにより、モジュールが他のプリコンパイル済みモジュールによってインポートされることも防止されます。</target>
        </trans-unit>
        <trans-unit id="9119dc7e0716f5e2cbcc069fcd20399d5871b899" translate="yes" xml:space="preserve">
          <source>If you need to dispatch on multiple arguments, and there are many fallbacks with too many combinations to make it practical to define all possible variants, then consider introducing a &quot;name cascade&quot; where (for example) you dispatch on the first argument and then call an internal method:</source>
          <target state="translated">複数の引数でディスパッチする必要があり、可能なすべてのバリエーションを定義するのが実用的ではないほど多くの組み合わせのフォールバックがある場合は、(例えば)最初の引数でディスパッチしてから内部メソッドを呼び出す &quot;名前のカスケード &quot;の導入を検討してみてください。</target>
        </trans-unit>
        <trans-unit id="76f3bebbfec4cfb424affa402369c33eff6a7949" translate="yes" xml:space="preserve">
          <source>If you need to obtain valid indices for a string, you can use the &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt;&lt;code&gt;nextind&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/strings/index#Base.prevind&quot;&gt;&lt;code&gt;prevind&lt;/code&gt;&lt;/a&gt; functions to increment/decrement to the next/previous valid index, as mentioned above. You can also use the &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; function to iterate over the valid character indices:</source>
          <target state="translated">文字列の有効なインデックスを取得する必要がある場合は、&lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt; &lt;code&gt;nextind&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/strings/index#Base.prevind&quot;&gt; &lt;code&gt;prevind&lt;/code&gt; &lt;/a&gt;関数とprevind関数を使用して、次の/前の有効なインデックスに増分または減分できます。&lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt;関数を使用して、有効な文字インデックスを反復処理することもできます。</target>
        </trans-unit>
        <trans-unit id="801f3bd6c180fb1f8c8c459f54a17ac585429686" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;code&gt;branch&lt;/code&gt;, this must be done in reference format, since the string will be turned into a &lt;code&gt;GitReference&lt;/code&gt;. For example, if you wanted to merge branch &lt;code&gt;branch_a&lt;/code&gt;, you would call &lt;code&gt;merge!(repo, branch=&quot;refs/heads/branch_a&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;branch&lt;/code&gt; を指定する場合、文字列は &lt;code&gt;GitReference&lt;/code&gt; に変換されるため、これは参照形式で行う必要があります。たとえば、ブランチ &lt;code&gt;branch_a&lt;/code&gt; をマージする場合は、 &lt;code&gt;merge!(repo, branch=&quot;refs/heads/branch_a&quot;)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="12b4daadf4d05ca4bd1781bb32cf57f260bb2750" translate="yes" xml:space="preserve">
          <source>If you supply more than one &lt;code&gt;AbstractArray&lt;/code&gt; argument, &lt;code&gt;eachindex&lt;/code&gt; will create an iterable object that is fast for all arguments (a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt; if all inputs have fast linear indexing, a &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt; otherwise). If the arrays have different sizes and/or dimensionalities, &lt;code&gt;eachindex&lt;/code&gt; will return an iterable that spans the largest range along each dimension.</source>
          <target state="translated">複数の &lt;code&gt;AbstractArray&lt;/code&gt; 引数を指定した場合、 &lt;code&gt;eachindex&lt;/code&gt; はすべての引数に対して高速な反復可能オブジェクトを作成します（すべての入力が高速線形インデックスの場合は&lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt; &lt;code&gt;UnitRange&lt;/code&gt; &lt;/a&gt;、それ以外の場合は&lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt;）。配列のサイズや次元が異なる場合、 &lt;code&gt;eachindex&lt;/code&gt; は各次元に沿った最大範囲にわたる反復可能オブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="0bf64552bec6648b4a2dbc60f5636537b6e39be4" translate="yes" xml:space="preserve">
          <source>If you want a quantity that is of the same type as &lt;code&gt;x&lt;/code&gt;, or of type &lt;code&gt;T&lt;/code&gt;, even if &lt;code&gt;x&lt;/code&gt; is dimensionful, use &lt;a href=&quot;#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と同じ型または &lt;code&gt;T&lt;/code&gt; 型の数量が必要な場合、 &lt;code&gt;x&lt;/code&gt; が次元数であっても、代わりに&lt;a href=&quot;#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="0d6bdd166c95ac54bc84be65e3c70b26b5a5d3fc" translate="yes" xml:space="preserve">
          <source>If you want to &lt;em&gt;avoid&lt;/em&gt; adding dots for selected function calls in &lt;code&gt;expr&lt;/code&gt;, splice those function calls in with &lt;code&gt;$&lt;/code&gt;. For example, &lt;code&gt;@. sqrt(abs($sort(x)))&lt;/code&gt; is equivalent to &lt;code&gt;sqrt.(abs.(sort(x)))&lt;/code&gt; (no dot for &lt;code&gt;sort&lt;/code&gt;).</source>
          <target state="translated">あなたがしたい場合は&lt;em&gt;避ける&lt;/em&gt;における選択された関数呼び出しのためのドットを追加 &lt;code&gt;expr&lt;/code&gt; の、とスプライスこれらの関数呼び出し &lt;code&gt;$&lt;/code&gt; を。たとえば、 &lt;code&gt;@. sqrt(abs($sort(x)))&lt;/code&gt; と等価である &lt;code&gt;sqrt.(abs.(sort(x)))&lt;/code&gt; 無ドットのための &lt;code&gt;sort&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="683a65524138ed99d613028444b793379d0ca4fd" translate="yes" xml:space="preserve">
          <source>If you want to extract a character from a string, you index into it:</source>
          <target state="translated">文字列から文字を抽出したい場合は、その文字列にインデックスを付けます。</target>
        </trans-unit>
        <trans-unit id="af6bdcdecfb445706192e5de8fd952192d9e2d0e" translate="yes" xml:space="preserve">
          <source>If you want to read the output of the external command, &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; can be used instead:</source>
          <target state="translated">外部コマンドの出力を読みたい場合は、代わりに&lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="66677df9764417ef6a9289f8e4f6bf8274c36caa" translate="yes" xml:space="preserve">
          <source>If you want to use logging as an audit trail you should disable this for your logger type.</source>
          <target state="translated">監査証跡としてロギングを使用したい場合は、ロガー タイプでこれを無効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="e7c7d63501e2b9d2d6b42831c4f6216f8a461efd" translate="yes" xml:space="preserve">
          <source>If you want to write to a file, you can open it with the write (&lt;code&gt;&quot;w&quot;&lt;/code&gt;) flag:</source>
          <target state="translated">ファイルに書き込みたい場合は、書き込み（ &lt;code&gt;&quot;w&quot;&lt;/code&gt; ）フラグを使用してファイルを開くことができます。</target>
        </trans-unit>
        <trans-unit id="c3b03f51e5a4a15df40aa0cdfd2977b041193157" translate="yes" xml:space="preserve">
          <source>If you were to profile &lt;code&gt;dumbsum3&lt;/code&gt;, and a backtrace was taken while it was executing &lt;code&gt;dumbsum(1)&lt;/code&gt;, the backtrace would look like this:</source>
          <target state="translated">&lt;code&gt;dumbsum3&lt;/code&gt; をプロファイルし、 &lt;code&gt;dumbsum(1)&lt;/code&gt; の実行中にバックトレースが取得された場合、バックトレースは次のようになります。</target>
        </trans-unit>
        <trans-unit id="0bc4f596ffa41c5fb93ede00ad1673e3a89c26be" translate="yes" xml:space="preserve">
          <source>If you wish to specialize on a particular style &lt;code&gt;DestStyle&lt;/code&gt;, define a method for</source>
          <target state="translated">特定のスタイル &lt;code&gt;DestStyle&lt;/code&gt; に特化したい場合は、</target>
        </trans-unit>
        <trans-unit id="f81fa178f278896f499b8c79cc33cce8975b52ac" translate="yes" xml:space="preserve">
          <source>If you write a custom &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt; type, you can specify that it has fast linear indexing using</source>
          <target state="translated">カスタムの&lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt;型を作成する場合、次のコマンドを使用して、高速な線形インデックスを指定できます。</target>
        </trans-unit>
        <trans-unit id="731e84cb8afd8370c60140146ac6c2a5c345b233" translate="yes" xml:space="preserve">
          <source>If you write generic code which handles numbers, and which can be expected to run with many different numeric type arguments, try using literals of a numeric type that will affect the arguments as little as possible through promotion.</source>
          <target state="translated">数値を扱う汎用的なコードを書く場合で、多くの異なる数値型の引数での実行が予想される場合は、プロモーションによって引数にできるだけ影響を与えないような数値型のリテラルを使ってみてください。</target>
        </trans-unit>
        <trans-unit id="dcea13c507e05364e2e2a422c4d4bb092770bc50" translate="yes" xml:space="preserve">
          <source>If your array type does have fixed dimensionality requirements, then you should subtype &lt;code&gt;AbstractArrayStyle&lt;/code&gt;. For example, the sparse array code has the following definitions:</source>
          <target state="translated">配列型に固定次元要件がある場合は、 &lt;code&gt;AbstractArrayStyle&lt;/code&gt; をサブタイプする必要があります。たとえば、スパース配列コードには次の定義があります。</target>
        </trans-unit>
        <trans-unit id="86e175e64e8da6c7e916078c1c6ea2b5a935db82" translate="yes" xml:space="preserve">
          <source>If your code has recursion, one potentially-confusing point is that a line in a &quot;child&quot; function can accumulate more counts than there are total backtraces. Consider the following function definitions:</source>
          <target state="translated">コードに再帰性がある場合、「子」関数の行は、バックトレースの総数よりも多くのカウントを蓄積することができるという点で、混乱を招く可能性があります。以下の関数定義を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="aa3f9be2eca1806a6c02bd56dca6f747bcc2726c" translate="yes" xml:space="preserve">
          <source>If your function returns an &lt;code&gt;Array&lt;/code&gt; or some other complex type, it may have to allocate memory. Unfortunately, oftentimes allocation and its converse, garbage collection, are substantial bottlenecks.</source>
          <target state="translated">関数が &lt;code&gt;Array&lt;/code&gt; またはその他の複合型を返す場合、メモリを割り当てる必要がある場合があります。残念ながら、割り当てとその逆のガベージコレクションは、かなりのボトルネックになることがよくあります。</target>
        </trans-unit>
        <trans-unit id="203770fc43c2ec3f449524fb36ddffdf662a89aa" translate="yes" xml:space="preserve">
          <source>If, on the other hand, Julia was loading the &lt;em&gt;other&lt;/em&gt;&lt;code&gt;Priv&lt;/code&gt; package&amp;mdash;the one with UUID &lt;code&gt;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&lt;/code&gt;&amp;mdash;it finds its stanza in the manifest, see that it does &lt;em&gt;not&lt;/em&gt; have a &lt;code&gt;path&lt;/code&gt; entry, but that it does have a &lt;code&gt;git-tree-sha1&lt;/code&gt; entry. It then computes the &lt;code&gt;slug&lt;/code&gt; for this UUID/SHA-1 pair, which is &lt;code&gt;HDkrT&lt;/code&gt; (the exact details of this computation aren't important, but it is consistent and deterministic). This means that the path to this &lt;code&gt;Priv&lt;/code&gt; package will be &lt;code&gt;packages/Priv/HDkrT/src/Priv.jl&lt;/code&gt; in one of the package depots. Suppose the contents of &lt;code&gt;DEPOT_PATH&lt;/code&gt; is &lt;code&gt;[&quot;/home/me/.julia&quot;, &quot;/usr/local/julia&quot;]&lt;/code&gt;, then Julia will look at the following paths to see if they exist:</source>
          <target state="translated">一方、Juliaが&lt;em&gt;他の&lt;/em&gt; &lt;code&gt;Priv&lt;/code&gt; パッケージ（UUID &lt;code&gt;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&lt;/code&gt; を含むもの)をロードしていた&lt;em&gt;場合&lt;/em&gt;、マニフェストにそのスタンザが見つかった&lt;em&gt;場合&lt;/em&gt;は、 &lt;code&gt;path&lt;/code&gt; エントリが&lt;em&gt;ない&lt;/em&gt;ことを確認してください。 &lt;code&gt;git-tree-sha1&lt;/code&gt; エントリはありません。次に、このUUID / SHA-1ペアの &lt;code&gt;slug&lt;/code&gt; を計算します。これは &lt;code&gt;HDkrT&lt;/code&gt; です（この計算の正確な詳細は重要ではありませんが、一貫していて確定的です）。つまり、この &lt;code&gt;Priv&lt;/code&gt; パッケージへのパスは、パッケージデポの1つにある &lt;code&gt;packages/Priv/HDkrT/src/Priv.jl&lt;/code&gt; になります。 &lt;code&gt;DEPOT_PATH&lt;/code&gt; の内容が &lt;code&gt;[&quot;/home/me/.julia&quot;, &quot;/usr/local/julia&quot;]&lt;/code&gt; 場合、Juliaは次のパスを調べて、それらが存在するかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="08884ba6d9fbd224895a7cbdeceeec1f4c59bf40" translate="yes" xml:space="preserve">
          <source>Image Of</source>
          <target state="translated">イメージ</target>
        </trans-unit>
        <trans-unit id="6ea4ebbef3751656124627e822bd05d7b6569f88" translate="yes" xml:space="preserve">
          <source>Image Of Or Approximately Equal To</source>
          <target state="translated">のイメージまたはそれにほぼ等しい</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="a1dd283e60c10a07da0fde84cdded35b0d62bc7f" translate="yes" xml:space="preserve">
          <source>Immediately run finalizers registered for object &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">オブジェクト &lt;code&gt;x&lt;/code&gt; に登録されているファイナライザをすぐに実行します。</target>
        </trans-unit>
        <trans-unit id="3f8a84e660062cc9351aa99e4736b44741ec8c96" translate="yes" xml:space="preserve">
          <source>Immutable composite types with no fields are singletons; there can be only one instance of such types:</source>
          <target state="translated">フィールドを持たない不変複合型はシングルトンです。</target>
        </trans-unit>
        <trans-unit id="546c2aff0baec3bbc325a5abd6340afd6a503d6d" translate="yes" xml:space="preserve">
          <source>ImmutableDict</source>
          <target state="translated">ImmutableDict</target>
        </trans-unit>
        <trans-unit id="4d5fca35f85700fe41f680f762e716a68cf32a0c" translate="yes" xml:space="preserve">
          <source>ImmutableDict is a Dictionary implemented as an immutable linked list, which is optimal for small dictionaries that are constructed over many individual insertions Note that it is not possible to remove a value, although it can be partially overridden and hidden by inserting a new value with the same key</source>
          <target state="translated">ImmutableDict は、不変リンクリストとして実装された辞書で、多数の個別挿入で構成された小さな辞書に最適です。</target>
        </trans-unit>
        <trans-unit id="5a205de46742b724da4bcd47864315bbfb29bffa" translate="yes" xml:space="preserve">
          <source>Imp</source>
          <target state="translated">Imp</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="91db407238f7692c5a1c288977c0c95bb564522e" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers using custom transports. It should establish a logical connection to worker with id &lt;code&gt;pid&lt;/code&gt;, specified by &lt;code&gt;config&lt;/code&gt; and return a pair of &lt;code&gt;IO&lt;/code&gt; objects. Messages from &lt;code&gt;pid&lt;/code&gt; to current process will be read off &lt;code&gt;instrm&lt;/code&gt;, while messages to be sent to &lt;code&gt;pid&lt;/code&gt; will be written to &lt;code&gt;outstrm&lt;/code&gt;. The custom transport implementation must ensure that messages are delivered and received completely and in order. &lt;code&gt;connect(manager::ClusterManager.....)&lt;/code&gt; sets up TCP/IP socket connections in-between workers.</source>
          <target state="translated">カスタムトランスポートを使用してクラスターマネージャーによって実装されます。 &lt;code&gt;config&lt;/code&gt; で指定されたID &lt;code&gt;pid&lt;/code&gt; のワーカーへの論理接続を確立し、 &lt;code&gt;IO&lt;/code&gt; オブジェクトのペアを返す必要があります。 &lt;code&gt;pid&lt;/code&gt; から現在のプロセスへのメッセージは &lt;code&gt;instrm&lt;/code&gt; から読み取られ、 &lt;code&gt;pid&lt;/code&gt; に送信されるメッセージは &lt;code&gt;outstrm&lt;/code&gt; に書き込まれます。カスタム転送の実装では、メッセージが完全かつ順序どおりに送受信されるようにする必要があります。 &lt;code&gt;connect(manager::ClusterManager.....)&lt;/code&gt; は、ワーカー間のTCP / IPソケット接続をセットアップします。</target>
        </trans-unit>
        <trans-unit id="08979f61f84f8ad3b659b0b75ccddbf1892ea3a4" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. For every Julia worker launched by this function, it should append a &lt;code&gt;WorkerConfig&lt;/code&gt; entry to &lt;code&gt;launched&lt;/code&gt; and notify &lt;code&gt;launch_ntfy&lt;/code&gt;. The function MUST exit once all workers, requested by &lt;code&gt;manager&lt;/code&gt; have been launched. &lt;code&gt;params&lt;/code&gt; is a dictionary of all keyword arguments &lt;a href=&quot;#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt; was called with.</source>
          <target state="translated">クラスターマネージャーによって実装されます。この関数によって起動されたすべてのJuliaワーカーについて、 &lt;code&gt;WorkerConfig&lt;/code&gt; エントリを &lt;code&gt;launched&lt;/code&gt; 追加し、launch_ntfyに通知する &lt;code&gt;launch_ntfy&lt;/code&gt; ます。この関数は、 &lt;code&gt;manager&lt;/code&gt; から要求されたすべてのワーカーが起動されたら終了する必要があります。 &lt;code&gt;params&lt;/code&gt; は、&lt;a href=&quot;#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt;が呼び出されたすべてのキーワード引数の辞書です。</target>
        </trans-unit>
        <trans-unit id="b5a68dbaa7e53b1fdc013e1b1b627c788dfd10b1" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. It is called on the master process, by &lt;a href=&quot;#Distributed.rmprocs&quot;&gt;&lt;code&gt;rmprocs&lt;/code&gt;&lt;/a&gt;. It should cause the remote worker specified by &lt;code&gt;pid&lt;/code&gt; to exit. &lt;code&gt;kill(manager::ClusterManager.....)&lt;/code&gt; executes a remote &lt;code&gt;exit()&lt;/code&gt; on &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">クラスターマネージャーによって実装されます。&lt;a href=&quot;#Distributed.rmprocs&quot;&gt; &lt;code&gt;rmprocs&lt;/code&gt; &lt;/a&gt;によってマスタープロセスで呼び出されます。 &lt;code&gt;pid&lt;/code&gt; で指定されたリモートワーカーが終了するはずです。 &lt;code&gt;kill(manager::ClusterManager.....)&lt;/code&gt; は、 &lt;code&gt;pid&lt;/code&gt; でリモート &lt;code&gt;exit()&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="dba266234257c3d4b0aca4b478ddab2be6ca2905" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. It is called on the master process, during a worker's lifetime, with appropriate &lt;code&gt;op&lt;/code&gt; values:</source>
          <target state="translated">クラスターマネージャーによって実装されます。これは、適切な &lt;code&gt;op&lt;/code&gt; 値を使用して、ワーカーのライフタイム中にマスタープロセスで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a6456a3318802fc28959139bf29a9bdf8b9e1954" translate="yes" xml:space="preserve">
          <source>Import Command</source>
          <target state="translated">インポートコマンド</target>
        </trans-unit>
        <trans-unit id="a4489b5a6e6e45ce5f1172241f2ce59438e83997" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MyModule&lt;/code&gt; above we wanted to add a method to the standard &lt;code&gt;show&lt;/code&gt; function, so we had to write &lt;code&gt;import Base.show&lt;/code&gt;. Functions whose names are only visible via &lt;code&gt;using&lt;/code&gt; cannot be extended.</source>
          <target state="translated">で &lt;code&gt;MyModule&lt;/code&gt; という上記の我々は、標準的にメソッドを追加したい &lt;code&gt;show&lt;/code&gt; 我々が書かなければならなかったので、機能 &lt;code&gt;import Base.show&lt;/code&gt; 。名前を &lt;code&gt;using&lt;/code&gt; てのみ表示される関数は拡張できません。</target>
        </trans-unit>
        <trans-unit id="035c9cab15fd9dc0120582c57dc7ae1a95ac181b" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;very rare&lt;/em&gt; cases it might make sense for the constructor &lt;code&gt;T(x)&lt;/code&gt; to return an object not of type &lt;code&gt;T&lt;/code&gt;. This could happen if a wrapper type is its own inverse (e.g. &lt;code&gt;Flip(Flip(x)) === x&lt;/code&gt;), or to support an old calling syntax for backwards compatibility when a library is restructured. But &lt;code&gt;convert(T, x)&lt;/code&gt; should always return a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;非常にまれな&lt;/em&gt;ケースには、コンストラクタの意味になるかもしれない &lt;code&gt;T(x)&lt;/code&gt; タイプのオブジェクトを返すことはない &lt;code&gt;T&lt;/code&gt; 。これは、ラッパータイプがそれ自体の逆の場合（ &lt;code&gt;Flip(Flip(x)) === x&lt;/code&gt; ）、またはライブラリの再構築時に下位互換性のために古い呼び出し構文をサポートする場合に発生する可能性があります。ただし、 &lt;code&gt;convert(T, x)&lt;/code&gt; は常に &lt;code&gt;T&lt;/code&gt; 型の値を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="d6ddd3549cd522fa313ced4025d3d58df8994646" translate="yes" xml:space="preserve">
          <source>In C++ or Java, for example, in a method call like &lt;code&gt;obj.meth(arg1,arg2)&lt;/code&gt;, the object obj &quot;receives&quot; the method call and is implicitly passed to the method via the &lt;code&gt;this&lt;/code&gt; keyword, rather than as an explicit method argument. When the current &lt;code&gt;this&lt;/code&gt; object is the receiver of a method call, it can be omitted altogether, writing just &lt;code&gt;meth(arg1,arg2)&lt;/code&gt;, with &lt;code&gt;this&lt;/code&gt; implied as the receiving object.</source>
          <target state="translated">C ++またはJavaでは、たとえば、 &lt;code&gt;obj.meth(arg1,arg2)&lt;/code&gt; ようなメソッド呼び出しでは、オブジェクトobjはメソッド呼び出しを「受け取り」、明示的なメソッド引数としてではなく、 &lt;code&gt;this&lt;/code&gt; キーワードを介して暗黙的にメソッドに渡されます。 。現在の場合 &lt;code&gt;this&lt;/code&gt; オブジェクトは、メソッド呼び出しの受信機であり、それだけで書き込み、完全に省略することができる &lt;code&gt;meth(arg1,arg2)&lt;/code&gt; 用いて、 &lt;code&gt;this&lt;/code&gt; 受信対象として暗示します。</target>
        </trans-unit>
        <trans-unit id="0b44231782a66524e37b6a261f0e356297afae45" translate="yes" xml:space="preserve">
          <source>In C++, by default, you have static dispatch, i.e. you need to annotate a function as virtual, in order to have dynamic dispatch. On the other hand, in Julia every method is &quot;virtual&quot; (although it's more general than that since methods are dispatched on every argument type, not only &lt;code&gt;this&lt;/code&gt;, using the most-specific-declaration rule).</source>
          <target state="translated">C ++では、デフォルトで静的ディスパッチがあります。つまり、動的ディスパッチを行うには、関数に仮想アノテーションを付ける必要があります。一方、Juliaでは、すべてのメソッドが「仮想」です（メソッドは、 &lt;code&gt;this&lt;/code&gt; だけでなく、すべての引数型でディスパッチされるため、最も具体的な宣言ルールを使用するため、より一般的です）。</target>
        </trans-unit>
        <trans-unit id="a64f4137e1f00234d12e399e1c5435c90a8e6c63" translate="yes" xml:space="preserve">
          <source>In Julia (as in much of scientific computation), dense linear-algebra operations are based on the &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK library&lt;/a&gt;, which in turn is built on top of basic linear-algebra building-blocks known as the &lt;a href=&quot;http://www.netlib.org/blas/&quot;&gt;BLAS&lt;/a&gt;. There are highly optimized implementations of BLAS available for every computer architecture, and sometimes in high-performance linear algebra routines it is useful to call the BLAS functions directly.</source>
          <target state="translated">Juliaでは（科学計算の多くと同様）、密な線形代数演算は&lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACKライ​​ブラリーに&lt;/a&gt;基づいており、LAPACKライ​​ブラリーは&lt;a href=&quot;http://www.netlib.org/blas/&quot;&gt;BLASと&lt;/a&gt;呼ばれる基本的な線形代数ビルディングブロックの上に構築されています。すべてのコンピューターアーキテクチャで利用できる高度に最適化されたBLASの実装があり、高性能の線形代数ルーチンでは、BLAS関数を直接呼び出すと便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="247a76ccd2e14a487830d09d4cedad7b8f5df0c1" translate="yes" xml:space="preserve">
          <source>In Julia 1.0 this method only supported a square destination matrix. Julia 1.1. added support for a rectangular matrix.</source>
          <target state="translated">Julia 1.0 では、このメソッドは正方行列のみをサポートしていました。Julia 1.1.では、長方形の行列をサポートするようになりました。</target>
        </trans-unit>
        <trans-unit id="7eb90fb66dbd8787a2bcb4484cc97817d278a46b" translate="yes" xml:space="preserve">
          <source>In Julia 1.0, the default &lt;code&gt;--project=@.&lt;/code&gt; option did not search up from the root directory of a Git repository for the &lt;code&gt;Project.toml&lt;/code&gt; file. From Julia 1.1 forward, it does.</source>
          <target state="translated">Julia 1.0では、デフォルトは &lt;code&gt;--project=@.&lt;/code&gt; オプションは、Gitリポジトリのルートディレクトリから &lt;code&gt;Project.toml&lt;/code&gt; ファイルを検索しませんでした。Julia 1.1以降では、そうなります。</target>
        </trans-unit>
        <trans-unit id="0050127afe87c7fac6e12932d051462ec8c65b3e" translate="yes" xml:space="preserve">
          <source>In Julia 1.1 &lt;code&gt;randcycle&lt;/code&gt; returns a vector &lt;code&gt;v&lt;/code&gt; with &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; while in Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt;.</source>
          <target state="translated">Julia 1.1では、 &lt;code&gt;randcycle&lt;/code&gt; は &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; ベクトル &lt;code&gt;v&lt;/code&gt; を返しますが、Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d8b5eb0c54cc4aad9911d4c5d77bfea05f710df6" translate="yes" xml:space="preserve">
          <source>In Julia 1.1 &lt;code&gt;randperm&lt;/code&gt; returns a vector &lt;code&gt;v&lt;/code&gt; with &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; while in Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt;.</source>
          <target state="translated">Julia 1.1では、 &lt;code&gt;randperm&lt;/code&gt; は &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; ベクトル &lt;code&gt;v&lt;/code&gt; を返しますが、Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d630cc94b63c31ac28921da908c57f1454c54e15" translate="yes" xml:space="preserve">
          <source>In Julia &lt;code&gt;%&lt;/code&gt; is the remainder operator, whereas in Python it is the modulus.</source>
          <target state="translated">ジュリアでは &lt;code&gt;%&lt;/code&gt; は剰余演算子ですが、Pythonではそれが係数です。</target>
        </trans-unit>
        <trans-unit id="cbc49b243ca968548d5e6046855ea243ea0a10fe" translate="yes" xml:space="preserve">
          <source>In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type &lt;code&gt;T&lt;/code&gt; inside the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, as they are passed by value. For C code accepting pointers, &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref{T}&lt;/code&gt;&lt;/a&gt; should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt;. In contrast, pointers returned by the C function called should be declared to be of output type &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr{T}&lt;/code&gt;&lt;/a&gt;, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type &lt;code&gt;Ptr{T}&lt;/code&gt; within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.</source>
          <target state="translated">外部Cルーチンへの呼び出しをラップするJuliaコードでは、通常の（非ポインター）データは値で渡されるため、&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;内で &lt;code&gt;T&lt;/code&gt; 型であると宣言する必要があります。ポインターを受け入れるCコードの場合、入力引数のタイプには通常&lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref{T}&lt;/code&gt; &lt;/a&gt;を使用する必要があります。これにより、&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt;への暗黙的な呼び出しを通じてJuliaまたはCによって管理されるメモリへのポインターを使用できるようになります。対照的に、呼び出されたC関数によって返されたポインタは、出力タイプ&lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr{T}&lt;/code&gt; &lt;/a&gt;であると宣言する必要があります。これは、ポイントされたメモリがCによってのみ管理されることを反映しています。 C構造体に含まれるポインターは、タイプ &lt;code&gt;Ptr{T}&lt;/code&gt; フィールドとして表す必要があります 対応するC構造体の内部構造を模倣するように設計された、対応するJulia構造体タイプ内。</target>
        </trans-unit>
        <trans-unit id="1fa4d6ec34fe20b0509960e834e463ea1a6b4cc7" translate="yes" xml:space="preserve">
          <source>In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type &lt;code&gt;Ref{T}&lt;/code&gt;, as Fortran passes all variables by pointers to memory locations. The return type should either be &lt;code&gt;Cvoid&lt;/code&gt; for Fortran subroutines, or a &lt;code&gt;T&lt;/code&gt; for Fortran functions returning the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">外部のFortranルーチンへの呼び出しをラップするJuliaコードでは、Fortranはすべての変数をポインターによってメモリ位置に渡すため、すべての入力引数は &lt;code&gt;Ref{T}&lt;/code&gt; 型として宣言する必要があります。戻り値の型は、Fortranサブルーチンの場合は &lt;code&gt;Cvoid&lt;/code&gt; であるか、型 &lt;code&gt;T&lt;/code&gt; を返すFortran関数の場合は &lt;code&gt;T&lt;/code&gt; である必要があります。</target>
        </trans-unit>
        <trans-unit id="34f3cdb66f13e42ca43c63a9c817a8c4007728b9" translate="yes" xml:space="preserve">
          <source>In Julia each module has its own global scope/namespace, whereas in MATLAB there is just one global scope.</source>
          <target state="translated">Juliaでは各モジュールは独自のグローバルスコープ/名前空間を持っていますが、MATLABではグローバルスコープは1つだけです。</target>
        </trans-unit>
        <trans-unit id="d9649a4e1eb5caa62495053957d722a3d4bba674" translate="yes" xml:space="preserve">
          <source>In Julia mode, the REPL supports something called &lt;em&gt;prompt pasting&lt;/em&gt;. This activates when pasting text that starts with &lt;code&gt;julia&amp;gt;&lt;/code&gt; into the REPL. In that case, only expressions starting with &lt;code&gt;julia&amp;gt;&lt;/code&gt; are parsed, others are removed. This makes it is possible to paste a chunk of code that has been copied from a REPL session without having to scrub away prompts and outputs. This feature is enabled by default but can be disabled or enabled at will with &lt;code&gt;REPL.enable_promptpaste(::Bool)&lt;/code&gt;. If it is enabled, you can try it out by pasting the code block above this paragraph straight into the REPL. This feature does not work on the standard Windows command prompt due to its limitation at detecting when a paste occurs.</source>
          <target state="translated">Juliaモードでは、REPLは&lt;em&gt;プロンプト貼り付け&lt;/em&gt;と呼ばれるものをサポートし&lt;em&gt;ます&lt;/em&gt;。これは、 &lt;code&gt;julia&amp;gt;&lt;/code&gt; で始まるテキストをREPL に貼り付けるとアクティブになります。その場合、 &lt;code&gt;julia&amp;gt;&lt;/code&gt; で始まる式のみが解析され、その他は削除されます。これにより、プロンプトや出力を消し去ることなく、REPLセッションからコピーされたコードのチャンクを貼り付けることができます。この機能はデフォルトで有効になっていますが、 &lt;code&gt;REPL.enable_promptpaste(::Bool)&lt;/code&gt; で自由に無効または有効にできます。有効になっている場合は、この段落の上のコードブロックをREPLに直接貼り付けることで試してみることができます。この機能は、貼り付けの発生を検出する際の制限により、標準のWindowsコマンドプロンプトでは機能しません。</target>
        </trans-unit>
        <trans-unit id="57d6ea2617d808e81c678587852ffabe403f81cb" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;&amp;lt;-&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt; are not assignment operators.</source>
          <target state="translated">ジュリアでは、 &lt;code&gt;&amp;lt;-&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; 、 &lt;code&gt;-&amp;gt;&lt;/code&gt; は代入演算子ではありません。</target>
        </trans-unit>
        <trans-unit id="601692d3aba8995fb01afb976c7c7f5a8aab46fc" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;...&lt;/code&gt; is not used to continue lines of code. Instead, incomplete expressions automatically continue onto the next line.</source>
          <target state="translated">ジュリアでは、 &lt;code&gt;...&lt;/code&gt; はコード行の継続には使用されません。代わりに、不完全な式は自動的に次の行に続きます。</target>
        </trans-unit>
        <trans-unit id="5bdd69cd27046bb2e3189abcdf750e49518e8509" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;Ref&lt;/code&gt; objects are dereferenced (loaded or stored) with &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Juliaでは、 &lt;code&gt;Ref&lt;/code&gt; オブジェクトは &lt;code&gt;[]&lt;/code&gt; で逆参照（ロードまたは保存）されます。</target>
        </trans-unit>
        <trans-unit id="bbe698f34efa48506b3a034b90fcbacaa3b44d79" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[1, 2, 3, 4][[true, false, true, false]]&lt;/code&gt; produces &lt;code&gt;[1, 3]&lt;/code&gt;.</source>
          <target state="translated">ジュリアでは、 &lt;code&gt;[1, 2, 3, 4][[true, false, true, false]]&lt;/code&gt; は &lt;code&gt;[1, 3]&lt;/code&gt; 生成します。</target>
        </trans-unit>
        <trans-unit id="41c6478a96484907c7a62d3fc652aeb5cc697413" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[1, 2, 3, 4][[true, false]]&lt;/code&gt; throws a &lt;a href=&quot;../../base/base/index#Core.BoundsError&quot;&gt;&lt;code&gt;BoundsError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ジュリアでは、 &lt;code&gt;[1, 2, 3, 4][[true, false]]&lt;/code&gt; が&lt;a href=&quot;../../base/base/index#Core.BoundsError&quot;&gt; &lt;code&gt;BoundsError&lt;/code&gt; を&lt;/a&gt;スローします。</target>
        </trans-unit>
        <trans-unit id="0974da83f18cbcaffe16bb6459e3edda104c9151" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[x,y,z]&lt;/code&gt; will always construct a 3-element array containing &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">Juliaでは、 &lt;code&gt;[x,y,z]&lt;/code&gt; は常に &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、 &lt;code&gt;z&lt;/code&gt; を含む3要素の配列を作成します。</target>
        </trans-unit>
        <trans-unit id="1d138a3241eb075445bbb09d48ceedbc03b1d34e" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;a:b&lt;/code&gt; and &lt;code&gt;a:b:c&lt;/code&gt; construct &lt;code&gt;AbstractRange&lt;/code&gt; objects. To construct a full vector like in MATLAB, use &lt;code&gt;collect(a:b)&lt;/code&gt;. Generally, there is no need to call &lt;code&gt;collect&lt;/code&gt; though. An &lt;code&gt;AbstractRange&lt;/code&gt; object will act like a normal array in most cases but is more efficient because it lazily computes its values. This pattern of creating specialized objects instead of full arrays is used frequently, and is also seen in functions such as &lt;a href=&quot;../../base/math/index#Base.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, or with iterators such as &lt;code&gt;enumerate&lt;/code&gt;, and &lt;code&gt;zip&lt;/code&gt;. The special objects can mostly be used as if they were normal arrays.</source>
          <target state="translated">Juliaでは、 &lt;code&gt;a:b&lt;/code&gt; および &lt;code&gt;a:b:c&lt;/code&gt; が &lt;code&gt;AbstractRange&lt;/code&gt; オブジェクトを構築します。MATLABのように完全なベクトルを作成するには、 &lt;code&gt;collect(a:b)&lt;/code&gt; を使用します。ただし、通常は、 &lt;code&gt;collect&lt;/code&gt; を呼び出す必要はありません。 &lt;code&gt;AbstractRange&lt;/code&gt; のオブジェクトは、ほとんどの場合、通常の配列のように作用するが、それはいい加減にその値を計算しているため、より効率的であるだろう。完全な配列の代わりに特殊なオブジェクトを作成するこのパターンは頻繁に使用され、&lt;a href=&quot;../../base/math/index#Base.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt;などの関数、または &lt;code&gt;enumerate&lt;/code&gt; や &lt;code&gt;zip&lt;/code&gt; などのイテレータでも見られます。特別なオブジェクトは、通常の配列のように使用できます。</target>
        </trans-unit>
        <trans-unit id="5622f51f1798995f4e2f17cefbf558acb8bdcceb" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;return&lt;/code&gt; does not require parentheses.</source>
          <target state="translated">ジュリアでは、 &lt;code&gt;return&lt;/code&gt; 括弧は必要ありません。</target>
        </trans-unit>
        <trans-unit id="c5612272a8f825cb7424d2a9deb9bd304a01ce42" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;x += y&lt;/code&gt; gets replaced during parsing by &lt;code&gt;x = x + y&lt;/code&gt;. For arrays, this has the consequence that, rather than storing the result in the same location in memory as &lt;code&gt;x&lt;/code&gt;, it allocates a new array to store the result.</source>
          <target state="translated">Juliaでは、 &lt;code&gt;x += y&lt;/code&gt; は解析中に &lt;code&gt;x = x + y&lt;/code&gt; 置き換えられます。配列の場合、これは結果をメモリ内の &lt;code&gt;x&lt;/code&gt; と同じ場所に格納するのではなく、結果を格納するために新しい配列を割り当てるという結果になります。</target>
        </trans-unit>
        <trans-unit id="58b1700c001aef7c6e8210d638550d343b095441" translate="yes" xml:space="preserve">
          <source>In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not pure mathematical functions, in the sense that functions can alter and be affected by the global state of the program. The basic syntax for defining functions in Julia is:</source>
          <target state="translated">Julia では、関数は引数の値のタプルを戻り値にマッピングするオブジェクトです。Julia の関数は純粋な数学関数ではなく、プログラムのグローバルな状態を変更したり影響を受けたりすることができるという意味で、純粋な数学関数です。Julia で関数を定義するための基本的な構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="4f9d45e10bb7e036a0e05a4d8d4376715db6b481" translate="yes" xml:space="preserve">
          <source>In Julia, a range like &lt;code&gt;a:b&lt;/code&gt; is not shorthand for a vector like in R, but is a specialized &lt;code&gt;AbstractRange&lt;/code&gt; object that is used for iteration without high memory overhead. To convert a range into a vector, use &lt;code&gt;collect(a:b)&lt;/code&gt;.</source>
          <target state="translated">Juliaでは、 &lt;code&gt;a:b&lt;/code&gt; のような範囲はRのようなベクトルの省略表現ではありませんが、高いメモリオーバーヘッドなしで反復に使用される特殊な &lt;code&gt;AbstractRange&lt;/code&gt; オブジェクトです。範囲をベクトルに変換するには、 &lt;code&gt;collect(a:b)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="40f5223023ecdb73df06f3b1a01d3f068c335d77" translate="yes" xml:space="preserve">
          <source>In Julia, all arguments to functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;passed by sharing&lt;/a&gt; (i.e. by pointers). Some technical computing languages pass arrays by value, and while this prevents accidental modification by callees of a value in the caller, it makes avoiding unwanted copying of arrays difficult. By convention, a function name ending with a &lt;code&gt;!&lt;/code&gt; indicates that it will mutate or destroy the value of one or more of its arguments (compare, for example, &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;). Callees must make explicit copies to ensure that they don't modify inputs that they don't intend to change. Many non- mutating functions are implemented by calling a function of the same name with an added &lt;code&gt;!&lt;/code&gt; at the end on an explicit copy of the input, and returning that copy.</source>
          <target state="translated">Juliaでは、関数へのすべての引数は&lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;共有&lt;/a&gt;（つまり、ポインター）によって渡されます。一部のテクニカルコンピューティング言語は配列を値で渡します。これにより、呼び出し元の値の呼び出し先による誤った変更は防止されますが、配列の不要なコピーを回避することが難しくなります。慣例により、 &lt;code&gt;!&lt;/code&gt; で終わる関数名 1つ以上の引数の値を変更または破棄することを示します（たとえば、&lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; を&lt;/a&gt;比較してください）。呼び出し先は、明示的にコピーを作成して、変更するつもりのない入力を変更しないようにする必要があります。多くの非変更関数は、同じ名前の関数を &lt;code&gt;!&lt;/code&gt; 入力の明示的なコピーの最後で、そのコピーを返します。</target>
        </trans-unit>
        <trans-unit id="9c3127614001f5fb915dc8fbc84746b3f3f27566" translate="yes" xml:space="preserve">
          <source>In Julia, an array &quot;slice&quot; expression like &lt;code&gt;array[1:5, :]&lt;/code&gt; creates a copy of that data (except on the left-hand side of an assignment, where &lt;code&gt;array[1:5, :] = ...&lt;/code&gt; assigns in-place to that portion of &lt;code&gt;array&lt;/code&gt;). If you are doing many operations on the slice, this can be good for performance because it is more efficient to work with a smaller contiguous copy than it would be to index into the original array. On the other hand, if you are just doing a few simple operations on the slice, the cost of the allocation and copy operations can be substantial.</source>
          <target state="translated">Juliaでは、array &lt;code&gt;array[1:5, :]&lt;/code&gt; 、：]のような配列の「スライス」式は、そのデータのコピーを作成します（ &lt;code&gt;array[1:5, :] = ...&lt;/code&gt; 、：] = ...割り当ての左側の割り当てを除く） &lt;code&gt;array&lt;/code&gt; その部分にインプレース）。スライスで多くの操作を実行している場合、元の配列にインデックスを付けるよりも小さな連続したコピーで作業する方が効率的であるため、これはパフォーマンスにとって良い場合があります。一方、スライスでいくつかの単純な操作を実行しているだけの場合、割り当てとコピーの操作のコストはかなり高くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="3012ec15c747cb5e8c8ab3cbb7a1be0e9f5c2879" translate="yes" xml:space="preserve">
          <source>In Julia, exceeding the maximum representable value of a given type results in a wraparound behavior:</source>
          <target state="translated">Julia では、指定された型の表現可能な最大値を超えると、ラップアラウンド動作が発生します。</target>
        </trans-unit>
        <trans-unit id="64ca87b8c062eb3ffaa0f39bec7e937ad18a966d" translate="yes" xml:space="preserve">
          <source>In Julia, if &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are arrays, logical comparison operations like &lt;code&gt;A == B&lt;/code&gt; do not return an array of booleans. Instead, use &lt;code&gt;A .== B&lt;/code&gt;, and similarly for the other boolean operators like &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Juliaでは、 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; が配列の場合、 &lt;code&gt;A == B&lt;/code&gt; ような論理比較演算はブール値の配列を返しません。代わりに、 &lt;code&gt;A .== B&lt;/code&gt; 使用し、 &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; などの他のブール演算子にも同様に使用します。</target>
        </trans-unit>
        <trans-unit id="d922f5b73911084e1798e1fbea58a0f20f71a33c" translate="yes" xml:space="preserve">
          <source>In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.</source>
          <target state="translated">Juliaでは、配列や文字列などのインデックスは0ベースではなく1ベースになります。</target>
        </trans-unit>
        <trans-unit id="06df6596eaa7007459b69a3e35309023ab071dc0" translate="yes" xml:space="preserve">
          <source>In Julia, like Python but unlike R, strings can be created with triple quotes &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt;. This syntax is convenient for constructing strings that contain line breaks.</source>
          <target state="translated">Juliaでは、Pythonと同様ですが、Rとは異なり、文字列は三重引用符 &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt; で作成できます。この構文は、改行を含む文字列を作成するのに便利です。</target>
        </trans-unit>
        <trans-unit id="c8b7771804f2b70605beeefa21f23d88e1f845ae" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create integers instead of floating point numbers. As a result, some operations can throw a domain error if they expect a float; for example, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; throws a domain error, as the result is not an integer (see &lt;a href=&quot;../faq/index#faq-domain-errors-1&quot;&gt;the FAQ entry on domain errors&lt;/a&gt; for details).</source>
          <target state="translated">Juliaでは、小数点のないリテラル数（ &lt;code&gt;42&lt;/code&gt; など）は、浮動小数点数ではなく整数を作成します。その結果、フロートが必要な場合、一部の操作はドメインエラーをスローする可能性があります。たとえば、 &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; は結果が整数ではないため、ドメインエラーをスローします（詳細について&lt;a href=&quot;../faq/index#faq-domain-errors-1&quot;&gt;は、ドメインエラーに関するFAQエントリ&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="abe9d8d534555f871e47223b8068b11086c34b86" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create signed integers, of type &lt;code&gt;Int&lt;/code&gt;, but literals too large to fit in the machine word size will automatically be promoted to a larger size type, such as &lt;code&gt;Int64&lt;/code&gt; (if &lt;code&gt;Int&lt;/code&gt; is &lt;code&gt;Int32&lt;/code&gt;), &lt;code&gt;Int128&lt;/code&gt;, or the arbitrarily large &lt;code&gt;BigInt&lt;/code&gt; type. There are no numeric literal suffixes, such as &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;LL&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;UL&lt;/code&gt;, &lt;code&gt;ULL&lt;/code&gt; to indicate unsigned and/or signed vs. unsigned. Decimal literals are always signed, and hexadecimal literals (which start with &lt;code&gt;0x&lt;/code&gt; like C/C++), are unsigned. Hexadecimal literals also, unlike C/C++/Java and unlike decimal literals in Julia, have a type based on the &lt;em&gt;length&lt;/em&gt; of the literal, including leading 0s. For example, &lt;code&gt;0x0&lt;/code&gt; and &lt;code&gt;0x00&lt;/code&gt; have type &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;0x000&lt;/code&gt; and &lt;code&gt;0x0000&lt;/code&gt; have type &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/a&gt;, then literals with 5 to 8 hex digits have type &lt;code&gt;UInt32&lt;/code&gt;, 9 to 16 hex digits type &lt;code&gt;UInt64&lt;/code&gt; and 17 to 32 hex digits type &lt;code&gt;UInt128&lt;/code&gt;. This needs to be taken into account when defining hexadecimal masks, for example &lt;code&gt;~0xf == 0xf0&lt;/code&gt; is very different from &lt;code&gt;~0x000f == 0xfff0&lt;/code&gt;. 64 bit &lt;code&gt;Float64&lt;/code&gt; and 32 bit &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; bit literals are expressed as &lt;code&gt;1.0&lt;/code&gt; and &lt;code&gt;1.0f0&lt;/code&gt; respectively. Floating point literals are rounded (and not promoted to the &lt;code&gt;BigFloat&lt;/code&gt; type) if they can not be exactly represented. Floating point literals are closer in behavior to C/C++. Octal (prefixed with &lt;code&gt;0o&lt;/code&gt;) and binary (prefixed with &lt;code&gt;0b&lt;/code&gt;) literals are also treated as unsigned.</source>
          <target state="translated">Juliaでは、小数点のないリテラル数（ &lt;code&gt;42&lt;/code&gt; など）は、タイプ &lt;code&gt;Int&lt;/code&gt; の符号付き整数を作成しますが、リテラルが大きすぎてマシンワードサイズに収まらない場合、 &lt;code&gt;Int64&lt;/code&gt; などのより大きなサイズタイプに自動的に昇格されます（ &lt;code&gt;Int&lt;/code&gt; が &lt;code&gt;Int32&lt;/code&gt; ）、 &lt;code&gt;Int128&lt;/code&gt; 、または任意の大きさ &lt;code&gt;BigInt&lt;/code&gt; 種類。 &lt;code&gt;L&lt;/code&gt; 、 &lt;code&gt;LL&lt;/code&gt; 、 &lt;code&gt;U&lt;/code&gt; 、 &lt;code&gt;UL&lt;/code&gt; 、 &lt;code&gt;ULL&lt;/code&gt; などの数値リテラルサフィックスはありません。 10進リテラルは常に署名され、16進リテラル（ &lt;code&gt;0x&lt;/code&gt; で始まる）C / C ++のように）、署名されていません。 16進リテラルも、C / C ++ / Javaとは異なり、Juliaの10進リテラルとは異なり、先行する0を含め、リテラルの&lt;em&gt;長さ&lt;/em&gt;に基づいた型を持っています。例えば、 &lt;code&gt;0x0&lt;/code&gt; と &lt;code&gt;0x00&lt;/code&gt; のタイプ有する&lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;0x000&lt;/code&gt; および &lt;code&gt;0x0000&lt;/code&gt; 入力した&lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt; &lt;code&gt;UInt16&lt;/code&gt; 型を&lt;/a&gt;、次いで5~8六角桁リテラルが入力持っ &lt;code&gt;UInt32&lt;/code&gt; 型を、9〜16進数字が入力 &lt;code&gt;UInt64&lt;/code&gt; 型を 17〜32進数字が入力 &lt;code&gt;UInt128&lt;/code&gt; を。これは、例えば、進マスクを定義する際に考慮される必要がある &lt;code&gt;~0xf == 0xf0&lt;/code&gt; 非常に異なっている &lt;code&gt;~0x000f == 0xfff0&lt;/code&gt; 。 64ビット &lt;code&gt;Float64&lt;/code&gt; および32ビット&lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;ビットリテラルは、それぞれ &lt;code&gt;1.0&lt;/code&gt; および &lt;code&gt;1.0f0&lt;/code&gt; として表されます。浮動小数点リテラルは、正確に表すことができない場合、丸められます（ &lt;code&gt;BigFloat&lt;/code&gt; タイプにプロモートされません）。浮動小数点リテラルは、C / C ++に近い動作をします。 8 進数（接頭辞 &lt;code&gt;0o&lt;/code&gt; ）および2進（接頭辞 &lt;code&gt;0b&lt;/code&gt; ）リテラルも符号なしとして扱われます。</target>
        </trans-unit>
        <trans-unit id="bdfe6baa0b2a1067c27d35abb55f2ee6ec449a3c" translate="yes" xml:space="preserve">
          <source>In Julia, missing values are represented by the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object rather than by &lt;code&gt;NA&lt;/code&gt;. Use &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt;&lt;code&gt;ismissing(x)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;ismissing.(x)&lt;/code&gt; for element-wise operation on vectors) instead of &lt;code&gt;is.na(x)&lt;/code&gt;. The &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function is generally used instead of &lt;code&gt;na.rm=TRUE&lt;/code&gt; (though in some particular cases functions take a &lt;code&gt;skipmissing&lt;/code&gt; argument).</source>
          <target state="translated">Juliaでは、欠損値は &lt;code&gt;NA&lt;/code&gt; ではなく&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;オブジェクトで表されます。使用&lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt; &lt;code&gt;ismissing(x)&lt;/code&gt; &lt;/a&gt;（又は &lt;code&gt;ismissing.(x)&lt;/code&gt; の代わりに、要素ごとの操作のためのベクターに） &lt;code&gt;is.na(x)&lt;/code&gt; 。&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; の&lt;/a&gt;機能は、一般の代わりに使用され &lt;code&gt;na.rm=TRUE&lt;/code&gt; （いくつかの特定のケースで機能を取るのに &lt;code&gt;skipmissing&lt;/code&gt; の引数）。</target>
        </trans-unit>
        <trans-unit id="c2883abece45992fb07a9eafea704ad64c7847f2" translate="yes" xml:space="preserve">
          <source>In Julia, modulus is &lt;code&gt;mod(a, b)&lt;/code&gt;, not &lt;code&gt;a %% b&lt;/code&gt;. &lt;code&gt;%&lt;/code&gt; in Julia is the remainder operator.</source>
          <target state="translated">ジュリアでは、係数は &lt;code&gt;mod(a, b)&lt;/code&gt; であり &lt;code&gt;a %% b&lt;/code&gt; ではありません。ジュリアの &lt;code&gt;%&lt;/code&gt; は剰余演算子です。</target>
        </trans-unit>
        <trans-unit id="2e2622d04790dce54d4881a8ca271df72d322df7" translate="yes" xml:space="preserve">
          <source>In Julia, most operators are just functions with support for special syntax. (The exceptions are operators with special evaluation semantics like &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;. These operators cannot be functions since &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;Short-Circuit Evaluation&lt;/a&gt; requires that their operands are not evaluated before evaluation of the operator.) Accordingly, you can also apply them using parenthesized argument lists, just as you would any other function:</source>
          <target state="translated">Juliaでは、ほとんどの演算子は特別な構文をサポートする関数です。 （例外はのような特別な評価のセマンティクスを持つ演算子です &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; と &lt;code&gt;||&lt;/code&gt; 。これらの演算子は機能することはできませんので、&lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;ショートサーキット評価は&lt;/a&gt;、オペランドが演算子の評価の前に評価されていないことが必要です。）したがって、あなたはまた、括弧で囲まれた引数リストを使用してそれらを適用することができます、他の関数と同じように：</target>
        </trans-unit>
        <trans-unit id="cec708186271fab31b28911da66c39fb5ef32d0d" translate="yes" xml:space="preserve">
          <source>In Julia, multiple values are returned and assigned as tuples, e.g. &lt;code&gt;(a, b) = (1, 2)&lt;/code&gt; or &lt;code&gt;a, b = 1, 2&lt;/code&gt;. MATLAB's &lt;code&gt;nargout&lt;/code&gt;, which is often used in MATLAB to do optional work based on the number of returned values, does not exist in Julia. Instead, users can use optional and keyword arguments to achieve similar capabilities.</source>
          <target state="translated">Juliaでは、複数の値が返され、タプルとして割り当てられます（例： &lt;code&gt;(a, b) = (1, 2)&lt;/code&gt; または &lt;code&gt;a, b = 1, 2&lt;/code&gt; 。戻り値の数に基づいてオプションの作業を行うためにMATLABでよく使用されるMATLABの &lt;code&gt;nargout&lt;/code&gt; は、Juliaには存在しません。代わりに、ユーザーはオプションの引数とキーワード引数を使用して、同様の機能を実現できます。</target>
        </trans-unit>
        <trans-unit id="4f6861a8c923af27ce752544647b06d9e6a0a07e" translate="yes" xml:space="preserve">
          <source>In Julia, not all data structures support logical indexing. Furthermore, logical indexing in Julia is supported only with vectors of length equal to the object being indexed. For example:</source>
          <target state="translated">Julia では、すべてのデータ構造が論理インデックスをサポートしているわけではありません。さらに、ジュリアでの論理インデキシングは、インデキシングされているオブジェクトと等しい長さのベクトルでのみサポートされています。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="451c3e5bbe0419b361a11d608a26c62bcc892288" translate="yes" xml:space="preserve">
          <source>In Julia, one returns a tuple of values to simulate returning multiple values. However, tuples can be created and destructured without needing parentheses, thereby providing an illusion that multiple values are being returned, rather than a single tuple value. For example, the following function returns a pair of values:</source>
          <target state="translated">Juliaでは、複数の値を返すことをシミュレートするために、値のタプルを返します。しかし、タプルは括弧を必要とせずに作成したり破壊したりすることができるので、単一のタプル値ではなく複数の値が返されているかのような錯覚を与えます。例えば、以下の関数は値のペアを返します。</target>
        </trans-unit>
        <trans-unit id="d1f236e7a8645aa4ffbd134429aa159fdbc206da" translate="yes" xml:space="preserve">
          <source>In Julia, parentheses must be used to call a function with zero arguments, like in &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt;&lt;code&gt;rand()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Juliaでは、&lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt; &lt;code&gt;rand()&lt;/code&gt; の&lt;/a&gt;ように、引数をゼロにして関数を呼び出すには括弧を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="b62993ba8b73165f19053f9f6eaf87bfbe97454f" translate="yes" xml:space="preserve">
          <source>In Julia, reductions such as &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; are performed over every element of an array when called with a single argument, as in &lt;code&gt;sum(A)&lt;/code&gt;, even if &lt;code&gt;A&lt;/code&gt; has more than one dimension.</source>
          <target state="translated">ジュリアでは、などの還元&lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; は&lt;/a&gt;、単一の引数で呼び出されたときのように、配列の各要素にわたって行われる &lt;code&gt;sum(A)&lt;/code&gt; としても、 &lt;code&gt;A&lt;/code&gt; が複数の寸法を有します。</target>
        </trans-unit>
        <trans-unit id="6b1973243505286be855fb241367233be8bd84fa" translate="yes" xml:space="preserve">
          <source>In Julia, sparse matrices are stored in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29&quot;&gt;Compressed Sparse Column (CSC) format&lt;/a&gt;. Julia sparse matrices have the type &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC{Tv,Ti}&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;Tv&lt;/code&gt; is the type of the stored values, and &lt;code&gt;Ti&lt;/code&gt; is the integer type for storing column pointers and row indices. The internal representation of &lt;code&gt;SparseMatrixCSC&lt;/code&gt; is as follows:</source>
          <target state="translated">Juliaでは、スパース行列は&lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29&quot;&gt;圧縮スパース列（CSC）形式で&lt;/a&gt;保存されます。ジュリアスパース行列は、タイプ有する&lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC{Tv,Ti}&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;Tv&lt;/code&gt; が格納された値のタイプであり、および &lt;code&gt;Ti&lt;/code&gt; はカラムポインタと行インデックスを格納する整数型です。 &lt;code&gt;SparseMatrixCSC&lt;/code&gt; の内部表現は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="1e8bc1ec2e65356b67489d496d41c529e84e8334" translate="yes" xml:space="preserve">
          <source>In Julia, the binding of a variable &lt;code&gt;x&lt;/code&gt; cannot be changed by passing &lt;code&gt;x&lt;/code&gt; as an argument to a function. When calling &lt;code&gt;change_value!(x)&lt;/code&gt; in the above example, &lt;code&gt;y&lt;/code&gt; is a newly created variable, bound initially to the value of &lt;code&gt;x&lt;/code&gt;, i.e. &lt;code&gt;10&lt;/code&gt;; then &lt;code&gt;y&lt;/code&gt; is rebound to the constant &lt;code&gt;17&lt;/code&gt;, while the variable &lt;code&gt;x&lt;/code&gt; of the outer scope is left untouched.</source>
          <target state="translated">Juliaでは、変数 &lt;code&gt;x&lt;/code&gt; のバインディングは、 &lt;code&gt;x&lt;/code&gt; を引数として関数に渡しても変更できません。上記の例で &lt;code&gt;change_value!(x)&lt;/code&gt; を呼び出す場合、 &lt;code&gt;y&lt;/code&gt; は新しく作成された変数であり、最初に &lt;code&gt;x&lt;/code&gt; の値、つまり &lt;code&gt;10&lt;/code&gt; にバインドされます。次に、 &lt;code&gt;y&lt;/code&gt; は定数 &lt;code&gt;17&lt;/code&gt; にリバインドされますが、外側のスコープの変数 &lt;code&gt;x&lt;/code&gt; は変更されません。</target>
        </trans-unit>
        <trans-unit id="7ad2abcec621eb10f8cdb25e242afd4f9efd6dd1" translate="yes" xml:space="preserve">
          <source>In Julia, the elements of a collection can be passed as arguments to a function using the splat operator &lt;code&gt;...&lt;/code&gt;, as in &lt;code&gt;xs=[1,2]; f(xs...)&lt;/code&gt;.</source>
          <target state="translated">Juliaでは、 &lt;code&gt;xs=[1,2]; f(xs...)&lt;/code&gt; ように、スプラット演算子 &lt;code&gt;...&lt;/code&gt; を使用して、コレクションの要素を引数として関数に渡すことができます。f（xs ...）。</target>
        </trans-unit>
        <trans-unit id="93d049ffcb952000d0f8ebc0a66e0ee55d575d87" translate="yes" xml:space="preserve">
          <source>In Julia, the operator &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;) performs the bitwise XOR operation, i.e. &lt;code&gt;^&lt;/code&gt; in C/C++. Also, the bitwise operators do not have the same precedence as C/++, so parenthesis may be required.</source>
          <target state="translated">Juliaでは、演算子&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt;）はビット単位のXOR演算を実行します（C / C ++では &lt;code&gt;^&lt;/code&gt; )。また、ビットごとの演算子の優先順位はC / ++と同じではないため、括弧が必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="8490fa684242627635a34751122775551824f7e6" translate="yes" xml:space="preserve">
          <source>In Julia, the operators &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;) perform the bitwise operations equivalent to &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, and &lt;code&gt;xor&lt;/code&gt; respectively in MATLAB, and have precedence similar to Python's bitwise operators (unlike C). They can operate on scalars or element-wise across arrays and can be used to combine logical arrays, but note the difference in order of operations: parentheses may be required (e.g., to select elements of &lt;code&gt;A&lt;/code&gt; equal to 1 or 2 use &lt;code&gt;(A .== 1) .| (A .== 2)&lt;/code&gt;).</source>
          <target state="translated">ジュリアでは、演算子&lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;|&lt;/code&gt; 、および&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt;）は、MATLABでそれぞれ &lt;code&gt;and&lt;/code&gt; 、 &lt;code&gt;or&lt;/code&gt; 、および &lt;code&gt;xor&lt;/code&gt; と同等のビット単位演算を実行し、Pythonのビット単位演算子（Cとは異なります）と同様の優先順位を持っています。これらは配列全体でスカラーまたは要素単位で操作でき、論理配列を組み合わせるために使用できますが、操作の順序の違いに注意してください：括弧が必要な場合があります（たとえば、1または2に等しい &lt;code&gt;A&lt;/code&gt; の要素を選択するには &lt;code&gt;(A .== 1) .| (A .== 2)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c924b695c23524838be4cdefba6d4ecf3f12bd7f" translate="yes" xml:space="preserve">
          <source>In Julia, values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller. This is very different from R and allows new functions to operate on large data structures much more efficiently.</source>
          <target state="translated">Juliaでは、関数に代入されたり渡されたりしても、値はコピーされません。関数が配列を変更した場合、その変更は呼び出し元に表示されます。これはRとは大きく異なり、新しい関数が大きなデータ構造をより効率的に操作できるようになります。</target>
        </trans-unit>
        <trans-unit id="4125f91a0372e71681729284bfb74b1b5f121b87" translate="yes" xml:space="preserve">
          <source>In Julia, varargs are specified using the splat operator &lt;code&gt;...&lt;/code&gt;, which always follows the name of a specific variable, unlike R, for which &lt;code&gt;...&lt;/code&gt; can occur in isolation.</source>
          <target state="translated">Juliaでは、可変長引数は、splat演算子 &lt;code&gt;...&lt;/code&gt; を使用して指定されます。これは、Rとは異なり、 &lt;code&gt;...&lt;/code&gt; が単独で発生する場合があるため、特定の変数の名前の後に常に続きます。</target>
        </trans-unit>
        <trans-unit id="61706e2cf7e3e0b63c2023adcea629882d9748dd" translate="yes" xml:space="preserve">
          <source>In Julia, vectors and matrices are concatenated using &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt;&lt;code&gt;hcat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt;&lt;code&gt;vcat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt;&lt;code&gt;hvcat&lt;/code&gt;&lt;/a&gt;, not &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;rbind&lt;/code&gt; and &lt;code&gt;cbind&lt;/code&gt; like in R.</source>
          <target state="translated">ジュリアでは、ベクトルと行列を用いて連結され&lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt; &lt;code&gt;hcat&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt; &lt;code&gt;vcat&lt;/code&gt; &lt;/a&gt;及び&lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt; &lt;code&gt;hvcat&lt;/code&gt; &lt;/a&gt;なく、 &lt;code&gt;c&lt;/code&gt; 、 &lt;code&gt;rbind&lt;/code&gt; と &lt;code&gt;cbind&lt;/code&gt; R.のよう</target>
        </trans-unit>
        <trans-unit id="c15bdde6dec6d1761a5dc60f223d32d1ac186e83" translate="yes" xml:space="preserve">
          <source>In Julia, we can access the parts independently to make a copy of that string:</source>
          <target state="translated">Juliaでは、パーツを独立してアクセスして、その文字列のコピーを作成することができます。</target>
        </trans-unit>
        <trans-unit id="8bbe2d9f25b242e167641a97cc1e17c904778314" translate="yes" xml:space="preserve">
          <source>In Julia, whitespace is significant, unlike C/C++, so care must be taken when adding/removing whitespace from a Julia program.</source>
          <target state="translated">Julia では C/C++とは異なり、空白は重要な意味を持つので、Julia プログラムに空白を追加したり削除したりする際には注意が必要です。</target>
        </trans-unit>
        <trans-unit id="dfd2a6192ce5ab720952e7ded70bfe43e1c2837a" translate="yes" xml:space="preserve">
          <source>In Julia, you can't dispatch on a &lt;em&gt;value&lt;/em&gt; such as &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. However, you can dispatch on parametric types, and Julia allows you to include &quot;plain bits&quot; values (Types, Symbols, Integers, floating-point numbers, tuples, etc.) as type parameters. A common example is the dimensionality parameter in &lt;code&gt;Array{T,N}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a type (e.g., &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;) but &lt;code&gt;N&lt;/code&gt; is just an &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">Juliaでは、 &lt;code&gt;true&lt;/code&gt; や &lt;code&gt;false&lt;/code&gt; などの&lt;em&gt;値で&lt;/em&gt;ディスパッチすることはできません。ただし、パラメトリックタイプでディスパッチでき、Juliaでは「プレーンビット」値（タイプ、シンボル、整数、浮動小数点数、タプルなど）をタイプパラメータとして含めることができます。一般的な例は、 &lt;code&gt;Array{T,N}&lt;/code&gt; の次元パラメーターです。ここで、 &lt;code&gt;T&lt;/code&gt; は型（&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; など&lt;/a&gt;）ですが、 &lt;code&gt;N&lt;/code&gt; は単なる &lt;code&gt;Int&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0987332b373dba2f6dccb678d104e0da95c47a9e" translate="yes" xml:space="preserve">
          <source>In MATLAB, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression &lt;code&gt;x(x&amp;gt;3)&lt;/code&gt; or in the statement &lt;code&gt;x(x&amp;gt;3) = []&lt;/code&gt; to modify &lt;code&gt;x&lt;/code&gt; in-place. In contrast, Julia provides the higher order functions &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;, allowing users to write &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; and &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; as alternatives to the corresponding transliterations &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; and &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt;. Using &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt; reduces the use of temporary arrays.</source>
          <target state="translated">MATLABでは、不要な値を削除する慣用的な方法は、式 &lt;code&gt;x(x&amp;gt;3)&lt;/code&gt; またはステートメント &lt;code&gt;x(x&amp;gt;3) = []&lt;/code&gt; ように論理インデックスを使用して、 &lt;code&gt;x&lt;/code&gt; をインプレースで変更することです。対照的に、ジュリアはより高次の関数&lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;提供します！、対応する音訳 &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; および &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt; 代替として &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; および &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; をユーザーが記述できるようにします。 3]。&lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;使用！一時配列の使用を減らします。</target>
        </trans-unit>
        <trans-unit id="6e02ea871ca138515cbf18e7481d0fb87b2d5244" translate="yes" xml:space="preserve">
          <source>In R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE)]&lt;/code&gt; is equivalent to &lt;code&gt;c(1, 3)&lt;/code&gt;.</source>
          <target state="translated">Rでは、 &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE)]&lt;/code&gt; は &lt;code&gt;c(1, 3)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="616e3b4685be805ef30bd44974ee4d2b22ae8fea" translate="yes" xml:space="preserve">
          <source>In R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]&lt;/code&gt; is equivalent to &lt;code&gt;c(1, 3)&lt;/code&gt;.</source>
          <target state="translated">Rでは、 &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]&lt;/code&gt; は &lt;code&gt;c(1, 3)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="ce0a60c169bc6c80688de200a5cb77dbd4fa3448" translate="yes" xml:space="preserve">
          <source>In R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression &lt;code&gt;x[x&amp;gt;3]&lt;/code&gt; or in the statement &lt;code&gt;x = x[x&amp;gt;3]&lt;/code&gt; to modify &lt;code&gt;x&lt;/code&gt; in-place. In contrast, Julia provides the higher order functions &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;, allowing users to write &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; and &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; as alternatives to the corresponding transliterations &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; and &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt;. Using &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt; reduces the use of temporary arrays.</source>
          <target state="translated">Rでは、不要な値を削除する慣用的な方法は、式 &lt;code&gt;x[x&amp;gt;3]&lt;/code&gt; またはステートメント &lt;code&gt;x = x[x&amp;gt;3]&lt;/code&gt; ように論理インデックスを使用して、 &lt;code&gt;x&lt;/code&gt; をインプレースで変更することです。対照的に、ジュリアはより高次の関数&lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;提供します！、対応する音訳 &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; および &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt; 代替として &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; および &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; をユーザーが記述できるようにします。 3]。&lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;使用！一時配列の使用を減らします。</target>
        </trans-unit>
        <trans-unit id="f6752ab2f8e0e7630531a6d7a1987e0bbb17b890" translate="yes" xml:space="preserve">
          <source>In R, performance requires vectorization. In Julia, almost the opposite is true: the best performing code is often achieved by using devectorized loops.</source>
          <target state="translated">Rでは、パフォーマンスにはベクトル化が必要です。Juliaでは、ほとんど逆のことが言えます:最高のパフォーマンスを発揮するコードは、多くの場合、デバイス化されたループを使用することで達成されます。</target>
        </trans-unit>
        <trans-unit id="01878b8d1b390512d629c49ff65589c19ca63ad8" translate="yes" xml:space="preserve">
          <source>In a linear-algebra context, this means that even though operations like &lt;code&gt;vector + vector&lt;/code&gt; and &lt;code&gt;vector * scalar&lt;/code&gt; are defined, it can be advantageous to instead use &lt;code&gt;vector .+ vector&lt;/code&gt; and &lt;code&gt;vector .* scalar&lt;/code&gt; because the resulting loops can be fused with surrounding computations. For example, consider the two functions:</source>
          <target state="translated">線形代数のコンテキストでは、これは、 &lt;code&gt;vector + vector&lt;/code&gt; および &lt;code&gt;vector * scalar&lt;/code&gt; ような演算が定義されていても、結果として生じるループが周囲の計算と融合できるため、代わりに &lt;code&gt;vector .+ vector&lt;/code&gt; および &lt;code&gt;vector .* scalar&lt;/code&gt; 使用することが有利になる場合があることを意味します。たとえば、次の2つの関数を考えます。</target>
        </trans-unit>
        <trans-unit id="9e1d6d725f550ad6f9da6bf98cc247f18f2108d6" translate="yes" xml:space="preserve">
          <source>In a local scope, all variables are inherited from its parent global scope block unless:</source>
          <target state="translated">ローカルスコープでは、すべての変数は親グローバルスコープブロックから継承されます。</target>
        </trans-unit>
        <trans-unit id="8fb94127a63695dc8bd7c2b91c9aa1704119e38b" translate="yes" xml:space="preserve">
          <source>In a module, declare that the file specified by &lt;code&gt;path&lt;/code&gt; (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.</source>
          <target state="translated">モジュールで、 &lt;code&gt;path&lt;/code&gt; （相対または絶対）で指定されたファイルがプリコンパイルの依存関係であることを宣言します。つまり、このファイルが変更された場合、モジュールを再コンパイルする必要があります。</target>
        </trans-unit>
        <trans-unit id="ba39320cdec145895823bcc997669a25a6af7855" translate="yes" xml:space="preserve">
          <source>In a sense, Julia falls into the &quot;no automatic promotion&quot; category: mathematical operators are just functions with special syntax, and the arguments of functions are never automatically converted. However, one may observe that applying mathematical operations to a wide variety of mixed argument types is just an extreme case of polymorphic multiple dispatch &amp;ndash; something which Julia's dispatch and type systems are particularly well-suited to handle. &quot;Automatic&quot; promotion of mathematical operands simply emerges as a special application: Julia comes with pre-defined catch-all dispatch rules for mathematical operators, invoked when no specific implementation exists for some combination of operand types. These catch-all rules first promote all operands to a common type using user-definable promotion rules, and then invoke a specialized implementation of the operator in question for the resulting values, now of the same type. User-defined types can easily participate in this promotion system by defining methods for conversion to and from other types, and providing a handful of promotion rules defining what types they should promote to when mixed with other types.</source>
          <target state="translated">ある意味では、ジュリアは「自動昇格なし」のカテゴリに分類されます。数学演算子は特別な構文を持つ関数であり、関数の引数が自動的に変換されることはありません。ただし、多種多様な混合引数型に数学演算を適用することは、多態的な複数のディスパッチの極端なケースにすぎないことに気づくかもしれません。これは、ジュリアのディスパッチおよび型システムが特に処理するのに適しています。数学的オペランドの「自動」プロモーションは、特別なアプリケーションとして出現します。Juliaには、オペランドの型の特定の組み合わせの特定の実装が存在しないときに呼び出される、数学的演算子の定義済みキャッチオールディスパッチルールが付属しています。これらのキャッチオールルールは、最初に、ユーザー定義可能なプロモーションルールを使用して、すべてのオペランドを共通の型にプロモートします。次に、結果として同じ値の結果の値に対して、問題の演算子の特殊な実装を呼び出します。ユーザー定義タイプは、他のタイプとの間の変換方法を定義し、他のタイプと混合したときにどのタイプにプロモートするかを定義する少数のプロモーションルールを提供することにより、このプロモーションシステムに簡単に参加できます。</target>
        </trans-unit>
        <trans-unit id="18e44910a826a7be9fd86ad6a5c3ed3f73d517fa" translate="yes" xml:space="preserve">
          <source>In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations of many common and useful linear algebra operations which can be loaded with &lt;code&gt;using LinearAlgebra&lt;/code&gt;. Basic operations, such as &lt;a href=&quot;#LinearAlgebra.tr&quot;&gt;&lt;code&gt;tr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;inv&lt;/code&gt; are all supported:</source>
          <target state="translated">Juliaは、多次元配列のサポートに加えて（およびその一部として）、 &lt;code&gt;using LinearAlgebra&lt;/code&gt; を使用してロードできる多くの一般的で有用な線形代数演算のネイティブ実装を提供します。&lt;a href=&quot;#LinearAlgebra.tr&quot;&gt; &lt;code&gt;tr&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;inv&lt;/code&gt; などの基本的な操作はすべてサポートされています。</target>
        </trans-unit>
        <trans-unit id="f10487aa88c806dfd44fdee05bfc7281d910b478" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;, a few other basic functions are needed to use tasks effectively.</source>
          <target state="translated">&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;に加えて、タスクを効果的に使用するには、いくつかの他の基本的な関数が必要です。</target>
        </trans-unit>
        <trans-unit id="f2ab7ee40bd53e11319399c116d8d2cc2c48169d" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;using Base&lt;/code&gt;, modules also automatically contain definitions of the &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.MainInclude.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt; functions, which evaluate expressions/files within the global scope of that module.</source>
          <target state="translated">&lt;code&gt;using Base&lt;/code&gt; 加えて、モジュールには&lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../base/base/index#Base.MainInclude.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt;関数の定義が自動的に含まれ、そのモジュールのグローバルスコープ内で式/ファイルを評価します。</target>
        </trans-unit>
        <trans-unit id="10d21e803c8a9917ec9f0f6ebe5595e193060fc6" translate="yes" xml:space="preserve">
          <source>In addition to all the iterable and indexable methods from above, these types can also interact with each other and use most of the methods defined in Julia Base for &lt;code&gt;AbstractArrays&lt;/code&gt;:</source>
          <target state="translated">上記のすべての反復可能およびインデックス付け可能なメソッドに加えて、これらのタイプは互いに相互作用し、Julia Base for &lt;code&gt;AbstractArrays&lt;/code&gt; で定義されているほとんどのメソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="e406211c0c63c531f5fd9ccb75f3528a5be0658c" translate="yes" xml:space="preserve">
          <source>In addition to linear indexing, an &lt;code&gt;N&lt;/code&gt;-dimensional array may be indexed with fewer or more than &lt;code&gt;N&lt;/code&gt; indices in certain situations.</source>
          <target state="translated">線形インデックス付けに加えて、特定の状況では、 &lt;code&gt;N&lt;/code&gt; 次元配列に &lt;code&gt;N&lt;/code&gt; インデックスより少ないまたは多いインデックスを付けることができます。</target>
        </trans-unit>
        <trans-unit id="98e86e056613a088089dad092fe39f17f798108b" translate="yes" xml:space="preserve">
          <source>In addition to tasks Julia forwards natively supports multi-threading. Note that this section is experimental and the interfaces may change in the future.</source>
          <target state="translated">タスクに加えて、Julia forwards はマルチスレッドをネイティブにサポートしています。このセクションは実験的なものであり、将来的にインターフェースが変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ec666f0e17f38401053d73ee95bfc69ad9a82cc3" translate="yes" xml:space="preserve">
          <source>In addition to the given argument list, every macro is passed extra arguments named &lt;code&gt;__source__&lt;/code&gt; and &lt;code&gt;__module__&lt;/code&gt;.</source>
          <target state="translated">指定された引数リストに加えて、すべてのマクロには &lt;code&gt;__source__&lt;/code&gt; および &lt;code&gt;__module__&lt;/code&gt; という名前の追加の引数が渡されます。</target>
        </trans-unit>
        <trans-unit id="24215bb3919d42188faab69329d0bd6705349ee5" translate="yes" xml:space="preserve">
          <source>In addition, Julia provides many &lt;a href=&quot;#man-linalg-factorizations-1&quot;&gt;factorizations&lt;/a&gt; which can be used to speed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See the documentation on &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; for more information. As an example:</source>
          <target state="translated">さらに、Juliaは多くの&lt;a href=&quot;#man-linalg-factorizations-1&quot;&gt;因数分解&lt;/a&gt;を提供します。これを使用して、行列を問題に対して（パフォーマンスまたはメモリ上の理由から）より扱いやすい形式に事前因数分解することにより、線形解や行列のべき乗などの問題を高速化できます。詳細については、&lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; &lt;/a&gt;のドキュメントを参照してください。例として：</target>
        </trans-unit>
        <trans-unit id="655d29ad2536f5920e2f78273e9aa1a0a062ab22" translate="yes" xml:space="preserve">
          <source>In all cases the ambiguity is resolved in favor of interpretation as numeric literals:</source>
          <target state="translated">いずれの場合も、曖昧さは数値リテラルとして解釈することに有利に解決される。</target>
        </trans-unit>
        <trans-unit id="73ededace2cf23e632ef0400ebd52a78d322cb00" translate="yes" xml:space="preserve">
          <source>In all of the above modes, the executed lines get saved to a history file, which can be searched. To initiate an incremental search through the previous history, type &lt;code&gt;^R&lt;/code&gt; &amp;ndash; the control key together with the &lt;code&gt;r&lt;/code&gt; key. The prompt will change to &lt;code&gt;(reverse-i-search)`':&lt;/code&gt;, and as you type the search query will appear in the quotes. The most recent result that matches the query will dynamically update to the right of the colon as more is typed. To find an older result using the same query, simply type &lt;code&gt;^R&lt;/code&gt; again.</source>
          <target state="translated">上記のすべてのモードで、実行された行は履歴ファイルに保存され、検索できます。以前の履歴を介してインクリメンタル検索を開始するには、 &lt;code&gt;^R&lt;/code&gt; &amp;ndash;コントロールキーと &lt;code&gt;r&lt;/code&gt; キーを入力します。プロンプトが &lt;code&gt;(reverse-i-search)`':&lt;/code&gt; に変わり、入力すると検索クエリが引用符で囲まれて表示されます。クエリに一致する最新の結果は、さらに入力すると、コロンの右側に動的に更新されます。同じクエリを使用して古い結果を見つけるには、もう一度 &lt;code&gt;^R&lt;/code&gt; と入力します。</target>
        </trans-unit>
        <trans-unit id="486b6c3b28f75c69ec1138bc26e8cd5e151040ee" translate="yes" xml:space="preserve">
          <source>In all of these cases, &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; ultimately operates on a &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; object, which is in charge of queueing and restarting tasks. When a task calls &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt;, the task is marked as non-runnable, added to the condition's queue, and switches to the scheduler. The scheduler will then pick another task to run, or block waiting for external events. If all goes well, eventually an event handler will call &lt;a href=&quot;../../base/parallel/index#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; on the condition, which causes tasks waiting for that condition to become runnable again.</source>
          <target state="translated">これらすべてのケースで、&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;最終的に、タスクのキューイングと再起動を担当する&lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt;オブジェクトで動作します。タスクコールが&lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt;で&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;する場合、タスクは実行不可としてマークされ、条件のキューに追加され、スケジューラに切り替わります。スケジューラーは、実行する別のタスクを選択するか、外部イベントの待機をブロックします。すべてが順調に進むと、最終的にイベントハンドラーが条件に対して&lt;a href=&quot;../../base/parallel/index#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt;を呼び出し、その条件を待機しているタスクが再び実行可能になります。</target>
        </trans-unit>
        <trans-unit id="a3a06ca6a5caa39934e953da1e9f4336d389c6e0" translate="yes" xml:space="preserve">
          <source>In all these cases, &lt;code&gt;x&lt;/code&gt; is bound to a tuple of the trailing values passed to &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">これらすべての場合で、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;bar&lt;/code&gt; に渡される後続の値のタプルにバインドされます。</target>
        </trans-unit>
        <trans-unit id="b99ce256d318c1c2f2354f48619a6804a821c4e0" translate="yes" xml:space="preserve">
          <source>In an all-to-all topology (the default), all workers connect to each other via plain TCP sockets. The security policy on the cluster nodes must thus ensure free connectivity between workers for the ephemeral port range (varies by OS).</source>
          <target state="translated">all-to-all トポロジ(デフォルト)では、すべてのワーカーはプレーンTCPソケットを介して相互に接続します。このため、クラスタノードのセキュリティポリシーは、(OSによって異なりますが)エフェメラルポート範囲のワーカー間の自由な接続性を確保する必要があります。</target>
        </trans-unit>
        <trans-unit id="3c8cda3e1e2865b38c43f81658a24d808d5fe92a" translate="yes" xml:space="preserve">
          <source>In both Julia and MATLAB, the variable &lt;code&gt;ans&lt;/code&gt; is set to the value of the last expression issued in an interactive session. In Julia, unlike MATLAB, &lt;code&gt;ans&lt;/code&gt; is not set when Julia code is run in non-interactive mode.</source>
          <target state="translated">JuliaとMATLABの両方で、変数 &lt;code&gt;ans&lt;/code&gt; はインタラクティブセッションで発行された最後の式の値に設定されます。 Juliaでは、MATLABとは異なり、Juliaコードが非インタラクティブモードで実行されている場合、 &lt;code&gt;ans&lt;/code&gt; は設定されません。</target>
        </trans-unit>
        <trans-unit id="b8e4ada1bafffe80f21502163f1a66167c6265bb" translate="yes" xml:space="preserve">
          <source>In both the Julian and help modes of the REPL, one can enter the first few characters of a function or type and then press the tab key to get a list all matches:</source>
          <target state="translated">REPLのジュリアンとヘルプモードの両方で、1つは、関数またはタイプの最初の数文字を入力してから、すべての一致するリストを取得するためにタブキーを押すことができます。</target>
        </trans-unit>
        <trans-unit id="661336deabc49d6bd089fab9e0056b342efe5561" translate="yes" xml:space="preserve">
          <source>In case of remote references, the size of the local reference object is quite small, while the value stored on the remote node may be quite large. Since the local object may not be collected immediately, it is a good practice to explicitly call &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt; on local instances of a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;, or on unfetched &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s. Since calling &lt;code&gt;fetch&lt;/code&gt; on a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; also removes its reference from the remote store, this is not required on fetched &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s. Explicitly calling &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt; results in an immediate message sent to the remote node to go ahead and remove its reference to the value.</source>
          <target state="translated">リモート参照の場合、ローカル参照オブジェクトのサイズは非常に小さく、リモートノードに格納されている値は非常に大きい場合があります。ローカルオブジェクトはすぐに収集されない可能性があるため、&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; の&lt;/a&gt;ローカルインスタンスまたはフェッチされていない&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;で&lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt; &lt;code&gt;finalize&lt;/code&gt; &lt;/a&gt;を明示的に呼び出すことをお勧めします。呼び出し以来 &lt;code&gt;fetch&lt;/code&gt; に&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;、リモートストアからその参照を削除し、これはフェッチに必要とされていない&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;の。&lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt; &lt;code&gt;finalize&lt;/code&gt; &lt;/a&gt;を明示的に呼び出すと、リモートノードに即時メッセージが送信され、値への参照が削除されます。</target>
        </trans-unit>
        <trans-unit id="bf07799a9aab60dca9abdd6af2de0083f4fd55f9" translate="yes" xml:space="preserve">
          <source>In cases where &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; would need to take a Julia object and turn it into a &lt;code&gt;Ptr&lt;/code&gt;, this function should be used to define and perform that conversion.</source>
          <target state="translated">&lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;がJuliaオブジェクトを取得して &lt;code&gt;Ptr&lt;/code&gt; に変換する必要がある場合、この関数を使用して、その変換を定義および実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="62d2a9fdaaf73a0db81376306b368d8784225fa7" translate="yes" xml:space="preserve">
          <source>In cases where &lt;code&gt;x&lt;/code&gt; cannot be safely converted to &lt;code&gt;T&lt;/code&gt;, unlike &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;cconvert&lt;/code&gt; may return an object of a type different from &lt;code&gt;T&lt;/code&gt;, which however is suitable for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; to handle. The result of this function should be kept valid (for the GC) until the result of &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; is not needed anymore. This can be used to allocate memory that will be accessed by the &lt;code&gt;ccall&lt;/code&gt;. If multiple objects need to be allocated, a tuple of the objects can be used as return value.</source>
          <target state="translated">ケースでは &lt;code&gt;x&lt;/code&gt; 安全に変換できない &lt;code&gt;T&lt;/code&gt; とは異なり&lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;cconvert&lt;/code&gt; はからタイプ別のオブジェクトを返すことができる &lt;code&gt;T&lt;/code&gt; が適している、&lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt;ハンドルを。この関数の結果は、&lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt;の結果が不要になるまで（GCに対して）有効なままにしておく必要があります。これは、 &lt;code&gt;ccall&lt;/code&gt; がアクセスするメモリを割り当てるために使用できます。複数のオブジェクトを割り当てる必要がある場合は、オブジェクトのタプルを戻り値として使用できます。</target>
        </trans-unit>
        <trans-unit id="20a6a008693353a3bba07852d46b5ac7a61ffe13" translate="yes" xml:space="preserve">
          <source>In cases where you want to be able to mix multiple &lt;code&gt;AbstractArrayStyle&lt;/code&gt;s and keep track of dimensionality, your style needs to support a &lt;a href=&quot;../base/index#Base.Val&quot;&gt;&lt;code&gt;Val&lt;/code&gt;&lt;/a&gt; constructor:</source>
          <target state="translated">複数の &lt;code&gt;AbstractArrayStyle&lt;/code&gt; を混合して次元を追跡できるようにする場合は、スタイルで&lt;a href=&quot;../base/index#Base.Val&quot;&gt; &lt;code&gt;Val&lt;/code&gt; &lt;/a&gt;コンストラクタをサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="371183813ad83fb61979b332a5033cb1b76e325b" translate="yes" xml:space="preserve">
          <source>In code that performs state changes or uses resources like files, there is typically clean-up work (such as closing files) that needs to be done when the code is finished. Exceptions potentially complicate this task, since they can cause a block of code to exit before reaching its normal end. The &lt;code&gt;finally&lt;/code&gt; keyword provides a way to run some code when a given block of code exits, regardless of how it exits.</source>
          <target state="translated">状態の変更を実行するコードやファイルなどのリソースを使用するコードでは、通常、コードの終了時に実行する必要があるクリーンアップ作業（ファイルを閉じるなど）があります。例外は、コードブロックが正常に終了する前に終了する可能性があるため、このタスクを複雑にする可能性があります。 &lt;code&gt;finally&lt;/code&gt; 、キーワードのコード出口の与えられたブロックにかかわらず、それが出てどのように、いくつかのコードを実行する方法を提供します。</target>
        </trans-unit>
        <trans-unit id="439d8b30359bbc8d6b7d18a09ea082d188e37311" translate="yes" xml:space="preserve">
          <source>In contrast to the use of the &lt;code&gt;...&lt;/code&gt; operator to denote slurping many different arguments into one argument when defining a function, the &lt;code&gt;...&lt;/code&gt; operator is also used to cause a single function argument to be split apart into many different arguments when used in the context of a function call. This use of &lt;code&gt;...&lt;/code&gt; is called splatting:</source>
          <target state="translated">関数を定義するときに &lt;code&gt;...&lt;/code&gt; 演算子を使用して多くの異なる引数を1つの引数に丸めることを示すのとは対照的に、 &lt;code&gt;...&lt;/code&gt; 演算子は、単一の関数引数を使用時に複数の異なる引数に分割するためにも使用されます関数呼び出しのコンテキスト。この &lt;code&gt;...&lt;/code&gt; の使用はスプラッティングと呼ばれます。</target>
        </trans-unit>
        <trans-unit id="9c8f753b1f6a1a771efd3464599b303870131486" translate="yes" xml:space="preserve">
          <source>In contrast with &lt;code&gt;for i = 1:length(A)&lt;/code&gt;, iterating with &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; provides an efficient way to iterate over any array type.</source>
          <target state="translated">&lt;code&gt;for i = 1:length(A)&lt;/code&gt; とは対照的に、&lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt;での反復は、あらゆる配列型を反復する効率的な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="7142e8f2e408ab35102cc379780cf0e33b4e8234" translate="yes" xml:space="preserve">
          <source>In contrast, once &lt;code&gt;m&lt;/code&gt; is constructed, the type of &lt;code&gt;m.a&lt;/code&gt; cannot change:</source>
          <target state="translated">対照的に、 &lt;code&gt;m&lt;/code&gt; が作成されると、 &lt;code&gt;m.a&lt;/code&gt; のタイプは変更できません。</target>
        </trans-unit>
        <trans-unit id="0d5137a043d33963d37d01766416ca959609cfd8" translate="yes" xml:space="preserve">
          <source>In general you can place a &lt;code&gt;return&lt;/code&gt; statement anywhere within a function body, including within deeply nested loops or conditionals, but be careful with &lt;code&gt;do&lt;/code&gt; blocks. For example:</source>
          <target state="translated">一般に、深くネストされたループや条件文など、関数本体内の任意の場所に &lt;code&gt;return&lt;/code&gt; ステートメントを配置できますが、 &lt;code&gt;do&lt;/code&gt; ブロックには注意してください。例えば：</target>
        </trans-unit>
        <trans-unit id="c2d6d0431d403e66982fc3bf0664898813b75b58" translate="yes" xml:space="preserve">
          <source>In general, a broadcast operation is represented by a lazy &lt;code&gt;Broadcasted&lt;/code&gt; container that holds onto the function to be applied alongside its arguments. Those arguments may themselves be more nested &lt;code&gt;Broadcasted&lt;/code&gt; containers, forming a large expression tree to be evaluated. A nested tree of &lt;code&gt;Broadcasted&lt;/code&gt; containers is directly constructed by the implicit dot syntax; &lt;code&gt;5 .+ 2.*x&lt;/code&gt; is transiently represented by &lt;code&gt;Broadcasted(+, 5, Broadcasted(*, 2, x))&lt;/code&gt;, for example. This is invisible to users as it is immediately realized through a call to &lt;code&gt;copy&lt;/code&gt;, but it is this container that provides the basis for broadcast's extensibility for authors of custom types. The built-in broadcast machinery will then determine the result type and size based upon the arguments, allocate it, and then finally copy the realization of the &lt;code&gt;Broadcasted&lt;/code&gt; object into it with a default &lt;code&gt;copyto!(::AbstractArray, ::Broadcasted)&lt;/code&gt; method. The built-in fallback &lt;code&gt;broadcast&lt;/code&gt; and &lt;code&gt;broadcast!&lt;/code&gt; methods similarly construct a transient &lt;code&gt;Broadcasted&lt;/code&gt; representation of the operation so they can follow the same codepath. This allows custom array implementations to provide their own &lt;code&gt;copyto!&lt;/code&gt; specialization to customize and optimize broadcasting. This is again determined by the computed broadcast style. This is such an important part of the operation that it is stored as the first type parameter of the &lt;code&gt;Broadcasted&lt;/code&gt; type, allowing for dispatch and specialization.</source>
          <target state="translated">一般に、ブロードキャスト操作は、引数とともに適用される関数を保持する遅延 &lt;code&gt;Broadcasted&lt;/code&gt; コンテナで表されます。これらの引数自体は、ネストされた &lt;code&gt;Broadcasted&lt;/code&gt; コンテナであり、評価される大きな式ツリーを形成します。 &lt;code&gt;Broadcasted&lt;/code&gt; コンテナのネストされたツリーは、暗黙のドット構文によって直接構築されます。 &lt;code&gt;5 .+ 2.*x&lt;/code&gt; は、たとえば &lt;code&gt;Broadcasted(+, 5, Broadcasted(*, 2, x))&lt;/code&gt; によって一時的に表されます。これは、 &lt;code&gt;copy&lt;/code&gt; の呼び出しを通じてすぐに認識されるため、ユーザーには見えません。ですが、カスタムタイプの作成者にブロードキャストの拡張性の基礎を提供するのはこのコンテナです。組み込みのブロードキャスト機構は、引数に基づいて結果のタイプとサイズを決定し、それを割り当て、最後にデフォルトの &lt;code&gt;copyto!(::AbstractArray, ::Broadcasted)&lt;/code&gt; メソッドを使用して &lt;code&gt;Broadcasted&lt;/code&gt; オブジェクトの実現をそれにコピーします。内蔵のフォールバック &lt;code&gt;broadcast&lt;/code&gt; と &lt;code&gt;broadcast!&lt;/code&gt; メソッドは同様に、操作の一時的な &lt;code&gt;Broadcasted&lt;/code&gt; 表現を構築するため、同じコードパスをたどることができます。これにより、カスタム配列実装が独自の &lt;code&gt;copyto!&lt;/code&gt; を提供できるようになります。放送をカスタマイズおよび最適化する専門分野。これも、計算されたブロードキャストスタイルによって決定されます。これは、 &lt;code&gt;Broadcasted&lt;/code&gt; 型の最初の型パラメーターとして格納される操作の重要な部分であり、ディスパッチと特殊化を可能にします。</target>
        </trans-unit>
        <trans-unit id="8d1babd281f2e672316bf23dea36c5ab29827a0a" translate="yes" xml:space="preserve">
          <source>In general, if you have &lt;code&gt;N&lt;/code&gt; samples collected at a line, you can expect an uncertainty on the order of &lt;code&gt;sqrt(N)&lt;/code&gt; (barring other sources of noise, like how busy the computer is with other tasks). The major exception to this rule is garbage collection, which runs infrequently but tends to be quite expensive. (Since Julia's garbage collector is written in C, such events can be detected using the &lt;code&gt;C=true&lt;/code&gt; output mode described below, or by using &lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;ProfileView.jl&lt;/a&gt;.)</source>
          <target state="translated">一般に、ラインで &lt;code&gt;N&lt;/code&gt; 個のサンプルを収集した場合、 &lt;code&gt;sqrt(N)&lt;/code&gt; の次数の不確実性が予想されます（コンピューターが他のタスクでビジー状態であることなど、他のノイズソースを除く）。このルールの主な例外はガベージコレクションです。ガベージコレクションは実行頻度は低いですが、かなり高価になる傾向があります。 （JuliaのガベージコレクターはCで記述されているため、このようなイベントは、以下で説明する &lt;code&gt;C=true&lt;/code&gt; 出力モードを使用して、または&lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;ProfileView.jl&lt;/a&gt;を使用して検出できます。）</target>
        </trans-unit>
        <trans-unit id="efbd7c168e8e9417f99b66ae892e749285151330" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;for&lt;/code&gt; loop construct can iterate over any container. In these cases, the alternative (but fully equivalent) keyword &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;&amp;isin;&lt;/code&gt; is typically used instead of &lt;code&gt;=&lt;/code&gt;, since it makes the code read more clearly:</source>
          <target state="translated">一般に、 &lt;code&gt;for&lt;/code&gt; ループ構造は任意のコンテナーに対して反復できます。これらのケースでは、代替的な（しかし、完全に等価）はキーワード &lt;code&gt;in&lt;/code&gt; 又は &lt;code&gt;&amp;isin;&lt;/code&gt; 典型的に使用される代わりの &lt;code&gt;=&lt;/code&gt; は、コードがより明確に読み取ることができるので、：</target>
        </trans-unit>
        <trans-unit id="e63801e02d1bdf10fcfad068986ce15007cba3d8" translate="yes" xml:space="preserve">
          <source>In general, the Julia backtick syntax is carefully designed so that you can just cut-and-paste shell commands as is into backticks and they will work: the escaping, quoting, and interpolation behaviors are the same as the shell's. The only difference is that the interpolation is integrated and aware of Julia's notion of what is a single string value, and what is a container for multiple values. Let's try the above two examples in Julia:</source>
          <target state="translated">一般的に、Julia のバックティック構文は注意深く設計されており、シェルコマンドをそのままバックティックにカットアンドペーストするだけで動作します:エスケープ、クォート、補間の動作はシェルのものと同じです。唯一の違いは、補間が統合されており、何が単一の文字列の値で、何が複数の値のためのコンテナであるかというジュリアの概念を認識していることです。上記2つの例をJuliaで試してみましょう。</target>
        </trans-unit>
        <trans-unit id="e9d0a19dc1691ca7e9543783f1a58a636105f54f" translate="yes" xml:space="preserve">
          <source>In general, unlike many other technical computing languages, Julia does not expect programs to be written in a vectorized style for performance. Julia's compiler uses type inference and generates optimized code for scalar array indexing, allowing programs to be written in a style that is convenient and readable, without sacrificing performance, and using less memory at times.</source>
          <target state="translated">一般的に、他の多くの技術的な計算言語とは異なり、Juliaは性能を犠牲にすることなく、プログラムがベクトル化されたスタイルで書かれることを期待していません。Julia のコンパイラは型推論を使用し、スカラ配列のインデキシングのために最適化されたコードを生成するので、プログラムを便利で読みやすいスタイルで書くことができ、性能を犠牲にすることなく、時には少ないメモリ使用量でプログラムを書くことができます。</target>
        </trans-unit>
        <trans-unit id="0aca2d8ec448ee15667ecd2efa9a783d316a76f6" translate="yes" xml:space="preserve">
          <source>In general, you cannot assume that &lt;code&gt;display&lt;/code&gt; output goes to &lt;code&gt;stdout&lt;/code&gt; (unlike &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print(x)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt;). For example, &lt;code&gt;display(x)&lt;/code&gt; may open up a separate window with an image. &lt;code&gt;display(x)&lt;/code&gt; means &quot;show &lt;code&gt;x&lt;/code&gt; in the best way you can for the current output device(s).&quot; If you want REPL-like text output that is guaranteed to go to &lt;code&gt;stdout&lt;/code&gt;, use &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">一般に、（&lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print(x)&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; &lt;/a&gt;とは異なり） &lt;code&gt;display&lt;/code&gt; 出力が &lt;code&gt;stdout&lt;/code&gt; に送られるとは想定できません。たとえば、 &lt;code&gt;display(x)&lt;/code&gt; は画像を含む別のウィンドウを開く場合があります。 &lt;code&gt;display(x)&lt;/code&gt; は、「 &lt;code&gt;x&lt;/code&gt; を現在の出力デバイスに対して可能な限り最良の方法で表示する」ことを意味します。あなたがしたい場合はREPLのように移動することが保証されてテキスト出力 &lt;code&gt;stdout&lt;/code&gt; 、使用&lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt; &lt;/a&gt;代わりに。</target>
        </trans-unit>
        <trans-unit id="421d35772a37767957f94e34c887a2a8d79cd54e" translate="yes" xml:space="preserve">
          <source>In interpreting the results, there are a few important details. Under the &lt;code&gt;user&lt;/code&gt; setting, the first line of any function directly called from the REPL will exhibit allocation due to events that happen in the REPL code itself. More significantly, JIT-compilation also adds to allocation counts, because much of Julia's compiler is written in Julia (and compilation usually requires memory allocation). The recommended procedure is to force compilation by executing all the commands you want to analyze, then call &lt;a href=&quot;../../stdlib/profile/index#Profile.clear_malloc_data&quot;&gt;&lt;code&gt;Profile.clear_malloc_data()&lt;/code&gt;&lt;/a&gt; to reset all allocation counters. Finally, execute the desired commands and quit Julia to trigger the generation of the &lt;code&gt;.mem&lt;/code&gt; files.</source>
          <target state="translated">結果の解釈には、いくつかの重要な詳細があります。下では &lt;code&gt;user&lt;/code&gt; 設定、直接REPLから呼び出される任意の関数の最初の行が原因REPLコード自体に発生するイベントへの割り当てを示すであろう。さらに重要なことに、Juliaのコンパイラの多くはJuliaで記述されているため（通常、コンパイルにはメモリの割り当てが必要です）、JITコンパイルによって割り当て数も増えます。推奨される手順は、分析するすべてのコマンドを実行してコンパイルを強制し、&lt;a href=&quot;../../stdlib/profile/index#Profile.clear_malloc_data&quot;&gt; &lt;code&gt;Profile.clear_malloc_data()&lt;/code&gt; &lt;/a&gt;を呼び出してすべての割り当てカウンターをリセットすることです。最後に、必要なコマンドを実行してJuliaを終了し、 &lt;code&gt;.mem&lt;/code&gt; ファイルの生成をトリガーします。</target>
        </trans-unit>
        <trans-unit id="76e2766644f11aec36d4590582770e2731974fc5" translate="yes" xml:space="preserve">
          <source>In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have named functions associated with them, and the combination is called an &quot;object&quot;. In purer object-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are composites or not. In less pure object oriented languages, including C++ and Java, some values, such as integers and floating-point values, are not objects, while instances of user-defined composite types are true objects with associated methods. In Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of a function to use by multiple dispatch, meaning that the types of &lt;em&gt;all&lt;/em&gt; of a function's arguments are considered when selecting a method, rather than just the first one (see &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt; for more information on methods and dispatch). Thus, it would be inappropriate for functions to &quot;belong&quot; to only their first argument. Organizing methods into function objects rather than having named bags of methods &quot;inside&quot; each object ends up being a highly beneficial aspect of the language design.</source>
          <target state="translated">C ++、Java、Python、Rubyなどの主流のオブジェクト指向言語では、複合型にも名前付き関数が関連付けられており、その組み合わせは「オブジェクト」と呼ばれます。 RubyやSmalltalkなどの純粋なオブジェクト指向言語では、すべての値は、コンポジットであるかどうかに関係なくオブジェクトです。 C ++やJavaなどのそれほど純粋ではないオブジェクト指向言語では、整数や浮動小数点値などの一部の値はオブジェクトではありませんが、ユーザー定義の複合型のインスタンスは、関連するメソッドを持つ真のオブジェクトです。 Juliaでは、すべての値はオブジェクトですが、関数は、それらが操作するオブジェクトにバンドルされていません。これはつまり、どの複数派遣して、使用する機能の方法ジュリア選択しますので、必要があるのタイプ&lt;em&gt;すべて&lt;/em&gt;関数を選択するときは、最初の引数ではなく、関数の引数の1つが考慮されます（メソッドとディスパッチの詳細については、&lt;a href=&quot;../methods/index#Methods-1&quot;&gt;メソッド&lt;/a&gt;を参照してください）。したがって、関数が最初の引数だけに「所属する」ことは不適切です。メソッドの名前付きバッグを各オブジェクトの「内部」に持つのではなく、メソッドを関数オブジェクトに編成すると、言語設計の非常に有益な側面になります。</target>
        </trans-unit>
        <trans-unit id="eae8b05ff1c12682f8c0f5b0dacd56bde327dcb6" translate="yes" xml:space="preserve">
          <source>In many cases there are in-place versions of matrix operations that allow you to supply a pre-allocated output vector or matrix. This is useful when optimizing critical code in order to avoid the overhead of repeated allocations. These in-place operations are suffixed with &lt;code&gt;!&lt;/code&gt; below (e.g. &lt;code&gt;mul!&lt;/code&gt;) according to the usual Julia convention.</source>
          <target state="translated">多くの場合、事前に割り当てられた出力ベクトルまたは行列を提供できる行列演算のインプレースバージョンがあります。これは、繰り返し割り当てのオーバーヘッドを回避するために重要なコードを最適化するときに役立ちます。これらのインプレース操作には、末尾に &lt;code&gt;!&lt;/code&gt; 通常のJuliaの慣例に従って、以下（例 &lt;code&gt;mul!&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1ed441529eec7f43ad66971217220df4ecd80a6e" translate="yes" xml:space="preserve">
          <source>In many cases, Julia is able to automatically vectorize inner for loops without the use of &lt;code&gt;@simd&lt;/code&gt;. Using &lt;code&gt;@simd&lt;/code&gt; gives the compiler a little extra leeway to make it possible in more situations. In either case, your inner loop should have the following properties to allow vectorization:</source>
          <target state="translated">多くの場合、Juliaは &lt;code&gt;@simd&lt;/code&gt; を使用せずに内部forループを自動的にベクトル化できます。 &lt;code&gt;@simd&lt;/code&gt; を使用すると、より多くの状況でそれを可能にするためにコンパイラに少し余分な余裕が与えられます。どちらの場合でも、ベクトル化を可能にするには、内部ループに次のプロパティが必要です。</target>
        </trans-unit>
        <trans-unit id="36269174e578550d7d7f0601c4aea1c6ce0438f9" translate="yes" xml:space="preserve">
          <source>In many cases, function arguments have sensible default values and therefore might not need to be passed explicitly in every call. For example, the function &lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt;&lt;code&gt;Date(y, [m, d])&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;Dates&lt;/code&gt; module constructs a &lt;code&gt;Date&lt;/code&gt; type for a given year &lt;code&gt;y&lt;/code&gt;, month &lt;code&gt;m&lt;/code&gt; and day &lt;code&gt;d&lt;/code&gt;. However, &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; arguments are optional and their default value is &lt;code&gt;1&lt;/code&gt;. This behavior can be expressed concisely as:</source>
          <target state="translated">多くの場合、関数の引数には適切なデフォルト値があるため、すべての呼び出しで明示的に渡す必要がない場合があります。たとえば、 &lt;code&gt;Dates&lt;/code&gt; モジュールの関数&lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt; &lt;code&gt;Date(y, [m, d])&lt;/code&gt; &lt;/a&gt;は、指定された年 &lt;code&gt;y&lt;/code&gt; 、月 &lt;code&gt;m&lt;/code&gt; 、日 &lt;code&gt;d&lt;/code&gt; の &lt;code&gt;Date&lt;/code&gt; 型を作成します。ただし、 &lt;code&gt;m&lt;/code&gt; および &lt;code&gt;d&lt;/code&gt; 引数はオプションであり、それらのデフォルト値は &lt;code&gt;1&lt;/code&gt; です。この動作は、次のように簡潔に表現できます。</target>
        </trans-unit>
        <trans-unit id="1dd343721288798b24ab9ba3f9547e7ac41c164d" translate="yes" xml:space="preserve">
          <source>In many cases, it is redundant to provide the type of &lt;code&gt;Point&lt;/code&gt; object one wants to construct, since the types of arguments to the constructor call already implicitly provide type information. For that reason, you can also apply &lt;code&gt;Point&lt;/code&gt; itself as a constructor, provided that the implied value of the parameter type &lt;code&gt;T&lt;/code&gt; is unambiguous:</source>
          <target state="translated">多くの場合、コンストラクタ呼び出しへの引数の型はすでに暗黙的に型情報を提供しているため、構築したい &lt;code&gt;Point&lt;/code&gt; オブジェクトの型を提供することは冗長です。そのため、パラメーター型 &lt;code&gt;T&lt;/code&gt; の暗黙の値が明確であれば、 &lt;code&gt;Point&lt;/code&gt; 自体をコンストラクターとして適用することもできます。</target>
        </trans-unit>
        <trans-unit id="269254287f284598e6e04a282963713d5ef0932c" translate="yes" xml:space="preserve">
          <source>In many cases, the resolution specified for rounding (e.g., &lt;code&gt;Dates.Second(30)&lt;/code&gt;) divides evenly into the next largest period (in this case, &lt;code&gt;Dates.Minute(1)&lt;/code&gt;). But rounding behaviour in cases in which this is not true may lead to confusion. What is the expected result of rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to the nearest 10 hours?</source>
          <target state="translated">多くの場合、丸めに指定された解像度（たとえば、 &lt;code&gt;Dates.Second(30)&lt;/code&gt; ）は、次に大きい期間（この場合は、 &lt;code&gt;Dates.Minute(1)&lt;/code&gt; ）に均等に分割されます。しかし、これが当てはまらない場合の丸め動作は、混乱を招く可能性があります。&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;を最も近い10時間に丸めた場合の予想される結果は何ですか？</target>
        </trans-unit>
        <trans-unit id="619846970e9e167e4db1b981435711d687bd4ed9" translate="yes" xml:space="preserve">
          <source>In many languages with optional type declarations, adding declarations is the principal way to make code run faster. This is &lt;em&gt;not&lt;/em&gt; the case in Julia. In Julia, the compiler generally knows the types of all function arguments, local variables, and expressions. However, there are a few specific instances where declarations are helpful.</source>
          <target state="translated">オプションの型宣言を持つ多くの言語では、宣言を追加することがコードをより速く実行するための主要な方法です。これはジュリアには当てはまり&lt;em&gt;ません&lt;/em&gt;。 Juliaでは、コンパイラーは通常、すべての関数引数、ローカル変数、および式のタイプを認識しています。ただし、宣言が役立つ特定のインスタンスがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="9450b748dbcdb8ba9fd42add95485312cab4012f" translate="yes" xml:space="preserve">
          <source>In mathematics, &lt;code&gt;+&lt;/code&gt; usually denotes a &lt;em&gt;commutative&lt;/em&gt; operation, where the order of the operands does not matter. An example of this is matrix addition, where &lt;code&gt;A + B == B + A&lt;/code&gt; for any matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; that have the same shape. In contrast, &lt;code&gt;*&lt;/code&gt; typically denotes a &lt;em&gt;noncommutative&lt;/em&gt; operation, where the order of the operands &lt;em&gt;does&lt;/em&gt; matter. An example of this is matrix multiplication, where in general &lt;code&gt;A * B != B * A&lt;/code&gt;. As with matrix multiplication, string concatenation is noncommutative: &lt;code&gt;greet * whom != whom * greet&lt;/code&gt;. As such, &lt;code&gt;*&lt;/code&gt; is a more natural choice for an infix string concatenation operator, consistent with common mathematical use.</source>
          <target state="translated">数学では、 &lt;code&gt;+&lt;/code&gt; は通常、&lt;em&gt;可換&lt;/em&gt;演算を示し、オペランドの順序は重要ではありません。この例は、行列の加算です。ここで、 &lt;code&gt;A + B == B + A&lt;/code&gt; は、同じ形状を持つすべての行列 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; に対応しています。対照的に、 &lt;code&gt;*&lt;/code&gt; は通常、&lt;em&gt;非可換&lt;/em&gt;演算を示し、オペランドの順序&lt;em&gt;が&lt;/em&gt;重要になります。これの例は、一般的に &lt;code&gt;A * B != B * A&lt;/code&gt; である行列乗算です。行列の乗算と同様に、文字列の連結は非可換です： &lt;code&gt;greet * whom != whom * greet&lt;/code&gt; 。そのため、 &lt;code&gt;*&lt;/code&gt; 中置文字列連結演算子のより自然な選択であり、一般的な数学的使用と一致しています。</target>
        </trans-unit>
        <trans-unit id="ab8bd1f7589c990d976c1051b69449b020a43727" translate="yes" xml:space="preserve">
          <source>In more complex cases, resolving method ambiguities involves a certain element of design; this topic is explored further &lt;a href=&quot;#man-method-design-ambiguities-1&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">より複雑なケースでは、メソッドのあいまいさの解決には、設計の特定の要素が含まれます。このトピックについては、&lt;a href=&quot;#man-method-design-ambiguities-1&quot;&gt;以下で&lt;/a&gt;詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="be4d8bd032078d1d618f689c7b9a8339132970a1" translate="yes" xml:space="preserve">
          <source>In most cases, if &lt;code&gt;A&lt;/code&gt; is a subtype &lt;code&gt;S&lt;/code&gt; of &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; with an element type &lt;code&gt;T&lt;/code&gt; supporting &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;, the return type is &lt;code&gt;LU{T,S{T}}&lt;/code&gt;. If pivoting is chosen (default) the element type should also support &lt;code&gt;abs&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;A&lt;/code&gt; が &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; サブタイプ &lt;code&gt;S&lt;/code&gt; であり、要素型 &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; および &lt;code&gt;/&lt;/code&gt; をサポートしている場合、戻り値の型は &lt;code&gt;LU{T,S{T}}&lt;/code&gt; です。ピボットが選択されている場合（デフォルト）、要素タイプは &lt;code&gt;abs&lt;/code&gt; および &lt;code&gt;&amp;lt;&lt;/code&gt; もサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="c01897c1c5dfe56ff403bf92da50402dc901b089" translate="yes" xml:space="preserve">
          <source>In order to access the data of x, we can use &lt;code&gt;jl_array_data&lt;/code&gt;:</source>
          <target state="translated">xのデータにアクセスするには、 &lt;code&gt;jl_array_data&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="1c8c964572487783a93c9f805bd24c6191a24c97" translate="yes" xml:space="preserve">
          <source>In order to build this program you have to put the path to the Julia header into the include path and link against &lt;code&gt;libjulia&lt;/code&gt;. For instance, when Julia is installed to &lt;code&gt;$JULIA_DIR&lt;/code&gt;, one can compile the above test program &lt;code&gt;test.c&lt;/code&gt; with &lt;code&gt;gcc&lt;/code&gt; using:</source>
          <target state="translated">このプログラムをビルドするには、Juliaヘッダーへのパスをインクルードパスに入れ、 &lt;code&gt;libjulia&lt;/code&gt; にリンクする必要があります。たとえば、Juliaが &lt;code&gt;$JULIA_DIR&lt;/code&gt; にインストールされている場合、上記のテストプログラム &lt;code&gt;test.c&lt;/code&gt; を &lt;code&gt;gcc&lt;/code&gt; を使用してコンパイルできます。</target>
        </trans-unit>
        <trans-unit id="f634f39fd97c0fd5eaef9dfae9571e089a9c4f67" translate="yes" xml:space="preserve">
          <source>In order to check whether &lt;code&gt;ret&lt;/code&gt; is of a specific Julia type, we can use the &lt;code&gt;jl_isa&lt;/code&gt;, &lt;code&gt;jl_typeis&lt;/code&gt;, or &lt;code&gt;jl_is_...&lt;/code&gt; functions. By typing &lt;code&gt;typeof(sqrt(2.0))&lt;/code&gt; into the Julia shell we can see that the return type is &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;double&lt;/code&gt; in C). To convert the boxed Julia value into a C double the &lt;code&gt;jl_unbox_float64&lt;/code&gt; function is used in the above code snippet.</source>
          <target state="translated">&lt;code&gt;ret&lt;/code&gt; が特定のJuliaタイプであるかどうかを確認するには、 &lt;code&gt;jl_isa&lt;/code&gt; 、 &lt;code&gt;jl_typeis&lt;/code&gt; 、または &lt;code&gt;jl_is_...&lt;/code&gt; 関数を使用できます。Juliaシェルに &lt;code&gt;typeof(sqrt(2.0))&lt;/code&gt; と入力すると、戻り値の型が&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;（Cでは &lt;code&gt;double&lt;/code&gt; )であることがわかります。ボックス化されたジュリア値をCに変換するには、上記のコードスニペットで &lt;code&gt;jl_unbox_float64&lt;/code&gt; 関数を使用します。</target>
        </trans-unit>
        <trans-unit id="c26dfd25e758364e0dcd1c617a188ec51d32baad" translate="yes" xml:space="preserve">
          <source>In order to compute trigonometric functions with degrees instead of radians, suffix the function with &lt;code&gt;d&lt;/code&gt;. For example, &lt;a href=&quot;../../base/math/index#Base.Math.sind&quot;&gt;&lt;code&gt;sind(x)&lt;/code&gt;&lt;/a&gt; computes the sine of &lt;code&gt;x&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is specified in degrees. The complete list of trigonometric functions with degree variants is:</source>
          <target state="translated">ラジアンの代わりに次数を含む三角関数を計算するには、関数の後に &lt;code&gt;d&lt;/code&gt; を付けます。たとえば、&lt;a href=&quot;../../base/math/index#Base.Math.sind&quot;&gt; &lt;code&gt;sind(x)&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;x&lt;/code&gt; の正弦を計算します。ここで、 &lt;code&gt;x&lt;/code&gt; は度数で指定されます。次数バリアントを含む三角関数の完全なリストは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="f65b6a7038eae90009481c5aaae33e0c39a02ac4" translate="yes" xml:space="preserve">
          <source>In order to define a new display backend, one should first create a subtype &lt;code&gt;D&lt;/code&gt; of the abstract class &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt;&lt;code&gt;AbstractDisplay&lt;/code&gt;&lt;/a&gt;. Then, for each MIME type (&lt;code&gt;mime&lt;/code&gt; string) that can be displayed on &lt;code&gt;D&lt;/code&gt;, one should define a function &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; that displays &lt;code&gt;x&lt;/code&gt; as that MIME type, usually by calling &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;show(io, mime, x)&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;repr(io, mime, x)&lt;/code&gt;. A &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; should be thrown if &lt;code&gt;x&lt;/code&gt; cannot be displayed as that MIME type; this is automatic if one calls &lt;code&gt;show&lt;/code&gt; or &lt;code&gt;repr&lt;/code&gt;. Finally, one should define a function &lt;code&gt;display(d::D, x)&lt;/code&gt; that queries &lt;a href=&quot;#Base.Multimedia.showable&quot;&gt;&lt;code&gt;showable(mime, x)&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;mime&lt;/code&gt; types supported by &lt;code&gt;D&lt;/code&gt; and displays the &quot;best&quot; one; a &lt;code&gt;MethodError&lt;/code&gt; should be thrown if no supported MIME types are found for &lt;code&gt;x&lt;/code&gt;. Similarly, some subtypes may wish to override &lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt;&lt;code&gt;redisplay(d::D, ...)&lt;/code&gt;&lt;/a&gt;. (Again, one should &lt;code&gt;import Base.display&lt;/code&gt; to add new methods to &lt;code&gt;display&lt;/code&gt;.) The return values of these functions are up to the implementation (since in some cases it may be useful to return a display &quot;handle&quot; of some type). The display functions for &lt;code&gt;D&lt;/code&gt; can then be called directly, but they can also be invoked automatically from &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; simply by pushing a new display onto the display-backend stack with:</source>
          <target state="translated">新しい表示バックエンドを定義するには、まず抽象クラス&lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt; &lt;code&gt;AbstractDisplay&lt;/code&gt; の&lt;/a&gt;サブタイプ &lt;code&gt;D&lt;/code&gt; を作成する必要があります。次に、 &lt;code&gt;D&lt;/code&gt; に表示できる各MIMEタイプ（ &lt;code&gt;mime&lt;/code&gt; 文字列）に対して &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; をそのMIMEタイプとして表示する関数display（d :: D、:: MIME &quot;mime&quot;、x）= ...を定義する必要があります。通常は、&lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;show(io, mime, x)&lt;/code&gt; &lt;/a&gt;または &lt;code&gt;repr(io, mime, x)&lt;/code&gt; 呼び出します。 A &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; は&lt;/a&gt;場合にスローされるべきで &lt;code&gt;x&lt;/code&gt; そのMIMEタイプとして表示することはできません。これは、 &lt;code&gt;show&lt;/code&gt; または &lt;code&gt;repr&lt;/code&gt; を呼び出すと自動的に行われます。最後に、関数 &lt;code&gt;display(d::D, x)&lt;/code&gt; を定義する必要があります &lt;code&gt;D&lt;/code&gt; でサポートされている &lt;code&gt;mime&lt;/code&gt; タイプについて&lt;a href=&quot;#Base.Multimedia.showable&quot;&gt; &lt;code&gt;showable(mime, x)&lt;/code&gt; &lt;/a&gt;を照会し、「最高」のものを表示します。 &lt;code&gt;x&lt;/code&gt; でサポートされているMIMEタイプが見つからない場合は、 &lt;code&gt;MethodError&lt;/code&gt; がスローされます。同様に、一部のサブタイプは&lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt; &lt;code&gt;redisplay(d::D, ...)&lt;/code&gt; &lt;/a&gt;をオーバーライドしたい場合があります。 （繰り返しますが、 &lt;code&gt;import Base.display&lt;/code&gt; をインポートして、 &lt;code&gt;display&lt;/code&gt; する新しいメソッドを追加する必要があります。）これらの関数の戻り値は実装次第です（場合によっては、あるタイプのディスプレイ「ハンドル」を返すことが役立つ場合があるため）。その後、 &lt;code&gt;D&lt;/code&gt; の表示関数を直接呼び出すことができますが、&lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt;から自動的に呼び出すこともできます。 新しいディスプレイをディスプレイバックエンドスタックにプッシュするだけです。</target>
        </trans-unit>
        <trans-unit id="e0fa42e97ec0c0f5639428f8bc25c0313c261f3b" translate="yes" xml:space="preserve">
          <source>In order to dispatch a multi-level parametric argument list, often it is best to separate each level of dispatch into distinct functions. This may sound similar in approach to single-dispatch, but as we shall see below, it is still more flexible.</source>
          <target state="translated">マルチレベルのパラメトリック引数リストをディスパッチするためには、多くの場合、各レベルのディスパッチを別々の関数に分離するのがベストです。これはシングルディスパッチと似たようなアプローチに聞こえるかもしれませんが、後述するように、この方がより柔軟性があります。</target>
        </trans-unit>
        <trans-unit id="c64f4c986b251a9a23920c12ed0e829f663e97f9" translate="yes" xml:space="preserve">
          <source>In order to implement such a &lt;code&gt;copy&lt;/code&gt; or &lt;code&gt;copyto!&lt;/code&gt;, method, of course, you must work with the &lt;code&gt;Broadcasted&lt;/code&gt; wrapper to compute each element. There are two main ways of doing so:</source>
          <target state="translated">そのような &lt;code&gt;copy&lt;/code&gt; または &lt;code&gt;copyto!&lt;/code&gt; を実装するために！もちろん、各要素を計算するには、 &lt;code&gt;Broadcasted&lt;/code&gt; ラッパーを使用する必要があります。これには主に2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="7c65ae2a5b36599056aee26d3163a0e9101f727b" translate="yes" xml:space="preserve">
          <source>In order to losslessly represent arbitrary byte streams stored in a &lt;code&gt;String&lt;/code&gt;, a &lt;code&gt;Char&lt;/code&gt; value may store information that cannot be converted to a Unicode codepoint &amp;mdash; converting such a &lt;code&gt;Char&lt;/code&gt; to &lt;code&gt;UInt32&lt;/code&gt; will throw an error. The &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;isvalid(c::Char)&lt;/code&gt;&lt;/a&gt; function can be used to query whether &lt;code&gt;c&lt;/code&gt; represents a valid Unicode character.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; に格納された任意のバイトストリームをロスレスで表すために、 &lt;code&gt;Char&lt;/code&gt; 値はUnicodeコードポイントに変換できない情報を格納する場合があります。このような &lt;code&gt;Char&lt;/code&gt; を &lt;code&gt;UInt32&lt;/code&gt; に変換するとエラーがスローされます。&lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;isvalid(c::Char)&lt;/code&gt; &lt;/a&gt;関数は、かどうかを照会するために使用することができます &lt;code&gt;c&lt;/code&gt; が有効なUnicode文字を表します。</target>
        </trans-unit>
        <trans-unit id="fab91460cbe612949b4b9d95753296ca7abe3d3b" translate="yes" xml:space="preserve">
          <source>In order to pass this function to C, we obtain its address using the macro &lt;code&gt;@cfunction&lt;/code&gt;:</source>
          <target state="translated">この関数をCに渡すために、マクロ &lt;code&gt;@cfunction&lt;/code&gt; を使用してそのアドレスを取得します。</target>
        </trans-unit>
        <trans-unit id="cd5618b4a563dff2d7a927d5353ef78a361df290" translate="yes" xml:space="preserve">
          <source>In order to refer to &lt;code&gt;MyType&lt;/code&gt; across all processes, &lt;code&gt;DummyModule.jl&lt;/code&gt; needs to be loaded on every process. Calling &lt;code&gt;include(&quot;DummyModule.jl&quot;)&lt;/code&gt; loads it only on a single process. To load it on every process, use the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@everywhere&quot;&gt;&lt;code&gt;@everywhere&lt;/code&gt;&lt;/a&gt; macro (starting Julia with &lt;code&gt;julia -p 2&lt;/code&gt;):</source>
          <target state="translated">参照するためには &lt;code&gt;MyType&lt;/code&gt; すべてのプロセス間で、 &lt;code&gt;DummyModule.jl&lt;/code&gt; は、すべてのプロセスにロードする必要があります。 &lt;code&gt;include(&quot;DummyModule.jl&quot;)&lt;/code&gt; を呼び出すと、単一のプロセスでのみロードされます。すべてのプロセスでロードするには、&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@everywhere&quot;&gt; &lt;code&gt;@everywhere&lt;/code&gt; &lt;/a&gt;マクロを使用します（juliaをjulia &lt;code&gt;julia -p 2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="47f30e462ec98fcc58c9494bb836f85ec8257aff" translate="yes" xml:space="preserve">
          <source>In order to support mutation, such objects are generally allocated on the heap, and have stable memory addresses. A mutable object is like a little container that might hold different values over time, and so can only be reliably identified with its address. In contrast, an instance of an immutable type is associated with specific field values &amp;ndash;- the field values alone tell you everything about the object. In deciding whether to make a type mutable, ask whether two instances with the same field values would be considered identical, or if they might need to change independently over time. If they would be considered identical, the type should probably be immutable.</source>
          <target state="translated">変更をサポートするために、このようなオブジェクトは通常ヒープに割り当てられ、安定したメモリアドレスを持っています。変更可能なオブジェクトは、時間の経過とともに異なる値を保持する可能性のある小さなコンテナーのようなものであり、そのアドレスでのみ確実に識別できます。対照的に、不変タイプのインスタンスは特定のフィールド値に関連付けられています。フィールド値だけでオブジェクトに関するすべてを知ることができます。型を変更可能にするかどうかを決定する際には、同じフィールド値を持つ2つのインスタンスが同一であると見なされるか、または時間の経過とともに独立して変更する必要があるかどうかを尋ねます。それらが同一であると見なされる場合、タイプはおそらく不変でなければなりません。</target>
        </trans-unit>
        <trans-unit id="2f2293a5b64eabd8ff88bd22ea606404b9b1e108" translate="yes" xml:space="preserve">
          <source>In other circumstances, it is handy to be able to stop an iteration and move on to the next one immediately. The &lt;code&gt;continue&lt;/code&gt; keyword accomplishes this:</source>
          <target state="translated">他の状況では、イテレーションを停止してすぐに次のイテレーションに進むことができると便利です。 &lt;code&gt;continue&lt;/code&gt; キーワードは、これを達成します：</target>
        </trans-unit>
        <trans-unit id="c004c636d1b0703eca9cda2590edfd6579e7129c" translate="yes" xml:space="preserve">
          <source>In other words, &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt;&lt;code&gt;isa(A,Type{B})&lt;/code&gt;&lt;/a&gt; is true if and only if &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are the same object and that object is a type. Without the parameter, &lt;code&gt;Type&lt;/code&gt; is simply an abstract type which has all type objects as its instances, including, of course, singleton types:</source>
          <target state="translated">換言すれば、&lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt; &lt;code&gt;isa(A,Type{B})&lt;/code&gt; &lt;/a&gt;場合にのみ真である &lt;code&gt;A&lt;/code&gt; 及び &lt;code&gt;B&lt;/code&gt; は、同じオブジェクトであり、そのオブジェクトのタイプです。パラメーターがない場合、 &lt;code&gt;Type&lt;/code&gt; は、単純なタイプであり、インスタンスとしてすべてのタイプオブジェクトを持ちます。</target>
        </trans-unit>
        <trans-unit id="fb4e1a8fb772b24b6039451c201b81e5c718d91a" translate="yes" xml:space="preserve">
          <source>In other words, in the parlance of type theory, Julia's type parameters are &lt;em&gt;invariant&lt;/em&gt;, rather than being &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;covariant (or even contravariant)&lt;/a&gt;. This is for practical reasons: while any instance of &lt;code&gt;Point{Float64}&lt;/code&gt; may conceptually be like an instance of &lt;code&gt;Point{Real}&lt;/code&gt; as well, the two types have different representations in memory:</source>
          <target state="translated">言い換えると、型理論の用語では、ジュリアの型パラメーターは&lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;共変（または反変）&lt;/a&gt;ではなく&lt;em&gt;不変&lt;/em&gt;です。これは実際的な理由によるものです &lt;code&gt;Point{Float64}&lt;/code&gt; のインスタンスは概念的には &lt;code&gt;Point{Real}&lt;/code&gt; インスタンスのようでもありますが、2つのタイプのメモリ内の表現は異なります。</target>
        </trans-unit>
        <trans-unit id="2489400c16a870eb77390027298b5bae2afac7fd" translate="yes" xml:space="preserve">
          <source>In particular this means that overlong and too-high code unit sequences and prefixes thereof are treated as a single invalid character rather than multiple invalid characters. This rule may be best explained with an example:</source>
          <target state="translated">特に、これは、長すぎて高すぎるコードユニットシーケンス及びその接頭辞は、複数の無効な文字ではなく、1つの無効な文字として扱われることを意味する。この規則は、例を挙げて説明するのが最も良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="86e6d7b557572810776afd763390d8c87a4b9b3f" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; is typically a &quot;pretty-printed&quot; version of &lt;code&gt;x&lt;/code&gt; designed for human consumption. See also &lt;code&gt;repr(x)&lt;/code&gt; to instead return a string corresponding to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt; that may be closer to how the value of &lt;code&gt;x&lt;/code&gt; would be entered in Julia.</source>
          <target state="translated">特に、 &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; は、通常、人間が使用するために設計された &lt;code&gt;x&lt;/code&gt; の「かなり印刷された」バージョンです。Julia で &lt;code&gt;x&lt;/code&gt; の値がどのように入力されるかにより近い&lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; に&lt;/a&gt;対応する文字列を返すには、 &lt;code&gt;repr(x)&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="a352a9e712137ef0293428d01a95dc381f03f45f" translate="yes" xml:space="preserve">
          <source>In particular, if you define a &lt;code&gt;function __init__()&lt;/code&gt; in a module, then Julia will call &lt;code&gt;__init__()&lt;/code&gt; immediately &lt;em&gt;after&lt;/em&gt; the module is loaded (e.g., by &lt;code&gt;import&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt;, or &lt;code&gt;require&lt;/code&gt;) at runtime for the &lt;em&gt;first&lt;/em&gt; time (i.e., &lt;code&gt;__init__&lt;/code&gt; is only called once, and only after all statements in the module have been executed). Because it is called after the module is fully imported, any submodules or other imported modules have their &lt;code&gt;__init__&lt;/code&gt; functions called &lt;em&gt;before&lt;/em&gt; the &lt;code&gt;__init__&lt;/code&gt; of the enclosing module.</source>
          <target state="translated">具体的には、ユーザーが定義した場合 &lt;code&gt;function __init__()&lt;/code&gt; モジュールでは、その後、ジュリアが呼び出されます &lt;code&gt;__init__()&lt;/code&gt; すぐ&lt;em&gt;後に&lt;/em&gt;モジュールが（で、例えばロードされている &lt;code&gt;import&lt;/code&gt; 、 &lt;code&gt;using&lt;/code&gt; 、または &lt;code&gt;require&lt;/code&gt; ）実行時のための&lt;em&gt;最初&lt;/em&gt;の時間（すなわち、 &lt;code&gt;__init__&lt;/code&gt; があります1回だけ呼び出され、モジュール内のすべてのステートメントが実行された後にのみ呼び出されます）。モジュールが完全にインポートされた後に呼び出されるため、サブモジュールまたは他のインポートされたモジュールは、それらを囲むモジュールの &lt;code&gt;__init__&lt;/code&gt; の&lt;em&gt;前&lt;/em&gt;に呼び出される &lt;code&gt;__init__&lt;/code&gt; 関数を持っています。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f00fe64f586624c25d908def02434ca5a5747cc" translate="yes" xml:space="preserve">
          <source>In particular, note that &lt;code&gt;LibGit2.free&lt;/code&gt; should be called afterward on the &lt;code&gt;Ref&lt;/code&gt; object.</source>
          <target state="translated">特に、 &lt;code&gt;LibGit2.free&lt;/code&gt; は &lt;code&gt;Ref&lt;/code&gt; オブジェクトで後で呼び出す必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1b992ee319e3397f73ab42aa368ea422a279c258" translate="yes" xml:space="preserve">
          <source>In particular, note that &lt;code&gt;missing == missing&lt;/code&gt; returns &lt;code&gt;missing&lt;/code&gt;, so &lt;code&gt;==&lt;/code&gt; cannot be used to test whether a value is missing. To test whether &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;missing&lt;/code&gt;, use &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt;&lt;code&gt;ismissing(x)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">具体的には、なお、 &lt;code&gt;missing == missing&lt;/code&gt; 戻る &lt;code&gt;missing&lt;/code&gt; ので &lt;code&gt;==&lt;/code&gt; 値が欠落しているかどうかをテストするために使用することができません。 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;missing&lt;/code&gt; かどうかをテストするには、&lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt; &lt;code&gt;ismissing(x)&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="10aa2526d9c8eb28f8fc8b12b251cb66391f9afe" translate="yes" xml:space="preserve">
          <source>In particular, this means that small enough immutable values like integers and floats are typically passed to functions in registers (or stack allocated).</source>
          <target state="translated">特に、これは、整数や浮動小数点数のような十分に小さい不変値が、一般的にレジスタ内の関数に渡されることを意味します(または、スタックが割り当てられている)。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
