<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="rxjs">
    <body>
      <group id="rxjs">
        <trans-unit id="392ce755360743798adc6f37abf60a01a85dac13" translate="yes" xml:space="preserve">
          <source>&quot;Complete&quot; notification: does not send a value.</source>
          <target state="translated">&quot;Complete&quot; 通知:値を送信しません。</target>
        </trans-unit>
        <trans-unit id="c81d9f638ee0e1bf38fde281d7d0722e5ae02890" translate="yes" xml:space="preserve">
          <source>&quot;Creation&quot; operators The following operators have been moved from &lt;code&gt;rxjs/operators&lt;/code&gt; to &lt;code&gt;rxjs&lt;/code&gt;, and their usage has changed:</source>
          <target state="translated">「創造」演算子以下の演算子から移動されました &lt;code&gt;rxjs/operators&lt;/code&gt; に &lt;code&gt;rxjs&lt;/code&gt; 、及びその使用方法が変更されました：</target>
        </trans-unit>
        <trans-unit id="3e7d16b53c2fad1237d23976a605c79f1b13451d" translate="yes" xml:space="preserve">
          <source>&quot;Error&quot; notification: sends a JavaScript Error or exception.</source>
          <target state="translated">&quot;Error&quot; 通知:JavaScript のエラーまたは例外を送信します。</target>
        </trans-unit>
        <trans-unit id="61ed1f5cc7d257c5a6fb114343a8ac81acd81a74" translate="yes" xml:space="preserve">
          <source>&quot;Marble Tests&quot; are tests that use a specialized VirtualScheduler called the &lt;code&gt;TestScheduler&lt;/code&gt;. They enable us to test asynchronous operations in a synchronous and dependable manner. The &quot;marble notation&quot; is something that's been adapted from many teachings and documents by people such as &lt;a href=&quot;https://twitter.com/jhusain&quot;&gt;@jhusain&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/headinthebox&quot;&gt;@headinthebox&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/mattpodwysocki&quot;&gt;@mattpodwysocki&lt;/a&gt; and &lt;a href=&quot;https://twitter.com/andrestaltz&quot;&gt;@andrestaltz&lt;/a&gt;. In fact, Andr&amp;eacute; Staltz first recommended this as a DSL for creating unit tests, and it has since been altered and adopted.</source>
          <target state="translated">「マーブルテスト」は、 &lt;code&gt;TestScheduler&lt;/code&gt; と呼ばれる特殊なVirtualSchedulerを使用するテストです。これにより、非同期操作を同期的かつ信頼できる方法でテストできます。「大理石の表記は」のような人々によって多くの教えや文書から適応されていますものです&lt;a href=&quot;https://twitter.com/jhusain&quot;&gt;@jhusain&lt;/a&gt;、&lt;a href=&quot;https://twitter.com/headinthebox&quot;&gt;@headinthebox&lt;/a&gt;、&lt;a href=&quot;https://twitter.com/mattpodwysocki&quot;&gt;@mattpodwysocki&lt;/a&gt;と&lt;a href=&quot;https://twitter.com/andrestaltz&quot;&gt;@andrestaltz&lt;/a&gt;。実際、Andr&amp;eacute;Staltzは最初に単体テストを作成するためのDSLとしてこれを推奨し、それ以来変更され採用されています。</target>
        </trans-unit>
        <trans-unit id="42a2c7dc9cd6a678723aae38fa9f03c7b8bf1f15" translate="yes" xml:space="preserve">
          <source>&quot;Next&quot; notification: sends a value such as a Number, a String, an Object, etc.</source>
          <target state="translated">&quot;Next&quot; 通知:数値、文字列、オブジェクトなどの値を送信します。</target>
        </trans-unit>
        <trans-unit id="cd753dbdc17c8e8263d11f9f804dab829f01e73e" translate="yes" xml:space="preserve">
          <source>&quot;Next&quot; notifications are the most important and most common type: they represent actual data being delivered to an subscriber. &quot;Error&quot; and &quot;Complete&quot; notifications may happen only once during the Observable Execution, and there can only be either one of them.</source>
          <target state="translated">&quot;Next&quot; 通知は最も重要で、最も一般的なタイプです。&quot;Error&quot; と &quot;Complete&quot; 通知は、Observable の実行中に一度だけ発生することがあり、どちらか一方しかありません。</target>
        </trans-unit>
        <trans-unit id="346adb0427f466457992cab12b66149214b60148" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2015&amp;ndash;2018 Google, Inc., Netflix, Inc., Microsoft Corp. and contributors.</source>
          <target state="translated">&amp;copy;2015&amp;ndash;2018 Google、Inc.、Netflix、Inc.、Microsoft Corp.および寄稿者。</target>
        </trans-unit>
        <trans-unit id="ec83739778c86aaa8e3c14cb62c33740056380aa" translate="yes" xml:space="preserve">
          <source>(The &lt;code&gt;pipe()&lt;/code&gt; function is analogous to, but not the same thing as, the &lt;code&gt;.pipe()&lt;/code&gt; method on an Observable.)</source>
          <target state="translated">（ &lt;code&gt;pipe()&lt;/code&gt; 関数は、Observableの &lt;code&gt;.pipe()&lt;/code&gt; メソッドに類似していますが、同じものではありません。）</target>
        </trans-unit>
        <trans-unit id="11fc77211983736b813c658ece601fdcc5bca5b3" translate="yes" xml:space="preserve">
          <source>// Logs: // 0 // 1 // 2 // &quot;Yo!&quot;</source>
          <target state="translated">//ログだ //0 //1 //2 //&quot;ヨ!&quot;</target>
        </trans-unit>
        <trans-unit id="413662e05fbda8a75422816345471abce134f0b2" translate="yes" xml:space="preserve">
          <source>// Logs: // 0 // 1000 // 2000 // &quot;Yo!&quot;</source>
          <target state="translated">//ログだ //0 //1000 //2000 //&quot;Yo!</target>
        </trans-unit>
        <trans-unit id="4cf7b3b0689dc3d62e361b359129706be46007b9" translate="yes" xml:space="preserve">
          <source>// Logs: // 0 // 1000 // 2000 // 3000 // ...and never stops.</source>
          <target state="translated">//ログだ //0 //1000 //2000 //3000 //...と止まることはありません。</target>
        </trans-unit>
        <trans-unit id="4932860fd63504b051ce368dbc339d987387b63a" translate="yes" xml:space="preserve">
          <source>1 frame is 10 virtual milliseconds by default. i.e. &lt;code&gt;TestScheduler.frameTimeFactor = 10&lt;/code&gt;</source>
          <target state="translated">デフォルトでは、1フレームは10仮想ミリ秒です。つまり、 &lt;code&gt;TestScheduler.frameTimeFactor = 10&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d65e71651123d00f13f6a1dd9134124f96f272f3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../api/operators/exhaust&quot;&gt;&lt;code&gt;exhaust()&lt;/code&gt;&lt;/a&gt; &amp;mdash; subscribes to the first inner Observable when it arrives, and emits each value as it arrives, discarding all newly arriving inner Observables until that first one completes, then waits for the next inner Observable.</source>
          <target state="translated">&lt;a href=&quot;../api/operators/exhaust&quot;&gt; &lt;code&gt;exhaust()&lt;/code&gt; &lt;/a&gt; &amp;mdash;到着時に最初の内部Observableをサブスクライブし、到着時に各値を発行し、最初に完了するまですべての新しく到着した内部Observableを破棄し、次の内部Observableを待ちます。</target>
        </trans-unit>
        <trans-unit id="7a7ea42cc6cca0849dbb1c78069f7e16487eadce" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../api/operators/mergeall&quot;&gt;&lt;code&gt;mergeAll()&lt;/code&gt;&lt;/a&gt; &amp;mdash; subscribes to each inner Observable as it arrives, then emits each value as it arrives</source>
          <target state="translated">&lt;a href=&quot;../api/operators/mergeall&quot;&gt; &lt;code&gt;mergeAll()&lt;/code&gt; &lt;/a&gt; &amp;mdash;到着時に各Observableをサブスクライブし、到着時に各値を発行します</target>
        </trans-unit>
        <trans-unit id="00d7dfe90d22907f84e2b9aa6d174c7093188de9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../api/operators/switchall&quot;&gt;&lt;code&gt;switchAll()&lt;/code&gt;&lt;/a&gt; &amp;mdash; subscribes to the first inner Observable when it arrives, and emits each value as it arrives, but when the next inner Observable arrives, unsubscribes to the previous one, and subscribes to the new one.</source>
          <target state="translated">&lt;a href=&quot;../api/operators/switchall&quot;&gt; &lt;code&gt;switchAll()&lt;/code&gt; &lt;/a&gt; &amp;mdash;到着時に最初の内部Observableをサブスクライブし、到着時に各値を発行しますが、次の内部Observableが到着すると、前の値をサブスクライブ解除し、新しい値をサブスクライブします。</target>
        </trans-unit>
        <trans-unit id="6a5210f0bf7d5b359aadf70cf0e45a3b962eba14" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../index/class/subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt; that communicates with a server via WebSocket</source>
          <target state="translated">&lt;a href=&quot;../index/class/subject&quot;&gt; &lt;code&gt;Subject&lt;/code&gt; &lt;/a&gt;WebSocketを介してサーバーと通信するサブジェクト</target>
        </trans-unit>
        <trans-unit id="058d6b50d45cc928153edc804bde7133ba593471" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;!&quot;&lt;/code&gt; unsubscription point: shows the point in time at which a subscription is unsubscribed.</source>
          <target state="translated">&lt;code&gt;&quot;!&quot;&lt;/code&gt; サブスクリプション解除ポイント：サブスクリプションがサブスクリプション解除される時点を示します。</target>
        </trans-unit>
        <trans-unit id="81a3ce5520c5667d66bf855b46c44589a826a0d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;#&quot;&lt;/code&gt; error: An error terminating the observable. This is the observable producer signaling &lt;code&gt;error()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;#&quot;&lt;/code&gt; エラー：オブザーバブルを終了するエラー。これは、 &lt;code&gt;error()&lt;/code&gt; を通知する観察可能なプロデューサーです</target>
        </trans-unit>
        <trans-unit id="107cfd640387781b75d0bb619e0d899ed5b34314" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;()&quot;&lt;/code&gt; sync groupings: When multiple events need to be in the same frame synchronously, parentheses are used to group those events. You can group nexted values, a completion or an error in this manner. The position of the initial &lt;code&gt;(&lt;/code&gt; determines the time at which its values are emitted.</source>
          <target state="translated">&lt;code&gt;&quot;()&quot;&lt;/code&gt; 同期のグループ化：複数のイベントを同じフレームに同期的に配置する必要がある場合、括弧を使用してそれらのイベントをグループ化します。このようにして、次の値、完了、またはエラーをグループ化できます。初期の位置は &lt;code&gt;(&lt;/code&gt; その値が放出される時間を決定します。</target>
        </trans-unit>
        <trans-unit id="064762d55524c322feeaa267de2dba55cae25836" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;-&quot;&lt;/code&gt; time: 10 &quot;frames&quot; of the passage.</source>
          <target state="translated">&lt;code&gt;&quot;-&quot;&lt;/code&gt; 時間：パッセージの10「フレーム」。</target>
        </trans-unit>
        <trans-unit id="8e080bce20eb3fc6c4946b152fe200b8a369f991" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;-&quot;&lt;/code&gt; time: 10 &quot;frames&quot; of time passage.</source>
          <target state="translated">&lt;code&gt;&quot;-&quot;&lt;/code&gt; 時間：時間経過の10「フレーム」。</target>
        </trans-unit>
        <trans-unit id="48a3e4768e9a2314ab6c955d210fda5eee9e16ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;^&quot;&lt;/code&gt; subscription point: (hot observables only) shows the point at which the tested observables will be subscribed to the hot observable. This is the &quot;zero frame&quot; for that observable, every frame before the &lt;code&gt;^&lt;/code&gt; will be negative.</source>
          <target state="translated">&lt;code&gt;&quot;^&quot;&lt;/code&gt; サブスクリプションポイント：（ホットオブザーバブルのみ）テストされたオブザーバブルがホットオブザーバブルにサブスクライブされるポイントを示します。これは、その観測可能オブジェクトの「ゼロフレーム」です。 &lt;code&gt;^&lt;/code&gt; の前のすべてのフレームは負になります。</target>
        </trans-unit>
        <trans-unit id="00e0999da09e1b7ac615beac5e032458d7eaeb8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;^&quot;&lt;/code&gt; subscription point: shows the point in time at which a subscription happen.</source>
          <target state="translated">&lt;code&gt;&quot;^&quot;&lt;/code&gt; サブスクリプションポイント：サブスクリプションが発生する時点を示します。</target>
        </trans-unit>
        <trans-unit id="42596687beb2a6b5b9594c84cc181a1c419f8a34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;a&quot;&lt;/code&gt; any character: All other characters represent a value being emitted by the producer signaling &lt;code&gt;next()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;a&quot;&lt;/code&gt; 任意の文字：他のすべての文字は、 &lt;code&gt;next()&lt;/code&gt; をシグナリングするプロデューサーによって発行される値を表します</target>
        </trans-unit>
        <trans-unit id="d0f4e7bf26a0b7700ddaf9f8256bbac86b3539a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;|&quot;&lt;/code&gt; complete: The successful completion of an observable. This is the observable producer signaling &lt;code&gt;complete()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;|&quot;&lt;/code&gt; complete：オブザーバブルの正常な完了。これは、 &lt;code&gt;complete()&lt;/code&gt; を通知する観測可能なプロデューサーです。</target>
        </trans-unit>
        <trans-unit id="264671634e07abdf4534265024ab55c7443d1523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&lt;/code&gt;: Equivalent to &lt;code&gt;Observable.throw()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; ： &lt;code&gt;Observable.throw()&lt;/code&gt; と同等</target>
        </trans-unit>
        <trans-unit id="826146bd4f6b3958dfa2716d8a103525afcd4809" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&lt;/code&gt;: Equivalent to &lt;code&gt;throwError()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; ： &lt;code&gt;throwError()&lt;/code&gt; と同等</target>
        </trans-unit>
        <trans-unit id="63834177a0d274bef046c96bd46b7d79ffa05fb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;' '&lt;/code&gt; whitespace: horizontal whitespace is ignored, and can be used to help vertically align multiple marble diagrams.</source>
          <target state="translated">&lt;code&gt;' '&lt;/code&gt; ホワイトスペース：水平ホワイトスペースは無視され、複数の大理石の図を垂直方向に整列させるために使用できます。</target>
        </trans-unit>
        <trans-unit id="6954e21ca9dfaa3f0526fc31dd9bb1ea892618cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'!'&lt;/code&gt; unsubscription point: shows the point in time at which a subscription is unsubscribed.</source>
          <target state="translated">&lt;code&gt;'!'&lt;/code&gt; サブスクリプション解除ポイント：サブスクリプションのサブスクリプションが解除される時点を示します。</target>
        </trans-unit>
        <trans-unit id="494cfb16dcf327f243341a9829050b41fdaaafa7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'#'&lt;/code&gt; error: An error terminating the observable. This is the observable producer signaling &lt;code&gt;error()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'#'&lt;/code&gt; エラー：オブザーバブルの終了エラー。これは、 &lt;code&gt;error()&lt;/code&gt; を通知する監視可能なプロデューサーです。</target>
        </trans-unit>
        <trans-unit id="900db5e390475e30c0b02294da8a016b0ba83ca6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'()'&lt;/code&gt; sync groupings: When multiple events need to be in the same frame synchronously, parentheses are used to group those events. You can group next'd values, a completion, or an error in this manner. The position of the initial &lt;code&gt;(&lt;/code&gt; determines the time at which its values are emitted. While it can be unintuitive at first, after all the values have synchronously emitted time will progress a number of frames equal to the number of ASCII characters in the group, including the parentheses. e.g. &lt;code&gt;'(abc)'&lt;/code&gt; will emit the values of a, b, and c synchronously in the same frame and then advance virtual time by 5 frames, &lt;code&gt;'(abc)'.length === 5&lt;/code&gt;. This is done because it often helps you vertically align your marble diagrams, but it's a known pain point in real-world testing. &lt;a href=&quot;marble-testing#known-issues&quot;&gt;Learn more about known issues&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;'()'&lt;/code&gt; 同期のグループ化：複数のイベントを同じフレームに同期的に配置する必要がある場合、括弧を使用してそれらのイベントをグループ化します。この方法で、次の値、完了、またはエラーをグループ化できます。初期の位置 &lt;code&gt;(&lt;/code&gt; その値が放出される時間を決定する。すべての値は、同期時間を出射された後、それは、最初は直感的であることができるがフレームの数を進行するなど、グループ内のASCII文字の数に等しいですかっこ。たとえば、 &lt;code&gt;'(abc)'&lt;/code&gt; は、a、b、cの値を同じフレームで同期的に放出し、仮想時間を5フレーム進めます &lt;code&gt;'(abc)'.length === 5&lt;/code&gt; 。これは、大理石の図を垂直方向に整列させるのに役立つことが多いためですが、実際のテストではそれが既知の問題点です。&lt;a href=&quot;marble-testing#known-issues&quot;&gt;既知の問題の詳細をご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd0ed6d06b7c0c50d7f1ded02adc8d9c93dc954e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; frame: 1 &quot;frame&quot; of virtual time passing (see above description of frames).</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; フレーム：仮想時間経過の1 &quot;フレーム&quot;（上記のフレームの説明を参照）。</target>
        </trans-unit>
        <trans-unit id="cd2274308e133d94aab4086c64348e0b9367d78f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'------'&lt;/code&gt;: Equivalent to &lt;code&gt;Observable.never()&lt;/code&gt;, or an observable that never emits or completes</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; または &lt;code&gt;'------'&lt;/code&gt; ： &lt;code&gt;Observable.never()&lt;/code&gt; と同等、または決して発行または完了しないオブザーバブル</target>
        </trans-unit>
        <trans-unit id="b9ddd2753c7382111307878ff965226a99935b81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'------'&lt;/code&gt;: Equivalent to &lt;code&gt;never()&lt;/code&gt;, or an observable that never emits or completes</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; または &lt;code&gt;'------'&lt;/code&gt; ： &lt;code&gt;never()&lt;/code&gt; と同等、または決して発生または完了しないオブザーバブル</target>
        </trans-unit>
        <trans-unit id="e85ff3d8ea96e01ddc94347b9770c2baafc5a3f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'------'&lt;/code&gt;: no subscription ever happened.</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; または &lt;code&gt;'------'&lt;/code&gt; ：サブスクリプションは発生しませんでした。</target>
        </trans-unit>
        <trans-unit id="b2deb15be9de4e952591a988c11249d643af1ab1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; time: 1 frame time passing.</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; 時間：1フレーム時間経過。</target>
        </trans-unit>
        <trans-unit id="90551104ab363bce845a980f30cb723fbc3d84ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--(abc)-|'&lt;/code&gt;: on frame 2 emit &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, then on frame 8 &lt;code&gt;complete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--(abc)-|'&lt;/code&gt; ：フレーム2 で &lt;code&gt;b&lt;/code&gt; 、b、 &lt;code&gt;c&lt;/code&gt; を放出 &lt;code&gt;a&lt;/code&gt; 、フレーム8で &lt;code&gt;complete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a66914cc904a1616e408742fcf744c2669d43dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--(abc)-|'&lt;/code&gt;: on frame 20, emit &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, then on frame 80 &lt;code&gt;complete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--(abc)-|'&lt;/code&gt; ：フレーム20で &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、および &lt;code&gt;c&lt;/code&gt; を放出し、フレーム80で &lt;code&gt;complete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fe548a294627e814b17d903dab9561a209e6a12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-----(a|)'&lt;/code&gt;: on frame 5 emit &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'-----(a|)'&lt;/code&gt; ：フレーム5で &lt;code&gt;a&lt;/code&gt; を発行し、を &lt;code&gt;complete&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="4fa0191fc2dbbdc24db47e31a6c21c2c4d99e31c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-----(a|)'&lt;/code&gt;: on frame 50, emit &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'-----(a|)'&lt;/code&gt; ：フレーム50で、 &lt;code&gt;a&lt;/code&gt; を発行して &lt;code&gt;complete&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="857d299688e4bc90586f9054240d4d4f9908447e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--^--!-'&lt;/code&gt;: on frame 2 a subscription happened, and on frame 5 was unsubscribed.</source>
          <target state="translated">&lt;code&gt;'--^--!-'&lt;/code&gt; ：フレーム2でサブスクリプションが発生し、フレーム5でサブスクリプションが解除されました。</target>
        </trans-unit>
        <trans-unit id="f7eb2910a933490ae2e8679f6e15b0ea2a86e24c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--^--!-'&lt;/code&gt;: on frame 20 a subscription happened, and on frame 50 was unsubscribed.</source>
          <target state="translated">&lt;code&gt;'--^--!-'&lt;/code&gt; ：フレーム20でサブスクリプションが発生し、フレーム50でサブスクリプションが解除されました。</target>
        </trans-unit>
        <trans-unit id="0006636d06083015f66b5db0ac8912f9ce320737" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--^--'&lt;/code&gt;: a subscription happened after 2 &quot;frames&quot; of time passed, and the subscription was not unsubscribed.</source>
          <target state="translated">&lt;code&gt;'--^--'&lt;/code&gt; ：サブスクリプションは2フレームの時間が経過した後に発生し、サブスクリプションは解除されませんでした。</target>
        </trans-unit>
        <trans-unit id="1f35221f2edb5714d1b0dc2c10a61f6aa4d5ec78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--^--'&lt;/code&gt;: a subscription happened after 20 &quot;frames&quot; of time passed, and the subscription was not unsubscribed.</source>
          <target state="translated">&lt;code&gt;'--^--'&lt;/code&gt; ：サブスクリプションは20フレームの時間が経過した後に発生し、サブスクリプションは解除されませんでした。</target>
        </trans-unit>
        <trans-unit id="5dc8c6bec3861c166b48135c76387c8aae72940a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a 2.5m b'&lt;/code&gt;: on frame 2 emit &lt;code&gt;a&lt;/code&gt;, on frame 150,003 emit &lt;code&gt;b&lt;/code&gt; and never complete.</source>
          <target state="translated">&lt;code&gt;'--a 2.5m b'&lt;/code&gt; ：フレーム2でaを放出 &lt;code&gt;a&lt;/code&gt; 、フレーム150,003で &lt;code&gt;b&lt;/code&gt; を放出し、決して完了しません。</target>
        </trans-unit>
        <trans-unit id="c518d60968c44900d3105e92d3ff56cbce420fb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--'&lt;/code&gt;: An observable that waits 2 &quot;frames&quot;, emits value &lt;code&gt;a&lt;/code&gt; and then never completes.</source>
          <target state="translated">&lt;code&gt;'--a--'&lt;/code&gt; ：2つの「フレーム」を待機し、値 &lt;code&gt;a&lt;/code&gt; を発行してから完了することはないオブザーバブル。</target>
        </trans-unit>
        <trans-unit id="e9a8a6bc5f8b8dc21df4a25f847e34ac915bf0ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--'&lt;/code&gt;: An observable that waits 20 &quot;frames&quot;, emits value &lt;code&gt;a&lt;/code&gt; and then never completes.</source>
          <target state="translated">&lt;code&gt;'--a--'&lt;/code&gt; ：20の「フレーム」を待機し、値 &lt;code&gt;a&lt;/code&gt; を発行してから完了しないオブザーバブル。</target>
        </trans-unit>
        <trans-unit id="558dc22b4c13f724e11da08b71a45c7a874aadbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--b--#'&lt;/code&gt;: On frame 2 emit &lt;code&gt;a&lt;/code&gt;, on frame 5 emit &lt;code&gt;b&lt;/code&gt;, and on frame 8, &lt;code&gt;error&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--a--b--#'&lt;/code&gt; ：フレーム2で &lt;code&gt;a&lt;/code&gt; を放出し、フレーム5で &lt;code&gt;b&lt;/code&gt; を放出し、フレーム8で &lt;code&gt;error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f66a0e5bb742deb080922072f07969bf8f5073f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--b--#'&lt;/code&gt;: On frame 20 emit &lt;code&gt;a&lt;/code&gt;, on frame 50 emit &lt;code&gt;b&lt;/code&gt;, and on frame 80, &lt;code&gt;error&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--a--b--#'&lt;/code&gt; EMITフレーム20について： &lt;code&gt;a&lt;/code&gt; フレーム50 EMITの上、 &lt;code&gt;b&lt;/code&gt; 、及びフレーム80に、 &lt;code&gt;error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1fbec99faa34f8d8c6178c17bdba6a6c88e1bc7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--b--|'&lt;/code&gt;: On frame 2 emit &lt;code&gt;a&lt;/code&gt;, on frame 5 emit &lt;code&gt;b&lt;/code&gt;, and on frame 8, &lt;code&gt;complete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--a--b--|'&lt;/code&gt; ：フレーム2で放出 &lt;code&gt;a&lt;/code&gt; 、フレーム5で放出 &lt;code&gt;b&lt;/code&gt; 、フレーム8で &lt;code&gt;complete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="011793c2617b3542600d252674d69a846c293e1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--b--|'&lt;/code&gt;: On frame 20 emit &lt;code&gt;a&lt;/code&gt;, on frame 50 emit &lt;code&gt;b&lt;/code&gt;, and on frame 80, &lt;code&gt;complete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--a--b--|'&lt;/code&gt; ：フレーム20で放出 &lt;code&gt;a&lt;/code&gt; 、フレーム50で放出 &lt;code&gt;b&lt;/code&gt; 、フレーム80で &lt;code&gt;complete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d571db83420af98e9c5810ad493278bf7ed45756" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-a-^-b--|'&lt;/code&gt;: In a hot observable, on frame -2 emit &lt;code&gt;a&lt;/code&gt;, then on frame 2 emit &lt;code&gt;b&lt;/code&gt;, and on frame 5, &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'-a-^-b--|'&lt;/code&gt; ：ホットオブザーバブルでは、フレーム-2で &lt;code&gt;a&lt;/code&gt; を放出し、次にフレーム2で &lt;code&gt;b&lt;/code&gt; を放出し、フレーム5で &lt;code&gt;complete&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="3c4be0daed0fe6a5f4a6444309f2485c8d7052a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-a-^-b--|'&lt;/code&gt;: In a hot observable, on frame -20 emit &lt;code&gt;a&lt;/code&gt;, then on frame 20 emit &lt;code&gt;b&lt;/code&gt;, and on frame 50, &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'-a-^-b--|'&lt;/code&gt; ：高温のオブザーバブルでは、フレーム-20で &lt;code&gt;a&lt;/code&gt; を放出し、次にフレーム20で &lt;code&gt;b&lt;/code&gt; を放出し、フレーム50でを &lt;code&gt;complete&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="e08758a3a46525c399cbbae215e45c0d5e4f18d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'500ms ^ 1s !'&lt;/code&gt;: on frame 500 a subscription happened, and on frame 1,501 was unsubscribed.</source>
          <target state="translated">&lt;code&gt;'500ms ^ 1s !'&lt;/code&gt; ：フレーム500でサブスクリプションが発生し、フレーム1,501でサブスクリプションが解除されました。</target>
        </trans-unit>
        <trans-unit id="3645e6c2789e746235dbb1a683c78f91316c0ff1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'^'&lt;/code&gt; subscription point: (hot observables only) shows the point at which the tested observables will be subscribed to the hot observable. This is the &quot;zero frame&quot; for that observable, every frame before the &lt;code&gt;^&lt;/code&gt; will be negative. Negative time might seem pointless, but there are in fact advanced cases where this is necessary, usually involving ReplaySubjects.</source>
          <target state="translated">&lt;code&gt;'^'&lt;/code&gt; サブスクリプションポイント：（ホットオブザーバブルのみ）テストされたオブザーバブルがホットオブザーバブルにサブスクライブされるポイントを示します。これは、その観測可能オブジェクトの「ゼロフレーム」です。 &lt;code&gt;^&lt;/code&gt; の前のすべてのフレームは負になります。負の時間は無意味に思えるかもしれませんが、実際には、これが必要になる高度なケースがあり、通常はReplaySubjectsが関係します。</target>
        </trans-unit>
        <trans-unit id="e08ffcab1613e5d26675b9934c425ca2aeaeb774" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'^'&lt;/code&gt; subscription point: shows the point in time at which a subscription happen.</source>
          <target state="translated">&lt;code&gt;'^'&lt;/code&gt; サブスクリプションポイント：サブスクリプションが発生する時点を示します。</target>
        </trans-unit>
        <trans-unit id="c9eec6341670ec1c6b1e9b19d18fdf631feeedf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'a 9ms b 9s c|'&lt;/code&gt;: on frame 0 emit &lt;code&gt;a&lt;/code&gt;, on frame 10 emit &lt;code&gt;b&lt;/code&gt;, on frame 10,012 emit &lt;code&gt;c&lt;/code&gt;, then on on frame 10,013 &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'a 9ms b 9s c|'&lt;/code&gt; ：フレーム0で放出 &lt;code&gt;a&lt;/code&gt; 、フレーム10で放出 &lt;code&gt;b&lt;/code&gt; 、フレーム10,012で放出 &lt;code&gt;c&lt;/code&gt; 、そしてフレーム10,013で &lt;code&gt;complete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52c23705b515df4c100f707c5889b869f7738d66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'|'&lt;/code&gt; complete: The successful completion of an observable. This is the observable producer signaling &lt;code&gt;complete()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'|'&lt;/code&gt; complete：オブザーバブルの正常な完了。これは、 &lt;code&gt;complete()&lt;/code&gt; を通知する監視可能なプロデューサーです。</target>
        </trans-unit>
        <trans-unit id="8ed8289c6915557851ae2fc185944335fcceab94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(...args: any[]) =&amp;gt; Observable&amp;lt;T&amp;gt;&lt;/code&gt;: A function which returns the Observable that delivers the same values the Node.js callback would deliver.</source>
          <target state="translated">&lt;code&gt;(...args: any[]) =&amp;gt; Observable&amp;lt;T&amp;gt;&lt;/code&gt; ：Node.jsコールバックが提供するのと同じ値を提供するObservableを返す関数。</target>
        </trans-unit>
        <trans-unit id="9af6c1ceaf17b75b780332cfb3ea76a28e668fd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(...args: any[]) =&amp;gt; Observable&amp;lt;T&amp;gt;&lt;/code&gt;: A function which returns the Observable that delivers the same values the callback would deliver.</source>
          <target state="translated">&lt;code&gt;(...args: any[]) =&amp;gt; Observable&amp;lt;T&amp;gt;&lt;/code&gt; ：コールバックが提供するのと同じ値を提供するObservableを返す関数。</target>
        </trans-unit>
        <trans-unit id="77f4a7aa096d066890cd4560eb8be8512c98b678" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; When using &lt;code&gt;elementAt(i)&lt;/code&gt;, it delivers an ArgumentOutOrRangeError to the Observer's &lt;code&gt;error&lt;/code&gt; callback if &lt;code&gt;i &amp;lt; 0&lt;/code&gt; or the Observable has completed before emitting the i-th &lt;code&gt;next&lt;/code&gt; notification.</source>
          <target state="translated">&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; &lt;code&gt;elementAt(i)&lt;/code&gt; を使用する場合、 &lt;code&gt;i &amp;lt; 0&lt;/code&gt; またはObservableが完了してからi番目の &lt;code&gt;next&lt;/code&gt; 通知を送信すると、ArgumentOutOrRangeErrorがオブザーバーの &lt;code&gt;error&lt;/code&gt; コールバックに配信されます。</target>
        </trans-unit>
        <trans-unit id="440326ab0df253e9d1a2baf16e42ef22aea1f82d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; When using &lt;code&gt;skipLast(i)&lt;/code&gt;, it throws ArgumentOutOrRangeError if &lt;code&gt;i &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; &lt;code&gt;skipLast(i)&lt;/code&gt; を使用する場合、 &lt;code&gt;i &amp;lt; 0&lt;/code&gt; 場合はArgumentOutOrRangeErrorをスローします。</target>
        </trans-unit>
        <trans-unit id="ab36e17fb5757f8497903f935e1060283fd57611" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; When using &lt;code&gt;take(i)&lt;/code&gt;, it delivers an ArgumentOutOrRangeError to the Observer's &lt;code&gt;error&lt;/code&gt; callback if &lt;code&gt;i &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; &lt;code&gt;take(i)&lt;/code&gt; を使用すると、 &lt;code&gt;i &amp;lt; 0&lt;/code&gt; 場合、ArgumentOutOrRangeErrorがオブザーバーの &lt;code&gt;error&lt;/code&gt; コールバックに配信されます。</target>
        </trans-unit>
        <trans-unit id="640ea84593ebfbf6d363bf5efc85c28283078a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; When using &lt;code&gt;takeLast(i)&lt;/code&gt;, it delivers an ArgumentOutOrRangeError to the Observer's &lt;code&gt;error&lt;/code&gt; callback if &lt;code&gt;i &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; &lt;code&gt;takeLast(i)&lt;/code&gt; を使用すると、 &lt;code&gt;i &amp;lt; 0&lt;/code&gt; 場合、ArgumentOutOrRangeErrorがオブザーバーの &lt;code&gt;error&lt;/code&gt; コールバックに配信されます。</target>
        </trans-unit>
        <trans-unit id="31e642c2f3e6b9f25cc4726681ae36498a69e080" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ConnectableObservable&lt;/code&gt; is hidden from direct use in v6 and is accessible only through operators &lt;code&gt;multicast&lt;/code&gt;, &lt;code&gt;publish&lt;/code&gt;, &lt;code&gt;publishReplay&lt;/code&gt;, and &lt;code&gt;publishLast&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ConnectableObservable&lt;/code&gt; は V6で直接使用から隠され、唯一の事業者を介してアクセスされる &lt;code&gt;multicast&lt;/code&gt; 、 &lt;code&gt;publish&lt;/code&gt; 、 &lt;code&gt;publishReplay&lt;/code&gt; を、そして &lt;code&gt;publishLast&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25628c7cfe20af88f31a364c509c719222e82f15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EmptyError&lt;/code&gt; Delivers an EmptyError to the Observer's &lt;code&gt;error&lt;/code&gt; callback if the Observable completes before any &lt;code&gt;next&lt;/code&gt; notification was sent.</source>
          <target state="translated">&lt;code&gt;EmptyError&lt;/code&gt; &lt;code&gt;next&lt;/code&gt; 通知が送信される前にObservableが完了した場合、EmptyErrorをオブザーバーの &lt;code&gt;error&lt;/code&gt; コールバックに配信します。</target>
        </trans-unit>
        <trans-unit id="cf43bc7be5b6a9f4eff2297551b22603dcce7470" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Error&lt;/code&gt; - Throws if no items that match the predicate are emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;Error&lt;/code&gt; -述語に一致するアイテムがソースObservableによって発行されない場合にスローされます。</target>
        </trans-unit>
        <trans-unit id="0c038e664cac7e678a7189ea519cc11210358a93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;If&lt;/code&gt; statement for Observables.</source>
          <target state="translated">&lt;code&gt;If&lt;/code&gt; Observablesのifステートメント。</target>
        </trans-unit>
        <trans-unit id="c8604585789c7f45b430d747e2826b514bd35187" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt; | OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt; | OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：接続時に、ソースObservableがオブザーバーにアイテムを発行するConnectableObservable。</target>
        </trans-unit>
        <trans-unit id="0833ea0338f3e9c17cc9ca3e78e5ac2595518c59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable identical to the source, but runs the specified Observer or callback(s) for each item.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：ソースと同じObservableですが、各アイテムに対して指定されたObserverまたはコールバックを実行します。</target>
        </trans-unit>
        <trans-unit id="9a3ff938938e7f92083767cff963ec408bc72281" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable of values from the source that were allowed by the &lt;code&gt;predicate&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ： &lt;code&gt;predicate&lt;/code&gt; 関数によって許可されたソースからの値の監視可能。</target>
        </trans-unit>
        <trans-unit id="48b16d89a273649e6300bb81e302e25a4c761d4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that begins emitting items emitted by the source Observable when the specified predicate becomes false.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：指定された述語がfalseになると、ソースObservableによって放出されたアイテムの放出を開始するObservable。</target>
        </trans-unit>
        <trans-unit id="9449ccb1f132a2fe147e056e41b27587341903fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that delays the emissions of the source Observable by an amount of time specified by the Observable returned by &lt;code&gt;delayDurationSelector&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ： &lt;code&gt;delayDurationSelector&lt;/code&gt; によって返されたObservableによって指定された時間量だけソースObservableのエミッションを遅延させるObservable 。</target>
        </trans-unit>
        <trans-unit id="38a02d0451e76caad26e6ddc73ce1e225241f99f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that delays the emissions of the source Observable by the specified &lt;code&gt;dueTime&lt;/code&gt;, and may drop some values if they occur too frequently.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：ソースObservableのエミッションを指定された &lt;code&gt;dueTime&lt;/code&gt; だけ遅延させ、頻繁に発生すると一部の値がドロップされる可能性があるObservable 。</target>
        </trans-unit>
        <trans-unit id="ed3ec44e2afb8b4f0db7d022d34500a94284cdbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that delays the emissions of the source Observable by the specified duration Observable returned by &lt;code&gt;durationSelector&lt;/code&gt;, and may drop some values if they occur too frequently.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：によって返された観察可能な指定された期間で観察源の排出量遅らせるアン観察可能 &lt;code&gt;durationSelector&lt;/code&gt; を、そして彼らはあまりにも頻繁に発生する場合にはいくつかの値を低下することがあります。</target>
        </trans-unit>
        <trans-unit id="c1abab6fda2770b6bc76976f9a61742680f62d69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that delays the emissions of the source Observable by the specified timeout or Date.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：ソースObservableのエミッションを指定されたタイムアウトまたは日付で遅延させるObservable。</target>
        </trans-unit>
        <trans-unit id="e889533f93eed35b01537d0147d0955ccb947ef4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits a single item, if it is found. Otherwise, will emit the default value if given. If not, then emits an error.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：見つかった場合に単一のアイテムを発行するObservable。それ以外の場合、デフォルト値が指定されている場合はそれを発行します。そうでない場合は、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="6395d1a685b354afb5235c686fc8add7f341178f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits at most the last count values emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：ソースObservableによって放出された最大で最後のカウント値を放出するObservable。</target>
        </trans-unit>
        <trans-unit id="b5d994a03ce94afe4026fa16bc1a7e336127fa8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits item with the largest value.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：最大値のアイテムを発行するObservable。</target>
        </trans-unit>
        <trans-unit id="b9d8c36ee2b5cd4623102825282d7ac16ed85f38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits item with the smallest value.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：最小値のアイテムを放出するObservable。</target>
        </trans-unit>
        <trans-unit id="682f9f17153985c8d9995ecf01c83b22afc2f6ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits items from the source Observable with distinct values based on the key specified.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：指定されたキーに基づいて異なる値を持つソースObservableからアイテムを発行するObservable。</target>
        </trans-unit>
        <trans-unit id="3d6800c9e0f9ae6a14fbb6b44f0d6875055a3d0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits items from the source Observable with distinct values.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：異なる値を持つソースObservableからアイテムを発行するObservable。</target>
        </trans-unit>
        <trans-unit id="a5ae53fe7fc4ee976638967a24f49e925818d67f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits only the first &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable, or all of the values from the source if the source emits fewer than &lt;code&gt;count&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：ソースのObservableによって放出された最初の &lt;code&gt;count&lt;/code&gt; 値のみを放出するObservable、またはソースが放出する &lt;code&gt;count&lt;/code&gt; 値よりも少ない場合は、ソースからのすべての値。</target>
        </trans-unit>
        <trans-unit id="b4a8c6ed88fd287a7fb8db2c7007184096326e4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the items emitted by the source Observable and then emits the items in the specified Iterable.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：ソースのObservableによって発行されたアイテムを発行し、指定されたIterableのアイテムを発行するObservable。</target>
        </trans-unit>
        <trans-unit id="9c81ca47826ed80fc19d479ca6fdffc6d56f6a6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the results of sampling the values emitted by the source Observable at the specified time interval.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：指定された時間間隔でソースObservableによって放出された値をサンプリングした結果を放出するObservable。</target>
        </trans-unit>
        <trans-unit id="7cd751b89528c1671e4f80823e7b81bacc8aeec1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the results of sampling the values emitted by the source Observable whenever the notifier Observable emits value or completes.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：通知機能Observableが値を発行するか完了するときに、ソースObservableが発行した値をサンプリングした結果を発行するObservable。</target>
        </trans-unit>
        <trans-unit id="a1a0b870de4e6611a1c770dfd589fb1187f9deae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the single item emitted by the source Observable that matches the predicate or &lt;code&gt;undefined&lt;/code&gt; when no items match.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：述語と一致する、または一致するアイテムが &lt;code&gt;undefined&lt;/code&gt; 場合は未定義の、ソースObservableによって発行された単一のアイテムを発行するObservable 。</target>
        </trans-unit>
        <trans-unit id="d8e0addfb5015dbaa3535820ab93808a87b6e9c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the values from the source Observable so long as each value satisfies the condition defined by the &lt;code&gt;predicate&lt;/code&gt;, then completes.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：各値が &lt;code&gt;predicate&lt;/code&gt; で定義された条件を満たす限り、ソースObservableから値を出力するObservableが完了します。</target>
        </trans-unit>
        <trans-unit id="e6261ccdbc462844fef242c6c04ab7ff1aa60d18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the values from the source Observable until such time as &lt;code&gt;notifier&lt;/code&gt; emits its first value.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ： &lt;code&gt;notifier&lt;/code&gt; が最初の値を発行するまで、ソースObservableから値を発行するObservable 。</target>
        </trans-unit>
        <trans-unit id="3c308d842f2d0d1867ca783e8dc73eaa380e9c04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that mirrors the output of the first Observable to emit an item.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：アイテムを放出する最初のObservableの出力をミラーリングするObservable。</target>
        </trans-unit>
        <trans-unit id="c1f86da4ab0846a743a7251a13b70c94c877b6f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that mirrors the source, but will call the specified function on termination.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：ソースをミラーリングしますが、終了時に指定された関数を呼び出すObservable。</target>
        </trans-unit>
        <trans-unit id="7e4710248cea691104373b5664ba6d261d7d8dc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that performs rate-limiting of emissions from the source Observable.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：ソースObservableからのエミッションのレート制限を実行するObservable。</target>
        </trans-unit>
        <trans-unit id="946c0b65142202dabd849b9b61c4283b9dd08baf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that performs the throttle operation to limit the rate of emissions from the source.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：ソースからのエミッションのレートを制限するためにスロットル操作を実行するObservable。</target>
        </trans-unit>
        <trans-unit id="602e1b382729f2ce251c1b92b443bbd937af3340" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that skips items from the source Observable until the second Observable emits an item, then emits the remaining items.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：2番目のObservableがアイテムを発行するまでソースObservableからアイテムをスキップし、残りのアイテムを発行するObservable。</target>
        </trans-unit>
        <trans-unit id="1ef7f4cf892977bb212561f1a77acf132b290686" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that skips the last count values emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：ソースObservableによって発行された最後のカウント値をスキップするObservable。</target>
        </trans-unit>
        <trans-unit id="d557c423d0245ce169be446a043cb268e1ca5ec5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that skips values emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：ソースObservableによって発行された値をスキップするObservable。</target>
        </trans-unit>
        <trans-unit id="4cfa061328f40141206293f33fa4e67d138bc66a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that upon connection causes the source Observable to emit items to its Observers.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：接続時に、ソースObservableがアイテムをObserversに発行するObservable。</target>
        </trans-unit>
        <trans-unit id="9c6d52f8ed9f46e4195b54356a66ccf875933728" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that will resubscribe to the source stream when the source stream completes , at most count times.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：ソースストリームが完了したときに、最大でcount回、ソースストリームに再サブスクライブするObservable。</target>
        </trans-unit>
        <trans-unit id="0f22925542ce9ba6590bea06ee00f05160b4c25e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: Observable that emits the same notifications as the source Observable, but with provided scheduler.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：ソースObservableと同じ通知を送信しますが、スケジューラが提供されているObservable。</target>
        </trans-unit>
        <trans-unit id="58a671188d09f4f66f5a13afcd8af3a07fbd548d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: Observable that mirrors behaviour of source, unless timeout checks fail.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：タイムアウトチェックが失敗しない限り、ソースの動作を反映する監視可能。</target>
        </trans-unit>
        <trans-unit id="c6bf69d4f9d0ab23a12db778ab90b11d481273cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: The source Observable modified so that its subscriptions happen on the specified &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt;. .</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：サブスクリプションが指定された&lt;a href=&quot;../index/interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; で&lt;/a&gt;発生するように変更されたソースObservable 。。</target>
        </trans-unit>
        <trans-unit id="98eaeae8156b0d69ae687593c863bfb00f1b8b0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: The source Observable modified with repeat logic.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：繰り返しロジックで変更されたソースObservable。</target>
        </trans-unit>
        <trans-unit id="32b9e6769395cbfd746c2fd896e1edba7235d3c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: The source Observable modified with retry logic.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：再試行ロジックで変更されたソースObservable。</target>
        </trans-unit>
        <trans-unit id="a06d6f1678091badb1098fdfbba9250008ad6ef3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: The source Observable modified with the retry logic.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：再試行ロジックで変更されたソースObservable。</target>
        </trans-unit>
        <trans-unit id="8763fb5889ab433a69024fe4938e084fc22037c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Notification&amp;lt;T&amp;gt;&lt;/code&gt;: The &quot;error&quot; Notification representing the argument.</source>
          <target state="translated">&lt;code&gt;Notification&amp;lt;T&amp;gt;&lt;/code&gt; ：引数を表す「エラー」通知。</target>
        </trans-unit>
        <trans-unit id="ef879440b9acd7b903b77c7ea86c552b00e297d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Notification&amp;lt;T&amp;gt;&lt;/code&gt;: The &quot;next&quot; Notification representing the argument.</source>
          <target state="translated">&lt;code&gt;Notification&amp;lt;T&amp;gt;&lt;/code&gt; ：引数を表す「次の」通知。</target>
        </trans-unit>
        <trans-unit id="38d464bb5af13abcb15464548a27988c4fe87d46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Notification&amp;lt;any&amp;gt;&lt;/code&gt;: The valueless &quot;complete&quot; Notification.</source>
          <target state="translated">&lt;code&gt;Notification&amp;lt;any&amp;gt;&lt;/code&gt; ：値のない「完全な」通知。</target>
        </trans-unit>
        <trans-unit id="ee120528c9ab1715102554c9aa15756201b1fb7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: All values of each passed Observable merged into a single Observable, in order, in serial fashion.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; ：渡された各Observableのすべての値が、順番に1つのObservableにマージされます。</target>
        </trans-unit>
        <trans-unit id="bd0e1703773d09072a2fc9c6abfbab19b7184e3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;O&amp;gt;[] | R&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;O&amp;gt;[] | R&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9fd71541e5d46e89663978e9c179e73d33d7f460" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;R&amp;gt;&amp;gt;&lt;/code&gt;: An Observable whose Observers' subscriptions trigger an invocation of the given Observable factory function.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;R&amp;gt;&amp;gt;&lt;/code&gt; ：オブザーバーのサブスクリプションが特定のObservableファクトリー関数の呼び出しをトリガーするObservable。</target>
        </trans-unit>
        <trans-unit id="72ea18b738f13176716cd3530244cf48151fd843" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt;: An Observable of projected values from the most recent values from each input Observable, or an array of the most recent values from each input Observable.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt; ：各入力Observableの最新の値からの予測値のObservable、または各入力Observableの最新の値の配列。</target>
        </trans-unit>
        <trans-unit id="669000de8f64c0f068e1e8d2b995d5ae4e1cd7e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt;: An Observable that concatenates all sources, one after the other, ignoring all errors, such that any error causes it to move on to the next source.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt; ：すべてのエラーを無視してすべてのソースを次々に連結し、エラーが発生すると次のソースに移動するObservable。</target>
        </trans-unit>
        <trans-unit id="5dd2c89285ed413ee73cb8ed373783a71556739e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt;: a new observable with the Operator applied</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt; ：オペレーターが適用された新しいオブザーバブル</target>
        </trans-unit>
        <trans-unit id="546d4d5a898b2514cd733c7691edcbe22e343808" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt;: an Observable that emits items that are the result of every input Observable.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt; ：すべての入力Observableの結果であるアイテムを発行するObservable。</target>
        </trans-unit>
        <trans-unit id="f246ffeb696ea044aea059a6547ab60ed97903e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;Response&amp;gt;&lt;/code&gt;: An Observable, that when subscribed to performs an HTTP request using the native &lt;code&gt;fetch&lt;/code&gt; function. The &lt;a href=&quot;../index/class/subscription&quot;&gt;&lt;code&gt;Subscription&lt;/code&gt;&lt;/a&gt; is tied to an &lt;code&gt;AbortController&lt;/code&gt; for the the fetch.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;Response&amp;gt;&lt;/code&gt; ：Observable。サブスクライブすると、ネイティブ &lt;code&gt;fetch&lt;/code&gt; 関数を使用してHTTPリクエストを実行します。&lt;a href=&quot;../index/class/subscription&quot;&gt; &lt;code&gt;Subscription&lt;/code&gt; &lt;/a&gt;に結ばれ &lt;code&gt;AbortController&lt;/code&gt; フェッチのために。</target>
        </trans-unit>
        <trans-unit id="12df656ce83de0d952270b74d9d36115ce231f71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;S&amp;gt;&lt;/code&gt;: The generated sequence.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;S&amp;gt;&lt;/code&gt; ：生成されたシーケンス。</target>
        </trans-unit>
        <trans-unit id="1b8df8881cd223a6d99f276649bb495aa498b2e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T | F&amp;gt;&lt;/code&gt;: Either first or second Observable, depending on condition.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T | F&amp;gt;&lt;/code&gt; ：条件に応じて、1番目または2番目の観測可能。</target>
        </trans-unit>
        <trans-unit id="09e76145a70f20853eb46f82588e140da99d594f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T | T[]&amp;gt;&lt;/code&gt;: Observable which, when an event happens, emits first parameter passed to registered event handler. Alternatively it emits whatever project function returns at that moment.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T | T[]&amp;gt;&lt;/code&gt; ：イベントが発生したときに、登録されたイベントハンドラーに渡された最初のパラメーターを発行する監視可能。または、その時点で返されるプロジェクト関数を発行します。</target>
        </trans-unit>
        <trans-unit id="d7584ca661dd77ce664d3ff61f1e49b4909d87c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="1b80f12276d3a40a5fa937076c33adccf9646b17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that behaves the same as Observable returned by &lt;code&gt;observableFactory&lt;/code&gt;, but which - when completed, errored or unsubscribed - will also call &lt;code&gt;unsubscribe&lt;/code&gt; on created resource object.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt; ：Observableは &lt;code&gt;observableFactory&lt;/code&gt; から返されるObservableと同じように動作しますが、完了すると、エラーが発生するか、サブスク &lt;code&gt;unsubscribe&lt;/code&gt; 、作成されたリソースオブジェクトでunsubscribeも呼び出します。</target>
        </trans-unit>
        <trans-unit id="8d9f59154e679519172ccff523d963b577c7ba52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the arguments described above and then completes.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt; ：上記の引数を発行してから完了するObservable。</target>
        </trans-unit>
        <trans-unit id="5a17efa17d3475364890f0d3f49f8f8c5cd4a4d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: Observable that the Subject casts to</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt; ：サブジェクトがキャストする監視可能</target>
        </trans-unit>
        <trans-unit id="a80ce4eeb36f3e609ba0293318360af2884d5e92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: The generated sequence.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt; ：生成されたシーケンス。</target>
        </trans-unit>
        <trans-unit id="625771d790fd38d43439cefc89d792200861d6c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: an Observable that mirrors the output of the first Observable to emit an item.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt; ：アイテムを放出する最初のObservableの出力をミラーリングするObservable。</target>
        </trans-unit>
        <trans-unit id="3c402a0e4b6a9e65ebc0e3c78845b844e7e841a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;any&amp;gt;&lt;/code&gt;: Observable emitting either an array of last values emitted by passed Observables or value from project function.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;any&amp;gt;&lt;/code&gt; ：Observableは、渡されたObservableによって放出された最後の値の配列、またはプロジェクト関数からの値を放出します。</target>
        </trans-unit>
        <trans-unit id="d644633ca879cf0518e4252c5291db0c1473f62e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;never&amp;gt;&lt;/code&gt;: An error Observable: emits only the error notification using the given error argument.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;never&amp;gt;&lt;/code&gt; ：エラーObservable：指定されたエラー引数を使用してエラー通知のみを発行します。</target>
        </trans-unit>
        <trans-unit id="4fd37309412eebab1af8b444e3494ff46307ad58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt;: An Observable of numbers that emits a finite range of sequential integers.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt; ：有限範囲の連続した整数を放出する数値のObservable。</target>
        </trans-unit>
        <trans-unit id="5bafa5caf9714920c7d9794783daad8cb6cfe408" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt;: An Observable that emits a &lt;code&gt;0&lt;/code&gt; after the &lt;code&gt;dueTime&lt;/code&gt; and ever increasing numbers after each &lt;code&gt;period&lt;/code&gt; of time thereafter.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt; ： &lt;code&gt;dueTime&lt;/code&gt; の後に &lt;code&gt;0&lt;/code&gt; を発行し、その後は各 &lt;code&gt;period&lt;/code&gt; の後に増加する数値を含む Observable 。</target>
        </trans-unit>
        <trans-unit id="18ef7a2d7b03b517f7cba00b53dce721410629dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt;: An Observable that emits a sequential number each time interval.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt; ：時間間隔ごとに連続番号を出力するObservable。</target>
        </trans-unit>
        <trans-unit id="9c60d02600031a7c4e4077aaed375e92e7ce4c66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable.if&lt;/code&gt; and &lt;code&gt;Observable.throw&lt;/code&gt; These methods have been replaced by the static &lt;code&gt;iif()&lt;/code&gt; and &lt;code&gt;throwError()&lt;/code&gt; functions. Use &lt;a href=&quot;https://github.com/reactivex/rxjs-tslint&quot;&gt;rxjs-tslint&lt;/a&gt; to convert method calls with function calls.</source>
          <target state="translated">&lt;code&gt;Observable.if&lt;/code&gt; および &lt;code&gt;Observable.throw&lt;/code&gt; これらのメソッドは、静的な &lt;code&gt;iif()&lt;/code&gt; および &lt;code&gt;throwError()&lt;/code&gt; 関数に置き換えられました。&lt;a href=&quot;https://github.com/reactivex/rxjs-tslint&quot;&gt;rxjs-tslint&lt;/a&gt;を使用して、メソッド呼び出しを関数呼び出しに変換します。</target>
        </trans-unit>
        <trans-unit id="e8dd422c34dd6670e5820789a3935b0f8a163b30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;Notification&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt;: An Observable that emits items and notifications embedded in Notification objects emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;Notification&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt; ：ソースObservableによって発行されたNotificationオブジェクトに埋め込まれたアイテムと通知を発行するObservable。</target>
        </trans-unit>
        <trans-unit id="b943e1dff560a9b4731381e69c691f9f2663856d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;ObservableInput&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt;: An Observable emitting values from all the inner Observables concatenated.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;ObservableInput&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt; ：連結されたすべての内部Observableからの値を放出するObservable。</target>
        </trans-unit>
        <trans-unit id="a9fbd53ce8c4ca4704991f6a4e6424efb51a3e50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;ObservableInput&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt;: An Observable that emits values coming from all the inner Observables emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;ObservableInput&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt; ：ソースObservableによって放出されたすべての内部Observableからの値を放出するObservable。</target>
        </trans-unit>
        <trans-unit id="4e9e5b74e3d4c5968ec5aa65403ccf2f27d4ac10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, GroupedObservable&amp;lt;K, R&amp;gt;&amp;gt;&lt;/code&gt;: An Observable that emits GroupedObservables, each of which corresponds to a unique key value and each of which emits those items from the source Observable that share that key value.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, GroupedObservable&amp;lt;K, R&amp;gt;&amp;gt;&lt;/code&gt; ：GroupedObservableを発行するObservable。それぞれが一意のキー値に対応し、それぞれがそのキー値を共有するソースObservableから項目を発行します。</target>
        </trans-unit>
        <trans-unit id="a31762e776d77c6f8116c3b05cba4d1b24ca6464" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, I | R&amp;gt;&lt;/code&gt;: An Observable that emits items from the given &lt;code&gt;innerObservable&lt;/code&gt; (and optionally transformed through the deprecated &lt;code&gt;resultSelector&lt;/code&gt;) every time a value is emitted on the source Observable, and taking only the values from the most recently projected inner Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, I | R&amp;gt;&lt;/code&gt; ：値がソースObservableで &lt;code&gt;innerObservable&lt;/code&gt; 、指定されたinnerObservableからアイテムを発行し（オプションで非推奨の &lt;code&gt;resultSelector&lt;/code&gt; によって変換され）、最も最近投影された内部Observableからの値のみを取るObservable。</target>
        </trans-unit>
        <trans-unit id="8a4fd670838262d305edf3ffd88f8a75a09e6037" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Notification&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An Observable that emits &lt;a href=&quot;../index/class/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; objects that wrap the original emissions from the source Observable with metadata.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, Notification&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ：ソースObservableからの元の放出をメタデータでラップする&lt;a href=&quot;../index/class/notification&quot;&gt; &lt;code&gt;Notification&lt;/code&gt; &lt;/a&gt;オブジェクトを放出するObservable 。</target>
        </trans-unit>
        <trans-unit id="25fe863e956990570054cbe8f4a3ae938b4a7a37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An Observable of windows, which are Observables emitting values of the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ：ソースObservableの値を放出するObservableであるウィンドウのObservable。</target>
        </trans-unit>
        <trans-unit id="0391947d88f4f7f42a95717260c28949831f0f0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An Observable of windows, which in turn are Observable of values.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ：ウィンドウのObservable、次に値のObservable。</target>
        </trans-unit>
        <trans-unit id="2f931b53ceabcaf37290a1e173d5261898200497" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An observable of windows, which in turn are Observables.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ：ウィンドウのオブザーバブル、つまりオブザーバブルです。</target>
        </trans-unit>
        <trans-unit id="36b665d4b96e8622df44bceaa15c3aef802424b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable containing projected Observables of each item of the source, ignoring projected Observables that start before their preceding Observable has completed.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; ：ソースの各アイテムの予測されたObservableを含むObservable。前のObservableが完了する前に開始される予測されたObservableは無視されます。</target>
        </trans-unit>
        <trans-unit id="ae05bfd16d5b0dc9ad579b88debdcb634355a5d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable that emits items from the given &lt;code&gt;innerObservable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; ：指定された &lt;code&gt;innerObservable&lt;/code&gt; からアイテムを放出するObservable</target>
        </trans-unit>
        <trans-unit id="f1114fbae762bbcc842c75a346d50886aba62bd3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable that emits the result of applying the projection function (and the optional deprecated &lt;code&gt;resultSelector&lt;/code&gt;) to each item emitted by the source Observable and merging the results of the Observables obtained from this transformation.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; ：射影関数（およびオプションの廃止された &lt;code&gt;resultSelector&lt;/code&gt; ）をソースObservableによって放出された各アイテムに適用し、この変換から取得されたObservableの結果をマージした結果を放出するObservable。</target>
        </trans-unit>
        <trans-unit id="4936e9ad8b47feae4057bfc06b74066ba9c2244e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable that emits the result of applying the projection function (and the optional deprecated &lt;code&gt;resultSelector&lt;/code&gt;) to each item emitted by the source Observable and taking only the values from the most recently projected inner Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; ：ソースObservableによって &lt;code&gt;resultSelector&lt;/code&gt; された各アイテムに投影関数（およびオプションの非推奨のresultSelector）を適用した結果を発行し、最後に投影された内部Observableからの値のみを取得するObservable。</target>
        </trans-unit>
        <trans-unit id="2a802dcfd33b79856466fc5e35de71361bf29241" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable that emits the result of applying the projection function (and the optional deprecated &lt;code&gt;resultSelector&lt;/code&gt;) to each item emitted by the source Observable and taking values from each projected inner Observable sequentially.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; ：射影関数（およびオプションの廃止された &lt;code&gt;resultSelector&lt;/code&gt; ）をソースObservableによって放出された各アイテムに適用し、各射影された内部Observableから順次値を取得した結果を放出するObservable。</target>
        </trans-unit>
        <trans-unit id="92eec52d3a9e0aee0ab31663d93da5ec6a88327a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An observable of values merged together by joining the passed observable with itself, one after the other, for each value emitted from the source.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; ：ソースから出力された各値について、渡されたオブザーバブルを次々にそれ自体と結合することによってマージされた値のオブザーバブル。</target>
        </trans-unit>
        <trans-unit id="6389b114b24798b556b201a37917cf23aa19a979" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e8d1bd733bcb192dc0ef096871364d3d023737c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: A new Observable of property values from the source values.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：ソース値からのプロパティ値の新しいObservable。</target>
        </trans-unit>
        <trans-unit id="e304529f59d93d3c25b21c0bd7fe17bed8f078ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable of projected values from the most recent values from each input Observable, or an array of the most recent values from each input Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：各入力Observableからの最新の値からの投影値のObservable、または各入力Observableからの最新の値の配列。</target>
        </trans-unit>
        <trans-unit id="0c94ddce24cecab84d17bb4f8b35baa77d868ac0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits the given &lt;code&gt;value&lt;/code&gt; every time the source Observable emits something.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：ソースObservableが何かを発行するたびに指定された &lt;code&gt;value&lt;/code&gt; 発行するObservable。</target>
        </trans-unit>
        <trans-unit id="fc79b7763d23cae388f6ab3337dcf1c4d68ce6b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits the results of invoking the selector on the items emitted by a &lt;code&gt;ConnectableObservable&lt;/code&gt; that shares a single subscription to the underlying stream.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：基になるストリームへの単一のサブスクリプションを共有する &lt;code&gt;ConnectableObservable&lt;/code&gt; によって発行されたアイテムでセレクターを呼び出した結果を発行するObservable 。</target>
        </trans-unit>
        <trans-unit id="83d1263ae27c17bb3433e47a18a1040160a7d6e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits the source values and also result of applying the projection function to each value emitted on the output Observable and and merging the results of the Observables obtained from this transformation.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：ソース値を出力するObservableと、出力Observableで出力された各値に投影関数を適用し、この変換から得られたObservableの結果をマージした結果。</target>
        </trans-unit>
        <trans-unit id="1e461258d10f81fe5813686fbc0c2bda14a219dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits the values from the source Observable transformed by the given &lt;code&gt;project&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：指定された &lt;code&gt;project&lt;/code&gt; 関数によって変換されたソースObservableから値を出力するObservable 。</target>
        </trans-unit>
        <trans-unit id="936d1a67ca42c166a86a10148a49bde1e454fa75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits values from source Observable, but - if it errors - subscribes to the next passed Observable and so on, until it completes or runs out of Observables.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：ソースObservableから値を出力するObservableですが、エラーが発生した場合は、次に渡されるObservableをサブスクライブし、Observableが完了するか実行可能になるまでサブスクライブします。</target>
        </trans-unit>
        <trans-unit id="99d2bff6a3704c559e008d5d0bc66fdcb9c51d50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An observable of the accumulated values.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：累積値のオブザーバブル。</target>
        </trans-unit>
        <trans-unit id="b40b1eb80ecabc355acb81f89cecbb6782e4906c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt;: An Observable of the first item that matches the condition.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt; ：条件に一致する最初のアイテムのObservable。</target>
        </trans-unit>
        <trans-unit id="0da3914377c50370c3b653fe993f2deb3effae27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt;: An Observable that emits only the last item satisfying the given condition from the source, or an NoSuchElementException if no such items are emitted.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt; ：ソースから指定された条件を満たす最後の項目のみを発行するObservable、またはそのような項目が発行されない場合はNoSuchElementException。</target>
        </trans-unit>
        <trans-unit id="609691028cdab1ac2a82fd5eb880713da1a59fd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt;: An Observable that emits the items in the specified Iterable and then emits the items emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt; ：指定されたIterableのアイテムを発行し、次にソースObservableが発行したアイテムを発行するObservable。</target>
        </trans-unit>
        <trans-unit id="ed5d3fe82744ac00ef5f18025cfc4a819f2feec8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | ObservedValueOf&amp;lt;O&amp;gt;&amp;gt;&lt;/code&gt;: An observable that originates from either the source or the observable returned by the catch &lt;code&gt;selector&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | ObservedValueOf&amp;lt;O&amp;gt;&amp;gt;&lt;/code&gt; ：ソースまたはキャッチ &lt;code&gt;selector&lt;/code&gt; 関数によって返されたオブザーバブルのいずれかに由来するオブザーバブル。</target>
        </trans-unit>
        <trans-unit id="917e13a869d45f18bbb3fa233d195401c5881fc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt;: An Observable that emits a single value that is the result of accumulating the values emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt; ：ソースObservableによって放出された値を累積した結果である単一の値を放出するObservable。</target>
        </trans-unit>
        <trans-unit id="f3dbf8202edc720dbee99010f4de8c8d524a1654" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt;: An Observable that emits either the specified &lt;code&gt;defaultValue&lt;/code&gt; if the source Observable emits no items, or the values emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt; ：ソースObservableがアイテムを &lt;code&gt;defaultValue&lt;/code&gt; ない場合は指定されたdefaultValue、またはソースObservableが発行する値のいずれかを発行するObservable。</target>
        </trans-unit>
        <trans-unit id="529b798ac9b12565a4850db4ce7e7eedfdc11a0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt;: Observable that mirrors behaviour of source or, when timeout check fails, of an Observable passed as a second parameter.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt; ：ソースの動作をミラーリングするObservable、またはタイムアウトチェックが失敗した場合、2番目のパラメーターとして渡されるObservableの動作。</target>
        </trans-unit>
        <trans-unit id="6ab6b4873dd13ed201c943f6c53cf2f2269d7d5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | undefined&amp;gt;&lt;/code&gt;: An Observable of the first item that matches the condition.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | undefined&amp;gt;&lt;/code&gt; ：条件に一致する最初のアイテムのObservable。</target>
        </trans-unit>
        <trans-unit id="92b0d5ad575e28215f2190858c47eade8e16ab5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt;: An Observable of arrays of buffered values.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt; ：バッファリングされた値の配列の監視可能。</target>
        </trans-unit>
        <trans-unit id="06e1a442a5978c8053196612fd140be99654a739" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt;: An Observable of buffers, which are arrays of values.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt; ：値の配列であるバッファーの監視可能。</target>
        </trans-unit>
        <trans-unit id="963e1454f929c69a8e15356996340866e7328b0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt;: An array from an observable sequence.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt; ：監視可能なシーケンスからの配列。</target>
        </trans-unit>
        <trans-unit id="46031b573a888633ac1d11c7d0c5a75d253ba889" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt;: An observable of arrays of buffered values.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt; ：バッファリングされた値の配列のオブザーバブル。</target>
        </trans-unit>
        <trans-unit id="95d772c65fa6e969daaef9c997413f7d78c99bab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, TimeInterval&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: Observable that emit infomation about value and interval</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, TimeInterval&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ：値と間隔に関する情報を出力する監視可能</target>
        </trans-unit>
        <trans-unit id="f01e99c7b50bfb9837a11c004da57eb915716d96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Timestamp&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, Timestamp&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ac1c1912e9c531cf65e1edd68b325400d84e4c9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, [T, T]&amp;gt;&lt;/code&gt;: An Observable of pairs (as arrays) of consecutive values from the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, [T, T]&amp;gt;&lt;/code&gt; ：ソースObservableからの連続した値のペア（配列として）のObservable。</target>
        </trans-unit>
        <trans-unit id="1c706a87589545aacce9fc175adab0cfa04a67fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt;: An Observable of a boolean value indicating whether observable was empty or not</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt; ：オブザーバブルが空かどうかを示すブール値のObservable</target>
        </trans-unit>
        <trans-unit id="52c5f27dea5137ec37457b98a437e8a147c2012b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt;: An Observable of a single boolean value representing whether or not the values emitted by both observables were equal in sequence.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt; ：両方のオブザーバブルから出力された値が順番に等しいかどうかを表す単一のブール値のObservable。</target>
        </trans-unit>
        <trans-unit id="084491f279558c6a0089f3fafc3e046ac95017d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt;: An Observable of booleans that determines if all items of the source Observable meet the condition specified.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt; ：ソースObservableのすべてのアイテムが指定された条件を満たすかどうかを決定するブール値のObservable。</target>
        </trans-unit>
        <trans-unit id="9c8ab2999ba64eaf1d254ef445e315a3af05b9ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, number&amp;gt;&lt;/code&gt;: An Observable of one number that represents the count as described above.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, number&amp;gt;&lt;/code&gt; ：上記のようにカウントを表す1つの数値のObservable。</target>
        </trans-unit>
        <trans-unit id="21508cc91f2bf6aad48d4bf57db2587d1fdae434" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, number&amp;gt;&lt;/code&gt;: An Observable of the index of the first item that matches the condition.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, number&amp;gt;&lt;/code&gt; ：条件に一致する最初のアイテムのインデックスのObservable。</target>
        </trans-unit>
        <trans-unit id="6e1666f9fe233ad327cda0b296e7fd550add86f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;any, T&amp;gt;&lt;/code&gt;: An Observable that takes a source of Observables and propagates the first observable exclusively until it completes before subscribing to the next.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;any, T&amp;gt;&lt;/code&gt; ：Observableのソースを取得し、次のサブスクライブをサブスクライブする前に完了するまで、最初のオブザーバブルを排他的に伝播するObservable。</target>
        </trans-unit>
        <trans-unit id="c6a5ca5378c9fcf666946deff36b36b6ae25600b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;any, never&amp;gt;&lt;/code&gt;: An empty Observable that only calls &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;, based on which one is called by the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;any, never&amp;gt;&lt;/code&gt; ：空のObservableは &lt;code&gt;complete&lt;/code&gt; または &lt;code&gt;error&lt;/code&gt; を呼び出すだけであり、それに基づいてソースObservableによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="6e58713c020d2f707061137552b408199b941f2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Promise&amp;lt;void&amp;gt;&lt;/code&gt;: a promise that either resolves on observable completion or rejects with the handled error</source>
          <target state="translated">&lt;code&gt;Promise&amp;lt;void&amp;gt;&lt;/code&gt; ：監視可能な完了で解決するか、処理されたエラーで拒否するプロミス</target>
        </trans-unit>
        <trans-unit id="cd50de8ad5bd5bb0c32bba750b39c2af3faa752d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SubscribeOnObservable&lt;/code&gt; is hidden from direct use in v6 and is accessible only through operator &lt;code&gt;subscribeOn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SubscribeOnObservable&lt;/code&gt; は、v6では直接使用できません。オペレーター &lt;code&gt;subscribeOn&lt;/code&gt; を介してのみアクセスできます。</target>
        </trans-unit>
        <trans-unit id="3d845fe57dde654307e9827b34a87ee47b1565c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Subscriber&amp;lt;T&amp;gt;&lt;/code&gt;: A Subscriber wrapping the (partially defined) Observer represented by the given arguments.</source>
          <target state="translated">&lt;code&gt;Subscriber&amp;lt;T&amp;gt;&lt;/code&gt; ：指定された引数で表される（部分的に定義された）Observerをラップするサブスクライバー。</target>
        </trans-unit>
        <trans-unit id="e9296bc5910b2bafe547429ecf483eeaf5e40ba8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Subscription&lt;/code&gt;: A subscription in order to be able to unsubscribe the scheduled work.</source>
          <target state="translated">&lt;code&gt;Subscription&lt;/code&gt; ：スケジュールされた作業のサブスクリプションを解除できるようにするためのサブスクリプション。</target>
        </trans-unit>
        <trans-unit id="5eb8999b131bccb24bac0dc65dd7ee3184a724a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Subscription&lt;/code&gt;: Returns the Subscription used or created to be added to the inner subscriptions list. This Subscription can be used with &lt;code&gt;remove()&lt;/code&gt; to remove the passed teardown logic from the inner subscriptions list.</source>
          <target state="translated">&lt;code&gt;Subscription&lt;/code&gt; ：内部サブスクリプションリストに追加するために使用または作成されたサブスクリプションを返します。このサブスクリプションを &lt;code&gt;remove()&lt;/code&gt; と一緒に使用して、渡された破棄ロジックを内部サブスクリプションリストから削除できます。</target>
        </trans-unit>
        <trans-unit id="9751fe552726353c3cf0acaa69371203468189b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, ConnectableObservable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, ConnectableObservable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8caae40fe3d57bed9c2dba2b723525aef2fe63ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, ConnectableObservable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.</source>
          <target state="translated">&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, ConnectableObservable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ：ソースシーケンスをマルチキャストすることによって生成されたシーケンスの要素を含む監視可能なシーケンス。</target>
        </trans-unit>
        <trans-unit id="0c0eb17bf7e6eda8feecbb427e767db2329c3198" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, [Observable&amp;lt;T&amp;gt;, Observable&amp;lt;T&amp;gt;]&amp;gt;&lt;/code&gt;: An array with two Observables: one with values that passed the predicate, and another with values that did not pass the predicate.</source>
          <target state="translated">&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, [Observable&amp;lt;T&amp;gt;, Observable&amp;lt;T&amp;gt;]&amp;gt;&lt;/code&gt; ：2つのObservableを持つ配列。1つは述語を渡した値を持つもの、もう1つは述語を渡さなかった値を持つものです。</target>
        </trans-unit>
        <trans-unit id="daa3594eaba6fa012b962e692bb34ebadc67452e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WebSocketSubject&amp;lt;T&amp;gt;&lt;/code&gt;: Subject which allows to both send and receive messages via WebSocket connection.</source>
          <target state="translated">&lt;code&gt;WebSocketSubject&amp;lt;T&amp;gt;&lt;/code&gt; ：WebSocket接続を介してメッセージを送受信できるようにするサブジェクト。</target>
        </trans-unit>
        <trans-unit id="b48aa90627a1c9215b79016aecac86a4deb348c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WebSocketSubject&lt;/code&gt; has an additional operator, not found in other Subjects. It is called &lt;code&gt;multiplex&lt;/code&gt; and it is used to simulate opening several socket connections, while in reality maintaining only one. For example, an application has both chat panel and real-time notifications about sport news. Since these are two distinct functions, it would make sense to have two separate connections for each. Perhaps there could even be two separate services with WebSocket endpoints, running on separate machines with only GUI combining them together. Having a socket connection for each functionality could become too resource expensive. It is a common pattern to have single WebSocket endpoint that acts as a gateway for the other services (in this case chat and sport news services). Even though there is a single connection in a client app, having the ability to manipulate streams as if it were two separate sockets is desirable. This eliminates manually registering and unregistering in a gateway for given service and filter out messages of interest. This is exactly what &lt;code&gt;multiplex&lt;/code&gt; method is for.</source>
          <target state="translated">&lt;code&gt;WebSocketSubject&lt;/code&gt; には、他のサブジェクトにはない追加の演算子があります。 &lt;code&gt;multiplex&lt;/code&gt; と呼ばれますそして、実際には1つだけを維持しながら、いくつかのソケット接続を開くことをシミュレートするために使用されます。たとえば、アプリケーションには、スポーツニュースに関するチャットパネルとリアルタイム通知の両方があります。これらは2つの別個の機能であるため、それぞれに2つの別個の接続があることは理にかなっています。おそらく、WebSocketエンドポイントを備えた2つの別個のサービスがあり、GUIだけを組み合わせて別個のマシンで実行することもできます。各機能にソケット接続を使用すると、リソースの負荷が高くなりすぎる場合があります。他のサービス（この場合はチャットとスポーツニュースサービス）のゲートウェイとして機能する単一のWebSocketエンドポイントを持つことは一般的なパターンです。クライアントアプリには単一の接続がありますが、2つの個別のソケットであるかのようにストリームを操作できることが望ましいです。これにより、特定のサービスのゲートウェイで手動で登録および登録解除する必要がなくなり、関心のあるメッセージを除外できます。これはまさに &lt;code&gt;multiplex&lt;/code&gt; 方式用です。</target>
        </trans-unit>
        <trans-unit id="69561978d6621715d34ad8aac9add39a6dd9bc48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[0-9]+[ms|s|m]&lt;/code&gt; time progression: the time progression syntax lets you progress virtual time by a specific amount. It's a number, followed by a time unit of &lt;code&gt;ms&lt;/code&gt; (milliseconds), &lt;code&gt;s&lt;/code&gt; (seconds), or &lt;code&gt;m&lt;/code&gt; (minutes) without any space between them, e.g. &lt;code&gt;a 10ms b&lt;/code&gt;. See &lt;a href=&quot;marble-testing#time-progression-syntax&quot;&gt;Time progression syntax&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;[0-9]+[ms|s|m]&lt;/code&gt; 時間進行：時間進行構文を使用すると、仮想時間を特定の量だけ進めることができます。これは数値で、その後に &lt;code&gt;ms&lt;/code&gt; （ミリ秒）、 &lt;code&gt;s&lt;/code&gt; （秒）、または &lt;code&gt;m&lt;/code&gt; （分）の時間単位が続き、間にスペースはありません（例： &lt;code&gt;a 10ms b&lt;/code&gt; 。詳細については、&lt;a href=&quot;marble-testing#time-progression-syntax&quot;&gt;時間進行構文&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="06d76181f50eed2bda7f22c043e74fa2ae4d0f2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[Observable&amp;lt;T&amp;gt;, Observable&amp;lt;T&amp;gt;]&lt;/code&gt;: An array with two Observables: one with values that passed the predicate, and another with values that did not pass the predicate.</source>
          <target state="translated">&lt;code&gt;[Observable&amp;lt;T&amp;gt;, Observable&amp;lt;T&amp;gt;]&lt;/code&gt; ：2つのObservableを持つ配列。1つは述語を渡した値を持つもの、もう1つは述語を渡さなかった値を持つものです。</target>
        </trans-unit>
        <trans-unit id="7be0d73ff95f971ce3d0ec056f20b5e78d2401a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[a-z0-9]&lt;/code&gt; e.g. &lt;code&gt;'a'&lt;/code&gt; any alphanumeric character: Represents a value being emitted by the producer signaling &lt;code&gt;next()&lt;/code&gt;. Also consider that you could map this into an object or an array like this:</source>
          <target state="translated">&lt;code&gt;[a-z0-9]&lt;/code&gt; 例 &lt;code&gt;'a'&lt;/code&gt; 任意の英数字： &lt;code&gt;next()&lt;/code&gt; に通知するプロデューサーが発行する値を表します。また、これを次のようにオブジェクトまたは配列にマッピングできることも考慮してください。</target>
        </trans-unit>
        <trans-unit id="76574adecd5f0112d1ef6e3dee5ffec9d1760f98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="1d66416b13f1e69be3b9fe9168a34eccd8117317" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asap&lt;/code&gt; scheduler behaves the same as &lt;a href=&quot;asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; scheduler when you use it to delay task in time. If however you set delay to &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;asap&lt;/code&gt; will wait for current synchronously executing code to end and then it will try to execute given task as fast as possible.</source>
          <target state="translated">&lt;code&gt;asap&lt;/code&gt; スケジューラは、タスクを遅延させるために使用する場合、&lt;a href=&quot;asyncscheduler&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt;スケジューラと同じように動作します。ただし、遅延を &lt;code&gt;0&lt;/code&gt; に設定すると、 &lt;code&gt;asap&lt;/code&gt; は現在の同期実行コードが終了するまで待機し、指定されたタスクを可能な限り高速に実行しようとします。</target>
        </trans-unit>
        <trans-unit id="8d2f7871c278c3ff4f15d4e1797b46bd3a11325e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asap&lt;/code&gt; scheduler will do its best to minimize time between end of currently executing code and start of scheduled task. This makes it best candidate for performing so called &quot;deferring&quot;. Traditionally this was achieved by calling &lt;code&gt;setTimeout(deferredTask, 0)&lt;/code&gt;, but that technique involves some (although minimal) unwanted delay.</source>
          <target state="translated">&lt;code&gt;asap&lt;/code&gt; スケジューラは、現在実行中のコードの終了からスケジュールされたタスクの開始までの時間を最小限に抑えるために最善を尽くします。これは、いわゆる「据え置き」を実行するための最良の候補になります。従来、これは &lt;code&gt;setTimeout(deferredTask, 0)&lt;/code&gt; 呼び出すことで実現されていましたが、この手法には（最小限ではありますが）不要な遅延が含まれます。</target>
        </trans-unit>
        <trans-unit id="38282087e639f45cb81b714b183b93c266c618fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt; scheduler schedules tasks asynchronously, by putting them on the JavaScript event loop queue. It is best used to delay tasks in time or to schedule tasks repeating in intervals.</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; スケジューラは、JavaScriptイベントループキューにタスクを置くことにより、タスクを非同期的にスケジュールします。これは、タスクを時間的に遅らせるか、タスクを間隔を置いて繰り返すようにスケジュールするのに最適です。</target>
        </trans-unit>
        <trans-unit id="5f3bfc256736a1a2b56372aad02d0143b55bdd10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;audit&lt;/code&gt; is similar to &lt;code&gt;throttle&lt;/code&gt;, but emits the last value from the silenced time window, instead of the first value. &lt;code&gt;audit&lt;/code&gt; emits the most recent value from the source Observable on the output Observable as soon as its internal timer becomes disabled, and ignores source values while the timer is enabled. Initially, the timer is disabled. As soon as the first source value arrives, the timer is enabled by calling the &lt;code&gt;durationSelector&lt;/code&gt; function with the source value, which returns the &quot;duration&quot; Observable. When the duration Observable emits a value or completes, the timer is disabled, then the most recent source value is emitted on the output Observable, and this process repeats for the next source value.</source>
          <target state="translated">&lt;code&gt;audit&lt;/code&gt; は &lt;code&gt;throttle&lt;/code&gt; に似ていますが、最初の値ではなく、沈黙時間ウィンドウから最後の値を出力します。 &lt;code&gt;audit&lt;/code&gt; は、内部タイマーが無効になるとすぐに、出力ObservableのソースObservableから最新の値を出力し、タイマーが有効になっている間はソース値を無視します。最初、タイマーは無効になっています。最初のソース値が到着するとすぐに、「selection」オブザーバブルを返すソース値を使用して &lt;code&gt;durationSelector&lt;/code&gt; 関数を呼び出すことにより、タイマーが有効になります。 Observableが値を発行または完了すると、タイマーは無効になり、最新のソース値が出力Observableで発行され、このプロセスが次のソース値に対して繰り返されます。</target>
        </trans-unit>
        <trans-unit id="40805c639cd2c3fa224cf3a2a39ee4a56ef4f08e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auditTime&lt;/code&gt; is similar to &lt;code&gt;throttleTime&lt;/code&gt;, but emits the last value from the silenced time window, instead of the first value. &lt;code&gt;auditTime&lt;/code&gt; emits the most recent value from the source Observable on the output Observable as soon as its internal timer becomes disabled, and ignores source values while the timer is enabled. Initially, the timer is disabled. As soon as the first source value arrives, the timer is enabled. After &lt;code&gt;duration&lt;/code&gt; milliseconds (or the time unit determined internally by the optional &lt;code&gt;scheduler&lt;/code&gt;) has passed, the timer is disabled, then the most recent source value is emitted on the output Observable, and this process repeats for the next source value. Optionally takes a &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; for managing timers.</source>
          <target state="translated">&lt;code&gt;auditTime&lt;/code&gt; は &lt;code&gt;throttleTime&lt;/code&gt; に似ていますが、最初の値ではなく、沈黙時間ウィンドウから最後の値を出力します。 &lt;code&gt;auditTime&lt;/code&gt; は、内部のタイマーが無効になるとすぐに、出力ObservableのソースObservableから最新の値を送信し、タイマーが有効になっている間はソースの値を無視します。最初、タイマーは無効になっています。最初のソース値が到着するとすぐに、タイマーが有効になります。後 &lt;code&gt;duration&lt;/code&gt; ミリ秒（または時間単位はオプションで内部的に決定 &lt;code&gt;scheduler&lt;/code&gt; 経過した）、タイマーは、最新のソース値が観察可能な出力に放出され、無効になり、次のソース値のため、このプロセスが繰り返されます。オプションで、&lt;a href=&quot;../index/interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; を&lt;/a&gt;取る タイマーを管理するため。</target>
        </trans-unit>
        <trans-unit id="0b2f0508ff5d8cf3b8a58819217df8e1f5a557ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bindCallback&lt;/code&gt; is not an operator because its input and output are not Observables. The input is a function &lt;code&gt;func&lt;/code&gt; with some parameters. The last parameter must be a callback function that &lt;code&gt;func&lt;/code&gt; calls when it is done.</source>
          <target state="translated">&lt;code&gt;bindCallback&lt;/code&gt; は、その入出力が監視可能ではないため、オペレーターではありません。入力は、いくつかのパラメーターを持つ関数 &lt;code&gt;func&lt;/code&gt; です。最後のパラメーターは、完了時に &lt;code&gt;func&lt;/code&gt; が呼び出すコールバック関数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="9211f4b858fc968794a77bc7b1d03546135e6858" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bindNodeCallback&lt;/code&gt; is not an operator because its input and output are not Observables. The input is a function &lt;code&gt;func&lt;/code&gt; with some parameters, but the last parameter must be a callback function that &lt;code&gt;func&lt;/code&gt; calls when it is done. The callback function is expected to follow Node.js conventions, where the first argument to the callback is an error object, signaling whether call was successful. If that object is passed to callback, it means something went wrong.</source>
          <target state="translated">&lt;code&gt;bindNodeCallback&lt;/code&gt; は、その入出力が監視可能ではないため、オペレーターではありません。入力はいくつかのパラメーターを持つ関数 &lt;code&gt;func&lt;/code&gt; ですが、最後のパラメーターは、完了時に &lt;code&gt;func&lt;/code&gt; が呼び出すコールバック関数でなければなりません。コールバック関数はNode.jsの規則に従うことが期待されます。コールバックへの最初の引数は、呼び出しが成功したかどうかを通知するエラーオブジェクトです。そのオブジェクトがコールバックに渡された場合、何かがうまくいかなかったことを意味します。</target>
        </trans-unit>
        <trans-unit id="b958fd92ecb9faf8ae58cd7ebc6f92725abe218c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; -&amp;gt; &lt;code&gt;catchError&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; - &amp;gt; &lt;code&gt;catchError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="090112e53789f1e202cdc6c3e33483de9d1744a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;class&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a862595a3c1548793957cd83ac96a6a641a31216" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;class&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48fe30ff9e2a9d2bcaf4ee2c5d861788e26cdd20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cold(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; - creates a &lt;a href=&quot;https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339&quot;&gt;&quot;cold&quot; observable&lt;/a&gt; whose subscription starts when the test begins.</source>
          <target state="translated">&lt;code&gt;cold(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; - テストの開始時にサブスクリプションが開始される&lt;a href=&quot;https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339&quot;&gt;「コールド」オブザーバブル&lt;/a&gt;を作成します。</target>
        </trans-unit>
        <trans-unit id="86ed056620603316b0dd1656f24b1776a713dcee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cold(marbles: string, values?: object, error?: any)&lt;/code&gt; - creates a &quot;cold&quot; observable whose subscription starts when the test begins.</source>
          <target state="translated">&lt;code&gt;cold(marbles: string, values?: object, error?: any)&lt;/code&gt; -テストの開始時にサブスクリプションが開始される「コールド」オブザーバブルを作成します。</target>
        </trans-unit>
        <trans-unit id="f6b28dc7fe98921afceb99175e066d6a87d85a26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineAll&lt;/code&gt; takes an Observable of Observables, and collects all Observables from it. Once the outer Observable completes, it subscribes to all collected Observables and combines their values using the &lt;a href=&quot;../index/function/combinelatest&quot;&gt;&lt;code&gt;combineLatest&lt;/code&gt;&lt;/a&gt; strategy, such that:</source>
          <target state="translated">&lt;code&gt;combineAll&lt;/code&gt; は、ObservableのObservableを受け取り、そこからすべてのObservableを収集します。外側のObservableが完了すると、収集されたすべてのObservableをサブスクライブし、次のような&lt;a href=&quot;../index/function/combinelatest&quot;&gt; &lt;code&gt;combineLatest&lt;/code&gt; &lt;/a&gt;戦略を使用してそれらの値を結合します。</target>
        </trans-unit>
        <trans-unit id="c48c87a64f802358b3ec81f54db717377180b5f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineLatest&lt;/code&gt; accepts as optional parameter &lt;code&gt;project&lt;/code&gt; function, which takes as arguments all values that would normally be emitted by resulting Observable. &lt;code&gt;project&lt;/code&gt; can return any kind of value, which will be then emitted by Observable instead of default array. Note that &lt;code&gt;project&lt;/code&gt; does not take as argument that array of values, but values themselves. That means default &lt;code&gt;project&lt;/code&gt; can be imagined as function that takes all its arguments and puts them into an array.</source>
          <target state="translated">&lt;code&gt;combineLatest&lt;/code&gt; は、オプションのパラメーターとして &lt;code&gt;project&lt;/code&gt; 関数を受け入れます。この関数は、結果として得られるObservableによって通常出力されるすべての値を引数として受け取ります。 &lt;code&gt;project&lt;/code&gt; は任意の種類の値を返すことができ、その値はデフォルトの配列の代わりにObservableによって発行されます。 &lt;code&gt;project&lt;/code&gt; は、値の配列ではなく値自体を引数として取ることに注意してください。つまり、デフォルトの &lt;code&gt;project&lt;/code&gt; は、すべての引数を取り、それらを配列に入れる関数と考えることができます。</target>
        </trans-unit>
        <trans-unit id="a0acc0a59cb9c4861d27d529a998d4109e7b2dd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineLatest&lt;/code&gt; combines the values from all the Observables passed as arguments. This is done by subscribing to each Observable in order and, whenever any Observable emits, collecting an array of the most recent values from each Observable. So if you pass &lt;code&gt;n&lt;/code&gt; Observables to operator, returned Observable will always emit an array of &lt;code&gt;n&lt;/code&gt; values, in order corresponding to order of passed Observables (value from the first Observable on the first place and so on).</source>
          <target state="translated">&lt;code&gt;combineLatest&lt;/code&gt; は、引数として渡されたすべてのObservableの値を結合します。これは、各Observableを順番にサブスクライブし、Observableが発行するたびに、各Observableから最新の値の配列を収集することによって行われます。したがって、 &lt;code&gt;n&lt;/code&gt; 個の Observableを演算子に渡すと、返されたObservableは常に、 &lt;code&gt;n&lt;/code&gt; 個の値の配列を、渡されたObservable（最初のObservableからの値など）の順序に対応する順序で出力します。</target>
        </trans-unit>
        <trans-unit id="01ad8a728f3323a7a044e430120e60f1ce5b8a98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&lt;/code&gt; joins multiple Observables together, by subscribing to them one at a time and merging their results into the output Observable. You can pass either an array of Observables, or put them directly as arguments. Passing an empty array will result in Observable that completes immediately.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; は、一度に1つずつサブスクライブし、その結果を出力Observableにマージすることにより、複数のObservableを結合します。Observableの配列を渡すか、直接引数として渡すことができます。空の配列を渡すと、Observableがすぐに完了します。</target>
        </trans-unit>
        <trans-unit id="cd455e398737536791faa98b5aaf7d26b9064afe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&lt;/code&gt; will subscribe to first input Observable and emit all its values, without changing or affecting them in any way. When that Observable completes, it will subscribe to then next Observable passed and, again, emit its values. This will be repeated, until the operator runs out of Observables. When last input Observable completes, &lt;code&gt;concat&lt;/code&gt; will complete as well. At any given moment only one Observable passed to operator emits values. If you would like to emit values from passed Observables concurrently, check out &lt;a href=&quot;merge&quot;&gt;&lt;code&gt;merge&lt;/code&gt;&lt;/a&gt; instead, especially with optional &lt;code&gt;concurrent&lt;/code&gt; parameter. As a matter of fact, &lt;code&gt;concat&lt;/code&gt; is an equivalent of &lt;code&gt;merge&lt;/code&gt; operator with &lt;code&gt;concurrent&lt;/code&gt; parameter set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; は、最初の入力Observableをサブスクライブし、変更や影響を与えることなく、すべての値を出力します。そのObservableが完了すると、次に渡されるObservableにサブスクライブし、再びその値を発行します。これは、オペレーターがObservableを使い果たすまで繰り返されます。最後の入力Observableが完了すると、 &lt;code&gt;concat&lt;/code&gt; も完了します。任意の時点で、オペレーターに渡された1つのObservableのみが値を発行します。渡されたObservableから同時に値を出力する場合は、特にオプションの &lt;code&gt;concurrent&lt;/code&gt; パラメーターを使用して、代わりに&lt;a href=&quot;merge&quot;&gt; &lt;code&gt;merge&lt;/code&gt; &lt;/a&gt;を確認してください。実際のところ、 &lt;code&gt;concat&lt;/code&gt; は、 &lt;code&gt;concurrent&lt;/code&gt; パラメーターが次のように設定された &lt;code&gt;merge&lt;/code&gt; 演算子と同等です。 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="385581e593ae600c22359073bd8d84c8d9c69e58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a4d3fc4b7f98a5a344bac51798dbde83d943597" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; transforms an Observable that emits values into an Observable that emits a single value that represents the number of values emitted by the source Observable. If the source Observable terminates with an error, &lt;code&gt;count&lt;/code&gt; will pass this error notification along without emitting a value first. If the source Observable does not terminate at all, &lt;code&gt;count&lt;/code&gt; will neither emit a value nor terminate. This operator takes an optional &lt;code&gt;predicate&lt;/code&gt; function as argument, in which case the output emission will represent the number of source values that matched &lt;code&gt;true&lt;/code&gt; with the &lt;code&gt;predicate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; は、値を発行するObservableを、ソースObservableが発行する値の数を表す単一の値を発行するObservableに変換します。ソースObservableがエラーで終了した場合、 &lt;code&gt;count&lt;/code&gt; は最初に値を出力せずにこのエラー通知を渡します。ソースObservableがまったく終了しない場合、 &lt;code&gt;count&lt;/code&gt; は値を出力せず、終了しません。この演算子は、オプションの &lt;code&gt;predicate&lt;/code&gt; 関数を引数として取ります。この場合、出力エミッションは、 &lt;code&gt;predicate&lt;/code&gt; と &lt;code&gt;true&lt;/code&gt; に一致したソース値の数を表します。</target>
        </trans-unit>
        <trans-unit id="f0cdc1ef62ba04465e2f72df3b6dbbf436fe86ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debounce&lt;/code&gt; delays values emitted by the source Observable, but drops previous pending delayed emissions if a new value arrives on the source Observable. This operator keeps track of the most recent value from the source Observable, and spawns a duration Observable by calling the &lt;code&gt;durationSelector&lt;/code&gt; function. The value is emitted only when the duration Observable emits a value or completes, and if no other value was emitted on the source Observable since the duration Observable was spawned. If a new value appears before the duration Observable emits, the previous value will be dropped and will not be emitted on the output Observable.</source>
          <target state="translated">&lt;code&gt;debounce&lt;/code&gt; は、ソースObservableによって放出された値を遅延させますが、新しい値がソースObservableに到着した場合、以前の保留中の遅延放出をドロップします。このオペレーターは、ソースのObservableからの最新の値を追跡し、 &lt;code&gt;durationSelector&lt;/code&gt; 関数を呼び出すことによって、期間Observableを生成します。値は、Observableの継続時間が値を出力するか完了したとき、およびObservableの継続時間が生成されてからソースObservableで他の値が出力されなかった場合にのみ出力されます。 Observableが放出する期間の前に新しい値が表示される場合、以前の値は削除され、出力Observableで放出されません。</target>
        </trans-unit>
        <trans-unit id="37876e5463e7779e33fb2f769015b62934416edb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debounceTime&lt;/code&gt; delays values emitted by the source Observable, but drops previous pending delayed emissions if a new value arrives on the source Observable. This operator keeps track of the most recent value from the source Observable, and emits that only when &lt;code&gt;dueTime&lt;/code&gt; enough time has passed without any other value appearing on the source Observable. If a new value appears before &lt;code&gt;dueTime&lt;/code&gt; silence occurs, the previous value will be dropped and will not be emitted on the output Observable.</source>
          <target state="translated">&lt;code&gt;debounceTime&lt;/code&gt; は、ソースObservableによって放出された値を遅延させますが、新しい値がソースObservableに到着した場合、以前の保留中の遅延放出をドロップします。このオペレーターは、ソースObservableからの最新の値を追跡し、ソースObservableに他の値が表示されずに &lt;code&gt;dueTime&lt;/code&gt; の十分な時間が経過した場合にのみそれを出力します。 &lt;code&gt;dueTime&lt;/code&gt; silenceが発生する前に新しい値が表示される場合、以前の値は削除され、出力Observableで発生しません。</target>
        </trans-unit>
        <trans-unit id="c49335f81d19a51a43bd936b56c74ed6776fb327" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defaultIfEmpty&lt;/code&gt; emits the values emitted by the source Observable or a specified default value if the source Observable is empty (completes without having emitted any &lt;code&gt;next&lt;/code&gt; value).</source>
          <target state="translated">&lt;code&gt;defaultIfEmpty&lt;/code&gt; は観測ソースまたはソース観測が空の場合は指定されたデフォルト値（任意の放出されたことなく完了することによって放出された値発する &lt;code&gt;next&lt;/code&gt; 値）。</target>
        </trans-unit>
        <trans-unit id="b48bcd84068ffa0b67531f2cc7d97d7b8ddcc69e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defer&lt;/code&gt; allows you to create the Observable only when the Observer subscribes, and create a fresh Observable for each Observer. It waits until an Observer subscribes to it, and then it generates an Observable, typically with an Observable factory function. It does this afresh for each subscriber, so although each subscriber may think it is subscribing to the same Observable, in fact each subscriber gets its own individual Observable.</source>
          <target state="translated">&lt;code&gt;defer&lt;/code&gt; を使用すると、オブザーバーがサブスクライブするときにのみオブザーバブルを作成し、オブザーバーごとに新しいオブザーバブルを作成できます。オブザーバーがサブスクライブするまで待機してから、通常はObservableファクトリー関数を使用してObservableを生成します。これはサブスクライバーごとにこれを新たに実行するため、各サブスクライバーは同じObservableにサブスクライブしていると思うかもしれませんが、実際には各サブスクライバーは独自のObservableを取得します。</target>
        </trans-unit>
        <trans-unit id="5eaa3f953343c295087c9f21c5472ac2c26f0955" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delayWhen&lt;/code&gt; time shifts each emitted value from the source Observable by a time span determined by another Observable. When the source emits a value, the &lt;code&gt;delayDurationSelector&lt;/code&gt; function is called with the source value as argument, and should return an Observable, called the &quot;duration&quot; Observable. The source value is emitted on the output Observable only when the duration Observable emits a value or completes. The completion of the notifier triggering the emission of the source value is deprecated behavior and will be removed in future versions.</source>
          <target state="translated">&lt;code&gt;delayWhen&lt;/code&gt; ソースのObservableからの各放出値が、別のObservableによって決定された期間だけ時間シフトするとき。ソースが値を出力すると、 &lt;code&gt;delayDurationSelector&lt;/code&gt; 関数がソース値を引数として呼び出され、 &quot;duration&quot; Observableと呼ばれるObservableを返します。ソースの値は、Observableが値を出力するか、または完了する期間のみ、出力Observableで出力されます。ソース値の発行をトリガーする通知機能の完了は非推奨の動作であり、将来のバージョンでは削除される予定です。</target>
        </trans-unit>
        <trans-unit id="263c061588410725a4756688a261e25ff539d88a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; is assumed to operate an Observable that only emits &lt;a href=&quot;../index/class/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; objects as &lt;code&gt;next&lt;/code&gt; emissions, and does not emit any &lt;code&gt;error&lt;/code&gt;. Such Observable is the output of a &lt;code&gt;materialize&lt;/code&gt; operation. Those notifications are then unwrapped using the metadata they contain, and emitted as &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, and &lt;code&gt;complete&lt;/code&gt; on the output Observable.</source>
          <target state="translated">&lt;code&gt;dematerialize&lt;/code&gt; は、&lt;a href=&quot;../index/class/notification&quot;&gt; &lt;code&gt;Notification&lt;/code&gt; &lt;/a&gt;オブジェクトを &lt;code&gt;next&lt;/code&gt; 放出としてのみ放出し、 &lt;code&gt;error&lt;/code&gt; 放出しないObservableを操作すると想定されています。このようなObservableは、 &lt;code&gt;materialize&lt;/code&gt; ライズ操作の出力です。次に、それらの通知は、それらに含まれるメタデータを使用してラップ解除され、 &lt;code&gt;next&lt;/code&gt; 、 &lt;code&gt;error&lt;/code&gt; 、および &lt;code&gt;complete&lt;/code&gt; として出力Observableで発行されます。</target>
        </trans-unit>
        <trans-unit id="337f0156035bbe32cb1c65689f5ceaab1523241c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;distinctUntilKeyChanged&lt;/code&gt; emits all items of the source Observable, wich are distinct by comparison. The comparison checks if the previous item is distinct from the current item, using a &lt;code&gt;key&lt;/code&gt; to access a property. If a comparator function is provided, then it will be called for each item with the property key to test for whether or not that value should be emitted.</source>
          <target state="translated">&lt;code&gt;distinctUntilKeyChanged&lt;/code&gt; を比較することによって区別されるWICH源観測のすべてのアイテムを、発します。比較では、 &lt;code&gt;key&lt;/code&gt; を使用してプロパティにアクセスし、前のアイテムが現在のアイテムと異なるかどうかを確認します。コンパレーター関数が提供されている場合、その値が発行されるかどうかをテストするために、プロパティキーを使用してアイテムごとに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="c68787b081b8a13ef3a2883757212c65f8a16510" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt; -&amp;gt; &lt;code&gt;tap&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; -&amp;gt; &lt;code&gt;tap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7709400aa46a908f912c42fdd85c31afe4bd334c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;elementAt&lt;/code&gt; returns an Observable that emits the item at the specified &lt;code&gt;index&lt;/code&gt; in the source Observable, or a default value if that &lt;code&gt;index&lt;/code&gt; is out of range and the &lt;code&gt;default&lt;/code&gt; argument is provided. If the &lt;code&gt;default&lt;/code&gt; argument is not given and the &lt;code&gt;index&lt;/code&gt; is out of range, the output Observable will emit an &lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; error.</source>
          <target state="translated">&lt;code&gt;elementAt&lt;/code&gt; は、ソースのObservableの指定された &lt;code&gt;index&lt;/code&gt; でアイテムを発行するObservableを返します。または、その &lt;code&gt;index&lt;/code&gt; が範囲外であり、 &lt;code&gt;default&lt;/code&gt; 引数が指定されている場合はデフォルト値を返します。場合は &lt;code&gt;default&lt;/code&gt; 引数が与えられておらず、 &lt;code&gt;index&lt;/code&gt; 範囲外にある、出力観測が放出する &lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; のエラーを。</target>
        </trans-unit>
        <trans-unit id="48cd8a1eb0de7b3c8ccb7d3f4b8f0aab446953b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76ad9b9d842a773470337752107150337d51fd75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exhaust&lt;/code&gt; subscribes to an Observable that emits Observables, also known as a higher-order Observable. Each time it observes one of these emitted inner Observables, the output Observable begins emitting the items emitted by that inner Observable. So far, it behaves like &lt;a href=&quot;mergeall&quot;&gt;&lt;code&gt;mergeAll&lt;/code&gt;&lt;/a&gt;. However, &lt;code&gt;exhaust&lt;/code&gt; ignores every new inner Observable if the previous Observable has not yet completed. Once that one completes, it will accept and flatten the next inner Observable and repeat this process.</source>
          <target state="translated">&lt;code&gt;exhaust&lt;/code&gt; は、高次Observableとも呼ばれるObservableを発行するObservableにサブスクライブします。これらの放出された内部Observableの1つを観察するたびに、出力Observableはその内部Observableによって放出されたアイテムの放出を開始します。これまでのところ、それは&lt;a href=&quot;mergeall&quot;&gt; &lt;code&gt;mergeAll&lt;/code&gt; の&lt;/a&gt;ように動作します。ただし、前のObservableがまだ完了していない場合、 &lt;code&gt;exhaust&lt;/code&gt; は新しい内部Observableをすべて無視します。それが完了すると、次の内側のObservableを受け入れて平坦化し、このプロセスを繰り返します。</target>
        </trans-unit>
        <trans-unit id="40ffb7c8fd558d6f81aaa088689dbebae17d57a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expectObservable(actual: Observable&amp;lt;T&amp;gt;).toBe(marbles: string, values?: object, error?: any)&lt;/code&gt; - schedules an assertion for when the TestScheduler flushes. The TestScheduler will automatically flush at the end of your jasmine &lt;code&gt;it&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;expectObservable(actual: Observable&amp;lt;T&amp;gt;).toBe(marbles: string, values?: object, error?: any)&lt;/code&gt; -TestSchedulerがフラッシュしたときのアサーションをスケジュールします。TestSchedulerは &lt;code&gt;it&lt;/code&gt; ブロックするジャスミンの最後に自動的にフラッシュします。</target>
        </trans-unit>
        <trans-unit id="549efb9322293515e99c072f635c335f7dea77ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expectObservable(actual: Observable&amp;lt;T&amp;gt;, subscriptionMarbles?: string).toBe(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; - schedules an assertion for when the TestScheduler flushes. Give &lt;code&gt;subscriptionMarbles&lt;/code&gt; as parameter to change the schedule of subscription and unsubscription. If you don't provide the &lt;code&gt;subscriptionMarbles&lt;/code&gt; parameter it will subscribe at the beginning and never unsubscribe. Read below about subscription marble diagram.</source>
          <target state="translated">&lt;code&gt;expectObservable(actual: Observable&amp;lt;T&amp;gt;, subscriptionMarbles?: string).toBe(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; -TestSchedulerがフラッシュしたときのアサーションをスケジュールします。与える &lt;code&gt;subscriptionMarbles&lt;/code&gt; を購読し、退会のスケジュールを変更するパラメータとして。 &lt;code&gt;subscriptionMarbles&lt;/code&gt; パラメータを指定しない場合、最初にサブスクライブされ、サブスクライブが解除されることはありません。サブスクリプションの大理石図については以下をお読みください。</target>
        </trans-unit>
        <trans-unit id="b7e81cef1adea62fe9dabc7f8970e2ecbcee0d1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]).toBe(subscriptionMarbles: string)&lt;/code&gt; - like &lt;code&gt;expectObservable&lt;/code&gt; schedules an assertion for when the testScheduler flushes. Both &lt;code&gt;cold()&lt;/code&gt; and &lt;code&gt;hot()&lt;/code&gt; return an observable with a property &lt;code&gt;subscriptions&lt;/code&gt; of type &lt;code&gt;SubscriptionLog[]&lt;/code&gt;. Give &lt;code&gt;subscriptions&lt;/code&gt; as parameter to &lt;code&gt;expectSubscriptions&lt;/code&gt; to assert whether it matches the &lt;code&gt;subscriptionsMarbles&lt;/code&gt; marble diagram given in &lt;code&gt;toBe()&lt;/code&gt;. Subscription marble diagrams are slightly different than Observable marble diagrams. Read more below.</source>
          <target state="translated">&lt;code&gt;expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]).toBe(subscriptionMarbles: string)&lt;/code&gt; &lt;code&gt;expectObservable&lt;/code&gt; 同様に、testSchedulerがフラッシュするときのアサーションをスケジュールします。 &lt;code&gt;cold()&lt;/code&gt; と &lt;code&gt;hot()&lt;/code&gt; はどちらも、タイプ &lt;code&gt;SubscriptionLog[]&lt;/code&gt; プロパティ &lt;code&gt;subscriptions&lt;/code&gt; を持つオブザーバブルを返します。与える &lt;code&gt;subscriptions&lt;/code&gt; へのパラメータとして &lt;code&gt;expectSubscriptions&lt;/code&gt; それが一致するかどうかをアサートする &lt;code&gt;subscriptionsMarbles&lt;/code&gt; の中で与えられた大理石の図 &lt;code&gt;toBe()&lt;/code&gt; 。サブスクリプションの大理石図は、観察可能な大理石図とは少し異なります。以下を読んでください。</target>
        </trans-unit>
        <trans-unit id="468eda33598bc9af7354a4a5ba445b8895a6ac71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finally&lt;/code&gt; -&amp;gt; &lt;code&gt;finalize&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;finally&lt;/code&gt; -&amp;gt; &lt;code&gt;finalize&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="513a86951178ed9972ed24317636bd2a20645e11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&lt;/code&gt; searches for the first item in the source Observable that matches the specified condition embodied by the &lt;code&gt;predicate&lt;/code&gt;, and returns the first occurrence in the source. Unlike &lt;a href=&quot;first&quot;&gt;&lt;code&gt;first&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;predicate&lt;/code&gt; is required in &lt;code&gt;find&lt;/code&gt;, and does not emit an error if a valid value is not found.</source>
          <target state="translated">&lt;code&gt;find&lt;/code&gt; は、 &lt;code&gt;predicate&lt;/code&gt; によって具体化された指定された条件に一致するソースObservable内の最初の項目を検索し、ソース内の最初の出現を返します。&lt;a href=&quot;first&quot;&gt; &lt;code&gt;first&lt;/code&gt; &lt;/a&gt;とは異なり、 &lt;code&gt;predicate&lt;/code&gt; は &lt;code&gt;find&lt;/code&gt; で必須であり、有効な値が見つからない場合でもエラーを発行しません。</target>
        </trans-unit>
        <trans-unit id="42f3c71e5ee0b7b93c06c1bd1e67828f7bee0200" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findIndex&lt;/code&gt; searches for the first item in the source Observable that matches the specified condition embodied by the &lt;code&gt;predicate&lt;/code&gt;, and returns the (zero-based) index of the first occurrence in the source. Unlike &lt;a href=&quot;first&quot;&gt;&lt;code&gt;first&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;predicate&lt;/code&gt; is required in &lt;code&gt;findIndex&lt;/code&gt;, and does not emit an error if a valid value is not found.</source>
          <target state="translated">&lt;code&gt;findIndex&lt;/code&gt; は、 &lt;code&gt;predicate&lt;/code&gt; によって具体化された指定された条件に一致するソースObservableの最初の項目を検索し、ソースで最初に出現した（ゼロから始まる）インデックスを返します。&lt;a href=&quot;first&quot;&gt; &lt;code&gt;first&lt;/code&gt; &lt;/a&gt;とは異なり、 &lt;code&gt;predicate&lt;/code&gt; は &lt;code&gt;findIndex&lt;/code&gt; で必須であり、有効な値が見つからない場合でもエラーを発行しません。</target>
        </trans-unit>
        <trans-unit id="bbafc7127363c7baba3b13392ba68a2794417a48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flush()&lt;/code&gt; - immediately starts virtual time. Not often used since &lt;code&gt;run()&lt;/code&gt; will automatically flush for you when your callback returns, but in some cases you may wish to flush more than once or otherwise have more control.</source>
          <target state="translated">&lt;code&gt;flush()&lt;/code&gt; -すぐに仮想時間を開始します。 &lt;code&gt;run()&lt;/code&gt; はコールバックが戻ったときに自動的にフラッシュするため、あまり使用されませんが、場合によっては、複数回フラッシュしたり、制御を強化したりすることができます。</target>
        </trans-unit>
        <trans-unit id="7a725c42c24e4558c24a6dceba8ebb231a13bba5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forkJoin&lt;/code&gt; is an operator that takes any number of input observables which can be passed either as an array or a dictionary of input observables. If no input observables are provided, resulting stream will complete immediately.</source>
          <target state="translated">&lt;code&gt;forkJoin&lt;/code&gt; は、配列または入力オブザーバブルの辞書として渡すことができる任意の数の入力オブザーバブルを受け取る演算子です。入力オブザーバブルが提供されない場合、結果のストリームはすぐに完了します。</target>
        </trans-unit>
        <trans-unit id="7d066c42163ed51de74c8d0a23c6fbe14edf715a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forkJoin&lt;/code&gt; will wait for all passed observables to complete and then it will emit an array or an object with last values from corresponding observables.</source>
          <target state="translated">&lt;code&gt;forkJoin&lt;/code&gt; は、渡されたすべてのオブザーバブルが完了するのを待ってから、対応するオブザーバブルの最後の値を持つ配列またはオブジェクトを発行します。</target>
        </trans-unit>
        <trans-unit id="701b8bcaf7f433faa8857e32bc6ab6cb78a529cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from&lt;/code&gt; converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable&quot;&gt;iterable&lt;/a&gt; object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be converted through this operator.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; は、他のさまざまなオブジェクトおよびデータ型をObservableに変換します。また、Promise、配列のようなオブジェクト、または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable&quot;&gt;反復可能な&lt;/a&gt;オブジェクトを、そのpromise、配列、または反復可能なアイテムを生成するObservableに変換します。このコンテキストでは、文字列は文字の配列として扱われます。 Observableのようなオブジェクト（ES2015 Symbol for Observableで名前が付けられた関数を含む）も、この演算子を使用して変換できます。</target>
        </trans-unit>
        <trans-unit id="f6cd47e56e386e34dc898b3c2f75f66f676fe304" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromEvent&lt;/code&gt; accepts as a first argument event target, which is an object with methods for registering event handler functions. As a second argument it takes string that indicates type of event we want to listen for. &lt;code&gt;fromEvent&lt;/code&gt; supports selected types of event targets, which are described in detail below. If your event target does not match any of the ones listed, you should use &lt;a href=&quot;fromeventpattern&quot;&gt;&lt;code&gt;fromEventPattern&lt;/code&gt;&lt;/a&gt;, which can be used on arbitrary APIs. When it comes to APIs supported by &lt;code&gt;fromEvent&lt;/code&gt;, their methods for adding and removing event handler functions have different names, but they all accept a string describing event type and function itself, which will be called whenever said event happens.</source>
          <target state="translated">&lt;code&gt;fromEvent&lt;/code&gt; は、最初の引数としてイベントターゲットを受け入れます。これは、イベントハンドラー関数を登録するためのメソッドを持つオブジェクトです。2番目の引数として、リッスンするイベントのタイプを示す文字列を取ります。 &lt;code&gt;fromEvent&lt;/code&gt; は、以下で詳細に説明する、選択したタイプのイベントターゲットをサポートします。イベントターゲットがリストされているものと一致しない場合は、任意のAPIで使用できる&lt;a href=&quot;fromeventpattern&quot;&gt; &lt;code&gt;fromEventPattern&lt;/code&gt; &lt;/a&gt;を使用する必要があります。 &lt;code&gt;fromEvent&lt;/code&gt; でサポートされているAPI に関しては、イベントハンドラー関数を追加および削除するためのメソッドの名前は異なりますが、それらはすべて、イベントタイプと関数自体を説明する文字列を受け入れます。</target>
        </trans-unit>
        <trans-unit id="1462671f1cb00bce6cf0a828bb7679536e52712a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromEvent&lt;/code&gt; supports following types of event targets:</source>
          <target state="translated">&lt;code&gt;fromEvent&lt;/code&gt; は、次のタイプのイベントターゲットをサポートしています。</target>
        </trans-unit>
        <trans-unit id="63e874687188bf84e0cd65512816c5a08aed1deb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromEventPattern&lt;/code&gt; allows you to convert into an Observable any API that supports registering handler functions for events. It is similar to &lt;a href=&quot;fromevent&quot;&gt;&lt;code&gt;fromEvent&lt;/code&gt;&lt;/a&gt;, but far more flexible. In fact, all use cases of &lt;a href=&quot;fromevent&quot;&gt;&lt;code&gt;fromEvent&lt;/code&gt;&lt;/a&gt; could be easily handled by &lt;code&gt;fromEventPattern&lt;/code&gt; (although in slightly more verbose way).</source>
          <target state="translated">&lt;code&gt;fromEventPattern&lt;/code&gt; を使用すると、イベントのハンドラー関数の登録をサポートするObservable任意のAPIに変換できます。これは&lt;a href=&quot;fromevent&quot;&gt; &lt;code&gt;fromEvent&lt;/code&gt; &lt;/a&gt;に似ていますが、はるかに柔軟です。実際には、すべてのユースケース&lt;a href=&quot;fromevent&quot;&gt; &lt;code&gt;fromEvent&lt;/code&gt; は&lt;/a&gt;簡単で扱うことができ &lt;code&gt;fromEventPattern&lt;/code&gt; （ただし、やや冗長な方法で）。</target>
        </trans-unit>
        <trans-unit id="0e7665a15f690a6c0179b0183091da0c68190f5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func.call()&lt;/code&gt; means &quot;&lt;em&gt;give me one value synchronously&lt;/em&gt;&quot;</source>
          <target state="translated">&lt;code&gt;func.call()&lt;/code&gt; の手段は、「&lt;em&gt;同期私に一つの値を与えます&lt;/em&gt;」</target>
        </trans-unit>
        <trans-unit id="8fe45d23f684b15638587a600e466d7276009066" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;function&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="81fd3bab51295b9b61c59cc065e6349a7f240f69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;function&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3ba75bfe8b6d2f7dad160fa84807c8529ff10b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;generate&lt;/code&gt; allows you to create stream of values generated with a loop very similar to traditional for loop. First argument of &lt;code&gt;generate&lt;/code&gt; is a beginning value. Second argument is a function that accepts this value and tests if some condition still holds. If it does, loop continues, if not, it stops. Third value is a function which takes previously defined value and modifies it in some way on each iteration. Note how these three parameters are direct equivalents of three expressions in regular for loop: first expression initializes some state (for example numeric index), second tests if loop can make next iteration (for example if index is lower than 10) and third states how defined value will be modified on every step (index will be incremented by one).</source>
          <target state="translated">&lt;code&gt;generate&lt;/code&gt; を使用すると、従来のforループとよく似たループで生成された値のストリームを作成できます。 &lt;code&gt;generate&lt;/code&gt; の最初の引数は開始値です。 2番目の引数は、この値を受け入れて、何らかの条件がまだ成立しているかどうかをテストする関数です。含まれている場合はループが続行され、含まれていない場合は停止します。 3番目の値は、以前に定義された値を取り、反復ごとに何らかの方法で変更する関数です。これらの3つのパラメーターが通常のforループの3つの式と直接同等であることに注意してください：最初の式はいくつかの状態（たとえば、数値インデックス）を初期化し、2番目のテストはループが次の反復を行えるかどうか（たとえば、インデックスが10未満の場合）をテストし、3番目の状態はどのように定義された値はすべてのステップで変更されます（インデックスは1ずつ増加します）。</target>
        </trans-unit>
        <trans-unit id="94c16493b674e13437dfb3fd79fcd0ea9dff5d88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot('---#')&lt;/code&gt; will emit error &lt;code&gt;&quot;error&quot;&lt;/code&gt; whereas</source>
          <target state="translated">&lt;code&gt;hot('---#')&lt;/code&gt; はエラー &lt;code&gt;&quot;error&quot;&lt;/code&gt; を発行しますが、</target>
        </trans-unit>
        <trans-unit id="d6a2e8fa0c13885a147ad8101a000224f75f5e84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot('---#', null, new SpecialError('test'))&lt;/code&gt; will emit &lt;code&gt;new SpecialError('test')&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hot('---#', null, new SpecialError('test'))&lt;/code&gt; は &lt;code&gt;new SpecialError('test')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2911c19e5e499272edbb90d648b992bf10bf1534" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot('--a--b')&lt;/code&gt; will emit &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;&quot;b&quot;&lt;/code&gt; whereas</source>
          <target state="translated">&lt;code&gt;hot('--a--b')&lt;/code&gt; -a --b'）は &lt;code&gt;&quot;a&quot;&lt;/code&gt; と &lt;code&gt;&quot;b&quot;&lt;/code&gt; を出力しますが、</target>
        </trans-unit>
        <trans-unit id="799d6476abc1d323a6766cadbdeb1eaebd8adc4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot('--a--b', { a: 1, b: 2 })&lt;/code&gt; will emit &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hot('--a--b', { a: 1, b: 2 })&lt;/code&gt; は &lt;code&gt;1&lt;/code&gt; と &lt;code&gt;2&lt;/code&gt; を放出します。</target>
        </trans-unit>
        <trans-unit id="767983367cb68219511d69bc8f1151ae9e35c771" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; - creates a &lt;a href=&quot;https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339&quot;&gt;&quot;hot&quot; observable&lt;/a&gt; (like a subject) that will behave as though it's already &quot;running&quot; when the test begins. An interesting difference is that &lt;code&gt;hot&lt;/code&gt; marbles allow a &lt;code&gt;^&lt;/code&gt; character to signal where the &quot;zero frame&quot; is. This is the default point at which the subscription to observables being tested begins, (this can be configured - see &lt;code&gt;expectObservable&lt;/code&gt; below).</source>
          <target state="translated">&lt;code&gt;hot(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; - テストの開始時にすでに「実行中」であるかのように動作する&lt;a href=&quot;https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339&quot;&gt;「&lt;/a&gt;サブジェクト」のような「ホット」なオブザーバブルを作成します。興味深い違いは、 &lt;code&gt;hot&lt;/code&gt; マーブルにより、 &lt;code&gt;^&lt;/code&gt; 文字が「ゼロフレーム」の位置を示すことができることです。これは、テストされるオブザーバブルのサブスクリプションが開始するデフォルトのポイントです（これは構成できます- 以下の &lt;code&gt;expectObservable&lt;/code&gt; を参照してください）。</target>
        </trans-unit>
        <trans-unit id="5a7962e956269eb833ec362893ebed3b1638a063" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot(marbles: string, values?: object, error?: any)&lt;/code&gt; - creates a &quot;hot&quot; observable (a subject) that will behave as though it's already &quot;running&quot; when the test begins. An interesting difference is that &lt;code&gt;hot&lt;/code&gt; marbles allow a &lt;code&gt;^&lt;/code&gt; character to signal where the &quot;zero frame&quot; is. That is the point at which the subscription to observables being tested begins.</source>
          <target state="translated">&lt;code&gt;hot(marbles: string, values?: object, error?: any)&lt;/code&gt; -テストの開始時にすでに「実行中」であるかのように動作する「ホット」オブザーバブル（サブジェクト）を作成します。興味深い違いは、 &lt;code&gt;hot&lt;/code&gt; マーブルにより、 &lt;code&gt;^&lt;/code&gt; 文字が「ゼロフレーム」の位置を示すことができることです。これは、テストされているオブザーバブルのサブスクリプションが始まる時点です。</target>
        </trans-unit>
        <trans-unit id="0690d36fbdcb56b4f242b89d13ab4d0c31ca0bc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;http.get()&lt;/code&gt; returns an Observable (of string or string arrays probably) for each individual URL. Now you have an Observables &lt;em&gt;of&lt;/em&gt; Observables, a higher-order Observable.</source>
          <target state="translated">&lt;code&gt;http.get()&lt;/code&gt; は、個々のURLごとに（おそらく文字列または文字列配列の）Observableを返します。これで、高次&lt;em&gt;の&lt;/em&gt; ObservableであるObservableのObservableができました。</target>
        </trans-unit>
        <trans-unit id="981ee7c6f5b4848e80c872e42d57f19bc3938e4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iif&lt;/code&gt; accepts a condition function and two Observables. When an Observable returned by the operator is subscribed, condition function will be called. Based on what boolean it returns at that moment, consumer will subscribe either to the first Observable (if condition was true) or to the second (if condition was false). Condition function may also not return anything - in that case condition will be evaluated as false and second Observable will be subscribed.</source>
          <target state="translated">&lt;code&gt;iif&lt;/code&gt; は、条件関数と2つのObservableを受け入れます。オペレーターから返されたObservableがサブスクライブされると、条件関数が呼び出されます。その時点で返されるブール値に基づいて、コンシューマーは最初のObservable（条件が真の場合）または2番目の（条件が真の場合）をサブスクライブします。条件関数も何も返さない場合があります。その場合、条件はfalseと評価され、2番目のObservableがサブスクライブされます。</target>
        </trans-unit>
        <trans-unit id="ff917215158e324736c1491962076002ae2685e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index&lt;/code&gt;: the (zero-based) &quot;index&quot; of the value from the source Observable.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; ：ソースObservableからの値の（ゼロから始まる）「インデックス」。</target>
        </trans-unit>
        <trans-unit id="da2c4ef43d82866aae3c09d679912b62685d5d30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interface&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;interface&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c06c8243829ec012b90429a487f7f9de74dfe132" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interval&lt;/code&gt; returns an Observable that emits an infinite sequence of ascending integers, with a constant interval of time of your choosing between those emissions. The first emission is not sent immediately, but only after the first period has passed. By default, this operator uses the &lt;code&gt;async&lt;/code&gt;&lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to provide a notion of time, but you may pass any &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to it.</source>
          <target state="translated">&lt;code&gt;interval&lt;/code&gt; は、昇順の整数の無限シーケンスを放出するObservableを返します。これらの放出の間で選択した時間間隔は一定です。最初の放出はすぐには送信されず、最初の期間が経過した後でのみ送信されます。デフォルトでは、このオペレーターは &lt;code&gt;async&lt;/code&gt; &lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;を使用して時間の概念を提供しますが、任意の&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="7aec19d4438c03177ae60e77c76f1deda18e1f69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isEmpty&lt;/code&gt; transforms an Observable that emits values into an Observable that emits a single boolean value representing whether or not any values were emitted by the source Observable. As soon as the source Observable emits a value, &lt;code&gt;isEmpty&lt;/code&gt; will emit a &lt;code&gt;false&lt;/code&gt; and complete. If the source Observable completes having not emitted anything, &lt;code&gt;isEmpty&lt;/code&gt; will emit a &lt;code&gt;true&lt;/code&gt; and complete.</source>
          <target state="translated">&lt;code&gt;isEmpty&lt;/code&gt; は、値を発行するObservableを、ソースObservableによって値が発行されたかどうかを表す単一のブール値を発行するObservableに変換します。ソースObservableが値を &lt;code&gt;isEmpty&lt;/code&gt; するとすぐに、isEmptyは &lt;code&gt;false&lt;/code&gt; を発行して完了します。ソースObservableが何も出力せずに完了した場合、 &lt;code&gt;isEmpty&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; を完了して完了します。</target>
        </trans-unit>
        <trans-unit id="c31771f17b1d50d97171a9c911e381ff4519dabb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;materialize&lt;/code&gt; returns an Observable that emits a &lt;code&gt;next&lt;/code&gt; notification for each &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, or &lt;code&gt;complete&lt;/code&gt; emission of the source Observable. When the source Observable emits &lt;code&gt;complete&lt;/code&gt;, the output Observable will emit &lt;code&gt;next&lt;/code&gt; as a Notification of type &quot;complete&quot;, and then it will emit &lt;code&gt;complete&lt;/code&gt; as well. When the source Observable emits &lt;code&gt;error&lt;/code&gt;, the output will emit &lt;code&gt;next&lt;/code&gt; as a Notification of type &quot;error&quot;, and then &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;materialize&lt;/code&gt; 発するその観測戻り &lt;code&gt;next&lt;/code&gt; それぞれの通知 &lt;code&gt;next&lt;/code&gt; 、 &lt;code&gt;error&lt;/code&gt; 、または &lt;code&gt;complete&lt;/code&gt; 観測光源の発光を。ソースのObservableが &lt;code&gt;complete&lt;/code&gt; を発行すると、出力のObservableはタイプ「complete」の通知として &lt;code&gt;next&lt;/code&gt; 発行され、その後、それも &lt;code&gt;complete&lt;/code&gt; を発行します。ソースのObservableが &lt;code&gt;error&lt;/code&gt; を出力すると、出力はタイプ「エラー」の通知として &lt;code&gt;next&lt;/code&gt; 出力され、 &lt;code&gt;complete&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="a620a1dab62832d7036c018e55f712758cba7539" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; subscribes to each given input Observable (as arguments), and simply forwards (without doing any transformation) all the values from all the input Observables to the output Observable. The output Observable only completes once all input Observables have completed. Any error delivered by an input Observable will be immediately emitted on the output Observable.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; は、指定された各入力Observableを（引数として）サブスクライブし、すべての値をすべての入力Observableから出力Observableに（変換を行わずに）転送します。出力Observableは、すべての入力Observableが完了すると完了します。入力Observableによって配信されたエラーは、出力Observableですぐに出力されます。</target>
        </trans-unit>
        <trans-unit id="59410dc6a24fddd12fdff9f08ed905e09d08d34c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeAll&lt;/code&gt; subscribes to an Observable that emits Observables, also known as a higher-order Observable. Each time it observes one of these emitted inner Observables, it subscribes to that and delivers all the values from the inner Observable on the output Observable. The output Observable only completes once all inner Observables have completed. Any error delivered by a inner Observable will be immediately emitted on the output Observable.</source>
          <target state="translated">&lt;code&gt;mergeAll&lt;/code&gt; は、高次Observableとも呼ばれるObservableを発行するObservableをサブスクライブします。これらの放出された内部Observableの1つを観察するたびに、それをサブスクライブし、内部Observableからのすべての値を出力Observableに配信します。出力Observableは、すべての内部Observableが完了すると完了します。内部のObservableによって配信されたエラーは、出力Observableですぐに出力されます。</target>
        </trans-unit>
        <trans-unit id="777683b7cfdd5857d651bddab3fd9e125e6cb74e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multicast&lt;/code&gt; returns an Observable that looks like a normal Observable, but works like a Subject when it comes to subscribing. &lt;code&gt;multicast&lt;/code&gt; returns a &lt;code&gt;ConnectableObservable&lt;/code&gt;, which is simply an Observable with the &lt;code&gt;connect()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;multicast&lt;/code&gt; は、通常のObservableのように見えますが、サブスクライブに関してはSubjectのように機能するObservableを返します。 &lt;code&gt;multicast&lt;/code&gt; は &lt;code&gt;ConnectableObservable&lt;/code&gt; を返します。これは、単に &lt;code&gt;connect()&lt;/code&gt; メソッドを使用したObservable です。</target>
        </trans-unit>
        <trans-unit id="5f5b38c7d5c43ed1d44d70a0d42babaf3da2c27d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;observable.subscribe()&lt;/code&gt; means &quot;&lt;em&gt;give me any amount of values, either synchronously or asynchronously&lt;/em&gt;&quot;</source>
          <target state="translated">&lt;code&gt;observable.subscribe()&lt;/code&gt; の手段は、「&lt;em&gt;同期または非同期、私の値の任意の量を与えます&lt;/em&gt;」</target>
        </trans-unit>
        <trans-unit id="5a554e609492cca8c57b2a0aecc84d1057a5aac3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;observeOn&lt;/code&gt; is an operator that accepts a scheduler as a first parameter, which will be used to reschedule notifications emitted by the source Observable. It might be useful, if you do not have control over internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.</source>
          <target state="translated">&lt;code&gt;observeOn&lt;/code&gt; は、最初のパラメーターとしてスケジューラーを受け入れるオペレーターであり、ソースObservableによって発行された通知を再スケジュールするために使用されます。これは、特定のObservableの内部スケジューラを制御できないが、その値がいつ出力されるかを制御したい場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="d1994390fee01ea975c48bfe909a4072be3d883a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; Will subscribe to each observable source it is provided, in order. If the source it's subscribed to emits an error or completes, it will move to the next source without error.</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; 提供される各監視可能なソースを順番にサブスクライブします。サブスクライブしているソースがエラーを出力または完了した場合、エラーなしで次のソースに移動します。</target>
        </trans-unit>
        <trans-unit id="ef16d58131c642abbfab0c592384eafb6f227b95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; can be therefore thought of as version of &lt;a href=&quot;../index/function/concat&quot;&gt;&lt;code&gt;concat&lt;/code&gt;&lt;/a&gt; operator, which is more permissive when it comes to the errors emitted by its input Observables. While &lt;code&gt;concat&lt;/code&gt; subscribes to the next Observable in series only if previous one successfully completed, &lt;code&gt;onErrorResumeNext&lt;/code&gt; subscribes even if it ended with an error.</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; したがって、onErrorResumeNextは&lt;a href=&quot;../index/function/concat&quot;&gt; &lt;code&gt;concat&lt;/code&gt; &lt;/a&gt;演算子のバージョンと考えることができます。concat演算子は、入力Observableによって発行されるエラーに関してはより寛容です。一方で &lt;code&gt;concat&lt;/code&gt; シリーズの次の観察可能に加入しているが、以前のものが正常に完了した場合にのみ、 &lt;code&gt;onErrorResumeNext&lt;/code&gt; は、それはエラーで終了した場合でもサブスクライブします。</target>
        </trans-unit>
        <trans-unit id="291e2549ced3cc796e330b6fc2231a429b9e5349" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; is an operator that accepts a series of Observables, provided either directly as arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same as the source.</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; は、引数または配列として直接提供される一連のObservableを受け入れる演算子です。Observableが1つも指定されていない場合、返されたObservableはソースと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="1dd5ccaf3fba11c911848593b79d46ec1794b960" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; is basically &lt;a href=&quot;concat&quot;&gt;&lt;code&gt;concat&lt;/code&gt;&lt;/a&gt;, only it will continue, even if one of its sources emits an error.</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; は基本的に&lt;a href=&quot;concat&quot;&gt; &lt;code&gt;concat&lt;/code&gt; であり&lt;/a&gt;、そのソースの1つがエラーを発行した場合でも、それだけが続行されます。</target>
        </trans-unit>
        <trans-unit id="ff80ad62141e00cd2add9d085cf99cc33cc90177" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; returns an Observable that starts by subscribing and re-emitting values from the source Observable. When its stream of values ends - no matter if Observable completed or emitted an error - &lt;code&gt;onErrorResumeNext&lt;/code&gt; will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting its values as well and - again - when that stream ends, &lt;code&gt;onErrorResumeNext&lt;/code&gt; will proceed to subscribing yet another Observable in provided series, no matter if previous Observable completed or ended with an error. This will be happening until there is no more Observables left in the series, at which point returned Observable will complete - even if the last subscribed stream ended with an error.</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; は、ソースObservableから値をサブスクライブして再送信することから始まるObservableを返します。値のストリームが終了すると、Observableが完了したかエラーを &lt;code&gt;onErrorResumeNext&lt;/code&gt; したかに関係なく、onErrorResumeNextは、メソッドに引数として渡された最初のObservableをサブスクライブします。値の再 &lt;code&gt;onErrorResumeNext&lt;/code&gt; も開始し、再び-そのストリームが終了すると、onErrorResumeNextは、以前のObservableが完了したかエラーで終了したかに関係なく、提供されたシリーズのさらに別のObservableのサブスクライブに進みます。これは、シリーズにObservableがなくなるまで発生します。その時点で、最後にサブスクライブされたストリームがエラーで終了した場合でも、返されたObservableは完了します。</target>
        </trans-unit>
        <trans-unit id="1c9b05342b9557c75c17b290cebc80a1b1e3220f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pairs&lt;/code&gt; takes an arbitrary object and returns an Observable that emits arrays. Each emitted array has exactly two elements - the first is a key from the object and the second is a value corresponding to that key. Keys are extracted from an object via &lt;code&gt;Object.keys&lt;/code&gt; function, which means that they will be only enumerable keys that are present on an object directly - not ones inherited via prototype chain.</source>
          <target state="translated">&lt;code&gt;pairs&lt;/code&gt; は任意のオブジェクトを取り、配列を出力するObservableを返します。放出された各配列には正確に2つの要素があります。1つ目はオブジェクトのキーで、2つ目はそのキーに対応する値です。キーは &lt;code&gt;Object.keys&lt;/code&gt; 関数を介してオブジェクトから抽出されます。つまり、キーはオブジェクトに直接存在する列挙可能なキーのみであり、プロトタイプチェーンを介して継承されたキーではありません。</target>
        </trans-unit>
        <trans-unit id="4f6fdfa42f667cfba7439d1f21478f14b5582463" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partition&lt;/code&gt; outputs an array with two Observables that partition the values from the source Observable through the given &lt;code&gt;predicate&lt;/code&gt; function. The first Observable in that array emits source values for which the predicate argument returns true. The second Observable emits source values for which the predicate returns false. The first behaves like &lt;a href=&quot;../../operators/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and the second behaves like &lt;a href=&quot;../../operators/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; with the predicate negated.</source>
          <target state="translated">&lt;code&gt;partition&lt;/code&gt; は、指定された &lt;code&gt;predicate&lt;/code&gt; 関数を介してソースObservableからの値を分割する2つのObservableを含む配列を出力します。その配列の最初のObservableは、述語引数がtrueを返すソース値を出力します。2番目のObservableは、述語がfalseを返すソース値を出力します。以下のような第一の振る舞い&lt;a href=&quot;../../operators/filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;など第振る舞う&lt;a href=&quot;../../operators/filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;否定述語を持ちます。</target>
        </trans-unit>
        <trans-unit id="29b0a69077ab704f04ffa917a9190d5c068cb61d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partition&lt;/code&gt; outputs an array with two Observables that partition the values from the source Observable through the given &lt;code&gt;predicate&lt;/code&gt; function. The first Observable in that array emits source values for which the predicate argument returns true. The second Observable emits source values for which the predicate returns false. The first behaves like &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and the second behaves like &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; with the predicate negated.</source>
          <target state="translated">&lt;code&gt;partition&lt;/code&gt; は、指定された &lt;code&gt;predicate&lt;/code&gt; 関数を介してソースObservableからの値を分割する2つのObservableを含む配列を出力します。その配列の最初のObservableは、述語引数がtrueを返すソース値を出力します。2番目のObservableは、述語がfalseを返すソース値を出力します。以下のような第一の振る舞い&lt;a href=&quot;filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;など第振る舞う&lt;a href=&quot;filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;否定述語を持ちます。</target>
        </trans-unit>
        <trans-unit id="d757360aa9c33465dd08a4b49ea5c09adbe8789e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;queue&lt;/code&gt; scheduler, when used with delay, behaves the same as &lt;a href=&quot;asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;queue&lt;/code&gt; スケジューラを遅延と共に使用すると、&lt;a href=&quot;asyncscheduler&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt;スケジューラと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="17fdff06ac58fc951a7149d674b80a48d8ad8290" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; operator emits a range of sequential integers, in order, where you select the &lt;code&gt;start&lt;/code&gt; of the range and its &lt;code&gt;length&lt;/code&gt;. By default, uses no &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; and just delivers the notifications synchronously, but may use an optional &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to regulate those deliveries.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 演算子は、連続する整数の範囲を順番に出力します。ここで、範囲の &lt;code&gt;start&lt;/code&gt; とその &lt;code&gt;length&lt;/code&gt; を選択します。デフォルトでは、&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;を使用せず、通知を同期的に配信しますが、オプションの&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;を使用してこれらの配信を規制する場合があります。</target>
        </trans-unit>
        <trans-unit id="2e22b100da74aa12e2c1daa7b8100c2dbf04c3dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refCount&lt;/code&gt; makes the multicasted Observable automatically start executing when the first subscriber arrives, and stop executing when the last subscriber leaves.</source>
          <target state="translated">&lt;code&gt;refCount&lt;/code&gt; は、最初のサブスクライバーが到着したときにマルチキャストObservableの実行を自動的に開始し、最後のサブスクライバーが終了したときに実行を停止します。</target>
        </trans-unit>
        <trans-unit id="7dbccc612f4b41c939a27316ce2aa6e8a76a4022" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sampleTime&lt;/code&gt; periodically looks at the source Observable and emits whichever value it has most recently emitted since the previous sampling, unless the source has not emitted anything since the previous sampling. The sampling happens periodically in time every &lt;code&gt;period&lt;/code&gt; milliseconds (or the time unit defined by the optional &lt;code&gt;scheduler&lt;/code&gt; argument). The sampling starts as soon as the output Observable is subscribed.</source>
          <target state="translated">&lt;code&gt;sampleTime&lt;/code&gt; は定期的にソースObservableを調べ、前回のサンプリング以降にソースが何も出力していない場合を除き、前回のサンプリング以降に最後に出力された値を出力します。サンプリングは、時間に定期的に発生したすべての &lt;code&gt;period&lt;/code&gt; ミリ秒（またはオプションで定義された時間単位 &lt;code&gt;scheduler&lt;/code&gt; 引数）。出力Observableがサブスクライブされるとすぐに、サンプリングが開始されます。</target>
        </trans-unit>
        <trans-unit id="d5980710dadf7c9ae58853275ba85eaf3881bd1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sequenceEqual&lt;/code&gt; subscribes to two observables and buffers incoming values from each observable. Whenever either observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom up; If any value pair doesn't match, the returned observable will emit &lt;code&gt;false&lt;/code&gt; and complete. If one of the observables completes, the operator will wait for the other observable to complete; If the other observable emits before completing, the returned observable will emit &lt;code&gt;false&lt;/code&gt; and complete. If one observable never completes or emits after the other complets, the returned observable will never complete.</source>
          <target state="translated">&lt;code&gt;sequenceEqual&lt;/code&gt; は2つのオブザーバブルをサブスクライブし、各オブザーバブルからの受信値をバッファーします。どちらかのオブザーバブルが値を出力するたびに、値がバッファーに入れられ、バッファーがシフトされてボトムアップで比較されます。値のペアが一致しない場合、返されたオブザーバブルは &lt;code&gt;false&lt;/code&gt; を発行して完了します。オブザーバブルの1つが完了すると、オペレーターは他のオブザーバブルが完了するのを待ちます。他のオブザーバブルが完了する前に発行する場合、返されたオブザーバブルは &lt;code&gt;false&lt;/code&gt; を発行して完了します。 1つのオブザーバブルが他の完了後に完了または発行しない場合、返されたオブザーバブルは決して完了しません。</target>
        </trans-unit>
        <trans-unit id="4f58d2f8563d7e3159c6ebb8ebafb1de8e6d7489" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipLast&lt;/code&gt; returns an Observable that accumulates a queue with a length enough to store the first &lt;code&gt;count&lt;/code&gt; values. As more values are received, values are taken from the front of the queue and produced on the result sequence. This causes values to be delayed.</source>
          <target state="translated">&lt;code&gt;skipLast&lt;/code&gt; は、最初の &lt;code&gt;count&lt;/code&gt; 値を格納するのに十分な長さのキューを蓄積するObservableを返します。さらに多くの値が受信されると、値はキューの先頭から取得され、結果シーケンスで生成されます。これにより、値が遅延します。</target>
        </trans-unit>
        <trans-unit id="4dfa14c602b33dade952c18426ddaa9fa684801b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;source&lt;/code&gt;: the source Observable instance itself.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; ：ソースのObservableインスタンス自体。</target>
        </trans-unit>
        <trans-unit id="1b4b0818cfe231af3c058ff8b49a57db0d1c71e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribe&lt;/code&gt; is not a regular operator, but a method that calls Observable's internal &lt;code&gt;subscribe&lt;/code&gt; function. It might be for example a function that you passed to Observable's constructor, but most of the time it is a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means that calling &lt;code&gt;subscribe&lt;/code&gt; is actually the moment when Observable starts its work, not when it is created, as it is often the thought.</source>
          <target state="translated">&lt;code&gt;subscribe&lt;/code&gt; は通常の演算子ではなく、Observableの内部の &lt;code&gt;subscribe&lt;/code&gt; 関数を呼び出すメソッドです。たとえば、Observableのコンストラクターに渡した関数の場合がありますが、ほとんどの場合、Observableによって何が出力されるか、いつ出力されるかを定義するライブラリー実装です。つまり、 &lt;code&gt;subscribe&lt;/code&gt; 呼び出しは、実際にはObservableが作業を開始した瞬間であり、頻繁に考えられるため、作成時ではありません。</target>
        </trans-unit>
        <trans-unit id="7b11a8ddb4b29050c92924f7c707c9f383b4539d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; -&amp;gt; &lt;code&gt;switchAll&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; -&amp;gt; &lt;code&gt;switchAll&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42f30fe54a88e73cf07d5e7dde80265a6018d9c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switchAll&lt;/code&gt; subscribes to a source that is an observable of observables, also known as a &quot;higher-order observable&quot; (or &lt;code&gt;Observable&amp;lt;Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;). It subscribes to the most recently provided &quot;inner observable&quot; emitted by the source, unsubscribing from any previously subscribed to inner observable, such that only the most recent inner observable may be subscribed to at any point in time. The resulting observable returned by &lt;code&gt;switchAll&lt;/code&gt; will only complete if the source observable completes, &lt;em&gt;and&lt;/em&gt; any currently subscribed to inner observable also has completed, if there are any.</source>
          <target state="translated">&lt;code&gt;switchAll&lt;/code&gt; は、「高次のオブザーバブル」（または &lt;code&gt;Observable&amp;lt;Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ）とも呼ばれるオブザーバブルのオブザーバブルであるソースにサブスクライブします。これは、ソースによって発行された最近提供された「内部オブザーバブル」をサブスクライブし、以前にサブスクライブした内部オブザーバブルからのサブスクライブを解除して、最新の内部オブザーバブルのみがいつでもサブスクライブできるようにします。返された観察可能な &lt;code&gt;switchAll&lt;/code&gt; は、ソース、観察に完了した場合にのみ完了します、&lt;em&gt;そして&lt;/em&gt;いずれかが存在する場合、現在の内側に観察に加入いずれかはまた、完了しました。</target>
        </trans-unit>
        <trans-unit id="69dd20bf2331adf056c62cc0c41f4a92f233c680" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take&lt;/code&gt; returns an Observable that emits only the first &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable. If the source emits fewer than &lt;code&gt;count&lt;/code&gt; values then all of its values are emitted. After that, it completes, regardless if the source completes.</source>
          <target state="translated">&lt;code&gt;take&lt;/code&gt; は、ソースObservableによって発行された最初の &lt;code&gt;count&lt;/code&gt; 値のみを発行するObservable を返します。ソースが &lt;code&gt;count&lt;/code&gt; 値よりも少ない値を放出する場合、そのすべての値が放出されます。その後、ソースが完了しているかどうかに関係なく、完了します。</target>
        </trans-unit>
        <trans-unit id="e0d3558cc44022c2e8684d41349bf690ef45ad6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLast&lt;/code&gt; returns an Observable that emits at most the last &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable. If the source emits fewer than &lt;code&gt;count&lt;/code&gt; values then all of its values are emitted. This operator must wait until the &lt;code&gt;complete&lt;/code&gt; notification emission from the source in order to emit the &lt;code&gt;next&lt;/code&gt; values on the output Observable, because otherwise it is impossible to know whether or not more values will be emitted on the source. For this reason, all values are emitted synchronously, followed by the complete notification.</source>
          <target state="translated">&lt;code&gt;takeLast&lt;/code&gt; は、ソースObservableによって発行された最大で最後の &lt;code&gt;count&lt;/code&gt; 値を発行するObservableを返します。ソースが &lt;code&gt;count&lt;/code&gt; 値よりも少ない値を放出する場合、そのすべての値が放出されます。このオペレーターは、出力Observableで &lt;code&gt;next&lt;/code&gt; 値を発行するために、ソースからの &lt;code&gt;complete&lt;/code&gt; 通知発行まで待機する必要があります。そうしないと、ソースでさらに値が発行されるかどうかを知ることができないためです。このため、すべての値が同期的に発行され、その後に完全な通知が送信されます。</target>
        </trans-unit>
        <trans-unit id="a41e94110409f4ba43cb9c3758b60c921ba32bbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeUntil&lt;/code&gt; subscribes and begins mirroring the source Observable. It also monitors a second Observable, &lt;code&gt;notifier&lt;/code&gt; that you provide. If the &lt;code&gt;notifier&lt;/code&gt; emits a value, the output Observable stops mirroring the source Observable and completes. If the &lt;code&gt;notifier&lt;/code&gt; doesn't emit any value and completes then &lt;code&gt;takeUntil&lt;/code&gt; will pass all values.</source>
          <target state="translated">&lt;code&gt;takeUntil&lt;/code&gt; がサブスクライブし、ソースObservableのミラーリングを開始します。また、指定した2番目のObservable &lt;code&gt;notifier&lt;/code&gt; も監視します。場合は &lt;code&gt;notifier&lt;/code&gt; 値を発し、出力観察可能な停止は、ソースが観察し、完了ミラーリング。場合は &lt;code&gt;notifier&lt;/code&gt; 任意の値と完了を放出しない、その後 &lt;code&gt;takeUntil&lt;/code&gt; は、すべての値を渡します。</target>
        </trans-unit>
        <trans-unit id="4a230ff2a0b2808f0225be3b8c769a658194b52c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeWhile&lt;/code&gt; subscribes and begins mirroring the source Observable. Each value emitted on the source is given to the &lt;code&gt;predicate&lt;/code&gt; function which returns a boolean, representing a condition to be satisfied by the source values. The output Observable emits the source values until such time as the &lt;code&gt;predicate&lt;/code&gt; returns false, at which point &lt;code&gt;takeWhile&lt;/code&gt; stops mirroring the source Observable and completes the output Observable.</source>
          <target state="translated">&lt;code&gt;takeWhile&lt;/code&gt; がサブスクライブし、ソースObservableのミラーリングを開始します。ソースで発行された各値は、ブール値を返す &lt;code&gt;predicate&lt;/code&gt; 関数に渡され、ソース値が満たすべき条件を表します。出力Observableは、 &lt;code&gt;predicate&lt;/code&gt; がfalseを返すまでソース値を出力します。この時点で、 &lt;code&gt;takeWhile&lt;/code&gt; はソースObservableのミラーリングを停止し、出力Observableを完了します。</target>
        </trans-unit>
        <trans-unit id="893d4d7f1c2faad041677d314bbceaa20ca07709" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throttle&lt;/code&gt; emits the source Observable values on the output Observable when its internal timer is disabled, and ignores source values when the timer is enabled. Initially, the timer is disabled. As soon as the first source value arrives, it is forwarded to the output Observable, and then the timer is enabled by calling the &lt;code&gt;durationSelector&lt;/code&gt; function with the source value, which returns the &quot;duration&quot; Observable. When the duration Observable emits a value or completes, the timer is disabled, and this process repeats for the next source value.</source>
          <target state="translated">&lt;code&gt;throttle&lt;/code&gt; は、内部タイマーが無効になっている場合は出力ObservableにソースのObservable値を出力し、タイマーが有効になっている場合はソースの値を無視します。最初、タイマーは無効になっています。最初のソース値が到着するとすぐに、それは出力Observableに転送されます。その後、タイマーは、「duration」Observableを返すソース値で &lt;code&gt;durationSelector&lt;/code&gt; 関数を呼び出すことによって有効になります。 Observableが値を出力するか完了すると、タイマーが無効になり、このプロセスが次のソース値に対して繰り返されます。</target>
        </trans-unit>
        <trans-unit id="ed9390044a64b750cabefbab7627d762696a0957" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throttleTime&lt;/code&gt; emits the source Observable values on the output Observable when its internal timer is disabled, and ignores source values when the timer is enabled. Initially, the timer is disabled. As soon as the first source value arrives, it is forwarded to the output Observable, and then the timer is enabled. After &lt;code&gt;duration&lt;/code&gt; milliseconds (or the time unit determined internally by the optional &lt;code&gt;scheduler&lt;/code&gt;) has passed, the timer is disabled, and this process repeats for the next source value. Optionally takes a &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; for managing timers.</source>
          <target state="translated">&lt;code&gt;throttleTime&lt;/code&gt; は、内部タイマーが無効になっている場合は出力ObservableにソースのObservable値を送信し、タイマーが有効になっている場合はソースの値を無視します。最初、タイマーは無効になっています。最初のソース値が到着するとすぐに、出力Observableに転送され、タイマーが有効になります。後の &lt;code&gt;duration&lt;/code&gt; （ミリ秒）（またはオプションによって内部的に決定される時間単位 &lt;code&gt;scheduler&lt;/code&gt; ）経過、タイマーは無効になり、次のソース値について、このプロセスを繰り返します。オプションで、タイマーを管理するために&lt;a href=&quot;../index/interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="837bf2907a5094046aef9c509d4b9c80692617d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments) when returned Observable will check if source stream emitted value or completed.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; は、2番目のパラメーターとしてスケジューラーも受け入れます。これは、返されるオブザーバブルが値を放出したか完了したかをチェックする瞬間をスケジュールするために使用されます。</target>
        </trans-unit>
        <trans-unit id="4a7dc88dd8ca560076bef8f42aecb45980ad1c4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; operator accepts as an argument either a number or a Date.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 演算子は、数値または日付のいずれかを引数として受け入れます。</target>
        </trans-unit>
        <trans-unit id="9434e63eff4482ecfbfd0ab90266a6145b5d0017" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeoutWith&lt;/code&gt; is a variation of &lt;code&gt;timeout&lt;/code&gt; operator. It behaves exactly the same, still accepting as a first argument either a number or a Date, which control - respectively - when values of source Observable should be emitted or when it should complete.</source>
          <target state="translated">&lt;code&gt;timeoutWith&lt;/code&gt; は、 &lt;code&gt;timeout&lt;/code&gt; 演算子のバリエーションです。まったく同じように動作しますが、最初の引数として数値または日付のいずれかを受け入れます。これらは、ソースObservableの値をいつ出力するか、いつ完了するかをそれぞれ制御します。</target>
        </trans-unit>
        <trans-unit id="4710700c6f8e512d7c421a3fa66ab6a55bd22c59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; returns an Observable that emits an infinite sequence of ascending integers, with a constant interval of time, &lt;code&gt;period&lt;/code&gt; of your choosing between those emissions. The first emission happens after the specified &lt;code&gt;dueTime&lt;/code&gt;. The initial delay may be a &lt;code&gt;Date&lt;/code&gt;. By default, this operator uses the &lt;a href=&quot;../const/asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to provide a notion of time, but you may pass any &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to it. If &lt;code&gt;period&lt;/code&gt; is not specified, the output Observable emits only one value, &lt;code&gt;0&lt;/code&gt;. Otherwise, it emits an infinite sequence.</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; は、一定の時間間隔で昇順の整数の無限シーケンスを放出するObservableを返します。これらの放出の間で選択した &lt;code&gt;period&lt;/code&gt; 。最初の放出は、指定された &lt;code&gt;dueTime&lt;/code&gt; の後に発生します。最初の遅延は &lt;code&gt;Date&lt;/code&gt; 場合があります。デフォルトでは、このオペレーターは&lt;a href=&quot;../const/asyncscheduler&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;を使用して時間の概念を提供しますが、任意の&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;を渡すことができます。 &lt;code&gt;period&lt;/code&gt; が指定されていない場合、出力Observableは1つの値 &lt;code&gt;0&lt;/code&gt; のみを出力します。それ以外の場合は、無限シーケンスが発生します。</target>
        </trans-unit>
        <trans-unit id="5d336ba47502080cf68f8a6221d7a484097c3e86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toArray&lt;/code&gt; will wait until the source Observable completes before emitting the array containing all emissions. When the source Observable errors no array will be emitted.</source>
          <target state="translated">&lt;code&gt;toArray&lt;/code&gt; は、ソースObservableが完了するまで待機してから、すべてのエミッションを含むアレイをエミットします。ソースのObservableエラーが発生した場合、配列は出力されません。</target>
        </trans-unit>
        <trans-unit id="882041f58c61297d3bc52474672369483f237e67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type-alias&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;type-alias&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c1be2711a1aca94a2a1d5e62e346824e0545d42d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type-alias&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;type-alias&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d345979c928da012a70daaf3ad24a52650157db4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using&lt;/code&gt; is a factory operator, which accepts two functions. First function returns a disposable resource. It can be an arbitrary object that implements &lt;code&gt;unsubscribe&lt;/code&gt; method. Second function will be injected with that object and should return an Observable. That Observable can use resource object during its execution. Both functions passed to &lt;code&gt;using&lt;/code&gt; will be called every time someone subscribes - neither an Observable nor resource object will be shared in any way between subscriptions.</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt; は、2つの関数を受け入れるファクトリオペレータです。最初の関数は使い捨てリソースを返します。 &lt;code&gt;unsubscribe&lt;/code&gt; メソッドを実装する任意のオブジェクトにすることができます。2番目の関数にはそのオブジェクトが注入され、Observableを返す必要があります。そのObservableは、実行中にリソースオブジェクトを使用できます。 &lt;code&gt;using&lt;/code&gt; に渡される両方の関数は、誰かがサブスクライブするたびに呼び出されます-Observableもリソースオブジェクトもサブスクリプション間で何らかの方法で共有されることはありません。</target>
        </trans-unit>
        <trans-unit id="61103ee33a8a3cb94239d307c3afbd3dc50159b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt;: the value from the source Observable.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; ：ソースObservableからの値。</target>
        </trans-unit>
        <trans-unit id="9bd5b9326ee02528186bb1b60e87af552140ef37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="31d672942033870f817236e058621cb34ad12098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;webSocket&lt;/code&gt; is a factory function that produces a &lt;code&gt;WebSocketSubject&lt;/code&gt;, which can be used to make WebSocket connection with an arbitrary endpoint. &lt;code&gt;webSocket&lt;/code&gt; accepts as an argument either a string with url of WebSocket endpoint, or an &lt;a href=&quot;websocketsubjectconfig&quot;&gt;&lt;code&gt;WebSocketSubjectConfig&lt;/code&gt;&lt;/a&gt; object for providing additional configuration, as well as Observers for tracking lifecycle of WebSocket connection.</source>
          <target state="translated">&lt;code&gt;webSocket&lt;/code&gt; は、任意のエンドポイントとのWebSocket接続を確立するために使用できる &lt;code&gt;WebSocketSubject&lt;/code&gt; を生成するファクトリ関数です。 &lt;code&gt;webSocket&lt;/code&gt; は、WebSocketエンドポイントのURLを持つ文字列、または追加の構成を提供するための&lt;a href=&quot;websocketsubjectconfig&quot;&gt; &lt;code&gt;WebSocketSubjectConfig&lt;/code&gt; &lt;/a&gt;オブジェクト、およびWebSocket接続のライフサイクルを追跡するためのオブザーバーを引数として受け入れます。</target>
        </trans-unit>
        <trans-unit id="42327b58fe89d4b9abe60f993e7061fb8c13cb90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;withLatestFrom&lt;/code&gt; combines each value from the source Observable (the instance) with the latest values from the other input Observables only when the source emits a value, optionally using a &lt;code&gt;project&lt;/code&gt; function to determine the value to be emitted on the output Observable. All input Observables must emit at least one value before the output Observable will emit a value.</source>
          <target state="translated">&lt;code&gt;withLatestFrom&lt;/code&gt; は、ソースObservable（インスタンス）の各値を、ソースが値を発行する場合にのみ他の入力Observableの最新の値と組み合わせ、オプションで &lt;code&gt;project&lt;/code&gt; 関数を使用して出力Observableで発行される値を決定します。すべての入力Observableは、出力Observableが値を出力する前に、少なくとも1つの値を出力する必要があります。</target>
        </trans-unit>
        <trans-unit id="1b728c16ebf18a54406f817875e31683e7bead01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt;: Equivalent to &lt;code&gt;Observable.empty()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; ： &lt;code&gt;Observable.empty()&lt;/code&gt; と同等</target>
        </trans-unit>
        <trans-unit id="9fc5c704c2f6cc2c0c5a80f700059819fe2e60c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt;: Equivalent to &lt;code&gt;empty()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; ： &lt;code&gt;empty()&lt;/code&gt; と同等</target>
        </trans-unit>
        <trans-unit id="611ae3064b4a8437c9d8a8987b8edf4d63b802fc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pull&lt;/em&gt; and &lt;em&gt;Push&lt;/em&gt; are two different protocols that describe how a data &lt;em&gt;Producer&lt;/em&gt; can communicate with a data &lt;em&gt;Consumer&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;プル&lt;/em&gt;と&lt;em&gt;プッシュ&lt;/em&gt;は、データ&lt;em&gt;プロデューサー&lt;/em&gt;がデータ&lt;em&gt;コンシューマー&lt;/em&gt;と通信する方法を記述する2つの異なるプロトコルです。</target>
        </trans-unit>
        <trans-unit id="b062cafef9329a689038f3f6bb0d6df3b1e17fc9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Scheduler has a (virtual) clock.&lt;/strong&gt; It provides a notion of &quot;time&quot; by a getter method &lt;code&gt;now()&lt;/code&gt; on the scheduler. Tasks being scheduled on a particular scheduler will adhere only to the time denoted by that clock.</source>
          <target state="translated">&lt;strong&gt;スケジューラーには（仮想）クロックがあります。&lt;/strong&gt;これは、スケジューラーのゲッターメソッド &lt;code&gt;now()&lt;/code&gt; によって「時間」の概念を提供します。特定のスケジューラーでスケジュールされているタスクは、そのクロックで示される時間のみに従います。</target>
        </trans-unit>
        <trans-unit id="074b016986830a891feacbe88dcea585792b6754" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Scheduler is a data structure.&lt;/strong&gt; It knows how to store and queue tasks based on priority or other criteria.</source>
          <target state="translated">&lt;strong&gt;スケジューラはデータ構造です。&lt;/strong&gt;優先度やその他の基準に基づいてタスクを保存してキューに入れる方法を知っています。</target>
        </trans-unit>
        <trans-unit id="d23e926a842ae9b7ec36083837a1300934aa0807" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Scheduler is an execution context.&lt;/strong&gt; It denotes where and when the task is executed (e.g. immediately, or in another callback mechanism such as setTimeout or process.nextTick, or the animation frame).</source>
          <target state="translated">&lt;strong&gt;スケジューラは実行コンテキストです。&lt;/strong&gt;これは、タスクが実行される場所と時間を示します（たとえば、即時、またはsetTimeoutやprocess.nextTickなどの別のコールバックメカニズム、またはアニメーションフレーム）。</target>
        </trans-unit>
        <trans-unit id="c2696dbc62b706589ef9271f2becbde4c0d86eb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Active:&lt;/strong&gt; decides when data is requested.</source>
          <target state="translated">&lt;strong&gt;アクティブ：&lt;/strong&gt;データが要求されるタイミングを決定します。</target>
        </trans-unit>
        <trans-unit id="40ad7c047bd1f3c45b24a8afae9c8e0660d7e1af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Active:&lt;/strong&gt; produces data at its own pace.</source>
          <target state="translated">&lt;strong&gt;アクティブ：&lt;/strong&gt;独自のペースでデータを生成します。</target>
        </trans-unit>
        <trans-unit id="84179ebccd8aeb96d5d2a2ad2a67b59c7a558188" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Creating&lt;/strong&gt; Observables</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;オブザーバブルを&lt;strong&gt;作成する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2cbf914fb3e5f78e9d854a8a21e5a8003fab511a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Creation Operators&lt;/strong&gt; are the other kind of operator, which can be called as standalone functions to create a new Observable. For example: &lt;code&gt;of(1, 2, 3)&lt;/code&gt; creates an observable that will emit 1, 2, and 3, one right after another. Creation operators will be discussed in more detail in a later section.</source>
          <target state="translated">&lt;strong&gt;作成演算子&lt;/strong&gt;は別の種類の演算子で、スタンドアロン関数として呼び出して新しいObservableを作成できます。例： &lt;code&gt;of(1, 2, 3)&lt;/code&gt; は、1、2、3を次々に放出するオブザーバブルを作成します。作成演算子については、後のセクションで詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="ca200ee9bac7753c1984e93beda095c8fbb8031e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DOM EventTarget&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DOM EventTarget&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e68420a4c7815b5f0c672698af4bf7843778d45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DOM HtmlCollection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DOM HtmlCollection&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8943c4167154d5069a0f8a5c2c3dd62af27cc3cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DOM NodeList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DOM NodeList&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a21f27d9b01b50a7b29f7fa2322b39771e0b7e35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disposing&lt;/strong&gt; Observables</source>
          <target state="translated">&lt;strong&gt;廃棄&lt;/strong&gt;観測を</target>
        </trans-unit>
        <trans-unit id="cb151d1e02f000a2e2e7a787d5b9cd87bf237000" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Every Subject is an Observable.&lt;/strong&gt; Given a Subject, you can &lt;code&gt;subscribe&lt;/code&gt; to it, providing an Observer, which will start receiving values normally. From the perspective of the Observer, it cannot tell whether the Observable execution is coming from a plain unicast Observable or a Subject.</source>
          <target state="translated">&lt;strong&gt;すべての対象は観察可能です。&lt;/strong&gt;サブジェクトを指定すると、 &lt;code&gt;subscribe&lt;/code&gt; して、通常どおり値の受信を開始するオブザーバーを提供できます。オブザーバーの観点から見ると、Observableの実行がプレーンユニキャストのObservableから発生しているか、Subjectから発生しているかはわかりません。</target>
        </trans-unit>
        <trans-unit id="5373b1d2caa00d50f019c34ecd9071bc9c038433" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Every Subject is an Observer.&lt;/strong&gt; It is an object with the methods &lt;code&gt;next(v)&lt;/code&gt;, &lt;code&gt;error(e)&lt;/code&gt;, and &lt;code&gt;complete()&lt;/code&gt;. To feed a new value to the Subject, just call &lt;code&gt;next(theValue)&lt;/code&gt;, and it will be multicasted to the Observers registered to listen to the Subject.</source>
          <target state="translated">&lt;strong&gt;すべての被験者はオブザーバーです。&lt;/strong&gt;これは、メソッド &lt;code&gt;next(v)&lt;/code&gt; 、 &lt;code&gt;error(e)&lt;/code&gt; 、および &lt;code&gt;complete()&lt;/code&gt; を持つオブジェクトです。サブジェクトに新しい値をフィードするには、 &lt;code&gt;next(theValue)&lt;/code&gt; を呼び出すだけで、サブジェクトをリッスンするように登録されたオブザーバーにマルチキャストされます。</target>
        </trans-unit>
        <trans-unit id="183af49f4d960a43e78387ddc6ee3ed6f8e3ccf0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example.&lt;/strong&gt; The following is an Observable that pushes the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; immediately (synchronously) when subscribed, and the value &lt;code&gt;4&lt;/code&gt; after one second has passed since the subscribe call, then completes:</source>
          <target state="translated">&lt;strong&gt;例。&lt;/strong&gt;以下は値プッシュ観察される &lt;code&gt;1&lt;/code&gt; 、 &lt;code&gt;2&lt;/code&gt; 、 &lt;code&gt;3&lt;/code&gt; 加入、および値ときに直ちに（同期） &lt;code&gt;4&lt;/code&gt; コールをサブスクライブから1秒後が経過した後に完了します。</target>
        </trans-unit>
        <trans-unit id="dc8b1db7d6c863328921dd393ba3c393b762f959" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Executing&lt;/strong&gt; the Observable</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;オブザーバブルの&lt;strong&gt;実行&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4048867ebc7d64b979ef3246ca49c44be92b16b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Instance operators may take a Scheduler as argument.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;インスタンスオペレータは、スケジューラを引数として使用できます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="96bab829a0c0f4399a5e75cee75d035f3056b17b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JQuery-style event target&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jQueryスタイルのイベントターゲット&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="27bbb9b4010ebcf793220387d26bf7f0eb25cef0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multiplexing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Multiplexing&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ed0d7836fa3fb4540d3c4bbd9ca9eb12e6e3e01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Using &lt;code&gt;rxjs&lt;/code&gt; or &lt;code&gt;rxjs/operators&lt;/code&gt; without making changes to your build process can result in larger bundles. See &lt;a href=&quot;pipeable-operators#known-issues&quot;&gt;Known Issues&lt;/a&gt; section below.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：ビルドプロセスを変更せずに &lt;code&gt;rxjs&lt;/code&gt; または &lt;code&gt;rxjs/operators&lt;/code&gt; を使用すると、バンドルが大きくなる可能性があります。以下の&lt;a href=&quot;pipeable-operators#known-issues&quot;&gt;既知の問題の&lt;/a&gt;セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="f105f3f8fa68751b4b8a425493ce2fc80d1fe5b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: You may have to subtract 1 millisecond from the time you want to progress because the alphanumeric marbles (representing an actual emitted value) &lt;em&gt;advance time 1 virtual frame&lt;/em&gt; themselves already, after they emit. This can be very unintuitive and frustrating, but for now it is indeed correct.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：英数字のマーブル（実際の放出値を表す）は、放出後、&lt;em&gt;仮想フレーム&lt;/em&gt;を&lt;em&gt;1つ前に進める&lt;/em&gt;ため、進行時間から1ミリ秒を引く必要がある場合があります。これは非常に直感的でイライラすることがありますが、今のところ、それは確かに正しいです。</target>
        </trans-unit>
        <trans-unit id="1b82b6885d2ca4a917dedb922318618f04d40411" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Node.js EventEmitter&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Node.js EventEmitter&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e6804a13811d1de6f399d6c72e02d791ca86aa0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observable.error &amp;gt; throwError()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Observable.error&amp;gt; throwError（）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8bd3c9bb800e7f0fb7e366cf1c7b3e082bddc190" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observable.if &amp;gt; iif()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Observable.if&amp;gt; iif（）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00391a5b16891388706b4319b8c7649c5c3df177" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observable:&lt;/strong&gt; represents the idea of an invokable collection of future values or events.</source>
          <target state="translated">&lt;strong&gt;観察可能：&lt;/strong&gt;将来の値またはイベントの呼び出し&lt;strong&gt;可能な&lt;/strong&gt;コレクションの概念を表します。</target>
        </trans-unit>
        <trans-unit id="0acdf1a2141240d22bc99dc78cf3713da2737dcd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observer:&lt;/strong&gt; is a collection of callbacks that knows how to listen to values delivered by the Observable.</source>
          <target state="translated">&lt;strong&gt;Observer：&lt;/strong&gt; Observableによって配信された値をリッスンする方法を知っているコールバックのコレクションです。</target>
        </trans-unit>
        <trans-unit id="af427c5f339addc519da7767cdb1e6f5c930d89d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Operators:&lt;/strong&gt; are pure functions that enable a functional programming style of dealing with collections with operations like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;concat&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;strong&gt;演算子：&lt;/strong&gt; &lt;code&gt;map&lt;/code&gt; 、 &lt;code&gt;filter&lt;/code&gt; 、 &lt;code&gt;concat&lt;/code&gt; 、 &lt;code&gt;reduce&lt;/code&gt; などの操作でコレクションを処理する関数型プログラミングスタイルを可能にする純粋な関数です。</target>
        </trans-unit>
        <trans-unit id="903114a5875a76c7e7e738db8ee5670ecaffeb9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passive:&lt;/strong&gt; produces data when requested.</source>
          <target state="translated">&lt;strong&gt;パッシブ：&lt;/strong&gt;要求されたときにデータを生成します。</target>
        </trans-unit>
        <trans-unit id="a9558477bc2631c7221403c490210bc959155791" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passive:&lt;/strong&gt; reacts to received data.</source>
          <target state="translated">&lt;strong&gt;パッシブ：&lt;/strong&gt;受信したデータに反応します。</target>
        </trans-unit>
        <trans-unit id="3f0517560b9f6522d3ec876a649641ec26e37bec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pipeable Operators&lt;/strong&gt; are the kind that can be piped to Observables using the syntax &lt;code&gt;observableInstance.pipe(operator())&lt;/code&gt;. These include, &lt;a href=&quot;../api/operators/filter&quot;&gt;&lt;code&gt;filter(...)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../api/operators/mergemap&quot;&gt;&lt;code&gt;mergeMap(...)&lt;/code&gt;&lt;/a&gt;. When called, they do not &lt;em&gt;change&lt;/em&gt; the existing Observable instance. Instead, they return a &lt;em&gt;new&lt;/em&gt; Observable, whose subscription logic is based on the first Observable.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;パイプ可能&lt;strong&gt;演算子&lt;/strong&gt;は、構文 &lt;code&gt;observableInstance.pipe(operator())&lt;/code&gt; を使用してObservableにパイプできる種類です。これらには、&lt;a href=&quot;../api/operators/filter&quot;&gt; &lt;code&gt;filter(...)&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../api/operators/mergemap&quot;&gt; &lt;code&gt;mergeMap(...)&lt;/code&gt; が含まれ&lt;/a&gt;ます。呼び出されても、既存のObservableインスタンスは&lt;em&gt;変更され&lt;/em&gt;ません。代わりに、サブスクリプションロジックが最初のObservableに基づいている&lt;em&gt;新しい&lt;/em&gt; Observable を返します。</target>
        </trans-unit>
        <trans-unit id="dfcbd70cd68821b77e692cfdf2ea4926f7734a21" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pull&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pull&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15f12ede62915f48b6ad83b8e92e23880f687ba9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Push&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Push&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a3a338d979540294175612757b03b13e50907fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Renamed Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;名前が変更された演算子&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1f679c158b945669b0b1bcd8dcbe4cf80ff3e13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Replacing synchronous error handling&lt;/strong&gt; The following example shows code that subscribes to an observable within a &lt;code&gt;try/catch&lt;/code&gt; block, in order to handle errors synchronously:</source>
          <target state="translated">&lt;strong&gt;同期エラー処理&lt;/strong&gt;の&lt;strong&gt;置き換え&lt;/strong&gt;次の例は、エラーを同期的に処理するために、 &lt;code&gt;try/catch&lt;/code&gt; ブロック内のオブザーバブルにサブスクライブするコードを示しています。</target>
        </trans-unit>
        <trans-unit id="657c2d83cff0ceff049ce2ce6e5ebce465c69192" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Schedulers:&lt;/strong&gt; are centralized dispatchers to control concurrency, allowing us to coordinate when computation happens on e.g. &lt;code&gt;setTimeout&lt;/code&gt; or &lt;code&gt;requestAnimationFrame&lt;/code&gt; or others.</source>
          <target state="translated">&lt;strong&gt;スケジューラー：&lt;/strong&gt;並行性を制御する集中ディスパッチャーであり、 &lt;code&gt;setTimeout&lt;/code&gt; や &lt;code&gt;requestAnimationFrame&lt;/code&gt; などで計算が発生したときに調整できます。</target>
        </trans-unit>
        <trans-unit id="230aa9b6906a94c5dd268a2a57b8df69be5e6259" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Static creation operators usually take a Scheduler as argument.&lt;/strong&gt; For instance, &lt;code&gt;from(array, scheduler)&lt;/code&gt; lets you specify the Scheduler to use when delivering each notification converted from the &lt;code&gt;array&lt;/code&gt;. It is usually the last argument to the operator. The following static creation operators take a Scheduler argument:</source>
          <target state="translated">&lt;strong&gt;静的作成演算子は通常、スケジューラを引数として取ります。&lt;/strong&gt;たとえば、 &lt;code&gt;from(array, scheduler)&lt;/code&gt; では、 &lt;code&gt;array&lt;/code&gt; から変換された各通知を配信するときに使用するスケジューラを指定できます。これは通常、演算子の最後の引数です。次の静的作成演算子は、Scheduler引数を取ります。</target>
        </trans-unit>
        <trans-unit id="4bc5912a19fdcb523a962180f2331e7ae3926205" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subject:&lt;/strong&gt; is the equivalent to an EventEmitter, and the only way of multicasting a value or event to multiple Observers.</source>
          <target state="translated">&lt;strong&gt;Subject：&lt;/strong&gt;はEventEmitterと同等であり、値またはイベントを複数のオブザーバーにマルチキャストする唯一の方法です。</target>
        </trans-unit>
        <trans-unit id="428168244c9f05e1c6da25e04311afe32902b6a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subscribing&lt;/strong&gt; to Observables</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;Observablesの&lt;strong&gt;購読&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c45e0a77d0dd75edd547e7bfbd17a13e9e46d91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subscription:&lt;/strong&gt; represents the execution of an Observable, is primarily useful for cancelling the execution.</source>
          <target state="translated">&lt;strong&gt;サブスクリプション：&lt;/strong&gt; Observableの実行を表し、主に実行のキャンセルに役立ちます。</target>
        </trans-unit>
        <trans-unit id="e7223a3f6b3dd5ad4fd2f32718adaef606ac7aca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TS 2.3 and under&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TS 2.3以下&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7646ff7a27645ddbc2bb23a98cb8442f76858fe1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TS 2.4 and up&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TS 2.4以降&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8497eed474718bc72853151f790b74187f2c7fd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The connection to the multicasted Observable is unsubscribed&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;マルチキャストされたObservableへの接続は登録解除されています&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ed94109423adc7864e5311e1fc56286c608c0c06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The multicasted Observable is connected&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;マルチキャストされたObservableが接続されています&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="90bf18b1ad6ea31a02c0712a451768817863ff9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TypeScript user-defined prototype operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TypeScriptユーザー定義プロトタイプ演算子&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0fd6589a319070a0e7bfc47072abae83661199ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;observeOn&lt;/code&gt; to schedule in what context will notifications be delivered.&lt;/strong&gt; As we saw in the examples above, instance operator &lt;code&gt;observeOn(scheduler)&lt;/code&gt; introduces a mediator Observer between the source Observable and the destination Observer, where the mediator schedules calls to the destination Observer using your given &lt;code&gt;scheduler&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;observeOn&lt;/code&gt; を使用して、通知が配信されるコンテキストをスケジュールします。&lt;/strong&gt;上記の例で見たように、インスタンスオペレーター &lt;code&gt;observeOn(scheduler)&lt;/code&gt; は、ソースObservableと宛先Observerの間にメディエーターObserverを導入します。メディエーターは、指定 &lt;code&gt;scheduler&lt;/code&gt; を使用して宛先Observerへの呼び出しをスケジュールします。</target>
        </trans-unit>
        <trans-unit id="fc501f48fc8f14891b059480a7053bc23bc4bcf9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;subscribeOn&lt;/code&gt; to schedule in what context will the &lt;code&gt;subscribe()&lt;/code&gt; call happen.&lt;/strong&gt; By default, a &lt;code&gt;subscribe()&lt;/code&gt; call on an Observable will happen synchronously and immediately. However, you may delay or schedule the actual subscription to happen on a given Scheduler, using the instance operator &lt;code&gt;subscribeOn(scheduler)&lt;/code&gt;, where &lt;code&gt;scheduler&lt;/code&gt; is an argument you provide.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;subscribeOn&lt;/code&gt; を使用して、 &lt;code&gt;subscribe()&lt;/code&gt; コールが発生するコンテキストをスケジュールします。&lt;/strong&gt;デフォルトでは、Observableの &lt;code&gt;subscribe()&lt;/code&gt; 呼び出しは同期してすぐに実行されます。ただし、遅延またはインスタンス演算子使用して、与えられたスケジューラ上で発生する実際のサブスクリプションをスケジュールすることができる &lt;code&gt;subscribeOn(scheduler)&lt;/code&gt; 、 &lt;code&gt;scheduler&lt;/code&gt; あなたが提供する引数です。</target>
        </trans-unit>
        <trans-unit id="f02212ebedff47f3c2d37899d71ae6efdb50385f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt; Parts of the fetch API are still experimental. &lt;code&gt;AbortController&lt;/code&gt; is required for this implementation to work and use cancellation appropriately.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;フェッチAPIの一部はまだ実験段階です。この実装が機能し、キャンセルを適切に使用するには、 &lt;code&gt;AbortController&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="1891fe62d5c1ffcfee45323d0789bc157a1b7e2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If the source Observable emits Observables quickly and endlessly, and the inner Observables it emits generally complete slower than the source emits, you can run into memory issues as the incoming Observables collect in an unbounded buffer.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;ソースObservableがObservableを迅速かつ無限に放出し、ソースObservableが放出する内部Observableがソースの放出よりも遅く完了する場合、着信Observableが無制限のバッファーに収集されるため、メモリの問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="7cb773da4994f4f259ae2f115254f536579e71cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if source values arrive endlessly and faster than their corresponding inner Observables can complete, it will result in memory issues as inner Observables amass in an unbounded buffer waiting for their turn to be subscribed to.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;ソース値が対応する内部Observableが完了するよりも速く無限に到着すると、内部Observableがサブスクライブされるのを待機している無制限のバッファーに蓄積されるため、メモリの問題が発生します。</target>
        </trans-unit>
        <trans-unit id="16407a2f9afdb7f2ce60cdb22355e0487e064350" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What are creation operators?&lt;/strong&gt; Distinct from pipeable operators, creation operators are functions that can be used to create an Observable with some common predefined behavior or by joining other Observables.</source>
          <target state="translated">&lt;strong&gt;作成演算子とは何ですか？&lt;/strong&gt;パイプ可能演算子とは異なり、作成演算子は、いくつかの一般的な事前定義された動作を使用してObservableを作成するため、または他のObservableを結合することによって使用できる関数です。</target>
        </trans-unit>
        <trans-unit id="a15df290a491ec301883de6ed75f191f29efc83f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is Pull?&lt;/strong&gt; In Pull systems, the Consumer determines when it receives data from the data Producer. The Producer itself is unaware of when the data will be delivered to the Consumer.</source>
          <target state="translated">&lt;strong&gt;プルとは？&lt;/strong&gt;プルシステムでは、コンシューマーはデータプロデューサーからデータを受信するタイミングを決定します。プロデューサー自体は、データがコンシューマーに配信されるタイミングを認識していません。</target>
        </trans-unit>
        <trans-unit id="712dfa59ac3cdd93a3d866043138aa70bec8cb8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is Push?&lt;/strong&gt; In Push systems, the Producer determines when to send data to the Consumer. The Consumer is unaware of when it will receive that data.</source>
          <target state="translated">&lt;strong&gt;プッシュとは？&lt;/strong&gt;プッシュシステムでは、プロデューサーがコンシューマーにデータを送信するタイミングを決定します。消費者は、いつそのデータを受信するかを認識していません。</target>
        </trans-unit>
        <trans-unit id="6e4e1cb26de7af121d4d8d54dca402173b733a70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Scheduler?&lt;/strong&gt; A scheduler controls when a subscription starts and when notifications are delivered. It consists of three components.</source>
          <target state="translated">&lt;strong&gt;スケジューラとは？&lt;/strong&gt;スケジューラは、サブスクリプションの開始時と通知の配信時を制御します。3つのコンポーネントで構成されています。</target>
        </trans-unit>
        <trans-unit id="2d2a4d77a523e5f22052a30bccc030255bae1a0d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Subject?&lt;/strong&gt; An RxJS Subject is a special type of Observable that allows values to be multicasted to many Observers. While plain Observables are unicast (each subscribed Observer owns an independent execution of the Observable), Subjects are multicast.</source>
          <target state="translated">&lt;strong&gt;主題とは何ですか？&lt;/strong&gt;RxJSサブジェクトは、値を多数のオブザーバーにマルチキャストできるようにする特別なタイプのObservableです。プレーンなObservableはユニキャストですが（サブスクライブされた各ObserverはObservableの独立した実行を所有しています）、Subjectはマルチキャストです。</target>
        </trans-unit>
        <trans-unit id="10d4a8daeb2d6cb88fe9a685eea5d8b32f44696b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Subscription?&lt;/strong&gt; A Subscription is an object that represents a disposable resource, usually the execution of an Observable. A Subscription has one important method, &lt;code&gt;unsubscribe&lt;/code&gt;, that takes no argument and just disposes the resource held by the subscription. In previous versions of RxJS, Subscription was called &quot;Disposable&quot;.</source>
          <target state="translated">&lt;strong&gt;サブスクリプションとは何ですか？&lt;/strong&gt;サブスクリプションは、使い捨てのリソース、通常はObservableの実行を表すオブジェクトです。サブスクリプションには1つの重要なメソッドである &lt;code&gt;unsubscribe&lt;/code&gt; があり、引数をとらず、サブスクリプションによって保持されているリソースを破棄するだけです。RxJSの以前のバージョンでは、サブスクリプションは「使い捨て」と呼ばれていました。</target>
        </trans-unit>
        <trans-unit id="3c08f2aa1b9f97e99a2ace9631fba523ce2fd5c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;closeObserver&lt;/strong&gt; allows us to set a custom error when an error raise up.</source>
          <target state="translated">&lt;strong&gt;closeObserverを&lt;/strong&gt;使用すると、エラーが発生したときにカスタムエラーを設定できます。</target>
        </trans-unit>
        <trans-unit id="c9617eb95fe095e9c89063af41768f15e1a35cf1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;combineLatest()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;combineLatest()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d99ba7b6ef9e2babf8c03e5482a1865fc0add46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;combineLatest&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;combineLatest&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cb88dd148fb5f8fde2a56a840fd602c4b4bdd87e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;concat&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;concat&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="93b6911eb6bffc04528624a72bd00d9ce4d69501" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;concatMap()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;concatMap()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee79ceed9ae5ea9c01c077904fc5aeebea2049a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;concatMapTo()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;concatMapTo()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dc0108ff4be926ab3398bb1da3b2169513a5b19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;deserializer&lt;/strong&gt;, the default for this property is &lt;code&gt;JSON.parse&lt;/code&gt; but since there are just two options for incomming data, either be text or binarydata. We can apply a custom deserialization strategy or just simply skip the default behaviour.</source>
          <target state="translated">&lt;strong&gt;デシリアライザ&lt;/strong&gt;、このプロパティのデフォルトは &lt;code&gt;JSON.parse&lt;/code&gt; しかし、データをincommingのためのちょうど2つのオプションがありますので、テキストやbinarydataをすることのいずれか。カスタムの逆シリアル化戦略を適用することも、単にデフォルトの動作をスキップすることもできます。</target>
        </trans-unit>
        <trans-unit id="88b721e1327ee5ca846cce316ea3831e2a114c03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;exhaustMap()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;exhaustMap()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e64aa89b14e9f0fb930d801d1474b5a069471528" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;first()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;first()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42e9b71b0c9f6abe41f5d21d7b89bce1bc5a1757" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;forkJoin()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;forkJoin()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="02f22409ce12dc5cd696a8b7770bb37378c4161b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fromEvent()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;fromEvent()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9e7f297cde0f3e57a576c156803f456f4db3232" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;last()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;last()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2f99c5d66faa95e388d7a91e5e6a1a931e1e9e04" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;merge&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;merge&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be2ed258895844046061c6a16c4d7666a9c67e9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mergeMap()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;mergeMap()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="30a98a7c67095b1f9efa43fb3cf29683f8e7d437" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mergeMapTo()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;mergeMapTo()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="df9761fa7db55227d364bae7412590b4a16c3a00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;openObserver&lt;/strong&gt;, Let's say we need to make some kind of init task before sending/receiving msgs to the webSocket or sending notification that the connection was successful, this is when openObserver is usefull for.</source>
          <target state="translated">&lt;strong&gt;openObserver&lt;/strong&gt;、&lt;strong&gt;webSocket&lt;/strong&gt;にメッセージを送受信する前、または接続が成功したという通知を送信する前に、何らかのinitタスクを実行する必要があるとしましょう。これは、openObserverが役立つ場合です。</target>
        </trans-unit>
        <trans-unit id="8538babf0df6e2488807caf11c32fb6442ea9a8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;path-mapping&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;path-mapping&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7a7c1c0408320eae8f251ee13416ba7fa8e9813" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;race&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;race&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8033164aedc67a47d9b741674b893e5df574ec71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs/ajax&lt;/strong&gt;: The Rx ajax implementation</source>
          <target state="translated">&lt;strong&gt;rxjs / ajax&lt;/strong&gt;：Rx ajax実装</target>
        </trans-unit>
        <trans-unit id="ee249de4ff74839d7d59160e6fa42747ac6d1f64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs/operators&lt;/strong&gt;: All pipeable operators:</source>
          <target state="translated">&lt;strong&gt;rxjs / operators&lt;/strong&gt;：すべてのパイプ可能な演算子：</target>
        </trans-unit>
        <trans-unit id="b77ea218deb17c3d483e367c8b5e926f7e94fd62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs/testing&lt;/strong&gt;: The testing utilities</source>
          <target state="translated">&lt;strong&gt;rxjs / testing&lt;/strong&gt;：テストユーティリティ</target>
        </trans-unit>
        <trans-unit id="6f08d6ab32819c43824e650817b5cea7ae780d4d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs/webSocket:&lt;/strong&gt; The web socket subject implementation</source>
          <target state="translated">&lt;strong&gt;rxjs / webSocket：&lt;/strong&gt; Webソケットのサブジェクトの実装</target>
        </trans-unit>
        <trans-unit id="5b5978c6ff6549ebfd8d09317422f89f556f26bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs:&lt;/strong&gt; Creation methods, types, schedulers and utilities</source>
          <target state="translated">&lt;strong&gt;rxjs：&lt;/strong&gt;作成方法、タイプ、スケジューラー、およびユーティリティー</target>
        </trans-unit>
        <trans-unit id="5a96c3978998d062f56f520209675d5ca2e3200e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;serializer&lt;/strong&gt; allows us tom apply custom serialization strategy but for the outgoing messages</source>
          <target state="translated">&lt;strong&gt;シリアライザは、&lt;/strong&gt;私たちのトムは、カスタムのシリアル化戦略を適用することができますが、送信メッセージの</target>
        </trans-unit>
        <trans-unit id="25d76e530dc6bddd9b5a2cbb5c4fc4417032db68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;switchMap()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;switchMap()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e09ba85c76d585a9df1b1dcd098e925200d3fff8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;switchMapTo()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;switchMapTo()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2d721ba21cdb4b4325c8bcbfaa215f9c4db0440" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;webpack.config.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;webpack.config.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37c0839b8cdacbbaae239d4a9bad18c24e1f7e5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;zip()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;zip()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37b86f110b2db8e46463dee1f96085d7c7d8c7ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;zip&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;zip&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d9cbda34fcb1655f6eac22b4d8800b2f74463f70" translate="yes" xml:space="preserve">
          <source>@example</source>
          <target state="translated">@example</target>
        </trans-unit>
        <trans-unit id="7752616a2a7d9f9dad2611e86f931cdee6d7370c" translate="yes" xml:space="preserve">
          <source>@example Converts a javascript object to an Observable</source>
          <target state="translated">例)javascriptオブジェクトをObservableに変換します。</target>
        </trans-unit>
        <trans-unit id="69554a23de0b45d4239ec533bf92361e87963547" translate="yes" xml:space="preserve">
          <source>@param {Object} obj The object to inspect and turn into an Observable sequence. @param {Scheduler} [scheduler] An optional IScheduler to schedule when resulting Observable will emit values. @returns {(Observable&amp;lt;Array&amp;lt;string|T&amp;gt;&amp;gt;)} An observable sequence of [key, value] pairs from the object.</source>
          <target state="translated">@param {Object} obj検査してObservableシーケンスに変換するオブジェクト。@param {Scheduler} [scheduler]結果のObservableが値を出力するタイミングをスケジュールするオプションのIScheduler。@returns {（Observable &amp;lt;Array &amp;lt;string | T &amp;gt;&amp;gt;）}オブジェクトからの[key、value]ペアの監視可能なシーケンス。</target>
        </trans-unit>
        <trans-unit id="aecffaccb00ca124ca2411785bcddae1a5614c86" translate="yes" xml:space="preserve">
          <source>@param {S} initialState Initial state. @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false). @param {function (state: S): S} iterate Iteration step function. @param {function (state: S): T} [resultSelector] Selector function for results produced in the sequence. @param {Scheduler} [scheduler] A &lt;a href=&quot;../class/scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; on which to run the generator loop. If not provided, defaults to emitting immediately. @return {Observable</source>
          <target state="translated">@param {S} initialState初期状態。@param {関数（状態：S）：ブール}条件生成を終了するための条件（falseを返すと）。@param {関数（状態：S）：S}反復ステップ関数を繰り返します。@param {関数（状態：S）：T} [resultSelector]シーケンスで生成された結果のセレクター関数。@param {Scheduler} [scheduler] ジェネレータループを実行する&lt;a href=&quot;../class/scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt;。指定しない場合、デフォルトですぐに放出されます。@return {監視可能</target>
        </trans-unit>
        <trans-unit id="a86b8f8b9392a35784c87db9c3a38fa906373730" translate="yes" xml:space="preserve">
          <source>@see &lt;a href=&quot;from&quot;&gt;&lt;code&gt;from&lt;/code&gt;&lt;/a&gt; @see &lt;a href=&quot;../class/observable#create&quot;&gt;&lt;code&gt;create&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">@see &lt;a href=&quot;../class/observable#create&quot;&gt; &lt;code&gt;create&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;from&quot;&gt; &lt;code&gt;from&lt;/code&gt; &lt;/a&gt; @see</target>
        </trans-unit>
        <trans-unit id="df198b98a019b86cf56dbdbe15e6f3192da5358f" translate="yes" xml:space="preserve">
          <source>A &quot;multicasted Observable&quot; passes notifications through a Subject which may have many subscribers, whereas a plain &quot;unicast Observable&quot; only sends notifications to a single Observer.</source>
          <target state="translated">マルチキャストObservable」は、多くのサブスクライバを持つサブジェクトに通知を渡しますが、プレーンな「ユニキャストObservable」は単一のオブザーバにのみ通知を送信します。</target>
        </trans-unit>
        <trans-unit id="92b8313735e022c08e283746820b60689e84e023" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; represents values belonging to the same group represented by a common key. The common key is available as the key field of a &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">A &lt;a href=&quot;../index/class/groupedobservable&quot;&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; は&lt;/a&gt;共通鍵で表される同一のグループに属する値を表します。共通キーは、&lt;a href=&quot;../index/class/groupedobservable&quot;&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; &lt;/a&gt;インスタンスのキーフィールドとして使用できます。</target>
        </trans-unit>
        <trans-unit id="d526b50bab2cb764a769f15056314286d65451b5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; on which to run the generator loop. If not provided, defaults to emit immediately.</source>
          <target state="translated">ジェネレータループを実行する&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;。指定しない場合、デフォルトですぐに発行されます。</target>
        </trans-unit>
        <trans-unit id="b4ec8a1e9cab67d3465e14c22c1480c899232202" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for scheduling the emission of the complete notification.</source>
          <target state="translated">完全な通知の発行をスケジュールするために使用する&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3502d4cd60420575855768df193717ce7af823c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for scheduling the emission of the error notification.</source>
          <target state="translated">エラー通知の発行をスケジュールするために使用する&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bfb45378875cd0dbee1204d3f1675469e0de052d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for scheduling the emissions of the notifications.</source>
          <target state="translated">通知の発行をスケジュールするために使用する&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e45bc63b80ef36d258103d1502ec98c1bc283c44" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ReplaySubject&lt;/code&gt; is similar to a &lt;code&gt;BehaviorSubject&lt;/code&gt; in that it can send old values to new subscribers, but it can also &lt;em&gt;record&lt;/em&gt; a part of the Observable execution.</source>
          <target state="translated">A &lt;code&gt;ReplaySubject&lt;/code&gt; はに似て &lt;code&gt;BehaviorSubject&lt;/code&gt; それは新しい加入者に古い値を送ることができるという点で、それはまたできる&lt;em&gt;録音&lt;/em&gt;観察可能な実行の一部を。</target>
        </trans-unit>
        <trans-unit id="9266d79d79e506e9015638a1e7fa25d05eed2d9a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ReplaySubject&lt;/code&gt; records multiple values from the Observable execution and replays them to new subscribers.</source>
          <target state="translated">A &lt;code&gt;ReplaySubject&lt;/code&gt; が観察可能な実行から複数の値を記録し、新規加入者にそれらを再生します。</target>
        </trans-unit>
        <trans-unit id="b627fb490427e84b2fb30afc924259f8c9213ca3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;subscribe&lt;/code&gt; call is simply a way to start an &quot;Observable execution&quot; and deliver values or events to an Observer of that execution.</source>
          <target state="translated">&lt;code&gt;subscribe&lt;/code&gt; 呼び出しは単に「観察可能な実行」を起動し、その実行のオブザーバーに値やイベントを配信する方法です。</target>
        </trans-unit>
        <trans-unit id="efd0bc3590ad0e5cd305fc066f8858e79d9f944e" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;Function&lt;/strong&gt; is a lazily evaluated computation that synchronously returns a single value on invocation.</source>
          <target state="translated">&lt;strong&gt;機能&lt;/strong&gt;同期呼び出しで単一の値を返す遅延評価の計算です。</target>
        </trans-unit>
        <trans-unit id="3f042dfe09e5b8f66ba0f9c0ba654f1fd5be3a96" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;Promise&lt;/strong&gt; is a computation that may (or may not) eventually return a single value.</source>
          <target state="translated">A &lt;strong&gt;プロミスは&lt;/strong&gt;、最終的に単一の値を返すことができる（又はない場合もある）の計算です。</target>
        </trans-unit>
        <trans-unit id="65e785fe4afd3cb8b2772ccac68387742bbdc4b9" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;generator&lt;/strong&gt; is a lazily evaluated computation that synchronously returns zero to (potentially) infinite values on iteration.</source>
          <target state="translated">&lt;strong&gt;発電機は、&lt;/strong&gt;同期戻り、反復に（潜在的に）無限の値にゼロこと遅延評価の計算です。</target>
        </trans-unit>
        <trans-unit id="787a4416e61a830e0934a34a8528eaf6a5d6f8a0" translate="yes" xml:space="preserve">
          <source>A Pipeable Operator is a function that takes an Observable as its input and returns another Observable. It is a pure operation: the previous Observable stays unmodified.</source>
          <target state="translated">パイプ可能な演算子は、Observableを入力として受け取り、別のObservableを返す関数です。これは純粋な操作です。</target>
        </trans-unit>
        <trans-unit id="ee8f5678bb76afe5dd5b02ced66fb1b0d0044586" translate="yes" xml:space="preserve">
          <source>A Pipeable Operator is essentially a pure function which takes one Observable as input and generates another Observable as output. Subscribing to the output Observable will also subscribe to the input Observable.</source>
          <target state="translated">パイプ可能な演算子は、基本的には純粋な関数で、1つのObservableを入力として受け取り、別のObservableを出力として生成します。出力Observableをサブスクライブすると、入力Observableもサブスクライブされます。</target>
        </trans-unit>
        <trans-unit id="8a8fb471411d33905e9737fbb68ea61b6feae34c" translate="yes" xml:space="preserve">
          <source>A Scheduler lets you define in what execution context will an Observable deliver notifications to its Observer.</source>
          <target state="translated">スケジューラは、どのような実行コンテキストでObservableがObserverに通知を配信するかを定義します。</target>
        </trans-unit>
        <trans-unit id="1383655957399b6d6567929c08301e77b08501ae" translate="yes" xml:space="preserve">
          <source>A Subject is a special type of Observable that allows values to be multicasted to many Observers. Subjects are like EventEmitters.</source>
          <target state="translated">Subjectは、値を多くのObserverにマルチキャストすることができるObservableの特別なタイプです。Subject は EventEmitters のようなものです。</target>
        </trans-unit>
        <trans-unit id="595e5accf5017b8e9b3a26eab2f3945e3ee64ffd" translate="yes" xml:space="preserve">
          <source>A Subject is like an Observable, but can multicast to many Observers. Subjects are like EventEmitters: they maintain a registry of many listeners.</source>
          <target state="translated">SubjectはObservableのようなものですが、多くのObserversにマルチキャストすることができます。サブジェクトは EventEmitters のようなもので、多くのリスナーのレジストリを管理します。</target>
        </trans-unit>
        <trans-unit id="59267fecd593def896e3fba4fd2bf602984d25ea" translate="yes" xml:space="preserve">
          <source>A Subscribable or Promise of notifications to start new buffers.</source>
          <target state="translated">新しいバッファを開始するための通知のサブスクライバブルまたはプロミス。</target>
        </trans-unit>
        <trans-unit id="7313d23b65818f64b6af3fe148cd41e7983c1394" translate="yes" xml:space="preserve">
          <source>A Subscription essentially just has an &lt;code&gt;unsubscribe()&lt;/code&gt; function to release resources or cancel Observable executions.</source>
          <target state="translated">サブスクリプションには、基本的に、リソースを解放したり、監視可能な実行をキャンセルしたりするための &lt;code&gt;unsubscribe()&lt;/code&gt; 関数があります。</target>
        </trans-unit>
        <trans-unit id="c63c60cba20643163ad3c75c34404680f19c072f" translate="yes" xml:space="preserve">
          <source>A WebSocket constructor to use. This is useful for situations like using a WebSocket impl in Node (WebSocket is a DOM API), or for mocking a WebSocket for testing purposes</source>
          <target state="translated">使用するWebSocketのコンストラクタです。これは、NodeでWebSocket implを使用したり(WebSocketはDOM APIです)、テストのためにWebSocketをモックしたりするのに便利です。</target>
        </trans-unit>
        <trans-unit id="a9e61acb5afa79b453b4ba08613ae03fd867cf3a" translate="yes" xml:space="preserve">
          <source>A backward-compatibility layer eases the update process, allowing you to keep your apps working while you address most code changes at your own pace. The overall process can be carried out in stages:</source>
          <target state="translated">下位互換性のあるレイヤーはアップデートプロセスを容易にし、自分のペースでほとんどのコード変更に対応しながらアプリを動作させ続けることを可能にします。全体的なプロセスを段階的に行うことができます。</target>
        </trans-unit>
        <trans-unit id="4bd800c7ab855f649fc2eab1b004a611c7c13886" translate="yes" xml:space="preserve">
          <source>A basic test might look as follows:</source>
          <target state="translated">基本的なテストは以下のようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="eef697f1cf672e4d57623879c7156c74ecc95eec" translate="yes" xml:space="preserve">
          <source>A boolean function to select what values are to be counted. It is provided with arguments of:</source>
          <target state="translated">カウントされる値を選択するブール関数。の引数で提供されます。</target>
        </trans-unit>
        <trans-unit id="8f45c3c3413edfacde63e5866f13cd65204265d1" translate="yes" xml:space="preserve">
          <source>A configuration object for the fetch. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters&quot;&gt;See MDN for more details&lt;/a&gt;</source>
          <target state="translated">フェッチの構成オブジェクト。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters&quot;&gt;詳細については、MDNを参照してください&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c4de04a5af82cb23d096ab9e62b3870971781c1" translate="yes" xml:space="preserve">
          <source>A deserializer used for messages arriving on the socket from the server. Defaults to JSON.parse.</source>
          <target state="translated">サーバからソケットに到着するメッセージに使用されるデシリアライザ。デフォルトは JSON.parse です。</target>
        </trans-unit>
        <trans-unit id="d167c96728eb69fa561194cbec15b9f0fe0d7285" translate="yes" xml:space="preserve">
          <source>A diagram in the marble DSL. Letters map to keys in &lt;code&gt;values&lt;/code&gt; if provided.</source>
          <target state="translated">大理石のDSLの図。提供されている場合、文字は &lt;code&gt;values&lt;/code&gt; キーにマップされます。</target>
        </trans-unit>
        <trans-unit id="f009493c51fc2592cb8421af3d23ee4de3965f99" translate="yes" xml:space="preserve">
          <source>A factory function called to produce the error to be thrown when the source observable completes without emitting a value.</source>
          <target state="translated">値を出さずに観測可能なソースが終了した場合に、エラーを発生させるために呼び出されるファクトリー関数です。</target>
        </trans-unit>
        <trans-unit id="b40eaa47a4ae0d329a8fa61931721257cccf71cf" translate="yes" xml:space="preserve">
          <source>A flag to indicate whether this Subscription has already been unsubscribed.</source>
          <target state="translated">このサブスクリプションが既に購読解除されているかどうかを示すフラグ。</target>
        </trans-unit>
        <trans-unit id="02bee705142a9e998ed4143d3f997683135a4d25" translate="yes" xml:space="preserve">
          <source>A function called with each item to test for condition matching.</source>
          <target state="translated">条件一致をテストするために各項目で呼び出される関数。</target>
        </trans-unit>
        <trans-unit id="2ee4f743ea411d4ec9d0fd32831905e9c306b5b3" translate="yes" xml:space="preserve">
          <source>A function describing how to perform the disposal of resources when the &lt;code&gt;unsubscribe&lt;/code&gt; method is called.</source>
          <target state="translated">&lt;code&gt;unsubscribe&lt;/code&gt; メソッドが呼び出されたときにリソースの破棄を実行する方法を説明する関数。</target>
        </trans-unit>
        <trans-unit id="a174085e61b79f49711a9af69a212b61636f083c" translate="yes" xml:space="preserve">
          <source>A function for determining if an item meets a specified condition.</source>
          <target state="translated">指定された条件を満たしているかどうかを判定する機能。</target>
        </trans-unit>
        <trans-unit id="8a7581bf977049768d2d00279073287d26391eb0" translate="yes" xml:space="preserve">
          <source>A function representing a task, or some unit of work to be executed by the Scheduler.</source>
          <target state="translated">スケジューラが実行するタスクや作業の単位を表す関数。</target>
        </trans-unit>
        <trans-unit id="a7aff61d4e068dee4178bfa46d0c1c9fd8cd2470" translate="yes" xml:space="preserve">
          <source>A function that evaluates a value emitted by the source Observable and returns a boolean. Also takes the (zero-based) index as the second argument.</source>
          <target state="translated">ソースObservableによって放出された値を評価し、ブール値を返す関数。また、(ゼロベースの)インデックスを第二引数に取ります。</target>
        </trans-unit>
        <trans-unit id="f3ab69212cd1f782cb1df01a2c437c820bc7a64d" translate="yes" xml:space="preserve">
          <source>A function that evaluates each value emitted by the source Observable. If it returns &lt;code&gt;true&lt;/code&gt;, the value is emitted on the first Observable in the returned array, if &lt;code&gt;false&lt;/code&gt; the value is emitted on the second Observable in the array. The &lt;code&gt;index&lt;/code&gt; parameter is the number &lt;code&gt;i&lt;/code&gt; for the i-th source emission that has happened since the subscription, starting from the number &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">ソースObservableによって発行された各値を評価する関数。 &lt;code&gt;true&lt;/code&gt; を返す場合、値は返された配列の最初のObservableで発行され、 &lt;code&gt;false&lt;/code&gt; の場合、値は配列の2番目のObservableで発行されます。 &lt;code&gt;index&lt;/code&gt; パラメータは、数ある &lt;code&gt;i&lt;/code&gt; 番号から開始し、サブスクリプション以降起こったi番目のソース排出用 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b06811fdd9e2d5cba0316a248e9cd4d70bbd164" translate="yes" xml:space="preserve">
          <source>A function that evaluates each value emitted by the source Observable. If it returns &lt;code&gt;true&lt;/code&gt;, the value is emitted, if &lt;code&gt;false&lt;/code&gt; the value is not passed to the output Observable. The &lt;code&gt;index&lt;/code&gt; parameter is the number &lt;code&gt;i&lt;/code&gt; for the i-th source emission that has happened since the subscription, starting from the number &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">ソースObservableによって発行された各値を評価する関数。それが返された場合は &lt;code&gt;true&lt;/code&gt; 場合、値は、放出される &lt;code&gt;false&lt;/code&gt; 値が出力観察可能に渡されていません。 &lt;code&gt;index&lt;/code&gt; パラメータは、数ある &lt;code&gt;i&lt;/code&gt; 番号から開始し、サブスクリプション以降起こったi番目のソース排出用 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e1cc55fd47812c320470c4debab0def8d7c31a3" translate="yes" xml:space="preserve">
          <source>A function that extracts the key for each item.</source>
          <target state="translated">各項目のキーを抽出する機能。</target>
        </trans-unit>
        <trans-unit id="3f20c2c55aa51748f5e336dd5f3cb99f33dbde47" translate="yes" xml:space="preserve">
          <source>A function that extracts the return element for each item.</source>
          <target state="translated">各項目の戻り値要素を抽出する関数。</target>
        </trans-unit>
        <trans-unit id="a7a58224a8bd100ed0e485a88080137b3854b471" translate="yes" xml:space="preserve">
          <source>A function that receives a value from the source Observable, for computing the silencing duration for each source value, returned as an Observable or a Promise.</source>
          <target state="translated">ソースObservableから値を受け取り、ObservableまたはPromiseとして返される各ソース値の消音時間を計算する関数。</target>
        </trans-unit>
        <trans-unit id="1d7f24177fda0fadd63dbf54c962d5ab5af0557d" translate="yes" xml:space="preserve">
          <source>A function that receives a value from the source Observable, for computing the silencing duration, returned as an Observable or a Promise.</source>
          <target state="translated">消音時間を計算するためにソースObservableから値を受け取る関数で、ObservableまたはPromiseとして返されます。</target>
        </trans-unit>
        <trans-unit id="436e0ae8e52a3c1bd4ebac765d2258eba7bc6c87" translate="yes" xml:space="preserve">
          <source>A function that receives a value from the source Observable, for computing the timeout duration for each source value, returned as an Observable or a Promise.</source>
          <target state="translated">ソースObservableから値を受け取る関数で、ObservableまたはPromiseとして返される各ソース値のタイムアウト時間を計算します。</target>
        </trans-unit>
        <trans-unit id="825ac0575211babe238f66911631d9f77c0e8aed" translate="yes" xml:space="preserve">
          <source>A function that returns an Observable for each value emitted by the source Observable, which is then used to delay the emission of that item on the output Observable until the Observable returned from this function emits a value.</source>
          <target state="translated">ソースObservableによって放出された値ごとにObservableを返す関数で、この関数から返されたObservableが値を放出するまで、その項目の出力Observableへの放出を遅延させるために使用されます。</target>
        </trans-unit>
        <trans-unit id="181087b8926d4dacf4b94055e684261bebea38b7" translate="yes" xml:space="preserve">
          <source>A function that returns an Observable to determine how long each group should exist.</source>
          <target state="translated">各グループがどのくらいの期間存在するべきかを決定するためのObservableを返す関数。</target>
        </trans-unit>
        <trans-unit id="eac0f18ee26680057d8da59fa8a9a4494d446b1a" translate="yes" xml:space="preserve">
          <source>A function that takes a &lt;code&gt;handler&lt;/code&gt; function as an argument and removes it from the event source. If &lt;code&gt;addHandler&lt;/code&gt; returns some kind of token, &lt;code&gt;removeHandler&lt;/code&gt; function will have it as a second parameter.</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; 関数を引数として取り、それをイベントソースから削除する関数。 &lt;code&gt;addHandler&lt;/code&gt; が何らかのトークンを返す場合、 &lt;code&gt;removeHandler&lt;/code&gt; 関数はそれを2番目のパラメーターとして使用します。</target>
        </trans-unit>
        <trans-unit id="512d938ca2d5a7413ab46f41aee1ed8553649e96" translate="yes" xml:space="preserve">
          <source>A function that takes a &lt;code&gt;handler&lt;/code&gt; function as argument and attaches it somehow to the actual source of events.</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; 関数を引数として取り、それを何らかの形で実際のイベントソースに添付する関数。</target>
        </trans-unit>
        <trans-unit id="3a61edb60f61f060a406dfa0442bbf11948b3169" translate="yes" xml:space="preserve">
          <source>A function that takes no arguments and returns an Observable that signals (on either &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;complete&lt;/code&gt;) when to close the previous window and start a new one.</source>
          <target state="translated">引数を取らず、前のウィンドウを閉じて新しいウィンドウを開始するタイミングを（ &lt;code&gt;next&lt;/code&gt; または &lt;code&gt;complete&lt;/code&gt; で）通知するObservableを返す関数。</target>
        </trans-unit>
        <trans-unit id="b395dbcb5596f4c88f229c93db0ee664db88fae9" translate="yes" xml:space="preserve">
          <source>A function that takes no arguments and returns an Observable that signals buffer closure.</source>
          <target state="translated">引数を取らず、バッファの閉鎖を知らせるObservableを返す関数。</target>
        </trans-unit>
        <trans-unit id="eb8af6ffdd3fa19c6c972a4b39dd50cf5f5f1294" translate="yes" xml:space="preserve">
          <source>A function that takes the value emitted by the &lt;code&gt;openings&lt;/code&gt; observable and returns a Subscribable or Promise, which, when it emits, signals that the associated buffer should be emitted and cleared.</source>
          <target state="translated">&lt;code&gt;openings&lt;/code&gt; 可能な開始点によって発行された値を取り、SubscribableまたはPromiseを返す関数。発行すると、関連するバッファーが発行およびクリアされる必要があることを通知します。</target>
        </trans-unit>
        <trans-unit id="7d19cda655bdbba514c8fec7bdafdf3f88786fc2" translate="yes" xml:space="preserve">
          <source>A function that takes the value emitted by the &lt;code&gt;openings&lt;/code&gt; observable and returns an Observable, which, when it emits (either &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;complete&lt;/code&gt;), signals that the associated window should complete.</source>
          <target state="translated">監視可能な &lt;code&gt;openings&lt;/code&gt; によって放出された値を取り、Observableを返す関数。放出されると（ &lt;code&gt;next&lt;/code&gt; または &lt;code&gt;complete&lt;/code&gt; ）、関連するウィンドウが完了する必要があることを通知します。</target>
        </trans-unit>
        <trans-unit id="9369aa3d687e421514195d33b42429aec008ddf9" translate="yes" xml:space="preserve">
          <source>A function that, when applied to an item emitted by the source Observable, returns an Observable.</source>
          <target state="translated">ソースObservableによって放出されたアイテムに適用されると、Observableを返す関数。</target>
        </trans-unit>
        <trans-unit id="e4521e5c267ddc4bb538190c2ca06dc029d5330e" translate="yes" xml:space="preserve">
          <source>A function that, when applied to an item emitted by the source or the output Observable, returns an Observable.</source>
          <target state="translated">ソースまたは出力Observableによって放出されたアイテムに適用され、Observableを返す関数。</target>
        </trans-unit>
        <trans-unit id="a84e17a04254867664848fc07b92b50560da7d6a" translate="yes" xml:space="preserve">
          <source>A function to generate the subscription message to be sent to the server. This will still be processed by the serializer in the WebSocketSubject's config. (Which defaults to JSON serialization)</source>
          <target state="translated">サーバに送信するサブスクリプション・メッセージを生成する関数です。これはまだ WebSocketSubject の設定のシリアライザによって処理されます。(デフォルトは JSON シリアライゼーション)</target>
        </trans-unit>
        <trans-unit id="a1d17233911c6a0e69dc28d400ccf5e8edbe8e23" translate="yes" xml:space="preserve">
          <source>A function to generate the unsubscription message to be sent to the server at teardown. This will still be processed by the serializer in the WebSocketSubject's config.</source>
          <target state="translated">テアダウン時にサーバに送信されるサブスクリプション解除メッセージを生成する関数です。これは、WebSocketSubject の設定にあるシリアライザによって処理されます。</target>
        </trans-unit>
        <trans-unit id="345023669dea9569b5e96a5b0a04ffc52aedf25a" translate="yes" xml:space="preserve">
          <source>A function to test each item emitted from the source Observable.</source>
          <target state="translated">ソースObservableから放出された各項目をテストする関数。</target>
        </trans-unit>
        <trans-unit id="20ba5bd927254728b204da746dfd84abfc0c9fa2" translate="yes" xml:space="preserve">
          <source>A function which creates an Observable, that can use injected resource object.</source>
          <target state="translated">インジェクションされたリソースオブジェクトを利用できるObservableを作成する関数です。</target>
        </trans-unit>
        <trans-unit id="9ec4c214ea4517113854529a01f2d0f71b7f9ef9" translate="yes" xml:space="preserve">
          <source>A function which creates any resource object that implements &lt;code&gt;unsubscribe&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;unsubscribe&lt;/code&gt; メソッドを実装するリソースオブジェクトを作成する関数。</target>
        </trans-unit>
        <trans-unit id="085acb778c87b3d06d060ed301b6efeae7bf802c" translate="yes" xml:space="preserve">
          <source>A getter method that returns a number representing the current time (at the time this function was called) according to the scheduler's own internal clock.</source>
          <target state="translated">スケジューラの内部時計に応じて、現在時刻(この関数が呼び出された時刻)を表す数値を返すゲッターメソッドです。</target>
        </trans-unit>
        <trans-unit id="06d29234ccfd4191ed3ffb325c080e536a830b43" translate="yes" xml:space="preserve">
          <source>A multicasted Observable uses a Subject under the hood to make multiple Observers see the same Observable execution.</source>
          <target state="translated">マルチキャストされたObservableは、フードの下にあるSubjectを使用して、複数のObservableが同じObservableの実行を見られるようにします。</target>
        </trans-unit>
        <trans-unit id="f1c6692289c195d88b6f02552c67a2b7ecc0cfc2" translate="yes" xml:space="preserve">
          <source>A normal Observer object or a callback for &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">通常のObserverオブジェクトまたは &lt;code&gt;next&lt;/code&gt; のコールバック。</target>
        </trans-unit>
        <trans-unit id="0b14e10f14b46eb52564b107c3c18922d62e81ef" translate="yes" xml:space="preserve">
          <source>A normalized AJAX response.</source>
          <target state="translated">正規化されたAJAXレスポンス。</target>
        </trans-unit>
        <trans-unit id="832e857924dcf7ac90856d16c612abe5583d2e58" translate="yes" xml:space="preserve">
          <source>A partially defined Observer or a &lt;code&gt;next&lt;/code&gt; callback function.</source>
          <target state="translated">部分的に定義されたオブザーバーまたは &lt;code&gt;next&lt;/code&gt; コールバック関数。</target>
        </trans-unit>
        <trans-unit id="3e7fcb0ff2bd1ab1f5f2e0116a79bcfe7f2f9174" translate="yes" xml:space="preserve">
          <source>A predicate for selecting the appropriate messages from the server for the output stream.</source>
          <target state="translated">出力ストリームのためにサーバからの適切なメッセージを選択するための述語。</target>
        </trans-unit>
        <trans-unit id="69939066fee7c1a440ccb1dfd8dfbe76ef63e1ce" translate="yes" xml:space="preserve">
          <source>A predicate function to evaluate items emitted by the source Observable.</source>
          <target state="translated">ソースObservableから放出された項目を評価する述語関数。</target>
        </trans-unit>
        <trans-unit id="ed983b10ec661fc781c33afc49596f31baaae0ee" translate="yes" xml:space="preserve">
          <source>A representation of any set of values over any amount of time. This is the most basic building block of RxJS.</source>
          <target state="translated">任意の値の集合を任意の時間にわたって表現したもの。これはRxJSの最も基本的な構成要素です。</target>
        </trans-unit>
        <trans-unit id="b9b66ed15a9a4e0c284c9afdfaeb0b0b176e9562" translate="yes" xml:space="preserve">
          <source>A serializer used to create messages from passed values before the messages are sent to the server. Defaults to JSON.stringify.</source>
          <target state="translated">メッセージがサーバーに送信される前に、渡された値からメッセージを作成するために使用されるシリアライザ。デフォルトは JSON.stringify です。</target>
        </trans-unit>
        <trans-unit id="ff7eb2bf9dc197cd6db071463f78db0f65ad773e" translate="yes" xml:space="preserve">
          <source>A shortcut to create a Notification instance of the type &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;complete&lt;/code&gt; の Notificationインスタンスを作成するためのショートカット。</target>
        </trans-unit>
        <trans-unit id="d81c5d3e349ae456b72b795ea3af164beb77755c" translate="yes" xml:space="preserve">
          <source>A shortcut to create a Notification instance of the type &lt;code&gt;error&lt;/code&gt; from a given error.</source>
          <target state="translated">指定された &lt;code&gt;error&lt;/code&gt; からタイプerrorの Notificationインスタンスを作成するショートカット。</target>
        </trans-unit>
        <trans-unit id="dc2ac3c034182e80275264531f2481e8b5aa45f0" translate="yes" xml:space="preserve">
          <source>A shortcut to create a Notification instance of the type &lt;code&gt;next&lt;/code&gt; from a given value.</source>
          <target state="translated">指定された値から &lt;code&gt;next&lt;/code&gt; のタイプの通知インスタンスを作成するショートカット。</target>
        </trans-unit>
        <trans-unit id="c3d9971add316bca4c32c78db34ba1835fc86306" translate="yes" xml:space="preserve">
          <source>A similar effect could be achieved with &lt;a href=&quot;count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;isEmpty&lt;/code&gt; can emit a &lt;code&gt;false&lt;/code&gt; value sooner.</source>
          <target state="translated">&lt;a href=&quot;count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;でも同様の効果が得られますが、 &lt;code&gt;isEmpty&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; 値をより早く出力できます。</target>
        </trans-unit>
        <trans-unit id="58aead400ac5e5653e3f72ddc4177b36ea162b31" translate="yes" xml:space="preserve">
          <source>A simple Observable that emits neither values nor errors nor the completion notification. It can be used for testing purposes or for composing with other Observables. Please note that by never emitting a complete notification, this Observable keeps the subscription from being disposed automatically. Subscriptions need to be manually disposed.</source>
          <target state="translated">値もエラーも完了通知も出さないシンプルなObservableです。テスト目的で使用したり、他のObservableと組み合わせて使用することができます。完了通知を出さないことで、このObservableはサブスクリプションが自動的に破棄されないようにしていることに注意してください。サブスクリプションは手動で処分する必要があります。</target>
        </trans-unit>
        <trans-unit id="daeebe20328b78c57c2965c3885cd4f9150827af" translate="yes" xml:space="preserve">
          <source>A simple example emitting true if all elements are less than 5, false otherwise</source>
          <target state="translated">すべての要素が5未満の場合はtrue、そうでない場合はfalseを発行する単純な例</target>
        </trans-unit>
        <trans-unit id="81e41a4a8e6d911462364fa9ad372501ccb3129c" translate="yes" xml:space="preserve">
          <source>A simple example with numbers</source>
          <target state="translated">数字を使った簡単な例</target>
        </trans-unit>
        <trans-unit id="0017d7fc0455f54b0b0d3ac7b46d34bb31004b1b" translate="yes" xml:space="preserve">
          <source>A static factory for a Subscriber, given a (potentially partial) definition of an Observer.</source>
          <target state="translated">オブザーバの (潜在的に部分的な)定義が与えられたサブスクライバの静的ファクトリ。</target>
        </trans-unit>
        <trans-unit id="1a80de59cfb7fce6af657c15200a9ea50fa95ff4" translate="yes" xml:space="preserve">
          <source>A test example with specified values:</source>
          <target state="translated">値を指定したテスト例です。</target>
        </trans-unit>
        <trans-unit id="5904f92e91374bb07f1b8a9b7cf799d0276598a4" translate="yes" xml:space="preserve">
          <source>A test example with subscription assertions:</source>
          <target state="translated">サブスクリプション・アサーションを使用したテスト例。</target>
        </trans-unit>
        <trans-unit id="6d05f99bacc1009f0378c940ffbdf08d8d33492a" translate="yes" xml:space="preserve">
          <source>A typical example of a creation operator would be the &lt;code&gt;interval&lt;/code&gt; function. It takes a number (not an Observable) as input argument, and produces an Observable as output:</source>
          <target state="translated">作成演算子の典型的な例は、 &lt;code&gt;interval&lt;/code&gt; 関数です。入力引数として（Observableではなく）数値を取り、Observableを出力として生成します。</target>
        </trans-unit>
        <trans-unit id="b3423f2e2a7685acbd8fc5ab4ba2ea70e1e221bb" translate="yes" xml:space="preserve">
          <source>A variant of Subject that &quot;replays&quot; or emits old values to new subscribers. It buffers a set number of values and will emit those values immediately to any new subscribers in addition to emitting new values to existing subscribers.</source>
          <target state="translated">新しいサブスクライバに古い値を「リプレイ」したり、放出したりする Subject の変種。これは、設定された数の値をバッファリングし、既存の加入者に新しい値を送信するだけでなく、新しい加入者にもすぐにそれらの値を送信します。</target>
        </trans-unit>
        <trans-unit id="77bd200819e8216578aa6a20682297a4fcdf7791" translate="yes" xml:space="preserve">
          <source>A variant of Subject that only emits a value when it completes. It will emit its latest value to all its observers on completion.</source>
          <target state="translated">完了したときにのみ値を出力する Subject の変種です。これは、完了時にその最新の値をすべてのオブザーバに送信します。</target>
        </trans-unit>
        <trans-unit id="ce13e7226e5fa3326a58386cbacfa231b35fc1b1" translate="yes" xml:space="preserve">
          <source>A variant of Subject that requires an initial value and emits its current value whenever it is subscribed to.</source>
          <target state="translated">初期値を必要とし、それが購読されているときはいつでも現在の値を出力するSubjectのバリアント。</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="6970dba4e61b8a8291ad7482373472fd7ab1cb7e" translate="yes" xml:space="preserve">
          <source>Accepts an &lt;code&gt;Array&lt;/code&gt; of &lt;a href=&quot;../type-alias/observableinput&quot;&gt;&lt;code&gt;ObservableInput&lt;/code&gt;&lt;/a&gt; or a dictionary &lt;code&gt;Object&lt;/code&gt; of &lt;a href=&quot;../type-alias/observableinput&quot;&gt;&lt;code&gt;ObservableInput&lt;/code&gt;&lt;/a&gt; and returns an &lt;a href=&quot;../class/observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt; that emits either an array of values in the exact same order as the passed array, or a dictionary of values in the same shape as the passed dictionary.</source>
          <target state="translated">受け入れ &lt;code&gt;Array&lt;/code&gt; の&lt;a href=&quot;../type-alias/observableinput&quot;&gt; &lt;code&gt;ObservableInput&lt;/code&gt; &lt;/a&gt;または辞書 &lt;code&gt;Object&lt;/code&gt; の&lt;a href=&quot;../type-alias/observableinput&quot;&gt; &lt;code&gt;ObservableInput&lt;/code&gt; に&lt;/a&gt;戻る&lt;a href=&quot;../class/observable&quot;&gt; &lt;code&gt;Observable&lt;/code&gt; &lt;/a&gt;その発するいずれか渡された配列、または渡された辞書と同じ形状の値の辞書とまったく同じ順序で値の配列。</target>
        </trans-unit>
        <trans-unit id="f302cad0f3e21130c578083076708337124b26be" translate="yes" xml:space="preserve">
          <source>Add fallback observable</source>
          <target state="translated">フォールバック観測値の追加</target>
        </trans-unit>
        <trans-unit id="04b3ddff5046a21c4d3de14d423344ef2017b089" translate="yes" xml:space="preserve">
          <source>Add type definition file included in tsconfig.json or CLI argument.</source>
          <target state="translated">tsconfig.jsonに含まれる型定義ファイルを追加するか、CLIの引数に追加します。</target>
        </trans-unit>
        <trans-unit id="e96e9902a32c66c0b71790ad6985f9dd53265b5c" translate="yes" xml:space="preserve">
          <source>Additionally, subscriptions may be grouped together through the &lt;code&gt;add()&lt;/code&gt; method, which will attach a child Subscription to the current Subscription. When a Subscription is unsubscribed, all its children (and its grandchildren) will be unsubscribed as well.</source>
          <target state="translated">さらに、サブスクリプションは、現在のサブスクリプションに子サブスクリプションをアタッチする &lt;code&gt;add()&lt;/code&gt; メソッドを介してグループ化できます。サブスクリプションが購読解除されると、そのすべての子（およびその孫）も購読解除されます。</target>
        </trans-unit>
        <trans-unit id="0aa18f6c9ead1c7ca1c22b5cfd3ff2341aea9ebe" translate="yes" xml:space="preserve">
          <source>Adds a tear down to be called during the unsubscribe() of this Subscription. Can also be used to add a child subscription.</source>
          <target state="translated">このサブスクリプションのunsubscribe()中に呼び出されるティアダウンを追加します。子サブスクリプションの追加にも使用できます。</target>
        </trans-unit>
        <trans-unit id="fdd3e24e6fb92b8a42d2faa20d75b3f18d75c394" translate="yes" xml:space="preserve">
          <source>After Observable emits value, it will complete immediately. This means even if &lt;code&gt;func&lt;/code&gt; calls callback again, values from second and consecutive calls will never appear on the stream. If you need to handle functions that call callbacks multiple times, check out &lt;a href=&quot;fromevent&quot;&gt;&lt;code&gt;fromEvent&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;fromeventpattern&quot;&gt;&lt;code&gt;fromEventPattern&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Observableが値を発行した後、すぐに完了します。つまり、 &lt;code&gt;func&lt;/code&gt; が再度コールバックを呼び出しても、2回目以降の呼び出しからの値はストリームに表示されません。コールバックを複数回呼び出す関数を処理する必要がある場合は、代わりに&lt;a href=&quot;fromevent&quot;&gt; &lt;code&gt;fromEvent&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;fromeventpattern&quot;&gt; &lt;code&gt;fromEventPattern&lt;/code&gt; を&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="62e230c5906ba4af3b736e1edf79883437e056f5" translate="yes" xml:space="preserve">
          <source>After registration, every time an event that we listen to happens, Observable returned by &lt;code&gt;fromEventPattern&lt;/code&gt; will emit value that event handler function was called with. Note that if event handler was called with more then one argument, second and following arguments will not appear in the Observable.</source>
          <target state="translated">登録後、リッスンするイベントが発生する &lt;code&gt;fromEventPattern&lt;/code&gt; に、fromEventPatternから返されたObservableは、イベントハンドラー関数が呼び出されたときの値を発行します。イベントハンドラーが複数の引数で呼び出された場合、2番目以降の引数はObservableに表示されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="01e81606a47771087aa940effff843c4b9eaabf0" translate="yes" xml:space="preserve">
          <source>After the source observable completes, appends an emission and then completes too.</source>
          <target state="translated">ソースオブザーバブルが完了した後、エミッショ ンを追加して完了します。</target>
        </trans-unit>
        <trans-unit id="812b4c6aa91173811b26dca0debd2d93641cd98c" translate="yes" xml:space="preserve">
          <source>AjaxError</source>
          <target state="translated">AjaxError</target>
        </trans-unit>
        <trans-unit id="e1175723771662904588d76a2118378edca8e6d8" translate="yes" xml:space="preserve">
          <source>AjaxRequest</source>
          <target state="translated">AjaxRequest</target>
        </trans-unit>
        <trans-unit id="b50c373483c8fcf45654d5d17af76c8e637c982d" translate="yes" xml:space="preserve">
          <source>AjaxResponse</source>
          <target state="translated">AjaxResponse</target>
        </trans-unit>
        <trans-unit id="9af59b49cf059f9d459db29a4d043d065589afb4" translate="yes" xml:space="preserve">
          <source>AjaxTimeoutError</source>
          <target state="translated">AjaxTimeoutError</target>
        </trans-unit>
        <trans-unit id="105cfe4477aacf8249d3536b4bf75dabe360f308" translate="yes" xml:space="preserve">
          <source>Align the start of &lt;code&gt;xsubs&lt;/code&gt; and &lt;code&gt;ysubs&lt;/code&gt; diagrams with &lt;code&gt;expected&lt;/code&gt; diagram.</source>
          <target state="translated">&lt;code&gt;xsubs&lt;/code&gt; および &lt;code&gt;ysubs&lt;/code&gt; 図の始点を &lt;code&gt;expected&lt;/code&gt; 図と揃えます。</target>
        </trans-unit>
        <trans-unit id="6ef4c56f1f3170c1f08a8ed6c2e4fe9df4af5b0f" translate="yes" xml:space="preserve">
          <source>All Module Types (CJS/ES6/AMD/TypeScript) via npm</source>
          <target state="translated">すべてのモジュールタイプ (CJS/ES6/AMD/TypeScript)を npm 経由で提供</target>
        </trans-unit>
        <trans-unit id="514510db8c4150ad0ec84a47308b42bde697ded1" translate="yes" xml:space="preserve">
          <source>All observable classes (&lt;a href=&quot;https://github.com/ReactiveX/rxjs/tree/5.5.8/src/observable&quot;&gt;https://github.com/ReactiveX/rxjs/tree/5.5.8/src/observable&lt;/a&gt;) have been removed from v6, in favor of existing or new operators that perform the same operations as the class methods. For example, &lt;code&gt;ArrayObservable.create(myArray)&lt;/code&gt; can be replaced by &lt;code&gt;from(myArray)&lt;/code&gt;, or the new operator &lt;code&gt;fromArray()&lt;/code&gt;.</source>
          <target state="translated">クラスメソッドと同じ操作を実行する既存または新規の演算子を優先して、すべての監視可能なクラス（&lt;a href=&quot;https://github.com/ReactiveX/rxjs/tree/5.5.8/src/observable&quot;&gt;https://github.com/ReactiveX/rxjs/tree/5.5.8/src/observable&lt;/a&gt;）がv6から削除されました。たとえば、 &lt;code&gt;ArrayObservable.create(myArray)&lt;/code&gt; は、 &lt;code&gt;from(myArray)&lt;/code&gt; または新しい演算子 &lt;code&gt;fromArray()&lt;/code&gt; で置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="0570b2ca99e5e7005b25a7d91319eade51046745" translate="yes" xml:space="preserve">
          <source>Also see the &lt;a href=&quot;operators#join-creation-operators&quot;&gt;Join Creation Operators&lt;/a&gt; section above.</source>
          <target state="translated">上記の&lt;a href=&quot;operators#join-creation-operators&quot;&gt;結合作成演算子の&lt;/a&gt;セクションも参照してください。</target>
        </trans-unit>
        <trans-unit id="ddc4de29faa4779f5e84f09b14c51796f6f1d9db" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;run()&lt;/code&gt; executes entirely synchronously, the helper functions inside your callback function do not! These functions &lt;strong&gt;schedule assertions&lt;/strong&gt; that will execute either when your callback completes or when you explicitly call &lt;code&gt;flush()&lt;/code&gt;. Be wary of calling synchronous assertions, for example &lt;code&gt;expect&lt;/code&gt; from your testing library of choice, from within the callback. See &lt;a href=&quot;marble-testing#synchronous-assertion&quot;&gt;Synchronous Assertion&lt;/a&gt; for more information on how to do this.</source>
          <target state="translated">が、 &lt;code&gt;run()&lt;/code&gt; 完全同期を実行、コールバック関数内のヘルパー関数はしないでください！これらの関数は、コールバックが完了したとき、または &lt;code&gt;flush()&lt;/code&gt; を明示的に呼び出したときに実行&lt;strong&gt;されるアサーション&lt;/strong&gt;を&lt;strong&gt;スケジュール&lt;/strong&gt;します。コールバック内から、選択したテストライブラリに &lt;code&gt;expect&lt;/code&gt; するなど、同期アサーションの呼び出しに注意してください。これを行う方法の詳細については、&lt;a href=&quot;marble-testing#synchronous-assertion&quot;&gt;同期アサーション&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7290a7b1e738919f1fad7cc0ff505aa61251a321" translate="yes" xml:space="preserve">
          <source>Although this collection is not event target in itself, &lt;code&gt;fromEvent&lt;/code&gt; will iterate over all Nodes it contains and install event handler function in every of them. When returned Observable is unsubscribed, function will be removed from all Nodes.</source>
          <target state="translated">このコレクション自体はイベントターゲットではありませんが、 &lt;code&gt;fromEvent&lt;/code&gt; は、それが含むすべてのノードを反復処理し、それらすべてにイベントハンドラー関数をインストールします。返されたObservableがサブスクライブされていない場合、関数はすべてのノードから削除されます。</target>
        </trans-unit>
        <trans-unit id="2f3d96867ef3ae1b957b32b3ee78a80f323ec3df" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;Observable&lt;/strong&gt; is a lazily evaluated computation that can synchronously or asynchronously return zero to (potentially) infinite values from the time it's invoked onwards.</source>
          <target state="translated">アン&lt;strong&gt;観測は、&lt;/strong&gt;同期または非同期で、それ以降は呼び出さだ時から（潜在的に）無限の値にゼロを返すことができます遅延評価計算です。</target>
        </trans-unit>
        <trans-unit id="fdabd30359339d2f65c66d1635f6a6017447f842" translate="yes" xml:space="preserve">
          <source>An Observable representing values belonging to the same group represented by a common key. The values emitted by a GroupedObservable come from the source Observable. The common key is available as the field &lt;code&gt;key&lt;/code&gt; on a GroupedObservable instance.</source>
          <target state="translated">共通のキーで表される同じグループに属する値を表すObservable。GroupedObservableによって発行される値は、ソースObservableから取得されます。共通キーは、GroupedObservableインスタンスのフィールド &lt;code&gt;key&lt;/code&gt; として使用できます。</target>
        </trans-unit>
        <trans-unit id="2126f07d8b41f5aaca35b6c0b56828a7558936a0" translate="yes" xml:space="preserve">
          <source>An Observable that completes the previous window and starts a new window.</source>
          <target state="translated">前のウィンドウを完了させ、新しいウィンドウを開始するObservable。</target>
        </trans-unit>
        <trans-unit id="eef9d9f524886759c9f7f7b8471abe2dc0dbd650" translate="yes" xml:space="preserve">
          <source>An Observable that emits no items to the Observer and never completes.</source>
          <target state="translated">オブザーバにアイテムを放出せず、完了しないオブザーバブル。</target>
        </trans-unit>
        <trans-unit id="f5a1fcfb06b841150430ba58a7521f53ce01d9a1" translate="yes" xml:space="preserve">
          <source>An Observable that signals the buffer to be emitted on the output Observable.</source>
          <target state="translated">出力されるObservable上で、バッファが放出されるようにシグナルを送るObservable。</target>
        </trans-unit>
        <trans-unit id="a31b174ccd32d747b6510dfee065773758e2d469" translate="yes" xml:space="preserve">
          <source>An Observable that triggers the subscription to the source Observable once it emits any value.</source>
          <target state="translated">任意の値を放出すると、ソースObservableへのサブスクリプションをトリガーするObservable。</target>
        </trans-unit>
        <trans-unit id="773261e3c36d88f960d0387c51370a6a26126228" translate="yes" xml:space="preserve">
          <source>An Observable to replace each value from the source Observable.</source>
          <target state="translated">ソースのObservableから各値を置き換えるためのObservable。</target>
        </trans-unit>
        <trans-unit id="b6e7ad14921bdce569edd7b5b3ca7dca5e12aabd" translate="yes" xml:space="preserve">
          <source>An Observer &lt;code&gt;complete&lt;/code&gt; callback.</source>
          <target state="translated">オブザーバーの &lt;code&gt;complete&lt;/code&gt; コールバック。</target>
        </trans-unit>
        <trans-unit id="8d40920acd75345296d3a12fbe36dadd5106b59a" translate="yes" xml:space="preserve">
          <source>An Observer &lt;code&gt;error&lt;/code&gt; callback.</source>
          <target state="translated">オブザーバー &lt;code&gt;error&lt;/code&gt; コールバック。</target>
        </trans-unit>
        <trans-unit id="d2e15da54f48a5ffa62a9bd03b8be8923ce3223c" translate="yes" xml:space="preserve">
          <source>An Observer &lt;code&gt;next&lt;/code&gt; callback.</source>
          <target state="translated">オブザーバーの &lt;code&gt;next&lt;/code&gt; コールバック。</target>
        </trans-unit>
        <trans-unit id="290534edc14a92a2f20f67f00211fac900855530" translate="yes" xml:space="preserve">
          <source>An Observer or the &lt;code&gt;next&lt;/code&gt; callback.</source>
          <target state="translated">オブザーバーまたは &lt;code&gt;next&lt;/code&gt; コールバック。</target>
        </trans-unit>
        <trans-unit id="8142d3c4512e5fc9ab5b382e6d48c2f2c070d795" translate="yes" xml:space="preserve">
          <source>An Observer than watches when close events occur on the underlying webSocket</source>
          <target state="translated">ベースとなる webSocket で close イベントが発生したときに監視する Observer</target>
        </trans-unit>
        <trans-unit id="7657d899f5aaec99147ebbd9f77e9b0e634b3882" translate="yes" xml:space="preserve">
          <source>An Observer that watches when a close is about to occur due to unsubscription.</source>
          <target state="translated">サブスクリプション解除によるクローズが発生しそうになったときに監視するオブザーバー。</target>
        </trans-unit>
        <trans-unit id="3132b8e54e0ef31bfe72f5ff852390ecf6b3479f" translate="yes" xml:space="preserve">
          <source>An Observer that watches when open events occur on the underlying web socket.</source>
          <target state="translated">ウェブソケット上でオープンイベントが発生したときに監視するオブザーバです。</target>
        </trans-unit>
        <trans-unit id="91c0a696b86c72c060aa4384dcb22d8de7a3a054" translate="yes" xml:space="preserve">
          <source>An error thrown when an Observable or a sequence was queried but has no elements.</source>
          <target state="translated">Observable またはシーケンスがクエリされたが、要素がない場合にスローされるエラー。</target>
        </trans-unit>
        <trans-unit id="da13ad6095d69814a5801a7d120440a1d6cab007" translate="yes" xml:space="preserve">
          <source>An error thrown when an action is invalid because the object has been unsubscribed.</source>
          <target state="translated">オブジェクトが購読解除されていないため、アクションが無効な場合にスローされるエラー。</target>
        </trans-unit>
        <trans-unit id="edcf9ad5deaa38ba68865544115b17e656d8234c" translate="yes" xml:space="preserve">
          <source>An error thrown when an element was queried at a certain index of an Observable, but no such index or position exists in that sequence.</source>
          <target state="translated">Observable の特定のインデックスで要素がクエリされたが、そのシーケンスにそのようなインデックスや位置が存在しない場合にスローされるエラー。</target>
        </trans-unit>
        <trans-unit id="e3bba335f950fd7f62a4632dd56239ddfb99ade9" translate="yes" xml:space="preserve">
          <source>An error thrown when duetime elapses.</source>
          <target state="translated">duetime が経過したときにエラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="351c9f6fe481a21cfd383241cc681a6e67328aa7" translate="yes" xml:space="preserve">
          <source>An error thrown when one or more errors have occurred during the &lt;code&gt;unsubscribe&lt;/code&gt; of a &lt;a href=&quot;../class/subscription&quot;&gt;&lt;code&gt;Subscription&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1つ以上のエラーが中に発生したときにエラーがスロー &lt;code&gt;unsubscribe&lt;/code&gt; の&lt;a href=&quot;../class/subscription&quot;&gt; &lt;code&gt;Subscription&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9db7036f458eae0a4e55d2760ffc791aecceeada" translate="yes" xml:space="preserve">
          <source>An example comparing the first letters of the name</source>
          <target state="translated">名前の頭文字を比較した例</target>
        </trans-unit>
        <trans-unit id="e65a68f21295f409926b7be91cbe2fa484218580" translate="yes" xml:space="preserve">
          <source>An example comparing the name of persons</source>
          <target state="translated">人名を比較した例</target>
        </trans-unit>
        <trans-unit id="01e0a637d42f33d5f806ef0237a5736686d5cbad" translate="yes" xml:space="preserve">
          <source>An example using a compare function</source>
          <target state="translated">比較関数を使用した例</target>
        </trans-unit>
        <trans-unit id="97a9626aa65abda5d59774630093d7b017384c98" translate="yes" xml:space="preserve">
          <source>An example using a keySelector function</source>
          <target state="translated">keySelector関数を使用した例</target>
        </trans-unit>
        <trans-unit id="b56783c677e083451fb563ec7d3d0942623e25d6" translate="yes" xml:space="preserve">
          <source>An execution context and a data structure to order tasks and schedule their execution. Provides a notion of (potentially virtual) time, through the &lt;code&gt;now()&lt;/code&gt; getter method.</source>
          <target state="translated">タスクを順序付けし、その実行をスケジュールするための実行コンテキストとデータ構造。 &lt;code&gt;now()&lt;/code&gt; ゲッターメソッドを介して（仮想の可能性がある）時間の概念を提供します。</target>
        </trans-unit>
        <trans-unit id="8dd554f8f53b0e7325a2a34d17ed08bf4a5f2f7b" translate="yes" xml:space="preserve">
          <source>An object with &lt;code&gt;addListener&lt;/code&gt; and &lt;code&gt;removeListener&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;addListener&lt;/code&gt; および &lt;code&gt;removeListener&lt;/code&gt; メソッドを持つオブジェクト。</target>
        </trans-unit>
        <trans-unit id="8764ac07674a81492e4055cbd5febfdaa5d400ac" translate="yes" xml:space="preserve">
          <source>An object with &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;off&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; メソッドと &lt;code&gt;off&lt;/code&gt; メソッドを持つオブジェクト</target>
        </trans-unit>
        <trans-unit id="9e40e670213d473533cefd4270f561e8408dc324" translate="yes" xml:space="preserve">
          <source>An observable of notifications to start new windows.</source>
          <target state="translated">新しいウィンドウを起動するための通知のオブザーバブル。</target>
        </trans-unit>
        <trans-unit id="4600b8f07b4000ea590f0835556e6c2afb8552ae" translate="yes" xml:space="preserve">
          <source>An optional argument to define what &lt;code&gt;this&lt;/code&gt; is in the &lt;code&gt;project&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; が &lt;code&gt;project&lt;/code&gt; 関数で何であるかを定義するオプションの引数。</target>
        </trans-unit>
        <trans-unit id="dcc798e4ed4023df36df2945f6d44acbe266748f" translate="yes" xml:space="preserve">
          <source>An optional argument to determine the value of &lt;code&gt;this&lt;/code&gt; in the &lt;code&gt;predicate&lt;/code&gt; function.</source>
          <target state="translated">値を決定するためのオプションの引数 &lt;code&gt;this&lt;/code&gt; 中に &lt;code&gt;predicate&lt;/code&gt; 関数。</target>
        </trans-unit>
        <trans-unit id="0f8b9e0b704b92c65ddc070628f4835bbb78aeac" translate="yes" xml:space="preserve">
          <source>An optional default value to provide if last predicate isn't met or no values were emitted.</source>
          <target state="translated">最後の述語が満たされていなかったり、値が出力されなかったりした場合に提供するオプションのデフォルト値。</target>
        </trans-unit>
        <trans-unit id="e052978179167326c8d61eac34c703447b1e61fb" translate="yes" xml:space="preserve">
          <source>An optional function called with each item to test for condition matching.</source>
          <target state="translated">条件一致をテストするために各項目で呼び出されるオプションの関数。</target>
        </trans-unit>
        <trans-unit id="11fde83a782627f966a91292359ee23e91c0e522" translate="yes" xml:space="preserve">
          <source>An optional function to compare each value pair</source>
          <target state="translated">各値のペアを比較するオプションの関数</target>
        </trans-unit>
        <trans-unit id="44db2f22e6b5dff55846c4998171a7b720c141ea" translate="yes" xml:space="preserve">
          <source>Anatomy of a Test</source>
          <target state="translated">テストの解剖学</target>
        </trans-unit>
        <trans-unit id="d54c716cf2e4abcaf1f883f748f7d86e57c136a9" translate="yes" xml:space="preserve">
          <source>Anatomy of an Observable</source>
          <target state="translated">オブザブルの解剖学</target>
        </trans-unit>
        <trans-unit id="f5680c78958499a16c8fcf9016c85188d194ba63" translate="yes" xml:space="preserve">
          <source>And the output is the same:</source>
          <target state="translated">そして、出力は同じです。</target>
        </trans-unit>
        <trans-unit id="ef4d4c6fb57c79a8162041f226c5e4efb9e26af4" translate="yes" xml:space="preserve">
          <source>And the output is:</source>
          <target state="translated">そしてアウトプットは</target>
        </trans-unit>
        <trans-unit id="2198b9b68b5a6618e09f564fa6fda9a820559da6" translate="yes" xml:space="preserve">
          <source>And this is the same behavior with Observables:</source>
          <target state="translated">そして、これはObservablesと同じ動作です。</target>
        </trans-unit>
        <trans-unit id="214aff037545c6d78b224ab75b946443ebeacca1" translate="yes" xml:space="preserve">
          <source>Animation Frame Scheduler</source>
          <target state="translated">アニメーションフレームスケジューラ</target>
        </trans-unit>
        <trans-unit id="0dd0b75d03698b8df77f879fc79e7a964c400184" translate="yes" xml:space="preserve">
          <source>Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications would be: [1, 2, 1, 2, 3, 4, 5, &lt;code&gt;complete&lt;/code&gt;].</source>
          <target state="translated">ソースのObservableによって発行されたすべてのアイテムは、失敗したサブスクリプション中に発行されたものであっても、結果のObservableによって発行されます。たとえば、Observableが最初は失敗するが[1、2]を発行し、次に2回目に成功して[1、2、3、4、5]を発行する場合、発行と通知の完全なストリームは[1、2]になります。 、1、2、3、4、5、 &lt;code&gt;complete&lt;/code&gt; ]。</target>
        </trans-unit>
        <trans-unit id="d23ece9441868386248d50c2f4a407afa2b6ac2c" translate="yes" xml:space="preserve">
          <source>Any library that imports a patch operator will augment the &lt;code&gt;Observable.prototype&lt;/code&gt; for all consumers of that library, creating blind dependencies. If the library removes their usage, they unknowingly break everyone else. With pipeables, you have to import the operators you need into each file you use them in.</source>
          <target state="translated">パッチオペレーターをインポートするライブラリーは、そのライブラリーのすべてのコンシューマーの &lt;code&gt;Observable.prototype&lt;/code&gt; を拡張して、ブラインド依存関係を作成します。ライブラリが使用を削除すると、無意識のうちに他のすべてのユーザーを破壊します。パイプ可能オブジェクトでは、必要な演算子を、それらを使用する各ファイルにインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="5a9be752cd40fb5aa6726b480b2cc085a184fb0b" translate="yes" xml:space="preserve">
          <source>Any number of Observables provided either as an array or as an arguments passed directly to the operator.</source>
          <target state="translated">配列または演算子に直接渡される引数として提供される任意の数のObservables。</target>
        </trans-unit>
        <trans-unit id="7a81bf5d2d1e477c23e38f5412482a72481c13bc" translate="yes" xml:space="preserve">
          <source>Apart from starting the execution of an Observable, this method allows you to listen for values that an Observable emits, as well as for when it completes or errors. You can achieve this in two of the following ways.</source>
          <target state="translated">このメソッドは、Observableの実行を開始することとは別に、Observableの実行が完了したときやエラーが発生したときに、Observableが発する値をリッスンすることができます。これを実現するには、以下の2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="ff7736e9905851cb4d03cef20435fde04d60ad18" translate="yes" xml:space="preserve">
          <source>Applies a given &lt;code&gt;project&lt;/code&gt; function to each value emitted by the source Observable, and emits the resulting values as an Observable.</source>
          <target state="translated">ソースのObservableによって発行された各値に特定の &lt;code&gt;project&lt;/code&gt; 関数を適用し、結果の値をObservableとして発行します。</target>
        </trans-unit>
        <trans-unit id="fb6220c1b034dd6ba15056fd67c656e6ac8dbc7a" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over the source Observable where the accumulator function itself returns an Observable, then each intermediate Observable returned is merged into the output Observable.</source>
          <target state="translated">アキュムレータ関数を元のObservableに適用し、アキュムレータ関数自身がObservableを返し、返された各中間Observableを出力Observableにマージします。</target>
        </trans-unit>
        <trans-unit id="18af990d85065af126fe49df23d1000d8f9bea14" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over the source Observable, and returns each intermediate result, with an optional seed value.</source>
          <target state="translated">ソースObservableにアキュムレータ関数を適用し、各中間結果をオプションのシード値とともに返します。</target>
        </trans-unit>
        <trans-unit id="896a5a66d1584a3cd0b7ce73ba41aa2daa7bfdd6" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over the source Observable, and returns the accumulated result when the source completes, given an optional seed value.</source>
          <target state="translated">ソースObservableにアキュムレータ関数を適用し、オプションのシード値を指定して、ソースが完了したときに累積結果を返します。</target>
        </trans-unit>
        <trans-unit id="0cbc9507c24ae88b47a008f6d590f27d4404b1b6" translate="yes" xml:space="preserve">
          <source>ArgumentOutOfRangeError</source>
          <target state="translated">ArgumentOutOfRangeError</target>
        </trans-unit>
        <trans-unit id="d06d786204f911793c3c415d554d0f4e76454fb1" translate="yes" xml:space="preserve">
          <source>ArrayLikeObservable</source>
          <target state="translated">ArrayLikeObservable</target>
        </trans-unit>
        <trans-unit id="668878ff5d1e1cf54d4ec1d029de7b2fb934a432" translate="yes" xml:space="preserve">
          <source>ArrayObservable</source>
          <target state="translated">ArrayObservable</target>
        </trans-unit>
        <trans-unit id="66dcfefb4f4c7b689358e87ea28105b7823f1fa7" translate="yes" xml:space="preserve">
          <source>As a matter of fact, &lt;code&gt;observeOn&lt;/code&gt; accepts second parameter, which specifies in milliseconds with what delay notifications will be emitted. The main difference between &lt;a href=&quot;delay&quot;&gt;&lt;code&gt;delay&lt;/code&gt;&lt;/a&gt; operator and &lt;code&gt;observeOn&lt;/code&gt; is that &lt;code&gt;observeOn&lt;/code&gt; will delay all notifications - including error notifications - while &lt;code&gt;delay&lt;/code&gt; will pass through error from source Observable immediately when it is emitted. In general it is highly recommended to use &lt;code&gt;delay&lt;/code&gt; operator for any kind of delaying of values in the stream, while using &lt;code&gt;observeOn&lt;/code&gt; to specify which scheduler should be used for notification emissions in general.</source>
          <target state="translated">実際には、 &lt;code&gt;observeOn&lt;/code&gt; は2番目のパラメーターを受け入れます。これは、ミリ秒単位で、どの遅延通知が発行されるかを指定します。&lt;a href=&quot;delay&quot;&gt; &lt;code&gt;delay&lt;/code&gt; &lt;/a&gt;演算子と &lt;code&gt;observeOn&lt;/code&gt; の主な違いは、 &lt;code&gt;observeOn&lt;/code&gt; はすべての通知（エラー通知を含む）を &lt;code&gt;delay&lt;/code&gt; させますが、遅延は発生時にソースObservableからのエラーをすぐに通過させます。一般に、 &lt;code&gt;observeOn&lt;/code&gt; を使用して通知エミッションに一般に使用する必要があるスケジューラを指定しながら、ストリーム内のあらゆる種類の値の &lt;code&gt;delay&lt;/code&gt; 演算子を使用することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="3d5c716ac8bd96d9826faee7f9bc5e977aad794e" translate="yes" xml:space="preserve">
          <source>As a stylistic matter, &lt;code&gt;op()(obs)&lt;/code&gt; is never used, even if there is only one operator; &lt;code&gt;obs.pipe(op())&lt;/code&gt; is universally preferred.</source>
          <target state="translated">文体的には、演算子が1つしかない場合でも、 &lt;code&gt;op()(obs)&lt;/code&gt; は使用されません。 &lt;code&gt;obs.pipe(op())&lt;/code&gt; が広く推奨されています。</target>
        </trans-unit>
        <trans-unit id="968f7565b22c962aa3c40415db42dac7b144a148" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;bindcallback&quot;&gt;&lt;code&gt;bindCallback&lt;/code&gt;&lt;/a&gt;, context (&lt;code&gt;this&lt;/code&gt; property) of input function will be set to context of returned function, when it is called.</source>
          <target state="translated">&lt;a href=&quot;bindcallback&quot;&gt; &lt;code&gt;bindCallback&lt;/code&gt; &lt;/a&gt;と同様に、入力関数のコンテキスト（ &lt;code&gt;this&lt;/code&gt; プロパティ）は、呼び出されたときに、返された関数のコンテキストに設定されます。</target>
        </trans-unit>
        <trans-unit id="54800d323d149aa9eb668c0c0768a97a0cc7370b" translate="yes" xml:space="preserve">
          <source>Asap Scheduler</source>
          <target state="translated">早期スケジューラ</target>
        </trans-unit>
        <trans-unit id="52a6e3d46a41f66b32f4c8d80361bb3892c5a671" translate="yes" xml:space="preserve">
          <source>Async Scheduler</source>
          <target state="translated">非同期スケジューラ</target>
        </trans-unit>
        <trans-unit id="81a3a332582f8b7c97ecac0a351df1689bfb7637" translate="yes" xml:space="preserve">
          <source>AsyncSubject</source>
          <target state="translated">AsyncSubject</target>
        </trans-unit>
        <trans-unit id="05e4550664a2860277fdca7625b41eb03e1da7ab" translate="yes" xml:space="preserve">
          <source>AsyncSubject._subscribe()</source>
          <target state="translated">AsyncSubject._subscribe()</target>
        </trans-unit>
        <trans-unit id="cdc3490a12008c174af711e0f3ece207778092a8" translate="yes" xml:space="preserve">
          <source>AsyncSubject.complete()</source>
          <target state="translated">AsyncSubject.complete()</target>
        </trans-unit>
        <trans-unit id="7ed8300fc48bbd3e79239add064fa42a036adee5" translate="yes" xml:space="preserve">
          <source>AsyncSubject.error()</source>
          <target state="translated">AsyncSubject.error()</target>
        </trans-unit>
        <trans-unit id="421d4487d1f2f065114b3871b83b0469818575a2" translate="yes" xml:space="preserve">
          <source>AsyncSubject.next()</source>
          <target state="translated">AsyncSubject.next()</target>
        </trans-unit>
        <trans-unit id="1f7d665c10ce012f074c9cbc8a3520a520d0e05d" translate="yes" xml:space="preserve">
          <source>Asynchronously subscribes Observers to this Observable on the specified &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指定された&lt;a href=&quot;../index/interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; で&lt;/a&gt;このオブザーバブルにオブザーバーを非同期的にサブスクライブします。</target>
        </trans-unit>
        <trans-unit id="b422e2c59989bd1e00ff26b3cef6aec5666b0b25" translate="yes" xml:space="preserve">
          <source>At this time the TestScheduler can only be used to test code that uses timers, like delay/debounceTime/etc (i.e. it uses AsyncScheduler with delays &amp;gt; 1). If the code consumes a Promise or does scheduling with AsapScheduler/AnimationFrameScheduler/etc it cannot be reliably tested with TestScheduler, but instead should be tested more traditionally. See the &lt;a href=&quot;marble-testing#known-issues&quot;&gt;Known Issues&lt;/a&gt; section for more details.</source>
          <target state="translated">現時点では、TestSchedulerは、delay / debounceTimeなどのタイマーを使用するコードのテストにのみ使用できます（つまり、delays&amp;gt; 1のAsyncSchedulerを使用します）。コードがPromiseを消費するか、AsapScheduler / AnimationFrameSchedulerなどでスケジューリングを行う場合、TestSchedulerで確実にテストすることはできませんが、代わりに、より伝統的な方法でテストする必要があります。詳細については、&lt;a href=&quot;marble-testing#known-issues&quot;&gt;既知の問題の&lt;/a&gt;セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="068b119ae196b62a5a08d536ca924f4965b8125d" translate="yes" xml:space="preserve">
          <source>Attaches a timestamp to each item emitted by an observable indicating when it was emitted</source>
          <target state="translated">オブザーバブルで放出された各アイテムに、放出された時刻を示すタイムスタンプを付けます。</target>
        </trans-unit>
        <trans-unit id="8fd78925dba59eef91afba0cdabe923520e5ee69" translate="yes" xml:space="preserve">
          <source>Backwards compatibility</source>
          <target state="translated">下位互換性</target>
        </trans-unit>
        <trans-unit id="c8932006bc9fb215b4928a3cadf6c2845e613b82" translate="yes" xml:space="preserve">
          <source>Basic Use</source>
          <target state="translated">基本的な使い方</target>
        </trans-unit>
        <trans-unit id="7308cb8418c068204c128968b5967fdf3606cc09" translate="yes" xml:space="preserve">
          <source>Basic methods</source>
          <target state="translated">基本的な方法</target>
        </trans-unit>
        <trans-unit id="59428be2e125d7f441079c691a9bbee761fe6cb1" translate="yes" xml:space="preserve">
          <source>Because Observable Executions may be infinite, and it's common for an Observer to want to abort execution in finite time, we need an API for canceling an execution. Since each execution is exclusive to one Observer only, once the Observer is done receiving values, it has to have a way to stop the execution, in order to avoid wasting computation power or memory resources.</source>
          <target state="translated">Observable Executionsは無限にある可能性があり、Observerは有限時間内に実行を中止したいと考えるのが一般的なので、実行をキャンセルするためのAPIが必要になります。各実行は1つのオブザーバのみに限定されているため、オブザーバが値を受け取り終わったら、計算パワーやメモリリソースを無駄にしないように、実行を停止する方法が必要です。</target>
        </trans-unit>
        <trans-unit id="3fe58a0f3e937be16a4d3adc3bbcdc21e755f616" translate="yes" xml:space="preserve">
          <source>Because RxJS uses the least concurrency scheduler, you can pick a different scheduler if you want to introduce concurrency for performance purpose. To specify a particular scheduler, you can use those operator methods that take a scheduler, e.g., &lt;code&gt;from([10, 20, 30], asyncScheduler)&lt;/code&gt;.</source>
          <target state="translated">RxJSは最小並行性スケジューラーを使用するため、パフォーマンス目的で並行性を導入したい場合は、別のスケジューラーを選択できます。特定のスケジューラーを指定するには、 &lt;code&gt;from([10, 20, 30], asyncScheduler)&lt;/code&gt; ように、スケジューラーを取るオペレーターメソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="86af633db829662420c6a9d8694edaad1afb49df" translate="yes" xml:space="preserve">
          <source>Before RxJS release v7, you will need to remove and replace all use of &lt;a href=&quot;migration#deprecations&quot;&gt;deprecated functionality&lt;/a&gt;.</source>
          <target state="translated">RxJSリリースv7より前のバージョンでは、&lt;a href=&quot;migration#deprecations&quot;&gt;廃止された機能の&lt;/a&gt;すべての使用を削除して置き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="6910ad273ef167a843b9c22fe90ab4067b73a2e7" translate="yes" xml:space="preserve">
          <source>Before RxJS releases v7, you will need to remove and replace all use of deprecated functionality. The following areas contain deprecated functionality:</source>
          <target state="translated">RxJSがv7をリリースする前に、非推奨の機能をすべて削除して置き換える必要があります。以下の領域に非推奨の機能が含まれています。</target>
        </trans-unit>
        <trans-unit id="80a472e92e169440db08c5cb53e9880fe704c6ac" translate="yes" xml:space="preserve">
          <source>Before converting dot-chained operators to pipeable operators, make sure you import all operators used from &lt;code&gt;rxjs/operators&lt;/code&gt;. For example:</source>
          <target state="translated">ドットチェーン演算子をパイプ可能な演算子に変換する前に、 &lt;code&gt;rxjs/operators&lt;/code&gt; から使用されるすべての演算子をインポートしていることを確認してください。例えば：</target>
        </trans-unit>
        <trans-unit id="5427d9bbbb297506a892f764b0a10b1efb9ef3e2" translate="yes" xml:space="preserve">
          <source>Before you can remove the compatibility layer, you must refactor your code to use only pipeable operators. For Typescript, the &lt;code&gt;tslint&lt;/code&gt; tool automates the process to some extent, by applying the transform to well-typed code.</source>
          <target state="translated">互換性レイヤーを削除する前に、パイプ可能な演算子のみを使用するようにコードをリファクタリングする必要があります。 &lt;code&gt;tslint&lt;/code&gt; 場合、tslintツールは、適切に入力されたコードに変換を適用することにより、プロセスをある程度自動化します。</target>
        </trans-unit>
        <trans-unit id="5cb66fd20ca03a58764710f01cf907abc931d1ec" translate="yes" xml:space="preserve">
          <source>Behavior is different outside of &lt;code&gt;testScheduler.run(callback)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;testScheduler.run(callback)&lt;/code&gt; 外では動作が異なります</target>
        </trans-unit>
        <trans-unit id="368c978e94ba7ae5d0f5a362fef744af7dd7667e" translate="yes" xml:space="preserve">
          <source>BehaviorSubject</source>
          <target state="translated">BehaviorSubject</target>
        </trans-unit>
        <trans-unit id="09fcd7eca9f3082eeb05a34f8c6c349c912eacc6" translate="yes" xml:space="preserve">
          <source>BehaviorSubject._subscribe()</source>
          <target state="translated">BehaviorSubject._subscribe()</target>
        </trans-unit>
        <trans-unit id="656e17240ff3b7b269f8e9c364cfb41b688c27b5" translate="yes" xml:space="preserve">
          <source>BehaviorSubject.getValue()</source>
          <target state="translated">BehaviorSubject.getValue()</target>
        </trans-unit>
        <trans-unit id="2f226a2a37d46000d57385a4e6bc7b2abbb68c8b" translate="yes" xml:space="preserve">
          <source>BehaviorSubject.next()</source>
          <target state="translated">BehaviorSubject.next()</target>
        </trans-unit>
        <trans-unit id="df8979ce02d450847fa09bc10fa2a8741c7eea06" translate="yes" xml:space="preserve">
          <source>BehaviorSubjects are useful for representing &quot;values over time&quot;. For instance, an event stream of birthdays is a Subject, but the stream of a person's age would be a BehaviorSubject.</source>
          <target state="translated">BehaviorSubjectは「時間の経過とともに変化する値」を表現するのに便利です。例えば、誕生日のイベントストリームはSubjectですが、人の年齢のストリームはBehaviorSubjectになります。</target>
        </trans-unit>
        <trans-unit id="3a70d04c1ef62c14933cff1c5df6d13ef6a06dc8" translate="yes" xml:space="preserve">
          <source>Below is an example:</source>
          <target state="translated">以下、一例です。</target>
        </trans-unit>
        <trans-unit id="30731caf412562ba61e98248292d79cfc45fd636" translate="yes" xml:space="preserve">
          <source>Below you can see the anatomy of a marble diagram.</source>
          <target state="translated">下に大理石の解剖図があります。</target>
        </trans-unit>
        <trans-unit id="ca1c302c34fc031ab37087b438ad1e0215b218b0" translate="yes" xml:space="preserve">
          <source>Both Observable &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; will emit their values directly and synchronously once they are subscribed to. This will result in the output of &lt;code&gt;1 2 3 4 5 6 7 8 9&lt;/code&gt;.</source>
          <target state="translated">Observable &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; の両方は、サブスクライブされると、それらの値を直接かつ同期的に発行します。これにより、 &lt;code&gt;1 2 3 4 5 6 7 8 9&lt;/code&gt; が出力されます。</target>
        </trans-unit>
        <trans-unit id="9cb922bf8af8668272484b70ff6096a26125cc4f" translate="yes" xml:space="preserve">
          <source>Both forms of &lt;code&gt;generate&lt;/code&gt; can optionally accept a scheduler. In case of multi-parameter call, scheduler simply comes as a last argument (no matter if there is resultSelector function or not). In case of single-parameter call, you can provide it as a &lt;code&gt;scheduler&lt;/code&gt; property on object passed to the operator. In both cases scheduler decides when next iteration of the loop will happen and therefore when next value will be emitted by the Observable. For example to ensure that each value is pushed to the observer on separate task in event loop, you could use &lt;code&gt;async&lt;/code&gt; scheduler. Note that by default (when no scheduler is passed) values are simply emitted synchronously.</source>
          <target state="translated">どちらの形式の &lt;code&gt;generate&lt;/code&gt; も、オプションでスケジューラを受け入れることができます。マルチパラメーター呼び出しの場合、スケジューラーは単に（resultSelector関数があるかどうかに関係なく）最後の引数になります。単一パラメーター呼び出しの場合、オペレーターに渡されるオブジェクトの &lt;code&gt;scheduler&lt;/code&gt; プロパティーとして提供できます。どちらの場合でも、スケジューラーはループの次の反復がいつ発生するか、したがって、次の値がObservableによっていつ発行されるかを決定します。たとえば、各値がイベントループの個別のタスクでオブザーバーに確実にプッシュされるようにするには、 &lt;code&gt;async&lt;/code&gt; スケジューラーを使用できます。デフォルトでは（スケジューラーが渡されない場合）、値は単に同期的に発行されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5f36985eed9db6051e472734cab05c794944ca1d" translate="yes" xml:space="preserve">
          <source>BoundCallbackObservable</source>
          <target state="translated">BoundCallbackObservable</target>
        </trans-unit>
        <trans-unit id="7ed5f49381a89f00035a1e54c238c08417cd22c7" translate="yes" xml:space="preserve">
          <source>BoundNodeCallbackObservable</source>
          <target state="translated">BoundNodeCallbackObservable</target>
        </trans-unit>
        <trans-unit id="0d8754ad2d4f272c021b8a6de30806cf10b10891" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable periodically in time.</source>
          <target state="translated">ソースObservableの値を時間的に定期的にネストされたObservableとして分岐させます。</target>
        </trans-unit>
        <trans-unit id="d5768cefc3dc6135e746fa10e7dc64978cd8c7d2" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable starting from an emission from &lt;code&gt;openings&lt;/code&gt; and ending when the output of &lt;code&gt;closingSelector&lt;/code&gt; emits.</source>
          <target state="translated">ソースのObservable値をネストされたObservableとして分岐し、 &lt;code&gt;openings&lt;/code&gt; からの放出から始まり、 &lt;code&gt;closingSelector&lt;/code&gt; の出力が放出されるときに終了します。</target>
        </trans-unit>
        <trans-unit id="2f875199af965263013c9045ea52ec0e0f71c9b4" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable using a factory function of closing Observables to determine when to start a new window.</source>
          <target state="translated">新しいウィンドウをいつ開始するかを決定するためにObservableを閉じるファクトリー機能を使用して、ソースObservableの値を入れ子になったObservableとして分岐させます。</target>
        </trans-unit>
        <trans-unit id="d41ca8a818abab5874a4f5707cd8909fc3d690c8" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable whenever &lt;code&gt;windowBoundaries&lt;/code&gt; emits.</source>
          <target state="translated">&lt;code&gt;windowBoundaries&lt;/code&gt; が発行するたびに、ネストされたObservableとしてソースObservable値を分岐します。</target>
        </trans-unit>
        <trans-unit id="5c9602d8a405448b7a2d3de72389356d74e29054" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable with each nested Observable emitting at most &lt;code&gt;windowSize&lt;/code&gt; values.</source>
          <target state="translated">ソースのObservable値をネストされたObservableとして分岐し、ネストされた各Observableが最大で &lt;code&gt;windowSize&lt;/code&gt; 値を放出します。</target>
        </trans-unit>
        <trans-unit id="a75f48b1b22b879f9c22d646edaa0759db697611" translate="yes" xml:space="preserve">
          <source>Breaking changes not covered by rxjs-compat</source>
          <target state="translated">rxjs-compat でカバーされていない変更を壊す</target>
        </trans-unit>
        <trans-unit id="91726b714dab75ed3b7d092c95de02bacf38fad2" translate="yes" xml:space="preserve">
          <source>Buffers a number of values from the source Observable by &lt;code&gt;bufferSize&lt;/code&gt; then emits the buffer and clears it, and starts a new buffer each &lt;code&gt;startBufferEvery&lt;/code&gt; values. If &lt;code&gt;startBufferEvery&lt;/code&gt; is not provided or is &lt;code&gt;null&lt;/code&gt;, then new buffers are started immediately at the start of the source and when each buffer closes and is emitted.</source>
          <target state="translated">&lt;code&gt;bufferSize&lt;/code&gt; によってObservableのソースからいくつかの値をバッファリングし、次にバッファを発行してそれをクリアし、 &lt;code&gt;startBufferEvery&lt;/code&gt; 値ごとに新しいバッファを開始します。場合 &lt;code&gt;startBufferEvery&lt;/code&gt; が提供またはされないが &lt;code&gt;null&lt;/code&gt; の場合、新しいバッファは、ソースの開始時に即座に開始され、各バッファが閉じ、放出されたとき。</target>
        </trans-unit>
        <trans-unit id="45860b887da4c0323bdef83a3c8f9aa2573f347f" translate="yes" xml:space="preserve">
          <source>Buffers the incoming Observable values until the given &lt;code&gt;closingNotifier&lt;/code&gt; Observable emits a value, at which point it emits the buffer on the output Observable and starts a new buffer internally, awaiting the next time &lt;code&gt;closingNotifier&lt;/code&gt; emits.</source>
          <target state="translated">指定された &lt;code&gt;closingNotifier&lt;/code&gt; Observableが値を発行するまで、着信Observable値をバッファリングします。この時点で、出力Observableでバッファを &lt;code&gt;closingNotifier&lt;/code&gt; 、内部で新しいバッファを開始して、次にcloseNotNotifierが発行されるのを待ちます。</target>
        </trans-unit>
        <trans-unit id="15d7d3de47ff61c82d143794cb6ccfc5db3c977c" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values for a specific time period.</source>
          <target state="translated">特定の期間のソースObservable値をバッファリングします。</target>
        </trans-unit>
        <trans-unit id="24cf8cc6ee5fcd728d08f9677bba84affa9b2ed5" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values starting from an emission from &lt;code&gt;openings&lt;/code&gt; and ending when the output of &lt;code&gt;closingSelector&lt;/code&gt; emits.</source>
          <target state="translated">&lt;code&gt;openings&lt;/code&gt; からの放出から始まり、 &lt;code&gt;closingSelector&lt;/code&gt; の出力が放出されるときに終了するソースのObservable値をバッファリングします。</target>
        </trans-unit>
        <trans-unit id="5667b07dfc95ab11889cc351c1f1a6450c22be83" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values until &lt;code&gt;closingNotifier&lt;/code&gt; emits.</source>
          <target state="translated">&lt;code&gt;closingNotifier&lt;/code&gt; するまで、ソースのObservable値をバッファリングします。</target>
        </trans-unit>
        <trans-unit id="aa0cc84b678395e32b914e69c26a7d621ee5a670" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values until the size hits the maximum &lt;code&gt;bufferSize&lt;/code&gt; given.</source>
          <target state="translated">サイズが指定された最大の &lt;code&gt;bufferSize&lt;/code&gt; に達するまで、ソースのObservable値をバッファリングします。</target>
        </trans-unit>
        <trans-unit id="03884c4fb7d2e362201a4108c8ca60b6bfb2b71f" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values, using a factory function of closing Observables to determine when to close, emit, and reset the buffer.</source>
          <target state="translated">ソースのObservableの値をバッファリングし、Observableを閉じるファクトリー機能を使用して、バッファを閉じる、放出する、リセットするタイミングを決定します。</target>
        </trans-unit>
        <trans-unit id="eb04a2297b04b37862c0441dd71728bd5ba4a23a" translate="yes" xml:space="preserve">
          <source>Buffers values from the source by opening the buffer via signals from an Observable provided to &lt;code&gt;openings&lt;/code&gt;, and closing and sending the buffers when a Subscribable or Promise returned by the &lt;code&gt;closingSelector&lt;/code&gt; function emits.</source>
          <target state="translated">&lt;code&gt;closingSelector&lt;/code&gt; 提供されたObservableからの信号を介してバッファを &lt;code&gt;openings&lt;/code&gt; 、closeingSelector関数によって返されたSubscribableまたはPromiseが発行されたときにバッファを閉じて送信することにより、ソースからの値をバッファします。</target>
        </trans-unit>
        <trans-unit id="12d7e4a57d8db25980df2b5e57d6a44630d2bef0" translate="yes" xml:space="preserve">
          <source>Buffers values from the source for a specific time duration &lt;code&gt;bufferTimeSpan&lt;/code&gt;. Unless the optional argument &lt;code&gt;bufferCreationInterval&lt;/code&gt; is given, it emits and resets the buffer every &lt;code&gt;bufferTimeSpan&lt;/code&gt; milliseconds. If &lt;code&gt;bufferCreationInterval&lt;/code&gt; is given, this operator opens the buffer every &lt;code&gt;bufferCreationInterval&lt;/code&gt; milliseconds and closes (emits and resets) the buffer every &lt;code&gt;bufferTimeSpan&lt;/code&gt; milliseconds. When the optional argument &lt;code&gt;maxBufferSize&lt;/code&gt; is specified, the buffer will be closed either after &lt;code&gt;bufferTimeSpan&lt;/code&gt; milliseconds or when it contains &lt;code&gt;maxBufferSize&lt;/code&gt; elements.</source>
          <target state="translated">特定の期間 &lt;code&gt;bufferTimeSpan&lt;/code&gt; のソースからの値をバッファリングします。オプションの引数 &lt;code&gt;bufferCreationInterval&lt;/code&gt; が指定されていない限り、それは &lt;code&gt;bufferTimeSpan&lt;/code&gt; ミリ秒ごとにバッファを発行およびリセットします。 &lt;code&gt;bufferCreationInterval&lt;/code&gt; が指定されている場合、このオペレーターは &lt;code&gt;bufferCreationInterval&lt;/code&gt; ミリ秒ごとにバッファーを開き、 &lt;code&gt;bufferTimeSpan&lt;/code&gt; ミリ秒ごとにバッファーを閉じます（エミットおよびリセット）。オプションの引数 &lt;code&gt;maxBufferSize&lt;/code&gt; が指定されている場合、バッファーは &lt;code&gt;bufferTimeSpan&lt;/code&gt; ミリ秒後、または &lt;code&gt;maxBufferSize&lt;/code&gt; 要素が含まれているときに閉じられます。</target>
        </trans-unit>
        <trans-unit id="2ab13858e624370f0f64b6c332c7f2614bc328c2" translate="yes" xml:space="preserve">
          <source>Build Your Own Operators Easily</source>
          <target state="translated">独自のオペレータを簡単に構築</target>
        </trans-unit>
        <trans-unit id="676f6ca72b7ceddfaefe05b718ec94fe4ee584db" translate="yes" xml:space="preserve">
          <source>Build and Treeshaking</source>
          <target state="translated">ビルドとツリーシェイク</target>
        </trans-unit>
        <trans-unit id="fbdb16ef0c14df9ae818c34fde6140cc17ebec29" translate="yes" xml:space="preserve">
          <source>But how do you work with a higher-order Observable? Typically, by &lt;em&gt;flattening&lt;/em&gt;: by (somehow) converting a higher-order Observable into an ordinary Observable. For example:</source>
          <target state="translated">しかし、高次のObservableをどのように操作しますか？通常は、&lt;em&gt;フラット化&lt;/em&gt;することにより、（何らかの形で）高次のObservableを通常のObservableに変換します。例えば：</target>
        </trans-unit>
        <trans-unit id="81261945285e1f2fcd2cb9624774cb27067692f5" translate="yes" xml:space="preserve">
          <source>But if we instead us the &lt;code&gt;subscribeOn&lt;/code&gt; operator declaring that we want to use the &lt;a href=&quot;../index/const/asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; for values emited by Observable &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">しかし、代わりに、Observable &lt;code&gt;a&lt;/code&gt; によって発行された値に&lt;a href=&quot;../index/const/asyncscheduler&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt;を使用することを宣言する &lt;code&gt;subscribeOn&lt;/code&gt; 演算子を使用する場合：</target>
        </trans-unit>
        <trans-unit id="e6d6e0552657f23eb778d7b0e73b6e76e73ea9a7" translate="yes" xml:space="preserve">
          <source>But you can also &quot;return&quot; values asynchronously:</source>
          <target state="translated">しかし、値を非同期に「返す」こともできます。</target>
        </trans-unit>
        <trans-unit id="f90e5f831e73c22e973a350195d169a635741751" translate="yes" xml:space="preserve">
          <source>By default these arrays are emitted synchronously. To change that you can pass a &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; as a second argument to &lt;code&gt;pairs&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、これらの配列は同期的に発行されます。これを変更するには、&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;pairs&lt;/code&gt; 2番目の引数として渡します。</target>
        </trans-unit>
        <trans-unit id="ab95b076b9a889a20adbe974f689337a0938a989" translate="yes" xml:space="preserve">
          <source>By default, results passed to the callback are emitted immediately after &lt;code&gt;func&lt;/code&gt; invokes the callback. In particular, if the callback is called synchronously, then the subscription of the resulting Observable will call the &lt;code&gt;next&lt;/code&gt; function synchronously as well. If you want to defer that call, you may use &lt;a href=&quot;../const/asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; just as before. This means that by using &lt;code&gt;Scheduler.async&lt;/code&gt; you can ensure that &lt;code&gt;func&lt;/code&gt; always calls its callback asynchronously, thus avoiding terrifying Zalgo.</source>
          <target state="translated">デフォルトでは、コールバックに渡された結果は、 &lt;code&gt;func&lt;/code&gt; がコールバックを呼び出した直後に発行されます。特に、コールバックが同期的に呼び出される場合、結果のObservableのサブスクリプションは &lt;code&gt;next&lt;/code&gt; 関数も同期的に呼び出します。その呼び出しを延期したい場合は、以前と同じように&lt;a href=&quot;../const/asyncscheduler&quot;&gt; &lt;code&gt;async&lt;/code&gt; を&lt;/a&gt;使用できます。つまり、 &lt;code&gt;Scheduler.async&lt;/code&gt; を使用することで、 &lt;code&gt;func&lt;/code&gt; が常にコールバックを非同期に呼び出すことができるため、Zalgoの恐怖を回避できます。</target>
        </trans-unit>
        <trans-unit id="2f3c24c0b8ca48e155030e9400fba049ed478537" translate="yes" xml:space="preserve">
          <source>By not passing any scheduler, notifications are delivered synchronously and recursively. Use this for constant-time operations or tail recursive operations.</source>
          <target state="translated">スケジューラを渡さないことで、通知は同期的に再帰的に配信されます。これは、一定時間操作や最後尾の再帰的操作に使用します。</target>
        </trans-unit>
        <trans-unit id="511c31182dd5c650c4510a3c0301a11cadc8c586" translate="yes" xml:space="preserve">
          <source>By virtue of being a &lt;a href=&quot;../index/class/subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;WebSocketSubject&lt;/code&gt; allows for receiving and sending messages from the server. In order to communicate with a connected endpoint, use &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt; methods. &lt;code&gt;next&lt;/code&gt; sends a value to the server, so bear in mind that this value will not be serialized beforehand. Because of This, &lt;code&gt;JSON.stringify&lt;/code&gt; will have to be called on a value by hand, before calling &lt;code&gt;next&lt;/code&gt; with a result. Note also that if at the moment of nexting value there is no socket connection (for example no one is subscribing), those values will be buffered, and sent when connection is finally established. &lt;code&gt;complete&lt;/code&gt; method closes socket connection. &lt;code&gt;error&lt;/code&gt; does the same, as well as notifying the server that something went wrong via status code and string with details of what happened. Since status code is required in WebSocket API, &lt;code&gt;WebSocketSubject&lt;/code&gt; does not allow, like regular &lt;code&gt;Subject&lt;/code&gt;, arbitrary values being passed to the &lt;code&gt;error&lt;/code&gt; method. It needs to be called with an object that has &lt;code&gt;code&lt;/code&gt; property with status code number and optional &lt;code&gt;reason&lt;/code&gt; property with string describing details of an error.</source>
          <target state="translated">ことによって&lt;a href=&quot;../index/class/subject&quot;&gt; &lt;code&gt;Subject&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;WebSocketSubject&lt;/code&gt; がサーバからメッセージを受信し、送信することを可能にします。接続されたエンドポイントと通信するには、 &lt;code&gt;next&lt;/code&gt; 、 &lt;code&gt;error&lt;/code&gt; 、および &lt;code&gt;complete&lt;/code&gt; メソッドを使用します。 &lt;code&gt;next&lt;/code&gt; 、サーバーに値を送信するため、この値は事前にシリアル化されないことに注意してください。このため、 &lt;code&gt;JSON.stringify&lt;/code&gt; は、 &lt;code&gt;next&lt;/code&gt; の結果を呼び出す前に、手動で値を呼び出す必要があります。次の値の時点でソケット接続がない場合（たとえば、誰もサブスクライブしていない場合）、それらの値はバッファーに入れられ、接続が最終的に確立されたときに送信されることにも注意してください。 &lt;code&gt;complete&lt;/code&gt; メソッドはソケット接続を閉じます。 &lt;code&gt;error&lt;/code&gt; は同じことをするだけでなく、何が起こったかの詳細を含むステータスコードと文字列を介して何かがうまくいかなかったことをサーバーに通知します。 WebSocket APIではステータスコードが必要なため、 &lt;code&gt;WebSocketSubject&lt;/code&gt; では、通常の &lt;code&gt;Subject&lt;/code&gt; と同様に、 &lt;code&gt;error&lt;/code&gt; メソッドに任意の値を渡すことはできません。ステータスコード番号を含む &lt;code&gt;code&lt;/code&gt; プロパティと、エラーの詳細を説明する文字列を含むオプションの &lt;code&gt;reason&lt;/code&gt; プロパティを持つオブジェクトで呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="67b6c4b8addee6f0bec9b64fdc066f75fd594e81" translate="yes" xml:space="preserve">
          <source>CDN</source>
          <target state="translated">CDN</target>
        </trans-unit>
        <trans-unit id="2c85a73cd12db61768b9bb19ea9828e95032a59a" translate="yes" xml:space="preserve">
          <source>COMPLETE</source>
          <target state="translated">COMPLETE</target>
        </trans-unit>
        <trans-unit id="4590aa62874fd7b9a9997615d2263d8941afd9c2" translate="yes" xml:space="preserve">
          <source>Callback for errors in the source.</source>
          <target state="translated">ソースのエラーのためのコールバック。</target>
        </trans-unit>
        <trans-unit id="2a398f7106ab8cbcc00f7e0b623031a44b27c4c0" translate="yes" xml:space="preserve">
          <source>Callback for the completion of the source.</source>
          <target state="translated">ソースの完成のためのコールバック。</target>
        </trans-unit>
        <trans-unit id="6bc9d59a54f34bf3e88d0a22203ceafb349998a2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;connect()&lt;/code&gt; manually and handling the Subscription is often cumbersome. Usually, we want to &lt;em&gt;automatically&lt;/em&gt; connect when the first Observer arrives, and automatically cancel the shared execution when the last Observer unsubscribes.</source>
          <target state="translated">多くの場合、 &lt;code&gt;connect()&lt;/code&gt; を手動で呼び出してサブスクリプションを処理するのは面倒です。通常、最初のオブザーバーが到着すると&lt;em&gt;自動的に&lt;/em&gt;接続し、最後のオブザーバーがサブスクライブを解除すると共有実行を自動的にキャンセルします。</target>
        </trans-unit>
        <trans-unit id="cac74e4863ea82589bf37f274214232a2020fde7" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;next&lt;/code&gt; does not affect subscribers of &lt;code&gt;WebSocketSubject&lt;/code&gt; - they have no information that something was sent to the server (unless of course the server responds somehow to a message). On the other hand, since calling &lt;code&gt;complete&lt;/code&gt; triggers an attempt to close socket connection. If that connection is closed without any errors, stream will complete, thus notifying all subscribers. And since calling &lt;code&gt;error&lt;/code&gt; closes socket connection as well, just with a different status code for the server, if closing itself proceeds without errors, subscribed Observable will not error, as one might expect, but complete as usual. In both cases (calling &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;), if process of closing socket connection results in some errors, &lt;em&gt;then&lt;/em&gt; stream will error.</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; を呼び出しても &lt;code&gt;WebSocketSubject&lt;/code&gt; のサブスクライバーには影響しません-サーバーに何かが送信されたという情報はありません（もちろん、サーバーが何らかの方法でメッセージに応答しない限り）。一方、 &lt;code&gt;complete&lt;/code&gt; を呼び出すと、ソケット接続を閉じる試みがトリガーされます。その接続がエラーなしで閉じられると、ストリームが完了し、すべてのサブスクライバーに通知されます。また、 &lt;code&gt;error&lt;/code&gt; 呼び出すと、サーバーのステータスコードが異なるだけでソケット接続も閉じるため、エラーなしでそれ自体を閉じると、サブスクライブされたObservableはエラーにならず、通常どおり完了します。どちらの場合も（calling &lt;code&gt;complete&lt;/code&gt; または &lt;code&gt;error&lt;/code&gt; ）、いくつかのエラーでソケット接続結果を閉じる工程と、&lt;em&gt;次いで、&lt;/em&gt;ストリームがエラーであろう。</target>
        </trans-unit>
        <trans-unit id="935e0374fc62004171fd85c905965758a1891c08" translate="yes" xml:space="preserve">
          <source>Cancel a subscription</source>
          <target state="translated">購読をキャンセルする</target>
        </trans-unit>
        <trans-unit id="9d1e2f3e476609e344df33a8265f591eb579afca" translate="yes" xml:space="preserve">
          <source>Catches errors on the observable to be handled by returning a new observable or throwing an error.</source>
          <target state="translated">新しいオブザーバブルを返すか、エラーを投げることで、処理されるオブザーバブルのエラーをキャッチします。</target>
        </trans-unit>
        <trans-unit id="40e6c757452db48cd925951cfe7eef7f22c5e862" translate="yes" xml:space="preserve">
          <source>Categories of operators</source>
          <target state="translated">演算子のカテゴリ</target>
        </trans-unit>
        <trans-unit id="bf247e16c63f07775f0becbb509d151d49677413" translate="yes" xml:space="preserve">
          <source>Change at runtime which Observable will be subscribed</source>
          <target state="translated">どのObservableをサブスクライブするかを実行時に変更します。</target>
        </trans-unit>
        <trans-unit id="acddfe6e0f84690d12ae8d6dba931938820b0320" translate="yes" xml:space="preserve">
          <source>Check if ticks are emitted within certain timespan</source>
          <target state="translated">一定時間内にダニが出るかどうかをチェック</target>
        </trans-unit>
        <trans-unit id="4180596115cf7ecf0a22e17994523dc7e25709ef" translate="yes" xml:space="preserve">
          <source>Checks to see of all values emitted by both observables are equal, in order.</source>
          <target state="translated">両方の観測値が全て等しいかどうかを順番にチェックします。</target>
        </trans-unit>
        <trans-unit id="3c6f0a9d624ec81db524dbe06b9e088e944f553b" translate="yes" xml:space="preserve">
          <source>Child Interfaces</source>
          <target state="translated">子インターフェース</target>
        </trans-unit>
        <trans-unit id="92a715716ffdf82ae0698aa576184e0fd68dee01" translate="yes" xml:space="preserve">
          <source>Class Implementations</source>
          <target state="translated">クラスの実装</target>
        </trans-unit>
        <trans-unit id="92adf227123fe3164559c8b57554084d078adbb1" translate="yes" xml:space="preserve">
          <source>Classes that operate on observables have been replaced by functions.</source>
          <target state="translated">観測値を操作するクラスは、関数に置き換えられました。</target>
        </trans-unit>
        <trans-unit id="f56986343e465f67e4ade9b4d5003bb79270d98a" translate="yes" xml:space="preserve">
          <source>Code licensed under an Apache-2.0 License. Documentation licensed under CC BY 4.0.</source>
          <target state="translated">コードは Apache-2.0 ライセンスの下でライセンスされています。ドキュメントはCC BY 4.0ライセンスでライセンスされています。</target>
        </trans-unit>
        <trans-unit id="264398069882e7753347718021d0c9c51b7ce8fc" translate="yes" xml:space="preserve">
          <source>Code of Conduct</source>
          <target state="translated">行動規範</target>
        </trans-unit>
        <trans-unit id="bff53ee5bce91f6e48134eda698e59b8359d48bf" translate="yes" xml:space="preserve">
          <source>Collects all source emissions and emits them as an array when the source completes.</source>
          <target state="translated">すべてのソースの排出を収集し、ソースが完了したときに配列として排出します。</target>
        </trans-unit>
        <trans-unit id="a87c4457cd65817173f42a58e3b056f94792975c" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array, and emits that array only when another Observable emits.</source>
          <target state="translated">過去の値を配列として収集し、別のObservableが放出するときだけその配列を放出します。</target>
        </trans-unit>
        <trans-unit id="84e5c2c56ccc76a9cf62fb80908721c69ede86cf" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array, and emits that array only when its size reaches &lt;code&gt;bufferSize&lt;/code&gt;.</source>
          <target state="translated">過去の値を配列として収集し、そのサイズが &lt;code&gt;bufferSize&lt;/code&gt; に達した場合にのみその配列を出力します。</target>
        </trans-unit>
        <trans-unit id="dcb48d99f7461fdace8881995c945f640d453091" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array, and emits those arrays periodically in time.</source>
          <target state="translated">過去の値を配列として収集し、それらの配列を時間的に定期的に放出します。</target>
        </trans-unit>
        <trans-unit id="a28d40eb03d856d357a7a6d8bf9631fe8ab94554" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array. Starts collecting only when &lt;code&gt;opening&lt;/code&gt; emits, and calls the &lt;code&gt;closingSelector&lt;/code&gt; function to get an Observable that tells when to close the buffer.</source>
          <target state="translated">過去の値を配列として収集します。開始は、ときにのみ収集 &lt;code&gt;opening&lt;/code&gt; 発し、呼び出す &lt;code&gt;closingSelector&lt;/code&gt; のバッファを閉じるようにするとき告げる観測を取得する機能を。</target>
        </trans-unit>
        <trans-unit id="4b8aa081fb705436429dff9d465de035e7e62f11" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array. When it starts collecting values, it calls a function that returns an Observable that tells when to close the buffer and restart collecting.</source>
          <target state="translated">過去の値を配列として収集します。値の収集を開始すると、バッファを閉じて収集を再開するタイミングを指示するObservableを返す関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="16dc60a0adf13d9db9d55f345c909d25f48d7dd5" translate="yes" xml:space="preserve">
          <source>Combine age and name from different sources</source>
          <target state="translated">異なるソースから年齢と名前を組み合わせる</target>
        </trans-unit>
        <trans-unit id="ddcd6864d0909fbc11124756a02fcda077e9eee9" translate="yes" xml:space="preserve">
          <source>Combine an array of Observables</source>
          <target state="translated">Observablesの配列を組み合わせる</target>
        </trans-unit>
        <trans-unit id="3290c60aa41ac81295b37ea06bcc86ce998efa56" translate="yes" xml:space="preserve">
          <source>Combine two timer Observables</source>
          <target state="translated">2つのタイマーを組み合わせる Observables</target>
        </trans-unit>
        <trans-unit id="d89a0d96a043bd7133e0dc51016f7f120ae0eaae" translate="yes" xml:space="preserve">
          <source>Combines multiple Observables to create an Observable whose values are calculated from the latest values of each of its input Observables.</source>
          <target state="translated">複数のObservableを組み合わせて、それぞれの入力Observableの最新の値から計算された値を持つObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="7db2a4e0664e1e1247e446b34d85228f39aa98c1" translate="yes" xml:space="preserve">
          <source>Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each of its input Observables.</source>
          <target state="translated">複数のObservableを組み合わせて、入力Observableの値から順に計算された値を持つObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="a94b90034171278929060f4c02c4d77ccd4193cc" translate="yes" xml:space="preserve">
          <source>Combines the source Observable with other Observables to create an Observable whose values are calculated from the latest values of each, only when the source emits.</source>
          <target state="translated">ソースのObservableと他のObservableを組み合わせて、ソースが発光したときだけ、それぞれの最新の値から値が計算されるObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="5b0baff3ec7a8c1314bf1adf98ac28a48a1e9524" translate="yes" xml:space="preserve">
          <source>Combines together all values emitted on the source, using an accumulator function that knows how to join a new source value into the accumulation from the past.</source>
          <target state="translated">新しいソース値を過去からの蓄積に結合する方法を知っているアキュムレータ機能を使用して、ソース上に放出されたすべての値を結合します。</target>
        </trans-unit>
        <trans-unit id="b2cd10bda67f3c2a0db363c783f1be790f5f461a" translate="yes" xml:space="preserve">
          <source>Combines together all values emitted on the source, using an accumulator function that knows how to join a new source value into the accumulation from the past. Is similar to &lt;a href=&quot;reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but emits the intermediate accumulations.</source>
          <target state="translated">新しいソース値を過去の累積に結合する方法を知っているアキュムレータ関数を使用して、ソースで放出されたすべての値を結合します。&lt;a href=&quot;reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;に似ていますが、中間の蓄積を放出します。</target>
        </trans-unit>
        <trans-unit id="d9a3849cfa8277187bcfd6ad0b01e4f8005b9aaf" translate="yes" xml:space="preserve">
          <source>CommonJS via npm</source>
          <target state="translated">npm経由のCommonJS</target>
        </trans-unit>
        <trans-unit id="d4d22effb8cb3b670cec35ed783a128ce947ac0a" translate="yes" xml:space="preserve">
          <source>Compare async and asap scheduler&amp;lt;</source>
          <target state="translated">非同期スケジューラとasapスケジューラを比較する&amp;lt;</target>
        </trans-unit>
        <trans-unit id="7435cdb2b01945189354f363a0421a39f3cd8faa" translate="yes" xml:space="preserve">
          <source>Compare behaviour with and without async Scheduler</source>
          <target state="translated">非同期スケジューラの有無による挙動の比較</target>
        </trans-unit>
        <trans-unit id="ea2fd62aaac1214e57e275acea20cefc00fdc055" translate="yes" xml:space="preserve">
          <source>Compares all values of two observables in sequence using an optional comparator function and returns an observable of a single boolean value representing whether or not the two sequences are equal.</source>
          <target state="translated">オプションのコンパレータ関数を使用して、2つの観測値のすべての値を順番に比較し、2つのシーケンスが等しいかどうかを表す1つのブール値の観測値を返します。</target>
        </trans-unit>
        <trans-unit id="3a4a4ba8ed0c16db5d39596cb0488aad4649a436" translate="yes" xml:space="preserve">
          <source>CompletionObserver</source>
          <target state="translated">CompletionObserver</target>
        </trans-unit>
        <trans-unit id="d982b449859a628c84de4d2d6a5c484a7c842af0" translate="yes" xml:space="preserve">
          <source>Concatenate 3 Observables</source>
          <target state="translated">3つの観測値を連結する</target>
        </trans-unit>
        <trans-unit id="63f84436a9e4551523680f6e33010bbd81eceb69" translate="yes" xml:space="preserve">
          <source>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</source>
          <target state="translated">0から3までのタイマーを1から10までの同期シーケンスと連結する</target>
        </trans-unit>
        <trans-unit id="d2f209d251c0e1e81cd1edf9ef7e4dd74fc1df55" translate="yes" xml:space="preserve">
          <source>Concatenate the same Observable to repeat it</source>
          <target state="translated">同じObservableを連結して繰り返す</target>
        </trans-unit>
        <trans-unit id="6ca2d7e68988508caae3db5f7e018aedff9b9fc9" translate="yes" xml:space="preserve">
          <source>Concatenates multiple Observables together by sequentially emitting their values, one Observable after the other.</source>
          <target state="translated">複数のObservableを1つのObservableから順番に値を出して連結します。</target>
        </trans-unit>
        <trans-unit id="d0b35f2e80cf4078de3821051d01800d2a02ba30" translate="yes" xml:space="preserve">
          <source>Conclusion:</source>
          <target state="translated">Conclusion:</target>
        </trans-unit>
        <trans-unit id="0994f75274a8c52a8effb0dff41d86197463bb06" translate="yes" xml:space="preserve">
          <source>Condition to terminate generation (upon returning false).</source>
          <target state="translated">世代を終了させる条件(falseを返したとき)。</target>
        </trans-unit>
        <trans-unit id="89e222ef595e95335f78cd2e3d813306054bc919" translate="yes" xml:space="preserve">
          <source>Condition which Observable should be chosen.</source>
          <target state="translated">観測可能なものを選択する条件</target>
        </trans-unit>
        <trans-unit id="9b047f76f02c3292f835923209499db8eb35fdb8" translate="yes" xml:space="preserve">
          <source>Conditional and Boolean Operators</source>
          <target state="translated">条件演算子とブール演算子</target>
        </trans-unit>
        <trans-unit id="98fc062426c459824189a5ec2607ca8eff08cd75" translate="yes" xml:space="preserve">
          <source>ConnectableObservable</source>
          <target state="translated">ConnectableObservable</target>
        </trans-unit>
        <trans-unit id="227f6773256bb7ed0a8c8aef07706b2d613095e7" translate="yes" xml:space="preserve">
          <source>ConnectableObservable._subscribe()</source>
          <target state="translated">ConnectableObservable._subscribe()</target>
        </trans-unit>
        <trans-unit id="e4e83313fbffa48c823bbad63fe418da25e13b75" translate="yes" xml:space="preserve">
          <source>ConnectableObservable.connect()</source>
          <target state="translated">ConnectableObservable.connect()</target>
        </trans-unit>
        <trans-unit id="5b738b218b7aa49bf8395157e1f139e5d7314c3d" translate="yes" xml:space="preserve">
          <source>ConnectableObservable.getSubject()</source>
          <target state="translated">ConnectableObservable.getSubject()</target>
        </trans-unit>
        <trans-unit id="682ebb04b9bff65e60368de186fac3051021f642" translate="yes" xml:space="preserve">
          <source>ConnectableObservable.refCount()</source>
          <target state="translated">ConnectableObservable.refCount()</target>
        </trans-unit>
        <trans-unit id="a3613a775b8dd1ea901d700f28e65babb54cab38" translate="yes" xml:space="preserve">
          <source>Consider the following example where subscriptions occur as outlined by this list:</source>
          <target state="translated">このリストで概説されているように、サブスクリプションが発生する次の例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="fc53f41d4c528eb43347a836891919335055512d" translate="yes" xml:space="preserve">
          <source>Consider the following:</source>
          <target state="translated">次のように考えてみてください。</target>
        </trans-unit>
        <trans-unit id="edb7861f190be64ab7c7a39786a00727bb16847d" translate="yes" xml:space="preserve">
          <source>Constructor</source>
          <target state="translated">Constructor</target>
        </trans-unit>
        <trans-unit id="0c707f2781a489cf7e4ea7d11c190f8dfe3a0bf0" translate="yes" xml:space="preserve">
          <source>Consumer</source>
          <target state="translated">Consumer</target>
        </trans-unit>
        <trans-unit id="c98977bcb8208e29729ee8d1a4102b950f779678" translate="yes" xml:space="preserve">
          <source>Continues with a different Observable when there's an error</source>
          <target state="translated">エラーが発生した場合は、別のObservableを使用して続行します。</target>
        </trans-unit>
        <trans-unit id="7ada7cd7c5728485ea37e7e90c589b594cd34212" translate="yes" xml:space="preserve">
          <source>Contrary to popular claims, Observables are not like EventEmitters nor are they like Promises for multiple values. Observables &lt;em&gt;may act&lt;/em&gt; like EventEmitters in some cases, namely when they are multicasted using RxJS Subjects, but usually they don't act like EventEmitters.</source>
          <target state="translated">一般的な主張とは異なり、ObservableはEventEmittersのようなものではなく、複数の値に対するPromiseのようなものでもありません。オブザーバブル&lt;em&gt;は&lt;/em&gt;、RxJSサブジェクトを使用してマルチキャストされる場合など、EventEmitterのように動作する場合がありますが、通常、EventEmitterのようには動作しません。</target>
        </trans-unit>
        <trans-unit id="0a49d6e404607e10a989271aec1f79d6ac8a2119" translate="yes" xml:space="preserve">
          <source>Control an access to an Observable</source>
          <target state="translated">Observableへのアクセス制御</target>
        </trans-unit>
        <trans-unit id="59cdbb05d9b9d2c325ba6cc70236d63b8806330c" translate="yes" xml:space="preserve">
          <source>Convert a faulty Observable to an Observable of Notifications</source>
          <target state="translated">障害のあるObservableをNotificationsのObservableに変換する</target>
        </trans-unit>
        <trans-unit id="c7a397319f2ad4db3ea562e9725ebd2ef8e801dc" translate="yes" xml:space="preserve">
          <source>Convert an Observable of Notifications to an actual Observable</source>
          <target state="translated">通知のObservableを実際のObservableに変換する</target>
        </trans-unit>
        <trans-unit id="a57ac9929f9075b8bad9951d6bf02471c724dcb8" translate="yes" xml:space="preserve">
          <source>Convert an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions.</source>
          <target state="translated">アイテムを放出するObservableを、それらの放出の間の経過時間を表示するObservableに変換します。</target>
        </trans-unit>
        <trans-unit id="a364d3d6bb030d153b00d33ba8b033883901284b" translate="yes" xml:space="preserve">
          <source>Convert an infinite iterable (from a generator) to an Observable</source>
          <target state="translated">無限反復可能な(ジェネレータからの)反復可能体をObservableに変換する</target>
        </trans-unit>
        <trans-unit id="ea2d5c2f9388b6f9038c0c700046b2170a04bde6" translate="yes" xml:space="preserve">
          <source>Convert an object into an Observable of &lt;code&gt;[key, value]&lt;/code&gt; pairs.</source>
          <target state="translated">オブジェクトを &lt;code&gt;[key, value]&lt;/code&gt; ペアのObservableに変換します。</target>
        </trans-unit>
        <trans-unit id="3288bcd2be86adb205c2a9df12810cd9003b7c8e" translate="yes" xml:space="preserve">
          <source>Convert jQuery's getJSON to an Observable API</source>
          <target state="translated">jQueryのgetJSONをObservable APIに変換する</target>
        </trans-unit>
        <trans-unit id="819a8ca76a22d542e92a562a9321de242bb32824" translate="yes" xml:space="preserve">
          <source>Converts a Node.js-style callback API to a function that returns an Observable.</source>
          <target state="translated">Node.jsスタイルのコールバックAPIをObservableを返す関数に変換します。</target>
        </trans-unit>
        <trans-unit id="0ca228dc00e3b500ab7c0c59f7db8fa3cc379cf4" translate="yes" xml:space="preserve">
          <source>Converts a callback API to a function that returns an Observable.</source>
          <target state="translated">コールバック API を Observable を返す関数に変換します。</target>
        </trans-unit>
        <trans-unit id="d8bdbac484a550c5290dc0793186ded042951331" translate="yes" xml:space="preserve">
          <source>Converts a higher-order Observable into a first-order Observable by concatenating the inner Observables in order.</source>
          <target state="translated">内部のObservableを順番に連結して、高次のObservableを1次のObservableに変換します。</target>
        </trans-unit>
        <trans-unit id="512eb28280b7e03ca5f0d999e4ad906680f5cf55" translate="yes" xml:space="preserve">
          <source>Converts a higher-order Observable into a first-order Observable by dropping inner Observables while the previous inner Observable has not yet completed.</source>
          <target state="translated">前の内側のObservableが完了していない間に内側のObservableをドロップすることで、高次のObservableを1次のObservableに変換します。</target>
        </trans-unit>
        <trans-unit id="0fc3a87abee50d7640e787cc66c96745d64bcdfe" translate="yes" xml:space="preserve">
          <source>Converts a higher-order Observable into a first-order Observable producing values only from the most recent observable sequence</source>
          <target state="translated">高次のObservableを1次のObservableに変換し、最新の観測可能なシーケンスからのみ値を生成します。</target>
        </trans-unit>
        <trans-unit id="fc15afc5a3b5a5a5700f443e1064756e1aeb0ef1" translate="yes" xml:space="preserve">
          <source>Converts a higher-order Observable into a first-order Observable which concurrently delivers all values that are emitted on the inner Observables.</source>
          <target state="translated">高次のObservableを、内部のObservableに放出されたすべての値を同時に配信する1次のObservableに変換します。</target>
        </trans-unit>
        <trans-unit id="b51d3e7b3c8cccda64472b781a2fe516fd3c8d36" translate="yes" xml:space="preserve">
          <source>Converts almost anything to an Observable.</source>
          <target state="translated">ほとんどのものをObservableに変換します。</target>
        </trans-unit>
        <trans-unit id="dcafce430dc29181daa478cf9c06fd80fd059a0f" translate="yes" xml:space="preserve">
          <source>Converts an Observable of &lt;a href=&quot;../index/class/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; objects into the emissions that they represent.</source>
          <target state="translated">Observable of &lt;a href=&quot;../index/class/notification&quot;&gt; &lt;code&gt;Notification&lt;/code&gt; &lt;/a&gt;オブジェクトを、それらが表すエミッションに変換します。</target>
        </trans-unit>
        <trans-unit id="90543f0ae59be2561cf130cfe357a2eb0d2f310c" translate="yes" xml:space="preserve">
          <source>Converts an array to an Observable</source>
          <target state="translated">配列をObservableに変換します。</target>
        </trans-unit>
        <trans-unit id="38d9b9c231b0641f88f17b35e4cd114dbaa6824b" translate="yes" xml:space="preserve">
          <source>Converts from a common &lt;a href=&quot;../type-alias/observableinput&quot;&gt;&lt;code&gt;ObservableInput&lt;/code&gt;&lt;/a&gt; type to an observable where subscription and emissions are scheduled on the provided scheduler.</source>
          <target state="translated">共通の&lt;a href=&quot;../type-alias/observableinput&quot;&gt; &lt;code&gt;ObservableInput&lt;/code&gt; &lt;/a&gt;型から、サブスクリプションとエミッションが指定されたスケジューラーでスケジュールされるオブザーバブルに変換します。</target>
        </trans-unit>
        <trans-unit id="c8516852b5b3e129bf4cf88d8db27cd4db8ae7ec" translate="yes" xml:space="preserve">
          <source>Converts the arguments to an observable sequence.</source>
          <target state="translated">引数を観測可能なシーケンスに変換します。</target>
        </trans-unit>
        <trans-unit id="cd9fea92083a870676e543be5c6771c16d35faf8" translate="yes" xml:space="preserve">
          <source>Core Observable concerns:</source>
          <target state="translated">コア観察可能な懸念事項。</target>
        </trans-unit>
        <trans-unit id="fc6c40245600e6f83559183f877fd23ea3ec4525" translate="yes" xml:space="preserve">
          <source>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</source>
          <target state="translated">クリックごとに0から9までを1秒ごとにカウントしますが、2つのタイマーを同時に使用することはできません。</target>
        </trans-unit>
        <trans-unit id="8e4e16903b9c68e1a70feb9c1b12a2e432e40e13" translate="yes" xml:space="preserve">
          <source>Count the number of click events</source>
          <target state="translated">クリックイベントの数をカウントする</target>
        </trans-unit>
        <trans-unit id="76fe820e51c08ab2fdcfa79429ab0f2b55d0239b" translate="yes" xml:space="preserve">
          <source>Count the number of click events that happened in 5 seconds</source>
          <target state="translated">5秒間に発生したクリックイベントの数をカウントする</target>
        </trans-unit>
        <trans-unit id="38297b14fd834b687d5f9c6c0c377bc3a26611e7" translate="yes" xml:space="preserve">
          <source>Counts how many odd numbers are there between 1 and 7</source>
          <target state="translated">1から7までの間にある奇数の数を数える</target>
        </trans-unit>
        <trans-unit id="6527ed3c67425451554706dd6e296b6b07cfda36" translate="yes" xml:space="preserve">
          <source>Counts how many seconds have passed before the first click happened</source>
          <target state="translated">最初のクリックが発生するまでに何秒経過したかをカウントします。</target>
        </trans-unit>
        <trans-unit id="491a828d8c53ae7db8b33fbcf030f25402cd90e8" translate="yes" xml:space="preserve">
          <source>Counts the number of emissions on the source and emits that number when the source completes.</source>
          <target state="translated">ソース上の排出数をカウントし、ソースが完了したらその数を排出します。</target>
        </trans-unit>
        <trans-unit id="b7d8894a964a606855f76a9e1a3c256a85a77af3" translate="yes" xml:space="preserve">
          <source>Creates a new Observable with this Subject as the source. You can do this to create customize Observer-side logic of the Subject and conceal it from code that uses the Observable.</source>
          <target state="translated">このSubjectをソースとして新しいObservableを作成します。これにより、Subject のカスタマイズされた Observer 側のロジックを作成し、Observable を使用するコードからそれを隠すことができます。</target>
        </trans-unit>
        <trans-unit id="efd43c4f17bae72263830052e23af52fd14ac204" translate="yes" xml:space="preserve">
          <source>Creates a new Observable, with this Observable as the source, and the passed operator defined as the new observable's operator.</source>
          <target state="translated">このObservableをソースとし、渡された演算子を新しいObservableの演算子として定義して、新しいObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="6c433e239b323f6366118477eb69a8b50b369846" translate="yes" xml:space="preserve">
          <source>Creates a new cold Observable by calling the Observable constructor</source>
          <target state="translated">Observableのコンストラクタを呼び出して、新しいコールドObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="e42c4af5ccb591cb72c7f304fdf206bf4581acd1" translate="yes" xml:space="preserve">
          <source>Creates an &lt;a href=&quot;../index/class/observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;, that when subscribed to, sends a message, defined by the &lt;code&gt;subMsg&lt;/code&gt; function, to the server over the socket to begin a subscription to data over that socket. Once data arrives, the &lt;code&gt;messageFilter&lt;/code&gt; argument will be used to select the appropriate data for the resulting Observable. When teardown occurs, either due to unsubscription, completion or error, a message defined by the &lt;code&gt;unsubMsg&lt;/code&gt; argument will be send to the server over the WebSocketSubject.</source>
          <target state="translated">&lt;a href=&quot;../index/class/observable&quot;&gt; &lt;code&gt;Observable&lt;/code&gt; を&lt;/a&gt;作成します。サブスクライブすると、 &lt;code&gt;subMsg&lt;/code&gt; 関数によって定義されたメッセージをソケットを介してサーバーに送信し、そのソケットを介したデータへのサブスクリプションを開始します。データが到着すると、 &lt;code&gt;messageFilter&lt;/code&gt; 引数を使用して、結果のObservableに適切なデータを選択します。 &lt;code&gt;unsubMsg&lt;/code&gt; 解除、完了、またはエラーによりティアダウンが発生すると、unsubMsg引数で定義されたメッセージがWebSocketSubjectを介してサーバーに送信されます。</target>
        </trans-unit>
        <trans-unit id="6ba57e20fce78b5dfa9aefcbbbb2225cbb2cd085" translate="yes" xml:space="preserve">
          <source>Creates an Observable from DOM events, or Node.js EventEmitter events or others.</source>
          <target state="translated">DOMイベントやNode.js EventEmitterイベントなどからObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="30076be76739faf49c8bf250c9ce3b8582621a15" translate="yes" xml:space="preserve">
          <source>Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.</source>
          <target state="translated">配列、配列のようなオブジェクト、Promise、反復可能なオブジェクト、またはObservableのようなオブジェクトからObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="a4b1d654222d9d963587195913c2db77cd1b2ff3" translate="yes" xml:space="preserve">
          <source>Creates an Observable from an arbitrary API for registering event handlers.</source>
          <target state="translated">イベントハンドラを登録するための任意のAPIからObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="8733e65df876cdecf09a85905357f82185d6f2a9" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits a sequence of numbers within a specified range.</source>
          <target state="translated">指定された範囲内の数値を連続して出力するObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="8ee788397d60121f2a0cdbe5153d1f8ed70114d7" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits events of a specific type coming from the given event target.</source>
          <target state="translated">指定されたイベントターゲットから特定のタイプのイベントを発生させるObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="b19f653638b964e69cc5d6d83f264b627db6396d" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits no items to the Observer and immediately emits a complete notification.</source>
          <target state="translated">オブザーバにアイテムを出さず、すぐに完全な通知を出すObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="9ecbdd7d8ebb055a77e819dc27b5b8e144ac8f76" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits no items to the Observer and immediately emits an error notification.</source>
          <target state="translated">オブザーバにアイテムを出さず、エラー通知を即座に出すObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="c834efdbaabe5e44921e2ec46f3ff1e6caa151a5" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits sequential numbers every specified interval of time, on a specified &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指定された&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;で、指定された時間間隔ごとに連続番号を発行するObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="c660a5a39524e13cbab144cbe8ab5e14563e2a40" translate="yes" xml:space="preserve">
          <source>Creates an Observable that starts emitting after an &lt;code&gt;dueTime&lt;/code&gt; and emits ever increasing numbers after each &lt;code&gt;period&lt;/code&gt; of time thereafter.</source>
          <target state="translated">&lt;code&gt;dueTime&lt;/code&gt; の後に放出を開始し、その後の各 &lt;code&gt;period&lt;/code&gt; の後に増加する数値を放出するObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="ae9fed84cdc523c537f6047938e7614dfd90ce38" translate="yes" xml:space="preserve">
          <source>Creates an Observable that uses a resource which will be disposed at the same time as the Observable.</source>
          <target state="translated">Observableと同時に廃棄されるリソースを使用するObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="88400625480f529b5c6a9d3898751cae3e084fbf" translate="yes" xml:space="preserve">
          <source>Creates an Observable that, on subscribe, calls an Observable factory to make an Observable for each new Observer.</source>
          <target state="translated">Observable を作成します。この Observable は、Subscribe 時に Observable ファクトリを呼び出して、新しい Observer ごとに Observable を作成します。</target>
        </trans-unit>
        <trans-unit id="0763a1a84734bc982d4480f3a3459456e835d5cd" translate="yes" xml:space="preserve">
          <source>Creates an output Observable which concurrently emits all values from every given input Observable.</source>
          <target state="translated">与えられたすべての入力Observableからすべての値を同時に出力する出力Observableを作成します。</target>
        </trans-unit>
        <trans-unit id="33b018d042209578a46cb7d33213ab03f281363d" translate="yes" xml:space="preserve">
          <source>Creates an output Observable which sequentially emits all values from given Observable and then moves on to the next.</source>
          <target state="translated">与えられたObservableからすべての値を順次出力し、次のObservableに移動する出力Observableを作成します。</target>
        </trans-unit>
        <trans-unit id="70011ddbfcf5671aa0c05bf7fceff4d551c240d5" translate="yes" xml:space="preserve">
          <source>Creates the Observable lazily, that is, only when it is subscribed.</source>
          <target state="translated">Observableを怠惰に、つまりサブスクライブされているときだけ作成します。</target>
        </trans-unit>
        <trans-unit id="6ad6131d04bc2f8da39dba3829954ab817589a3f" translate="yes" xml:space="preserve">
          <source>Creating Observables</source>
          <target state="translated">オブザーバブルの作成</target>
        </trans-unit>
        <trans-unit id="3b55e62a31cf0de003b499939010016bd026ad3c" translate="yes" xml:space="preserve">
          <source>Creating custom observables</source>
          <target state="translated">カスタム観測値の作成</target>
        </trans-unit>
        <trans-unit id="eb98788b461efb61b82601e6daec4642ab62fad1" translate="yes" xml:space="preserve">
          <source>Creating new operators from scratch</source>
          <target state="translated">ゼロからの新規事業者の作成</target>
        </trans-unit>
        <trans-unit id="94397887885ac635c016bdd99861cf6ef324405b" translate="yes" xml:space="preserve">
          <source>Creation Operators</source>
          <target state="translated">クリエイションオペレーター</target>
        </trans-unit>
        <trans-unit id="e10b82309ae23cd7af56714b5258dc6a40b2138f" translate="yes" xml:space="preserve">
          <source>Decides at subscription time which Observable will actually be subscribed.</source>
          <target state="translated">どのObservableが実際にサブスクライブされるかをサブスクリプション時に決定します。</target>
        </trans-unit>
        <trans-unit id="4cf333763d14e699755bedabc5590efe13366f13" translate="yes" xml:space="preserve">
          <source>Declared in constructor.</source>
          <target state="translated">コンストラクタで宣言されています。</target>
        </trans-unit>
        <trans-unit id="23bcb0d403ca12abcc86f64467b703be68b8f8c7" translate="yes" xml:space="preserve">
          <source>DeferObservable</source>
          <target state="translated">DeferObservable</target>
        </trans-unit>
        <trans-unit id="621045d69c5be1f634a4e5bcc53ff0a6021d3950" translate="yes" xml:space="preserve">
          <source>Delay all clicks until a future date happens</source>
          <target state="translated">将来の日付が来るまですべてのクリックを遅延させる</target>
        </trans-unit>
        <trans-unit id="fe5c6e39f63a2abb17033a49863d02e213157524" translate="yes" xml:space="preserve">
          <source>Delay each click by a random amount of time, between 0 and 5 seconds</source>
          <target state="translated">各クリックを0~5秒の間でランダムに遅延させます。</target>
        </trans-unit>
        <trans-unit id="8915b9cde2c4ef9b51fbce85255c288a61f24642" translate="yes" xml:space="preserve">
          <source>Delay each click by one second</source>
          <target state="translated">各クリックを1秒ずつ遅らせる</target>
        </trans-unit>
        <trans-unit id="68662352061ba86d162c267de395269277632ba7" translate="yes" xml:space="preserve">
          <source>Delays the emission of items from the source Observable by a given time span determined by the emissions of another Observable.</source>
          <target state="translated">ソースObservableからのアイテムの放出を、他のObservableの放出によって決定された時間だけ遅らせます。</target>
        </trans-unit>
        <trans-unit id="1ef659436a6c36a417cd112a0a121582339f99c4" translate="yes" xml:space="preserve">
          <source>Delays the emission of items from the source Observable by a given timeout or until a given Date.</source>
          <target state="translated">特定のタイムアウトまで、または特定の日付まで、Observableソースからのアイテムの放出を遅延させます。</target>
        </trans-unit>
        <trans-unit id="7e315272fd1a4207c99a387e25509471282803ef" translate="yes" xml:space="preserve">
          <source>Delivers to the given &lt;code&gt;observer&lt;/code&gt; the value wrapped by this Notification.</source>
          <target state="translated">この通知によってラップされた値を、指定された &lt;code&gt;observer&lt;/code&gt; 配信します。</target>
        </trans-unit>
        <trans-unit id="1605f6c45747aafbe495b3876f2cf20e7b6fdd24" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/combinelatest&quot;&gt;&lt;code&gt;combineLatest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">静的&lt;a href=&quot;../index/function/combinelatest&quot;&gt; &lt;code&gt;combineLatest&lt;/code&gt; &lt;/a&gt;を支持して廃止されました。</target>
        </trans-unit>
        <trans-unit id="6b14b595931fc098a11ef3100bdb2821b6ac22c6" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/concat&quot;&gt;&lt;code&gt;concat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">static &lt;a href=&quot;../index/function/concat&quot;&gt; &lt;code&gt;concat&lt;/code&gt; &lt;/a&gt;を支持して廃止されました。</target>
        </trans-unit>
        <trans-unit id="bb891d216533ca453393f5560f216a593180a0c4" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/merge&quot;&gt;&lt;code&gt;merge&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">静的&lt;a href=&quot;../index/function/merge&quot;&gt; &lt;code&gt;merge&lt;/code&gt; &lt;/a&gt;ために廃止予定。</target>
        </trans-unit>
        <trans-unit id="4923b07923f47345827f9dbc43bdd9226f071ef1" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/race&quot;&gt;&lt;code&gt;race&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">静的な&lt;a href=&quot;../index/function/race&quot;&gt; &lt;code&gt;race&lt;/code&gt; &lt;/a&gt;ために廃止予定。</target>
        </trans-unit>
        <trans-unit id="65017388b7b5b653ed1176ea2721b4807d0aab75" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">静的な&lt;a href=&quot;../index/function/zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt;を支持して非推奨。</target>
        </trans-unit>
        <trans-unit id="bd528af798c288f24a1995a90fcf7251b1fb384c" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of using &lt;a href=&quot;../const/never&quot;&gt;&lt;code&gt;NEVER&lt;/code&gt;&lt;/a&gt; constant.</source>
          <target state="translated">&lt;a href=&quot;../const/never&quot;&gt; &lt;code&gt;NEVER&lt;/code&gt; &lt;/a&gt;定数を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="22ecf0e4bb675b2432fe6ba41fe1a4c5f10d31ec" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of using &lt;a href=&quot;empty&quot;&gt;EMPTY&lt;/a&gt; constant, or &lt;a href=&quot;scheduled&quot;&gt;&lt;code&gt;scheduled&lt;/code&gt;&lt;/a&gt; (e.g. &lt;code&gt;scheduled([], scheduler)&lt;/code&gt;)</source>
          <target state="translated">&lt;a href=&quot;empty&quot;&gt;EMPTY&lt;/a&gt;定数を使用するか、または&lt;a href=&quot;scheduled&quot;&gt; &lt;code&gt;scheduled&lt;/code&gt; &lt;/a&gt;（たとえば、 &lt;code&gt;scheduled([], scheduler)&lt;/code&gt; ）を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="463582ed19dfc58a87321a7b92cfba5549a9c5d0" translate="yes" xml:space="preserve">
          <source>Deprecation Notes</source>
          <target state="translated">非推奨の注意事項</target>
        </trans-unit>
        <trans-unit id="34730e9bbd5c0ba7b7655973316eed44e39da85f" translate="yes" xml:space="preserve">
          <source>Deprecations</source>
          <target state="translated">Deprecations</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="2666820b5bb0173df8ddd17b764bde4b0f8b1b61" translate="yes" xml:space="preserve">
          <source>Disposes the resources held by the subscription. May, for instance, cancel an ongoing Observable execution or cancel any other type of work that started when the Subscription was created.</source>
          <target state="translated">サブスクリプションによって保持されているリソースを破棄します。例えば、進行中のObservableの実行をキャンセルしたり、サブスクリプションが作成されたときに開始された他の種類の作業をキャンセルしたりすることができます。</target>
        </trans-unit>
        <trans-unit id="316644b959082a2cc487f06bf5876e8dcf368159" translate="yes" xml:space="preserve">
          <source>Disposing Observable Executions</source>
          <target state="translated">観察可能な実行の廃棄</target>
        </trans-unit>
        <trans-unit id="af481d033e3d6a89a0a00f12185b62203c7b5177" translate="yes" xml:space="preserve">
          <source>Double Click</source>
          <target state="translated">ダブルクリック</target>
        </trans-unit>
        <trans-unit id="f04e90acad2440fd4a1e87ff19b6433cbce9b7c3" translate="yes" xml:space="preserve">
          <source>Dropping the compatibility layer</source>
          <target state="translated">互換性レイヤーの削除</target>
        </trans-unit>
        <trans-unit id="52f444678c751856f9a1ce086837968f7c75e741" translate="yes" xml:space="preserve">
          <source>Due to having operators available independent of an Observable, operator names cannot conflict with JavaScript keyword restrictions. Therefore the names of the pipeable version of some operators have changed. These operators are:</source>
          <target state="translated">Observable とは独立して演算子を利用できるようにするため、演算子名は JavaScript のキーワード制限と衝突することができません。そのため、いくつかの演算子のパイプ可能なバージョンの名前が変更されました。これらの演算子は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="5bc604777adb22ae457a5473c397202e00689e23" translate="yes" xml:space="preserve">
          <source>EMPTY</source>
          <target state="translated">EMPTY</target>
        </trans-unit>
        <trans-unit id="0b99cebe565822c64ac5d84aecb00fe40e59cbd3" translate="yes" xml:space="preserve">
          <source>ERROR</source>
          <target state="translated">ERROR</target>
        </trans-unit>
        <trans-unit id="42e1bdd92a7f77d27b8d2717d5eeb1d59be288ff" translate="yes" xml:space="preserve">
          <source>ES2015 introduced &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;generator functions and iterators&lt;/a&gt; (&lt;code&gt;function*&lt;/code&gt;), another type of Pull system. Code that calls &lt;code&gt;iterator.next()&lt;/code&gt; is the Consumer, &quot;pulling&quot; out &lt;em&gt;multiple&lt;/em&gt; values from the iterator (the Producer).</source>
          <target state="translated">ES2015では、別のタイプのプルシステムである&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;ジェネレータ関数とイテレータ&lt;/a&gt;（ &lt;code&gt;function*&lt;/code&gt; ）が導入されました。 &lt;code&gt;iterator.next()&lt;/code&gt; を呼び出すコードはコンシューマーであり、イテレーター（プロデューサー）から&lt;em&gt;複数の&lt;/em&gt;値を「引き出し」ます。</target>
        </trans-unit>
        <trans-unit id="674227a972a4b55f0756d9b2d66199ac3bfe89e5" translate="yes" xml:space="preserve">
          <source>ES6 via npm</source>
          <target state="translated">npm経由のES6</target>
        </trans-unit>
        <trans-unit id="666ff450a66a4678df3ec36c42739caaec2c8c52" translate="yes" xml:space="preserve">
          <source>Each Observable must define how to dispose resources of that execution when we create the Observable using &lt;code&gt;create()&lt;/code&gt;. You can do that by returning a custom &lt;code&gt;unsubscribe&lt;/code&gt; function from within &lt;code&gt;function subscribe()&lt;/code&gt;.</source>
          <target state="translated">各Observableは、 &lt;code&gt;create()&lt;/code&gt; を使用してObservableを作成するときに、その実行のリソースを破棄する方法を定義する必要があります。これを行うには、 &lt;code&gt;function subscribe()&lt;/code&gt; 内からカスタム &lt;code&gt;unsubscribe&lt;/code&gt; 関数を返します。</target>
        </trans-unit>
        <trans-unit id="f678d49cb58e833db6233feb20eeeaa4428483bb" translate="yes" xml:space="preserve">
          <source>Each argument becomes a &lt;code&gt;next&lt;/code&gt; notification.</source>
          <target state="translated">各引数は &lt;code&gt;next&lt;/code&gt; 通知になります。</target>
        </trans-unit>
        <trans-unit id="058613ebc4c427459ecefefd3afa54ff8652eb4e" translate="yes" xml:space="preserve">
          <source>Each space  equals 1 frame, same as a hyphen &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">各スペースはハイフン &lt;code&gt;-&lt;/code&gt; と同じ1フレームに相当します。</target>
        </trans-unit>
        <trans-unit id="adf1a47a9d340f3325f9f83ae4bbd1be31b28aa3" translate="yes" xml:space="preserve">
          <source>Each unit of work in a Scheduler is called an &lt;code&gt;Action&lt;/code&gt;.</source>
          <target state="translated">スケジューラの各作業単位は &lt;code&gt;Action&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="a38b3bf75f93d9975be6df57e4eea447fc05cb7b" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;false&lt;/code&gt; for a non-empty Observable</source>
          <target state="translated">空でないObservableに対して &lt;code&gt;false&lt;/code&gt; を発行します</target>
        </trans-unit>
        <trans-unit id="36595adf79029effea5aafbe0b33e1661d847cfa" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;true&lt;/code&gt; for an empty Observable</source>
          <target state="translated">空のObservableに対して &lt;code&gt;true&lt;/code&gt; を発行します</target>
        </trans-unit>
        <trans-unit id="9e45731f0c536caf528a3c80e03eb08e5adb47de" translate="yes" xml:space="preserve">
          <source>Emit an array of the last clicks every [1-5] random seconds</source>
          <target state="translated">最後のクリックの配列をランダムな秒数[1-5]ごとに表示します。</target>
        </trans-unit>
        <trans-unit id="cae1dc3d5bbad2305fd286cad6d208c19363eab7" translate="yes" xml:space="preserve">
          <source>Emit click events only while the clientX property is greater than 200</source>
          <target state="translated">clientXプロパティが200より大きい場合にのみクリックイベントを送信します。</target>
        </trans-unit>
        <trans-unit id="dda0faf5498ca6dcf8ab28c43818f4feec0a0a42" translate="yes" xml:space="preserve">
          <source>Emit clicks at a rate of at most one click per second</source>
          <target state="translated">1秒間に最大1回のクリック率でクリックを送信します。</target>
        </trans-unit>
        <trans-unit id="3c76a13f5ebea7e20bbf00f2c9d32b7c447120aa" translate="yes" xml:space="preserve">
          <source>Emit inteval between current value with the last value</source>
          <target state="translated">現在の値と最後の値との間の整数値を出力します。</target>
        </trans-unit>
        <trans-unit id="84e59125f4895d959fba5383e8c9b85b6d26b42c" translate="yes" xml:space="preserve">
          <source>Emit only click events whose target was a DIV element</source>
          <target state="translated">ターゲットがDIV要素であるクリックイベントのみを送信する</target>
        </trans-unit>
        <trans-unit id="aca713a5446a034f7eb7ee7cfd82582714e0d9f0" translate="yes" xml:space="preserve">
          <source>Emit only the first click that happens on the DOM</source>
          <target state="translated">DOM 上で発生した最初のクリックのみを表示します。</target>
        </trans-unit>
        <trans-unit id="6b2725c4f577b99a3c281b978bc1da2e3d162a2d" translate="yes" xml:space="preserve">
          <source>Emit only the first two clicks events in every window of [1-5] random seconds</source>
          <target state="translated">ランダム秒数[1-5]の各ウィンドウで、最初の2回のクリックイベントのみを送信します。</target>
        </trans-unit>
        <trans-unit id="d4bf60f5d394bc9dce56c9746cc1455601173e04" translate="yes" xml:space="preserve">
          <source>Emit only the third click event</source>
          <target state="translated">3回目のクリックイベントのみを表示する</target>
        </trans-unit>
        <trans-unit id="be82a967776bd06b73a9ef958b479a7e772ebb46" translate="yes" xml:space="preserve">
          <source>Emit the array &lt;code&gt;[1,2,3]&lt;/code&gt;</source>
          <target state="translated">配列を放出 &lt;code&gt;[1,2,3]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="258507901d76adefcf885e2d2ba14720064b4f43" translate="yes" xml:space="preserve">
          <source>Emit the index of first click that happens on a DIV element</source>
          <target state="translated">DIV要素上で発生した最初のクリックのインデックスを表示する</target>
        </trans-unit>
        <trans-unit id="e999d3a97f2c47d682185359cbc062466b4ecaee" translate="yes" xml:space="preserve">
          <source>Emit the last two click events as an array</source>
          <target state="translated">最後の2つのクリックイベントを配列として出力します。</target>
        </trans-unit>
        <trans-unit id="b06ea69b0090aa2950941eebc373f9ab08c43134" translate="yes" xml:space="preserve">
          <source>Emit the most recent click after a burst of clicks</source>
          <target state="translated">クリックを繰り返した後、最新のクリックを表示する</target>
        </trans-unit>
        <trans-unit id="2ea4407361558147d8a964707b8d5610dfeeb1ab" translate="yes" xml:space="preserve">
          <source>Emit the number 7, then complete</source>
          <target state="translated">数字の7を出して完了</target>
        </trans-unit>
        <trans-unit id="08b53dacead1c62d68921ed8a27c7e6dd38496b0" translate="yes" xml:space="preserve">
          <source>Emit the number 7, then emit an error</source>
          <target state="translated">数字の7を出してからエラーを出す</target>
        </trans-unit>
        <trans-unit id="b6f544e32d0273819a571f258748d660fa3de0b5" translate="yes" xml:space="preserve">
          <source>Emit the number 7, then never emit anything else (not even complete)</source>
          <target state="translated">数字の7を出して、それ以外は絶対に出さない(完全ではない</target>
        </trans-unit>
        <trans-unit id="035524c755f99f7f39661d88482f9c247d60ae51" translate="yes" xml:space="preserve">
          <source>Emit the values &lt;code&gt;10, 20, 30&lt;/code&gt;</source>
          <target state="translated">EMIT値 &lt;code&gt;10, 20, 30&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71a66df699b18ab8842ed8372fe230b4344398b0" translate="yes" xml:space="preserve">
          <source>Emits a given value if the source Observable completes without emitting any &lt;code&gt;next&lt;/code&gt; value, otherwise mirrors the source Observable.</source>
          <target state="translated">ソースObservableが &lt;code&gt;next&lt;/code&gt; 値を発行せずに完了する場合は、指定された値を発行します。それ以外の場合は、ソースObservableをミラーリングします。</target>
        </trans-unit>
        <trans-unit id="f5936dfcfd0d7b376e741c1351e9508df5c31a94" translate="yes" xml:space="preserve">
          <source>Emits a sequence of numbers in a range.</source>
          <target state="translated">範囲内の数値を連続して出力します。</target>
        </trans-unit>
        <trans-unit id="3459aa8bde5600535a38bc29ec55520c8ffe5b3b" translate="yes" xml:space="preserve">
          <source>Emits a value from the source Observable only after a particular time span determined by another Observable has passed without another source emission.</source>
          <target state="translated">他のObservableによって決定された特定の時間が経過した後にのみ、他のソースObservableから値を放出します。</target>
        </trans-unit>
        <trans-unit id="796b34385a59e79b833e9d74db73634c2b0ff888" translate="yes" xml:space="preserve">
          <source>Emits a value from the source Observable only after a particular time span has passed without another source emission.</source>
          <target state="translated">他のソースからの放出がなく、特定の時間スパンが経過した後にのみ、ソースから値を放出します。</target>
        </trans-unit>
        <trans-unit id="1145fc21b2f2c2783c18b2286b6ba6d20b685d48" translate="yes" xml:space="preserve">
          <source>Emits a value from the source Observable, then ignores subsequent source values for &lt;code&gt;duration&lt;/code&gt; milliseconds, then repeats this process.</source>
          <target state="translated">ソースObservableから値を発行し、 &lt;code&gt;duration&lt;/code&gt; ミリ秒の間、後続のソース値を無視して、このプロセスを繰り返します。</target>
        </trans-unit>
        <trans-unit id="3ea9d1e82cdd52be474e2587516de6ae66e19bc8" translate="yes" xml:space="preserve">
          <source>Emits a value from the source Observable, then ignores subsequent source values for a duration determined by another Observable, then repeats this process.</source>
          <target state="translated">ソースObservableから値を放出し、別のObservableによって決定された期間、後続のソース値を無視し、このプロセスを繰り返します。</target>
        </trans-unit>
        <trans-unit id="9362d35a79ede3aa7be38e1b31753d1ce5e19bfa" translate="yes" xml:space="preserve">
          <source>Emits an object containing the current value, and the time that has passed between emitting the current value and the previous value, which is calculated by using the provided &lt;code&gt;scheduler&lt;/code&gt;'s &lt;code&gt;now()&lt;/code&gt; method to retrieve the current time at each emission, then calculating the difference. The &lt;code&gt;scheduler&lt;/code&gt; defaults to &lt;a href=&quot;../index/const/asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt;, so by default, the &lt;code&gt;interval&lt;/code&gt; will be in milliseconds.</source>
          <target state="translated">現在の値と、現在の値と以前の値の放出の間に経過した時間を含むオブジェクトを放出します。これは、提供さ &lt;code&gt;scheduler&lt;/code&gt; の &lt;code&gt;now()&lt;/code&gt; メソッドを使用して各放出の現在の時間を取得し、次に差。 &lt;code&gt;scheduler&lt;/code&gt; デフォルト&lt;a href=&quot;../index/const/asyncscheduler&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt;、そのデフォルトでは、 &lt;code&gt;interval&lt;/code&gt; ミリ秒単位になります。</target>
        </trans-unit>
        <trans-unit id="a0bc548abaef51ec19270a209d925069b3deaf16" translate="yes" xml:space="preserve">
          <source>Emits ascending numbers, one every second (1000ms) up to the number 3</source>
          <target state="translated">3までの昇順の数字、1秒に1つ(1000ms)を送信します。</target>
        </trans-unit>
        <trans-unit id="416f5c82d0c0c1e9c7bc782fe6a56560370e5e6d" translate="yes" xml:space="preserve">
          <source>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</source>
          <target state="translated">3秒後に始まる昇順番号、毎秒(1000ms)に1つを送信します。</target>
        </trans-unit>
        <trans-unit id="987c87f4a4f4e45515380da71ea51604f2c31a4c" translate="yes" xml:space="preserve">
          <source>Emits clicks happening on the DOM document</source>
          <target state="translated">DOM ドキュメント上で発生したクリックを表示します。</target>
        </trans-unit>
        <trans-unit id="fb68143f9c22c639fe4241870686be6e3443cf56" translate="yes" xml:space="preserve">
          <source>Emits false if the input observable emits any values, or emits true if the input observable completes without emitting any values.</source>
          <target state="translated">入力観測可能な値が出た場合はfalseを、値を出さずに入力観測可能な値が終了した場合はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="40866b2ae203c7bcd97be2c7b2bd3a74f920770b" translate="yes" xml:space="preserve">
          <source>Emits incremental numbers periodically in time.</source>
          <target state="translated">周期的にインクリメンタルな数字を表示します。</target>
        </trans-unit>
        <trans-unit id="dfc6629a60560428832a42a80e579e178deeedea" translate="yes" xml:space="preserve">
          <source>Emits one number after five seconds</source>
          <target state="translated">5秒後に1つの数字を発する</target>
        </trans-unit>
        <trans-unit id="c8db73b5e36157de7f7351e274e9b9ff88a812aa" translate="yes" xml:space="preserve">
          <source>Emits only the first &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable.</source>
          <target state="translated">ソースObservableによって発行された最初の &lt;code&gt;count&lt;/code&gt; 値のみを発行します。</target>
        </trans-unit>
        <trans-unit id="8578296e355b5b8276c06eca98343ce699c77a41" translate="yes" xml:space="preserve">
          <source>Emits only the first value (or the first value that meets some condition) emitted by the source Observable.</source>
          <target state="translated">ソースObservableによって放出された最初の値(または何らかの条件を満たす最初の値)のみを放出します。</target>
        </trans-unit>
        <trans-unit id="ee4e2bb5f62bd3a3b6a3b8f9742dadbb7c8fd314" translate="yes" xml:space="preserve">
          <source>Emits only the first value emitted by the source Observable that meets some condition.</source>
          <target state="translated">ある条件を満たすソースObservableによって放出された最初の値のみを放出します。</target>
        </trans-unit>
        <trans-unit id="d453139a17724a88567155f88992de9a43704fed" translate="yes" xml:space="preserve">
          <source>Emits only the first value. Or emits only the first value that passes some test.</source>
          <target state="translated">最初の値だけを出力します。または、何らかのテストに合格した最初の値のみを出力します。</target>
        </trans-unit>
        <trans-unit id="47bb0a635fba06f7e64359ed31cd996b61370dd0" translate="yes" xml:space="preserve">
          <source>Emits only the i-th value, then completes.</source>
          <target state="translated">i 番目の値のみを出力し、終了します。</target>
        </trans-unit>
        <trans-unit id="ce3a6a1ffd4b5b5bdb5c7fe2a320ecee099869c6" translate="yes" xml:space="preserve">
          <source>Emits only the index of the first value emitted by the source Observable that meets some condition.</source>
          <target state="translated">ある条件を満たすソースObservableによって放出された最初の値のインデックスのみを放出します。</target>
        </trans-unit>
        <trans-unit id="c942645033239d24b677fcb60f721a558bf5f73f" translate="yes" xml:space="preserve">
          <source>Emits only the last &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable.</source>
          <target state="translated">ソースObservableによって発行された最後の &lt;code&gt;count&lt;/code&gt; 値のみを発行します。</target>
        </trans-unit>
        <trans-unit id="633638a649508aa1d7574551df6b44843d5c0978" translate="yes" xml:space="preserve">
          <source>Emits the first click that happens on a DIV</source>
          <target state="translated">DIV上で発生した最初のクリックを表示します。</target>
        </trans-unit>
        <trans-unit id="33baacac631afed4cb4748baf32b4a71bcb00d28" translate="yes" xml:space="preserve">
          <source>Emits the given constant value on the output Observable every time the source Observable emits a value.</source>
          <target state="translated">ソースObservableが値を放出するたびに、与えられた定数値を出力Observableに放出します。</target>
        </trans-unit>
        <trans-unit id="471a2baa629dc6681c52e99caccf2f18b0e2938c" translate="yes" xml:space="preserve">
          <source>Emits the most recently emitted value from the source Observable whenever another Observable, the &lt;code&gt;notifier&lt;/code&gt;, emits.</source>
          <target state="translated">別のObservable、 &lt;code&gt;notifier&lt;/code&gt; が発行するたびに、ソースObservableから最後に発行された値を発行します。</target>
        </trans-unit>
        <trans-unit id="2254e36517076818c8f4383fb5e0ecdaf0d2521b" translate="yes" xml:space="preserve">
          <source>Emits the most recently emitted value from the source Observable within periodic time intervals.</source>
          <target state="translated">周期的な時間間隔で観測可能なソースから最近放出された値を放出します。</target>
        </trans-unit>
        <trans-unit id="c275f10e004389aaf9cbd780140b6f96348805dc" translate="yes" xml:space="preserve">
          <source>Emits the numbers 1 to 10</source>
          <target state="translated">1から10までの数字を表示</target>
        </trans-unit>
        <trans-unit id="33e3a9ae3cb8e784f5aecfedde6103fba869fe5b" translate="yes" xml:space="preserve">
          <source>Emits the single value at the specified &lt;code&gt;index&lt;/code&gt; in a sequence of emissions from the source Observable.</source>
          <target state="translated">ソースObservableからの一連の放出の指定された &lt;code&gt;index&lt;/code&gt; で単一の値を放出します。</target>
        </trans-unit>
        <trans-unit id="1a493989aa04d9a64a56db66249f73aafd987eda" translate="yes" xml:space="preserve">
          <source>Emits the values emitted by the source Observable until a &lt;code&gt;notifier&lt;/code&gt; Observable emits a value.</source>
          <target state="translated">&lt;code&gt;notifier&lt;/code&gt; Observableが値を発行するまで、ソースObservableが発行した値を発行します。</target>
        </trans-unit>
        <trans-unit id="3c7bee64498c2a7e9a5a73840f298dd4a0a008ee" translate="yes" xml:space="preserve">
          <source>Emits values emitted by the source Observable so long as each value satisfies the given &lt;code&gt;predicate&lt;/code&gt;, and then completes as soon as this &lt;code&gt;predicate&lt;/code&gt; is not satisfied.</source>
          <target state="translated">各値が指定された &lt;code&gt;predicate&lt;/code&gt; を満たす限り、ソースObservableによって発行された値を発行し、この &lt;code&gt;predicate&lt;/code&gt; が満たされないときにすぐに完了します。</target>
        </trans-unit>
        <trans-unit id="4a93d62619ac813564e9da8a4eebdc9e63296f52" translate="yes" xml:space="preserve">
          <source>EmptyError</source>
          <target state="translated">EmptyError</target>
        </trans-unit>
        <trans-unit id="c6a5baec1a656a6918482ae0a38e309a4e174ed7" translate="yes" xml:space="preserve">
          <source>EmptyObservable</source>
          <target state="translated">EmptyObservable</target>
        </trans-unit>
        <trans-unit id="c919a5ad2e7fdd8f109a1caa5d1715b51ed11664" translate="yes" xml:space="preserve">
          <source>Ensure a specific scheduler is used, from outside of an Observable.</source>
          <target state="translated">Observable の外部から、特定のスケジューラが使用されることを確認します。</target>
        </trans-unit>
        <trans-unit id="83c2c62e8479762708c16c7da93e27d58c64626d" translate="yes" xml:space="preserve">
          <source>Ensure values in subscribe are called just before browser repaint.</source>
          <target state="translated">ブラウザの再描画の直前に subscribe の値が呼び出されるようにします。</target>
        </trans-unit>
        <trans-unit id="c2e8a31728f0c93cb4c1c3ea370cd7225cf97657" translate="yes" xml:space="preserve">
          <source>Ergonomic defaults for &lt;code&gt;hot&lt;/code&gt; and &lt;code&gt;cold&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hot&lt;/code&gt; と &lt;code&gt;cold&lt;/code&gt; 人間工学に基づいたデフォルト</target>
        </trans-unit>
        <trans-unit id="b8a2a7f6e5c6d27ddebfed1897c207d4db559890" translate="yes" xml:space="preserve">
          <source>Error Handling Operators</source>
          <target state="translated">エラー処理演算子</target>
        </trans-unit>
        <trans-unit id="9ceb71ac05eb7c0d4e0f71e59f027348742ea94e" translate="yes" xml:space="preserve">
          <source>ErrorObservable</source>
          <target state="translated">ErrorObservable</target>
        </trans-unit>
        <trans-unit id="459dd73e2f9690fb4438b0975a4b05b0ce7cfa81" translate="yes" xml:space="preserve">
          <source>ErrorObserver</source>
          <target state="translated">ErrorObserver</target>
        </trans-unit>
        <trans-unit id="5e34fb3687b1278339ee0d3379e624bb84cd98a9" translate="yes" xml:space="preserve">
          <source>Errors if Observable does not emit a value in given time span, in case of which subscribes to the second Observable.</source>
          <target state="translated">Observableが2番目のObservableを購読している場合、Observableが指定された時間内に値を出さなかった場合にエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="6e5818bcafbec15ddf51911a2500238bc9d154f3" translate="yes" xml:space="preserve">
          <source>Errors if Observable does not emit a value in given time span.</source>
          <target state="translated">Observableが指定された時間内に値を出力しなかった場合のエラー。</target>
        </trans-unit>
        <trans-unit id="38f019ec5a63549d3da60d25881b1179dbc406bc" translate="yes" xml:space="preserve">
          <source>Eventually, you will want to &lt;a href=&quot;migration#drop-compat&quot;&gt;drop the compatibility layer&lt;/a&gt; to complete the update to RxJS v6. Doing so will significantly decrease the size of your apps.</source>
          <target state="translated">最終的には&lt;a href=&quot;migration#drop-compat&quot;&gt;、互換性レイヤー&lt;/a&gt;を削除して、 RxJS v6への更新を完了する必要があります。そうすることで、アプリのサイズが大幅に減少します。</target>
        </trans-unit>
        <trans-unit id="d18cb123476987ea913bfeca6bc87919f03bebfc" translate="yes" xml:space="preserve">
          <source>Every 5 seconds start a window 1 second long, and emit at most 2 click events per window</source>
          <target state="translated">5秒ごとに1秒の長さのウィンドウを開始し、1つのウィンドウにつき最大2つのクリックイベントを発生させます。</target>
        </trans-unit>
        <trans-unit id="cb9905734da60c3cce52678ea5d32b0f08238cd2" translate="yes" xml:space="preserve">
          <source>Every 5 seconds, emit the click events from the next 2 seconds</source>
          <target state="translated">5秒ごとに、次の2秒からのクリックイベントを放出する</target>
        </trans-unit>
        <trans-unit id="90c6a7e49deda3f103b834960dca350177cc2e5b" translate="yes" xml:space="preserve">
          <source>Every JavaScript Function is a Pull system. The function is a Producer of data, and the code that calls the function is consuming it by &quot;pulling&quot; out a &lt;em&gt;single&lt;/em&gt; return value from its call.</source>
          <target state="translated">すべてのJavaScript関数はプルシステムです。関数はデータのプロデューサーであり、関数を呼び出すコードは、その呼び出しからの&lt;em&gt;単一の&lt;/em&gt;戻り値を「引き出す」ことによってそれを消費します。</target>
        </trans-unit>
        <trans-unit id="568b3d67354a5fa6ac1d4ef7693c00e90a54fb43" translate="yes" xml:space="preserve">
          <source>Every Subject is an Observable and an Observer. You can subscribe to a Subject, and you can call next to feed values as well as error and complete.</source>
          <target state="translated">すべてのSubjectはObservableとObserverです。Subjectをサブスクライブすることができ、エラーや完了だけでなく、フィード値のnextを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="1aa05f062d0202c71119ad89e743230455866b79" translate="yes" xml:space="preserve">
          <source>Every other second, emit the click events from the next 500ms</source>
          <target state="translated">1秒おきに、次の500msからのクリックイベントを放出する</target>
        </trans-unit>
        <trans-unit id="d7a66bf925858e2f45ba1914ac8b54a09fb42dc1" translate="yes" xml:space="preserve">
          <source>Every second, emit an array of the recent click events</source>
          <target state="translated">1秒ごとに、最近のクリックイベントの配列を出力します。</target>
        </trans-unit>
        <trans-unit id="fe3c8aa86bdfe0f0edf5b8b63b533f703120c08f" translate="yes" xml:space="preserve">
          <source>Every second, emit the most recent click at most once</source>
          <target state="translated">1秒ごとに、最新のクリックを1回までに放出する</target>
        </trans-unit>
        <trans-unit id="d33c52a1410cde2ffc8ffc9c4edd53ef14bdbed3" translate="yes" xml:space="preserve">
          <source>Every time an inner Observable emits, the output Observable emits</source>
          <target state="translated">内側のObservableが発光するたびに、出力Observableが発光します。</target>
        </trans-unit>
        <trans-unit id="19ed07cf669163fd549db2eac802f1a0db6dcee4" translate="yes" xml:space="preserve">
          <source>Every time resulting Observable is subscribed, event handler function will be registered to event target on given event type. When that event fires, value passed as a first argument to registered function will be emitted by output Observable. When Observable is unsubscribed, function will be unregistered from event target.</source>
          <target state="translated">出来上がったObservableがサブスクライブされるたびに、指定されたイベントタイプのイベントターゲットにイベントハンドラ関数が登録されます。そのイベントが発生すると、登録された関数の第一引数に渡された値が出力されます。Observableの購読が解除されると、関数の登録は解除されます。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="392fe123059b9042a525c45fd36c5654d0b87c0c" translate="yes" xml:space="preserve">
          <source>Execute series of Observables no matter what, even if it means swallowing errors.</source>
          <target state="translated">エラーを飲み込むことになっても、何があってもObservablesの系列を実行します。</target>
        </trans-unit>
        <trans-unit id="ffa0db8a0362fcc46cdb81bf76f1fdb699e21fa2" translate="yes" xml:space="preserve">
          <source>Executing Observables</source>
          <target state="translated">観測可能ファイルの実行</target>
        </trans-unit>
        <trans-unit id="71a576c62e540f89942e39482d77e573b45c5750" translate="yes" xml:space="preserve">
          <source>Factory function to create an intermediate subject through which the source sequence's elements will be multicast to the selector function or Subject to push source elements into.</source>
          <target state="translated">ソースシーケンスの要素をセレクタ機能またはソース要素をプッシュするサブジェクトにマルチキャストするための中間サブジェクトを作成するためのファクトリ関数です。</target>
        </trans-unit>
        <trans-unit id="49ebe28cd9d8a3b499e2ee48c4519d62f46db7ff" translate="yes" xml:space="preserve">
          <source>FactoryOrValue</source>
          <target state="translated">FactoryOrValue</target>
        </trans-unit>
        <trans-unit id="b2b3f280ebecac0f650af8442da0c28b812dc3a1" translate="yes" xml:space="preserve">
          <source>Filter items emitted by the source Observable by only emitting those that satisfy a specified predicate.</source>
          <target state="translated">指定された述語を満たすものだけを放出することで、ソースObservableによって放出される項目をフィルタリングします。</target>
        </trans-unit>
        <trans-unit id="40e34b6dd8be897316b63fbba02a18e6929f348e" translate="yes" xml:space="preserve">
          <source>Filtering Operators</source>
          <target state="translated">フィルタリング演算子</target>
        </trans-unit>
        <trans-unit id="e8471e9cac7e3ccd5d662762dfc077ee68ce5fa5" translate="yes" xml:space="preserve">
          <source>Find and emit the first click that happens on a DIV element</source>
          <target state="translated">DIV要素上で発生した最初のクリックを検索して表示する</target>
        </trans-unit>
        <trans-unit id="bdde1667c7637fa9e392561fe37a9129b5e37d35" translate="yes" xml:space="preserve">
          <source>Finds the first value that passes some test and emits that.</source>
          <target state="translated">何らかのテストに合格した最初の値を見つけ、それを出力します。</target>
        </trans-unit>
        <trans-unit id="e93ac40354ce3c02e55c7b9d6be7101043533708" translate="yes" xml:space="preserve">
          <source>First Observer subscribes to the multicasted Observable</source>
          <target state="translated">最初のオブザーバは、マルチキャストされたObservableにサブスクライブします。</target>
        </trans-unit>
        <trans-unit id="9f43d22726f1db010faa50c5dad1f4baef24a307" translate="yes" xml:space="preserve">
          <source>First Observer unsubscribes from the multicasted Observable</source>
          <target state="translated">最初のオブザーバは、マルチキャストされたObservableからのサブスクライブを解除します。</target>
        </trans-unit>
        <trans-unit id="2c0a59b2a738934720a981af4caf0f2257febc5f" translate="yes" xml:space="preserve">
          <source>First emits its arguments in order, and then any emissions from the source.</source>
          <target state="translated">最初にその引数を順番に排出し、その後、ソースからの任意の排出を行います。</target>
        </trans-unit>
        <trans-unit id="8447958c50fe14e1542bd2daf039b6f88aec1dcb" translate="yes" xml:space="preserve">
          <source>First examples</source>
          <target state="translated">第一例</target>
        </trans-unit>
        <trans-unit id="3e6017001d21808ecf90abeb0ea1829904c30600" translate="yes" xml:space="preserve">
          <source>Flattens an Observable-of-Observables by applying &lt;a href=&quot;../index/function/combinelatest&quot;&gt;&lt;code&gt;combineLatest&lt;/code&gt;&lt;/a&gt; when the Observable-of-Observables completes.</source>
          <target state="translated">Observable-of-Observablesが完了したときに、&lt;a href=&quot;../index/function/combinelatest&quot;&gt; &lt;code&gt;combineLatest&lt;/code&gt; &lt;/a&gt;を適用して、Observable-of-Observablesをフラット化します。</target>
        </trans-unit>
        <trans-unit id="04cfff7f117896451c5efe35700ad71de1b0e885" translate="yes" xml:space="preserve">
          <source>Flattens an Observable-of-Observables by dropping the next inner Observables while the current inner is still executing.</source>
          <target state="translated">現在の内側が実行中の間に次の内側のObservablesをドロップすることで、Observable-of-Observablesをフラット化します。</target>
        </trans-unit>
        <trans-unit id="7c4a395e33ae8f3613262bc17d460166f11f9771" translate="yes" xml:space="preserve">
          <source>Flattens an Observable-of-Observables by putting one inner Observable after the other.</source>
          <target state="translated">内側のObservableを次々に配置することで、Observable-of-Observableを平坦化します。</target>
        </trans-unit>
        <trans-unit id="6261077d2db4f0f01ad8b5805900564289137493" translate="yes" xml:space="preserve">
          <source>Flattens an Observable-of-Observables.</source>
          <target state="translated">観測可能な観測値を平坦化します。</target>
        </trans-unit>
        <trans-unit id="336fdc425e8fb1e80985b24a579f686f6a6e2009" translate="yes" xml:space="preserve">
          <source>Flattens multiple Observables together by blending their values into one Observable.</source>
          <target state="translated">複数のObservableの値を1つのObservableにブレンドすることで、複数のObservableをフラット化します。</target>
        </trans-unit>
        <trans-unit id="86eff8eb789b097ddca83f2c9c4617ed23605105" translate="yes" xml:space="preserve">
          <source>Flow</source>
          <target state="translated">Flow</target>
        </trans-unit>
        <trans-unit id="3c706a96d542205f77531708a1c3b3097bd865a3" translate="yes" xml:space="preserve">
          <source>For CDN, you can use &lt;a href=&quot;https://unpkg.com/&quot;&gt;unpkg&lt;/a&gt;. Just replace version with the current version on the link below:</source>
          <target state="translated">CDNの場合は、&lt;a href=&quot;https://unpkg.com/&quot;&gt;unpkg&lt;/a&gt;を使用できます。以下のリンクでバージョンを現在のバージョンに置き換えるだけです。</target>
        </trans-unit>
        <trans-unit id="4dfc618a631337e10398e7c78f1909641f8774de" translate="yes" xml:space="preserve">
          <source>For JavaScript developers, the general rule is as follows:</source>
          <target state="translated">JavaScript開発者にとって、一般的なルールは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b93bc381a837cdd2e8f67790fd49b772a51d3702" translate="yes" xml:space="preserve">
          <source>For RxJS 5.0.0-beta.1 through beta.11: &lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.umd.js&quot;&gt;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.umd.js&lt;/a&gt;</source>
          <target state="translated">RxJS 5.0.0-beta.1〜beta.11の場合：&lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.umd.js&quot;&gt;https&lt;/a&gt; ://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.umd.js</target>
        </trans-unit>
        <trans-unit id="b2cc880d660c8400030b8519a180258b600db213" translate="yes" xml:space="preserve">
          <source>For RxJS 5.0.0-beta.12 and higher: &lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.js&quot;&gt;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.js&lt;/a&gt;</source>
          <target state="translated">RxJS 5.0.0-beta.12以降の場合：&lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.js&quot;&gt;https&lt;/a&gt; ://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.js</target>
        </trans-unit>
        <trans-unit id="30781bd7122d9317d92dfe60463848c929299e16" translate="yes" xml:space="preserve">
          <source>For RxJS 6.0.0 and higher: &lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/rxjs.umd.js&quot;&gt;https://unpkg.com/@reactivex/rxjs@version/dist/global/rxjs.umd.js&lt;/a&gt;</source>
          <target state="translated">RxJS 6.0.0以降の場合：&lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/rxjs.umd.js&quot;&gt;https&lt;/a&gt; ://unpkg.com/@reactivex/rxjs@version/dist/global/rxjs.umd.js</target>
        </trans-unit>
        <trans-unit id="3aacb38d3ba8f1eca27a7d04d08c9ec383211f28" translate="yes" xml:space="preserve">
          <source>For a complete overview, see the &lt;a href=&quot;https://rxjs.dev/api&quot;&gt;references page&lt;/a&gt;.</source>
          <target state="translated">完全な概要については、&lt;a href=&quot;https://rxjs.dev/api&quot;&gt;リファレンスページをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="71adf40f1b3801502c368d773ac928b5fff11968" translate="yes" xml:space="preserve">
          <source>For a full explanation of what you will have to update in order to remove &lt;code&gt;rxjs-compat&lt;/code&gt;, see &lt;a href=&quot;migration#drop-compat&quot;&gt;Dropping the compatibility layer&lt;/a&gt;. Note also that fully updating your application to v6 may expose existing type errors that were not previously shown.</source>
          <target state="translated">&lt;code&gt;rxjs-compat&lt;/code&gt; を削除するために何を更新する必要があるかについて詳しくは&lt;a href=&quot;migration#drop-compat&quot;&gt;、互換性レイヤーの&lt;/a&gt;削除をご覧ください。また、アプリケーションをv6に完全に更新すると、以前は表示されなかった既存のタイプエラーが発生する可能性があることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="3075c8d5f2ddd9453495c23a6d3a85a860c95665" translate="yes" xml:space="preserve">
          <source>For details about this package, see &lt;a href=&quot;https://www.npmjs.com/package/rxjs-compat&quot;&gt;https://www.npmjs.com/package/rxjs-compat&lt;/a&gt;.</source>
          <target state="translated">このパッケージの詳細については、&lt;a href=&quot;https://www.npmjs.com/package/rxjs-compat&quot;&gt;https：//www.npmjs.com/package/rxjs-compatを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cd428686c6c90545d8b2bcd91920f91a6a7f16b7" translate="yes" xml:space="preserve">
          <source>For each click event, start an interval Observable ticking every 1 second</source>
          <target state="translated">クリックイベントごとに、1秒ごとにクリックする間隔のObservableを開始します。</target>
        </trans-unit>
        <trans-unit id="9b5bd25151ae50ac80cb48151094fd9a522bc6b1" translate="yes" xml:space="preserve">
          <source>For each click event, tick every second from 0 to 3, with no concurrency</source>
          <target state="translated">各クリックイベントに対して、0 から 3 までの間で 1 秒ごとに目盛りを付け、同時実行はしません。</target>
        </trans-unit>
        <trans-unit id="da73e6bc7c69579ce47d156493aaad13c78b9719" translate="yes" xml:space="preserve">
          <source>For example, the following code uses chaining:</source>
          <target state="translated">例えば、次のコードではチェーニングを使用しています。</target>
        </trans-unit>
        <trans-unit id="1390fdbdab4c48752843cc3d3c5e3771179171fc" translate="yes" xml:space="preserve">
          <source>For example, the operator called &lt;a href=&quot;../api/operators/map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; is analogous to the Array method of the same name. Just as &lt;code&gt;[1, 2, 3].map(x =&amp;gt; x * x)&lt;/code&gt; will yield &lt;code&gt;[1, 4, 9]&lt;/code&gt;, the Observable created like this:</source>
          <target state="translated">たとえば、&lt;a href=&quot;../api/operators/map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;という演算子は、同じ名前のArrayメソッドに似ています。同じように &lt;code&gt;[1, 2, 3].map(x =&amp;gt; x * x)&lt;/code&gt; 得られます &lt;code&gt;[1, 4, 9]&lt;/code&gt; 、このように作成された観測：</target>
        </trans-unit>
        <trans-unit id="853b2727d71c0f828cbb891d5a55aed1ec783449" translate="yes" xml:space="preserve">
          <source>For example, you could make a function that discarded odd values and doubled even values like this:</source>
          <target state="translated">例えば、奇数値を破棄して偶数値を倍にする関数を以下のように作ることができます。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="ec273ba7965ca090ef888c5ba8c99a2ff30f1dec" translate="yes" xml:space="preserve">
          <source>For instance, this is how we clear an interval execution set with &lt;code&gt;setInterval&lt;/code&gt;:</source>
          <target state="translated">たとえば、これは &lt;code&gt;setInterval&lt;/code&gt; で設定された間隔実行をクリアする方法です。</target>
        </trans-unit>
        <trans-unit id="e26f23e8b0af8cdf983bb14b29d6d328a65014a9" translate="yes" xml:space="preserve">
          <source>For instance, with &lt;code&gt;zip&lt;/code&gt;, we would write</source>
          <target state="translated">たとえば、 &lt;code&gt;zip&lt;/code&gt; では、次のように記述します</target>
        </trans-unit>
        <trans-unit id="838888620b40e19c6ff7033090befe975b7f38ac" translate="yes" xml:space="preserve">
          <source>For typings users:</source>
          <target state="translated">タイピングをお使いの方へ</target>
        </trans-unit>
        <trans-unit id="0e64fe21f9689afc29ace240393c9a0373103b20" translate="yes" xml:space="preserve">
          <source>ForkJoinObservable</source>
          <target state="translated">ForkJoinObservable</target>
        </trans-unit>
        <trans-unit id="1c20ecad94bb21004fd90931f9cf9570a480d646" translate="yes" xml:space="preserve">
          <source>FromEventObservable</source>
          <target state="translated">FromEventObservable</target>
        </trans-unit>
        <trans-unit id="c3e704712cb43291834e2a5aa665ac60fe6ead64" translate="yes" xml:space="preserve">
          <source>FromEventPatternObservable</source>
          <target state="translated">FromEventPatternObservable</target>
        </trans-unit>
        <trans-unit id="ba952857f29ad095dbdd44119f64aee2803a96d9" translate="yes" xml:space="preserve">
          <source>FromObservable</source>
          <target state="translated">FromObservable</target>
        </trans-unit>
        <trans-unit id="621c78a2e74d2dc796c3b71647b55c0326ffa66c" translate="yes" xml:space="preserve">
          <source>Function to be called when source terminates.</source>
          <target state="translated">ソースが終了したときに呼び出される関数。</target>
        </trans-unit>
        <trans-unit id="957c5944acd33361e7062dcad7a7a9a695d6b332" translate="yes" xml:space="preserve">
          <source>Functional composition is awesome. Building your own custom operators becomes much easier, and now they work and look just like all other operators in rxjs. You don't need to extend Observable or override &lt;code&gt;lift&lt;/code&gt; anymore.</source>
          <target state="translated">機能的な構成は素晴らしいです。独自のカスタムオペレーターの作成がはるかに簡単になり、rxjsの他のすべてのオペレーターと同じように機能します。Observableを拡張したり、 &lt;code&gt;lift&lt;/code&gt; オーバーライドしたりする必要はもうありません。</target>
        </trans-unit>
        <trans-unit id="3889ea8611c26a725e8465c567a219fb5666a68d" translate="yes" xml:space="preserve">
          <source>Functions can only return one value. Observables, however, can do this:</source>
          <target state="translated">関数は1つの値しか返すことができません。しかし、Observablesはこれを行うことができます。</target>
        </trans-unit>
        <trans-unit id="303e10207f177b23a328afb3ed7c795eb19ec395" translate="yes" xml:space="preserve">
          <source>Generate new Observable according to source Observable values</source>
          <target state="translated">ソースのObservableの値に応じて新しいObservableを生成します。</target>
        </trans-unit>
        <trans-unit id="5bc786743f08df2282eeb88bdd929373a66a5cbd" translate="yes" xml:space="preserve">
          <source>GenerateObservable</source>
          <target state="translated">GenerateObservable</target>
        </trans-unit>
        <trans-unit id="81c0c27865a5aabbe78b36634e674339ea12f03f" translate="yes" xml:space="preserve">
          <source>Generates an Observable by running a state-driven loop that emits an element on each iteration.</source>
          <target state="translated">状態駆動ループを実行してObservableを生成し、各反復で要素を放出します。</target>
        </trans-unit>
        <trans-unit id="54ff995c1db460f7d4ec8a43c9ff7df5b3307597" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages.</source>
          <target state="translated">シーケンスの要素を生成する状態駆動ループを実行して観測可能なシーケンスを生成し、指定されたスケジューラを使用してオブザーバメッセージを送信します。</target>
        </trans-unit>
        <trans-unit id="98b825ac41b8397865bf35074f515a8f5e86edd2" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages. The overload accepts options object that might contain initial state, iterate, condition and scheduler.</source>
          <target state="translated">シーケンスの要素を生成する状態駆動ループを実行し、指定されたスケジューラを用いてオブザーバメッセージを送信することで、観測可能なシーケンスを生成します。オーバーロードは、初期状態、反復、条件、スケジューラを含むオプションオブジェクトを受け付けます。</target>
        </trans-unit>
        <trans-unit id="ad90c1a944ee3fa6d5c7be853db7c58d15ddb878" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages. The overload accepts options object that might contain initial state, iterate, condition, result selector and scheduler.</source>
          <target state="translated">シーケンスの要素を生成する状態駆動ループを実行し、指定されたスケジューラを用いてオブザーバメッセージを送信することで、オブザーバ可能なシーケンスを生成します。オーバーロードは、初期状態、反復、条件、結果セレクタ、スケジューラを含むオプションオブジェクトを受け付けます。</target>
        </trans-unit>
        <trans-unit id="57184ea89e0ad3d9688251dfe4bd88d9b6a4b24c" translate="yes" xml:space="preserve">
          <source>Generating PNG marble diagrams from tests</source>
          <target state="translated">テストからPNGマーブル図を生成する</target>
        </trans-unit>
        <trans-unit id="551763240307b358e2541252c4ea9844aad40ac7" translate="yes" xml:space="preserve">
          <source>Get all values inside an array when the source completes</source>
          <target state="translated">ソースが完了したときに配列内のすべての値を取得します。</target>
        </trans-unit>
        <trans-unit id="6192885702ae8a6bc4b4e65f4064742ed47013e0" translate="yes" xml:space="preserve">
          <source>Get the maximal value of a series of numbers</source>
          <target state="translated">数列の最大値を取得します。</target>
        </trans-unit>
        <trans-unit id="cd9b12ae584c39e58461f2d1c2bc7b2d2d918c83" translate="yes" xml:space="preserve">
          <source>Get the minimal value of a series of numbers</source>
          <target state="translated">連続した数値の最小値を取得します。</target>
        </trans-unit>
        <trans-unit id="82645a0e54372b3bd69d16159415e8bede299b3c" translate="yes" xml:space="preserve">
          <source>Give it a function &lt;code&gt;f&lt;/code&gt; of type &lt;code&gt;f(x, callback)&lt;/code&gt; and it will return a function &lt;code&gt;g&lt;/code&gt; that when called as &lt;code&gt;g(x)&lt;/code&gt; will output an Observable.</source>
          <target state="translated">タイプ &lt;code&gt;f(x, callback)&lt;/code&gt; 関数 &lt;code&gt;f&lt;/code&gt; を与えると、 &lt;code&gt;g(x)&lt;/code&gt; として呼び出されるとObservableを出力する関数 &lt;code&gt;g&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="6f36b89b671804ed1110fb922788cc37c4a564fe" translate="yes" xml:space="preserve">
          <source>Given a hot source, test multiple subscribers that subscribe at different times:</source>
          <target state="translated">ホットソースがある場合、異なる時間に購読する複数の購読者をテストします。</target>
        </trans-unit>
        <trans-unit id="39da52064d9093fec3f687f9ef3a311b61691213" translate="yes" xml:space="preserve">
          <source>Given a list of strings describing a path to an object property, retrieves the value of a specified nested property from all values in the source Observable. If a property can't be resolved, it will return &lt;code&gt;undefined&lt;/code&gt; for that value.</source>
          <target state="translated">オブジェクトプロパティへのパスを説明する文字列のリストを指定して、ソースObservableのすべての値から、指定されたネストされたプロパティの値を取得します。プロパティを解決できない場合、その値は &lt;code&gt;undefined&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="07449bc0c82fd975877782bde1b7acc37ead6d3e" translate="yes" xml:space="preserve">
          <source>Given some &lt;a href=&quot;../interface/observer&quot;&gt;&lt;code&gt;Observer&lt;/code&gt;&lt;/a&gt; callbacks, deliver the value represented by the current Notification to the correctly corresponding callback.</source>
          <target state="translated">いくつかの&lt;a href=&quot;../interface/observer&quot;&gt; &lt;code&gt;Observer&lt;/code&gt; &lt;/a&gt;コールバックを指定して、現在の通知で表される値を、対応する適切なコールバックに配信します。</target>
        </trans-unit>
        <trans-unit id="54f2ff8a238acabb2079588d5c2033656ef069ee" translate="yes" xml:space="preserve">
          <source>Given the following code:</source>
          <target state="translated">以下のコードが与えられているとします。</target>
        </trans-unit>
        <trans-unit id="c124c9fdd71373efa4b6882f80c535df13098af6" translate="yes" xml:space="preserve">
          <source>Group objects by id and return as array</source>
          <target state="translated">id でオブジェクトをグループ化し、配列として返す</target>
        </trans-unit>
        <trans-unit id="dc85de0c8d1aa8d1842c6bc27349fd8488ab304a" translate="yes" xml:space="preserve">
          <source>GroupedObservable</source>
          <target state="translated">GroupedObservable</target>
        </trans-unit>
        <trans-unit id="29da1b8ea5e10bb6cee089501b380d1c22317b19" translate="yes" xml:space="preserve">
          <source>GroupedObservable._subscribe()</source>
          <target state="translated">GroupedObservable._subscribe()</target>
        </trans-unit>
        <trans-unit id="67a5ee349162f7ac679862e2cb19c477ef489ade" translate="yes" xml:space="preserve">
          <source>Groups pairs of consecutive emissions together and emits them as an array of two values.</source>
          <target state="translated">連続した排出のペアをグループ化し、2つの値の配列として排出します。</target>
        </trans-unit>
        <trans-unit id="20050b3ab03e9f7ad2f940b4b5719c213555e0f0" translate="yes" xml:space="preserve">
          <source>Groups the items emitted by an Observable according to a specified criterion, and emits these grouped items as &lt;code&gt;GroupedObservables&lt;/code&gt;, one &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; per group.</source>
          <target state="translated">指定された基準に従ってObservableによって &lt;code&gt;GroupedObservables&lt;/code&gt; れたアイテムをグループ化し、これらのグループ化されたアイテムをグループごとに1つの&lt;a href=&quot;../index/class/groupedobservable&quot;&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; &lt;/a&gt;としてGroupedObservablesとして発行します。</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">ガイド</target>
        </trans-unit>
        <trans-unit id="1c928db5e3e6d1f30a2aed1390d012555c85e156" translate="yes" xml:space="preserve">
          <source>Here are different ways you can install RxJs:</source>
          <target state="translated">ここでは、RxJsをインストールするための様々な方法を紹介します。</target>
        </trans-unit>
        <trans-unit id="3a5385a2e5e53ebc1302f5ef2e06bfb489acf042" translate="yes" xml:space="preserve">
          <source>Here is an example of a user-defined prototype operator:</source>
          <target state="translated">ここでは、ユーザ定義のプロトタイプ演算子の例を示します。</target>
        </trans-unit>
        <trans-unit id="c07d60dcb84ebdbbf843c148434b505c3237d745" translate="yes" xml:space="preserve">
          <source>Here's how you can add the current mouse x position for every click, in plain JavaScript:</source>
          <target state="translated">ここでは、クリックするたびに現在のマウスの x 位置を、プレーンな JavaScript で追加する方法を紹介します。</target>
        </trans-unit>
        <trans-unit id="7e8f1c39f2eee220aa407a7a27af05dd7e03a1ba" translate="yes" xml:space="preserve">
          <source>Higher-order Observables</source>
          <target state="translated">高次の観測値</target>
        </trans-unit>
        <trans-unit id="03629c9d2b75927156ea1bbd28d4746b87641d9a" translate="yes" xml:space="preserve">
          <source>How many virtual milliseconds one frame represents depends on the value of &lt;code&gt;TestScheduler.frameTimeFactor&lt;/code&gt;. For legacy reasons the value of &lt;code&gt;frameTimeFactor&lt;/code&gt; is 1 &lt;em&gt;only&lt;/em&gt; when your code inside the &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; callback is running. Outside of it, it's set to 10. This will likely change in a future version of RxJS so that it is always 1.</source>
          <target state="translated">1フレームが表す仮想ミリ秒の数は、 &lt;code&gt;TestScheduler.frameTimeFactor&lt;/code&gt; の値によって異なります。従来の理由から、 &lt;code&gt;frameTimeFactor&lt;/code&gt; の値は、 &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; コールバック内のコードが実行されている場合に&lt;em&gt;のみ&lt;/em&gt; 1になります。それ以外では、10に設定されます。これは、RxJSの将来のバージョンで変更され、常に1になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="ac69cb6bdf7453f64d6f79219570637438301804" translate="yes" xml:space="preserve">
          <source>HowTo: Convert deprecated methods</source>
          <target state="translated">HowTo.非推奨のメソッドを変換する</target>
        </trans-unit>
        <trans-unit id="a70b4ef372737a8a66669faafec62818909ed3a7" translate="yes" xml:space="preserve">
          <source>HowTo: Convert to pipe syntax</source>
          <target state="translated">HowTo.パイプ構文に変換する</target>
        </trans-unit>
        <trans-unit id="36e080fecbaabae929b5fc636275d5fc7eb5d6cc" translate="yes" xml:space="preserve">
          <source>HowTo: Result selector migration</source>
          <target state="translated">HowTo.結果セレクタの移行</target>
        </trans-unit>
        <trans-unit id="8b929422af26da967f9b75d1aeabb1e1f639d189" translate="yes" xml:space="preserve">
          <source>IMPORTANT: This syntax guide refers to usage of marble diagrams when using the new &lt;code&gt;testScheduler.run(callback)&lt;/code&gt;. The semantics of marble diagrams when using the TestScheduler manually are different, and some features like the new time progression syntax are not supported.</source>
          <target state="translated">重要：この構文ガイドでは、新しい &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; を使用するときの大理石の図の使用について説明しています。TestSchedulerを手動で使用する場合の大理石図のセマンティクスは異なり、新しい時間進行構文などの一部の機能はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="40f0b7905e2da41f9e18c82b1b0614b2ffabfa2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; depends on some context (&lt;code&gt;this&lt;/code&gt; property) and is not already bound, the context of &lt;code&gt;func&lt;/code&gt; will be the context that the output function has at call time. In particular, if &lt;code&gt;func&lt;/code&gt; is called as a method of some objec and if &lt;code&gt;func&lt;/code&gt; is not already bound, in order to preserve the context it is recommended that the context of the output function is set to that object as well.</source>
          <target state="translated">場合 &lt;code&gt;func&lt;/code&gt; は、いくつかのコンテキスト（に依存し &lt;code&gt;this&lt;/code&gt; プロパティ）とすでにバインドされていない、の文脈 &lt;code&gt;func&lt;/code&gt; が出力関数は、呼び出し時に持っていることをコンテキストになります。特に、 &lt;code&gt;func&lt;/code&gt; がobjecのメソッドとして呼び出され、 &lt;code&gt;func&lt;/code&gt; がまだバインドされていない場合、コンテキストを保持するために、出力関数のコンテキストもそのオブジェクトに設定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="07c92379e38482d3edbd155b04331dd9b3b02da3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;onErrorResumeNext&lt;/code&gt; is provided no arguments, or a single, empty array, it will return &lt;a href=&quot;../const/empty&quot;&gt;&lt;code&gt;EMPTY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; に引数が指定されていない場合、または単一の空の配列が提供されている場合、&lt;a href=&quot;../const/empty&quot;&gt; &lt;code&gt;EMPTY&lt;/code&gt; &lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="b1c709af96b5325f3d70325ca645039104585d8e" translate="yes" xml:space="preserve">
          <source>If API you are using allows to unregister event handlers as well, you can pass to &lt;code&gt;fromEventPattern&lt;/code&gt; another function - &lt;code&gt;removeHandler&lt;/code&gt; - as a second parameter. It will be injected with the same handler function as before, which now you can use to unregister it from the API. &lt;code&gt;removeHandler&lt;/code&gt; will be called when consumer of resulting Observable unsubscribes from it.</source>
          <target state="translated">使用しているAPIでイベントハンドラーの登録を解除することもできる場合は、 &lt;code&gt;fromEventPattern&lt;/code&gt; に別の関数 &lt;code&gt;removeHandler&lt;/code&gt; 2番目のパラメーターとして渡すことができます。これには以前と同じハンドラー関数が注入され、APIからの登録解除に使用できるようになります。 &lt;code&gt;removeHandler&lt;/code&gt; は、結果のObservableのコンシューマーがそれからサブスクライブを解除したときに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="4af6c10fb1dd2648dc979da484b8a8053c819fb3" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; for this key exists, this &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; emits. Elsewhere, a new &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; for this key is created and emits.</source>
          <target state="translated">場合&lt;a href=&quot;../index/class/groupedobservable&quot;&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; &lt;/a&gt;このキーの存在が、この&lt;a href=&quot;../index/class/groupedobservable&quot;&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; を&lt;/a&gt;発します。他の場所では、このキーの新しい&lt;a href=&quot;../index/class/groupedobservable&quot;&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; &lt;/a&gt;が作成され、発行されます。</target>
        </trans-unit>
        <trans-unit id="df8b94facaadd3672b301652e68967bd50f31e88" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;project&lt;/code&gt; function is provided, it is called with each recent value from each inner Observable in whatever order they arrived, and the result of the &lt;code&gt;project&lt;/code&gt; function is what is emitted by the output Observable.</source>
          <target state="translated">場合は &lt;code&gt;project&lt;/code&gt; 機能が提供され、それは彼らが到着し、その結果どのような順序、各内側の観察可能な内から各近年の値で呼び出され &lt;code&gt;project&lt;/code&gt; 機能は、出力観察可能で放出されているものです。</target>
        </trans-unit>
        <trans-unit id="9a850724cf0766e1952f2eb5588d6e0108fae17b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;signal&lt;/code&gt; is provided via the &lt;code&gt;init&lt;/code&gt; argument, it will behave like it usually does with &lt;code&gt;fetch&lt;/code&gt;. If the provided &lt;code&gt;signal&lt;/code&gt; aborts, the error that &lt;code&gt;fetch&lt;/code&gt; normally rejects with in that scenario will be emitted as an error from the observable.</source>
          <target state="translated">&lt;code&gt;signal&lt;/code&gt; が &lt;code&gt;init&lt;/code&gt; 引数を介して提供される場合、それは通常 &lt;code&gt;fetch&lt;/code&gt; と同じように動作します。提供された &lt;code&gt;signal&lt;/code&gt; 異常終了した場合、そのシナリオで &lt;code&gt;fetch&lt;/code&gt; 通常拒否されるエラーは、オブザーバブルからエラーとして発行されます。</target>
        </trans-unit>
        <trans-unit id="028415691a9845121c3a2af04d5b598c1f3893a8" translate="yes" xml:space="preserve">
          <source>If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted. If a comparator function is not provided, an equality check is used by default.</source>
          <target state="translated">コンパレータ関数が提供されている場合、その値が放出されるべきかどうかをテストするために各項目ごとに呼び出されます。コンパレータ関数が提供されていない場合、デフォルトでは等質性チェックが使用されます。</target>
        </trans-unit>
        <trans-unit id="4b4b939b7eaab790925369773890c1bf7cf233c9" translate="yes" xml:space="preserve">
          <source>If a keySelector function is provided, then it will project each value from the source observable into a new value that it will check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the source observable directly with an equality check against previous values.</source>
          <target state="translated">keySelector関数が提供されている場合は、ソースオブザーバブルからの各値を新しい値に投影し、以前に投影された値との等質性をチェックします。keySelector関数が提供されていない場合は、ソースオブザーバブルからの各値を直接使用し、以前の値との等質性をチェックします。</target>
        </trans-unit>
        <trans-unit id="f37cc6878132becb067139744ba3d260310d9d74" translate="yes" xml:space="preserve">
          <source>If any Observable in chain errors, instead of passing control to the next Observable, &lt;code&gt;concat&lt;/code&gt; will error immediately as well. Observables that would be subscribed after the one that emitted error, never will.</source>
          <target state="translated">チェーン内のObservableにエラーが発生した場合、次のObservableに制御を渡す代わりに、 &lt;code&gt;concat&lt;/code&gt; もすぐにエラーになります。エラーを発行したオブザーバの後にサブスクライブされるオブザーバブルは、今後はサブスクライブされません。</target>
        </trans-unit>
        <trans-unit id="cb0b51e78db6718b4838278fc6306924448093f9" translate="yes" xml:space="preserve">
          <source>If any input observable errors at some point, &lt;code&gt;forkJoin&lt;/code&gt; will error as well and all other observables will be immediately unsubscribed.</source>
          <target state="translated">ある時点で入力の &lt;code&gt;forkJoin&lt;/code&gt; 可能なエラーが発生した場合、forkJoinもエラーになり、他のすべての監視可能なオブジェクトはすぐにサブスクライブ解除されます。</target>
        </trans-unit>
        <trans-unit id="b185bb62138ba5ed799cdcae2d55f53c229a1bb0" translate="yes" xml:space="preserve">
          <source>If at least one Observable was passed to &lt;code&gt;combineLatest&lt;/code&gt; and all passed Observables emitted something, resulting Observable will complete when all combined streams complete. So even if some Observable completes, result of &lt;code&gt;combineLatest&lt;/code&gt; will still emit values when other Observables do. In case of completed Observable, its value from now on will always be the last emitted value. On the other hand, if any Observable errors, &lt;code&gt;combineLatest&lt;/code&gt; will error immediately as well, and all other Observables will be unsubscribed.</source>
          <target state="translated">少なくとも1つのObservableが &lt;code&gt;combineLatest&lt;/code&gt; に渡され、渡されたすべてのObservableが何かを発行した場合、結合されたすべてのストリームが完了すると、結果のObservableが完了します。したがって、一部のObservableが完了しても、 &lt;code&gt;combineLatest&lt;/code&gt; の結果は、他のObservableが完了したときに値を発行します。 Observableが完了した場合、その値は今後常に最後に出力される値になります。一方、Observableエラーが発生した場合、 &lt;code&gt;combineLatest&lt;/code&gt; もすぐにエラーになり、他のすべてのObservableはサブスクライブ解除されます。</target>
        </trans-unit>
        <trans-unit id="1e0c62fb072d51f0442df156d8425d45e8d5cf22" translate="yes" xml:space="preserve">
          <source>If called with no arguments, &lt;code&gt;first&lt;/code&gt; emits the first value of the source Observable, then completes. If called with a &lt;code&gt;predicate&lt;/code&gt; function, &lt;code&gt;first&lt;/code&gt; emits the first value of the source that matches the specified condition. It may also take a deprecated &lt;code&gt;resultSelector&lt;/code&gt; function to produce the output value from the input value, and a &lt;code&gt;defaultValue&lt;/code&gt; to emit in case the source completes before it is able to emit a valid value. Throws an error if &lt;code&gt;defaultValue&lt;/code&gt; was not provided and a matching element is not found.</source>
          <target state="translated">引数なしで呼び出された場合、 &lt;code&gt;first&lt;/code&gt; にソースObservableの最初の値を発行し、次に完了します。 &lt;code&gt;predicate&lt;/code&gt; 関数で呼び出された場合、 &lt;code&gt;first&lt;/code&gt; 、指定された条件に一致するソースの最初の値を出力します。また、非推奨の &lt;code&gt;resultSelector&lt;/code&gt; 関数を使用して、入力値から出力値を生成し、有効な値を出力する前にソースが完了した場合に出力する &lt;code&gt;defaultValue&lt;/code&gt; を使用する場合もあります。 &lt;code&gt;defaultValue&lt;/code&gt; が指定されておらず、一致する要素が見つからない場合は、エラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="3bcd9d37561bf68f49980616d1911338e805195a" translate="yes" xml:space="preserve">
          <source>If no clicks happen in 5 seconds, then emit &quot;no clicks&quot;</source>
          <target state="translated">5秒以内にクリックが発生しなかった場合、&quot;no clicks &quot;を発する</target>
        </trans-unit>
        <trans-unit id="fe2f6c30c49a1d0418d15b8fce2ca69c14e338fe" translate="yes" xml:space="preserve">
          <source>If number was provided, it returns an Observable that behaves like a source Observable, unless there is a period of time where there is no value emitted. So if you provide &lt;code&gt;100&lt;/code&gt; as argument and first value comes after 50ms from the moment of subscription, this value will be simply re-emitted by the resulting Observable. If however after that 100ms passes without a second value being emitted, stream will end with an error and source Observable will be unsubscribed. These checks are performed throughout whole lifecycle of Observable - from the moment it was subscribed to, until it completes or errors itself. Thus every value must be emitted within specified period since previous value.</source>
          <target state="translated">数値が指定されている場合、値が発行されない期間がない限り、ソースのObservableのように動作するObservableを返します。したがって、引数として &lt;code&gt;100&lt;/code&gt; を指定し、サブスクリプションの瞬間から50ミリ秒後に最初の値が来る場合、この値は結果のObservableによって単純に再送信されます。ただし、2番目の値が発行されずに100ミリ秒経過すると、ストリームはエラーで終了し、ソースObservableはサブスクライブ解除されます。これらのチェックは、Observableのサブスクライブされた瞬間から完了またはエラー自体まで、Observableのライフサイクル全体を通じて実行されます。したがって、すべての値は、前の値から指定された期間内に放出される必要があります。</target>
        </trans-unit>
        <trans-unit id="9927bd26769cb903fed62e7a678f564c56dffc51" translate="yes" xml:space="preserve">
          <source>If provided argument was Date, returned Observable behaves differently. It throws if Observable did not complete before provided Date. This means that periods between emission of particular values do not matter in this case. If Observable did not complete before provided Date, source Observable will be unsubscribed. Other than that, resulting stream behaves just as source Observable.</source>
          <target state="translated">引数に Date を指定した場合、返された Observable の振る舞いは異なります。Observableが指定されたDateの前に完了しなかった場合はスローされます。つまり、この場合、特定の値の放出の間の期間は重要ではないということです。もしObservableが指定された日付より前に完了しなかった場合、ソースのObservableは購読解除されます。それ以外は、結果のストリームはソースObservableと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="f38eff0754b3ee76a87f735922543165f876702b" translate="yes" xml:space="preserve">
          <source>If the API you use is more callback then event handler oriented (subscribed callback function fires only once and thus there is no need to manually unregister it), you should use &lt;a href=&quot;bindcallback&quot;&gt;&lt;code&gt;bindCallback&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;bindnodecallback&quot;&gt;&lt;code&gt;bindNodeCallback&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">使用するAPIがコールバックよりイベントハンドラー指向の場合（サブスクライブしたコールバック関数は1回だけ起動するため、手動で登録を解除する必要はありません）、代わりに&lt;a href=&quot;bindcallback&quot;&gt; &lt;code&gt;bindCallback&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;bindnodecallback&quot;&gt; &lt;code&gt;bindNodeCallback&lt;/code&gt; &lt;/a&gt;を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="d701a75284d0a6eaaaeb95b5a8f86ab1226adb0a" translate="yes" xml:space="preserve">
          <source>If the delay argument is a Date, this operator time shifts the start of the Observable execution until the given date occurs.</source>
          <target state="translated">delay 引数が Date の場合、この演算子は指定された日付が発生するまで、Observable の実行開始をタイムシフトします。</target>
        </trans-unit>
        <trans-unit id="a35fe97591e295a1ffadb54ac04ce29d0914a39f" translate="yes" xml:space="preserve">
          <source>If the delay argument is a Number, this operator time shifts the source Observable by that amount of time expressed in milliseconds. The relative time intervals between the values are preserved.</source>
          <target state="translated">delay 引数がNumberの場合、この演算子は、ミリ秒単位で表される時間分だけObservableをタイムシフトします。値の間の相対的な時間間隔は保持されます。</target>
        </trans-unit>
        <trans-unit id="1d0edea354d308cd425e5a8ad0f533ee55c07ab3" translate="yes" xml:space="preserve">
          <source>If the input function calls its callback in the &quot;node style&quot; (i.e. first argument to callback is optional error parameter signaling whether the call failed or not), &lt;a href=&quot;bindnodecallback&quot;&gt;&lt;code&gt;bindNodeCallback&lt;/code&gt;&lt;/a&gt; provides convenient error handling and probably is a better choice. &lt;code&gt;bindCallback&lt;/code&gt; will treat such functions the same as any other and error parameters (whether passed or not) will always be interpreted as regular callback argument.</source>
          <target state="translated">入力関数が「ノードスタイル」でコールバックを呼び出す場合（つまり、コールバックの最初の引数は、呼び出しが失敗したかどうかを示すオプションのエラーパラメーターです）、&lt;a href=&quot;bindnodecallback&quot;&gt; &lt;code&gt;bindNodeCallback&lt;/code&gt; &lt;/a&gt;は便利なエラー処理を提供し、おそらくより良い選択です。 &lt;code&gt;bindCallback&lt;/code&gt; はそのような関数を他の関数と同じように扱い、エラーパラメータ（渡されるかどうかにかかわらず）は常に通常のコールバック引数として解釈されます。</target>
        </trans-unit>
        <trans-unit id="0b21237624e24ba4cc805cfeee666fd31c53c5b0" translate="yes" xml:space="preserve">
          <source>If the last parameter is a function, this function is used to compute the created value from the input values. Otherwise, an array of the input values is returned.</source>
          <target state="translated">最後のパラメータが関数の場合,この関数は入力値から作成された値を計算するために使用されます.そうでない場合は、入力値の配列が返されます。</target>
        </trans-unit>
        <trans-unit id="704afffd75894b6709cab10f66bc542fc722f744" translate="yes" xml:space="preserve">
          <source>If the source Observable turns out to be empty, then this operator will emit a default value.</source>
          <target state="translated">ソースObservableが空であることが判明した場合、この演算子はデフォルト値を出力します。</target>
        </trans-unit>
        <trans-unit id="65c66c04bc0bef2071226e606af604f4bb46432a" translate="yes" xml:space="preserve">
          <source>If the source observable completes without emitting a value, it will emit an error. The error will be created at that time by the optional &lt;code&gt;errorFactory&lt;/code&gt; argument, otherwise, the error will be &lt;a href=&quot;../index/interface/emptyerror&quot;&gt;&lt;code&gt;EmptyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ソースオブザーバブルが値を出力せずに完了すると、エラーが発生します。エラーはオプションの &lt;code&gt;errorFactory&lt;/code&gt; 引数によってそのときに作成されます。それ以外の場合、エラーは&lt;a href=&quot;../index/interface/emptyerror&quot;&gt; &lt;code&gt;EmptyError&lt;/code&gt; になり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b81b74a71c6eeb0509a7903617c743cf2e95798b" translate="yes" xml:space="preserve">
          <source>If the tear down being added is a subscription that is already unsubscribed, is the same reference &lt;code&gt;add&lt;/code&gt; is being called on, or is &lt;code&gt;Subscription.EMPTY&lt;/code&gt;, it will not be added.</source>
          <target state="translated">追加されるティアダウンが既にサブスクライブされていない &lt;code&gt;Subscription.EMPTY&lt;/code&gt; である場合、同じ参照の &lt;code&gt;add&lt;/code&gt; が呼び出されている場合、またはSubscription.EMPTYである場合は、追加されません。</target>
        </trans-unit>
        <trans-unit id="9540c042022e13c3a09c2d5bc7fab29748e20f12" translate="yes" xml:space="preserve">
          <source>If there is a commonly used sequence of operators in your code, use the &lt;code&gt;pipe()&lt;/code&gt; function to extract the sequence into a new operator. Even if a sequence is not that common, breaking it out into a single operator can improve readability.</source>
          <target state="translated">コードによく使用される演算子のシーケンスがある場合は、 &lt;code&gt;pipe()&lt;/code&gt; 関数を使用してシーケンスを新しい演算子に抽出します。シーケンスがそれほど一般的ではない場合でも、シーケンスを1つの演算子に分割すると、読みやすさが向上します。</target>
        </trans-unit>
        <trans-unit id="120e2aa081d0d7d86f0ec952fbf8c0c6ba52c280" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;project&lt;/code&gt; function, an array of all the most recent values is emitted by the output Observable.</source>
          <target state="translated">&lt;code&gt;project&lt;/code&gt; 関数がない場合、最新のすべての値の配列が出力Observableによって発行されます。</target>
        </trans-unit>
        <trans-unit id="2042c5f5108b1085d8f0cd4827f1b1647e843180" translate="yes" xml:space="preserve">
          <source>If this subscription is already in an &lt;code&gt;closed&lt;/code&gt; state, the passed tear down logic will be executed immediately.</source>
          <target state="translated">このサブスクリプションがすでに &lt;code&gt;closed&lt;/code&gt; 状態にある場合、渡された破棄ロジックはすぐに実行されます。</target>
        </trans-unit>
        <trans-unit id="617020e61af12a357bc2772c78eadc0453defeed" translate="yes" xml:space="preserve">
          <source>If we wish to avoid explicit calls to &lt;code&gt;connect()&lt;/code&gt;, we can use ConnectableObservable's &lt;code&gt;refCount()&lt;/code&gt; method (reference counting), which returns an Observable that keeps track of how many subscribers it has. When the number of subscribers increases from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;, it will call &lt;code&gt;connect()&lt;/code&gt; for us, which starts the shared execution. Only when the number of subscribers decreases from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt; will it be fully unsubscribed, stopping further execution.</source>
          <target state="translated">&lt;code&gt;connect()&lt;/code&gt; への明示的な呼び出しを避けたい場合は、ConnectableObservableの &lt;code&gt;refCount()&lt;/code&gt; メソッド（参照カウント）を使用できます。このメソッドは、サブスクライバーの数を追跡するObservableを返します。サブスクライバーの数が &lt;code&gt;0&lt;/code&gt; から &lt;code&gt;1&lt;/code&gt; に増加すると、 &lt;code&gt;connect()&lt;/code&gt; が呼び出され、共有実行が開始されます。サブスクライバーの数が &lt;code&gt;1&lt;/code&gt; から &lt;code&gt;0&lt;/code&gt; に減少した場合にのみ、完全にサブスクライブ解除され、それ以上の実行は停止されます。</target>
        </trans-unit>
        <trans-unit id="5439a31ba2d71bf365539528323ff6c90d45a470" translate="yes" xml:space="preserve">
          <source>If you &lt;code&gt;require('rxjs/_esm5/path-mapping')&lt;/code&gt;, you will receive a function that returns an object of key-value pairs mapping each input to it's file location on disk. Utilize this mapping as follows:</source>
          <target state="translated">あなたがいる場合 &lt;code&gt;require('rxjs/_esm5/path-mapping')&lt;/code&gt; 、あなたはディスク上のそれのファイルの場所に戻り、それぞれの入力をマッピングするキーと値のペアのオブジェクトをその関数を受信します。このマッピングを次のように利用します。</target>
        </trans-unit>
        <trans-unit id="38877b71d192590feabd1b186895b050de142d89" translate="yes" xml:space="preserve">
          <source>If you are defining your own prototype operators in TypeScript and modifying the &lt;code&gt;Observable&lt;/code&gt; namespace, you will need to change your operator code in order to get TypeScript to compile. See &lt;a href=&quot;migration#ex-2&quot;&gt;examples&lt;/a&gt;. This is a relatively rare case, likely to affect only advanced TypeScript developers.</source>
          <target state="translated">TypeScriptで独自のプロトタイプオペレーターを定義し、 &lt;code&gt;Observable&lt;/code&gt; 名前空間を変更する場合、TypeScriptをコンパイルするためにオペレーターコードを変更する必要があります。&lt;a href=&quot;migration#ex-2&quot;&gt;例を&lt;/a&gt;参照してください。これは比較的まれなケースで、高度なTypeScript開発者のみに影響する可能性があります。</target>
        </trans-unit>
        <trans-unit id="77ad98badca810f45da78ca2f70f7bab1d886cbb" translate="yes" xml:space="preserve">
          <source>If you are using npm version 2 before this library has achieved a stable version, you need to specify the library version explicitly:</source>
          <target state="translated">このライブラリが安定版に到達する前に npm バージョン 2 を使用している場合は、ライブラリのバージョンを明示的に指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="844ad591748c8aca77e4dcdccf63c8692cdaaa4b" translate="yes" xml:space="preserve">
          <source>If you are using the parameter, you must update your code by moving your result-selection function out of the original operator call, and applying it to the results of the call.</source>
          <target state="translated">パラメータを使用している場合は、結果選択関数を元の演算子呼び出しの外に移動し、呼び出しの結果に適用することでコードを更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="3978310b1cc85c905bb0eeaf6cf95815f8dd8096" translate="yes" xml:space="preserve">
          <source>If you enable the &lt;code&gt;leading&lt;/code&gt; parameter in this example, the output would be the primary click and the double click, but restricts additional clicks within 400ms.</source>
          <target state="translated">この例の &lt;code&gt;leading&lt;/code&gt; パラメータを有効にすると、出力はプライマリクリックとダブルクリックになりますが、追加のクリックは400ms以内に制限されます。</target>
        </trans-unit>
        <trans-unit id="8924e6022acb95d4b22dad3bc88d202b7faa16fd" translate="yes" xml:space="preserve">
          <source>If you find three anonymous functions in &lt;code&gt;generate&lt;/code&gt; call hard to read, you can provide single object to the operator instead. That object has properties: &lt;code&gt;initialState&lt;/code&gt;, &lt;code&gt;condition&lt;/code&gt;, &lt;code&gt;iterate&lt;/code&gt; and &lt;code&gt;resultSelector&lt;/code&gt;, which should have respective values that you would normally pass to &lt;code&gt;generate&lt;/code&gt;. &lt;code&gt;resultSelector&lt;/code&gt; is still optional, but that form of calling &lt;code&gt;generate&lt;/code&gt; allows you to omit &lt;code&gt;condition&lt;/code&gt; as well. If you omit it, that means condition always holds, so output Observable will never complete.</source>
          <target state="translated">&lt;code&gt;generate&lt;/code&gt; で 3つの無名関数を読み取るのが難しい場合は、代わりに単一のオブジェクトをオペレーターに提供できます。そのオブジェクトには、 &lt;code&gt;initialState&lt;/code&gt; 、 &lt;code&gt;condition&lt;/code&gt; 、 &lt;code&gt;iterate&lt;/code&gt; 、および &lt;code&gt;resultSelector&lt;/code&gt; のプロパティがあります。これらは通常、 &lt;code&gt;generate&lt;/code&gt; 渡すそれぞれの値を持つ必要があります。 &lt;code&gt;resultSelector&lt;/code&gt; は依然としてオプションですが、 &lt;code&gt;generate&lt;/code&gt; を呼び出すこの形式では、 &lt;code&gt;condition&lt;/code&gt; を省略することもできます。省略すると、常に条件が満たされるため、Observableの出力は完了しません。</target>
        </trans-unit>
        <trans-unit id="6622080ade80659a6c5d1d8c040185d09d9ce150" translate="yes" xml:space="preserve">
          <source>If you have RxJS code that uses any other form of async scheduling other than AsyncScheduler, e.g. Promises, AsapScheduler, etc. you can't reliably use marble diagrams &lt;em&gt;for that particular code&lt;/em&gt;. This is because those other scheduling methods won't be virtualized or known to TestScheduler.</source>
          <target state="translated">AsyncScheduler以外の他の形式の非同期スケジューリング（Promise、AsapSchedulerなど）を使用するRxJSコードがある場合&lt;em&gt;、その特定のコードに&lt;/em&gt;マーブルダイアグラム&lt;em&gt;を&lt;/em&gt;確実に使用することはできません。これは、それらの他のスケジューリングメソッドが仮想化されないか、TestSchedulerに認識されないためです。</target>
        </trans-unit>
        <trans-unit id="e8f64885951634f31a84994c2ad579ee912cd26e" translate="yes" xml:space="preserve">
          <source>If you have installed &lt;code&gt;rxjs-compat&lt;/code&gt;, there are only two breaking changes that you might need to address immediately.</source>
          <target state="translated">&lt;code&gt;rxjs-compat&lt;/code&gt; をインストールした場合、すぐに対処する必要がある可能性のある2つの重大な変更があります。</target>
        </trans-unit>
        <trans-unit id="9392292c8ce329d2c59bb25843c4bd27a5cd47c1" translate="yes" xml:space="preserve">
          <source>If you have more complex logic that requires decision between more than two Observables, &lt;a href=&quot;defer&quot;&gt;&lt;code&gt;defer&lt;/code&gt;&lt;/a&gt; will probably be a better choice. Actually &lt;code&gt;iif&lt;/code&gt; can be easily implemented with &lt;a href=&quot;defer&quot;&gt;&lt;code&gt;defer&lt;/code&gt;&lt;/a&gt; and exists only for convenience and readability reasons.</source>
          <target state="translated">3つ以上のObservable間の決定を必要とするより複雑なロジックがある場合は、おそらく&lt;a href=&quot;defer&quot;&gt; &lt;code&gt;defer&lt;/code&gt; &lt;/a&gt;がより良い選択になります。実際、 &lt;code&gt;iif&lt;/code&gt; は&lt;a href=&quot;defer&quot;&gt; &lt;code&gt;defer&lt;/code&gt; &lt;/a&gt;を使用して簡単に実装でき、利便性と読みやすさの理由でのみ存在します。</target>
        </trans-unit>
        <trans-unit id="e5dd67de623021f1d498a36750dcf6c79d4e0143" translate="yes" xml:space="preserve">
          <source>If you just want to &quot;defer&quot; task, that is to perform it right after currently executing synchronous code ends (commonly achieved by &lt;code&gt;setTimeout(deferredTask, 0)&lt;/code&gt;), better choice will be the &lt;a href=&quot;asapscheduler&quot;&gt;&lt;code&gt;asap&lt;/code&gt;&lt;/a&gt; scheduler.</source>
          <target state="translated">タスクを「延期」したい場合、つまり現在実行中の同期コードが終了した直後にそれを実行する場合（通常、 &lt;code&gt;setTimeout(deferredTask, 0)&lt;/code&gt; によって実現されます）、&lt;a href=&quot;asapscheduler&quot;&gt; &lt;code&gt;asap&lt;/code&gt; &lt;/a&gt;スケジューラを選択します。</target>
        </trans-unit>
        <trans-unit id="5a9a1fa1312c35ddac86b41c30d41c3f5e594c2e" translate="yes" xml:space="preserve">
          <source>If you need access to all event handler parameters (not only the first one), or you need to transform them in any way, you can call &lt;code&gt;fromEventPattern&lt;/code&gt; with optional third parameter - project function which will accept all arguments passed to event handler when it is called. Whatever is returned from project function will appear on resulting stream instead of usual event handlers first argument. This means that default project can be thought of as function that takes its first parameter and ignores the rest.</source>
          <target state="translated">（最初のパラメーターだけでなく）すべてのイベントハンドラーパラメーターにアクセスする必要がある場合、または何らかの方法でパラメーターを変換する必要がある場合は、オプションの3番目のパラメーター &lt;code&gt;fromEventPattern&lt;/code&gt; 場合にイベントハンドラーに渡されるすべての引数を受け入れるプロジェクト関数でfromEventPatternを呼び出すことができます。呼ばれた。プロジェクト関数から返されたものはすべて、通常のイベントハンドラの最初の引数ではなく、結果のストリームに表示されます。つまり、デフォルトのプロジェクトは、最初のパラメーターを受け取り、残りを無視する関数と考えることができます。</target>
        </trans-unit>
        <trans-unit id="1bdbac235dd8a8f9129b495ef4e47c6d79c2d5d4" translate="yes" xml:space="preserve">
          <source>If you pass a dictionary of observables to the operator, resulting objects will have the same keys as the dictionary passed, with their last values they've emitted located at the corresponding key.</source>
          <target state="translated">観測値の辞書を演算子に渡すと、結果として得られるオブジェクトは辞書と同じキーを持ち、最後に出力された値は対応するキーに位置します。</target>
        </trans-unit>
        <trans-unit id="7d837f1f500cd898bebd92644c0fcb4ec5f7fcb7" translate="yes" xml:space="preserve">
          <source>If you pass an array of &lt;code&gt;n&lt;/code&gt; observables to the operator, resulting array will have &lt;code&gt;n&lt;/code&gt; values, where first value is the last thing emitted by the first observable, second value is the last thing emitted by the second observable and so on.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 個のオブザーバブルの配列を演算子に渡すと、結果の配列には &lt;code&gt;n&lt;/code&gt; 個の値が含まれます。最初の値は最初のオブザーバブルによって出力される最後のもので、2番目の値は2番目のオブザーバブルによって出力される最後のものです。</target>
        </trans-unit>
        <trans-unit id="ee570c9f654defeedccb901085f0bb73f4226f34" translate="yes" xml:space="preserve">
          <source>If you pass to &lt;code&gt;concat&lt;/code&gt; the same Observable many times, its stream of values will be &quot;replayed&quot; on every subscription, which means you can repeat given Observable as many times as you like. If passing the same Observable to &lt;code&gt;concat&lt;/code&gt; 1000 times becomes tedious, you can always use &lt;a href=&quot;../../operators/repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">同じObservableを何度も &lt;code&gt;concat&lt;/code&gt; て渡すと、サブスクリプションごとにその値のストリームが「リプレイ」されます。つまり、指定されたObservableを何度でも繰り返すことができます。同じObservableを1000回 &lt;code&gt;concat&lt;/code&gt; するために渡すのが面倒になる場合は、常に&lt;a href=&quot;../../operators/repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; を&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="d4a842ea19f74aaea650d3b005c684fa452f2f03" translate="yes" xml:space="preserve">
          <source>If you receive an error like error TS2304: Cannot find name 'Promise' or error TS2304: Cannot find name 'Iterable' when using RxJS you may need to install a supplemental set of typings.</source>
          <target state="translated">RxJSを使用しているときにTS2304:名前「Promise」が見つからない、またはTS2304:名前「反復可能」が見つからないというエラーが表示された場合は、補助的なタイピングセットをインストールする必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="bc2f69f01e85bf5d619a756550c3023d53f1eb41" translate="yes" xml:space="preserve">
          <source>If you use functionality that is removed from v6, but supported by the &lt;code&gt;rxjs-compat&lt;/code&gt; package, you must refactor or rewrite code to complete the update to v6. The following areas of functionality depend on the compatibility layer:</source>
          <target state="translated">v6から削除されたが &lt;code&gt;rxjs-compat&lt;/code&gt; パッケージでサポートされている機能を使用する場合、v6 への更新を完了するには、コードをリファクタリングまたは書き直す必要があります。次の機能領域は、互換性レイヤーに依存します。</target>
        </trans-unit>
        <trans-unit id="8115cc9902d10e9cbc721cbe7139de103776ba25" translate="yes" xml:space="preserve">
          <source>If you're a TypeScript developer, it's recommended that you use &lt;code&gt;rxjs-tslint&lt;/code&gt; to refactor your import paths.</source>
          <target state="translated">TypeScript開発者の場合は、 &lt;code&gt;rxjs-tslint&lt;/code&gt; を使用してインポートパスをリファクタリングすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6013f20fa65ee7b571375547cde18c11a11195b9" translate="yes" xml:space="preserve">
          <source>If you're not using typings the interfaces can be copied from /es6-shim/es6-shim.d.ts.</source>
          <target state="translated">タイピングを使用していない場合、インターフェイスは /es6-shim/es6-shim.d.ts からコピーすることができます。</target>
        </trans-unit>
        <trans-unit id="e55924f1e55081fa0d810b45171dfff9935a10b9" translate="yes" xml:space="preserve">
          <source>If your app is affected by the few &lt;a href=&quot;migration#breaking-changes&quot;&gt;breaking changes&lt;/a&gt; not covered by &lt;code&gt;rxjs-compat&lt;/code&gt;, update the affected code according to the instructions provided below.</source>
          <target state="translated">アプリが &lt;code&gt;rxjs-compat&lt;/code&gt; でカバーされていないいくつかの重大&lt;a href=&quot;migration#breaking-changes&quot;&gt;な変更の&lt;/a&gt;影響を受けている場合は、以下の手順に従って、影響を受けるコードを更新します。</target>
        </trans-unit>
        <trans-unit id="a25eefd9034a0248cd7ddd31d1d8d721666b3a11" translate="yes" xml:space="preserve">
          <source>IfObservable</source>
          <target state="translated">IfObservable</target>
        </trans-unit>
        <trans-unit id="a71757c57da2855a990877a7134d7fa854f423d4" translate="yes" xml:space="preserve">
          <source>Ignore every 3rd click event, starting from the first one</source>
          <target state="translated">3回目のクリックイベントを無視して、最初のクリックイベントから開始します。</target>
        </trans-unit>
        <trans-unit id="fa4d2cc45a3baa30509775b1cb451f0bae0f04ac" translate="yes" xml:space="preserve">
          <source>Ignore every 3rd click event, starting from the third one</source>
          <target state="translated">3回目から始まるクリックイベントをすべて無視する</target>
        </trans-unit>
        <trans-unit id="c30072d05b38673f5eb2d636804574de2101d7e1" translate="yes" xml:space="preserve">
          <source>Ignores all items emitted by the source Observable and only passes calls of &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;.</source>
          <target state="translated">ソースObservableによって発行されたすべてのアイテムを無視し、 &lt;code&gt;complete&lt;/code&gt; または &lt;code&gt;error&lt;/code&gt; の呼び出しのみを渡します。</target>
        </trans-unit>
        <trans-unit id="40e5987468ce7f856e1a72614ed4dc8bef08b57f" translate="yes" xml:space="preserve">
          <source>Ignores emitted values, reacts to observable's completion.</source>
          <target state="translated">排出された値を無視し、オブザーバブルの完了に反応します。</target>
        </trans-unit>
        <trans-unit id="70355e794eb2aafb77d98edb0d89a6e944d813ad" translate="yes" xml:space="preserve">
          <source>Ignores source values for &lt;code&gt;duration&lt;/code&gt; milliseconds, then emits the most recent value from the source Observable, then repeats this process.</source>
          <target state="translated">&lt;code&gt;duration&lt;/code&gt; ミリ秒のソース値を無視し、ソースObservableから最新の値を出力してから、このプロセスを繰り返します。</target>
        </trans-unit>
        <trans-unit id="529d2ea415ea19d29423e03ad35a1b7fa6aec7f7" translate="yes" xml:space="preserve">
          <source>Ignores source values for a duration determined by another Observable, then emits the most recent value from the source Observable, then repeats this process.</source>
          <target state="translated">別のObservableによって決定された期間、ソース値を無視し、ソースObservableから最新の値を放出し、このプロセスを繰り返します。</target>
        </trans-unit>
        <trans-unit id="a40044f6794fce3bb8fd5737e1d66787d43844de" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;../interface/observer&quot;&gt;&lt;code&gt;Observer&lt;/code&gt;&lt;/a&gt; interface and extends the &lt;a href=&quot;subscription&quot;&gt;&lt;code&gt;Subscription&lt;/code&gt;&lt;/a&gt; class. While the &lt;a href=&quot;../interface/observer&quot;&gt;&lt;code&gt;Observer&lt;/code&gt;&lt;/a&gt; is the public API for consuming the values of an &lt;a href=&quot;observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;, all Observers get converted to a Subscriber, in order to provide Subscription-like capabilities such as &lt;code&gt;unsubscribe&lt;/code&gt;. Subscriber is a common type in RxJS, and crucial for implementing operators, but it is rarely used as a public API.</source>
          <target state="translated">&lt;a href=&quot;../interface/observer&quot;&gt; &lt;code&gt;Observer&lt;/code&gt; &lt;/a&gt;インターフェースを実装し、&lt;a href=&quot;subscription&quot;&gt; &lt;code&gt;Subscription&lt;/code&gt; &lt;/a&gt;クラスを拡張します。一方で&lt;a href=&quot;../interface/observer&quot;&gt; &lt;code&gt;Observer&lt;/code&gt; &lt;/a&gt;値を消費するための公開APIで&lt;a href=&quot;observable&quot;&gt; &lt;code&gt;Observable&lt;/code&gt; &lt;/a&gt;、すべてのオブザーバーは、次のようなサブスクリプションのような機能を提供するために、加入者に変換します &lt;code&gt;unsubscribe&lt;/code&gt; 。サブスクライバーはRxJSの一般的なタイプであり、オペレーターの実装に不可欠ですが、パブリックAPIとして使用されることはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="22a882e9f78320d3f6a26b70debc5504cfb608e8" translate="yes" xml:space="preserve">
          <source>Import paths</source>
          <target state="translated">パスのインポート</target>
        </trans-unit>
        <trans-unit id="d78821ba5d868d9a31095edd36e64f53ec95ec9b" translate="yes" xml:space="preserve">
          <source>Import paths have changed.</source>
          <target state="translated">インポートパスが変更されました。</target>
        </trans-unit>
        <trans-unit id="604c5adf7e512895ef3206a2a38925fde75adbf4" translate="yes" xml:space="preserve">
          <source>In JavaScript runtimes that support &lt;code&gt;Set&lt;/code&gt;, this operator will use a &lt;code&gt;Set&lt;/code&gt; to improve performance of the distinct value checking.</source>
          <target state="translated">&lt;code&gt;Set&lt;/code&gt; をサポートするJavaScriptランタイムでは、この演算子は &lt;code&gt;Set&lt;/code&gt; を使用して、個別値チェックのパフォーマンスを向上させます。</target>
        </trans-unit>
        <trans-unit id="e5195133f63632cc13452c63ce186838089e5949" translate="yes" xml:space="preserve">
          <source>In RxJS v5.x, a number of operators have an optional resultSelector argument, in which you can pass a function for handling the result of the operations.</source>
          <target state="translated">RxJS v5.xでは、多くの演算子にオプションのresultSelector引数があり、演算結果を処理する関数を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="9ed98d14e00fa6f78e3945d35bbdbe8132e2ecd9" translate="yes" xml:space="preserve">
          <source>In RxJS v6.x, UMD module name has been changed from Rx to rxjs so that it's align with other imports module name.</source>
          <target state="translated">RxJS v6.xでは、UMDモジュール名がRxからrxjsに変更され、他のインポートモジュール名との整合性が図られました。</target>
        </trans-unit>
        <trans-unit id="9f5e3817dd59d2b07ee7cbf50ed5e3af33894a40" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.3 and lower, typings will need to be added to functions passed to operators, as types cannot be inferred prior to TypeScript 2.4. In TypeScript 2.4, types will infer via composition properly.</source>
          <target state="translated">TypeScript 2.3 以下では、TypeScript 2.4 以前では型を推論できないため、演算子に渡される関数に型を追加する必要があります。TypeScript 2.4 では、型の推論は適切に組版を介して行われるようになります。</target>
        </trans-unit>
        <trans-unit id="09c23a7addb52527b7cdfb469f68066abf364c42" translate="yes" xml:space="preserve">
          <source>In a marble diagram, time flows to the right, and the diagram describes how values (&quot;marbles&quot;) are emitted on the Observable execution.</source>
          <target state="translated">ビー玉図では、時間が右に流れ、Observableの実行時に値(「ビー玉」)がどのように放出されるかを説明しています。</target>
        </trans-unit>
        <trans-unit id="fb16cf9ddcefacd27292666512786e6449d62f05" translate="yes" xml:space="preserve">
          <source>In an Observable Execution, zero to infinite Next notifications may be delivered. If either an Error or Complete notification is delivered, then nothing else can be delivered afterwards.</source>
          <target state="translated">Observable 実行では、ゼロから無限に次の通知を配信することができます。エラー通知または完了通知のいずれかが配信された場合、それ以降は何も配信できません。</target>
        </trans-unit>
        <trans-unit id="6c035b77c3b045a395fde85eddc3bc476a772acf" translate="yes" xml:space="preserve">
          <source>In both &lt;code&gt;hot&lt;/code&gt; and &lt;code&gt;cold&lt;/code&gt; methods, value characters specified in marble diagrams are emitted as strings unless a &lt;code&gt;values&lt;/code&gt; argument is passed to the method. Therefor:</source>
          <target state="translated">&lt;code&gt;hot&lt;/code&gt; メソッドと &lt;code&gt;cold&lt;/code&gt; メソッドの両方で、 &lt;code&gt;values&lt;/code&gt; 引数がメソッドに渡されない限り、大理石の図で指定された値文字は文字列として出力されます。そのため：</target>
        </trans-unit>
        <trans-unit id="295e5d256d6bbe1d0869e05b595f7b24f349478f" translate="yes" xml:space="preserve">
          <source>In every window of 1 second each, emit at most 2 click events</source>
          <target state="translated">1秒ごとのウィンドウで、最大2回のクリックイベントを発生させます。</target>
        </trans-unit>
        <trans-unit id="c49794905cd1728d46b3103a435edb3badc67155" translate="yes" xml:space="preserve">
          <source>In functions that have the resultSelector parameter, the parameters have been deprecated in most cases, and removed for two functions. The ones that have been removed must be updated before you can remove the compatibility layer.</source>
          <target state="translated">resultSelector パラメータを持つ関数では、ほとんどの場合、パラメータは非推奨となり、2 つの関数では削除されています。削除されたものは、互換性レイヤーを削除する前に更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="e1fd85e3cd2bf300851eee6724b69f0c2ea88b01" translate="yes" xml:space="preserve">
          <source>In most tests it will be unnecessary to test subscription and unsubscription points, being either obvious or implied from the &lt;code&gt;expected&lt;/code&gt; diagram. In those cases do not write subscription assertions. In test cases that have inner subscriptions or cold observables with multiple subscribers, these subscription assertions can be useful.</source>
          <target state="translated">ほとんどのテストでは、サブスクリプションポイントとサブスクリプション解除ポイントをテストする必要はなく、 &lt;code&gt;expected&lt;/code&gt; 図から明らかであるか、暗黙のうちに示されます。そのような場合は、サブスクリプションアサーションを記述しないでください。内部サブスクリプションまたは複数のサブスクライバーを持つコールドオブザーバブルが存在するテストケースでは、これらのサブスクリプションアサーションが役立ちます。</target>
        </trans-unit>
        <trans-unit id="aec95503709d60cd6d6b2ee3ce1d30d30b825fd7" translate="yes" xml:space="preserve">
          <source>In order for resulting array to have the same length as the number of input observables, whenever any of that observables completes without emitting any value, &lt;code&gt;forkJoin&lt;/code&gt; will complete at that moment as well and it will not emit anything either, even if it already has some last values from other observables. Conversely, if there is an observable that never completes, &lt;code&gt;forkJoin&lt;/code&gt; will never complete as well, unless at any point some other observable completes without emitting value, which brings us back to the previous case. Overall, in order for &lt;code&gt;forkJoin&lt;/code&gt; to emit a value, all observables passed as arguments have to emit something at least once and complete.</source>
          <target state="translated">結果の配列が入力オブザーバブルの数と同じ長さになるように、そのオブザーバブルのいずれかが値を &lt;code&gt;forkJoin&lt;/code&gt; せずに完了すると、forkJoinもその瞬間に完了し、すでにいくらか持っていても何も出力しません。他のオブザーバブルの最後の値。逆に、完了しないオブザーバブルが存在する場合、 &lt;code&gt;forkJoin&lt;/code&gt; も完了しません。ただし、他のオブザーバブルが値を出力せずに完了するため、前のケースに戻ります。全体として、 &lt;code&gt;forkJoin&lt;/code&gt; が値を出力するには、引数として渡されるすべてのオブザーバブルが少なくとも1回何かを出力して完了する必要があります。</target>
        </trans-unit>
        <trans-unit id="a45eba608694af1c74ee2e9386099587189e2989" translate="yes" xml:space="preserve">
          <source>In order to minimize the impact of the upgrade, RxJS v6 releases with a sibling package, &lt;code&gt;rxjs-compat&lt;/code&gt;, which provides a compatibility layer between the v6 and v5 APIs. Most developers with existing applications should upgrade by installing both &lt;code&gt;rxjs&lt;/code&gt; and &lt;code&gt;rxjs-compat&lt;/code&gt; at ^6.0.0:</source>
          <target state="translated">アップグレードの影響を最小限に抑えるため、RxJS v6は兄弟パッケージ &lt;code&gt;rxjs-compat&lt;/code&gt; とともにリリースされ、v6 APIとv5 API間の互換性レイヤーを提供します。既存のアプリケーションを使用するほとんどの開発者は、^ 6.0.0に &lt;code&gt;rxjs&lt;/code&gt; と &lt;code&gt;rxjs-compat&lt;/code&gt; の両方をインストールしてアップグレードする必要があります。</target>
        </trans-unit>
        <trans-unit id="fe403bd5e814fd0d03b717695065a0f083c8e78f" translate="yes" xml:space="preserve">
          <source>In order to use the new pipeable operators and not gain bundle size, you will need to change your Webpack configuration. This will only work with Webpack 3+ as it relies on the new &lt;code&gt;ModuleConcatenationPlugin&lt;/code&gt; from Webpack 3.</source>
          <target state="translated">新しいパイプ可能演算子を使用してバンドルサイズを取得しないためには、Webpack構成を変更する必要があります。これは、Webpack 3 &lt;code&gt;ModuleConcatenationPlugin&lt;/code&gt; の新しいModuleConcatenationPluginに依存しているため、Webpack 3 以降でのみ機能します。</target>
        </trans-unit>
        <trans-unit id="3d435e3fa3d8d13c3292375c9df88ca4214ee5db" translate="yes" xml:space="preserve">
          <source>In other runtimes, this operator will use a minimal implementation of &lt;code&gt;Set&lt;/code&gt; that relies on an &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;indexOf&lt;/code&gt; under the hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running &lt;code&gt;distinct&lt;/code&gt; use might result in memory leaks. To help alleviate this in some scenarios, an optional &lt;code&gt;flushes&lt;/code&gt; parameter is also provided so that the internal &lt;code&gt;Set&lt;/code&gt; can be &quot;flushed&quot;, basically clearing it of values.</source>
          <target state="translated">他のランタイムでは、この演算子は &lt;code&gt;indexOf&lt;/code&gt; で &lt;code&gt;Array&lt;/code&gt; とindexOfに依存する &lt;code&gt;Set&lt;/code&gt; の最小限の実装を使用するため、区別のためにチェックされる値が増えるとパフォーマンスが低下します。でも、新しいブラウザで、長時間実行される &lt;code&gt;distinct&lt;/code&gt; 使用はメモリリークが発生する場合があります。いくつかのシナリオでこれを軽減するのを助けるために、オプションで &lt;code&gt;flushes&lt;/code&gt; パラメータも提供され、内部 &lt;code&gt;Set&lt;/code&gt; が「フラッシュ」され、基本的に値がクリアされます。</target>
        </trans-unit>
        <trans-unit id="768c1eec37c4aabe5ab384f41143b24385fc36f4" translate="yes" xml:space="preserve">
          <source>In some APIs unregistering is actually handled differently. Method registering an event handler returns some kind of token, which is later used to identify which function should be unregistered or it itself has method that unregisters event handler. If that is the case with your API, make sure token returned by registering method is returned by &lt;code&gt;addHandler&lt;/code&gt;. Then it will be passed as a second argument to &lt;code&gt;removeHandler&lt;/code&gt;, where you will be able to use it.</source>
          <target state="translated">一部のAPIでは、登録解除は実際には異なる方法で処理されます。イベントハンドラーを登録するメソッドは、ある種のトークンを返します。このトークンは、登録解除する必要がある関数を識別するために後で使用されるか、それ自体がイベントハンドラーを登録解除するメソッドを持っています。 APIがそうである場合は、registeringメソッドによって返されたトークンが &lt;code&gt;addHandler&lt;/code&gt; によって返されることを確認してください。次に、2番目の引数として &lt;code&gt;removeHandler&lt;/code&gt; に渡され、そこで使用できます。</target>
        </trans-unit>
        <trans-unit id="31cb9789c815a7a8a9b3a98df002734fb61392f8" translate="yes" xml:space="preserve">
          <source>In the above situation we need the observable stream to complete so that we can test the variable was set to the correct value. The TestScheduler runs in 'virtual time' (synchronously), but doesn't normally run (and complete) until the testScheduler callback returns. The flush() method manually triggers the virtual time so that we can test the local variable after the observable completes.</source>
          <target state="translated">上記の状況では、変数が正しい値に設定されているかどうかをテストするために、観測可能なストリームを完了させる必要があります。TestSchedulerは'仮想時間'で(同期的に)実行されますが、通常はtestSchedulerコールバックが戻るまで実行されません(完了しません)。flush()メソッドは手動で仮想時間をトリガーするので、オブザーバブルが完了した後にローカル変数をテストすることができます。</target>
        </trans-unit>
        <trans-unit id="d19c3b25e6f5d0f4dceb81b95a860d7b023fe387" translate="yes" xml:space="preserve">
          <source>In the browser, &lt;code&gt;addEventListener&lt;/code&gt; accepts - apart from event type string and event handler function arguments - optional third parameter, which is either an object or boolean, both used for additional configuration how and when passed function will be called. When &lt;code&gt;fromEvent&lt;/code&gt; is used with event target of that type, you can provide this values as third parameter as well.</source>
          <target state="translated">ブラウザーでは、 &lt;code&gt;addEventListener&lt;/code&gt; は、イベントタイプの文字列とイベントハンドラー関数の引数を除いて、オプションの3番目のパラメーター（オブジェクトまたはブール値）を受け入れます。どちらも追加の構成に使用され、渡された関数が呼び出される方法とときに呼び出されます。とき &lt;code&gt;fromEvent&lt;/code&gt; はそのタイプのイベントターゲットで使用されている、あなたにも三番目のパラメータとして、この値を提供することができます。</target>
        </trans-unit>
        <trans-unit id="d611fc72a1a0461578e38fb87221937cf83ac16c" translate="yes" xml:space="preserve">
          <source>In the context of TestScheduler, a marble diagram is a string containing special syntax representing events happening over virtual time. Time progresses by &lt;em&gt;frames&lt;/em&gt;. The first character of any marble string always represents the &lt;em&gt;zero frame&lt;/em&gt;, or the start of time. Inside of &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; the frameTimeFactor is set to 1, which means one frame is equal to one virtual millisecond.</source>
          <target state="translated">TestSchedulerのコンテキストでは、大理石の図は、仮想時間中に発生するイベントを表す特別な構文を含む文字列です。時間は&lt;em&gt;フレーム&lt;/em&gt;ごとに進みます。大理石の文字列の最初の文字は常に&lt;em&gt;ゼロフレーム&lt;/em&gt;、つまり時間の始まりを表し&lt;em&gt;ます&lt;/em&gt;。 &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; 内では、frameTimeFactorが1に設定されています。これは、1フレームが1仮想ミリ秒に等しいことを意味します。</target>
        </trans-unit>
        <trans-unit id="9e61d0bd368bc24118ba8a711748b25b10256924" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;subscribe&lt;/code&gt; function is the most important piece to describe the Observable. Let's look at what subscribing means.</source>
          <target state="translated">上記の例では、 &lt;code&gt;subscribe&lt;/code&gt; 関数はObservableを説明する最も重要な部分です。サブスクライブの意味を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="2d66b1569870cda1caa7fda5b5781d96cf478a71" translate="yes" xml:space="preserve">
          <source>In the example below, we have two Observers attached to a Subject, and we feed some values to the Subject:</source>
          <target state="translated">以下の例では、2つのObserversをSubjectにアタッチして、いくつかの値をSubjectに与えています。</target>
        </trans-unit>
        <trans-unit id="ab82f1f7a93e0c1d53bf67dd2a2293a5337f6463" translate="yes" xml:space="preserve">
          <source>In the example below, we take the usual simple Observable that emits values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; synchronously, and use the operator &lt;code&gt;observeOn&lt;/code&gt; to specify the &lt;code&gt;async&lt;/code&gt; scheduler to use for delivering those values.</source>
          <target state="translated">以下の例では、観測通常簡単に取ること発する値 &lt;code&gt;1&lt;/code&gt; 、 &lt;code&gt;2&lt;/code&gt; 、 &lt;code&gt;3&lt;/code&gt; 同期、及びオペレータの使用 &lt;code&gt;observeOn&lt;/code&gt; を指定する &lt;code&gt;async&lt;/code&gt; それらの値を送達するために使用するスケジューラ。</target>
        </trans-unit>
        <trans-unit id="e820ca5df78d6c0c13eb499231cccdc5f101da8d" translate="yes" xml:space="preserve">
          <source>In the following example there are two intervals turned into connectable observables by using the &lt;em&gt;publish&lt;/em&gt; operator. The first one uses the &lt;em&gt;refCount&lt;/em&gt; operator, the second one does not use it. You will notice that a connectable observable does nothing until you call its connect function.</source>
          <target state="translated">次の例では、&lt;em&gt;公開&lt;/em&gt;演算子を使用して接続可能なオブザーバブルに変換された2つの間隔があります。最初のものは&lt;em&gt;refCount&lt;/em&gt;演算子を使用し、2番目のものはそれを使用しません。接続可能なオブザーバブルは、その接続関数を呼び出すまで何もしないことに気づくでしょう。</target>
        </trans-unit>
        <trans-unit id="0552027c5d9b9c65f728320bf4fafca352e42373" translate="yes" xml:space="preserve">
          <source>In the following example, all emitted values ​​of the interval observable are skipped until the user clicks anywhere within the page.</source>
          <target state="translated">次の例では、ユーザがページ内のどこかをクリックするまで、観測可能な間隔のすべての値がスキップされます。</target>
        </trans-unit>
        <trans-unit id="efee9e2790f7d7f99cf98470cbc85b870bc2c30d" translate="yes" xml:space="preserve">
          <source>In the following example, the BehaviorSubject is initialized with the value &lt;code&gt;0&lt;/code&gt; which the first Observer receives when it subscribes. The second Observer receives the value &lt;code&gt;2&lt;/code&gt; even though it subscribed after the value &lt;code&gt;2&lt;/code&gt; was sent.</source>
          <target state="translated">次の例では、BehaviorSubjectは、最初のObserverがサブスクライブするときに受け取る値 &lt;code&gt;0&lt;/code&gt; で初期化されています。第オブザーバ値受け取り &lt;code&gt;2&lt;/code&gt; 値の後にそれが加入していても &lt;code&gt;2&lt;/code&gt; が送信されました。</target>
        </trans-unit>
        <trans-unit id="8ee442c5a6c2ae9c1636bfba12a54be8b0e91b7b" translate="yes" xml:space="preserve">
          <source>In this example there is a timestamp attached to the documents click event.</source>
          <target state="translated">この例では、ドキュメントのクリックイベントにタイムスタンプが添付されています。</target>
        </trans-unit>
        <trans-unit id="7b43a6d6f344b089c30152a966852ef922f720b7" translate="yes" xml:space="preserve">
          <source>Initial state.</source>
          <target state="translated">初期状態。</target>
        </trans-unit>
        <trans-unit id="b2a80b44b4811d2384ef831fa8087b37898d084c" translate="yes" xml:space="preserve">
          <source>Input Observables to merge together.</source>
          <target state="translated">入力したObservablesをマージします。</target>
        </trans-unit>
        <trans-unit id="2f07bb68f696a1f9376f7eac1c90eada31549502" translate="yes" xml:space="preserve">
          <source>Install RxJS v6 along with the &lt;a href=&quot;migration#backwards-compatibility&quot;&gt;backward-compatibility&lt;/a&gt; package, &lt;code&gt;rxjs-compat&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;migration#backwards-compatibility&quot;&gt;下位互換性&lt;/a&gt;パッケージ &lt;code&gt;rxjs-compat&lt;/code&gt; とともにRxJS v6をインストールします。</target>
        </trans-unit>
        <trans-unit id="550c70d12638cfa6aa8f9e73e5ae88f8cbc4e453" translate="yes" xml:space="preserve">
          <source>Installation Instructions</source>
          <target state="translated">インストール手順</target>
        </trans-unit>
        <trans-unit id="65ec13dada396444df2fea802736eaf9062f72a3" translate="yes" xml:space="preserve">
          <source>Intercepts each emission on the source and runs a function, but returns an output which is identical to the source as long as errors don't occur.</source>
          <target state="translated">ソース上の各排出をインターセプトして関数を実行しますが、エラーが発生しない限りソースと同じ出力を返します。</target>
        </trans-unit>
        <trans-unit id="fb09c60d73f84a6357255306df1f745b4014fb6b" translate="yes" xml:space="preserve">
          <source>Internal implementation detail, do not use directly.</source>
          <target state="translated">内部実装の詳細は、直接使用しないでください。</target>
        </trans-unit>
        <trans-unit id="05fd7d31eb579f2cd61b47be24e926bade2627fd" translate="yes" xml:space="preserve">
          <source>Internally it counts the subscriptions to the observable and subscribes (only once) to the source if the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it unsubscribes from the source. This way you can make sure that everything before the &lt;em&gt;published&lt;/em&gt; refCount has only a single subscription independently of the number of subscribers to the target observable.</source>
          <target state="translated">内部的には、オブザーバブルのサブスクリプションをカウントし、サブスクリプションの数が0より大きい場合はソースにサブスクライブします（1回だけ）。サブスクリプションの数が1より小さい場合は、ソースからサブスクライブ解除します。このようにして、&lt;em&gt;公開された&lt;/em&gt; refCountの前のすべてに、ターゲットオブザーバブルのサブスクライバーの数とは関係なく、1つのサブスクリプションのみが含まれることを確認できます。</target>
        </trans-unit>
        <trans-unit id="aaa8e0fc940297bcdab02842e2a5147eec870040" translate="yes" xml:space="preserve">
          <source>Internally the &lt;code&gt;skipUntil&lt;/code&gt; operator subscribes to the passed in observable (in the following called &lt;em&gt;notifier&lt;/em&gt;) in order to recognize the emission of its first value. When this happens, the operator unsubscribes from the &lt;em&gt;notifier&lt;/em&gt; and starts emitting the values of the &lt;em&gt;source&lt;/em&gt; observable. It will never let the &lt;em&gt;source&lt;/em&gt; observable emit any values if the &lt;em&gt;notifier&lt;/em&gt; completes or throws an error without emitting a value before.</source>
          <target state="translated">内部的に、 &lt;code&gt;skipUntil&lt;/code&gt; オペレーターは、最初の値の発行を認識するために、渡されたオブザーバブル（以下では&lt;em&gt;notifier&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;）にサブスクライブします。これが発生すると、オペレーターは&lt;em&gt;通知機能の&lt;/em&gt;登録を解除し、&lt;em&gt;ソース&lt;/em&gt;オブザーバブルの値の出力を開始します。以前に値を&lt;em&gt;発行&lt;/em&gt;せずに&lt;em&gt;ノーティファイアが&lt;/em&gt;完了するかエラーをスローした場合、&lt;em&gt;ソース&lt;/em&gt;オブザーバブルが値を発行することはありません。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8a7007ce84b08e270eeaa49d4929b8f2489cac28" translate="yes" xml:space="preserve">
          <source>Internally to the Subject, &lt;code&gt;subscribe&lt;/code&gt; does not invoke a new execution that delivers values. It simply registers the given Observer in a list of Observers, similarly to how &lt;code&gt;addListener&lt;/code&gt; usually works in other libraries and languages.</source>
          <target state="translated">サブジェクトの内部では、 &lt;code&gt;subscribe&lt;/code&gt; は値を配信する新しい実行を呼び出しません。 &lt;code&gt;addListener&lt;/code&gt; が他のライブラリや言語で通常どのように機能するかと同様に、指定されたオブザーバーをオブザーバーのリストに登録するだけです。</target>
        </trans-unit>
        <trans-unit id="24accef6c599f78a54078eab954e8eaa64e50ddd" translate="yes" xml:space="preserve">
          <source>InteropObservable</source>
          <target state="translated">InteropObservable</target>
        </trans-unit>
        <trans-unit id="2137906387d8cc5b016d85b0a13be63dbc02c890" translate="yes" xml:space="preserve">
          <source>Interval at which to start a new buffer. For example if &lt;code&gt;startBufferEvery&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, then a new buffer will be started on every other value from the source. A new buffer is started at the beginning of the source by default.</source>
          <target state="translated">新しいバッファを開始する間隔。たとえば、 &lt;code&gt;startBufferEvery&lt;/code&gt; が &lt;code&gt;2&lt;/code&gt; の場合、ソースからの他のすべての値で新しいバッファーが開始されます。デフォルトでは、新しいバッファーはソースの先頭から開始されます。</target>
        </trans-unit>
        <trans-unit id="099ee7f53a8b8a0c2b710920d86de6469411ddbb" translate="yes" xml:space="preserve">
          <source>Interval at which to start a new window. For example if &lt;code&gt;startWindowEvery&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, then a new window will be started on every other value from the source. A new window is started at the beginning of the source by default.</source>
          <target state="translated">新しいウィンドウを開始する間隔。たとえば、 &lt;code&gt;startWindowEvery&lt;/code&gt; が &lt;code&gt;2&lt;/code&gt; の場合、ソースからの他のすべての値で新しいウィンドウが開始されます。デフォルトでは、ソースの最初から新しいウィンドウが開始されます。</target>
        </trans-unit>
        <trans-unit id="cf4da275720c283107736e8fa280351990f16a51" translate="yes" xml:space="preserve">
          <source>IntervalObservable</source>
          <target state="translated">IntervalObservable</target>
        </trans-unit>
        <trans-unit id="c36e44208f62181f22b4bcd7126f50a720e594e1" translate="yes" xml:space="preserve">
          <source>Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.</source>
          <target state="translated">Observable の実行を呼び出し、それが発する通知のための Observer ハンドラを登録します。</target>
        </trans-unit>
        <trans-unit id="9d3ed26be15137921010183c814a29d964162f2d" translate="yes" xml:space="preserve">
          <source>Is the number &lt;code&gt;i&lt;/code&gt; for the i-th source emission that has happened since the subscription, starting from the number &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">番号 &lt;code&gt;0&lt;/code&gt; から始まる、サブスクリプション以降に発生したi番目のソース放出の番号 &lt;code&gt;i&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="97ed0bfaa76c328255273846366b63dd8bec2bd0" translate="yes" xml:space="preserve">
          <source>It creates an observable for an Ajax request with either a request object with url, headers, etc or a string for a URL.</source>
          <target state="translated">これは、URLやヘッダなどのリクエストオブジェクト、またはURLの文字列を持つAjaxリクエスト用のオブザーバブルを作成します。</target>
        </trans-unit>
        <trans-unit id="0db1e53616a29e5e2b418755002a34b4586aae8c" translate="yes" xml:space="preserve">
          <source>It defines a set of properties to provide custom behavior in specific moments of the socket's lifecycle. When the connection opens we can use &lt;code&gt;openObserver&lt;/code&gt;, when the connection is closed &lt;code&gt;closeObserver&lt;/code&gt;, if we are interested in listening for data comming from server: &lt;code&gt;deserializer&lt;/code&gt;, which allows us to customize the deserialization strategy of data before passing it to the socket client. By default &lt;code&gt;deserializer&lt;/code&gt; is going to apply &lt;code&gt;JSON.parse&lt;/code&gt; to each message comming from the Server.</source>
          <target state="translated">ソケットのライフサイクルの特定の瞬間にカスタム動作を提供する一連のプロパティを定義します。接続は、我々が使用することができます開くと &lt;code&gt;openObserver&lt;/code&gt; を接続が閉じているとき、 &lt;code&gt;closeObserver&lt;/code&gt; ：私たちは、サーバーから来たデータをリッスンに興味がある場合は、 &lt;code&gt;deserializer&lt;/code&gt; 私たちはソケットクライアントに渡す前に、データの直列化復元戦略をカスタマイズすることができます。デフォルトでは、 &lt;code&gt;deserializer&lt;/code&gt; &lt;code&gt;JSON.parse&lt;/code&gt; はサーバーから送信される各メッセージにJSON.parseを適用します。</target>
        </trans-unit>
        <trans-unit id="bd607bfeb0a8c9ef7622b42ffa771561bde8a17d" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;very important&lt;/strong&gt; to remember that input function &lt;code&gt;func&lt;/code&gt; is not called when the output function is, but rather when the Observable returned by the output function is subscribed. This means if &lt;code&gt;func&lt;/code&gt; makes an AJAX request, that request will be made every time someone subscribes to the resulting Observable, but not before.</source>
          <target state="translated">入力関数 &lt;code&gt;func&lt;/code&gt; は、出力関数が呼び出されるときに呼び出されるのではなく、出力関数によって返されるObservableがサブスクライブされるときに呼び出されることを覚えておくことは&lt;strong&gt;非常に重要&lt;/strong&gt;です。つまり、 &lt;code&gt;func&lt;/code&gt; がAJAX要求を行う場合、その要求は、誰かが結果のObservableをサブスクライブするたびに行われますが、以前は行われません。</target>
        </trans-unit>
        <trans-unit id="38a279bd2826e12e3145c4d6fbc3b6abb46c6bdb" translate="yes" xml:space="preserve">
          <source>It is a good idea to wrap any code in &lt;code&gt;subscribe&lt;/code&gt; with &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; block that will deliver an Error notification if it catches an exception:</source>
          <target state="translated">例外をキャッチした場合にエラー通知を配信する &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; ブロックを使用して、 &lt;code&gt;subscribe&lt;/code&gt; でコードをラップすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="b9794570cb14fba1d1e1d2d489f15060023fbee9" translate="yes" xml:space="preserve">
          <source>It is more complicated, but if you have to write an operator that cannot be made from a combination of existing operators (a rare occurrance), you can write an operator from scratch using the Observable constructor, like this:</source>
          <target state="translated">もっと複雑ですが、既存の演算子の組み合わせでは作れない演算子を書かなければならない場合(稀に発生します)は、このようにObservableのコンストラクタを使って一から演算子を書くことができます。</target>
        </trans-unit>
        <trans-unit id="0cdb922439d8586a691049b40d1a49708c3bd2ec" translate="yes" xml:space="preserve">
          <source>It is not a coincidence that &lt;code&gt;observable.subscribe&lt;/code&gt; and &lt;code&gt;subscribe&lt;/code&gt; in &lt;code&gt;new Observable(function subscribe(subscriber) {...})&lt;/code&gt; have the same name. In the library, they are different, but for practical purposes you can consider them conceptually equal.</source>
          <target state="translated">&lt;code&gt;new Observable(function subscribe(subscriber) {...})&lt;/code&gt; での &lt;code&gt;observable.subscribe&lt;/code&gt; と &lt;code&gt;subscribe&lt;/code&gt; が同じ名前を持つのは偶然ではありません。ライブラリでは、これらは異なりますが、実用的には概念的に等しいと考えることができます。</target>
        </trans-unit>
        <trans-unit id="1f49f2032f83866e5a41394fb7bdc366cf78bdb9" translate="yes" xml:space="preserve">
          <source>It's a version of &lt;code&gt;timeout&lt;/code&gt; operator that let's you specify fallback Observable.</source>
          <target state="translated">これは、フォールバックオブザーバブルを指定できるようにする &lt;code&gt;timeout&lt;/code&gt; オペレーターのバージョンです。</target>
        </trans-unit>
        <trans-unit id="adba087c9c9e58ee773402b9f6f601d478443832" translate="yes" xml:space="preserve">
          <source>It's just like &lt;a href=&quot;bindcallback&quot;&gt;&lt;code&gt;bindCallback&lt;/code&gt;&lt;/a&gt;, but the callback is expected to be of type &lt;code&gt;callback(error, result)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;bindcallback&quot;&gt; &lt;code&gt;bindCallback&lt;/code&gt; &lt;/a&gt;に似ていますが、コールバックのタイプは &lt;code&gt;callback(error, result)&lt;/code&gt; が期待されています。</target>
        </trans-unit>
        <trans-unit id="8a949408305dcb2e7acb7e5b74339b4b8a9ea2f9" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;../../operators/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, but returns two Observables: one like the output of &lt;a href=&quot;../../operators/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, and the other with values that did not pass the condition.</source>
          <target state="translated">これは&lt;a href=&quot;../../operators/filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;に似ていますが、2つのObservableを返します。1つは&lt;a href=&quot;../../operators/filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;の出力のようなもので、もう1つは条件を通過しなかった値を持つものです。</target>
        </trans-unit>
        <trans-unit id="df2238ba3a95389559de5a8118b9e1b31e6870d1" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;audittime&quot;&gt;&lt;code&gt;auditTime&lt;/code&gt;&lt;/a&gt;, but the silencing duration is determined by a second Observable.</source>
          <target state="translated">これは&lt;a href=&quot;audittime&quot;&gt; &lt;code&gt;auditTime&lt;/code&gt; &lt;/a&gt;に似ていますが、沈黙時間は2番目のObservableによって決定されます。</target>
        </trans-unit>
        <trans-unit id="c6de2f5807f7a8f592a3f85530871d0646e8235f" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;buffer&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="translated">これは&lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;buffer&lt;/code&gt; &lt;/a&gt;に似ていますが、配列の代わりにネストされたObservableを発行します。</target>
        </trans-unit>
        <trans-unit id="bb360af1ed3cecf856ed4ee0d48cd7d85b7a8dbf" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;buffercount&quot;&gt;&lt;code&gt;bufferCount&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="translated">これは&lt;a href=&quot;buffercount&quot;&gt; &lt;code&gt;bufferCount&lt;/code&gt; &lt;/a&gt;に似ていますが、配列の代わりにネストされたObservableを発行します。</target>
        </trans-unit>
        <trans-unit id="ea49a2ff2b8a6a7fb1a2e802f2a2482ba7e26405" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;buffertime&quot;&gt;&lt;code&gt;bufferTime&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="translated">これは&lt;a href=&quot;buffertime&quot;&gt; &lt;code&gt;bufferTime&lt;/code&gt; &lt;/a&gt;に似ていますが、配列の代わりにネストされたObservableを発行します。</target>
        </trans-unit>
        <trans-unit id="706a3adc8ab410c897c16a98366204b1a5b1240e" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;buffertoggle&quot;&gt;&lt;code&gt;bufferToggle&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="translated">これは&lt;a href=&quot;buffertoggle&quot;&gt; &lt;code&gt;bufferToggle&lt;/code&gt; &lt;/a&gt;に似ていますが、配列の代わりにネストされたObservableを発行します。</target>
        </trans-unit>
        <trans-unit id="c558f7f5e114dacdde1f0f95f96fa4b2c26413e6" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;bufferwhen&quot;&gt;&lt;code&gt;bufferWhen&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="translated">これは&lt;a href=&quot;bufferwhen&quot;&gt; &lt;code&gt;bufferWhen&lt;/code&gt; &lt;/a&gt;に似ていますが、配列の代わりにネストされたObservableを発行します。</target>
        </trans-unit>
        <trans-unit id="11e12fef4db4958942dc505d6a8f8247a1770fb1" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;concatmap&quot;&gt;&lt;code&gt;concatMap&lt;/code&gt;&lt;/a&gt;, but maps each value always to the same inner Observable.</source>
          <target state="translated">これは&lt;a href=&quot;concatmap&quot;&gt; &lt;code&gt;concatMap&lt;/code&gt; &lt;/a&gt;に似ていますが、各値を常に同じ内部Observableにマップします。</target>
        </trans-unit>
        <trans-unit id="e3a867c904920532b682926d9570e66b6bd84a27" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;debouncetime&quot;&gt;&lt;code&gt;debounceTime&lt;/code&gt;&lt;/a&gt;, but the time span of emission silence is determined by a second Observable.</source>
          <target state="translated">これは&lt;a href=&quot;debouncetime&quot;&gt; &lt;code&gt;debounceTime&lt;/code&gt; &lt;/a&gt;に似ていますが、無音の期間は2番目のObservableによって決定されます。</target>
        </trans-unit>
        <trans-unit id="3275012c1bb12737fa3e7ae966dc46708b8e6efc" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;delay&quot;&gt;&lt;code&gt;delay&lt;/code&gt;&lt;/a&gt;, but passes only the most recent value from each burst of emissions.</source>
          <target state="translated">これは&lt;a href=&quot;delay&quot;&gt; &lt;code&gt;delay&lt;/code&gt; &lt;/a&gt;のようなものですが、各放出バーストからの最新の値のみを渡します。</target>
        </trans-unit>
        <trans-unit id="d6cdbfb00c44af71004ef36133f0e226b40e866d" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;delay&quot;&gt;&lt;code&gt;delay&lt;/code&gt;&lt;/a&gt;, but the time span of the delay duration is determined by a second Observable.</source>
          <target state="translated">これは&lt;a href=&quot;delay&quot;&gt; &lt;code&gt;delay&lt;/code&gt; &lt;/a&gt;に似ていますが、遅延期間の期間は2番目のObservableによって決定されます。</target>
        </trans-unit>
        <trans-unit id="ce158c4252c2c44186bb2ae22b21fe949150e8db" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;distinctuntilchanged&quot;&gt;&lt;code&gt;distinctUntilChanged&lt;/code&gt;&lt;/a&gt;, but the distinct comparison uses a key to access a property.</source>
          <target state="translated">それは、distinctUntilChangedに似てい&lt;a href=&quot;distinctuntilchanged&quot;&gt; &lt;code&gt;distinctUntilChanged&lt;/code&gt; &lt;/a&gt;が、distinct比較はキーを使用してプロパティにアクセスします。</target>
        </trans-unit>
        <trans-unit id="5c0357dea7ccb925e323e6256fef87dc2aa65faa" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, but just emits the values that are distinct from the previous.</source>
          <target state="translated">これは&lt;a href=&quot;filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;に似ていますが、前のものとは異なる値を出力するだけです。</target>
        </trans-unit>
        <trans-unit id="99fd3844345480d4d64d317a7f5cce322d21307b" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, but returns two Observables: one like the output of &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, and the other with values that did not pass the condition.</source>
          <target state="translated">これは&lt;a href=&quot;filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;に似ていますが、2つのObservableを返します。1つは&lt;a href=&quot;filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;の出力のようなもので、もう1つは条件を通過しなかった値を持つものです。</target>
        </trans-unit>
        <trans-unit id="d3d241a8228a7878020999c61c552183637beb90" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but emits the index of the found value, not the value itself.</source>
          <target state="translated">これは&lt;a href=&quot;find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt;に似ていますが、値自体ではなく、見つかった値のインデックスを発行します。</target>
        </trans-unit>
        <trans-unit id="e351dca74c30132376a13304bc29d358d6a27d4a" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;mergemap&quot;&gt;&lt;code&gt;mergeMap&lt;/code&gt;&lt;/a&gt;, but maps each value always to the same inner Observable.</source>
          <target state="translated">これは&lt;a href=&quot;mergemap&quot;&gt; &lt;code&gt;mergeMap&lt;/code&gt; &lt;/a&gt;に似ていますが、各値を常に同じ内部Observableにマップします。</target>
        </trans-unit>
        <trans-unit id="5a2dae1b945020085aa1bdb445e10117bc9edf5c" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but emits the current accumulation whenever the source emits a value.</source>
          <target state="translated">それは&lt;a href=&quot;reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;に似ていますが、ソースが値を出力するたびに現在の累積を出力します。</target>
        </trans-unit>
        <trans-unit id="11335e7a911246f108a73bcdde65715b0a687052" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;sampletime&quot;&gt;&lt;code&gt;sampleTime&lt;/code&gt;&lt;/a&gt;, but samples whenever the &lt;code&gt;notifier&lt;/code&gt; Observable emits something.</source>
          <target state="translated">これは&lt;a href=&quot;sampletime&quot;&gt; &lt;code&gt;sampleTime&lt;/code&gt; &lt;/a&gt;に似ていますが、 &lt;code&gt;notifier&lt;/code&gt; Observableが何かを出力するたびにサンプリングします。</target>
        </trans-unit>
        <trans-unit id="9c680229f70e56c617131cc1ad57ec227fad2968" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;scan&quot;&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/a&gt;, but the Observables returned by the accumulator are merged into the outer Observable.</source>
          <target state="translated">これは&lt;a href=&quot;scan&quot;&gt; &lt;code&gt;scan&lt;/code&gt; &lt;/a&gt;に似ていますが、アキュムレータから返されたObservableは外側のObservableにマージされます。</target>
        </trans-unit>
        <trans-unit id="91c3e182197c6bbc8865c1e13f76ab49385127db" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;switchmap&quot;&gt;&lt;code&gt;switchMap&lt;/code&gt;&lt;/a&gt;, but maps each value always to the same inner Observable.</source>
          <target state="translated">これは&lt;a href=&quot;switchmap&quot;&gt; &lt;code&gt;switchMap&lt;/code&gt; &lt;/a&gt;に似ていますが、各値を常に同じ内部Observableにマップします。</target>
        </trans-unit>
        <trans-unit id="30b32b4febb6083279feeaff98ca0e142595e8ea" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;throttletime&quot;&gt;&lt;code&gt;throttleTime&lt;/code&gt;&lt;/a&gt;, but the silencing duration is determined by a second Observable.</source>
          <target state="translated">これは、&lt;a href=&quot;throttletime&quot;&gt; &lt;code&gt;throttleTime&lt;/code&gt; &lt;/a&gt;に似ていますが、沈黙時間は2番目のObservableによって決定されます。</target>
        </trans-unit>
        <trans-unit id="8810900091c7ff83ffa55bebab9241df1287ca4d" translate="yes" xml:space="preserve">
          <source>It's similar to &lt;a href=&quot;mergemap&quot;&gt;&lt;code&gt;mergeMap&lt;/code&gt;&lt;/a&gt;, but applies the projection function to every source value as well as every output value. It's recursive.</source>
          <target state="translated">これは&lt;a href=&quot;mergemap&quot;&gt; &lt;code&gt;mergeMap&lt;/code&gt; &lt;/a&gt;に似ていますが、すべての出力値だけでなくすべてのソース値に射影関数を適用します。再帰的です。</target>
        </trans-unit>
        <trans-unit id="dcf6717fe65da536a04da4f882bbdfa195868e09" translate="yes" xml:space="preserve">
          <source>Iteration step function.</source>
          <target state="translated">反復ステップ関数。</target>
        </trans-unit>
        <trans-unit id="2b22b7393382746b99d053013a324ab18c83302f" translate="yes" xml:space="preserve">
          <source>IteratorObservable</source>
          <target state="translated">IteratorObservable</target>
        </trans-unit>
        <trans-unit id="18774004fcf928104b67925a5470d3718ffd4dd1" translate="yes" xml:space="preserve">
          <source>Its like &lt;a href=&quot;interval&quot;&gt;&lt;code&gt;interval&lt;/code&gt;&lt;/a&gt;, but you can specify when should the emissions start.</source>
          <target state="translated">その&lt;a href=&quot;interval&quot;&gt; &lt;code&gt;interval&lt;/code&gt; &lt;/a&gt;と似ていますが、排出を開始するタイミングを指定できます。</target>
        </trans-unit>
        <trans-unit id="1203b0749dc07175c4d76a73a84de4edcdb74c59" translate="yes" xml:space="preserve">
          <source>Join Creation Operators</source>
          <target state="translated">クリエイション・オペレーターに参加する</target>
        </trans-unit>
        <trans-unit id="63c003abaf20a9193778451d8079bc48f87ac911" translate="yes" xml:space="preserve">
          <source>Join Operators</source>
          <target state="translated">オペレータに参加する</target>
        </trans-unit>
        <trans-unit id="84e488e39c2aaa417a3c3e76304c3db42f028475" translate="yes" xml:space="preserve">
          <source>Joins every Observable emitted by the source (a higher-order Observable), in a serial fashion. It subscribes to each inner Observable only after the previous inner Observable has completed, and merges all of their values into the returned observable.</source>
          <target state="translated">ソース(高次のObservable)から放出された全てのObservableをシリアルに結合します。前の内側のObservableが完了した後にのみ、それぞれの内側のObservableに加入し、それらの値をすべてマージして戻り値のObservableにします。</target>
        </trans-unit>
        <trans-unit id="3515b72ff2f6de015a4a8c6afbf292965ba26aa0" translate="yes" xml:space="preserve">
          <source>Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is installed and removed in each of elements.</source>
          <target state="translated">NodeListの場合と同様に、それはDOMノードの集合体です。ここでもイベントハンドラ関数が各要素にインストールされたり削除されたりします。</target>
        </trans-unit>
        <trans-unit id="404e85255f54d27c3b2cdce08ac4a990657b5eac" translate="yes" xml:space="preserve">
          <source>Just as many array library combine &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat&quot;&gt;&lt;code&gt;flat()&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;flatten()&lt;/code&gt;) into a single &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap&quot;&gt;&lt;code&gt;flatMap()&lt;/code&gt;&lt;/a&gt;, there are mapping equivalents of all the RxJS flattening operators &lt;a href=&quot;../api/operators/concatmap&quot;&gt;&lt;code&gt;concatMap()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/operators/mergemap&quot;&gt;&lt;code&gt;mergeMap()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/operators/switchmap&quot;&gt;&lt;code&gt;switchMap()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../api/operators/exhaustmap&quot;&gt;&lt;code&gt;exhaustMap()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">多くの配列ライブラリが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat&quot;&gt; &lt;code&gt;flat()&lt;/code&gt; &lt;/a&gt;（または &lt;code&gt;flatten()&lt;/code&gt; ）を単一の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap&quot;&gt; &lt;code&gt;flatMap()&lt;/code&gt; &lt;/a&gt;に結合するのと同じように、RxJSのすべての平坦化演算子&lt;a href=&quot;../api/operators/concatmap&quot;&gt; &lt;code&gt;concatMap()&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../api/operators/mergemap&quot;&gt; &lt;code&gt;mergeMap()&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../api/operators/switchmap&quot;&gt; &lt;code&gt;switchMap()&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../api/operators/exhaustmap&quot;&gt; &lt;code&gt;exhaustMap()&lt;/code&gt; &lt;/a&gt;マップと同等のマッピングがあります（）。</target>
        </trans-unit>
        <trans-unit id="6c1daef5575638ed8a0458933187be02bbdef946" translate="yes" xml:space="preserve">
          <source>Just emits 'complete', and nothing else.</source>
          <target state="translated">ただ「完全」を発するだけで、それ以外は何もない。</target>
        </trans-unit>
        <trans-unit id="c3af46a19db3dcac82625d7bebe2770ee0d8fc0f" translate="yes" xml:space="preserve">
          <source>Just emits 'error', and nothing else.</source>
          <target state="translated">エラー」を出すだけで、それ以外は何も出ません。</target>
        </trans-unit>
        <trans-unit id="1b80e3c5bd407999419466edbb962c55711528d1" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;observable.subscribe&lt;/code&gt; resembles &lt;code&gt;new Observable(function subscribe() {...})&lt;/code&gt;, the &lt;code&gt;unsubscribe&lt;/code&gt; we return from &lt;code&gt;subscribe&lt;/code&gt; is conceptually equal to &lt;code&gt;subscription.unsubscribe&lt;/code&gt;. In fact, if we remove the ReactiveX types surrounding these concepts, we're left with rather straightforward JavaScript.</source>
          <target state="translated">同じよう &lt;code&gt;observable.subscribe&lt;/code&gt; の似ている &lt;code&gt;new Observable(function subscribe() {...})&lt;/code&gt; 、 &lt;code&gt;unsubscribe&lt;/code&gt; から我々の戻り &lt;code&gt;subscribe&lt;/code&gt; 、概念的に等しい &lt;code&gt;subscription.unsubscribe&lt;/code&gt; 。実際、これらの概念を取り巻くReactiveXタイプを削除すると、かなり単純なJavaScriptが残ります。</target>
        </trans-unit>
        <trans-unit id="f5025143a89e9b224781aa62468c0e2c91c66496" translate="yes" xml:space="preserve">
          <source>Known Issues</source>
          <target state="translated">既知の問題</target>
        </trans-unit>
        <trans-unit id="52fab7dcbdbdd2ead5469234d5dae4a2b47ad34c" translate="yes" xml:space="preserve">
          <source>Last argument to &lt;code&gt;multiplex&lt;/code&gt; is a &lt;code&gt;messageFilter&lt;/code&gt; function which should return a boolean. It is used to filter out messages sent by the server to only those that belong to simulated WebSocket stream. For example, server might mark these messages with some kind of string identifier on a message object and &lt;code&gt;messageFilter&lt;/code&gt; would return &lt;code&gt;true&lt;/code&gt; if there is such identifier on an object emitted by the socket. Messages which returns &lt;code&gt;false&lt;/code&gt; in &lt;code&gt;messageFilter&lt;/code&gt; are simply skipped, and are not passed down the stream.</source>
          <target state="translated">&lt;code&gt;multiplex&lt;/code&gt; 最後の引数は、ブール値を返すはずの &lt;code&gt;messageFilter&lt;/code&gt; 関数です。これは、サーバーから送信されたメッセージを、シミュレートされたWebSocketストリームに属するメッセージのみにフィルターで除外するために使用されます。たとえば、サーバーはこれらのメッセージをメッセージオブジェクトのなんらかの文字列識別子でマークし、ソケットによって &lt;code&gt;messageFilter&lt;/code&gt; されたオブジェクトにそのような識別子が &lt;code&gt;true&lt;/code&gt; 場合、messageFilterはtrueを返します。返すメッセージ &lt;code&gt;false&lt;/code&gt; に &lt;code&gt;messageFilter&lt;/code&gt; は単にスキップされ、下流に渡されません。</target>
        </trans-unit>
        <trans-unit id="ae3a986fdd0c26fe5d0e22d38167502d27e4db8f" translate="yes" xml:space="preserve">
          <source>Lets a value pass, then ignores source values for the next &lt;code&gt;duration&lt;/code&gt; milliseconds.</source>
          <target state="translated">値を渡してから、次の &lt;code&gt;duration&lt;/code&gt; ミリ秒のソース値を無視します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
