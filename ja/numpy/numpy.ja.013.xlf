<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="d2fd87ac5f2fe419cf576e3d1240b873a7fd353f" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte unsigned integer.</source>
          <target state="translated">64ビット/8バイトの符号なし整数の列挙値。</target>
        </trans-unit>
        <trans-unit id="7aee8554ea2f116b0ced362cc168497aed3b5e7d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a data type which holds dates or datetimes with a precision based on selectable date or time units.</source>
          <target state="translated">選択可能な日付または時間単位に基づいた精度で日付または日付時刻を保持するデータ型の列挙値。</target>
        </trans-unit>
        <trans-unit id="81373e1b16d0b1374953b29f2c2ce84e5c1e7ca6" translate="yes" xml:space="preserve">
          <source>The enumeration value for a data type which holds lengths of times in integers of selectable date or time units.</source>
          <target state="translated">選択可能な日付または時間単位の整数で時間の長さを保持するデータ型の列挙値。</target>
        </trans-unit>
        <trans-unit id="025565ff9d1efa7089189ec4ae9c78d4afba6baf" translate="yes" xml:space="preserve">
          <source>The enumeration value for a platform-specific complex floating point type which is made up of two NPY_LONGDOUBLE values.</source>
          <target state="translated">2つのNPY_LONGDOUBLE値からなるプラットフォーム固有の複素浮動小数点型の列挙値。</target>
        </trans-unit>
        <trans-unit id="02ee59a76dc8246cf577894e400f4aef4b3c2cdb" translate="yes" xml:space="preserve">
          <source>The enumeration value for a platform-specific floating point type which is at least as large as NPY_DOUBLE, but larger on many platforms.</source>
          <target state="translated">プラットフォーム固有の浮動小数点型の列挙値で、少なくとも NPY_DOUBLE と同じくらいの大きさですが、多くのプラットフォームではそれよりも大きい値になります。</target>
        </trans-unit>
        <trans-unit id="12bd9d6078665b062a610e653e29b9b8b5cd0f4d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a signed integer type which is the same size as a (void *) pointer. This is the type used by all arrays of indices.</source>
          <target state="translated">(void *)ポインタと同じサイズの符号付き整数型の列挙値。これはインデックスのすべての配列で使用される型です。</target>
        </trans-unit>
        <trans-unit id="1915b2aac968e6b707b08a802a86e659f6b7b54c" translate="yes" xml:space="preserve">
          <source>The enumeration value for an 8-bit/1-byte signed integer.</source>
          <target state="translated">8ビット/1バイト符号付き整数の列挙値。</target>
        </trans-unit>
        <trans-unit id="e2cde6e55c74a7eec76c04ac7971b58aabed014c" translate="yes" xml:space="preserve">
          <source>The enumeration value for an 8-bit/1-byte unsigned integer.</source>
          <target state="translated">8ビット/1バイト符号なし整数の列挙値。</target>
        </trans-unit>
        <trans-unit id="3bc60c39b304a6beb211c263d892c90730d59bf2" translate="yes" xml:space="preserve">
          <source>The enumeration value for an unsigned integer type which is the same size as a (void *) pointer.</source>
          <target state="translated">(void *)ポインタと同じサイズの符号なし整数型の列挙値。</target>
        </trans-unit>
        <trans-unit id="00cb2e716adb7d63188da00709d01e2a11b34089" translate="yes" xml:space="preserve">
          <source>The enumeration value for references to arbitrary Python objects.</source>
          <target state="translated">任意のPythonオブジェクトへの参照のための列挙値。</target>
        </trans-unit>
        <trans-unit id="dbec8c6917cdb1fb9cc672eba6fd415b762d7774" translate="yes" xml:space="preserve">
          <source>The enumeration value for the boolean type, stored as one byte. It may only be set to the values 0 and 1.</source>
          <target state="translated">ブール型の列挙値で、1バイトとして格納されています。値0と1にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="f6d7694b75b473ad222039c05e89641ad1c019cb" translate="yes" xml:space="preserve">
          <source>The enumeration value of the type used for masks, such as with the &lt;a href=&quot;c-api.iterator#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; iterator flag. This is equivalent to &lt;a href=&quot;#c.NPY_UINT8&quot;&gt;&lt;code&gt;NPY_UINT8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c-api.iterator#c.NPY_ITER_ARRAYMASK&quot;&gt; &lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt; &lt;/a&gt;イテレータフラグなど、マスクに使用されるタイプの列挙値。これは&lt;a href=&quot;#c.NPY_UINT8&quot;&gt; &lt;code&gt;NPY_UINT8&lt;/code&gt; &lt;/a&gt;と同等です。</target>
        </trans-unit>
        <trans-unit id="60104b59eca7223d2be466212e148860409e987c" translate="yes" xml:space="preserve">
          <source>The equivalent for floating point data types.</source>
          <target state="translated">浮動小数点データ型に相当します。</target>
        </trans-unit>
        <trans-unit id="4e36288c483218b6153f62263e1c19e0918537e1" translate="yes" xml:space="preserve">
          <source>The equivalent for integer data types.</source>
          <target state="translated">整数データ型に相当します。</target>
        </trans-unit>
        <trans-unit id="7c428e56ed9d259c349566498573b0b72cf82c45" translate="yes" xml:space="preserve">
          <source>The error mask is a single integer that holds the treatment information on all four floating point errors. The information for each error type is contained in three bits of the integer. If we print it in base 8, we can see what treatment is set for &amp;ldquo;invalid&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, and &amp;ldquo;divide&amp;rdquo; (in that order). The printed string can be interpreted with</source>
          <target state="translated">エラーマスクは、4つの浮動小数点エラーすべての処理情報を保持する単一の整数です。各エラータイプの情報は、整数の3ビットに含まれています。ベース8で印刷すると、「無効」、「アンダー」、「オーバー」、および「分割」に設定されている処理がこの順序で表示されます。印刷された文字列は、</target>
        </trans-unit>
        <trans-unit id="6236f64a81230ccb9458bf1fe006ba3279baed6f" translate="yes" xml:space="preserve">
          <source>The error message to be printed in case of failure.</source>
          <target state="translated">失敗した場合に表示されるエラーメッセージ。</target>
        </trans-unit>
        <trans-unit id="46e36d39518380daadad6b1e62b8973365b854c8" translate="yes" xml:space="preserve">
          <source>The error object contains all information that defines the error handling behavior in NumPy. &lt;a href=&quot;#numpy.geterrobj&quot;&gt;&lt;code&gt;geterrobj&lt;/code&gt;&lt;/a&gt; is used internally by the other functions that get and set error handling behavior (&lt;a href=&quot;numpy.geterr#numpy.geterr&quot;&gt;&lt;code&gt;geterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.geterrcall#numpy.geterrcall&quot;&gt;&lt;code&gt;geterrcall&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">エラーオブジェクトには、NumPyでのエラー処理動作を定義するすべての情報が含まれています。&lt;a href=&quot;#numpy.geterrobj&quot;&gt; &lt;code&gt;geterrobj&lt;/code&gt; &lt;/a&gt;は、エラー処理動作を取得および設定する他の関数（&lt;a href=&quot;numpy.geterr#numpy.geterr&quot;&gt; &lt;code&gt;geterr&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;numpy.geterrcall#numpy.geterrcall&quot;&gt; &lt;code&gt;geterrcall&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt;）によって内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="d7bceac49145568dab2a83ccab3ab1eea9b12faf" translate="yes" xml:space="preserve">
          <source>The error object contains all information that defines the error handling behavior in NumPy. &lt;a href=&quot;#numpy.seterrobj&quot;&gt;&lt;code&gt;seterrobj&lt;/code&gt;&lt;/a&gt; is used internally by the other functions that set error handling behavior (&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">エラーオブジェクトには、NumPyでのエラー処理動作を定義するすべての情報が含まれています。&lt;a href=&quot;#numpy.seterrobj&quot;&gt; &lt;code&gt;seterrobj&lt;/code&gt; &lt;/a&gt;は、エラー処理動作を設定する他の関数（&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt;）によって内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="717ffb083d9a010e39e00d26ae4cbb3686fdec82" translate="yes" xml:space="preserve">
          <source>The error object, a list containing three elements: [internal numpy buffer size, error mask, error callback function].</source>
          <target state="translated">エラーオブジェクトは、3つの要素を含むリストです。内部numpyバッファサイズ、エラーマスク、エラーコールバック関数]の3つの要素を含むリストです。</target>
        </trans-unit>
        <trans-unit id="9f5b3632192f41c961bfe841ce3532fd1faa0967" translate="yes" xml:space="preserve">
          <source>The evaluation uses Clenshaw recursion, aka synthetic division.</source>
          <target state="translated">評価はクレンショーの再帰、別名合成分割を使用しています。</target>
        </trans-unit>
        <trans-unit id="9a7486fe20eefd44f8d5d46a29c17743d8baf71d" translate="yes" xml:space="preserve">
          <source>The evaluation uses Horner&amp;rsquo;s method.</source>
          <target state="translated">評価はホーナーの方法を使用しています。</target>
        </trans-unit>
        <trans-unit id="db5640fe4648623a565ed032ffc116fcc6e293bd" translate="yes" xml:space="preserve">
          <source>The exact definition of a slow test is obviously both subjective and hardware-dependent, but in general any individual test that requires more than a second or two should be labeled as slow (the whole suite consists of thousands of tests, so even a second is significant).</source>
          <target state="translated">遅いテストの正確な定義は、明らかに主観的であり、ハードウェアに依存しますが、一般的には、1~2秒以上かかる個々のテストは、遅いと表示されるべきです(スイート全体では何千ものテストで構成されているため、1秒でも重要です)。</target>
        </trans-unit>
        <trans-unit id="4a28216e8d502daba2aa9f77ed97bda4ac746a41" translate="yes" xml:space="preserve">
          <source>The exceptions to the above rules are given below:</source>
          <target state="translated">上記のルールの例外については、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="8953035a1ae2630eb8257139de6a8432deef2d8b" translate="yes" xml:space="preserve">
          <source>The expected object.</source>
          <target state="translated">期待されるオブジェクト。</target>
        </trans-unit>
        <trans-unit id="ec4e2a0cf38710bdb603b5d339066519f8b6c301" translate="yes" xml:space="preserve">
          <source>The expected string.</source>
          <target state="translated">期待される文字列。</target>
        </trans-unit>
        <trans-unit id="59f101f805e4afd5d4f5aac41091912e82f52cce" translate="yes" xml:space="preserve">
          <source>The exponent can be any integer or long integer, positive, negative, or zero.</source>
          <target state="translated">指数は、任意の整数または長整数、正、負、ゼロのいずれかである。</target>
        </trans-unit>
        <trans-unit id="48bfe58fce3c9524a47514144118fc15384f8ce9" translate="yes" xml:space="preserve">
          <source>The exponent that yields &lt;code&gt;eps&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eps&lt;/code&gt; を生成する指数。</target>
        </trans-unit>
        <trans-unit id="8728d1625b1f4800f5da44ea73eddec8a90b29f7" translate="yes" xml:space="preserve">
          <source>The exponent that yields &lt;code&gt;epsneg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;epsneg&lt;/code&gt; を生成する指数。</target>
        </trans-unit>
        <trans-unit id="3d2aac84d1e998e3af66433136551e2122fcd6db" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#r0dbb9b01ef9c-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#r0dbb9b01ef9c-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">指数分布は、幾何分布の連続的な類似物です。多くの暴風雨で測定された雨滴のサイズ&lt;a href=&quot;#r0dbb9b01ef9c-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;や、ウィキペディアへのページリクエスト間の時間&lt;a href=&quot;#r0dbb9b01ef9c-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;など、多くの一般的な状況を説明します。</target>
        </trans-unit>
        <trans-unit id="ae0234d51209697de2e3092417cea04cdd633ab5" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#rcf497e7bc958-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#rcf497e7bc958-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">指数分布は、幾何分布の連続的な類似物です。多くの暴風雨で測定された雨滴のサイズ&lt;a href=&quot;#rcf497e7bc958-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;や、ウィキペディアへのページリクエスト間の時間&lt;a href=&quot;#rcf497e7bc958-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;など、多くの一般的な状況を説明します。</target>
        </trans-unit>
        <trans-unit id="33ed180d63f4fd6bda2a99808d388e4ba0b2acb0" translate="yes" xml:space="preserve">
          <source>The exponents. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">指数。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="330beb4f458d2c8c447ab8cdae27158e06bf7cb9" translate="yes" xml:space="preserve">
          <source>The extracted diagonal or constructed diagonal array.</source>
          <target state="translated">抽出された対角線または構築された対角線配列。</target>
        </trans-unit>
        <trans-unit id="c76b262eba97deb65c7a5b3c9fb6314561e8e763" translate="yes" xml:space="preserve">
          <source>The field names, either specified as a comma-separated string in the form &lt;code&gt;'col1, col2, col3'&lt;/code&gt;, or as a list or tuple of strings in the form &lt;code&gt;['col1', 'col2', 'col3']&lt;/code&gt;. An empty list can be used, in that case default field names (&amp;lsquo;f0&amp;rsquo;, &amp;lsquo;f1&amp;rsquo;, &amp;hellip;) are used.</source>
          <target state="translated">フィールド名。 &lt;code&gt;'col1, col2, col3'&lt;/code&gt; の形式のコンマ区切りの文字列として、または &lt;code&gt;['col1', 'col2', 'col3']&lt;/code&gt; の形式の文字列のリストまたはタプルとして指定します。空のリストを使用できます。その場合、デフォルトのフィールド名（ 'f0'、 'f1'、&amp;hellip;）が使用されます。</target>
        </trans-unit>
        <trans-unit id="0a3f62236ba0b0b8ce93c2fc463e81343db95a91" translate="yes" xml:space="preserve">
          <source>The file contains an object array, but allow_pickle=False given.</source>
          <target state="translated">ファイルにはオブジェクト配列が含まれていますが、allow_pickle=Falseが与えられています。</target>
        </trans-unit>
        <trans-unit id="cd858c6c51a98e96ec8ac35aea8fe45863b797ca" translate="yes" xml:space="preserve">
          <source>The file is opened in this mode:</source>
          <target state="translated">このモードでファイルを開きます。</target>
        </trans-unit>
        <trans-unit id="5b33f093bafabe18517ca8ac91b17b43d100f40c" translate="yes" xml:space="preserve">
          <source>The file name or file object to be used as the array data buffer.</source>
          <target state="translated">配列データバッファとして使用するファイル名またはファイルオブジェクト。</target>
        </trans-unit>
        <trans-unit id="26bdea2d86889049bdd7c48c4150155a14c6f9d5" translate="yes" xml:space="preserve">
          <source>The file or file name to load.</source>
          <target state="translated">読み込むファイルまたはファイル名。</target>
        </trans-unit>
        <trans-unit id="410bba1d09731e6c1884743045c51541ebe57e5e" translate="yes" xml:space="preserve">
          <source>The file to pickle &lt;code&gt;a&lt;/code&gt; to. If a string, the full path to the file.</source>
          <target state="translated">ピクル &lt;code&gt;a&lt;/code&gt; ファイル。文字列の場合、ファイルへの完全パス。</target>
        </trans-unit>
        <trans-unit id="48b7a50cb95566779f051ba6cb8275f9d03a7f05" translate="yes" xml:space="preserve">
          <source>The file to read. File-like objects must support the &lt;code&gt;seek()&lt;/code&gt; and &lt;code&gt;read()&lt;/code&gt; methods. Pickled files require that the file-like object support the &lt;code&gt;readline()&lt;/code&gt; method as well.</source>
          <target state="translated">読み取るファイル。ファイルのようなオブジェクトは &lt;code&gt;seek()&lt;/code&gt; および &lt;code&gt;read()&lt;/code&gt; メソッドをサポートする必要があります。ピクルされたファイルでは、ファイルのようなオブジェクトが &lt;code&gt;readline()&lt;/code&gt; メソッドもサポートしている必要があります。</target>
        </trans-unit>
        <trans-unit id="68f5b58fd976e02c0c3bbbefcb6355b0422acf86" translate="yes" xml:space="preserve">
          <source>The fill_value is set to &lt;code&gt;value&lt;/code&gt; and the mask is set to &lt;code&gt;nomask&lt;/code&gt; if possible.</source>
          <target state="translated">fill_valueは &lt;code&gt;value&lt;/code&gt; に設定され、 &lt;code&gt;nomask&lt;/code&gt; マスクはnomaskに設定されます。</target>
        </trans-unit>
        <trans-unit id="ac0cc14c76ce415edde3f9c0f5c15cc239b98f83" translate="yes" xml:space="preserve">
          <source>The filled array.</source>
          <target state="translated">埋め尽くされた配列。</target>
        </trans-unit>
        <trans-unit id="02297c05ffd69a001bc553284a8c48319db02e69" translate="yes" xml:space="preserve">
          <source>The filling value of the masked array is a scalar.</source>
          <target state="translated">マスクされた配列の充填値はスカラです。</target>
        </trans-unit>
        <trans-unit id="104abb4185415b9595a8eb2fd00671acf84e203a" translate="yes" xml:space="preserve">
          <source>The filling value of the masked array is a scalar. When setting, None will set to a default based on the data type.</source>
          <target state="translated">マスクされた配列の充填値はスカラです。設定すると、データ型に応じて None がデフォルトで設定されます。</target>
        </trans-unit>
        <trans-unit id="0bd5aa8a98810899514ee710bc2579712901ebe5" translate="yes" xml:space="preserve">
          <source>The final value of the sequence, unless &lt;code&gt;endpoint&lt;/code&gt; is False. In that case, &lt;code&gt;num + 1&lt;/code&gt; values are spaced over the interval in log-space, of which all but the last (a sequence of length &lt;code&gt;num&lt;/code&gt;) are returned.</source>
          <target state="translated">&lt;code&gt;endpoint&lt;/code&gt; がFalse でない限り、シーケンスの最終値。その場合、 &lt;code&gt;num + 1&lt;/code&gt; 値はlog-spaceの間隔で間隔をあけて配置され、最後以外のすべて（長さ &lt;code&gt;num&lt;/code&gt; のシーケンス）が返されます。</target>
        </trans-unit>
        <trans-unit id="5b6f2d1ecce5ed0ec2d0e715086fccc9259a6627" translate="yes" xml:space="preserve">
          <source>The first 6 bytes are a magic string: exactly &lt;code&gt;\x93NUMPY&lt;/code&gt;.</source>
          <target state="translated">最初の6バイトはマジックストリングです。正確には &lt;code&gt;\x93NUMPY&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="df3f3dac6a267f56fafa2c760b8d38d59413267f" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;nargs&lt;/code&gt; elements of &lt;code&gt;steps&lt;/code&gt; remain the same as for scalar ufuncs. The following elements contain the strides of all core dimensions for all arguments in order.</source>
          <target state="translated">&lt;code&gt;steps&lt;/code&gt; の最初の &lt;code&gt;nargs&lt;/code&gt; 要素は、スカラーufuncの場合と同じです。次の要素には、すべての引数のすべてのコアディメンションのストライドが順番に含まれています。</target>
        </trans-unit>
        <trans-unit id="b9577dc8ae8dc3d75fe0e9351485a971c104657b" translate="yes" xml:space="preserve">
          <source>The first argument contains the Extension instance that can be useful to access its attributes like &lt;code&gt;depends&lt;/code&gt;, &lt;code&gt;sources&lt;/code&gt;, etc. lists and modify them during the building process. The second argument gives a path to a build directory that must be used when creating files to a disk.</source>
          <target state="translated">最初の引数には、 &lt;code&gt;depends&lt;/code&gt; 、 &lt;code&gt;sources&lt;/code&gt; などの属性にアクセスし、ビルドプロセス中にそれらを変更するのに役立つExtensionインスタンスが含まれています。2番目の引数は、ディスクにファイルを作成するときに使用する必要があるビルドディレクトリへのパスを指定します。</target>
        </trans-unit>
        <trans-unit id="98f417ae094b593aad4f373856f9d75fc3caadf1" translate="yes" xml:space="preserve">
          <source>The first argument is any object that can be converted into a fixed-size data-type object. The second argument is the desired shape of this type. If the shape parameter is 1, then the data-type object is equivalent to fixed dtype. If &lt;em&gt;shape&lt;/em&gt; is a tuple, then the new dtype defines a sub-array of the given shape.</source>
          <target state="translated">最初の引数は、固定サイズのデータ​​型オブジェクトに変換できる任意のオブジェクトです。2番目の引数は、このタイプの望ましい形状です。形状パラメーターが1の場合、データ型オブジェクトは固定dtypeと同等です。&lt;em&gt;shape&lt;/em&gt;がタプルの場合、新しいdtypeは指定された形状のサブ配列を定義します。</target>
        </trans-unit>
        <trans-unit id="2a0c10acae5d14d1b06af72f8c3df392eea96371" translate="yes" xml:space="preserve">
          <source>The first argument must be an object that is converted to a zero-sized flexible data-type object, the second argument is an integer providing the desired itemsize.</source>
          <target state="translated">第一引数はゼロサイズの柔軟なデータ型オブジェクトに変換されたオブジェクトでなければならず、第二引数は希望するアイテムサイズを提供する整数です。</target>
        </trans-unit>
        <trans-unit id="4ab185078e9e031c6680e1f1eab45ad50f864a10" translate="yes" xml:space="preserve">
          <source>The first array shows the outcomes of throwing the dice 10 times, and the second shows the outcomes from throwing the dice 20 times.</source>
          <target state="translated">最初の配列はサイコロを10回投げたときの結果を示し、2番目の配列はサイコロを20回投げたときの結果を示します。</target>
        </trans-unit>
        <trans-unit id="251cc7294c3d03a290266d04d53995289d0bed50" translate="yes" xml:space="preserve">
          <source>The first assert does not raise an exception:</source>
          <target state="translated">最初のアサートでは例外は発生しません。</target>
        </trans-unit>
        <trans-unit id="0135e65581d52468c8b55907d113ce790f408aef" translate="yes" xml:space="preserve">
          <source>The first business day on or after a date:</source>
          <target state="translated">日付が入った日以降の最初の営業日。</target>
        </trans-unit>
        <trans-unit id="034408f6ac73256e0eb3a019833e3b1d26d2adb1" translate="yes" xml:space="preserve">
          <source>The first business day strictly after a date:</source>
          <target state="translated">厳密にはデートの後の最初の営業日。</target>
        </trans-unit>
        <trans-unit id="d4d700653c3699a51205d4e8a1ce2d74d29df2ba" translate="yes" xml:space="preserve">
          <source>The first character specifies the kind of data and the remaining characters specify the number of bytes per item, except for Unicode, where it is interpreted as the number of characters. The item size must correspond to an existing type, or an error will be raised. The supported kinds are</source>
          <target state="translated">最初の文字はデータの種類を指定し、残りの文字は項目ごとのバイト数を指定します。項目のサイズは既存の型に対応していなければならず、そうしないとエラーが発生します。サポートされている種類は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="fce5520747cac508bb51c31e51bc43340f4f28dc" translate="yes" xml:space="preserve">
          <source>The first difference is given by &lt;code&gt;out[i] = a[i+1] - a[i]&lt;/code&gt; along the given axis, higher differences are calculated by using &lt;a href=&quot;#numpy.diff&quot;&gt;&lt;code&gt;diff&lt;/code&gt;&lt;/a&gt; recursively.</source>
          <target state="translated">最初の差は、与えられた軸に沿って &lt;code&gt;out[i] = a[i+1] - a[i]&lt;/code&gt; で与えられます。より高い差は、&lt;a href=&quot;#numpy.diff&quot;&gt; &lt;code&gt;diff&lt;/code&gt; を&lt;/a&gt;再帰的に使用して計算されます。</target>
        </trans-unit>
        <trans-unit id="a9df17052dacee8cafb40ea7e55b18075cf5de14" translate="yes" xml:space="preserve">
          <source>The first element, &lt;em&gt;field_name&lt;/em&gt;, is the field name (if this is &lt;code&gt;''&lt;/code&gt; then a standard field name, &lt;code&gt;'f#'&lt;/code&gt;, is assigned). The field name may also be a 2-tuple of strings where the first string is either a &amp;ldquo;title&amp;rdquo; (which may be any string or unicode string) or meta-data for the field which can be any object, and the second string is the &amp;ldquo;name&amp;rdquo; which must be a valid Python identifier.</source>
          <target state="translated">最初の要素&lt;em&gt;field_name&lt;/em&gt;はフィールド名です（これが &lt;code&gt;''&lt;/code&gt; の場合、標準のフィールド名 &lt;code&gt;'f#'&lt;/code&gt; が割り当てられます）。フィールド名は2タプルの文字列にすることもできます。最初の文字列は「タイトル」（任意の文字列またはUnicode文字列）または任意のオブジェクトにすることができるフィールドのメタデータで、2番目の文字列は有効なPython識別子である必要がある「名前」。</target>
        </trans-unit>
        <trans-unit id="67d77719eacdaf274558e4a616994274e8d068b0" translate="yes" xml:space="preserve">
          <source>The first example integrates &lt;code&gt;p&lt;/code&gt; once, the second example integrates it twice. By default, the lower bound of the integration and the integration constant are 0, but both can be specified.:</source>
          <target state="translated">最初の例は &lt;code&gt;p&lt;/code&gt; を 1回積分し、2番目の例は2回積分します。デフォルトでは、積分の下限と積分定数は0ですが、両方を指定できます。</target>
        </trans-unit>
        <trans-unit id="311abfb54dbdf5d2ba16af23aef0589cc8d8cc86" translate="yes" xml:space="preserve">
          <source>The first form should be preferred.</source>
          <target state="translated">第一形態が好ましい。</target>
        </trans-unit>
        <trans-unit id="eb41b42b24f210f1f4be6981685ada6a1cb54412" translate="yes" xml:space="preserve">
          <source>The first law of Laplace, from 1774, states that the frequency of an error can be expressed as an exponential function of the absolute magnitude of the error, which leads to the Laplace distribution. For many problems in economics and health sciences, this distribution seems to model the data better than the standard Gaussian distribution.</source>
          <target state="translated">1774年のラプラスの第1法則は、誤差の頻度が誤差の絶対的な大きさの指数関数として表現できることを述べており、これがラプラス分布につながります。経済学や健康科学の多くの問題では、この分布は、標準のガウス分布よりもデータをよりよくモデル化しているようです。</target>
        </trans-unit>
        <trans-unit id="f7deea27a398e3cec5cdd6f79c6e53fb0be11445" translate="yes" xml:space="preserve">
          <source>The first output can be provided as either a positional or a keyword parameter. Keyword &amp;lsquo;out&amp;rsquo; arguments are incompatible with positional ones.</source>
          <target state="translated">最初の出力は、位置パラメータまたはキーワードパラメータとして提供できます。キーワードの 'out'引数は定位置引数と互換性がありません。</target>
        </trans-unit>
        <trans-unit id="6c26c4fe0578c2071a8b45fe1c269e9b84d2d403" translate="yes" xml:space="preserve">
          <source>The first parameter, arr, must be an ndarray or subclass. The parameter, &lt;em&gt;flags&lt;/em&gt;, should be an integer consisting of bitwise combinations of the possible flags an array can have: &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">最初のパラメーターarrは、ndarrayまたはサブクラスでなければなりません。パラメータ&lt;em&gt;フラグは&lt;/em&gt;、配列が持つことができる可能なフラグのビット単位の組み合わせからなる整数でなければならない：&lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt; &lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8639bf3cb0cf6544a568d7a40bcc68d44fbb8c9" translate="yes" xml:space="preserve">
          <source>The first signature listed, &lt;code&gt;( DATA_TYPE IN_ARRAY[ANY] )&lt;/code&gt; is for one-dimensional arrays with hard-coded dimensions. Likewise, &lt;code&gt;( DATA_TYPE IN_ARRAY2[ANY][ANY] )&lt;/code&gt; is for two-dimensional arrays with hard-coded dimensions, and similarly for three-dimensional.</source>
          <target state="translated">リストされている最初のシグネチャ &lt;code&gt;( DATA_TYPE IN_ARRAY[ANY] )&lt;/code&gt; は、ハードコードされた次元を持つ1次元配列用です。同様に、 &lt;code&gt;( DATA_TYPE IN_ARRAY2[ANY][ANY] )&lt;/code&gt; は、ハードコードされた次元を持つ2次元配列用であり、同様に3次元用です。</target>
        </trans-unit>
        <trans-unit id="21bc00ee1c8a15912cb2e713abebe2d2f93cd1e7" translate="yes" xml:space="preserve">
          <source>The first thing done is to look-up in the thread-specific global dictionary the current values for the buffer-size, the error mask, and the associated error object. The state of the error mask controls what happens when an error condition is found. It should be noted that checking of the hardware error flags is only performed after each 1-D loop is executed. This means that if the input and output arrays are contiguous and of the correct type so that a single 1-D loop is performed, then the flags may not be checked until all elements of the array have been calculated. Looking up these values in a thread- specific dictionary takes time which is easily ignored for all but very small arrays.</source>
          <target state="translated">最初に行われることは、スレッド固有のグローバル辞書でバッファサイズ、エラーマスク、関連するエラーオブジェクトの現在の値を調べることです。エラーマスクの状態は、エラー状態が発見されたときに何が起こるかを制御します。ハードウェアエラーフラグのチェックは、各1-Dループが実行された後にのみ実行されることに注意する必要があります。これは,入力配列と出力配列が連続しており,1 つの 1-D ループが実行されるように正しい型である場合,配列のすべての要素が計算されるまでフラグはチェックされない可能性があることを意味します.これらの値をスレッド固有の辞書で調べるには時間がかかりますが,非常に小さな配列以外は簡単に無視できます.</target>
        </trans-unit>
        <trans-unit id="eec0cb9e2856c8840ae3269c16ee7eee2770a458" translate="yes" xml:space="preserve">
          <source>The first thing to understand is that there are two conflicting conventions for indexing 2-dimensional arrays. Matrix notation uses the first index to indicate which row is being selected and the second index to indicate which column is selected. This is opposite the geometrically oriented-convention for images where people generally think the first index represents x position (i.e., column) and the second represents y position (i.e., row). This alone is the source of much confusion; matrix-oriented users and image-oriented users expect two different things with regard to indexing.</source>
          <target state="translated">まず最初に理解すべきことは、2次元配列のインデックス付けには2つの相反する慣習があるということです。行列の記法では、どの行が選択されているかを示すために最初のインデックスを使用し、どの列が選択されているかを示すために2番目のインデックスを使用します。これは、画像の幾何学的に指向された慣習とは逆で、一般的には最初のインデックスがxの位置(つまり列)を表し、2番目のインデックスがyの位置(つまり行)を表していると考えられています。これだけでも多くの混乱の原因となっています。行列指向のユーザーと画像指向のユーザーは、インデックスに関して2つの異なることを期待しています。</target>
        </trans-unit>
        <trans-unit id="dae27e752e6250bcf53dd15428c26bfc6c4aff24" translate="yes" xml:space="preserve">
          <source>The flags member may consist of 5 bits showing how the data should be interpreted and one bit showing how the Interface should be interpreted. The data-bits are &lt;code&gt;CONTIGUOUS&lt;/code&gt; (0x1), &lt;code&gt;FORTRAN&lt;/code&gt; (0x2), &lt;code&gt;ALIGNED&lt;/code&gt; (0x100), &lt;code&gt;NOTSWAPPED&lt;/code&gt; (0x200), and &lt;code&gt;WRITEABLE&lt;/code&gt; (0x400). A final flag &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; (0x800) indicates whether or not this structure has the arrdescr field. The field should not be accessed unless this flag is present.</source>
          <target state="translated">フラグメンバーは、データの解釈方法を示す5ビットと、インターフェイスの解釈方法を示す1ビットで構成されます。データビットは、 &lt;code&gt;CONTIGUOUS&lt;/code&gt; （0x1）、 &lt;code&gt;FORTRAN&lt;/code&gt; （0x2）、 &lt;code&gt;ALIGNED&lt;/code&gt; （0x100）、 &lt;code&gt;NOTSWAPPED&lt;/code&gt; （0x200）、および &lt;code&gt;WRITEABLE&lt;/code&gt; （0x400）です。最後のフラグ &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; （0x800）は、この構造にarrdescrフィールドがあるかどうかを示します。このフラグが存在しない限り、フィールドにアクセスしないでください。</target>
        </trans-unit>
        <trans-unit id="80d94b3bc99b1a4e8e2a1a02a0e27c0ae964964b" translate="yes" xml:space="preserve">
          <source>The flexible type array that is returned will have two fields:</source>
          <target state="translated">返されるフレキシブル型の配列は、2つのフィールドを持ちます。</target>
        </trans-unit>
        <trans-unit id="9b521c71cd9d32371a352dcf94d2ff132ccb79f4" translate="yes" xml:space="preserve">
          <source>The floating-point exceptions are defined in the IEEE 754 standard &lt;a href=&quot;#r4cab4292821f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="translated">浮動小数点例外は、IEEE 754標準&lt;a href=&quot;#r4cab4292821f-1&quot; id=&quot;id1&quot;&gt;[1]で&lt;/a&gt;定義されています。</target>
        </trans-unit>
        <trans-unit id="25cd839f1fa0397dfd8a073d288328126b03cd06" translate="yes" xml:space="preserve">
          <source>The floor division operator &lt;code&gt;//&lt;/code&gt; was added in Python 2.2 making &lt;code&gt;//&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; equivalent operators. The default floor division operation of &lt;code&gt;/&lt;/code&gt; can be replaced by true division with &lt;code&gt;from
__future__ import division&lt;/code&gt;.</source>
          <target state="translated">フロア除算演算子 &lt;code&gt;//&lt;/code&gt; は、Python 2.2で追加され、 &lt;code&gt;//&lt;/code&gt; および &lt;code&gt;/&lt;/code&gt; 同等の演算子を作成します。 &lt;code&gt;/&lt;/code&gt; のデフォルトの床除算演算は、 &lt;code&gt;from __future__ import division&lt;/code&gt; による実際の除算に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="9e26997b358814cca7850a49e412f8a41b34dbe5" translate="yes" xml:space="preserve">
          <source>The floor of each element in &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の各要素の床。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="eaacb373a79b18f285bd66c2cf0778d5b163c8e7" translate="yes" xml:space="preserve">
          <source>The floor of the scalar &lt;code&gt;x&lt;/code&gt; is the largest integer &lt;code&gt;i&lt;/code&gt;, such that &lt;code&gt;i &amp;lt;= x&lt;/code&gt;. It is often denoted as</source>
          <target state="translated">スカラー &lt;code&gt;x&lt;/code&gt; のフロアは、 &lt;code&gt;i &amp;lt;= x&lt;/code&gt; ような最大の整数 &lt;code&gt;i&lt;/code&gt; です。多くの場合、</target>
        </trans-unit>
        <trans-unit id="837a298621c37ae4f32158adfb48d3ae2b900f73" translate="yes" xml:space="preserve">
          <source>The fmax is equivalent to &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">x1もx2もNaNでない場合 &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; fmaxはnp.where（x1&amp;gt; = x2、x1、x2）と同等ですが、高速で適切なブロードキャストを行います。</target>
        </trans-unit>
        <trans-unit id="9192d9bcf4b5d5fc29087b97fc9fad549a45ccf6" translate="yes" xml:space="preserve">
          <source>The fmin is equivalent to &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">x1もx2もNaNでない場合 &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; fminはnp.where（x1 &amp;lt;= x2、x1、x2）と同等ですが、高速で適切なブロードキャストを行います。</target>
        </trans-unit>
        <trans-unit id="26c655f10b13c11e712f57319bac1772cdc5526b" translate="yes" xml:space="preserve">
          <source>The following attributes contain information about the memory layout of the array:</source>
          <target state="translated">以下の属性には、配列のメモリレイアウトに関する情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="b09df459a0ad4a5d7d6218f92cc55900d726085b" translate="yes" xml:space="preserve">
          <source>The following comparison does not raise an exception. There are NaNs in the inputs, but they are in the same positions.</source>
          <target state="translated">以下の比較では例外は発生しません。入力にNaNがありますが、同じ位置にあります。</target>
        </trans-unit>
        <trans-unit id="367c359a19964728c01ac0e57fac7d66168d5b07" translate="yes" xml:space="preserve">
          <source>The following data types are &lt;strong&gt;flexible&lt;/strong&gt;: they have no predefined size and the data they describe can be of different length in different arrays. (In the character codes &lt;code&gt;#&lt;/code&gt; is an integer denoting how many elements the data type consists of.)</source>
          <target state="translated">次のデータ型は&lt;strong&gt;柔軟&lt;/strong&gt;です。事前定義されたサイズがなく、それらが記述するデータは、異なる配列で異なる長さになる可能性があります。（文字コードの &lt;code&gt;#&lt;/code&gt; は、データ型を構成する要素の数を示す整数です。）</target>
        </trans-unit>
        <trans-unit id="87cc18e3bbbb39d0641f0c5e5f7aaba73b3bfa17" translate="yes" xml:space="preserve">
          <source>The following example checks that &lt;code&gt;a * a+ * a == a&lt;/code&gt; and &lt;code&gt;a+ * a * a+ == a+&lt;/code&gt;:</source>
          <target state="translated">次の例では、 &lt;code&gt;a * a+ * a == a&lt;/code&gt; および &lt;code&gt;a+ * a * a+ == a+&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="da726617ef56fc847d878f222531de4392ef5079" translate="yes" xml:space="preserve">
          <source>The following example demonstrates that operations on this particular dtype requires Python C-API.</source>
          <target state="translated">以下の例は、この特定のdtypeに対する操作がPythonのC-APIを必要とすることを示しています。</target>
        </trans-unit>
        <trans-unit id="c7cc30376235469e66891b8aa9bb0978b2dc2799" translate="yes" xml:space="preserve">
          <source>The following is equivalent to &lt;code&gt;x[np.newaxis,:]&lt;/code&gt; or &lt;code&gt;x[np.newaxis]&lt;/code&gt;:</source>
          <target state="translated">以下は &lt;code&gt;x[np.newaxis,:]&lt;/code&gt; または &lt;code&gt;x[np.newaxis]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b1e13d507d651c25d5c30d03b160ce21c4df709" translate="yes" xml:space="preserve">
          <source>The following is probably true, given that 0.6 is roughly twice the standard deviation:</source>
          <target state="translated">0.6が標準偏差の約2倍であることを考えると、以下のことが当てはまるのではないでしょうか。</target>
        </trans-unit>
        <trans-unit id="abb45d568d4c1dc6b1960772da10fbcd2d6bd4ca" translate="yes" xml:space="preserve">
          <source>The following keys are allowed:</source>
          <target state="translated">以下のキーが許可されています。</target>
        </trans-unit>
        <trans-unit id="c7e7738746294a7939f873df246ce33769c08494" translate="yes" xml:space="preserve">
          <source>The following math constants are available in &lt;code&gt;npy_math.h&lt;/code&gt;. Single and extended precision are also available by adding the &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;l&lt;/code&gt; suffixes respectively.</source>
          <target state="translated">次の数学定数は &lt;code&gt;npy_math.h&lt;/code&gt; で使用できます。単精度と拡張精度は、それぞれ &lt;code&gt;f&lt;/code&gt; と &lt;code&gt;l&lt;/code&gt; 接尾辞を追加することによっても利用できます。</target>
        </trans-unit>
        <trans-unit id="18400fc6ad0ef15f4b4b9f40c34d77a0b29576fd" translate="yes" xml:space="preserve">
          <source>The following methods can be used to access information about the mask or to manipulate the mask.</source>
          <target state="translated">マスクに関する情報にアクセスしたり、マスクを操作したりするには、以下の方法があります。</target>
        </trans-unit>
        <trans-unit id="a7a27e2b2ff01b711d127c91926b8f2614c9b919" translate="yes" xml:space="preserve">
          <source>The following methods implement the pickle protocol:</source>
          <target state="translated">以下のメソッドは、Pickleプロトコルを実装しています。</target>
        </trans-unit>
        <trans-unit id="3e142b98cf4f076b7f9b0cce4a8911bba92433dc" translate="yes" xml:space="preserve">
          <source>The following norms can be calculated:</source>
          <target state="translated">以下のノルムを算出することができます。</target>
        </trans-unit>
        <trans-unit id="7d6f7c16ce7db4761de0d3a2abd525b89c4146e9" translate="yes" xml:space="preserve">
          <source>The following predefined named repeat rules are available:</source>
          <target state="translated">以下の定義済みの名前付きリピートルールが利用可能です。</target>
        </trans-unit>
        <trans-unit id="2238114e4622f64961aa457707939beca3d22430" translate="yes" xml:space="preserve">
          <source>The form of each element of the files sequence is very flexible allowing many combinations of where to get the files from the package and where they should ultimately be installed on the system. The most basic usage is for an element of the files argument sequence to be a simple filename. This will cause that file from the local path to be installed to the installation path of the self.name package (package path). The file argument can also be a relative path in which case the entire relative path will be installed into the package directory. Finally, the file can be an absolute path name in which case the file will be found at the absolute path name but installed to the package path.</source>
          <target state="translated">ファイルシーケンスの各要素の形式は非常に柔軟で、パッケージからファイルを取得する場所や、最終的にシステム上にインストールされるべき場所の多くの組み合わせを可能にします。最も基本的な使い方は、ファイル引数シーケンスの要素を単純なファイル名にすることです。これにより、そのファイルはローカルパスから self.name パッケージのインストールパス (パッケージパス)にインストールされます。ファイルの引数には相対パスを指定することもでき、その場合は相対パス全体がパッケージディレクトリにインストールされます。最後に、ファイルは絶対パス名を指定することもできます。この場合、ファイルは絶対パス名で見つかりますが、パッケージパスにインストールされます。</target>
        </trans-unit>
        <trans-unit id="7343176dc74f7dbd7af11c9825b614f0b44c3446" translate="yes" xml:space="preserve">
          <source>The formal syntax of signatures is as follows:</source>
          <target state="translated">署名の正式な構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="9dfcbb2acec4cf5d146ee3b9671f0f8af54935b6" translate="yes" xml:space="preserve">
          <source>The format description, either specified as a string with comma-separated format descriptions in the form &lt;code&gt;'f8, i4, a5'&lt;/code&gt;, or a list of format description strings in the form &lt;code&gt;['f8', 'i4', 'a5']&lt;/code&gt;.</source>
          <target state="translated">形式の説明。 &lt;code&gt;'f8, i4, a5'&lt;/code&gt; 形式のコンマ区切り形式の説明を含む文字列、または &lt;code&gt;['f8', 'i4', 'a5']&lt;/code&gt; の形式の形式説明文字列のリストとして指定します。</target>
        </trans-unit>
        <trans-unit id="8d7571d646719e6a89afce2ffa8ca97d9a9e64da" translate="yes" xml:space="preserve">
          <source>The format is that required by the &amp;lsquo;descr&amp;rsquo; key in the &lt;code&gt;__array_interface__&lt;/code&gt; attribute.</source>
          <target state="translated">形式は、 &lt;code&gt;__array_interface__&lt;/code&gt; 属性の「descr」キーに必要な形式です。</target>
        </trans-unit>
        <trans-unit id="8a1e4bed9460777336f2b104636d1f996f032590" translate="yes" xml:space="preserve">
          <source>The format of these binary file types is documented in &lt;a href=&quot;generated/numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">これらのバイナリファイルタイプの形式は、&lt;a href=&quot;generated/numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; に&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="ab7733aff55a201beeb5e33bad2c1efefa91a712" translate="yes" xml:space="preserve">
          <source>The forward 2-dimensional FFT, of which &lt;a href=&quot;#numpy.fft.ifft2&quot;&gt;&lt;code&gt;ifft2&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">フォワード2次元&lt;a href=&quot;#numpy.fft.ifft2&quot;&gt; &lt;code&gt;ifft2&lt;/code&gt; &lt;/a&gt;はその逆です。</target>
        </trans-unit>
        <trans-unit id="0bd56e9c9eb1ee54cf6d17ca53e59f27e56218bd" translate="yes" xml:space="preserve">
          <source>The forward &lt;em&gt;n&lt;/em&gt;-dimensional FFT, of which &lt;a href=&quot;#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">前方&lt;em&gt;n&lt;/em&gt;次元&lt;a href=&quot;#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt;はその逆です。</target>
        </trans-unit>
        <trans-unit id="aeabce19c51398cd914249fe750519a8327c3674" translate="yes" xml:space="preserve">
          <source>The forward n-dimensional FFT of real input, of which &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">実数入力の順方向n次元&lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt;はその逆です。</target>
        </trans-unit>
        <trans-unit id="61a4038ee203c584eee7f06e34f73b9e221966a9" translate="yes" xml:space="preserve">
          <source>The four core distributions (&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;) all allow existing arrays to be filled using the &lt;code&gt;out&lt;/code&gt; keyword argument. Existing arrays need to be contiguous and well-behaved (writable and aligned). Under normal circumstances, arrays created using the common constructors such as &lt;a href=&quot;../generated/numpy.empty#numpy.empty&quot;&gt;&lt;code&gt;numpy.empty&lt;/code&gt;&lt;/a&gt; will satisfy these requirements.</source>
          <target state="translated">4つのコア分布（&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; &lt;/a&gt;）はすべて、 &lt;code&gt;out&lt;/code&gt; キーワード引数を使用して既存の配列を埋めることができます。既存のアレイは、隣接していて適切に動作する（書き込み可能で整列されている）必要があります。通常の状況では、&lt;a href=&quot;../generated/numpy.empty#numpy.empty&quot;&gt; &lt;code&gt;numpy.empty&lt;/code&gt; &lt;/a&gt;などの一般的なコンストラクターを使用して作成された配列は、これらの要件を満たします。</target>
        </trans-unit>
        <trans-unit id="6b6b0ab0e6259043a789c7cdf6069c9981b5ed51" translate="yes" xml:space="preserve">
          <source>The fourth-order derivative of a 3rd-order polynomial is zero:</source>
          <target state="translated">3次多項式の4次微分は0である。</target>
        </trans-unit>
        <trans-unit id="61efc608056775e101326edefdfb5b3e50b42207" translate="yes" xml:space="preserve">
          <source>The fractional and integral parts are negative if the given number is negative.</source>
          <target state="translated">分数や積分の部分は、与えられた数が負の場合は負になります。</target>
        </trans-unit>
        <trans-unit id="3162acb71296218159c712934b3730fe102cab75" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#numpy.random.default_rng&quot;&gt;&lt;code&gt;numpy.random.default_rng&lt;/code&gt;&lt;/a&gt; will instantiate a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; with numpy&amp;rsquo;s default &lt;code&gt;BitGenerator&lt;/code&gt;.</source>
          <target state="translated">関数&lt;a href=&quot;#numpy.random.default_rng&quot;&gt; &lt;code&gt;numpy.random.default_rng&lt;/code&gt; &lt;/a&gt;は、numpyのデフォルトの &lt;code&gt;BitGenerator&lt;/code&gt; で&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;をインスタンス化します。</target>
        </trans-unit>
        <trans-unit id="ada915777af34962f5a155b7336d9374672697e6" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt;&lt;code&gt;busday_offset&lt;/code&gt;&lt;/a&gt; allows you to apply offsets specified in business days to datetimes with a unit of &amp;lsquo;D&amp;rsquo; (day).</source>
          <target state="translated">関数&lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt; &lt;code&gt;busday_offset&lt;/code&gt; を&lt;/a&gt;使用すると、営業日で指定されたオフセットを 'D'（日）の単位で日時に適用できます。</target>
        </trans-unit>
        <trans-unit id="96d8a0725df6e95677a6e264d7cb37fa566a8b73" translate="yes" xml:space="preserve">
          <source>The function assumes that the number of dimensions of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are the same, if necessary prepending the smallest with ones. If &lt;code&gt;a.shape = (r0,r1,..,rN)&lt;/code&gt; and &lt;code&gt;b.shape = (s0,s1,&amp;hellip;,sN)&lt;/code&gt;, the Kronecker product has shape &lt;code&gt;(r0*s0, r1*s1, &amp;hellip;, rN*SN)&lt;/code&gt;. The elements are products of elements from &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, organized explicitly by:</source>
          <target state="translated">関数は、 &lt;code&gt;b&lt;/code&gt; とbの次元数が同じで &lt;code&gt;a&lt;/code&gt; と仮定します。必要に応じて、最小のものに1を付加します。場合 &lt;code&gt;a.shape = (r0,r1,..,rN)&lt;/code&gt; と &lt;code&gt;b.shape = (s0,s1,&amp;hellip;,sN)&lt;/code&gt; 、クロネッカー積は、形状がある &lt;code&gt;(r0*s0, r1*s1, &amp;hellip;, rN*SN)&lt;/code&gt; 。要素は、要素からの製品であり &lt;code&gt;a&lt;/code&gt; および &lt;code&gt;b&lt;/code&gt; によって明示的に整理します、：</target>
        </trans-unit>
        <trans-unit id="af59a6369749b3cb0f9764af498a65709d68b13e" translate="yes" xml:space="preserve">
          <source>The function has a mean of</source>
          <target state="translated">この関数の平均値は</target>
        </trans-unit>
        <trans-unit id="054f865aa3416e437e5f93f6d6b344a94ea0192f" translate="yes" xml:space="preserve">
          <source>The function has its peak (the mode) at</source>
          <target state="translated">関数のピーク(モード)は</target>
        </trans-unit>
        <trans-unit id="6069aba02c2ff9e33d0e7ae153f4ba83da37a833" translate="yes" xml:space="preserve">
          <source>The function has its peak at the mean, and its &amp;ldquo;spread&amp;rdquo; increases with the standard deviation (the function reaches 0.607 times its maximum at</source>
          <target state="translated">この関数は平均にピークがあり、その「広がり」は標準偏差とともに増加します（関数は、最大値の0.607倍に達します</target>
        </trans-unit>
        <trans-unit id="3aafd01a0784838ff12d9b42abaea56f0c51d8d3" translate="yes" xml:space="preserve">
          <source>The function has zeroes where the angle is a multiple of</source>
          <target state="translated">の倍数であるゼロを持つ関数です。</target>
        </trans-unit>
        <trans-unit id="fafbcce3a94cb5de2e94d10e8bc93622f1a9c81d" translate="yes" xml:space="preserve">
          <source>The function is also useful for computing some kinds of days like holidays. In Canada and the U.S., Mother&amp;rsquo;s day is on the second Sunday in May, which can be computed with a custom weekmask.</source>
          <target state="translated">この関数は、休日のようなある種の日の計算にも役立ちます。カナダと米国では、母の日は5月の第2日曜日であり、カスタムの週マスクで計算できます。</target>
        </trans-unit>
        <trans-unit id="67cb306690132e9cba2500b1fa7de5410b4f5260" translate="yes" xml:space="preserve">
          <source>The function is applied to both the _data and the _mask, if any.</source>
          <target state="translated">この関数は、_data と _mask の両方に適用されます。</target>
        </trans-unit>
        <trans-unit id="da183d0fc1832c644fcb348cf07cf8e31326309a" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="translated">関数はN個のパラメーターで呼び出されます。ここで、Nは&lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;のランクです。各パラメーターは、特定の軸に沿って変化する配列の座標を表します。たとえば、&lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;(2, 2)&lt;/code&gt; 場合、パラメーターは &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; および &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d612a9af75e269601691ae7eb90f682a5b996713" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;code&gt;shape&lt;/code&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;code&gt;shape&lt;/code&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="translated">関数はN個のパラメーターで呼び出されます。ここで、Nは &lt;code&gt;shape&lt;/code&gt; のランクです。各パラメーターは、特定の軸に沿って変化する配列の座標を表します。たとえば、 &lt;code&gt;shape&lt;/code&gt; が &lt;code&gt;(2, 2)&lt;/code&gt; 場合、パラメーターは &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; および &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8addd0f39cba25bd912a60b0fb5434bfd595dbe3" translate="yes" xml:space="preserve">
          <source>The function pointer type for NpyAuxData clone functions. These functions should never set the Python exception on error, because they may be called from a multi-threaded context.</source>
          <target state="translated">NpyAuxDataクローン関数のための関数ポインタの型です。これらの関数は、マルチスレッドのコンテキストから呼び出される可能性があるため、エラー時にPythonの例外を設定してはいけません。</target>
        </trans-unit>
        <trans-unit id="167c7a543d8ccb24656ce9a1687449c4ecfb1950" translate="yes" xml:space="preserve">
          <source>The function pointer type for NpyAuxData free functions.</source>
          <target state="translated">NpyAuxDataフリー関数の関数ポインタ型です。</target>
        </trans-unit>
        <trans-unit id="a328f1fcd0be371ed7460c86c4fd60c08690a1c3" translate="yes" xml:space="preserve">
          <source>The function returns the coefficients of the polynomial</source>
          <target state="translated">この関数は,多項式</target>
        </trans-unit>
        <trans-unit id="f0b123a5d43604d228ff7e22be71c876bc3f213f" translate="yes" xml:space="preserve">
          <source>The function that is called when x and y are omitted</source>
          <target state="translated">xとyが省略されたときに呼び出される関数</target>
        </trans-unit>
        <trans-unit id="1ed24e8ca86c415e0834a63e6e6d562c0814371f" translate="yes" xml:space="preserve">
          <source>The function to be interpolated. It must be a function of a single variable of the form &lt;code&gt;f(x, a, b, c...)&lt;/code&gt;, where &lt;code&gt;a, b, c...&lt;/code&gt; are extra arguments passed in the &lt;code&gt;args&lt;/code&gt; parameter.</source>
          <target state="translated">補間される関数。これは、 &lt;code&gt;f(x, a, b, c...)&lt;/code&gt; の形式の単一変数の関数でなければなりません。ここ &lt;code&gt;a, b, c...&lt;/code&gt; は、 &lt;code&gt;args&lt;/code&gt; パラメーターで渡される追加の引数です。</target>
        </trans-unit>
        <trans-unit id="dd5723a1284c8aa8946aa81b4b7601e07d26020c" translate="yes" xml:space="preserve">
          <source>The functionality is based on &lt;a href=&quot;https://docs.python.org/dev/library/os.path.html#os.path.abspath&quot;&gt;&lt;code&gt;os.path.abspath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">機能は&lt;a href=&quot;https://docs.python.org/dev/library/os.path.html#os.path.abspath&quot;&gt; &lt;code&gt;os.path.abspath&lt;/code&gt; に&lt;/a&gt;基づいています。</target>
        </trans-unit>
        <trans-unit id="e6e850d04a35d82db7e5c340cdd654a0e7af1cfd" translate="yes" xml:space="preserve">
          <source>The functionality this provides is largely superceded by iterator &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt; introduced in 1.6, with flag &lt;a href=&quot;c-api.iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt; or with the same dtype parameter for all operands.</source>
          <target state="translated">これが提供する機能の大部分は、フラグ&lt;a href=&quot;c-api.iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt; &lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt; &lt;/a&gt;またはすべてのオペランドに同じdtypeパラメータを使用して、1.6で導入されたイテレータ&lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt; &lt;code&gt;NpyIter&lt;/code&gt; に&lt;/a&gt;取って代わられています。</target>
        </trans-unit>
        <trans-unit id="9e207dc9abcf693e32399f76b884fbb8a9e3545f" translate="yes" xml:space="preserve">
          <source>The functions called to implement many arithmetic special methods for arrays can be modified using &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">配列の多くの算術特殊メソッドを実装するために呼び出される関数は、&lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;を使用して変更できます。</target>
        </trans-unit>
        <trans-unit id="780f3f42d3ad6d900b31dca5cc39ba44b8433b34" translate="yes" xml:space="preserve">
          <source>The future value is computed by solving the equation:</source>
          <target state="translated">式を解くことで、将来の値を計算します。</target>
        </trans-unit>
        <trans-unit id="f54d15f1fff04aaad23c1e30a6699255a7286273" translate="yes" xml:space="preserve">
          <source>The gains are substantial and the scaling is reasonable even for large that are only moderately large. The gains are even larger when compared to a call that does not use an existing array due to array creation overhead.</source>
          <target state="translated">この利得は実質的なものであり,中程度の大きさしかない大規模なものでもスケーリングは妥当です.配列作成のオーバーヘッドのために既存の配列を使用しない呼び出しと比較すると、利益はさらに大きくなります。</target>
        </trans-unit>
        <trans-unit id="3a2348245b14000fc86ba9addf452f0058449713" translate="yes" xml:space="preserve">
          <source>The general concept of broadcasting is also available from Python using the &lt;a href=&quot;generated/numpy.broadcast#numpy.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt; iterator. This object takes</source>
          <target state="translated">ブロードキャストの一般的な概念は、&lt;a href=&quot;generated/numpy.broadcast#numpy.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt;イテレータを使用してPythonからも利用できます。このオブジェクトは</target>
        </trans-unit>
        <trans-unit id="a9641437007836c208f74db848ac79bd7c6780e6" translate="yes" xml:space="preserve">
          <source>The generated file will have the following content:</source>
          <target state="translated">生成されたファイルは以下の内容になります。</target>
        </trans-unit>
        <trans-unit id="1a1433c2f9219adfdc1717ee54946e456e115a63" translate="yes" xml:space="preserve">
          <source>The generated random samples</source>
          <target state="translated">生成されたランダムサンプル</target>
        </trans-unit>
        <trans-unit id="770d667a086582311721a20b1950124d0ed2b0b8" translate="yes" xml:space="preserve">
          <source>The generic hierarchical type objects convert to corresponding type objects according to the associations:</source>
          <target state="translated">一般的な階層型オブジェクトは、関連付けに応じて対応する型オブジェクトに変換されます。</target>
        </trans-unit>
        <trans-unit id="7b9da9a1e497b53c1498ef8728ff28c753a44590" translate="yes" xml:space="preserve">
          <source>The given decorator is applied to all public methods of &lt;code&gt;cls&lt;/code&gt; that are matched by the regular expression &lt;code&gt;testmatch&lt;/code&gt; (&lt;code&gt;testmatch.search(methodname)&lt;/code&gt;). Methods that are private, i.e. start with an underscore, are ignored.</source>
          <target state="translated">指定されたデコレータは、正規表現 &lt;code&gt;testmatch&lt;/code&gt; （ &lt;code&gt;testmatch.search(methodname)&lt;/code&gt; ）によって照合される &lt;code&gt;cls&lt;/code&gt; のすべてのパブリックメソッドに適用されます。プライベートなメソッド、つまりアンダースコアで始まるメソッドは無視されます。</target>
        </trans-unit>
        <trans-unit id="d15ec8784a28b893c0b85001548e5baae80372c7" translate="yes" xml:space="preserve">
          <source>The gradient is computed using second order accurate central differences in the interior points and either first or second order accurate one-sides (forward or backwards) differences at the boundaries. The returned gradient hence has the same shape as the input array.</source>
          <target state="translated">勾配は,内部の点における2次の正確な中心差と,境界での1次または2次の正確な片側(前方または後方)差を用いて計算されます.返される勾配は,入力配列と同じ形をしています.</target>
        </trans-unit>
        <trans-unit id="2b74e85f5516f60e3dbf421bf49f69c39506c265" translate="yes" xml:space="preserve">
          <source>The greatest common divisor</source>
          <target state="translated">最大公約数</target>
        </trans-unit>
        <trans-unit id="1335775c2defd62ddac3bf62f622a970f395fc71" translate="yes" xml:space="preserve">
          <source>The greatest common divisor of the absolute value of the inputs This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">入力の絶対値の最大公約数 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="1ffad58d21fbb0c889485660c6a73c057db064f2" translate="yes" xml:space="preserve">
          <source>The header file &amp;lt;numpy/halffloat.h&amp;gt; provides functions to work with IEEE 754-2008 16-bit floating point values. While this format is not typically used for numerical computations, it is useful for storing values which require floating point but do not need much precision. It can also be used as an educational tool to understand the nature of floating point round-off error.</source>
          <target state="translated">ヘッダーファイル&amp;lt;numpy / halffloat.h&amp;gt;は、IEEE 754-2008 16ビット浮動小数点値を処理する関数を提供します。この形式は通常、数値計算には使用されませんが、浮動小数点を必要とするがあまり精度を必要としない値を格納するのに役立ちます。また、浮動小数点の丸め誤差の性質を理解するための教育ツールとしても使用できます。</target>
        </trans-unit>
        <trans-unit id="d730bb14ffcab30f2844567d44182ca5b3af1815" translate="yes" xml:space="preserve">
          <source>The header of a typical SciPy &lt;code&gt;__init__.py&lt;/code&gt; is:</source>
          <target state="translated">一般的なSciPy &lt;code&gt;__init__.py&lt;/code&gt; のヘッダーは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="881c9d2e47b4057e556e6ff5df02bfb9e5dee04c" translate="yes" xml:space="preserve">
          <source>The highest precision data type of the same kind (&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt;&lt;code&gt;dtype.kind&lt;/code&gt;&lt;/a&gt;) as &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; と同じ種類（&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt; &lt;code&gt;dtype.kind&lt;/code&gt; &lt;/a&gt;）の最も精度の高いデータ型。</target>
        </trans-unit>
        <trans-unit id="f28aa2c9365c3014c1b3133bf8c0527b1b6cd92f" translate="yes" xml:space="preserve">
          <source>The hyperbolic cosine describes the shape of a hanging cable:</source>
          <target state="translated">双曲余弦は、ぶら下がっているケーブルの形状を表します。</target>
        </trans-unit>
        <trans-unit id="5dfe11baf5c84767b263b0b9280dd1d13ec6b531" translate="yes" xml:space="preserve">
          <source>The hypotenuse of the triangle(s). This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">三角形の斜辺。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="a77669c9a72d14b0f58a0186d231f3894219b608" translate="yes" xml:space="preserve">
          <source>The identity array is a square array with ones on the main diagonal.</source>
          <target state="translated">アイデンティティ配列は、主対角線上にあるものを四角い配列にしたものです。</target>
        </trans-unit>
        <trans-unit id="2bf1c25d751d392b46c1da854b9e2214e84ecbda" translate="yes" xml:space="preserve">
          <source>The identity value.</source>
          <target state="translated">アイデンティティの値。</target>
        </trans-unit>
        <trans-unit id="a3a4e04cbf529a826b2105546fd57be959a238a1" translate="yes" xml:space="preserve">
          <source>The imaginary component of the complex argument. If &lt;code&gt;val&lt;/code&gt; is real, the type of &lt;code&gt;val&lt;/code&gt; is used for the output. If &lt;code&gt;val&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">複素引数の虚数成分。場合 &lt;code&gt;val&lt;/code&gt; が本当である、の種類 &lt;code&gt;val&lt;/code&gt; が出力のために使用されています。場合 &lt;code&gt;val&lt;/code&gt; は複雑な要素を持って、返された型はfloatです。</target>
        </trans-unit>
        <trans-unit id="7286bf711b04d53845d16cb5a31eaaaaa02757bf" translate="yes" xml:space="preserve">
          <source>The imaginary part of the array.</source>
          <target state="translated">配列の虚数部.</target>
        </trans-unit>
        <trans-unit id="9bc674154d61adacb44dda1d44c441449cdf2af6" translate="yes" xml:space="preserve">
          <source>The imaginary part of the masked array.</source>
          <target state="translated">マスクされた配列の虚数部。</target>
        </trans-unit>
        <trans-unit id="fd6e842a69d72f29a0581eb97a936eaef8759475" translate="yes" xml:space="preserve">
          <source>The implementation of the tests that produce this information.</source>
          <target state="translated">この情報を生成するテストの実施形態。</target>
        </trans-unit>
        <trans-unit id="1e2ea421bf4e67c223dedefb366e2029ced79732" translate="yes" xml:space="preserve">
          <source>The importance that each element has in the computation of the average. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one. If &lt;code&gt;weights&lt;/code&gt; is complex, the imaginary parts are ignored.</source>
          <target state="translated">平均の計算における各要素の重要性。重みアレイは、いずれかの1-D（その長さの大きさでなければならない場合であってもよい所定の軸に沿って）又は同様の形状。 &lt;code&gt;weights=None&lt;/code&gt; の場合、 &lt;code&gt;a&lt;/code&gt; のすべてのデータの重みは1であると想定されます。場合は &lt;code&gt;weights&lt;/code&gt; 複雑で、虚部は無視されます。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e99cfec9384fa0ceb0f339e2c89b3b94a829c5f" translate="yes" xml:space="preserve">
          <source>The included BitGenerators are:</source>
          <target state="translated">同梱されているBitGeneratorsは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="22391c7101fab8760afe729b1932a0c59fad5983" translate="yes" xml:space="preserve">
          <source>The included generators can be used in parallel, distributed applications in one of three ways:</source>
          <target state="translated">付属のジェネレータは、3つの方法のいずれかで並列分散型アプリケーションで使用できます。</target>
        </trans-unit>
        <trans-unit id="2c2a3bfa2d0e12fb3599b918fb58fa555ca8de7c" translate="yes" xml:space="preserve">
          <source>The indexed result.</source>
          <target state="translated">インデックス化された結果。</target>
        </trans-unit>
        <trans-unit id="03743182a2227ccf2811c37150a243244da1cf36" translate="yes" xml:space="preserve">
          <source>The indexing works on the flattened target array. &lt;a href=&quot;#numpy.put&quot;&gt;&lt;code&gt;put&lt;/code&gt;&lt;/a&gt; is roughly equivalent to:</source>
          <target state="translated">インデックスは、平坦化されたターゲット配列に対して機能します。&lt;a href=&quot;#numpy.put&quot;&gt; &lt;code&gt;put&lt;/code&gt; &lt;/a&gt;はおおよそ次と同等です。</target>
        </trans-unit>
        <trans-unit id="59838ac2347062b68deb1ef0e067a09f0f1f12f7" translate="yes" xml:space="preserve">
          <source>The indices can be used as an index into an array.</source>
          <target state="translated">インデックスは配列へのインデックスとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="41bdc266e504f1b3636c2cdbc5a9368b53208f9c" translate="yes" xml:space="preserve">
          <source>The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array.</source>
          <target state="translated">三角形のインデックス.返されるタプルには2つの配列が含まれており,それぞれが配列の1次元に沿ったインデックスを持ちます.</target>
        </trans-unit>
        <trans-unit id="083f53a10046b877a4d17cdf8a047cadb142a0a5" translate="yes" xml:space="preserve">
          <source>The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array. Can be used to slice a ndarray of shape(&lt;code&gt;n&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;).</source>
          <target state="translated">三角形のインデックス。返されるタプルには2つの配列が含まれ、それぞれに配列の1次元に沿ったインデックスが付いています。shape（ &lt;code&gt;n&lt;/code&gt; 、 &lt;code&gt;n&lt;/code&gt; ）のndarrayをスライスするために使用できます。</target>
        </trans-unit>
        <trans-unit id="313bb1645ee0bcc96011930b78001b8efa601b2f" translate="yes" xml:space="preserve">
          <source>The indices of first and last non-masked value in the array. Returns None if all values are masked.</source>
          <target state="translated">配列内の最初と最後のマスクされていない値のインデックス。すべての値がマスクされている場合は None を返します。</target>
        </trans-unit>
        <trans-unit id="02de7d9422fcf4d3bd70015e02df12b6de819fce" translate="yes" xml:space="preserve">
          <source>The indices of the current iteration.</source>
          <target state="translated">現在の反復のインデックス。</target>
        </trans-unit>
        <trans-unit id="caeefd07d81c974d4f02d2a7cd29c00df5d3e970" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the common values in &lt;code&gt;ar1&lt;/code&gt;. Only provided if &lt;code&gt;return_indices&lt;/code&gt; is True.</source>
          <target state="translated">&lt;code&gt;ar1&lt;/code&gt; の共通値が最初に出現するインデックス。 &lt;code&gt;return_indices&lt;/code&gt; がTrueの場合にのみ提供されます。</target>
        </trans-unit>
        <trans-unit id="d03a2050722c8950165a7a42c8f8fbec16c8b478" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the common values in &lt;code&gt;ar2&lt;/code&gt;. Only provided if &lt;code&gt;return_indices&lt;/code&gt; is True.</source>
          <target state="translated">&lt;code&gt;ar2&lt;/code&gt; の共通値が最初に出現するインデックス。 &lt;code&gt;return_indices&lt;/code&gt; がTrueの場合にのみ提供されます。</target>
        </trans-unit>
        <trans-unit id="dba5b2feac59133a263255144aa942786b75991f" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the unique values in the original array. Only provided if &lt;code&gt;return_index&lt;/code&gt; is True.</source>
          <target state="translated">元の配列で一意の値が最初に出現するインデックス。 &lt;code&gt;return_index&lt;/code&gt; がTrueの場合にのみ提供されます。</target>
        </trans-unit>
        <trans-unit id="a4f376a3994ea66b3e8fe543f1059936c2c097d7" translate="yes" xml:space="preserve">
          <source>The indices of the matched values can be obtained with &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">一致した値のインデックスは、&lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt;で取得できます。</target>
        </trans-unit>
        <trans-unit id="43a87c99c2b28bd6cf46e8003a99b97203e9c8c1" translate="yes" xml:space="preserve">
          <source>The indices of the values to extract.</source>
          <target state="translated">抽出する値のインデックス。</target>
        </trans-unit>
        <trans-unit id="6ca413808a0cb47ebd7eb463c61ac12f6ed3fe9d" translate="yes" xml:space="preserve">
          <source>The indices to reconstruct the original array from the unique array. Only provided if &lt;code&gt;return_inverse&lt;/code&gt; is True.</source>
          <target state="translated">一意の配列から元の配列を再構築するためのインデックス。 &lt;code&gt;return_inverse&lt;/code&gt; がTrueの場合にのみ提供されます。</target>
        </trans-unit>
        <trans-unit id="76cdf05ced9d0285381afd071b2e4305a0c8b8a1" translate="yes" xml:space="preserve">
          <source>The indices will be valid for square arrays whose dimensions are the same as arr.</source>
          <target state="translated">インデックスは,arr と同じ寸法の正方配列に対して有効になります.</target>
        </trans-unit>
        <trans-unit id="b73635c48b132fb2b59a6aa95f3cc03ac517b9fa" translate="yes" xml:space="preserve">
          <source>The indices will be valid for square arrays.</source>
          <target state="translated">インデックスは正方配列で有効になります。</target>
        </trans-unit>
        <trans-unit id="b17807d1d3d4b02432b9a563a71fb115959130d3" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;a&lt;/code&gt; as a float ndarray.</source>
          <target state="translated">float ndarrayとしての入力 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="223b4394f2d166cb77455c12d7788790c3301749" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;a&lt;/code&gt; in Fortran, or column-major, order.</source>
          <target state="translated">Fortran、または列優先の順序での入力 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="528560fa701c687c766a152165432c7d1064754a" translate="yes" xml:space="preserve">
          <source>The input array</source>
          <target state="translated">入力配列</target>
        </trans-unit>
        <trans-unit id="c14ffcb4fd955aec9b7bdb6f4e9b85112587e6c8" translate="yes" xml:space="preserve">
          <source>The input array needs to be of integer dtype, otherwise a TypeError is raised:</source>
          <target state="translated">入力配列は整数の dtype である必要があり、そうでない場合は TypeError が発生します。</target>
        </trans-unit>
        <trans-unit id="8ffb9fe9f3741ba95404f548e61803acdf79b642" translate="yes" xml:space="preserve">
          <source>The input array with invalid entries fixed.</source>
          <target state="translated">無効なエントリが固定された入力配列。</target>
        </trans-unit>
        <trans-unit id="729e431a614c3f0d0d957b108e3ad1877caf7dd5" translate="yes" xml:space="preserve">
          <source>The input array&amp;rsquo;s mask is modified by this function.</source>
          <target state="translated">入力配列のマスクは、この関数によって変更されます。</target>
        </trans-unit>
        <trans-unit id="2bcc0bcc75499b8aa5923f648739bb1e1c9c5f2a" translate="yes" xml:space="preserve">
          <source>The input array, but with all or a subset of the dimensions of length 1 removed. This is always &lt;code&gt;a&lt;/code&gt; itself or a view into &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">入力配列ですが、長さ1の次元のすべてまたはサブセットが削除されています。これは、常に自分自身またはへのビュー。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b9eebd6f3c2dccb825ca1eb5d3b6fff39eb990c" translate="yes" xml:space="preserve">
          <source>The input array.</source>
          <target state="translated">入力配列です。</target>
        </trans-unit>
        <trans-unit id="a8dbbfb64079646cc26f949474f62f6d5a8bdb10" translate="yes" xml:space="preserve">
          <source>The input arrays are the coefficients (including any coefficients equal to zero) of the &amp;ldquo;numerator&amp;rdquo; (dividend) and &amp;ldquo;denominator&amp;rdquo; (divisor) polynomials, respectively.</source>
          <target state="translated">入力配列は、それぞれ「分子」（被除数）および「分母」（除数）多項式の係数（ゼロに等しい係数を含む）です。</target>
        </trans-unit>
        <trans-unit id="a4fe0b89df27127c64e2d6a838fb7376eb328411" translate="yes" xml:space="preserve">
          <source>The input can be of any type and shape.</source>
          <target state="translated">入力の種類や形状は問いません。</target>
        </trans-unit>
        <trans-unit id="0756c557e9cd622a4b4a6242d6e56ce5652e83a5" translate="yes" xml:space="preserve">
          <source>The input data type is preserved, list/tuple in means list/tuple out.</source>
          <target state="translated">入力データ型は保存され、list/tuple in は list/tuple out を意味します。</target>
        </trans-unit>
        <trans-unit id="7e65fba32b4c379aee34d72564b929f364329962" translate="yes" xml:space="preserve">
          <source>The input data type. This can be a &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; object or an object that is convertible to a &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">入力データ型。これは、&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;オブジェクトまたはdtypeに変換可能なオブジェクトにすることが&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="8769eb794f5a03165931ba8181e41168fd7a696f" translate="yes" xml:space="preserve">
          <source>The input domain.</source>
          <target state="translated">入力領域。</target>
        </trans-unit>
        <trans-unit id="8cece683eb84b1c6561cdb1ebf8cbf9f503e743a" translate="yes" xml:space="preserve">
          <source>The input is expected to be in the form returned by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, i.e. the real zero-frequency term followed by the complex positive frequency terms in order of increasing frequency. Since the discrete Fourier Transform of real input is Hermitian-symmetric, the negative frequency terms are taken to be the complex conjugates of the corresponding positive frequency terms.</source>
          <target state="translated">入力は、&lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt;によって返される形式であることが期待されます。つまり、実際のゼロ周波数項の後に、周波数の昇順で複素数の正の周波数項が続きます。実際の入力の離散フーリエ変換はエルミート対称であるため、負の周波数項は対応する正の周波数項の複素共役と見なされます。</target>
        </trans-unit>
        <trans-unit id="8d2a5838e3e88200b2eb57081e0d55983a6951c5" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to fill the whole state. The first element is reset such that only its most significant bit is set.</source>
          <target state="translated">入力シードは、 &lt;code&gt;SeedSequence&lt;/code&gt; によって処理され、状態全体が埋められます。最初の要素はリセットされ、最上位ビットのみが設定されます。</target>
        </trans-unit>
        <trans-unit id="b59429801bb072b95be274b2cab8c79cb4d9a0af" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate both values. The increment is not independently settable.</source>
          <target state="translated">入力シードは &lt;code&gt;SeedSequence&lt;/code&gt; によって処理され、両方の値が生成されます。増分は独立して設定できません。</target>
        </trans-unit>
        <trans-unit id="837326b6e18d83ecb217345cd40ecfada7f873f1" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate the first 3 values, then the &lt;code&gt;SFC64&lt;/code&gt; algorithm is iterated a small number of times to mix.</source>
          <target state="translated">入力シードは &lt;code&gt;SeedSequence&lt;/code&gt; によって処理されて最初の3つの値が生成され、次に &lt;code&gt;SFC64&lt;/code&gt; アルゴリズムが少数回反復されて混合されます。</target>
        </trans-unit>
        <trans-unit id="df03e47997abce099faab26366e6f5795a2b583f" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate the key. The counter is set to 0.</source>
          <target state="translated">入力シードは、 &lt;code&gt;SeedSequence&lt;/code&gt; によって処理されてキーが生成されます。カウンターは0に設定されます。</target>
        </trans-unit>
        <trans-unit id="9065e71c46c758a421d1a5608c4e7515cdea0b0c" translate="yes" xml:space="preserve">
          <source>The input should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, i.e.,</source>
          <target state="translated">入力は、&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;によって返されるのと同じ方法で順序付けする必要があります。つまり、</target>
        </trans-unit>
        <trans-unit id="14cd4f07dbbafbca343da6b376f0bb96ca0ebb1e" translate="yes" xml:space="preserve">
          <source>The input should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;, i.e. as for &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; for the final transformation axis, and as for &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; along all the other axes.</source>
          <target state="translated">入力が返されるのと同じ方法で順序付けされるべき&lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt;用として、すなわち&lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt;最終変換軸用、およびに関しては&lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt;他のすべての軸に沿っ。</target>
        </trans-unit>
        <trans-unit id="44801963410659f1459e257160aa0d4b1ef39ba2" translate="yes" xml:space="preserve">
          <source>The input value(s).</source>
          <target state="translated">入力された値。</target>
        </trans-unit>
        <trans-unit id="519628f03d9ba5d6ae3260f3b709f32afd6fac80" translate="yes" xml:space="preserve">
          <source>The input, analogously to &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fft2#numpy.fft.fft2&quot;&gt;&lt;code&gt;fft2&lt;/code&gt;&lt;/a&gt;, i.e. it should have the term for zero frequency in the low-order corner of the two axes, the positive frequency terms in the first half of these axes, the term for the Nyquist frequency in the middle of the axes and the negative frequency terms in the second half of both axes, in order of decreasingly negative frequency.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt;と同様に、入力は&lt;a href=&quot;numpy.fft.fft2#numpy.fft.fft2&quot;&gt; &lt;code&gt;fft2&lt;/code&gt; &lt;/a&gt;によって返されるのと同じ方法で順序付けする必要があります。つまり、2つの軸の低次コーナーにゼロ周波数の項があり、これらの前半に正の周波数項があります。軸、軸の中央にあるナイキスト周波数の項、および両方の軸の後半にある負の周波数の項。</target>
        </trans-unit>
        <trans-unit id="572b4f9e26edc1e967cf68e0ade8b40ff905e225" translate="yes" xml:space="preserve">
          <source>The input, analogously to &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;, i.e. it should have the term for zero frequency in all axes in the low-order corner, the positive frequency terms in the first half of all axes, the term for the Nyquist frequency in the middle of all axes and the negative frequency terms in the second half of all axes, in order of decreasingly negative frequency.</source>
          <target state="translated">入力は、&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt;と同様に、&lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt;によって返されるのと同じ方法で順序付けする必要があります。つまり、入力は、低次のコーナーのすべての軸でゼロ周波数の項、すべての軸の前半で正の周波数項を持つ必要があります、すべての軸の真ん中のナイキスト周波数の項と、すべての軸の後半の負の周波数項を、負の周波数から順に示します。</target>
        </trans-unit>
        <trans-unit id="0d58354ed5e0735b3768fbb2adf71637dbdf3f49" translate="yes" xml:space="preserve">
          <source>The integration constants default to zero, but can be specified:</source>
          <target state="translated">積分定数のデフォルトはゼロですが、指定することができます。</target>
        </trans-unit>
        <trans-unit id="a5987614ed3add49e80f0f100dd67a16f44fe90c" translate="yes" xml:space="preserve">
          <source>The interpolated values, same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と同じ形状の補間値。</target>
        </trans-unit>
        <trans-unit id="c7907bef880fafa82932152f51dbb34029c0604c" translate="yes" xml:space="preserve">
          <source>The inverse &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt;&lt;code&gt;cos&lt;/code&gt;&lt;/a&gt; is also known as &lt;code&gt;acos&lt;/code&gt; or cos^-1.</source>
          <target state="translated">逆&lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt; &lt;code&gt;cos&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;acos&lt;/code&gt; またはcos ^ -1 とも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="ec2dceba2b532e6fed6c11da573a946f40425e79" translate="yes" xml:space="preserve">
          <source>The inverse DFT is defined as</source>
          <target state="translated">逆DFTは次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="8495a1f69fb848ed573ead2789554fd370f64138" translate="yes" xml:space="preserve">
          <source>The inverse Gaussian distribution was first studied in relationship to Brownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian because there is an inverse relationship between the time to cover a unit distance and distance covered in unit time.</source>
          <target state="translated">逆ガウス分布は、ブラウン運動との関係で最初に研究されました。1956年にM.C.K.Tweedieが逆ガウス分布という名前を使ったのは、単位距離をカバーする時間と単位時間でカバーされる距離の間に逆の関係があるからです。</target>
        </trans-unit>
        <trans-unit id="68560eb00ac6299a73ce699655a0c6fd4e05a46a" translate="yes" xml:space="preserve">
          <source>The inverse function.</source>
          <target state="translated">逆関数です。</target>
        </trans-unit>
        <trans-unit id="fe2bbafffa2c0c536b90659aca2befdd2f2ba17e" translate="yes" xml:space="preserve">
          <source>The inverse hyperbolic sine is also known as &lt;code&gt;asinh&lt;/code&gt; or &lt;code&gt;sinh^-1&lt;/code&gt;.</source>
          <target state="translated">逆双曲線正弦は、 &lt;code&gt;asinh&lt;/code&gt; または &lt;code&gt;sinh^-1&lt;/code&gt; とも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="6a141e357fc6a95097873c345fcfc1ca43237a09" translate="yes" xml:space="preserve">
          <source>The inverse hyperbolic tangent is also known as &lt;code&gt;atanh&lt;/code&gt; or &lt;code&gt;tanh^-1&lt;/code&gt;.</source>
          <target state="translated">逆双曲線正接は、 &lt;code&gt;atanh&lt;/code&gt; または &lt;code&gt;tanh^-1&lt;/code&gt; とも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="aed0ee03d4e87b9fedd1788aca12c58fdfb391c4" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;の逆。</target>
        </trans-unit>
        <trans-unit id="0b353ae768e12e71d0fa6bfe266dc15cf5490d90" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;, the inverse &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt;次元の逆FFT である&lt;a href=&quot;#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt;の逆。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c086c016e117d897d4f2eb057744861a76634688" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt;の逆です。</target>
        </trans-unit>
        <trans-unit id="9c2cb38b9631386379f4eeff7af3bee02f4b9bd5" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.hfft&quot;&gt;&lt;code&gt;hfft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.hfft&quot;&gt; &lt;code&gt;hfft&lt;/code&gt; &lt;/a&gt;の逆です。</target>
        </trans-unit>
        <trans-unit id="13314fd29e0fae4ac48c552fa0a549b05087d956" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt;の逆です。</target>
        </trans-unit>
        <trans-unit id="ff66e88345498b6e91d7444ef284a6ddd3ab7bea" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;, i.e. the inverse of the n-dimensional FFT of real input.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt;の逆、つまり実数入力のn次元FFTの逆。</target>
        </trans-unit>
        <trans-unit id="9e5b2a4471d9b30f761353eccfa786e46a0a43ee" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;generated/numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt;の逆です。</target>
        </trans-unit>
        <trans-unit id="f58d6b52f1a134a30d097dc36ab0b6c772a15466" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt;&lt;code&gt;cos&lt;/code&gt;&lt;/a&gt; so that, if &lt;code&gt;y = cos(x)&lt;/code&gt;, then &lt;code&gt;x = arccos(y)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt; &lt;code&gt;cos&lt;/code&gt; &lt;/a&gt;の逆なので、 &lt;code&gt;y = cos(x)&lt;/code&gt; 場合、 &lt;code&gt;x = arccos(y)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="55a9d6743075a74b179dcc12407ef1436ea7bf25" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;. Although identical for even-length &lt;code&gt;x&lt;/code&gt;, the functions differ by one sample for odd-length &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt;の逆です。偶数長の &lt;code&gt;x&lt;/code&gt; についても同じですが、関数は奇数長の &lt;code&gt;x&lt;/code&gt; について1つのサンプルが異なります。</target>
        </trans-unit>
        <trans-unit id="2b74e3f8abd785dde93a2e8dda9f5c04957251f7" translate="yes" xml:space="preserve">
          <source>The inverse of tan, so that if &lt;code&gt;y = tan(x)&lt;/code&gt; then &lt;code&gt;x = arctan(y)&lt;/code&gt;.</source>
          <target state="translated">tanの逆なので、 &lt;code&gt;y = tan(x)&lt;/code&gt; 場合、 &lt;code&gt;x = arctan(y)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="7167a352b20dee7e079ce80d9af1a1aba672dc81" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;em&gt;n&lt;/em&gt;-dimensional FFT of real input.</source>
          <target state="translated">実数入力の&lt;em&gt;n&lt;/em&gt;次元FFT の逆。</target>
        </trans-unit>
        <trans-unit id="c880c78696b367269e70a1f53424d9f97028c767" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt;次元FFT の逆。</target>
        </trans-unit>
        <trans-unit id="f53fd91fa9c77430f006f0266202a3482a70bbcc" translate="yes" xml:space="preserve">
          <source>The inverse of the one-dimensional FFT of real input.</source>
          <target state="translated">実数入力の一次元FFTの逆数です。</target>
        </trans-unit>
        <trans-unit id="3905252dc05b002d9515309faf3f78f1dbb4c5f8" translate="yes" xml:space="preserve">
          <source>The inverse of the two-dimensional FFT of real input.</source>
          <target state="translated">実数入力の2次元FFTの逆数です。</target>
        </trans-unit>
        <trans-unit id="3423775348fb08030d24725c90e7b0f2bd7d7c47" translate="yes" xml:space="preserve">
          <source>The inverse operation, adding singleton dimensions</source>
          <target state="translated">逆の操作、シングルトン次元の追加</target>
        </trans-unit>
        <trans-unit id="aa766ce77746577ed5c08c35ec888672cda564ff" translate="yes" xml:space="preserve">
          <source>The inverse operation, removing singleton dimensions</source>
          <target state="translated">逆演算、シングルトン次元の除去</target>
        </trans-unit>
        <trans-unit id="61a85cd6779e9d5a8b6211c3c235036b15ffb999" translate="yes" xml:space="preserve">
          <source>The inverse sine is also known as &lt;code&gt;asin&lt;/code&gt; or sin^{-1}.</source>
          <target state="translated">逆正弦は、 &lt;code&gt;asin&lt;/code&gt; またはsin ^ {-1} とも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="bfedf779c5c4bd6b17ab80b12a0d79168ab5aaa7" translate="yes" xml:space="preserve">
          <source>The inverse sine of each element in &lt;code&gt;x&lt;/code&gt;, in radians and in the closed interval &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 、ラジアン、および閉区間 &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt; の各要素の逆正弦。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="9c1a84044c9dab08c09d55a04b2b48623b8d59b6" translate="yes" xml:space="preserve">
          <source>The inverse tangent is also known as &lt;code&gt;atan&lt;/code&gt; or tan^{-1}.</source>
          <target state="translated">逆正接は、 &lt;code&gt;atan&lt;/code&gt; またはtan ^ {-1} とも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="6981525643a6c5c7fc9e1e7dde681f16ce56e65e" translate="yes" xml:space="preserve">
          <source>The inverse two-dimensional FFT.</source>
          <target state="translated">逆二次元FFTです。</target>
        </trans-unit>
        <trans-unit id="bdb5ead908952013fac6606928f3a4c8d7370b91" translate="yes" xml:space="preserve">
          <source>The irrational number &lt;code&gt;e&lt;/code&gt; is also known as Euler&amp;rsquo;s number. It is approximately 2.718281, and is the base of the natural logarithm, &lt;code&gt;ln&lt;/code&gt; (this means that, if</source>
          <target state="translated">無理数 &lt;code&gt;e&lt;/code&gt; はオイラー数とも呼ばれます。これは約2.718281であり、自然対数 &lt;code&gt;ln&lt;/code&gt; の底です（これは、</target>
        </trans-unit>
        <trans-unit id="3dd3b5ec09656689d6b02dda587489104a598f1e" translate="yes" xml:space="preserve">
          <source>The iterator flag &amp;ldquo;delay_bufalloc&amp;rdquo; is there to allow iterator-allocated reduction operands to exist together with buffering. When this flag is set, the iterator will leave its buffers uninitialized until it receives a reset, after which it will be ready for regular iteration. Here&amp;rsquo;s how the previous example looks if we also enable buffering.</source>
          <target state="translated">イテレータフラグ「delay_bufalloc」は、イテレータ割り当ての縮小オペランドがバッファリングと一緒に存在できるようにするためのものです。このフラグが設定されると、イテレーターは、リセットを受け取るまでバッファーを初期化せずに残し、その後、通常の反復の準備が整います。これも、バッファリングを有効にした場合の前の例の外観です。</target>
        </trans-unit>
        <trans-unit id="83edec37e4aaff5eef637f7c874f4dba22293c2c" translate="yes" xml:space="preserve">
          <source>The iterator holds a reference to iter</source>
          <target state="translated">イテレータは、イテレータへの参照を保持します。</target>
        </trans-unit>
        <trans-unit id="ffb4fa1555c6cc08c5edb304e11089604a5e4b03" translate="yes" xml:space="preserve">
          <source>The iterator layout is an internal detail, and user code only sees an incomplete struct.</source>
          <target state="translated">イテレータのレイアウトは内部的な詳細であり、ユーザー・コードは不完全な構造体しか見ていません。</target>
        </trans-unit>
        <trans-unit id="5cd3a081c57ba646ed11444a9ba92c76e9cd9145" translate="yes" xml:space="preserve">
          <source>The iterator object &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;, introduced in NumPy 1.6, provides many flexible ways to visit all the elements of one or more arrays in a systematic fashion. This page introduces some basic ways to use the object for computations on arrays in Python, then concludes with how one can accelerate the inner loop in Cython. Since the Python exposure of &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; is a relatively straightforward mapping of the C array iterator API, these ideas will also provide help working with array iteration from C or C++.</source>
          <target state="translated">NumPy 1.6で導入されたイテレーターオブジェクト&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; は&lt;/a&gt;、1つ以上の配列のすべての要素に体系的にアクセスする多くの柔軟な方法を提供します。このページでは、Pythonでの配列の計算にオブジェクトを使用するいくつかの基本的な方法を紹介し、Cythonの内部ループを加速する方法で終わります。&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;のPythonへの公開は、C配列反復子APIの比較的単純なマッピングであるため、これらのアイデアは、CまたはC ++からの配列反復の操作にも役立ちます。</target>
        </trans-unit>
        <trans-unit id="c7cde3e3f66c5a8b8cc8bfff4db276cc023c595e" translate="yes" xml:space="preserve">
          <source>The iterator uses NumPy&amp;rsquo;s casting rules to determine whether a specific conversion is permitted. By default, it enforces &amp;lsquo;safe&amp;rsquo; casting. This means, for example, that it will raise an exception if you try to treat a 64-bit float array as a 32-bit float array. In many cases, the rule &amp;lsquo;same_kind&amp;rsquo; is the most reasonable rule to use, since it will allow conversion from 64 to 32-bit float, but not from float to int or from complex to float.</source>
          <target state="translated">イテレーターは、NumPyのキャスト規則を使用して、特定の変換が許可されているかどうかを判別します。デフォルトでは、「安全な」キャストを強制します。つまり、たとえば、64ビットの浮動小数点配列を32ビットの浮動小数点配列として処理しようとすると、例外が発生します。多くの場合、ルール「same_kind」は、64ビットから32ビットの浮動小数点への変換を許可しますが、浮動小数点からintへの変換、または複素数から浮動小数点への変換を許可しないため、使用する最も合理的なルールです。</target>
        </trans-unit>
        <trans-unit id="bfb129467dcc5458e92314d1dc23bfece4b4c9b2" translate="yes" xml:space="preserve">
          <source>The jump size is</source>
          <target state="translated">ジャンプサイズは</target>
        </trans-unit>
        <trans-unit id="1697c380f1179f3bbb3a86f4d75a8de0b46efbc6" translate="yes" xml:space="preserve">
          <source>The keys are:</source>
          <target state="translated">鍵は...</target>
        </trans-unit>
        <trans-unit id="b094a8a56c283a1dca9080c127defb8dc7eabacc" translate="yes" xml:space="preserve">
          <source>The kind of integer data type to get information about.</source>
          <target state="translated">情報を取得するための整数データ型の種類。</target>
        </trans-unit>
        <trans-unit id="d80fbf99f1073ba593f4b530d71e8ae5f9ae88a1" translate="yes" xml:space="preserve">
          <source>The larger object to compare.</source>
          <target state="translated">比較対象の大きい方。</target>
        </trans-unit>
        <trans-unit id="3b1d6d882f09df5877abb8ef200d99a4552edbcc" translate="yes" xml:space="preserve">
          <source>The largest representable number.</source>
          <target state="translated">表現可能な最大の数。</target>
        </trans-unit>
        <trans-unit id="2abbd596290a88e6d12f22ea12675111b689f0a9" translate="yes" xml:space="preserve">
          <source>The last is an instance of freezing a core dimension and can be used to improve ufunc performance</source>
          <target state="translated">最後はコアディメンジョンのフリーズの例で、ufunc のパフォーマンスを向上させるために使用することができます。</target>
        </trans-unit>
        <trans-unit id="64a2253d0a7bf7afbe6eb3cddc1d5520d0b0c60a" translate="yes" xml:space="preserve">
          <source>The last one giving only the first elements because of the extra dimension. Compare &lt;code&gt;rowsum.nonzero()&lt;/code&gt; to understand this example.</source>
          <target state="translated">余分な次元のため、最後の要素は最初の要素のみを与えます。 &lt;code&gt;rowsum.nonzero()&lt;/code&gt; を比較して、この例を理解してください。</target>
        </trans-unit>
        <trans-unit id="2e8784c819189f431349d4282dd8265432f3285b" translate="yes" xml:space="preserve">
          <source>The latter group of &lt;code&gt;{NAME}s&lt;/code&gt; corresponds to letters used in the array interface typestring specification.</source>
          <target state="translated">後者の &lt;code&gt;{NAME}s&lt;/code&gt; グループは、配列インターフェイスのtypestring仕様で使用される文字に対応しています。</target>
        </trans-unit>
        <trans-unit id="34445ad4113f33f26d89f86d8eb17d5993aa2b33" translate="yes" xml:space="preserve">
          <source>The leftmost and rightmost edges of the bins along each dimension (if not specified explicitly in the &lt;code&gt;bins&lt;/code&gt; parameters): &lt;code&gt;[[xmin, xmax], [ymin, ymax]]&lt;/code&gt;. All values outside of this range will be considered outliers and not tallied in the histogram.</source>
          <target state="translated">各次元に沿ったビンの左端と右端（ &lt;code&gt;bins&lt;/code&gt; パラメーターで明示的に指定されていない場合）： &lt;code&gt;[[xmin, xmax], [ymin, ymax]]&lt;/code&gt; 。この範囲外のすべての値は外れ値と見なされ、ヒストグラムで集計されません。</target>
        </trans-unit>
        <trans-unit id="7a57cb0c41d71bfde5dfe132d9a4c3e502a05b10" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;condlist&lt;/code&gt; must correspond to that of &lt;code&gt;funclist&lt;/code&gt;. If one extra function is given, i.e. if &lt;code&gt;len(funclist) == len(condlist) + 1&lt;/code&gt;, then that extra function is the default value, used wherever all conditions are false.</source>
          <target state="translated">&lt;code&gt;condlist&lt;/code&gt; の長さは、funclistの長さに対応している必要があり &lt;code&gt;funclist&lt;/code&gt; 。1つの追加関数が指定されている場合、つまり &lt;code&gt;len(funclist) == len(condlist) + 1&lt;/code&gt; 場合、その追加関数はデフォルト値であり、すべての条件がfalseの場合に使用されます。</target>
        </trans-unit>
        <trans-unit id="74e1dfe5bb68b99490ab8db3a4549a897ab92285" translate="yes" xml:space="preserve">
          <source>The length of the list of integers. It is assumed safe to access &lt;em&gt;ptr&lt;/em&gt; [0] to &lt;em&gt;ptr&lt;/em&gt; [len-1].</source>
          <target state="translated">整数のリストの長さ。&lt;em&gt;ptr&lt;/em&gt; [0]から&lt;em&gt;ptr&lt;/em&gt; [len-1] に安全にアクセスできると想定されています。</target>
        </trans-unit>
        <trans-unit id="c7170d6904bad30d46bd752038c157844edf21e6" translate="yes" xml:space="preserve">
          <source>The length of the prefix and suffix strings are used to respectively align and wrap the output. An array is typically printed as:</source>
          <target state="translated">接頭辞と接尾辞の文字列の長さは、それぞれ出力の位置合わせと折り返しに使われます。配列は通常次のように出力されます。</target>
        </trans-unit>
        <trans-unit id="2a29e90467961f11261cb34c5ec7868485d4aa81" translate="yes" xml:space="preserve">
          <source>The length of the resulting strings</source>
          <target state="translated">結果として得られる文字列の長さ</target>
        </trans-unit>
        <trans-unit id="bd80f84b161ca3d681912061b09ff3df6041ed39" translate="yes" xml:space="preserve">
          <source>The length of the returned string if &lt;code&gt;num&lt;/code&gt; is positive, or the length of the two&amp;rsquo;s complement if &lt;code&gt;num&lt;/code&gt; is negative, provided that &lt;code&gt;width&lt;/code&gt; is at least a sufficient number of bits for &lt;code&gt;num&lt;/code&gt; to be represented in the designated form.</source>
          <target state="translated">&lt;code&gt;num&lt;/code&gt; が正の場合は返される文字列の長さ、または &lt;code&gt;num&lt;/code&gt; が負の場合は2の補数の長さ。ただし、 &lt;code&gt;width&lt;/code&gt; が、指定された形式で &lt;code&gt;num&lt;/code&gt; を表すのに十分なビット数である場合。</target>
        </trans-unit>
        <trans-unit id="63e0949a7b519952c49eb749b0448baf6c2dcdf9" translate="yes" xml:space="preserve">
          <source>The length of the segment in bytes.</source>
          <target state="translated">セグメントの長さをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="b0af5a70b649c99b0be522e1c0ad6114744383d4" translate="yes" xml:space="preserve">
          <source>The length of the span is the range of a 64-bit integer times the length of the date or unit. For example, the time span for &amp;lsquo;W&amp;rsquo; (week) is exactly 7 times longer than the time span for &amp;lsquo;D&amp;rsquo; (day), and the time span for &amp;lsquo;D&amp;rsquo; (day) is exactly 24 times longer than the time span for &amp;lsquo;h&amp;rsquo; (hour).</source>
          <target state="translated">スパンの長さは、64ビット整数に日付または単位の長さを掛けた範囲です。たとえば、「W」（週）のタイムスパンは「D」（日）のタイムスパンより正確に7倍長く、「D」（日）のタイムスパンはタイムスパンより正確に24倍長くなります。 「h」（時間）。</target>
        </trans-unit>
        <trans-unit id="c92e142a9e3623399b64df009d94b4d034da17ea" translate="yes" xml:space="preserve">
          <source>The line above represents z**3 + 0*z**2 + 0*z + 0.</source>
          <target state="translated">上の線は、z**3+0*z**2+0*z+0を表しています。</target>
        </trans-unit>
        <trans-unit id="b578e5e67f3e586204e4994bbe5c88c656a6cae7" translate="yes" xml:space="preserve">
          <source>The line above represents z**3 - z/4</source>
          <target state="translated">上の線は z**3-z/4 を表しています。</target>
        </trans-unit>
        <trans-unit id="cb5275e91dcecc0c6dc816bc9710e92658bd3377" translate="yes" xml:space="preserve">
          <source>The linear map &lt;code&gt;offset + scale*x&lt;/code&gt; that maps the domain &lt;code&gt;old&lt;/code&gt; to the domain &lt;code&gt;new&lt;/code&gt; is applied to the points &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">リニアマップ &lt;code&gt;offset + scale*x&lt;/code&gt; ドメインマップする &lt;code&gt;old&lt;/code&gt; ドメインに &lt;code&gt;new&lt;/code&gt; ポイントに適用される &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="647499d1a98b89607edcd5f783a0adb1c730bbde" translate="yes" xml:space="preserve">
          <source>The list of arrays from which the output elements are taken. It has to be of the same length as &lt;code&gt;condlist&lt;/code&gt;.</source>
          <target state="translated">出力要素が取得される配列のリスト。 &lt;code&gt;condlist&lt;/code&gt; と同じ長さでなければなりません。</target>
        </trans-unit>
        <trans-unit id="529e159ac14f2e5a4bfd821c54e94a56730b5c46" translate="yes" xml:space="preserve">
          <source>The list of conditions which determine from which array in &lt;code&gt;choicelist&lt;/code&gt; the output elements are taken. When multiple conditions are satisfied, the first one encountered in &lt;code&gt;condlist&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;choicelist&lt;/code&gt; のどの配列から出力要素を取得するかを決定する条件のリスト。複数の条件が満たされた場合、 &lt;code&gt;condlist&lt;/code&gt; で最初に検出された条件が使用されます。</target>
        </trans-unit>
        <trans-unit id="92c329f0ce8c711e6636f92601cc50d421b9b226" translate="yes" xml:space="preserve">
          <source>The list of slices, one for each continuous region of masked elements in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">スライスのリストでマスクされた要素の各連続領域のための1つ。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="88a36ffbba49be32da3baf6bb43ea7e384cf3381" translate="yes" xml:space="preserve">
          <source>The list of slices, one for each continuous region of unmasked elements in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">スライスのリスト、でマスクされていない要素のそれぞれの連続した領域に1つ。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7251af1a3271825930cf9fcd1d817e4c55bd823" translate="yes" xml:space="preserve">
          <source>The list of sources may contain functions (&amp;lsquo;source generators&amp;rsquo;) with a pattern &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return
&amp;lt;source(s) or None&amp;gt;&lt;/code&gt;. If &lt;code&gt;funcname&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, no sources are generated. And if the &lt;code&gt;Extension&lt;/code&gt; instance has no sources after processing all source generators, no extension module will be built. This is the recommended way to conditionally define extension modules. Source generator functions are called by the &lt;code&gt;build_src&lt;/code&gt; command of &lt;code&gt;numpy.distutils&lt;/code&gt;.</source>
          <target state="translated">ソースのリストには、パターン &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return &amp;lt;source(s) or None&amp;gt;&lt;/code&gt; 持つ関数（「ソースジェネレーター」）が含まれる場合があります。 &lt;code&gt;funcname&lt;/code&gt; が &lt;code&gt;None&lt;/code&gt; を返す場合、ソースは生成されません。また、すべてのソースジェネレーターを処理した後、 &lt;code&gt;Extension&lt;/code&gt; インスタンスにソースがない場合、拡張モジュールはビルドされません。これは、拡張モジュールを条件付きで定義するための推奨される方法です。ソースジェネレータ関数は、 &lt;code&gt;build_src&lt;/code&gt; コマンドによって &lt;code&gt;numpy.distutils&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="e86e6b1dfd4d026f3bb365ed0394b538f40e1c2c" translate="yes" xml:space="preserve">
          <source>The location of the mode of the distribution. Default is 0.</source>
          <target state="translated">ディストリビューションのモードの位置。デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="f922a603661ce7b289c8f2d5dd79d3f8d12f2d5b" translate="yes" xml:space="preserve">
          <source>The log series distribution is frequently used to represent species richness and occurrence, first proposed by Fisher, Corbet, and Williams in 1943 [2]. It may also be used to model the numbers of occupants seen in cars [3].</source>
          <target state="translated">対数系列分布は,種の豊富さと発生を表現するために頻繁に使用され,1943年にFisher,Corbet,and Williamsによって最初に提案された [2].また,車の中で見られる乗員の数をモデル化するのにも使われることがある [3].</target>
        </trans-unit>
        <trans-unit id="23451df0ca8ba5d5bfbdca9cf8c2255b108c68ac" translate="yes" xml:space="preserve">
          <source>The logarithm to the base 10 of &lt;code&gt;x&lt;/code&gt;, element-wise. NaNs are returned where x is negative. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">要素ごとの &lt;code&gt;x&lt;/code&gt; の底10の対数。NaNは、xが負の場合に返されます。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="b8615daefc462d9e38519ed036e0e283940da95b" translate="yes" xml:space="preserve">
          <source>The lower and upper range of the bins. If not provided, range is simply &lt;code&gt;(a.min(), a.max())&lt;/code&gt;. Values outside the range are ignored. The first element of the range must be less than or equal to the second. &lt;code&gt;range&lt;/code&gt; affects the automatic bin computation as well. While bin width is computed to be optimal based on the actual data within &lt;code&gt;range&lt;/code&gt;, the bin count will fill the entire range including portions containing no data.</source>
          <target state="translated">ビンの下限と上限。指定しない場合、範囲は単に &lt;code&gt;(a.min(), a.max())&lt;/code&gt; ます。範囲外の値は無視されます。範囲の最初の要素は、2番目の要素以下でなければなりません。 &lt;code&gt;range&lt;/code&gt; は自動ビン計算にも影響します。ビンの幅は、 &lt;code&gt;range&lt;/code&gt; 内の実際のデータに基づいて最適になるように計算されますが、ビンの数は、データを含まない部分を含む範囲全体を占めます。</target>
        </trans-unit>
        <trans-unit id="6456e48a0250380ada9bfcdc5cd3014ca07e5eb0" translate="yes" xml:space="preserve">
          <source>The lower bound for the top 1% of the samples is :</source>
          <target state="translated">サンプルの上位1%の下限は.</target>
        </trans-unit>
        <trans-unit id="4e9276b72baca62196e481978e6fcfbd0f0274c3" translate="yes" xml:space="preserve">
          <source>The lower bound of the definite integral.</source>
          <target state="translated">定積分の下界。</target>
        </trans-unit>
        <trans-unit id="37caf12cbe44bfdef1d91bca2e93d01e775cf201" translate="yes" xml:space="preserve">
          <source>The lower bound of the integral. (Default: 0)</source>
          <target state="translated">積分の下界。(デフォルト:0)</target>
        </trans-unit>
        <trans-unit id="a76f1d77a96a5b462f5fae8acc24fa2aae62620a" translate="yes" xml:space="preserve">
          <source>The lowest common multiple</source>
          <target state="translated">最低公倍数</target>
        </trans-unit>
        <trans-unit id="87d6bfa25ac3b02d4e51aa1f4135cd735f016c13" translate="yes" xml:space="preserve">
          <source>The lowest common multiple of the absolute value of the inputs This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">入力の絶対値の最小公倍数 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="6767713cd6108661a0803484e7289fe42459ebb5" translate="yes" xml:space="preserve">
          <source>The main feature of the &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module is the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; class, which is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;. The class, its attributes and methods are described in more details in the &lt;a href=&quot;maskedarray.baseclass#maskedarray-baseclass&quot;&gt;MaskedArray class&lt;/a&gt; section.</source>
          <target state="translated">主な特徴&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; の&lt;/a&gt;モジュールである&lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; 用&lt;/a&gt;のサブクラスであるクラス、&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt;。クラス、その属性、およびメソッドについては、&lt;a href=&quot;maskedarray.baseclass#maskedarray-baseclass&quot;&gt;MaskedArrayクラスの&lt;/a&gt;セクションで詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="b863f0a577a40cd3794882f4e85002ecea6308b0" translate="yes" xml:space="preserve">
          <source>The mantissas &lt;code&gt;x1&lt;/code&gt; and twos exponents &lt;code&gt;x2&lt;/code&gt; are used to construct floating point numbers &lt;code&gt;x1 * 2**x2&lt;/code&gt;.</source>
          <target state="translated">仮数 &lt;code&gt;x1&lt;/code&gt; と2の指数 &lt;code&gt;x2&lt;/code&gt; は、浮動小数点数 &lt;code&gt;x1 * 2**x2&lt;/code&gt; を構成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="1288609b08eeb3cc92c01ebf371043c8f0d81962" translate="yes" xml:space="preserve">
          <source>The map &lt;code&gt;L(x) = offset + scale*x&lt;/code&gt; maps the first domain to the second.</source>
          <target state="translated">マップ &lt;code&gt;L(x) = offset + scale*x&lt;/code&gt; は、最初のドメインを2番目のドメインにマップします。</target>
        </trans-unit>
        <trans-unit id="fd5781bc4f89018e0fb9cd14ef3f3c125e3d74bb" translate="yes" xml:space="preserve">
          <source>The mapping function is defined by &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">マッピング関数は、 &lt;code&gt;off + scl*x&lt;/code&gt; 定義されます。</target>
        </trans-unit>
        <trans-unit id="f0d7698b06a0aedcc32f911c787189d531c3eac9" translate="yes" xml:space="preserve">
          <source>The mask is lost if &lt;code&gt;out&lt;/code&gt; is not a valid &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; !</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; が有効な&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; で&lt;/a&gt;はない場合、マスクは失われます。</target>
        </trans-unit>
        <trans-unit id="649d4874d06fb274533beb59f5f2cd10f5dc2b95" translate="yes" xml:space="preserve">
          <source>The mask is lost if &lt;code&gt;out&lt;/code&gt; is not a valid MaskedArray !</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; が有効なMaskedArrayではない場合、マスクは失われます。</target>
        </trans-unit>
        <trans-unit id="f9bf54dc7bd5e650858bf619f77da75fc06bf1f6" translate="yes" xml:space="preserve">
          <source>The mask of a masked array is accessible through its &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.mask&quot;&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/a&gt; attribute. We must keep in mind that a &lt;code&gt;True&lt;/code&gt; entry in the mask indicates an &lt;em&gt;invalid&lt;/em&gt; data.</source>
          <target state="translated">マスクされた配列のマスクには、その&lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.mask&quot;&gt; &lt;code&gt;mask&lt;/code&gt; &lt;/a&gt;属性を通じてアクセスできます。マスクの &lt;code&gt;True&lt;/code&gt; エントリは&lt;em&gt;無効な&lt;/em&gt;データを示していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="136b0641a8efd21e297d96cb868071b555117d7d" translate="yes" xml:space="preserve">
          <source>The masked arrays for which to compare fill values.</source>
          <target state="translated">塗りつぶし値を比較するためのマスクされた配列。</target>
        </trans-unit>
        <trans-unit id="6a7c669e8d49f546a924fb9ea3a27606961c98f7" translate="yes" xml:space="preserve">
          <source>The matmul function implements the semantics of the &lt;code&gt;@&lt;/code&gt; operator introduced in Python 3.5 following PEP465.</source>
          <target state="translated">関数matmulは、PEP465に続いてPython 3.5で導入された &lt;code&gt;@&lt;/code&gt; 演算子のセマンティクスを実装します。</target>
        </trans-unit>
        <trans-unit id="b0018603311d83d5ccf5c07dff4523d1ca410b48" translate="yes" xml:space="preserve">
          <source>The matrix class is a Python subclass of the ndarray and can be used as a reference for how to construct your own subclass of the ndarray. Matrices can be created from other matrices, strings, and anything else that can be converted to an &lt;code&gt;ndarray&lt;/code&gt; . The name &amp;ldquo;mat &amp;ldquo;is an alias for &amp;ldquo;matrix &amp;ldquo;in NumPy.</source>
          <target state="translated">行列クラスは、ndarrayのPythonサブクラスであり、ndarrayの独自のサブクラスを作成する方法のリファレンスとして使用できます。行列は、他の行列、文字列、および &lt;code&gt;ndarray&lt;/code&gt; に変換できるその他のものから作成できます。名前「mat」は、NumPyの「matrix」のエイリアスです。</target>
        </trans-unit>
        <trans-unit id="5f8d7cfa51bd7c57bbf7e03577a1825ff994845e" translate="yes" xml:space="preserve">
          <source>The matrix of random values with shape given by &lt;code&gt;*args&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; によって与えられる形状を持つランダム値の行列。</target>
        </trans-unit>
        <trans-unit id="608aa6eae8f7f68c13529cd8bd42452f015b4b90" translate="yes" xml:space="preserve">
          <source>The matrix product of the inputs. This is a scalar only when both x1, x2 are 1-d vectors.</source>
          <target state="translated">入力の行列積。これは x1,x2 が共に 1-d ベクトルの場合のみスカラーである。</target>
        </trans-unit>
        <trans-unit id="c658bc86aaba588a6a002ba9982fdea6c89bc9cc" translate="yes" xml:space="preserve">
          <source>The matrix whose condition number is sought.</source>
          <target state="translated">条件番号が求められる行列.</target>
        </trans-unit>
        <trans-unit id="c8c3ef8c7c85bd35de6e1deb7b50a36e856e51b4" translate="yes" xml:space="preserve">
          <source>The matrix, but as a (1, N) matrix if it had shape (N, 1).</source>
          <target state="translated">行列であるが、形状(N,1)を有する場合には(1,N)行列として</target>
        </trans-unit>
        <trans-unit id="d2f91514f11b147277135520b0867d5d6ef7f638" translate="yes" xml:space="preserve">
          <source>The maximum is equivalent to &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are nans, but it is faster and does proper broadcasting.</source>
          <target state="translated">x1もx2もnanでない場合 &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; 最大値はnp.where（x1&amp;gt; = x2、x1、x2）と同等ですが、高速で適切なブロードキャストを行います。</target>
        </trans-unit>
        <trans-unit id="d4b71803b063354491818e9ff7d7f91cb1c1ba7e" translate="yes" xml:space="preserve">
          <source>The maximum number of dimensions allowed in arrays.</source>
          <target state="translated">配列で許可される次元の最大数。</target>
        </trans-unit>
        <trans-unit id="aff70196c900f17cb2833a4c90eb4869b491b830" translate="yes" xml:space="preserve">
          <source>The maximum number of rows to read. Must not be used with skip_footer at the same time. If given, the value must be at least 1. Default is to read the entire file.</source>
          <target state="translated">読み込み可能な最大行数。skip_footerと同時に使用してはいけません。指定した場合、値は少なくとも1でなければなりません。 デフォルトはファイル全体を読み込むことになっています。</target>
        </trans-unit>
        <trans-unit id="bd4584d425d2919fbb0f9bcabce0ec35c9487dde" translate="yes" xml:space="preserve">
          <source>The maximum number of unit in the last place for tolerance (see Notes). Default is 1.</source>
          <target state="translated">許容範囲の最後の位置にある最大単位数(注意事項を参照)。デフォルトは1です。</target>
        </trans-unit>
        <trans-unit id="3cded325e7f85dbd01c8e732779ef69a0c4dfb37" translate="yes" xml:space="preserve">
          <source>The maximum number of units in the last place that elements of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; can differ. Default is 1.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; の要素が異なる可能性がある最後の場所の最大ユニット数。デフォルトは1です。</target>
        </trans-unit>
        <trans-unit id="4d9efaa03fd6ffe081e389f0039d71a839a20c3f" translate="yes" xml:space="preserve">
          <source>The maximum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">要素ごとの &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の最大値。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="0b24f05221f4af03e40635809a9e83b6c24ab35f" translate="yes" xml:space="preserve">
          <source>The maximum value along a given axis.</source>
          <target state="translated">与えられた軸に沿った最大値。</target>
        </trans-unit>
        <trans-unit id="fda69f03e934be306357e5eceaea53c34ff9559a" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, ignores NaNs.</source>
          <target state="translated">指定された軸に沿った配列の最大値で、NaNは無視されます。</target>
        </trans-unit>
        <trans-unit id="7815283b9ba6a866678fcbb140334dc5a033015a" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, ignoring any NaNs.</source>
          <target state="translated">任意のNaNを無視した、指定された軸に沿った配列の最大値。</target>
        </trans-unit>
        <trans-unit id="d4de50ed13c4c863bfa3e8deacb7e5bde93f23df" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, propagates NaNs.</source>
          <target state="translated">与えられた軸に沿った配列の最大値は、NaNを伝播する。</target>
        </trans-unit>
        <trans-unit id="7ea2e2a635f47e2f3d7b25aa79029eb57056d0e6" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, propagating any NaNs.</source>
          <target state="translated">任意のNaNを伝搬する、与えられた軸に沿った配列の最大値。</target>
        </trans-unit>
        <trans-unit id="1062669c35965744b7646a80587bb754273c0111" translate="yes" xml:space="preserve">
          <source>The maximum value of an output element. Must be present to allow computation on empty slice. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">出力要素の最大値。空のスライスでの計算を可能にするために存在する必要があります。詳細については、&lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4217fb4da5a1a61065cf374f0d2db5e29f625661" translate="yes" xml:space="preserve">
          <source>The mean is a coordinate in N-dimensional space, which represents the location where samples are most likely to be generated. This is analogous to the peak of the bell curve for the one-dimensional or univariate normal distribution.</source>
          <target state="translated">平均はN次元空間における座標であり、サンプルが最も発生しやすい位置を表しています。これは、一次元または一変量正規分布のベル曲線のピークに類似している。</target>
        </trans-unit>
        <trans-unit id="3afbef537c228c554c040f21270cfff32d76c2bc" translate="yes" xml:space="preserve">
          <source>The mean is normally calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of a hypothetical infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables.</source>
          <target state="translated">平均は通常 &lt;code&gt;x.sum() / N&lt;/code&gt; として計算されます。ここで、 &lt;code&gt;N = len(x)&lt;/code&gt; です。ただし、 &lt;code&gt;ddof&lt;/code&gt; が指定されている場合は、除数 &lt;code&gt;N - ddof&lt;/code&gt; が代わりに使用されます。標準的な統計手法では、 &lt;code&gt;ddof=1&lt;/code&gt; は、仮想の無限母集団の分散の不偏推定量を提供します。 &lt;code&gt;ddof=0&lt;/code&gt; は、正規分布変数の分散の最尤推定を提供します。</target>
        </trans-unit>
        <trans-unit id="476855af021420263dd600a85590e6b055b087d3" translate="yes" xml:space="preserve">
          <source>The members are</source>
          <target state="translated">メンバーは</target>
        </trans-unit>
        <trans-unit id="f25c150719f0aed3ef8299c88981d255d24f240e" translate="yes" xml:space="preserve">
          <source>The members of this structure are</source>
          <target state="translated">この構造のメンバーは</target>
        </trans-unit>
        <trans-unit id="a80fc0f190e501871954ac9917a55a8bb93998fb" translate="yes" xml:space="preserve">
          <source>The memmap object can be used anywhere an ndarray is accepted. Given a memmap &lt;code&gt;fp&lt;/code&gt;, &lt;code&gt;isinstance(fp, numpy.ndarray)&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">memmapオブジェクトは、ndarrayが受け入れられる場所ならどこでも使用できます。memmap &lt;code&gt;fp&lt;/code&gt; を指定すると、 &lt;code&gt;isinstance(fp, numpy.ndarray)&lt;/code&gt; は &lt;code&gt;True&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="afefc9cb88d75583ea623e16ea1f8cf60770f93a" translate="yes" xml:space="preserve">
          <source>The memory layout of an advanced indexing result is optimized for each indexing operation and no particular memory order can be assumed.</source>
          <target state="translated">高度なインデキシング結果のメモリレイアウトは、インデキシング操作ごとに最適化されており、特定のメモリ順序を想定することはできません。</target>
        </trans-unit>
        <trans-unit id="aca17bd9cdf5246e194be60887f21d5d2d2f6e20" translate="yes" xml:space="preserve">
          <source>The merged result.</source>
          <target state="translated">結合された結果です。</target>
        </trans-unit>
        <trans-unit id="7df7fe557cb7d0b2f7c1ec9ba89a3700046e049a" translate="yes" xml:space="preserve">
          <source>The method should return either the result of the operation, or &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; if the operation requested is not implemented.</source>
          <target state="translated">メソッドは操作の結果を返すか、要求された操作が実装されていない場合は&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; を返す&lt;/a&gt;必要があります。</target>
        </trans-unit>
        <trans-unit id="a4edd76a8cc0cb5a2a3b89a3543cae8f78bd75ba" translate="yes" xml:space="preserve">
          <source>The method uses the following property for computation: let</source>
          <target state="translated">このメソッドは、次のプロパティを計算に使用します。</target>
        </trans-unit>
        <trans-unit id="ad0d254fa1824d11c17af544fbf486dd80c358ac" translate="yes" xml:space="preserve">
          <source>The methods to estimate the optimal number of bins are well founded in literature, and are inspired by the choices R provides for histogram visualisation. Note that having the number of bins proportional to</source>
          <target state="translated">最適なビンの数を推定する方法は、文献でもよく知られており、Rがヒストグラムの可視化のために提供する選択肢に触発されています。に比例するビンの数を持つことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3d7963e1ce4d80720f0895da566be576ac9149e1" translate="yes" xml:space="preserve">
          <source>The minimal data type.</source>
          <target state="translated">最小限のデータ型です。</target>
        </trans-unit>
        <trans-unit id="24db4b82ce9f82692c92a9ac46d90c6b64d6bb97" translate="yes" xml:space="preserve">
          <source>The minimum is equivalent to &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">x1もx2もNaNでない場合 &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; 最小値はnp.where（x1 &amp;lt;= x2、x1、x2）と同等ですが、高速で適切なブロードキャストを行います。</target>
        </trans-unit>
        <trans-unit id="830a82f2ffde76e612c1dc506f1272bc14c9b4a2" translate="yes" xml:space="preserve">
          <source>The minimum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">要素ごとの &lt;code&gt;x1&lt;/code&gt; および &lt;code&gt;x2&lt;/code&gt; の最小値。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="f7a8e12ffb3a7b028e99ec9cbaae32de38a438d0" translate="yes" xml:space="preserve">
          <source>The minimum representable value.</source>
          <target state="translated">表現可能な最小値。</target>
        </trans-unit>
        <trans-unit id="78d2dd7cf3cdcedef397cc8cfe35854b295317af" translate="yes" xml:space="preserve">
          <source>The minimum value along a given axis.</source>
          <target state="translated">与えられた軸に沿った最小値。</target>
        </trans-unit>
        <trans-unit id="7e0b0cb52a1bf19ef3e6bff0be136a12d77ae7e7" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, ignores NaNs.</source>
          <target state="translated">指定された軸に沿った配列の最小値で、NaNを無視します。</target>
        </trans-unit>
        <trans-unit id="d9e2b0a11e46ec4c3892cf8fdab488270aa4c95b" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, ignoring any NaNs.</source>
          <target state="translated">任意のNaNを無視した、指定された軸に沿った配列の最小値。</target>
        </trans-unit>
        <trans-unit id="77d53ae61484ff6af896adddf96d0d76b8331b4b" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, propagates NaNs.</source>
          <target state="translated">与えられた軸に沿った配列の最小値は、NaNを伝播する。</target>
        </trans-unit>
        <trans-unit id="f3f970ad0b31d892cafa6b5a21e637a9f0353aee" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, propagating any NaNs.</source>
          <target state="translated">任意のNaNを伝播する、与えられた軸に沿った配列の最小値。</target>
        </trans-unit>
        <trans-unit id="9ae224843f4578886c03cad9e1377c9c95d0f44e" translate="yes" xml:space="preserve">
          <source>The minimum value of an output element. Must be present to allow computation on empty slice. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">出力要素の最小値。空のスライスでの計算を可能にするために存在する必要があります。詳細については、&lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d437e19520a89179e90a54d1512529a938dad3c6" translate="yes" xml:space="preserve">
          <source>The mode should be one of:</source>
          <target state="translated">のいずれかのモードであること。</target>
        </trans-unit>
        <trans-unit id="2ec84546189af066d8b391b45bfecb14d0737c14" translate="yes" xml:space="preserve">
          <source>The modified Bessel function evaluated at each of the elements of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の各要素で評価された修正ベッセル関数。</target>
        </trans-unit>
        <trans-unit id="852847496df2ea03e82e7e539f1768f78993a6b8" translate="yes" xml:space="preserve">
          <source>The more common 2-parameter Weibull, including a scale parameter</source>
          <target state="translated">スケールパラメータを含む、より一般的な2パラメータのワイブル</target>
        </trans-unit>
        <trans-unit id="ec8c35dc12f2bc0af45e628c14f8329c8c69aba9" translate="yes" xml:space="preserve">
          <source>The most basic task that can be done with the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; is to visit every element of an array. Each element is provided one by one using the standard Python iterator interface.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;で実行できる最も基本的なタスクは、配列のすべての要素にアクセスすることです。各要素は、標準のPythonイテレータインターフェースを使用して1つずつ提供されます。</target>
        </trans-unit>
        <trans-unit id="d496ee7436ae1753a08460be49874cd0a97104de" translate="yes" xml:space="preserve">
          <source>The most basic way to create datetimes is from strings in ISO 8601 date or datetime format. The unit for internal storage is automatically selected from the form of the string, and can be either a &lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;date unit&lt;/a&gt; or a &lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;time unit&lt;/a&gt;. The date units are years (&amp;lsquo;Y&amp;rsquo;), months (&amp;lsquo;M&amp;rsquo;), weeks (&amp;lsquo;W&amp;rsquo;), and days (&amp;lsquo;D&amp;rsquo;), while the time units are hours (&amp;lsquo;h&amp;rsquo;), minutes (&amp;lsquo;m&amp;rsquo;), seconds (&amp;lsquo;s&amp;rsquo;), milliseconds (&amp;lsquo;ms&amp;rsquo;), and some additional SI-prefix seconds-based units.</source>
          <target state="translated">日時を作成する最も基本的な方法は、ISO 8601の日付または日時形式の文字列から作成することです。内部ストレージの単位は、文字列の形式から自動的に選択され、&lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;日付単位&lt;/a&gt;または&lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;時間単位の&lt;/a&gt;いずれかになります。日付の単位は年（ 'Y'）、月（ 'M'）、週（ 'W'）、日（ 'D'）であり、時間の単位は時間（ 'h'）、分（ 'm' ）、秒（ 's'）、ミリ秒（ 'ms'）、および追加のSIプレフィックス秒ベースの単位。</target>
        </trans-unit>
        <trans-unit id="66cbaf133a9d7fa2f2885d6f3bc9c4d230706591" translate="yes" xml:space="preserve">
          <source>The most common use of this function is to build a block matrix</source>
          <target state="translated">この関数の最も一般的な使用法は、ブロック行列を構築することです。</target>
        </trans-unit>
        <trans-unit id="9781573736aca31c85fa33ce77a1caad972dd370" translate="yes" xml:space="preserve">
          <source>The most negative power of the base (2) consistent with there being no leading 0&amp;rsquo;s in the mantissa.</source>
          <target state="translated">仮数部に先行ゼロがないことと一致する、基数の最も負の累乗（2）。</target>
        </trans-unit>
        <trans-unit id="fb15b7417ee56d15205cea48f990a823be057c87" translate="yes" xml:space="preserve">
          <source>The multidimensional histogram of sample x. See normed and weights for the different possible semantics.</source>
          <target state="translated">サンプル x の多次元ヒストグラム.</target>
        </trans-unit>
        <trans-unit id="8be5b73af053c4fe54ab6b95a4f36c70767b3576" translate="yes" xml:space="preserve">
          <source>The multinomial distribution is a multivariate generalization of the binomial distribution. Take an experiment with one of &lt;code&gt;p&lt;/code&gt; possible outcomes. An example of such an experiment is throwing a dice, where the outcome can be 1 through 6. Each sample drawn from the distribution represents &lt;code&gt;n&lt;/code&gt; such experiments. Its values, &lt;code&gt;X_i = [X_0, X_1, ..., X_p]&lt;/code&gt;, represent the number of times the outcome was &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">多項分布は、二項分布の多変量一般化です。 &lt;code&gt;p&lt;/code&gt; 可能な結果の1つを使って実験します。そのような実験の例は、サイコロを投げることであり、結果は1から6になります。分布から抽出された各サンプルは、そのような実験の &lt;code&gt;n&lt;/code&gt; を表します。その値 &lt;code&gt;X_i = [X_0, X_1, ..., X_p]&lt;/code&gt; は、結果が &lt;code&gt;i&lt;/code&gt; であった回数を表します。</target>
        </trans-unit>
        <trans-unit id="6e35df9de409e360898297beb49d42cda54d84d4" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Hermite polynomials in the form</source>
          <target state="translated">乗算は、エルミテ多項式の再帰関係を使用します。</target>
        </trans-unit>
        <trans-unit id="5d48b11de72371fe59540d3a1093cd7c7ef9026d" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Laguerre polynomials in the form</source>
          <target state="translated">乗算は、次の形式のラグエール多項式の再帰関係を使用します。</target>
        </trans-unit>
        <trans-unit id="1da9d21187f4507f9a0b400fa81210b7d7adb8cd" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Legendre polynomials in the form</source>
          <target state="translated">乗算は、レジェンドレ多項式の再帰関係を使用します。</target>
        </trans-unit>
        <trans-unit id="28fc83b7bf97d866e44dde49fafcb06224f49002" translate="yes" xml:space="preserve">
          <source>The multithreaded random number generator can be used to fill an array. The &lt;code&gt;values&lt;/code&gt; attributes shows the zero-value before the fill and the random value after.</source>
          <target state="translated">マルチスレッドの乱数ジェネレーターを使用して、配列を埋めることができます。 &lt;code&gt;values&lt;/code&gt; 塗りつぶしとした後、ランダムな値の前にゼロ値のショーを属性。</target>
        </trans-unit>
        <trans-unit id="4747005456762b666a88180df9655da6422f2a03" translate="yes" xml:space="preserve">
          <source>The multivariate normal, multinormal or Gaussian distribution is a generalization of the one-dimensional normal distribution to higher dimensions. Such a distribution is specified by its mean and covariance matrix. These parameters are analogous to the mean (average or &amp;ldquo;center&amp;rdquo;) and variance (standard deviation, or &amp;ldquo;width,&amp;rdquo; squared) of the one-dimensional normal distribution.</source>
          <target state="translated">多変量正規分布、多正規分布、またはガウス分布は、1次元の正規分布をより高い次元に一般化したものです。このような分布は、平均と共分散行列によって指定されます。これらのパラメーターは、1次元正規分布の平均（平均または「中心」）および分散（標準偏差、または「幅」の2乗）に類似しています。</target>
        </trans-unit>
        <trans-unit id="acd94e258d3a5164d9494ffb8bffe2f44669511c" translate="yes" xml:space="preserve">
          <source>The n-dimensional FFT.</source>
          <target state="translated">n次元FFTです。</target>
        </trans-unit>
        <trans-unit id="6c60f6d35e1563484077efd2da3ec7438c9b55d8" translate="yes" xml:space="preserve">
          <source>The n-dimensional array</source>
          <target state="translated">n次元配列</target>
        </trans-unit>
        <trans-unit id="3b220f6b818351a33b819aef741ffc069011f1f9" translate="yes" xml:space="preserve">
          <source>The n-dimensional inverse FFT.</source>
          <target state="translated">n次元の逆FFT。</target>
        </trans-unit>
        <trans-unit id="e1700cb4660502cb99b1ba6b83abc787863343a8" translate="yes" xml:space="preserve">
          <source>The n-th differences. The shape of the output is the same as &lt;code&gt;a&lt;/code&gt; except along &lt;code&gt;axis&lt;/code&gt; where the dimension is smaller by &lt;code&gt;n&lt;/code&gt;. The type of the output is the same as the type of the difference between any two elements of &lt;code&gt;a&lt;/code&gt;. This is the same as the type of &lt;code&gt;a&lt;/code&gt; in most cases. A notable exception is &lt;code&gt;datetime64&lt;/code&gt;, which results in a &lt;code&gt;timedelta64&lt;/code&gt; output array.</source>
          <target state="translated">n番目の違い。出力の形状は、次元が &lt;code&gt;n&lt;/code&gt; 小さい &lt;code&gt;axis&lt;/code&gt; に沿っ &lt;code&gt;a&lt;/code&gt; を除いて、と同じです。出力のタイプは、任意の2つの要素間の差のタイプと同じです。これは、ほとんどの場合、 &lt;code&gt;a&lt;/code&gt; のタイプと同じです。注目すべき例外は &lt;code&gt;datetime64&lt;/code&gt; で、これにより &lt;code&gt;timedelta64&lt;/code&gt; 出力配列が生成されます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0669ec99aeb2d5368091f67cb13b60ba81e67528" translate="yes" xml:space="preserve">
          <source>The name of an encoding</source>
          <target state="translated">エンコーディングの名前</target>
        </trans-unit>
        <trans-unit id="da19f645db8ba8aaf5c7216ec7214ec27975bb88" translate="yes" xml:space="preserve">
          <source>The name of each column, e.g. &lt;code&gt;('x', 'y', 'z')&lt;/code&gt;.</source>
          <target state="translated">各列の名前、例えば &lt;code&gt;('x', 'y', 'z')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9271935a282dc40ee28d57c245df327643e67b9" translate="yes" xml:space="preserve">
          <source>The name of the function comes from the acronym for &amp;lsquo;peak to peak&amp;rsquo;.</source>
          <target state="translated">関数の名前は「ピークツーピーク」の頭字語に由来します。</target>
        </trans-unit>
        <trans-unit id="bb2cb1a8dd236bcfb532f7c48c470cce2101b1ff" translate="yes" xml:space="preserve">
          <source>The name of the polynomial variable</source>
          <target state="translated">多項式変数の名前</target>
        </trans-unit>
        <trans-unit id="48bd936a95b9da34fbbddac207b9c61cefe6e361" translate="yes" xml:space="preserve">
          <source>The name of the ufunc.</source>
          <target state="translated">ufuncの名前です。</target>
        </trans-unit>
        <trans-unit id="8afcf394e9ae5bb9fa899425c9a8ba31df0dd746" translate="yes" xml:space="preserve">
          <source>The name sinc is short for &amp;ldquo;sine cardinal&amp;rdquo; or &amp;ldquo;sinus cardinalis&amp;rdquo;.</source>
          <target state="translated">sincという名前は、「sin cardinal」または「sinus cardinalis」の略です。</target>
        </trans-unit>
        <trans-unit id="429822cfcff1010e8a45d7946ea2696aeb70a3d1" translate="yes" xml:space="preserve">
          <source>The names are ordered according to increasing byte offset. This can be used, for example, to walk through all of the named fields in offset order.</source>
          <target state="translated">名前は、バイトオフセットの増加に応じて順序付けられます。これは、例えば、名前のついたすべてのフィールドをオフセット順にウォークスルーするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="d89404c184de8cb612b9ba60ba8159aea12d80ca" translate="yes" xml:space="preserve">
          <source>The names for the types in c code follows c naming conventions more closely. The Python names for these types follow Python conventions. Thus, &lt;a href=&quot;#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; picks up a 32-bit float in C, but &lt;code&gt;numpy.float_&lt;/code&gt; in Python corresponds to a 64-bit double. The bit-width names can be used in both Python and C for clarity.</source>
          <target state="translated">cコード内の型の名前は、cの命名規則に厳密に従います。これらのタイプのPython名はPythonの規則に従います。したがって、&lt;a href=&quot;#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; &lt;/a&gt;はCで32ビットのfloatを &lt;code&gt;numpy.float_&lt;/code&gt; しますが、Pythonのnumpy.float_は64ビットのdoubleに対応します。ビット幅の名前は、わかりやすくするためにPythonとCの両方で使用できます。</target>
        </trans-unit>
        <trans-unit id="be2b0c55353c6ed87f255a0400693d129089b164" translate="yes" xml:space="preserve">
          <source>The native NumPy indexing type is &lt;code&gt;intp&lt;/code&gt; and may differ from the default integer array type. &lt;code&gt;intp&lt;/code&gt; is the smallest data type sufficient to safely index any array; for advanced indexing it may be faster than other types.</source>
          <target state="translated">ネイティブのNumPyインデックスタイプは &lt;code&gt;intp&lt;/code&gt; であり、デフォルトの整数配列タイプと異なる場合があります。 &lt;code&gt;intp&lt;/code&gt; は、配列に安全にインデックスを付けるのに十分な最小のデータ型です。高度なインデックス作成では、他のタイプよりも高速になる場合があります。</target>
        </trans-unit>
        <trans-unit id="762cb1cca826c6e2247cb37d4810072af245272b" translate="yes" xml:space="preserve">
          <source>The natural log of the absolute value of the determinant.</source>
          <target state="translated">行列式の絶対値の自然対数。</target>
        </trans-unit>
        <trans-unit id="b3888cd1c7265c4b4a7bad4003632b69982812b1" translate="yes" xml:space="preserve">
          <source>The natural logarithm &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; is the inverse of the exponential function, so that &lt;code&gt;log(exp(x)) = x&lt;/code&gt;. The natural logarithm is logarithm in base &lt;a href=&quot;../constants#numpy.e&quot;&gt;&lt;code&gt;e&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">自然対数の&lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt;、指数関数の逆数となるように &lt;code&gt;log(exp(x)) = x&lt;/code&gt; 。自然対数は&lt;a href=&quot;../constants#numpy.e&quot;&gt; &lt;code&gt;e&lt;/code&gt; を&lt;/a&gt;底とする対数です。</target>
        </trans-unit>
        <trans-unit id="133131ae7b63a1c0b2c215fb536c3aee797a1a49" translate="yes" xml:space="preserve">
          <source>The natural logarithm of &lt;code&gt;x&lt;/code&gt;, element-wise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">要素ごとの &lt;code&gt;x&lt;/code&gt; の自然対数。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="79018bd215ed2a4de07a7be8acb4bd00eb575cb1" translate="yes" xml:space="preserve">
          <source>The nditer can no longer be iterated once either &lt;code&gt;close&lt;/code&gt; is called or its context is exited.</source>
          <target state="translated">&lt;code&gt;close&lt;/code&gt; が呼び出されるか、そのコンテキストが終了すると、nditerは反復できなくなります。</target>
        </trans-unit>
        <trans-unit id="fba110cc07d7918f904cb2219cd75774f5e101fe" translate="yes" xml:space="preserve">
          <source>The nditer will then yield writeable buffer arrays which you may modify. However, because the nditer must copy this buffer data back to the original array once iteration is finished, you must signal when the iteration is ended, by one of two methods. You may either:</source>
          <target state="translated">nditerは、書き込み可能なバッファ配列を生成し、これを変更することができます。ただし、 nditer は、 イテレーションが終了するとバッファデータを元の配列に戻さなければならないので、 イテレーションが終了したときには、 2 つの方法のいずれかで合図を送る必要があります。次のいずれかの方法をとることができます。</target>
        </trans-unit>
        <trans-unit id="36c9f1e0a0257851539d48df01a2ed2f053f22d7" translate="yes" xml:space="preserve">
          <source>The new array is formed from the data in the old array, repeated if necessary to fill out the required number of elements. The data are repeated in the order that they are stored in memory.</source>
          <target state="translated">新しい配列は、古い配列のデータから形成され、必要な要素数を埋めるために必要に応じて繰り返されます。データはメモリに格納されている順に繰り返されます。</target>
        </trans-unit>
        <trans-unit id="5d98e8d2c80f824b8ece662a9850103c0477cac7" translate="yes" xml:space="preserve">
          <source>The new infrastructure takes a different approach to producing random numbers from the &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; object. Random number generation is separated into two components, a bit generator and a random generator.</source>
          <target state="translated">新しいインフラストラクチャは、&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;オブジェクトから乱数を生成するための別のアプローチを採用しています。乱数生成は、ビットジェネレーターとランダムジェネレーターの2つのコンポーネントに分かれています。</target>
        </trans-unit>
        <trans-unit id="86aae80fcd76b7ce0d8ebf83a57b3d06b3426d61" translate="yes" xml:space="preserve">
          <source>The new keyword argument interface and &lt;code&gt;excluded&lt;/code&gt; argument support further degrades performance.</source>
          <target state="translated">新しいキーワード引数インターフェイスと &lt;code&gt;excluded&lt;/code&gt; 引数のサポートにより、パフォーマンスがさらに低下します。</target>
        </trans-unit>
        <trans-unit id="55a87f3b341973ae0ced92b1f1a3e3e7074aa9e8" translate="yes" xml:space="preserve">
          <source>The new shape should be compatible with the original shape. If an integer is supplied, then the result will be a 1-D array of that length.</source>
          <target state="translated">新しい形状は元の形状と互換性のあるものでなければなりません。整数が与えられた場合、結果はその長さの1次元配列となります。</target>
        </trans-unit>
        <trans-unit id="691ae079d9ba62e9263b39950b26bbea5ce21d52" translate="yes" xml:space="preserve">
          <source>The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.</source>
          <target state="translated">新しい形状は元の形状と互換性のあるものでなければなりません。整数であれば,結果はその長さの1次元配列となります.この場合,配列の長さと残りの次元から値が推測されます.</target>
        </trans-unit>
        <trans-unit id="5388ec77c34409cb3cbd101b8eec670a3d1a1fdf" translate="yes" xml:space="preserve">
          <source>The next 1 byte is an unsigned byte: the major version number of the file format, e.g. &lt;code&gt;\x01&lt;/code&gt;.</source>
          <target state="translated">次の1バイトは符号なしバイトです。たとえば、 &lt;code&gt;\x01&lt;/code&gt; などのファイル形式のメジャーバージョン番号です。</target>
        </trans-unit>
        <trans-unit id="728636cfde682c4ca8ef5825e1a61b87b60f117f" translate="yes" xml:space="preserve">
          <source>The next 1 byte is an unsigned byte: the minor version number of the file format, e.g. &lt;code&gt;\x00&lt;/code&gt;. Note: the version of the file format is not tied to the version of the numpy package.</source>
          <target state="translated">次の1バイトは符号なしバイトです：ファイル形式のマイナーバージョン番号（例： &lt;code&gt;\x00&lt;/code&gt; 。注：ファイル形式のバージョンは、numpyパッケージのバージョンに関連付けられていません。</target>
        </trans-unit>
        <trans-unit id="87a88c47d7bd9a05055f3613db15f890d4b10172" translate="yes" xml:space="preserve">
          <source>The next 2 bytes form a little-endian unsigned short int: the length of the header data HEADER_LEN.</source>
          <target state="translated">次の2バイトはリトルエンディアンの符号なしショートintを形成します:ヘッダデータの長さ HEADER_LEN.</target>
        </trans-unit>
        <trans-unit id="c0777c38aebc3061e6b58d63a6472bc19821f955" translate="yes" xml:space="preserve">
          <source>The next HEADER_LEN bytes form the header data describing the array&amp;rsquo;s format. It is an ASCII string which contains a Python literal expression of a dictionary. It is terminated by a newline (&lt;code&gt;\n&lt;/code&gt;) and padded with spaces (&lt;code&gt;\x20&lt;/code&gt;) to make the total of &lt;code&gt;len(magic string) + 2 + len(length) + HEADER_LEN&lt;/code&gt; be evenly divisible by 64 for alignment purposes.</source>
          <target state="translated">次のHEADER_LENバイトは、配列の形式を説明するヘッダーデータを形成します。これは、辞書のPythonリテラル式を含むASCII文字列です。改行（ &lt;code&gt;\n&lt;/code&gt; ）で終了し、スペース（ &lt;code&gt;\x20&lt;/code&gt; ）で埋めて、 &lt;code&gt;len(magic string) + 2 + len(length) + HEADER_LEN&lt;/code&gt; を64で割り切れるようにします。</target>
        </trans-unit>
        <trans-unit id="82fde05cc761629191474fcaee36452854b7c17c" translate="yes" xml:space="preserve">
          <source>The next representable values of &lt;code&gt;x1&lt;/code&gt; in the direction of &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x2&lt;/code&gt; の方向における &lt;code&gt;x1&lt;/code&gt; の次の表現可能な値。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="4935ecbe795efbe6b2d076bc80d266ef9b3d3b31" translate="yes" xml:space="preserve">
          <source>The next step depends on the type of index which was found. If all dimensions are indexed with an integer a scalar is returned or set. A single boolean indexing array will call specialized boolean functions. Indices containing an ellipsis or slice but no advanced indexing will always create a view into the old array by calculating the new strides and memory offset. This view can then either be returned or, for assignments, filled using &lt;code&gt;PyArray_CopyObject&lt;/code&gt;. Note that &lt;code&gt;PyArray_CopyObject&lt;/code&gt; may also be called on temporary arrays in other branches to support complicated assignments when the array is of object dtype.</source>
          <target state="translated">次のステップは、見つかったインデックスのタイプによって異なります。すべての次元に整数のインデックスが付けられている場合、スカラーが返されるか設定されます。単一のブールインデックス配列は、特殊なブール関数を呼び出します。省略記号またはスライスを含むが高度なインデックス付けを含まないインデックスは、新しいストライドとメモリオフセットを計算することにより、常に古い配列へのビューを作成します。次に、このビューを返すか、割り当ての場合は &lt;code&gt;PyArray_CopyObject&lt;/code&gt; を使用して埋めることができます。 &lt;code&gt;PyArray_CopyObject&lt;/code&gt; は、配列がオブジェクトdtypeの場合に、複雑な割り当てをサポートするために、他のブランチの一時配列でも呼び出される場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="bdf75a3a6e21cea0d77ec634980ca032f5eeb858" translate="yes" xml:space="preserve">
          <source>The next table presents the performance in percentage relative to values generated by the legacy generator, &lt;code&gt;RandomState(MT19937())&lt;/code&gt;. The overall performance was computed using a geometric mean.</source>
          <target state="translated">次の表は、レガシージェネレーター &lt;code&gt;RandomState(MT19937())&lt;/code&gt; によって生成された値に対するパフォーマンスをパーセンテージで示しています。全体的なパフォーマンスは、幾何平均を使用して計算されました。</target>
        </trans-unit>
        <trans-unit id="0153c9bc357a3afb289f46e1296cad96a6ebfe64" translate="yes" xml:space="preserve">
          <source>The noncentral</source>
          <target state="translated">非中央の</target>
        </trans-unit>
        <trans-unit id="007f1b9babda9d4c7b56259360ff2b4902c7689b" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">正規分布は自然界で頻繁に発生します。たとえば、それは多数の小さなランダムな外乱の影響を受けるサンプルの一般的に発生する分布を表し、それぞれに独自の固有の分布があります&lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="edcb775700a94ba4ed282cab54aed1dcf6bc2923" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">正規分布は自然界で頻繁に発生します。たとえば、それは多数の小さなランダムな外乱の影響を受けるサンプルの一般的に発生する分布を表し、それぞれに独自の固有の分布があります&lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="966686da674deab5a174046b2e8990436c2787f9" translate="yes" xml:space="preserve">
          <source>The normal, exponential and gamma generators use 256-step Ziggurat methods which are 2-10 times faster than NumPy&amp;rsquo;s default implementation in &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常、指数およびガンマジェネレーターは、256ステップのZigguratメソッドを使用します。これは、&lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; &lt;/a&gt;でのNumPyのデフォルト実装よりも2〜10倍高速です。</target>
        </trans-unit>
        <trans-unit id="725e48eaa30d1b2cbd58c002507d29063f93ce22" translate="yes" xml:space="preserve">
          <source>The normalized (unit &amp;ldquo;length&amp;rdquo;) eigenvectors, such that the column &lt;code&gt;v[:,i]&lt;/code&gt; is the eigenvector corresponding to the eigenvalue &lt;code&gt;w[i]&lt;/code&gt;.</source>
          <target state="translated">列 &lt;code&gt;v[:,i]&lt;/code&gt; が固有値 &lt;code&gt;w[i]&lt;/code&gt; 対応する固有ベクトルになるような、正規化された（単位「長さ」）固有ベクトル。</target>
        </trans-unit>
        <trans-unit id="4a2bc0ba793eb9bb3e0347a0cebea0eac0618ee5" translate="yes" xml:space="preserve">
          <source>The nuclear norm is the sum of the singular values.</source>
          <target state="translated">核ノルムは特異値の和である。</target>
        </trans-unit>
        <trans-unit id="fb33d48b0d271638a6f54e06bd5c7431683a4b77" translate="yes" xml:space="preserve">
          <source>The number 13 has the binaray representation &lt;code&gt;00001101&lt;/code&gt;. Likewise, 16 is represented by &lt;code&gt;00010000&lt;/code&gt;. The bit-wise OR of 13 and 16 is then &lt;code&gt;000111011&lt;/code&gt;, or 29:</source>
          <target state="translated">番号13は、ビナレイ表現 &lt;code&gt;00001101&lt;/code&gt; を持っています。同様に、16は &lt;code&gt;00010000&lt;/code&gt; で表されます。13と16のビット単位のORは &lt;code&gt;000111011&lt;/code&gt; または29になります。</target>
        </trans-unit>
        <trans-unit id="9301b88af54fb2d08827d44439e6252ad34f0666" translate="yes" xml:space="preserve">
          <source>The number 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. Likewise, 17 is represented by &lt;code&gt;00010001&lt;/code&gt;. The bit-wise AND of 13 and 17 is therefore &lt;code&gt;000000001&lt;/code&gt;, or 1:</source>
          <target state="translated">番号13は &lt;code&gt;00001101&lt;/code&gt; で表されます。同様に、17は &lt;code&gt;00010001&lt;/code&gt; で表されます。したがって、13と17のビット単位のANDは &lt;code&gt;000000001&lt;/code&gt; 、つまり1です。</target>
        </trans-unit>
        <trans-unit id="5dd5ca9f1bd4e589a273ee53560b9a52127f59e7" translate="yes" xml:space="preserve">
          <source>The number 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. Likewise, 17 is represented by &lt;code&gt;00010001&lt;/code&gt;. The bit-wise XOR of 13 and 17 is therefore &lt;code&gt;00011100&lt;/code&gt;, or 28:</source>
          <target state="translated">番号13は &lt;code&gt;00001101&lt;/code&gt; で表されます。同様に、17は &lt;code&gt;00010001&lt;/code&gt; で表されます。したがって、13と17のビット単位のXORは &lt;code&gt;00011100&lt;/code&gt; または28です。</target>
        </trans-unit>
        <trans-unit id="dafcbdde76f7395561c97c3255cdf449984b5af3" translate="yes" xml:space="preserve">
          <source>The number &lt;code&gt;w&lt;/code&gt; is an eigenvalue of &lt;code&gt;a&lt;/code&gt; if there exists a vector &lt;code&gt;v&lt;/code&gt; such that &lt;code&gt;dot(a,v) = w * v&lt;/code&gt;. Thus, the arrays &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;dot(a[:,:], v[:,i]) = w[i] * v[:,i]&lt;/code&gt; for</source>
          <target state="translated">&lt;code&gt;dot(a,v) = w * v&lt;/code&gt; ようなベクトル &lt;code&gt;v&lt;/code&gt; が存在する場合、数値 &lt;code&gt;w&lt;/code&gt; は &lt;code&gt;a&lt;/code&gt; の固有値です。したがって、配列 &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;w&lt;/code&gt; 、および &lt;code&gt;v&lt;/code&gt; は、式 &lt;code&gt;dot(a[:,:], v[:,i]) = w[i] * v[:,i]&lt;/code&gt; を満たし、</target>
        </trans-unit>
        <trans-unit id="1bb66b4a14636c387bd7dac27c6170702e129db5" translate="yes" xml:space="preserve">
          <source>The number of arguments.</source>
          <target state="translated">引数の数です。</target>
        </trans-unit>
        <trans-unit id="50f26fa4113f32c300038f926f58c5de950b657e" translate="yes" xml:space="preserve">
          <source>The number of arrays that need to be broadcast to the same shape.</source>
          <target state="translated">同じ形状にブロードキャストする必要がある配列の数。</target>
        </trans-unit>
        <trans-unit id="cd1c13079fc7462745575ad6cadd5c1655d5fd8f" translate="yes" xml:space="preserve">
          <source>The number of base units in a step.</source>
          <target state="translated">ステップの基本単位の数。</target>
        </trans-unit>
        <trans-unit id="ddeea3732f7461b0e4b46d4155abe0931176b591" translate="yes" xml:space="preserve">
          <source>The number of bins (of size 1) is one larger than the largest value in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;minlength&lt;/code&gt; is specified, there will be at least this number of bins in the output array (though it will be longer if necessary, depending on the contents of &lt;code&gt;x&lt;/code&gt;). Each bin gives the number of occurrences of its index value in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;weights&lt;/code&gt; is specified the input array is weighted by it, i.e. if a value &lt;code&gt;n&lt;/code&gt; is found at position &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;out[n] += weight[i]&lt;/code&gt; instead of &lt;code&gt;out[n] += 1&lt;/code&gt;.</source>
          <target state="translated">（サイズ1の）ビンの数は、 &lt;code&gt;x&lt;/code&gt; の最大値より1つ大きくなります。 &lt;code&gt;minlength&lt;/code&gt; が指定されている場合、出力配列には少なくともこの数のビンがあります（ただし、 &lt;code&gt;x&lt;/code&gt; の内容に応じて、必要に応じて長くなります）。各ビンは、 &lt;code&gt;x&lt;/code&gt; でのインデックス値の出現回数を示します。 &lt;code&gt;weights&lt;/code&gt; が指定されている場合、入力配列はそれによって重み付けされます。つまり、値 &lt;code&gt;n&lt;/code&gt; が位置 &lt;code&gt;i&lt;/code&gt; にある場合、 &lt;code&gt;out[n] += 1&lt;/code&gt; ではなく &lt;code&gt;out[n] += weight[i]&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="961981b3d06507afe179094c308682fa430fda0e" translate="yes" xml:space="preserve">
          <source>The number of bins for all dimensions (nx=ny=&amp;hellip;=bins).</source>
          <target state="translated">すべての次元のビンの数（nx = ny =&amp;hellip;= bins）。</target>
        </trans-unit>
        <trans-unit id="180a01cbfbe39044df94a38205c151e4055dfaef" translate="yes" xml:space="preserve">
          <source>The number of bins for each dimension (nx, ny, &amp;hellip; =bins)</source>
          <target state="translated">各次元のビンの数（nx、ny、&amp;hellip;= bins）</target>
        </trans-unit>
        <trans-unit id="ef8032cee94538f0c3d6bbb995bbf06ce4b1a135" translate="yes" xml:space="preserve">
          <source>The number of bins is only proportional to cube root of &lt;code&gt;a.size&lt;/code&gt;. It tends to overestimate the number of bins and it does not take into account data variability.</source>
          <target state="translated">ビンの数は、 &lt;code&gt;a.size&lt;/code&gt; の立方根にのみ比例します。ビンの数を過大評価する傾向があり、データの変動性は考慮されません。</target>
        </trans-unit>
        <trans-unit id="3c7ac04dd9e94e09e580f7718e7797190217f2db" translate="yes" xml:space="preserve">
          <source>The number of bins is the base 2 log of &lt;code&gt;a.size&lt;/code&gt;. This estimator assumes normality of data and is too conservative for larger, non-normal datasets. This is the default method in R&amp;rsquo;s &lt;code&gt;hist&lt;/code&gt; method.</source>
          <target state="translated">ビンの数は、 &lt;code&gt;a.size&lt;/code&gt; の 2を底とする対数です。この推定量はデータの正規性を想定しており、大規模で非正規のデータセットには保守的すぎます。これは、Rの &lt;code&gt;hist&lt;/code&gt; メソッドのデフォルトのメソッドです。</target>
        </trans-unit>
        <trans-unit id="ec49cbff29de9e7b90f0c2a06cd3039e0f213a48" translate="yes" xml:space="preserve">
          <source>The number of bits in the exponent including its sign and bias.</source>
          <target state="translated">指数の符号と偏りを含めたビット数。</target>
        </trans-unit>
        <trans-unit id="ffbebedcdf5bf4f1593520cffb80749e6f34262c" translate="yes" xml:space="preserve">
          <source>The number of bits in the exponent portion of the floating point representation.</source>
          <target state="translated">浮動小数点表現の指数部分のビット数。</target>
        </trans-unit>
        <trans-unit id="96302b58629afe268f2042e560d43721a3fc2867" translate="yes" xml:space="preserve">
          <source>The number of bits in the mantissa.</source>
          <target state="translated">マンティッサのビット数です。</target>
        </trans-unit>
        <trans-unit id="792cc1a58f0a3a46d19118877b6d13c493cb98ec" translate="yes" xml:space="preserve">
          <source>The number of bits occupied by the type.</source>
          <target state="translated">型が占有するビット数。</target>
        </trans-unit>
        <trans-unit id="b307f502028d1a8e478a9e28dfcf2d36c5fe0bca" translate="yes" xml:space="preserve">
          <source>The number of bits required to generate a simulated value differs from the number of bits generated by the underlying RNG. For example, two 16-bit integer values can be simulated from a single draw of a 32-bit RNG.</source>
          <target state="translated">シミュレートされた値を生成するのに必要なビット数は、基礎となるRNGで生成されるビット数とは異なります。例えば、32ビットのRNGの1回の描画から2つの16ビットの整数値をシミュレートすることができます。</target>
        </trans-unit>
        <trans-unit id="c523c9c933fe391fb48ef56ebd3c154a68738ed9" translate="yes" xml:space="preserve">
          <source>The number of bytes each item in the array requires.</source>
          <target state="translated">配列の各項目が必要とするバイト数。</target>
        </trans-unit>
        <trans-unit id="accc8d694cc26b9e63438cb6cbca5878ebb2f8ff" translate="yes" xml:space="preserve">
          <source>The number of bytes into the field at which to place &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; を配置するフィールドへのバイト数。</target>
        </trans-unit>
        <trans-unit id="a1bc94a2ea241fcb184442f81754fe01e618cf6a" translate="yes" xml:space="preserve">
          <source>The number of characters per line for the purpose of inserting line breaks (default 75).</source>
          <target state="translated">改行を挿入するための1行あたりの文字数(デフォルトは75)。</target>
        </trans-unit>
        <trans-unit id="e62a5487dfe8294b0662475991a8ef49d96aaa30" translate="yes" xml:space="preserve">
          <source>The number of children already spawned. Only pass this if reconstructing a &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; from a serialized form.</source>
          <target state="translated">すでにスポーンされている子の数。シリアル化されたフォームから&lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;を再構築する場合にのみこれを渡します。</target>
        </trans-unit>
        <trans-unit id="51818f09691484990d73679da97e27bd0b748a81" translate="yes" xml:space="preserve">
          <source>The number of dimensions and the size of each dimension</source>
          <target state="translated">寸法の数と各寸法の大きさは</target>
        </trans-unit>
        <trans-unit id="20f7440820740cd73bd8bc73940f9eb0da1ec572" translate="yes" xml:space="preserve">
          <source>The number of dimensions in the array.</source>
          <target state="translated">配列の次元数。</target>
        </trans-unit>
        <trans-unit id="d4b953d2df6296d252217619c918790078f1f070" translate="yes" xml:space="preserve">
          <source>The number of dimensions in the broadcasted result.</source>
          <target state="translated">ブロードキャストされた結果の次元数。</target>
        </trans-unit>
        <trans-unit id="16045283fd37589fa60a5d2a0d49dd57ac83ac40" translate="yes" xml:space="preserve">
          <source>The number of dimensions.</source>
          <target state="translated">寸法の数です。</target>
        </trans-unit>
        <trans-unit id="3a0a0191ab6889929bc691e4ea5f7b01d6f77c2e" translate="yes" xml:space="preserve">
          <source>The number of elements to unpack along &lt;code&gt;axis&lt;/code&gt;, provided as a way of undoing the effect of packing a size that is not a multiple of eight. A non-negative number means to only unpack &lt;code&gt;count&lt;/code&gt; bits. A negative number means to trim off that many bits from the end. &lt;code&gt;None&lt;/code&gt; means to unpack the entire array (the default). Counts larger than the available number of bits will add zero padding to the output. Negative counts must not exceed the available number of bits.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; に沿ってアンパックする要素の数。8の倍数ではないサイズのパッキングの効果を元に戻す方法として提供されます。負でない数は、 &lt;code&gt;count&lt;/code&gt; ビットのみをアンパックすることを意味します。負の数は、最後からその数のビットを切り捨てることを意味します。 &lt;code&gt;None&lt;/code&gt; は、アレイ全体をアンパックすることを意味します（デフォルト）。利用可能なビット数よりも大きいカウントは、出力にゼロパディングを追加します。負の数は、使用可能なビット数を超えてはなりません。</target>
        </trans-unit>
        <trans-unit id="9762b9c4461b4320b651627cdc827d526c1d8a36" translate="yes" xml:space="preserve">
          <source>The number of floating-point types</source>
          <target state="translated">浮動小数点型の数</target>
        </trans-unit>
        <trans-unit id="5f79b76db3c0063c4dbecc42a7851ca0e7d61297" translate="yes" xml:space="preserve">
          <source>The number of input arguments.</source>
          <target state="translated">入力引数の数です。</target>
        </trans-unit>
        <trans-unit id="5f16430ff4bbbb029090f84ca5392fa4a978dcbf" translate="yes" xml:space="preserve">
          <source>The number of inputs.</source>
          <target state="translated">入力数です。</target>
        </trans-unit>
        <trans-unit id="ad3ac53999da2a535168ea7e917e83fb83c41419" translate="yes" xml:space="preserve">
          <source>The number of integrations to perform.</source>
          <target state="translated">実行する統合の数。</target>
        </trans-unit>
        <trans-unit id="fb27416d0d8fd4a79bebfa578ec630568a0908f0" translate="yes" xml:space="preserve">
          <source>The number of items to read from &lt;em&gt;iterable&lt;/em&gt;. The default is -1, which means all data is read.</source>
          <target state="translated">&lt;em&gt;イテラブル&lt;/em&gt;から読み取るアイテムの数。デフォルトは-1で、すべてのデータが読み取られることを意味します。</target>
        </trans-unit>
        <trans-unit id="59d7f6376949b026c4f59178cb450cda4e03c50d" translate="yes" xml:space="preserve">
          <source>The number of iterator operands.</source>
          <target state="translated">イテレータのオペランドの数。</target>
        </trans-unit>
        <trans-unit id="906dbe82e1bcf21f6f38450b28f60987840c67b3" translate="yes" xml:space="preserve">
          <source>The number of lines to skip at the beginning of the file.</source>
          <target state="translated">ファイルの先頭でスキップする行数を指定します。</target>
        </trans-unit>
        <trans-unit id="1f9e5bb5bb6065f40b3b5f1acf92ad15826aa414" translate="yes" xml:space="preserve">
          <source>The number of lines to skip at the end of the file.</source>
          <target state="translated">ファイルの最後にスキップする行数を指定します。</target>
        </trans-unit>
        <trans-unit id="36ce98d71e68fb1757547c834a0c7900df88883d" translate="yes" xml:space="preserve">
          <source>The number of numerical NumPy types - of which there are 18 total - on which the ufunc can operate.</source>
          <target state="translated">ufuncが操作可能なNumPyの数値型の数(全部で18個)。</target>
        </trans-unit>
        <trans-unit id="9d9f649df57a2efc7c5d1837c8cce03f4ddffe4d" translate="yes" xml:space="preserve">
          <source>The number of objects returned by &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; によって返されるオブジェクトの数。</target>
        </trans-unit>
        <trans-unit id="cd1491ebeebfc5761455718746328a874537820d" translate="yes" xml:space="preserve">
          <source>The number of output arguments.</source>
          <target state="translated">出力引数の数を指定します。</target>
        </trans-unit>
        <trans-unit id="bb79176b795c17c39b28af054f09df09e008175b" translate="yes" xml:space="preserve">
          <source>The number of outputs.</source>
          <target state="translated">出力数です。</target>
        </trans-unit>
        <trans-unit id="1f9d3b6c33190d8820407a65c8dfbe71f2fb41db" translate="yes" xml:space="preserve">
          <source>The number of periods &lt;code&gt;nper&lt;/code&gt; is computed by solving the equation:</source>
          <target state="translated">&lt;code&gt;nper&lt;/code&gt; の期間数は、次の方程式を解くことによって計算されます。</target>
        </trans-unit>
        <trans-unit id="9f00991307aeed3ff212ec1f19aa64c4d4a70887" translate="yes" xml:space="preserve">
          <source>The number of places by which elements are shifted. If a tuple, then &lt;code&gt;axis&lt;/code&gt; must be a tuple of the same size, and each of the given axes is shifted by the corresponding number. If an int while &lt;code&gt;axis&lt;/code&gt; is a tuple of ints, then the same value is used for all given axes.</source>
          <target state="translated">要素がシフトされる場所の数。タプルの場合、 &lt;code&gt;axis&lt;/code&gt; は同じサイズのタプルでなければならず、指定された各軸は対応する数だけシフトされます。一方INT場合 &lt;code&gt;axis&lt;/code&gt; intのタプルであり、同じ値が、すべての所与の軸のために使用されます。</target>
        </trans-unit>
        <trans-unit id="1c87f40038faffc87024cc0b95bb28f19f5ea872" translate="yes" xml:space="preserve">
          <source>The number of repetitions for each element. &lt;code&gt;repeats&lt;/code&gt; is broadcasted to fit the shape of the given axis.</source>
          <target state="translated">各要素の繰り返し数。 &lt;code&gt;repeats&lt;/code&gt; は、指定された軸の形状に合わせてブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="4fedda7271f10f5b28b1a15e8ad961405e48dbc3" translate="yes" xml:space="preserve">
          <source>The number of repetitions of &lt;code&gt;A&lt;/code&gt; along each axis.</source>
          <target state="translated">各軸に沿った &lt;code&gt;A&lt;/code&gt; の繰り返し数。</target>
        </trans-unit>
        <trans-unit id="1e0a0e5cb024809c54b4083f3e0a5bc9d1d9a145" translate="yes" xml:space="preserve">
          <source>The number of supported data types for the ufunc. This number specifies how many different 1-d loops (of the builtin data types) are available.</source>
          <target state="translated">ufuncでサポートされているデータ型の数。この数は、(組み込みのデータ型の)1-dループの数を指定します。</target>
        </trans-unit>
        <trans-unit id="d384dcdb010cb83d633476edabf26a7cd5dcb98d" translate="yes" xml:space="preserve">
          <source>The number of times &lt;code&gt;a&lt;/code&gt; is repeated along the first and second axes.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; が第1軸と第2軸に沿って繰り返される回数。</target>
        </trans-unit>
        <trans-unit id="84ea540c48d087fa8db5ec94e472c5f5f973f2f5" translate="yes" xml:space="preserve">
          <source>The number of times each of the unique values comes up in the original array. Only provided if &lt;code&gt;return_counts&lt;/code&gt; is True.</source>
          <target state="translated">一意の値のそれぞれが元の配列に出現する回数。 &lt;code&gt;return_counts&lt;/code&gt; がTrueの場合にのみ提供されます。</target>
        </trans-unit>
        <trans-unit id="27ba063589e5e81b80624f4103b1f5b28059f11a" translate="yes" xml:space="preserve">
          <source>The number of times values are differenced. If zero, the input is returned as-is.</source>
          <target state="translated">値が異なる回数を指定します。ゼロの場合、入力はそのまま返されます。</target>
        </trans-unit>
        <trans-unit id="9f0b88f6fb636dd892bff0b33b009c20d79ffb03" translate="yes" xml:space="preserve">
          <source>The number of types.</source>
          <target state="translated">種類の数です。</target>
        </trans-unit>
        <trans-unit id="8a67e415f6489cfd59cc7656bd025411ca29912b" translate="yes" xml:space="preserve">
          <source>The numpy array shares the memory with the ctypes object.</source>
          <target state="translated">numpy配列はctypesオブジェクトとメモリを共有します。</target>
        </trans-unit>
        <trans-unit id="d790ce3a56f19101368186a47de94f2e3aed2abb" translate="yes" xml:space="preserve">
          <source>The numpy core math library (&amp;lsquo;npymath&amp;rsquo;) is a first step in this direction. This library contains most math-related C99 functionality, which can be used on platforms where C99 is not well supported. The core math functions have the same API as the C99 ones, except for the npy_* prefix.</source>
          <target state="translated">numpyコア数学ライブラリ（ 'npymath'）は、この方向への最初のステップです。このライブラリには、ほとんどの数学関連のC99機能が含まれており、C99が十分にサポートされていないプラットフォームで使用できます。コア数学関数は、npy_ *接頭辞を除いて、C99のものと同じAPIを持っています。</target>
        </trans-unit>
        <trans-unit id="d91b51f2620c8e0f1fabe752803d49bce22176fb" translate="yes" xml:space="preserve">
          <source>The numpy.ma module</source>
          <target state="translated">numpy.ma モジュール</target>
        </trans-unit>
        <trans-unit id="a12e93df39508259f846e57ebebd07dec5405cd4" translate="yes" xml:space="preserve">
          <source>The object of which the type is returned.</source>
          <target state="translated">型が返されるオブジェクト。</target>
        </trans-unit>
        <trans-unit id="892e730df208b39897e2c0d1b1cca7fbb8ae1420" translate="yes" xml:space="preserve">
          <source>The object to be converted to a type-and-requirement-satisfying array.</source>
          <target state="translated">型と要求を満たす配列に変換されるオブジェクト。</target>
        </trans-unit>
        <trans-unit id="bfbfb146acae6cf5d1e2df4b8b0cf4b046d06226" translate="yes" xml:space="preserve">
          <source>The object to check.</source>
          <target state="translated">チェックするオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="0f3ea496874fb4613c3a9be9c6a176f4f24c9e54" translate="yes" xml:space="preserve">
          <source>The object to iterate over.</source>
          <target state="translated">反復処理を行うオブジェクト。</target>
        </trans-unit>
        <trans-unit id="45971228cf20d163b0ca1b27e71b0f9a03bee868" translate="yes" xml:space="preserve">
          <source>The object type is also special because an array containing &lt;code&gt;object_&lt;/code&gt; items does not return an &lt;code&gt;object_&lt;/code&gt; object on item access, but instead returns the actual object that the array item refers to.</source>
          <target state="translated">&lt;code&gt;object_&lt;/code&gt; items を含む配列は、アイテムアクセス時に &lt;code&gt;object_&lt;/code&gt; オブジェクトを返さず、代わりに配列itemが参照する実際のオブジェクトを返すため、オブジェクトタイプも特別です。</target>
        </trans-unit>
        <trans-unit id="74fb22be6dfa85b139cc4a823d71b842fbca772d" translate="yes" xml:space="preserve">
          <source>The object which calculated these parameters and holds more detailed information.</source>
          <target state="translated">これらのパラメータを計算し、より詳細な情報を保持しているオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="29b86a58a4365210dddb9297096eac1156c7d098" translate="yes" xml:space="preserve">
          <source>The offset (in bytes) from the file&amp;rsquo;s current position. Defaults to 0. Only permitted for binary files.</source>
          <target state="translated">ファイルの現在位置からのオフセット（バイト単位）。デフォルトは0です。バイナリファイルに対してのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="93c773e560e0498af231d1a157163977066e3d8a" translate="yes" xml:space="preserve">
          <source>The old error handler.</source>
          <target state="translated">古いエラーハンドラです。</target>
        </trans-unit>
        <trans-unit id="1ec4554bb191ce258f048e411e4e87d29267fb91" translate="yes" xml:space="preserve">
          <source>The old iterator API includes functions like PyArrayIter_Check, PyArray_Iter* and PyArray_ITER_*. The multi-iterator array includes PyArray_MultiIter*, PyArray_Broadcast, and PyArray_RemoveSmallest. The new iterator design replaces all of this functionality with a single object and associated API. One goal of the new API is that all uses of the existing iterator should be replaceable with the new iterator without significant effort. In 1.6, the major exception to this is the neighborhood iterator, which does not have corresponding features in this iterator.</source>
          <target state="translated">古いイテレータAPIには、PyArrayIter_Check、PyArray_Iter*、PyArray_ITER_*のような関数が含まれています。マルチイテレータ配列には、PyArray_MultiIter*、PyArray_Broadcast、およびPyArray_RemoveSmallestが含まれています。新しいイテレータのデザインは、これらの機能をすべて単一のオブジェクトと関連するAPIで置き換えます。新しいAPIの目標の1つは、既存のイテレータのすべての使用は、大きな労力をかけずに新しいイテレータで置き換えることができるということです。1.6では、これに対応する主要な例外は近傍イテレータであり、このイテレータには対応する機能がありません。</target>
        </trans-unit>
        <trans-unit id="5bba457e9d70db346759d26e013499c6bff97b55" translate="yes" xml:space="preserve">
          <source>The one-dimensional (forward) FFT, of which &lt;a href=&quot;#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt; is the inverse</source>
          <target state="translated">1次元（フォワード）FFT、その&lt;a href=&quot;#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt;はその逆</target>
        </trans-unit>
        <trans-unit id="b13835d03a9daf8c507b45bfab105cd08fae35d5" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of general (complex) input.</source>
          <target state="translated">一般的な(複素)入力の一次元FFT。</target>
        </trans-unit>
        <trans-unit id="0cd037d8b0e459e2ea7f7abda9a2074a96ea80a2" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of real input, of which &lt;a href=&quot;#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; is inverse.</source>
          <target state="translated">実数入力の1次元&lt;a href=&quot;#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt;は逆です。</target>
        </trans-unit>
        <trans-unit id="9fbd4ce083fd828af7518629c69fc1b51be085ea" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of real input.</source>
          <target state="translated">実数入力の一次元FFT。</target>
        </trans-unit>
        <trans-unit id="5c18581fbbf72b4741168098a1d9545410236f6d" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT, with definitions and conventions used.</source>
          <target state="translated">一次元FFTの定義と使用される慣例を示します。</target>
        </trans-unit>
        <trans-unit id="cb7777bd048622e7012600d71666f63fa7ceb74f" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT.</source>
          <target state="translated">一次元FFTです。</target>
        </trans-unit>
        <trans-unit id="225306f7f184d0b92b85104fd4b6b278cc44c9a3" translate="yes" xml:space="preserve">
          <source>The one-dimensional inverse FFT.</source>
          <target state="translated">一次元逆FFT。</target>
        </trans-unit>
        <trans-unit id="df0b92ea232e6d8dccfcd905588f89bc51445e3a" translate="yes" xml:space="preserve">
          <source>The operands of some operation whose result type is needed.</source>
          <target state="translated">結果の型が必要な操作のオペランド。</target>
        </trans-unit>
        <trans-unit id="10e5b80590b5efbd493758bd757a312d4d78c228" translate="yes" xml:space="preserve">
          <source>The operation in the inner loop is a straightforward multiplication. Everything to do with the outer product is handled by the iterator setup.</source>
          <target state="translated">内側のループでの操作は単純な乗算です。外積に関するすべての処理はイテレータの設定によって行われます。</target>
        </trans-unit>
        <trans-unit id="94b62b6ba781a5ddd569b811fe572b78fe805c1d" translate="yes" xml:space="preserve">
          <source>The optional output arguments can be used to help you save memory for large calculations. If your arrays are large, complicated expressions can take longer than absolutely necessary due to the creation and (later) destruction of temporary calculation spaces. For example, the expression &lt;code&gt;G = a * b + c&lt;/code&gt; is equivalent to &lt;code&gt;t1 = A * B; G = T1 + C; del t1&lt;/code&gt;. It will be more quickly executed as &lt;code&gt;G = A * B; add(G, C, G)&lt;/code&gt; which is the same as &lt;code&gt;G = A * B; G += C&lt;/code&gt;.</source>
          <target state="translated">オプションの出力引数を使用すると、大規模な計算でメモリを節約できます。配列が大きい場合、一時的な計算スペースの作成と（後で）破棄が原因で、複雑な式は絶対に必要な時間より長くかかることがあります。たとえば、式 &lt;code&gt;G = a * b + c&lt;/code&gt; は &lt;code&gt;t1 = A * B; G = T1 + C; del t1&lt;/code&gt; と同等です。G = T1 + C; デルt1。 &lt;code&gt;G = A * B; add(G, C, G)&lt;/code&gt; ように、より速く実行されます。add（G、C、G）これは &lt;code&gt;G = A * B; G += C&lt;/code&gt; と同じです。G + = C。</target>
        </trans-unit>
        <trans-unit id="7b2c78f4cc1b5de9c0c210654a3400e8183ebd83" translate="yes" xml:space="preserve">
          <source>The optional third element &lt;em&gt;field_shape&lt;/em&gt; contains the shape if this field represents an array of the data-type in the second element. Note that a 3-tuple with a third argument equal to 1 is equivalent to a 2-tuple.</source>
          <target state="translated">このフィールドが2番目の要素のデータ型の配列を表す場合、オプションの3番目の要素&lt;em&gt;field_shape&lt;/em&gt;には形状が含まれます。3番目の引数が1の3タプルは2タプルと同等であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="14b215bf63d4b571de67dcde3ac908fb35772330" translate="yes" xml:space="preserve">
          <source>The options &amp;lsquo;reduced&amp;rsquo;, &amp;lsquo;complete, and &amp;lsquo;raw&amp;rsquo; are new in numpy 1.8, see the notes for more information. The default is &amp;lsquo;reduced&amp;rsquo;, and to maintain backward compatibility with earlier versions of numpy both it and the old default &amp;lsquo;full&amp;rsquo; can be omitted. Note that array h returned in &amp;lsquo;raw&amp;rsquo; mode is transposed for calling Fortran. The &amp;lsquo;economic&amp;rsquo; mode is deprecated. The modes &amp;lsquo;full&amp;rsquo; and &amp;lsquo;economic&amp;rsquo; may be passed using only the first letter for backwards compatibility, but all others must be spelled out. See the Notes for more explanation.</source>
          <target state="translated">オプション 'reduced'、 'complete、' raw 'はnumpy 1.8で新しく追加されました。詳細についてはノートを参照してください。デフォルトは 'reduced'であり、以前のバージョンのnumpyとの下位互換性を維持するために、それと古いデフォルトの 'full'の両方を省略できます。「raw」モードで返された配列hは、Fortranを呼び出すために転置されることに注意してください。'economic'モードは非推奨です。下位互換性のために、「full」モードと「economic」モードは最初の文字のみを使用して渡すことができますが、他のすべてのモードは入力する必要があります。詳細については、注を参照してください。</target>
        </trans-unit>
        <trans-unit id="6d9b2da0a0a7c1206d894d6f0fcce902e86c7458" translate="yes" xml:space="preserve">
          <source>The order in which the array data is stored in memory: &amp;lsquo;C&amp;rsquo; -&amp;gt; &amp;ldquo;row major&amp;rdquo; order (the default), &amp;lsquo;F&amp;rsquo; -&amp;gt; &amp;ldquo;column major&amp;rdquo; (Fortran) order.</source>
          <target state="translated">配列データがメモリに格納される順序： 'C'-&amp;gt;「行優先」順序（デフォルト）、「F」-&amp;gt;「列優先」（Fortran）順序。</target>
        </trans-unit>
        <trans-unit id="e18fbd568fd064406da176fc5bb0b9a80dc8baa0" translate="yes" xml:space="preserve">
          <source>The order of &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; doesn&amp;rsquo;t matter.</source>
          <target state="translated">&lt;code&gt;v1&lt;/code&gt; と &lt;code&gt;v2&lt;/code&gt; の順序は関係ありません。</target>
        </trans-unit>
        <trans-unit id="1a665b347299d28c9a4225cbaa35961f7257fdf3" translate="yes" xml:space="preserve">
          <source>The order of the input bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011 =&amp;gt; ``, 'little' will
reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="translated">入力ビットの順序。'big'はbin（val）を模倣し、 &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011 =&amp;gt; ``, 'little' will reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt; 。デフォルトは「big」です。</target>
        </trans-unit>
        <trans-unit id="c023a0582544690f15510a2492956e0e66cdc058" translate="yes" xml:space="preserve">
          <source>The order of the returned bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;3 = 0b00000011 =&amp;gt; [0, 0, 0, 0, 0, 0, 1, 1]&lt;/code&gt;, &amp;lsquo;little&amp;rsquo; will reverse the order to &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0]&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="translated">返されるビットの順序。'big'はbin（val）を模倣します、 &lt;code&gt;3 = 0b00000011 =&amp;gt; [0, 0, 0, 0, 0, 0, 1, 1]&lt;/code&gt; 、 'little'は[1、1、0、0 &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0]&lt;/code&gt; 。デフォルトは「big」です。</target>
        </trans-unit>
        <trans-unit id="d31a5b9999b59b34b6ad9fdaccda217e19238ad4" translate="yes" xml:space="preserve">
          <source>The order or degree of the polynomial</source>
          <target state="translated">多項式の次数または次数</target>
        </trans-unit>
        <trans-unit id="eea06a8f88d6f17386cd112eab18c7ac9fc8e799" translate="yes" xml:space="preserve">
          <source>The orientation of &lt;code&gt;c&lt;/code&gt; can be changed using the &lt;code&gt;axisc&lt;/code&gt; keyword.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; の方向は、 &lt;code&gt;axisc&lt;/code&gt; キーワードを使用して変更できます。</target>
        </trans-unit>
        <trans-unit id="5b2e34a61895054c86583de1c9f28efb1bf046c4" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;coef&lt;/code&gt; attribute.</source>
          <target state="translated">他のクラスには &lt;code&gt;coef&lt;/code&gt; 属性が必要です。</target>
        </trans-unit>
        <trans-unit id="beffd1aec86565c0ed7e85fa9756b03e99dc1093" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;domain&lt;/code&gt; attribute.</source>
          <target state="translated">他のクラスには &lt;code&gt;domain&lt;/code&gt; 属性が必要です。</target>
        </trans-unit>
        <trans-unit id="c7b5b660115b8d1bff6ffdc35071c1bc977b44f5" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;window&lt;/code&gt; attribute.</source>
          <target state="translated">他のクラスには &lt;code&gt;window&lt;/code&gt; 属性が必要です。</target>
        </trans-unit>
        <trans-unit id="208270eb05b02b535197d000879d544f3abebcde" translate="yes" xml:space="preserve">
          <source>The out argument specifies where to place the result. If out is NULL, then the output array is created, otherwise the output is placed in out which must be the correct size and type. A new reference to the output array is always returned even when out is not NULL. The caller of the routine has the responsibility to &lt;code&gt;DECREF&lt;/code&gt; out if not NULL or a memory-leak will occur.</source>
          <target state="translated">out引数は、結果を配置する場所を指定します。 outがNULLの場合、出力配列が作成されます。それ以外の場合、出力はoutに配置され、正しいサイズとタイプでなければなりません。出力配列への新しい参照は、outがNULLでない場合でも常に返されます。ルーチンの呼び出し元は、NULLでないかメモリリークが発生した場合に &lt;code&gt;DECREF&lt;/code&gt; を実行する責任があります。</target>
        </trans-unit>
        <trans-unit id="d41934f2889307f51eefc25e7532b745714248c8" translate="yes" xml:space="preserve">
          <source>The outer product</source>
          <target state="translated">外装品</target>
        </trans-unit>
        <trans-unit id="eaacd893fa91168722bb422e1bd4cfd1660e87de" translate="yes" xml:space="preserve">
          <source>The output arguments (if any) are then processed and any missing return arrays are constructed. If any provided output array doesn&amp;rsquo;t have the correct type (or is mis-aligned) and is smaller than the buffer size, then a new output array is constructed with the special &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag set. At the end of the function, &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called so that its contents will be copied back into the output array. Iterators for the output arguments are then processed.</source>
          <target state="translated">次に、出力引数（存在する場合）が処理され、欠落している戻り配列が作成されます。提供された出力配列が正しいタイプを持たない（または整列が間違っている）場合、バッファーサイズよりも小さい場合、新しい出力配列は特別な &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; フラグセットで構築されます。関数の最後で&lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;が呼び出され、その内容が出力配列にコピーされます。次に、出力引数の反復子が処理されます。</target>
        </trans-unit>
        <trans-unit id="f268497aae1cce8ff8c25da79f231196a245eaac" translate="yes" xml:space="preserve">
          <source>The output array is masked where all the values along the given axis are masked: if the output would have been a scalar and that all the values are masked, then the output is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">出力配列はマスクされ、指定された軸に沿ったすべての値がマスク&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;ます。出力がスカラーであり、すべての値がマスクされている場合、出力はマスクされます。</target>
        </trans-unit>
        <trans-unit id="f55976ddc6094b99d81ee9f07a8be602a3926550" translate="yes" xml:space="preserve">
          <source>The output array, containing the part of the content of &lt;code&gt;file&lt;/code&gt; that was matched by &lt;code&gt;regexp&lt;/code&gt;. &lt;code&gt;output&lt;/code&gt; is always a structured array.</source>
          <target state="translated">&lt;code&gt;regexp&lt;/code&gt; で一致した &lt;code&gt;file&lt;/code&gt; のコンテンツの一部を含む出力配列。 &lt;code&gt;output&lt;/code&gt; は常に構造化配列です。</target>
        </trans-unit>
        <trans-unit id="5aa2c29b27cf9fdf4a29996c1b8c28730e8e0aea" translate="yes" xml:space="preserve">
          <source>The output array, element-wise Heaviside step function of &lt;code&gt;x1&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; の要素ごとのヘビサイドステップ関数の出力配列。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="70719ba0effebe3bb3aa417f56a4a6c01822a6e7" translate="yes" xml:space="preserve">
          <source>The output array.</source>
          <target state="translated">出力配列です。</target>
        </trans-unit>
        <trans-unit id="09c7e58e3fd89577e8de606a001975293d749592" translate="yes" xml:space="preserve">
          <source>The output array. The number of dimensions is the same as &lt;code&gt;a&lt;/code&gt;, but the shape can be different. This depends on whether &lt;code&gt;func&lt;/code&gt; changes the shape of its output with respect to its input.</source>
          <target state="translated">出力配列。次元数は同じであるが、形状が異なっていてもよいです。これは、 &lt;code&gt;func&lt;/code&gt; が入力に対して出力の形状を変更するかどうかによって異なります。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d041e4d25d02f826463aa1a16a95e06fcf896235" translate="yes" xml:space="preserve">
          <source>The output array. The shape of &lt;code&gt;out&lt;/code&gt; is identical to the shape of &lt;code&gt;arr&lt;/code&gt;, except along the &lt;code&gt;axis&lt;/code&gt; dimension. This axis is removed, and replaced with new dimensions equal to the shape of the return value of &lt;code&gt;func1d&lt;/code&gt;. So if &lt;code&gt;func1d&lt;/code&gt; returns a scalar &lt;code&gt;out&lt;/code&gt; will have one fewer dimensions than &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">出力配列。 &lt;code&gt;out&lt;/code&gt; の形状は、 &lt;code&gt;axis&lt;/code&gt; 次元に沿っていることを除いて、 &lt;code&gt;arr&lt;/code&gt; の形状と同じです。この軸は削除され、 &lt;code&gt;func1d&lt;/code&gt; の戻り値の形状に等しい新しい次元に置き換えられます。あれば &lt;code&gt;func1d&lt;/code&gt; はスカラーを返す &lt;code&gt;out&lt;/code&gt; より1つの少ない寸法があります &lt;code&gt;arr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8620240fb2ec2168fe1488fc7c50d1b1766a372e" translate="yes" xml:space="preserve">
          <source>The output at position m is the m-th element of the array in &lt;code&gt;choicelist&lt;/code&gt; where the m-th element of the corresponding array in &lt;code&gt;condlist&lt;/code&gt; is True.</source>
          <target state="translated">位置mの出力は、 &lt;code&gt;choicelist&lt;/code&gt; の配列のm番目の要素で、 &lt;code&gt;condlist&lt;/code&gt; の対応する配列のm番目の要素はTrueです。</target>
        </trans-unit>
        <trans-unit id="0043f09ea13cb649da8f2d6d2895f2519551c732" translate="yes" xml:space="preserve">
          <source>The output data type. It must be specified as either a string of typecode characters or a list of data type specifiers. There should be one data type specifier for each output.</source>
          <target state="translated">出力データ型。これは、タイプコード文字の文字列またはデータ型指定子のリストのいずれかで指定する必要があります。各出力に対して1つのデータ型指定子を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="abacf3469f99309139bddd0efe494fc74e079f06" translate="yes" xml:space="preserve">
          <source>The output has the same shape as the input and each 1-D loop operates over</source>
          <target state="translated">出力は入力と同じ形状をしており、各1次元ループはオーバーで動作します。</target>
        </trans-unit>
        <trans-unit id="2e90afe5c10bc3b541c84caa9141acf978817abb" translate="yes" xml:space="preserve">
          <source>The output is left-padded by the length of the prefix string, and wrapping is forced at the column &lt;code&gt;max_line_width - len(suffix)&lt;/code&gt;. It should be noted that the content of prefix and suffix strings are not included in the output.</source>
          <target state="translated">出力には、プレフィックス文字列の長さが左側に埋め込まれ、列 &lt;code&gt;max_line_width - len(suffix)&lt;/code&gt; れます。接頭辞と接尾辞の文字列の内容は出力に含まれないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="8da09507a5558a4c68826bbfbad5a55048ee486a" translate="yes" xml:space="preserve">
          <source>The output is the same shape and type as x and is found by calling the functions in &lt;code&gt;funclist&lt;/code&gt; on the appropriate portions of &lt;code&gt;x&lt;/code&gt;, as defined by the boolean arrays in &lt;code&gt;condlist&lt;/code&gt;. Portions not covered by any condition have a default value of 0.</source>
          <target state="translated">出力は、xと同じ形状およびタイプであり、 &lt;code&gt;funclist&lt;/code&gt; のブール配列で定義されているように、 &lt;code&gt;x&lt;/code&gt; の適切な部分でfunclistの関数を呼び出すことで &lt;code&gt;condlist&lt;/code&gt; ます。どの条件にも該当しない部分のデフォルト値は0です。</target>
        </trans-unit>
        <trans-unit id="f50dbb1c407bc1480ac12746928854d5651c29cc" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;argwhere&lt;/code&gt; is not suitable for indexing arrays. For this purpose use &lt;code&gt;nonzero(a)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;argwhere&lt;/code&gt; の出力は、配列のインデックス付けには適していません。この目的のために &lt;code&gt;nonzero(a)&lt;/code&gt; 代わりにnonzero（a）を使用してください。</target>
        </trans-unit>
        <trans-unit id="9cad5509a2704fc8189ddac84d202e22c4e895ee" translate="yes" xml:space="preserve">
          <source>The output of the ufunc (and its methods) is not necessarily an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if all input arguments are not &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. Indeed, if any input defines an &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, control will be passed completely to that function, i.e., the ufunc is &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/ufuncs.overrides&quot;&gt;overridden&lt;/a&gt;.</source>
          <target state="translated">すべての入力引数が&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; s&lt;/a&gt;ではない場合、ufunc（およびそのメソッド）の出力は必ずしもndarrayであるとは限りませ&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;。実際、入力が&lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;メソッドを定義している場合、制御はその関数に完全に渡されます。つまり、ufuncは&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/ufuncs.overrides&quot;&gt;オーバーライドされ&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="dffd3ba3dd5dfca8ee836a2b9bb97cc8318013a0" translate="yes" xml:space="preserve">
          <source>The output shape in the dense case is obtained by prepending the number of dimensions in front of the tuple of dimensions, i.e. if &lt;code&gt;dimensions&lt;/code&gt; is a tuple &lt;code&gt;(r0, ..., rN-1)&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the output shape is &lt;code&gt;(N, r0, ..., rN-1)&lt;/code&gt;.</source>
          <target state="translated">密な場合の出力形状は、次元のタプルの前に次元数を付加することによって得られます。つまり、 &lt;code&gt;dimensions&lt;/code&gt; が長さ &lt;code&gt;N&lt;/code&gt; のタプル &lt;code&gt;(r0, ..., rN-1)&lt;/code&gt; である場合、出力形状は &lt;code&gt;(N, r0, ..., rN-1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b58a2d32420f4e758be11c792f006660e86c89ee" translate="yes" xml:space="preserve">
          <source>The output type is determined by evaluating the first element of the input, unless it is specified:</source>
          <target state="translated">出力タイプは、指定されていない限り、入力の最初の要素を評価することで決定されます。</target>
        </trans-unit>
        <trans-unit id="a8b2e53b333d791e589c426b13ebb877541abc09" translate="yes" xml:space="preserve">
          <source>The output, analogously to &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, contains the term for zero frequency in the low-order corner of all axes, the positive frequency terms in the first half of all axes, the term for the Nyquist frequency in the middle of all axes and the negative frequency terms in the second half of all axes, in order of decreasingly negative frequency.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;と同様に、出力には、すべての軸の低次コーナーのゼロ周波数の項、すべての軸の前半の正の周波数項、すべての軸の中央のナイキスト周波数の項、および負の項が含まれます。すべての軸の後半にある周波数の項。負の周波数から順に減少します。</target>
        </trans-unit>
        <trans-unit id="2e04271603cd70e84ef996c185fb1fb3c75eb84c" translate="yes" xml:space="preserve">
          <source>The output, analogously to &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, contains the term for zero frequency in the low-order corner of the transformed axes, the positive frequency terms in the first half of these axes, the term for the Nyquist frequency in the middle of the axes and the negative frequency terms in the second half of the axes, in order of decreasingly negative frequency.</source>
          <target state="translated">出力には、&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;と同様に、変換された軸の低次コーナーのゼロ周波数の項、これらの軸の前半の正の周波数項、軸の中央のナイキスト周波数の項、および負の周波数の順に、軸の後半にある負の周波数の項。</target>
        </trans-unit>
        <trans-unit id="ed35a4029927607a6ec8e44ffef5c4477bb8a981" translate="yes" xml:space="preserve">
          <source>The package ensures that masked entries are not used in computations.</source>
          <target state="translated">このパッケージは、マスクされたエントリが計算で使用されないことを保証します。</target>
        </trans-unit>
        <trans-unit id="f6f78aee1988dc701d01aad263b1da5166d3a53f" translate="yes" xml:space="preserve">
          <source>The padding character to use (default is space).</source>
          <target state="translated">使用するパディング文字(デフォルトはスペース)。</target>
        </trans-unit>
        <trans-unit id="7e8fe55b063cd4163ba4aeac13d68612e9f5d53b" translate="yes" xml:space="preserve">
          <source>The padding function, if used, should modify a rank 1 array in-place. It has the following signature:</source>
          <target state="translated">padding関数が使用されている場合,ランク1の配列をその場で修正しなければなりません.これは次のようなシグネチャを持っています。</target>
        </trans-unit>
        <trans-unit id="91842f7bb32c0502ac19c7e4e8ff23d234b3cdfd" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;oa_ndim&lt;/code&gt;, when not zero or -1, specifies the number of dimensions that will be iterated with customized broadcasting. If it is provided, &lt;code&gt;op_axes&lt;/code&gt; must and &lt;code&gt;itershape&lt;/code&gt; can also be provided. The &lt;code&gt;op_axes&lt;/code&gt; parameter let you control in detail how the axes of the operand arrays get matched together and iterated. In &lt;code&gt;op_axes&lt;/code&gt;, you must provide an array of &lt;code&gt;nop&lt;/code&gt; pointers to &lt;code&gt;oa_ndim&lt;/code&gt;-sized arrays of type &lt;code&gt;npy_intp&lt;/code&gt;. If an entry in &lt;code&gt;op_axes&lt;/code&gt; is NULL, normal broadcasting rules will apply. In &lt;code&gt;op_axes[j][i]&lt;/code&gt; is stored either a valid axis of &lt;code&gt;op[j]&lt;/code&gt;, or -1 which means &lt;code&gt;newaxis&lt;/code&gt;. Within each &lt;code&gt;op_axes[j]&lt;/code&gt; array, axes may not be repeated. The following example is how normal broadcasting applies to a 3-D array, a 2-D array, a 1-D array and a scalar.</source>
          <target state="translated">パラメータ &lt;code&gt;oa_ndim&lt;/code&gt; は、ゼロまたは-1でない場合、カスタマイズされたブロードキャストで反復される次元の数を指定します。提供される場合、 &lt;code&gt;op_axes&lt;/code&gt; は必須であり、 &lt;code&gt;itershape&lt;/code&gt; も提供できます。 &lt;code&gt;op_axes&lt;/code&gt; のパラメータを使用すると、オペランドアレイの軸が一緒にマッチし、繰り返し取得する方法を詳細に制御できます。では &lt;code&gt;op_axes&lt;/code&gt; 、あなたはの配列を提供しなければならない &lt;code&gt;nop&lt;/code&gt; へのポインタを &lt;code&gt;oa_ndim&lt;/code&gt; 型の-sized配列 &lt;code&gt;npy_intp&lt;/code&gt; を。 &lt;code&gt;op_axes&lt;/code&gt; のエントリがNULLの場合、通常のブロードキャストルールが適用されます。 &lt;code&gt;op_axes[j][i]&lt;/code&gt; の有効軸のいずれかの記憶されている &lt;code&gt;op[j]&lt;/code&gt; 、または-1れる手段 &lt;code&gt;newaxis&lt;/code&gt; 。各 &lt;code&gt;op_axes[j]&lt;/code&gt; 配列内では、軸を繰り返すことはできません。次の例は、通常のブロードキャストが3次元配列、2次元配列、1次元配列、およびスカラーにどのように適用されるかを示しています。</target>
        </trans-unit>
        <trans-unit id="6f24110e4501ed427c7d67150722a36e47c9eb87" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;x&lt;/code&gt; is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either &lt;code&gt;x&lt;/code&gt; or its elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">パラメーター &lt;code&gt;x&lt;/code&gt; は、タプルまたはリストの場合にのみ配列に変換されます。それ以外の場合は、スカラーとして扱われます。どちらの場合でも、 &lt;code&gt;x&lt;/code&gt; またはその要素は、それ自体と &lt;code&gt;c&lt;/code&gt; の要素の両方で乗算と加算をサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="81b1fc95a0e75fbef51d185592084c9ff4aaba4c" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;x&lt;/code&gt; is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either &lt;code&gt;x&lt;/code&gt; or its elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">パラメーター &lt;code&gt;x&lt;/code&gt; は、タプルまたはリストの場合にのみ配列に変換されます。それ以外の場合は、スカラーとして扱われます。どちらの場合でも、 &lt;code&gt;x&lt;/code&gt; またはその要素は、それ自体と &lt;code&gt;r&lt;/code&gt; の要素の両方での乗算と加算をサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="fed3e36a151b3d1051d8c0d0e63efcd30243f871" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;dtype&lt;/em&gt; specifies the data type over which a reduction operation (like summing) should take place. The default reduce data type is the same as the data type of &lt;em&gt;self&lt;/em&gt;. To avoid overflow, it can be useful to perform the reduction using a larger data type.</source>
          <target state="translated">パラメータ&lt;em&gt;dtype&lt;/em&gt;は、（合計などの）縮約操作を実行するデータ型を指定します。デフォルトのreduceデータ型は、&lt;em&gt;selfの&lt;/em&gt;データ型と同じです。オーバーフローを回避するには、より大きなデータ型を使用して削減を実行すると便利です。</target>
        </trans-unit>
        <trans-unit id="5047704927c94b8b6586c636aa20a6789550df01" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars and they must have the same shape after conversion. In either case, either &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">パラメーター &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は、タプルまたはリストの場合にのみ配列に変換されます。それ以外の場合は、スカラーとして扱われ、変換後の形状は同じでなければなりません。どちらの場合でも、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; またはそれらの要素は、自身と &lt;code&gt;c&lt;/code&gt; の要素の両方で乗算と加算をサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="ab30d7deae7ce08d9cafc57f0a0d9da22b443d75" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars. In either case, either &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">パラメーター &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; は、タプルまたはリストの場合にのみ配列に変換されます。それ以外の場合は、スカラーとして扱われます。どちらの場合でも、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; またはそれらの要素は、自身と &lt;code&gt;c&lt;/code&gt; の要素の両方で乗算と加算をサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="dea737cd6cbb9eb4fabc09fa179fafbb398a4ba4" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars and they must have the same shape after conversion. In either case, either &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">パラメーター &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;z&lt;/code&gt; は、タプルまたはリストの場合にのみ配列に変換されます。それ以外の場合は、スカラーとして扱われ、変換後は同じ形状でなければなりません。どちらの場合でも、 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;z&lt;/code&gt; またはそれらの要素は、自身と &lt;code&gt;c&lt;/code&gt; の要素の両方で乗算と加算をサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="942247face18dfe9d547bf9f163892321bfcd347" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars. In either case, either &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">パラメーター &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;z&lt;/code&gt; は、タプルまたはリストの場合にのみ配列に変換されます。それ以外の場合は、スカラーとして扱われます。どちらの場合でも、 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;z&lt;/code&gt; またはそれらの要素は、自身と &lt;code&gt;c&lt;/code&gt; の要素の両方で乗算と加算をサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="2f059fed0e631d6e93c76ef517cee1b4493e82a4" translate="yes" xml:space="preserve">
          <source>The path of the template, relatively to the current package path.</source>
          <target state="translated">テンプレートのパスを、現在のパッケージのパスと相対的に比較したものです。</target>
        </trans-unit>
        <trans-unit id="a3bed8bc2ca97f198b6eb9b3e908d4ed3c7c443d" translate="yes" xml:space="preserve">
          <source>The path to the file for which the doctests are run.</source>
          <target state="translated">Doctests を実行するファイルへのパスです。</target>
        </trans-unit>
        <trans-unit id="decb24fde62e2b923b5a976163e8c054497d68bf" translate="yes" xml:space="preserve">
          <source>The pattern for using nested iterators is as follows.</source>
          <target state="translated">ネストされたイテレータを使用するパターンは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="82eacc753e4241f8676568f6609cbd6d30cfc9ba" translate="yes" xml:space="preserve">
          <source>The pattern is similar for other, more complex generators. The normal performance of the legacy &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; generator is much lower than the other since it uses the Box-Muller transformation rather than the Ziggurat generator. The performance gap for Exponentials is also large due to the cost of computing the log function to invert the CDF. The column labeled MT19973 is used the same 32-bit generator as &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; but produces random values using &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このパターンは、他のより複雑なジェネレーターでも同様です。レガシー&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;ジェネレーターの通常のパフォーマンスは、ZigguratジェネレーターではなくBox-Muller変換を使用するため、他のジェネレーターよりもはるかに低くなります。指数関数のパフォーマンスギャップは、CDFを反転するログ関数を計算するコストのためにも大きくなります。MT19973というラベルの列は、RandomStateと同じ32ビットジェネレーターを&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;いますが、&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;を使用してランダムな値を生成しています。</target>
        </trans-unit>
        <trans-unit id="5f948cd9daa190278b24b7616c4acaf6e82e63af" translate="yes" xml:space="preserve">
          <source>The payment is computed by solving the equation:</source>
          <target state="translated">支払いは式を解くことで計算されます。</target>
        </trans-unit>
        <trans-unit id="7c38a52dfb1124cf95fad23836990fb2bf0bbca3" translate="yes" xml:space="preserve">
          <source>The percentage of waves larger than 3 meters is:</source>
          <target state="translated">m以上の波の割合は</target>
        </trans-unit>
        <trans-unit id="bf26c5d0de790b76d482846fdfc7d5a573504f09" translate="yes" xml:space="preserve">
          <source>The performance of 64-bit generators on 32-bit Windows is much lower than on 64-bit operating systems due to register width. MT19937, the generator that has been in NumPy since 2005, operates on 32-bit integers.</source>
          <target state="translated">32ビットWindows上での64ビットジェネレータの性能は、レジスタ幅の関係で、64ビットOS上での性能よりもはるかに低い。2005年からNumPyに搭載されているジェネレータMT19937は、32ビット整数で動作します。</target>
        </trans-unit>
        <trans-unit id="0779c65ec163a12759193f89f82723f01bb394dd" translate="yes" xml:space="preserve">
          <source>The polynomial coefficients</source>
          <target state="translated">多項式係数</target>
        </trans-unit>
        <trans-unit id="b9ed1328025571c1195a04bff5fdf98ece032c1f" translate="yes" xml:space="preserve">
          <source>The polynomial resulting from the multiplication of the inputs. If either inputs is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</source>
          <target state="translated">入力の乗算から得られる多項式。どちらかの入力がポリ1次元オブジェクトの場合、出力もポリ1次元オブジェクトとなります。そうでない場合は、最高次数から最低次数までの多項式係数の1次元配列です。</target>
        </trans-unit>
        <trans-unit id="515cfb6ef96288d03850b077c1e2ea4a5a576f0e" translate="yes" xml:space="preserve">
          <source>The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used.</source>
          <target state="translated">現在のインスタンスが変換されるべき多項式級数型のクラス。kindがNoneの場合は、現在のインスタンスのクラスが使用されます。</target>
        </trans-unit>
        <trans-unit id="75f7f784e98730c24c6aac1a9a0a155ec4addf47" translate="yes" xml:space="preserve">
          <source>The polynomial&amp;rsquo;s coefficients, in decreasing powers, or if the value of the second parameter is True, the polynomial&amp;rsquo;s roots (values where the polynomial evaluates to 0). For example, &lt;code&gt;poly1d([1, 2, 3])&lt;/code&gt; returns an object that represents</source>
          <target state="translated">多項式の係数、降べきの順、または2番目のパラメーターの値がTrueの場合、多項式の根（多項式が0と評価される値）。たとえば、 &lt;code&gt;poly1d([1, 2, 3])&lt;/code&gt; は、次を表すオブジェクトを返します</target>
        </trans-unit>
        <trans-unit id="80160250c999cde418e5655d194ff040c11e355e" translate="yes" xml:space="preserve">
          <source>The position,</source>
          <target state="translated">位置です。</target>
        </trans-unit>
        <trans-unit id="04babac298b058269a3dd833ef7829f7e3894479" translate="yes" xml:space="preserve">
          <source>The possibly nested list of array elements.</source>
          <target state="translated">入れ子になっている可能性のある配列要素のリスト.</target>
        </trans-unit>
        <trans-unit id="5cb3bd54a03911e525c1ba1e36e3cfe8b319cbe5" translate="yes" xml:space="preserve">
          <source>The power function distribution is just the inverse of the Pareto distribution. It may also be seen as a special case of the Beta distribution.</source>
          <target state="translated">力関数分布は,パレート分布の逆数にすぎません.ベータ分布の特殊なケースと見なすこともできます。</target>
        </trans-unit>
        <trans-unit id="bce0b83b0022d3f62b001c90ef9147d9a4659969" translate="yes" xml:space="preserve">
          <source>The preferred way to use a BitGenerator in parallel applications is to use the &lt;code&gt;SeedSequence.spawn&lt;/code&gt; method to obtain entropy values, and to use these to generate new BitGenerators:</source>
          <target state="translated">並列アプリケーションでBitGeneratorを使用する好ましい方法は、 &lt;code&gt;SeedSequence.spawn&lt;/code&gt; メソッドを使用してエントロピー値を取得し、これらを使用して新しいBitGeneratorを生成することです。</target>
        </trans-unit>
        <trans-unit id="7ca668d501fbd18bd9dc320e9a4abf1ee3d102d7" translate="yes" xml:space="preserve">
          <source>The preprocessing of generically typed C source files (whether in NumPy proper or in any third party package using NumPy Distutils) is performed by &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/distutils/conv_template.py&quot;&gt;conv_template.py&lt;/a&gt;. The type specific C files generated (extension: .c) by these modules during the build process are ready to be compiled. This form of generic typing is also supported for C header files (preprocessed to produce .h files).</source>
          <target state="translated">汎用的に型付けされたCソースファイルの前処理（NumPyの適切なファイル、またはNumPy Distutilsを使用するサードパーティのパッケージのいずれか）は、&lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/distutils/conv_template.py&quot;&gt;conv_template.py&lt;/a&gt;によって実行されます。ビルドプロセス中にこれらのモジュールによって生成されたタイプ固有のCファイル（拡張子：.c）は、コンパイルする準備ができています。この形式のジェネリックタイピングは、Cヘッダーファイル（.hファイルを生成するために前処理されたもの）でもサポートされています。</target>
        </trans-unit>
        <trans-unit id="79ca2b18555d36b1c58583e3de2322375811401a" translate="yes" xml:space="preserve">
          <source>The presence of &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; also influences how &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; handles binary operations like &lt;code&gt;arr + obj&lt;/code&gt; and &lt;code&gt;arr
&amp;lt; obj&lt;/code&gt; when &lt;code&gt;arr&lt;/code&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;obj&lt;/code&gt; is an instance of a custom class. There are two possibilities. If &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; is present and not &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;code&gt;ndarray.__add__&lt;/code&gt; and friends will delegate to the ufunc machinery, meaning that &lt;code&gt;arr + obj&lt;/code&gt; becomes &lt;code&gt;np.add(arr, obj)&lt;/code&gt;, and then &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; invokes &lt;code&gt;obj.__array_ufunc__&lt;/code&gt;. This is useful if you want to define an object that acts like an array.</source>
          <target state="translated">存在&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;も影響どの&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;等ハンドルバイナリ操作 &lt;code&gt;arr + obj&lt;/code&gt; と &lt;code&gt;arr &amp;lt; obj&lt;/code&gt; 場合 &lt;code&gt;arr&lt;/code&gt; ある&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;obj&lt;/code&gt; がカスタムクラスのインスタンスです。2つの可能性があります。&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;でない &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; が存在する場合、 &lt;code&gt;ndarray.__add__&lt;/code&gt; とそのフレンドはufunc機構に委任します。これは、 &lt;code&gt;arr + obj&lt;/code&gt; が &lt;code&gt;np.add(arr, obj)&lt;/code&gt; になり、次に&lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt; &lt;code&gt;add&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; 呼び出すことを意味します。。これは、配列のように機能するオブジェクトを定義する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="e5f36326e83630873ee2db09163f521fed09ccf8" translate="yes" xml:space="preserve">
          <source>The present value is computed by solving the equation:</source>
          <target state="translated">現在値は、式を解くことで計算されます。</target>
        </trans-unit>
        <trans-unit id="8faab5fdb76f1a3f47be9fc86bef262e2ab4b27a" translate="yes" xml:space="preserve">
          <source>The probabilities associated with each entry in a. If not given the sample assumes a uniform distribution over all entries in a.</source>
          <target state="translated">与えられていない場合は,標本はaのすべての項目について一様分布を仮定しています.</target>
        </trans-unit>
        <trans-unit id="8e475ecd8059b20acc5cee6528910a74a85f3b11" translate="yes" xml:space="preserve">
          <source>The probability density for the Gamma distribution is</source>
          <target state="translated">ガンマ分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="de744fd74c21b122de22a0d8e948a2a51ccc2b96" translate="yes" xml:space="preserve">
          <source>The probability density for the Gaussian distribution is</source>
          <target state="translated">ガウス分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="5905e8ef12f7d0d9eb54f382d72998ae48c8ef44" translate="yes" xml:space="preserve">
          <source>The probability density for the Gumbel distribution is</source>
          <target state="translated">ガンベル分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="bfb8724927e73ab8d936772b36c634818f86c5a4" translate="yes" xml:space="preserve">
          <source>The probability density for the Hypergeometric distribution is</source>
          <target state="translated">ハイパージオメトリック分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="f8985b96e26b0408a1f84b2787ee767e62c90303" translate="yes" xml:space="preserve">
          <source>The probability density for the Log Series distribution is</source>
          <target state="translated">対数系列分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="99fc9473ccfc113313d9fd374b914f025b58f310" translate="yes" xml:space="preserve">
          <source>The probability density for the Logistic distribution is</source>
          <target state="translated">ロジスティック分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="7985bdd977289b5652a3a0bba81a5da1bd3adf6d" translate="yes" xml:space="preserve">
          <source>The probability density for the Pareto distribution is</source>
          <target state="translated">パレート分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="238160654ada0174d17d83e1f0d7a26707c02c8d" translate="yes" xml:space="preserve">
          <source>The probability density for the Weibull distribution is</source>
          <target state="translated">ワイブル分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="fc3b79ebd29285bfc80812044ba5bd995aaaa06a" translate="yes" xml:space="preserve">
          <source>The probability density for the Zipf distribution is</source>
          <target state="translated">Zipf分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="bb707b06597dece119e6e3ebea40c8f15c1cb44f" translate="yes" xml:space="preserve">
          <source>The probability density for the binomial distribution is</source>
          <target state="translated">二項分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="6264a2e3e986c29af2fd700f69cafdda6f6c9d98" translate="yes" xml:space="preserve">
          <source>The probability density for the von Mises distribution is</source>
          <target state="translated">フォン・ミーゼス分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="2e977910510c195394a91f298d7c9556abc16027" translate="yes" xml:space="preserve">
          <source>The probability density function</source>
          <target state="translated">確率密度関数</target>
        </trans-unit>
        <trans-unit id="a293dce90e3fe47dddc6a55e94ccb69a8fef9b0c" translate="yes" xml:space="preserve">
          <source>The probability density function for the Rayleigh distribution is</source>
          <target state="translated">レイリー分布の確率密度関数は</target>
        </trans-unit>
        <trans-unit id="d3e0872e16a6ab7b6c0ee2a22d52dd0d2e1ca84e" translate="yes" xml:space="preserve">
          <source>The probability density function for the Wald distribution is</source>
          <target state="translated">ウォルト分布の確率密度関数は</target>
        </trans-unit>
        <trans-unit id="2f149a65fa2739e5de1eec985af9c1621ffacc73" translate="yes" xml:space="preserve">
          <source>The probability density function for the full Cauchy distribution is</source>
          <target state="translated">完全コーキー分布の確率密度関数は</target>
        </trans-unit>
        <trans-unit id="6b0dc98514227cdd44ff47b528c8a0bcaf89c265" translate="yes" xml:space="preserve">
          <source>The probability density function for the noncentral Chi-square distribution is</source>
          <target state="translated">非中心カイ二乗分布の確率密度関数は</target>
        </trans-unit>
        <trans-unit id="c30948020144257a9fb38966abff7c99e81c50e9" translate="yes" xml:space="preserve">
          <source>The probability density function for the t distribution is</source>
          <target state="translated">t分布の確率密度関数は</target>
        </trans-unit>
        <trans-unit id="dcdbad2794701215e8c40510ff713b7913263c5a" translate="yes" xml:space="preserve">
          <source>The probability density function for the triangular distribution is</source>
          <target state="translated">三角分布の確率密度関数は</target>
        </trans-unit>
        <trans-unit id="6467351c7a0571530575123e2ae036078aaa2303" translate="yes" xml:space="preserve">
          <source>The probability density function is</source>
          <target state="translated">確率密度関数は</target>
        </trans-unit>
        <trans-unit id="ee41aab696af2a63a045005f9a20ab50a30087b5" translate="yes" xml:space="preserve">
          <source>The probability density function of the chi-squared distribution is</source>
          <target state="translated">カイ二乗分布の確率密度関数は</target>
        </trans-unit>
        <trans-unit id="c5e3eadc4ee0ddfc376707a7c47e36bdec30614e" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">正規分布の確率密度関数は、最初にDe Moivreによって導出され、200年後にGaussとLaplaceの両方によって独立して導出されます&lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id1&quot;&gt;[2]が&lt;/a&gt;、その特徴的な形状のためにベルカーブと呼ばれることがよくあります（以下の例を参照）。</target>
        </trans-unit>
        <trans-unit id="d7e2875a44ce7ebdc83cb0f55dc114499ca0e8b1" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">正規分布の確率密度関数は、最初にDe Moivreによって導出され、200年後にGaussとLaplaceの両方によって独立して導出されます&lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id1&quot;&gt;[2]が&lt;/a&gt;、その特徴的な形状のためにベルカーブと呼ばれることがよくあります（以下の例を参照）。</target>
        </trans-unit>
        <trans-unit id="2755556e2db9bd446cf581401e578c5337420320" translate="yes" xml:space="preserve">
          <source>The probability density function of the uniform distribution is</source>
          <target state="translated">一様分布の確率密度関数は</target>
        </trans-unit>
        <trans-unit id="415051b020f7949a62618fb53ef560dee4613543" translate="yes" xml:space="preserve">
          <source>The probability inputs should be normalized. As an implementation detail, the value of the last entry is ignored and assumed to take up any leftover probability mass, but this should not be relied on. A biased coin which has twice as much weight on one side as on the other should be sampled like so:</source>
          <target state="translated">確率入力は正規化されるべきである。実装の詳細として、最後のエントリの値は無視され、残された確率の質量を取ると仮定されますが、これに依存すべきではありません。片側に2倍の重みを持つ偏ったコインは、このようにサンプリングされるべきです。</target>
        </trans-unit>
        <trans-unit id="8e4c202be333253a1251675439dcd7f21c1ef125" translate="yes" xml:space="preserve">
          <source>The probability mass function for the Log Series distribution is</source>
          <target state="translated">対数系列分布の確率質量関数は</target>
        </trans-unit>
        <trans-unit id="2d117aed0c4f59861c0b3330028791db8f91f6f5" translate="yes" xml:space="preserve">
          <source>The probability mass function of the geometric distribution is</source>
          <target state="translated">幾何学的分布の確率質量関数は</target>
        </trans-unit>
        <trans-unit id="53c49feadffaed0acd89d507cebd4872b9032162" translate="yes" xml:space="preserve">
          <source>The probability mass function of the negative binomial distribution is</source>
          <target state="translated">負の二項分布の確率質量関数は</target>
        </trans-unit>
        <trans-unit id="f1f5e6e451a12ecc1dfa7cb3123b997ae141c402" translate="yes" xml:space="preserve">
          <source>The probability of success of an individual trial.</source>
          <target state="translated">個々の試験が成功する確率。</target>
        </trans-unit>
        <trans-unit id="c0419d3f3c0dd14cc710a6332bd5b9e9f12f94e6" translate="yes" xml:space="preserve">
          <source>The problem here is that there is one dimension argument and two array arguments, and our typemaps are set up for dimensions that apply to a single array (in fact, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; does not provide a mechanism for associating &lt;code&gt;len&lt;/code&gt; with &lt;code&gt;vec2&lt;/code&gt; that takes two Python input arguments). The recommended solution is the following:</source>
          <target state="translated">ここでの問題は、1つの次元引数と2つの配列引数があり、タイプマップが単一の配列に適用される次元に対して設定されていることです（実際、&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;は、 &lt;code&gt;len&lt;/code&gt; を &lt;code&gt;vec2&lt;/code&gt; に関連付けて2つのPython入力引数を取るメカニズムを提供していません）。推奨される解決策は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="258606759bb8ded772cb41c8f492be953461a647" translate="yes" xml:space="preserve">
          <source>The problem is solved exactly. In this case, the function returns True only if there is an element shared between the arrays.</source>
          <target state="translated">問題は正確に解決されます。この場合、この関数は配列間で共有されている要素がある場合にのみTrueを返します。</target>
        </trans-unit>
        <trans-unit id="12f7b79ffc79e216081a6d98b051a230198244d5" translate="yes" xml:space="preserve">
          <source>The product of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">要素ごとの &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の積。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="3f6e1c408d5c694acb6e117eca1f17a66ff95359" translate="yes" xml:space="preserve">
          <source>The product of an empty array is the neutral element 1:</source>
          <target state="translated">空の配列の積が中立要素1となります。</target>
        </trans-unit>
        <trans-unit id="0cb319efd0acc22671f035a1669648180fbd73bb" translate="yes" xml:space="preserve">
          <source>The promoted data type.</source>
          <target state="translated">昇格したデータ型。</target>
        </trans-unit>
        <trans-unit id="6912cd62e766bc5197bb815c3a7a6d0beffe9f0f" translate="yes" xml:space="preserve">
          <source>The pseudo Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Chebyshev polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">疑似ヴァンダーモンド行列。返される行列の形状は &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; 。ここで、最後のインデックスは対応するチェビシェフ多項式の次数です。dtypeは、変換された &lt;code&gt;x&lt;/code&gt; と同じになります。</target>
        </trans-unit>
        <trans-unit id="4ae75dbae228045f6a44f16a4959415e52a060af" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Hermite polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">疑似ヴァンダーモンド行列。返される行列の形状は &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; 。ここで、最後のインデックスは対応するエルミート多項式の次数です。dtypeは、変換された &lt;code&gt;x&lt;/code&gt; と同じになります。</target>
        </trans-unit>
        <trans-unit id="88145706d808f4e5b4b300c092c6d0b48707e827" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding HermiteE polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">疑似ヴァンダーモンド行列。返される行列の形状は &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; 。ここで、最後のインデックスは対応するHermiteE多項式の次数です。dtypeは、変換された &lt;code&gt;x&lt;/code&gt; と同じになります。</target>
        </trans-unit>
        <trans-unit id="461d6f363a2da4bb21861bdd9199b9a080f1058c" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Laguerre polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">疑似ヴァンダーモンド行列。返される行列の形状は &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; 。ここで、最後のインデックスは対応するラゲール多項式の次数です。dtypeは、変換された &lt;code&gt;x&lt;/code&gt; と同じになります。</target>
        </trans-unit>
        <trans-unit id="a9fac4b82ab694bb7879684258269647508526ed" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Legendre polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">疑似ヴァンダーモンド行列。返される行列の形状は &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; です。最後のインデックスは、対応するルジャンドル多項式の次数です。dtypeは、変換された &lt;code&gt;x&lt;/code&gt; と同じになります。</target>
        </trans-unit>
        <trans-unit id="14e8343a4bfc8bf0e783456b4d87d1a38896cde9" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;matrix&lt;/code&gt; instance, then so is &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">の擬似逆。場合である &lt;code&gt;matrix&lt;/code&gt; インスタンスは、そのようになる &lt;code&gt;B&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9935b0bcef3c9f2790af77d395c4f7367a5b4f9" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of a matrix A, denoted</source>
          <target state="translated">行列 A の擬似逆行列である</target>
        </trans-unit>
        <trans-unit id="273d622b1bbcac1e58ca2d1b74d9ecdc471af9f8" translate="yes" xml:space="preserve">
          <source>The purpose of the reference count check is to make sure you do not use this array as a buffer for another Python object and then reallocate the memory. However, reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object, then you may safely set &lt;code&gt;refcheck&lt;/code&gt; to False.</source>
          <target state="translated">参照カウントチェックの目的は、この配列を別のPythonオブジェクトのバッファとして使用しないようにし、メモリを再割り当てすることです。ただし、他の方法で参照カウントが増加する可能性があるため、この配列のメモリを別のPythonオブジェクトと共有していないことが確実な場合は、 &lt;code&gt;refcheck&lt;/code&gt; を安全にFalse に設定できます。</target>
        </trans-unit>
        <trans-unit id="fd1af1501c6ee7b4f0b0aa9bb7ca5e17785491ff" translate="yes" xml:space="preserve">
          <source>The quadrant (i.e., branch) is chosen so that &lt;code&gt;arctan2(x1, x2)&lt;/code&gt; is the signed angle in radians between the ray ending at the origin and passing through the point (1,0), and the ray ending at the origin and passing through the point (&lt;code&gt;x2&lt;/code&gt;, &lt;code&gt;x1&lt;/code&gt;). (Note the role reversal: the &amp;ldquo;&lt;code&gt;y&lt;/code&gt;-coordinate&amp;rdquo; is the first function parameter, the &amp;ldquo;&lt;code&gt;x&lt;/code&gt;-coordinate&amp;rdquo; is the second.) By IEEE convention, this function is defined for &lt;code&gt;x2&lt;/code&gt; = +/-0 and for either or both of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; = +/-inf (see Notes for specific values).</source>
          <target state="translated">象限（つまり、ブランチ）は、 &lt;code&gt;arctan2(x1, x2)&lt;/code&gt; が、原点で終了し、点（1,0）を通過する光線と、原点で終了し、通過する光線の間のラジアン単位の符号付き角度になるように選択されます。点（ &lt;code&gt;x2&lt;/code&gt; 、 &lt;code&gt;x1&lt;/code&gt; ）を通過します。 （役割の逆転に注意してください。「 &lt;code&gt;y&lt;/code&gt; 座標」は最初の関数パラメーター、「 &lt;code&gt;x&lt;/code&gt; 座標」は2番目のパラメーターです。）IEEEの規則により、この関数は &lt;code&gt;x2&lt;/code&gt; = +/- 0に対して、および &lt;code&gt;x1&lt;/code&gt; および &lt;code&gt;x2&lt;/code&gt; = +/- inf（特定の値については「注意」を参照）。</target>
        </trans-unit>
        <trans-unit id="d11423e3cc4bf0ed835c8b796b2965976e8e77d3" translate="yes" xml:space="preserve">
          <source>The random values are simulated using a rejection-based method and so, on average, more than one value from the underlying RNG is required to generate an single draw.</source>
          <target state="translated">乱数値は拒絶に基づく方法でシミュレートされるため、平均して、1回のドローを生成するためには、基礎となるRNGから1つ以上の値が必要となります。</target>
        </trans-unit>
        <trans-unit id="28da8ed4d2357ec2f5fb90d47c281e28c8eefc86" translate="yes" xml:space="preserve">
          <source>The random values produced by &lt;a href=&quot;../generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; orignate in a BitGenerator. The BitGenerators do not directly provide random numbers and only contains methods used for seeding, getting or setting the state, jumping or advancing the state, and for accessing low-level wrappers for consumption by code that can efficiently access the functions provided, e.g., &lt;a href=&quot;https://numba.pydata.org&quot;&gt;numba&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;によって生成されたランダムな値は、BitGeneratorで調整されます。BitGeneratorは直接乱数を提供せず、シードの取得、状態の取得または設定、状態のジャンプまたは進行、および提供された関数に効率的にアクセスできるコードによる消費のための低レベルラッパーへのアクセスに使用されるメソッドのみを含みます。たとえば、&lt;a href=&quot;https://numba.pydata.org&quot;&gt;numba&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ad47a80d273e6280e7c076840353be5436abdd4" translate="yes" xml:space="preserve">
          <source>The random variate of the F distribution (also known as the Fisher distribution) is a continuous probability distribution that arises in ANOVA tests, and is the ratio of two chi-square variates.</source>
          <target state="translated">F 分布のランダム分散量(フィッシャー分布としても知られている)は、ANOVA検定で生じる連続確率分布で、2つのカイ2乗分散量の比率である。</target>
        </trans-unit>
        <trans-unit id="0add6113b9556467f5d4df18305b83fe87d90739" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;a href=&quot;numpy.full#numpy.full&quot;&gt;&lt;code&gt;full&lt;/code&gt;&lt;/a&gt; = False.</source>
          <target state="translated">最小二乗近似における係数行列のランクが不十分です。警告は、&lt;a href=&quot;numpy.full#numpy.full&quot;&gt; &lt;code&gt;full&lt;/code&gt; &lt;/a&gt; = Falseの場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="b6ce678d6ccc2a705d695d4a88057837caab615e" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;code&gt;full&lt;/code&gt; = False.</source>
          <target state="translated">最小二乗近似における係数行列のランクが不十分です。警告は、 &lt;code&gt;full&lt;/code&gt; = Falseの場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="bd75ec6be6b0946c94eb5124dc2c270b7f45fc83" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;code&gt;full&lt;/code&gt; = False. The warnings can be turned off by</source>
          <target state="translated">最小二乗近似における係数行列のランクが不十分です。警告は、 &lt;code&gt;full&lt;/code&gt; = Falseの場合にのみ発生します。警告はオフにすることができます</target>
        </trans-unit>
        <trans-unit id="2c0ff958aa13b6c22519b1f58af607e808b9fc81" translate="yes" xml:space="preserve">
          <source>The rate of interest is computed by iteratively solving the (non-linear) equation:</source>
          <target state="translated">利率は、(非線形の)方程式を反復的に解くことによって計算されます。</target>
        </trans-unit>
        <trans-unit id="b661d55a0a19500a077ffd4c961cfcdd8af11a0d" translate="yes" xml:space="preserve">
          <source>The real and imaginary parts of complex numbers are rounded separately. The result of rounding a float is a float.</source>
          <target state="translated">複素数の実数部と虚数部は別々に丸められます。丸めた結果が浮動小数点数になります。</target>
        </trans-unit>
        <trans-unit id="207d8f1e0e497b598f007938a1132510a97a9210" translate="yes" xml:space="preserve">
          <source>The real component of the complex argument. If &lt;code&gt;val&lt;/code&gt; is real, the type of &lt;code&gt;val&lt;/code&gt; is used for the output. If &lt;code&gt;val&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">複素引数の実数コンポーネント。場合 &lt;code&gt;val&lt;/code&gt; が本当である、の種類 &lt;code&gt;val&lt;/code&gt; が出力のために使用されています。場合 &lt;code&gt;val&lt;/code&gt; は複雑な要素を持って、返された型はfloatです。</target>
        </trans-unit>
        <trans-unit id="bcba5206897319bd4dfef5984f33a61e7bfd3a3e" translate="yes" xml:space="preserve">
          <source>The real part of the array.</source>
          <target state="translated">配列の実際の部分。</target>
        </trans-unit>
        <trans-unit id="f76c20342380d19b36138a77680129546c04ac6d" translate="yes" xml:space="preserve">
          <source>The real part of the masked array.</source>
          <target state="translated">マスクされた配列の実際の部分。</target>
        </trans-unit>
        <trans-unit id="f8c34f7042b404b994731920ea347bbd1e355fae" translate="yes" xml:space="preserve">
          <source>The recommended approach to multithreaded iteration is to first create an iterator with the flags &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt;&lt;code&gt;NPY_ITER_RANGED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt;&lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt;&lt;/a&gt;, and possibly &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt;. Create a copy of this iterator for each thread (minus one for the first iterator). Then, take the iteration index range &lt;code&gt;[0, NpyIter_GetIterSize(iter))&lt;/code&gt; and split it up into tasks, for example using a TBB parallel_for loop. When a thread gets a task to execute, it then uses its copy of the iterator by calling &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt;&lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt;&lt;/a&gt; and iterating over the full range.</source>
          <target state="translated">マルチスレッド反復の推奨アプローチは、最初にフラグ&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt; &lt;code&gt;NPY_ITER_RANGED&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt; &lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt; &lt;/a&gt;、および場合によっては&lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; を&lt;/a&gt;使用してイテレーターを作成することです。このイテレータのコピーをスレッドごとに作成します（最初のイテレータの場合は1を引いてください）。次に、反復インデックスの範囲 &lt;code&gt;[0, NpyIter_GetIterSize(iter))&lt;/code&gt; を取得し、たとえばTBB parallel_forループを使用して、タスクに分割します。スレッドは、実行するタスクを取得すると、&lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt; &lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt; &lt;/a&gt;を呼び出して全範囲を反復することにより、イテレータのコピーを使用します。</target>
        </trans-unit>
        <trans-unit id="5447919d67b87c18366730a8d862cd10ecf68752" translate="yes" xml:space="preserve">
          <source>The recommended generator for general use is &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt;. It is statistically high quality, full-featured, and fast on most platforms, but somewhat slow when compiled for 32-bit processes.</source>
          <target state="translated">一般的な使用に推奨されるジェネレータは&lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;です。統計的に高品質でフル機能を備え、ほとんどのプラットフォームで高速ですが、32ビットプロセス用にコンパイルすると多少遅くなります。</target>
        </trans-unit>
        <trans-unit id="f1f83ab16efb108e21fd8dc9140501bac936f974" translate="yes" xml:space="preserve">
          <source>The recommended way to mark one or several specific entries of a masked array as invalid is to assign the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; to them:</source>
          <target state="translated">無効としてマスクされた配列の一つまたは複数の特定のエントリをマークする場合に推奨される方法は、特別な値割り当てることで&lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;、それらには：</target>
        </trans-unit>
        <trans-unit id="8e71a8b22e3d3f7dda123223a571d40b785e19ae" translate="yes" xml:space="preserve">
          <source>The recommended way to store and load data:</source>
          <target state="translated">データの保存・読み込みにおすすめの方法をご紹介します。</target>
        </trans-unit>
        <trans-unit id="8911e36d75ead22da4c98276ac7d48a14f617b1b" translate="yes" xml:space="preserve">
          <source>The reduceat function is a generalization of both the reduce and accumulate functions. It implements a reduce over ranges of the input array specified by indices. The extra indices argument is checked to be sure that every input is not too large for the input array along the selected dimension before the loop calculations take place. The loop implementation is handled using code that is very similar to the reduce code repeated as many times as there are elements in the indices input. In particular: the first input pointer passed to the underlying 1-D computational loop points to the input array at the correct location indicated by the index array. In addition, the output pointer and the second input pointer passed to the underlying 1-D loop point to the same position in memory. The size of the 1-D computational loop is fixed to be the difference between the current index and the next index (when the current index is the last index, then the next index is assumed to be the length of the array along the selected dimension). In this way, the 1-D loop will implement a reduce over the specified indices.</source>
          <target state="translated">reduceat 関数は,reduce と accumulate の両方の関数を一般化したものです.これは,インデックスで指定された入力配列の範囲を対象としたリダクションを実装しています.余分なindices引数は,ループ計算が行われる前に,選択された次元に沿った入力配列に対して,すべての入力が大きすぎないことを確認するためにチェックされます.ループの実装は,indicesの入力に要素がある限り何度でも繰り返されるreduceコードと非常によく似たコードを用いて処理されます.特に:基礎となる1次元計算ループに渡される最初の入力ポインタは,インデックス配列によって示される正しい位置にある入力配列を指します.さらに、基礎となる1次元ループに渡される出力ポインタと第2の入力ポインタは、メモリ内の同じ位置を指す。1次元計算ループのサイズは、現在のインデックスと次のインデックスとの差(現在のインデックスが最後のインデックスである場合、次のインデックスは、選択された次元に沿った配列の長さであると仮定される)に固定されている。このようにして,1次元ループは,指定されたインデックスに対するリダクションを実装します.</target>
        </trans-unit>
        <trans-unit id="7b43a1a08f82a3b68e452cbd124797f3f5925ce7" translate="yes" xml:space="preserve">
          <source>The reduced array. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to it.</source>
          <target state="translated">縮小された配列。 &lt;code&gt;out&lt;/code&gt; が指定された場合、 &lt;code&gt;r&lt;/code&gt; はそれへの参照です。</target>
        </trans-unit>
        <trans-unit id="d46d2581ba496f8d142f6a4f33e8d4c920183656" translate="yes" xml:space="preserve">
          <source>The reduced values. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">削減された値。 &lt;code&gt;out&lt;/code&gt; が指定されている場合、 &lt;code&gt;r&lt;/code&gt; は &lt;code&gt;out&lt;/code&gt; への参照です。</target>
        </trans-unit>
        <trans-unit id="3281b17df16674bbe40c7e1efbe54eb9d464c9ee" translate="yes" xml:space="preserve">
          <source>The regular expression. Default value is None, in which case the nose default (&lt;code&gt;re.compile(r'(?:^|[\b_\.%s-])[Tt]est' % os.sep)&lt;/code&gt;) is used. If &lt;code&gt;testmatch&lt;/code&gt; is a string, it is compiled to a regular expression first.</source>
          <target state="translated">正規表現。デフォルト値はNoneです。この場合、ノーズのデフォルト（ &lt;code&gt;re.compile(r'(?:^|[\b_\.%s-])[Tt]est' % os.sep)&lt;/code&gt; ）が使用されます。 &lt;code&gt;testmatch&lt;/code&gt; が文字列の場合、最初に正規表現にコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="bd0a0dfb20db6ba5c33bc9ca8a9fe1a01f1841cf" translate="yes" xml:space="preserve">
          <source>The relative performance on 64-bit Linux and 64-bit Windows is broadly similar.</source>
          <target state="translated">64ビットLinuxと64ビットWindowsでの相対的なパフォーマンスは大まかに似ています。</target>
        </trans-unit>
        <trans-unit id="7989f6ae8fcd58319573d40c534aa46fe0a84b96" translate="yes" xml:space="preserve">
          <source>The relative tolerance parameter (see Notes).</source>
          <target state="translated">相対的な許容範囲パラメータ(注記を参照)。</target>
        </trans-unit>
        <trans-unit id="dafb58a5db48e1dfe53af56fea252537c1419b45" translate="yes" xml:space="preserve">
          <source>The remainder of the division of &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; を &lt;code&gt;x2&lt;/code&gt; で割った余り。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="45876a6251302c94b60ea59421b48e6f10e76b32" translate="yes" xml:space="preserve">
          <source>The required alignment (bytes) of this data-type according to the compiler.</source>
          <target state="translated">コンパイラによるこのデータ型の必要なアラインメント(バイト数)。</target>
        </trans-unit>
        <trans-unit id="13ef7d8fa51bbebbe1bd1d3ed4d25fe31e0c8b11" translate="yes" xml:space="preserve">
          <source>The required data type(s) of the operands. If copying or buffering is enabled, the data will be converted to/from their original types.</source>
          <target state="translated">オペランドの必要なデータ型です。コピーまたはバッファリングが有効な場合、データは元の型に変換されます。</target>
        </trans-unit>
        <trans-unit id="0a7d78831f72627736ecbbe6affd07acc842cf9c" translate="yes" xml:space="preserve">
          <source>The required data-type. If None preserve the current dtype. If your application requires the data to be in native byteorder, include a byteorder specification as a part of the dtype specification.</source>
          <target state="translated">必要なデータ型。None の場合は、現在の dtype を保持します。アプリケーションでデータがネイティブのバイト順であることが必要な場合は、dtype 仕様の一部としてバイト順仕様を含めてください。</target>
        </trans-unit>
        <trans-unit id="bb180b40fee6aef0d41f93f405142f00de46dd28" translate="yes" xml:space="preserve">
          <source>The requirements list can be any of the following</source>
          <target state="translated">要件リストは以下のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="bf0f3cb688cf9b5f44c6080748b72439b46fb978" translate="yes" xml:space="preserve">
          <source>The reshaping operation cannot guarantee that a copy will not be made, to modify the shape in place, use &lt;code&gt;a.shape = s&lt;/code&gt;</source>
          <target state="translated">形状変更操作では、コピーが作成されないことを保証できません。形状を変更するには、 &lt;code&gt;a.shape = s&lt;/code&gt; 使用します</target>
        </trans-unit>
        <trans-unit id="efae226cd4ce4ec97472c40d085c0b19d6b0deb7" translate="yes" xml:space="preserve">
          <source>The rest of this page will give you a basic idea of how to add unit tests to modules in SciPy. It is extremely important for us to have extensive unit testing since this code is going to be used by scientists and researchers and is being developed by a large number of people spread across the world. So, if you are writing a package that you&amp;rsquo;d like to become part of SciPy, please write the tests as you develop the package. Also since much of SciPy is legacy code that was originally written without unit tests, there are still several modules that don&amp;rsquo;t have tests yet. Please feel free to choose one of these modules and develop tests for it as you read through this introduction.</source>
          <target state="translated">このページの残りの部分では、ユニットテストをSciPyのモジュールに追加する方法の基本的な考え方を説明します。このコードは科学者や研究者によって使用され、世界中に広がる多数の人々によって開発されているため、広範なユニットテストを実施することは非常に重要です。したがって、SciPyの一部になりたいパッケージを作成している場合は、パッケージを開発するときにテストを作成してください。また、SciPyの多くは元々ユニットテストなしで作成されたレガシーコードであるため、まだテストを行っていないモジュールがまだいくつかあります。この紹介を読みながら、これらのモジュールの1つを選択してテストを開発してください。</target>
        </trans-unit>
        <trans-unit id="90738a573063433b40a2bef8dfa08dda95ee95c6" translate="yes" xml:space="preserve">
          <source>The result can be used to construct a datetime that uses the same units as a timedelta</source>
          <target state="translated">その結果を使って、timedeltaと同じ単位を使ったdatetimeを構築することができます。</target>
        </trans-unit>
        <trans-unit id="8baf21a4c319c73c6c3f91016a95ecc1ae5e1dca" translate="yes" xml:space="preserve">
          <source>The result depends on the bit-width:</source>
          <target state="translated">結果はビット幅に依存します。</target>
        </trans-unit>
        <trans-unit id="7a004033c9a8a28e785dfe7afb00d43720c2d90c" translate="yes" xml:space="preserve">
          <source>The result is &lt;strong&gt;not&lt;/strong&gt; a MaskedArray!</source>
          <target state="translated">結果はMaskedArrayではあり&lt;strong&gt;ません&lt;/strong&gt;！</target>
        </trans-unit>
        <trans-unit id="88b2f160b598518e6df066363213cebfd6339e40" translate="yes" xml:space="preserve">
          <source>The result is an inverse for &lt;code&gt;a&lt;/code&gt; relative to the tensordot operation &lt;code&gt;tensordot(a, b, ind)&lt;/code&gt;, i. e., up to floating-point accuracy, &lt;code&gt;tensordot(tensorinv(a), a, ind)&lt;/code&gt; is the &amp;ldquo;identity&amp;rdquo; tensor for the tensordot operation.</source>
          <target state="translated">結果は、テンソルドット演算 &lt;code&gt;tensordot(a, b, ind)&lt;/code&gt; に対する &lt;code&gt;a&lt;/code&gt; の逆です。つまり、浮動小数点精度まで、 &lt;code&gt;tensordot(tensorinv(a), a, ind)&lt;/code&gt; は、テンソルドットの「同一性」テンソルです操作。</target>
        </trans-unit>
        <trans-unit id="d98fd654993b2c5bc8c34d84506f2eeb585bf55f" translate="yes" xml:space="preserve">
          <source>The result is padded to full bytes by inserting zero bits at the end.</source>
          <target state="translated">結果は、最後にゼロビットを挿入することでフルバイトにパディングされます。</target>
        </trans-unit>
        <trans-unit id="a05d82855a760b96ff01a98014b6f39cd92699f0" translate="yes" xml:space="preserve">
          <source>The result is returned as a boolean array.</source>
          <target state="translated">結果はブール値の配列として返されます。</target>
        </trans-unit>
        <trans-unit id="f9d8170d98950c22e6026933d7548298a3e52f98" translate="yes" xml:space="preserve">
          <source>The result is:</source>
          <target state="translated">結果が出ています。</target>
        </trans-unit>
        <trans-unit id="f485f36eec65ddcecdc4119f77e3da3d4540a73e" translate="yes" xml:space="preserve">
          <source>The result masks values that are masked in either &lt;code&gt;m1&lt;/code&gt; or &lt;code&gt;m2&lt;/code&gt;.</source>
          <target state="translated">結果は、 &lt;code&gt;m1&lt;/code&gt; または &lt;code&gt;m2&lt;/code&gt; のいずれかでマスクされている値をマスクします。</target>
        </trans-unit>
        <trans-unit id="93fabead91587e60c1a08bfee6b05728d77a4b94" translate="yes" xml:space="preserve">
          <source>The result may be a view on &lt;code&gt;m1&lt;/code&gt; or &lt;code&gt;m2&lt;/code&gt; if the other is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (i.e. False).</source>
          <target state="translated">結果は、他の&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;がない（つまりFalse）場合、 &lt;code&gt;m1&lt;/code&gt; または &lt;code&gt;m2&lt;/code&gt; のビューになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="12ea562d907c93ffb2a2a48a2ff38a17f82a53ed" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;cPickle.loads(strg)&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;cPickle.loads(strg)&lt;/code&gt; の結果が返されます。</target>
        </trans-unit>
        <trans-unit id="437933320e33dbd911c7ecb653e24b023c9820e4" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;x1 * 2**x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1 * 2**x2&lt;/code&gt; の結果。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="d200549129cf50987e2e3db04a3ddae4d86fd86e" translate="yes" xml:space="preserve">
          <source>The result of binning the input array. The length of &lt;code&gt;out&lt;/code&gt; is equal to &lt;code&gt;np.amax(x)+1&lt;/code&gt;.</source>
          <target state="translated">入力配列をビニングした結果。 &lt;code&gt;out&lt;/code&gt; の長さは &lt;code&gt;np.amax(x)+1&lt;/code&gt; に等しくなります。</target>
        </trans-unit>
        <trans-unit id="b74fd032efc344495e89da82ba5cefb838c783f0" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;a&lt;/code&gt; where &lt;code&gt;condition&lt;/code&gt; is True.</source>
          <target state="translated">マスキングの結果 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;condition&lt;/code&gt; 真であるが。</target>
        </trans-unit>
        <trans-unit id="2f9d4558b4365ff73c9c67d9671ab31c28b67b0f" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;x&lt;/code&gt; where approximately equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">マスキングの結果 &lt;code&gt;x&lt;/code&gt; にほぼ等しい &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c8d1e813923a2b2b410b1cadd9d90a6a3b27803" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;x&lt;/code&gt; where equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; と等しい &lt;code&gt;x&lt;/code&gt; をマスキングした結果。</target>
        </trans-unit>
        <trans-unit id="20b27291ef8731ea508bbd0cd5e12a0ad3afd15b" translate="yes" xml:space="preserve">
          <source>The result of repeating &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">を繰り返し &lt;code&gt;a&lt;/code&gt; 結果。</target>
        </trans-unit>
        <trans-unit id="5a3504d8e95aae2a9b20b749f6d2c5a3889c5102" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;code&gt;shape&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; の呼び出しの結果は直接戻されます。したがって、&lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt;の形状は完全に &lt;code&gt;function&lt;/code&gt; によって決まります。 &lt;code&gt;function&lt;/code&gt; がスカラー値を返す場合、&lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt;の &lt;code&gt;shape&lt;/code&gt; は形状パラメーターと一致しません。</target>
        </trans-unit>
        <trans-unit id="02a8e58b3d72e0b52f3592cd0fcb4ec46672a2f6" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; の呼び出しの結果は直接戻されます。したがって、&lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt;の形状は完全に &lt;code&gt;function&lt;/code&gt; によって決まります。 &lt;code&gt;function&lt;/code&gt; がスカラー値を返す場合、&lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt;の&lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;は形状パラメーターと一致しません。</target>
        </trans-unit>
        <trans-unit id="be63aee25a235ea7ecaebcc7084bf9b89e5f1ba3" translate="yes" xml:space="preserve">
          <source>The result of the inverse real 2-D FFT.</source>
          <target state="translated">逆実2次元FFTの結果。</target>
        </trans-unit>
        <trans-unit id="0a8c1e8c657004ada13d1bd67fea4f58af8cdb70" translate="yes" xml:space="preserve">
          <source>The result of the modulo operation for negative dividend and divisors is bound by conventions. For &lt;a href=&quot;#numpy.fmod&quot;&gt;&lt;code&gt;fmod&lt;/code&gt;&lt;/a&gt;, the sign of result is the sign of the dividend, while for &lt;a href=&quot;numpy.remainder#numpy.remainder&quot;&gt;&lt;code&gt;remainder&lt;/code&gt;&lt;/a&gt; the sign of the result is the sign of the divisor. The &lt;a href=&quot;#numpy.fmod&quot;&gt;&lt;code&gt;fmod&lt;/code&gt;&lt;/a&gt; function is equivalent to the Matlab(TM) &lt;code&gt;rem&lt;/code&gt; function.</source>
          <target state="translated">負の被除数と除数のモジュロ演算の結果は、慣例に拘束されます。ため&lt;a href=&quot;#numpy.fmod&quot;&gt; &lt;code&gt;fmod&lt;/code&gt; &lt;/a&gt;ためながら、結果の符号は、被除数の符号である&lt;a href=&quot;numpy.remainder#numpy.remainder&quot;&gt; &lt;code&gt;remainder&lt;/code&gt; &lt;/a&gt;結果の符号は除数の符号です。&lt;a href=&quot;#numpy.fmod&quot;&gt; &lt;code&gt;fmod&lt;/code&gt; &lt;/a&gt;関数は、MATLAB（登録商標）と同等である &lt;code&gt;rem&lt;/code&gt; 機能。</target>
        </trans-unit>
        <trans-unit id="432755e899e9d369003d6c1f79ef56f8c75f0660" translate="yes" xml:space="preserve">
          <source>The result of the real 2-D FFT.</source>
          <target state="translated">実質2次元FFTの結果。</target>
        </trans-unit>
        <trans-unit id="a62988dd4c556a700006b20bcac64bfa1f21b000" translate="yes" xml:space="preserve">
          <source>The result of this is always a 2d array, with a row for each non-zero element.</source>
          <target state="translated">この結果は常に2次元配列となり、0以外の要素にはそれぞれ行が入ります。</target>
        </trans-unit>
        <trans-unit id="552e732df1a7e97a3ac3793f40b01156b930c9d2" translate="yes" xml:space="preserve">
          <source>The result of trimming the input. The input data type is preserved.</source>
          <target state="translated">入力をトリミングした結果です。入力データ型は保存されます。</target>
        </trans-unit>
        <trans-unit id="0ff6806d85e8fabd807a03dd151b7e1cdd284df8" translate="yes" xml:space="preserve">
          <source>The result type.</source>
          <target state="translated">結果の種類。</target>
        </trans-unit>
        <trans-unit id="e2a369eb25dfa6d23e15865ad12a81c98b2538db" translate="yes" xml:space="preserve">
          <source>The result.</source>
          <target state="translated">結果が出ました。</target>
        </trans-unit>
        <trans-unit id="d1fb43fabbedcad07c574b0e98cbace4463e697f" translate="yes" xml:space="preserve">
          <source>The resulting approximation of</source>
          <target state="translated">の結果として得られる近似値は</target>
        </trans-unit>
        <trans-unit id="a4450860735a4299b5638f4df95ccd877c9615a2" translate="yes" xml:space="preserve">
          <source>The resulting array therefore has a value &lt;code&gt;fn(x, y, z)&lt;/code&gt; at coordinate &lt;code&gt;(x, y, z)&lt;/code&gt;.</source>
          <target state="translated">したがって、結果の配列は、座標 &lt;code&gt;(x, y, z)&lt;/code&gt; 値 &lt;code&gt;fn(x, y, z)&lt;/code&gt; を持ちます。</target>
        </trans-unit>
        <trans-unit id="8e45fa029de06ce207816940e254f28318e174ec" translate="yes" xml:space="preserve">
          <source>The resulting path indicates which terms of the input contraction should be contracted first, the result of this contraction is then appended to the end of the contraction list. This list can then be iterated over until all intermediate contractions are complete.</source>
          <target state="translated">結果として得られるパスは、入力された縮約のどの項を最初に縮約すべきかを示し、この縮約の結果が縮約リストの最後に追加されます。このリストは、すべての中間縮約が完了するまで繰り返し実行されます。</target>
        </trans-unit>
        <trans-unit id="4e44a556cdbd9e08c1c73c688efe96d93b4a9c2d" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100 higher degrees may be problematic. The weights are determined by using the fact that</source>
          <target state="translated">結果は100度までしか検証されていませんが、問題があるかもしれません。という事実を利用して重みを決定しています。</target>
        </trans-unit>
        <trans-unit id="ef4a7d2bf5791e871493bd9bc1998dc73f56d092" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100, higher degrees may be problematic. For Gauss-Chebyshev there are closed form solutions for the sample points and weights. If n = &lt;code&gt;deg&lt;/code&gt;, then</source>
          <target state="translated">結果は100度までしかテストされていないため、より高い度数では問題が生じる可能性があります。Gauss-Chebyshevの場合、サンプルポイントと重みの閉形式の解があります。n = &lt;code&gt;deg&lt;/code&gt; の場合、</target>
        </trans-unit>
        <trans-unit id="7a2a5f718e6f28fd9a2d71c1fb3ee2ee9fe5b2fb" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100, higher degrees may be problematic. The weights are determined by using the fact that</source>
          <target state="translated">結果は度数100までしかテストされていないので、それ以上の度数は問題があるかもしれません。重みは、次のような事実を利用して決定されます。</target>
        </trans-unit>
        <trans-unit id="af6fbd4d24683930cbf1a134289a3df4c1b144c3" translate="yes" xml:space="preserve">
          <source>The results will be placed in this array. It may be the input array for in-place clipping. &lt;code&gt;out&lt;/code&gt; must be of the right shape to hold the output. Its type is preserved.</source>
          <target state="translated">結果はこの配列に配置されます。インプレースクリッピングの入力配列になる場合があります。 &lt;code&gt;out&lt;/code&gt; 出力を保持する権利形状のものでなければなりません。そのタイプは保持されます。</target>
        </trans-unit>
        <trans-unit id="9002868afc12284eedaa4f924eaaabb6a7944154" translate="yes" xml:space="preserve">
          <source>The return type will always be an inexact (i.e. floating point) scalar type, even if all the arrays are integer arrays. If one of the inputs is an integer array, the minimum precision type that is returned is a 64-bit floating point dtype.</source>
          <target state="translated">すべての配列が整数配列であっても,戻り値の型は常に不正確な(つまり浮動小数点の)スカラ型になります.入力の1つが整数配列の場合、返される最小精度の型は64ビット浮動小数点dtypeです。</target>
        </trans-unit>
        <trans-unit id="273dde020fc2e47183998cc14b3fb20e4a9436a7" translate="yes" xml:space="preserve">
          <source>The return value is 0 on success, -1 on failure.</source>
          <target state="translated">成功した場合は0、失敗した場合は-1を返します。</target>
        </trans-unit>
        <trans-unit id="95baf9f3feb186151992e17419a9d52bee50a218" translate="yes" xml:space="preserve">
          <source>The return value is the same shape and type as &lt;code&gt;M&lt;/code&gt;; if the exponent is positive or zero then the type of the elements is the same as those of &lt;code&gt;M&lt;/code&gt;. If the exponent is negative the elements are floating-point.</source>
          <target state="translated">戻り値は &lt;code&gt;M&lt;/code&gt; と同じ形状と型です。指数が正またはゼロの場合、要素のタイプは &lt;code&gt;M&lt;/code&gt; のタイプと同じです。指数が負の場合、要素は浮動小数点です。</target>
        </trans-unit>
        <trans-unit id="55801c938cbd16156c4c8c48d17f11e40e4107d9" translate="yes" xml:space="preserve">
          <source>The return value of failed converter functions which are called using the &amp;ldquo;O&amp;amp;&amp;rdquo; syntax in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;-like functions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; の&lt;/a&gt;ような関数で「O＆」構文を使用して呼び出された、失敗したコンバーター関数の戻り値。</target>
        </trans-unit>
        <trans-unit id="41e4fb8b6c4e49bb724d556b26ed34481cfcd6dd" translate="yes" xml:space="preserve">
          <source>The return value of successful converter functions which are called using the &amp;ldquo;O&amp;amp;&amp;rdquo; syntax in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;-like functions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; の&lt;/a&gt;ような関数で「O＆」構文を使用して呼び出された、成功したコンバーター関数の戻り値。</target>
        </trans-unit>
        <trans-unit id="c05aab266b5f8aae47c5e7319a883da33ec4e284" translate="yes" xml:space="preserve">
          <source>The return value, False if &lt;code&gt;x&lt;/code&gt; is of a complex type.</source>
          <target state="translated">戻り値、 &lt;code&gt;x&lt;/code&gt; が複合型の場合はFalse 。</target>
        </trans-unit>
        <trans-unit id="c002d9b8869cd4388cf5943fa7426632d76c13b5" translate="yes" xml:space="preserve">
          <source>The return value, True if &lt;code&gt;x&lt;/code&gt; is of a complex type or has at least one complex element.</source>
          <target state="translated">戻り値、 &lt;code&gt;x&lt;/code&gt; が複合型の場合、または少なくとも1つの複合要素がある場合はTrue 。</target>
        </trans-unit>
        <trans-unit id="8cacfcdc238ffe8ba32e3f60b54d5d84f6258480" translate="yes" xml:space="preserve">
          <source>The returned array has the same type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">返される配列は、同じタイプ有します。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8984b85b3f1b178d24103374b554ddde5426110f" translate="yes" xml:space="preserve">
          <source>The returned array is always 1D.</source>
          <target state="translated">返される配列は常に1Dです。</target>
        </trans-unit>
        <trans-unit id="59afb62c6311159c3a4c4a5a09d0fcb3d683db81" translate="yes" xml:space="preserve">
          <source>The returned array is always a structured array, and is constructed from all matches of the regular expression in the file. Groups in the regular expression are converted to fields of the structured array.</source>
          <target state="translated">返される配列は常に構造化された配列で、ファイル内の正規表現のすべてのマッチから構築されます。正規表現のグループは構造化配列のフィールドに変換されます。</target>
        </trans-unit>
        <trans-unit id="235ae9f13128943772ff554e126bc69621884d0e" translate="yes" xml:space="preserve">
          <source>The returned array will be guaranteed to have the listed requirements by making a copy if needed.</source>
          <target state="translated">返された配列は、必要に応じてコピーを作成することで、リストされた要件を持つことが保証されます。</target>
        </trans-unit>
        <trans-unit id="4d7c736b03b1eeb7cc2b9172d888763588690bd3" translate="yes" xml:space="preserve">
          <source>The returned array will have at least &lt;code&gt;ndmin&lt;/code&gt; dimensions. Otherwise mono-dimensional axes will be squeezed. Legal values: 0 (default), 1 or 2.</source>
          <target state="translated">返される配列には、少なくとも &lt;code&gt;ndmin&lt;/code&gt; の次元があります。そうしないと、1次元の軸が圧縮されます。有効な値：0（デフォルト）、1または2。</target>
        </trans-unit>
        <trans-unit id="0991fc7713b9227f260fa7eb1775e9a559dcb08f" translate="yes" xml:space="preserve">
          <source>The returned class can be of different type than the current instance and/or have a different domain and/or different window.</source>
          <target state="translated">返されるクラスは、現在のインスタンスとは異なるタイプのものであってもよいし、異なるドメインおよび/または異なるウィンドウを持つものであってもよい。</target>
        </trans-unit>
        <trans-unit id="f40fdf0f51a86b8b90c8d1563cabe3126d1130f1" translate="yes" xml:space="preserve">
          <source>The returned float array &lt;code&gt;f&lt;/code&gt; contains the frequency bin centers in cycles per unit of the sample spacing (with zero at the start). For instance, if the sample spacing is in seconds, then the frequency unit is cycles/second.</source>
          <target state="translated">返されるfloat配列 &lt;code&gt;f&lt;/code&gt; には、周波数間隔の中心がサンプル間隔の単位あたりのサイクルで含まれます（最初はゼロ）。たとえば、サンプル間隔が秒単位の場合、周波数の単位はサイクル/秒です。</target>
        </trans-unit>
        <trans-unit id="235d36eec348db0a4ce24e42c9d6a7df17b250d1" translate="yes" xml:space="preserve">
          <source>The returned indices will be valid to access arrays of shape (n, n).</source>
          <target state="translated">返されたインデックスは、シェイプ(n,n)の配列にアクセスするために有効になります。</target>
        </trans-unit>
        <trans-unit id="ae4549a46a428a48cedb9424b21a41ed06873386" translate="yes" xml:space="preserve">
          <source>The returned list contains array(s) of dtype double, complex double, or object. A 1-d argument of shape &lt;code&gt;(N,)&lt;/code&gt; is parsed into &lt;code&gt;N&lt;/code&gt; arrays of size one; a 2-d argument of shape &lt;code&gt;(M,N)&lt;/code&gt; is parsed into &lt;code&gt;M&lt;/code&gt; arrays of size &lt;code&gt;N&lt;/code&gt; (i.e., is &amp;ldquo;parsed by row&amp;rdquo;); and a higher dimensional array raises a Value Error if it is not first reshaped into either a 1-d or 2-d array.</source>
          <target state="translated">返されるリストには、dtype double、complex double、またはobjectの配列が含まれています。形状 &lt;code&gt;(N,)&lt;/code&gt; の1次元引数は、サイズ1の &lt;code&gt;N&lt;/code&gt; 個の配列に解析されます。形状 &lt;code&gt;(M,N)&lt;/code&gt; 2次元引数は、サイズ &lt;code&gt;N&lt;/code&gt; の &lt;code&gt;M&lt;/code&gt; 配列に解析されます（つまり、「行で解析」されます）。より高次元の配列は、最初に1次元または2次元配列に再形成されない場合、値エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="14f1e30e33046331e7dfbbcb8096ad0d5112d69f" translate="yes" xml:space="preserve">
          <source>The returned object is an object of Python-type &lt;em&gt;subtype&lt;/em&gt;, which must be a subtype of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. The array has &lt;em&gt;nd&lt;/em&gt; dimensions, described by &lt;em&gt;dims&lt;/em&gt;. The data-type descriptor of the new array is &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="translated">返されるオブジェクトはPythonタイプの&lt;em&gt;サブタイプの&lt;/em&gt;オブジェクトであり、&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; の&lt;/a&gt;&lt;em&gt;サブタイプ&lt;/em&gt;である必要があります。配列には、&lt;em&gt;dims&lt;/em&gt;で記述される&lt;em&gt;nd&lt;/em&gt;次元があります。新しい配列のデータ型記述子は&lt;em&gt;descr&lt;/em&gt;です。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5d88cddc6712bcffcc47387ee400aa7949d299dc" translate="yes" xml:space="preserve">
          <source>The returned order &lt;code&gt;m&lt;/code&gt; antiderivative &lt;code&gt;P&lt;/code&gt; of polynomial &lt;code&gt;p&lt;/code&gt; satisfies</source>
          <target state="translated">返された次数 &lt;code&gt;m&lt;/code&gt; 不定積分 &lt;code&gt;P&lt;/code&gt; 多項式の &lt;code&gt;p&lt;/code&gt; 個の満足</target>
        </trans-unit>
        <trans-unit id="0b8999800a1f602548a03b4247be14d85063c532" translate="yes" xml:space="preserve">
          <source>The returned pointer will keep a reference to the array.</source>
          <target state="translated">返されたポインタは配列への参照を保持します。</target>
        </trans-unit>
        <trans-unit id="592b730c2fcc65333034a0c7238210b05d5a5c20" translate="yes" xml:space="preserve">
          <source>The returned tuple can be passed as the second argument of &lt;code&gt;numpy.datetime64&lt;/code&gt; and &lt;code&gt;numpy.timedelta64&lt;/code&gt;.</source>
          <target state="translated">返されるタプルは、 &lt;code&gt;numpy.datetime64&lt;/code&gt; および &lt;code&gt;numpy.timedelta64&lt;/code&gt; の 2番目の引数として渡すことができます。</target>
        </trans-unit>
        <trans-unit id="f91874be1de458c40a0f1f04bc921bf313bf20d4" translate="yes" xml:space="preserve">
          <source>The returned tuple has the following items:</source>
          <target state="translated">返されたタプルには以下の項目があります。</target>
        </trans-unit>
        <trans-unit id="cef76c21baa4e56901ef823fceedd7a7068daf4e" translate="yes" xml:space="preserve">
          <source>The returned type character must represent the smallest size dtype such that an array of the returned type can handle the data from an array of all types in &lt;code&gt;typechars&lt;/code&gt; (or if &lt;code&gt;typechars&lt;/code&gt; is an array, then its dtype.char).</source>
          <target state="translated">返される型の文字は、返される型の配列が &lt;code&gt;typechars&lt;/code&gt; のすべての型の配列からのデータを処理できるように、最小サイズのdtypeを表す必要があります（ &lt;code&gt;typechars&lt;/code&gt; が配列の場合は、そのdtype.char）。</target>
        </trans-unit>
        <trans-unit id="4fcc4213866e3a2e0117cc077e63fcf825ea6d85" translate="yes" xml:space="preserve">
          <source>The returned ufunc always returns PyObject arrays.</source>
          <target state="translated">返された ufunc は常に PyObject の配列を返します。</target>
        </trans-unit>
        <trans-unit id="15355fac5e58f997eedbca2c4b98e86da4be8c2c" translate="yes" xml:space="preserve">
          <source>The returned values define a linear map &lt;code&gt;off + scl*x&lt;/code&gt; that is applied to the input arguments before the series is evaluated. The map depends on the &lt;code&gt;domain&lt;/code&gt; and &lt;code&gt;window&lt;/code&gt;; if the current &lt;code&gt;domain&lt;/code&gt; is equal to the &lt;code&gt;window&lt;/code&gt; the resulting map is the identity. If the coefficients of the series instance are to be used by themselves outside this class, then the linear function must be substituted for the &lt;code&gt;x&lt;/code&gt; in the standard representation of the base polynomials.</source>
          <target state="translated">戻り値は、シリーズが評価される前に入力引数に適用される線形マップ &lt;code&gt;off + scl*x&lt;/code&gt; を定義します。マップは &lt;code&gt;domain&lt;/code&gt; と &lt;code&gt;window&lt;/code&gt; によって異なります。現在の &lt;code&gt;domain&lt;/code&gt; が &lt;code&gt;window&lt;/code&gt; と等しい場合、結果のマップはアイデンティティです。系列インスタンスの係数がこのクラスの外で単独で使用される場合は、線形関数を基本多項式の標準表現の &lt;code&gt;x&lt;/code&gt; に置き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="ee620d4452ada0e1d6c1803fadfa839462d12739" translate="yes" xml:space="preserve">
          <source>The root estimates are obtained as the eigenvalues of the companion matrix, Roots far from the origin of the complex plane may have large errors due to the numerical instability of the power series for such values. Roots with multiplicity greater than 1 will also show larger errors as the value of the series near such points is relatively insensitive to errors in the roots. Isolated roots near the origin can be improved by a few iterations of Newton&amp;rsquo;s method.</source>
          <target state="translated">根の推定値は、コンパニオンマトリックスの固有値として取得されます。複素平面の原点から遠い根には、そのような値のべき級数の数値的不安定性のために大きな誤差がある場合があります。多重度が1より大きい根も、そのような点の近くの系列の値が根の誤差に比較的鈍感であるため、より大きい誤差を示します。原点近くの孤立した根は、ニュートン法を数回繰り返すことで改善できます。</target>
        </trans-unit>
        <trans-unit id="f62c87e72745436aa10f6d1a92b0a21eb2cc7b33" translate="yes" xml:space="preserve">
          <source>The root estimates are obtained as the eigenvalues of the companion matrix, Roots far from the origin of the complex plane may have large errors due to the numerical instability of the series for such values. Roots with multiplicity greater than 1 will also show larger errors as the value of the series near such points is relatively insensitive to errors in the roots. Isolated roots near the origin can be improved by a few iterations of Newton&amp;rsquo;s method.</source>
          <target state="translated">根の推定値は、コンパニオンマトリックスの固有値として取得されます。複素平面の原点から遠い根は、そのような値の系列の数値的不安定性のために大きな誤差を持っている可能性があります。多重度が1より大きい根も、そのような点の近くの系列の値が根の誤差に比較的鈍感であるため、より大きい誤差を示します。原点近くの孤立した根は、ニュートン法を数回繰り返すことで改善できます。</target>
        </trans-unit>
        <trans-unit id="a8ae81d114b6feba67040d0b0dda1df226f1fa7e" translate="yes" xml:space="preserve">
          <source>The roots of the polynomial, where self(x) == 0</source>
          <target state="translated">self(x)==0である多項式の根</target>
        </trans-unit>
        <trans-unit id="b31543f4d0be4f9892b87954c40031df062dff89" translate="yes" xml:space="preserve">
          <source>The row dimension of the arrays for which the returned indices will be valid.</source>
          <target state="translated">返されたインデックスが有効になる配列の行の次元。</target>
        </trans-unit>
        <trans-unit id="0cdec07351f87c4df86a480e3a89d1fead72ecd2" translate="yes" xml:space="preserve">
          <source>The rtype argument specifies the data-type the reduction should take place over. This is important if the data-type of the array is not &amp;ldquo;large&amp;rdquo; enough to handle the output. By default, all integer data-types are made at least as large as &lt;a href=&quot;c-api.dtype#c.NPY_LONG&quot;&gt;&lt;code&gt;NPY_LONG&lt;/code&gt;&lt;/a&gt; for the &amp;ldquo;add&amp;rdquo; and &amp;ldquo;multiply&amp;rdquo; ufuncs (which form the basis for mean, sum, cumsum, prod, and cumprod functions).</source>
          <target state="translated">rtype引数は、削減が行われるデータ型を指定します。配列のデータ型が出力を処理するのに十分な大きさでない場合、これは重要です。デフォルトでは、すべての整数データ型は、少なくとも限り大きく作られる&lt;a href=&quot;c-api.dtype#c.NPY_LONG&quot;&gt; &lt;code&gt;NPY_LONG&lt;/code&gt; &lt;/a&gt;「追加」と（平均、合計、CUMSUM、PROD、及びcumprod機能のための基礎を形成する）、「乗算」ufuncsため。</target>
        </trans-unit>
        <trans-unit id="3014977f10c304b722035fb1a265596f0e833693" translate="yes" xml:space="preserve">
          <source>The rules for ABI and API compatibilities can be summarized as follows:</source>
          <target state="translated">ABIとAPIの互換性に関するルールをまとめると以下のようになります。</target>
        </trans-unit>
        <trans-unit id="db5c92fbe4ce9110548aea4ebd5e7c863e8e7523" translate="yes" xml:space="preserve">
          <source>The same analysis could be done with several different interest rates and/or payments and/or total amounts to produce an entire table.</source>
          <target state="translated">同じ分析を、いくつかの異なる金利および/または支払額および/または合計額で行って、表全体を作成することができます。</target>
        </trans-unit>
        <trans-unit id="48a74e2709e394bc98ff4e370f8920b6550d09a0" translate="yes" xml:space="preserve">
          <source>The same function can operate on a 4-D array:</source>
          <target state="translated">4次元配列でも同じ機能を動作させることができます。</target>
        </trans-unit>
        <trans-unit id="0259137762b94ac22ad991901b42b9be660a1c59" translate="yes" xml:space="preserve">
          <source>The same works for max and min, if you expand the dimensions:</source>
          <target state="translated">寸法を拡大すれば、maxとminでも同じように動作します。</target>
        </trans-unit>
        <trans-unit id="2941e8dc3350840406ccff2f87675580f31546c3" translate="yes" xml:space="preserve">
          <source>The sample points corresponding to the &lt;code&gt;y&lt;/code&gt; values. If &lt;code&gt;x&lt;/code&gt; is None, the sample points are assumed to be evenly spaced &lt;code&gt;dx&lt;/code&gt; apart. The default is None.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 値に対応するサンプルポイント。場合 &lt;code&gt;x&lt;/code&gt; Noneです、サンプルポイントが等間隔されているものとする &lt;code&gt;dx&lt;/code&gt; 離れ。デフォルトは「なし」です。</target>
        </trans-unit>
        <trans-unit id="52ca25ab3ba5f07f393e1c15a4222278fa9f69d6" translate="yes" xml:space="preserve">
          <source>The scale of the gamma distribution. Must be non-negative. Default is equal to 1.</source>
          <target state="translated">ガンマ分布のスケール。非負でなければなりません。デフォルトは1です。</target>
        </trans-unit>
        <trans-unit id="db0a2a364021746365e2e2dca54712719a934f9d" translate="yes" xml:space="preserve">
          <source>The scale parameter of the distribution. Default is 1. Must be non- negative.</source>
          <target state="translated">分布のスケール・パラメータ。デフォルトは1です。</target>
        </trans-unit>
        <trans-unit id="da19b6d80b0b211e043d20a99e868d2264fb18da" translate="yes" xml:space="preserve">
          <source>The scale parameter,</source>
          <target state="translated">スケールパラメータ。</target>
        </trans-unit>
        <trans-unit id="7f0e6c0ce58755cae988a618ed26819ae121acf3" translate="yes" xml:space="preserve">
          <source>The scipy implementation is recommended over this function: it is a proper ufunc written in C, and more than an order of magnitude faster.</source>
          <target state="translated">scipy の実装はこの関数よりも推奨されます:C で書かれた適切な ufunc であり、桁違いに高速です。</target>
        </trans-unit>
        <trans-unit id="f1d1e93a16e6953d6dc31578f1bc0e4185a42885" translate="yes" xml:space="preserve">
          <source>The second element, &lt;em&gt;field_dtype&lt;/em&gt;, can be anything that can be interpreted as a data-type.</source>
          <target state="translated">2番目の要素である&lt;em&gt;field_dtype&lt;/em&gt;は、データ型として解釈できるものであれば何でも&lt;em&gt;かまいませ&lt;/em&gt;ん。</target>
        </trans-unit>
        <trans-unit id="4ebced32cc87e2c3435e9151b36d6b3c2cfaf845" translate="yes" xml:space="preserve">
          <source>The second is to set the error-handler to &amp;lsquo;log&amp;rsquo;, using &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;. Floating-point errors then trigger a call to the &amp;lsquo;write&amp;rsquo; method of the provided object.</source>
          <target state="translated">2つ目は、&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;を使用して、エラーハンドラーを 'log'に設定することです。次に、浮動小数点エラーにより、提供されたオブジェクトの「write」メソッドの呼び出しがトリガーされます。</target>
        </trans-unit>
        <trans-unit id="6f31ccc451074791f12a3d0394615bd3d0e3cdd2" translate="yes" xml:space="preserve">
          <source>The second issue to understand is how indices correspond to the order the array is stored in memory. In Fortran the first index is the most rapidly varying index when moving through the elements of a two dimensional array as it is stored in memory. If you adopt the matrix convention for indexing, then this means the matrix is stored one column at a time (since the first index moves to the next row as it changes). Thus Fortran is considered a Column-major language. C has just the opposite convention. In C, the last index changes most rapidly as one moves through the array as stored in memory. Thus C is a Row-major language. The matrix is stored by rows. Note that in both cases it presumes that the matrix convention for indexing is being used, i.e., for both Fortran and C, the first index is the row. Note this convention implies that the indexing convention is invariant and that the data order changes to keep that so.</source>
          <target state="translated">理解すべき2番目の問題は,配列がメモリに格納されている順序にインデックスがどのように対応するかということです.Fortranでは,メモリに格納されている2次元配列の要素を移動する際に,最初のインデックスが最も急激に変化するインデックスとなります.インデックス付けに行列の規則を採用すると、行列が一度に1列ずつ格納されることを意味します(最初のインデックスが変化すると次の行に移動するので)。このようにして、Fortranは列メジャー言語と考えられています。C言語は,ちょうどその逆の規則を持っています.C言語では、メモリに格納されている配列を移動する際に、最後のインデックスが最も速く変化します。したがって,C は行メジャー言語です.行列は行によって格納されます.どちらの場合も,行列のインデックス付けの規則が使用されていることを前提としていることに注意してください.この規則は,インデックス付けの規則が不変であることと,それを維持するためにデータの順序が変化することを意味していることに注意してください.</target>
        </trans-unit>
        <trans-unit id="8eb125eefbda7190ce972cb7d8270d5ae89dc7b7" translate="yes" xml:space="preserve">
          <source>The self.paths(&amp;hellip;) method is applied to all lists that may contain paths.</source>
          <target state="translated">self.paths（&amp;hellip;）メソッドは、パスを含む可能性のあるすべてのリストに適用されます。</target>
        </trans-unit>
        <trans-unit id="8c7148486ba5b770e99fd7463ec63c216dee7366" translate="yes" xml:space="preserve">
          <source>The separation between elements for each dimension (the &amp;lsquo;stride&amp;rsquo;). This does not have to be a multiple of the element size</source>
          <target state="translated">各次元の要素間の分離（「ストライド」）。これは要素サイズの倍数である必要はありません</target>
        </trans-unit>
        <trans-unit id="9cd2ff64b895aeb8d0b16f3694ac2aea08560437" translate="yes" xml:space="preserve">
          <source>The series in this context are finite sums of the corresponding polynomial basis functions multiplied by coefficients. For instance, a power series looks like</source>
          <target state="translated">この文脈での級数は、対応する多項式基底関数の有限和に係数を掛けたものです。例えば、累乗級数は次のようになります。</target>
        </trans-unit>
        <trans-unit id="9285a776c2a659ee75e7938ac17b155070381205" translate="yes" xml:space="preserve">
          <source>The series instance to be converted.</source>
          <target state="translated">変換対象のシリーズインスタンス。</target>
        </trans-unit>
        <trans-unit id="89a518ad1f6d727d2464d8f222f198c518f126e6" translate="yes" xml:space="preserve">
          <source>The series is reduced to degree &lt;code&gt;deg&lt;/code&gt; by discarding the high order terms. The value of &lt;code&gt;deg&lt;/code&gt; must be a non-negative integer.</source>
          <target state="translated">級数は、高次の項を破棄することにより、 &lt;code&gt;deg&lt;/code&gt; 度まで削減されます。 &lt;code&gt;deg&lt;/code&gt; の値は負でない整数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="adbbacc122f5859d958a7eb7009d4955c1c2c537" translate="yes" xml:space="preserve">
          <source>The series is reduced to length &lt;code&gt;size&lt;/code&gt; by discarding the high degree terms. The value of &lt;code&gt;size&lt;/code&gt; must be a positive integer.</source>
          <target state="translated">シリーズは、高次の項を破棄することにより、長さ &lt;code&gt;size&lt;/code&gt; 縮小されます。 &lt;code&gt;size&lt;/code&gt; の値は正の整数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="38262a9c7d66cebff5a42640a9df021a775761be" translate="yes" xml:space="preserve">
          <source>The set of available codecs comes from the Python standard library, and may be extended at runtime. For more information, see the &lt;a href=&quot;https://docs.python.org/dev/library/codecs.html#module-codecs&quot;&gt;&lt;code&gt;codecs&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">利用可能なコーデックのセットは、Python標準ライブラリからのもので、実行時に拡張できます。詳細については、&lt;a href=&quot;https://docs.python.org/dev/library/codecs.html#module-codecs&quot;&gt; &lt;code&gt;codecs&lt;/code&gt; &lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="a717e3302b8636b7790364bffe6b5a183f3f6e7f" translate="yes" xml:space="preserve">
          <source>The set of available codecs comes from the Python standard library, and may be extended at runtime. For more information, see the codecs module.</source>
          <target state="translated">利用可能なコーデックのセットはPython標準ライブラリから来ており、実行時に拡張される可能性があります。詳細はコーデックモジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="f3119f479b7378be171f9e5461ebc7ae89470f50" translate="yes" xml:space="preserve">
          <source>The set of characters that the returned character is chosen from. The default set is &amp;lsquo;GDFgdf&amp;rsquo;.</source>
          <target state="translated">返される文字が選択される文字のセット。デフォルトのセットは「GDFgdf」です。</target>
        </trans-unit>
        <trans-unit id="a3a4541aef2e0618e33ebd5e18d9c022d28bcaa8" translate="yes" xml:space="preserve">
          <source>The set of functions that convert the data of a column to a value. The converters can also be used to provide a default value for missing data: &lt;code&gt;converters = {3: lambda s: float(s or 0)}&lt;/code&gt;.</source>
          <target state="translated">列のデータを値に変換する関数のセット。コンバーターは、欠落データのデフォルト値を提供するためにも使用できます： &lt;code&gt;converters = {3: lambda s: float(s or 0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e26f5391f4384da7c676eb1e9d468550abb0eb1" translate="yes" xml:space="preserve">
          <source>The set of int values is not a subset of the uint values for types with the same number of bits, something not reflected in &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt;, but handled as a special case in PyArray_ResultType.</source>
          <target state="translated">int値のセットは、同じビット数の型のuint値のサブセットではありません。これは、&lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; &lt;/a&gt;には反映されませんが、PyArray_ResultTypeでは特殊なケースとして処理されます。</target>
        </trans-unit>
        <trans-unit id="e76841686484db8628455fd162b8197749bc84c1" translate="yes" xml:space="preserve">
          <source>The set of int values is not a subset of the uint values for types with the same number of bits, something not reflected in &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt;, but handled as a special case in &lt;a href=&quot;#numpy.result_type&quot;&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">int値のセットは、同じビット数の型のuint値のサブセットではなく、&lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; &lt;/a&gt;には反映されませんが、&lt;a href=&quot;#numpy.result_type&quot;&gt; &lt;code&gt;result_type&lt;/code&gt; で&lt;/a&gt;特殊なケースとして処理されます。</target>
        </trans-unit>
        <trans-unit id="561107923e2d5ef74733b059316312382b1f95e9" translate="yes" xml:space="preserve">
          <source>The set of strings corresponding to missing data.</source>
          <target state="translated">欠損データに対応する文字列の集合。</target>
        </trans-unit>
        <trans-unit id="3c3fdff23bd130c5708b43d7769884cc7638d9dc" translate="yes" xml:space="preserve">
          <source>The set of values to be used as default when the data are missing.</source>
          <target state="translated">データが欠落しているときにデフォルトで使用する値のセットです。</target>
        </trans-unit>
        <trans-unit id="40c5a46b247f5eb179525001f8ba092f80c0ed2a" translate="yes" xml:space="preserve">
          <source>The setup function for all three methods is &lt;code&gt;construct_reduce&lt;/code&gt;. This function creates a reducing loop object and fills it with parameters needed to complete the loop. All of the methods only work on ufuncs that take 2-inputs and return 1 output. Therefore, the underlying 1-D loop is selected assuming a signature of [ &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt; ] where &lt;code&gt;otype&lt;/code&gt; is the requested reduction data-type. The buffer size and error handling is then retrieved from (per-thread) global storage. For small arrays that are mis-aligned or have incorrect data-type, a copy is made so that the un-buffered section of code is used. Then, the looping strategy is selected. If there is 1 element or 0 elements in the array, then a simple looping method is selected. If the array is not mis-aligned and has the correct data-type, then strided looping is selected. Otherwise, buffered looping must be performed. Looping parameters are then established, and the return array is constructed. The output array is of a different shape depending on whether the method is reduce, accumulate, or reduceat. If an output array is already provided, then it&amp;rsquo;s shape is checked. If the output array is not C-contiguous, aligned, and of the correct data type, then a temporary copy is made with the WRITEBACKIFCOPY flag set. In this way, the methods will be able to work with a well-behaved output array but the result will be copied back into the true output array when &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called at function completion. Finally, iterators are set up to loop over the correct axis (depending on the value of axis provided to the method) and the setup routine returns to the actual computation routine.</source>
          <target state="translated">3つのメソッドすべてのセットアップ関数は、 &lt;code&gt;construct_reduce&lt;/code&gt; です。この関数は、縮小ループオブジェクトを作成し、ループを完了するために必要なパラメーターをそのオブジェクトに入力します。すべてのメソッドは、2つの入力を取り、1つの出力を返すufuncでのみ機能します。したがって、[ &lt;code&gt;otype&lt;/code&gt; 、 &lt;code&gt;otype&lt;/code&gt; 、 &lt;code&gt;otype&lt;/code&gt; ]のシグネチャを想定して、基礎となる1次元ループが選択されます。ここで &lt;code&gt;otype&lt;/code&gt; 要求された削減データタイプです。次に、バッファサイズとエラー処理が（スレッドごとの）グローバルストレージから取得されます。整列が正しくない、またはデータ型が正しくない小さな配列の場合、バッファリングされていないコードのセクションが使用されるようにコピーが作成されます。次に、ループ戦略が選択されます。配列に1要素または0要素がある場合、単純なループ方法が選択されます。配列が正しく整列されておらず、正しいデータ型である場合、ストライドループが選択されます。それ以外の場合は、バッファリングされたループを実行する必要があります。次に、ループパラメーターが確立され、戻り配列が作成されます。出力配列は、メソッドがreduce、accumulate、reduceatのいずれであるかによって異なる形状になります。出力配列がすでに提供されている場合は、その形状がチェックされます。出力配列がC隣接ではなく、整列されている場合、正しいデータタイプの場合、WRITEBACKIFCOPYフラグを設定して一時コピーが作成されます。このようにして、メソッドは適切に動作する出力配列を処理できますが、結果は実際の出力配列にコピーされます。&lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;は関数の完了時に呼び出されます。最後に、（メソッドに提供された軸の値に応じて）正しい軸をループするように反復子が設定され、設定ルーチンが実際の計算ルーチンに戻ります。</target>
        </trans-unit>
        <trans-unit id="780e857a060059f3e4636a17060f123b8f85b3b2" translate="yes" xml:space="preserve">
          <source>The shape (always C-style contiguous) of the sub-array as a Python tuple.</source>
          <target state="translated">Pythonのタプルとしての部分配列の形状(常にCスタイルの連続)。</target>
        </trans-unit>
        <trans-unit id="9bd591fada3b4117c12a2a1f4d689c069ec359b8" translate="yes" xml:space="preserve">
          <source>The shape and data-type of &lt;code&gt;a&lt;/code&gt; define these same attributes of the returned array.</source>
          <target state="translated">形状とデータ型返される配列のこれらの同じ属性を定義します。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea4fdc5d91eb3f313e977fbfd63ada0a25a66896" translate="yes" xml:space="preserve">
          <source>The shape and data-type of &lt;code&gt;prototype&lt;/code&gt; define these same attributes of the returned array.</source>
          <target state="translated">&lt;code&gt;prototype&lt;/code&gt; の形状とデータ型は、返される配列のこれらと同じ属性を定義します。</target>
        </trans-unit>
        <trans-unit id="55cbdf85b9592ec5dbddfd31ccd2c86de9452ccc" translate="yes" xml:space="preserve">
          <source>The shape of array into which the indices from &lt;code&gt;multi_index&lt;/code&gt; apply.</source>
          <target state="translated">&lt;code&gt;multi_index&lt;/code&gt; のインデックスが適用される配列の形状。</target>
        </trans-unit>
        <trans-unit id="86ea4631bc5657813d3aa6a6102c3531d8908358" translate="yes" xml:space="preserve">
          <source>The shape of each output is determined from the loop dimensions plus the output&amp;rsquo;s core dimensions</source>
          <target state="translated">各出力の形状は、ループの次元と出力のコアの次元から決定されます</target>
        </trans-unit>
        <trans-unit id="432cd297e760e974a03d449cad5f33c7ccb0d645" translate="yes" xml:space="preserve">
          <source>The shape of the array is preserved, but the elements are reordered.</source>
          <target state="translated">配列の形状は保持されますが,要素は並び替えられます.</target>
        </trans-unit>
        <trans-unit id="fb341212b6f41ae91b019292b043b6094616b784" translate="yes" xml:space="preserve">
          <source>The shape of the array to be iterated over.</source>
          <target state="translated">反復される配列の形状.</target>
        </trans-unit>
        <trans-unit id="a015ba13ffb4171bac494c802f272bfb87417c5d" translate="yes" xml:space="preserve">
          <source>The shape of the array to use for unraveling &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; 解明に使用する配列の形状。</target>
        </trans-unit>
        <trans-unit id="9865a6cbf282f8b0812325650b93441342efdd22" translate="yes" xml:space="preserve">
          <source>The shape of the array.</source>
          <target state="translated">配列の形状。</target>
        </trans-unit>
        <trans-unit id="634c22963834ab0f96135fc087ba541ef29a9351" translate="yes" xml:space="preserve">
          <source>The shape of the broadcasted result (only &lt;code&gt;nd&lt;/code&gt; slots are used).</source>
          <target state="translated">ブロードキャストされた結果の形状（ &lt;code&gt;nd&lt;/code&gt; スロットのみが使用されます）。</target>
        </trans-unit>
        <trans-unit id="b35ba9f7409c5e79b96888dfb9fe12c59d8276ca" translate="yes" xml:space="preserve">
          <source>The shape of the desired array.</source>
          <target state="translated">希望する配列の形状。</target>
        </trans-unit>
        <trans-unit id="f8fd7f6a4e1f2e482a2f6d64364dd79594585ba9" translate="yes" xml:space="preserve">
          <source>The shape of the gamma distribution. Must be non-negative.</source>
          <target state="translated">ガンマ分布の形状。非負でなければなりません。</target>
        </trans-unit>
        <trans-unit id="40d55544c4b29b3e5cccb47aa9255a7413094e32" translate="yes" xml:space="preserve">
          <source>The shape of the grid.</source>
          <target state="translated">グリッドの形状。</target>
        </trans-unit>
        <trans-unit id="666be679bea4cf4401944751286d85ef9bcbd1ab" translate="yes" xml:space="preserve">
          <source>The shape of the new array. Defaults to &lt;code&gt;x.shape&lt;/code&gt;.</source>
          <target state="translated">新しい配列の形状。デフォルトは &lt;code&gt;x.shape&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="be82fcdcf7279745a92907a11f17b40fb49cfa8e" translate="yes" xml:space="preserve">
          <source>The shape of the output depends on the size of &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt;, and may be larger than &lt;code&gt;a&lt;/code&gt; (this happens if &lt;code&gt;len(indices) &amp;gt; a.shape[axis]&lt;/code&gt;).</source>
          <target state="translated">出力の形状は&lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt;のサイズに依存し、 &lt;code&gt;a&lt;/code&gt; よりも大きくなる可能性があります（これは &lt;code&gt;len(indices) &amp;gt; a.shape[axis]&lt;/code&gt; 場合に発生します）。</target>
        </trans-unit>
        <trans-unit id="dac69f494ba7fae89ed73806775a3c39622a5622" translate="yes" xml:space="preserve">
          <source>The shape of the return value is described above.</source>
          <target state="translated">戻り値の形状については、上記のとおりである。</target>
        </trans-unit>
        <trans-unit id="e988320cd7cc6c4a6c3dd57d84589dcf99664d33" translate="yes" xml:space="preserve">
          <source>The shape of the returned array is described above.</source>
          <target state="translated">返された配列の形状は上記の通りです。</target>
        </trans-unit>
        <trans-unit id="3b10de911cd8ce2a5b2b31e29ac9a30a0aac3857" translate="yes" xml:space="preserve">
          <source>The shape of the returned matrix is &lt;code&gt;x.shape + (order,)&lt;/code&gt;, where</source>
          <target state="translated">返される行列の形状は &lt;code&gt;x.shape + (order,)&lt;/code&gt; 。ここで、</target>
        </trans-unit>
        <trans-unit id="80077b48358a43ab7ec659d3d5fde9d46b95fb86" translate="yes" xml:space="preserve">
          <source>The shape parameter must be given if converting from a ctypes POINTER. The shape parameter is ignored if converting from a ctypes array</source>
          <target state="translated">ctypes POINTERから変換する場合は、shapeパラメータを指定する必要があります。ctypesの配列から変換する場合、このshapeパラメータは無視されます。</target>
        </trans-unit>
        <trans-unit id="fd56dfcd2507095f44b621f1654fe8bcd97f2720" translate="yes" xml:space="preserve">
          <source>The shape property is usually used to get the current shape of an array, but may also be used to reshape the array in-place by assigning a tuple of array dimensions to it. As with &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, one of the new shape dimensions can be -1, in which case its value is inferred from the size of the array and the remaining dimensions. Reshaping an array in-place will fail if a copy is required.</source>
          <target state="translated">shapeプロパティは通常、配列の現在の形状を取得するために使用されますが、配列次元のタプルをそれに割り当てることにより、配列をその場で再形成するために使用することもできます。&lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt;と同様に、新しい形状の次元の1つを-1にすることができます。その場合、その値は配列のサイズと残りの次元から推測されます。コピーが必要な場合、アレイをインプレースで再形成すると失敗します。</target>
        </trans-unit>
        <trans-unit id="80c5a27079e0e5c1026de7841cb52daa2c677404" translate="yes" xml:space="preserve">
          <source>The shapes of x, y, and the condition are broadcast together:</source>
          <target state="translated">x,y,条件の形が一緒に放送されます。</target>
        </trans-unit>
        <trans-unit id="18b788b2f85a3ae45e9f183bcbf59e96d87edbee" translate="yes" xml:space="preserve">
          <source>The shifted array.</source>
          <target state="translated">シフトされた配列です。</target>
        </trans-unit>
        <trans-unit id="a03c5ad272b253bf040f55b1c50d0da307be8ac5" translate="yes" xml:space="preserve">
          <source>The sign of &lt;code&gt;x2&lt;/code&gt; is copied to &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">&lt;code&gt;x2&lt;/code&gt; の符号が &lt;code&gt;x1&lt;/code&gt; にコピーされます。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="9a96a866f0e16363f3d77343ed89edc57a089b06" translate="yes" xml:space="preserve">
          <source>The sign of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の符号。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="39e50e1c53e79cf4e2679a1929a8b236a790ceb1" translate="yes" xml:space="preserve">
          <source>The signature defines &amp;ldquo;core&amp;rdquo; dimensionality of input and output variables, and thereby also defines the contraction of the dimensions. The signature is represented by a string of the following format:</source>
          <target state="translated">シグネチャは、入力変数と出力変数の「コア」次元を定義し、それによって次元の縮小も定義します。署名は、次の形式の文字列で表されます。</target>
        </trans-unit>
        <trans-unit id="077a1bbb529dbf66c684eb23b600d5d4d40598cf" translate="yes" xml:space="preserve">
          <source>The signature determines how the dimensions of each input/output array are split into core and loop dimensions:</source>
          <target state="translated">シグネチャは、各入出力配列の次元をコア次元とループ次元にどのように分割するかを決定します。</target>
        </trans-unit>
        <trans-unit id="29c6d5e035a62abf39bca07984559eb4c2eed470" translate="yes" xml:space="preserve">
          <source>The simplest and fastest estimator. Only takes into account the data size.</source>
          <target state="translated">最もシンプルで最速の推定器。データサイズのみを考慮する。</target>
        </trans-unit>
        <trans-unit id="f68339a598fdad0949b432ba0f071db76d4162b2" translate="yes" xml:space="preserve">
          <source>The simplest case of indexing with &lt;em&gt;N&lt;/em&gt; integers returns an &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar&lt;/a&gt; representing the corresponding item. As in Python, all indices are zero-based: for the &lt;em&gt;i&lt;/em&gt;-th index</source>
          <target state="translated">&lt;em&gt;N個の&lt;/em&gt;整数を使用したインデックス付けの最も単純なケースは、対応するアイテムを表す&lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;配列スカラーを&lt;/a&gt;返します。Pythonと同様に、すべてのインデックスはゼロベースです：&lt;em&gt;i&lt;/em&gt;番目のインデックスの場合</target>
        </trans-unit>
        <trans-unit id="47091f34475faaaa1ba4de46a8ad6549a8d5a1f2" translate="yes" xml:space="preserve">
          <source>The simulation of a C-style array is not complete for 2-d and 3-d arrays. For example, the simulated arrays of pointers cannot be passed to subroutines expecting specific, statically-defined 2-d and 3-d arrays. To pass to functions requiring those kind of inputs, you must statically define the required array and copy data.</source>
          <target state="translated">Cスタイルの配列のシミュレーションは,2-dおよび3-d配列については完全ではありません.例えば、シミュレートされたポインタの配列は、静的に定義された特定の2次元配列や3次元配列を期待してサブルーチンに渡すことはできません。そのような入力を必要とする関数に渡すには、必要な配列を静的に定義してデータをコピーしなければなりません。</target>
        </trans-unit>
        <trans-unit id="51abf12252a4d92a90b52830906a8c2bd4002537" translate="yes" xml:space="preserve">
          <source>The sinc function is</source>
          <target state="translated">sinc関数は</target>
        </trans-unit>
        <trans-unit id="ca8287ab64739fe1883b42785585fd67081d297d" translate="yes" xml:space="preserve">
          <source>The sinc function is used in various signal processing applications, including in anti-aliasing, in the construction of a Lanczos resampling filter, and in interpolation.</source>
          <target state="translated">sinc関数は、アンチエイリアシング、ランチョス再サンプリングフィルタの構築、補間など、様々な信号処理アプリケーションで使用されています。</target>
        </trans-unit>
        <trans-unit id="237e09976f401d9a2f1baabe777a697734eddddd" translate="yes" xml:space="preserve">
          <source>The sine is one of the fundamental functions of trigonometry (the mathematical study of triangles). Consider a circle of radius 1 centered on the origin. A ray comes in from the</source>
          <target state="translated">サインは三角法(三角形の数学的研究)の基本的な関数の一つである。原点を中心とする半径 1 の円を考えてみましょう。線が</target>
        </trans-unit>
        <trans-unit id="eeee63a3a1e6205f2e90fb5ed65d351e3798fee5" translate="yes" xml:space="preserve">
          <source>The sine of each element of x. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">xの各要素の正弦。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="b9c09c4d5914f0dda5c0b150c5f3b90e766bd841" translate="yes" xml:space="preserve">
          <source>The single threaded call directly uses the BitGenerator.</source>
          <target state="translated">シングル スレッドの呼び出しは、BitGenerator を直接使用します。</target>
        </trans-unit>
        <trans-unit id="4e52363a0d1aff84bc0a45f224b49ba218e2396a" translate="yes" xml:space="preserve">
          <source>The situation with numpy makes this issue yet more complicated. The internal machinery of numpy arrays is flexible enough to accept any ordering of indices. One can simply reorder indices by manipulating the internal stride information for arrays without reordering the data at all. NumPy will know how to map the new index order to the data without moving the data.</source>
          <target state="translated">numpyの状況は、この問題をさらに複雑にしています。numpy配列の内部機構は、インデックスの並び順を自由に変更できる柔軟性を持っています。配列の内部ストライド情報を操作することで、データを全く並べ替えることなくインデックスを並べ替えることができます。NumPyは、データを移動することなく、新しいインデックスの順序をデータにマッピングする方法を知っているでしょう。</target>
        </trans-unit>
        <trans-unit id="6d5ab6e4dc0fec0528be17bc5d4e3ad5f3c1a900" translate="yes" xml:space="preserve">
          <source>The size in each dimension of the output shape is the maximum of all the input sizes in that dimension.</source>
          <target state="translated">出力形状の各次元のサイズは,その次元のすべての入力サイズの最大値である.</target>
        </trans-unit>
        <trans-unit id="0f600bd12887e2a8896ddc5bed9d6833c21b9000" translate="yes" xml:space="preserve">
          <source>The size of each dimension of the array.</source>
          <target state="translated">配列の各次元のサイズ.</target>
        </trans-unit>
        <trans-unit id="bcfaa2928c38d19614d82820fec94f09b6747c0f" translate="yes" xml:space="preserve">
          <source>The size of each word. This should only be either &lt;code&gt;uint32&lt;/code&gt; or &lt;code&gt;uint64&lt;/code&gt;. Strings (&lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt;, &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt;) are fine. Note that requesting &lt;code&gt;uint64&lt;/code&gt; will draw twice as many bits as &lt;code&gt;uint32&lt;/code&gt; for the same &lt;code&gt;n_words&lt;/code&gt;. This is a convenience for &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; arrays.</source>
          <target state="translated">各単語のサイズ。これは &lt;code&gt;uint32&lt;/code&gt; または &lt;code&gt;uint64&lt;/code&gt; のいずれかでなければなりません。文字 &lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt; （'uint32'、 &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt; ）は問題ありません。 &lt;code&gt;uint64&lt;/code&gt; を要求すると、同じ &lt;code&gt;n_words&lt;/code&gt; に対して &lt;code&gt;uint32&lt;/code&gt; の 2倍のビットが描画されることに注意してください。これは、 &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; 配列」として表すBitGeneratorにとって便利です。</target>
        </trans-unit>
        <trans-unit id="28a984c9bdd908f87770bb977436d6a66f4306a1" translate="yes" xml:space="preserve">
          <source>The size of the array minus 1 in each dimension.</source>
          <target state="translated">配列のサイズから各次元で1を引いた値。</target>
        </trans-unit>
        <trans-unit id="c41c1278613c7ed690de9865ed90f9449e9899a0" translate="yes" xml:space="preserve">
          <source>The size of the arrays for which the returned indices will be valid.</source>
          <target state="translated">返されるインデックスが有効になる配列のサイズ。</target>
        </trans-unit>
        <trans-unit id="b0386b240ebd0571b8a05df9bc4fa0aef34289c1" translate="yes" xml:space="preserve">
          <source>The size, along each dimension, of the arrays for which the returned indices can be used.</source>
          <target state="translated">返されたインデックスが使用できる配列の各次元に沿ったサイズ.</target>
        </trans-unit>
        <trans-unit id="eb79b94dc729ec0da33bab5d4cd377a2401e89f0" translate="yes" xml:space="preserve">
          <source>The smaller object to check.</source>
          <target state="translated">小さい方のオブジェクトをチェックします。</target>
        </trans-unit>
        <trans-unit id="c2b26e02affe13f7769ad145c9ef05f90265c054" translate="yes" xml:space="preserve">
          <source>The smallest positive power of the base (2) that causes overflow.</source>
          <target state="translated">オーバーフローの原因となるベース(2)の最小の正の乗。</target>
        </trans-unit>
        <trans-unit id="52e11ee8daa6593b3d750ee5dc32dda2fcbf193b" translate="yes" xml:space="preserve">
          <source>The smallest positive usable number. Type of &lt;code&gt;tiny&lt;/code&gt; is an appropriate floating point type.</source>
          <target state="translated">使用可能な正の最小数。 &lt;code&gt;tiny&lt;/code&gt; タイプは適切な浮動小数点タイプです。</target>
        </trans-unit>
        <trans-unit id="af2a8dd9510ac11ca6b963d4ee773dcefbea79aa" translate="yes" xml:space="preserve">
          <source>The smallest representable number, typically &lt;code&gt;-max&lt;/code&gt;.</source>
          <target state="translated">表現可能な最小の数値、通常 &lt;code&gt;-max&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a159db5ccf6a60aac5543438bfb54acff104da1e" translate="yes" xml:space="preserve">
          <source>The smallest representable positive number such that &lt;code&gt;1.0 + eps != 1.0&lt;/code&gt;. Type of &lt;code&gt;eps&lt;/code&gt; is an appropriate floating point type.</source>
          <target state="translated">&lt;code&gt;1.0 + eps != 1.0&lt;/code&gt; ような、表現可能な最小の正の数。 &lt;code&gt;eps&lt;/code&gt; のタイプは、適切な浮動小数点タイプです。</target>
        </trans-unit>
        <trans-unit id="d9321ebdb39683114ce6992ea6b9cc620e5ef480" translate="yes" xml:space="preserve">
          <source>The smallest representable positive number such that &lt;code&gt;1.0 - epsneg != 1.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1.0 - epsneg != 1.0&lt;/code&gt; ような、表現可能な最小の正の数。</target>
        </trans-unit>
        <trans-unit id="fff36344b5ce01b9f9447846bf8f8d0ca8bf20cf" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Chebyshev series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解は、加重二乗誤差の合計を最小化するチェビシェフシリーズ &lt;code&gt;p&lt;/code&gt; の係数です。</target>
        </trans-unit>
        <trans-unit id="d7b342b5e308288dae8bce1f9ff3a83bc7ae73a3" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Hermite series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解は、加重二乗誤差の合計を最小にするエルミート級数 &lt;code&gt;p&lt;/code&gt; の係数です。</target>
        </trans-unit>
        <trans-unit id="e858f502931c190b84210ff73e4892a2231f8dea" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the HermiteE series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解は、加重二乗誤差の合計を最小化するHermiteEシリーズ &lt;code&gt;p&lt;/code&gt; の係数です。</target>
        </trans-unit>
        <trans-unit id="cac2b42634eddb5565b046dffc57149ff94fb5e5" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Laguerre series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解は、重み付き二乗誤差の合計を最小化するラゲール級数 &lt;code&gt;p&lt;/code&gt; の係数です。</target>
        </trans-unit>
        <trans-unit id="acc0f8a9120be725868622995211f9656fc88e64" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Legendre series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解は、重み付き二乗誤差の合計を最小化するルジャンドル級数 &lt;code&gt;p&lt;/code&gt; の係数です。</target>
        </trans-unit>
        <trans-unit id="132408df155a153e982d44f873f2076aed312f9a" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the polynomial &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解は、重み付き二乗誤差の合計を最小化する多項式 &lt;code&gt;p&lt;/code&gt; の係数です。</target>
        </trans-unit>
        <trans-unit id="727489824facdfd8e793d7820b6d48d439e20ed1" translate="yes" xml:space="preserve">
          <source>The solution minimizes the squared error</source>
          <target state="translated">解は,二乗誤差を最小化します.</target>
        </trans-unit>
        <trans-unit id="ea7110277074b52a752297c7e2a8351687eb1a36" translate="yes" xml:space="preserve">
          <source>The solutions are computed using LAPACK routine &lt;code&gt;_gesv&lt;/code&gt;.</source>
          <target state="translated">ソリューションはLAPACKルーチン &lt;code&gt;_gesv&lt;/code&gt; を使用して計算されます。</target>
        </trans-unit>
        <trans-unit id="2324f65c28650d2bb749a64e0d6878a8a423096e" translate="yes" xml:space="preserve">
          <source>The sort order for complex numbers is lexicographic. If both the real and imaginary parts are non-nan then the order is determined by the real parts except when they are equal, in which case the order is determined by the imaginary parts.</source>
          <target state="translated">複素数のソート順は辞書的なものである.実部と虚部の両方が非ナンである場合は、実部が等しい場合を除いて実部によって順序が決定されますが、その場合は虚部によって順序が決定されます。</target>
        </trans-unit>
        <trans-unit id="94fa27637cf0004fe36c14f580e547f6911b6110" translate="yes" xml:space="preserve">
          <source>The sorted unique values.</source>
          <target state="translated">ソートされた一意の値。</target>
        </trans-unit>
        <trans-unit id="c380c0b74f7e3ca7cbe5b2bb1b45003f6fb70837" translate="yes" xml:space="preserve">
          <source>The sorting algorithm used.</source>
          <target state="translated">使用されているソートアルゴリズム。</target>
        </trans-unit>
        <trans-unit id="2132b1a1146e5e5ced071e842080bf9a009b6944" translate="yes" xml:space="preserve">
          <source>The source array.</source>
          <target state="translated">ソース配列です。</target>
        </trans-unit>
        <trans-unit id="f3a4e63ab5a7b2b3732df5942d36a724d124f0ea" translate="yes" xml:space="preserve">
          <source>The source code is only returned for objects written in Python.</source>
          <target state="translated">ソースコードはPythonで書かれたオブジェクトに対してのみ返されます。</target>
        </trans-unit>
        <trans-unit id="cf16b74745b78ed96effaeceb909805fb279ce98" translate="yes" xml:space="preserve">
          <source>The source code is only returned for objects written in Python. Many functions and classes are defined in C and will therefore not return useful information.</source>
          <target state="translated">ソースコードが返されるのは、Pythonで書かれたオブジェクトのみです。多くの関数やクラスはC言語で定義されているため、有用な情報は返されません。</target>
        </trans-unit>
        <trans-unit id="cd5904ef77ea8bffca88dd379e736043b3ab2537" translate="yes" xml:space="preserve">
          <source>The spacing between sample points when &lt;code&gt;x&lt;/code&gt; is None. The default is 1.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; がNoneの場合のサンプルポイント間の間隔。デフォルトは1です。</target>
        </trans-unit>
        <trans-unit id="f3c0291e43c18442ce997268f6d827c51450c140" translate="yes" xml:space="preserve">
          <source>The spacing of values of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の値の間隔。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="90f7163cd42de5312873857f6e49d754d0181393" translate="yes" xml:space="preserve">
          <source>The specific algorithm used is as follows.</source>
          <target state="translated">具体的なアルゴリズムは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="87dcde88b185fa2a9572c4ddf0c6760b6d6e72a4" translate="yes" xml:space="preserve">
          <source>The specified line is given by &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">指定された行は、 &lt;code&gt;off + scl*x&lt;/code&gt; 指定されます。</target>
        </trans-unit>
        <trans-unit id="6ffe340425612aa0e424be1bcdd9b7a397555dd0" translate="yes" xml:space="preserve">
          <source>The stacked array has one more dimension than the input arrays.</source>
          <target state="translated">積層された配列は,入力配列よりも1つ多くの次元を持っています.</target>
        </trans-unit>
        <trans-unit id="b5df163136221ee565809e31a5ec5ce477690b37" translate="yes" xml:space="preserve">
          <source>The standard array can have 24 different data types (and has some support for adding your own types). These data types all have an enumerated type, an enumerated type-character, and a corresponding array scalar Python type object (placed in a hierarchy). There are also standard C typedefs to make it easier to manipulate elements of the given data type. For the numeric types, there are also bit-width equivalent C typedefs and named typenumbers that make it easier to select the precision desired.</source>
          <target state="translated">標準の配列は24種類のデータ型を持つことができます(独自の型を追加するためのサポートもあります)。これらのデータ型はすべて、列挙型、列挙型文字列、対応する配列スカラPython型オブジェクト(階層に配置されています)を持っています。また、与えられたデータ型の要素をより簡単に操作できるようにするための標準的なCの型定義もあります。数値型については、ビット幅に相当するCの型定義や名前付きの型数もあり、希望する精度を簡単に選択できるようになっています。</target>
        </trans-unit>
        <trans-unit id="45b18b5cfbbed3fbae9c681cc6f3c1fa70483591" translate="yes" xml:space="preserve">
          <source>The standard casting rules ensure that a scalar cannot up-cast an array unless the scalar is of a fundamentally different kind of data (i.e. under a different hierarchy in the data type hierarchy) then the array:</source>
          <target state="translated">標準的なキャストルールでは,スカラが配列とは根本的に異なる種類のデータ(つまり,データ型の階層が異なる)でない限り,スカラが配列をアップキャストすることはできないことが保証されています.</target>
        </trans-unit>
        <trans-unit id="3b087bfb5ae783fa5041fbcb80716e85b4cfcd9d" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean, i.e., &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt;.</source>
          <target state="translated">標準偏差は、平均からの偏差の二乗の平均の平方根です。つまり、 &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3f057ac9f65af78fe632de7c8031e6f6e2ae80dc" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean: &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt;.</source>
          <target state="translated">標準偏差は、平均からの偏差の二乗の平均の平方根です &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9194bef8dfee2642aab9789d8b2c457a98f783af" translate="yes" xml:space="preserve">
          <source>The standard rules of sequence slicing apply to basic slicing on a per-dimension basis (including using a step index). Some useful concepts to remember include:</source>
          <target state="translated">シーケンス・スライシングの標準的なルールは、基本的なスライシングを寸法ごとに適用します(ステップ・インデックスの使用を含む)。覚えておくと便利な概念をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="903735d28aa358318c996f0fbe6f9bd887af58b8" translate="yes" xml:space="preserve">
          <source>The start of the data within the data buffer (an offset relative to the beginning of the data buffer).</source>
          <target state="translated">データバッファ内のデータの開始点(データバッファの先頭からの相対的なオフセット)。</target>
        </trans-unit>
        <trans-unit id="df2af17caf9f66a81db3bc6a51eb1b52d78258be" translate="yes" xml:space="preserve">
          <source>The start of type numbers used for Custom Data types.</source>
          <target state="translated">カスタムデータ型に使用される型番号の先頭です。</target>
        </trans-unit>
        <trans-unit id="e63c738294e147bc42d8454a2cacbd481d845725" translate="yes" xml:space="preserve">
          <source>The starting value for this product. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">この製品の開始値。詳細については、&lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b49e967087e1769cf1a280ea97d2d8fd93d40ef9" translate="yes" xml:space="preserve">
          <source>The starting value of the sequence.</source>
          <target state="translated">シーケンスの開始値。</target>
        </trans-unit>
        <trans-unit id="be3a2f4f7af9d19db4503332628441741d474403" translate="yes" xml:space="preserve">
          <source>The state of the returned big generator is jumped as-if 2**(128 * jumps) random numbers have been generated.</source>
          <target state="translated">2**(128*ジャンプ)の乱数が生成されていれば、ビッグジェネレータの状態がジャンプされます。</target>
        </trans-unit>
        <trans-unit id="9f0543dedf6d1409b4f87e0823027e644cab05a9" translate="yes" xml:space="preserve">
          <source>The step size is phi-1 when multiplied by 2**128 where phi is the golden ratio.</source>
          <target state="translated">ステップサイズは、2**128を乗じたときに、phi-1となり、ここでphiは黄金比である。</target>
        </trans-unit>
        <trans-unit id="da99252ecc9a954c9ea523c42dd589060111b276" translate="yes" xml:space="preserve">
          <source>The strides of the array. How many bytes needed to jump to the next element in each dimension.</source>
          <target state="translated">配列のストライド。各次元の次の要素にジャンプするのに必要なバイト数。</target>
        </trans-unit>
        <trans-unit id="6bea4f23f51bf1c5c1b134b3c31652eb62271512" translate="yes" xml:space="preserve">
          <source>The strides of the new array. Defaults to &lt;code&gt;x.strides&lt;/code&gt;.</source>
          <target state="translated">新しい配列のストライド。デフォルトは &lt;code&gt;x.strides&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0e7d4c32101a82d4a575c51fa47c579d84a90ccb" translate="yes" xml:space="preserve">
          <source>The string character corresponding to the scalar type.</source>
          <target state="translated">スカラー型に対応する文字列文字。</target>
        </trans-unit>
        <trans-unit id="56e3689374848f3f51b64947b16bec4c3ea61c9e" translate="yes" xml:space="preserve">
          <source>The string representation of an array.</source>
          <target state="translated">配列の文字列表現。</target>
        </trans-unit>
        <trans-unit id="3e6678ed1379ae4a29d74cf130ddd533a3d54faa" translate="yes" xml:space="preserve">
          <source>The string representation of the floating point value</source>
          <target state="translated">浮動小数点値の文字列表現</target>
        </trans-unit>
        <trans-unit id="a73fe28c8757ab0f0da0e2f4243de7dc56a5b482" translate="yes" xml:space="preserve">
          <source>The string separating numbers in the data; extra whitespace between elements is also ignored.</source>
          <target state="translated">データ内の数値を区切る文字列、要素間の余分な空白も無視されます。</target>
        </trans-unit>
        <trans-unit id="3dd7799be74e76e0df59b70e60e88893f1e79944" translate="yes" xml:space="preserve">
          <source>The string to load.</source>
          <target state="translated">ロードする文字列。</target>
        </trans-unit>
        <trans-unit id="fe1a3737165141949913fff90aaf8e13cf8c53af" translate="yes" xml:space="preserve">
          <source>The string to test for equality against the expected string.</source>
          <target state="translated">期待される文字列との等質性をテストするための文字列。</target>
        </trans-unit>
        <trans-unit id="abd4042bc9b171ded494b956ae5b9d9577f995c1" translate="yes" xml:space="preserve">
          <source>The string used to separate values. By default, any consecutive whitespaces act as delimiter. An integer or sequence of integers can also be provided as width(s) of each field.</source>
          <target state="translated">値を区切るために使用する文字列。デフォルトでは、連続した空白が区切り文字として機能します。各フィールドの幅として、整数または整数のシーケンスを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="af52fb130d33fe69945cefb6f52e5cf4ca3f8766" translate="yes" xml:space="preserve">
          <source>The string used to separate values. For backwards compatibility, byte strings will be decoded as &amp;lsquo;latin1&amp;rsquo;. The default is whitespace.</source>
          <target state="translated">値を区切るために使用される文字列。下位互換性のために、バイト文字列は「latin1」としてデコードされます。デフォルトは空白です。</target>
        </trans-unit>
        <trans-unit id="9d54c543599ad13e3bb6b6bb26859ee068b06992" translate="yes" xml:space="preserve">
          <source>The strings produced by the Python float.hex method can be used as input for floats.</source>
          <target state="translated">Pythonのfloat.hexメソッドで生成された文字列をfloatの入力として使用することができます。</target>
        </trans-unit>
        <trans-unit id="05daa592464e6166b985d1ccf981f505cab14119" translate="yes" xml:space="preserve">
          <source>The sub-arrays whose main diagonals we just obtained; note that each corresponds to fixing the right-most (column) axis, and that the diagonals are &amp;ldquo;packed&amp;rdquo; in rows.</source>
          <target state="translated">主な対角線を取得したサブ配列。それぞれが右端の（列）軸の固定に対応し、対角線が行に「パック」されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="032fe52a10dbbb96d8d2155ebf017c5a37d540fb" translate="yes" xml:space="preserve">
          <source>The sub-diagonal at and below which the array is filled. &lt;code&gt;k&lt;/code&gt; = 0 is the main diagonal, while &lt;code&gt;k&lt;/code&gt; &amp;lt; 0 is below it, and &lt;code&gt;k&lt;/code&gt; &amp;gt; 0 is above. The default is 0.</source>
          <target state="translated">配列が塗りつぶされるその下の対角線。 &lt;code&gt;k&lt;/code&gt; = 0は主対角線で、 &lt;code&gt;k&lt;/code&gt; &amp;lt;0はその下、 &lt;code&gt;k&lt;/code&gt; &amp;gt; 0は上です。デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="8e6c361139d8c7c0ac565e0bf2e23b72d7fed91d" translate="yes" xml:space="preserve">
          <source>The subarrays &lt;code&gt;grid[k]&lt;/code&gt; contains the N-D array of indices along the &lt;code&gt;k-th&lt;/code&gt; axis. Explicitly:</source>
          <target state="translated">サブ配列 &lt;code&gt;grid[k]&lt;/code&gt; には、 &lt;code&gt;k-th&lt;/code&gt; 軸に沿ったインデックスのND配列が含まれています。明示的に：</target>
        </trans-unit>
        <trans-unit id="c73621fe8c8d7b0663f28b8d7e7772440297f53c" translate="yes" xml:space="preserve">
          <source>The subscripts string is a comma-separated list of subscript labels, where each label refers to a dimension of the corresponding operand. Whenever a label is repeated it is summed, so &lt;code&gt;np.einsum('i,i', a, b)&lt;/code&gt; is equivalent to &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt;&lt;code&gt;np.inner(a,b)&lt;/code&gt;&lt;/a&gt;. If a label appears only once, it is not summed, so &lt;code&gt;np.einsum('i', a)&lt;/code&gt; produces a view of &lt;code&gt;a&lt;/code&gt; with no changes. A further example &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; describes traditional matrix multiplication and is equivalent to &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;np.matmul(a,b)&lt;/code&gt;&lt;/a&gt;. Repeated subscript labels in one operand take the diagonal. For example, &lt;code&gt;np.einsum('ii', a)&lt;/code&gt; is equivalent to &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;np.trace(a)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">下付き文字列は、下付きラベルのコンマ区切りのリストで、各ラベルは対応するオペランドのディメンションを参照します。ラベルが繰り返される場合は常に合計されるため、 &lt;code&gt;np.einsum('i,i', a, b)&lt;/code&gt; は&lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt; &lt;code&gt;np.inner(a,b)&lt;/code&gt; &lt;/a&gt; a、b）と同等です。ラベルは一度しか表示された場合は、それが合計されていないので、 &lt;code&gt;np.einsum('i', a)&lt;/code&gt; のビュー生成変更なしに。さらなる例 &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; は、従来の行列乗算を説明して&lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;np.matmul(a,b)&lt;/code&gt; &lt;/a&gt;と同等です。 1つのオペランドで繰り返される添え字ラベルは対角になります。たとえば、 &lt;code&gt;np.einsum('ii', a)&lt;/code&gt; は&lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;np.trace(a)&lt;/code&gt; &lt;/a&gt;と同等です。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67e5fbff128f593f5baf173c69fe839b3262add2" translate="yes" xml:space="preserve">
          <source>The substring to search for.</source>
          <target state="translated">検索する部分文字列。</target>
        </trans-unit>
        <trans-unit id="965c999c4a333ea7538f32117fa173b48c1340d4" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">要素ごとの &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の合計。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="6ad40e475222ea9afc0452e8c7fd45129517c8c0" translate="yes" xml:space="preserve">
          <source>The sum of an empty array is the neutral element 0:</source>
          <target state="translated">空の配列の和は中立要素0です。</target>
        </trans-unit>
        <trans-unit id="d51acbb68e0ec9e47200775b381bf1325a23c32a" translate="yes" xml:space="preserve">
          <source>The sum of the inputs. If either input is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</source>
          <target state="translated">入力の合計。どちらかの入力がポリ1次元オブジェクトの場合、出力もポリ1次元オブジェクトとなります。そうでない場合は、最高次数から最低次数までの多項式係数の1次元配列です。</target>
        </trans-unit>
        <trans-unit id="a83a6a324c47c50fcc7b05d36f9de3513626990f" translate="yes" xml:space="preserve">
          <source>The suppression behavior is selected with the &lt;code&gt;axis&lt;/code&gt; parameter.</source>
          <target state="translated">抑制動作は &lt;code&gt;axis&lt;/code&gt; パラメーターで選択されます。</target>
        </trans-unit>
        <trans-unit id="4cac57b443c7e139444cef039c708d06cc974fbe" translate="yes" xml:space="preserve">
          <source>The t test is based on an assumption that the data come from a Normal distribution. The t test provides a way to test whether the sample mean (that is the mean calculated from the data) is a good estimate of the true mean.</source>
          <target state="translated">t 検定は,データが正規分布から来ているという仮定に基づいている.t 検定は,標本平均(データから計算された平均)が真の平均の良い推定値であるかどうかを検定する方法を提供する.</target>
        </trans-unit>
        <trans-unit id="1feedf873323b1df0d515f29065f1cceac91a5f6" translate="yes" xml:space="preserve">
          <source>The template language blocks are delimited by &lt;code&gt;/**begin repeat&lt;/code&gt; and &lt;code&gt;/**end repeat**/&lt;/code&gt; lines, which may also be nested using consecutively numbered delimiting lines such as &lt;code&gt;/**begin repeat1&lt;/code&gt; and &lt;code&gt;/**end repeat1**/&lt;/code&gt;:</source>
          <target state="translated">テンプレート言語ブロックは、 &lt;code&gt;/**begin repeat&lt;/code&gt; および &lt;code&gt;/**end repeat**/&lt;/code&gt; 行で区切られます。これらは、 &lt;code&gt;/**begin repeat1&lt;/code&gt; や &lt;code&gt;/**end repeat1**/&lt;/code&gt; などの連続した番号の区切られた行を使用してネストすることもできます。</target>
        </trans-unit>
        <trans-unit id="2a419cbcd05b123b547d845ae2a3bfd3fd96fc50" translate="yes" xml:space="preserve">
          <source>The tensor dot product of the input.</source>
          <target state="translated">入力のテンソル点積。</target>
        </trans-unit>
        <trans-unit id="0567674780e936db24c51c4154cb1e7bb19a5fb1" translate="yes" xml:space="preserve">
          <source>The test can also be inverted:</source>
          <target state="translated">また、試験は反転も可能です。</target>
        </trans-unit>
        <trans-unit id="a043640318788c216d9c35c72474b86e64a58875" translate="yes" xml:space="preserve">
          <source>The test is equivalent to &lt;code&gt;allclose(actual, desired, rtol, atol)&lt;/code&gt; (note that &lt;code&gt;allclose&lt;/code&gt; has different default values). It compares the difference between &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; to &lt;code&gt;atol + rtol * abs(desired)&lt;/code&gt;.</source>
          <target state="translated">このテストは &lt;code&gt;allclose(actual, desired, rtol, atol)&lt;/code&gt; と同等です（ &lt;code&gt;allclose&lt;/code&gt; のデフォルト値は異なることに注意してください）。 &lt;code&gt;actual&lt;/code&gt; &lt;code&gt;atol + rtol * abs(desired)&lt;/code&gt; と &lt;code&gt;desired&lt;/code&gt; 値の差をatol + rtol * abs（desired）と比較します。</target>
        </trans-unit>
        <trans-unit id="d949a99e166ed49b879032942f22bd239ac73b6e" translate="yes" xml:space="preserve">
          <source>The test is marked as skipped if &lt;code&gt;SkipMyTest&lt;/code&gt; evaluates to nonzero, and the message in verbose test output is the second argument given to &lt;code&gt;skipif&lt;/code&gt;. Similarly, a test can be marked as a known failure by using &lt;code&gt;xfail&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;SkipMyTest&lt;/code&gt; の評価がゼロ以外の場合、テストはスキップされたとマークされ、詳細なテスト出力のメッセージは &lt;code&gt;skipif&lt;/code&gt; に 2番目の引数として指定されます。同様に、 &lt;code&gt;xfail&lt;/code&gt; を使用して、テストを既知の失敗としてマークできます。</target>
        </trans-unit>
        <trans-unit id="85bd6917449fe181340a2938e0dac494fbfea5fe" translate="yes" xml:space="preserve">
          <source>The test method may take two or more arguments; the first, &lt;code&gt;label&lt;/code&gt; is a string specifying what should be tested and the second, &lt;code&gt;verbose&lt;/code&gt; is an integer giving the level of output verbosity. See the docstring for numpy.test for details. The default value for &lt;code&gt;label&lt;/code&gt; is &amp;lsquo;fast&amp;rsquo; - which will run the standard tests. The string &amp;lsquo;full&amp;rsquo; will run the full battery of tests, including those identified as being slow to run. If &lt;code&gt;verbose&lt;/code&gt; is 1 or less, the tests will just show information messages about the tests that are run; but if it is greater than 1, then the tests will also provide warnings on missing tests. So if you want to run every test and get messages about which modules don&amp;rsquo;t have tests:</source>
          <target state="translated">テストメソッドは2つ以上の引数を取る場合があります。最初の &lt;code&gt;label&lt;/code&gt; はテスト対象を指定する文字列で、2番目の &lt;code&gt;verbose&lt;/code&gt; は出力の冗長性のレベルを示す整数です。詳細については、numpy.testのdocstringを参照してください。 &lt;code&gt;label&lt;/code&gt; のデフォルト値は 'fast'で、標準のテストを実行します。文字列「full」は、実行が遅いと識別されたものも含め、一連のテストをすべて実行します。場合は &lt;code&gt;verbose&lt;/code&gt; 1以下であり、テストは単に実行されるテストに関する情報メッセージが表示されます。しかし、それが1より大きい場合、テストは欠落したテストに関する警告も提供します。したがって、すべてのテストを実行し、どのモジュールにテストがないかについてのメッセージを取得したい場合は、</target>
        </trans-unit>
        <trans-unit id="03733f354e779af14d028cdbdf0476c16657d14e" translate="yes" xml:space="preserve">
          <source>The test to label as slow.</source>
          <target state="translated">遅いとレッテルを貼るテスト。</target>
        </trans-unit>
        <trans-unit id="28bda9f13cb5fd35de4d1871d5d1a6b158a05b66" translate="yes" xml:space="preserve">
          <source>The test verifies identical shapes and that the elements of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; satisfy.</source>
          <target state="translated">テストは、同一の形状を検証し、 &lt;code&gt;actual&lt;/code&gt; の要素と &lt;code&gt;desired&lt;/code&gt; 要素が満たすことを検証します。</target>
        </trans-unit>
        <trans-unit id="a7fabe2aaa71feebc60270bd4d75ad9164f05bed" translate="yes" xml:space="preserve">
          <source>The test verifies that the elements of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; satisfy.</source>
          <target state="translated">テストでは、 &lt;code&gt;actual&lt;/code&gt; の要素と &lt;code&gt;desired&lt;/code&gt; 要素が満たされていることを確認します。</target>
        </trans-unit>
        <trans-unit id="bf9247f40709953bae5128ab011a3c6a23e1bb6b" translate="yes" xml:space="preserve">
          <source>The three dimensional series is evaluated at the points &lt;code&gt;(x, y, z)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; must have the same shape. If any of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, or &lt;code&gt;z&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn&amp;rsquo;t an ndarray it is treated as a scalar.</source>
          <target state="translated">3次元シリーズは、ポイント &lt;code&gt;(x, y, z)&lt;/code&gt; で評価されます。ここで、 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;z&lt;/code&gt; は同じ形状でなければなりません。 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、または &lt;code&gt;z&lt;/code&gt; のいずれかがリストまたはタプルの場合、最初にndarrayに変換されます。それ以外の場合は変更されず、ndarrayでない場合はスカラーとして扱われます。</target>
        </trans-unit>
        <trans-unit id="ababec7c614f8cc809a5f4b9df993b70ee13a8f8" translate="yes" xml:space="preserve">
          <source>The three dimensional series is evaluated at the points in the Cartesian product of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt;,`y`, or &lt;code&gt;z&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">3次元シリーズは、 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;z&lt;/code&gt; のデカルト積のポイントで評価されます。場合 &lt;code&gt;x&lt;/code&gt; 、 `y`、又は &lt;code&gt;z&lt;/code&gt; 、リストまたはタプルであるが最初ndarrayに変換され、それ以外の場合は、それがndarrayない場合、それはスカラーとして扱われ、変更されないままとされます。</target>
        </trans-unit>
        <trans-unit id="3f792b485609224acbb4d7367551edb56b3d1d82" translate="yes" xml:space="preserve">
          <source>The three division operators are all defined; &lt;code&gt;div&lt;/code&gt; is active by default, &lt;code&gt;truediv&lt;/code&gt; is active when &lt;a href=&quot;https://docs.python.org/dev/library/__future__.html#module-__future__&quot;&gt;&lt;code&gt;__future__&lt;/code&gt;&lt;/a&gt; division is in effect.</source>
          <target state="translated">3つの除算演算子がすべて定義されています。 &lt;code&gt;div&lt;/code&gt; はデフォルトでアクティブであり、&lt;a href=&quot;https://docs.python.org/dev/library/__future__.html#module-__future__&quot;&gt; &lt;code&gt;__future__&lt;/code&gt; &lt;/a&gt;除算が有効な場合は &lt;code&gt;truediv&lt;/code&gt; がアクティブです。</target>
        </trans-unit>
        <trans-unit id="6953aff01d51815d13e09f72484f920fa7369db2" translate="yes" xml:space="preserve">
          <source>The thresholds above deal with floating point roundoff error in the calculation of the SVD. However, you may have more information about the sources of error in &lt;code&gt;M&lt;/code&gt; that would make you consider other tolerance values to detect &lt;em&gt;effective&lt;/em&gt; rank deficiency. The most useful measure of the tolerance depends on the operations you intend to use on your matrix. For example, if your data come from uncertain measurements with uncertainties greater than floating point epsilon, choosing a tolerance near that uncertainty may be preferable. The tolerance may be absolute if the uncertainties are absolute rather than relative.</source>
          <target state="translated">上記のしきい値は、SVDの計算における浮動小数点丸め誤差を扱います。ただし、 &lt;code&gt;M&lt;/code&gt; の誤差の原因についてより多くの情報があり、他の許容値を考慮して&lt;em&gt;有効な&lt;/em&gt;ランクの不足を検出する場合があります。許容誤差の最も有用な測定は、マトリックスで使用する操作に依存します。たとえば、データが浮動小数点イプシロンより大きい不確実性を伴う不確かな測定からのものである場合、その不確実性に近い許容誤差を選択することが望ましい場合があります。不確実性が相対的ではなく絶対的な場合、許容誤差は絶対的な場合があります。</target>
        </trans-unit>
        <trans-unit id="64c20447e1e6f9694ec0f7bb75ec43f4f4cb6058" translate="yes" xml:space="preserve">
          <source>The tiled output array.</source>
          <target state="translated">タイル化された出力配列。</target>
        </trans-unit>
        <trans-unit id="8bc4b16e1cf995efdf33020e8a2b8f7760d88f9e" translate="yes" xml:space="preserve">
          <source>The time required to produce using multiple threads can be compared to the time required to generate using a single thread.</source>
          <target state="translated">複数のスレッドを使用して生成する場合の所要時間と、1つのスレッドを使用して生成する場合の所要時間を比較することができます。</target>
        </trans-unit>
        <trans-unit id="343a5bcbcad72b541893cb8c8e45cc7f466bba8b" translate="yes" xml:space="preserve">
          <source>The timings below are the time in ns to produce 1 random value from a specific distribution. The original &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; generator is much slower since it requires 2 32-bit values to equal the output of the faster generators.</source>
          <target state="translated">以下のタイミングは、特定の分布から1つのランダムな値を生成する時間（ns）です。元の&lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt;ジェネレーターは、より高速なジェネレーターの出力と等しくするために2つの32ビット値を必要とするため、はるかに低速です。</target>
        </trans-unit>
        <trans-unit id="1d2c30ac9be07be723e9ef95eaf137f9bc73af0a" translate="yes" xml:space="preserve">
          <source>The tolerance values are positive, typically very small numbers. The relative difference (&lt;code&gt;rtol&lt;/code&gt; * abs(&lt;code&gt;b&lt;/code&gt;)) and the absolute difference &lt;code&gt;atol&lt;/code&gt; are added together to compare against the absolute difference between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">許容値は正で、通常は非常に小さい数値です。相対差（ &lt;code&gt;rtol&lt;/code&gt; * ABS（ &lt;code&gt;b&lt;/code&gt; ））との差分絶対 &lt;code&gt;atol&lt;/code&gt; 差の絶対値と比較するために一緒に追加されると &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52a51aeadfd53cc309968068f2e1965d359a3909" translate="yes" xml:space="preserve">
          <source>The total broadcasted size.</source>
          <target state="translated">放送されたサイズの合計。</target>
        </trans-unit>
        <trans-unit id="1470f5efa816c498ec2cdd99dd6bc7fe2a058b68" translate="yes" xml:space="preserve">
          <source>The total number of arguments (&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;). This must be less than &lt;code&gt;NPY_MAXARGS&lt;/code&gt;.</source>
          <target state="translated">引数の合計数（&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;）。これは &lt;code&gt;NPY_MAXARGS&lt;/code&gt; 未満でなければなりません。</target>
        </trans-unit>
        <trans-unit id="af0d1953b87871e5f5c2cfb05eba9aaf99050200" translate="yes" xml:space="preserve">
          <source>The total number of built-in NumPy types. The enumeration covers the range from 0 to NPY_NTYPES-1.</source>
          <target state="translated">組み込みのNumPy型の総数。列挙は 0 から NPY_NTYPES-1 までの範囲をカバーしています。</target>
        </trans-unit>
        <trans-unit id="abe92a5e4aa66a77153ec46749bbd30d898eb468" translate="yes" xml:space="preserve">
          <source>The total number of masked elements (axis=None) or the number of masked elements along each slice of the given axis.</source>
          <target state="translated">マスクされた要素の合計数(axis=None)、または与えられた軸の各スライスに沿ったマスクされた要素の数。</target>
        </trans-unit>
        <trans-unit id="7423c677797c62eaba11c700e763c8330a87769e" translate="yes" xml:space="preserve">
          <source>The total payment is made up of payment against principal plus interest.</source>
          <target state="translated">支払総額は、元金に対する支払いに利息を加えて構成されています。</target>
        </trans-unit>
        <trans-unit id="b7226d44903c768f342634b37f3cd2cbe870d83c" translate="yes" xml:space="preserve">
          <source>The total size of the underlying array.</source>
          <target state="translated">基礎となる配列の合計サイズ。</target>
        </trans-unit>
        <trans-unit id="b17ef49a2b827517f40e328c2cdae6675b6f65d6" translate="yes" xml:space="preserve">
          <source>The transform for real input is performed over the last transformation axis, as by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, then the transform over the remaining axes is performed as by &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;. The order of the output is as for &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt; for the final transformation axis, and as for &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt; for the remaining transformation axes.</source>
          <target state="translated">実際の入力の変換は、&lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; の&lt;/a&gt;ように最後の変換軸で実行され、残りの軸の変換は&lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; で&lt;/a&gt;実行されます。出力の順序は、最終的な変換軸の場合は&lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt;、残りの変換軸の場合は&lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="85975e151b66ed8086ffe0edc17f692849490b8d" translate="yes" xml:space="preserve">
          <source>The transpose of a C-ordered array is a FORTRAN-ordered array.</source>
          <target state="translated">C順配列の転置はFORTRAN順配列です。</target>
        </trans-unit>
        <trans-unit id="be8d0d980a1c43a49c10382a49da454ce905c4ef" translate="yes" xml:space="preserve">
          <source>The transposed array.</source>
          <target state="translated">転置配列です。</target>
        </trans-unit>
        <trans-unit id="362e7b5f1deb8afe588bc61b11c57a486aa6b58d" translate="yes" xml:space="preserve">
          <source>The triangular distribution is a continuous probability distribution with lower limit left, peak at mode, and upper limit right. Unlike the other distributions, these parameters directly define the shape of the pdf.</source>
          <target state="translated">三角分布は,下限左,モードでのピーク,上限右を持つ連続確率分布である。他の分布とは異なり、これらのパラメータはpdfの形状を直接定義します。</target>
        </trans-unit>
        <trans-unit id="1d2039a815b5ec90474a824463e862d2894a1c82" translate="yes" xml:space="preserve">
          <source>The triangular distribution is often used in ill-defined problems where the underlying distribution is not known, but some knowledge of the limits and mode exists. Often it is used in simulations.</source>
          <target state="translated">三角分布は、基礎となる分布が知られていないが、限界とモードの知識がある程度存在するような不明確な問題でよく使われます。しばしばシミュレーションで使用されます。</target>
        </trans-unit>
        <trans-unit id="6a93dc1adb33729debf6e5480c2814c2157666fd" translate="yes" xml:space="preserve">
          <source>The triangular window, with the maximum value normalized to one (the value one appears only if the number of samples is odd), with the first and last samples equal to zero.</source>
          <target state="translated">三角形のウィンドウで、最大値が1に正規化されており(サンプル数が奇数の場合にのみ値1が表示されます)、最初と最後のサンプルは0に等しくなっています。</target>
        </trans-unit>
        <trans-unit id="24e66129ed79808afe1e2c37f4c9f61c91ca2839" translate="yes" xml:space="preserve">
          <source>The true value of &lt;code&gt;exp(1e-10) - 1&lt;/code&gt; is &lt;code&gt;1.00000000005e-10&lt;/code&gt; to about 32 significant digits. This example shows the superiority of expm1 in this case.</source>
          <target state="translated">&lt;code&gt;exp(1e-10) - 1&lt;/code&gt; の真の値は、 &lt;code&gt;1.00000000005e-10&lt;/code&gt; から約32桁の有効数字です。この例は、この場合のexpm1の優位性を示しています。</target>
        </trans-unit>
        <trans-unit id="973da8e077b17711228349d2b08c7d0d4f2d3661" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above.</source>
          <target state="translated">上記のパラメーターのセクションで説明したように、axesによって示される &lt;code&gt;axes&lt;/code&gt; 沿って、または &lt;code&gt;s&lt;/code&gt; と &lt;code&gt;a&lt;/code&gt; の組み合わせによって変換された、切り捨てられた、またはゼロが埋め込まれた入力。</target>
        </trans-unit>
        <trans-unit id="0cef9d8907fc4d88debbd9a6424b4425ec58e68f" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above. The length of the last axis transformed will be &lt;code&gt;s[-1]//2+1&lt;/code&gt;, while the remaining transformed axes will have lengths according to &lt;code&gt;s&lt;/code&gt;, or unchanged from the input.</source>
          <target state="translated">上記のパラメーターのセクションで説明したように、axesによって示される &lt;code&gt;axes&lt;/code&gt; 沿って、または &lt;code&gt;s&lt;/code&gt; と &lt;code&gt;a&lt;/code&gt; の組み合わせによって変換された、切り捨てられた、またはゼロが埋め込まれた入力。変換された最後の軸の長さは &lt;code&gt;s[-1]//2+1&lt;/code&gt; ですが、残りの変換された軸の長さは &lt;code&gt;s&lt;/code&gt; に従うか、入力から変更されません。</target>
        </trans-unit>
        <trans-unit id="9c91d131105a38ed60b366938edb9bb82399cba7" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above.</source>
          <target state="translated">上記のパラメーターのセクションで説明したように、axesによって示される &lt;code&gt;axes&lt;/code&gt; 沿って、または &lt;code&gt;s&lt;/code&gt; または &lt;code&gt;a&lt;/code&gt; の組み合わせによって変換された、切り捨てられた入力またはゼロが埋め込まれた入力。</target>
        </trans-unit>
        <trans-unit id="879b9a05c20a089a225b78254a5b2e292b149d60" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above. The length of each transformed axis is as given by the corresponding element of &lt;code&gt;s&lt;/code&gt;, or the length of the input in every axis except for the last one if &lt;code&gt;s&lt;/code&gt; is not given. In the final transformed axis the length of the output when &lt;code&gt;s&lt;/code&gt; is not given is &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the final transformed axis of the input. To get an odd number of output points in the final axis, &lt;code&gt;s&lt;/code&gt; must be specified.</source>
          <target state="translated">上記のパラメーターのセクションで説明したように、axesによって示される &lt;code&gt;axes&lt;/code&gt; 沿って、または &lt;code&gt;s&lt;/code&gt; または &lt;code&gt;a&lt;/code&gt; の組み合わせによって変換された、切り捨てられた入力またはゼロが埋め込まれた入力。変換された各軸の長さは、 &lt;code&gt;s&lt;/code&gt; の対応する要素、または &lt;code&gt;s&lt;/code&gt; が指定されていない場合は最後の軸を除くすべての軸の入力の長さによって与えられます。最終変換軸では、 &lt;code&gt;s&lt;/code&gt; が指定されていない場合の出力の長さは &lt;code&gt;2*(m-1)&lt;/code&gt; ここで、 &lt;code&gt;m&lt;/code&gt; は入力の最終変換軸の長さです。最終軸で奇数の出力ポイントを取得するには、 &lt;code&gt;s&lt;/code&gt; を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="933c6e0a0fb2fd7449c8d46cb7e6572b1c3279dd" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or the last two axes if &lt;code&gt;axes&lt;/code&gt; is not given.</source>
          <target state="translated">軸に沿って転換切り捨てまたはゼロパディング入力は、で示される &lt;code&gt;axes&lt;/code&gt; 場合、または最後の二つの軸 &lt;code&gt;axes&lt;/code&gt; 与えられていません。</target>
        </trans-unit>
        <trans-unit id="bdca2715ebaff6edc1c47e7d7cb69eb535ec549b" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified.</source>
          <target state="translated">axisで示された &lt;code&gt;axis&lt;/code&gt; 沿って変換された、切り捨てられた、またはゼロが埋め込まれた入力、または &lt;code&gt;axis&lt;/code&gt; が指定されていない場合は最後の入力。</target>
        </trans-unit>
        <trans-unit id="f4095a8db5d8ecd4ba9c0d3227d91d6c6751102f" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. If &lt;code&gt;n&lt;/code&gt; is even, the length of the transformed axis is &lt;code&gt;(n/2)+1&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is odd, the length is &lt;code&gt;(n+1)/2&lt;/code&gt;.</source>
          <target state="translated">axisで示された &lt;code&gt;axis&lt;/code&gt; 沿って変換された、切り捨てられた、またはゼロが埋め込まれた入力、または &lt;code&gt;axis&lt;/code&gt; が指定されていない場合は最後の入力。 &lt;code&gt;n&lt;/code&gt; が偶数の場合、変換された軸の長さは &lt;code&gt;(n/2)+1&lt;/code&gt; です。場合 &lt;code&gt;n&lt;/code&gt; は奇数である、長さが &lt;code&gt;(n+1)/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="210fa87b6170797ddb3ab263d911a488e3f1f97e" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n//2 + 1&lt;/code&gt;.</source>
          <target state="translated">axisで示された &lt;code&gt;axis&lt;/code&gt; 沿って変換された、切り捨てられた、またはゼロが埋め込まれた入力、または &lt;code&gt;axis&lt;/code&gt; が指定されていない場合は最後の入力。変換後の軸の長さは &lt;code&gt;n//2 + 1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1026feb255ba9e4ae695f12a04d60bbc57c49ac5" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n&lt;/code&gt;, or, if &lt;code&gt;n&lt;/code&gt; is not given, &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the transformed axis of the input. To get an odd number of output points, &lt;code&gt;n&lt;/code&gt; must be specified.</source>
          <target state="translated">axisで示された &lt;code&gt;axis&lt;/code&gt; 沿って変換された、切り捨てられた、またはゼロが埋め込まれた入力、または &lt;code&gt;axis&lt;/code&gt; が指定されていない場合は最後の入力。変換された軸の長さは &lt;code&gt;n&lt;/code&gt; です &lt;code&gt;n&lt;/code&gt; が指定されていない場合は、 &lt;code&gt;2*(m-1)&lt;/code&gt; ここで、 &lt;code&gt;m&lt;/code&gt; は入力の変換された軸の長さです。奇数の出力ポイントを取得するには、 &lt;code&gt;n&lt;/code&gt; を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="785f913e97e6f2c077e366a11b3d02d03922b2c4" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n&lt;/code&gt;, or, if &lt;code&gt;n&lt;/code&gt; is not given, &lt;code&gt;2*m - 2&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the transformed axis of the input. To get an odd number of output points, &lt;code&gt;n&lt;/code&gt; must be specified, for instance as &lt;code&gt;2*m - 1&lt;/code&gt; in the typical case,</source>
          <target state="translated">axisで示された &lt;code&gt;axis&lt;/code&gt; 沿って変換された、切り捨てられた、またはゼロが埋め込まれた入力、または &lt;code&gt;axis&lt;/code&gt; が指定されていない場合は最後の入力。変換された軸の長さは &lt;code&gt;n&lt;/code&gt; です &lt;code&gt;n&lt;/code&gt; が指定されていない場合は、 &lt;code&gt;2*m - 2&lt;/code&gt; ここで、 &lt;code&gt;m&lt;/code&gt; は入力の変換された軸の長さです。奇数の出力ポイントを取得するには、 &lt;code&gt;n&lt;/code&gt; を指定する必要があります。たとえば、通常の場合は &lt;code&gt;2*m - 1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="890cb80542174800559555fcc8928d47ac767144" translate="yes" xml:space="preserve">
          <source>The truncated value of each element in &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の各要素の切り捨てられた値。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="d225104697ad1c2e4adc5e266a19505669d514fa" translate="yes" xml:space="preserve">
          <source>The truncated value of the scalar &lt;code&gt;x&lt;/code&gt; is the nearest integer &lt;code&gt;i&lt;/code&gt; which is closer to zero than &lt;code&gt;x&lt;/code&gt; is. In short, the fractional part of the signed number &lt;code&gt;x&lt;/code&gt; is discarded.</source>
          <target state="translated">スカラーの切り捨て値 &lt;code&gt;x&lt;/code&gt; は整数最も近い &lt;code&gt;i&lt;/code&gt; 近いゼロよりなる &lt;code&gt;x&lt;/code&gt; があります。つまり、符号付き数値 &lt;code&gt;x&lt;/code&gt; の小数部分が破棄されます。</target>
        </trans-unit>
        <trans-unit id="7473e98cdd8b9577d457a4ec3ae00062b1e0d1c1" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;args&lt;/code&gt; and dict &lt;code&gt;kwargs&lt;/code&gt; are directly passed on from the original call.</source>
          <target state="translated">タプル &lt;code&gt;args&lt;/code&gt; とdict &lt;code&gt;kwargs&lt;/code&gt; は、元の呼び出しから直接渡されます。</target>
        </trans-unit>
        <trans-unit id="462bd3332737c1c0e3c136e2df99165ffa307b94" translate="yes" xml:space="preserve">
          <source>The tuple returned from __array_interface__[&amp;lsquo;data&amp;rsquo;] used to be a hex-string (now it is an integer or a long integer).</source>
          <target state="translated">__array_interface __ ['data']から返されたタプルは、16進文字列でした（現在は整数または長整数です）。</target>
        </trans-unit>
        <trans-unit id="ac07e35413d52171420d0546afbc516e4675dfc6" translate="yes" xml:space="preserve">
          <source>The two arrays are of the same length, so there is only one position where they completely overlap:</source>
          <target state="translated">2つの配列は同じ長さなので、完全に重なる位置は1つだけです。</target>
        </trans-unit>
        <trans-unit id="a1576896c14768083aa4b0494018f6de168f9aa6" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points &lt;code&gt;(x, y)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn&amp;rsquo;t an ndarray it is treated as a scalar.</source>
          <target state="translated">2次元の系列は、点 &lt;code&gt;(x, y)&lt;/code&gt; で評価されます。ここで、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は同じ形状でなければなりません。場合 &lt;code&gt;x&lt;/code&gt; または &lt;code&gt;y&lt;/code&gt; リストまたはタプルである、それは最初ndarrayに変換され、そうでない場合は変更されないままであり、それはndarrayない場合には、スカラーとして扱われます。</target>
        </trans-unit>
        <trans-unit id="2eba9ab6dc5fc4a672b7a559261dcf61c08663b7" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points &lt;code&gt;(x, y)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">2次元の系列は、点 &lt;code&gt;(x, y)&lt;/code&gt; で評価されます。ここで、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は同じ形状でなければなりません。場合 &lt;code&gt;x&lt;/code&gt; または &lt;code&gt;y&lt;/code&gt; リストまたはタプルであるが最初ndarrayに変換され、それ以外の場合は、それがndarrayない場合、それはスカラーとして扱われ、変更されないままとされます。</target>
        </trans-unit>
        <trans-unit id="0688b7907322e12f298dd8f02d187105297d15b2" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">2次元系列は、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; のデカルト積の点で評価されます。場合 &lt;code&gt;x&lt;/code&gt; または &lt;code&gt;y&lt;/code&gt; リストまたはタプルであるが最初ndarrayに変換され、それ以外の場合は、それがndarrayない場合、それはスカラーとして扱われ、変更されないままとされます。</target>
        </trans-unit>
        <trans-unit id="d4aa44f129ba54b421bffe3762821ce4945dce60" translate="yes" xml:space="preserve">
          <source>The two domains that determine the map. Each must (successfully) convert to 1-d arrays containing precisely two values.</source>
          <target state="translated">マップを決定する2つのドメイン。それぞれが(成功して)正確に2つの値を含む1-d配列に変換しなければなりません。</target>
        </trans-unit>
        <trans-unit id="810d0511d5cc6182785b949cef8752429de415c1" translate="yes" xml:space="preserve">
          <source>The two&amp;rsquo;s complement is returned when the input number is negative and width is specified:</source>
          <target state="translated">入力数が負で幅が指定されている場合、2の補数が返されます。</target>
        </trans-unit>
        <trans-unit id="584450aea06b04e9037daf43c6af1e81a83e775a" translate="yes" xml:space="preserve">
          <source>The two-dimensional FFT of real input.</source>
          <target state="translated">実数入力の2次元FFT。</target>
        </trans-unit>
        <trans-unit id="9b11970984391ed9339a62d69846a84202600584" translate="yes" xml:space="preserve">
          <source>The two-dimensional FFT.</source>
          <target state="translated">二次元FFTです。</target>
        </trans-unit>
        <trans-unit id="cc89089001cef3c7a737f8de3b95a6b67d11a175" translate="yes" xml:space="preserve">
          <source>The two-dimensional inverse FFT.</source>
          <target state="translated">2次元の逆FFT。</target>
        </trans-unit>
        <trans-unit id="66cebb62b229032f20fef01d3cd3e2d8c08b92d1" translate="yes" xml:space="preserve">
          <source>The type object used to instantiate a scalar of this data-type.</source>
          <target state="translated">このデータ型のスカラのインスタンスを作成するために使用される型オブジェクト。</target>
        </trans-unit>
        <trans-unit id="fa0bd68b05131d508a3464e6044d68f87729d81c" translate="yes" xml:space="preserve">
          <source>The type of the data can be accessed through the &lt;a href=&quot;#numpy.ma.MaskedArray.baseclass&quot;&gt;&lt;code&gt;baseclass&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">データのタイプは、&lt;a href=&quot;#numpy.ma.MaskedArray.baseclass&quot;&gt; &lt;code&gt;baseclass&lt;/code&gt; &lt;/a&gt;属性を介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="55666432b4662cbbcca855eedc915c8dbb074f43" translate="yes" xml:space="preserve">
          <source>The type of the data is described by the following &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; attributes:</source>
          <target state="translated">データのタイプは、次の&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;属性によって記述されます。</target>
        </trans-unit>
        <trans-unit id="7c7e8530225fc135f4d9b6eea552288840993321" translate="yes" xml:space="preserve">
          <source>The type of the input is checked, not the value. Even if the input has an imaginary part equal to zero, &lt;a href=&quot;#numpy.iscomplexobj&quot;&gt;&lt;code&gt;iscomplexobj&lt;/code&gt;&lt;/a&gt; evaluates to True.</source>
          <target state="translated">値ではなく、入力のタイプがチェックされます。入力にゼロに等しい虚数部がある場合でも、&lt;a href=&quot;#numpy.iscomplexobj&quot;&gt; &lt;code&gt;iscomplexobj&lt;/code&gt; &lt;/a&gt;はTrueと評価されます。</target>
        </trans-unit>
        <trans-unit id="1a2c8e641184f0940417186c9bd1b40520bec6a6" translate="yes" xml:space="preserve">
          <source>The type of the input is checked, not the value. So even if the input has an imaginary part equal to zero, &lt;a href=&quot;#numpy.isrealobj&quot;&gt;&lt;code&gt;isrealobj&lt;/code&gt;&lt;/a&gt; evaluates to False if the data type is complex.</source>
          <target state="translated">値ではなく、入力のタイプがチェックされます。したがって、入力の虚数部がゼロに等しい場合でも、データ型が複素数の場合、&lt;a href=&quot;#numpy.isrealobj&quot;&gt; &lt;code&gt;isrealobj&lt;/code&gt; &lt;/a&gt;はFalseと評価されます。</target>
        </trans-unit>
        <trans-unit id="ea61e4d42852a1b3d6a2054bbf717a4dcd45c615" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not given, infer the data type from the other input arguments.</source>
          <target state="translated">出力配列のタイプ。&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;が指定されていない場合は、他の入力引数からデータ型を推測します。</target>
        </trans-unit>
        <trans-unit id="2c73d98907158f7fb67c4efa759cdbb5f806f2d4" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;code&gt;dtype&lt;/code&gt; is not given, infer the data type from the other input arguments.</source>
          <target state="translated">出力配列のタイプ。 &lt;code&gt;dtype&lt;/code&gt; が指定されていない場合は、他の入力引数からデータ型を推測します。</target>
        </trans-unit>
        <trans-unit id="a61a6b8f22a17e9cfb7771cdc6f2f0f745c54b06" translate="yes" xml:space="preserve">
          <source>The type of the result will depend on the encoding specified.</source>
          <target state="translated">結果の型は、指定されたエンコーディングに依存します。</target>
        </trans-unit>
        <trans-unit id="9f964988f963b226cae3c6098e96762218b96f31" translate="yes" xml:space="preserve">
          <source>The type of the returned array and of the accumulator in which the elements are summed. By default, the dtype of &lt;code&gt;a&lt;/code&gt; is used. An exception is when &lt;code&gt;a&lt;/code&gt; has an integer type with less precision than the platform (u)intp. In that case, the default will be either (u)int32 or (u)int64 depending on whether the platform is 32 or 64 bits. For inexact inputs, dtype must be inexact.</source>
          <target state="translated">返される配列の型と、要素が合計されるアキュムレータの型。デフォルトでは、のdtypeは使用されています。例外は、 &lt;code&gt;a&lt;/code&gt; がプラットフォーム（u）intpよりも精度が低い整数型の場合です。その場合、プラットフォームが32ビットか64ビットかによって、デフォルトは（u）int32または（u）int64になります。不正確な入力の場合、dtypeは不正確でなければなりません。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fae2388276bf4adee2baf6958155240f0239ec9b" translate="yes" xml:space="preserve">
          <source>The type of the returned array and of the accumulator in which the elements are summed. The dtype of &lt;code&gt;a&lt;/code&gt; is used by default unless &lt;code&gt;a&lt;/code&gt; has an integer dtype of less precision than the default platform integer. In that case, if &lt;code&gt;a&lt;/code&gt; is signed then the platform integer is used while if &lt;code&gt;a&lt;/code&gt; is unsigned then an unsigned integer of the same precision as the platform integer is used.</source>
          <target state="translated">返される配列の型と、要素が合計されるアキュムレータの型。 DTYPE ない限り、デフォルトで使用されるデフォルトプラットフォームの整数未満の精度の整数DTYPEを有しています。場合この場合、次に署名されている場合ながらプラットフォームの整数が使用され、次に署名され、プラットフォームの整数と同じ精度の符号なし整数が使用されます。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd79c4b3d3f0f1be1ec3ce5a1aa5d47271e61a5b" translate="yes" xml:space="preserve">
          <source>The type of the returned array, as well as of the accumulator in which the elements are multiplied. The dtype of &lt;code&gt;a&lt;/code&gt; is used by default unless &lt;code&gt;a&lt;/code&gt; has an integer dtype of less precision than the default platform integer. In that case, if &lt;code&gt;a&lt;/code&gt; is signed then the platform integer is used while if &lt;code&gt;a&lt;/code&gt; is unsigned then an unsigned integer of the same precision as the platform integer is used.</source>
          <target state="translated">返される配列の型と、要素が乗算されるアキュムレータの型。 DTYPE ない限り、デフォルトで使用されるデフォルトプラットフォームの整数未満の精度の整数DTYPEを有しています。場合この場合、次に署名されている場合ながらプラットフォームの整数が使用され、次に署名され、プラットフォームの整数と同じ精度の符号なし整数が使用されます。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3a7bb2863553d52f83413fb23d739a7fea567ae" translate="yes" xml:space="preserve">
          <source>The type used to represent the intermediate results. Defaults to the data type of the output array if this is provided, or the data type of the input array if no output array is provided.</source>
          <target state="translated">中間結果の表現に用いられる型。デフォルトは、出力配列が指定されている場合は出力配列のデータ型、出力配列が指定されていない場合は入力配列のデータ型となります。</target>
        </trans-unit>
        <trans-unit id="f46b668fbc5ae74dc471bbfdc9b1c8b2040c3ed5" translate="yes" xml:space="preserve">
          <source>The type used to represent the intermediate results. Defaults to the data-type of the output array if this is provided, or the data-type of the input array if no output array is provided.</source>
          <target state="translated">中間結果の表現に用いられる型。デフォルトは、出力配列が指定されている場合は出力配列のデータ型、出力配列が指定されていない場合は入力配列のデータ型となります。</target>
        </trans-unit>
        <trans-unit id="3d1a1953424d5a7364adfc318f2ceeb8ef42f6ff" translate="yes" xml:space="preserve">
          <source>The typemap directives provided by &lt;code&gt;numpy.i&lt;/code&gt; for arrays of different data types, say &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt;, and dimensions of different types, say &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;, are identical to one another except for the C and NumPy type specifications. The typemaps are therefore implemented (typically behind the scenes) via a macro:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; が提供する、 &lt;code&gt;double&lt;/code&gt; および &lt;code&gt;int&lt;/code&gt; などの異なるデータ型の配列、および &lt;code&gt;int&lt;/code&gt; または &lt;code&gt;long&lt;/code&gt; などの異なる型の次元に対して提供されるtypemapディレクティブは、CおよびNumPy型の指定を除いて、互いに同じです。したがって、タイプマップはマクロを介して（通常は裏で）実装されます。</target>
        </trans-unit>
        <trans-unit id="dff7b3c37fb51796f178f8cb67e96939e35d8847" translate="yes" xml:space="preserve">
          <source>The typemap signatures are largely differentiated on the name given to the buffer pointer. Names with &lt;code&gt;FARRAY&lt;/code&gt; are for Fortran-ordered arrays, and names with &lt;code&gt;ARRAY&lt;/code&gt; are for C-ordered (or 1D arrays).</source>
          <target state="translated">タイプマップシグネチャは、バッファポインタに付けられた名前で大きく異なります。 &lt;code&gt;FARRAY&lt;/code&gt; が付いた名前はFortran順の配列用で、 &lt;code&gt;ARRAY&lt;/code&gt; が付いた名前はC順（または1D配列）用です。</target>
        </trans-unit>
        <trans-unit id="d316f93b51d10bd2681fb7336deed9067a473d1a" translate="yes" xml:space="preserve">
          <source>The typemaps from &lt;code&gt;numpy.i&lt;/code&gt; are responsible for the following lines of code: 12&amp;ndash;20, 25 and 30. Line 10 parses the input to the &lt;code&gt;rms&lt;/code&gt; function. From the format string &lt;code&gt;&quot;O:rms&quot;&lt;/code&gt;, we can see that the argument list is expected to be a single Python object (specified by the &lt;code&gt;O&lt;/code&gt; before the colon) and whose pointer is stored in &lt;code&gt;obj0&lt;/code&gt;. A number of functions, supplied by &lt;code&gt;numpy.i&lt;/code&gt;, are called to make and check the (possible) conversion from a generic Python object to a NumPy array. These functions are explained in the section &lt;a href=&quot;#helper-functions&quot;&gt;Helper Functions&lt;/a&gt;, but hopefully their names are self-explanatory. At line 12 we use &lt;code&gt;obj0&lt;/code&gt; to construct a NumPy array. At line 17, we check the validity of the result: that it is non-null and that it has a single dimension of arbitrary length. Once these states are verified, we extract the data buffer and length in lines 19 and 20 so that we can call the underlying C function at line 22. Line 25 performs memory management for the case where we have created a new array that is no longer needed.</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; のタイプマップは、次のコード行を担当します：12&amp;ndash;20、25、および30。10行目は、 &lt;code&gt;rms&lt;/code&gt; 関数への入力を解析します。フォーマット文字列 &lt;code&gt;&quot;O:rms&quot;&lt;/code&gt; から、引数リストは単一のPythonオブジェクト（コロンの前の &lt;code&gt;O&lt;/code&gt; で指定）であることが期待され、そのポインターが &lt;code&gt;obj0&lt;/code&gt; に格納されていることがわかります。 &lt;code&gt;numpy.i&lt;/code&gt; によって提供される多数の関数が呼び出され、汎用のPythonオブジェクトからNumPy配列への（可能な）変換を実行および確認します。これらの関数については、「&lt;a href=&quot;#helper-functions&quot;&gt;ヘルパー関数&lt;/a&gt;」セクションで説明していますが、名前が一目でわかるようになっています。 12行目では &lt;code&gt;obj0&lt;/code&gt; を使用していますNumPy配列を作成します。 17行目では、結果の有効性を確認します。これはnullではなく、任意の長さの単一の次元を持っています。これらの状態が確認されたら、19行目と20行目でデータバッファーと長さを抽出し、22行目で基礎となるC関数を呼び出すことができます。25行目は、もはや存在しない新しい配列を作成した場合のメモリ管理を実行します。必要。</target>
        </trans-unit>
        <trans-unit id="94a9db34d902a4524ad7871b0441ea5be9c4a8b8" translate="yes" xml:space="preserve">
          <source>The typical looping construct is as follows.</source>
          <target state="translated">典型的なループ構造は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="93f339cfb377248f9f368c97945ac549c08d48eb" translate="yes" xml:space="preserve">
          <source>The ufunc object is implemented by creation of the &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt;&lt;code&gt;PyUFunc_Type&lt;/code&gt;&lt;/a&gt;. It is a very simple type that implements only basic getattribute behavior, printing behavior, and has call behavior which allows these objects to act like functions. The basic idea behind the ufunc is to hold a reference to fast 1-dimensional (vector) loops for each data type that supports the operation. These one-dimensional loops all have the same signature and are the key to creating a new ufunc. They are called by the generic looping code as appropriate to implement the N-dimensional function. There are also some generic 1-d loops defined for floating and complexfloating arrays that allow you to define a ufunc using a single scalar function (&lt;em&gt;e.g.&lt;/em&gt; atanh).</source>
          <target state="translated">ufuncオブジェクトはの創設によって実装され&lt;a href=&quot;#c.PyUFunc_Type&quot;&gt; &lt;code&gt;PyUFunc_Type&lt;/code&gt; &lt;/a&gt;。これは、基本的なgetattribute動作と印刷動作のみを実装する非常に単純なタイプであり、これらのオブジェクトを関数のように動作させる呼び出し動作を持っています。ufuncの背後にある基本的な考え方は、操作をサポートする各データ型の高速1次元（ベクトル）ループへの参照を保持することです。これらの1次元ループはすべて同じ署名を持ち、新しいufuncを作成するための鍵となります。これらは、N次元関数を実装するために、必要に応じて汎用ループコードによって呼び出されます。単一のスカラー関数（&lt;em&gt;例えば&lt;/em&gt; atanh）を使用してufuncを定義できる、浮動配列および複素浮動配列に対して定義されたいくつかの一般的な1-dループもあります。</target>
        </trans-unit>
        <trans-unit id="cf8db1044487cf17b16ec5dfd6f051754480a0fd" translate="yes" xml:space="preserve">
          <source>The ufunc still returns its output(s) even if you use the optional output argument(s).</source>
          <target state="translated">ufuncは、オプションの出力引数(s)を使用しても、その出力(s)を返します。</target>
        </trans-unit>
        <trans-unit id="6d199d62fee4302579457e386e4a80ba73f82400" translate="yes" xml:space="preserve">
          <source>The underlying data of a masked array can be accessed in several ways:</source>
          <target state="translated">マスクされた配列の基礎となるデータには,いくつかの方法でアクセスすることができます.</target>
        </trans-unit>
        <trans-unit id="11e8796701c0b67707f7be52c1081d9ae533b8cd" translate="yes" xml:space="preserve">
          <source>The underlying file descriptor is closed when exiting the &amp;lsquo;with&amp;rsquo; block.</source>
          <target state="translated">「with」ブロックを終了すると、基になるファイル記述子が閉じます。</target>
        </trans-unit>
        <trans-unit id="8a7d26eedaa6e3c6ca58f22a4d3a1445aae9ed58" translate="yes" xml:space="preserve">
          <source>The upper-triangular matrix.</source>
          <target state="translated">上三角行列。</target>
        </trans-unit>
        <trans-unit id="8fcd141d1c403551e053ceda2314596f85b55796" translate="yes" xml:space="preserve">
          <source>The usual caution for verifying equality with floating point numbers is advised.</source>
          <target state="translated">浮動小数点数で等号を検証する際には、通常の注意が必要です。</target>
        </trans-unit>
        <trans-unit id="6f6231b1c986a1cae99123ebb4b0aec8cf8b789f" translate="yes" xml:space="preserve">
          <source>The usual companion matrix of the Laguerre polynomials is already symmetric when &lt;code&gt;c&lt;/code&gt; is a basis Laguerre polynomial, so no scaling is applied.</source>
          <target state="translated">ラゲール多項式の通常のコンパニオン行列は、 &lt;code&gt;c&lt;/code&gt; が基底ラゲール多項式である場合、すでに対称であるため、スケーリングは適用されません。</target>
        </trans-unit>
        <trans-unit id="f77acab0966818b5a377ef30b38be521ef7f7b59" translate="yes" xml:space="preserve">
          <source>The value of the function when x1 is 0. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">x1が0の場合の関数の値 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状（出力の形状になる）にブロードキャスト可能でなければなりません。</target>
        </trans-unit>
        <trans-unit id="c3e9e5da5ef1ee5aadaa824ae3c6fd2914c94c23" translate="yes" xml:space="preserve">
          <source>The value of this attribute is used to determine what type of object to return in situations where there is more than one possibility for the Python type of the returned object. Subclasses inherit a default value of 0.0 for this attribute.</source>
          <target state="translated">この属性の値は、返されるオブジェクトの Python 型が複数の可能性がある場合に、どのような型のオブジェクトを返すかを決定するために使用されます。サブクラスはこの属性のデフォルト値 0.0 を継承します。</target>
        </trans-unit>
        <trans-unit id="8bcc816a3b6323731b656c466ec0a5744f30e87e" translate="yes" xml:space="preserve">
          <source>The value to convert. Positive and negative values are handled.</source>
          <target state="translated">変換する値。正の値と負の値を扱います。</target>
        </trans-unit>
        <trans-unit id="32b4c5a64bc9a7f3fa379e6006c427acc72a2601" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="translated">無効なエントリに使用する値（デフォルトではなし）。Noneの場合、代わりに配列の&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;属性が使用されます。</target>
        </trans-unit>
        <trans-unit id="11b1837d34a4ca9f6b2279399c10c60d4b55936a" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Default is None.</source>
          <target state="translated">無効なエントリに使用する値。デフォルトは None です。</target>
        </trans-unit>
        <trans-unit id="adfb1baad553fefd1bd16dad3fa307f22463d54c" translate="yes" xml:space="preserve">
          <source>The value where the peak of the distribution occurs. The value must fulfill the condition &lt;code&gt;left &amp;lt;= mode &amp;lt;= right&lt;/code&gt;.</source>
          <target state="translated">分布のピークが発生する値。値は、条件 &lt;code&gt;left &amp;lt;= mode &amp;lt;= right&lt;/code&gt; 満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="686c0ef41d4f40d919659043042cba31d0a83ddd" translate="yes" xml:space="preserve">
          <source>The value whose minimal data type is to be found.</source>
          <target state="translated">データ型が最小となる値。</target>
        </trans-unit>
        <trans-unit id="ec08073e01c06623c4f6388732ecfb40030e861d" translate="yes" xml:space="preserve">
          <source>The value with which to start the reduction. If the ufunc has no identity or the dtype is object, this defaults to None - otherwise it defaults to ufunc.identity. If &lt;code&gt;None&lt;/code&gt; is given, the first element of the reduction is used, and an error is thrown if the reduction is empty.</source>
          <target state="translated">削減を開始する値。ufuncにIDがない場合、またはdtypeがオブジェクトの場合、これはデフォルトでNoneになります。それ以外の場合は、デフォルトでufunc.identityになります。 &lt;code&gt;None&lt;/code&gt; が指定された場合、削減の最初の要素が使用され、削減が空の場合はエラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="930e3ad8c3851bb30a80a559ca4a2af60560b1ff" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;ar1[in1d]&lt;/code&gt; are in &lt;code&gt;ar2&lt;/code&gt;.</source>
          <target state="translated">値 &lt;code&gt;ar1[in1d]&lt;/code&gt; は &lt;code&gt;ar2&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="a4cb91abe1a0f589bcf1ee9ebaba06339dc294dc" translate="yes" xml:space="preserve">
          <source>The values against which to test each value of &lt;code&gt;ar1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ar1&lt;/code&gt; の各値をテストする値。</target>
        </trans-unit>
        <trans-unit id="55096101173292ac6a418aa55429cc3cfcc3d718" translate="yes" xml:space="preserve">
          <source>The values against which to test each value of &lt;code&gt;element&lt;/code&gt;. This argument is flattened if it is an array or array_like. See notes for behavior with non-array-like parameters.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; の各値をテストする値。この引数は、配列またはarray_likeの場合、フラット化されます。配列のようなパラメータ以外の動作については、注意事項を参照してください。</target>
        </trans-unit>
        <trans-unit id="10fa1bca5c63978c522a37d289203eb7633c9fb5" translate="yes" xml:space="preserve">
          <source>The values in the rank-1 array &lt;code&gt;p&lt;/code&gt; are coefficients of a polynomial. If the length of &lt;code&gt;p&lt;/code&gt; is n+1 then the polynomial is described by:</source>
          <target state="translated">ランク1の配列 &lt;code&gt;p&lt;/code&gt; の値は、多項式の係数です。 &lt;code&gt;p&lt;/code&gt; の長さがn + 1の場合、多項式は次のように記述されます。</target>
        </trans-unit>
        <trans-unit id="427b2ca25633b731d69a885f7ebcb443f1d11f04" translate="yes" xml:space="preserve">
          <source>The values in the result follow so-called &amp;ldquo;standard&amp;rdquo; order: If &lt;code&gt;A =
fft(a, n)&lt;/code&gt;, then &lt;code&gt;A[0]&lt;/code&gt; contains the zero-frequency term (the sum of the signal), which is always purely real for real inputs. Then &lt;code&gt;A[1:n/2]&lt;/code&gt; contains the positive-frequency terms, and &lt;code&gt;A[n/2+1:]&lt;/code&gt; contains the negative-frequency terms, in order of decreasingly negative frequency. For an even number of input points, &lt;code&gt;A[n/2]&lt;/code&gt; represents both positive and negative Nyquist frequency, and is also purely real for real input. For an odd number of input points, &lt;code&gt;A[(n-1)/2]&lt;/code&gt; contains the largest positive frequency, while &lt;code&gt;A[(n+1)/2]&lt;/code&gt; contains the largest negative frequency. The routine &lt;code&gt;np.fft.fftfreq(n)&lt;/code&gt; returns an array giving the frequencies of corresponding elements in the output. The routine &lt;code&gt;np.fft.fftshift(A)&lt;/code&gt; shifts transforms and their frequencies to put the zero-frequency components in the middle, and &lt;code&gt;np.fft.ifftshift(A)&lt;/code&gt; undoes that shift.</source>
          <target state="translated">結果の値は、いわゆる「標準」の順序に従います &lt;code&gt;A = fft(a, n)&lt;/code&gt; 場合、 &lt;code&gt;A[0]&lt;/code&gt; にはゼロ周波数項（信号の合計）が含まれます。入力。次に、 &lt;code&gt;A[1:n/2]&lt;/code&gt; には正の周波数の項が含まれ、 &lt;code&gt;A[n/2+1:]&lt;/code&gt; には負の周波数の項が含まれます。偶数の入力ポイントの場合、 &lt;code&gt;A[n/2]&lt;/code&gt; は正と負の両方のナイキスト周波数を表し、実際の入力では純粋に実数になります。奇数の入力ポイントの場合、 &lt;code&gt;A[(n-1)/2]&lt;/code&gt; は最大の正の周波数を含み、 &lt;code&gt;A[(n+1)/2]&lt;/code&gt; は最大の負の周波数を含みます。ルーチン &lt;code&gt;np.fft.fftfreq(n)&lt;/code&gt; は、出力内の対応する要素の頻度を示す配列を返します。ルーチン &lt;code&gt;np.fft.fftshift(A)&lt;/code&gt; は変換とその周波数をシフトして、ゼロ周波数成分を中央に配置し、 &lt;code&gt;np.fft.ifftshift(A)&lt;/code&gt; はそのシフトを元に戻します。</target>
        </trans-unit>
        <trans-unit id="049629d5662346c69d1da68173623b07fbd3ce2f" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;R&lt;/code&gt; are between -1 and 1, inclusive.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; の値は-1から1の間です。</target>
        </trans-unit>
        <trans-unit id="9be1b3aaf13595cf59a1cfa63bbe9d63fd300725" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;x1&lt;/code&gt; with the sign of &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x2&lt;/code&gt; の符号付きの &lt;code&gt;x1&lt;/code&gt; の値。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="0b6f0a3f189dc33bd74c3b4b3649d7d6ee49f75c" translate="yes" xml:space="preserve">
          <source>The values of the histogram. See &lt;code&gt;density&lt;/code&gt; and &lt;code&gt;weights&lt;/code&gt; for a description of the possible semantics.</source>
          <target state="translated">ヒストグラムの値。可能なセマンティクスの説明については、 &lt;code&gt;density&lt;/code&gt; と &lt;code&gt;weights&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="94c9275f5f339f7a7296146a88f4dacc4958d420" translate="yes" xml:space="preserve">
          <source>The values of the multidimension polynomial on points formed with triples of corresponding values from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、 &lt;code&gt;z&lt;/code&gt; からの対応する値のトリプルで形成された点の多次元多項式の値。</target>
        </trans-unit>
        <trans-unit id="000e1e6aea9b8f07ac10536f42598c0ea9bb0313" translate="yes" xml:space="preserve">
          <source>The values of the multidimensional polynomial on points formed with triples of corresponding values from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、 &lt;code&gt;z&lt;/code&gt; からの対応する値のトリプルで形成された点の多次元多項式の値。</target>
        </trans-unit>
        <trans-unit id="04875120c52fa413c52d82fe0fc8626bcc9f10c7" translate="yes" xml:space="preserve">
          <source>The values of the time series of cash flows. The (fixed) time interval between cash flow &amp;ldquo;events&amp;rdquo; must be the same as that for which &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; is given (i.e., if &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; is per year, then precisely a year is understood to elapse between each cash flow event). By convention, investments or &amp;ldquo;deposits&amp;rdquo; are negative, income or &amp;ldquo;withdrawals&amp;rdquo; are positive; &lt;code&gt;values&lt;/code&gt; must begin with the initial investment, thus &lt;code&gt;values[0]&lt;/code&gt; will typically be negative.</source>
          <target state="translated">キャッシュフローの時系列の値。キャッシュフローの「イベント」間の（固定）時間間隔は、&lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt;が指定されている時間間隔と同じである必要があります（つまり、&lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt;が1年あたりの場合、各キャッシュフローイベント間で正確に1年が経過すると理解されます）。慣例により、投資または「預金」はマイナスであり、収入または「引き出し」はプラスです。 &lt;code&gt;values&lt;/code&gt; は初期投資で始まる必要があるため、 &lt;code&gt;values[0]&lt;/code&gt; は通常負の値になります。</target>
        </trans-unit>
        <trans-unit id="1a3aeed326405c6ff97973ff76e3c1ac5b78c950" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Chebyshev series at points formed from pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の対応する値のペアから形成された点での2次元チェビシェフシリーズの値。</target>
        </trans-unit>
        <trans-unit id="d500e0f26328b27b56cc6ea280ce335971a39a93" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Chebyshev series at points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; のデカルト積の点における2次元のチェビシェフシリーズの値。</target>
        </trans-unit>
        <trans-unit id="118ceee048eeb019cc7036790e58ad86a6694410" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Legendre series at points formed from pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; からの対応する値のペアから形成された点での2次元ルジャンドル系列の値。</target>
        </trans-unit>
        <trans-unit id="75bce5c26e8d20f2a28b76fe4bee99ba20e34131" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional polynomial at points formed with pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; からの対応する値のペアで形成された点での2次元多項式の値。</target>
        </trans-unit>
        <trans-unit id="fb47214ec0ab61ed4f83b6664e41c0aa8a83d3ed" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional polynomial at points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; のデカルト積の点における2次元多項式の値。</target>
        </trans-unit>
        <trans-unit id="7d3e958b62535b85e2d7d32e34bc42123eb7d409" translate="yes" xml:space="preserve">
          <source>The values reported are normalized relative to the speed of MT19937 in each table. A value of 100 indicates that the performance matches the MT19937. Higher values indicate improved performance. These values cannot be compared across tables.</source>
          <target state="translated">報告された値は、各テーブルのMT19937の速度と比較して正規化されています。100の値は、性能がMT19937と一致していることを示しています。値が大きいほど性能が向上していることを示しています。これらの値は、テーブル間で比較することはできません。</target>
        </trans-unit>
        <trans-unit id="d8a3da63b70322018b836bf5f65f57d16d3ac651" translate="yes" xml:space="preserve">
          <source>The values whose cube-roots are required.</source>
          <target state="translated">立方根が必要とされる値。</target>
        </trans-unit>
        <trans-unit id="b42bae2bd42a8c9e82a7332d1979f8a09c759feb" translate="yes" xml:space="preserve">
          <source>The values whose square-roots are required.</source>
          <target state="translated">平方根が必要な値。</target>
        </trans-unit>
        <trans-unit id="187833930bd2cba800be6e8dd52776f374cc2f1c" translate="yes" xml:space="preserve">
          <source>The variable obtained by summing the squares of &lt;code&gt;df&lt;/code&gt; independent, standard normally distributed random variables:</source>
          <target state="translated">&lt;code&gt;df&lt;/code&gt; 独立した標準正規分布確率変数の2乗を合計して得られる変数：</target>
        </trans-unit>
        <trans-unit id="fddb7e65a48e5500c69e424836450e7732656827" translate="yes" xml:space="preserve">
          <source>The variable used in the string representation of &lt;code&gt;p&lt;/code&gt; can be modified, using the &lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt;&lt;code&gt;variable&lt;/code&gt;&lt;/a&gt; parameter:</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; の文字列表現で使用される&lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt; &lt;code&gt;variable&lt;/code&gt; &lt;/a&gt;は、variableパラメーターを使用して変更できます。</target>
        </trans-unit>
        <trans-unit id="032af5a223b6a82b2905b5c850f693e8fec137cd" translate="yes" xml:space="preserve">
          <source>The variance is the average of the squared deviations from the mean, i.e., &lt;code&gt;var = mean(abs(x - x.mean())**2)&lt;/code&gt;.</source>
          <target state="translated">分散は、平均からの偏差の二乗の平均です。つまり、 &lt;code&gt;var = mean(abs(x - x.mean())**2)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="598bba43a5fa13ecb982a04e1ac2dcfa3fb5a79a" translate="yes" xml:space="preserve">
          <source>The various character codes indicating certain types are also part of an enumerated list. References to type characters (should they be needed at all) should always use these enumerations. The form of them is &lt;code&gt;NPY_{NAME}LTR&lt;/code&gt; where &lt;code&gt;{NAME}&lt;/code&gt; can be</source>
          <target state="translated">特定のタイプを示すさまざまな文字コードも、列挙リストの一部です。タイプ文字への参照（必要な場合）は、常にこれらの列挙を使用する必要があります。それらの形式は &lt;code&gt;NPY_{NAME}LTR&lt;/code&gt; で、 &lt;code&gt;{NAME}&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="d2bf21ee585f4c470168bc467b8b8760de8826fd" translate="yes" xml:space="preserve">
          <source>The various routines in the Polynomial package all deal with series whose coefficients go from degree zero upward, which is the &lt;em&gt;reverse order&lt;/em&gt; of the Poly1d convention. The easy way to remember this is that indexes correspond to degree, i.e., coef[i] is the coefficient of the term of degree i.</source>
          <target state="translated">多項式パッケージのさまざまなルーチンの係数である、上方度ゼロから行くシリーズのすべての契約&lt;em&gt;逆順&lt;/em&gt; Poly1d大会の。これを覚える簡単な方法は、インデックスが次数に対応することです。つまり、coef [i]は次数iの項の係数です。</target>
        </trans-unit>
        <trans-unit id="40dcb2f33f2d122b10f89906b0fa578dee7f50c3" translate="yes" xml:space="preserve">
          <source>The various selection algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The available algorithms have the following properties:</source>
          <target state="translated">様々なソートアルゴリズムは、平均速度、最悪の場合の性能、作業スペースの大きさ、安定しているかどうかによって特徴づけられています。安定したソートは、同じキーを持つアイテムを同じ相対順序で保持します。利用可能なアルゴリズムは以下のような特性を持っています。</target>
        </trans-unit>
        <trans-unit id="cc8322a9b3a11e0738c1dc848dd44452ebdc9f34" translate="yes" xml:space="preserve">
          <source>The various sorting algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The four algorithms implemented in NumPy have the following properties:</source>
          <target state="translated">様々なソートアルゴリズムは、平均速度、最悪の場合の性能、作業スペースの大きさ、安定しているかどうかによって特徴づけられています。安定したソートとは、同じキーを持つアイテムを同じ相対順序で並べ替えることです。NumPyで実装されている4つのアルゴリズムは、以下のような特性を持っています。</target>
        </trans-unit>
        <trans-unit id="909b1eaadbbd85f2064b83f98f4324e7aba0802c" translate="yes" xml:space="preserve">
          <source>The vdot(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;) function handles complex numbers differently than dot(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;). If the first argument is complex the complex conjugate of the first argument is used for the calculation of the dot product.</source>
          <target state="translated">vdot（ &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; ）関数は、dot（ &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; ）とは異なる方法で複素数を処理します。最初の引数が複素数の場合、最初の引数の複素共役が内積の計算に使用されます。</target>
        </trans-unit>
        <trans-unit id="f8aeebbf639e209f314766460959c079ab13f5dd" translate="yes" xml:space="preserve">
          <source>The version 1.0 format only allowed the array header to have a total size of 65535 bytes. This can be exceeded by structured arrays with a large number of columns. The version 2.0 format extends the header size to 4 GiB. &lt;a href=&quot;numpy.save#numpy.save&quot;&gt;&lt;code&gt;numpy.save&lt;/code&gt;&lt;/a&gt; will automatically save in 2.0 format if the data requires it, else it will always use the more compatible 1.0 format.</source>
          <target state="translated">バージョン1.0形式では、配列ヘッダーの合計サイズは65535バイトのみでした。これは、列の数が多い構造化配列では超えられます。バージョン2.0形式では、ヘッダーサイズが4 GiBに拡張されています。&lt;a href=&quot;numpy.save#numpy.save&quot;&gt; &lt;code&gt;numpy.save&lt;/code&gt; &lt;/a&gt;は、データで必要な場合は自動的に2.0形式で保存します。それ以外の場合は、常に互換性の高い1.0形式を使用します。</target>
        </trans-unit>
        <trans-unit id="7a92769f6aa86193f32ae6d12aa9581114703198" translate="yes" xml:space="preserve">
          <source>The version 2 interface was very similar. The differences were largely aesthetic. In particular:</source>
          <target state="translated">バージョン2のインターフェイスは非常に似ていました。違いは主に審美的なものでした。特に</target>
        </trans-unit>
        <trans-unit id="73bb55ce329b913976b213535f9642d82795177e" translate="yes" xml:space="preserve">
          <source>The version numbering of these formats is independent of NumPy version numbering. If the format is upgraded, the code in &lt;code&gt;numpy.io&lt;/code&gt; will still be able to read and write Version 1.0 files.</source>
          <target state="translated">これらのフォーマットのバージョン番号は、NumPyのバージョン番号とは無関係です。フォーマットがアップグレードされても、 &lt;code&gt;numpy.io&lt;/code&gt; のコードは引き続きバージョン1.0ファイルを読み書きできます。</target>
        </trans-unit>
        <trans-unit id="d465b2400649c410304e54f051f7d49aa970de97" translate="yes" xml:space="preserve">
          <source>The von Mises distribution (also known as the circular normal distribution) is a continuous probability distribution on the unit circle. It may be thought of as the circular analogue of the normal distribution.</source>
          <target state="translated">フォン・ミーゼス分布(円正規分布としても知られている)は,単位円上の連続確率分布である.正規分布の円のアナログと考えられています。</target>
        </trans-unit>
        <trans-unit id="08a316a93b85a841b11a6055717875d0502f2c60" translate="yes" xml:space="preserve">
          <source>The von Mises is named for Richard Edler von Mises, who was born in Austria-Hungary, in what is now the Ukraine. He fled to the United States in 1939 and became a professor at Harvard. He worked in probability theory, aerodynamics, fluid mechanics, and philosophy of science.</source>
          <target state="translated">フォン・ミーゼスは、オーストリア・ハンガリー、現在のウクライナに生まれたリチャード・エドラー・フォン・ミーゼスにちなんで命名された。1939年にアメリカに亡命し、ハーバード大学の教授となった。確率論、空気力学、流体力学、科学哲学などを研究した。</target>
        </trans-unit>
        <trans-unit id="c66491ff606b4dc91911613d519dc8370dc0d225" translate="yes" xml:space="preserve">
          <source>The warnings can be turned off by</source>
          <target state="translated">警告は</target>
        </trans-unit>
        <trans-unit id="a3b6182c6d54b721f88f41929f57467a3fff8892" translate="yes" xml:space="preserve">
          <source>The weight function at &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; での重み関数。</target>
        </trans-unit>
        <trans-unit id="88ba21dce5f8f071e2673c0f1f06439caa2807d7" translate="yes" xml:space="preserve">
          <source>The weight function is</source>
          <target state="translated">重みの関数は</target>
        </trans-unit>
        <trans-unit id="308836c1d8a38528ab14ca4524532677c1153f22" translate="yes" xml:space="preserve">
          <source>The weight function of the Chebyshev polynomials.</source>
          <target state="translated">チェビシェフ多項式の重み関数。</target>
        </trans-unit>
        <trans-unit id="9b231b3ccfadec2079a40387b8d56e7ec8b9bb3d" translate="yes" xml:space="preserve">
          <source>The window of the converted series. If the value is None, the default window of &lt;code&gt;kind&lt;/code&gt; is used.</source>
          <target state="translated">変換されたシリーズのウィンドウ。値がNoneの場合、デフォルトの &lt;code&gt;kind&lt;/code&gt; ウィンドウが使用されます。</target>
        </trans-unit>
        <trans-unit id="1da2fe6ad3abf125b431351fbdd12b7a74edc3f3" translate="yes" xml:space="preserve">
          <source>The window, with the maximum value normalized to one (the value one appears only if &lt;code&gt;M&lt;/code&gt; is odd).</source>
          <target state="translated">最大値が1に正規化されたウィンドウ（値1 は &lt;code&gt;M&lt;/code&gt; が奇数の場合にのみ表示されます）。</target>
        </trans-unit>
        <trans-unit id="48ac736d93f8e7e8643c8e0f7b0c321855533edd" translate="yes" xml:space="preserve">
          <source>The window, with the maximum value normalized to one (the value one appears only if the number of samples is odd).</source>
          <target state="translated">最大値を1に正規化したウィンドウ(サンプル数が奇数の場合のみ値1が表示されます)。</target>
        </trans-unit>
        <trans-unit id="523eb308fcdc8d9a4d1dacdeabc03bc7b0a18f42" translate="yes" xml:space="preserve">
          <source>The word &amp;ldquo;non-zero&amp;rdquo; is in reference to the Python 2.x built-in method &lt;code&gt;__nonzero__()&lt;/code&gt; (renamed &lt;code&gt;__bool__()&lt;/code&gt; in Python 3.x) of Python objects that tests an object&amp;rsquo;s &amp;ldquo;truthfulness&amp;rdquo;. For example, any number is considered truthful if it is nonzero, whereas any string is considered truthful if it is not the empty string. Thus, this function (recursively) counts how many elements in &lt;code&gt;a&lt;/code&gt; (and in sub-arrays thereof) have their &lt;code&gt;__nonzero__()&lt;/code&gt; or &lt;code&gt;__bool__()&lt;/code&gt; method evaluated to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">「非ゼロ」という言葉は、オブジェクトの「真実性」をテストするPythonオブジェクトのPython 2.x組み込みメソッド &lt;code&gt;__nonzero__()&lt;/code&gt; （Python 3.xでは &lt;code&gt;__bool__()&lt;/code&gt; に名前が変更された）を参照しています。たとえば、ゼロ以外の数値は真であると見なされ、空の文字列ではない文字列は真であると見なされます。したがって、この関数は（再帰的に） &lt;code&gt;a&lt;/code&gt; （およびそのサブ配列）内の &lt;code&gt;__nonzero__()&lt;/code&gt; または &lt;code&gt;__bool__()&lt;/code&gt; メソッドが &lt;code&gt;True&lt;/code&gt; に評価された要素の数をカウントします。</target>
        </trans-unit>
        <trans-unit id="a3f383c240aa5414ebaced6e3034416ca7d1b6af" translate="yes" xml:space="preserve">
          <source>The wrap option affects only tall matrices:</source>
          <target state="translated">wrap オプシ ョ ンは、 背の高い行列にのみ影響を与えます。</target>
        </trans-unit>
        <trans-unit id="f30f1b95441858e7d3037adb27c5185133726d2e" translate="yes" xml:space="preserve">
          <source>The x-coordinates at which to evaluate the interpolated values.</source>
          <target state="translated">補間された値を評価するx座標。</target>
        </trans-unit>
        <trans-unit id="98e412a8d1f1dc441497184c5505f308bf594274" translate="yes" xml:space="preserve">
          <source>The x-coordinates of the data points, must be increasing if argument &lt;code&gt;period&lt;/code&gt; is not specified. Otherwise, &lt;code&gt;xp&lt;/code&gt; is internally sorted after normalizing the periodic boundaries with &lt;code&gt;xp = xp % period&lt;/code&gt;.</source>
          <target state="translated">引数の &lt;code&gt;period&lt;/code&gt; が指定されていない場合、データポイントのx座標は増加している必要があります。それ以外の場合、 &lt;code&gt;xp&lt;/code&gt; は &lt;code&gt;xp = xp % period&lt;/code&gt; 周期的な境界を正規化した後で内部的にソートされます。</target>
        </trans-unit>
        <trans-unit id="5fb42b6312c1e1cea4c01b6bb567b8d84d30c4b2" translate="yes" xml:space="preserve">
          <source>The y-coordinates of the data points, same length as &lt;code&gt;xp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;xp&lt;/code&gt; と同じ長さのデータポイントのy座標。</target>
        </trans-unit>
        <trans-unit id="13617ef6d1ed670620e3eee1fe6521faed558f33" translate="yes" xml:space="preserve">
          <source>Their contents are described below.</source>
          <target state="translated">その内容は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="2a2d6eb0d79238cba7c8636b58f3ce6ad4b5b344" translate="yes" xml:space="preserve">
          <source>There are 4 relevant uses of the word &lt;code&gt;align&lt;/code&gt; used in numpy:</source>
          <target state="translated">numpyで使用される &lt;code&gt;align&lt;/code&gt; という単語の関連する使用法は4つあります。</target>
        </trans-unit>
        <trans-unit id="4a7e737fa7ec2df18d82d046fe4547a421ecb3b7" translate="yes" xml:space="preserve">
          <source>There are 6 (binary) flags that describe the memory area used by the data buffer. These constants are defined in &lt;code&gt;arrayobject.h&lt;/code&gt; and determine the bit-position of the flag. Python exposes a nice attribute- based interface as well as a dictionary-like interface for getting (and, if appropriate, setting) these flags.</source>
          <target state="translated">データバッファーによって使用されるメモリ領域を説明する6つの（バイナリ）フラグがあります。これらの定数は &lt;code&gt;arrayobject.h&lt;/code&gt; で定義され、フラグのビット位置を決定します。Pythonは、これらのフラグを取得（および必要に応じて設定）するための、辞書に似たインターフェースだけでなく、属性ベースのインターフェースも公開しています。</target>
        </trans-unit>
        <trans-unit id="92880b58f6bd9442d0573770c5bcc16b810e1cdc" translate="yes" xml:space="preserve">
          <source>There are &lt;code&gt;num&lt;/code&gt; equally spaced samples in the closed interval &lt;code&gt;[start, stop]&lt;/code&gt; or the half-open interval &lt;code&gt;[start, stop)&lt;/code&gt; (depending on whether &lt;code&gt;endpoint&lt;/code&gt; is True or False).</source>
          <target state="translated">閉じた間隔 &lt;code&gt;[start, stop]&lt;/code&gt; または半分開いた間隔 &lt;code&gt;[start, stop)&lt;/code&gt; ]には、等間隔のサンプルが &lt;code&gt;num&lt;/code&gt; 個あります（ &lt;code&gt;endpoint&lt;/code&gt; がTrueかFalse かによって異なります）。</target>
        </trans-unit>
        <trans-unit id="6009b813cfbdbc400ba73901cd26bc8dc165215e" translate="yes" xml:space="preserve">
          <source>There are also typedefs for signed integers, unsigned integers, floating point, and complex floating point types of specific bit- widths. The available type names are</source>
          <target state="translated">また、符号付き整数、符号なし整数、浮動小数点、および特定のビット幅の複素浮動小数点型の型定義もあります。利用可能な型名は以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="2cd3e7355c4c3985bff39b5837a16202e8c1540c" translate="yes" xml:space="preserve">
          <source>There are currently more than 60 universal functions defined in &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; on one or more types, covering a wide variety of operations. Some of these ufuncs are called automatically on arrays when the relevant infix notation is used (&lt;em&gt;e.g.&lt;/em&gt;, &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add(a, b)&lt;/code&gt;&lt;/a&gt; is called internally when &lt;code&gt;a + b&lt;/code&gt; is written and &lt;em&gt;a&lt;/em&gt; or &lt;em&gt;b&lt;/em&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;). Nevertheless, you may still want to use the ufunc call in order to use the optional output argument(s) to place the output(s) in an object (or objects) of your choice.</source>
          <target state="translated">現在、1つ以上の型で&lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt;で定義されている60を超える汎用関数があり、さまざまな操作をカバーしています。これらのufuncの一部は、関連するインフィックス表記法が使用されると、配列で自動的に呼び出されます（&lt;em&gt;たとえば&lt;/em&gt;&lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt; &lt;code&gt;add(a, b)&lt;/code&gt; &lt;/a&gt; &lt;code&gt;a + b&lt;/code&gt; が書き込まれ、&lt;em&gt;a&lt;/em&gt;または&lt;em&gt;b&lt;/em&gt;が&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; である&lt;/a&gt;場合、add（a、b）は内部で呼び出されます）。それでも、オプションの出力引数を使用して、選択した1つまたは複数のオブジェクトに出力を配置するために、ufunc呼び出しを使用したい場合があります。</target>
        </trans-unit>
        <trans-unit id="68b9dbbab83df5d12e3f17adf9850959d4114286" translate="yes" xml:space="preserve">
          <source>There are many C or C++ array/NumPy array situations not covered by a simple &lt;code&gt;%include &quot;numpy.i&quot;&lt;/code&gt; and subsequent &lt;code&gt;%apply&lt;/code&gt; directives.</source>
          <target state="translated">単純な &lt;code&gt;%include &quot;numpy.i&quot;&lt;/code&gt; およびそれに続く &lt;code&gt;%apply&lt;/code&gt; ディレクティブではカバーされない多くのCまたはC ++配列/ NumPy配列の状況があります。</target>
        </trans-unit>
        <trans-unit id="850bf20dccfb45fbea5bb3bf4cc123a24de9ce74" translate="yes" xml:space="preserve">
          <source>There are many ways to define the DFT, varying in the sign of the exponent, normalization, etc. In this implementation, the DFT is defined as</source>
          <target state="translated">指数の符号、正規化など様々な方法でDFTを定義する方法があります。この実装では、DFTは次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="76da8844fec054fd5276e6ad85d740b68fcb82e8" translate="yes" xml:space="preserve">
          <source>There are no general requirements on the return value from &lt;code&gt;__array_function__&lt;/code&gt;, although most sensible implementations should probably return array(s) with the same type as one of the function&amp;rsquo;s arguments.</source>
          <target state="translated">&lt;code&gt;__array_function__&lt;/code&gt; からの戻り値には一般的な要件はありませんが、賢明な実装のほとんどは、関数の引数の1つと同じ型の配列を返すはずです。</target>
        </trans-unit>
        <trans-unit id="95381d820ed4d179172c69e3a1efc8e39007df94" translate="yes" xml:space="preserve">
          <source>There are only integer array indices so that no subarray exists.</source>
          <target state="translated">配列のインデックスは整数だけなので、部分配列は存在しません。</target>
        </trans-unit>
        <trans-unit id="72e1214b4766467e55cb3f8f030a4456afbf45a2" translate="yes" xml:space="preserve">
          <source>There are other wrapping situations in which &lt;code&gt;numpy.i&lt;/code&gt; may be helpful when you encounter them.</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; が発生したときに役立つ場合がある他のラッピング状況があります。</target>
        </trans-unit>
        <trans-unit id="b82ec3b39568bfec9a11840bdb7b6ec4c84323cc" translate="yes" xml:space="preserve">
          <source>There are several ways to construct a masked array.</source>
          <target state="translated">マスクされた配列を構築する方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="ffbc541dfd45825fd321c5ec3bdf633ecc4c702b" translate="yes" xml:space="preserve">
          <source>There are some informational attributes that universal functions possess. None of the attributes can be set.</source>
          <target state="translated">普遍的な関数が持つ情報属性があります。いずれの属性も設定することはできません。</target>
        </trans-unit>
        <trans-unit id="014e04d63bbb11cf7242b7931500c73711d0520d" translate="yes" xml:space="preserve">
          <source>There are standard variable types for each of the numeric data types and the bool data type. Some of these are already available in the C-specification. You can create variables in extension code with these types.</source>
          <target state="translated">数値データ型とboolデータ型のそれぞれに標準的な変数型があります。これらのうちのいくつかは、C-specificationですでに利用可能です。これらの型を使って拡張コードで変数を作成することができます。</target>
        </trans-unit>
        <trans-unit id="d266f8d3fc00db82d70a1cf8a8ecaaaa80431033" translate="yes" xml:space="preserve">
          <source>There are three independent testing frameworks supported, for one-, two-, and three-dimensional arrays respectively. For one-dimensional arrays, there are two C++ files, a header and a source, named:</source>
          <target state="translated">それぞれ1次元配列、2次元配列、3次元配列の3つの独立したテストフレームワークがサポートされています。1次元配列の場合、ヘッダとソースという名前の2つのC++ファイルがあります。</target>
        </trans-unit>
        <trans-unit id="a98d06ff6365cb9b94028f7c87529f8503c9281a" translate="yes" xml:space="preserve">
          <source>There are three methods of ufuncs that require calculation similar to the general-purpose ufuncs. These are reduce, accumulate, and reduceat. Each of these methods requires a setup command followed by a loop. There are four loop styles possible for the methods corresponding to no-elements, one-element, strided-loop, and buffered- loop. These are the same basic loop styles as implemented for the general purpose function call except for the no-element and one- element cases which are special-cases occurring when the input array objects have 0 and 1 elements respectively.</source>
          <target state="translated">汎用的なufuncsと同様に計算が必要なufuncsには3つの方法があります。これらは、reduce、accumulate、reduceatです。これらのメソッドはそれぞれセットアップコマンドとループを必要とします。ループスタイルには、no-elements、one-element、strided-loop、buffered-loopの4種類があります。これらは,入力配列オブジェクトがそれぞれ0と1の要素を持つ場合に発生する特殊なケースである無要素と1要素のケースを除いては,汎用関数呼び出しに実装されているのと同じ基本的なループスタイルです.</target>
        </trans-unit>
        <trans-unit id="30d692f23dd01af5033268a8ed1b02fd45c32c1c" translate="yes" xml:space="preserve">
          <source>There are three strategies implemented that can be used to produce repeatable pseudo-random numbers across multiple processes (local or distributed).</source>
          <target state="translated">複数のプロセス(ローカルまたは分散)で再現性のある疑似乱数を生成するために使用できる3つの戦略が実装されています。</target>
        </trans-unit>
        <trans-unit id="9dfb3a62923157363de4f21bfcb4cc89da91a3e2" translate="yes" xml:space="preserve">
          <source>There are three use-cases related to memory alignment in numpy (as of 1.14):</source>
          <target state="translated">numpy のメモリアラインメントに関連したユースケースは 3 つあります (1.14 現在)。</target>
        </trans-unit>
        <trans-unit id="1878e6ac9e299677e2b59b09c76f88c728c9412d" translate="yes" xml:space="preserve">
          <source>There are times when it is important to visit the elements of an array in a specific order, irrespective of the layout of the elements in memory. The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object provides an &lt;code&gt;order&lt;/code&gt; parameter to control this aspect of iteration. The default, having the behavior described above, is order=&amp;rsquo;K&amp;rsquo; to keep the existing order. This can be overridden with order=&amp;rsquo;C&amp;rsquo; for C order and order=&amp;rsquo;F&amp;rsquo; for Fortran order.</source>
          <target state="translated">メモリ内の要素のレイアウトに関係なく、特定の順序で配列の要素にアクセスすることが重要な場合があります。&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; の&lt;/a&gt;オブジェクトが提供 &lt;code&gt;order&lt;/code&gt; 反復のこの局面を制御するパラメータ。上記の動作を持つデフォルトは、既存の順序を維持するためにorder = 'K'です。これは、Cオーダーの場合はorder = 'C'、Fortranオーダーの場合はorder = 'F'でオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="8bcb408782f4cab8808f9329f353388438a050d8" translate="yes" xml:space="preserve">
          <source>There are times when it is necessary to treat an array as a different data type than it is stored as. For instance, one may want to do all computations on 64-bit floats, even if the arrays being manipulated are 32-bit floats. Except when writing low-level C code, it&amp;rsquo;s generally better to let the iterator handle the copying or buffering instead of casting the data type yourself in the inner loop.</source>
          <target state="translated">配列を、格納されているのとは異なるデータ型として扱う必要がある場合があります。たとえば、操作される配列が32ビットの浮動小数点数であっても、64ビットの浮動小数点数ですべての計算を実行したい場合があります。低レベルのCコードを作成する場合を除いて、内部ループでデータ型を自分でキャストするのではなく、イテレータにコピーまたはバッファリングを処理させる方が一般的には適切です。</target>
        </trans-unit>
        <trans-unit id="52cac18f5846d7a58eabeae3e5d687453dc981d9" translate="yes" xml:space="preserve">
          <source>There are two Timedelta units (&amp;lsquo;Y&amp;rsquo;, years and &amp;lsquo;M&amp;rsquo;, months) which are treated specially, because how much time they represent changes depending on when they are used. While a timedelta day unit is equivalent to 24 hours, there is no way to convert a month unit into days, because different months have different numbers of days.</source>
          <target state="translated">2つのTimedelta単位（「Y」、年と「M」、月）があり、それらが使用される時間に応じてそれらが表す時間の長さが変化するため、特別に扱われます。timedelta日の単位は24時間に相当しますが、月によって日数が異なるため、月の単位を日に変換する方法はありません。</target>
        </trans-unit>
        <trans-unit id="ced97d88ae2c849acfa28a2cee713cefa36672d2" translate="yes" xml:space="preserve">
          <source>There are two major new types: the ndarray ( &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; ) and the ufunc ( &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt;&lt;code&gt;PyUFunc_Type&lt;/code&gt;&lt;/a&gt; ). Additional types play a supportive role: the &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt;&lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; . The &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt; is the type for a flat iterator for an ndarray (the object that is returned when getting the flat attribute). The &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt;&lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt;&lt;/a&gt; is the type of the object returned when calling &lt;code&gt;broadcast&lt;/code&gt; (). It handles iteration and broadcasting over a collection of nested sequences. Also, the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the data-type-descriptor type whose instances describe the data. Finally, there are 21 new scalar-array types which are new Python scalars corresponding to each of the fundamental data types available for arrays. An additional 10 other types are place holders that allow the array scalars to fit into a hierarchy of actual Python types.</source>
          <target state="translated">二つの主要な新しい種類があります。ndarray（&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;）とufunc（&lt;a href=&quot;#c.PyUFunc_Type&quot;&gt; &lt;code&gt;PyUFunc_Type&lt;/code&gt; &lt;/a&gt;）。追加のタイプは支援的な役割を果たし：&lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt; &lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; を&lt;/a&gt;。&lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; は&lt;/a&gt; ndarray（フラット属性を取得するときに返されるオブジェクト）用のフラットイテレータの型です。&lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt; &lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt; は、&lt;/a&gt;呼び出し時に返されるオブジェクトの型である &lt;code&gt;broadcast&lt;/code&gt; ）（。ネストされたシーケンスのコレクションを介して反復とブロードキャストを処理します。また、&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt;インスタンスがデータを記述するデータタイプ記述子タイプです。最後に、21の新しいスカラー配列型があります。これらは、配列で使用できる基本的なデータ型のそれぞれに対応する新しいPythonスカラーです。その他の10の型はプレースホルダーで、配列スカラーを実際のPython型の階層に適合させることができます。</target>
        </trans-unit>
        <trans-unit id="c37fba99ab33d4532607fe9319066dc8a4405878" translate="yes" xml:space="preserve">
          <source>There are two mechanisms which allow this to be done, temporary copies and buffering mode. With temporary copies, a copy of the entire array is made with the new data type, then iteration is done in the copy. Write access is permitted through a mode which updates the original array after all the iteration is complete. The major drawback of temporary copies is that the temporary copy may consume a large amount of memory, particularly if the iteration data type has a larger itemsize than the original one.</source>
          <target state="translated">これを可能にするメカニズムには,一時的なコピーとバッファリングモードの2つがあります.一時的なコピーでは,新しいデータ型で配列全体のコピーを作成し,そのコピーで反復処理を行います.書き込みアクセスは,すべての反復処理が完了した後に元の配列を更新するモードで許可されます.一時コピーの主な欠点は,一時コピーが大量のメモリを消費する可能性があること,特に反復データ型が元のデータ型よりも大きなアイテムサイズを持つ場合には,メモリを大量に消費する可能性があることです.</target>
        </trans-unit>
        <trans-unit id="bbd0e93d84494368770e6b417effb4b358f4babd" translate="yes" xml:space="preserve">
          <source>There are two modes of creating an array using &lt;code&gt;__new__&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;__new__&lt;/code&gt; を使用して配列を作成するには、2つのモードがあります。</target>
        </trans-unit>
        <trans-unit id="0373fb682b5018f30be6571b2e08840bdbbdebff" translate="yes" xml:space="preserve">
          <source>There are two ways to capture floating-point error messages. The first is to set the error-handler to &amp;lsquo;call&amp;rsquo;, using &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;. Then, set the function to call using this function.</source>
          <target state="translated">浮動小数点エラーメッセージをキャプチャするには、2つの方法があります。1つ目は、&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;を使用して、エラーハンドラーを 'call'に設定することです。次に、この関数を使用して呼び出す関数を設定します。</target>
        </trans-unit>
        <trans-unit id="7822fba8682a2c5b4fec5101c082332701ec52bb" translate="yes" xml:space="preserve">
          <source>There are two ways to effectively define a new array scalar type (apart from composing structured types &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtypes&lt;/a&gt; from the built-in scalar types): One way is to simply subclass the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and overwrite the methods of interest. This will work to a degree, but internally certain behaviors are fixed by the data type of the array. To fully customize the data type of an array you need to define a new data-type, and register it with NumPy. Such new types can only be defined in C, using the &lt;a href=&quot;c-api#c-api&quot;&gt;NumPy C-API&lt;/a&gt;.</source>
          <target state="translated">新しい配列スカラー型を効果的に定義するには2つの方法があります（組み込みのスカラー型から構造化型&lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtype&lt;/a&gt;を構成することは別として）。1つの方法は、単純に&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;をサブクラス化し、対象のメソッドを上書きすることです。これはある程度機能しますが、内部では特定の動作が配列のデータ型によって修正されています。配列のデータ型を完全にカスタマイズするには、新しいデータ型を定義し、それをNumPyに登録する必要があります。このような新しい型は、&lt;a href=&quot;c-api#c-api&quot;&gt;NumPy C-API&lt;/a&gt;を使用してCでのみ定義できます。</target>
        </trans-unit>
        <trans-unit id="07256ff1dd075c50fc2daea66eb388157aacb269" translate="yes" xml:space="preserve">
          <source>There are two ways to use the interface: A Python side and a C-side. Both are separate attributes.</source>
          <target state="translated">インターフェースの使い方は2通りあります。Python側とC側です。どちらも別属性です。</target>
        </trans-unit>
        <trans-unit id="dde43af7d13c44f94f0d79c46e9390e7c8216335" translate="yes" xml:space="preserve">
          <source>There is a Python type for each of the different built-in data types that can be present in the array Most of these are simple wrappers around the corresponding data type in C. The C-names for these types are &lt;code&gt;Py{TYPE}ArrType_Type&lt;/code&gt; where &lt;code&gt;{TYPE}&lt;/code&gt; can be</source>
          <target state="translated">配列内に存在できるさまざまな組み込みデータ型ごとにPython型があります。これらのほとんどは、Cの対応するデータ型の単純なラッパーです。これらの型のC名は &lt;code&gt;Py{TYPE}ArrType_Type&lt;/code&gt; 。 &lt;code&gt;{TYPE}&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="c0d05d2bbb1d4347eb1dace6314a1a3b989e2daa" translate="yes" xml:space="preserve">
          <source>There is a fragment for converting a Python integer to a C &lt;code&gt;long&lt;/code&gt;. There is a different fragment that converts a Python integer to a C &lt;code&gt;int&lt;/code&gt;, that calls the routine defined in the &lt;code&gt;long&lt;/code&gt; fragment. We can make the changes we want here by changing the definition for the &lt;code&gt;long&lt;/code&gt; fragment. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; determines the active definition for a fragment using a &amp;ldquo;first come, first served&amp;rdquo; system. That is, we need to define the fragment for &lt;code&gt;long&lt;/code&gt; conversions prior to &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; doing it internally. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; allows us to do this by putting our fragment definitions in the file &lt;code&gt;pyfragments.swg&lt;/code&gt;. If we were to put the new fragment definitions in &lt;code&gt;numpy.i&lt;/code&gt;, they would be ignored.</source>
          <target state="translated">Python整数をC &lt;code&gt;long&lt;/code&gt; に変換するフラグメントがあります。 Python整数をC &lt;code&gt;int&lt;/code&gt; に変換する別のフラグメントがあり、 &lt;code&gt;long&lt;/code&gt; フラグメントで定義されたルーチンを呼び出します。 &lt;code&gt;long&lt;/code&gt; フラグメントの定義を変更することで、ここで必要な変更を加えることができます。&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIGは&lt;/a&gt;、「先着順」システムを使用して、フラグメントのアクティブな定義を決定します。つまり、&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIGが&lt;/a&gt;内部で行う前に、 &lt;code&gt;long&lt;/code&gt; 変換のフラグメントを定義する必要があります。&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;では、フラグメント定義をファイル &lt;code&gt;pyfragments.swg&lt;/code&gt; に配置することでこれを行うことができます。新しいフラグメントの定義を &lt;code&gt;numpy.i&lt;/code&gt; 、それらは無視されます。</target>
        </trans-unit>
        <trans-unit id="d31593a379a881f2302877c7bf40c8ae65305ffb" translate="yes" xml:space="preserve">
          <source>There is a general need for looping over not only functions on scalars but also over functions on vectors (or arrays). This concept is realized in NumPy by generalizing the universal functions (ufuncs). In regular ufuncs, the elementary function is limited to element-by-element operations, whereas the generalized version (gufuncs) supports &amp;ldquo;sub-array&amp;rdquo; by &amp;ldquo;sub-array&amp;rdquo; operations. The Perl vector library PDL provides a similar functionality and its terms are re-used in the following.</source>
          <target state="translated">スカラーの関数だけでなく、ベクトル（または配列）の関数もループする必要があります。この概念は、汎用関数（ufunc）を一般化することによってNumPyで実現されます。通常のufuncでは、基本関数は要素ごとの操作に制限されていますが、一般化バージョン（gufuncs）は「サブ配列」による「サブ配列」操作をサポートしています。PerlベクターライブラリPDLは同様の機能を提供し、その用語は以下で再利用されます。</target>
        </trans-unit>
        <trans-unit id="16ce9fcfde9d0ef11eba9dffd6932b4fb7fe6e10" translate="yes" xml:space="preserve">
          <source>There is a list of enumerated types defined providing the basic 24 data types plus some useful generic names. Whenever the code requires a type number, one of these enumerated types is requested. The types are all called &lt;code&gt;NPY_{NAME}&lt;/code&gt;:</source>
          <target state="translated">基本的な24のデータ型といくつかの有用な総称名を提供する定義された列挙型のリストがあります。コードが型番号を必要とするときはいつでも、これらの列挙型の1つが要求されます。タイプはすべて &lt;code&gt;NPY_{NAME}&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="426d6a71d6ada6c4fe36711b0bf2acc4eb8a1d92" translate="yes" xml:space="preserve">
          <source>There is a subarray but it has exactly one element. This case can be handled as if there is no subarray, but needs some care during setup.</source>
          <target state="translated">部分配列はあるが、要素は1つだけである。この場合はサブアレイがない場合と同じように扱うことができますが、設定時には注意が必要です。</target>
        </trans-unit>
        <trans-unit id="a1e2cb9284c447866f4fcfbd5e36a19034ca7940" translate="yes" xml:space="preserve">
          <source>There is also a &amp;ldquo;flat&amp;rdquo; in-place array for situations in which you would like to modify or process each element, regardless of the number of dimensions. One example is a &amp;ldquo;quantization&amp;rdquo; function that quantizes each element of an array in-place, be it 1D, 2D or whatever. This form checks for continuity but allows either C or Fortran ordering.</source>
          <target state="translated">次元の数に関係なく、各要素を変更または処理する状況に対応する「フラット」インプレース配列もあります。1つの例は、1D、2Dなど、配列の各要素をインプレースで量子化する「量子化」関数です。このフォームは連続性をチェックしますが、CまたはFortranの順序を許可します。</target>
        </trans-unit>
        <trans-unit id="89b73fe8185f285d3a10cd617f08eb8cadb40473" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;arrays.nditer#arrays-nditer&quot;&gt;introductory guide to array iteration&lt;/a&gt; which may be of interest for those using this C API. In many instances, testing out ideas by creating the iterator in Python is a good idea before writing the C iteration code.</source>
          <target state="translated">このC APIを使用するユーザーにとって興味深い&lt;a href=&quot;arrays.nditer#arrays-nditer&quot;&gt;配列反復の入門ガイド&lt;/a&gt;があります。多くの場合、Pythonでイテレーターを作成してアイデアをテストすることは、C反復コードを作成する前に行うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="606a479ef2292dc711e91c789c67dff3002d3e8e" translate="yes" xml:space="preserve">
          <source>There is an ongoing effort to improve the API. It is important in this effort to ensure that code that compiles for NumPy 1.X continues to compile for NumPy 1.X. At the same time, certain API&amp;rsquo;s will be marked as deprecated so that future-looking code can avoid these API&amp;rsquo;s and follow better practices.</source>
          <target state="translated">APIを改善するための継続的な取り組みがあります。この取り組みでは、NumPy 1.X用にコンパイルされるコードがNumPy 1.X用にコンパイルされ続けることを保証することが重要です。同時に、将来を見据えたコードがこれらのAPIを回避し、より適切な慣行に従うように、特定のAPIは非推奨としてマークされます。</target>
        </trans-unit>
        <trans-unit id="c951415e0655e2f1d542beb400e29df172840589" translate="yes" xml:space="preserve">
          <source>There is more than one definition of sign in common use for complex numbers. The definition used here is equivalent to</source>
          <target state="translated">複素数で一般的に使われている符号の定義は1つだけではありません。ここで使われている定義は</target>
        </trans-unit>
        <trans-unit id="23297908101e96f4ab7052c44ca172ce18526477" translate="yes" xml:space="preserve">
          <source>There is one indexing array and it, as well as the assignment array, can be iterated trivially. For example they may be contiguous. Also the indexing array must be of &lt;code&gt;intp&lt;/code&gt; type and the value array in assignments should be of the correct type. This is purely a fast path.</source>
          <target state="translated">インデックス配列が1つあり、割り当て配列と同様に、簡単に繰り返すことができます。たとえば、それらは隣接している場合があります。また、インデックス配列は &lt;code&gt;intp&lt;/code&gt; タイプである必要があり、割り当ての値配列は正しいタイプである必要があります。これは純粋に高速パスです。</target>
        </trans-unit>
        <trans-unit id="df9a641fbd94988d395fb4542afcc38f2bd13355" translate="yes" xml:space="preserve">
          <source>There must be at least 1 argument, and define the last argument as &lt;em&gt;item&lt;/em&gt;. Then, &lt;code&gt;a.itemset(*args)&lt;/code&gt; is equivalent to but faster than &lt;code&gt;a[args] = item&lt;/code&gt;. The item should be a scalar value and &lt;code&gt;args&lt;/code&gt; must select a single item in the array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">少なくとも1つの引数が必要で、最後の引数を&lt;em&gt;item&lt;/em&gt;として定義し&lt;em&gt;ます&lt;/em&gt;。次に、 &lt;code&gt;a.itemset(*args)&lt;/code&gt; は、 &lt;code&gt;a[args] = item&lt;/code&gt; と同等ですが、それより高速です。項目はスカラー値である必要があり、 &lt;code&gt;args&lt;/code&gt; は配列 &lt;code&gt;a&lt;/code&gt; 内の単一の項目を選択する必要があります。</target>
        </trans-unit>
        <trans-unit id="bc33808ec0ca031cf8b9c1fdd7c9278c78f0db38" translate="yes" xml:space="preserve">
          <source>There was no __array_interface__ attribute instead all of the keys (except for version) in the __array_interface__ dictionary were their own attribute: Thus to obtain the Python-side information you had to access separately the attributes:</source>
          <target state="translated">その代わりに__array_interface__属性は存在せず、__array_interface__辞書の全てのキー(バージョンを除く)はそれぞれの属性でした。このように、Python側の情報を得るためには、個別に属性にアクセスしなければなりませんでした。</target>
        </trans-unit>
        <trans-unit id="1d3ca63c0d0c4fb92d45d132b89354f4e2a0e2fc" translate="yes" xml:space="preserve">
          <source>There will not be anything &lt;em&gt;wrong&lt;/em&gt; with the results, per se; even a seed of 0 is perfectly fine thanks to the processing that &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; does. If you just need &lt;em&gt;some&lt;/em&gt; fixed value for unit tests or debugging, feel free to use whatever seed you like. But if you want to make inferences from the results or publish them, drawing from a larger set of seeds is good practice.</source>
          <target state="translated">結果自体には&lt;em&gt;問題&lt;/em&gt;はありません。&lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;が行う処理のおかげで、0のシードでさえ完全に問題ありません。あなただけが必要な場合は&lt;em&gt;、いくつかの&lt;/em&gt;ユニットテストのための固定値をやデバッグ、あなたが好きな種子を使用して自由に感じます。しかし、結果から推論したり、それらを公開したりする場合は、より多くのシードのセットから描画することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="de5a5e9111615649ff06d77b214a9aa4744c2e9e" translate="yes" xml:space="preserve">
          <source>These Boolean-valued flags affect how numpy interprets the memory area used by &lt;code&gt;a&lt;/code&gt; (see Notes below). The ALIGNED flag can only be set to True if the data is actually aligned according to the type. The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set to True. The flag WRITEABLE can only be set to True if the array owns its own memory, or the ultimate owner of the memory exposes a writeable buffer interface, or is a string. (The exception for string is made so that unpickling can be done without copying memory.)</source>
          <target state="translated">これらのブール値フラグは、numpyが &lt;code&gt;a&lt;/code&gt; によって使用されるメモリ領域を解釈する方法に影響します（下記の注を参照）。ALIGNEDフラグをTrueに設定できるのは、データが実際にタイプに従って配置されている場合のみです。WRITEBACKIFCOPYフラグおよび（非推奨）UPDATEIFCOPYフラグをTrueに設定することはできません。フラグWRITEABLEをTrueに設定できるのは、配列が独自のメモリを所有している場合、またはメモリの最終的な所有者が書き込み可能なバッファインターフェイスを公開している場合、または文字列の場合のみです。（stringの例外は、メモリをコピーせずにunpickleを実行できるようにするためです。）</target>
        </trans-unit>
        <trans-unit id="7faf38a4c03dd7b8b5f6a940a17e52f4253526ca" translate="yes" xml:space="preserve">
          <source>These all achieve the same result:</source>
          <target state="translated">これらはすべて同じ結果をもたらします。</target>
        </trans-unit>
        <trans-unit id="ca33633bc8f8738d475e05fabdb7eda73e305c81" translate="yes" xml:space="preserve">
          <source>These are defined for &lt;code&gt;{bits}&lt;/code&gt; = 8, 16, 32, 64, 128, and 256 and provide the maximum (minimum) value of the corresponding (unsigned) integer type. Note: the actual integer type may not be available on all platforms (i.e. 128-bit and 256-bit integers are rare).</source>
          <target state="translated">これらは &lt;code&gt;{bits}&lt;/code&gt; = 8、16、32、64、128、および256 に対して定義され、対応する（符号なし）整数型の最大（最小）値を提供します。注：実際の整数型はすべてのプラットフォームで使用できるわけではありません（つまり、128ビットおよび256ビットの整数はまれです）。</target>
        </trans-unit>
        <trans-unit id="8ddb00a13475a7300c7d1510545ce91de444184f" translate="yes" xml:space="preserve">
          <source>These are enhanced arrays of either &lt;code&gt;string_&lt;/code&gt; type or &lt;code&gt;unicode_&lt;/code&gt; type. These arrays inherit from the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, but specially-define the operations &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt; on a (broadcasting) element-by-element basis. These operations are not available on the standard &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; of character type. In addition, the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; has all of the standard &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; (and &lt;code&gt;unicode&lt;/code&gt;) methods, executing them on an element-by-element basis. Perhaps the easiest way to create a chararray is to use &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;self.view(chararray)&lt;/code&gt;&lt;/a&gt; where &lt;em&gt;self&lt;/em&gt; is an ndarray of str or unicode data-type. However, a chararray can also be created using the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;numpy.chararray&lt;/code&gt;&lt;/a&gt; constructor, or via the &lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt;&lt;code&gt;numpy.char.array&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">これらは、 &lt;code&gt;string_&lt;/code&gt; タイプまたは &lt;code&gt;unicode_&lt;/code&gt; タイプの拡張配列です。これらの配列は&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; を&lt;/a&gt;継承しますが、要素ごとに（ブロードキャスト）要素ごとに演算 &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、および &lt;code&gt;%&lt;/code&gt; を特別に定義します。これらの操作は、文字型の標準&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;では使用できません。さらに、&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; に&lt;/a&gt;はすべての標準&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt;（および &lt;code&gt;unicode&lt;/code&gt; ）メソッドがあり、要素ごとに実行されます。おそらくchararrayを作成する最も簡単な方法は、使用することです&lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;self.view(chararray)&lt;/code&gt; を&lt;/a&gt;&lt;em&gt;自己&lt;/em&gt;strまたはunicodeデータ型のndarrayです。ただし、charpyは&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;numpy.chararray&lt;/code&gt; &lt;/a&gt;コンストラクターを使用して、または&lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt; &lt;code&gt;numpy.char.array&lt;/code&gt; &lt;/a&gt;関数を介して作成することもできます。</target>
        </trans-unit>
        <trans-unit id="5c5d09f4ce60946e76740852fd56ca7c8c49e5bd" translate="yes" xml:space="preserve">
          <source>These are roughly ordered from least-to-most precision.</source>
          <target state="translated">これらは、大まかには最小精度のものから順に並べられています。</target>
        </trans-unit>
        <trans-unit id="2ce5765c6141294e2d5121321badaf2a8b57c10d" translate="yes" xml:space="preserve">
          <source>These are some detailed notes, which are not of importance for day to day indexing (in no particular order):</source>
          <target state="translated">これらは、日々のインデックス作成にはあまり重要ではない詳細なメモです(順不同)。</target>
        </trans-unit>
        <trans-unit id="3f20305498e715f2e7a95c2c0aa48306a2b1d79a" translate="yes" xml:space="preserve">
          <source>These are the arrays for the operation.</source>
          <target state="translated">これらは操作のための配列です。</target>
        </trans-unit>
        <trans-unit id="7a1ac004102d237171aefc6abd621531cd490cc4" translate="yes" xml:space="preserve">
          <source>These are the constants and functions for accessing the ufunc C-API from extension modules in precisely the same way as the array C-API can be accessed. The &lt;code&gt;import_ufunc&lt;/code&gt; () function must always be called (in the initialization subroutine of the extension module). If your extension module is in one file then that is all that is required. The other two constants are useful if your extension module makes use of multiple files. In that case, define &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to something unique to your code and then in source files that do not contain the module initialization function but still need access to the UFUNC API, define &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to the same name used previously and also define &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt;&lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これらは、配列C-APIにアクセスできるのとまったく同じ方法で、拡張モジュールからufunc C-APIにアクセスするための定数と関数です。 &lt;code&gt;import_ufunc&lt;/code&gt; （）関数は、常に、（拡張モジュールの初期化サブルーチンで）呼び出されなければなりません。拡張モジュールが1つのファイルにある場合は、それだけで十分です。他の2つの定数は、拡張モジュールが複数のファイルを使用する場合に役立ちます。その場合には、定義&lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; を&lt;/a&gt;あなたのコードに固有のものにして、モジュールの初期化機能が含まれているが、それでもUFUNC APIへのアクセスを必要としないソースファイルで、定義&lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; を&lt;/a&gt;同じ名前に以前に使用しても定義&lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt; &lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0aaea1e5f2c4b6d0e0dc28a8aa40e102fa58beb" translate="yes" xml:space="preserve">
          <source>These are the indices that would allow you to access the upper triangular part of any 3x3 array:</source>
          <target state="translated">これらは、3x3配列の上部の三角形部分にアクセスできるようにするためのインデックスです。</target>
        </trans-unit>
        <trans-unit id="43efdc6f451764645e6025c80a5a83f304f68569" translate="yes" xml:space="preserve">
          <source>These are typically used in situations where in C/C++, you would allocate a(n) array(s) on the heap, and call the function to fill the array(s) values. In Python, the arrays are allocated for you and returned as new array objects.</source>
          <target state="translated">これらは通常、C/C++ではヒープ上に(n)個の配列を確保し、その配列の値を埋めるために関数を呼び出すような状況で使用されます。Pythonでは、配列はあなたのために確保され、新しい配列オブジェクトとして返されます。</target>
        </trans-unit>
        <trans-unit id="a93c5dc49de55891886f179425b788a1c6ad1b35" translate="yes" xml:space="preserve">
          <source>These arrays are views on the original arrays. They are typically not contiguous. Furthermore, more than one element of a broadcasted array may refer to a single memory location. If you need to write to the arrays, make copies first. While you can set the &lt;code&gt;writable&lt;/code&gt; flag True, writing to a single output value may end up changing more than one location in the output array.</source>
          <target state="translated">これらの配列は、元の配列のビューです。それらは通常隣接していません。さらに、ブロードキャストされた配列の複数の要素が単一のメモリ位置を参照する場合があります。アレイに書き込む必要がある場合は、最初にコピーを作成してください。 &lt;code&gt;writable&lt;/code&gt; フラグをTrueに設定できますが、単一の出力値に書き込むと、出力配列の複数の場所が変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="7f0acac4ec85b4b4bd7ae1e0ff5a3f9603fcfbc3" translate="yes" xml:space="preserve">
          <source>These constants are used in &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; (and its macro forms) to specify desired properties of the new array.</source>
          <target state="translated">これらの定数は&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;（およびそのマクロ形式）で使用され、新しい配列の必要なプロパティを指定します。</target>
        </trans-unit>
        <trans-unit id="3d245bb5214c903868626d468b5ef8607e3f9a4a" translate="yes" xml:space="preserve">
          <source>These cover almost the whole array (two diagonals right of the main one):</source>
          <target state="translated">これらは、配列のほぼ全体をカバーしています(主なものの右にある2つの斜めのもの)。</target>
        </trans-unit>
        <trans-unit id="f7e900132de2199b00f5d74615e0a1848ce14490" translate="yes" xml:space="preserve">
          <source>These cover only a small part of the whole array (two diagonals right of the main one):</source>
          <target state="translated">これらは、アレイ全体のごく一部をカバーしています(主なものの右にある2つの斜めをカバーしています)。</target>
        </trans-unit>
        <trans-unit id="63868acfbf699fe963e728a55308e7d3a9b22eb9" translate="yes" xml:space="preserve">
          <source>These examples illustrate the low-level &lt;a href=&quot;#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; constructor. Refer to the &lt;code&gt;See Also&lt;/code&gt; section above for easier ways of constructing an ndarray.</source>
          <target state="translated">これらの例は、低レベルの&lt;a href=&quot;#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;コンストラクターを示しています。ndarrayを構築する簡単な方法については、上記の &lt;code&gt;See Also&lt;/code&gt; セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="8a348b17d2fb1b33a90b7baa8a557d9af808a018" translate="yes" xml:space="preserve">
          <source>These function all require integer arguments and they manipulate the bit-pattern of those arguments.</source>
          <target state="translated">これらの関数はすべて整数の引数を必要とし、それらの引数のビットパターンを操作します。</target>
        </trans-unit>
        <trans-unit id="d7e647d09c10f9f4521e851e5661f2624622c65e" translate="yes" xml:space="preserve">
          <source>These functions along with a minimal setup file are included in the examples folder.</source>
          <target state="translated">これらの関数と最小限のセットアップファイルは、examples フォルダに含まれています。</target>
        </trans-unit>
        <trans-unit id="47c8ad5dd0ea816b255a3666826ae66a37ff3a15" translate="yes" xml:space="preserve">
          <source>These functions and macros provide easy access to elements of the ndarray from C. These work for all arrays. You may need to take care when accessing the data in the array, however, if it is not in machine byte-order, misaligned, or not writeable. In other words, be sure to respect the state of the flags unless you know what you are doing, or have previously guaranteed an array that is writeable, aligned, and in machine byte-order using &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt;. If you wish to handle all types of arrays, the copyswap function for each type is useful for handling misbehaved arrays. Some platforms (e.g. Solaris) do not like misaligned data and will crash if you de-reference a misaligned pointer. Other platforms (e.g. x86 Linux) will just work more slowly with misaligned data.</source>
          <target state="translated">これらの関数とマクロにより、Cからndarrayの要素に簡単にアクセスできます。これらはすべての配列で機能します。ただし、配列内のデータにアクセスするときは、マシンのバイト順でない場合、整列されていない場合、または書き込み可能でない場合は、注意が必要な場合があります。言い換えれば、何をしているのかが分からない場合、または&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;を使用して書き込み可能で整列されたマシンのバイト順の配列が以前に保証されていない限り、フラグの状態を尊重するようにしてください。すべてのタイプの配列を処理したい場合、各タイプのcopyswap関数は、正しく動作しない配列を処理するのに役立ちます。一部のプラットフォーム（Solarisなど）は、不整合データを好まないため、不整合ポインタを逆参照するとクラッシュします。他のプラットフォーム（x86 Linuxなど）は、誤って配置されたデータを使用すると、動作が遅くなります。</target>
        </trans-unit>
        <trans-unit id="a0b164307df93568d43c0a9ad269b4dbe393e0e6" translate="yes" xml:space="preserve">
          <source>These functions are included here because they are used at least once in the array object&amp;rsquo;s methods. The function returns -1 (without setting a Python Error) if one of the objects being assigned is not callable.</source>
          <target state="translated">これらの関数は、配列オブジェクトのメソッドで少なくとも1回使用されるため、ここに含まれています。割り当てられているオブジェクトの1つが呼び出し可能でない場合、関数は（Pythonエラーを設定せずに）-1を返します。</target>
        </trans-unit>
        <trans-unit id="13b269cced89ab6392bc06c8030f96e4b737c057" translate="yes" xml:space="preserve">
          <source>These macros all access the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure members. The input argument, arr, can be any &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that is directly interpretable as a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; (any instance of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and its sub-types).</source>
          <target state="translated">これらのマクロはすべて&lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;構造体のメンバーにアクセスします。入力引数arr は、&lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;とそのサブタイプのインスタンス）として直接解釈可能な任意の&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; にする&lt;/a&gt;ことができます。</target>
        </trans-unit>
        <trans-unit id="0b21dcbffd2b61b3d3ee30959d3bc33fc08a9c74" translate="yes" xml:space="preserve">
          <source>These macros are only meaningful if &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; evaluates True during compilation of the extension module. Otherwise, these macros are equivalent to whitespace. Python uses a single Global Interpreter Lock (GIL) for each Python process so that only a single thread may execute at a time (even on multi-cpu machines). When calling out to a compiled function that may take time to compute (and does not have side-effects for other threads like updated global variables), the GIL should be released so that other Python threads can run while the time-consuming calculations are performed. This can be accomplished using two groups of macros. Typically, if one macro in a group is used in a code block, all of them must be used in the same code block. Currently, &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined to the python-defined &lt;code&gt;WITH_THREADS&lt;/code&gt; constant unless the environment variable &lt;code&gt;NPY_NOSMP&lt;/code&gt; is set in which case &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined to be 0.</source>
          <target state="translated">これらのマクロは、拡張モジュールのコンパイル中に &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; が Trueを評価する場合にのみ意味があります。それ以外の場合、これらのマクロは空白と同等です。 Pythonは、Pythonプロセスごとに単一のグローバルインタープリターロック（GIL）を使用するため、一度に実行できるスレッドは1つだけです（マルチCPUマシンでも）。計算に時間がかかる可能性がある（更新されたグローバル変数のような他のスレッドに副作用がない）コンパイルされた関数を呼び出す場合、GILを解放して、時間のかかる計算が実行されている間に他のPythonスレッドを実行できるようにする必要があります。 。これは、マクロの2つのグループを使用して実現できます。通常、グループ内の1つのマクロがコードブロックで使用される場合、それらすべてを同じコードブロックで使用する必要があります。現在、 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 環境変数 &lt;code&gt;NPY_NOSMP&lt;/code&gt; が設定されていない限り、pythonで定義された &lt;code&gt;WITH_THREADS&lt;/code&gt; 定数に定義されます。この場合、 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; は0として定義されます。</target>
        </trans-unit>
        <trans-unit id="da2fff533a172874c502697494e5cdbf3a7c39b3" translate="yes" xml:space="preserve">
          <source>These macros use different memory allocators, depending on the constant &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt;. The system malloc is used when &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; is 0, if &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; is 1, then the Python memory allocator is used.</source>
          <target state="translated">これらのマクロは、定数 &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; に応じて、異なるメモリアロケータを使用します。 &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; が0の場合、システムmallocが使用されます &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; が1の場合、Python メモリアロケーターが使用されます。</target>
        </trans-unit>
        <trans-unit id="512de4565bde2a4a800d6eb7f4ecd21ece637307" translate="yes" xml:space="preserve">
          <source>These members are both pointers to functions to copy data from &lt;em&gt;src&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;swap&lt;/em&gt; if indicated. The value of arr is only used for flexible ( &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ) arrays (and is obtained from &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; ). The second function copies a single value, while the first loops over n values with the provided strides. These functions can deal with misbehaved &lt;em&gt;src&lt;/em&gt; data. If &lt;em&gt;src&lt;/em&gt; is NULL then no copy is performed. If &lt;em&gt;swap&lt;/em&gt; is 0, then no byteswapping occurs. It is assumed that &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;src&lt;/em&gt; do not overlap. If they overlap, then use &lt;code&gt;memmove&lt;/code&gt; (&amp;hellip;) first followed by &lt;code&gt;copyswap(n)&lt;/code&gt; with NULL valued &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">これらのメンバーは、関数へのポインタの両方からデータをコピーしている&lt;em&gt;SRC&lt;/em&gt;に&lt;em&gt;はdest&lt;/em&gt;と&lt;em&gt;スワップ&lt;/em&gt;示された場合。 arrの値は、フレキシブル（&lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt; &lt;code&gt;NPY_STRING&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt; &lt;code&gt;NPY_UNICODE&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt; &lt;code&gt;NPY_VOID&lt;/code&gt; &lt;/a&gt;）配列（および &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; から取得）にのみ使用されます。 2番目の関数は単一の値をコピーし、最初の関数は提供されたストライドでn個の値をループします。これらの関数は、正しく動作しない&lt;em&gt;src&lt;/em&gt;データを処理できます。場合&lt;em&gt;srcが&lt;/em&gt; NULLであるその後、コピーは実行されません。&lt;em&gt;swap&lt;/em&gt;が0の場合、バイト&lt;em&gt;スワップ&lt;/em&gt;は発生しません。これは想定されている&lt;em&gt;DEST&lt;/em&gt;および&lt;em&gt;SRC&lt;/em&gt;重複しないでください。それらが重複している場合は、最初に &lt;code&gt;memmove&lt;/code&gt; （&amp;hellip;）を使用し、次にNULL値の &lt;code&gt;src&lt;/code&gt; を &lt;code&gt;copyswap(n)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="d6721252244f80ca68ee960086197a2ea6f31616" translate="yes" xml:space="preserve">
          <source>These numbers in the previous line represent (0, 0) to machine precision</source>
          <target state="translated">前の行のこれらの数字は、機械精度に対して(0,0)を表しています。</target>
        </trans-unit>
        <trans-unit id="dc06d74801540c694b86fd1603123c1d29a31d44" translate="yes" xml:space="preserve">
          <source>These options determine the way floating point numbers, arrays and other NumPy objects are displayed.</source>
          <target state="translated">これらのオプションは、浮動小数点数や配列、その他のNumPyオブジェクトの表示方法を決定します。</target>
        </trans-unit>
        <trans-unit id="dcba0fcabfaea90dcbb4dedc9f83dbe704fc9440" translate="yes" xml:space="preserve">
          <source>These pointers are different from the pointers accepted by &lt;code&gt;NpyIter_ResetBasePointers&lt;/code&gt;, because the direction along some axes may have been reversed.</source>
          <target state="translated">これらのポインターは、一部の軸に沿った方向が逆になっている可能性があるため、 &lt;code&gt;NpyIter_ResetBasePointers&lt;/code&gt; が受け入れるポインターとは異なります。</target>
        </trans-unit>
        <trans-unit id="43a8a14f212cc60aa00fe9447268d1975d32ef40" translate="yes" xml:space="preserve">
          <source>These properties together mean that we can safely mix together the usual user-provided seed with simple incrementing counters to get &lt;code&gt;BitGenerator&lt;/code&gt; states that are (to very high probability) independent of each other. We can wrap this together into an API that is easy to use and difficult to misuse.</source>
          <target state="translated">これらのプロパティを組み合わせると、通常のユーザー提供のシードと単純な増分カウンターを安全に組み合わせて、（非常に高い確率で）互いに独立した &lt;code&gt;BitGenerator&lt;/code&gt; 状態を取得できます。これを、使いやすく、誤用しにくいAPIにまとめることができます。</target>
        </trans-unit>
        <trans-unit id="f0fbc806872e828602fd0c760ad7240ac769262d" translate="yes" xml:space="preserve">
          <source>These two macros are similar and obtain the pointer to the data-buffer for the array. The first macro can (and should be) assigned to a particular pointer where the second is for generic processing. If you have not guaranteed a contiguous and/or aligned array then be sure you understand how to access the data in the array to avoid memory and/or alignment problems.</source>
          <target state="translated">これら2つのマクロは類似しており、配列のデータバッファへのポインタを取得します。最初のマクロは特定のポインタに代入することができます(そして代入すべきです)が、2番目のマクロは一般的な処理のためのものです。配列の連続性やアラインメントが保証されていない場合は,メモリやアラインメントの問題を避けるために,配列内のデータにアクセスする方法を理解しておく必要があります.</target>
        </trans-unit>
        <trans-unit id="be4a900566749a67d476933d0258a41ade60543e" translate="yes" xml:space="preserve">
          <source>These type names are part of the C-API and can therefore be created in extension C-code. There is also a &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; and a &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; that are simple substitutes for one of the integer types that can hold a pointer on the platform. The structure of these scalar objects is not exposed to C-code. The function &lt;a href=&quot;c-api.array#c.PyArray_ScalarAsCtype&quot;&gt;&lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt;&lt;/a&gt; (..) can be used to extract the C-type value from the array scalar and the function &lt;a href=&quot;c-api.array#c.PyArray_Scalar&quot;&gt;&lt;code&gt;PyArray_Scalar&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to construct an array scalar from a C-value.</source>
          <target state="translated">これらのタイプ名はC-APIの一部であるため、拡張Cコードで作成できます。あり &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; と &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; プラットフォーム上のポインタを保持できる整数型のいずれかのための簡単な代替です。これらのスカラーオブジェクトの構造は、Cコードに公開されていません。関数&lt;a href=&quot;c-api.array#c.PyArray_ScalarAsCtype&quot;&gt; &lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt; &lt;/a&gt;（..）を使用して配列スカラーからCタイプの値を抽出し、関数&lt;a href=&quot;c-api.array#c.PyArray_Scalar&quot;&gt; &lt;code&gt;PyArray_Scalar&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）を使用してC値から配列スカラーを構築できます。</target>
        </trans-unit>
        <trans-unit id="39c33e43ad465d1114668c2913272d120aead183" translate="yes" xml:space="preserve">
          <source>These typemaps now check to make sure that the &lt;code&gt;INPLACE_ARRAY&lt;/code&gt; arguments use native byte ordering. If not, an exception is raised.</source>
          <target state="translated">これらのタイプマップは、 &lt;code&gt;INPLACE_ARRAY&lt;/code&gt; 引数がネイティブのバイト順序を使用していることを確認するようになりました。そうでない場合は、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="afffd3e5751f118e6c4a8e5fa416a0de7397d2ff" translate="yes" xml:space="preserve">
          <source>These values are appended to a copy of &lt;code&gt;a&lt;/code&gt;. It must be of the correct shape (the same shape as &lt;code&gt;a&lt;/code&gt;, excluding &lt;code&gt;axis&lt;/code&gt;). If &lt;code&gt;axis&lt;/code&gt; is not specified, &lt;code&gt;b&lt;/code&gt; can be any shape and will be flattened before use.</source>
          <target state="translated">これらの値は、のコピーに追加されます。これは、正しい形状（同じ形状である必要があり、除く &lt;code&gt;axis&lt;/code&gt; ）。 &lt;code&gt;axis&lt;/code&gt; が指定されていない場合、 &lt;code&gt;b&lt;/code&gt; は任意の形状にすることができ、使用前に平坦化されます。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="612fafedc61071a5e61db03c65c0f553ab91df63" translate="yes" xml:space="preserve">
          <source>These values are appended to a copy of &lt;code&gt;arr&lt;/code&gt;. It must be of the correct shape (the same shape as &lt;code&gt;arr&lt;/code&gt;, excluding &lt;code&gt;axis&lt;/code&gt;). If &lt;code&gt;axis&lt;/code&gt; is not specified, &lt;code&gt;values&lt;/code&gt; can be any shape and will be flattened before use.</source>
          <target state="translated">これらの値は &lt;code&gt;arr&lt;/code&gt; のコピーに追加されます。正しい形状（ &lt;code&gt;axis&lt;/code&gt; を除いて &lt;code&gt;arr&lt;/code&gt; と同じ形状）でなければなりません。 &lt;code&gt;axis&lt;/code&gt; が指定されていない場合、 &lt;code&gt;values&lt;/code&gt; は任意の形状にすることができ、使用前に平坦化されます。</target>
        </trans-unit>
        <trans-unit id="c265d10397c2203b05e143772f5cfb33ffa2cf8c" translate="yes" xml:space="preserve">
          <source>These values are only returned if &lt;code&gt;full&lt;/code&gt; = True</source>
          <target state="translated">これらの値は、 &lt;code&gt;full&lt;/code&gt; = Trueの場合にのみ返されます</target>
        </trans-unit>
        <trans-unit id="94c85fa0224cf9a04b1b6ccf08fcebfe46c06507" translate="yes" xml:space="preserve">
          <source>These values will be element-wise interpolated into the string.</source>
          <target state="translated">これらの値は、文字列に要素ごとに補間されます。</target>
        </trans-unit>
        <trans-unit id="d528fd04772fea95a1dd88b443f26490baf33962" translate="yes" xml:space="preserve">
          <source>Things are a little bit more tricky when combining reduction and allocated operands. Before iteration is started, any reduction operand must be initialized to its starting values. Here&amp;rsquo;s how we can do this, taking sums along the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">リダクションオペランドと割り当てられたオペランドを組み合わせる場合は、少し注意が必要です。反復を開始する前に、すべてのリダクションオペランドを初期値に初期化する必要があります。ここでは、最後の軸に沿って合計を取って、これを行うことができます方法です。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="998943208ea6deef89245cfe0875a67c35f9b773" translate="yes" xml:space="preserve">
          <source>Think of &lt;a href=&quot;#numpy.linalg.multi_dot&quot;&gt;&lt;code&gt;multi_dot&lt;/code&gt;&lt;/a&gt; as:</source>
          <target state="translated">&lt;a href=&quot;#numpy.linalg.multi_dot&quot;&gt; &lt;code&gt;multi_dot&lt;/code&gt; &lt;/a&gt;は次のように考えてください。</target>
        </trans-unit>
        <trans-unit id="269959a51cb8489ddd62f29ffab3f7d5a6b40d53" translate="yes" xml:space="preserve">
          <source>This Chapter attempts to explain the logic behind some of the new pieces of code. The purpose behind these explanations is to enable somebody to be able to understand the ideas behind the implementation somewhat more easily than just staring at the code. Perhaps in this way, the algorithms can be improved on, borrowed from, and/or optimized by more people.</source>
          <target state="translated">この章では、いくつかの新しいコードの背後にあるロジックを説明しようとしています。これらの説明の背後にある目的は、コードを見ているだけではなく、実装の背後にある考え方を誰かがより簡単に理解できるようにすることです。おそらくこのようにして、より多くの人がアルゴリズムを改良したり、借りたり、最適化したりすることができるようになるでしょう。</target>
        </trans-unit>
        <trans-unit id="d8eb7804ceb212518c04178ca9353c5652cddc34" translate="yes" xml:space="preserve">
          <source>This address may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it. The value itself may change during iteration, in particular if buffering is enabled. This function may be safely called without holding the Python GIL.</source>
          <target state="translated">このアドレスは反復ループの前にキャッシュされる可能性があり、 &lt;code&gt;iternext&lt;/code&gt; を呼び出しても変更されません。特にバッファリングが有効になっている場合、反復中に値自体が変更される可能性があります。この関数は、Python GILを保持せずに安全に呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="2dacb6ef0aabe4e0449ac2f7d6e826edb424af8c" translate="yes" xml:space="preserve">
          <source>This advanced indexing occurs when obj is an array object of Boolean type, such as may be returned from comparison operators. A single boolean index array is practically identical to &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; where, as described above, &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;obj.nonzero()&lt;/code&gt;&lt;/a&gt; returns a tuple (of length &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt;&lt;code&gt;obj.ndim&lt;/code&gt;&lt;/a&gt;) of integer index arrays showing the &lt;code&gt;True&lt;/code&gt; elements of &lt;em&gt;obj&lt;/em&gt;. However, it is faster when &lt;code&gt;obj.shape == x.shape&lt;/code&gt;.</source>
          <target state="translated">この高度なインデックス付けは、objが比較演算子から返されるようなブール型の配列オブジェクトである場合に発生します。単一のブールインデックス配列は、 &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; と実質的に同じです。上記のように、&lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;obj.nonzero()&lt;/code&gt; &lt;/a&gt;は、&lt;em&gt;objの&lt;/em&gt; &lt;code&gt;True&lt;/code&gt; 要素を示す整数インデックス配列の（長さ&lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt; &lt;code&gt;obj.ndim&lt;/code&gt; の&lt;/a&gt;）タプルを返します。ただし、 &lt;code&gt;obj.shape == x.shape&lt;/code&gt; 場合は高速です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d160c6be16a498bbc805a56a17ad9724ae3c358b" translate="yes" xml:space="preserve">
          <source>This applies type promotion to all the inputs, using the NumPy rules for combining scalars and arrays, to determine the output type of a set of operands. This is the same result type that ufuncs produce. The specific algorithm used is as follows.</source>
          <target state="translated">これは、スカラと配列を結合するためのNumPyのルールを使用して、すべての入力に型昇格を適用し、オペランドのセットの出力型を決定します。これは、ufuncsが生成するのと同じ結果型です。使用される具体的なアルゴリズムは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="2e8bc0cbcc5f069a41dc6497b9c0a909fd514a44" translate="yes" xml:space="preserve">
          <source>This approach to the array interface allows for faster access to an array using only one attribute lookup and a well-defined C-structure.</source>
          <target state="translated">この配列インターフェースへのアプローチにより、1つの属性ルックアップとよく定義されたC構造のみを使用して、より高速に配列にアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="b2cfa3868ca6d5d3eec71f613d2a281e952e696d" translate="yes" xml:space="preserve">
          <source>This approach to the interface consists of the object having an &lt;a href=&quot;#__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">インターフェイスへのこのアプローチは、&lt;a href=&quot;#__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; &lt;/a&gt;属性を持つオブジェクトで構成されます。</target>
        </trans-unit>
        <trans-unit id="e27c7321ec2c09e2c1e41b0fb7ac933d7973957f" translate="yes" xml:space="preserve">
          <source>This arrangement allow for very flexible use of arrays. One thing that it allows is simple changes of the metadata to change the interpretation of the array buffer. Changing the byteorder of the array is a simple change involving no rearrangement of the data. The shape of the array can be changed very easily without changing anything in the data buffer or any data copying at all</source>
          <target state="translated">この配置は、配列を非常に柔軟に使用することを可能にします。一つは、配列バッファの解釈を変更するためにメタデータを簡単に変更することです。配列のバイト順を変更することは、データの再配置を伴わない簡単な変更です。配列の形状は、データバッファ内の何も変更することなく、またデータのコピーも全く行わずに、非常に簡単に変更することができます。</target>
        </trans-unit>
        <trans-unit id="13b0f80cc0af4acb749cdb54d3ae94021e334ad5" translate="yes" xml:space="preserve">
          <source>This array creation routine allows for the convenient creation of a new array matching an existing array&amp;rsquo;s shapes and memory layout, possibly changing the layout and/or data type.</source>
          <target state="translated">この配列作成ルーチンを使用すると、既存の配列の形状とメモリレイアウトに一致する新しい配列を簡単に作成でき、レイアウトやデータタイプを変更できます。</target>
        </trans-unit>
        <trans-unit id="b6ad81be881df54f2faa5255b14c490a53a2cd92" translate="yes" xml:space="preserve">
          <source>This array is a copy of some other array. The C-API function PyArray_ResolveWritebackIfCopy must be called before deallocating to the base array will be updated with the contents of this array.</source>
          <target state="translated">この配列は他の配列のコピーです。C-API関数PyArray_ResolveWritebackIfCopyを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="9975deeda2df7b42c75df625b9b5fc69426c2203" translate="yes" xml:space="preserve">
          <source>This array is stored in memory as 40 bytes, one after the other (known as a contiguous block of memory). The strides of an array tell us how many bytes we have to skip in memory to move to the next position along a certain axis. For example, we have to skip 4 bytes (1 value) to move to the next column, but 20 bytes (5 values) to get to the same position in the next row. As such, the strides for the array &lt;code&gt;x&lt;/code&gt; will be &lt;code&gt;(20, 4)&lt;/code&gt;.</source>
          <target state="translated">この配列は、40バイトとしてメモリに連続して格納されます（連続したメモリブロックと呼ばれます）。配列のストライドは、特定の軸に沿って次の位置に移動するためにメモリでスキップする必要があるバイト数を示します。たとえば、次の列に移動するには4バイト（1つの値）をスキップする必要がありますが、次の行の同じ位置に移動するには20バイト（5つの値）をスキップする必要があります。このように、アレイのためのストライド &lt;code&gt;x&lt;/code&gt; があろう &lt;code&gt;(20, 4)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ed5fe179d122dc6d0ff4af8af1bf207796107b0" translate="yes" xml:space="preserve">
          <source>This array is the mask for all &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;writemasked&lt;/code&gt;&lt;/a&gt; operands. Code uses the &lt;code&gt;writemasked&lt;/code&gt; flag which indicates that only elements where the chosen ARRAYMASK operand is True will be written to. In general, the iterator does not enforce this, it is up to the code doing the iteration to follow that promise.</source>
          <target state="translated">この配列は、すべての&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;writemasked&lt;/code&gt; &lt;/a&gt;マスクされたオペランドのマスクです。コードは、選択されたARRAYMASKオペランドがTrueである要素のみに書き込まれることを示す &lt;code&gt;writemasked&lt;/code&gt; フラグを使用します。一般に、イテレータはこれを強制しません。その約束に従って反復を行うのはコード次第です。</target>
        </trans-unit>
        <trans-unit id="da76cf9484436ae5f595cbe33ce62d99eee348ae" translate="yes" xml:space="preserve">
          <source>This array is used in computing an N-d index from a 1-d index. It contains needed products of the dimensions.</source>
          <target state="translated">この配列は,1次元のインデックスからN次元のインデックスを計算する際に使用されます.次元の必要積が格納されています.</target>
        </trans-unit>
        <trans-unit id="2950d768bc15bd8305b22a36aa90ddcbd53411a1" translate="yes" xml:space="preserve">
          <source>This array method can be conveniently chained:</source>
          <target state="translated">この配列メソッドは、便利に連鎖させることができます。</target>
        </trans-unit>
        <trans-unit id="cd59928fafb5b8b3afd2257d5348ff12e61a3751" translate="yes" xml:space="preserve">
          <source>This array must contain integers in &lt;code&gt;[0, n-1]&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of choices, unless &lt;code&gt;mode=wrap&lt;/code&gt; or &lt;code&gt;mode=clip&lt;/code&gt;, in which cases any integers are permissible.</source>
          <target state="translated">この配列は &lt;code&gt;[0, n-1]&lt;/code&gt; 整数を含む必要があります。ここで &lt;code&gt;n&lt;/code&gt; は選択の数です。ただし、 &lt;code&gt;mode=wrap&lt;/code&gt; または &lt;code&gt;mode=clip&lt;/code&gt; の場合を除きます。この場合、任意の整数が許可されます。</target>
        </trans-unit>
        <trans-unit id="2801e85aeaae18790917a73e502d7026a3a34d08" translate="yes" xml:space="preserve">
          <source>This array must contain integers in &lt;code&gt;[0, n-1]&lt;/code&gt;, where n is the number of choices.</source>
          <target state="translated">この配列には、 &lt;code&gt;[0, n-1]&lt;/code&gt; 整数が含まれている必要があります。ここで、nは選択肢の数です。</target>
        </trans-unit>
        <trans-unit id="19820dc6931f03b4ce34d1e382ce5208e82ba583" translate="yes" xml:space="preserve">
          <source>This attribute can also be an object exposing the &lt;a href=&quot;https://docs.python.org/dev/c-api/objbuffer.html#c.PyObject_AsCharBuffer&quot;&gt;&lt;code&gt;buffer interface&lt;/code&gt;&lt;/a&gt; which will be used to share the data. If this key is not present (or returns &lt;code&gt;None&lt;/code&gt;), then memory sharing will be done through the buffer interface of the object itself. In this case, the offset key can be used to indicate the start of the buffer. A reference to the object exposing the array interface must be stored by the new object if the memory area is to be secured.</source>
          <target state="translated">この属性は、データの共有に使用される&lt;a href=&quot;https://docs.python.org/dev/c-api/objbuffer.html#c.PyObject_AsCharBuffer&quot;&gt; &lt;code&gt;buffer interface&lt;/code&gt; &lt;/a&gt;を公開するオブジェクトにすることもできます。このキーが存在しない（または &lt;code&gt;None&lt;/code&gt; を返す）場合、メモリ共有はオブジェクト自体のバッファーインターフェイスを介して行われます。この場合、オフセットキーを使用して、バッファの開始を示すことができます。メモリ領域を確保する必要がある場合は、配列インターフェイスを公開するオブジェクトへの参照を新しいオブジェクトに格納する必要があります。</target>
        </trans-unit>
        <trans-unit id="99486092092808fe1a7a3c63950908fb38dd3c25" translate="yes" xml:space="preserve">
          <source>This attribute creates an object that makes it easier to use arrays when calling shared libraries with the ctypes module. The returned object has, among others, data, shape, and strides attributes (see Notes below) which themselves return ctypes objects that can be used as arguments to a shared library.</source>
          <target state="translated">この属性は、ctypesモジュールで共有ライブラリを呼び出す際に、配列をより簡単に使用できるようにするオブジェクトを作成します。返されるオブジェクトは、特に、data,shape,strides属性(以下の注意事項を参照)を持っており、これらの属性自体が共有ライブラリの引数として使用できるctypesオブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="94f279541eccc23ec8d58b2be974fecc119fa4c7" translate="yes" xml:space="preserve">
          <source>This basic behavior can be augmented by passing a 2-tuple in as the file argument. The first element of the tuple should specify the relative path (under the package install directory) where the remaining sequence of files should be installed to (it has nothing to do with the file-names in the source distribution). The second element of the tuple is the sequence of files that should be installed. The files in this sequence can be filenames, relative paths, or absolute paths. For absolute paths the file will be installed in the top-level package installation directory (regardless of the first argument). Filenames and relative path names will be installed in the package install directory under the path name given as the first element of the tuple.</source>
          <target state="translated">この基本的な動作は、ファイルの引数に 2 タプルを渡すことで拡張できます。タプルの最初の要素は、残りの一連のファイルがインストールされる相対パス (パッケージのインストールディレクトリの下)を指定します (ソース配布物のファイル名とは関係ありません)。タプルの 2 番目の要素は、インストールされるべきファイルのシーケンスです。このシーケンスに含まれるファイルは、ファイル名、相対パス、絶対パスのいずれかになります。絶対パスの場合、ファイルはトップレベルのパッケージインストールディレクトリにインストールされます (最初の引数に関係なく)。ファイル名と相対パス名は、タプルの最初の要素として与えられたパス名の下のパッケージインストールディレクトリにインストールされます。</target>
        </trans-unit>
        <trans-unit id="38d8b59be8238ec40cd52d11a1691c2db5ac9b19" translate="yes" xml:space="preserve">
          <source>This broadcasting can also be achieved using the function &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">このブロードキャストは、関数&lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt;を使用して実現することもできます。</target>
        </trans-unit>
        <trans-unit id="040d755c45914cdad7e449ca2485bc004cd21eb5" translate="yes" xml:space="preserve">
          <source>This bug causes Python before 3.4 to not reliably show warnings again after they have been ignored once (even within catch_warnings). It means that no &amp;ldquo;ignore&amp;rdquo; filter can be used easily, since following tests might need to see the warning. Additionally it allows easier specificity for testing warnings and can be nested.</source>
          <target state="translated">このバグにより、3.4より前のPythonでは、（catch_warnings内であっても）一度無視された後も、警告が確実に表示されなくなります。これは、次のテストで警告を確認する必要がある可能性があるため、「無視」フィルターを簡単に使用できないことを意味します。さらに、警告をテストするための特定を容易にし、ネストすることができます。</target>
        </trans-unit>
        <trans-unit id="3d1ccaf9367b320b45fde18f5d1b6d26c14c28d1" translate="yes" xml:space="preserve">
          <source>This can be used on multidimensional arrays too:</source>
          <target state="translated">これは多次元配列でも使用できます。</target>
        </trans-unit>
        <trans-unit id="f7b07ef80d0cc13652d9fe61895de6904fd8ef60" translate="yes" xml:space="preserve">
          <source>This class implements the special methods for almost all of Python&amp;rsquo;s builtin operators defined in the &lt;a href=&quot;https://docs.python.org/dev/library/operator.html#module-operator&quot;&gt;&lt;code&gt;operator&lt;/code&gt;&lt;/a&gt; module, including comparisons (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, etc.) and arithmetic (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, etc.), by deferring to the &lt;code&gt;__array_ufunc__&lt;/code&gt; method, which subclasses must implement.</source>
          <target state="translated">このクラスは、 &lt;code&gt;__array_ufunc__&lt;/code&gt; メソッドを遅延させることにより、&lt;a href=&quot;https://docs.python.org/dev/library/operator.html#module-operator&quot;&gt; &lt;code&gt;operator&lt;/code&gt; &lt;/a&gt;モジュールで定義されたほとんどすべてのPythonの組み込み演算子の特別なメソッドを実装します。これには、比較（ &lt;code&gt;==&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; など）や算術（ &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; など）が含まれます。どのサブクラスが実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="cbc453ece1fc4bcfba8a214ebb68dae3ad49689e" translate="yes" xml:space="preserve">
          <source>This class is provided for numarray backward-compatibility. New code (not concerned with numarray compatibility) should use arrays of type &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt; and use the free functions in &lt;code&gt;numpy.char&lt;/code&gt; for fast vectorized string operations instead.</source>
          <target state="translated">このクラスは、numarrayの下位互換性のために提供されています。新しいコード（numarrayの互換性には関係ありません）では、 &lt;code&gt;string_&lt;/code&gt; または &lt;code&gt;unicode_&lt;/code&gt; タイプの配列を使用し、代わりに &lt;code&gt;numpy.char&lt;/code&gt; の無料の関数を使用して高速なベクトル化された文字列操作を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="547d58e17f08661cffe0028727466b3bfecb1f09" translate="yes" xml:space="preserve">
          <source>This class may at some point be turned into a factory function which returns a view into an mmap buffer.</source>
          <target state="translated">このクラスは、いつかはビューをmmapバッファに返すファクトリ関数に変わるかもしれません。</target>
        </trans-unit>
        <trans-unit id="051a76f1d3dcebdcceb5b6a498f248ede74e08da" translate="yes" xml:space="preserve">
          <source>This code has a significant amount of error handling. Note the &lt;code&gt;SWIG_fail&lt;/code&gt; is a macro for &lt;code&gt;goto fail&lt;/code&gt;, referring to the label at line 28. If the user provides the wrong number of arguments, this will be caught at line 10. If construction of the NumPy array fails or produces an array with the wrong number of dimensions, these errors are caught at line 17. And finally, if an error is detected, memory is still managed correctly at line 30.</source>
          <target state="translated">このコードには、大量のエラー処理があります。注意 &lt;code&gt;SWIG_fail&lt;/code&gt; がためのマクロです &lt;code&gt;goto fail&lt;/code&gt; numpyの配列の構築が間違ったの配列を失敗したか、生成された場合、ユーザーが間違った数の引数を提供している場合はライン28でラベルを参照し、これはライン10で捕捉されます次元数の場合、これらのエラーは17行目でキャッチされます。最後に、エラーが検出された場合でも、メモリは30行目で正しく管理されています。</target>
        </trans-unit>
        <trans-unit id="4e0a485b84958d1031e7018c2536aa8e72a66489" translate="yes" xml:space="preserve">
          <source>This condition is broadcast over the input. At locations where the condition is True, the &lt;code&gt;out&lt;/code&gt; array will be set to the ufunc result. Elsewhere, the &lt;code&gt;out&lt;/code&gt; array will retain its original value. Note that if an uninitialized &lt;code&gt;out&lt;/code&gt; array is created via the default &lt;code&gt;out=None&lt;/code&gt;, locations within it where the condition is False will remain uninitialized.</source>
          <target state="translated">この状態は入力を介してブロードキャストされます。条件がTrueである場所では、 &lt;code&gt;out&lt;/code&gt; 配列はufuncの結果に設定されます。それ以外の場合、 &lt;code&gt;out&lt;/code&gt; 配列は元の値を保持します。初期化さ &lt;code&gt;out&lt;/code&gt; ていないout配列がデフォルトの &lt;code&gt;out=None&lt;/code&gt; を介して作成される場合、条件内がFalseである配列内の場所は初期化されないままになることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ee4c6c49dffb551e0984368af8f98c122bd3ccfb" translate="yes" xml:space="preserve">
          <source>This constructor can be compared to &lt;code&gt;empty&lt;/code&gt;: it creates a new record array but does not fill it with data. To create a record array from data, use one of the following methods:</source>
          <target state="translated">このコンストラクタは &lt;code&gt;empty&lt;/code&gt; と比較できます。新しいレコード配列を作成しますが、データを入れません。データからレコード配列を作成するには、次のいずれかの方法を使用します。</target>
        </trans-unit>
        <trans-unit id="33c942d2092f2a81aa60d19a082d10077f5b892d" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='Fortran'&lt;/code&gt;, in which case &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">このコンストラクターは、 &lt;code&gt;None&lt;/code&gt; でない場合、 &lt;code&gt;buffer&lt;/code&gt; （ &lt;code&gt;offset&lt;/code&gt; と&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;）を使用して配列を作成します。場合 &lt;code&gt;buffer&lt;/code&gt; ありません &lt;code&gt;None&lt;/code&gt; 、その後で新しいアレイ構築&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;、両方のない限り、「C順序」に &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; 及び &lt;code&gt;order='Fortran'&lt;/code&gt; でケース、&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;「Fortranの順序」です。</target>
        </trans-unit>
        <trans-unit id="244906121f35fcb6808baef572df1faf5ecac2b9" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='Fortran'&lt;/code&gt;, in which case &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">このコンストラクターは、 &lt;code&gt;None&lt;/code&gt; でない場合、 &lt;code&gt;buffer&lt;/code&gt; （ &lt;code&gt;offset&lt;/code&gt; と&lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;）を使用して配列を作成します。場合 &lt;code&gt;buffer&lt;/code&gt; ありません &lt;code&gt;None&lt;/code&gt; 、その後で新しいアレイ構築&lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;、両方のない限り、「C順序」に &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; 及び &lt;code&gt;order='Fortran'&lt;/code&gt; でケース、&lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;「Fortranの順序」です。</target>
        </trans-unit>
        <trans-unit id="c221f7f1dff9c4b5017181532f28da44b16fcb82" translate="yes" xml:space="preserve">
          <source>This decorator can be used to filter DeprecationWarning&amp;rsquo;s, to avoid printing them during the test suite run, while checking that the test actually raises a DeprecationWarning.</source>
          <target state="translated">このデコレータを使用してDeprecationWarningをフィルタリングし、テストが実際にDeprecationWarningを発生させていることを確認しながら、テストスイートの実行中にそれらを出力しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="50d52a319d15baa1479e649a743cee7e5d09023b" translate="yes" xml:space="preserve">
          <source>This decorator can&amp;rsquo;t use the nose namespace, because it can be called from a non-test module. See also &lt;code&gt;istest&lt;/code&gt; and &lt;code&gt;nottest&lt;/code&gt; in &lt;code&gt;nose.tools&lt;/code&gt;.</source>
          <target state="translated">このデコレータは、テスト以外のモジュールから呼び出すことができるため、nose名前空間を使用できません。参照してください &lt;code&gt;istest&lt;/code&gt; と &lt;code&gt;nottest&lt;/code&gt; で &lt;code&gt;nose.tools&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67fd7e1d7456c74a698475b7f144fadff01137fb" translate="yes" xml:space="preserve">
          <source>This default iterator selects a sub-array of dimension</source>
          <target state="translated">このデフォルトのイテレータは,次元の部分配列を選択します.</target>
        </trans-unit>
        <trans-unit id="cfb9c1da992a1d1aaddfb397e6c91ff1039b17da" translate="yes" xml:space="preserve">
          <source>This default threshold is designed to detect rank deficiency accounting for the numerical errors of the SVD computation. Imagine that there is a column in &lt;code&gt;M&lt;/code&gt; that is an exact (in floating point) linear combination of other columns in &lt;code&gt;M&lt;/code&gt;. Computing the SVD on &lt;code&gt;M&lt;/code&gt; will not produce a singular value exactly equal to 0 in general: any difference of the smallest SVD value from 0 will be caused by numerical imprecision in the calculation of the SVD. Our threshold for small SVD values takes this numerical imprecision into account, and the default threshold will detect such numerical rank deficiency. The threshold may declare a matrix &lt;code&gt;M&lt;/code&gt; rank deficient even if the linear combination of some columns of &lt;code&gt;M&lt;/code&gt; is not exactly equal to another column of &lt;code&gt;M&lt;/code&gt; but only numerically very close to another column of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">このデフォルトのしきい値は、SVD計算の数値エラーを考慮したランク不足を検出するように設計されています。列があることを想像する &lt;code&gt;M&lt;/code&gt; における他の列の（浮動小数点）で正確な線形組み合わせである &lt;code&gt;M&lt;/code&gt; は。 &lt;code&gt;M&lt;/code&gt; で SVDを計算しても、一般に正確に0に等しい特異値は生成されません。最小のSVD値と0との差は、SVDの計算における数値の不正確さが原因です。小さいSVD値のしきい値は、この数値の不正確さを考慮に入れており、デフォルトのしきい値は、このような数値ランクの不足を検出します。マトリックス宣言することができる閾値 &lt;code&gt;M&lt;/code&gt; のランクが不足場合でも、一部の列の線形結合 &lt;code&gt;M&lt;/code&gt; 丁度の別の列に等しくない &lt;code&gt;M&lt;/code&gt; 非常に近くの別の列にのみ数値が、 &lt;code&gt;M&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2007e99c49141c98bee8b2f4b8b703b1ff66930c" translate="yes" xml:space="preserve">
          <source>This does not compute the usual correlation: if op2 is larger than op1, the arguments are swapped, and the conjugate is never taken for complex arrays. See PyArray_Correlate2 for the usual signal processing correlation.</source>
          <target state="translated">これは通常の相関を計算しません:op2 が op1 よりも大きい場合、引数はスワップされ、複素数配列の場合は共役が取られることはありません。通常の信号処理の相関については PyArray_Correlate2 を参照してください。</target>
        </trans-unit>
        <trans-unit id="2ac0e7432126a7d32cb5b22ed347524b29026575" translate="yes" xml:space="preserve">
          <source>This enables the iterator to reason about data dependency, possibly avoiding unnecessary copies.</source>
          <target state="translated">これにより、イテレータはデータの依存性を推論し、不要なコピーを回避することができます。</target>
        </trans-unit>
        <trans-unit id="ff3d50ffaaf1fbc724fd92676a9a6bf2dd386440" translate="yes" xml:space="preserve">
          <source>This example makes use of Python 3 &lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt;&lt;code&gt;concurrent.futures&lt;/code&gt;&lt;/a&gt; to fill an array using multiple threads. Threads are long-lived so that repeated calls do not require any additional overheads from thread creation. The underlying BitGenerator is &lt;code&gt;PCG64&lt;/code&gt; which is fast, has a long period and supports using &lt;code&gt;PCG64.jumped&lt;/code&gt; to return a new generator while advancing the state. The random numbers generated are reproducible in the sense that the same seed will produce the same outputs.</source>
          <target state="translated">この例では、Python 3の&lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt; &lt;code&gt;concurrent.futures&lt;/code&gt; &lt;/a&gt;を使用して、複数のスレッドを使用して配列を埋めています。スレッドは存続期間が長いので、呼び出しを繰り返しても、スレッドの作成による追加のオーバーヘッドは必要ありません。基礎となるBitGeneratorは &lt;code&gt;PCG64&lt;/code&gt; であり、高速で、期間が長く、 &lt;code&gt;PCG64.jumped&lt;/code&gt; を使用して、状態を進めながら新しいジェネレーターを返すことができます。生成された乱数は、同じシードが同じ出力を生成するという意味で再現可能です。</target>
        </trans-unit>
        <trans-unit id="b788d751d6a8b5a6ea3f2e12485a26037e6ed998" translate="yes" xml:space="preserve">
          <source>This example shows how numba can be used to produce Box-Muller normals using a pure Python implementation which is then compiled. The random numbers are provided by &lt;code&gt;ctypes.next_double&lt;/code&gt;.</source>
          <target state="translated">この例では、numbaを使用して、コンパイルされた純粋なPython実装を使用してBox-Muller法線を生成する方法を示します。乱数は &lt;code&gt;ctypes.next_double&lt;/code&gt; によって提供されます。</target>
        </trans-unit>
        <trans-unit id="15659709a5e32bf1f77ae2078941bf91dc0f1586" translate="yes" xml:space="preserve">
          <source>This example uses a temporary file so that doctest doesn&amp;rsquo;t write files to your directory. You would use a &amp;lsquo;normal&amp;rsquo; filename.</source>
          <target state="translated">この例では一時ファイルを使用しているため、doctestはディレクトリにファイルを書き込みません。「通常の」ファイル名を使用します。</target>
        </trans-unit>
        <trans-unit id="c6a6109259025b3790be906b9d5fd08b4a7ddd22" translate="yes" xml:space="preserve">
          <source>This explanation of &lt;code&gt;fmt&lt;/code&gt; is not complete, for an exhaustive specification see &lt;a href=&quot;#r672d4d5b6143-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">この &lt;code&gt;fmt&lt;/code&gt; の説明は完全ではありません。徹底的な仕様については、&lt;a href=&quot;#r672d4d5b6143-1&quot; id=&quot;id1&quot;&gt;[1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c6f060f066c80d886f242a9ad00dc6b69ec16949" translate="yes" xml:space="preserve">
          <source>This feature lets you make local decisions about when and how to split up streams without coordination between processes. You do not have to preallocate space to avoid overlapping or request streams from a common global service. This general &amp;ldquo;tree-hashing&amp;rdquo; scheme is &lt;a href=&quot;https://www.iro.umontreal.ca/~lecuyer/myftp/papers/parallel-rng-imacs.pdf&quot;&gt;not unique to numpy&lt;/a&gt; but not yet widespread. Python has increasingly-flexible mechanisms for parallelization available, and this scheme fits in very well with that kind of use.</source>
          <target state="translated">この機能を使用すると、プロセス間の調整なしで、いつ、どのようにストリームを分割するかをローカルで決定できます。重複を回避したり、共通のグローバルサービスからのストリームを要求したりするために、領域を事前に割り当てる必要はありません。この一般的な「ツリーハッシュ」スキームは&lt;a href=&quot;https://www.iro.umontreal.ca/~lecuyer/myftp/papers/parallel-rng-imacs.pdf&quot;&gt;、numpyに固有のもので&lt;/a&gt;はありませんが、まだ普及していません。Pythonには、利用できる並列化のメカニズムがますます柔軟になっており、このスキームはそのような使用法に非常によく適合します。</target>
        </trans-unit>
        <trans-unit id="482a4249cfca9480f9fad090626bdeb4f2b9945b" translate="yes" xml:space="preserve">
          <source>This file is installed to the package installation directory.</source>
          <target state="translated">このファイルは、パッケージのインストールディレクトリにインストールされます。</target>
        </trans-unit>
        <trans-unit id="53df6470e0b1cc077e937e47a1974181b9abe4c8" translate="yes" xml:space="preserve">
          <source>This flag can only be used with &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; when &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt; is enabled. This is because without buffering, the inner loop is always the size of the innermost iteration dimension, and allowing it to get cut up would require special handling, effectively making it more like the buffered version.</source>
          <target state="translated">このフラグはのみで使用することができます&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;とき&lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; が&lt;/a&gt;有効になっています。これは、バッファリングを行わない場合、内部ループは常に最も内側の反復次元のサイズであり、切り捨てられるようにするには特別な処理が必要になるため、事実上、バッファされたバージョンのようになります。</target>
        </trans-unit>
        <trans-unit id="b15ae805eec5e668ba73f9b0b01c1bc16e63444d" translate="yes" xml:space="preserve">
          <source>This flag has effect only if &lt;code&gt;NPY_ITER_COPY_IF_OVERLAP&lt;/code&gt; is enabled on the iterator.</source>
          <target state="translated">このフラグは、 &lt;code&gt;NPY_ITER_COPY_IF_OVERLAP&lt;/code&gt; がイテレーターで有効になっている場合にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="9da2bfdfbda0e7663b5a969172c32a000741b205" translate="yes" xml:space="preserve">
          <source>This flag is incompatible with &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このフラグは、&lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt;と互換性がありません。</target>
        </trans-unit>
        <trans-unit id="dded0adeb2bd9373f814af71190afe223e5d417b" translate="yes" xml:space="preserve">
          <source>This flag is true if the underlying array is &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;. It is used to simplify calculations when possible.</source>
          <target state="translated">基礎となる配列が&lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; の&lt;/a&gt;場合、このフラグはtrueです。可能な場合は、計算を簡略化するために使用されます。</target>
        </trans-unit>
        <trans-unit id="e07be9168d02cb1629420a221f75d6ebada0e23c" translate="yes" xml:space="preserve">
          <source>This flag only affects writing from the buffer back to the array. This means that if the operand is also &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt;&lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt;&lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt;&lt;/a&gt;, code doing iteration can write to this operand to control which elements will be untouched and which ones will be modified. This is useful when the mask should be a combination of input masks.</source>
          <target state="translated">このフラグは、バッファから配列への書き込みにのみ影響します。これは、オペランドも&lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt; &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt; &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; の&lt;/a&gt;場合、反復を実行するコードがこのオペランドに書き込み、変更されない要素と変更されない要素を制御できることを意味します。これは、マスクを定型入力の組み合わせにする必要がある場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="61e9f59feb262d0f073bfa393f7c68aa5599a46b" translate="yes" xml:space="preserve">
          <source>This form also makes it possible to specify struct dtypes with overlapping fields, functioning like the &amp;lsquo;union&amp;rsquo; type in C. This usage is discouraged, however, and the union mechanism is preferred.</source>
          <target state="translated">この形式では、Cの「union」タイプのように機能する、フィールドが重複するstruct dtypeを指定することもできます。ただし、この使用はお勧めできませんが、unionメカニズムが推奨されます。</target>
        </trans-unit>
        <trans-unit id="55ceb45713d06ac7d3696f87a18d50201d0b6641" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;steals a reference&lt;/strong&gt; to &lt;code&gt;obj&lt;/code&gt; and sets it as the base property of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">この関数は&lt;strong&gt;、&lt;/strong&gt; &lt;code&gt;obj&lt;/code&gt; へ&lt;strong&gt;の参照&lt;/strong&gt;を&lt;strong&gt;盗み、&lt;/strong&gt;それを &lt;code&gt;arr&lt;/code&gt; の基本プロパティとして設定します。</target>
        </trans-unit>
        <trans-unit id="d09c0732b811d51b99b90004b51ceb77de43b711" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;steals a reference&lt;/strong&gt; to &lt;code&gt;op&lt;/code&gt; and makes sure that &lt;code&gt;op&lt;/code&gt; is a base-class ndarray. It special cases array scalars, but otherwise calls &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;op&lt;/code&gt;, NULL, 0, 0, &lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt;&lt;/a&gt;, NULL).</source>
          <target state="translated">この関数は、&lt;strong&gt;参照盗み&lt;/strong&gt;に &lt;code&gt;op&lt;/code&gt; していることを確認します &lt;code&gt;op&lt;/code&gt; が基底クラスのndarrayです。配列スカラーは特別な場合ですが、それ以外の場合は&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;op&lt;/code&gt; 、NULL、0、0、&lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt; &lt;/a&gt;、NULL）を呼び出します。</target>
        </trans-unit>
        <trans-unit id="39a0c64e238756c013e69a01cf344f4e1849a8a1" translate="yes" xml:space="preserve">
          <source>This function accepts but discards arguments &lt;code&gt;bias&lt;/code&gt; and &lt;code&gt;ddof&lt;/code&gt;. This is for backwards compatibility with previous versions of this function. These arguments had no effect on the return values of the function and can be safely ignored in this and previous versions of numpy.</source>
          <target state="translated">この関数は、引数 &lt;code&gt;bias&lt;/code&gt; と &lt;code&gt;ddof&lt;/code&gt; を受け入れますが破棄します。これは、この関数の以前のバージョンとの下位互換性のためです。これらの引数は関数の戻り値に影響を与えなかったため、numpyのこのバージョンと以前のバージョンでは無視しても問題ありません。</target>
        </trans-unit>
        <trans-unit id="f2fa4598ed049a537ca6f0801826008a1fe6bde0" translate="yes" xml:space="preserve">
          <source>This function aims to be a fast reader for simply formatted files. The &lt;a href=&quot;numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; function provides more sophisticated handling of, e.g., lines with missing values.</source>
          <target state="translated">この関数は、単純にフォーマットされたファイルの高速リーダーを目指しています。&lt;a href=&quot;numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;機能は、より洗練されたの取り扱い、例えば、欠損値を持つ行を提供します。</target>
        </trans-unit>
        <trans-unit id="ff21c5d7fbe80ce59f5b300cd13fc6a4fc144e9d" translate="yes" xml:space="preserve">
          <source>This function allows one set of bins to be computed, and reused across multiple histograms:</source>
          <target state="translated">この関数は、1つのビンのセットを計算し、複数のヒストグラムに渡って再利用することができます。</target>
        </trans-unit>
        <trans-unit id="8a2a88415c2050cb4cd9564db4ec54b1d4908d16" translate="yes" xml:space="preserve">
          <source>This function allows the user to register a 1-d loop with an already- created ufunc to be used whenever the ufunc is called with any of its input arguments as the user-defined data-type. This is needed in order to make ufuncs work with built-in data-types. The data-type must have been previously registered with the numpy system. The loop is passed in as &lt;em&gt;function&lt;/em&gt;. This loop can take arbitrary data which should be passed in as &lt;em&gt;data&lt;/em&gt;. The data-types the loop requires are passed in as &lt;em&gt;arg_types&lt;/em&gt; which must be a pointer to memory at least as large as ufunc-&amp;gt;nargs.</source>
          <target state="translated">この関数を使用すると、ユーザーは、既に作成されたufuncを使用して1次元ループを登録し、ユーザー定義のデータ型として入力引数のいずれかを指定してufuncを呼び出すときに使用できます。これは、組み込みデータ型でufuncを機能させるために必要です。 data-typeは、numpyシステムに事前に登録されている必要があります。ループは&lt;em&gt;関数&lt;/em&gt;として渡され&lt;em&gt;ます&lt;/em&gt;。このループは、&lt;em&gt;data&lt;/em&gt;として渡される任意のデータを取ることができ&lt;em&gt;ます&lt;/em&gt;。ループが必要とするデータ型は、少なくともufunc-&amp;gt; nargsと同じ大きさのメモリへのポインタでなければならない&lt;em&gt;arg_types&lt;/em&gt;として渡されます。</target>
        </trans-unit>
        <trans-unit id="f1576babab462c2253d07a719792b0ff878bb525" translate="yes" xml:space="preserve">
          <source>This function allows you to alter the tp_str and tp_repr methods of the array object to any Python function. Thus you can alter what happens for all arrays when str(arr) or repr(arr) is called from Python. The function to be called is passed in as &lt;em&gt;op&lt;/em&gt;. If &lt;em&gt;repr&lt;/em&gt; is non-zero, then this function will be called in response to repr(arr), otherwise the function will be called in response to str(arr). No check on whether or not &lt;em&gt;op&lt;/em&gt; is callable is performed. The callable passed in to &lt;em&gt;op&lt;/em&gt; should expect an array argument and should return a string to be printed.</source>
          <target state="translated">この関数を使用すると、配列オブジェクトのtp_strメソッドとtp_reprメソッドを任意のPython関数に変更できます。したがって、Pythonからstr（arr）またはrepr（arr）が呼び出されたときに、すべての配列で何が起こるかを変更できます。呼び出される関数は&lt;em&gt;op&lt;/em&gt;として渡されます。場合&lt;em&gt;のreprが&lt;/em&gt;非ゼロであり、この関数は、そうでなければ関数はSTR（ARR）に応答して呼び出される、のrepr（ARR）に応答して呼び出されます。&lt;em&gt;op&lt;/em&gt;が呼び出し可能かどうかのチェックは行われません。&lt;em&gt;opに&lt;/em&gt;渡される呼び出し可能オブジェクトは、配列引数を予期し、出力される文字列を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="12c8f95658bf6b7edc09d3adda4d0c4816cea136" translate="yes" xml:space="preserve">
          <source>This function behaves like PyUFunc_RegisterLoopForType above, except that it allows the user to register a 1-d loop using PyArray_Descr objects instead of dtype type num values. This allows a 1-d loop to be registered for structured array data-dtypes and custom data-types instead of scalar data-types.</source>
          <target state="translated">この関数は上記の PyUFunc_RegisterLoopForType と同様の動作をしますが、dtype 型の num 値の代わりに PyArray_Descr オブジェクトを用いて 1-d ループを登録することができます。これにより、スカラーデータ型の代わりに構造化配列データ型やカスタムデータ型に対して1次元ループを登録することができます。</target>
        </trans-unit>
        <trans-unit id="71ac25efd0c9fb7e70f813509afc2d6139c57b07" translate="yes" xml:space="preserve">
          <source>This function changes the fill value of the masked array &lt;code&gt;a&lt;/code&gt; in place. If &lt;code&gt;a&lt;/code&gt; is not a masked array, the function returns silently, without doing anything.</source>
          <target state="translated">この関数は、マスクされた配列 &lt;code&gt;a&lt;/code&gt; の塗りつぶし値を変更します。 &lt;code&gt;a&lt;/code&gt; がマスクされた配列でない場合、関数は何もせずにサイレントに戻ります。</target>
        </trans-unit>
        <trans-unit id="dc2a1bc44c01911d64ceae9284770c887ff15ab1" translate="yes" xml:space="preserve">
          <source>This function checks to see if &lt;em&gt;arr&lt;/em&gt; is a 0-dimensional array and, if so, returns the appropriate array scalar. It should be used whenever 0-dimensional arrays could be returned to Python.</source>
          <target state="translated">この関数は、&lt;em&gt;arr&lt;/em&gt;が0次元配列かどうかを確認し、0次元配列の場合は、適切な配列スカラーを返します。Pythonに0次元配列が返される可能性がある場合は常に使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="6e0d86a376dbbcdcd20b9ab0ced8ac2eae8ffe8a" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;N&lt;/em&gt;-dimensional discrete Fourier Transform over any number of axes in an &lt;em&gt;M&lt;/em&gt;-dimensional array by means of the Fast Fourier Transform (FFT).</source>
          <target state="translated">この関数は、高速フーリエ変換（FFT）を使用して、&lt;em&gt;M&lt;/em&gt;次元配列の任意の数の軸で&lt;em&gt;N&lt;/em&gt;次元の離散フーリエ変換を計算します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f34d917f1e7128a56a07b81dc929875f904b8a8c" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;n&lt;/em&gt;-dimensional discrete Fourier Transform over any axes in an &lt;em&gt;M&lt;/em&gt;-dimensional array by means of the Fast Fourier Transform (FFT). By default, the transform is computed over the last two axes of the input array, i.e., a 2-dimensional FFT.</source>
          <target state="translated">この関数は、高速フーリエ変換（FFT）を使用して、&lt;em&gt;M&lt;/em&gt;次元配列の任意の軸で&lt;em&gt;n&lt;/em&gt;次元の離散フーリエ変換を計算します。デフォルトでは、変換は入力配列の最後の2つの軸、つまり2次元FFTで計算されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8915bccc6bfc2e5b959f002fb985788d011a64f" translate="yes" xml:space="preserve">
          <source>This function computes the N-dimensional discrete Fourier Transform over any number of axes in an M-dimensional real array by means of the Fast Fourier Transform (FFT). By default, all axes are transformed, with the real transform performed over the last axis, while the remaining transforms are complex.</source>
          <target state="translated">この関数は,高速フーリエ変換(FFT)を用いて,M次元実数配列内の任意の数の軸に対するN次元離散フーリエ変換を計算します.デフォルトでは,すべての軸が変換され,最後の軸に対して実数変換が実行され,残りの変換は複素数になります.</target>
        </trans-unit>
        <trans-unit id="b8c7b22438d176337766fd2e49c4b7cfc3e07bab" translate="yes" xml:space="preserve">
          <source>This function computes the correlation as generally defined in signal processing texts:</source>
          <target state="translated">この関数は,信号処理のテキストで一般的に定義されている相関を計算します.</target>
        </trans-unit>
        <trans-unit id="cd6ec7a4da9a308e6c6acab0d22d9735b9865d50" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the 2-dimensional discrete Fourier Transform over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;ifft2(fft2(a)) == a&lt;/code&gt; to within numerical accuracy. By default, the inverse transform is computed over the last two axes of the input array.</source>
          <target state="translated">この関数は、高速フーリエ変換（FFT）を使用して、M次元配列の任意の数の軸上の2次元離散フーリエ変換の逆を計算します。言い換えれば、 &lt;code&gt;ifft2(fft2(a)) == a&lt;/code&gt; は数値精度の範囲内です。デフォルトでは、逆変換は入力配列の最後の2つの軸に対して計算されます。</target>
        </trans-unit>
        <trans-unit id="1a4ebaf525beaf877d17151690d3a34bb9c59baf" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the N-dimensional discrete Fourier Transform for real input over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;irfftn(rfftn(a), a.shape) == a&lt;/code&gt; to within numerical accuracy. (The &lt;code&gt;a.shape&lt;/code&gt; is necessary like &lt;code&gt;len(a)&lt;/code&gt; is for &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt;, and for the same reason.)</source>
          <target state="translated">この関数は、高速フーリエ変換（FFT）を使用して、M次元配列の任意の数の軸に渡る実数入力のN次元離散フーリエ変換の逆を計算します。言い換えると、 &lt;code&gt;irfftn(rfftn(a), a.shape) == a&lt;/code&gt; は、数値の精度内です。（ &lt;code&gt;a.shape&lt;/code&gt; は &lt;code&gt;len(a)&lt;/code&gt; が&lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; の&lt;/a&gt;場合と同じように必要であり、同じ理由で必要です。）</target>
        </trans-unit>
        <trans-unit id="0c7a0cee522d4ce9c957b628834b82e1d28defa5" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the N-dimensional discrete Fourier Transform over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;ifftn(fftn(a)) == a&lt;/code&gt; to within numerical accuracy. For a description of the definitions and conventions used, see &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数は、高速フーリエ変換（FFT）を使用して、M次元配列の任意の数の軸でN次元の離散フーリエ変換の逆数を計算します。言い換えると、 &lt;code&gt;ifftn(fftn(a)) == a&lt;/code&gt; は、数値精度の範囲内です。使用される定義と規則の説明については、&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b2f9d73633ea8b8eb82a0685fcd08ea3505d9a66" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform of real input computed by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;. In other words, &lt;code&gt;irfft(rfft(a), len(a)) == a&lt;/code&gt; to within numerical accuracy. (See Notes below for why &lt;code&gt;len(a)&lt;/code&gt; is necessary here.)</source>
          <target state="translated">この関数は、&lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt;によって計算された実数入力の1次元&lt;em&gt;n&lt;/em&gt;ポイント離散フーリエ変換の逆を計算します。言い換えると、 &lt;code&gt;irfft(rfft(a), len(a)) == a&lt;/code&gt; は、数値精度の範囲内です。（ここで &lt;code&gt;len(a)&lt;/code&gt; が必要な理由については、下記の注を参照してください。）</target>
        </trans-unit>
        <trans-unit id="35acba32b3eea01535885b216d423da5ad809ed9" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier transform computed by &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;. In other words, &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; to within numerical accuracy. For a general description of the algorithm and definitions, see &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数は、&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;によって計算された1次元の&lt;em&gt;n点&lt;/em&gt;離散フーリエ変換の逆を計算します。言い換えると、 &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; は数値精度の範囲内です。アルゴリズムと定義の一般的な説明については、&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ad9d7d69d57ac9facd5b4f82ac6ba6f908913a31" translate="yes" xml:space="preserve">
          <source>This function computes the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform (DFT) of a real-valued array by means of an efficient algorithm called the Fast Fourier Transform (FFT).</source>
          <target state="translated">この関数は、高速フーリエ変換（FFT）と呼ばれる効率的なアルゴリズムを使用して、実数値配列の1次元&lt;em&gt;n点&lt;/em&gt;離散フーリエ変換（DFT）を計算します。</target>
        </trans-unit>
        <trans-unit id="68ec181d19ee1190284573e044b4ba392f94f385" translate="yes" xml:space="preserve">
          <source>This function computes the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform (DFT) with the efficient Fast Fourier Transform (FFT) algorithm [CT].</source>
          <target state="translated">この関数は、効率的な高速フーリエ変換（FFT）アルゴリズム[CT]を使用して、1次元の&lt;em&gt;n点&lt;/em&gt;離散フーリエ変換（DFT）を計算します。</target>
        </trans-unit>
        <trans-unit id="30a498de56241e50f5fd1a10939273e87357615d" translate="yes" xml:space="preserve">
          <source>This function continues to be supported for backward compatibility, but you should prefer &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt;&lt;code&gt;moveaxis&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt;&lt;code&gt;moveaxis&lt;/code&gt;&lt;/a&gt; function was added in NumPy 1.11.</source>
          <target state="translated">この関数は、下位互換性のために引き続きサポートされていますが、&lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt; &lt;code&gt;moveaxis&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。&lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt; &lt;code&gt;moveaxis&lt;/code&gt; の&lt;/a&gt;機能はnumpyの1.11で追加されました。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
