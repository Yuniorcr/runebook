<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="40a3c4882101734d96d5257d2a74ae5e78eaf3de" translate="yes" xml:space="preserve">
          <source>Taint Mode</source>
          <target state="translated">テインモード</target>
        </trans-unit>
        <trans-unit id="f63611c6fa286ffcd2142b28c1284de824194c00" translate="yes" xml:space="preserve">
          <source>Taint an SV. Use &lt;code&gt;SvTAINTED_on&lt;/code&gt; instead.</source>
          <target state="translated">SVを汚染します。代わりに &lt;code&gt;SvTAINTED_on&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="413e513edb03310442a1614d65a7d4ad85d457e0" translate="yes" xml:space="preserve">
          <source>Taint checking is most useful when although you trust yourself not to have written a program to give away the farm, you don't necessarily trust those who end up using it not to try to trick it into doing something bad. This is the kind of security checking that's useful for set-id programs and programs launched on someone else's behalf, like CGI programs.</source>
          <target state="translated">テインチェックは、農場を手放すためのプログラムを書いたのではないと自分自身を信頼しているが、それを使うことになった人がそれを悪用して何か悪いことをしようとしていないとは限らない場合に最も有用である。このようなセキュリティチェックは、セットIDプログラムやCGIプログラムのように他人に代わって起動されたプログラムに有効です。</target>
        </trans-unit>
        <trans-unit id="88ab9771610a9a442e0329746e6647da7d9f316c" translate="yes" xml:space="preserve">
          <source>Taint mode</source>
          <target state="translated">テインモード</target>
        </trans-unit>
        <trans-unit id="504eb6d55f3dd75624d53392fb2ec7ee299aa14f" translate="yes" xml:space="preserve">
          <source>Taint mode and @INC</source>
          <target state="translated">テインモードと@INC</target>
        </trans-unit>
        <trans-unit id="d6624f88ac2856ed8ccebfe23a63eebf43e447bd" translate="yes" xml:space="preserve">
          <source>Tainting is also likely if the pattern is to be matched case-insensitively (via &lt;code&gt;/i&lt;/code&gt;). The exception is if all the code points to be matched this way are above 255 and do not have folds under Unicode rules to below 256. Tainting is not done for these because Perl only uses Unicode rules for such code points, and those rules are the same no matter what the current locale.</source>
          <target state="translated">パターンが大文字と小文字を区別せずに一致する場合（ &lt;code&gt;/i&lt;/code&gt; を介して）も汚染される可能性があります。例外は、この方法で一致するすべてのコードポイントが255を超え、Unicodeルールで256未満に折りたたまれていない場合です。PerlはそのようなコードポイントにUnicodeルールのみを使用し、これらのルールは現在のロケールに関係なく同じです。</target>
        </trans-unit>
        <trans-unit id="b1e437790166193a4c207aa58d0fb3a4d2a31ed7" translate="yes" xml:space="preserve">
          <source>Taints an SV if tainting is enabled, and if some input to the current expression is tainted--usually a variable, but possibly also implicit inputs such as locale settings. &lt;code&gt;SvTAINT&lt;/code&gt; propagates that taintedness to the outputs of an expression in a pessimistic fashion; i.e., without paying attention to precisely which outputs are influenced by which inputs.</source>
          <target state="translated">汚染が有効になっている場合、および現在の式への入力が汚染されている場合、SVを汚染します。通常は変数ですが、ロケール設定などの暗黙的な入力も可能です。 &lt;code&gt;SvTAINT&lt;/code&gt; は、その汚染を式の出力に悲観的に伝播します。つまり、どの出力がどの入力に影響されるかについて正確に注意を払う必要はありません。</target>
        </trans-unit>
        <trans-unit id="750e96a06b9d3c66d6ca7a66a25a581164f0d409" translate="yes" xml:space="preserve">
          <source>Taiwan-based Chinese Encodings</source>
          <target state="translated">台湾を拠点とする中国語エンコード</target>
        </trans-unit>
        <trans-unit id="5a5b403505c94cab4e9f224e4af932dc5aa9d4c7" translate="yes" xml:space="preserve">
          <source>Take a look at &lt;a href=&quot;#Good-Practices&quot;&gt;Good Practices&lt;/a&gt; for some variants you will like to use in modern Perl code.</source>
          <target state="translated">最新のPerlコードで使用するいくつかのバリアントについては、&lt;a href=&quot;#Good-Practices&quot;&gt;グッドプラクティス&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="0e2b74024aba36db1a23fa804fd1c560d6088d9a" translate="yes" xml:space="preserve">
          <source>Take a sprintf-style format pattern and argument list. These are used to generate a string message. If the message does not end with a newline, then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;mess_sv&lt;/a&gt;.</source>
          <target state="translated">sprintfスタイルのフォーマットパターンと引数リストを取ります。これらは、文字列メッセージを生成するために使用されます。メッセージが改行で終わっていない場合は、&lt;a href=&quot;#mess_sv&quot;&gt;mess_svで&lt;/a&gt;説明されているように、コード内の現在の場所を示すいくつかのメッセージで拡張されます。</target>
        </trans-unit>
        <trans-unit id="fb04817116fcc4f36afb8949c5edb0a2147a3489" translate="yes" xml:space="preserve">
          <source>Take care when changing a released module.</source>
          <target state="translated">リリースされたモジュールを変更する際には注意が必要です。</target>
        </trans-unit>
        <trans-unit id="fcbbed68b647be19cced53ca66bc41d5fb7b63bd" translate="yes" xml:space="preserve">
          <source>Take care when using this function simply as a truth test (such as in &lt;code&gt;&lt;a href=&quot;../functions/if&quot;&gt;if&lt;/a&gt;(blessed $ref)...&lt;/code&gt; ) because the package name &lt;code&gt;&quot;0&quot;&lt;/code&gt; is defined yet false.</source>
          <target state="translated">パッケージ名 &lt;code&gt;&quot;0&quot;&lt;/code&gt; はまだfalseと定義されているため、この関数を真偽テスト（ &lt;code&gt;&lt;a href=&quot;../functions/if&quot;&gt;if&lt;/a&gt;(blessed $ref)...&lt;/code&gt; ）として使用する場合は注意してください。</target>
        </trans-unit>
        <trans-unit id="c4c196051206e9d1dadde68b1305cdecd7c48024" translate="yes" xml:space="preserve">
          <source>Take the example case of trying to split a string that is comma-separated into its different fields. You can't use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split(/,/)&lt;/a&gt;&lt;/code&gt; because you shouldn't split if the comma is inside quotes. For example, take a data line like this:</source>
          <target state="translated">カンマで区切られた文字列を異なるフィールドに分割しようとする場合を例にとってみましょう。コンマが引用符の内側にある場合は分割してはならないため &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split(/,/)&lt;/a&gt;&lt;/code&gt; は使用できません。たとえば、次のようなデータ行があるとします。</target>
        </trans-unit>
        <trans-unit id="4471e2b4acce8ca9f0f3bc156ed9ea2897b12f89" translate="yes" xml:space="preserve">
          <source>Take the opportunity to reconsider and redesign the interfaces.</source>
          <target state="translated">この機会にインターフェイスを再考し、再設計してみてはいかがでしょうか。</target>
        </trans-unit>
        <trans-unit id="891afd1ff7caaa23526c0cd4250f4fb5063fe719" translate="yes" xml:space="preserve">
          <source>Taken together, these features go a long way towards making Perl's regular expressions more readable. Here's an example:</source>
          <target state="translated">これらの機能を合わせると、Perl の正規表現をより読みやすくすることができます。ここに例を示します。</target>
        </trans-unit>
        <trans-unit id="d4622f933170417209394d51b607728c20fb64f4" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;sockaddr_in6&lt;/code&gt; structure. Returns a list of four elements: the port number, an opaque string representing the IPv6 address, the scope ID, and the flow label. (You can use inet_ntop() to convert the address to the usual string format). Will croak if the structure does not represent an &lt;code&gt;AF_INET6&lt;/code&gt; address.</source>
          <target state="translated">&lt;code&gt;sockaddr_in6&lt;/code&gt; 構造体を取ります。4つの要素のリストを返します。ポート番号、IPv6アドレスを表す不透明な文字列、スコープID、フローラベルです。（inet_ntop（）を使用して、アドレスを通常の文字列形式に変換できます）。構造が &lt;code&gt;AF_INET6&lt;/code&gt; アドレスを表さない場合は、クロークします。</target>
        </trans-unit>
        <trans-unit id="8ffd8f37fe17f4475f9ac3335803a5668dd9a5a9" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;sockaddr_in&lt;/code&gt; structure (as returned by pack_sockaddr_in(), getpeername() or recv()). Returns a list of two elements: the port and an opaque string representing the IP address (you can use inet_ntoa() to convert the address to the four-dotted numeric format). Will croak if the structure does not represent an &lt;code&gt;AF_INET&lt;/code&gt; address.</source>
          <target state="translated">&lt;code&gt;sockaddr_in&lt;/code&gt; 構造体を取ります（pack_sockaddr_in（）、getpeername（）またはrecv（）によって返される）。ポートとIPアドレスを表す不透明な文字列の2つの要素のリストを返します（inet_ntoa（）を使用して、アドレスを4ドットの数値形式に変換できます）。構造が &lt;code&gt;AF_INET&lt;/code&gt; アドレスを表していない場合は、クロークします。</target>
        </trans-unit>
        <trans-unit id="0d55a321d267dd95843d2a82446b8e074d9b4482" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;sockaddr_un&lt;/code&gt; structure (as returned by pack_sockaddr_un(), getpeername() or recv()). Returns a list of one element: the pathname. Will croak if the structure does not represent an &lt;code&gt;AF_UNIX&lt;/code&gt; address.</source>
          <target state="translated">&lt;code&gt;sockaddr_un&lt;/code&gt; 構造体を取ります（pack_sockaddr_un（）、getpeername（）またはrecv（）によって返される）。1つの要素（パス名）のリストを返します。構造が &lt;code&gt;AF_UNIX&lt;/code&gt; アドレスを表していない場合は、クロークします。</target>
        </trans-unit>
        <trans-unit id="b39b8aaa0796e13f2d536ba4ee5000dfd3368b8e" translate="yes" xml:space="preserve">
          <source>Takes a LIST of values and converts it into a string using the rules given by the TEMPLATE. The resulting string is the concatenation of the converted values. Typically, each converted value looks like its machine-level representation. For example, on 32-bit machines an integer may be represented by a sequence of 4 bytes, which will in Perl be presented as a string that's 4 characters long.</source>
          <target state="translated">値のLISTを取り、TEMPLATEで与えられたルールを使って文字列に変換します。結果として得られる文字列は、変換された値を連結したものです。通常、変換された各値は、そのマシンレベルの表現のように見えます。例えば、32ビットマシンでは、整数は4バイトのシーケンスで表現され、Perlでは4文字の長さの文字列として表示されます。</target>
        </trans-unit>
        <trans-unit id="5bea2fb93e96bf3299efd7e7cc45533fa8e0d5df" translate="yes" xml:space="preserve">
          <source>Takes a destination path and an optional base path and returns a relative path from the base path to the destination path:</source>
          <target state="translated">宛先パスとオプションのベースパスを受け取り、ベースパスから宛先パスへの相対パスを返します。</target>
        </trans-unit>
        <trans-unit id="95774c404168139c6e80f1611020974553158f89" translate="yes" xml:space="preserve">
          <source>Takes a destination path and an optional base path returns a relative path from the base path to the destination path:</source>
          <target state="translated">宛先パスを受け取り、オプションのベースパスは、ベースパスから宛先パスへの相対パスを返します。</target>
        </trans-unit>
        <trans-unit id="d94b0d11d4ec10ac5d773f5e69a50730359dca25" translate="yes" xml:space="preserve">
          <source>Takes a filename, a scalar full of data and optionally a reference to a hash with specific options.</source>
          <target state="translated">ファイル名、データを含むスカラ値、そしてオプションで特定のオプションを持つハッシュへの参照を受け取ります。</target>
        </trans-unit>
        <trans-unit id="ef9cdc80b0d99b082834a1fbb8d5a11a97402e97" translate="yes" xml:space="preserve">
          <source>Takes a list of capabilities as an argument and will croak if one is not found.</source>
          <target state="translated">能力のリストを引数に取り、それが見つからない場合は泣き叫ぶ。</target>
        </trans-unit>
        <trans-unit id="2eadd3f3ba856c4409ed2499d0a3d0b488f0dfce" translate="yes" xml:space="preserve">
          <source>Takes a list of filenames and adds them to the in-memory archive.</source>
          <target state="translated">ファイル名のリストを取得し、インメモリアーカイブに追加します。</target>
        </trans-unit>
        <trans-unit id="f1b41457fa3731d32047968d9b9c24bbf39e5764" translate="yes" xml:space="preserve">
          <source>Takes a module name as an argument, returns the first perl version by release date where that module was removed from core. Returns undef if the given module was never in core or remains in core.</source>
          <target state="translated">モジュール名を引数にとり、そのモジュールがコアから削除されたリリース日の最初のperlバージョンを返します。与えられたモジュールがコアになかったり、コアに残っている場合は undef を返します。</target>
        </trans-unit>
        <trans-unit id="f46e15336d9744fdb143311ac69c4190fa941309" translate="yes" xml:space="preserve">
          <source>Takes a module name as an argument, returns the first perl version where that module was removed from core. Returns undef if the given module was never in core or remains in core.</source>
          <target state="translated">モジュール名を引数にとり、そのモジュールがコアから削除された最初のperlバージョンを返します。与えられたモジュールがコアになかったり、コアに残っている場合は undef を返します。</target>
        </trans-unit>
        <trans-unit id="b0cf83e512f827739a6bf491886eab3446e0a621" translate="yes" xml:space="preserve">
          <source>Takes a number, the value of the array base $[. Cannot be non-zero on Perl 5.15.3 or later.</source>
          <target state="translated">数値を取り、配列の基底 $[.Perl 5.15.3 以降では、0 以外の値を指定することはできません。</target>
        </trans-unit>
        <trans-unit id="5735d53ded3f64fc817f32e6801f9c3332c8c742" translate="yes" xml:space="preserve">
          <source>Takes a packed binary address structure such as returned by unpack_sockaddr_in() (or a v-string representing the four octets of the IPv4 address in network order) and translates it into a string of the form &lt;code&gt;d.d.d.d&lt;/code&gt; where the &lt;code&gt;d&lt;/code&gt; s are numbers less than 256 (the normal human-readable four dotted number notation for Internet addresses).</source>
          <target state="translated">unpack_sockaddr_in（）（またはネットワーク順でIPv4アドレスの4つのオクテットを表すv文字列）によって返されるようなパックされたバイナリアドレス構造を受け取り、それを &lt;code&gt;d.d.d.d&lt;/code&gt; 形式の文字列に変換します。ここで &lt;code&gt;d&lt;/code&gt; は256未満の数値です（インターネットアドレスの通常の人間が読める4つのドット付き番号表記）。</target>
        </trans-unit>
        <trans-unit id="1a2abe4e916de97dcbd3a2d8761e95258307eb47" translate="yes" xml:space="preserve">
          <source>Takes a packed socket address (as returned by pack_sockaddr_in(), pack_sockaddr_un() or the perl builtin functions getsockname() and getpeername()). Returns the address family tag. This will be one of the &lt;code&gt;AF_*&lt;/code&gt; constants, such as &lt;code&gt;AF_INET&lt;/code&gt; for a &lt;code&gt;sockaddr_in&lt;/code&gt; addresses or &lt;code&gt;AF_UNIX&lt;/code&gt; for a &lt;code&gt;sockaddr_un&lt;/code&gt; . It can be used to figure out what unpack to use for a sockaddr of unknown type.</source>
          <target state="translated">パックされたソケットアドレスを取ります（pack_sockaddr_in（）、pack_sockaddr_un（）またはperl組み込み関数getsockname（）およびgetpeername（）によって返される）。アドレスファミリタグを返します。これは、のいずれかになります &lt;code&gt;AF_*&lt;/code&gt; などの定数、 &lt;code&gt;AF_INET&lt;/code&gt; のため &lt;code&gt;sockaddr_in&lt;/code&gt; アドレスまたは &lt;code&gt;AF_UNIX&lt;/code&gt; ため &lt;code&gt;sockaddr_un&lt;/code&gt; 。不明なタイプのsockaddrに使用するアンパックを判別するために使用できます。</target>
        </trans-unit>
        <trans-unit id="a13e8e801bfdc18ca93880299add6c6b51640d38" translate="yes" xml:space="preserve">
          <source>Takes a path to a file or dir and returns an empty string if we don't want to include this file in the library. Otherwise it returns the the $path unchanged.</source>
          <target state="translated">ファイルやディレクトリへのパスを取り、ライブラリにこのファイルを含めたくない場合は空の文字列を返します。それ以外の場合は、変更されていない $path を返します。</target>
        </trans-unit>
        <trans-unit id="5857a3f9b8ca80529d602d68d365fa9061a89d78" translate="yes" xml:space="preserve">
          <source>Takes a perl version as an argument. Returns that perl version if it exists or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">引数としてperlバージョンを使用します。そのperlバージョンが存在する場合はそれを返し、そうでない場合は &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="40ef5af0a7a23fbe908b8c6d6bfe7afebb158b73" translate="yes" xml:space="preserve">
          <source>Takes a quoted regular expression produced by &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, or a string representing a regular expression.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; によって生成された引用符付きの正規表現、または正規表現を表す文字列を受け取ります。</target>
        </trans-unit>
        <trans-unit id="9f021fc102096073a09c0f85c8e63b62bb7905ee" translate="yes" xml:space="preserve">
          <source>Takes a reference to any Perl value, and turns the referred-to value into an object in the appropriate B::OP-derived or B::SV-derived class. Apart from functions such as &lt;code&gt;main_root&lt;/code&gt; , this is the primary way to get an initial &quot;handle&quot; on an internal perl data structure which can then be followed with the other access methods.</source>
          <target state="translated">任意のPerl値への参照を取得し、参照先の値を適切なB :: OP派生またはB :: SV派生クラスのオブジェクトに変換します。 &lt;code&gt;main_root&lt;/code&gt; などの関数は別として、これは内部perlデータ構造の初期「ハンドル」を取得するための主要な方法であり、その後に他のアクセスメソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="e41f495e23e8b7129fbf9bc3a9bb6ededd8628d3" translate="yes" xml:space="preserve">
          <source>Takes a regex as an argument, returns a list of modules that match the regex given. If only a regex is provided applies to all modules in all perl versions. Optionally you may provide a list of perl versions to limit the regex search.</source>
          <target state="translated">正規表現を引数に取り、与えられた正規表現にマッチするモジュールのリストを返します。正規表現のみが与えられた場合は、すべての perl バージョンのすべてのモジュールに適用されます。オプションで、正規表現の検索を制限するためにPerlのバージョンのリストを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="4409b17c674e2781e58d19f638d2dce9b604b410" translate="yes" xml:space="preserve">
          <source>Takes a sprintf-style format pattern and conventional (non-SV) arguments and returns the formatted string.</source>
          <target state="translated">sprintf スタイルのフォーマットパターンと従来の (非 SV)引数を受け取り、フォーマットされた文字列を返します。</target>
        </trans-unit>
        <trans-unit id="33c7557687a090fd43bd56b07499b14fc80993e2" translate="yes" xml:space="preserve">
          <source>Takes a string giving the name of a host, or a textual representation of an IP address and translates that to an packed binary address structure suitable to pass to pack_sockaddr_in(). If passed a hostname that cannot be resolved, returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. For multi-homed hosts (hosts with more than one address), the first address found is returned.</source>
          <target state="translated">ホストの名前を示す文字列、またはIPアドレスのテキスト表現を受け取り、pack_sockaddr_in（）に渡すのに適したパックされたバイナリアドレス構造に変換します。解決できないホスト名を渡すと、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。マルチホームホスト（複数のアドレスを持つホスト）の場合、最初に見つかったアドレスが返されます。</target>
        </trans-unit>
        <trans-unit id="1f86839b95b2c7ce0cd8df0fd7189ee9fa362403" translate="yes" xml:space="preserve">
          <source>Takes a string, possibly containing a whitespace-separated list of values. The values &quot;all&quot; and &quot;none&quot; are special, again. It's also permissible to pass an array reference here.</source>
          <target state="translated">文字列を取り、空白で区切られた値のリストを含む可能性があります。値 &quot;all&quot; と &quot;none&quot; は特殊です。ここで配列の参照を渡すことも可能です。</target>
        </trans-unit>
        <trans-unit id="4925dcea23e5ae74b5fce407317c9fa3709b6b25" translate="yes" xml:space="preserve">
          <source>Takes a string, possibly containing a whitespace-separated list of values. The values &quot;all&quot; and &quot;none&quot; are special. It's also permissible to pass an array reference here.</source>
          <target state="translated">文字列を取り、空白で区切られた値のリストを含む可能性があります。値 &quot;all&quot; と &quot;none&quot; は特別です。ここで配列の参照を渡すことも可能です。</target>
        </trans-unit>
        <trans-unit id="90662514b3c1c8b5cad150f77c448383f9911cee" translate="yes" xml:space="preserve">
          <source>Takes a string, possibly containing several values separated by whitespace. The special values &quot;all&quot; and &quot;none&quot; mean what you'd expect.</source>
          <target state="translated">いくつかの値を空白で区切って含む可能性のある文字列を取ります。特別な値 &quot;all&quot; と &quot;none&quot; は、あなたが期待するものを意味します。</target>
        </trans-unit>
        <trans-unit id="8b8cbc4c6f861e88e0cc4c3970f3d7711c8f40ee" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ip_mreq&lt;/code&gt; structure. Returns a list of two elements; the IPv4 multicast address and interface address.</source>
          <target state="translated">&lt;code&gt;ip_mreq&lt;/code&gt; 構造体を取ります。2つの要素のリストを返します。IPv4マルチキャストアドレスとインターフェイスアドレス。</target>
        </trans-unit>
        <trans-unit id="04696d2255aec363ebf123f1adcef127402d7fca" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ip_mreq_source&lt;/code&gt; structure. Returns a list of three elements; the IPv4 multicast address, source address and interface address.</source>
          <target state="translated">&lt;code&gt;ip_mreq_source&lt;/code&gt; 構造体を取ります。3つの要素のリストを返します。IPv4マルチキャストアドレス、送信元アドレス、およびインターフェイスアドレス。</target>
        </trans-unit>
        <trans-unit id="8895fb55870fc5cb5b67d2b6b1ab10511fd087e6" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ipv6_mreq&lt;/code&gt; structure. Returns a list of two elements; the IPv6 address and an interface number.</source>
          <target state="translated">&lt;code&gt;ipv6_mreq&lt;/code&gt; 構造をとります。2つの要素のリストを返します。IPv6アドレスとインターフェース番号。</target>
        </trans-unit>
        <trans-unit id="ad12a7e2dccc21686af63739f893c4d2a53e4c04" translate="yes" xml:space="preserve">
          <source>Takes an IPv4 multicast address and optionally an interface address (or &lt;code&gt;INADDR_ANY&lt;/code&gt; ). Returns the &lt;code&gt;ip_mreq&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IP_ADD_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="translated">IPv4マルチキャストアドレスを &lt;code&gt;INADDR_ANY&lt;/code&gt; 、オプションでインターフェースアドレス（またはINADDR_ANY）を受け取ります。これらの引数がパックされた &lt;code&gt;ip_mreq&lt;/code&gt; 構造体を返します &lt;code&gt;IP_ADD_MEMBERSHIP&lt;/code&gt; および &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; sockopts での使用に適しています。</target>
        </trans-unit>
        <trans-unit id="e80cd3ce1fd8acb10289fb4bd58c0849f55a8d71" translate="yes" xml:space="preserve">
          <source>Takes an IPv4 multicast address, source address, and optionally an interface address (or &lt;code&gt;INADDR_ANY&lt;/code&gt; ). Returns the &lt;code&gt;ip_mreq_source&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IP_ADD_SOURCE_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IP_DROP_SOURCE_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="translated">IPv4マルチキャストアドレス、送信元アドレス、およびオプションでインターフェースアドレス（または &lt;code&gt;INADDR_ANY&lt;/code&gt; ）を取ります。これらの引数がパックされた &lt;code&gt;ip_mreq_source&lt;/code&gt; 構造体を返します &lt;code&gt;IP_ADD_SOURCE_MEMBERSHIP&lt;/code&gt; および &lt;code&gt;IP_DROP_SOURCE_MEMBERSHIP&lt;/code&gt; sockopts での使用に適しています。</target>
        </trans-unit>
        <trans-unit id="414f4fb4a3a1f32b47a120675c30046be162adca" translate="yes" xml:space="preserve">
          <source>Takes an IPv6 multicast address and an interface number. Returns the &lt;code&gt;ipv6_mreq&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IPV6_ADD_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IPV6_DROP_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="translated">IPv6マルチキャストアドレスとインターフェイス番号を取得します。これらの引数がパックされた &lt;code&gt;ipv6_mreq&lt;/code&gt; 構造体を返します &lt;code&gt;IPV6_ADD_MEMBERSHIP&lt;/code&gt; および &lt;code&gt;IPV6_DROP_MEMBERSHIP&lt;/code&gt; sockopts での使用に適しています。</target>
        </trans-unit>
        <trans-unit id="84da4affe0802d1076fb7e8fa5b5ab6e38634ce8" translate="yes" xml:space="preserve">
          <source>Takes an address family (such as &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;AF_INET6&lt;/code&gt; ) and a string containing a textual representation of an address in that family and translates that to an packed binary address structure.</source>
          <target state="translated">アドレスファミリ（ &lt;code&gt;AF_INET&lt;/code&gt; やAF_INET6など）と、そのファミリのアドレスのテキスト表現を含む文字列を &lt;code&gt;AF_INET6&lt;/code&gt; 、パックされたバイナリアドレス構造に変換します。</target>
        </trans-unit>
        <trans-unit id="185fc4d2aaf4353f2b2708aa34a24508e0a971cd" translate="yes" xml:space="preserve">
          <source>Takes an address family and a packed binary address structure and translates it into a human-readable textual representation of the address; typically in &lt;code&gt;d.d.d.d&lt;/code&gt; form for &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;hhhh:hhhh::hhhh&lt;/code&gt; form for &lt;code&gt;AF_INET6&lt;/code&gt; .</source>
          <target state="translated">アドレスファミリとパックされたバイナリアドレス構造を取得し、人間が読める形式のアドレス表記に変換します。通常、 &lt;code&gt;AF_INET&lt;/code&gt; の場合は &lt;code&gt;d.d.d.d&lt;/code&gt; 形式、AF_INET6の場合は &lt;code&gt;hhhh:hhhh::hhhh&lt;/code&gt; 形式 &lt;code&gt;AF_INET6&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e77ed8250b0ab9eed8ffd2c4c006ad06b6129f6" translate="yes" xml:space="preserve">
          <source>Takes an array of items and turns them into a well-formatted list of arguments. In most cases this is simply something like:</source>
          <target state="translated">項目の配列を取り、整形された引数のリストに変換します。ほとんどの場合、これは単に次のようなものです。</target>
        </trans-unit>
        <trans-unit id="21d2a6e85e05ac293f43bf0aadd4c7b6d2f0e70c" translate="yes" xml:space="preserve">
          <source>Takes as argument a path and returns true if it is an absolute path.</source>
          <target state="translated">引数としてパスを受け取り、それが絶対パスであれば真を返します。</target>
        </trans-unit>
        <trans-unit id="6dc3e333ed2be58598d7c496ec3d73ebab444c2b" translate="yes" xml:space="preserve">
          <source>Takes as argument a path and returns true, if it is an absolute path. If the path has a leading &quot;:&quot;, it's a relative path. Otherwise, it's an absolute path, unless the path doesn't contain any colons, i.e. it's a name like &quot;a&quot;. In this particular case, the path is considered to be relative (i.e. it is considered to be a filename). Use &quot;:&quot; in the appropriate place in the path if you want to distinguish unambiguously. As a special case, the filename '' is always considered to be absolute. Note that with version 1.2 of File::Spec::Mac, this does no longer consult the local filesystem.</source>
          <target state="translated">引数としてパスを受け取り、絶対パスであれば真を返します。パスの先頭に &quot;:&quot; がある場合は、相対パスです。そうでない場合は絶対パスで、コロンが含まれていない場合、つまり &quot;a &quot;のような名前の場合を除きます。この特定のケースでは、パスは相対パスとみなされます(すなわち、ファイル名とみなされます)。曖昧さなく区別したい場合は、パスの適切な場所に「:」を使用してください。特殊なケースとして、ファイル名 '' は常に絶対的なものとみなされます。File::Spec::Macのバージョン1.2では、ローカルファイルシステムを参照しなくなったことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f927c21bb3e3c4ff729f953eef64006ef1f031a9" translate="yes" xml:space="preserve">
          <source>Takes as arguments a directory name and a regular expression. Returns all entries in the directory that match the regular expression.</source>
          <target state="translated">ディレクトリ名と正規表現を引数に取ります。正規表現にマッチするディレクトリ内のすべてのエントリを返します。</target>
        </trans-unit>
        <trans-unit id="6047190e6cf9ba865c7d15a28d5823f107249805" translate="yes" xml:space="preserve">
          <source>Takes as its argument a path, and returns true if it is an absolute path.</source>
          <target state="translated">引数にパスを取り、絶対パスの場合は真を返します。</target>
        </trans-unit>
        <trans-unit id="29d3a8d482e59f44bd119209a124f4322f931d36" translate="yes" xml:space="preserve">
          <source>Takes no argument, returns the environment variable PATH as an array.</source>
          <target state="translated">引数を取らず、環境変数PATHを配列として返します。</target>
        </trans-unit>
        <trans-unit id="fabbbd7a986855e1324a147a7f7a2a0ae979a9a1" translate="yes" xml:space="preserve">
          <source>Takes no argument. Returns the environment variable &lt;code&gt;PATH&lt;/code&gt; (or the local platform's equivalent) as a list.</source>
          <target state="translated">引数は取りません。環境変数 &lt;code&gt;PATH&lt;/code&gt; （またはローカルプラットフォームで同等のもの）をリストとして返します。</target>
        </trans-unit>
        <trans-unit id="904758c12da1c3cf57f2a62e3976ec89f757603e" translate="yes" xml:space="preserve">
          <source>Takes one argument ( 'stdin' | 'stdout' | 'stderr' ) and returns true if the IoIFP of the object is equal to the handle whose name was passed as argument; i.e., $io-&amp;gt;IsSTD('stderr') is true if IoIFP($io) == PerlIO_stderr().</source>
          <target state="translated">1つの引数（ 'stdin' | 'stdout' | 'stderr'）を取り、オブジェクトのIoIFPが引数として渡された名前のハンドルと等しい場合にtrueを返します。つまり、IoIFP（$ io）== PerlIO_stderr（）の場合、$ io-&amp;gt; IsSTD（ 'stderr'）はtrueです。</target>
        </trans-unit>
        <trans-unit id="2250c086cb14652296208baa0752736a068d5cdd" translate="yes" xml:space="preserve">
          <source>Takes one argument, a file name, and returns the file name, if the argument is likely to be a perl script. On MM_Unix this is true for any ordinary, readable file.</source>
          <target state="translated">引数の一つであるファイル名を取り、引数がperlスクリプトである可能性が高い場合には、そのファイル名を返します。MM_Unixでは、これは普通の、読めるファイルであれば何でも真です。</target>
        </trans-unit>
        <trans-unit id="b67ed86e7a795bece24f2642cf574b99635c4b90" translate="yes" xml:space="preserve">
          <source>Takes one argument, a pathname. Returns the &lt;code&gt;sockaddr_un&lt;/code&gt; structure with that path packed in with &lt;code&gt;AF_UNIX&lt;/code&gt; filled in. For &lt;code&gt;PF_UNIX&lt;/code&gt; sockets, this structure is normally what you need for the arguments in bind(), connect(), and send().</source>
          <target state="translated">1つの引数、パス名を取ります。 &lt;code&gt;AF_UNIX&lt;/code&gt; で埋められたパスがパックされた &lt;code&gt;sockaddr_un&lt;/code&gt; 構造体を返します &lt;code&gt;PF_UNIX&lt;/code&gt; ソケットの場合、この構造体は通常、bind（）、connect（）、およびsend（）の引数に必要なものです。</target>
        </trans-unit>
        <trans-unit id="5460ec5112334feb4ac9398f4b8e6e656f42cd55" translate="yes" xml:space="preserve">
          <source>Takes one argument: &lt;code&gt;$type&lt;/code&gt; . Returns the class for this $type, or &lt;code&gt;croak&lt;/code&gt; s with an error.</source>
          <target state="translated">1つの引数を取ります： &lt;code&gt;$type&lt;/code&gt; 。この$ typeのクラス、またはエラーのある &lt;code&gt;croak&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="16af72bfdf1441df18765f4029d283a1f7f95693" translate="yes" xml:space="preserve">
          <source>Takes the name of a package, which may be a nested package, in the form 'Foo/Bar.pm' and replaces the slash with &lt;code&gt;::&lt;/code&gt; or something else safe for a man page file name. Returns the replacement.</source>
          <target state="translated">'Foo / Bar.pm'の形式で、ネストされたパッケージである可能性のあるパッケージの名前を受け取り、スラッシュを &lt;code&gt;::&lt;/code&gt; またはマニュアルページのファイル名に対して安全な何かに置き換えます。交換品を返します。</target>
        </trans-unit>
        <trans-unit id="ff0d6765017f7f35ad28bb62529040cd32d236cb" translate="yes" xml:space="preserve">
          <source>Takes the necessary steps (cache invalidations, mostly) when the @ISA of the given package has changed. Invoked by the &lt;code&gt;setisa&lt;/code&gt; magic, should not need to invoke directly.</source>
          <target state="translated">指定されたパッケージの@ISAが変更されたときに、必要な手順（主にキャッシュの無効化）を実行します。 &lt;code&gt;setisa&lt;/code&gt; マジックによって呼び出されます。直接呼び出す必要はありません。</target>
        </trans-unit>
        <trans-unit id="98237f7a990bc1f6af918e56a3b7b9f24407d459" translate="yes" xml:space="preserve">
          <source>Takes two arguments, a port number and an opaque string (as returned by inet_aton(), or a v-string). Returns the &lt;code&gt;sockaddr_in&lt;/code&gt; structure with those arguments packed in and &lt;code&gt;AF_INET&lt;/code&gt; filled in. For Internet domain sockets, this structure is normally what you need for the arguments in bind(), connect(), and send().</source>
          <target state="translated">2つの引数、ポート番号と不透明な文字列（inet_aton（）またはv-stringによって返される）を取ります。引数がパックされ、 &lt;code&gt;AF_INET&lt;/code&gt; が入力された &lt;code&gt;sockaddr_in&lt;/code&gt; 構造体を返します。インターネットドメインソケットの場合、通常、この構造体はbind（）、connect（）、およびsend（）の引数に必要なものです。</target>
        </trans-unit>
        <trans-unit id="b14fed1e8f7026c1b53ef7c0d55d1e273446b0ea" translate="yes" xml:space="preserve">
          <source>Takes two arguments: &lt;code&gt;$type&lt;/code&gt; , &lt;code&gt;$class&lt;/code&gt;</source>
          <target state="translated">2つの引数を取ります： &lt;code&gt;$type&lt;/code&gt; 、 &lt;code&gt;$class&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a9f99285830e8621999fc816f54c6c6183fd552" translate="yes" xml:space="preserve">
          <source>Takes two to four arguments, a port number, an opaque string (as returned by inet_pton()), optionally a scope ID number, and optionally a flow label number. Returns the &lt;code&gt;sockaddr_in6&lt;/code&gt; structure with those arguments packed in and &lt;code&gt;AF_INET6&lt;/code&gt; filled in. IPv6 equivalent of pack_sockaddr_in().</source>
          <target state="translated">2〜4つの引数、ポート番号、不透明な文字列（inet_pton（）によって返される）、オプ​​ションでスコープID番号、オプションでフローラベル番号を受け取ります。戻り値は &lt;code&gt;sockaddr_in6&lt;/code&gt; これらの引数を持つ構造が中に詰め、 &lt;code&gt;AF_INET6&lt;/code&gt; は）（pack_sockaddr_inの同等。IPv6の記入しました。</target>
        </trans-unit>
        <trans-unit id="6768416e6b2dea0b5b355ce619b2d42c6c2f27cf" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. On Mac OS, $volume, $directory and $file are concatenated. A ':' is inserted if need be. You may pass an empty string for each portion. If all portions are empty, the empty string is returned. If $volume is empty, the result will be a relative path, beginning with a ':'. If $volume and $directory are empty, a leading &quot;:&quot; (if any) is removed form $file and the remainder is returned. If $file is empty, the resulting path will have a trailing ':'.</source>
          <target state="translated">ボリューム、ディレクトリ、ファイルの部分を取り、パス全体を返します。Mac OS では、$volume、$directory、$file が連結されます。必要に応じて ':' が挿入されます。各部分には空の文字列を渡すことができます。すべての部分が空の場合は、空の文字列が返されます。volume が空の場合、結果は ':' で始まる相対パスとなります。ボリュームと $ディレクトリが空の場合は、先頭の &quot;:&quot; (もしあれば)が $file から取り除かれ、残りが返されます。file が空の場合は、結果のパスの末尾に ':' が付きます。</target>
        </trans-unit>
        <trans-unit id="03fb347623243a59c8c7215b498a631b05381519" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. Under Unix, $volume is ignored, and directory and file are concatenated. A '/' is inserted if needed (though if the directory portion doesn't start with '/' it is not added). On other OSs, $volume is significant.</source>
          <target state="translated">ボリューム、ディレクトリ、ファイルの部分を取り、パス全体を返します。Unix では、$volume は無視され、ディレクトリとファイルは連結されます。必要に応じて '/' が挿入されます (ただし、ディレクトリ部分が '/' で始まらない場合は追加されません)。他のOSでは、$volumeは重要です。</target>
        </trans-unit>
        <trans-unit id="9945bfbc052c2b04dca187c3550c5f1feee8878d" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. Under Unix, $volume is ignored, and this is just like catfile(). On other OSs, the $volume become significant.</source>
          <target state="translated">ボリューム、ディレクトリ、ファイルの部分を取り、パス全体を返します。Unix では $volume は無視され、これは catfile()と同じです。他のOSでは、$volumeが重要になります。</target>
        </trans-unit>
        <trans-unit id="972a64a368ed52f92018a4453bba5f6c8e73cecd" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. Under Unix, &lt;code&gt;$volume&lt;/code&gt; is ignored, and directory and file are concatenated. A '/' is inserted if need be. On other OSes, &lt;code&gt;$volume&lt;/code&gt; is significant.</source>
          <target state="translated">ボリューム、ディレクトリ、ファイルの部分を取得し、パス全体を返します。Unixでは、 &lt;code&gt;$volume&lt;/code&gt; は無視され、ディレクトリとファイルが連結されます。必要に応じて「/」を挿入します。他のOSでは、 &lt;code&gt;$volume&lt;/code&gt; は重要です。</target>
        </trans-unit>
        <trans-unit id="510dd54f6700e32b2e33a7ae6bf0b69436048e78" translate="yes" xml:space="preserve">
          <source>Taking a pattern, usually a &lt;b&gt;regular expression&lt;/b&gt;, and trying the pattern various ways on a string to see whether there&amp;rsquo;s any way to make it fit. Often used to pick interesting tidbits out of a file.</source>
          <target state="translated">パターン（通常は&lt;b&gt;正規表現&lt;/b&gt;）を取得し、文字列に対してさまざまな方法でパターンを試し、それを適合させる方法があるかどうかを確認します。多くの場合、ファイルから興味深い情報を選択するために使用されます。</target>
        </trans-unit>
        <trans-unit id="71bab857be3a2f057d5a14d3b22be3dc59b9b4df" translate="yes" xml:space="preserve">
          <source>Taking a reference to an enumerated list is not the same as using square brackets--instead it's the same as creating a list of references!</source>
          <target state="translated">列挙リストへの参照を取ることは、角括弧を使うことと同じではありません --むしろ、参照のリストを作ることと同じです!</target>
        </trans-unit>
        <trans-unit id="15f9cd429dc93becd860c5d004ae9bccaf0f7bef" translate="yes" xml:space="preserve">
          <source>Taking references to the elements of shared arrays and hashes does not autovivify the elements, and neither does slicing a shared array/hash over non-existent indices/keys autovivify the elements.</source>
          <target state="translated">共有配列やハッシュの要素を参照しても要素は自動的に進化しませんし、存在しないインデックスやキーの上で共有配列やハッシュをスライスしても要素は自動的に進化しません。</target>
        </trans-unit>
        <trans-unit id="4c38f4d8d122fb1493ff34d8747e9c4346d4b600" translate="yes" xml:space="preserve">
          <source>Tanenbaum, Andrew S. Distributed Operating Systems. Prentice Hall, 1995, ISBN 0-13-219908-4 (great textbook).</source>
          <target state="translated">Tanenbaum,Andrew S.分散オペレーティングシステム.Prentice Hall,1995,ISBN 0-13-219908-4 (素晴らしい教科書)。</target>
        </trans-unit>
        <trans-unit id="2c7e55c8c22c8578371b576097055d97d0b00faf" translate="yes" xml:space="preserve">
          <source>Tar</source>
          <target state="translated">Tar</target>
        </trans-unit>
        <trans-unit id="6fa1266b6a5ee03e688676077ed07cbe3831ca7d" translate="yes" xml:space="preserve">
          <source>Tar command verbosity level (none or v or vv)?</source>
          <target state="translated">タールコマンドの動詞レベル(なしかvかvvか)?</target>
        </trans-unit>
        <trans-unit id="ad911c00bd7a291ef3efa483132270f4863e5d78" translate="yes" xml:space="preserve">
          <source>Tar magic string -- not useful for most users</source>
          <target state="translated">タール魔法の文字列 --ほとんどのユーザーには役に立たない</target>
        </trans-unit>
        <trans-unit id="6c049aa004ef5f9f848604b292466698be913578" translate="yes" xml:space="preserve">
          <source>Tar version string -- not useful for most users</source>
          <target state="translated">Tar のバージョン文字列 --ほとんどのユーザには有用ではありません。</target>
        </trans-unit>
        <trans-unit id="61ad50a9b9189cc3cf1874568e35e7901ff4c982" translate="yes" xml:space="preserve">
          <source>Target</source>
          <target state="translated">Target</target>
        </trans-unit>
        <trans-unit id="1826e633e69fd1415d51f9f2a918eb7307883a23" translate="yes" xml:space="preserve">
          <source>Target &lt;code&gt;dist&lt;/code&gt; prepares distribution file set. Target &lt;code&gt;zipdist&lt;/code&gt; performs same as &lt;code&gt;dist&lt;/code&gt; but additionally compresses distribution files into zip archive.</source>
          <target state="translated">ターゲット &lt;code&gt;dist&lt;/code&gt; は配布ファイルセットを準備します。ターゲットの &lt;code&gt;zipdist&lt;/code&gt; は &lt;code&gt;dist&lt;/code&gt; と同じように機能しますが、さらに配布ファイルをzipアーカイブに圧縮します。</target>
        </trans-unit>
        <trans-unit id="d35260a00f655f27edcc35a7eb16da44a4f671a6" translate="yes" xml:space="preserve">
          <source>Targets</source>
          <target state="translated">Targets</target>
        </trans-unit>
        <trans-unit id="cb47f8fe09a055e30fa78d0ffd45295628f69b2c" translate="yes" xml:space="preserve">
          <source>Task-Oriented</source>
          <target state="translated">Task-Oriented</target>
        </trans-unit>
        <trans-unit id="184d6c1f032beb495ac0920ba867a330761f1d3a" translate="yes" xml:space="preserve">
          <source>Tautologous boolean operators are still going to be optimized away. Don't be tempted to write</source>
          <target state="translated">同語論理演算子はまだ最適化が離れていきそうです。誘惑に駆られて</target>
        </trans-unit>
        <trans-unit id="3954704c666cb5b3d49966b92f96bca0955f9f5c" translate="yes" xml:space="preserve">
          <source>Technically speaking casting between function pointers and data pointers is unportable and undefined, but practically speaking it seems to work, but you should use the FPTR2DPTR() and DPTR2FPTR() macros. Sometimes you can also play games with unions.</source>
          <target state="translated">技術的に言えば、関数ポインタとデータポインタの間のキャストは移植性がなく未定義ですが、実際にはうまくいくようですが、FPTR2DPTR()とDPTR2FPTR()マクロを使った方がいいでしょう。ユニオンを使ってゲームをすることもあります。</target>
        </trans-unit>
        <trans-unit id="789a9f1903bc34d24a4cbcecb6e7df34821ef6e1" translate="yes" xml:space="preserve">
          <source>Technically speaking, any extra semantics attached to a variable such as &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$0&lt;/code&gt; , &lt;code&gt;%ENV&lt;/code&gt; , or &lt;code&gt;%SIG&lt;/code&gt; , or to any tied variable. Magical things happen when you diddle those variables.</source>
          <target state="translated">技術的には、 &lt;code&gt;$!&lt;/code&gt; などの変数に付加された追加のセマンティクス。、 &lt;code&gt;$0&lt;/code&gt; 、 &lt;code&gt;%ENV&lt;/code&gt; 、または &lt;code&gt;%SIG&lt;/code&gt; 、または任意のタイ変数。これらの変数を操作すると、魔法のようなことが起こります。</target>
        </trans-unit>
        <trans-unit id="b3fc1fc6f28fa057e70de617f17fd53df2eeea80" translate="yes" xml:space="preserve">
          <source>Tell the grammar which TAP syntax version to support. The lowest supported version is 12. Although 'TAP version' isn't valid version 12 syntax it is accepted so that higher version numbers may be parsed.</source>
          <target state="translated">サポートするTAP構文のバージョンを文法に伝えます。最も低いバージョンは12です。TAP version'は有効なバージョン12の構文ではありませんが、より高いバージョン番号を解析するために受け入れられます。</target>
        </trans-unit>
        <trans-unit id="bf7b0d797da557d31ab2a71f5864f39fe5a06aac" translate="yes" xml:space="preserve">
          <source>Tell the parser to ignore the exit status from the test when determining whether the test passed. Normally tests with non-zero exit status are considered to have failed even if all individual tests passed. In cases where it is not possible to control the exit value of the test script use this option to ignore it.</source>
          <target state="translated">パーサに、テストが合格したかどうかを判断する際に、テストの終了ステータスを無視するように指示します。通常、終了ステータスが 0 以外のテストは、個々のテストがすべて合格していても失敗したとみなされます。テストスクリプトの終了値を制御できない場合は、このオプションを使用して無視します。</target>
        </trans-unit>
        <trans-unit id="bf2d615f3aae044f0b7af594b2368699ca553959" translate="yes" xml:space="preserve">
          <source>Tell the parser where should the output go. In this case it will be placed in the $html variable:</source>
          <target state="translated">パーサーに出力をどこに置くかを指定します。この場合、$html変数に格納されます。</target>
        </trans-unit>
        <trans-unit id="29533c09561de1801d031a71f8c7c8a01e5f03c1" translate="yes" xml:space="preserve">
          <source>Tell the remote server that I am not a user client, but probably another news server.</source>
          <target state="translated">リモートサーバーに、私はユーザークライアントではなく、おそらく別のニュースサーバーであることを伝えてください。</target>
        </trans-unit>
        <trans-unit id="08608b0e566d4fb7e89ec44318b59ab07dde69d0" translate="yes" xml:space="preserve">
          <source>Tell the remote server the mail domain which you are in using the EHLO command (or HELO if EHLO fails). Since this method is invoked automatically when the Net::SMTP object is constructed the user should normally not have to call it manually.</source>
          <target state="translated">EHLO コマンド (EHLO が失敗した場合は HELO)を使用して、自分が今いるメール ドメインをリモート サーバーに伝えます。このメソッドは Net::SMTP オブジェクトが構築されたときに自動的に呼び出されるので、通常は手動で呼び出す必要はありません。</target>
        </trans-unit>
        <trans-unit id="1f6b5a09a58a8567f17dcd614ece669f9d14b0d0" translate="yes" xml:space="preserve">
          <source>Tell the server that we want to append some data to the end of a file called &lt;code&gt;FILE&lt;/code&gt; . If this file does not exist then create it.</source>
          <target state="translated">&lt;code&gt;FILE&lt;/code&gt; というファイルの最後にデータを追加することをサーバーに伝えます。このファイルが存在しない場合は作成してください。</target>
        </trans-unit>
        <trans-unit id="995cb880453aaa8bd60b7aae252f5462234be732" translate="yes" xml:space="preserve">
          <source>Tell the server that you are a reader and not another server.</source>
          <target state="translated">自分がリーダーであり、他のサーバーではないことをサーバーに伝えます。</target>
        </trans-unit>
        <trans-unit id="055d9e27b5b7d5b8f2d504557166da8931089570" translate="yes" xml:space="preserve">
          <source>Tell the server that you wish to store a file. &lt;code&gt;FILE&lt;/code&gt; is the name of the new file that should be created.</source>
          <target state="translated">ファイルを保存することをサーバーに伝えます。 &lt;code&gt;FILE&lt;/code&gt; は、作成する必要がある新しいファイルの名前です。</target>
        </trans-unit>
        <trans-unit id="9366b9a09ea150c339542dc64664840e4fc85da8" translate="yes" xml:space="preserve">
          <source>Tell the server to go into passive mode (&lt;code&gt;pasv&lt;/code&gt; for IPv4, &lt;code&gt;epsv&lt;/code&gt; for IPv6). Returns the text that represents the port on which the server is listening, this text is in a suitable form to send to another ftp server using the &lt;code&gt;port&lt;/code&gt; or &lt;code&gt;eprt&lt;/code&gt; method.</source>
          <target state="translated">サーバーにパッシブモードにするように伝えます（IPv4の場合は &lt;code&gt;pasv&lt;/code&gt; 、IPv6の場合は &lt;code&gt;epsv&lt;/code&gt; ）。サーバーが待機しているポートを表すテキストを返します。このテキストは、 &lt;code&gt;port&lt;/code&gt; または &lt;code&gt;eprt&lt;/code&gt; メソッドを使用して別のFTPサーバーに送信するのに適した形式です。</target>
        </trans-unit>
        <trans-unit id="15d551aaf2266eb9d86adea81d4570cc191bb729" translate="yes" xml:space="preserve">
          <source>Telling &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email::Sender::Simple&lt;/a&gt; to use your transport is straightforward.</source>
          <target state="translated">占い&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;メール::送信者::シンプルを&lt;/a&gt;あなたのトランスポートを使用するようにするのは簡単です。</target>
        </trans-unit>
        <trans-unit id="dd2c3160deeb317e223ba57be41f996c28b1ec03" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; the given string in scalar context and return an SV* result.</source>
          <target state="translated">指定された文字列をスカラーコンテキストで &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; し、SV *結果を返すようにPerlに指示します。</target>
        </trans-unit>
        <trans-unit id="d9e092fa3e1e256147594ca30bda8c3f4672e0ee" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; the string in the SV. It supports the same flags as &lt;code&gt;call_sv&lt;/code&gt; , with the obvious exception of G_EVAL. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">PerlにSVの文字列を &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; するように指示します。 &lt;code&gt;call_sv&lt;/code&gt; の明らかな例外を除いて、call_svと同じフラグをサポートします。&lt;a href=&quot;perlcall&quot;&gt;perlcallを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a71daae5e0e57d93d6228536edc45b69ba84a875" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; the file named by the string argument. It is analogous to the Perl code &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require '$file'&quot;&lt;/code&gt; . It's even implemented that way; consider using load_module instead.</source>
          <target state="translated">文字列引数で指定されたファイルを &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; するようにPerlに指示します。これはPerlコード &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require '$file'&quot;&lt;/code&gt; 似ています。それもそのように実装されています。代わりにload_moduleの使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="e1bf556e6d9dede28e015a565e8d9027e099de7d" translate="yes" xml:space="preserve">
          <source>Tells Test::Builder what package you exported your functions to.</source>
          <target state="translated">関数をエクスポートしたパッケージを Test::Builder に伝えます。</target>
        </trans-unit>
        <trans-unit id="21d8020c0986f9af967d2434489f1dff7dddc2b6" translate="yes" xml:space="preserve">
          <source>Tells a Perl interpreter to parse a Perl script. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">PerlインタプリタにPerlスクリプトを解析するように指示します。&lt;a href=&quot;perlembed&quot;&gt;perlembedを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="90de9fbbe619d0267fd7167e5dc1db64eb361247" translate="yes" xml:space="preserve">
          <source>Tells a Perl interpreter to run. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">Perlインタープリターに実行を指示します。&lt;a href=&quot;perlembed&quot;&gt;perlembedを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2794a27373eb4499d2dd0fc224b3c502ced9a12f" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a double and disables all other OK bits.</source>
          <target state="translated">SV にダブルであることを伝え、他のすべての OK ビットを無効にします。</target>
        </trans-unit>
        <trans-unit id="cde3486f8b34dcc836358775446f605a6e5f5219" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a double.</source>
          <target state="translated">SVにダブルであることを伝える。</target>
        </trans-unit>
        <trans-unit id="d29a05e0eb81580dedcd3ec32c30e53e3f465ef8" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string and disables all other OK bits, and leaves the UTF-8 status as it was.</source>
          <target state="translated">SV に文字列であることを伝え、他のすべての OK ビットを無効化し、UTF-8 の状態をそのままにする。</target>
        </trans-unit>
        <trans-unit id="826cf5cb563ce76cd986386302e8a1a458503e48" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string and disables all other OK bits. Will also turn off the UTF-8 status.</source>
          <target state="translated">SV に文字列であることを伝え、他のすべての OK ビットを無効にします。また、UTF-8 の状態をオフにします。</target>
        </trans-unit>
        <trans-unit id="3a0e0af0ea20a9f25152c6d76518063affb1c7ae" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string.</source>
          <target state="translated">SV に文字列であることを伝えます。</target>
        </trans-unit>
        <trans-unit id="9359d018a66deddebc4670552c35dfa39c5db6a1" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an RV.</source>
          <target state="translated">SVにRVであることを伝える。</target>
        </trans-unit>
        <trans-unit id="a2ea638c533f4384730e93210ef4a899bb9d756b" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an integer and disables all other OK bits.</source>
          <target state="translated">SV に整数であることを伝え、他のすべての OK ビットを無効にします。</target>
        </trans-unit>
        <trans-unit id="6d0dafe3ace125974c920e3d5dd9ad0e37849cd8" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an integer.</source>
          <target state="translated">SV に整数であることを伝えます。</target>
        </trans-unit>
        <trans-unit id="b0b98f3f753198e2b29067e4cd07e7535b94339d" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an unsigned integer and disables all other OK bits.</source>
          <target state="translated">SV に符号なし整数であることを伝え、他のすべての OK ビットを無効にします。</target>
        </trans-unit>
        <trans-unit id="98e3c3ca5f6df324b9d092553470d578100c40eb" translate="yes" xml:space="preserve">
          <source>Tells an SV to use &lt;code&gt;ptr&lt;/code&gt; to find its string value. Implemented by calling &lt;code&gt;sv_usepvn_flags&lt;/code&gt; with &lt;code&gt;flags&lt;/code&gt; of 0, hence does not handle 'set' magic. See &lt;code&gt;sv_usepvn_flags&lt;/code&gt; .</source>
          <target state="translated">文字列値を見つけるために &lt;code&gt;ptr&lt;/code&gt; を使用するようにSVに指示します。 &lt;code&gt;flags&lt;/code&gt; を0にして &lt;code&gt;sv_usepvn_flags&lt;/code&gt; を呼び出すことで実装されているため、「設定」マジックは処理されません。 &lt;code&gt;sv_usepvn_flags&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="898e0cc9cfb0dad2df7d68beacd47f39b7ca2406" translate="yes" xml:space="preserve">
          <source>Tells an SV to use &lt;code&gt;ptr&lt;/code&gt; to find its string value. Normally the string is stored inside the SV, but sv_usepvn allows the SV to use an outside string. The &lt;code&gt;ptr&lt;/code&gt; should point to memory that was allocated by &lt;a href=&quot;perlclib#Memory-Management-and-String-Handling&quot;&gt;Newx&lt;/a&gt;. It must be the start of a Newx-ed block of memory, and not a pointer to the middle of it (beware of &lt;a href=&quot;perlguts#Offsets&quot;&gt;OOK&lt;/a&gt; and copy-on-write), and not be from a non-Newx memory allocator like &lt;code&gt;malloc&lt;/code&gt; . The string length, &lt;code&gt;len&lt;/code&gt; , must be supplied. By default this function will &lt;code&gt;Renew&lt;/code&gt; (i.e. realloc, move) the memory pointed to by &lt;code&gt;ptr&lt;/code&gt; , so that pointer should not be freed or used by the programmer after giving it to sv_usepvn, and neither should any pointers from &quot;behind&quot; that pointer (e.g. ptr + 1) be used.</source>
          <target state="translated">文字列値を見つけるために &lt;code&gt;ptr&lt;/code&gt; を使用するようにSVに指示します。通常、文字列はSV内に格納されますが、sv_usepvnを使用すると、SVは外部文字列を使用できます。 &lt;code&gt;ptr&lt;/code&gt; がによって割り当てられたメモリを指している必要があり&lt;a href=&quot;perlclib#Memory-Management-and-String-Handling&quot;&gt;Newx&lt;/a&gt;。これはメモリのNewx-edブロックの先頭である必要があり、その中央へのポインタではなく（&lt;a href=&quot;perlguts#Offsets&quot;&gt;OOK&lt;/a&gt;とコピーオンライトに注意）、 &lt;code&gt;malloc&lt;/code&gt; などの非Newxメモリアロケータからではない必要があります。文字列の長さ &lt;code&gt;len&lt;/code&gt; を指定する必要があります。デフォルトでは、この関数は &lt;code&gt;ptr&lt;/code&gt; が指すメモリを &lt;code&gt;Renew&lt;/code&gt; （つまり、再割り当て、移動）します 、プログラマがsv_usepvnに渡した後にポインタを解放または使用しないでください。また、そのポインタの「背後」からのポインタ（ptr + 1など）も使用しないでください。</target>
        </trans-unit>
        <trans-unit id="ea1983bb2952566f54d05f0ce7c7dc4c67383643" translate="yes" xml:space="preserve">
          <source>Tells the debugger that we'll want to pause execution when we reach either the named function (but see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;Internal Functions in perlguts&lt;/a&gt;!) or the given line in the named source file.</source>
          <target state="translated">名前付き関数（&lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;perlgutsの内部関数を&lt;/a&gt;参照！）または名前付きソースファイルの特定の行に到達したときに実行を一時停止することをデバッガーに指示します。</target>
        </trans-unit>
        <trans-unit id="d14b1bd32ddb84a178c8e757f0eede95fcc4f56d" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on characters. The definition of character varies depending on if the target string is a UTF-8 string.</source>
          <target state="translated">対象の文字列を文字で分割するようにsplit演算子に指示します。文字の定義は、対象文字列がUTF-8文字列であるかどうかによって異なります。</target>
        </trans-unit>
        <trans-unit id="184bc1d12ee8da813cda422d2ca1e00df540f884" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on newlines (&lt;code&gt;\n&lt;/code&gt; ) without invoking the regex engine.</source>
          <target state="translated">正規表現エンジンを呼び出さずに改行（ &lt;code&gt;\n&lt;/code&gt; ）でターゲット文字列を分割するように分割演算子に指示します。</target>
        </trans-unit>
        <trans-unit id="b48808542e716e16e3adb670d9889b9528897056" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on whitespace without invoking the regex engine. The definition of whitespace varies depending on if the target string is a UTF-8 string and on if RXf_PMf_LOCALE is set.</source>
          <target state="translated">正規表現エンジンを呼び出さずに、対象の文字列をホワイトスペースで分割するように split 演算子に指示します。ホワイトスペースの定義は、対象文字列がUTF-8文字列であるかどうかと、RXf_PMf_LOCALEが設定されているかどうかによって異なります。</target>
        </trans-unit>
        <trans-unit id="e150384486349cedc8729ff69a3903d6982a4a60" translate="yes" xml:space="preserve">
          <source>Tells whether the object is renewed (and how many times). Some modules emit &lt;code&gt;Use of uninitialized value in null operation&lt;/code&gt; warning unless the value is numeric so return 0 for false.</source>
          <target state="translated">オブジェクトが更新されるかどうか（およびその回数）を通知します。一部のモジュールは、値が数値でない限り、 &lt;code&gt;Use of uninitialized value in null operation&lt;/code&gt; 警告するため、falseの場合は0を返します。</target>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="716ec42869a03408fcb77c9873e5ac4f7f2b0aad" translate="yes" xml:space="preserve">
          <source>Template Grouping</source>
          <target state="translated">テンプレートのグループ化</target>
        </trans-unit>
        <trans-unit id="c9f888d973643e39eea58ba0d4385df9a5d27ccf" translate="yes" xml:space="preserve">
          <source>Template code &lt;code&gt;P&lt;/code&gt; promises to pack a &quot;pointer to a fixed length string&quot;. Isn't this what we want? Let's try:</source>
          <target state="translated">テンプレートコード &lt;code&gt;P&lt;/code&gt; は、「固定長文字列へのポインタ」をパックすることを約束します。これは私たちが欲しいものではありませんか？やってみよう：</target>
        </trans-unit>
        <trans-unit id="a108586754857c54e59b71ddb85b8b2a3279733a" translate="yes" xml:space="preserve">
          <source>Template is the same as that required by mkstemp().</source>
          <target state="translated">テンプレートは mkstemp()で要求されるものと同じです。</target>
        </trans-unit>
        <trans-unit id="58aad47f3a12a51d4d52aa8432c69a9c8ebbb3e7" translate="yes" xml:space="preserve">
          <source>Temporarily disable a member of the XOP, by clearing the appropriate flag.</source>
          <target state="translated">適切なフラグをクリアすることで、XOP のメンバーを一時的に無効にします。</target>
        </trans-unit>
        <trans-unit id="d80af7efaaaefafc73c5845cc5b267960e4626cc" translate="yes" xml:space="preserve">
          <source>Temporarily disable an entry in this BHK structure, by clearing the appropriate flag.</source>
          <target state="translated">適切なフラグをクリアすることで、この BHK 構造体のエントリを一時的に無効にする。</target>
        </trans-unit>
        <trans-unit id="3e3f1700e4dfa66cdfab75739db179821b620308" translate="yes" xml:space="preserve">
          <source>Temporarily fixing locale problems</source>
          <target state="translated">ロケールの問題を一時的に修正</target>
        </trans-unit>
        <trans-unit id="48915beb5208adc13703e622845e9d9286a425c6" translate="yes" xml:space="preserve">
          <source>Temporarily override assorted &lt;code&gt;CPAN.pm&lt;/code&gt; configuration variables.</source>
          <target state="translated">各種 &lt;code&gt;CPAN.pm&lt;/code&gt; 構成変数を一時的にオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="6563ecf47ef5662e753d4670106fb233c800e886" translate="yes" xml:space="preserve">
          <source>Temporary Values via local()</source>
          <target state="translated">local()による一時的な値</target>
        </trans-unit>
        <trans-unit id="ab6577ed3ab16dc6a0a24e8a29b8f2320a3f1bea" translate="yes" xml:space="preserve">
          <source>Temporary files and NFS</source>
          <target state="translated">一時ファイルとNFS</target>
        </trans-unit>
        <trans-unit id="972e2ab11e7ed25c1af63f02f49c51ed09f64187" translate="yes" xml:space="preserve">
          <source>Tend to fail, not succeed.</source>
          <target state="translated">失敗しがちで、成功しない。</target>
        </trans-unit>
        <trans-unit id="038c9aeb7bb05d375a32b9ab2979691faa497330" translate="yes" xml:space="preserve">
          <source>Term used by language lawyers for a storage location you can assign a new &lt;b&gt;value&lt;/b&gt; to, such as a &lt;b&gt;variable&lt;/b&gt; or an element of an &lt;b&gt;array&lt;/b&gt;. The &amp;ldquo;l&amp;rdquo; is short for &amp;ldquo;left&amp;rdquo;, as in the left side of an assignment, a typical place for lvalues. An &lt;b&gt;lvaluable&lt;/b&gt; function or expression is one to which a value may be assigned, as in &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;($x) = 10&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;変数&lt;/b&gt;や&lt;b&gt;配列の&lt;/b&gt;要素など、新しい&lt;b&gt;値&lt;/b&gt;を割り当てることができる保管場所として言語弁護士が使用する用語。lvalueの典型的な場所である代入の左側にあるように、「l」は「左」の省略形です。&lt;b&gt;lvaluable&lt;/b&gt;機能または発現値はのように割り当てることができるれたものである &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;($x) = 10&lt;/code&gt; （$ X）= 10。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4d0028d995c201a4db08a4f29da91c7c14dbfb31" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor</source>
          <target state="translated">Term::ANSIColor</target>
        </trans-unit>
        <trans-unit id="a16dc007b248f41d8a8b48934fc42c79241aa183" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor - Color screen output using ANSI escape sequences</source>
          <target state="translated">Term::ANSIColor-ANSI エスケープシーケンスを使用したカラー画面出力</target>
        </trans-unit>
        <trans-unit id="db406ea9117455f0b666b6ba8f4edfbd34a6728b" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor is used to get colors and therefore must be installed to use this module.</source>
          <target state="translated">Term::ANSIColor は色を取得するために使用されるため、このモジュールを使用するにはインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="f7bdc8f03c4b5d2f5d03a99d6b589da67ba2844c" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor was first included with Perl in Perl 5.6.0.</source>
          <target state="translated">Term::ANSIColorはPerl 5.6.0で初めてPerlに搭載されました。</target>
        </trans-unit>
        <trans-unit id="3973a6639b848462a9aba2fb3883fdeeeee93564" translate="yes" xml:space="preserve">
          <source>Term::Cap</source>
          <target state="translated">Term::Cap</target>
        </trans-unit>
        <trans-unit id="82cd629b4593ce6a72b220343056170a7eb3d545" translate="yes" xml:space="preserve">
          <source>Term::Cap - Perl termcap interface</source>
          <target state="translated">Term::Cap-Perl の termcap インターフェース</target>
        </trans-unit>
        <trans-unit id="3d3bfe455e655790515f3b006edeb99748236633" translate="yes" xml:space="preserve">
          <source>Term::Complete</source>
          <target state="translated">Term::Complete</target>
        </trans-unit>
        <trans-unit id="6d23da7c53fbf0f4faebaefa6851bd7ad00eee31" translate="yes" xml:space="preserve">
          <source>Term::Complete - Perl word completion module</source>
          <target state="translated">Term::Complete-Perl の単語補完モジュール</target>
        </trans-unit>
        <trans-unit id="23ebd3bc9f5af49b1131c82bd5eefd1ac9f6bc11" translate="yes" xml:space="preserve">
          <source>Term::ReadLine</source>
          <target state="translated">Term::ReadLine</target>
        </trans-unit>
        <trans-unit id="bfadfd7a83f6920cfb9038f1942ac1ea2e3b25c1" translate="yes" xml:space="preserve">
          <source>Term::ReadLine - Perl interface to various &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; packages. If no real package is found, substitutes stubs instead of basic functions.</source>
          <target state="translated">Term :: ReadLine-さまざまな &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; パッケージへのPerlインターフェイス。実際のパッケージが見つからない場合は、基本機能の代わりにスタブを置き換えます。</target>
        </trans-unit>
        <trans-unit id="eb8379c22e18e11951de951761db8a9d7c5f2195" translate="yes" xml:space="preserve">
          <source>Terminal emulators that support color divide into two types: ones that support only eight colors, ones that support sixteen, and ones that support 256. This module provides the ANSI escape codes all of them. These colors are referred to as ANSI colors 0 through 7 (normal), 8 through 15 (16-color), and 16 through 255 (256-color).</source>
          <target state="translated">色をサポートしているターミナルエミュレータは、8色のみをサポートしているもの、16色をサポートしているもの、256色をサポートしているものの2種類に分かれます。このモジュールは、それらすべてのANSIエスケープコードを提供します。これらの色をANSI色0~7(通常)、8~15(16色)、16~255(256色)と呼びます。</target>
        </trans-unit>
        <trans-unit id="9b13399f2e2e5cbdb3d2ac7675630b976b3e5443" translate="yes" xml:space="preserve">
          <source>Terminate use of a parser. Typically used and/or overridden in subclasses. The parser isn't destroyed as a result of this.</source>
          <target state="translated">パーサの使用を終了します。通常、サブクラスで使用されたり、オーバーライドされたりします。この結果、パーサは破棄されません。</target>
        </trans-unit>
        <trans-unit id="6b2081166b6ec9fa584db14b8bc64a4e53b287d9" translate="yes" xml:space="preserve">
          <source>Terminates the compressed data stream and flushes any pending compressed data to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">圧縮データストリームを終了し、保留中の圧縮データを &lt;code&gt;$output&lt;/code&gt; フラッシュします。</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="2c65f89cb90bf010c5c15d59ad7362f6575faeff" translate="yes" xml:space="preserve">
          <source>Terms and List Operators (Leftward)</source>
          <target state="translated">用語とリスト演算子(左寄せ</target>
        </trans-unit>
        <trans-unit id="f7687808514bd6fdef254462f2ef21603ff94c5d" translate="yes" xml:space="preserve">
          <source>Ternary &lt;code&gt;&quot;?:&quot;&lt;/code&gt; is the conditional operator, just as in C. It works much like an if-then-else. If the argument before the &lt;code&gt;?&lt;/code&gt; is true, the argument before the &lt;code&gt;:&lt;/code&gt; is returned, otherwise the argument after the &lt;code&gt;:&lt;/code&gt; is returned. For example:</source>
          <target state="translated">Ternary &lt;code&gt;&quot;?:&quot;&lt;/code&gt; は、Cと同様に条件演算子です。if -then-elseのように機能します。 &lt;code&gt;?&lt;/code&gt; の前の引数が がtrueの場合、 &lt;code&gt;:&lt;/code&gt; の前の引数が返されます。それ以外の場合は、 &lt;code&gt;:&lt;/code&gt; の後の引数が返されます。例えば：</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="a606ccac095617dc9512d70db5efd42e7bb98a43" translate="yes" xml:space="preserve">
          <source>Test - provides a simple framework for writing test scripts</source>
          <target state="translated">Test-テストスクリプトを書くためのシンプルなフレームワークを提供します。</target>
        </trans-unit>
        <trans-unit id="39cded9148b38cec922514bd35a2aef5469fc539" translate="yes" xml:space="preserve">
          <source>Test Status and Info</source>
          <target state="translated">テスト状況と情報</target>
        </trans-unit>
        <trans-unit id="0f42e18af9e42f65883381d95b6da9a9beb625ba" translate="yes" xml:space="preserve">
          <source>Test _all_ behaviors of a given operator, library, or function.</source>
          <target state="translated">与えられた演算子、ライブラリ、関数のすべての動作をテストします。</target>
        </trans-unit>
        <trans-unit id="ccbf4ddf89827f1aef746e7810ae2a433cf06e90" translate="yes" xml:space="preserve">
          <source>Test all optional arguments.</source>
          <target state="translated">すべてのオプション引数をテストします。</target>
        </trans-unit>
        <trans-unit id="ee2236a26189cf2bce4daa0c312f2ad998013277" translate="yes" xml:space="preserve">
          <source>Test an SV for taintedness. Use &lt;code&gt;SvTAINTED&lt;/code&gt; instead.</source>
          <target state="translated">SVの汚染をテストします。代わりに &lt;code&gt;SvTAINTED&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="435f6b9009ca18e663fe202fc1240deccf2b918a" translate="yes" xml:space="preserve">
          <source>Test building utility methods</source>
          <target state="translated">建物のユーティリティー方法をテストします。</target>
        </trans-unit>
        <trans-unit id="b4b87c6940ff3faed10366f7a463d3bfb89e71a4" translate="yes" xml:space="preserve">
          <source>Test control</source>
          <target state="translated">テスト制御</target>
        </trans-unit>
        <trans-unit id="10d741ad5424269aabb883c550c337fb9f577347" translate="yes" xml:space="preserve">
          <source>Test for Memoize expiration semantics</source>
          <target state="translated">Memoizeの有効期限のセマンティクスのテスト</target>
        </trans-unit>
        <trans-unit id="f76975f4d894de42ed86a6b96159814a64e69414" translate="yes" xml:space="preserve">
          <source>Test for end of file.</source>
          <target state="translated">ファイルの終端をテストします。</target>
        </trans-unit>
        <trans-unit id="79382a00ce637c0c3d356c1d16aa7f8ddce716b6" translate="yes" xml:space="preserve">
          <source>Test for the value of &amp;amp;Time::HiRes::d_hires_stat to find out whether the operating system supports subsecond file timestamps: a value larger than zero means yes. There are unfortunately no easy ways to find out whether the filesystem supports such timestamps. UNIX filesystems often do; NTFS does; FAT doesn't (FAT timestamp granularity is &lt;b&gt;two&lt;/b&gt; seconds).</source>
          <target state="translated">＆Time :: HiRes :: d_hires_statの値をテストして、オペレーティングシステムがサブセカンドファイルのタイムスタンプをサポートしているかどうかを確認します。ゼロより大きい値は、はいを意味します。残念ながら、ファイルシステムがそのようなタイムスタンプをサポートしているかどうかを確認する簡単な方法はありません。UNIXファイルシステムはしばしばそうします。NTFSにはあります。FATはサポートしていません（FATタイムスタンプの粒度は&lt;b&gt;2&lt;/b&gt;秒です）。</target>
        </trans-unit>
        <trans-unit id="7f831cc3a669b4e57bff2b2ef159b4ea5dded3cc" translate="yes" xml:space="preserve">
          <source>Test if the content of an SV looks like a number (or is a number). &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt; are treated as numbers (so will not issue a non-numeric warning), even if your atof() doesn't grok them. Get-magic is ignored.</source>
          <target state="translated">SVの内容が数値のように見える（または数値である）かどうかをテストします。 &lt;code&gt;Inf&lt;/code&gt; と &lt;code&gt;Infinity&lt;/code&gt; は数値として扱われます（したがって、非数値の警告は発行されません）。たとえ、atof（）がそれらを処理しなくてもです。Get-magicは無視されます。</target>
        </trans-unit>
        <trans-unit id="7f13862d482c878134330e38991502bcc64e1f31" translate="yes" xml:space="preserve">
          <source>Test mode. The target address defaults to &lt;b&gt;perlbug-test@perl.org&lt;/b&gt;.</source>
          <target state="translated">テストモード。ターゲットアドレスのデフォルトは&lt;b&gt;perlbug-test@perl.org&lt;/b&gt;です。</target>
        </trans-unit>
        <trans-unit id="69080e5c49da5d3bba9b15a273b20b2df3903f2b" translate="yes" xml:space="preserve">
          <source>Test names</source>
          <target state="translated">テスト名</target>
        </trans-unit>
        <trans-unit id="5df0db78620ddd32bfd4efd442e6b3f36d8261a7" translate="yes" xml:space="preserve">
          <source>Test result token.</source>
          <target state="translated">テスト結果トークン。</target>
        </trans-unit>
        <trans-unit id="ee151a1ef75c0ed5024755e133172ea9006bb555" translate="yes" xml:space="preserve">
          <source>Test results vary depending on your host system and your Cygwin configuration. If a test can pass in some Cygwin setup, it is always attempted and explainable test failures are documented. It is possible for Perl to pass all the tests, but it is more likely that some tests will fail for one of the reasons listed below.</source>
          <target state="translated">テスト結果は、ホストシステムとCygwinの設定によって異なります。いくつかのCygwin設定でテストが合格した場合、それは常に試みられ、説明可能なテストの失敗は文書化されています。Perlがすべてのテストに合格することは可能ですが、以下の理由でいくつかのテストが失敗する可能性が高くなります。</target>
        </trans-unit>
        <trans-unit id="7aeb2301cd878b4bea322bf5867e98635082f17a" translate="yes" xml:space="preserve">
          <source>Test results will be added to the supplied &lt;a href=&quot;parser/aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;. &lt;code&gt;aggregate_tests&lt;/code&gt; may be called multiple times to run several sets of tests. Multiple &lt;code&gt;Test::Harness&lt;/code&gt; instances may be used to pass results to a single aggregator so that different parts of a complex test suite may be run using different &lt;code&gt;TAP::Harness&lt;/code&gt; settings. This is useful, for example, in the case where some tests should run in parallel but others are unsuitable for parallel execution.</source>
          <target state="translated">テスト結果は、提供されている&lt;a href=&quot;parser/aggregator&quot;&gt;TAP :: Parser :: Aggregatorに&lt;/a&gt;追加されます。 &lt;code&gt;aggregate_tests&lt;/code&gt; は、複数のテストセットを実行するために複数回呼び出すことができます。複数の &lt;code&gt;Test::Harness&lt;/code&gt; インスタンスを使用して結果を単一のアグリゲーターに渡すことができるため、複雑なテストスイートのさまざまな部分をさまざまな &lt;code&gt;TAP::Harness&lt;/code&gt; 設定を使用して実行できます。これは、たとえば、一部のテストを並列に実行する必要があるが、他のテストは並列実行に適さない場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="30bf8d2a1f537e3de40966fbaca2a259bafa1326" translate="yes" xml:space="preserve">
          <source>Test return values in various contexts (boolean, scalar, list, lvalue).</source>
          <target state="translated">様々なコンテキスト(boolean,scalar,list,lvalue)で戻り値をテストします。</target>
        </trans-unit>
        <trans-unit id="87b25e7182a4957634bdf28eb60aa42f52a26bbf" translate="yes" xml:space="preserve">
          <source>Test style</source>
          <target state="translated">テストスタイル</target>
        </trans-unit>
        <trans-unit id="5f967f7d2e1f440aeb4c91e854d76b62157077cf" translate="yes" xml:space="preserve">
          <source>Test suite</source>
          <target state="translated">テストスイート</target>
        </trans-unit>
        <trans-unit id="26b3f7125d4977a4c818431649628fa0924ccde1" translate="yes" xml:space="preserve">
          <source>Test testsuites that have been built with</source>
          <target state="translated">で構築されたテストスイートをテストします。</target>
        </trans-unit>
        <trans-unit id="c743b9b50bdf1cbd4320751b7b3e3e77099e55b4" translate="yes" xml:space="preserve">
          <source>Test that the given &lt;code&gt;pv&lt;/code&gt; doesn't contain any internal &lt;code&gt;NUL&lt;/code&gt; characters. If it does, set &lt;code&gt;errno&lt;/code&gt; to ENOENT, optionally warn, and return FALSE.</source>
          <target state="translated">指定された &lt;code&gt;pv&lt;/code&gt; に内部 &lt;code&gt;NUL&lt;/code&gt; 文字が含まれていないことをテストします。存在する場合は、 &lt;code&gt;errno&lt;/code&gt; をENOENTに設定し、オプションで警告して、FALSEを返します。</target>
        </trans-unit>
        <trans-unit id="e8e7a9e15ab34cf742c942e50d6aff3c06043d08" translate="yes" xml:space="preserve">
          <source>Test the perl C API</source>
          <target state="translated">perl の C API をテストする</target>
        </trans-unit>
        <trans-unit id="8c712f8219cebd35791babf9ed3b703a8351ea8b" translate="yes" xml:space="preserve">
          <source>Test two buffers (which may contain embedded &lt;code&gt;NUL&lt;/code&gt; characters, to see if they are equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns zero if equal, or non-zero if non-equal.</source>
          <target state="translated">2つのバッファー（埋め込み &lt;code&gt;NUL&lt;/code&gt; 文字が含まれている可能性がある）をテストして、それらが等しいかどうかを確認します &lt;code&gt;len&lt;/code&gt; パラメーターは、比較するバイト数を示します。等しい場合はゼロを返し、等しくない場合はゼロ以外を返します。</target>
        </trans-unit>
        <trans-unit id="aa66181e4ff9ebce0ccdea0d81358cf4b122fa39" translate="yes" xml:space="preserve">
          <source>Test two buffers (which may contain embedded &lt;code&gt;NUL&lt;/code&gt; characters, to see if they are not equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns zero if non-equal, or non-zero if equal.</source>
          <target state="translated">2つのバッファー（埋め込まれた &lt;code&gt;NUL&lt;/code&gt; 文字を含む可能性がある）をテストして、それらが等しくないかどうかを確認します &lt;code&gt;len&lt;/code&gt; パラメーターは、比較するバイト数を示します。等しくない場合はゼロを返し、等しくない場合はゼロ以外を返します。</target>
        </trans-unit>
        <trans-unit id="7588b6c061b826b0f7a0fe2738aa760c611f4b7d" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is greater than or equal to the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">2つの文字列をテストして、最初の文字列 &lt;code&gt;s1&lt;/code&gt; が2番目の文字列 &lt;code&gt;s2&lt;/code&gt; 以上かどうかを確認します。trueまたはfalseを返します。</target>
        </trans-unit>
        <trans-unit id="960024a856f809dce4509cd90004cd8da3ca6ba1" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is greater than the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">2つの文字列をテストして、最初の文字列 &lt;code&gt;s1&lt;/code&gt; が2番目の文字列 &lt;code&gt;s2&lt;/code&gt; よりも大きいかどうかを確認します。trueまたはfalseを返します。</target>
        </trans-unit>
        <trans-unit id="ee2367cd81142917d4f07c520dafb2f8d390eb84" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is less than or equal to the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">2つの文字列をテストして、最初の文字列 &lt;code&gt;s1&lt;/code&gt; が2番目の文字列 &lt;code&gt;s2&lt;/code&gt; 以下かどうかを確認します。trueまたはfalseを返します。</target>
        </trans-unit>
        <trans-unit id="57ddc2e399365a286280a07fe9ed50d6bfa9604c" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is less than the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">2つの文字列をテストして、最初の文字列 &lt;code&gt;s1&lt;/code&gt; が2番目の文字列 &lt;code&gt;s2&lt;/code&gt; よりも小さいかどうかを確認します。trueまたはfalseを返します。</target>
        </trans-unit>
        <trans-unit id="237ab8c0b99038db78a7c54fb0bfdbb2ab764cbb" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are different. Returns true or false.</source>
          <target state="translated">2つの文字列が異なるかどうかをテストします。true または false を返します。</target>
        </trans-unit>
        <trans-unit id="fb2934866aafd7ff65638c4caf1d299244cb4e65" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are different. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for &lt;code&gt;strncmp&lt;/code&gt; ).</source>
          <target state="translated">2つの文字列をテストして、それらが異なるかどうかを確認します。 &lt;code&gt;len&lt;/code&gt; パラメータは比較するバイト数を示します。trueまたはfalseを返します。（ &lt;code&gt;strncmp&lt;/code&gt; のラッパー）。</target>
        </trans-unit>
        <trans-unit id="44326cf741b4ea53c3861e1c04224785c2787564" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are equal. Returns true or false.</source>
          <target state="translated">2つの文字列が等しいかどうかをテストします。真か偽を返します。</target>
        </trans-unit>
        <trans-unit id="f0b60c1b2d7c48750566bd13231437cae4745024" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for &lt;code&gt;strncmp&lt;/code&gt; ).</source>
          <target state="translated">2つの文字列をテストして、それらが等しいかどうかを確認します。 &lt;code&gt;len&lt;/code&gt; パラメータは比較するバイト数を示します。trueまたはfalseを返します。（ &lt;code&gt;strncmp&lt;/code&gt; のラッパー）。</target>
        </trans-unit>
        <trans-unit id="368b5822e8d2728701a3f8f8b37d0363f9573092" translate="yes" xml:space="preserve">
          <source>Test.pl</source>
          <target state="translated">Test.pl</target>
        </trans-unit>
        <trans-unit id="193904736b8940fdc2ba17861b0cc502cad2d12e" translate="yes" xml:space="preserve">
          <source>Test::Builder</source>
          <target state="translated">Test::Builder</target>
        </trans-unit>
        <trans-unit id="ab9974f668e2c6c0ffc2992746669dd361b94a4d" translate="yes" xml:space="preserve">
          <source>Test::Builder - Backend for building test libraries</source>
          <target state="translated">Test::Builder-テストライブラリをビルドするためのバックエンド</target>
        </trans-unit>
        <trans-unit id="b3b54af1fc0cfa765b71e78e4e18039fd43150ca" translate="yes" xml:space="preserve">
          <source>Test::Builder is only thread-aware if threads.pm is loaded</source>
          <target state="translated">Test::Builder は threads.pm がロードされている場合にのみスレッドを認識します。</target>
        </trans-unit>
        <trans-unit id="a49fdf2299317bf9d9dff7fce116cd0d0e8a3c2b" translate="yes" xml:space="preserve">
          <source>Test::Builder.</source>
          <target state="translated">Test::Builder.</target>
        </trans-unit>
        <trans-unit id="a007e7488b132a0e9d1aa8009a01ac991651ac14" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module</source>
          <target state="translated">Test::Builder::Module</target>
        </trans-unit>
        <trans-unit id="3ed23c6a90bd99e62a3c52acce5c4439a1d74951" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module - Base class for test modules</source>
          <target state="translated">Test::Builder::Module-テストモジュールの基底クラス</target>
        </trans-unit>
        <trans-unit id="cc216e7a80df8491f0b761fca22c7d52cff231ca" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module is a subclass of &lt;a href=&quot;../../exporter&quot;&gt;Exporter&lt;/a&gt; which means your module is also a subclass of Exporter. @EXPORT, @EXPORT_OK, etc... all act normally.</source>
          <target state="translated">Test :: Builder :: Moduleは&lt;a href=&quot;../../exporter&quot;&gt;Exporterの&lt;/a&gt;サブクラスです。つまり、モジュールもExporterのサブクラスです。@ EXPORT、@ EXPORT_OKなど...すべて正常に動作します。</target>
        </trans-unit>
        <trans-unit id="59c85c34391e2a59a9a1aebf543278d41eaede1e" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module provides an &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; method which acts in the same basic way as &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt;'s, setting the plan and controlling exporting of functions and variables. This allows your module to set the plan independent of &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt;.</source>
          <target state="translated">Test :: Builder :: Moduleは、&lt;a href=&quot;../more&quot;&gt;Test :: More&lt;/a&gt;と同じ基本的な方法で機能する &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; メソッドを提供し、プランを設定し、関数と変数のエクスポートを制御します。これにより、モジュールは&lt;a href=&quot;../more&quot;&gt;Test :: Moreから&lt;/a&gt;独立してプランを設定できます。</target>
        </trans-unit>
        <trans-unit id="1860964402a6fbbf4a8ee83b8ff81c101e436168" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module provides some methods of getting at the underlying Test::Builder object.</source>
          <target state="translated">Test::Builder::Module は、基礎となる Test::Builder オブジェクトを取得するためのいくつかのメソッドを提供します。</target>
        </trans-unit>
        <trans-unit id="dfe8750e469aab07b5d8dadae68c198e1a6ea505" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester</source>
          <target state="translated">Test::Builder::Tester</target>
        </trans-unit>
        <trans-unit id="99afed4f8190d67c7ca9fceff64feafac8a2c27f" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester - test testsuites that have been built with Test::Builder</source>
          <target state="translated">Test::Builder::Tester-Test::Builder でビルドされたテストスイートをテストする</target>
        </trans-unit>
        <trans-unit id="21b5ba34db69a6e0e7e2db842da88dc2874db319" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester::Color</source>
          <target state="translated">Test::Builder::Tester::Color</target>
        </trans-unit>
        <trans-unit id="2d500c7bf4e510506ebc84f5c768b05a6cccce1c" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester::Color - turn on colour in Test::Builder::Tester</source>
          <target state="translated">Test::Builder::Tester::Color-Test::Builder::Tester で色をオンにする</target>
        </trans-unit>
        <trans-unit id="d22ac9fb1a5b65be8b995c5c95d6e3ef8ecf556f" translate="yes" xml:space="preserve">
          <source>Test::Harness</source>
          <target state="translated">Test::Harness</target>
        </trans-unit>
        <trans-unit id="999566fc7acbd2379a803a5571ff7ae9c8a53f12" translate="yes" xml:space="preserve">
          <source>Test::Harness - Run Perl standard test scripts with statistics</source>
          <target state="translated">Test::Harness-統計情報を用いて Perl の標準テストスクリプトを実行する</target>
        </trans-unit>
        <trans-unit id="8bc418104ff43998dd3e36faf2584e579de681bc" translate="yes" xml:space="preserve">
          <source>Test::More</source>
          <target state="translated">Test::More</target>
        </trans-unit>
        <trans-unit id="6bfa9c991e549bd99bf8bd638cf1236dd03e5675" translate="yes" xml:space="preserve">
          <source>Test::More - yet another framework for writing test scripts</source>
          <target state="translated">Test::More-テストスクリプトを書くための別のフレームワーク</target>
        </trans-unit>
        <trans-unit id="09cadd12e0ce824bc15b5cc2302b3277911f9d5d" translate="yes" xml:space="preserve">
          <source>Test::More is loaded. This is ok:</source>
          <target state="translated">Test::Moreが読み込まれています。これでOKです。</target>
        </trans-unit>
        <trans-unit id="298bd3075d22676dbcd8f6e949f1684dca1178d5" translate="yes" xml:space="preserve">
          <source>Test::More will only be aware of threads if &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; has been done</source>
          <target state="translated">どうかをテスト::詳細はスレッドだけに気付くであろう &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 行われています</target>
        </trans-unit>
        <trans-unit id="71a20537d51a274a0fa5bf1a1b0842f5d372eac9" translate="yes" xml:space="preserve">
          <source>Test::More works with Perls as old as 5.8.1.</source>
          <target state="translated">Test::More は 5.8.1 以降の古い Perl で動作します。</target>
        </trans-unit>
        <trans-unit id="1daa106bfbe0f2bf149e9e695740563a8ed4ebb6" translate="yes" xml:space="preserve">
          <source>Test::Simple</source>
          <target state="translated">Test::Simple</target>
        </trans-unit>
        <trans-unit id="3b9ad9cea20f592f35fa16d26cd1276645b8b0c3" translate="yes" xml:space="preserve">
          <source>Test::Simple - Basic utilities for writing tests.</source>
          <target state="translated">Test::Simple-テストを書くための基本的なユーティリティ。</target>
        </trans-unit>
        <trans-unit id="475687d59b9799eb28a9bf920c296a61e431b89f" translate="yes" xml:space="preserve">
          <source>Test::Simple is &lt;b&gt;explicitly&lt;/b&gt; tested all the way back to perl 5.6.0.</source>
          <target state="translated">Test :: Simpleは、perl 5.6.0までずっと&lt;b&gt;明示的に&lt;/b&gt;テストされています。</target>
        </trans-unit>
        <trans-unit id="5f28cc996a292888e74e1d0b0e1cee8d8ca4199f" translate="yes" xml:space="preserve">
          <source>Test::Simple is thread-safe in perl 5.8.1 and up.</source>
          <target state="translated">Test::Simple は perl 5.8.1 以降でスレッドセーフです。</target>
        </trans-unit>
        <trans-unit id="73bb7e431ecc9d090ef6327ee2db2dd9ad7a8638" translate="yes" xml:space="preserve">
          <source>Test::Simple will only report a maximum of 254 failures in its exit code. If this is a problem, you probably have a huge test script. Split it into multiple files. (Otherwise blame the Unix folks for using an unsigned short integer as the exit status).</source>
          <target state="translated">Test::Simpleは、その終了コードで最大254件の失敗しか報告しません。これが問題になっている場合は、おそらく巨大なテストスクリプトを持っていることでしょう。それを複数のファイルに分割してください。(そうでなければ、終了ステータスとして符号なしの短い整数を使用しているUnixの人々を非難してください)。</target>
        </trans-unit>
        <trans-unit id="7410d0684050e7e2cf37f448e25d1181f683a339" translate="yes" xml:space="preserve">
          <source>Test::Simple will start by printing number of tests run in the form &quot;1..M&quot; (so &quot;1..5&quot; means you're going to run 5 tests). This strange format lets &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; know how many tests you plan on running in case something goes horribly wrong.</source>
          <target state="translated">Test :: Simpleは、「1..M」の形式で実行されたテストの数を出力することから始めます（「1..5」は5つのテストを実行することを意味します）。この奇妙なフォーマットにより、&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt;は、何かがひどくうまくいかない場合に実行する予定のテストの数を知ることができます。</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="df0cbdcfcbefab8ee9cdb49385d677707edb64f0" translate="yes" xml:space="preserve">
          <source>Testing Anomalies with Perl on OS/390</source>
          <target state="translated">OS/390でPerlを使って異常をテストする</target>
        </trans-unit>
        <trans-unit id="5570491e686f99f120f682632ae7878ad3d5e6f3" translate="yes" xml:space="preserve">
          <source>Testing Perl on AmigaOS</source>
          <target state="translated">AmigaOSでPerlをテストする</target>
        </trans-unit>
        <trans-unit id="8fcfced2bef4012741d97c1ae50789df4c2ca1a7" translate="yes" xml:space="preserve">
          <source>Testing Perl on BS2000</source>
          <target state="translated">BS2000でのPerlのテスト</target>
        </trans-unit>
        <trans-unit id="d2f23703acfdab063aa7e2b458c49da1d7edf65c" translate="yes" xml:space="preserve">
          <source>Testing Perl on DOS</source>
          <target state="translated">DOSでのPerlのテスト</target>
        </trans-unit>
        <trans-unit id="06d9fe11979b660c9a4ee9181d453bdc4d62d418" translate="yes" xml:space="preserve">
          <source>Testing Perl on Tru64</source>
          <target state="translated">Tru64でのPerlのテスト</target>
        </trans-unit>
        <trans-unit id="ad2407f8ab58aad232d3d10c4a28600678ba9ac4" translate="yes" xml:space="preserve">
          <source>Testing Perl on Windows</source>
          <target state="translated">WindowsでPerlをテストする</target>
        </trans-unit>
        <trans-unit id="77bcc7871b8f58fd20b1c5a5350ee1211c163038" translate="yes" xml:space="preserve">
          <source>Testing for broken locales</source>
          <target state="translated">壊れた地域のテスト</target>
        </trans-unit>
        <trans-unit id="8a625de0654c02e74db29ae73bd5e3bde68f2ba9" translate="yes" xml:space="preserve">
          <source>Testing for exact floating-point equality or inequality is not a good idea. Here's a (relatively expensive) work-around to compare whether two floating-point numbers are equal to a particular number of decimal places. See Knuth, volume II, for a more robust treatment of this topic.</source>
          <target state="translated">浮動小数点の正確な等しさや不等しさをテストすることは、良い考えではありません。2つの浮動小数点数が特定の小数点以下の数と等しいかどうかを比較するための(比較的高価な)回避策がここにあります。このトピックのより堅牢な扱いについては、Knuth,volume IIを参照してください。</target>
        </trans-unit>
        <trans-unit id="ce74fac01896559c610eb3a5a4dbe52a84d8dafc" translate="yes" xml:space="preserve">
          <source>Testing for operating systems or versions when should be testing for features</source>
          <target state="translated">機能のテストが必要な場合のOSやバージョンのテスト</target>
        </trans-unit>
        <trans-unit id="e225b583da27a200eb4cb29e5d543c5d33dff11a" translate="yes" xml:space="preserve">
          <source>Testing results: &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/&lt;/a&gt;</source>
          <target state="translated">テスト結果：&lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http&lt;/a&gt; : //www.cpantesters.org/</target>
        </trans-unit>
        <trans-unit id="062a3b44009f84b9f2800778be4849f48c73f2e1" translate="yes" xml:space="preserve">
          <source>Testing the patch</source>
          <target state="translated">パッチのテスト</target>
        </trans-unit>
        <trans-unit id="39fdec1194d94212b871a28b2aa04a73cd40fce1" translate="yes" xml:space="preserve">
          <source>Tests</source>
          <target state="translated">Tests</target>
        </trans-unit>
        <trans-unit id="16d924262049c4868fcbd9b1e4dbe661fd3a3f60" translate="yes" xml:space="preserve">
          <source>Tests are run from the top level of your distribution. So inside a test you would refer to ./lib to enter the lib directory, for example.</source>
          <target state="translated">テストはディストリビューションのトップレベルから実行されます。そのため、テストの中では ./lib を参照して lib ディレクトリに入ることになります。</target>
        </trans-unit>
        <trans-unit id="54a6b8165e3eb024d50e4aac5941e40919fd1c85" translate="yes" xml:space="preserve">
          <source>Tests for basic control structures, &lt;code&gt;if/else&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; , subroutines, etc.</source>
          <target state="translated">基本的な制御構造、 &lt;code&gt;if/else&lt;/code&gt; 、 &lt;code&gt;while&lt;/code&gt; 、サブルーチンなどのテスト</target>
        </trans-unit>
        <trans-unit id="d23a0f9aaa05867bc6031160779c65549d0d4574" translate="yes" xml:space="preserve">
          <source>Tests for basic issues of how Perl parses and compiles itself.</source>
          <target state="translated">Perl がどのように自分自身を解析してコンパイルするかの基本的な問題をテストします。</target>
        </trans-unit>
        <trans-unit id="308c251d349eaa69d0bf0cd8f27225db41d2132b" translate="yes" xml:space="preserve">
          <source>Tests for built-in IO functions, including command line arguments.</source>
          <target state="translated">コマンドライン引数を含む組み込みIO関数のテスト。</target>
        </trans-unit>
        <trans-unit id="19b2942a8db27974454d5941c50ac27e7e57bf55" translate="yes" xml:space="preserve">
          <source>Tests for core modules in the</source>
          <target state="translated">のコアモジュールのテスト</target>
        </trans-unit>
        <trans-unit id="b5bc9dd6c6b565df077d3e101f86339fa68c2de9" translate="yes" xml:space="preserve">
          <source>Tests for features of how perl actually runs, including exit codes and handling of PERL* environment variables.</source>
          <target state="translated">終了コードやPERL*環境変数の取り扱いなど、Perlが実際にどのように動作するかの機能をテストします。</target>
        </trans-unit>
        <trans-unit id="3267c94afb370d057a2cbf7d80804c00a071b8c7" translate="yes" xml:space="preserve">
          <source>Tests for modules in</source>
          <target state="translated">のモジュールのテスト</target>
        </trans-unit>
        <trans-unit id="546a42daa356e4d754d8415b0cf28f28144cb38f" translate="yes" xml:space="preserve">
          <source>Tests for perl's built in functions that don't fit into any of the other directories.</source>
          <target state="translated">他のディレクトリに収まらないPerlの組み込み関数をテストします。</target>
        </trans-unit>
        <trans-unit id="7dde17b953b0dbe2392223a460035fd53ab6fcb8" translate="yes" xml:space="preserve">
          <source>Tests for perl's built in functions which, like those in</source>
          <target state="translated">のようなPerlの組み込み関数のテストを行います。</target>
        </trans-unit>
        <trans-unit id="cee38a612a6bf39e0ad8abf7e176cb7eb3696a9c" translate="yes" xml:space="preserve">
          <source>Tests for perl's method resolution order implementations (see &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt;).</source>
          <target state="translated">perlのメソッド解決順序実装のテスト（&lt;a href=&quot;mro&quot;&gt;mroを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="20b59967ab49cfe543876fa9d6d79f51e0848a3e" translate="yes" xml:space="preserve">
          <source>Tests for regex related functions or behaviour. (These used to live in t/op).</source>
          <target state="translated">正規表現に関連する関数や動作のテスト。(これらは以前は t/op に含まれていました)。</target>
        </trans-unit>
        <trans-unit id="9a9539800599d59b0f69e2e288d490ed3068858e" translate="yes" xml:space="preserve">
          <source>Tests for the absolute basic functionality of Perl. This includes &lt;code&gt;if&lt;/code&gt; , basic file reads and writes, simple regexes, etc. These are run first in the test suite and if any of them fail, something is</source>
          <target state="translated">Perlの絶対的な基本機能をテストします。これには &lt;code&gt;if&lt;/code&gt; 、基本的なファイルの読み取りと書き込み、単純な正規表現などが含まれます。これらはテストスイートで最初に実行され、いずれかが失敗した場合、何かが</target>
        </trans-unit>
        <trans-unit id="4c72675b2d7c270a253600fe2e92bb83c326034f" translate="yes" xml:space="preserve">
          <source>Tests for the core support of Unicode.</source>
          <target state="translated">Unicode のコアサポートのためのテスト。</target>
        </trans-unit>
        <trans-unit id="5399480a16c4de144214dd4ce3a72127bb1a23c7" translate="yes" xml:space="preserve">
          <source>Tests for your modules go here. Each test filename ends with a .t. So</source>
          <target state="translated">モジュールのテストはここにあります。それぞれのテストファイル名は .t で終わります。</target>
        </trans-unit>
        <trans-unit id="3b09fe0c89b9d62c4f3f3bd0ca9b2eec4dcf9e3b" translate="yes" xml:space="preserve">
          <source>Tests if a directory exists.</source>
          <target state="translated">ディレクトリが存在するかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="46dcf6b14fde2f007d3642aeb765c51b6d6d9ef7" translate="yes" xml:space="preserve">
          <source>Tests if a file exists and is not empty (size &amp;gt; 0).</source>
          <target state="translated">ファイルが存在し、空ではない（サイズ&amp;gt; 0）かどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="6b574534ebbfa4f25620de8b753e474bc0774320" translate="yes" xml:space="preserve">
          <source>Tests if a file exists.</source>
          <target state="translated">ファイルが存在するかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="cbd83d5913990ad1027b8f9518f00ff7c97af8a7" translate="yes" xml:space="preserve">
          <source>Tests if some arbitrary number of bytes begins in a valid UTF-8 character. Note that an INVARIANT (i.e. ASCII on non-EBCDIC machines) character is a valid UTF-8 character. The actual number of bytes in the UTF-8 character will be returned if it is valid, otherwise 0.</source>
          <target state="translated">任意のバ イ ト 数が有効な UTF-8 キ ャ ラ ク タ で始ま る か ど う か を テ ス ト し ます。INVARIANT (すなわち、EBCDIC 以外のマシンでは ASCII)キ ャ ラ ク タ は有効な UTF-8 キ ャ ラ ク タ であ る こ と に注意 し て く だ さ い。UTF-8 キ ャ ラ ク タ の実際のバ イ ト 数は、 それが有効な場合に返 さ れ、 それ以外の場合には 0 にな り ます。</target>
        </trans-unit>
        <trans-unit id="44e861c8808d6c4fdc4afa5679c3cee1a9b5d6ca" translate="yes" xml:space="preserve">
          <source>Tests if the SV is an RV.</source>
          <target state="translated">SV が RV であるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="e941f360f3702d2e201c15e9113b9156e131c64f" translate="yes" xml:space="preserve">
          <source>Tests if the source file exists and is not empty (size &amp;gt; 0). If it is not empty it copies it to the given destination with the given permissions.</source>
          <target state="translated">ソースファイルが存在し、空ではない（サイズ&amp;gt; 0）かどうかをテストします。空でない場合は、指定されたアクセス権で指定された宛先にコピーします。</target>
        </trans-unit>
        <trans-unit id="8add41d28c736769282eb5984bc3956add793925" translate="yes" xml:space="preserve">
          <source>Tests if two threads objects are the same thread or not. This is overloaded to the more natural forms:</source>
          <target state="translated">2 つのスレッドオブジェクトが同じスレッドであるかどうかをテストします。これはより自然な形にオーバーロードされます。</target>
        </trans-unit>
        <trans-unit id="374b92e6c8d9a3ee7da76fc28e0b35de614ef062" translate="yes" xml:space="preserve">
          <source>Tests that have never failed will not be selected. To run all tests with the most recently failed first use</source>
          <target state="translated">一度も失敗したことのないテストは選択されません。最近失敗したテストをすべて実行するには、最初に</target>
        </trans-unit>
        <trans-unit id="0b32728377a8f935217ef765a504aecedda1d3ff" translate="yes" xml:space="preserve">
          <source>Tests the SigSet object to see if it contains a specific signal.</source>
          <target state="translated">SigSet オブジェクトに特定のシグナルが含まれているかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="018f42b8eff88fccb00a8501792db561a99e45b3" translate="yes" xml:space="preserve">
          <source>Tests the state of the source tree for various common errors. For example, it tests that everyone who is listed in the git log has a corresponding entry in the</source>
          <target state="translated">ソースツリーの状態をテストし、さまざまな一般的なエラーの有無を調べます。たとえば、git ログにリストアップされているすべての人が、それに対応するエントリを</target>
        </trans-unit>
        <trans-unit id="ea2ffd035ac28e433a00f696dde2f14824fdd414" translate="yes" xml:space="preserve">
          <source>Tests will be run in the order found.</source>
          <target state="translated">テストは見つかった順に実行されます。</target>
        </trans-unit>
        <trans-unit id="e7d8144d0e2f5125039e56e9f410b15ff3f27544" translate="yes" xml:space="preserve">
          <source>Texas Instruments</source>
          <target state="translated">テキサス・インスツルメンツ</target>
        </trans-unit>
        <trans-unit id="c1c3994d542e6e140e686559285de68d361dbc43" translate="yes" xml:space="preserve">
          <source>Text Fields</source>
          <target state="translated">テキストフィールド</target>
        </trans-unit>
        <trans-unit id="5295b0156f97937927214f3e61425549fb5528ba" translate="yes" xml:space="preserve">
          <source>Text after __DATA__ may be read via the filehandle &lt;code&gt;PACKNAME::DATA&lt;/code&gt; , where &lt;code&gt;PACKNAME&lt;/code&gt; is the package that was current when the __DATA__ token was encountered. The filehandle is left open pointing to the line after __DATA__. The program should &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; DATA&lt;/code&gt; when it is done reading from it. (Leaving it open leaks filehandles if the module is reloaded for any reason, so it's a safer practice to close it.) For compatibility with older scripts written before __DATA__ was introduced, __END__ behaves like __DATA__ in the top level script (but not in files loaded with &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;) and leaves the remaining contents of the file accessible via &lt;code&gt;main::DATA&lt;/code&gt; .</source>
          <target state="translated">__DATA__の後のテキストは、ファイルハンドル &lt;code&gt;PACKNAME::DATA&lt;/code&gt; を介して読み取ることができます。ここで、 &lt;code&gt;PACKNAME&lt;/code&gt; は、__ DATA__トークンが検出されたときに最新であったパッケージです。ファイルハンドルは、__ DATA__の後の行を指すように開いたままにしておきます。プログラムは、 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; DATA&lt;/code&gt; 読み取りが完了したらDATAを&lt;a href=&quot;functions/close&quot;&gt;閉じる&lt;/a&gt;必要があります。 （モジュールをなんらかの理由でリロードすると、開いたままにするとファイルハンドルがリークするため、モジュールを閉じる方が安全です。 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; ）でロードされ、 &lt;code&gt;main::DATA&lt;/code&gt; 介してアクセス可能なファイルの残りのコンテンツを残します。</target>
        </trans-unit>
        <trans-unit id="14b961306ccde8b23c4b7e5620da4263be5fc453" translate="yes" xml:space="preserve">
          <source>Text from a &lt;code&gt;&quot;#&quot;&lt;/code&gt; character until the end of the line is a comment, and is ignored. Exceptions include &lt;code&gt;&quot;#&quot;&lt;/code&gt; inside a string or regular expression.</source>
          <target state="translated">&lt;code&gt;&quot;#&quot;&lt;/code&gt; 文字から行末までのテキストはコメントであり、無視されます。例外には、文字列または正規表現内の &lt;code&gt;&quot;#&quot;&lt;/code&gt; 含まれます。</target>
        </trans-unit>
        <trans-unit id="612222022f1b46958ab65767470934164201705e" translate="yes" xml:space="preserve">
          <source>Text sorted by numeric codepoint follows no reasonable alphabetic order; use the UCA for sorting text.</source>
          <target state="translated">数字のコードポイントでソートされたテキストは、合理的なアルファベット順ではありません。</target>
        </trans-unit>
        <trans-unit id="2c6fa58228dea3c204f1dbf0a6dfadcd17082dee" translate="yes" xml:space="preserve">
          <source>Text strings (character strings)</source>
          <target state="translated">テキスト文字列(文字列</target>
        </trans-unit>
        <trans-unit id="3b64142186315d3b56e626d60aec3cca8845fddf" translate="yes" xml:space="preserve">
          <source>Text-mode filehandles</source>
          <target state="translated">テキストモードのファイルハンドル</target>
        </trans-unit>
        <trans-unit id="5f66be9f33facdd2db9a099e59f4d627dc79cb6a" translate="yes" xml:space="preserve">
          <source>Text-tokens from Pod::Simple::PullParser</source>
          <target state="translated">Pod::Simple::PullParserからのテキストトークン</target>
        </trans-unit>
        <trans-unit id="0ff712854e85b7ca719cd920d585fda4d395d5a6" translate="yes" xml:space="preserve">
          <source>Text/Soundex.pm</source>
          <target state="translated">Text/Soundex.pm</target>
        </trans-unit>
        <trans-unit id="e496659a9c65305c9d5cc245d38c0b1cea09e5cd" translate="yes" xml:space="preserve">
          <source>Text2</source>
          <target state="translated">Text2</target>
        </trans-unit>
        <trans-unit id="76fdd8573b883583b24f2ee565ca6b0eb2a5486b" translate="yes" xml:space="preserve">
          <source>Text::Abbrev</source>
          <target state="translated">Text::Abbrev</target>
        </trans-unit>
        <trans-unit id="2068aa4164bd7ee8a2ded8f7cd23b18d6c9d99cd" translate="yes" xml:space="preserve">
          <source>Text::Abbrev - abbrev - create an abbreviation table from a list</source>
          <target state="translated">Text::Abbrev-abbrev-リストから略語表を作成する</target>
        </trans-unit>
        <trans-unit id="3fa2f6e623c8f3b7b036f20657d7a8f10bb6417e" translate="yes" xml:space="preserve">
          <source>Text::Balanced</source>
          <target state="translated">Text::Balanced</target>
        </trans-unit>
        <trans-unit id="ed925f6d474c4516a347932710d3ebe30e7e56cb" translate="yes" xml:space="preserve">
          <source>Text::Balanced - Extract delimited text sequences from strings.</source>
          <target state="translated">Text::Balanced-文字列から区切り文字列を抽出する</target>
        </trans-unit>
        <trans-unit id="e4b49cafa2ac97b401d3d68d8bed306fe21eb79b" translate="yes" xml:space="preserve">
          <source>Text::ParseWords</source>
          <target state="translated">Text::ParseWords</target>
        </trans-unit>
        <trans-unit id="4524c2c613f4d738713e1d030d34e60049e80d95" translate="yes" xml:space="preserve">
          <source>Text::ParseWords - parse text into an array of tokens or array of arrays</source>
          <target state="translated">Text::ParseWords-テキストをトークンの配列あるいは配列の配列にパースする</target>
        </trans-unit>
        <trans-unit id="bdadcd3fc912962eb41c1688bb499f95c2ac99b6" translate="yes" xml:space="preserve">
          <source>Text::Tabs</source>
          <target state="translated">Text::Tabs</target>
        </trans-unit>
        <trans-unit id="d895b382c2e881055f9eeb7a0411fad11058bd8a" translate="yes" xml:space="preserve">
          <source>Text::Tabs - expand and unexpand tabs like unix expand(1) and unexpand(1)</source>
          <target state="translated">Text::Tabs-unix expand(1)や unexpand(1)のようにタブを展開したり展開しなかったりする</target>
        </trans-unit>
        <trans-unit id="4b087dde2df1e77a15a3f15af552e2d614eda1ab" translate="yes" xml:space="preserve">
          <source>Text::Tabs does most of what the unix utilities expand(1) and unexpand(1) do. Given a line with tabs in it, &lt;code&gt;expand&lt;/code&gt; replaces those tabs with the appropriate number of spaces. Given a line with or without tabs in it, &lt;code&gt;unexpand&lt;/code&gt; adds tabs when it can save bytes by doing so, like the &lt;code&gt;unexpand -a&lt;/code&gt; command.</source>
          <target state="translated">Text :: Tabsは、unixユーティリティのexpand（1）およびunexpand（1）が行うことのほとんどを実行します。タブが含まれる行を指定すると、 &lt;code&gt;expand&lt;/code&gt; はそれらのタブを適切な数のスペースに置き換えます。タブが含まれている行と含まれていない行がある場合、 &lt;code&gt;unexpand&lt;/code&gt; は、それによってバイトを節約できるときにタブを追加します（ &lt;code&gt;unexpand -a&lt;/code&gt; コマンドのように）。</target>
        </trans-unit>
        <trans-unit id="f269210fd9d87098c23ad7f43c52bf42decefb07" translate="yes" xml:space="preserve">
          <source>Text::Tabs handles only tabs (&lt;code&gt;&quot;\t&quot;&lt;/code&gt; ) and combining characters (&lt;code&gt;/\pM/&lt;/code&gt; ). It doesn't count backwards for backspaces (&lt;code&gt;&quot;\t&quot;&lt;/code&gt; ), omit other non-printing control characters (&lt;code&gt;/\pC/&lt;/code&gt; ), or otherwise deal with any other zero-, half-, and full-width characters.</source>
          <target state="translated">Text :: Tabsは、タブ（ &lt;code&gt;&quot;\t&quot;&lt;/code&gt; ）と結合文字（ &lt;code&gt;/\pM/&lt;/code&gt; ）のみを処理します。バックスペース（ &lt;code&gt;&quot;\t&quot;&lt;/code&gt; ）を逆方向にカウントしたり、他の非印刷制御文字（ &lt;code&gt;/\pC/&lt;/code&gt; ）を省略したり、その他のゼロ、半幅、および全角文字を処理したりしません。</target>
        </trans-unit>
        <trans-unit id="b226bf7a7ae42bd7cbd6a0b3ba78466abba19e61" translate="yes" xml:space="preserve">
          <source>Text::Wrap</source>
          <target state="translated">Text::Wrap</target>
        </trans-unit>
        <trans-unit id="8aabd1ad489c52bb200edd21bc6dce9b91083963" translate="yes" xml:space="preserve">
          <source>Text::Wrap - line wrapping to form simple paragraphs</source>
          <target state="translated">Text::Wrap-シンプルな段落を形成するための行の折り返し</target>
        </trans-unit>
        <trans-unit id="f8e8cd6c504322691d26989da020afe0ebedb22f" translate="yes" xml:space="preserve">
          <source>Thank you to (in chronological order):</source>
          <target state="translated">ありがとうございました(時系列順)。</target>
        </trans-unit>
        <trans-unit id="b05872aaf946f643e0804715742f143fabda127d" translate="yes" xml:space="preserve">
          <source>Thanks (in no particular order) to Chaim Frenkel, Steve Fink, Gurusamy Sarathy, Ilya Zakharevich, Benjamin Sugars, J&amp;uuml;rgen Christoffel, Joshua Pritikin, and Alan Burlison, for their help in reality-checking and polishing this article. Big thanks to Tom Christiansen for his rewrite of the prime number generator.</source>
          <target state="translated">Chaim Frenkel、Steve Fink、Gurusamy Sarathy、Ilya Zakharevich、Benjamin Sugars、Jurgen Christoffel、Joshua Pritikin、およびAlan Burlisonに、この記事の現実の確認と改善にご協力いただき、ありがとうございました（順不同）。トム・クリスチャンセンが素数ジェネレーターを書き直してくれたことに感謝します。</target>
        </trans-unit>
        <trans-unit id="515198f3ec489e991661ee9be0d3531260928534" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fhe.net%2f&quot;&gt;Hurricane Electric&lt;/a&gt; for permission to use its &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net%2f&quot;&gt;Linux man pages online&lt;/a&gt; site for man page links.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net%2f&quot;&gt;Linuxのmanページのオンライン&lt;/a&gt;サイトでmanページのリンクを使用する許可を与えてくれた&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fhe.net%2f&quot;&gt;Hurricane Electricに&lt;/a&gt;感謝します。</target>
        </trans-unit>
        <trans-unit id="4a56281c4f40d78c915f83cd7dcb75140989545c" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2f&quot;&gt;search.cpan.org&lt;/a&gt; for permission to use the site for Perl module links.</source>
          <target state="translated">Perlモジュールリンクのサイトを使用する許可を与えてくれた&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2f&quot;&gt;search.cpan.org&lt;/a&gt;に感謝します。</target>
        </trans-unit>
        <trans-unit id="3cf7d45d74afe72eed5d28a1078191c21d4ed94f" translate="yes" xml:space="preserve">
          <source>Thanks to Chia-Liang Kao for suggesting &lt;code&gt;Path&lt;/code&gt; and &lt;code&gt;loc_lang&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Path&lt;/code&gt; と &lt;code&gt;loc_lang&lt;/code&gt; を提案してくれたChia-Liang Kaoに感謝します。</target>
        </trans-unit>
        <trans-unit id="28343241fc627e1ddfa37f27bcd25a3afbba56c2" translate="yes" xml:space="preserve">
          <source>Thanks to Gerard Goossen from TTY. His presentation &quot;UTF-8 in the wild&quot; (Dutch Perl Workshop 2006) inspired me to publish my thoughts and write this tutorial.</source>
          <target state="translated">TTY の Gerard Goossen さんに感謝します。彼のプレゼンテーション &quot;UTF-8 in the wild&quot; (Dutch Perl Workshop 2006)に触発されて、私は自分の考えを発表し、このチュートリアルを書くことになりました。</target>
        </trans-unit>
        <trans-unit id="eebcdc028466185c372d461642a6d1089c91d63f" translate="yes" xml:space="preserve">
          <source>Thanks to Graham Barr for contributing the following paragraphs about the interaction between perl, and various firewall configurations. For further information on firewalls, it is recommended to consult the documentation that comes with the</source>
          <target state="translated">Graham Barr さんには、perl と様々なファイアウォールの設定の相互作用について、以下の段落を提供していただきました。ファイアウォールについての詳細な情報は</target>
        </trans-unit>
        <trans-unit id="d6d72a4f35680c5e9eebf1d781be27639e4c1c23" translate="yes" xml:space="preserve">
          <source>Thanks to James Mastros and Martijn van der Streek for their help in getting &lt;a href=&quot;open3&quot;&gt;IPC::Open3&lt;/a&gt; to behave nicely.</source>
          <target state="translated">&lt;a href=&quot;open3&quot;&gt;IPC :: Open3が適切&lt;/a&gt;に動作するように支援してくれたJames MastrosとMartijn van der Streekに感謝します。</target>
        </trans-unit>
        <trans-unit id="7dd46c60691bdec97830a740ba5397edf654eae8" translate="yes" xml:space="preserve">
          <source>Thanks to Johan Vromans from Squirrel Consultancy. His UTF-8 rants during the Amsterdam Perl Mongers meetings got me interested and determined to find out how to use character encodings in Perl in ways that don't break easily.</source>
          <target state="translated">Squirrel Consultancy の Johan Vromans に感謝します。アムステルダムの Perl Mongers ミーティングでの彼の UTF-8 の暴言に興味を持ち、Perl で簡単に壊れない方法で文字エンコーディングを使う方法を見つけようと決意しました。</target>
        </trans-unit>
        <trans-unit id="6253d9253e0f2874bf9d499be7a8e0251aa0083e" translate="yes" xml:space="preserve">
          <source>Thanks to Jonas B. Nielsen for making explicit imports work.</source>
          <target state="translated">明示的な輸入を可能にしてくれた Jonas B.Nielsen に感謝します。</target>
        </trans-unit>
        <trans-unit id="485f1de2dc0f3f17fa293a32651cd066b318634d" translate="yes" xml:space="preserve">
          <source>Thanks to Jos I. Boumans for suggesting this module to be written.</source>
          <target state="translated">このモジュールを書くことを提案してくれた Jos I.Boumans に感謝します。</target>
        </trans-unit>
        <trans-unit id="5e83291fa2c7af3f2f4cad5da93414b81429569b" translate="yes" xml:space="preserve">
          <source>Thanks to Petya Kohts for the &lt;code&gt;run_forked&lt;/code&gt; code.</source>
          <target state="translated">&lt;code&gt;run_forked&lt;/code&gt; コードを提供してくれたPetya Kohtsに感謝します。</target>
        </trans-unit>
        <trans-unit id="c916a51d90472cf9a92ff461a1e0369e54a45763" translate="yes" xml:space="preserve">
          <source>Thanks to Richard Clamp &amp;lt;richardc@unixbeard.net&amp;gt; for letting me use his testing system to try this module out on.</source>
          <target state="translated">彼のテストシステムを使用してこのモジュールを試してくれたRichard Clamp &amp;lt;richardc@unixbeard.net&amp;gt;に感謝します。</target>
        </trans-unit>
        <trans-unit id="d8791cdde7f82c928089217628fa54dbdfb5e400" translate="yes" xml:space="preserve">
          <source>Thanks to Richard Soderberg for his performance improvements.</source>
          <target state="translated">リチャード・ソダーバーグ氏のパフォーマンス向上に感謝します。</target>
        </trans-unit>
        <trans-unit id="1d0320e05ae32871d886bed9f5bf625ba37f166b" translate="yes" xml:space="preserve">
          <source>Thanks to Sean Burke, Chris Nandor, Chip Salzenberg, Tim Heaney, Gisle Aas, Rainer Tammer and especially Andrew Savige for their help and suggestions.</source>
          <target state="translated">Sean Burke、Chris Nandor、Chip Salzenberg、Tim Heaney、Gisle Aas、Rainer Tammer、そして特にAndrew Savigeの協力と提案に感謝します。</target>
        </trans-unit>
        <trans-unit id="3c490099b710a18daaafdd3d9d34a147de5b78a3" translate="yes" xml:space="preserve">
          <source>Thanks to Tom Christiansen for suggesting that this module should be written and providing ideas for code improvements and security enhancements.</source>
          <target state="translated">このモジュールを書くべきだと提案し、コードの改善とセキュリティ強化のためのアイデアを提供してくれた Tom Christiansen に感謝します。</target>
        </trans-unit>
        <trans-unit id="243da9ccc28383d127f497ef267f78f655f69ef4" translate="yes" xml:space="preserve">
          <source>Thanks to overloading, the handling of arithmetics with complex numbers is simple and almost transparent.</source>
          <target state="translated">オーバーロードのおかげで、複素数を使った算術の扱いがシンプルで、ほとんど透過的になりました。</target>
        </trans-unit>
        <trans-unit id="e1237be2e8e888521e762a958f2915acb036e56d" translate="yes" xml:space="preserve">
          <source>Thanks to the kind readers of the perl5-porters@perl.org, perl-unicode@perl.org, linux-utf8@nl.linux.org, and unicore@unicode.org mailing lists for their valuable feedback.</source>
          <target state="translated">perl5-porters@perl.org,perl-unicode@perl.org,linux-utf8@nl.linux.org,unicore@unicode.org メーリングリストの親切な読者の皆様、貴重なフィードバックをありがとうございました。</target>
        </trans-unit>
        <trans-unit id="895e96674a21c983f493504acc0807a09ac741d7" translate="yes" xml:space="preserve">
          <source>Thanks to the people who asked about this kind of stuff in several Perl IRC channels, and have constantly reminded me that a simpler explanation was needed.</source>
          <target state="translated">いくつかのPerlのIRCチャンネルでこのようなことを質問してくれた人たちに感謝します。</target>
        </trans-unit>
        <trans-unit id="5daafe91df31a9585afc5052640e7074b414f20e" translate="yes" xml:space="preserve">
          <source>Thanks to the people who reviewed this document for me, before it went public. They are: Benjamin Smith, Jan-Pieter Cornet, Johan Vromans, Lukas Mai, Nathan Gray.</source>
          <target state="translated">この文書が公開される前に、私のためにこの文書をレビューしてくれた人々に感謝します。彼らは以下の方々です。Benjamin Smith、Jan-Pieter Cornet、Johan Vromans、Lukas Mai、Nathan Grayです。</target>
        </trans-unit>
        <trans-unit id="01f69c9fb3b65301a9a56633220645f84a279dc1" translate="yes" xml:space="preserve">
          <source>That a certain field exists in a struct</source>
          <target state="translated">あるフィールドが構造体に存在すること</target>
        </trans-unit>
        <trans-unit id="13e180f49380db1e610eb63f2836d65fe6a7ff96" translate="yes" xml:space="preserve">
          <source>That a field is of certain signedness, sizeof, or type</source>
          <target state="translated">フィールドが特定の符号付き、sizeof、または型であること</target>
        </trans-unit>
        <trans-unit id="f34dd8b430aa837e89a7b0c15eb719863c536f5a" translate="yes" xml:space="preserve">
          <source>That being said, there are several ways to approach this. In Perl 5.10 and later, you can use the smart match operator to check that an item is contained in an array or a hash:</source>
          <target state="translated">これにはいくつかの方法があります。Perl 5.10 以降では、スマートマッチ演算子を使用して、項目が配列やハッシュに含まれているかどうかをチェックすることができます。</target>
        </trans-unit>
        <trans-unit id="0c260ee0a50dde66d3ef426f496fd0710d1eecdf" translate="yes" xml:space="preserve">
          <source>That being said, we value Perl's stability and security and have long had an unwritten covenant with the broader Perl community to support and maintain releases of Perl.</source>
          <target state="translated">そのため、私たちは Perl の安定性とセキュリティを重視しており、Perl のリリースをサポートし、維持するために、より広い Perl コミュニティと長い間、不文律のない契約を結んできました。</target>
        </trans-unit>
        <trans-unit id="bbe53d4c6627e25c7f5c04a5ce2e7f7fde39b418" translate="yes" xml:space="preserve">
          <source>That block is a proper block like any other, so you can put more complicated code there. This sends the message out to one of two places:</source>
          <target state="translated">このブロックは他のブロックと同じように適切なブロックなので、より複雑なコードを入れることができます。これはメッセージを2つの場所のどちらかに送ります。</target>
        </trans-unit>
        <trans-unit id="b8b88815853e7b011e14c857de7c3f74f6afc9bd" translate="yes" xml:space="preserve">
          <source>That build was a portable hppa-1.1 multithread build that supports large files compiled with gcc-2.9-hppa-991112.</source>
          <target state="translated">このビルドは、gcc-2.9-hppa-991112 でコンパイルされた大容量ファイルをサポートする移植性の高い hppa-1.1 マルチスレッドビルドです。</target>
        </trans-unit>
        <trans-unit id="51461163b856a03794ba96810bf1373b9d61492c" translate="yes" xml:space="preserve">
          <source>That clarifies the situation with regards Berkeley DB itself. What about &lt;b&gt;DB_File&lt;/b&gt;? Well, the behavior defined in the quote above is quite useful, so &lt;b&gt;DB_File&lt;/b&gt; conforms to it.</source>
          <target state="translated">これにより、Berkeley DB自体に関する状況が明らかになります。何について&lt;b&gt;はDB_File&lt;/b&gt;？さて、上記の引用で定義された動作は非常に便利なので、&lt;b&gt;DB_File&lt;/b&gt;はそれに準拠しています。</target>
        </trans-unit>
        <trans-unit id="42854bfa17d6ca63556d6a3b16e69afee421b58e" translate="yes" xml:space="preserve">
          <source>That example prints something like &lt;code&gt;&quot;1314363215shiftbbb&quot;&lt;/code&gt; , because the &lt;code&gt;=&amp;gt;&lt;/code&gt; implicitly quotes the &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; immediately on its left, ignoring the fact that &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time.shift&lt;/a&gt;&lt;/code&gt; is the entire left operand.</source>
          <target state="translated">この例では、 &lt;code&gt;&quot;1314363215shiftbbb&quot;&lt;/code&gt; ように出力します。これは、 &lt;code&gt;=&amp;gt;&lt;/code&gt; が暗黙的に &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 左側を引用し、 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time.shift&lt;/a&gt;&lt;/code&gt; が左側のオペランド全体であることを無視しているためです。</target>
        </trans-unit>
        <trans-unit id="435a3c58eaf95bd7ca9114e558f52a39c1b31273" translate="yes" xml:space="preserve">
          <source>That example will print &quot;I like dogs. I like cats&quot;. Notice the original &lt;code&gt;$x&lt;/code&gt; variable has not been affected. The overall result of the substitution is instead stored in &lt;code&gt;$y&lt;/code&gt; . If the substitution doesn't affect anything then the original string is returned:</source>
          <target state="translated">この例では、「犬が好き。猫が好き」と出力されます。元の &lt;code&gt;$x&lt;/code&gt; 変数は影響を受けていません。代わりに、置換の全体的な結果は &lt;code&gt;$y&lt;/code&gt; に格納されます。置換が何も影響しない場合は、元の文字列が返されます。</target>
        </trans-unit>
        <trans-unit id="8395ebcf27841eba05938be973987efc8d458043" translate="yes" xml:space="preserve">
          <source>That explicit association is created by the built-in &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function, which is typically used within the</source>
          <target state="translated">この明示的な関連付けは、組み込みの &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 関数によって作成されます。これは通常、</target>
        </trans-unit>
        <trans-unit id="c2ec0978d45de2f32fa9de32d3062c113e6a14e6" translate="yes" xml:space="preserve">
          <source>That extra space comes from the interpolation of the array. If you don't want to put anything between your array elements, don't use the array in double quotes. You can send it to print without them:</source>
          <target state="translated">この余分なスペースは配列の補間から来ています。配列の要素の間に何も入れたくない場合は、配列を二重引用符で囲んではいけません。二重引用符を使わずに印刷に送ることができます。</target>
        </trans-unit>
        <trans-unit id="9b298824efc1a224419fada1ed430ca9a977cee5" translate="yes" xml:space="preserve">
          <source>That function can be called with either of the following statements. Note the different argument lists.</source>
          <target state="translated">この関数は、以下のステートメントのいずれかで呼び出すことができます。引数リストの違いに注意してください。</target>
        </trans-unit>
        <trans-unit id="5a589d98a381dc121a0ca9e45213c36fe88d4b95" translate="yes" xml:space="preserve">
          <source>That gives you a parse-tree for each paragraph - so now all you need is an ordered list of paragraphs. You can maintain that yourself as a data element in the object/hash. The most straightforward way would be simply to use an array-ref, with the desired set of custom &quot;options&quot; for each invocation of &lt;b&gt;parse_text&lt;/b&gt;. Let's assume the desired option-set is given by the hash &lt;code&gt;%options&lt;/code&gt; . Then we might do something like the following:</source>
          <target state="translated">これにより、各段落の解析ツリーが得られます。つまり、必要なのは、段落の順序付きリストだけです。これは、オブジェクト/ハッシュのデータ要素として自分で管理できます。最も簡単な方法は、&lt;b&gt;parse_textを&lt;/b&gt;呼び出すたびに必要なカスタム「オプション」のセットを使用して、array-refを使用することです。希望のオプションセットがハッシュ &lt;code&gt;%options&lt;/code&gt; によって与えられていると仮定しましょう。次に、次のようなことを行います。</target>
        </trans-unit>
        <trans-unit id="64f729272f1f6cba682dfada58129c0e19d1beec" translate="yes" xml:space="preserve">
          <source>That has historically been Perl's notion of UTF-8, as that is how UTF-8 was first conceived by Ken Thompson when he invented it. However, thanks to later revisions to the applicable standards, official UTF-8 is now rather stricter than that. For example, its range is much narrower (0 .. 0x10_FFFF to cover only 21 bits instead of 32 or 64 bits) and some sequences are not allowed, like those used in surrogate pairs, the 31 non-character code points 0xFDD0 .. 0xFDEF, the last two code points in</source>
          <target state="translated">それは歴史的にPerlがUTF-8を発明したときにKen Thompsonが最初に考え出したように、UTF-8という概念があったからです。しかし、後に適用される規格の改訂のおかげで、公式の UTF-8 は今ではそれよりもかなり厳しいものになっています。た と えば、 その範囲ははるかに狭くなっており(0 ...0x10_FFFF は 32 ビッ トや 64 ビッ トの代わりに 21 ビッ トだけをカバーしています)、いくつかのシーケンスは許可されていません。</target>
        </trans-unit>
        <trans-unit id="d65679687da0ceb818cf54be11aba010b00841bb" translate="yes" xml:space="preserve">
          <source>That has the same effect as</source>
          <target state="translated">と同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="70ca5d290cf7d16b2ad0d56ac0c8bb778d981254" translate="yes" xml:space="preserve">
          <source>That is C99 or C++. Perl is C89. Using the //-comments is silently allowed by many C compilers but cranking up the ANSI C89 strictness (which we like to do) causes the compilation to fail.</source>
          <target state="translated">それはC99かC++です。PerlはC89です。多くの C コンパイラでは //-comments の使用は黙認されていますが、(私たちが好きな)ANSI C89 の厳しさを上げるとコンパイルに失敗します。</target>
        </trans-unit>
        <trans-unit id="fbc80ae07cc14a3e9ed515ddb417d3903b3e2d4c" translate="yes" xml:space="preserve">
          <source>That is C99 or C++. Some C compilers allow that, but you shouldn't.</source>
          <target state="translated">それはC99かC++です。Cコンパイラによってはそれを許すものもありますが、許すべきではありません。</target>
        </trans-unit>
        <trans-unit id="828feba24600ccd2337dfee90dbb710d49a4eff3" translate="yes" xml:space="preserve">
          <source>That is C99 or C++. While it would indeed be awfully nice to have that also in C89, to limit the scope of the loop variable, alas, we cannot.</source>
          <target state="translated">それはC99かC++です。ループ変数の範囲を制限するために、C89にもそれがあれば本当に素晴らしいのですが、残念ながら、私たちはできません。</target>
        </trans-unit>
        <trans-unit id="17c6f4c7bbbd6286d0fe21947d2ba8ade38beb92" translate="yes" xml:space="preserve">
          <source>That is because the translation from EBCDIC to ASCII is done by the web server in this case. Consult your web server's documentation for further details.</source>
          <target state="translated">この場合、EBCDICからASCIIへの変換はウェブサーバーが行うためです。詳細については、ウェブサーバーのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="942bc883ec6c98a20c711318e17853f42162c195" translate="yes" xml:space="preserve">
          <source>That is exactly equivalent to</source>
          <target state="translated">と全く同じことが言えます。</target>
        </trans-unit>
        <trans-unit id="755dfd149254cee016be67859ecceb8b680f03fe" translate="yes" xml:space="preserve">
          <source>That is fine as far as it goes. The thing is, the Perl subroutine can be specified as only a string, however, Perl allows references to subroutines and anonymous subroutines. This is where</source>
          <target state="translated">それはそれでいいのです。問題は、Perlのサブルーチンは文字列だけで指定できるのですが、Perlではサブルーチンや匿名サブルーチンへの参照を許可しています。ここで</target>
        </trans-unit>
        <trans-unit id="f6e51945777f4de56dfd6b06b12bc029f8de1ebc" translate="yes" xml:space="preserve">
          <source>That is just short for this:</source>
          <target state="translated">これだけでは短いですね。</target>
        </trans-unit>
        <trans-unit id="48a322119a3ce010a99cb16daaa24fe8a2a63a40" translate="yes" xml:space="preserve">
          <source>That is, a &quot;start&quot; character followed by any number of &quot;continue&quot; characters. Perl requires every character in an identifier to also match &lt;code&gt;\w&lt;/code&gt; (this prevents some problematic cases); and Perl additionally accepts identfier names beginning with an underscore.</source>
          <target state="translated">つまり、「開始」文字の後に任意の数の「継続」文字が続きます。Perlは、識別子のすべての文字が &lt;code&gt;\w&lt;/code&gt; にも一致することを要求します（これにより、いくつかの問題のあるケースが防止されます）。さらに、Perlはアンダースコアで始まる識別名を受け入れます。</target>
        </trans-unit>
        <trans-unit id="6558436d977d36dc225d2cf7090e600f732d6f4d" translate="yes" xml:space="preserve">
          <source>That is, a &lt;code&gt;'code...'&lt;/code&gt; filter</source>
          <target state="translated">つまり、 &lt;code&gt;'code...'&lt;/code&gt; フィルター</target>
        </trans-unit>
        <trans-unit id="1f4f6b5b263faf39b0387453cc01be5508d1f769" translate="yes" xml:space="preserve">
          <source>That is, a complex number with the real part of approximately &lt;code&gt;1.571&lt;/code&gt; and the imaginary part of approximately &lt;code&gt;-1.317&lt;/code&gt; .</source>
          <target state="translated">つまり、実部が約 &lt;code&gt;1.571&lt;/code&gt; で虚部が約 &lt;code&gt;-1.317&lt;/code&gt; の複素数です。</target>
        </trans-unit>
        <trans-unit id="0eeeaa892b3243ba38eb1a4d1d75a40e3e83e990" translate="yes" xml:space="preserve">
          <source>That is, any word character in the ASCII range, as long as the first character is not a digit.</source>
          <target state="translated">つまり、最初の文字が桁でない限り、ASCII範囲内の任意のワード文字です。</target>
        </trans-unit>
        <trans-unit id="36c759497b0b38fb79d0c364113b1512a2c43723" translate="yes" xml:space="preserve">
          <source>That is, both are like this:</source>
          <target state="translated">つまり、どちらもこんな感じです。</target>
        </trans-unit>
        <trans-unit id="75581dadc9573c00040ace36ddd58570a8c1a03a" translate="yes" xml:space="preserve">
          <source>That is, fetch the &lt;code&gt;a&lt;/code&gt; entry from the main symbol table, and then look at the scalar component of it: &lt;code&gt;gvsv&lt;/code&gt; (&lt;code&gt;pp_gvsv&lt;/code&gt; into</source>
          <target state="translated">つまり、メインシンボルテーブルからエントリをフェッチし &lt;code&gt;a&lt;/code&gt; そのスカラーコンポーネントを確認します &lt;code&gt;gvsv&lt;/code&gt; （ &lt;code&gt;pp_gvsv&lt;/code&gt; into</target>
        </trans-unit>
        <trans-unit id="fe7215514db7a28aa89b16be5f49f87245a3434d" translate="yes" xml:space="preserve">
          <source>That is, it creates a region consisting of a single paragraph; that paragraph is to be treated as a normal paragraph if &quot;formatname&quot; begins with a &quot;:&quot;; if &quot;formatname&quot;</source>
          <target state="translated">つまり、一つの段落からなる領域を作成し、&quot;formatname &quot;が&quot;:&quot;で始まる場合、その段落は通常の段落として扱われます。</target>
        </trans-unit>
        <trans-unit id="7678e34c3ebdef14cc53701ea7fd891c9a91f614" translate="yes" xml:space="preserve">
          <source>That is, it runs a conversion with default options, for whatever inputdirs and output dir you specify.</source>
          <target state="translated">つまり、あなたが指定した入力ディレクトリと出力ディレクトリに対して、デフォルトのオプションで変換を実行します。</target>
        </trans-unit>
        <trans-unit id="27a7e3645a7eb93795bc368264f8f8cb79cd561d" translate="yes" xml:space="preserve">
          <source>That is, it treated both matches as undefined, and converted that to false (raising a warning on each). The first case is the expected result, but the second is likely counterintuitive: &quot;How could both be false when they are complements?&quot; Another problem was that the implementation optimized many Unicode property matches down to already existing simpler, faster operations, which don't raise the warning. We chose to not forgo those optimizations, which help the vast majority of matches, just to generate a warning for the unlikely event that an above-Unicode code point is being matched against.</source>
          <target state="translated">つまり、両方のマッチを未定義として扱い、それを false に変換します (それぞれについて警告が表示されます)。最初のケースは期待される結果ですが、2 番目のケースはおそらく直観的ではないでしょう。もう一つの問題は、実装が多くの Unicode プロパティのマッチを、警告を発生させない既存のより単純で高速な操作に最適化していることでした。私たちは、一致の大部分を助けるこれらの最適化を見送らないことを選択しましたが、これは単に、Unicode以上のコードポイントが一致している場合に警告を生成するためだけです。</target>
        </trans-unit>
        <trans-unit id="b2448cc58794e445286f5f6bd3ff90ad3138eeba" translate="yes" xml:space="preserve">
          <source>That is, there should be (at least roughly) equal spacing between items as between paragraphs (although that spacing may well be less than the full height of a line of text). This leaves it to the reader to use (con)textual cues to figure out whether the &quot;Qui dolorem ipsum...&quot; paragraph applies to the &quot;Quisquam Est&quot; item or to all three items &quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam Est&quot;. While not an ideal situation, this is preferable to providing formatting cues that may be actually contrary to the author's intent.</source>
          <target state="translated">つまり、項目間の間隔は段落間と同じように(少なくとも大まかには)等しくなければなりません(ただし、その間隔はテキストの行の全高よりも小さくてもかまいません)。これにより、&quot;Qui dolorem ipsum...&quot;段落が &quot;Quisquam Est &quot;項目に適用されるのか、それとも &quot;Neque&quot;、&quot;Porro&quot;、&quot;Quisquam Est &quot;の3つの項目すべてに適用されるのかを理解するために、読者がテキストの合図を使用することになります。理想的な状況ではありませんが、これは、実際には著者の意図に反している可能性がある書式設定の手がかりを提供するよりも好ましいです。</target>
        </trans-unit>
        <trans-unit id="d2a300a2c4d8d472deffaf92f425ba9342ddb708" translate="yes" xml:space="preserve">
          <source>That is, to get a number between 10 and 15, inclusive, you want a random number between 0 and 5 that you can then add to 10.</source>
          <target state="translated">つまり、10から15の間の数字を得るためには、0から5の間の乱数を求め、それを10に足すことができます。</target>
        </trans-unit>
        <trans-unit id="951f36d3e716f12408c22757558026bf31602523" translate="yes" xml:space="preserve">
          <source>That is, with &quot;=for&quot;, you can have only one paragraph's worth of text (i.e., the text in &quot;=foo targetname text...&quot;), but with &quot;=begin targetname&quot; ... &quot;=end targetname&quot;, you can have any amount of stuff in between. (Note that there still must be a blank line after the &quot;=begin&quot; command and a blank line before the &quot;=end&quot; command.)</source>
          <target state="translated">つまり、&quot;=for &quot;では、1つの段落分のテキスト(つまり、&quot;=foo targetname text...&quot;のテキスト)しか持てませんが、&quot;=begin targetname&quot; ...&quot;=end targetname &quot;では、その間には何でもあります。&quot;=end targetname&quot; であれば、その間にいくらでも内容を入れることができます。(ただし、&quot;=begin &quot;コマンドの後には空行が、&quot;=end &quot;コマンドの前には空行が必要です)。</target>
        </trans-unit>
        <trans-unit id="bc1a3360b8c34a0baef326cea1af80815467c26c" translate="yes" xml:space="preserve">
          <source>That last test line above should have the number '3' instead of '2'.</source>
          <target state="translated">上の最後のテスト行には、「2」の代わりに「3」という数字が入っているはずです。</target>
        </trans-unit>
        <trans-unit id="c5a055a52b37b46f2d6c0e63eaf4e182af37b495" translate="yes" xml:space="preserve">
          <source>That looks a bit nicer; but we've got to take apart that weird template. Where did I pull that out of?</source>
          <target state="translated">ちょっといい感じだけど、あの変なテンプレートを分解しないと。どこから引っ張り出してきたんだろう?</target>
        </trans-unit>
        <trans-unit id="1d5efec9cd6d8da4fb36301f3de63b6888e753f1" translate="yes" xml:space="preserve">
          <source>That means that the address comes back in binary for the host functions, and as a regular perl integer for the net ones. This seems a bug, but here's how to deal with it:</source>
          <target state="translated">つまり、アドレスはホスト関数ではバイナリで返され、ネット関数では通常のPerlの整数で返されます。これはバグのようですが、以下に対処方法を示します。</target>
        </trans-unit>
        <trans-unit id="f3988f8ba5df3605cc3a35c620ff3fb6ee001ddb" translate="yes" xml:space="preserve">
          <source>That means that the inheritance tree of the object is traversed breadth-first and the resulting order of classes is used as the sequence in which methods are called. However, that sequence is modified by imposing a rule that the appropriate method of a derived class must be called before the same method of any ancestral class. That's why, in the above example, &lt;code&gt;X::foo&lt;/code&gt; is called before &lt;code&gt;D::foo&lt;/code&gt; , even though &lt;code&gt;D&lt;/code&gt; comes before &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;@B::ISA&lt;/code&gt; .</source>
          <target state="translated">これは、オブジェクトの継承ツリーが幅優先でトラバースされ、クラスの結果の順序がメソッドが呼び出されるシーケンスとして使用されることを意味します。ただし、そのシーケンスは、派生クラスの適切なメソッドを祖先クラスの同じメソッドの前に呼び出す必要があるという規則を課すことによって変更されます。そのため、上記の例では、 &lt;code&gt;D::foo&lt;/code&gt; 前に &lt;code&gt;X::foo&lt;/code&gt; が呼び出されますが、 &lt;code&gt;@B::ISA&lt;/code&gt; &lt;code&gt;X&lt;/code&gt; 、 &lt;code&gt;D&lt;/code&gt; がXの前に来ます。</target>
        </trans-unit>
        <trans-unit id="02a75b8fa4871b84e34a76476fddd056744d525a" translate="yes" xml:space="preserve">
          <source>That means that you can specify other options (e.g. cachesize) and still have bval default to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; for variable length records, and space for fixed length records.</source>
          <target state="translated">つまり、他のオプション（cachesizeなど）を指定しても、可変長レコードの場合はbvalのデフォルトが &lt;code&gt;&quot;\n&quot;&lt;/code&gt; になり、固定長レコードの場合はスペースが使用されます。</target>
        </trans-unit>
        <trans-unit id="ef48d86c4cc8b17f43db860898bcc6635d718b02" translate="yes" xml:space="preserve">
          <source>That method may be best because otherwise you won't treat IEEE notations like &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Infinity&lt;/code&gt; properly. At other times, you might prefer to determine whether string data can be used numerically by calling the POSIX::strtod() function or by inspecting your string with a regular expression (as documented in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;).</source>
          <target state="translated">そうしないと、 &lt;code&gt;NaN&lt;/code&gt; や &lt;code&gt;Infinity&lt;/code&gt; などのIEEE表記を適切に処理できないため、その方法が最適な場合があります。また、POSIX :: strtod（）関数を呼び出すか、正規表現（&lt;a href=&quot;perlre&quot;&gt;perlreに&lt;/a&gt;記載されている）を使用して文字列を検査することにより、文字列データを数値的に使用できるかどうかを判断したい場合もあります。</target>
        </trans-unit>
        <trans-unit id="6fd672a313da74831278f92221ca3146d4b9f20c" translate="yes" xml:space="preserve">
          <source>That no other fields exist besides the ones you know of</source>
          <target state="translated">あなたが知っている分野以外には存在しないこと</target>
        </trans-unit>
        <trans-unit id="5527de36ef73a03f5b5a63ba8cbaf8b4f3a8fcb3" translate="yes" xml:space="preserve">
          <source>That now parses as you'd expect, but you still ought to get in the habit of using parentheses in that situation. For more on prototypes, see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">これで期待どおりに構文解析されますが、その場合でも括弧を使用する習慣を身に付ける必要があります。プロトタイプの詳細については、&lt;a href=&quot;perlsub&quot;&gt;perlsubを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d37fa65fedd67f278b74cbc5a381d76fb677b39a" translate="yes" xml:space="preserve">
          <source>That prints &lt;code&gt;&quot;unphooey&quot;&lt;/code&gt; . (Yes, there are still unresolved issues having to do with visibility of &lt;code&gt;@_&lt;/code&gt; . I'm ignoring that question for the moment. (But note that if we make &lt;code&gt;@_&lt;/code&gt; lexically scoped, those anonymous subroutines can act like closures... (Gee, is this sounding a little Lispish? (Never mind.))))</source>
          <target state="translated">それは &lt;code&gt;&quot;unphooey&quot;&lt;/code&gt; と出力します。（はい、まだ &lt;code&gt;@_&lt;/code&gt; の可視性に関連する未解決の問題があります。今のところその質問は無視します（ただし、 &lt;code&gt;@_&lt;/code&gt; _ をレキシカルにスコープ指定すると、これらの匿名サブルーチンはクロージャーのように動作することに注意してください...（ああ、これは少しLispishに聞こえますか？（気にしないでください。））））</target>
        </trans-unit>
        <trans-unit id="b8f34b1d00199940c59db31a2c92190f8c2d18ac" translate="yes" xml:space="preserve">
          <source>That prints out: &lt;code&gt;&quot;The third fish is a red one.&quot;&lt;/code&gt; You can also use a repetition count and repeated pattern like this:</source>
          <target state="translated">それはプリントアウト： &lt;code&gt;&quot;The third fish is a red one.&quot;&lt;/code&gt; 次のような繰り返し数と繰り返しパターンを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="efe950f82cdddb13c9f97d9e858479f8a7148487" translate="yes" xml:space="preserve">
          <source>That problem is corrected by using the &lt;code&gt;&amp;amp;&lt;/code&gt; operator. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will now turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; correctly with parameters &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; . It does this by carrying the &lt;code&gt;&amp;amp;&lt;/code&gt; through, so the function call looks like &lt;code&gt;rpcb_gettime(host, &amp;amp;timep)&lt;/code&gt; .</source>
          <target state="translated">この問題は、 &lt;code&gt;&amp;amp;&lt;/code&gt; 演算子を使用して修正されます。&lt;b&gt;xsubppの&lt;/b&gt;コンパイラは呼び出すコードにこれを有効にします &lt;code&gt;rpcb_gettime()&lt;/code&gt; パラメータで正しく &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; 。これは &lt;code&gt;&amp;amp;&lt;/code&gt; を介して行われるため、関数呼び出しは &lt;code&gt;rpcb_gettime(host, &amp;amp;timep)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="cd92600acf1aacb4bb45d3c98acc1cde89639e0e" translate="yes" xml:space="preserve">
          <source>That produces a new perl binary in the current directory with all extensions linked in that can be found in INST_ARCHLIB, SITELIBEXP, and PERL_ARCHLIB. To do that, MakeMaker writes a new Makefile, on UNIX, this is called</source>
          <target state="translated">これは、INST_ARCHLIB、SITELIBEXP、PERL_ARCHLIBにあるすべての拡張子がリンクされた新しいperlバイナリをカレントディレクトリに生成します。これを行うために、MakeMakerは新しいMakefileを書きます。</target>
        </trans-unit>
        <trans-unit id="2351c4ce268ed6ae21d8f1fadbceac3b965331bf" translate="yes" xml:space="preserve">
          <source>That said, &lt;code&gt;miniperl -Ilib -MConfig -we 1&lt;/code&gt; should report an error, because it can not find</source>
          <target state="translated">とは &lt;code&gt;miniperl -Ilib -MConfig -we 1&lt;/code&gt; 、miniperl -Ilib -MConfig -we 1はエラーを報告するはずです。</target>
        </trans-unit>
        <trans-unit id="55a11affd308eca30c6c076da831e9e75ab6c62b" translate="yes" xml:space="preserve">
          <source>That said, be aware that Perl version 5.14 introduces an exception to the rule, for syntactic convenience. Experimental array and hash container function behavior allows array and hash references to be handled by Perl as if they had been explicitly syntactically dereferenced. See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl5140delta.html#Syntactical-Enhancements&quot;&gt;Syntactical Enhancements in perl5140delta&lt;/a&gt; and &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for details.</source>
          <target state="translated">とはいえ、構文の便宜上、Perlバージョン5.14ではルールに例外が導入されていることに注意してください。実験的な配列およびハッシュコンテナ関数の動作により、配列およびハッシュ参照は、Perlによって、構文的に明示的に逆参照されているかのように処理できます。詳細について&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl5140delta.html#Syntactical-Enhancements&quot;&gt;は、perl5140delta&lt;/a&gt;および&lt;a href=&quot;perlfunc&quot;&gt;perlfuncの&lt;/a&gt;構文の拡張を参照してください。</target>
        </trans-unit>
        <trans-unit id="dd96836988cad318a9323c182f881952adb3274c" translate="yes" xml:space="preserve">
          <source>That said, there are a number of steps that can be taken to make life difficult for the potential cracker. The most important: Write your decryption filter in C and statically link the decryption module into the Perl binary. For further tips to make life difficult for the potential cracker, see the file</source>
          <target state="translated">そうは言っても、クラッカーの可能性のある人の生活を困難にするためには、いくつかのステップを踏む必要があります。最も重要なのは、復号化フィルタを C 言語で記述し、復号化モジュールを Perl バイナリに静的にリンクすることです。潜在的なクラッカーを困難にするためのヒントは、以下のファイルを参照してください。</target>
        </trans-unit>
        <trans-unit id="6ebc1959c7e697a446f0d0678eca3b28f8c37055" translate="yes" xml:space="preserve">
          <source>That said, there will always be small, focused, special-purpose languages dedicated to a specific problem domain that are simply more convenient for certain kinds of problems. Perl tries to be all things to all people, but nothing special to anyone. Examples of specialized languages that come to mind include prolog and matlab.</source>
          <target state="translated">つまり、ある特定の問題領域に特化した、小さな、焦点を絞った、特別な目的のための言語が常に存在し、それはある種の問題に対して単により便利です。Perlはすべての人にとってすべてのものになろうとしていますが、誰にとっても特別なものではありません。特殊な言語の例としては、prologやmatlabなどが挙げられます。</target>
        </trans-unit>
        <trans-unit id="e78afc53e325aea84cf9c7e198003b89094d500a" translate="yes" xml:space="preserve">
          <source>That same loop could be replaced with a slice operation:</source>
          <target state="translated">その同じループをスライス操作に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="c28091748ec2b3306715e341483bb158b9c0cd3f" translate="yes" xml:space="preserve">
          <source>That second argument may be either a &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt;'d regular expression (which is then used to match the terminator line), or a defined false value (which indicates that no terminator line should be looked for), or a reference to a hash (in which case the terminator is the value associated with the key &lt;code&gt;'terminator'&lt;/code&gt; .</source>
          <target state="translated">その2番目の引数は、 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt; 'd正規表現（ターミネーター行を照合するために使用される）、または定義されたfalse値（ターミネーター行を検索する必要がないことを示す）、またはハッシュへの参照（ターミネーターは、キー &lt;code&gt;'terminator'&lt;/code&gt; に関連付けられた値です。</target>
        </trans-unit>
        <trans-unit id="0abf2ef0e2b7f166486ede4264164097c7510116" translate="yes" xml:space="preserve">
          <source>That should be written:</source>
          <target state="translated">それは書かれているはずです。</target>
        </trans-unit>
        <trans-unit id="21e34acb57e36768d34631cec4d8c18d970f96ef" translate="yes" xml:space="preserve">
          <source>That should probably be written more simply as:</source>
          <target state="translated">それは、もっと簡単にこう書くべきでしょう。</target>
        </trans-unit>
        <trans-unit id="6c2b874251fc59b8ebf4af56444c528d2be2ade1" translate="yes" xml:space="preserve">
          <source>That shows the &lt;code&gt;UTF8&lt;/code&gt; flag in FLAGS and both the UTF-8 bytes and Unicode characters in &lt;code&gt;PV&lt;/code&gt; . See also later in this document the discussion about the &lt;code&gt;utf8::is_utf8()&lt;/code&gt; function.</source>
          <target state="translated">これは、FLAGS の &lt;code&gt;UTF8&lt;/code&gt; フラグと &lt;code&gt;PV&lt;/code&gt; の UTF-8バイトとUnicode文字の両方を示しています。このドキュメントの後半で、 &lt;code&gt;utf8::is_utf8()&lt;/code&gt; 関数についての説明も参照してください。</target>
        </trans-unit>
        <trans-unit id="032b01f3384ab611cdf4fd40994fa76549ad8c4f" translate="yes" xml:space="preserve">
          <source>That syntax simply won't work. It sets just &lt;code&gt;@a&lt;/code&gt; or &lt;code&gt;%a&lt;/code&gt; and clears the &lt;code&gt;@b&lt;/code&gt; or &lt;code&gt;%b&lt;/code&gt; . Plus the function didn't get passed into two separate arrays or hashes: it got one long list in &lt;code&gt;@_&lt;/code&gt; , as always.</source>
          <target state="translated">その構文は単に機能しません。 &lt;code&gt;@a&lt;/code&gt; または &lt;code&gt;%a&lt;/code&gt; のみを設定し、 &lt;code&gt;@b&lt;/code&gt; &lt;code&gt;%b&lt;/code&gt; または％bをクリアします。さらに、関数は2つの別々の配列またはハッシュに渡されませんでした。いつものように、 &lt;code&gt;@_&lt;/code&gt; に長いリストが1つあります。</target>
        </trans-unit>
        <trans-unit id="d7adc8c9bedd29857f8a7951c4ad397c707680f4" translate="yes" xml:space="preserve">
          <source>That temporarily undefs your record separator, and will automatically close the file at block exit. If the file is already open, just use this:</source>
          <target state="translated">これは一時的にレコードセパレータを解除し、ブロック終了時に自動的にファイルを閉じます。ファイルが既に開いている場合は、これを使用するだけです。</target>
        </trans-unit>
        <trans-unit id="e79dac633171d977159db125388db2bf16415ce0" translate="yes" xml:space="preserve">
          <source>That the fields are in a certain order</source>
          <target state="translated">フィールドが一定の順序であること</target>
        </trans-unit>
        <trans-unit id="5adec0092e434c8b7770e6ed721609aafb6fb0d1" translate="yes" xml:space="preserve">
          <source>That the sizeof(struct) or the alignments are the same everywhere</source>
          <target state="translated">構造体のサイズeof(sizeof)やアラインメントがどこでも同じであること</target>
        </trans-unit>
        <trans-unit id="ff9ccf09dc2dc150e284071ebd76e3a60583513f" translate="yes" xml:space="preserve">
          <source>That third argument tests the byte size of the data on the &lt;code&gt;$fh&lt;/code&gt; filehandle and reads that many bytes into the buffer &lt;code&gt;$var&lt;/code&gt; .</source>
          <target state="translated">3番目の引数は、 &lt;code&gt;$fh&lt;/code&gt; ファイルハンドルのデータのバイトサイズをテストし、そのバイト数をバッファー &lt;code&gt;$var&lt;/code&gt; 読み取ります。</target>
        </trans-unit>
        <trans-unit id="f38824e1c7c399bcd876c5d796e89f3c65e609e8" translate="yes" xml:space="preserve">
          <source>That will efficiently match a nonempty group with matching parentheses two levels deep or less. However, if there is no such group, it will take virtually forever on a long string. That's because there are so many different ways to split a long string into several substrings. This is what &lt;code&gt;(.+)+&lt;/code&gt; is doing, and &lt;code&gt;(.+)+&lt;/code&gt; is similar to a subpattern of the above pattern. Consider how the pattern above detects no-match on &lt;code&gt;((()aaaaaaaaaaaaaaaaaa&lt;/code&gt; in several seconds, but that each extra letter doubles this time. This exponential performance will make it appear that your program has hung. However, a tiny change to this pattern</source>
          <target state="translated">これは、2レベル以下の括弧で対応する空でないグループを効率的に照合します。ただし、そのようなグループがない場合、長い文字列では事実上永遠にかかります。これは、長い文字列をいくつかの部分文字列に分割する方法が数多くあるためです。これは &lt;code&gt;(.+)+&lt;/code&gt; が行っていることであり、 &lt;code&gt;(.+)+&lt;/code&gt; は上記のパターンのサブパターンに似ています。上記のパターンが &lt;code&gt;((()aaaaaaaaaaaaaaaaaa&lt;/code&gt; で数秒で一致しないことを検出するが、今回は余分な文字がそれぞれ2倍になることを検出します。この指数関数的なパフォーマンスにより、プログラムがハングしたように見えます。ただし、このパターンへの小さな変更</target>
        </trans-unit>
        <trans-unit id="d2c33811186783297750533407ae69a2c30dbe1c" translate="yes" xml:space="preserve">
          <source>That will print out &lt;code&gt;20&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt; .</source>
          <target state="translated">これは、プリントアウトします &lt;code&gt;20&lt;/code&gt; と &lt;code&gt;10&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="844b1a95e3bd3c94e0935eae872c27cb6a3ae275" translate="yes" xml:space="preserve">
          <source>That will print out:</source>
          <target state="translated">それがプリントアウトされます。</target>
        </trans-unit>
        <trans-unit id="3d6db72df23e281596a803d5b93d6efaedb2438e" translate="yes" xml:space="preserve">
          <source>That will run the script &lt;b&gt;myprogram&lt;/b&gt; without human intervention, printing out the call tree with entry and exit points. Note that &lt;code&gt;NonStop=1 frame=2&lt;/code&gt; is equivalent to &lt;code&gt;N f=2&lt;/code&gt; , and that originally, options could be uniquely abbreviated by the first letter (modulo the &lt;code&gt;Dump*&lt;/code&gt; options). It is nevertheless recommended that you always spell them out in full for legibility and future compatibility.</source>
          <target state="translated">これにより、人間の介入なしにスクリプト&lt;b&gt;myprogram&lt;/b&gt;が実行され、エントリポイントと終了ポイントを含むコールツリーが出力されます。 &lt;code&gt;NonStop=1 frame=2&lt;/code&gt; は &lt;code&gt;N f=2&lt;/code&gt; = 2と同等であり、最初はオプションが最初の文字（ &lt;code&gt;Dump*&lt;/code&gt; オプションを法とする）によって一意に省略できることに注意してください。それにもかかわらず、読みやすさと将来の互換性のために、常に完全な形でそれらを綴ることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d06ee710fae521075f5d16e4386c06facdb36dbc" translate="yes" xml:space="preserve">
          <source>That won't work at all, because &lt;code&gt;.*&lt;/code&gt; was greedy and gobbled up the whole string. As &lt;code&gt;\d*&lt;/code&gt; can match on an empty string the complete regular expression matched successfully.</source>
          <target state="translated">&lt;code&gt;.*&lt;/code&gt; は貪欲で文字列全体を食い尽くしたため、これはまったく機能しません。 &lt;code&gt;\d*&lt;/code&gt; 完全な正規表現がうまくマッチした空の文字列に一致させることができます。</target>
        </trans-unit>
        <trans-unit id="025065d41f91f68021f87b4bc88af80b714297bb" translate="yes" xml:space="preserve">
          <source>That's a bit better, but we still have that last column which needs to be moved further over. There's an easy way to fix this up: unfortunately, we can't get &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; to right-justify our fields, but we can get &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; to do it:</source>
          <target state="translated">それは少し良いですが、まだ最後に移動する必要がある最後の列があります。これを修正する簡単な方法があります。残念ながら、フィールドを右揃えにする &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; を取得できませんが、 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; でそれを実行できます。</target>
        </trans-unit>
        <trans-unit id="85ac81e130e91631a9d78d2d6a68196fcf7146e7" translate="yes" xml:space="preserve">
          <source>That's about all there is to it. Actually, it's more than all there is to it, because we've done a few nice things here for the sake of completeness, robustness, and general aesthetics. Simpler TIESCALAR classes are certainly possible.</source>
          <target state="translated">これがその全てです。実際には、完全性、堅牢性、一般的な美学のためにいくつかの良いことをしてきたので、それ以上のことがあります。よりシンプルな TIESCALARAR クラスは確かに可能です。</target>
        </trans-unit>
        <trans-unit id="eb3acd01c2e3336fdfd272a108c9af206f049bc1" translate="yes" xml:space="preserve">
          <source>That's all that's strictly necessary. There's additional files you might want:</source>
          <target state="translated">厳密にはそれだけです。追加で必要なファイルがあります</target>
        </trans-unit>
        <trans-unit id="f4b60ee9e69236a73adb2c3c53252dab7254d2c9" translate="yes" xml:space="preserve">
          <source>That's all well and good for declaration of a fixed data structure, but what if you wanted to add new elements on the fly, or build it up entirely from scratch?</source>
          <target state="translated">固定データ構造体の宣言はそれでいいのですが、新しい要素をその場で追加したり、ゼロから構築したりしたいとしたらどうでしょうか?</target>
        </trans-unit>
        <trans-unit id="10d195eb40678f2e435ff6368a25ea9770d7ae62" translate="yes" xml:space="preserve">
          <source>That's all you need to do on Unix systems with dynamic linking. Most Unix systems have dynamic linking. If yours doesn't, or if for another reason you have a statically-linked perl, &lt;b&gt;and&lt;/b&gt; the module requires compilation, you'll need to build a new Perl binary that includes the module. Again, you'll probably need to be root.</source>
          <target state="translated">これが、動的リンクを使用するUnixシステムで実行する必要があるすべてです。ほとんどのUnixシステムには動的リンクがあります。そうでない場合、または別の理由で静的にリンクされたperlが&lt;b&gt;あり&lt;/b&gt;、モジュールがコンパイルを必要とする場合は、モジュールを含む新しいPerlバイナリをビルドする必要があります。繰り返しますが、おそらくrootになる必要があります。</target>
        </trans-unit>
        <trans-unit id="a00ede3b70bdf4862c08ec2dce8548cbf40dc38c" translate="yes" xml:space="preserve">
          <source>That's all. Similarly for ncftp or ftp, you would configure something like</source>
          <target state="translated">これだけです。ncftp や ftp の場合も同様に、以下のように設定します。</target>
        </trans-unit>
        <trans-unit id="6a90902fefb78efc91bb4045efc7ccd96cd2b158" translate="yes" xml:space="preserve">
          <source>That's autovivification. You can get around this in a few ways. The easiest way is to just turn it off. The lexical &lt;code&gt;autovivification&lt;/code&gt; pragma is available on CPAN. Now you don't add to the hash:</source>
          <target state="translated">それが自動活性化です。いくつかの方法でこれを回避できます。最も簡単な方法は、単にオフにすることです。字句の &lt;code&gt;autovivification&lt;/code&gt; プラグマはCPANで入手できます。今、あなたはハッシュに追加しません：</target>
        </trans-unit>
        <trans-unit id="9f49d51a5d99f95a36f28eae4b0601a8a32ea05a" translate="yes" xml:space="preserve">
          <source>That's because &lt;code&gt;.*&lt;/code&gt; was greedy, so you get everything between the</source>
          <target state="translated">これは、 &lt;code&gt;.*&lt;/code&gt; が貪欲だったため、</target>
        </trans-unit>
        <trans-unit id="1b898ba735cd15a6bd993ec3d75a6b0058359915" translate="yes" xml:space="preserve">
          <source>That's because Perl doesn't (ever) implicitly dereference your variables. If you want to get at the thing a reference is referring to, then you have to do this yourself using either prefix typing indicators, like &lt;code&gt;${$blah}&lt;/code&gt; , &lt;code&gt;@{$blah}&lt;/code&gt; , &lt;code&gt;@{$blah[$i]}&lt;/code&gt; , or else postfix pointer arrows, like &lt;code&gt;$a-&amp;gt;[3]&lt;/code&gt; , &lt;code&gt;$h-&amp;gt;{fred}&lt;/code&gt; , or even &lt;code&gt;$ob-&amp;gt;method()-&amp;gt;[3]&lt;/code&gt; .</source>
          <target state="translated">これは、Perlが（常に）暗黙的に変数を逆参照しないためです。参照が参照していることを知りたい場合は、 &lt;code&gt;${$blah}&lt;/code&gt; 、 &lt;code&gt;@{$blah}&lt;/code&gt; 、 &lt;code&gt;@{$blah[$i]}&lt;/code&gt; ような接頭辞タイピングインジケーターを使用して自分で行う必要があります。または、 &lt;code&gt;$h-&amp;gt;{fred}&lt;/code&gt; &lt;code&gt;$a-&amp;gt;[3]&lt;/code&gt; 、$ h-&amp;gt; {fred}、または &lt;code&gt;$ob-&amp;gt;method()-&amp;gt;[3]&lt;/code&gt; ような後置ポインタ矢印。</target>
        </trans-unit>
        <trans-unit id="07d4ba2bfdf5f5b21a00717fd39047d39da3c192" translate="yes" xml:space="preserve">
          <source>That's because Perl's precedence rules on its five prefix dereferencers (which look like someone swearing: &lt;code&gt;$ @ * % &amp;amp;&lt;/code&gt; ) make them bind more tightly than the postfix subscripting brackets or braces! This will no doubt come as a great shock to the C or C++ programmer, who is quite accustomed to using &lt;code&gt;*a[i]&lt;/code&gt; to mean what's pointed to by the</source>
          <target state="translated">これは、Perlの5つの接頭辞逆参照子（だれかが言っているように見える： &lt;code&gt;$ @ * % &amp;amp;&lt;/code&gt; ）の優先規則により、接尾辞の添え字の大括弧や中括弧よりも強く結合するためです。これは間違いなく、 &lt;code&gt;*a[i]&lt;/code&gt; を使用して何が指しているのかを意味することに慣れているCまたはC ++プログラマにとって大きな衝撃となるでしょう。</target>
        </trans-unit>
        <trans-unit id="0f393c4bb027f44afad135cf4530852dabaa1d38" translate="yes" xml:space="preserve">
          <source>That's because it treats &lt;code&gt;$fh&lt;/code&gt; as a string like &lt;code&gt;&quot;IO::Handle=GLOB(0x8039e0)&quot;&lt;/code&gt; , then pattern matches against that.</source>
          <target state="translated">これは、 &lt;code&gt;$fh&lt;/code&gt; を &lt;code&gt;&quot;IO::Handle=GLOB(0x8039e0)&quot;&lt;/code&gt; ような文字列として扱い、それに対してパターンが一致するためです。</target>
        </trans-unit>
        <trans-unit id="5ef987861945b1d2e7a185649ce3d062e04bb5bf" translate="yes" xml:space="preserve">
          <source>That's because my() is more of a run-time statement than it is a compile-time declaration</source>
          <target state="translated">これは my()がコンパイル時の宣言というよりも実行時の宣言だからです。</target>
        </trans-unit>
        <trans-unit id="62587e053e8900b6dd6dfce6fa04010b4761573b" translate="yes" xml:space="preserve">
          <source>That's certainly better, but we still have to know how long all the integers are, and portability is far away. Rather than &lt;code&gt;2&lt;/code&gt; , for instance, we want to say &quot;however long a short is&quot;. But this can be done by enclosing the appropriate pack code in brackets: &lt;code&gt;[s]&lt;/code&gt;. So, here's the very best we can do:</source>
          <target state="translated">それは確かに優れていますが、すべての整数がどれくらいの長さであるかを知る必要があり、移植性は遠く離れています。たとえば &lt;code&gt;2&lt;/code&gt; ではなく、「ショートの長さはどれくらいか」と言いたいです。ただし、これは適切なパックコードを角かっこで囲むことで実行できます： &lt;code&gt;[s]&lt;/code&gt; 。だから、これが私たちができる最高のことです：</target>
        </trans-unit>
        <trans-unit id="0971c7f378d8883abc6949fc548118faa7827c21" translate="yes" xml:space="preserve">
          <source>That's faster, cleaner, and safer than the previous approach. Of course, you don't need to use a dollar sign. You could use your own scheme to make it less confusing, like bracketed percent symbols, etc.</source>
          <target state="translated">その方が、今までのやり方よりも早くて、きれいで、安全です。もちろん、ドル記号を使う必要はありません。括弧付きのパーセント記号など、混乱を避けるために独自のスキームを使用することができます。</target>
        </trans-unit>
        <trans-unit id="c29a101730c3253b24f4d81e9d501b9e43d3a5b6" translate="yes" xml:space="preserve">
          <source>That's fine for Internet-domain clients and servers, but what about local communications? While you can use the same setup, sometimes you don't want to. Unix-domain sockets are local to the current host, and are often used internally to implement pipes. Unlike Internet domain sockets, Unix domain sockets can show up in the file system with an ls(1) listing.</source>
          <target state="translated">インターネットドメインのクライアントやサーバではそれでいいのですが、ローカル通信ではどうでしょうか?同じ設定を使うことはできますが、時には使いたくないこともあるでしょう。Unix ドメインソケットは現在のホストにローカルであり、パイプを実装するために内部的に使用されることがよくあります。インターネットのドメインソケットとは異なり、Unix ドメインソケットはファイルシステムに ls(1)のリストで表示されます。</target>
        </trans-unit>
        <trans-unit id="931aa8f88f4f387e1b11a09a91636eb5c2525c4d" translate="yes" xml:space="preserve">
          <source>That's how Perl parsed the program, from top to bottom:</source>
          <target state="translated">これがPerlがプログラムを上から下まで解析した方法です。</target>
        </trans-unit>
        <trans-unit id="8a9ad9d817fc65f643335d0c0e239182a33f908e" translate="yes" xml:space="preserve">
          <source>That's how it works. It's pretty simple; as with many Perl programs, the explanation is much longer than the program.</source>
          <target state="translated">これがその仕組みです。これは非常に簡単で、多くのPerlプログラムと同様に、説明はプログラムよりもはるかに長くなります。</target>
        </trans-unit>
        <trans-unit id="a4ec64876254c2b08386415f463aa4c3731a3571" translate="yes" xml:space="preserve">
          <source>That's how the &lt;code&gt;*PL_keyword_plugin&lt;/code&gt; function needs to behave overall. Conventionally, however, one does not completely replace the existing handler function. Instead, take a copy of &lt;code&gt;PL_keyword_plugin&lt;/code&gt; before assigning your own function pointer to it. Your handler function should look for keywords that it is interested in and handle those. Where it is not interested, it should call the saved plugin function, passing on the arguments it received. Thus &lt;code&gt;PL_keyword_plugin&lt;/code&gt; actually points at a chain of handler functions, all of which have an opportunity to handle keywords, and only the last function in the chain (built into the Perl core) will normally return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;*PL_keyword_plugin&lt;/code&gt; 関数が全体的に動作する必要がある方法です。しかし、従来は、既存のハンドラー関数を完全に置き換えるものではありませんでした。代わりに、独自の関数ポインタを割り当てる前に、 &lt;code&gt;PL_keyword_plugin&lt;/code&gt; のコピーを作成してください。ハンドラー関数は、関心のあるキーワードを探し、それらを処理する必要があります。興味がない場合は、保存されたプラグイン関数を呼び出して、受け取った引数を渡します。したがって、 &lt;code&gt;PL_keyword_plugin&lt;/code&gt; は実際にはキーワードを処理する機会を持つハンドラー関数のチェーンを指し、チェーンの最後の関数（Perlコアに組み込まれている）のみが通常 &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="417bb675fe45cc9c0d3fa87fb632598764e6a64d" translate="yes" xml:space="preserve">
          <source>That's it for creating references. By now you're probably dying to know how to use references to get back to your long-lost data. There are several basic methods.</source>
          <target state="translated">リファレンスの作成は以上です。今頃になって、あなたはリファレンスの使い方を知りたくてたまらなくなっているでしょう。基本的な方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="e93f4cf2c16977aa0828b84202ee64df60519c65" translate="yes" xml:space="preserve">
          <source>That's it!</source>
          <target state="translated">それだ!</target>
        </trans-unit>
        <trans-unit id="4ad43787f3a61735da906162ae4566f1716a8e9d" translate="yes" xml:space="preserve">
          <source>That's it, you're back on home turf again.</source>
          <target state="translated">そうだ、またホームグラウンドに戻ってきたんだな。</target>
        </trans-unit>
        <trans-unit id="ad818b8edee0b9dd293a16c07bd537675f5226f7" translate="yes" xml:space="preserve">
          <source>That's just the simple case of assigning an array to a scalar and getting its element count. If that's what you really and truly want, then you might do well to consider being a tad more explicit about it, like this:</source>
          <target state="translated">これは、スカラに配列を代入してその要素数を取得するだけの単純なケースです。もしそれが本当に欲しいものであれば、以下のようにもう少し明示的にした方がいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="64d9d2742b71e9220af551f7c7046f7f081af6aa" translate="yes" xml:space="preserve">
          <source>That's not much help, a couple of welcomes in there, but no indication of which are keys, and which are values, it's just a listed array dump and, in this case, not particularly helpful. The trick here, is to use a &lt;b&gt;reference&lt;/b&gt; to the data structure:</source>
          <target state="translated">それはあまり役に立ちませんが、そこにはいくつかの歓迎がありますが、どれがキーでどれが値であるかは示されていません。これはリストされた配列ダンプであり、この場合は特に役に立ちません。ここでの秘訣は、データ構造への&lt;b&gt;参照&lt;/b&gt;を使用すること&lt;b&gt;です&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="33e7ab43a8b3ad63335115c42e08832229acf410" translate="yes" xml:space="preserve">
          <source>That's not particularly efficient. It would be more space-efficient to use:</source>
          <target state="translated">それは特に効率的ではありません。使った方がスペース的にも効率がいいだろう。</target>
        </trans-unit>
        <trans-unit id="69885b7848b259e032939450164926f255956e80" translate="yes" xml:space="preserve">
          <source>That's pretty much it. Now write</source>
          <target state="translated">それはそれはかなりのものです。では、次のように書きます。</target>
        </trans-unit>
        <trans-unit id="0e0f898332e33495bcec31fc5e9658f137da2c67" translate="yes" xml:space="preserve">
          <source>That's probably because you forgot libraries, or library paths differ. You really should build the whole distribution on the machine it will eventually live on, and then type &lt;code&gt;make install&lt;/code&gt; . Most other approaches are doomed to failure.</source>
          <target state="translated">ライブラリを忘れたか、ライブラリパスが異なるためと考えられます。ディストリビューション全体を、最終的にはそのマシンが存在するマシンでビルドしてから、 &lt;code&gt;make install&lt;/code&gt; と入力する必要があります。他のほとんどのアプローチは失敗する運命にあります。</target>
        </trans-unit>
        <trans-unit id="a1f563351f204013afa271606ba9bd745aa56dda" translate="yes" xml:space="preserve">
          <source>That's shown below, in a program I'll call</source>
          <target state="translated">これは以下のようなプログラムで、私が</target>
        </trans-unit>
        <trans-unit id="651cfe39b8f69bca0fd98eae5d4edf4fd6370a67" translate="yes" xml:space="preserve">
          <source>That's where the glue code can be inserted to create the initial contact between Perl and linked C/C++ routines. Let's take a look some pieces of</source>
          <target state="translated">そこにグルーコードを挿入して、PerlとリンクされたC/C++ルーチンの間の初期接点を作ることができます。ここでは、Perl とリンクされた C/C++ルーチンの間の初期接触を作成するために</target>
        </trans-unit>
        <trans-unit id="9608b4f77e4cb870b25879f8aef6ee06bf6a1b9f" translate="yes" xml:space="preserve">
          <source>That's why &lt;code&gt;STORABLE_freeze&lt;/code&gt; lets you provide a list of references to serialize. The engine guarantees that those will be serialized in the same context as the other objects, and therefore that shared objects will stay shared.</source>
          <target state="translated">これが、 &lt;code&gt;STORABLE_freeze&lt;/code&gt; でシリアル化する参照のリストを提供できる理由です。エンジンは、それらが他のオブジェクトと同じコンテキストでシリアル化されることを保証します。したがって、共有オブジェクトは共有されたままになります。</target>
        </trans-unit>
        <trans-unit id="735b594fd42209c8688db3bd34982beb910ab493" translate="yes" xml:space="preserve">
          <source>That's why they're called 'options'.</source>
          <target state="translated">だから「オプション」と呼ばれているのです。</target>
        </trans-unit>
        <trans-unit id="8301b3f815f17c3dd7076e96039e1678841b82a4" translate="yes" xml:space="preserve">
          <source>Thatclassname</source>
          <target state="translated">Thatclassname</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="6f203dc849e9f4f723b6a77e413f463ccf14a492" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; above stands for some two digit Unicode version number, such as &lt;code&gt;1.1&lt;/code&gt; or &lt;code&gt;4.0&lt;/code&gt; ; or the &quot;*&quot; can also be &lt;code&gt;Unassigned&lt;/code&gt; . This property will match the code points whose final disposition has been settled as of the Unicode release given by the version number; &lt;code&gt;\p{Present_In: Unassigned}&lt;/code&gt; will match those code points whose meaning has yet to be assigned.</source>
          <target state="translated">上記の「*」は、 &lt;code&gt;1.1&lt;/code&gt; や &lt;code&gt;4.0&lt;/code&gt; などの2桁のUnicodeバージョン番号を表します。または「*」を &lt;code&gt;Unassigned&lt;/code&gt; にすることもできます。このプロパティは、バージョン番号で指定されたUnicodeリリースの時点で最終処分が解決されているコードポイントと一致します。 &lt;code&gt;\p{Present_In: Unassigned}&lt;/code&gt; は、まだ意味が割り当てられていないコードポイントと一致します。</target>
        </trans-unit>
        <trans-unit id="a22d3668e744bc1f40c2f7d6bd90a8803737c69c" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; character will be replaced with the complete input filename.</source>
          <target state="translated">という文字は、完全な入力ファイル名に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="3b9595dacd7d80fdab60d4dc5871376b0675fb8c" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; quantifier is equivalent to &lt;code&gt;{0,}&lt;/code&gt; , the &quot;+&quot; quantifier to &lt;code&gt;{1,}&lt;/code&gt; , and the &quot;?&quot; quantifier to &lt;code&gt;{0,1}&lt;/code&gt; . n and m are limited to non-negative integral values less than a preset limit defined when perl is built. This is usually 32766 on the most common platforms. The actual limit can be seen in the error message generated by code such as this:</source>
          <target state="translated">「*」数量詞は &lt;code&gt;{0,}&lt;/code&gt; と、「+」数量詞は &lt;code&gt;{1,}&lt;/code&gt; と、「？」と同等です。 &lt;code&gt;{0,1}&lt;/code&gt; への数量詞。nとmは、perlのビルド時に定義された事前設定の制限未満の非負の整数値に制限されます。これは通常、最も一般的なプラットフォームでは32766です。実際の制限は、次のようなコードによって生成されるエラーメッセージで確認できます。</target>
        </trans-unit>
        <trans-unit id="ef1a900f188939b7338bcc6047d7f99f423bcf86" translate="yes" xml:space="preserve">
          <source>The &quot;:&quot; on these identifiers means simply &quot;process this stuff normally, even though the result will be for some special target&quot;. I suggest that parser APIs report &quot;biblio&quot; as the target identifier, but also report that it had a &quot;:&quot; prefix. (And similarly, with the above &quot;html&quot;, report &quot;html&quot; as the target identifier, and note the</source>
          <target state="translated">これらの識別子の&quot;:&quot;は、単純に「結果は何か特別なターゲットのためのものになりますが、普通に処理してください」という意味になります。パーサAPIでは、ターゲット識別子として &quot;biblio &quot;を報告するだけでなく、&quot;:&quot;が接頭辞として付いていたことを報告することを提案します(同様に、上記の &quot;html &quot;では、ターゲット識別子として &quot;html &quot;を報告し、&quot;:&quot;が付いていたことを報告するようにします)。(同様に、上記の &quot;html &quot;についても、ターゲット識別子として &quot;html &quot;を報告し、その際に</target>
        </trans-unit>
        <trans-unit id="64b5d9da126d3d99727eec1708f648b1bd4f7983" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;rules&lt;/code&gt; &quot; data structure is the the heart of the scheduler. It allows you to express simple rules like &quot;run all tests in sequence&quot; or &quot;run all tests in parallel except these five tests.&quot;. However, the rules structure also supports glob-style pattern matching and recursive definitions, so you can also express arbitarily complicated patterns.</source>
          <target state="translated">「 &lt;code&gt;rules&lt;/code&gt; 」データ構造は、スケジューラの中心です。「すべてのテストを順番に実行する」または「これらの5つのテストを除くすべてのテストを並行して実行する」のような単純なルールを表現できます。ただし、ルール構造はglobスタイルのパターンマッチングと再帰的な定義もサポートしているため、任意に複雑なパターンを表現することもできます。</target>
        </trans-unit>
        <trans-unit id="1074d5a9a7dcd2040a3f0c45e46a4676237c27c8" translate="yes" xml:space="preserve">
          <source>The &quot;=begin</source>
          <target state="translated">は、「=begin</target>
        </trans-unit>
        <trans-unit id="15a448a46373702e33d38bd4498490c44fd2b70f" translate="yes" xml:space="preserve">
          <source>The &quot;=item [text]&quot; paragraph should not match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\*\s*\z/&lt;/a&gt;&lt;/code&gt;, nor should it match just &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s*\z/&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&quot;= item [text]&quot;段落は &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\*\s*\z/&lt;/a&gt;&lt;/code&gt; と一致してはならず、 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s*\z/&lt;/a&gt;&lt;/code&gt; とのみ一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="66cea2af4ab6ab309f2a49ef717323c3929bef20" translate="yes" xml:space="preserve">
          <source>The &quot;=pod&quot; command by itself doesn't do much of anything, but it signals to Perl (and Pod formatters) that a Pod block starts here. A Pod block starts with</source>
          <target state="translated">pod &quot;コマンドはそれ自体は何もしませんが、Perl (とPodフォーマッタ)にPodブロックがここから始まることを知らせています。Podブロックは</target>
        </trans-unit>
        <trans-unit id="45c9bcf242eeaf20585053facd6dddbfcd2e77f0" translate="yes" xml:space="preserve">
          <source>The &quot;English&quot; operators (&lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;xor&lt;/code&gt; , and &lt;code&gt;not&lt;/code&gt; ) deliberately have precedence lower than that of list operators for just such situations as the one above.</source>
          <target state="translated">&quot;English&quot;演算子（ &lt;code&gt;and&lt;/code&gt; 、 &lt;code&gt;or&lt;/code&gt; 、 &lt;code&gt;xor&lt;/code&gt; 、および &lt;code&gt;not&lt;/code&gt; ）は、上記のような状況の場合のみ、意図的にリスト演算子よりも優先されます。</target>
        </trans-unit>
        <trans-unit id="00c4bf3828130bdd16f6f681093f66656168cc64" translate="yes" xml:space="preserve">
          <source>The &quot;MIT&quot; License</source>
          <target state="translated">MIT」ライセンス</target>
        </trans-unit>
        <trans-unit id="f6804bf4d1b752ec09b4b554040a4294aa2c28e2" translate="yes" xml:space="preserve">
          <source>The &quot;U&quot; mode is modeled on Python's &quot;Universal Newlines&quot; concept, whereby DOS and Mac OS line terminators are converted internally to UNIX newlines before processing. This ensures consistent digest values when working simultaneously across multiple file systems. &lt;b&gt;The &quot;U&quot; mode influences only text files&lt;/b&gt;, namely those passing Perl's</source>
          <target state="translated">&quot;U&quot;モードはPythonの &quot;Universal Newlines&quot;コンセプトに基づいてモデル化されており、DOSおよびMac OSの行末記号は処理前に内部でUNIX改行に変換されます。これにより、複数のファイルシステムで同時に作業するときに、一貫したダイジェスト値が保証されます。&lt;b&gt;「U」モードはテキストファイル&lt;/b&gt;、つまりPerlを渡す&lt;b&gt;ファイル&lt;/b&gt;に&lt;b&gt;のみ影響します&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3825414166fcae7ca1f01fa808eb7b2edebcc1b6" translate="yes" xml:space="preserve">
          <source>The &quot;Unicode Bug&quot;</source>
          <target state="translated">&quot;Unicodeのバグ&quot;</target>
        </trans-unit>
        <trans-unit id="0ec3a96aade5dbc6ee323c533eb4507821e58ebe" translate="yes" xml:space="preserve">
          <source>The &quot;access&quot; sub-pragma</source>
          <target state="translated">アクセス」サブプラグマ</target>
        </trans-unit>
        <trans-unit id="c5bfb037ae6662a8b7a6614931ff100518e1954f" translate="yes" xml:space="preserve">
          <source>The &quot;bad interpreter&quot; message comes from the shell, not perl. The actual message may vary depending on your platform, shell, and locale settings.</source>
          <target state="translated">&quot;bad interpreter&quot; メッセージは、Perl ではなくシェルから来ています。実際のメッセージは、プラットフォーム、シェル、ロケールの設定によって異なるかもしれません。</target>
        </trans-unit>
        <trans-unit id="7324c65fe364cafe1f0b648f9b09ee839b62c197" translate="yes" xml:space="preserve">
          <source>The &quot;else if&quot; keyword is spelled &lt;code&gt;elsif&lt;/code&gt; in Perl. There's no &lt;code&gt;elif&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;else&quot;&gt;else&lt;/a&gt; &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;&lt;/code&gt; either. It does parse &lt;code&gt;&lt;a href=&quot;elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt;, but only to warn you about not using it.</source>
          <target state="translated">「else if」キーワードは、Perlでは &lt;code&gt;elsif&lt;/code&gt; と綴られています。 &lt;code&gt;elif&lt;/code&gt; も &lt;code&gt;&lt;a href=&quot;else&quot;&gt;else&lt;/a&gt; &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;&lt;/code&gt; elseもありません。 &lt;code&gt;&lt;a href=&quot;elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt; を解析しますが、使用しないことを警告するだけです。</target>
        </trans-unit>
        <trans-unit id="dcec7b786aaf98a8eb4d77d89e7fe0ef405e7fc1" translate="yes" xml:space="preserve">
          <source>The &quot;else if&quot; keyword is spelled &lt;code&gt;elsif&lt;/code&gt; in Perl. There's no &lt;code&gt;elif&lt;/code&gt; or &lt;code&gt;else if&lt;/code&gt; either. It does parse &lt;code&gt;&lt;a href=&quot;functions/elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt;, but only to warn you about not using it.</source>
          <target state="translated">「else if」キーワードは、Perlでは &lt;code&gt;elsif&lt;/code&gt; と綴られています。 &lt;code&gt;elif&lt;/code&gt; も &lt;code&gt;else if&lt;/code&gt; ありません。 &lt;code&gt;&lt;a href=&quot;functions/elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt; を解析しますが、使用しないことを警告するだけです。</target>
        </trans-unit>
        <trans-unit id="de0a3bbed813bc00b5b829d702e3237f3e106a1b" translate="yes" xml:space="preserve">
          <source>The &quot;fail&quot; attribute can be accessed with the &lt;code&gt;fail_with&lt;/code&gt; method:</source>
          <target state="translated">「fail」属性には、 &lt;code&gt;fail_with&lt;/code&gt; メソッドでアクセスできます。</target>
        </trans-unit>
        <trans-unit id="3cfcc407b9b43637eb6bd977679586bbeebf2328" translate="yes" xml:space="preserve">
          <source>The &quot;grab all you can, and do not give anything back&quot; semantic is desirable in many situations where on the first sight a simple &lt;code&gt;()*&lt;/code&gt; looks like the correct solution. Suppose we parse text with comments being delimited by &lt;code&gt;#&lt;/code&gt; followed by some optional (horizontal) whitespace. Contrary to its appearance, &lt;code&gt;#[ \t]*&lt;/code&gt;</source>
          <target state="translated">一目見ただけで単純な &lt;code&gt;()*&lt;/code&gt; が正しい解決策のように見える多くの状況では、「できる限り手に入れ、何も返さない」というセマンティクスが望ましいです。 &lt;code&gt;#&lt;/code&gt; で区切られたコメントとそれに続くオプションの（水平）空白でテキストを解析するとします。外観とは逆に、 &lt;code&gt;#[ \t]*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a64504831dda4d8442cac5969f1512970ea2ab8e" translate="yes" xml:space="preserve">
          <source>The &quot;in most cases&quot; hedge is because local TCP state machine behavior may depend on the peer's socket options. In particular, if the peer socket has SO_LINGER enabled with a zero timeout, then the peer's close() will generate a RST segment, upon receipt of which the local TCP transitions immediately to &lt;b&gt;CLOSED&lt;/b&gt;, and in that state, connected()</source>
          <target state="translated">「ほとんどの場合」ヘッジは、ローカルTCPステートマシンの動作がピアのソケットオプションに依存する可能性があるためです。特に、ピアソケットのSO_LINGERがゼロタイムアウトで有効になっている場合、ピアのclose（）はRSTセグメントを生成します。これを受信すると、ローカルTCPはすぐに&lt;b&gt;CLOSED&lt;/b&gt;に移行し、その状態では、connected（）になります。</target>
        </trans-unit>
        <trans-unit id="97ff934381d4470548d727908956bd70f3d20831" translate="yes" xml:space="preserve">
          <source>The &quot;inode change timestamp&quot; (the &lt;code&gt;-C&lt;/code&gt; filetest) may really be the &quot;creation timestamp&quot; (which it is not in Unix).</source>
          <target state="translated">「inode変更タイムスタンプ」（ &lt;code&gt;-C&lt;/code&gt; ファイルテスト）は、実際には「作成タイムスタンプ」（UNIXにはありません）である場合があります。</target>
        </trans-unit>
        <trans-unit id="d5dae6e25029009f346d93a94005c0b2df86ea03" translate="yes" xml:space="preserve">
          <source>The &quot;interpreter-based threads&quot; provided by Perl are not the fast, lightweight system for multitasking that one might expect or hope for. Threads are implemented in a way that make them easy to misuse. Few people know how to use them correctly or will be able to provide help.</source>
          <target state="translated">Perl が提供する「インタプリタベースのスレッド」は、マルチタスクのための高速で軽量なシステムではありません。スレッドは悪用しやすいように実装されています。スレッドの正しい使い方を知っている人はほとんどいませんし、ヘルプを提供してくれる人もいません。</target>
        </trans-unit>
        <trans-unit id="611cc4fe5613cabb6ac2b4cb6c84bf4897881a2a" translate="yes" xml:space="preserve">
          <source>The &quot;like&quot; code entry is not always an exact rendition. For example, the smartmatch operator short-circuits whenever possible, but &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; does not. Also, &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in scalar context returns the number of matches, but &lt;code&gt;~~&lt;/code&gt; returns only true or false.</source>
          <target state="translated">「like」コードのエントリは、必ずしも正確な表現ではありません。たとえば、smartmatch演算子は可能な限り短絡しますが、 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; は短絡しません。また、スカラーコンテキストの &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; は一致の数を返しますが、 &lt;code&gt;~~&lt;/code&gt; はtrueまたはfalseのみを返します。</target>
        </trans-unit>
        <trans-unit id="812d0b36924ed8327e26e7bd66db9f34693b1e0d" translate="yes" xml:space="preserve">
          <source>The &quot;locked&quot; attribute is deprecated, and has no effect in 5.10.0 and later. It was used as part of the now-removed &quot;Perl 5.005 threads&quot;.</source>
          <target state="translated">locked&quot; 属性は非推奨で、5.10.0 以降では効果がありません。これは、現在は削除された &quot;Perl 5.005 threads &quot;の一部として使用されていました。</target>
        </trans-unit>
        <trans-unit id="9dcce4d393c04df7e129e843600a4cbb41352ba2" translate="yes" xml:space="preserve">
          <source>The &quot;make test&quot; step runs a Perl Verification Procedure, usually before installation. You might encounter STDERR messages even during a successful run of &quot;make test&quot;. Here is a guide to some of the more commonly seen anomalies:</source>
          <target state="translated">make test &quot;ステップは、通常はインストールの前にPerlの検証手順を実行します。make test &quot;が正常に実行されていても、STDERRメッセージが表示されることがあります。ここでは、より一般的に見られるいくつかの異常について説明します。</target>
        </trans-unit>
        <trans-unit id="c90503a55170e15efc4d9ae431c0e36ee6a25e33" translate="yes" xml:space="preserve">
          <source>The &quot;maketext&quot; Method</source>
          <target state="translated">maketext&quot; メソッド</target>
        </trans-unit>
        <trans-unit id="7968697304f2035aa2639422d611288498d75cab" translate="yes" xml:space="preserve">
          <source>The &quot;mro&quot; namespace provides several utilities for dealing with method resolution order and method caching in general.</source>
          <target state="translated">mro&quot; ネームスペースは、一般的にメソッドの解決順序とメソッドキャッシュを扱うためのいくつかのユーティリティを提供します。</target>
        </trans-unit>
        <trans-unit id="71bf414e13a483c3f8866e169ca7ae68644d2c78" translate="yes" xml:space="preserve">
          <source>The &quot;next&quot; pointers of all regops except &lt;code&gt;BRANCH&lt;/code&gt; implement concatenation; a &quot;next&quot; pointer with a &lt;code&gt;BRANCH&lt;/code&gt; on both ends of it is connecting two alternatives. [Here we have one of the subtle syntax dependencies: an individual &lt;code&gt;BRANCH&lt;/code&gt; (as opposed to a collection of them) is never concatenated with anything because of operator precedence.]</source>
          <target state="translated">&lt;code&gt;BRANCH&lt;/code&gt; を除くすべてのregopsの「次の」ポインターは連結を実装します。両端に &lt;code&gt;BRANCH&lt;/code&gt; がある「次の」ポインターは、2つの選択肢を接続しています。[ここには、構文の微妙な依存関係の1つがあります。個々の &lt;code&gt;BRANCH&lt;/code&gt; （それらのコレクションではなく）は、演算子の優先順位のため、何にも連結されません。]</target>
        </trans-unit>
        <trans-unit id="7475859558b8ac99b6dbae28949b5ee5991af403" translate="yes" xml:space="preserve">
          <source>The &quot;p&quot; mode differs from &quot;U&quot; only in that it treats &quot;\r\r\n&quot; as a single newline, a quirky feature designed to accommodate legacy applications that occasionally added an extra carriage return before DOS line terminators. The &quot;p&quot; mode will be phased out eventually in favor of the cleaner and more well-established Universal Newlines concept.</source>
          <target state="translated">p&quot; モードは &quot;U&quot; とは異なり、&quot;\r\r\r\r\n&quot; を単一の改行として扱うという点だけで、DOS ラインターミネータの前に余分なキャリッジリターンを時々追加するレガシーアプリケーションに対応するために設計された風変わりな機能です。p」モードは、最終的には、よりクリーンで確立されたユニバーサル・ニューラインのコンセプトを支持して、段階的に廃止されるでしょう。</target>
        </trans-unit>
        <trans-unit id="21a4e20c8659f7cc84f2dc6e2b2235449667f421" translate="yes" xml:space="preserve">
          <source>The &quot;prototype&quot; attribute is an alternate means of specifying a prototype on a sub. The desired prototype is within the parens.</source>
          <target state="translated">&quot;prototype &quot;属性は、サブにプロトタイプを指定する代替手段です。目的のプロトタイプはparensの中にあります。</target>
        </trans-unit>
        <trans-unit id="dd5b998a91e6bf19722acfe03146f25538072352" translate="yes" xml:space="preserve">
          <source>The &quot;quality&quot; of a hash is defined as the total number of comparisons needed to access every element once, relative to the expected number needed for a random hash. The value can go over 100%.</source>
          <target state="translated">ハッシュの「品質」は、ランダムハッシュに必要とされる期待される数と比較して、すべての要素に一度アクセスするために必要とされる比較の合計数として定義されます。この値は100%を超えることもあります。</target>
        </trans-unit>
        <trans-unit id="0fa71c4992e21ca9d0f8816931658731741f8823" translate="yes" xml:space="preserve">
          <source>The &quot;root&quot; of the namespace (i.e. &quot;main::&quot;) is changed to a different package and code evaluated in the compartment cannot refer to variables outside this namespace, even with run-time glob lookups and other tricks.</source>
          <target state="translated">名前空間の &quot;ルート&quot;(つまり &quot;main::&quot;)は別のパッケージに変更され、コンパートメント内で評価されたコードは、実行時のグロブ検索やその他のトリックを使っても、この名前空間外の変数を参照することはできません。</target>
        </trans-unit>
        <trans-unit id="40e9eeb816659a4d78537c8ea14e7c775679daaf" translate="yes" xml:space="preserve">
          <source>The &quot;status value&quot; returned in &lt;code&gt;$?&lt;/code&gt; is synthesized from the actual exit status of the subprocess in a way that approximates POSIX wait(5) semantics, in order to allow Perl programs to portably test for successful completion of subprocesses. The low order 8 bits of &lt;code&gt;$?&lt;/code&gt; are always 0 under VMS, since the termination status of a process may or may not have been generated by an exception.</source>
          <target state="translated">&lt;code&gt;$?&lt;/code&gt; 返される「ステータス値」？Perlプログラムがサブプロセスの正常な完了を移植可能にテストできるように、POSIXのwait（5）セマンティクスに近い方法でサブプロセスの実際の終了ステータスから合成されます。 &lt;code&gt;$?&lt;/code&gt; 下位8ビット？プロセスの終了ステータスが例外によって生成された場合と生成されなかった場合があるため、VMSでは常に0です。</target>
        </trans-unit>
        <trans-unit id="9220e93c05c2e58fcb6c44f1b19d591bad6f075c" translate="yes" xml:space="preserve">
          <source>The &quot;unique&quot; attribute is deprecated, and has no effect in 5.10.0 and later. It used to indicate that a single copy of an &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; variable was to be used by all interpreters should the program happen to be running in a multi-interpreter environment.</source>
          <target state="translated">「一意」属性は非推奨であり、5.10.0以降では効果がありません。これは、プログラムがマルチインタープリター環境で実行されて &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 場合に、変数の単一のコピーがすべてのインタープリターによって使用されることを示していました。</target>
        </trans-unit>
        <trans-unit id="72e1eabd61e84fec8e9b71e8964b6733954ac85d" translate="yes" xml:space="preserve">
          <source>The &quot;use locale&quot; pragma</source>
          <target state="translated">use locale&quot; プラグマ</target>
        </trans-unit>
        <trans-unit id="127c26381686cdc6cb6db8e06a75ac1b05a13d0e" translate="yes" xml:space="preserve">
          <source>The #endif and #else cannot portably have anything non-comment after them. If you want to document what is going (which is a good idea especially if the branches are long), use (C) comments:</source>
          <target state="translated">endif と #else の後にコメント以外のものをつけることはできません。何が起こっているのかを文書化したい場合は (特にブランチが長い場合は良いアイデアです)、(C)コメントを使用してください。</target>
        </trans-unit>
        <trans-unit id="6d394482dea20b84087d97ed59f1a7ab0353698f" translate="yes" xml:space="preserve">
          <source>The $algorithm is a string like &quot;MD2&quot;, &quot;MD5&quot;, &quot;SHA-1&quot;, &quot;SHA-512&quot;. Additional arguments are passed to the constructor for the implementation of the given algorithm.</source>
          <target state="translated">アルゴリズムは、&quot;MD2&quot;、&quot;MD5&quot;、&quot;SHA-1&quot;、&quot;SHA-512&quot; のような文字列です。追加の引数は、指定したアルゴリズムを実装するためのコンストラクタに渡されます。</target>
        </trans-unit>
        <trans-unit id="060c7393d1a230b15152f168cb6702d886a2c8e8" translate="yes" xml:space="preserve">
          <source>The $always_copy parameter which when true causes files to be updated regardless as to whether they have changed, if it is defined but false then copies are made only if the files have changed, if it is undefined then the value of the environment variable EU_INSTALL_ALWAYS_COPY is used as default.</source>
          <target state="translated">このパラメータがtrueの場合は、ファイルが変更されたかどうかに関わらずファイルを更新します。</target>
        </trans-unit>
        <trans-unit id="2195889fc63370a441ff8bf1c8a9db960470ff14" translate="yes" xml:space="preserve">
          <source>The $buffer should be a Storable image or the first few bytes of it. If $buffer starts with a Storable header, then a hash describing the image is returned, otherwise &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">$ bufferはStorableイメージまたはその最初の数バイトである必要があります。$ bufferがStorableヘッダーで始まる場合、画像を説明するハッシュが返されます。それ以外の場合は、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="45f3f95232308dda6cf28aa29e85f72c7757c618" translate="yes" xml:space="preserve">
          <source>The $data provided as argument are appended to the message we calculate the digest for. The return value is the $md5 object itself.</source>
          <target state="translated">引数として提供された$dataは、ダイジェストを計算するメッセージに追加されます。戻り値は $md5 オブジェクトそのものです。</target>
        </trans-unit>
        <trans-unit id="0b852897867aa68fb0b59cef6457c36880f5fe89" translate="yes" xml:space="preserve">
          <source>The $f that has &quot;bar&quot; added to it three times should be a new &lt;code&gt;$f&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; should create a new lexical variable each time through the loop. The expected output is:</source>
          <target state="translated">「バー」は$ fは新しいである必要があり、それ三回に追加 &lt;code&gt;$f&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; ループを通して新しいレキシカル変数を毎回作成する必要があります。予想される出力は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="1718e632a613e4c3f044b1d3a129d6229eab251a" translate="yes" xml:space="preserve">
          <source>The $filename parameter is used by Perl to identify the source file for the function if required by die(), caller() or the debugger. If $filename is not defined then &quot;DynaLoader&quot; will be used.</source>
          <target state="translated">パラメータ $filename は、関数のソースファイルを識別するために Perl が使用するもので、die()、caller()、デバッガで必要とされる場合に使用します。もし $filename が定義されていない場合は、&quot;DynaLoader&quot; が使用されます。</target>
        </trans-unit>
        <trans-unit id="84c0a13d8949255c1b3abd5830e5bb4ca9af26b0" translate="yes" xml:space="preserve">
          <source>The $flags argument to alters dl_load_file behaviour. Assigned bits:</source>
          <target state="translated">引数 $flags は、dl_load_file の動作を変更します。割り当てられたビット数。</target>
        </trans-unit>
        <trans-unit id="fd706f4aac9bb23ac72e5f391e9438d3b6687fe7" translate="yes" xml:space="preserve">
          <source>The $io_handle is read until EOF and the content is appended to the message we calculate the digest for. The return value is the $ctx object itself.</source>
          <target state="translated">IOFになるまで$io_handleが読み込まれ、その内容がダイジェストを計算するメッセージに追加されます。戻り値は$ctxオブジェクトそのものです。</target>
        </trans-unit>
        <trans-unit id="f48497c09ab813ab9f670545e1d053cf6b1c4105" translate="yes" xml:space="preserve">
          <source>The $io_handle will be read until EOF and its content appended to the message we calculate the digest for. The return value is the $md5 object itself.</source>
          <target state="translated">IOFになるまで$io_handleが読み込まれ、その内容がダイジェストを計算したメッセージに追加されます。戻り値は$md5オブジェクトそのものです。</target>
        </trans-unit>
        <trans-unit id="73b7765fc89db094ffe9099cbf5e1b07621f5606" translate="yes" xml:space="preserve">
          <source>The $keep argument is a boolean flag. If true, then the tokens are split on the specified delimiter, but all other characters (including quotes and backslashes) are kept in the tokens. If $keep is false then the &amp;amp;*quotewords() functions remove all quotes and backslashes that are not themselves backslash-escaped or inside of single quotes (i.e., &amp;amp;quotewords() tries to interpret these characters just like the Bourne shell). NB: these semantics are significantly different from the original version of this module shipped with Perl 5.000 through 5.004. As an additional feature, $keep may be the keyword &quot;delimiters&quot; which causes the functions to preserve the delimiters in each string as tokens in the token lists, in addition to preserving quote and backslash characters.</source>
          <target state="translated">$ keep引数はブールフラグです。trueの場合、トークンは指定された区切り文字で分割されますが、他のすべての文字（引用符とバックスラッシュを含む）はトークンに保持されます。$ keepがfalseの場合、＆* quotewords（）関数は、バックスラッシュでエスケープされていない、または単一引用符内にないすべての引用符とバックスラッシュを削除します（つまり、＆quotewords（）は、Bourneシェルのようにこれらの文字を解釈しようとします）。注意：これらのセマンティクスは、Perl 5.000から5.004で出荷されたこのモジュールの元のバージョンとは大きく異なります。追加機能として、$ keepはキーワード &quot;delimiters&quot;である場合があります。これにより、関数は各文字列の区切り文字をトークンリストのトークンとして保持し、さらに引用符とバックスラッシュ文字を保持します。</target>
        </trans-unit>
        <trans-unit id="4e5f5797e7dfa3a15e15f61203e30952d45673d5" translate="yes" xml:space="preserve">
          <source>The $members value returned by</source>
          <target state="translated">が返す $members の値は</target>
        </trans-unit>
        <trans-unit id="ea59b84534455476bdc42448f750e6798f5fa6a2" translate="yes" xml:space="preserve">
          <source>The %result hash will be populated with the various keys/subhashes reflecting the install. Currently these keys and their structure are:</source>
          <target state="translated">結果ハッシュには、インストールを反映した様々なキー/サブハッシュが入力されます。現在のところ、これらのキーとその構造は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="eb2003a4836fd23e3d85388f2cbd39901c6bc22d" translate="yes" xml:space="preserve">
          <source>The &amp;amp; Unary Operator</source>
          <target state="translated">＆単項演算子</target>
        </trans-unit>
        <trans-unit id="ddb7807e2ac7fcb7b1862d48b33f4bdc45bd2c34" translate="yes" xml:space="preserve">
          <source>The &amp;amp;&amp;amp; problem</source>
          <target state="translated">問題</target>
        </trans-unit>
        <trans-unit id="4101646effcfa6c9b3723eeb19290b923da87717" translate="yes" xml:space="preserve">
          <source>The &amp;amp;&amp;amp; problem.</source>
          <target state="translated">問題。</target>
        </trans-unit>
        <trans-unit id="819c8af579e67bbf16b0d43d190eb1e52a12ff6c" translate="yes" xml:space="preserve">
          <source>The &amp;amp;nested_quotewords() and &amp;amp;quotewords() functions accept a delimiter (which can be a regular expression) and a list of lines and then breaks those lines up into a list of words ignoring delimiters that appear inside quotes. &amp;amp;quotewords() returns all of the tokens in a single long list, while &amp;amp;nested_quotewords() returns a list of token lists corresponding to the elements of @lines. &amp;amp;parse_line() does tokenizing on a single string. The &amp;amp;*quotewords() functions simply call &amp;amp;parse_line(), so if you're only splitting one line you can call &amp;amp;parse_line() directly and save a function call.</source>
          <target state="translated">＆nested_quotewords（）関数と＆quotewords（）関数は、区切り文字（正規表現でもかまいません）と行のリストを受け入れ、それらの行を引用符内にある区切り文字を無視して単語のリストに分割します。＆quotewords（）はすべてのトークンを単一の長いリストで返し、＆nested_quotewords（）は@linesの要素に対応するトークンリストのリストを返します。＆parse_line（）は、単一の文字列をトークン化します。＆* quotewords（）関数は＆parse_line（）を呼び出すだけなので、1行だけを分割する場合は＆parse_line（）を直接呼び出して関数呼び出しを保存できます。</target>
        </trans-unit>
        <trans-unit id="9c87ced9da37d8df457e1116fcc0073fb1557eae" translate="yes" xml:space="preserve">
          <source>The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered.</source>
          <target state="translated">&amp;lt;-HEREは、正規表現のどこに問題が発見されたかを示しています。</target>
        </trans-unit>
        <trans-unit id="c4f590c76222edc7a4139c10a801899ef6080952" translate="yes" xml:space="preserve">
          <source>The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">&amp;lt;-HEREは、正規表現のどこに問題が発見されたかを示しています。&lt;a href=&quot;perlre&quot;&gt;perlreを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5bf8f7c8c4159c0583c72496084082131f49306a" translate="yes" xml:space="preserve">
          <source>The &amp;lt;FH&amp;gt; construct is not the name of the filehandle, it is a readline operation on that handle. The data read is assigned to $_ only if the file read is the sole condition in a while loop:</source>
          <target state="translated">&amp;lt;FH&amp;gt;コンストラクトはファイルハンドルの名前ではなく、そのハンドルに対するreadline操作です。読み込まれたデータが$ _に割り当てられるのは、読み込まれたファイルがwhileループの唯一の条件である場合のみです。</target>
        </trans-unit>
        <trans-unit id="ab73cfd3e43216b54a963f39932451a527bcc6a3" translate="yes" xml:space="preserve">
          <source>The '&lt;b&gt;-w&lt;/b&gt;' switch would have told us about this, had we used it at the start, and saved us a lot of trouble:</source>
          <target state="translated">' &lt;b&gt;-w&lt;/b&gt; 'スイッチは、このことを私たちに教えてくれましたが、最初にそれを使用し、私たちに多くのトラブルを救いました。</target>
        </trans-unit>
        <trans-unit id="bd6318c738360c72f699370e44631e5d478a985b" translate="yes" xml:space="preserve">
          <source>The 'array_base' feature</source>
          <target state="translated">array_base' 機能</target>
        </trans-unit>
        <trans-unit id="0d3b66a213047641035eea0c1bcf8c880d1b087a" translate="yes" xml:space="preserve">
          <source>The 'bitwise' feature</source>
          <target state="translated">ビットワイズ」機能</target>
        </trans-unit>
        <trans-unit id="3a5d26aebe5343fcb8365359fdfecbe6a1f9ce93" translate="yes" xml:space="preserve">
          <source>The 'bval' Option</source>
          <target state="translated">bval' オプション</target>
        </trans-unit>
        <trans-unit id="e00309e30b37c032e9723d99c993712660e13d4a" translate="yes" xml:space="preserve">
          <source>The 'current_sub' feature</source>
          <target state="translated">'current_sub' 機能</target>
        </trans-unit>
        <trans-unit id="6c052a5c9bdb1ba3c0df3df62a320e47a9bd25cd" translate="yes" xml:space="preserve">
          <source>The 'd' and the 'm' command normally only show you information they have in their in-memory database and thus will never connect to the internet. If you set the 'show_upload_date' variable to true, 'm' and 'd' will additionally show you the upload date of the module or distribution. Per default this feature is off because it may require a net connection to get at the upload date.</source>
          <target state="translated">d' と 'm' コマンドは通常、メモリ内のデータベースにある情報を表示するだけで、 インターネットに接続することはありません。変数 'show_upload_date' を true に設定すると、'm' と 'd' はモジュールやディストリビューションのアップロード日を追加で表示します。デフォルトでは、この機能はオフになっています。</target>
        </trans-unit>
        <trans-unit id="c6e825d609e1bdb12613a2765369452bfb2902c9" translate="yes" xml:space="preserve">
          <source>The 'fc' feature</source>
          <target state="translated">fc」機能</target>
        </trans-unit>
        <trans-unit id="c532c19d0965a864c1673a10c98911020476e550" translate="yes" xml:space="preserve">
          <source>The 'hushed' flag has a global scope during compilation: the exit() or die() commands that are compiled after 'vmsish hushed' will be hushed when they are executed. Doing a &quot;no vmsish 'hushed'&quot; turns off the hushed flag.</source>
          <target state="translated">vmsish hushed' の後にコンパイルされた exit()や die()コマンドは、実行時に hushed されます。no vmsish ' hushed' を実行すると、 hushed フラグはオフになります。</target>
        </trans-unit>
        <trans-unit id="476d927d17a3d46a0ed772d0abdb4399c93a366e" translate="yes" xml:space="preserve">
          <source>The 'lexical_subs' feature</source>
          <target state="translated">lexical_subs' 機能</target>
        </trans-unit>
        <trans-unit id="d15b2cae0ecbb384e6a16c159b73754a15b73452" translate="yes" xml:space="preserve">
          <source>The 'postderef' and 'postderef_qq' features</source>
          <target state="translated">postderef」と「postderef_qq」の特徴</target>
        </trans-unit>
        <trans-unit id="032a279126f29bd2ca1a4d576f6688e5bd0a4721" translate="yes" xml:space="preserve">
          <source>The 'postderef' feature allows the use of &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;postfix dereference syntax&lt;/a&gt;. For example, it will make the following two statements equivalent:</source>
          <target state="translated">'postderef'機能により、&lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;後&lt;/a&gt;置参照解除構文を使用できます。たとえば、次の2つのステートメントは同等になります。</target>
        </trans-unit>
        <trans-unit id="72039153ef5da3a0b8c844ea7ff1d46ddb7f3f43" translate="yes" xml:space="preserve">
          <source>The 'postderef_qq' feature extends this, for array and scalar dereference, to working inside of double-quotish interpolations.</source>
          <target state="translated">postderef_qq' 機能は、配列やスカラの参照を拡張し、二重引用符補間の内部で動作するようにしました。</target>
        </trans-unit>
        <trans-unit id="1856b511545a836fd1960f70b611782e60e03174" translate="yes" xml:space="preserve">
          <source>The 'refaliasing' feature</source>
          <target state="translated">リファリアシング」機能</target>
        </trans-unit>
        <trans-unit id="43acd92859b0081e26405b0092a9e001da38bcb0" translate="yes" xml:space="preserve">
          <source>The 'say' feature</source>
          <target state="translated">言う」機能</target>
        </trans-unit>
        <trans-unit id="48c11f3663366e7407088877b28bc4e952cd3e8c" translate="yes" xml:space="preserve">
          <source>The 'signatures' feature</source>
          <target state="translated">シグネチャー」の特徴</target>
        </trans-unit>
        <trans-unit id="1ef5c6a6bc489a315173331d45afe7880d296d9b" translate="yes" xml:space="preserve">
          <source>The 'state' feature</source>
          <target state="translated">状態」の特徴</target>
        </trans-unit>
        <trans-unit id="0202f826bf3e7b7586cfc812c13b1dfe89d2bf49" translate="yes" xml:space="preserve">
          <source>The 'switch' feature</source>
          <target state="translated">スイッチ」機能</target>
        </trans-unit>
        <trans-unit id="7029a8b5bd568b6e4297fb88434b17a5f75b3a17" translate="yes" xml:space="preserve">
          <source>The 'unicode_eval' and 'evalbytes' features</source>
          <target state="translated">unicode_eval' および 'evalbytes' 機能は</target>
        </trans-unit>
        <trans-unit id="e493b49d6dbbae3a5be3b8f2dff13d8ec26ef7db" translate="yes" xml:space="preserve">
          <source>The 'unicode_strings' feature</source>
          <target state="translated">unicode_string' 機能</target>
        </trans-unit>
        <trans-unit id="0f31ae17f71ba4abf6738dd8a78689f3b1ddbaf2" translate="yes" xml:space="preserve">
          <source>The -Dprefix option will install Perl in a directory parallel to the IBM AIX system Perl installation.</source>
          <target state="translated">Dprefixオプションは、IBM AIXシステムのPerlのインストールと並行したディレクトリにPerlをインストールします。</target>
        </trans-unit>
        <trans-unit id="3bc3be0ef0e3e9886678cc868f1c296c736baaaa" translate="yes" xml:space="preserve">
          <source>The .c files will automatically be included in the list of files deleted by a make clean.</source>
          <target state="translated">.cファイルは、自動的にmake cleanによって削除されたファイルのリストに含まれます。</target>
        </trans-unit>
        <trans-unit id="eaa1f52ae3c132b312829a1a099fb15cc4451f8a" translate="yes" xml:space="preserve">
          <source>The .i Targets</source>
          <target state="translated">.iターゲット</target>
        </trans-unit>
        <trans-unit id="c5957baac4fddeea5c92174eefc52a682210436d" translate="yes" xml:space="preserve">
          <source>The .netrc file contains login and initialization information used by the auto-login process. It resides in the user's home directory. The following tokens are recognized; they may be separated by spaces, tabs, or new-lines:</source>
          <target state="translated">.netrcファイルには、自動ログインプロセスで使用されるログイン情報と初期化情報が含まれています。このファイルはユーザのホームディレクトリにあります。以下のトークンが認識されます。</target>
        </trans-unit>
        <trans-unit id="54f9e8c707fce1b5fb29121fecf5b3c5f6fb75cd" translate="yes" xml:space="preserve">
          <source>The .pm and .xs files contain the meat of the extension. The .xs file holds the C routines that make up the extension. The .pm file contains routines that tell Perl how to load your extension.</source>
          <target state="translated">.pm と .xs ファイルには、拡張子を構成する要素が含まれています。.xs ファイルは拡張子を構成する C ルーチンを保持しています。.pm ファイルには、Perl がどのように拡張子をロードするかを教えるルーチンが含まれています。</target>
        </trans-unit>
        <trans-unit id="dd2519bf881a43a692b68b1c0e909064ae51fbd0" translate="yes" xml:space="preserve">
          <source>The .pm file originally exported the name &lt;code&gt;TESTVAL&lt;/code&gt; in the &lt;code&gt;@EXPORT&lt;/code&gt; array. This could lead to name clashes. A good rule of thumb is that if the #define is only going to be used by the C routines themselves, and not by the user, they should be removed from the &lt;code&gt;@EXPORT&lt;/code&gt; array. Alternately, if you don't mind using the &quot;fully qualified name&quot; of a variable, you could move most or all of the items from the &lt;code&gt;@EXPORT&lt;/code&gt; array into the &lt;code&gt;@EXPORT_OK&lt;/code&gt; array.</source>
          <target state="translated">.pmファイルは、もともと &lt;code&gt;TESTVAL&lt;/code&gt; という名前を &lt;code&gt;@EXPORT&lt;/code&gt; 配列にエクスポートしていました。これは名前の衝突につながる可能性があります。経験則として、＃defineがユーザーではなくCルーチン自体でのみ使用される場合は、 &lt;code&gt;@EXPORT&lt;/code&gt; 配列から削除する必要があります。あなたは、変数の「完全修飾名」を使用して気にしない場合は別の方法としては、あなたがからほとんどまたはすべてのアイテムを移動することができ &lt;code&gt;@EXPORT&lt;/code&gt; のに配列 &lt;code&gt;@EXPORT_OK&lt;/code&gt; の配列。</target>
        </trans-unit>
        <trans-unit id="e7ef13c3a85e7562d01716fd477e5df2797f8e0b" translate="yes" xml:space="preserve">
          <source>The .xs file of &lt;a href=&quot;#EXAMPLE-4&quot;&gt;EXAMPLE 4&lt;/a&gt; contained some new elements. To understand the meaning of these elements, pay attention to the line which reads</source>
          <target state="translated">&lt;a href=&quot;#EXAMPLE-4&quot;&gt;例4&lt;/a&gt;の.xsファイルには、いくつかの新しい要素が含まれています。これらの要素の意味を理解するには、次の行に注意してください</target>
        </trans-unit>
        <trans-unit id="9a412534f9637df17d083fc0dd838ed8c9b7cead" translate="yes" xml:space="preserve">
          <source>The /usr/bin/perl is obvious (hopefully).</source>
          <target state="translated">usr/bin/perlは明らかです(うまくいけば)。</target>
        </trans-unit>
        <trans-unit id="b90c8fc76aaca137d93e66aec85f8cb2eec3fed5" translate="yes" xml:space="preserve">
          <source>The 0th entry of the PADLIST is a PADNAMELIST which represents the &quot;names&quot; or rather the &quot;static type information&quot; for lexicals. The individual elements of a PADNAMELIST are PADNAMEs. Future refactorings might stop the PADNAMELIST from being stored in the PADLIST's array, so don't rely on it. See &lt;a href=&quot;#PadlistNAMES&quot;&gt;PadlistNAMES&lt;/a&gt;.</source>
          <target state="translated">PADLISTの0番目のエントリはPADNAMELISTで、字句の「名前」または「静的タイプ情報」を表します。PADNAMELISTの個々の要素はPADNAMEです。今後のリファクタリングにより、PADNAMELISTがPADLISTの配列に格納されなくなる可能性があるため、これに依存しないでください。&lt;a href=&quot;#PadlistNAMES&quot;&gt;PadlistNAMESを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e0c98b5db329af061627f1088cd649948958ceb6" translate="yes" xml:space="preserve">
          <source>The 1 or 2 rows of numbers following that correspond to the number of buckets of each size between &lt;code&gt;SMALLEST&lt;/code&gt; and &lt;code&gt;GREATEST&lt;/code&gt; . In the first row, the sizes (memory footprints) of buckets are powers of two--or possibly one page greater. In the second row, if present, the memory footprints of the buckets are between the memory footprints of two buckets &quot;above&quot;.</source>
          <target state="translated">&lt;code&gt;SMALLEST&lt;/code&gt; から &lt;code&gt;GREATEST&lt;/code&gt; までの各サイズのバケット数に対応する、それに続く1行または2行の数字。最初の行では、バケットのサイズ（メモリフットプリント）は2の累乗、場合によっては1ページ大きくなります。2行目では、存在する場合、バケットのメモリフットプリントは、「上」の2つのバケットのメモリフットプリントの間にあります。</target>
        </trans-unit>
        <trans-unit id="474f74fc74e6b97d1b22c49840ad80fdd2b7a470" translate="yes" xml:space="preserve">
          <source>The 1-argument form of cacheout will open a file for writing (&lt;code&gt;'&amp;gt;'&lt;/code&gt; ) on it's first use, and appending (&lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt; ) thereafter.</source>
          <target state="translated">引数が1の形式のcacheoutは、最初に使用するときにファイルを開き（ &lt;code&gt;'&amp;gt;'&lt;/code&gt; ）、その後に追加（ &lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt; ）します。</target>
        </trans-unit>
        <trans-unit id="ece20b2e43644dc279ab7b6d2adb512919e3c93c" translate="yes" xml:space="preserve">
          <source>The 13 variant characters</source>
          <target state="translated">13種類のバリアントキャラクター</target>
        </trans-unit>
        <trans-unit id="a9393cb211cfe66570248ab99ec7632708f22fae" translate="yes" xml:space="preserve">
          <source>The 1st column is the op's sequence number, starting at 1, and is displayed in base 36 by default. Here they're purely linear; the sequences are very helpful when looking at code with loops and branches.</source>
          <target state="translated">1 番目の列は op のシーケンス番号で、1 から始まり、デフォルトでは 36 ベースで表示されます。ここでは、これらは純粋に線形です。シーケンスはループや分岐のあるコードを見るときに非常に便利です。</target>
        </trans-unit>
        <trans-unit id="004f29b5a23df31b01d8aa7e1fc9952890ebb7d2" translate="yes" xml:space="preserve">
          <source>The 2-argument form of cacheout will use the supplied mode for the initial and subsequent openings. Most valid modes for 3-argument &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; are supported namely; &lt;code&gt;'&amp;gt;'&lt;/code&gt; , &lt;code&gt;'+&amp;gt;'&lt;/code&gt; , &lt;code&gt;'&amp;lt;'&lt;/code&gt; , &lt;code&gt;'&amp;lt;+'&lt;/code&gt; , &lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt; , &lt;code&gt; '|-' &lt;/code&gt; and &lt;code&gt; '-|' &lt;/code&gt;</source>
          <target state="translated">2引数形式のキャッシュアウトは、最初とその後の開始時に提供されたモードを使用します。つまり、3引数の &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 最も有効なモードがサポートされています。 &lt;code&gt;'&amp;gt;'&lt;/code&gt; 、 &lt;code&gt;'+&amp;gt;'&lt;/code&gt; 、 &lt;code&gt;'&amp;lt;'&lt;/code&gt; 、 &lt;code&gt;'&amp;lt;+'&lt;/code&gt; 、 &lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt; 、 &lt;code&gt; '|-' &lt;/code&gt; 、 &lt;code&gt; '-|' &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="11ff8f169a4e9a0d5e765f1f57d4ab8242fb17bb" translate="yes" xml:space="preserve">
          <source>The 256-color control sequences are documented at &lt;a href=&quot;http://invisible-island.net/xterm/ctlseqs/ctlseqs.html&quot;&gt;http://invisible-island.net/xterm/ctlseqs/ctlseqs.html&lt;/a&gt; (search for 256-color).</source>
          <target state="translated">256色の制御シーケンスは、&lt;a href=&quot;http://invisible-island.net/xterm/ctlseqs/ctlseqs.html&quot;&gt;http：//invisible-island.net/xterm/ctlseqs/ctlseqs.html&lt;/a&gt;（256色を検索）に記載されています。</target>
        </trans-unit>
        <trans-unit id="b81b42d9c2528e2e2cc53554ea82b10b2357c0c7" translate="yes" xml:space="preserve">
          <source>The :browse tag represents the next step beyond :default. It it a superset of the :default ops and adds :filesys_read the :sys_db. The intent being that scripts can access more (possibly sensitive) information about your system but not be able to change it.</source>
          <target state="translated">browse タグは :default の次のステップを表します。これは :default 操作のスーパーセットであり、 :sys_db の :filesys_read を追加します。その意図は、スクリプトがシステムに関するより多くの (おそらくは機密の)情報にアクセスしても、それを変更することができないようにすることです。</target>
        </trans-unit>
        <trans-unit id="913829e3b140a41628c9596982f027a8f2285b7a" translate="yes" xml:space="preserve">
          <source>The :locale sub-pragma</source>
          <target state="translated">ロケールサブパラメータ</target>
        </trans-unit>
        <trans-unit id="d85820f28213c3599595658668ce44deb0578d4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Extended-Grapheme-Clusters-(Logical-characters)&quot;&gt;Extended Grapheme Clusters (Logical characters)&lt;/a&gt; section above talked about canonical decompositions. However, many more characters have a different type of decomposition, a &quot;compatible&quot; or &quot;non-canonical&quot; decomposition. The sequences that form these decompositions are not considered canonically equivalent to the pre-composed character. An example is the &lt;code&gt;&quot;SUPERSCRIPT ONE&quot;&lt;/code&gt; . It is somewhat like a regular digit 1, but not exactly; its decomposition into the digit 1 is called a &quot;compatible&quot; decomposition, specifically a &quot;super&quot; decomposition. There are several such compatibility decompositions (see &lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;http://www.unicode.org/reports/tr44&lt;/a&gt;), including one called &quot;compat&quot;, which means some miscellaneous type of decomposition that doesn't fit into the other decomposition categories that Unicode has chosen.</source>
          <target state="translated">上記の&lt;a href=&quot;#Extended-Grapheme-Clusters-(Logical-characters)&quot;&gt;拡張書記素クラスター（論理文字）&lt;/a&gt;セクションでは、正準分解について説明しました。ただし、さらに多くの文字には、「互換性のある」または「非正規」の分解という異なるタイプの分解があります。これらの分解を形成するシーケンスは、事前に構成された文字と標準的に同等であるとは見なされません。その一例が &lt;code&gt;&quot;SUPERSCRIPT ONE&quot;&lt;/code&gt; です。これは通常の数字の1に似ていますが、正確ではありません。数字1への分解は、「互換性のある」分解、特に「スーパー」分解と呼ばれます。そのような互換性分解がいくつかあります（&lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;http://www.unicode.org/reports/tr44を参照）&lt;/a&gt;）、 &quot;compat&quot;と呼ばれるものを含みます。これは、Unicodeが選択した他の分解カテゴリに適合しないその他の分解タイプを意味します。</target>
        </trans-unit>
        <trans-unit id="6f116e91479173f83f0ee6321a3113bbe8db276b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt; function is unsuitable for hashing large quantities of data, not least of all because you can't get the information back. Look at the &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; module for more robust algorithms.</source>
          <target state="translated">&lt;a href=&quot;#crypt&quot;&gt;暗号&lt;/a&gt;機能を使用すると、情報を取り戻すことができないためではない以上、すべてのデータを大量に、ハッシュ化には不向きです。より堅牢なアルゴリズムについては、&lt;a href=&quot;digest&quot;&gt;ダイジェスト&lt;/a&gt;モジュールをご覧ください。</target>
        </trans-unit>
        <trans-unit id="8854fb6583fec2754cd3983ea80d85f9b0022749" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the bidi type name.</source>
          <target state="translated">&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;関数は、双方向型の名前のすべての同義語を取得するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="76a16bb68fd364d030e4901c8f1d916862b53339" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the category name.</source>
          <target state="translated">&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;関数は、カテゴリ名のすべての同義語を取得するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="2277466bc19ae0c38a8069cd1ac99be48d5794e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the combining class number.</source>
          <target state="translated">&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;関数は、合成クラス番号のすべての同義語を取得するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="d0d02ad47d23ca3616a65821c3a3e94a1c4a3210" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short bidi type names; and the second gets all the synonyms of a given bidi type name.</source>
          <target state="translated">&lt;a href=&quot;#prop_values()&quot;&gt;prop_values（）&lt;/a&gt;と&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;関数は、この関数の代替として使用することができます。最初は短い双方向タイプ名の単純なリストを返します。2番目は、指定されたBidiタイプ名のすべての同義語を取得します。</target>
        </trans-unit>
        <trans-unit id="ff1836f9843147fc775222ff3469395bcf43b303" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short category names; and the second gets all the synonyms of a given category name.</source>
          <target state="translated">&lt;a href=&quot;#prop_values()&quot;&gt;prop_values（）&lt;/a&gt;と&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;関数は、この関数の代替として使用することができます。最初は短いカテゴリ名の単純なリストを返します。2番目は、指定されたカテゴリ名のすべての同義語を取得します。</target>
        </trans-unit>
        <trans-unit id="8295b9c404465c68e21720ae88623e9c9b91d667" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist()&lt;/a&gt; function is provided for finding a code point within an inversion list.</source>
          <target state="translated">&lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist（）&lt;/a&gt;関数は、反転リスト内のコード・ポイントを発見するために設けられています。</target>
        </trans-unit>
        <trans-unit id="a99fc3c1e89a0b4e840a4661bca0de0880d27694" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../file/stat&quot;&gt;File::stat&lt;/a&gt; module provides a convenient, by-name access mechanism:</source>
          <target state="translated">&lt;a href=&quot;../file/stat&quot;&gt;ファイル:: STAT&lt;/a&gt;モジュールは便利、名前によるアクセス機構を提供します。</target>
        </trans-unit>
        <trans-unit id="f74e082436b86f6a01a3f1c31662df75f43fb323" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; does not use a formal grammar because TAP is essentially a stream-based protocol. In fact, it's quite legal to have an infinite stream. For the same reason that we don't apply regexes to streams, we're not using a formal grammar here. Instead, we parse the TAP in lines.</source>
          <target state="translated">&lt;a href=&quot;../parser&quot;&gt;TAP ::パーサーは&lt;/a&gt; TAPは、本質的に、ストリームベースのプロトコルであるため、正式な文法を使用していません。実際、無限のストリームを持つことは非常に合法です。正規表現をストリームに適用しないのと同じ理由で、ここでは正式な文法を使用していません。代わりに、TAPを行で解析します。</target>
        </trans-unit>
        <trans-unit id="9b27238d4d5342b8376d19c0241b7f8feab19452" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section contains an example of tying handles.</source>
          <target state="translated">&lt;a href=&quot;../perltie&quot;&gt;perltieやの&lt;/a&gt;セクションでは、同点のハンドルの例が含まれています。</target>
        </trans-unit>
        <trans-unit id="6d31ab6a810582c2c717e2c46d057f9872d7ae58" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section uses a good example of tying scalars by associating process IDs with priority.</source>
          <target state="translated">&lt;a href=&quot;../perltie&quot;&gt;perltieやの&lt;/a&gt;部分は、優先的にプロセスIDを関連付けることにより、スカラーを結ぶの良い例を使用します。</target>
        </trans-unit>
        <trans-unit id="ef794a4d4eb5de692a3463fa7a1780b4cded7598" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../time/gmtime&quot;&gt;Time::gmtime&lt;/a&gt; and &lt;a href=&quot;../time/localtime&quot;&gt;Time::localtime&lt;/a&gt; modules provide a convenient, by-name access mechanism to the gmtime() and localtime() functions, respectively.</source>
          <target state="translated">&lt;a href=&quot;../time/gmtime&quot;&gt;時間:: gmtimeは&lt;/a&gt;と&lt;a href=&quot;../time/localtime&quot;&gt;時間:: localtimeの&lt;/a&gt;モジュールは、それぞれのgmtime（）やlocaltimeの（）関数に便利な、名前によるアクセス機構を提供します。</target>
        </trans-unit>
        <trans-unit id="1b61ff031aeab44addeeb9ed990fdd03cf707db7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;b/xref&quot;&gt;B::Xref&lt;/a&gt; module can be used to generate cross-reference reports for Perl programs.</source>
          <target state="translated">&lt;a href=&quot;b/xref&quot;&gt;B ::外部参照&lt;/a&gt;モジュールは、Perlプログラムのクロスリファレンスレポートを生成するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="1c782dc05843dae452f5fa426b35990195e14641" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; module allows you to present your error messages from the caller's perspective; this gives you a way to signal a problem with the caller and not your module. For instance, if you say this:</source>
          <target state="translated">&lt;a href=&quot;carp&quot;&gt;鯉の&lt;/a&gt;モジュールを使用すると、呼び出し側の視点から自分のエラーメッセージを提示することができます。これにより、モジュールではなく呼び出し元に問題を通知する方法が提供されます。たとえば、次のように言った場合：</target>
        </trans-unit>
        <trans-unit id="99917712f2804784fe8d984e9caf76b36fd4b3a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; function is unsuitable for hashing large quantities of data, not least of all because you can't get the information back. Look at the &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; module for more robust algorithms.</source>
          <target state="translated">&lt;a href=&quot;crypt&quot;&gt;暗号&lt;/a&gt;機能を使用すると、情報を取り戻すことができないためではない以上、すべてのデータを大量に、ハッシュ化には不向きです。より堅牢なアルゴリズムについては、&lt;a href=&quot;../digest&quot;&gt;ダイジェスト&lt;/a&gt;モジュールをご覧ください。</target>
        </trans-unit>
        <trans-unit id="5477977d65c206b7b8a0bfb0ffcfed2d08e7d436" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; module can pretty-print Perl data structures:</source>
          <target state="translated">&lt;a href=&quot;data/dumper&quot;&gt;データ::ダンパ&lt;/a&gt;モジュールはPerlのデータ構造をかなり-印刷することができます。</target>
        </trans-unit>
        <trans-unit id="c389b29dcc18d72eca5cc18bef171945489bed86" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; module on CPAN (or the 5.005 release of Perl) is great for printing out data structures. The &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; module on CPAN (or the 5.8 release of Perl), provides a function called &lt;code&gt;dclone&lt;/code&gt; that recursively copies its argument.</source>
          <target state="translated">CPAN（またはPerlの5.005リリース）の&lt;a href=&quot;data/dumper&quot;&gt;Data :: Dumper&lt;/a&gt;モジュールは、データ構造の印刷に最適です。CPAN（または5.8リリースのPerl）の&lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt;モジュールは、引数を再帰的にコピーする &lt;code&gt;dclone&lt;/code&gt; と呼ばれる関数を提供します。</target>
        </trans-unit>
        <trans-unit id="f90e864f3a759969a519520835fc4b34320f5652" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; module, better known simply as &quot;MakeMaker&quot;, turns a Perl script, typically called &lt;code&gt;Makefile.PL&lt;/code&gt; , into a Makefile. The Unix tool &lt;code&gt;make&lt;/code&gt; uses this file to manage dependencies and actions to process and install a Perl distribution.</source>
          <target state="translated">&lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMakerのの&lt;/a&gt;よりよい単に「MakeMakerの」として知られているモジュールは、一般的に呼ばれる、Perlスクリプトをオン &lt;code&gt;Makefile.PL&lt;/code&gt; のMakefileに、。Unixツール &lt;code&gt;make&lt;/code&gt; はこのファイルを使用して、Perlディストリビューションを処理およびインストールするための依存関係とアクションを管理します。</target>
        </trans-unit>
        <trans-unit id="b36a8fb9e123f79842afcd307b1051443b42499f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt; module, which comes with Perl, does all of the hard work to traverse a directory structure. It comes with Perl. You simply call the &lt;code&gt;find&lt;/code&gt; subroutine with a callback subroutine and the directories you want to traverse:</source>
          <target state="translated">&lt;a href=&quot;file/find&quot;&gt;ファイル::検索&lt;/a&gt;のPerlモジュールが付属していますが、ディレクトリ構造を横断するハードワークのすべてを行います。Perlが付属しています。コールバックサブルーチンとトラバースするディレクトリを指定して、 &lt;code&gt;find&lt;/code&gt; サブルーチンを呼び出すだけです。</target>
        </trans-unit>
        <trans-unit id="c85303530151e0f7d4bf77f032f56bce0f2d433a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module also has a legacy interface to the older &lt;code&gt;rmtree&lt;/code&gt; subroutine.</source>
          <target state="translated">&lt;a href=&quot;file/path&quot;&gt;ファイル::パスの&lt;/a&gt;モジュールも古いのレガシーインタフェースあり &lt;code&gt;rmtree&lt;/code&gt; のサブルーチンを。</target>
        </trans-unit>
        <trans-unit id="2e3abc4db13d619062f522429a3b20e4ff646e91" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module, which comes with Perl, has a &lt;code&gt;remove_tree&lt;/code&gt; which can take care of all of the hard work for you:</source>
          <target state="translated">Perlに付属の&lt;a href=&quot;file/path&quot;&gt;File :: Path&lt;/a&gt;モジュールには、ハードワークのすべてを処理できる &lt;code&gt;remove_tree&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="e423ba5fb093092e153154cd61200bfa0809ecf8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/stat&quot;&gt;File::stat&lt;/a&gt; module provides a convenient, by-name access mechanism:</source>
          <target state="translated">&lt;a href=&quot;file/stat&quot;&gt;ファイル:: STAT&lt;/a&gt;モジュールは便利、名前によるアクセス機構を提供します。</target>
        </trans-unit>
        <trans-unit id="147153b8beaaff8771aea84e885cb82d17734d7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;findbin&quot;&gt;FindBin&lt;/a&gt; module, which comes with Perl, might work. It finds the directory of the currently running script and puts it in &lt;code&gt;$Bin&lt;/code&gt; , which you can then use to construct the right library path:</source>
          <target state="translated">&lt;a href=&quot;findbin&quot;&gt;FindBinの&lt;/a&gt; Perlのモジュールが付属していますが、うまくいくかもしれません。現在実行中のスクリプトのディレクトリを見つけて &lt;code&gt;$Bin&lt;/code&gt; 入れます。これを使用して、適切なライブラリパスを作成できます。</target>
        </trans-unit>
        <trans-unit id="6627242b752186d85aed5b69d9aaec46b0dd05af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Loops&quot;&gt;Algorithm::Loops&lt;/a&gt; module also provides the &lt;code&gt;NextPermute&lt;/code&gt; and &lt;code&gt;NextPermuteNum&lt;/code&gt; functions which efficiently find all unique permutations of an array, even if it contains duplicate values, modifying it in-place: if its elements are in reverse-sorted order then the array is reversed, making it sorted, and it returns false; otherwise the next permutation is returned.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Loops&quot;&gt;アルゴリズム::ループ&lt;/a&gt;モジュールも提供 &lt;code&gt;NextPermute&lt;/code&gt; と &lt;code&gt;NextPermuteNum&lt;/code&gt; インプレース、それを修正する、効率的に重複する値が含まれている場合でも、アレイのすべての固有の順列を見つける機能を：その要素が逆ソート順に、配列が逆転している場合、ソートして、falseを返します。それ以外の場合は、次の順列が返されます。</target>
        </trans-unit>
        <trans-unit id="7f004cbac628e9968204a02264b31a3bb1043a19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Array::Iterator::Circular&quot;&gt;Array::Iterator::Circular&lt;/a&gt; creates an iterator object for circular arrays:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Array::Iterator::Circular&quot;&gt;アレイ::イテレータ::丸は&lt;/a&gt;、円形アレイのイテレータオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="a8c05beafd26231c80f038931300ac0e459427b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt; module provides an abstract interface to most database servers and types, including Oracle, DB2, Sybase, mysql, Postgresql, ODBC, and flat files. The DBI module accesses each database type through a database driver, or DBD. You can see a complete list of available drivers on CPAN: &lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http://www.cpan.org/modules/by-module/DBD/&lt;/a&gt; . You can read more about DBI on &lt;a href=&quot;http://dbi.perl.org/&quot;&gt;http://dbi.perl.org/&lt;/a&gt; .</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBIの&lt;/a&gt;モジュールは、Oracle、DB2、Sybaseのは、MySQL、Postgresqlの、ODBC、およびフラット・ファイルなど、ほとんどのデータベースサーバや種類、に抽象インタフェースを提供します。DBIモジュールは、データベースドライバーまたはDBDを介して各データベースタイプにアクセスします。CPANで利用可能なドライバーの完全なリストを見ることができます：&lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http&lt;/a&gt; : //www.cpan.org/modules/by-module/DBD/。DBIの詳細については、&lt;a href=&quot;http://dbi.perl.org/&quot;&gt;http：&lt;/a&gt; //dbi.perl.org/を参照してください。</target>
        </trans-unit>
        <trans-unit id="d99e17e2d810ab06df1befd3ba4deffe8e1f4100" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; module on CPAN can do it for you too. Its &lt;code&gt;Dive&lt;/code&gt; subroutine can tell you not only if the keys exist but also get the value:</source>
          <target state="translated">CPAN の&lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data :: Diver&lt;/a&gt;モジュールもあなたのためにそれをすることができます。その &lt;code&gt;Dive&lt;/code&gt; サブルーチンは、キーが存在するかどうかだけでなく、値を取得することもできます。</target>
        </trans-unit>
        <trans-unit id="2f20a46404ea5d10e8ff52857742923d6a8c636c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module provides two functions to calculate these, too:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;日付::のCalc&lt;/a&gt;モジュールは、あまりにも、これらを計算するための2つの機能を提供します。</target>
        </trans-unit>
        <trans-unit id="cffc0b8a618b23964a5ae541c5cad5a91da659e3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt; (New York Times Profiler) does both statement and subroutine profiling. It's available from CPAN and you also invoke it with the &lt;code&gt;-d&lt;/code&gt; switch:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Develの:: NYTProf&lt;/a&gt;（ニューヨーク・タイムズプロファイラー）は、両方の文とサブルーチンのプロファイリングを行います。これはCPANから入手でき、 &lt;code&gt;-d&lt;/code&gt; スイッチを使用して呼び出すこともできます。</target>
        </trans-unit>
        <trans-unit id="36fe1514538dca6b4e14625a53ea351dc45f0bbb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; module can decode base 64-encoded email message parts transparently so the developer doesn't need to worry about it.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;メール:: MIMEの&lt;/a&gt;モジュールは透過的にその開発者はそれを心配する必要はありませんベース64でエンコードされた電子メールメッセージの一部をデコードすることができます。</target>
        </trans-unit>
        <trans-unit id="5544c90428de4242a1010e3b0f0f5fbfd72933f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Closures&quot;&gt;File::Find::Closures&lt;/a&gt;, which you can download from CPAN, provides many ready-to-use subroutines that you can use with &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Closures&quot;&gt;ファイル::検索::クロージャ&lt;/a&gt;あなたはCPANからダウンロードすることができ、あなたが使用できることを多くのすぐに使用できるサブルーチンを提供し&lt;a href=&quot;file/find&quot;&gt;、ファイル::検索します&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56af297ba8a5f6d4fadfc00398e4a75a93e0389e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File::Find::Rule&lt;/a&gt; module, which you can download from CPAN, has a similar interface, but does the traversal for you too:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;ファイル::検索::ルール&lt;/a&gt;あなたはCPANからダウンロードできるモジュールは、同様のインタフェースを持っていますが、あまりにもあなたのためのトラバーサルを行います。</target>
        </trans-unit>
        <trans-unit id="b152dc512307ef4ac58f7c9208c20855dec936d6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Finder&quot;&gt;File::Finder&lt;/a&gt;, which you can download from CPAN, can help you create the callback subroutine using something closer to the syntax of the &lt;code&gt;find&lt;/code&gt; command-line utility:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/File::Finder&quot;&gt;ファイル::ファインダー&lt;/a&gt;、あなたはCPANからダウンロードすることができ、あなたが近いの構文に何かを使用してコールバックサブルーチンを作成することができます &lt;code&gt;find&lt;/code&gt; コマンドラインユーティリティ：</target>
        </trans-unit>
        <trans-unit id="1598869d41d1eca117a3416dff8d5309f0c6cfec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt; module also has the advantage of setting the input record separator to a regular expression.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;ファイル:: ReadBackwardsは、&lt;/a&gt;モジュールは、正規表現の入力レコードセパレータを設定するという利点があります。</target>
        </trans-unit>
        <trans-unit id="91110246c66bf6d661128beb45e4417253ba4c01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Interactive&quot;&gt;IO::Interactive&lt;/a&gt; module does the best it can to give you an answer. Its &lt;code&gt;is_interactive&lt;/code&gt; function returns an output filehandle; that filehandle points to standard output if the module thinks the session is interactive. Otherwise, the filehandle is a null handle that simply discards the output:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/IO::Interactive&quot;&gt;IO ::インタラクティブな&lt;/a&gt;モジュールはあなたに答えを与えるためにそれができる最善を尽くします。その &lt;code&gt;is_interactive&lt;/code&gt; 機能は、出力ファイルハンドルを返します。モジュールがセッションがインタラクティブであると考える場合、そのファイルハンドルは標準出力を指します。それ以外の場合、filehandleは出力を単に破棄するnullハンドルです。</target>
        </trans-unit>
        <trans-unit id="6b13cf53c66e0915c0e8281e749fbd4b759e7ba2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Proc::Daemon&quot;&gt;Proc::Daemon&lt;/a&gt; module, available from CPAN, provides a function to perform these actions for you.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Proc::Daemon&quot;&gt;PROC ::デーモン&lt;/a&gt; CPANから利用できるモジュールは、あなたのためにこれらのアクションを実行するための機能を提供します。</target>
        </trans-unit>
        <trans-unit id="078338e81125883115260ece46dd352b4457327c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Sys::Hostname::Long&quot;&gt;Sys::Hostname::Long&lt;/a&gt; module takes a different approach and tries harder to return the fully qualified hostname:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Sys::Hostname::Long&quot;&gt;Sys ::ホスト名::ロング&lt;/a&gt;モジュールは異なるアプローチをとり、完全修飾ホスト名を返すために難しくしようとします：</target>
        </trans-unit>
        <trans-unit id="d7d7335f50cc47451871f0f97f15916c1b4287d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Task::Kensho&quot;&gt;Task::Kensho&lt;/a&gt; module has a list of recommended modules which you should review as a good starting point.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Task::Kensho&quot;&gt;タスク:: Kenshoの&lt;/a&gt;モジュールは、あなたが良い出発点として検討すべき推奨モジュールのリストを持っています。</target>
        </trans-unit>
        <trans-unit id="96f2822c5bca6e995fc1a0007a9363af6e5934b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN offers an easy-to-use interface that should be more efficient than shelling out to &lt;b&gt;stty&lt;/b&gt; for each key. It even includes limited support for Windows.</source>
          <target state="translated">CPAN の&lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt;モジュールは、キーごとに&lt;b&gt;stty&lt;/b&gt;を使用するよりも効率的な、使いやすいインターフェースを提供します。Windowsの限定的なサポートも含まれます。</target>
        </trans-unit>
        <trans-unit id="32118c4d7f9e3bede84a1a66430b5426071bf4d3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Tussle&quot;&gt;Unicode::Tussle&lt;/a&gt; CPAN module includes many programs to help with working with Unicode, including these programs to fully or partly replace standard utilities:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Tussle&quot;&gt;ユニコード::闘争&lt;/a&gt; CPANモジュールは、完全にまたは部分的に標準ユーティリティを置き換えるために、これらのプログラムを含め、ユニコードでの作業を支援するために多くのプログラムが含まれています。</target>
        </trans-unit>
        <trans-unit id="919f72853738df881eb6e91400681adc998b688b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/strictures#VERSION-2&quot;&gt;strictures&lt;/a&gt; module on CPAN offers one example of a warnings subset that the module's authors believe is relatively safe to fatalize.</source>
          <target state="translated">CPAN の&lt;a href=&quot;http://search.cpan.org/perldoc/strictures#VERSION-2&quot;&gt;strictures&lt;/a&gt;モジュールは、モジュールの作成者が致命的に比較的安全であると信じている警告サブセットの1つの例を提供します。</target>
        </trans-unit>
        <trans-unit id="843917bc0f80fad466bd923d5aab8d1c0906f90e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt; objects also have a &lt;code&gt;flush&lt;/code&gt; method. You can flush the buffer any time you want without auto-buffering</source>
          <target state="translated">&lt;a href=&quot;io/handle&quot;&gt;IO ::ハンドル&lt;/a&gt;も持っているオブジェクト &lt;code&gt;flush&lt;/code&gt; 方法を。自動バッファリングなしでいつでもバッファをフラッシュできます</target>
        </trans-unit>
        <trans-unit id="5839e7279588dcb1c4433f17b527ae9a9d772eed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;ipc/open2&quot;&gt;IPC::Open2&lt;/a&gt; module (part of the standard perl distribution) is an easy-to-use approach that internally uses &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; to do the job. Make sure you read the deadlock warnings in its documentation, though (see &lt;a href=&quot;ipc/open2&quot;&gt;IPC::Open2&lt;/a&gt;). See &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Another-Process&quot;&gt;Bidirectional Communication with Another Process in perlipc&lt;/a&gt; and &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Yourself&quot;&gt;Bidirectional Communication with Yourself in perlipc&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ipc/open2&quot;&gt;IPC :: Open2の&lt;/a&gt;モジュール（標準Perl配布の一部）は、内部的に使用することを簡単に使用できるアプローチである &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 仕事をします。ただし、そのドキュメントのデッドロック警告を必ず読んでください（&lt;a href=&quot;ipc/open2&quot;&gt;IPC :: Open2を&lt;/a&gt;参照）。&lt;a href=&quot;perlipc#Bidirectional-Communication-with-Another-Process&quot;&gt;perlipcの別のプロセス&lt;/a&gt;との&lt;a href=&quot;perlipc#Bidirectional-Communication-with-Yourself&quot;&gt;双方向通信&lt;/a&gt;およびperlipcの自分との双方向通信を参照してください。</target>
        </trans-unit>
        <trans-unit id="09e04b4b58ffa26e2662b854208dafbdb133126a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mime/base64&quot;&gt;MIME::Base64&lt;/a&gt; package handles this as well as the MIME/QP encoding. Decoding base 64 becomes as simple as:</source>
          <target state="translated">&lt;a href=&quot;mime/base64&quot;&gt;MIME :: Base64での&lt;/a&gt;パッケージハンドル本だけでなく、MIME / QPエンコーディング。Base 64のデコードは次のように簡単になります。</target>
        </trans-unit>
        <trans-unit id="0b7108620b7e75ec5ba066fc83c0e7f6113d802f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; pragma provides some functions for manipulating the method cache directly.</source>
          <target state="translated">&lt;a href=&quot;mro&quot;&gt;MRO&lt;/a&gt;プラグマは、直接法のキャッシュを操作するためのいくつかの機能を提供します。</target>
        </trans-unit>
        <trans-unit id="f076d77a637b12522b1379f81df9ca81640a9292" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;net/domain&quot;&gt;Net::Domain&lt;/a&gt; module, which is part of the Standard Library starting in Perl 5.7.3, can get you the fully qualified domain name (FQDN), the host name, or the domain name.</source>
          <target state="translated">&lt;a href=&quot;net/domain&quot;&gt;ネット::ドメイン&lt;/a&gt;のPerl 5.7.3以降で標準ライブラリの一部であるモジュールは、あなたの完全修飾ドメイン名（FQDN）、ホスト名、またはドメイン名を取得することができます。</target>
        </trans-unit>
        <trans-unit id="76dc71fd851bfecf3d4eefc768e03ef389a05460" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma affects all the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; calls after the pragma by setting default layers. If you want to affect only certain streams, use explicit layers directly in the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">&lt;a href=&quot;open&quot;&gt;オープン&lt;/a&gt;プラグマは、すべての影響 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; デフォルト層を設定することで、プラグマの後に呼び出されます。特定のストリームのみに影響を与えたい場合は、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 呼び出しで明示的なレイヤーを直接使用します。</target>
        </trans-unit>
        <trans-unit id="2cf8373e5ee8839618cf4f3d8412574499af0964" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; module is one of several ways that Perl lets you define inheritance relationships.</source>
          <target state="translated">&lt;a href=&quot;parent&quot;&gt;親&lt;/a&gt;モジュールは、Perlを使用して、継承関係を定義することができますことを、いくつかの方法の一つです。</target>
        </trans-unit>
        <trans-unit id="6b0fe01583804e7c24edcd36bf4d1dc86edd7004" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C &lt;/a&gt; command line option can specify that certain inputs to the program are Unicode, and the values of this can be read by your Perl code, see &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;${^UNICODE} in perlvar&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt;コマンドラインオプションは、プログラムに特定の入力がUnicodeをしており、これの値は、あなたのPerlコードで読み取ることができるように指定することができ、参照&lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;はperlvarで$ {^ UNICODE}を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1dd5f1da5843d43e215f1c5605c7bd2602ba3c8d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; documentation has general advice about data security. If you are using the &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt; module, use placeholder to fill in data. If you are running external programs with &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, use the list forms. There are many other precautions that you should take, too many to list here, and most of them fall under the category of not using any data that you don't intend to use. Trust no one.</source>
          <target state="translated">&lt;a href=&quot;perlsec&quot;&gt;perlsecを&lt;/a&gt;ドキュメントには、データセキュリティに関する一般的なアドバイスがあります。&lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt;モジュールを使用している場合は、プレースホルダーを使用してデータを入力します。 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; で外部プログラムを実行している場合は、リスト形式を使用してください。他にも多くの予防策を講じる必要がありますが、ここにリストするには多すぎますが、それらのほとんどは、使用する予定のないデータを使用しないというカテゴリに分類されます。誰も信じない。</target>
        </trans-unit>
        <trans-unit id="d3dddc8cefb2df3a4b2f380a117370ecb94e0324" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module (part of the standard Perl distribution) implements &lt;code&gt;ceil()&lt;/code&gt; , &lt;code&gt;floor()&lt;/code&gt; , and a number of other mathematical and trigonometric functions.</source>
          <target state="translated">&lt;a href=&quot;posix&quot;&gt;POSIXの&lt;/a&gt;モジュール（標準Perl配布の一部）を実装する &lt;code&gt;ceil()&lt;/code&gt; 、 &lt;code&gt;floor()&lt;/code&gt; 、および他の数学的及び三角関数の数。</target>
        </trans-unit>
        <trans-unit id="eb81881ffc1ffa7659057b3aad0d531c1c255d43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module can also format a date as the day of the year or week of the year.</source>
          <target state="translated">&lt;a href=&quot;posix&quot;&gt;POSIXの&lt;/a&gt;モジュールはまた、今年の年または曜日と日付の書式を設定することができます。</target>
        </trans-unit>
        <trans-unit id="f19febd4ca12ddc4d78578d816e9ed0531d16d0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module makes extensive use of this type.</source>
          <target state="translated">&lt;a href=&quot;posix&quot;&gt;POSIXの&lt;/a&gt;モジュールは、この型を多用します。</target>
        </trans-unit>
        <trans-unit id="2b0fd33e8403b054935aab9d8ee0ab65dd34b689" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; module to alter behaviour and aid debugging.</source>
          <target state="translated">&lt;a href=&quot;re&quot;&gt;再の&lt;/a&gt; ALTER行動と援助デバッグするモジュール。</target>
        </trans-unit>
        <trans-unit id="cb49b0f767217eaf2addd5f51c9329970eca01df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sys/hostname&quot;&gt;Sys::Hostname&lt;/a&gt; module, part of the Standard Library, can also get the hostname:</source>
          <target state="translated">&lt;a href=&quot;sys/hostname&quot;&gt;Sys ::ホスト名&lt;/a&gt;モジュール、標準ライブラリの一部は、また、ホスト名を取得することができます：</target>
        </trans-unit>
        <trans-unit id="220edf79ba9ff4834b00c1168d4289b47c73eb1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;term/cap&quot;&gt;Term::Cap&lt;/a&gt; module can also get the special sequence if you want to deal with the low-level details of terminal control. The &lt;code&gt;Tputs&lt;/code&gt; method returns the string for the given capability:</source>
          <target state="translated">&lt;a href=&quot;term/cap&quot;&gt;ターム::キャップ&lt;/a&gt;あなたは、端末制御の低レベルの詳細に対処したい場合は、モジュールは、特別なシーケンスを得ることができます。 &lt;code&gt;Tputs&lt;/code&gt; メソッドは、指定された機能のための文字列を返します。</target>
        </trans-unit>
        <trans-unit id="e87c5439cafd856838e66bb969aac3bccda2430c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; modules are included in the core Perl distribution. Additionally, they are maintained as a separate modules on CPAN, so you can check there for any updates.</source>
          <target state="translated">&lt;a href=&quot;threads&quot;&gt;スレッド&lt;/a&gt;と&lt;a href=&quot;threads/shared&quot;&gt;スレッド::共有&lt;/a&gt;モジュールはコアPerl配布に含まれています。さらに、それらはCPAN上の個別のモジュールとして維持されるため、更新がないかどうかをそこで確認できます。</target>
        </trans-unit>
        <trans-unit id="2a9bb0674257a5140b5151993d5c3d3a37202400" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module provides the basic functions you need to write threaded programs. In the following sections, we'll cover the basics, showing you what you need to do to create a threaded program. After that, we'll go over some of the features of the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module that make threaded programming easier.</source>
          <target state="translated">&lt;a href=&quot;threads&quot;&gt;スレッドの&lt;/a&gt;モジュールを使用すると、スレッド化プログラムを作成するために必要な基本的な機能を提供します。次のセクションでは、基本をカバーし、スレッド化されたプログラムを作成するために必要なことを示します。その後、&lt;a href=&quot;threads&quot;&gt;スレッド&lt;/a&gt;化プログラミングを容易にするスレッドモジュールのいくつかの機能について説明します。</target>
        </trans-unit>
        <trans-unit id="2a739a40945ec3475dfa2806df561fe8eb1d910a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module provides the tools you need to create new threads. Like any other module, you need to tell Perl that you want to use it; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads;&lt;/code&gt; imports all the pieces you need to create basic threads.</source>
          <target state="translated">&lt;a href=&quot;threads&quot;&gt;スレッドの&lt;/a&gt;モジュールを使用すると、新しいスレッドを作成するために必要なツールを提供します。他のモジュールと同様に、使用することをPerlに指示する必要があります。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用し&lt;/a&gt;ます。基本的なスレッドを作成するために必要なすべての部分をインポートします。</target>
        </trans-unit>
        <trans-unit id="ac95afd4b80a6c32d7d4b6fc126fc11993d69484" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/gmtime&quot;&gt;Time::gmtime&lt;/a&gt; and &lt;a href=&quot;time/localtime&quot;&gt;Time::localtime&lt;/a&gt; modules provide a convenient, by-name access mechanism to the gmtime() and localtime() functions, respectively.</source>
          <target state="translated">&lt;a href=&quot;time/gmtime&quot;&gt;時間:: gmtimeは&lt;/a&gt;と&lt;a href=&quot;time/localtime&quot;&gt;時間:: localtimeの&lt;/a&gt;モジュールは、それぞれのgmtime（）やlocaltimeの（）関数に便利な、名前によるアクセス機構を提供します。</target>
        </trans-unit>
        <trans-unit id="27e7660ba02616c82b0460251677001be2bab8d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; module (part of the standard distribution as of Perl 5.8) measures time with the &lt;code&gt;gettimeofday()&lt;/code&gt; system call, which returns the time in microseconds since the epoch. If you can't install &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; for older Perls and you are on a Unixish system, you may be able to call &lt;code&gt;gettimeofday(2)&lt;/code&gt; directly. See &lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;time/hires&quot;&gt;時間::ハイレゾ&lt;/a&gt;モジュール（Perlの5.8のような標準的なディストリビューションの一部）を用いて時間を計測 &lt;code&gt;gettimeofday()&lt;/code&gt; エポックからマイクロ秒の時間を戻すシステムコール、。古いPerl用の&lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt;をインストールできず、Unixishシステムを使用している場合は、 &lt;code&gt;gettimeofday(2)&lt;/code&gt; を直接呼び出すことができる場合があります。&lt;a href=&quot;functions/syscall&quot;&gt;syscallを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="70cd112c1d983694e459a2b5affce0b2c176b5e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; module exports a new &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; that returns an object, and &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; exports the &lt;code&gt;ONE_DAY&lt;/code&gt; constant that is a set number of seconds. This means that it always gives the time 24 hours ago, which is not always yesterday. This can cause problems around the end of daylight saving time when there's one day that is 25 hours long.</source>
          <target state="translated">&lt;a href=&quot;time/piece&quot;&gt;時間::ワンピースの&lt;/a&gt;モジュールがエクスポート新しい &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; のオブジェクトを返し、&lt;a href=&quot;time/seconds&quot;&gt;タイム::秒の&lt;/a&gt;輸出 &lt;code&gt;ONE_DAY&lt;/code&gt; を設定した秒数である定数。これは、常に24時間前の時刻を提供することを意味しますが、昨日とは限りません。これにより、1日が25時間である夏時間の終わり頃に問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ad7b96811e1e0447b346c7c68b0b6f49a0e303ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; module, which comes with Perl, replaces &lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt; with a version that returns an object. It also overloads the comparison operators so you can compare them directly:</source>
          <target state="translated">&lt;a href=&quot;time/piece&quot;&gt;時間::ピース&lt;/a&gt;のPerlモジュールが付属していますが、置き換え&lt;a href=&quot;functions/localtime&quot;&gt;のlocaltimeを&lt;/a&gt;オブジェクトを返しバージョンで。また、比較演算子をオーバーロードして、直接比較できるようにします。</target>
        </trans-unit>
        <trans-unit id="7624d8ccf09fad70c6649ad6b1aa4fa701ecfb1c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-C&lt;/b&gt; flag controls some of the Perl Unicode features.</source>
          <target state="translated">&lt;b&gt;-C&lt;/b&gt;フラグ制御PerlのUnicodeの機能の一部。</target>
        </trans-unit>
        <trans-unit id="eeee1b2385aaa3798bce91466fcda51762a843eb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-C&lt;/b&gt; option only works if it is specified on the command line as well (with the same sequence of letters or numbers following). Either specify this option on the command line, or, if your system supports it, make your script executable and run it directly instead of passing it to perl.</source>
          <target state="translated">&lt;b&gt;-C&lt;/b&gt;それは（文字または数字以下の同じ配列を有する）だけでなく、コマンドラインで指定されている場合のオプションにのみ動作します。このオプションをコマンドラインで指定するか、システムがサポートしている場合は、スクリプトを実行可能にして、perlに渡す代わりに直接実行します。</target>
        </trans-unit>
        <trans-unit id="adbe88919d7c337e67d217e417ae52c5e78e86cc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-DL&lt;/b&gt; command-line switch is obsolete since circa Perl 5.6.0 (it was available only if Perl was built with &lt;code&gt;-DDEBUGGING&lt;/code&gt; ). The switch was used to track Perl's memory allocations and possible memory leaks. These days the use of malloc debugging tools like</source>
          <target state="translated">&lt;b&gt;-DL&lt;/b&gt;コマンドラインスイッチは、年頃のPerl 5.6.0（Perlはで構築された場合にのみ使用可能だったので廃止されました &lt;code&gt;-DDEBUGGING&lt;/code&gt; ）。このスイッチは、Perlのメモリ割り当てとメモリリークの可能性を追跡するために使用されていました。最近のようなmallocデバッグツールの使用</target>
        </trans-unit>
        <trans-unit id="7a02c2d05901d298065bac05eaefdaf89b098f1d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-a&lt;/b&gt; option followed by the name of a perl api function will extract the documentation of this function from &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;-a&lt;/b&gt; perlのAPI関数の名前が続くオプションがこの関数のドキュメントを抽出します&lt;a href=&quot;perlapi&quot;&gt;はperlapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7458f799f2d3bc9e0821f8f30b793deae5a843f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-f&lt;/b&gt; option followed by the name of a perl built-in function will extract the documentation of this function from &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;-f&lt;/b&gt;組み込み関数のperlの名前が続くオプションがこの関数のドキュメントを抽出します&lt;a href=&quot;perlfunc&quot;&gt;はperlfunc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1902e94f8bb188d5617c0fc133e4af994267a619" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-q&lt;/b&gt; option takes a regular expression as an argument. It will search the &lt;b&gt;q&lt;/b&gt;uestion headings in perlfaq[1-9] and print the entries matching the regular expression.</source>
          <target state="translated">&lt;b&gt;-q&lt;/b&gt;オプションは、引数として正規表現をとります。これは、検索する&lt;b&gt;q個の&lt;/b&gt; perlfaq [1-9]にuestion見出しおよび正規表現に一致するエントリを印刷します。</target>
        </trans-unit>
        <trans-unit id="5344e76d29fb1384ca26893a56599519b1faad07" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-v&lt;/b&gt; option followed by the name of a Perl predefined variable will extract the documentation of this variable from &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;-v&lt;/b&gt;のPerlの名前が続くオプションは、変数がこの変数のドキュメントを抽出しますあらかじめ定義&lt;a href=&quot;perlvar&quot;&gt;はperlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5ae0073660f495c2b0b0a5aff71edb22c20f2cb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-verbose&lt;/b&gt; flag first prints out the &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; introduction before any other diagnostics. The $diagnostics::PRETTY variable can generate nicer escape sequences for pagers.</source>
          <target state="translated">&lt;b&gt;-verbose&lt;/b&gt;フラグは、最初のプリントアウト&lt;a href=&quot;perldiag&quot;&gt;はperldiagの&lt;/a&gt;他の診断の前に導入を。$ diagnostics :: PRETTY変数は、ポケットベル用のより適切なエスケープシーケンスを生成できます。</target>
        </trans-unit>
        <trans-unit id="ceb38ecccfec93207c00c9dee183b84b32a5f056" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-w&lt;/b&gt; flag just sets the global &lt;code&gt;$^W&lt;/code&gt; variable as in 5.005. This means that any legacy code that currently relies on manipulating &lt;code&gt;$^W&lt;/code&gt; to control warning behavior will still work as is.</source>
          <target state="translated">&lt;b&gt;-w&lt;/b&gt;フラグは、単にグローバル設定 &lt;code&gt;$^W&lt;/code&gt; 5.005のように変数を。つまり、警告動作を制御するために現在 &lt;code&gt;$^W&lt;/code&gt; 操作に依存しているレガシーコードはすべて、そのまま機能します。</target>
        </trans-unit>
        <trans-unit id="72bbdbcc137e1ec7edde830d8069bcdc7d47c4dc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;AutoLoader&lt;/b&gt; is similar in purpose to &lt;b&gt;SelfLoader&lt;/b&gt;: both delay the loading of subroutines.</source>
          <target state="translated">&lt;b&gt;オートローダーは、&lt;/b&gt;と目的が類似している&lt;b&gt;のSelfLoader&lt;/b&gt;：両方の遅延サブルーチンのローディング。</target>
        </trans-unit>
        <trans-unit id="0f53ec7201e8a617c94e28662bed3af80a664f4d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;AutoLoader&lt;/b&gt; module works with the &lt;b&gt;AutoSplit&lt;/b&gt; module and the &lt;code&gt;__END__&lt;/code&gt; token to defer the loading of some subroutines until they are used rather than loading them all at once.</source>
          <target state="translated">&lt;b&gt;オートローダー&lt;/b&gt;とモジュールの動作&lt;b&gt;自動splitの&lt;/b&gt;モジュールと &lt;code&gt;__END__&lt;/code&gt; いくつかのサブルーチンのトークンに延期ロードは、彼らが一度にすべてをロードするのではなく、使用されるまで。</target>
        </trans-unit>
        <trans-unit id="93865b59868e970114227e97ec05c9ea3f594f39" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;ExtUtils::Embed&lt;/b&gt; kit on CPAN also contains all source code for the examples in this document, tests, additional examples and other information you may find useful.</source>
          <target state="translated">CPAN の&lt;b&gt;ExtUtils :: Embed&lt;/b&gt;キットには、このドキュメントの例のすべてのソースコード、テスト、追加の例、および役立つと思われるその他の情報も含まれています。</target>
        </trans-unit>
        <trans-unit id="d362af90dceed3d87816d0dcbc3d699668f7c9c9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;IO&lt;/b&gt; extension, &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;IOの&lt;/b&gt;延長、&lt;a href=&quot;perlfunc&quot;&gt;perlfuncの&lt;/a&gt;、&lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;はperlopでI / O演算子&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4ddb503abc843b9ef214b377226c71b441a111a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Pod::Hyperlink&lt;/b&gt; class is mainly designed to parse the contents of the &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; sequence, providing a simple interface for accessing the different parts of a POD hyperlink for further processing. It can also be used to construct hyperlinks.</source>
          <target state="translated">&lt;b&gt;ポッド::ハイパーリンクの&lt;/b&gt;クラスは、主の内容解析するために設計されて &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; さらに処理するためにPODハイパーリンクのさまざまな部分にアクセスするためのシンプルなインターフェイスを提供する、シーケンスを。ハイパーリンクを作成するためにも使用できます。</target>
        </trans-unit>
        <trans-unit id="159cbd250976e52bd0b54f9fbb2c920f60501cf2" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; can replace the AutoLoader - just change 'use AutoLoader' to 'use SelfLoader' (though note that the &lt;b&gt;SelfLoader&lt;/b&gt; exports the AUTOLOAD function - but if you have your own AUTOLOAD and are using the AutoLoader too, you probably know what you're doing), and the &lt;code&gt;__END__&lt;/code&gt; token to &lt;code&gt;__DATA__&lt;/code&gt; . You will need perl version 5.001m or later to use this (version 5.001 with all patches up to patch m).</source>
          <target state="translated">&lt;b&gt;SelfLoaderは、&lt;/b&gt;オートローダーを置き換えることができます- 「使用のSelfLoader」（ノートしかしそれにだけ変更「使用オートローダー」&lt;b&gt;のSelfLoader&lt;/b&gt;輸出AUTOLOAD機能-しかし、あなたはあなた自身のAUTOLOADを持って、あまりにもオートローダーを使用している場合、あなたはおそらく、あなたがしているものを知っています）やって、そして &lt;code&gt;__END__&lt;/code&gt; にトークン &lt;code&gt;__DATA__&lt;/code&gt; 。これを使用するには、perlバージョン5.001m以降が必要です（バージョン5.001からパッチmまでのすべてのパッチ）。</target>
        </trans-unit>
        <trans-unit id="9cc1e94494f4935e31dcd4aca4dd8097e05b3034" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; exports the &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine to the package using the &lt;b&gt;SelfLoader&lt;/b&gt;, and this loads the called subroutine when it is first called.</source>
          <target state="translated">&lt;b&gt;SelfLoaderは&lt;/b&gt;エクスポート &lt;code&gt;AUTOLOAD&lt;/code&gt; の使用して、パッケージにサブルーチンを&lt;b&gt;のSelfLoaderを&lt;/b&gt;、それが最初に呼び出されると呼ばれるサブルーチンを、このロード。</target>
        </trans-unit>
        <trans-unit id="be3fad23fb52579393cf97f6d16c823542fd3d2f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; reads from wherever the current position of the &lt;code&gt;FOOBAR::DATA&lt;/code&gt; filehandle is, until the EOF or &lt;code&gt;__END__&lt;/code&gt; . This means that if you want to use that filehandle (and ONLY if you want to), you should either</source>
          <target state="translated">&lt;b&gt;SelfLoaderは、&lt;/b&gt;現在の位置をどこから読み込む &lt;code&gt;FOOBAR::DATA&lt;/code&gt; ファイルハンドルはEOFまで、または、ある &lt;code&gt;__END__&lt;/code&gt; 。これは、そのファイルハンドルを使用したい場合（そして使用したい場合のみ）、</target>
        </trans-unit>
        <trans-unit id="0f59147d20cbbd96eaf3ce69c4654c447143a93e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; will read from the FOOBAR::DATA filehandle to load in the data after &lt;code&gt;__DATA__&lt;/code&gt; , and load in any subroutine when it is called. The costs are the one-time parsing of the data after &lt;code&gt;__DATA__&lt;/code&gt; , and a load delay for the _first_ call of any autoloaded function. The benefits (hopefully) are a speeded up compilation phase, with no need to load functions which are never used.</source>
          <target state="translated">&lt;b&gt;SelfLoaderは、&lt;/b&gt;後のデータで負荷へ:: FOOBARからのデータファイルハンドルを読み込みます &lt;code&gt;__DATA__&lt;/code&gt; 、それが呼び出された任意のサブルーチンでロード。コストは、 &lt;code&gt;__DATA__&lt;/code&gt; の後のデータの1回限りの解析、およびオートロードされた関数の_first_呼び出しのロード遅延です。利点は（うまくいけば）使用されない関数をロードする必要がないため、コンパイルフェーズが高速化されることです。</target>
        </trans-unit>
        <trans-unit id="b9076a846b441722c5113e39b9bcd0673ac55d99" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; will stop reading from &lt;code&gt;__DATA__&lt;/code&gt; if it encounters the &lt;code&gt;__END__&lt;/code&gt; token - just as you would expect. If the &lt;code&gt;__END__&lt;/code&gt; token is present, and is followed by the token DATA, then the &lt;b&gt;SelfLoader&lt;/b&gt; leaves the FOOBAR::DATA filehandle open on the line after that token.</source>
          <target state="translated">&lt;b&gt;SelfLoaderは&lt;/b&gt;からの読み取りを停止します &lt;code&gt;__DATA__&lt;/code&gt; それが発生した場合、 &lt;code&gt;__END__&lt;/code&gt; あなたが期待するのと同じように-トークンを。場合 &lt;code&gt;__END__&lt;/code&gt; のトークンが存在し、トークンのDATAが続き、その後&lt;b&gt;のSelfLoader&lt;/b&gt;葉FOOBAR ::そのトークンの後の行のデータがファイルハンドル開きました。</target>
        </trans-unit>
        <trans-unit id="ae4ca9e2af773bc53d6ebfbbbcbbb68e0e663b29" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; works by the user placing the &lt;code&gt;__DATA__&lt;/code&gt; token</source>
          <target state="translated">&lt;b&gt;SelfLoaderは&lt;/b&gt;置く、ユーザによって動作します &lt;code&gt;__DATA__&lt;/code&gt; トークンを</target>
        </trans-unit>
        <trans-unit id="b8a45570c1acb4c43b6a7805f6337844a9606503" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; works similarly to the AutoLoader, but picks up the subs from after the &lt;code&gt;__DATA__&lt;/code&gt; instead of in the 'lib/auto' directory. There is a maintenance gain in not needing to run AutoSplit on the module at installation, and a runtime gain in not needing to keep opening and closing files to load subs. There is a runtime loss in needing to parse the code after the &lt;code&gt;__DATA__&lt;/code&gt; . Details of the &lt;b&gt;AutoLoader&lt;/b&gt; and another view of these distinctions can be found in that module's documentation.</source>
          <target state="translated">&lt;b&gt;SelfLoaderは、&lt;/b&gt;オートローダーと同様に動作しますが、後から潜水艦までピック &lt;code&gt;__DATA__&lt;/code&gt; の代わりに、「libに/オート」ディレクトリインチ インストール時にモジュールでAutoSplitを実行する必要がないことでメンテナンスが向上し、サブファイルをロードするためにファイルを開いたり閉じたりし続ける必要がないことでランタイムが向上します。 &lt;code&gt;__DATA__&lt;/code&gt; の後にコードを解析する必要があるため、ランタイムが失われます。&lt;b&gt;オートローダーの&lt;/b&gt;詳細とこれらの違いの別の見方は、そのモジュールのドキュメントにあります。</target>
        </trans-unit>
        <trans-unit id="94dafc36f54a138d4c7c8beed77372c0b7d94298" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::Array&lt;/b&gt; implementation is a stub that simply croaks.</source>
          <target state="translated">&lt;b&gt;タイ::配列の&lt;/b&gt;実装は単にcroaksスタブです。</target>
        </trans-unit>
        <trans-unit id="6b199766c781a0ae9ebeafd1ad9efb33847e8a69" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::Hash&lt;/b&gt; implementation is a stub that simply croaks.</source>
          <target state="translated">&lt;b&gt;タイ::ハッシュ&lt;/b&gt;実装は単にcroaksスタブです。</target>
        </trans-unit>
        <trans-unit id="4134fa729bc36043c1bbc4226f0d69bd4bd166dc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::StdArray&lt;/b&gt; package provides efficient methods required for tied arrays which are implemented as blessed references to an &quot;inner&quot; perl array. It inherits from &lt;b&gt;Tie::Array&lt;/b&gt;, and should cause tied arrays to behave exactly like standard arrays, allowing for selective overloading of methods.</source>
          <target state="translated">&lt;b&gt;タイ:: StdArrayの&lt;/b&gt;パッケージは、「内側」Perlの配列に恵まれ参照として実装されて結ばアレイに必要な効率的な方法を提供します。これは&lt;b&gt;Tie :: Array&lt;/b&gt;から継承し、タイド配列が標準配列とまったく同じように動作するようにし、メソッドの選択的なオーバーロードを可能にします。</target>
        </trans-unit>
        <trans-unit id="61ae2de46d00875a51e425357ad71e5ccdd2ad38" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::StdHandle&lt;/b&gt; package provide most methods for file handles described in &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; (the exceptions are &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; ). It causes tied file handles to behave exactly like standard file handles and allow for selective overwriting of methods.</source>
          <target state="translated">&lt;b&gt;タイ:: StdHandle&lt;/b&gt;パッケージはで説明したファイルハンドルのためのほとんどのメソッドを提供&lt;a href=&quot;../perltie&quot;&gt;perltieやを&lt;/a&gt;（例外はある &lt;code&gt;UNTIE&lt;/code&gt; や &lt;code&gt;DESTROY&lt;/code&gt; ）。これにより、結合されたファイルハンドルが標準のファイルハンドルとまったく同じように動作し、メソッドを選択的に上書きできます。</target>
        </trans-unit>
        <trans-unit id="eacf0e41a2a5258a61ae34656b72764dd7acc141" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::SubstrHash&lt;/b&gt; package provides a hash-table-like interface to an array of determinate size, with constant key size and record size.</source>
          <target state="translated">&lt;b&gt;タイ:: SubstrHash&lt;/b&gt;パッケージは、一定のキーサイズとレコードサイズの確定サイズのアレイにハッシュテーブルのようなインターフェイスを提供します。</target>
        </trans-unit>
        <trans-unit id="a8a3a1e60f743e1378ee92d392f9857036d4b3d2" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;begincheck&lt;/b&gt; program makes it all clear, eventually:</source>
          <target state="translated">&lt;b&gt;begincheckの&lt;/b&gt;プログラムは最終的に、それはすべて明らかに：</target>
        </trans-unit>
        <trans-unit id="1112db1b82f4fc99681fd70d53f56d13ced227cf" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;encoding&lt;/b&gt; pragma changes this to use the specified encoding instead. For example:</source>
          <target state="translated">&lt;b&gt;エンコーディング&lt;/b&gt;プラグマは、これは指定された代わりに、エンコードを使用するように変更します。例えば：</target>
        </trans-unit>
        <trans-unit id="b7162377ab2247a065b27f7ed4e48c5d078da511" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;encoding&lt;/b&gt; pragma works by decoding string literals in &lt;code&gt;q//,qq//,qr//,qw///, qx//&lt;/code&gt; and so forth. In perl v5.8.0, this does not apply to &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. Therefore,</source>
          <target state="translated">&lt;b&gt;エンコーディング&lt;/b&gt;プラグマは、中に文字列リテラルをデコードすることによって動作します &lt;code&gt;q//,qq//,qr//,qw///, qx//&lt;/code&gt; など。perl v5.8.0では、これは &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; は適用されません。したがって、</target>
        </trans-unit>
        <trans-unit id="80faef413c7207aab71b9f1d03988df6331ef791" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;file&lt;/b&gt; (or &lt;b&gt;string&lt;/b&gt;, in the case of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;) that is currently being &lt;b&gt;compiled&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;ファイル&lt;/b&gt;（または&lt;b&gt;文字列&lt;/b&gt;の場合は、 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; を現在されている）&lt;b&gt;にコンパイル&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="bb5cf33051195df3d457e45e85209f2138dc4a05" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;first time&lt;/b&gt; the hook is hit in a serialization flow, you may have it return an empty list. That will signal the Storable engine to further discard that hook for this class and to therefore revert to the default serialization of the underlying Perl data. The hook will again be normally processed in the next serialization.</source>
          <target state="translated">&lt;b&gt;初めて&lt;/b&gt;のフックは、直列化の流れにヒットしたが、あなたはそれが空のリストを返す必要があります。これは、Storableエンジンに、このクラスのフックをさらに破棄するように通知し、その結果、基礎となるPerlデータのデフォルトの直列化に戻ります。フックは再び次のシリアライゼーションで通常どおり処理されます。</target>
        </trans-unit>
        <trans-unit id="31b896e0d53803b62960180dd945e43dfa7f81e7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;garbage collection&lt;/b&gt; of globals (and the running of any associated object destructors) that takes place when a Perl &lt;b&gt;interpreter&lt;/b&gt; is being shut down. Global destruction should not be confused with the Apocalypse, except perhaps when it should.</source>
          <target state="translated">Perl &lt;b&gt;インタープリター&lt;/b&gt;がシャットダウンされるときに行われるグローバルの&lt;b&gt;ガベージコレクション&lt;/b&gt;（および関連するオブジェクトデストラクタの実行）。地球規模の破壊は、おそらくそれが必要な場合を除いて、黙示録と混同されるべきではありません。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="987526f88e29534e7fb822b3987e499066378921" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;grouping&lt;/b&gt; metacharacters &lt;code&gt;()&lt;/code&gt; allow a part of a regex to be treated as a single unit. Parts of a regex are grouped by enclosing them in parentheses. The regex &lt;code&gt;house(cat|keeper)&lt;/code&gt; means match &lt;code&gt;house&lt;/code&gt; followed by either &lt;code&gt;cat&lt;/code&gt; or &lt;code&gt;keeper&lt;/code&gt; . Some more examples are</source>
          <target state="translated">&lt;b&gt;グルーピング&lt;/b&gt;メタ文字 &lt;code&gt;()&lt;/code&gt; は、正規表現の一部は、単一のユニットとして扱うことを可能にします。正規表現の一部は、括弧で囲むことによりグループ化されます。regex &lt;code&gt;house(cat|keeper)&lt;/code&gt; は、マッチ &lt;code&gt;house&lt;/code&gt; 後に &lt;code&gt;cat&lt;/code&gt; または &lt;code&gt;keeper&lt;/code&gt; が続くことを意味します。さらにいくつかの例は</target>
        </trans-unit>
        <trans-unit id="ba87bd98015a685039202791b8b4c178941ed0ba" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;interpolation&lt;/b&gt; of a scalar or array variable into a string.</source>
          <target state="translated">文字列へのスカラーまたは配列変数の&lt;b&gt;補間&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="fd9fd954815d11416f915389911ed3472be1a48a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;new()&lt;/b&gt; method can either be passed a set of key/value pairs or a single scalar value, namely the contents of a &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; sequence. An object of the class &lt;code&gt;Pod::Hyperlink&lt;/code&gt; is returned. The value &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; indicates a failure, the error message is stored in &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;新しい（）&lt;/b&gt;メソッドは、いずれかのキー/値ペアのセットまたは単一のスカラー値、すなわち内容渡すことができ &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 配列。クラス &lt;code&gt;Pod::Hyperlink&lt;/code&gt; のオブジェクトが返されます。値 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; は失敗を示し、エラーメッセージは &lt;code&gt;$@&lt;/code&gt; 格納されます。</target>
        </trans-unit>
        <trans-unit id="22dcd0ec3aed7a2c1842ef98e2374e061c59b868" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;package&lt;/b&gt; in which the current statement is &lt;b&gt;compiled&lt;/b&gt;. Scan backward in the text of your program through the current &lt;b&gt;lexical scope&lt;/b&gt; or any enclosing lexical scopes until you find a package declaration. That&amp;rsquo;s your current package name.</source>
          <target state="translated">&lt;b&gt;パッケージ&lt;/b&gt;現在の文がされている&lt;b&gt;コンパイル&lt;/b&gt;。パッケージ宣言が見つかるまで、現在の&lt;b&gt;字句スコープ&lt;/b&gt;またはそれを囲む字句スコープを介して、プログラムのテキストを逆方向にスキャンします。これが現在のパッケージ名です。</target>
        </trans-unit>
        <trans-unit id="837534d7853b1df8d6be64303da76d4fb655fe6c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parse_text()&lt;/b&gt; method takes a given paragraph of text, and returns a parse-tree that contains one or more children, each of which may be a text-string, or an InteriorSequence object. There are also callback-options that may be passed to &lt;b&gt;parse_text()&lt;/b&gt; to customize the way it expands or transforms interior-sequences, as well as the returned result. These callbacks can be used to create a parse-tree with custom-made objects (which may or may not support the parse-tree interface, depending on how you choose to do it).</source>
          <target state="translated">&lt;b&gt;parse_text（）&lt;/b&gt;メソッドは、テキストの指定された段落を受け取り、テキスト文字列、またはInteriorSequenceオブジェクトであってもよいそれぞれが一つ以上の子供を含み、構文解析木を返します。&lt;b&gt;parse_text（）&lt;/b&gt;に渡すことができるコールバックオプションもあり、内部シーケンスの拡張または変換方法と、返される結果をカスタマイズします。これらのコールバックを使用して、カスタムメイドのオブジェクトを使用して解析ツリーを作成できます（選択した方法に応じて、解析ツリーインターフェイスをサポートする場合としない場合があります）。</target>
        </trans-unit>
        <trans-unit id="b2fcda0a32417727cdd721f28d0c908b93bc1f19" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;perlivp&lt;/b&gt; program is set up at Perl source code build time to test the Perl version it was built under. It can be used after running:</source>
          <target state="translated">&lt;b&gt;perlivpの&lt;/b&gt;プログラムは、それがもとで構築されたPerlのバージョンをテストするためのPerlソースコードのビルド時に設定されています。実行後に使用できます：</target>
        </trans-unit>
        <trans-unit id="dc37ad02e0c6923bebd0d4430ccd02307461404f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;podchecker&lt;/b&gt; command is provided for checking Pod syntax for errors and warnings. For example, it checks for completely blank lines in Pod blocks and for unknown commands and formatting codes. You should still also pass your document through one or more translators and proofread the result, or print out the result and proofread that. Some of the problems found may be bugs in the translators, which you may or may not wish to work around.</source>
          <target state="translated">&lt;b&gt;podcheckerの&lt;/b&gt;コマンドは、エラーと警告のためのポッドの構文をチェックするために提供されます。たとえば、Podブロック内の完全に空白の行や、不明なコマンドやフォーマットコードをチェックします。文書を1人以上の翻訳者に渡して結果を校正するか、結果を印刷して校正する必要もあります。見つかった問題の一部は、翻訳者のバグである可能性があり、回避するかどうかは問題ではありません。</target>
        </trans-unit>
        <trans-unit id="d299b97d8bab37b1330370eb9473b8a413d005a5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;quantifier&lt;/b&gt; metacharacters &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , and &lt;code&gt;{}&lt;/code&gt; allow us to determine the number of repeats of a portion of a regex we consider to be a match. Quantifiers are put immediately after the character, character class, or grouping that we want to specify. They have the following meanings:</source>
          <target state="translated">&lt;b&gt;数量詞の&lt;/b&gt;メタ文字 &lt;code&gt;?&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;+&lt;/code&gt; 、および &lt;code&gt;{}&lt;/code&gt; により、一致と見なす正規表現の一部の繰り返し数を決定できます。数量詞は、指定する文字、文字クラス、またはグループの直後に配置されます。それらの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9b54e7f659f70ec7a4f3708e917b8834ab10ef21" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;scalar values&lt;/b&gt; that you supply to a &lt;b&gt;function&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt; when you call it. For instance, when you call &lt;code&gt;power(&quot;puff&quot;)&lt;/code&gt; , the string &lt;code&gt;&quot;puff&quot;&lt;/code&gt; is the actual argument. See also &lt;b&gt;argument&lt;/b&gt; and &lt;b&gt;formal arguments&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;スカラー値&lt;/b&gt;あなたに供給していること&lt;b&gt;の機能&lt;/b&gt;または&lt;b&gt;サブルーチン&lt;/b&gt;あなたはそれを呼び出します。たとえば、 &lt;code&gt;power(&quot;puff&quot;)&lt;/code&gt; を呼び出すと、文字列 &lt;code&gt;&quot;puff&quot;&lt;/code&gt; が実際の引数になります。「&lt;b&gt;引数」&lt;/b&gt;および「&lt;b&gt;仮引数&lt;/b&gt;」も参照してください。</target>
        </trans-unit>
        <trans-unit id="4a023f0632e523744570838f6670cc7a9e367c0e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sigtrap&lt;/b&gt; pragma is a simple interface to installing signal handlers. You can have it install one of two handlers supplied by &lt;b&gt;sigtrap&lt;/b&gt; itself (one which provides a Perl stack trace and one which simply &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;s), or alternately you can supply your own handler for it to install. It can be told only to install a handler for signals which are either untrapped or ignored. It has a couple of lists of signals to trap, plus you can supply your own list of signals.</source>
          <target state="translated">&lt;b&gt;SIGTRAPの&lt;/b&gt;プラグマはシグナルハンドラをインストールする簡単なインターフェースです。&lt;b&gt;sigtrap&lt;/b&gt;自体が提供する2つのハンドラーの1つ（P​​erlスタックトレースを提供するハンドラーと単に &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; を提供するハンドラー）のいずれかをインストールすることも、独自のハンドラーを指定してインストールすることもできます。トラップされないか無視されるシグナルのハンドラをインストールするように指示することができます。トラップする信号のリストがいくつかあります。さらに、独自の信号のリストを提供できます。</target>
        </trans-unit>
        <trans-unit id="d7c162ba3d4340b1ed67afae232423e0f505fd2b" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;value&lt;/b&gt; produced by a &lt;b&gt;subroutine&lt;/b&gt; or &lt;b&gt;expression&lt;/b&gt; when evaluated. In Perl, a return value may be either a &lt;b&gt;list&lt;/b&gt; or a &lt;b&gt;scalar&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;値は、&lt;/b&gt;によって生成される&lt;b&gt;サブルーチン&lt;/b&gt;又は&lt;b&gt;発現&lt;/b&gt;を評価します。Perlでは、戻り値は&lt;b&gt;リスト&lt;/b&gt;または&lt;b&gt;スカラーの&lt;/b&gt;いずれかです。</target>
        </trans-unit>
        <trans-unit id="7487920171bd7708f5f44fcbcd3a51b3cd669ff9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;value&lt;/b&gt; returned to the parent &lt;b&gt;process&lt;/b&gt; when one of its child processes dies. This value is placed in the special variable &lt;code&gt;$?&lt;/code&gt; . Its upper eight &lt;b&gt;bits&lt;/b&gt; are the exit status of the defunct process, and its lower eight bits identify the signal (if any) that the process died from. On Unix systems, this status value is the same as the status word returned by</source>
          <target state="translated">&lt;b&gt;値は&lt;/b&gt;、親に戻った&lt;b&gt;プロセス&lt;/b&gt;の子プロセスダイの一つ。この値は、特殊変数 &lt;code&gt;$?&lt;/code&gt; に入れられます。。上位8 &lt;b&gt;ビット&lt;/b&gt;は無効プロセスの終了ステータスであり、下位8ビットはプロセスが停止したシグナル（存在する場合）を識別します。Unixシステムでは、このステータス値は、によって返されるステータスワードと同じです。</target>
        </trans-unit>
        <trans-unit id="f75f87bdfa0eb35c4f5fe0a1642de1f3532d7289" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;values&lt;/b&gt; you supply along with a program name when you tell a &lt;b&gt;shell&lt;/b&gt; to execute a &lt;b&gt;command&lt;/b&gt;. These values are passed to a Perl program through &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;値は、&lt;/b&gt;あなたが教えてくれたときには、プログラム名と一緒に供給する&lt;b&gt;シェルを&lt;/b&gt;実行する&lt;b&gt;コマンドを&lt;/b&gt;。これらの値は &lt;code&gt;@ARGV&lt;/code&gt; を介してPerlプログラムに渡されます。</target>
        </trans-unit>
        <trans-unit id="8215a7b783f151c4ff06cfd84ff859eb48442e77" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;word anchor&lt;/b&gt;&lt;code&gt;\b&lt;/code&gt; matches a boundary between a word character and a non-word character &lt;code&gt;\w\W&lt;/code&gt; or &lt;code&gt;\W\w&lt;/code&gt; :</source>
          <target state="translated">&lt;b&gt;ワードアンカー&lt;/b&gt; &lt;code&gt;\b&lt;/code&gt; 単語文字と非単語文字との間の境界と一致し &lt;code&gt;\w\W&lt;/code&gt; または &lt;code&gt;\W\w&lt;/code&gt; ：を</target>
        </trans-unit>
        <trans-unit id="98df2a206a33c61c05323edbf28b990dfe8bb9b6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;xsubpp&lt;/b&gt; program takes the XS code in the .xs file and translates it into C code, placing it in a file whose suffix is .c. The C code created makes heavy use of the C functions within Perl.</source>
          <target state="translated">&lt;b&gt;xsubppの&lt;/b&gt;プログラムは.xsファイル内のXSコードを取り、そのサフィックス.Cあるファイルにそれを置く、Cコードに変換します。作成されたCコードは、Perl内のC関数を多用します。</target>
        </trans-unit>
        <trans-unit id="e9db711485ba959f3d0b453c931365b6638809a5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;xsubpp&lt;/b&gt; program uses rules to convert from Perl's data types (scalar, array, etc.) to C's data types (int, char, etc.). These rules are stored in the typemap file ($PERLLIB/ExtUtils/typemap). There's a brief discussion below, but all the nitty-gritty details can be found in &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;. If you have a new-enough version of perl (5.16 and up) or an upgraded XS compiler (&lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 3.13_01 or better), then you can inline typemaps in your XS instead of writing separate files. Either way, this typemap thing is split into three parts:</source>
          <target state="translated">&lt;b&gt;xsubppの&lt;/b&gt; Perlのデータ型Cのデータ・タイプ（整数、文字など）（スカラ、アレイ、等）へ変換するプログラムの使用規則。これらのルールは、タイプマップファイル（$ PERLLIB / ExtUtils / typemap）に格納されます。以下に簡単な説明がありますが、重要な詳細はすべて&lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemapにあり&lt;/a&gt;ます。新しいバージョンのperl（5.16以降）またはアップグレードされたXSコンパイラ（ &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 3.13_01以上）を使用している場合は、個別のファイルを作成する代わりに、XSにタイプマップをインライン化できます。どちらにしても、このタイプマップは3つの部分に分かれています。</target>
        </trans-unit>
        <trans-unit id="1082cc04157e373604ca98ab1606eeb58e2bd5d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt; $output &lt;/code&gt; argument may be:</source>
          <target state="translated">&lt;code&gt; $output &lt;/code&gt; 引数は次のようになります。</target>
        </trans-unit>
        <trans-unit id="fe02d79593918e0f0b57f9efa92b9388e3573b1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;)&quot;&lt;/code&gt; is out-of-place. Something apparently was supposed to be combined with the digits, or the &lt;code&gt;&quot;+&quot;&lt;/code&gt; shouldn't be there, or something like that. Perl can't figure out what was intended.</source>
          <target state="translated">&lt;code&gt;&quot;)&quot;&lt;/code&gt; アウトオブプレースです。明らかに数字と組み合わせることが想定されていたもの、または &lt;code&gt;&quot;+&quot;&lt;/code&gt; がそこにあるべきではない、またはそのようなものです。Perlは意図されたものを理解できません。</target>
        </trans-unit>
        <trans-unit id="54034a923125cadab60eef06f26fcb91d4e7c351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;+&quot;&lt;/code&gt; is valid only when followed by digits, indicating a capturing group. See &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(?PARNO)&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;+&quot;&lt;/code&gt; 捕捉基を示し、数字が続く場合にのみ有効です。&lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;（？PARNO）を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="07bb712ac114a7fe219229eb5a67b484b3ca58ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;?&quot;&lt;/code&gt; and &lt;code&gt;&quot;+&quot;&lt;/code&gt; don't have any effect, as they modify whether to match more or fewer when there is a choice, and by specifying to match exactly a given numer, there is no room left for a choice.</source>
          <target state="translated">&lt;code&gt;&quot;?&quot;&lt;/code&gt; そして &lt;code&gt;&quot;+&quot;&lt;/code&gt; の選択肢があるとき、彼らはより多くのまたはより少ないと一致するかどうかを修正するよう、任意の効果を持っていない、と正確に与えられたNUMERと一致するように指定することで、選択のために残さ余地はありません。</target>
        </trans-unit>
        <trans-unit id="622f5262d7227133a18718033006d1fe595c3150" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;U&quot;&lt;/code&gt; template has been ported to mean &quot;Unicode&quot; on all platforms so that</source>
          <target state="translated">&lt;code&gt;&quot;U&quot;&lt;/code&gt; ようにテンプレートは、すべてのプラットフォームで「ユニコード」を意味するように移植されました</target>
        </trans-unit>
        <trans-unit id="d9a4c62629e10d33b540e16fc1ce8f7a3f41635f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;\x&quot;&lt;/code&gt; construct without curly braces should be followed by exactly two hex digits; this one is followed by three. This currently evaluates as equivalent to</source>
          <target state="translated">&lt;code&gt;&quot;\x&quot;&lt;/code&gt; 中括弧なしの構築物は、正確に二桁の数字が続くべきです。これには3つ続きます。これは現在、以下と同等と評価されます</target>
        </trans-unit>
        <trans-unit id="18a8e19a030c3c8f53e48396122990cc28295c5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;a&quot;&lt;/code&gt; is a valid modifier flag, but the &lt;code&gt;&quot;n&quot;&lt;/code&gt; is not, and raises this error. Likely what was meant instead was:</source>
          <target state="translated">&lt;code&gt;&quot;a&quot;&lt;/code&gt; 有効な修飾フラグですが、 &lt;code&gt;&quot;n&quot;&lt;/code&gt; ないが、このエラーが発生します。代わりに意味された可能性が高かったのは：</target>
        </trans-unit>
        <trans-unit id="14e2e8dae7c922be26733e3e660b25612cc5ce26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;c&quot;&lt;/code&gt; and &lt;code&gt;&quot;C&quot;&lt;/code&gt; templates for &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; are dependent upon character set encoding. Examples of usage on EBCDIC include:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&quot;c&quot;&lt;/code&gt; および &lt;code&gt;&quot;C&quot;&lt;/code&gt; テンプレートは、文字セットのエンコーディングに依存しています。EBCDICでの使用例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5c8f5308cfb898e8f57b9a7b021b28f517778138" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;code&quot;&lt;/code&gt; subroutine will only be used to filter parts of the source code that are not quotelikes, POD, or &lt;code&gt;__DATA__&lt;/code&gt; . The &lt;code&gt;quotelike&lt;/code&gt; subroutine only filters Perl quotelikes (including here documents).</source>
          <target state="translated">&lt;code&gt;&quot;code&quot;&lt;/code&gt; サブルーチンのみquotelikes、POD、又はないソースコードのフィルタ部品に使用される &lt;code&gt;__DATA__&lt;/code&gt; 。 &lt;code&gt;quotelike&lt;/code&gt; のサブルーチンは（ヒアドキュメントを含む）のPerl quotelikesをフィルタリングします。</target>
        </trans-unit>
        <trans-unit id="de5cb8ed1d57c1871e5453eb580a0076b635dfd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; pragma</source>
          <target state="translated">&lt;code&gt;&quot;use locale&quot;&lt;/code&gt; プラグマ</target>
        </trans-unit>
        <trans-unit id="5361c21bc61e8999f4b7544ffeef33e12b0b1a2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#!&lt;/code&gt; line is always examined for switches as the line is being parsed. Thus, if you're on a machine that allows only one argument with the &lt;code&gt;#!&lt;/code&gt; line, or worse, doesn't even recognize the &lt;code&gt;#!&lt;/code&gt; line, you still can get consistent switch behaviour regardless of how Perl was invoked, even if &lt;b&gt;-x&lt;/b&gt; was used to find the beginning of the program.</source>
          <target state="translated">&lt;code&gt;#!&lt;/code&gt; ラインが解析されている間、ラインは常にスイッチについて検査されます。したがって、 &lt;code&gt;#!&lt;/code&gt; で引数を1つだけ許可するマシンを使用している場合は、行、またはさらに悪いことに、 &lt;code&gt;#!&lt;/code&gt; も認識しません。&lt;b&gt;-x&lt;/b&gt;を使用してプログラムの先頭を検索した場合でも、Perlの起動方法に関係なく、一貫したスイッチ動作を得ることができます。</target>
        </trans-unit>
        <trans-unit id="4fb2868e39025eacf0d00ec1478ba8ee01a99e7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$VERSION&lt;/code&gt; variable is used to ensure that the .pm file and the shared library are &quot;in sync&quot; with each other. Any time you make changes to the .pm or .xs files, you should increment the value of this variable.</source>
          <target state="translated">&lt;code&gt;$VERSION&lt;/code&gt; 変数が.PMファイルと共有ライブラリがお互いに「同期」していることを確認するために使用されます。.pmファイルまたは.xsファイルに変更を加える場合は常に、この変数の値を増分する必要があります。</target>
        </trans-unit>
        <trans-unit id="2ee72eb90ddce6bbc0931d4e233b1341c5327087" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$^O&lt;/code&gt; variable (&lt;code&gt;$OSNAME&lt;/code&gt; if you use &lt;code&gt;English&lt;/code&gt; ) contains an indication of the name of the operating system (not its release number) that your perl binary was built for.</source>
          <target state="translated">&lt;code&gt;$^O&lt;/code&gt; 変数（ &lt;code&gt;$OSNAME&lt;/code&gt; あなたが使用している場合 &lt;code&gt;English&lt;/code&gt; ）あなたのperlバイナリがために建てられたことをオペレーティングシステム（ないそのリリース番号）の名前の表示を含みます。</target>
        </trans-unit>
        <trans-unit id="d2aab00569329bab82f1ebc14faa8b668168dc31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$^O&lt;/code&gt; variable and the &lt;code&gt;$Config{archname}&lt;/code&gt; values for various DOSish perls are as follows:</source>
          <target state="translated">さまざまなDOSish perl の &lt;code&gt;$^O&lt;/code&gt; 変数と &lt;code&gt;$Config{archname}&lt;/code&gt; 値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="eba7fdbb831c55f9a441c12e1806775b9e1de0a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$array[1]&lt;/code&gt; is a single-element access to the array. It's going to return the item in index 1 (or undef if there is no item there). If you intend to get exactly one element from the array, this is the form you should use.</source>
          <target state="translated">&lt;code&gt;$array[1]&lt;/code&gt; 、アレイへの単一の要素へのアクセスです。インデックス1の項目を返します（そこに項目がない場合はundef）。配列から要素を1つだけ取得する場合は、これを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="2844c7d661123084d4f84dec0ab13e6bfc03da52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter can either be a scalar or a scalar reference.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; パラメータは、いずれかのスカラーまたはスカラー参照することができます。</target>
        </trans-unit>
        <trans-unit id="27274181277155f678e99b9a2b287e41860c82ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter can either be a scalar or a scalar reference. The contents of the &lt;code&gt;$buffer&lt;/code&gt; parameter are destroyed after calling this function.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; パラメータは、いずれかのスカラーまたはスカラー参照することができます。 &lt;code&gt;$buffer&lt;/code&gt; パラメータの内容は、この関数を呼び出した後に破棄されます。</target>
        </trans-unit>
        <trans-unit id="8c4fb1959a7d1bef1019739dc5a4ea212bbc1a3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter is modified by &lt;code&gt;inflate&lt;/code&gt; . On completion it will contain what remains of the input buffer after inflation. This means that &lt;code&gt;$buffer&lt;/code&gt; will be an empty string when the return status is &lt;code&gt;Z_OK&lt;/code&gt; . When the return status is &lt;code&gt;Z_STREAM_END&lt;/code&gt; the &lt;code&gt;$buffer&lt;/code&gt; parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; パラメータはによって変更される &lt;code&gt;inflate&lt;/code&gt; 。完了すると、インフレーション後の入力バッファーの残りが含まれます。つまり、戻りステータスが &lt;code&gt;Z_OK&lt;/code&gt; の場合、 &lt;code&gt;$buffer&lt;/code&gt; は空の文字列になります。戻りステータスが &lt;code&gt;Z_STREAM_END&lt;/code&gt; の場合、 &lt;code&gt;$buffer&lt;/code&gt; パラメータには、デフレートされたデータストリームの後に入力バッファに格納されたもの（もしあれば）が含まれます。</target>
        </trans-unit>
        <trans-unit id="4deaa69228d0bed93aa2331246fd160457f98868" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$description&lt;/code&gt; is usually a test file name (but only by convention.) It is used as a unique identifier (see e.g. &lt;a href=&quot;#parsers&quot;&gt;parsers&lt;/a&gt;.) Reusing a description is a fatal error.</source>
          <target state="translated">&lt;code&gt;$description&lt;/code&gt; （だけ慣例により。）通常、テストファイル名であることが一意の識別子として使用されている（例えば参照&lt;a href=&quot;#parsers&quot;&gt;パーサを&lt;/a&gt;。）の記述を再利用するには、致命的なエラーです。</target>
        </trans-unit>
        <trans-unit id="04558cf60bc9c7167d85368eb6635a2473770d4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$eof&lt;/code&gt; parameter needs a bit of explanation.</source>
          <target state="translated">&lt;code&gt;$eof&lt;/code&gt; パラメータは、説明のビットを必要とします。</target>
        </trans-unit>
        <trans-unit id="65f92aaac6b66cd674844396e8d45e3f370fce50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$eof&lt;/code&gt; parameter only needs to be used if &lt;b&gt;all&lt;/b&gt; of the following conditions apply</source>
          <target state="translated">&lt;code&gt;$eof&lt;/code&gt; 場合は、パラメータにのみ使用する必要があり&lt;b&gt;、すべての&lt;/b&gt;次の条件の適用は、</target>
        </trans-unit>
        <trans-unit id="8a410599f21ede34ce0c4e99388bf1aa3ff8199e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$gzerrno&lt;/code&gt; scalar holds the error code associated with the most recent</source>
          <target state="translated">&lt;code&gt;$gzerrno&lt;/code&gt; スカラーは、最新に関連付けられたエラーコードを保持しています</target>
        </trans-unit>
        <trans-unit id="6264c4349310ae2e82ed9dccab08bd7526a285d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$in_fh&lt;/code&gt; parameter may be any object that provides a &lt;b&gt;getline()&lt;/b&gt; method to retrieve a single line of input text (hence, an appropriate wrapper object could be used to parse PODs from a single string or an array of strings).</source>
          <target state="translated">&lt;code&gt;$in_fh&lt;/code&gt; パラメータが提供する任意のオブジェクトであってもよい&lt;b&gt;のgetline（）&lt;/b&gt;入力テキストの単一行を取得する方法（したがって、適切なラッパー・オブジェクトは、単一の文字列または文字列の配列から解析のPODに使用することができます）。</target>
        </trans-unit>
        <trans-unit id="e89b34e9c40c9e18afebc88c2be1c3150fecd52e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$input&lt;/code&gt; and &lt;code&gt;$output&lt;/code&gt; parameters can be either scalars or scalar references.</source>
          <target state="translated">&lt;code&gt;$input&lt;/code&gt; と &lt;code&gt;$output&lt;/code&gt; パラメータは、スカラーまたはスカラーリファレンスのいずれかになります。</target>
        </trans-unit>
        <trans-unit id="d5ad245702c5052688f1d153e2fbd703e2f8f301" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; パラメータ</target>
        </trans-unit>
        <trans-unit id="daa9f5f9a1ef279c49e625124d1e76146ad5e7d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$level&lt;/code&gt; parameter defines the compression level. Valid values are 0 through 9, &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt; , &lt;code&gt;Z_BEST_SPEED&lt;/code&gt; , &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt; , and &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; . If &lt;code&gt;$level&lt;/code&gt; is not specified &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;$level&lt;/code&gt; パラメータは、圧縮レベルを定義します。有効な値は0〜9、 &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt; 、 &lt;code&gt;Z_BEST_SPEED&lt;/code&gt; 、 &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt; 、および &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; です。 &lt;code&gt;$level&lt;/code&gt; が指定されていない場合、 &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="cb33cd5cc665b9c3bd624d64f0ec40381e42cbac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$mon&lt;/code&gt; is zero-based: January equals &lt;code&gt;0&lt;/code&gt; . The &lt;code&gt;$year&lt;/code&gt; is 1900-based: 2001 equals &lt;code&gt;101&lt;/code&gt; . &lt;code&gt;$wday&lt;/code&gt; and &lt;code&gt;$yday&lt;/code&gt; default to zero (and are usually ignored anyway), and &lt;code&gt;$isdst&lt;/code&gt; defaults to -1.</source>
          <target state="translated">&lt;code&gt;$mon&lt;/code&gt; ゼロベースである：1月は等しい &lt;code&gt;0&lt;/code&gt; を。 &lt;code&gt;$year&lt;/code&gt; 1900ベースである：2001等しい &lt;code&gt;101&lt;/code&gt; 。 &lt;code&gt;$wday&lt;/code&gt; と &lt;code&gt;$yday&lt;/code&gt; デフォルトでゼロになり（そして通常無視されます）、 &lt;code&gt;$isdst&lt;/code&gt; デフォルトで-1になります。</target>
        </trans-unit>
        <trans-unit id="d866868676edf3ef0ef337619cbb9d7d463b060f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; パラメータ</target>
        </trans-unit>
        <trans-unit id="c96d672905fea90a5656f24eb9f7936742884276" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$parser&lt;/code&gt; is a &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; object.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; ある&lt;a href=&quot;../parser&quot;&gt;TAP ::パーサ&lt;/a&gt;オブジェクト。</target>
        </trans-unit>
        <trans-unit id="0cde3685cee91824cf2720ce6f47ce3c1655541a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$tabstop&lt;/code&gt; variable controls how many column positions apart each tabstop is. The default is 8.</source>
          <target state="translated">&lt;code&gt;$tabstop&lt;/code&gt; 各タブストップがどのように多くの列の位置離れて変数を制御します。デフォルトは8です。</target>
        </trans-unit>
        <trans-unit id="07507ab596d7a55a579157466578b8c289c17f57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$whence&lt;/code&gt; parameter should be one of SEEK_SET, SEEK_CUR or SEEK_END.</source>
          <target state="translated">&lt;code&gt;$whence&lt;/code&gt; パラメータがSEEK_SET、SEEK_CURまたはSEEK_ENDの一つでなければなりません。</target>
        </trans-unit>
        <trans-unit id="78200cc1ea59e994c5d2418e77df8c6e8fa8185d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$whence&lt;/code&gt; parameter takes one the usual values, namely SEEK_SET, SEEK_CUR or SEEK_END.</source>
          <target state="translated">&lt;code&gt;$whence&lt;/code&gt; パラメータが1つの通常の値、すなわちSEEK_SET、SEEK_CURまたはSEEK_ENDをとります。</target>
        </trans-unit>
        <trans-unit id="d36c42de8f17d5532305a2dae875ef12d3135188" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$|&lt;/code&gt; is one of the per-filehandle special variables, so each filehandle has its own copy of its value. If you want to merge standard output and standard error for instance, you have to unbuffer each (although STDERR might be unbuffered by default):</source>
          <target state="translated">&lt;code&gt;$|&lt;/code&gt; ファイルハンドルごとの特殊変数の1つであるため、各ファイルハンドルには、その値の独自のコピーがあります。たとえば、標準出力と標準エラーをマージする場合は、それぞれをバッファリング解除する必要があります（ただし、STDERRはデフォルトでバッファリングされない場合があります）。</target>
        </trans-unit>
        <trans-unit id="697d0e02c23a6252ba73964b72ba7fef06e6718b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%^H&lt;/code&gt; hash provides the same scoping semantic as &lt;code&gt;$^H&lt;/code&gt; . This makes it useful for implementation of lexically scoped pragmas. See &lt;a href=&quot;perlpragma&quot;&gt;perlpragma&lt;/a&gt;. All the entries are stringified when accessed at runtime, so only simple values can be accommodated. This means no pointers to objects, for example.</source>
          <target state="translated">&lt;code&gt;%^H&lt;/code&gt; ハッシュは、セマンティックとして同じスコープ提供 &lt;code&gt;$^H&lt;/code&gt; 。これにより、レキシカルスコープのプラグマの実装に役立ちます。&lt;a href=&quot;perlpragma&quot;&gt;perlpragmaを&lt;/a&gt;参照してください。実行時にアクセスされると、すべてのエントリが文字列化されるため、単純な値のみに対応できます。これは、たとえば、オブジェクトへのポインタがないことを意味します。</target>
        </trans-unit>
        <trans-unit id="0c6228356b1a9a18f543cd58f3d14ae5ed0885fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%s&lt;/code&gt; is expanded to be the filename (&lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; is used, so be careful to escape any other &lt;code&gt;%&lt;/code&gt; signs). The 'commands' are checked for sanity - they must contain the &lt;code&gt;%s&lt;/code&gt; , and the read open must end with the pipe sign, and the write open must begin with the pipe sign.</source>
          <target state="translated">&lt;code&gt;%s&lt;/code&gt; が（ファイル名であることが展開されている &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 使用されているので、他のエスケープするように注意してください &lt;code&gt;%&lt;/code&gt; の徴候を）。「コマンド」の健全性がチェックされます-コマンドには &lt;code&gt;%s&lt;/code&gt; が含まれている必要があり、読み取りオープンはパイプ記号で終了し、書き込みオープンはパイプ記号で開始する必要があります。</target>
        </trans-unit>
        <trans-unit id="cf6ebcc90a0416e4d456de5b17214b9e0b4a29e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator in the INPUT: section is used to tell &lt;b&gt;xsubpp&lt;/b&gt; that it should convert a Perl value to/from C using the C type to the left of &lt;code&gt;&amp;amp;&lt;/code&gt; , but provide a pointer to this value when the C function is called.</source>
          <target state="translated">INPUT：セクションの &lt;code&gt;&amp;amp;&lt;/code&gt; 単項演算子は、 &lt;code&gt;&amp;amp;&lt;/code&gt; の左側のCタイプを使用してPerl値をCとの間で変換する必要があることを&lt;b&gt;xsubpp&lt;/b&gt;に通知するために使用されますが、C関数が呼び出されると、この値へのポインターを提供します。</target>
        </trans-unit>
        <trans-unit id="0b29d8efcd6e9fd3b54226af4554626aa17bc6d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers can also be used on &lt;code&gt;()&lt;/code&gt; groups to force a particular byte-order on all components in that group, including all its subgroups.</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;&lt;/code&gt; 改質剤はまた、上で使用することができる &lt;code&gt;()&lt;/code&gt; そのすべてのサブグループを含む、そのグループ内のすべてのコンポーネントの特定のバイト順を強制するグループ。</target>
        </trans-unit>
        <trans-unit id="46a36b2037ff10a0c2a8e03718578280ecd8883f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers can only be used on floating-point formats on big- or little-endian machines. Otherwise, attempting to use them raises an exception.</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; または &lt;code&gt;&amp;lt;&lt;/code&gt; 修飾子はビッグエンディアンかリトルエンディアンのマシン上の浮動小数点形式で使用することができます。そうでない場合、それらを使用しようとすると例外が発生します。</target>
        </trans-unit>
        <trans-unit id="99da10732816cfac1a93d49f7cb24d6856262342" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator is most often seen in a &lt;code&gt;while&lt;/code&gt; loop:</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 演算子は、最も頻繁に見られ &lt;code&gt;while&lt;/code&gt; ループ：</target>
        </trans-unit>
        <trans-unit id="afce8c3936870dcddae71b2f62bcc6619bb65ebe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator performs a globbing operation (see above). In Perl versions earlier than v5.6.0, the internal glob() operator forks csh(1) to do the actual glob expansion, but csh can't handle more than 127 items and so gives the error message &lt;code&gt;Argument list too long&lt;/code&gt; . People who installed tcsh as csh won't have this problem, but their users may be surprised by it.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; オペレータが実行グロブ操作（上記参照）。v5.6.0より前のバージョンのPerlでは、内部glob（）演算子はcsh（1）をフォークして実際のグロブ拡張を実行しますが、cshは127を超えるアイテムを処理できないため、エラーメッセージ &lt;code&gt;Argument list too long&lt;/code&gt; ます。cshとしてtcshをインストールした人にはこの問題はありませんが、ユーザーは驚くかもしれません。</target>
        </trans-unit>
        <trans-unit id="6640438652752fb93dc538db26332c2e258075d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; symbol will return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for end-of-file only once. If you call it again after this, it will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from STDIN.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 記号が返されます &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を一度だけファイルの終わりのために。この後でもう一度呼び出すと、別の &lt;code&gt;@ARGV&lt;/code&gt; リストを処理していると見 &lt;code&gt;@ARGV&lt;/code&gt; 、@ ARGVを設定していない場合は、STDINから入力が読み取られます。</target>
        </trans-unit>
        <trans-unit id="eb62b601a884f58c8064f8b862089ac2459b0228" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'I'&lt;/code&gt; prefix is used during creation of &lt;code&gt;stdin&lt;/code&gt; ..&lt;code&gt;stderr&lt;/code&gt; via special &lt;code&gt;PerlIO_fdopen&lt;/code&gt; calls; the &lt;code&gt;'#'&lt;/code&gt; prefix means that this is &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; and that</source>
          <target state="translated">&lt;code&gt;'I'&lt;/code&gt; プレフィックスは作成時に使用されている &lt;code&gt;stdin&lt;/code&gt; .. &lt;code&gt;stderr&lt;/code&gt; を経由して、特別な &lt;code&gt;PerlIO_fdopen&lt;/code&gt; の呼び出し; &lt;code&gt;'#'&lt;/code&gt; であると接頭手段 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; で、その</target>
        </trans-unit>
        <trans-unit id="039ae207dd483bda31bf76d897310e5b8ac60fad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'nomethod'&lt;/code&gt; key is used to specify a catch-all function to be called for any operator that is not individually overloaded. The specified function will be passed four parameters. The first three arguments coincide with those that would have been passed to the corresponding method if it had been defined. The fourth argument is the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; key for that missing method. If the experimental &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; to indicate that the caller is expecting numeric behaviour.</source>
          <target state="translated">&lt;code&gt;'nomethod'&lt;/code&gt; キーは個別に過負荷にされていない任意の演算子のために呼ばれるキャッチオール機能を指定するために使用されます。指定された関数には4つのパラメーターが渡されます。最初の3つの引数は、対応するメソッドが定義されていれば、それに渡されていた引数と一致します。 4番目の引数は、欠落しているメソッドの &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; キーです。実験的な「ビット単位」機能が有効になっている場合（&lt;a href=&quot;feature&quot;&gt;機能を&lt;/a&gt;参照）、5番目のTRUE引数が &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; を処理するサブルーチンに渡されます。、 &lt;code&gt;^&lt;/code&gt; 、 &lt;code&gt;~&lt;/code&gt; は、呼び出し元が数値の動作を期待していることを示します。</target>
        </trans-unit>
        <trans-unit id="a56ee7f30e7bca1dfc3e81783dadbc2bc19f727f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(a|b)*&lt;/code&gt; part can match at every char in the string, and then fail every time because there is no &lt;code&gt;z&lt;/code&gt; in the string. So obviously we can avoid using the regex engine unless there is a &lt;code&gt;z&lt;/code&gt; in the string. Likewise in a pattern like:</source>
          <target state="translated">&lt;code&gt;(a|b)*&lt;/code&gt; の部分は、文字列内のすべての文字に一致し、その後、何もありませんので、毎回失敗することができ &lt;code&gt;z&lt;/code&gt; の文字列では。そのため、文字列に &lt;code&gt;z&lt;/code&gt; がない限り、正規表現エンジンの使用を避けることができます。同様に次のようなパターンで：</target>
        </trans-unit>
        <trans-unit id="13f6771d5d5f30a227731a56b375d2b66657907c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*_BS&lt;/code&gt; file can put some code into the generated &lt;code&gt;*.bs&lt;/code&gt; file by placing it in &lt;code&gt;$bscode&lt;/code&gt; . This is a handy 'escape' mechanism that may prove useful in complex situations.</source>
          <target state="translated">&lt;code&gt;*_BS&lt;/code&gt; ファイルが生成さにいくつかのコードを置くことができます &lt;code&gt;*.bs&lt;/code&gt; に置くことで、ファイル &lt;code&gt;$bscode&lt;/code&gt; 。これは、複雑な状況で役立つことがある便利な「エスケープ」メカニズムです。</target>
        </trans-unit>
        <trans-unit id="2ecae669ab5e752a1da7ac780070c852f9269859" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*foo{THING}&lt;/code&gt; notation can also be used to obtain references to the individual elements of *foo. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;*foo{THING}&lt;/code&gt; 記法も* FOOの個々の要素への参照を取得するために使用することができます。&lt;a href=&quot;perlref&quot;&gt;perlrefを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="255645a7c66228ebcb1a14a341007dcfb97aeb51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*x = \$y&lt;/code&gt; mechanism may be used to pass and return cheap references into or from subroutines if you don't want to copy the whole thing. It only works when assigning to dynamic variables, not lexicals.</source>
          <target state="translated">全体をコピーしたくない場合は、 &lt;code&gt;*x = \$y&lt;/code&gt; メカニズムを使用して、安価な参照をサブルーチンに渡したり、サブルーチンから返したりできます。これは、動的変数に割り当てるときにのみ機能し、字句には割り当てられません。</target>
        </trans-unit>
        <trans-unit id="fa1621299f61dcb4d1993cf9ac21afe7e26870e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; form is now obsolete and strongly deprecated.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; のフォームは廃止と強く非推奨です。</target>
        </trans-unit>
        <trans-unit id="6cc8f120eca26410795cc27186ae2b363ac834f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; prototype is a special alternative to &lt;code&gt;$&lt;/code&gt; that will act like &lt;code&gt;\[@%]&lt;/code&gt; when given a literal array or hash variable, but will otherwise force scalar context on the argument. This is useful for functions which should accept either a literal array or an array reference as the argument:</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; のプロトタイプはに特別な代替案である &lt;code&gt;$&lt;/code&gt; のように動作します &lt;code&gt;\[@%]&lt;/code&gt; リテラル配列やハッシュ変数を与えられたが、それ以外の引数にスカラーコンテキストを強制するとき。これは、引数としてリテラル配列または配列参照のいずれかを受け入れる必要がある関数に役立ちます。</target>
        </trans-unit>
        <trans-unit id="bb2105637115aa748fce8bf2036dcef89f13282b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; specifier is ignored if the option destination is not a scalar.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; のオプション先がスカラーでない場合、指定子は無視されます。</target>
        </trans-unit>
        <trans-unit id="6806c6a2e8d1792a36b6bbc8a8afc151b341b78f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; unary operator doesn't do anything in Perl. It exists to avoid syntactic ambiguities.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 単項演算子は、Perlで何もしません。構文のあいまいさを避けるために存在します。</target>
        </trans-unit>
        <trans-unit id="37675ebea1632ec83c2cb0e9f47bb19d76dac534" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&amp;gt;&lt;/code&gt; syntax is also used when dereferencing a reference. It looks like the same operator, but these are two different operations.</source>
          <target state="translated">&lt;code&gt;-&amp;gt;&lt;/code&gt; 参照を参照解除するときの構文も使用されています。同じ演算子のように見えますが、これらは2つの異なる操作です。</target>
        </trans-unit>
        <trans-unit id="d4b0e534108246bac541ccb7068bc25380ccc720" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&amp;gt;new()&lt;/code&gt; method is an alias for &lt;code&gt;-&amp;gt;create()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-&amp;gt;new()&lt;/code&gt; メソッドは、の別名である &lt;code&gt;-&amp;gt;create()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="127cc52ec86933168c2c1aece6f9b232d7cd7b7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--rules&lt;/code&gt; option is used to control which tests are run sequentially and which are run in parallel, if the &lt;code&gt;--jobs&lt;/code&gt; option is specified. The option may be specified multiple times, and the order matters.</source>
          <target state="translated">&lt;code&gt;--rules&lt;/code&gt; のオプションは、テストが順次実行された場合にどのは、並行して実行される制御するために使用される &lt;code&gt;--jobs&lt;/code&gt; オプションが指定されています。オプションは複数回指定でき、順序が重要です。</target>
        </trans-unit>
        <trans-unit id="608a757f76e2d49976d1abe026a19ab9cb45d134" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--state&lt;/code&gt; switch may be used more than once.</source>
          <target state="translated">&lt;code&gt;--state&lt;/code&gt; スイッチを複数回使用することができます。</target>
        </trans-unit>
        <trans-unit id="cc3c8ce0b0c852fbdda4091c52f36592afcdc410" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--state&lt;/code&gt; switch requires an argument which must be a comma separated list of one or more of the following options.</source>
          <target state="translated">&lt;code&gt;--state&lt;/code&gt; スイッチは、コンマは、以下の1つ以上のオプションのリストを分離しなければならない引数が必要です。</target>
        </trans-unit>
        <trans-unit id="377dc2d9444ba53f1e07b9f9c8ed4eb80a1854c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--trap&lt;/code&gt; option will attempt to trap SIGINT (Ctrl-C) during a test run and display the test summary even if the run is interrupted</source>
          <target state="translated">&lt;code&gt;--trap&lt;/code&gt; オプションは、テスト実行中にトラップSIGINT（Ctrl + Cキー）にしようとすると、実行が中断された場合でも、テストの概要が表示されます</target>
        </trans-unit>
        <trans-unit id="e392f25b1c4fe3943f476468712579d620408f6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-A&lt;/code&gt; command line switch</source>
          <target state="translated">&lt;code&gt;-A&lt;/code&gt; コマンドラインスイッチ</target>
        </trans-unit>
        <trans-unit id="597b9a9c8e6ccba33470cbc78977519edc52f8e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-A&lt;/code&gt; omits the Autoloader code, &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; omits XS elements, &lt;code&gt;--skip-exporter&lt;/code&gt; omits the Exporter code, &lt;code&gt;--&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;-new-tests&lt;/code&gt; sets up a modern testing environment, and &lt;code&gt;-n&lt;/code&gt; specifies the name of the module.</source>
          <target state="translated">&lt;code&gt;-A&lt;/code&gt; は、オートローダコード、省略 &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 、省いXS要素を &lt;code&gt;--skip-exporter&lt;/code&gt; 、輸出のコードを省略 &lt;code&gt;--&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;-new-tests&lt;/code&gt; 近代的なテスト環境設定、および &lt;code&gt;-n&lt;/code&gt; モジュールの名前を指定します。</target>
        </trans-unit>
        <trans-unit id="c623c1943d0dabf76760d7670756f1a93a94f39a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Dusecbacktrace&lt;/code&gt; also enables keeping the debug information when compiling/linking (often: &lt;code&gt;-g&lt;/code&gt; ). Many compilers/linkers do support having both optimization and keeping the debug information. The debug information is needed for the symbol names and the source locations.</source>
          <target state="translated">&lt;code&gt;-Dusecbacktrace&lt;/code&gt; は（：多くの場合もリンク/コンパイル時にデバッグ情報を保持できます &lt;code&gt;-g&lt;/code&gt; ）。多くのコンパイラ/リンカーは、最適化とデバッグ情報の保持の両方をサポートしています。デバッグ情報は、シンボル名とソースの場所に必要です。</target>
        </trans-unit>
        <trans-unit id="63378b07c96f9b709eea4a8451598ec112926512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; switches work as follows. The first block or so of the file is examined to see if it is valid UTF-8 that includes non-ASCII characters. If, so it's a &lt;code&gt;-T&lt;/code&gt; file. Otherwise, that same portion of the file is examined for odd characters such as strange control codes or characters with the high bit set. If more than a third of the characters are strange, it's a &lt;code&gt;-B&lt;/code&gt; file; otherwise it's a &lt;code&gt;-T&lt;/code&gt; file. Also, any file containing a zero byte in the examined portion is considered a binary file. (If executed within the scope of a &lt;a href=&quot;../perllocale&quot;&gt;use locale&lt;/a&gt; which includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , odd characters are anything that isn't a printable nor space in the current locale.) If &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-B&lt;/code&gt; is used on a filehandle, the current IO buffer is examined rather than the first block. Both &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; return true on an empty file, or a file at EOF when testing a filehandle. Because you have to read a file to do the &lt;code&gt;-T&lt;/code&gt; test, on most occasions you want to use a &lt;code&gt;-f&lt;/code&gt; against the file first, as in &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-T&lt;/code&gt; と &lt;code&gt;-B&lt;/code&gt; は、次のように仕事を切り替えます。ファイルの最初のブロックなどが検査され、非ASCII文字を含む有効なUTF-8であるかどうかが確認されます。もしそうなら、それは &lt;code&gt;-T&lt;/code&gt; ファイルです。それ以外の場合は、ファイルの同じ部分で、奇妙な制御コードや上位ビットが設定された文字などの奇数文字が検査されます。 3分の1以上の文字が奇妙な場合、それは &lt;code&gt;-B&lt;/code&gt; ファイルです。それ以外の場合は &lt;code&gt;-T&lt;/code&gt; ファイルです。また、検査された部分にゼロバイトを含むファイルは、バイナリファイルと見なされます。 （ &lt;code&gt;LC_CTYPE&lt;/code&gt; を含む&lt;a href=&quot;../perllocale&quot;&gt;使用ロケールの&lt;/a&gt;範囲内で実行される場合、奇数文字は、現在のロケールでは印刷可能でもスペースでもないものです。） &lt;code&gt;-T&lt;/code&gt; または &lt;code&gt;-B&lt;/code&gt; がファイルハンドルで使用されている場合、最初のブロックではなく現在のIOバッファーが検査されます。 &lt;code&gt;-T&lt;/code&gt; と &lt;code&gt;-B&lt;/code&gt; はどちらも、ファイルハンドルのテスト時に、空のファイルまたはEOFのファイルに対してtrueを返します。 &lt;code&gt;-T&lt;/code&gt; テストを行うにはファイルを読み取る必要があるため、ほとんどの場合、 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; ように-f $ file &amp;amp;&amp;amp; -T $ fileでない限り、最初にファイルに対して &lt;code&gt;-f&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="c91ca83f347b61a13eb65089f07047ddb67d9622" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; switches work as follows. The first block or so of the file is examined to see if it is valid UTF-8 that includes non-ASCII characters. If, so it's a &lt;code&gt;-T&lt;/code&gt; file. Otherwise, that same portion of the file is examined for odd characters such as strange control codes or characters with the high bit set. If more than a third of the characters are strange, it's a &lt;code&gt;-B&lt;/code&gt; file; otherwise it's a &lt;code&gt;-T&lt;/code&gt; file. Also, any file containing a zero byte in the examined portion is considered a binary file. (If executed within the scope of a &lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt; which includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , odd characters are anything that isn't a printable nor space in the current locale.) If &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-B&lt;/code&gt; is used on a filehandle, the current IO buffer is examined rather than the first block. Both &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; return true on an empty file, or a file at EOF when testing a filehandle. Because you have to read a file to do the &lt;code&gt;-T&lt;/code&gt; test, on most occasions you want to use a &lt;code&gt;-f&lt;/code&gt; against the file first, as in &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-T&lt;/code&gt; と &lt;code&gt;-B&lt;/code&gt; は、次のように仕事を切り替えます。ファイルの最初のブロックなどが検査され、非ASCII文字を含む有効なUTF-8であるかどうかが確認されます。もしそうなら、それは &lt;code&gt;-T&lt;/code&gt; ファイルです。それ以外の場合は、ファイルの同じ部分で、奇妙な制御コードや上位ビットが設定された文字などの奇数文字が検査されます。 3分の1以上の文字が奇妙な場合、それは &lt;code&gt;-B&lt;/code&gt; ファイルです。それ以外の場合は &lt;code&gt;-T&lt;/code&gt; ファイルです。また、検査された部分にゼロバイトを含むファイルは、バイナリファイルと見なされます。 （ &lt;code&gt;LC_CTYPE&lt;/code&gt; を含む&lt;a href=&quot;perllocale&quot;&gt;使用ロケールの&lt;/a&gt;範囲内で実行される場合、奇数文字は、現在のロケールでは印刷可能でもスペースでもないものです。） &lt;code&gt;-T&lt;/code&gt; または &lt;code&gt;-B&lt;/code&gt; がファイルハンドルで使用されている場合、最初のブロックではなく現在のIOバッファーが検査されます。 &lt;code&gt;-T&lt;/code&gt; と &lt;code&gt;-B&lt;/code&gt; はどちらも、ファイルハンドルのテスト時に、空のファイルまたはEOFのファイルに対してtrueを返します。 &lt;code&gt;-T&lt;/code&gt; テストを行うにはファイルを読み取る必要があるため、ほとんどの場合、 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; ように-f $ file &amp;amp;&amp;amp; -T $ fileでない限り、最初にファイルに対して &lt;code&gt;-f&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="9bc0f3fa215c39800076a942f11672815853d1f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Wall&lt;/code&gt; is by default on.</source>
          <target state="translated">&lt;code&gt;-Wall&lt;/code&gt; は上のデフォルトです。</target>
        </trans-unit>
        <trans-unit id="6dfbaa82d695de76db5a43cbdf063e4ffac5d9ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Wtraditional&lt;/code&gt; is another example of the annoying tendency of gcc to bundle a lot of warnings under one switch (it would be impossible to deploy in practice because it would complain a lot) but it does contain some warnings that would be beneficial to have available on their own, such as the warning about string constants inside macros containing the macro arguments: this behaved differently pre-ANSI than it does in ANSI, and some C compilers are still in transition, AIX being an example.</source>
          <target state="translated">&lt;code&gt;-Wtraditional&lt;/code&gt; は一つのスイッチの下での警告の多くをバンドルするためのgccの迷惑な傾向の他の例である（多くのことを文句になるので、実際に展開することは不可能であろう）が、それは可能なを持っていることは有益であろういくつかの警告が含まれていませんマクロ引数を含むマクロ内の文字列定数に関する警告など、単独で。これは、ANSI以前とANSIでの動作が異なり、一部のCコンパイラはまだ移行中です。AIXがその例です。</target>
        </trans-unit>
        <trans-unit id="dea68b3a7d6bdc421299da6629ccc22d6bd7b572" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-ansi&lt;/code&gt; (and its sidekick, &lt;code&gt;-pedantic&lt;/code&gt; ) would be nice to be on always, but unfortunately they are not safe on all platforms, they can for example cause fatal conflicts with the system headers (Solaris being a prime example). If Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; is used, the &lt;code&gt;cflags&lt;/code&gt; frontend selects &lt;code&gt;-ansi -pedantic&lt;/code&gt; for the platforms where they are known to be safe.</source>
          <target state="translated">&lt;code&gt;-ansi&lt;/code&gt; （とその相棒、 &lt;code&gt;-pedantic&lt;/code&gt; は、システムヘッダと致命的なコンフリクト（Solarisが典型的な例である）原因など）は常にオンにいいだろうが、残念ながら、彼らはすべてのプラットフォーム上で安全ではない、彼らがすることができます。Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; が使用されている場合、 &lt;code&gt;cflags&lt;/code&gt; フロントエンドは、安全であることがわかっているプラ​​ットフォームに対して &lt;code&gt;-ansi -pedantic&lt;/code&gt; -pedanticを選択します。</target>
        </trans-unit>
        <trans-unit id="cb94d9f2c59455332a30530ef3be81c2f437b975" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-h&lt;/code&gt; option will show a usage message.</source>
          <target state="translated">&lt;code&gt;-h&lt;/code&gt; オプションは、使用法のメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="02d034bd54a852b799ddb0bca00601006bc9ad62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-newlex&lt;/code&gt; option produces a more readable &lt;code&gt;name =&amp;gt; value&lt;/code&gt; format, and is shown in the second example above.</source>
          <target state="translated">&lt;code&gt;-newlex&lt;/code&gt; オプションが読みやすい生成 &lt;code&gt;name =&amp;gt; value&lt;/code&gt; フォーマットを、上記第二の例に示されています。</target>
        </trans-unit>
        <trans-unit id="3ed7e26de1fd10b827d09512227b49a4f8d06d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-nosp&lt;/code&gt; option eliminates reporting of SPECIALs, such as &lt;code&gt;0: SPECIAL
#1 &amp;amp;PL_sv_undef&lt;/code&gt; above. Reporting of SPECIALs can sometimes overwhelm your declared lexicals.</source>
          <target state="translated">&lt;code&gt;-nosp&lt;/code&gt; のようなスペシャルの報告オプションの排除、 &lt;code&gt;0: SPECIAL #1 &amp;amp;PL_sv_undef&lt;/code&gt; 以上。SPECIALの報告は、宣言された語彙を圧倒することがあります。</target>
        </trans-unit>
        <trans-unit id="063586d44811e787a3acc7fa9925ec22a0e1ef32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-pretty&lt;/code&gt; directive is called too late to affect matters. You have to do this instead, and</source>
          <target state="translated">&lt;code&gt;-pretty&lt;/code&gt; ディレクティブは問題に影響を与えるために遅すぎると呼ばれています。代わりにこれを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="64b5e1fcc02dcf849bd221c8c257f81fb47b92a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-q&lt;/code&gt; and &lt;code&gt;-qq&lt;/code&gt; options don't work correctly if perl isn't compiled with PerlIO support : STDOUT will be closed instead of being redirected to &lt;code&gt;$O::BEGIN_output&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-q&lt;/code&gt; と &lt;code&gt;-qq&lt;/code&gt; STDOUTが閉じられますの代わりにリダイレクトされます。perlがPerlIOをサポートしてコンパイルされていない場合のオプションが正しく動作しません &lt;code&gt;$O::BEGIN_output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6261ab8564541d33e35c7ac1e97aa8a5e571dd14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-qq&lt;/code&gt; option behaves like &lt;code&gt;-q&lt;/code&gt;, except that it also closes STDERR after deparsing has finished. This suppresses the &quot;Syntax OK&quot; message normally produced by perl.</source>
          <target state="translated">&lt;code&gt;-qq&lt;/code&gt; のようなオプションの振る舞い &lt;code&gt;-q&lt;/code&gt; それも終わったデパース後STDERRを閉じていることを除いて、。これにより、perlによって通常生成される「構文OK」メッセージが抑制されます。</target>
        </trans-unit>
        <trans-unit id="cb173d8eff47f06c7e37f7374c7227453a2ad4d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-u&lt;/code&gt; switch causes the VMS debugger to be invoked after the Perl program is compiled, but before it has run. It does not create a core dump file.</source>
          <target state="translated">&lt;code&gt;-u&lt;/code&gt; スイッチは、Perlプログラムがコンパイルされた後、VMSのデバッガが呼び出されますが、それが実行される前に。コアダンプファイルは作成されません。</target>
        </trans-unit>
        <trans-unit id="1e542d84460c8b59074b5a3d74792d84cf2329fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; and &lt;code&gt;...&lt;/code&gt; flip-flop operators. Note that the &lt;code&gt;...&lt;/code&gt; flip-flop operator is completely different from the &lt;code&gt;...&lt;/code&gt; elliptical statement just described.</source>
          <target state="translated">&lt;code&gt;..&lt;/code&gt; .と &lt;code&gt;...&lt;/code&gt; フリップフロップ演算子。 &lt;code&gt;...&lt;/code&gt; フリップフロップ演算子は、前述の &lt;code&gt;...&lt;/code&gt; 楕円ステートメントとは完全に異なることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8189082aec1c35ce34b10a2a482272d1f9442cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; range operator treats certain character ranges with care on EBCDIC platforms. For example the following array will have twenty six elements on either an EBCDIC platform or an ASCII platform:</source>
          <target state="translated">&lt;code&gt;..&lt;/code&gt; 範囲演算子の扱いEBCDICプラットフォーム上で注意して、特定の文字範囲を。たとえば、次の配列には、EBCDICプラットフォームまたはASCIIプラットフォームのいずれかで26の要素があります。</target>
        </trans-unit>
        <trans-unit id="1bfc1b4066699d36e1a1c96b8bf42e5d376ee7e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;//&lt;/code&gt; matching operator is documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;. It operates on &lt;code&gt;$_&lt;/code&gt; by default, or can be bound to another variable using the &lt;code&gt;=~&lt;/code&gt; binding operator (also documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;//&lt;/code&gt; マッチング演算子は、に記載されて&lt;a href=&quot;perlop&quot;&gt;はperlop&lt;/a&gt;。デフォルトでは &lt;code&gt;$_&lt;/code&gt; で動作します。または、 &lt;code&gt;=~&lt;/code&gt; バインディング演算子を使用して別の変数にバインドすることもできます（&lt;a href=&quot;perlop&quot;&gt;perlopに&lt;/a&gt;も記載されています）。</target>
        </trans-unit>
        <trans-unit id="32ef826cb43c384876c66cdfd8ef3d6094273ed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;//a&lt;/code&gt; modifier, available starting in Perl 5.14, is used to restrict the matches of \d, \s, and \w to just those in the ASCII range. It is useful to keep your program from being needlessly exposed to full Unicode (and its accompanying security considerations) when all you want is to process English-like text. (The &quot;a&quot; may be doubled, &lt;code&gt;//aa&lt;/code&gt; , to provide even more restrictions, preventing case-insensitive matching of ASCII with non-ASCII characters; otherwise a Unicode &quot;Kelvin Sign&quot; would caselessly match a &quot;k&quot; or &quot;K&quot;.)</source>
          <target state="translated">&lt;code&gt;//a&lt;/code&gt; 修飾子はPerl 5.14で利用可能な出発は、ASCIIの範囲のものだけにwを\ \ Dの試合、\ sのを制限するために使用され、。英語のようなテキストを処理することだけが目的の場合、プログラムが完全なUnicode（およびそれに付随するセキュリティ上の考慮事項）に不必要に公開されないようにするのに役立ちます。 （ &quot;a&quot;は &lt;code&gt;//aa&lt;/code&gt; のように2倍にするとさらに多くの制限が提供され、ASCIIと非ASCII文字との大文字と小文字を区別しないマッチングが防止されます。それ以外の場合、Unicodeの &quot;ケルビン記号&quot;は &quot;k&quot;または &quot;K&quot;と大文字と小文字を区別せず。）</target>
        </trans-unit>
        <trans-unit id="4d28a339cbae1f464fa994976dfeef2db93a1d7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/&lt;/code&gt; template character allows packing and unpacking of a sequence of items where the packed structure contains a packed item count followed by the packed items themselves. This is useful when the structure you're unpacking has encoded the sizes or repeat counts for some of its fields within the structure itself as separate fields.</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; テンプレート文字は、梱包及び充填構造がパックアイテムそのものが続くパックされたアイテム数が含まれている項目のシーケンスの開梱ことができます。これは、アンパックする構造体が、構造体自体の一部のフィールドのサイズまたは繰り返し回数を個別のフィールドとしてエンコードしている場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="8377a1a6991c29f230dc12ce290846f6b362ebc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/a&lt;/code&gt; modifier, on the other hand, may be useful. Its purpose is to allow code that is to work mostly on ASCII data to not have to concern itself with Unicode.</source>
          <target state="translated">&lt;code&gt;/a&lt;/code&gt; 改質剤は、一方で、有用であり得ます。その目的は、主にASCIIデータで機能するコードが、Unicodeに関与する必要がないようにすることです。</target>
        </trans-unit>
        <trans-unit id="9d46362c6dee371fc1e41d5a94fbe9c509a82363" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/d&lt;/code&gt;, &lt;code&gt;/u&lt;/code&gt; , and &lt;code&gt;/l&lt;/code&gt; modifiers are not likely to be of much use to you, and so you need not worry about them very much. They exist for Perl's internal use, so that complex regular expression data structures can be automatically serialized and later exactly reconstituted, including all their nuances. But, since Perl can't keep a secret, and there may be rare instances where they are useful, they are documented here.</source>
          <target state="translated">&lt;code&gt;/d&lt;/code&gt; は、 &lt;code&gt;/u&lt;/code&gt; 、および &lt;code&gt;/l&lt;/code&gt; の修飾子は、おそらくあなたに非常に有用であること、そしてあなたが非常に多く、それらを心配する必要はありませんので、することはありません。これらはPerlの内部使用のために存在するため、複雑な正規表現データ構造を自動的にシリアル化し、後ですべてのニュアンスを含めて正確に再構成できます。しかし、Perlは秘密を守ることができず、それらが有用である場合がまれにあるため、ここに記載されています。</target>
        </trans-unit>
        <trans-unit id="7a635bd3deb5f6d1f8ced7e30d0ca4af436ee119" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/e&lt;/code&gt; will also silently ignore violations of strict, replacing undefined variable names with the empty string. Since I'm using the &lt;code&gt;/e&lt;/code&gt; flag (twice even!), I have all of the same security problems I have with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; in its string form. If there's something odd in &lt;code&gt;$foo&lt;/code&gt; , perhaps something like &lt;code&gt;@{[ &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; &quot;rm -rf /&quot; ]}&lt;/code&gt; , then I could get myself in trouble.</source>
          <target state="translated">&lt;code&gt;/e&lt;/code&gt; はまた静かに空の文字列で未定義の変数名を置き換える、厳しいの違反を無視します。 &lt;code&gt;/e&lt;/code&gt; フラグを使用しているので（2回でも！）、文字列形式の &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; と同じセキュリティ問題があります。 &lt;code&gt;$foo&lt;/code&gt; &lt;code&gt;@{[ &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; &quot;rm -rf /&quot; ]}&lt;/code&gt; ように、$ fooに奇妙なものがあった場合、問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="613bcc3a2284ecc4926054a5b934f30e880d5007" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/g&lt;/code&gt; modifier specifies global pattern matching--that is, matching as many times as possible within the string. How it behaves depends on the context. In list context, it returns a list of the substrings matched by any capturing parentheses in the regular expression. If there are no parentheses, it returns a list of all the matched strings, as if there were parentheses around the whole pattern.</source>
          <target state="translated">&lt;code&gt;/g&lt;/code&gt; で、文字列内の可能な回数だけマッチングである-修飾子指定するグローバルパターンマッチング。動作はコンテキストによって異なります。リストコンテキストでは、正規表現内のキャプチャ括弧に一致する部分文字列のリストを返します。括弧がない場合は、パターン全体を括弧で囲んでいるかのように、一致したすべての文字列のリストを返します。</target>
        </trans-unit>
        <trans-unit id="987314591903795033c1fec25347d7b594aec577" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/l&lt;/code&gt; and &lt;code&gt;/u&lt;/code&gt; modifiers are automatically selected for regular expressions compiled within the scope of various pragmas, and we recommend that in general, you use those pragmas instead of specifying these modifiers explicitly. For one thing, the modifiers affect only pattern matching, and do not extend to even any replacement done, whereas using the pragmas give consistent results for all appropriate operations within their scopes. For example,</source>
          <target state="translated">&lt;code&gt;/l&lt;/code&gt; と &lt;code&gt;/u&lt;/code&gt; の修飾子は自動的にさまざまなプラグマの範囲内でコンパイルされた正規表現のために選択され、我々は一般的に、あなたの代わりに明示的にこれらの修飾子を指定するこれらのプラグマを使用することをお勧めされています。1つには、修飾子はパターンマッチングにのみ影響し、実行された置換にも拡張されませんが、プラグマを使用すると、スコープ内のすべての適切な操作に対して一貫した結果が得られます。例えば、</target>
        </trans-unit>
        <trans-unit id="9a222e38b5a40a1bf140094ce44f5b0c1b82a0ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/o&lt;/code&gt; option for regular expressions (documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlreref&quot;&gt;perlreref&lt;/a&gt;) tells Perl to compile the regular expression only once. This is only useful when the pattern contains a variable. Perls 5.6 and later handle this automatically if the pattern does not change.</source>
          <target state="translated">正規表現の &lt;code&gt;/o&lt;/code&gt; オプション（&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;および&lt;a href=&quot;perlreref&quot;&gt;perlrerefに記載&lt;/a&gt;）は、正規表現を1回だけコンパイルするようにPerlに指示します。これは、パターンに変数が含まれている場合にのみ役立ちます。Perl 5.6以降では、パターンが変更されない場合、これを自動的に処理します。</target>
        </trans-unit>
        <trans-unit id="02f1967b4475720a962bf35cfc3049c63165e0f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/x&lt;/code&gt; modifier causes whitespace to be ignored in a regex pattern (except in a character class and a few other places), and also allows you to use normal comments there, too. As you can imagine, whitespace and comments help a lot.</source>
          <target state="translated">&lt;code&gt;/x&lt;/code&gt; （文字クラスといくつかの他の場所を除いて）正規表現パターンに無視され、あまりにも、あなたはそこに通常のコメントを使用することができますすることが空白修飾子原因。ご想像のとおり、空白とコメントは非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="26a965e97d532904de76cbb5ec7fa62c78040c70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0x&lt;/code&gt; prefix means a hexadecimal number, the digits are 0-9</source>
          <target state="translated">&lt;code&gt;0x&lt;/code&gt; 接頭辞は16進数を意味し、数字は0-9であります</target>
        </trans-unit>
        <trans-unit id="c084ffd08879b68d48b86f14b0edd6d007fd471f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; tag, now discouraged, is the old version of &lt;code&gt;:bsd_glob&lt;/code&gt; . It exports the same constants and functions, but its glob() override does not support iteration; it returns the last file name in scalar context. That means this will loop forever:</source>
          <target state="translated">&lt;code&gt;:&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; タグ、今落胆は、古いバージョンである &lt;code&gt;:bsd_glob&lt;/code&gt; 。同じ定数と関数をエクスポートしますが、glob（）オーバーライドは反復をサポートしていません。スカラーコンテキストで最後のファイル名を返します。つまり、これは永久にループします。</target>
        </trans-unit>
        <trans-unit id="4231c54d461bf5e25a3f991c3ecf987daad7c115" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:ALL&lt;/code&gt; tag will get all of the above exports.</source>
          <target state="translated">&lt;code&gt;:ALL&lt;/code&gt; タグは、上記の輸出のすべてを取得します。</target>
        </trans-unit>
        <trans-unit id="f4ffb1e41b5af144e1e66d6009daba34fcfe78d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bsd_glob&lt;/code&gt; export tag exports bsd_glob() and the constants listed below. It also overrides glob() in the calling package with one that behaves like bsd_glob() with regard to spaces (the space is treated as part of a file name), but supports iteration in scalar context; i.e., it preserves the core function's feature of returning the next item each time it is called.</source>
          <target state="translated">&lt;code&gt;:bsd_glob&lt;/code&gt; 輸出タグ輸出bsd_glob（）および以下に示す定数。また、呼び出し側パッケージのglob（）を、スペースに関してbsd_glob（）のように動作するものでオーバーライドします（スペースはファイル名の一部として扱われます）が、スカラーコンテキストでの反復をサポートしています。つまり、呼び出されるたびに次のアイテムを返すというコア関数の機能を保持します。</target>
        </trans-unit>
        <trans-unit id="e5933b7ecdff0d26d0d1ee137373273e087ab3ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bytes&lt;/code&gt; , &lt;code&gt;:crlf&lt;/code&gt; , &lt;code&gt;:utf8&lt;/code&gt; , and any other directives of the form &lt;code&gt;:...&lt;/code&gt; , are called I/O</source>
          <target state="translated">&lt;code&gt;:bytes&lt;/code&gt; 、 &lt;code&gt;:crlf&lt;/code&gt; 、 &lt;code&gt;:utf8&lt;/code&gt; で、フォームの任意の他のディレクティブ &lt;code&gt;:...&lt;/code&gt; 、I / Oと呼ばれています</target>
        </trans-unit>
        <trans-unit id="586c160f0002e3dc300faf81c49d6dc770a315b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bytes&lt;/code&gt; layer corresponds to &quot;binary mode&quot; and the &lt;code&gt;:crlf&lt;/code&gt; layer corresponds to &quot;text mode&quot; on platforms that distinguish between the two modes when opening files (which is many DOS-like platforms, including Windows). These two layers are no-ops on platforms where binmode() is a no-op, but perform their functions everywhere if PerlIO is enabled.</source>
          <target state="translated">&lt;code&gt;:bytes&lt;/code&gt; 「バイナリモード」とする層の対応を &lt;code&gt;:crlf&lt;/code&gt; （多くのDOSのようなWindowsを含むプラットフォームである）ファイルを開くときに、2つのモードを区別するプラットフォーム上で、「テキストモード」に層が対応します。これらの2つの層は、binmode（）が何もしないプラットフォームでは何もしませんが、PerlIOが有効になっている場合はどこでも機能を実行します。</target>
        </trans-unit>
        <trans-unit id="ec6da40dddc20e97c2aa930b3dff507bcb27589f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:default&lt;/code&gt; bundle represents the feature set that is enabled before any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature&lt;/code&gt; declaration.</source>
          <target state="translated">&lt;code&gt;:default&lt;/code&gt; バンドルは、任意の前に有効になっている機能セットを表し &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature&lt;/code&gt; 宣言を。</target>
        </trans-unit>
        <trans-unit id="a790449d8cd7160d313e0f6fd7d2b5f5cd711410" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_external&lt;/code&gt; requires one boolean argument.</source>
          <target state="translated">&lt;code&gt;:gzip_external&lt;/code&gt; は 1つのブール引数が必要です。</target>
        </trans-unit>
        <trans-unit id="bc95aee8e2b941e818640ac51c8f3c3052958780" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_external&lt;/code&gt; requires one string argument.</source>
          <target state="translated">&lt;code&gt;:gzip_external&lt;/code&gt; は、 1つの文字列引数が必要です。</target>
        </trans-unit>
        <trans-unit id="20c0f5f557ffbe0666f0dfcd916d2b61a638ef52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_read_open&lt;/code&gt; argument must end with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;USING THE EXTERNAL GZIP&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;:gzip_read_open&lt;/code&gt; （|）を持っていると引数がパイプ記号で終わらなければなりません &lt;code&gt;%s&lt;/code&gt; のをファイル名に。&lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;外部GZIPの使用を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="740fe127c4ced02d559ebb2a859c745ac796eb7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_write_open&lt;/code&gt; argument must begin with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. An output redirect (&amp;gt;) is also often a good idea, depending on your operating system shell syntax. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;USING THE EXTERNAL GZIP&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;:gzip_write_open&lt;/code&gt; （|）を持っていると引数がパイプ記号で始まる必要があります &lt;code&gt;%s&lt;/code&gt; のをファイル名に。オペレーティングシステムのシェル構文によっては、出力リダイレクト（&amp;gt;）もよくあります。&lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;外部GZIPの使用を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="244205effe1c86456dd4171100ec82efbb0324f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:locale&lt;/code&gt; does not currently work with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;, only with the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma. The &lt;code&gt;:utf8&lt;/code&gt; and &lt;code&gt;:encoding(...)&lt;/code&gt; methods do work with all of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;, and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma.</source>
          <target state="translated">&lt;code&gt;:locale&lt;/code&gt; 、現在では動作しません &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; だけで、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; プラグマ。 &lt;code&gt;:utf8&lt;/code&gt; と &lt;code&gt;:encoding(...)&lt;/code&gt; メソッドは、すべてと仕事を &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; プラグマ。</target>
        </trans-unit>
        <trans-unit id="b0a7c262fbc0be9a9844fe48c62a845c0f4528fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:locale&lt;/code&gt; sub-pragma</source>
          <target state="translated">&lt;code&gt;:locale&lt;/code&gt; サブプラグマ</target>
        </trans-unit>
        <trans-unit id="90148b6fce0bbabdeb9d2a0e71e782bdff20ba4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:mmap&lt;/code&gt; layer will not exist if the platform does not support &lt;code&gt;mmap()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;:mmap&lt;/code&gt; プラットフォームがサポートされていない場合は層が存在しません &lt;code&gt;mmap()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd944a87b4f64134b2d5190fde7ca74a27bd05a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:raw&lt;/code&gt; layer is</source>
          <target state="translated">&lt;code&gt;:raw&lt;/code&gt; 層であります</target>
        </trans-unit>
        <trans-unit id="eb8af45fe08808536fe0e78893d59ec120f251eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:std&lt;/code&gt; subpragma on its own has no effect, but if combined with the &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding&lt;/code&gt; subpragmas, it converts the standard filehandles (STDIN, STDOUT, STDERR) to comply with encoding selected for input/output handles. For example, if both input and out are chosen to be &lt;code&gt;:encoding(utf8)&lt;/code&gt; , a &lt;code&gt;:std&lt;/code&gt; will mean that STDIN, STDOUT, and STDERR are also in &lt;code&gt;:encoding(utf8)&lt;/code&gt; . On the other hand, if only output is chosen to be in &lt;code&gt;:encoding(koi8r)&lt;/code&gt; , a &lt;code&gt;:std&lt;/code&gt; will cause only the STDOUT and STDERR to be in &lt;code&gt;koi8r&lt;/code&gt; . The &lt;code&gt;:locale&lt;/code&gt; subpragma implicitly turns on &lt;code&gt;:std&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;:std&lt;/code&gt; 独自にサブプラグマは影響を及ぼさないが、組み合わせる場合 &lt;code&gt;:utf8&lt;/code&gt; または &lt;code&gt;:encoding&lt;/code&gt; subpragmas、入力/出力ハンドルのために選択したエンコードに準拠する標準ファイルハンドル（STDIN、STDOUT、STDERR）に変換します。インプットとアウトの両方があるように選択される場合、例えば &lt;code&gt;:encoding(utf8)&lt;/code&gt; 、 &lt;code&gt;:std&lt;/code&gt; STDIN、STDOUT、およびSTDERRにもあることを意味する &lt;code&gt;:encoding(utf8)&lt;/code&gt; 。一方、出力のみが &lt;code&gt;:encoding(koi8r)&lt;/code&gt; に含まれるように選択されている場合、 &lt;code&gt;:std&lt;/code&gt; はSTDOUTとSTDERRのみが &lt;code&gt;koi8r&lt;/code&gt; に含まれるようにします。 &lt;code&gt;:locale&lt;/code&gt; サブプラグマは、暗黙的にオンに &lt;code&gt;:std&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2743b792818bf7f895d0f0b22baae763060aa81f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:void&lt;/code&gt; option is supported in &lt;a href=&quot;fatal&quot;&gt;Fatal&lt;/a&gt;, but not &lt;code&gt;autodie&lt;/code&gt; . To workaround this, &lt;code&gt;autodie&lt;/code&gt; may be explicitly disabled until the end of the current block with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; . To disable autodie for only a single function (eg, open) use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(open)&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;:void&lt;/code&gt; オプションがサポートされ&lt;a href=&quot;fatal&quot;&gt;致命的&lt;/a&gt;ではなく、 &lt;code&gt;autodie&lt;/code&gt; 。これを回避するには、 &lt;code&gt;autodie&lt;/code&gt; は、明示的で、現在のブロックの終わりまで無効にすることも &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; 。単一の機能（たとえば、open）のみの自動ダイを無効にするには、 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(open)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="67318be992f4377bb68fbe49ed99f910c657a047" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method is used to create an instance of the filter. It is called indirectly by Perl when it encounters the &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; MyFilter&lt;/code&gt; line in a source file (See &lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt; for more details on &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法は、フィルタのインスタンスを作成するために使用されます。ソースファイルで &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; MyFilter&lt;/code&gt; 行が検出されると、Perlによって間接的に呼び出されます（&lt;a href=&quot;../../functions/import&quot;&gt;インポートの&lt;/a&gt;詳細については、 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 参照してください）。</target>
        </trans-unit>
        <trans-unit id="69849addd7818fee9c7e8c167a05d6c0d2986859" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; will</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 意志</target>
        </trans-unit>
        <trans-unit id="0eafa6355d483056647b2819a7f67215461c3497" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call returns an object, say &lt;code&gt;$o&lt;/code&gt; . You may call</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; コールは言う、オブジェクトを返す &lt;code&gt;$o&lt;/code&gt; 。あなたは電話するかもしれません</target>
        </trans-unit>
        <trans-unit id="51ffe3fc21c6601c2932126d4f4eca5123604eda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct can also be used to localize the deletion of array/hash elements to the current block. See &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; の&lt;a href=&quot;delete&quot;&gt;削除&lt;/a&gt; EXPR構文を使用して、配列/ハッシュ要素の削除を現在のブロックにローカライズすることもできます。&lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;perlsubの複合型の要素のローカライズされた削除を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b1621ad946434d6c08e6becea5950298e8d654de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct localizes the deletion to the current block at run time. Until the block exits, elements locally deleted temporarily no longer exist. See &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; の&lt;a href=&quot;delete&quot;&gt;削除&lt;/a&gt; EXPR構文は、実行時に削除を現在のブロックにローカライズします。ブロックが終了するまで、一時的にローカルに削除された要素は存在しなくなります。&lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;perlsubの複合型の要素のローカライズされた削除を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="413b32076323a1b9dc32ef8307740eba59479274" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function executes a system command</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 関数は、システムコマンドを実行します</target>
        </trans-unit>
        <trans-unit id="2195a8cff19304cef2dc99fbcce68cf6dbdaf4fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; function is not implemented on all versions of Windows. Check the documentation for your specific version of Perl.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; 関数は、Windowsのすべてのバージョンで実装されていません。Perlの特定のバージョンのドキュメントを確認してください。</target>
        </trans-unit>
        <trans-unit id="1cc7a7cd989d44101ffb59063ba0d9ec90f901e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; operator will attempt to insure that no translation of carriage control occurs on input from or output to this filehandle. Since this involves reopening the file and then restoring its file position indicator, if this function returns FALSE, the underlying filehandle may no longer point to an open file, or may point to a different position in the file than before &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; のオペレータは、キャリッジ制御のない翻訳は、このファイルハンドルへの入力または出力に発生しないことを保証しようとします。これにはファイルを再度開いてからファイル位置インジケーターを復元する必要があるため、この関数がFALSEを返すと、基になるファイルハンドルが開いているファイルを指さなくなったり、 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; が呼び出される前とはファイル内の別の位置を指したりすることがあります。</target>
        </trans-unit>
        <trans-unit id="d7b9155394683e2730126a87d41bdd8b7ec8ee0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; functions work on whole characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; 関数は、全体の文字に取り組みます。</target>
        </trans-unit>
        <trans-unit id="b8d018fd592275cef4c6f8f9148b669393d46ef8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; operator uses the &lt;code&gt;sys$hash_password&lt;/code&gt; system service to generate the hashed representation of PLAINTEXT. If USER is a valid username, the algorithm and salt values are taken from that user's UAF record. If it is not, then the preferred algorithm and a salt of 0 are used. The quadword encrypted value is returned as an 8-character string.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; 演算子は使用しています &lt;code&gt;sys$hash_password&lt;/code&gt; PLAINTEXTのハッシュされた表現を生成するシステムサービスを。USERが有効なユーザー名である場合、アルゴリズムとソルト値はそのユーザーのUAFレコードから取得されます。そうでない場合は、優先アルゴリズムと0のソルトが使用されます。クワッドワードの暗号化された値は、8文字の文字列として返されます。</target>
        </trans-unit>
        <trans-unit id="51567ba352ff0d9256d32ae3d4a4cc5e55c3b1bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct can also be used to localize the deletion of array/hash elements to the current block. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; の&lt;a href=&quot;functions/delete&quot;&gt;削除&lt;/a&gt; EXPR構文を使用して、配列/ハッシュ要素の削除を現在のブロックにローカライズすることもできます。&lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;perlsubの複合型の要素のローカライズされた削除を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="205f4f4c053e1354b5fd41e9a973041210cd6cb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct localizes the deletion to the current block at run time. Until the block exits, elements locally deleted temporarily no longer exist. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; の&lt;a href=&quot;functions/delete&quot;&gt;削除&lt;/a&gt; EXPR構文は、実行時に削除を現在のブロックにローカライズします。ブロックが終了するまで、一時的にローカルに削除された要素は存在しなくなります。&lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;perlsubの複合型の要素のローカライズされた削除を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7c330ed0d1614413aef6482d1172074b901ca8ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; construct isn't a real loop that you can use loop control on.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; 構文を使用すると、上のループ制御を使用できることを本当のループではありません。&lt;a href=&quot;functions/do&quot;&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf5bbfe9093c8abccc03e7c7efe8dbe3d8e0233d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; operator can be a bit tricky though. You can't add or delete keys of the hash while you're using it without possibly skipping or re-processing some pairs after Perl internally rehashes all of the elements. Additionally, a hash has only one iterator, so if you mix &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; on the same hash, you risk resetting the iterator and messing up your processing. See the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; entry in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; 演算子は、ビットトリッキーしかしすることができます。Perlがすべての要素を内部的に再ハッシュした後、いくつかのペアをスキップまたは再処理することなく、ハッシュの使用中にハッシュのキーを追加または削除することはできません。また、ハッシュにはイテレータが1つしかないため、同じハッシュに &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; を混在させると、イテレータがリセットされて処理が台無しになるリスクがあります。詳細については、&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;の &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; エントリを参照してください。</target>
        </trans-unit>
        <trans-unit id="6a7ce17abb69e82a8250b438247bf503d68963f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; operator returns the pairs in apparently random order, so if ordering matters to you, you'll have to stick with the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 事業者は、明らかにランダムな順序でペアを返すので、あなたに問題を注文する場合は、あなたがに固執する必要があります &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="1d704aced95cc8764eb35404aac65f2304fbf2d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; method wrapped an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; around a &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;, and so waited for a thread to exit, passing along any values the thread might have returned and placing any errors into &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 方法は、ラップ &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 周り &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; スレッドが戻ったかもしれない任意の値に沿って通過するとに、エラーを置くと、その出口にスレッドを待っていました &lt;code&gt;$@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80c53083069f05797eef5848d626cca139bde071" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; feature enables the &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; keyword, which evaluates the argument passed to it as a string of bytes. It dies if the string contains any characters outside the 8-bit range. Source filters work within &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt;: they apply to the contents of the string being evaluated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; の機能が有効に &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; キーワード、バイトの文字列として渡された引数を評価しているし。文字列に8ビットの範囲外の文字が含まれている場合は、終了します。ソースフィルターは &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; 内で機能します。これらは、評価される文字列の内容に適用されます。</target>
        </trans-unit>
        <trans-unit id="013c20c8a39c1e9d213753c8f42aa60136c4133a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function executes a system command</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 関数は、システムコマンドを実行します</target>
        </trans-unit>
        <trans-unit id="cc6b445e37f9fe0173dc131ac1ed2864194322f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function's job is to turn your process into another command and never to return. If that's not what you want to do, don't use &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;. :)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 関数の仕事は、別のコマンドに、決してリターンにあなたのプロセスを有効にすることです。それがあなたがやりたいことではないなら、 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; を使わないでください。:)</target>
        </trans-unit>
        <trans-unit id="c64c8f5547bb2a6573770267608423f5c2aa4dc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for(each)&lt;/a&gt;&lt;/code&gt; modifier is an iterator: it executes the statement once for each item in the LIST (with &lt;code&gt;$_&lt;/code&gt; aliased to each item in turn).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for(each)&lt;/a&gt;&lt;/code&gt; 修飾子はイテレータです：それは一度（と、リスト内の各アイテムに対してstatementを実行 &lt;code&gt;$_&lt;/code&gt; 順番に各項目にエイリアス）。</target>
        </trans-unit>
        <trans-unit id="fcbb7f06dac39b4543299760a90086a0717180ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; function, even though it only takes one argument, has the precedence of a list operator, so beware:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; の機能は、それが唯一の引数を取るにもかかわらず、リスト演算子の優先順位を持っているので、注意してください：</target>
        </trans-unit>
        <trans-unit id="d7025a8a8790fde9485d755f6c425f01c04b8467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; operator will function properly if you have a working CRTL &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; routine, or if the logical name SYS$TIMEZONE_DIFFERENTIAL is defined as the number of seconds which must be added to UTC to yield local time. (This logical name is defined automatically if you are running a version of VMS with built-in UTC support.) If neither of these cases is true, a warning message is printed, and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; はのオペレータを使用すると、作業CRTLを持っている場合は正常に機能します &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; ルーチンを、または論理名SYS $ TIMEZONE_DIFFERENTIALは現地時間を得るためにUTCに追加しなければならない秒数として定義されている場合。 （この論理名は、組み込みUTCサポートを備えたバージョンのVMSを実行している場合に自動的に定義されます。）これらのどちらのケースにも該当しない場合、警告メッセージが出力され、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="5a3ff2f4c2a7967681e4811d9bc792e927dbfcbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; form is quite different from the other forms of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. In fact, it isn't a goto in the normal sense at all, and doesn't have the stigma associated with other gotos. Instead, it exits the current subroutine (losing any changes set by local()) and immediately calls in its place the named subroutine using the current value of @_. This is used by &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; の形式は、他の形態とは全く異なる &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 。実際、これは通常の意味でのgotoではなく、他のgotoに関連する汚名もありません。代わりに、現在のサブルーチンを終了し（local（）によって設定された変更は失われます）、その場所で、@ _の現在の値を使用して名前付きサブルーチンをすぐに呼び出します。これはで使用されている &lt;code&gt;AUTOLOAD&lt;/code&gt; の願いは別のサブルーチンをロードして、他のサブルーチンが最初に呼ばれたようふりをすることサブルーチン（への変更点を除いて &lt;code&gt;@_&lt;/code&gt; 現在のサブルーチンでは、他のサブルーチンに伝播されます。）後に &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; さえも このルーチンが最初に呼び出されたことを知ることができます。</target>
        </trans-unit>
        <trans-unit id="8c6cdb8b9140a3413b924a1be37defd8094c23ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; form expects to evaluate &lt;code&gt;EXPR&lt;/code&gt; to a code reference or a label name. If it evaluates to a code reference, it will be handled like &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; , below. This is especially useful for implementing tail recursion via &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 形式は、評価することを期待 &lt;code&gt;EXPR&lt;/code&gt; をコード参照またはラベル名に。コード参照に評価される場合、以下の &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; ように処理されます。これは、 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; を介して末尾再帰を実装する場合に特に便利です。</target>
        </trans-unit>
        <trans-unit id="f9a08aec53b4872b20c38601dfe1ff47bb7271a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; form finds the statement labeled with LABEL and resumes execution there. It can't be used to get out of a block or subroutine given to &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is; C is another matter). (The difference is that C does not offer named loops combined with loop control. Perl does, and this replaces most structured uses of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; in other languages.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; 形式は、標識で標識された文を見つけだし、そこから実行を再開します。 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; に指定されたブロックまたはサブルーチンから抜け出すために使用することはできません。これは、サブルーチンの外を含む、動的スコープ内の他のほぼすべての場所に移動するために使用できますが、通常は、 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; などの他の構成を使用する方が適切です。 Perlの作者は、この形式の &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; を使用する必要性を感じたことはありません（Perlでは、Cは別の問題です）。 （違いは、Cはループ制御と組み合わせた名前付きループを提供しないことです。Perlが提供し、これは他の言語での &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; のほとんどの構造化された使用を置き換えます。）</target>
        </trans-unit>
        <trans-unit id="fd5e7141b6809acf60b4ffb9ca0527589ab4d1fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-&amp;amp;NAME form is highly magical, and substitutes a call to the named subroutine for the currently running subroutine. This is used by &lt;code&gt;AUTOLOAD()&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; - ＆NAMEの形式は非常に魔法で、現在実行中のサブルーチンの名前が付けられたサブルーチンへの呼び出しを置き換えます。これは、別のサブルーチンをロードし、最初に他のサブルーチンが呼び出されたように見せかける &lt;code&gt;AUTOLOAD()&lt;/code&gt; サブルーチンによって使用されます（現在のサブルーチンでの &lt;code&gt;@_&lt;/code&gt; への変更が他のサブルーチンに伝達される場合を除く）。 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; でさえ、このルーチンが最初に呼び出されたことを認識できません。</target>
        </trans-unit>
        <trans-unit id="0f2fbb144491503128d3d631573fe99dbb58cb74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-EXPR form expects a label name, whose scope will be resolved dynamically. This allows for computed &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -EXPRフォームは、その範囲を動的に解決されるラベル名を、期待しています。これにより、FORTRANごとに計算された &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; が可能になりますが、保守性を最適化している場合は、必ずしも推奨されません。</target>
        </trans-unit>
        <trans-unit id="747fd1051ce1561b7aad0a462ec80a7083e807f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-LABEL form finds the statement labeled with LABEL and resumes execution there. It may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is--C is another matter).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -labelフォームは標識で標識された文を見つけだし、そこから実行を再開します。サブルーチンや &lt;code&gt;foreach&lt;/code&gt; ループなど、初期化が必要な構成要素へのアクセスには使用できません。また、最適化された構成に入るのにも使用できません。これは、サブルーチンの外を含む、動的スコープ内の他のほぼすべての場所に移動するために使用できますが、通常は、 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; などの他の構成を使用する方が適切です。Perlの作者は、この形式の &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; を使用する必要性を感じたことはありません（Perlでは、Cは別の問題です）。</target>
        </trans-unit>
        <trans-unit id="b3e30e59d91f75eda248244fb51004176883c63f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in scalar context returns the count. If you want the list of matching items, just use it in list context instead:</source>
          <target state="translated">スカラーコンテキストの &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; はカウントを返します。一致するアイテムのリストが必要な場合は、代わりにリストコンテキストで使用します。</target>
        </trans-unit>
        <trans-unit id="612dabc89cee10beadc6c980b04dfdba8cc2e280" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; function also resets the iterator, which means that you may see strange results if you use this between uses of other hash operators such as &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; 関数は、次のような他のハッシュ演算子の使用の間、これを使用する場合は奇妙な結果を見ることができることを意味し、イテレータ、リセット &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84a92b66f23e84ffcea0f8036601109332768c0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; function can be used to test this functionality from within a program.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 機能は、プログラム内からこの機能をテストするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="8f9dd8be24cd7b207201afca586d0393221c8761" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; function in the parent's &lt;code&gt;if&lt;/code&gt; block is there to send a signal to our child process, currently running in the &lt;code&gt;else&lt;/code&gt; block, as soon as the remote server has closed its end of the connection.</source>
          <target state="translated">リモートサーバーが接続の終わりを閉じるとすぐに、親の &lt;code&gt;if&lt;/code&gt; ブロックの &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 関数が存在して、現在 &lt;code&gt;else&lt;/code&gt; ブロックで実行されている子プロセスにシグナルを送信します。</target>
        </trans-unit>
        <trans-unit id="8bfb3b07d45ff01232bb221af626a6a5fb4ea5a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command immediately exits the loop in question. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; コマンドループを即座に抜けます。 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 存在する場合、ブロックを、実行されません。</target>
        </trans-unit>
        <trans-unit id="ac302bdab0f919a07174f63d0969bebc85f1b892" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;break&lt;/code&gt; statement in C (as used in loops); it immediately exits the loop in question. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; コマンドは次のようにある &lt;code&gt;break&lt;/code&gt; （ループ内で使った）Cの陳述。問題のループをすぐに終了します。LABELが省略されている場合、コマンドは最も内側の囲みループを参照します。 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; 形式はPerl 5.18.0で入手可能な出発は、ラベル名は、実行時に計算することができ、そしてそれ以外に同じである &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 存在する場合、ブロックを、実行されません。</target>
        </trans-unit>
        <trans-unit id="506963259280dc353e83831a1d7243717b046918" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; Keyword</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; キーワード</target>
        </trans-unit>
        <trans-unit id="249bfee98e5c2e5ddbdeda77c1a70bb97c684fdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; function takes a shared variable and puts a lock on it. No other thread may lock the variable until the variable is unlocked by the thread holding the lock. Unlocking happens automatically when the locking thread exits the block that contains the call to the &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; function. Using &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; is straightforward: This example has several threads doing some calculations in parallel, and occasionally updating a running total:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; 関数は共有変数を取り、それにロックを置きます。ロックを保持しているスレッドによって変数がロック解除されるまで、他のスレッドは変数をロックできません。ロック解除スレッドは、 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; 関数の呼び出しを含むブロックを終了すると自動的に解除されます。 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; の使用は簡単です。この例では、いくつかのスレッドがいくつかの計算を並行して実行し、時々合計を更新しています。</target>
        </trans-unit>
        <trans-unit id="844dd628839d69aa91981cfdf9d35b8aa941b210" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; is actually not required; you could just use:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ISは、実際には必要ありません。あなたはただ使うことができます：</target>
        </trans-unit>
        <trans-unit id="15c7027f68a72fedc245e7d612cf00a82d9df24d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; is simply a modifier on something you might assign to. So when you do assign to variables in its argument list, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; doesn't change whether those variables are viewed as a scalar or an array. So</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 単にあなたがに割り当てるかもしれない何かの修飾子です。したがって、引数リストの変数に割り当てても、それらの変数がスカラーと配列のどちらとして表示されても、 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; は変更しません。そう</target>
        </trans-unit>
        <trans-unit id="82cb7d6fd4d7d98853ace6ba4000362cdc7fa762" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; operator declares the listed variables to be lexically confined to the enclosing block, conditional (&lt;code&gt;if/unless/elsif/else&lt;/code&gt;), loop (&lt;code&gt;for/foreach/while/until/continue&lt;/code&gt;), subroutine, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do/require/use&lt;/a&gt;&lt;/code&gt;'d file. If more than one value is listed, the list must be placed in parentheses. All listed elements must be legal lvalues. Only alphanumeric identifiers may be lexically scoped--magical built-ins like &lt;code&gt;$/&lt;/code&gt; must currently be &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized with &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; オペレータは、字句的に取り囲むブロック、（条件に限定することが記載されている変数を宣言します &lt;code&gt;if/unless/elsif/else&lt;/code&gt; ）、ループ（ &lt;code&gt;for/foreach/while/until/continue&lt;/code&gt; ）、サブルーチン、 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; の、または &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do/require/use&lt;/a&gt;&lt;/code&gt; 'dファイル。複数の値がリストされている場合は、リストを括弧で囲む必要があります。リストされたすべての要素は、正当な左辺値でなければなりません。英数字のみ識別子はレキシカルスコープすることができる-のような魔法のような組み込み関数 &lt;code&gt;$/&lt;/code&gt; 現在する必要があります &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; と化し &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 代わりに。</target>
        </trans-unit>
        <trans-unit id="598c24981891ed39a33542154be0ea54335c8268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement in C; it starts the next iteration of the loop:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; コマンドは次のようにあり &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; C内のステートメント。ループの次の反復を開始します。</target>
        </trans-unit>
        <trans-unit id="4ac987f577bf457aa0aa7edd6027d43957e00541" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command starts the next iteration of the loop:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; のコマンドは、ループの次の反復を開始します。</target>
        </trans-unit>
        <trans-unit id="90d027781b9d30c834bc3f75976b8010ac44b08a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; keywords work differently.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; キーワードは異なる動作をします。</target>
        </trans-unit>
        <trans-unit id="5eeb76addad99da0bbdd65d75ec9e60f2b34827f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma doesn't</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; プラグマはしていません</target>
        </trans-unit>
        <trans-unit id="7bf3b5adc84fde6d734586f4bec0209359aa5187" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; lib&lt;/code&gt; statement deletes all instances of each named directory from @INC.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; lib&lt;/code&gt; 文は@INCから各指定されたディレクトリのすべてのインスタンスを削除します。</target>
        </trans-unit>
        <trans-unit id="1aa289805fbc7ad3a1863fbfa81d350e063c7221" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;|-&quot;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(BAR, &quot;-|&quot;)&lt;/code&gt; constructs are not yet implemented. This limitation can be easily worked around in new code by creating a pipe explicitly. The following example shows how to write to a forked child:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;|-&quot;)&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(BAR, &quot;-|&quot;)&lt;/code&gt; 構築物はまだ実装されていません。この制限は、パイプを明示的に作成することにより、新しいコードで簡単に回避できます。次の例は、フォークされた子に書き込む方法を示しています。</target>
        </trans-unit>
        <trans-unit id="91b6442686235ec3446ecfbcfcc1b68ae5f717df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma serves as one of the interfaces to declare default &quot;layers&quot; (also known as &quot;disciplines&quot;) for all I/O. Any two-argument open(), readpipe() (aka qx//) and similar operators found within the lexical scope of this pragma will use the declared defaults. Even three-argument opens may be affected by this pragma when they don't specify IO layers in MODE.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; プラグマはすべてのI / Oのために（また、「分野」としても知られる）デフォルトの「層」を宣言するためのインターフェイスとして機能します。このプラグマの字句スコープ内にある2つの引数を持つopen（）、readpipe（）（別名qx //）および類似の演算子は、宣言されたデフォルトを使用します。3つの引数のオープンでさえ、MODEでIOレイヤーを指定しない場合、このプラグマの影響を受ける可能性があります。</target>
        </trans-unit>
        <trans-unit id="d568cb2b48539b711386365d8e03258e04c0c727" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; functions work transparently on all codepoints, not just on ASCII alone &amp;mdash; nor in fact, not even just on Unicode alone.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 関数だけではないだけでASCIIに、すべてのコードポイントに透過的に動作する-も実際には、ないだけでも一人ではUnicodeに。</target>
        </trans-unit>
        <trans-unit id="48c955c71d75929afac22e8dfa9aad63b2004a10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator showed up in perl 5.005. It compiles a regular expression, but doesn't apply it. When you use the pre-compiled version of the regex, perl does less work. In this example, I inserted a &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; to turn each pattern into its pre-compiled form. The rest of the script is the same, but faster:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 演算子は、Perl 5.005に現れました。正規表現をコンパイルしますが、適用しません。コンパイル済みバージョンの正規表現を使用すると、perlはあまり機能しません。この例では、 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; を挿入して、各パターンをコンパイル済みの形式に変換しました。スクリプトの残りの部分は同じですが、より高速です。</target>
        </trans-unit>
        <trans-unit id="6086a140e1b37399f10a989a119aa2028d369c83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; コマンドが再び条件を評価することなく、ループブロックを再開する。 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 、であれば、ブロックを</target>
        </trans-unit>
        <trans-unit id="362e8253628830d9a4d5614fd639fe79bc546984" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;
LABEL&lt;/code&gt; . Programs that want to lie to themselves about what was just input normally use this command:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; コマンドが再び条件を評価することなく、ループブロックを再開する。 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 存在する場合、ブロックを、実行されません。LABELが省略されている場合、コマンドは最も内側の囲みループを参照します。 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; 形式はPerl 5.18.0で入手可能な出発は、ラベル名は、実行時に計算することができ、そしてそれ以外に同一 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; LABEL&lt;/code&gt; 。入力されたものについて嘘をつきたいプログラムは通常、次のコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="f9c130f1621f9ce97dabd985717a6055d0d6afd0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; substitution operator is documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 置換演算子は、に記載されて&lt;a href=&quot;perlop&quot;&gt;はperlop&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="121511ae0b5d1fbb23eba64b638e8a05d463c939" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; function is another place where a regexp is used. &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; /regexp/, string, limit&lt;/code&gt; separates the &lt;code&gt;string&lt;/code&gt; operand into a list of substrings and returns that list. The regexp must be designed to match whatever constitutes the separators for the desired substrings. The &lt;code&gt;limit&lt;/code&gt; , if present, constrains splitting into no more than &lt;code&gt;limit&lt;/code&gt; number of strings. For example, to split a string into words, use</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; 関数は、正規表現を使用している別の場所です。 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; /regexp/, string, limit&lt;/code&gt; は、 &lt;code&gt;string&lt;/code&gt; オペランドを部分文字列のリストに分離し、そのリストを返します。正規表現は、目的の部分文字列のセパレータを構成するものと一致するように設計する必要があります。 &lt;code&gt;limit&lt;/code&gt; 、存在する場合、より多くないに分割を制約する &lt;code&gt;limit&lt;/code&gt; 文字列の数。たとえば、文字列を単語に分割するには、次を使用します</target>
        </trans-unit>
        <trans-unit id="7f7da5ebd320780203ed7d5e0028f1f486db3bfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword creates a lexical variable (following the same scoping rules as &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;) that persists from one subroutine call to the next. If a state variable resides inside an anonymous subroutine, then each copy of the subroutine has its own copy of the state variable. However, the value of the state variable will still persist between calls to the same copy of the anonymous subroutine. (Don't forget that &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; { ... }&lt;/code&gt; creates a new subroutine each time it is executed.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; キーワードは、（同じスコープ規則、次のレキシカル変数を作成 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ）と次のサブルーチン呼び出しから持続することを。状態変数が無名サブルーチン内にある場合、サブルーチンの各コピーには、状態変数の独自のコピーがあります。ただし、状態変数の値は、無名サブルーチンの同じコピーへの呼び出し間でも保持されます。（ &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; { ... }&lt;/code&gt; は、実行されるたびに新しいサブルーチンを作成することを忘れないでください。）</target>
        </trans-unit>
        <trans-unit id="87a4764ce311581074e8327a658c6ee1ed914b66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; probes gain a fourth argument: the package name of the function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; 機能のパッケージ名：プローブは、四番目の引数を獲得します。</target>
        </trans-unit>
        <trans-unit id="fa495b532decb2c8f20d40c7506dd35df2aff6f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; built-in is considered to have failed in the following circumstances:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 内蔵のは、次の状況で失敗したとみなされます。</target>
        </trans-unit>
        <trans-unit id="007bfa453d22a010bcc25f103e9e741d0e19770d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; operator creates a subprocess, and passes its arguments to the subprocess for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt; , any valid DCL command string may be specified. If the string begins with '@', it is treated as a DCL command unconditionally. Otherwise, if the first token contains a character used as a delimiter in file specification (e.g. &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;]&lt;/code&gt;), an attempt is made to expand it using a default type of</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; オペレータは、サブプロセスを作成し、DCLコマンドとして実行するためのサブプロセスに引数を渡します。サブプロセスは &lt;code&gt;lib$spawn()&lt;/code&gt; を介して直接作成されるため、有効なDCLコマンド文字列を指定できます。文字列が「@」で始まる場合、無条件にDCLコマンドとして扱われます。それ以外の場合、最初のトークンにファイル指定で区切り文字として使用される文字が含まれている場合（例 &lt;code&gt;:&lt;/code&gt; または &lt;code&gt;]&lt;/code&gt; ）、デフォルトのタイプを使用してそれを拡張しようとします</target>
        </trans-unit>
        <trans-unit id="c442498b077f35c1d517c581c1d1aa5d5b6d170c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; function returns elapsed realtime since some point in the past (such as system startup), user and system times for this process, and user and system times used by child processes. All times are returned in clock ticks.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; 関数戻り、子プロセスで使用される過去のある時点（例えば、システムの起動など）、このプロセスのユーザとシステム時間、およびユーザとシステム時代からリアルタイム経過しました。すべての時間はクロック刻みで返されます。</target>
        </trans-unit>
        <trans-unit id="80b97318408e6d656bf28c96d67c4dfdc24c2653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; operator translates whole characters. (Note that the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///CU&lt;/a&gt;&lt;/code&gt; functionality has been removed. For similar functionality to that, see &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('U0', ...)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('C0', ...)&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 演算子は、全体の文字を変換します。（ &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///CU&lt;/a&gt;&lt;/code&gt; 機能は削除されています。同様の機能については、 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('U0', ...)&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('C0', ...)&lt;/code&gt; 参照してください）。</target>
        </trans-unit>
        <trans-unit id="11a568ea0ae08ef300d37d167d740832b4c2b16f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; alternative might look like this:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 選択肢は次のようになります。</target>
        </trans-unit>
        <trans-unit id="42f87c254ee8d81cee26e792f60cacaefbfbe36a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; counts the null bytes. The &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; call returns a list of name-value pairs each of which is taken apart in the &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; ヌルバイトをカウントします。 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; コールがに間隔を取られそれぞれが名前と値のペアのリストを返し &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; ブロック。</target>
        </trans-unit>
        <trans-unit id="a53ff006297297281156ad4ddc8aef0830e3811c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; version is a clear winner. One solution is flexible, the other is fast - and it's appropriately the programmer's choice which to use.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; バージョンは明確な勝者です。1つのソリューションは柔軟性があり、もう1つのソリューションは高速です。適切な方法は、プログラマーが選択するものです。</target>
        </trans-unit>
        <trans-unit id="6f47b182b84a1df9e8040499b142da5e15a5a35d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; Gotcha</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; ガッチャ</target>
        </trans-unit>
        <trans-unit id="5e2ca855aa217bd553e610f05dba85cf9019d5da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma disables character semantics for the rest of the lexical scope in which it appears. &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; bytes&lt;/code&gt; can be used to reverse the effect of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; within the current lexical scope.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 、それが表示されるレキシカルスコープの残りのためのプラグマ無効キャラクタ・セマンティクス。 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; bytes&lt;/code&gt; を使用して、現在の字句スコープ内の &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; の&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;の影響を元に戻すことはでき&lt;a href=&quot;functions/no&quot;&gt;ません&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9fdef637aec2a8c40d4ef4a640873fd3daeaa545" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; filetest&lt;/code&gt; statements affect file tests defined in their block, up to the end of the closest enclosing block (they are lexically block-scoped).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; filetest&lt;/code&gt; 文がアップし、最も近い外側のブロックの終わり（彼らは字句スコープのブロックされている）に、そのブロック内で定義されたファイルのテストに影響を与えます。</target>
        </trans-unit>
        <trans-unit id="8744ea2543ae1b476ba91732c622f01f08c1038b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma tells the Perl parser to allow UTF-8 in the program text in the current lexical scope (allow UTF-EBCDIC on EBCDIC based platforms). The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8&lt;/code&gt; pragma tells Perl to switch back to treating the source text as literal bytes in the current lexical scope.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; プラグマは、現在のレキシカルスコープ（EBCDICベースのプラットフォーム上でUTF-EBCDICを許可する）のプログラムのテキストにUTF-8を許可するようにPerlのパーサに指示します。 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8&lt;/code&gt; プラグマは、現在のレキシカルスコープでリテラルバイトとしてソーステキストを処理に戻すためにPerlを伝えます。</target>
        </trans-unit>
        <trans-unit id="43067066e43761608ec314550d1ef0009ca78c23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; switch will warn you if it interprets a reserved word as a string. But it will no longer warn you about using lowercase words, because the string is effectively quoted.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; プラグマや&lt;b&gt;-w&lt;/b&gt;は文字列が予約語として解釈した場合、スイッチは、警告を表示します。ただし、文字列が効果的に引用符で囲まれているため、小文字の単語の使用について警告されなくなります。</target>
        </trans-unit>
        <trans-unit id="19cdd025fab18dcd164b56bb8b49804d47261c9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma produces some lovely diagnostics. One can also use the &lt;b&gt;-w&lt;/b&gt; flag, but its use is normally discouraged, because it gets applied to all executed Perl code, including that not under your control.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; プラグマは、いくつかの素敵な診断を生成します。&lt;b&gt;-w&lt;/b&gt;フラグを使用することもできますが、ユーザーの制御下にないものも含め、実行されたすべてのPerlコードに適用されるため、通常は使用しないでください。</target>
        </trans-unit>
        <trans-unit id="98ff32ffdb1aaec51b5964ab04fedf9b556042ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; function, even though it only takes one argument, has the precedence of a list operator, so beware:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; の機能は、それが唯一の引数を取るにもかかわらず、リスト演算子の優先順位を持っているので、注意してください：</target>
        </trans-unit>
        <trans-unit id="57bb7a10c9bf27aba4e74945efa7f4324ecc8306" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; form is quite different from the other forms of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. In fact, it isn't a goto in the normal sense at all, and doesn't have the stigma associated with other gotos. Instead, it exits the current subroutine (losing any changes set by local()) and immediately calls in its place the named subroutine using the current value of @_. This is used by &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; の形式は、他の形態とは全く異なる &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 。実際、これは通常の意味でのgotoではなく、他のgotoに関連する汚名もありません。代わりに、現在のサブルーチンを終了し（local（）によって設定された変更は失われます）、その場所で、@ _の現在の値を使用して名前付きサブルーチンをすぐに呼び出します。これはで使用されている &lt;code&gt;AUTOLOAD&lt;/code&gt; の願いは別のサブルーチンをロードして、他のサブルーチンが最初に呼ばれたようふりをすることサブルーチン（への変更点を除いて &lt;code&gt;@_&lt;/code&gt; 現在のサブルーチンでは、他のサブルーチンに伝播されます。）後に &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; さえも このルーチンが最初に呼び出されたことを知ることができます。</target>
        </trans-unit>
        <trans-unit id="e45cfef5656ef233c1972b6e6db8f04158149f58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; form expects to evaluate &lt;code&gt;EXPR&lt;/code&gt; to a code reference or a label name. If it evaluates to a code reference, it will be handled like &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; , below. This is especially useful for implementing tail recursion via &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 形式は、評価することを期待 &lt;code&gt;EXPR&lt;/code&gt; をコード参照またはラベル名に。コード参照に評価される場合、以下の &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; ように処理されます。これは、 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; を介して末尾再帰を実装する場合に特に便利です。</target>
        </trans-unit>
        <trans-unit id="a0fba7d2ee7cbb751d9b45951b63706bcd429d8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; form finds the statement labeled with LABEL and resumes execution there. It can't be used to get out of a block or subroutine given to &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is; C is another matter). (The difference is that C does not offer named loops combined with loop control. Perl does, and this replaces most structured uses of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; in other languages.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; 形式は、標識で標識された文を見つけだし、そこから実行を再開します。 &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; に指定されたブロックまたはサブルーチンから抜け出すために使用することはできません。これは、サブルーチンの外を含む、動的スコープ内の他のほぼすべての場所に移動するために使用できますが、通常、 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; などの他の構成要素を使用する方が適切です。 Perlの作者は、この形式の &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; を使用する必要性を感じたことはありません（Perlでは、Cは別の問題です）。 （違いは、Cはループ制御と組み合わせた名前付きループを提供しないことです。Perlが提供し、これは他の言語での &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; のほとんどの構造化された使用を置き換えます。）</target>
        </trans-unit>
        <trans-unit id="0ec2144df4bcb647e47e9a3fffb037716e0ff735" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;break&lt;/code&gt; statement in C (as used in loops); it immediately exits the loop in question. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; コマンドは次のようにある &lt;code&gt;break&lt;/code&gt; （ループ内で使った）Cの陳述。問題のループをすぐに終了します。LABELが省略されている場合、コマンドは最も内側の囲みループを参照します。 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; 形式はPerl 5.18.0で入手可能な出発は、ラベル名は、実行時に計算することができ、そしてそれ以外に同じである &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 存在する場合、ブロックを、実行されません。</target>
        </trans-unit>
        <trans-unit id="0dc04adeb5f33f6be3e55c3b75049d3460dd5faf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement in C; it starts the next iteration of the loop:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; コマンドは次のようにあり &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; C内のステートメント。ループの次の反復を開始します。</target>
        </trans-unit>
        <trans-unit id="d90f5477a728439ae001b7de4028bc5063fe8048" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;use re '/foo'&lt;/a&gt;&lt;/code&gt; pragma can be used to set default modifiers (including these) for regular expressions compiled within its scope. This pragma has precedence over the other pragmas listed below that also change the defaults.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;use re '/foo'&lt;/a&gt;&lt;/code&gt; プラグマは、その範囲内にコンパイルされた正規表現のために（これらを含む）セットデフォルトの修飾に使用することができます。このプラグマは、デフォルトを変更する以下にリストされている他のプラグマよりも優先されます。</target>
        </trans-unit>
        <trans-unit id="00f56e4e287b4dad7bb9b00175cad4e28ccf4f49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;
LABEL&lt;/code&gt; . Programs that want to lie to themselves about what was just input normally use this command:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; コマンドが再び条件を評価することなく、ループブロックを再開する。 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 存在する場合、ブロックを、実行されません。LABELが省略されている場合、コマンドは最も内側の囲みループを参照します。 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; 形式はPerl 5.18.0で入手可能な出発は、ラベル名は、実行時に計算することができ、そしてそれ以外に同一 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; LABEL&lt;/code&gt; 。入力されたばかりのものについて嘘をつきたいプログラムは、通常、次のコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="98d8fed67bad4314d20d9f4fe777fa7ab53123e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator (sometimes pronounced &quot;fat comma&quot;) is a synonym for the comma except that it causes a word on its left to be interpreted as a string if it begins with a letter or underscore and is composed only of letters, digits and underscores. This includes operands that might otherwise be interpreted as operators, constants, single number v-strings or function calls. If in doubt about this behavior, the left operand can be quoted explicitly.</source>
          <target state="translated">&lt;code&gt;=&amp;gt;&lt;/code&gt; 演算子（時々 、発音「脂肪カンマ」）は、それは文字またはアンダースコアで始まり、文字だけで構成されている場合、それは文字列として解釈されるその左側の単語を引き起こすことを除いて、コンマの同義語で、数字とアンダースコア。これには、演算子、定数、単一の数値のV文字列、または関数呼び出しとして解釈される可能性のあるオペランドが含まれます。この動作について疑問がある場合は、左のオペランドを明示的に引用できます。</target>
        </trans-unit>
        <trans-unit id="8399dbf8e2e784c4274bc7b091a4f7216970d51b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is helpful in documenting the correspondence between keys and values in hashes, and other paired elements in lists.</source>
          <target state="translated">&lt;code&gt;=&amp;gt;&lt;/code&gt; 演算子は、ハッシュのキーと値の対応関係、およびリスト内の他の対になった要素をドキュメントに有用です。</target>
        </trans-unit>
        <trans-unit id="efd3e2bb957eaa0ff2ef103df55bdfaea8225389" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=back&lt;/code&gt; command does not take any arguments.</source>
          <target state="translated">&lt;code&gt;=back&lt;/code&gt; コマンドは引数を取りません。</target>
        </trans-unit>
        <trans-unit id="2748bc14f635bff7b4cada98a19718c4d6f31834" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=begin&lt;/code&gt; directive can mark a section for a particular purpose. If the Pod parser doesn't want to handle it, it just ignores it. Label the comments with &lt;code&gt;comment&lt;/code&gt; . End the comment using &lt;code&gt;=end&lt;/code&gt; with the same label. You still need the &lt;code&gt;=cut&lt;/code&gt; to go back to Perl code from the Pod comment:</source>
          <target state="translated">&lt;code&gt;=begin&lt;/code&gt; ディレクティブは、特定の目的のためのセクションをマークすることができます。ポッドパーサーがそれを処理したくない場合は、それを無視します。コメントに &lt;code&gt;comment&lt;/code&gt; というラベルを付けます。同じラベルで &lt;code&gt;=end&lt;/code&gt; を使用してコメントを終了します。ポッドのコメントからPerlコードに戻るには、まだ &lt;code&gt;=cut&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="ef8064ce24f5339d152aec47e53a990ce73ae1e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=over&lt;/code&gt; command does not have a corresponding &lt;code&gt;=back&lt;/code&gt; before the next heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt; ) or the end of the file.</source>
          <target state="translated">&lt;code&gt;=over&lt;/code&gt; コマンドが対応する必要はありません &lt;code&gt;=back&lt;/code&gt; 次の見出しの前に（ &lt;code&gt;=head1&lt;/code&gt; または &lt;code&gt;=head2&lt;/code&gt; ）またはファイルの終わりを。</target>
        </trans-unit>
        <trans-unit id="8153dbca699722108378e052ce04788e510ab3df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@EXPORT&lt;/code&gt; array tells Perl which of the extension's variables and subroutines should be placed into the calling package's namespace. Because you don't know if the user has already used your variable and subroutine names, it's vitally important to carefully select what to export. Do</source>
          <target state="translated">&lt;code&gt;@EXPORT&lt;/code&gt; の配列は、呼び出し元のパッケージの名前空間に配置する必要がありエクステンションの変数とサブルーチンのPerlを伝えます。ユーザーがすでに変数名とサブルーチン名を使用しているかどうかはわからないため、何をエクスポートするかを慎重に選択することが非常に重要です。行う</target>
        </trans-unit>
        <trans-unit id="59c8e98631ebe2ad43446558b18c0e9a67b97b20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@array[1]&lt;/code&gt; is an array slice, although it has only one index. You can pull out multiple elements simultaneously by specifying additional indices as a list, like &lt;code&gt;@array[1,4,3,0]&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;@array[1]&lt;/code&gt; 、それが唯一のインデックスを有するが、配列スライスです。 &lt;code&gt;@array[1,4,3,0]&lt;/code&gt; ように、リストとして追加のインデックスを指定することで、複数の要素を同時にプルできます。</target>
        </trans-unit>
        <trans-unit id="651c155493f8eecba5929c58d7483ab06d1863f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ACTUAL&lt;/code&gt; tells &lt;code&gt;NEXT&lt;/code&gt; that there must actually be a next method to call, or it should throw an exception.</source>
          <target state="translated">&lt;code&gt;ACTUAL&lt;/code&gt; は伝え &lt;code&gt;NEXT&lt;/code&gt; をそこに実際に呼び出すために、次の方法でなければならない、またはそれが例外をスローする必要があること。</target>
        </trans-unit>
        <trans-unit id="8e537d261fb0eb0877ceb1c6331c23797b3540cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alias&lt;/code&gt; module implements localization of the basic types within the</source>
          <target state="translated">&lt;code&gt;Alias&lt;/code&gt; 内の基本的な種類のモジュールが実装ローカリゼーション</target>
        </trans-unit>
        <trans-unit id="2c6a8f1a286c25be4929a3d652924543120a4cba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Archive::Tar&lt;/code&gt; module can optionally use &lt;code&gt;Compress::Zlib&lt;/code&gt; (via the &lt;code&gt;IO::Zlib&lt;/code&gt; module) to access tar files that have been compressed with &lt;code&gt;gzip&lt;/code&gt; . Unfortunately tar files compressed with the Unix &lt;code&gt;compress&lt;/code&gt; utility cannot be read by &lt;code&gt;Compress::Zlib&lt;/code&gt; and so cannot be directly accesses by &lt;code&gt;Archive::Tar&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Archive::Tar&lt;/code&gt; モジュールは、必要に応じて使用することができます &lt;code&gt;Compress::Zlib&lt;/code&gt; （経由 &lt;code&gt;IO::Zlib&lt;/code&gt; で圧縮されているアクセスtarファイルにモジュールを） &lt;code&gt;gzip&lt;/code&gt; 。残念ながら、Unix &lt;code&gt;compress&lt;/code&gt; ユーティリティで圧縮されたtarファイルは &lt;code&gt;Compress::Zlib&lt;/code&gt; 読み取ることができないため、 &lt;code&gt;Archive::Tar&lt;/code&gt; 直接アクセスすることはできません。</target>
        </trans-unit>
        <trans-unit id="43769b61441be000184345132a2a54dc3708064b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B::COP&lt;/code&gt; class is used for &quot;nextstate&quot; and &quot;dbstate&quot; ops. As of Perl 5.22, it is also used for &quot;null&quot; ops that started out as COPs.</source>
          <target state="translated">&lt;code&gt;B::COP&lt;/code&gt; クラスは、 &quot;nextstate&quot;と&quot;dbstate&quot; OPSのために使用されています。Perl 5.22以降では、COPとして開始された「null」操作にも使用されます。</target>
        </trans-unit>
        <trans-unit id="1a2938ca3d630d110b73048269c361ea78fb5cb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module contains a set of utility functions for querying the current state of the Perl interpreter; typically these functions return objects from the B::SV and B::OP classes, or their derived classes. These classes in turn define methods for querying the resulting objects about their own internal state.</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; のモジュールは、Perlインタプリタの現在の状態を問い合わせるためのユーティリティ関数のセットを含みます。通常、これらの関数はB :: SVおよびB :: OPクラス、またはそれらの派生クラスからオブジェクトを返します。次に、これらのクラスは、独自の内部状態について結果のオブジェクトを照会するためのメソッドを定義します。</target>
        </trans-unit>
        <trans-unit id="40f9413962f128106cd0802b4a2c73013cd7ed0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module exports a variety of functions: some are simple utility functions, others provide a Perl program with a way to get an initial &quot;handle&quot; on an internal object.</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; のモジュールの輸出のさまざまな機能：いくつかの簡単なユーティリティ関数ですが、他は内部オブジェクトの最初の「ハンドル」を取得する方法でPerlプログラムを提供しています。</target>
        </trans-unit>
        <trans-unit id="5c92116836eedf111e1da108ac269b10e9e38e79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module supplies classes which allow a Perl program to delve into its own innards. It is the module used to implement the &quot;backends&quot; of the Perl compiler. Usage of the compiler does not require knowledge of this module: see the</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; のモジュールは、独自の内臓を詳細に調べるにPerlプログラムを許可するクラスを提供します。これは、Perlコンパイラの「バックエンド」を実装するために使用されるモジュールです。コンパイラの使用には、このモジュールの知識は必要ありません。</target>
        </trans-unit>
        <trans-unit id="36e744ee541a84c63162e7b4ffbdc783bc6d5f1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; subroutines are not so much subroutines as named special code blocks, of which you can have more than one in a package, and which you can &lt;b&gt;not&lt;/b&gt; call explicitly. See &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;BEGIN, UNITCHECK, CHECK, INIT and END in perlmod&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;BEGIN&lt;/code&gt; 、 &lt;code&gt;UNITCHECK&lt;/code&gt; 、 &lt;code&gt;CHECK&lt;/code&gt; 、 &lt;code&gt;INIT&lt;/code&gt; と &lt;code&gt;END&lt;/code&gt; サブルーチンは、パッケージ内に複数のを持つことができたのという名前の特別なコードブロックほどサブルーチン、ではない、とどのあなたがすることができ&lt;b&gt;ません&lt;/b&gt;明示的に呼び出します。&lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;perlmodのBEGIN、UNITCHECK、CHECK、INIT、ENDを&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="38a9cf1f5e3f21b86fcbb8df98f12cbc38b145e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; forces the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to happen at compile time. The &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; makes sure the module is loaded into memory if it hasn't been yet. The &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; is not a builtin; it's just an ordinary static method call into the &lt;code&gt;Module&lt;/code&gt; package to tell the module to import the list of features back into the current package. The module can implement its &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method any way it likes, though most modules just choose to derive their &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method via inheritance from the &lt;code&gt;Exporter&lt;/code&gt; class that is defined in the &lt;code&gt;Exporter&lt;/code&gt; module. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;. If no &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method can be found then the call is skipped, even if there is an AUTOLOAD method.</source>
          <target state="translated">&lt;code&gt;BEGIN&lt;/code&gt; 力が &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 、コンパイル時に発生します。 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; それはまだされていない場合は必ずモジュールがメモリにロードされますが。 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 組み込みではありません。これは、 &lt;code&gt;Module&lt;/code&gt; パッケージへの通常の静的メソッド呼び出しであり、機能のリストを現在のパッケージにインポートするようにモジュールに指示します。ほとんどのモジュールは、 &lt;code&gt;Exporter&lt;/code&gt; モジュールで定義されている &lt;code&gt;Exporter&lt;/code&gt; クラスからの継承を介して &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; メソッドを派生させることを選択するだけですが、モジュールは &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; メソッドを任意の方法で実装できます。&lt;a href=&quot;exporter&quot;&gt;エクスポーターを&lt;/a&gt;参照してください。いいえの場合 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; メソッドが見つかると、AUTOLOADメソッドがあっても呼び出しはスキップされます。</target>
        </trans-unit>
        <trans-unit id="a9fa3a73043129ebc13296822d30d370f57d9e72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; forces the &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to happen at compile time. The &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; makes sure the module is loaded into memory if it hasn't been yet. The &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; is not a builtin; it's just an ordinary static method call into the &lt;code&gt;Module&lt;/code&gt; package to tell the module to import the list of features back into the current package. The module can implement its &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method any way it likes, though most modules just choose to derive their &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method via inheritance from the &lt;code&gt;Exporter&lt;/code&gt; class that is defined in the &lt;code&gt;Exporter&lt;/code&gt; module. See &lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt;. If no &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method can be found then the call is skipped, even if there is an AUTOLOAD method.</source>
          <target state="translated">&lt;code&gt;BEGIN&lt;/code&gt; 力が &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 、コンパイル時に発生します。 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; それはまだされていない場合は必ずモジュールがメモリにロードされますが。 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 組み込みではありません。これは、 &lt;code&gt;Module&lt;/code&gt; パッケージへの通常の静的メソッド呼び出しであり、機能のリストを現在のパッケージにインポートするようにモジュールに指示します。ほとんどのモジュールは、 &lt;code&gt;Exporter&lt;/code&gt; モジュールで定義されている &lt;code&gt;Exporter&lt;/code&gt; クラスからの継承を介して &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; メソッドを派生させることを選択するだけですが、モジュールは &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; メソッドを任意の方法で実装できます。&lt;a href=&quot;../exporter&quot;&gt;エクスポーターを&lt;/a&gt;参照してください。いいえの場合 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; メソッドが見つかると、AUTOLOADメソッドがあっても呼び出しはスキップされます。</target>
        </trans-unit>
        <trans-unit id="9201471b5261b8b4c37aca6c270b666c4082753d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; will assure that the loading of</source>
          <target state="translated">&lt;code&gt;BEGIN&lt;/code&gt; のロードことを保証します</target>
        </trans-unit>
        <trans-unit id="08a5cc1adfa77075f0adc752b299d298837ebeee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;INIT&lt;/code&gt; blocks in code compiled by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, string &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, or string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; will not be executed if they occur after the end of the main compilation phase; that can be a problem in mod_perl and other persistent environments which use those functions to load code at runtime.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 、string &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 、またはstring &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; によってコンパイルされたコードの &lt;code&gt;CHECK&lt;/code&gt; および &lt;code&gt;INIT&lt;/code&gt; ブロックは、メインのコンパイルフェーズの終了後に発生した場合、実行されません。これは、mod_perlおよびこれらの関数を使用して実行時にコードをロードする他の永続的な環境で問題になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="9d8f4372f9a2ba513ea1d0d1264224c42f7ba97c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CNS11643&lt;/code&gt; encoding files are not complete. For common &lt;code&gt;CNS11643&lt;/code&gt; manipulation, please use &lt;code&gt;EUC-TW&lt;/code&gt; in &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;Encode::HanExtra&lt;/a&gt;, which contains planes 1-7.</source>
          <target state="translated">&lt;code&gt;CNS11643&lt;/code&gt; エンコードファイルが完全ではありません。共通のため &lt;code&gt;CNS11643&lt;/code&gt; の操作、使用してください &lt;code&gt;EUC-TW&lt;/code&gt; で&lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;エンコード:: HanExtra&lt;/a&gt;、プレーン1-7が含まれています。</target>
        </trans-unit>
        <trans-unit id="82651f5375f4780d1c104db566c2ac41e7d83b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CORE&lt;/code&gt; namespace gives access to the original built-in functions of Perl. The &lt;code&gt;CORE&lt;/code&gt; package is built into Perl, and therefore you do not need to use or require a hypothetical &quot;CORE&quot; module prior to accessing routines in this namespace.</source>
          <target state="translated">&lt;code&gt;CORE&lt;/code&gt; の名前空間は、内蔵のPerlの機能を元にアクセスすることができます。 &lt;code&gt;CORE&lt;/code&gt; のパッケージは、Perlに組み込まれているので、あなたが使用する必要はありませんか、この名前空間内のルーチンにアクセスする前に仮想の「CORE」モジュールが必要です。</target>
        </trans-unit>
        <trans-unit id="8ae42d583657def46159ee7ad1318ba4bd6a3fc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Compress::Zlib&lt;/code&gt; module can be split into two general areas of functionality, namely a simple read/write interface to</source>
          <target state="translated">&lt;code&gt;Compress::Zlib&lt;/code&gt; モジュールは、機能の二つの一般的な領域に、すなわち、単純な読み出し/書き込みインタフェースに分割することができ</target>
        </trans-unit>
        <trans-unit id="b6db4ade377c3bdb345b712f7106420996bb7261" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DB::OUT&lt;/code&gt; filehandle is opened to</source>
          <target state="translated">&lt;code&gt;DB::OUT&lt;/code&gt; ファイルハンドルを開放します</target>
        </trans-unit>
        <trans-unit id="b7ced3778c80b0e6ddceec7627220df1317342e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DEBUG&lt;/code&gt; constant wipes the floor with even the &lt;code&gt;$debug&lt;/code&gt; variable, clocking in at minus zero seconds, and generates a &quot;warning: too few iterations for a reliable count&quot; message into the bargain. To see what is really going on, and why we had too few iterations when we thought we asked for 100000, we can use the very useful &lt;code&gt;B::Deparse&lt;/code&gt; to inspect the new code:</source>
          <target state="translated">&lt;code&gt;DEBUG&lt;/code&gt; の定数はさえで床を拭く &lt;code&gt;$debug&lt;/code&gt; マイナスでゼロ秒でクロッキング、変数、および生成：バーゲンへのメッセージ「警告信頼性の数はあまりにも数回の反復を」。実際に何が起こっているのか、そして100000を要求したと思ったときに反復が少なすぎる理由を確認するには、非常に便利な &lt;code&gt;B::Deparse&lt;/code&gt; を使用して新しいコードを検査します。</target>
        </trans-unit>
        <trans-unit id="c9d4dcbece0076153dceb385297ea42930b3d2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DOES&lt;/code&gt; method returns</source>
          <target state="translated">&lt;code&gt;DOES&lt;/code&gt; のメソッドが返します</target>
        </trans-unit>
        <trans-unit id="13b108bacf05fadc1d57d69518e2671634247ba4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Deparse&lt;/code&gt; flag makes Dump() run slower, since the XSUB implementation does not support it.</source>
          <target state="translated">&lt;code&gt;Deparse&lt;/code&gt; フラグは、ダンプ（）XSUB実装がそれをサポートしていないため、実行速度が遅くなります。</target>
        </trans-unit>
        <trans-unit id="1afec46de9e3c4185e7d2feb3396554e349575f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel::NYTProf&lt;/code&gt; and &lt;code&gt;Devel::FindAmpersand&lt;/code&gt; modules can help you find uses of these problematic match variables in your code.</source>
          <target state="translated">&lt;code&gt;Devel::NYTProf&lt;/code&gt; と &lt;code&gt;Devel::FindAmpersand&lt;/code&gt; モジュールは、あなたのコードでこれらの問題のマッチ変数の使用法を見つけるのを助けることができます。</target>
        </trans-unit>
        <trans-unit id="7a6b56d230ad8470a46e41fa3a6181ade20a4909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel::SmallProf&lt;/code&gt; profiler examines the runtime of your Perl program and produces a line-by-line listing to show how many times each line was called, and how long each line took to execute. It is called by supplying the familiar &lt;code&gt;-d&lt;/code&gt; flag to Perl at runtime.</source>
          <target state="translated">&lt;code&gt;Devel::SmallProf&lt;/code&gt; プロファイラは、あなたのPerlプログラムの実行時間を調べ、ライン・バイ・ラインの各ラインが呼び出された回数を表示するようにリストを生成し、どのくらいの各行は、実行するのにかかりました。これは、実行時におなじみの &lt;code&gt;-d&lt;/code&gt; フラグをPerlに提供することによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="e3e899b88f5d9c103f9957a381fb75493e4ca219" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel&lt;/code&gt; namespace has several modules which you can use to profile your Perl programs.</source>
          <target state="translated">&lt;code&gt;Devel&lt;/code&gt; 名前空間には、あなたのPerlプログラムをプロファイルするために使用できるいくつかのモジュールがあります。</target>
        </trans-unit>
        <trans-unit id="f7b3b4bbb4e3a91049c3f2bf1c1599a52a4bab75" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::&lt;/code&gt; interface is based on the interface originally developed by Neil Winton for his &lt;code&gt;MD5&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;Digest::&lt;/code&gt; インターフェースは元々 、彼のためにニール・ウィントンによって開発されたインターフェイスに基づいて &lt;code&gt;MD5&lt;/code&gt; のモジュール。</target>
        </trans-unit>
        <trans-unit id="359f33360a7a83f14790bf4d659bef0945120eaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::&lt;/code&gt; modules calculate digests, also called &quot;fingerprints&quot; or &quot;hashes&quot;, of some data, called a message. The digest is (usually) some small/fixed size string. The actual size of the digest depend of the algorithm used. The message is simply a sequence of arbitrary bytes or bits.</source>
          <target state="translated">&lt;code&gt;Digest::&lt;/code&gt; モジュールは、メッセージと呼ばれるいくつかのデータ、の、また「指紋」または「ハッシュ」と呼ばれるダイジェストを計算します。ダイジェストは（通常）小さい/固定サイズの文字列です。ダイジェストの実際のサイズは、使用するアルゴリズムによって異なります。メッセージは単に任意のバイトまたはビットのシーケンスです。</target>
        </trans-unit>
        <trans-unit id="5112b49f2609b19e911cd2f6a34cb7ffa7088cff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module allows you to use the RSA Data Security Inc. MD5 Message Digest algorithm from within Perl programs. The algorithm takes as input a message of arbitrary length and produces as output a 128-bit &quot;fingerprint&quot; or &quot;message digest&quot; of the input.</source>
          <target state="translated">&lt;code&gt;Digest::MD5&lt;/code&gt; モジュールを使用すると、Perlプログラム内からRSAデータセキュリティ社のMD5メッセージダイジェストアルゴリズムを使用することができます。このアルゴリズムは、任意の長さのメッセージを入力として受け取り、入力として128ビットの「フィンガープリント」または「メッセージダイジェスト」を出力として生成します。</target>
        </trans-unit>
        <trans-unit id="2adafeb0e9eb580775e9922353cdda9ed2fef18a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module is written by Gisle Aas &amp;lt;gisle@ActiveState.com&amp;gt;.</source>
          <target state="translated">&lt;code&gt;Digest::MD5&lt;/code&gt; モジュールはGisle Aasの&amp;lt;gisle@ActiveState.com&amp;gt;によって書かれています。</target>
        </trans-unit>
        <trans-unit id="048cfda097524929fcf424f6794f7c010276767b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module provide a procedural interface for simple use, as well as an object oriented interface that can handle messages of arbitrary length and which can read files directly.</source>
          <target state="translated">&lt;code&gt;Digest::MD5&lt;/code&gt; 、単純な使用のための手続きインタフェースだけでなく、直接ファイルを読み込むことができ、任意の長さとのメッセージを処理することができ、オブジェクト指向のインターフェイスを提供モジュール。</target>
        </trans-unit>
        <trans-unit id="417545c4adfbc434083e36d20bccbfb0f99aa98e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::base&lt;/code&gt; class provide implementations of the methods &lt;code&gt;addfile&lt;/code&gt; and &lt;code&gt;add_bits&lt;/code&gt; in terms of &lt;code&gt;add&lt;/code&gt; , and of the methods &lt;code&gt;hexdigest&lt;/code&gt; and &lt;code&gt;b64digest&lt;/code&gt; in terms of &lt;code&gt;digest&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Digest::base&lt;/code&gt; クラスは、メソッドの実装を提供 &lt;code&gt;addfile&lt;/code&gt; と &lt;code&gt;add_bits&lt;/code&gt; をするという点で &lt;code&gt;add&lt;/code&gt; 、およびメソッドの &lt;code&gt;hexdigest&lt;/code&gt; と &lt;code&gt;b64digest&lt;/code&gt; の面で &lt;code&gt;digest&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="628d5f24b15638f2c6ff193717192cc425ae4155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DirHandle&lt;/code&gt; method provide an alternative interface to the opendir(), closedir(), readdir(), and rewinddir() functions.</source>
          <target state="translated">&lt;code&gt;DirHandle&lt;/code&gt; 方法はopendir関数（）、closedirの（）、READDIR（）、及びrewinddir（）関数の代替のインタフェースを提供します。</target>
        </trans-unit>
        <trans-unit id="358ca39e53232388840862f052183678f86697cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dump()&lt;/code&gt; function takes one or two arguments: something to dump, and an optional limit for recursion and array elements (default is 4). The first argument is evaluted in rvalue scalar context, with exceptions for @array and %hash, which dump the array or hash itself. So &lt;code&gt;Dump @array&lt;/code&gt; works, as does &lt;code&gt;Dump $foo&lt;/code&gt; . And &lt;code&gt;Dump &lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; will call &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; in rvalue context, whereas &lt;code&gt;Dump ${\&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;}&lt;/code&gt; will call it in lvalue context.</source>
          <target state="translated">&lt;code&gt;Dump()&lt;/code&gt; ダンプに何か、と再帰と配列の要素のためのオプションの制限（デフォルトは4です）：関数は、1つのまたは2つの引数を取ります。最初の引数は、配列またはハッシュ自体をダンプする@arrayおよび％hashを除いて、右辺値スカラーコンテキストで評価されます。したがって、 &lt;code&gt;Dump @array&lt;/code&gt; は &lt;code&gt;Dump $foo&lt;/code&gt; と同様に機能します。そして、 &lt;code&gt;Dump &lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 呼ぶ &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 一方、右辺値コンテキストで &lt;code&gt;Dump ${\&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;}&lt;/code&gt; 左辺値コンテキストでそれを呼び出します。</target>
        </trans-unit>
        <trans-unit id="cdbf79b7555598c068ba8d9743bee2fb95392923" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dump()&lt;/code&gt; function, by default, dumps up to 4 elements from a toplevel array or hash. This number can be increased by supplying a second argument to the function.</source>
          <target state="translated">&lt;code&gt;Dump()&lt;/code&gt; 関数は、デフォルトでは、トップレベルのアレイ又はハッシュからの4つの要素までダンプ。この数は、関数に2番目の引数を指定することで増やすことができます。</target>
        </trans-unit>
        <trans-unit id="c95778d99c76e8e03e061209f2b6b5768436be5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;END&lt;/code&gt; block isn't called when untrapped signals kill the program, though, so if you use &lt;code&gt;END&lt;/code&gt; blocks you should also use</source>
          <target state="translated">&lt;code&gt;END&lt;/code&gt; のトラップされない信号は、あなたが使用している場合ので、かかわらず、プログラムを殺したときにブロックが呼び出されない &lt;code&gt;END&lt;/code&gt; のブロックを使用すると、使用もすべき</target>
        </trans-unit>
        <trans-unit id="f434d74067f98a36c01cbe9c20f7d7cf7b02ed54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXPR&lt;/code&gt; following the modifier is referred to as the &quot;condition&quot;. Its truth or falsehood determines how the modifier will behave.</source>
          <target state="translated">&lt;code&gt;EXPR&lt;/code&gt; 修飾子以下は、「条件」と呼ばれています。その真偽によって、モディファイアの動作が決まります。</target>
        </trans-unit>
        <trans-unit id="0be035a23dc6f5f75a5bb7fdc10fe00056028240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encode&lt;/code&gt; module knows about many encodings and has interfaces for doing conversions between those encodings:</source>
          <target state="translated">&lt;code&gt;Encode&lt;/code&gt; モジュールは、多くのエンコーディングを知っていて、それらの符号化方式との間の変換を行うためのインタフェースを持っています：</target>
        </trans-unit>
        <trans-unit id="5cdf933f51543c5ce4713919bd68bbd3f797378f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encode&lt;/code&gt; module provides the interface between Perl strings and the rest of the system. Perl strings are sequences of</source>
          <target state="translated">&lt;code&gt;Encode&lt;/code&gt; モジュールは、Perl文字列とシステムの残りの部分との間のインタフェースを提供します。Perl文字列はシーケンスです</target>
        </trans-unit>
        <trans-unit id="4968644a1dddd78111692e0824f91d81d4b5fde6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Env::import()&lt;/code&gt; function ties environment variables with suitable names to global Perl variables with the same names. By default it ties all existing environment variables (&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %ENV&lt;/code&gt; ) to scalars. If the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function receives arguments, it takes them to be a list of variables to tie; it's okay if they don't yet exist. The scalar type prefix '$' is inferred for any element of this list not prefixed by '$' or '@'. Arrays are implemented in terms of &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;, using &lt;code&gt;$Config::Config{path_sep}&lt;/code&gt; as the delimiter.</source>
          <target state="translated">&lt;code&gt;Env::import()&lt;/code&gt; と同じ名前のグローバル変数はPerlに適した名前を持つ関数の絆の環境変数。デフォルトでは、既存のすべての環境変数（ &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %ENV&lt;/code&gt; ）をスカラーに関連付けます。 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 関数が引数を受け取った場合、それらは結合する変数のリストであると見なします。それらがまだ存在しなくても大丈夫です。スカラー型の接頭辞「$」は、「$」または「@」の接頭辞が付いていないこのリストの要素に対して推測されます。配列は、 &lt;code&gt;$Config::Config{path_sep}&lt;/code&gt; を区切り文字として使用して、 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; の観点から実装されます。</target>
        </trans-unit>
        <trans-unit id="04fe8159aef76b700007013f5b9be387367b2a84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraFieldLocal&lt;/code&gt; option is used to store additional metadata in the local header for the zip file/buffer. The &lt;code&gt;ExtraFieldCentral&lt;/code&gt; does the same for the matching central header.</source>
          <target state="translated">&lt;code&gt;ExtraFieldLocal&lt;/code&gt; オプションは、zipファイル/バッファのローカルヘッダに追加のメタデータを格納するために使用されます。 &lt;code&gt;ExtraFieldCentral&lt;/code&gt; は一致中央ヘッダの同じこと。</target>
        </trans-unit>
        <trans-unit id="7dceaf4fc99f40b45472fc6396adb3cf093b19ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FREETMPS&lt;/code&gt; /&lt;code&gt;LEAVE&lt;/code&gt; pair will get rid of any values returned by the Perl subroutine (see next example), plus it will also dump the mortal SVs we have created. Having &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;SAVETMPS&lt;/code&gt; at the beginning of the code makes sure that no other mortals are destroyed.</source>
          <target state="translated">&lt;code&gt;FREETMPS&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; のペアはPerlサブルーチン（次の例を参照）によって返された値を取り除くだろう、プラスそれはまた、我々が作成した死を免れなSVをダンプします。持っ &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;SAVETMPS&lt;/code&gt; のコードの先頭にしても、他の人間が破壊されていないことを確認します。</target>
        </trans-unit>
        <trans-unit id="e1e824605b84cee8c0b954423f3ab5ef2eb2758b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN&lt;/code&gt; /&lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; keywords can be mixed with ANSI-style declarations, as in</source>
          <target state="translated">&lt;code&gt;IN&lt;/code&gt; / &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; のキーワードはのように、ANSI-スタイル宣言と混合することができます</target>
        </trans-unit>
        <trans-unit id="2291d3950c0f7a1274711a429d0d47b0e9604c3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; sections have identical formats, that is, each unindented line starts a new in- or output map respectively. A new in- or output map must start with the name of the XS type to map on a line by itself, followed by the code that implements it indented on the following lines. Example:</source>
          <target state="translated">&lt;code&gt;INPUT&lt;/code&gt; と &lt;code&gt;OUTPUT&lt;/code&gt; セクションであることを、同じフォーマットを有する、それぞれ、インデントラインは、それぞれの新しいインまたは出力マップを開始します。新しい入力マップまたは出力マップは、1行でマップするXSタイプの名前で始まり、その後に、それをインプリメントするコードが続く行でインデントされている必要があります。例：</target>
        </trans-unit>
        <trans-unit id="0839ebfa51c8f90f143d226a6a7f33a7ff311878" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INT2PTR&lt;/code&gt; macro (defined in perl.h) casts an integer to a pointer of a given type, taking care of the possible different size of integers and pointers. There are also &lt;code&gt;PTR2IV&lt;/code&gt; , &lt;code&gt;PTR2UV&lt;/code&gt; , &lt;code&gt;PTR2NV&lt;/code&gt; macros, to map the other way, which may be useful in OUTPUT sections.</source>
          <target state="translated">&lt;code&gt;INT2PTR&lt;/code&gt; の（perl.hで定義された）マクロは整数とポインタの可能な異なるサイズの世話をして、指定されたタイプのポインタに整数をキャスト。 &lt;code&gt;PTR2IV&lt;/code&gt; 、 &lt;code&gt;PTR2UV&lt;/code&gt; 、 &lt;code&gt;PTR2NV&lt;/code&gt; マクロもあり、他の方法でマップするため、OUTPUTセクションで役立ちます。</target>
        </trans-unit>
        <trans-unit id="61f85903ef5f9040c0ff99931c044e8d15426a65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN_OUT&lt;/code&gt; parameters are identical with parameters introduced with &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The &amp;amp; Unary Operator&lt;/a&gt; and put into the &lt;code&gt;OUTPUT:&lt;/code&gt; section (see &lt;a href=&quot;#The-OUTPUT%3a-Keyword&quot;&gt;The OUTPUT: Keyword&lt;/a&gt;). The &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters are very similar, the only difference being that the value C function writes through the pointer would not modify the Perl parameter, but is put in the output list.</source>
          <target state="translated">&lt;code&gt;IN_OUT&lt;/code&gt; のパラメータはで導入パラメータと同一である&lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;と単項演算子&lt;/a&gt;とに入れ &lt;code&gt;OUTPUT:&lt;/code&gt; セクション（参照&lt;a href=&quot;#The-OUTPUT%3a-Keyword&quot;&gt;OUTPUT：キーワード&lt;/a&gt;）。 &lt;code&gt;IN_OUTLIST&lt;/code&gt; のパラメータは、ポインタによる値C関数書き込みはPerlのパラメータを変更していないだろうが、出力リストに入れていることを唯一の違いは非常に似ています。</target>
        </trans-unit>
        <trans-unit id="e01d4a34408ea1bec61899bb0715159c8fcfc543" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO::Dir&lt;/code&gt; package provides two interfaces to perl's directory reading routines.</source>
          <target state="translated">&lt;code&gt;IO::Dir&lt;/code&gt; パッケージは、perlのディレクトリの読み取りルーチンには、2つのインタフェースを提供します。</target>
        </trans-unit>
        <trans-unit id="2e8c3db24464dee992cbd4fb5389ee4e7af6c03b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO::Select&lt;/code&gt; package implements an object approach to the system &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function call. It allows the user to see what IO handles, see &lt;a href=&quot;handle&quot;&gt;IO::Handle&lt;/a&gt;, are ready for reading, writing or have an exception pending.</source>
          <target state="translated">&lt;code&gt;IO::Select&lt;/code&gt; たパッケージには、システムへのオブジェクトのアプローチを実装 &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 関数呼び出しを。これにより、ユーザーはどのIOハンドルを参照するか、&lt;a href=&quot;handle&quot;&gt;IO :: Handle&lt;/a&gt;を参照するか、読み取り、書き込みの準備ができているか、または例外を保留することができます。</target>
        </trans-unit>
        <trans-unit id="93e9868cf44653a0a473010fe2cd91001e0a676d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Interpolation&lt;/code&gt; module can also do a lot of magic for you. You can specify a variable name, in this case &lt;code&gt;E&lt;/code&gt; , to set up a tied hash that does the interpolation for you. It has several other methods to do this as well.</source>
          <target state="translated">&lt;code&gt;Interpolation&lt;/code&gt; モジュールはまたあなたのための魔法の多くを行うことができます。変数名（この場合は &lt;code&gt;E&lt;/code&gt; ）を指定して、補間を実行する結合ハッシュを設定できます。これを行うには、他にもいくつかの方法があります。</target>
        </trans-unit>
        <trans-unit id="d3bc590cafc9b13c0e888463643b3750cf44fd73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_CTYPE&lt;/code&gt; locale also provides the map used in transliterating characters between lower and uppercase. This affects the case-mapping functions--&lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt;; case-mapping interpolation with &lt;code&gt;\F&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , or &lt;code&gt;\U&lt;/code&gt; in double-quoted strings and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; substitutions; and case-independent regular expression pattern matching using the &lt;code&gt;i&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; のロケールも低いと大文字の間の文字を翻字に使用されるマップを提供します。これは、大文字と小文字をマッピングする関数 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt; に影響します。二重引用符で囲まれた文字列と &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 置換での &lt;code&gt;\F&lt;/code&gt; 、 &lt;code&gt;\l&lt;/code&gt; 、 &lt;code&gt;\L&lt;/code&gt; 、 &lt;code&gt;\u&lt;/code&gt; 、または &lt;code&gt;\U&lt;/code&gt; した大文字小文字マッピングの補間。また、 &lt;code&gt;i&lt;/code&gt; 修飾子を使用した大文字と小文字を区別しない正規表現パターンマッチング。</target>
        </trans-unit>
        <trans-unit id="941219cd505be61ac26ba8728d69370c60e37046" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_NUMERIC&lt;/code&gt; controls the numeric output:</source>
          <target state="translated">&lt;code&gt;LC_NUMERIC&lt;/code&gt; は、数値出力を制御します。</target>
        </trans-unit>
        <trans-unit id="412121500ef04a2233556ed3ed8bb5c784494003" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option changes the behavior of the &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; method so that the amount of memory used by the output buffer can be limited.</source>
          <target state="translated">&lt;code&gt;LimitOutput&lt;/code&gt; のオプションは、振舞いの変更 &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; 出力バッファが使用するメモリの量を制限することができるようにする方法を。</target>
        </trans-unit>
        <trans-unit id="1b18a1d213993f63112fefb5d5804b6552cbf33b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option changes the behavior of the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method so that the amount of memory used by the output buffer can be limited.</source>
          <target state="translated">&lt;code&gt;LimitOutput&lt;/code&gt; のオプションは、振舞いの変更 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 出力バッファが使用するメモリの量を制限することができるようにする方法を。</target>
        </trans-unit>
        <trans-unit id="3600b0d3775b442853dade84e908851ee6d60512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option is designed to help with this use-case.</source>
          <target state="translated">&lt;code&gt;LimitOutput&lt;/code&gt; のオプションは、このユースケースを支援するために設計されています。</target>
        </trans-unit>
        <trans-unit id="4e39cafde8d7c8f339d79044ffb14c41f2b59abf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Listen&lt;/code&gt; parameter is set to the maximum number of pending connections we can accept until we turn away incoming clients. Think of it as a call-waiting queue for your telephone. The low-level Socket module has a special symbol for the system maximum, which is SOMAXCONN.</source>
          <target state="translated">&lt;code&gt;Listen&lt;/code&gt; パラメータは、私たちは離れて、着信クライアントをオンにするまで、我々は受け入れることができ保留中の接続の最大数に設定されています。それはあなたの電話のためのキャッチホンのキューと考えてください。低レベルのソケットモジュールには、システムの最大値を表す特別な記号（SOMAXCONN）があります。</target>
        </trans-unit>
        <trans-unit id="39d8f8a92949aebb617dd074e69f347a559dd1fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Country&lt;/code&gt; module provides access to several code sets that can be used for identifying countries, such as those defined in ISO 3166-1.</source>
          <target state="translated">&lt;code&gt;Locale::Country&lt;/code&gt; モジュールは、ISO 3166-1に定義されたもののような国を識別するために使用することができるいくつかのコード・セットへのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="7ce570b70dc3b1217c7829eb357747faae317306" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Currency&lt;/code&gt; module provides access to standard codes used for identifying currencies and funds, such as those defined in ISO 4217.</source>
          <target state="translated">&lt;code&gt;Locale::Currency&lt;/code&gt; モジュールは、ISO 4217で定義されたもののような通貨と資金を識別するために使用される標準コードへのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="e1ffcce2675347ee9e15ffb62b7a866fc9499f7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Language&lt;/code&gt; module provides access to standard codes used for identifying languages, such as those as defined in ISO 639.</source>
          <target state="translated">&lt;code&gt;Locale::Language&lt;/code&gt; モジュールは、ISO 639で定義されたようなもののような言語を識別するために使用される標準コードへのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="aa76c519ff8997e91915d966da6aed9450ba1a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Script&lt;/code&gt; module provides access to standards codes used for identifying scripts, such as those defined in ISO 15924.</source>
          <target state="translated">&lt;code&gt;Locale::Script&lt;/code&gt; モジュールは、ISO 15924で定義されているようなスクリプトを、識別するために使用される標準コードへのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="e8120d017d19784f5ec18621659dfbf762367c0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MGVTBL&lt;/code&gt; has five (or sometimes eight) pointers to the following routine types:</source>
          <target state="translated">&lt;code&gt;MGVTBL&lt;/code&gt; は、以下のルーチンのタイプに5（時には8）のポインタがあります。</target>
        </trans-unit>
        <trans-unit id="62960d717ea2191ee6cb352f5b362492a57f4b7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Math::Trig&lt;/code&gt; handles this by using the &lt;code&gt;Math::Complex&lt;/code&gt; package which knows how to handle complex numbers, please see &lt;a href=&quot;complex&quot;&gt;Math::Complex&lt;/a&gt; for more information. In practice you need not to worry about getting complex numbers as results because the &lt;code&gt;Math::Complex&lt;/code&gt; takes care of details like for example how to display complex numbers. For example:</source>
          <target state="translated">&lt;code&gt;Math::Trig&lt;/code&gt; 使用してこれを扱う &lt;code&gt;Math::Complex&lt;/code&gt; 複素数を扱う方法を知っているパッケージを参照してください&lt;a href=&quot;complex&quot;&gt;数学::複雑な&lt;/a&gt;詳細については。 &lt;code&gt;Math::Complex&lt;/code&gt; が複素数の表示方法などの詳細を処理するため、実際には結果として複素数を取得することについて心配する必要はありません。例えば：</target>
        </trans-unit>
        <trans-unit id="59d3e5116a50776a62b5e7307aca3591f0689480" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Moose&lt;/code&gt; authors hope that one day &lt;code&gt;Moo&lt;/code&gt; can be made obsolete by improving &lt;code&gt;Moose&lt;/code&gt; enough, but for now it provides a worthwhile alternative to &lt;code&gt;Moose&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Moose&lt;/code&gt; 著者は、1日のことを願ってい &lt;code&gt;Moo&lt;/code&gt; 改善することにより、時代遅れ行うことができ &lt;code&gt;Moose&lt;/code&gt; 十分な、しかし今のところは、に価値のある選択肢を提供 &lt;code&gt;Moose&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cda22c66d7ae69cf0c1a687755ef0ea97e644b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NNTP&lt;/code&gt; protocol uses the &lt;code&gt;WILDMAT&lt;/code&gt; format for patterns. The WILDMAT format was first developed by Rich Salz based on the format used in the UNIX &quot;find&quot; command to articulate file names. It was developed to provide a uniform mechanism for matching patterns in the same manner that the UNIX shell matches filenames.</source>
          <target state="translated">&lt;code&gt;NNTP&lt;/code&gt; のプロトコルを使用し &lt;code&gt;WILDMAT&lt;/code&gt; のパターンの形式を。 WILDMAT形式は、ファイル名を明確にするためにUNIXの「find」コマンドで使用される形式に基づいて、Rich Salzによって最初に開発されました。これは、UNIXシェルがファイル名を照合するのと同じ方法でパターンを照合するための統一されたメカニズムを提供するために開発されました。</target>
        </trans-unit>
        <trans-unit id="812543816e7e36906e0a41744e1b881bd6061a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;O::import&lt;/code&gt; function loads the appropriate &lt;code&gt;B::Backend&lt;/code&gt; module and calls its &lt;code&gt;compile&lt;/code&gt; function, passing it OPTIONS. That function is expected to return a sub reference which we'll call CALLBACK. Next, the &quot;compile-only&quot; flag is switched on (equivalent to the command-line option &lt;code&gt;-c&lt;/code&gt; ) and a CHECK block is registered which calls CALLBACK. Thus the main Perl program mentioned on the command-line is read in, parsed and compiled into internal syntax tree form. Since the &lt;code&gt;-c&lt;/code&gt; flag is set, the program does not start running (excepting BEGIN blocks of course) but the CALLBACK function registered by the compiler backend is called.</source>
          <target state="translated">&lt;code&gt;O::import&lt;/code&gt; 機能ロード適切 &lt;code&gt;B::Backend&lt;/code&gt; モジュールとその呼び出し &lt;code&gt;compile&lt;/code&gt; それにオプションを渡し、関数。この関数は、CALLBACKと呼ぶサブ参照を返すことが期待されています。次に、「コンパイルのみ」フラグがオンになり（コマンドラインオプション &lt;code&gt;-c&lt;/code&gt; と同等）、CALLBACKを呼び出すCHECKブロックが登録されます。したがって、コマンドラインで言及されているメインのPerlプログラムが読み込まれ、解析され、内部構文ツリー形式にコンパイルされます。以来 &lt;code&gt;-c&lt;/code&gt; フラグがセットされ、プログラムは（当然のブロックをBEGIN除く）に実行を開始しませんが、コンパイラのバックエンドで登録したコールバック関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="3d373b71890ff94863d227c7cfce5d1d697b7746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OP *&lt;/code&gt; is op_free()ed at the end of</source>
          <target state="translated">&lt;code&gt;OP *&lt;/code&gt; の最後にあるop_free（）編</target>
        </trans-unit>
        <trans-unit id="998cf5d3020bb78a9ba1d3cad328d90e354a7767" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; parameter differ from &lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; parameters only by the initial value of the Perl parameter not being read (and not being given to the C function - which gets some garbage instead). For example, the same C function as above can be interfaced with as</source>
          <target state="translated">&lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; 異なるパラメータ &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; の唯一ではないが読み取られるPerlのパラメータの初期値でパラメータが（ -いくつかのごみ代わりを取得し、C関数に与えられていません）。たとえば、上記と同じC関数をasとインターフェイスできます。</target>
        </trans-unit>
        <trans-unit id="0628c399d26c3378a27108a14e1ac2344b8aefb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Open()&lt;/code&gt; method has lots of arguments because it combines the functions of perl's &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;PerlIO_open&lt;/code&gt; , perl's &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;PerlIO_fdopen&lt;/code&gt; and &lt;code&gt;PerlIO_reopen&lt;/code&gt; . The full prototype is as follows:</source>
          <target state="translated">&lt;code&gt;Open()&lt;/code&gt; 、それはPerlのの機能を兼ね備えているための方法は、引数がたくさんある &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;PerlIO_open&lt;/code&gt; 、perlの &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; で、 &lt;code&gt;PerlIO_fdopen&lt;/code&gt; と &lt;code&gt;PerlIO_reopen&lt;/code&gt; を。完全なプロトタイプは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9b50db457121e66e0a351ce78b3a957dc8ab0fb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL5DB&lt;/code&gt; environment variable can be used to define a debugger. For example, the minimal &quot;working&quot; debugger (it actually doesn't do anything) consists of one line:</source>
          <target state="translated">&lt;code&gt;PERL5DB&lt;/code&gt; の環境変数は、デバッガを定義するために使用することができます。たとえば、最小限の「動作している」デバッガー（実際には何もしない）は、1行で構成されています。</target>
        </trans-unit>
        <trans-unit id="d2bc99a442d5c0b29501891792cdc1fff80da05a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; and &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic types are defined specifically for use by extensions and will not be used by perl itself. Extensions can use &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic to 'attach' private information to variables (typically objects). This is especially useful because there is no way for normal perl code to corrupt this private information (unlike using extra elements of a hash object).</source>
          <target state="translated">&lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; と &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 魔法の種類は拡張子で使用するために特別に定義されており、Perl自身によって使用されることはありません。拡張機能は &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; マジックを使用して、プライベート情報を変数（通常はオブジェクト）に「アタッチ」できます。通常のperlコードがこのプライベート情報を破壊する方法はないため（ハッシュオブジェクトの追加の要素を使用する場合とは異なり）、これは特に便利です。</target>
        </trans-unit>
        <trans-unit id="8a6e94721b04748465ec2688a94fd6f249730156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; interface for hashes</source>
          <target state="translated">ハッシュ用の &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; インターフェース</target>
        </trans-unit>
        <trans-unit id="ebc956792cc9e74cf6710a9899c98dc65f9e9723" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POPi&lt;/code&gt; macro is used here to pop the return value from the stack. In this case we wanted an integer, so &lt;code&gt;POPi&lt;/code&gt; was used.</source>
          <target state="translated">ここでは、 &lt;code&gt;POPi&lt;/code&gt; マクロを使用して、スタックから戻り値をポップします。この場合は整数が必要なので、 &lt;code&gt;POPi&lt;/code&gt; を使用しました。</target>
        </trans-unit>
        <trans-unit id="441004a0b6f6f50d94cdd26e8efdb4418e11d7d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POSIX::getattr&lt;/code&gt; function can do this more portably on systems purporting POSIX compliance. See also the &lt;code&gt;Term::ReadKey&lt;/code&gt; module from your nearest &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org&quot;&gt;CPAN&lt;/a&gt; site.</source>
          <target state="translated">&lt;code&gt;POSIX::getattr&lt;/code&gt; 機能は、POSIX準拠を主張するシステムでより多くの移植性これを行うことができます。最寄りの&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org&quot;&gt;CPAN&lt;/a&gt;サイトの &lt;code&gt;Term::ReadKey&lt;/code&gt; モジュールも参照してください。</target>
        </trans-unit>
        <trans-unit id="30a4c7c0312ad4ebafbfc4ecde82010a30e5b1d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POSIX::localeconv()&lt;/code&gt; function allows you to get particulars of the locale-dependent numeric formatting information specified by the current underlying &lt;code&gt;LC_NUMERIC&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt; locales (regardless of whether called from within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; or not). (If you just want the name of the current locale for a particular category, use &lt;code&gt;POSIX::setlocale()&lt;/code&gt; with a single parameter--see &lt;a href=&quot;#The-setlocale-function&quot;&gt;The setlocale function&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;POSIX::localeconv()&lt;/code&gt; 関数は、現在の基本となることにより、指定されたロケール依存の数値書式設定情報の詳細を取得することができます &lt;code&gt;LC_NUMERIC&lt;/code&gt; と &lt;code&gt;LC_MONETARY&lt;/code&gt; （関わらずの範囲内から呼び出さかどうかのロケールを &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; またはしません）。（特定のカテゴリの現在のロケールの名前だけが必要な場合は、 &lt;code&gt;POSIX::setlocale()&lt;/code&gt; を1つのパラメータで&lt;a href=&quot;#The-setlocale-function&quot;&gt;使用します。setlocale関数を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="1f685f77eea7b515d4045c7a67182dbbc7755a25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUSHMARK&lt;/code&gt; macro tells Perl to make a mental note of the current stack pointer. Even if you aren't passing any parameters (like the example shown in the section</source>
          <target state="translated">&lt;code&gt;PUSHMARK&lt;/code&gt; のマクロは、現在のスタックポインタの精神的なメモを作るためにPerlを伝えます。パラメータを渡していない場合でも（セクションで示した例のように</target>
        </trans-unit>
        <trans-unit id="07465ad7c738ebeee81550400552ecd67a850bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUTBACK&lt;/code&gt; macro sets the global copy of the stack pointer to be the same as our local copy. If we didn't do this,</source>
          <target state="translated">&lt;code&gt;PUTBACK&lt;/code&gt; のマクロは、スタックポインタのグローバルコピーは、私たちのローカルコピーと同じになるように設定します。これを行わなかった場合、</target>
        </trans-unit>
        <trans-unit id="8baae86fdb4cb4e701226e31c2071774be7ff5cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PeerAddr&lt;/code&gt; can be a hostname or the IP-address on the &quot;xx.xx.xx.xx&quot; form. The &lt;code&gt;PeerPort&lt;/code&gt; can be a number or a symbolic service name. The service name might be followed by a number in parenthesis which is used if the service is not known by the system. The &lt;code&gt;PeerPort&lt;/code&gt; specification can also be embedded in the &lt;code&gt;PeerAddr&lt;/code&gt; by preceding it with a &quot;:&quot;.</source>
          <target state="translated">&lt;code&gt;PeerAddr&lt;/code&gt; は「XX.XX.XX.XX」フォーム上のホスト名またはIPアドレスをすることができます。 &lt;code&gt;PeerPort&lt;/code&gt; は番号またはシンボリックサービス名を指定できます。サービス名の後に括弧で囲まれた数字が続く場合があります。これは、サービスがシステムに認識されていない場合に使用されます。 &lt;code&gt;PeerPort&lt;/code&gt; の仕様も埋め込むことができる &lt;code&gt;PeerAddr&lt;/code&gt; 「：」とそれに先行することによって。</target>
        </trans-unit>
        <trans-unit id="354584d7434f3b3042f7e803f86eee0735ecb30f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PerlInterpreter*&lt;/code&gt; is being constructed via &lt;code&gt;perl_construct&lt;/code&gt; . This value is mostly there for completeness and for use via the underlying C variable &lt;code&gt;PL_phase&lt;/code&gt; . It's not really possible for Perl code to be executed unless construction of the interpreter is finished.</source>
          <target state="translated">&lt;code&gt;PerlInterpreter*&lt;/code&gt; 経由して構築されて &lt;code&gt;perl_construct&lt;/code&gt; 。この値は、完全性のために、および基礎となるC変数 &lt;code&gt;PL_phase&lt;/code&gt; を介して使用するために、ほとんど存在します。インタプリタの構築が終了しない限り、Perlコードを実行することは実際には不可能です。</target>
        </trans-unit>
        <trans-unit id="619b9e421badf230488baf0eee0a8b4f64f3d92d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REGlob&lt;/code&gt; example above does not implement all the support needed to cleanly override perl's &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator. The built-in &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; has different behaviors depending on whether it appears in a scalar or list context, but our &lt;code&gt;REGlob&lt;/code&gt; doesn't. Indeed, many perl built-in have such context sensitive behaviors, and these must be adequately supported by a properly written override. For a fully functional example of overriding &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, study the implementation of &lt;code&gt;File::DosGlob&lt;/code&gt; in the standard library.</source>
          <target state="translated">上記の &lt;code&gt;REGlob&lt;/code&gt; の例は、perlの &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 演算子を完全にオーバーライドするために必要なすべてのサポートを実装しているわけではありません。組み込み &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; は、スカラーコンテキストとリストコンテキストのどちらで表示されるかによって動作が異なりますが、 &lt;code&gt;REGlob&lt;/code&gt; では表示されません。実際、多くのperl組み込みにはそのような状況依存の動作があり、これらは適切に記述されたオーバーライドによって適切にサポートされる必要があります。 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; のオーバーライドの完全に機能する例については、標準ライブラリの &lt;code&gt;File::DosGlob&lt;/code&gt; 実装を調べてください。</target>
        </trans-unit>
        <trans-unit id="541482224c51c4cb7a6cd08e437f820560b203ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Return&lt;/code&gt; and &lt;code&gt;Envelope&lt;/code&gt; parameters are used for DSN (Delivery Status Notification).</source>
          <target state="translated">&lt;code&gt;Return&lt;/code&gt; と &lt;code&gt;Envelope&lt;/code&gt; のパラメータは、DSN（配信ステータス通知）のために使用されています。</target>
        </trans-unit>
        <trans-unit id="0fb74752f70cdbcc4b24e6fe1a79d1c71cc57bd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reuse&lt;/code&gt; parameter is needed so that we restart our server manually without waiting a few minutes to allow system buffers to clear out.</source>
          <target state="translated">システムバッファーがクリアされるまで数分待たずにサーバーを手動で再起動するには、 &lt;code&gt;Reuse&lt;/code&gt; パラメーターが必要です。</target>
        </trans-unit>
        <trans-unit id="6ef497f2f64147d9fc11b64ad7836f6a54270b55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIGALRM&lt;/code&gt; signal is sent after the specified number of seconds. Implemented using &lt;code&gt;setitimer()&lt;/code&gt; if available, &lt;code&gt;ualarm()&lt;/code&gt; if not. The &lt;code&gt;$interval_floating_seconds&lt;/code&gt; argument is optional and will be zero if unspecified, resulting in &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt;-like behaviour. This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;SIGALRM&lt;/code&gt; の信号が指定した秒数後に送信されます。使用して実装 &lt;code&gt;setitimer()&lt;/code&gt; 利用可能な場合、 &lt;code&gt;ualarm()&lt;/code&gt; ではない場合が。 &lt;code&gt;$interval_floating_seconds&lt;/code&gt; 引数はオプションで、指定されていない場合、その結果はゼロになり &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; 様の挙動。この関数はインポート可能であり、perlで提供される &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 優れた代替品になります。以下の&lt;a href=&quot;#EXAMPLES&quot;&gt;例を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="bcb26b9a2abefa95e1228823d5039552d2541e20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER::&lt;/code&gt; bit tells Perl to look for the &lt;code&gt;print_info()&lt;/code&gt; in the &lt;code&gt;File::MP3&lt;/code&gt; class's inheritance chain. When it finds the parent class that implements this method, the method is called.</source>
          <target state="translated">&lt;code&gt;SUPER::&lt;/code&gt; ビットを探すためにPerlを伝え &lt;code&gt;print_info()&lt;/code&gt; で &lt;code&gt;File::MP3&lt;/code&gt; クラスの継承チェーン。このメソッドを実装する親クラスが見つかると、メソッドが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="3f5b4cff6fbfe1c281604ef06c021cd92e1eaa6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER&lt;/code&gt; modifier can</source>
          <target state="translated">&lt;code&gt;SUPER&lt;/code&gt; 修飾子缶</target>
        </trans-unit>
        <trans-unit id="371b5ebfc9cdf0db9a0a55eae240989e954cb726" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER&lt;/code&gt; pseudo-class is resolved from the package where the call is made. It is</source>
          <target state="translated">&lt;code&gt;SUPER&lt;/code&gt; の疑似クラスは、呼び出しが行われているパッケージから解決されます。です</target>
        </trans-unit>
        <trans-unit id="ce9315ac1b0e03b32c4d0f032e1290883c21a935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Script&lt;/code&gt; or &lt;code&gt;Script_Extensions&lt;/code&gt; properties are likely to be the ones you want to use when processing natural language; the &lt;code&gt;Block&lt;/code&gt; property may occasionally be useful in working with the nuts and bolts of Unicode.</source>
          <target state="translated">&lt;code&gt;Script&lt;/code&gt; または &lt;code&gt;Script_Extensions&lt;/code&gt; プロパティは、自然言語を処理するときに使用するものである可能性が高いです。 &lt;code&gt;Block&lt;/code&gt; プロパティは時折ユニコードのナットとボルトでの作業に有用であり得ます。</target>
        </trans-unit>
        <trans-unit id="0daac5f890ff04f28fabf32094505977d698c4f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Storable::last_op_in_netorder()&lt;/code&gt; predicate will tell you whether network order was used in the last store or retrieve operation. If you don't know how to use this, just forget about it.</source>
          <target state="translated">&lt;code&gt;Storable::last_op_in_netorder()&lt;/code&gt; 述語は、ネットワーク順序が最後の店で使用されたかどうかを教えてくれたり、操作を取得します。これの使い方がわからない場合は、忘れてください。</target>
        </trans-unit>
        <trans-unit id="4f2453d7aa3fb23473e60b4a26a3d26672cf6341" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TODO:&lt;/code&gt; and &lt;code&gt;$TODO&lt;/code&gt; syntax is generally pretty good about figuring out whether or not we're in a TODO test. However, often we find that this is not possible to determine (such as when we want to use &lt;code&gt;$TODO&lt;/code&gt; but the tests are being executed in other packages which can't be inferred beforehand).</source>
          <target state="translated">&lt;code&gt;TODO:&lt;/code&gt; と &lt;code&gt;$TODO&lt;/code&gt; 構文は、一般的に、我々はTODOテストにいるかどうかを考え出すについてかなり良いです。ただし、これを判断できない場合がよくあります（ &lt;code&gt;$TODO&lt;/code&gt; を使用したいが、事前に推測できない他のパッケージでテストが実行されている場合など）。</target>
        </trans-unit>
        <trans-unit id="ca16843b685fa84c8313aca285e376c5597ef322" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TYPEMAP&lt;/code&gt; section should contain one pair of C type and XS type per line as follows. An example from the core typemap file:</source>
          <target state="translated">&lt;code&gt;TYPEMAP&lt;/code&gt; のセクションでは、C型と次のようにライン当たりXS型の一対を含むべきです。コアタイプマップファイルの例：</target>
        </trans-unit>
        <trans-unit id="ea8183d7125676dfc1989dcabf04b34c38b4f669" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; function returns a thread object that represents the thread making the &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; call.</source>
          <target state="translated">&lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; 機能は製造スレッド表すスレッドオブジェクト戻り &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; 呼び出しを。</target>
        </trans-unit>
        <trans-unit id="5f72cf2b372d3d426c2948d6098fd6cd1afad651" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; module provides multithreading support for Perl.</source>
          <target state="translated">&lt;code&gt;Thread&lt;/code&gt; モジュールはPerl用のマルチスレッドサポートを提供します。</target>
        </trans-unit>
        <trans-unit id="7fe8315550458ad4289f70c4a27bed2792ae2d78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; module served as the frontend to the old-style thread model, called</source>
          <target state="translated">&lt;code&gt;Thread&lt;/code&gt; と呼ばれる古いスタイルのスレッドモデルへのフロントエンドを務めモジュール、</target>
        </trans-unit>
        <trans-unit id="ab5cb47a9617fcafbcf6221a375828cf9de09e24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Time::HiRes&lt;/code&gt; module implements a Perl interface to the &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;nanosleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , and &lt;code&gt;setitimer&lt;/code&gt; /&lt;code&gt;getitimer&lt;/code&gt; system calls, in other words, high resolution time and timers. See the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; section below and the test scripts for usage; see your system documentation for the description of the underlying &lt;code&gt;nanosleep&lt;/code&gt; or &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , and &lt;code&gt;setitimer&lt;/code&gt; /&lt;code&gt;getitimer&lt;/code&gt; calls.</source>
          <target state="translated">&lt;code&gt;Time::HiRes&lt;/code&gt; モジュール実装A Perlインタフェースに &lt;code&gt;usleep&lt;/code&gt; 、 &lt;code&gt;nanosleep&lt;/code&gt; 、 &lt;code&gt;ualarm&lt;/code&gt; 関数、 &lt;code&gt;gettimeofday&lt;/code&gt; 、そして &lt;code&gt;setitimer&lt;/code&gt; が / &lt;code&gt;getitimer&lt;/code&gt; システムコール、換言すれば、高解像度時間とタイマー。使用&lt;a href=&quot;#EXAMPLES&quot;&gt;例&lt;/a&gt;については、以下の「例」セクションとテストスクリプトを参照してください。基礎となる &lt;code&gt;nanosleep&lt;/code&gt; または &lt;code&gt;usleep&lt;/code&gt; 、 &lt;code&gt;ualarm&lt;/code&gt; 、 &lt;code&gt;gettimeofday&lt;/code&gt; 、および &lt;code&gt;setitimer&lt;/code&gt; / &lt;code&gt;getitimer&lt;/code&gt; 呼び出しの説明については、システムのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="adde2e15da0476d4564064bbc384c4ca957b8d40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VERSION&lt;/code&gt; method returns the version number of the class (package).</source>
          <target state="translated">&lt;code&gt;VERSION&lt;/code&gt; の方法は、クラス（パッケージ）のバージョン番号を返します。</target>
        </trans-unit>
        <trans-unit id="d8baa2e2f7c0fd0a2f0c9455f11a42eb910290cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Win32::*&lt;/code&gt; modules in &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Win32::*&lt;/code&gt; のモジュール&lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;のWin32&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6c47ba9b1855f9e0e157ed96c1dac4112ef8de3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; sequence is supposed to be empty.</source>
          <target state="translated">&lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; シーケンスが空になっています。</target>
        </trans-unit>
        <trans-unit id="f3c164b87544e368a57522144bf31b4093cb008b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;i&gt;digit&lt;/i&gt;&lt;/code&gt; notation also works in certain circumstances outside the pattern. See &lt;a href=&quot;#Warning-on-%5c1-Instead-of-%241&quot;&gt;Warning on \1 Instead of $1&lt;/a&gt; below for details.</source>
          <target state="translated">&lt;code&gt;\&lt;i&gt;digit&lt;/i&gt;&lt;/code&gt; 表記は、パターン外の特定の状況で動作します。詳細については、以下&lt;a href=&quot;#Warning-on-%5c1-Instead-of-%241&quot;&gt;の$ 1ではなく\ 1に関する警告を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c49d42a1bfbc0b22f583d2817d2ce107934b83b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\C&lt;/code&gt; is unsupported in lookbehind, because the already treacherous definition of &lt;code&gt;\C&lt;/code&gt; would become even more so when going backwards.</source>
          <target state="translated">&lt;code&gt;\C&lt;/code&gt; のすでに危険な定義ので、後読みでサポートされていません &lt;code&gt;\C&lt;/code&gt; 後方に行くときなおさらなります。</target>
        </trans-unit>
        <trans-unit id="b97997ed1726a2dd70e1e88046ee54105827a12b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\G&lt;/code&gt; assertion can be used to chain global matches (using &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt;), as described in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;. It is also useful when writing &lt;code&gt;lex&lt;/code&gt; -like scanners, when you have several patterns that you want to match against consequent substrings of your string; see the previous reference. The actual location where &lt;code&gt;\G&lt;/code&gt; will match can also be influenced by using &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; as an lvalue: see &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;. Note that the rule for zero-length matches (see &lt;a href=&quot;#Repeated-Patterns-Matching-a-Zero-length-Substring&quot;&gt;Repeated Patterns Matching a Zero-length Substring&lt;/a&gt;) is modified somewhat, in that contents to the left of &lt;code&gt;\G&lt;/code&gt; are not counted when determining the length of the match. Thus the following will not match forever:</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; アサーションは、チェーングローバルマッチ（使用するために使用することができる &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; で説明したように、）&lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;はperlopで正規表現引用様演算子&lt;/a&gt;。文字列の後続の部分文字列と照合する複数のパターンがある場合に、 &lt;code&gt;lex&lt;/code&gt; のようなスキャナーを作成するときにも役立ちます。前のリファレンスを参照してください。実際の場所 &lt;code&gt;\G&lt;/code&gt; 一致するにも使用することによって影響され得る &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 参照：左辺値として&lt;a href=&quot;functions/pos&quot;&gt;POSを&lt;/a&gt;。長さがゼロの一致のルール（長さ&lt;a href=&quot;#Repeated-Patterns-Matching-a-Zero-length-Substring&quot;&gt;がゼロの部分文字列と一致する繰り返しパターンを&lt;/a&gt;参照）は、 &lt;code&gt;\G&lt;/code&gt; 左側の内容が多少変更されていることに注意してください。一致の長さを決定するときにカウントされません。したがって、次のものは永久には一致しません。</target>
        </trans-unit>
        <trans-unit id="9300fc0425608314652e19b5173bc5fd7efd18c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\N&lt;/code&gt; character class, not to be confused with the named character sequence &lt;code&gt;\N{NAME}&lt;/code&gt; , denotes any non-newline character in a regular expression.</source>
          <target state="translated">&lt;code&gt;\N&lt;/code&gt; 名前の文字列と混同しない文字クラス、 &lt;code&gt;\N{NAME}&lt;/code&gt; 、正規表現で任意の非改行文字を表します。</target>
        </trans-unit>
        <trans-unit id="6fc55e5a124a8f9ba1fb9b74d5a25063c2e050b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\N{...}&lt;/code&gt; construct explicitly refers to a Unicode code point, even if it is one that is also in ASCII. Therefore the string containing it must be Unicode.</source>
          <target state="translated">&lt;code&gt;\N{...}&lt;/code&gt; 構築物は、明示的にASCIIでもあるものであっても、Unicodeコードポイントを指します。したがって、それを含む文字列はUnicodeである必要があります。</target>
        </trans-unit>
        <trans-unit id="52316cb23d6228b5040f834369875ce8a00e4e55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations can be used both inside and outside of bracketed character classes. Here are some in use:</source>
          <target state="translated">&lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; 略語は括弧文字クラスの内側と外側の両方を使用することができます。以下は使用中の一部です。</target>
        </trans-unit>
        <trans-unit id="dc3bb1079451a53e38a66554502d10e12737dc82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations can be used both inside and outside of character classes. Here are some in use:</source>
          <target state="translated">&lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; 略語は、文字クラスの内側と外側の両方を使用することができます。以下は使用中の一部です。</target>
        </trans-unit>
        <trans-unit id="0f2c8f2ff00b285673d694a7e44211cdef772f8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;/code&gt; and &lt;code&gt;\k&lt;/code&gt; notations were introduced in Perl 5.10.0. Prior to that there were no named nor relative numbered capture groups. Absolute numbered groups were referred to using &lt;code&gt;\1&lt;/code&gt; , &lt;code&gt;\2&lt;/code&gt; , etc., and this notation is still accepted (and likely always will be). But it leads to some ambiguities if there are more than 9 capture groups, as &lt;code&gt;\10&lt;/code&gt; could mean either the tenth capture group, or the character whose ordinal in octal is 010 (a backspace in ASCII). Perl resolves this ambiguity by interpreting &lt;code&gt;\10&lt;/code&gt; as a backreference only if at least 10 left parentheses have opened before it. Likewise &lt;code&gt;\11&lt;/code&gt; is a backreference only if at least 11 left parentheses have opened before it. And so on. &lt;code&gt;\1&lt;/code&gt; through &lt;code&gt;\9&lt;/code&gt; are always interpreted as backreferences. There are several examples below that illustrate these perils. You can avoid the ambiguity by always using &lt;code&gt;\g{}&lt;/code&gt; or &lt;code&gt;\g&lt;/code&gt; if you mean capturing groups; and for octal constants always using &lt;code&gt;\o{}&lt;/code&gt; , or for &lt;code&gt;\077&lt;/code&gt; and below, using 3 digits padded with leading zeros, since a leading zero implies an octal constant.</source>
          <target state="translated">&lt;code&gt;\g&lt;/code&gt; と &lt;code&gt;\k&lt;/code&gt; 表記はPerl 5.10.0で導入されました。それ以前は、名前の付いた、または相対的に番号が付けられたキャプチャグループはありませんでした。絶対番号グループは、 &lt;code&gt;\1&lt;/code&gt; 、 &lt;code&gt;\2&lt;/code&gt; などを使用して参照され、この表記は引き続き受け入れられます（常にそうなる可能性があります）。ただし、 &lt;code&gt;\10&lt;/code&gt; は10番目のキャプチャグループ、または8進数の序数が010（ASCIIのバックスペース）の文字のいずれかを意味する可能性があるため、キャプチャグループが9つを超える場合はあいまいになります。 Perlは、少なくとも10個の左括弧がその前に開いている場合にのみ、 &lt;code&gt;\10&lt;/code&gt; を後方参照として解釈することにより、このあいまいさを解決します。同様に &lt;code&gt;\11&lt;/code&gt; 少なくとも11個の左括弧がその前に開いている場合にのみ後方参照になります。等々。 &lt;code&gt;\1&lt;/code&gt; から &lt;code&gt;\9&lt;/code&gt; は常に後方参照として解釈されます。これらの危険を説明するいくつかの例が以下にあります。グループをキャプチャする場合は、常に &lt;code&gt;\g{}&lt;/code&gt; または &lt;code&gt;\g&lt;/code&gt; を使用して、あいまいさを回避できます。そして進定数のために常に使用し &lt;code&gt;\o{}&lt;/code&gt; またはのために &lt;code&gt;\077&lt;/code&gt; 、先行ゼロは、8進定数を意味するので、先行ゼロで埋め3桁を使用して、以下。</target>
        </trans-unit>
        <trans-unit id="517d2abbf8670e3eaf5c272713d99b8bf67cd7d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; form can be equivalently written as &lt;code&gt;\g{&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; which avoids ambiguity when building a regex by concatenating shorter strings. Otherwise if you had a regex &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt; , you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="translated">&lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; 形式は同等のように書くことができる &lt;code&gt;\g{&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; 短い文字列を連結することによって正規表現を構築する際にあいまいさを回避します。そうでない場合、正規表現 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt; があり、 &lt;code&gt;$a&lt;/code&gt; に &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; 含まれ、 &lt;code&gt;$b&lt;/code&gt; に &lt;code&gt;&quot;37&quot;&lt;/code&gt; が含まれている場合、 &lt;code&gt;/\g137/&lt;/code&gt; が得られますが、これはおそらく意図したものではありません。</target>
        </trans-unit>
        <trans-unit id="1162dcf378fe4b180c42e9c8606223aea754f52f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__DATA__&lt;/code&gt; token tells the perl compiler that the perl code for compilation is finished. Everything after the &lt;code&gt;__DATA__&lt;/code&gt; token is available for reading via the filehandle FOOBAR::DATA, where FOOBAR is the name of the current package when the &lt;code&gt;__DATA__&lt;/code&gt; token is reached. This works just the same as &lt;code&gt;__END__&lt;/code&gt; does in package 'main', but for other modules data after &lt;code&gt;__END__&lt;/code&gt; is not automatically retrievable, whereas data after &lt;code&gt;__DATA__&lt;/code&gt; is. The &lt;code&gt;__DATA__&lt;/code&gt; token is not recognized in versions of perl prior to 5.001m.</source>
          <target state="translated">&lt;code&gt;__DATA__&lt;/code&gt; のトークンは、コンパイルのためのPerlコードが終了したことをperlのコンパイラに指示します。 &lt;code&gt;__DATA__&lt;/code&gt; トークンの後のすべては、ファイルハンドルFOOBAR :: DATAを介して読み取ることができます。FOOBARは、 &lt;code&gt;__DATA__&lt;/code&gt; トークンに達したときの現在のパッケージの名前です。これはちょうど同じ動作を &lt;code&gt;__END__&lt;/code&gt; は、「メイン」パッケージにはありませんが、他のモジュールの後にデータ &lt;code&gt;__END__&lt;/code&gt; は、データのに対し、後に、自動的に検索可能ではありません &lt;code&gt;__DATA__&lt;/code&gt; があります。 &lt;code&gt;__DATA__&lt;/code&gt; のトークンは、perlの前に5.001メートルのバージョンでは認識されません。</target>
        </trans-unit>
        <trans-unit id="e8e846812293eaeddc68b23ea744d79168534a2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , and &lt;code&gt;Z&lt;/code&gt; types gobble just one value, but pack it as a string of length count, padding with nulls or spaces as needed. When unpacking, &lt;code&gt;A&lt;/code&gt; strips trailing whitespace and nulls, &lt;code&gt;Z&lt;/code&gt; strips everything after the first null, and &lt;code&gt;a&lt;/code&gt; returns data with no stripping at all.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;A&lt;/code&gt; 、および &lt;code&gt;Z&lt;/code&gt; の種類は、ちょうど一つの値をガツガツ食べるが、必要に応じてヌルやスペースでパディング、長さ数の文字列としてそれを詰めます。解凍すると、 &lt;code&gt;A&lt;/code&gt; は末尾の空白とnullを取り除き、 &lt;code&gt;Z&lt;/code&gt; は最初のnullの後のすべてを取り除き、 &lt;code&gt;a&lt;/code&gt; はまったく取り除いていないデータを返します。</target>
        </trans-unit>
        <trans-unit id="d5cca45db774b8d4bbc26743f5dae5512cca0753" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;antlers&lt;/code&gt; import flag tells &lt;code&gt;Class::Accessor&lt;/code&gt; that you want to define your attributes using &lt;code&gt;Moose&lt;/code&gt; -like syntax. The only parameter that you can pass to &lt;code&gt;has&lt;/code&gt; is &lt;code&gt;is&lt;/code&gt; . We recommend that you use this Moose-like syntax if you choose &lt;code&gt;Class::Accessor&lt;/code&gt; since it means you will have a smoother upgrade path if you later decide to move to &lt;code&gt;Moose&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;antlers&lt;/code&gt; フラグが伝えインポート &lt;code&gt;Class::Accessor&lt;/code&gt; あなたが使用して属性を定義したいこと &lt;code&gt;Moose&lt;/code&gt; 構文様。あなたに渡すことができる唯一のパラメータ &lt;code&gt;has&lt;/code&gt; あります &lt;code&gt;is&lt;/code&gt; 。 &lt;code&gt;Class::Accessor&lt;/code&gt; を選択する場合は、このMooseのような構文を使用することをお勧めします。これは、後で &lt;code&gt;Moose&lt;/code&gt; に移行することを決定した場合に、よりスムーズなアップグレードパスが得られることを意味します。</target>
        </trans-unit>
        <trans-unit id="30d4c5418acb92744951617bccd4c2bb4e907086" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as_number()&lt;/code&gt; function returns a BigInt from a Math::BigFloat. It uses 'trunc' as rounding mode to make it equivalent to:</source>
          <target state="translated">&lt;code&gt;as_number()&lt;/code&gt; 関数は、数学::ビッグフロートからのBigIntを返します。丸めモードとして「trunc」を使用して、以下と同等にします。</target>
        </trans-unit>
        <trans-unit id="3e4be85862bcecd6790751ef47534ab240cde4eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autodie&lt;/code&gt; pragma has</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; プラグマあり</target>
        </trans-unit>
        <trans-unit id="92907be6274b88924410c3eb7108af17c084f529" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autodie&lt;/code&gt; pragma provides a convenient way to replace functions that normally return false on failure with equivalents that throw an exception on failure.</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; プラグマは、通常、失敗した場合に例外をスロー同等で失敗した場合にはfalseを返す関数を置き換えるための便利な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="3ccf77f6494c4bb94f71a5890c3e377c22247ef4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autosplit&lt;/code&gt; interface splits the specified file into a hierarchy rooted at the directory &lt;code&gt;$dir&lt;/code&gt; . It creates directories as needed to reflect class hierarchy, and creates the file</source>
          <target state="translated">&lt;code&gt;autosplit&lt;/code&gt; インターフェースは、ディレクトリをルートとする階層に指定されたファイルを分割 &lt;code&gt;$dir&lt;/code&gt; 。クラス階層を反映するために必要に応じてディレクトリを作成し、ファイルを作成します</target>
        </trans-unit>
        <trans-unit id="cc73dbc80868b5e2537b36abd82d968f2ba4c751" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autosplit_lib_modules&lt;/code&gt; form is used in the building of perl. It takes as input a list of files (modules) that are assumed to reside in a directory &lt;b&gt;lib&lt;/b&gt; relative to the current directory. Each file is sent to the autosplitter one at a time, to be split into the directory &lt;b&gt;lib/auto&lt;/b&gt;.</source>
          <target state="translated">&lt;code&gt;autosplit_lib_modules&lt;/code&gt; のフォームは、perlのの建物に使用されています。これは、現在のディレクトリに対して相対的なディレクトリ&lt;b&gt;lib&lt;/b&gt;にあると想定されているファイル（モジュール）のリストを入力として受け取ります。各ファイルは一度に1つずつ&lt;b&gt;オート&lt;/b&gt;スプリッターに送信され、ディレクトリ&lt;b&gt;lib / autoに&lt;/b&gt;分割されます。</target>
        </trans-unit>
        <trans-unit id="423004d21ce960dd9509db30e9f26d66964e12d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autotie&lt;/code&gt; mechanism supports this too. The following code:</source>
          <target state="translated">&lt;code&gt;autotie&lt;/code&gt; のメカニズムは、あまりにもこれをサポートしています。次のコード：</target>
        </trans-unit>
        <trans-unit id="eadb034339c34e003fe891167b8ebaef4be23657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_clear&lt;/code&gt; function deletes all the elements in the AV* array, but does not actually delete the array itself. The &lt;code&gt;av_undef&lt;/code&gt; function will delete all the elements in the array plus the array itself. The &lt;code&gt;av_extend&lt;/code&gt; function extends the array so that it contains at least &lt;code&gt;key+1&lt;/code&gt; elements. If &lt;code&gt;key+1&lt;/code&gt; is less than the currently allocated length of the array, then nothing is done.</source>
          <target state="translated">&lt;code&gt;av_clear&lt;/code&gt; 機能は、AV *、アレイ内のすべての要素を削除し、実際の配列自体を削除しません。 &lt;code&gt;av_undef&lt;/code&gt; 関数は、配列プラス配列自体内のすべての要素を削除します。 &lt;code&gt;av_extend&lt;/code&gt; のそれが少なくとも含まれるように関数は、配列を拡張 &lt;code&gt;key+1&lt;/code&gt; 要素。場合は &lt;code&gt;key+1&lt;/code&gt; 、アレイの現在割り当てられている長さより短い、何も行われません。</target>
        </trans-unit>
        <trans-unit id="d6bd36bbe209d0e332f324c88cb8fab5da451e26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_store&lt;/code&gt; function, when given a tied array argument, merely copies the magic of the array onto the value to be &quot;stored&quot;, using &lt;code&gt;mg_copy&lt;/code&gt; . It may also return NULL, indicating that the value did not actually need to be stored in the array. [MAYCHANGE] After a call to &lt;code&gt;av_store&lt;/code&gt; on a tied array, the caller will usually need to call &lt;code&gt;mg_set(val)&lt;/code&gt; to actually invoke the perl level &quot;STORE&quot; method on the TIEARRAY object. If &lt;code&gt;av_store&lt;/code&gt; did return NULL, a call to &lt;code&gt;SvREFCNT_dec(val)&lt;/code&gt; will also be usually necessary to avoid a memory leak. [/MAYCHANGE]</source>
          <target state="translated">&lt;code&gt;av_store&lt;/code&gt; を用いて、「保存された」される値に単にコピー配列のマジック、tieされた配列の引数が与えられる機能、 &lt;code&gt;mg_copy&lt;/code&gt; を。また、NULLを返すこともあり、値を実際に配列に格納する必要がなかったことを示します。 [MAYCHANGE] &lt;code&gt;av_store&lt;/code&gt; れた配列でav_storeを呼び出した後、呼び出し側は通常、 &lt;code&gt;mg_set(val)&lt;/code&gt; を呼び出して、TIEARRAYオブジェクトのperlレベルの「STORE」メソッドを実際に呼び出す必要があります。 &lt;code&gt;av_store&lt;/code&gt; がNULLを返した場合は、通常、メモリリークを回避するために &lt;code&gt;SvREFCNT_dec(val)&lt;/code&gt; の呼び出しも必要です。 [/ MAYCHANGE]</target>
        </trans-unit>
        <trans-unit id="b0bf6421125301461c635d2914e7cd34219ce4cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_top_index&lt;/code&gt; function returns the highest index value in an array (just like $#array in Perl). If the array is empty, -1 is returned. The &lt;code&gt;av_fetch&lt;/code&gt; function returns the value at index &lt;code&gt;key&lt;/code&gt; , but if &lt;code&gt;lval&lt;/code&gt; is non-zero, then &lt;code&gt;av_fetch&lt;/code&gt; will store an undef value at that index. The &lt;code&gt;av_store&lt;/code&gt; function stores the value &lt;code&gt;val&lt;/code&gt; at index &lt;code&gt;key&lt;/code&gt; , and does not increment the reference count of &lt;code&gt;val&lt;/code&gt; . Thus the caller is responsible for taking care of that, and if &lt;code&gt;av_store&lt;/code&gt; returns NULL, the caller will have to decrement the reference count to avoid a memory leak. Note that &lt;code&gt;av_fetch&lt;/code&gt; and &lt;code&gt;av_store&lt;/code&gt; both return &lt;code&gt;SV**&lt;/code&gt; 's, not &lt;code&gt;SV*&lt;/code&gt; 's as their return value.</source>
          <target state="translated">&lt;code&gt;av_top_index&lt;/code&gt; 関数は、配列（Perlで同じよう$＃配列）で最高のインデックス値を返します。配列が空の場合、-1が返されます。 &lt;code&gt;av_fetch&lt;/code&gt; 関数は、インデックスに値を返す &lt;code&gt;key&lt;/code&gt; が、場合 &lt;code&gt;lval&lt;/code&gt; 非ゼロであり、その後 &lt;code&gt;av_fetch&lt;/code&gt; は、そのインデックスにはundef値を格納します。 &lt;code&gt;av_store&lt;/code&gt; の機能を格納値 &lt;code&gt;val&lt;/code&gt; のインデックスでの &lt;code&gt;key&lt;/code&gt; 、との参照カウントインクリメントしない &lt;code&gt;val&lt;/code&gt; 。したがって、呼び出し側はそれを処理する責任があり、 &lt;code&gt;av_store&lt;/code&gt; がNULLを返す場合、呼び出し側はメモリリークを回避するために参照カウントをデクリメントする必要があります。なお、 &lt;code&gt;av_fetch&lt;/code&gt; と &lt;code&gt;av_store&lt;/code&gt; はどちらも、戻り値として &lt;code&gt;SV*&lt;/code&gt; ではなく &lt;code&gt;SV**&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="ca3e501abc26cf1405f0402c343ec30915264f88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; keywords from C become in Perl &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, respectively. Unlike in C, these do</source>
          <target state="translated">C の &lt;code&gt;break&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; キーワードは、それぞれPerlの &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; になります。Cとは異なり、これらは</target>
        </trans-unit>
        <trans-unit id="1750aab93908ada1ee29e1880f7061b67617e505" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cacheout&lt;/code&gt; function will make sure that there's a filehandle open for reading or writing available as the pathname you give it. It automatically closes and re-opens files if you exceed your system's maximum number of file descriptors, or the suggested maximum</source>
          <target state="translated">&lt;code&gt;cacheout&lt;/code&gt; の機能は必ず読んだり、あなたがそれを与えるパス名として利用できる書き込み用のファイルハンドルのオープンがあることになります。システムのファイル記述子の最大数、または推奨される最大数を超えると、ファイルを自動的に閉じて再度開きます。</target>
        </trans-unit>
        <trans-unit id="2c5778ca552de672cec71f94fb24332cb951e6b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can&lt;/code&gt; method checks to see if the class or object it was called on has a method named &lt;code&gt;$method&lt;/code&gt; . This checks for the method in the class and all of its parents. If the method exists, then a reference to the subroutine is returned. If it does not then &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;can&lt;/code&gt; それは上と呼ばれていたクラスやオブジェクトは、名前のメソッドがあるかどうかを確認するためのメソッドをチェック &lt;code&gt;$method&lt;/code&gt; 。これにより、クラス内のメソッドとそのすべての親がチェックされます。メソッドが存在する場合、サブルーチンへの参照が返されます。そうでない場合は、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="a231f00f91910adc2ab3862d9199fc8f2fdda4f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can_run&lt;/code&gt; function can tell you if a certain binary is installed and if so where, whereas the &lt;code&gt;run&lt;/code&gt; function can actually execute any of the commands you give it and give you a clear return value, as well as adhere to your verbosity settings.</source>
          <target state="translated">&lt;code&gt;can_run&lt;/code&gt; の機能は、特定のバイナリがインストールされている場合はあなたを伝えることができそうであればどこ、一方 &lt;code&gt;run&lt;/code&gt; 機能は、実際にあなたがそれを与え、あなたの冗長性の設定に明確な戻り値だけでなく、付着を与えるコマンドのいずれかを実行することができます。</target>
        </trans-unit>
        <trans-unit id="ae669119c46135f428f552580c056d83e94ae6fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char*&lt;/code&gt; string does not tell you the whole story, and you can't copy or reconstruct an SV just by copying the string value. Check if the old SV has the UTF8 flag set (</source>
          <target state="translated">&lt;code&gt;char*&lt;/code&gt; 文字列は、あなたの全体の話を教えてくれない、とあなただけの文字列値をコピーすることによってSVをコピーまたは復元することはできません。古いSVにUTF8フラグが設定されているかどうかを確認します（</target>
        </trans-unit>
        <trans-unit id="3b094d933bb88b4ae1f6722063975d6ce16a864f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;charnames&lt;/code&gt; pragma supports arguments &lt;code&gt;:full&lt;/code&gt; , &lt;code&gt;:loose&lt;/code&gt; , &lt;code&gt;:short&lt;/code&gt; , script names and &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;customized aliases&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;charnames&lt;/code&gt; のプラグマがサポートする引数 &lt;code&gt;:full&lt;/code&gt; 、 &lt;code&gt;:loose&lt;/code&gt; 、 &lt;code&gt;:short&lt;/code&gt; 、スクリプト名および&lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;カスタマイズされた別名&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7bf018bbe36ec38be15a617cdd0dc65af5cb382c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cmp&lt;/code&gt; (and hence &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;) operators do not necessarily give the correct results when both operands are UTF-EBCDIC encoded strings and there is a mixture of ASCII and/or control characters, along with other characters.</source>
          <target state="translated">&lt;code&gt;cmp&lt;/code&gt; （従って &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; ）両方のオペランドがUTF-EBCDICエンコードされた文字列であり、ASCIIおよび/または制御文字の混合物が他の文字と一緒に、存在する場合にオペレータが必ずしも正しい結果を与えません。</target>
        </trans-unit>
        <trans-unit id="ec09ece4b13035db3b64ac6559a812694d130f2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;color&lt;/code&gt; function determines if colouring should occur or not. Passing it a true or false value will enable or disable colouring respectively, and the function called with no argument will return the current setting.</source>
          <target state="translated">&lt;code&gt;color&lt;/code&gt; 着色が発生したりべきではない場合、関数は決定されます。trueまたはfalseの値を渡すと、それぞれカラーリングが有効または無効になり、引数なしで呼び出された関数は現在の設定を返します。</target>
        </trans-unit>
        <trans-unit id="fcc832a2467057f7acfd689fa1bb07925f149ce1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;complicated&lt;/code&gt; function will return the same numeric &lt;code&gt;$result&lt;/code&gt; regardless of whether it is called in list or in scalar context.</source>
          <target state="translated">&lt;code&gt;complicated&lt;/code&gt; 機能は同じ数値を返します &lt;code&gt;$result&lt;/code&gt; 関係なく、それがリストまたはスカラーコンテキストで呼び出されているかどうかの。</target>
        </trans-unit>
        <trans-unit id="f67952b359119ecd8ea38089ffb10eb7987a4172" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_broadcast&lt;/code&gt; function works similarly to &lt;code&gt;cond_signal&lt;/code&gt; . &lt;code&gt;cond_broadcast&lt;/code&gt; , though, will unblock &lt;b&gt;all&lt;/b&gt; the threads that are blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the locked variable, rather than only one.</source>
          <target state="translated">&lt;code&gt;cond_broadcast&lt;/code&gt; 関数はcond_signalと同様に機能し &lt;code&gt;cond_signal&lt;/code&gt; 。 &lt;code&gt;cond_broadcast&lt;/code&gt; は、かかわらず、ブロック解除されます&lt;b&gt;全て&lt;/b&gt;にブロックされたスレッド &lt;code&gt;cond_wait&lt;/code&gt; というだけのものよりも、ロックされた変数にします。</target>
        </trans-unit>
        <trans-unit id="a85c76c4fd238a57c5f21f762fcaeb20729d17df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt; ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="translated">&lt;code&gt;cond_signal&lt;/code&gt; 関数は、かかる&lt;b&gt;ロック&lt;/b&gt;だパラメータとブロック解除一つのスレッドとして変数を &lt;code&gt;cond_wait&lt;/code&gt; その変数のING。その変数の &lt;code&gt;cond_wait&lt;/code&gt; で複数のスレッドがブロックされている場合、ブロックが解除されるのは1つ（および不確定なスレッド）だけです。</target>
        </trans-unit>
        <trans-unit id="c5be06c4673c5f0381dc64821a424c5ce57dffbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a locked variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt; ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="translated">&lt;code&gt;cond_signal&lt;/code&gt; 関数は、パラメータとして、ロックされた変数を取り、だ一つのスレッドブロック解除 &lt;code&gt;cond_wait&lt;/code&gt; その変数のINGを。その変数の &lt;code&gt;cond_wait&lt;/code&gt; で複数のスレッドがブロックされている場合、ブロックが解除されるのは1つ（および不確定なスレッド）だけです。</target>
        </trans-unit>
        <trans-unit id="076e7dbb91376a2a5dc565f0cafe6a8c9c90bfab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is re-locked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt; ing on the same variable, all but one will re-block waiting to reacquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible). The two actions of unlocking the variable and entering the blocked wait state are atomic, the two actions of exiting from the blocked wait state and re-locking the variable are not.</source>
          <target state="translated">&lt;code&gt;cond_wait&lt;/code&gt; 関数は、かかる&lt;b&gt;ロックされ&lt;/b&gt;、別のスレッドが行うまで、パラメータとして変数を変数のロックを解除し、ブロック &lt;code&gt;cond_signal&lt;/code&gt; や &lt;code&gt;cond_broadcast&lt;/code&gt; その同じロックされた変数のために。 &lt;code&gt;cond_wait&lt;/code&gt; がブロックされた変数は、 &lt;code&gt;cond_wait&lt;/code&gt; が満たされた後に再度ロックされます。同じ変数で &lt;code&gt;cond_wait&lt;/code&gt; を実行しているスレッドが複数ある場合、1つを除くすべてのスレッドが、変数のロックの再取得を待機して再ブロックします。 （つまり、 &lt;code&gt;cond_wait&lt;/code&gt; のみを使用している場合同期のために、できるだけ早くロックを放棄してください）。変数のロック解除とブロックされた待機状態への2つのアクションはアトミックです。ブロックされた待機状態からの終了と変数の再ロックの2つのアクションはアトミックではありません。</target>
        </trans-unit>
        <trans-unit id="0fa04a005ef5fee3bbdeb8f830aca63065ce2e7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is relocked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt; ing on the same variable, all but one will reblock waiting to re-acquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible.)</source>
          <target state="translated">&lt;code&gt;cond_wait&lt;/code&gt; 関数は、かかる&lt;b&gt;ロックされ&lt;/b&gt;、別のスレッドが行うまで、パラメータとして変数を変数のロックを解除し、ブロック &lt;code&gt;cond_signal&lt;/code&gt; や &lt;code&gt;cond_broadcast&lt;/code&gt; その同じロックされた変数のために。 &lt;code&gt;cond_wait&lt;/code&gt; がブロックされた変数は、 &lt;code&gt;cond_wait&lt;/code&gt; が満たされた後に再度ロックされます。同じ変数で &lt;code&gt;cond_wait&lt;/code&gt; を実行しているスレッドが複数ある場合、1つを除くすべてのスレッドが、変数のロックの再取得を待機して再ブロックします。 （したがって、同期に &lt;code&gt;cond_wait&lt;/code&gt; のみを使用している場合は、できるだけ早くロックを放棄してください。）</target>
        </trans-unit>
        <trans-unit id="c05e65092ed5c30b3ec99766dc7198ef2d697366" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;condition&lt;/code&gt; can have several forms. The first form is simply an integer in parentheses &lt;code&gt;(integer)&lt;/code&gt; . It is true if the corresponding backreference &lt;code&gt;\integer&lt;/code&gt; matched earlier in the regexp. The same thing can be done with a name associated with a capture group, written as &lt;code&gt;(&amp;lt;name&amp;gt;)&lt;/code&gt; or &lt;code&gt;('name')&lt;/code&gt; . The second form is a bare zero-width assertion &lt;code&gt;(?...)&lt;/code&gt;, either a lookahead, a lookbehind, or a code assertion (discussed in the next section). The third set of forms provides tests that return true if the expression is executed within a recursion (&lt;code&gt;(R)&lt;/code&gt; ) or is being called from some capturing group, referenced either by number (&lt;code&gt;(R1)&lt;/code&gt; , &lt;code&gt;(R2)&lt;/code&gt; ,...) or by name (&lt;code&gt;(R&amp;amp;name)&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; いくつかの形式を持つことができます。最初の形式は、括弧内の &lt;code&gt;(integer)&lt;/code&gt; です。対応する後方参照 &lt;code&gt;\integer&lt;/code&gt; が正規表現の最初の部分で一致した場合はtrueです。 &lt;code&gt;(&amp;lt;name&amp;gt;)&lt;/code&gt; または &lt;code&gt;('name')&lt;/code&gt; のように記述されたキャプチャグループに関連付けられた名前でも同じことができます。 2番目の形式は、先読み、後読み、またはコードアサーション（次のセクションで説明 &lt;code&gt;(?...)&lt;/code&gt; いずれかである、ゼロ幅アサーション（？...）です。フォームの3番目のセットは、式が再帰内で実行された場合（ &lt;code&gt;(R)&lt;/code&gt; ）、または番号（ &lt;code&gt;(R1)&lt;/code&gt; 、 &lt;code&gt;(R2)&lt;/code&gt; 、...）または名前（ &lt;code&gt;(R&amp;amp;name)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bf42e706aa15e3b9613116ccaae1bce3997d5965" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; function takes two parameters: a file to copy from and a file to copy to. Either argument may be a string, a FileHandle reference or a FileHandle glob. Obviously, if the first argument is a filehandle of some sort, it will be read from, and if it is a file</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; からコピーするファイルとコピー先のファイル：関数は2つのパラメータを取ります。どちらの引数も、文字列、FileHandle参照、またはFileHandleグロブのいずれかです。明らかに、最初の引数がなんらかのファイルハンドルである場合は、それが読み取られ、ファイルの場合は</target>
        </trans-unit>
        <trans-unit id="bb585d66ac9e0baf39acd70331ff3f0f5eef7b95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cpp&lt;/code&gt; filter does not apply to the text of the Fred module, only to the text of the file that used it (&lt;code&gt;cpp_test&lt;/code&gt; ). Although the use statement on line 3 will pass through the cpp filter, the module that gets included (&lt;code&gt;Fred&lt;/code&gt; ) will not. The source streams look like this after line 3 has been parsed and before line 4 is parsed:</source>
          <target state="translated">&lt;code&gt;cpp&lt;/code&gt; フィルタは、それを使用したファイル（のテキストに、フレッド・モジュールのテキストには適用されません &lt;code&gt;cpp_test&lt;/code&gt; ）。3行目のuseステートメントはcppフィルターを通過しますが、含まれるモジュール（ &lt;code&gt;Fred&lt;/code&gt; ）は通過しません。3行目が解析された後、4行目が解析される前のソースストリームは次のようになります。</target>
        </trans-unit>
        <trans-unit id="3a0e889b0f475939308ccb8373e116461d3751c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;create()&lt;/code&gt; method takes a reference to a subroutine and creates a new thread that starts executing in the referenced subroutine. Control then passes both to the subroutine and the caller.</source>
          <target state="translated">&lt;code&gt;create()&lt;/code&gt; メソッドは、サブルーチンへの参照を取得し、参照サブルーチンで実行を開始し、新しいスレッドを作成します。その後、制御はサブルーチンと呼び出し元の両方に渡されます。</target>
        </trans-unit>
        <trans-unit id="30b3d6c14b075946962dafa1dc3a2886740f908a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;diagnostics&lt;/code&gt; Pragma</source>
          <target state="translated">&lt;code&gt;diagnostics&lt;/code&gt; プラグマ</target>
        </trans-unit>
        <trans-unit id="086b0e345be46fb23c5d4022bc1b3516ac49d7c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;display_format&lt;/code&gt; class method and the corresponding &lt;code&gt;display_format&lt;/code&gt; object method can now be called using a parameter hash instead of just a one parameter.</source>
          <target state="translated">&lt;code&gt;display_format&lt;/code&gt; のクラスメソッドと対応 &lt;code&gt;display_format&lt;/code&gt; のオブジェクトメソッドは、現在のパラメータハッシュの代わりにただ一つのパラメータを使用して呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="85937d63d0c2a7155254307de5c15a8dc64cc7fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;done&lt;/code&gt; method returns true if the thread you're checking has finished, and false otherwise.</source>
          <target state="translated">&lt;code&gt;done&lt;/code&gt; あなたがしているチェックがそうでなければ終了し、偽したスレッド場合はtrueメソッドが返します。</target>
        </trans-unit>
        <trans-unit id="5c42a2b150a081cef9d9a1db39370eb144f13339" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down&lt;/code&gt; method decreases the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="translated">&lt;code&gt;down&lt;/code&gt; 方法は、数が指定されていない場合、または1つによって（整数&amp;gt; = 1でなければならない）指定された数によってセマフォの数を減少させます。</target>
        </trans-unit>
        <trans-unit id="1d986e9044d0332c0e0b20d1b476092f758b1763" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down_force&lt;/code&gt; method decreases the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified. This method does not block, and may cause the semaphore's count to drop below zero.</source>
          <target state="translated">&lt;code&gt;down_force&lt;/code&gt; の方法は、数が指定されていない場合、または1つによって（整数&amp;gt; = 1でなければならない）指定された数によってセマフォの数を減少させます。このメソッドはブロックせず、セマフォのカウントがゼロ未満になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="59032671c2f862c61987094dab4187139af577bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down_nb&lt;/code&gt; method attempts to decrease the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="translated">&lt;code&gt;down_nb&lt;/code&gt; の数が特定されていない場合（&amp;gt; = 1の整数でなければならない）指定された数により、または1つによってセマフォの数を減少させる方法を試み。</target>
        </trans-unit>
        <trans-unit id="48ce45b8c5dc5a90ffb8cc26e428eb8e7134ca2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eogc&lt;/code&gt; flags are stripped out before being passed to the comp routine. The regex engine does not need to know if any of these are set, as those flags should only affect what Perl does with the pattern and its match variables, not how it gets compiled and executed.</source>
          <target state="translated">&lt;code&gt;eogc&lt;/code&gt; フラグはカンプ・ルーチンに渡される前に取り除かれています。正規表現エンジンは、これらのフラグが設定されているかどうかを知る必要はありません。これらのフラグは、Perlがパターンとその一致変数を使用して行う動作にのみ影響し、コンパイルと実行の方法には影響しないためです。</target>
        </trans-unit>
        <trans-unit id="5dcaf0131993c2fe373ceb68066111b75397ce84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equal()&lt;/code&gt; method takes two thread objects and returns true if the objects represent the same thread, and false if they don't.</source>
          <target state="translated">&lt;code&gt;equal()&lt;/code&gt; メソッドは、そうでない場合は、オブジェクトは同じスレッドを表し、falseの場合、真の2つのスレッド・オブジェクトとリターンを取ります。</target>
        </trans-unit>
        <trans-unit id="d80af1149bc4ce69fb624da74e40c6a5dafd9409" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;examples&lt;/code&gt; sub-directory has copies of all these filters implemented both as</source>
          <target state="translated">&lt;code&gt;examples&lt;/code&gt; サブディレクトリには、すべてのこれらのフィルタのコピーでは、どちらを実施しています</target>
        </trans-unit>
        <trans-unit id="a371087f59ef9684a3303b0318405ae011e9ec34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract_delimited&lt;/code&gt; function formalizes the common idiom of extracting a single-character-delimited substring from the start of a string. For example, to extract a single-quote delimited string, the following code is typically used:</source>
          <target state="translated">&lt;code&gt;extract_delimited&lt;/code&gt; 関数は、文字列の先頭から単一文字で区切られた部分文字列を抽出する一般的なイディオムを定式化したものです。たとえば、単一引用符で区切られた文字列を抽出するには、通常次のコードを使用します。</target>
        </trans-unit>
        <trans-unit id="01013bd276b6d8fe2331fe338d632601823957b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract_multiple&lt;/code&gt; subroutine takes a string to be processed and a list of extractors (subroutines or regular expressions) to apply to that string.</source>
          <target state="translated">&lt;code&gt;extract_multiple&lt;/code&gt; サブルーチンは、その文字列に適用するために処理される文字列と抽出（サブルーチンや正規表現）のリストを取ります。</target>
        </trans-unit>
        <trans-unit id="0234e9715d2d58dfe4e40eada785cc5d3ba85e48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fail&lt;/code&gt; option indicates the action to be taken if a matching end tag is not encountered (i.e. before the end of the string or some &lt;code&gt;reject&lt;/code&gt; pattern matches). By default, a failure to match a closing tag causes &lt;code&gt;extract_tagged&lt;/code&gt; to immediately fail.</source>
          <target state="translated">&lt;code&gt;fail&lt;/code&gt; オプションは、対応する終了タグが遭遇していない場合に実行するアクションを示します（つまり、文字列の末尾または一部が前に &lt;code&gt;reject&lt;/code&gt; パターンの一致を）。デフォルトでは、終了タグとの一致に失敗すると、 &lt;code&gt;extract_tagged&lt;/code&gt; はすぐに失敗します。</target>
        </trans-unit>
        <trans-unit id="7fdb136937ca0405fd0e09f20f2a40c4f858261d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;failed&lt;/code&gt; command reports all distributions that failed on one of &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; or &lt;code&gt;install&lt;/code&gt; for some reason in the currently running shell session.</source>
          <target state="translated">&lt;code&gt;failed&lt;/code&gt; コマンドは次のいずれかに失敗したことをすべてのディストリビューションを報告 &lt;code&gt;make&lt;/code&gt; 、 &lt;code&gt;test&lt;/code&gt; または &lt;code&gt;install&lt;/code&gt; 現在実行中のシェルのセッションで何らかの理由を。</target>
        </trans-unit>
        <trans-unit id="5ad80da9f3017cad820985c782b83967ca308a28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;family&lt;/code&gt; hint to getaddrinfo(), or the family of the socket address passed to getnameinfo() is not supported.</source>
          <target state="translated">getaddrinfo（）への &lt;code&gt;family&lt;/code&gt; ヒント、またはgetnameinfo（）に渡されたソケットアドレスのファミリはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="aaa028e0e10b907654ea97ca6e2e56dbd54cf34e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch&lt;/code&gt; utility is available on FreeBSD. NetBSD and Dragonfly BSD may also have it from &lt;code&gt;pkgsrc&lt;/code&gt; . We only check for &lt;code&gt;fetch&lt;/code&gt; on those three platforms.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; ユーティリティはFreeBSD上で使用可能です。NetBSDとDragonfly BSDは、 &lt;code&gt;pkgsrc&lt;/code&gt; からそれを持っているかもしれません。これらの3つのプラットフォームでのみ &lt;code&gt;fetch&lt;/code&gt; をチェックします。</target>
        </trans-unit>
        <trans-unit id="9e227d5e7190288807dd09d5662a48f3b24c6088" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fforce&lt;/code&gt; pragma is a variant that emulates a &lt;code&gt;force get&lt;/code&gt; which erases the entire memory followed by the action specified, effectively restarting the whole get/make/test/install procedure from scratch.</source>
          <target state="translated">&lt;code&gt;fforce&lt;/code&gt; プラグマは、エミュレートバリアントである &lt;code&gt;force get&lt;/code&gt; メモリ全体を効果的に最初からインストール手順/全体のget /メイク/テストを再起動し、指定されたアクションが続く消去されます。</target>
        </trans-unit>
        <trans-unit id="67136aec5c09887a5fbdbeaf79603ace225d72fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fields&lt;/code&gt; pragma enables compile-time and run-time verified class fields.</source>
          <target state="translated">&lt;code&gt;fields&lt;/code&gt; プラグマは、コンパイル時と実行時にクラスのフィールドを検証できます。</target>
        </trans-unit>
        <trans-unit id="1da25c8608c050c137eec0fcb8b96dfa9d530dcf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filename&lt;/code&gt; , &lt;code&gt;flags&lt;/code&gt; and &lt;code&gt;mode&lt;/code&gt; parameters are the direct equivalent of their dbopen() counterparts. The final parameter $DB_HASH performs the function of both the &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;openinfo&lt;/code&gt; parameters in dbopen().</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 、 &lt;code&gt;flags&lt;/code&gt; 及び &lt;code&gt;mode&lt;/code&gt; パラメータは、それらのdbopen（）対応の直接等価です。最終パラメータ$ DB_HASHの実行の両方の機能 &lt;code&gt;type&lt;/code&gt; と &lt;code&gt;openinfo&lt;/code&gt; のdbopenのパラメータ（）。</target>
        </trans-unit>
        <trans-unit id="711049b66f21cfb21f8abf404e302b9cb973606c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fileparse()&lt;/code&gt; routine divides a file path into its $dirs, $filename and (optionally) the filename $suffix.</source>
          <target state="translated">&lt;code&gt;fileparse()&lt;/code&gt; （オプション）ルーチン除算その$ dirsににファイルのパス、$ファイル名やファイル名$サフィックス。</target>
        </trans-unit>
        <trans-unit id="602708ab2289d55123d1e5cfa483278e5dc2b095" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument can have UNI_DISPLAY_ISPRINT set to display isPRINT()able characters as themselves, UNI_DISPLAY_BACKSLASH to display the \\[nrfta\\] as the backslashed versions (like '\n') (UNI_DISPLAY_BACKSLASH is preferred over UNI_DISPLAY_ISPRINT for \\). UNI_DISPLAY_QQ (and its alias UNI_DISPLAY_REGEX) have both UNI_DISPLAY_BACKSLASH and UNI_DISPLAY_ISPRINT turned on.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 引数は（UNI_DISPLAY_BACKSLASHが\\ためUNI_DISPLAY_ISPRINTよりも好ましい）（「\ n」のような）バックスラッシュバージョンとして\\ [nrfta \\]を表示するために、それ自体としてUNI_DISPLAY_BACKSLASHをisprintは（）ことができる文字を表示するUNI_DISPLAY_ISPRINTセットを有することができます。UNI_DISPLAY_QQ（およびそのエイリアスUNI_DISPLAY_REGEX）では、UNI_DISPLAY_BACKSLASHとUNI_DISPLAY_ISPRINTの両方がオンになっています。</target>
        </trans-unit>
        <trans-unit id="db2dfe02c9ae062f42652141438a9f9714c71cea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument is as in &lt;a href=&quot;#pv_uni_display&quot;&gt;pv_uni_display&lt;/a&gt;().</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 引数がのようである&lt;a href=&quot;#pv_uni_display&quot;&gt;pv_uni_display&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="99738c77e0f1da5722068673963c4a8f215d0b31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; can be:</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 指定できます。</target>
        </trans-unit>
        <trans-unit id="cefd6d4dfafa940aea51a92bdcb195eed2de69a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; method returned the flags for the thread - an integer value corresponding to the internal flags for the thread.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; スレッドの内部フラグに対応する整数値を-メソッドは、スレッドのためのフラグを返しました。</target>
        </trans-unit>
        <trans-unit id="6cca4f06215bca47eddea026c40afe1b9a43be1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter can be used to determine which of these operations the callbacks should respond to. The following flags are currently defined:</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; パラメータは、コールバックが応答する必要があり、これらの操作のどれかを決定するために使用することができます。現在、次のフラグが定義されています。</target>
        </trans-unit>
        <trans-unit id="459faaa5e3280fee22284d6b094987c77fa7de30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter in all the</source>
          <target state="translated">すべての &lt;code&gt;flags&lt;/code&gt; パラメータ</target>
        </trans-unit>
        <trans-unit id="bfe1865df397f3698f54ec1b600413c38607abed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is a bitfield which indicates which of the &lt;code&gt;msixpn&lt;/code&gt; flags the regex was compiled with. It also contains additional info, such as if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; パラメータは、のかを示すビットフィールドである &lt;code&gt;msixpn&lt;/code&gt; 正規表現がコンパイルされたフラグ。また、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; が有効かどうかなどの追加情報も含まれています。</target>
        </trans-unit>
        <trans-unit id="b886ddfa56e0b9ebfe8f2070d41589a1086768dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flush_cache()&lt;/code&gt; function will raise a run-time error unless the tied package provides a &lt;code&gt;CLEAR&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;flush_cache()&lt;/code&gt; 結ばれたパッケージが提供されない限り機能は、実行時エラーが発生します &lt;code&gt;CLEAR&lt;/code&gt; の方法を。</target>
        </trans-unit>
        <trans-unit id="8ee8bf6c49cb0d370b573c84b81eeff22daa626c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;force&lt;/code&gt; pragma may precede another command (currently: &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; , or &lt;code&gt;install&lt;/code&gt; ) to execute the command from scratch and attempt to continue past certain errors. See the section below on the &lt;code&gt;force&lt;/code&gt; and the &lt;code&gt;fforce&lt;/code&gt; pragma.</source>
          <target state="translated">&lt;code&gt;force&lt;/code&gt; ：（現在プラグマは、別のコマンド先行して &lt;code&gt;get&lt;/code&gt; 、 &lt;code&gt;make&lt;/code&gt; 、 &lt;code&gt;test&lt;/code&gt; 、または &lt;code&gt;install&lt;/code&gt; 最初からコマンドを実行すると、過去の特定のエラーを継続しようとします）。以下の &lt;code&gt;force&lt;/code&gt; および &lt;code&gt;fforce&lt;/code&gt; プラグマのセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="34f4026c135fb9c9e701839369f22ab72881f9e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; is the non-experimental way to set a topicalizer. If you wish to use the highly experimental &lt;code&gt;given&lt;/code&gt; , that could be written like this:</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; のはのtopicalizerを設定するための非実験的な方法です。あなたは非常に実験的に使用したい場合は &lt;code&gt;given&lt;/code&gt; 、それはこのように書くことができます：</target>
        </trans-unit>
        <trans-unit id="de226564415ab69d6441fa2857763cf2ce5fdae3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; keyword is actually a synonym for the &lt;code&gt;for&lt;/code&gt; keyword, so you can use either. If VAR is omitted, &lt;code&gt;$_&lt;/code&gt; is set to each value.</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; のキーワードは、実際の同義語である &lt;code&gt;for&lt;/code&gt; 、キーワード、あなたがいずれかを使用することができます。VARを省略すると、 &lt;code&gt;$_&lt;/code&gt; が各値に設定されます。</target>
        </trans-unit>
        <trans-unit id="375dcc1d1d2f6f42cca4896811ca8fdfa2d3b491" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; keyword is actually a synonym for the &lt;code&gt;for&lt;/code&gt; keyword. See &lt;code&gt;&lt;a href=&quot;perlsyn#Foreach-Loops&quot;&gt;Foreach Loops in perlsyn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; キーワードは、実際の同義語である &lt;code&gt;for&lt;/code&gt; のキーワード。 &lt;code&gt;&lt;a href=&quot;perlsyn#Foreach-Loops&quot;&gt;Foreach Loops in perlsyn&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="b86bb402e5da8037aee4e69efe060f892f194612" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop can also take a reference constructor for its loop variable, though the syntax is limited to one of the following, with an optional &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; after the backslash:</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 構文は次のいずれかに限定されているもののループはまた、オプションで、そのループ変数の参照コンストラクタを取ることができ &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; バックスラッシュの後に：</target>
        </trans-unit>
        <trans-unit id="d9c367bfb9bb4dab65fff1b13521d38572d69dfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop defaults to scoping its index variable dynamically in the manner of &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;. However, if the index variable is prefixed with the keyword &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, or if there is already a lexical by that name in scope, then a new lexical is created instead. Thus in the loop</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; の方法で動的にインデックス変数をスコープにループのデフォルトは &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 。ただし、インデックス変数の前にキーワード &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; が付いている場合、またはスコープ内にその名前のレキシカルがすでに存在する場合は、代わりに新しいレキシカルが作成されます。したがって、ループで</target>
        </trans-unit>
        <trans-unit id="a4c4603cb509242d80999a110064359f577c21d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop iterates over a normal list value and sets the scalar variable VAR to be each element of the list in turn. If the variable is preceded with the keyword &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, then it is lexically scoped, and is therefore visible only within the loop. Otherwise, the variable is implicitly local to the loop and regains its former value upon exiting the loop. If the variable was previously declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, it uses that variable instead of the global one, but it's still localized to the loop. This implicit localization occurs</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; の通常のリスト値をループの反復と順番にリストの各要素であることがスカラー変数VARを設定します。変数の前にキーワード &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; が付いている場合、それはレキシカルにスコープされているため、ループ内でのみ表示されます。それ以外の場合、変数は暗黙的にループに対してローカルであり、ループを終了すると元の値に戻ります。変数が以前に &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; で宣言されていた場合、グローバル変数ではなくその変数を使用しますが、それでもループにローカライズされています。この暗黙のローカリゼーションが発生します</target>
        </trans-unit>
        <trans-unit id="bb381f2681e84a2954e18395a958e606ca6cba3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame&lt;/code&gt; option can be used to control the output of frame information. For example, contrast this expression trace:</source>
          <target state="translated">&lt;code&gt;frame&lt;/code&gt; オプションは、フレーム情報の出力を制御するために使用することができます。たとえば、次の式のトレースを対比します。</target>
        </trans-unit>
        <trans-unit id="01af8f56de621025abc07dc645713da63a5fe927" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_delimited_pat&lt;/code&gt; subroutine takes a single (string) argument and &amp;gt; builds a Friedl-style optimized regex that matches a string delimited by any one of the characters in the single argument. For example:</source>
          <target state="translated">&lt;code&gt;gen_delimited_pat&lt;/code&gt; サブルーチンは、単一の（文字列）の引数を取り、&amp;gt;単一の引数の文字のいずれかで区切られた文字列に一致するFriedlのスタイルに最適化正規表現を構築します。例えば：</target>
        </trans-unit>
        <trans-unit id="617ccfb027c1e5d2773071a87cbcedc95dc112aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get_dup&lt;/code&gt; method assists in reading duplicate values from BTREE databases. The method can take the following forms:</source>
          <target state="translated">&lt;code&gt;get_dup&lt;/code&gt; BTREEデータベースから重複した値を読んで方法を支援。このメソッドは次の形式を取ることができます。</target>
        </trans-unit>
        <trans-unit id="7ea986ecd3305b94f4546f1c6e3ce692488dd0fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopt()&lt;/code&gt; function is similar, but its argument is a string containing all switches that take an argument. If no argument is provided for a switch, say, &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, the corresponding &lt;code&gt;$opt_y&lt;/code&gt; will be set to an undefined value. Unspecified switches are silently accepted. Use of &lt;code&gt;getopt()&lt;/code&gt; is not recommended.</source>
          <target state="translated">&lt;code&gt;getopt()&lt;/code&gt; 関数は、類似しているが、その引数は、引数を取る全てのスイッチを含む文字列です。スイッチに引数が指定されていない場合、たとえば &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; の場合、対応する &lt;code&gt;$opt_y&lt;/code&gt; は未定義の値に設定されます。未指定のスイッチは黙って受け入れられます。 &lt;code&gt;getopt()&lt;/code&gt; の使用は推奨されません。</target>
        </trans-unit>
        <trans-unit id="c037451f79364fbd043155e0ffbbe91d2a70fbad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopts()&lt;/code&gt; function processes single-character switches with switch clustering. Pass one argument which is a string containing all switches to be recognized. For each switch found, if an argument is expected and provided, &lt;code&gt;getopts()&lt;/code&gt; sets &lt;code&gt;$opt_x&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is the switch name) to the value of the argument. If an argument is expected but none is provided, &lt;code&gt;$opt_x&lt;/code&gt; is set to an undefined value. If a switch does not take an argument, &lt;code&gt;$opt_x&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;getopts()&lt;/code&gt; 関数は、スイッチクラスタリングを有する単一文字のスイッチを処理します。認識されるすべてのスイッチを含む文字列である1つの引数を渡します。見つかった各スイッチについて、引数が予期されて提供されている場合、 &lt;code&gt;getopts()&lt;/code&gt; は &lt;code&gt;$opt_x&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; はスイッチ名）を引数の値に設定します。引数が期待されているが提供されていない場合、 &lt;code&gt;$opt_x&lt;/code&gt; は未定義の値に設定されます。スイッチが引数を取らない場合、 &lt;code&gt;$opt_x&lt;/code&gt; は &lt;code&gt;1&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="fe182c59e721bf2edc44a9253eded06fe11c1a8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopts()&lt;/code&gt; function returns true unless an invalid option was found.</source>
          <target state="translated">&lt;code&gt;getopts()&lt;/code&gt; 無効なオプションが見つかった場合を除き関数はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="688985f64d8825090cd98452194bcbd67a98423b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grammar_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;grammar_class&lt;/code&gt; はで説明したように、カスタマイズすることができる&lt;a href=&quot;#new&quot;&gt;新しいです&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="361db5e35a8a030899f4185a6ca897ccf88b2984" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;h&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; formats pack a string that many nybbles (4-bit groups, representable as hexadecimal digits, &lt;code&gt;&quot;0&quot;..&quot;9&quot;&lt;/code&gt;&lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; ) long.</source>
          <target state="translated">&lt;code&gt;h&lt;/code&gt; 及び &lt;code&gt;H&lt;/code&gt; フォーマットでは、文字列をパック多くのニブル（16進数として表現4ビットのグループ、 &lt;code&gt;&quot;0&quot;..&quot;9&quot;&lt;/code&gt; &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; ）長いです。</target>
        </trans-unit>
        <trans-unit id="52b0ba82d51f8c56aed17fcdac89e94cd7a38305" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has()&lt;/code&gt; subroutine declares an attribute, and &lt;code&gt;Moose&lt;/code&gt; automatically creates accessors for these attributes. It also takes care of creating a &lt;code&gt;new()&lt;/code&gt; method for you. This constructor knows about the attributes you declared, so you can set them when creating a new &lt;code&gt;File&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;has()&lt;/code&gt; サブルーチンは、属性を宣言し、 &lt;code&gt;Moose&lt;/code&gt; 自動的にこれらの属性のアクセサを作成します。また、 &lt;code&gt;new()&lt;/code&gt; メソッドの作成も行います。このコンストラクターは宣言した属性を認識しているため、新しい &lt;code&gt;File&lt;/code&gt; を作成するときにそれらを設定できます。</target>
        </trans-unit>
        <trans-unit id="5a9683174ca55dfc5709630b38ddbf4013af69ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i!&lt;/code&gt; and &lt;code&gt;I!&lt;/code&gt; codes aren't different from &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt; ; they are tolerated for completeness' sake.</source>
          <target state="translated">&lt;code&gt;i!&lt;/code&gt; そして &lt;code&gt;I!&lt;/code&gt; コードは &lt;code&gt;i&lt;/code&gt; や &lt;code&gt;I&lt;/code&gt; と変わりません。完全を期すために許容されます。</target>
        </trans-unit>
        <trans-unit id="441288d51b032bd9af407d3a9d7124153bae7480" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id()&lt;/code&gt; function is incorporated in</source>
          <target state="translated">&lt;code&gt;id()&lt;/code&gt; 関数に組み込まれています</target>
        </trans-unit>
        <trans-unit id="5b77bbf33fef07ab4b901464b3d1fbf57256a9cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id()&lt;/code&gt; function is provided in addition to the existing &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; . Besides its short name it can be a little faster under some circumstances (and a bit slower under others). Benchmark if it matters. The working of &lt;code&gt;id()&lt;/code&gt; also allows the use of the class name as a</source>
          <target state="translated">&lt;code&gt;id()&lt;/code&gt; 関数は、既存のに加えて提供される &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; 。その短い名前に加えて、状況によっては少し速くなる場合があります（他の状況では少し遅くなります）。重要な場合はベンチマーク。作業 &lt;code&gt;id()&lt;/code&gt; としても、クラス名を使用できます</target>
        </trans-unit>
        <trans-unit id="1d508e8165fd2906f6e1a4da8eddef354ad1b2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; module is used to conditionally load or unload another module. The construct</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; モジュールは、条件付きで他のモジュールをロードまたはアンロードするために使用されます。構成</target>
        </trans-unit>
        <trans-unit id="4b048e8a441fb17f85efa08c37a67df6bc5d9c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is straightforward. Because BLOCKs are always bounded by curly brackets, there is never any ambiguity about which &lt;code&gt;if&lt;/code&gt; an &lt;code&gt;else&lt;/code&gt; goes with. If you use &lt;code&gt;unless&lt;/code&gt; in place of &lt;code&gt;if&lt;/code&gt; , the sense of the test is reversed. Like &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;unless&lt;/code&gt; can be followed by &lt;code&gt;else&lt;/code&gt; . &lt;code&gt;unless&lt;/code&gt; can even be followed by one or more &lt;code&gt;elsif&lt;/code&gt; statements, though you may want to think twice before using that particular language construct, as everyone reading your code will have to think at least twice before they can understand what's going on.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 文は簡単です。 BLOCKは常に中かっこで囲まれているため、 &lt;code&gt;else&lt;/code&gt; が使用される &lt;code&gt;if&lt;/code&gt; あいまいさはありません。 ifの代わりに使用し &lt;code&gt;unless&lt;/code&gt; &lt;code&gt;if&lt;/code&gt; 、テストの意味が逆になります。同様に &lt;code&gt;if&lt;/code&gt; 、 &lt;code&gt;unless&lt;/code&gt; 続けることができ &lt;code&gt;else&lt;/code&gt; 。1つ以上の &lt;code&gt;elsif&lt;/code&gt; ステートメントを続けることができ &lt;code&gt;unless&lt;/code&gt; て、特定の言語構成を使用する前に2度考えた方がよいかもしれません。コードを読んでいるすべての人は、何が起こっているのかを理解する前に少なくとも2度考えなければならないからです。</target>
        </trans-unit>
        <trans-unit id="e9f3b671cb1eeb07ae7f1604035f9acb4eeee7c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ihave&lt;/code&gt; command informs the server that the client has an article whose id is &lt;code&gt;MSGID&lt;/code&gt; . If the server desires a copy of that article, and &lt;code&gt;MESSAGE&lt;/code&gt; has been given the it will be sent.</source>
          <target state="translated">&lt;code&gt;ihave&lt;/code&gt; コマンドは、クライアントがIDです記事持っていることをサーバーに通知 &lt;code&gt;MSGID&lt;/code&gt; を。サーバーがその記事のコピーを希望し、 &lt;code&gt;MESSAGE&lt;/code&gt; が提供されている場合は、それが送信されます。</target>
        </trans-unit>
        <trans-unit id="31aa9addcda21b8978ff9bf041daba569f826e41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;io&lt;/code&gt; options mean that any subsequent open() (or similar I/O operations) in the current file scope will have the &lt;code&gt;:utf8&lt;/code&gt; PerlIO layer implicitly applied to them, in other words, UTF-8 is expected from any input stream, and UTF-8 is produced to any output stream. This is just the default, with explicit layers in open() and with binmode() one can manipulate streams as usual.</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; オプションは、現在のファイルスコープ内の任意）（オープン後続の（または類似のI / O操作が）を有するであろうことを意味 &lt;code&gt;:utf8&lt;/code&gt; PerlIOを層は暗黙UTF-8は、任意の入力ストリームから期待される、換言すれば、それらに適用される、及びUTF-8は任意の出力ストリームに生成されます。これは単なるデフォルトであり、open（）に明示的なレイヤーがあり、binmode（）を使用すると、通常どおりストリームを操作できます。</target>
        </trans-unit>
        <trans-unit id="ea8cc24a093a2a51529b8db29000183dfdfc585d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isa&lt;/code&gt; method returns</source>
          <target state="translated">&lt;code&gt;isa&lt;/code&gt; メソッドが返します</target>
        </trans-unit>
        <trans-unit id="40b75cea7c9c256a2c7f367ec1f2a28305318646" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;klen&lt;/code&gt; parameter is the length of the key being passed in (Note that you cannot pass 0 in as a value of &lt;code&gt;klen&lt;/code&gt; to tell Perl to measure the length of the key). The &lt;code&gt;val&lt;/code&gt; argument contains the SV pointer to the scalar being stored, and &lt;code&gt;hash&lt;/code&gt; is the precomputed hash value (zero if you want &lt;code&gt;hv_store&lt;/code&gt; to calculate it for you). The &lt;code&gt;lval&lt;/code&gt; parameter indicates whether this fetch is actually a part of a store operation, in which case a new undefined value will be added to the HV with the supplied key and &lt;code&gt;hv_fetch&lt;/code&gt; will return as if the value had already existed.</source>
          <target state="translated">&lt;code&gt;klen&lt;/code&gt; パラメータは、（あなたがの値として0を渡すことができないことに注意してくださいに渡される鍵の長さである &lt;code&gt;klen&lt;/code&gt; キーの長さを測定するためにPerlを指示します）。 &lt;code&gt;val&lt;/code&gt; の引数は、スカラへのSVポインタが格納されている含まれており、 &lt;code&gt;hash&lt;/code&gt; （あなたがしたい場合は、ゼロ事前に計算されたハッシュ値である &lt;code&gt;hv_store&lt;/code&gt; があなたのためにそれを計算します）。 &lt;code&gt;lval&lt;/code&gt; パラメータは、これが実際に新しい未定義の値が供給鍵とを用いてHVに追加される場合に、ストア動作の一部であるかどうかを示すフェッチ &lt;code&gt;hv_fetch&lt;/code&gt; 値が既に存在していたかのように戻ります。</target>
        </trans-unit>
        <trans-unit id="d1b3be6dbaf0292e629ff79d5077e6e86e950020" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line numbers&lt;/code&gt; are a comma separated list of line numbers (some preceded by code letters) where that object is used in some way. Simple uses aren't preceded by a code letter. Introductions (such as where a lexical is first defined with &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;) are indicated with the letter &quot;i&quot;. Subroutine and method calls are indicated by the character &quot;&amp;amp;&quot;. Subroutine definitions are indicated by &quot;s&quot; and format definitions by &quot;f&quot;.</source>
          <target state="translated">&lt;code&gt;line numbers&lt;/code&gt; 、そのオブジェクトが何らかの方法で使用される行番号（いくつかはコード文字によって先行）のカンマ区切りのリストです。簡単な使い方の前にコードレターはありません。イントロダクション（語彙が &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; で最初に定義される場所など）は、文字「i」で示されます。サブルーチンとメソッドの呼び出しは、文字「＆」で示されます。サブルーチン定義は「s」で、フォーマット定義は「f」で示します。</target>
        </trans-unit>
        <trans-unit id="ed26c2274a611c42add606638c2955102446922f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_nstore&lt;/code&gt; routine are equivalent to &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;nstore&lt;/code&gt; , except that they get an exclusive lock on the file before writing. Likewise, &lt;code&gt;lock_retrieve&lt;/code&gt; does the same as &lt;code&gt;retrieve&lt;/code&gt; , but also gets a shared lock on the file before reading.</source>
          <target state="translated">&lt;code&gt;lock_store&lt;/code&gt; と &lt;code&gt;lock_nstore&lt;/code&gt; ルーチンに相当している &lt;code&gt;store&lt;/code&gt; と &lt;code&gt;nstore&lt;/code&gt; 彼らは書き込み前に、ファイルに排他ロックを取得することを除いて、。同様に、 &lt;code&gt;lock_retrieve&lt;/code&gt; は &lt;code&gt;retrieve&lt;/code&gt; と同じですが、読み取る前にファイルの共有ロックも取得します。</target>
        </trans-unit>
        <trans-unit id="931b71dd87fea82969167ed5b3226571750cd592" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mail&lt;/code&gt; method can some additional ESMTP OPTIONS which is passed in hash like fashion, using key and value pairs. Possible options are:</source>
          <target state="translated">&lt;code&gt;mail&lt;/code&gt; 方法は、いくつかの追加のESMTPオプションのキーと値のペアを使用して、ハッシュ形式で渡される可能性があります。可能なオプションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="1672385883542a7bfdb246cc1c07640a71a68feb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make&lt;/code&gt; and &lt;code&gt;emake&lt;/code&gt; accept both real and complex arguments. When they cannot recognize the arguments they will die with error messages like the following</source>
          <target state="translated">&lt;code&gt;make&lt;/code&gt; と &lt;code&gt;emake&lt;/code&gt; は両方の実数と複素数の引数を取ります。引数を認識できない場合、次のようなエラーメッセージが表示されて死亡します。</target>
        </trans-unit>
        <trans-unit id="36df2e300d21e511804bebffd14eb9e7ae60ac30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make_path&lt;/code&gt; function creates the given directories if they don't exists before, much like the Unix command &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt; -p&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;make_path&lt;/code&gt; の彼らは以前に存在していない場合、この関数は、多くのUnixコマンドのように、与えられたディレクトリを作成し &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt; -p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="072d415ade3aa9a1737c770e2e53b08afe60d304" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;match&lt;/code&gt; , &lt;code&gt;gmatch&lt;/code&gt; , &lt;code&gt;subst&lt;/code&gt; , &lt;code&gt;gsubst&lt;/code&gt; methods work like &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt;, respectively, but they are not aware of any pattern, but only a literal substring.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 、 &lt;code&gt;gmatch&lt;/code&gt; 、 &lt;code&gt;subst&lt;/code&gt; 、 &lt;code&gt;gsubst&lt;/code&gt; 方法の作業のような &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; 、それぞれ、それらは任意のパターンを認識していないが、唯一のリテラルのストリング。</target>
        </trans-unit>
        <trans-unit id="ece173d4e6c78d6e5935815075ac81cc7c62a227" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;memory&lt;/code&gt; value is not an absolute or exact limit on the memory used. &lt;code&gt;Tie::File&lt;/code&gt; objects contains some structures besides the read cache and the deferred write buffer, whose sizes are not charged against &lt;code&gt;memory&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;memory&lt;/code&gt; 値が使用されるメモリ上の絶対または正確制限はありません。 &lt;code&gt;Tie::File&lt;/code&gt; オブジェクトには、読み取りキャッシュと据え置き書き込みバッファーのほかに、サイズが &lt;code&gt;memory&lt;/code&gt; に対して課金されない構造体がいくつか含まれています。</target>
        </trans-unit>
        <trans-unit id="19d121e9a361d9d72576c01fa16affeece8189c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mg_virtual&lt;/code&gt; field in the &lt;code&gt;MAGIC&lt;/code&gt; structure is a pointer to an &lt;code&gt;MGVTBL&lt;/code&gt; , which is a structure of function pointers and stands for &quot;Magic Virtual Table&quot; to handle the various operations that might be applied to that variable.</source>
          <target state="translated">&lt;code&gt;MAGIC&lt;/code&gt; 構造体の &lt;code&gt;mg_virtual&lt;/code&gt; フィールドは、関数ポインターの構造体である &lt;code&gt;MGVTBL&lt;/code&gt; へのポインターであり、その変数に適用される可能性のあるさまざまな操作を処理するための「マジック仮想テーブル」を表しています。</target>
        </trans-unit>
        <trans-unit id="a5023c90eb5f90ef422233e2dd5d44f7824eab24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; related one will be matched against</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; に関連するものが照合されます</target>
        </trans-unit>
        <trans-unit id="47efd6577f009e8c4308e174f5b14a11ddfaec14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;move&lt;/code&gt; function also takes two parameters: the current name and the intended name of the file to be moved. If the destination already exists and is a directory, and the source is not a directory, then the source file will be renamed into the directory specified by the destination.</source>
          <target state="translated">&lt;code&gt;move&lt;/code&gt; 機能は、2つのパラメータを取ります：現在の名前とファイルの意図した名前が移動します。宛先がすでに存在し、ディレクトリであり、ソースがディレクトリでない場合、ソースファイルは宛先で指定されたディレクトリに名前変更されます。</target>
        </trans-unit>
        <trans-unit id="82300ffe8ea8c4a83935f63ac88aba05d079a68e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;namlen&lt;/code&gt; arguments are used to associate a string with the magic, typically the name of a variable. &lt;code&gt;namlen&lt;/code&gt; is stored in the &lt;code&gt;mg_len&lt;/code&gt; field and if &lt;code&gt;name&lt;/code&gt; is non-null then either a &lt;code&gt;savepvn&lt;/code&gt; copy of &lt;code&gt;name&lt;/code&gt; or &lt;code&gt;name&lt;/code&gt; itself is stored in the &lt;code&gt;mg_ptr&lt;/code&gt; field, depending on whether &lt;code&gt;namlen&lt;/code&gt; is greater than zero or equal to zero respectively. As a special case, if &lt;code&gt;(name &amp;amp;&amp;amp; namlen == HEf_SVKEY)&lt;/code&gt; then &lt;code&gt;name&lt;/code&gt; is assumed to contain an &lt;code&gt;SV*&lt;/code&gt; and is stored as-is with its REFCNT incremented.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; と &lt;code&gt;namlen&lt;/code&gt; 引数は魔法の文字列、変数の一般的に名前を関連付けるために使用されています。 &lt;code&gt;namlen&lt;/code&gt; に格納され &lt;code&gt;mg_len&lt;/code&gt; フィールドとIF &lt;code&gt;name&lt;/code&gt; その後のいずれかで非ヌルである &lt;code&gt;savepvn&lt;/code&gt; のコピー &lt;code&gt;name&lt;/code&gt; または &lt;code&gt;name&lt;/code&gt; 自体に記憶されている &lt;code&gt;mg_ptr&lt;/code&gt; かどうかに応じて、フィールド &lt;code&gt;namlen&lt;/code&gt; がゼロまたはそれぞれゼロよりも大きいです。特殊なケースとして、 &lt;code&gt;(name &amp;amp;&amp;amp; namlen == HEf_SVKEY)&lt;/code&gt; 場合、 &lt;code&gt;name&lt;/code&gt; は &lt;code&gt;SV*&lt;/code&gt; を含むと見なされ、そのままREFCNTがインクリメントされて格納されます。</target>
        </trans-unit>
        <trans-unit id="30007f38d6317a12ba00ec6e0a7e1a8a5a903fc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; will also understand a single (string) argument of the forms</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 、 &lt;code&gt;make&lt;/code&gt; 、 &lt;code&gt;emake&lt;/code&gt; 、 &lt;code&gt;cplx&lt;/code&gt; 、および &lt;code&gt;cplxe&lt;/code&gt; はまた、フォームのシングル（文字列）の引数を理解します</target>
        </trans-unit>
        <trans-unit id="ed69370147fad222f299ba19e375b2bf7b98be5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; will also understand the case of no arguments: this means plain zero or (0, 0).</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 、 &lt;code&gt;make&lt;/code&gt; 、 &lt;code&gt;emake&lt;/code&gt; は、 &lt;code&gt;cplx&lt;/code&gt; 、および &lt;code&gt;cplxe&lt;/code&gt; は、この手段プレーンゼロか（0、0）：また、引数なしの場合を理解します。</target>
        </trans-unit>
        <trans-unit id="99af811bc283e732950a12fee28684ae132d20bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; method returns a collator object. If new() is called with no parameters, the collator should do the default collation.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; メソッドは、コレータオブジェクトを返します。パラメータなしでnew（）が呼び出された場合、照合はデフォルトの照合を行う必要があります。</target>
        </trans-unit>
        <trans-unit id="ebe7378b188460d4f95907a0bf8fffd8170aa799" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nntpstat&lt;/code&gt; command is similar to the &lt;code&gt;article&lt;/code&gt; command except that no text is returned. When selecting by message number within a group, the &lt;code&gt;nntpstat&lt;/code&gt; command serves to set the &quot;current article pointer&quot; without sending text.</source>
          <target state="translated">&lt;code&gt;nntpstat&lt;/code&gt; コマンドは次のようにある &lt;code&gt;article&lt;/code&gt; テキストが返されないことを除いてコマンド。グループ内のメッセージ番号で選択する場合、 &lt;code&gt;nntpstat&lt;/code&gt; コマンドは、テキストを送信せずに「現在の記事のポインター」を設定します。</target>
        </trans-unit>
        <trans-unit id="9a9f846f976939c6373f157aacddb5340df46521" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;notest&lt;/code&gt; pragma skips the test part in the build process.</source>
          <target state="translated">&lt;code&gt;notest&lt;/code&gt; プラグマは、ビルドプロセスのテスト部分をスキップします。</target>
        </trans-unit>
        <trans-unit id="402cbf532fb5078e8455cec160e9e8dbd08504b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nvsize&lt;/code&gt; element is only present for file format v2.2 and higher.</source>
          <target state="translated">&lt;code&gt;nvsize&lt;/code&gt; の要素は、ファイル形式v2.2と高いためにのみ存在しています。</target>
        </trans-unit>
        <trans-unit id="c6ccaa6545aa4fe6352eb7229eabe18e5414aa4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o conf&lt;/code&gt; command has various bells and whistles:</source>
          <target state="translated">&lt;code&gt;o conf&lt;/code&gt; コマンドは、様々な添えものを持っています</target>
        </trans-unit>
        <trans-unit id="e1d6fb5846e3f0194a9a7d71677ca6c483145c33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o?&lt;/code&gt; matches at the beginning of &lt;code&gt;'foo'&lt;/code&gt; , and since the position in the string is not moved by the match, &lt;code&gt;o?&lt;/code&gt; would match again and again because of the &lt;code&gt;*&lt;/code&gt; quantifier. Another common way to create a similar cycle is with the looping modifier &lt;code&gt;//g&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;o?&lt;/code&gt; &lt;code&gt;'foo'&lt;/code&gt; の先頭で一致し、文字列内の位置は一致によって移動されないため、 &lt;code&gt;o?&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; 数量詞のため、何度も一致します。同様のサイクルを作成するもう1つの一般的な方法は、ループ修飾子 &lt;code&gt;//g&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="8add6c5a9ee20cf8238a46e09a0cd46fe0b061c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obj&lt;/code&gt; argument is stored in the &lt;code&gt;mg_obj&lt;/code&gt; field of the &lt;code&gt;MAGIC&lt;/code&gt; structure. If it is not the same as the &lt;code&gt;sv&lt;/code&gt; argument, the reference count of the &lt;code&gt;obj&lt;/code&gt; object is incremented. If it is the same, or if the &lt;code&gt;how&lt;/code&gt; argument is &lt;code&gt;PERL_MAGIC_arylen&lt;/code&gt; , or if it is a NULL pointer, then &lt;code&gt;obj&lt;/code&gt; is merely stored, without the reference count being incremented.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 引数はに格納され &lt;code&gt;mg_obj&lt;/code&gt; の分野 &lt;code&gt;MAGIC&lt;/code&gt; の構造。引数 &lt;code&gt;sv&lt;/code&gt; と同じでない場合、 &lt;code&gt;obj&lt;/code&gt; オブジェクトの参照カウントが増分されます。同じである場合、または &lt;code&gt;how&lt;/code&gt; 引数が &lt;code&gt;PERL_MAGIC_arylen&lt;/code&gt; である場合、またはNULLポインターである場合、 &lt;code&gt;obj&lt;/code&gt; は、参照カウントがインクリメントされることなく、単に格納されます。</target>
        </trans-unit>
        <trans-unit id="d80e9ad5ac5b4640a379da6ded2e4e7da8ef85d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op-entry&lt;/code&gt; , &lt;code&gt;loading-file&lt;/code&gt; , and &lt;code&gt;loaded-file&lt;/code&gt; probes were added.</source>
          <target state="translated">&lt;code&gt;op-entry&lt;/code&gt; 、 &lt;code&gt;loading-file&lt;/code&gt; 、および &lt;code&gt;loaded-file&lt;/code&gt; のプローブを添加しました。</target>
        </trans-unit>
        <trans-unit id="2f6e73c286e870319f1bf5046f6a37ff92d8c6ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;overloading&lt;/code&gt; pragma can be used to enable or disable overloaded operations within a lexical scope - see &lt;a href=&quot;overloading&quot;&gt;overloading&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;overloading&lt;/code&gt; を参照-プラグマはレキシカルスコープ内オーバー操作を有効または無効にするために使用することができる&lt;a href=&quot;overloading&quot;&gt;過負荷します&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22d5bf30a5d50f38a10cfc2d7578244917da917c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats should be used with care. Since Perl has no way of checking whether the value passed to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; corresponds to a valid memory location, passing a pointer value that's not known to be valid is likely to have disastrous consequences.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; および &lt;code&gt;P&lt;/code&gt; フォーマットは注意して使用する必要があります。 Perlには、 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; に渡された値が有効なメモリ位置に対応するかどうかをチェックする方法がないため、有効であることがわかっていないポインター値を渡すと、悲惨な結果になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="edad35170db1a049ca495222b3c0b5b8c415db1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats should be used with care. Since Perl has no way of checking whether the value passed to &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; corresponds to a valid memory location, passing a pointer value that's not known to be valid is likely to have disastrous consequences.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; および &lt;code&gt;P&lt;/code&gt; フォーマットは注意して使用する必要があります。 Perlには、 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; に渡された値が有効なメモリ位置に対応するかどうかをチェックする方法がないため、有効であることがわかっていないポインター値を渡すと、悲惨な結果になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a342dbe90eb2666a6875f71f1fa1cb3e6e7241a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; format packs a pointer to a null-terminated string. You are responsible for ensuring that the string is not a temporary value, as that could potentially get deallocated before you got around to using the packed result. The &lt;code&gt;P&lt;/code&gt; format packs a pointer to a structure of the size indicated by the length. A null pointer is created if the corresponding value for &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;; similarly with unpack(), where a null pointer unpacks into &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 個のフォーマットは、NULLで終わる文字列へのポインタをパックします。文字列が一時的な値ではないことを確認する必要があります。パックされた結果を使用する前に、割り当てが解除される可能性があります。 &lt;code&gt;P&lt;/code&gt; のフォーマットは、長さによって示されたサイズの構造体へのポインタをパック。 &lt;code&gt;p&lt;/code&gt; または &lt;code&gt;P&lt;/code&gt; の対応する値が &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; の場合、nullポインターが作成されます。unpack（）と同様に、nullポインタが &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; にアンパックします。</target>
        </trans-unit>
        <trans-unit id="e2e0e3d979b5c34967b7ced67a74a5510cb236cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; format packs a pointer to a null-terminated string. You are responsible for ensuring that the string is not a temporary value, as that could potentially get deallocated before you got around to using the packed result. The &lt;code&gt;P&lt;/code&gt; format packs a pointer to a structure of the size indicated by the length. A null pointer is created if the corresponding value for &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;; similarly with unpack(), where a null pointer unpacks into &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 個のフォーマットは、NULLで終わる文字列へのポインタをパックします。文字列が一時的な値ではないことを確認する必要があります。パックされた結果を使用する前に、割り当てが解除される可能性があります。 &lt;code&gt;P&lt;/code&gt; のフォーマットは、長さによって示されたサイズの構造体へのポインタをパック。 &lt;code&gt;p&lt;/code&gt; または &lt;code&gt;P&lt;/code&gt; の対応する値が &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; の場合、nullポインターが作成されます。unpack（）と同様に、nullポインタが &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; にアンパックします。</target>
        </trans-unit>
        <trans-unit id="6cd57772719120a4cc44e7170b8984f064c5142a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;paren&lt;/code&gt; parameter will be &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; for &lt;code&gt;$2&lt;/code&gt; and so forth, and have these symbolic values for the special variables:</source>
          <target state="translated">&lt;code&gt;paren&lt;/code&gt; のパラメータは次のようになります &lt;code&gt;1&lt;/code&gt; のための &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;2&lt;/code&gt; のための &lt;code&gt;$2&lt;/code&gt; など、および特殊変数のためにこれらの記号の値を持っています：</target>
        </trans-unit>
        <trans-unit id="49927bc872809a6862bb2b73a995c90fcc3d0b9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; parameter is the scalar that was used as the pattern. Previous versions of Perl would pass two &lt;code&gt;char*&lt;/code&gt; indicating the start and end of the stringified pattern; the following snippet can be used to get the old parameters:</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; パラメータは、パターンとして使用したスカラーです。以前のバージョンのPerlは、文字列化されたパターンの開始と終了を示す2つの &lt;code&gt;char*&lt;/code&gt; を渡していました。次のスニペットを使用して、古いパラメーターを取得できます。</target>
        </trans-unit>
        <trans-unit id="db17bf3bf687b24a2fdb5945dac7eff0732c46a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perl&lt;/code&gt; related one will be matched against &lt;code&gt;$^X&lt;/code&gt; (but with the absolute path).</source>
          <target state="translated">&lt;code&gt;perl&lt;/code&gt; の関係する1つが照合されます &lt;code&gt;$^X&lt;/code&gt; （ただし、絶対パス付き）。</target>
        </trans-unit>
        <trans-unit id="5f5ee6756d1fcb64032b91cf7b890baca1e81e1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perl_alloc&lt;/code&gt; and &lt;code&gt;perl_clone&lt;/code&gt; API functions will automatically set the TLS slot to the interpreter they created, so that there is no need to do anything special if the interpreter is always accessed in the same thread that created it, and that thread did not create or call any other interpreters afterwards. If that is not the case, you have to set the TLS slot of the thread before calling any functions in the Perl API on that particular interpreter. This is done by calling the &lt;code&gt;PERL_SET_CONTEXT&lt;/code&gt; macro in that thread as the first thing you do:</source>
          <target state="translated">&lt;code&gt;perl_alloc&lt;/code&gt; と &lt;code&gt;perl_clone&lt;/code&gt; API関数は、自動的にインタプリタが常にそれを作成した同じスレッドにアクセスされた場合は何も特別な操作を行うために必要がないように、それらが作成インタプリタにTLSスロットを設定し、そのスレッドを作成したり、コールしませんでしたその後の他の通訳。そうでない場合は、その特定のインタープリターでPerl APIの関数を呼び出す前に、スレッドのTLSスロットを設定する必要があります。これを行うには、最初に、そのスレッドで &lt;code&gt;PERL_SET_CONTEXT&lt;/code&gt; マクロを呼び出します。</target>
        </trans-unit>
        <trans-unit id="97a02a3c258cf1103ffa6170e07625f674c4d40e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perldoc&lt;/code&gt; command line tool is part of the standard Perl distribution. To read the perlfaq:</source>
          <target state="translated">&lt;code&gt;perldoc&lt;/code&gt; コマンドラインツールは、標準のPerl配布の一部です。perlfaqを読むには：</target>
        </trans-unit>
        <trans-unit id="50ad124de63dc48f75c0f2545fa281fab8aa3db8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phase-change&lt;/code&gt; probe was added.</source>
          <target state="translated">&lt;code&gt;phase-change&lt;/code&gt; プローブが追加されました。</target>
        </trans-unit>
        <trans-unit id="04bb003d93ac0037aab6a2f453c58a6ac0c41912" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;plugin_list&lt;/code&gt; configuration parameter holds a list of strings of the form</source>
          <target state="translated">&lt;code&gt;plugin_list&lt;/code&gt; 設定パラメータは、次の形式の文字列のリストを保持しています</target>
        </trans-unit>
        <trans-unit id="a63eacc1cc33a9d0218e84fb4e04a60cb849a989" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pp_tie&lt;/code&gt; does a &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; , then starts a second runops loop to execute the body of &lt;code&gt;TIEARRAY&lt;/code&gt; . When it executes the entertry op on line 3, &lt;code&gt;CATCH_GET&lt;/code&gt; is true, so &lt;code&gt;pp_entertry&lt;/code&gt; calls &lt;code&gt;docatch&lt;/code&gt; which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and starts a third runops loop, which then executes the die op. At this point the C call stack looks like this:</source>
          <target state="translated">&lt;code&gt;pp_tie&lt;/code&gt; はない &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; 、その後のボディ実行する第runopsループを開始 &lt;code&gt;TIEARRAY&lt;/code&gt; を。それはライン3にentertry OPを実行すると、 &lt;code&gt;CATCH_GET&lt;/code&gt; は真であり、そう &lt;code&gt;pp_entertry&lt;/code&gt; は呼び出し &lt;code&gt;docatch&lt;/code&gt; し &lt;code&gt;JMPENV_PUSH&lt;/code&gt; を、次いでダイ演算を実行する第runopsループを開始します。この時点で、Cコールスタックは次のようになります。</target>
        </trans-unit>
        <trans-unit id="6f6012284b93fc2045dcbcea769da43a4a9d853f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prompt()&lt;/code&gt; function provides an easy way to request user input used to write a makefile. It displays the $message as a prompt for input. If a $default is provided it will be used as a default. The function returns the $value selected by the user.</source>
          <target state="translated">&lt;code&gt;prompt()&lt;/code&gt; 関数は、メイクファイルを書き込むために使用される要求のユーザ入力に簡単な方法を提供します。入力のプロンプトとして$ messageを表示します。$ defaultが指定されている場合、それがデフォルトとして使用されます。この関数は、ユーザーが選択した$ valueを返します。</target>
        </trans-unit>
        <trans-unit id="251a318ac7ae399ceb208b84bc39666205a2a077" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module encapsulates the results for a single test suite run.</source>
          <target state="translated">&lt;code&gt;prove&lt;/code&gt; コマンドがサポートされてい &lt;code&gt;--state&lt;/code&gt; それが実行間の永続的な状態を保存するように指示するオプションを選択します。このモジュールは、単一のテストスイート実行の結果をカプセル化します。</target>
        </trans-unit>
        <trans-unit id="225b0b123ca124089a53e65a14a10e06fffd421b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module encapsulates the results for a single test.</source>
          <target state="translated">&lt;code&gt;prove&lt;/code&gt; コマンドがサポートされてい &lt;code&gt;--state&lt;/code&gt; それが実行間の永続的な状態を保存するように指示するオプションを選択します。このモジュールは、単一のテストの結果をカプセル化します。</target>
        </trans-unit>
        <trans-unit id="630214733172c835a26947747354eba32ad3911c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module implements that state and the operations that may be performed on it.</source>
          <target state="translated">&lt;code&gt;prove&lt;/code&gt; コマンドがサポートされてい &lt;code&gt;--state&lt;/code&gt; それが実行間の永続的な状態を保存するように指示するオプションを選択します。このモジュールは、その状態と、その状態で実行される可能性のある操作を実装します。</target>
        </trans-unit>
        <trans-unit id="16ee1aae608f6953af89e472ae38b6d9068b7d8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;re '/flags'&lt;/code&gt; pragma (introduced in Perl 5.14) turns on the given regular expression flags until the end of the lexical scope. See &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;'/flags' mode in re&lt;/a&gt; for more detail.</source>
          <target state="translated">&lt;code&gt;re '/flags'&lt;/code&gt; （Perlの5.14で導入）プラグマはレキシカルスコープの終わりまで与えられた正規表現フラグをオンにします。詳細については、&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;「/ flags」モードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="eabbdc8a005d2bf3f21650b9e863366189c7ced7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recent&lt;/code&gt; command downloads a list of recent uploads to CPAN and displays them</source>
          <target state="translated">&lt;code&gt;recent&lt;/code&gt; コマンドはCPANと表示し、それらに最近アップロードのリストをダウンロード</target>
        </trans-unit>
        <trans-unit id="3ae27e036bb44d621cb68002f9a110e07c700371" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recipient&lt;/code&gt; method can also pass additional case-sensitive OPTIONS as an anonymous hash using key and value pairs. Possible options are:</source>
          <target state="translated">&lt;code&gt;recipient&lt;/code&gt; 方法はまた、キーと値のペアを使用して、匿名のハッシュなどの追加の大文字と小文字を区別オプションを渡すことができます。可能なオプションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5f6b672315250ddc806f0b1d734bf40a266a6de9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is common to all regex engines. Two of its fields are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and pprivate members. The &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values. In the case of the stock engine the structure pointed to by &lt;code&gt;pprivate&lt;/code&gt; is called &lt;code&gt;regexp_internal&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;regexp&lt;/code&gt; で説明した構造&lt;a href=&quot;perlreapi&quot;&gt;perlreapiは&lt;/a&gt;すべて正規表現エンジンに共通しています。その2つのフィールドは、パターンをコンパイルした正規表現エンジンの私的使用を目的としています。これらは &lt;code&gt;intflags&lt;/code&gt; とpprivateメンバーです。 &lt;code&gt;pprivate&lt;/code&gt; は、使用及び管理コンパイルエンジンの責務である任意の構造にボイドのポインタです。 perlがこれらの値を変更することはありません。ストックエンジンの場合、 &lt;code&gt;pprivate&lt;/code&gt; が指す構造はregexp_internalと呼ばれ &lt;code&gt;regexp_internal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2292ba9ae057df1902ceef2446c66c533b62b3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;remove_tree&lt;/code&gt; function deletes the given directories and any files and subdirectories they might contain, much like the Unix command &lt;code&gt;rm -r&lt;/code&gt; or &lt;code&gt;del /s&lt;/code&gt; on Windows.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; 関数は、指定したディレクトリと多くのUnixコマンドのように、彼らが含まれている可能性のあるすべてのファイルとサブディレクトリ、削除 &lt;code&gt;rm -r&lt;/code&gt; または &lt;code&gt;del /s&lt;/code&gt; Windows上を。</target>
        </trans-unit>
        <trans-unit id="f800b61fba3cbdc9dbaf2d3127156f3c10c2be33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;report&lt;/code&gt; command temporarily turns on the &lt;code&gt;test_report&lt;/code&gt; config variable, then runs the &lt;code&gt;force test&lt;/code&gt; command with the given arguments. The &lt;code&gt;force&lt;/code&gt; pragma reruns the tests and repeats every step that might have failed before.</source>
          <target state="translated">&lt;code&gt;report&lt;/code&gt; コマンドは、一時的にオンに &lt;code&gt;test_report&lt;/code&gt; の設定変数、そして走る &lt;code&gt;force test&lt;/code&gt; 与えられた引数を指定して、コマンドを。 &lt;code&gt;force&lt;/code&gt; プラグマは、テストを再実行し、前に失敗している可能性があるすべてのステップを繰り返します。</target>
        </trans-unit>
        <trans-unit id="bb965f28ada4d369f813e7b58370f45663a7e17c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;requires&lt;/code&gt; and &lt;code&gt;build_requires&lt;/code&gt; dependency declarations</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt; して &lt;code&gt;build_requires&lt;/code&gt; 依存関係の宣言を</target>
        </trans-unit>
        <trans-unit id="6825adde139cbe709d6cacc6c4ea55d8ef7cff02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;resolve&lt;/code&gt; function is called to generate a linearised ISA for the given stash, using this MRO. It is called with a pointer to the stash, and a</source>
          <target state="translated">&lt;code&gt;resolve&lt;/code&gt; 機能は、このMROを使用して、与えられた隠しのための直線化ISAを生成するために呼び出されます。stashへのポインタを指定して呼び出され、</target>
        </trans-unit>
        <trans-unit id="0e85b7e6554a08b089b5049ccd1a608787302c15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result_factory_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;result_factory_class&lt;/code&gt; はで説明したように、カスタマイズすることができる&lt;a href=&quot;#new&quot;&gt;新しいです&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6451f829e84fc9b2a12b294243486a8357dccdcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;roffitall&lt;/code&gt; utility is not installed on your system but lives in the</source>
          <target state="translated">&lt;code&gt;roffitall&lt;/code&gt; のユーティリティは、システムにインストールされますがに住んでいません</target>
        </trans-unit>
        <trans-unit id="9411561fa33dd9a0d96df4e7b49fae524226bee1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip(...)&lt;/code&gt; function is for tests that might or might not be possible to run, depending on the availability of platform-specific features. The first argument should evaluate to true (think &quot;yes, please skip&quot;) if the required feature is</source>
          <target state="translated">&lt;code&gt;skip(...)&lt;/code&gt; 関数は、プラットフォーム固有の機能の可用性に応じて、可能性がありますかできない場合がありますが、実行するテストのためのものです。必要な機能が次の場合、最初の引数はtrueと評価されます（「はい、スキップしてください」と考えてください）。</target>
        </trans-unit>
        <trans-unit id="4dd34dc5f337a99adbdb95ed69eaa2b33a678e8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;smoke&lt;/code&gt; command takes the list of recent uploads to CPAN as provided by the &lt;code&gt;recent&lt;/code&gt; command and tests them all. While the command is running $SIG{INT} is defined to mean that the current item shall be skipped.</source>
          <target state="translated">&lt;code&gt;smoke&lt;/code&gt; コマンドは、によって提供されるCPANへの最近のアップロードのリストを受け取り &lt;code&gt;recent&lt;/code&gt; コマンドおよびそれらすべてをテストします。コマンドの実行中、$ SIG {INT}は、現在のアイテムがスキップされることを意味するように定義されています。</target>
        </trans-unit>
        <trans-unit id="c81eca2265a8bfa89f7e2b8216b25f7468527582" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;socktype&lt;/code&gt; hint to getaddrinfo() filters the results to only include one socket type and protocol. Without this most OSes return three combinations, for &lt;code&gt;SOCK_STREAM&lt;/code&gt; , &lt;code&gt;SOCK_DGRAM&lt;/code&gt; and &lt;code&gt;SOCK_RAW&lt;/code&gt; , resulting in triplicate output of addresses. The &lt;code&gt;NI_NUMERICHOST&lt;/code&gt; flag to getnameinfo() causes it to return a string-formatted plain IP address, rather than reverse resolving it back into a hostname.</source>
          <target state="translated">getaddrinfo（）への &lt;code&gt;socktype&lt;/code&gt; ヒントは、結果をフィルタリングして、1つのソケットタイプとプロトコルのみを含めます。これがないと、ほとんどのOSは &lt;code&gt;SOCK_STREAM&lt;/code&gt; 、 &lt;code&gt;SOCK_DGRAM&lt;/code&gt; 、および &lt;code&gt;SOCK_RAW&lt;/code&gt; の 3つの組み合わせを返し、アドレスの出力が3つになります。 &lt;code&gt;NI_NUMERICHOST&lt;/code&gt; のてgetnameinfoするフラグが（）、それは逆のバックホスト名にそれを解決するのではなく、文字列形式のプレーンなIPアドレスを返すようになります。</target>
        </trans-unit>
        <trans-unit id="8fb1bd48c372b36b030a4985fb7d0b8ecfff9314" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;source&lt;/code&gt; is used to create a &lt;a href=&quot;parser/source&quot;&gt;TAP::Parser::Source&lt;/a&gt; that is passed to the &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt; which in turn figures out how to handle the source and creates a &amp;lt;TAP::Parser::Iterator&amp;gt; for it. The iterator is used by the parser to read in the TAP stream.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 作成するために使用され&lt;a href=&quot;parser/source&quot;&gt;TAP :: Parserの::ソース&lt;/a&gt;に渡され&lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_classを&lt;/a&gt;どの&amp;lt;TAP :: Parserの:: Iteratorを&amp;gt;ソースを処理し、作成する方法を順番の数字で、それのために。イテレータは、パーサーがTAPストリームを読み取るために使用されます。</target>
        </trans-unit>
        <trans-unit id="92eb80578e9c5fa00cf858e0d3634beaaf8da658" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sources&lt;/code&gt; parameter affects how &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; parameters are handled.</source>
          <target state="translated">&lt;code&gt;sources&lt;/code&gt; パラメータがどのように影響する &lt;code&gt;source&lt;/code&gt; 、 &lt;code&gt;tap&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; のパラメータが処理されます。</target>
        </trans-unit>
        <trans-unit id="027d4af5bb9710fddfec7b10292492a3bd8321cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict&lt;/code&gt; pragma is useful in avoiding such errors.</source>
          <target state="translated">&lt;code&gt;strict&lt;/code&gt; プラグマは、このようなエラーを回避するのに役立ちます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
