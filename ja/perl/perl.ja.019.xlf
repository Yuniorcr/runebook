<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="670b1ddc67f6054d3b05d014236af978c695794a" translate="yes" xml:space="preserve">
          <source>Additionally,</source>
          <target state="translated">Additionally,</target>
        </trans-unit>
        <trans-unit id="d13e57a8614451ac86ee80ef497567c6c1217ddd" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;reg()&lt;/code&gt; is responsible for parsing the one or more branches from the pattern, and for &quot;finishing them off&quot; by correctly setting their next pointers. In order to do the parsing, it repeatedly calls out to &lt;code&gt;regbranch()&lt;/code&gt; , which is responsible for handling up to the first &lt;code&gt;|&lt;/code&gt; symbol it sees.</source>
          <target state="translated">さらに、 &lt;code&gt;reg()&lt;/code&gt; は、パターンからの1つ以上のブランチを解析し、次のポインターを正しく設定することによって「それらを終了する」責任があります。構文解析を行うために、最初の処理までを担当する &lt;code&gt;regbranch()&lt;/code&gt; を繰り返し呼び出します &lt;code&gt;|&lt;/code&gt; 見えるシンボル。</target>
        </trans-unit>
        <trans-unit id="e0e807bcf6cc2e8c544c361c110388bef7a27722" translate="yes" xml:space="preserve">
          <source>Additionally, extra colons can be used to control formatting. A trailing colon suppresses the linefeed and terminator &quot;;&quot;, allowing you to embed queries into shell commands. (mnemonic: PATH separator &quot;:&quot;.)</source>
          <target state="translated">さらに、余分なコロンを使用してフォーマットを制御することができます。最後のコロンは、行送りとターミネータ &quot;;&quot; を抑制し、シェルコマンドにクエリを埋め込むことができます。(ニーモニック:PATH セパレータ &quot;:&quot;)</target>
        </trans-unit>
        <trans-unit id="e495cf9a286350e9c50957cc8351f8f292fd0e8c" translate="yes" xml:space="preserve">
          <source>Additionally, if the &lt;code&gt;h_errno&lt;/code&gt; variable is supported in C, its value is returned via &lt;code&gt;$?&lt;/code&gt; if any &lt;code&gt;gethost*()&lt;/code&gt; function fails.</source>
          <target state="translated">さらに、Cで &lt;code&gt;h_errno&lt;/code&gt; 変数がサポートされている場合、その値は &lt;code&gt;$?&lt;/code&gt; を介して返されます。いずれの場合 &lt;code&gt;gethost*()&lt;/code&gt; 関数が失敗しました。</target>
        </trans-unit>
        <trans-unit id="f146d2cdc65cbc8a75b0db4de74950e484d62ea3" translate="yes" xml:space="preserve">
          <source>Additionally, if the identifier is preceded by a sigil -- that is, if the identifier is part of a variable name -- it may optionally be enclosed in braces.</source>
          <target state="translated">さらに、識別子の前に sigil が付いている場合、つまり、識別子が変数名の一部である場合は、中括弧で囲むことができます。</target>
        </trans-unit>
        <trans-unit id="0a9aa35376d4ff22f823726940db699aadebfdc8" translate="yes" xml:space="preserve">
          <source>Additionally, implementations of the standard &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; tmpnam() and tmpfile() functions are provided if required.</source>
          <target state="translated">さらに、必要に応じて、標準の&lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; tmpnam（）およびtmpfile（）関数の実装が提供されます。</target>
        </trans-unit>
        <trans-unit id="ec069a599a9fe7b608d8c7621218dba9e34959bc" translate="yes" xml:space="preserve">
          <source>Additionally, it will create META.yml and META.json module meta-data file in the distdir and add this to the distdir's MANIFEST. You can shut this behavior off with the NO_META flag.</source>
          <target state="translated">さらに、META.yml と META.json モジュールのメタデータファイルを distdir に作成し、これを distdir の MANIFEST に追加します。NO_META フラグでこの動作を止めることができます。</target>
        </trans-unit>
        <trans-unit id="fdcb47de4e9258bc110d7122692a049db6fbb22a" translate="yes" xml:space="preserve">
          <source>Additionally, on Windows NT not all the fields returned by stat() can be compared. For example, the C</source>
          <target state="translated">さらに、Windows NT では stat()が返すすべてのフィールドを比較できるわけではありません。例えば、C</target>
        </trans-unit>
        <trans-unit id="51fffd62248577e35b4f056a4c962f40c15d81d6" translate="yes" xml:space="preserve">
          <source>Additionally, quoting rules for the end-of-string identifier are unrelated to Perl's quoting rules. &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq()&lt;/a&gt;&lt;/code&gt;, and the like are not supported in place of &lt;code&gt;''&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; , and the only interpolation is for backslashing the quoting character:</source>
          <target state="translated">さらに、文字列の終わりの識別子の引用規則は、Perlの引用規則とは無関係です。 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq()&lt;/a&gt;&lt;/code&gt; などは、 &lt;code&gt;''&lt;/code&gt; および &lt;code&gt;&quot;&quot;&lt;/code&gt; の代わりにサポートされていません。唯一の補間は、引用文字のバックスラッシュです。</target>
        </trans-unit>
        <trans-unit id="60224bb897c08e69d3d354606005d24af0b374cd" translate="yes" xml:space="preserve">
          <source>Additionally, the following still works:</source>
          <target state="translated">さらに、以下のようにしても動作します。</target>
        </trans-unit>
        <trans-unit id="03aa6ebb82309c10827e49e960c12581e1baf1dc" translate="yes" xml:space="preserve">
          <source>Additionally, the type of each element is determined from the type of the array. If the array uses type &lt;code&gt;intArray *&lt;/code&gt; xsubpp will automatically work out that it contains variables of type &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; and use that typemap entry to perform the copy of each element. All pointer '*' and 'Array' tags are removed from the name to determine the subtype.</source>
          <target state="translated">さらに、各要素のタイプは、配列のタイプから決定されます。配列がタイプ &lt;code&gt;intArray *&lt;/code&gt; xsubppを使用する場合、xsubppは、タイプ &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; の変数を含むことを自動的に計算し、そのタイプマップエントリを使用して各要素のコピーを実行します。サブタイプを判別するために、すべてのポインター '*'および 'Array'タグが名前から削除されます。</target>
        </trans-unit>
        <trans-unit id="5b8c86e3562fdf5c9d82a5e93b3d4cafa347de77" translate="yes" xml:space="preserve">
          <source>Additionally, unless the &lt;code&gt;safe&lt;/code&gt; parameter is set (or the third parameter in the traditional interface is TRUE), should a &lt;code&gt;remove_tree&lt;/code&gt; be interrupted, files that were originally in read-only mode may now have their permissions set to a read-write (or &quot;delete OK&quot;) mode.</source>
          <target state="translated">さらに、 &lt;code&gt;safe&lt;/code&gt; パラメータが設定されていない限り（または従来のインターフェースの3番目のパラメータがTRUEである場合）、 &lt;code&gt;remove_tree&lt;/code&gt; が中断された場合、元々読み取り専用モードであったファイルの権限が読み取り/書き込み（または「削除OK &quot;）モード。</target>
        </trans-unit>
        <trans-unit id="ec0f027d3baa565712bd5dc0ad0e80af4eb514d9" translate="yes" xml:space="preserve">
          <source>Additionally, you can enable and disable categories of warnings. You turn off the categories you want to ignore and you can still get other categories of warnings. See &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; for the complete details, including the category names and hierarchy.</source>
          <target state="translated">さらに、警告のカテゴリを有効または無効にすることができます。無視するカテゴリをオフにしても、他のカテゴリの警告を受け取ることができます。カテゴリ名や階層などの詳細については、&lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3f10369c70dcbc4071416e4238c5876b81c9796c" translate="yes" xml:space="preserve">
          <source>Additionally, you might want to provide the following two globals to allow auto-upgrading and auto-downgrading to work correctly:</source>
          <target state="translated">さらに、自動アップグレードと自動ダウングレー ドが正しく動作するように、以下の 2 つのグローバルを指定するとよいでしょう。</target>
        </trans-unit>
        <trans-unit id="0595fe59d92f01dd8f2cab1ee0be7afe3d67ccd0" translate="yes" xml:space="preserve">
          <source>Additionaly, on Solaris 8 and 9 you also need:</source>
          <target state="translated">加えて、Solaris 8 と 9 では、必要なものがあります。</target>
        </trans-unit>
        <trans-unit id="bf73559c41806dc25286227ff308976c154c29de" translate="yes" xml:space="preserve">
          <source>Additive Operators</source>
          <target state="translated">加法演算子</target>
        </trans-unit>
        <trans-unit id="15668d6e15430dae7c65fa496b4f2aa5393ff6b7" translate="yes" xml:space="preserve">
          <source>Address family constants used by the socket address structures, to pass to such functions as inet_pton() or getaddrinfo(), or are returned by such functions as sockaddr_family().</source>
          <target state="translated">ソケットアドレス構造体で使用されるアドレスファミリ定数で、inet_pton()や getaddrinfo()などの関数に渡すか、 sockaddr_family()などの関数から返される。</target>
        </trans-unit>
        <trans-unit id="398491e08f855e6e51bbd01773f98e6f34b68ef0" translate="yes" xml:space="preserve">
          <source>Address to send copy of report to. Defaults to the address of the local perl administrator (recorded when perl was built).</source>
          <target state="translated">レポートのコピーを送信するアドレス。デフォルトはローカルのperl管理者のアドレス(perlがビルドされたときに記録された)。</target>
        </trans-unit>
        <trans-unit id="866089dee6e89f6a5b436348a98fb9411f98472d" translate="yes" xml:space="preserve">
          <source>Address to send the report to. Defaults to &lt;b&gt;perlbug@perl.org&lt;/b&gt;.</source>
          <target state="translated">レポートの送信先のアドレス。デフォルトは&lt;b&gt;perlbug@perl.org&lt;/b&gt;です。</target>
        </trans-unit>
        <trans-unit id="6b59857dd57932d5d50e4861a06a2080338435ed" translate="yes" xml:space="preserve">
          <source>Address-of operator. (But see the &lt;code&gt;&quot;\&quot;&lt;/code&gt; operator for taking a reference.)</source>
          <target state="translated">アドレス演算子。（ただし、参照については &lt;code&gt;&quot;\&quot;&lt;/code&gt; 演算子を参照してください。）</target>
        </trans-unit>
        <trans-unit id="875b1b8e40002002efb28f1a8fa46b6af7e34564" translate="yes" xml:space="preserve">
          <source>AddressSanitizer</source>
          <target state="translated">AddressSanitizer</target>
        </trans-unit>
        <trans-unit id="97d2869e530035313b88d71ffdc660bf28a9cf95" translate="yes" xml:space="preserve">
          <source>AddressSanitizer is a clang and gcc extension, included in clang since v3.1 and gcc since v4.8. It checks illegal heap pointers, global pointers, stack pointers and use after free errors, and is fast enough that you can easily compile your debugging or optimized perl with it. It does not check memory leaks though. AddressSanitizer is available for Linux, Mac OS X and soon on Windows.</source>
          <target state="translated">AddressSanitizerはclangとgccの拡張機能で、clangはv3.1から、gccはv4.8から含まれています。不正なヒープポインタ、グローバルポインタ、スタックポインタ、フリーエラー後の使用をチェックします。ただし、メモリリークはチェックしません。AddressSanitizerはLinux、Mac OS X、そして近々Windowsでも利用可能です。</target>
        </trans-unit>
        <trans-unit id="975fc2f37ec74ac4dc4429c1af7095af2a49e10a" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;#line&lt;/code&gt; directives to the C output so error messages will look like they came from the original XS file. Default is true.</source>
          <target state="translated">&lt;code&gt;#line&lt;/code&gt; ディレクティブをC出力に追加して、エラーメッセージが元のXSファイルから送信されたように見えるようにします。デフォルトはtrueです。</target>
        </trans-unit>
        <trans-unit id="14f679936dccdbe9d754f57ef3015e396a6c5718" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; to the C code. Default is false.</source>
          <target state="translated">Cコードに &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; を追加します。デフォルトはfalseです。</target>
        </trans-unit>
        <trans-unit id="9fbaf45d7bbf38840f610cf2fa4335deddb3f4a7" translate="yes" xml:space="preserve">
          <source>Adds a list of items onto the end of the queue.</source>
          <target state="translated">アイテムのリストをキューの最後に追加します。</target>
        </trans-unit>
        <trans-unit id="973f265e0df96f52e35c5a95591ee9281a6a4277" translate="yes" xml:space="preserve">
          <source>Adds a name to a stash's internal list of effective names. See &lt;code&gt;hv_ename_delete&lt;/code&gt; .</source>
          <target state="translated">stashの有効な名前の内部リストに名前を追加します。 &lt;code&gt;hv_ename_delete&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="e689b98670881df4701aa3dac263f404709c80f2" translate="yes" xml:space="preserve">
          <source>Adds an action (Perl command) to happen after the prompt when you've just given a command to return to executing the script. A multi-line command may be entered by backslashing the newlines.</source>
          <target state="translated">プロンプトの後に、スクリプトの実行に戻るためのコマンドを入力したときに発生するアクション (Perl コマンド)を追加します。複数行のコマンドは、バックスラッシュで改行して入力することができます。</target>
        </trans-unit>
        <trans-unit id="6f66738644531c5b87f8955ebdca5064179de491" translate="yes" xml:space="preserve">
          <source>Adds an entry to an existing</source>
          <target state="translated">既存の</target>
        </trans-unit>
        <trans-unit id="0de7670702a5255a31f66440c4b7be5b815e4074" translate="yes" xml:space="preserve">
          <source>Adds directives to point C preprocessor to the right place when handling #include &amp;lt;sys/foo.h&amp;gt; directives. Also constructs CC command line a bit differently than MM_Unix method.</source>
          <target state="translated">#include &amp;lt;sys / foo.h&amp;gt;ディレクティブを処理するときに、Cプリプロセッサーを正しい場所にポイントするディレクティブを追加します。また、CCコマンドラインをMM_Unixメソッドとは少し異なる方法で構築します。</target>
        </trans-unit>
        <trans-unit id="57db6ceb50b20e26da1bd06687e1abc05f545a8e" translate="yes" xml:space="preserve">
          <source>Adds exception handling stubs to the C code.</source>
          <target state="translated">Cコードに例外処理のスタブを追加します。</target>
        </trans-unit>
        <trans-unit id="75f4dd4f96db4d1994f4da6375a60458e7848772" translate="yes" xml:space="preserve">
          <source>Adds exception handling stubs to the C code. Default is false.</source>
          <target state="translated">例外処理のスタブを C コードに追加します。デフォルトは false です。</target>
        </trans-unit>
        <trans-unit id="4af44986ac261800435ec27f11809711c0f2176e" translate="yes" xml:space="preserve">
          <source>Adds magic to a hash. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">ハッシュに魔法を追加します。 &lt;code&gt;sv_magic&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="5d4c5e94cf59f9802d65e1e2f74c4b0b68104c99" translate="yes" xml:space="preserve">
          <source>Adds magic to an SV, upgrading it if necessary. Applies the supplied vtable and returns a pointer to the magic added.</source>
          <target state="translated">SV にマジックを追加し、必要に応じてアップグレードします。与えられた vtable を適用し、追加されたマジックへのポインタを返します。</target>
        </trans-unit>
        <trans-unit id="28665dcfafc5d1482673492d1c1b2b0ccfb32625" translate="yes" xml:space="preserve">
          <source>Adds magic to an SV. First upgrades &lt;code&gt;sv&lt;/code&gt; to type &lt;code&gt;SVt_PVMG&lt;/code&gt; if necessary, then adds a new magic item of type &lt;code&gt;how&lt;/code&gt; to the head of the magic list.</source>
          <target state="translated">SVに魔法を追加します。最初のアップグレードは &lt;code&gt;sv&lt;/code&gt; 入力する &lt;code&gt;SVt_PVMG&lt;/code&gt; を必要に応じて、そのタイプの新しい魔法のアイテム追加 &lt;code&gt;how&lt;/code&gt; 魔法のリストの先頭に。</target>
        </trans-unit>
        <trans-unit id="542cadc025698f26c94694489350a3b0f8078ab7" translate="yes" xml:space="preserve">
          <source>Adds the UTF-8 representation of the native code point &lt;code&gt;uv&lt;/code&gt; to the end of the string &lt;code&gt;d&lt;/code&gt; ; &lt;code&gt;d&lt;/code&gt; should have at least &lt;code&gt;UVCHR_SKIP(uv)+1&lt;/code&gt; (up to &lt;code&gt;UTF8_MAXBYTES+1&lt;/code&gt; ) free bytes available. The return value is the pointer to the byte after the end of the new character. In other words,</source>
          <target state="translated">ネイティブコードポイント &lt;code&gt;uv&lt;/code&gt; のUTF-8表現を文字列 &lt;code&gt;d&lt;/code&gt; の末尾に追加します。 &lt;code&gt;d&lt;/code&gt; には、少なくとも &lt;code&gt;UVCHR_SKIP(uv)+1&lt;/code&gt; （ &lt;code&gt;UTF8_MAXBYTES+1&lt;/code&gt; まで）の空きバイトが必要です。戻り値は、新しい文字の終わりの後のバイトへのポインタです。言い換えると、</target>
        </trans-unit>
        <trans-unit id="05920eaea07a3bf7b3235f61833114608d265ccb" translate="yes" xml:space="preserve">
          <source>Adds the list of items to the queue at the specified index position (0 is the head of the list). Any existing items at and beyond that position are pushed back past the newly added items:</source>
          <target state="translated">指定されたインデックス位置 (0 がリストの先頭)に、項目のリストをキューに追加します。その位置以降の既存のアイテムは、新しく追加されたアイテムの前に押し戻されます。</target>
        </trans-unit>
        <trans-unit id="0e0d3dac3482cf17fed1b9381fe12a1473ad738e" translate="yes" xml:space="preserve">
          <source>Adds the standard Module prologue lines</source>
          <target state="translated">標準的なモジュールのプロローグ行を追加します。</target>
        </trans-unit>
        <trans-unit id="e8de0b7636a50e6e023d32d6c6819a0178b632ba" translate="yes" xml:space="preserve">
          <source>Adds the supplied opset to the current opmask. Note that there is currently</source>
          <target state="translated">指定した opset を現在の opmask に追加します。現在のところ</target>
        </trans-unit>
        <trans-unit id="ad3dde36a3137b653e95b59ad8f34b7ac4e19623" translate="yes" xml:space="preserve">
          <source>Adjust the read pointer and count of bytes to match &lt;code&gt;ptr&lt;/code&gt; and/or &lt;code&gt;cnt&lt;/code&gt; . The application (or layer above) must ensure they are consistent. (Checking is allowed by the paranoid.)</source>
          <target state="translated">読み取りポインタとバイト数を調整して、 &lt;code&gt;ptr&lt;/code&gt; や &lt;code&gt;cnt&lt;/code&gt; に一致させます。アプリケーション（またはその上のレイヤー）は、それらの整合性を確保する必要があります。（チェックは偏執狂によって許可されています。）</target>
        </trans-unit>
        <trans-unit id="02eff1841c4085ce501a79933ae5da5167e9d1b8" translate="yes" xml:space="preserve">
          <source>Adjusting the system clock (either manually or by services like ntp) may cause problems, especially for long running programs that assume a monotonously increasing time (note that all platforms do not adjust time as gracefully as UNIX ntp does). For example in Win32 (and derived platforms like Cygwin and MinGW) the Time::HiRes::time() may temporarily drift off from the system clock (and the original time()) by up to 0.5 seconds. Time::HiRes will notice this eventually and recalibrate. Note that since Time::HiRes 1.77 the clock_gettime(CLOCK_MONOTONIC) might help in this (in case your system supports CLOCK_MONOTONIC).</source>
          <target state="translated">システムクロックを(手動またはntpのようなサービスで)調整すると問題が発生する可能性があります。例えば、Win32(およびCygwinやMinGWなどの派生プラットフォーム)では、Time::HiRes::time()が一時的にシステムクロック(および元のtime())から0.5秒までずれてしまうことがあります。Time::HiResは最終的にこれに気付き、再調整します。Time::HiRes 1.77以降では、clock_gettime(CLOCK_MONOTONIC)がこの場合に役立つかもしれないことに注意してください(お使いのシステムがCLOCK_MONOTONICをサポートしている場合)。</target>
        </trans-unit>
        <trans-unit id="e8d0942ed6347577c01feddee9c6edaf4ffde5a8" translate="yes" xml:space="preserve">
          <source>Adjustments are made for Borland's quirks needing -L to come first.</source>
          <target state="translated">ボーランドのクセには-Lが先に来るように調整されています。</target>
        </trans-unit>
        <trans-unit id="b8be3d1264310c3b8c848d4b90d5206179a40cc4" translate="yes" xml:space="preserve">
          <source>Administration</source>
          <target state="translated">Administration</target>
        </trans-unit>
        <trans-unit id="1eda23758be9e36e5e0d2a6a87de584aaca0193f" translate="yes" xml:space="preserve">
          <source>Administrator</source>
          <target state="translated">Administrator</target>
        </trans-unit>
        <trans-unit id="e6a9cb58c1721e13f0512658aa83841944c325f3" translate="yes" xml:space="preserve">
          <source>Admittedly, it's a little silly to use the curlies in this case, but the BLOCK can contain any arbitrary expression, in particular, subscripted expressions:</source>
          <target state="translated">確かに、この場合にカーリーを使うのは少し馬鹿げていますが、blockには任意の式、特に添え字式を入れることができます。</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">高度な機能</target>
        </trans-unit>
        <trans-unit id="64e04a8cbc4193de6f65fd1544695b7f543269ac" translate="yes" xml:space="preserve">
          <source>Advanced Possibilities</source>
          <target state="translated">高度な可能性</target>
        </trans-unit>
        <trans-unit id="a79e7b92e71c562343b0e0c5c252eadade25490c" translate="yes" xml:space="preserve">
          <source>Advanced Semaphores</source>
          <target state="translated">高度なセマフォ</target>
        </trans-unit>
        <trans-unit id="0d7049ed333121f6ad65eac902c5a2d1cec948e8" translate="yes" xml:space="preserve">
          <source>Advanced Topics</source>
          <target state="translated">先進的なトピック</target>
        </trans-unit>
        <trans-unit id="5646362e1c7206c24de0aa69540a4070b9eef4ad" translate="yes" xml:space="preserve">
          <source>Affects screen appearance of the command line (see &lt;a href=&quot;term/readline&quot;&gt;Term::ReadLine&lt;/a&gt;). There is currently no way to disable these, which can render some output illegible on some displays, or with some pagers. This is considered a bug.</source>
          <target state="translated">コマンドラインの画面表示に影響します（&lt;a href=&quot;term/readline&quot;&gt;Term :: ReadLineを&lt;/a&gt;参照）。現在、これらを無効にする方法はありません。これにより、一部のディスプレイまたは一部のページャーで一部の出力が読みにくくなる場合があります。これはバグと見なされます。</target>
        </trans-unit>
        <trans-unit id="7ac09ae75b5fa764eed3b6f049863915415754f4" translate="yes" xml:space="preserve">
          <source>Affects the printing of messages upon entry and exit from subroutines. If &lt;code&gt;frame &amp;amp; 2&lt;/code&gt; is false, messages are printed on entry only. (Printing on exit might be useful if interspersed with other messages.)</source>
          <target state="translated">サブルーチンの開始時および終了時のメッセージの印刷に影響します。 &lt;code&gt;frame &amp;amp; 2&lt;/code&gt; がfalseの場合、メッセージは入力時にのみ印刷されます。（出口での印刷は、他のメッセージが散在している場合に役立つことがあります。）</target>
        </trans-unit>
        <trans-unit id="1d35114b8f34bf6224a46dac8d98b4ed3594b7f5" translate="yes" xml:space="preserve">
          <source>Africa</source>
          <target state="translated">Africa</target>
        </trans-unit>
        <trans-unit id="79ba5e1b3f99abfd54ef8d839ba12bd2ac4d79cb" translate="yes" xml:space="preserve">
          <source>After</source>
          <target state="translated">After</target>
        </trans-unit>
        <trans-unit id="87099a71e0044f05a4ae4680480a6ca9151bafd1" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigFloat ':constant'&lt;/code&gt; all the floating point constants in the given scope are converted to &lt;code&gt;Math::BigFloat&lt;/code&gt; . This conversion happens at compile time.</source>
          <target state="translated">後 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigFloat ':constant'&lt;/code&gt; 指定されたスコープ内のすべての浮動小数点定数はに変換されている &lt;code&gt;Math::BigFloat&lt;/code&gt; 。この変換はコンパイル時に行われます。</target>
        </trans-unit>
        <trans-unit id="809e579562da8a6c62758fa5638ee2d5856559cc" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigInt ':constant'&lt;/code&gt; all the &lt;b&gt;integer&lt;/b&gt; decimal, hexadecimal and binary constants in the given scope are converted to &lt;code&gt;Math::BigInt&lt;/code&gt; . This conversion happens at compile time.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigInt ':constant'&lt;/code&gt; &lt;a href=&quot;../functions/use&quot;&gt;使用した&lt;/a&gt;後、指定されたスコープ内のすべての&lt;b&gt;整数の&lt;/b&gt; 10進、16進、および2進定数が &lt;code&gt;Math::BigInt&lt;/code&gt; 変換されます。この変換はコンパイル時に行われます。</target>
        </trans-unit>
        <trans-unit id="dc94e5687372ef5e696852ffc210ec8b3418a842" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; has returned all entries from the hash or array, the next call to &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; returns the empty list in list context and &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context; the next call following</source>
          <target state="translated">後 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; の次の呼び出し、ハッシュや配列からすべてのエントリを返した &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; リストコンテキストとに戻るに空のリストを &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; をスカラーコンテキストでは、次の呼び出し</target>
        </trans-unit>
        <trans-unit id="655e7d0919e193463d83e3f9f9d5abefb149c7ea" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; has returned all entries from the hash or array, the next call to &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; returns the empty list in list context and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context; the next call following</source>
          <target state="translated">後 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; の次の呼び出し、ハッシュや配列からすべてのエントリを返した &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; リストコンテキストとに戻るに空のリストを &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; をスカラーコンテキストでは、次の呼び出し</target>
        </trans-unit>
        <trans-unit id="1d724f064157a1afcae77bb02216759e4c7bf880" translate="yes" xml:space="preserve">
          <source>After a match against some variable &lt;code&gt;$var&lt;/code&gt; :</source>
          <target state="translated">いくつかの変数 &lt;code&gt;$var&lt;/code&gt; 一致した後：</target>
        </trans-unit>
        <trans-unit id="b84c3333b0e2cfaba4160f029890fe89d06d1d06" translate="yes" xml:space="preserve">
          <source>After a proper &lt;code&gt;POSIX::setlocale()&lt;/code&gt; call, and within the scope of of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes numerics, Perl obeys the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale information, which controls an application's idea of how numbers should be formatted for human readability. In most implementations the only effect is to change the character used for the decimal point--perhaps from &quot;.&quot; to &quot;,&quot;. The functions aren't aware of such niceties as thousands separation and so on. (See &lt;a href=&quot;#The-localeconv-function&quot;&gt;The localeconv function&lt;/a&gt; if you care about these things.)</source>
          <target state="translated">適切な &lt;code&gt;POSIX::setlocale()&lt;/code&gt; 呼び出しの後、数値を含む &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; フォームの範囲内で、Perlは &lt;code&gt;LC_NUMERIC&lt;/code&gt; ロケール情報に従います。これは、人間が読みやすいように数値をフォーマットする方法に関するアプリケーションの考えを制御します。ほとんどの実装では、唯一の効果は、おそらく「。」から、小数点に使用される文字を変更することです。「、」に。関数は、何千もの分離などの優れた機能を認識していません。（これらについて気に&lt;a href=&quot;#The-localeconv-function&quot;&gt;する&lt;/a&gt;場合は、localeconv関数を参照してください。）</target>
        </trans-unit>
        <trans-unit id="1775073c0fe50242e57a96b412a98f0e94cc679a" translate="yes" xml:space="preserve">
          <source>After a successful compilation, you'll be able to use</source>
          <target state="translated">コンパイルが成功したら</target>
        </trans-unit>
        <trans-unit id="f087a68cf0ba68c94dea17e31581c5258e5a685a" translate="yes" xml:space="preserve">
          <source>After all, the best thing about this pragma is that you don't have to resort to \x{....} just to spell your name in a native encoding. So feel free to put your strings in your encoding in quotes and regexes.</source>
          <target state="translated">結局のところ、このpragmaの一番の利点は、ネイティブエンコーディングで自分の名前を綴るためだけに \x{....}に頼る必要がないということです。ですから、エンコーディングの文字列は引用符や正規表現で自由に記述してください。</target>
        </trans-unit>
        <trans-unit id="7593ddf636c03d07a5c407ca6961ab2d5ad931e8" translate="yes" xml:space="preserve">
          <source>After an environment variable is tied, merely use it like a normal variable. You may access its value</source>
          <target state="translated">環境変数が紐付けられた後は、通常の変数と同じように使用するだけです。その値にアクセスするには</target>
        </trans-unit>
        <trans-unit id="755e56a66bf3563f2fb9151f704977af6151c9b5" translate="yes" xml:space="preserve">
          <source>After an extension has been built and before it is installed it may be desirable to test it bypassing &lt;code&gt;make test&lt;/code&gt; . By adding</source>
          <target state="translated">拡張機能がビルドされた後、インストールされる前に、 &lt;code&gt;make test&lt;/code&gt; をバイパスしてテストすることが望ましい場合があります。追加することにより</target>
        </trans-unit>
        <trans-unit id="82f653c370563b01ec9f101f2aaad77e03914b8a" translate="yes" xml:space="preserve">
          <source>After command line parsing the following attributes reflect the values of the corresponding command line switches. They may be altered before calling &lt;code&gt;run&lt;/code&gt; .</source>
          <target state="translated">コマンドラインの解析後、次の属性は、対応するコマンドラインスイッチの値を反映しています。 &lt;code&gt;run&lt;/code&gt; を呼び出す前に変更される場合があります。</target>
        </trans-unit>
        <trans-unit id="5e251b544ae28a039470aaf55a5b7b59f40f8190" translate="yes" xml:space="preserve">
          <source>After each &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d file is compiled, but before it is executed, &lt;code&gt;DB::postponed(*{&quot;_&amp;lt;$filename&quot;})&lt;/code&gt; is called if the subroutine &lt;code&gt;DB::postponed&lt;/code&gt; exists. Here, the $filename is the expanded name of the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d file, as found in the values of %INC.</source>
          <target state="translated">それぞれの &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; dファイルがコンパイルされた後、それが実行される前に、サブルーチン &lt;code&gt;DB::postponed&lt;/code&gt; が存在する場合、 &lt;code&gt;DB::postponed(*{&quot;_&amp;lt;$filename&quot;})&lt;/code&gt; が呼び出されます。ここでは、$ファイル名はの拡張名である &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ％INCの値に見られるような、Dファイルを。</target>
        </trans-unit>
        <trans-unit id="e73cebac8df604a03fa2c93d2c658b08259d94b6" translate="yes" xml:space="preserve">
          <source>After each subroutine &lt;code&gt;subname&lt;/code&gt; is compiled, the existence of &lt;code&gt;$DB::postponed{subname}&lt;/code&gt; is checked. If this key exists, &lt;code&gt;DB::postponed(subname)&lt;/code&gt; is called if the &lt;code&gt;DB::postponed&lt;/code&gt; subroutine also exists.</source>
          <target state="translated">各サブルーチンの &lt;code&gt;subname&lt;/code&gt; がコンパイルされた後、 &lt;code&gt;$DB::postponed{subname}&lt;/code&gt; がチェックされます。このキーが存在し、 &lt;code&gt;DB::postponed&lt;/code&gt; サブルーチンも存在する場合、 &lt;code&gt;DB::postponed(subname)&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="e09c67a58e395afd52ffb2f20be8dce115f5694f" translate="yes" xml:space="preserve">
          <source>After each such removal you need to rerun the &lt;code&gt;Makefile.PL&lt;/code&gt; /&lt;code&gt;make&lt;/code&gt; process; usually this procedure converges soon. (But be sure to convert all the necessary external C libraries from</source>
          <target state="translated">そのような各削除の後、 &lt;code&gt;Makefile.PL&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; プロセスを再実行する必要があります。通常、この手順はすぐに収束します。（ただし、必要なすべての外部Cライブラリを</target>
        </trans-unit>
        <trans-unit id="eb84d48b7946333a20d799fbde5105dfdef9cef8" translate="yes" xml:space="preserve">
          <source>After extracting the archive you copy the whole directory tree to your EBCDIC filesystem. &lt;b&gt;This time you use I/O-conversion&lt;/b&gt;:</source>
          <target state="translated">アーカイブを抽出したら、ディレクトリツリー全体をEBCDICファイルシステムにコピーします。&lt;b&gt;今回はI / O変換を使用します&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="19dac0c58c8882858862b2f71b6cf8f32d646112" translate="yes" xml:space="preserve">
          <source>After having failed to remove a directory, &lt;code&gt;remove_tree&lt;/code&gt; was unable to restore its permissions from a permissive state back to a possibly more restrictive setting. (Permissions given in octal).</source>
          <target state="translated">ディレクトリの削除に失敗した後、 &lt;code&gt;remove_tree&lt;/code&gt; は、そのアクセス許可を許可状態からより制限的な設定に戻すことができませんでした。（許可は8進数で与えられます）。</target>
        </trans-unit>
        <trans-unit id="82bcd3184999ba561b43a537f2cc4ce40931101a" translate="yes" xml:space="preserve">
          <source>After having failed to remove a file, &lt;code&gt;remove_tree&lt;/code&gt; was also unable to restore the permissions on the file to a possibly less permissive setting. (Permissions given in octal).</source>
          <target state="translated">ファイルの削除に失敗した後、 &lt;code&gt;remove_tree&lt;/code&gt; はファイルに対する権限を、許容度が低い設定に復元することもできませんでした。（許可は8進数で与えられます）。</target>
        </trans-unit>
        <trans-unit id="23dac87df7f1fec6e0cffc03d2d5c4ff05ad76e5" translate="yes" xml:space="preserve">
          <source>After having this in the first part of .xs file, the &quot;Perl glue&quot; part becomes as simple as</source>
          <target state="translated">これを .xs ファイルの最初の部分に入れておくと、&quot;Perl glue&quot; の部分は次のように簡単になります。</target>
        </trans-unit>
        <trans-unit id="2a05093cdd7b4cafe419584a2ca96b5327589ac9" translate="yes" xml:space="preserve">
          <source>After importing this module, when you use localtime or gmtime in a scalar context, rather than getting an ordinary scalar string representing the date and time, you get a Time::Piece object, whose stringification happens to produce the same effect as the localtime and gmtime functions. There is also a new() constructor provided, which is the same as localtime(), except when passed a Time::Piece object, in which case it's a copy constructor. The following methods are available on the object:</source>
          <target state="translated">このモジュールをインポートした後、スカラコンテキストでlocaltimeやgmtimeを使用すると、日付と時刻を表す普通のスカラ文字列ではなく、Time::Pieceオブジェクトが得られ、その文字列化はlocaltimeやgmtime関数と同じ効果をもたらします。また、new()コンストラクタも用意されており、これはlocaltime()と同じですが、Time::Pieceオブジェクトを渡した場合はコピーコンストラクタになります。オブジェクトには以下のメソッドが用意されています。</target>
        </trans-unit>
        <trans-unit id="989e7c432fe7873dedca66b4efcb012930902467" translate="yes" xml:space="preserve">
          <source>After initialisation @dl_library_path can be manipulated by an application using push and unshift before calling dl_findfile(). Unshift can be used to add directories to the front of the search order either to save search time or to override libraries with the same name in the 'normal' directories.</source>
          <target state="translated">初期化後、dl_findfile()を呼び出す前にアプリケーションが push と unshift を使って @dl_library_path を操作することができます。unshift は、検索時間を節約するために、あるいは「通常の」ディレクトリ内の同名のライブラリをオーバーライドするために、ディレクトリを検索順序の先頭に追加するために使用できます。</target>
        </trans-unit>
        <trans-unit id="384ec4e8afa39c03a7ec5ccae79ea44f50b98953" translate="yes" xml:space="preserve">
          <source>After installation &amp;amp; testing processes will stabilize, information will be more precise.</source>
          <target state="translated">インストールとテストのプロセスが安定すると、情報はより正確になります。</target>
        </trans-unit>
        <trans-unit id="2fb4a06d67a8330d3fbde3ddb1645d723c7e519d" translate="yes" xml:space="preserve">
          <source>After installing cpan-mac, drop the module archive on the &lt;b&gt;untarzipme&lt;/b&gt; droplet, which will decompress and unpack for you.</source>
          <target state="translated">cpan-macをインストールし&lt;b&gt;たら&lt;/b&gt;、モジュールアーカイブを&lt;b&gt;untarzipme&lt;/b&gt;ドロップレットにドロップします。これにより、解凍および解凍されます。</target>
        </trans-unit>
        <trans-unit id="ebf5ce736aa7d823aae94b0fbadad820a15f7f86" translate="yes" xml:space="preserve">
          <source>After locating your program, Perl compiles the entire program to an internal form. If there are any compilation errors, execution of the program is not attempted. (This is unlike the typical shell script, which might run part-way through before finding a syntax error.)</source>
          <target state="translated">プログラムが見つかると、Perl はプログラム全体を内部形式にコンパイルします。コンパイルエラーがあった場合、プログラムの実行は試みられません。(これは典型的なシェルスクリプトとは異なり、構文エラーが見つかる前に途中で実行される可能性があります)。</target>
        </trans-unit>
        <trans-unit id="1f14adfb2016d61c246f44ef48217385e9787764" translate="yes" xml:space="preserve">
          <source>After much staring at the same piece of code and not seeing the wood for the trees for some time, we get a cup of coffee and try another approach. That is, we bring in the cavalry by giving perl the '&lt;b&gt;-d&lt;/b&gt;' switch on the command line:</source>
          <target state="translated">同じコードをじっくりと見つめ、しばらくの間木の森を見ないで、コーヒーを飲みながら別の方法を試しました。つまり、コマンドラインでperlに「&lt;b&gt;-d&lt;/b&gt;」スイッチを指定して、騎兵隊を呼び込みます。</target>
        </trans-unit>
        <trans-unit id="88dec92da58c74e4620b3cd18d97733f553fa72c" translate="yes" xml:space="preserve">
          <source>After parsing the TAP, there are many methods available to let you dig through the results and determine what is meaningful to you.</source>
          <target state="translated">TAPを解析した後、結果を掘り下げて自分にとって何が意味のあることなのかを判断させるための方法がたくさんあります。</target>
        </trans-unit>
        <trans-unit id="b702243123830daddfd7ae611e2d0a89f36745c6" translate="yes" xml:space="preserve">
          <source>After parsing, this method returns any warnings encountered during the parsing process.</source>
          <target state="translated">解析後、このメソッドは解析中に発生した警告を返します。</target>
        </trans-unit>
        <trans-unit id="cebf2b23cf8d6511ea00c15fa6633daadf530471" translate="yes" xml:space="preserve">
          <source>After positional parameters, additional arguments may be captured in a slurpy parameter. The simplest form of this is just an array variable:</source>
          <target state="translated">位置パラメータの後には、追加の引数をスラスラとしたパラメータで捕捉することができます。これの最も単純な形式は、単なる配列変数です。</target>
        </trans-unit>
        <trans-unit id="79faa591ef4aa9c1048ecde8617caf4bb4f6e42f" translate="yes" xml:space="preserve">
          <source>After processing of the error using</source>
          <target state="translated">を使用してエラー処理を行った後</target>
        </trans-unit>
        <trans-unit id="de441b5d72f77ccdab32c953f236dc0929b26bfe" translate="yes" xml:space="preserve">
          <source>After reading &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; explaining how to use &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; we can write this Perl function copying a file to standard output:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; の使用方法を説明する&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;を読んだ後、ファイルを標準出力にコピーするこのPerl関数を書くことができます：</target>
        </trans-unit>
        <trans-unit id="79b88eddec153e8e34fbe3804e13971f48b0d9e3" translate="yes" xml:space="preserve">
          <source>After reading this document, you ought to read &lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt; too, then &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">このドキュメントを読んだ&lt;a href=&quot;perlunifaq&quot;&gt;後&lt;/a&gt;は、perlunifaqも読んでから、&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;も読んでください。</target>
        </trans-unit>
        <trans-unit id="bde067e2f6a70b830351def3b30472931261a063" translate="yes" xml:space="preserve">
          <source>After that,</source>
          <target state="translated">その後のことです。</target>
        </trans-unit>
        <trans-unit id="33a6f21294ecc8bfb003384c79fe3378bc362230" translate="yes" xml:space="preserve">
          <source>After the call to &lt;code&gt;inflate&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;inflate&lt;/code&gt; 呼び出しの後</target>
        </trans-unit>
        <trans-unit id="82f20576e0d7a55f07ad388dd8a48aef5935809c" translate="yes" xml:space="preserve">
          <source>After the compile tree for a subroutine (or for an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or a file) is created, an additional pass over the code is performed. This pass is neither top-down or bottom-up, but in the execution order (with additional complications for conditionals). Optimizations performed at this stage are subject to the same restrictions as in the pass 2.</source>
          <target state="translated">サブルーチン（または &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; またはファイル）のコンパイルツリーが作成された後、コードに対する追加のパスが実行されます。このパスはトップダウンでもボトムアップでもありませんが、実行順です（条件文の場合はさらに複雑になります）。この段階で実行される最適化には、パス2と同じ制限が適用されます。</target>
        </trans-unit>
        <trans-unit id="030398b98f864699ff503816f85c07e82cf00fe5" translate="yes" xml:space="preserve">
          <source>After the match fails at the letter &lt;code&gt;a&lt;/code&gt; , perl resets &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; and the next match on the same string starts at the beginning.</source>
          <target state="translated">文字 &lt;code&gt;a&lt;/code&gt; で一致が失敗した後、perlは &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; をリセットし、同じ文字列の次の一致が最初から始まります。</target>
        </trans-unit>
        <trans-unit id="293c71dbddf34e425e567a76e0a301441dc6a8bc" translate="yes" xml:space="preserve">
          <source>After the rc file is read, the debugger reads the &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; environment variable and parses this as the remainder of a &quot;O ...&quot; line as one might enter at the debugger prompt. You may place the initialization options &lt;code&gt;TTY&lt;/code&gt; , &lt;code&gt;noTTY&lt;/code&gt; , &lt;code&gt;ReadLine&lt;/code&gt; , and &lt;code&gt;NonStop&lt;/code&gt; there.</source>
          <target state="translated">rcファイルが読み取られると、デバッガーは &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; 環境変数を読み取り、これをデバッガープロンプトで入力する可能性がある「O ...」行の残りとして解析します。初期化オプション &lt;code&gt;TTY&lt;/code&gt; 、 &lt;code&gt;noTTY&lt;/code&gt; 、 &lt;code&gt;ReadLine&lt;/code&gt; 、および &lt;code&gt;NonStop&lt;/code&gt; をそこに配置できます。</target>
        </trans-unit>
        <trans-unit id="e899e5cdac5e0e6b4bee21b7339405a7360957f3" translate="yes" xml:space="preserve">
          <source>After the rc file is read, the debugger reads the PERLDB_OPTS environment variable and uses it to set debugger options. The contents of this variable are treated as if they were the argument of an &lt;code&gt;o ...&lt;/code&gt; debugger command (q.v. in &lt;a href=&quot;perldebug#Configurable-Options&quot;&gt;Configurable Options in perldebug&lt;/a&gt;).</source>
          <target state="translated">rcファイルが読み取られた後、デバッガーはPERLDB_OPTS環境変数を読み取り、それを使用してデバッガーオプションを設定します。この変数の内容は、 &lt;code&gt;o ...&lt;/code&gt; デバッガーコマンド（&lt;a href=&quot;perldebug#Configurable-Options&quot;&gt;perldebugの構成可能オプションの&lt;/a&gt; qv）の引数であるかのように扱われます。</target>
        </trans-unit>
        <trans-unit id="48e96da87f1b22f4a662b486f469bd089c2d194f" translate="yes" xml:space="preserve">
          <source>After this you can direct your browser the file</source>
          <target state="translated">この後、あなたはあなたのブラウザにファイルを指示することができます</target>
        </trans-unit>
        <trans-unit id="047aa94c055cd198e88e38eec23f2d3fb520f816" translate="yes" xml:space="preserve">
          <source>After this you can either copy Perl from your operating system media (you will need at least the /System/Library/Perl and /usr/bin/perl), or rebuild Perl from the source code with &lt;code&gt;Configure -Dprefix=/usr
-Duseshrplib&lt;/code&gt; NOTE: the &lt;code&gt;-Dprefix=/usr&lt;/code&gt; to replace the system Perl works much better with Perl 5.8.1 and later, in Perl 5.8.0 the settings were not quite right.</source>
          <target state="translated">この後、オペレーティングシステムメディアからPerlをコピーするか（少なくとも/ System / Library / Perlおよび/ usr / bin / perlが必要です）、 &lt;code&gt;Configure -Dprefix=/usr -Duseshrplib&lt;/code&gt; 使用してソースコードからPerlを再構築します。注：システムを置き換える &lt;code&gt;-Dprefix=/usr&lt;/code&gt; Perlは、Perl 5.8.1以降でより適切に機能します。Perl5.8.0では、設定が正しくありませんでした。</target>
        </trans-unit>
        <trans-unit id="afc63f5dda4ecced4f5f45482623e56ea1f306ab" translate="yes" xml:space="preserve">
          <source>After you have built perl using the Configure script, ensure that you have modify and default write permission to &lt;code&gt;&amp;gt;system&amp;gt;ported&lt;/code&gt; and all subdirectories. Then type</source>
          <target state="translated">Configureスクリプトを使用してperlをビルドしたら、 &lt;code&gt;&amp;gt;system&amp;gt;ported&lt;/code&gt; およびすべてのサブディレクトリに対する変更およびデフォルトの書き込み権限があることを確認します。次に、</target>
        </trans-unit>
        <trans-unit id="8aca2e8c01b81a07c6eb69c26b8265b8e7beb0f1" translate="yes" xml:space="preserve">
          <source>After you installed the components you needed and updated the</source>
          <target state="translated">必要なコンポーネントをインストールし、更新した後に</target>
        </trans-unit>
        <trans-unit id="61179f6b3dda7b5ee08dd7ce8f69dddb876677ab" translate="yes" xml:space="preserve">
          <source>Again assuming the existence of the &lt;code&gt;tree&lt;/code&gt; database</source>
          <target state="translated">再び、 &lt;code&gt;tree&lt;/code&gt; データベースの存在を想定します。</target>
        </trans-unit>
        <trans-unit id="7c2b707160e59a8a50ca98c9028a92309952c8b9" translate="yes" xml:space="preserve">
          <source>Again like &lt;code&gt;cond_wait&lt;/code&gt; , waking up and reacquiring the lock are not atomic, and you should always check your desired condition after this function returns. Since the timeout is an absolute value, however, it does not have to be recalculated with each pass:</source>
          <target state="translated">再度 &lt;code&gt;cond_wait&lt;/code&gt; と同様に、ロックの起動と再取得はアトミックではないため、この関数が戻った後は、常に目的の状態を確認する必要があります。ただし、タイムアウトは絶対値であるため、パスごとに再計算する必要はありません。</target>
        </trans-unit>
        <trans-unit id="f1807d38160980407aafc2417f04ad9be3af89ae" translate="yes" xml:space="preserve">
          <source>Again, for elementary pieces there is no such question, since at most one match at a given position is possible. This section describes the notion of better/worse for combining operators. In the description below &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; are regular subexpressions.</source>
          <target state="translated">繰り返しになりますが、基本的な部分では、特定の位置で最大1つの一致が可能であるため、そのような質問はありません。このセクションでは、結合演算子の良い/悪いの概念について説明します。以下の説明では、 &lt;code&gt;S&lt;/code&gt; と &lt;code&gt;T&lt;/code&gt; は正規の部分式です。</target>
        </trans-unit>
        <trans-unit id="5f5a18a4eff39b7d1528cf15b17087b5d8251fa1" translate="yes" xml:space="preserve">
          <source>Again, if you already have the data in memory or want to avoid the complexity of the above, you can use sv_setpvn().</source>
          <target state="translated">繰り返しになりますが、すでにメモリにデータがある場合や、上記のような複雑さを避けたい場合は sv_setpvn()を使うことができます。</target>
        </trans-unit>
        <trans-unit id="cf8e2e1b9b0e08a7a42ff9da61e6daf28394e96e" translate="yes" xml:space="preserve">
          <source>Again, the PERL_DL_NONLAZY thing.</source>
          <target state="translated">またしてもperl_dl_nonlazyの件。</target>
        </trans-unit>
        <trans-unit id="cc9355813d20c04f9885340bd38f5820f772f6ef" translate="yes" xml:space="preserve">
          <source>Again, the result is a string, now containing 2 bytes. If you print this string (which is, generally, not recommended) you might see &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;NO&lt;/code&gt; (depending on your system's byte ordering) - or something entirely different if your computer doesn't use ASCII character encoding. Unpacking &lt;code&gt;$ps&lt;/code&gt; with the same template returns the original integer value:</source>
          <target state="translated">繰り返しになりますが、結果は文字列になり、現在は2バイトが含まれています。この文字列（一般的には推奨されません）を出力すると、 &lt;code&gt;ON&lt;/code&gt; または &lt;code&gt;NO&lt;/code&gt; （システムのバイト順によって異なります）、またはコンピューターがASCII文字エンコードを使用していない場合はまったく異なるものが表示されることがあります。同じテンプレートで &lt;code&gt;$ps&lt;/code&gt; をアンパックすると、元の整数値が返されます。</target>
        </trans-unit>
        <trans-unit id="1336fb8f59fe4c2604eb97dc0557c0ec454667ba" translate="yes" xml:space="preserve">
          <source>Again, the same rule about having a valid invocand applies -- use an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block or &lt;code&gt;blessed&lt;/code&gt; if you need to be extra paranoid.</source>
          <target state="translated">繰り返しになりますが、有効なinvocandを持つことに関する同じルールが適用されます- 特別な偏執狂が必要な場合は、 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ブロックを使用するか、 &lt;code&gt;blessed&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="f032390a780d79dd005854d30b600a71dcbdee7e" translate="yes" xml:space="preserve">
          <source>Again, there is a distinction between omitting LIST (&lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; called with no arguments) and an explicit empty LIST &lt;code&gt;()&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; not called). Note that there is no comma after VERSION!</source>
          <target state="translated">繰り返しますが、LISTの省略（引数なしで呼び出された &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ）と明示的な空のLIST &lt;code&gt;()&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; は呼び出されません）には違いがあります。VERSIONの後にはカンマがないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="150579942e699af9662ec748d7e74bb724b4dd49" translate="yes" xml:space="preserve">
          <source>Again, there is a distinction between omitting LIST (&lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; called with no arguments) and an explicit empty LIST &lt;code&gt;()&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; not called). Note that there is no comma after VERSION!</source>
          <target state="translated">繰り返しますが、LISTの省略（引数なしで呼び出された &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ）と明示的な空のLIST &lt;code&gt;()&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; は呼び出されません）には違いがあります。VERSIONの後にはカンマがないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="245e36d26002b84ee14a1352ac81744d3ee557bd" translate="yes" xml:space="preserve">
          <source>Again, this allows for very dynamic code.</source>
          <target state="translated">繰り返しになりますが、これにより非常に動的なコードが可能になります。</target>
        </trans-unit>
        <trans-unit id="b538a15a09c26e00740fa45cdf77f8fdb9a0d9a7" translate="yes" xml:space="preserve">
          <source>Again, this procedure should not be absolutely smooth. Some &lt;code&gt;Makefile.PL&lt;/code&gt; 's in subdirectories may be buggy, and would not run as &quot;child&quot; scripts. The interdependency of modules can strike you; however, since non-XS modules are already installed, the prerequisites of most modules have a very good chance to be present.</source>
          <target state="translated">繰り返しますが、この手順は完全にスムーズであってはなりません。サブディレクトリ内の一部の &lt;code&gt;Makefile.PL&lt;/code&gt; はバグがあり、「子」スクリプトとして実行されない場合があります。モジュールの相互依存性があなたを襲う可能性があります。ただし、非XSモジュールがすでにインストールされているため、ほとんどのモジュールの前提条件が存在する可能性が非常に高くなります。</target>
        </trans-unit>
        <trans-unit id="d29cd93346e769552a8195aadabaa89c166d289b" translate="yes" xml:space="preserve">
          <source>Again, this should be a last resort only. Ideally, this should never happen, and every possible effort at cooperation and compromise should be made before doing this. If it does prove necessary to fork a module for the overall health of Perl, proper credit must be given to the original author in perpetuity and the decision should be constantly re-evaluated to see if a remerging of the two branches is possible down the road.</source>
          <target state="translated">繰り返しになりますが、これは最後の手段でしかありません。理想的には、これは決して起こってはならないことであり、これを行う前に、協力と妥協のためのあらゆる可能な努力がなされるべきです。Perl の全体的な健全性のためにモジュールをフォークする必要があることが判明した場合、原著者には永続的に適切な信用が与えられなければなりませんし、将来的に 2 つのブランチの再結合が可能かどうかを確認するために、その決定は常に再評価されるべきです。</target>
        </trans-unit>
        <trans-unit id="3a830cc268120c6d62fd1503dae1fe4595320a8c" translate="yes" xml:space="preserve">
          <source>Aggregate TAP::Parser results</source>
          <target state="translated">TAP::Parserの結果を集計</target>
        </trans-unit>
        <trans-unit id="c99323987b877f0729176ba94246c79d0ffee75d" translate="yes" xml:space="preserve">
          <source>Ah, but what if you wanted a</source>
          <target state="translated">ああ、でも、あなたが欲しがっていたのは</target>
        </trans-unit>
        <trans-unit id="fc54c7321882850cd59ca3c898a45a1866c62d48" translate="yes" xml:space="preserve">
          <source>Alan Burlison &amp;lt;Alan.Burlison@uk.sun.com&amp;gt;</source>
          <target state="translated">アラン・バーリソン&amp;lt;Alan.Burlison@uk.sun.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="28819c4f1ea8b8ef6efc038b761b2ce064e6ebed" translate="yes" xml:space="preserve">
          <source>Alas, however simple this may appear, underneath it's a much more elaborate construct than meets the eye!</source>
          <target state="translated">このように、私たちは、あなたがそれを行うことができるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="60deebc91420b65bfc5133938fc33e7af7cddcdc" translate="yes" xml:space="preserve">
          <source>Albeit this is apt to be confusing: As a consequence of the length being implied by the string's length, a number after pack code &lt;code&gt;p&lt;/code&gt; is a repeat count, not a length as after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">これは混乱しがちですが、文字列の長さによって長さが暗示される結果として、パックコード &lt;code&gt;p&lt;/code&gt; の後の数値は、 &lt;code&gt;P&lt;/code&gt; の後の長さではなく、繰り返しカウントになります。</target>
        </trans-unit>
        <trans-unit id="c375d17736d5ba75bae4628bbac2b8464ec67f67" translate="yes" xml:space="preserve">
          <source>Alex Waugh &amp;lt;alex@alexwaugh.com&amp;gt;</source>
          <target state="translated">アレックスウォー&amp;lt;alex@alexwaugh.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="98410e18a5313b84b52dba6923f79fa84662fc78" translate="yes" xml:space="preserve">
          <source>Algorithmic Complexity Attacks</source>
          <target state="translated">アルゴリズムの複雑さへの攻撃</target>
        </trans-unit>
        <trans-unit id="880e348dcb112fd7762be969b0a0f638889a7979" translate="yes" xml:space="preserve">
          <source>Alias 'great_circle_bearing' for 'great_circle_direction' is also available.</source>
          <target state="translated">また、'great_circle_direction'のエイリアス'great_circle_bearing'も用意されています。</target>
        </trans-unit>
        <trans-unit id="0898ef4b9ee98efd06a1a0a5dfd90a367c2cd721" translate="yes" xml:space="preserve">
          <source>Alias definitions to encodings</source>
          <target state="translated">エンコーディングへのエイリアス定義</target>
        </trans-unit>
        <trans-unit id="38f722ea341fc11c96b38a2a9a95013e2024c780" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/accept_codes&quot;&gt;accept_codes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/accept_codes&quot;&gt;accept_codesの&lt;/a&gt;エイリアス。</target>
        </trans-unit>
        <trans-unit id="f3ca2b4415e7c30e7f132f19403b5bffd02f19e2" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets&quot;&gt;accept_targets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets&quot;&gt;accept_targetsの&lt;/a&gt;エイリアス。</target>
        </trans-unit>
        <trans-unit id="90cb0f686347b95e9bf9ac20dee8ecef9cc3e7cc" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets_as_text&quot;&gt;accept_targets_as_text&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets_as_text&quot;&gt;accept_targets_as_textの&lt;/a&gt;エイリアス。</target>
        </trans-unit>
        <trans-unit id="d8a37b728f269336ef2b0d916cf56f8cff9a7dab" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_codes&quot;&gt;unaccept_codes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_codes&quot;&gt;unaccept_codesの&lt;/a&gt;エイリアス。</target>
        </trans-unit>
        <trans-unit id="55942451ef5112cddaa2996d9b3ade198613f3aa" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_directives&quot;&gt;unaccept_directives&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_directives&quot;&gt;unaccept_directivesの&lt;/a&gt;エイリアス。</target>
        </trans-unit>
        <trans-unit id="fc63b361fbc74519b267bcb5465524b93139434d" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_targets&quot;&gt;unaccept_targets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_targets&quot;&gt;unaccept_targetsの&lt;/a&gt;エイリアス。</target>
        </trans-unit>
        <trans-unit id="74c2c2daa5f5a0797029a2454513a78581202693" translate="yes" xml:space="preserve">
          <source>Alias overloading</source>
          <target state="translated">エイリアスのオーバーロード</target>
        </trans-unit>
        <trans-unit id="f57cd105a2d625b230e3773e4d9ad4fd8007e4e8" translate="yes" xml:space="preserve">
          <source>Aliases are added either by the use of anonymous hashes:</source>
          <target state="translated">エイリアスは匿名ハッシュを使用して追加されます。</target>
        </trans-unit>
        <trans-unit id="a04d03e091eed69bf0cabdf08f34999597a31b63" translate="yes" xml:space="preserve">
          <source>Aliases have no effect on the return value of uncolor().</source>
          <target state="translated">エイリアスは uncolor()の戻り値に影響を与えません。</target>
        </trans-unit>
        <trans-unit id="bde3b653ba60660ff94a6811c58e93a5bf93107d" translate="yes" xml:space="preserve">
          <source>Aliases must begin with a character that is alphabetic. After that, each may contain any combination of word (&lt;code&gt;\w&lt;/code&gt; ) characters, SPACE (U+0020), HYPHEN-MINUS (U+002D), LEFT PARENTHESIS (U+0028), RIGHT PARENTHESIS (U+0029), and NO-BREAK SPACE (U+00A0). These last three should never have been allowed in names, and are retained for backwards compatibility only; NO-BREAK SPACE IS currently deprecated and scheduled for removal in Perl v5.26; the other two may also be deprecated and removed in future releases of Perl, so don't use them for new names. (More precisely, the first character of a name you specify must be something that matches all of &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{Alphabetic}&lt;/code&gt; , and &lt;code&gt;\p{Gc=Letter}&lt;/code&gt; . This makes sure it is what any reasonable person would view as an alphabetic character. And, the continuation characters that match &lt;code&gt;\w&lt;/code&gt; must also match &lt;code&gt;\p{ID_Continue}&lt;/code&gt; .) Starting with Perl v5.18, any Unicode characters meeting the above criteria may be used; prior to that only Latin1-range characters were acceptable.</source>
          <target state="translated">エイリアスはアルファベットの文字で始まる必要があります。その後、それぞれに単語（ &lt;code&gt;\w&lt;/code&gt; ）文字、スペース（U + 0020）、ハイフンマイナス（U + 002D）、左括弧（U + 0028）、右括弧（U + 0029）、およびNOの任意の組み合わせを含めることができます-BREAK SPACE（U + 00A0）。これらの最後の3つは名前に使用できませんでした。下位互換性のためにのみ保持されています。ブレークなしスペースは現在非推奨であり、Perl v5.26での削除が予定されています。他の2つは、Perlの将来のリリースで非推奨になり、削除される可能性があるため、新しい名前に使用しないでください。 （より正確には、指定する名前の最初の文字は、 &lt;code&gt;\p{ID_Start}&lt;/code&gt; 、 &lt;code&gt;\p{Alphabetic}&lt;/code&gt; 、および &lt;code&gt;\p{Gc=Letter}&lt;/code&gt; すべてに一致するものである必要があります。これにより、合理的な人物がアルファベット文字と見なすものになります。また、 &lt;code&gt;\w&lt;/code&gt; 一致する継続文字は &lt;code&gt;\p{ID_Continue}&lt;/code&gt; も一致する必要があります。Perlv5.18以降では、上記の基準を満たす任意のUnicode文字を使用できます。それ以前は、Latin1範囲の文字のみが受け入れられていました。</target>
        </trans-unit>
        <trans-unit id="91f975513dec5dd8e68b29fb075833bd77c269b1" translate="yes" xml:space="preserve">
          <source>Alignment, Take 2</source>
          <target state="translated">アライメント、テイク2</target>
        </trans-unit>
        <trans-unit id="a1ea8b54954e0fde287940a149a033befa43e6c8" translate="yes" xml:space="preserve">
          <source>Alignment, Take 3</source>
          <target state="translated">アライメント、テイク3</target>
        </trans-unit>
        <trans-unit id="764199267e4fee8134969e2bb73e632b952ebdb3" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;--sources&lt;/code&gt; are combined into a hash, and passed to &lt;a href=&quot;tap/harness#new&quot;&gt;new in TAP::Harness&lt;/a&gt;'s &lt;code&gt;sources&lt;/code&gt; parameter.</source>
          <target state="translated">すべての &lt;code&gt;--sources&lt;/code&gt; はハッシュに結合され、&lt;a href=&quot;tap/harness#new&quot;&gt;新しいTAP :: Harness&lt;/a&gt;の &lt;code&gt;sources&lt;/code&gt; パラメータに渡されます。</target>
        </trans-unit>
        <trans-unit id="f52d6e40e6d60dfb65b7ff9829f21ad743f4c4af" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;Digest::&lt;/code&gt; modules provide the same programming interface. A functional interface for simple use, as well as an object oriented interface that can handle messages of arbitrary length and which can read files directly.</source>
          <target state="translated">すべての &lt;code&gt;Digest::&lt;/code&gt; モジュールは同じプログラミングインターフェイスを提供します。シンプルな使用のための機能的なインターフェイス、および任意の長さのメッセージを処理でき、ファイルを直接読み取ることができるオブジェクト指向のインターフェイス。</target>
        </trans-unit>
        <trans-unit id="457b3764fb61bab63f516bcecf7b3d7be10ba056" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;TAP::*&lt;/code&gt; objects inherit from &lt;a href=&quot;object&quot;&gt;TAP::Object&lt;/a&gt;.</source>
          <target state="translated">すべての &lt;code&gt;TAP::*&lt;/code&gt; オブジェクトは&lt;a href=&quot;object&quot;&gt;TAP :: Object&lt;/a&gt;から継承します。</target>
        </trans-unit>
        <trans-unit id="5afc429b1453c07f0d0baef120b89dcb6d31ac74" translate="yes" xml:space="preserve">
          <source>All I want to do is append a small amount of text to the end of a file. Do I still have to use locking?</source>
          <target state="translated">ファイルの最後に少量のテキストを追加したいだけです。それでもロックを使用する必要がありますか?</target>
        </trans-unit>
        <trans-unit id="364f430073ddd95c184ef6908813da97f63c8227" translate="yes" xml:space="preserve">
          <source>All NULs, returns, and newlines are removed from the result.</source>
          <target state="translated">すべての NUL、リターン、および改行は結果から削除されます。</target>
        </trans-unit>
        <trans-unit id="3357b46fb83adc9becdcce6c42b795ffab969cd7" translate="yes" xml:space="preserve">
          <source>All Perl applications that make use of the script will need to be changed (slightly) if the script is converted into a module. Is it worth it unless you plan to make other changes at the same time?</source>
          <target state="translated">スクリプトを使用するすべての Perl アプリケーションは、スクリプトがモジュールに変換された場合、(少しだけ)変更する必要があります。同時に他の変更を行う予定がない限り、その価値はあるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="c0556d5f4ef8cf5b2d75a71a511d88da552691b2" translate="yes" xml:space="preserve">
          <source>All Perl module files have the extension</source>
          <target state="translated">すべてのPerlモジュールファイルには拡張子</target>
        </trans-unit>
        <trans-unit id="c9df8c5103a954885f4c9cd5391cce1f658e5378" translate="yes" xml:space="preserve">
          <source>All Perl source filters are implemented as Perl classes and have the same basic structure as the example above.</source>
          <target state="translated">すべてのPerlソースフィルタはPerlクラスとして実装されており、基本的な構造は上記の例と同じです。</target>
        </trans-unit>
        <trans-unit id="a24109cbe749713ab37960e5621fab63c25af84c" translate="yes" xml:space="preserve">
          <source>All SVs that contain strings should be terminated with a &lt;code&gt;NUL&lt;/code&gt; character. If it is not &lt;code&gt;NUL&lt;/code&gt; -terminated there is a risk of core dumps and corruptions from code which passes the string to C functions or system calls which expect a &lt;code&gt;NUL&lt;/code&gt; -terminated string. Perl's own functions typically add a trailing &lt;code&gt;NUL&lt;/code&gt; for this reason. Nevertheless, you should be very careful when you pass a string stored in an SV to a C function or system call.</source>
          <target state="translated">文字列を含むすべてのSVは、 &lt;code&gt;NUL&lt;/code&gt; 文字で終了する必要があります。 &lt;code&gt;NUL&lt;/code&gt; で終了していない場合、CUL関数に文字列を渡すコードや、 &lt;code&gt;NUL&lt;/code&gt; で終了している文字列を予期するシステムコールにより、コアダンプや破損のリスクがあります。このため、Perl独自の関数は通常、末尾に &lt;code&gt;NUL&lt;/code&gt; を追加します。それでも、SVに格納されている文字列をC関数またはシステムコールに渡す場合は、十分に注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="48a5c9b581d8c7b87b13529ddc2ea4756cd71725" translate="yes" xml:space="preserve">
          <source>All Solaris documentation is available on-line at &lt;a href=&quot;http://docs.sun.com/&quot;&gt;http://docs.sun.com/&lt;/a&gt;.</source>
          <target state="translated">Solarisのすべてのドキュメントは、&lt;a href=&quot;http://docs.sun.com/&quot;&gt;http：//docs.sun.com/&lt;/a&gt;からオンラインで入手できます。</target>
        </trans-unit>
        <trans-unit id="02a6fc4950c3ff395602f4e234c32b98fa8bbb9b" translate="yes" xml:space="preserve">
          <source>All Unicode-defined character properties may be written in these compound forms of &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; or &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;:&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt;, but Perl provides some additional properties that are written only in the single form, as well as single-form short-cuts for all binary properties and certain others described below, in which you may omit the property name and the equals or colon separator.</source>
          <target state="translated">すべてのUnicode定義の文字プロパティは、 &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; または &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;:&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; これらの複合形式で記述できますが、Perlは、単一形式だけでなく、すべてのバイナリプロパティと、以下で説明するその他の特定のプロパティのショートカットを作成します。ここでは、プロパティ名と等号またはコロン区切り文字を省略できます。</target>
        </trans-unit>
        <trans-unit id="824a27b5a0842833d945bd7311a2e5202945d5f2" translate="yes" xml:space="preserve">
          <source>All above are #define'd to stdio functions or are trivial wrapper functions which call stdio. In this case</source>
          <target state="translated">上記のすべての関数は #define されて stdio 関数になっているか、あるいは stdio を呼び出している些細なラッパー関数になっています。この場合</target>
        </trans-unit>
        <trans-unit id="480b6099af5b199261a0cc5b0a69906525b8aab5" translate="yes" xml:space="preserve">
          <source>All are zero-width assertions.</source>
          <target state="translated">すべてゼロ幅のアサーションです。</target>
        </trans-unit>
        <trans-unit id="ea4147392f071907aee8241573927949a9171c29" translate="yes" xml:space="preserve">
          <source>All arguments are optional. If the escape characters are not specified, every delimiter is escaped with a backslash (&lt;code&gt;\&lt;/code&gt; ). If the prefix is not specified, the pattern &lt;code&gt;'\s*'&lt;/code&gt; - optional whitespace - is used. If the delimiter set is also not specified, the set &lt;code&gt;/[&quot;'`]/&lt;/code&gt; is used. If the text to be processed is not specified either, &lt;code&gt;$_&lt;/code&gt; is used.</source>
          <target state="translated">すべての引数はオプションです。エスケープ文字が指定されていない場合、すべての区切り文字はバックスラッシュ（ &lt;code&gt;\&lt;/code&gt; ）でエスケープされます。プレフィックスが指定されていない場合、パターン &lt;code&gt;'\s*'&lt;/code&gt; （オプションの空白）が使用されます。区切り文字セットも指定されていない場合は &lt;code&gt;/[&quot;'`]/&lt;/code&gt; が使用され、処理するテキストも指定されていない場合は &lt;code&gt;$_&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="9ae556487b52756ee168bee18fdadcf299ff8eb4" translate="yes" xml:space="preserve">
          <source>All arguments passed to &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; are passed onto &lt;code&gt;Your::Module-&amp;gt;builder-&amp;gt;plan()&lt;/code&gt; with the exception of &lt;code&gt;import =&amp;gt;[qw(things to import)]&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;import =&amp;gt;[qw(things to import)]&lt;/code&gt; 除いて、 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; に渡されるすべての引数は &lt;code&gt;Your::Module-&amp;gt;builder-&amp;gt;plan()&lt;/code&gt; 渡されます。</target>
        </trans-unit>
        <trans-unit id="b2e982744f4ac0300218d6f294863226187db18a" translate="yes" xml:space="preserve">
          <source>All arguments passed to the &lt;b&gt;new()&lt;/b&gt; constructor will be treated as key/value pairs in a hash-table. The newly constructed object will be initialized by copying the contents of the given hash-table (which may have been empty). The &lt;b&gt;new()&lt;/b&gt; constructor for this class and all of its subclasses returns a blessed reference to the initialized object (hash-table).</source>
          <target state="translated">&lt;b&gt;new（）&lt;/b&gt;コンストラクターに渡されるすべての引数は、ハッシュテーブルでキー/値のペアとして扱われます。新しく作成されたオブジェクトは、指定されたハッシュテーブル（空の可能性があります）の内容をコピーして初期化されます。このクラスとそのすべてのサブクラスの&lt;b&gt;new（）&lt;/b&gt;コンストラクターは、初期化されたオブジェクト（ハッシュテーブル）へのblessされた参照を返します。</target>
        </trans-unit>
        <trans-unit id="ec83cba8a792f2692f5daa6167d2d16a27e37ea4" translate="yes" xml:space="preserve">
          <source>All arguments to bootstrap() are passed to the module's bootstrap function. The default code generated by</source>
          <target state="translated">bootstrap()へのすべての引数は、モジュールのブートストラップ関数に渡されます。によって生成されたデフォルトのコードは</target>
        </trans-unit>
        <trans-unit id="0641330064a33946ad2abf69443076e60a765bfc" translate="yes" xml:space="preserve">
          <source>All bytes in a multi-byte UTF-8 character will have the high bit set, so you can test if you need to do something special with this character like this (the &lt;code&gt;UTF8_IS_INVARIANT()&lt;/code&gt; is a macro that tests whether the byte is encoded as a single byte even in UTF-8):</source>
          <target state="translated">マルチバイトUTF-8文字のすべてのバイトには高ビットが設定されているので、この文字でこのような特別な何かを行う必要があるかどうかをテストできます（ &lt;code&gt;UTF8_IS_INVARIANT()&lt;/code&gt; は、バイトが次のようにエンコードされているかどうかをテストするマクロですUTF-8でも1バイト）：</target>
        </trans-unit>
        <trans-unit id="3518d33b42f2dc03b1a9ce5a7bf1630a8c432554" translate="yes" xml:space="preserve">
          <source>All classes automatically inherit from the &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class, which is built-in to the Perl core. This class provides a number of methods, all of which can be called on either a class or an object. You can also choose to override some of these methods in your class. If you do so, we recommend that you follow the built-in semantics described below.</source>
          <target state="translated">すべてのクラスは、Perlコアに組み込まれている&lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt;クラスから自動的に継承します。このクラスはいくつかのメソッドを提供し、それらはすべてクラスまたはオブジェクトで呼び出すことができます。クラスでこれらのメソッドの一部をオーバーライドすることもできます。その場合は、以下で説明する組み込みのセマンティクスに従うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="01913ce43f34cc16d63eaaa24a00e403aac3c548" translate="yes" xml:space="preserve">
          <source>All classes inherit from the &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class implicitly. The &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class is implemented by the Perl core, and provides several default methods, such as &lt;code&gt;isa()&lt;/code&gt; , &lt;code&gt;can()&lt;/code&gt; , and &lt;code&gt;VERSION()&lt;/code&gt; . The &lt;code&gt;UNIVERSAL&lt;/code&gt; class will</source>
          <target state="translated">すべてのクラスは&lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt;クラスから暗黙的に継承します。&lt;a href=&quot;universal&quot;&gt;ユニバーサル&lt;/a&gt;クラスは、Perlのコアによって実現され、のようないくつかのデフォルトの方法、提供された &lt;code&gt;isa()&lt;/code&gt; 、 &lt;code&gt;can()&lt;/code&gt; 、および &lt;code&gt;VERSION()&lt;/code&gt; 。 &lt;code&gt;UNIVERSAL&lt;/code&gt; のクラスの意志</target>
        </trans-unit>
        <trans-unit id="d7ed55b8e4e0eb9f903d01566d45c62ffc547221" translate="yes" xml:space="preserve">
          <source>All code points that would be matched by this are matched by either &quot;Script_Extensions=Katakana&quot; or &quot;Script_Extensions=Hiragana&quot;</source>
          <target state="translated">これによってマッチするすべてのコードポイントは、 「Script_Extensions=カタカナ」か「Script_Extensions=ひらがな」のいずれかでマッチします。</target>
        </trans-unit>
        <trans-unit id="68b93a9f8c08d5ea78bcf3b0d94efaeadf4ebfe0" translate="yes" xml:space="preserve">
          <source>All command paragraphs (which are typically only one line long) start with &quot;=&quot;, followed by an identifier, followed by arbitrary text that the command can use however it pleases. Currently recognized commands are</source>
          <target state="translated">すべてのコマンドの段落(通常は1行のみの長さ)は&quot;=&quot;で始まり、識別子が続き、その後に任意のテキストが続き、コマンドが好きなように使うことができます。現在認識されているコマンドは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="982b67a682c875ad11cfce0a29c201661fc04837" translate="yes" xml:space="preserve">
          <source>All data in Perl is a scalar, an array of scalars, or a hash of scalars. A scalar may contain one single value in any of three different flavors: a number, a string, or a reference. In general, conversion from one form to another is transparent. Although a scalar may not directly hold multiple values, it may contain a reference to an array or hash which in turn contains multiple values.</source>
          <target state="translated">Perl のすべてのデータはスカラ、スカラの配列、またはスカラのハッシュです。スカラは、数値、文字列、参照の3つの異なる形式のいずれかで1つの値を含むことができます。一般的に,ある形式から別の形式への変換は透過的である.スカラは複数の値を直接保持することはできませんが,配列やハッシュへの参照を含むことができます.</target>
        </trans-unit>
        <trans-unit id="69c2eb01381ceb109c37169bc1329fc48f7a2dca" translate="yes" xml:space="preserve">
          <source>All decryption filters work on the principle of &quot;security through obscurity.&quot; Regardless of how well you write a decryption filter and how strong your encryption algorithm is, anyone determined enough can retrieve the original source code. The reason is quite simple - once the decryption filter has decrypted the source back to its original form, fragments of it will be stored in the computer's memory as Perl parses it. The source might only be in memory for a short period of time, but anyone possessing a debugger, skill, and lots of patience can eventually reconstruct your program.</source>
          <target state="translated">すべての復号化フィルタは 「不明瞭さによるセキュリティ」の原則に基づいて動作する 復号化フィルタをどれだけうまく書けていても、暗号化アルゴリズムがどれだけ強力であっても、十分な判断力があれば誰でも元のソースコードを取り出すことができます。その理由は非常に単純です。一旦復号化フィルタがソースを元の形に復号化すると、Perl が解析する際にその断片がコンピュータのメモリに保存されます。ソースは短期間しかメモリに保存されないかもしれませんが、デバッガとスキルと忍耐力があれば、誰でも最終的にはプログラムを再構築することができます。</target>
        </trans-unit>
        <trans-unit id="ba741a80f2a14355d94b77c4ceb115a27afc7f18" translate="yes" xml:space="preserve">
          <source>All defaults for Configure can be used.</source>
          <target state="translated">Configure のすべてのデフォルトを使用することができます。</target>
        </trans-unit>
        <trans-unit id="acfa01600fe34368d13dbcac106b2c8f27f49465" translate="yes" xml:space="preserve">
          <source>All development releases of perl since 5.9.0 are covered.</source>
          <target state="translated">5.9.0以降のPerlの開発リリースはすべてカバーしています。</target>
        </trans-unit>
        <trans-unit id="df049cfa442a524a56259811400e36eee4811c18" translate="yes" xml:space="preserve">
          <source>All diagnostic output is sent to &lt;code&gt;STDERR&lt;/code&gt; .</source>
          <target state="translated">すべての診断出力は &lt;code&gt;STDERR&lt;/code&gt; に送信されます。</target>
        </trans-unit>
        <trans-unit id="93306c0ef9fe5f266a659b8a075c1bae7f08ce4e" translate="yes" xml:space="preserve">
          <source>All dollar signs must be doubled in the $perl_code if you expect them to be interpreted normally, otherwise it will be considered a make macro. Also remember to quote make macros else it might be used as a bareword. For example:</source>
          <target state="translated">すべてのドル記号が正常に解釈されることを期待している場合、$perl_code内のすべてのドル記号は2倍にしなければなりません。また、make マクロを引用符で囲むことを忘れないでください。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="7a1f8634b122edec02ff5f85c8a73c5f24ae4096" translate="yes" xml:space="preserve">
          <source>All environment vars must be stored in HKLM\Environment as strings. They are read at process startup.</source>
          <target state="translated">すべての環境変数は、文字列として HKLM\Environment に格納されなければならない。それらはプロセスの起動時に読み込まれます。</target>
        </trans-unit>
        <trans-unit id="92b87396d02d1c058e99dc606debd7ebb31b0abf" translate="yes" xml:space="preserve">
          <source>All error reporting is done with exceptions (die'ing).</source>
          <target state="translated">すべてのエラー報告は例外(ダイイング)で行われます。</target>
        </trans-unit>
        <trans-unit id="7a3f297670f9579dd31a61d74a21533ee88a594f" translate="yes" xml:space="preserve">
          <source>All features that combine Unicode and I/O also require using the new PerlIO feature. Almost all Perl 5.8 platforms do use PerlIO, though: you can see whether yours is by running &quot;perl -V&quot; and looking for &lt;code&gt;useperlio=define&lt;/code&gt; .</source>
          <target state="translated">UnicodeとI / Oを組み合わせるすべての機能でも、新しいPerlIO機能を使用する必要があります。ただし、ほとんどすべてのPerl 5.8プラットフォームはPerlIOを使用し &lt;code&gt;useperlio=define&lt;/code&gt; 。「perl -V」を実行してuseperlio = defineを探すことにより、自分のプラットフォームがPerlIOかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="ad80d55320f9dffac4aa0255715379a201879293" translate="yes" xml:space="preserve">
          <source>All file tests (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; ) except for &lt;code&gt;-t&lt;/code&gt; , which defaults to STDIN. See &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; を除くすべてのファイルテスト（ &lt;code&gt;-f&lt;/code&gt; 、 &lt;code&gt;-d&lt;/code&gt; ）。デフォルトはSTDINです。&lt;a href=&quot;functions/-x&quot;&gt;-Xを&lt;/a&gt;参照</target>
        </trans-unit>
        <trans-unit id="815b16d15ecd8197f8c89531e6b38bdaa59c037d" translate="yes" xml:space="preserve">
          <source>All files are stored internally as &lt;code&gt;Archive::Tar::File&lt;/code&gt; objects. Please consult the &lt;a href=&quot;tar/file&quot;&gt;Archive::Tar::File&lt;/a&gt; documentation for details.</source>
          <target state="translated">すべてのファイルは &lt;code&gt;Archive::Tar::File&lt;/code&gt; オブジェクトとして内部的に保存されます。詳細は&lt;a href=&quot;tar/file&quot;&gt;Archive :: Tar :: Fileの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="f073482fc073c0918a2379dd16dc7865e1091f64" translate="yes" xml:space="preserve">
          <source>All files that match any regular expression in a file</source>
          <target state="translated">ファイル内の任意の正規表現にマッチするすべてのファイル</target>
        </trans-unit>
        <trans-unit id="cfa975a72f5514a96c923193276bf554b250a3e3" translate="yes" xml:space="preserve">
          <source>All files used by the program or function, normally presented as a list, and what it uses them for. File names should be enclosed in F&amp;lt;&amp;gt;. It's particularly important to document files that will be potentially modified.</source>
          <target state="translated">プログラムまたは関数によって使用されるすべてのファイル。通常はリストとして表示され、それらが何のために使用されるかを示します。ファイル名はF &amp;lt;&amp;gt;で囲む必要があります。変更される可能性のあるファイルを文書化することは特に重要です。</target>
        </trans-unit>
        <trans-unit id="a2dd9a73e29796f6b2de6625428d9204a9270fdb" translate="yes" xml:space="preserve">
          <source>All filter methods return the existing filter, if present, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if not.</source>
          <target state="translated">すべてのフィルターメソッドは、存在する場合は既存のフィルターを返し、存在しない場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="4139db9439a578bf12cb959a5143dbafa321c592" translate="yes" xml:space="preserve">
          <source>All filter methods return the existing filter, if present, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in not.</source>
          <target state="translated">すべてのフィルターメソッドは、存在する場合は既存のフィルターを返し、存在しない場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="311ff967643c4d237a819b285dc4b5880471f22d" translate="yes" xml:space="preserve">
          <source>All forms of the pragma enable use of the following 3 functions:</source>
          <target state="translated">すべての形式のpragmaは、以下の3つの関数を使用することができます。</target>
        </trans-unit>
        <trans-unit id="74749eec650dc1a9457b607830f24533a5ba9c1c" translate="yes" xml:space="preserve">
          <source>All four routines return the number of arguments that the subroutine returned on the Perl stack.</source>
          <target state="translated">4つのルーチンはすべて、サブルーチンがPerlスタック上で返した引数の数を返します。</target>
        </trans-unit>
        <trans-unit id="5e2132ad2da2d7aa2f6043aad2cc1232db0e47df" translate="yes" xml:space="preserve">
          <source>All functions have the following rules to decide what it thinks you want:</source>
          <target state="translated">すべての機能は、それがあなたが欲しいと思うものを決定するために、次のようなルールを持っています。</target>
        </trans-unit>
        <trans-unit id="7a4768442025565f5f815b90b4d35c19d4f3c9c1" translate="yes" xml:space="preserve">
          <source>All functions return 1 on success, 0 on failure. $! will be set if an error was encountered.</source>
          <target state="translated">すべての関数は成功すると1を返し、失敗すると0を返します。エラーが発生した場合は、$!</target>
        </trans-unit>
        <trans-unit id="6ff8d7d6682320cce258b48a2cf6142f6da6f3bb" translate="yes" xml:space="preserve">
          <source>All functions that are capable of creating filehandles (open(), opendir(), pipe(), socketpair(), sysopen(), socket(), and accept()) automatically create an anonymous filehandle if the handle passed to them is an uninitialized scalar variable. This allows the constructs such as &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh, ...)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $fh,...)&lt;/code&gt; to be used to create filehandles that will conveniently be closed automatically when the scope ends, provided there are no other references to them. This largely eliminates the need for typeglobs when opening filehandles that must be passed around, as in the following example:</source>
          <target state="translated">ファイルハンドルを作成できるすべての関数（open（）、opendir（）、pipe（）、socketpair（）、sysopen（）、socket（）、accept（））は、それらに渡されたハンドルが初期化されていないスカラー変数。これにより、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh, ...)&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $fh,...)&lt;/code&gt; などのコンストラクトを使用して、他に参照がなければ、スコープが終了したときに自動的に閉じるファイルハンドルを作成できます。彼らへ。これにより、次の例のように、受け渡しが必要なファイルハンドルを開くときにタイプグロブが不要になります。</target>
        </trans-unit>
        <trans-unit id="8c0ff391fcad9c66a86b68973a78df205636b6ef" translate="yes" xml:space="preserve">
          <source>All information required to &quot;attach&quot; back to the shared resource object &lt;b&gt;must&lt;/b&gt; be contained &lt;b&gt;only&lt;/b&gt; in the &lt;code&gt;STORABLE_freeze&lt;/code&gt; return string. Otherwise, &lt;code&gt;STORABLE_freeze&lt;/code&gt; behaves as normal for &lt;code&gt;STORABLE_attach&lt;/code&gt; classes.</source>
          <target state="translated">共有リソースオブジェクトに「アタッチ」するために必要なすべての情報は、 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 戻り文字列に&lt;b&gt;のみ&lt;/b&gt;含まれている&lt;b&gt;必要&lt;/b&gt;が&lt;b&gt;あり&lt;/b&gt;ます。それ以外の場合、 &lt;code&gt;STORABLE_freeze&lt;/code&gt; は &lt;code&gt;STORABLE_attach&lt;/code&gt; クラスの場合と同じように動作します。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0ca38b7907bcdd63b3829617b4fa2da1157cda75" translate="yes" xml:space="preserve">
          <source>All inputs to WriteMakefile are Unicode characters, not just octets. EUMM seeks to handle all of these correctly. It is currently still not possible to portably use Unicode characters in module names, because this requires Perl to handle Unicode filenames, which is not yet the case on Windows.</source>
          <target state="translated">WriteMakefileへの入力はすべてUnicode文字であり、オクテットだけではありません。EUMM はこれらすべてを正しく扱おうとしています。モジュール名にUnicode文字を移植的に使用することは現在のところできません。</target>
        </trans-unit>
        <trans-unit id="d69ebadb686cb973f8c2cd133297ec1e0e33a51b" translate="yes" xml:space="preserve">
          <source>All invokes of</source>
          <target state="translated">のすべての呼び出し</target>
        </trans-unit>
        <trans-unit id="4ffd0a2ad25e2bbb80e9fa8d007272b04eac86d9" translate="yes" xml:space="preserve">
          <source>All list elements are numeric and come straight out of the C `struct tm'. &lt;code&gt;$sec&lt;/code&gt; , &lt;code&gt;$min&lt;/code&gt; , and &lt;code&gt;$hour&lt;/code&gt; are the seconds, minutes, and hours of the specified time.</source>
          <target state="translated">すべてのリスト要素は数値であり、Cのstruct tmから直接取得されます。 &lt;code&gt;$sec&lt;/code&gt; 、 &lt;code&gt;$min&lt;/code&gt; 、および &lt;code&gt;$hour&lt;/code&gt; は、指定された時刻の秒、分、および時間です。</target>
        </trans-unit>
        <trans-unit id="b0cbbd027f9d74998550632f8f717d3b9830f840" translate="yes" xml:space="preserve">
          <source>All memory meant to be used with the Perl API functions should be manipulated using the macros described in this section. The macros provide the necessary transparency between differences in the actual malloc implementation that is used within perl.</source>
          <target state="translated">Perl API 関数で使用されるすべてのメモリは、このセクションで説明されているマクロを使用して操作しなければなりません。このマクロは、Perl 内で使用される実際の malloc 実装の違いの間に必要な透明性を提供します。</target>
        </trans-unit>
        <trans-unit id="9a9e166f6a8a9986486a965b0218230a1bd88001" translate="yes" xml:space="preserve">
          <source>All methods provided are accessible in a programmer style and in an interactive shell style.</source>
          <target state="translated">提供されるすべてのメソッドは、プログラマスタイルと対話型シェルスタイルでアクセス可能です。</target>
        </trans-unit>
        <trans-unit id="1459ac0067a9be1ca453815893a04263c9ab6fda" translate="yes" xml:space="preserve">
          <source>All modules should be tested before distribution (using &quot;make disttest&quot;), and the tests should also be available to people installing the modules (using &quot;make test&quot;). For Module::Build you would use the &lt;code&gt;make test&lt;/code&gt; equivalent &lt;code&gt;perl Build test&lt;/code&gt; .</source>
          <target state="translated">すべてのモジュールは配布前にテストする必要があり（「make disttest」を使用）、モジュールをインストールするユーザーもテストを利用できるはずです（「make test」を使用）。Module :: Buildの場合、 &lt;code&gt;make test&lt;/code&gt; に相当する &lt;code&gt;perl Build test&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="45a75ffb3c37d77e5c140116de26483a43d3e7a6" translate="yes" xml:space="preserve">
          <source>All objects belong to a specific class. For example, our</source>
          <target state="translated">すべてのオブジェクトは特定のクラスに属します。例えば、私たちの</target>
        </trans-unit>
        <trans-unit id="758a43e77b8dfcfe840782d07ab7ccfb64e67a82" translate="yes" xml:space="preserve">
          <source>All of Perl's internal functions which will be exposed to the outside world are prefixed by &lt;code&gt;Perl_&lt;/code&gt; so that they will not conflict with XS functions or functions used in a program in which Perl is embedded. Similarly, all global variables begin with &lt;code&gt;PL_&lt;/code&gt; . (By convention, static functions start with &lt;code&gt;S_&lt;/code&gt; .)</source>
          <target state="translated">外部に公開されるすべてのPerlの内部関数には、 &lt;code&gt;Perl_&lt;/code&gt; がプレフィックスとして付けられ、XS関数や、Perlが組み込まれているプログラムで使用される関数と競合しません。同様に、すべてのグローバル変数は &lt;code&gt;PL_&lt;/code&gt; で始まります。（慣例により、静的関数は &lt;code&gt;S_&lt;/code&gt; で始まります。）</target>
        </trans-unit>
        <trans-unit id="f0201779d13335d0611380b1efaab78cf7d99ae8" translate="yes" xml:space="preserve">
          <source>All of Perl's source code is kept centrally in a Git repository at</source>
          <target state="translated">Perl のソースコードはすべて、Git リポジトリに一元管理されています。</target>
        </trans-unit>
        <trans-unit id="f5c3cc30932079fdea98918bb1694882d908dc3a" translate="yes" xml:space="preserve">
          <source>All of the above special cases can occasionally cause some problems. See &lt;a href=&quot;#BUGS-and-CAVEATS&quot;&gt;BUGS and CAVEATS&lt;/a&gt;.</source>
          <target state="translated">上記の特殊なケースはすべて、場合によってはいくつかの問題を引き起こす可能性があります。&lt;a href=&quot;#BUGS-and-CAVEATS&quot;&gt;バグと警告を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0e73d4a25ee89208a71c06aba4a44554f2676c3f" translate="yes" xml:space="preserve">
          <source>All of the core documentation intended for end users lives in</source>
          <target state="translated">エンドユーザーを対象としたコアドキュメントはすべて、以下の場所にあります。</target>
        </trans-unit>
        <trans-unit id="8bb2fabac85e17c62678907ad7293e4a29bfd44a" translate="yes" xml:space="preserve">
          <source>All of the following SvREFCNT_inc* macros are optimized versions of SvREFCNT_inc, and can be replaced with SvREFCNT_inc.</source>
          <target state="translated">以下の SvREFCNT_inc*マクロはすべて,SvREFCNT_inc の最適化版であり,SvREFCNT_inc で置き換えることができます.</target>
        </trans-unit>
        <trans-unit id="82ef093e61dfa9c43730994ceca5ef32106472a3" translate="yes" xml:space="preserve">
          <source>All of the following have helped. Bug reports, patches, (im)moral support, or just words of encouragement have all been forthcoming.</source>
          <target state="translated">以下のすべてが助けになっています。バグレポート、パッチ、(im)道徳的なサポート、あるいは励ましの言葉など、すべてが提供されています。</target>
        </trans-unit>
        <trans-unit id="7491564d89215b867c8e0fd7859217a07aea983b" translate="yes" xml:space="preserve">
          <source>All of the following print &quot;ok&quot; or &quot;not ok&quot; depending on if the test succeeded or failed. They all also return true or false, respectively.</source>
          <target state="translated">以下のすべては、テストが成功したか失敗したかに応じて、&quot;ok &quot;または &quot;not ok &quot;を表示します。また、これらはすべて、それぞれ真または偽を返します。</target>
        </trans-unit>
        <trans-unit id="41e3b701113b5066b37e3af11d04cea9cb6499ec" translate="yes" xml:space="preserve">
          <source>All of these functions will croak on read-only scalars (see the previous section for more on those).</source>
          <target state="translated">これらの関数はすべて,読み取り専用のスカラで動作します(これらについては前のセクションを参照してください).</target>
        </trans-unit>
        <trans-unit id="4ff83273a3484775dac4d0e13bc9dfb2d37a34a0" translate="yes" xml:space="preserve">
          <source>All of these interact with or use &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; which is worth understanding the basics of when building a website in Perl (there is a lot of useful &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%253A%253Amiddleware&quot;&gt;Plack::Middleware&lt;/a&gt;).</source>
          <target state="translated">これらはすべて、&lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt;と相互作用または使用します。これは、PerlでWebサイトを構築するときの基本を理解する価値があります（便利な&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%253A%253Amiddleware&quot;&gt;Plack :: Middlewareが&lt;/a&gt;たくさんあります）。</target>
        </trans-unit>
        <trans-unit id="669764792c2fd17c1b68c9548896f6adc424fb5e" translate="yes" xml:space="preserve">
          <source>All of this is especially useful when perl is embedded in some other program, where output to STDOUT and STDERR may have to be redirected in some special way. See nvi and the Apache module for examples.</source>
          <target state="translated">これらはすべて、perl が他のプログラムに組み込まれている場合に特に便利です。例については nvi と Apache モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="f9469b3540381c36cb61f1bd013bbc92d5d1e0fa" translate="yes" xml:space="preserve">
          <source>All of this occurs in the routine &lt;code&gt;study_chunk()&lt;/code&gt; which uses a special structure &lt;code&gt;scan_data_t&lt;/code&gt; to store the analysis that it has performed, and does the &quot;peep-hole&quot; optimisations as it goes.</source>
          <target state="translated">これはすべて、特別な構造体 &lt;code&gt;scan_data_t&lt;/code&gt; を使用して、実行した分析を保存し、「のぞき穴」最適化を実行するルーチン &lt;code&gt;study_chunk()&lt;/code&gt; で発生します。</target>
        </trans-unit>
        <trans-unit id="52f1e1f474a63fabc7410cc13bd34f20b84caea7" translate="yes" xml:space="preserve">
          <source>All of those strange functions with</source>
          <target state="translated">との奇妙な機能のすべてが</target>
        </trans-unit>
        <trans-unit id="bd329654decca432a697c3105f88903a2261a243" translate="yes" xml:space="preserve">
          <source>All open handles are dup()-ed in pseudo-processes, so that closing any handles in one process does not affect the others. See below for some limitations.</source>
          <target state="translated">開いているハンドルはすべて擬似プロセス内で dup()されているので、あるプロセス内でハンドルを閉じても他のプロセスには影響を与えません。いくつかの制限事項については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="f714b09d9b62651db015cac63428a3e648501bda" translate="yes" xml:space="preserve">
          <source>All operations above are performed simultaneously, left to right.</source>
          <target state="translated">上記の操作は、左から右へ、すべて同時に行われます。</target>
        </trans-unit>
        <trans-unit id="2c5dee63173bc6728f471c2ffbe6ede7b9622657" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) are overloaded if you declare your big floating point numbers as</source>
          <target state="translated">大きな浮動小数点数を</target>
        </trans-unit>
        <trans-unit id="47240c2bd1c42148438e132fbe97c4470bd81a8b" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) are overloaded if you declare your big integers as</source>
          <target state="translated">大規模な整数を</target>
        </trans-unit>
        <trans-unit id="8aea450e6db040db0c87b5e94c4f04af81589adb" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) are overloaded. Integer and floating-point constants are created as proper BigInts or BigFloats, respectively.</source>
          <target state="translated">すべての演算子(基本的な数学演算を含む)はオーバーロードされます。整数定数と浮動小数点定数は、それぞれ適切なBigIntsまたはBigFloatsとして作成されます。</target>
        </trans-unit>
        <trans-unit id="97e8744f2aba4f4c5299d3315f0e922fa7662452" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) except the range operator &lt;code&gt;..&lt;/code&gt; are overloaded. Integer constants are created as proper BigInts.</source>
          <target state="translated">範囲演算子 &lt;code&gt;..&lt;/code&gt; を除くすべての演算子（基本的な数学演算を含む）はオーバーロードされます。整数定数は適切なBigIntsとして作成されます。</target>
        </trans-unit>
        <trans-unit id="d94d5908e53102da28ed793d2b7b1e3aac035e25" translate="yes" xml:space="preserve">
          <source>All options are passed either via the &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, or via an explicit &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">すべてのオプションは、 &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ステートメントを介して、または明示的な &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; を介して渡されます。</target>
        </trans-unit>
        <trans-unit id="6af1c2304a59b49a5e4c4bb3624f5d7d2569e662" translate="yes" xml:space="preserve">
          <source>All other arguments are optional and should correspond to filehandles to read from or the names of input files containing POD sections. A file name of &quot;&quot;, &quot;-&quot; or &quot;&amp;lt;&amp;amp;STDIN&quot; will be interpreted to mean standard input (which is the default if no arguments are given).</source>
          <target state="translated">他のすべての引数はオプションであり、読み取るファイルハンドルまたはPODセクションを含む入力ファイルの名前に対応している必要があります。「」、「-」、または「&amp;lt;＆STDIN」のファイル名は、標準入力を意味すると解釈されます（引数が指定されていない場合のデフォルト）。</target>
        </trans-unit>
        <trans-unit id="7f44679a6de4260413fa97b63aefa6bbb62b1b1f" translate="yes" xml:space="preserve">
          <source>All other code points corresponding to Unicode characters, including private use and those yet to be assigned, are never considered malformed and never warn.</source>
          <target state="translated">私用やまだ割り当てられていないものも含めて、Unicode キ ャ ラ ク タ に対応する他のすべての コ ー ド 点は、 決して不正な形である と は見なされず、 警告 さ れることもありません。</target>
        </trans-unit>
        <trans-unit id="9abb59ed9447dcd04c7f87e709793152669bc13e" translate="yes" xml:space="preserve">
          <source>All other errors may be trapped using the modern interface, otherwise they will be &lt;code&gt;carp&lt;/code&gt; ed about. Program execution will not be halted.</source>
          <target state="translated">他のすべてのエラーは、そうでなければなり、近代的なインタフェースを使用して捕捉することが可能 &lt;code&gt;carp&lt;/code&gt; について編。プログラムの実行は停止されません。</target>
        </trans-unit>
        <trans-unit id="87f6ed6f32251cf3d91bc227de27a29b35179c3f" translate="yes" xml:space="preserve">
          <source>All other implemented styles of rounding attempt to round to the &quot;nearest digit.&quot; If the digit D immediately to the right of the rounding place (skipping the decimal point) is greater than 5, the number is incremented at the rounding place (possibly causing a cascade of incrementation): e.g. when rounding to units, 0.9 rounds to 1, and -19.9 rounds to -20. If D &amp;lt; 5, the number is similarly truncated at the rounding place: e.g. when rounding to units, 0.4 rounds to 0, and -19.4 rounds to -19.</source>
          <target state="translated">他のすべての実装された丸めスタイルは、「最も近い数字」に丸めようとします。丸め場所のすぐ右側の桁D（小数点をスキップ）が5より大きい場合、数値は丸め場所で増分されます（増分のカスケードが発生する可能性があります）。たとえば、単位に丸める場合、0.9は1に丸められます。 、-19.9は-20に丸められます。 D &amp;lt;5の場合、数値は丸めの場所で同様に切り捨てられます。たとえば、単位に丸める場合、0.4は0に丸められ、-19.4は-19に丸められます。</target>
        </trans-unit>
        <trans-unit id="0673283fae5e4cb931ef195f174d0d6b1d1f68b5" translate="yes" xml:space="preserve">
          <source>All other methods upgrade themselves only when one (or all) of their arguments are of the class mentioned in $upgrade (This might change in later versions to a more sophisticated scheme):</source>
          <target state="translated">他のすべてのメソッドは、引数のひとつ (あるいはすべて)が $upgrade で指定したクラスのものである場合にのみ、自分自身をアップグレードします (これは後のバージョンでは、より洗練されたスキームに変更されるかもしれません)。</target>
        </trans-unit>
        <trans-unit id="5e2040cfcc351c3e2d5a5185b8c874a98a40126c" translate="yes" xml:space="preserve">
          <source>All other object methods and overloaded functions can be directly inherited from the parent class.</source>
          <target state="translated">他のすべてのオブジェクトメソッドとオーバーロードされた関数は、親クラスから直接継承することができます。</target>
        </trans-unit>
        <trans-unit id="b83a0c68243d6a9c451b88def8620109da8b38fe" translate="yes" xml:space="preserve">
          <source>All other parameters that control the content of the gzip header will be ignored if this parameter is set to 1.</source>
          <target state="translated">このパラメータが1に設定されている場合、 gzipヘッダの内容を制御する他のすべてのパラメータは無視される。</target>
        </trans-unit>
        <trans-unit id="6c37ee1b0941f972f146000c72b7c3b6715243db" translate="yes" xml:space="preserve">
          <source>All possible messages the program can print out and what they mean. You may wish to follow the same documentation style as the Perl documentation; see perldiag(1) for more details (and look at the POD source as well).</source>
          <target state="translated">プログラムが出力できるすべての可能性のあるメッセージとその意味。詳細は perldiag(1)を参照してください (POD のソースも参照してください)。</target>
        </trans-unit>
        <trans-unit id="604e2a22c32db1e7a6f30a5a33e18c36a9822954" translate="yes" xml:space="preserve">
          <source>All printable characters, which is the set of all graphical characters plus those whitespace characters which are not also controls.</source>
          <target state="translated">すべての印刷可能な文字は、すべてのグラフィカルな文字とコントロールではない空白文字のセットです。</target>
        </trans-unit>
        <trans-unit id="5f0cb252127c0b51324ce6af0cb1b37825719005" translate="yes" xml:space="preserve">
          <source>All questions related to building for WinCE devices could be asked in</source>
          <target state="translated">WinCE デバイスの構築に関連するすべての質問は、以下で行うことができます。</target>
        </trans-unit>
        <trans-unit id="af228b0481468b2f1d341e2655d2bfbf46fb813b" translate="yes" xml:space="preserve">
          <source>All references to line numbers by the program (warnings, errors, ...) will treat the &lt;code&gt;#!&lt;/code&gt; line as the first line. Thus a warning on the 2nd line of the program, which is on the 100th line in the file will be reported as line 2, not as line 100. This can be overridden by using the &lt;code&gt;#line&lt;/code&gt; directive. (See &lt;a href=&quot;perlsyn#Plain-Old-Comments-(Not!)&quot;&gt;Plain Old Comments (Not!) in perlsyn&lt;/a&gt;)</source>
          <target state="translated">プログラムによる行番号へのすべての参照（警告、エラーなど）は、 &lt;code&gt;#!&lt;/code&gt; を扱います。最初の行として行。したがって、ファイルの100行目にあるプログラムの2行目の警告は、100行ではなく2行として報告されます。これは、 &lt;code&gt;#line&lt;/code&gt; line ディレクティブを使用してオーバーライドできます。 （&lt;a href=&quot;perlsyn#Plain-Old-Comments-(Not!)&quot;&gt;perlsynのPlain Old Comments（Not！）を&lt;/a&gt;参照してください）</target>
        </trans-unit>
        <trans-unit id="e60ba7561109a1c032c7ac0364a6dfa0ffa088bc" translate="yes" xml:space="preserve">
          <source>All results share some common attributes:</source>
          <target state="translated">すべての結果は、いくつかの共通の属性を持っています。</target>
        </trans-unit>
        <trans-unit id="1a067ae12ba3c0d999a29e551f40bb7142e1e1b0" translate="yes" xml:space="preserve">
          <source>All rounding functions take as a second parameter a rounding mode from one of the following: 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'.</source>
          <target state="translated">すべての丸め関数は、2 番目のパラメータとして、以下のいずれかの丸めモードを取ります。even'、'odd'、'+inf'、'-inf'、'zero'、'trunc'、'common'のいずれかです。</target>
        </trans-unit>
        <trans-unit id="2b331c6fdc80ccf345de0513f8a62b9eab6492a7" translate="yes" xml:space="preserve">
          <source>All routines expect to be given real or complex numbers. Don't attempt to use BigFloat, since Perl has currently no rule to disambiguate a '+' operation (for instance) between two overloaded entities.</source>
          <target state="translated">すべてのルーチンは、実数または複素数が与えられることを期待しています。現在のところ、Perlには、2つのオーバーロードされた実体間の'+'演算(例えば)を曖昧さをなくすルールがないので、BigFloatを使用しようとしないでください。</target>
        </trans-unit>
        <trans-unit id="e55cf27d1ee5fe9a7d51e12a991cd2052b26c3ef" translate="yes" xml:space="preserve">
          <source>All single forms are Perl extensions; a few compound forms are as well, and are noted as such.</source>
          <target state="translated">単一の形式はすべて Perl の拡張で、いくつかの複合形式も同様で、そのように表記されています。</target>
        </trans-unit>
        <trans-unit id="47270bc8154b38c6bf8c6928d77cd1d441578544" translate="yes" xml:space="preserve">
          <source>All stable releases of perl since 5.6.0 are covered.</source>
          <target state="translated">5.6.0 以降の perl の安定版リリースをすべてカバーしています。</target>
        </trans-unit>
        <trans-unit id="eab81422eaa753ceb04583bd0ca24dcc4c83f889" translate="yes" xml:space="preserve">
          <source>All subpatterns, either delivered as a list-context result or as &lt;code&gt;$1&lt;/code&gt;</source>
          <target state="translated">リストコンテキストの結果または &lt;code&gt;$1&lt;/code&gt; として配信されるすべてのサブパターン</target>
        </trans-unit>
        <trans-unit id="48589ddd875d011fdf990744a29e7ccd3465ffa6" translate="yes" xml:space="preserve">
          <source>All subsequent characters can be letters, numbers (0-9), hyphens (-), underscores (_), colons (:), and periods (.).</source>
          <target state="translated">後続のすべての文字は、文字、数字 (0-9)、ハイフン (-)、アンダースコア (_)、コロン (:)、ピリオド (.)です。</target>
        </trans-unit>
        <trans-unit id="42ba1038004475ab41cd7a5ef01656aad2449ad3" translate="yes" xml:space="preserve">
          <source>All systems use the virtual &lt;code&gt;&quot;\n&quot;&lt;/code&gt; to represent a line terminator, called a &quot;newline&quot;. There is no such thing as an unvarying, physical newline character. It is only an illusion that the operating system, device drivers, C libraries, and Perl all conspire to preserve. Not all systems read &lt;code&gt;&quot;\r&quot;&lt;/code&gt; as ASCII CR and &lt;code&gt;&quot;\n&quot;&lt;/code&gt; as ASCII LF. For example, on the ancient Macs (pre-MacOS X) of yesteryear, these used to be reversed, and on systems without a line terminator, printing &lt;code&gt;&quot;\n&quot;&lt;/code&gt; might emit no actual data. In general, use &lt;code&gt;&quot;\n&quot;&lt;/code&gt; when you mean a &quot;newline&quot; for your system, but use the literal ASCII when you need an exact character. For example, most networking protocols expect and prefer a CR+LF (&lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; or &lt;code&gt;&quot;\cM\cJ&quot;&lt;/code&gt; ) for line terminators, and although they often accept just &lt;code&gt;&quot;\012&quot;&lt;/code&gt; , they seldom tolerate just &lt;code&gt;&quot;\015&quot;&lt;/code&gt; . If you get in the habit of using &lt;code&gt;&quot;\n&quot;&lt;/code&gt; for networking, you may be burned some day.</source>
          <target state="translated">すべてのシステムは仮想 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; を使用して、「改行」と呼ばれる行末記号を表します。変化のない、物理的な改行文字などはありません。オペレーティングシステム、デバイスドライバー、Cライブラリ、Perlが共存して共存しているのは幻想にすぎません。すべてのシステムが &lt;code&gt;&quot;\r&quot;&lt;/code&gt; をASCII CRとして読み取り、 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; をASCII LFとして読み取るわけではありません。たとえば、往年の古代Mac（MacOS Xより前）では、これらは逆転していました。ラインターミネータのないシステムでは、 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 印刷しても実際のデータが出力されない場合がありました。一般に、システムの「改行」を意味する場合は &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 使用しますが、正確な文字が必要な場合はリテラルASCIIを使用します。例えば、ほとんどのネットワークプロトコルでは、CR + LF（ &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; または &lt;code&gt;&quot;\cM\cJ&quot;&lt;/code&gt; ）行終端記号の場合、 &lt;code&gt;&quot;\012&quot;&lt;/code&gt; だけを受け入れることが多いが、 &lt;code&gt;&quot;\015&quot;&lt;/code&gt; だけを許容することはめったにない。ネットワーキングに &lt;code&gt;&quot;\n&quot;&lt;/code&gt; を使用する習慣をつけると、いつかやけどをする可能性があります。</target>
        </trans-unit>
        <trans-unit id="fb8ea7b6eceda9fa2e8d1025a7231d980eabe21a" translate="yes" xml:space="preserve">
          <source>All test functions take a name argument. It's optional, but highly suggested that you use it.</source>
          <target state="translated">すべてのテスト関数は名前の引数を取ります。これは任意ですが、使用することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="08563314f6fd252cfab4add5f5d112e141d01e88" translate="yes" xml:space="preserve">
          <source>All tests are run in scalar context. So this:</source>
          <target state="translated">すべてのテストはスカラーコンテキストで実行されます。だからこれは</target>
        </trans-unit>
        <trans-unit id="9e1df8eee4a1033ecd0a19707416e97c2ada1eab" translate="yes" xml:space="preserve">
          <source>All tests should succeed (with some of them skipped). If you have the same version of Perl installed, it is crucial that you have &lt;code&gt;.&lt;/code&gt; early in your LIBPATH (or in BEGINLIBPATH), otherwise your tests will most probably test the wrong version of Perl.</source>
          <target state="translated">すべてのテストが成功するはずです（一部のテストはスキップされます）。同じバージョンのPerlがインストールされている場合は、それが重要です &lt;code&gt;.&lt;/code&gt; LIBPATH（またはBEGINLIBPATH）の早い段階で、それ以外の場合、テストはおそらく間違ったバージョンのPerlをテストします。</target>
        </trans-unit>
        <trans-unit id="525c6957ea6de35e124ab99764227b6cdf29f16d" translate="yes" xml:space="preserve">
          <source>All tests were conducted on the oldest supported AIX technology level with the latest support package applied. If the tested AIX version is out of support (AIX 4.3.3, 5.1, 5.2) then the last available support level was used.</source>
          <target state="translated">すべてのテストは、最新のサポートパッケージを適用した、最も古いサポートされているAIXテクノロジーレベルで実施されました。テストされたAIXバージョンがサポートされていない場合(AIX 4.3.3.3、5.1、5.2)、最後に利用可能なサポートレベルが使用されました。</target>
        </trans-unit>
        <trans-unit id="39ef06ab79291a214e8f7d5dbacda492f3f9bc96" translate="yes" xml:space="preserve">
          <source>All the</source>
          <target state="translated">すべての</target>
        </trans-unit>
        <trans-unit id="6adc75ada238ccb6959bf3be512aa6c8d041cf3e" translate="yes" xml:space="preserve">
          <source>All the DLLs built with the current versions of Perl have ID strings identifying the name of the extension, its version, and the version of Perl required for this DLL. Run &lt;code&gt;bldlevel DLL-name&lt;/code&gt; to find this info.</source>
          <target state="translated">現在のバージョンのPerlでビルドされたすべてのDLLには、拡張機能の名前、そのバージョン、およびこのDLLに必要なPerlのバージョンを識別するID文字列があります。この情報を見つけるには、 &lt;code&gt;bldlevel DLL-name&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="bf0f04a776f7c27f1c272831fed2f282bc5d62df" translate="yes" xml:space="preserve">
          <source>All the above &quot;don't&quot;:s may look daunting, and they are, but the key is to degrade gracefully if one cannot reach the particular network service one wants. Croaking or hanging do not look very professional.</source>
          <target state="translated">上記のすべての「しないでください」は、大変なことのように見えるかもしれませんが、重要なのは、特定のネットワークサービスに到達できない場合には、優雅に劣化させることです。唸ったり、ぶら下がったりするのは、非常にプロフェッショナルには見えません。</target>
        </trans-unit>
        <trans-unit id="4b15325c472386a4b2fcce8cfa22d048d90743b2" translate="yes" xml:space="preserve">
          <source>All the above operations</source>
          <target state="translated">上記のすべての操作</target>
        </trans-unit>
        <trans-unit id="18c65db4629a7b0de1b15db2854f6c3f0396dc3a" translate="yes" xml:space="preserve">
          <source>All the advice contained in this document has been gleaned from extensive conversations with experienced CPAN authors and users. Every piece of advice given here is the result of previous mistakes. This information is here to help you avoid the same mistakes and the extra work that would inevitably be required to fix them.</source>
          <target state="translated">本書に記載されているすべてのアドバイスは、経験豊富なCPANの著者やユーザーとの広範な会話から得られたものです。ここに記載されているアドバイスはすべて、過去に犯した間違いの結果です。この情報は、同じ過ちを犯したり、それを修正するために必然的に必要となる余計な作業を避けるために提供されています。</target>
        </trans-unit>
        <trans-unit id="035cec5a0531d1b6a2296cd59ca2814d6d18a1bb" translate="yes" xml:space="preserve">
          <source>All the binary operators left associate; &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; is higher precedence than the others, which all have equal precedence. The unary operator right associates, and has highest precedence. Thus this follows the normal Perl precedence rules for logical operators. Use parentheses to override the default precedence and associativity.</source>
          <target state="translated">すべての二項演算子は関連付けられたままです。 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; は他のすべてよりも優先順位が高く、すべてが同じ優先順位を持っています。単項演算子の権限は関連付けられ、最高の優先順位を持ちます。したがって、これは論理演算子の通常のPerl優先規則に従います。括弧を使用して、デフォルトの優先順位と結合性をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="a6d917ce9244febe094ff576631bcd960c5f5696" translate="yes" xml:space="preserve">
          <source>All the common mathematical functions defined on real numbers that are extended to complex numbers share that same property of working</source>
          <target state="translated">複素数に拡張された実数上で定義されたすべての一般的な数学関数は,同じ性質を持っています.</target>
        </trans-unit>
        <trans-unit id="c39940047cd8d69a382c58b19f467066fdda2d58" translate="yes" xml:space="preserve">
          <source>All the common operations that can be performed on a real number have been defined to work on complex numbers as well, and are merely</source>
          <target state="translated">実数に対して実行できるすべての一般的な操作は複素数に対しても動作するように定義されており、単に</target>
        </trans-unit>
        <trans-unit id="af40a4a3889be35304f9f526d3725dd711506782" translate="yes" xml:space="preserve">
          <source>All the constants defined in &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt; for use in the flags parameters in the methods defined below are also available. Refer to the Berkeley DB documentation for the precise meaning of the flags values.</source>
          <target state="translated">以下に定義されているメソッドのフラグパラメータで使用するために&lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt;で定義されているすべての定数も使用できます。フラグ値の正確な意味については、Berkeley DBのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="90dde32e9abf15d2dcbf6ab5b218367d1761ce60" translate="yes" xml:space="preserve">
          <source>All the data uses to generate the &lt;code&gt;%Extensions&lt;/code&gt; hash is already present in the &lt;code&gt;Config&lt;/code&gt; module, but not in such a convenient format to quickly reference.</source>
          <target state="translated">&lt;code&gt;%Extensions&lt;/code&gt; ハッシュを生成するために使用するすべてのデータは、 &lt;code&gt;Config&lt;/code&gt; モジュールにすでに存在しますが、すばやく参照するのに便利な形式ではありません。</target>
        </trans-unit>
        <trans-unit id="0d00162e91300896732fceff8f7c85a986709fae" translate="yes" xml:space="preserve">
          <source>All the examples so far have shown objects based on a blessed hash. However, it's possible to bless any type of data structure or referent, including scalars, globs, and subroutines. You may see this sort of thing when looking at code in the wild.</source>
          <target state="translated">これまでのすべての例は、祝福されたハッシュに基づいたオブジェクトを示しています。しかし、スカラ、グロブ、サブルーチンなど、あらゆるタイプのデータ構造や参照元を祝福することが可能です。野生のコードを見ていると、このようなものを目にすることがあるかもしれません。</target>
        </trans-unit>
        <trans-unit id="f288780205f670aaf71d07523bf6fc9a50b071fd" translate="yes" xml:space="preserve">
          <source>All the exportable functions are listed below -- you're free to import only some, or none at all. By default, none are imported. If you say:</source>
          <target state="translated">エクスポート可能な関数はすべて以下のリストにありますが、一部だけをインポートすることも、全くインポートしないことも自由です。デフォルトでは、何もインポートされません。もしあなたが</target>
        </trans-unit>
        <trans-unit id="dc02c5d731db84c233601bd3b09aab07385ecc22" translate="yes" xml:space="preserve">
          <source>All the functions defined in &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt; are available except for close() and dbopen() itself. The &lt;b&gt;DB_File&lt;/b&gt; method interface to the supported functions have been implemented to mirror the way Berkeley DB works whenever possible. In particular note that:</source>
          <target state="translated">close（）とdbopen（）自体を除いて、&lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopenで&lt;/a&gt;定義されているすべての関数を使用できます。サポートされている関数への&lt;b&gt;DB_File&lt;/b&gt;メソッドインターフェースが実装され、Berkeley DBの動作を可能な限り反映します。特に次のことに注意してください。</target>
        </trans-unit>
        <trans-unit id="85af2ce50ee2f541004fc9d53df5f4d00e80abb3" translate="yes" xml:space="preserve">
          <source>All the functions may be imported using the &lt;code&gt;:ALL&lt;/code&gt; tag.</source>
          <target state="translated">&lt;code&gt;:ALL&lt;/code&gt; タグを使用して、すべての関数をインポートできます。</target>
        </trans-unit>
        <trans-unit id="e17de002dfef54a49f116af6d04ace151f1db1a1" translate="yes" xml:space="preserve">
          <source>All the functions return an integer. This is a count of the number of items returned by the Perl subroutine. The actual items returned by the subroutine are stored on the Perl stack.</source>
          <target state="translated">すべての関数は整数を返します。これはPerlのサブルーチンが返した項目の数をカウントしたものです。実際にサブルーチンによって返された項目はPerlスタックに格納されます。</target>
        </trans-unit>
        <trans-unit id="52532a7385f2fd6662a92f143b996eb16f224ae0" translate="yes" xml:space="preserve">
          <source>All the gzip headers defined in RFC 1952 can be created using this module.</source>
          <target state="translated">RFC 1952 で定義されているすべての gzip ヘッダは、このモジュールを使って作成することができます。</target>
        </trans-unit>
        <trans-unit id="51037cd1e5bef0efdf785304da29a37a7b0cdc06" translate="yes" xml:space="preserve">
          <source>All the modules and switches just described can be used in v5.20 with just plain &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , and, should the input locales not be UTF-8, you'll get the less than ideal behavior, described below, that you get with pre-v5.16 Perls, or when you use the locale pragma without the &lt;code&gt;:not_characters&lt;/code&gt; parameter in v5.16 and v5.18. If you are using exclusively UTF-8 locales in v5.20 and higher, the rest of this section does not apply to you.</source>
          <target state="translated">今説明したすべてのモジュールとスイッチは、v5.20で単純な &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; だけで使用できます。入力ロケールがUTF-8でない場合は、preで得られる以下の理想的な動作が得られません。 -v5.16 Perl、またはv5.16とv5.18で &lt;code&gt;:not_characters&lt;/code&gt; パラメーターなしでロケールプラグマを使用する場合。v5.20以降でUTF-8ロケールのみを使用している場合、このセクションの残りの部分は適用されません。</target>
        </trans-unit>
        <trans-unit id="6bcfac1e4c22e90a7b2f875c6b72f2c0d403c1be" translate="yes" xml:space="preserve">
          <source>All the operators which need an argument in the integer format treat the argument as in modular arithmetic, e.g., &lt;code&gt;mod 2**32&lt;/code&gt; on a 32-bit architecture. &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, -1&lt;/code&gt; therefore provides the same result as &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, ~0&lt;/code&gt; .</source>
          <target state="translated">整数形式の引数を必要とするすべての演算子は、引数をモジュラー演算のように扱います。たとえば、32ビットアーキテクチャでは &lt;code&gt;mod 2**32&lt;/code&gt; です。したがって &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, -1&lt;/code&gt; &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;％u&quot;、-1は、 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, ~0&lt;/code&gt; と同じ結果を提供します。</target>
        </trans-unit>
        <trans-unit id="a4fb9683d7bd9f1429d51b7805c318a33084783c" translate="yes" xml:space="preserve">
          <source>All the other macros which will be used in this example require you to have used this macro.</source>
          <target state="translated">この例で使用する他のすべてのマクロは、このマクロを使用している必要があります。</target>
        </trans-unit>
        <trans-unit id="b08b2f77f4eeb817def95bb1cac60c09fd5e4ffe" translate="yes" xml:space="preserve">
          <source>All the others are scalar types, that is, things that can be bound to a &lt;code&gt;$&lt;/code&gt; variable. For these, the internal types are mostly orthogonal to types in the Perl language.</source>
          <target state="translated">その他はすべてスカラー型、つまり &lt;code&gt;$&lt;/code&gt; 変数にバインドできるものです。これらの場合、内部型はほとんどがPerl言語の型と直交しています。</target>
        </trans-unit>
        <trans-unit id="813e0349f99be3e1ec9a99a0d6e9329cddd2f012" translate="yes" xml:space="preserve">
          <source>All the properties that begin with &lt;code&gt;\p&lt;/code&gt; (and its inverse &lt;code&gt;\P&lt;/code&gt; ) are actually character classes that are Unicode-aware. There are dozens of them, see &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\p&lt;/code&gt; （およびその逆の &lt;code&gt;\P&lt;/code&gt; ）で始まるすべてのプロパティは、実際にはUnicode対応の文字クラスです。それらは数十あります&lt;a href=&quot;perluniprops&quot;&gt;。perlunipropsを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0b65a75a2da1466ad79df3a0e8287f617c933054" translate="yes" xml:space="preserve">
          <source>All the sequences and escapes</source>
          <target state="translated">すべてのシーケンスとエスケープ</target>
        </trans-unit>
        <trans-unit id="6f5a47adb9e53e6ad59a65ed39b02f84d8f84ac1" translate="yes" xml:space="preserve">
          <source>All the supported functions should be called as methods, i.e., either as</source>
          <target state="translated">サポートされているすべての関数は、メソッドとして呼ばれなければなりません。</target>
        </trans-unit>
        <trans-unit id="7e345efa9c5194482201d78c3449d77663639ae8" translate="yes" xml:space="preserve">
          <source>All the talk in the world is useless without an implementation. In almost every case, the person or people who argue for a new feature will be expected to be the ones who implement it. Porters capable of coding new features have their own agendas, and are not available to implement your (possibly good) idea.</source>
          <target state="translated">世の中のすべての話は、実装がなければ意味がありません。ほとんどすべての場合において、新機能を主張する人や人々は、それを実装する人であることが期待されます。新しい機能をコーディングすることができるポータは、それぞれのアジェンダを持っていて、あなたの(おそらく良い)アイデアを実装することができません。</target>
        </trans-unit>
        <trans-unit id="8a484c468483007c96c3a2efbbc829000cb69672" translate="yes" xml:space="preserve">
          <source>All the usual warnings about file locking apply here. In particular, note that file locking in Perl is &lt;b&gt;advisory&lt;/b&gt;, which means that holding a lock will not prevent anyone else from reading, writing, or erasing the file; it only prevents them from getting another lock at the same time. Locks are analogous to green traffic lights: If you have a green light, that does not prevent the idiot coming the other way from plowing into you sideways; it merely guarantees to you that the idiot does not also have a green light at the same time.</source>
          <target state="translated">ここでは、ファイルロックに関する通常の警告がすべて適用されます。特に、Perlでのファイルのロックは&lt;b&gt;助言&lt;/b&gt;であることに注意してください。つまり、ロックを保持しても、他のユーザーによるファイルの読み取り、書き込み、または消去が妨げられることはありません。それらが同時に別のロックを取得するのを防ぐだけです。ロックは緑の信号機に似ています。緑の信号灯があっても、逆方向に馬鹿が横に侵入するのを防ぐことはできません。それはあなたに馬鹿が同時に青信号も持っていないことをあなたに保証するだけです。</target>
        </trans-unit>
        <trans-unit id="7e349ac65c026bbc32c4eb141cc9c0c2c6c1c9d7" translate="yes" xml:space="preserve">
          <source>All the work of numeric conversion is done in %subr and num(). Of course, %subr is not complete, it contains only operators used in the example below. Here is the extra-credit question: why do we need an explicit recursion in num()? (Answer is at the end of this section.)</source>
          <target state="translated">数値変換のすべての作業は %subr と num()で行われます。もちろん、%subrは完全ではなく、以下の例で使用されている演算子のみを含んでいます。ここで、余計な質問があります:なぜ num()で明示的な再帰が必要なのか? (答えはこのセクションの最後にあります。)</target>
        </trans-unit>
        <trans-unit id="0f15e65c6cfe10e49621033c9085af7927a8ea20" translate="yes" xml:space="preserve">
          <source>All these commands are callable via method interface and have names which conform to standard conventions with the leading &lt;code&gt;rl_&lt;/code&gt; stripped.</source>
          <target state="translated">これらのコマンドはすべて、メソッドインターフェイスを介して &lt;code&gt;rl_&lt;/code&gt; ができ、先頭のrl_を取り除いた標準の規則に準拠した名前が付けられています。</target>
        </trans-unit>
        <trans-unit id="1a68fff09705709c0c5d238842991f6619aad537" translate="yes" xml:space="preserve">
          <source>All these flags require &lt;b&gt;-DDEBUGGING&lt;/b&gt; when you compile the Perl executable (but see &lt;code&gt;:opd&lt;/code&gt; in &lt;a href=&quot;devel/peek&quot;&gt;Devel::Peek&lt;/a&gt; or &lt;a href=&quot;re#'debug'-mode&quot;&gt;'debug' mode in re&lt;/a&gt; which may change this). See the</source>
          <target state="translated">これらのフラグはすべて、Perl実行可能ファイルをコンパイルするときに&lt;b&gt;-DDEBUGGINGを&lt;/b&gt;必要とします（ただし、&lt;a href=&quot;devel/peek&quot;&gt;Devel :: Peekの&lt;/a&gt; &lt;code&gt;:opd&lt;/code&gt; またはこれを変更する可能性がある&lt;a href=&quot;re#'debug'-mode&quot;&gt;reの「デバッグ」モードを&lt;/a&gt;参照してください）。を参照してください</target>
        </trans-unit>
        <trans-unit id="4fa65daee4b35c0bdf01aba1673c1bba399f82d9" translate="yes" xml:space="preserve">
          <source>All these lines will have the same effect on the state of the $md5 object:</source>
          <target state="translated">これらの行はすべて、$md5オブジェクトの状態に同じ効果をもたらします。</target>
        </trans-unit>
        <trans-unit id="9bcd9b22dce2b631b5e9d54d48830f4469977758" translate="yes" xml:space="preserve">
          <source>All these variables have no effect on a newer Perl which supports the relevant feature.</source>
          <target state="translated">これらの変数はすべて、関連する機能をサポートしている新しい Perl には影響しません。</target>
        </trans-unit>
        <trans-unit id="75179ef80cbabbf7cf9ad45aff86010dedc268e1" translate="yes" xml:space="preserve">
          <source>All this obviously requires a way for the Perl internal functions to be either subroutines taking some kind of structure as the first argument, or subroutines taking nothing as the first argument. To enable these two very different ways of building the interpreter, the Perl source (as it does in so many other situations) makes heavy use of macros and subroutine naming conventions.</source>
          <target state="translated">これは明らかに、Perlの内部関数が何らかの構造体を第一引数に取るサブルーチンか、何も第一引数に取らないサブルーチンのどちらかになるようにする必要があります。これら2つの全く異なる方法でインタプリタを構築できるようにするために、Perlのソースでは(他の多くの状況でそうであるように)マクロとサブルーチンの命名規則を多用しています。</target>
        </trans-unit>
        <trans-unit id="05bb57d634b2fcc45dc9babcad96740ee2e8f313" translate="yes" xml:space="preserve">
          <source>All this should be handled automatically by the hints file, if requested.</source>
          <target state="translated">このすべての処理は、要求された場合、ヒントファイルによって自動的に処理されるべきです。</target>
        </trans-unit>
        <trans-unit id="7381ecad8164c50156cc34405ade99393869ea97" translate="yes" xml:space="preserve">
          <source>All those functions (red(), blue(), green(), etc.) appear to be separate, but the real code in the closure actually was compiled only once.</source>
          <target state="translated">これらの関数(red()、blue()、green()など)はすべて別のもののように見えますが、クロージャ内の実際のコードは実際には一度だけコンパイルされました。</target>
        </trans-unit>
        <trans-unit id="1eb3cfb093a32021b17dfa327362fe2a1ecb7499" translate="yes" xml:space="preserve">
          <source>All threads blocking on &lt;code&gt;dequeue()&lt;/code&gt; calls will be unblocked with any remaining items in the queue and/or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; being returned. Any subsequent calls to &lt;code&gt;dequeue()&lt;/code&gt; will behave like &lt;code&gt;dequeue_nb()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;dequeue()&lt;/code&gt; 呼び出しでブロックされているすべてのスレッドは、ブロック解除され、キューに残っているアイテムや &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。以降の &lt;code&gt;dequeue()&lt;/code&gt; の呼び出しは、 &lt;code&gt;dequeue_nb()&lt;/code&gt; のように動作します。</target>
        </trans-unit>
        <trans-unit id="31b59027aac85c24edba2402c4b5479124b0b5b8" translate="yes" xml:space="preserve">
          <source>All three APIs &lt;code&gt;fill_mstats($buf)&lt;/code&gt; , &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt; , and &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; are designed to allocate no memory if used</source>
          <target state="translated">3つのすべてのAPI &lt;code&gt;fill_mstats($buf)&lt;/code&gt; 、 &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt; 、および &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; は、使用してもメモリを割り当てないように設計されています</target>
        </trans-unit>
        <trans-unit id="93f405b3f1113c619eaa3ff8cf11a04161308e3b" translate="yes" xml:space="preserve">
          <source>All three types, namely &lt;code&gt;configure_requires&lt;/code&gt; , &lt;code&gt;build_requires&lt;/code&gt; , and &lt;code&gt;requires&lt;/code&gt; are supported in the way specified in the META.yml specification. The current implementation</source>
          <target state="translated">すべての3つのタイプ、すなわち &lt;code&gt;configure_requires&lt;/code&gt; 、 &lt;code&gt;build_requires&lt;/code&gt; 、および &lt;code&gt;requires&lt;/code&gt; META.yml仕様で指定された方法でサポートされています。現在の実装</target>
        </trans-unit>
        <trans-unit id="e69868d20db4582400a5d6cd9bcd656e5299ed1b" translate="yes" xml:space="preserve">
          <source>All variants of Unix, Mac OS (old and new), and Stream_LF files on VMS use a single character to end each line in the external representation of text (even though that single character is CARRIAGE RETURN on old, pre-Darwin flavors of Mac OS, and is LINE FEED on Unix and most VMS files). In other systems like OS/2, DOS, and the various flavors of MS-Windows, your program sees a &lt;code&gt;\n&lt;/code&gt; as a simple &lt;code&gt;\cJ&lt;/code&gt; , but what's stored in text files are the two characters &lt;code&gt;\cM\cJ&lt;/code&gt; . That means that if you don't use binmode() on these systems, &lt;code&gt;\cM\cJ&lt;/code&gt; sequences on disk will be converted to &lt;code&gt;\n&lt;/code&gt; on input, and any &lt;code&gt;\n&lt;/code&gt; in your program will be converted back to &lt;code&gt;\cM\cJ&lt;/code&gt; on output. This is what you want for text files, but it can be disastrous for binary files.</source>
          <target state="translated">Unix、Mac OS（古いものと新しいもの）、およびVMS上のStream_LFファイルのすべてのバリアントは、テキストの外部表現の各行を終了するために単一の文字を使用します（その単一の文字は、古い、Darwin以前のMacのバージョンではCARRIAGE RETURNです。 OS、およびUnixおよびほとんどのVMSファイルではLINE FEEDです）。 OS / 2、DOS、およびMS-Windowsのさまざまな種類のような他のシステムでは、プログラムは &lt;code&gt;\n&lt;/code&gt; を単純な &lt;code&gt;\cJ&lt;/code&gt; ますが、テキストファイルに格納されるのは2つの文字 &lt;code&gt;\cM\cJ&lt;/code&gt; です。つまり、これらのシステムでbinmode（）を使用しない場合、ディスク上の &lt;code&gt;\cM\cJ&lt;/code&gt; シーケンスは入力時に &lt;code&gt;\n&lt;/code&gt; に変換され、プログラム内の &lt;code&gt;\n&lt;/code&gt; は &lt;code&gt;\cM\cJ&lt;/code&gt; 変換されます。出力時。これはテキストファイルに必要なことですが、バイナリファイルには悲惨な場合があります。</target>
        </trans-unit>
        <trans-unit id="ad579c08df3b605d9bcdf2dd854aada4ff50f1d7" translate="yes" xml:space="preserve">
          <source>All warnings are enabled in a block by either of these:</source>
          <target state="translated">これらのいずれかでブロック内のすべての警告が有効になります。</target>
        </trans-unit>
        <trans-unit id="ac638dedbe9b121696313ec4c1b744224313d7b2" translate="yes" xml:space="preserve">
          <source>All warnings from these class elements are fatal, as well as some practices that don't currently warn. For example you cannot say</source>
          <target state="translated">これらのクラス要素からの警告はすべて致命的なものであり、現在は警告しないいくつかのプラクティスも同様です。例えば、以下のようなことはできません。</target>
        </trans-unit>
        <trans-unit id="370cb67fce7c69dd6b28a7668dbdd050522c81c2" translate="yes" xml:space="preserve">
          <source>All we send is -nologo to nmake to prevent it from printing its damned banner.</source>
          <target state="translated">nologoをnmakeに送るだけで、バナーが印刷されないようにしてくれます。</target>
        </trans-unit>
        <trans-unit id="89ae61e8070c7c0925079d83f7934e0eb3357598" translate="yes" xml:space="preserve">
          <source>All writes should be appends.</source>
          <target state="translated">書き込みはすべて追記してください。</target>
        </trans-unit>
        <trans-unit id="d673c2e10445ecd4d4244da3c2339308139938ca" translate="yes" xml:space="preserve">
          <source>All you need to be able to use this is a C compiler than generates BSD/GCC-style stabs. The &lt;b&gt;-g&lt;/b&gt; option on native BSD compilers and GCC should get this for you.</source>
          <target state="translated">これを使用するために必要なのは、BSD / GCCスタイルのスタブを生成するCコンパイラだけです。ネイティブBSDコンパイラおよびGCC の&lt;b&gt;-g&lt;/b&gt;オプションは、これを取得するはずです。</target>
        </trans-unit>
        <trans-unit id="3703c85b2e19a742cbffc3e68e850016eb81f530" translate="yes" xml:space="preserve">
          <source>All you need to do is post a short summary of the module, its purpose and interfaces. A few lines on each of the main methods is probably enough. (If you post the whole module it might be ignored by busy people - generally the very people you want to read it!)</source>
          <target state="translated">あなたがすべきことは、モジュール、その目的、インターフェイスの簡単な要約を投稿することです。それぞれの主要なメソッドについて数行で十分でしょう。(モジュール全体を投稿すると、忙しい人たちに無視されてしまうかもしれません-一般的には、あなたが読みたいと思っている人たちそのものです!)</target>
        </trans-unit>
        <trans-unit id="42dd47aab008353520f505d14f8982da5b7ec66c" translate="yes" xml:space="preserve">
          <source>All you need to do is turn on caching outside of the lexicon hash itself like so:</source>
          <target state="translated">必要なのは、このようにレキシコンハッシュ自体の外でキャッシングをオンにすることだけです。</target>
        </trans-unit>
        <trans-unit id="97cf0e2918a9254a0eafa0498166116f753c3eef" translate="yes" xml:space="preserve">
          <source>All-in-one interface</source>
          <target state="translated">オールインワンインターフェース</target>
        </trans-unit>
        <trans-unit id="6fee78bc0546aa696412ff85a7bc963fbc9ca7d4" translate="yes" xml:space="preserve">
          <source>Allocate (if not already done so) the read buffer for this layer and return pointer to it. Return NULL on failure.</source>
          <target state="translated">このレイヤーの読み込みバッファを確保し(まだ確保していない場合)、そのポインタを返します。失敗した場合は NULL を返します。</target>
        </trans-unit>
        <trans-unit id="3b2ee334827d425691fcbfb9ca0bc34e49168fb9" translate="yes" xml:space="preserve">
          <source>Allocates a new Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">新しいPerlインタープリターを割り当てます。&lt;a href=&quot;perlembed&quot;&gt;perlembedを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="204757b0500eb920f73e23856bcfacd06d0f5f77" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad (via &lt;a href=&quot;#pad_alloc&quot;&gt;pad_alloc&lt;/a&gt;) for an anonymous function that is lexically scoped inside the currently-compiling function. The function</source>
          <target state="translated">現在コンパイル中の関数内で&lt;a href=&quot;#pad_alloc&quot;&gt;レキシカル&lt;/a&gt;にスコープ指定された無名関数のために、（pad_allocを介して）現在コンパイル中のパッド内の場所を割り当てます。関数</target>
        </trans-unit>
        <trans-unit id="cbc8fd0f139e1ed3d083e8bda55cb3c680701f85" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad (via &lt;a href=&quot;perlapi#pad_alloc&quot;&gt;pad_alloc in perlapi&lt;/a&gt;) and then stores a name for that entry.</source>
          <target state="translated">現在コンパイル中のパッドに場所を割り当て（&lt;a href=&quot;perlapi#pad_alloc&quot;&gt;perlapiのpad_allocを&lt;/a&gt;介して）、そのエントリの名前を格納します。</target>
        </trans-unit>
        <trans-unit id="5c5b44a37c6737cadc335e0a4b7b826b48bad95f" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad for a named lexical variable. Stores the name and other metadata in the name part of the pad, and makes preparations to manage the variable's lexical scoping. Returns the offset of the allocated pad slot.</source>
          <target state="translated">現在コンパイル中のパッドに、名前付き字句変数のための場所を割り当てます。名前とその他のメタデータをパッドの名前部分に格納し、その変数の字句型スコーピングを管理するための準備を行います。割り当てられたパッドスロットのオフセットを返します。</target>
        </trans-unit>
        <trans-unit id="b7b59f013b83c5b7e66a9f56292d13c76f0cfbe1" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad, returning the offset of the allocated pad slot. No name is initially attached to the pad slot.</source>
          <target state="translated">現在コンパイル中のパッドに場所を割り当て、割り当てられたパッドスロットのオフセットを返します。パッドスロットには初期状態では名前は付けられていません。</target>
        </trans-unit>
        <trans-unit id="1b5c021aee14bea734803bc4262d3ac794a7f664" translate="yes" xml:space="preserve">
          <source>Allocation</source>
          <target state="translated">Allocation</target>
        </trans-unit>
        <trans-unit id="2e2f6a9fe9c75300156ed8faa2846a84de58e28c" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;+&lt;/code&gt; to start options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;getopt_compat&lt;/code&gt; is disabled.</source>
          <target state="translated">許可 &lt;code&gt;+&lt;/code&gt; オプションを開始します。環境変数POSIXLY_CORRECTが設定されていない限り、デフォルトは有効です。その場合、 &lt;code&gt;getopt_compat&lt;/code&gt; は無効になります。</target>
        </trans-unit>
        <trans-unit id="a59030efa024b93a6e819c9cb26054addbab292b" translate="yes" xml:space="preserve">
          <source>Allow option names to be abbreviated to uniqueness. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;auto_abbrev&lt;/code&gt; is disabled.</source>
          <target state="translated">オプション名を一意に短縮できるようにします。環境変数POSIXLY_CORRECTが設定されていない限り、デフォルトは有効です。その場合、 &lt;code&gt;auto_abbrev&lt;/code&gt; は無効になります。</target>
        </trans-unit>
        <trans-unit id="daa78d2843413d350c8af8e2659c80ab1cc32bed" translate="yes" xml:space="preserve">
          <source>Allowing &quot;.&quot; as a version delimiter is simply incompatible with determining whether a pathname is in VMS format or in Unix format with extended file syntax. There is no way to know whether &quot;perl-5.8.6&quot; is a Unix &quot;perl-5.8.6&quot; or a VMS &quot;perl-5.8;6&quot; when passing it to unixify() or vmsify().</source>
          <target state="translated">バージョンの区切り文字として &quot;.&quot; を許可することは、パス名が VMS 形式なのか Unix 形式なのかを判断することとは単に互換性がありません。unixify()や vmsify()に渡しても &quot;woman.8.6.6&quot; が Unix の &quot;woman.8.6.6&quot; なのか VMS の &quot;woman.8.6;6&quot; なのかを知る方法はありません。</target>
        </trans-unit>
        <trans-unit id="c408189be3311ef544fc6916d88f93932d6bdffc" translate="yes" xml:space="preserve">
          <source>Allowing this could have security implications, as a malicious tar archive could alter or replace any file the extracting user has permissions to. Therefor, the default is to not allow insecure extractions.</source>
          <target state="translated">これを許可すると、悪意のある tar アーカイブが、抽出したユーザが権限を持っているファイルを変更したり置き換えたりする可能性があるため、セキュリティ上の意味合いがあるかもしれません。そのため、デフォルトでは安全でない抽出を許可しないようになっています。</target>
        </trans-unit>
        <trans-unit id="ddbc44ff2a879d62f5a15a25c82d1c43a6e19ca9" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of &lt;a href=&quot;../perlpod#Formatting-Codes&quot;&gt;Formatting Codes in perlpod&lt;/a&gt;. This can be used to implement user-defined codes.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; &lt;a href=&quot;../perlpod#Formatting-Codes&quot;&gt;がperlpod&lt;/a&gt;のフォーマットコードのリストを受け入れることを許可します。これは、ユーザー定義コードの実装に使用できます。</target>
        </trans-unit>
        <trans-unit id="101aab8a8afb357465320bb5f121a4ac661795be" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for &lt;a href=&quot;../perlpod#Verbatim-Paragraph&quot;&gt;Verbatim Paragraph in perlpod&lt;/a&gt;. A directive is the label of a &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. This can be used to implement user-defined directives.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; &lt;a href=&quot;../perlpod#Verbatim-Paragraph&quot;&gt;がperlpodのVerbatim Paragraph&lt;/a&gt;のディレクティブのリストを受け入れることを許可します。ディレクティブは、&lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;perlpodのコマンド段落の&lt;/a&gt;ラベルです。これは、ユーザー定義のディレクティブを実装するために使用できます。</target>
        </trans-unit>
        <trans-unit id="f2a410a266e9f220f21c4f8d80b7768daa7e08ef" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for data paragraphs. A directive is the label of a &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. A data paragraph is one delimited by &lt;code&gt;=begin/=for/=end&lt;/code&gt; directives. This can be used to implement user-defined directives.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; がデータ段落のディレクティブのリストを受け入れることを許可します。ディレクティブは、&lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;perlpodのコマンド段落の&lt;/a&gt;ラベルです。データ段落は、 &lt;code&gt;=begin/=for/=end&lt;/code&gt; ディレクティブで区切られた段落です。これは、ユーザー定義のディレクティブを実装するために使用できます。</target>
        </trans-unit>
        <trans-unit id="0abf6fb24aebd1865d65a4df47fe30a801298ce2" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for processed paragraphs. A directive is the label of a &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. A processed paragraph is also known as &lt;a href=&quot;../perlpod#Ordinary-Paragraph&quot;&gt;Ordinary Paragraph in perlpod&lt;/a&gt;. This can be used to implement user-defined directives.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; が処理済み段落のディレクティブのリストを受け入れることを許可します。ディレクティブは、&lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;perlpodのコマンド段落の&lt;/a&gt;ラベルです。処理された段落は&lt;a href=&quot;../perlpod#Ordinary-Paragraph&quot;&gt;、Perlpod&lt;/a&gt;では通常段落とも呼ばれます。これは、ユーザー定義のディレクティブを実装するために使用できます。</target>
        </trans-unit>
        <trans-unit id="a3735b17f2c2eb4921645bcf6a4d22392282447c" translate="yes" xml:space="preserve">
          <source>Allows a pre-existing extension directory to be overwritten.</source>
          <target state="translated">既存の拡張子ディレクトリを上書きできるようにします。</target>
        </trans-unit>
        <trans-unit id="4b9153c7965fe5ac4319d07a3a1e17ae8bc10ce3" translate="yes" xml:space="preserve">
          <source>Allows an extension to be created for a header even if that header is not found in standard include directories.</source>
          <target state="translated">そのヘッダが標準のインクルードディレクトリにない場合でも、そのヘッダのための拡張機能を作成できるようにします。</target>
        </trans-unit>
        <trans-unit id="daf02b11ffbf9506236d387546a93a50fc62cc0a" translate="yes" xml:space="preserve">
          <source>Allows files and directories to be moved to the Trashcan/Recycle Bin (where they may later be restored if necessary) if the operating system supports such functionality. This feature may one day be made available directly in &lt;code&gt;File::Path&lt;/code&gt; .</source>
          <target state="translated">オペレーティングシステムがそのような機能をサポートしている場合、ファイルとディレクトリをゴミ箱/ごみ箱（後で必要に応じて復元できる場所）に移動できます。この機能はいつか &lt;code&gt;File::Path&lt;/code&gt; 直接利用できるようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="559ebf2a9218f8c70716cdc11eee2f4b586a5213" translate="yes" xml:space="preserve">
          <source>Allows multiple concatenated compressed streams to be treated as a single compressed stream. Decompression will stop once either the end of the file/buffer is reached, an error is encountered (premature eof, corrupt compressed data) or the end of a stream is not immediately followed by the start of another stream.</source>
          <target state="translated">複数の連結された圧縮ストリームを 1 つの圧縮ストリームとして扱うことができます。ファイル/バッファの終端に達した場合、エラーが発生した場合 (早期の eof、圧縮データの破損)、またはストリームの終端がすぐに別のストリームの開始に続いていない場合、伸長は停止します。</target>
        </trans-unit>
        <trans-unit id="7e5261df1ca0e4f1432538fbf7dfbe931383691e" translate="yes" xml:space="preserve">
          <source>Allows newName to be used as an alias for ENCODING. ENCODING may be either the name of an encoding or an encoding object (as described in &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;).</source>
          <target state="translated">ENCODINGのエイリアスとしてnewNameを使用できるようにします。ENCODINGは、エンコードの名前またはエンコードオブジェクトのいずれかです（&lt;a href=&quot;../encode&quot;&gt;Encodeで&lt;/a&gt;説明）。</target>
        </trans-unit>
        <trans-unit id="76b238c6a405ca46725f72efca71d3c55969afb7" translate="yes" xml:space="preserve">
          <source>Allows source endpoint verification to be enabled or disabled. This is useful for those remote destinations with multiples interfaces where the response may not originate from the same endpoint that the original destination endpoint was sent to. This only affects udp and icmp protocol pings.</source>
          <target state="translated">ソースエンドポイントの検証を有効または無効にすることができます。これは、複数のインターフェイスを持つリモートデスティネーションで、レスポンスが元のデスティネーションのエンドポイントが送信されたのと同じエンドポイントから発信されていない場合に便利です。これは udp および icmp プロトコルの ping にのみ影響します。</target>
        </trans-unit>
        <trans-unit id="b46332805263e8790df0747eb20b444ed87a43b7" translate="yes" xml:space="preserve">
          <source>Allows you to both load one or more modules, while setting up inheritance from those modules at the same time. Mostly similar in effect to</source>
          <target state="translated">1つ以上のモジュールをロードしながら、それらのモジュールからの継承を同時に設定することができます。とほとんど似たような効果があります。</target>
        </trans-unit>
        <trans-unit id="c9da0fc905ccf60ade5ca9f7c49a801a55f4a1c8" translate="yes" xml:space="preserve">
          <source>Allows you to both load one or more modules, while setting up inheritance from those modules at the same time. Roughly similar in effect to</source>
          <target state="translated">1つ以上のモジュールをロードしながら、それらのモジュールからの継承を同時に設定することができます。とほぼ同様の効果があります。</target>
        </trans-unit>
        <trans-unit id="22f08aec036591ac3a4e81d90d5af18a1bd7db2a" translate="yes" xml:space="preserve">
          <source>Allows you to choose the character encoding will be store in the DBM file.</source>
          <target state="translated">DBMファイルに格納する文字エンコーディングを選択します。</target>
        </trans-unit>
        <trans-unit id="dab85f86a937e724bd3f8c905ebc9700e2dbc47d" translate="yes" xml:space="preserve">
          <source>Allows you to write your script in non-ASCII and non-UTF-8</source>
          <target state="translated">非ASCIIおよび非UTF-8でスクリプトを書くことができます。</target>
        </trans-unit>
        <trans-unit id="dce4c63a4fe0fe7df493313e47b4aaa4d8491416" translate="yes" xml:space="preserve">
          <source>Almost all properties are immune to case-insensitive matching. That is, adding a &lt;code&gt;/i&lt;/code&gt; regular expression modifier does not change what they match. There are two sets that are affected. The first set is &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; , and &lt;code&gt;Titlecase_Letter&lt;/code&gt; , all of which match &lt;code&gt;Cased_Letter&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. And the second set is &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; , and &lt;code&gt;Titlecase&lt;/code&gt; , all of which match &lt;code&gt;Cased&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. This set also includes its subsets &lt;code&gt;PosixUpper&lt;/code&gt; and &lt;code&gt;PosixLower&lt;/code&gt; both of which under &lt;code&gt;/i&lt;/code&gt; match &lt;code&gt;PosixAlpha&lt;/code&gt; . (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case so they are &lt;code&gt;Cased&lt;/code&gt; , but aren't considered letters, so they aren't &lt;code&gt;Cased_Letter&lt;/code&gt; 's.)</source>
          <target state="translated">ほとんどすべてのプロパティは、大文字と小文字を区別しないマッチングの影響を受けません。つまり、 &lt;code&gt;/i&lt;/code&gt; 正規表現修飾子を追加しても、一致するものは変更されません。影響を受けるセットは2つあります。最初のセットである &lt;code&gt;Uppercase_Letter&lt;/code&gt; 、 &lt;code&gt;Lowercase_Letter&lt;/code&gt; 、及び &lt;code&gt;Titlecase_Letter&lt;/code&gt; 一致すべては、 &lt;code&gt;Cased_Letter&lt;/code&gt; を下 &lt;code&gt;/i&lt;/code&gt; マッチング。そして第二のセットは &lt;code&gt;Uppercase&lt;/code&gt; 、 &lt;code&gt;Lowercase&lt;/code&gt; 、および &lt;code&gt;Titlecase&lt;/code&gt; 一致すべては、 &lt;code&gt;Cased&lt;/code&gt; の下 &lt;code&gt;/i&lt;/code&gt; マッチング。このセットには、 &lt;code&gt;PosixUpper&lt;/code&gt; および &lt;code&gt;PosixLower&lt;/code&gt; のサブセットも含まれます。 &lt;code&gt;/i&lt;/code&gt; &lt;code&gt;PosixAlpha&lt;/code&gt; と一致します。 （これらのセットの違いは、ローマ数字など、大文字と小文字の両方が含まれるため &lt;code&gt;Cased&lt;/code&gt; であるが、文字とは見なされないため &lt;code&gt;Cased_Letter&lt;/code&gt; ではないことです。）</target>
        </trans-unit>
        <trans-unit id="e26025e2ac0ac02421707ba70eeed5ab6641b4e6" translate="yes" xml:space="preserve">
          <source>Almost definitely only useful to people hacking on the offsets part of the debug engine.</source>
          <target state="translated">ほぼ間違いなく、デバッグエンジンのオフセット部分をハックする人にのみ有用です。</target>
        </trans-unit>
        <trans-unit id="38d90c72fc98727ed772fa67692cb8b8e8e09948" translate="yes" xml:space="preserve">
          <source>Along the same lines, just because you</source>
          <target state="translated">同じ線に沿って、単にあなたが</target>
        </trans-unit>
        <trans-unit id="bfe689be701eb0f2bfb705a857c3ee07252b9d77" translate="yes" xml:space="preserve">
          <source>Along with the Perl interpreter itself, the Perl distribution installs a range of utilities on your system. There are also several utilities which are used by the Perl distribution itself as part of the install process. This document exists to list all of these utilities, explain what they are for and provide pointers to each module's documentation, if appropriate.</source>
          <target state="translated">Perl インタプリタ自体と一緒に、Perl ディストリビューションはシステム上に様々なユーティリ ティをインストールします。また、Perl ディストリビューション自体がインストールプロセスの一部として使用するユーティリ ティもいくつかあります。このドキュメントは、これらのユーティリティをすべてリストアップし、それらが何のために使われているのかを説明し、必要に応じて各モジュールのドキュメントへのポインタを提供するために存在しています。</target>
        </trans-unit>
        <trans-unit id="e9e4db05fa3da393c5842e003969195c59714caf" translate="yes" xml:space="preserve">
          <source>Alphabetical Listing of Perl Functions</source>
          <target state="translated">Perl関数のアルファベット順リスト</target>
        </trans-unit>
        <trans-unit id="35100f76a7dd5f19974c02f54724529e98b1eb3a" translate="yes" xml:space="preserve">
          <source>Alphabetical index of Unicode characters</source>
          <target state="translated">Unicode文字のアルファベットインデックス</target>
        </trans-unit>
        <trans-unit id="834177335506d3ec099968dc2393bf176b00318d" translate="yes" xml:space="preserve">
          <source>Also Perl gives access to various C library functions through the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module. Some of those functions are always affected by the current locale. For example, &lt;code&gt;POSIX::strftime()&lt;/code&gt; uses &lt;code&gt;LC_TIME&lt;/code&gt; ; &lt;code&gt;POSIX::strtod()&lt;/code&gt; uses &lt;code&gt;LC_NUMERIC&lt;/code&gt; ; &lt;code&gt;POSIX::strcoll()&lt;/code&gt; and &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; use &lt;code&gt;LC_COLLATE&lt;/code&gt; ; and character classification functions like &lt;code&gt;POSIX::isalnum()&lt;/code&gt; use &lt;code&gt;LC_CTYPE&lt;/code&gt; . All such functions will behave according to the current underlying locale, even if that locale isn't exposed to Perl space.</source>
          <target state="translated">また、Perlは&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;モジュールを通じてさまざまなCライブラリ関数へのアクセスを提供します。これらの関数の一部は、常に現在のロケールの影響を受けます。たとえば、 &lt;code&gt;POSIX::strftime()&lt;/code&gt; は &lt;code&gt;LC_TIME&lt;/code&gt; を使用します。 &lt;code&gt;POSIX::strtod()&lt;/code&gt; は &lt;code&gt;LC_NUMERIC&lt;/code&gt; を使用します。 &lt;code&gt;POSIX::strcoll()&lt;/code&gt; および &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; は &lt;code&gt;LC_COLLATE&lt;/code&gt; を使用します。 &lt;code&gt;POSIX::isalnum()&lt;/code&gt; ような文字分類関数は &lt;code&gt;LC_CTYPE&lt;/code&gt; を使用します。そのような関数はすべて、そのロケールがPerlスペースに公開されていなくても、現在の基本的なロケールに従って動作します。</target>
        </trans-unit>
        <trans-unit id="80beb22d4bec02699379f749d87a910462f32ef7" translate="yes" xml:space="preserve">
          <source>Also add the following code segment to Mytest.t while incrementing the &quot;9&quot; tests to &quot;11&quot;:</source>
          <target state="translated">また、&quot;9 &quot;テストを &quot;11 &quot;にインクリメントしながら、以下のコードセグメントをMytest.tに追加します。</target>
        </trans-unit>
        <trans-unit id="ac140b9c3d4faf5ff89331ade5065ee26ad2ce5b" translate="yes" xml:space="preserve">
          <source>Also available in the CPAN &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::CaseFold&quot;&gt;Unicode::CaseFold&lt;/a&gt; module, the new &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; &amp;ldquo;foldcase&amp;rdquo; function from v5.16 grants access to the same Unicode casefolding as the &lt;code&gt;/i&lt;/code&gt; pattern modifier has always used:</source>
          <target state="translated">CPAN &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::CaseFold&quot;&gt;Unicode :: CaseFold&lt;/a&gt;モジュールでも利用できる、v5.16からの新しい &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; &amp;ldquo; foldcase&amp;rdquo;関数は、 &lt;code&gt;/i&lt;/code&gt; パターン修飾子が常に使用していたのと同じUnicodeケースフォールディングへのアクセスを許可します。</target>
        </trans-unit>
        <trans-unit id="46cd58b57422283c68d064857c29c9de3e394325" translate="yes" xml:space="preserve">
          <source>Also change</source>
          <target state="translated">また、変更</target>
        </trans-unit>
        <trans-unit id="c0abeeb67d5f473db892c8e04d0607c1def48eaa" translate="yes" xml:space="preserve">
          <source>Also compare &lt;code&gt;SAVEMORTALIZESV&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;SAVEMORTALIZESV&lt;/code&gt; も比較してください。</target>
        </trans-unit>
        <trans-unit id="05e4ad005c5681ba47d1d566b8e0cb49ffb2ad43" translate="yes" xml:space="preserve">
          <source>Also consider this valid structure:</source>
          <target state="translated">この有効な構造も考慮してください。</target>
        </trans-unit>
        <trans-unit id="a7b339961adc2d21b9a876670a45b1f1d855a3be" translate="yes" xml:space="preserve">
          <source>Also create a file mylib.c that looks like this:</source>
          <target state="translated">また、以下のようなファイルmylib.cを作成します。</target>
        </trans-unit>
        <trans-unit id="c401faba028e376c88469287989685e42d637510" translate="yes" xml:space="preserve">
          <source>Also floating point numbers have endianness. Usually (but not always) this agrees with the integer endianness. Even though most platforms these days use the IEEE 754 binary format, there are differences, especially if the long doubles are involved. You can see the &lt;code&gt;Config&lt;/code&gt; variables &lt;code&gt;doublekind&lt;/code&gt; and &lt;code&gt;longdblkind&lt;/code&gt; (also &lt;code&gt;doublesize&lt;/code&gt; , &lt;code&gt;longdblsize&lt;/code&gt; ): the &quot;kind&quot; values are enums, unlike &lt;code&gt;byteorder&lt;/code&gt; .</source>
          <target state="translated">また、浮動小数点数にはエンディアンがあります。通常（常にではありません）、これは整数のエンディアンと一致します。最近のほとんどのプラットフォームはIEEE 754バイナリ形式を使用していますが、特に長いdoubleが含まれる場合は違いがあります。 &lt;code&gt;Config&lt;/code&gt; 変数 &lt;code&gt;doublekind&lt;/code&gt; と &lt;code&gt;longdblkind&lt;/code&gt; （これも &lt;code&gt;doublesize&lt;/code&gt; 、 &lt;code&gt;longdblsize&lt;/code&gt; ）を確認できます。「kind」値は、 &lt;code&gt;byteorder&lt;/code&gt; とは異なり、列挙型です。</target>
        </trans-unit>
        <trans-unit id="d6a0632d09aa67f7c933563807a5dc4e1be43b5e" translate="yes" xml:space="preserve">
          <source>Also good for one-liners:</source>
          <target state="translated">ワンライナーにも最適です。</target>
        </trans-unit>
        <trans-unit id="801a4731c98561cdcf16aa86d636dfa32a54b0ca" translate="yes" xml:space="preserve">
          <source>Also keep around the old $(SAY) macro in case somebody's using it.</source>
          <target state="translated">また、誰かが使っている場合に備えて、古い $(SAY)マクロも保管しておきましょう。</target>
        </trans-unit>
        <trans-unit id="2c84ea90ff2c682d2dfed6ff8b041df2e7877e52" translate="yes" xml:space="preserve">
          <source>Also like the &quot;strict&quot; pragma, if there is more than one instance of the &lt;code&gt;warnings&lt;/code&gt; pragma in a given scope the cumulative effect is additive.</source>
          <target state="translated">また、「strict」プラグマと同様に、特定のスコープ内に &lt;code&gt;warnings&lt;/code&gt; プラグマのインスタンスが複数ある場合、累積的な効果は付加的です。</target>
        </trans-unit>
        <trans-unit id="8b1ee43d27cd54e3a73fd0b027a7a33d6ab24281" translate="yes" xml:space="preserve">
          <source>Also make sure that you have</source>
          <target state="translated">また、あなたが持っていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="ccf329915f222131778e86ee9fd087f89f391e81" translate="yes" xml:space="preserve">
          <source>Also make sure you read &lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;BUGS AND CAVEATS&lt;/a&gt; below for the known limitations of this port.</source>
          <target state="translated">また、このポートの既知の制限については、以下の&lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;バグと警告を&lt;/a&gt;お読みください。</target>
        </trans-unit>
        <trans-unit id="fe06cc0daccf4654b8c81c8f1faee5e0b7783c69" translate="yes" xml:space="preserve">
          <source>Also no attention is paid to &lt;code&gt;\c\&lt;/code&gt; (multichar control char syntax) during this search. Thus the second &lt;code&gt;\&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq/\c\/&lt;/a&gt;&lt;/code&gt; is interpreted as a part of &lt;code&gt;\/&lt;/code&gt;, and the following &lt;code&gt;/&lt;/code&gt; is not recognized as a delimiter. Instead, use &lt;code&gt;\034&lt;/code&gt; or &lt;code&gt;\x1c&lt;/code&gt; at the end of quoted constructs.</source>
          <target state="translated">また、この検索中は &lt;code&gt;\c\&lt;/code&gt; （マルチ文字制御文字構文）には注意が払われません。こうして第 &lt;code&gt;\&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq/\c\/&lt;/a&gt;&lt;/code&gt; の一部として解釈され &lt;code&gt;\/&lt;/code&gt; 、および次 &lt;code&gt;/&lt;/code&gt; 区切り文字として認識されません。代わりに、引用符で囲まれた構成要素の最後に &lt;code&gt;\034&lt;/code&gt; または &lt;code&gt;\x1c&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="73a9b46957654b20ec65fb83845a1d68f2c4bbed" translate="yes" xml:space="preserve">
          <source>Also note that</source>
          <target state="translated">また、以下の点にも注意してください。</target>
        </trans-unit>
        <trans-unit id="674fbb1e5f8c5ba4d4b18a90ede292ece92dabf5" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; passes command line arguments to &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;, which doesn't necessarily interpret them as file names. See &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for possible security implications.</source>
          <target state="translated">また、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; はコマンドライン引数を&lt;a href=&quot;functions/open&quot;&gt;openに&lt;/a&gt;渡しますが、必ずしもファイル名として解釈されるわけではありません。考えられるセキュリティへの影響については、&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="93e48d832329c669ef467acfbb855710b1f11c32" translate="yes" xml:space="preserve">
          <source>Also note that in order to be compatible with the shell command, &lt;code&gt;basename()&lt;/code&gt; does not strip off a suffix if it is identical to the remaining characters in the filename.</source>
          <target state="translated">また、シェルコマンドとの互換性を保つために、 &lt;code&gt;basename()&lt;/code&gt; は、ファイル名の残りの文字と同じ場合、サフィックスを削除しません。</target>
        </trans-unit>
        <trans-unit id="6d4f64c4ffda1e49198c526880412a3685e89bbb" translate="yes" xml:space="preserve">
          <source>Also note that in some platforms trying to use the infinity in arithmetic operations may result in Perl crashing because using an infinity causes SIGFPE or its moral equivalent to be sent. The way to ignore this is</source>
          <target state="translated">また、いくつかのプラットフォームでは、算術演算で無限大を使おうとすると、無限大を使うと SIGFPE やその道徳的な等価物が送られてくるため、Perl がクラッシュする可能性があることに注意してください。これを無視する方法は</target>
        </trans-unit>
        <trans-unit id="e93493c0471e07df3c4c3cbce58bbf69cdead50b" translate="yes" xml:space="preserve">
          <source>Also note that non-STD file handles remain unaffected. Use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to change the layers of those.</source>
          <target state="translated">また、非STDファイルハンドルは影響を受けないことに注意してください。これらのレイヤーを変更するには、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="8343e14f16aa3f23ee42ee984961cfee3da48f48" translate="yes" xml:space="preserve">
          <source>Also note that the &lt;code&gt;sv_set*()&lt;/code&gt; and &lt;code&gt;sv_cat*()&lt;/code&gt; functions described earlier do &lt;b&gt;not&lt;/b&gt; invoke 'set' magic on their targets. This must be done by the user either by calling the &lt;code&gt;SvSETMAGIC()&lt;/code&gt; macro after calling these functions, or by using one of the &lt;code&gt;sv_set*_mg()&lt;/code&gt; or &lt;code&gt;sv_cat*_mg()&lt;/code&gt; functions. Similarly, generic C code must call the &lt;code&gt;SvGETMAGIC()&lt;/code&gt; macro to invoke any 'get' magic if they use an SV obtained from external sources in functions that don't handle magic. See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for a description of these functions. For example, calls to the &lt;code&gt;sv_cat*()&lt;/code&gt; functions typically need to be followed by &lt;code&gt;SvSETMAGIC()&lt;/code&gt; , but they don't need a prior &lt;code&gt;SvGETMAGIC()&lt;/code&gt; since their implementation handles 'get' magic.</source>
          <target state="translated">また、 &lt;code&gt;sv_set*()&lt;/code&gt; および &lt;code&gt;sv_cat*()&lt;/code&gt; 関数は、ターゲットに対して「設定」マジックを呼び出さ&lt;b&gt;ない&lt;/b&gt;ことに注意してください。これは、ユーザーがこれらの関数を呼び出した後に &lt;code&gt;SvSETMAGIC()&lt;/code&gt; マクロを呼び出すか、 &lt;code&gt;sv_set*_mg()&lt;/code&gt; または &lt;code&gt;sv_cat*_mg()&lt;/code&gt; 関数のいずれかを使用して行う必要があります。同様に、ジェネリックCコードは、マジックを処理しない関数で外部ソースから取得したSVを使用する場合、 &lt;code&gt;SvGETMAGIC()&lt;/code&gt; マクロを呼び出して「取得」マジックを呼び出す必要があります。これらの関数の説明については&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;を参照してください。たとえば、通常は &lt;code&gt;sv_cat*()&lt;/code&gt; 関数の呼び出しの後に &lt;code&gt;SvSETMAGIC()&lt;/code&gt; を実行する必要があります、ただし、実装は「取得」マジックを処理するため、事前の &lt;code&gt;SvGETMAGIC()&lt;/code&gt; は必要ありません。</target>
        </trans-unit>
        <trans-unit id="e7be1aad912cf4ad5fcf4064cf6ab4309ca326be" translate="yes" xml:space="preserve">
          <source>Also note that the bval option only allows you to specify a single byte as a delimiter.</source>
          <target state="translated">また、bval オプションは、デリミタとして 1 バイトしか指定できないことにも注意してください。</target>
        </trans-unit>
        <trans-unit id="fb785a40ce237466b61cf74c58f19b12f7daa54a" translate="yes" xml:space="preserve">
          <source>Also note that there's no value for UNITCHECK-blocks. That's because those are run for each compilation unit individually, and therefore is not a global interpreter phase.</source>
          <target state="translated">また、UNITCHECK-blockには値がないことにも注意してください。これは、各コンパイルユニットごとに個別に実行されるため、グローバルインタプリタフェーズではないからです。</target>
        </trans-unit>
        <trans-unit id="8af529a7344d9be72e889a1f3967799ba9dc98d6" translate="yes" xml:space="preserve">
          <source>Also note that these instructions are tailored for installing the module into your system's repository of Perl modules, but you can install modules into any directory you wish. For instance, where I say &lt;code&gt;perl Makefile.PL&lt;/code&gt; , you can substitute &lt;code&gt;perl Makefile.PL
PREFIX=/my/perl_directory&lt;/code&gt; to install the modules into</source>
          <target state="translated">また、これらの手順は、Perlモジュールのシステムのリポジトリにモジュールをインストールするために調整されていますが、モジュールは任意のディレクトリにインストールできます。例えば、私が言うところ &lt;code&gt;perl Makefile.PL&lt;/code&gt; 、あなたは置き換えることができる &lt;code&gt;perl Makefile.PL PREFIX=/my/perl_directory&lt;/code&gt; にモジュールをインストールします</target>
        </trans-unit>
        <trans-unit id="736913cda9c361fafb5f7987b822471b70893809" translate="yes" xml:space="preserve">
          <source>Also note that this does not (yet) work with all configurations, it is known to fail with 64-bit versions of GCC.</source>
          <target state="translated">また、これは(まだ)すべての設定では動作しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="1ab79db4a65e3d1bcd26f59f38af2eeb810bbb25" translate="yes" xml:space="preserve">
          <source>Also note that under the current implementation, shared variables use a little more memory and are a little slower than ordinary variables.</source>
          <target state="translated">また、現在の実装では、共有変数は少し多くのメモリを使用し、通常の変数よりも少し遅いことにも注意してください。</target>
        </trans-unit>
        <trans-unit id="df7301891c8738a820a79c945053b0568b895b92" translate="yes" xml:space="preserve">
          <source>Also note that whether enums are implicitly morphable to ints varies between compilers, you might need to (int).</source>
          <target state="translated">また、列挙型が暗黙的にintにモーフィング可能かどうかはコンパイラによって異なるので、(int)が必要になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="971b7944044758dad02956ec65121b0bd485f6a2" translate="yes" xml:space="preserve">
          <source>Also note that while the order of the hash elements might be randomized, this &quot;pseudo-ordering&quot; should &lt;b&gt;not&lt;/b&gt; be used for applications like shuffling a list randomly (use &lt;code&gt;List::Util::shuffle()&lt;/code&gt; for that, see &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt;, a standard core module since Perl 5.8.0; or the CPAN module &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt; ), or for generating permutations (use e.g. the CPAN modules &lt;code&gt;Algorithm::Permute&lt;/code&gt; or &lt;code&gt;Algorithm::FastPermute&lt;/code&gt; ), or for any cryptographic applications.</source>
          <target state="translated">また、ハッシュ要素の順序はランダム化される可能性がありますが、この「疑似順序付け」は、リストをランダムにシャッフルするようなアプリケーションには使用し&lt;b&gt;ない&lt;/b&gt;でください（ &lt;code&gt;List::Util::shuffle()&lt;/code&gt; を使用してください&lt;a href=&quot;list/util&quot;&gt;。List:: Utilを&lt;/a&gt;参照）。、Perl 5.8.0以降の標準コアモジュール、またはCPANモジュール &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt; ）、または順列の生成（たとえば、CPANモジュール &lt;code&gt;Algorithm::Permute&lt;/code&gt; または &lt;code&gt;Algorithm::FastPermute&lt;/code&gt; ）、または任意の暗号アプリケーション。</target>
        </trans-unit>
        <trans-unit id="4516f893f396703a765e286979d300545dd3cb43" translate="yes" xml:space="preserve">
          <source>Also note that, for the superuser on the local filesystems, the &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-W&lt;/code&gt; tests always return 1, and &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a stat() to determine the actual mode of the file, or temporarily set their effective uid to something else.</source>
          <target state="translated">また、ローカルファイルシステムのスーパーユーザーの場合、 &lt;code&gt;-r&lt;/code&gt; 、 &lt;code&gt;-R&lt;/code&gt; 、 &lt;code&gt;-w&lt;/code&gt; 、および &lt;code&gt;-W&lt;/code&gt; テストは常に1を返し、モードに実行ビットが設定されている場合、 &lt;code&gt;-x&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; テストは1を返します。したがって、スーパーユーザーが実行するスクリプトは、stat（）を実行してファイルの実際のモードを判別するか、一時的に有効なuidを他の何かに設定する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="63277c7c7b95830e3556168d50e815433213b167" translate="yes" xml:space="preserve">
          <source>Also note that, for the superuser on the local filesystems, the &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-W&lt;/code&gt; tests always return 1, and &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a stat() to determine the actual mode of the file, or temporarily set their effective uid to something else.</source>
          <target state="translated">また、ローカルファイルシステムのスーパーユーザーの場合、 &lt;code&gt;-r&lt;/code&gt; 、 &lt;code&gt;-R&lt;/code&gt; 、 &lt;code&gt;-w&lt;/code&gt; 、および &lt;code&gt;-W&lt;/code&gt; テストは常に1を返し、モードに実行ビットが設定されている場合、 &lt;code&gt;-x&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; テストは1を返します。したがって、スーパーユーザーが実行するスクリプトは、stat（）を実行してファイルの実際のモードを判別するか、一時的に有効なuidを他の何かに設定する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="0d0223c3f3274398a55ed8725b06675a40efd8ef" translate="yes" xml:space="preserve">
          <source>Also note that:</source>
          <target state="translated">また、そのことにも注意してください。</target>
        </trans-unit>
        <trans-unit id="87da44cc851ca2f3b8c127c8f7ddc08e6bd458e4" translate="yes" xml:space="preserve">
          <source>Also note, that because all ASCII characters are UTF-8 invariant (meaning they have the exact same representation (always a single byte) whether encoded in UTF-8 or not), &lt;code&gt;isASCII&lt;/code&gt; will give the correct results when called with any byte in any string encoded or not in UTF-8. And similarly &lt;code&gt;isASCII_utf8&lt;/code&gt; will work properly on any string encoded or not in UTF-8.</source>
          <target state="translated">また、すべてのASCII文字はUTF-8不変（UTF-8でエンコードされているかどうかにかかわらず、まったく同じ表現（常に1バイト）であることを意味する）であるため、 &lt;code&gt;isASCII&lt;/code&gt; は任意のバイトで呼び出されたときに正しい結果を提供します。 UTF-8でエンコードされた、またはエンコードされていない文字列。また、 &lt;code&gt;isASCII_utf8&lt;/code&gt; は、UTF-8でエンコードされているかどうかに関係なく、適切に機能します。</target>
        </trans-unit>
        <trans-unit id="523b244d1d9de0ba3f1938d9267c5634264d7182" translate="yes" xml:space="preserve">
          <source>Also notice that no matter what arguments you pass to perl_parse(), PERL_SYS_INIT3() must be invoked on the C main() argc, argv and env and only once.</source>
          <target state="translated">また、perl_parse()にどんな引数を渡しても、PERL_SYS_INIT3()はCのmain()argc,argv,envで一度だけ呼び出されなければならないことにも注意してください。</target>
        </trans-unit>
        <trans-unit id="e0b1e0d1886e4ff75f5ec5ef85846c4c02e181e1" translate="yes" xml:space="preserve">
          <source>Also of use is &lt;code&gt;File::Basename&lt;/code&gt; from the standard distribution, which splits a pathname into pieces (base filename, full path to directory, and file suffix).</source>
          <target state="translated">また、標準配布の &lt;code&gt;File::Basename&lt;/code&gt; も使用されます。これは、パス名を分割します（ベースファイル名、ディレクトリへのフルパス、およびファイルサフィックス）。</target>
        </trans-unit>
        <trans-unit id="5f72eee36e825db36f597f9decf9236b17c32472" translate="yes" xml:space="preserve">
          <source>Also parsed as terms are the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; constructs, as well as subroutine and method calls, and the anonymous constructors &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt; .</source>
          <target state="translated">また、用語として解析されるのは、 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 構成、サブルーチンとメソッドの呼び出し、および匿名コンストラクタ &lt;code&gt;[]&lt;/code&gt; と &lt;code&gt;{}&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a2bae6f7ee0c691e590b07608d4c9653431dd798" translate="yes" xml:space="preserve">
          <source>Also read the &lt;a href=&quot;#DESCRIPTION&quot;&gt;DESCRIPTION&lt;/a&gt; section above, about how &lt;code&gt;Carp&lt;/code&gt; decides where the error is reported from.</source>
          <target state="translated">&lt;code&gt;Carp&lt;/code&gt; がエラーの報告元を決定する方法については、上記の「&lt;a href=&quot;#DESCRIPTION&quot;&gt;説明」&lt;/a&gt;セクションもお読みください。</target>
        </trans-unit>
        <trans-unit id="8e594eb3334af2971f8b461e9ae7e0b95244811c" translate="yes" xml:space="preserve">
          <source>Also remember that &quot;|&quot; is interpreted as a literal within square brackets, so if you write &lt;code&gt;[fee|fie|foe]&lt;/code&gt; you're really only matching &lt;code&gt;[feio|]&lt;/code&gt; .</source>
          <target state="translated">「|」も覚えておいてください は角括弧内のリテラルとして解釈されるため、 &lt;code&gt;[fee|fie|foe]&lt;/code&gt; と記述した場合は、実際には &lt;code&gt;[feio|]&lt;/code&gt; のみ一致します。</target>
        </trans-unit>
        <trans-unit id="2d930463c65b067a74fc5ff7d23d0ccb6261af74" translate="yes" xml:space="preserve">
          <source>Also remember that C doesn't allow you to safely say &lt;code&gt;foo(SvPV(s, len),
len);&lt;/code&gt;. It might work with your compiler, but it won't work for everyone. Break this sort of statement up into separate assignments:</source>
          <target state="translated">また、Cでは &lt;code&gt;foo(SvPV(s, len), len);&lt;/code&gt; と安全に言うことができないことも覚えておいてください。。それはあなたのコンパイラで動作するかもしれませんが、誰にとっても動作するとは限りません。この種類のステートメントを個別の割り当てに分割します。</target>
        </trans-unit>
        <trans-unit id="f44fcd946ba2f23c70977904fbf45aba4b6fafca" translate="yes" xml:space="preserve">
          <source>Also remember that the &lt;code&gt;%p&lt;/code&gt; format really does require a void pointer:</source>
          <target state="translated">また、 &lt;code&gt;%p&lt;/code&gt; 形式にはvoidポインターが実際に必要であることも覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="058a190dd3d11e3f9bf93212c115f6265d98bac0" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; or &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;または&lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="aa855f9ba4cde9a2842bd3fc97af3045ad2e00c0" translate="yes" xml:space="preserve">
          <source>Also see:</source>
          <target state="translated">も参照してください。</target>
        </trans-unit>
        <trans-unit id="e8ab5cecbe34d47a3838306a541fd22a09e183f0" translate="yes" xml:space="preserve">
          <source>Also starting in v5.8.1, the &lt;code&gt;DATA&lt;/code&gt; pseudo-filehandle is translated from the encoding into UTF-8.</source>
          <target state="translated">また、v5.8.1から、 &lt;code&gt;DATA&lt;/code&gt; 疑似ファイルハンドルはエンコーディングからUTF-8に変換されます。</target>
        </trans-unit>
        <trans-unit id="ab76f7fb0dafb2fd9b645c8d2859052a429122ce" translate="yes" xml:space="preserve">
          <source>Also study &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; carefully to avoid any bad assumptions about the operating system, filesystems, character set, and so forth.</source>
          <target state="translated">また、オペレーティングシステム、ファイルシステム、文字セットなどに関する&lt;a href=&quot;perlport&quot;&gt;誤った&lt;/a&gt;想定を避けるために、perlportを注意深く調べてください。</target>
        </trans-unit>
        <trans-unit id="330eeffd40ec44ea764cda155371e57d6de9d850" translate="yes" xml:space="preserve">
          <source>Also unchanged is the quoting of non-UTF-8 strings when outside the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; , which is to quote all characters in the upper Latin1 range. This provides complete backwards compatibility for old programs which do not use Unicode. (Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically enabled within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or greater.)</source>
          <target state="translated">また、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; の範囲外の場合、UTF-8以外の文字列の引用は変更されません。これは、Latin1の上位範囲のすべての文字を引用することです。これにより、Unicodeを使用しない古いプログラムに完全な下位互換性が提供されます。（ &lt;code&gt;unicode_strings&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; 以降の&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;の範囲内で自動的に有効になることに注意してください。）</target>
        </trans-unit>
        <trans-unit id="d897a47e8affb873fdb6ab1911f0d831b446c551" translate="yes" xml:space="preserve">
          <source>Also unchanged is the quoting of non-UTF-8 strings when outside the scope of a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; , which is to quote all characters in the upper Latin1 range. This provides complete backwards compatibility for old programs which do not use Unicode. (Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically enabled within the scope of a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or greater.)</source>
          <target state="translated">また、 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; の範囲外の場合、UTF-8以外の文字列の引用は変更されません。これは、Latin1の上位範囲のすべての文字を引用することです。これにより、Unicodeを使用しない古いプログラムに完全な下位互換性が提供されます。（ &lt;code&gt;unicode_strings&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; 以降の&lt;a href=&quot;use&quot;&gt;使用&lt;/a&gt;の範囲内で自動的に有効になることに注意してください。）</target>
        </trans-unit>
        <trans-unit id="77e4638580e542bd7efbc6ad1037c219e33a2a27" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;fileparse()&lt;/code&gt; , &lt;code&gt;dirname()&lt;/code&gt; does not include a trailing slash on its returned path.</source>
          <target state="translated">また、 &lt;code&gt;fileparse()&lt;/code&gt; とは異なり、 &lt;code&gt;dirname()&lt;/code&gt; は、返されたパスに末尾のスラッシュを含めません。</target>
        </trans-unit>
        <trans-unit id="3cf4e79f0d2cc479a41a6179c877f4a73d453199" translate="yes" xml:space="preserve">
          <source>Also when working on Perl programs on VMS, if you need a syntax in a specific operating system format, then you need either to check the appropriate DECC$ feature logical, or call a conversion routine to force it to that format.</source>
          <target state="translated">また、VMS上のPerlプログラムで作業する際に、特定のオペレーティングシステム形式の構文が必要な場合は、適切なDECC$機能論理をチェックするか、その形式に強制的に変換するための変換ルーチンを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="b4a91fa72735b293f0702212cc8b8ff7dd3fc1bc" translate="yes" xml:space="preserve">
          <source>Also you have to be careful when using &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a value in AVs or HVs (see &lt;a href=&quot;#AVs%2c-HVs-and-undefined-values&quot;&gt;AVs, HVs and undefined values&lt;/a&gt;).</source>
          <target state="translated">また、 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; をAVまたはHVの値として使用する場合は注意が必要です（&lt;a href=&quot;#AVs%2c-HVs-and-undefined-values&quot;&gt;AV、HV、および未定義の値を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="88b9515cdbcd45bb30a5ed0507a9f79663403c03" translate="yes" xml:space="preserve">
          <source>Also, &lt;b&gt;in Perl 5.8.x and earlier&lt;/b&gt;, this pragma uses pseudo-hashes, the effect being that you can have objects with named fields which are as compact and as fast arrays to access, as long as the objects are accessed through properly typed variables.</source>
          <target state="translated">また、&lt;b&gt;Perl 5.8.x以前では&lt;/b&gt;、このプラグマは疑似ハッシュを使用しており、適切に型指定された変数を介してオブジェクトにアクセスする限り、コンパクトで高速な配列である名前付きフィールドを持つオブジェクトにアクセスできます。 。</target>
        </trans-unit>
        <trans-unit id="67b0ddab77dcdca452f298cae2c04c86ed3d38be" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; yields &lt;code&gt; chr(28) . &quot;&lt;i&gt;X&lt;/i&gt;&quot;&lt;/code&gt; for any</source>
          <target state="translated">また、 &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; は &lt;code&gt; chr(28) . &quot;&lt;i&gt;X&lt;/i&gt;&quot;&lt;/code&gt; 生成します。「&lt;i&gt;X&lt;/i&gt;」いずれかのために</target>
        </trans-unit>
        <trans-unit id="d7b7987422ffa4fcf0f2ef8eb8b0440e2263954b" translate="yes" xml:space="preserve">
          <source>Also, Case_Folding is accessible through the &lt;code&gt;/i&lt;/code&gt; modifier in regular expressions, the &lt;code&gt;\F&lt;/code&gt; transliteration escape, and the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">また、Case_Foldingには、正規表現の &lt;code&gt;/i&lt;/code&gt; 修飾子、 &lt;code&gt;\F&lt;/code&gt; 文字変換エスケープ、および &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 演算子を使用してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="329290910e0fbb3b491e01928584618de2f21b4e" translate="yes" xml:space="preserve">
          <source>Also, Configure might abort with</source>
          <target state="translated">また、Configure は</target>
        </trans-unit>
        <trans-unit id="1e804a10723cc82e329f560a2f2a4e122d8ad225" translate="yes" xml:space="preserve">
          <source>Also, a backslash followed by two or three octal digits is considered an octal number.</source>
          <target state="translated">また、バックスラッシュの後に8進数の2桁または3桁が続くものは、8進数とみなされます。</target>
        </trans-unit>
        <trans-unit id="6cc421c7386da7b14eefaf275d4a113f5c542cb3" translate="yes" xml:space="preserve">
          <source>Also, both these methods currently allow only single characters to be named. To name a sequence of characters, use a &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;custom translator&lt;/a&gt; (described below).</source>
          <target state="translated">また、これらの両方の方法では現在、単一の文字のみに名前を付けることができます。一連の文字に名前を付けるには、&lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;カスタムトランスレータ&lt;/a&gt;（以下で説明）を使用します。</target>
        </trans-unit>
        <trans-unit id="0b19a92a5a63a3defc0247ff7123f75e1b423945" translate="yes" xml:space="preserve">
          <source>Also, calling &amp;amp;$coderef($lh, ...parameters...) can throw any sort of exception (if, say, code in that sub tries to divide by zero). But a very common exception occurs when you have Bracket Notation text that says to call a method &quot;foo&quot;, but there is no such method. (E.g., &quot;You have [qua&lt;b&gt;tn&lt;/b&gt;,_1,ball].&quot; will throw an exception on trying to call $lh-&amp;gt;qua&lt;b&gt;tn&lt;/b&gt;($_[1],'ball') -- you presumably meant &quot;quant&quot;.) &lt;code&gt;maketext&lt;/code&gt; catches these exceptions, but only to make the error message more readable, at which point it rethrows the exception.</source>
          <target state="translated">また、＆$ coderef（$ lh、... parameters ...）を呼び出すと、あらゆる種類の例外がスローされる可能性があります（たとえば、そのサブのコードがゼロで除算しようとした場合）。しかし、メソッド「foo」を呼び出すように指示するブラケット表記テキストがある場合に、非常に一般的な例外が発生しますが、そのようなメソッドはありません。 （たとえば、「あなたは[qua &lt;b&gt;tn&lt;/b&gt;、_1、ball]を持っています。」は$ lh-&amp;gt; qua &lt;b&gt;tn&lt;/b&gt;（$ _ [1]、 'ball'）を呼び出そうとすると例外をスローします-おそらく「クオンツ」を意味していました。 ） &lt;code&gt;maketext&lt;/code&gt; はこれらの例外をキャッチしますが、エラーメッセージを読みやすくするためだけです。その時点で例外が再スローされます。</target>
        </trans-unit>
        <trans-unit id="bd6593efc170267903ffe758130a7c9bc58d5233" translate="yes" xml:space="preserve">
          <source>Also, entries like</source>
          <target state="translated">また、以下のようなエントリーもあります。</target>
        </trans-unit>
        <trans-unit id="74a420b208a6c382bb28f75840a5f1acef599188" translate="yes" xml:space="preserve">
          <source>Also, every C program that uses Perl must link in the</source>
          <target state="translated">また、Perl を使用するすべての C プログラムは</target>
        </trans-unit>
        <trans-unit id="34500a88731ba3291ee1333607a6b7ca5f090a54" translate="yes" xml:space="preserve">
          <source>Also, feel free to play with experimental features. Run</source>
          <target state="translated">また、実験的な機能で気軽に遊んでみてください。走らせる</target>
        </trans-unit>
        <trans-unit id="7b8f99a26ea97ae4edab854723c19d8a2e3a7a2e" translate="yes" xml:space="preserve">
          <source>Also, for a somewhat finer-grained set of characters that are in programming language identifiers beyond the ASCII range, you may wish to instead use the more customized &lt;a href=&quot;#Unicode-Properties&quot;&gt;Unicode Properties&lt;/a&gt;, &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{ID_Continue}&lt;/code&gt; , &lt;code&gt;\p{XID_Start}&lt;/code&gt; , and &lt;code&gt;\p{XID_Continue}&lt;/code&gt; . See &lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31&lt;/a&gt;.</source>
          <target state="translated">また、ASCIIの範囲を超えてプログラミング言語識別子に含まれるややきめの細かい文字セットの場合は、代わりに、よりカスタマイズされた&lt;a href=&quot;#Unicode-Properties&quot;&gt;Unicodeプロパティ&lt;/a&gt;、 &lt;code&gt;\p{ID_Start}&lt;/code&gt; 、 &lt;code&gt;\p{ID_Continue}&lt;/code&gt; 、 &lt;code&gt;\p{XID_Start}&lt;/code&gt; 、および &lt;code&gt;\p{XID_Continue}&lt;/code&gt; 。&lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ccef320717b4d17e6eccfe71944895dfdb94c8a6" translate="yes" xml:space="preserve">
          <source>Also, having valid values as keys becomes very useful if you set up an _AUTO lexicon. _AUTO lexicons are discussed in a later section.</source>
          <target state="translated">また、_AUTOレキシコンを設定した場合、有効な値をキーとして持つことが非常に便利になります。AUTO レキシコンについては後述します。</target>
        </trans-unit>
        <trans-unit id="57c4e07e0cc219d38dd06e6e1bcf0b1ea8e52540" translate="yes" xml:space="preserve">
          <source>Also, if the SV passed to &lt;code&gt;mg_find&lt;/code&gt; or &lt;code&gt;mg_findext&lt;/code&gt; is not of type SVt_PVMG, Perl may core dump.</source>
          <target state="translated">また、 &lt;code&gt;mg_find&lt;/code&gt; または &lt;code&gt;mg_findext&lt;/code&gt; に渡されたSV のタイプがSVt_PVMGでない場合、Perlがコアダンプすることがあります。</target>
        </trans-unit>
        <trans-unit id="a715fbfabba33c1ab0f07edc90c111741da66e2f" translate="yes" xml:space="preserve">
          <source>Also, in binary properties, 'Yes', 'T', and 'True' are all synonyms for 'Y'. And 'No', 'F', and 'False' are all synonyms for 'N'. The table shows 'Y*' and 'N*' to indicate this, and doesn't have separate entries for the other possibilities. Note that not all properties which have values 'Yes' and 'No' are binary, and they have all their values spelled out without using this wild card, and a &lt;code&gt;NOT&lt;/code&gt; clause in their description that highlights their not being binary. These also require the compound form to match them, whereas true binary properties have both single and compound forms available.</source>
          <target state="translated">また、バイナリプロパティでは、「Yes」、「T」、および「True」はすべて「Y」の同義語です。また、「いいえ」、「F」、および「False」はすべて「N」の同義語です。この表は、これを示すために 'Y *'と 'N *'を示しており、他の可能性に対する個別のエントリはありません。 「はい」と「いいえ」の値を持つすべてのプロパティがバイナリであるとは限らず、このワイルドカードを使用せずにすべての値がスペルアウトされ、バイナリではないことを強調する説明に &lt;code&gt;NOT&lt;/code&gt; 句があることに注意してください。また、これらは一致する複合形式を必要としますが、真のバイナリプロパティは単一形式と複合形式の両方を利用できます。</target>
        </trans-unit>
        <trans-unit id="a00a976f777c7c9555d5a4f1c975df6f1666beb4" translate="yes" xml:space="preserve">
          <source>Also, in the context of &lt;b&gt;Unicode&lt;/b&gt;, a writing system for a particular language or group of languages, such as Greek, Bengali, or Tengwar.</source>
          <target state="translated">また、&lt;b&gt;Unicode&lt;/b&gt;のコンテキストでは、ギリシャ語、ベンガル語、またはテンガル語などの特定の言語または言語のグループ用の書記体系。</target>
        </trans-unit>
        <trans-unit id="d74824efd3c4979bad6a6f8c4e477bf4cb023fd4" translate="yes" xml:space="preserve">
          <source>Also, it's worth noting that patterns defined this way probably will not be as efficient, as the optimizer is not very clever about handling them.</source>
          <target state="translated">また、このように定義されたパターンは、オプティマイザがそれらを扱うことについてあまり賢くないので、おそらく効率的ではないだろうということにも注目しておきましょう。</target>
        </trans-unit>
        <trans-unit id="487cc7057b2c00a1fbc251ce9c403787bcbb592b" translate="yes" xml:space="preserve">
          <source>Also, lines should not be split within &lt;code&gt;CRLF&lt;/code&gt; (i.e. there is no empty line between &lt;code&gt;\r&lt;/code&gt; and &lt;code&gt;\n&lt;/code&gt; ). For &lt;code&gt;CRLF&lt;/code&gt; , try the &lt;code&gt;:crlf&lt;/code&gt; layer (see &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;).</source>
          <target state="translated">また、行は &lt;code&gt;CRLF&lt;/code&gt; 内で分割しないでください（つまり、 &lt;code&gt;\r&lt;/code&gt; と &lt;code&gt;\n&lt;/code&gt; 間に空の行はありません）。 &lt;code&gt;CRLF&lt;/code&gt; については、 &lt;code&gt;:crlf&lt;/code&gt; レイヤーを試してください（&lt;a href=&quot;perlio&quot;&gt;PerlIOを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="63323aa4e4ec3045e43bf822a9f6601fadcf053b" translate="yes" xml:space="preserve">
          <source>Also, negative signal values don't do anything special under VMS; they're just converted to the corresponding positive value.</source>
          <target state="translated">また、負の信号値はVMSの下では特別なことをするわけではなく、対応する正の値に変換されるだけです。</target>
        </trans-unit>
        <trans-unit id="6a350d1c09fc9665a8e389e53064c822190440b0" translate="yes" xml:space="preserve">
          <source>Also, note that using the file tests for security purposes is a lost cause from the start: there is a window open for race conditions (who is to say that the permissions will not change between the test and the real operation?). Therefore if you are serious about security, just try the real operation and test for its success - think in terms of atomic operations. Filetests are more useful for filesystem administrative tasks, when you have no need for the content of the elements on disk.</source>
          <target state="translated">また、セキュリティ目的でファイルテストを使うことは、最初から原因を見失っていることに注意してください。ですから、セキュリティを真剣に考えているのであれば、実際の操作を試してみて、その成功をテストしてみてください-アトミック操作の観点から考えてください。ファイルテストは、ディスク上の要素の内容を必要としない場合には、ファイルシステムの管理タスクのために、より有用です。</target>
        </trans-unit>
        <trans-unit id="d574d865815009daf05f1054bf415b0bf6943266" translate="yes" xml:space="preserve">
          <source>Also, note the following:</source>
          <target state="translated">また、以下の点にも注意してください。</target>
        </trans-unit>
        <trans-unit id="48ddb81f1627e1f3a6389ef3f6f1aa66ba367e47" translate="yes" xml:space="preserve">
          <source>Also, once a project is otherwise complete and you start to localize it, you can scrape together all the various keys you use, and pass it to a translator; and then the translator's work will go faster if what he's presented is this:</source>
          <target state="translated">また、プロジェクトが完成してローカリゼーションを始めたら、使用している様々なキーをまとめて翻訳者に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="25de230710079ae2e7ac75bdcf59f8719d1c3ed7" translate="yes" xml:space="preserve">
          <source>Also, perl can be recompiled to operate on an earlier version of the Unicode standard. Further information is at &lt;code&gt;$Config{privlib}&lt;/code&gt; /</source>
          <target state="translated">また、perlを再コンパイルして、以前のバージョンのUnicode標準で動作させることもできます。詳細は &lt;code&gt;$Config{privlib}&lt;/code&gt; /にあります</target>
        </trans-unit>
        <trans-unit id="76997e16af65c741ca3a61aadd72db51de092e73" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;$x&lt;/code&gt; is lexical, it can't be reached or modified by any Perl code outside.</source>
          <target state="translated">また、 &lt;code&gt;$x&lt;/code&gt; はレキシカルであるため、外部のPerlコードから到達または変更することはできません。</target>
        </trans-unit>
        <trans-unit id="38f33518e3f4f0a218000c4a9eb29242c2ff03c6" translate="yes" xml:space="preserve">
          <source>Also, since the number of opcodes in your current version of perl might not be an exact multiple of eight, there may be unused bits in the last byte of an upset. This should not cause any problems (Opcode functions ignore those extra bits) but it does mean that using the ~ operator will typically not produce the same 'physical' opset 'string' as the invert_opset function.</source>
          <target state="translated">また、現在のバージョンの perl のオペコード数は 8 の正確な倍数ではないかもしれないので、アップセットの最後のバイトに未使用のビットがあるかもしれません。これは問題にならないはずですが (オプコード関数はこれらの余分なビットを無視します)、 ~ 演算子を使用しても通常は invert_opset 関数と同じ「物理的な」オプセットの「文字列」が生成されないことを意味しています。</target>
        </trans-unit>
        <trans-unit id="3ed7ac3c49479a3dd530e1364bfdfcfdef42d4e9" translate="yes" xml:space="preserve">
          <source>Also, some common socket &quot;newline&quot; constants are provided: the constants &lt;code&gt;CR&lt;/code&gt; , &lt;code&gt;LF&lt;/code&gt; , and &lt;code&gt;CRLF&lt;/code&gt; , as well as &lt;code&gt;$CR&lt;/code&gt; , &lt;code&gt;$LF&lt;/code&gt; , and &lt;code&gt;$CRLF&lt;/code&gt; , which map to &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; , and &lt;code&gt;\015\012&lt;/code&gt; . If you do not want to use the literal characters in your programs, then use the constants provided here. They are not exported by default, but can be imported individually, and with the &lt;code&gt;:crlf&lt;/code&gt; export tag:</source>
          <target state="translated">また、いくつかの一般的なソケット「改行」定数が提供されています。定数 &lt;code&gt;CR&lt;/code&gt; 、 &lt;code&gt;LF&lt;/code&gt; 、および &lt;code&gt;CRLF&lt;/code&gt; と、 &lt;code&gt;$CR&lt;/code&gt; 、 &lt;code&gt;$LF&lt;/code&gt; 、および &lt;code&gt;$CRLF&lt;/code&gt; 、 &lt;code&gt;\015&lt;/code&gt; 、 &lt;code&gt;\012&lt;/code&gt; 、および &lt;code&gt;\015\012&lt;/code&gt; マップされます。プログラムでリテラル文字を使用したくない場合は、ここで提供されている定数を使用してください。これらはデフォルトではエクスポートされませんが、個別にインポートできます。また、 &lt;code&gt;:crlf&lt;/code&gt; エクスポートタグを使用します。</target>
        </trans-unit>
        <trans-unit id="13c4a82fda1ed827381af159c98e8fcbdf05900b" translate="yes" xml:space="preserve">
          <source>Also, some special instructions for building Perl with Sun Studio on Linux. Following the normal &lt;code&gt;Configure&lt;/code&gt; , you have to run make as follows:</source>
          <target state="translated">また、Linux上のSun StudioでPerlを構築するためのいくつかの特別な指示。通常の &lt;code&gt;Configure&lt;/code&gt; に従って、次のようにmakeを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="430b83395a22758023df144cbbf527affef6a44c" translate="yes" xml:space="preserve">
          <source>Also, subroutines could be declared with the &lt;code&gt;:locked&lt;/code&gt; attribute which would serialize access to the subroutine, but allowed different threads non-simultaneous access.</source>
          <target state="translated">また、サブルーチンは、サブルーチンへのアクセスをシリアル化する &lt;code&gt;:locked&lt;/code&gt; 属性を使用して宣言できますが、異なるスレッドに非同時アクセスを許可しました。</target>
        </trans-unit>
        <trans-unit id="cdb14deb83dae5ba493a96acfadaf1236cbdc5ea" translate="yes" xml:space="preserve">
          <source>Also, the object is configured such that it stringifies to the name of the temporary file and so can be compared to a filename directly. It numifies to the C</source>
          <target state="translated">また、オブジェクトは一時ファイルの名前を文字列化し、直接ファイル名と比較できるように設定されています。また、オブジェクトは、一時ファイルの名前を文字列化して</target>
        </trans-unit>
        <trans-unit id="ad7807da341a2e1187eef533ebec80cd0117d203" translate="yes" xml:space="preserve">
          <source>Also, the range 'A' - 'Z' in ASCII is an unbroken sequence of 26 upper case alphabetic characters. That is not true in EBCDIC. Nor for 'a' to 'z'. But '0' - '9' is an unbroken range in both systems. Don't assume anything about other ranges. (Note that special handling of ranges in regular expression patterns makes it appear to Perl code that the aforementioned ranges are all unbroken.)</source>
          <target state="translated">また、ASCIIの'A'~'Z'の範囲は、アルファベットの大文字26文字が途切れずに並んでいます。EBCDICではそうではありません。a' から 'z' もそうです。しかし、'0'-'9' はどちらのシステムでも途切れない範囲です。他の範囲については何も仮定しないでください。(正規表現パターンでの範囲の特別な処理により、Perl のコードでは前述の範囲がすべて途切れていないように見えることに注意してください)。</target>
        </trans-unit>
        <trans-unit id="11e213d7b8a81bd451ffb3f3ae8fa862e904a6c3" translate="yes" xml:space="preserve">
          <source>Also, the use of Unicode may present security issues that aren't obvious. Read &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;Unicode Security Considerations&lt;/a&gt;.</source>
          <target state="translated">また、Unicodeを使用すると、明らかではないセキュリティの問題が発生する可能性があります。&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;Unicodeのセキュリティに関する考慮事項&lt;/a&gt;をお読みください。</target>
        </trans-unit>
        <trans-unit id="5a6ddd5f6cea51490776d1ee7aa46674933e080d" translate="yes" xml:space="preserve">
          <source>Also, under this modifier, case-insensitive matching works on the full set of Unicode characters. The &lt;code&gt;KELVIN SIGN&lt;/code&gt; , for example matches the letters &quot;k&quot; and &quot;K&quot;; and &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; matches the sequence &quot;ff&quot;, which, if you're not prepared, might make it look like a hexadecimal constant, presenting another potential security issue. See &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt; for a detailed discussion of Unicode security issues.</source>
          <target state="translated">また、この修飾子の下では、大文字と小文字を区別しないマッチングは、Unicode文字のフルセットで機能します。 &lt;code&gt;KELVIN SIGN&lt;/code&gt; 、例えば文字「K」と「K」と一致します。そして &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; は、あなたが準備していない場合、それは別の潜在的なセキュリティ問題を提示し、進定数のように見えるように可能性があるシーケンス「FF」を、一致します。Unicodeのセキュリティ問題の詳細については、&lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http：//unicode.org/reports/tr36&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7d458ad7a020a232313ae8d56db7bcab0ded5305" translate="yes" xml:space="preserve">
          <source>Also, various synonyms like &lt;code&gt;\p{Alpha}&lt;/code&gt; for &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; ; all listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;</source>
          <target state="translated">また、のような様々な同義語 &lt;code&gt;\p{Alpha}&lt;/code&gt; ため &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; 。&lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;perlunipropsの\ p {}および\ P {}を介してアクセス可能なプロパティに&lt;/a&gt;リストされているすべて</target>
        </trans-unit>
        <trans-unit id="3fd51e4e1d10037d178287b3c2e52d39f31c50f2" translate="yes" xml:space="preserve">
          <source>Also, when your</source>
          <target state="translated">また、あなたの</target>
        </trans-unit>
        <trans-unit id="94df63c3696c6e9f216a0b26ed643a62ffdfe44b" translate="yes" xml:space="preserve">
          <source>Also, white space, hyphens, and underscores are normally ignored everywhere between the {braces}, and hence can be freely added or removed even if the &lt;code&gt;/x&lt;/code&gt; modifier hasn't been specified on the regular expression. But in the table below a '&lt;b&gt;T&lt;/b&gt;' at the beginning of an entry means that tighter (stricter) rules are used for that entry:</source>
          <target state="translated">また、ホワイトスペース、ハイフン、アンダースコアは通常、{中かっ​​こ}の間のすべての場所で無視されるため、正規表現で &lt;code&gt;/x&lt;/code&gt; 修飾子が指定されていなくても、自由に追加または削除できます。ただし、以下の表で、エントリの先頭にある「&lt;b&gt;T&lt;/b&gt;」は、そのエントリに対してより厳しい（より厳しい）ルールが使用されていることを意味します。</target>
        </trans-unit>
        <trans-unit id="87ea7db4a430030d90185495584807fc225cd906" translate="yes" xml:space="preserve">
          <source>Also:</source>
          <target state="translated">Also:</target>
        </trans-unit>
        <trans-unit id="554a943cef6b1565f2a13a13d21f280b671c0db6" translate="yes" xml:space="preserve">
          <source>Alter regular expression behaviour</source>
          <target state="translated">正規表現の動作を変更する</target>
        </trans-unit>
        <trans-unit id="4b26f888988c3f23411577d380346f5e87008e97" translate="yes" xml:space="preserve">
          <source>Alternate Stack Manipulation</source>
          <target state="translated">代替スタック操作</target>
        </trans-unit>
        <trans-unit id="fd038ee8b646edddd400b75f62f9db870f503cd5" translate="yes" xml:space="preserve">
          <source>Alternately, if you have an SV that is a blessed reference, you can find out the stash pointer by using:</source>
          <target state="translated">あるいは、祝福された参照先であるSVがある場合は、スタッシュポインタを利用して調べることができます。</target>
        </trans-unit>
        <trans-unit id="6589e5a8ee283a61027f2499ac81f9bd22f55b5a" translate="yes" xml:space="preserve">
          <source>Alternately, if you import &lt;code&gt;:constants&lt;/code&gt; , you can use the following constants directly:</source>
          <target state="translated">または、 &lt;code&gt;:constants&lt;/code&gt; をインポートする場合、次の定数を直接使用できます。</target>
        </trans-unit>
        <trans-unit id="3835ce5fac7a47f4550c37daaf24821ea36a9658" translate="yes" xml:space="preserve">
          <source>Alternately, if you use OS/2-ish shell, like CMD or 4os2, put the following at the start of your perl script:</source>
          <target state="translated">あるいは、CMDや4os2のようなOS/2っぽいシェルを使っている場合は、perlスクリプトの先頭に以下のように記述してください。</target>
        </trans-unit>
        <trans-unit id="3c02b30c04d1bd2e064bba714a6c966f7e7001cc" translate="yes" xml:space="preserve">
          <source>Alternately, try running pod2text on</source>
          <target state="translated">別の方法として、pod2textを</target>
        </trans-unit>
        <trans-unit id="c6586bf995507ef47c1e8462c0b96f9bda48432b" translate="yes" xml:space="preserve">
          <source>Alternately, you can change to binary mode on an existing handle this way:</source>
          <target state="translated">別の方法として、この方法で既存のハンドルをバイナリモードに変更することもできます。</target>
        </trans-unit>
        <trans-unit id="436c604fc9e91f4036987513f30ceb0b117df526" translate="yes" xml:space="preserve">
          <source>Alternately, you can set the global variable &lt;code&gt;$Carp::Verbose&lt;/code&gt; to true. See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section below.</source>
          <target state="translated">または、グローバル変数 &lt;code&gt;$Carp::Verbose&lt;/code&gt; をtrueに設定できます。以下の「 &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="15f2c59a8b9b5baf596fabaf5af782241acbedb6" translate="yes" xml:space="preserve">
          <source>Alternately, you can specify the exact directory to place the extension's files by placing a &quot;PREFIX=/destination/directory&quot; after the make install (or in between the make and install if you have a brain-dead version of make). This can be very useful if you are building an extension that will eventually be distributed to multiple systems. You can then just archive the files in the destination directory and distribute them to your destination systems.</source>
          <target state="translated">あるいは、make install の後に &quot;PREFIX=/destination/directory&quot; を指定して、拡張機能のファイルを置くディレクトリを正確に指定することもできます (あるいは、頭の悪いバージョンの make を使っている場合は make と install の間に指定してください)。これは、最終的に複数のシステムに配布されるような拡張機能を構築している場合に非常に便利です。インストール先ディレクトリにあるファイルをアーカイブして、インストール先のシステムに配布すればいいのです。</target>
        </trans-unit>
        <trans-unit id="e00c3a1ce8b9e2b0c7ee0051f3ec0d7cf8bcbdb9" translate="yes" xml:space="preserve">
          <source>Alternately, you can try to get a replacement for the system's &lt;b&gt;Execute&lt;/b&gt; command that honors the #!/usr/bin/perl syntax in scripts and set the s-Bit of your scripts. Then you can invoke your scripts like under UNIX with</source>
          <target state="translated">あるいは、スクリプト内の＃！/ usr / bin / perl構文を尊重し、スクリプトのsビットを設定するシステムの&lt;b&gt;実行&lt;/b&gt;コマンドの代替を取得することもできます。次に、UNIXのようにスクリプトを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="70b8f05f7796eca9b3373c7ecd058a653ad0409c" translate="yes" xml:space="preserve">
          <source>Alternately, you can use &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, the regular expression quote operator (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details). It quotes and perhaps compiles the pattern, and you can apply regular expression flags to the pattern.</source>
          <target state="translated">または、正規表現の引用演算子である &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; を使用できます（詳細については、&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;を参照してください）。パターンを引用し、おそらくコンパイルします。正規表現フラグをパターンに適用できます。</target>
        </trans-unit>
        <trans-unit id="5b04c7a5831dedb851aed975f051c1cac400682e" translate="yes" xml:space="preserve">
          <source>Alternation</source>
          <target state="translated">Alternation</target>
        </trans-unit>
        <trans-unit id="be9a6aa6691045b50a599c27892a7efaa458c7af" translate="yes" xml:space="preserve">
          <source>Alternation allows a regexp to choose among alternatives, but by itself it is unsatisfying. The reason is that each alternative is a whole regexp, but sometime we want alternatives for just part of a regexp. For instance, suppose we want to search for housecats or housekeepers. The regexp &lt;code&gt;housecat|housekeeper&lt;/code&gt; fits the bill, but is inefficient because we had to type &lt;code&gt;house&lt;/code&gt; twice. It would be nice to have parts of the regexp be constant, like &lt;code&gt;house&lt;/code&gt; , and some parts have alternatives, like &lt;code&gt;cat|keeper&lt;/code&gt; .</source>
          <target state="translated">代替は正規表現が代替の中から選択することを可能にしますが、それだけでは満足できません。その理由は、それぞれの代替案が完全な正規表現であるためですが、正規表現の一部だけの代替案が必要になる場合があります。たとえば、家猫や家政婦を検索したいとします。正規表現の &lt;code&gt;housecat|housekeeper&lt;/code&gt; は法案に適合しますが、 &lt;code&gt;house&lt;/code&gt; 2回入力する必要があったため、非効率的です。正規表現の一部を &lt;code&gt;house&lt;/code&gt; のように一定にして、一部の部分を &lt;code&gt;cat|keeper&lt;/code&gt; ように変更できるようにすると便利です。</target>
        </trans-unit>
        <trans-unit id="1cf43ccde7eeaee521a4a189652a63c1baacf5e0" translate="yes" xml:space="preserve">
          <source>Alternations behave the same way in groups as out of them: at a given string position, the leftmost alternative that allows the regexp to match is taken. So in the last example at the first string position, &lt;code&gt;&quot;20&quot;&lt;/code&gt; matches the second alternative, but there is nothing left over to match the next two digits &lt;code&gt;\d\d&lt;/code&gt; . So Perl moves on to the next alternative, which is the null alternative and that works, since &lt;code&gt;&quot;20&quot;&lt;/code&gt; is two digits.</source>
          <target state="translated">代替は、グループ内でもグループ外でも同じように動作します。指定された文字列の位置で、正規表現の一致を可能にする左端の代替が採用されます。したがって、最初の文字列位置の最後の例では、 &lt;code&gt;&quot;20&quot;&lt;/code&gt; は2番目の選択肢と一致しますが、次の2桁の &lt;code&gt;\d\d&lt;/code&gt; と一致するものはありません。したがって、 &lt;code&gt;&quot;20&quot;&lt;/code&gt; は2桁なので、Perlは次の選択肢に進みます。これはnullの選択肢であり、機能します。</target>
        </trans-unit>
        <trans-unit id="92135acee6fb42da0402ddedc5b8263e8afa69de" translate="yes" xml:space="preserve">
          <source>Alternative capture group numbering</source>
          <target state="translated">代替キャプチャグループのナンバリング</target>
        </trans-unit>
        <trans-unit id="79c07200d4699b036f2138680fade3c9689f7058" translate="yes" xml:space="preserve">
          <source>Alternative math libraries</source>
          <target state="translated">代替の数学ライブラリ</target>
        </trans-unit>
        <trans-unit id="6aa5c766a08c26061e42a91b28e7696a27f14067" translate="yes" xml:space="preserve">
          <source>Alternative option starters</source>
          <target state="translated">代替オプションのスターター</target>
        </trans-unit>
        <trans-unit id="443fe46b83982a5185e410eceac3b7185f7ae257" translate="yes" xml:space="preserve">
          <source>Alternative to Test::More::use_ok</source>
          <target state="translated">Test::More::use_ok に代わるもの</target>
        </trans-unit>
        <trans-unit id="c7461a3c1c3204afbbfd69dbbccd1e2b59471f99" translate="yes" xml:space="preserve">
          <source>Alternative warn and die for modules</source>
          <target state="translated">モジュールのための代替的な警告とダイ</target>
        </trans-unit>
        <trans-unit id="12e5972b55b252c3c9bc2d82985850d79c96249e" translate="yes" xml:space="preserve">
          <source>Alternatively edit the init file interactively via: 3rd mouse button -&amp;gt; New Display -&amp;gt; Edit Menu</source>
          <target state="translated">または、次の方法でインタラクティブに初期化ファイルを編集します。3番目のマウスボタン-&amp;gt; [新しい表示]-&amp;gt; [編集]メニュー</target>
        </trans-unit>
        <trans-unit id="44c86b27ab468eef89d417477ce09eb4480abfb2" translate="yes" xml:space="preserve">
          <source>Alternatively look here: &lt;a href=&quot;http://www.unix.com/man-page/FreeBSD/3/strftime/&quot;&gt;http://www.unix.com/man-page/FreeBSD/3/strftime/&lt;/a&gt;</source>
          <target state="translated">または、こちらを&lt;a href=&quot;http://www.unix.com/man-page/FreeBSD/3/strftime/&quot;&gt;ご覧ください&lt;/a&gt;：http : //www.unix.com/man-page/FreeBSD/3/strftime/</target>
        </trans-unit>
        <trans-unit id="5d17661d2312f06dcd6c1a5156f20af2512c469b" translate="yes" xml:space="preserve">
          <source>Alternatively the list of subfields can by supplied as a scalar, thus</source>
          <target state="translated">また、サブフィールドのリストをスカラ値として提供することもできます。</target>
        </trans-unit>
        <trans-unit id="0e3d4d311210785c85520063de48eeff7de6af69" translate="yes" xml:space="preserve">
          <source>Alternatively you can use the compiler directive our() to bring a dynamic variable into the current lexical scope.</source>
          <target state="translated">あるいは、コンパイラディレクティブ our()を使用して動的変数を現在の辞書スコープに入れることもできます。</target>
        </trans-unit>
        <trans-unit id="2cec5cf8bbfadcf33f7e5849e13d536e2c1766e0" translate="yes" xml:space="preserve">
          <source>Alternatively you can use:</source>
          <target state="translated">または、使用することができます。</target>
        </trans-unit>
        <trans-unit id="43f0cea439a0fe2f49f0e9b79ff517dcdbec8d84" translate="yes" xml:space="preserve">
          <source>Alternatively you may be able to get these docs prebuilt from &lt;code&gt;CPAN&lt;/code&gt; .</source>
          <target state="translated">あるいは、これらのドキュメントを &lt;code&gt;CPAN&lt;/code&gt; から事前に作成することもできます。</target>
        </trans-unit>
        <trans-unit id="f7f7013a74aa2034d027da86e6edefa6ad1f3b65" translate="yes" xml:space="preserve">
          <source>Alternatively you may be able to get these docs prebuilt from CPAN.</source>
          <target state="translated">あるいは、これらのドキュメントをCPANから事前に作成してもらうこともできます。</target>
        </trans-unit>
        <trans-unit id="06dab9dc9469b67b9f013b1f7d978b8fd09b7e74" translate="yes" xml:space="preserve">
          <source>Alternatively, Berkeley DB version 1 is available at your nearest CPAN archive in</source>
          <target state="translated">また、Berkeley DB バージョン 1 は、お近くの CPAN アーカイブで入手できます。</target>
        </trans-unit>
        <trans-unit id="18aa5e8fea6653b702c48738f98b3e8db633fcaf" translate="yes" xml:space="preserve">
          <source>Alternatively, an array reference of section specifications can be used:</source>
          <target state="translated">あるいは、セクション仕様の配列参照を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="89c6743b65649f02ac7d006f9c75c999b8c0f7a0" translate="yes" xml:space="preserve">
          <source>Alternatively, as of version 2.24, the configuration options may be passed together with the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement:</source>
          <target state="translated">または、バージョン2.24以降では、構成オプションを &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ステートメントとともに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="e9aa6c54c04158a408f2c0b76a7a51f158187ce5" translate="yes" xml:space="preserve">
          <source>Alternatively, if you don't need perlglob.exe and don't need to enable the USE_SETARGV option then you can safely just remove all mention of $(GLOBEXE) from win32/Makefile and setargv.obj won't be required anyway.</source>
          <target state="translated">あるいは、perlglob.exeが不要で、USE_SETARGVオプションを有効にする必要がない場合は、win32/Makefileから$(GLOBEXE)の言及をすべて削除するだけで安全に、setargv.objはいずれにせよ必要ありません。</target>
        </trans-unit>
        <trans-unit id="068fceff1e33e5da627a6b110b456936f6082b0c" translate="yes" xml:space="preserve">
          <source>Alternatively, if you have the &lt;code&gt;gunzip&lt;/code&gt; program available, you can use this to read compressed files</source>
          <target state="translated">または、 &lt;code&gt;gunzip&lt;/code&gt; プログラムを使用できる場合は、これを使用して圧縮ファイルを読み取ることができます</target>
        </trans-unit>
        <trans-unit id="4d16466752d2c087e599f1526f5793b26a5e2b0a" translate="yes" xml:space="preserve">
          <source>Alternatively, if you want to read the &lt;code&gt;&quot;data1&quot;&lt;/code&gt; member into memory, use a scalar reference for the &lt;code&gt;output&lt;/code&gt; parameter.</source>
          <target state="translated">または、 &lt;code&gt;&quot;data1&quot;&lt;/code&gt; メンバーをメモリに読み込む場合は、 &lt;code&gt;output&lt;/code&gt; パラメーターにスカラー参照を使用します。</target>
        </trans-unit>
        <trans-unit id="742c3c00178ebe72a9bfad0e3ef29810b62b04e9" translate="yes" xml:space="preserve">
          <source>Alternatively, put this as the first line of your script:</source>
          <target state="translated">あるいは、これをスクリプトの最初の行として記述することもできます。</target>
        </trans-unit>
        <trans-unit id="daefa0329439a8224d52050e5214c48286284b22" translate="yes" xml:space="preserve">
          <source>Alternatively, rather than having to explicitly name each of the files that you want to compress, you could use a fileglob to select all the &lt;code&gt;txt&lt;/code&gt; files in the current directory, as follows</source>
          <target state="translated">または、圧縮する各ファイルに明示的に名前を付ける必要はなく、fileglobを使用して、次のように現在のディレクトリ内のすべての &lt;code&gt;txt&lt;/code&gt; ファイルを選択できます。</target>
        </trans-unit>
        <trans-unit id="c44b1aed9efe7eda393df0bd7f553f139ab03a17" translate="yes" xml:space="preserve">
          <source>Alternatively, simply use &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; for comparisons, this will get it always right. There is not yet a way to get a number automatically represented as a string that matches exactly the way Perl represents it.</source>
          <target state="translated">または、比較に &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; を使用するだけで、常に正しい結果が得られます。Perlがそれを表す方法と正確に一致する文字列として自動的に表される数を取得する方法はまだありません。</target>
        </trans-unit>
        <trans-unit id="8ad4e77e5423588b083e2af8975456f597a84a91" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;text/parsewords&quot;&gt;Text::ParseWords&lt;/a&gt; module (part of the standard Perl distribution) lets you say:</source>
          <target state="translated">あるいは、&lt;a href=&quot;text/parsewords&quot;&gt;Text :: ParseWords&lt;/a&gt;モジュール（標準のPerlディストリビューションの一部）では、次のように言うことができます。</target>
        </trans-unit>
        <trans-unit id="e3f5b7f0771697b931c8ecd89602848a9590421e" translate="yes" xml:space="preserve">
          <source>Alternatively, the crypt libraries in GNU libc have been ported to Cygwin.</source>
          <target state="translated">あるいは、GNU libc の crypt ライブラリは Cygwin に移植されています。</target>
        </trans-unit>
        <trans-unit id="996763dc438b824d04ceb178a7d6d2de1f4e3617" translate="yes" xml:space="preserve">
          <source>Alternatively, using a customized typemap for your purposes in the first place is probably preferable.</source>
          <target state="translated">あるいは、そもそもの目的に合わせてカスタマイズされたタイプマップを使用することが望ましいでしょう。</target>
        </trans-unit>
        <trans-unit id="818d3daf2781969164beb46d939858b0992b14b8" translate="yes" xml:space="preserve">
          <source>Alternatively, we could have used &lt;code&gt;C&lt;/code&gt; to unpack the individually accessible byte registers FL, FH, AL, AH, etc.:</source>
          <target state="translated">あるいは、 &lt;code&gt;C&lt;/code&gt; を使用して、個別にアクセス可能なバイトレジスタFL、FH、AL、AHなどをアンパックすることもできます。</target>
        </trans-unit>
        <trans-unit id="973c34c798c56bb32a7153f1be5f39dd390df9c7" translate="yes" xml:space="preserve">
          <source>Alternatively, you can fiddle with the stack directly: &lt;code&gt;SP&lt;/code&gt; gives you the first element in your portion of the stack, and &lt;code&gt;TOP*&lt;/code&gt; gives you the top SV/IV/NV/etc. on the stack. So, for instance, to do unary negation of an integer:</source>
          <target state="translated">または、スタックを直接いじることもできます &lt;code&gt;SP&lt;/code&gt; はスタックの最初の要素を提供し、 &lt;code&gt;TOP*&lt;/code&gt; は上位のSV / IV / NV / etcを提供します。スタック上。したがって、たとえば、整数の単項否定を行うには：</target>
        </trans-unit>
        <trans-unit id="4486c955e53dc63730c2501b04fe03ec6d1fb66c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can quote the class name:</source>
          <target state="translated">あるいは、クラス名を引用することもできます。</target>
        </trans-unit>
        <trans-unit id="9393a15204a23768f5fb6e120d832da535fff827" translate="yes" xml:space="preserve">
          <source>Alternatively, you can specify that the option can have multiple values by adding a &quot;@&quot;, and pass a scalar reference as the destination:</source>
          <target state="translated">あるいは、オプションに&quot;@&quot;を追加して複数の値を持つことができるように指定し、スカラ参照を宛先として渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="86794ed15412a1fa79e33d4ba8f3e04841c9eebc" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the &lt;code&gt;plan()&lt;/code&gt; function. Useful for when you have to calculate the number of tests.</source>
          <target state="translated">または、 &lt;code&gt;plan()&lt;/code&gt; 関数を使用することもできます。テストの数を計算する必要がある場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="bd695ed1549655fbf2b6a69e34efa112b5887ecd" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the GCC_EXEC_PREFIX environment variable to ensure that Sun's as and ld are used. Consult your gcc documentation for further information on the -B option and the GCC_EXEC_PREFIX variable.</source>
          <target state="translated">あるいは、GCC_EXEC_PREFIX 環境変数を使用して、Sun の as と ld が確実に使用されるようにすることもできます。BオプションとGCC_EXEC_PREFIX変数の詳細については、gccのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="5e3eb7cca34a1ce6ec3422f81caa582587938fc9" translate="yes" xml:space="preserve">
          <source>Alternatively, you may inspect the value of &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; with the &lt;code&gt;W*()&lt;/code&gt; calls from the POSIX module.</source>
          <target state="translated">別の方法として、次の値検査することができる &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; との &lt;code&gt;W*()&lt;/code&gt; POSIXモジュールからの呼び出しを。</target>
        </trans-unit>
        <trans-unit id="efc46e4aa2514a5747d9e66b804729fd4f6f91eb" translate="yes" xml:space="preserve">
          <source>Alternatives are tried from left to right, so the first alternative found for which the entire expression matches, is the one that is chosen. This means that alternatives are not necessarily greedy. For example: when matching &lt;code&gt;foo|foot&lt;/code&gt; against &quot;barefoot&quot;, only the &quot;foo&quot; part will match, as that is the first alternative tried, and it successfully matches the target string. (This might not seem important, but it is important when you are capturing matched text using parentheses.)</source>
          <target state="translated">選択肢は左から右に試行されるため、式全体が一致する最初に見つかった選択肢が選択されます。つまり、代替案は必ずしも貪欲ではありません。例： &lt;code&gt;foo|foot&lt;/code&gt; を &quot;barefoot&quot;と照合する場合、 &quot;foo&quot;の部分のみが一致します。これは、最初に試行された代替であり、ターゲット文字列と正常に一致するためです。（これは重要に見えないかもしれませんが、括弧を使用して一致したテキストをキャプチャする場合は重要です。）</target>
        </trans-unit>
        <trans-unit id="178ef3c8a39076052130de80299d367dd5e6090f" translate="yes" xml:space="preserve">
          <source>Alternatives to raw</source>
          <target state="translated">生の代替品</target>
        </trans-unit>
        <trans-unit id="895965b31db8e4bfa4de954e884b587830b4927d" translate="yes" xml:space="preserve">
          <source>Alternativly look at &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Auth::Basic&quot;&gt;Plack::Middleware::Auth::Basic&lt;/a&gt;, or one of the other &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%2bauth&quot;&gt;Plack authentication&lt;/a&gt; options.</source>
          <target state="translated">代わりに、&lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Auth::Basic&quot;&gt;Plack :: Middleware :: Auth :: Basic&lt;/a&gt;または他の&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%2bauth&quot;&gt;Plack認証&lt;/a&gt;オプションの1つを確認してください。</target>
        </trans-unit>
        <trans-unit id="083655cd712cf57272ed2f0a7a5805f36d9802f0" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; cannot do this directly, there is a module which can layer transparently over &lt;b&gt;DB_File&lt;/b&gt; to accomplish this feat.</source>
          <target state="translated">けれども&lt;b&gt;はDB_Fileは&lt;/b&gt;直接これを行うことはできません、上に透過層ができモジュールがあり&lt;b&gt;DB_Fileで&lt;/b&gt;この偉業を達成します。</target>
        </trans-unit>
        <trans-unit id="3768f14455445c5980f80214d4ffa65dc7a14002" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; is covered by the Perl license, the library it makes use of, namely Berkeley DB, is not. Berkeley DB has its own copyright and its own license. Please take the time to read it.</source>
          <target state="translated">けれども&lt;b&gt;のDB_Fileは、&lt;/b&gt; Perlのライセンスでカバーされ、ライブラリーは、それは、つまりBerkeley DBは、を利用していません。Berkeley DBには、独自の著作権と独自のライセンスがあります。時間をかけて読んでください。</target>
        </trans-unit>
        <trans-unit id="73b1840016122f68e05350fe0f1ab0303bd2fd8b" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; is intended to be used with Berkeley DB version 1, it can also be used with version 2, 3 or 4. In this case the interface is limited to the functionality provided by Berkeley DB 1.x. Anywhere the version 2 or greater interface differs, &lt;b&gt;DB_File&lt;/b&gt; arranges for it to work like version 1. This feature allows &lt;b&gt;DB_File&lt;/b&gt; scripts that were built with version 1 to be migrated to version 2 or greater without any changes.</source>
          <target state="translated">けれども&lt;b&gt;はDB_Fileを&lt;/b&gt; Berkeley DBバージョン1を使用することを意図され、それはこの場合にも、バージョン2、3または4で使用することができるインタフェースはバークレイDB 1.xのによって提供される機能に制限され バージョン2以降のインターフェースが異なる場合、&lt;b&gt;DB_File&lt;/b&gt;はバージョン1のように機能するように&lt;b&gt;調整し&lt;/b&gt;ます。この機能により、バージョン1でビルドされた&lt;b&gt;DB_File&lt;/b&gt;スクリプトを変更せずにバージョン2以降に移行できます。</target>
        </trans-unit>
        <trans-unit id="a4ee4e9c8be6f9bb865a03f9dd6635b3149d28d3" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;$_&lt;/code&gt; doesn't actually appear explicitly in the sample filters above, it is implicitly used in a number of places.</source>
          <target state="translated">が &lt;code&gt;$_&lt;/code&gt; 実際に上記のサンプルフィルタで明示的に表示されません、それは暗黙のうちに多くの場所で使用されています。</target>
        </trans-unit>
        <trans-unit id="80dfb6d994a40fa49e44520920eac36d9fa1f16f" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; is false on a plain not-yet-used hash, it becomes true in several non-obvious circumstances, including iterators, weak references, stash names, even remaining true after &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; . These things make &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; fairly useless in practice, so it now generates a fatal error.</source>
          <target state="translated">が &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; 、プレーン未使用されるハッシュに偽で、それも後に真の残り、イテレータ、弱い参照、隠し名を含む、いくつかの非自明な状況で真となり &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; 。これらのことは、 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; を実際にはかなり役に立たないようにするため、致命的なエラーを生成します。</target>
        </trans-unit>
        <trans-unit id="df1f79335b5e25baa8b910d3ca247a13fd7eda4e" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;cmp_ok()&lt;/code&gt; was introduced in 0.40, 0.86 fixed an important bug to make it safe for overloaded objects; the fixed first shipped with Perl in 5.10.1 as part of Test::More 0.92.</source>
          <target state="translated">けれども &lt;code&gt;cmp_ok()&lt;/code&gt; が 0.40で導入された、0.86は、オーバーロードされたオブジェクトのためにそれを安全にするために重要なバグを修正しました。この修正は、Test :: More 0.92の一部として5.10.1でPerlとともに最初に出荷されました。</target>
        </trans-unit>
        <trans-unit id="1c4fc726a9484b19113d6eedd6d8805f1968eb73" translate="yes" xml:space="preserve">
          <source>Although FileCache can be used with piped opens ('-|' or '|-') doing so is strongly discouraged. If FileCache finds it necessary to close and then reopen a pipe, the command at the far end of the pipe will be reexecuted - the results of performing IO on FileCache'd pipes is unlikely to be what you expect. The ability to use FileCache on pipes may be removed in a future release.</source>
          <target state="translated">FileCache はパイプオープン ('-|' または '|-')と共に使用することができますが、これは強くお勧めしません。FileCache がパイプを閉じて再度開く必要があると判断した場合、パイプの最後尾にあるコマンドが再実行されます-FileCache'd パイプで IO を実行した結果は期待したものではありません。パイプ上で FileCache を使用する機能は、将来のリリースで削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="077804ce34db1c72deaf81a9a83f1e62f8a114a7" translate="yes" xml:space="preserve">
          <source>Although I have made use of only the &lt;code&gt;POP*&lt;/code&gt; macros to access values returned from Perl subroutines, it is also possible to bypass these macros and read the stack using the &lt;code&gt;ST&lt;/code&gt; macro (See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for a full description of the &lt;code&gt;ST&lt;/code&gt; macro).</source>
          <target state="translated">私は唯一の利用作ってきたが &lt;code&gt;POP*&lt;/code&gt; Perlのサブルーチンから返されたアクセス値にマクロを、それがこれらのマクロバイパスすることも可能であるし、使用してスタックを読ん &lt;code&gt;ST&lt;/code&gt; のマクロを（参照&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;の完全な説明のための &lt;code&gt;ST&lt;/code&gt; のマクロを）。</target>
        </trans-unit>
        <trans-unit id="ebf0c3d2a317483257bd5985b5509d45e615f5a4" translate="yes" xml:space="preserve">
          <source>Although PA-RISC binaries can run on Itanium systems, you should not attempt to use a PA-RISC version of Perl on an Itanium system. This is because shared libraries created on an Itanium system cannot be loaded while running a PA-RISC executable.</source>
          <target state="translated">PA-RISCバイナリはItaniumシステム上でも動作しますが、Itaniumシステム上でPA-RISC版のPerlを使用しようとするべきではありません。これは、Itaniumシステム上で作成された共有ライブラリは、PA-RISC実行ファイルを実行している間はロードできないからです。</target>
        </trans-unit>
        <trans-unit id="2b071251c66f97d7a5a833d31d9bbb833fc948ef" translate="yes" xml:space="preserve">
          <source>Although Perl will automatically grow strings for you, if you need to force Perl to allocate more memory for your SV, you can use the macro</source>
          <target state="translated">Perl は自動的に文字列を成長させてくれますが、Perl が SV にもっと多くのメモリを割り当てる必要がある場合は、マクロを使用します。</target>
        </trans-unit>
        <trans-unit id="3fece6ab5bd6d283eb840842e215942103cb610e" translate="yes" xml:space="preserve">
          <source>Although Plan 9 Perl currently only provides static loading, it is built with a number of useful extensions. These include Opcode, FileHandle, Fcntl, and POSIX. Expect to see others (and DynaLoading!) in the future.</source>
          <target state="translated">Plan 9 Perl は現在、スタティック・ローディングのみを提供していますが、多くの便利な拡張機能で構築されています。これらには、Opcode、FileHandle、Fcntl、POSIX が含まれます。将来的には、他の拡張機能(とDynaLoadingも!)に期待してください。</target>
        </trans-unit>
        <trans-unit id="e4e6f6df84571e93788f39ee96ef2a5f0752bec2" translate="yes" xml:space="preserve">
          <source>Although Test::More has been a core module in versions of Perl since 5.6.2, Test::More has evolved since then, and not all of the features you're used to will be present in the shipped version of Test::More. If you are writing a module, don't forget to indicate in your package metadata the minimum version of Test::More that you require. For instance, if you want to use &lt;code&gt;done_testing()&lt;/code&gt; but want your test script to run on Perl 5.10.0, you will need to explicitly require Test::More &amp;gt; 0.88.</source>
          <target state="translated">Test :: Moreは5.6.2以降のバージョンのPerlのコアモジュールですが、Test :: Moreはそれ以降進化しており、使い慣れた機能のすべてが出荷されたバージョンのTest ::に存在するわけではありません。もっと。モジュールを作成している場合は、パッケージメタデータで、必要なTest :: Moreの最小バージョンを示すことを忘れないでください。たとえば、 &lt;code&gt;done_testing()&lt;/code&gt; を使用したいが、テストスクリプトをPerl 5.10.0で実行したい場合は、Test :: More&amp;gt; 0.88を明示的に要求する必要があります。</target>
        </trans-unit>
        <trans-unit id="a0cac5f469f6b90c62f4e56ab4bfa747637957a2" translate="yes" xml:space="preserve">
          <source>Although as of 5.14, that can be also be accomplished this way:</source>
          <target state="translated">5.14の時点では、このようにすることも可能です。</target>
        </trans-unit>
        <trans-unit id="b446ed3017bd4a5c94fd715dbc357d36cd8b9eae" translate="yes" xml:space="preserve">
          <source>Although if your manager accused you of seeking job security (or rapid insecurity) through inscrutable code, it would be hard to argue. :-) If I were you, I'd put that in a function:</source>
          <target state="translated">もしあなたの上司が、不可解なコードを使って仕事の安全性(または急速な不安)を求めていると非難したとしたら、反論するのは難しいでしょうが。私があなただったら、それを関数に入れますね。</target>
        </trans-unit>
        <trans-unit id="4a4e26bb6dd1017566ef68d6d6d4ea499d6e917f" translate="yes" xml:space="preserve">
          <source>Although it has no direct equivalent in C, Perl's &lt;code&gt;//&lt;/code&gt; operator is related to its C-style &quot;or&quot;. In fact, it's exactly the same as &lt;code&gt;||&lt;/code&gt;, except that it tests the left hand side's definedness instead of its truth. Thus, &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; returns the value of &lt;code&gt;EXPR1&lt;/code&gt; if it's defined, otherwise, the value of &lt;code&gt;EXPR2&lt;/code&gt; is returned. (&lt;code&gt;EXPR1&lt;/code&gt; is evaluated in scalar context, &lt;code&gt;EXPR2&lt;/code&gt; in the context of &lt;code&gt;//&lt;/code&gt; itself). Usually, this is the same result as &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; (except that the ternary-operator form can be used as a lvalue, while &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; cannot). This is very useful for providing default values for variables. If you actually want to test if at least one of &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; is defined, use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;($x // $y)&lt;/code&gt; .</source>
          <target state="translated">Cには直接対応するものはありませんが、Perlの &lt;code&gt;//&lt;/code&gt; 演算子はCスタイルの「or」に関連しています。実際、 &lt;code&gt;||&lt;/code&gt; とまったく同じです。、それはその真実の代わりに左側の定義をテストすることを除いて。したがって、 &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; は、定義されている場合は &lt;code&gt;EXPR1&lt;/code&gt; の値を返し、定義されていない場合は &lt;code&gt;EXPR2&lt;/code&gt; の値を返します。 （ &lt;code&gt;EXPR1&lt;/code&gt; はスカラーコンテキストで評価され、 &lt;code&gt;EXPR2&lt;/code&gt; は &lt;code&gt;//&lt;/code&gt; 自体のコンテキストで評価されます）。通常、これは &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; たものと同じ結果です（EXPR1）？ EXPR1：EXPR2（3項演算子形式を左辺値として使用できることを除き、 &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; できません）。これは、変数のデフォルト値を提供するのに非常に役立ちます。 &lt;code&gt;$x&lt;/code&gt; と &lt;code&gt;$y&lt;/code&gt; 少なくとも1つが定義されているかどうかを実際にテストする場合は、 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;($x // $y)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="3d57a21b7f19f0f3f2ceca275a472340c6e4e3a5" translate="yes" xml:space="preserve">
          <source>Although it has the same precedence as in C, Perl's &lt;code&gt;?:&lt;/code&gt; operator produces an lvalue. This assigns $x to either $if_true or $if_false, depending on the trueness of $maybe:</source>
          <target state="translated">Cと同じ優先順位 &lt;code&gt;?:&lt;/code&gt; 、Perlの？：演算子は左辺値を生成します。これは、$ maybeの真実性に応じて、$ xを$ if_trueまたは$ if_falseのいずれかに割り当てます。</target>
        </trans-unit>
        <trans-unit id="5ee0b4360c14601bcb250b62e156bc4ae2010689" translate="yes" xml:space="preserve">
          <source>Although it is a bit confusing and some people object to the terminology, it is worth taking a look at a comment that has been in</source>
          <target state="translated">少し混乱していて、用語に反対する人もいるようですが、以下のようなコメントを見てみる価値はあります。</target>
        </trans-unit>
        <trans-unit id="da1e430c6e0d63cde26c5c8c71827f0d44bf6196" translate="yes" xml:space="preserve">
          <source>Although it is not illegal, the use of &lt;code&gt;MultiHomed&lt;/code&gt; on a socket which is in non-blocking mode is of little use. This is because the first connect will never fail with a timeout as the connect call will not block.</source>
          <target state="translated">違法ではありませんが、ノンブロッキングモードのソケットで &lt;code&gt;MultiHomed&lt;/code&gt; を使用してもほとんど役に立ちません。これは、接続呼び出しがブロックされないため、最初の接続がタイムアウトで失敗することはないためです。</target>
        </trans-unit>
        <trans-unit id="e93362b29f52a34d35cc322a788d526233d087a7" translate="yes" xml:space="preserve">
          <source>Although it is possible (with some effort on your part) to use this module to access .zip files, there are other perl modules available that will do all the hard work for you. Check out &lt;code&gt;Archive::Zip&lt;/code&gt; , &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; , &lt;code&gt;IO::Compress::Zip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt; .</source>
          <target state="translated">このモジュールを使用して.zipファイルにアクセスすることは（ある程度の労力で）可能ですが、他のperlモジュールを使用して、すべてのハードワークを行うことができます。 &lt;code&gt;Archive::Zip&lt;/code&gt; 、 &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; 、 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; および &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt; 確認してください。</target>
        </trans-unit>
        <trans-unit id="7a135fdb236629c700a0674370bcc8d9bb97bd72" translate="yes" xml:space="preserve">
          <source>Although it may be considered internal, the class hierarchy does matter for both users and programmer. CPAN.pm deals with the four classes mentioned above, and those classes all share a set of methods. Classical single polymorphism is in effect. A metaclass object registers all objects of all kinds and indexes them with a string. The strings referencing objects have a separated namespace (well, not completely separated):</source>
          <target state="translated">内部的なものと思われるかもしれませんが、クラスの階層はユーザとプログラマの両方にとって重要です。CPAN.pmは上記の4つのクラスを扱い、それらのクラスはすべてメソッドのセットを共有しています。古典的な単一多相性が有効です。メタクラスオブジェクトは、あらゆる種類のオブジェクトを登録し、文字列でインデックスを付けます。オブジェクトを参照する文字列は分離された名前空間を持っています(まあ、完全に分離されているわけではありませんが)。</target>
        </trans-unit>
        <trans-unit id="c770d25bc14389e491ccd1785ab555be61626cb8" translate="yes" xml:space="preserve">
          <source>Although it may not be immediately obvious from the code above, the associative array interface can be used to write values with duplicate keys, but it cannot be used to read them back from the database.</source>
          <target state="translated">上のコードではすぐにはわからないかもしれませんが、連想配列のインターフェイスは キーが重複している値を書き込むのには使えますが、データベースから値を読み出すのには使えません。</target>
        </trans-unit>
        <trans-unit id="180ef42cd3ef3f7ed108e6700423675760cce278" translate="yes" xml:space="preserve">
          <source>Although it might seem like a real pain, it is really worth the effort of having a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; in all your scripts.</source>
          <target state="translated">それは本当の痛みのように思えるかもしれませんが、すべてのスクリプトで &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; を使用する努力をする価値があります。</target>
        </trans-unit>
        <trans-unit id="7eddb5fd279be6b295018b9f9f42e02ddccfda46" translate="yes" xml:space="preserve">
          <source>Although memory overhead of bigger buckets is kept inside the bucket, for smaller buckets, it is kept in separate areas. This field gives the total size of these areas.</source>
          <target state="translated">大きなバケットのメモリオーバーヘッドはバケット内に保持されますが、小さなバケットの場合は別の領域に保持されます。このフィールドは、これらの領域の合計サイズを与えます。</target>
        </trans-unit>
        <trans-unit id="5fe78f913ab3f5713143fe4461404c36ff017beb" translate="yes" xml:space="preserve">
          <source>Although no warning is currently raised, the results are not well defined when these operations are performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;).</source>
          <target state="translated">現在警告は出されていませんが、数値（&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;整数演算を&lt;/a&gt;参照）または&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;ビット文字列&lt;/a&gt;（ビットごとの文字列演算子を参照）ではないオペランドに対してこれらの演算を実行すると、結果は明確に定義されません。</target>
        </trans-unit>
        <trans-unit id="c94501363b8d49d883be5ef00569dcb0d5283b0f" translate="yes" xml:space="preserve">
          <source>Although not for the faint of heart, Perl does support a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; statement. There are three forms: &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-LABEL, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-EXPR, and &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-&amp;amp;NAME. A loop's LABEL is not actually a valid target for a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;; it's just the name of the loop.</source>
          <target state="translated">気弱な人には向いていませんが、Perlは &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; ステートメントをサポートしています。 ：三つの形式があり &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -label、 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -EXPR、そして &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; - ＆NAMEは。ループのLABELは実際には &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; の有効なターゲットではありません。それは単にループの名前です。</target>
        </trans-unit>
        <trans-unit id="c556c081516373f750515951f1b9a5217dc9bdfc" translate="yes" xml:space="preserve">
          <source>Although one can already do quite a lot with the literal string regexps above, we've only scratched the surface of regular expression technology. In this and subsequent sections we will introduce regexp concepts (and associated metacharacter notations) that will allow a regexp to represent not just a single character sequence, but a</source>
          <target state="translated">上述のリテラル文字列正規表現ではすでに多くのことができますが、正規表現技術の表面にはまだ触れていません。このセクションとそれ以降のセクションでは、正規表現の概念(とそれに関連するメタ文字表記)を紹介します。</target>
        </trans-unit>
        <trans-unit id="18a0eac57e1c4484372ccab28955e18fb02ea640" translate="yes" xml:space="preserve">
          <source>Although one would expect the quantities $y and $z to be the same and equal to 100000 they will differ and instead will be 0 and 100000 respectively.</source>
          <target state="translated">人は $y と $z が同じで 100000 に等しい量であることを期待しますが、それらは異なり、その代わりにそれぞれ 0 と 100000 になります。</target>
        </trans-unit>
        <trans-unit id="5829c5fcc8ce3b64df01881896b3b15fd774741a" translate="yes" xml:space="preserve">
          <source>Although only a single value was expected to be returned from</source>
          <target state="translated">からは単一の値しか返ってこないと予想されていましたが</target>
        </trans-unit>
        <trans-unit id="2a2b97db7310124d07426632d32011d83ef42107" translate="yes" xml:space="preserve">
          <source>Although primarily designed for use with multi-threaded Perl, the macros have been designed so that they will work with non-threaded Perl as well.</source>
          <target state="translated">主にマルチスレッドPerlで使用するために設計されていますが、マクロは非スレッドPerlでも動作するように設計されています。</target>
        </trans-unit>
        <trans-unit id="797e69b4382557ebf9cc947a771d199448156185" translate="yes" xml:space="preserve">
          <source>Although similar, file path specifications differ between Unix, Windows, Mac OS, OS/2, VMS, VOS, RISC OS, and probably others. Unix, for example, is one of the few OSes that has the elegant idea of a single root directory.</source>
          <target state="translated">似ていますが、ファイルパスの仕様は、Unix、Windows、Mac OS、OS/2、VMS、VOS、RISC OS、そしておそらく他のOSの間で異なります。例えば、Unix は、単一のルートディレクトリというエレガントなアイデアを持つ数少ない OS の一つです。</target>
        </trans-unit>
        <trans-unit id="d6190ff15955860c6c9fdd297f5be90390874780" translate="yes" xml:space="preserve">
          <source>Although test failures should be enough, extra diagnostics can be triggered at the end of a test run. &lt;code&gt;onfail&lt;/code&gt; is passed an array ref of hash refs that describe each test failure. Each hash will contain at least the following fields: &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;repetition&lt;/code&gt; , and &lt;code&gt;result&lt;/code&gt; . (You shouldn't rely on any other fields being present.) If the test had an expected value or a diagnostic (or &quot;note&quot;) string, these will also be included.</source>
          <target state="translated">テストの失敗で十分なはずですが、テスト実行の最後に追加の診断がトリガーされる可能性があります。 &lt;code&gt;onfail&lt;/code&gt; には、各テストの失敗を説明するハッシュ参照の配列参照が渡されます。各ハッシュには、少なくとも次のフィールドが含まれます： &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;repetition&lt;/code&gt; 、 &lt;code&gt;result&lt;/code&gt; 。（存在する他のフィールドに依存することはできません。）テストに期待値または診断（または「メモ」）文字列があった場合、これらも含まれます。</target>
        </trans-unit>
        <trans-unit id="224e863badf25248ea988718d8bd34cef72cce5a" translate="yes" xml:space="preserve">
          <source>Although that form may run into trouble in network transit (due to the presence of 8 bit characters) or on non ISO-Latin character sets. But it does allow &lt;code&gt;Is_c1&lt;/code&gt; to be rewritten so it works on Perls that don't have &lt;code&gt;'unicode_strings'&lt;/code&gt; (earlier than v5.14):</source>
          <target state="translated">ただし、この形式では、ネットワーク転送（8ビット文字が存在するため）またはISO-Latin以外の文字セットで問題が発生する場合があります。しかし、 &lt;code&gt;Is_c1&lt;/code&gt; を書き換えることができるので、 &lt;code&gt;'unicode_strings'&lt;/code&gt; がない（v5.14より前の）Perlで動作します。</target>
        </trans-unit>
        <trans-unit id="99123ea723cf2a29473e47c091f28928ebbdafd8" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;%&lt;/code&gt; code is documented as returning a &quot;checksum&quot;: don't put your trust in such values! Even when applied to a small number of bytes, they won't guarantee a noticeable Hamming distance.</source>
          <target state="translated">けれども &lt;code&gt;%&lt;/code&gt; のコードは「チェックサム」を返すと文書化されています。このような値にあなたの信頼を置かないでください！少数のバイトに適用した場合でも、顕著なハミング距離は保証されません。</target>
        </trans-unit>
        <trans-unit id="6834c0c595f466c17dc9377b6377ec111fa7e11c" translate="yes" xml:space="preserve">
          <source>Although the above may seem a bit confusing at first, it generally does &quot;the right thing&quot; in most situations. This determination of the default values to use is based upon the following typical Unix conventions:</source>
          <target state="translated">最初は少し混乱するかもしれませんが、一般的にはほとんどの状況で「正しいこと」をしています。使用するデフォルト値の決定は、以下の典型的な Unix の規約に基づいています。</target>
        </trans-unit>
        <trans-unit id="a0b752b8fd0002195999a4940b4a67ff51de0cf2" translate="yes" xml:space="preserve">
          <source>Although the error message above refers to the second tie() statement in the script, the source of the problem is really with the untie() statement that precedes it.</source>
          <target state="translated">上のエラーメッセージはスクリプト内の 2 番目の tie()文を指していますが、問題の原因はその前の untie()文にあります。</target>
        </trans-unit>
        <trans-unit id="050771d84c3ebf7bfb6e4438000d2961a2adc2a7" translate="yes" xml:space="preserve">
          <source>Although the functionality provided by this flag may seem straightforward, it should be used only if there is a good reason to do so. The reason for being cautious is that, even if you have specified the G_NOARGS flag, it is still possible for the Perl subroutine that has been called to think that you have passed it parameters.</source>
          <target state="translated">このフラグによって提供される機能は簡単なように見えるかもしれませんが、それを行う正当な理由がある場合にのみ使用すべきです。慎重になる理由は、G_NOARGSフラグを指定していても、呼び出されたPerlのサブルーチンにパラメータを渡したと勘違いされる可能性があるからです。</target>
        </trans-unit>
        <trans-unit id="0019a6a5066bef3137d87deda446668085e7063b" translate="yes" xml:space="preserve">
          <source>Although the ignored argument doesn't go into a variable, it is still mandatory for the caller to pass it.</source>
          <target state="translated">無視された引数が変数に入ることはありませんが、それでも呼び出し元に渡すことは必須です。</target>
        </trans-unit>
        <trans-unit id="35ed9f698c7272524026c7a45834a834a74d7bb0" translate="yes" xml:space="preserve">
          <source>Although the main discussion of Perl security issues can be found in &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;, a discussion of Perl's locale handling would be incomplete if it did not draw your attention to locale-dependent security issues. Locales--particularly on systems that allow unprivileged users to build their own locales--are untrustworthy. A malicious (or just plain broken) locale can make a locale-aware application give unexpected results. Here are a few possibilities:</source>
          <target state="translated">Perlのセキュリティ問題に関する主な議論は&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;にありますが、Perlのロケール処理に関する議論は、ロケールに依存するセキュリティ問題に注意を向けなければ不完全です。ロケール、特に特権のないユーザーが自分のロケールを作成できるシステムでは、信頼できません。悪意のある（または単純に壊れた）ロケールは、ロケール対応アプリケーションに予期しない結果をもたらす可能性があります。いくつかの可能性があります：</target>
        </trans-unit>
        <trans-unit id="6ad8f5d884e3bfe99068d75f61c2b91c556f88ba" translate="yes" xml:space="preserve">
          <source>Although the most deeply nested array or hash element will not spring into existence just because its existence was tested, any intervening ones will. Thus &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; and &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; will spring into existence due to the existence test for the $key element above. This happens anywhere the arrow operator is used, including even here:</source>
          <target state="translated">最も深くネストされた配列またはハッシュ要素は、その存在がテストされたという理由だけでは存在しませんが、介在するものは存在します。したがって、上記の$ key要素の存在テストにより、 &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; と$ ref-&amp;gt; {&quot;A&quot;}-&amp;gt; {&quot;B&quot;}が存在するようになります。これは、以下を含め、矢印演算子が使用されるすべての場所で発生します。</target>
        </trans-unit>
        <trans-unit id="ece6731e40fd98f25883ef891976cdd74d8b5353" translate="yes" xml:space="preserve">
          <source>Although the optree is read-only, there is an overlay facility that allows you to override what values the various B::*OP methods return for a particular op. &lt;code&gt;$B::overlay&lt;/code&gt; should be set to reference a two-deep hash: indexed by OP address, then method name. Whenever a an op method is called, the value in the hash is returned if it exists. This facility is used by B::Deparse to &quot;undo&quot; some optimisations. For example:</source>
          <target state="translated">optreeは読み取り専用ですが、特定のopに対してさまざまなB :: * OPメソッドが返す値をオーバーライドできるオーバーレイ機能があります。 &lt;code&gt;$B::overlay&lt;/code&gt; は、2つのディープハッシュを参照するように設定する必要があります。OPアドレス、次にメソッド名でインデックスが作成されます。opメソッドが呼び出されると、ハッシュの値が存在する場合は、その値が返されます。この機能は、いくつかの最適化を「取り消す」ためにB :: Deparseによって使用されます。例えば：</target>
        </trans-unit>
        <trans-unit id="4006666c099c71fba2fd95778e8d769cab92e521" translate="yes" xml:space="preserve">
          <source>Although the primary purpose for the existence of &lt;code&gt;Compress::Raw::Bzip2&lt;/code&gt; is for use by the &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; and &lt;code&gt;IO::Compress::Bunzip2&lt;/code&gt; modules, it can be used on its own for simple compression/uncompression tasks.</source>
          <target state="translated">&lt;code&gt;Compress::Raw::Bzip2&lt;/code&gt; の存在の主な目的は &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; および &lt;code&gt;IO::Compress::Bunzip2&lt;/code&gt; モジュールで使用することですが、単純な圧縮/解凍タスク用に単独で使用できます。</target>
        </trans-unit>
        <trans-unit id="73cce3599d213093393a3d6545498d75ae280481" translate="yes" xml:space="preserve">
          <source>Although the techniques described here are applicable when embedding Perl in a C program, this is not the primary goal of this document. There are other details that must be considered and are specific to embedding Perl. For details on embedding Perl in C refer to &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">ここで説明する手法は、PerlをCプログラムに埋め込むときに適用できますが、これはこのドキュメントの主な目的ではありません。考慮する必要があり、Perlの埋め込みに固有のその他の詳細があります。PerlのCへの埋め込みの詳細については、&lt;a href=&quot;perlembed&quot;&gt;perlembedを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="14e1e99a665303302472280aa271e6e7551860a9" translate="yes" xml:space="preserve">
          <source>Although there can be any number of source streams in existence at any given time, only one will be active.</source>
          <target state="translated">任意の時間にいくつものソースストリームが存在することができますが、アクティブになるのは1つだけです。</target>
        </trans-unit>
        <trans-unit id="c84534656a685169f0194cbbe1e16531f562b033" translate="yes" xml:space="preserve">
          <source>Although these are grouped by family, they all have the precedence of assignment. These combined assignment operators can only operate on scalars, whereas the ordinary assignment operator can assign to arrays, hashes, lists and even references. (See &lt;a href=&quot;perldata#Context&quot;&gt;Context&lt;/a&gt; and &lt;a href=&quot;perldata#List-value-constructors&quot;&gt;List value constructors in perldata&lt;/a&gt;, and &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Assigning to References in perlref&lt;/a&gt;.)</source>
          <target state="translated">これらは家族ごとにグループ化されていますが、すべて割り当ての優先順位があります。これらの結合された代入演算子はスカラーでのみ動作できますが、通常の代入演算子は配列、ハッシュ、リスト、さらには参照に代入できます。（&lt;a href=&quot;perldata#List-value-constructors&quot;&gt;perldataの&lt;/a&gt;&lt;a href=&quot;perldata#Context&quot;&gt;コンテキスト&lt;/a&gt;およびリスト値コンストラクター、および&lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;perlrefの参照への割り当てを参照してください&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="459be48ccfdeb87ea73fbd1fbec51d1410292106" translate="yes" xml:space="preserve">
          <source>Although this function returns its values on the perl argument stack, it doesn't take any parameters from that stack (and thus in particular there's no need to do a PUSHMARK before calling it, unlike &lt;a href=&quot;#call_pv&quot;&gt;call_pv&lt;/a&gt; for example).</source>
          <target state="translated">この関数は、perl引数スタックで値を返しますが、そのスタックからパラメーターを受け取りません（したがって、たとえば、&lt;a href=&quot;#call_pv&quot;&gt;call_pvの&lt;/a&gt;ように、呼び出す前にPUSHMARKを実行する必要はありません）。</target>
        </trans-unit>
        <trans-unit id="9ecb9099e922e4493577adbe3649de5e0005a135" translate="yes" xml:space="preserve">
          <source>Although this keyword is optional and in some cases provides redundant information it should always be used. This keyword will ensure that the XSUBs appear in the desired package.</source>
          <target state="translated">このキーワードはオプションであり、場合によっては冗長な情報を提供しますが、常に使用すべきです。このキーワードは、XSUB が目的のパッケージに確実に表示されるようにします。</target>
        </trans-unit>
        <trans-unit id="66fb31ad783a8264f17dab51f3aa1ad011017a08" translate="yes" xml:space="preserve">
          <source>Although this option can be used with the OO interface, it is of most use with the one-shot interface. For example, the code below shows how &lt;code&gt;FilterName&lt;/code&gt; can be used to remove the path component from a series of filenames before they are stored in &lt;code&gt;$zipfile&lt;/code&gt; .</source>
          <target state="translated">このオプションはOOインターフェースで使用できますが、ほとんどの場合、ワンショットインターフェースで使用します。たとえば、次のコードは、 &lt;code&gt;FilterName&lt;/code&gt; を使用して、一連のファイル名からパスコンポーネントを削除してから、 &lt;code&gt;$zipfile&lt;/code&gt; 保存する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="2398658140451226b4cd3f1886215ebf8c65091f" translate="yes" xml:space="preserve">
          <source>Although this stuff is easier to explain using examples, you first need be aware of a few important definitions.</source>
          <target state="translated">このようなものは例を使って説明する方が簡単ですが、まずはいくつかの重要な定義を知っておく必要があります。</target>
        </trans-unit>
        <trans-unit id="5d6b9d5e42d7a86677e3f471c1e47e328daf1dc8" translate="yes" xml:space="preserve">
          <source>Although very useful, the big problem with using &lt;b&gt;-w&lt;/b&gt; on the command line to enable warnings is that it is all or nothing. Take the typical scenario when you are writing a Perl program. Parts of the code you will write yourself, but it's very likely that you will make use of pre-written Perl modules. If you use the &lt;b&gt;-w&lt;/b&gt; flag in this case, you end up enabling warnings in pieces of code that you haven't written.</source>
          <target state="translated">非常に便利ですが、警告を有効にするためにコマンドラインで&lt;b&gt;-w&lt;/b&gt;を使用することの大きな問題は、それがすべてかゼロかということです。Perlプログラムを作成する場合は、一般的なシナリオを考えてください。自分で作成するコードの一部ですが、事前に作成されたPerlモジュールを利用する可能性が非常に高くなります。この場合に&lt;b&gt;-w&lt;/b&gt;フラグを使用すると、作成していないコードで警告が有効になってしまいます。</target>
        </trans-unit>
        <trans-unit id="560edbbb945d8ba093edcea345708feb744a0493" translate="yes" xml:space="preserve">
          <source>Although we do suggest that you always build your own Perl from the source code, both for maximal configurability and for security, in case you are in a hurry you can check &lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html&lt;/a&gt; for binary distributions.</source>
          <target state="translated">私たちは、いつでもソースコードから独自のPerlを構築することを示唆しているんが、最大限のコンフィギュラ用とセキュリティの両方、場合にあなたがチェックすることができます急いでいる&lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.htmlを&lt;/a&gt;するためにバイナリ分布。</target>
        </trans-unit>
        <trans-unit id="46ce08a44dd2ba4f6ce9e91fa3d420e93dff144d" translate="yes" xml:space="preserve">
          <source>Although write can work with lexical or package variables, whatever variables you use have to scope in the format. That most likely means you'll want to localize some package variables:</source>
          <target state="translated">write は辞書変数やパッケージ変数を扱うことができますが、 使用する変数はすべてスコープ形式でなければなりません。つまり、いくつかのパッケージ変数をローカライズしたいということになります。</target>
        </trans-unit>
        <trans-unit id="e1e9346790d51b0db2514b5ac70a5da4526349c7" translate="yes" xml:space="preserve">
          <source>Although, for historical reasons, the &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; distribution takes its name from this module it now exists only to provide &lt;a href=&quot;../tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; with an interface that is somewhat backwards compatible with &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; 2.xx. If you're writing new code consider using &lt;a href=&quot;../tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; directly instead.</source>
          <target state="translated">歴史的な理由により、&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt;ディストリビューションの名前はこのモジュールから取られていますが、現在は、&lt;a href=&quot;../tap/harness&quot;&gt;TAP :: Harnessに&lt;/a&gt;&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; 2.xx と多少後方互換性のあるインターフェースを提供するためだけに存在しています。新しいコードを作成する場合は、代わりに&lt;a href=&quot;../tap/harness&quot;&gt;TAP :: Harnessを&lt;/a&gt;直接使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="f966b3ea336af8830bc18236a5389bd937c78b7c" translate="yes" xml:space="preserve">
          <source>Always be civil.</source>
          <target state="translated">常に礼儀正しく。</target>
        </trans-unit>
        <trans-unit id="c369c01b27ace1a743bc3e37d378c5dbbf093f50" translate="yes" xml:space="preserve">
          <source>Always check the return codes of system calls. Good error messages should go to &lt;code&gt;STDERR&lt;/code&gt; , include which program caused the problem, what the failed system call and arguments were, and (VERY IMPORTANT) should contain the standard system error message for what went wrong. Here's a simple but sufficient example:</source>
          <target state="translated">常にシステムコールのリターンコードを確認してください。適切なエラーメッセージは &lt;code&gt;STDERR&lt;/code&gt; に送信され、問題の原因となったプログラム、失敗したシステムコールと引数が含まれます。また、（非常に重要）エラーの標準的なシステムエラーメッセージが含まれます。簡単ですが十分な例を次に示します。</target>
        </trans-unit>
        <trans-unit id="5844f1a31b652c47f84d0aaae5c714b741011321" translate="yes" xml:space="preserve">
          <source>Always commit changes to config variables to disk?</source>
          <target state="translated">設定変数の変更を常にディスクにコミットするか?</target>
        </trans-unit>
        <trans-unit id="cd2fdc72c972de55363038192e944aae07f2f5ef" translate="yes" xml:space="preserve">
          <source>Always decompose on the way in, then recompose on the way out.</source>
          <target state="translated">入るときは必ず分解して、出るときは再分解する。</target>
        </trans-unit>
        <trans-unit id="8c61fff2e0b1e2b49630e69bc2a2e99ec24ecff3" translate="yes" xml:space="preserve">
          <source>Always explicitly and immediately call close() on the writable end of any pipe, unless that process is actually writing to it. Even if you don't explicitly call close(), Perl will still close() all filehandles during global destruction. As previously discussed, if those filehandles have been opened with Safe Pipe Open, this will result in calling waitpid(), which may again deadlock.</source>
          <target state="translated">どのようなパイプでも、そのプロセスが実際に書き込みを行っている場合を除いて、書き込み可能な端では常に明示的かつ即座に close()をコールするようにしてください。明示的に close()を呼び出さなくても、Perl はグローバル破壊の際にすべてのファイルハンドルを close()します。前に説明したように、それらのファイルハンドルが Safe Pipe Open でオープンされている場合、これは waitpid()を呼び出す結果となり、再びデッドロックする可能性があります。</target>
        </trans-unit>
        <trans-unit id="242eddbfa115df236054209d0570301b5af3c68e" translate="yes" xml:space="preserve">
          <source>Always place the START_MY_CXT macro directly after the declaration of &lt;code&gt;my_cxt_t&lt;/code&gt; .</source>
          <target state="translated">START_MY_CXTマクロは、常に &lt;code&gt;my_cxt_t&lt;/code&gt; の宣言の直後に配置してください。</target>
        </trans-unit>
        <trans-unit id="33f26e154493acc9e3d45671d863271e7464d39e" translate="yes" xml:space="preserve">
          <source>Always strive to remain compatible with previous released versions. Otherwise try to add a mechanism to revert to the old behavior if people rely on it. Document incompatible changes.</source>
          <target state="translated">常に以前にリリースされたバージョンとの互換性を保つように努力してください。そうでなければ、人々がそれに依存している場合には、古い動作に戻すメカニズムを追加するようにしてください。互換性のない変更を文書化する。</target>
        </trans-unit>
        <trans-unit id="1c41f11cd18971bbdb3e2ef9969d459e5296677c" translate="yes" xml:space="preserve">
          <source>Always try to check and verify signatures if a SIGNATURE file is in the package and Module::Signature is installed (yes/no)?</source>
          <target state="translated">パッケージ内に SIGNATURE ファイルがあり、Module::Signature がインストールされている場合は、常に署名の確認と検証を試みます (yes/no)?</target>
        </trans-unit>
        <trans-unit id="24f1e77216b2edc00da08bfb70769a17a94800b4" translate="yes" xml:space="preserve">
          <source>Always try to show upload date with 'd' and 'm' command (yes/no)?</source>
          <target state="translated">常に'd'と'm'コマンドでアップロードの日付を表示しようとすると(はい/いいえ)?</target>
        </trans-unit>
        <trans-unit id="ab3692e008452cea5b34a3fe52ad03c81207161c" translate="yes" xml:space="preserve">
          <source>Always use &lt;b&gt;-w&lt;/b&gt;.</source>
          <target state="translated">常に&lt;b&gt;-wを&lt;/b&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="8367b54257a55d960e03d572f3ffce6e4f988276" translate="yes" xml:space="preserve">
          <source>Always use with a subtag. Notable forms: {sgn-gb} British Sign Language (BSL); {sgn-ie} Irish Sign Language (ESL); {sgn-ni} Nicaraguan Sign Language (ISN); {sgn-us} American Sign Language (ASL).</source>
          <target state="translated">必ずサブタグと一緒に使用してください。注目すべき形式。{sgn-gb}。ブリティッシュ手話(BSL);{sgn-ie}。アイルランド手話(ESL);{sgn-ni}。ニカラグア手話(ISN);{sgn-us}。アメリカ手話(ASL)。</target>
        </trans-unit>
        <trans-unit id="d7fc26ae93e0cf00af5e88a1fe69971068f3bf0a" translate="yes" xml:space="preserve">
          <source>Ambiguous Local Times (DST)</source>
          <target state="translated">曖昧な現地時間(DST)</target>
        </trans-unit>
        <trans-unit id="b61e588022eb4910c7d278a411480210f9347590" translate="yes" xml:space="preserve">
          <source>Ambulation.pm</source>
          <target state="translated">Ambulation.pm</target>
        </trans-unit>
        <trans-unit id="7dec8f79f324daec9e2bc3cec19154d9b44d20cf" translate="yes" xml:space="preserve">
          <source>Amiga Developers Environment</source>
          <target state="translated">Amiga 開発者環境</target>
        </trans-unit>
        <trans-unit id="7eb77f842d900a2dedf7fde5ab4f77cd221a01f3" translate="yes" xml:space="preserve">
          <source>Amiga,</source>
          <target state="translated">Amiga,</target>
        </trans-unit>
        <trans-unit id="3c76575f93cf9b6439e5c8c228d14871841f2be6" translate="yes" xml:space="preserve">
          <source>Among IBM EBCDIC character code sets there are 13 characters that are often mapped to different integer values. Those characters are known as the 13 &quot;variant&quot; characters and are:</source>
          <target state="translated">IBM EBCDIC 文字コードセットの中には、異なる整数値にマップされることが多い 13 の文字があります。これらの文字は、13 の「バリアント」文字として知られており、以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="dc547e0c079def6202bb164de4204e6fef69df9c" translate="yes" xml:space="preserve">
          <source>Amongst the changes made for OS/2 are...</source>
          <target state="translated">OS/2のために行われた変更点の中には、以下のものがあります。</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="a57b3b45aeac822e093194b4bfd981f0e59fb655" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing no &quot;=item&quot; paragraphs at all, and containing only some number of ordinary/verbatim paragraphs, and possibly also some nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions. Such an itemless &quot;=over&quot; ... &quot;=back&quot; region in Pod is equivalent in meaning to a &quot;&amp;lt;blockquote&amp;gt;...&amp;lt;/blockquote&amp;gt;&quot; element in HTML.</source>
          <target state="translated">&quot;= over&quot; ... &quot;= back&quot;領域。 &quot;= item&quot;段落はまったく含まれず、通常の/逐語的段落がいくつかだけ含まれ、ネストされた &quot;= over&quot; ... &quot;= back&quot;も含まれる可能性がありますリージョン、「= for ...」段落、および「= begin」...「= end」リージョン。ポッドのこのようなアイテムのない「= over」...「= back」領域は、HTMLの「&amp;lt;blockquote&amp;gt; ... &amp;lt;/ blockquote&amp;gt;」要素と同じ意味です。</target>
        </trans-unit>
        <trans-unit id="a1fa998f4d85fe0a03c929b0df6c0b9a9c55bdd0" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &quot;=item *&quot; commands, each followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions.</source>
          <target state="translated">オーバー&quot; ...&quot;back &quot;領域は、&quot;=item *&quot;コマンドのみを含み、それぞれにいくつかの通常/逐語的な段落が続き、他の入れ子になった&quot;=over&quot; ...&quot;back &quot;領域、&quot;=for...&quot;パラグラフ、および&quot;=begin&quot;...&quot;=end &quot;領域。</target>
        </trans-unit>
        <trans-unit id="f7c11a0a43a54d0c5011769a3613a3b8e32e4b7f" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &quot;=item [text]&quot; commands, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, or &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions.</source>
          <target state="translated">オーバー&quot; ...&quot;back &quot;領域は、&quot;=item [text]&quot;コマンドのみを含み、それぞれのコマンド(またはそれらのグループ)の後には、いくつかの通常の/逐語的な段落が続き、他のネストした&quot;=over&quot; ...&quot;back &quot;領域、または&quot;=for...&quot;段落、そして&quot;=begin&quot;...&quot;=end &quot;領域。</target>
        </trans-unit>
        <trans-unit id="bf06369b3eb3e5c957377be368c2f7244136f0a8" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; paragraphs, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and/or &quot;=begin&quot;...&quot;=end&quot; codes. Note that the numbers must start at 1 in each section, and must proceed in order and without skipping numbers.</source>
          <target state="translated">&quot;= over&quot; ... &quot;= back&quot;領域には、 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; 段落のみが含まれ、各段落（またはそれらの各グループ）の後にいくつかの段落が続きます通常の/逐語的な段落、その他のネストされた「= over」...「= back」領域、「= for ...」段落、および/または「= begin」...「= end」コード。番号は各セクションで1から始まり、番号をスキップせずに順番に進む必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9c821406e2ce644bf837234397ad75d8f26b35cf" translate="yes" xml:space="preserve">
          <source>An &quot;independent&quot; subexpression, one which matches the substring that a</source>
          <target state="translated">独立した」部分式。</target>
        </trans-unit>
        <trans-unit id="3a02e2541679357b758fec91e5c00ccb84d49cd8" translate="yes" xml:space="preserve">
          <source>An &quot;internal&quot; derivative of &quot;perlio&quot; which can be used to provide Unread() function for layers which have no buffer or cannot be bothered. (Basically this layer's &lt;code&gt;Fill()&lt;/code&gt; pops itself off the stack and so resumes reading from layer below.)</source>
          <target state="translated">&quot;perlio&quot;の &quot;内部&quot;派生物であり、バッファーを持たないか、または気にすることができないレイヤーにUnread（）関数を提供するために使用できます。（基本的に、このレイヤーの &lt;code&gt;Fill()&lt;/code&gt; はそれ自体をスタックからポップするため、下のレイヤーから読み取りを再開します。）</target>
        </trans-unit>
        <trans-unit id="94f93318c67b8e306fa7a939182b6dc1a8d99788" translate="yes" xml:space="preserve">
          <source>An &quot;internal&quot; method, subject to change, currently called to allow an overriding class to cache information that will then be passed into all the &lt;code&gt;*param*&lt;/code&gt; calls. (Yes, having to read the source to make sense of this is considered a known bug).</source>
          <target state="translated">変更される可能性がある「内部」メソッド。現在、オーバーライドするクラスがすべての &lt;code&gt;*param*&lt;/code&gt; 呼び出しに渡される情報をキャッシュできるようにするために呼び出されます。（はい、これを理解するためにソースを読む必要があることは既知のバグと見なされます）。</target>
        </trans-unit>
        <trans-unit id="c723dc089a4e0462d0565d4c223eb6a79ebcd3aa" translate="yes" xml:space="preserve">
          <source>An $eol of &quot;&quot; (the empty string) is special. In this case, no &quot;soft line breaks&quot; are introduced and binary mode is effectively enabled so that any &quot;\n&quot; in the original data is encoded as well.</source>
          <target state="translated">eol の &quot; &quot; (空文字列)は特殊です。この場合、&quot;soft line breaks &quot;は導入されず、バイナリモードが効果的に有効になり、元のデータの&quot;\n &quot;も同様にエンコードされます。</target>
        </trans-unit>
        <trans-unit id="7efa71e97154f5e1c53935b4d4b0410d3433b623" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;XSUB&lt;/b&gt; forms the basic unit of the XS interface. After compilation by the &lt;b&gt;xsubpp&lt;/b&gt; compiler, each XSUB amounts to a C function definition which will provide the glue between Perl calling conventions and C calling conventions.</source>
          <target state="translated">アン&lt;b&gt;XSUBは&lt;/b&gt; XSインターフェースの基本的な単位を形成しています。&lt;b&gt;xsubpp&lt;/b&gt;コンパイラーによるコンパイル後、各XSUBは、Perl呼び出し規約とC呼び出し規約の間の接着剤を提供するC関数定義になります。</target>
        </trans-unit>
        <trans-unit id="09718e49ee8b20061f562ba9e5c34673e940b8ad" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;anonymous&lt;/b&gt; subroutine that, when a reference to it is generated at runtime, keeps track of the identities of externally visible &lt;b&gt;lexical variables&lt;/b&gt;, even after those lexical variables have supposedly gone out of &lt;b&gt;scope&lt;/b&gt;. They&amp;rsquo;re called &amp;ldquo;closures&amp;rdquo; because this sort of behavior gives mathematicians a sense of closure.</source>
          <target state="translated">実行時に参照が生成されるときに、外部から見える&lt;b&gt;レキシカル変数の&lt;/b&gt; IDを追跡する&lt;b&gt;匿名&lt;/b&gt;サブルーチン。これらのレキシカル変数が&lt;b&gt;スコープ外に&lt;/b&gt;なったと考えられる場合でも。このような行動は数学者に閉鎖感を与えるため、「閉鎖」と呼ばれます。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9e2f49be17e25fca915fffd9825b7a69527fa78a" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;argument&lt;/b&gt;-passing mechanism in which the &lt;b&gt;formal arguments&lt;/b&gt; refer directly to the &lt;b&gt;actual arguments&lt;/b&gt;, and the &lt;b&gt;subroutine&lt;/b&gt; can change the actual arguments by changing the formal arguments. That is, the formal argument is an &lt;b&gt;alias&lt;/b&gt; for the actual argument. See also &lt;b&gt;call by value&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;引数&lt;/b&gt; -passingメカニズムとは、&lt;b&gt;仮引数を&lt;/b&gt;直接参照する&lt;b&gt;実引数&lt;/b&gt;、および&lt;b&gt;サブルーチンは、&lt;/b&gt;仮引数を変更することで、実引数を変更することができます。つまり、仮引数は実引数の&lt;b&gt;エイリアス&lt;/b&gt;です。&lt;b&gt;値による呼び出し&lt;/b&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="4e9ca74e5eb3ceca0031d5a290a9926f188e9f44" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;argument&lt;/b&gt;-passing mechanism in which the &lt;b&gt;formal arguments&lt;/b&gt; refer to a copy of the &lt;b&gt;actual arguments&lt;/b&gt;, and the &lt;b&gt;subroutine&lt;/b&gt; cannot change the actual arguments by changing the formal arguments. See also &lt;b&gt;call by reference&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;引数&lt;/b&gt; -passingメカニズムとは、&lt;b&gt;仮引数は、&lt;/b&gt;のコピーを参照して&lt;b&gt;実引数&lt;/b&gt;、および&lt;b&gt;サブルーチンは、&lt;/b&gt;仮引数を変更することで、実引数を変更することはできません。参照&lt;b&gt;による呼び出し&lt;/b&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="3ae7537da81b89a37f1fba19db52f45ea5a64265" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that peeks at the string to the left of the current match location.</source>
          <target state="translated">&lt;b&gt;アサーション&lt;/b&gt;現在のマッチ位置の左にある文字列でのぞき見ています。</target>
        </trans-unit>
        <trans-unit id="9186a718ac3c2fd4c0066859c2036b1188f86bf7" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that peeks at the string to the right of the current match location.</source>
          <target state="translated">&lt;b&gt;アサーション&lt;/b&gt;現在のマッチ位置の右にある文字列でのぞき見ています。</target>
        </trans-unit>
        <trans-unit id="fccd6c0eca3ee2fd48a0479b2f7467ef677a981b" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that states something exists and perhaps describes what it&amp;rsquo;s like, without giving any commitment as to how or where you&amp;rsquo;ll use it. A declaration is like the part of your recipe that says, &amp;ldquo;two cups flour, one large egg, four or five tadpoles&amp;hellip;&amp;rdquo; See &lt;b&gt;statement&lt;/b&gt; for its opposite. Note that some declarations also function as statements. Subroutine declarations also act as definitions if a body is supplied.</source>
          <target state="translated">&lt;b&gt;アサーション&lt;/b&gt;何かを述べている方法や場所、あなたがそれを使用しますについてどのようなコミットメントを与えることなく、存在し、おそらくそれはどのようなものかを説明します。宣言は、レシピの「2カップの小麦粉、1つの大きな卵、4つまたは5つのオタマジャクシ&amp;hellip;」のようなものです。その反対の&lt;b&gt;説明&lt;/b&gt;を参照してください。一部の宣言はステートメントとしても機能することに注意してください。本体が提供されている場合、サブルーチン宣言も定義として機能します。</target>
        </trans-unit>
        <trans-unit id="a79df62ffe9655f3bb9b573a11129a38c97d9727" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;attribute&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;; data stored with the particular object rather than with the class as a whole.</source>
          <target state="translated">&lt;b&gt;属性&lt;/b&gt;の&lt;b&gt;オブジェクト&lt;/b&gt;。クラス全体ではなく、特定のオブジェクトで保存されたデータ。</target>
        </trans-unit>
        <trans-unit id="6b5c38c6212536b2650f8fd4b5e6e9c46fa7ac78" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;expression&lt;/b&gt; that evaluates to something that can be used as a &lt;b&gt;filehandle&lt;/b&gt;: a &lt;b&gt;string&lt;/b&gt; (filehandle name), a &lt;b&gt;typeglob&lt;/b&gt;, a typeglob &lt;b&gt;reference&lt;/b&gt;, or a low-level &lt;b&gt;IO&lt;/b&gt; object.</source>
          <target state="translated">&lt;b&gt;表現&lt;/b&gt;として使用することができるものと評価され、その&lt;b&gt;ファイルハンドル&lt;/b&gt;：&lt;b&gt;文字列&lt;/b&gt;（ファイルハンドル名）、&lt;b&gt;型グロブ&lt;/b&gt;、型グロブの&lt;b&gt;リファレンス&lt;/b&gt;、または低レベル&lt;b&gt;のIO&lt;/b&gt;オブジェクト。</target>
        </trans-unit>
        <trans-unit id="a9ea33da0846dba2dfc2c719e640a6b936943a76" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;expression&lt;/b&gt; that yields a &lt;b&gt;value&lt;/b&gt; that an &lt;b&gt;operator&lt;/b&gt; operates on. See also &lt;b&gt;precedence&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;表現&lt;/b&gt;生み出す&lt;b&gt;価値&lt;/b&gt;ことを&lt;b&gt;オペレータが&lt;/b&gt;上で動作します。&lt;b&gt;precedence&lt;/b&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="cc6a827ebadd37467385c749c36afe5cfe5a720e" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;increment&lt;/b&gt; operator that knows how to bump up ASCII alphabetics as well as numbers.</source>
          <target state="translated">&lt;b&gt;インクリメント&lt;/b&gt; ASCIIのアルファベットだけでなく、数字をつり上げる方法を知っているオペレータ。</target>
        </trans-unit>
        <trans-unit id="6e6a46de7223236ab22a0ae8657b922fe424257e" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;instance&lt;/b&gt; of a &lt;b&gt;class&lt;/b&gt;. Something that &amp;ldquo;knows&amp;rdquo; what user-defined type (class) it is, and what it can do because of what class it is. Your program can request an object to do things, but the object gets to decide whether it wants to do them or not. Some objects are more accommodating than others.</source>
          <target state="translated">&lt;b&gt;インスタンス&lt;/b&gt;の&lt;b&gt;クラス&lt;/b&gt;。ユーザー定義型（クラス）とは何か、それがクラスであるために何ができるかを「知っている」何か。プログラムはオブジェクトに処理を要求できますが、オブジェクトは処理を実行するかどうかを決定します。一部のオブジェクトは、他のオブジェクトよりも融通が利きます。</target>
        </trans-unit>
        <trans-unit id="193974eee4df69740e47a6c9868c573734e793d8" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;object&lt;/b&gt; is a data structure that bundles together data and subroutines which operate on that data. An object's data is called &lt;b&gt;attributes&lt;/b&gt;, and its subroutines are called &lt;b&gt;methods&lt;/b&gt;. An object can be thought of as a noun (a person, a web service, a computer).</source>
          <target state="translated">&lt;b&gt;オブジェクトは、&lt;/b&gt;一緒にそのデータを操作データとサブルーチンをバンドルデータ構造です。オブジェクトのデータは&lt;b&gt;属性&lt;/b&gt;と呼ばれ、そのサブルーチンは&lt;b&gt;メソッド&lt;/b&gt;と呼ばれ&lt;b&gt;ます&lt;/b&gt;。オブジェクトは名詞（人、Webサービス、コンピューター）と考えることができます。</target>
        </trans-unit>
        <trans-unit id="9f3264403f458576129fd753f7da0132d1126157" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; X&lt;code&gt;that looks something like a &lt;b&gt;literal&lt;/b&gt;,
such as the output-grabbing operator, &amp;lt;literal
moreinfo=&quot;none&quot;&lt;/code&gt;`&amp;gt;</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt; X &lt;code&gt;that looks something like a &lt;b&gt;literal&lt;/b&gt;, such as the output-grabbing operator, &amp;lt;literal moreinfo=&quot;none&quot;&lt;/code&gt; `&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e3876b6031a7c1f940174f56c5f7362a7f615429" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; taking three &lt;b&gt;operands&lt;/b&gt;. Sometimes pronounced &lt;b&gt;trinary&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt; 3つの服用&lt;b&gt;オペランドを&lt;/b&gt;。時には顕著&lt;b&gt;トライナリ&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="209f1fbbc9e85cade5ad6da705d3c26984c35559" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that comes in between its &lt;b&gt;operands&lt;/b&gt;, such as multiplication in &lt;code&gt;24 * 7&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt;の間に来る&lt;b&gt;オペランド&lt;/b&gt;などで乗算など、 &lt;code&gt;24 * 7&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="463ba99d535672eaf8355ca19021da8d2cf33452" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that does something with a list of values, such as &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;. Usually used for named built-in operators (such as &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;) that do not require parentheses around their &lt;b&gt;argument&lt;/b&gt; list.</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt;値のリストで何かをする、などの &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; の。通常、&lt;b&gt;引数&lt;/b&gt;リストの前後に括弧を必要としない名前付き組み込み演算子（ &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; など）に使用されます。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="de2a4670adc782be015d0bb2ea5ffee02ea42397" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that follows its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;$x++&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt;にその次の&lt;b&gt;オペランドを&lt;/b&gt;のように、 &lt;code&gt;$x++&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f7f1151c5c90e6fb1284f5e0bc779ad8ed2e33c" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that precedes its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;++$x&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt;の前にある&lt;b&gt;オペランドを&lt;/b&gt;のように、 &lt;code&gt;++$x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dabe188f0a1b9c27289c477dd8047df3b523cb5a" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that says whether a particular ordering relationship is &lt;b&gt;true&lt;/b&gt; about a pair of &lt;b&gt;operands&lt;/b&gt;. Perl has both numeric and string relational operators. See &lt;b&gt;collating sequence&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt;特定の順序関係があるかどうかと言う&lt;b&gt;真&lt;/b&gt;のペアに関する&lt;b&gt;オペランド&lt;/b&gt;。Perlには、数値と文字列の両方の関係演算子があります。&lt;b&gt;照合順序を&lt;/b&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="717a4af81f7132fc96e1d23c981f1ff3401e5290" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that surrounds its &lt;b&gt;operand&lt;/b&gt;, like the angle operator, or parentheses, or a hug.</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt;その包囲&lt;b&gt;オペランドを&lt;/b&gt;角度演算など、または括弧、または抱擁。</target>
        </trans-unit>
        <trans-unit id="355f7096b65520d72731600341dac924b0bb6aad" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that takes two &lt;b&gt;operands&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt; 2つの取る&lt;b&gt;オペランドを&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="b7885e2c7085b9ecc7bc4fd21946e64edd22e910" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; whose assigned mission in life is to change the value of a &lt;b&gt;variable&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt;その割り当てられた使命生活の中での値を変更することで&lt;b&gt;、変数を&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="7b3959ebca99af56cd591ab2c731b4edab6ffa5f" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;ordinary paragraph&lt;/b&gt;. A paragraph is an ordinary paragraph if its first line matches neither &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; nor &lt;code&gt;m/\A[ \t]/&lt;/code&gt; ,</source>
          <target state="translated">&lt;b&gt;普通の段落&lt;/b&gt;。最初の行が &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; も &lt;code&gt;m/\A[ \t]/&lt;/code&gt; にも一致しない場合、段落は通常の段落です。</target>
        </trans-unit>
        <trans-unit id="d98f8de412a14cfe117cc1f33fdf08a188a327cd" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without an argument uses the last file read. Using &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; with empty parentheses is different. It refers to the pseudo file formed from the files listed on the command line and accessed via the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. Since &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn't explicitly opened, as a normal filehandle is, an &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; before &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has been used will cause &lt;code&gt;@ARGV&lt;/code&gt; to be examined to determine if input is available. Similarly, an &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; after &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has returned end-of-file will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from &lt;code&gt;STDIN&lt;/code&gt; ; see &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 引数なしでは、最後のファイルの読み込みを使用しています。空の括弧で &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; を使用することは異なります。コマンドラインにリストされ、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 演算子を介してアクセスされるファイルから形成される疑似ファイルを指します。 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; は明示的に開かれていないため、通常のファイルハンドルと同様に、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; が使用される前に &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; を使用すると、 &lt;code&gt;@ARGV&lt;/code&gt; が検査され、入力が利用可能かどうかが判断されます。同様に、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; がファイルの終わりを返した後の &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; は、別の &lt;code&gt;@ARGV&lt;/code&gt; リストを処理していると想定し、 &lt;code&gt;@ARGV&lt;/code&gt; 設定していない場合は、 &lt;code&gt;STDIN&lt;/code&gt; から入力を読み取ります; &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;perlopのI / O演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b538c9784366b2a5b380fc1646cd6d2c36676cbb" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; executed within a subroutine defined in the &lt;code&gt;DB&lt;/code&gt; package doesn't see the usual surrounding lexical scope, but rather the scope of the first non-DB piece of code that called it. You don't normally need to worry about this unless you are writing a Perl debugger.</source>
          <target state="translated">&lt;code&gt;DB&lt;/code&gt; パッケージで定義されたサブルーチン内で実行された &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; は、通常の周囲の字句スコープを認識しませんが、それを呼び出した最初のDB以外のコードのスコープを認識します。Perlデバッガーを作成しているのでない限り、通常はこのことを心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="9638cc264773db141fdbff9966aa75b61a42b264" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without an argument uses the last file read. Using &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; with empty parentheses is different. It refers to the pseudo file formed from the files listed on the command line and accessed via the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. Since &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn't explicitly opened, as a normal filehandle is, an &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; before &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has been used will cause &lt;code&gt;@ARGV&lt;/code&gt; to be examined to determine if input is available. Similarly, an &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; after &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has returned end-of-file will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from &lt;code&gt;STDIN&lt;/code&gt; ; see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 引数なしでは、最後のファイルの読み込みを使用しています。空の括弧で &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; を使用することは異なります。コマンドラインにリストされ、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 演算子を介してアクセスされるファイルから形成される疑似ファイルを指します。 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; は明示的に開かれていないため、通常のファイルハンドルと同様に、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; が使用される前に &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; を使用すると、 &lt;code&gt;@ARGV&lt;/code&gt; が検査され、入力が利用可能かどうかが判断されます。同様に、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; がファイルの終わりを返した後の &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; は、別の &lt;code&gt;@ARGV&lt;/code&gt; リストを処理していると想定し、 &lt;code&gt;@ARGV&lt;/code&gt; 設定していない場合は、 &lt;code&gt;STDIN&lt;/code&gt; から入力を読み取ります; &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;perlopのI / O演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f39d8054296556b4b922794a4d5a34f617f1fc94" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;, however, can see lexical variables of the scope it is being evaluated in, so long as the names aren't hidden by declarations within the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; itself. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; は、しかし、そう長い名前が内の宣言によって隠されていないとして、それが中に評価されているスコープのレキシカル変数を見ることができる &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; そのもの。&lt;a href=&quot;perlref&quot;&gt;perlrefを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6342bae4fda60017077e5c45e326240a9752de8d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; executed within a subroutine defined in the &lt;code&gt;DB&lt;/code&gt; package doesn't see the usual surrounding lexical scope, but rather the scope of the first non-DB piece of code that called it. You don't normally need to worry about this unless you are writing a Perl debugger.</source>
          <target state="translated">&lt;code&gt;DB&lt;/code&gt; パッケージで定義されたサブルーチン内で実行された &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; は、通常の周囲の字句スコープを認識しませんが、それを呼び出した最初のDB以外のコードのスコープを認識します。Perlデバッガーを作成しているのでない限り、通常はこのことを心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="e98b3b90e3045dc3b637b5a6dd09b73503e89407" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares an alias for a package variable that will be visible across its entire lexical scope, even across package boundaries. The package in which the variable is entered is determined at the point of the declaration, not at the point of use. This means the following behavior holds:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 宣言はしても、パッケージ境界を越えて、その全体のレキシカルスコープ全体に表示されますパッケージ変数のエイリアスを宣言します。変数が入力されるパッケージは、使用の時点ではなく、宣言の時点で決定されます。つまり、次の動作が保持されます。</target>
        </trans-unit>
        <trans-unit id="b85b4821ea02e10c76868c61d73ce67c03c3c58f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration may also have a list of attributes associated with it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 宣言はまた、それに関連する属性のリストを有することができます。</target>
        </trans-unit>
        <trans-unit id="0e6a38b5837351a0fa7ad12169129c95c04803d4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares an alias for a package variable that will be visible across its entire lexical scope, even across package boundaries. The package in which the variable is entered is determined at the point of the declaration, not at the point of use. This means the following behavior holds:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 宣言はしても、パッケージ境界を越えて、その全体のレキシカルスコープ全体に表示されますパッケージ変数のエイリアスを宣言します。変数が入力されるパッケージは、使用の時点ではなく、宣言の時点で決定されます。つまり、次の動作が保持されます。</target>
        </trans-unit>
        <trans-unit id="ff67756e1b83b8c246879fd06b2405feac998276" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration may also have a list of attributes associated with it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 宣言はまた、それに関連する属性のリストを有することができます。</target>
        </trans-unit>
        <trans-unit id="09f284e34c7193100513bdbf0c748168a131c400" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;=item&lt;/code&gt; or &lt;code&gt;=back&lt;/code&gt; command has been found outside a &lt;code&gt;=over&lt;/code&gt; /&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;=item&lt;/code&gt; または &lt;code&gt;=back&lt;/code&gt; コマンドは、外部発見された &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; ブロック。</target>
        </trans-unit>
        <trans-unit id="66cb1e02933a96ffc4b888e742e11e5e2a0810c8" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;END&lt;/code&gt; code block is executed as late as possible, that is, after perl has finished running the program and just before the interpreter is being exited, even if it is exiting as a result of a die() function. (But not if it's morphing into another program via &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, or being blown out of the water by a signal--you have to trap that yourself (if you can).) You may have multiple &lt;code&gt;END&lt;/code&gt; blocks within a file--they will execute in reverse order of definition; that is: last in, first out (LIFO). &lt;code&gt;END&lt;/code&gt; blocks are not executed when you run perl with the &lt;code&gt;-c&lt;/code&gt; switch, or if compilation fails.</source>
          <target state="translated">&lt;code&gt;END&lt;/code&gt; のコードブロックは、それがダイ（）関数の結果として出た場合であっても、Perlはプログラムを実行して終了し、インタプリタが終了される直前後に、すなわち、できるだけ遅くとして実行されます。 （ただし、 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; を介して別のプログラムにモーフィングしている場合や、信号によって水から吹き飛ばされている場合は-自分でトラップする必要があります（可能であれば）。）ファイル内に複数の &lt;code&gt;END&lt;/code&gt; ブロックがある場合があります-それらは定義の逆の順序で実行します。つまり、後入れ先出し（LIFO）です。 &lt;code&gt;-c&lt;/code&gt; スイッチを指定してperlを実行した場合、またはコンパイルが失敗した場合、 &lt;code&gt;END&lt;/code&gt; ブロックは実行されません。</target>
        </trans-unit>
        <trans-unit id="2106dcfb583dc95f2d7d0a7530b5308a6cea8ccd" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IO::Handle&lt;/code&gt; object is a reference to a symbol/GLOB reference (see the &lt;code&gt;Symbol&lt;/code&gt; package). Some modules that inherit from &lt;code&gt;IO::Handle&lt;/code&gt; may want to keep object related variables in the hash table part of the GLOB. In an attempt to prevent modules trampling on each other I propose the that any such module should prefix its variables with its own name separated by _'s. For example the IO::Socket module keeps a &lt;code&gt;timeout&lt;/code&gt; variable in 'io_socket_timeout'.</source>
          <target state="translated">AN &lt;code&gt;IO::Handle&lt;/code&gt; オブジェクトは、シンボル/ GLOB参照への参照（参照ある &lt;code&gt;Symbol&lt;/code&gt; パッケージ）。 &lt;code&gt;IO::Handle&lt;/code&gt; から継承する一部のモジュールは、オブジェクトに関連する変数をGLOBのハッシュテーブル部分に保持したい場合があります。モジュールが互いに踏みつぶさないようにするために、そのようなモジュールは、変数の前に_で区切られた独自の名前を付けることをお勧めします。たとえば、IO :: Socketモジュールは &lt;code&gt;timeout&lt;/code&gt; 変数を「io_socket_timeout」に保持します。</target>
        </trans-unit>
        <trans-unit id="8d4bdf476b3365f09a887c13f6c40076ebfaf6c1" translate="yes" xml:space="preserve">
          <source>An Aside About Smarter and Safer Code</source>
          <target state="translated">よりスマートで安全なコードについての余談</target>
        </trans-unit>
        <trans-unit id="dcd29613666219a97f2491f0610be4945ceed298" translate="yes" xml:space="preserve">
          <source>An Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8c1ce33e34656d389a163577db68ecf2ef0ded0" translate="yes" xml:space="preserve">
          <source>An Example -- the NULL termination problem.</source>
          <target state="translated">例 --NULL終端問題。</target>
        </trans-unit>
        <trans-unit id="b0338e71cce0b4ccb879ecd4b7099e83ebe3be92" translate="yes" xml:space="preserve">
          <source>An Example: the NULL termination problem.</source>
          <target state="translated">例:NULL終了問題。</target>
        </trans-unit>
        <trans-unit id="8c00947f1047eee3af23c94728ed5ad710d9cb2f" translate="yes" xml:space="preserve">
          <source>An INSTALL file should be included, and should contain simple installation instructions. When using ExtUtils::MakeMaker this will usually be:</source>
          <target state="translated">INSTALL ファイルが含まれており、簡単なインストール手順が含まれている必要があります。ExtUtils::MakeMaker を使用する場合、通常はこれになります。</target>
        </trans-unit>
        <trans-unit id="c6d4eb0ecab7adc479ea3b6eef3a6aca32ccbec3" translate="yes" xml:space="preserve">
          <source>An OFFSET may be specified to place the read data at some place in the string other than the beginning. A negative OFFSET specifies placement at that many characters counting backwards from the end of the string. A positive OFFSET greater than the length of SCALAR results in the string being padded to the required size with &lt;code&gt;&quot;\0&quot;&lt;/code&gt; bytes before the result of the read is appended.</source>
          <target state="translated">オフセットを指定して、読み取ったデータを文字列の先頭以外の場所に配置できます。負のOFFSETは、文字列の末尾から逆方向に数えた文字数の配置を指定します。 SCALARの長さを超える正のOFFSET は、読み取りの結果が追加される前に、文字列が &lt;code&gt;&quot;\0&quot;&lt;/code&gt; バイトで必要なサイズになるように埋め込まれます。</target>
        </trans-unit>
        <trans-unit id="0dc3cbd84029f4f613840045b9422510efa87d84" translate="yes" xml:space="preserve">
          <source>An OFFSET may be specified to write the data from some part of the string other than the beginning. A negative OFFSET specifies writing that many characters counting backwards from the end of the string. If SCALAR is of length zero, you can only use an OFFSET of 0.</source>
          <target state="translated">OFFSETを指定すると、文字列の先頭以外の部分からデータを書き込むことができます。負のOFFSETを指定すると、文字列の末尾から逆算してその数だけの文字を書き込むことができます。SCALARが長さ0の場合、0のOFFSETしか使用できません。</target>
        </trans-unit>
        <trans-unit id="bd9383fdee820dfd7a79259db8339a2ec8fb85d9" translate="yes" xml:space="preserve">
          <source>An Object is Simply a Data Structure</source>
          <target state="translated">オブジェクトは単なるデータ構造</target>
        </trans-unit>
        <trans-unit id="e69ceb552111cae999e0e9d8f79c888a4e18b2ab" translate="yes" xml:space="preserve">
          <source>An SV (or AV, HV, etc.) is allocated in two parts: the head (struct sv, av, hv...) contains type and reference count information, and for many types, a pointer to the body (struct xrv, xpv, xpviv...), which contains fields specific to each type. Some types store all they need in the head, so don't have a body.</source>
          <target state="translated">SV (または AV、HV など)は 2 つの部分に分かれて割り当てられます。ヘッド (構造体 sv,av,hv...)には型と参照カウントの情報が格納され、多くの型ではボディ (構造体 xrv,xpv,xpviv...)へのポインタが格納されます。型の中には、必要な情報をすべてヘッドに格納しているものもあり、ボディを持たないものもあります。</target>
        </trans-unit>
        <trans-unit id="0db48295b7cb634bd39479ea9baf6751db33420c" translate="yes" xml:space="preserve">
          <source>An SV can be created and loaded with one command. There are five types of values that can be loaded: an integer value (IV), an unsigned integer value (UV), a double (NV), a string (PV), and another scalar (SV). (&quot;PV&quot; stands for &quot;Pointer Value&quot;. You might think that it is misnamed because it is described as pointing only to strings. However, it is possible to have it point to other things. For example, it could point to an array of UVs. But, using it for non-strings requires care, as the underlying assumption of much of the internals is that PVs are just for strings. Often, for example, a trailing &lt;code&gt;NUL&lt;/code&gt; is tacked on automatically. The non-string use is documented only in this paragraph.)</source>
          <target state="translated">SVは、1つのコマンドで作成およびロードできます。ロードできる値には、整数値（IV）、符号なし整数値（UV）、倍精度浮動小数点数（NV）、文字列（PV）、および別のスカラー（SV）の5つのタイプがあります。（ &quot;PV&quot;は &quot;ポインタ値&quot;を表します。文字列のみを指すと説明されているため、誤った名前になっていると思うかもしれません。ただし、他のものを指すようにすることもできます。たとえば、配列を指す場合があります。 UVの使用。ただし、PVは文字列専用であることが内部の多くの根本的な前提であるので、非文字列に使用する場合は注意が必要です。たとえば、多くの場合、末尾の &lt;code&gt;NUL&lt;/code&gt; が自動的に追加されます。非文字列の使用はこの段落でのみ文書化されています。）</target>
        </trans-unit>
        <trans-unit id="e49daf61f2f4bab338dc0435e2098c4740ae32f6" translate="yes" xml:space="preserve">
          <source>An SV may be passed as a second argument. If so, the name will be assigned to it and it will be returned. Otherwise the returned SV will be a new mortal.</source>
          <target state="translated">第二引数に SV を渡すことができます。その場合、名前が割り当てられて返されます。そうでなければ、返された SV は新しい人間になります。</target>
        </trans-unit>
        <trans-unit id="35a93457850bdbb33ca102c024544fcdc99dd999" translate="yes" xml:space="preserve">
          <source>An XSUB section continues until another section-start keyword is found.</source>
          <target state="translated">XSUBセクションは、別のセクション開始キーワードが見つかるまで継続します。</target>
        </trans-unit>
        <trans-unit id="db98408a971f988d838aae97c21a88cbfeff498b" translate="yes" xml:space="preserve">
          <source>An abstract character&amp;rsquo;s integer value. Same thing as &lt;b&gt;codepoint&lt;/b&gt;.</source>
          <target state="translated">抽象文字の整数値。&lt;b&gt;コードポイントと&lt;/b&gt;同じです。</target>
        </trans-unit>
        <trans-unit id="bd8526c4f7f2f82dc46961c40bfa270781cafa7e" translate="yes" xml:space="preserve">
          <source>An accessor function can be redefined in order to provide additional checking of values, etc. Here, we want the &lt;code&gt;count&lt;/code&gt; element always to be nonnegative, so we redefine the &lt;code&gt;count&lt;/code&gt; accessor accordingly.</source>
          <target state="translated">値の追加チェックなどを提供するために、アクセサー関数を再定義できます。ここでは、 &lt;code&gt;count&lt;/code&gt; 要素を常に非負にしたいので、それに応じて &lt;code&gt;count&lt;/code&gt; アクセサーを再定義します。</target>
        </trans-unit>
        <trans-unit id="76864d299088548272113a8d31dd2510d163d674" translate="yes" xml:space="preserve">
          <source>An accessor lets you add additional code around attribute access. For example, you could apply a default to an attribute that wasn't set in the constructor, or you could validate that a new value for the attribute is acceptable.</source>
          <target state="translated">アクセサを使用すると、属性へのアクセスに関するコードを追加することができます。例えば、コンストラクタで設定されていない属性にデフォルトを適用したり、属性の新しい値が許容されるかどうかを検証したりすることができます。</target>
        </trans-unit>
        <trans-unit id="7f7dfcb0e79b76d6607a032d4c42004b6d846b72" translate="yes" xml:space="preserve">
          <source>An action that terminates a process will terminate</source>
          <target state="translated">プロセスを終了させるアクションは、次のように終了します。</target>
        </trans-unit>
        <trans-unit id="3d55486b7ae618b0c9e5822b88065546dbd8b09b" translate="yes" xml:space="preserve">
          <source>An actual piece of data, in contrast to all the variables, references, keys, indices, operators, and whatnot that you need to access the value.</source>
          <target state="translated">変数、参照、キー、インデックス、演算子、および値にアクセスするために必要なすべてのものとは対照的に、実際のデータの一部。</target>
        </trans-unit>
        <trans-unit id="1e18a14c7435e1ad99b33d06cb67211ccd6f13ff" translate="yes" xml:space="preserve">
          <source>An adjectival pseudofunction that warps the meaning of an &lt;b&gt;lvalue&lt;/b&gt; in some declarative fashion. Currently there are three lvalue modifiers: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ある宣言的な方法で&lt;b&gt;左辺値&lt;/b&gt;の意味をゆがめる形容詞の疑似関数。現在、3つの左辺値修飾子があります： &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ddce428631d662b65df938a0ab59dc6d26df5c3" translate="yes" xml:space="preserve">
          <source>An alias can map to either an official Unicode character name (not a loose matched name) or to a numeric code point (ordinal). The latter is useful for assigning names to code points in Unicode private use areas such as U+E800 through U+F8FF. A numeric code point must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; , it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="translated">エイリアスは、正式なUnicode文字名（完全に一致しない名前ではない）または数値コードポイント（序数）のいずれかにマップできます。後者は、U + E800からU + F8FFなどのUnicodeプライベート使用領域のコードポイントに名前を割り当てる場合に便利です。数値コードポイントは、負でない整数、または &lt;code&gt;&quot;U+&quot;&lt;/code&gt; または &lt;code&gt;&quot;0x&quot;&lt;/code&gt; で始まり、残りが16進整数と見なされる文字列である必要があります。リテラル数値定数は符号なしでなければなりません。先頭に0が付いているか、10進数以外の16進数が含まれている場合は、16進数と解釈されます。それ以外の場合は、10進数として解釈されます。 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; で始まる場合は、Unicodeコードポイントとして解釈されます。それ以外の場合は、ネイティブとして解釈されます。 （256未満のコードポイントのみがUnicodeとネイティブの間で異なる可能性があります。）したがって &lt;code&gt;U+41&lt;/code&gt; は常にラテン文字「A」です。ただし、EBCDICプラットフォームでは &lt;code&gt;0x41&lt;/code&gt; を「NO-BREAK SPACE」にすることができます。</target>
        </trans-unit>
        <trans-unit id="2346eaad655197a010139149e8271c64c649a891" translate="yes" xml:space="preserve">
          <source>An alias for fullname</source>
          <target state="translated">フルネームの別名</target>
        </trans-unit>
        <trans-unit id="7fe1e0c1ce121b1e661962490b3a8d17f0df008e" translate="yes" xml:space="preserve">
          <source>An alias for hostfqdn ().</source>
          <target state="translated">hostfqdn ()のエイリアス。</target>
        </trans-unit>
        <trans-unit id="fa449dd40ff0246bd3a833083086ff6fe9ea989c" translate="yes" xml:space="preserve">
          <source>An alternate (and possibly simpler) method to pushing values on the stack is to use the macro:</source>
          <target state="translated">スタックに値をプッシュする別の (おそらくもっとシンプルな)方法としては、マクロを使用する方法があります。</target>
        </trans-unit>
        <trans-unit id="490e5f218f41d502acc0f80b9b4c03244664bdb6" translate="yes" xml:space="preserve">
          <source>An alternate delimiter may be specified using &lt;b&gt;-F&lt;/b&gt;.</source>
          <target state="translated">代替の区切り文字は、&lt;b&gt;-F&lt;/b&gt;を使用して指定できます。</target>
        </trans-unit>
        <trans-unit id="a3cee96423e82840fff05ec16e3bc4bd5558bd28" translate="yes" xml:space="preserve">
          <source>An alternate filename that points to the real &lt;b&gt;filename&lt;/b&gt;, which in turn points to the real &lt;b&gt;file&lt;/b&gt;. Whenever the &lt;b&gt;operating system&lt;/b&gt; is trying to parse a &lt;b&gt;pathname&lt;/b&gt; containing a symbolic link, it merely substitutes the new name and continues parsing.</source>
          <target state="translated">実際の&lt;b&gt;ファイル&lt;/b&gt;名を指す代替ファイル名は、実際の&lt;b&gt;ファイルを&lt;/b&gt;指し&lt;b&gt;ます&lt;/b&gt;。&lt;b&gt;オペレーティングシステム&lt;/b&gt;がシンボリックリンクを含む&lt;b&gt;パス名&lt;/b&gt;を解析しようとするときは常に、単に新しい名前に置き換えられ、解析が続行されます。</target>
        </trans-unit>
        <trans-unit id="567849086db2a3773d0ebaa265c330619cbbb371" translate="yes" xml:space="preserve">
          <source>An alternate interface to Filter::Util::Call is now available. See &lt;a href=&quot;../simple&quot;&gt;Filter::Simple&lt;/a&gt; for more details.</source>
          <target state="translated">Filter :: Util :: Callの代替インターフェースが利用可能になりました。詳細は&lt;a href=&quot;../simple&quot;&gt;Filter :: Simple&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="675501f93d17028172930c214a15945683c8e504" translate="yes" xml:space="preserve">
          <source>An alternative approach to cache flushing is to use the &lt;code&gt;HASH&lt;/code&gt; option (see above) to request that &lt;code&gt;Memoize&lt;/code&gt; use a particular hash variable as its cache. Then you can examine or modify the hash at any time in any way you desire. You may flush the cache by using &lt;code&gt;%hash = ()&lt;/code&gt; .</source>
          <target state="translated">キャッシュをフラッシュする別の方法は、 &lt;code&gt;HASH&lt;/code&gt; オプション（上記を参照）を使用して、 &lt;code&gt;Memoize&lt;/code&gt; が特定のハッシュ変数をキャッシュとして使用することを要求することです。その後、いつでも好きな方法でハッシュを検査または変更できます。 &lt;code&gt;%hash = ()&lt;/code&gt; を使用してキャッシュをフラッシュできます。</target>
        </trans-unit>
        <trans-unit id="b2fe156c5b22968eab0fbdde266b1268db8760ef" translate="yes" xml:space="preserve">
          <source>An alternative is CamelBones, a framework that allows access to both Foundation and AppKit classes and objects, so that full GUI applications can be built in Perl. CamelBones can be found on SourceForge, at &lt;a href=&quot;http://www.sourceforge.net/projects/camelbones/&quot;&gt;http://www.sourceforge.net/projects/camelbones/&lt;/a&gt;.</source>
          <target state="translated">代替は、CamelBonesです。これは、FoundationとAppKitの両方のクラスとオブジェクトへのアクセスを可能にするフレームワークであり、完全なGUIアプリケーションをPerlで構築できます。CamelBonesはSourceForgeの&lt;a href=&quot;http://www.sourceforge.net/projects/camelbones/&quot;&gt;http://www.sourceforge.net/projects/camelbones/にあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="adf70c06c68960fa2b5ce48b474675e096b9430d" translate="yes" xml:space="preserve">
          <source>An alternative method of debugging regexps is to embed &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; statements within the regexp. This provides a blow-by-blow account of the backtracking in an alternation:</source>
          <target state="translated">regexp をデバッグする別の方法は、regexp内に &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ステートメントを埋め込むことです。これにより、交互にバックトラックする方法が次々に説明されます。</target>
        </trans-unit>
        <trans-unit id="bf78a032596f44477dfca0392a1f37e462bfc42f" translate="yes" xml:space="preserve">
          <source>An alternative to using substr() as an lvalue is to specify the replacement string as the 4th argument. This allows you to replace parts of the EXPR and return what was there before in one operation, just as you can with splice().</source>
          <target state="translated">substr()を lvalue として使用する代わりに、第四引数に置換文字列を指定することができます。これにより、 splice()でできるように EXPR の一部を置換して、一度の操作で前にあったものを返すことができます。</target>
        </trans-unit>
        <trans-unit id="25b5286961be13762e984cfd1189ea7a9bb06d7a" translate="yes" xml:space="preserve">
          <source>An alternative to writing the filter in C is to create a separate executable in the language of your choice. The separate executable reads from standard input, does whatever processing is necessary, and writes the filtered data to standard output. &lt;code&gt;Filter::cpp&lt;/code&gt; is an example of a source filter implemented as a separate executable - the executable is the C preprocessor bundled with your C compiler.</source>
          <target state="translated">Cでフィルターを作成する代わりに、選択した言語で別の実行可能ファイルを作成することもできます。個別の実行可能ファイルは標準入力から読み取り、必要な処理をすべて行い、フィルタリングされたデータを標準出力に書き込みます。 &lt;code&gt;Filter::cpp&lt;/code&gt; は、個別の実行可能ファイルとして実装されたソースフィルターの例です。実行可能ファイルは、CコンパイラにバンドルされているCプリプロセッサです。</target>
        </trans-unit>
        <trans-unit id="9216315bb2214d5ed94f6db6fec42532477a8283" translate="yes" xml:space="preserve">
          <source>An alternative way of writing something more easily; a shortcut.</source>
          <target state="translated">より簡単に何かを書くための代替方法。</target>
        </trans-unit>
        <trans-unit id="f6ef70866e892e0391f54f3f0e595fde0691ccb0" translate="yes" xml:space="preserve">
          <source>An anchor useful in basic regexps is the</source>
          <target state="translated">基本的な正規表現で便利なアンカーは</target>
        </trans-unit>
        <trans-unit id="a941741e26d01bf48e71deca7cfe67d745df0d18" translate="yes" xml:space="preserve">
          <source>An anonymous array of alternative library specifications to be searched for (in order) until at least one library is found. E.g.</source>
          <target state="translated">少なくとも1つのライブラリが見つかるまで(順番に)検索される代替ライブラリ仕様の匿名配列。例えば</target>
        </trans-unit>
        <trans-unit id="c253698bf9e4f75c2b5d0a18558b851f2d3f6b5e" translate="yes" xml:space="preserve">
          <source>An application that takes the trouble to use information in &lt;code&gt;LC_MONETARY&lt;/code&gt; may format debits as if they were credits and vice versa if that locale has been subverted. Or it might make payments in US dollars instead of Hong Kong dollars.</source>
          <target state="translated">&lt;code&gt;LC_MONETARY&lt;/code&gt; の情報を使用する手間がかかるアプリケーションは、借方がクレジットであるかのように借方をフォーマットし、そのロケールが破壊されている場合はその逆の場合があります。または、香港ドルではなく米ドルで支払いを行う場合があります。</target>
        </trans-unit>
        <trans-unit id="01ac9da7b76fdd816e4e95bf07e705af326d0f2c" translate="yes" xml:space="preserve">
          <source>An application using Module can say something like:</source>
          <target state="translated">モジュールを使用したアプリケーションは、次のようなことを言うことができます。</target>
        </trans-unit>
        <trans-unit id="a335ab967a8e1f5c521e6fbf8a762d039a0699ab" translate="yes" xml:space="preserve">
          <source>An archaic expression for what is more correctly referred to as &lt;b&gt;list context&lt;/b&gt;.</source>
          <target state="translated">より正確に&lt;b&gt;リストコンテキスト&lt;/b&gt;と呼ばれるものの古風な表現。</target>
        </trans-unit>
        <trans-unit id="7dd0ff3c6abfb69f462a62c5017ae088c797d806" translate="yes" xml:space="preserve">
          <source>An argument can be ignored by omitting the main part of the name from a parameter declaration, leaving just a bare &lt;code&gt;$&lt;/code&gt; sigil. For example,</source>
          <target state="translated">パラメータ宣言から名前の主要部分を省略して、単なる &lt;code&gt;$&lt;/code&gt; シギルを残すことで、引数を無視できます。例えば、</target>
        </trans-unit>
        <trans-unit id="3f5cfd48537bc41203499ec678c7f8d1ffcc4184" translate="yes" xml:space="preserve">
          <source>An argument line supplying values to plug into the previous picture line.</source>
          <target state="translated">前の画像行に差し込むための値を与える引数行。</target>
        </trans-unit>
        <trans-unit id="e1318b0f2b2dd2f7e8a55cad33c819c262a23ea1" translate="yes" xml:space="preserve">
          <source>An array can also change its length:</source>
          <target state="translated">配列は、その長さを変更することもできます。</target>
        </trans-unit>
        <trans-unit id="a7633012ecb371a2113d013c22d2c030bb2a3192" translate="yes" xml:space="preserve">
          <source>An array can be accessed one scalar at a time by specifying a dollar sign (&lt;code&gt;$&lt;/code&gt; ), then the name of the array (without the leading &lt;code&gt;@&lt;/code&gt; ), then the subscript inside square brackets. For example:</source>
          <target state="translated">配列は、ドル記号（ &lt;code&gt;$&lt;/code&gt; ）、配列の名前（先頭の &lt;code&gt;@&lt;/code&gt; なし）、角かっこ内の添え字を指定することで、一度に1つのスカラーにアクセスできます。例えば：</target>
        </trans-unit>
        <trans-unit id="015711954685a7b3ea99a44f6e657f520fa53416" translate="yes" xml:space="preserve">
          <source>An array of an array is just a regular old array @AoA that you can get at with two subscripts, like &lt;code&gt;$AoA[3][2]&lt;/code&gt; . Here's a declaration of the array:</source>
          <target state="translated">配列の配列は、 &lt;code&gt;$AoA[3][2]&lt;/code&gt; ような2つの添え字で取得できる通常の古い配列@AoAです。配列の宣言は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9aee3421650400587ce5406d39d397928a2add0e" translate="yes" xml:space="preserve">
          <source>An array of constants' names, either scalars containing names, or hashrefs as detailed in &lt;a href=&quot;#C_constant&quot;&gt;C_constant&lt;/a&gt;.</source>
          <target state="translated">定数の名前の配列。名前を含むスカラー、またはC_constantで詳しく説明されている&lt;a href=&quot;#C_constant&quot;&gt;ハッシュ参照&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4dbdb6c0876baa594d12d6a72f40a78381bda16" translate="yes" xml:space="preserve">
          <source>An array of file names for the shared objects that were loaded.</source>
          <target state="translated">読み込まれた共有オブジェクトのファイル名の配列。</target>
        </trans-unit>
        <trans-unit id="26930aebfa1fee021fd440dae3cf343080566995" translate="yes" xml:space="preserve">
          <source>An array of module (package) names that have been bootstrap'ed.</source>
          <target state="translated">ブートストラップされたモジュール (パッケージ)名の配列。</target>
        </trans-unit>
        <trans-unit id="792d37106ab796a9da516b2cfe4619175268f4f1" translate="yes" xml:space="preserve">
          <source>An array of patches on CPAN or on the local disk to be applied in order via an external patch program. If the value for the &lt;code&gt;-p&lt;/code&gt; parameter is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; is determined by reading the patch beforehand. The path to each patch is either an absolute path on the local filesystem or relative to a patch directory specified in the &lt;code&gt;patches_dir&lt;/code&gt; configuration variable or in the format of a canonical distro name. For examples please consult the distroprefs/ directory in the CPAN.pm distribution (these examples are not installed by default).</source>
          <target state="translated">外部パッチプログラムを介して順番に適用されるCPANまたはローカルディスク上のパッチの配列。値場合 &lt;code&gt;-p&lt;/code&gt; パラメータが &lt;code&gt;0&lt;/code&gt; または &lt;code&gt;1&lt;/code&gt; が予めパッチを読み取ることによって決定されます。各パッチへのパスは、ローカルファイルシステム上の絶対パスか、 &lt;code&gt;patches_dir&lt;/code&gt; 設定変数または正規のディストリビューション名の形式で指定されたパッチディレクトリへの相対パスです。例については、CPAN.pmディストリビューションのdistroprefs /ディレクトリを参照してください（これらの例はデフォルトではインストールされません）。</target>
        </trans-unit>
        <trans-unit id="b89f1be8b64b665e2888aa36341ca67f3fc8a573" translate="yes" xml:space="preserve">
          <source>An array of the handles returned by successful calls to dl_load_file(), made by bootstrap, in the order in which they were loaded. Can be used with dl_find_symbol() to look for a symbol in any of the loaded files.</source>
          <target state="translated">ブートストラップによる dl_load_file()の呼び出しが成功したときに返されたハンドルを、読み込まれた順に配列化したもの。dl_find_symbol()と一緒に使用して、ロードされたファイルの中からシンボルを探すことができます。</target>
        </trans-unit>
        <trans-unit id="2042400b9cf51420ca0bb02f4a95651f7d9e0fc1" translate="yes" xml:space="preserve">
          <source>An array represents a list of values:</source>
          <target state="translated">配列は、値のリストを表します。</target>
        </trans-unit>
        <trans-unit id="d58bf09473fcb443f32238cd3f343fe1cb52e884" translate="yes" xml:space="preserve">
          <source>An array with multiple subscripts for finding a single element. Perl implements these using &lt;b&gt;references&lt;/b&gt;&amp;mdash;see Camel chapter 9, &amp;ldquo;Data Structures&amp;rdquo;.</source>
          <target state="translated">単一の要素を見つけるための複数の添え字を持つ配列。Perlは&lt;b&gt;参照&lt;/b&gt;を使用してこれらを実装し&lt;b&gt;ます&amp;mdash;&lt;/b&gt; Camelの第9章「データ構造」を&lt;b&gt;参照&lt;/b&gt;して&lt;b&gt;ください&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="e730b7563caa7a9a3615b79242bd88575f2b5d2f" translate="yes" xml:space="preserve">
          <source>An attempt to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require $module&quot;&lt;/code&gt; failed, even though the list of extensions indicated that it should succeed. Correct by conducting a proper installation.</source>
          <target state="translated">試み &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require $module&quot;&lt;/code&gt; 拡張子のリストは、それが成功する必要があることを示していても、失敗しました。正しく取り付けて修正してください。</target>
        </trans-unit>
        <trans-unit id="8668d93103d45211068cbb7aa1991bd63b959bd9" translate="yes" xml:space="preserve">
          <source>An attempt to allocate memory failed.</source>
          <target state="translated">メモリの割り当てに失敗しました。</target>
        </trans-unit>
        <trans-unit id="4965e597a6abdfe2d520970b55b8363275b2a451" translate="yes" xml:space="preserve">
          <source>An attempt to set an unrecognized attribute is a fatal error. (The error is trappable, but it still stops the compilation within that &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;.) Setting an attribute with a name that's all lowercase letters that's not a built-in attribute (such as &quot;foo&quot;) will result in a warning with &lt;b&gt;-w&lt;/b&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'reserved'&lt;/code&gt; .</source>
          <target state="translated">認識されない属性を設定しようとすると、致命的なエラーになります。（エラーはトラップ可能ですが、それでもその &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 内でのコンパイルは停止します。）組み込み属性ではないすべて小文字の名前で属性を設定すると（ &quot;foo&quot;など）、- &lt;b&gt;w&lt;/b&gt;または &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'reserved'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="93c1784b7ddee55af5b75a4bf233031106bc926c" translate="yes" xml:space="preserve">
          <source>An attribute handler was specified with an &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt;, but the type of referent it was defined to handle wasn't one of the five permitted: &lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; , &lt;code&gt;CODE&lt;/code&gt; , or &lt;code&gt;ANY&lt;/code&gt; .</source>
          <target state="translated">属性ハンドラが &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt; で指定されましたが、それが処理するように定義された参照先のタイプは、許可されている5つの &lt;code&gt;SCALAR&lt;/code&gt; 、 &lt;code&gt;ARRAY&lt;/code&gt; 、 &lt;code&gt;HASH&lt;/code&gt; 、 &lt;code&gt;CODE&lt;/code&gt; 、または &lt;code&gt;ANY&lt;/code&gt; の 1つではありませんでした。</target>
        </trans-unit>
        <trans-unit id="9ed24a1addfea7e1a18f9560990ecafe644b6003" translate="yes" xml:space="preserve">
          <source>An attribute is a piece of data belonging to a particular object. Unlike most object-oriented languages, Perl provides no special syntax or support for declaring and manipulating attributes.</source>
          <target state="translated">属性とは、特定のオブジェクトに属するデータの一部です。ほとんどのオブジェクト指向言語とは異なり、Perl は属性を宣言したり操作したりするための特別な構文やサポートを提供しません。</target>
        </trans-unit>
        <trans-unit id="4774fb20b25b2c00d90761710a32f25902ad2435" translate="yes" xml:space="preserve">
          <source>An attribute list is a sequence of attribute specifications, separated by whitespace or a colon (with optional whitespace). Each attribute specification is a simple name, optionally followed by a parenthesised parameter list. If such a parameter list is present, it is scanned past as for the rules for the &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; operator. (See &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;.) The parameter list is passed as it was found, however, and not as per &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">属性リストは、空白またはコロン（オプションの空白あり）で区切られた一連の属性指定です。各属性の指定は単純な名前で、オプションで括弧で囲まれたパラメーターリストが後に続きます。そのようなパラメータリストが存在する場合、 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; 演算子のルールと同様にスキャンされます。 （&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;perlopのQuoteおよびQuote-like演算子を&lt;/a&gt;参照してください。）ただし、パラメーターリストは、 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; ではなく、見つかったとおりに渡されます。</target>
        </trans-unit>
        <trans-unit id="b6ff4a009f82a7cfb00247fff66222df5571297d" translate="yes" xml:space="preserve">
          <source>An effect similar to &lt;code&gt;(?&amp;gt;pattern)&lt;/code&gt; may be achieved by writing &lt;code&gt;(?=(pattern))\g{-1}&lt;/code&gt; . This matches the same substring as a standalone &lt;code&gt;a+&lt;/code&gt; , and the following &lt;code&gt;\g{-1}&lt;/code&gt; eats the matched string; it therefore makes a zero-length assertion into an analogue of &lt;code&gt;(?&amp;gt;...)&lt;/code&gt;. (The difference between these two constructs is that the second one uses a capturing group, thus shifting ordinals of backreferences in the rest of a regular expression.)</source>
          <target state="translated">&lt;code&gt;(?&amp;gt;pattern)&lt;/code&gt; と同様の効果は、 &lt;code&gt;(?=(pattern))\g{-1}&lt;/code&gt; 書くことで実現できます。これは、スタンドアロン &lt;code&gt;a+&lt;/code&gt; と同じ部分文字列に一致し、次の &lt;code&gt;\g{-1}&lt;/code&gt; は一致した文字列を食べます。したがって、長さゼロのアサーションを &lt;code&gt;(?&amp;gt;...)&lt;/code&gt; の類似物にします。（これらの2つの構成の違いは、2番目の構成がキャプチャグループを使用するため、正規表現の残りの部分で後方参照の序数がシフトされることです。）</target>
        </trans-unit>
        <trans-unit id="e5eb41f6f24dfa906c0da1eda1f150cd75892a06" translate="yes" xml:space="preserve">
          <source>An empty leading field is produced when there is a positive-width match at the beginning of EXPR. For instance:</source>
          <target state="translated">EXPRの先頭に正の幅の一致がある場合、空の先頭フィールドが生成されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="7c1d0be8e8ca70fd2b14e62fb21989504ef1df2a" translate="yes" xml:space="preserve">
          <source>An empty list as soon as an explicit &lt;code&gt;break&lt;/code&gt; is encountered.</source>
          <target state="translated">明示的な &lt;code&gt;break&lt;/code&gt; が発生するとすぐに空のリスト。</target>
        </trans-unit>
        <trans-unit id="afbf0f80f22fc5d795da7f111754a1b9ed2a4fe4" translate="yes" xml:space="preserve">
          <source>An empty trailing field, on the other hand, is produced when there is a match at the end of EXPR, regardless of the length of the match (of course, unless a non-zero LIMIT is given explicitly, such fields are removed, as in the last example). Thus:</source>
          <target state="translated">一方、空の末尾フィールドは、EXPRの最後に一致があった場合、一致の長さに関係なく生成されます(もちろん、明示的に0以外のLIMITが与えられない限り、最後の例のように、そのようなフィールドは削除されます)。したがって、次のようになります。</target>
        </trans-unit>
        <trans-unit id="cd562f569c7a192c547c6c2160f193f3f97949c6" translate="yes" xml:space="preserve">
          <source>An enchantment, illusion, phantasm, or jugglery. Said when Perl&amp;rsquo;s magical &lt;b&gt;dwimmer&lt;/b&gt; effects don&amp;rsquo;t do what you expect, but rather seem to be the product of arcane</source>
          <target state="translated">エンチャント、幻想、幻想、手品。Perlの不思議な&lt;b&gt;ちらつき&lt;/b&gt;効果が期待どおりに動作せず、難解な製品のように見える場合に&lt;b&gt;発言&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5a1e64f9893fb69df07a9e0956194fcfd71ca286" translate="yes" xml:space="preserve">
          <source>An endpoint for network communication among multiple &lt;b&gt;processes&lt;/b&gt; that works much like a telephone or a post office box. The most important thing about a socket is its &lt;b&gt;network address&lt;/b&gt; (like a phone number). Different kinds of sockets have different kinds of addresses&amp;mdash;some look like filenames, and some don&amp;rsquo;t.</source>
          <target state="translated">電話や私書箱のように機能する複数の&lt;b&gt;プロセス&lt;/b&gt;間のネットワーク通信のエンドポイント。ソケットについて最も重要なことは、その&lt;b&gt;ネットワークアドレス&lt;/b&gt;（電話番号など）です。ソケットの種類によって、アドレスの種類が異なります。ファイル名のように見えるものと、そうでないものがあります。</target>
        </trans-unit>
        <trans-unit id="84340afb233fc1ed2c36b5178d0bb87bc821d3fd" translate="yes" xml:space="preserve">
          <source>An entire computer program crammed into one line of text.</source>
          <target state="translated">コンピュータプログラム全体を一行のテキストに詰め込んだもの。</target>
        </trans-unit>
        <trans-unit id="0b89a9a0affedc51570a8afe57fcceb747dbf5fe" translate="yes" xml:space="preserve">
          <source>An entity specified by number (dec, hex, oct) is out of range (1-255).</source>
          <target state="translated">数字(dec,hex,oct)で指定されたエンティティが範囲外(1-255)です。</target>
        </trans-unit>
        <trans-unit id="e4a99f74cee987dba72920fbff7e10dc623de69d" translate="yes" xml:space="preserve">
          <source>An entry of the form &lt;code&gt;-La:\foo&lt;/code&gt; specifies the &lt;code&gt;a:\foo&lt;/code&gt; directory to look for the libraries that follow.</source>
          <target state="translated">&lt;code&gt;-La:\foo&lt;/code&gt; という形式のエントリは、後に続くライブラリを探すために &lt;code&gt;a:\foo&lt;/code&gt; ディレクトリを指定します。</target>
        </trans-unit>
        <trans-unit id="e872c91a08d6535bc529f64f8ec25e1266b0facd" translate="yes" xml:space="preserve">
          <source>An entry of the form &lt;code&gt;-lfoo&lt;/code&gt; specifies the library &lt;code&gt;foo&lt;/code&gt; , which may be spelled differently depending on what kind of compiler you are using. If you are using GCC, it gets translated to &lt;code&gt;libfoo.a&lt;/code&gt; , but for other win32 compilers, it becomes &lt;code&gt;foo.lib&lt;/code&gt; . If no files are found by those translated names, one more attempt is made to find them using either &lt;code&gt;foo.a&lt;/code&gt; or &lt;code&gt;libfoo.lib&lt;/code&gt; , depending on whether GCC or some other win32 compiler is being used, respectively.</source>
          <target state="translated">&lt;code&gt;-lfoo&lt;/code&gt; 形式のエントリは、ライブラリ &lt;code&gt;foo&lt;/code&gt; を指定します。これは、使用しているコンパイラの種類に応じてスペルが異なる場合があります。GCCを使用している場合は &lt;code&gt;libfoo.a&lt;/code&gt; に変換されますが、他のwin32コンパイラの場合は &lt;code&gt;foo.lib&lt;/code&gt; になります。これらの翻訳された名前でファイルが見つからない場合は、それぞれGCCまたは他のwin32コンパイラーが使用されているかどうかに応じて、 &lt;code&gt;foo.a&lt;/code&gt; または &lt;code&gt;libfoo.lib&lt;/code&gt; のいずれかを使用してファイルを検索するためのもう1つの試みが行われます。</target>
        </trans-unit>
        <trans-unit id="542b3550714b3908eea8d8c13ea7256018c9e930" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:nodefault/i&lt;/code&gt; disables the appending of default libraries found in &lt;code&gt;$Config{perllibs}&lt;/code&gt; (this should be only needed very rarely).</source>
          <target state="translated">&lt;code&gt;/:nodefault/i&lt;/code&gt; に一致するエントリは、 &lt;code&gt;$Config{perllibs}&lt;/code&gt; あるデフォルトライブラリの追加を無効にします（これが必要になることは非常にまれです）。</target>
        </trans-unit>
        <trans-unit id="54596c2d41917bea50cab186303f4d27d58e3783" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:nosearch/i&lt;/code&gt; disables all searching for the libraries specified after it. Translation of &lt;code&gt;-Lfoo&lt;/code&gt; and &lt;code&gt;-lfoo&lt;/code&gt; still happens as appropriate (depending on compiler being used, as reflected by &lt;code&gt;$Config{cc}&lt;/code&gt; ), but the entries are not verified to be valid files or directories.</source>
          <target state="translated">&lt;code&gt;/:nosearch/i&lt;/code&gt; に一致するエントリは、その後に指定されたライブラリの検索をすべて無効にします。 &lt;code&gt;-Lfoo&lt;/code&gt; および &lt;code&gt;-lfoo&lt;/code&gt; の変換は引き続き適切に行われ（使用されるコンパイラーに応じて、 &lt;code&gt;$Config{cc}&lt;/code&gt; によって反映されます）、エントリは有効なファイルまたはディレクトリであることが確認されていません。</target>
        </trans-unit>
        <trans-unit id="341641ec8dfdfc884739074e9d2b0f226cf6a1e7" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:search/i&lt;/code&gt; reenables searching for the libraries specified after it. You can put it at the end to enable searching for default libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;/:search/i&lt;/code&gt; に一致するエントリは、その後に指定されたライブラリの検索を再度有効にします。これを最後に置くと、 &lt;code&gt;$Config{perllibs}&lt;/code&gt; 指定されたデフォルトのライブラリを検索できるようになります。</target>
        </trans-unit>
        <trans-unit id="eac77ebce5cb434a4347aeb52157baf13e86e68f" translate="yes" xml:space="preserve">
          <source>An enum of flags for Perl types. These are found in the file &lt;b&gt;sv.h&lt;/b&gt; in the &lt;code&gt;svtype&lt;/code&gt; enum. Test these flags with the &lt;code&gt;SvTYPE&lt;/code&gt; macro.</source>
          <target state="translated">Perlタイプのフラグの列挙。これらは、ファイルの中に発見され&lt;b&gt;sv.h&lt;/b&gt;で &lt;code&gt;svtype&lt;/code&gt; の列挙。 &lt;code&gt;SvTYPE&lt;/code&gt; マクロでこれらのフラグをテストします。</target>
        </trans-unit>
        <trans-unit id="a352e1f402bd0b0688137a6b2ecc0dfb6c13f18b" translate="yes" xml:space="preserve">
          <source>An enum value. Used to transfer an enum component from C. There is no reason to pass an enum value to C since it is stored as an IV inside perl.</source>
          <target state="translated">enum値です。Cからenumコンポーネントを転送するために使用されます。</target>
        </trans-unit>
        <trans-unit id="85b348ed9fe24e3e5ab044fd0ea208d3866c0f50" translate="yes" xml:space="preserve">
          <source>An environment variable is used, rather than parallel make itself, because &lt;a href=&quot;tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; needs to be able to schedule individual non-conflicting test scripts itself, and there is no standard interface to &lt;code&gt;make&lt;/code&gt; utilities to interact with their job schedulers.</source>
          <target state="translated">&lt;a href=&quot;tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt;は、競合しない個々のテストスクリプト自体をスケジュールできる必要があり、ユーティリティがジョブスケジューラと対話する &lt;code&gt;make&lt;/code&gt; の標準インターフェイスがないため、並列make自体ではなく環境変数が使用されます。</target>
        </trans-unit>
        <trans-unit id="066862fe86f40b5704d122b8bfa39f1462669702" translate="yes" xml:space="preserve">
          <source>An error has occurred (for &lt;code&gt;PerlIO_error()&lt;/code&gt; ).</source>
          <target state="translated">エラーが発生しました（ &lt;code&gt;PerlIO_error()&lt;/code&gt; の場合）。</target>
        </trans-unit>
        <trans-unit id="bf25473c20a4c33f096f0b4023a99e2a049e0b27" translate="yes" xml:space="preserve">
          <source>An essential part of any good development process is appropriate error handling with appropriately informative messages, however there exists a school of thought which suggests that log files should be</source>
          <target state="translated">いかなる良い開発プロセスにおいても、適切なエラー処理と適切な有益なメッセージが不可欠ですが、ログファイルは</target>
        </trans-unit>
        <trans-unit id="66bdaa16d0763f3a76de0b4a13d35f1b3d80f29a" translate="yes" xml:space="preserve">
          <source>An even stranger template code is &lt;code&gt;%&lt;/code&gt; &amp;lt;</source>
          <target state="translated">さらに奇妙なテンプレートコードは &lt;code&gt;%&lt;/code&gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="8a5463243357a8ee13bfd32810dc057038bf9e07" translate="yes" xml:space="preserve">
          <source>An event that causes a &lt;b&gt;handler&lt;/b&gt; to be run.</source>
          <target state="translated">&lt;b&gt;ハンドラー&lt;/b&gt;を実行させるイベント。</target>
        </trans-unit>
        <trans-unit id="aa855332f899b198338c3e15641312b3dfa643e8" translate="yes" xml:space="preserve">
          <source>An example conversion function for a typemapped struct &lt;code&gt;foo_t *&lt;/code&gt; might be:</source>
          <target state="translated">タイプマップされたstruct &lt;code&gt;foo_t *&lt;/code&gt; の変換関数の例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="ec7aaa34ffb73c97f6ed68693695810184b33f37" translate="yes" xml:space="preserve">
          <source>An example disabling Nagle's algorithm on a socket:</source>
          <target state="translated">ソケット上でNagleのアルゴリズムを無効にする例。</target>
        </trans-unit>
        <trans-unit id="370a61094a87b707b90886b80eccf424717c5430" translate="yes" xml:space="preserve">
          <source>An example for Russian and some languages using the Cyrillic script:</source>
          <target state="translated">ロシア語およびキリル文字を使用したいくつかの言語の例。</target>
        </trans-unit>
        <trans-unit id="562686eabf6589e6760dcb870fbc2918a4b18229" translate="yes" xml:space="preserve">
          <source>An example of all of the phases Perl code can see:</source>
          <target state="translated">Perlのコードが見ることができるすべてのフェーズの例。</target>
        </trans-unit>
        <trans-unit id="5242beac10407637f4a4b464517825d71718f4a4" translate="yes" xml:space="preserve">
          <source>An example of how this might be used is as follows:</source>
          <target state="translated">これをどのように使うかの例としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="ab9dc32ca31441503bc05feea6fc9cf1b0dfb98e" translate="yes" xml:space="preserve">
          <source>An example output might be:</source>
          <target state="translated">出力例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="516a8fafa09adceb915093c484c5d89d031db306" translate="yes" xml:space="preserve">
          <source>An example usage looks like:</source>
          <target state="translated">使用例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">一例です。</target>
        </trans-unit>
        <trans-unit id="b3e01d95d4f7169aa36a737a1211243d324cf5ef" translate="yes" xml:space="preserve">
          <source>An exception</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb08b0a2e1d46bb5d472e490ea7b28d5dd9e956d" translate="yes" xml:space="preserve">
          <source>An exception to this is that you may assign to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in a list. This is useful for throwing away some of the return values of a function:</source>
          <target state="translated">これの例外は、リストで &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; に割り当てることができることです。これは、関数の戻り値の一部を破棄するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="0fc1d98cce4c241de46d33d676c33734f841fc89" translate="yes" xml:space="preserve">
          <source>An executable compiled on a PA-RISC 2.0 platform will not execute on a PA-RISC 1.1 platform, even if they are running the same version of HP-UX. If you are building Perl on a PA-RISC 2.0 platform and want that Perl to also run on a PA-RISC 1.1, the compiler flags +DAportable and +DS32 should be used.</source>
          <target state="translated">PA-RISC 2.0プラットフォーム上でコンパイルされた実行ファイルは、同じバージョンのHP-UXであってもPA-RISC 1.1プラットフォーム上では実行されません。PA-RISC 2.0プラットフォーム上でPerlをビルドしていて、そのPerlをPA-RISC 1.1上でも実行させたい場合は、コンパイラフラグ+DAportableと+DS32を使用してください。</target>
        </trans-unit>
        <trans-unit id="089b36ce65cddba1918a51ae6a46d8831ee39956" translate="yes" xml:space="preserve">
          <source>An exit status of 0 implies &quot;success&quot;. For example, &lt;b&gt;diff(1)&lt;/b&gt; exits with a status of 0 if the two files have the same contents.</source>
          <target state="translated">終了ステータス0は「成功」を意味します。たとえば、2つのファイルの内容が同じ場合、&lt;b&gt;diff（1）&lt;/b&gt;はステータス0で終了します。</target>
        </trans-unit>
        <trans-unit id="bbd4429d08a5ebe605cc6bfbbfa2eaacec53a0f9" translate="yes" xml:space="preserve">
          <source>An exit status of 1 implies possibly abnormal, but non-defective, program termination. For example, &lt;b&gt;grep(1)&lt;/b&gt; exits with a status of 1 if it did</source>
          <target state="translated">終了ステータスが1の場合は、プログラムが異常終了している可能性がありますが、正常に終了しています。たとえば、&lt;b&gt;grep（1）&lt;/b&gt;が終了した場合、ステータス1で終了します。</target>
        </trans-unit>
        <trans-unit id="e246081e6327d64a230056100ee6a6d47e29ef00" translate="yes" xml:space="preserve">
          <source>An exit status of 2 or more implies a fatal error. For example, &lt;b&gt;ls(1)&lt;/b&gt; exits with a status of 2 if you specify an illegal (unknown) option on the command line.</source>
          <target state="translated">2以上の終了ステータスは、致命的なエラーを意味します。たとえば、コマンドラインで不正な（不明な）オプションを指定すると、&lt;b&gt;ls（1）&lt;/b&gt;はステータス2で終了します。</target>
        </trans-unit>
        <trans-unit id="1ff1cef51589fc8dbb6faba666f12b831fe6b899" translate="yes" xml:space="preserve">
          <source>An experimental pseudolayer that removes the topmost layer. Use with the same care as is reserved for nitroglycerine.</source>
          <target state="translated">最上層を除去する実験的な擬似層。ニトログリセリンと同様の注意を払って使用してください。</target>
        </trans-unit>
        <trans-unit id="846db25d0ecc19ed2c5fd44070c00f6f8a9c0772" translate="yes" xml:space="preserve">
          <source>An explanation of VMS file specs can be found at &lt;a href=&quot;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&quot;&gt;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&lt;/a&gt;.</source>
          <target state="translated">VMSファイル仕様の説明は、&lt;a href=&quot;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&quot;&gt;http：//h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_filesにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b85172cf7a158b615a4c1e4c610cfa79b7fa2c51" translate="yes" xml:space="preserve">
          <source>An explicit format parameter index, such as &lt;code&gt;2$&lt;/code&gt;. By default sprintf will format the next unused argument in the list, but this allows you to take the arguments out of order:</source>
          <target state="translated">&lt;code&gt;2$&lt;/code&gt; などの明示的なフォーマットパラメータインデックス。デフォルトでは、sprintfはリスト内の次の未使用の引数をフォーマットしますが、これにより引数を順不同にすることができます。</target>
        </trans-unit>
        <trans-unit id="52691b6df07cdbefee8cb7a498d3dc93b2c8dd90" translate="yes" xml:space="preserve">
          <source>An exploration of some of the issues facing Perl programmers on EBCDIC based computers.</source>
          <target state="translated">EBCDICベースのコンピュータ上でPerlプログラマが直面している問題のいくつかを探ります。</target>
        </trans-unit>
        <trans-unit id="372a1e4ea54335151ba75e3cd2ea53899b760f24" translate="yes" xml:space="preserve">
          <source>An expression which, when its value changes, causes a breakpoint in the Perl debugger.</source>
          <target state="translated">値が変更されると、Perl デバッガでブレークポイントを発生させる式。</target>
        </trans-unit>
        <trans-unit id="d16dfa398c1840b695b36040deeba3088ca6a02a" translate="yes" xml:space="preserve">
          <source>An extension is a way of calling compiled C code from Perl. Reading &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; is a good place to learn more about extensions.</source>
          <target state="translated">拡張機能は、PerlからコンパイルされたCコードを呼び出す方法です。拡張機能について詳しく学ぶには、&lt;a href=&quot;perlxstut&quot;&gt;perlxstutを&lt;/a&gt;読むのがよいでしょう。</target>
        </trans-unit>
        <trans-unit id="9164cae08d37bdf18edf58e540f0e6c559fb27cc" translate="yes" xml:space="preserve">
          <source>An extension that is built with the above steps is ready to use on systems supporting dynamic loading. On systems that do not support dynamic loading, any newly created extension has to be linked together with the available resources. MakeMaker supports the linking process by creating appropriate targets in the Makefile whenever an extension is built. You can invoke the corresponding section of the makefile with</source>
          <target state="translated">上記の手順で構築された拡張機能は、動的読み込みをサポートしているシステムで使用する準備ができています。ダイナミックローディングをサポートしていないシステムでは、新しく作成した拡張機能は利用可能なリソースとリンクする必要があります。MakeMaker は、拡張機能がビルドされるたびに Makefile に適切なターゲットを作成することで、リンク処理をサポートします。makefile の対応するセクションを</target>
        </trans-unit>
        <trans-unit id="62fe96c831d4e5434f2a2484c5da0d22ce2c69d7" translate="yes" xml:space="preserve">
          <source>An external &lt;b&gt;subroutine&lt;/b&gt; defined in &lt;b&gt;XS&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;XSで&lt;/b&gt;定義された外部&lt;b&gt;サブルーチン&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7422ed8b7617c92670f322946ad1f9ad0f35ee57" translate="yes" xml:space="preserve">
          <source>An extra field consists of zero or more subfields. Each subfield consists of a two byte header followed by the subfield data.</source>
          <target state="translated">エクストラフィールドは、ゼロ以上のサブフィールドで構成されます。各サブフィールドは、2バイトのヘッダとサブフィールドデータの後に続く2バイトのヘッダで構成されています。</target>
        </trans-unit>
        <trans-unit id="18c0e84026650565acf5b36d62e6093af36330f9" translate="yes" xml:space="preserve">
          <source>An extraordinarily exported, expeditiously excellent, expressly eXternal Subroutine, executed in existing C or C++ or in an exciting extension language called (exasperatingly) XS.</source>
          <target state="translated">既存のCやC++、またはXSと呼ばれるエキサイティングな拡張言語で実行される、非常に迅速にエクスポートされた優れた、明示的にeXternalサブルーチンです。</target>
        </trans-unit>
        <trans-unit id="5ae0ec1c420230a4b9a6f6f5a35cd2c66a33eeb2" translate="yes" xml:space="preserve">
          <source>An extremely lightweight &lt;b&gt;DB_File&lt;/b&gt; wrapper that simply flocks a lockfile before tie-ing the database and drops the lock after the untie. Allows one to use the same lockfile for multiple databases to avoid deadlock problems, if desired. Use for databases where updates are reads are quick and simple flock locking semantics are enough.</source>
          <target state="translated">データベースを結合する前にロックファイルをフロックし、結合解除後にロックをドロップする、非常に軽量な&lt;b&gt;DB_File&lt;/b&gt;ラッパー。必要に応じて、複数のデータベースに同じロックファイルを使用してデッドロックの問題を回避できます。更新が読み取りであるデータベースに使用すると、迅速かつ単純なフロックロックのセマンティクスで十分です。</target>
        </trans-unit>
        <trans-unit id="6c7aaf1b9af23250eb8ede6f4c91ca5fbe3ad083" translate="yes" xml:space="preserve">
          <source>An identifier (not necessarily related to the real name of a file) that represents a particular instance of opening a file, until you close it. If you&amp;rsquo;re going to open and close several different files in succession, it&amp;rsquo;s fine to open each of them with the same filehandle, so you don&amp;rsquo;t have to write out separate code to process each file.</source>
          <target state="translated">ファイルを閉じるまで、ファイルを開く特定のインスタンスを表す識別子（必ずしもファイルの実際の名前に関連している必要はありません）。複数の異なるファイルを連続して開いたり閉じたりする場合は、同じファイルハンドルで各ファイルを開いても問題ないため、各ファイルを処理するために個別のコードを記述する必要はありません。</target>
        </trans-unit>
        <trans-unit id="2ca4f6f5a018c6a780d2f920105ee21e87c135e6" translate="yes" xml:space="preserve">
          <source>An immediate filter allows you to specify the filter code to be used at the point where the filter is applied to a dbm. In this mode the Filter_*_Push methods expects to receive exactly two parameters.</source>
          <target state="translated">即時フィルタは、フィルタが dbm に適用された時点で使用するフィルタコードを指定することができます。このモードでは、Filter_*_Pushメソッドは2つのパラメータを正確に受け取ることを期待しています。</target>
        </trans-unit>
        <trans-unit id="854d43de9440512807e67ff18407c545a932b325" translate="yes" xml:space="preserve">
          <source>An imperfect standard</source>
          <target state="translated">不完全な基準</target>
        </trans-unit>
        <trans-unit id="20af74febdbf871248a6b2f4c417ca9aaffe6f3f" translate="yes" xml:space="preserve">
          <source>An important property of the digest algorithms is that the digest is</source>
          <target state="translated">ダイジェストアルゴリズムの重要な特性は、ダイジェストが</target>
        </trans-unit>
        <trans-unit id="5358f4c4e85e881620623ef0fa458c651c57bf92" translate="yes" xml:space="preserve">
          <source>An incremental option is specified with a plus &lt;code&gt;+&lt;/code&gt; after the option name:</source>
          <target state="translated">増分オプションは、オプション名の後にプラス &lt;code&gt;+&lt;/code&gt; を付けて指定します。</target>
        </trans-unit>
        <trans-unit id="eff14445a69700081714d1ed9ff369fb4f2bc735" translate="yes" xml:space="preserve">
          <source>An index of character names is available on-line from the Unicode Consortium, &lt;a href=&quot;http://www.unicode.org/charts/charindex.html&quot;&gt;http://www.unicode.org/charts/charindex.html&lt;/a&gt;; explanatory material with links to other resources at &lt;a href=&quot;http://www.unicode.org/standard/where&quot;&gt;http://www.unicode.org/standard/where&lt;/a&gt;.</source>
          <target state="translated">キャラクター名のインデックスは、Unicodeコンソーシアム&lt;a href=&quot;http://www.unicode.org/charts/charindex.html&quot;&gt;http://www.unicode.org/charts/charindex.html&lt;/a&gt;からオンラインで入手できます。&lt;a href=&quot;http://www.unicode.org/standard/where&quot;&gt;http://www.unicode.org/standard/where&lt;/a&gt;にある他のリソースへのリンクを含む説明資料。</target>
        </trans-unit>
        <trans-unit id="ef770a25a15f3c0ce63ccdcd24649733fd026bd0" translate="yes" xml:space="preserve">
          <source>An indirect filehandle is the use of something other than a symbol in a place that a filehandle is expected. Here are ways to get indirect filehandles:</source>
          <target state="translated">間接ファイルハンドルとは、ファイルハンドルが期待される場所でシンボル以外の何かを使用することです。間接ファイルハンドルを取得する方法を以下に示します。</target>
        </trans-unit>
        <trans-unit id="858451a2efc846133fcc1f6e934e6a48b50f2e8c" translate="yes" xml:space="preserve">
          <source>An informative hash, accessible via &lt;code&gt;details()&lt;/code&gt; , is stored for each test you perform. So memory usage will scale linearly with each test run. Although this is not a problem for most test suites, it can become an issue if you do large (hundred thousands to million) combinatorics tests in the same run.</source>
          <target state="translated">&lt;code&gt;details()&lt;/code&gt; からアクセスできる有益なハッシュは、実行するテストごとに保存されます。したがって、メモリ使用量は、テストの実行ごとに線形にスケーリングされます。これはほとんどのテストスイートにとって問題ではありませんが、大規模な（数十万から数百万）組み合わせテストを同じ実行で行う場合、問題になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a9e6a3af85651e42bfa391fe495fc3734c02ae8b" translate="yes" xml:space="preserve">
          <source>An input file that uses source filtering probably won't be deparsed into runnable code, because it will still include the &lt;b&gt;use&lt;/b&gt; declaration for the source filtering module, even though the code that is produced is already ordinary Perl which shouldn't be filtered again.</source>
          <target state="translated">ソースフィルタリングを使用する入力ファイルは、実行可能なコードに分解されない可能性があります。生成されるコードが既に通常のPerlであるため、再度フィルタリングする必要はありませんが、ソースフィルタリングモジュールの&lt;b&gt;使用&lt;/b&gt;宣言が含まれている&lt;b&gt;ため&lt;/b&gt;です。</target>
        </trans-unit>
        <trans-unit id="aa16b38820f7deb5595d1bc31e5c4264a804f15b" translate="yes" xml:space="preserve">
          <source>An installation can choose to allow any of these to be matched by downloading the Unicode database from &lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt; to &lt;code&gt;$Config{privlib}&lt;/code&gt; /</source>
          <target state="translated">インストールでは、&lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http：//www.unicode.org/Public/&lt;/a&gt;から &lt;code&gt;$Config{privlib}&lt;/code&gt; /にUnicodeデータベースをダウンロードすることにより、これらのいずれかを一致させることができます。</target>
        </trans-unit>
        <trans-unit id="a014f84e1453ef226d46effcd0a9cbfe569a9f81" translate="yes" xml:space="preserve">
          <source>An instance of a running program. Under multitasking systems like Unix, two or more separate processes could be running the same program independently at the same time&amp;mdash;in fact, the &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; function is designed to bring about this happy state of affairs. Under other operating systems, processes are sometimes called &amp;ldquo;threads&amp;rdquo;, &amp;ldquo;tasks&amp;rdquo;, or &amp;ldquo;jobs&amp;rdquo;, often with slight nuances in meaning.</source>
          <target state="translated">実行中のプログラムのインスタンス。Unixのようなマルチタスクシステムでは、2つ以上の別々のプロセスが同じプログラムを同時に独立して同時に実行できます。実際、 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 機能はこの幸せな状態をもたらすように設計されています。他のオペレーティングシステムでは、プロセスは「スレッド」、「タスク」、または「ジョブ」と呼ばれることもあり、意味に微妙なニュアンスを伴うことがよくあります。</target>
        </trans-unit>
        <trans-unit id="0214de560f2556559c172656f6d4683531a40229" translate="yes" xml:space="preserve">
          <source>An integer divisor when you&amp;rsquo;re interested in the remainder instead of the quotient.</source>
          <target state="translated">商ではなく剰余に関心がある場合の整数除数。</target>
        </trans-unit>
        <trans-unit id="ef97a772df2ab33140914238f0dfa09aa1f2481c" translate="yes" xml:space="preserve">
          <source>An integer in the range from 0 to 1, inclusive. The smallest possible unit of information storage. An eighth of a &lt;b&gt;byte&lt;/b&gt; or of a dollar. (The term &amp;ldquo;Pieces of Eight&amp;rdquo; comes from being able to split the old Spanish dollar into 8 bits, each of which still counted for money. That&amp;rsquo;s why a 25- cent piece today is still &amp;ldquo;two bits&amp;rdquo;.)</source>
          <target state="translated">0から1までの範囲の整数。情報ストレージの可能な最小単位。&lt;b&gt;バイト&lt;/b&gt;またはドルの8分の1。（「Pieces of Eight」という用語は、古いスペインドルを8ビットに分割できることから来ています。それぞれ8ビットですが、それでもお金に数えられます。そのため、今日の25セントのピースは、まだ「2ビット」です。</target>
        </trans-unit>
        <trans-unit id="487c5ee86805465c96baeca407a9f1d4e496a654" translate="yes" xml:space="preserve">
          <source>An interesting property of the 32 C0 control characters in the ASCII table is that they can &quot;literally&quot; be constructed as control characters in Perl, e.g. &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt; )&amp;gt; &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt; )&amp;gt;, and so on. Perl on EBCDIC platforms has been ported to take &lt;code&gt;\c@&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;\cA&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt;, etc. as well, but the characters that result depend on which code page you are using. The table below uses the standard acronyms for the controls. The POSIX-BC and 1047 sets are identical throughout this range and differ from the 0037 set at only one spot (21 decimal). Note that the line terminator character may be generated by &lt;code&gt;\cJ&lt;/code&gt; on ASCII platforms but by &lt;code&gt;\cU&lt;/code&gt; on 1047 or POSIX-BC platforms and cannot be generated as a &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; control character on 0037 platforms. Note also that &lt;code&gt;\c\&lt;/code&gt; cannot be the final element in a string or regex, as it will absorb the terminator. But &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; is a &lt;code&gt;FILE
SEPARATOR&lt;/code&gt; concatenated with</source>
          <target state="translated">ASCIIテーブルの32個のC0制御文字の興味深い特性は、Perlで制御文字として「文字通り」構築できることです。たとえば、 &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt; ）&amp;gt; &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt; ）&amp;gt; 、 等々。 EBCDICプラットフォーム上のPerlは、 &lt;code&gt;\c@&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0)&lt;/a&gt;&lt;/code&gt; に、 &lt;code&gt;\cA&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt; に移植するように移植されていますなども含まれますが、結果として得られる文字は、使用しているコードページによって異なります。以下の表では、コントロールに標準の頭字語を使用しています。 POSIX-BCおよび1047セットは、この範囲全体で同一であり、0037セットとは1つのスポット（10進数21）のみが異なります。行終端文字がによって生成されてもよいことに注意してください &lt;code&gt;\cJ&lt;/code&gt; ASCIIプラットフォーム上ではなくで &lt;code&gt;\cU&lt;/code&gt; 1047またはPOSIX-BCプラットフォーム上ととして生成することができない &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; 0037プラットフォームの制御文字。 &lt;code&gt;\c\&lt;/code&gt; はターミネーターを吸収するため、文字列または正規表現の最後の要素にはならないことにも注意してください。しかし、 &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; は、 &lt;code&gt;FILE SEPARATOR&lt;/code&gt; 連結されたFILE SEPARATORです。</target>
        </trans-unit>
        <trans-unit id="aef88cb460d98eb7a1821664038bd8e659735536" translate="yes" xml:space="preserve">
          <source>An internal &amp;ldquo;glob value&amp;rdquo; typedef, holding a &lt;b&gt;typeglob&lt;/b&gt;. The &lt;code&gt;GV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">内部の「グロブ値」のtypedefは、保持&lt;b&gt;型グロブを&lt;/b&gt;。 &lt;code&gt;GV&lt;/code&gt; のタイプはのサブクラスである&lt;b&gt;SV&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="365d20928561014537aae861944e88c7698c35b5" translate="yes" xml:space="preserve">
          <source>An internal I/O object. Can also mean &lt;b&gt;indirect object&lt;/b&gt;.</source>
          <target state="translated">内部I / Oオブジェクト。&lt;b&gt;間接オブジェクトを&lt;/b&gt;意味することもあり&lt;b&gt;ます&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="56ae7164116e23d92fc781838b142ca53874c36a" translate="yes" xml:space="preserve">
          <source>An internal function to generate the embedded perl code that will regenerate the constant subroutines.</source>
          <target state="translated">定数サブルーチンを再生成する埋め込みperlコードを生成するための内部関数です。</target>
        </trans-unit>
        <trans-unit id="7baaf8aedf397c98d596c2159887aa7f484b6db4" translate="yes" xml:space="preserve">
          <source>An internal function to generate the embedded perl code that will regenerate the constant subroutines. Parameters are the same as for C_constant.</source>
          <target state="translated">定数サブルーチンを再生成する埋め込みperlコードを生成するための内部関数です。パラメータはC_constantと同じです。</target>
        </trans-unit>
        <trans-unit id="85667dd393cb7f2981dedf066accff60dc1411e5" translate="yes" xml:space="preserve">
          <source>An internal method to generate a suitable &lt;code&gt;switch&lt;/code&gt; clause, called by &lt;code&gt;C_constant&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;C_constant&lt;/code&gt; によって呼び出される適切な &lt;code&gt;switch&lt;/code&gt; 句を生成する内部メソッド</target>
        </trans-unit>
        <trans-unit id="69e28cd04a2779fc9d5742eab6b3a6ded1892dd3" translate="yes" xml:space="preserve">
          <source>An internal representation of your program wherein lower-level &lt;b&gt;constructs&lt;/b&gt; dangle off the higher-level constructs enclosing them.</source>
          <target state="translated">プログラムの内部表現で、下位レベルの&lt;b&gt;構成要素が&lt;/b&gt;、それらを囲む上位レベルの&lt;b&gt;構成要素を&lt;/b&gt;ぶら下げます。</target>
        </trans-unit>
        <trans-unit id="ce42a8cc64b6b6a7bf11b4b312683fee15a303f0" translate="yes" xml:space="preserve">
          <source>An internal shorthand for a &amp;ldquo;push- pop&amp;rdquo; code; that is, C code implementing Perl&amp;rsquo;s stack machine.</source>
          <target state="translated">「プッシュポップ」コードの内部短縮形。つまり、Perlのスタックマシンを実装するCコードです。</target>
        </trans-unit>
        <trans-unit id="07d1d6d772129317410071c249632c5b5382b664" translate="yes" xml:space="preserve">
          <source>An internal variable used by PerlIO. A string in two parts, separated by a &lt;code&gt;\0&lt;/code&gt; byte, the first part describes the input layers, the second part describes the output layers.</source>
          <target state="translated">PerlIOによって使用される内部変数。 &lt;code&gt;\0&lt;/code&gt; バイトで区切られた2つの部分の文字列。最初の部分は入力レイヤーを説明し、2番目の部分は出力レイヤーを説明します。</target>
        </trans-unit>
        <trans-unit id="30d4f93cd3d13081a21910a8e9e9a9f2e19354af" translate="yes" xml:space="preserve">
          <source>An invalid POD command has been found. Valid are &lt;code&gt;=head1&lt;/code&gt; , &lt;code&gt;=head2&lt;/code&gt; , &lt;code&gt;=head3&lt;/code&gt; , &lt;code&gt;=head4&lt;/code&gt; , &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; , &lt;code&gt;=back&lt;/code&gt; , &lt;code&gt;=begin&lt;/code&gt; , &lt;code&gt;=end&lt;/code&gt; , &lt;code&gt;=for&lt;/code&gt; , &lt;code&gt;=pod&lt;/code&gt; , &lt;code&gt;=cut&lt;/code&gt;</source>
          <target state="translated">無効なPODコマンドが見つかりました。有効なのは &lt;code&gt;=head1&lt;/code&gt; 、 &lt;code&gt;=head2&lt;/code&gt; 、 &lt;code&gt;=head3&lt;/code&gt; 、 &lt;code&gt;=head4&lt;/code&gt; 、 &lt;code&gt;=over&lt;/code&gt; 、 &lt;code&gt;=item&lt;/code&gt; 、 &lt;code&gt;=back&lt;/code&gt; 、 &lt;code&gt;=begin&lt;/code&gt; 、 &lt;code&gt;=end&lt;/code&gt; 、 &lt;code&gt;=for&lt;/code&gt; 、 &lt;code&gt;=pod&lt;/code&gt; 、 &lt;code&gt;=cut&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8cf1c0648159d8ce5ec8b307b5ed4c7e4b2df3c9" translate="yes" xml:space="preserve">
          <source>An invalid markup command has been encountered. Valid are: &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">無効なマークアップコマンドが検出されました。有効なもの： &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee1262d5508556d2b36a24c42f3e9a2dee57cb72" translate="yes" xml:space="preserve">
          <source>An item &quot;_*&quot; is interpreted to mean &quot;all of @_ except $_[0]&quot;. I.e., &lt;code&gt;@_[1..$#_]&lt;/code&gt; . Note that this is an empty list in the case of calls like $lh-&amp;gt;maketext(</source>
          <target state="translated">アイテム「_ *」は「$ _ [0]を除くすべての@_」を意味すると解釈されます。つまり、 &lt;code&gt;@_[1..$#_]&lt;/code&gt; です。$ lh-&amp;gt; maketext（のような呼び出しの場合、これは空のリストであることに注意してください</target>
        </trans-unit>
        <trans-unit id="9af9ff7e003c973fa83a18c634e0daee75f8051b" translate="yes" xml:space="preserve">
          <source>An item that is &quot;_</source>
          <target state="translated">となっているアイテム。</target>
        </trans-unit>
        <trans-unit id="7b5f2c15e59a54bf0587db95d2a9b094a2521830" translate="yes" xml:space="preserve">
          <source>An number specifying the maximum number of fields to return. If this argument is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), split continues as long as possible.</source>
          <target state="translated">返すフィールドの最大数を指定する数値。この引数を省略した場合（または &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; の場合）、splitは可能な限り継続されます。</target>
        </trans-unit>
        <trans-unit id="eabc404e0d4e219ccc6748ea24d333aab485d543" translate="yes" xml:space="preserve">
          <source>An object belonging to a language class is called a &quot;language handle&quot;; it's typically a flyweight object.</source>
          <target state="translated">言語クラスに属するオブジェクトは「言語ハンドル」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="49f2fe3106e7ff8ff917e823e3eefb2822882e64" translate="yes" xml:space="preserve">
          <source>An object corresponding to a paragraph of POD input text. It may be a plain paragraph, a verbatim paragraph, or a command paragraph (see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;).</source>
          <target state="translated">POD入力テキストの段落に対応するオブジェクト。プレーンパラグラフ、逐語的パラグラフ、またはコマンドパラグラフ（&lt;a href=&quot;../perlpod&quot;&gt;perlpodを&lt;/a&gt;参照）のいずれかです。</target>
        </trans-unit>
        <trans-unit id="8c3786be4e01790b87960925526e572088af640f" translate="yes" xml:space="preserve">
          <source>An object corresponding to a tree of parsed POD text. Each &quot;node&quot; in a parse-tree (or</source>
          <target state="translated">解析されたPODテキストのツリーに対応するオブジェクト。パースツリー(または</target>
        </trans-unit>
        <trans-unit id="7e0998ddd63a38891699bf9ec1b0ac44c576baee" translate="yes" xml:space="preserve">
          <source>An object corresponding to an interior sequence command from the POD input text (see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;).</source>
          <target state="translated">POD入力テキストからの内部シーケンスコマンドに対応するオブジェクト（&lt;a href=&quot;../perlpod&quot;&gt;perlpodを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="9a21e67f15a49134056700786cd13ad755082aac" translate="yes" xml:space="preserve">
          <source>An object is simply a data structure that knows to which class it belongs.</source>
          <target state="translated">オブジェクトは、それがどのクラスに属しているかを知っているデータ構造体に過ぎません。</target>
        </trans-unit>
        <trans-unit id="a359cbcceea3057766a3859aec9166b89f1082b5" translate="yes" xml:space="preserve">
          <source>An object method that initializes the first and last name to its two arguments. If called as a class method, &lt;code&gt;init()&lt;/code&gt; creates an object in the given class and initializes that.</source>
          <target state="translated">姓と名を2つの引数に初期化するオブジェクトメソッド。クラスメソッドとして呼び出された場合、 &lt;code&gt;init()&lt;/code&gt; は指定されたクラスにオブジェクトを作成し、それを初期化します。</target>
        </trans-unit>
        <trans-unit id="2624824193fa16111d4b98614c9c89fd43601093" translate="yes" xml:space="preserve">
          <source>An object of a class created by the first and third forms is based on an array, whereas an object of a class created by the second form is based on a hash. The array-based forms will be somewhat faster and smaller; the hash-based forms are more flexible.</source>
          <target state="translated">第一形態と第三形態によって作成されたクラスのオブジェクトは配列に基づいていますが、第二形態によって作成されたクラスのオブジェクトはハッシュに基づいています。配列ベースのフォームは多少高速で小さくなりますが、ハッシュベースのフォームはより柔軟性があります。</target>
        </trans-unit>
        <trans-unit id="439e33121717fb8b3802d4a57550afd4a17f81f5" translate="yes" xml:space="preserve">
          <source>An object of class Archive::Tar represents a .tar(.gz) archive full of files and things.</source>
          <target state="translated">Archive::Tar クラスのオブジェクトは、ファイルや物が詰まった .tar(.gz)アーカイブを表します。</target>
        </trans-unit>
        <trans-unit id="fcd5621c0c225a91e3f7d06ac2a91fa4ab613367" translate="yes" xml:space="preserve">
          <source>An object representing a POD interior sequence command. It has the following methods/attributes:</source>
          <target state="translated">POD 内部シーケンスコマンドを表すオブジェクト。以下のメソッド/属性を持ちます。</target>
        </trans-unit>
        <trans-unit id="c24cc2e914ce53bfd778879fef27948d64904b08" translate="yes" xml:space="preserve">
          <source>An object representing a paragraph of POD input text. It has the following methods/attributes:</source>
          <target state="translated">POD入力テキストの段落を表すオブジェクト。以下のメソッド/属性を持つ。</target>
        </trans-unit>
        <trans-unit id="6fdb094e1018942aa0eb673bb8c92b50838eeb01" translate="yes" xml:space="preserve">
          <source>An object represents a single discrete thing. For example, an object might represent a file. The attributes for a file object might include its path, content, and last modification time. If we created an object to represent</source>
          <target state="translated">オブジェクトは、単一の離散的なものを表します。例えば、オブジェクトはファイルを表します。ファイル・オブジェクトの属性には、パス、内容、最終更新時刻が含まれるかもしれません。を表すオブジェクトを作成したとします。</target>
        </trans-unit>
        <trans-unit id="ca7e61e203c4b11d26a8c4d45f16575384df7da5" translate="yes" xml:space="preserve">
          <source>An object that overloads an assignment operator does so only in respect of assignments to that object. In other words, Perl never calls the corresponding methods with the third argument (the &quot;swap&quot; argument) set to TRUE. For example, the operation</source>
          <target state="translated">代入演算子をオーバーロードするオブジェクトは、そのオブジェクトへの代入に関してのみオーバーロードします。言い換えれば、Perl は第三引数 (swap 引数)を TRUE に設定して対応するメソッドを呼び出すことはありません。例えば</target>
        </trans-unit>
        <trans-unit id="5dcc2b27aa012d9c72429af38062f2b4f54986c2" translate="yes" xml:space="preserve">
          <source>An object's members cannot be made accessible as variables. The closest Perl equivalent to &lt;code&gt;with(object) { method() }&lt;/code&gt; is &lt;code&gt;for&lt;/code&gt; , which can alias &lt;code&gt;$_&lt;/code&gt; to the object:</source>
          <target state="translated">オブジェクトのメンバーを変数としてアクセス可能にすることはできません。 &lt;code&gt;with(object) { method() }&lt;/code&gt; する最も近いPerl は &lt;code&gt;for&lt;/code&gt; で、 &lt;code&gt;$_&lt;/code&gt; をオブジェクトにエイリアスできます。</target>
        </trans-unit>
        <trans-unit id="b940725a20a5223e137a3da755a048d1310c8a3b" translate="yes" xml:space="preserve">
          <source>An object, however, is a reference to blessed data, so if &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are objects then the assignment &lt;code&gt;$a = $b&lt;/code&gt; copies only the reference, leaving &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; referring to the same object data. One might therefore expect the operation &lt;code&gt;--$a&lt;/code&gt; to decrement &lt;code&gt;$b&lt;/code&gt; as well as &lt;code&gt;$a&lt;/code&gt; . However, this would not be consistent with how we expect the mathematical operators to work.</source>
          <target state="translated">ただし、オブジェクトは祝福されたデータへの参照であるため、 &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; がオブジェクトの場合、割り当て &lt;code&gt;$a = $b&lt;/code&gt; は参照のみをコピー &lt;code&gt;$a&lt;/code&gt; 、 &lt;code&gt;$b&lt;/code&gt; と$ bは同じオブジェクトデータを参照します。一つは、そのための操作を期待するかもしれない &lt;code&gt;--$a&lt;/code&gt; デクリメントする &lt;code&gt;$b&lt;/code&gt; だけでなく、 &lt;code&gt;$a&lt;/code&gt; 。ただし、これは、数学演算子が機能することを期待する方法とは一致しません。</target>
        </trans-unit>
        <trans-unit id="cee679c1ad7f71a88f44d59f19712e4063863e7e" translate="yes" xml:space="preserve">
          <source>An older style is to use a bareword as the filehandle, as</source>
          <target state="translated">古いスタイルでは、ファイルハンドルとして bareword を使用します。</target>
        </trans-unit>
        <trans-unit id="60dc562d58d05afda178b352ef3aa2e15f8841ff" translate="yes" xml:space="preserve">
          <source>An op is a fundamental operation that Perl can perform: all the built-in functions and operators are ops, and there are a series of ops which deal with concepts the interpreter needs internally - entering and leaving a block, ending a statement, fetching a variable, and so on.</source>
          <target state="translated">opはPerlが実行できる基本的な操作です。組み込みの関数や演算子はすべてopであり、インタープリタが内部的に必要とする概念を扱う一連のopがあります。</target>
        </trans-unit>
        <trans-unit id="7d7b9e438ab0eb414e5789ea7e5ffe93395e4dff" translate="yes" xml:space="preserve">
          <source>An operator with only one &lt;b&gt;operand&lt;/b&gt;, like &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;. Unary operators are usually prefix operators; that is, they precede their operand. The &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; operators can be either prefix or postfix. (Their position</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; のように、&lt;b&gt;オペランドが&lt;/b&gt; 1つだけの演算子 または &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 。単項演算子は通常、前置演算子です。つまり、オペランドの前に置かれます。 &lt;code&gt;++&lt;/code&gt; と &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; 演算子は接頭辞または接尾辞のいずれかになります。（彼らの位置</target>
        </trans-unit>
        <trans-unit id="9f9db1e29b16d48958d935e90ad14b3aea77dc3c" translate="yes" xml:space="preserve">
          <source>An opname or optag can be prefixed with an exclamation mark, e.g., !mkdir. Negating an opname or optag means remove the corresponding ops from the accumulated set of ops at that point.</source>
          <target state="translated">opname や optag の前には感嘆符を付けることができます。opname または optag を否定することは、その時点で蓄積された ops のセットから対応する ops を削除することを意味します。</target>
        </trans-unit>
        <trans-unit id="dd9db1bae968b2ebc8590123585766603b6be162" translate="yes" xml:space="preserve">
          <source>An option on a pattern or substitution, such as &lt;code&gt;/i&lt;/code&gt; to render the pattern case- insensitive.</source>
          <target state="translated">パターンの大文字小文字を区別しないようにする &lt;code&gt;/i&lt;/code&gt; などのパターンまたは置換のオプション。</target>
        </trans-unit>
        <trans-unit id="1a49163e236ca9288cd8e7003ee1066226da4567" translate="yes" xml:space="preserve">
          <source>An option you give on a command line to influence the way your program works, usually introduced with a minus sign. The word is also used as a nickname for a &lt;b&gt;switch statement&lt;/b&gt;.</source>
          <target state="translated">プログラムの動作に影響を与えるためにコマンドラインで指定するオプション。通常はマイナス記号で始まります。この単語は、&lt;b&gt;switchステートメントの&lt;/b&gt;ニックネームとしても使用されます。</target>
        </trans-unit>
        <trans-unit id="e2561efefd0f2b6e16416b85a2d7a359b74ad024" translate="yes" xml:space="preserve">
          <source>An optional feature provided by a CPAN distribution</source>
          <target state="translated">CPAN ディストリビューションで提供されるオプション機能</target>
        </trans-unit>
        <trans-unit id="9645245b8e6172ce42528bd667596edb4e44c226" translate="yes" xml:space="preserve">
          <source>An optional filehandle (or IO::Handle ) that output will be printed to.</source>
          <target state="translated">出力が出力されるオプションのファイルハンドル(または IO::Handle )。</target>
        </trans-unit>
        <trans-unit id="bcc5a81df3ac1dbb29e0b23ff110e8ac5f546061" translate="yes" xml:space="preserve">
          <source>An optional filehandle (or IO::Handle ) to which the output string will be printed.</source>
          <target state="translated">出力文字列が出力されるファイルハンドル(または IO::Handle)。</target>
        </trans-unit>
        <trans-unit id="2f9901f0f16239239419edd137f25118d48c58b4" translate="yes" xml:space="preserve">
          <source>An optional parameter can be nameless just like a mandatory parameter. For example,</source>
          <target state="translated">オプションのパラメータは、必須のパラメータと同じように無名にすることができます。例えば</target>
        </trans-unit>
        <trans-unit id="c0d6b2a0df46d7d7fb341e1412dc44bcca1bf51c" translate="yes" xml:space="preserve">
          <source>An optional part of a &lt;b&gt;subroutine&lt;/b&gt; declaration telling the Perl compiler how many and what flavor of arguments may be passed as &lt;b&gt;actual arguments&lt;/b&gt;, so you can write subroutine calls that parse much like built-in functions. (Or don&amp;rsquo;t parse, as the case may be.)</source>
          <target state="translated">&lt;b&gt;サブルーチン&lt;/b&gt;宣言のオプションの部分は、Perlコンパイラーに、&lt;b&gt;実際の引数&lt;/b&gt;として渡される引数の数と種類を伝えるため、組み込み関数のように解析されるサブルーチン呼び出しを記述できます。（または、場合によっては解析しないでください。）</target>
        </trans-unit>
        <trans-unit id="a21eb72be8656b34c88984249eec6f0bab32e544" translate="yes" xml:space="preserve">
          <source>An optional third parameter can be used to specify the buffer size used for copying. This is the number of bytes from the first file, that will be held in memory at any given time, before being written to the second file. The default buffer size depends upon the file, but will generally be the whole file (up to 2MB), or 1k for filehandles that do not reference files (eg. sockets).</source>
          <target state="translated">オプションの 3 番目のパラメータを使用して、コピーに使用するバッファサイズを指定することができます。これは、2 番目のファイルに書き込まれる前に、1 番目のファイルからメモリに保持されるバイト数です。デフォルトのバッファサイズはファイルに依存しますが、一般的にはファイル全体(2MBまで)、ファイルを参照しないファイルハンドル(ソケットなど)の場合は1kになります。</target>
        </trans-unit>
        <trans-unit id="0ba928fdaea76c696564501e58ec48f20c5c9dc1" translate="yes" xml:space="preserve">
          <source>An ordered sequence of &lt;b&gt;values&lt;/b&gt;, stored such that you can easily access any of the values using an</source>
          <target state="translated">&lt;b&gt;値&lt;/b&gt;の順序付けされたシーケンス。格納された値を使用して、任意の値に簡単にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="2b793fb04f1842403dcb9eae8e630daf85625e60" translate="yes" xml:space="preserve">
          <source>An ordered set of scalar values.</source>
          <target state="translated">スカラー値の順序付き集合。</target>
        </trans-unit>
        <trans-unit id="93d009c1cdb4335605c0d3fe2975d2046a8496a5" translate="yes" xml:space="preserve">
          <source>An overview of the Perl interpreter source code and some details on how Perl does what it does.</source>
          <target state="translated">Perl インタプリタのソースコードの概要と、Perl がどのように動作するかの詳細。</target>
        </trans-unit>
        <trans-unit id="bfd206b59d07c02456cd04b8e043a98488117f17" translate="yes" xml:space="preserve">
          <source>An overview of the Perl source tree. This will help you find the files you're looking for.</source>
          <target state="translated">Perl のソースツリーの概要です。これは、探しているファイルを見つけるのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="a982a39a2d5d6b9f37342b5e83c23e1f0856fa85" translate="yes" xml:space="preserve">
          <source>An uncaught &lt;b&gt;exception&lt;/b&gt;, which causes termination of the &lt;b&gt;process&lt;/b&gt; after printing a message on your &lt;b&gt;standard error&lt;/b&gt; stream. Errors that happen inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; are not fatal. Instead, the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; terminates after placing the exception message in the &lt;code&gt;$@&lt;/code&gt; (&lt;code&gt;$EVAL_ERROR&lt;/code&gt; ) variable. You can try to provoke a fatal error with the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; operator (known as throwing or raising an exception), but this may be caught by a dynamically enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. If not caught, the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; becomes a fatal error.</source>
          <target state="translated">&lt;b&gt;標準エラー&lt;/b&gt;ストリームにメッセージを出力した後に&lt;b&gt;プロセス&lt;/b&gt;を終了させる、キャッチされない&lt;b&gt;例外&lt;/b&gt;。 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 内部で発生するエラーは致命的ではありません。代わりに、例外メッセージを &lt;code&gt;$@&lt;/code&gt; （ &lt;code&gt;$EVAL_ERROR&lt;/code&gt; ）変数に配置した後、 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; は終了します。 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; オペレーターを使用して致命的なエラーを引き起こそうとすることもできます（例外のスローまたは発生と呼ばれます）が、動的に囲んでいる &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; によってキャッチされる場合があります。キャッチされない場合、 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; は致命的なエラーになります。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="54365bc1044b88eb77fbf7f1b4c0664f5bcb036c" translate="yes" xml:space="preserve">
          <source>An undefined value is not permitted as a record separator. Perl's special &quot;paragraph mode&quot; semantics (&amp;agrave; la &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt; ) are not emulated.</source>
          <target state="translated">未定義の値は、レコードセパレータとして使用できません。Perlの特別な「段落モード」セマンティクス（&amp;agrave; &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt; ）はエミュレートされません。</target>
        </trans-unit>
        <trans-unit id="b64166e760d6e4e08cfb550598a86717021fc931" translate="yes" xml:space="preserve">
          <source>An unnamed list of temporary scalar values that may be passed around within a program from any list-generating function to any function or construct that provides a &lt;b&gt;list context&lt;/b&gt;.</source>
          <target state="translated">プログラム内でリスト生成関数から&lt;b&gt;リストコンテキスト&lt;/b&gt;を提供する関数または構造体に渡される一時的なスカラー値の名前のないリスト。</target>
        </trans-unit>
        <trans-unit id="b7a4ac1dececd2f0138b0d9e87eae14a3bf0f323" translate="yes" xml:space="preserve">
          <source>An unordered association of &lt;b&gt;key&lt;/b&gt;/&lt;b&gt;value&lt;/b&gt; pairs, stored such that you can easily use a string &lt;b&gt;key&lt;/b&gt; to look up its associated data &lt;b&gt;value&lt;/b&gt;. This glossary is like a hash, where the word to be defined is the key and the definition is the value. A hash is also sometimes septisyllabically called an &amp;ldquo;associative array&amp;rdquo;, which is a pretty good reason for simply calling it a &amp;ldquo;hash&amp;rdquo; instead.</source>
          <target state="translated">順不同関連&lt;b&gt;のキー&lt;/b&gt; / &lt;b&gt;値&lt;/b&gt;ペア、あなたは簡単に文字列を使用できるように保存された&lt;b&gt;キーを&lt;/b&gt;その関連データのルックアップするために&lt;b&gt;値を&lt;/b&gt;。この用語集は、定義される単語がキーであり、定義が値であるハッシュのようなものです。ハッシュは、「連想配列」と改宗的に呼ばれることもあります。これは、単に「ハッシュ」と呼ぶのに十分な理由です。</target>
        </trans-unit>
        <trans-unit id="b718389bf63428a7f7a0b8e8cfc5e0574b25619d" translate="yes" xml:space="preserve">
          <source>An unset or empty PERLIO is equivalent to the default set of layers for your platform; for example, &lt;code&gt;:unix:perlio&lt;/code&gt; on Unix-like systems and &lt;code&gt;:unix:crlf&lt;/code&gt; on Windows and other DOS-like systems.</source>
          <target state="translated">未設定または空のPERLIOは、プラットフォームのデフォルトのレイヤーセットと同等です。たとえば、 &lt;code&gt;:unix:perlio&lt;/code&gt; 上のシステムとUnixライクな &lt;code&gt;:unix:crlf&lt;/code&gt; Windowsやその他のDOSのようなシステムでは。</target>
        </trans-unit>
        <trans-unit id="1b2099e63b3baac079849a311cb94bc9726d2b6a" translate="yes" xml:space="preserve">
          <source>An unsigned byte.</source>
          <target state="translated">符号なしバイト。</target>
        </trans-unit>
        <trans-unit id="17f8abaddabc70c518443c4340875b6f3d1f87f6" translate="yes" xml:space="preserve">
          <source>An unsigned integer.</source>
          <target state="translated">符号なし整数。</target>
        </trans-unit>
        <trans-unit id="6dc9fd633e86a9f8c5100a5a45701b6dac466c39" translate="yes" xml:space="preserve">
          <source>An upgrade to the PA-RISC design, it shipped for many years in many different system.</source>
          <target state="translated">PA-RISCデザインへのアップグレードで、多くの異なるシステムで何年もの間出荷されました。</target>
        </trans-unit>
        <trans-unit id="abd7bedc3ca5ffad7ed1a2379448571632c9a196" translate="yes" xml:space="preserve">
          <source>Analogously to &lt;code&gt;pTHX&lt;/code&gt; , there are equivalent forms for when the macro is the first or last in multiple arguments, where an underscore represents a comma, i.e. &lt;code&gt;_aMY_CXT&lt;/code&gt; , &lt;code&gt;aMY_CXT_&lt;/code&gt; , &lt;code&gt;_pMY_CXT&lt;/code&gt; and &lt;code&gt;pMY_CXT_&lt;/code&gt; .</source>
          <target state="translated">同様に &lt;code&gt;pTHX&lt;/code&gt; 、マクロは、最初または最後の複数の引数で、下線がカンマを表し、すなわちである場合の等価形態がある &lt;code&gt;_aMY_CXT&lt;/code&gt; 、 &lt;code&gt;aMY_CXT_&lt;/code&gt; 、 &lt;code&gt;_pMY_CXT&lt;/code&gt; と &lt;code&gt;pMY_CXT_&lt;/code&gt; は。</target>
        </trans-unit>
        <trans-unit id="edf45b9159d8cf5fded0f359396c02baabcce4fe" translate="yes" xml:space="preserve">
          <source>Analyses the string in order to make fast searches on it using fbm_instr() -- the Boyer-Moore algorithm.</source>
          <target state="translated">fbm_instr()--Boyer-Moore アルゴリズムを使用して高速に検索するために文字列を解析します。</target>
        </trans-unit>
        <trans-unit id="b23a158b83cb28ac3361aeaadb0ea701f833add8" translate="yes" xml:space="preserve">
          <source>Anantha Kesari H Y (hyanantha@novell.com) Aditya C (caditya@novell.com)</source>
          <target state="translated">Anantha Kesari H Y (hyanantha@novell.com)Aditya C (caditya@novell.com)</target>
        </trans-unit>
        <trans-unit id="e7694709c56de3564de85fb7f6b62bf3f9d5a2dd" translate="yes" xml:space="preserve">
          <source>Anatomy of .xs file</source>
          <target state="translated">.xsファイルの解剖学</target>
        </trans-unit>
        <trans-unit id="c371090fde9f09dd68fd0c025b019139f11c3b43" translate="yes" xml:space="preserve">
          <source>Anatomy of a typemap</source>
          <target state="translated">タイプマップの構造</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="56126a3ba8ff8d615bfc883458ff2ad74c4445f8" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; supports odd bit counts:</source>
          <target state="translated">また、&lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt;は奇数のビット数をサポートしています。</target>
        </trans-unit>
        <trans-unit id="0fdb46cc394058268f8370b027acd6f7507ad5af" translate="yes" xml:space="preserve">
          <source>And a print to show what values we're currently using:</source>
          <target state="translated">そして、現在使用している値を示すプリント。</target>
        </trans-unit>
        <trans-unit id="3e6cfdab3639e924ccc0236d51702eea17278fbe" translate="yes" xml:space="preserve">
          <source>And add the following code to Mytest.t, while incrementing the &quot;11&quot; tests to &quot;13&quot;:</source>
          <target state="translated">そして、「11」のテストを「13」にインクリメントしながら、以下のコードをMytest.tに追加します。</target>
        </trans-unit>
        <trans-unit id="7e934152fc5094b95aee4b1e3cfca4dfe3b716a5" translate="yes" xml:space="preserve">
          <source>And also add the following function definition to the end of the .xs file:</source>
          <target state="translated">また、.xsファイルの最後に以下の関数定義を追加します。</target>
        </trans-unit>
        <trans-unit id="e095a5f2bc9f3ebef8eb601baecde5aacc183619" translate="yes" xml:space="preserve">
          <source>And an even parity bit can be determined like this:</source>
          <target state="translated">そして、偶数パリティビットは、このように決定することができます。</target>
        </trans-unit>
        <trans-unit id="fa65fe1d258f3efe5fa4b14f6a4bdf869e0bca12" translate="yes" xml:space="preserve">
          <source>And don't forget, all commands but &lt;code&gt;=encoding&lt;/code&gt; last up until the end of its</source>
          <target state="translated">そして忘れないでください、 &lt;code&gt;=encoding&lt;/code&gt; を除くすべてのコマンドは、その最後まで続きます</target>
        </trans-unit>
        <trans-unit id="d49f8a3fb63a02de3bc96673eb479046741fcd21" translate="yes" xml:space="preserve">
          <source>And elsewhere:</source>
          <target state="translated">他の場所でも</target>
        </trans-unit>
        <trans-unit id="0d86ebfaa42125fcbf7621caf9b51d0d516488b0" translate="yes" xml:space="preserve">
          <source>And even if you take all the above into account, ANSI still lets this:</source>
          <target state="translated">そして、あなたが上記のすべてを考慮に入れても、ANSIはまだこれを許可します。</target>
        </trans-unit>
        <trans-unit id="7a24c6f39dbf571ec01b5431e8552ecca7394253" translate="yes" xml:space="preserve">
          <source>And finally create a file Makefile.PL that looks like this:</source>
          <target state="translated">そして最後にこのようなMakefile.PLというファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="ae77b129ec8a4042483f52a6f594546db002727e" translate="yes" xml:space="preserve">
          <source>And finally we'll test that we don't make Unicode strings if &lt;code&gt;U&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; the first active format:</source>
          <target state="translated">最後に、 &lt;code&gt;U&lt;/code&gt; が最初のアクティブな形式で&lt;b&gt;ない&lt;/b&gt;場合は、Unicode文字列を作成しないことをテストします。</target>
        </trans-unit>
        <trans-unit id="a3e1249d44e165c645bd656a34581eba0f8a1e5b" translate="yes" xml:space="preserve">
          <source>And finally, END OF CHARMAP ends the section.</source>
          <target state="translated">そして最後にEND OF CHARMAPでセクションが終了します。</target>
        </trans-unit>
        <trans-unit id="0fa08a28d9fbfd1e04544d3cbe387157894102ef" translate="yes" xml:space="preserve">
          <source>And finally, the &lt;code&gt;//&lt;/code&gt; default delimiters for a match can be changed to arbitrary delimiters by putting an &lt;code&gt;'m'&lt;/code&gt; out front:</source>
          <target state="translated">そして最後に、 &lt;code&gt;//&lt;/code&gt; マッチのデフォルトの区切り文字は、 &lt;code&gt;'m'&lt;/code&gt; を前に置くことで任意の区切り文字に変更できます。</target>
        </trans-unit>
        <trans-unit id="8bfb479933b19ce9cc3cdcd7ea52e1ab56622323" translate="yes" xml:space="preserve">
          <source>And finally, the flag UNICODE_WARN_ILLEGAL_INTERCHANGE selects all four of the above WARN flags; and UNICODE_DISALLOW_ILLEGAL_INTERCHANGE selects all four DISALLOW flags.</source>
          <target state="translated">そして最後に、UNICODE_WARN_ILLEGAL_INTERCHANGEフラグは、上記のWARNフラグの4つすべてを選択し、UNICODE_DISALLOW_ILLEGAL_INTERCHANGEフラグは、4つのDISALLOWフラグのすべてを選択する。</target>
        </trans-unit>
        <trans-unit id="805a895ac4ae294cb6372936f60badec42431ba0" translate="yes" xml:space="preserve">
          <source>And get the correct results.</source>
          <target state="translated">そして、正しい結果を得る。</target>
        </trans-unit>
        <trans-unit id="e2f2205f3663f3c210b60bce452eee7ce9387b44" translate="yes" xml:space="preserve">
          <source>And have a look at the return value:</source>
          <target state="translated">そして、戻り値を見てみてください。</target>
        </trans-unit>
        <trans-unit id="fbc4c3241647a832011ec07f9650e675a0c500ca" translate="yes" xml:space="preserve">
          <source>And here are some alternative portable ways to write them:</source>
          <target state="translated">そして、ここでは、それらを書くための代替のポータブルな方法をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="dd7d82addca3d88c7a2654bf3c9e6dcef14475a8" translate="yes" xml:space="preserve">
          <source>And here is an example of</source>
          <target state="translated">そして、ここではその一例として</target>
        </trans-unit>
        <trans-unit id="d607f0d907db7da1691c33f97b8d6b2f2769c71d" translate="yes" xml:space="preserve">
          <source>And here is some Perl to test it.</source>
          <target state="translated">そして、それをテストするためのPerlがここにあります。</target>
        </trans-unit>
        <trans-unit id="97a015e04d33b93191e1790b436d13c5a1d0ec08" translate="yes" xml:space="preserve">
          <source>And here is the previous example modified to use the &lt;code&gt;comment&lt;/code&gt; method (which requires the tied object):</source>
          <target state="translated">そして、これは &lt;code&gt;comment&lt;/code&gt; メソッドを使用するように変更された前の例です（タイドオブジェクトが必要です）。</target>
        </trans-unit>
        <trans-unit id="949c884471ed5b1d107f6efb48c3d4a2b28f9c98" translate="yes" xml:space="preserve">
          <source>And here it is as a subroutine, modeled after the above:</source>
          <target state="translated">そして、ここでは、上記をモデルにしたサブルーチンです。</target>
        </trans-unit>
        <trans-unit id="33110031311636694f867a410fcd13fa8bb80c0c" translate="yes" xml:space="preserve">
          <source>And here's a corresponding server to go along with it. We'll leave the address as &lt;code&gt;INADDR_ANY&lt;/code&gt; so that the kernel can choose the appropriate interface on multihomed hosts. If you want sit on a particular interface (like the external side of a gateway or firewall machine), fill this in with your real address instead.</source>
          <target state="translated">そして、それに対応するサーバーがここにあります。カーネルがマルチホームホスト上の適切なインターフェイスを選択できるように、アドレスを &lt;code&gt;INADDR_ANY&lt;/code&gt; のままにします。特定のインターフェース（ゲートウェイやファイアウォールマシンの外部側など）を使用する場合は、代わりに実際のアドレスを入力します。</target>
        </trans-unit>
        <trans-unit id="dbd6a4af2108db6ae982ecf10d7522ed7e526a16" translate="yes" xml:space="preserve">
          <source>And here's a corresponding server. You don't have to worry about silly network terminators here because Unix domain sockets are guaranteed to be on the localhost, and thus everything works right.</source>
          <target state="translated">そして、これが対応するサーバです。Unix ドメインソケットはローカルホスト上にあることが保証されているので、 ここでは愚かなネットワークターミネータを心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="944b5652f25ab675361c7efd6d5681a5765fc752" translate="yes" xml:space="preserve">
          <source>And here's a multitasking version. It's multitasked in that like most typical servers, it spawns (fork()s) a slave server to handle the client request so that the master server can quickly go back to service a new client.</source>
          <target state="translated">そして、これはマルチタスク版です。これはマルチタスク版で、ほとんどの典型的なサーバと同様に、クライアントのリクエストを処理するためにスレーブサーバを生成 (fork()します)し、マスターサーバがすぐに新しいクライアントにサービスを提供できるようにしています。</target>
        </trans-unit>
        <trans-unit id="412d21e904b4a5d9be299f9e46dd7d8fb8650015" translate="yes" xml:space="preserve">
          <source>And here's a reimplementation of the Perl &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; operator:</source>
          <target state="translated">そして、Perl &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; オペレーターの再実装を以下に示します。</target>
        </trans-unit>
        <trans-unit id="a39e0321aadc55f074a271968aaa41d7162f8c6f" translate="yes" xml:space="preserve">
          <source>And here's a safe pipe open for writing:</source>
          <target state="translated">そして、ここには書き込み用の安全なパイプが開いています。</target>
        </trans-unit>
        <trans-unit id="e0737e576532a52571f2f02f804f1b9fffb668de" translate="yes" xml:space="preserve">
          <source>And here's how it could be (ab)used:</source>
          <target state="translated">そして、このような使い方ができます。</target>
        </trans-unit>
        <trans-unit id="9d8d64c2d75cb873a59d78e68255422a53fcc02a" translate="yes" xml:space="preserve">
          <source>And here's how to start up a child process you intend to read from:</source>
          <target state="translated">そして、ここから読み解くつもりの子プロセスの立ち上げ方。</target>
        </trans-unit>
        <trans-unit id="4c941c96c3f11d53f1f07f2e00498b7a8046f1f0" translate="yes" xml:space="preserve">
          <source>And here's the &lt;code&gt;HotKey&lt;/code&gt; module, which hides the somewhat mystifying calls to manipulate the POSIX termios structures.</source>
          <target state="translated">そして、ここには &lt;code&gt;HotKey&lt;/code&gt; モジュールがあります。これは、POSIX termios構造を操作するためのやや不可解な呼び出しを隠します。</target>
        </trans-unit>
        <trans-unit id="c1de37a9a564348e268bb7765797260079df1212" translate="yes" xml:space="preserve">
          <source>And if it's an integer</source>
          <target state="translated">そして、整数であれば</target>
        </trans-unit>
        <trans-unit id="1e83d880ce4037fe2787ac7496582407c6b33838" translate="yes" xml:space="preserve">
          <source>And if the protocol you're using supports a way of letting the recipient know which character encoding you used, please help the receiving end by using that feature! For example, E-mail and HTTP support MIME headers, so you can use the &lt;code&gt;Content-Type&lt;/code&gt; header. They can also have &lt;code&gt;Content-Length&lt;/code&gt; to indicate the number of</source>
          <target state="translated">また、使用しているプロトコルが、使用した文字エンコーディングを受信者に知らせる方法をサポートしている場合は、その機能を使用して受信側を支援してください！たとえば、電子メールとHTTPはMIMEヘッダーをサポートしているため、 &lt;code&gt;Content-Type&lt;/code&gt; ヘッダーを使用できます。また、 &lt;code&gt;Content-Length&lt;/code&gt; を使用して、</target>
        </trans-unit>
        <trans-unit id="530bb41f401dd9a37c76bab8cac0844cf9ab82e0" translate="yes" xml:space="preserve">
          <source>And if you used &lt;code&gt;*&lt;/code&gt; 's in the internal groups instead of limiting them to 0 through 5 matches, then it would take forever--or until you ran out of stack space. Moreover, these internal optimizations are not always applicable. For example, if you put &lt;code&gt;{0,5}&lt;/code&gt; instead of &lt;code&gt;*&lt;/code&gt; on the external group, no current optimization is applicable, and the match takes a long time to finish.</source>
          <target state="translated">また、内部グループで &lt;code&gt;*&lt;/code&gt; を使用して0から5の一致に制限するのではなく、永久に、またはスタックスペースが不足するまでかかります。さらに、これらの内部最適化は常に適用できるとは限りません。たとえば、外部グループに &lt;code&gt;*&lt;/code&gt; の代わりに &lt;code&gt;{0,5}&lt;/code&gt; を指定すると、現在の最適化は適用されず、一致が完了するまでに長い時間がかかります。</target>
        </trans-unit>
        <trans-unit id="85fb030d5b378f589d8d5a1abf4a0effa17a51ec" translate="yes" xml:space="preserve">
          <source>And if you want to repeat any previous command, use the exclamation: '&lt;b&gt;!&lt;/b&gt;':</source>
          <target state="translated">また、前のコマンドを繰り返す場合は、感嘆符を使用します&lt;b&gt;。&lt;/b&gt;'：</target>
        </trans-unit>
        <trans-unit id="81ee0ae161979dc9986599ac47ae17f4297a5e95" translate="yes" xml:space="preserve">
          <source>And if you wanted to list line 5 again, type 'l 5', (note the space):</source>
          <target state="translated">そして、5行目をもう一度リストアップしたい場合は、'l 5'と入力します(スペースに注意)。</target>
        </trans-unit>
        <trans-unit id="749d2869c6a2cd1160d264bfc5684c9df865e407" translate="yes" xml:space="preserve">
          <source>And if you're not writing a formatter class, but are instead just writing a program that does something simple with a Pod::PullParser object (and not an object of a subclass), then there's no reason to bother subclassing to add a &lt;code&gt;run&lt;/code&gt; method.</source>
          <target state="translated">また、フォーマッタークラスを作成せずに、Pod :: PullParserオブジェクト（サブクラスのオブジェクトではない）で単純な処理を行うプログラムを作成している場合は、サブクラスを作成して &lt;code&gt;run&lt;/code&gt; を追加する必要はありません。方法。</target>
        </trans-unit>
        <trans-unit id="a90e884faa57a601f440de65c751d0540510d763" translate="yes" xml:space="preserve">
          <source>And in gdb do:</source>
          <target state="translated">そして、gdbでは。</target>
        </trans-unit>
        <trans-unit id="81cf331b9c5b31a88becd7901f7891213a4ee929" translate="yes" xml:space="preserve">
          <source>And in gdb:</source>
          <target state="translated">そしてgdbで。</target>
        </trans-unit>
        <trans-unit id="46441ba6d0d6e8d0a7cff3ad4e65de9157fcaa3a" translate="yes" xml:space="preserve">
          <source>And in the special case of Unix value 1 the encoding is:</source>
          <target state="translated">そして、Unix の値 1 の特殊なケースでは、エンコーディングは次のようになります。</target>
        </trans-unit>
        <trans-unit id="c703bcbb84cf0b00ade16c5fcf17098b7ecf2788" translate="yes" xml:space="preserve">
          <source>And it worked; nowadays, those legacy standards are rarely used. Most everyone uses Unicode.</source>
          <target state="translated">それが功を奏して、現在では、これらのレガシーな標準はほとんど使われていません。ほとんどの人がユニコードを使っています。</target>
        </trans-unit>
        <trans-unit id="54037314563b22510a39098497cd62d4a291d5ca" translate="yes" xml:space="preserve">
          <source>And it'll be faster, too, since we can begin processing the program's stdout immediately, rather than waiting for the program to finish.</source>
          <target state="translated">そして、プログラムの終了を待つよりも、すぐにプログラムの標準出力の処理を始めることができるので、こちらも早くなります。</target>
        </trans-unit>
        <trans-unit id="05b8d44f52c6cb1137bdef7406a03b86305390f3" translate="yes" xml:space="preserve">
          <source>And just before we start the loop, we'll set &lt;code&gt;patcopy&lt;/code&gt; to be the start of &lt;code&gt;pat&lt;/code&gt; :</source>
          <target state="translated">ループを開始する直前に、 &lt;code&gt;patcopy&lt;/code&gt; を &lt;code&gt;pat&lt;/code&gt; の開始に設定します。</target>
        </trans-unit>
        <trans-unit id="5d9997bbf1b12f8dbc675ed04e53a7e01c218a79" translate="yes" xml:space="preserve">
          <source>And just use a multilevel hash to start with.</source>
          <target state="translated">そもそもマルチレベルハッシュを使えばいいんだよ</target>
        </trans-unit>
        <trans-unit id="6f762806ee86000a08af1e9120bb69dbd27df3b8" translate="yes" xml:space="preserve">
          <source>And let's have a look at it:</source>
          <target state="translated">そして、それを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="3304a768e2182435437e989432d9119802e93fc2" translate="yes" xml:space="preserve">
          <source>And locally for months:</source>
          <target state="translated">そして地元では数ヶ月間。</target>
        </trans-unit>
        <trans-unit id="a3a5e5aaccae80b6482e3c73484c3e27d16e3695" translate="yes" xml:space="preserve">
          <source>And make sure the '|1' or '|3' entry FOLLOWS the '|0' entry.</source>
          <target state="translated">また、'|1'または'|3'の項目が'|0'の項目に続いていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="13b0bb554f54abc8fbffc8c8994d2d663c4a335c" translate="yes" xml:space="preserve">
          <source>And make the &lt;code&gt;SHELL&lt;/code&gt; environment variable point to this</source>
          <target state="translated">そして、 &lt;code&gt;SHELL&lt;/code&gt; 環境変数がこれを指すようにします</target>
        </trans-unit>
        <trans-unit id="be7020a4d943fe59e561bee80058c6fdc65ab9a2" translate="yes" xml:space="preserve">
          <source>And more miscellaneous functions:</source>
          <target state="translated">さらに雑多な機能も。</target>
        </trans-unit>
        <trans-unit id="d2abac4d1c06c7d4176cadc5fbb88490348f44bd" translate="yes" xml:space="preserve">
          <source>And now some examples as a list operator:</source>
          <target state="translated">そして、リスト演算子としての例をいくつか挙げてみました。</target>
        </trans-unit>
        <trans-unit id="325f253298d4946260db0eee17abb5d004c58cf0" translate="yes" xml:space="preserve">
          <source>And now the Perl program calling &lt;code&gt;tzname&lt;/code&gt; , the two values will be assigned as in:</source>
          <target state="translated">そして今、Perlプログラムが &lt;code&gt;tzname&lt;/code&gt; を呼び出すと、2つの値が次のように割り当てられます。</target>
        </trans-unit>
        <trans-unit id="22d6d0f0cc9d0f09a7a155f9b933e949a3d93b8d" translate="yes" xml:space="preserve">
          <source>And now when we run it, we get &quot;\n&quot; still, but at least we know why. Just getting this script to compile has exposed the '$varl' (with the letter 'l') variable, and simply changing $varl to $var1 solves the problem.</source>
          <target state="translated">そして、実行すると、まだ &quot;\n&quot; が出てきますが、少なくとも理由はわかっています。このスクリプトをコンパイルするだけで、変数 '$varl'('l' の文字が入っている)が公開されてしまい、$varl を $var1 に変更するだけで問題が解決します。</target>
        </trans-unit>
        <trans-unit id="5ed144a58c9fd20df52c8636158ebb39098e1299" translate="yes" xml:space="preserve">
          <source>And now whenever either of those variables is accessed, its current system priority is retrieved and returned. If those variables are set, then the process's priority is changed!</source>
          <target state="translated">そして、これらの変数のいずれかがアクセスされたときはいつでも、その現在のシステムの優先度が取得されて返されます。これらの変数が設定されている場合、プロセスの優先度が変更されます!</target>
        </trans-unit>
        <trans-unit id="f9560789fd59b77ec60e56d7ede2c768c8b84e1a" translate="yes" xml:space="preserve">
          <source>And now you will only have duplicates when the keys themselves are truly the same. (note: in versions of the db library prior to about November 1996, such duplicate keys were retained so it was possible to recover the original keys in sets of keys that compared as equal).</source>
          <target state="translated">これで、キー自体が本当に同じである場合にのみ、複製を作成することができるようになりました。(注:1996年11月以前のバージョンのdbライブラリでは、このような重複したキーは保持されていたので、同じように比較されたキーのセットで元のキーを復元することが可能でした。)</target>
        </trans-unit>
        <trans-unit id="5a5750ab899553015c34706ef7f35d79aa761c9c" translate="yes" xml:space="preserve">
          <source>And of course a very basic test:</source>
          <target state="translated">もちろん基礎的なテストも</target>
        </trans-unit>
        <trans-unit id="892ba36b3022eacc3edbb4c21af99c36c593d715" translate="yes" xml:space="preserve">
          <source>And on the off chance you need a literal tilde in a bracket expression, you get it with &quot;~~&quot;.</source>
          <target state="translated">また、大括弧表現の中でリテラルチルダが必要な場合は、&quot;~~&quot;を使用します。</target>
        </trans-unit>
        <trans-unit id="7c31eaf7ebf6ce5c72185594ad0e1b74e04b6fe1" translate="yes" xml:space="preserve">
          <source>And only on Solaris 8 you also need:</source>
          <target state="translated">また、Solaris 8 でのみ必要となります。</target>
        </trans-unit>
        <trans-unit id="15fba9c4eb39007661b94becfb32901d56aa6cd3" translate="yes" xml:space="preserve">
          <source>And only the last two of these match:</source>
          <target state="translated">そして、この中で最後の2つだけがマッチしています。</target>
        </trans-unit>
        <trans-unit id="96df95971f3fa6b1c473a349d8884984b667322b" translate="yes" xml:space="preserve">
          <source>And other assignment variations are analogous to &lt;code&gt;'+='&lt;/code&gt; and &lt;code&gt;'-='&lt;/code&gt; (and similar to &lt;code&gt;'.='&lt;/code&gt; and &lt;code&gt;'x='&lt;/code&gt; above):</source>
          <target state="translated">その他の割り当てのバリエーションは、 &lt;code&gt;'+='&lt;/code&gt; および &lt;code&gt;'-='&lt;/code&gt; 類似しています（上記の &lt;code&gt;'.='&lt;/code&gt; および &lt;code&gt;'x='&lt;/code&gt; 類似しています）。</target>
        </trans-unit>
        <trans-unit id="efa161d50be827f153878be8fe5d6eeddd3f9aab" translate="yes" xml:space="preserve">
          <source>And perhaps most importantly, keep the items consistent: either use &quot;=item *&quot; for all of them, to produce bullets; or use &quot;=item 1.&quot;, &quot;=item 2.&quot;, etc., to produce numbered lists; or use &quot;=item foo&quot;, &quot;=item bar&quot;, etc.--namely, things that look nothing like bullets or numbers.</source>
          <target state="translated">そしておそらく最も重要なことは、項目を一貫性のあるものに保つことです:弾丸を生成するために、それらのすべてに&quot;=item *&quot;を使用するか、または番号付きリストを生成するために&quot;=item 1.&quot;,&quot;=item 2.&quot;,などを使用します。</target>
        </trans-unit>
        <trans-unit id="f91e4f8b7302927647ddce5513c00f7d31bca99b" translate="yes" xml:space="preserve">
          <source>And since we're on that subject ...</source>
          <target state="translated">そして、私たちは、その話題をしているので...</target>
        </trans-unit>
        <trans-unit id="787438686ae95a1032fa3a9e1aa177c6c4fd8565" translate="yes" xml:space="preserve">
          <source>And so do these:</source>
          <target state="translated">これもそうだ</target>
        </trans-unit>
        <trans-unit id="58a765d6600ae95d5f3b4bad120d6d7aba62ac6d" translate="yes" xml:space="preserve">
          <source>And success is always the value 0 in all behaviors.</source>
          <target state="translated">そして、成功はすべての行動において常に値0である。</target>
        </trans-unit>
        <trans-unit id="438bed71f720bad1480f9f02fbee09a0688495fa" translate="yes" xml:space="preserve">
          <source>And suppose then that you answer client requests for language $wanted by just looking up $greetings{$wanted}.</source>
          <target state="translated">そして、$wanted言語に対するクライアントからのリクエストに、 $greetings{$wanted}を検索するだけで答えられるとします。</target>
        </trans-unit>
        <trans-unit id="2669b5893403010caa914594080405bbbce0ff5c" translate="yes" xml:space="preserve">
          <source>And suppose you write a program that reads that file and then runs as a daemon, answering client requests that specify a language tag and then expect the string that says how to greet in that language. So an interaction looks like:</source>
          <target state="translated">そして、そのファイルを読み込んでデーモンとして実行するプログラムを書いたとしましょう。言語タグを指定したクライアントからのリクエストに答え、その言語での挨拶の仕方を示す文字列を期待します。インタラクションは次のようになります。</target>
        </trans-unit>
        <trans-unit id="2df99fba715f8ad036f73439b0d1c572a25bb0d8" translate="yes" xml:space="preserve">
          <source>And that does the Right Thing.</source>
          <target state="translated">それが正しいことだ</target>
        </trans-unit>
        <trans-unit id="f185ef04d67f1d1642dde1d5aaeb827268181df4" translate="yes" xml:space="preserve">
          <source>And that's where the first quirk strikes: &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; templates have to be stuffed with &lt;code&gt;x&lt;/code&gt; codes to get those extra fill bytes.</source>
          <target state="translated">そして、それが最初の奇妙なところです： &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; テンプレートは、それらの余分なフィルバイトを取得するために &lt;code&gt;x&lt;/code&gt; コードを詰め込む必要があります。</target>
        </trans-unit>
        <trans-unit id="69c7d2fddd9456e1d45eb87fbe318da0c23d0419" translate="yes" xml:space="preserve">
          <source>And the removal of:</source>
          <target state="translated">撤去も</target>
        </trans-unit>
        <trans-unit id="6321b918eecf63aae95252ec27d4a4007661cbea" translate="yes" xml:space="preserve">
          <source>And then at least you can use the values(), which will be real refs, instead of the keys(), which won't.</source>
          <target state="translated">そうすれば、少なくとも実際の参照となる values()を使うことができるようになります。</target>
        </trans-unit>
        <trans-unit id="4c721f20845157aa106a3ca5329f5d50475f12f2" translate="yes" xml:space="preserve">
          <source>And then hard-code it, leaving porting as an exercise to your successor.</source>
          <target state="translated">そして、ハードコード化して、移植は後継者に任せる。</target>
        </trans-unit>
        <trans-unit id="47e6e2e5fec5f13213aa3c81c38b973ca1f59e41" translate="yes" xml:space="preserve">
          <source>And then instead of storing the compiled value in the lexicon hash it will store it in $lh-&amp;gt;{'_external_lex_cache'}</source>
          <target state="translated">そして、コンパイルされた値をレキシコンハッシュに保存する代わりに、$ lh-&amp;gt; {'_ external_lex_cache'}に保存します</target>
        </trans-unit>
        <trans-unit id="4ddb0364527af5ee5b5762f819c0ea16f6ac0a17" translate="yes" xml:space="preserve">
          <source>And then open as before, choosing &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; , or &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; as needed:</source>
          <target state="translated">次に、以前と同様に開き、必要に応じて &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; を選択します。</target>
        </trans-unit>
        <trans-unit id="733e92d2677896a5105fc9334a5547dcbabc4286" translate="yes" xml:space="preserve">
          <source>And then provide a typemap entry &lt;code&gt;T_PTROBJ_SPECIAL&lt;/code&gt; that maps underscores to double-colons (::), and declare &lt;code&gt;Net_Config&lt;/code&gt; to be of that type:</source>
          <target state="translated">次に、アンダースコアをダブルコロン（：:)にマップする &lt;code&gt;T_PTROBJ_SPECIAL&lt;/code&gt; マップエントリT_PTROBJ_SPECIALを提供し、 &lt;code&gt;Net_Config&lt;/code&gt; をそのタイプであると宣言します。</target>
        </trans-unit>
        <trans-unit id="0b78c6f57eb325a818fb40b5bb64b41ae51db883" translate="yes" xml:space="preserve">
          <source>And then replace the hash name with the reference:</source>
          <target state="translated">そして、ハッシュ名を参照先に置き換えます。</target>
        </trans-unit>
        <trans-unit id="1482b41f1c8c23a1b6f51e392e8562858f488f4e" translate="yes" xml:space="preserve">
          <source>And then set PERL5LIB to</source>
          <target state="translated">そして、PERL5LIB を</target>
        </trans-unit>
        <trans-unit id="e66399c5da24330a870822849d8e76cf4cddfe41" translate="yes" xml:space="preserve">
          <source>And then step until you hit what you're looking for. This works well in a loop if you want to only break at certain iterations:</source>
          <target state="translated">そして、あなたが探しているものを見つけるまでステップします。これは、特定の反復でのみブレークしたい場合には、ループの中でうまく機能します。</target>
        </trans-unit>
        <trans-unit id="4fa5c1cdc4927fc4a1301e4902474775669ad62e" translate="yes" xml:space="preserve">
          <source>And these conditions hold</source>
          <target state="translated">そして、これらの条件は</target>
        </trans-unit>
        <trans-unit id="d5d9b0ee41acfcea7375d0a36877f181aee3c098" translate="yes" xml:space="preserve">
          <source>And they all mean exactly the same as this:</source>
          <target state="translated">そして、どれもこれと全く同じ意味になります。</target>
        </trans-unit>
        <trans-unit id="8536c300c45ef5952d0313ea8b714a35911f6d2e" translate="yes" xml:space="preserve">
          <source>And this example uses anonymous subroutines to create separate counters:</source>
          <target state="translated">そして、この例では匿名のサブルーチンを使用して個別のカウンタを作成しています。</target>
        </trans-unit>
        <trans-unit id="2e09b2a3ab0575b70e3e084aed68993db1ebce78" translate="yes" xml:space="preserve">
          <source>And this is the XS code:</source>
          <target state="translated">そして、これがXSのコードです。</target>
        </trans-unit>
        <trans-unit id="1e0a495178fdf07510ea88975dd8d193311ceae6" translate="yes" xml:space="preserve">
          <source>And this is what the script above will print:</source>
          <target state="translated">そして、上のスクリプトで印刷されるのはこれです。</target>
        </trans-unit>
        <trans-unit id="35194f4922bc124f887493e5a4a0600918a32f35" translate="yes" xml:space="preserve">
          <source>And this isn't the whole story. Starting in Perl v5.12, strings that aren't encoded in UTF-8 may also be treated as Unicode under various conditions (see &lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII Rules versus Unicode Rules in perlunicode&lt;/a&gt;). This is only really a problem for characters whose ordinals are between 128 and 255, and their behavior varies under ASCII versus Unicode rules in ways that your code cares about (see &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug in perlunicode&lt;/a&gt;). There is no published API for dealing with this, as it is subject to change, but you can look at the code for &lt;code&gt;pp_lc&lt;/code&gt; in</source>
          <target state="translated">そして、これはすべての話ではありません。Perl v5.12以降では、UTF-8でエンコードされていない文字列も、さまざまな条件下でUnicodeとして扱われる可能性があります（&lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;perlunicodeのASCII規則とUnicode規則を参照&lt;/a&gt;）。これは実際には、序数が128から255の文字にのみ問題であり、ASCIIルールとUnicodeルールでは、コード&lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;が考慮&lt;/a&gt;している方法で動作が異なります（perlunicodeのUnicodeバグを参照）。これは変更される可能性があるため、これを処理するための公開されたAPIはありませんが、 &lt;code&gt;pp_lc&lt;/code&gt; のコードは</target>
        </trans-unit>
        <trans-unit id="04dc4562232363a5a2cdcef5ad0c57a632cc4d72" translate="yes" xml:space="preserve">
          <source>And this one reads from the child:</source>
          <target state="translated">そしてこちらは子供からの読み聞かせ。</target>
        </trans-unit>
        <trans-unit id="22fab1b1ab24735dd2f54767a6ec2977de574611" translate="yes" xml:space="preserve">
          <source>And this too is valid:</source>
          <target state="translated">そして、これも有効です。</target>
        </trans-unit>
        <trans-unit id="ca100b799213c6d95d191edf790bdf80dab3cf7a" translate="yes" xml:space="preserve">
          <source>And this:</source>
          <target state="translated">そして、これ。</target>
        </trans-unit>
        <trans-unit id="ca54ab72a0f62623ded9fadca0c4ae598b7f81fe" translate="yes" xml:space="preserve">
          <source>And to check the sequence in which the library directories are searched by perl, run</source>
          <target state="translated">また、ライブラリディレクトリがPerlによって検索される順序を確認するには、次のように実行します。</target>
        </trans-unit>
        <trans-unit id="362fec7b951a6425bfa81311e580eeb12dfb603d" translate="yes" xml:space="preserve">
          <source>And to desurrogate;</source>
          <target state="translated">そして、代位継承権を放棄する。</target>
        </trans-unit>
        <trans-unit id="2615ff8743f40d3114fe04e3d5a96ce87c8f4c9d" translate="yes" xml:space="preserve">
          <source>And try again:</source>
          <target state="translated">そして、もう一度やってみてください。</target>
        </trans-unit>
        <trans-unit id="92794ee0d6f5c6f795ca92dffa6111092171b2bc" translate="yes" xml:space="preserve">
          <source>And we end up with the program:</source>
          <target state="translated">そして、最後はプログラムで終わります。</target>
        </trans-unit>
        <trans-unit id="397d92a7cd41c0dad432b26c8f27299cae1c6b41" translate="yes" xml:space="preserve">
          <source>And with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding &quot;euc-jp&quot;&lt;/code&gt; in effect, it is the same thing as that code in UTF-8:</source>
          <target state="translated">そして、実際には &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding &quot;euc-jp&quot;&lt;/code&gt; で、それはUTF-8でのそのコードと同じものです：</target>
        </trans-unit>
        <trans-unit id="e0cc2408ca05432d5f7face5b62924a44acb8f84" translate="yes" xml:space="preserve">
          <source>And your caller module would be something like this:</source>
          <target state="translated">呼び出し元のモジュールは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f429519c2ad8f6db43559b6df0122aa7e92ef582" translate="yes" xml:space="preserve">
          <source>And, as you'll have noticed from the previous example, if you override &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob operator is overridden as well.</source>
          <target state="translated">また、前の例で気付いたように、 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; をオーバーライドすると、 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob演算子もオーバーライドされます。</target>
        </trans-unit>
        <trans-unit id="0872d4a5d2061a3d40ffa31b9853ff607e66e0c5" translate="yes" xml:space="preserve">
          <source>And, the Name and Name_Aliases properties are accessible through the &lt;code&gt;\N{}&lt;/code&gt; interpolation in double-quoted strings and regular expressions; and functions &lt;code&gt;charnames::viacode()&lt;/code&gt; , &lt;code&gt;charnames::vianame()&lt;/code&gt; , and &lt;code&gt;charnames::string_vianame()&lt;/code&gt; (which require a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames ();&lt;/code&gt; to be specified.</source>
          <target state="translated">また、NameプロパティとName_Aliasesプロパティには、二重引用符で囲まれた文字列と正規表現の &lt;code&gt;\N{}&lt;/code&gt; 補間を介してアクセスできます。および関数 &lt;code&gt;charnames::viacode()&lt;/code&gt; 、 &lt;code&gt;charnames::vianame()&lt;/code&gt; 、および &lt;code&gt;charnames::string_vianame()&lt;/code&gt; （これには、指定 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames ();&lt;/code&gt; は、charnames（）;を使用する必要があります）。</target>
        </trans-unit>
        <trans-unit id="b49cf0754660175d0a77b4c857d087e651cbf367" translate="yes" xml:space="preserve">
          <source>And, with Perl 5.10 and later, you don't have to check for an inheritance to see if the object can handle a role. For that, you can use &lt;code&gt;DOES&lt;/code&gt; , which comes from &lt;code&gt;UNIVERSAL&lt;/code&gt; :</source>
          <target state="translated">また、Perl 5.10以降では、オブジェクトがロールを処理できるかどうかを確認するために継承を確認する必要はありません。そのためには、 &lt;code&gt;UNIVERSAL&lt;/code&gt; の &lt;code&gt;DOES&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="5b41c9a4e6f27e4cb868723e388d3e3baf23ec77" translate="yes" xml:space="preserve">
          <source>Andreas Koenig &lt;code&gt;&amp;lt;andk@cpan.org&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Andreas Koenig &lt;code&gt;&amp;lt;andk@cpan.org&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17721a7a6efc10cf2782e06109ae542e5e371c5d" translate="yes" xml:space="preserve">
          <source>Andreas Koenig &lt;code&gt;andreas.koenig@anima.de&lt;/code&gt;</source>
          <target state="translated">Andreas Koenig &lt;code&gt;andreas.koenig@anima.de&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2f8905b2465e6f0ad9cfd91b9febf4156adfa14" translate="yes" xml:space="preserve">
          <source>Andy Armstong &amp;lt;andy@hexten.net&amp;gt;</source>
          <target state="translated">Andy Armstong &amp;lt;andy@hexten.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d272317e48a940ed9b68adfad919572635019ce3" translate="yes" xml:space="preserve">
          <source>Andy Armstrong &lt;code&gt;&amp;lt;andy@hexten.net&amp;gt;&lt;/code&gt;</source>
          <target state="translated">アンディアームストロング &lt;code&gt;&amp;lt;andy@hexten.net&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b85b5eb312e6917fec0aa730c7d70660252958f" translate="yes" xml:space="preserve">
          <source>Andy Armstrong, &amp;lt;andy@hexten.net&amp;gt;</source>
          <target state="translated">Andy Armstrong、&amp;lt;andy@hexten.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8e9ef1486d01c7ad977376f692dc981d906e478c" translate="yes" xml:space="preserve">
          <source>Andy Dougherty &lt;code&gt;doughera@lafayette.edu&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt; , Tim Bunce &lt;code&gt;timb@cpan.org&lt;/code&gt; . VMS support by Charles Bailey &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt; . OS/2 support by Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; .</source>
          <target state="translated">アンディ・ドハティの &lt;code&gt;doughera@lafayette.edu&lt;/code&gt; 、アンドレアス・ケーニッヒは &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt; 、ティムバンス &lt;code&gt;timb@cpan.org&lt;/code&gt; 。Charles Bailey &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt; によるVMSサポート。Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; によるOS / 2サポート。</target>
        </trans-unit>
        <trans-unit id="f309e7ea03de47735dc8e5cfc8cc01f796755634" translate="yes" xml:space="preserve">
          <source>Anecdotal estimates of source-to-compiled code bloat suggest an eightfold increase. This means that the compiled form of reasonable (normally commented, properly indented etc.) code will take about eight times more space in memory than the code took on disk.</source>
          <target state="translated">ソースからコンパイルされたコードの肥大化についての逸話的な見積もりによると、8倍にもなることが示唆されています。これは、合理的な (普通にコメントされた、適切にインデントされたなど)コードのコンパイルされた形式のコードは、ディスク上のコードの約 8 倍のメモリ容量を必要とすることを意味しています。</target>
        </trans-unit>
        <trans-unit id="dd5ff38fa4ac27c93c3c6622ac77c49ca0b0e6b7" translate="yes" xml:space="preserve">
          <source>Angle brackets not written as &lt;code&gt;&amp;lt;lt&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;gt&amp;gt;&lt;/code&gt; can potentially cause errors as they could be misinterpreted as markup commands. This is only printed when the -warnings level is greater than 1.</source>
          <target state="translated">&lt;code&gt;&amp;lt;lt&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;lt;gt&amp;gt;&lt;/code&gt; として記述されていない山括弧は、マークアップコマンドとして誤って解釈される可能性があるため、エラーを引き起こす可能性があります。-warningsレベルが1より大きい場合にのみ出力されます。</target>
        </trans-unit>
        <trans-unit id="4a0daf5f778b84f7d47324f4951f69110d4d48b4" translate="yes" xml:space="preserve">
          <source>Anno Siegel (ANNO) wrote the xs code and the changes in perl proper Jerry Hedden (JDHEDDEN) made it faster</source>
          <target state="translated">Anno Siegel (ANNO)は xs のコードを書き、Jerry Hedden (JDHEDDEN)は perl の適切な変更により高速化しました。</target>
        </trans-unit>
        <trans-unit id="4fa7bfd58b194e39ca2dde6c48f032e168048d8e" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt;: &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;threads&quot;&gt;スレッドの&lt;/a&gt;注釈付きPOD ：&lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;http&lt;/a&gt; : //annocpan.org/? mode=search&amp;amp;field=Module&amp;amp;name= threads</target>
        </trans-unit>
        <trans-unit id="ba63b983b01c370d674ecdc009b4d7bcd13f4f33" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;: &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;threads/shared&quot;&gt;threads :: sharedの&lt;/a&gt;注釈付きPOD ：&lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;http&lt;/a&gt; : //annocpan.org/? mode=search&amp;amp;field=Module&amp;amp;name= threads %3A% 3Ashared</target>
        </trans-unit>
        <trans-unit id="4d0700dd0d246c337cd6fa922a92caa253e25b21" translate="yes" xml:space="preserve">
          <source>Annotated list of characters</source>
          <target state="translated">文字の注釈付きリスト</target>
        </trans-unit>
        <trans-unit id="911169a23e106a872e476c8d2fa5935672c571c0" translate="yes" xml:space="preserve">
          <source>Anonymous hash and array composers like these can be intermixed freely to produce as complicated a structure as you want. The multidimensional syntax described below works for these too. The values above are literals, but variables and expressions would work just as well, because assignment operators in Perl (even within local() or my()) are executable statements, not compile-time declarations.</source>
          <target state="translated">これらのような匿名ハッシュと配列のコンポーザは自由に混ぜ合わせて、好きなだけ複雑な構造を作ることができます。以下に説明する多次元構文は、これらにも対応しています。上記の値はリテラルですが、Perl の代入演算子(local()やmy()の中でも)は実行可能なステートメントであり、コンパイル時の宣言ではないので、変数や式も同様に動作します。</target>
        </trans-unit>
        <trans-unit id="ddd265fb1f3b46963f4185e092c2f56d761a6e96" translate="yes" xml:space="preserve">
          <source>Anonymous subroutines act as closures with respect to my() variables, that is, variables lexically visible within the current scope. Closure is a notion out of the Lisp world that says if you define an anonymous function in a particular lexical context, it pretends to run in that context even when it's called outside the context.</source>
          <target state="translated">匿名サブルーチンはmy()変数、つまり現在のスコープ内で語彙的に見える変数に対してクロージャとして動作します。クロージャとはLispの世界にある概念で、特定の語彙的コンテキストで匿名関数を定義すると、コンテキスト外で呼び出されてもそのコンテキストで実行されているかのように振る舞うというものです。</target>
        </trans-unit>
        <trans-unit id="3eb95879a615d5ea34c741b40bf67030c1977968" translate="yes" xml:space="preserve">
          <source>Anonymous subroutines get to capture each time you execute the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; operator, as they are created on the fly. If you are accustomed to using nested subroutines in other programming languages with their own private variables, you'll have to work at it a bit in Perl. The intuitive coding of this type of thing incurs mysterious warnings about &quot;will not stay shared&quot; due to the reasons explained above. For example, this won't work:</source>
          <target state="translated">匿名のサブルーチンは、その場で作成されるため、 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 演算子を実行するたびにキャプチャされます。独自のプライベート変数を持つ他のプログラミング言語でネストされたサブルーチンを使用することに慣れている場合は、Perlで少し作業する必要があります。このタイプのことを直感的にコーディングすると、上記の理由により、「共有されない」という不可解な警告が発生します。たとえば、これは機能しません：</target>
        </trans-unit>
        <trans-unit id="c0878cc2f5c4c23ed0c52c0dfcedfeb6916f96a7" translate="yes" xml:space="preserve">
          <source>Another Example</source>
          <target state="translated">別の例</target>
        </trans-unit>
        <trans-unit id="58127100a894b61eeb7ff5e87057e807d55c8b96" translate="yes" xml:space="preserve">
          <source>Another Example -- Key is a C int.</source>
          <target state="translated">別の例 --キーは C の int です。</target>
        </trans-unit>
        <trans-unit id="60d38257f9d2129e1058114b1893e74a3db974bb" translate="yes" xml:space="preserve">
          <source>Another Example: Key is a C int.</source>
          <target state="translated">別の例。キーはCの整数です。</target>
        </trans-unit>
        <trans-unit id="be5842d0c6f0b2a32d5a2aac4ce0ec4bcd453989" translate="yes" xml:space="preserve">
          <source>Another Portable Binary Encoding</source>
          <target state="translated">別のポータブルバイナリエンコーディング</target>
        </trans-unit>
        <trans-unit id="a3a811e6345c52a72030025da749e7378837c8a7" translate="yes" xml:space="preserve">
          <source>Another brief debugger, slightly more useful, can be created with only the line:</source>
          <target state="translated">もう一つ、少しだけ便利な短いデバッガを一行だけで作成することができます。</target>
        </trans-unit>
        <trans-unit id="723c39858f051ddac15e8257e9c5bc5481712afe" translate="yes" xml:space="preserve">
          <source>Another common error is to use ordinary parentheses to construct a list reference when you should be using square or curly brackets, for example, if you say</source>
          <target state="translated">もう一つよくある間違いは、通常の括弧を使用してリスト参照を構築することです。</target>
        </trans-unit>
        <trans-unit id="989f6c267d1aa6631d47641c01947fa297495517" translate="yes" xml:space="preserve">
          <source>Another common use for this construct is when you need to execute something without the shell's interference. With system(), it's straightforward, but you can't use a pipe open or backticks safely. That's because there's no way to stop the shell from getting its hands on your arguments. Instead, use lower-level control to call exec() directly.</source>
          <target state="translated">このコンストラクトのもう一つの一般的な使用法は、シェルの干渉を受けずに何かを実行する必要がある場合です。system()を使えば簡単ですが、パイプオープンやバックティックを安全に使うことはできません。シェルが引数に手を出すのを止める方法がないからです。代わりに、下位レベルの制御を使って exec()を直接呼び出すようにしましょう。</target>
        </trans-unit>
        <trans-unit id="9e79a0e3805beb03c075ab9c59ea2fd3f85cbbe5" translate="yes" xml:space="preserve">
          <source>Another complication is that the representation used for the program differs if it needs to store Unicode, but it's not always possible to know for sure whether it does until midway through parsing. The Unicode representation for the program is larger, and cannot be matched as efficiently. (See &lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;Unicode and Localisation Support&lt;/a&gt; below for more details as to why.) If the pattern contains literal Unicode, it's obvious that the program needs to store Unicode. Otherwise, the parser optimistically assumes that the more efficient representation can be used, and starts sizing on this basis. However, if it then encounters something in the pattern which must be stored as Unicode, such as an &lt;code&gt;\x{...}&lt;/code&gt; escape sequence representing a character literal, then this means that all previously calculated sizes need to be redone, using values appropriate for the Unicode representation. Currently, all regular expression constructions which can trigger this are parsed by code in &lt;code&gt;regatom()&lt;/code&gt; .</source>
          <target state="translated">もう1つの複雑なことは、Unicodeを格納する必要がある場合、プログラムで使用される表現が異なることですが、解析の途中まで実行するかどうかを常に確実に知ることはできません。プログラムのUnicode表現は大きく、効率的に一致させることができません。 （理由の詳細については、以下の&lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;Unicodeおよびローカリゼーションのサポートを&lt;/a&gt;参照してください。）パターンにリテラルUnicodeが含まれている場合、プログラムがUnicodeを格納する必要があるのは明らかです。そうでない場合、パーサーはより効率的な表現を使用できると楽観的に想定し、これに基づいてサイジングを開始します。ただし、パターンで &lt;code&gt;\x{...}&lt;/code&gt; などのUnicodeとして保存する必要がある何かに遭遇した場合文字リテラルを表すエスケープシーケンス。これは、以前に計算されたすべてのサイズを、Unicode表現に適した値を使用してやり直す必要があることを意味します。現在、これをトリガーできるすべての正規表現の構成は、 &lt;code&gt;regatom()&lt;/code&gt; のコードによって解析されます。</target>
        </trans-unit>
        <trans-unit id="8b313efb71a57a4464cb94a659a9e8b90c24250e" translate="yes" xml:space="preserve">
          <source>Another confusion with both these properties is that the definition is not that the code point has been</source>
          <target state="translated">これらの両方のプロパティとのもう一つの混乱は、定義がコードポイントが</target>
        </trans-unit>
        <trans-unit id="a7643f36484ae100d2da2d3c144ef9dbeaed949e" translate="yes" xml:space="preserve">
          <source>Another consequence of using binmode() (on some systems) is that special end-of-file markers will be seen as part of the data stream. For systems from the Microsoft family this means that, if your binary data contain &lt;code&gt;\cZ&lt;/code&gt; , the I/O subsystem will regard it as the end of the file, unless you use binmode().</source>
          <target state="translated">（一部のシステムで）binmode（）を使用することのもう1つの結果は、特別なファイル終了マーカーがデータストリームの一部として表示されることです。Microsoftファミリのシステムの場合、これは、バイナリデータに &lt;code&gt;\cZ&lt;/code&gt; が含まれている場合、binmode（）を使用しない限り、I / Oサブシステムはそれをファイルの終わりと見なすことを意味します。</target>
        </trans-unit>
        <trans-unit id="3cc44056a9f339f4466b010a8b6a440f514bb627" translate="yes" xml:space="preserve">
          <source>Another construct to be wary of is the inappropriate use of hex (unless you use &lt;code&gt;\N{U+...}&lt;/code&gt; ) or octal constants in regular expressions. Consider the following set of subs:</source>
          <target state="translated">注意すべきもう1つの構成は、正規表現での16進数（ &lt;code&gt;\N{U+...}&lt;/code&gt; を使用しない限り）または8進定数の不適切な使用です。次のサブセットを検討してください。</target>
        </trans-unit>
        <trans-unit id="dd580d9d1c12fa08ea2d8378d289e2825dd48a0c" translate="yes" xml:space="preserve">
          <source>Another description starts with notions of &quot;better&quot;/&quot;worse&quot;. All the substrings which may be matched by the given regular expression can be sorted from the &quot;best&quot; match to the &quot;worst&quot; match, and it is the &quot;best&quot; match which is chosen. This substitutes the question of &quot;what is chosen?&quot; by the question of &quot;which matches are better, and which are worse?&quot;.</source>
          <target state="translated">もう一つの記述は、&quot;より良い&quot;/&quot;より悪い &quot;の概念から始まります。与えられた正規表現によってマッチする可能性のあるすべての部分文字列は、&quot;最高 &quot;のマッチから &quot;最悪 &quot;のマッチまで並べ替えることができ、&quot;最高 &quot;のマッチが選択される。これは、&quot;何が選ばれるのか?&quot;という質問を、&quot;どのマッチがより良く、どのマッチがより悪いのか?&quot;という質問に置き換えます。</target>
        </trans-unit>
        <trans-unit id="856a6f6c8652259321cab00a9ad8f033dc81e6f4" translate="yes" xml:space="preserve">
          <source>Another drawback is only valid for Perl versions before 5.6.0. This drawback is that the seek and tell functions (both the builtin version and POSIX module version) will not perform correctly.</source>
          <target state="translated">もう一つの欠点は、Perl のバージョンが 5.6.0 より前の場合にのみ有効です。この欠点は、シークとテル関数(ビルトイン版とPOSIXモジュール版の両方)が正しく動作しないことです。</target>
        </trans-unit>
        <trans-unit id="d8eeb28f49e1f9d89b4e036aaf71838ed7700dd9" translate="yes" xml:space="preserve">
          <source>Another dummy layer. When pushed it pops itself and sets the &lt;code&gt;PERLIO_F_UTF8&lt;/code&gt; flag on the layer which was (and now is once more) the top of the stack.</source>
          <target state="translated">別のダミー層。プッシュされると、それ自体がポップされ、スタックの最上部であった（現在はもう一度）レイヤーに &lt;code&gt;PERLIO_F_UTF8&lt;/code&gt; フラグが設定されます。</target>
        </trans-unit>
        <trans-unit id="d9e8985e4a56d117b356dcbeb0c42c3cbcba847b" translate="yes" xml:space="preserve">
          <source>Another example of a data paragraph:</source>
          <target state="translated">データパラグラフの別の例。</target>
        </trans-unit>
        <trans-unit id="b5c62d28b9310748f7a00e0cde763766b0ceff47" translate="yes" xml:space="preserve">
          <source>Another example switched the first &quot;latin1&quot; encoding it finds to &quot;utf8&quot; in a pod file:</source>
          <target state="translated">別の例では、ポッドファイルの最初の &quot;latin1 &quot;エンコーディングを &quot;utf8 &quot;に切り替えています。</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">別の例です。</target>
        </trans-unit>
        <trans-unit id="ece934d7c44856dd3f545147d03b2aa737a1de6d" translate="yes" xml:space="preserve">
          <source>Another form of code expression is the</source>
          <target state="translated">コード表現の別の形式は</target>
        </trans-unit>
        <trans-unit id="48b78ab1e531e9b3794c2d43c0589ca792ae0b42" translate="yes" xml:space="preserve">
          <source>Another form of optimisation that can occur is the post-parse &quot;peep-hole&quot; optimisation, where inefficient constructs are replaced by more efficient constructs. The &lt;code&gt;TAIL&lt;/code&gt; regops which are used during parsing to mark the end of branches and the end of groups are examples of this. These regops are used as place-holders during construction and &quot;always match&quot; so they can be &quot;optimised away&quot; by making the things that point to the &lt;code&gt;TAIL&lt;/code&gt; point to the thing that &lt;code&gt;TAIL&lt;/code&gt; points to, thus &quot;skipping&quot; the node.</source>
          <target state="translated">発生する可能性のある別の形式の最適化は、解析後の「のぞき穴」最適化です。この場合、非効率的な構造がより効率的な構造に置き換えられます。 &lt;code&gt;TAIL&lt;/code&gt; の分岐の終わりをマークするために解析中に使用されregopsおよびグループの端部がその例です。これらのレゴップは、構築中のプレースホルダーとして使用され、「常に一致」するため、 &lt;code&gt;TAIL&lt;/code&gt; を指すものを &lt;code&gt;TAIL&lt;/code&gt; が指すものにポイントし、ノードを「スキップ」することで、「最適化」できます。</target>
        </trans-unit>
        <trans-unit id="6a81857ae4b443a44f359782c057cbbbeb457048" translate="yes" xml:space="preserve">
          <source>Another good reason in addition to readability and maintainability for using relative backreferences is illustrated by the following example, where a simple pattern for matching peculiar strings is used:</source>
          <target state="translated">相対後方参照を使う理由としては、読みやすさや保守性のほかに、以下の例では、特殊な文字列をマッチングさせるための簡単なパターンを使っています。</target>
        </trans-unit>
        <trans-unit id="bfac64b9584bc828981db16d0cc4e6658be646cc" translate="yes" xml:space="preserve">
          <source>Another interesting approach to IPC is making your single program go multiprocess and communicate between--or even amongst--yourselves. The open() function will accept a file argument of either &lt;code&gt;&quot;-|&quot;&lt;/code&gt; or &lt;code&gt;&quot;|-&quot;&lt;/code&gt; to do a very interesting thing: it forks a child connected to the filehandle you've opened. The child is running the same program as the parent. This is useful for safely opening a file when running under an assumed UID or GID, for example. If you open a pipe</source>
          <target state="translated">IPCへのもう1つの興味深いアプローチは、単一のプログラムをマルチプロセスにして、自分自身の間、または自分自身の間でさえ通信することです。open（）関数は、 &lt;code&gt;&quot;-|&quot;&lt;/code&gt; のいずれかのファイル引数を受け入れます または &lt;code&gt;&quot;|-&quot;&lt;/code&gt; は、非常に興味深いことを行います。開いたファイルハンドルに接続された子をフォークします。子は親と同じプログラムを実行しています。これは、たとえば、想定されたUIDまたはGIDで実行しているときにファイルを安全に開くのに役立ちます。パイプを開けると</target>
        </trans-unit>
        <trans-unit id="075cc903bac6f7e2aa6bd64ab5e44c58b488750c" translate="yes" xml:space="preserve">
          <source>Another interesting signal to send is signal number zero. This doesn't actually affect a child process, but instead checks whether it's alive or has changed its UIDs.</source>
          <target state="translated">もう一つの興味深いシグナルとして、シグナル番号ゼロがあります。これは実際には子プロセスには影響を与えませんが、その代わりに子プロセスが生きているか、UIDが変更されたかをチェックします。</target>
        </trans-unit>
        <trans-unit id="5625c9da79ea74fa11d7487b4856a60b8a448f5c" translate="yes" xml:space="preserve">
          <source>Another interface for querying locale-dependent information is the &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; function, available at least in Unix-like systems and VMS.</source>
          <target state="translated">ロケール依存情報を照会するためのもう1つのインターフェースは、 &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; 関数です。これは、少なくともUnixライクなシステムとVMSで使用できます。</target>
        </trans-unit>
        <trans-unit id="7cdba3e1788bc415b19d9a9a11cdf704cabf535e" translate="yes" xml:space="preserve">
          <source>Another kind of client-server setup is one that uses not connections, but messages. UDP communications involve much lower overhead but also provide less reliability, as there are no promises that messages will arrive at all, let alone in order and unmangled. Still, UDP offers some advantages over TCP, including being able to &quot;broadcast&quot; or &quot;multicast&quot; to a whole bunch of destination hosts at once (usually on your local subnet). If you find yourself overly concerned about reliability and start building checks into your message system, then you probably should use just TCP to start with.</source>
          <target state="translated">もう一つの種類のクライアント・サーバのセットアップは、接続ではなくメッセージを使用するものです。UDP通信では、オーバーヘッドがはるかに低くなりますが、メッセージが順番通りに到着するという約束がないため、信頼性も低くなります。しかし、UDPはTCPよりもいくつかの利点があり、一度にたくさんの宛先ホスト(通常はローカルサブネット上)に「ブロードキャスト」や「マルチキャスト」ができるなどの利点があります。信頼性を過度に気にして、メッセージシステムにチェック機能を組み込むようになった場合は、最初からTCPだけを使うべきでしょう。</target>
        </trans-unit>
        <trans-unit id="15bc936b8bd7810df3b41eba0889fe66dfa9061e" translate="yes" xml:space="preserve">
          <source>Another memory limiting item to check is your MAXASSIZE parameter in your 'SYS1.PARMLIB(BPXPRMxx)' data set (note too that as of V2R8 address space limits can be set on a per user ID basis in the USS segment of a RACF profile). People have reported successful builds of Perl with MAXASSIZE parameters as small as 503316480 (and it may be possible to build Perl with a MAXASSIZE smaller than that).</source>
          <target state="translated">チェックすべきもう一つのメモリ制限項目は、'SYS1.PARMLIB(BPXPRMxx)' データセットの MAXASSIZE パラメータです(V2R8 では、RACF プロファイルの USS セグメントでユーザ ID ごとにアドレス空間の制限を設定できることにも注意してください)。人々は、MAXASSIZEパラメータが503316480と小さいPerlのビルドに成功したと報告しています(そして、それより小さいMAXASSIZEでPerlをビルドすることが可能かもしれません)。</target>
        </trans-unit>
        <trans-unit id="ce05ce9dfc0d776de0b8b42183a9011dbca61f46" translate="yes" xml:space="preserve">
          <source>Another mnemonic for this modifier is &quot;Depends&quot;, as the rules actually used depend on various things, and as a result you can get unexpected results. See &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug in perlunicode&lt;/a&gt;. The Unicode Bug has become rather infamous, leading to yet another (printable) name for this modifier, &quot;Dodgy&quot;.</source>
          <target state="translated">この修飾子のもう1つのニーモニックは &quot;Depends&quot;です。これは、実際に使用されるルールがさまざまなものに依存するため、予期しない結果が生じる可能性があるためです。&lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicodeのUnicodeバグを&lt;/a&gt;参照してください。 Unicodeのバグはかなり悪名高いものになり、この修飾子の「印刷可能な」名前が「Dodgy」に変わりました。</target>
        </trans-unit>
        <trans-unit id="3cfb16782780267975128af9b462f0c7f8f09971" translate="yes" xml:space="preserve">
          <source>Another odd-man-out in the template alphabet is &lt;code&gt;u&lt;/code&gt; , which packs a &quot;uuencoded string&quot;. (&quot;uu&quot; is short for Unix-to-Unix.) Chances are that you won't ever need this encoding technique which was invented to overcome the shortcomings of old-fashioned transmission mediums that do not support other than simple ASCII data. The essential recipe is simple: Take three bytes, or 24 bits. Split them into 4 six-packs, adding a space (0x20) to each. Repeat until all of the data is blended. Fold groups of 4 bytes into lines no longer than 60 and garnish them in front with the original byte count (incremented by 0x20) and a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at the end. - The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; chef will prepare this for you, a la minute, when you select pack code &lt;code&gt;u&lt;/code&gt; on the menu:</source>
          <target state="translated">テンプレートアルファベットのもう1つの奇妙な例は &lt;code&gt;u&lt;/code&gt; で、これは「uuencoded文字列」をパックします。 （「uu」はUnix-to-Unixの略です。）単純なASCIIデータ以外をサポートしない旧式の伝送媒体の欠点を克服するために発明されたこのエンコード手法は、おそらく必要ないでしょう。基本的なレシピは簡単です。3バイト、つまり24ビットを使用します。それらを4つの6パックに分割し、それぞれにスペース（0x20）を追加します。すべてのデータがブレンドされるまで繰り返します。 4バイトのグループを60行以下に折りたたみ、元のバイトカウント（0x20ずつ増加）と最後に &lt;code&gt;&quot;\n&quot;&lt;/code&gt; を前に付けます。 - メニューでパックコード &lt;code&gt;u&lt;/code&gt; を選択すると、 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; シェフがすぐに準備します。</target>
        </trans-unit>
        <trans-unit id="f3b90d55edc9bd711b381039fe4df0f81ca8e910" translate="yes" xml:space="preserve">
          <source>Another operator with surprising precedence is exponentiation. It binds more tightly even than unary minus, making &lt;code&gt;-2**2&lt;/code&gt; produce a negative four and not a positive one. It is also right-associating, meaning that &lt;code&gt;2**3**2&lt;/code&gt; is two raised to the ninth power, not eight squared.</source>
          <target state="translated">驚くべき優先順位を持つ別の演算子は、指数です。単項マイナスよりも強く結合し、 &lt;code&gt;-2**2&lt;/code&gt; が正の1ではなく負の4を生成します。また、右に関連しています。つまり、 &lt;code&gt;2**3**2&lt;/code&gt; は、8の2乗ではなく、2の9乗です。</target>
        </trans-unit>
        <trans-unit id="0a8ead7308fc061719df6bc244f6348d6cfaf232" translate="yes" xml:space="preserve">
          <source>Another optimisation that can occur is that of &quot;&lt;code&gt;EXACT&lt;/code&gt; merging&quot; which is where two consecutive &lt;code&gt;EXACT&lt;/code&gt; nodes are merged into a single regop. An even more aggressive form of this is that a branch sequence of the form &lt;code&gt;EXACT BRANCH ... EXACT&lt;/code&gt; can be converted into a &lt;code&gt;TRIE-EXACT&lt;/code&gt; regop.</source>
          <target state="translated">発生する可能性のある別の最適化は、2つの連続する &lt;code&gt;EXACT&lt;/code&gt; ノードが1つのレゴップにマージされる「 &lt;code&gt;EXACT&lt;/code&gt; merging 」の最適化です。これのさらに強力な形式は、 &lt;code&gt;EXACT BRANCH ... EXACT&lt;/code&gt; という形式の分岐シーケンスをTRIE &lt;code&gt;TRIE-EXACT&lt;/code&gt; regopに変換できることです。</target>
        </trans-unit>
        <trans-unit id="6aabd99f333ab712e259e5fbe14c5365c3fb3eb5" translate="yes" xml:space="preserve">
          <source>Another option is to use the &lt;code&gt;iter&lt;/code&gt; class method to iterate over the files in the tarball without reading them all in memory at once.</source>
          <target state="translated">もう1つのオプションは、 &lt;code&gt;iter&lt;/code&gt; クラスメソッドを使用して、メモリ内のすべてのファイルを一度に読み取ることなく、tarball内のファイルを反復処理することです。</target>
        </trans-unit>
        <trans-unit id="82d37f84faabd12d777cc2ff160de45bc66b098d" translate="yes" xml:space="preserve">
          <source>Another option is to use the make written in Perl, available from CPAN.</source>
          <target state="translated">もう一つの選択肢は、CPANから入手できるPerlで書かれたmakeを使用することです。</target>
        </trans-unit>
        <trans-unit id="655a86d88b6839dd2179128ff91b78ce22ba6c96" translate="yes" xml:space="preserve">
          <source>Another peculiarity of urllist is that the site that we could successfully fetch the last file from automatically gets a preference token and is tried as the first site for the next request. So if you add a new site at runtime it may happen that the previously preferred site will be tried another time. This means that if you want to disallow a site for the next transfer, it must be explicitly removed from urllist.</source>
          <target state="translated">urllist のもう一つの特徴は、最後のファイルの取得に成功したサイトが自動的にプリファレンストークンを取得し、次のリクエストの最初のサイトとして試行されることです。そのため、実行時に新しいサイトを追加した場合、以前に優先されていたサイトが再度試行される可能性があります。つまり、次の転送でサイトを許可しないようにしたい場合は、明示的に urllist から削除しなければなりません。</target>
        </trans-unit>
        <trans-unit id="ce6cb12c61e008cd3f2b006405f6306cfa9808f3" translate="yes" xml:space="preserve">
          <source>Another point worth noting is that in the first series of examples I have made use of only the</source>
          <target state="translated">もう一つの注目すべき点は、最初の一連の例で、私が使用したのは</target>
        </trans-unit>
        <trans-unit id="4398365ad3174110f099b9553fe6a9ab1f982409" translate="yes" xml:space="preserve">
          <source>Another popular use for &lt;code&gt;recompile&lt;/code&gt; is to act as a rescue in case your perl breaks binary compatibility. If one of the modules that CPAN uses is in turn depending on binary compatibility (so you cannot run CPAN commands), then you should try the CPAN::Nox module for recovery.</source>
          <target state="translated">&lt;code&gt;recompile&lt;/code&gt; もう1つの一般的な用途は、perlがバイナリ互換性を破った場合の救済として機能することです。CPANが使用するモジュールの1つがバイナリ互換性に依存している場合（つまり、CPANコマンドを実行できない場合）は、CPAN :: Noxモジュールを試して回復する必要があります。</target>
        </trans-unit>
        <trans-unit id="9d8cd00450b93b9762fe1f4860bcee6a18ea20de" translate="yes" xml:space="preserve">
          <source>Another possibility is that you forgot a backslash. Perl isn't smart enough to figure out what you really meant.</source>
          <target state="translated">もう一つの可能性としては、バックスラッシュを忘れたということが考えられます。Perlはあなたが本当に言いたいことを理解するほど賢くはありません。</target>
        </trans-unit>
        <trans-unit id="385e095c764654e0fb183ec8deedb8c0e3232a76" translate="yes" xml:space="preserve">
          <source>Another possible reason for problems is that you've used the indirect object syntax (eg, &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt; ) on a class name before Perl has seen that such a package exists. It's wisest to make sure your packages are all defined before you start using them, which will be taken care of if you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement instead of &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;. If not, make sure to use arrow notation (eg., &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt; ) instead. Object notation is explained in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">問題のもう1つの考えられる理由は、Perlがそのようなパッケージの存在を確認する前に、クラス名で間接オブジェクト構文（たとえば、 &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt; ）を使用したことです。パッケージの使用を開始する前に、パッケージがすべて定義されていることを確認するのが最も賢明です。requireの代わりに &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ステートメントを使用する場合は、これが考慮され &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 。そうでない場合は、代わりに矢印表記を使用してください（例： &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt; ）。オブジェクトの表記法は&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;で説明されています。</target>
        </trans-unit>
        <trans-unit id="c972997167e011df9a56046ecd4a5023cc5037ca" translate="yes" xml:space="preserve">
          <source>Another problem that occurs with inside-out classes is serialization. Since the object data is not in its usual place, standard routines like &lt;code&gt;Storable::freeze()&lt;/code&gt; , &lt;code&gt;Storable::thaw()&lt;/code&gt; and &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; can't deal with it on their own. Both &lt;code&gt;Data::Dumper&lt;/code&gt; and &lt;code&gt;Storable&lt;/code&gt; provide the necessary hooks to make things work, but the functions or methods used by the hooks must be provided by each inside-out class.</source>
          <target state="translated">裏返しのクラスで発生する別の問題は、シリアル化です。オブジェクトデータは通常の場所にないため、 &lt;code&gt;Storable::freeze()&lt;/code&gt; 、 &lt;code&gt;Storable::thaw()&lt;/code&gt; 、 &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; Dumper :: Dumper （）などの標準ルーチンは、それ自体では処理できません。 &lt;code&gt;Data::Dumper&lt;/code&gt; &lt;code&gt;Storable&lt;/code&gt; とStorableはどちらも、物事を機能させるために必要なフックを提供しますが、フックによって使用される関数またはメソッドは、各インサイドアウトクラスによって提供される必要があります。</target>
        </trans-unit>
        <trans-unit id="4838334963e3cee1c557a4f6afcd664375d054be" translate="yes" xml:space="preserve">
          <source>Another problem with this approach is that operations that cross the single byte/multiple byte boundary are not well-defined, and so are disallowed. (This boundary is between the codepoints at 255/256.) For example, lower casing LATIN CAPITAL LETTER Y WITH DIAERESIS (U+0178) should return LATIN SMALL LETTER Y WITH DIAERESIS (U+00FF). But in the Greek locale, for example, there is no character at 0xFF, and Perl has no way of knowing what the character at 0xFF is really supposed to represent. Thus it disallows the operation. In this mode, the lowercase of U+0178 is itself.</source>
          <target state="translated">このアプローチのもう一つの問題点は、シングルバイト/マルチバイトの境界を越える操作は十分に定義されていないため、許可されないということです(この境界は255/256のコードポイントの間にあります)。(この境界は255/256のコードポイントの間にあります。)例えば、小文字のLATIN CAPITAL LETTER Y WITH DIAERESIS (U+0178)は、LATIN SMALL LETTER Y WITH DIAERESIS (U+00FF)を返すべきです。しかし、例えばギリシャ語ロケールでは、0xFFには文字がなく、Perlは0xFFの文字が実際に何を表しているのかを知る方法がありません。そのため、Perl はこの操作を無効にします。このモードでは、U+0178の小文字はそれ自体です。</target>
        </trans-unit>
        <trans-unit id="1d25e58d1b57cecb55c387a5dd5c52709e7a7cf9" translate="yes" xml:space="preserve">
          <source>Another reason that folks sometimes think they want a variable to contain the name of a variable is that they don't know how to build proper data structures using hashes. For example, let's say they wanted two hashes in their program: %fred and %barney, and that they wanted to use another scalar variable to refer to those by name.</source>
          <target state="translated">変数に変数名を入れたいと考えるもう一つの理由は、ハッシュを使って適切なデータ構造を構築する方法を知らないということです。例えば、プログラムの中で 2 つのハッシュが必要だったとします。fred と %barney で、これらを名前で参照するために別のスカラ変数を使用したいとします。</target>
        </trans-unit>
        <trans-unit id="0421a2fa7b166fbdb782231a9f8dbd1fd87115e8" translate="yes" xml:space="preserve">
          <source>Another reason to use &lt;code&gt;HASH&lt;/code&gt; is to provide your own hash variable. You can then inspect or modify the contents of the hash to gain finer control over the cache management.</source>
          <target state="translated">&lt;code&gt;HASH&lt;/code&gt; を使用するもう1つの理由は、独自のハッシュ変数を提供することです。その後、ハッシュの内容を検査または変更して、キャッシュ管理をより細かく制御できます。</target>
        </trans-unit>
        <trans-unit id="8b8bed8e10e25cfa736414741ddf1e9e2d2b9072" translate="yes" xml:space="preserve">
          <source>Another sample module, &lt;a href=&quot;http://search.cpan.org/perldoc/Memoize::Saves&quot;&gt;Memoize::Saves&lt;/a&gt;, is available in a separate distribution on CPAN. It implements a policy that allows you to specify that certain function values would always be looked up afresh. See the documentation for details.</source>
          <target state="translated">別のサンプルモジュール&lt;a href=&quot;http://search.cpan.org/perldoc/Memoize::Saves&quot;&gt;Memoize :: Savesは&lt;/a&gt;、CPANの別のディストリビューションで入手できます。これは、特定の関数値が常に新しく検索されるように指定できるポリシーを実装しています。詳細については、ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="f67a475c6b156df5eac51c84854028a80181079b" translate="yes" xml:space="preserve">
          <source>Another thing to try is learning whether your Perl was compiled with the system malloc or with Perl's builtin malloc. Whichever one it is, try using the other one and see whether this makes a difference. Information about malloc is in the</source>
          <target state="translated">もう一つは、Perl がシステムの malloc でコンパイルされたのか、Perl の組み込み malloc でコンパイルされたのかを知ることです。どちらか一方を使ってみて、違いがあるかどうかを確認してください。malloc に関する情報は</target>
        </trans-unit>
        <trans-unit id="a1cb48749447600d090febf98d3e4d0e00ee484e" translate="yes" xml:space="preserve">
          <source>Another thing you should bear in mind is that the UNINST parameter can be dangerous when you are installing into a private area because you might accidentally remove modules that other people depend on that are not using the private area.</source>
          <target state="translated">もう一つ覚えておいてほしいのは、プライベートエリアにインストールする際に UNINST パラメータが危険な場合があるということです。</target>
        </trans-unit>
        <trans-unit id="fc7600b26c92e308f5a7b9737781947f5e033b05" translate="yes" xml:space="preserve">
          <source>Another thorough remedy to that runtime vs. compile-time trap is to use &lt;a href=&quot;http://search.cpan.org/perldoc/Exporter::Easy&quot;&gt;Exporter::Easy&lt;/a&gt;, which is a wrapper of Exporter that allows all boilerplate code at a single gulp in the use statement.</source>
          <target state="translated">ランタイムトラップとコンパイル時のトラップに対するもう1つの完全な対策は、&lt;a href=&quot;http://search.cpan.org/perldoc/Exporter::Easy&quot;&gt;Exporter :: Easy&lt;/a&gt;を使用することです。これは、すべてのボイラープレートコードをuseステートメントの単一の一括で許可するExporterのラッパーです。</target>
        </trans-unit>
        <trans-unit id="8f128db16727c4206b263e3f2e5e2f91028aada1" translate="yes" xml:space="preserve">
          <source>Another typical use of redispatch would be in &lt;code&gt;AUTOLOAD&lt;/code&gt; 'ed methods. If such a method determined that it was not able to handle a particular call, it might choose to redispatch that call, in the hope that some other &lt;code&gt;AUTOLOAD&lt;/code&gt; (above it, or to its left) might do better.</source>
          <target state="translated">再ディスパッチのもう1つの一般的な使用法は、 &lt;code&gt;AUTOLOAD&lt;/code&gt; されたメソッドでの使用です。そのようなメソッドが特定の呼び出しを処理できなかったと判断した場合、他の &lt;code&gt;AUTOLOAD&lt;/code&gt; （その上またはその左側）がより良い結果を期待できるように、その呼び出しを再ディスパッチすることを選択できます。</target>
        </trans-unit>
        <trans-unit id="28f35e8d306941d11adce5505a92ca2044351acf" translate="yes" xml:space="preserve">
          <source>Another unofficial source of data. Currently, it is not used to get data, but the notes and explanatory material were very useful for understanding discrepancies between the sources.</source>
          <target state="translated">もう一つの非公式なデータソース。現在はデータ取得には使われていませんが、ノートや解説資料はソース間の齟齬を把握するのに非常に役立ちました。</target>
        </trans-unit>
        <trans-unit id="a159ba74ceaa166e4b6d8831134290b3cd8265be" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;MERGE&lt;/code&gt; is when you want both kinds of return values stored in the same disk file; this saves you from having to deal with two disk files instead of one. You can use a normalizer function to keep the two sets of return values separate. For example:</source>
          <target state="translated">&lt;code&gt;MERGE&lt;/code&gt; のもう1つの用途は、両方の種類の戻り値を同じディスクファイルに格納する場合です。これにより、1つではなく2つのディスクファイルを処理する必要がなくなります。ノーマライザ関数を使用して、2つの戻り値のセットを分離しておくことができます。例えば：</target>
        </trans-unit>
        <trans-unit id="3dd7e16e7ef3fb6df50c7af26f6bc9d68c338053" translate="yes" xml:space="preserve">
          <source>Another use for a closure is to make a variable</source>
          <target state="translated">クロージャのもう一つの用途は、変数を</target>
        </trans-unit>
        <trans-unit id="a46f51ca5d9afdb7291b96d0559a5eecba4e7c63" translate="yes" xml:space="preserve">
          <source>Another use for normalizers is when the function depends on data other than those in its arguments. Suppose you have a function which returns a value which depends on the current hour of the day:</source>
          <target state="translated">ノーマライザのもう一つの用途は、関数が引数以外のデータに依存している場合です。一日の現在の時間に依存した値を返す関数があるとしましょう。</target>
        </trans-unit>
        <trans-unit id="62444c7bc781846313fe8302369f08d7688eae95" translate="yes" xml:space="preserve">
          <source>Another use for the INIT: section is to check for preconditions before making a call to the C function:</source>
          <target state="translated">INIT:セクションのもう一つの用途は、C関数を呼び出す前に前提条件をチェックすることです。</target>
        </trans-unit>
        <trans-unit id="3a9f1ae19985a41ad9db3a10b2882d84afcc8d3c" translate="yes" xml:space="preserve">
          <source>Another use for typeglobs is to pass filehandles into a function or to create new filehandles. If you need to use a typeglob to save away a filehandle, do it this way:</source>
          <target state="translated">タイプグローブのもう一つの用途は、ファイルハンドルを関数に渡したり、新しいファイルハンドルを作成したりすることです。ファイルハンドルを保存するためにタイプグローブを使用する必要がある場合は、このようにしてください。</target>
        </trans-unit>
        <trans-unit id="385eea7f2546356b9012fe969f08ace72fffebdd" translate="yes" xml:space="preserve">
          <source>Another use of symbol tables is for making &quot;constant&quot; scalars.</source>
          <target state="translated">シンボルテーブルのもう一つの用途は、「定数」のスカラーを作るためのものです。</target>
        </trans-unit>
        <trans-unit id="7e444bc856c81853904c1c90381dc826b2163cfa" translate="yes" xml:space="preserve">
          <source>Another use of the generic object would be as a template. It is a convenient place to store class-specific defaults for various fields to be used in actual object initialization.</source>
          <target state="translated">ジェネリック・オブジェクトのもう一つの用途は、テンプレートとしての利用でしょう。これは、実際のオブジェクトの初期化で使用される様々なフィールドのクラス固有のデフォルトを格納するのに便利な場所です。</target>
        </trans-unit>
        <trans-unit id="03d707d0fcf79e0d7b50ca27287f1758fef3a3d9" translate="yes" xml:space="preserve">
          <source>Another useful shortcut is that, if you use a literal array or hash as the argument to &lt;code&gt;given&lt;/code&gt; , it is turned into a reference. So &lt;code&gt;given(@foo)&lt;/code&gt; is the same as &lt;code&gt;given(\@foo)&lt;/code&gt; , for example.</source>
          <target state="translated">別の便利なショートカットは、リテラル配列またはハッシュを &lt;code&gt;given&lt;/code&gt; の引数として使用する場合、それが参照に変わることです。したがって、 &lt;code&gt;given(@foo)&lt;/code&gt; は &lt;code&gt;given(\@foo)&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="4a05112cda91b50dc34bb4913074b7fa53fabce3" translate="yes" xml:space="preserve">
          <source>Another variation on a theme. This time we will modify the &lt;code&gt;Subst&lt;/code&gt; filter to allow a starting and stopping pattern to be specified as well as the</source>
          <target state="translated">テーマの別のバリエーション。今回は、 &lt;code&gt;Subst&lt;/code&gt; フィルターを変更して、開始パターンと停止パターン、および</target>
        </trans-unit>
        <trans-unit id="95d0ad8589b46d03f061e120707df66c84d9cbde" translate="yes" xml:space="preserve">
          <source>Another version uses a global match in list context, then assigns the result to a scalar, producing a count of the number of matches.</source>
          <target state="translated">別のバージョンでは、リストコンテキストでグローバルマッチを使用し、その結果をスカラに代入してマッチ数をカウントします。</target>
        </trans-unit>
        <trans-unit id="a0589db0a4f4f29bef401c1107ff7696f0cffdbb" translate="yes" xml:space="preserve">
          <source>Another way is to assign to a substr() that's off the end of the string.</source>
          <target state="translated">もう一つの方法は、文字列の末尾から外れた部分をsubstr()に代入することです。</target>
        </trans-unit>
        <trans-unit id="3c83abcaae94dfa04aa0d7e9c83f8b2a9880cd1b" translate="yes" xml:space="preserve">
          <source>Another way is to use the &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; module, which treats the entire file as an array. Simply access a random array element.</source>
          <target state="translated">別の方法は、ファイル全体を配列として扱う&lt;a href=&quot;tie/file&quot;&gt;Tie :: File&lt;/a&gt;モジュールを使用することです。ランダムな配列要素にアクセスするだけです。</target>
        </trans-unit>
        <trans-unit id="360771e8bfe1eade19d5dbc8ea8baae5f8a955ef" translate="yes" xml:space="preserve">
          <source>Another way is to use undef as an element on the left-hand-side:</source>
          <target state="translated">もう一つの方法は、左側の要素として undef を使用することです。</target>
        </trans-unit>
        <trans-unit id="f81299a8407385b954919f2cec05019d576de6e8" translate="yes" xml:space="preserve">
          <source>Another way to create anonymous filehandles is with the Symbol module or with the IO::Handle module and its ilk. These modules have the advantage of not hiding different types of the same name during the local(). See the bottom of &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for an example.</source>
          <target state="translated">匿名ファイルハンドルを作成する別の方法は、Symbolモジュール、またはIO :: Handleモジュールとそのilkを使用することです。これらのモジュールには、local（）中に同じ名前の異なるタイプを隠さないという利点があります。例については、&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;の下部を参照してください。</target>
        </trans-unit>
        <trans-unit id="e614c6db5b38b002f45562db1a27e62289c42947" translate="yes" xml:space="preserve">
          <source>Another way to debug compile-time code is to start the debugger, set a breakpoint on the</source>
          <target state="translated">コンパイル時のコードをデバッグするもう一つの方法は、デバッガを起動して</target>
        </trans-unit>
        <trans-unit id="9901f72c76524abdcc53f059c75aff5db9ab2a29" translate="yes" xml:space="preserve">
          <source>Another way to declare &lt;code&gt;host&lt;/code&gt; is to use a C block in the CODE: section:</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; を宣言する別の方法は、CODE：セクションでCブロックを使用することです。</target>
        </trans-unit>
        <trans-unit id="205baf27defe296be93a335acebfa113cc8193c2" translate="yes" xml:space="preserve">
          <source>Another way to disable the safe signal behavior locally is to use the &lt;code&gt;Perl::Unsafe::Signals&lt;/code&gt; module from CPAN, which affects all signals.</source>
          <target state="translated">安全な信号動作をローカルで無効にする別の方法は、CPANの &lt;code&gt;Perl::Unsafe::Signals&lt;/code&gt; モジュールを使用することです。これは、すべての信号に影響します。</target>
        </trans-unit>
        <trans-unit id="68459b39b80a3326501665280a8d6df2de3c0dc3" translate="yes" xml:space="preserve">
          <source>Another way to examine the tree is to use a compiler back-end module, such as &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="translated">ツリーを調べるもう1つの方法は、&lt;a href=&quot;b/concise&quot;&gt;B :: Concise&lt;/a&gt;などのコンパイラバックエンドモジュールを使用することです。</target>
        </trans-unit>
        <trans-unit id="1475dee12421b2759f280ec12406b6a9a8686bb7" translate="yes" xml:space="preserve">
          <source>Another way to lay hands on a reference to the underlying object is to use the tied() function, so they might alternately have set clobber using:</source>
          <target state="translated">基底オブジェクトへの参照に手を置くもう一つの方法は tied()関数を使用することで、彼らは交互に clobber をセットしているかもしれません。</target>
        </trans-unit>
        <trans-unit id="00149c3d1137c9330feb23e2fe36062f95ccc0ba" translate="yes" xml:space="preserve">
          <source>Another way to look at it is via bits:</source>
          <target state="translated">別の見方としては、ビットを経由したものがあります。</target>
        </trans-unit>
        <trans-unit id="87cb792899401773acea6f65b31b31644b7caaf0" translate="yes" xml:space="preserve">
          <source>Another way to modify &lt;code&gt;@INC&lt;/code&gt; without modifying the program, is to use the &lt;code&gt;lib&lt;/code&gt; pragma, e.g.:</source>
          <target state="translated">プログラムを変更せずに &lt;code&gt;@INC&lt;/code&gt; を変更する別の方法は、 &lt;code&gt;lib&lt;/code&gt; プラグマを使用することです。例：</target>
        </trans-unit>
        <trans-unit id="53f5ac93c7a0f074f16d88622079abd1a07b9541" translate="yes" xml:space="preserve">
          <source>Another way to see the output of a PM program is to run it as</source>
          <target state="translated">PMプログラムの出力を見るもう一つの方法は、次のように実行することです。</target>
        </trans-unit>
        <trans-unit id="60d4191bfc5b5a27fe1df7d104bb0fb301db392c" translate="yes" xml:space="preserve">
          <source>Another way to skip over characters in a UTF-8 string is to use &lt;code&gt;utf8_hop&lt;/code&gt; , which takes a string and a number of characters to skip over. You're on your own about bounds checking, though, so don't use it lightly.</source>
          <target state="translated">UTF-8文字列の文字をスキップする別の方法は、文字列とスキップする文字数を &lt;code&gt;utf8_hop&lt;/code&gt; を使用することです。ただし、境界チェックについては自分で決めるので、軽く使用しないでください。</target>
        </trans-unit>
        <trans-unit id="ebbeb1bfc20bbb2eabb0051011fd1f94e30bfced" translate="yes" xml:space="preserve">
          <source>Another way to specify many INSTALL directories with a single parameter is LIB.</source>
          <target state="translated">1つのパラメータで多くのinstallディレクトリを指定するもう一つの方法はLIBです。</target>
        </trans-unit>
        <trans-unit id="ab320674027c2ae8c6c6ac4c9c8202490be618cd" translate="yes" xml:space="preserve">
          <source>Another way to write &lt;code&gt;Is_latin_1()&lt;/code&gt; would be to use the characters in the range explicitly:</source>
          <target state="translated">&lt;code&gt;Is_latin_1()&lt;/code&gt; を記述する別の方法は、範囲内の文字を明示的に使用することです。</target>
        </trans-unit>
        <trans-unit id="697b561300a9259946d1254bc1d65f626fe87539" translate="yes" xml:space="preserve">
          <source>Any $(FOO) used in the examples are make variables, not Perl.</source>
          <target state="translated">例で使用されている $(FOO)はすべて make 変数であり、Perl ではありません。</target>
        </trans-unit>
        <trans-unit id="bea7ca75aae1ff5f6e730010d46af50a09d7d1c8" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;user-defined property&lt;/a&gt; used must be already defined by the time the regular expression is compiled (but note that this construct can be used instead of such properties).</source>
          <target state="translated">使用する&lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;ユーザー定義のプロパティ&lt;/a&gt;は、正規表現がコンパイルされる時点ですでに定義されている必要があります（ただし、この構成はこのようなプロパティの代わりに使用できることに注意してください）。</target>
        </trans-unit>
        <trans-unit id="31e755c53eda86352ddd4b11acb45031c2d27960" translate="yes" xml:space="preserve">
          <source>Any &lt;b&gt;class method&lt;/b&gt;, &lt;b&gt;instance&lt;/b&gt;, or &lt;b&gt;subroutine&lt;/b&gt; that composes, initializes, blesses, and returns an &lt;b&gt;object&lt;/b&gt;. Sometimes we use the term loosely to mean a &lt;b&gt;composer&lt;/b&gt;.</source>
          <target state="translated">任意の&lt;b&gt;クラスメソッド&lt;/b&gt;、&lt;b&gt;インスタンス&lt;/b&gt;、または&lt;b&gt;サブルーチン&lt;/b&gt;構成、初期化、祝福、戻るその&lt;b&gt;オブジェクト&lt;/b&gt;。時々、&lt;b&gt;作曲家&lt;/b&gt;を意味するために大まかにこの用語を使用します。</target>
        </trans-unit>
        <trans-unit id="ebc443723afa597f0f46ae7e71ea2b268b18eec2" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;\&lt;/code&gt; (backslashes) are converted to &lt;code&gt;/&lt;/code&gt; (forward slashes), and then File::Spec::Unix canonpath() is called on the result.</source>
          <target state="translated">どれ &lt;code&gt;\&lt;/code&gt; （バックスラッシュ）に変換されます &lt;code&gt;/&lt;/code&gt; （スラッシュ）、[ファイル::スペックは:: Unixのcanonpath（）結果に呼ばれています。</target>
        </trans-unit>
        <trans-unit id="0297ad87a59e1b9acfbd34804e1d88eb60665363" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;make&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; is run unconditionally. An</source>
          <target state="translated">どれ &lt;code&gt;make&lt;/code&gt; や &lt;code&gt;test&lt;/code&gt; 無条件に実行されます。あ</target>
        </trans-unit>
        <trans-unit id="3cd3503f8d612240a0cdcfcf3958cd4b47fd1bc1" translate="yes" xml:space="preserve">
          <source>Any SV may be magical, that is, it has special features that a normal SV does not have. These features are stored in the SV structure in a linked list of &lt;code&gt;struct magic&lt;/code&gt; 's, typedef'ed to &lt;code&gt;MAGIC&lt;/code&gt; .</source>
          <target state="translated">どのSVも魔法のようです。つまり、通常のSVにはない特別な機能があります。これらの機能は、 &lt;code&gt;MAGIC&lt;/code&gt; にtypedefされた &lt;code&gt;struct magic&lt;/code&gt; のリンクリストのSV構造に格納されます。</target>
        </trans-unit>
        <trans-unit id="3990dd07c484552abc78d056ff16c2e2a8e23114" translate="yes" xml:space="preserve">
          <source>Any additional arguments are expected to be names of modules to generate code for.</source>
          <target state="translated">追加の引数には、コードを生成するモジュールの名前を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="33e9e1331c3f51ebe91a9bc05248aec433c1afce" translate="yes" xml:space="preserve">
          <source>Any additional arguments found before the &lt;b&gt;--&lt;/b&gt; token are expected to be names of modules to generate code for.</source>
          <target state="translated">&lt;b&gt;-&lt;/b&gt;トークンの前にある追加の引数は、コードを生成するモジュールの名前であると想定されます。</target>
        </trans-unit>
        <trans-unit id="c6e53a3422c150f8910984634fe5fc4926bb37bc" translate="yes" xml:space="preserve">
          <source>Any additional flags you wish to pass to the linker.</source>
          <target state="translated">リンカに渡したい追加のフラグ。</target>
        </trans-unit>
        <trans-unit id="28fc9753c4799266fbd1d9873fa8ed5292bbf609" translate="yes" xml:space="preserve">
          <source>Any argument which looks like a signal name (that is, &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt; ) indicates that &lt;b&gt;sigtrap&lt;/b&gt; should install a handler for that name.</source>
          <target state="translated">シグナル名のように見える引数（つまり、 &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt; ）は、&lt;b&gt;sigtrap&lt;/b&gt;がその名前のハンドラーをインストールする必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="669f46fd59266a6910f9368caa3825ce94a0d579" translate="yes" xml:space="preserve">
          <source>Any arguments after the second '--' token are additional linker arguments that will be examined for potential conflict. If there is no conflict, the additional arguments will be part of the output.</source>
          <target state="translated">2 番目の '--' トークンの後の引数は、競合の可能性があるかどうか検査される追加のリンカ引数です。競合がなければ、追加の引数は出力の一部となります。</target>
        </trans-unit>
        <trans-unit id="b8ba7c975cc3879d276e04e3e9eb8ad2f669d5cb" translate="yes" xml:space="preserve">
          <source>Any arguments passed in show up in the array &lt;code&gt;@_&lt;/code&gt; . (They may also show up in lexical variables introduced by a signature; see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt; below.) Therefore, if you called a function with two arguments, those would be stored in &lt;code&gt;$_[0]&lt;/code&gt; and &lt;code&gt;$_[1]&lt;/code&gt; . The array &lt;code&gt;@_&lt;/code&gt; is a local array, but its elements are aliases for the actual scalar parameters. In particular, if an element &lt;code&gt;$_[0]&lt;/code&gt; is updated, the corresponding argument is updated (or an error occurs if it is not updatable). If an argument is an array or hash element which did not exist when the function was called, that element is created only when (and if) it is modified or a reference to it is taken. (Some earlier versions of Perl created the element whether or not the element was assigned to.) Assigning to the whole array &lt;code&gt;@_&lt;/code&gt; removes that aliasing, and does not update any arguments.</source>
          <target state="translated">渡された引数は、配列 &lt;code&gt;@_&lt;/code&gt; に表示されます。（シグネチャによって導入されたレキシカル変数にも表示される場合があります。以下の「&lt;a href=&quot;#Signatures&quot;&gt;シグネチャ&lt;/a&gt;」を参照してください。）したがって、2つの引数で関数を呼び出すと、それらは &lt;code&gt;$_[0]&lt;/code&gt; および &lt;code&gt;$_[1]&lt;/code&gt; に格納されます。配列 &lt;code&gt;@_&lt;/code&gt; はローカル配列ですが、その要素は実際のスカラーパラメーターのエイリアスです。特に、要素 &lt;code&gt;$_[0]&lt;/code&gt; が更新されると、対応する引数が更新されます（更新できない場合はエラーが発生します）。引数が、関数が呼び出されたときに存在しなかった配列またはハッシュ要素である場合、その要素は、それが変更または参照された場合にのみ作成されます。 （一部の以前のバージョンのPerlは、要素が割り当てられているかどうかに関係なく、要素を作成していました。）配列全体 &lt;code&gt;@_&lt;/code&gt; に割り当てると、そのエイリアスが削除され、引数は更新されません。</target>
        </trans-unit>
        <trans-unit id="ff6247c19341895e60632e62b6ff63ef2ca7a1ee" translate="yes" xml:space="preserve">
          <source>Any attempt by the code in STRING to use an operator which is not permitted by the compartment will cause an error (at run-time of the main program but at compile-time for the code in STRING). The error is of the form &quot;'%s' trapped by operation mask...&quot;.</source>
          <target state="translated">STRING内のコードがコンパートメントで許可されていない演算子を使用しようとすると、エラーが発生します(メイン・プログラムの実行時にはエラーが発生しますが、STRING内のコードのコンパイル時にはエラーが発生します)。このエラーは &quot;'%s' trapped by operation mask...&quot; という形式のものです。</target>
        </trans-unit>
        <trans-unit id="813cebd9a54eacff09b02a5f15b34a12df0ec8d1" translate="yes" xml:space="preserve">
          <source>Any backslashed prototype character represents an actual argument that must start with that character (optionally preceded by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;), with the exception of &lt;code&gt;$&lt;/code&gt; , which will accept any scalar lvalue expression, such as &lt;code&gt;$foo = 7&lt;/code&gt; or &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt; . The value passed as part of &lt;code&gt;@_&lt;/code&gt; will be a reference to the actual argument given in the subroutine call, obtained by applying &lt;code&gt;\&lt;/code&gt; to that argument.</source>
          <target state="translated">バックスラッシュされたプロトタイプ文字は、その文字で始まる必要がある実際の引数を表します（オプションで、 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; が前に付きます）。ただし、 &lt;code&gt;$&lt;/code&gt; は例外で、 &lt;code&gt;$foo = 7&lt;/code&gt; や &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt; などのスカラーlvalue式を受け入れます&amp;gt; [0]。 &lt;code&gt;@_&lt;/code&gt; の一部として渡される値は、その引数に &lt;code&gt;\&lt;/code&gt; を適用することによって取得される、サブルーチン呼び出しで指定された実際の引数への参照になります。</target>
        </trans-unit>
        <trans-unit id="e8738a2a75fb40cb2ee10b2d9e2137a995a5cab3" translate="yes" xml:space="preserve">
          <source>Any call from a package to itself is safe.</source>
          <target state="translated">パッケージからそれ自身への呼び出しは安全です。</target>
        </trans-unit>
        <trans-unit id="4b72ee9b0cb5399c6a83f5d4a70d821be8027231" translate="yes" xml:space="preserve">
          <source>Any call from an internal Perl module is safe. (Nothing keeps user modules from marking themselves as internal to Perl, but this practice is discouraged.)</source>
          <target state="translated">内部 Perl モジュールからの呼び出しは安全です。(ユーザモジュールが自分自身をPerlの内部であるとマークしないようにするものはありませんが、これは推奨されていません)</target>
        </trans-unit>
        <trans-unit id="32561ad60b0d62ef81eb27f4c0654f92745f16b5" translate="yes" xml:space="preserve">
          <source>Any call to Perl's warning system (eg Carp itself) is safe. (This rule is what keeps it from reporting the error at the point where you call &lt;code&gt;carp&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt; .)</source>
          <target state="translated">Perlの警告システム（たとえば、Carp自体）への呼び出しはすべて安全です。（このルールにより、 &lt;code&gt;carp&lt;/code&gt; または &lt;code&gt;croak&lt;/code&gt; を呼び出した時点でエラーが報告されなくなります。）</target>
        </trans-unit>
        <trans-unit id="6be54b4dca13888b86e758e818195dea970243c9" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\d&lt;/code&gt; is matched by &lt;code&gt;\D&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; と一致しない文字はすべて &lt;code&gt;\D&lt;/code&gt; と一致します。</target>
        </trans-unit>
        <trans-unit id="072286fccc69e711078f97acb3c710b733c38c10" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\s&lt;/code&gt; is matched by &lt;code&gt;\S&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; 一致しない文字はすべて &lt;code&gt;\S&lt;/code&gt; 一致します。</target>
        </trans-unit>
        <trans-unit id="edd14be74c570e6d8f1d353ef998bd9cdb853857" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\w&lt;/code&gt; is matched by &lt;code&gt;\W&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; と一致しない文字はすべて &lt;code&gt;\W&lt;/code&gt; と一致します。</target>
        </trans-unit>
        <trans-unit id="e45bb18b3ba9ff92c60226f6eef9c2b785d393ac" translate="yes" xml:space="preserve">
          <source>Any character not part of the 65-character base64 subset is silently ignored. Characters occurring after a '=' padding character are never decoded.</source>
          <target state="translated">65文字のbase64サブセットに含まれない文字は、静かに無視されます。パディング文字「=」の後にある文字は、決してデコードされません。</target>
        </trans-unit>
        <trans-unit id="fdc4fb7a943f332e78ce7564ebae9fbe7a142c7e" translate="yes" xml:space="preserve">
          <source>Any character that is</source>
          <target state="translated">どんなキャラクターでも</target>
        </trans-unit>
        <trans-unit id="d1ae992eb64cfaf05e3391f63560921ed6515ef6" translate="yes" xml:space="preserve">
          <source>Any character with the General Category of Combining Mark (&lt;code&gt;\p{GC=M}&lt;/code&gt; ), which may be spacing or nonspacing. Some are even invisible. A sequence of combining characters following a grapheme base character together make up a single user-visible character called a &lt;b&gt;grapheme&lt;/b&gt;. Most but not all diacritics are combining characters, and vice versa.</source>
          <target state="translated">結合マークの一般的なカテゴリ（ &lt;code&gt;\p{GC=M}&lt;/code&gt; ）を持つ任意の文字。これは、間隔があってもなくてもかまいません。見えないものもあります。書記素の基本文字に続く文字を組み合わせたシーケンスは、&lt;b&gt;書記素&lt;/b&gt;と呼ばれる単一のユーザー表示文字を構成します。すべてではないがほとんどの発音区別符号は文字を組み合わせており、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="f47500f097947cd7ef6b655a33fe0adeaed93c8c" translate="yes" xml:space="preserve">
          <source>Any class derived from an overloaded class is also overloaded and inherits its operator implementations. If the same operator is overloaded in more than one ancestor then the implementation is determined by the usual inheritance rules.</source>
          <target state="translated">オーバーロードされたクラスから派生したクラスもオーバーロードされ、その演算子の実装を継承します。同じ演算子が複数の祖先でオーバーロードされている場合は、通常の継承ルールによって実装が決定されます。</target>
        </trans-unit>
        <trans-unit id="82762c13b8c241690349f9ba71914d3aafcada68" translate="yes" xml:space="preserve">
          <source>Any class for which this function returns true is &quot;universal&quot; in the sense that all classes potentially inherit methods from it.</source>
          <target state="translated">この関数が真を返すクラスは、すべてのクラスがメソッドを継承する可能性があるという意味で「普遍的」です。</target>
        </trans-unit>
        <trans-unit id="4c366c83fbe5661336d1ed5dad628d12372f6675" translate="yes" xml:space="preserve">
          <source>Any class may define hooks that will be called during the serialization and deserialization process on objects that are instances of that class. Those hooks can redefine the way serialization is performed (and therefore, how the symmetrical deserialization should be conducted).</source>
          <target state="translated">どのクラスでも、そのクラスのインスタンスであるオブジェクトのシリアライズとデシリアライズの処理中に呼び出されるフックを定義することができます。これらのフックはシリアライズの実行方法を再定義することができます(したがって、対称的なデシリアライズがどのように行われるべきか)。</target>
        </trans-unit>
        <trans-unit id="6e6281f412687ca7280049212c9dd37d5f605837" translate="yes" xml:space="preserve">
          <source>Any command not recognized by the debugger is directly executed (&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;'d) as Perl code in the current package. (The debugger uses the DB package for keeping its own state information.)</source>
          <target state="translated">デバッガーで認識されないコマンドは、現在のパッケージのPerlコードとして直接実行（ &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 'd）されます。（デバッガーは、独自の状態情報を保持するためにDBパッケージを使用します。）</target>
        </trans-unit>
        <trans-unit id="a8dc7e3add242376e935c5e7dec68c1bf0f28dae" translate="yes" xml:space="preserve">
          <source>Any committer may cherry-pick any commit from blead to a maint branch if they send mail to perl5-porters announcing their intent to cherry-pick a specific commit along with a rationale for doing so and at least two other committers respond to the list giving their assent. (This policy applies to current and former pumpkings, as well as other committers.)</source>
          <target state="translated">コミット者は誰でも、特定のコミットをチェリーピックする意図とその理由を明記したメールを perl5-porters に送り、少なくとも 2 人の他のコミット者がメーリングリストに返信して同意した場合、 blead から maint ブランチへのコミットをチェリーピックすることができます。(このポリシーは、現在のコミット者、以前のコミット者、他のコミット者にも適用されます)。</target>
        </trans-unit>
        <trans-unit id="b95f0a7c9cbc43fb72281273ec465950ff501fea" translate="yes" xml:space="preserve">
          <source>Any contained POSIX character classes, including things like &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\D&lt;/code&gt; respect the &lt;code&gt;/a&lt;/code&gt; (and &lt;code&gt;/aa&lt;/code&gt; ) modifiers.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; や &lt;code&gt;\D&lt;/code&gt; などの含まれるPOSIX文字クラスは、 &lt;code&gt;/a&lt;/code&gt; （および &lt;code&gt;/aa&lt;/code&gt; ）修飾子を尊重します。</target>
        </trans-unit>
        <trans-unit id="5db2df3ee56bd2a814ccc5209f324c5b3591842c" translate="yes" xml:space="preserve">
          <source>Any data types supported by &lt;a href=&quot;../threads/shared&quot;&gt;threads::shared&lt;/a&gt; can be passed via queues:</source>
          <target state="translated">&lt;a href=&quot;../threads/shared&quot;&gt;threads :: sharedで&lt;/a&gt;サポートされるすべてのデータ型は、キューを介して渡すことができます。</target>
        </trans-unit>
        <trans-unit id="500c84c6a69d3cbc0070a804d35fd877c67e676d" translate="yes" xml:space="preserve">
          <source>Any directory to prefix to the extraction path, if any</source>
          <target state="translated">抽出パスに接頭辞を付けたいディレクトリがあれば、それを指定します。</target>
        </trans-unit>
        <trans-unit id="fe63280e6a478a3a4b2a298d74baf468659f885a" translate="yes" xml:space="preserve">
          <source>Any existing</source>
          <target state="translated">既存の</target>
        </trans-unit>
        <trans-unit id="910f15fcdac4d39c624eb5925c6aedfca05cbd8f" translate="yes" xml:space="preserve">
          <source>Any extension to Perl, including those containing XSUBs, should have a Perl module to serve as the bootstrap which pulls the extension into Perl. This module will export the extension's functions and variables to the Perl program and will cause the extension's XSUBs to be linked into Perl. The following module will be used for most of the examples in this document and should be used from Perl with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; command as shown earlier. Perl modules are explained in more detail later in this document.</source>
          <target state="translated">XSUBを含むものを含む、Perlへの拡張には、Perlに拡張をプルするブートストラップとして機能するPerlモジュールが必要です。このモジュールは、拡張の関数と変数をPerlプログラムにエクスポートし、拡張のXSUBをPerlにリンクさせます。次のモジュールは、このドキュメントのほとんどの例で &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; され、前述のように、useコマンドを使用してPerlから使用する必要があります。Perlモジュールについては、このドキュメントの後半で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="25a23450424903dcd5fa1cc3d1a014ad157de4c5" translate="yes" xml:space="preserve">
          <source>Any extra arguments which shouldn't be passed on to &lt;code&gt;plan()&lt;/code&gt; should be stripped off by this method.</source>
          <target state="translated">&lt;code&gt;plan()&lt;/code&gt; に渡してはならない追加の引数は、このメソッドで取り除く必要があります。</target>
        </trans-unit>
        <trans-unit id="e812c3c14740bd790df37fd5ab976ff0e033c047" translate="yes" xml:space="preserve">
          <source>Any filehandles open at the time of the fork() will be dup()-ed. Thus, the files can be closed independently in the parent and child, but beware that the dup()-ed handles will still share the same seek pointer. Changing the seek position in the parent will change it in the child and vice-versa. One can avoid this by opening files that need distinct seek pointers separately in the child.</source>
          <target state="translated">fork()の時点で開いているファイルハンドルはすべて dup()-ed となります。このようにして、親と子でそれぞれ独立してファイルを閉じることができますが、 dup()されたハンドルは同じシークポインタを共有していることに注意してください。親側でシーク位置を変更すると、子側でもシーク位置が変更され、逆に子側でもシーク位置が変更されます。これを回避するには、別々のシークポインタを必要とするファイルを子プロセスで別々に開くようにします。</target>
        </trans-unit>
        <trans-unit id="187558535ccb5da9eca3826ba8e4d8b30ca76bc1" translate="yes" xml:space="preserve">
          <source>Any function in the list below may be used either with or without parentheses around its arguments. (The syntax descriptions omit the parentheses.) If you use parentheses, the simple but occasionally surprising rule is this: It</source>
          <target state="translated">以下のリストにある関数は、引数の周りに括弧を付けても付けなくても使用できます。(構文の説明では括弧は省略されています。)括弧を使用する場合、単純ですが時折驚くようなルールがあります。それは</target>
        </trans-unit>
        <trans-unit id="24c8f5e2946c066d9a62168dcf66b92198c6784a" translate="yes" xml:space="preserve">
          <source>Any keys for which the value is &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be ignored.</source>
          <target state="translated">値が &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; であるキーはすべて無視されます。</target>
        </trans-unit>
        <trans-unit id="0c7f27e33616c341daf05c0b6c508f0fa8fdbd74" translate="yes" xml:space="preserve">
          <source>Any keys for which the value is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be ignored.</source>
          <target state="translated">値が &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; であるキーはすべて無視されます。</target>
        </trans-unit>
        <trans-unit id="204edb5197689fcdc449ffc64469cd176c221d73" translate="yes" xml:space="preserve">
          <source>Any large IRC network (Dalnet, EFnet) is also likely to have a #perl channel, with varying activity levels.</source>
          <target state="translated">大規模な IRC ネットワーク (Dalnet,EFnet)は、アクティビティレベルが変化する #perl チャネルを持っている可能性があります。</target>
        </trans-unit>
        <trans-unit id="44271c2c405bf35e52ab0041e6847e60ca1ca0c2" translate="yes" xml:space="preserve">
          <source>Any letters between &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt; act as flags modifiers as with &lt;code&gt;(?adluimsx-imsx)&lt;/code&gt; . For example,</source>
          <target state="translated">の間の任意の文字 &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt; ( &lt;code&gt;(?adluimsx-imsx)&lt;/code&gt; ようにフラグ修飾子として機能します。例えば、</target>
        </trans-unit>
        <trans-unit id="5618684dee489724ebf8f57ba00718b3f30e3494" translate="yes" xml:space="preserve">
          <source>Any method calls on an object created with &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; will be dispatched to the package as a normal object.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 作成されたオブジェクトに対するメソッド呼び出しは、通常のオブジェクトとしてパッケージにディスパッチされます。</target>
        </trans-unit>
        <trans-unit id="125ade77b67e2c4cd7a637af74e96e943bde8b70" translate="yes" xml:space="preserve">
          <source>Any methods marked</source>
          <target state="translated">マークのついたメソッド</target>
        </trans-unit>
        <trans-unit id="c1aa612608eba8166ce338b4b530d56d4e20399c" translate="yes" xml:space="preserve">
          <source>Any methods not listed here are derived from Math::BigFloat (or Math::BigInt), so make sure you check these two modules for further information.</source>
          <target state="translated">ここに記載されていないメソッドはすべて Math::BigFloat (または Math::BigInt)から派生したものなので、詳細についてはこの 2 つのモジュールを確認するようにしてください。</target>
        </trans-unit>
        <trans-unit id="9782a834fd90fe5d5545a24d61a39706e25bf926" translate="yes" xml:space="preserve">
          <source>Any mixture is possible. For example, the most frequently used options could be stored in variables while all other options get stored in the hash:</source>
          <target state="translated">どのような混合物も可能です。例えば、最もよく使われるオプションは変数に格納され、他のオプションはハッシュに格納されます。</target>
        </trans-unit>
        <trans-unit id="d9afc9d2e9f12a7ae747d6b9bda2062ad21b9fd2" translate="yes" xml:space="preserve">
          <source>Any names which are not tags are added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; unchanged but will trigger a warning (with &lt;code&gt;-w&lt;/code&gt; ) to avoid misspelt tags names being silently added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; . Future versions may make this a fatal error.</source>
          <target state="translated">タグではない名前は、変更されずに &lt;code&gt;@EXPORT&lt;/code&gt; または &lt;code&gt;@EXPORT_OK&lt;/code&gt; に追加されますが、警告がトリガーされ（ &lt;code&gt;-w&lt;/code&gt; を使用）、ミススペルタグ名が &lt;code&gt;@EXPORT&lt;/code&gt; または &lt;code&gt;@EXPORT_OK&lt;/code&gt; に暗黙的に追加されないようにします。将来のバージョンでは、これは致命的なエラーになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="485a3dceff3fe3343086f55cd7ded47422eb7429" translate="yes" xml:space="preserve">
          <source>Any newlines in $perl_code will be escaped. Leading and trailing newlines will be stripped. Makes this idiom much easier:</source>
          <target state="translated">perl_code内のすべての改行はエスケープされます。先頭と末尾の改行は除去されます。このイディオムをより簡単にします。</target>
        </trans-unit>
        <trans-unit id="85505e3e03d4cfb2c5d76c353aad39b235819057" translate="yes" xml:space="preserve">
          <source>Any non-whitespace delimiter may replace the slashes. Add space after the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; when using a character allowed in identifiers. If single quotes are used, no interpretation is done on the replacement string (the &lt;code&gt;/e&lt;/code&gt; modifier overrides this, however). Note that Perl treats backticks as normal delimiters; the replacement text is not evaluated as a command. If the</source>
          <target state="translated">空白以外の区切り文字はスラッシュを置き換えることができます。識別子で使用できる文字を使用する場合は、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; の後にスペースを追加します。一重引用符が使用されている場合、置換文字列は解釈されません（ただし、 &lt;code&gt;/e&lt;/code&gt; 修飾子はこれをオーバーライドします）。Perlはバックティックを通常の区切り文字として扱うことに注意してください。置換テキストはコマンドとして評価されません。もし</target>
        </trans-unit>
        <trans-unit id="21321c35f59a007bf7dcddd13bebabd646dd3b58" translate="yes" xml:space="preserve">
          <source>Any number of &lt;code&gt;(*PRUNE)&lt;/code&gt; assertions may be used in a pattern.</source>
          <target state="translated">任意の数の &lt;code&gt;(*PRUNE)&lt;/code&gt; アサーションをパターンで使用できます。</target>
        </trans-unit>
        <trans-unit id="8bc2478d6a5974c2f338a393e6f6ea8ec88b251c" translate="yes" xml:space="preserve">
          <source>Any number of arguments can occur in the list before the array but the input and output arrays must be the last elements in the list.</source>
          <target state="translated">配列の前には任意の数の引数をリストに入れることができますが、入力配列と出力配列はリストの最後の要素でなければなりません。</target>
        </trans-unit>
        <trans-unit id="637eecabf535d7591a4a05a68e784539a4cbb56d" translate="yes" xml:space="preserve">
          <source>Any number of tildes and surrounding whitespace will be collapsed to a single space.</source>
          <target state="translated">任意の数のチルダとその周囲のホワイトスペースは、1つのスペースに折りたたまれます。</target>
        </trans-unit>
        <trans-unit id="799d3a594ea06ab8f69431e4521092706a0ca250" translate="yes" xml:space="preserve">
          <source>Any of the bit masks can also be undef. The timeout, if specified, is in seconds, which may be fractional. Note: not all implementations are capable of returning the $timeleft. If not, they always return $timeleft equal to the supplied $timeout.</source>
          <target state="translated">ビットマスクのいずれかを undef にすることもできます。タイムアウトが指定されている場合は、秒単位で指定します。注意:すべての実装が $timeleft を返すことができるわけではありません。そうでない場合は、常に与えられた $timeout と等しい $timeleft を返します。</target>
        </trans-unit>
        <trans-unit id="96dac77ef4a45d1d47b4f15ad920f1efda518fb4" translate="yes" xml:space="preserve">
          <source>Any of these modifiers can be set to apply globally to all regular expressions compiled within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; . See &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;'/flags' mode in re&lt;/a&gt;.</source>
          <target state="translated">これらの修飾子は、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; のスコープ内でコンパイルされたすべての正規表現にグローバルに適用されるように設定できます。&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;reの「/ flags」モードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d72e7a2b4416a01397ed95a3d69723c275ceb3de" translate="yes" xml:space="preserve">
          <source>Any of these statements are nice replacements for &lt;code&gt;BEGIN { &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter; @ISA = qw(Exporter); }&lt;/code&gt; with the same compile-time effect. The basic difference is that &lt;code&gt;base&lt;/code&gt; code interacts with declared &lt;code&gt;fields&lt;/code&gt; while &lt;code&gt;parent&lt;/code&gt; is a streamlined version of the older &lt;code&gt;base&lt;/code&gt; code to just establish the IS-A relationship.</source>
          <target state="translated">これらのステートメントはいずれも、 &lt;code&gt;BEGIN { &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter; @ISA = qw(Exporter); }&lt;/code&gt; 代わりに使用できます。@ISA = qw（エクスポーター）; }コンパイル時の効果は同じです。基本的な違いは、 &lt;code&gt;base&lt;/code&gt; コードは宣言された &lt;code&gt;fields&lt;/code&gt; と相互作用しますが、 &lt;code&gt;parent&lt;/code&gt; はIS-A関係を確立するためだけの古い &lt;code&gt;base&lt;/code&gt; コードの合理化されたバージョンです。</target>
        </trans-unit>
        <trans-unit id="54d3e07363608f1d20995e0548f7b8658feed7f4" translate="yes" xml:space="preserve">
          <source>Any omitted or empty regular expressions will default to &quot;.*&quot;. Please note that each regular expression given is implicitly anchored by adding &quot;^&quot; and &quot;$&quot; to the beginning and end. Also, if a given regular expression starts with a &quot;!&quot; character, then the expression is</source>
          <target state="translated">省略された正規表現や空の正規表現はデフォルトで &quot;.*&quot; となります。与えられた各正規表現は、最初と最後に&quot;^&quot;と&quot;$&quot;を追加することで、暗黙のうちにアンカーされていることに注意してください。また、与えられた正規表現が&quot;!&quot;文字で始まる場合、その正規表現は</target>
        </trans-unit>
        <trans-unit id="0f87f06eba2caf7b827d1f8e16065d83ac575560" translate="yes" xml:space="preserve">
          <source>Any other character it taken literally.</source>
          <target state="translated">他のキャラクターは、それが文字通り取られています。</target>
        </trans-unit>
        <trans-unit id="3effb550cd8c77527aa9de81743828a3b7722f93" translate="yes" xml:space="preserve">
          <source>Any other parameters specific to the method</source>
          <target state="translated">メソッドに固有のその他のパラメータ</target>
        </trans-unit>
        <trans-unit id="c9c0186423c77aa8d8e97bed87ca7acf745a240d" translate="yes" xml:space="preserve">
          <source>Any other return code means that a flush point was not found. If more data is available, &lt;code&gt;inflateSync&lt;/code&gt; can be called repeatedly with more compressed data until the flush point is found.</source>
          <target state="translated">その他の戻りコードは、フラッシュポイントが見つからなかったことを意味します。さらに多くのデータが利用可能な場合、フラッシュポイントが見つかるまで、より多くの圧縮データを使用して &lt;code&gt;inflateSync&lt;/code&gt; を繰り返し呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="26c9cefe7b574f70d77490b40ef9d059faa47f0c" translate="yes" xml:space="preserve">
          <source>Any parameters to be pushed onto the stack should be bracketed by the &lt;code&gt;PUSHMARK&lt;/code&gt; and &lt;code&gt;PUTBACK&lt;/code&gt; macros. The purpose of these two macros, in this context, is to count the number of parameters you are pushing automatically. Then whenever Perl is creating the &lt;code&gt;@_&lt;/code&gt; array for the subroutine, it knows how big to make it.</source>
          <target state="translated">スタックにプッシュされるパラメーターは、 &lt;code&gt;PUSHMARK&lt;/code&gt; および &lt;code&gt;PUTBACK&lt;/code&gt; マクロで囲む必要があります。この2つのマクロの目的は、このコンテキストでは、自動的にプッシュするパラメーターの数をカウントすることです。そうすれば、Perlがサブルーチン用の &lt;code&gt;@_&lt;/code&gt; 配列を作成するときはいつでも、その大きさを知っています。</target>
        </trans-unit>
        <trans-unit id="393576095a8de6bc0086f7597df6e48f941f115a" translate="yes" xml:space="preserve">
          <source>Any pattern containing a special backtracking verb that allows an argument has the special behaviour that when executed it sets the current package's &lt;code&gt;$REGERROR&lt;/code&gt; and &lt;code&gt;$REGMARK&lt;/code&gt; variables. When doing so the following rules apply:</source>
          <target state="translated">引数が実行されたときに、それが現在のパッケージのセットという特殊な振る舞いがあることができ、特殊なバックトラック動詞含む任意のパターン &lt;code&gt;$REGERROR&lt;/code&gt; と &lt;code&gt;$REGMARK&lt;/code&gt; 変数を。その際、次のルールが適用されます。</target>
        </trans-unit>
        <trans-unit id="0f7c0d8ab3a57bbfaec5da2f59e5489aaf2f7ee1" translate="yes" xml:space="preserve">
          <source>Any references that are the same as one of those passed in will be named &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">渡されたものと同じ参照はすべて &lt;code&gt;$VAR&lt;/code&gt; という名前になります</target>
        </trans-unit>
        <trans-unit id="d0947cd6471d04a9e9e7aba2d6ed254ce36b6a65" translate="yes" xml:space="preserve">
          <source>Any regular expression special characters in &lt;code&gt;$regex&lt;/code&gt; are still special, and the pattern still has to be valid or Perl will complain. For instance, in this pattern there is an unpaired parenthesis.</source>
          <target state="translated">&lt;code&gt;$regex&lt;/code&gt; 表現の特殊文字は依然として特殊であり、パターンは依然として有効である必要があります。そうしないと、Perlから不満が出ます。たとえば、このパターンでは、対になっていない括弧があります。</target>
        </trans-unit>
        <trans-unit id="fe7f6f318181e1a9721562694a44d98bb9f0d89c" translate="yes" xml:space="preserve">
          <source>Any scalar value that doesn&amp;rsquo;t evaluate to 0 or &lt;code&gt;&quot;&quot;&lt;/code&gt; .</source>
          <target state="translated">0または &lt;code&gt;&quot;&quot;&lt;/code&gt; に評価されないスカラー値。</target>
        </trans-unit>
        <trans-unit id="b9848f5389028c0e6f897c58baee24bbe4b4452b" translate="yes" xml:space="preserve">
          <source>Any scalar variable may carry PERL_MAGIC_collxfrm magic that contains the scalar data of the variable, but transformed to such a format that a normal memory comparison can be used to compare the data according to the locale settings.</source>
          <target state="translated">任意のスカラ変数は、その変数のスカラデータを含むPERL_MAGIC_collxfrmマジックを運ぶことができますが、通常のメモリ比較がロケール設定に従ってデータを比較するために使用できるような形式に変換されています。</target>
        </trans-unit>
        <trans-unit id="38fbec488780a53c892b68c97c1898064ef5cf3c" translate="yes" xml:space="preserve">
          <source>Any simple statement may optionally be followed by a</source>
          <target state="translated">任意の単純な文の後には、オプションで</target>
        </trans-unit>
        <trans-unit id="d57ad08ad6b4b977666be8da12ed7e9b3597a3e6" translate="yes" xml:space="preserve">
          <source>Any single character matches itself, unless it is a</source>
          <target state="translated">1つの文字がそれ自体にマッチするものは、それが</target>
        </trans-unit>
        <trans-unit id="f581a0aac4749093894a9605cfac9a184c97919e" translate="yes" xml:space="preserve">
          <source>Any special flags that might need to be passed to ld to create a shared library suitable for dynamic loading. It is up to the makefile to use it. (See &lt;a href=&quot;../config#lddlflags&quot;&gt;lddlflags in Config&lt;/a&gt;)</source>
          <target state="translated">動的ロードに適した共有ライブラリを作成するためにldに渡す必要のある特別なフラグ。それを使用するのはメイクファイル次第です。（&lt;a href=&quot;../config#lddlflags&quot;&gt;構成のlddlflagsを&lt;/a&gt;参照）</target>
        </trans-unit>
        <trans-unit id="cae1c49f6637fcf58ae140f395f043a2e193fb5a" translate="yes" xml:space="preserve">
          <source>Any statement within the body of a loop that can make a loop prematurely stop looping or skip an &lt;b&gt;iteration&lt;/b&gt;. Generally, you shouldn&amp;rsquo;t try this on roller coasters.</source>
          <target state="translated">ループが途中でループを停止したり、&lt;b&gt;反復を&lt;/b&gt;スキップしたりする可能性がある、ループの本体内のステートメント。一般的に、ジェットコースターではこれを試してはいけません。</target>
        </trans-unit>
        <trans-unit id="a7b963c94b597f0a356b5a56744621822590c340" translate="yes" xml:space="preserve">
          <source>Any string eval which is executed by code executing in a compartment, or by code called from code executing in a compartment, will be eval'd in the namespace of the compartment. This is potentially a serious problem.</source>
          <target state="translated">コンパートメント内で実行されたコードや、コンパートメント内で実行されたコードから呼び出されたコードによって実行された文字列evalは、コンパートメントの名前空間でevalされます。これは潜在的に深刻な問題です。</target>
        </trans-unit>
        <trans-unit id="8a7a9db7b2a7d9c3bc4a0371b24f090bb005ce01" translate="yes" xml:space="preserve">
          <source>Any switches in the &lt;code&gt;PERLDOC&lt;/code&gt; environment variable will be used before the command line arguments.</source>
          <target state="translated">&lt;code&gt;PERLDOC&lt;/code&gt; 環境変数のスイッチは、コマンドライン引数の前に使用されます。</target>
        </trans-unit>
        <trans-unit id="c697d8a2e427d5d56c9e1028dbc399fcc4b347e2" translate="yes" xml:space="preserve">
          <source>Any time after Perl starts running your main program. See also &lt;b&gt;compile phase&lt;/b&gt;. Run phase is mostly spent in &lt;b&gt;runtime&lt;/b&gt; but may also be spent in &lt;b&gt;compile time&lt;/b&gt; when &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Perlがメインプログラムの実行を開始した後。&lt;b&gt;コンパイルフェーズ&lt;/b&gt;も参照してください。実行フェーズは、ほとんどに費やされている&lt;b&gt;ランタイム&lt;/b&gt;もで過ごしたことがあり&lt;b&gt;、コンパイル時&lt;/b&gt;際に &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00807e0e44bec9e684bd05f5d6ca841ffb6f513c" translate="yes" xml:space="preserve">
          <source>Any time before Perl starts running your main program. See also &lt;b&gt;run phase&lt;/b&gt;. Compile phase is mostly spent in &lt;b&gt;compile time&lt;/b&gt;, but may also be spent in &lt;b&gt;runtime&lt;/b&gt; when &lt;code&gt;BEGIN&lt;/code&gt; blocks, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; declarations, or constant subexpressions are being evaluated. The startup and import code of any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; declaration is also run during compile phase.</source>
          <target state="translated">Perlがメインプログラムの実行を開始する前。&lt;b&gt;実行フェーズ&lt;/b&gt;も参照してください。コンパイルフェーズは、主に&lt;b&gt;コンパイル時&lt;/b&gt;に費やされ&lt;b&gt;ますが&lt;/b&gt;、 &lt;code&gt;BEGIN&lt;/code&gt; ブロックが宣言されているか &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 宣言が &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ないか、または定数の部分式が評価されている場合、&lt;b&gt;ランタイム&lt;/b&gt;にも費やされ&lt;b&gt;ます&lt;/b&gt;。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 宣言の起動およびインポートコードもコンパイルフェーズで実行されます。</target>
        </trans-unit>
        <trans-unit id="5bea195cc0120bd58a5f6ddfad70e861a932bba8" translate="yes" xml:space="preserve">
          <source>AnyDBM_File</source>
          <target state="translated">AnyDBM_File</target>
        </trans-unit>
        <trans-unit id="abf989fc06a7a8552843b93b1474a012067198d8" translate="yes" xml:space="preserve">
          <source>AnyDBM_File - provide framework for multiple DBMs</source>
          <target state="translated">AnyDBM_File-複数のDBM用のフレームワークを提供します。</target>
        </trans-unit>
        <trans-unit id="29c9b5ccd4a8843ac06d93de6db98a168d9747a5" translate="yes" xml:space="preserve">
          <source>Anyone interested in resurrecting this file should pull the old version from the MakeMaker CVS repository and contact makemaker@perl.org.</source>
          <target state="translated">このファイルの復活に興味がある人は、MakeMaker CVS リポジトリから古いバージョンを引っ張ってきて、makemaker@perl.org に連絡してください。</target>
        </trans-unit>
        <trans-unit id="f1313a33b13e0ad302add61f009e5344735237ef" translate="yes" xml:space="preserve">
          <source>Anything after this line is the description of XSUB functions. These descriptions are translated by &lt;b&gt;xsubpp&lt;/b&gt; into C code which implements these functions using Perl calling conventions, and which makes these functions visible from Perl interpreter.</source>
          <target state="translated">この行の後は、XSUB関数の説明です。これらの記述は、&lt;b&gt;xsubppによって&lt;/b&gt;、Perl呼び出し規約を使用してこれらの関数を実装し、Perlインタープリターからこれらの関数を見えるようにするCコードに変換されます。</target>
        </trans-unit>
        <trans-unit id="7767ddde79c4e54f955f8a8770af897489800878" translate="yes" xml:space="preserve">
          <source>Anything before this line is plain C code which describes which headers to include, and defines some convenience functions. No translations are performed on this part, apart from having embedded POD documentation skipped over (see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;) it goes into the generated output C file as is.</source>
          <target state="translated">この行の前の部分は、含めるヘッダーを記述し、いくつかの便利な関数を定義するプレーンなCコードです。埋め込まれたPODドキュメントをスキップすること（&lt;a href=&quot;perlpod&quot;&gt;perlpodを&lt;/a&gt;参照）を除いて、この部分では変換は行われず、生成された出力Cファイルにそのまま送られます。</target>
        </trans-unit>
        <trans-unit id="9e010e0ae6e0590e5e1834d00dd2ae5e4328a555" translate="yes" xml:space="preserve">
          <source>Anything between white space and an end of line within a &lt;code&gt;MANIFEST&lt;/code&gt; file is considered to be a comment. Any line beginning with # is also a comment. Beginning with ExtUtils::Manifest 1.52, a filename may contain whitespace characters if it is enclosed in single quotes; single quotes or backslashes in that filename must be backslash-escaped.</source>
          <target state="translated">空白と &lt;code&gt;MANIFEST&lt;/code&gt; ファイル内の行の終わりの間のすべてはコメントと見なされます。＃で始まる行もコメントです。ExtUtils :: Manifest 1.52以降、ファイル名が一重引用符で囲まれている場合、ファイル名に空白文字が含まれる可能性があります。そのファイル名の単一引用符またはバックスラッシュは、バックスラッシュでエスケープする必要があります。</target>
        </trans-unit>
        <trans-unit id="d23663e502213da0e6ba19093e62429d22e02845" translate="yes" xml:space="preserve">
          <source>Anything else is a Perl-specific convenience abbreviation. Specify one or more scripts by names if you want short names that are script-specific.</source>
          <target state="translated">それ以外のものは Perl 固有の便宜上の略語です。スクリプト固有の短い名前を付けたい場合は、1つ以上のスクリプトを名前で指定します。</target>
        </trans-unit>
        <trans-unit id="7d749de0de5c93aeb0a7eeebe5226cb0dd35304d" translate="yes" xml:space="preserve">
          <source>Anything in EXPR that matches PATTERN is taken to be a separator that separates the EXPR into substrings (called &quot;</source>
          <target state="translated">EXPRの中でPATTERNにマッチするものは、EXPRを部分文字列に分離するセパレータとして扱われます(これを&quot;</target>
        </trans-unit>
        <trans-unit id="beac50162375e06d01167c42cce2dc5426c4e092" translate="yes" xml:space="preserve">
          <source>Anything marked as BE is Big Endian (or network byte order) and LE is Little Endian (aka VAX byte order). For anything not marked either BE or LE, a character called Byte Order Mark (BOM) indicating the endianness is prepended to the string.</source>
          <target state="translated">BE とマークされているものはすべてビッグエンディアン(またはネットワークバイトオーダー)であり、LE はリトルエンディアン(別名 VAX バイトオーダー)です。BE または LE のいずれかにマークされていないものについては、エンディアンを示すバイト・オーダー・マーク (BOM)と呼ばれる文字が文字列の前に付加されます。</target>
        </trans-unit>
        <trans-unit id="595fc50992e17250599953061722960b35607014" translate="yes" xml:space="preserve">
          <source>Anything put here will be passed to MY::postamble() if you have one.</source>
          <target state="translated">ここに書かれたものは、もしあれば MY::postamble()に渡されます。</target>
        </trans-unit>
        <trans-unit id="eb489bfffc02c3f32a21cb7909eae48c47e3d9b4" translate="yes" xml:space="preserve">
          <source>Anything that follows &lt;code&gt;#&lt;/code&gt; is treated as a comment.</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; に続くものはすべてコメントとして扱われます。</target>
        </trans-unit>
        <trans-unit id="aaea73d52ae0a47a220342d260ea4c54a027d322" translate="yes" xml:space="preserve">
          <source>Anything you can legally say in a spot where a &lt;b&gt;value&lt;/b&gt; is required. Typically composed of &lt;b&gt;literals&lt;/b&gt;, &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;operators&lt;/b&gt;, &lt;b&gt;functions&lt;/b&gt;, and &lt;b&gt;subroutine&lt;/b&gt; calls, not necessarily in that order.</source>
          <target state="translated">&lt;b&gt;値&lt;/b&gt;が必要な場所で合法的に言えること。通常、&lt;b&gt;リテラル&lt;/b&gt;、&lt;b&gt;変数&lt;/b&gt;、&lt;b&gt;演算子&lt;/b&gt;、&lt;b&gt;関数&lt;/b&gt;、および&lt;b&gt;サブルーチン&lt;/b&gt;呼び出しで構成され&lt;b&gt;ますが&lt;/b&gt;、必ずしもこの順序である必要はありません。</target>
        </trans-unit>
        <trans-unit id="90ac4d3777dbcf43ec0f981e70e6cb4230e6e6f9" translate="yes" xml:space="preserve">
          <source>Anyway, here it is. Should run on perl v4 or greater. Maybe less.</source>
          <target state="translated">とにかく、これです。perl v4以上で動作するはずです。それ以下かもしれません。</target>
        </trans-unit>
        <trans-unit id="2e755b3358691db1161de932e3c7e74daf5374dd" translate="yes" xml:space="preserve">
          <source>Anyway, this is what you can do if you can't help yourself.</source>
          <target state="translated">とにかく、どうしようもない時には、これでいいのです。</target>
        </trans-unit>
        <trans-unit id="61fbeb450419f819d1d3fb527e61bbd77f1f245b" translate="yes" xml:space="preserve">
          <source>Anywhere you'd put an identifier (or chain of identifiers) as part of a variable or subroutine name, you can replace the identifier with a BLOCK returning a reference of the correct type. In other words, the previous examples could be written like this:</source>
          <target state="translated">変数名やサブルーチン名の一部として識別子(または識別子の連鎖)を置く場合はどこでも、識別子を正しい型の参照を返すブロックに置き換えることができます。言い換えれば、先ほどの例は次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="c4897c70becad60eb583b067e9239c22c138553c" translate="yes" xml:space="preserve">
          <source>Anywhere you'd put an identifier (or chain of identifiers) as part of a variable or subroutine name, you can replace the identifier with a simple scalar variable containing a reference of the correct type:</source>
          <target state="translated">変数名やサブルーチン名の一部として識別子(または識別子の連鎖)を置く場合はどこでも、その識別子を正しい型の参照を含む単純なスカラー変数に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="1152548ba48e279bc989a0c42814e21456001922" translate="yes" xml:space="preserve">
          <source>Apache::GZip Revisited</source>
          <target state="translated">Apache::GZip の再訪</target>
        </trans-unit>
        <trans-unit id="eef8ccdc1b5028a7590e9e7eb6807d9775169439" translate="yes" xml:space="preserve">
          <source>Apart from being non-portable to some operating systems, this made it difficult to use &lt;code&gt;gzopen&lt;/code&gt; in situations where you wanted to extract/create a gzip data stream that is embedded in a larger file, without having to resort to opening and closing the file multiple times.</source>
          <target state="translated">一部のオペレーティングシステムに移植できないことを &lt;code&gt;gzopen&lt;/code&gt; て、これにより、ファイルを複数回開いたり閉じたりすることなく、大きなファイルに埋め込まれているgzipデータストリームを抽出/作成したい状況でgzopenを使用することが困難になりました。回。</target>
        </trans-unit>
        <trans-unit id="4e3144b6ad1fe422c840b3431e9e995cf1a334a3" translate="yes" xml:space="preserve">
          <source>Apart from discussing the C interface provided by Perl for writing callbacks the document uses a series of examples to show how the interface actually works in practice. In addition some techniques for coding callbacks are covered.</source>
          <target state="translated">このドキュメントでは、Perl が提供するコールバックを書くための C インターフェースの説明の他に、実際にどのように動作するかを示すために、一連の例を使用しています。さらに、コールバックをコーディングするためのテクニックも紹介しています。</target>
        </trans-unit>
        <trans-unit id="6c594049f559b0aa030aaa7fc2712868c419ba1f" translate="yes" xml:space="preserve">
          <source>Apart from now being a boolean, the &lt;code&gt;$^W&lt;/code&gt; variable operates in exactly the same horrible uncontrolled global way, except that it cannot disable/enable default warnings.</source>
          <target state="translated">現在はブール値であることを除けば、 &lt;code&gt;$^W&lt;/code&gt; 変数は、デフォルトの警告を無効/有効にできないことを除いて、まったく同じように制御できないグローバルな方法で動作します。</target>
        </trans-unit>
        <trans-unit id="177ebac14cb8719946f6e7935d5609a89f70ecb3" translate="yes" xml:space="preserve">
          <source>Apart from the behavior described above, Perl does not expand multiple levels of interpolation. In particular, contrary to the expectations of shell programmers, back-quotes do</source>
          <target state="translated">上記の動作とは別に、Perl は複数レベルの補間を展開しません。特に、シェルプログラマの期待に反して、バッククォートは</target>
        </trans-unit>
        <trans-unit id="5e5b5fcfebfb49c5cb95c4adedad19fe315234ce" translate="yes" xml:space="preserve">
          <source>Apart from the first parameter, import can accept an optional list of parameters. These can be used to pass parameters to the filter. For example:</source>
          <target state="translated">最初のパラメータとは別に、 import はオプションでパラメータのリストを受け取ることができます。これらを使ってフィルタにパラメータを渡すことができます。たとえば次のようになります。</target>
        </trans-unit>
        <trans-unit id="ea290b2592c04a29efbf4275fbffd4e15c783ad7" translate="yes" xml:space="preserve">
          <source>Apart from the overstrike, it in all ways functions like Pod::Text. See &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">重ね打ちは別として、あらゆる点でPod :: Textのように機能します。参照&lt;a href=&quot;../text&quot;&gt;ポッド::テキスト&lt;/a&gt;詳細と利用可能なオプションのために。</target>
        </trans-unit>
        <trans-unit id="59fd50fcdac085cfabfc65f7db775038f8cecc31" translate="yes" xml:space="preserve">
          <source>App::Prove</source>
          <target state="translated">App::Prove</target>
        </trans-unit>
        <trans-unit id="3a1656ea85b06be3923d0763368c6414c09514c6" translate="yes" xml:space="preserve">
          <source>App::Prove - Implements the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">App :: Prove- &lt;code&gt;prove&lt;/code&gt; コマンドを実装します。</target>
        </trans-unit>
        <trans-unit id="7174791288d36e70929f8c68ba39037f796046e4" translate="yes" xml:space="preserve">
          <source>App::Prove::State</source>
          <target state="translated">App::Prove::State</target>
        </trans-unit>
        <trans-unit id="39ce25b85982de5bdaced90b86fd5469adc9a51a" translate="yes" xml:space="preserve">
          <source>App::Prove::State - State storage for the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">App :: Prove :: State- &lt;code&gt;prove&lt;/code&gt; コマンドの状態ストレージ。</target>
        </trans-unit>
        <trans-unit id="96f79883bf2f299a489c18241a0f9c3ce22137d2" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result</source>
          <target state="translated">App::Prove::State::Result</target>
        </trans-unit>
        <trans-unit id="604c79e231e51591da6ce53e73549980b6c066b2" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result - Individual test suite results.</source>
          <target state="translated">App::Prove::State::Result-個々のテストスイートの結果。</target>
        </trans-unit>
        <trans-unit id="83a53d94c22845a17e42b81ff706d21b9d9578b9" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result::Test</source>
          <target state="translated">App::Prove::State::Result::Test</target>
        </trans-unit>
        <trans-unit id="dcd1440850fc9e2913d7cf105103afc698a85230" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result::Test - Individual test results.</source>
          <target state="translated">App::Prove::State::Result::Test-個別のテスト結果。</target>
        </trans-unit>
        <trans-unit id="a04f6596455dd68a60a8ad9f2a7176ca7fb0ee44" translate="yes" xml:space="preserve">
          <source>Apparently, IBM used a compiler (for some period of time around '95?) which changes FP mask right and left. This is not</source>
          <target state="translated">どうやらIBMはFPマスクを左右に変えるコンパイラを使っていたようです(95年頃のある時期?これは</target>
        </trans-unit>
        <trans-unit id="3c4496c4495e5c99d047e29d461a211122789431" translate="yes" xml:space="preserve">
          <source>Appeal to their self interest! If Perl is new (and thus scary) to them, find something that Perl can do to solve one of their problems. That might mean that Perl either saves them something (time, headaches, money) or gives them something (flexibility, power, testability).</source>
          <target state="translated">彼らの自己利益にアピールしてください! Perl が彼らにとって新しい(したがって怖い)ものであれば、Perl が彼らの問題の一つを解決するために何かできることを見つけてください。それは、Perlが彼らに何か(時間、頭痛、お金)を節約するか、何か(柔軟性、パワー、テスト可能性)を与えることを意味するかもしれません。</target>
        </trans-unit>
        <trans-unit id="b71dbc9f1f2c8f41b80953098f3e95dfa1012f02" translate="yes" xml:space="preserve">
          <source>Append an item to the list of ops contained directly within a list-type op, returning the lengthened list.</source>
          <target state="translated">list-type op内に直接含まれるopのリストに項目を追加し、長くなったリストを返します。</target>
        </trans-unit>
        <trans-unit id="becdeb6adee05d280a8a50e1526a1a849bef0624" translate="yes" xml:space="preserve">
          <source>Append elements of</source>
          <target state="translated">の要素を追加します。</target>
        </trans-unit>
        <trans-unit id="7b02fe45aa574073ed825bd38be9577b88d0ca63" translate="yes" xml:space="preserve">
          <source>Append elements of LIST to the array.</source>
          <target state="translated">LISTの要素を配列に追加します。</target>
        </trans-unit>
        <trans-unit id="89394607a467e98868ad0332e6c7061404a979e4" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;../../time/hires&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">各テストの実行時間を出力に追加します。使用&lt;a href=&quot;../../time/hires&quot;&gt;時間::ハイレゾを&lt;/a&gt;利用できます。</target>
        </trans-unit>
        <trans-unit id="f3320c1303317ee828f35f641012da0ef7ad78b8" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;../time/hires&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">各テストの実行時間を出力に追加します。使用&lt;a href=&quot;../time/hires&quot;&gt;時間::ハイレゾを&lt;/a&gt;利用できます。</target>
        </trans-unit>
        <trans-unit id="115b06d7e965b2c8ec031641d6914969c4847565" translate="yes" xml:space="preserve">
          <source>Appending the G_KEEPERR flag, so that the</source>
          <target state="translated">G_KEEPERR フラグを追加することで</target>
        </trans-unit>
        <trans-unit id="112a3bb05c1aa885c550b6193e7eaea408add2b6" translate="yes" xml:space="preserve">
          <source>Appends the given string or parse-tree or sequence object to the parse-tree of this interior sequence.</source>
          <target state="translated">与えられた文字列,構文解析木,シーケンスオブジェクトを,この内部シーケンスの構文解析木に追加します.</target>
        </trans-unit>
        <trans-unit id="6dd82bd12d46344a2006677b750f75da928a5f51" translate="yes" xml:space="preserve">
          <source>Application of the patches</source>
          <target state="translated">パッチの適用</target>
        </trans-unit>
        <trans-unit id="e91f35534bce18d06e39334fde833d8a1d0115a1" translate="yes" xml:space="preserve">
          <source>Application release September 2001, HP-UX 11.00 is the first to ship with Perl. By the time it was perl-5.6.1 in /opt/perl. The first occurrence is on CD 5012-7954 and can be installed using</source>
          <target state="translated">アプリケーションリリース 2001年9月、HP-UX 11.00はPerlが初めて出荷されました。その頃には/opt/perl に perl-5.6.1 が入っていた。最初の出現は CD 5012-7954 にあり、インストールには</target>
        </trans-unit>
        <trans-unit id="70dcb259ecf9216f358dc0f66966f145bfe54f70" translate="yes" xml:space="preserve">
          <source>Applies a syntactic context to an op tree representing an expression.</source>
          <target state="translated">式を表すオペツリーに構文コンテキストを適用する。</target>
        </trans-unit>
        <trans-unit id="d5ed3f5653497e355ed136e0b7c54a5982ace7b4" translate="yes" xml:space="preserve">
          <source>Applies dl_find_symbol() to the members of @dl_librefs and returns the first match found.</source>
          <target state="translated">dl_find_symbol()を @dl_librefs のメンバに適用し、最初に見つかったマッチを返します。</target>
        </trans-unit>
        <trans-unit id="197e68ad33f090de266ab7a82716d4dcf0c6223c" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; to the value returned by &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">ランダムな小数ではなくランダムな整数が必要な場合は、 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; が返す値に &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; を適用します。例えば、</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
