<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="8df52c6dbe1d57b617631599c530a100984708ce" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt; '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; accepts.</source>
          <target state="translated">新しいソルトを選択するとき、文字がセット &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; に由来するランダムな2文字の文字列を作成します（ &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt; '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ）。この文字セットは単なる推奨です。 saltで許可される文字はシステムのcryptライブラリにのみ依存し、Perlはsalt &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; が受け入れるものを制限できません。</target>
        </trans-unit>
        <trans-unit id="ba90a2d042a133e843c0ea1363bae85f48e8fd9f" translate="yes" xml:space="preserve">
          <source>When combined with variable declaration, simple scalar assignment to &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables (as in &lt;code&gt;state $x = 42&lt;/code&gt; ) is executed only the first time. When such statements are evaluated subsequent times, the assignment is ignored. The behavior of this sort of assignment to non-scalar variables is undefined.</source>
          <target state="translated">変数宣言と組み合わせると、 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 変数への単純なスカラー割り当て（ &lt;code&gt;state $x = 42&lt;/code&gt; ）は初めてのみ実行されます。そのようなステートメントがその後評価されるとき、割り当ては無視されます。この種の非スカラー変数への割り当ての動作は定義されていません。</target>
        </trans-unit>
        <trans-unit id="8723e913d037ae6e1a9af1f510a75733eba10e88" translate="yes" xml:space="preserve">
          <source>When comparing &lt;code&gt;$]&lt;/code&gt; , string comparison operators are &lt;b&gt;highly recommended&lt;/b&gt;. The inherent limitations of binary floating point representation can sometimes lead to incorrect comparisons for some numbers on some architectures.</source>
          <target state="translated">&lt;code&gt;$]&lt;/code&gt; を比較するときは、文字列比較演算子を使用することを&lt;b&gt;強くお勧めし&lt;/b&gt;ます。2進浮動小数点表現の固有の制限により、一部のアーキテクチャでは、一部の数値の比較が不正確になることがあります。</target>
        </trans-unit>
        <trans-unit id="9cb0233568f5abd1d88fb8340be5337623b26d31" translate="yes" xml:space="preserve">
          <source>When compiling Perl in Tru64 you may (depending on the compiler release) see two warnings like this</source>
          <target state="translated">Tru64 で Perl をコンパイルすると、(コンパイラのリリースによっては)以下のような 2 つの警告が表示されることがあります。</target>
        </trans-unit>
        <trans-unit id="bfc6666c4c5744908a4efd082506a76f331670ff" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. AIX does not ship an ANSI compliant C compiler with AIX by default, but binary builds of gcc for AIX are widely available. A version of gcc is also included in the AIX Toolbox which is shipped with AIX.</source>
          <target state="translated">Perlをコンパイルする際には、ANSI Cコンパイラを使用する必要があります。AIX には ANSI 準拠の C コンパイラはデフォルトでは同梱されていませんが、AIX 用の gcc のバイナリビルドは広く利用可能です。gcc のバージョンは AIX に同梱されている AIX Toolbox にも含まれています。</target>
        </trans-unit>
        <trans-unit id="f65988610c7d74b5ae9b07dd95c21b84e89fdc66" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. AIX does not ship an ANSI compliant C-compiler with AIX by default, but binary builds of gcc for AIX are widely available.</source>
          <target state="translated">Perlをコンパイルする際には、ANSI Cコンパイラを使用する必要があります。AIX には ANSI 準拠の C コンパイラはデフォルトでは搭載されていませんが、AIX 用の gcc のバイナリビルドは広く利用可能です。</target>
        </trans-unit>
        <trans-unit id="e54d0f630f4052fa4f5e8949b94bd1a858274b61" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. The C compiler that ships with all HP-UX systems is a K&amp;amp;R compiler that should only be used to build new kernels.</source>
          <target state="translated">Perlをコンパイルするときは、ANSI Cコンパイラを使用する必要があります。すべてのHP-UXシステムに同梱されているCコンパイラはK＆Rコンパイラであり、新しいカーネルの構築にのみ使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="396066667b73652500c61d9a6b382668c31190fa" translate="yes" xml:space="preserve">
          <source>When compiling in PASE, there is no &quot;oslevel&quot; command. Therefore, you may want to create a script called &quot;oslevel&quot; that echoes the level of AIX that your version of PASE runtime supports. If you're unsure, consult your documentation or use &quot;4.3.3.0&quot;.</source>
          <target state="translated">PASEでコンパイルする場合、&quot;oslevel &quot;コマンドはありません。そのため、あなたのバージョンの PASE ランタイムがサポートしている AIX のレベルをエコーする &quot;oslevel&quot; というスクリプトを作成するとよいでしょう。よくわからない場合は、ドキュメントを参照するか、&quot;4.3.3.3.0 &quot;を使用してください。</target>
        </trans-unit>
        <trans-unit id="975dca0ce3b92270da7ce263ccd6670142595f91" translate="yes" xml:space="preserve">
          <source>When complementing strings, if all characters have ordinal values under 256, then their complements will, also. But if they do not, all characters will be in either 32- or 64-bit complements, depending on your architecture. So for example, &lt;code&gt;~&quot;\x{3B1}&quot;&lt;/code&gt; is &lt;code&gt;&quot;\x{FFFF_FC4E}&quot;&lt;/code&gt; on 32-bit machines and &lt;code&gt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&lt;/code&gt; on 64-bit machines.</source>
          <target state="translated">文字列を補完する場合、すべての文字の序数値が256未満であれば、それらの補完も同様です。ただし、そうでない場合は、アーキテクチャに応じて、すべての文字が32ビットまたは64ビットの補数になります。そう例えば、 &lt;code&gt;~&quot;\x{3B1}&quot;&lt;/code&gt; である &lt;code&gt;&quot;\x{FFFF_FC4E}&quot;&lt;/code&gt; 32ビットマシンとに &lt;code&gt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&lt;/code&gt; 64ビットマシン。</target>
        </trans-unit>
        <trans-unit id="927dc05b306a20a322eed6c8168ca784ea3ed41b" translate="yes" xml:space="preserve">
          <source>When configured for bundling, single-character options are matched case sensitive while long options are matched case insensitive. To have the single-character options matched case insensitive as well, use:</source>
          <target state="translated">バンドル用に構成されている場合、1 文字のオプションは大文字と小文字が区別されますが、長いオプションは大文字と小文字が区別されません。一文字のオプションも大文字小文字を区別せずに一致させるには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="c4fb4623ce7c6c321834d001ce6f813a2fa89505" translate="yes" xml:space="preserve">
          <source>When creating and extending application programming interfaces (APIs) for Symbian or Series 60 or Series 80 or Series 90 it is suggested that trademarks, registered trademarks, or trade names are not used in the API names. Instead, developers should consider basing the API naming in the existing (C++, or maybe Java) public component and API naming, modified as appropriate by the rules of the programming language the new APIs are for.</source>
          <target state="translated">Symbian、Series 60、Series 80、Series 90 のためのアプリケーション・プログラミング・インターフェース(API)を作成したり拡張したりするとき、商標、登録商標、または商号を API 名に使用しないことが提案されています。代わりに、開発者は、既存の (C++、または多分 Java)パブリックコンポーネントと API の名前をベースにして、新しい API が対象とするプログラミング言語のルールによって適切に修正された API の名前を検討するべきです。</target>
        </trans-unit>
        <trans-unit id="8dc80c71b0aa717f38046cb0d740616e9bd6381f" translate="yes" xml:space="preserve">
          <source>When dealing with C structures one should select either &lt;b&gt;T_PTROBJ&lt;/b&gt; or &lt;b&gt;T_PTRREF&lt;/b&gt; for the XS type. Both types are designed to handle pointers to complex objects. The T_PTRREF type will allow the Perl object to be unblessed while the T_PTROBJ type requires that the object be blessed. By using T_PTROBJ one can achieve a form of type-checking because the XSUB will attempt to verify that the Perl object is of the expected type.</source>
          <target state="translated">C構造体を扱うときは、XSタイプに&lt;b&gt;T_PTROBJ&lt;/b&gt;または&lt;b&gt;T_PTRREF&lt;/b&gt;を選択する必要があります。どちらのタイプも、複雑なオブジェクトへのポインタを処理するように設計されています。T_PTRREF型では、Perlオブジェクトをunblessすることができますが、T_PTROBJ型では、オブジェクトをblessする必要があります。T_PTROBJを使用することにより、XSUBはPerlオブジェクトが予期されたタイプであることを確認しようとするため、タイプチェックの形式を実現できます。</target>
        </trans-unit>
        <trans-unit id="5ef807c417305a11bdb217741916eb3c09e8b5cd" translate="yes" xml:space="preserve">
          <source>When dealing with binary files (or text files in binary mode) be sure to explicitly set $/ to the appropriate value for your file format before using &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">バイナリファイル（またはバイナリモードのテキストファイル）を扱う場合は、 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; を使用する前に、$ /をファイル形式に適切な値に明示的に設定してください。</target>
        </trans-unit>
        <trans-unit id="d089cbb7da6fb1de4b8e802beb51489b821fccc7" translate="yes" xml:space="preserve">
          <source>When dealing with references, it is important to handle them with caution. The &lt;code&gt;INIT:&lt;/code&gt; block first calls SvGETMAGIC(paths), in case paths is a tied variable. Then it checks that &lt;code&gt;SvROK&lt;/code&gt; returns true, which indicates that paths is a valid reference. (Simply checking &lt;code&gt;SvROK&lt;/code&gt; won't trigger FETCH on a tied variable.) It then verifies that the object referenced by paths is an array, using &lt;code&gt;SvRV&lt;/code&gt; to dereference paths, and &lt;code&gt;SvTYPE&lt;/code&gt; to discover its type. As an added test, it checks that the array referenced by paths is non-empty, using the &lt;code&gt;av_top_index&lt;/code&gt; function (which returns -1 if the array is empty). The XSRETURN_UNDEF macro is used to abort the XSUB and return the undefined value whenever all three of these conditions are not met.</source>
          <target state="translated">参照を処理するときは、注意して扱うことが重要です。 &lt;code&gt;INIT:&lt;/code&gt; ブロックは、最初のケースパスに縛ら変数である、SvGETMAGIC（パス）を呼び出します。次に、 &lt;code&gt;SvROK&lt;/code&gt; がtrueを返すことを確認します。これは、パスが有効な参照であることを示します。 （ &lt;code&gt;SvROK&lt;/code&gt; を単純にチェックしても、関連付けられた変数のFETCHはトリガーされません。）次に、パスによって参照されるオブジェクトが配列であることを確認し、 &lt;code&gt;SvRV&lt;/code&gt; を使用してパスを逆参照し、 &lt;code&gt;SvTYPE&lt;/code&gt; を使用してそのタイプを検出します。追加のテストとして、 &lt;code&gt;av_top_index&lt;/code&gt; を使用して、パスによって参照される配列が空でないことを確認します関数（配列が空の場合は-1を返します）。XSRETURN_UNDEFマクロを使用して、XSUBを中止し、これら3つの条件がすべて満たされない場合は常に未定義の値を返します。</target>
        </trans-unit>
        <trans-unit id="38a7bf875048ed175efb40337595a64499d137a5" translate="yes" xml:space="preserve">
          <source>When dealing with strings containing characters that cannot be represented using an eight-bit character set, perl uses an internal representation that is a permissive version of Unicode's UTF-8 encoding[2]. This uses single bytes to represent characters from the ASCII character set, and sequences of two or more bytes for all other characters. (See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more information about the relationship between UTF-8 and perl's encoding, utf8. The difference isn't important for this discussion.)</source>
          <target state="translated">8ビット文字セットを使用して表現できない文字を含む文字列を処理する場合、perlは、UnicodeのUTF-8エンコーディングの許容バージョンである内部表現を使用します[2]。これは、1バイトを使用してASCII文字セットの文字を表し、他のすべての文字には2バイト以上のシーケンスを使用します。（UTF-8とperlのエンコーディングutf8の関係について詳しくは、&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;を参照してください。この説明では、違いは重要ではありません。）</target>
        </trans-unit>
        <trans-unit id="ec373fa59b49b953efac841d6f570fdf4b7bbe64" translate="yes" xml:space="preserve">
          <source>When debugging a script that uses #! and is thus normally found in $PATH, the -S option causes perl to search $PATH for it, so you don't have to type the path or &lt;code&gt;which $scriptname&lt;/code&gt; .</source>
          <target state="translated">＃！を使用するスクリプトをデバッグするとき したがって、通常は$ PATHにありますが、-Sオプションを指定すると、perlは$ PATHを検索して、パスや &lt;code&gt;which $scriptname&lt;/code&gt; を入力する必要がなくなります。</target>
        </trans-unit>
        <trans-unit id="f6fa41bd97a298d1cd8b0e0f363528cda01ea2a0" translate="yes" xml:space="preserve">
          <source>When defining multiple constants, you cannot use the values of other constants defined in the same declaration. This is because the calling package doesn't know about any constant within that group until</source>
          <target state="translated">複数の定数を定義する場合、同じ宣言で定義された他の定数の値を使用することはできません。これは、呼び出し元のパッケージがそのグループ内の定数について</target>
        </trans-unit>
        <trans-unit id="4723c71ed09d6ef17fa09da9076bcc24872495e5" translate="yes" xml:space="preserve">
          <source>When designing an interface between Perl and a C library a straight translation from C to XS (such as created by &lt;code&gt;h2xs -x&lt;/code&gt; ) is often sufficient. However, sometimes the interface will look very C-like and occasionally nonintuitive, especially when the C function modifies one of its parameters, or returns failure inband (as in &quot;negative return values mean failure&quot;). In cases where the programmer wishes to create a more Perl-like interface the following strategy may help to identify the more critical parts of the interface.</source>
          <target state="translated">PerlとCライブラリ間のインターフェースを設計する場合、CからXSへの直接変換（たとえば &lt;code&gt;h2xs -x&lt;/code&gt; で作成されたもの）で十分なことがよくあります。ただし、特にC関数がパラメーターの1つを変更したり、帯域内で障害を返す場合（特に、「負の戻り値は障害を意味する」のように）、インターフェイスが非常にCに似ていて、ときには直感的でない場合があります。プログラマーがよりPerlに似たインターフェースを作成したい場合は、以下の戦略がインターフェースのより重要な部分を識別するのに役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="1a3b14a33a7328d3c4446b4818b46b0e10681a93" translate="yes" xml:space="preserve">
          <source>When developing interactive and/or potentially long-running applications, it's a good idea to maintain a persistent interpreter rather than allocating and constructing a new interpreter multiple times. The major reason is speed: since Perl will only be loaded into memory once.</source>
          <target state="translated">インタラクティブなアプリケーションや、長期的に動作する可能性のあるアプリケーションを開発する場合、新しいインタプリタを何度も割り当てて構築するよりも、永続的なインタプリタを維持することをお勧めします。主な理由は、Perl がメモリにロードされるのは一度だけだからです。</target>
        </trans-unit>
        <trans-unit id="bf6878bf07602f9398e0aebf78788b970eee0437" translate="yes" xml:space="preserve">
          <source>When doing XS / Symbian C++ programming include first the Symbian headers, then any standard C/POSIX headers, then Perl headers, and finally any application headers.</source>
          <target state="translated">XS/Symbian C++プログラミングを行う際には、最初に Symbian ヘッダ、次に標準的な C/POSIX ヘッダ、Perl ヘッダ、そして最後にアプリケーションヘッダを含めるようにしてください。</target>
        </trans-unit>
        <trans-unit id="68e541a18f2f1ca2cdf86c535b1f959438918ee4" translate="yes" xml:space="preserve">
          <source>When downloading from CPAN, save your file with a &lt;code&gt;.tgz&lt;/code&gt; extension instead of &lt;code&gt;.tar.gz&lt;/code&gt;. All other periods in the filename should be replaced with underscores. For example, &lt;code&gt;Your-Module-1.33.tar.gz&lt;/code&gt; should be downloaded as &lt;code&gt;Your-Module-1_33.tgz&lt;/code&gt;.</source>
          <target state="translated">CPANからダウンロードする場合は、ファイルを &lt;code&gt;.tar.gz&lt;/code&gt; ではなく &lt;code&gt;.tgz&lt;/code&gt; 拡張子で保存します。ファイル名の他のピリオドはすべてアンダースコアに置き換える必要があります。たとえば、 &lt;code&gt;Your-Module-1.33.tar.gz&lt;/code&gt; は &lt;code&gt;Your-Module-1_33.tgz&lt;/code&gt; としてダウンロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="7a4bca7ef82b244e2bfab60f9ed2d006dc99b5fe" translate="yes" xml:space="preserve">
          <source>When each filter is called by Perl, a local copy of &lt;code&gt;$_&lt;/code&gt; will contain the key or value to be filtered. Filtering is achieved by modifying the contents of &lt;code&gt;$_&lt;/code&gt; . The return code from the filter is ignored.</source>
          <target state="translated">Perlによって各フィルターが呼び出されると、 &lt;code&gt;$_&lt;/code&gt; ローカルコピーにフィルターされるキーまたは値が含まれます。フィルタリングは、 &lt;code&gt;$_&lt;/code&gt; の内容を変更することによって実現されます。フィルターからの戻りコードは無視されます。</target>
        </trans-unit>
        <trans-unit id="d0a0c84572d5c8f36ddeeedc2b34034d9368a3d3" translate="yes" xml:space="preserve">
          <source>When embedded code is quantified, successful matches will call the code once for each matched iteration of the quantifier. For example:</source>
          <target state="translated">埋め込まれたコードが定量化されている場合、一致したコードは、定量化子の一致した繰り返しごとに一度だけコードを呼び出します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="b2de387631853c970d098f700c90774516567311" translate="yes" xml:space="preserve">
          <source>When evaluated, the typeglob produces a scalar value that represents all the objects of that name, including any filehandle, format, or subroutine. When assigned to, it causes the name mentioned to refer to whatever &lt;code&gt;*&lt;/code&gt; value was assigned to it. Example:</source>
          <target state="translated">評価されると、typeglobは、ファイルハンドル、フォーマット、またはサブルーチンを含む、その名前のすべてのオブジェクトを表すスカラー値を生成します。割り当てられている場合は、名前が何を参照するために言及した原因 &lt;code&gt;*&lt;/code&gt; それに割り当てられた値。例：</target>
        </trans-unit>
        <trans-unit id="4c69b020552d0b8ae9319c611f51330e0fd5df99" translate="yes" xml:space="preserve">
          <source>When exec() is called inside a pseudo-process then DESTROY methods and END blocks will still be called after the external process returns.</source>
          <target state="translated">exec()が疑似プロセス内で呼び出された場合、外部プロセスが戻ってきた後も DESTROY メソッドと END ブロックが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="8c7eebc997f4f93f028327a4f1ff0c0608dc29e2" translate="yes" xml:space="preserve">
          <source>When execution of the program reaches a subroutine call, a call to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</source>
          <target state="translated">プログラムの実行がサブルーチン呼び出しに到達すると、 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; （</target>
        </trans-unit>
        <trans-unit id="1b8b87da2107f5f6b07c4ad0b8f0c3bd9b3e2787" translate="yes" xml:space="preserve">
          <source>When execution of the program uses &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; to enter a non-XS subroutine and the 0x80 bit is set in &lt;code&gt;$^P&lt;/code&gt; , a call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; is made, with &lt;code&gt;$DB::sub&lt;/code&gt; holding the name of the subroutine being entered.</source>
          <target state="translated">プログラムの実行で &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; を使用して非XSサブルーチンを開始し、 &lt;code&gt;$^P&lt;/code&gt; に0x80ビットが設定されている場合、 &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; への呼び出しが行われ、 &lt;code&gt;$DB::sub&lt;/code&gt; に入力されたサブルーチンの名前が保持されます。</target>
        </trans-unit>
        <trans-unit id="a7780be4ab5e34307ca9834bebf3c5ea11f2bda2" translate="yes" xml:space="preserve">
          <source>When exitcode is non-zero, a message box appears, otherwise the console closes, so you might have to catch an exit with status 0 in your program to see any output.</source>
          <target state="translated">exitcode が 0 以外の場合はメッセージボックスが表示され、そうでない場合はコンソールが閉じます。</target>
        </trans-unit>
        <trans-unit id="b361c8c46cd947899ffa296e187a289b54d8046a" translate="yes" xml:space="preserve">
          <source>When field hashes are used, the basic structure remains the same. Each lexical hash will be made a field hash. The call to &lt;code&gt;refaddr&lt;/code&gt; can be omitted from the accessor methods. DESTROY and CLONE methods are not necessary.</source>
          <target state="translated">フィールドハッシュを使用しても、基本的な構造は変わりません。各字句ハッシュはフィールドハッシュになります。 &lt;code&gt;refaddr&lt;/code&gt; の呼び出しは、アクセサーメソッドから省略できます。DESTROYメソッドとCLONEメソッドは必要ありません。</target>
        </trans-unit>
        <trans-unit id="7ff1c534eb53fb9adf1f1f7cdd902bdbfec52451" translate="yes" xml:space="preserve">
          <source>When finding a program to run, Perl first asks the OS to look for executables on &lt;code&gt;PATH&lt;/code&gt; (OS/2 adds extension</source>
          <target state="translated">実行するプログラムを見つけると、Perlは最初にOSに &lt;code&gt;PATH&lt;/code&gt; で実行可能ファイルを探すように要求します（OS / 2は拡張子を追加します</target>
        </trans-unit>
        <trans-unit id="13a2688e14421cbafe067aeaa351f65e3474e11f" translate="yes" xml:space="preserve">
          <source>When finished, &lt;code&gt;$input&lt;/code&gt; will be completely processed (assuming there were no errors). If the deflation was successful it writes the deflated data to &lt;code&gt;$output&lt;/code&gt; and returns a status value of &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">終了すると、 &lt;code&gt;$input&lt;/code&gt; は完全に処理されます（エラーがないと仮定）。デフレが成功した場合、デフレしたデータを &lt;code&gt;$output&lt;/code&gt; に書き込み、ステータス値 &lt;code&gt;Z_OK&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="3d09ef2037aaa8553df4a9d1d56e3501c5f5a619" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is actually a flow control statement rather than a function. If there is a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; ), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement (which is similar to the C &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement).</source>
          <target state="translated">BLOCKが &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 場合、continueは実際には関数ではなくフロー制御ステートメントです。BLOCKに接続された &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK がある場合（通常、 &lt;code&gt;while&lt;/code&gt; または &lt;code&gt;foreach&lt;/code&gt; で）、Cの &lt;code&gt;for&lt;/code&gt; ループの3番目の部分のように、条件が再び評価される直前に常に実行されます。ループが &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ステートメント（C &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; ステートメントに似ています）を介して継続されている場合でも、ループ変数をインクリメントするために使用されます。</target>
        </trans-unit>
        <trans-unit id="2cd67d2b65a87b65d002d9fa075eef11fc3372a5" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is actually a flow control statement rather than a function. If there is a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; ), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement (which is similar to the C &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement).</source>
          <target state="translated">BLOCKが &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 場合、continueは実際には関数ではなくフロー制御ステートメントです。BLOCKに接続された &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK がある場合（通常、 &lt;code&gt;while&lt;/code&gt; または &lt;code&gt;foreach&lt;/code&gt; で）、Cの &lt;code&gt;for&lt;/code&gt; ループの3番目の部分のように、条件が再び評価される直前に常に実行されます。ループが &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ステートメント（C &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; ステートメントに似ています）を介して継続されている場合でも、ループ変数をインクリメントするために使用されます。</target>
        </trans-unit>
        <trans-unit id="aa8159a0d83694276288a2a5fe07fe61d16edc97" translate="yes" xml:space="preserve">
          <source>When functions within an XS source file must be separated into packages the PACKAGE keyword should be used. This keyword is used with the MODULE keyword and must follow immediately after it when used.</source>
          <target state="translated">XSソースファイル内の関数をパッケージに分けなければならない場合は、 PACKAGEキーワードを使用しなければなりません。このキーワードはMODULEキーワードと一緒に使用され、使用時には直後に続く必要があります。</target>
        </trans-unit>
        <trans-unit id="c6f577a0659ee785a75d16bfb954974346b28a9b" translate="yes" xml:space="preserve">
          <source>When given an ambiguous local time, the timelocal() function should always return the epoch for the</source>
          <target state="translated">曖昧なローカル時刻が与えられた場合、timelocal()関数は常に</target>
        </trans-unit>
        <trans-unit id="905210e566be8553d344f14d5ca8c62a30b6a0a2" translate="yes" xml:space="preserve">
          <source>When handling output parameters with a PPCODE section, be sure to handle 'set' magic properly. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; for details about 'set' magic.</source>
          <target state="translated">PPCODEセクションで出力パラメーターを処理するときは、必ず「設定」マジックを適切に処理してください。「セット」マジックの詳細については&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="76666973f161e896d15ace4d3f87a7a9c3ef5759" translate="yes" xml:space="preserve">
          <source>When in doubt, parenthesize. At the very least it will let some poor schmuck bounce on the % key in &lt;b&gt;vi&lt;/b&gt;.</source>
          <target state="translated">疑問がある場合は括弧で囲みます。少なくとも、&lt;b&gt;viの&lt;/b&gt;％キーで貧弱なシュマックが跳ね返ることはあります。</target>
        </trans-unit>
        <trans-unit id="b4688043e9a06a71613858ea73f001a633497cb7" translate="yes" xml:space="preserve">
          <source>When in doubt, run the &lt;b&gt;awk&lt;/b&gt; construct through &lt;b&gt;a2p&lt;/b&gt; and see what it gives you.</source>
          <target state="translated">疑わしい場合は、&lt;b&gt;a2p&lt;/b&gt;を介して&lt;b&gt;awk&lt;/b&gt;構文を実行し、何が得られるかを確認してください。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0c9ab777cdba3a81e6f12be90b090ea8b365cf98" translate="yes" xml:space="preserve">
          <source>When in doubt, you can use</source>
          <target state="translated">迷ったときは</target>
        </trans-unit>
        <trans-unit id="6948014018e5357f830915cd0ed311117487ecb2" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;`perl -MExtUtils::Embed -e ldopts --`&lt;/code&gt; the following options are recognized:</source>
          <target state="translated">&lt;code&gt;`perl -MExtUtils::Embed -e ldopts --`&lt;/code&gt; として呼び出されると、次のオプションが認識されます。</target>
        </trans-unit>
        <trans-unit id="cc36b4e11ce2156b2b41d828826a07de94fcec39" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;`perl -MExtUtils::Embed -e xsinit --`&lt;/code&gt; the following options are recognized:</source>
          <target state="translated">&lt;code&gt;`perl -MExtUtils::Embed -e xsinit --`&lt;/code&gt; として呼び出されると、次のオプションが認識されます。</target>
        </trans-unit>
        <trans-unit id="ee150951d5eb2b6fd45fd97edec569546ed48f9b" translate="yes" xml:space="preserve">
          <source>When invoked using a single string, &lt;b&gt;parseopts&lt;/b&gt; treats the string as the name of a parse-option and returns its corresponding value if it exists (returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it doesn't).</source>
          <target state="translated">単一の文字列を使用して呼び出されると、&lt;b&gt;parseopts&lt;/b&gt;は文字列を解析オプションの名前として扱い、対応する値が存在する場合はそれを返し &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （存在しない場合はundefを返します）。</target>
        </trans-unit>
        <trans-unit id="7277cd46617f74f2842ee4af54a1d49db21e598b" translate="yes" xml:space="preserve">
          <source>When invoked with multiple arguments, &lt;b&gt;parseopts&lt;/b&gt; treats them as key/value pairs and the specified parse-option names are set to the given values. Any unspecified parse-options are unaffected.</source>
          <target state="translated">複数の引数を指定して呼び出されると、&lt;b&gt;parseopts&lt;/b&gt;はそれらをキー/値のペアとして扱い、指定された解析オプション名は指定された値に設定されます。指定されていない解析オプションは影響を受けません。</target>
        </trans-unit>
        <trans-unit id="f1033de63c389a24f6517627a4b9b4657247752f" translate="yes" xml:space="preserve">
          <source>When invoked with no additional arguments, &lt;b&gt;parseopts&lt;/b&gt; returns a hashtable of all the current parsing options.</source>
          <target state="translated">追加の引数なしで呼び出されると、&lt;b&gt;parseopts&lt;/b&gt;は現在のすべての解析オプションのハッシュテーブルを返します。</target>
        </trans-unit>
        <trans-unit id="8a84fb9fbc48134e4aa29a0c0010fa21ec733eeb" translate="yes" xml:space="preserve">
          <source>When invoked with parameters the following are accepted and optional:</source>
          <target state="translated">パラメータを指定して起動した場合、以下の内容が受け入れられ、オプションとなります。</target>
        </trans-unit>
        <trans-unit id="3db92287943a254b1a1b0d74b4c460a69a45306e" translate="yes" xml:space="preserve">
          <source>When is a bool not a bool?</source>
          <target state="translated">boolがboolでないのはいつですか?</target>
        </trans-unit>
        <trans-unit id="7b77a4a5d5b65846fa5a3f0440157e545f392596" translate="yes" xml:space="preserve">
          <source>When it appears singly, it causes the sequences &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt; , and the Posix character classes to match only in the ASCII range. They thus revert to their pre-5.6, pre-Unicode meanings. Under &lt;code&gt;/a&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; always means precisely the digits &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &lt;code&gt;&quot;9&quot;&lt;/code&gt; ; &lt;code&gt;\s&lt;/code&gt; means the five characters &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; , and starting in Perl v5.18, the vertical tab; &lt;code&gt;\w&lt;/code&gt; means the 63 characters &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ; and likewise, all the Posix classes such as &lt;code&gt;[[:print:]]&lt;/code&gt; match only the appropriate ASCII-range characters.</source>
          <target state="translated">単独で表示される場合、シーケンス &lt;code&gt;\d&lt;/code&gt; 、 &lt;code&gt;\s&lt;/code&gt; 、 &lt;code&gt;\w&lt;/code&gt; 、およびPosix文字クラスはASCII範囲でのみ一致します。したがって、それらは5.6より前の、Unicodeより前の意味に戻ります。 &lt;code&gt;/a&lt;/code&gt; の下では、 &lt;code&gt;\d&lt;/code&gt; 常に正確に &lt;code&gt;&quot;0&quot;&lt;/code&gt; から &lt;code&gt;&quot;9&quot;&lt;/code&gt; までの数字を意味します。 &lt;code&gt;\s&lt;/code&gt; は5文字 &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; 意味し、Perl v5.18以降、垂直タブです。 &lt;code&gt;\w&lt;/code&gt; は63文字を意味します &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ;同様に、 &lt;code&gt;[[:print:]]&lt;/code&gt; などのすべてのPosixクラスは、適切なASCII範囲の文字のみに一致します。</target>
        </trans-unit>
        <trans-unit id="ae018fd8a3823b08fc79c33ba2f6c60484d5a434" translate="yes" xml:space="preserve">
          <source>When it comes to time-space tradeoffs, Perl nearly always prefers to throw memory at a problem. Scalars in Perl use more memory than strings in C, arrays take more than that, and hashes use even more. While there's still a lot to be done, recent releases have been addressing these issues. For example, as of 5.004, duplicate hash keys are shared amongst all hashes using them, so require no reallocation.</source>
          <target state="translated">時間空間のトレードオフに関して言えば、Perl はほとんどの場合、問題にメモリを投入することを好みます。Perl のスカラは C の文字列よりも多くのメモリを使用し、配列はそれよりも多くのメモリを使用し、ハッシュはさらに多くのメモリを使用します。まだまだやるべきことはたくさんありますが、最近のリリースではこれらの問題に対処しています。例えば、5.004では、重複したハッシュキーは、それらを使用している全てのハッシュの間で共有されるため、再割り当ては必要ありません。</target>
        </trans-unit>
        <trans-unit id="e21264012009a4f52f16ff3209c2f52a03a6b032" translate="yes" xml:space="preserve">
          <source>When it comes to undefined variables that would trigger a warning under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , you can promote the warning to an error.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; で警告をトリガーする未定義の変数に関しては、警告をエラーに昇格させることができます。</target>
        </trans-unit>
        <trans-unit id="ea78a63efa4e07bcbad222b4b53d8108119efd5b" translate="yes" xml:space="preserve">
          <source>When it converges, you got a functional variant of</source>
          <target state="translated">それが収束すると、関数的には</target>
        </trans-unit>
        <trans-unit id="079267d57082e05e5aa6528a39e11837b4f6a244" translate="yes" xml:space="preserve">
          <source>When it starts, the debugger reads your rc file (</source>
          <target state="translated">起動すると、デバッガはあなたの rc ファイル (</target>
        </trans-unit>
        <trans-unit id="f1e1e6def162fe17764cc69d6d5531c8389ffa63" translate="yes" xml:space="preserve">
          <source>When items collide into a given hash bucket the order they are stored in the chain is no longer predictable in Perl 5.18. This has the intention to make it harder to observe a collision. This behavior can be overridden by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS in perlrun&lt;/a&gt;.</source>
          <target state="translated">アイテムが特定のハッシュバケットに衝突すると、チェーンに格納される順序はPerl 5.18では予測できなくなります。これは、衝突を観察しにくくすることを目的としています。この動作は、PERL_PERTURB_KEYS環境変数を使用してオーバーライドできます&lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;。perlrunのPERL_PERTURB_KEYSを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="65043d3a1d3f5988941ccbcf07e25510773d1e57" translate="yes" xml:space="preserve">
          <source>When loading &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;, you must &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; before you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . (&lt;code&gt;threads&lt;/code&gt; will emit a warning if you do it the other way around.)</source>
          <target state="translated">ロードすると&lt;a href=&quot;threads/shared&quot;&gt;スレッドが::共有&lt;/a&gt;、あなたがしなければならない &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; あなたが前に &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; 。（逆にすると、 &lt;code&gt;threads&lt;/code&gt; は警告を発します。）</target>
        </trans-unit>
        <trans-unit id="4d97ad32fbcc62b0394446ba4a901eea150b590d" translate="yes" xml:space="preserve">
          <source>When looking for &lt;code&gt;DBD::Oracle&lt;/code&gt; relative to a search path, we should find</source>
          <target state="translated">探しているときに &lt;code&gt;DBD::Oracle&lt;/code&gt; 検索パスに対して、我々は見つける必要があります</target>
        </trans-unit>
        <trans-unit id="d1306624a66d42061de8cb1de14bb165b2e9253e" translate="yes" xml:space="preserve">
          <source>When naming your module, consider the following:</source>
          <target state="translated">モジュールの名前を付ける際には、以下のことを考慮してください。</target>
        </trans-unit>
        <trans-unit id="a2f6fa234dea48f4123a74cda1902ae1a1335eb2" translate="yes" xml:space="preserve">
          <source>When no destination is specified for an option, GetOptions will store the resultant value in a global variable named &lt;code&gt;opt_&lt;/code&gt;</source>
          <target state="translated">オプションの宛先が指定されていない場合、GetOptionsは結果の値を &lt;code&gt;opt_&lt;/code&gt; という名前のグローバル変数に格納します</target>
        </trans-unit>
        <trans-unit id="d995d17f45ad38c16e65d9df03d9013a6e8bd451" translate="yes" xml:space="preserve">
          <source>When non-&lt;code&gt;NULL&lt;/code&gt; , the function pointed by this variable will be called each time an OP is freed with the corresponding OP as the argument. This allows extensions to free any extra attribute they have locally attached to an OP. It is also assured to first fire for the parent OP and then for its kids.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 以外の場合、この変数が指す関数は、対応するOPを引数としてOPが解放されるたびに呼び出されます。これにより、拡張機能はローカルでOPに接続されている追加の属性を解放できます。また、最初に親OPに、次にその子供に発砲することも保証されています。</target>
        </trans-unit>
        <trans-unit id="fda14717d0ef780a84b7072c8af4b8c2a6e41355" translate="yes" xml:space="preserve">
          <source>When non-zero this options will make bzip2 use a decompression algorithm that uses less memory at the expense of increasing the amount of time taken for decompression.</source>
          <target state="translated">このオプションが 0 以外の場合、このオプションは bzip2 に、より少ないメモリ使用量で、伸長にかかる時間を増加させることを犠牲にして、より少ないメモリ使用量の伸長アルゴリズムを使用するようにする。</target>
        </trans-unit>
        <trans-unit id="53e144afe4dd441bf4ca7ad26c550e29a83fc4df" translate="yes" xml:space="preserve">
          <source>When open() is given an explicit list of layers (with the three-arg syntax), they override the list declared using this pragma. open() can also be given a single colon (:) for a layer name, to override this pragma and use the default (&lt;code&gt;:raw&lt;/code&gt; on Unix, &lt;code&gt;:crlf&lt;/code&gt; on Windows).</source>
          <target state="translated">open（）に（3つの引数の構文で）レイヤーの明示的なリストを指定すると、このプラグマを使用して宣言されたリストがオーバーライドされます。オープン（）も（1つのコロンを与えることができます:)レイヤ名のために、このプラグマを上書きすると、デフォルト（使用 &lt;code&gt;:raw&lt;/code&gt; Unixで、 &lt;code&gt;:crlf&lt;/code&gt; Windowsの場合）。</target>
        </trans-unit>
        <trans-unit id="ea26acaec78382fd2c97d3e0f9466f873120022e" translate="yes" xml:space="preserve">
          <source>When opened for writing, empty parts of the file will have NULL (0x00) bytes written to them.</source>
          <target state="translated">書き込み用にオープンした場合、ファイルの空の部分には NULL (0x00)バイトが書き込まれます。</target>
        </trans-unit>
        <trans-unit id="4a6b9011509d11da3fcfb04f15c06a413aa28bf6" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is frequently used with &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. Even if &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</source>
          <target state="translated">ファイルを開くとき、要求が失敗した場合に続行することはめったにないので、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; で頻繁に使用されます。 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; が期待どおりに動作しない場合でも（たとえば、CGIスクリプトで適切なエラーメッセージをフォーマットする必要があります（ただし、その問題に役立つモジュールがあります））、常にファイルを開いたときの戻り値を確認してください。</target>
        </trans-unit>
        <trans-unit id="713d157f79aa607cdf5ba0f3803c5ba5ac49d060" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is frequently used with &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. Even if &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</source>
          <target state="translated">ファイルを開くとき、要求が失敗した場合に続行することはめったにないので、 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; で頻繁に使用されます。 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; が期待どおりに動作しない場合でも（たとえば、CGIスクリプトで適切なエラーメッセージをフォーマットする必要があります（ただし、その問題に役立つモジュールがあります））、常にファイルを開いたときの戻り値を確認してください。</target>
        </trans-unit>
        <trans-unit id="136d8820f5385aeb92b2b0d8596ed06c40a27f32" translate="yes" xml:space="preserve">
          <source>When passed a single hash-ref, &lt;b&gt;parseopts&lt;/b&gt; uses that hash to completely reset the existing parse-options, all previous parse-option values are lost.</source>
          <target state="translated">単一のハッシュ参照が渡されると、&lt;b&gt;parseopts&lt;/b&gt;はそのハッシュを使用して既存の解析オプションを完全にリセットし、以前のすべての解析オプション値は失われます。</target>
        </trans-unit>
        <trans-unit id="47b91ab5f28f979fd8b5568f2d0f9b2f727e616c" translate="yes" xml:space="preserve">
          <source>When perl begins to parse any block construct that provides a lexical scope (e.g., eval body, required file, subroutine body, loop body, or conditional block), the existing value of &lt;code&gt;$^H&lt;/code&gt; is saved, but its value is left unchanged. When the compilation of the block is completed, it regains the saved value. Between the points where its value is saved and restored, code that executes within BEGIN blocks is free to change the value of &lt;code&gt;$^H&lt;/code&gt; .</source>
          <target state="translated">perlが字句スコープを提供するブロック構造（たとえば、eval本文、必要なファイル、サブルーチン本文、ループ本文、または条件付きブロック）の解析を開始すると、 &lt;code&gt;$^H&lt;/code&gt; 既存の値は保存されますが、その値は変更されません。ブロックのコンパイルが完了すると、保存された値が復元されます。値が保存および復元されるポイント間で、BEGINブロック内で実行されるコードは &lt;code&gt;$^H&lt;/code&gt; 値を自由に変更できます。</target>
        </trans-unit>
        <trans-unit id="8e10e03e69e1ff5f3a594f297790818dcb4b2f72" translate="yes" xml:space="preserve">
          <source>When perl executes something like &lt;code&gt;addop&lt;/code&gt; , how does it pass on its results to the next op? The answer is, through the use of stacks. Perl has a number of stacks to store things it's currently working on, and we'll look at the three most important ones here.</source>
          <target state="translated">perlが &lt;code&gt;addop&lt;/code&gt; のようなものを実行するとき、その結果を次のopにどのように渡しますか？答えは、スタックを使用することです。Perlには現在作業しているものを格納するための多数のスタックがあり、ここでは最も重要な3つのスタックを見ていきます。</target>
        </trans-unit>
        <trans-unit id="b736497c10b0a6402c79bf644d3d7290bca7e8df" translate="yes" xml:space="preserve">
          <source>When perl executes the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; expression, it translates the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; calls in the C run-time library and thence to the operating system kernel. perl sets &lt;code&gt;$!&lt;/code&gt; to the C library's &lt;code&gt;errno&lt;/code&gt; if one of these calls fails.</source>
          <target state="translated">perlが &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 式を実行すると、Cランタイムライブラリの &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; の呼び出しが変換され、オペレーティングシステムのカーネルに変換されます。perlが &lt;code&gt;$!&lt;/code&gt; 設定します！これらの呼び出しの1つが失敗した場合は、Cライブラリの &lt;code&gt;errno&lt;/code&gt; に。</target>
        </trans-unit>
        <trans-unit id="c23db1f0df62364b5b67f120eb77a3d581033b3c" translate="yes" xml:space="preserve">
          <source>When perl is compiled with support for memory footprint debugging (default with Perl's malloc()), Devel::Peek provides an access to this API.</source>
          <target state="translated">perlがメモリフットプリントデバッグをサポートしてコンパイルされている場合(Perlのmalloc()でデフォルト)、Devel::PeekはこのAPIへのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="215e17f5873c9b21cb203952a3ef2363b112bec3" translate="yes" xml:space="preserve">
          <source>When perl is configured to use ithreads, it will use re-entrant library calls in preference to non-re-entrant versions. There is a bug in FreeBSD's &lt;code&gt;readdir_r&lt;/code&gt; function in versions 4.5 and earlier that can cause a SEGV when reading large directories. A patch for FreeBSD libc is available (see &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&lt;/a&gt; ) which has been integrated into FreeBSD 4.6.</source>
          <target state="translated">perlがithreadsを使用するように構成されている場合、非再入可能バージョンよりも再入可能ライブラリー呼び出しが優先されます。FreeBSDのバージョン4.5以前の &lt;code&gt;readdir_r&lt;/code&gt; 関数には、大きなディレクトリを読み取るときにSEGVを引き起こす可能性のあるバグがあります。FreeBSD 4.6に統合されたFreeBSD libcのパッチが利用可能です（&lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631を参照&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="09323de6d789f44fb18ba022fc8c8c24e89843b3" translate="yes" xml:space="preserve">
          <source>When present this option will limit the number of compressed bytes read from the input file/buffer to &lt;code&gt;$size&lt;/code&gt; . This option can be used in the situation where there is useful data directly after the compressed data stream and you know beforehand the exact length of the compressed data stream.</source>
          <target state="translated">このオプションを指定すると、入力ファイル/バッファから読み取られる圧縮バイト数が &lt;code&gt;$size&lt;/code&gt; 制限されます。このオプションは、圧縮データストリームの直後に有用なデータがあり、事前に圧縮データストリームの正確な長さがわかっている場合に使用できます。</target>
        </trans-unit>
        <trans-unit id="2ede0a2d2bf6a5a00a9412db1d402428ce441463" translate="yes" xml:space="preserve">
          <source>When presented with something that might have several different interpretations, Perl uses the &lt;b&gt;DWIM&lt;/b&gt; (that's &quot;Do What I Mean&quot;) principle to pick the most probable interpretation. This strategy is so successful that Perl programmers often do not suspect the ambivalence of what they write. But from time to time, Perl's notions differ substantially from what the author honestly meant.</source>
          <target state="translated">いくつかの異なる解釈があるかもしれない何かが提示された場合、Perlは&lt;b&gt;DWIM&lt;/b&gt;（「何を意味するか」）の原則を使用して、最も可能性の高い解釈を選択します。この戦略は非常に成功しているため、Perlプログラマーは多くの場合、自分が書いたもののあいまいさを疑うことはありません。しかし、時々、Perlの概念は作者が正直に言ったものとは大幅に異なります。</target>
        </trans-unit>
        <trans-unit id="3ad187dab51002d9f1db84c4af0c7454d06b80be" translate="yes" xml:space="preserve">
          <source>When printed, a complex number is usually shown under its cartesian style</source>
          <target state="translated">印刷される場合、複素数は通常、その直交スタイルの下に表示されます。</target>
        </trans-unit>
        <trans-unit id="5caa7cd7539097bbbb349ec1e585b2c803d154a7" translate="yes" xml:space="preserve">
          <source>When prompted, pick a subject that summarizes your changes.</source>
          <target state="translated">プロンプトが表示されたら、あなたの変更点を要約する件名を選択します。</target>
        </trans-unit>
        <trans-unit id="0c308dc95015b79380949643660ba2048891c6cf" translate="yes" xml:space="preserve">
          <source>When putting items into &lt;code&gt;%^H&lt;/code&gt; , in order to avoid conflicting with other users of the hash there is a convention regarding which keys to use. A module should use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; .</source>
          <target state="translated">アイテムを &lt;code&gt;%^H&lt;/code&gt; 入れるとき、ハッシュの他のユーザーとの競合を避けるために、使用するキーに関する規則があります。モジュールは、モジュールの名前（メインパッケージの名前）と &quot;/&quot;文字で始まるキーのみを使用する必要があります。たとえば、モジュール &lt;code&gt;Foo::Bar&lt;/code&gt; は &lt;code&gt;Foo::Bar/baz&lt;/code&gt; などのキーを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="97c16015d247b91d71c9d2f79344302034231eb3" translate="yes" xml:space="preserve">
          <source>When reading from a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before reading.</source>
          <target state="translated">ファイルまたはファイルハンドルから読み取る場合は、読み取る前に &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; を設定します。</target>
        </trans-unit>
        <trans-unit id="f0130766d53ae0779f7ffce6dac2883bf210c349" translate="yes" xml:space="preserve">
          <source>When reading from a socket, remember that the default input record separator &lt;code&gt;$/&lt;/code&gt; is &lt;code&gt;\n&lt;/code&gt; , but robust socket code will recognize as either &lt;code&gt;\012&lt;/code&gt; or &lt;code&gt;\015\012&lt;/code&gt; as end of line:</source>
          <target state="translated">ソケットから読み取る場合、デフォルトの入力レコード区切り記号 &lt;code&gt;$/&lt;/code&gt; は &lt;code&gt;\n&lt;/code&gt; ですが、堅牢なソケットコードは行の終わりとして &lt;code&gt;\012&lt;/code&gt; または &lt;code&gt;\015\012&lt;/code&gt; として認識されます。</target>
        </trans-unit>
        <trans-unit id="ff12069c161fb8190739473ed34f724f30594524" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::AnyInflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">圧縮された入力データを読み取るとき、IO :: Uncompress :: AnyInflateは &lt;code&gt;$num&lt;/code&gt; バイトのブロックでそれを読み取ります。</target>
        </trans-unit>
        <trans-unit id="16d4e8c4e7b7384f70b2f1766cc139537265740d" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::AnyUncompress will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">圧縮された入力データを読み取るとき、IO :: Uncompress :: AnyUncompressは &lt;code&gt;$num&lt;/code&gt; バイトのブロックでそれを読み取ります。</target>
        </trans-unit>
        <trans-unit id="32ca9aeb1f06332449d6eb9320261dff0e66b312" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Bunzip2 will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">圧縮された入力データを読み取るとき、IO :: Uncompress :: Bunzip2は &lt;code&gt;$num&lt;/code&gt; バイトのブロックでそれを読み取ります。</target>
        </trans-unit>
        <trans-unit id="50715bb3c754686d721e8aea919c37db141e1994" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Gunzip will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">圧縮された入力データを読み取るとき、IO :: Uncompress :: Gunzipは &lt;code&gt;$num&lt;/code&gt; バイトのブロックでそれを読み取ります。</target>
        </trans-unit>
        <trans-unit id="59f000056402b83ac85f2986c043bbc1a33d0339" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Inflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">圧縮された入力データを読み取るとき、IO :: Uncompress :: Inflateは &lt;code&gt;$num&lt;/code&gt; バイトのブロックでそれを読み取ります。</target>
        </trans-unit>
        <trans-unit id="07686b740fde1338aeadfd29d15b206d9e710502" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::RawInflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">圧縮された入力データを読み取るとき、IO :: Uncompress :: RawInflateは &lt;code&gt;$num&lt;/code&gt; バイトのブロックでそれを読み取ります。</target>
        </trans-unit>
        <trans-unit id="f6933aca30493bfe2ae64d115f3d25c9d4614976" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Unzip will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">圧縮された入力データを読み取るとき、IO :: Uncompress :: Unzipは &lt;code&gt;$num&lt;/code&gt; バイトのブロックでそれを読み取ります。</target>
        </trans-unit>
        <trans-unit id="4d74245b43f70a678ebe3b1f9167c1e1ba7b4408" translate="yes" xml:space="preserve">
          <source>When referenced, &lt;code&gt;$!&lt;/code&gt; retrieves the current value of the C &lt;code&gt;errno&lt;/code&gt; integer variable. If &lt;code&gt;$!&lt;/code&gt; is assigned a numerical value, that value is stored in &lt;code&gt;errno&lt;/code&gt; . When referenced as a string, &lt;code&gt;$!&lt;/code&gt; yields the system error string corresponding to &lt;code&gt;errno&lt;/code&gt; .</source>
          <target state="translated">参照されると、 &lt;code&gt;$!&lt;/code&gt; C &lt;code&gt;errno&lt;/code&gt; 整数変数の現在の値を取得します。もし &lt;code&gt;$!&lt;/code&gt; 数値が割り当てられている場合、その値は &lt;code&gt;errno&lt;/code&gt; に格納されます。文字列として参照される場合、 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;errno&lt;/code&gt; に対応するシステムエラー文字列を生成します。</target>
        </trans-unit>
        <trans-unit id="27e9bf02eb38760deb66646d65b7d40e7944e879" translate="yes" xml:space="preserve">
          <source>When referring to characters by using a E&amp;lt;n&amp;gt; numeric code, numbers in the range 32-126 refer to those well known US-ASCII characters (also defined there by Unicode, with the same meaning), which all Pod formatters must render faithfully. Characters whose E&amp;lt;&amp;gt; numbers are in the ranges 0-31 and 127-159 should not be used (neither as literals, nor as E&amp;lt;number&amp;gt; codes), except for the literal byte-sequences for newline (ASCII 13, ASCII 13 10, or ASCII 10), and tab (ASCII 9).</source>
          <target state="translated">E &amp;lt;n&amp;gt;数値コードを使用して文字を参照する場合、32〜126の範囲の数字は、すべてのポッドフォーマッタが忠実にレンダリングする必要がある、よく知られているUS-ASCII文字（Unicodeでも同じ意味で定義）を参照します。 。改行のリテラルバイトシーケンス（ASCII 13、ASCII 13）を除いて、E &amp;lt;&amp;gt;番号が0-31と127-159の範囲にある文字は使用できません（リテラルとしてもE &amp;lt;number&amp;gt;コードとしても） 10、またはASCII 10）、およびタブ（ASCII 9）。</target>
        </trans-unit>
        <trans-unit id="df6e47ff65713a910476ca008419bf15d9f92656" translate="yes" xml:space="preserve">
          <source>When registering new categories of warning, you can supply more names to warnings::register like this:</source>
          <target state="translated">警告の新しいカテゴリを登録する際には、以下のようにwarnings::registerにさらに多くの名前を与えることができます。</target>
        </trans-unit>
        <trans-unit id="59e513d53fd0a8e9868f35002e2f8f73a3de8302" translate="yes" xml:space="preserve">
          <source>When removing directory trees, if you want to examine each file to decide whether to delete it (and possibly leaving large swathes alone),</source>
          <target state="translated">ディレクトリツリーを削除する際に、各ファイルを調べて削除するかどうかを決めたい場合(そして、場合によっては大きなスワースだけを残す場合もあります)には、ディレクトリツリーを削除します。</target>
        </trans-unit>
        <trans-unit id="ca0ea7cec59778756e53aaa7191d9a85c0fefd1a" translate="yes" xml:space="preserve">
          <source>When rendering Pod to a format that allows comments (i.e., to nearly any format other than plaintext), a Pod formatter must insert comment text identifying its name and version number, and the name and version numbers of any modules it might be using to process the Pod. Minimal examples:</source>
          <target state="translated">Podをコメントを許可する形式にレンダリングする場合(つまり、プレーンテキスト以外のほぼすべての形式にレンダリングする場合)、Podのフォーマッタは、その名前とバージョン番号、Podを処理するために使用している可能性のあるモジュールの名前とバージョン番号を示すコメントテキストを挿入しなければなりません。最小限の例を示します。</target>
        </trans-unit>
        <trans-unit id="2ad27da5819e821c8cd5bf0434eaf270b819ceff" translate="yes" xml:space="preserve">
          <source>When rendering Pod to a format that has two kinds of hyphens (-), one that's a non-breaking hyphen, and another that's a breakable hyphen (as in &quot;object-oriented&quot;, which can be split across lines as &quot;object-&quot;, newline, &quot;oriented&quot;), formatters are encouraged to generally translate &quot;-&quot; to non-breaking hyphen, but may apply heuristics to convert some of these to breaking hyphens.</source>
          <target state="translated">2種類のハイフン(-)を持つフォーマットにPodをレンダリングする際には、非区切りハイフンと区切りハイフン(「object-oriented」のように、「object-&quot;,newline,&quot;oriented &quot;のように線をまたいで分割することができます)の2種類のハイフンを持つフォーマットでは、フォーマッタは一般的に&quot;-&quot;を非区切りハイフンに変換することが推奨されますが、これらの一部を区切りハイフンに変換するためにヒューリスティックを適用しても構いません。</target>
        </trans-unit>
        <trans-unit id="f52c5a574eb5f1fd47869d07460df5abd7dd5137" translate="yes" xml:space="preserve">
          <source>When reporting a bug, please run through this checklist:</source>
          <target state="translated">バグを報告する際には、このチェックリストを実行してください。</target>
        </trans-unit>
        <trans-unit id="8b6bb8cb7867586650585befc2c1fd8387be0539" translate="yes" xml:space="preserve">
          <source>When reporting bugs/problems please include as much information as possible. It may be difficult for me to reproduce the problem as almost every setup is different.</source>
          <target state="translated">バグや問題を報告する際には、できるだけ多くの情報を記載してください。ほとんどすべての設定が異なるため、問題を再現するのは難しいかもしれません。</target>
        </trans-unit>
        <trans-unit id="f2af35fcfc2870add3a574f13c6598d925c1d896" translate="yes" xml:space="preserve">
          <source>When resolving a request for a global DLL, the table of already-loaded specific DLLs is (effectively) ignored; moreover, specific DLLs are</source>
          <target state="translated">グローバル DLL のリクエストを解決するとき、すでにロードされている特定の DLL のテーブルは (事実上)無視されます。</target>
        </trans-unit>
        <trans-unit id="62379e9d05e773d7f9a20bc63493ce786aebefd0" translate="yes" xml:space="preserve">
          <source>When returning a C array to Perl the XS writer must provide an integer variable called &lt;code&gt;size_$var&lt;/code&gt; containing the number of elements in the array. This is used to determine how many elements should be pushed onto the return argument stack. This is not required on input since Perl knows how many arguments are on the stack when the routine is called. Ordinarily this variable would be called &lt;code&gt;size_RETVAL&lt;/code&gt; .</source>
          <target state="translated">C配列をPerlに返すとき、XSライターは配列の要素数を含む &lt;code&gt;size_$var&lt;/code&gt; と呼ばれる整数変数を提供する必要があります。これは、戻り引数スタックにプッシュされる要素の数を決定するために使用されます。ルーチンが呼び出されたときにPerlがスタックにある引数の数を知っているため、これは入力では必要ありません。通常、この変数は &lt;code&gt;size_RETVAL&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="8ca08b2641f1d92e43e0d4ac166dca80cda23751" translate="yes" xml:space="preserve">
          <source>When returning a non-null result the type of the return is relevant. If it is an AV then the elements of the AV are the weak reference RVs which point at this item. If it is any other type then the item itself is the weak reference.</source>
          <target state="translated">非ヌルでない結果を返す場合、戻り値の型が関係しています。それがAVであれば、AVの要素はこのアイテムを指す弱い参照RVになります。それが他の型であれば、その項目自体が弱い参照です。</target>
        </trans-unit>
        <trans-unit id="97489cccab69eb1d35c1a341e128a78067c55f21" translate="yes" xml:space="preserve">
          <source>When rounding a number, different 'styles' or 'kinds' of rounding are possible. (Note that random rounding, as in Math::Round, is not implemented.)</source>
          <target state="translated">数値を丸めるときには、さまざまな「スタイル」や「種類」の丸めが可能です。(Math::Round のようなランダム丸めは実装されていないことに注意してください)。</target>
        </trans-unit>
        <trans-unit id="b2582b20778ca5521eeab7f1f747014dfe26c89f" translate="yes" xml:space="preserve">
          <source>When run it produces this output</source>
          <target state="translated">実行すると、以下のような出力が得られます。</target>
        </trans-unit>
        <trans-unit id="160ab26c7ebae1afd875b8a69bb2544386a0a133" translate="yes" xml:space="preserve">
          <source>When run, the script will produce this error message:</source>
          <target state="translated">スクリプトを実行すると、このようなエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="5d4a1a1df4c481bafe8952728953b7a8106417f0" translate="yes" xml:space="preserve">
          <source>When running &lt;code&gt;perl Makefile.PL&lt;/code&gt; , the environment variable &lt;code&gt;PERL5_CPAN_IS_EXECUTING&lt;/code&gt; is set to the full path of the &lt;code&gt;Makefile.PL&lt;/code&gt; that is being executed. This prevents runaway processes with newer versions of Module::Install.</source>
          <target state="translated">実行している場合 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 、環境変数 &lt;code&gt;PERL5_CPAN_IS_EXECUTING&lt;/code&gt; はの完全なパスに設定されている &lt;code&gt;Makefile.PL&lt;/code&gt; 実行されています。これにより、新しいバージョンのModule :: Installでプロセスが暴走するのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="2495ae50df460c2e127a2a6fc0eec9930e9be952" translate="yes" xml:space="preserve">
          <source>When running taint checks, either because the program was running setuid or setgid, or the &lt;b&gt;-T&lt;/b&gt; or &lt;b&gt;-t&lt;/b&gt; switch was specified, neither PERL5LIB nor PERLLIB is consulted. The program should instead say:</source>
          <target state="translated">汚染チェックを実行するとき、プログラムがsetuidまたはsetgidを実行しているか、&lt;b&gt;-T&lt;/b&gt;または&lt;b&gt;-t&lt;/b&gt;スイッチが指定されていたため、PERL5LIBもPERLLIBも参照されません。プログラムは代わりに言うべきです：</target>
        </trans-unit>
        <trans-unit id="7b3cb45c9a7da578dedba06cdb9f023a384333cd" translate="yes" xml:space="preserve">
          <source>When running this program, redirect &lt;code&gt;STDOUT&lt;/code&gt; so it is possible to check the output is correct from following test runs and use the system &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; utility to check the overall runtime.</source>
          <target state="translated">このプログラムを実行するときは、 &lt;code&gt;STDOUT&lt;/code&gt; をリダイレクトして、以下のテスト実行からの出力が正しいことを確認し、システム &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; ユーティリティを使用して全体のランタイムを確認できるようにします。</target>
        </trans-unit>
        <trans-unit id="7975efeb25c8aaa03ac880e03163e48a54218208" translate="yes" xml:space="preserve">
          <source>When running under Eunice this variable contains a command which will convert a shell script to the proper form of text file for it to be executable by the shell. On other systems it is a no-op.</source>
          <target state="translated">Eunice の下で実行している場合、この変数にはシェルスクリプトを適切な形式のテキストファイルに変換し、シェルが実行できるようにするコマンドが含まれています。他のシステムでは、この変数は何もしません。</target>
        </trans-unit>
        <trans-unit id="401f0ab26dc2fddd741da0955da0f9c560a5d28d" translate="yes" xml:space="preserve">
          <source>When safe signals is in effect (the default behavior - see &lt;a href=&quot;#Unsafe-signals&quot;&gt;Unsafe signals&lt;/a&gt; for more details), then signals may be sent and acted upon by individual threads.</source>
          <target state="translated">安全な信号が有効な場合（デフォルトの動作-詳細については「&lt;a href=&quot;#Unsafe-signals&quot;&gt;安全でない信号」&lt;/a&gt;を参照）、信号が送信され、個々のスレッドによって処理されます。</target>
        </trans-unit>
        <trans-unit id="dba60ff6fd07f256c35eeeb0201541b7eaafeee0" translate="yes" xml:space="preserve">
          <source>When satisfied with the results, rerun the &lt;code&gt;installcmd&lt;/code&gt; target. Now you can copy &lt;code&gt;perl5.8.2.exe&lt;/code&gt; to &lt;code&gt;perl.exe&lt;/code&gt; , and install the other OMF-build executables: &lt;code&gt;perl__.exe&lt;/code&gt; etc. They are ready to be used.</source>
          <target state="translated">結果に満足したら、 &lt;code&gt;installcmd&lt;/code&gt; ターゲットを再実行します。これで、 &lt;code&gt;perl5.8.2.exe&lt;/code&gt; を &lt;code&gt;perl.exe&lt;/code&gt; にコピーし、他のOMFビルド実行可能ファイル（ &lt;code&gt;perl__.exe&lt;/code&gt; など）をインストールできます。これらは使用する準備ができています。</target>
        </trans-unit>
        <trans-unit id="64d487e30347818adf665d0d1f254f13a4106809" translate="yes" xml:space="preserve">
          <source>When saving source, include evals that generate no subroutines.</source>
          <target state="translated">ソースを保存する際には、サブルーチンを生成しないエバールを含めます。</target>
        </trans-unit>
        <trans-unit id="c90d39de52f44bc4955e7d1999e5bc6bf1c25af5" translate="yes" xml:space="preserve">
          <source>When saving source, include source that did not compile.</source>
          <target state="translated">ソースを保存する際に、コンパイルされなかったソースを含めるようにしました。</target>
        </trans-unit>
        <trans-unit id="398d8ece97f780e7acaac52b6e525bbaea7d6236" translate="yes" xml:space="preserve">
          <source>When searching for single-character delimiters, escaped delimiters and &lt;code&gt;\\&lt;/code&gt; are skipped. For example, while searching for terminating &lt;code&gt;/&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\/&lt;/code&gt; are skipped. If the delimiters are bracketing, nested pairs are also skipped. For example, while searching for a closing &lt;code&gt;]&lt;/code&gt; paired with the opening &lt;code&gt;[&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; , &lt;code&gt;\]&lt;/code&gt;, and &lt;code&gt;\[&lt;/code&gt; are all skipped, and nested &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; are skipped as well. However, when backslashes are used as the delimiters (like &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq\\&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr\\\&lt;/a&gt;&lt;/code&gt;), nothing is skipped. During the search for the end, backslashes that escape delimiters or other backslashes are removed (exactly speaking, they are not copied to the safe location).</source>
          <target state="translated">単一文字の区切り文字を検索する場合、エスケープされた区切り文字と &lt;code&gt;\\&lt;/code&gt; はスキップされます。たとえば、 &lt;code&gt;\\&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; を検索するとき、\\と &lt;code&gt;\/&lt;/code&gt; 組み合わせはスキップされます。区切り文字がブラケットの場合、ネストされたペアもスキップされます。たとえば、開始 &lt;code&gt;[&lt;/code&gt; とペアになっている終了 &lt;code&gt;]&lt;/code&gt; を検索しているとき、 &lt;code&gt;\\&lt;/code&gt; 、 &lt;code&gt;\]&lt;/code&gt; 、および &lt;code&gt;\[&lt;/code&gt; 組み合わせはすべてスキップされ、ネストされた &lt;code&gt;[&lt;/code&gt; および &lt;code&gt;]&lt;/code&gt; もスキップされます。ただし、バックスラッシュが区切り文字として使用されている場合（ &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq\\&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr\\\&lt;/a&gt;&lt;/code&gt; ）、何もスキップされません。末尾の検索中に、区切り文字やその他のバックスラッシュをエスケープするバックスラッシュが削除されます（正確には、安全な場所にコピーされません）。</target>
        </trans-unit>
        <trans-unit id="32c34df309dbf3ee7f15cd5785f504c8f035d38f" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;&quot;1&quot;&lt;/code&gt; or &lt;code&gt;&quot;RANDOM&quot;&lt;/code&gt; then traversing keys will be randomized. Every time a hash is inserted into the key order will change in a random fashion. The order may not be repeatable in a following program run even if the PERL_HASH_SEED has been specified. This is the default mode for perl.</source>
          <target state="translated">&lt;code&gt;&quot;1&quot;&lt;/code&gt; または &lt;code&gt;&quot;RANDOM&quot;&lt;/code&gt; 設定すると、移動キーがランダム化されます。ハッシュがキーの順序に挿入されるたびに、ランダムに変化します。PERL_HASH_SEEDが指定されている場合でも、次のプログラムの実行では順序を繰り返すことができない場合があります。これはperlのデフォルトモードです。</target>
        </trans-unit>
        <trans-unit id="04d0e5e2f5a4ede1100f0e4584215cbbf899e23b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;&quot;2&quot;&lt;/code&gt; or &lt;code&gt;&quot;DETERMINISTIC&quot;&lt;/code&gt; then inserting keys into a hash will cause the key order to change, but in a way that is repeatable from program run to program run.</source>
          <target state="translated">&lt;code&gt;&quot;2&quot;&lt;/code&gt; または &lt;code&gt;&quot;DETERMINISTIC&quot;&lt;/code&gt; 設定した場合、ハッシュにキーを挿入すると、キーの順序が変更されますが、プログラムの実行ごとに繰り返すことができます。</target>
        </trans-unit>
        <trans-unit id="9e7128c2c7dce5a0a3a9029329df5cbd50b2f0b7" translate="yes" xml:space="preserve">
          <source>When set to a true value, will cause &lt;code&gt;remove_tree&lt;/code&gt; to skip the files for which the process lacks the required privileges needed to delete files, such as delete privileges on VMS. In other words, the code will make no attempt to alter file permissions. Thus, if the process is interrupted, no filesystem object will be left in a more permissive mode.</source>
          <target state="translated">trueに設定すると、 &lt;code&gt;remove_tree&lt;/code&gt; は、VMSでの削除特権など、ファイルを削除するために必要な特権がプロセスに不足しているファイルをスキップします。つまり、コードはファイルのアクセス許可を変更しようとはしません。したがって、プロセスが中断された場合、ファイルシステムオブジェクトはより寛容なモードのままになることはありません。</target>
        </trans-unit>
        <trans-unit id="c7f5dc6825eff7e1f171e69f42059c82111432c0" translate="yes" xml:space="preserve">
          <source>When set to a true value, will cause all files and subdirectories to be removed, except the initially specified directories. This comes in handy when cleaning out an application's scratch directory.</source>
          <target state="translated">true に設定すると、最初に指定したディレクトリ以外のすべてのファイルとサブディレクトリが削除されます。これは、アプリケーションのスクラッチディレクトリをクリーンアウトするときに便利です。</target>
        </trans-unit>
        <trans-unit id="2ff22a09dbb1fd01f1d9e27ed6ec106512c2eedc" translate="yes" xml:space="preserve">
          <source>When set, Data::Dumper will emit single, non-self-referential values as atoms/terms rather than statements. This means that the &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">設定すると、Data :: Dumperはステートメントではなく、アトム/タームとして単一の非自己参照値を出力します。これは、 &lt;code&gt;$VAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe8e786dd3039d8dd6d2bfab15396a2a2af496f5" translate="yes" xml:space="preserve">
          <source>When set, controls the network timeout (counted in seconds).</source>
          <target state="translated">設定すると、ネットワークのタイムアウトを制御します(秒単位でカウントされます)。</target>
        </trans-unit>
        <trans-unit id="b5e8c42abd62cd10178b1f40a287ed255997e01d" translate="yes" xml:space="preserve">
          <source>When set, enables the use of double quotes for representing string values. Whitespace other than space will be represented as &lt;code&gt;[\n\t\r]&lt;/code&gt; , &quot;unsafe&quot; characters will be backslashed, and unprintable characters will be output as quoted octal integers. The default is 0.</source>
          <target state="translated">設定すると、文字列値を表すための二重引用符の使用が有効になります。スペース以外の空白は &lt;code&gt;[\n\t\r]&lt;/code&gt; として表され、「安全でない」文字はバックスラッシュが付けられ、印刷できない文字は引用符付きの8進整数として出力されます。デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="e7c58b77eb133eea8c15ca3a9398533c775f314b" translate="yes" xml:space="preserve">
          <source>When should I decode or encode?</source>
          <target state="translated">いつデコードするか、エンコードするか?</target>
        </trans-unit>
        <trans-unit id="1dc62984ecca7c09ade87153ed4ccd6695dd04ce" translate="yes" xml:space="preserve">
          <source>When shouldn't I program in Perl?</source>
          <target state="translated">Perlでプログラミングをしてはいけないのはいつですか?</target>
        </trans-unit>
        <trans-unit id="38a0e44be6c1f4e08e2750d9d92dbacbb5e6685b" translate="yes" xml:space="preserve">
          <source>When something is contained in something else, particularly when that might be considered surprising: &amp;ldquo;I&amp;rsquo;ve embedded a complete Perl interpreter in my editor!&amp;rdquo;</source>
          <target state="translated">何かが別の何かに含まれている場合、特にそれが意外と考えられる場合：「エディタに完全なPerlインタプリタを組み込んだ！」</target>
        </trans-unit>
        <trans-unit id="0a4af2a22b89ee59f46fa6ec1a2f89f7c8de8e00" translate="yes" xml:space="preserve">
          <source>When speaking about regexes we need to distinguish between their source code form and their internal form. In this document we will use the term &quot;pattern&quot; when we speak of their textual, source code form, and the term &quot;program&quot; when we speak of their internal representation. These correspond to the terms</source>
          <target state="translated">正規表現について話すときには、ソースコードの形式と内部の形式を区別する必要があります。このドキュメントでは、テキスト的なソース・コードの形式について話すときは「パターン」という用語を使用し、内部的な表現について話すときは「プログラム」という用語を使用します。これらは、以下の用語に対応しています。</target>
        </trans-unit>
        <trans-unit id="71fc37572f09658b981cd729d4958d3d9535564d" translate="yes" xml:space="preserve">
          <source>When specified (localised) in a module's</source>
          <target state="translated">モジュールの</target>
        </trans-unit>
        <trans-unit id="0b48aaafd2407a97f05ee6a676562dca0cfeebf8" translate="yes" xml:space="preserve">
          <source>When starting scripts directly, Perl uses exactly the same algorithm as for the search of script given by &lt;b&gt;-S&lt;/b&gt; command-line option: it will look in the current directory, then on components of &lt;code&gt;$ENV{PATH}&lt;/code&gt; using the following order of appended extensions: no extension,</source>
          <target state="translated">スクリプトを直接開始する場合、Perlは&lt;b&gt;-S&lt;/b&gt;コマンドラインオプションで指定されたスクリプトの検索とまったく同じアルゴリズムを使用します。現在のディレクトリを検索し、次に &lt;code&gt;$ENV{PATH}&lt;/code&gt; コンポーネントを次の順序で追加された拡張子で検索します。：拡張子なし、</target>
        </trans-unit>
        <trans-unit id="31501718ea48b1c7c96923d7f9ebcfb80e76fc7d" translate="yes" xml:space="preserve">
          <source>When storing doubles in network order, their value is stored as text. However, you should also not expect non-numeric floating-point values such as infinity and &quot;not a number&quot; to pass successfully through a nstore()/retrieve() pair.</source>
          <target state="translated">ネットワーク順にダブルスを格納する場合、その値はテキストとして格納されます。しかし、無限大や &quot;数ではない &quot;などの浮動小数点型の数値以外の値が nstore()/retrieve()のペアをうまく通過することは期待しない方がいいでしょう。</target>
        </trans-unit>
        <trans-unit id="aadbffec66a30c1a002a47c90a7b1248371d0324" translate="yes" xml:space="preserve">
          <source>When testing applications, often you find yourself needing to provide functionality in your test environment that would usually be provided by external modules. Rather than munging the &lt;code&gt;%INC&lt;/code&gt; by hand to mark these external modules as loaded, so they are not attempted to be loaded by perl, this module offers you a very simple way to mark modules as loaded and/or unloaded.</source>
          <target state="translated">アプリケーションをテストする場合、多くの場合、通常は外部モジュールによって提供される機能をテスト環境で提供する必要があります。むしろいじるよりも、 &lt;code&gt;%INC&lt;/code&gt; を彼らはperlのでロードしようとしていないので、ロードされたとして、これらの外部モジュールをマークするために手で、マーク・モジュールにこのモジュールの提供あなたは非常に簡単な方法は、ロードおよび/またはアンロードとして。</target>
        </trans-unit>
        <trans-unit id="961c445e33a9a31bd9e2652fe106daffb549bbdf" translate="yes" xml:space="preserve">
          <source>When that string is compiled from bracket notation into a real Perl sub, it's basically turned into:</source>
          <target state="translated">その文字列がブラケット記法から実際のPerlのサブにコンパイルされると、基本的には</target>
        </trans-unit>
        <trans-unit id="956082e29333281c1000de72a422a6d173c77cc1" translate="yes" xml:space="preserve">
          <source>When the # flag and a precision are given in the %o conversion, the precision is incremented if it's necessary for the leading &quot;0&quot;.</source>
          <target state="translated">#フラグと精度が%o変換で与えられた場合、先頭の &quot;0 &quot;が必要な場合は精度がインクリメントされます。</target>
        </trans-unit>
        <trans-unit id="b4c77bd95ba1c8037180b07d06856855d317ef69" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is omitted or false, then the tied hash elements will be the contents of the leftmost defined buffer with the name of the associated hash key. In other words, the tied hash will behave as &lt;code&gt;%+&lt;/code&gt; .</source>
          <target state="translated">場合は &lt;code&gt;all&lt;/code&gt; パラメータを省略またはfalseをされ、その後、結ばれたハッシュ要素は、関連するハッシュキーの名前の一番左の定義されたバッファの内容になります。つまり、結合ハッシュは &lt;code&gt;%+&lt;/code&gt; として動作します。</target>
        </trans-unit>
        <trans-unit id="d840453ed70b6c8cd04f568b5e24263c8a47ca21" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is provided, then the tied hash elements will be array refs listing the contents of each capture buffer whose name is the same as the associated hash key. If none of these buffers were involved in the match, the contents of that array ref will be as many &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; values as there are capture buffers with that name. In other words, the tied hash will behave as &lt;code&gt;%-&lt;/code&gt; .</source>
          <target state="translated">場合 &lt;code&gt;all&lt;/code&gt; パラメータが提供され、その後、tieされたハッシュ要素は、名前、関連するハッシュキーと同じであり、各キャプチャバッファの内容をリストする配列リファレンスであろう。これらのバッファーのいずれも一致に関与しなかった場合、その配列refの内容は、その名前のキャプチャバッファーと同じ数の &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 値になります。言い換えると、結合ハッシュは &lt;code&gt;%-&lt;/code&gt; として動作します。</target>
        </trans-unit>
        <trans-unit id="ad645af5beffff4dcf298e97bda326c957e193d6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnix2&lt;/code&gt; option is present it will trigger the creation of a Unix2 extra field (ID is &quot;Ux&quot;) in the local zip header. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . An empty Unix2 extra field will also be created in the central zip header.</source>
          <target state="translated">とき &lt;code&gt;exUnix2&lt;/code&gt; のオプションが存在することは、ローカルのzipヘッダ内（IDは「UXの」です）Unix2余分なフィールドの作成をトリガーします。これには &lt;code&gt;$uid&lt;/code&gt; と &lt;code&gt;$gid&lt;/code&gt; が入力されます。空のUnix2追加フィールドも中央のzipヘッダーに作成されます。</target>
        </trans-unit>
        <trans-unit id="40f9a81cf7aa8b00ade31d3ca1a070fc29516dbb" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnixN&lt;/code&gt; option is present it will trigger the creation of a UnixN extra field (ID is &quot;ux&quot;) in both the local and central zip headers. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . The UID &amp;amp; GID are stored as 32-bit integers.</source>
          <target state="translated">とき &lt;code&gt;exUnixN&lt;/code&gt; のオプションが存在している、それは両方のローカルおよび中央のジッパーヘッダー内（IDは「UX」である）UnixN余分なフィールドの作成をトリガーします。これには &lt;code&gt;$uid&lt;/code&gt; と &lt;code&gt;$gid&lt;/code&gt; が入力されます。UIDとGIDは32ビット整数として格納されます。</target>
        </trans-unit>
        <trans-unit id="97ce970ca586eb9f9dd65ce4eb91d435bcb2b455" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;frame&lt;/code&gt; option is set, the debugger would print entered (and optionally exited) subroutines in different styles. See &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; for incredibly long examples of these.</source>
          <target state="translated">場合 &lt;code&gt;frame&lt;/code&gt; オプションがセットされ、デバッガは異なるスタイルで入力された（および必要に応じて終了）のサブルーチンを印刷することになります。これらの非常に長い例については、&lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="801df7cc1a118615aee66edb536ee9e06cf840b5" translate="yes" xml:space="preserve">
          <source>When the CPAN module is used for the first time, a configuration dialogue tries to determine a couple of site specific options. The result of the dialog is stored in a hash reference &lt;code&gt; $CPAN::Config &lt;/code&gt; in a file CPAN/Config.pm.</source>
          <target state="translated">CPANモジュールが初めて使用されるとき、構成ダイアログはいくつかのサイト固有のオプションを決定しようとします。ダイアログの結果は、ファイルCPAN / Config.pmのハッシュ参照 &lt;code&gt; $CPAN::Config &lt;/code&gt; に保存されます。</target>
        </trans-unit>
        <trans-unit id="7cb924f6e524bd0e1830b8259c680c4e75924eac" translate="yes" xml:space="preserve">
          <source>When the CPAN shell enters a subshell via the look command, it sets the environment CPAN_SHELL_LEVEL to 1, or increments that variable if it is already set.</source>
          <target state="translated">CPANシェルがlookコマンドを使用してサブシェルに入ると、環境CPAN_SHELL_LEVELを1に設定するか、すでに設定されている場合はその変数をインクリメントする。</target>
        </trans-unit>
        <trans-unit id="3650ff6a9d15f4cddf8e012952c2eb6d79121733" translate="yes" xml:space="preserve">
          <source>When the CPAN shell is started it normally displays a greeting message that contains the running version and the status of readline support.</source>
          <target state="translated">CPANシェルが起動すると、通常、実行中のバージョンと読取線サポートのステータスを含むグリーティングメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="3b2e82923d74c1d230a5130604df06c8f537a860" translate="yes" xml:space="preserve">
          <source>When the SV is read from or written to, the &lt;code&gt;uf_val&lt;/code&gt; or &lt;code&gt;uf_set&lt;/code&gt; function will be called with &lt;code&gt;uf_index&lt;/code&gt; as the first arg and a pointer to the SV as the second. A simple example of how to add &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic is shown below. Note that the ufuncs structure is copied by sv_magic, so you can safely allocate it on the stack.</source>
          <target state="translated">SVが読み書きされるとき、 &lt;code&gt;uf_val&lt;/code&gt; または &lt;code&gt;uf_set&lt;/code&gt; 関数は、最初の引数として &lt;code&gt;uf_index&lt;/code&gt; を使用し、2番目の引数としてSVへのポインターを使用して呼び出されます。 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; マジックを追加する簡単な例を以下に示します。ufuncs構造体はsv_magicによってコピーされるため、スタックに安全に割り当てることができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7cf75e5eda3afd46688cf75f69b185773f733453" translate="yes" xml:space="preserve">
          <source>When the Storable engine does not find any &lt;code&gt;STORABLE_thaw&lt;/code&gt; hook routine, it tries to load the class by requiring the package dynamically (using the blessed package name), and then re-attempts the lookup. If at that time the hook cannot be located, the engine croaks. Note that this mechanism will fail if you define several classes in the same file, but &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; warned you.</source>
          <target state="translated">Storableエンジンは、 &lt;code&gt;STORABLE_thaw&lt;/code&gt; フックルーチンを見つけられない場合、（bless されたパッケージ名を使用して）パッケージを動的に要求することによりクラスをロードしようとし、その後、検索を再試行します。その時点でフックが見つからない場合、エンジンが鳴きます。同じファイルで複数のクラスを定義するとこのメカニズムは失敗しますが、&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;は警告を出します。</target>
        </trans-unit>
        <trans-unit id="44a6516f88b32cd0929f74947668f35c10106658" translate="yes" xml:space="preserve">
          <source>When the actual VMS termination status of the child is an error, internally the &lt;code&gt;$!&lt;/code&gt; value will be set to the closest Unix errno value to that error so that Perl scripts that test for error messages will see the expected Unix style error message instead of a VMS message.</source>
          <target state="translated">子の実際のVMS終了ステータスがエラーの場合、内部的に &lt;code&gt;$!&lt;/code&gt; valueは、そのエラーに最も近いUnix errno値に設定されるため、エラーメッセージをテストするPerlスクリプトは、VMSメッセージではなく、予期されるUnixスタイルのエラーメッセージを表示します。</target>
        </trans-unit>
        <trans-unit id="2e8f0d2ae12a2e39fe8c86870d0da6c283532175" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; for details.</source>
          <target state="translated">引数がシステムシェルを介して実行される場合、結果はその癖や機能の影響を受けます。詳細については&lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;、perlopの「STRING」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1fb744771cfcd60aec9ab66ef08b4b0d1508a2fd" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; for details.</source>
          <target state="translated">引数がシステムシェルを介して実行される場合、結果はその癖や機能の影響を受けます。詳細については&lt;a href=&quot;perlop#%60STRING%60&quot;&gt;、perlopの「STRING」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="af5d3dc3800fc64d81a21bf6e187c8743b336401" translate="yes" xml:space="preserve">
          <source>When the class is to match caselessly under &lt;code&gt;/i&lt;/code&gt; matching rules, and a character that is explicitly mentioned inside the class matches a multiple-character sequence caselessly under Unicode rules, the class will also match that sequence. For example, Unicode says that the letter &lt;code&gt;LATIN SMALL LETTER SHARP S&lt;/code&gt; should match the sequence &lt;code&gt;ss&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; rules. Thus,</source>
          <target state="translated">&lt;code&gt;/i&lt;/code&gt; マッチングルールでクラスが大文字と小文字を区別せずに一致し、クラス内で明示的に言及されている文字がUnicodeルールで大文字と小文字を区別せずに一致する場合、クラスもそのシーケンスに一致します。たとえば、Unicodeは、 &lt;code&gt;LATIN SMALL LETTER SHARP S&lt;/code&gt; 文字の小文字Sの文字は、 &lt;code&gt;/i&lt;/code&gt; ルールの下でシーケンス &lt;code&gt;ss&lt;/code&gt; と一致する必要があると述べています。したがって、</target>
        </trans-unit>
        <trans-unit id="4739858b160d44355cadf7e584ea672d7f556732" translate="yes" xml:space="preserve">
          <source>When the code will run on only two or three operating systems, you may need to consider only the differences of those particular systems. The important thing is to decide where the code will run and to be deliberate in your decision.</source>
          <target state="translated">コードが2つか3つのオペレーティング・システムでしか実行されない場合、それらの特定のシステムの違いだけを考慮する必要があるかもしれません。重要なのは、コードを実行する場所を決め、慎重に決定することです。</target>
        </trans-unit>
        <trans-unit id="dfc1084fa585e179656ac972bdfbaccc526f6fbd" translate="yes" xml:space="preserve">
          <source>When the config variable ftp_passive is set, all downloads will be run with the environment variable FTP_PASSIVE set to this value. This is in general a good idea as it influences both Net::FTP and LWP based connections. The same effect can be achieved by starting the cpan shell with this environment variable set. For Net::FTP alone, one can also always set passive mode by running libnetcfg.</source>
          <target state="translated">設定変数 ftp_passive が設定されている場合、すべてのダウンロードは環境変数 FTP_PASSIVE がこの値に設定された状態で実行される。これは、Net::FTP と LWP ベースの接続の両方に影響を与えるので、一般的には良い考えです。この環境変数を設定した状態で cpan シェルを起動しても同じ効果が得られる。Net::FTP のみの場合、libnetcfg を実行して常にパッシブモードを設定することもできる。</target>
        </trans-unit>
        <trans-unit id="78466bcc2cdd4ead9e6349b03cf49de5263729eb" translate="yes" xml:space="preserve">
          <source>When the database contains only UTF-8, a wrapper function or method is a convenient way to replace all your &lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt; calls. A wrapper function will also make it easier to adapt to future enhancements in your database driver. Note that at the time of this writing (January 2012), the DBI has no standardized way to deal with UTF-8 data. Please check the &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI documentation&lt;/a&gt; to verify if that is still true.</source>
          <target state="translated">データベースにUTF-8のみが含まれる場合、ラッパー関数またはメソッドは、すべての &lt;code&gt;fetchrow_array&lt;/code&gt; および &lt;code&gt;fetchrow_hashref&lt;/code&gt; 呼び出しを置き換える便利な方法です。ラッパー関数は、データベースドライバーの将来の拡張機能への適応を容易にします。この記事の執筆時点（2012年1月）では、DBIにはUTF-8データを処理するための標準化された方法がないことに注意してください。それがまだ当てはまるかどうかを確認するには、&lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBIのドキュメント&lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="424c9b91abc16b60883f34954f20bc0920b45171" translate="yes" xml:space="preserve">
          <source>When the execution of your program reaches a point that can hold a breakpoint, the &lt;code&gt;DB::DB()&lt;/code&gt; subroutine is called if any of the variables &lt;code&gt;$DB::trace&lt;/code&gt; , &lt;code&gt;$DB::single&lt;/code&gt; , or &lt;code&gt;$DB::signal&lt;/code&gt; is true. These variables are not &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;izable. This feature is disabled when executing inside &lt;code&gt;DB::DB()&lt;/code&gt; , including functions called from it unless &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; is true.</source>
          <target state="translated">プログラムの実行がブレークポイントを保持できるポイントに到達すると、変数 &lt;code&gt;$DB::trace&lt;/code&gt; 、 &lt;code&gt;$DB::single&lt;/code&gt; 、または &lt;code&gt;$DB::signal&lt;/code&gt; いずれかがtrueの場合、 &lt;code&gt;DB::DB()&lt;/code&gt; サブルーチンが呼び出されます。 。これらの変数は、 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 変更可能ではありません。 &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; がtrue でない限り、 &lt;code&gt;DB::DB()&lt;/code&gt; 内から実行されるとき、この機能は呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b4013fd718fab58c3590b6ef9433727cc8d4f1b2" translate="yes" xml:space="preserve">
          <source>When the file</source>
          <target state="translated">ファイルの場合</target>
        </trans-unit>
        <trans-unit id="0e9d22cf15c89f0be579b7cac8b2920cd0618fca" translate="yes" xml:space="preserve">
          <source>When the files you're processing are small, it doesn't much matter which way you do it, but it makes a huge difference when they start getting larger.</source>
          <target state="translated">処理しているファイルが小さいときは、どちらの方法で処理してもあまり問題になりませんが、ファイルが大きくなり始めると大きな違いが出てきます。</target>
        </trans-unit>
        <trans-unit id="3edca323b0aa2a8c22d79426f73f2c12bb6d2e6d" translate="yes" xml:space="preserve">
          <source>When the inner subroutine is called, it will see the value of the outer subroutine's lexical subroutine as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the lexical subroutine. In other words, it will no longer be shared. This will especially make a difference if the lexical subroutines accesses lexical variables declared in its surrounding scope.</source>
          <target state="translated">内側のサブルーチンが呼び出されると、外側のサブルーチンの語彙サブルーチンの値は、外側のサブルーチンへの*最初の*呼び出しの前とその間にあったものを見ることになります;この場合、外側のサブルーチンへの最初の呼び出しが完了した後、内側のサブルーチンと外側のサブルーチンは、もはや語彙サブルーチンの共通の値を共有しなくなります。言い換えれば、もはや共有されなくなります。これは特に、語彙的サブルーチンがその周囲のスコープで宣言された語彙的変数にアクセスする場合に違いが出てきます。</target>
        </trans-unit>
        <trans-unit id="c8e896e8cfb6883a198899b3b354096b8ef21889" translate="yes" xml:space="preserve">
          <source>When the inner subroutine is called, it will see the value of the outer subroutine's variable as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the variable. In other words, the variable will no longer be shared.</source>
          <target state="translated">内側のサブルーチンが呼び出されると、外側のサブルーチンの変数の値は、外側のサブルーチンへの*最初の*呼び出しの前と呼び出し中に、外側のサブルーチンの変数の値を見ることになります;この場合、外側のサブルーチンへの最初の呼び出しが完了した後、内側のサブルーチンと外側のサブルーチンは、もはや変数のための共通の値を共有しません。言い換えれば、変数はもはや共有されません。</target>
        </trans-unit>
        <trans-unit id="631ef295238142aad88b3365a36b169f7f950bf1" translate="yes" xml:space="preserve">
          <source>When the last reference to an object goes away, the object is destroyed. If you only have one reference to an object stored in a lexical scalar, the object is destroyed when that scalar goes out of scope. If you store the object in a package global, that object may not go out of scope until the program exits.</source>
          <target state="translated">オブジェクトへの最後の参照がなくなると、そのオブジェクトは破棄されます。レキシカルスカラに格納されているオブジェクトへの参照が一つしかない場合、そのスカラがスコープ外になるとオブジェクトは破棄されます。オブジェクトをグローバルパッケージに格納している場合、そのオブジェクトはプログラムが終了するまでスコープ外にならないかもしれません。</target>
        </trans-unit>
        <trans-unit id="c4bd6e1ab0ed4ba3f062fe2340aa266f01cbc661" translate="yes" xml:space="preserve">
          <source>When the layer is pushed as part of an &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;PUSHED&lt;/code&gt; will be called</source>
          <target state="translated">レイヤーが &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; コールの一部としてプッシュされると、 &lt;code&gt;PUSHED&lt;/code&gt; が呼び出されます</target>
        </trans-unit>
        <trans-unit id="0128971f85240b4f39abca0c6ce4a11b4e096972" translate="yes" xml:space="preserve">
          <source>When the layer is pushed, the current value of &lt;code&gt;$PerlIO::encoding::fallback&lt;/code&gt; is saved and used as the CHECK argument when calling the Encode methods encode() and decode().</source>
          <target state="translated">レイヤーがプッシュされると、 &lt;code&gt;$PerlIO::encoding::fallback&lt;/code&gt; の現在の値が保存され、Encodeメソッドencode（）およびdecode（）を呼び出すときにCHECK引数として使用されます。</target>
        </trans-unit>
        <trans-unit id="8cb85b7bdde203de76612ce7dec71db2d2570629" translate="yes" xml:space="preserve">
          <source>When the lib module is first loaded it records the current value of @INC in an array &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; . To restore @INC to that value you can say</source>
          <target state="translated">libモジュールが最初にロードされると、 &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; に@INCの現在の値が記録されます。@INCをその値に戻すには、次のように言うことができます</target>
        </trans-unit>
        <trans-unit id="415f4830f0a5c60f55a1d0556cdab8350fdd12bf" translate="yes" xml:space="preserve">
          <source>When the match runs, the first part of the regular expression (&lt;code&gt;\b(foo)&lt;/code&gt; ) finds a possible match right at the beginning of the string, and loads up $1 with &quot;Foo&quot;. However, as soon as the matching engine sees that there's no whitespace following the &quot;Foo&quot; that it had saved in $1, it realizes its mistake and starts over again one character after where it had the tentative match. This time it goes all the way until the next occurrence of &quot;foo&quot;. The complete regular expression matches this time, and you get the expected output of &quot;table follows foo.&quot;</source>
          <target state="translated">一致が実行されると、正規表現の最初の部分（ &lt;code&gt;\b(foo)&lt;/code&gt; ）が文字列の先頭で一致の可能性を見つけ、$ 1に &quot;Foo&quot;をロードします。ただし、マッチングエンジンは、$ 1に保存した &quot;Foo&quot;の後に空白がないことを確認するとすぐに、その誤りを認識し、仮の一致があった場所の1文字後にもう一度やり直します。今回は次の &quot;foo&quot;が現れるまで続きます。今回は完全な正規表現が一致し、「table follows foo」の予想される出力が得られます。</target>
        </trans-unit>
        <trans-unit id="3d9aa22c95db143c4f71ce6060fc0fa951e547b8" translate="yes" xml:space="preserve">
          <source>When the object goes out of scope, the destructor is called. This destructor will attempt to unlink the file (using L</source>
          <target state="translated">オブジェクトがスコープ外になると、デストラクタが呼ばれます。このデストラクタはファイルのリンクを解除しようとします (L</target>
        </trans-unit>
        <trans-unit id="08260b550e8cbd87b7894a9886c2e5f84f74a639" translate="yes" xml:space="preserve">
          <source>When the optimisation criteria have been satisfied, &lt;code&gt;reg_try()&lt;/code&gt; is called to perform the match.</source>
          <target state="translated">最適化基準が満たされると、 &lt;code&gt;reg_try()&lt;/code&gt; が呼び出されて一致が実行されます。</target>
        </trans-unit>
        <trans-unit id="5ec2c96e37a54667487e24f12619de8d206380fe" translate="yes" xml:space="preserve">
          <source>When the output is a filename, it will truncate the contents of the file before writing any compressed data. If the output is a filehandle its position will not be changed. If the output is a buffer, it will be wiped before any compressed data is output.</source>
          <target state="translated">出力がファイル名の場合は、圧縮データを書き込む前にファイルの内容を切り詰めます。出力がファイルハンドルの場合、その位置は変更されません。出力がバッファの場合は、圧縮データが出力される前に消去されます。</target>
        </trans-unit>
        <trans-unit id="490632792a6bd230d4b7574b0a1ce3af888c0fe9" translate="yes" xml:space="preserve">
          <source>When the output is a filename, it will truncate the contents of the file before writing any uncompressed data. If the output is a filehandle its position will not be changed. If the output is a buffer, it will be wiped before any uncompressed data is output.</source>
          <target state="translated">出力がファイル名の場合には、 非圧縮デー タ を書き出す前に、 フ ァ イ ルの内容を切り詰めます。出力がファイルハンドルの場合は、その位置は変更されません。出力がバッファの場合は、非圧縮データが出力される前に消去されます。</target>
        </trans-unit>
        <trans-unit id="923167a1de1c89698b7cefa97410f6784a41b41c" translate="yes" xml:space="preserve">
          <source>When the program has terminated, the output may be examined and sorted using any standard text filtering utilities. Something like the following may be sufficient:</source>
          <target state="translated">プログラムが終了したら、標準的なテキストフィルタリングユーティリティを使って出力を調べたり、ソートしたりすることができます。以下のようなもので十分かもしれません。</target>
        </trans-unit>
        <trans-unit id="a2704235b2d8eb8f428696670573c7525bbfe494" translate="yes" xml:space="preserve">
          <source>When the script ends, and you want to change some values in the generated</source>
          <target state="translated">スクリプトが終了し、生成された</target>
        </trans-unit>
        <trans-unit id="116008ef85147614241af5722a4a2daf4c0fac34" translate="yes" xml:space="preserve">
          <source>When the script terminates the profiler will create a database of the profile information that you can turn into reports using the profiler's tools. See &amp;lt;perlperf&amp;gt; for details.</source>
          <target state="translated">スクリプトが終了すると、プロファイラーは、プロファイラーのツールを使用してレポートに変換できるプロファイル情報のデータベースを作成します。詳細については、&amp;lt;perlperf&amp;gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d7811c9ae79cafa461b23dd21d92c2852fa57021" translate="yes" xml:space="preserve">
          <source>When the string contains a Unicode named code point &lt;code&gt;\N{...}&lt;/code&gt;</source>
          <target state="translated">文字列にUnicode名前付きコードポイント &lt;code&gt;\N{...}&lt;/code&gt; が含まれている場合</target>
        </trans-unit>
        <trans-unit id="219689a8c46c6da015ee7181b846d635f06ea57d" translate="yes" xml:space="preserve">
          <source>When the string contains a Unicode-only code point</source>
          <target state="translated">文字列にユニコードのみのコードポイントが含まれている場合</target>
        </trans-unit>
        <trans-unit id="c5aaa6f97ab5589891e81e58fbc94f58509000ee" translate="yes" xml:space="preserve">
          <source>When the string has come from an external source marked as Unicode</source>
          <target state="translated">文字列が Unicode としてマークされた外部ソースから来ている場合</target>
        </trans-unit>
        <trans-unit id="33e82ba1ad1caecfef00b667970977ee30c1a1ff" translate="yes" xml:space="preserve">
          <source>When the taint mode (&lt;code&gt;-T&lt;/code&gt; ) is in effect, the &quot;.&quot; directory is removed from &lt;code&gt;@INC&lt;/code&gt; , and the environment variables &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;PERLLIB&lt;/code&gt; are ignored by Perl. You can still adjust &lt;code&gt;@INC&lt;/code&gt; from outside the program by using the &lt;code&gt;-I&lt;/code&gt; command line option as explained in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. The two environment variables are ignored because they are obscured, and a user running a program could be unaware that they are set, whereas the &lt;code&gt;-I&lt;/code&gt; option is clearly visible and therefore permitted.</source>
          <target state="translated">汚染モード（ &lt;code&gt;-T&lt;/code&gt; ）が有効な場合、「。」ディレクトリは &lt;code&gt;@INC&lt;/code&gt; から削除され、環境変数 &lt;code&gt;PERL5LIB&lt;/code&gt; および &lt;code&gt;PERLLIB&lt;/code&gt; はPerlによって無視されます。あなたはまだ調整でき &lt;code&gt;@INC&lt;/code&gt; を使用してプログラムの外部から &lt;code&gt;-I&lt;/code&gt; で説明したように、コマンドラインオプションを&lt;a href=&quot;perlrun&quot;&gt;perlrunを&lt;/a&gt;。 2つの環境変数は隠されているため無視され、プログラムを実行しているユーザーはそれらが設定されていることに気づかない可能性がありますが、 &lt;code&gt;-I&lt;/code&gt; オプションは明確に表示されるため許可されます。</target>
        </trans-unit>
        <trans-unit id="05614cc2a7184900b0ce6634ffcfa41b43df8b62" translate="yes" xml:space="preserve">
          <source>When the test file finishes, outputs the summary, together.</source>
          <target state="translated">テストファイルが終了したら、まとめて出力します。</target>
        </trans-unit>
        <trans-unit id="4c7dc2674104ea2267f99aaaacf86ff6b7f8474b" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;&lt;a href=&quot;given&quot;&gt;given&lt;/a&gt;&lt;/code&gt;. In Perl 5.14 and earlier, this form of &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; was only available when the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature was enabled. See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">BLOCKがない場合、 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; は、動的に囲まれた &lt;code&gt;foreach&lt;/code&gt; を繰り返したり、字句的に囲まれた &lt;code&gt;&lt;a href=&quot;given&quot;&gt;given&lt;/a&gt;&lt;/code&gt; を終了したりする代わりに、現在の &lt;code&gt;when&lt;/code&gt; または &lt;code&gt;default&lt;/code&gt; ブロックを通り抜ける関数です。 Perl 5.14以前では、この形式の &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 機能が有効になっている場合にのみ使用できました。詳細について&lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;は、perlsynの&lt;/a&gt;&lt;a href=&quot;../feature&quot;&gt;機能&lt;/a&gt;とスイッチステートメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="d0601e1c27a0dc14d5d3038756194559ec0b7177" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;given&lt;/code&gt; . In Perl 5.14 and earlier, this form of &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; was only available when the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature was enabled. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">BLOCKがない場合、 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; は、動的に囲まれた &lt;code&gt;foreach&lt;/code&gt; を繰り返したり、字句的に囲まれた &lt;code&gt;given&lt;/code&gt; を終了したりする代わりに、現在の &lt;code&gt;when&lt;/code&gt; または &lt;code&gt;default&lt;/code&gt; ブロックを通り抜ける関数です。Perl 5.14以前では、この形式の &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 機能が有効になっている場合にのみ使用できました。詳細について&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;は、perlsynの&lt;/a&gt;&lt;a href=&quot;feature&quot;&gt;機能&lt;/a&gt;とスイッチステートメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="d14e56899b59096c05cd14ff3a8ecfb95a7d60b7" translate="yes" xml:space="preserve">
          <source>When there is no method, it takes the method name as the name of the encoding and encodes the instance</source>
          <target state="translated">メソッドがない場合は、メソッド名をエンコード名とし、インスタンスをエンコードします。</target>
        </trans-unit>
        <trans-unit id="b009ed76d6586de96f41fbede53e1b376b816ad5" translate="yes" xml:space="preserve">
          <source>When these are embedded in another pattern, what they match does not change, regardless of parenthesization or what modifiers are in effect in that outer pattern.</source>
          <target state="translated">これらが別のパターンに埋め込まれている場合は、括弧で囲まれていても、その外側のパターンでどのような修飾子が有効であるかにかかわらず、それらが一致するものは変わりません。</target>
        </trans-unit>
        <trans-unit id="e1c33d2bb86243cd92baa102e04bd026d16cffb4" translate="yes" xml:space="preserve">
          <source>When this code is executed there is no output. Here's why:</source>
          <target state="translated">このコードを実行しても何も出力されません。これが理由です。</target>
        </trans-unit>
        <trans-unit id="7f61484b00c940e7437bf32bc5684d2e69d1807c" translate="yes" xml:space="preserve">
          <source>When this code is run only the &lt;code&gt;Derived&lt;/code&gt; object, &lt;code&gt;$b&lt;/code&gt; , will generate a warning.</source>
          <target state="translated">このコードを実行すると、 &lt;code&gt;Derived&lt;/code&gt; オブジェクト &lt;code&gt;$b&lt;/code&gt; のみが警告を生成します。</target>
        </trans-unit>
        <trans-unit id="917174880fc77c13ccda7d2e62ec7ea358e2a066" translate="yes" xml:space="preserve">
          <source>When this code is run with the &lt;b&gt;-w&lt;/b&gt; flag, a warning will be produced for the &lt;code&gt;$a&lt;/code&gt; line: &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; .</source>
          <target state="translated">このコードを&lt;b&gt;-w&lt;/b&gt;フラグを指定して実行すると、 &lt;code&gt;$a&lt;/code&gt; 行に対して警告が表示されます： &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16748736985dd4c981bc264b989b01547f68e378" translate="yes" xml:space="preserve">
          <source>When this form of the pragma is used, only the non-character portions of locales are used by Perl, for example &lt;code&gt;LC_NUMERIC&lt;/code&gt; . Perl assumes that you have translated all the characters it is to operate on into Unicode (actually the platform's native character set (ASCII or EBCDIC) plus Unicode). For data in files, this can conveniently be done by also specifying</source>
          <target state="translated">この形式のプラグマが使用される場合、ロケールの文字以外の部分（たとえば &lt;code&gt;LC_NUMERIC&lt;/code&gt; )のみが Perlによって使用されます。Perlは、操作対象のすべての文字をUnicode（実際にはプラットフォームのネイティブ文字セット（ASCIIまたはEBCDIC）に加えてUnicode）に変換したと見なします。ファイル内のデータの場合、これも指定することで便利に実行できます</target>
        </trans-unit>
        <trans-unit id="f3b915026102758b5ff7da846b6098df7e775168" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by</source>
          <target state="translated">この関数が呼び出されると</target>
        </trans-unit>
        <trans-unit id="01472604570ddd05a81c224b83daf7199b2292ca" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;OBJECT&lt;/code&gt; will be automagically derived from &lt;code&gt;O_FILES&lt;/code&gt; .</source>
          <target state="translated">これが &lt;code&gt;1&lt;/code&gt; に設定されている場合、 &lt;code&gt;OBJECT&lt;/code&gt; は自動的に &lt;code&gt;O_FILES&lt;/code&gt; から派生します。</target>
        </trans-unit>
        <trans-unit id="5e7dd367eef2d9f8124f8f23ef52e931a536491c" translate="yes" xml:space="preserve">
          <source>When this is true, CPAN will set PERL_MM_USE_DEFAULT to a true value. This causes ExtUtils::MakeMaker (and compatible) prompts to use default values instead of stopping to prompt you to answer questions. It also sets NONINTERACTIVE_TESTING to a true value to signal more generally that distributions should not try to interact with you.</source>
          <target state="translated">これが真の場合、CPAN は PERL_MM_USE_DEFAULT を真の値に設定します。これにより、ExtUtils::MakeMaker (および互換性のある)プロンプトは、質問への回答を促すために停止するのではなく、デフォルト値を使用するようになります。また、NONINTERACTIVE_TESTING を真の値に設定して、ディストリビューションがあなたと対話しようとしないことをより一般的に知らせるようにします。</target>
        </trans-unit>
        <trans-unit id="d2ca05f5323dff5f446952bd69ac6477b5186d11" translate="yes" xml:space="preserve">
          <source>When to Still Use local()</source>
          <target state="translated">それでも local()を使用する場合</target>
        </trans-unit>
        <trans-unit id="84389d029ef5726370dd8c2cf19105277288fbc8" translate="yes" xml:space="preserve">
          <source>When to Use OO</source>
          <target state="translated">OOを使用する場合</target>
        </trans-unit>
        <trans-unit id="1aff41766b1c1facad70ba1087945ce4b9ff69fd" translate="yes" xml:space="preserve">
          <source>When true this parameter will set the FLG.FHCRC bit to 1 in the gzip header and set the CRC16 header field to the CRC of the complete gzip header except the CRC16 field itself.</source>
          <target state="translated">真の場合、このパラメータはgzipヘッダのFLG.FHCRCビットを1に設定し、 CRC16ヘッダフィールドをCRC16フィールド自体を除く完全なgzipヘッダのCRCに設定する。</target>
        </trans-unit>
        <trans-unit id="71e94facdb69a355a340449fba8e5c34fbd178ec" translate="yes" xml:space="preserve">
          <source>When true, perform the generation and addition to the MANIFEST of the SIGNATURE file in the distdir during 'make distdir', via 'cpansign -s'.</source>
          <target state="translated">true の場合、'make distdir' の間に、'cpansign -s' を通して distdir にある SIGNATURE ファイルの MANIFEST の生成と追加を行います。</target>
        </trans-unit>
        <trans-unit id="2f8d8efe7dc5d620dd4b31a7d176203c2784135f" translate="yes" xml:space="preserve">
          <source>When true, suppresses the appending of installations to &lt;code&gt;perllocal&lt;/code&gt; .</source>
          <target state="translated">trueの場合、インストールの &lt;code&gt;perllocal&lt;/code&gt; への追加を抑制します。</target>
        </trans-unit>
        <trans-unit id="92a480e39d3219d70893b100f9cf0554ca8d0e6e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the generation and addition to the MANIFEST of the META.yml and META.json module meta-data files during 'make distdir'.</source>
          <target state="translated">true の場合、'make distdir' の間に META.yml と META.json モジュールのメタデータファイルの生成と MANIFEST への追加を抑制します。</target>
        </trans-unit>
        <trans-unit id="8f0d56eaaf65617686939dad5c1d3b6bcfce688e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the generation of MYMETA.yml and MYMETA.json module meta-data files during 'perl Makefile.PL'.</source>
          <target state="translated">trueの場合、'perl Makefile.PL'の間にMYMETA.ymlとMYMETA.jsonモジュールのメタデータファイルの生成を抑制します。</target>
        </trans-unit>
        <trans-unit id="b0686c4aa533a7288139fdb7b691343d38cb093e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the writing of &lt;code&gt;packlist&lt;/code&gt; files for installs.</source>
          <target state="translated">trueの場合、インストール用の &lt;code&gt;packlist&lt;/code&gt; ファイルの書き込みを抑制します。</target>
        </trans-unit>
        <trans-unit id="f79c2493f27b952ee97bbc3534495620a8d27f41" translate="yes" xml:space="preserve">
          <source>When trying to explain stacks, most computer science textbooks mumble something about spring-loaded columns of cafeteria plates: the last thing you pushed on the stack is the first thing you pop off. That'll do for our purposes: your C program will push some arguments onto &quot;the Perl stack&quot;, shut its eyes while some magic happens, and then pop the results--the return value of your Perl subroutine--off the stack.</source>
          <target state="translated">スタックを説明しようとするとき、ほとんどのコンピュータサイエンスの教科書は、カフェテリアの皿のバネのついた列について何かをつぶやいています:スタックに最後に押したものは、最初に飛び出すものです。あなたのCプログラムは、引数を &quot;Perlスタック &quot;にプッシュして、魔法のようなことが起こるまで目を閉じて、その結果(Perlサブルーチンの戻り値)をスタックからポップします。</target>
        </trans-unit>
        <trans-unit id="d64835545d5a37bef9d2f55b36f2fe943d1540a7" translate="yes" xml:space="preserve">
          <source>When tying a handle, the first argument to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; should begin with an asterisk. So, if you are tying STDOUT, use &lt;code&gt;*STDOUT&lt;/code&gt; . If you have assigned it to a scalar variable, say &lt;code&gt;$handle&lt;/code&gt; , use &lt;code&gt;*$handle&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; $handle&lt;/code&gt; ties the scalar variable &lt;code&gt;$handle&lt;/code&gt; , not the handle inside it.</source>
          <target state="translated">ハンドルを結ぶ場合、 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; の最初の引数はアスタリスクで始まる必要があります。したがって、STDOUTを使用する場合は、 &lt;code&gt;*STDOUT&lt;/code&gt; を使用します。これをスカラー変数（ &lt;code&gt;$handle&lt;/code&gt; など）に割り当てている場合は、 &lt;code&gt;*$handle&lt;/code&gt; 使用します。 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; $handle&lt;/code&gt; は、内部の &lt;code&gt;$handle&lt;/code&gt; ではなく、スカラー変数$ handleを結び付けます。</target>
        </trans-unit>
        <trans-unit id="47eb3f77b1aa39c24f8302cc0873a61651a1ff55" translate="yes" xml:space="preserve">
          <source>When used as a class method (&lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; , sometimes referred to as a static method), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">クラスメソッドとして使用する場合（ &lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; 、時には静的メソッドと呼ぶ） &lt;code&gt;isa&lt;/code&gt; 戻ります</target>
        </trans-unit>
        <trans-unit id="162b9c04aadf8419ca082eaa8547d0e2ff3e950b" translate="yes" xml:space="preserve">
          <source>When used as a filter we want to invoke it like this:</source>
          <target state="translated">フィルタとして使用する場合はこのように呼び出したいと思います。</target>
        </trans-unit>
        <trans-unit id="b4db60389b8735ef282c0fba599e707380d0e9b0" translate="yes" xml:space="preserve">
          <source>When used as an instance or class method (&lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">インスタンスまたはクラスメソッドとして使用（ &lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ）、 &lt;code&gt;isa&lt;/code&gt; 戻り</target>
        </trans-unit>
        <trans-unit id="5e6ec0259043a949cd69ad7f24d41a6b32189cc3" translate="yes" xml:space="preserve">
          <source>When used like this, options and their possible values are removed from &lt;code&gt;@myopts&lt;/code&gt; , the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched at all.</source>
          <target state="translated">このように使用すると、オプションとその可能な値が &lt;code&gt;@myopts&lt;/code&gt; から削除され、グローバル &lt;code&gt;@ARGV&lt;/code&gt; はまったく影響を受けません。</target>
        </trans-unit>
        <trans-unit id="ea41fdab3a3ea375bf5d28665d083eb7efcab0b4" translate="yes" xml:space="preserve">
          <source>When used like this:</source>
          <target state="translated">こんな風に使うと</target>
        </trans-unit>
        <trans-unit id="55e5fa91bb111ccb9cef7a1998ea49cd864765f0" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;#exists&quot;&gt;exists&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">ハッシュ要素で使用すると、キーがハッシュに存在するかどうかではなく、値が定義されているかどうかがわかります。後者の目的で使用され&lt;a href=&quot;#exists&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b6188971c7d17d6c416874631a361633fc0e0a7" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;exists&quot;&gt;exists&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">ハッシュ要素で使用すると、キーがハッシュに存在するかどうかではなく、値が定義されているかどうかがわかります。後者の目的で使用され&lt;a href=&quot;exists&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50c2719662a96956c6434b730a2ed7499859c514" translate="yes" xml:space="preserve">
          <source>When used on an element of an array or hash, &lt;code&gt;is_shared&lt;/code&gt; checks if the specified element belongs to a shared array or hash. (It does not check the contents of that element.)</source>
          <target state="translated">&lt;code&gt;is_shared&lt;/code&gt; は、配列またはハッシュの要素で使用すると、指定した要素が共有配列またはハッシュに属しているかどうかを確認します。（その要素の内容はチェックしません。）</target>
        </trans-unit>
        <trans-unit id="4c68152ee142aad2a08fe0b7ebba2ea1aa45f4fa" translate="yes" xml:space="preserve">
          <source>When used to pass a perl list to C the XS writer must provide a function (named after the array type but with 'Ptr' substituted for '*') to allocate the memory required to hold the list. A pointer should be returned. It is up to the XS writer to free the memory on exit from the function. The variable &lt;code&gt;ix_$var&lt;/code&gt; is set to the number of elements in the new array.</source>
          <target state="translated">PerlリストをCに渡すために使用する場合、XSライターは、リストを保持するために必要なメモリを割り当てる関数（配列タイプにちなんで名付けられますが、「*」が「Ptr」に置き換えられています）を提供する必要があります。ポインタが返されます。関数の終了時にメモリを解放するのはXSライターの責任です。変数 &lt;code&gt;ix_$var&lt;/code&gt; は、新しい配列の要素数に設定されます。</target>
        </trans-unit>
        <trans-unit id="39279e0ab9adf92c0d9845ce33153aaae548b141" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;.&lt;/code&gt;, the repeat count determines the starting position to calculate the value offset as follows:</source>
          <target state="translated">で使用し &lt;code&gt;.&lt;/code&gt; 場合。、繰り返し回数は、次のようにオフセット値を計算するための開始位置を決定します。</target>
        </trans-unit>
        <trans-unit id="059dd6ca0ad7f29f71f81bb70c2d0a3da8cc3820" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;@&lt;/code&gt; , the repeat count represents an offset from the start of the innermost &lt;code&gt;()&lt;/code&gt; group.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; と一緒に使用すると、繰り返し数は最も内側の &lt;code&gt;()&lt;/code&gt; グループの先頭からのオフセットを表します。</target>
        </trans-unit>
        <trans-unit id="745e9758fddddfd17b1f8070f37c73b6ef6dd2f4" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;Z&lt;/code&gt; , a &lt;code&gt;*&lt;/code&gt; as the repeat count is guaranteed to add a trailing null byte, so the resulting string is always one byte longer than the byte length of the item itself.</source>
          <target state="translated">で使用した場合 &lt;code&gt;Z&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 結果の文字列は、アイテム自体のバイト長より1台のバイト長く常にあるので、繰り返し回数としては、末尾のヌル・バイトを追加することが保証されています。</target>
        </trans-unit>
        <trans-unit id="501ee2b6d5b82410bf49c6ef557d5b8111f9b9e9" translate="yes" xml:space="preserve">
          <source>When used with class methods, the problem is even worse. Because Perl allows subroutine names to be written as barewords, Perl has to guess whether the bareword after the method is a class name or subroutine name. In other words, Perl can resolve the syntax as either &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt;&lt;b&gt;or&lt;/b&gt;&lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; .</source>
          <target state="translated">クラスメソッドで使用すると、問題はさらに悪化します。Perlでは、サブルーチン名をベアワードとして記述できるため、Perlは、メソッドの後のベアワードがクラス名なのかサブルーチン名なのかを推測する必要があります。言い換えれば、Perlは構文を &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt; &lt;b&gt;または&lt;/b&gt; &lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; として解決できます。</target>
        </trans-unit>
        <trans-unit id="f87eff678443c76527dd2ab6f92ce339964a9f84" translate="yes" xml:space="preserve">
          <source>When used with command line options:</source>
          <target state="translated">コマンドラインオプションで使用する場合。</target>
        </trans-unit>
        <trans-unit id="034d2956d3ab35d5d0a3009bf9f647819ce96d9f" translate="yes" xml:space="preserve">
          <source>When userelocatableinc is true, this variable holds the location that make install should copy the perl binary to, with all the run-time relocatable paths calculated from this at install time. When used, it is initialized to the original value of binexp, and then binexp is set to</source>
          <target state="translated">userelocatableinc が真の場合、この変数は make install が perl バイナリをコピーする場所を保持します。使用される場合は、binexp の元の値に初期化され、binexp が</target>
        </trans-unit>
        <trans-unit id="52d8c19f5d99981fe4c4d2fcb09c34b0b19ca9a0" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; on a &lt;code&gt;()&lt;/code&gt; group, this affects all types inside the group that accept byte-order modifiers, including all subgroups. It is silently ignored for all other types. You are not allowed to override the byte-order within a group that already has a byte-order modifier suffix.</source>
          <target state="translated">使用する場合 &lt;code&gt;&amp;gt;&lt;/code&gt; または &lt;code&gt;&amp;lt;&lt;/code&gt; 上 &lt;code&gt;()&lt;/code&gt; 群、これはすべてのサブグループを含む、バイト順修飾子を受け入れるグループ内のすべてのタイプに影響を与えます。他のすべてのタイプでは、黙って無視されます。すでにバイト順修飾子のサフィックスが付いているグループ内のバイト順を上書きすることはできません。</target>
        </trans-unit>
        <trans-unit id="834a7e8ec8b7da2f955444b22e5081d5fee5d139" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Exporter&lt;/code&gt; with the standard &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas, the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; keyword is needed to declare the package variables &lt;code&gt;@EXPORT_OK&lt;/code&gt; , &lt;code&gt;@EXPORT&lt;/code&gt; , &lt;code&gt;@ISA&lt;/code&gt; , etc.</source>
          <target state="translated">使用する場合は &lt;code&gt;Exporter&lt;/code&gt; 規格に &lt;code&gt;strict&lt;/code&gt; と &lt;code&gt;warnings&lt;/code&gt; プラグマ、 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; キーワードは、パッケージ変数を宣言するために必要とされる &lt;code&gt;@EXPORT_OK&lt;/code&gt; 、 &lt;code&gt;@EXPORT&lt;/code&gt; 、 &lt;code&gt;@ISA&lt;/code&gt; など</target>
        </trans-unit>
        <trans-unit id="098b7ca0910242ebfe289953bb787b86df641163" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Open3&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, it is assumed to be appropriately escaped. You can use the &lt;code&gt;QUOTE&lt;/code&gt; constant to use as a portable quote character (see above). However, if you provide an array reference, special rules apply:</source>
          <target state="translated">使用する場合は &lt;code&gt;IPC::Open3&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 、あなたのように文字列を提供する場合、 &lt;code&gt;command&lt;/code&gt; 引数、適切にエスケープされているものとします。 &lt;code&gt;QUOTE&lt;/code&gt; 定数を使用して、移植可能な引用文字として使用できます（上記を参照）。ただし、配列参照を提供する場合は、特別な規則が適用されます。</target>
        </trans-unit>
        <trans-unit id="ac72f6ccde75b586d99f93dce2fef690fbdd778e" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Run&lt;/code&gt; , if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, the string will be split on whitespace to determine the individual elements of your command. Although this will usually just Do What You Mean, it may break if you have files or commands with whitespace in them.</source>
          <target state="translated">&lt;code&gt;IPC::Run&lt;/code&gt; を使用する場合、 &lt;code&gt;command&lt;/code&gt; 引数として文字列を指定すると、コマンドの個々の要素を決定するために文字列が空白で分割されます。これは通常、単にあなたの意味を実行しますが、空白が含まれているファイルまたはコマンドがあると、壊れる可能性があります。</target>
        </trans-unit>
        <trans-unit id="887f4ef11aea133bd95f7e158dd018aa1d9071b1" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;autodie&lt;/code&gt; or &lt;code&gt;Fatal&lt;/code&gt; with user subroutines, the declaration of those subroutines must appear before the first use of &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; , or have been exported from a module. Attempting to use &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; on other user subroutines will result in a compile-time error.</source>
          <target state="translated">使用する場合 &lt;code&gt;autodie&lt;/code&gt; または &lt;code&gt;Fatal&lt;/code&gt; ユーザサブルーチンとを、それらのサブルーチンの宣言は、最初の使用の前に現れなければならない &lt;code&gt;Fatal&lt;/code&gt; または &lt;code&gt;autodie&lt;/code&gt; 、またはモジュールからエクスポートされています。他のユーザーサブルーチンで &lt;code&gt;Fatal&lt;/code&gt; または &lt;code&gt;autodie&lt;/code&gt; を使用しようとすると、コンパイル時エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="8ea0745997af7ee70fec196994401476b7830212" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fd_retrieve&lt;/code&gt; , objects are retrieved in sequence, one object (i.e. one recursive tree) per associated &lt;code&gt;store_fd&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;fd_retrieve&lt;/code&gt; を使用すると、オブジェクトは順番に取得され、関連付けられた &lt;code&gt;store_fd&lt;/code&gt; ごとに1つのオブジェクト（つまり、1つの再帰的ツリー）が取得されます。</target>
        </trans-unit>
        <trans-unit id="e2d48fc5105eb38ba5d5e3af6a3868bf8d76aac7" translate="yes" xml:space="preserve">
          <source>When using GCC, that entry specifies that MakeMaker should first look for &lt;code&gt;libgl.a&lt;/code&gt; (followed by &lt;code&gt;gl.a&lt;/code&gt; ) in all the locations specified by &lt;code&gt;$Config{libpth}&lt;/code&gt; .</source>
          <target state="translated">GCCを使用する場合、そのエントリは、MakeMakerが最初に &lt;code&gt;$Config{libpth}&lt;/code&gt; 指定されたすべての場所で &lt;code&gt;libgl.a&lt;/code&gt; （後に &lt;code&gt;gl.a&lt;/code&gt; ）を探すように指定します。</target>
        </trans-unit>
        <trans-unit id="d3c3fbdf4905ed574790e43ad2b1e958281ade4d" translate="yes" xml:space="preserve">
          <source>When using Module::Build, this will usually be:</source>
          <target state="translated">Module::Buildを使用する場合、通常はこれになります。</target>
        </trans-unit>
        <trans-unit id="04e10d3b847f5d46ec45809bdc9654ea510527e6" translate="yes" xml:space="preserve">
          <source>When using PUSHCOLOR, POPCOLOR, and LOCALCOLOR, it's particularly important to not put commas between the constants.</source>
          <target state="translated">PUSHCOLOR、POPCOLOR、LOCALCOLORを使用する場合は、定数の間にカンマを入れないことが特に重要です。</target>
        </trans-unit>
        <trans-unit id="0fcdfebaed2e26ac7b40fe2bc2a6520f86b06a73" translate="yes" xml:space="preserve">
          <source>When using Term::ReadLine, you can turn ornaments on so that your input stands out against the output from CPAN.pm.</source>
          <target state="translated">Term::ReadLineを使用している場合、CPAN.pmからの出力に対して入力が目立つように装飾をオンにすることができます。</target>
        </trans-unit>
        <trans-unit id="3bb24a915046f34ce04a56f60336d0fb58d6c025" translate="yes" xml:space="preserve">
          <source>When using Unix or MSDOS syntax this emulates the &lt;code&gt;dirname(1)&lt;/code&gt; shell function which is subtly different from how &lt;code&gt;fileparse()&lt;/code&gt; works. It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; for file paths.</source>
          <target state="translated">UnixまたはMSDOS構文を使用する場合、 &lt;code&gt;fileparse()&lt;/code&gt; の動作とは微妙に異なる &lt;code&gt;dirname(1)&lt;/code&gt; シェル関数をエミュレートします。最後のレベルが明らかにディレクトリであっても、ファイルパスの最後のレベルを除くすべてを返します。実際には、それはディレクトリ部分を返すのではなく、ファイルパスの &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; のように機能する1レベル上のパスを返します。</target>
        </trans-unit>
        <trans-unit id="cd36b103bb843eb67404d1ba086bba3444a9a91a" translate="yes" xml:space="preserve">
          <source>When using a compiler other than GCC, the above entry will search for &lt;code&gt;gl.lib&lt;/code&gt; (followed by &lt;code&gt;libgl.lib&lt;/code&gt; ).</source>
          <target state="translated">GCC以外のコンパイラを使用する場合、上記のエントリは &lt;code&gt;gl.lib&lt;/code&gt; を検索します（その後に &lt;code&gt;libgl.lib&lt;/code&gt; が続きます）。</target>
        </trans-unit>
        <trans-unit id="a204d7a3df2c41a83e110893f714e673583621f8" translate="yes" xml:space="preserve">
          <source>When using a custom engine that doesn't support the &lt;code&gt;(?:)&lt;/code&gt; construct for inline modifiers, it's probably best to have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</source>
          <target state="translated">インライン修飾子の &lt;code&gt;(?:)&lt;/code&gt; 構成をサポートしないカスタムエンジンを使用する場合、 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; を指定されたパターンに文字列化するのがおそらく最善です。これにより、次のような場合に望ましくないパターンが作成されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="aa29772ff0d1046f60f263e930495cc6300916c4" translate="yes" xml:space="preserve">
          <source>When using a signature, the arguments are still available in the special array variable &lt;code&gt;@_&lt;/code&gt; , in addition to the lexical variables of the signature. There is a difference between the two ways of accessing the arguments: &lt;code&gt;@_&lt;/code&gt;</source>
          <target state="translated">署名を使用する場合、引数は、署名の字句変数に加えて、特別な配列変数 &lt;code&gt;@_&lt;/code&gt; でも引き続き使用できます。引数にアクセスする2つの方法には違いがあります： &lt;code&gt;@_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="551ef8173c29847114a58bb1f60332f351498c93" translate="yes" xml:space="preserve">
          <source>When using any of these routines (except &lt;code&gt;call_argv&lt;/code&gt; ), the programmer must manipulate the Perl stack. These include the following macros and functions:</source>
          <target state="translated">これらのルーチン（ &lt;code&gt;call_argv&lt;/code&gt; を除く）のいずれかを使用する場合、プログラマーはPerlスタックを操作する必要があります。これらには、次のマクロと関数が含まれます。</target>
        </trans-unit>
        <trans-unit id="b83deb7885e7123190175e707dccaec554d080b8" translate="yes" xml:space="preserve">
          <source>When using look-ahead assertions and negations, this can all get even trickier. Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;. You might try to write that as</source>
          <target state="translated">先読みアサーションや否定を使用すると、これがさらに厄介になることがあります。123&quot; の後に &quot;123 &quot;が続いていない非数値の連続を見つけたいと想像してみてください。次のように書いてみましょう。</target>
        </trans-unit>
        <trans-unit id="104bb1d18df407b49f695cf681f4f8244f6c16f3" translate="yes" xml:space="preserve">
          <source>When using perl on OS/390 please keep in mind that the EBCDIC and ASCII character sets are different. See perlebcdic.pod for more on such character set issues. Perl builtin functions that may behave differently under EBCDIC are also mentioned in the perlport.pod document.</source>
          <target state="translated">OS/390 で perl を使うときは、EBCDIC と ASCII の文字セットが異なることを覚えておいてください。そのような文字セットの問題については perlebcdic.pod を参照してください。EBCDIC の下で異なる動作をするかもしれない Perl の組み込み関数は、perlport.pod のドキュメントにも記載されています。</target>
        </trans-unit>
        <trans-unit id="1ef7e739e319a736386db6464491dd098d4f2bf1" translate="yes" xml:space="preserve">
          <source>When using perldoc in it's &lt;code&gt;-m&lt;/code&gt; mode (display module source code), &lt;code&gt;perldoc&lt;/code&gt; will attempt to use the pager set in &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; . A useful setting for this command is your favorite editor as in &lt;code&gt;/usr/bin/nano&lt;/code&gt; . (Don't judge me.)</source>
          <target state="translated">それの中にはperldoc使用する場合は &lt;code&gt;-m&lt;/code&gt; モード（ディスプレイモジュールのソースコードを）、 &lt;code&gt;perldoc&lt;/code&gt; のは、ページャのセットを使用しようとします &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; 。このコマンドの便利な設定は、 &lt;code&gt;/usr/bin/nano&lt;/code&gt; にあるようなお気に入りのエディターです。（私を判断しないでください。）</target>
        </trans-unit>
        <trans-unit id="6f3d08e19ee9978bf8615d5e1fb391a30ff5fc30" translate="yes" xml:space="preserve">
          <source>When using the &quot;syn&quot; protocol, use this method to determine the reachability of the remote host. This method is meant to be called up to as many times as ping() was called. Each call returns the host (as passed to ping()) that came back with the TCP ACK. The order in which the hosts are returned may not necessarily be the same order in which they were SYN queued using the ping() method. If the timeout is reached before the TCP ACK is received, or if the remote host is not listening on the port attempted, then the TCP connection will not be established and ack() will return undef. In list context, the host, the ack time, and the dotted ip string will be returned instead of just the host. If the optional $host argument is specified, the return value will be pertaining to that host only. This call simply does nothing if you are using any protocol other than syn.</source>
          <target state="translated">syn&quot; プロトコルを使用する場合、このメソッドを使用してリモートホストの到達可能性を判断します。このメソッドは、ping()が呼び出された回数だけ呼び出されることを意味します。各呼び出しは、TCP ACK を返してきたホスト (ping()に渡されたホスト)を返します。ホストが返される順番は、必ずしも ping()メソッドを使用して SYN キューに入れられた順番と同じとは限りません。TCP ACK を受信する前にタイムアウトに達した場合、またはリモートホストが試みたポートをリッスンしていない場合、TCP 接続は確立されず、 ack()は undef を返します。リストコンテキストでは、ホストだけではなく、ホスト、ACK時間、点線付きのIP文字列が返されます。オプションの $host 引数が指定された場合は、そのホストに関するものだけが返されます。syn 以外のプロトコルを使っている場合、この呼び出しは何もしません。</target>
        </trans-unit>
        <trans-unit id="8669a447d2a5338b38de691880feda228a223459" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;+&lt;/code&gt; prototype, your function must check that the argument is of an acceptable type.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; プロトタイプを使用する場合、関数は引数が受け入れ可能なタイプであることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="665e3521b5bde08e89b6fb412400db5ea3876686" translate="yes" xml:space="preserve">
          <source>When using the Borland compiler, the second item is returned as &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt;, and MakeMaker takes care of moving the &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; to the correct place in the linker command line.</source>
          <target state="translated">Borlandコンパイラーを使用する場合、2番目の項目は &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt; として返され、MakeMakerが &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; をリンカーコマンドラインの正しい場所に移動します。</target>
        </trans-unit>
        <trans-unit id="182973d530ef056d12686b9b768cbe121c56d846" translate="yes" xml:space="preserve">
          <source>When using the GUI version of SAM, click on the Kernel Configuration icon, then the Configurable Parameters icon. Scroll down and select the maxdsiz line. From the Actions menu, select the Modify Configurable Parameter item. Insert the new formula into the Formula/Value box. Then follow the instructions to rebuild your kernel and reboot your system.</source>
          <target state="translated">GUI 版の SAM を使用する場合は、[Kernel Configuration]アイコンをクリックし、[Configurable Parameters]アイコンをクリックします。下にスクロールして、maxdsiz 行を選択します。Actions」メニューから「Modify Configurable Parameter」項目を選択します。Formula/Value ボックスに新しい式を挿入します。その後、指示に従ってカーネルを再構築し、システムを再起動します。</target>
        </trans-unit>
        <trans-unit id="7f3f457ad81c7a19053f3621a5ae319fe9cb4521" translate="yes" xml:space="preserve">
          <source>When using the Visual C compiler, the second item is returned as &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt;.</source>
          <target state="translated">Visual Cコンパイラーを使用する場合、2番目の項目は &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt; として返されます。</target>
        </trans-unit>
        <trans-unit id="fa76c289706bb600b3c9b3e3777d7935b3662cb5" translate="yes" xml:space="preserve">
          <source>When using the constants, if you don't want to have to remember to add the &lt;code&gt;, RESET&lt;/code&gt; at the end of each print line, you can set $Term::ANSIColor::AUTORESET to a true value. Then, the display mode will automatically be reset if there is no comma after the constant. In other words, with that variable set:</source>
          <target state="translated">定数を使用するときに、各印刷行の最後に &lt;code&gt;, RESET&lt;/code&gt; を追加することを忘れたくない場合は、 $ Term :: ANSIColor :: AUTORESETをtrue値に設定できます。その後、定数の後にコンマがない場合、表示モードは自動的にリセットされます。つまり、その変数を設定すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="a51c1c8c0eb3074d9df3759b3281e7508c8091a5" translate="yes" xml:space="preserve">
          <source>When using this compiler to build Perl, you should make sure that the flag -Aa is added to the cpprun and cppstdin variables in the config.sh file (though see the section on 64-bit perl below). If you are using a recent version of the Perl distribution, these flags are set automatically.</source>
          <target state="translated">このコンパイラを使用して Perl をビルドする場合、config.sh ファイルの cpprun と cppstdin 変数に -Aa フラグが追加されていることを確認する必要があります (ただし、下記の 64-bit perl のセクションを参照してください)。最近のバージョンの Perl ディストリビューションを使用している場合、これらのフラグは自動的に設定されます。</target>
        </trans-unit>
        <trans-unit id="9d278a4b7e876e4a2527267176d89369b93fdace" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">既存のダイジェスト文字列を検証するときは、ダイジェストをソルトとして使用する必要があります（ &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ）。ダイジェストの作成に使用されたSALTは、ダイジェストの一部として表示されます。これにより、crypt（）は新しい文字列をダイジェストと同じソルトでハッシュします。これにより、コードを標準の&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;とよりエキゾチックな実装で動作させることができます。つまり、返される文字列自体や、SALTの何バイトが問題になるかについては何も想定しないでください。</target>
        </trans-unit>
        <trans-unit id="1154d04d428d0c152c2ffba2d49aad6c93079515" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">既存のダイジェスト文字列を検証するときは、ダイジェストをソルトとして使用する必要があります（ &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ）。ダイジェストの作成に使用されたSALTは、ダイジェストの一部として表示されます。これにより、crypt（）は新しい文字列をダイジェストと同じソルトでハッシュします。これにより、コードを標準の&lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt;とよりエキゾチックな実装で動作させることができます。つまり、返される文字列自体や、SALTの何バイトが問題になるかについては何も想定しないでください。</target>
        </trans-unit>
        <trans-unit id="3ffe4a395b717a174f8af1eb199172f9bf8e1018" translate="yes" xml:space="preserve">
          <source>When we bless something, we are not blessing the variable which contains a reference to that thing, nor are we blessing the reference that the variable stores; we are blessing the thing that the variable refers to (sometimes known as the</source>
          <target state="translated">私たちが何かを祝福するとき、私たちはそのものへの参照を含む変数を祝福しているのではありませんし、変数が格納する参照を祝福しているのでもありません。</target>
        </trans-unit>
        <trans-unit id="7f1d89cf9a7bec3f0e241604b9f6d2928198590e" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; on a variable, we are actually blessing the underlying data structure that the variable refers to. We are not blessing the reference itself, nor the variable that contains that reference. That's why the second call to &lt;code&gt;blessed( $bar )&lt;/code&gt; returns false. At that point &lt;code&gt;$bar&lt;/code&gt; is no longer storing a reference to an object.</source>
          <target state="translated">変数に対して &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; を呼び出すと、実際には、変数が参照する基本的なデータ構造が祝福されます。参照自体も、その参照を含む変数も祝福していません。そのため、 &lt;code&gt;blessed( $bar )&lt;/code&gt; への2番目の呼び出しはfalseを返します。その時点で、 &lt;code&gt;$bar&lt;/code&gt; はオブジェクトへの参照を格納していません。</target>
        </trans-unit>
        <trans-unit id="c70879bf53ea832ca0790a74069f648240179f77" translate="yes" xml:space="preserve">
          <source>When we make a method call, Perl arranges for the method's &lt;b&gt;invocant&lt;/b&gt; to be passed as the first argument. &lt;b&gt;Invocant&lt;/b&gt; is a fancy name for the thing on the left side of the arrow. The invocant can either be a class name or an object. We can also pass additional arguments to the method:</source>
          <target state="translated">私たちは、メソッドの呼び出しを行う場合は、この方法のためのPerl並べ&lt;b&gt;インボカントは、&lt;/b&gt;最初の引数として渡されます。&lt;b&gt;Invocaant&lt;/b&gt;は、矢印の左側にあるもののファンシーな名前です。呼び出し元は、クラス名またはオブジェクトのいずれかです。メソッドに追加の引数を渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="8e5660d78c1c3767afae15f24a83c561307c4b20" translate="yes" xml:space="preserve">
          <source>When we say &quot;Mac OS&quot; below, we mean Mac OS 7, 8, and 9, and</source>
          <target state="translated">以下、「Mac OS」というと、Mac OS 7、8、9のことであり</target>
        </trans-unit>
        <trans-unit id="32e492af43a84b7607b727f8ffe43ea47c5296c8" translate="yes" xml:space="preserve">
          <source>When we want to place values to be returned to the caller onto the stack, we use the series of macros that begin with &quot;XPUSH&quot;. There are five different versions, for placing integers, unsigned integers, doubles, strings, and Perl scalars on the stack. In our example, we placed a Perl scalar onto the stack. (In fact this is the only macro which can be used to return multiple values.)</source>
          <target state="translated">呼び出し元に返す値をスタックに配置したい場合は、&quot;XPUSH &quot;で始まる一連のマクロを使います。スタック上に整数、符号なし整数、倍数、文字列、Perl スカラを配置するための 5 つのバージョンがあります。この例では、Perlのスカラをスタックに配置しています。(実際には、これは複数の値を返すために使用できる唯一のマクロです)。</target>
        </trans-unit>
        <trans-unit id="5c32617504af087d7eaf74d60f9f81f18d15e5a1" translate="yes" xml:space="preserve">
          <source>When words that are longer than &lt;code&gt;$columns&lt;/code&gt; are encountered, they are broken up. &lt;code&gt;wrap()&lt;/code&gt; adds a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at column &lt;code&gt;$columns&lt;/code&gt; . This behavior can be overridden by setting &lt;code&gt;$huge&lt;/code&gt; to 'die' or to 'overflow'. When set to 'die', large words will cause &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; to be called. When set to 'overflow', large words will be left intact.</source>
          <target state="translated">&lt;code&gt;$columns&lt;/code&gt; より長い単語が検出されると、それらは分割されます。 &lt;code&gt;wrap()&lt;/code&gt; は、列 &lt;code&gt;$columns&lt;/code&gt; &lt;code&gt;&quot;\n&quot;&lt;/code&gt; を追加します。この動作は、 &lt;code&gt;$huge&lt;/code&gt; を「die」または「overflow」に設定することでオーバーライドできます。「die」に設定されている場合、大きな単語によって &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; が呼び出されます。「オーバーフロー」に設定すると、大きな単語はそのまま残ります。</target>
        </trans-unit>
        <trans-unit id="52a8fd5862d63d0243193e3a0106e35c7816b525" translate="yes" xml:space="preserve">
          <source>When writing a DBM filter it is</source>
          <target state="translated">DBMフィルタを書くときは</target>
        </trans-unit>
        <trans-unit id="6e29ef5da6dd2ada1107f66b4d19daef44972a34" translate="yes" xml:space="preserve">
          <source>When writing a Perl extension for general consumption, one should expect that the extension will be used with versions of Perl different from the version available on your machine. Since you are reading this document, the version of Perl on your machine is probably 5.005 or later, but the users of your extension may have more ancient versions.</source>
          <target state="translated">一般消費のためにPerlの拡張機能を書く場合、その拡張機能はあなたのマシンで利用可能なバージョンとは異なるPerlのバージョンで使用されることを期待しなければなりません。あなたがこのドキュメントを読んでいるので、あなたのマシン上のPerlのバージョンはおそらく5.005以降ですが、あなたの拡張機能のユーザはもっと古いバージョンを持っているかもしれません。</target>
        </trans-unit>
        <trans-unit id="b339c5d874b742d033a9c15bc59a2eb32b3fde03" translate="yes" xml:space="preserve">
          <source>When writing a character UV to a UTF-8 string, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;uvchr_to_utf8&lt;/code&gt; , unless &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; in which case you can use &lt;code&gt;*s = uv&lt;/code&gt; .</source>
          <target state="translated">UTF-8文字列に文字のUVを書くとき、&lt;b&gt;常に&lt;/b&gt;使用 &lt;code&gt;uvchr_to_utf8&lt;/code&gt; ない限り、 &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; 、その場合には、使用することができます &lt;code&gt;*s = uv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f50a991a4544cc3b4a29ac32fb9e95a158b8cf9" translate="yes" xml:space="preserve">
          <source>When writing a gzip file this interface will</source>
          <target state="translated">gzip ファイルを書くとき、このインターフェイスは</target>
        </trans-unit>
        <trans-unit id="bb628954db56a328fb9c77ac1ab1c6c9e5566f04" translate="yes" xml:space="preserve">
          <source>When writing to a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before writing to the file.</source>
          <target state="translated">ファイルまたはファイルハンドルに書き込むときは、ファイルに書き込む前に &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; を設定します。</target>
        </trans-unit>
        <trans-unit id="b83d473ca051f901386a9b5075ab3cc8642b96d1" translate="yes" xml:space="preserve">
          <source>When you</source>
          <target state="translated">あなたが</target>
        </trans-unit>
        <trans-unit id="2677cbf7ed31e30ff85aaafd2211c14bcf4260ba" translate="yes" xml:space="preserve">
          <source>When you are content with suspects list, you can now</source>
          <target state="translated">あなたが容疑者のリストに満足している場合は、今すぐにすることができます。</target>
        </trans-unit>
        <trans-unit id="2f2f89e3cbdda44107d5b7350f0150202920760d" translate="yes" xml:space="preserve">
          <source>When you are done, the XS-module install process will have added information to your &quot;perllocal&quot; information telling that the perl binary has been replaced, and what module was installed. You can view this information at any time by using the command:</source>
          <target state="translated">XSモジュールのインストールが完了すると、XSモジュールのインストール処理では、perlバイナリが置き換えられたことと、どのモジュールがインストールされたかを示す情報が &quot;perllocal &quot;情報に追加されます。この情報はコマンドを使うことでいつでも見ることができます。</target>
        </trans-unit>
        <trans-unit id="081b49cdc45047c15c231503ee57d721c9ac98ea" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself from the sources (available from e.g. &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="translated">GNU Cコンパイラ（gcc）を使用する予定で、まだgccがない場合は、ソースから自分でビルドすることもできます（例：&lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http&lt;/a&gt; : //gcc.gnu.org/mirrors.htmlから入手可能）または、&lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http：&lt;/a&gt; //hpux.connect.org.uk/hppd/cgi-bin/search？term = gcc＆Search = Search のHPポーティングセンターから、またはhttpのDSPP（メンバーである必要があります）からビルド済みのバイナリをフェッチし&lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;ます。 ：//h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801？ciid = 2a08725cc2f02110725cc2f02110275d6e10RCRD＆jumpid = reg_r1002_usen_c-001_title_r0001&lt;/a&gt;（複数のバージョンを使用できるため、同じパッケージを参照できます）。</target>
        </trans-unit>
        <trans-unit id="1e1fba30b9427287c1016e2b2ee037287889c225" translate="yes" xml:space="preserve">
          <source>When you are manually creating a UCM file, you should copy ascii.ucm or an existing encoding which is close to yours, rather than write your own from scratch.</source>
          <target state="translated">UCM ファイルを手動で作成する場合は、自分のものをゼロから書くのではなく、ascii.ucm や自分のものに近い既存のエンコーディングをコピーするべきです。</target>
        </trans-unit>
        <trans-unit id="4780d196081ec9146c3e56c719b52c3ce1654983" translate="yes" xml:space="preserve">
          <source>When you are satisfied with the results of tests, install the build C libraries for extensions:</source>
          <target state="translated">テストの結果に納得できたら、拡張機能用のビルドCライブラリをインストールします。</target>
        </trans-unit>
        <trans-unit id="a59f72a1e66eb8909341fcc7e63f4b0c726287dd" translate="yes" xml:space="preserve">
          <source>When you are sure that only a few subdirectories lead to failures, you may want to add &lt;code&gt;-j4&lt;/code&gt; option to &lt;code&gt;make&lt;/code&gt; to speed up skipping subdirectories with already finished build.</source>
          <target state="translated">いくつかのサブディレクトリだけが失敗につながると確信している場合は、 &lt;code&gt;-j4&lt;/code&gt; オプションを追加して、すでにビルドが完了しているサブディレクトリのスキップを高速化する &lt;code&gt;make&lt;/code&gt; ができます。</target>
        </trans-unit>
        <trans-unit id="c0610c400691e07d6b5c5967ea7cb5f197bdd7da" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;stream&quot; protocol, this call pre-opens the tcp socket. It's only necessary to do this if you want to provide a different timeout when creating the connection, or remove the overhead of establishing the connection from the first ping. If you don't call &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, the connection is automatically opened the first time &lt;code&gt;ping()&lt;/code&gt; is called. This call simply does nothing if you are using any protocol other than stream.</source>
          <target state="translated">「ストリーム」プロトコルを使用している場合、この呼び出しはtcpソケットを事前に開きます。接続を作成するときに別のタイムアウトを指定する場合、または最初のpingから接続を確立するオーバーヘッドを削除する場合にのみ、これを行う必要があります。 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; を呼び出さない場合、最初に &lt;code&gt;ping()&lt;/code&gt; が呼び出されたときに接続が自動的に開かれます。ストリーム以外のプロトコルを使用している場合、この呼び出しは単に何もしません。</target>
        </trans-unit>
        <trans-unit id="a9fd269eddc721c08a06a789973e8783627db576" translate="yes" xml:space="preserve">
          <source>When you build modules, tell Perl where to install the modules.</source>
          <target state="translated">モジュールをビルドする際に、Perlにモジュールをインストールする場所を指定します。</target>
        </trans-unit>
        <trans-unit id="d2efe854f0b34964ee2879b9748bb899c2079d18" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;bar&lt;/code&gt; with arguments, you see that &lt;code&gt;foo&lt;/code&gt; got the same &lt;code&gt;@_&lt;/code&gt; :</source>
          <target state="translated">引数を指定して &lt;code&gt;bar&lt;/code&gt; を呼び出すと、 &lt;code&gt;foo&lt;/code&gt; が同じ &lt;code&gt;@_&lt;/code&gt; を取得していることがわかります。</target>
        </trans-unit>
        <trans-unit id="010f5217ea46f708fe21b0efa65632329708b27e" translate="yes" xml:space="preserve">
          <source>When you call a method, the thing on the left side of the arrow is passed as the first argument to the method. That means when we call &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; , the &lt;code&gt;new()&lt;/code&gt; method receives the string &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; as its first argument. When we call &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; , the &lt;code&gt;$fred&lt;/code&gt; variable is passed as the first argument to &lt;code&gt;speak()&lt;/code&gt; .</source>
          <target state="translated">メソッドを呼び出すと、矢印の左側にあるものが最初の引数としてメソッドに渡されます。つまり、 &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; を呼び出すと、 &lt;code&gt;new()&lt;/code&gt; メソッドは最初の引数として文字列 &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; を受け取ります。 &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; を呼び出すと、 &lt;code&gt;$fred&lt;/code&gt; 変数は、 &lt;code&gt;speak()&lt;/code&gt; の最初の引数として渡されます。</target>
        </trans-unit>
        <trans-unit id="f9ac7d5348373bdb94113353aa9433d2aa26a56e" translate="yes" xml:space="preserve">
          <source>When you change a &lt;b&gt;value&lt;/b&gt; as it is being copied. [From French &amp;ldquo;in passing&amp;rdquo;, as in the exotic pawn-capturing maneuver in chess.]</source>
          <target state="translated">コピーされている&lt;b&gt;値&lt;/b&gt;を変更したとき。[チェスでのエキゾチックなポーン捕獲マニューバのように、「通過中」のフランス語から。]</target>
        </trans-unit>
        <trans-unit id="f19e6c82fbc2b2542cdae76f95f1a0c2e0deb19b" translate="yes" xml:space="preserve">
          <source>When you chop() a mathemagical object it is promoted to a string and its mathemagical properties are lost. The same can happen with other operations as well.</source>
          <target state="translated">数学的オブジェクトを chop()すると、それは文字列に昇格し、その数学的プロパティは失われます。他の操作でも同じことが起こります。</target>
        </trans-unit>
        <trans-unit id="ffb591449d98f90fa2f19a8fc5d8c220dd517b21" translate="yes" xml:space="preserve">
          <source>When you combine legacy data and Unicode, the legacy data needs to be upgraded to Unicode. Normally the legacy data is assumed to be ISO 8859-1 (or EBCDIC, if applicable).</source>
          <target state="translated">レガシーデータとユニコードを組み合わせる場合、レガシーデータをユニコードにアップグレードする必要があります。通常、レガシーデータは ISO 8859-1 (該当する場合は EBCDIC)を前提としています。</target>
        </trans-unit>
        <trans-unit id="177eeefc399a73cfd5bfb70b98c9df5de8601114" translate="yes" xml:space="preserve">
          <source>When you create a map, you SHOULD make your mappings round-trip safe. That is, &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq
$data&lt;/code&gt; stands for all characters that are marked as &lt;code&gt;|0&lt;/code&gt;. Here is how to make sure:</source>
          <target state="translated">マップを作成するときは、マッピングを安全に往復させる必要があります。つまり、 &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq $data&lt;/code&gt; は、 &lt;code&gt;|0&lt;/code&gt; としてマークされているすべての文字を表します。確認方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="bb9cd7b8a4ff60818aa2eb01184f94103173f0c2" translate="yes" xml:space="preserve">
          <source>When you declare a constant such as &lt;code&gt;PI&lt;/code&gt; using the method shown above, each machine your script runs upon can have as many digits of accuracy as it can use. Also, your program will be easier to read, more likely to be maintained (and maintained correctly), and far less likely to send a space probe to the wrong planet because nobody noticed the one equation in which you wrote &lt;code&gt;3.14195&lt;/code&gt; .</source>
          <target state="translated">上記の方法を使用して &lt;code&gt;PI&lt;/code&gt; などの定数を宣言すると、スクリプトを実行する各マシンは、使用できる限りの桁数の精度を持つことができます。また、 &lt;code&gt;3.14195&lt;/code&gt; と記述した方程式に誰も気づかなかったため、プログラムは読みやすく、維持される可能性が高く（正しく維持され）、間違った惑星に宇宙探査機を送信する可能性がはるかに低くなります。</target>
        </trans-unit>
        <trans-unit id="34ad5430f738cd6a6ba4f6afa7a8297067c10fdd" translate="yes" xml:space="preserve">
          <source>When you decode(=?</source>
          <target state="translated">デコード(=?</target>
        </trans-unit>
        <trans-unit id="1f9cd5bf8b9a9dc5c6c543459671e6a174da6ded" translate="yes" xml:space="preserve">
          <source>When you decode, &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; is inserted for a malformed character, where</source>
          <target state="translated">デコードすると、不正な文字に &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; が挿入されます。</target>
        </trans-unit>
        <trans-unit id="8f3fe5c47178db8be10e4d3c50152806e0a7dfbf" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; object, you might get an object of this class.</source>
          <target state="translated">&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;オブジェクトで$ parser-&amp;gt; get_tokenを実行すると、このクラスのオブジェクトが取得される場合があります。</target>
        </trans-unit>
        <trans-unit id="fdee2ab8e3f283c88595afe8fae4920b1af2e43f" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you might get an object of this class.</source>
          <target state="translated">&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;で$ parser-&amp;gt; get_tokenを実行すると、このクラスのオブジェクトが取得される場合があります。</target>
        </trans-unit>
        <trans-unit id="e49f09f58c9d01d7e0d1ab18e02275ef3d85f650" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you should get an object of a subclass of Pod::Simple::PullParserToken.</source>
          <target state="translated">&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;で$ parser-&amp;gt; get_tokenを実行すると、Pod :: Simple :: PullParserTokenのサブクラスのオブジェクトを取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="e5d10bb84f2ae2965aec52096372e0823e1ccc9f" translate="yes" xml:space="preserve">
          <source>When you do an open() and specify extra PerlIO layers to be deployed, the layers you specify are &quot;pushed&quot; on top of the already existing default stack. One way to see it is that &quot;operating system is on the left&quot; and &quot;Perl is on the right&quot;.</source>
          <target state="translated">open()を行い、デプロイする PerlIO の追加レイヤを指定すると、指定したレイヤは既に存在するデフォルトのスタックの上に「プッシュ」されます。これを見る方法の一つは、「オペレーティングシステムは左に、Perl は右に」ということです。</target>
        </trans-unit>
        <trans-unit id="deae100a89ba77dc88cb549c116cc2863e7500d7" translate="yes" xml:space="preserve">
          <source>When you do so, make sure you leave at least &lt;b&gt;U0000&lt;/b&gt; to &lt;b&gt;U0020&lt;/b&gt; as is, unless your environment is EBCDIC.</source>
          <target state="translated">その場合、環境がEBCDICでない限り、少なくとも&lt;b&gt;U0000&lt;/b&gt;から&lt;b&gt;U0020を&lt;/b&gt;そのままにしてください。</target>
        </trans-unit>
        <trans-unit id="5f9d98bf0fca35661c7810840d0018afb1d2ce55" translate="yes" xml:space="preserve">
          <source>When you do this, you replace ordinary Perl ops with custom ops by creating ops with the type &lt;code&gt;OP_CUSTOM&lt;/code&gt; and the &lt;code&gt;op_ppaddr&lt;/code&gt; of your own PP function. This should be defined in XS code, and should look like the PP ops in &lt;code&gt;pp_*.c&lt;/code&gt;. You are responsible for ensuring that your op takes the appropriate number of values from the stack, and you are responsible for adding stack marks if necessary.</source>
          <target state="translated">これを行うと、タイプ &lt;code&gt;OP_CUSTOM&lt;/code&gt; と独自のPP関数の &lt;code&gt;op_ppaddr&lt;/code&gt; を使用してopsを作成することにより、通常のPerl opsをカスタムopsに置き換えます。これはXSコードで定義する必要があり、 &lt;code&gt;pp_*.c&lt;/code&gt; PP opsのようになります。自分の操作がスタックから適切な数の値を取得するようにする責任があり、必要に応じてスタックマークを追加する責任があります。</target>
        </trans-unit>
        <trans-unit id="f0737e549db78c3f56b6cebadc591bd894132914" translate="yes" xml:space="preserve">
          <source>When you encode, it just encodes UTF-8 string with</source>
          <target state="translated">エンコードするときは、UTF-8の文字列を</target>
        </trans-unit>
        <trans-unit id="2cb93abd34cd25594e79f391f2b423cc436f1f2e" translate="yes" xml:space="preserve">
          <source>When you execute this script, Perl creates a source stream for the file. Before the parser processes any of the lines from the file, the source stream looks like this:</source>
          <target state="translated">このスクリプトを実行すると、Perl はファイルのソース・ストリームを作成します。パーサがファイルの行を処理する前に、ソース・ストリームは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="542d61dee2b7e163e5110ea366ba8573d821b115" translate="yes" xml:space="preserve">
          <source>When you get tired of writing a custom print for your data structures, you might look at the standard &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; or &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; modules. The former is what the Perl debugger uses, while the latter generates parsable Perl code. For example:</source>
          <target state="translated">データ構造のカスタムプリントの作成に飽きたら、標準の&lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt;または&lt;a href=&quot;data/dumper&quot;&gt;Data :: &lt;/a&gt;Dumperモジュールを確認することもできます。前者はPerlデバッガーが使用するもので、後者は解析可能なPerlコードを生成します。例えば：</target>
        </trans-unit>
        <trans-unit id="18b18f51c5b3a1ef29698b4db45e17c63b163a2a" translate="yes" xml:space="preserve">
          <source>When you have Module::Build installed and a module comes with both a Makefile.PL and a Build.PL, which shall have precedence?</source>
          <target state="translated">Module::Buildがインストールされていて、Makefile.PLとBuild.PLの両方がモジュールに付属している場合、どちらが優先されますか?</target>
        </trans-unit>
        <trans-unit id="90be52d2f2a07a95a09a611578f9d43f7cd9edea" translate="yes" xml:space="preserve">
          <source>When you have Term::ANSIColor installed, you can turn on colorized output to have some visual differences between normal CPAN.pm output, warnings, debugging output, and the output of the modules being installed. Set your favorite colors after some experimenting with the Term::ANSIColor module.</source>
          <target state="translated">Term::ANSIColorがインストールされている場合、通常のCPAN.pmの出力、警告、デバッグ出力、インストールされているモジュールの出力と視覚的な違いを持たせるために、色付きの出力を有効にすることができます。Term::ANSIColorモジュールを使って試してみて、好みの色を設定してみてください。</target>
        </trans-unit>
        <trans-unit id="805d35dab8fe4274cb0dab9ee72a05d301e431cf" translate="yes" xml:space="preserve">
          <source>When you have a &lt;code&gt;$normalized&lt;/code&gt; string and an &lt;code&gt;$unnormalized&lt;/code&gt; string following it, a simple concatenation is wrong:</source>
          <target state="translated">あなたが持っている場合は &lt;code&gt;$normalized&lt;/code&gt; た文字列と &lt;code&gt;$unnormalized&lt;/code&gt; 、それを次の文字列を、簡単な連結は間違っています：</target>
        </trans-unit>
        <trans-unit id="5fc33624ab4cb034a50a1d77e4381e870301d931" translate="yes" xml:space="preserve">
          <source>When you have a duplicate entry, mark either one with '|1' or '|3'.</source>
          <target state="translated">重複している場合は、'|1'または'|3'でマークしてください。</target>
        </trans-unit>
        <trans-unit id="c0776eaeac3f4218a7b8598aad81420ef0246911" translate="yes" xml:space="preserve">
          <source>When you list the arguments to the XSUB in the .xs file, that tells &lt;b&gt;xsubpp&lt;/b&gt; which argument corresponds to which of the argument stack (i.e., the first one listed is the first argument, and so on). You invite disaster if you do not list them in the same order as the function expects them.</source>
          <target state="translated">.xsファイルにXSUBへの引数をリストすると、それはどの引数がどの引数スタックに対応するかを&lt;b&gt;xsubpp&lt;/b&gt;に伝えます（つまり、リストされている最初の引数は最初の引数などです）。関数が期待するのと同じ順序でそれらをリストしないと、災害を招きます。</target>
        </trans-unit>
        <trans-unit id="4fe7c5d2090255d1c2f0cf1a507f4b889f93bbfd" translate="yes" xml:space="preserve">
          <source>When you make a script executable, in order to make it usable as a command, the system will pass switches to perl from the script's #! line. Perl checks that any command line switches given to a setuid (or setgid) script actually match the ones set on the #! line. Some Unix and Unix-like environments impose a one-switch limit on the #! line, so you may need to use something like &lt;code&gt;-wU&lt;/code&gt; instead of &lt;code&gt;-w -U&lt;/code&gt; under such systems. (This issue should arise only in Unix or Unix-like environments that support #! and setuid or setgid scripts.)</source>
          <target state="translated">スクリプトを実行可能にすると、コマンドとして使用できるようにするために、システムはスクリプトの＃からスイッチをperlに渡します。ライン。 Perlは、setuid（またはsetgid）スクリプトに指定されたすべてのコマンドラインスイッチが実際に＃に設定されているものと一致することを確認します。ライン。一部のUnixおよびUnixのような環境では、＃に1スイッチの制限が課されます。そのようなシステムでは、 &lt;code&gt;-w -U&lt;/code&gt; の代わりに &lt;code&gt;-wU&lt;/code&gt; のようなものを使用する必要があるかもしれません。 （この問題は、＃！およびsetuidまたはsetgidスクリプトをサポートするUnixまたはUnixのような環境でのみ発生します。）</target>
        </trans-unit>
        <trans-unit id="b95cff40ad5c3e10b014358530a3857e4311a17f" translate="yes" xml:space="preserve">
          <source>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; function with an argument of &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (see &lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;).</source>
          <target state="translated">組み込みをオーバーライドする場合、置き換えは組み込みのネイティブ構文と（可能な場合）一貫している必要があります。これは、適切なプロトタイプを使用して実現できます。オーバーライド可能な組み込みのプロトタイプを取得するには、引数 &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; 指定して &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; 関数を使用します（&lt;a href=&quot;functions/prototype&quot;&gt;プロトタイプを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="cde2c695557d23e73e52834a17ed471dd59562aa" translate="yes" xml:space="preserve">
          <source>When you replace this variable, it is considered a good practice to store the possibly previously installed hook and that you recall it inside your own.</source>
          <target state="translated">この変数を置き換えるとき、それは可能性のある以前にインストールされたフックを格納し、あなた自身の中でそれをリコールすることは良い習慣と考えられています。</target>
        </trans-unit>
        <trans-unit id="582bd31e20cc087ebfe2ecd8d499eadfcfa005d7" translate="yes" xml:space="preserve">
          <source>When you run Makefile.PL, it makes a Makefile. That's the whole point of MakeMaker. The Makefile.PL is a simple program which loads ExtUtils::MakeMaker and runs the WriteMakefile() function to generate a Makefile.</source>
          <target state="translated">Makefile.PLを実行するとMakefileを作成します。これがMakeMakerの真骨頂です。Makefile.PLは、ExtUtils::MakeMakerをロードしてWriteMakefile()関数を実行してMakefileを生成するシンプルなプログラムです。</target>
        </trans-unit>
        <trans-unit id="b579e440e9d1d7b9d0889bfe36abfaf0be29b72d" translate="yes" xml:space="preserve">
          <source>When you run a Perl script, something else is running the script for you, and that something else may output error messages. The script might emit its own warnings and error messages. Most of the time you cannot tell who said what.</source>
          <target state="translated">Perl スクリプトを実行すると、他の何かがあなたのためにスクリプトを実行しており、その何かがエラーメッセージを出力することがあります。スクリプトは独自の警告やエラーメッセージを出力するかもしれません。ほとんどの場合、誰が何を言ったのかわからないことが多いです。</target>
        </trans-unit>
        <trans-unit id="b459c97000689bfb2a9636d9e9707ca71827210e" translate="yes" xml:space="preserve">
          <source>When you run this program, you should get something back that looks like this:</source>
          <target state="translated">このプログラムを実行すると、以下のようなものが返ってくるはずです。</target>
        </trans-unit>
        <trans-unit id="a4188abf09b28b37cfb9f20a3ac1868d9c6a543c" translate="yes" xml:space="preserve">
          <source>When you say &quot;make test&quot;, Perl uses the</source>
          <target state="translated">make test」と言うと、Perlは</target>
        </trans-unit>
        <trans-unit id="7919c60f354343e7a5369000b965c8d2d0632381" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=gb2312&lt;/code&gt; on mails and web pages, they really mean &lt;code&gt;euc-cn&lt;/code&gt; encodings. To fix that, &lt;code&gt;gb2312&lt;/code&gt; is aliased to &lt;code&gt;euc-cn&lt;/code&gt; . Use &lt;code&gt;gb2312-raw&lt;/code&gt; when you really mean it.</source>
          <target state="translated">メールやWebページに &lt;code&gt;charset=gb2312&lt;/code&gt; が表示される場合、それらは本当に &lt;code&gt;euc-cn&lt;/code&gt; エンコーディングを意味しています。これを修正するために、 &lt;code&gt;gb2312&lt;/code&gt; は &lt;code&gt;euc-cn&lt;/code&gt; にエイリアスされます。本当の意味で &lt;code&gt;gb2312-raw&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="17139aebb0fce79faa8dece070270ecb6b39cc8b" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; on mails and web pages, they really mean &quot;cp949&quot; encodings. To fix that, the following aliases are set;</source>
          <target state="translated">メールおよびWebページに &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; が表示される場合、それらは実際には「cp949」エンコーディングを意味します。これを修正するために、次のエイリアスが設定されています。</target>
        </trans-unit>
        <trans-unit id="bed16d4ef44043e0ee787c3f181832f24be03ea6" translate="yes" xml:space="preserve">
          <source>When you speak one language and the computer thinks you&amp;rsquo;re speaking another. You&amp;rsquo;ll see odd translations when you send UTF‑8, for instance, but the computer thinks you sent Latin-1, showing all sorts of weird characters instead. The term is written 「文字化け」in Japanese and means &amp;ldquo;character rot&amp;rdquo;, an apt description. Pronounced [&lt;code&gt;modʑibake&lt;/code&gt; ] in standard &lt;b&gt;IPA&lt;/b&gt; phonetics, or approximately &amp;ldquo;moh-jee-bah-keh&amp;rdquo;.</source>
          <target state="translated">ある言語を話し、コンピュータが別の言語を話していると考えているとき。たとえば、UTF send8を送信すると奇妙な翻訳が表示されますが、コンピューターはLatin-1を送信したと見なし、代わりにあらゆる種類の奇妙な文字を表示します。言葉は「文字化け」と日本語で書かれており、適切な説明である「文字腐敗」を意味します。標準の&lt;b&gt;IPA&lt;/b&gt;音声では[ &lt;code&gt;modʑibake&lt;/code&gt; ]と発音されます。または、ほぼ「moh-jee-bah-keh」です。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="665a5769943788c4623d27cfed3bae7f7e133317" translate="yes" xml:space="preserve">
          <source>When you specify arguments to routines in the .xs file, you are really passing three pieces of information for each argument listed. The first piece is the order of that argument relative to the others (first, second, etc). The second is the type of argument, and consists of the type declaration of the argument (e.g., int, char*, etc). The third piece is the calling convention for the argument in the call to the library function.</source>
          <target state="translated">.xs ファイルでルーチンの引数を指定するとき、リストされている各引数に対して、実際には 3 つの情報を渡すことになります。最初の情報は、他の引数との相対的な引数の順番です(最初、2番目など)。2つ目は引数の型で、引数の型宣言(例えば、int、char*など)で構成されています。3番目の部分は、ライブラリ関数を呼び出す際の引数の呼び出し規則です。</target>
        </trans-unit>
        <trans-unit id="92bc744ea7824ccea4eeb23e82728fbc4ddab899" translate="yes" xml:space="preserve">
          <source>When you supply a separate display name it becomes possible to run a test more than once; the display name is effectively the alias by which the test is known inside the harness. The harness doesn't care if it runs the same test more than once when each invocation uses a different name.</source>
          <target state="translated">別々の表示名を指定すると、テストを複数回実行することが可能になります。表示名は事実上、ハーネス内部でテストを知るためのエイリアスです。ハーネスは、各呼び出しが異なる名前を使用している場合、同じテストを複数回実行しても気にしません。</target>
        </trans-unit>
        <trans-unit id="f5d8e81bcb99e99cbe008b301dbaa4156e030e10" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; to lock the file, &lt;code&gt;Tie::File&lt;/code&gt; assumes that the read cache is no longer trustworthy, because another process might have modified the file since the last time it was read. Therefore, a successful call to &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; discards the contents of the read cache and the internal record offset table.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; を使用してファイルをロックすると、 &lt;code&gt;Tie::File&lt;/code&gt; は、最後にファイルが読み取られてから別のプロセスがファイルを変更した可能性があるため、読み取りキャッシュが信頼できないものと見なします。したがって、 &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; の呼び出しが成功すると、読み取りキャッシュの内容と内部レコードオフセットテーブルが破棄されます。</target>
        </trans-unit>
        <trans-unit id="de1ea55b20ff67d97a482097e7d303cd94b1b34c" translate="yes" xml:space="preserve">
          <source>When you use Perl from C, your C program will--usually--allocate, &quot;run&quot;, and deallocate a</source>
          <target state="translated">CからPerlを使用する場合、Cプログラムは通常</target>
        </trans-unit>
        <trans-unit id="5b4b7e46fe751c099868927c5d1568ad4f11af65" translate="yes" xml:space="preserve">
          <source>When you use the &lt;b&gt;-n&lt;/b&gt; and &lt;b&gt;-p&lt;/b&gt; switches to Perl, &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; work just as they do in &lt;b&gt;awk&lt;/b&gt;, as a degenerate case. Both &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; blocks are run when you use the &lt;b&gt;-c&lt;/b&gt; switch for a compile-only syntax check, although your main code is not.</source>
          <target state="translated">Perlに&lt;b&gt;-n&lt;/b&gt;および&lt;b&gt;-p&lt;/b&gt;スイッチを使用すると、 &lt;code&gt;BEGIN&lt;/code&gt; と &lt;code&gt;END&lt;/code&gt; は、&lt;b&gt;awk&lt;/b&gt;と同じように機能します。&lt;b&gt;-c&lt;/b&gt;スイッチを使用してコンパイルのみの構文チェックを行うと、 &lt;code&gt;BEGIN&lt;/code&gt; ブロックと &lt;code&gt;CHECK&lt;/code&gt; ブロックの両方が実行されますが、メインコードは実行されません。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6e7c5168dc3e4d09a86a5c07db61ae55b067c306" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or Perl's &lt;b&gt;-w&lt;/b&gt; command-line option, you may see warnings about useless uses of constants or functions in &quot;void context&quot;. Void context just means the value has been discarded, such as a statement containing only &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid(0);&lt;/a&gt;&lt;/code&gt;. It still counts as scalar context for functions that care whether or not they're being called in list context.</source>
          <target state="translated">あなたが使用する場合 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; プラグマやPerlの&lt;b&gt;-w&lt;/b&gt;コマンドラインオプションを、あなたは「無効コンテキスト」での定数や関数の無用な使用に関する警告が表示されます。Voidコンテキストは、 &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; のみを含むステートメントなど、値が破棄されたことを意味します。または &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid(0);&lt;/a&gt;&lt;/code&gt; 。それでも、リストコンテキストで呼び出されているかどうかに関係のない関数のスカラーコンテキストとしてカウントされます。</target>
        </trans-unit>
        <trans-unit id="f561cbf428cfa38a570f079c8fe3f1e6c4934924" translate="yes" xml:space="preserve">
          <source>When you want to encode Unicode for mails and web pages, however, do not use UTF-7 unless you are sure your recipients and readers can handle it. Very few MUAs and WWW Browsers support these days (only Mozilla seems to support one). For general cases, use UTF-8 for message body and MIME-Header for header instead.</source>
          <target state="translated">ただし、メールやウェブページをUnicodeでエンコードしたい場合は、受信者や読者がそれを扱えると確信していない限り、UTF-7は使わないようにしてください。最近ではMUAやWWWブラウザがサポートしているものはほとんどありません(Mozillaだけがサポートしているようです)。一般的なケースでは、メッセージの本文には UTF-8、ヘッダには MIME-Header を使用してください。</target>
        </trans-unit>
        <trans-unit id="d1594b9a6f30c884e42aa7810e12c05455ffa364" translate="yes" xml:space="preserve">
          <source>When you want to write to a file, you first have to decide what to do about any existing contents of that file. You have two basic choices here: to preserve or to clobber.</source>
          <target state="translated">ファイルに書き込みたいときは、まず、そのファイルの既存の内容をどうするかを決めなければなりません。ここでは基本的に2つの選択肢があります。</target>
        </trans-unit>
        <trans-unit id="f729e16e6d70d308845c4e263f4f5d66444de2cc" translate="yes" xml:space="preserve">
          <source>When you're done with your filehandles, you should &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; them (though to be honest, Perl will clean up after you if you forget):</source>
          <target state="translated">ファイルハンドルを使い終わったら、それらを &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; する必要があります（正直なところ、Perlはあなたの後で忘れた場合にクリーンアップします）。</target>
        </trans-unit>
        <trans-unit id="f855bc56e9b2d1a2f4296535cb927b2c13c9dd7d" translate="yes" xml:space="preserve">
          <source>When you're using RETVAL to return an &lt;code&gt;SV *&lt;/code&gt; , there's some magic going on behind the scenes that should be mentioned. When you're manipulating the argument stack using the ST(x) macro, for example, you usually have to pay special attention to reference counts. (For more about reference counts, see &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.) To make your life easier, the typemap file automatically makes &lt;code&gt;RETVAL&lt;/code&gt; mortal when you're returning an &lt;code&gt;SV *&lt;/code&gt; . Thus, the following two XSUBs are more or less equivalent:</source>
          <target state="translated">RETVALを使用して &lt;code&gt;SV *&lt;/code&gt; を返す場合、言及する必要がある舞台裏でいくつかの魔法が起こっています。たとえば、ST（x）マクロを使用して引数スタックを操作する場合、通常は参照カウントに特別な注意を払う必要があります。（参照カウントの詳細については、&lt;a href=&quot;perlguts&quot;&gt;perlgutsを&lt;/a&gt;参照してください。）人生を楽にするために、 &lt;code&gt;SV *&lt;/code&gt; を返すときに、タイプマップファイルは自動的に &lt;code&gt;RETVAL&lt;/code&gt; を致命的にします。したがって、次の2つのXSUBはほぼ同等です。</target>
        </trans-unit>
        <trans-unit id="5829efde6fb988f406fa62c8ae4c250e14e41e30" translate="yes" xml:space="preserve">
          <source>When you've found that there isn't a module available for what you're trying to do, and you've had to write the code yourself, consider packaging up the solution into a module and uploading it to CPAN so that others can benefit.</source>
          <target state="translated">自分がやろうとしていることに利用できるモジュールがなく、自分でコードを書かなければならなかった場合は、ソリューションをモジュールにパッケージ化してCPANにアップロードすることを検討してみましょう。</target>
        </trans-unit>
        <trans-unit id="6b113771452e06c12bd2750d8700f91d2cc72def" translate="yes" xml:space="preserve">
          <source>When you've got your name sorted out and you're sure that your module is wanted and not currently available, it's time to start coding.</source>
          <target state="translated">名前を整理して、モジュールが必要とされていて現在利用できないことを確認したら、コーディングを開始しましょう。</target>
        </trans-unit>
        <trans-unit id="baa149e5f728be9fcf5c842fafa04ad779a77d18" translate="yes" xml:space="preserve">
          <source>When your child is done running tests, you must call &lt;code&gt;finalize&lt;/code&gt; to clean up and tell the parent your pass/fail status.</source>
          <target state="translated">子供がテストの実行を終えたら、 &lt;code&gt;finalize&lt;/code&gt; を呼び出してクリーンアップし、親に合格/不合格のステータスを通知する必要があります。</target>
        </trans-unit>
        <trans-unit id="701f121f0767fb048f9a1e9cdd7bcb29143a3d18" translate="yes" xml:space="preserve">
          <source>When your module encounters an error it should do one or more of:</source>
          <target state="translated">モジュールがエラーに遭遇した場合、次のうちの1つ以上を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="7d300f1dcd786450162ec26ef8c71857af330be4" translate="yes" xml:space="preserve">
          <source>When, &lt;code&gt;$Archive::Tar::CHMOD&lt;/code&gt; is enabled, this setting controls whether the permissions on files from the archive are used without modification of if they are filtered by removing any setid bits and applying the current umask.</source>
          <target state="translated">場合は、 &lt;code&gt;$Archive::Tar::CHMOD&lt;/code&gt; 有効になっている、アーカイブからファイルのパーミッションかどうか、この設定を制御し、それらがどのSETIDビットを削除し、現在のumaskを適用することにより、フィルタリングされた場合の修正なしで使用されています。</target>
        </trans-unit>
        <trans-unit id="cabccb147592c137e487eb001cea479dffb70830" translate="yes" xml:space="preserve">
          <source>Whenever a Berkeley DB function returns data via one of its parameters, the equivalent &lt;b&gt;DB_File&lt;/b&gt; method does exactly the same.</source>
          <target state="translated">Berkeley DB関数がパラメーターの1つを介してデータを返すときは常に、同等の&lt;b&gt;DB_File&lt;/b&gt;メソッドがまったく同じことを行います。</target>
        </trans-unit>
        <trans-unit id="6a800aba7242513688fb7365bc61881077cd8882" translate="yes" xml:space="preserve">
          <source>Whenever a Perl subroutine is called using one of the</source>
          <target state="translated">Perl のサブルーチンが呼び出されるたびに</target>
        </trans-unit>
        <trans-unit id="6344d70f52ab5669e0f868bcc4766007019f0e1c" translate="yes" xml:space="preserve">
          <source>Whenever a reference is used as a field hash key, the object registry is checked and a new entry is made if necessary. The field hash is then added to the list of fields this reference has used.</source>
          <target state="translated">参照がフィールドハッシュキーとして使用されるたびに、オブジェクトレジストリがチェックされ、必要に応じて新しいエントリが作成されます。フィールドハッシュは、この参照が使用したフィールドのリストに追加されます。</target>
        </trans-unit>
        <trans-unit id="ac59cb12b90f854e158e9f7e8d962f434ede4764" translate="yes" xml:space="preserve">
          <source>Whenever control returns from the</source>
          <target state="translated">から制御が戻るたびに</target>
        </trans-unit>
        <trans-unit id="58a47aafac8fca0c788807bc11f865583b9a79dd" translate="yes" xml:space="preserve">
          <source>Whenever possible, new features should be prototyped in a CPAN module before they will be considered for the core.</source>
          <target state="translated">可能な限り、新機能はCPANモジュールでプロトタイプを作成してからコアのために検討してください。</target>
        </trans-unit>
        <trans-unit id="a368a6c064c79ec6ec1d84f92fa7a58354e83dad" translate="yes" xml:space="preserve">
          <source>Whenever this is applied to a string which doesn't quite meet the pattern's expectations such as &lt;code&gt;&quot;abc  &quot;&lt;/code&gt; or &lt;code&gt;&quot;abc  def &quot;&lt;/code&gt; , the regex engine will backtrack, approximately once for each character in the string. But we know that there is no way around taking</source>
          <target state="translated">これが &lt;code&gt;&quot;abc &quot;&lt;/code&gt; や &lt;code&gt;&quot;abc def &quot;&lt;/code&gt; などのパターンの期待に完全に一致しない文字列に適用されるときはいつでも、正規表現エンジンは文字列の各文字に対して約1回バックトラックします。しかし、私たちは取る方法がないことを知っています</target>
        </trans-unit>
        <trans-unit id="1d972aca2274b3be6437814e7f18c3f8fdf56c12" translate="yes" xml:space="preserve">
          <source>Whenever you do I/O on a file in Perl, you do so through what in Perl is called a &lt;b&gt;filehandle&lt;/b&gt;. A filehandle is an internal name for an external file. It is the job of the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; function to make the association between the internal name and the external name, and it is the job of the &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; function to break that association.</source>
          <target state="translated">Perlでファイルに対してI / Oを行うときはいつでも、Perlでは&lt;b&gt;ファイルハンドル&lt;/b&gt;と呼ばれる方法で行い&lt;b&gt;ます&lt;/b&gt;。ファイルハンドルは、外部ファイルの内部名です。内部名と外部名の関連付けを行うのは &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 関数の仕事であり、その関連付けを解除するのは &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 関数の仕事です。</target>
        </trans-unit>
        <trans-unit id="ed7093ca3cc4a3c897e96991516ce1f4f0fcfd4e" translate="yes" xml:space="preserve">
          <source>Whenever you have more than one subprocess, you must be careful that each closes whichever half of any pipes created for interprocess communication it is not using. This is because any child process reading from the pipe and expecting an EOF will never receive it, and therefore never exit. A single process closing a pipe is not enough to close it; the last process with the pipe open must close it for it to read EOF.</source>
          <target state="translated">複数のサブプロセスがある場合は、プロセス間通信のために作成されたパイプのうち、使用していないパイプの半分をそれぞれが閉じるように注意しなければなりません。これは、パイプから読み込んでEOFを期待している子プロセスがパイプを受け取ることはなく、決して終了しないからです。1つのプロセスがパイプを閉じるだけではパイプを閉じることはできません。</target>
        </trans-unit>
        <trans-unit id="cd1ee0eb738b950d883ab6c08ca29be20ef06df7" translate="yes" xml:space="preserve">
          <source>Whenever you're communicating text with anything that is external to your perl process, like a database, a text file, a socket, or another program. Even if the thing you're communicating with is also written in Perl.</source>
          <target state="translated">データベース、テキストファイル、ソケット、他のプログラムなど、Perlプロセスの外部にあるものとテキストを通信しているときはいつもそうです。通信相手がPerlで書かれたものであってもです。</target>
        </trans-unit>
        <trans-unit id="cc31f890f5831db8c47f9104a5fd72a40a9b958c" translate="yes" xml:space="preserve">
          <source>Whenever your encoded, binary string is used together with a text string, Perl will assume that your binary string was encoded with ISO-8859-1, also known as latin-1. If it wasn't latin-1, then your data is unpleasantly converted. For example, if it was UTF-8, the individual bytes of multibyte characters are seen as separate characters, and then again converted to UTF-8. Such double encoding can be compared to double HTML encoding (&lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ), or double URI encoding (&lt;code&gt;%253E&lt;/code&gt; ).</source>
          <target state="translated">エンコードされたバイナリ文字列がテキスト文字列と一緒に使用される場合は常に、Perlはバイナリ文字列がISO-8859-1（別名latin-1）でエンコードされていると想定します。latin-1でない場合、データは不快に変換されます。たとえば、UTF-8の場合、マルチバイト文字の個々のバイトは個別の文字として認識され、再度UTF-8に変換されます。このような二重エンコーディングは、二重HTMLエンコーディング（ &lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ）または二重URIエンコーディング（ &lt;code&gt;%253E&lt;/code&gt; ）と比較できます。</target>
        </trans-unit>
        <trans-unit id="e1d629f115a3e97bf6ae620fc76d3801dd8ef401" translate="yes" xml:space="preserve">
          <source>Whenever your program accesses data or resources that can be accessed by other threads, you must take steps to coordinate access or risk data inconsistency and race conditions. Note that Perl will protect its internals from your race conditions, but it won't protect you from you.</source>
          <target state="translated">あなたのプログラムが他のスレッドからアクセス可能なデータやリソースにアクセスするときはいつでも、アクセスを調整するための措置を取らなければなりません。Perlは、あなたのレース条件から内部を保護しますが、あなたをあなたから守ることはできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="525f61b6729229b1a8854a9e50bcaa52ea96b131" translate="yes" xml:space="preserve">
          <source>Where</source>
          <target state="translated">Where</target>
        </trans-unit>
        <trans-unit id="fb9b184246f9c47c2085ba5fb400e91c6332924c" translate="yes" xml:space="preserve">
          <source>Where 1 is the position of the first char in the string. Note that position can be 0, or larger than the actual length of the pattern, likewise length can be zero.</source>
          <target state="translated">ここで 1 は文字列の最初の文字の位置です。位置は0か、パターンの実際の長さよりも大きくすることができ、同様に長さも0にすることができます。</target>
        </trans-unit>
        <trans-unit id="73e22419719a01d34b548da9ec30ecb83ae08c13" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's.</source>
          <target state="translated">ここで &lt;code&gt;$id1&lt;/code&gt; 、 &lt;code&gt;$id2&lt;/code&gt; 2つのバイトのサブフィールドIDのです。</target>
        </trans-unit>
        <trans-unit id="b9cb4e493b9dc9b7340611ceb99bc1cecceb2405" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's. The second byte of the ID cannot be 0, unless the &lt;code&gt;Strict&lt;/code&gt; option has been disabled.</source>
          <target state="translated">ここで &lt;code&gt;$id1&lt;/code&gt; 、 &lt;code&gt;$id2&lt;/code&gt; 2つのバイトのサブフィールドIDのです。 &lt;code&gt;Strict&lt;/code&gt; オプションが無効になっていない限り、IDの2番目のバイトを0にすることはできません。</target>
        </trans-unit>
        <trans-unit id="de8d3be1468ab688b0e6e35d8cea1268cae0caa0" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$r1&lt;/code&gt; can be a reference to any kind of data structure you'd like. It will be deeply copied. Because &lt;code&gt;dclone&lt;/code&gt; takes and returns references, you'd have to add extra punctuation if you had a hash of arrays that you wanted to copy.</source>
          <target state="translated">ここで、 &lt;code&gt;$r1&lt;/code&gt; は、任意の種類のデータ構造への参照にすることができます。深くコピーされます。 &lt;code&gt;dclone&lt;/code&gt; は参照を取得して返すため、コピーする配列のハッシュがある場合は、句読点を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="29126cbcaebf3032a0f200bdad16fd67b9d2ca9f" translate="yes" xml:space="preserve">
          <source>Where a &lt;b&gt;compiler&lt;/b&gt; remembers symbols. A program like Perl must somehow remember all the names of all the &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;filehandles&lt;/b&gt;, and &lt;b&gt;subroutines&lt;/b&gt; you&amp;rsquo;ve used. It does this by placing the names in a symbol table, which is implemented in Perl using a &lt;b&gt;hash table&lt;/b&gt;. There is a separate symbol table for each &lt;b&gt;package&lt;/b&gt; to give each package its own &lt;b&gt;namespace&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;コンパイラ&lt;/b&gt;がシンボルを記憶する場所。Perlのようなプログラムは、使用したすべての&lt;b&gt;変数&lt;/b&gt;、&lt;b&gt;ファイルハンドル&lt;/b&gt;、および&lt;b&gt;サブルーチンの&lt;/b&gt;すべての名前を何らかの方法で記憶する必要があります。これは、&lt;b&gt;ハッシュテーブル&lt;/b&gt;を使用してPerlで実装されているシンボルテーブルに名前を配置することで行われ&lt;b&gt;ます&lt;/b&gt;。各パッケージに独自の&lt;b&gt;名前空間&lt;/b&gt;を与えるために、&lt;b&gt;パッケージ&lt;/b&gt;ごとに個別のシンボルテーブルがあり&lt;b&gt;ます&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="841b8cfbd59c36bfe89c29e0da6a4675a6abce15" translate="yes" xml:space="preserve">
          <source>Where are modules installed?</source>
          <target state="translated">モジュールはどこに設置されていますか?</target>
        </trans-unit>
        <trans-unit id="77cc20dcc0c42287d0cc6c95ce660feb0b4c5aeb" translate="yes" xml:space="preserve">
          <source>Where can I buy a commercial version of Perl?</source>
          <target state="translated">Perlの商用版はどこで買えますか?</target>
        </trans-unit>
        <trans-unit id="08cf7f142b0ee15a977fe964d0ddcdb1002739ae" translate="yes" xml:space="preserve">
          <source>Where can I get Perl macros for vi?</source>
          <target state="translated">vi用のPerlマクロはどこで入手できますか?</target>
        </trans-unit>
        <trans-unit id="406cbb0495a55956cb84611a8d86c9d721557519" translate="yes" xml:space="preserve">
          <source>Where can I get information on Perl?</source>
          <target state="translated">Perlの情報はどこで手に入りますか?</target>
        </trans-unit>
        <trans-unit id="c63d9dfa4f6d6dcfc8103ea7650db10cd8e27fea" translate="yes" xml:space="preserve">
          <source>Where can I get perl-mode or cperl-mode for emacs?</source>
          <target state="translated">emacsのperl-modeやperl-modeはどこで入手できますか?</target>
        </trans-unit>
        <trans-unit id="f0f1c9d2159564047b740e7956f5640af04f1e3c" translate="yes" xml:space="preserve">
          <source>Where can I learn about CGI or Web programming in Perl?</source>
          <target state="translated">PerlのCGIやWebプログラミングはどこで学べますか?</target>
        </trans-unit>
        <trans-unit id="703366e9bd37f95d6d2b90762995773aff84d67e" translate="yes" xml:space="preserve">
          <source>Where can I learn about linking C with Perl?</source>
          <target state="translated">CとPerlの連携についてはどこで学べますか?</target>
        </trans-unit>
        <trans-unit id="ed8bfc60bd9d8b7923b8341ed07d83afc289bc35" translate="yes" xml:space="preserve">
          <source>Where can I learn about object-oriented Perl programming?</source>
          <target state="translated">オブジェクト指向のPerlプログラミングはどこで学べますか?</target>
        </trans-unit>
        <trans-unit id="210221a52d88064b34135e9105ebfd5d49152b00" translate="yes" xml:space="preserve">
          <source>Where can I post questions?</source>
          <target state="translated">質問はどこに投稿できますか?</target>
        </trans-unit>
        <trans-unit id="34466094d5547ae836abe0422810851106c8e987" translate="yes" xml:space="preserve">
          <source>Where do I get the include files to do ioctl() or syscall()?</source>
          <target state="translated">ioctl()や syscall()を実行するためのインクルードファイルはどこにありますか?</target>
        </trans-unit>
        <trans-unit id="ae774b74efc34a0e83321577caf18754079572a2" translate="yes" xml:space="preserve">
          <source>Where do I send bug reports?</source>
          <target state="translated">バグレポートはどこに送ればいいですか?</target>
        </trans-unit>
        <trans-unit id="93218aab454721cc4e38fe91ac1668248deeae63" translate="yes" xml:space="preserve">
          <source>Where is the implementation?</source>
          <target state="translated">どこに実装されているのか?</target>
        </trans-unit>
        <trans-unit id="8a78c0649556030e4985847b409471ca9ebd9274" translate="yes" xml:space="preserve">
          <source>Where people get into trouble is here:</source>
          <target state="translated">人が困るところは、ここにあります。</target>
        </trans-unit>
        <trans-unit id="f616a42d8ce8b58cf95a9bfc5e5383c6c84dc620" translate="yes" xml:space="preserve">
          <source>Where prereqs are concerned, if META_MERGE is used, prerequisites are merged with their counterpart &lt;code&gt;WriteMakefile()&lt;/code&gt; argument (PREREQ_PM is merged into {prereqs}{runtime}{requires}, BUILD_REQUIRES into &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; , CONFIGURE_REQUIRES into &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; , and TEST_REQUIRES into &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; . When prereqs are specified with META_ADD, the only prerequisites added to the file come from the metadata, not &lt;code&gt;WriteMakefile()&lt;/code&gt; arguments.</source>
          <target state="translated">前提条件が関係している場合、META_MERGEを使用すると、前提条件は対応する &lt;code&gt;WriteMakefile()&lt;/code&gt; 引数とマージされます（PREREQ_PMは{prereqs} {runtime} {requires}にマージされ、BUILD_REQUIRESは &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; にマージされ、CONFIGURE_REQUIRESは &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; 、およびTEST_REQUIRESを &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; に挿入します。前提条件がMETA_ADDで指定されている場合、ファイルに追加される唯一の前提条件は、 &lt;code&gt;WriteMakefile()&lt;/code&gt; 引数ではなく、メタデータから取得されます。</target>
        </trans-unit>
        <trans-unit id="2578ad2cf7eb4212c4c2f76a99c66a64a699a6f4" translate="yes" xml:space="preserve">
          <source>Where the $way is a value from zero ($theta0, $phi0) to one ($theta1, $phi1). Note that antipodal points (where their distance is</source>
          <target state="translated">ここで、$way は、0 ($theta0,$phi0)から 1 ($theta1,$phi1)までの値です。対蹠点(その距離が</target>
        </trans-unit>
        <trans-unit id="fd6d6e78410be236f0ee8b2e37126d4a25f62f65" translate="yes" xml:space="preserve">
          <source>Where the 'DSLIP' characters have the following meanings:</source>
          <target state="translated">ここで、「DSLIP」文字は以下の意味を持つ。</target>
        </trans-unit>
        <trans-unit id="3a57b05d69f49e2636c91eefc4c6774814129e12" translate="yes" xml:space="preserve">
          <source>Where there is only one operand (or only one operand with overloading) the checks in respect of the other operand above are skipped.</source>
          <target state="translated">オペランドが1つしかない場合(またはオーバーロードされたオペランドが1つしかない場合)、上記の他のオペランドに関するチェックはスキップされます。</target>
        </trans-unit>
        <trans-unit id="293c942f397777e729937e1824d906951d88e087" translate="yes" xml:space="preserve">
          <source>Where these steps occur in the actual execution of a perl program is determined by whether the pattern involves interpolating any string variables. If interpolation occurs, then compilation happens at run time. If it does not, then compilation is performed at compile time. (The &lt;code&gt;/o&lt;/code&gt; modifier changes this, as does &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; to a certain extent.) The engine doesn't really care that much.</source>
          <target state="translated">Perlプログラムの実際の実行でこれらのステップが発生する場所は、パターンに文字列変数の補間が含まれるかどうかによって決まります。補間が発生すると、コンパイルは実行時に行われます。そうでない場合、コンパイルはコンパイル時に実行されます。（ &lt;code&gt;/o&lt;/code&gt; 修飾子はこれを変更し、 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; ある程度変更します。）エンジンはそれほど気にしません。</target>
        </trans-unit>
        <trans-unit id="cca423190a1a1c785b9d576f8083e40dd5389585" translate="yes" xml:space="preserve">
          <source>Where to Find the Community</source>
          <target state="translated">コミュニティを探す場所</target>
        </trans-unit>
        <trans-unit id="536ef5aba264e8d2aec71ea10430b9efa22dfe0c" translate="yes" xml:space="preserve">
          <source>Where to find the perlfaq</source>
          <target state="translated">perlfaqを探す場所</target>
        </trans-unit>
        <trans-unit id="74e10717c102dd0c9df4c18b5606b9aaf6912d10" translate="yes" xml:space="preserve">
          <source>Where you look to find a pointer to information somewhere else. (See &lt;b&gt;indirection&lt;/b&gt;.) References come in two flavors: &lt;b&gt;symbolic references&lt;/b&gt; and &lt;b&gt;hard references&lt;/b&gt;.</source>
          <target state="translated">他のどこかで情報へのポインタを探すために探す場所。（&lt;b&gt;間接&lt;/b&gt;参照を参照してください。）参照には、&lt;b&gt;シンボリック参照&lt;/b&gt;と&lt;b&gt;ハード参照の&lt;/b&gt; 2種類があり&lt;b&gt;ます&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="500583f76e5e2a57eb1022812ab875f23db70975" translate="yes" xml:space="preserve">
          <source>Where's the catch? Padding is neither required before the first field &lt;code&gt;count&lt;/code&gt; , nor between this and the next field &lt;code&gt;glyph&lt;/code&gt; , so why can't we simply pack like this:</source>
          <target state="translated">キャッチはどこですか？最初のフィールド &lt;code&gt;count&lt;/code&gt; 前や、このフィールド &lt;code&gt;glyph&lt;/code&gt; と次のフィールドグリフの間にパディングは必要ないため、次のように単純にパックできないのはなぜですか。</target>
        </trans-unit>
        <trans-unit id="85ff01499d11ce21062a9b96027ab58ee226aad3" translate="yes" xml:space="preserve">
          <source>Where,</source>
          <target state="translated">Where,</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="4d453f1163fdbba0e62b8cfe55db1c43bd938110" translate="yes" xml:space="preserve">
          <source>Whereas a QP decoder that works on both ASCII and EBCDIC platforms would look somewhat like the following:</source>
          <target state="translated">一方、ASCII と EBCDIC の両方のプラットフォームで動作する QP デコーダは、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="4c1007108b497a2f8b15b3dc9255f03fbd82a20c" translate="yes" xml:space="preserve">
          <source>Whereas here's how a Perl programmer more comfortable with the idiom might do it:</source>
          <target state="translated">一方、ここでは、このイディオムに慣れたPerlプログラマがどのようにそれを行うかを説明します。</target>
        </trans-unit>
        <trans-unit id="5db7dff8fd1589f3c435af6d45d16e0816b2e9c4" translate="yes" xml:space="preserve">
          <source>Whereas if you comment out the two lines I said you might wish to, then it shows it to you this way instead:</source>
          <target state="translated">私が言った2行をコメントアウトすると、その代わりにこのように表示されます。</target>
        </trans-unit>
        <trans-unit id="aa7a6da1ef7f2699440e362142ae5565af060786" translate="yes" xml:space="preserve">
          <source>Wherever a list of operators can be given you can use one or more opsets. See also Manipulating Opsets below.</source>
          <target state="translated">演算子のリストが与えられる場合はどこでも、1つ以上の演算子を使用することができます。後述のオペセットの操作も参照してください。</target>
        </trans-unit>
        <trans-unit id="c457c17dce216494419135c71949242b8d09d0bb" translate="yes" xml:space="preserve">
          <source>Wherever possible, shareable images are preferred to object libraries, and object libraries to plain object files. In accordance with VMS naming conventions, ext() looks for files named</source>
          <target state="translated">可能な限り、オブジェクトライブラリよりも共有可能な画像を、オブジェクトライブラリよりもプレーンなオブジェクトファイルを優先します。VMS の命名規則に従って、ext()は</target>
        </trans-unit>
        <trans-unit id="60f21be64cee3c558562d0924a678b1007587a17" translate="yes" xml:space="preserve">
          <source>Whether PadnamePV is in UTF8. Currently, this is always true.</source>
          <target state="translated">PadnamePVがUTF8かどうか。現在、これは常にtrueです。</target>
        </trans-unit>
        <trans-unit id="63b3304921bf73755f27746fb53954b4a8c4de93" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is disabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;require_order&lt;/code&gt; is enabled.</source>
          <target state="translated">コマンドライン引数をオプションと混合できるかどうか。環境変数POSIXLY_CORRECTが設定されていない限り、デフォルトは無効です。この場合、 &lt;code&gt;require_order&lt;/code&gt; が有効になります。</target>
        </trans-unit>
        <trans-unit id="faea90df33f36630a481da4cad34e4c79bf52fc5" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;permute&lt;/code&gt; is disabled. Note that &lt;code&gt;permute&lt;/code&gt; is the opposite of &lt;code&gt;require_order&lt;/code&gt; .</source>
          <target state="translated">コマンドライン引数をオプションと混合できるかどうか。環境変数POSIXLY_CORRECTが設定されていない限り、デフォルトは有効です。この場合、 &lt;code&gt;permute&lt;/code&gt; は無効になります。 &lt;code&gt;permute&lt;/code&gt; は &lt;code&gt;require_order&lt;/code&gt; の逆であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="bf16a187d3ac8048da2c0a9f49f8874167f5a83b" translate="yes" xml:space="preserve">
          <source>Whether or not the op has been optimized by the peephole optimizer.</source>
          <target state="translated">オペがのぞき穴オプティマイザによって最適化されているかどうか。</target>
        </trans-unit>
        <trans-unit id="99e430c2678f913bd7c7b93452d560622af7b626" translate="yes" xml:space="preserve">
          <source>Whether or not the test should output numbers. That is, this if true:</source>
          <target state="translated">テストが数値を出力するかどうか。つまり、真であればこれです。</target>
        </trans-unit>
        <trans-unit id="5f8067023624d336e348da355a79650c3095a919" translate="yes" xml:space="preserve">
          <source>Whether or not to be verbose about what it is doing -- it will default to $Module::Load::Conditional::VERBOSE</source>
          <target state="translated">何をしているかについて冗長にするかどうか --デフォルトは $Module::Load::Conditional::VERBOSE になります。</target>
        </trans-unit>
        <trans-unit id="a8f7f78ec0e44e67b9396390cd1ee3bcf0e5e14e" translate="yes" xml:space="preserve">
          <source>Whether this entry belongs to an outer pad. Entries for which this is true are often referred to as 'fake'.</source>
          <target state="translated">このエントリが外側のパッドに属しているかどうか。これが真であるエントリーは、しばしば「偽物」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="6283322d116e1d51f7edcd1ec872a9eed355ceb1" translate="yes" xml:space="preserve">
          <source>Whether this is a &quot;state&quot; variable.</source>
          <target state="translated">これが「状態」変数であるかどうか。</target>
        </trans-unit>
        <trans-unit id="e7034c09da28fdb3d58392534621cc03eebbd14d" translate="yes" xml:space="preserve">
          <source>Whether this is an &quot;our&quot; variable.</source>
          <target state="translated">これが「私たちの」変数であるかどうか。</target>
        </trans-unit>
        <trans-unit id="8fe93610e6b23e15b98198b34ad48105c383339a" translate="yes" xml:space="preserve">
          <source>Whether to abort printing if debugger signal flag is raised.</source>
          <target state="translated">デバッガシグナルフラグが立った場合に印刷を中止するかどうか。</target>
        </trans-unit>
        <trans-unit id="2985490d3101108f328098168c5a21b3bc3c5a70" translate="yes" xml:space="preserve">
          <source>Whether to add a table-of-contents at the top of each page (called an index for the sake of tradition).</source>
          <target state="translated">各ページの一番上に目次をつけるかどうか(伝統のために索引と呼ばれる</target>
        </trans-unit>
        <trans-unit id="3a911a7e2bce47416920de6f21016acd3029366b" translate="yes" xml:space="preserve">
          <source>Whether to anchor every definition &lt;code&gt;=item&lt;/code&gt; directive. This needs to be enabled if you want to be able to link to specific &lt;code&gt;=item&lt;/code&gt; directives, which are output as &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; elements. Disabled by default.</source>
          <target state="translated">すべての定義を固定するかどうか &lt;code&gt;=item&lt;/code&gt; ディレクティブ。 &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; 要素として出力される特定の &lt;code&gt;=item&lt;/code&gt; ディレクティブにリンクできるようにする場合は、これを有効にする必要があります。デフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="626413839d3d50a20deaaad85828e47d347f236c" translate="yes" xml:space="preserve">
          <source>Whether to call these extended grapheme clusters &quot;characters&quot; depends on your point of view. If you are a programmer, you probably would tend towards seeing each element in the sequences as one unit, or &quot;character&quot;. However from the user's point of view, the whole sequence could be seen as one &quot;character&quot; since that's probably what it looks like in the context of the user's language. In this document, we take the programmer's point of view: one &quot;character&quot; is one Unicode code point.</source>
          <target state="translated">これらの拡張された書記素クラスタを「文字」と呼ぶかどうかは、あなたの視点に依存します。あなたがプログラマーであれば、おそらくシーケンスの各要素を一つの単位、つまり「文字」として見る傾向があるでしょう。しかし、ユーザの視点から見れば、シーケンス全体を1つの「文字」として見ることができるでしょう。この文書では、プログラマの視点から見た場合、1つの「文字」が1つのUnicodeコードポイントになります。</target>
        </trans-unit>
        <trans-unit id="ee66335b9db0c1d5103deb721dc40777dd212c3c" translate="yes" xml:space="preserve">
          <source>Whether to print chars with high bit set in binary or &quot;as is&quot;.</source>
          <target state="translated">バイナリで高ビットが設定されている文字を表示するか、「そのまま」で表示するか。</target>
        </trans-unit>
        <trans-unit id="238ca87137bc56748ce05a002a71d9a6db9c7ebe" translate="yes" xml:space="preserve">
          <source>Whether to print contents of globs.</source>
          <target state="translated">グローブの内容を印刷するかどうか。</target>
        </trans-unit>
        <trans-unit id="d3a12643fc63beef0ef6ccef6dae848daa691587" translate="yes" xml:space="preserve">
          <source>Whether to try to find the subroutine name given the reference.</source>
          <target state="translated">参照元に与えられたサブルーチン名を検索しようとするかどうか。</target>
        </trans-unit>
        <trans-unit id="bfd0c6dfe7d4e4cba4e02f1a0ab33700dc1c327f" translate="yes" xml:space="preserve">
          <source>Whether to turn every =head1 directive into a link pointing to the top of the page (specifically, the opening body tag).</source>
          <target state="translated">すべての =head1 ディレクティブを、ページの先頭 (具体的には冒頭のボディタグ)を指すリンクにするかどうか。</target>
        </trans-unit>
        <trans-unit id="d26288162f4ab8ff9ae48923849befc89334a4a3" translate="yes" xml:space="preserve">
          <source>Whether to write the non-overloaded form of the stringify-overloaded objects.</source>
          <target state="translated">文字列化されたオブジェクトのオーバーロードされていない形式を書くかどうか。</target>
        </trans-unit>
        <trans-unit id="db40c6156e22d6cc6531821dd75bdcb0d45e3842" translate="yes" xml:space="preserve">
          <source>Whether various library calls are thread-safe is outside the control of Perl. Calls often suffering from not being thread-safe include: &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;, functions fetching user, group and network information (such as &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent()&lt;/a&gt;&lt;/code&gt; and so on), &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt;. In general, calls that depend on some global external state.</source>
          <target state="translated">さまざまなライブラリ呼び出しがスレッドセーフであるかどうかは、Perlの制御外です。スレッドセーフではないことがよくある呼び出しには、 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 、ユーザー、グループ、およびネットワーク情報を取得する関数（ &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent()&lt;/a&gt;&lt;/code&gt; など）、 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 。一般に、いくつかのグローバルな外部状態に依存する呼び出し。</target>
        </trans-unit>
        <trans-unit id="201246e3611962dc1ed1a9edc779811bfcd3278b" translate="yes" xml:space="preserve">
          <source>Whether you are using NIS does not matter. Amazingly enough, the same bug also affects Solaris.</source>
          <target state="translated">NISを使っているかどうかは関係ありません。驚くべきことに、同じバグが Solaris にも影響を与えています。</target>
        </trans-unit>
        <trans-unit id="f8e039fc339d1036f86bd64ce844762f9417fe8b" translate="yes" xml:space="preserve">
          <source>Whether you use &lt;code&gt;perlbug&lt;/code&gt; or send the email manually, please make your Subject line informative. &quot;a bug&quot; is not informative. Neither is &quot;perl crashes&quot; nor is &quot;HELP!!!&quot;. These don't help. A compact description of what's wrong is fine.</source>
          <target state="translated">&lt;code&gt;perlbug&lt;/code&gt; を使用する場合も、手動でメールを送信する場合も、件名を参考にしてください。「バグ」は有益ではありません。「perl crashes」でも「HELP !!!」でもありません。これらは役に立ちません。何が悪いのかを簡潔に説明すれば問題ありません。</target>
        </trans-unit>
        <trans-unit id="0cde069a15e713b9fe4a9a6b7078fade7daf5170" translate="yes" xml:space="preserve">
          <source>Whew! That is all the rest of the characters and character classes.</source>
          <target state="translated">ふぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇ 残りのキャラとキャラクラスは以上です。</target>
        </trans-unit>
        <trans-unit id="56043e0fa27cef8d93950adbdc599597748f590d" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; operation is being performed from the Perl level on &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt; , if any:</source>
          <target state="translated">どの&lt;a href=&quot;tie/hash&quot;&gt;タイ::ハッシュ&lt;/a&gt;操作は上のPerlのレベルから実行されている &lt;code&gt;%+&lt;/code&gt; または &lt;code&gt;%+&lt;/code&gt; 、もしあれば：</target>
        </trans-unit>
        <trans-unit id="babf69836d4addec6f5a5308cb5825c678eb405e" translate="yes" xml:space="preserve">
          <source>Which Perl blogs should I read?</source>
          <target state="translated">どのPerlブログを読めばいいのか?</target>
        </trans-unit>
        <trans-unit id="54a12a94c6d59fab4aeefed76c9781df10879a85" translate="yes" xml:space="preserve">
          <source>Which YAML implementation would you prefer?</source>
          <target state="translated">どのYAML実装がいいですか?</target>
        </trans-unit>
        <trans-unit id="88e9358d41b432fbb58126174b7979a4235a746a" translate="yes" xml:space="preserve">
          <source>Which architecture dependent directory?</source>
          <target state="translated">どのアーキテクチャに依存するディレクトリ?</target>
        </trans-unit>
        <trans-unit id="b7506b68ee68fa595a60659e338ae77c9646b01d" translate="yes" xml:space="preserve">
          <source>Which character set modifier is in effect?</source>
          <target state="translated">どの文字セット修飾子が有効になっているか?</target>
        </trans-unit>
        <trans-unit id="dc6d9abe75ea380074d1386fb6bc4638c51ca405" translate="yes" xml:space="preserve">
          <source>Which is checked first, &lt;code&gt;nomethod&lt;/code&gt; or &lt;code&gt;fallback&lt;/code&gt; ? If the two operands of an operator are of different types and both overload the operator, which implementation is used? The following are the precedence rules:</source>
          <target state="translated">最初にチェックされるのは、 &lt;code&gt;nomethod&lt;/code&gt; または &lt;code&gt;fallback&lt;/code&gt; ですか？演算子の2つのオペランドが異なる型で、両方が演算子をオーバーロードする場合、どの実装が使用されますか？優先ルールは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="2db62588fd2906af96c2fa483b06db407a80424f" translate="yes" xml:space="preserve">
          <source>Which is effectively just:</source>
          <target state="translated">それは事実上、ただの</target>
        </trans-unit>
        <trans-unit id="b3fbe5ee09cb06684cac7d1a3e427f0dd899daef" translate="yes" xml:space="preserve">
          <source>Which is what we might expect, the match finds the only &lt;code&gt;cat&lt;/code&gt; in the string and locks onto it. Consider, however, this regexp:</source>
          <target state="translated">これは私たちが予想することですが、一致は文字列内の唯一の &lt;code&gt;cat&lt;/code&gt; を見つけて、それにロックします。ただし、次の正規表現について考えてみます。</target>
        </trans-unit>
        <trans-unit id="b248b8b60b90917a66aeb94063d05f7d477a94bd" translate="yes" xml:space="preserve">
          <source>Which magazines have Perl content?</source>
          <target state="translated">Perlのコンテンツがある雑誌は?</target>
        </trans-unit>
        <trans-unit id="786c2c13e1b48f509ddfa13fe457e7ade1e2d5c4" translate="yes" xml:space="preserve">
          <source>Which makes $richard and $dick the same variable, but leaves @richard and @dick as separate arrays. Tricky, eh?</source>
          <target state="translated">これで$richardと$dickは同じ変数になりますが、@richardと@dickは別々の配列になります。難しいでしょ?</target>
        </trans-unit>
        <trans-unit id="c62379639a4b05982ed9a5d227696146f851a074" translate="yes" xml:space="preserve">
          <source>Which of the various &lt;code&gt;*OP&lt;/code&gt; structures this op uses. This should be one of the &lt;code&gt;OA_*&lt;/code&gt; constants from</source>
          <target state="translated">このopが使用するさまざまな &lt;code&gt;*OP&lt;/code&gt; 構造。これは、 &lt;code&gt;OA_*&lt;/code&gt; 定数のいずれかである必要があります</target>
        </trans-unit>
        <trans-unit id="9c28a2fc8be0459fa3248ceb80936f8aba82ccd2" translate="yes" xml:space="preserve">
          <source>Which of these modifiers is in effect at any given point in a regular expression depends on a fairly complex set of interactions. These have been designed so that in general you don't have to worry about it, but this section gives the gory details. As explained below in &lt;a href=&quot;#Extended-Patterns&quot;&gt;Extended Patterns&lt;/a&gt; it is possible to explicitly specify modifiers that apply only to portions of a regular expression. The innermost always has priority over any outer ones, and one applying to the whole expression has priority over any of the default settings that are described in the remainder of this section.</source>
          <target state="translated">これらの修飾子のどれが正規表現の任意の時点で有効であるかは、かなり複雑な一連の相互作用に依存します。これらは、一般に心配する必要がないように設計されていますが、このセクションでは詳細を説明します。以下の「&lt;a href=&quot;#Extended-Patterns&quot;&gt;拡張パターン」&lt;/a&gt;で説明するように、正規表現の一部にのみ適用される修飾子を明示的に指定できます。最も内側のものが常に外側のものよりも優先され、式全体に適用されるものは、このセクションの残りの部分で説明されるデフォルト設定よりも優先されます。</target>
        </trans-unit>
        <trans-unit id="3d81e570041b9ef8c3716fd625de2184bc9fcbe4" translate="yes" xml:space="preserve">
          <source>Which one you pick depends on which of these expressions better reflects the above specification of comments.</source>
          <target state="translated">どちらを選ぶかは、これらの表現が上記のコメントの仕様をよりよく反映しているかどうかにかかっています。</target>
        </trans-unit>
        <trans-unit id="79ee8492b912fab00990fc318850246c7ab7a4ba" translate="yes" xml:space="preserve">
          <source>Which perhaps unexpectedly yields:</source>
          <target state="translated">おそらく予想外の結果になるだろう</target>
        </trans-unit>
        <trans-unit id="4e550746bad7dcee6b1162b28bf7aedac094cd1e" translate="yes" xml:space="preserve">
          <source>Which rules apply are determined as described in &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;.</source>
          <target state="translated">どの&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;文字セット修飾子が有効であるかで&lt;/a&gt;説明されているように、どのルールが適用されますか？perlreで。</target>
        </trans-unit>
        <trans-unit id="b4ea6c1227777eb0d0611636fc0f0ce8660134f3" translate="yes" xml:space="preserve">
          <source>Which substring to check first.</source>
          <target state="translated">どの部分文字列を最初にチェックするか。</target>
        </trans-unit>
        <trans-unit id="4b26c1ae972001db5809b34aeb5a2c0bda11feda" translate="yes" xml:space="preserve">
          <source>Which text formatter to use. Default is &lt;a href=&quot;pod/text&quot;&gt;Pod::Text&lt;/a&gt;, or for very old Perl versions &lt;a href=&quot;pod/plaintext&quot;&gt;Pod::PlainText&lt;/a&gt;. An alternative would be e.g. &lt;a href=&quot;pod/text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">使用するテキストフォーマッター。デフォルトは&lt;a href=&quot;pod/text&quot;&gt;Pod :: Text&lt;/a&gt;、または非常に古いPerlバージョンの場合は&lt;a href=&quot;pod/plaintext&quot;&gt;Pod :: PlainText&lt;/a&gt;です。別の例としては、&lt;a href=&quot;pod/text/termcap&quot;&gt;Pod :: Text :: Termcapがあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="9b8afbe233aaf49239a07d2a4536a6d9be415fc8" translate="yes" xml:space="preserve">
          <source>Which version of Perl should I use?</source>
          <target state="translated">どのバージョンのPerlを使えばいいですか?</target>
        </trans-unit>
        <trans-unit id="32a93a6b75c99229f45ca5666bf0720d67cc2e24" translate="yes" xml:space="preserve">
          <source>Which version of perl should I use?</source>
          <target state="translated">どのバージョンのperlを使えばいいですか?</target>
        </trans-unit>
        <trans-unit id="7631d79fe8017e212e81e096dcea8cb82517cdbf" translate="yes" xml:space="preserve">
          <source>Which web framework should I use?</source>
          <target state="translated">どのWebフレームワークを使えばいいですか?</target>
        </trans-unit>
        <trans-unit id="1bd7ff93be76f4f655ab909493a6705c72660d9c" translate="yes" xml:space="preserve">
          <source>Which will print</source>
          <target state="translated">どちらが印刷されますか?</target>
        </trans-unit>
        <trans-unit id="03d7614f12de55df0b888753d3fa1d0fb28069d7" translate="yes" xml:space="preserve">
          <source>Which would attempt to set breakpoints on lines 4 and 6 immediately after debugger initialization. Note that @DB::typeahead is not a supported interface and is subject to change in future releases.</source>
          <target state="translated">これは、デバッガの初期化直後の 4 行目と 6 行目にブレークポイントを設定しようとします。DB::typeahead はサポートされているインターフェイスではなく、将来のリリースで変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c966532947a1e874f5fbb5570050ef3e1254690b" translate="yes" xml:space="preserve">
          <source>Which would generate a format looking something like this:</source>
          <target state="translated">このようなフォーマットを生成します。</target>
        </trans-unit>
        <trans-unit id="91c0db76a3c1130f40e63caacba5a278833ffb99" translate="yes" xml:space="preserve">
          <source>Which, in the degenerate case of using only ordinary arrays, gives you multidimensional arrays just like C's:</source>
          <target state="translated">これは,通常の配列だけを使う退化したケースでは,Cの配列と同じように多次元配列が得られます.</target>
        </trans-unit>
        <trans-unit id="49233da44986d650dd0c62f9412171689ae74192" translate="yes" xml:space="preserve">
          <source>Whichever version is used, the actual methods are called in the same context (list, scalar, or void) as the original call via &lt;code&gt;EVERY&lt;/code&gt; , and return:</source>
          <target state="translated">どちらのバージョンを使用しても、実際のメソッドは &lt;code&gt;EVERY&lt;/code&gt; を介した元の呼び出しと同じコンテキスト（リスト、スカラー、またはvoid）で呼び出され、次を返します。</target>
        </trans-unit>
        <trans-unit id="fed29deaf6c9f70efd08af26605d88141ad2586b" translate="yes" xml:space="preserve">
          <source>While $FORMAT_TOP_NAME contains the name of the current header format, there is no corresponding mechanism to automatically do the same thing for a footer. Not knowing how big a format is going to be until you evaluate it is one of the major problems. It's on the TODO list.</source>
          <target state="translated">format_top_nameには現在のヘッダフォーマットの名前が含まれていますが、フッタに対して同じことを自動的に行う対応する仕組みはありません。評価するまでフォーマットがどのくらいの大きさになるのかわからないのは、大きな問題の一つです。これはTODOリストにあります。</target>
        </trans-unit>
        <trans-unit id="b0cd08c49ca70b961592a79d7ad5531909d37f26" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; provides integer-only arithmetic, there is no analogous mechanism to provide automatic rounding or truncation to a certain number of decimal places. For rounding to a certain number of digits, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; is usually the easiest route. See &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;.</source>
          <target state="translated">ながら &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 整数のみの演算提供、小数点以下の特定の番号に自動的に丸めまたは切り捨てを提供するいかなる類似のメカニズムは存在しません。特定の桁数に丸めるには、通常、 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; が最も簡単な方法です。&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="01f836f2c1198b05b58549da2eae8767a49ca6a1" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;STORABLE_freeze&lt;/code&gt; and &lt;code&gt;STORABLE_thaw&lt;/code&gt; are useful for classes where each instance is independent, this mechanism has difficulty (or is incompatible) with objects that exist as common process-level or system-level resources, such as singleton objects, database pools, caches or memoized objects.</source>
          <target state="translated">ながら &lt;code&gt;STORABLE_freeze&lt;/code&gt; と &lt;code&gt;STORABLE_thaw&lt;/code&gt; が各インスタンスは独立しているクラスのために有用である、このメカニズムは困難である（または互換性がない）そのようなシングルトン・オブジェクト、データベース・プール、キャッシュまたはメモ化オブジェクトなどの一般的なプロセスレベル又はシステムレベルのリソースとして存在するオブジェクトと。</target>
        </trans-unit>
        <trans-unit id="4a400d769e405e7503768315d8de6e5c08fa4438" translate="yes" xml:space="preserve">
          <source>While B::Deparse goes to some lengths to try to figure out what your original program was doing, some parts of the language can still trip it up; it still fails even on some parts of Perl's own test suite. If you encounter a failure other than the most common ones described in the BUGS section below, you can help contribute to B::Deparse's ongoing development by submitting a bug report with a small example.</source>
          <target state="translated">B::Deparseは元のプログラムが何をしていたのかを理解しようとするためにある程度の努力をしているが、言語のいくつかの部分では失敗する可能性がある。以下のBUGSセクションで説明されている最も一般的なもの以外の失敗に遭遇した場合は、小さな例を挙げてバグレポートを提出することで、B::Deparseの継続的な開発に貢献することができます。</target>
        </trans-unit>
        <trans-unit id="1fb4e05a5830c846a9dc5981bceec998799ac3ed" translate="yes" xml:space="preserve">
          <source>While BigInt has extensive handling of inf and NaN, certain quirks remain.</source>
          <target state="translated">BigIntはinfとNaNを広範囲に扱っていますが、ある種の癖が残っています。</target>
        </trans-unit>
        <trans-unit id="fd702ed1f93515e973caeb556144e84284909d1e" translate="yes" xml:space="preserve">
          <source>While C guarantees the ordering specified in the struct definition, between different platforms the definitions might differ</source>
          <target state="translated">C は構造体の定義で指定された順序を保証していますが、異なるプラットフォーム間では定義が異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="cc4691f27fe5f793a7b1a252b87e1f8adf7ae71b" translate="yes" xml:space="preserve">
          <source>While Dan Kogai retains the copyright as a maintainer, credit should go to all those involved. See AUTHORS for a list of those who submitted code to the project.</source>
          <target state="translated">Dan Kogaiはメンテナとしての著作権を保持していますが、クレジットはすべての関係者に帰属します。プロジェクトにコードを提出した人のリストはAUTHORSを参照してください。</target>
        </trans-unit>
        <trans-unit id="e79628255662d7502ebd0e9fa4c3c1aca53d77c4" translate="yes" xml:space="preserve">
          <source>While Perl attempts to keep the vaxc$errno value to be current, if errno is not EVMSERR, it may not be from the current operation.</source>
          <target state="translated">Perl は vaxc$errno の値を現在のものにしようとしますが、 errno が EVMSERR でない場合は、現在の操作ではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="82ff355555ab6d2ce0a2840754c6edfffe9b0329" translate="yes" xml:space="preserve">
          <source>While Perl passes arguments to functions by reference, C passes arguments by value; to implement a C function which modifies data of one of the &quot;arguments&quot;, the actual argument of this C function would be a pointer to the data. Thus two C functions with declarations</source>
          <target state="translated">Perlが参照によって関数に引数を渡すのに対し、C言語は値によって引数を渡します。「引数」の1つのデータを変更するC言語の関数を実装するには、このC言語の関数の実際の引数はデータへのポインタになります。したがって、次のような宣言を持つ2つのC関数があります。</target>
        </trans-unit>
        <trans-unit id="c23f9c83568988309005d4ebe9f3a7a4c7b974ed" translate="yes" xml:space="preserve">
          <source>While System V IPC isn't so widely used as sockets, it still has some interesting uses. However, you cannot use SysV IPC or Berkeley mmap() to have a variable shared amongst several processes. That's because Perl would reallocate your string when you weren't wanting it to. You might look into the &lt;code&gt;IPC::Shareable&lt;/code&gt; or &lt;code&gt;threads::shared&lt;/code&gt; modules for that.</source>
          <target state="translated">System V IPCはソケットとしてそれほど広く使用されていませんが、それでも興味深い用途がいくつかあります。ただし、SysV IPCまたはBerkeley mmap（）を使用して、複数のプロセス間で変数を共有することはできません。これは、Perlが望まないときに文字列を再割り当てするためです。そのためには、 &lt;code&gt;IPC::Shareable&lt;/code&gt; または &lt;code&gt;threads::shared&lt;/code&gt; モジュールを調べる必要があります。</target>
        </trans-unit>
        <trans-unit id="95ba383e6ad59d1d5877dab883127e0598dee045" translate="yes" xml:space="preserve">
          <source>While a nice extension, it's not portable. The Perl code does admittedly use them if available to gain some extra speed (essentially as a funky form of inlining), but you shouldn't.</source>
          <target state="translated">素晴らしい拡張機能ですが、移植性はありません。Perl のコードでは、速度を向上させるために (基本的にはインライン化のファンキーな形式として)利用可能な場合にはそれを使用していますが、使用すべきではありません。</target>
        </trans-unit>
        <trans-unit id="98ac33662fa3d3f638b9cfcc69effe66a6af5d40" translate="yes" xml:space="preserve">
          <source>While a search is in progress, the progress object's &lt;code&gt;reach&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; methods are called like this:</source>
          <target state="translated">検索の進行中、progressオブジェクトの &lt;code&gt;reach&lt;/code&gt; および &lt;code&gt;done&lt;/code&gt; メソッドは次のように呼び出されます：</target>
        </trans-unit>
        <trans-unit id="5af2731519a4e72226e3efaa5ed68cb8f21ac8fa" translate="yes" xml:space="preserve">
          <source>While apparently a whole nuther program,</source>
          <target state="translated">どうやら全く別のプログラムのようだが</target>
        </trans-unit>
        <trans-unit id="2192d44f9e946df5ee1f8628bb7cf84591b693e7" translate="yes" xml:space="preserve">
          <source>While building Perl some changes may be necessary to your Cygwin setup so that Perl builds cleanly. These changes are &lt;b&gt;not&lt;/b&gt; required for normal Perl usage.</source>
          <target state="translated">Perlをビルドしている間、Perlをきれいにビルドするために、Cygwinセットアップにいくつかの変更が必要になる場合があります。これらの変更は、Perlの通常の使用に&lt;b&gt;は&lt;/b&gt;必要あり&lt;b&gt;ません&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="917e67f81e56107e856d601af96f9ace961e9a9a" translate="yes" xml:space="preserve">
          <source>While checking, this module collects document properties, e.g. the nodes for hyperlinks (&lt;code&gt;=headX&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; ) and index entries (&lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ). POD translators can use this feature to syntax-check and get the nodes in a first pass before actually starting to convert. This is expensive in terms of execution time, but allows for very robust conversions.</source>
          <target state="translated">チェック中、このモジュールはドキュメントのプロパティ、たとえばハイパーリンクのノード（ &lt;code&gt;=headX&lt;/code&gt; 、 &lt;code&gt;=item&lt;/code&gt; ）とインデックスエントリ（ &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ）を収集します。PODトランスレータはこの機能を使用して構文チェックを行い、実際に変換を開始する前の最初のパスでノードを取得できます。これは実行時間の点ではコストがかかりますが、非常に堅牢な変換が可能になります。</target>
        </trans-unit>
        <trans-unit id="6234d5fa2f6fac6ddbcf991bea921371b64250cc" translate="yes" xml:space="preserve">
          <source>While experts may argue about these idioms, a novice to Perl guts may prefer a way which is as little Perl-guts-specific as possible, meaning automatic conversion and automatic call generation, as in &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;Getting the fat out of XSUBs&lt;/a&gt;. This approach has the additional benefit of protecting the XSUB writer from future changes to the Perl API.</source>
          <target state="translated">専門家はこれらの慣用句について議論することができるが、Perlの根性に初心者はのように自動変換と自動呼び出し世代、つまり、できるだけ少しのPerl-根性固有のような方法を好むかもしれ&lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;なXSUBの脂肪アウトを取得します&lt;/a&gt;。このアプローチには、Perl APIに対する将来の変更からXSUBライターを保護するという追加の利点があります。</target>
        </trans-unit>
        <trans-unit id="601070e02f682375d5e25990b39de3389f3b8c49" translate="yes" xml:space="preserve">
          <source>While in principle the &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; operator could be implemented via (and with the same rather severe limitations as) the CRTL &lt;code&gt;vfork()&lt;/code&gt; routine, and while some internal support to do just that is in place, the implementation has never been completed, making &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; currently unavailable. A true kernel &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; is expected in a future version of VMS, and the pseudo-fork based on interpreter threads may be available in a future version of Perl on VMS (see &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;). In the meantime, use &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, backticks, or piped filehandles to create subprocesses.</source>
          <target state="translated">原則として、 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 演算子はCRTL &lt;code&gt;vfork()&lt;/code&gt; ルーチンを介して（そして同じようにかなり厳しい制限付きで）実装できますが、それを行うための内部サポートはいくつかありますが、実装はまだ完了しておらず、 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; は現在利用できません。真のカーネル &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; は、VMSの将来のバージョンで期待されており、インタープリタースレッドに基づく疑似フォークは、VMS上のPerlの将来のバージョンで利用可能になる可能性があります（&lt;a href=&quot;perlfork&quot;&gt;perlforkを&lt;/a&gt;参照）。それまでの間、 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 、backticks、またはパイプ処理されたファイルハンドルを使用してサブプロセスを作成してください。</target>
        </trans-unit>
        <trans-unit id="a11b15d87bb1f9501075e6254f16292a57b123f0" translate="yes" xml:space="preserve">
          <source>While in this mode, Perl takes special precautions called</source>
          <target state="translated">このモードでは、Perl は特別な注意事項として</target>
        </trans-unit>
        <trans-unit id="7c260f0d64ec7ed3061fae8a4547b586a55f37c5" translate="yes" xml:space="preserve">
          <source>While it is permissible to &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; a FileCache managed file, do not do so if you are calling &lt;code&gt;FileCache::cacheout&lt;/code&gt; from a package other than which it was imported, or with another module which overrides &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;. If you must, use &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; .</source>
          <target state="translated">FileCacheマネージドファイルを &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; ことは許可されていますが、 &lt;code&gt;FileCache::cacheout&lt;/code&gt; れたパッケージ以外のパッケージから、または &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; をオーバーライドする別のモジュールでFileCache :: cacheoutを呼び出す場合は、閉じないでください。必要な場合は、 &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; 使用してください。</target>
        </trans-unit>
        <trans-unit id="959732eaecdd2fded6d5f4730815e7ecfbb3c6a3" translate="yes" xml:space="preserve">
          <source>While it's not necessary for documentation changes, new tests or trivial patches, it's often worth explaining how your change works. Even if it's clear to you today, it may not be clear to a porter next month or next year.</source>
          <target state="translated">ドキュメントの変更、新しいテストや些細なパッチには必要ないことですが、変更がどのように機能するのかを説明する価値があることがよくあります。今日あなたには明らかであっても、来月や来年にはポーターには明らかではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="44568ef65eee77bd20a0348b5e9b725eb8d8f779" translate="yes" xml:space="preserve">
          <source>While it's possible to refer directly to these hash keys outside of the class, it's considered a best practice to wrap all access to the attribute with accessor methods.</source>
          <target state="translated">クラスの外でこれらのハッシュキーを直接参照することは可能ですが、属性へのすべてのアクセスをアクセサメソッドでラップすることがベストプラクティスと考えられています。</target>
        </trans-unit>
        <trans-unit id="d0849418f5c8269f5aff84704c4d9acb674dcdcc" translate="yes" xml:space="preserve">
          <source>While it's true that Perl's regular expressions resemble the DFAs (deterministic finite automata) of the egrep(1) program, they are in fact implemented as NFAs (non-deterministic finite automata) to allow backtracking and backreferencing. And they aren't POSIX-style either, because those guarantee worst-case behavior for all cases. (It seems that some people prefer guarantees of consistency, even when what's guaranteed is slowness.) See the book &quot;Mastering Regular Expressions&quot; (from O'Reilly) by Jeffrey Friedl for all the details you could ever hope to know on these matters (a full citation appears in &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;).</source>
          <target state="translated">Perlの正規表現がegrep（1）プログラムのDFA（確定的有限オートマトン）に類似していることは事実ですが、実際にはそれらはNFA（非確定的有限オートマトン）として実装されており、バックトラックとバックリファレンスが可能です。また、すべてのケースで最悪の動作を保証するため、POSIXスタイルでもありません。 （一部の人々は、保証されているものが低速であっても、一貫性の保証を好むようです。）これらの問題について知りたいと思っているすべての詳細については、Jeffrey Friedl著「Mastering Regular Expressions」（O'Reillyから）を参照してください（完全な引用は&lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;）に表示されます。</target>
        </trans-unit>
        <trans-unit id="3329779b59b299850e8b68832610b0b339dc0b1f" translate="yes" xml:space="preserve">
          <source>While it's true that this documentation is somewhat subserious, if you use a program named</source>
          <target state="translated">このドキュメントがやや従属的であることは事実ですが、もしあなたが</target>
        </trans-unit>
        <trans-unit id="10a36fcf99a8e338089d469f203ab0168ce94e49" translate="yes" xml:space="preserve">
          <source>While literal lists and named arrays are often interchangeable, that's not the case for hashes. Just because you can subscript a list value like a normal array does not mean that you can subscript a list value as a hash. Likewise, hashes included as parts of other lists (including parameters lists and return lists from functions) always flatten out into key/value pairs. That's why it's good to use references sometimes.</source>
          <target state="translated">リテラルリストと名前付き配列はしばしば互換性がありますが、ハッシュの場合はそうではありません。通常の配列のようにリスト値を添え字で添字することができるからといって、リスト値をハッシュとして添え字することができるわけではありません。同様に、他のリスト(パラメータリストや関数の戻り値リストを含む)の一部として含まれるハッシュは、常にキーと値のペアに平坦化されます。だからこそ、たまには参照を使うのが良いのです。</target>
        </trans-unit>
        <trans-unit id="eca6e56d146060aa14a3a670fa7ed2185164c9b5" translate="yes" xml:space="preserve">
          <source>While most important values in this file</source>
          <target state="translated">このファイルで最も重要な値は</target>
        </trans-unit>
        <trans-unit id="393059c305b4f9157627b86935072088d84089d3" translate="yes" xml:space="preserve">
          <source>While none of the built-in data types have any arbitrary size limits (apart from memory size), there are still a few arbitrary limits: a given variable name may not be longer than 251 characters. Line numbers displayed by diagnostics are internally stored as short integers, so they are limited to a maximum of 65535 (higher numbers usually being affected by wraparound).</source>
          <target state="translated">組み込みのデータ型にはいずれも任意のサイズ制限はありませんが(メモリ・サイズは別として)、いくつかの任意の制限があります。診断で表示される行番号は、内部的に短い整数として格納されているため、最大65535までに制限されています(それ以上の数値は通常、ラップアラウンドの影響を受けます)。</target>
        </trans-unit>
        <trans-unit id="1f300b76b4f41dcdc512a5b3661d8c1aa39ba74e" translate="yes" xml:space="preserve">
          <source>While not entirely limited to Unix-derived operating systems (e.g., WinSock on PCs provides socket support, as do some VMS libraries), you might not have sockets on your system, in which case this section probably isn't going to do you much good. With sockets, you can do both virtual circuits like TCP streams and datagrams like UDP packets. You may be able to do even more depending on your system.</source>
          <target state="translated">Unix 由来のオペレーティングシステムに完全に限定されているわけではありませんが (例えば、PC の WinSock はソケットをサポートしていますし、いくつかの VMS ライブラリもソケットをサポートしています)、あなたのシステムではソケットを使用していないかもしれません。ソケットを使えば、TCP ストリームのような仮想回路と UDP パケットのようなデータグラムの両方を行うことができます。お使いのシステムによっては、さらに多くのことができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="6ad3cf3a478c4f24fb9ef9675cf14d8e5c5a06f1" translate="yes" xml:space="preserve">
          <source>While running Configure and when building, you are likely to get quite a few of these warnings:</source>
          <target state="translated">Configureを実行しているときやビルド中に、これらの警告がいくつか出てくることがあります。</target>
        </trans-unit>
        <trans-unit id="9b58fa2736239282292bc4dda51122cd95ae2910" translate="yes" xml:space="preserve">
          <source>While short identifiers like &lt;code&gt;$gotit&lt;/code&gt; are probably ok, use underscores to separate words in longer identifiers. It is generally easier to read &lt;code&gt;$var_names_like_this&lt;/code&gt; than &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; , especially for non-native speakers of English. It's also a simple rule that works consistently with &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$gotit&lt;/code&gt; ような短い識別子はおそらく問題ありませんが、アンダースコアを使用して長い識別子の単語を区切ります。特に英語を母国語としない人にとっては、一般的に &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; よりも &lt;code&gt;$var_names_like_this&lt;/code&gt; を読む方が簡単です。これは、 &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; と一貫して機能する単純なルールでもあります。</target>
        </trans-unit>
        <trans-unit id="ae3268e08a1d3bd058ed6f797f7794fd47fc37b4" translate="yes" xml:space="preserve">
          <source>While some developers find fatalizing some warnings to be a useful defensive programming technique, using &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; to fatalize all possible warning categories -- including custom ones -- is particularly risky. Therefore, the use of &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; is &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;.</source>
          <target state="translated">一部の開発者は、警告を致命的にすることは有用な防御的プログラミング手法であると考えていますが、 &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; を使用して、カスタムカテゴリを含むすべての可能な警告カテゴリを致命的にすることは特に危険です。したがって、 &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; は&lt;a href=&quot;perlpolicy#discouraged&quot;&gt;お勧めしません&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f10f744968048551bad6ee098cf44a11a372745" translate="yes" xml:space="preserve">
          <source>While still in that directory, type:</source>
          <target state="translated">そのディレクトリにいる間に、次のように入力します。</target>
        </trans-unit>
        <trans-unit id="42ffebb3bbe4e65d94b8f907df7dc389a8053ee0" translate="yes" xml:space="preserve">
          <source>While the GNU project includes Perl in its distributions, there's no such thing as &quot;GNU Perl&quot;. Perl is not produced nor maintained by the Free Software Foundation. Perl's licensing terms are also more open than GNU software's tend to be.</source>
          <target state="translated">GNUプロジェクトはそのディストリビューションにPerlを含んでいますが、&quot;GNU Perl &quot;のようなものは存在しません。Perlはフリーソフトウェアファウンデーションによって制作されたり、保守されたりしていません。Perlのライセンス条項はGNUソフトウェアのものよりもオープンです。</target>
        </trans-unit>
        <trans-unit id="bcb3c100d2dfc2d28078ac3b93ee7e431111c075" translate="yes" xml:space="preserve">
          <source>While the Unicode Standard defines two additional forms of casefolding, one for Turkic languages and one that never maps one character into multiple characters, these are not provided by the Perl core; However, the CPAN module &lt;code&gt;Unicode::Casing&lt;/code&gt; may be used to provide an implementation.</source>
          <target state="translated">Unicode標準は、2つの追加の形式の大文字小文字変換を定義していますが、1つはTurkic言語用で、もう1つは1文字を複数の文字にマップしませんが、これらはPerlコアでは提供されません。ただし、CPANモジュール &lt;code&gt;Unicode::Casing&lt;/code&gt; を使用して実装を提供できます。</target>
        </trans-unit>
        <trans-unit id="761ba2f6d0a7dac9fb4c5d145960b451d6d26420" translate="yes" xml:space="preserve">
          <source>While the key must be a string value (since that's a basic restriction that Perl places on hash keys), the value in the lexicon can currently be of several types: a defined scalar, scalarref, or coderef. The use of these is explained above, in the section 'The &quot;maketext&quot; Method', and Bracket Notation for strings is discussed in the next section.</source>
          <target state="translated">キーは文字列の値でなければなりませんが(これは Perl がハッシュキーに課す基本的な制限なので)、レキシコン内の値は現在のところいくつかのタイプがあります:定義されたスカラ、スカラref、または coderef です。これらの使用法については上記の'maketext'メソッドのセクションで説明し、文字列のブラケット記法については次のセクションで説明します。</target>
        </trans-unit>
        <trans-unit id="d08b05105bcedd2fb07dc0399888e4c9d241f3f1" translate="yes" xml:space="preserve">
          <source>While the list of arguments might work fine for one, two or even three arguments, any more arguments become hard for the module user to remember, and hard for the module author to manage. If you want to add a new parameter you will have to add it to the end of the list for backward compatibility, and this will probably make your list order unintuitive. Also, if many elements may be undefined you may see the following unattractive method calls:</source>
          <target state="translated">引数リストは1つ、2つ、あるいは3つの引数であれば問題なく動作するかもしれませんが、それ以上の引数はモジュールのユーザにとっては覚えにくく、モジュールの作者にとっては管理が難しくなります。新しいパラメータを追加したい場合は、下位互換性のためにリストの最後に追加しなければなりません。また、多くの要素が未定義の場合、以下のような魅力的でないメソッドコールが表示されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="019950bbf16db8b6543648ebb335d2eaf049366f" translate="yes" xml:space="preserve">
          <source>While the mapping &quot;infin&quot; to the character &quot;\x{221E}&quot; will (hopefully) have been already handled by the Pod parser, the presence of the character in this file means that it's reasonably important enough to include in a formatter's table that maps from notable Unicode characters to the codes necessary for rendering them. So for a Unicode-to-*roff mapping, for example, this would merit the entry:</source>
          <target state="translated">infin &quot;と文字&quot;\x{221E}&quot;のマッピングは(うまくいけば)すでにPodパーサによって処理されているでしょうが、このファイルにこの文字があるということは、注目すべきUnicode文字からそれらをレンダリングするために必要なコードへのマッピングを行うフォーマッタのテーブルに含めるのに十分なほど重要であるということを意味します。つまり、例えばUnicode-to-*roffのマッピングの場合、このファイルはエントリに値するということになります。</target>
        </trans-unit>
        <trans-unit id="549c813f59b3276935336cbd28f55b4770622941" translate="yes" xml:space="preserve">
          <source>While the two classes may differ in many ways, when it comes to the &lt;code&gt;print_content()&lt;/code&gt; method, they are the same. This means that we can try to call the &lt;code&gt;print_content()&lt;/code&gt; method on an object of either class, and &lt;b&gt;we don't have to know what class the object belongs to!&lt;/b&gt;</source>
          <target state="translated">2つのクラスは多くの点で異なる場合がありますが、 &lt;code&gt;print_content()&lt;/code&gt; メソッドに関しては同じです。これは、どちらかのクラスのオブジェクトで &lt;code&gt;print_content()&lt;/code&gt; メソッドを呼び出そうとすることができ、オブジェクトが&lt;b&gt;どのクラスに属するかを知る必要がないことを意味します！&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="05f8c54acc4d9406822b250e87f501917fa0a683" translate="yes" xml:space="preserve">
          <source>While there are currently no architecture-specific extensions or modules distributed with perl, the following directories can be used to hold such files (replace the string VERSION by the appropriate version number):</source>
          <target state="translated">現在のところ、perlで配布されているアーキテクチャ固有の拡張機能やモジュールはありませんが、以下のディレクトリを使用して、そのようなファイルを保持することができます(VERSIONという文字列を適切なバージョン番号に置き換えてください)。</target>
        </trans-unit>
        <trans-unit id="0c8516dbb58fd38e067d471797d458e282eb5b87" translate="yes" xml:space="preserve">
          <source>While these operations are not questions of life and death, they are needed for a lot of useful scripts. This forces &lt;code&gt;a.out&lt;/code&gt; -style compile of</source>
          <target state="translated">これらの操作は生と死の問題ではありませんが、多くの便利なスクリプトに必要です。これにより、 &lt;code&gt;a.out&lt;/code&gt; スタイルのコンパイルが強制されます</target>
        </trans-unit>
        <trans-unit id="1849a634e96a61e2b3cdef3b11aa962d9aad4c39" translate="yes" xml:space="preserve">
          <source>While this actually can be done, it's much harder than you'd think. For example, this one-liner</source>
          <target state="translated">これは実際には可能ですが、思ったよりもずっと難しいです。例えば、このワンライナー</target>
        </trans-unit>
        <trans-unit id="c8b72cb61463146c67f31be1d892fe7495f6bd9f" translate="yes" xml:space="preserve">
          <source>While this allows some (significant?) performance advantages, this makes life much harder for developers, since the above scheme makes it impossible for a DLL to be &quot;linked&quot; to a symbol in the</source>
          <target state="translated">これにより、いくつかの(重要な?)パフォーマンス上の利点が得られる一方で、開発者にとっては非常に困難になります。</target>
        </trans-unit>
        <trans-unit id="5a4ded2cb5289b97c3775e062e86790bf5432277" translate="yes" xml:space="preserve">
          <source>While this class is currently implemented using the Class::Struct module to build a struct-like class, you shouldn't rely upon this.</source>
          <target state="translated">現在、このクラスは Class::Structure モジュールを使って構造体のようなクラスを作るために実装されていますが、これに頼るべきではありません。</target>
        </trans-unit>
        <trans-unit id="e68b146940f9324cc2fc3ad49971a5aa379db2a9" translate="yes" xml:space="preserve">
          <source>While this compiles and runs happily, it probably won't do what's expected, namely it doesn't print &quot;Hello World\n&quot; at all; It will on the other hand do exactly what it was told to do, computers being a bit that way inclined. That is, it will print out a newline character, and you'll get what looks like a blank line. It looks like there's 2 variables when (because of the typo) there's really 3:</source>
          <target state="translated">これはコンパイルして楽しく動いていますが、おそらく期待されていることはできないでしょう、つまり、&quot;Hello World &quot;を全く印刷しません。つまり、改行文字を出力して、空白の行のように見えるものを得るでしょう。変数が2つあるように見えますが、(タイプミスのために)実際には3つあります。</target>
        </trans-unit>
        <trans-unit id="b959fa7d0d0730d45d9d80c8527dc6a6d9341163" translate="yes" xml:space="preserve">
          <source>While this currently exists in all three implementations perl itself does not use it.</source>
          <target state="translated">これは現在、3つの実装すべてに存在していますが、Perl自身はこれを使用していません。</target>
        </trans-unit>
        <trans-unit id="f084942a5c159bd226784a38fd066229baa22988" translate="yes" xml:space="preserve">
          <source>While this document is intended to be useful to all module authors, it is particularly aimed at authors who wish to publish their modules on CPAN.</source>
          <target state="translated">この文書はすべてのモジュール作成者に役立つことを意図していますが、特にCPANでモジュールを公開したいと考えている作成者を対象としています。</target>
        </trans-unit>
        <trans-unit id="1785d6466e3128c272757d8a3931f08ab9e01f53" translate="yes" xml:space="preserve">
          <source>While this is legal practice, it is certainly dubious, and downright fatal in at least one platform: for example VMS cc considers this a fatal error. One cause for people often making this mistake is that a &quot;naked char&quot; and therefore dereferencing a &quot;naked char pointer&quot; have an undefined signedness: it depends on the compiler and the flags of the compiler and the underlying platform whether the result is signed or unsigned. For this very same reason using a 'char' as an array index is bad.</source>
          <target state="translated">これは法律上の慣行ではありますが、少なくとも1つのプラットフォームでは確かに怪しく、致命的なエラーとなります。人々がしばしばこの間違いを犯す原因の一つは、&quot;naked char &quot;とそのために &quot;naked char ポインタ &quot;を参照していると、未定義の符号付きになってしまうことです。これと全く同じ理由で、配列のインデックスとして 'char' を使うのは良くありません。</target>
        </trans-unit>
        <trans-unit id="40200d6701039334e5e5bffbb6cca8ab91bc30ff" translate="yes" xml:space="preserve">
          <source>While this is true on the surface, it's much more efficient to process the file one line or record at a time because then you don't have to read the whole thing into memory at once. It also gives you finer control of the whole process, letting you kill off the child process early if you'd like.</source>
          <target state="translated">これは表面上はそうですが、ファイルを一度に一行またはレコードごとに処理する方がはるかに効率的です。また、プロセス全体をより細かく制御することができるので、子プロセスを早期に終了させることができます。</target>
        </trans-unit>
        <trans-unit id="9790d6e959def47c7e50e558f607fe7ba4374a90" translate="yes" xml:space="preserve">
          <source>While this might be too cumbersome to implement in event-based Pod parsers, it is straightforward for parsers that return parse trees.</source>
          <target state="translated">これはイベントベースのPodパーサに実装するには煩雑すぎるかもしれませんが、パースツリーを返すパーサでは簡単です。</target>
        </trans-unit>
        <trans-unit id="81aa0dd02571c7973cd68f4d9f805b1c67ff2c9c" translate="yes" xml:space="preserve">
          <source>While this might by accident work in some platform (where IV happens to be an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;), in general it cannot. IV might be something larger. Even worse the situation is with more specific types (defined by Perl's configuration step in</source>
          <target state="translated">これは、偶然に一部のプラットフォーム（IVがたまたま &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; である）で機能する可能性がありますが、一般的には機能しません。IVはもっと大きいかもしれません。さらに悪い状況は、より具体的なタイプ（Perlの構成ステップで定義されている）</target>
        </trans-unit>
        <trans-unit id="82be9c7a2de102e2677bf88ba7443091644097cd" translate="yes" xml:space="preserve">
          <source>While this works reasonably well for unidirectional communication, what about bidirectional communication? The most obvious approach doesn't work:</source>
          <target state="translated">これは一方向通信ではそれなりに機能しますが、双方向通信ではどうでしょうか?最も明白なアプローチはうまくいかない。</target>
        </trans-unit>
        <trans-unit id="26ea84a69e787188d7dfd7dc7bac4a8b95950ee8" translate="yes" xml:space="preserve">
          <source>While threads bring a new set of useful tools, they also bring a number of pitfalls. One pitfall is the race condition:</source>
          <target state="translated">スレッドは新しい便利なツールのセットをもたらす一方で、多くの落とし穴ももたらします。落とし穴の一つは、レース条件です。</target>
        </trans-unit>
        <trans-unit id="8fb55e176d75bb6afa2c9779e5d12c3767454404" translate="yes" xml:space="preserve">
          <source>While trying to read from his caller-id box, the notorious Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; , after much gnashing of teeth and fighting with &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, POSIX's &lt;code&gt;tcgetattr&lt;/code&gt; business, and various other functions that go bump in the night, finally came up with this:</source>
          <target state="translated">悪名高いJamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; は、彼の発信者IDボックスから読み込もうとしている間に、 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 、POSIXの &lt;code&gt;tcgetattr&lt;/code&gt; ビジネス、および夜間に衝突するその他のさまざまな関数との戦いを経て、最後にこれを思い付きました：</target>
        </trans-unit>
        <trans-unit id="5ffa8b7afc028fdbcdab4b6dea3d1eb48e0f55ad" translate="yes" xml:space="preserve">
          <source>While using the standard</source>
          <target state="translated">標準で使用している間は</target>
        </trans-unit>
        <trans-unit id="c059f6308f685a568f9b74b626f917b18a45a114" translate="yes" xml:space="preserve">
          <source>While version objects overload stringification, to portably convert &lt;code&gt;$^V&lt;/code&gt; into its string representation, use &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; conversion, which works for both v-strings or version objects:</source>
          <target state="translated">バージョンオブジェクトは文字列化をオーバーロードしますが、 &lt;code&gt;$^V&lt;/code&gt; をその文字列表現に移植可能に変換するには、 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; 変換を使用します。これは、v文字列またはバージョンオブジェクトの両方で機能します。</target>
        </trans-unit>
        <trans-unit id="3a5995cddc89ffbbaa6e8a0013934033bfcd3e1f" translate="yes" xml:space="preserve">
          <source>While versions earlier than 5.8.1 had threads they contain too many bugs to support.</source>
          <target state="translated">5.8.1 より前のバージョンにはスレッドがありましたが、サポートするにはあまりにも多くのバグを含んでいます。</target>
        </trans-unit>
        <trans-unit id="daa9a857c615b0eef13a54df6fdfd26532388959" translate="yes" xml:space="preserve">
          <source>While we normally think of patterns as being delimited with &lt;code&gt;/&lt;/code&gt; characters, they can be delimited by almost any character. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; describes this. For example, the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; above uses braces as delimiters. Selecting another delimiter can avoid quoting the delimiter within the pattern:</source>
          <target state="translated">通常、パターンは &lt;code&gt;/&lt;/code&gt; 文字で区切られていると考えられますが、ほとんどすべての文字で区切ることができます。&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;はこれについて説明しています。たとえば、上記 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; は、中括弧を区切り文字として使用します。別の区切り文字を選択すると、パターン内の区切り文字の引用を回避できます。</target>
        </trans-unit>
        <trans-unit id="09af51d2e240602d6d93896cb9f587c7a82f4e64" translate="yes" xml:space="preserve">
          <source>While we strongly suggest you don't build your objects from scratch, you should know the term &lt;b&gt;bless&lt;/b&gt;. A &lt;b&gt;blessed&lt;/b&gt; data structure (aka &quot;a referent&quot;) is an object. We sometimes say that an object has been &quot;blessed into a class&quot;.</source>
          <target state="translated">オブジェクトを最初から構築しないことを強くお勧めしますが、&lt;b&gt;bless&lt;/b&gt;という用語&lt;b&gt;を&lt;/b&gt;知っておく必要があります。&lt;b&gt;祝福&lt;/b&gt;データ構造（別名「参照先」）が目的です。オブジェクトは「クラスに祝福されている」と私たちは時々言います。</target>
        </trans-unit>
        <trans-unit id="562c113d1f1007e0a6502247b3772bac3c2d33a2" translate="yes" xml:space="preserve">
          <source>While we usually think of quotes as literal values, in Perl they function as operators, providing various kinds of interpolating and pattern matching capabilities. Perl provides customary quote characters for these behaviors, but also provides a way for you to choose your quote character for any of them. In the following table, a &lt;code&gt;{}&lt;/code&gt; represents any pair of delimiters you choose.</source>
          <target state="translated">通常、引用符はリテラル値と見なされますが、Perlでは演算子として機能し、さまざまな種類の補間およびパターンマッチング機能を提供します。Perlはこれらの振る舞いに慣習的な引用文字を提供しますが、それらのいずれかの引用文字を選択する方法も提供します。次の表では、 &lt;code&gt;{}&lt;/code&gt; は選択した区切り文字のペアを表します。</target>
        </trans-unit>
        <trans-unit id="34200b2d58936bc37828d3e87d2eebbab2c0f898" translate="yes" xml:space="preserve">
          <source>While we're here, take a closer look at the '&lt;b&gt;x&lt;/b&gt;' command, it's really useful and will merrily dump out nested references, complete objects, partial objects - just about whatever you throw at it:</source>
          <target state="translated">ここにいる間、 ' &lt;b&gt;x&lt;/b&gt; 'コマンドを詳しく見てみましょう。これは非常に便利であり、ネストされた参照、完全なオブジェクト、部分的なオブジェクト-何を投げたとしても非常に便利にダンプします。</target>
        </trans-unit>
        <trans-unit id="00e2fed4a06f99f6100461a2d8cbb333f4d09501" translate="yes" xml:space="preserve">
          <source>While you can mix double colons with singles quotes, the quotes must come after the colons: &lt;code&gt;$::::'foo&lt;/code&gt; and &lt;code&gt;$foo::'bar&lt;/code&gt; are legal, but &lt;code&gt;$::'::foo&lt;/code&gt; and &lt;code&gt;$foo'::bar&lt;/code&gt; are not.</source>
          <target state="translated">二重コロンと単一引用符を混在させることができますが、引用符はコロンの後に置く必要があります。 &lt;code&gt;$::::'foo&lt;/code&gt; と &lt;code&gt;$foo::'bar&lt;/code&gt; は正当ですが、 &lt;code&gt;$::'::foo&lt;/code&gt; と &lt;code&gt;$foo'::bar&lt;/code&gt; そうではありません。</target>
        </trans-unit>
        <trans-unit id="078d591b0ade8bcb579420345c7df7b2c236f00e" translate="yes" xml:space="preserve">
          <source>While you can use arbitrary unique IDs for lexicon keys (like &quot;_min_larger_max_error&quot;), it is often useful for if an entry's key is itself a valid value, like this example error message:</source>
          <target state="translated">レキシコンキーには任意のユニークなIDを使用することができますが(「_min_larger_max_error」のように)、この例のエラーメッセージのように、エントリのキー自体が有効な値であるかどうかを確認するのに便利なことがよくあります。</target>
        </trans-unit>
        <trans-unit id="59ac30a04c89545845f0a1e87ea492a8c9c597ff" translate="yes" xml:space="preserve">
          <source>While you're doing that, make really sure you haven't missed a module similar to the one you're about to write.</source>
          <target state="translated">そうしている間に、これから書こうとしているものと似たようなモジュールを見逃していないか、本当に確認してください。</target>
        </trans-unit>
        <trans-unit id="c6568ae799534002dc040ff86ba3511a9bd4bd58" translate="yes" xml:space="preserve">
          <source>Whilst control is in the library, an error condition occurs. You have previously set up a Perl callback to handle this situation, so it will get executed. Once the callback has finished, control will drop back to Perl again. Here is what the flow of control will be like in that situation</source>
          <target state="translated">制御がライブラリ内にあるときに、エラー状態が発生します。この状況を処理するためにPerlのコールバックを設定していますので、それが実行されます。コールバックが終了すると、制御は再びPerlに戻ります。その場合の制御の流れは次のようになります。</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="e3b1deb6ad1643a6518bffe011e47a1bbf2cd01d" translate="yes" xml:space="preserve">
          <source>Whitespace does not delimit fileglobs.</source>
          <target state="translated">空白はファイルグロブを区切りません。</target>
        </trans-unit>
        <trans-unit id="df7fa704cbceacef574fb86983159dfe4b06ae43" translate="yes" xml:space="preserve">
          <source>Whitespace in filenames is tolerated on most systems, but not all, and even on systems where it might be tolerated, some utilities might become confused by such whitespace.</source>
          <target state="translated">ファイル名の空白は、ほとんどのシステムでは許容されていますが、すべてのシステムでは許容されていません。</target>
        </trans-unit>
        <trans-unit id="baf39f9fbe05bd8902b826d4b1716bd33c1e5022" translate="yes" xml:space="preserve">
          <source>Whitespace is ignored.</source>
          <target state="translated">空白は無視されます。</target>
        </trans-unit>
        <trans-unit id="09822d18c062da75d056f267dd113eb02444df2b" translate="yes" xml:space="preserve">
          <source>Whitespace is irrelevant:</source>
          <target state="translated">空白は関係ありません。</target>
        </trans-unit>
        <trans-unit id="e6027b651e819925aa47dc4c27f8a2f557b14aae" translate="yes" xml:space="preserve">
          <source>Who Needs Complicated Data Structures?</source>
          <target state="translated">複雑なデータ構造を必要とするのは誰か?</target>
        </trans-unit>
        <trans-unit id="ce404d98012c2a69e116523288638e2bddf0b8c2" translate="yes" xml:space="preserve">
          <source>Who supports Perl? Who develops it? Why is it free?</source>
          <target state="translated">誰がPerlをサポートしていますか?誰が開発しているの?なぜ無料なのか?</target>
        </trans-unit>
        <trans-unit id="6272068bf74683d289db3b55d0ea826c2bd453e3" translate="yes" xml:space="preserve">
          <source>Who wrote it (use AUTHORS for multiple people). It's a good idea to include your current e-mail address (or some e-mail address to which bug reports should be sent) or some other contact information so that users have a way of contacting you. Remember that program documentation tends to roam the wild for far longer than you expect and pick a contact method that's likely to last.</source>
          <target state="translated">誰が書いたのか (複数人の場合は AUTHORS を使ってください)。あなたの現在の電子メールアドレス (あるいはバグ報告を送るべき電子メールアドレス)やその他の連絡先を記載して、 ユーザがあなたに連絡できるようにするのが良いでしょう。プログラムのドキュメントは、あなたが思っている以上に長く野放しにされている傾向があることを覚えておいて、長持ちする可能性の高い連絡方法を選んでください。</target>
        </trans-unit>
        <trans-unit id="b22ef207f555182408b6d1958c0f8d72d42ebbcf" translate="yes" xml:space="preserve">
          <source>Whoops! You just put a tab and a formfeed into that filename! Remember that within double quoted strings (&quot;like\this&quot;), the backslash is an escape character. The full list of these is in &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;. Unsurprisingly, you don't have a file called &quot;c:(tab)emp(formfeed)oo&quot; or &quot;c:(tab)emp(formfeed)oo.exe&quot; on your legacy DOS filesystem.</source>
          <target state="translated">おっと！そのファイル名にタブとフォームフィードを挿入するだけです！二重引用符で囲まれた文字列（ &quot;like \ this&quot;）内では、バックスラッシュがエスケープ文字であることを覚えておいてください。これらの完全なリストは&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;、perlopのQuoteおよびQuote-like Operatorsにあり&lt;/a&gt;ます。当然のことながら、レガシーDOSファイルシステムに「c：（tab）emp（formfeed）oo」または「c：（tab）emp（formfeed）oo.exe」というファイルはありません。</target>
        </trans-unit>
        <trans-unit id="8c0f41e4219d3445a18de71b89eb22ea90d39e82" translate="yes" xml:space="preserve">
          <source>Whoops. You should instead use this, which will fail if the file doesn't exist:</source>
          <target state="translated">おっと。これはファイルが存在しない場合に失敗します。</target>
        </trans-unit>
        <trans-unit id="9560992747d1a6605928cb6a17f56014fb292bd8" translate="yes" xml:space="preserve">
          <source>Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?</source>
          <target state="translated">なぜ私は、本来取得すべき数字(例:19.95)ではなく、長い小数点以下の数字(例:19.9499999999999)を取得しているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="dc84c992e3edcd39e94928310a7c42a03b0e34c8" translate="yes" xml:space="preserve">
          <source>Why aren't my random numbers random?</source>
          <target state="translated">なぜ私の乱数はランダムじゃないの?</target>
        </trans-unit>
        <trans-unit id="55451ebd45b1e100db71c6105ddc04433d37cb2f" translate="yes" xml:space="preserve">
          <source>Why can't I get the output of a command with system()?</source>
          <target state="translated">なぜ system()でコマンドの出力を取得できないのですか?</target>
        </trans-unit>
        <trans-unit id="6283f33f8240aceff8b5bf7c89ea62586d7996ea" translate="yes" xml:space="preserve">
          <source>Why can't I just open(FH, &quot;&amp;gt;file.lock&quot;)?</source>
          <target state="translated">なぜ単に開くことができないのですか（FH、 &quot;&amp;gt; file.lock&quot;）？</target>
        </trans-unit>
        <trans-unit id="45f36238b104ed9ce41136ab2cd5676c9546b754" translate="yes" xml:space="preserve">
          <source>Why can't I use &quot;C:\temp\foo&quot; in DOS paths? Why doesn't `C:\temp\foo.exe` work?</source>
          <target state="translated">DOSパスで &quot;C:\temp\foo&quot; が使えないのはなぜ?なぜ `C:tempemp\foo.exe` が動かないのでしょうか?</target>
        </trans-unit>
        <trans-unit id="7cf9bf3687394740ded1b7a3b49b00f8b7f479e0" translate="yes" xml:space="preserve">
          <source>Why can't a method included in this same file be found?</source>
          <target state="translated">同じファイルに含まれるメソッドが見つからないのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="c1b368f947117e2802b241b52fd0f345164c6250" translate="yes" xml:space="preserve">
          <source>Why can't my script read from STDIN after I gave it EOF (^D on Unix, ^Z on MS-DOS)?</source>
          <target state="translated">なぜ私のスクリプトはEOF (Unixでは^D、MS-DOSでは^Z)を与えた後、STDINから読み込めないのでしょうか?</target>
        </trans-unit>
        <trans-unit id="4a35a43f2543633bf09ecfd8ed381f93a2e351c4" translate="yes" xml:space="preserve">
          <source>Why chimera build?</source>
          <target state="translated">なぜキメラビルドなのか?</target>
        </trans-unit>
        <trans-unit id="4ad29870738240c44cf5d008e9ef6e5a830b4811" translate="yes" xml:space="preserve">
          <source>Why did MakeMaker reinvent the build configuration wheel? Why not just use autoconf or automake or ppm or Ant or ...</source>
          <target state="translated">なぜ MakeMaker はビルド設定ホイールを再発明したのでしょうか?なぜ autoconf や automake や ppm や Ant や ...を使わないのか?</target>
        </trans-unit>
        <trans-unit id="9c94cf8ad35b8d40bcd1d8a24897df534e24a65c" translate="yes" xml:space="preserve">
          <source>Why do I get asked the same questions every time I start the shell?</source>
          <target state="translated">シェルを起動するたびに同じ質問をされるのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="88d20a17cd64b1f5b322facdeee78dd428855e4f" translate="yes" xml:space="preserve">
          <source>Why do I get weird spaces when I print an array of lines?</source>
          <target state="translated">行の配列を印刷すると変なスペースが出るのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="22c242ee2f7e6a5499b05c8e9ef2302a328d950b" translate="yes" xml:space="preserve">
          <source>Why do I sometimes get an &quot;Argument list too long&quot; when I use &amp;lt;*&amp;gt;?</source>
          <target state="translated">&amp;lt;*&amp;gt;を使用すると、「引数リストが長すぎる」ことが時々あるのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="b24284283ebf1fc2287cf9d0bdc0093551feae63" translate="yes" xml:space="preserve">
          <source>Why do I sometimes get an &quot;Argument list too long&quot; when I use ?</source>
          <target state="translated">を使用すると、&quot;Argument list too long&quot; というメッセージが表示されることがあります。</target>
        </trans-unit>
        <trans-unit id="63e6abc6f1a440467925da9b75e53aa88bf445d6" translate="yes" xml:space="preserve">
          <source>Why do Perl operators have different precedence than C operators?</source>
          <target state="translated">なぜPerlの演算子はCの演算子とは優先順位が異なるのですか?</target>
        </trans-unit>
        <trans-unit id="ef2253bfbc8ad66388d03d0bb9e87b886d907b29" translate="yes" xml:space="preserve">
          <source>Why do regex character classes sometimes match only in the ASCII range?</source>
          <target state="translated">正規表現の文字クラスがASCIIの範囲内でしか一致しないことがあるのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="fe1dc5c347574cf3a08e8eebfbeb7750b39e6b8c" translate="yes" xml:space="preserve">
          <source>Why do setuid perl scripts complain about kernel problems?</source>
          <target state="translated">なぜ setuid perl スクリプトはカーネルの問題について文句を言うのですか?</target>
        </trans-unit>
        <trans-unit id="026df39820ea4af121bee1f807b65636d02b2c10" translate="yes" xml:space="preserve">
          <source>Why do some characters not uppercase or lowercase correctly?</source>
          <target state="translated">大文字や小文字が正しくない文字があるのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="c99d6ee81fb9e8a95f7bcc8c77d79b83dd80d118" translate="yes" xml:space="preserve">
          <source>Why do you want to do that? :-)</source>
          <target state="translated">なぜそんなことをしたいのか :-)</target>
        </trans-unit>
        <trans-unit id="bd94a8382da48e70b41ef67567b746b186c9a0e6" translate="yes" xml:space="preserve">
          <source>Why does Perl let me delete read-only files? Why does -i clobber protected files? Isn't this a bug in Perl?</source>
          <target state="translated">なぜPerlは読み取り専用のファイルを削除できるのですか?なぜ-iは保護されたファイルを削除しないのですか?これはPerlのバグではないのですか?</target>
        </trans-unit>
        <trans-unit id="cc878c7b17c2f51ef8a429a9375cb383410dd74c" translate="yes" xml:space="preserve">
          <source>Why does Perl let me delete read-only files? Why does &lt;code&gt;-i&lt;/code&gt; clobber protected files? Isn't this a bug in Perl?</source>
          <target state="translated">なぜPerlでは読み取り専用ファイルを削除できるのですか？ &lt;code&gt;-i&lt;/code&gt; clobberがファイルを保護するのはなぜですか？これはPerlのバグではありませんか？</target>
        </trans-unit>
        <trans-unit id="cab7997afd3e855e0bc949d3ba08b5a07d77bad2" translate="yes" xml:space="preserve">
          <source>Why does defined() return true on empty arrays and hashes?</source>
          <target state="translated">defined()が空の配列やハッシュに対して真を返すのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="a9078f034de31f1b296232dfb6a8a4e24d9d3fe0" translate="yes" xml:space="preserve">
          <source>Why does passing a subroutine an undefined element in a hash create it?</source>
          <target state="translated">なぜサブルーチンに未定義の要素を渡すとハッシュが作成されるのか?</target>
        </trans-unit>
        <trans-unit id="7586fa4c0b5fc90f209bbbf4172abb17863eb05e" translate="yes" xml:space="preserve">
          <source>Why does using $&amp;amp;, $`, or $' slow my program down?</source>
          <target state="translated">$＆、$ `、または$ 'を使用するとプログラムが遅くなるのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="d0d6812625a87b8571932c2c534a16df1d30c46a" translate="yes" xml:space="preserve">
          <source>Why doesn't &quot;my($foo) = &amp;lt;$fh&amp;gt;;&quot; work right?</source>
          <target state="translated">「my（$ foo）= &amp;lt;$ fh&amp;gt;;」にならないのはなぜですか 正しいですか？</target>
        </trans-unit>
        <trans-unit id="dce612b6a2414fd18ba042c0e4b6d8009b148ed5" translate="yes" xml:space="preserve">
          <source>Why doesn't &quot;my($foo) = ;&quot; work right?</source>
          <target state="translated">my($foo)=;」が正しく動作しないのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="5027566591e947a691e8c94cf6484817ceca1f52" translate="yes" xml:space="preserve">
          <source>Why doesn't &amp;amp; work the way I want it to?</source>
          <target state="translated">なぜ、思い通りに動作しないのですか？</target>
        </trans-unit>
        <trans-unit id="4cf8f75bbab1ae3d6a9b3cc517f4738f093df66a" translate="yes" xml:space="preserve">
          <source>Why doesn't glob(&quot;*.*&quot;) get all the files?</source>
          <target state="translated">なぜ glob(&quot;*.*&quot;)はすべてのファイルを取得しないのですか?</target>
        </trans-unit>
        <trans-unit id="2deaa0032d55ad3bbe4d463b92dc4d6876271de7" translate="yes" xml:space="preserve">
          <source>Why doesn't my sockets program work under System V (Solaris)? What does the error message &quot;Protocol not supported&quot; mean?</source>
          <target state="translated">システム V (Solaris)でソケットプログラムが動作しないのはなぜですか? エラーメッセージ「プロトコルがサポートされていません」は何を意味しますか?</target>
        </trans-unit>
        <trans-unit id="94b7e3ba62840111acddb7ecbcec36ba2e7bc4b2" translate="yes" xml:space="preserve">
          <source>Why doesn't open() return an error when a pipe open fails?</source>
          <target state="translated">パイプのオープンに失敗したときにopen()がエラーを返さないのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="39d80c781157cb75a05623de25db34f558131470" translate="yes" xml:space="preserve">
          <source>Why don't Perl one-liners work on my DOS/Mac/VMS system?</source>
          <target state="translated">なぜ私のDOS/Mac/VMSシステムでPerlのワンライナーが動作しないのですか?</target>
        </trans-unit>
        <trans-unit id="7efb6bacfd459d208d2e83d3ccd6f5a6e06b31a2" translate="yes" xml:space="preserve">
          <source>Why don't my &amp;lt;</source>
          <target state="translated">なぜ私の&amp;lt;</target>
        </trans-unit>
        <trans-unit id="d55b9cceedd9f6975831dcd97371f91faa17e9ba" translate="yes" xml:space="preserve">
          <source>Why don't my &amp;lt;&amp;lt;HERE documents work?</source>
          <target state="translated">&amp;lt;&amp;lt; HEREドキュメントが機能しないのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="1b729d456f5e2de755ce9ca47664753dfbd6fc06" translate="yes" xml:space="preserve">
          <source>Why don't my tied hashes make the defined/exists distinction?</source>
          <target state="translated">なぜ私のタイドハッシュは定義された/存在の区別をしないのですか?</target>
        </trans-unit>
        <trans-unit id="ec879bc347cf004a28479d385b991508d06231e9" translate="yes" xml:space="preserve">
          <source>Why don't word-boundary searches with &lt;code&gt;\b&lt;/code&gt; work for me?</source>
          <target state="translated">&lt;code&gt;\b&lt;/code&gt; を使用した単語境界検索が機能しないのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="123e5244abcc6475513e58c7be3baf1e624a09b7" translate="yes" xml:space="preserve">
          <source>Why don't word-boundary searches with \b work for me?</source>
          <target state="translated">Why don't work with \b with word-boundary search for me?</target>
        </trans-unit>
        <trans-unit id="aa0f337d4d9c4331ea81d21ad3497b56fec40614" translate="yes" xml:space="preserve">
          <source>Why dynamic linking?</source>
          <target state="translated">なぜダイナミックリンクなのか?</target>
        </trans-unit>
        <trans-unit id="4dfd253727c4f99a421a3b97c6c33e70ca139825" translate="yes" xml:space="preserve">
          <source>Why is int() broken?</source>
          <target state="translated">なぜ int()は壊れているのですか?</target>
        </trans-unit>
        <trans-unit id="a9539bbca1f0e44580627232613c4e6433a9dda3" translate="yes" xml:space="preserve">
          <source>Why is there Perl source in my database?</source>
          <target state="translated">なぜ私のデータベースにPerlのソースがあるのですか?</target>
        </trans-unit>
        <trans-unit id="5376410df92e4e194b5ef26e3120b8356d39f687" translate="yes" xml:space="preserve">
          <source>Why isn't my octal data interpreted correctly?</source>
          <target state="translated">私の八進数データが正しく解釈されないのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="8adf1b58b38027864f2d28cd98aeb834dee11ea7" translate="yes" xml:space="preserve">
          <source>Why strange names?</source>
          <target state="translated">なぜ変な名前なのか?</target>
        </trans-unit>
        <trans-unit id="d2f963c70a1ed1fc561f572fe023203fb76a83ae" translate="yes" xml:space="preserve">
          <source>Why the heck Encode API is different?</source>
          <target state="translated">なぜEncode APIは違うのか?</target>
        </trans-unit>
        <trans-unit id="2d967f841c57d824cac2c9266688fd2aa1c5db9c" translate="yes" xml:space="preserve">
          <source>Why use ppport.h?</source>
          <target state="translated">なぜppport.hを使うのか?</target>
        </trans-unit>
        <trans-unit id="df4212a2d988730cb90863e6978ac9cd91d10bdc" translate="yes" xml:space="preserve">
          <source>Why would you want a hash of lists? Let's take a simple example: You have a file of city and country names, like this:</source>
          <target state="translated">なぜリストのハッシュが欲しいのか?簡単な例を見てみましょう。あなたはこのような都市名と国名のファイルを持っています。</target>
        </trans-unit>
        <trans-unit id="7f3771c096b7c324730a1a8a01295eb54a206ffa" translate="yes" xml:space="preserve">
          <source>Why, you may ask, would you need a chunk of memory containing some values in binary representation? One good reason is input and output accessing some file, a device, or a network connection, whereby this binary representation is either forced on you or will give you some benefit in processing. Another cause is passing data to some system call that is not available as a Perl function: &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; requires you to provide parameters stored in the way it happens in a C program. Even text processing (as shown in the next section) may be simplified with judicious usage of these two functions.</source>
          <target state="translated">なぜあなたは尋ねるかもしれません、バイナリ表現のいくつかの値を含むメモリのチャンクが必要なのでしょうか？適切な理由の1つは、入出力が何らかのファイル、デバイス、またはネットワーク接続にアクセスすることです。これにより、このバイナリ表現は強制されるか、処理に何らかの利点をもたらします。もう1つの原因は、Perl関数として使用できないシステムコールにデータを渡すことです &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; では、Cプログラムで発生する方法で格納されたパラメーターを提供する必要があります。これらの2つの関数を適切に使用することで、テキスト処理（次のセクションに示す）も簡略化できます。</target>
        </trans-unit>
        <trans-unit id="d1b95af46a7dc5483f3c0502e26f80b536b33809" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;can&lt;/code&gt; returns a coderef to mean &quot;yes it can (and the method is this...)&quot;, and then &lt;code&gt;ok&lt;/code&gt; sees a coderef and thinks you're passing a function that you want it to call and consider the truth of the result of! I.e., just like:</source>
          <target state="translated">どうして？ので &lt;code&gt;can&lt;/code&gt; 意味するようにコードリファレンスを返します。「はい、それはすることができます（この方法はこれです...）」、次に &lt;code&gt;ok&lt;/code&gt; コードリファレンスを見て、あなたはそれが結果の真実を呼び出すと考えたいという関数を渡していると考えての！つまり、次のように：</target>
        </trans-unit>
        <trans-unit id="c682a5bde8a3f0f1d13f9a9af66f849014ab6208" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;nasty_break()&lt;/code&gt; modifies &lt;code&gt;$\&lt;/code&gt; without localizing it first. The value you set in &lt;code&gt;nasty_break()&lt;/code&gt; is still there when you return. The fix is to add &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; so the value doesn't leak out of &lt;code&gt;nasty_break()&lt;/code&gt; :</source>
          <target state="translated">どうして？ &lt;code&gt;nasty_break()&lt;/code&gt; は、最初にローカライズせずに &lt;code&gt;$\&lt;/code&gt; を変更するためです。 &lt;code&gt;nasty_break()&lt;/code&gt; で設定した値は、戻ったときも残っています。修正は、値が &lt;code&gt;nasty_break()&lt;/code&gt; からリークしないように &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; を追加することです。</target>
        </trans-unit>
        <trans-unit id="59af40d4a351e635fdbe369d7b681d20a590a23a" translate="yes" xml:space="preserve">
          <source>Wildcard expansion</source>
          <target state="translated">ワイルドカード拡張</target>
        </trans-unit>
        <trans-unit id="70477b387f14e0143de5873f3a9e791508ea1046" translate="yes" xml:space="preserve">
          <source>Will My Old Scripts Break?</source>
          <target state="translated">古いスクリプトは壊れますか?</target>
        </trans-unit>
        <trans-unit id="2758b8d4c9377404295cf137b65b7a19678f3231" translate="yes" xml:space="preserve">
          <source>Will add a file to the in-memory archive, with name &lt;code&gt;$filename&lt;/code&gt; and content &lt;code&gt;$data&lt;/code&gt; . Specific properties can be set using &lt;code&gt;$opthashref&lt;/code&gt; . The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type. (On MacOS, the file's path and modification times are converted to Unix equivalents.)</source>
          <target state="translated">名前が &lt;code&gt;$filename&lt;/code&gt; でコンテンツが &lt;code&gt;$data&lt;/code&gt; ファイルをメモリ内アーカイブに追加します。 &lt;code&gt;$opthashref&lt;/code&gt; を使用して特定のプロパティを設定できます。プロパティの次のリストがサポートされています：名前、サイズ、mtime（最終更新日）、モード、uid、gid、linkname、uname、gname、devmajor、devminor、プレフィックス、タイプ。（MacOSでは、ファイルのパスと変更時刻はUnixの同等のものに変換されます。）</target>
        </trans-unit>
        <trans-unit id="af66cccfd8aea183b531eebc0a74a7e923052ebf" translate="yes" xml:space="preserve">
          <source>Will be called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens. (See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; が発生すると呼び出されます。（以下&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;のuntie Gotchaを&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="5c123e132f25bf178be9ea2aca72fafe2969081c" translate="yes" xml:space="preserve">
          <source>Will be loaded on demand and called automatically by BigInt.</source>
          <target state="translated">必要に応じてロードされ、BigIntによって自動的に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a669aaf9a433f6903c152ca38a90c9c7cb258f3e" translate="yes" xml:space="preserve">
          <source>Will be prepended to each install path.</source>
          <target state="translated">各インストールパスの前に付加されます。</target>
        </trans-unit>
        <trans-unit id="9f18d29650d7b716edb7780278b512b0a8a59170" translate="yes" xml:space="preserve">
          <source>Will be used to modify the padding applied to string as described above.</source>
          <target state="translated">上記のように文字列に適用されるパディングを変更するために使用されます。</target>
        </trans-unit>
        <trans-unit id="a659ce6bd28efeb251560042f49a1924dca7c4a4" translate="yes" xml:space="preserve">
          <source>Will both leave the sentence as is. Normally, when accepting literal string input from the user, quotemeta() or &lt;code&gt;\Q&lt;/code&gt; must be used.</source>
          <target state="translated">どちらもそのまま文を残します。通常、ユーザーからリテラル文字列入力を受け入れる場合は、quotemeta（）または &lt;code&gt;\Q&lt;/code&gt; 使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="10fbb1ac2af71320cfd2110a94f422695cba5311" translate="yes" xml:space="preserve">
          <source>Will cause &lt;code&gt;$sentence&lt;/code&gt; to become &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; .</source>
          <target state="translated">原因となります &lt;code&gt;$sentence&lt;/code&gt; になることを &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66fbedfbffb0f55bc116220f01908ca58f12e965" translate="yes" xml:space="preserve">
          <source>Will croak() if there is an error.</source>
          <target state="translated">エラーが発生した場合は croak()を実行します。</target>
        </trans-unit>
        <trans-unit id="a89e6d7112dafb5b2ad3a46406c0ced36b7d13b7" translate="yes" xml:space="preserve">
          <source>Will die() if called on r-magic.</source>
          <target state="translated">r-magic で呼び出された場合は die()します。</target>
        </trans-unit>
        <trans-unit id="0768298b9a0627e90df27324883d97a236031b2a" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Handy for things like...</source>
          <target state="translated">リファレンスの内容を人間が読める形式でダンプします。以下のような場合に便利です。</target>
        </trans-unit>
        <trans-unit id="481a8de568a61f103c3af4da9f82b1f103a46712" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Usually you want to pass this into &lt;code&gt;note&lt;/code&gt; or &lt;code&gt;diag&lt;/code&gt; .</source>
          <target state="translated">参照の内容を人間が読める形式でダンプします。通常、これを &lt;code&gt;note&lt;/code&gt; または &lt;code&gt;diag&lt;/code&gt; に渡します。</target>
        </trans-unit>
        <trans-unit id="75f83221407c4472808dc0bb2139500f5229338d" translate="yes" xml:space="preserve">
          <source>Will force the generation of test code that uses the older &lt;code&gt;Test&lt;/code&gt; module.</source>
          <target state="translated">古い &lt;code&gt;Test&lt;/code&gt; モジュールを使用するテストコードを強制的に生成します。</target>
        </trans-unit>
        <trans-unit id="a329a554ce0cef11ca3198cc6cf9ba23c8d4f77f" translate="yes" xml:space="preserve">
          <source>Will incorrectly print</source>
          <target state="translated">不正確に印刷されます</target>
        </trans-unit>
        <trans-unit id="c610d24bbac520a7e0e174e12fe1f23a3ae5f9e4" translate="yes" xml:space="preserve">
          <source>Will make sure that =head1 will become &amp;lt;h3&amp;gt; and =head2 will become &amp;lt;h4&amp;gt; etc...</source>
          <target state="translated">= head1が&amp;lt;h3&amp;gt;になり、= head2が&amp;lt;h4&amp;gt;になることを確認します...</target>
        </trans-unit>
        <trans-unit id="49024b4120de3dd67c62575e0a4eb5f193ed6c22" translate="yes" xml:space="preserve">
          <source>Will not cause &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; to re-read the directory stream. The entries already read before the &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; call will just be returned again from a cache buffer. (Win32)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; がディレクトリストリームを再度読み取ることはありません。 &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; 呼び出しの前にすでに読み込まれたエントリは、キャッシュバッファから再び返されるだけです。（Win32）</target>
        </trans-unit>
        <trans-unit id="aff13c5ad9d691f5f29f20db0a92fc55a16499de" translate="yes" xml:space="preserve">
          <source>Will not work on platforms that do not support the C test for sticky bit.</source>
          <target state="translated">スティッキービットのCテストをサポートしていないプラットフォームでは動作しません。</target>
        </trans-unit>
        <trans-unit id="19ad79cf64559535aa01bc2039517ce48ed1f305" translate="yes" xml:space="preserve">
          <source>Will output 2, not 1. This is particularly important if you intend to compile the definitions with the &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator, and later interpolate them in another pattern.</source>
          <target state="translated">1ではなく2を出力します。これは、 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 演算子を使用して定義をコンパイルし、後で別のパターンで補間する場合に特に重要です。</target>
        </trans-unit>
        <trans-unit id="10021ccb8e306fb831263dee40b8f7ca24084b5a" translate="yes" xml:space="preserve">
          <source>Will prevent the automatic use of INSTALL.SKIP as the install skip file.</source>
          <target state="translated">インストールスキップファイルとして INSTALL.SKIP が自動的に使用されないようにします。</target>
        </trans-unit>
        <trans-unit id="897aeeccb9736732e15f96f20d971e76dcd3a8ff" translate="yes" xml:space="preserve">
          <source>Will print &lt;code&gt;2&lt;/code&gt; , because &lt;code&gt;$string&lt;/code&gt; is upgraded as UTF-8. Without &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding 'utf8';&lt;/code&gt; , it will print &lt;code&gt;4&lt;/code&gt; instead, since &lt;code&gt;$string&lt;/code&gt; is three octets when interpreted as Latin-1.</source>
          <target state="translated">印刷される &lt;code&gt;2&lt;/code&gt; をするので、 &lt;code&gt;$string&lt;/code&gt; UTF-8としてアップグレードされます。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding 'utf8';&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用し&lt;/a&gt;ない場合 ; 、Latin-1として解釈される場合、 &lt;code&gt;$string&lt;/code&gt; は3オクテットであるため、代わりに &lt;code&gt;4&lt;/code&gt; を出力します。</target>
        </trans-unit>
        <trans-unit id="f950740e9c08c94cdc9c22017e9c8d9e11964004" translate="yes" xml:space="preserve">
          <source>Will produce something like this:</source>
          <target state="translated">このようなものができあがります。</target>
        </trans-unit>
        <trans-unit id="db8fa98164c98267f0158f423a3da70d388112fe" translate="yes" xml:space="preserve">
          <source>Will use &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Harness::Archive&quot;&gt;TAP::Harness::Archive&lt;/a&gt; as the harness class, and save the TAP to &lt;code&gt;file.tgz&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Harness::Archive&quot;&gt;TAP :: Harness :: Archive&lt;/a&gt;をハーネスクラスとして使用し、TAPを &lt;code&gt;file.tgz&lt;/code&gt; に保存します。</target>
        </trans-unit>
        <trans-unit id="d2fdadddae42eb18256ba3d6c7445968142a4fd2" translate="yes" xml:space="preserve">
          <source>Win32 CORE function stubs</source>
          <target state="translated">Win32 コア関数のスタブ</target>
        </trans-unit>
        <trans-unit id="0cab5c56f7d1ce7bc278eb6ee5c4a8575346a7ef" translate="yes" xml:space="preserve">
          <source>Win32 implementation</source>
          <target state="translated">ウィン32実装</target>
        </trans-unit>
        <trans-unit id="c331f9a552ce93a52bd3bbd4fbac9c58a662301b" translate="yes" xml:space="preserve">
          <source>Win32 support for Sys::Syslog</source>
          <target state="translated">Sys::Syslog の Win32 サポート</target>
        </trans-unit>
        <trans-unit id="263a800b140dc4fe3448979f4261e583bcee830e" translate="yes" xml:space="preserve">
          <source>Win32 users should use the real slash. If you really want to use backslashes, consider using Sarathy's File::DosGlob, which comes with the standard Perl distribution.</source>
          <target state="translated">Win32ユーザは本当のスラッシュを使うべきです。本当にバックスラッシュを使いたいのであれば、標準の Perl ディストリビューションに付属している Sarathy の File::DosGlob の使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="a64d38eb25949cf47b772e208780c5548dc84962" translate="yes" xml:space="preserve">
          <source>Win95 and Win98 and WinME are collectively Win9x and Win32</source>
          <target state="translated">Win95、Win98、WinMEは、総称してWin9xとWin32です。</target>
        </trans-unit>
        <trans-unit id="38d123584917edd3d65a1c41ab99a9088beb8b64" translate="yes" xml:space="preserve">
          <source>Win98 chokes on things like Encode if we set the max length to nmake's max of 2K. So we go for a more conservative value of 1K.</source>
          <target state="translated">Win98では、nmakeの最大長を2Kに設定するとEncodeのようなものが窒息してしまいます。そこで、より保守的な1Kの値にしています。</target>
        </trans-unit>
        <trans-unit id="dcb6e2235a0d088883e2901a983ef0e7377f83c0" translate="yes" xml:space="preserve">
          <source>Win9x can not &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; an open file (although WinNT can).</source>
          <target state="translated">Win9xは開いているファイルの &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; ことはできません（ WinNTはできます）。</target>
        </trans-unit>
        <trans-unit id="1865487f835d74c1a32dc51f7e3fd10d2bb1c87c" translate="yes" xml:space="preserve">
          <source>Win9x does not correctly report &lt;code&gt;EOF&lt;/code&gt; with a non-blocking read on a closed pipe. You will see the following messages:</source>
          <target state="translated">Win9xは、閉じたパイプでの非ブロッキング読み取りで &lt;code&gt;EOF&lt;/code&gt; を正しく報告しません。次のメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="468c4f1d38914eeba7915aa856cfac9060a7a5fe" translate="yes" xml:space="preserve">
          <source>Win9x support was added in 5.6 (Benjamin Stuhl).</source>
          <target state="translated">5.6(Benjamin Stuhl)でWin9xのサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="bf4f5bc6b10d099fc4024cb19c3bd9cf757e522e" translate="yes" xml:space="preserve">
          <source>Windows .NET Server supports the LLP64 data model on the Intel Itanium architecture.</source>
          <target state="translated">Windows .NET Serverは、Intel Itaniumアーキテクチャ上のLLP64データモデルをサポートしています。</target>
        </trans-unit>
        <trans-unit id="6578fbd48a0229e823dac38105b1950bd25957b3" translate="yes" xml:space="preserve">
          <source>Windows Event Log, &lt;a href=&quot;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&lt;/a&gt;</source>
          <target state="translated">Windowsイベントログ、&lt;a href=&quot;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http：//msdn.microsoft.com/library/default.asp？url = / library / en-us / wes / wes / windows_event_log.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32384d85bc892c2cec1cd8f151b8007b98fa13ff" translate="yes" xml:space="preserve">
          <source>Windows is Win32.</source>
          <target state="translated">WindowsはWin32です。</target>
        </trans-unit>
        <trans-unit id="15932d7727c0d0850847ee4a3aea588d05fd6a45" translate="yes" xml:space="preserve">
          <source>Windows is Windows telnet, Cygwin SSH is the OpenSSH implementation under Cygwin on Windows NT, and Mac Terminal is the Terminal application in Mac OS X. Where the entry is other than yes or no, that emulator displays the given attribute as something else instead. Note that on an aixterm, clear doesn't reset colors; you have to explicitly set the colors back to what you want. More entries in this table are welcome.</source>
          <target state="translated">Windows は Windows telnet、Cygwin SSH は Windows NT 上の Cygwin の OpenSSH 実装、Mac Terminal は Mac OS X の Terminal アプリケーションです。エントリが yes か no 以外の場合、そのエミュレータは指定された属性を他のものとして表示します。aixtermでは、clearは色をリセットしないことに注意してください。この表の他のエントリを歓迎します。</target>
        </trans-unit>
        <trans-unit id="3093bbeb765cee856b62debb98821ba39f27fcc6" translate="yes" xml:space="preserve">
          <source>Windows users who are using &lt;code&gt;nmake&lt;/code&gt; should note that due to a bug in &lt;code&gt;nmake&lt;/code&gt; , when specifying &lt;code&gt;TEST_FILES&lt;/code&gt; you must use back-slashes instead of forward-slashes.</source>
          <target state="translated">使用しているWindowsユーザー &lt;code&gt;nmake&lt;/code&gt; 原因のバグにいることに注意してください &lt;code&gt;nmake&lt;/code&gt; を指定する際に、 &lt;code&gt;TEST_FILES&lt;/code&gt; をあなたはバックスラッシュの代わりに、フォワードスラッシュを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="968c4aaba72bd2883444cce7386789debafb547b" translate="yes" xml:space="preserve">
          <source>Windows-specific tests.</source>
          <target state="translated">Windowsに特化したテスト。</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="a51957fd22adb3afd697fb8ab328d3922f130d4b" translate="yes" xml:space="preserve">
          <source>With $k chosen carefully, and likely to be a small number like 1 or 2. In theory the larger the bucket array the less chance of collision.</source>
          <target state="translated">kは慎重に選ばれ、1や2のような小さな数になる可能性があります。理論的には、バケット配列が大きくなるほど衝突の可能性は低くなります。</target>
        </trans-unit>
        <trans-unit id="6185bdea28758a42fc320398e067ab2654617d96" translate="yes" xml:space="preserve">
          <source>With 5005threads, you could also &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; a sub such that any calls to that sub from another thread would block until the lock was released.</source>
          <target state="translated">5005 スレッドでは、別のスレッドからのそのサブルーチンへの呼び出しがロックが解放されるまでブロックされるように、サブルーチンを &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; することもできます。</target>
        </trans-unit>
        <trans-unit id="c2c741524004c7f8613fe0df95f2304ad27bfaf6" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;/a&lt;/code&gt; , one can write &lt;code&gt;\d&lt;/code&gt; with confidence that it will only match ASCII characters, and should the need arise to match beyond ASCII, you can instead use &lt;code&gt;\p{Digit}&lt;/code&gt; (or &lt;code&gt;\p{Word}&lt;/code&gt; for &lt;code&gt;\w&lt;/code&gt; ). There are similar &lt;code&gt;\p{...}&lt;/code&gt; constructs that can match beyond ASCII both white space (see &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;Whitespace in perlrecharclass&lt;/a&gt;), and Posix classes (see &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;). Thus, this modifier doesn't mean you can't use Unicode, it means that to get Unicode matching you must explicitly use a construct (&lt;code&gt;\p{}&lt;/code&gt; , &lt;code&gt;\P{}&lt;/code&gt; ) that signals Unicode.</source>
          <target state="translated">&lt;code&gt;/a&lt;/code&gt; 、1を書くことができます &lt;code&gt;\d&lt;/code&gt; あなたの代わりに使用することができ、それはASCII文字のみと一致することを自信を持って、そしてASCIIを超えて一致させるために発生する必要がある場合 &lt;code&gt;\p{Digit}&lt;/code&gt; （または &lt;code&gt;\p{Word}&lt;/code&gt; のために &lt;code&gt;\w&lt;/code&gt; ）。&lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;空白（perlrecharclassのWhitespaceを参照&lt;/a&gt;）とPosixクラス（&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclassのPOSIX文字クラスを&lt;/a&gt;参照）の両方でASCIIを超えて一致できる同様の &lt;code&gt;\p{...}&lt;/code&gt; 構成があります。したがって、この修飾子は、Unicodeを使用できないことを意味しません。つまり、Unicodeマッチングを取得するには、Unicodeを通知する構成（ &lt;code&gt;\p{}&lt;/code&gt; 、 &lt;code&gt;\P{}&lt;/code&gt; ）を明示的に使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="5132b5fe6c695f29613169cf8ff9a2c949197d0f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, you get around this by using a block and an expression where you would place the filehandle:</source>
          <target state="translated">で &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; して &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; の、あなたはブロックし、ファイルハンドルを置くだろう表現を使用することによってこの問題を回避します：</target>
        </trans-unit>
        <trans-unit id="487baf6c93470e20c12688608403c20fbdb8e8f3" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;, both STDOUT and STDERR will go the same place as the script's STDOUT and STDERR, unless the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; command redirects them. Backticks and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; read &lt;b&gt;only&lt;/b&gt; the STDOUT of your command.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; しない限り、STDOUTとSTDERRの両方が、スクリプトのSTDOUTとSTDERRと同じ場所に行く &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; コマンドはそれらをリダイレクトします。バックティックと &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; は、コマンドのSTDOUT &lt;b&gt;のみを&lt;/b&gt;読み取ります。</target>
        </trans-unit>
        <trans-unit id="e6ba4c518cc989a85f1859e34fe5315e0670671f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Class::Tiny&lt;/code&gt; , all accessors are read-write. It generates a constructor for you, as well as the accessors you define.</source>
          <target state="translated">&lt;code&gt;Class::Tiny&lt;/code&gt; 、すべてのアクセサは読み書きをしています。コンストラクタと、定義したアクセサを生成します。</target>
        </trans-unit>
        <trans-unit id="c6b55e3069c1cf271c20c8804a7b8c0dbfbb1f17" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ignore_case&lt;/code&gt; , option specifications for options that only differ in case, e.g., &lt;code&gt;&quot;foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; , will be flagged as duplicates.</source>
          <target state="translated">&lt;code&gt;ignore_case&lt;/code&gt; 、大文字と小文字の区別だけが異なるオプションのためのオプション仕様は、例えば、 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; および &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; 、重複としてフラグが設定されます。</target>
        </trans-unit>
        <trans-unit id="ee71de233ae712db3a62ad0a5f3c845bcb07690d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;pass_through&lt;/code&gt; anything that is unknown, ambiguous or supplied with an invalid option will not be flagged as an error. Instead the unknown option(s) will be passed to the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present, otherwise through to &lt;code&gt;@ARGV&lt;/code&gt; . This makes it possible to write wrapper scripts that process only part of the user supplied command line arguments, and pass the remaining options to some other program.</source>
          <target state="translated">&lt;code&gt;pass_through&lt;/code&gt; 不明であるもの、あいまいなまたは無効なオプションに付属のはエラーとしてフラグ付けされることはありません。代わりに、未知のオプション（複数可）に渡されますキャッチオール &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; もし存在するならば、そうでない場合に通じ &lt;code&gt;@ARGV&lt;/code&gt; 。これにより、ユーザーが指定したコマンドライン引数の一部のみを処理するラッパースクリプトを記述し、残りのオプションを他のプログラムに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="fb95ac886e1d528b24773e6c70b3ed1c1613335e" translate="yes" xml:space="preserve">
          <source>With EXPR, it returns some extra information that the debugger uses to print a stack trace. The value of EXPR indicates how many call frames to go back before the current one.</source>
          <target state="translated">EXPR を使用すると、デバッガがスタックトレースを表示するために使用する追加情報を返します。EXPR の値は、現在のコールフレームの前に何個のコールフレームを遡るかを示します。</target>
        </trans-unit>
        <trans-unit id="a55096d08b5ad2fe54fd898185c93fb2c1c7dfdd" translate="yes" xml:space="preserve">
          <source>With Mac OS X 10.4 &quot;Tiger&quot; and newer, there is almost no performance penalty for non-prebound libraries. Earlier releases will suffer a greater load time than either the static library, or Apple's pre-bound dynamic library.</source>
          <target state="translated">Mac OS X 10.4 &quot;Tiger &quot;以降では、プリバウンドしていないライブラリのパフォーマンスペナルティはほとんどありません。それ以前のリリースでは、静的ライブラリやAppleのプリバウンドされた動的ライブラリのいずれかよりも大きなロードタイムに悩まされることになります。</target>
        </trans-unit>
        <trans-unit id="5f9d3d0136d8a2d2276cb1a4c4f0bb0c82be3696" translate="yes" xml:space="preserve">
          <source>With NTFS (and no CYGWIN=nontsec), there should be no problems even if perl was built on FAT.</source>
          <target state="translated">NTFS(しかもCYGWIN=nontsecではない)であれば、perlがFAT上に構築されていても問題ないはずです。</target>
        </trans-unit>
        <trans-unit id="783aaaca75cc72bad41475003df821affc75b7c5" translate="yes" xml:space="preserve">
          <source>With OO style, you can break the message arbitrarily. This means that we are no longer limited to have space for the whole message in memory, i.e. we can handle messages of any size.</source>
          <target state="translated">OO スタイルでは、メッセージを任意に分割することができます。これは、メモリ上にメッセージ全体のためのスペースを持つことに制限されなくなったことを意味します。</target>
        </trans-unit>
        <trans-unit id="c1bf2f77022cd9fed463a5704b297d6ff88b00d5" translate="yes" xml:space="preserve">
          <source>With Perl 5.004 you can also use the TIEHANDLE interface to access compressed files just like ordinary files:</source>
          <target state="translated">Perl 5.004では、TIEHANDLEインターフェイスを使用して、通常のファイルのように圧縮ファイルにアクセスすることもできます。</target>
        </trans-unit>
        <trans-unit id="9f110b40627d54799c1a5b4c023b449d3f05b59d" translate="yes" xml:space="preserve">
          <source>With Perl 5.10 and later, the smart match operator can give you the answer with the least amount of work:</source>
          <target state="translated">Perl 5.10以降では、スマートマッチ演算子を使用することで、最小限の作業で答えを出すことができます。</target>
        </trans-unit>
        <trans-unit id="4e55c608e124b42bf25bf02c154381796e1d9852" translate="yes" xml:space="preserve">
          <source>With a</source>
          <target state="translated">を使って</target>
        </trans-unit>
        <trans-unit id="f458d9e5c6b401d23a0ff93a93cac73ffa40d782" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;, &lt;code&gt;charscript()&lt;/code&gt; returns the</source>
          <target state="translated">&lt;a href=&quot;#code-point-argument&quot;&gt;コードポイント引数&lt;/a&gt;、 &lt;code&gt;charscript()&lt;/code&gt; リターン</target>
        </trans-unit>
        <trans-unit id="7cfd816e3af239ee8e3392fa5dd4b28e10c2cbf9" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;&lt;code&gt;charblock()&lt;/code&gt; returns the</source>
          <target state="translated">&lt;a href=&quot;#code-point-argument&quot;&gt;コードポイント引数&lt;/a&gt; &lt;code&gt;charblock()&lt;/code&gt; リターン</target>
        </trans-unit>
        <trans-unit id="cc06a9c18caf674053e4b44b132356a1c540f757" translate="yes" xml:space="preserve">
          <source>With a little extra work, you can get all of the groups in angle brackets even if they are in other angle brackets too. Each time you get a balanced match, remove its outer delimiter (that's the one you just matched so don't match it again) and add it to a queue of strings to process. Keep doing that until you get no matches:</source>
          <target state="translated">少し余分な作業をすれば、たとえそれらが他の角括弧に入っていたとしても、すべてのグループを角括弧に入れることができます。バランスのとれたマッチを得るたびに、その外側の区切り文字を削除して (これは今マッチしたものなので二度とマッチしないようにしてください)、それを処理する文字列のキューに追加します。マッチしなくなるまでこれを続けてください。</target>
        </trans-unit>
        <trans-unit id="a69059588956460f70f3f90c71a968d5af85c118" translate="yes" xml:space="preserve">
          <source>With a non-&lt;code&gt;DEBUGGING&lt;/code&gt; perl, the buckets starting from &lt;code&gt;128&lt;/code&gt; have a 4-byte overhead, and thus an 8192-long bucket may take up to 8188-byte allocations.</source>
          <target state="translated">非 &lt;code&gt;DEBUGGING&lt;/code&gt; perlの場合、 &lt;code&gt;128&lt;/code&gt; から始まるバケットには4バイトのオーバーヘッドがあるため、8192の長さのバケットには最大8188バイトの割り当てが必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="3f782793180910fe0c252c5c5e6b40299dd75d89" translate="yes" xml:space="preserve">
          <source>With a slurpy parameter in the signature, there is no upper limit on how many arguments may be passed. A slurpy array parameter may be nameless just like a positional parameter, in which case its only effect is to turn off the argument limit that would otherwise apply:</source>
          <target state="translated">シグネチャにslurpyパラメータがある場合、引数の数に上限はありません。スラーピーな配列パラメータは、位置パラメータのように名前を持たないこともありますが、その場合は引数の制限を無効にするだけです。</target>
        </trans-unit>
        <trans-unit id="f9508f16c80ad6889c699daf40f43720b8251d92" translate="yes" xml:space="preserve">
          <source>With a technique called copy-on-write, the cost of copying with overload could be minimized or even completely avoided. A test implementation of COW did show performance gains for overloaded math, but introduced a performance loss due to a constant overhead for all other operations. So Math::BigInt does currently not COW.</source>
          <target state="translated">コピーオンライトと呼ばれる技術では、オーバーロードでのコピーのコストを最小化したり、完全に回避したりすることができました。COW のテスト実装では、オーバーロードされた数学の性能向上が示されましたが、他のすべての操作のために一定のオーバーヘッドによる性能低下が導入されました。そのため、Math::BigInt は現在のところ COW を行っていません。</target>
        </trans-unit>
        <trans-unit id="0ebe6d7c43f224246d4ca3387c92f6cc94b15954" translate="yes" xml:space="preserve">
          <source>With a todo block, the tests inside are expected to fail. Test::More will run the tests normally, but print out special flags indicating they are &quot;todo&quot;. &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret failures as being ok. Should anything succeed, it will report it as an unexpected success. You then know the thing you had todo is done and can remove the TODO flag.</source>
          <target state="translated">todoブロックを使用すると、内部のテストは失敗することが予想されます。Test :: Moreはテストを通常どおり実行しますが、「todo」であることを示す特別なフラグを出力します。&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt;は失敗を大丈夫と解釈します。何かが成功した場合、予期しない成功として報告されます。これで、todoが実行されたことを確認でき、TODOフラグを削除できます。</target>
        </trans-unit>
        <trans-unit id="2be7163284f82da14a87936dad63fbf983833559" translate="yes" xml:space="preserve">
          <source>With all of the regexes above, if the regex matched anywhere in the string, it was considered a match. To specify</source>
          <target state="translated">上記のすべての正規表現では、その正規表現が文字列のどこかにマッチしていれば、それはマッチしているとみなされます。を指定するには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="a49675e374380fe043aff3a5f63d6512021ecfd9" translate="yes" xml:space="preserve">
          <source>With all of the regexps above, if the regexp matched anywhere in the string, it was considered a match. Sometimes, however, we'd like to specify</source>
          <target state="translated">上記のすべての正規表現では、正規表現が文字列のどこかにマッチした場合、それはマッチしたとみなされます。しかし、時には</target>
        </trans-unit>
        <trans-unit id="544d324c6a361c56f15aa84b4f308989bea67735" translate="yes" xml:space="preserve">
          <source>With an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, you should be especially careful to remember what's being looked at when:</source>
          <target state="translated">では &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; を、あなたは時に見されているものを覚えておくことは特に注意する必要があります：</target>
        </trans-unit>
        <trans-unit id="250cfbca6e5e22d4d573a90cd37797d2cb8d3ac5" translate="yes" xml:space="preserve">
          <source>With an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, you should be especially careful to remember what's being looked at when:</source>
          <target state="translated">では &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; を、あなたは時に見されているものを覚えておくことは特に注意する必要があります：</target>
        </trans-unit>
        <trans-unit id="28933cd0405c565c32304d3c729c7e6f31006ad2" translate="yes" xml:space="preserve">
          <source>With any of these, you can change file descriptors before the call:</source>
          <target state="translated">これらのいずれかを使用すると、呼び出しの前にファイルディスクリプタを変更することができます。</target>
        </trans-unit>
        <trans-unit id="944f492857a1db6c839174233fd1c02f59c056dd" translate="yes" xml:space="preserve">
          <source>With any version of Perl 5 you can use the basic OO interface:</source>
          <target state="translated">Perl 5 のどのバージョンでも、基本的な OO インターフェースを使用することができます。</target>
        </trans-unit>
        <trans-unit id="108bd0cf30895e3a18d32866a5ada0ba72c0b2d2" translate="yes" xml:space="preserve">
          <source>With bundling it is possible to set several single-character options at once. For example if &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; are all valid options,</source>
          <target state="translated">バンドリングを使用すると、複数の単一文字オプションを同時に設定できます。たとえば、 &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;v&lt;/code&gt; 、 &lt;code&gt;x&lt;/code&gt; がすべて有効なオプションである場合、</target>
        </trans-unit>
        <trans-unit id="bf9c20d6876f103320c9d9424556b25f81d7af24" translate="yes" xml:space="preserve">
          <source>With earlier versions of Perl, you have to do a bit more work. If you are going to make this query many times over arbitrary string values, the fastest way is probably to invert the original array and maintain a hash whose keys are the first array's values:</source>
          <target state="translated">以前のバージョンのPerlでは、もう少し作業をしなければなりません。このクエリを任意の文字列の値に対して何度も実行する場合は、元の配列を反転させて、最初の配列の値をキーとするハッシュを保持するのが一番早い方法でしょう。</target>
        </trans-unit>
        <trans-unit id="089c9811008b67cdbb35efdae3d3f3034c15c2b2" translate="yes" xml:space="preserve">
          <source>With excerpts from Perl, and contributions and suggestions from Ronald J. Kimball, Dave Mitchell, Dominic Dunlop, Mark Jason Dominus, Stephen McCamant, and David Landgren.</source>
          <target state="translated">Perl からの抜粋と、Ronald J.Kimball、Dave Mitchell、Dominic Dunlop、Mark Jason Dominus、Stephen McCamant、David Landgren からの寄稿と提案。</target>
        </trans-unit>
        <trans-unit id="312cf396f9e4b4f5d83643b7fda95efc6c88ff9d" translate="yes" xml:space="preserve">
          <source>With hooks comes the ability to recurse back to the Storable engine. Indeed, hooks are regular Perl code, and Storable is convenient when it comes to serializing and deserializing things, so why not use it to handle the serialization string?</source>
          <target state="translated">フックを使うと、Storableエンジンへのリカーシングが可能になります。実際、フックは通常のPerlのコードであり、Storableはシリアライズやデシリアライズを行う際に便利です。</target>
        </trans-unit>
        <trans-unit id="2092bcf7558e6632164a74cbb09d09cc7943a0d7" translate="yes" xml:space="preserve">
          <source>With lots of help and suggestions from Dean Roehrich, Malcolm Beattie, Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer, Stephen McCamant, and Gurusamy Sarathy.</source>
          <target state="translated">Dean Roehrich、Malcolm Beattie、Andreas Koenig、Paul Hudson、Ilya Zakharevich、Paul Marquess、Neil Bowers、Matthew Green、Tim Bunce、Spider Boardman、Ulrich Pfeifer、Stephen McCamant、そしてGurusamy Sarathyからの多くの助けと提案があります。</target>
        </trans-unit>
        <trans-unit id="6a2d0cebca8f8c753e2f714f5c39699038d3b25f" translate="yes" xml:space="preserve">
          <source>With methods 2 and 3, Perl starts parsing the input file from the beginning, unless you've specified a &lt;b&gt;-x&lt;/b&gt; switch, in which case it scans for the first line starting with &lt;code&gt;#!&lt;/code&gt; and containing the word &quot;perl&quot;, and starts there instead. This is useful for running a program embedded in a larger message. (In this case you would indicate the end of the program using the &lt;code&gt;__END__&lt;/code&gt; token.)</source>
          <target state="translated">方法2および3では、&lt;b&gt;-x&lt;/b&gt;スイッチを指定しない限り、Perlは入力ファイルの最初から解析を開始します。&lt;b&gt;-x&lt;/b&gt;スイッチを指定した場合は、 &lt;code&gt;#!&lt;/code&gt; で始まる最初の行をスキャンします。「perl」という単語を含み、代わりにそこから始まります。これは、より大きなメッセージに埋め込まれたプログラムを実行するのに役立ちます。（この場合、 &lt;code&gt;__END__&lt;/code&gt; トークンを使用してプログラムの終了を示します。）</target>
        </trans-unit>
        <trans-unit id="6316d5824ca52c312f770e770e783e4a6d5033d6" translate="yes" xml:space="preserve">
          <source>With mod_perl and the Apache::Registry module (distributed with mod_perl), httpd will run with an embedded Perl interpreter which pre-compiles your script and then executes it within the same address space without forking. The Apache extension also gives Perl access to the internal server API, so modules written in Perl can do just about anything a module written in C can. For more on mod_perl, see &lt;a href=&quot;http://perl.apache.org/&quot;&gt;http://perl.apache.org/&lt;/a&gt;</source>
          <target state="translated">mod_perlとApache :: Registryモジュール（mod_perlで配布）を使用すると、httpdはスクリプトをプリコンパイルし、フォークせずに同じアドレススペース内で実行する埋め込みPerlインタープリターで実行されます。また、Apache拡張機能はPerlに内部サーバーAPIへのアクセスを提供するため、Perlで作成されたモジュールは、Cで作成されたモジュールが実行できるほぼすべてのことを実行できます。mod_perlの詳細については、&lt;a href=&quot;http://perl.apache.org/&quot;&gt;http：&lt;/a&gt; //perl.apache.org/を参照してください。</target>
        </trans-unit>
        <trans-unit id="cc2eb3f9b78400953fa9a4ff9c87b68e20c7b681" translate="yes" xml:space="preserve">
          <source>With much assistance regarding shared libraries from Marc Sabatella.</source>
          <target state="translated">Marc Sabatella氏から共有ライブラリに関する多くの支援をいただきました。</target>
        </trans-unit>
        <trans-unit id="b462e2e8ccefffa9756bd47bbfa7c723db9b9b54" translate="yes" xml:space="preserve">
          <source>With negative offsets, it remembers its position from the end of the string when the target string is modified:</source>
          <target state="translated">負のオフセットでは、対象の文字列が変更されたときに、文字列の末尾からの位置を記憶します。</target>
        </trans-unit>
        <trans-unit id="00344cc849fc9376fff9de99085e79fa3cd552d0" translate="yes" xml:space="preserve">
          <source>With no MASK argument present, it returns the current operator mask of the compartment.</source>
          <target state="translated">MASK 引数がない場合、コンパートメントの現在の演算子マスクを返します。</target>
        </trans-unit>
        <trans-unit id="a35650496b577c95afdac0e1ebb0191fd46fd2e0" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole array (whether or not the element was specified as &lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt; ).</source>
          <target state="translated">引数がない場合、アクセサーは要素の配列全体への参照を返します（要素が &lt;code&gt;'@'&lt;/code&gt; または &lt;code&gt;'*@'&lt;/code&gt; として指定されているかどうかに関係なく）。</target>
        </trans-unit>
        <trans-unit id="3a4963e3a2e84181fb9a499ef49896fdab34cd7c" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole hash (whether or not the element was specified as &lt;code&gt;'%'&lt;/code&gt; or &lt;code&gt;'*%'&lt;/code&gt; ).</source>
          <target state="translated">引数がない場合、アクセサは要素のハッシュ全体への参照を返します（要素が &lt;code&gt;'%'&lt;/code&gt; または &lt;code&gt;'*%'&lt;/code&gt; として指定されているかどうかは関係ありません）。</target>
        </trans-unit>
        <trans-unit id="6bae0e18d43bcb818e56d07261a055232eff0bf8" translate="yes" xml:space="preserve">
          <source>With no arguments (or using &lt;code&gt;threads::all&lt;/code&gt; ) and in a list context, returns a list of all non-joined, non-detached</source>
          <target state="translated">引数なしで（または &lt;code&gt;threads::all&lt;/code&gt; を使用して）リストコンテキストで、結合されていない、分離されていないすべてのリストを返します。</target>
        </trans-unit>
        <trans-unit id="d4cfb999178855ab18f46ce9c518e1bd1ef50096" translate="yes" xml:space="preserve">
          <source>With older versions of Perl, the &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO::String&lt;/a&gt; module provides similar functionality.</source>
          <target state="translated">古いバージョンのPerlでは、&lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO :: String&lt;/a&gt;モジュールが同様の機能を提供します。</target>
        </trans-unit>
        <trans-unit id="c467eeeb4f15846c2e3c26d1b4d74776d4da75d4" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is a key specifying one element of the hash; the second argument, if present, is assigned to the hash element. If the element type is &lt;code&gt;'%'&lt;/code&gt; , the accessor returns the hash element value. If the element type is &lt;code&gt;'*%'&lt;/code&gt; , a reference to the hash element is returned.</source>
          <target state="translated">1つまたは2つの引数がある場合、最初の引数はハッシュの1つの要素を指定するキーです。2番目の引数が存在する場合は、ハッシュ要素に割り当てられます。要素タイプが &lt;code&gt;'%'&lt;/code&gt; の場合、アクセサはハッシュ要素値を返します。要素タイプが &lt;code&gt;'*%'&lt;/code&gt; の場合、ハッシュ要素への参照が返されます。</target>
        </trans-unit>
        <trans-unit id="043fe821df73a58116e971eada4906da49321cca" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is an index specifying one element of the array; the second argument, if present, is assigned to the array element. If the element type is &lt;code&gt;'@'&lt;/code&gt; , the accessor returns the array element value. If the element type is &lt;code&gt;'*@'&lt;/code&gt; , a reference to the array element is returned.</source>
          <target state="translated">1つまたは2つの引数がある場合、最初の引数は配列の1つの要素を指定するインデックスです。2番目の引数が存在する場合は、配列要素に割り当てられます。要素タイプが &lt;code&gt;'@'&lt;/code&gt; の場合、アクセサは配列要素の値を返します。要素タイプが &lt;code&gt;'*@'&lt;/code&gt; の場合、配列要素への参照が返されます。</target>
        </trans-unit>
        <trans-unit id="d82587a9e3d9d950371c40dd7e06719bffb84440" translate="yes" xml:space="preserve">
          <source>With option -exec, walks tree in execute order, otherwise in basic order.</source>
          <target state="translated">オプション -exec を指定すると、ツリーを実行順に歩き、そうでない場合は基本順に歩きます。</target>
        </trans-unit>
        <trans-unit id="57d705a8d20354296c55ade02ce168e9aba3ea9c" translate="yes" xml:space="preserve">
          <source>With overloaded math, only the first two variants will result in a BigFloat:</source>
          <target state="translated">オーバーロードされた数学では、最初の2つのバリアントだけがBigFloatになります。</target>
        </trans-unit>
        <trans-unit id="549d9ba8c522ce4226592827b058814ec17aafc9" translate="yes" xml:space="preserve">
          <source>With respect to character matching, there are a few more points you need to know about. First of all, not all characters can be used 'as is' in a match. Some characters, called</source>
          <target state="translated">文字のマッチングに関しては、もう少し知っておくべきポイントがあります。まず第一に、すべての文字がマッチで「そのまま」使用できるわけではありません。と呼ばれる一部の文字は</target>
        </trans-unit>
        <trans-unit id="f52704b066745f4539042b4ca42ac5911b1eae8e" translate="yes" xml:space="preserve">
          <source>With respect to files, one that has the proper permission bit set to let you access the file. With respect to computer programs, one that&amp;rsquo;s written well enough that someone has a chance of figuring out what it&amp;rsquo;s trying to do.</source>
          <target state="translated">ファイルに関しては、ファイルにアクセスできるように適切な許可ビットが設定されているファイル。コンピュータプログラムに関しては、誰かがそれが何をしようとしているのかを理解する可能性があるほど十分に書かれているもの。</target>
        </trans-unit>
        <trans-unit id="3dc4eefad3d29ef780cb07bfc36df49d416959b4" translate="yes" xml:space="preserve">
          <source>With respect to loading &lt;code&gt;Exporter&lt;/code&gt; and inheriting, there are alternatives with the use of modules like &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;parent&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Exporter&lt;/code&gt; ロードと継承に関しては、 &lt;code&gt;base&lt;/code&gt; や &lt;code&gt;parent&lt;/code&gt; などのモジュールを使用する代替手段があります。</target>
        </trans-unit>
        <trans-unit id="64aab757411e3efe138dbb9f7787c6359c1eec8b" translate="yes" xml:space="preserve">
          <source>With some firewalls active mode does not work as the server cannot connect to your machine (because you are behind a firewall) and the firewall does not re-write the command. In this case you should set &lt;code&gt;ftp_ext_passive&lt;/code&gt; to a</source>
          <target state="translated">一部のファイアウォールでは、サーバーがマシンに接続できないため（ファイアウォールの内側にいるため）、アクティブモードは機能せず、ファイアウォールはコマンドを再書き込みしません。この場合、 &lt;code&gt;ftp_ext_passive&lt;/code&gt; をaに設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="39e7b288b06e2af98b83632e08ab80e03b9bf7c3" translate="yes" xml:space="preserve">
          <source>With source filters, you can store the text of your script compressed and use a source filter to uncompress it for Perl's parser:</source>
          <target state="translated">ソースフィルタを使うと、スクリプトのテキストを圧縮して保存し、ソースフィルタを使って Perl のパーサ用に圧縮を解除することができます。</target>
        </trans-unit>
        <trans-unit id="f3d0833032fe049783c845044de2a75767e40f62" translate="yes" xml:space="preserve">
          <source>With support for &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; this may be circumvented - unless one of DLLs is started from</source>
          <target state="translated">&lt;code&gt;LIBPATHSTRICT&lt;/code&gt; のサポートにより、これは回避される可能性があります-DLLの 1つが</target>
        </trans-unit>
        <trans-unit id="741296e189dd1627ab6af5dc824e2c81acff153a" translate="yes" xml:space="preserve">
          <source>With that trick MakeMaker will only read the first line and thus read the underscore, while the perl interpreter will evaluate the $VERSION and convert the string into a number. Later operations that treat $VERSION as a number will then be able to do so without provoking a warning about $VERSION not being a number.</source>
          <target state="translated">このトリックを使うと、MakeMaker は最初の行だけを読み込んでアンダースコアを読みますが、Perl インタプリタは $VERSION を評価して文字列を数値に変換します。後になって $VERSION を数値として扱う操作を行っても、$VERSION が数値ではないという警告を表示することなく行うことができるようになります。</target>
        </trans-unit>
        <trans-unit id="fa542340f7199357b9ddb7d211923c323666ef12" translate="yes" xml:space="preserve">
          <source>With the &quot;tcp&quot; protocol the ping() method attempts to establish a connection to the remote host's echo port. If the connection is successfully established, the remote host is considered reachable. No data is actually echoed. This protocol does not require any special privileges but has higher overhead than the &quot;udp&quot; and &quot;icmp&quot; protocols.</source>
          <target state="translated">tcp&quot; プロトコルでは、ping()メソッドはリモートホストの echo ポートへの接続の確立を試みます。接続が確立された場合は、リモートホストに到達可能であるとみなされます。実際にはデータはエコーされません。このプロトコルは特別な権限を必要としませんが、 &quot;udp&quot; や &quot;icmp&quot; プロトコルよりも高いオーバーヘッドを持ちます。</target>
        </trans-unit>
        <trans-unit id="0c9c2cd66698ade01d6241c0c3475076fe41182f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma you can use the &lt;code&gt;:locale&lt;/code&gt; layer</source>
          <target state="translated">では &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; プラグマを使用でき &lt;code&gt;:locale&lt;/code&gt; レイヤーを</target>
        </trans-unit>
        <trans-unit id="e4721b12184df4c626e83aff44b61b424dee2894" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. are immediately available for use in the replacement expression. With the global modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; will search and replace all occurrences of the regex in the string:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 演算子、マッチ変数 &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; などは、置換式ですぐに使用可能です。グローバル修飾子を使用すると、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; は文字列内のすべての正規表現を検索して置換します。</target>
        </trans-unit>
        <trans-unit id="a5f3ac7301bb1927406401553bc7979a7058d48f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma you can control the behaviour of the builtin &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">で &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; プラグマあなたは、組み込み用の動作を制御することができます &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 関数を。</target>
        </trans-unit>
        <trans-unit id="640e6849be58e830210cdb457742bd0e5d46239f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;IN&lt;/code&gt; subpragma you can declare the default layers of input streams, and with the &lt;code&gt;OUT&lt;/code&gt; subpragma you can declare the default layers of output streams. With the &lt;code&gt;IO&lt;/code&gt; subpragma you can control both input and output streams simultaneously.</source>
          <target state="translated">&lt;code&gt;IN&lt;/code&gt; サブプラグマあなたは、入力ストリームのデフォルト層を宣言することができ、かつと &lt;code&gt;OUT&lt;/code&gt; のサブプラグマあなたは、出力ストリームのデフォルト層を宣言することができます。 &lt;code&gt;IO&lt;/code&gt; のサブプラグマあなたは、入力と出力の両方が同時にストリームを制御することができます。</target>
        </trans-unit>
        <trans-unit id="9a9bb48f29cda9ceed93d7949280d0a2ae7a947b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; logical name defined as &quot;ENABLE&quot;, setting &lt;code&gt;$?&lt;/code&gt; will cause the new value to be encoded into &lt;code&gt;$^E&lt;/code&gt; so that either the original parent or child exit status values 0 to 255 can be automatically recovered by C programs expecting _POSIX_EXIT behavior. If both a parent and a child exit value are non-zero, then it will be assumed that this is actually a VMS native status value to be passed through. The special value of 0xFFFF is almost a NOOP as it will cause the current native VMS status in the C library to become the current native Perl VMS status, and is handled this way as it is known to not be a valid native VMS status value. It is recommend that only values in the range of normal Unix parent or child status numbers, 0 to 255 are used.</source>
          <target state="translated">「ENABLE」として定義された &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 論理名を使用して、 &lt;code&gt;$?&lt;/code&gt; 新しい値が &lt;code&gt;$^E&lt;/code&gt; エンコードされるので、元の親または子の終了ステータス値0〜255は、_POSIX_EXIT動作を期待するCプログラムによって自動的に回復できます。親と子の両方の終了値がゼロ以外の場合、これは実際に渡されるVMSネイティブステータス値であると見なされます。 Cライブラリ内の現在のネイティブVMSステータスが現在のネイティブPerl VMSステータスになるため、0xFFFFの特別な値はほぼNOOPであり、有効なネイティブVMSステータス値ではないことがわかっているため、このように処理されます。通常のUnixの親または子のステータス番号の範囲（0〜255）の値のみを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d85c0b58283979a05b1d958cf7b8e77666b21187" translate="yes" xml:space="preserve">
          <source>With the C-style operators that would have been written like this:</source>
          <target state="translated">こんな感じで書かれていたであろうCスタイルの演算子を使うと</target>
        </trans-unit>
        <trans-unit id="12231f536f1fde7f945e73b86c0bb0963f5133af" translate="yes" xml:space="preserve">
          <source>With the FCGI module (from CPAN) and the mod_fastcgi module (available from &lt;a href=&quot;http://www.fastcgi.com/&quot;&gt;http://www.fastcgi.com/&lt;/a&gt; ) each of your Perl programs becomes a permanent CGI daemon process.</source>
          <target state="translated">FCGIモジュール（CPANから）およびmod_fastcgiモジュール（&lt;a href=&quot;http://www.fastcgi.com/&quot;&gt;http://www.fastcgi.com/&lt;/a&gt;から入手可能）を使用すると、Perlプログラムのそれぞれが永続的なCGIデーモンプロセスになります。</target>
        </trans-unit>
        <trans-unit id="e9f0f761b750ef587b104ca22707f7d417110d25" translate="yes" xml:space="preserve">
          <source>With the MASK argument present, it sets the operator mask for the compartment (equivalent to calling the deny_only method).</source>
          <target state="translated">引数MASKが存在する場合、コンパートメントの演算子マスクを設定します(deny_onlyメソッドを呼び出すのと同等です)。</target>
        </trans-unit>
        <trans-unit id="a26ddc37c924b20873cf0fb8deaac6c02f3c0643" translate="yes" xml:space="preserve">
          <source>With the _POSIX_EXIT macro set, the Unix exit value of zero is represented as a VMS native status of 1, and the Unix values from 2 to 255 are encoded by the equation:</source>
          <target state="translated">POSIX_EXIT マクロが設定されている場合、Unix の終了値 0 は VMS ネイティブのステータス 1 として表現され、Unix の値 2 から 255 までの値は式でエンコードされます。</target>
        </trans-unit>
        <trans-unit id="b04e80858e882edcc84d0f324c4fa0f1bc41eaae" translate="yes" xml:space="preserve">
          <source>With the check_sigs parameter you can turn signature checking on and off. The default is off for now because the whole tool chain for the functionality is not yet considered mature by some. The author of CPAN.pm would recommend setting it to true most of the time and turning it off only if it turns out to be annoying.</source>
          <target state="translated">check_sigs パラメータで署名チェックのオンオフを切り替えることができます。機能のためのツールチェーン全体がまだ成熟していないと考える人もいるので、今のところデフォルトはoffです。CPAN.pm の作者はこのパラメータをほとんどの場合 true に設定して、面倒な場合のみ off にすることを推奨しています。</target>
        </trans-unit>
        <trans-unit id="65d6f831578499e9dbe5b97d3e54d9d6970d12d6" translate="yes" xml:space="preserve">
          <source>With the completion of Example 4, we now have an easy way to simulate some real-life libraries whose interfaces may not be the cleanest in the world. We shall now continue with a discussion of the arguments passed to the &lt;b&gt;xsubpp&lt;/b&gt; compiler.</source>
          <target state="translated">例4が完了すると、インターフェイスが世界で最もクリーンではない可能性がある実際のライブラリを簡単にシミュレートできるようになりました。次に、&lt;b&gt;xsubpp&lt;/b&gt;コンパイラーに渡される引数の説明を続けます。</target>
        </trans-unit>
        <trans-unit id="1f205214a6ba2cf07a234149bf2d1460c5296c50" translate="yes" xml:space="preserve">
          <source>With the creation of the &lt;code&gt;IO::Compress&lt;/code&gt; and &lt;code&gt;IO::Uncompress&lt;/code&gt; modules no new features are planned for &lt;code&gt;Compress::Zlib&lt;/code&gt; - the new modules do everything that &lt;code&gt;Compress::Zlib&lt;/code&gt; does and then some. Development on &lt;code&gt;Compress::Zlib&lt;/code&gt; will be limited to bug fixes only.</source>
          <target state="translated">&lt;code&gt;IO::Compress&lt;/code&gt; および &lt;code&gt;IO::Uncompress&lt;/code&gt; モジュールの作成により、 &lt;code&gt;Compress::Zlib&lt;/code&gt; の新機能は計画されていません。新しいモジュールは、 &lt;code&gt;Compress::Zlib&lt;/code&gt; が実行するすべての機能を実行し、その後一部を実行します。 &lt;code&gt;Compress::Zlib&lt;/code&gt; 開発は、バグ修正のみに限定されます。</target>
        </trans-unit>
        <trans-unit id="23f3553b9522af30d1dac804157bedd65e6495d3" translate="yes" xml:space="preserve">
          <source>With the default setting the size is limited to 128MB. The -1 removes this limit. If the &quot;make test&quot; fails please change your /etc/security/limits as stated above.</source>
          <target state="translated">デフォルトの設定では、サイズは128MBに制限されています。1はこの制限を解除します。make test&quot; が失敗した場合は、上記のように /etc/security/limits を変更してください。</target>
        </trans-unit>
        <trans-unit id="9b9699d8827c96371e7103bd01aa95e9549d18da" translate="yes" xml:space="preserve">
          <source>With the example above, you knew to look for &lt;code&gt;Perl_pp_add&lt;/code&gt; , but what if there were multiple calls to it all over the place, or you didn't know what the op was you were looking for?</source>
          <target state="translated">上記の例では、 &lt;code&gt;Perl_pp_add&lt;/code&gt; を探すことを知っていましたが、あちこちで複数の呼び出しがあった場合や、探している操作がわからない場合はどうでしょうか。</target>
        </trans-unit>
        <trans-unit id="65607d779f766d1b6b4828b7428d0ded3d690325" translate="yes" xml:space="preserve">
          <source>With the following options you get a Perl version which passes all make tests in 32-bit mode.</source>
          <target state="translated">以下のオプションを使用すると、32ビットモードですべてのmakeテストに合格するPerlバージョンが得られます。</target>
        </trans-unit>
        <trans-unit id="a8358873bd6ba12b8e2a5bea80bf9adbb46e0a6e" translate="yes" xml:space="preserve">
          <source>With the following options you get a Perl version which passes all make tests in 64-bit mode.</source>
          <target state="translated">以下のオプションを使用すると、64 ビットモードですべての make テストに合格する Perl バージョンが得られます。</target>
        </trans-unit>
        <trans-unit id="26bc1ab7fe70714950b9630e3ca1a3522b890186" translate="yes" xml:space="preserve">
          <source>With the following options you get a threaded Perl version which passes all make tests in 64-bit mode.</source>
          <target state="translated">以下のオプションを使用すると、64 ビットモードですべての make テストをパスするスレッド型 Perl バージョンが得られます。</target>
        </trans-unit>
        <trans-unit id="653ecd70c393a4f98976d6cf49198158a3d68bae" translate="yes" xml:space="preserve">
          <source>With the following options you get a threaded Perl version which passes all make tests in threaded 32-bit mode, which is the default configuration for the Perl builds that AIX ships with.</source>
          <target state="translated">以下のオプションを使用すると、AIX で出荷されている Perl ビルドのデフォルト設定であるスレッド 32 ビットモードですべての make テストをパスするスレッド付き Perl バージョンが得られます。</target>
        </trans-unit>
        <trans-unit id="826dec98b275c7a952ab77d69c22223ec197d3b5" translate="yes" xml:space="preserve">
          <source>With the introduction of lexical warnings, mandatory warnings now become</source>
          <target state="translated">語彙的警告の導入により、強制的な警告は、現在では</target>
        </trans-unit>
        <trans-unit id="cb83c7552e22c7b5119774691db23c4fd72dba00" translate="yes" xml:space="preserve">
          <source>With the introduction of the</source>
          <target state="translated">の導入に伴い</target>
        </trans-unit>
        <trans-unit id="dd358809edabd87f2081065d37eb93940f155fac" translate="yes" xml:space="preserve">
          <source>With the lock released, process &quot;B&quot; can now continue. It also updates the database and unfortunately it too modifies the data that was in its initial buffer. Once that data gets flushed to disk it will overwrite some/all of the changes process &quot;A&quot; made to the database.</source>
          <target state="translated">ロックが解除されたことで、プロセス「B」は続行できるようになりました。また、データベースを更新しますが、残念ながら、初期バッファにあったデータも変更されます。一旦そのデータがディスクにフラッシュされると、プロセス「A」がデータベースに行った変更の一部またはすべてを上書きしてしまいます。</target>
        </trans-unit>
        <trans-unit id="b4b71a45e3d179fe5db4257fdf8f0f1934140fcb" translate="yes" xml:space="preserve">
          <source>With the release 5.003_01 the dynamically loadable libraries should be rebuilt when a different version of Perl is compiled. In particular, DLLs (including</source>
          <target state="translated">リリース5.003_01では、異なるバージョンのPerlがコンパイルされたときに、動的にロード可能なライブラリが再構築されるようになっています。特に、DLL (</target>
        </trans-unit>
        <trans-unit id="5325c34a4ae29cf34042f77f365e0b89df2159a0" translate="yes" xml:space="preserve">
          <source>With this keyword present &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;The RETVAL Variable&lt;/a&gt; is created, and in the generated call to the subroutine this variable is assigned to, but the value of this variable is not going to be used in the auto-generated code.</source>
          <target state="translated">このキーワードが存在する場合&lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;、RETVAL変数&lt;/a&gt;が作成され、サブルーチンへの生成された呼び出しでこの変数が割り当てられますが、この変数の値は自動生成コードでは使用されません。</target>
        </trans-unit>
        <trans-unit id="1f7c25b6745f51eae37c62a2374f7ba131484e1b" translate="yes" xml:space="preserve">
          <source>With this option, the rendering of each statement (starting with the nextstate OP) will be preceded by the 1st line of source code that generates it. For example:</source>
          <target state="translated">このオプションを使用すると、各ステートメントのレンダリング(nextstate OPで始まる)の前には、それを生成するソースコードの1行目が表示されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="8f18c563efb0b7956e6e194500e98dba172fcbe5" translate="yes" xml:space="preserve">
          <source>With this syntax, the whitespace character(s) after the &quot;C&amp;lt;&amp;lt;&amp;lt;&quot; and before the &quot;&amp;gt;&amp;gt;&amp;gt;&quot; (or whatever letter) are</source>
          <target state="translated">この構文では、「C &amp;lt;&amp;lt;&amp;lt;」の後の「&amp;gt;&amp;gt;&amp;gt;」（または任意の文字）の前の空白文字は</target>
        </trans-unit>
        <trans-unit id="9b739cdb3f9d5a8eac7c3872d89896d374a02d63" translate="yes" xml:space="preserve">
          <source>With this, &quot;somepackage&quot; will be required, then the stash is inspected, and each function is rendered.</source>
          <target state="translated">これで、&quot;somepackage &quot;が必要になり、その後、stashを検査し、各関数をレンダリングします。</target>
        </trans-unit>
        <trans-unit id="a5fec2f4d5db8c4f13f212d9ea51033367a444e6" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;charinrange()&lt;/code&gt; will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if its input code point maps to &lt;code&gt;$default&lt;/code&gt; . You can avoid this by omitting the &lt;code&gt;&lt;a href=&quot;../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement, and adding a line after the loop to handle the final element of the inversion map.</source>
          <target state="translated">これにより、入力コードポイントが &lt;code&gt;$default&lt;/code&gt; マップされている場合、 &lt;code&gt;charinrange()&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。これを回避するには、 &lt;code&gt;&lt;a href=&quot;../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ステートメントを省略し、ループの後に行を追加して、反転マップの最後の要素を処理します。</target>
        </trans-unit>
        <trans-unit id="6dae05359217975cb78e41e5b34deca474650edf" translate="yes" xml:space="preserve">
          <source>With threads one must be careful to make sure they all have a chance to run to completion, assuming that is what you want.</source>
          <target state="translated">スレッドで1つは、彼らはすべてあなたが望むものであると仮定して、完了するために実行する機会を持っていることを確認するように注意しなければなりません。</target>
        </trans-unit>
        <trans-unit id="caa257633e4cd0d103eaaa262d9da80593127c23" translate="yes" xml:space="preserve">
          <source>With todo tests, it's best to have the tests actually run. That way you'll know when they start passing. Sometimes this isn't possible. Often a failing test will cause the whole program to die or hang, even inside an &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; with and using &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;. In these extreme cases you have no choice but to skip over the broken tests entirely.</source>
          <target state="translated">todoテストでは、テストを実際に実行するのが最善です。そうすれば、彼らがいつ通り過ぎるかがわかります。これが不可能な場合もあります。多くの場合、テストに失敗すると、 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; を使用した &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; 内であっても、プログラム全体が停止またはハングします。これらの極端なケースでは、壊れたテストを完全にスキップするしかありません。</target>
        </trans-unit>
        <trans-unit id="ec0e094c2438c09cc3dbc2cdfeb2a697dd782dc5" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;(?[ ])&lt;/code&gt; , no literal characters are allowed unless they are within an inner pair of square brackets, like</source>
          <target state="translated">&lt;code&gt;(?[ ])&lt;/code&gt; 内では、リテラル文字は、次のように内側の大括弧のペア内にある場合を除いて許可されません</target>
        </trans-unit>
        <trans-unit id="2e8425db1df10e66ba739a46b6d044fcd9cc27fd" translate="yes" xml:space="preserve">
          <source>Within Perl, you may use this directly:</source>
          <target state="translated">Perl内では、これを直接使用することができます。</target>
        </trans-unit>
        <trans-unit id="34e265601157e7965a7e7bfdb3408a61baf139df" translate="yes" xml:space="preserve">
          <source>Within USS your /etc/profile or $HOME/.profile may limit your ulimit settings. Check that the following command returns reasonable values:</source>
          <target state="translated">USS 内では、/etc/profile や $HOME/.profile が ulimit の設定を制限している場合があります。以下のコマンドが妥当な値を返していることを確認してください。</target>
        </trans-unit>
        <trans-unit id="29ba20619ba09719c47471e336e4ab5403150666" translate="yes" xml:space="preserve">
          <source>Within a Pod block, there are &lt;b&gt;Pod paragraphs&lt;/b&gt;. A Pod paragraph consists of non-blank lines of text, separated by one or more blank lines.</source>
          <target state="translated">ポッドブロック内には、&lt;b&gt;ポッドの段落があり&lt;/b&gt;ます。ポッドの段落は、1行以上の空白行で区切られた、空白以外のテキスト行で構成されます。</target>
        </trans-unit>
        <trans-unit id="e21031e24f9ec987f957a61688b27e62b9c110c1" translate="yes" xml:space="preserve">
          <source>Within a character class:</source>
          <target state="translated">文字クラス内。</target>
        </trans-unit>
        <trans-unit id="40c178236d58dee9559c7a2a4195e7fba2bd546e" translate="yes" xml:space="preserve">
          <source>Within a pattern, you may designate subpatterns for later reference by enclosing them in parentheses, and you may refer back to the</source>
          <target state="translated">パターン内では、後から参照するためにサブパターンを括弧で囲んで指定することができます。</target>
        </trans-unit>
        <trans-unit id="0cfdb7962d912e72a66b4f3d5343b1e5e212ac27" translate="yes" xml:space="preserve">
          <source>Within a subroutine the array &lt;code&gt;@_&lt;/code&gt; contains the parameters passed to that subroutine. Inside a subroutine, &lt;code&gt;@_&lt;/code&gt; is the default array for the array operators &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">サブルーチン内では、配列 &lt;code&gt;@_&lt;/code&gt; には、そのサブルーチンに渡されるパラメーターが含まれています。サブルーチン内では、 &lt;code&gt;@_&lt;/code&gt; が配列演算子 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; のデフォルト配列です。</target>
        </trans-unit>
        <trans-unit id="2ab4fe9703eceeab90b6dcb41e63f66c50a795d5" translate="yes" xml:space="preserve">
          <source>Within search patterns (which also undergo double-quotish substitution) there is an unfortunate ambiguity: Is &lt;code&gt;/$foo[bar]/&lt;/code&gt; to be interpreted as &lt;code&gt;/${foo}[bar]/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is a character class for the regular expression) or as &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is the subscript to array @foo)? If @foo doesn't otherwise exist, then it's obviously a character class. If @foo exists, Perl takes a good guess about &lt;code&gt;[bar]&lt;/code&gt; , and is almost always right. If it does guess wrong, or if you're just plain paranoid, you can force the correct interpretation with curly braces as above.</source>
          <target state="translated">検索パターン（二重引用符の置換も受ける）には、あいにくあいまいさがあります： &lt;code&gt;/$foo[bar]/&lt;/code&gt; は &lt;code&gt;/${foo}[bar]/&lt;/code&gt; として解釈されます（ &lt;code&gt;[bar]&lt;/code&gt; は、正規表現）または &lt;code&gt;/${foo[bar]}/&lt;/code&gt; （ &lt;code&gt;[bar]&lt;/code&gt; は配列@fooの添え字）として？ @fooが他に存在しない場合、それは明らかに文字クラスです。 @fooが存在する場合、Perlは &lt;code&gt;[bar]&lt;/code&gt; について適切な推測を行い、ほとんどの場合正しい。推測が間違っている場合、または単なる偏執狂である場合は、上記のように中括弧で正しい解釈を強制できます。</target>
        </trans-unit>
        <trans-unit id="d84dbb525d8c49a11b671ff1144decfba831a5a9" translate="yes" xml:space="preserve">
          <source>Within strings that are to be displayed in a fixed-length text field, each control character is substituted by a space. (But remember the special meaning of &lt;code&gt;\r&lt;/code&gt; when using fill mode.) This is done to avoid misalignment when control characters &quot;disappear&quot; on some output media.</source>
          <target state="translated">固定長テキストフィールドに表示される文字列内では、各制御文字はスペースに置き換えられます。（ただし、塗りつぶしモードを使用するときは、 &lt;code&gt;\r&lt;/code&gt; 特別な意味を覚えておいてください。）これは、一部の出力メディアで制御文字が「消える」ときの調整不良を回避するために行われます。</target>
        </trans-unit>
        <trans-unit id="4456754ccf74e411d5ea49ec8792a5f2c7c3945a" translate="yes" xml:space="preserve">
          <source>Within that basic form, add the parts that you need to insert, change, or delete lines.</source>
          <target state="translated">その基本フォームの中に、行の挿入、変更、削除に必要な部分を追加します。</target>
        </trans-unit>
        <trans-unit id="8cbc5afc548aa028061d92c2e27d708ba5cdc361" translate="yes" xml:space="preserve">
          <source>Within that module, create an &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine.</source>
          <target state="translated">そのモジュール内で、 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; サブルーチンを作成します。</target>
        </trans-unit>
        <trans-unit id="8c44a88f26bc68b39089193962c587ad7e818543" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine do a call to &lt;code&gt;filter_add&lt;/code&gt; , passing it either a subroutine reference.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; サブルーチン内で &lt;code&gt;filter_add&lt;/code&gt; を呼び出して、サブルーチン参照のいずれかを渡します。</target>
        </trans-unit>
        <trans-unit id="66ccfeaad3b7f2de2f94c5b7b2a2afe57c62216c" translate="yes" xml:space="preserve">
          <source>Within the alternative numbering group, group numbers start at the same position for each alternative. After the group, numbering continues with one higher than the maximum reached across all the alternatives.</source>
          <target state="translated">代替番号付けグループ内では、グループ番号は各代替案の同じ位置から始まる。グループの後、番号付けは、すべての代替案で到達した最大値よりも1つ高い番号で継続される。</target>
        </trans-unit>
        <trans-unit id="bee307dd55ae8e02f4730b754c6aca4828fa5f41" translate="yes" xml:space="preserve">
          <source>Within the anonymous subroutine or block that is passed to &lt;code&gt;FILTER&lt;/code&gt; , process the contents of $_ to change the source code in the desired manner.</source>
          <target state="translated">&lt;code&gt;FILTER&lt;/code&gt; に渡される匿名のサブルーチンまたはブロック内で、$ _の内容を処理して、ソースコードを目的の方法で変更します。</target>
        </trans-unit>
        <trans-unit id="00c20e56f1d9e34b6bd5de0acc2c9d7db7958c51" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;use feature 'unicode_strings' &lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;使用機能「unicode_strings」の&lt;/a&gt;範囲内</target>
        </trans-unit>
        <trans-unit id="db5115b248b9b3a92796783fe0ad72c64d3ee250" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;use locale 'not_characters' &lt;/a&gt;, or &lt;a href=&quot;perllocale&quot;&gt;use locale &lt;/a&gt; and the current locale is a UTF-8 locale.</source>
          <target state="translated">範囲内で&lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;使用するロケール「not_characters」&lt;/a&gt;、または&lt;a href=&quot;perllocale&quot;&gt;使用ロケール&lt;/a&gt;と現在のロケールUTF-8ロケールです。</target>
        </trans-unit>
        <trans-unit id="4b75686c25d4349996112a3e43d160bed9377b64" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 範囲5.012以上</target>
        </trans-unit>
        <trans-unit id="921e8cdb506222d3c5cb715870308743278f73c9" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; の範囲内では、文字列がUTF-8としてエンコードされているかどうかに関係なく、すべての非ASCII Latin1コードポイントが引用されます。上記のように、ロケールはASCII範囲の文字の引用には影響しません。これにより、 &lt;code&gt;&quot;|&quot;&lt;/code&gt; などの文字が含まれるロケールから保護されます。単語文字と見なされます。</target>
        </trans-unit>
        <trans-unit id="7f97b0baeb5c1f48ecb7c6036a913594c0cf832a" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 範囲内utf8</target>
        </trans-unit>
        <trans-unit id="6c6da8dacdcff581b760f12d305142c260f19722" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; の範囲内では、文字列がUTF-8としてエンコードされているかどうかに関係なく、すべての非ASCII Latin1コードポイントが引用されます。上記のように、ロケールはASCII範囲の文字の引用には影響しません。これにより、 &lt;code&gt;&quot;|&quot;&lt;/code&gt; などの文字が含まれるロケールから保護されます。単語文字と見なされます。</target>
        </trans-unit>
        <trans-unit id="b93e8b9c84e9c172138891ffbac960fd8330a481" translate="yes" xml:space="preserve">
          <source>Within the subroutine reference, call &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; to &quot;prime&quot; $_ with source code data from the source file that will &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; your module. Check the status value returned to see if any source code was actually read in.</source>
          <target state="translated">サブルーチン参照内で、 &lt;code&gt;filter_read&lt;/code&gt; または &lt;code&gt;filter_read_exact&lt;/code&gt; を呼び出して、モジュールを &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; するソースファイルからのソースコードデータで$ _を「準備」します。返されたステータス値をチェックして、ソースコードが実際に読み込まれたかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="4f5dc8da9477105396ff0284ea2a7a7433b232a3" translate="yes" xml:space="preserve">
          <source>Within the while loop we call accept() and check to see if it returns a false value. This would normally indicate a system error needs to be reported. However, the introduction of safe signals (see &lt;a href=&quot;#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals)&lt;/a&gt; above) in Perl 5.8.0 means that accept() might also be interrupted when the process receives a signal. This typically happens when one of the forked subprocesses exits and notifies the parent process with a CHLD signal.</source>
          <target state="translated">whileループ内で、accept（）を呼び出し、false値を返すかどうかを確認します。これは通常、システムエラーを報告する必要があることを示します。ただし、Perl 5.8.0 での安全なシグナル（上記の&lt;a href=&quot;#Deferred-Signals-(Safe-Signals)&quot;&gt;遅延シグナル（安全なシグナル）を&lt;/a&gt;参照）の導入により、プロセスがシグナルを受信すると、accept（）も中断される可能性があります。これは通常、分岐したサブプロセスの1つが終了し、CHLDシグナルで親プロセスに通知するときに発生します。</target>
        </trans-unit>
        <trans-unit id="17b7808b8c8156fa9926b089d73ad2021671fe67" translate="yes" xml:space="preserve">
          <source>Without Readline support you may see the symbols &quot;^[[A&quot;, &quot;^[[C&quot;, &quot;^[[B&quot;, &quot;^[[D&quot;&quot;, &quot;^H&quot;, ... when using the arrow keys and/or the backspace key.</source>
          <target state="translated">Readlineをサポートしていない場合、矢印キーやバックスペースキーを使用すると、&quot;^[[A&quot;,&quot;^[[C&quot;,&quot;^[[B&quot;,&quot;^[[D&quot;,&quot;^H&quot;,...&quot;という記号が表示されることがあります。</target>
        </trans-unit>
        <trans-unit id="7a72072ff5468f365a1052f00033c60b07221002" translate="yes" xml:space="preserve">
          <source>Without additional configuration, GetOptions() will ignore the case of option names, and allow the options to be abbreviated to uniqueness.</source>
          <target state="translated">追加の設定がなければ、 GetOptions()はオプション名の大文字小文字を無視し、オプションを一意に省略できるようにします。</target>
        </trans-unit>
        <trans-unit id="d5efb30492f1c199d1a2c0cf117a4ad4a638df64" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves a regular expression for simplifying the individual item strings once the list type has been determined. Usage: E.g. when converting to HTML, one might strip the leading number in an ordered list as &lt;code&gt;&amp;lt;OL&amp;gt;&lt;/code&gt; already prints numbers itself. This must have been set before by either specifying &lt;b&gt;-rx&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;rx()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">引数がない場合、リストタイプが決定されたら、個々のアイテム文字列を簡略化するために正規表現を取得します。使用法：たとえば、HTMLに変換する場合、 &lt;code&gt;&amp;lt;OL&amp;gt;&lt;/code&gt; はすでに数値自体を出力しているため、順序付きリストの先頭の数値を取り除く場合があります。これは、&lt;b&gt;new（）&lt;/b&gt;メソッドで&lt;b&gt;-rx&lt;/b&gt;を指定するか、スカラー引数を指定して&lt;b&gt;rx（）&lt;/b&gt;メソッドを呼び出すことにより、&lt;b&gt;事前&lt;/b&gt;に設定しておく必要があります。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="18657a3de0c78898530507337e291d8dba0f72cc" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves information about the list tag, which can be any scalar. This must have been set before by either specifying &lt;b&gt;-tag&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;tag()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">引数なしで、任意のスカラーのリストタグに関する情報を取得します。これは、&lt;b&gt;new（）&lt;/b&gt;メソッドで&lt;b&gt;-tag&lt;/b&gt;を指定するか、スカラー引数を指定して&lt;b&gt;tag（）&lt;/b&gt;メソッドを呼び出すことにより、&lt;b&gt;事前&lt;/b&gt;に設定しておく必要があります。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8ccc25a668b5326c657bc2f5c79197991b145ee7" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves information about the parent holding this list, which is represented as an arbitrary scalar. This must have been set before by either specifying &lt;b&gt;-parent&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;parent()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">引数なしで、このリストを保持する親に関する情報を取得します。これは、任意のスカラーとして表されます。これは、&lt;b&gt;new（）&lt;/b&gt;メソッドで&lt;b&gt;-parent&lt;/b&gt;を指定するか、スカラー引数を指定して&lt;b&gt;parent（）&lt;/b&gt;メソッドを呼び出すことにより、&lt;b&gt;事前&lt;/b&gt;に設定しておく必要があります。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c9f5dc6cba8c17ba8a8e789cb997502b75241827" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the array of the items in this list. The items may be represented by any scalar. If an argument has been given, it is pushed on the list of items.</source>
          <target state="translated">引数なしで、このリストの項目の配列を取得します。項目は任意のスカラーで表現することができます。引数が与えられた場合は、それがアイテムのリストにプッシュされます。</target>
        </trans-unit>
        <trans-unit id="b13b7cf761d2e7e6717a0226cb08e73a66d55812" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the file name the list is in. This must have been set before by either specifying &lt;b&gt;-file&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;file()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">引数なしで、リストが含まれているファイル名を取得します。これは、&lt;b&gt;new（）&lt;/b&gt;メソッドで&lt;b&gt;-file&lt;/b&gt;を指定するか、スカラー引数を指定して&lt;b&gt;file（）&lt;/b&gt;メソッドを呼び出すことにより、事前に設定しておく必要があります。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1b1eba0344418f60cab2e73b154b51b8cc2fd939" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the indent level of the list as specified in &lt;code&gt;=over n&lt;/code&gt; . This must have been set before by either specifying &lt;b&gt;-indent&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;indent()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">引数なしで、 &lt;code&gt;=over n&lt;/code&gt; で指定されたリストのインデントレベルを取得します。これは、&lt;b&gt;new（）&lt;/b&gt;メソッドで&lt;b&gt;-indent&lt;/b&gt;を指定するか、スカラー引数を指定して&lt;b&gt;indent（）&lt;/b&gt;メソッドを呼び出すことにより、&lt;b&gt;事前&lt;/b&gt;に設定しておく必要があります。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c3a863e0f35dbdfaea66e845edf4708bb6d53918" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the line number where the list started. This must have been set before by either specifying &lt;b&gt;-start&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;start()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">引数なしで、リストが始まった行番号を取得します。これは、&lt;b&gt;new（）&lt;/b&gt;メソッドで&lt;b&gt;-start&lt;/b&gt;を指定するか、スカラー引数を指定して&lt;b&gt;start（）&lt;/b&gt;メソッドを呼び出すことにより、事前に設定しておく必要があります。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="914d0fa2ff8badbccd79dfd30e292a8ed73be0c1" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the list type, which can be an arbitrary value, e.g. &lt;code&gt;OL&lt;/code&gt; , &lt;code&gt;UL&lt;/code&gt; , ... when thinking the HTML way. This must have been set before by either specifying &lt;b&gt;-type&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;type()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">引数なしで、リストのタイプを取得します。これは、HTMLの方法を考えるときに、 &lt;code&gt;OL&lt;/code&gt; 、 &lt;code&gt;UL&lt;/code&gt; などの任意の値にすることができます。これは、&lt;b&gt;new（）&lt;/b&gt;メソッドで&lt;b&gt;-type&lt;/b&gt;を指定するか、&lt;b&gt;type（）&lt;/b&gt;メソッドをスカラー引数で呼び出して、事前に設定しておく必要があります。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0c21aaff33380d9ba14cee3094239dfc4fb494ab" translate="yes" xml:space="preserve">
          <source>Without arguments libnetcfg displays the current configuration.</source>
          <target state="translated">引数なしでは libnetcfg は現在の設定を表示します。</target>
        </trans-unit>
        <trans-unit id="4decffda157c9d482865e95a2bef98fbdd07c180" translate="yes" xml:space="preserve">
          <source>Without autodie (and assuming BAREWORD is an open filehandle/dirhandle) this is a valid call to chdir. But under autodie, &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; will behave like it had the prototype &quot;;$&quot; and thus BAREWORD will be a syntax error (under &quot;use strict&quot;. Without strict, it will interpreted as a filename).</source>
          <target state="translated">autodieがなければ（BAREWORDが開いているファイルハンドル/ディレクトリハンドルであると仮定して）、これはchdirへの有効な呼び出しです。しかし、autodieでは、 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; はプロトタイプ「; $」のように動作するため、BAREWORDは構文エラーになります（「use strict」では。strictがないと、ファイル名として解釈されます）。</target>
        </trans-unit>
        <trans-unit id="157dc325ab3004964dba8cb99f25c548e59c3ee6" translate="yes" xml:space="preserve">
          <source>Without binmode this happens to work but without binmode, print() fails instead of write().</source>
          <target state="translated">binmodeを使用しない場合、これは動作しますが、binmodeを使用しない場合、write()ではなくprint()が失敗します。</target>
        </trans-unit>
        <trans-unit id="9fae572f92ad00688736431e8db34f7e13e97183" translate="yes" xml:space="preserve">
          <source>Without compiling a special Perl, there is no way to get the exact same behavior of any versions prior to Perl 5.18.0. The closest one can get is by setting PERL_PERTURB_KEYS to 0 and setting the PERL_HASH_SEED to a known value. We do not advise those settings for production use due to the above security considerations.</source>
          <target state="translated">特別なPerlをコンパイルしなければ、Perl 5.18.0以前のバージョンと全く同じ動作を得る方法はありません。最も近いのは、PERL_PERTURB_KEYSを0に設定し、PERL_HASH_SEEDを既知の値に設定することです。上記のセキュリティ上の配慮から、本番環境での使用はお勧めしません。</target>
        </trans-unit>
        <trans-unit id="40d89b93ede452cf3a3abe5db73cc3f6990cb465" translate="yes" xml:space="preserve">
          <source>Without sending mail to the address and seeing whether there's a human on the other end to answer you, you cannot fully answer part</source>
          <target state="translated">アドレスにメールを送って、相手に返事をしてくれる人間がいるかどうかを見ないと、一部を完全に答えることはできません。</target>
        </trans-unit>
        <trans-unit id="9dc761ae6cda1ca106ca429a9b91481691a414c5" translate="yes" xml:space="preserve">
          <source>Without tests provided by the original author, how can anyone else changing perl in the future be sure that they haven't unwittingly broken the behaviour the patch implements? And without tests, how can the patch's author be confident that his/her hard work put into the patch won't be accidentally thrown away by someone in the future?</source>
          <target state="translated">オリジナルの作者が提供したテストがなければ、将来Perlを変更する人が、そのパッチが実装している動作を知らず知らずのうちに壊していないことをどうやって確信できるでしょうか? また、テストがなければ、パッチの作者は、将来誰かに誤って捨てられてしまうことのないように、パッチに費やした苦労をどうやって自信を持つことができるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="c1443d621edad5afbf828f718460ec1c38b6ccbc" translate="yes" xml:space="preserve">
          <source>Without that empty line before the &quot;=head1&quot;, many translators wouldn't have recognized the &quot;=head1&quot; as starting a Pod block.</source>
          <target state="translated">head1」の前の空行がなければ、多くの翻訳者は「=head1」をPodブロックの始まりとして認識しなかったでしょう。</target>
        </trans-unit>
        <trans-unit id="d67d28a004691a2df73ec622342b344f42349502" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $AUTOLOAD&lt;/code&gt; declaration, this code will not compile under the &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; pragma.</source>
          <target state="translated">なければ &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $AUTOLOAD&lt;/code&gt; 宣言、このコードは下コンパイルされません&lt;a href=&quot;strict&quot;&gt;厳格な&lt;/a&gt;プラグマ。</target>
        </trans-unit>
        <trans-unit id="9862e56ba4382f4550c0a053a28a9edc67cb29a8" translate="yes" xml:space="preserve">
          <source>Without the \\ before the #, we'd have the start of a Makefile comment, and the macro would be incorrectly defined.</source>
          <target state="translated">の前に「\」がないと、Makefileのコメントが始まってしまい、マクロの定義がおかしくなってしまいます。</target>
        </trans-unit>
        <trans-unit id="c652adb6df9438fc28974e5263002f95713055c4" translate="yes" xml:space="preserve">
          <source>Without the all-critical &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declaration, putting UTF‑8 in your literals and identifiers won&amp;rsquo;t work right. If you used the standard preamble just given above, this already happened. If you did, you can do things like this:</source>
          <target state="translated">all-critical &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 宣言がないと、UTF and8をリテラルと識別子に入れても正しく機能しません。上記の標準プリアンブルを使用した場合、これはすでに起こりました。もしそうなら、あなたはこのようなことをすることができます：</target>
        </trans-unit>
        <trans-unit id="a805f73e432af03c931e3e4ebc6e43febdbb1b0f" translate="yes" xml:space="preserve">
          <source>Without the braces, Perl would have looked for a $whospeak, a &lt;code&gt;$who::0&lt;/code&gt; , and a &lt;code&gt;$who's&lt;/code&gt; variable. The last two would be the $0 and the $s variables in the (presumably) non-existent package &lt;code&gt;who&lt;/code&gt; .</source>
          <target state="translated">中括弧がなければ、Perlは$ whospeak、 &lt;code&gt;$who::0&lt;/code&gt; 、および &lt;code&gt;$who's&lt;/code&gt; 変数を探していました。最後の2つは、（おそらく）存在しないパッケージ &lt;code&gt;who&lt;/code&gt; の$ 0変数と$ s変数です。</target>
        </trans-unit>
        <trans-unit id="8b7119185642381b4835e616a2adfce6407060de" translate="yes" xml:space="preserve">
          <source>Without the file handle there is no straightforward way to map from the C callback to the Perl subroutine.</source>
          <target state="translated">ファイルハンドルがないと、CのコールバックからPerlのサブルーチンにマッピングする簡単な方法がありません。</target>
        </trans-unit>
        <trans-unit id="557fc723a913d1e3b2505b4094298be8eec2001a" translate="yes" xml:space="preserve">
          <source>Without the quotes Perl would convert the large number to a floating point constant at compile time and then hand the result to BigInt, which results in an truncated result or a NaN.</source>
          <target state="translated">引用符がない場合、Perlはコンパイル時に大きな数値を浮動小数点定数に変換し、その結果をBigIntに渡します。</target>
        </trans-unit>
        <trans-unit id="ebd1a191c5e0195ae68815f767eadf66793aed3f" translate="yes" xml:space="preserve">
          <source>Without this pragma, if strings operating under byte semantics and strings with Unicode character data are concatenated, the new string will be created by decoding the byte strings as</source>
          <target state="translated">このプラグマがない場合、バイトセマンティクスで動作する文字列と Unicode 文字データを持つ文字列が連結されている場合、バイト文字列を</target>
        </trans-unit>
        <trans-unit id="4e3240128cc4ac6294817aa01c1437d4416b9150" translate="yes" xml:space="preserve">
          <source>Word characters</source>
          <target state="translated">単語の文字</target>
        </trans-unit>
        <trans-unit id="c1ab804bf377c2d02f25ebababbe5112fca26b12" translate="yes" xml:space="preserve">
          <source>Work Crew</source>
          <target state="translated">作業員</target>
        </trans-unit>
        <trans-unit id="73f4875bffaeefb6bc4c9e5de5982f1c956b5814" translate="yes" xml:space="preserve">
          <source>Work around DCL's 255 character limit several times,and use VMS-style command line quoting in a few cases.</source>
          <target state="translated">DCLの255文字制限を何度か回避し、VMSスタイルのコマンドラインの引用符を使用することもあります。</target>
        </trans-unit>
        <trans-unit id="beb03a8c30af39505328c268c1180c75604701a0" translate="yes" xml:space="preserve">
          <source>Work for the pumpking, work for Perl programmers, work for module authors, ... Perl is supposed to be easy.</source>
          <target state="translated">パンプキンの仕事、Perlプログラマの仕事、モジュール作成者の仕事、...Perlは簡単なはずです。</target>
        </trans-unit>
        <trans-unit id="b837e4f0aacd9d9f6074d443ecd309cef87e661e" translate="yes" xml:space="preserve">
          <source>Working code is always preferred to pie-in-the-sky ideas. A patch to add a feature stands a much higher chance of making it to the language than does a random feature request, no matter how fervently argued the request might be. This ties into &quot;Will it be useful?&quot;, as the fact that someone took the time to make the patch demonstrates a strong desire for the feature.</source>
          <target state="translated">机上の空論のアイデアよりも、実際のコードの方が常に優先されます。機能を追加するためのパッチは、どんなに熱心に主張された要求であっても、無作為な機能要求よりも、言語に反映される可能性がはるかに高いのです。これは、誰かが時間をかけてパッチを作ったという事実が、その機能に対する強い欲求を示しているということであり、「役に立つかどうか」と関係しています。</target>
        </trans-unit>
        <trans-unit id="791f0cf1a4866efe09fa052199378fd87a29a636" translate="yes" xml:space="preserve">
          <source>Working with AVs</source>
          <target state="translated">AVとの連携</target>
        </trans-unit>
        <trans-unit id="fcf77865e202a40f39e6dc4633dec2c1c8b8542a" translate="yes" xml:space="preserve">
          <source>Working with HVs</source>
          <target state="translated">HVとの連携</target>
        </trans-unit>
        <trans-unit id="9ba6b91bf263dc667dda1becd81a9fbef7358bbd" translate="yes" xml:space="preserve">
          <source>Working with Net::FTP</source>
          <target state="translated">Net::FTP での作業</target>
        </trans-unit>
        <trans-unit id="9522f5ef01714aab2e2d70111bf52346aa9851c3" translate="yes" xml:space="preserve">
          <source>Working with SVs</source>
          <target state="translated">SVとの連携</target>
        </trans-unit>
        <trans-unit id="7efe528e837c3e9dd842174c934d74e9c8e8af64" translate="yes" xml:space="preserve">
          <source>Works currently only for integers.</source>
          <target state="translated">現在は整数でのみ動作します。</target>
        </trans-unit>
        <trans-unit id="c9cb7c59dae1a78441bca64b16b41d57dc70c3e5" translate="yes" xml:space="preserve">
          <source>Works exactly as &lt;code&gt;like()&lt;/code&gt; , only it checks if $got &lt;b&gt;does not&lt;/b&gt; match the given pattern.</source>
          <target state="translated">&lt;code&gt;like()&lt;/code&gt; とまったく同じように&lt;b&gt;機能し&lt;/b&gt;、$ got &lt;b&gt;が&lt;/b&gt;指定されたパターンに一致&lt;b&gt;しない&lt;/b&gt;かどうかを確認するだけです。</target>
        </trans-unit>
        <trans-unit id="9232c0576386ef7db9a66e0f3312f80aa2ae0362" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#localtime&quot;&gt;localtime&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">&lt;a href=&quot;#localtime&quot;&gt;localtimeと&lt;/a&gt;同じように機能しますが、戻り値は標準のグリニッジタイムゾーンにローカライズされます。</target>
        </trans-unit>
        <trans-unit id="63d895f5ba3197e6e250fa353d94a31dc5531f0f" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">&lt;a href=&quot;localtime&quot;&gt;localtimeと&lt;/a&gt;同じように機能しますが、戻り値は標準のグリニッジタイムゾーンにローカライズされます。</target>
        </trans-unit>
        <trans-unit id="59edd54160d7f94a92175d3ce89e67babbe534fb" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;cmp_ok()&lt;/code&gt; .</source>
          <target state="translated">&lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt;の &lt;code&gt;cmp_ok()&lt;/code&gt; と同じように機能します。</target>
        </trans-unit>
        <trans-unit id="b054b39e72ec238653744e3a117cbf2b7bacaa18" translate="yes" xml:space="preserve">
          <source>Works just like index() except that it returns the position of the</source>
          <target state="translated">の位置を返すことを除いては index()と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="62b7e0373549dae581f58b37784d19f9d489170e" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_catpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;sv_setpvf_mg&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;sv_catpvf&lt;/code&gt; のように機能しますが、テキストを追加するのではなく、SVにコピーします。「セット」マジックを処理しません。 &lt;code&gt;sv_setpvf_mg&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="43ccfff897978a36d025fbdd87f7f80f29da36e5" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;sv_vcatpvf&lt;/code&gt; のように機能しますが、テキストを追加するのではなく、SVにコピーします。「セット」マジックを処理しません。 &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="ce9ad1c2559537d328f2e9ae5ccf06d2341106d3" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvfn&lt;/code&gt; but copies the text into the SV instead of appending it.</source>
          <target state="translated">&lt;code&gt;sv_vcatpvfn&lt;/code&gt; のように機能しますが、テキストを追加するのではなく、SVにコピーします。</target>
        </trans-unit>
        <trans-unit id="e28088b9057a774cbeb7647c942ba983be39b65a" translate="yes" xml:space="preserve">
          <source>Workshops</source>
          <target state="translated">Workshops</target>
        </trans-unit>
        <trans-unit id="aca31ad78f24eb8f34a6f1515e5ad96783f7a4c5" translate="yes" xml:space="preserve">
          <source>World Wide Web, HTML, HTTP, CGI, MIME</source>
          <target state="translated">ワールドワイドウェブ、HTML、HTTP、CGI、MIME</target>
        </trans-unit>
        <trans-unit id="dc354627de17c28e4a463874cb49fb69cf80c2d0" translate="yes" xml:space="preserve">
          <source>Worse still, if you've got a language like Chinese or Japanese that has hundreds or thousands of characters, then you really can't fit them into a mere 256, so they had to forget about ASCII altogether, and build their own systems using pairs of numbers to refer to one character.</source>
          <target state="translated">さらに悪いことに、中国語や日本語のように何百、何千もの文字がある言語では、たった256文字では収まりきらないので、ASCIIを完全に忘れて、1つの文字を参照するための数字のペアを使って独自のシステムを構築しなければなりませんでした。</target>
        </trans-unit>
        <trans-unit id="c5bfba3d49e2ee674235e330da88197da31a7c79" translate="yes" xml:space="preserve">
          <source>Would print '1', because &lt;code&gt;$foo&lt;/code&gt; holds a reference to the</source>
          <target state="translated">&lt;code&gt;$foo&lt;/code&gt; はへの参照を保持しているため、「1」を出力します</target>
        </trans-unit>
        <trans-unit id="cb47f1ed4bc872fb3335bdefcb281f4424715abe" translate="yes" xml:space="preserve">
          <source>Would run bin/foobar.PL like this:</source>
          <target state="translated">bin/foobar.PLをこのように実行します。</target>
        </trans-unit>
        <trans-unit id="ead2351e2ba0bd4c816a4c94cc5152ad666ddb3d" translate="yes" xml:space="preserve">
          <source>Wrapper around CPAN.pm without using any XS module</source>
          <target state="translated">XS モジュールを使わない CPAN.pm のラッパー</target>
        </trans-unit>
        <trans-unit id="84ac379977c898d123ab3b5be8e7d1ebcc793262" translate="yes" xml:space="preserve">
          <source>Wrapper around Config.pm</source>
          <target state="translated">Config.pm のラッパー</target>
        </trans-unit>
        <trans-unit id="5e2ec9565586c686048d53d457fe37527f6aad30" translate="yes" xml:space="preserve">
          <source>Wrapper class for calling subs at end of scope</source>
          <target state="translated">スコープの終了時にサブを呼び出すためのラッパークラス</target>
        </trans-unit>
        <trans-unit id="49754b3431fd16ae1cf0d382c55b7fa7149dd942" translate="yes" xml:space="preserve">
          <source>Wrapping all die calls in a handler routine can be useful to see how, and from where, they're being called, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; has more information:</source>
          <target state="translated">すべてのdie呼び出しをハンドラールーチンでラップすると、呼び出されている方法と場所を確認するのに役立ちます&lt;a href=&quot;perlvar&quot;&gt;。perlvarに&lt;/a&gt;はさらに多くの情報があります。</target>
        </trans-unit>
        <trans-unit id="c2c61b8accf065e529ff818a1a9f4549b7fc54ab" translate="yes" xml:space="preserve">
          <source>Wrapping with parenthesis allows the wildcard parts of the Input File Glob to be referenced by the second parameter to &lt;code&gt;globmap&lt;/code&gt; , &lt;code&gt;#1.tgz&lt;/code&gt; , the</source>
          <target state="translated">括弧付きラッピングは、入力ファイルグロブのワイルドカードの部分は2番目のパラメータによって参照することができます &lt;code&gt;globmap&lt;/code&gt; 、 &lt;code&gt;#1.tgz&lt;/code&gt; 、</target>
        </trans-unit>
        <trans-unit id="7ee0be976deb11b8b1d2de7c10091a2cf26d9d3d" translate="yes" xml:space="preserve">
          <source>Wraps any CODE references found within the arguments by replacing each with the result of calling &lt;a href=&quot;#wrap_code_ref&quot;&gt;wrap_code_ref&lt;/a&gt; on the CODE reference. Any ARRAY or HASH references in the arguments are inspected recursively.</source>
          <target state="translated">CODEリファレンスで&lt;a href=&quot;#wrap_code_ref&quot;&gt;wrap_code_ref&lt;/a&gt;を呼び出した結果でそれぞれを置き換えることにより、引数内で見つかったすべてのCODEリファレンスをラップします。引数内のARRAYまたはHASH参照は再帰的に検査されます。</target>
        </trans-unit>
        <trans-unit id="c3415b34e4326194b5c5e94f65779568f9ab9142" translate="yes" xml:space="preserve">
          <source>Wraps up an op tree with some additional ops so that at runtime a dynamic scope will be created. The original ops run in the new dynamic scope, and then, provided that they exit normally, the scope will be unwound. The additional ops used to create and unwind the dynamic scope will normally be an &lt;code&gt;enter&lt;/code&gt; /&lt;code&gt;leave&lt;/code&gt; pair, but a &lt;code&gt;scope&lt;/code&gt; op may be used instead if the ops are simple enough to not need the full dynamic scope structure.</source>
          <target state="translated">実行時に動的スコープが作成されるように、opツリーをいくつかの追加のopでラップします。元の操作は新しい動的スコープで実行され、正常に終了すると、スコープが展開されます。動的スコープの作成と巻き戻しに使用される追加のopsは通常、 &lt;code&gt;enter&lt;/code&gt; / &lt;code&gt;leave&lt;/code&gt; ペアですが、完全な動的スコープ構造を必要としないほど単純な場合は、代わりに &lt;code&gt;scope&lt;/code&gt; opを使用できます。</target>
        </trans-unit>
        <trans-unit id="4a48932789d199bbed709777e2d743ca2bafdc6c" translate="yes" xml:space="preserve">
          <source>Write</source>
          <target state="translated">Write</target>
        </trans-unit>
        <trans-unit id="665e91485da7b1f4da854eb4a64d72b175917c29" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes of data from &lt;code&gt;BUFFER&lt;/code&gt; to the server, also performing any &amp;lt;CRLF&amp;gt; translation necessary. &lt;code&gt;TIMEOUT&lt;/code&gt; is optional, if not given, the timeout value from the command connection will be used.</source>
          <target state="translated">&lt;code&gt;BUFFER&lt;/code&gt; からサーバーに &lt;code&gt;SIZE&lt;/code&gt; バイトのデータを書き込み、必要な&amp;lt;CRLF&amp;gt;変換も実行します。 &lt;code&gt;TIMEOUT&lt;/code&gt; はオプションです。指定しない場合、コマンド接続からのタイムアウト値が使用されます。</target>
        </trans-unit>
        <trans-unit id="9e9970521c52eb1a81f415505a29f59eba7d4c0c" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes to the shared memory segment at &lt;code&gt;POS&lt;/code&gt; . Returns true if successful, or false if there is an error. See &lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;POS&lt;/code&gt; の共有メモリセグメントに &lt;code&gt;SIZE&lt;/code&gt; バイトを書き込みます。成功した場合はtrue、エラーが発生した場合はfalseを返します。&lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwriteを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c4d6106f35288022310ffee038cda3aae849b282" translate="yes" xml:space="preserve">
          <source>Write MYMETA information to MYMETA.json and MYMETA.yml.</source>
          <target state="translated">MYMETA.jsonとMYMETA.ymlにMYMETA情報を書き込む。</target>
        </trans-unit>
        <trans-unit id="a9b6c91570493bdee3be6eef5a6b183ad756cdab" translate="yes" xml:space="preserve">
          <source>Write RFC 1950 files/buffers</source>
          <target state="translated">RFC 1950 のファイル/バッファを書き込む</target>
        </trans-unit>
        <trans-unit id="0909abf68380a212e21e5479f6396ce54f63b785" translate="yes" xml:space="preserve">
          <source>Write RFC 1951 files/buffers</source>
          <target state="translated">RFC 1951 のファイル/バッファを書き込む</target>
        </trans-unit>
        <trans-unit id="0a1ef998109ed3777e0f667818ad2c1c3ea0b70e" translate="yes" xml:space="preserve">
          <source>Write RFC 1952 files/buffers</source>
          <target state="translated">RFC 1952 のファイル/バッファを書き込む</target>
        </trans-unit>
        <trans-unit id="e52a7d8ae8bb89850d8b0bad0931a61da15a6992" translate="yes" xml:space="preserve">
          <source>Write YAMLish data</source>
          <target state="translated">YAMLishデータの書き込み</target>
        </trans-unit>
        <trans-unit id="77878a047db48550e0d5361bfb44d185b930e978" translate="yes" xml:space="preserve">
          <source>Write a formatter as a Pod::Simple subclass</source>
          <target state="translated">Pod::Simpleのサブクラスとしてフォーマッタを書く</target>
        </trans-unit>
        <trans-unit id="bc54db5c1b3d5ac212fb800fdd56f965140da3e5" translate="yes" xml:space="preserve">
          <source>Write access via git</source>
          <target state="translated">git による書き込みアクセス</target>
        </trans-unit>
        <trans-unit id="935636e37a0f4339394c64f63b5cea6433c1f963" translate="yes" xml:space="preserve">
          <source>Write an entry, whose name is equivalent to the file name provided to disk. Optionally takes a second parameter, which is the full native path (including filename) the entry will be written to.</source>
          <target state="translated">ディスクに与えられたファイル名と同じ名前のエントリを書き込みます。オプションで、2 番目のパラメータとして、エントリの書き込まれるネイティブパス (ファイル名を含む)を指定します。</target>
        </trans-unit>
        <trans-unit id="5769fe16b9b0cad42af9406c72e837bd0c18c816" translate="yes" xml:space="preserve">
          <source>Write bzip2 files/buffers</source>
          <target state="translated">bzip2 ファイル/バッファの書き込み</target>
        </trans-unit>
        <trans-unit id="bafb7482744edca206da4c0baa12b4a11269c914" translate="yes" xml:space="preserve">
          <source>Write documentation in POD</source>
          <target state="translated">PODでドキュメントを書く</target>
        </trans-unit>
        <trans-unit id="01995de03181a3f8adb7e727e73e6dc5e4e106c7" translate="yes" xml:space="preserve">
          <source>Write files whose names are equivalent to any of the names in &lt;code&gt;@filenames&lt;/code&gt; to disk, creating subdirectories as necessary. This might not work too well under VMS. Under MacPerl, the file's modification time will be converted to the MacOS zero of time, and appropriate conversions will be done to the path. However, the length of each element of the path is not inspected to see whether it's longer than MacOS currently allows (32 characters).</source>
          <target state="translated">&lt;code&gt;@filenames&lt;/code&gt; の名前のいずれかと同じ名前のファイルをディスクに書き込み、必要に応じてサブディレクトリを作成します。これはVMSではうまく機能しない可能性があります。MacPerlでは、ファイルの変更時刻はMacOSのゼロの時刻に変換され、パスに対して適切な変換が行われます。ただし、パスの各要素の長さは、MacOSが現在許可している長さ（32文字）よりも長いかどうかを調べるために検査されません。</target>
        </trans-unit>
        <trans-unit id="cbcd4ec744f6a0cc7a8100b555d7a1173e6952f5" translate="yes" xml:space="preserve">
          <source>Write linker options files for dynamic extension</source>
          <target state="translated">動的拡張子用のリンカオプションファイルを書く</target>
        </trans-unit>
        <trans-unit id="dc5fd755a4779cecce293a2a1e919899f32cdf21" translate="yes" xml:space="preserve">
          <source>Write the C code for perlmain.c</source>
          <target state="translated">perlmain.cのCコードを書く</target>
        </trans-unit>
        <trans-unit id="0a8eff4063a82696c6af1e9ea9cf555d97a3ea2c" translate="yes" xml:space="preserve">
          <source>Write the in-memory archive to disk. The first argument can either be the name of a file or a reference to an already open filehandle (a GLOB reference).</source>
          <target state="translated">インメモリ・アーカイブをディスクに書き込む。最初の引数には、ファイル名か、既に開いているファイルハンドルへの参照 (GLOB参照)のいずれかを指定します。</target>
        </trans-unit>
        <trans-unit id="af8f82dc202f24f05f3598bed445a87ed08771b7" translate="yes" xml:space="preserve">
          <source>Write the state to a file.</source>
          <target state="translated">状態をファイルに書き込む。</target>
        </trans-unit>
        <trans-unit id="5ea3036e84ed65b742580afd08f2cf97f36ee5c9" translate="yes" xml:space="preserve">
          <source>Write to a file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">ファイルに書き込みます。これは、 &lt;code&gt;POSIX::open&lt;/code&gt; 呼び出すことによって取得されるようなファイル記述子を使用します。</target>
        </trans-unit>
        <trans-unit id="fff8491fc63b40787a6bc354a1c28b21cd65c0f1" translate="yes" xml:space="preserve">
          <source>Write to modules@perl.org explaining what you did to contact the current maintainer. The PAUSE admins will also try to reach the maintainer.</source>
          <target state="translated">現在のメンテナと連絡を取るために何をしたかを modules@perl.org に書いてください。PAUSEの管理者もメンテナに連絡を取ろうとします。</target>
        </trans-unit>
        <trans-unit id="ec3b4c2700310731999e0d7e25df0c587f5a195d" translate="yes" xml:space="preserve">
          <source>Write zip files/buffers</source>
          <target state="translated">zipファイル/バッファの書き込み</target>
        </trans-unit>
        <trans-unit id="08d9173120127debf58115903083c7548d3871d3" translate="yes" xml:space="preserve">
          <source>Write-only access to the data in the file.</source>
          <target state="translated">ファイル内のデータへの書き込み専用アクセス。</target>
        </trans-unit>
        <trans-unit id="94dee2fafe1d10d5ce6db659eb0c0fcb3d5842be" translate="yes" xml:space="preserve">
          <source>WriteFile</source>
          <target state="translated">WriteFile</target>
        </trans-unit>
        <trans-unit id="8a1db595bd4c07aab5da69c69b2b0b595010f3b7" translate="yes" xml:space="preserve">
          <source>WriteMakefile() now does some basic sanity checks on its parameters to protect against typos and malformatted values. This means some things which happened to work in the past will now throw warnings and possibly produce internal errors.</source>
          <target state="translated">WriteMakefile()は、タイプミスや不正フォーマットされた値から保護するために、 パラメータに対していくつかの基本的なサニティチェックを行うようになりました。これは、これまで動作していたものが警告を投げたり、内部エラーを発生させたりするようになったことを意味しています。</target>
        </trans-unit>
        <trans-unit id="6e814e2d111b3599c2bf1ca192478a3ffbfc4053" translate="yes" xml:space="preserve">
          <source>WriteMakefileSnippet ATTRIBUTE =&amp;gt; VALUE [, ...]</source>
          <target state="translated">WriteMakefileSnippet ATTRIBUTE =&amp;gt; VALUE [、...]</target>
        </trans-unit>
        <trans-unit id="7bdbf771b888449a861406dd116d15dd91371055" translate="yes" xml:space="preserve">
          <source>Writes SIZE bytes from STRING to a memory segment at ADDR starting at position POS. If STRING is too long, only SIZE bytes are used; if STRING is too short, nulls are written to fill out SIZE bytes. Returns true if successful, or false if there is an error.</source>
          <target state="translated">STRINGからPOSから始まるADDRのメモリセグメントにSIZEバイトを書き込みます。STRINGが長すぎる場合はSIZEバイトのみが使用され、STRINGが短すぎる場合はSIZEバイトを埋めるためにnullsが書き込まれます。成功した場合はtrue、エラーの場合はfalseを返します。</target>
        </trans-unit>
        <trans-unit id="5d0ca93d68b5dc214818ef186a1bc3e2b3d7c8cd" translate="yes" xml:space="preserve">
          <source>Writes a file of C code and a file of XS code which you should &lt;code&gt;#include&lt;/code&gt; and &lt;code&gt;INCLUDE&lt;/code&gt; in the C and XS sections respectively of your module's XS code. You probably want to do this in your &lt;code&gt;Makefile.PL&lt;/code&gt; , so that you can easily edit the list of constants without touching the rest of your module. The attributes supported are</source>
          <target state="translated">モジュールのXSコードのCおよびXSセクシ​​ョンにそれぞれ &lt;code&gt;#include&lt;/code&gt; および &lt;code&gt;INCLUDE&lt;/code&gt; する必要があるCコードのファイルとXSコードのファイルを書き込みます。あなたはおそらくあなたにこれをやりたい &lt;code&gt;Makefile.PL&lt;/code&gt; 簡単にあなたのモジュールの残りの部分を触れることなく、定数のリストを編集することができますのでこと、。サポートされる属性は</target>
        </trans-unit>
        <trans-unit id="68caf753088df284b27998c0bc22c79c995c9f8a" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function) may be set explicitly by assigning the name of the format to the &lt;code&gt;$~&lt;/code&gt; variable.</source>
          <target state="translated">指定されたFILEHANDLEに、そのファイルに関連付けられたフォーマットを使用して、フォーマットされたレコード（おそらく複数行）を書き込みます。デフォルトでは、ファイルの形式はファイルハンドルと同じ名前の形式ですが、現在の出力チャネル（ &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 関数を参照）の形式は、 &lt;code&gt;$~&lt;/code&gt; 変数に形式の名前を割り当てることで明示的に設定できます。</target>
        </trans-unit>
        <trans-unit id="3c8b534fc59790f52bbc323708c6a448e4336f1e" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function) may be set explicitly by assigning the name of the format to the &lt;code&gt;$~&lt;/code&gt; variable.</source>
          <target state="translated">指定されたFILEHANDLEに、そのファイルに関連付けられたフォーマットを使用して、フォーマットされたレコード（おそらく複数行）を書き込みます。デフォルトでは、ファイルの形式はファイルハンドルと同じ名前の形式ですが、現在の出力チャネル（ &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 関数を参照）の形式は、 &lt;code&gt;$~&lt;/code&gt; 変数に形式の名前を割り当てることで明示的に設定できます。</target>
        </trans-unit>
        <trans-unit id="4e8961057173b914aa902d24e81d3c55d00dde52" translate="yes" xml:space="preserve">
          <source>Writes all files in and below the current directory to your</source>
          <target state="translated">カレントディレクトリ以下のすべてのファイルを</target>
        </trans-unit>
        <trans-unit id="1ff3060cc065fe5dcf829a42d2a8d401fd64f6d8" translate="yes" xml:space="preserve">
          <source>Writes an empty FORCE: target.</source>
          <target state="translated">空の FORCE:target を書き込みます。</target>
        </trans-unit>
        <trans-unit id="f5369d43b2f75bf65f1c9b2bf55177161b67ef85" translate="yes" xml:space="preserve">
          <source>Writes are permitted, i.e. opened as &quot;w&quot; or &quot;r+&quot; or &quot;a&quot;, etc.</source>
          <target state="translated">書き込みが許可されており、&quot;w &quot;や &quot;r+&quot;や &quot;a &quot;などのようにオープンされています。</target>
        </trans-unit>
        <trans-unit id="bc03658e3c61d9705d37afb50e35b60738df57d4" translate="yes" xml:space="preserve">
          <source>Writes the contents of &lt;code&gt;$buffer&lt;/code&gt; to the compressed file. Returns the number of bytes actually written, or 0 on error.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; の内容を圧縮ファイルに書き込みます。実際に書き込まれたバイト数を返します。エラーの場合は0を返します。</target>
        </trans-unit>
        <trans-unit id="3b30b2d9d9b94819a1a73fa66ad9fdb3aaf93cb5" translate="yes" xml:space="preserve">
          <source>Writes the file META.yml (YAML encoded meta-data) and META.json (JSON encoded meta-data) about the module in the distdir. The format follows Module::Build's as closely as possible.</source>
          <target state="translated">モジュールに関する META.yml (YAML エンコードされたメタデータ)と META.json (JSON エンコードされたメタデータ)を distdir に書き込みます。書式は Module::Build のものにできるだけ忠実に従います。</target>
        </trans-unit>
        <trans-unit id="759cd7af683913d2e067b4f6ffe525a9a1d4a391" translate="yes" xml:space="preserve">
          <source>Writes the file SIGNATURE with &quot;cpansign -s&quot;.</source>
          <target state="translated">cpansign -s &quot;でsignatureファイルを書き込みます。</target>
        </trans-unit>
        <trans-unit id="284cf58439290385abdec38ca7c004471227b097" translate="yes" xml:space="preserve">
          <source>Writes the output of</source>
          <target state="translated">の出力を書き込みます。</target>
        </trans-unit>
        <trans-unit id="fdd8d478482d63bc406cd41436757960d17780fb" translate="yes" xml:space="preserve">
          <source>Writing Accessors</source>
          <target state="translated">ライティングアクセサ</target>
        </trans-unit>
        <trans-unit id="1986c44b3bdced950b196d1c43f6cf37a6963d63" translate="yes" xml:space="preserve">
          <source>Writing Constructors</source>
          <target state="translated">コンストラクタの記述</target>
        </trans-unit>
        <trans-unit id="ac0e44a3a37a4109877068f7584a4c6e490675d8" translate="yes" xml:space="preserve">
          <source>Writing Perl on an EBCDIC platform is really no different than writing on an &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; one, but with different underlying numbers, as we'll see shortly. You'll have to know something about those &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; platforms because the documentation is biased and will frequently use example numbers that don't apply to EBCDIC. There are also very few CPAN modules that are written for EBCDIC and which don't work on ASCII; instead the vast majority of CPAN modules are written for ASCII, and some may happen to work on EBCDIC, while a few have been designed to portably work on both.</source>
          <target state="translated">EBCDICプラットフォームでPerlを作成することは、&lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt;で作成することと実際に違いはありませんが、後で説明するように、基になる数値が異なります。ドキュメントには偏りがあり、EBCDICに適用されない例の数値を頻繁に使用するため、これらの&lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt;プラットフォームについて何か知っておく必要があります。また、EBCDIC用に作成され、ASCIIで動作しないCPANモジュールもほとんどありません。代わりに、CPANモジュールの大部分はASCII用に作成されており、一部はEBCDICで動作する可能性がありますが、一部は両方で移植可能に動作するように設計されています。</target>
        </trans-unit>
        <trans-unit id="b3e7a0572dc689213dcccc6f0ad9b2cbd894a46a" translate="yes" xml:space="preserve">
          <source>Writing Plugins</source>
          <target state="translated">プラグインの書き方</target>
        </trans-unit>
        <trans-unit id="b23e7b02c4f050eb7a5f668109f71a414a28c33d" translate="yes" xml:space="preserve">
          <source>Writing Your Own Debugger</source>
          <target state="translated">独自のデバッガを書く</target>
        </trans-unit>
        <trans-unit id="12d7ef5d9c4d923fdecfc0a2ba03562ba21e7e82" translate="yes" xml:space="preserve">
          <source>Writing a Filter</source>
          <target state="translated">フィルタの書き方</target>
        </trans-unit>
        <trans-unit id="7f135a17864ace6ae98bf7a3b9d9b4e20dd72358" translate="yes" xml:space="preserve">
          <source>Writing a module with MakeMaker</source>
          <target state="translated">MakeMakerでモジュールを書く</target>
        </trans-unit>
        <trans-unit id="f103eaa4bfb0cd111ad63870dfe99daf1dbfeefb" translate="yes" xml:space="preserve">
          <source>Writing a source filter as a separate executable works fine, but a small performance penalty is incurred. For example, if you execute the small example above, a separate subprocess will be created to run the Unix &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; command. Each use of the filter requires its own subprocess. If creating subprocesses is expensive on your system, you might want to consider one of the other options for creating source filters.</source>
          <target state="translated">ソースフィルターを個別の実行可能ファイルとして書き込むと問題なく動作しますが、パフォーマンスが少し低下します。たとえば、上の小さな例を実行すると、別のサブプロセスが作成され、Unix &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; コマンドを実行します。フィルターを使用するたびに、独自のサブプロセスが必要です。システムでサブプロセスの作成に負荷がかかる場合は、ソースフィルターを作成するための他のオプションの1つを検討することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="fc88b791ccf860fd9df472625687a215e4594f7f" translate="yes" xml:space="preserve">
          <source>Writing backticks in your program sends a clear message to the readers of your code that you wanted to collect the output of the command. Why send a clear message that isn't true?</source>
          <target state="translated">あなたのプログラムにバックティックを書くことは、あなたがコマンドの出力を収集したかったという明確なメッセージをコードの読者に送ります。なぜ真ではない明確なメッセージを送るのでしょうか?</target>
        </trans-unit>
        <trans-unit id="a44149bd1f420e38e67feec9febfbe47dcef5694" translate="yes" xml:space="preserve">
          <source>Writing good test scripts</source>
          <target state="translated">良いテストスクリプトを書く</target>
        </trans-unit>
        <trans-unit id="0d1216f3de5359a11d177bd450454690960a8410" translate="yes" xml:space="preserve">
          <source>Writing subroutines</source>
          <target state="translated">サブルーチンの書き方</target>
        </trans-unit>
        <trans-unit id="a553ca3bc37b04388da0cff3bc379f04cee8df42" translate="yes" xml:space="preserve">
          <source>Writing subroutines is easy:</source>
          <target state="translated">サブルーチンを書くのは簡単です。</target>
        </trans-unit>
        <trans-unit id="c828d0e28e2f569743446e2de56ca66e456c09b7" translate="yes" xml:space="preserve">
          <source>Writing the patch</source>
          <target state="translated">パッチを書く</target>
        </trans-unit>
        <trans-unit id="5c10b682e330dccc302170e80493f9eb65449a91" translate="yes" xml:space="preserve">
          <source>Writing the short option first is recommended because it's easier to read. The long option is long enough to draw the eye to it anyway and the short option can otherwise get lost in visual noise.</source>
          <target state="translated">短い方が読みやすいので、短い方を先に書くことをお勧めします。長いオプションはとにかく目を惹くのに十分な長さがあり、短いオプションはそうでなければ視覚的なノイズの中で迷子になってしまうことがあります。</target>
        </trans-unit>
        <trans-unit id="1b1d022be94ce5d1101d118c8c80cf3364019b48" translate="yes" xml:space="preserve">
          <source>Writing typemap Entries</source>
          <target state="translated">タイプマップの書き方 エントリー</target>
        </trans-unit>
        <trans-unit id="1292edaa487b14cb74f82d4343628858075e0756" translate="yes" xml:space="preserve">
          <source>Wrong: the Storable engine creates an empty one for you. If you know Eiffel, you can view &lt;code&gt;STORABLE_thaw&lt;/code&gt; as an alternate creation routine.</source>
          <target state="translated">誤り：Storableエンジンが空のエンジンを作成します。エッフェルを知っている場合は、 &lt;code&gt;STORABLE_thaw&lt;/code&gt; を別の作成ルーチンと見なすことができます。</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="7a5fc108bfdd5d96d6f99a6eac89c9af874db7d8" translate="yes" xml:space="preserve">
          <source>XPG operability often implies the presence of an</source>
          <target state="translated">XPGの操作性は、しばしば</target>
        </trans-unit>
        <trans-unit id="0f082b9799dcb8475e7d6fcb04a5adfa774635d5" translate="yes" xml:space="preserve">
          <source>XPUSH args AND set RETVAL AND assign return value to array</source>
          <target state="translated">XPUSH argsとRETVALを設定し、配列に戻り値を代入します。</target>
        </trans-unit>
        <trans-unit id="bdb1d0d2760db0ae33b02dff5258e945e708b990" translate="yes" xml:space="preserve">
          <source>XS</source>
          <target state="translated">XS</target>
        </trans-unit>
        <trans-unit id="92bd1887109d3a53eb97d00630c2016c2f9abe52" translate="yes" xml:space="preserve">
          <source>XS VERSION</source>
          <target state="translated">XSバージョン</target>
        </trans-unit>
        <trans-unit id="f150c9e4da4e74cdaf804a24288dd2d36c2aab56" translate="yes" xml:space="preserve">
          <source>XS code added by Greg Bacon &amp;lt;</source>
          <target state="translated">Greg Baconによって追加されたXSコード&amp;lt;</target>
        </trans-unit>
        <trans-unit id="1cf142c571c2183260c4664ac183845da5980944" translate="yes" xml:space="preserve">
          <source>XS code can usually be made to work with any platform, but dependent libraries, header files, etc., might not be readily available or portable, or the XS code itself might be platform-specific, just as Perl code might be. If the libraries and headers are portable, then it is normally reasonable to make sure the XS code is portable, too.</source>
          <target state="translated">XSのコードは通常、どのプラットフォームでも動作するようにすることができますが、依存するライブラリやヘッダファイルなどは、容易に入手できなかったり、移植性がなかったり、XSのコード自体がPerlのコードのようにプラットフォーム固有のものだったりします。ライブラリやヘッダが移植可能であれば、XSのコードも移植可能であることを確認するのが一般的です。</target>
        </trans-unit>
        <trans-unit id="7e8ccd1927a425f4cd71fc5858f4ce61be503a94" translate="yes" xml:space="preserve">
          <source>XS code for using native C functions borrowed from &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt;, written by Marcus Harnisch &amp;lt;</source>
          <target state="translated">Marcus Harnischによって作成された &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt; から借用したネイティブC関数を使用するためのXSコード&amp;lt;</target>
        </trans-unit>
        <trans-unit id="fe30568ef2d4c300e100572dbcce63bef5e87790" translate="yes" xml:space="preserve">
          <source>XS code has full access to system calls including C library functions. It thus has the capability of interfering with things that the Perl core or other modules have set up, such as signal handlers or file handles. It could mess with the memory, or any number of harmful things. Don't.</source>
          <target state="translated">XS のコードは、C ライブラリの関数を含むシステムコールに完全にアクセスすることができます。そのため、シグナルハンドラやファイルハンドルなど、Perlコアや他のモジュールが設定したものを妨害する能力を持っています。メモリに干渉したり、有害なことをする可能性があります。しないでください。</target>
        </trans-unit>
        <trans-unit id="33d48b61f9e9a038a7aea1ef00483763c58f6eff" translate="yes" xml:space="preserve">
          <source>XS code is probably better using &quot;typemap&quot; if it expects FILE * arguments. The standard typemap will be adjusted to comprehend any changes in this area.</source>
          <target state="translated">XSのコードは、FILE *の引数を期待している場合は、&quot;typemap &quot;を使った方が良いかもしれません。標準のタイプマップは、この部分の変更を理解するように調整されます。</target>
        </trans-unit>
        <trans-unit id="89e8c193e223b649f3d44b4194d19ce56bb23e01" translate="yes" xml:space="preserve">
          <source>XS code is very sensitive to the module version number and will complain if the version number in your Perl module doesn't match. If you change your module's version # without rerunning Makefile.PL the old version number will remain in the Makefile, causing the XS code to be built with the wrong number.</source>
          <target state="translated">XSのコードはモジュールのバージョン番号に非常に敏感で、Perlモジュールのバージョン番号が一致しないと文句を言います。Makefile.PL を再実行せずにモジュールのバージョン番号を変更すると、古いバージョン番号が Makefile に残り、XS コードが間違った番号でビルドされてしまいます。</target>
        </trans-unit>
        <trans-unit id="def563b19b3d7a04b960dc4d401ac89d52a4e717" translate="yes" xml:space="preserve">
          <source>XS is an interface description file format used to create an extension interface between Perl and C code (or a C library) which one wishes to use with Perl. The XS interface is combined with the library to create a new library which can then be either dynamically loaded or statically linked into perl. The XS interface description is written in the XS language and is the core component of the Perl extension interface.</source>
          <target state="translated">XSは、PerlとCコード(またはCライブラリ)の間の拡張インターフェースを作成するために使用されるインターフェース記述ファイル形式です。XSインタフェースはライブラリと結合されて新しいライブラリを作成し、動的に読み込まれたり、Perlに静的にリンクされたりすることができます。XSインタフェースの説明はXS言語で書かれており、Perl拡張インタフェースのコアコンポーネントとなっています。</target>
        </trans-unit>
        <trans-unit id="c6e0da0571ab8b6cd13332fb1b92e13ef69723c3" translate="yes" xml:space="preserve">
          <source>XS modules for all categories but &lt;code&gt;LC_NUMERIC&lt;/code&gt; get the underlying locale, and hence any C library functions they call will use that underlying locale. For more discussion, see &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;CAVEATS in perlxs&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;LC_NUMERIC&lt;/code&gt; を除くすべてのカテゴリのXSモジュールは、基になるロケールを取得するため、それらが呼び出すすべてのCライブラリ関数は、その基になるロケールを使用します。詳細については、&lt;a href=&quot;perlxs#CAVEATS&quot;&gt;perlxsの警告を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cde8f9f4aa7dc1d35b0c98fee87c3ff3dfbc220c" translate="yes" xml:space="preserve">
          <source>XS-type modules do require re-linking the perl binary, because part of an XS module is written in &quot;C&quot;, and has to be linked together with the perl binary to be executed. This is required because perl under DJGPP is built with the &quot;static link&quot; option, due to the lack of &quot;dynamic linking&quot; in the DJGPP environment.</source>
          <target state="translated">XS型モジュールの一部は &quot;C &quot;で書かれており、実行するためにはPerlのバイナリと一緒にリンクする必要があるため、XS型モジュールはPerlのバイナリを再リンクする必要があります。これは、DJGPP環境では「動的リンク」がないため、DJGPP環境のperlは「静的リンク」オプションでビルドされているために必要となります。</target>
        </trans-unit>
        <trans-unit id="69f57ba624b38c0aa8389aea0ffe9fd217df0165" translate="yes" xml:space="preserve">
          <source>XSLoader</source>
          <target state="translated">XSLoader</target>
        </trans-unit>
        <trans-unit id="afd8fa1c6f48c528375edb581b5cfae64284c5a7" translate="yes" xml:space="preserve">
          <source>XSLoader - Dynamically load C libraries into Perl code</source>
          <target state="translated">XSLoader-Perl コードに C ライブラリを動的にロードする</target>
        </trans-unit>
        <trans-unit id="4579138c9695c3de09b5142af11ef81d8446e749" translate="yes" xml:space="preserve">
          <source>XSUB.h</source>
          <target state="translated">XSUB.h</target>
        </trans-unit>
        <trans-unit id="4df5cfe3d83127b158a7d5a161b5570785b675ad" translate="yes" xml:space="preserve">
          <source>XSUBs and the Argument Stack</source>
          <target state="translated">XSUBと引数スタック</target>
        </trans-unit>
        <trans-unit id="3b5999991ea7d60b38c8ca1802a3aa2e3198b825" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to avoid automatic conversion of Perl function arguments to C function arguments. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details. Some people prefer manual conversion by inspecting &lt;code&gt;ST(i)&lt;/code&gt; even in the cases when automatic conversion will do, arguing that this makes the logic of an XSUB call clearer. Compare with &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;Getting the fat out of XSUBs&lt;/a&gt; for a similar tradeoff of a complete separation of &quot;Perl glue&quot; and &quot;workhorse&quot; parts of an XSUB.</source>
          <target state="translated">XSUBは、Perl関数の引数からC関数の引数への自動変換を回避することもできます。詳細については&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;を参照してください。一部の人々は、自動変換が行われる場合でも &lt;code&gt;ST(i)&lt;/code&gt; を検査することにより手動変換を好み、これによりXSUB呼び出しのロジックがより明確になると主張します。&lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;XSUB&lt;/a&gt;の「Perl接着剤」と「主力」の部分を完全に分離するという同様のトレードオフについては、XSUBから脂肪を取り除くことと比較してください。</target>
        </trans-unit>
        <trans-unit id="54080bcfea2adf5c913b064ead22f355c2ce0033" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to return lists, not just scalars. This must be done by manipulating stack values ST(0), ST(1), etc, in a subtly different way. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details.</source>
          <target state="translated">XSUBは、スカラーだけでなく、リストを返すこともできます。これは、スタック値ST（0）、ST（1）などを微妙に異なる方法で操作することによって実行する必要があります。詳細については&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="88b3157d6a7563b7eeae312db4f170271aab7d57" translate="yes" xml:space="preserve">
          <source>XSUBs can have variable-length parameter lists by specifying an ellipsis &lt;code&gt;(...)&lt;/code&gt; in the parameter list. This use of the ellipsis is similar to that found in ANSI C. The programmer is able to determine the number of arguments passed to the XSUB by examining the &lt;code&gt;items&lt;/code&gt; variable which the &lt;b&gt;xsubpp&lt;/b&gt; compiler supplies for all XSUBs. By using this mechanism one can create an XSUB which accepts a list of parameters of unknown length.</source>
          <target state="translated">XSUBは、パラメーターリストで省略記号 &lt;code&gt;(...)&lt;/code&gt; を指定することにより、可変長パラメーターリストを持つことができます。省略記号のこの使用法は、ANSI Cにあるものと似ています。プログラマーは、&lt;b&gt;xsubpp&lt;/b&gt;コンパイラーがすべてのXSUBに提供する &lt;code&gt;items&lt;/code&gt; 変数を調べることにより、XSUBに渡される引数の数を判別できます。このメカニズムを使用することで、長さが不明なパラメーターのリストを受け入れるXSUBを作成できます。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3f2e0ddc3d17d87460a2a8a983be1c97c83b73d1" translate="yes" xml:space="preserve">
          <source>XSUBs do not have a CvPADLIST. dXSTARG fetches values from PL_curpad, but that is really the callers pad (a slot of which is allocated by every entersub). Do not get or set CvPADLIST if a CV is an XSUB (as determined by &lt;code&gt;CvISXSUB()&lt;/code&gt; ), CvPADLIST slot is reused for a different internal purpose in XSUBs.</source>
          <target state="translated">XSUBにはCvPADLISTがありません。dXSTARGはPL_curpadから値をフェッチしますが、これは実際には発信者パッドです（そのスロットはすべてのentersubによって割り当てられます）。CVがXSUB（ &lt;code&gt;CvISXSUB()&lt;/code&gt; によって決定される）である場合、CvPADLISTを取得または設定しないでください。CvPADLISTスロットは、XSUBの別の内部目的で再利用されます。</target>
        </trans-unit>
        <trans-unit id="6daf3f5f97a3cf191b47d0b650ffb497515d3ee1" translate="yes" xml:space="preserve">
          <source>XSUBs refer to their stack arguments with the macro &lt;b&gt;ST(x)&lt;/b&gt;, where</source>
          <target state="translated">XSUBはスタック引数をマクロ&lt;b&gt;ST（x）&lt;/b&gt;で参照します。</target>
        </trans-unit>
        <trans-unit id="45e92c706e14fc42e8a65549cfb504f51b80720e" translate="yes" xml:space="preserve">
          <source>XS_DEFINE_VERSION: -D line to set the xs version when compiling.</source>
          <target state="translated">XS_DEFINE_VERSION:-D 行でコンパイル時に xs のバージョンを設定します。</target>
        </trans-unit>
        <trans-unit id="0b91e170805a05f3fc3b4f1fe3e1c801a51a5cd9" translate="yes" xml:space="preserve">
          <source>XS_FILE</source>
          <target state="translated">XS_FILE</target>
        </trans-unit>
        <trans-unit id="c30e58ff83929eb55292bc3f56bfb117c5d6b82f" translate="yes" xml:space="preserve">
          <source>XS_SUBNAME</source>
          <target state="translated">XS_SUBNAME</target>
        </trans-unit>
        <trans-unit id="f6c7bf9f42bb6c2a25e194ec60219f0a8150edce" translate="yes" xml:space="preserve">
          <source>XS_VERSION: version in your .xs file. Defaults to $(VERSION)</source>
          <target state="translated">XS_VERSION:.xs ファイルのバージョン。デフォルトは $(VERSION)です。</target>
        </trans-unit>
        <trans-unit id="53fccca1190b204bd667ec9d6791fd3b9d14df6c" translate="yes" xml:space="preserve">
          <source>XS_VERSION_MACRO: which macro represents the XS version.</source>
          <target state="translated">XS_VERSION_MACRO:XS のバージョンを表すマクロ。</target>
        </trans-unit>
        <trans-unit id="20026dc165c030fe3a5d9609a6e61ab26210cbc1" translate="yes" xml:space="preserve">
          <source>XX</source>
          <target state="translated">XX</target>
        </trans-unit>
        <trans-unit id="a9674b19f8c56f785c91a555d0a144522bb318e6" translate="yes" xml:space="preserve">
          <source>XXX</source>
          <target state="translated">XXX</target>
        </trans-unit>
        <trans-unit id="efc0ac66700effcf3b5c6d5cfb0d3ed1e5da5cc1" translate="yes" xml:space="preserve">
          <source>XXX DAPM it would make more sense to make the arg a PADOFFSET void SAVEPADSV(PADOFFSET po)</source>
          <target state="translated">XXX DAPMでは、引数をPADOFFSETにする方が理にかなっています。</target>
        </trans-unit>
        <trans-unit id="0a8c3822391bb958edc27b75e5a6c90f50363bce" translate="yes" xml:space="preserve">
          <source>XXX.</source>
          <target state="translated">XXX.</target>
        </trans-unit>
        <trans-unit id="759d5f762181a933d7c0ff7fd8096838ff6b5ec3" translate="yes" xml:space="preserve">
          <source>XXX: Needs more docs.</source>
          <target state="translated">XXX:もっとドキュメントが必要。</target>
        </trans-unit>
        <trans-unit id="e3a8809017dd76bd26557a5b923ab2ae16c0cdb3" translate="yes" xml:space="preserve">
          <source>XXXX</source>
          <target state="translated">XXXX</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="50bc04e009ed4a61bc2c2e4c00258238b3cec732" translate="yes" xml:space="preserve">
          <source>YAML result token.</source>
          <target state="translated">YAMLの結果トークン。</target>
        </trans-unit>
        <trans-unit id="bf4ca579becca81a75bf09eee1a917765b24f975" translate="yes" xml:space="preserve">
          <source>YMMV.</source>
          <target state="translated">YMMV.</target>
        </trans-unit>
        <trans-unit id="9a8fc610a3168e82e07390203ce40d7382c7da6f" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DDThh:mm:ss</source>
          <target state="translated">YYYY-MM-DDThh:mm:ss</target>
        </trans-unit>
        <trans-unit id="76ac22fb38468218ad6552d9043d5bb2c7920d48" translate="yes" xml:space="preserve">
          <source>Year Value Interpretation</source>
          <target state="translated">年値の解釈</target>
        </trans-unit>
        <trans-unit id="44f6289f7e3326b30824a187cdb204e4dc7264b2" translate="yes" xml:space="preserve">
          <source>Years greater than 999 are interpreted as being the actual year, rather than the offset from 1900. Thus, 1964 would indicate the year Martin Luther King won the Nobel prize, not the year 3864.</source>
          <target state="translated">999 より大きい年は、1900 年からのオフセットではなく、実際の年と解釈されます。したがって、1964年はマーティン・ルーサー・キングがノーベル賞を受賞した年であり、3864年ではないことを示しています。</target>
        </trans-unit>
        <trans-unit id="c9ec20e90ee8369d4a4738a1355fc718ca45a57e" translate="yes" xml:space="preserve">
          <source>Years in the range 0..99 are interpreted as shorthand for years in the rolling &quot;current century,&quot; defined as 50 years on either side of the current year. Thus, today, in 1999, 0 would refer to 2000, and 45 to 2045, but 55 would refer to 1955. Twenty years from now, 55 would instead refer to 2055. This is messy, but matches the way people currently think about two digit dates. Whenever possible, use an absolute four digit year instead.</source>
          <target state="translated">0~99の範囲の年は、現在の年の両側50年と定義されている「現在の世紀」の年の速記法として解釈されています。したがって、1999年の今日、0は2000年、45は2045年を意味しますが、55は1955年を意味します。20年後には、55年は2055年となります。これはややこしいですが、現在の人々の2桁の日付に対する考え方に合致しています。可能な限り、絶対4桁の年号を使用してください。</target>
        </trans-unit>
        <trans-unit id="862a9bbc8aa08db48d5ef905c8dc85be457e6ea8" translate="yes" xml:space="preserve">
          <source>Years in the range 100..999 are interpreted as offset from 1900, so that 112 indicates 2012. This rule also applies to years less than zero (but see note below regarding date range).</source>
          <target state="translated">100~999の範囲内の年は1900年からのオフセットとして解釈され、112は2012年を示します。この規則はゼロ未満の年にも適用されます(ただし、日付範囲については下記の注意事項を参照)。</target>
        </trans-unit>
        <trans-unit id="dfc439a506f8ca9ae872d5d02c2ad4c82b034c13" translate="yes" xml:space="preserve">
          <source>Yes it is, see previous answer. Since &lt;code&gt;Compress::Zlib&lt;/code&gt; and therefore &lt;code&gt;IO::Zlib&lt;/code&gt; doesn't support &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; on their filehandles, there is little choice but to read the archive into memory. This is ok if you want to do in-memory manipulation of the archive.</source>
          <target state="translated">はい、前の回答を参照してください。以来 &lt;code&gt;Compress::Zlib&lt;/code&gt; ため、 &lt;code&gt;IO::Zlib&lt;/code&gt; サポートしていません &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 彼らのファイルハンドルの上に、選択の余地はなくメモリにアーカイブを読むことがあります。これは、アーカイブをメモリ内で操作したい場合は問題ありません。</target>
        </trans-unit>
        <trans-unit id="acb5099459bfa43931dd4b78a628e1d113168a69" translate="yes" xml:space="preserve">
          <source>Yes it is. It's pure perl, so it's a lot slower then your &lt;code&gt;/bin/tar&lt;/code&gt; However, it's very portable. If speed is an issue, consider using &lt;code&gt;/bin/tar&lt;/code&gt; instead.</source>
          <target state="translated">はい、そうです。純粋なperlなので、 &lt;code&gt;/bin/tar&lt;/code&gt; よりもはるかに遅くなりますが、非常に移植性があります。速度が問題になる場合は、代わりに &lt;code&gt;/bin/tar&lt;/code&gt; の使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="4107dbe8a030ec286ba38d4f763957128d667542" translate="yes" xml:space="preserve">
          <source>Yes, it does</source>
          <target state="translated">はい、そうですね</target>
        </trans-unit>
        <trans-unit id="3678471c058284ba4000bf6331c346c6bbd02a28" translate="yes" xml:space="preserve">
          <source>Yes, that's a lot of expansion.</source>
          <target state="translated">はい、それはそれで拡張性が高いですね。</target>
        </trans-unit>
        <trans-unit id="eb5a8cd62389870da5aba481f01f1a18a4a6e511" translate="yes" xml:space="preserve">
          <source>Yes, there's a lot of that :-) But more precisely, in UNIX systems there's a utility called &lt;code&gt;file&lt;/code&gt; , which recognizes data files based on their contents (usually their first few bytes). For this to work, a certain file called</source>
          <target state="translated">はい、それはたくさんあります:-)しかし、より正確には、UNIXシステムには、 &lt;code&gt;file&lt;/code&gt; （通常は最初の数バイト）に基づいてデータファイルを認識するfileと呼ばれるユーティリティがあります。これが機能するために、</target>
        </trans-unit>
        <trans-unit id="dc1e472e45c46619f7f9549ce98213f0173da937" translate="yes" xml:space="preserve">
          <source>Yes, you can do this by either using the &lt;code&gt;-T&lt;/code&gt; option, or by invoking the program as &lt;code&gt;perlthanks&lt;/code&gt; . Thank-you notes are good. It makes people smile.</source>
          <target state="translated">はい、これを行うには、 &lt;code&gt;-T&lt;/code&gt; オプションを使用するか、プログラムを &lt;code&gt;perlthanks&lt;/code&gt; として呼び出します。ありがとうメモはいいです。それは人々を笑顔にします。</target>
        </trans-unit>
        <trans-unit id="2c8d0f90fcceba5d3649946cef16ef6f0de57be0" translate="yes" xml:space="preserve">
          <source>Yes, you can! If your sources are UTF-8 encoded, you can indicate that with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma.</source>
          <target state="translated">はい、できます！ソースがUTF-8でエンコードされている &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; は、use utf8プラグマでそれを示すことができます。</target>
        </trans-unit>
        <trans-unit id="fd3c0b60626749e4fb04200f5ac37da9c3ba6f91" translate="yes" xml:space="preserve">
          <source>Yes, you could probably do the same thing with code like $token-&amp;gt;isa('Pod::Simple::PullParserEndToken'), but that's not so pretty as using just $token-&amp;gt;type, or even the following shortcuts:</source>
          <target state="translated">はい、おそらく$ token-&amp;gt; isa（ 'Pod :: Simple :: PullParserEndToken'）のようなコードで同じことを行うことができますが、これは$ token-&amp;gt; typeだけを使用したり、次のショートカットを使用したりするのと同じくらいきれいではありません。</target>
        </trans-unit>
        <trans-unit id="9ba10bd10462c10515a891999d5f144a0ef8db84" translate="yes" xml:space="preserve">
          <source>Yes. If you are building a web site with any level of interactivity (forms / users / databases), you will want to use a framework to make handling requests and responses easier.</source>
          <target state="translated">はい、もしあなたが任意のレベルのインタラクティブ性(フォーム/ユーザー/データベース)を持つWebサイトを構築しているのであれば、リクエストやレスポンスをより簡単に処理できるフレームワークを使用したいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="4131deed69500e1ce76a1aa4746c5be5d04540cb" translate="yes" xml:space="preserve">
          <source>Yes. Perl's garbage collection system takes care of this so everything works out right.</source>
          <target state="translated">そうですね。Perlのガベージコレクションシステムがこれを処理してくれるので、すべてが正しく動作します。</target>
        </trans-unit>
        <trans-unit id="3a7fae4176564291917eb6c0f952942b7ae63ec5" translate="yes" xml:space="preserve">
          <source>Yes. Read &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for more information. Some examples follow. (These assume standard Unix shell quoting rules.)</source>
          <target state="translated">はい。詳細&lt;a href=&quot;perlrun&quot;&gt;については&lt;/a&gt;、perlrunを参照してください。次にいくつかの例を示します。（これらは標準のUnixシェルの引用規則を想定しています。）</target>
        </trans-unit>
        <trans-unit id="85739d75a309637ea84dea150d48798fe5f385f6" translate="yes" xml:space="preserve">
          <source>Yet Another Compiler Compiler. A parser generator without which Perl probably would not have existed. See the file</source>
          <target state="translated">Yet Another Compiler コンパイラ。Perl が存在しなければ、おそらく Perl は存在しなかったであろうパーサジェネレータ。ファイルを参照してください。</target>
        </trans-unit>
        <trans-unit id="7fafe5e36aa3122413d32c6d4c8b4284bb245038" translate="yes" xml:space="preserve">
          <source>Yet another capturing group numbering technique (also as from Perl 5.10) deals with the problem of referring to groups within a set of alternatives. Consider a pattern for matching a time of the day, civil or military style:</source>
          <target state="translated">もう一つのグループ番号付けのテクニック(Perl 5.10 からのものもあります)は、選択肢のセットの中でグループを参照する問題に対処しています。一日の時間帯、市民や軍人のスタイルを一致させるためのパターンを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="a23e788a3e5975e13dc401fc7dc400a7d94469f5" translate="yes" xml:space="preserve">
          <source>Yet another framework for writing test scripts</source>
          <target state="translated">テストスクリプトを書くための別のフレームワーク</target>
        </trans-unit>
        <trans-unit id="50d7418e5885441f0de4ccbd54d601d8993cfb34" translate="yes" xml:space="preserve">
          <source>Yet another pseudo-class that NEXT.pm provides is &lt;code&gt;EVERY&lt;/code&gt; . Its behaviour is considerably simpler than that of the &lt;code&gt;NEXT&lt;/code&gt; family. A call to:</source>
          <target state="translated">NEXT.pmが提供するさらに別の疑似クラスは &lt;code&gt;EVERY&lt;/code&gt; です。その動作は、 &lt;code&gt;NEXT&lt;/code&gt; ファミリーの動作よりもかなり単純です。への呼び出し：</target>
        </trans-unit>
        <trans-unit id="807fa18eacfa8333a4615b7233d28577520ce46b" translate="yes" xml:space="preserve">
          <source>Yet another way is to assign to a &lt;code&gt;foreach&lt;/code&gt; loop</source>
          <target state="translated">さらに別の方法は、 &lt;code&gt;foreach&lt;/code&gt; ループに割り当てることです</target>
        </trans-unit>
        <trans-unit id="fb6a80ccd3cd48516fa10f2b5e43ec6135ec9451" translate="yes" xml:space="preserve">
          <source>Yet another way would be to use the Devel::Peek module:</source>
          <target state="translated">さらに別の方法としては、Devel::Peek モジュールを使用することです。</target>
        </trans-unit>
        <trans-unit id="c970e3f1e790a2a4cd28b40401902501b9bc2d74" translate="yes" xml:space="preserve">
          <source>Yields:</source>
          <target state="translated">Yields:</target>
        </trans-unit>
        <trans-unit id="f551936e2c614f3a2dff9203d64b57c373086792" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;do not&lt;/b&gt; call &lt;code&gt;setlogsock&lt;/code&gt; .</source>
          <target state="translated">あなたは&lt;b&gt;していない&lt;/b&gt;呼び出し &lt;code&gt;setlogsock&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="adc6962b12f722ff929475c965699bd91420b623" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must&lt;/b&gt; convert characters to UVs using the above functions if you're ever in a situation where you have to match UTF-8 and non-UTF-8 characters. You may not skip over UTF-8 characters in this case. If you do this, you'll lose the ability to match hi-bit non-UTF-8 characters; for instance, if your UTF-8 string contains &lt;code&gt;v196.172&lt;/code&gt; , and you skip that character, you can never match a &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(200)&lt;/a&gt;&lt;/code&gt; in a non-UTF-8 string. So don't do that!</source>
          <target state="translated">UTF-8と非UTF-8文字を一致させる必要がある場合は、上記の関数を使用して文字をUVに変換する&lt;b&gt;必要&lt;/b&gt;があります。この場合、UTF-8文字をスキップすることはできません。これを行うと、ハイビットの非UTF-8文字に一致する機能が失われます。たとえば、UTF-8文字列に &lt;code&gt;v196.172&lt;/code&gt; が含まれている場合、その文字をスキップすると、UTF-8以外の文字列の &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(200)&lt;/a&gt;&lt;/code&gt; に一致することはできません。だから、それをしないでください！</target>
        </trans-unit>
        <trans-unit id="84f6ab55499a431ab963225e1b323e598c043cac" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must&lt;/b&gt; have the BFD (-lbfd) library installed, otherwise &lt;code&gt;perl&lt;/code&gt; will fail to link. The BFD is usually distributed as part of the GNU binutils.</source>
          <target state="translated">あなたは&lt;b&gt;しなければならない&lt;/b&gt;、BFD（-lbfd）ライブラリがインストールされているそれ以外の場合は &lt;code&gt;perl&lt;/code&gt; のリンクに失敗します。BFDは通常、GNU binutilsの一部として配布されます。</target>
        </trans-unit>
        <trans-unit id="b5fb57ccedc3fdf63890d16c6dbd3e60731ff70f" translate="yes" xml:space="preserve">
          <source>You CAN say</source>
          <target state="translated">あなたは言うことができます</target>
        </trans-unit>
        <trans-unit id="f4ab9d853c38812e284656a7bf6f62a6214856cd" translate="yes" xml:space="preserve">
          <source>You already learned that a &lt;b&gt;method&lt;/b&gt; is a subroutine that operates on an object. You can think of a method as the things that an object can</source>
          <target state="translated">&lt;b&gt;メソッド&lt;/b&gt;はオブジェクトを操作するサブルーチンであることをすでに学びました。メソッドはオブジェクトができることと考えることができます</target>
        </trans-unit>
        <trans-unit id="9a0c2a8aac855d59d1e419df17c0d8362fab4ef6" translate="yes" xml:space="preserve">
          <source>You also cannot exit out of the sort block or subroutine using any of the loop control operators described in &lt;a href=&quot;../perlsyn&quot;&gt;perlsyn&lt;/a&gt; or with &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">また、&lt;a href=&quot;../perlsyn&quot;&gt;perlsynで&lt;/a&gt;説明されているループ制御演算子または &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; を使用して、ソートブロックまたはサブルーチンを終了することもできません。</target>
        </trans-unit>
        <trans-unit id="cce8f481cd5c5e068e4367b0b286efd66e3e8b5e" translate="yes" xml:space="preserve">
          <source>You also cannot exit out of the sort block or subroutine using any of the loop control operators described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; or with &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">また、&lt;a href=&quot;perlsyn&quot;&gt;perlsynで&lt;/a&gt;説明されているループ制御演算子または &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; を使用して、ソートブロックまたはサブルーチンを終了することもできません。</target>
        </trans-unit>
        <trans-unit id="6462e3c6fa18441789982aade2cc057d4a5754fa" translate="yes" xml:space="preserve">
          <source>You also don't have to use push(). You could just make a direct assignment if you knew where you wanted to put it:</source>
          <target state="translated">また、push()を使う必要もありません。どこに置くかわかっていれば直接代入すればいいだけです。</target>
        </trans-unit>
        <trans-unit id="762d8de62e5184e1ddd3f7df62b51251838a45ad" translate="yes" xml:space="preserve">
          <source>You also have to be careful about context. You can assign an array to a scalar to get the number of elements in the array. This only works for arrays, though:</source>
          <target state="translated">また、コンテキストにも注意が必要です。配列をスカラに代入して、配列の要素数を取得することができます。ただし、これは配列に対してのみ機能します。</target>
        </trans-unit>
        <trans-unit id="e9900e6006f63d330e774e6c340305cdfb9e9fa2" translate="yes" xml:space="preserve">
          <source>You also need dmake. See &lt;a href=&quot;#Make&quot;&gt;Make&lt;/a&gt; above on how to get it.</source>
          <target state="translated">dmakeも必要です。入手方法については、上記の&lt;a href=&quot;#Make&quot;&gt;Makeを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="ad4cae9e1d17ccae297619ff7a90fc58163adef4" translate="yes" xml:space="preserve">
          <source>You are allowed to use underscores (underbars) in numeric literals between digits for legibility (but not multiple underscores in a row: &lt;code&gt;23__500&lt;/code&gt; is not legal; &lt;code&gt;23_500&lt;/code&gt; is). You could, for example, group binary digits by threes (as for a Unix-style mode argument such as 0b110_100_100) or by fours (to represent nibbles, as in 0b1010_0110) or in other groups.</source>
          <target state="translated">数字の間の数値リテラルでは、読み &lt;code&gt;23__500&lt;/code&gt; するためにアンダースコア（アンダーバー）を使用できます（ただし、連続して複数のアンダースコアを使用することはできません：23__500は無効です; &lt;code&gt;23_500&lt;/code&gt; は有効です）。たとえば、2進数を3でグループ化する（Unixスタイルのモード引数（0b110_100_100など））か、4でグループ化する（0b1010_0110のようにニブルを表す）か、他のグループにグループ化できます。</target>
        </trans-unit>
        <trans-unit id="e9086be8aa3acbf107ed69aa30ed1efd2e29806d" translate="yes" xml:space="preserve">
          <source>You are chdir()'d to &lt;code&gt;$File::Find::dir&lt;/code&gt; when the function is called, unless &lt;code&gt;no_chdir&lt;/code&gt; was specified. Note that when changing to directories is in effect the root directory (</source>
          <target state="translated">&lt;code&gt;no_chdir&lt;/code&gt; が指定されていない限り、関数が呼び出されると &lt;code&gt;$File::Find::dir&lt;/code&gt; にchdir（）されます。ディレクトリに変更すると、実際にはルートディレクトリ（</target>
        </trans-unit>
        <trans-unit id="765a24f0e7b225890131f993a03189d4db8249a5" translate="yes" xml:space="preserve">
          <source>You are either using a copy of zlib that is older than version 1.2.0 or you want your application code to be able to run with as many different versions of zlib as possible.</source>
          <target state="translated">バージョン1.2.0よりも古いzlibを使用しているか、アプリケーションコードをできるだけ多くの異なるバージョンのzlibで実行できるようにしたいと思っているかのどちらかです。</target>
        </trans-unit>
        <trans-unit id="a13d801950c0dc8ed9906d27d14a9952af5a263a" translate="yes" xml:space="preserve">
          <source>You are encouraged to participate in the discussion and advocate for your patch. Sometimes your patch may get lost in the shuffle. It's appropriate to send a reminder email to p5p if no action has been taken in a month. Please remember that the Perl 5 developers are all volunteers, and be polite.</source>
          <target state="translated">議論に参加し、あなたのパッチを擁護することをお勧めします。時々、あなたのパッチがシャッフルの中で迷子になるかもしれません。1ヶ月間何のアクションも取られていない場合は、p5pにリマインダーメールを送るのが適切です。Perl 5 の開発者はすべてボランティアであることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="719d41b23df4f3bd674c48a03b68b419d4539869" translate="yes" xml:space="preserve">
          <source>You are encouraged to use &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; over &lt;code&gt;ok()&lt;/code&gt; where possible, however do not be tempted to use them to find out if something is true or false!</source>
          <target state="translated">あなたが使用するように奨励されている &lt;code&gt;is()&lt;/code&gt; と &lt;code&gt;isnt()&lt;/code&gt; 上 &lt;code&gt;ok()&lt;/code&gt; 可能であれば、しかし、何かが真か偽であるかどうかを確認するためにそれらを使用するように誘惑することはありません！</target>
        </trans-unit>
        <trans-unit id="7231b46f1cb348d100d3ac2d2fb73b6bf57d8066" translate="yes" xml:space="preserve">
          <source>You are guaranteed that &lt;code&gt;$dirs . $filename . $suffix&lt;/code&gt; will denote the same location as the original $path.</source>
          <target state="translated">&lt;code&gt;$dirs . $filename . $suffix&lt;/code&gt; が保証されます。$ filename。$ suffixは、元の$ pathと同じ場所を示します。</target>
        </trans-unit>
        <trans-unit id="845992c360c01c1fffb9e8ef6310e8cc47a34923" translate="yes" xml:space="preserve">
          <source>You are not supposed to modify arrays while they are being iterated over. For speed and efficiency reasons, Perl internally does not do full reference-counting of iterated items, hence deleting such an item in the middle of an iteration causes Perl to see a freed value.</source>
          <target state="translated">反復処理中に配列を変更することはできません。速度と効率性の理由から、Perl は内部的に反復された項目の完全な参照カウントを行わないため、反復の途中でそのような項目を削除すると Perl は解放された値を見ることになります。</target>
        </trans-unit>
        <trans-unit id="c4250931e7c7965b87b322df0e377d3c209e4074" translate="yes" xml:space="preserve">
          <source>You are recommended to change your code to set &lt;code&gt;$/&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; explicitly if you wish to slurp the file. In future versions of Perl assigning a reference to will throw a fatal error.</source>
          <target state="translated">ファイルを丸呑みしたい場合は、コードを変更して &lt;code&gt;$/&lt;/code&gt; を明示的に &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; に設定することをお勧めします。Perlの将来のバージョンでは、参照を割り当てると致命的なエラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="d65f3a3a78dc9835626ba2ec61976c50a4907da1" translate="yes" xml:space="preserve">
          <source>You are responsible for &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; on the return value if you plan to store it anywhere semi-permanently (otherwise it might be deleted out from under you the next time the cache is invalidated).</source>
          <target state="translated">あなたは責任があり &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; あなたはどこにも半永久的に保管することを計画している場合、戻り値に（そうでない場合、それはあなたの下からキャッシュが無効化され、次回を削除される場合があります）。</target>
        </trans-unit>
        <trans-unit id="37e416f1d8fe7e351baa8b0e70e6dc37f69f6f41" translate="yes" xml:space="preserve">
          <source>You are strongly encouraged to implement methods below, at least either encode() or decode().</source>
          <target state="translated">以下のメソッドは、少なくとも encode()か decode()のいずれかを実装することを強く推奨します。</target>
        </trans-unit>
        <trans-unit id="ff134e38e289cfa6f5f3d471d7e0e0fabcbe8c66" translate="yes" xml:space="preserve">
          <source>You are strongly encouraged to migrate any existing threaded code to the new model (i.e., use the &lt;code&gt;threads&lt;/code&gt; and &lt;code&gt;threads::shared&lt;/code&gt; modules) as soon as possible.</source>
          <target state="translated">できるだけ早く、既存のスレッドコードを新しいモデルに移行する（つまり、 &lt;code&gt;threads&lt;/code&gt; と &lt;code&gt;threads::shared&lt;/code&gt; モジュールを使用する）ことを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="2a08b19fff728f8eb38fe62f343715380f316ef9" translate="yes" xml:space="preserve">
          <source>You aren't allowed to modify constants in this way, of course. If an argument were actually literal and you tried to change it, you'd take a (presumably fatal) exception. For example, this won't work:</source>
          <target state="translated">もちろん、この方法で定数を変更することはできません。もし引数が実際にはリテラルであり、それを変更しようとした場合、(おそらく致命的な)例外が発生します。例えば、これはうまくいきません。</target>
        </trans-unit>
        <trans-unit id="1622820db3665cc19fb76f05a9e122011064bf68" translate="yes" xml:space="preserve">
          <source>You can &quot;make install&quot; already but you should test first.</source>
          <target state="translated">すでに「make install」はできますが、まずはテストをしてみましょう。</target>
        </trans-unit>
        <trans-unit id="441d296a1602f9e39d91a622912b032dea66e8b8" translate="yes" xml:space="preserve">
          <source>You can (and should) read more about references in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Briefly, references are rather like pointers that know what they point to. (Objects are also a kind of reference, but we won't be needing them right away--if ever.) This means that when you have something which looks to you like an access to a two-or-more-dimensional array and/or hash, what's really going on is that the base type is merely a one-dimensional entity that contains references to the next level. It's just that you can</source>
          <target state="translated">&lt;a href=&quot;perlref&quot;&gt;perlrefで&lt;/a&gt;参照についての詳細を読むことができます（すべきです）。簡単に言うと、参照は、参照先を知っているポインタのようなものです。（オブジェクトも一種の参照ですが、すぐには必要ありません。これは、2次元以上の配列へのアクセスのように見えるものがあり、 /またはハッシュ、実際に起こっていることは、基本型が次のレベルへの参照を含む1次元のエンティティにすぎないということです。それはあなたができることだけです</target>
        </trans-unit>
        <trans-unit id="4c8d7d3437af9191b3b2ecdbf2e0cc22d58ff901" translate="yes" xml:space="preserve">
          <source>You can &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize just one element of an aggregate. Usually this is done on dynamics:</source>
          <target state="translated">集計の1つの要素のみを &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; できます。通常、これはダイナミクスで行われます。</target>
        </trans-unit>
        <trans-unit id="3c3c57d183363a886eda26951cab8a3d873beb8e" translate="yes" xml:space="preserve">
          <source>You can access the first characters of a string with substr(). To get the first character, for example, start at position 0 and grab the string of length 1.</source>
          <target state="translated">文字列の最初の文字にアクセスするには substr()を使用します。最初の文字を取得するには、例えば 0 の位置から始めて、長さ 1 の文字列を取得します。</target>
        </trans-unit>
        <trans-unit id="4b6168183223c539ff65f81f73941c2c4a8e59c2" translate="yes" xml:space="preserve">
          <source>You can actually chomp anything that's an lvalue, including an assignment:</source>
          <target state="translated">実際には、代入を含めてlvalueであれば何でもチョンプすることができます。</target>
        </trans-unit>
        <trans-unit id="ab3659f896bba38cbe056eb37538d331f15d2fcc" translate="yes" xml:space="preserve">
          <source>You can actually chop anything that's an lvalue, including an assignment.</source>
          <target state="translated">実際には、代入を含め、lvalueであれば何でも切り刻むことができます。</target>
        </trans-unit>
        <trans-unit id="06e51b7968687b9d39d3fba6b7611216b01c17eb" translate="yes" xml:space="preserve">
          <source>You can actually put an array or hash anywhere in the list, but the first one in the list will soak up all the values, and anything after it will become undefined. This may be useful in a my() or local().</source>
          <target state="translated">実際にはリストのどこにでも配列やハッシュを置くことができますが、リストの最初のものはすべての値を吸収し、それ以降のものは未定義になります。これは my()や local()で便利です。</target>
        </trans-unit>
        <trans-unit id="9fcefecb0feb2b6d0223364636eebffcb896a89d" translate="yes" xml:space="preserve">
          <source>You can add customized aliases to standard (&lt;code&gt;:full&lt;/code&gt; ) Unicode naming conventions. The aliases override any standard definitions, so, if you're twisted enough, you can change &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; to mean &lt;code&gt;&quot;B&quot;&lt;/code&gt; , etc.</source>
          <target state="translated">カスタマイズしたエイリアスを標準（ &lt;code&gt;:full&lt;/code&gt; ）Unicode命名規則に追加できます。エイリアスはすべての標準的な定義を上書きするため、十分に &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; 場合は、「\ N {LATIN CAPITAL LETTER A}」を &lt;code&gt;&quot;B&quot;&lt;/code&gt; などに変更できます。</target>
        </trans-unit>
        <trans-unit id="422d4c1954392600b653163b725624c46d77f3f0" translate="yes" xml:space="preserve">
          <source>You can adjust the counter by assigning to &lt;code&gt;$.&lt;/code&gt; , but this will not actually move the seek pointer.</source>
          <target state="translated">&lt;code&gt;$.&lt;/code&gt; 割り当てることで、カウンターを調整できます。、しかしこれは実際にはシークポインタを動かしません。</target>
        </trans-unit>
        <trans-unit id="add234c624f206426ee8290a3ddfc9b8ceedcb89" translate="yes" xml:space="preserve">
          <source>You can also alter the way the output and logic of &lt;code&gt;Carp&lt;/code&gt; works, by changing some global variables in the &lt;code&gt;Carp&lt;/code&gt; namespace. See the section on &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; below.</source>
          <target state="translated">&lt;code&gt;Carp&lt;/code&gt; 名前空間の一部のグローバル変数を変更することにより、 &lt;code&gt;Carp&lt;/code&gt; の出力とロジックの動作を変更することもできます。以下の &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="0d61dd797cd63f1042bbffa35621af46e71f5b31" translate="yes" xml:space="preserve">
          <source>You can also call &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with a reference argument, and if this is trapped within an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;$@&lt;/code&gt; contains that reference. This permits more elaborate exception handling using objects that maintain arbitrary state about the exception. Such a scheme is sometimes preferable to matching particular string values of &lt;code&gt;$@&lt;/code&gt; with regular expressions. Because &lt;code&gt;$@&lt;/code&gt; is a global variable and &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; may be used within object implementations, be careful that analyzing the error object doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="translated">参照引数を指定して &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; を呼び出すこともできます。これが &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 内にトラップされている場合、 &lt;code&gt;$@&lt;/code&gt; はその参照が含まれます。これにより、例外に関する任意の状態を維持するオブジェクトを使用した、より複雑な例外処理が可能になります。このようなスキームは、 &lt;code&gt;$@&lt;/code&gt; 特定の文字列値を正規表現と照合するよりも好ましい場合があります。ので &lt;code&gt;$@&lt;/code&gt; グローバル変数とある &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; はオブジェクト実装内で使用することができる、エラーオブジェクトの解析はグローバル変数の参照に置き換えられないように注意してください。操作を行う前に、参照のローカルコピーを作成するのが最も簡単です。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="151ae294544e5b15c198686df29c5202445b492a" translate="yes" xml:space="preserve">
          <source>You can also call &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with a reference argument, and if this is trapped within an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;$@&lt;/code&gt; contains that reference. This permits more elaborate exception handling using objects that maintain arbitrary state about the exception. Such a scheme is sometimes preferable to matching particular string values of &lt;code&gt;$@&lt;/code&gt; with regular expressions. Because &lt;code&gt;$@&lt;/code&gt; is a global variable and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; may be used within object implementations, be careful that analyzing the error object doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="translated">参照引数を指定して &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; を呼び出すこともできます。これが &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 内にトラップされている場合、 &lt;code&gt;$@&lt;/code&gt; はその参照が含まれます。これにより、例外に関する任意の状態を維持するオブジェクトを使用した、より複雑な例外処理が可能になります。このようなスキームは、 &lt;code&gt;$@&lt;/code&gt; 特定の文字列値を正規表現と照合するよりも好ましい場合があります。ので &lt;code&gt;$@&lt;/code&gt; グローバル変数とある &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; はオブジェクト実装内で使用することができる、エラーオブジェクトの解析はグローバル変数の参照に置き換えられないように注意してください。操作を行う前に、参照のローカルコピーを作成するのが最も簡単です。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="9cdb85fa1e67a62d3e70dba3d5bf1c75c04f7e09" translate="yes" xml:space="preserve">
          <source>You can also call parse_lines() to parse an array of lines or parse_string_document() to parse a document already in memory. As with parse_file(), parse_lines() and parse_string_document() default to sending their output to &lt;code&gt;STDOUT&lt;/code&gt; unless changed with the output_fh() method.</source>
          <target state="translated">parse_lines（）を呼び出して行の配列を解析したり、parse_string_document（）を呼び出してすでにメモリ内にあるドキュメントを解析したりすることもできます。parse_file（）と同様に、parse_lines（）およびparse_string_document（）は、output_fh（）メソッドで変更しない限り、デフォルトで出力を &lt;code&gt;STDOUT&lt;/code&gt; に送信します。</target>
        </trans-unit>
        <trans-unit id="e57fcafa1ea35942e9edb2cd8f5d66578716838d" translate="yes" xml:space="preserve">
          <source>You can also chain the calls like this, this will make first a copy and then multiply it by 2:</source>
          <target state="translated">このように呼び出しをチェーン化することもできます。</target>
        </trans-unit>
        <trans-unit id="029fcbbc45bf12d25b834057d9395bba7ab192ae" translate="yes" xml:space="preserve">
          <source>You can also change the internal suspects list via &lt;code&gt;set_suspects&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;set_suspects&lt;/code&gt; メソッドを使用して、内部容疑者リストを変更することもできます。</target>
        </trans-unit>
        <trans-unit id="d2a2e4e937f2dcf302981b9beceb35f4afd812bf" translate="yes" xml:space="preserve">
          <source>You can also choose to use rsync to get a copy of the current source tree for the bleadperl branch and all maintenance branches:</source>
          <target state="translated">bleadperl ブランチとすべてのメンテナンスブランチの現在のソースツリーのコピーを取得するために rsync を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="69913c0f24daf22d2c432ea27b2a49c000488188" translate="yes" xml:space="preserve">
          <source>You can also control the 'hushed' flag at run-time, using the built-in routine vmsish::hushed(). Without argument, it returns the hushed status. Since vmsish::hushed is built-in, you do not need to &quot;use vmsish&quot; to call it.</source>
          <target state="translated">また、組み込みルーチン vmsish::hushed()を使用して、実行時に ' hushed' フラグを制御することもできます。引数なしで、それは hushed 状態を返します。vmsish::hushed は組み込みなので、それを呼び出すために &quot;vmsish を使う&quot; 必要はありません。</target>
        </trans-unit>
        <trans-unit id="563cd6bbc176ecbc734b5b0b439a546964280899" translate="yes" xml:space="preserve">
          <source>You can also control the character encoding and entities. For example, if you're sure that the POD is properly encoded (using the &lt;code&gt;=encoding&lt;/code&gt; command), you can prevent high-bit characters from being encoded as HTML entities and declare the output character set as UTF-8 before parsing, like so:</source>
          <target state="translated">文字エンコーディングとエンティティを制御することもできます。たとえば、PODが適切にエンコードされていることが確実な場合（ &lt;code&gt;=encoding&lt;/code&gt; コマンドを使用）、ハイビット文字がHTMLエンティティとしてエンコードされないようにし、解析前に出力文字セットをUTF-8として宣言することができます。 ：</target>
        </trans-unit>
        <trans-unit id="ce7cb29295e37cbd29b717e64482225d4d4ba414" translate="yes" xml:space="preserve">
          <source>You can also control the shell that perl uses to run system() and backtick commands via PERL5SHELL. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">perlがsystem（）およびbacktickコマンドを実行するためにPERL5SHELLを介して使用するシェルを制御することもできます。&lt;a href=&quot;perlrun&quot;&gt;perlrunを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4b6274126a67429902f21b4ff102d4a5f157ec82" translate="yes" xml:space="preserve">
          <source>You can also create a circular reference with a single variable:</source>
          <target state="translated">1つの変数で循環参照を作成することもできます。</target>
        </trans-unit>
        <trans-unit id="fe319fa0895a7f47e55075d55fc2289e3b3f2bea" translate="yes" xml:space="preserve">
          <source>You can also do</source>
          <target state="translated">をすることもできます。</target>
        </trans-unit>
        <trans-unit id="69a5ee6a0a8ad7101d445832b3faf4f8db8fd92c" translate="yes" xml:space="preserve">
          <source>You can also do the same things with the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;モジュールでも同じことができます。</target>
        </trans-unit>
        <trans-unit id="efdd9cfab2b6e73dabdc31999bde389ad6e9c40e" translate="yes" xml:space="preserve">
          <source>You can also do the wrapping explicitly by rad2rad(), deg2deg(), and grad2grad().</source>
          <target state="translated">rad2rad()、deg2deg()、grad2grad()で明示的にラッピングを行うこともできます。</target>
        </trans-unit>
        <trans-unit id="e971cca5e90229321a699ea5b197dee6a304b5cb" translate="yes" xml:space="preserve">
          <source>You can also do this directly in the match operator using the &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; sequences. The &lt;code&gt;\Q&lt;/code&gt; tells Perl where to start escaping special characters, and the &lt;code&gt;\E&lt;/code&gt; tells it where to stop (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details).</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; および &lt;code&gt;\E&lt;/code&gt; シーケンスを使用して、一致演算子で直接これを行うこともできます。 &lt;code&gt;\Q&lt;/code&gt; どこの特殊文字をエスケープ開始するPerlを伝え、 &lt;code&gt;\E&lt;/code&gt; （参照どこに停止するように指示&lt;a href=&quot;perlop&quot;&gt;はperlop&lt;/a&gt;詳細）。</target>
        </trans-unit>
        <trans-unit id="fe2d0afbbbfb95dc9ef1705dc46b6eb4a3e77627" translate="yes" xml:space="preserve">
          <source>You can also do this for most systems using the &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, which is easier to use and in theory more portable.</source>
          <target state="translated">ほとんどのシステムでは、CPANの&lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt;モジュールを使用してこれを行うこともできます。これは、使いやすく、理論上は移植性が高くなります。</target>
        </trans-unit>
        <trans-unit id="f3337ad9bcb6d402cd92e0314d2032a9a8dc4c0a" translate="yes" xml:space="preserve">
          <source>You can also easily say to use all categories but one, by either, for example,</source>
          <target state="translated">また、例えばどちらか一方だけではなく、すべてのカテゴリを使用すると簡単に言うことができます。</target>
        </trans-unit>
        <trans-unit id="317bed7b561a99db6e7463d3bee761b35a18aa16" translate="yes" xml:space="preserve">
          <source>You can also embed newlines directly in your strings, i.e., they can end on a different line than they begin. This is nice, but if you forget your trailing quote, the error will not be reported until Perl finds another line containing the quote character, which may be much further on in the script. Variable substitution inside strings is limited to scalar variables, arrays, and array or hash slices. (In other words, names beginning with $ or @, followed by an optional bracketed expression as a subscript.) The following code segment prints out &quot;The price is $100.&quot;</source>
          <target state="translated">また、文字列の中に直接改行を埋め込むこともできます。これは良いことですが、もし末尾の引用符を忘れてしまった場合、Perl が引用符を含む別の行を見つけるまでエラーは報告されません。文字列内での変数の置換は、スカラ変数、配列、配列またはハッシュスライスに限定されています。(言い換えれば、$または@で始まる名前の後に、オプションで括弧付きの式を添え字として付けることができます)。次のコード・セグメントは、&quot;価格は 100 ドルです&quot; と出力します。</target>
        </trans-unit>
        <trans-unit id="6dc98b973b8e3861953362cf4137bf9098b40a23" translate="yes" xml:space="preserve">
          <source>You can also explicitly indicate that a single handler is meant to be used for all types of referents like so:</source>
          <target state="translated">また、単一のハンドラがすべてのタイプの参照に対して使用されることを明示的に指定することもできます。</target>
        </trans-unit>
        <trans-unit id="cc7d393dae203f89e29915d158bc84c0d091344a" translate="yes" xml:space="preserve">
          <source>You can also explicitly specify the argument number to use for the join string using something like &lt;code&gt;*2$v&lt;/code&gt;; for example:</source>
          <target state="translated">&lt;code&gt;*2$v&lt;/code&gt; ようなものを使用して、結合文字列に使用する引数番号を明示的に指定することもできます。例えば：</target>
        </trans-unit>
        <trans-unit id="3c69b8b0664f8688a90139832b96e7b725fab5ec" translate="yes" xml:space="preserve">
          <source>You can also gain some minuscule measure of efficiency by pre-extending an array that is going to get big. You can also extend an array by assigning to an element that is off the end of the array. You can truncate an array down to nothing by assigning the null list () to it. The following are equivalent:</source>
          <target state="translated">また、大きくなりそうな配列を事前に拡張しておくことで、効率化を図ることもできます。また、配列の端から外れた要素に代入することで配列を拡張することもできます。配列にヌルリスト()を代入することで、配列を何もない状態に切り詰めることができます。以下がこれに相当します。</target>
        </trans-unit>
        <trans-unit id="87f6d7508324248bf5fa6b6a6e4e9d73a898fe92" translate="yes" xml:space="preserve">
          <source>You can also get a pointer to the end of the string stored in the SV with the macro:</source>
          <target state="translated">また、SVに格納されている文字列の末尾へのポインタをマクロで取得することもできます。</target>
        </trans-unit>
        <trans-unit id="843f7af3e5947338619464418b011d78b7714032" translate="yes" xml:space="preserve">
          <source>You can also get differences with a subtraction, which returns a &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; object:</source>
          <target state="translated">&lt;a href=&quot;time/seconds&quot;&gt;Time :: Seconds&lt;/a&gt;オブジェクトを返す減算で差を取得することもできます。</target>
        </trans-unit>
        <trans-unit id="0da6f0ff3f9840990993a84402f300e13eb838e3" translate="yes" xml:space="preserve">
          <source>You can also get into subtle problems on those few operations in Perl that actually do care about the difference between a string and a number, such as the magical &lt;code&gt;++&lt;/code&gt; autoincrement operator or the syscall() function.</source>
          <target state="translated">また、魔法の &lt;code&gt;++&lt;/code&gt; 自動インクリメント演算子やsyscall（）関数など、文字列と数値の違いを実際に考慮しているPerlのいくつかの操作に関する微妙な問題に遭遇することもあります。</target>
        </trans-unit>
        <trans-unit id="dd7d480332101e4bfe5db6a1d74af4d69d28cfca" translate="yes" xml:space="preserve">
          <source>You can also get the precision from the next argument using &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="translated">また、使用して次の引数から精度を得ることができます &lt;code&gt;.*&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="31317a51fe6916c8950fb1738da08a3f662e794a" translate="yes" xml:space="preserve">
          <source>You can also go through each element and skip the ones you've seen before. Use a hash to keep track. The first time the loop sees an element, that element has no key in &lt;code&gt;%Seen&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement creates the key and immediately uses its value, which is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, so the loop continues to the &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; and increments the value for that key. The next time the loop sees that same element, its key exists in the hash</source>
          <target state="translated">各要素を確認して、前に見た要素をスキップすることもできます。ハッシュを使用して追跡します。ループが初めて要素を検出したとき、その要素には &lt;code&gt;%Seen&lt;/code&gt; にキーがありません。 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; の文は、キーを作成してすぐにある、その値、使用 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ループが続くように、 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; およびそのキーの値をインクリメントします。次にループが同じ要素を検出したとき、そのキーはハッシュに存在します</target>
        </trans-unit>
        <trans-unit id="7930ef83d4a331d3e89d11f276bc35572519ad08" translate="yes" xml:space="preserve">
          <source>You can also import the symbolic &lt;code&gt;S_I*&lt;/code&gt; constants from the &lt;code&gt;Fcntl&lt;/code&gt; module:</source>
          <target state="translated">&lt;code&gt;Fcntl&lt;/code&gt; モジュールからシンボリック &lt;code&gt;S_I*&lt;/code&gt; 定数をインポートすることもできます：</target>
        </trans-unit>
        <trans-unit id="254f31569eb5ae2200e952d6645d10bd474402c9" translate="yes" xml:space="preserve">
          <source>You can also insert hooks into the file inclusion system by putting Perl code directly into &lt;code&gt;@INC&lt;/code&gt; . Those hooks may be subroutine references, array references or blessed objects. See &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for details.</source>
          <target state="translated">また、Perlコードを &lt;code&gt;@INC&lt;/code&gt; に直接挿入することで、ファイルインクルードシステムにフックを挿入することもできます。これらのフックは、サブルーチン参照、配列参照、または祝福されたオブジェクトの場合があります。詳細&lt;a href=&quot;functions/require&quot;&gt;はrequire&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ae3dcb264a37bf433b3f44d57e7b80c09701bead" translate="yes" xml:space="preserve">
          <source>You can also insert hooks into the import facility by putting Perl code directly into the @INC array. There are three forms of hooks: subroutine references, array references, and blessed objects.</source>
          <target state="translated">また、Perlのコードを直接@INC配列に入れることで、インポート機能にフックを挿入することもできます。フックには、サブルーチン参照、配列参照、祝福されたオブジェクトの3つの形式があります。</target>
        </trans-unit>
        <trans-unit id="05e59c02014a1d5de9eba1297e8dbc08a175322a" translate="yes" xml:space="preserve">
          <source>You can also just quickly &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; on an undefined value this way:</source>
          <target state="translated">このようにして、未定義の値ですぐに &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; こともできます。</target>
        </trans-unit>
        <trans-unit id="5af0b3086e446e033f6737e913de95b977971d84" translate="yes" xml:space="preserve">
          <source>You can also look for information at:</source>
          <target state="translated">で情報を探すこともできます。</target>
        </trans-unit>
        <trans-unit id="52f3afa40db22b85e32dd734c2f80ac43010fee7" translate="yes" xml:space="preserve">
          <source>You can also override &lt;code&gt;DOES&lt;/code&gt; directly in your own classes. If you override this method, it should never throw an exception.</source>
          <target state="translated">また、独自のクラスで &lt;code&gt;DOES&lt;/code&gt; を直接オーバーライドすることもできます。このメソッドをオーバーライドした場合、例外がスローされることはありません。</target>
        </trans-unit>
        <trans-unit id="95cd0a4f9ce9a6a1469a2469c1efc68cdb5fae5b" translate="yes" xml:space="preserve">
          <source>You can also pass &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; an explicit encoding to change it on the fly. This isn't exactly &quot;binary&quot; mode, but we still use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to do it:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; に明示的なエンコーディングを渡して、オンザフライで変更することもできます。これは厳密には「バイナリ」モードではありませんが、 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; を使用して実行します。</target>
        </trans-unit>
        <trans-unit id="f90ccf1fd48c6dc4de43f56b2888c9c3134e2996" translate="yes" xml:space="preserve">
          <source>You can also pass a subroutine reference in order to determine and return the proper program to run based on a given test script. The subroutine reference should expect the TAP::Harness object itself as the first argument, and the file name as the second argument. It should return an array reference containing the command to be run and including the test file name. It can also simply return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, in which case TAP::Harness will fall back on executing the test script in Perl:</source>
          <target state="translated">また、特定のテストスクリプトに基づいて実行する適切なプログラムを決定して返すために、サブルーチン参照を渡すこともできます。サブルーチンの参照では、最初の引数としてTAP :: Harnessオブジェクト自体を想定し、2番目の引数としてファイル名を想定する必要があります。実行するコマンドを含み、テストファイル名を含む配列参照を返す必要があります。また、単に &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返すこともできます。その場合、TAP :: HarnessはPerlでのテストスクリプトの実行にフォールバックします。</target>
        </trans-unit>
        <trans-unit id="f73ef4e3f69ff87027791a2bee2e957755bc2ee3" translate="yes" xml:space="preserve">
          <source>You can also read and execute Perl statements from a file while in the midst of your C program, by placing the filename in</source>
          <target state="translated">また、C プログラムの途中でファイル名を</target>
        </trans-unit>
        <trans-unit id="e9bed781c4a6044ffb67b23fe5c127e03e4dd1a1" translate="yes" xml:space="preserve">
          <source>You can also refer to capture groups relatively, by using a negative number, so that &lt;code&gt;\g-1&lt;/code&gt; and &lt;code&gt;\g{-1}&lt;/code&gt; both refer to the immediately preceding capture group, and &lt;code&gt;\g-2&lt;/code&gt; and &lt;code&gt;\g{-2}&lt;/code&gt; both refer to the group before it. For example:</source>
          <target state="translated">負の数を使用して、キャプチャグループを相対的に参照することもできます。これにより、 &lt;code&gt;\g-1&lt;/code&gt; と &lt;code&gt;\g{-1}&lt;/code&gt; どちらも直前のキャプチャグループを参照し、 &lt;code&gt;\g-2&lt;/code&gt; と &lt;code&gt;\g{-2}&lt;/code&gt; 両方を参照できます。その前のグループを参照してください。例えば：</target>
        </trans-unit>
        <trans-unit id="108a751b15dd5a65748cd5542a9f662a512fab15" translate="yes" xml:space="preserve">
          <source>You can also restrict names to a certain alphabet by specifying the &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt; pragma:</source>
          <target state="translated">&lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;プラグマを指定して、名前を特定のアルファベットに制限することもできます。</target>
        </trans-unit>
        <trans-unit id="0b5023bd40fe3a7df91e6504812de04a002532fe" translate="yes" xml:space="preserve">
          <source>You can also see in that example that we use &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; to get the value of the character; the inverse function &lt;code&gt;uvchr_to_utf8&lt;/code&gt; is available for putting a UV into UTF-8:</source>
          <target state="translated">この例では、 &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; を使用して文字の値を取得していることもわかります。UVをUTF-8に入れるには、逆関数 &lt;code&gt;uvchr_to_utf8&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="7a3be218b57aec1fe1552cf95cde772b459e8c4a" translate="yes" xml:space="preserve">
          <source>You can also send pull requests to the Github repository:</source>
          <target state="translated">プルリクエストをGithubリポジトリに送ることもできます。</target>
        </trans-unit>
        <trans-unit id="2a4162cf16b37e0bb4e40d233ea23d3b932f7f0d" translate="yes" xml:space="preserve">
          <source>You can also specify the separator character using hexadecimal notation: &lt;b&gt;-0x&lt;i&gt;HHH...&lt;/i&gt;&lt;/b&gt;, where the &lt;code&gt;&lt;i&gt;H&lt;/i&gt;&lt;/code&gt; are valid hexadecimal digits. Unlike the octal form, this one may be used to specify any Unicode character, even those beyond 0xFF. So if you</source>
          <target state="translated">16進表記を使用して区切り文字を指定することもできます：&lt;b&gt;-0x &lt;i&gt;HHH ...。&lt;/i&gt;&lt;/b&gt;ここで、 &lt;code&gt;&lt;i&gt;H&lt;/i&gt;&lt;/code&gt; は有効な16進数です。8進形式とは異なり、これは0xFFを超えるものを含め、任意のUnicode文字を指定するために使用できます。だからあなたが</target>
        </trans-unit>
        <trans-unit id="5708c7cba5f95ced05791bc1f781cc7e3ab698d2" translate="yes" xml:space="preserve">
          <source>You can also specify to NOT use something:</source>
          <target state="translated">また、何かを使わないように指定することもできます。</target>
        </trans-unit>
        <trans-unit id="d0e21d8042eb943e53a763ac42b81475843fd69a" translate="yes" xml:space="preserve">
          <source>You can also store data in network order to allow easy sharing across multiple platforms, or when storing on a socket known to be remotely connected. The routines to call have an initial &lt;code&gt;n&lt;/code&gt; prefix for</source>
          <target state="translated">複数のプラットフォーム間で簡単に共有できるように、またはリモート接続されていることがわかっているソケットに保存するときに、ネットワーク順にデータを保存することもできます。呼び出すルーチンには、最初の &lt;code&gt;n&lt;/code&gt; 接頭辞が</target>
        </trans-unit>
        <trans-unit id="32a000612a53a9f73b8165e9ffd35ee663d455aa" translate="yes" xml:space="preserve">
          <source>You can also subscript a list to get a single element from it:</source>
          <target state="translated">また、リストから1つの要素を取得するために、リストに添え字をつけることもできます。</target>
        </trans-unit>
        <trans-unit id="e308900a9f85413017177815b933ee92128f909d" translate="yes" xml:space="preserve">
          <source>You can also test a class, to make sure that it has the right ancestor:</source>
          <target state="translated">クラスをテストして、それが正しい祖先を持っていることを確認することもできます。</target>
        </trans-unit>
        <trans-unit id="e940484c0812f3991ca3b5162180666fbbc774e9" translate="yes" xml:space="preserve">
          <source>You can also try &lt;code&gt;guess_encoding&lt;/code&gt; function which is exported by default. It takes $data to check and it also takes the list of suspects by option. The optional suspect list is</source>
          <target state="translated">デフォルトでエクスポートされる &lt;code&gt;guess_encoding&lt;/code&gt; 関数を試すこともできます。チェックには$ dataを使用し、オプションで容疑者のリストも取得します。オプションの容疑者リストは</target>
        </trans-unit>
        <trans-unit id="c6c2bb7263fcb86f56120bac5220dbcae10e778f" translate="yes" xml:space="preserve">
          <source>You can also try to include the module in a one-liner to see if perl finds it:</source>
          <target state="translated">また、ワンライナーにモジュールを入れてみて、Perlがそれを見つけるかどうかを確認することもできます。</target>
        </trans-unit>
        <trans-unit id="b15c66e70792efbd27fd6c112e317c6eb54c5b69" translate="yes" xml:space="preserve">
          <source>You can also try using &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, as described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; (although this is the same thing that many of the modules will do for you).</source>
          <target state="translated">&lt;a href=&quot;perlfunc&quot;&gt;perlfuncで&lt;/a&gt;説明されているように、 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; の使用を試すこともできます（ただし、これは多くのモジュールが行うことと同じです）。</target>
        </trans-unit>
        <trans-unit id="22d0b06ab6697336780029eb518e6cdd2c05382e" translate="yes" xml:space="preserve">
          <source>You can also use</source>
          <target state="translated">また、以下のような使い方もできます。</target>
        </trans-unit>
        <trans-unit id="b0304b03ea61e4912a40d9a36c7c0d47306360a9" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny::Antlers&quot;&gt;Class::Tiny::Antlers&lt;/a&gt; for &lt;code&gt;Moose&lt;/code&gt; -like syntax.</source>
          <target state="translated">&lt;code&gt;Moose&lt;/code&gt; のような構文には&lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny::Antlers&quot;&gt;Class :: Tiny :: Antlers&lt;/a&gt;を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="37de0be164e83020017ecbe8445d1b73a8f2a1b8" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::REPL&quot;&gt;Devel::REPL&lt;/a&gt; which is an interactive shell for Perl, commonly known as a REPL - Read, Evaluate, Print, Loop. It provides various handy features.</source>
          <target state="translated">また、Perlの対話型シェルである&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::REPL&quot;&gt;Devel :: REPL&lt;/a&gt;を使用することもできます。これは、一般にREPLとして知られています-読み取り、評価、印刷、ループ。さまざまな便利な機能を提供します。</target>
        </trans-unit>
        <trans-unit id="9013c35ad3298535ad5c8c74739a6a896be46939" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::Cycle&quot;&gt;Tie::Cycle&lt;/a&gt; to use a scalar that always has the next element of the circular array:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Tie::Cycle&quot;&gt;Tie :: Cycle&lt;/a&gt;を使用して、常に循環配列の次の要素を持つスカラーを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="ed9079885add1db23c7b692dc26264a6c8112995" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local::lib&lt;/a&gt; to do much of the same thing. Install modules using &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local::lib&lt;/a&gt;'s settings then use the module in your program:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local :: lib&lt;/a&gt;を使用して同じことの多くを行うこともできます。&lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local :: lib&lt;/a&gt;の設定を使用してモジュールをインストールし、プログラムでモジュールを使用します。</target>
        </trans-unit>
        <trans-unit id="38efc50c4c6a8567a3f07d734113580b8054b830" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt;, which comes with Perl and provides a &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; that returns an object:</source>
          <target state="translated">Perlに付属し、オブジェクトを返す &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; を提供する&lt;a href=&quot;time/piece&quot;&gt;Time :: Pieceを&lt;/a&gt;使用することもできます。</target>
        </trans-unit>
        <trans-unit id="fe8ff91507ad3e201158ab00126828440dda9b62" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;HANDLE-&amp;gt;input_line_number(EXPR)&lt;/code&gt; to access the line counter for a given filehandle without having to worry about which handle you last accessed.</source>
          <target state="translated">&lt;code&gt;HANDLE-&amp;gt;input_line_number(EXPR)&lt;/code&gt; を使用して、最後にアクセスしたハンドルを気にすることなく、特定のファイルハンドルの行カウンターにアクセスすることもできます。</target>
        </trans-unit>
        <trans-unit id="cfc194c704de65f5fa2e2dc7cdfca08cd861cafc" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;cpan&lt;/code&gt; 's &lt;code&gt;-a&lt;/code&gt; switch to create an autobundle file that &lt;code&gt;CPAN.pm&lt;/code&gt; understands and can use to re-install every module:</source>
          <target state="translated">また、使用することができます &lt;code&gt;cpan&lt;/code&gt; の &lt;code&gt;-a&lt;/code&gt; というautobundleファイルを作成するようにスイッチを &lt;code&gt;CPAN.pm&lt;/code&gt; を理解し、再インストールし、すべてのモジュールに使用することができます。</target>
        </trans-unit>
        <trans-unit id="3ed04ee9d470ae5bb5ded41953f6884557aab9f4" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;while&lt;/code&gt; in a post-condition:</source>
          <target state="translated">また、使用することができます &lt;code&gt;while&lt;/code&gt; 事後条件に：</target>
        </trans-unit>
        <trans-unit id="d2490129a2ade6b9a949f50bed0b1d18208e8c0a" translate="yes" xml:space="preserve">
          <source>You can also use Perl one-liners to modify a file in-place. The following changes all 'Fred' to 'Barney' in</source>
          <target state="translated">また、Perl のワンライナーを使って、ファイルをその場で修正することもできます。次の例では、'Fred'を'Barney'に変更しています。</target>
        </trans-unit>
        <trans-unit id="ae806fe9a09487e09415c88d84054f11b5bab926" translate="yes" xml:space="preserve">
          <source>You can also use a commercial debugger such as Affrus (Mac OS X), Komodo from Activestate (Windows and Mac OS X), or EPIC (most platforms).</source>
          <target state="translated">Affrus (Mac OS X)、ActivestateのKomodo (WindowsとMac OS X)、EPIC (ほとんどのプラットフォーム)などの市販のデバッガを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="79babd18e608e40e4da78366242734a20c79cee2" translate="yes" xml:space="preserve">
          <source>You can also use a double fork. You immediately &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; for your first child, and the init daemon will &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; for your grandchild once it exits.</source>
          <target state="translated">ダブルフォークを使用することもできます。あなたはすぐに &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 、あなたの最初の子のために、とinitデーモンがします &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 、それが終了したら、あなたの孫のために。</target>
        </trans-unit>
        <trans-unit id="9ef85cce54fb95ce8f948edcebadc50c579e68d3" translate="yes" xml:space="preserve">
          <source>You can also use a list slice to select only the elements that you need:</source>
          <target state="translated">リストスライスを使って、必要な要素だけを選択することもできます。</target>
        </trans-unit>
        <trans-unit id="d760c6f0200ce645ec4271e39ed0780a635d6be2" translate="yes" xml:space="preserve">
          <source>You can also use a localized &lt;code&gt;@ARGV&lt;/code&gt; to eliminate the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">ローカライズされた &lt;code&gt;@ARGV&lt;/code&gt; を使用して、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; を排除することもできます。</target>
        </trans-unit>
        <trans-unit id="4613c51eb74aabc580ab960ede735ed7c5a84c03" translate="yes" xml:space="preserve">
          <source>You can also use a subroutine reference as a method:</source>
          <target state="translated">サブルーチン参照をメソッドとして使用することもできます。</target>
        </trans-unit>
        <trans-unit id="f4a8095c707393fa806f56c74d791b44c5bdbd35" translate="yes" xml:space="preserve">
          <source>You can also use certain libraries like Config conditionally, but be sure to skip the test gracefully if it's not there.</source>
          <target state="translated">Configのような特定のライブラリを条件付きで使うこともできますが、それがない場合は潔くテストをスキップするようにしましょう。</target>
        </trans-unit>
        <trans-unit id="aee62fec81f8fc5af73b94cc4b6a4396ba0e2b3e" translate="yes" xml:space="preserve">
          <source>You can also use dmake to build using Visual C++; provided, however, you set OSRELEASE to &quot;microsft&quot; (or whatever the directory name under which the Visual C dmake configuration lives) in your environment and edit win32/config.vc to change &quot;make=nmake&quot; into &quot;make=dmake&quot;. The latter step is only essential if you want to use dmake as your default make for building extensions using MakeMaker.</source>
          <target state="translated">ただし、お使いの環境で OSRELEASE を &quot;microsft&quot; (または Visual C の dmake 設定が存在するディレクトリ名)に設定し、win32/config.vc を編集して &quot;make=nmake&quot; を &quot;make=dmake&quot; に変更する必要があります。後者のステップは、MakeMaker を使って拡張機能をビルドする際に dmake をデフォルトの make として使用したい場合にのみ必要です。</target>
        </trans-unit>
        <trans-unit id="4fabe958607319aed5413ce7d91aa1937c4486e1" translate="yes" xml:space="preserve">
          <source>You can also use file-descriptor redirection to make STDERR a duplicate of STDOUT:</source>
          <target state="translated">また、ファイルディスクリプターのリダイレクトを使用して、STDERRをSTDOUTの複製にすることもできます。</target>
        </trans-unit>
        <trans-unit id="bb1f48473296bb1c89d7c3f43ff784b475814cae" translate="yes" xml:space="preserve">
          <source>You can also use negation in both &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; by introducing a caret (&lt;code&gt;^&lt;/code&gt;) between the first brace and the property name: &lt;code&gt;\p{^Tamil}&lt;/code&gt; is equal to &lt;code&gt;\P{Tamil}&lt;/code&gt; .</source>
          <target state="translated">また、最初の括弧とプロパティ名の間にキャレット（ &lt;code&gt;^&lt;/code&gt; ）を導入することにより、 &lt;code&gt;\p{}&lt;/code&gt; と &lt;code&gt;\P{}&lt;/code&gt; 両方で否定を使用できます。 &lt;code&gt;\p{^Tamil}&lt;/code&gt; は &lt;code&gt;\P{Tamil}&lt;/code&gt; と等しいです。</target>
        </trans-unit>
        <trans-unit id="6e6a71e5490894554dcf75a2f44b77577d1780db" translate="yes" xml:space="preserve">
          <source>You can also use substr() as an lvalue.</source>
          <target state="translated">また、lvalueとしてsubstr()を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="c8a027b09bbb1035f68edd31b3dac9da865767c1" translate="yes" xml:space="preserve">
          <source>You can also use the -Duse64bitint flag to Configure. Although there are some minor differences between compiling Perl with this flag versus the -Duse64bitall flag, they should not be noticeable from a Perl user's perspective. When configuring -Duse64bitint using a 64bit gcc on a pa-risc architecture, -Duse64bitint is silently promoted to -Duse64bitall.</source>
          <target state="translated">また、-Duse64bitint フラグを使用して Configure を行うこともできます。このフラグを使ってPerlをコンパイルする場合と-Duse64bitallフラグを使ってPerlをコンパイルする場合とでは、若干の違いがありますが、Perlユーザの視点から見れば目立った違いはありません。PA-RISC アーキテクチャ上で 64bit gcc を使用して -Duse64bitint を設定すると、-Duse64bitint は -Duse64bitall に昇格します。</target>
        </trans-unit>
        <trans-unit id="01f985bfd65126ce04f3352a8f1c24d2647a415c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module using its &lt;code&gt;Today_and_Now&lt;/code&gt; function.</source>
          <target state="translated">また、 &lt;code&gt;Today_and_Now&lt;/code&gt; 関数を使用して&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date :: Calc&lt;/a&gt;モジュールを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="5948ec91fdfb792b5884ccadb56a91fc59d16359" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; module which lets you access the lines through a tied array. You can use normal array operations to modify your file, including setting the last index and using &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;tie/file&quot;&gt;Tie :: File&lt;/a&gt;モジュールを使用して、結合された配列を介して行にアクセスすることもできます。通常の配列操作を使用して、最後のインデックスの設定や &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; の使用など、ファイルを変更できます。</target>
        </trans-unit>
        <trans-unit id="cea4cf5784aecf948d1c03056df0b1645df434de" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;**&lt;/code&gt; operator, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; 演算子を使用することもできます&lt;a href=&quot;perlop&quot;&gt;。perlopを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="aca7a853e98fdbbaafd79c6bf0b9e3d107072aaf" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;\G&lt;/code&gt; anchor in scalar context. You still need the &lt;code&gt;g&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; アンカーをスカラーコンテキストで使用することもできます。まだ &lt;code&gt;g&lt;/code&gt; フラグが必要です。</target>
        </trans-unit>
        <trans-unit id="36d5ff0652d0a9cfb0d9a8028ed64cb97f87e026" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;open3()&lt;/code&gt; function from &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt;. Benjamin Goldberg provides some sample code:</source>
          <target state="translated">&lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt;から &lt;code&gt;open3()&lt;/code&gt; 関数を使用することもできます。Benjamin Goldbergがいくつかのサンプルコードを提供します。</target>
        </trans-unit>
        <trans-unit id="54c10825a7a9a0e79c4bc9a8acb25f8c895c8d2f" translate="yes" xml:space="preserve">
          <source>You can also use the Unix command mknod(1), or on some systems, mkfifo(1). These may not be in your normal path, though.</source>
          <target state="translated">Unix のコマンド mknod(1)や、いくつかのシステムでは mkfifo(1)を使うこともできます。しかし、これらは通常のパスにはないかもしれません。</target>
        </trans-unit>
        <trans-unit id="d558c8753e7739908d901edc4316bd26afe6b26c" translate="yes" xml:space="preserve">
          <source>You can also use the complement of \b, \B, to specify that there should not be a word boundary.</source>
          <target state="translated">また、\b,\Bの補語を使って、単語の境界があってはならないことを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="94817cf57f637575defe9d34927c35a3c77682d8" translate="yes" xml:space="preserve">
          <source>You can also use the following functions to extract the file header information from Storable images:</source>
          <target state="translated">また、以下の関数を使用してStorable画像からファイルヘッダ情報を抽出することもできます。</target>
        </trans-unit>
        <trans-unit id="621c9d7b846400426f6a8d8885a28fc12414361e" translate="yes" xml:space="preserve">
          <source>You can also write that as a single substitution, although it turns out the combined statement is slower than the separate ones. That might not matter to you, though:</source>
          <target state="translated">また、単一の代入として書くこともできます。しかし、それはあなたにとっては重要ではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="6e736747d1920ca322bb92742d39b47addfde6fe" translate="yes" xml:space="preserve">
          <source>You can also:</source>
          <target state="translated">また、あなたもできます。</target>
        </trans-unit>
        <trans-unit id="9a39342cae5acfdbd6b63da64d2d504d73f599e3" translate="yes" xml:space="preserve">
          <source>You can alter the global variable $Params::Check::NO_DUPLICATES to control whether the &lt;code&gt;store&lt;/code&gt; 'd key will still be present in your result set. See the &lt;a href=&quot;#Global-Variables&quot;&gt;Global Variables&lt;/a&gt; section below.</source>
          <target state="translated">グローバル変数$ Params :: Check :: NO_DUPLICATESを変更して、 &lt;code&gt;store&lt;/code&gt; のキーが結果セットにまだ存在するかどうかを制御できます。以下の&lt;a href=&quot;#Global-Variables&quot;&gt;グローバル変数の&lt;/a&gt;セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="330192003f1fea8edf49c86f71523fd9c154de87" translate="yes" xml:space="preserve">
          <source>You can always check the value you're using by printing it in octal notation to ensure it matches what you think it should be. Print it in octal and decimal format:</source>
          <target state="translated">使用している値を8進数で印刷することで、使用している値をいつでも確認することができます。8進数と10進数で印刷します。</target>
        </trans-unit>
        <trans-unit id="ef6c5c0a821b62556c215147b73e29172a7eabfd" translate="yes" xml:space="preserve">
          <source>You can always use an array reference, in curly braces, in place of the name of an array. For example, &lt;code&gt;@{$aref}&lt;/code&gt; instead of &lt;code&gt;@array&lt;/code&gt; .</source>
          <target state="translated">配列の名前の代わりに、中括弧で囲まれた配列参照をいつでも使用できます。たとえば、 &lt;code&gt;@{$aref}&lt;/code&gt; ではなく@ {$ aref} &lt;code&gt;@array&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4754996a46b2974a193b45735bde04e1ddad5927" translate="yes" xml:space="preserve">
          <source>You can arrange for a callback to be run just before the &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; does its deed, by setting the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook. The associated handler is called with the error text and can change the error message, if it sees fit, by calling &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again. See &lt;a href=&quot;../perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; for details on setting &lt;code&gt;%SIG&lt;/code&gt; entries, and &lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt; for some examples. Although this feature was to be run only right before your program was to exit, this is not currently so: the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook is currently called even inside eval()ed blocks/strings! If one wants the hook to do nothing in such situations, put</source>
          <target state="translated">&lt;code&gt;$SIG{__DIE__}&lt;/code&gt; フックを設定することにより、 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; が実行する直前にコールバックが実行されるように調整できます。関連付けられているハンドラーはエラーテキストとともに呼び出され、適切な場合は、もう一度 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; を呼び出すことでエラーメッセージを変更できます。参照&lt;a href=&quot;../perlvar#%25SIG&quot;&gt;はperlvarの％SIGの&lt;/a&gt;設定の詳細については、 &lt;code&gt;%SIG&lt;/code&gt; エントリ、と&lt;a href=&quot;#eval-BLOCK&quot;&gt;はeval BLOCKを&lt;/a&gt;いくつかの例について。この機能はプログラムが終了する直前にのみ実行される予定でしたが、現在はそうではありません。 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; フックは、現在eval（）されたブロック/文字列内でも呼び出されます！そのような状況でフックが何もしないようにしたい場合は、</target>
        </trans-unit>
        <trans-unit id="6d6ebe42604b8b630167882d7abe0a8f91ccbdb6" translate="yes" xml:space="preserve">
          <source>You can arrange for a callback to be run just before the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; does its deed, by setting the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook. The associated handler is called with the error text and can change the error message, if it sees fit, by calling &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again. See &lt;a href=&quot;perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; for details on setting &lt;code&gt;%SIG&lt;/code&gt; entries, and &lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt; for some examples. Although this feature was to be run only right before your program was to exit, this is not currently so: the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook is currently called even inside eval()ed blocks/strings! If one wants the hook to do nothing in such situations, put</source>
          <target state="translated">&lt;code&gt;$SIG{__DIE__}&lt;/code&gt; フックを設定することにより、 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; が実行する直前にコールバックが実行されるように調整できます。関連付けられているハンドラーはエラーテキストとともに呼び出され、適切な場合は、もう一度 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; を呼び出すことでエラーメッセージを変更できます。参照&lt;a href=&quot;perlvar#%25SIG&quot;&gt;はperlvarの％SIGの&lt;/a&gt;設定の詳細については、 &lt;code&gt;%SIG&lt;/code&gt; エントリ、と&lt;a href=&quot;#eval-BLOCK&quot;&gt;はeval BLOCKを&lt;/a&gt;いくつかの例について。この機能はプログラムが終了する直前にのみ実行される予定でしたが、現在はそうではありません。 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; フックは、現在eval（）されたブロック/文字列内でも呼び出されます！そのような状況でフックが何もしないようにしたい場合は、</target>
        </trans-unit>
        <trans-unit id="b111cf2dc7e21ab63d8886219ae9103dbe8e5745" translate="yes" xml:space="preserve">
          <source>You can ask &lt;code&gt;prove&lt;/code&gt; to remember the state of previous test runs and select and/or order the tests to be run based on that saved state.</source>
          <target state="translated">以前のテスト実行の状態を覚えている &lt;code&gt;prove&lt;/code&gt; を証明してもらい、その保存された状態に基づいて実行するテストを選択および/または注文することができます。</target>
        </trans-unit>
        <trans-unit id="5be6ec0673c2462bb7fe8ce793fcded60eef0f18" translate="yes" xml:space="preserve">
          <source>You can break circular references by creating a &quot;weak reference&quot;. A weak reference does not increment the reference count for a variable, which means that the object can go out of scope and be destroyed. You can weaken a reference with the &lt;code&gt;weaken&lt;/code&gt; function exported by the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module.</source>
          <target state="translated">「弱い参照」を作成することで循環参照を解除できます。弱い参照は変数の参照カウントをインクリメントしません。つまり、オブジェクトがスコープ外になり、破棄される可能性があります。あなたはして参照を弱めることができ &lt;code&gt;weaken&lt;/code&gt; ことにより、エクスポートされた関数&lt;a href=&quot;scalar/util&quot;&gt;スカラー:: Utilのの&lt;/a&gt;モジュール。</target>
        </trans-unit>
        <trans-unit id="7b50c9286c4042666f0e26f5a3f4bc1fff06eaf5" translate="yes" xml:space="preserve">
          <source>You can call the perl visible subroutine something other than &lt;code&gt;constant&lt;/code&gt; if you give the parameter</source>
          <target state="translated">パラメータを指定すると、perl visibleサブルーチンを &lt;code&gt;constant&lt;/code&gt; 以外のものと呼ぶことができます</target>
        </trans-unit>
        <trans-unit id="03c6b44929e8d300ef044fa7166e3c54539d868d" translate="yes" xml:space="preserve">
          <source>You can capture its numeric and string content using:</source>
          <target state="translated">を使用して、その数値や文字列の内容をキャプチャすることができます。</target>
        </trans-unit>
        <trans-unit id="596d44f0dc27aeca16b120bcaf752ef2dfa99248" translate="yes" xml:space="preserve">
          <source>You can categorize these CES by 3 criteria: size of each character, endianness, and Byte Order Mark.</source>
          <target state="translated">これらのCESは、各文字の大きさ、エンディアン度、バイトオーダーマークの3つの基準で分類することができます。</target>
        </trans-unit>
        <trans-unit id="6b889973d01196115807ed3e24800abe92e6ed58" translate="yes" xml:space="preserve">
          <source>You can change an array element, but you can't change a list element:</source>
          <target state="translated">配列の要素は変更できますが、リストの要素は変更できません。</target>
        </trans-unit>
        <trans-unit id="d178a91245c223a6b3d558a26825e4086182ea75" translate="yes" xml:space="preserve">
          <source>You can change both the effective gid and the real gid at the same time by using &lt;code&gt;POSIX::setgid()&lt;/code&gt; (use only a single numeric argument). Changes to &lt;code&gt;$)&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="translated">&lt;code&gt;POSIX::setgid()&lt;/code&gt; を使用して、有効なgidと実際のgidの両方を同時に変更できます（単一の数値引数のみを使用）。 &lt;code&gt;$)&lt;/code&gt; への変更は$へのチェックが必要です &lt;code&gt;$!&lt;/code&gt; 変更を試みた後に起こり得るエラーを検出するため。</target>
        </trans-unit>
        <trans-unit id="59d9719ad7d1133b142fc0ce7a1557db385a25a2" translate="yes" xml:space="preserve">
          <source>You can change both the effective uid and the real uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Changes to &lt;code&gt;$&amp;gt;&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="translated">&lt;code&gt;POSIX::setuid()&lt;/code&gt; を使用すると、有効なuidと実際のuidの両方を同時に変更できます。 &lt;code&gt;$&amp;gt;&lt;/code&gt; への変更には、 &lt;code&gt;$!&lt;/code&gt; へのチェックが必要です。変更を試みた後に起こり得るエラーを検出するため。</target>
        </trans-unit>
        <trans-unit id="57121de58d74f1a64c5b126aeda69842259d90c4" translate="yes" xml:space="preserve">
          <source>You can change both the real gid and the effective gid at the same time by using &lt;code&gt;POSIX::setgid()&lt;/code&gt; . Changes to &lt;code&gt;$(&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="translated">&lt;code&gt;POSIX::setgid()&lt;/code&gt; を使用すると、実際のgidと有効なgidの両方を同時に変更できます。 &lt;code&gt;$(&lt;/code&gt; への変更は、変更を試みた後に起こり得るエラーを検出するために &lt;code&gt;$!&lt;/code&gt; へのチェックが必要です。</target>
        </trans-unit>
        <trans-unit id="b09c5405e2b602271ef0ef2f3017aa480c6d1079" translate="yes" xml:space="preserve">
          <source>You can change options from</source>
          <target state="translated">からオプションを変更することができます。</target>
        </trans-unit>
        <trans-unit id="d6315b4e978f53eeff4964ee1909c618fbc90cfa" translate="yes" xml:space="preserve">
          <source>You can change the underlying module that does the low-level math operations by using:</source>
          <target state="translated">を使用して、低レベルの数学演算を行う基礎となるモジュールを変更することができます。</target>
        </trans-unit>
        <trans-unit id="ac0967b2c568b641678650e45e2b539ad81b2c7d" translate="yes" xml:space="preserve">
          <source>You can change this backend library by using:</source>
          <target state="translated">このバックエンドライブラリは、以下のようにして変更することができます。</target>
        </trans-unit>
        <trans-unit id="e271d7bee0eb9af50859c996a87b147d97ca08b1" translate="yes" xml:space="preserve">
          <source>You can change this by using:</source>
          <target state="translated">を使って変更することができます。</target>
        </trans-unit>
        <trans-unit id="a8c0aadd56b5a3424b47f02ac266fd1fef206d7e" translate="yes" xml:space="preserve">
          <source>You can check the values of these variables on your system with</source>
          <target state="translated">これらの変数の値は、システム上で</target>
        </trans-unit>
        <trans-unit id="19186d4d2aa107ae87a9009974a30d3e15b94cd1" translate="yes" xml:space="preserve">
          <source>You can choose if you want to always install (yes), never install (no) or be always asked. In the latter case you can set the default answer for the question to yes (ask/yes) or no (ask/no).</source>
          <target state="translated">常にインストールする (yes)、インストールしない (no)、または常に質問されるかどうかを選択できます。後者の場合、質問のデフォルトの答えを yes (尋ねる/yes)または no (尋ねる/no)に設定することができます。</target>
        </trans-unit>
        <trans-unit id="432283768bc5fcc2cbc19482faa7326a0cb0200d" translate="yes" xml:space="preserve">
          <source>You can compare $s1 and $s2 above with</source>
          <target state="translated">上記の$s1と$s2で比較してみてください。</target>
        </trans-unit>
        <trans-unit id="5cd28c9babbe3b0c5cce52c7e8b6bd3de247f8a7" translate="yes" xml:space="preserve">
          <source>You can compile a special debugging version of Perl, which allows you to use the &lt;code&gt;-D&lt;/code&gt; option of Perl to tell more about what Perl is doing. But sometimes there is no alternative than to dive in with a debugger, either to see the stack trace of a core dump (very useful in a bug report), or trying to figure out what went wrong before the core dump happened, or how did we end up having wrong or unexpected results.</source>
          <target state="translated">特別なデバッグバージョンのPerlをコンパイルできます。これにより、Perl の &lt;code&gt;-D&lt;/code&gt; オプションを使用して、Perlの動作の詳細を知ることができます。ただし、コアダンプのスタックトレースを確認する（バグレポートで非常に役立つ）か、コアダンプが発生する前に問題が発生したか、またはどのように実行したかを把握するために、デバッガーを使用する以外に方法がない場合があります。誤った結果や予期しない結果が生じることになります。</target>
        </trans-unit>
        <trans-unit id="87041007fca4b20217db14f0fb86e591cf75c1a4" translate="yes" xml:space="preserve">
          <source>You can compile perl as a universal binary (built for both ppc and intel). In Mac OS X 10.4 &quot;Tiger&quot;, you must export the 'u' variant of the SDK:</source>
          <target state="translated">(ppcとintelの両方のために作られた)ユニバーサルバイナリとしてPerlをコンパイルすることができます。Mac OS X 10.4 &quot;Tiger&quot; では、SDK の 'u' バリアントをエクスポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="fa58ab427e59cc304b800becf278713e2a473dc4" translate="yes" xml:space="preserve">
          <source>You can compute spherical distances, called &lt;b&gt;great circle distances&lt;/b&gt;, by importing the great_circle_distance() function:</source>
          <target state="translated">great_circle_distance（）関数をインポートすることにより、&lt;b&gt;大圏距離&lt;/b&gt;と呼ばれる球面距離を計算できます。</target>
        </trans-unit>
        <trans-unit id="e0e56eaab18c95d9fc59dbbcb6020dceb739e042" translate="yes" xml:space="preserve">
          <source>You can configure &lt;code&gt;CPAN.pm&lt;/code&gt; to automatically use this option too:</source>
          <target state="translated">このオプションを自動的に使用するように &lt;code&gt;CPAN.pm&lt;/code&gt; を構成することもできます。</target>
        </trans-unit>
        <trans-unit id="2d461022ba384996bf77747145dbd16f78eb1d3d" translate="yes" xml:space="preserve">
          <source>You can control which DBM library you use by loading that library before you call dbmopen():</source>
          <target state="translated">dbmopen()を呼び出す前にそのライブラリをロードすることで、どのDBMライブラリを使用するかを制御することができます。</target>
        </trans-unit>
        <trans-unit id="b63a08beb712c643691cdd9c1e77329f30769a82" translate="yes" xml:space="preserve">
          <source>You can create endless loops if the things you serialize via freeze() (for instance) point back to the object we're trying to serialize in the hook.</source>
          <target state="translated">(例えば)freeze()でシリアライズしたものが、フックでシリアライズしようとしているオブジェクトを指すようにすれば、無限ループを作ることができます。</target>
        </trans-unit>
        <trans-unit id="8cc300aa058401f33bcdc1d74e140c0960d7fa90" translate="yes" xml:space="preserve">
          <source>You can define for all tie types an UNTIE method that will be called at untie(). See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.</source>
          <target state="translated">すべてのタイタイプに対して、untie（）で呼び出されるUNTIEメソッドを定義できます。以下&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;のuntie Gotchaを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cd22b39009d785c43f4f9453185f24b021494e27" translate="yes" xml:space="preserve">
          <source>You can define your own binary character properties by defining subroutines whose names begin with &lt;code&gt;&quot;In&quot;&lt;/code&gt; or &lt;code&gt;&quot;Is&quot;&lt;/code&gt; . (The experimental feature &lt;a href=&quot;perlre#(%3f%5b-%5d)&quot;&gt;(?[ ]) in perlre&lt;/a&gt; provides an alternative which allows more complex definitions.) The subroutines can be defined in any package. The user-defined properties can be used in the regular expression &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs; if you are using a user-defined property from a package other than the one you are in, you must specify its package in the &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; construct.</source>
          <target state="translated">名前が &lt;code&gt;&quot;In&quot;&lt;/code&gt; または &lt;code&gt;&quot;Is&quot;&lt;/code&gt; で始まるサブルーチンを定義することにより、独自のバイナリ文字プロパティを定義できます。 （&lt;a href=&quot;perlre#(%3f%5b-%5d)&quot;&gt;perlre&lt;/a&gt;の実験的機能（？[]）は、より複雑な定義を可能にする代替手段を提供します。）サブルーチンは、任意のパッケージで定義できます。ユーザー定義プロパティは、正規表現 &lt;code&gt;\p{}&lt;/code&gt; および &lt;code&gt;\P{}&lt;/code&gt; 構成で使用できます。現在のパッケージ以外のパッケージのユーザー定義プロパティを使用している場合は、 &lt;code&gt;\p{}&lt;/code&gt; または &lt;code&gt;\P{}&lt;/code&gt; 構成でそのパッケージを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="107745b2e3d0c30dbe6a28beb79e3db6db75115c" translate="yes" xml:space="preserve">
          <source>You can define your own character properties and use them in the regular expression with the &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; construct. See &lt;a href=&quot;#User-Defined-Character-Properties&quot;&gt;User-Defined Character Properties&lt;/a&gt; for more details.</source>
          <target state="translated">独自の文字プロパティを定義し、 &lt;code&gt;\p{}&lt;/code&gt; または &lt;code&gt;\P{}&lt;/code&gt; 構成を使用して正規表現で使用できます。詳細については、&lt;a href=&quot;#User-Defined-Character-Properties&quot;&gt;ユーザー定義の文字プロパティ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9472dcd36f94375050dea75545931297e23f500b" translate="yes" xml:space="preserve">
          <source>You can detect the OS mode using &quot;isainfo -v&quot;, e.g.</source>
          <target state="translated">OSのモードは &quot;isainfo -v &quot;を使って検出することができます。</target>
        </trans-unit>
        <trans-unit id="ac56709f3e046a38d3f4f58f4d03fe93d1a1a7f4" translate="yes" xml:space="preserve">
          <source>You can determine your system endianness with this incantation:</source>
          <target state="translated">この呪文で自分のシステムのエンディアン性を見極めることができます。</target>
        </trans-unit>
        <trans-unit id="5e10ee4faf1824e9c84d1fdce76b93c2ae5f9fd0" translate="yes" xml:space="preserve">
          <source>You can disable &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; resets on fail with the &lt;code&gt;c&lt;/code&gt; flag, documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlreref&quot;&gt;perlreref&lt;/a&gt;. Subsequent matches start where the last successful match ended (the value of &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt;) even if a match on the same string has failed in the meantime. In this case, the match after the &lt;code&gt;while()&lt;/code&gt; loop starts at the &lt;code&gt;a&lt;/code&gt; (where the last match stopped), and since it does not use any anchor it can skip over the &lt;code&gt;a&lt;/code&gt; to find &lt;code&gt;44&lt;/code&gt; .</source>
          <target state="translated">&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;および&lt;a href=&quot;perlreref&quot;&gt;perlrerefに&lt;/a&gt;文書化されている &lt;code&gt;c&lt;/code&gt; フラグを使用して、失敗時に &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; リセットを無効にすることができます。同じ文字列の一致がその間に失敗した場合でも、後続の一致は、最後に成功した一致が終了した場所（ &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; の値）から始まります。この場合、 &lt;code&gt;while()&lt;/code&gt; ループの後の一致は &lt;code&gt;a&lt;/code&gt; （最後の一致が停止した場所）から始まり、アンカーを使用しないため、 &lt;code&gt;a&lt;/code&gt; をスキップして &lt;code&gt;44&lt;/code&gt; を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="458912b1d0d0c5a77d13c3e7ffc4ddad22f59daf" translate="yes" xml:space="preserve">
          <source>You can dispense with numbers altogether and create named capture groups. The notation is &lt;code&gt;(?&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;...)&lt;/code&gt; to declare and &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; to reference. (To be compatible with .Net regular expressions, &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; may also be written as &lt;code&gt;\k{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\k&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'&lt;i&gt;name&lt;/i&gt;'&lt;/code&gt;.)</source>
          <target state="translated">数字を省略して、名前付きのキャプチャグループを作成できます。表記は &lt;code&gt;(?&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;...)&lt;/code&gt; で宣言し、 &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; で参照します。（.Net正規表現と互換性を持たせるために、 &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; は &lt;code&gt;\k{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; 、 &lt;code&gt;\k&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt; または &lt;code&gt;\k'&lt;i&gt;name&lt;/i&gt;'&lt;/code&gt; としても記述できます。）</target>
        </trans-unit>
        <trans-unit id="b18d3c8d444331784ad87d0c9066604ce83188e2" translate="yes" xml:space="preserve">
          <source>You can do a similar thing with the value of &lt;code&gt;$0&lt;/code&gt; , which holds the script name. That might hold a relative path, but &lt;code&gt;rel2abs&lt;/code&gt; can turn it into an absolute path. Once you have the</source>
          <target state="translated">スクリプト名を保持する &lt;code&gt;$0&lt;/code&gt; の値でも同様のことができます。それは相対パスを保持するかもしれませんが、 &lt;code&gt;rel2abs&lt;/code&gt; はそれを絶対パスに変えることができます。あなたが持ったら</target>
        </trans-unit>
        <trans-unit id="2cb0b5304ad3a2505b033f6205316fe91cd8667f" translate="yes" xml:space="preserve">
          <source>You can do it yourself:</source>
          <target state="translated">自分でやればいいんだよ。</target>
        </trans-unit>
        <trans-unit id="3df3594ac830b3b367e2449531bc9481e6c2c743" translate="yes" xml:space="preserve">
          <source>You can do some customization by setting up a</source>
          <target state="translated">を設定することで、ある程度のカスタマイズが可能です。</target>
        </trans-unit>
        <trans-unit id="e36b0a11441d7f370d1c8f3b9a2c5df0ed14fec0" translate="yes" xml:space="preserve">
          <source>You can do the same thing with foreach and a match using the c flag and the \G anchor, if you do not mind your entire file being in memory at the end.</source>
          <target state="translated">ファイル全体が最後にメモリに残ることを気にしないのであれば、c フラグと \G アンカーを使って、foreach と match で同じことができます。</target>
        </trans-unit>
        <trans-unit id="94475bd1aa00e25358f732725451e1c48c0023a3" translate="yes" xml:space="preserve">
          <source>You can do this by filtering a list of &lt;code&gt;Archive::Tar::File&lt;/code&gt; objects based on your criteria. For example, to extract only files that have the string &lt;code&gt;foo&lt;/code&gt; in their title, you would use:</source>
          <target state="translated">これを行うには、基準に基づいて &lt;code&gt;Archive::Tar::File&lt;/code&gt; オブジェクトのリストをフィルタリングします。たとえば、タイトルに文字列 &lt;code&gt;foo&lt;/code&gt; が含まれるファイルのみを抽出するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="e3b58ea141bf0b2ab8308eba04e2fe1187709b38" translate="yes" xml:space="preserve">
          <source>You can do this in</source>
          <target state="translated">で行うことができます。</target>
        </trans-unit>
        <trans-unit id="0e82d2d4c5fee3c3455ee13c93472ac8305c2886" translate="yes" xml:space="preserve">
          <source>You can do various useful things to lists:</source>
          <target state="translated">リストにはいろいろと便利なことができます。</target>
        </trans-unit>
        <trans-unit id="2293c83d7e9f41c388c0c9ef674c18441a39f91a" translate="yes" xml:space="preserve">
          <source>You can download the NDK from &lt;a href=&quot;http://developer.blackberry.com/native/downloads/&quot;&gt;http://developer.blackberry.com/native/downloads/&lt;/a&gt;.</source>
          <target state="translated">NDKは&lt;a href=&quot;http://developer.blackberry.com/native/downloads/&quot;&gt;http://developer.blackberry.com/native/downloads/&lt;/a&gt;からダウンロードできます。</target>
        </trans-unit>
        <trans-unit id="2add1e5f384d4e366c7f0bda81dca221784f796a" translate="yes" xml:space="preserve">
          <source>You can easily do this yourself too by checking each level of the hash before you move onto the next level. This is essentially what &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; does for you:</source>
          <target state="translated">次のレベルに進む前にハッシュの各レベルをチェックすることで、これも自分で簡単に行うことができます。これは本質的に&lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data :: Diver&lt;/a&gt;があなたのために行うことです：</target>
        </trans-unit>
        <trans-unit id="aca937c9b8249ef74f6bdd2a2c24ef2b2c942c33" translate="yes" xml:space="preserve">
          <source>You can effect a sleep of 250 milliseconds this way:</source>
          <target state="translated">このようにして250ミリ秒のスリープを効果的に行うことができます。</target>
        </trans-unit>
        <trans-unit id="2cf03e7d8c028c108e1f07b9fdfd93ec5a0911cb" translate="yes" xml:space="preserve">
          <source>You can either get the latest perl-for-amiga source from Ninemoons and extract it with:</source>
          <target state="translated">Ninemoonsから最新のperl-for-amigaのソースを入手して、それをNinemoonsで抽出するか。</target>
        </trans-unit>
        <trans-unit id="dc1b686bd86f9825c512e3b19e24ca27d9b0e88c" translate="yes" xml:space="preserve">
          <source>You can embed Pod documentation in your Perl modules and scripts. Start your documentation with an empty line, a &quot;=head1&quot; command at the beginning, and end it with a &quot;=cut&quot; command and an empty line. The &lt;b&gt;perl&lt;/b&gt; executable will ignore the Pod text. You can place a Pod statement where &lt;b&gt;perl&lt;/b&gt; expects the beginning of a new statement, but not within a statement, as that would result in an error. See any of the supplied library modules for examples.</source>
          <target state="translated">Perlモジュールとスクリプトにポッドドキュメントを埋め込むことができます。ドキュメントを空の行で始め、「= head1」コマンドを最初に置き、「= cut」コマンドと空の行で終わります。&lt;b&gt;perlの&lt;/b&gt;実行ファイルは、ポッドのテキストを無視します。エラーが発生するため、&lt;b&gt;Perl&lt;/b&gt;が新しいステートメントの開始を期待する場所にPodステートメントを配置できますが、ステートメント内には配置できません。例については、提供されているライブラリモジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="4e8901a24d5203f278555dd6630e84e6495d5c32" translate="yes" xml:space="preserve">
          <source>You can enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; by using either the &lt;code&gt;-C&lt;/code&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable, see &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for the documentation of the &lt;code&gt;-C&lt;/code&gt; switch.</source>
          <target state="translated">あなたは、あなたの標準ファイルハンドルの自動的なUTF-8-ificationを有効にデフォルトすることができます &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 層、および &lt;code&gt;@ARGV&lt;/code&gt; をどちらか使用して &lt;code&gt;-C&lt;/code&gt; コマンドラインスイッチまたは &lt;code&gt;PERL_UNICODE&lt;/code&gt; の環境変数を参照してください&lt;a href=&quot;perlrun&quot;&gt;はperlrun&lt;/a&gt;のドキュメントについては &lt;code&gt;-C&lt;/code&gt; スイッチ。</target>
        </trans-unit>
        <trans-unit id="9b7d65e57af61c849fd344c325e8ff8558b6ea76" translate="yes" xml:space="preserve">
          <source>You can enable this program wide by setting the package variable &lt;code&gt;$Params::Check::VERBOSE&lt;/code&gt; to a true value. For details, see the section on &lt;code&gt;Global Variables&lt;/code&gt; below.</source>
          <target state="translated">パッケージ変数 &lt;code&gt;$Params::Check::VERBOSE&lt;/code&gt; をtrue値に設定することにより、このプログラム全体を有効にすることができます。詳細については、以下の &lt;code&gt;Global Variables&lt;/code&gt; のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="bd9f5fdd175da39fdf1b2aee95117b6f24089729" translate="yes" xml:space="preserve">
          <source>You can even add a line to the beginning of a file, since the current line prints at the end of the loop:</source>
          <target state="translated">ループの最後に現在の行が表示されるので、ファイルの先頭に行を追加することもできます。</target>
        </trans-unit>
        <trans-unit id="469cbe63338eb0799dde10314ea7997fd8799ab7" translate="yes" xml:space="preserve">
          <source>You can even chain the operations together as usual:</source>
          <target state="translated">いつものように操作を連鎖させることもできます。</target>
        </trans-unit>
        <trans-unit id="2aadc431d196d9bef8923dcadb3a5f0c2d7f67b9" translate="yes" xml:space="preserve">
          <source>You can even set them to pipe commands. For example, this automatically filters compressed arguments through &lt;b&gt;gzip&lt;/b&gt;:</source>
          <target state="translated">コマンドをパイプするように設定することもできます。たとえば、これは&lt;b&gt;gzip&lt;/b&gt;を通じて圧縮された引数を自動的にフィルタリングします。</target>
        </trans-unit>
        <trans-unit id="5959df3dd95aca5e6820f2cd7c4389121f214d69" translate="yes" xml:space="preserve">
          <source>You can examine the @INC variable from within a perl program to see the order in which Perl searches these directories.</source>
          <target state="translated">perlプログラムの中から@INC変数を調べて、Perlがこれらのディレクトリを検索する順番を見ることができます。</target>
        </trans-unit>
        <trans-unit id="b698e2e22416ac9eb31f0b1d16a0dd9b5e075ed0" translate="yes" xml:space="preserve">
          <source>You can expand the macros in a</source>
          <target state="translated">でマクロを展開することができます。</target>
        </trans-unit>
        <trans-unit id="c6984ea0cc547a7d94d70f8b198039214ca8c15f" translate="yes" xml:space="preserve">
          <source>You can explore the endianness of your platform by unpacking a data structure packed in native format such as:</source>
          <target state="translated">のようなネイティブ形式でパックされたデータ構造を解凍することで、プラットフォームのエンディアン性を探ることができます。</target>
        </trans-unit>
        <trans-unit id="25084ad020c81115ae6c13e15f94c38c747b7c70" translate="yes" xml:space="preserve">
          <source>You can explore various information from the Unicode data files using the &lt;code&gt;Unicode::UCD&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;Unicode::UCD&lt;/code&gt; モジュールを使用して、Unicodeデータファイルからさまざまな情報を探索できます。</target>
        </trans-unit>
        <trans-unit id="214226a1ed44146fabbcdf1d7ff955aea72e1c83" translate="yes" xml:space="preserve">
          <source>You can extend the data conversion shortcuts menu, so for example you can display an SV's IV value with one click, without doing any typing. To do that simply edit ~/.ddd/init file and add after:</source>
          <target state="translated">データ変換のショートカットメニューを拡張することができ、例えば SV の IV 値をワンクリックで表示することができます。これを行うには、~/.ddd/initファイルを編集して後から追加するだけです。</target>
        </trans-unit>
        <trans-unit id="9f3b19dace5e1ee6e80db897c83810c886662b0c" translate="yes" xml:space="preserve">
          <source>You can fake a static variable by using a lexical variable which goes out of scope. In this example, you define the subroutine &lt;code&gt;counter&lt;/code&gt; , and it uses the lexical variable &lt;code&gt;$count&lt;/code&gt; . Since you wrap this in a BEGIN block, &lt;code&gt;$count&lt;/code&gt; is defined at compile-time, but also goes out of scope at the end of the BEGIN block. The BEGIN block also ensures that the subroutine and the value it uses is defined at compile-time so the subroutine is ready to use just like any other subroutine, and you can put this code in the same place as other subroutines in the program text (i.e. at the end of the code, typically). The subroutine &lt;code&gt;counter&lt;/code&gt; still has a reference to the data, and is the only way you can access the value (and each time you do, you increment the value). The data in chunk of memory defined by &lt;code&gt;$count&lt;/code&gt; is private to &lt;code&gt;counter&lt;/code&gt; .</source>
          <target state="translated">スコープ外のレキシカル変数を使用して、静的変数を偽造できます。この例では、サブルーチン &lt;code&gt;counter&lt;/code&gt; を定義し、レキシカル変数 &lt;code&gt;$count&lt;/code&gt; 使用しています。これをBEGINブロックでラップするため、 &lt;code&gt;$count&lt;/code&gt; はコンパイル時に定義されますが、BEGINブロックの最後でスコープ外になります。BEGINブロックは、サブルーチンとそれが使用する値がコンパイル時に定義されることも保証するため、サブルーチンは他のサブルーチンと同じように使用できる状態になり、このコードをプログラムテキスト内の他のサブルーチンと同じ場所に配置できます（つまり、コードの最後に、通常）。サブルーチン &lt;code&gt;counter&lt;/code&gt; まだデータへの参照があり、値にアクセスできる唯一の方法です（アクセスするたびに値をインクリメントします）。 &lt;code&gt;$count&lt;/code&gt; 定義されたメモリのチャンク内のデータは、 &lt;code&gt;counter&lt;/code&gt; 専用です。</target>
        </trans-unit>
        <trans-unit id="98bfa69a23c16121bcf7918a14cd66f9c3c6d27f" translate="yes" xml:space="preserve">
          <source>You can find documentation for this module with the perldoc command.</source>
          <target state="translated">このモジュールのドキュメントは perldoc コマンドで見つけることができます。</target>
        </trans-unit>
        <trans-unit id="2ec893daacd3a612f16b5ff8e3b0ca737de8a9f5" translate="yes" xml:space="preserve">
          <source>You can find more info about Configure's command line switches in the</source>
          <target state="translated">Configure のコマンドラインスイッチについての詳細は</target>
        </trans-unit>
        <trans-unit id="60d30b2a5683150ee021b2d2efe823e684b28b49" translate="yes" xml:space="preserve">
          <source>You can find out whether Perl considers &quot;long double&quot; to be the default floating-point size to use on your platform via &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">Perlが &quot;long double&quot;を&lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;を介してプラットフォームで使用するデフォルトの浮動小数点サイズであると見なしているかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="0a14665644553d1c1ca40b3a369c0cfc1687919b" translate="yes" xml:space="preserve">
          <source>You can find out whether Perl considers &quot;long double&quot; to be the default floating-point size to use on your platform via &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">Perlが &quot;long double&quot;を&lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;を介してプラットフォームで使用するデフォルトの浮動小数点サイズであると見なしているかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="a8c0376796b23fff5ec186fab67f5500801dd3ed" translate="yes" xml:space="preserve">
          <source>You can find out whether your Perl supports quads via &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">Perlが&lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;を介してクワッドをサポートしているかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="977c50ef8718482d8b17abe375d1697e8f9a2d66" translate="yes" xml:space="preserve">
          <source>You can find out whether your Perl supports quads via &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">Perlが&lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;を介してクワッドをサポートしているかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="58566ff87e227e47e0a6175cb880b0492ff07d0d" translate="yes" xml:space="preserve">
          <source>You can find the bytes that make up a UTF-8 sequence with</source>
          <target state="translated">UTF-8 シーケンスを構成するバイトは、次のようにして見つけることができます。</target>
        </trans-unit>
        <trans-unit id="d66bda1e5630ce31a16d647268de04ca99f2d093" translate="yes" xml:space="preserve">
          <source>You can find the full DJGPP distribution on any of the mirrors listed here:</source>
          <target state="translated">DJGPP の完全なディストリビューションは、ここに掲載されているミラーのいずれかで見つけることができます。</target>
        </trans-unit>
        <trans-unit id="53a7bd12f9a84d4d155f8bc43066fe15624ba305" translate="yes" xml:space="preserve">
          <source>You can find them for example by</source>
          <target state="translated">例えば、以下のような方法で見つけることができます。</target>
        </trans-unit>
        <trans-unit id="abd3b038a5876faa8d912c01ba340b1b8ceaabfa" translate="yes" xml:space="preserve">
          <source>You can follow the formats with numbers to say how many characters should be affected by that format: &lt;code&gt;A12&lt;/code&gt; means &quot;take 12 characters&quot;; &lt;code&gt;x6&lt;/code&gt; means &quot;skip 6 bytes&quot; or &quot;character 0, 6 times&quot;.</source>
          <target state="translated">フォーマットに数字を付けて、そのフォーマットの影響を受ける文字数を指定できます &lt;code&gt;A12&lt;/code&gt; は「12文字を取る」を意味します。 &lt;code&gt;x6&lt;/code&gt; は、「6バイトをスキップ」または「文字0、6回」を意味します。</target>
        </trans-unit>
        <trans-unit id="3e5ffde15ed2080164a5592bd7bb881aeab7fa67" translate="yes" xml:space="preserve">
          <source>You can force Perl to interpret the bareword as a class name by appending &quot;::&quot; to it, like we saw earlier:</source>
          <target state="translated">先ほど見たように、「:::」を付け加えることで、Perl を強制的にベアワードをクラス名として解釈させることができます。</target>
        </trans-unit>
        <trans-unit id="6a0f7fd6c71d8ef00acad73e562310bfdc7188b5" translate="yes" xml:space="preserve">
          <source>You can force Perl to use the first interpretation (i.e. as a method call on the class named &quot;Class&quot;) in two ways. First, you can append a &lt;code&gt;::&lt;/code&gt; to the class name:</source>
          <target state="translated">Perlに最初の解釈を（つまり、「クラス」という名前のクラスのメソッド呼び出しとして）使用するように強制するには、2つの方法があります。まず、クラス名に &lt;code&gt;::&lt;/code&gt; を追加できます。</target>
        </trans-unit>
        <trans-unit id="3683b364293548110b32df191aa4769c6b0d7861" translate="yes" xml:space="preserve">
          <source>You can force a backreference interpretation always by using the &lt;code&gt;\g{...}&lt;/code&gt; form. You can the force an octal interpretation always by using the &lt;code&gt;\o{...}&lt;/code&gt; form, or for numbers up through \077 (= 63 decimal), by using three digits, beginning with a &quot;0&quot;.</source>
          <target state="translated">&lt;code&gt;\g{...}&lt;/code&gt; フォームを使用すると、常に後方参照解釈を強制できます。 &lt;code&gt;\o{...}&lt;/code&gt; 形式を使用するか、\ 077（10進数= 63）までの数値の場合は、常に「0」で始まる3桁を使用して、8進数の解釈を強制できます。</target>
        </trans-unit>
        <trans-unit id="b877192684c9091db1ed512a1471d2f292aa330b" translate="yes" xml:space="preserve">
          <source>You can force an SV to make its own copy of its string buffer by calling &lt;code&gt;sv_force_normal(sv)&lt;/code&gt; or SvPV_force_nolen(sv).</source>
          <target state="translated">&lt;code&gt;sv_force_normal(sv)&lt;/code&gt; またはSvPV_force_nolen（sv）を呼び出すことにより、SVに文字列バッファの独自のコピーを作成させることができます。</target>
        </trans-unit>
        <trans-unit id="59bd5097130055276750c2a4628acf949f4c2e6b" translate="yes" xml:space="preserve">
          <source>You can get a precompiled version of gcc from &lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt; or &lt;a href=&quot;http://www.blastwave.org/&quot;&gt;http://www.blastwave.org/&lt;/a&gt;. Make sure you pick up the package for your Solaris release.</source>
          <target state="translated">プリコンパイルされたバージョンのgccは、&lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt;または&lt;a href=&quot;http://www.blastwave.org/&quot;&gt;http://www.blastwave.org/&lt;/a&gt;から入手できます。Solarisリリース用のパッケージを必ず選択してください。</target>
        </trans-unit>
        <trans-unit id="6c43b7d416e3df44e0ee3889ce9e7a7e5b755245" translate="yes" xml:space="preserve">
          <source>You can get an overview of all the files with this command:</source>
          <target state="translated">このコマンドですべてのファイルの概要を知ることができます。</target>
        </trans-unit>
        <trans-unit id="a325b2e4941194b844aaba1d34803d7f10c46f65" translate="yes" xml:space="preserve">
          <source>You can get and set the current length of the string stored in an SV with the following macros:</source>
          <target state="translated">SV に格納されている文字列の現在の長さを以下のマクロで取得・設定することができます。</target>
        </trans-unit>
        <trans-unit id="498e28fc3884e7bafa55f40835a491ab14376104" translate="yes" xml:space="preserve">
          <source>You can get around this in several ways depending on our situation. First, if you don't want any of the characters in the string to be special, you can escape them with &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; before you use the string.</source>
          <target state="translated">あなたは私たちの状況に応じていくつかの方法でこれを回避することができます。まず、文字列内の文字を特別なものにし &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; ない場合は、文字列を使用する前にquotemetaでエスケープできます。</target>
        </trans-unit>
        <trans-unit id="2880274dc7c0ec586da21bf05619e960d62718ce" translate="yes" xml:space="preserve">
          <source>You can get at any of these quantities from C very easily; just add &lt;code&gt;Sv&lt;/code&gt; to the name of the field shown in the snippet, and you've got a macro which will return the value: &lt;code&gt;SvCUR(sv)&lt;/code&gt; returns the current length of the string, &lt;code&gt;SvREFCOUNT(sv)&lt;/code&gt; returns the reference count, &lt;code&gt;SvPV(sv, len)&lt;/code&gt; returns the string itself with its length, and so on. More macros to manipulate these properties can be found in &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">Cからこれらの量を非常に簡単に取得できます。スニペットに表示されているフィールドの名前に &lt;code&gt;Sv&lt;/code&gt; を追加するだけで、値を返すマクロが得られます &lt;code&gt;SvCUR(sv)&lt;/code&gt; は文字列の現在の長さを返し、 &lt;code&gt;SvREFCOUNT(sv)&lt;/code&gt; は参照カウントを返します &lt;code&gt;SvPV(sv, len)&lt;/code&gt; は、文字列自体とその長さなどを返します。これらのプロパティを操作するためのより多くのマクロが&lt;a href=&quot;perlguts&quot;&gt;perlgutsにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="98610d953793b8d3a809dccac32eb0df790fe7b6" translate="yes" xml:space="preserve">
          <source>You can get at lists of keys and values with &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values()&lt;/a&gt;&lt;/code&gt; を使用して、キーと値のリストを取得できます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
