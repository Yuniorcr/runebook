<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="a60da6ae1477278e788b56dd12901cf6a9b5b818" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; to the value returned by &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">ランダムな小数ではなくランダムな整数が必要な場合は、 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; によって返される値に &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; を適用します。例えば、</target>
        </trans-unit>
        <trans-unit id="974cf6b03d0010e4742b565eeb776443fe41243e" translate="yes" xml:space="preserve">
          <source>Apply Perl-specific heuristics to find the correct PODs. This includes stripping Perl-like extensions, omitting subdirectories that are numeric but do</source>
          <target state="translated">正しい POD を見つけるために Perl 固有のヒューリスティックを適用します。これには、Perl ライクな拡張機能を削除したり、数値ではあるが</target>
        </trans-unit>
        <trans-unit id="baaa234761c2eef7e15c7c661df9bd832e32f420" translate="yes" xml:space="preserve">
          <source>Apply a list of switch options to the state, updating the internal object state as a result. Nothing is returned.</source>
          <target state="translated">スイッチオプションのリストを状態に適用し、その結果として内部オブジェクトの状態を更新します。何も返されません。</target>
        </trans-unit>
        <trans-unit id="c72c1cee8e4b08228a22dc9c5e025abf27a61b14" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;autodie&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; causes the exotic forms &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; { $cmd } @args &lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; { $cmd } @args&lt;/code&gt; to be considered a syntax error until the end of the lexical scope. If you really need to use the exotic form, you can call &lt;code&gt;CORE::system&lt;/code&gt; or &lt;code&gt;CORE::exec&lt;/code&gt; instead, or use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(system exec)&lt;/code&gt; before calling the exotic form.</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; に適用すると、エキゾチックフォーム &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; { $cmd } @args &lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; { $cmd } @args&lt;/code&gt; は、字句スコープの終わりまで構文エラーと見なされます。エキゾチックなフォームを本当に使用する必要がある場合は、代わりに &lt;code&gt;CORE::system&lt;/code&gt; または &lt;code&gt;CORE::exec&lt;/code&gt; を呼び出すか、エキゾチックなフォームを呼び出す前に &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(system exec)&lt;/code&gt; 使用し&lt;a href=&quot;functions/no&quot;&gt;ないで&lt;/a&gt;ください。</target>
        </trans-unit>
        <trans-unit id="7b6bbaf0846e0f6542bb5b50d36df38212d67922" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;$myarray[$key] = $val;&lt;/code&gt; .</source>
          <target state="translated">おおよそのPerl相当： &lt;code&gt;$myarray[$key] = $val;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="255706027acb3bbb6c23a2beab5baa7da2561792" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; .</source>
          <target state="translated">おおよそのPerl同等物： &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b7d5efdfeaa09de6b4d853375871c9207032b5a" translate="yes" xml:space="preserve">
          <source>April 04-07th, 1997: by Jarkko Hietaniemi, added the run-for-some-time functionality.</source>
          <target state="translated">1997年04月04日~07日:Jarkko Hietaniemi氏による、ランフォーサム機能の追加。</target>
        </trans-unit>
        <trans-unit id="5383ba59b7a51b492dcc518df7e4190d4cdf46a1" translate="yes" xml:space="preserve">
          <source>Arbitrary big rational numbers</source>
          <target state="translated">任意の大きな有理数</target>
        </trans-unit>
        <trans-unit id="d355876ea51e167fe43014294b56e66adbafd342" translate="yes" xml:space="preserve">
          <source>Arbitrary size floating point math package</source>
          <target state="translated">任意サイズの浮動小数点演算パッケージ</target>
        </trans-unit>
        <trans-unit id="94977ff2a6f2fcf0486458c46c172275ed7d1a6e" translate="yes" xml:space="preserve">
          <source>Arbitrary size integer/float math package</source>
          <target state="translated">任意のサイズの整数/浮動小数点演算パッケージ</target>
        </trans-unit>
        <trans-unit id="f96ddf323d8050458b6f5da00e7d15254e6e51f7" translate="yes" xml:space="preserve">
          <source>Arch</source>
          <target state="translated">Arch</target>
        </trans-unit>
        <trans-unit id="ba6c5bbd1305838d356b1a16f613e5175253fc77" translate="yes" xml:space="preserve">
          <source>Archive::Tar</source>
          <target state="translated">Archive::Tar</target>
        </trans-unit>
        <trans-unit id="57cc32f42ad2d2bee580d99c3d374961c6559947" translate="yes" xml:space="preserve">
          <source>Archive::Tar - module for manipulations of tar archives</source>
          <target state="translated">Archive::Tar-tar アーカイブを操作するためのモジュール</target>
        </trans-unit>
        <trans-unit id="987b760cdf9eb8e8f22f82c621b2dbe3ee552aeb" translate="yes" xml:space="preserve">
          <source>Archive::Tar provides an object oriented mechanism for handling tar files. It provides class methods for quick and easy files handling while also allowing for the creation of tar file objects for custom manipulation. If you have the IO::Zlib module installed, Archive::Tar will also support compressed or gzipped tar files.</source>
          <target state="translated">Archive::Tar は、tar ファイルを扱うためのオブジェクト指向のメカニズムを提供します。素早く簡単にファイルを扱うためのクラスメソッドを提供する一方で、カスタム操作用の tar ファイルオブジェクトの作成も可能です。IO::Zlib モジュールがインストールされている場合、Archive::Tar は圧縮された tar ファイルや圧縮された tar ファイルもサポートします。</target>
        </trans-unit>
        <trans-unit id="7c0d8b6a96eeaeee2b14e15f99110273c20f8435" translate="yes" xml:space="preserve">
          <source>Archive::Tar will warn if you try to pass a bzip2 compressed file and the IO::Zlib / IO::Uncompress::Bunzip2 modules are not available and simply return.</source>
          <target state="translated">Archive::Tar は、bzip2 圧縮ファイルを渡そうとして IO::Zlib/IO::Uncompress::Bunzip2 モジュールが利用できない場合に警告を発し、単に返すだけです。</target>
        </trans-unit>
        <trans-unit id="ccbf19882dacfbec62ca802f4c207f93b26aac20" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;can_handle_compressed_files</source>
          <target state="translated">Archive::Tar-&amp;gt;can_handle_compressed_files</target>
        </trans-unit>
        <trans-unit id="3b7da738f6421ea5f244ab2a75337cb19a765083" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;create_archive($file, $compressed, @filelist)</source>
          <target state="translated">Archive :: Tar-&amp;gt; create_archive（$ file、$ compressed、@filelist）</target>
        </trans-unit>
        <trans-unit id="1dcbd289acf336b4bc9986937face374b8265d16" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;extract_archive($file, $compressed)</source>
          <target state="translated">Archive :: Tar-&amp;gt; extract_archive（$ file、$ compressed）</target>
        </trans-unit>
        <trans-unit id="8336b53d325ea70cb860e4292e999b5eb8ccc20b" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;iter( $filename, [ $compressed, {opt =&amp;gt; $val} ] )</source>
          <target state="translated">Archive :: Tar-&amp;gt; iter（$ filename、[$ compressed、{opt =&amp;gt; $ val}]）</target>
        </trans-unit>
        <trans-unit id="7b5db2965e54185ceb8a82cfef6b3bcf83d67256" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;list_archive($file, $compressed, [\@properties])</source>
          <target state="translated">Archive :: Tar-&amp;gt; list_archive（$ file、$ compressed、[\ @properties]）</target>
        </trans-unit>
        <trans-unit id="2b89433003c5207f03c7ec11ee01b11e8497bdb8" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;new( [$file, $compressed] )</source>
          <target state="translated">Archive :: Tar-&amp;gt; new（[$ file、$ compressed]）</target>
        </trans-unit>
        <trans-unit id="3fdd79ccbef7cb27b73af9645a51c4748537632a" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File</source>
          <target state="translated">Archive::Tar::File</target>
        </trans-unit>
        <trans-unit id="e4450126317363219e2891fd96c92d67bb8fdb14" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File - a subclass for in-memory extracted file from Archive::Tar</source>
          <target state="translated">Archive::Tar::File-Archive::Tar からメモリ内で抽出されたファイルのサブクラス</target>
        </trans-unit>
        <trans-unit id="9bb643189669555fb8fc9a5ad660a12af02d7c6a" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( chunk =&amp;gt; $chunk )</source>
          <target state="translated">Archive :: Tar :: File-&amp;gt; new（chunk =&amp;gt; $ chunk）</target>
        </trans-unit>
        <trans-unit id="ba9618dfc7889be15218e3ccacc09c8bf242756f" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( data =&amp;gt; $path, $data, $opt )</source>
          <target state="translated">Archive :: Tar :: File-&amp;gt; new（data =&amp;gt; $ path、$ data、$ opt）</target>
        </trans-unit>
        <trans-unit id="a50e4ac8ad32b339e1eb6dee5ec96a58d21300c3" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( file =&amp;gt; $path )</source>
          <target state="translated">Archive :: Tar :: File-&amp;gt; new（file =&amp;gt; $ path）</target>
        </trans-unit>
        <trans-unit id="752ab891c175e9890243ad0568d1b63da7b75555" translate="yes" xml:space="preserve">
          <source>Archive::Tar::Files provides a neat little object layer for in-memory extracted files. It's mostly used internally in Archive::Tar to tidy up the code, but there's no reason users shouldn't use this API as well.</source>
          <target state="translated">Archive::Tar::Files は、メモリ内で抽出されたファイルのためのきちんとした小さなオブジェクト層を提供します。ほとんどの場合、Archive::Tar の内部でコードを整理するために使われていますが、ユーザーがこの API を使わない理由はありません。</target>
        </trans-unit>
        <trans-unit id="2fa2e509f071fa28e01ed08cd42d1e6a982c1c93" translate="yes" xml:space="preserve">
          <source>Archiving and Compression</source>
          <target state="translated">アーカイブと圧縮</target>
        </trans-unit>
        <trans-unit id="470ed7908583fc807812b6f6f1c733d168001e41" translate="yes" xml:space="preserve">
          <source>Are Perl regexes DFAs or NFAs? Are they POSIX compliant?</source>
          <target state="translated">Perl の正規表現は DFA ですか NFA ですか?POSIXに準拠していますか?</target>
        </trans-unit>
        <trans-unit id="eb00fa046e6f0e29e318d2fe47833f95b6115931" translate="yes" xml:space="preserve">
          <source>Are These Threads The Same?</source>
          <target state="translated">これらのスレッドは同じですか?</target>
        </trans-unit>
        <trans-unit id="4b1b74d280a485e3d6be58ac5945ac8cbddc5958" translate="yes" xml:space="preserve">
          <source>Are not yet implemented.</source>
          <target state="translated">まだ実装されていません。</target>
        </trans-unit>
        <trans-unit id="1c7b6fd019a3db8f66c106580e36cbc2e27fdf91" translate="yes" xml:space="preserve">
          <source>Are you running Windows, and did you write</source>
          <target state="translated">Windowsを起動していて</target>
        </trans-unit>
        <trans-unit id="9835fff08898bf6d47cdf47b75c3d5a32e54abb7" translate="yes" xml:space="preserve">
          <source>Are you using a really old version of Perl?</source>
          <target state="translated">本当に古いバージョンのPerlを使っていませんか?</target>
        </trans-unit>
        <trans-unit id="6fa0e4cab9d0443ef8c9e6c56e4240cbc1230cdb" translate="yes" xml:space="preserve">
          <source>Arguably, these are the only routines you'll ever need to execute snippets of Perl code from within your C program. Your code can be as long as you wish; it can contain multiple statements; it can employ &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;, and &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; to include external Perl files.</source>
          <target state="translated">おそらく、これらはCプログラム内からPerlコードのスニペットを実行するために必要な唯一のルーチンです。コードは好きなだけ長くできます。複数のステートメントを含めることができます。&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;、&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;、および&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;を使用して、外部Perlファイルを含めることができます。</target>
        </trans-unit>
        <trans-unit id="068c4f93ca844add9151394d87be6f0eff5098cb" translate="yes" xml:space="preserve">
          <source>Argument callback</source>
          <target state="translated">引数コールバック</target>
        </trans-unit>
        <trans-unit id="becc16f3f9567f706b791b0867003075aa38f700" translate="yes" xml:space="preserve">
          <source>Argument stack</source>
          <target state="translated">引数スタック</target>
        </trans-unit>
        <trans-unit id="9acc1ee24f849a6b6943c3856e23bafeb8ea115e" translate="yes" xml:space="preserve">
          <source>Argument stack manipulation in the core is exactly the same as it is in XSUBs - see &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;, &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; for a longer description of the macros used in stack manipulation.</source>
          <target state="translated">コアの引数スタック操作は、XSUBの場合とまったく同じです。スタック操作で使用されるマクロの詳細については、&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;、&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;、および&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1e682d21a155016274d4c0edada169602cf2db63" translate="yes" xml:space="preserve">
          <source>Arguments are case insensitive.</source>
          <target state="translated">引数は大文字と小文字を区別しません。</target>
        </trans-unit>
        <trans-unit id="f350823ca978137e84ceb658074c062e77adbc5a" translate="yes" xml:space="preserve">
          <source>Arguments are forced into the integer format if not strings.</source>
          <target state="translated">引数は文字列でない場合は強制的に整数形式になります。</target>
        </trans-unit>
        <trans-unit id="e574a112087c49e835619f8e2053ef81199f3165" translate="yes" xml:space="preserve">
          <source>Arguments are passed to PP code and returned from PP code using the argument stack, &lt;code&gt;ST&lt;/code&gt; . The typical way to handle arguments is to pop them off the stack, deal with them how you wish, and then push the result back onto the stack. This is how, for instance, the cosine operator works:</source>
          <target state="translated">引数はPPコードに渡され、引数スタック &lt;code&gt;ST&lt;/code&gt; を使用してPPコードから返されます。引数を処理する一般的な方法は、引数をスタックからポップし、必要に応じて処理してから、結果をスタックにプッシュすることです。これは、たとえば余弦演算子がどのように機能するかです。</target>
        </trans-unit>
        <trans-unit id="5fccb02bffe9af13a6b48fc881c2035657ec7bff" translate="yes" xml:space="preserve">
          <source>Arguments are usually formatted to be only as wide as required to display the given value. You can override the width by putting a number here, or get the width from the next argument (with &lt;code&gt;*&lt;/code&gt; ) or from a specified argument (e.g., with &lt;code&gt;*2$&lt;/code&gt;):</source>
          <target state="translated">引数は通常、指定された値を表示するために必要な幅のみにフォーマットされます。ここに数値を入力して幅を上書きするか、次の引数（ &lt;code&gt;*&lt;/code&gt; を使用）または指定した引数（ &lt;code&gt;*2$&lt;/code&gt; ）から幅を取得できます。</target>
        </trans-unit>
        <trans-unit id="4fb3861e253aa9c040fd66d90deafd1a6d71292f" translate="yes" xml:space="preserve">
          <source>Arguments of the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive are (key, value) pairs. For the full set of legal keys, see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; ディレクティブの引数は、（キー、値）のペアです。正当なキーの完全なセットについては、以下の&lt;a href=&quot;#Overloadable-Operations&quot;&gt;オーバーロード可能なオペレーションを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5141dae339b17f35a7a4380f8f719ce252ef43f8" translate="yes" xml:space="preserve">
          <source>Arguments that don't start with a hyphen are taken to be the names of subroutines or formats to render; if no such functions are specified, the main body of the program (outside any subroutines, and not including use'd or require'd files) is rendered. Passing &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , or &lt;code&gt;END&lt;/code&gt; will cause all of the corresponding special blocks to be printed. Arguments must follow options.</source>
          <target state="translated">ハイフンで始まらない引数は、レンダリングするサブルーチンまたはフォーマットの名前と見なされます。そのような関数が指定されていない場合、プログラムの本体（サブルーチンの外にあり、use'dまたはrequire'dファイルを含まない）がレンダリングされます。 &lt;code&gt;BEGIN&lt;/code&gt; 、 &lt;code&gt;UNITCHECK&lt;/code&gt; 、 &lt;code&gt;CHECK&lt;/code&gt; 、 &lt;code&gt;INIT&lt;/code&gt; 、または &lt;code&gt;END&lt;/code&gt; を渡すと、対応するすべての特殊ブロックが印刷されます。引数はオプションに従う必要があります。</target>
        </trans-unit>
        <trans-unit id="ce73d1bc99ee20ea72fd21908b3617e55e0813cc" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; checked for taintedness.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; への引数は、汚染が&lt;b&gt;ないか&lt;/b&gt;チェックされ&lt;b&gt;ません&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="5b24aafc030974a768212046c7dad5ef0c74d247" translate="yes" xml:space="preserve">
          <source>Arguments to Tests</source>
          <target state="translated">テストへの引数</target>
        </trans-unit>
        <trans-unit id="253657f116857073367b6474bc4203deb4236cb2" translate="yes" xml:space="preserve">
          <source>Arguments to be added to the command line</source>
          <target state="translated">コマンドラインに追加する引数</target>
        </trans-unit>
        <trans-unit id="ef74aa3554ce37f3e92c7ca867fc499504f0b195" translate="yes" xml:space="preserve">
          <source>Arguments to these commands are either strings exactly matching the identification string of an object, or regular expressions matched case-insensitively against various attributes of the objects. The parser only recognizes a regular expression when you enclose it with slashes.</source>
          <target state="translated">これらのコマンドの引数は、オブジェクトの識別文字列に完全に一致する文字列か、オブジェクトの様々な属性に対して大文字小文字を区別せずにマッチする正規表現です。パーサは正規表現をスラッシュで囲んだ場合のみ認識します。</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="2007b9d426cd74d2705e9cb985a4b287291d5413" translate="yes" xml:space="preserve">
          <source>Arguments: COUNT is the number of times to run the loop, and CODE is the code to run. CODE may be either a code reference or a string to be eval'd; either way it will be run in the caller's package.</source>
          <target state="translated">引数です。COUNTはループを実行する回数、CODEは実行するコードです。CODEはコード参照かevalされる文字列のどちらかです。</target>
        </trans-unit>
        <trans-unit id="504073c25d9741031e514c8e9e91bef33965e548" translate="yes" xml:space="preserve">
          <source>Arguments: TIME is the minimum length of time to run CODE for, and CODE is the code to run. CODE may be either a code reference or a string to be eval'd; either way it will be run in the caller's package.</source>
          <target state="translated">引数。TIMEはCODEを実行する最小時間の長さであり、CODEは実行するコードです。CODEはコード参照かevalされる文字列のいずれかである可能性があります。</target>
        </trans-unit>
        <trans-unit id="2dd1feda95af0eae16b44852b3e991a7320b9877" translate="yes" xml:space="preserve">
          <source>Arnold, Ken and James Gosling. The Java Programming Language, 2nd ed. Addison-Wesley, 1998, ISBN 0-201-31006-6.</source>
          <target state="translated">アーノルド、ケン、ジェームス・ゴズリング。Javaプログラミング言語、第2版、アディソンウェズリー、1998年、ISBN 0-201-31006 アディソンウェズリー、1998年、ISBN 0-201-31006-6。</target>
        </trans-unit>
        <trans-unit id="41b85d47773b3148f4f3a1e9d404f9d2d3175fa5" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">ランタイムライブラリがバイナリファイルとテキストファイルを区別するシステムで、FILEHANDLEが「バイナリ」または「テキスト」モードで読み書きされるようにします。FILEHANDLEが式である場合、値はファイルハンドルの名前として使用されます。成功した場合はtrueを返し、それ以外の場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返し、 &lt;code&gt;$!&lt;/code&gt; を設定します。（errno）。</target>
        </trans-unit>
        <trans-unit id="1ffbadba9c3dce1044ad3f375a7830b9eb0ed44f" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">ランタイムライブラリがバイナリファイルとテキストファイルを区別するシステムで、FILEHANDLEが「バイナリ」または「テキスト」モードで読み書きされるようにします。FILEHANDLEが式である場合、値はファイルハンドルの名前として使用されます。成功した場合はtrueを返し、それ以外の場合は &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返し、 &lt;code&gt;$!&lt;/code&gt; を設定します。（errno）。</target>
        </trans-unit>
        <trans-unit id="343c9f92b2508f5809b499c36c6237ee53dad8e9" translate="yes" xml:space="preserve">
          <source>Arranges for a mutual exclusion lock to be obtained on sv if a suitable module has been loaded.</source>
          <target state="translated">適切なモジュールがロードされている場合、sv上で相互排除ロックが得られるように手配します。</target>
        </trans-unit>
        <trans-unit id="a5173bbe458c53871d9b1f27fa09a96bfb62b86e" translate="yes" xml:space="preserve">
          <source>Arranges for sv to be shared between threads if a suitable module has been loaded.</source>
          <target state="translated">適切なモジュールがロードされている場合に、スレッド間で sv が共有されるようにアレンジします。</target>
        </trans-unit>
        <trans-unit id="5e55b4fcd8dbc2fd2ba6c045d961bacb9e292142" translate="yes" xml:space="preserve">
          <source>Arranges to have a SIGALRM delivered to this process after the specified number of wallclock seconds has elapsed. If SECONDS is not specified, the value stored in &lt;code&gt;$_&lt;/code&gt; is used. (On some machines, unfortunately, the elapsed time may be up to one second less or more than you specified because of how seconds are counted, and process scheduling may delay the delivery of the signal even further.)</source>
          <target state="translated">指定されたウォールクロック秒数が経過した後に、SIGALRMがこのプロセスに配信されるようにします。SECONDSが指定されていない場合、 &lt;code&gt;$_&lt;/code&gt; 格納されている値が使用されます。（一部のマシンでは、残念ながら、秒数のカウント方法が原因で、指定した時間よりも経過時間が最大で1秒短くなる場合があります。また、プロセススケジューリングにより、信号の配信がさらに遅れる場合があります。）</target>
        </trans-unit>
        <trans-unit id="fc39e6a09e8f437b433c2957e8745936c343df43" translate="yes" xml:space="preserve">
          <source>Array Interpolation</source>
          <target state="translated">配列補間</target>
        </trans-unit>
        <trans-unit id="946f892404632d1e1ef312d460522dbcef0e5ca6" translate="yes" xml:space="preserve">
          <source>Array Manipulation Functions</source>
          <target state="translated">配列操作関数</target>
        </trans-unit>
        <trans-unit id="e55ce1c88c52594e868f7dcd4b7c1bf4e8ab55e6" translate="yes" xml:space="preserve">
          <source>Array of extension names to be included when doing a static build. MakeMaker will normally build with all of the installed extensions when doing a static build, and that is usually the desired behavior. If INCLUDE_EXT is present then MakeMaker will build only with those extensions which are explicitly mentioned. (e.g. [ qw( Socket POSIX ) ])</source>
          <target state="translated">静的ビルド時に含める拡張機能名の配列。MakeMaker は通常、スタティックビルド時にインストールされているすべての拡張機能を使用してビルドを行います。INCLUDE_EXT が指定されている場合、MakeMaker は明示的に指定された拡張機能のみを使ってビルドします。(例:[qw(Socket POSIX)])</target>
        </trans-unit>
        <trans-unit id="1a8fc45517962d9406be17b19c25fe3aa87b4fd8" translate="yes" xml:space="preserve">
          <source>Array of extension names to exclude when doing a static build. This is ignored if INCLUDE_EXT is present. Consult INCLUDE_EXT for more details. (e.g. [ qw( Socket POSIX ) ] )</source>
          <target state="translated">静的ビルド時に除外する拡張モジュール名の配列。これは INCLUDE_EXT が存在する場合は無視されます。詳細は INCLUDE_EXT を参照してください。(例:[qw(Socket POSIX)])</target>
        </trans-unit>
        <trans-unit id="ab0eedcb736c58c9e1bf3d9da5ea7d522b690f73" translate="yes" xml:space="preserve">
          <source>Array of strings containing name (and email address) of package author(s). Is used in CPAN Meta files (META.yml or META.json) and PPD (Perl Package Description) files for PPM (Perl Package Manager).</source>
          <target state="translated">パッケージ作成者の名前(およびメールアドレス)を含む文字列の配列。CPAN メタファイル (META.yml または META.json)および PPM (Perl Package Manager)の PPD (Perl Package Description)ファイルで使用されます。</target>
        </trans-unit>
        <trans-unit id="c57f3a7023d5d1d3793f2eb3d27a157609936e28" translate="yes" xml:space="preserve">
          <source>Array of symbol names for variables to be made available as universal symbols. Used only under AIX, OS/2, VMS and Win32 at present. Defaults to []. (e.g. [ qw(Foo_version Foo_numstreams Foo_tree ) ])</source>
          <target state="translated">ユニバーサルシンボルとして利用できるようにするための変数のシンボル名の配列。現在のところ、AIX、OS/2、VMS、Win32でのみ使用されています。デフォルトは[]です。(例:[qw(Foo_version Foo_numstreams Foo_tree)])</target>
        </trans-unit>
        <trans-unit id="9ab44c94b1ea31feff632108e9870b5e1654c616" translate="yes" xml:space="preserve">
          <source>Array operations, which change the scalars, rearrange them, or add or subtract some scalars, only work on arrays. These can't work on a list, which is fixed. Array operations include &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">スカラーの変更、再配置、または一部のスカラーの加算または減算を行う配列演算は、配列でのみ機能します。これらは修正されたリストでは機能しません。配列操作には、 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="70c97244599437a3af8dc620ee670c18edb6906b" translate="yes" xml:space="preserve">
          <source>Array size can be obtained by doing:</source>
          <target state="translated">配列の大きさは、こうすることで求めることができます。</target>
        </trans-unit>
        <trans-unit id="4958f544bd9596999a8c5e79c668a1a1962b374e" translate="yes" xml:space="preserve">
          <source>Array, indexed by opcode, of functions that will be called for the &quot;check&quot; phase of optree building during compilation of Perl code. For most (but not all) types of op, once the op has been initially built and populated with child ops it will be filtered through the check function referenced by the appropriate element of this array. The new op is passed in as the sole argument to the check function, and the check function returns the completed op. The check function may (as the name suggests) check the op for validity and signal errors. It may also initialise or modify parts of the ops, or perform more radical surgery such as adding or removing child ops, or even throw the op away and return a different op in its place.</source>
          <target state="translated">Perl コードのコンパイル時に optree 構築の「チェック」フェーズで呼び出される関数の配列。ほとんどの(すべてではありませんが)opのタイプでは、一旦opが最初に構築され、子opで満たされると、この配列の適切な要素で参照されるチェック関数によってフィルタリングされます。新しい op はチェック関数の唯一の引数として渡され、チェック関数は完成した op を返します。check関数は(その名の通り)opの有効性やシグナルエラーをチェックします。また、オペの一部を初期化したり変更したり、子オペの追加や削除といったより根本的な手術を行ったり、オペを捨てて別のオペを返したりすることもできます。</target>
        </trans-unit>
        <trans-unit id="7622ad2f459420f8cf1278b446072cfedac9e366" translate="yes" xml:space="preserve">
          <source>Arrayref. E.g. [qw(archname manext)] defines ARCHNAME &amp;amp; MANEXT from config.sh. MakeMaker will add to CONFIG the following values anyway: ar cc cccdlflags ccdlflags dlext dlsrc ld lddlflags ldflags libc lib_ext obj_ext ranlib sitelibexp sitearchexp so</source>
          <target state="translated">Arrayref。たとえば、[qw（archname manext）]は、config.shからARCHNAMEとMANEXTを定義します。MakeMakerはとにかく次の値をCONFIGに追加します。ar cc cccdlflags ccdlflags dlext dlsrc ld lddlflags ldflags libc lib_ext obj_ext ranlib sitelibexp sitearchexp so</target>
        </trans-unit>
        <trans-unit id="ac3c8cf1aba574321bc1f66afd6baee7d74ccdb5" translate="yes" xml:space="preserve">
          <source>Arrayref. E.g. [qw(name1 name2)] skip (do not write) sections of the Makefile. Caution! Do not use the SKIP attribute for the negligible speedup. It may seriously damage the resulting Makefile. Only use it if you really need it.</source>
          <target state="translated">配列参照。例:[qw(name1 name2)]Makefileのセクションをスキップする(書き込まない)。注意! SKIP属性を無視できるほどの高速化のために使用しないでください。結果のMakefileに深刻なダメージを与える可能性があります。本当に必要な場合のみ使用してください。</target>
        </trans-unit>
        <trans-unit id="065b62648ae15e66467cb649a0f78784ebc20d69" translate="yes" xml:space="preserve">
          <source>Arrays and slices are interpolated into double-quoted strings by joining the elements with the delimiter specified in the &lt;code&gt;$&quot;&lt;/code&gt; variable (&lt;code&gt;$LIST_SEPARATOR&lt;/code&gt; if &quot;use English;&quot; is specified), space by default. The following are equivalent:</source>
          <target state="translated">配列とスライスは、 &lt;code&gt;$&quot;&lt;/code&gt; 変数で指定された区切り記号（&quot; use English; &quot;が指定されている場合は &lt;code&gt;$LIST_SEPARATOR&lt;/code&gt; ）、デフォルトではスペースで要素を結合することにより、二重引用符で囲まれた文字列に補間されます。以下は同等です。</target>
        </trans-unit>
        <trans-unit id="015aea03d19c4f5404b14d2e291f0bb807a559b3" translate="yes" xml:space="preserve">
          <source>Arrays are zero-indexed. Here's how you get at elements in an array:</source>
          <target state="translated">配列のインデックスはゼロです。ここでは、配列の要素を取得する方法を説明します。</target>
        </trans-unit>
        <trans-unit id="62a56f74931523c8c6be523e0f4189cd13f83348" translate="yes" xml:space="preserve">
          <source>Arrays index from 0. Likewise string positions in substr() and index().</source>
          <target state="translated">配列のインデックスは 0 からです。 同様に substr()と index()の文字列の位置も同様です。</target>
        </trans-unit>
        <trans-unit id="c6d4028b66a4b9402be627f34603725a671721e9" translate="yes" xml:space="preserve">
          <source>Arrays:</source>
          <target state="translated">Arrays:</target>
        </trans-unit>
        <trans-unit id="d88829ea9618170c7e2c7635ccc9b881ef3d9e85" translate="yes" xml:space="preserve">
          <source>Arrow Rule</source>
          <target state="translated">アロールール</target>
        </trans-unit>
        <trans-unit id="59f3e01c7f1fff089e4fc72d78498e369ebc8aba" translate="yes" xml:space="preserve">
          <source>Article about software localization</source>
          <target state="translated">ソフトウェアのローカライズに関する記事</target>
        </trans-unit>
        <trans-unit id="7c422841b7e3951946583038790545c4ed38481b" translate="yes" xml:space="preserve">
          <source>Articles</source>
          <target state="translated">Articles</target>
        </trans-unit>
        <trans-unit id="c2be5dffac8f664ad6e121cb0e6596d1cc2f8c20" translate="yes" xml:space="preserve">
          <source>Articles that are either about &lt;b&gt;DB_File&lt;/b&gt; or make use of it.</source>
          <target state="translated">&lt;b&gt;DB_File&lt;/b&gt;に関する記事またはそれを利用する記事。</target>
        </trans-unit>
        <trans-unit id="5ec201db4d2d3c7be7bb34f8e626f24de679e0d7" translate="yes" xml:space="preserve">
          <source>Artur Bergman &amp;lt;sky AT crucially DOT net&amp;gt;</source>
          <target state="translated">Artur Bergman &amp;lt;Sky AT決定的にDOTネット&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8abf83e588a6f8dbd23df54124d573a8d6e50b02" translate="yes" xml:space="preserve">
          <source>Artur Bergman, &quot;Where Wizards Fear To Tread&quot;, June 11, 2002, &lt;a href=&quot;http://www.perl.com/pub/a/2002/06/11/threads.html&quot;&gt;http://www.perl.com/pub/a/2002/06/11/threads.html&lt;/a&gt;</source>
          <target state="translated">Artur Bergman、「Where Wizards Fear To Tread」、2002年6月11日、&lt;a href=&quot;http://www.perl.com/pub/a/2002/06/11/threads.html&quot;&gt;http：//www.perl.com/pub/a/2002/06/11/threads.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d31985fda87b26d6554bcfbfe7dbc398b51917e" translate="yes" xml:space="preserve">
          <source>As</source>
          <target state="translated">As</target>
        </trans-unit>
        <trans-unit id="47c29ec0c3f7f05bae80de5283a0b030f441a291" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt; or &lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt; but with the access/modify/change file timestamps in subsecond resolution, if the operating system and the filesystem both support such timestamps. To override the standard stat():</source>
          <target state="translated">など&lt;a href=&quot;../functions/stat&quot;&gt;のstat&lt;/a&gt;または&lt;a href=&quot;../functions/lstat&quot;&gt;lstatは&lt;/a&gt;なく、アクセス/修正/変更ファイルとオペレーティングシステムとファイルシステムは、このようなタイムスタンプをサポートし、両方の場合は、秒未満の解像度のタイムスタンプ。標準のstat（）をオーバーライドするには：</target>
        </trans-unit>
        <trans-unit id="02b2b57eecbbd649395f996ef53060747f75fc9c" translate="yes" xml:space="preserve">
          <source>As &lt;b&gt;-nok&lt;/b&gt; except it will report on older systems.</source>
          <target state="translated">&lt;b&gt;-nok&lt;/b&gt;それは古いシステムについて報告する点が異なります。</target>
        </trans-unit>
        <trans-unit id="4859922e8f70272693e823f3867ed24a92199eaa" translate="yes" xml:space="preserve">
          <source>As &lt;b&gt;-ok&lt;/b&gt; except it will report on older systems.</source>
          <target state="translated">古いシステムについて報告することを除いて&lt;b&gt;-okと&lt;/b&gt;同じです。</target>
        </trans-unit>
        <trans-unit id="11468a3ea9b3583c1d2e6860cce82a44a9b04f63" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;$form_name&lt;/code&gt; , one of the following names must be given.</source>
          <target state="translated">&lt;code&gt;$form_name&lt;/code&gt; として、次のいずれかの名前を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="2779b0caf565b7a913bad43d8e6bc994f2a3b086" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;-Dm&lt;/code&gt; is using the PerlIO layer for output, it will by itself allocate quite a bunch of SVs, which are hidden to avoid recursion. You can bypass the PerlIO layer if you use the SV logging provided by &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; instead.</source>
          <target state="translated">以下のよう &lt;code&gt;-Dm&lt;/code&gt; 出力用のPerlIO層を使用している、それはそれ自体で回避再帰に隠されているのSV、かなり束を割り当てます。代わりに &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; によって提供されるSVログを使用する場合は、PerlIOレイヤーをバイパスできます。</target>
        </trans-unit>
        <trans-unit id="67afac02f586f9bebcefbfe5f3e2ccc5758a2739" translate="yes" xml:space="preserve">
          <source>As Perl is developed by a global team of volunteers, our documentation often contains spellings which look funny to</source>
          <target state="translated">Perl は世界的なボランティアチームによって開発されているため、私たちのドキュメントには、しばしば</target>
        </trans-unit>
        <trans-unit id="56f06af6196a2958b2b24cc234e03f482b95a8e2" translate="yes" xml:space="preserve">
          <source>As Storable neither knows nor cares about character sets (although it does know that characters may be more than eight bits wide), any difference in the interpretation of character codes between a host and a target system is your problem. In particular, if host and target use different code points to represent the characters used in the text representation of floating-point numbers, you will not be able be able to exchange floating-point data, even with nstore().</source>
          <target state="translated">Storable は文字セットを知らないし、気にもしないので (文字が 8 ビット以上の幅であることは知っていますが)、ホストシステムとターゲットシステムの間で文字コードの解釈に違いがあれば、それはあなたの問題です。特に、ホストとターゲットが浮動小数点数のテキスト表現で使用される文字を表現するために異なるコードポイントを使用している場合、nstore()を使用しても浮動小数点データを交換することはできません。</target>
        </trans-unit>
        <trans-unit id="4eb26264176ff313034cbea4b1e32ac9ca4ff4be" translate="yes" xml:space="preserve">
          <source>As a beginning Perl programmer, your most common use of OO Perl will be in using third-party modules, which are documented below.</source>
          <target state="translated">Perlプログラマーを始めたばかりの方は、サードパーティ製のモジュールを使用していることが多いでしょう。</target>
        </trans-unit>
        <trans-unit id="c668c33e20c8d7992e509e03d3adf2ab76f6474b" translate="yes" xml:space="preserve">
          <source>As a consequence of the fact that &lt;code&gt;:raw&lt;/code&gt; normally pops layers, it usually only makes sense to have it as the only or first element in a layer specification. When used as the first element it provides a known base on which to build e.g.</source>
          <target state="translated">&lt;code&gt;:raw&lt;/code&gt; が通常はレイヤーをポップするという事実の結果として、通常、レイヤー仕様の唯一の要素または最初の要素としてそれを使用することは意味があります。最初の要素として使用される場合、それは例えば上に構築するための既知のベースを提供します</target>
        </trans-unit>
        <trans-unit id="85a48b10d40e66cd4a8aedc3b80bf9f3898c7f18" translate="yes" xml:space="preserve">
          <source>As a consequence, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ignores any number or &lt;code&gt;*&lt;/code&gt; after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">結果として、 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;P&lt;/code&gt; の後の数字または &lt;code&gt;*&lt;/code&gt; を無視します。</target>
        </trans-unit>
        <trans-unit id="af58dfe35e68f1702e8805a513e543501b556b2f" translate="yes" xml:space="preserve">
          <source>As a consequence, the behavior of the operator % agrees with the behavior of Perl's built-in % operator (as documented in the perlop manpage), and the equation</source>
          <target state="translated">結果として、演算子 % の動作は、Perl の組み込み % 演算子の動作と一致します (perlop の man ページに記載されています)。</target>
        </trans-unit>
        <trans-unit id="8ed20c41e94e838dcaa1f2e890809ac53aaadc11" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;io/socket&quot;&gt;IO::Socket&lt;/a&gt;'s setsockopt() method will convert a number into a packed byte buffer, and getsockopt() will unpack a byte buffer of the correct size back into a number.</source>
          <target state="translated">便宜上、&lt;a href=&quot;io/socket&quot;&gt;IO :: Socket&lt;/a&gt;のsetsockopt（）メソッドは数値をパックされたバイトバッファーに変換し、getsockopt（）は正しいサイズのバイトバッファーをアンパックして数値に戻します。</target>
        </trans-unit>
        <trans-unit id="39dd3ca26236e47c7f0b84b7220b02b39c4ce6f1" translate="yes" xml:space="preserve">
          <source>As a convenience, if only one argument is passed then this argument is assumed to be the name of the test (as in the above examples.)</source>
          <target state="translated">便宜上、1つの引数だけが渡された場合、この引数はテストの名前とみなされます(上記の例のように)。</target>
        </trans-unit>
        <trans-unit id="1cb03824a7a51fc71299760a7d72ef70c9f7d1d1" translate="yes" xml:space="preserve">
          <source>As a debugging aid, you can force Carp to treat a croak as a confess and a carp as a cluck across</source>
          <target state="translated">デバッグの補助として、Carpを強制的にクロークを告白として扱い、Carpをクラックとして扱うことができます。</target>
        </trans-unit>
        <trans-unit id="5de9c4f1738c3fbc65c8014410d9308c0bceec73" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Parser, Pod::PlainText supports the same methods and interfaces. See &lt;a href=&quot;parser&quot;&gt;Pod::Parser&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::PlainText-&amp;gt;new()&lt;/code&gt; and then calls either parse_from_filehandle() or parse_from_file().</source>
          <target state="translated">Pod :: Parserからの派生クラスとして、Pod :: PlainTextは同じメソッドとインターフェースをサポートします。詳細については、&lt;a href=&quot;parser&quot;&gt;Pod :: Parser&lt;/a&gt;を参照してください。簡単に言うと、 &lt;code&gt;Pod::PlainText-&amp;gt;new()&lt;/code&gt; 新しいパーサーを作成してから、parse_from_filehandle（）またはparse_from_file（）を呼び出します。</target>
        </trans-unit>
        <trans-unit id="f6ec952fc34afc28085390c8d52daf19e0a80643" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Man supports the same methods and interfaces. See &lt;a href=&quot;simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details.</source>
          <target state="translated">Pod :: Simpleからの派生クラスとして、Pod :: Manは同じメソッドとインターフェースをサポートします。詳細については、&lt;a href=&quot;simple&quot;&gt;Pod :: Simple&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3e4fc5bdbe388e6ddf3cda0d8bc20220f607ea7d" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Text supports the same methods and interfaces. See &lt;a href=&quot;simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; and then normally calls parse_file().</source>
          <target state="translated">Pod :: Simpleからの派生クラスとして、Pod :: Textは同じメソッドとインターフェースをサポートします。詳細については、&lt;a href=&quot;simple&quot;&gt;Pod :: Simple&lt;/a&gt;を参照してください。簡単に言うと、 &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; 新しいパーサーを作成し、通常はparse_file（）を呼び出します。</target>
        </trans-unit>
        <trans-unit id="b23f74daa8f57475a4ba46fd4485f5b745823a7e" translate="yes" xml:space="preserve">
          <source>As a final remark, note that one can fill %subr by</source>
          <target state="translated">最後の注意点として、%subr は</target>
        </trans-unit>
        <trans-unit id="4cc64b626e2a5166499114ddf2d5328e019929e3" translate="yes" xml:space="preserve">
          <source>As a final thought, remember that it's not (at the time of writing) possible to produce a useful program which will run in zero or negative time and this basic principle can be written as:</source>
          <target state="translated">最後に考えておきたいのは、(執筆時点では)ゼロ時やマイナス時に動くような便利なプログラムを作ることはできないということと、この基本原理は次のように書くことができるということを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="c76d7d0ab08773eceae9495e1336acd5bdc1e071" translate="yes" xml:space="preserve">
          <source>As a further example, this means that if you wanted to put these bits of code in &lt;code&gt;C&lt;/code&gt; (code) style:</source>
          <target state="translated">さらなる例として、これは、これらのコードを &lt;code&gt;C&lt;/code&gt; （コード）スタイルで記述したい場合に次のことを意味します。</target>
        </trans-unit>
        <trans-unit id="a5d5c5dbed3ae73f59f4d512802a9cfe627521f0" translate="yes" xml:space="preserve">
          <source>As a further example: At time of writing, no &quot;biblio&quot; identifier is supported, but suppose some processor were written to recognize it as a way of (say) denoting a bibliographic reference (necessarily containing formatting codes in ordinary paragraphs). The fact that &quot;biblio&quot; paragraphs were meant for ordinary processing would be indicated by prefacing each &quot;biblio&quot; identifier with a colon:</source>
          <target state="translated">さらなる例として。執筆時点では、&quot;biblio &quot;識別子はサポートされていませんが、(通常の段落の書式コードを必然的に含む)書誌参照を示す(例えば)方法として、それを認識するためのプロセッサが書かれていたとしましょう。&quot;biblio &quot;段落が通常の処理のためのものであるという事実は、各 &quot;biblio &quot;識別子の前にコロンを付けることで示されるだろう。</target>
        </trans-unit>
        <trans-unit id="32e712936b7f11c5ab2eb3ed80fcfadcc776b710" translate="yes" xml:space="preserve">
          <source>As a further optimisation, on exit from the eval block in the &lt;code&gt;FETCH&lt;/code&gt; , execution of the code following the block is still carried on in the inner loop. When an exception is raised, &lt;code&gt;docatch&lt;/code&gt; compares the &lt;code&gt;JMPENV&lt;/code&gt; level of the &lt;code&gt;CxEVAL&lt;/code&gt; with &lt;code&gt;PL_top_env&lt;/code&gt; and if they differ, just re-throws the exception. In this way any inner loops get popped.</source>
          <target state="translated">さらなる最適化として、 &lt;code&gt;FETCH&lt;/code&gt; の evalブロックからの出口で、ブロックに続くコードの実行が内部ループで引き続き実行されます。例外が発生すると、 &lt;code&gt;docatch&lt;/code&gt; は比較 &lt;code&gt;JMPENV&lt;/code&gt; のレベル &lt;code&gt;CxEVAL&lt;/code&gt; をして &lt;code&gt;PL_top_env&lt;/code&gt; し、それらが異なる場合は、単に例外を再スローします。このようにして、内部ループがポップされます。</target>
        </trans-unit>
        <trans-unit id="23702715810537d7f01f041b430e67e396dff672" translate="yes" xml:space="preserve">
          <source>As a general rule of thumb, your commit message should help a programmer who knows the Perl core quickly understand what you were trying to do, how you were trying to do it, and why the change matters to Perl.</source>
          <target state="translated">一般的な経験則として、あなたのコミットメッセージは、Perl のコアを知っているプログラマが、あなたが何をしようとしていたのか、どのようにそれをしようとしていたのか、そしてなぜその変更が Perl にとって重要なのかを素早く理解するのに役立つものでなければなりません。</target>
        </trans-unit>
        <trans-unit id="4e47a1601663426f056fd202a23442a94b37a934" translate="yes" xml:space="preserve">
          <source>As a general rule you should</source>
          <target state="translated">原則として</target>
        </trans-unit>
        <trans-unit id="f1a7ae8ef2fbb4b6cb7127db887caa429f079e93" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then &lt;code&gt;@EXPORT_OK&lt;/code&gt; anything but use &lt;code&gt;@EXPORT&lt;/code&gt; with caution. For function and method names use barewords in preference to names prefixed with ampersands for the export lists.</source>
          <target state="translated">一般的なルールとして、モジュールがオブジェクト指向である場合、何もエクスポートしません。関数のコレクションだけの場合は、 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 以外は何でも &lt;code&gt;@EXPORT&lt;/code&gt; を使用してください。関数名とメソッド名には、エクスポートリストのアンパサンドを前に付けた名前よりも、ベアワードを使用します。</target>
        </trans-unit>
        <trans-unit id="e17549d186f2cd9b2973080585cd98536cba2f89" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then @EXPORT_OK anything but use @EXPORT with caution.</source>
          <target state="translated">一般的なルールとして、モジュールがオブジェクト指向であろうとしている場合は、何もエクスポートしません。ただの関数の集合体であれば @EXPORT_OK 何でも良いのですが、@EXPORT は注意して使用してください。</target>
        </trans-unit>
        <trans-unit id="433c99eba76250876af9c971ad06d88a2549474f" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object-oriented then don't export anything. If it's just a collection of functions and variables, then you can export them via another array, called &lt;code&gt;@EXPORT_OK&lt;/code&gt; . This array does not automatically place its subroutine and variable names into the namespace unless the user specifically requests that this be done.</source>
          <target state="translated">原則として、モジュールがオブジェクト指向である場合は、何もエクスポートしないでください。関数と変数のコレクションの場合は、 &lt;code&gt;@EXPORT_OK&lt;/code&gt; と呼ばれる別の配列を介してそれらをエクスポートできます。この配列は、ユーザーが特別にこれを実行するように要求しない限り、サブルーチンと変数の名前を名前空間に自動的に配置しません。</target>
        </trans-unit>
        <trans-unit id="a207991a7d026174ee51a8481f0b776cbc48b6ea" translate="yes" xml:space="preserve">
          <source>As a last resort, however:</source>
          <target state="translated">しかし、最後の手段として</target>
        </trans-unit>
        <trans-unit id="3ab2161dda92a73d5893b103484d832131038b70" translate="yes" xml:space="preserve">
          <source>As a last resort, you can use the perl one-liner:</source>
          <target state="translated">最後の手段として、perlのワンライナーを使うことができます。</target>
        </trans-unit>
        <trans-unit id="9a117b27b5618d5856aaaf26d908e957a310a377" translate="yes" xml:space="preserve">
          <source>As a last resort, you could also use &lt;code&gt;PERL5DB&lt;/code&gt; to customize the debugger by directly setting internal variables or calling debugger functions.</source>
          <target state="translated">最後の手段として、 &lt;code&gt;PERL5DB&lt;/code&gt; を使用して、内部変数を直接設定するか、デバッガー関数を呼び出して、デバッガーをカスタマイズすることもできます。</target>
        </trans-unit>
        <trans-unit id="46efdbcc9fcabaefc1ffd7ba61888d42081d0818" translate="yes" xml:space="preserve">
          <source>As a noun, a piece of syntax made up of smaller pieces. As a transitive verb, to create an &lt;b&gt;object&lt;/b&gt; using a &lt;b&gt;constructor&lt;/b&gt;.</source>
          <target state="translated">名詞として、より小さな部分から構成される構文の一部。推移動詞として、&lt;b&gt;コンストラクター&lt;/b&gt;を使用して&lt;b&gt;オブジェクト&lt;/b&gt;を作成し&lt;b&gt;ます&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3f0cb7718076aa901719a5347944ab158c02cce2" translate="yes" xml:space="preserve">
          <source>As a result of these problems, starting in v5.20, what Perl does is to treat non-Unicode code points as just typical unassigned Unicode characters, and matches accordingly. (Note: Unicode has atypical unassigned code points. For example, it has noncharacter code points, and ones that, when they do get assigned, are destined to be written Right-to-left, as Arabic and Hebrew are. Perl assumes that no non-Unicode code point has any atypical properties.)</source>
          <target state="translated">これらの問題の結果、v5.20からPerlは、非Unicodeコードポイントを典型的な未割り当てUnicode文字として扱い、それに応じてマッチするようになりました。(注意:Unicode には非定型の未割り当てコードポイントがあります。例えば、非文字コードポイントと、それらが割り当てられた場合、アラビア語やヘブライ語がそうであるように、右から左に書かれるように運命づけられているコードポイントを持っています。Perlは、非Unicodeコードポイントが非定型の特性を持っていないことを前提としています。)</target>
        </trans-unit>
        <trans-unit id="dd723ff09f0dfd75022fcfe75451c37784da18b7" translate="yes" xml:space="preserve">
          <source>As a result, &lt;code&gt;$?&lt;/code&gt; will always be zero if the subprocess's exit status indicated successful completion, and non-zero if a warning or error occurred or a program compliant with encoding _POSIX_EXIT values was run and set a status.</source>
          <target state="translated">その結果、 &lt;code&gt;$?&lt;/code&gt; サブプロセスの終了ステータスが正常終了を示した場合は常に0になり、警告またはエラーが発生した場合、またはエンコード_POSIX_EXIT値に準拠したプログラムが実行されてステータスが設定された場合は、0以外になります。</target>
        </trans-unit>
        <trans-unit id="c26b5ebaa65b4ac15b7d233c58e1a9bb61162748" translate="yes" xml:space="preserve">
          <source>As a scalar operator:</source>
          <target state="translated">スカラー演算子として</target>
        </trans-unit>
        <trans-unit id="8274ec69a734737beb00f3f5313b731efea1dc76" translate="yes" xml:space="preserve">
          <source>As a shortcut &lt;code&gt;(*MARK:NAME)&lt;/code&gt; can be written &lt;code&gt;(*:NAME)&lt;/code&gt;.</source>
          <target state="translated">ショートカットとして &lt;code&gt;(*MARK:NAME)&lt;/code&gt; と書くことができます &lt;code&gt;(*:NAME)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b9a135b5dd5e3840c9d7b2126bd8f1513618105" translate="yes" xml:space="preserve">
          <source>As a shortcut a one-argument call takes the filename from the global scalar variable of the same name as the filehandle:</source>
          <target state="translated">ショートカットとして、1引数の呼び出しは、ファイルハンドルと同じ名前のグローバルスカラ変数からファイル名を取得します。</target>
        </trans-unit>
        <trans-unit id="9baecd622ad6ae8ccb368a1f47c6a9f4ae3fac55" translate="yes" xml:space="preserve">
          <source>As a shortcut, you can use the module &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;:</source>
          <target state="translated">ショートカットとして、モジュール&lt;a href=&quot;../bignum&quot;&gt;bignumを&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="5b3e1134bf3b8109ecb5762080e2eff8e1996cc6" translate="yes" xml:space="preserve">
          <source>As a side effect, as &lt;code&gt;_&lt;/code&gt; doesn't work, stacked filetest operators (&lt;code&gt;-f -w $file&lt;/code&gt; ) won't work either.</source>
          <target state="translated">副作用として、 &lt;code&gt;_&lt;/code&gt; は機能しないため、スタックされた &lt;code&gt;-f -w $file&lt;/code&gt; テスト演算子（-f -w $ file）も機能しません。</target>
        </trans-unit>
        <trans-unit id="e67c2575fdaa4cadca39640f540c5c1c25ff2b7b" translate="yes" xml:space="preserve">
          <source>As a side effect, calling keys() resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;). In particular, calling keys() in void context resets the iterator with no other overhead.</source>
          <target state="translated">副作用として、keys（）を呼び出すと、HASHまたはARRAYの内部反復子がリセットされます（&lt;a href=&quot;#each&quot;&gt;それぞれを&lt;/a&gt;参照）。特に、voidコンテキストでkeys（）を呼び出すと、他のオーバーヘッドなしでイテレーターがリセットされます。</target>
        </trans-unit>
        <trans-unit id="c7b3fa9f58a42d510ccd961956edd3b53e1d0c57" translate="yes" xml:space="preserve">
          <source>As a side effect, calling keys() resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;). In particular, calling keys() in void context resets the iterator with no other overhead.</source>
          <target state="translated">副作用として、keys（）を呼び出すと、HASHまたはARRAYの内部反復子がリセットされます（&lt;a href=&quot;each&quot;&gt;それぞれを&lt;/a&gt;参照）。特に、voidコンテキストでkeys（）を呼び出すと、他のオーバーヘッドなしでイテレーターがリセットされます。</target>
        </trans-unit>
        <trans-unit id="aa184b78eeef36fa29a1577f9bf8458234354229" translate="yes" xml:space="preserve">
          <source>As a side effect, calling values() resets the HASH or ARRAY's internal iterator, see &lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;. (In particular, calling values() in void context resets the iterator with no other overhead. Apart from resetting the iterator, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt; . (We recommend that you use void context &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">副作用として、values（）を呼び出すと、HASHまたはARRAYの内部反復子がリセットされます。&lt;a href=&quot;#each&quot;&gt;それぞれを&lt;/a&gt;参照してください。 （特に、values（）をvoidコンテキストで呼び出すと、他のオーバーヘッドなしでイテレーターがリセットされます。イテレーターをリセットする &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; 、リストコンテキストの値 @arrayはプレーン &lt;code&gt;@array&lt;/code&gt; と同じです（voidコンテキスト &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; を使用することをお勧めしますこのために、しかし取っていることを推論した &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; でそれを残してより多くのドキュメントを必要とするアウト。）</target>
        </trans-unit>
        <trans-unit id="a91a0923e5abea890fdc2bd22bb84126ade104fe" translate="yes" xml:space="preserve">
          <source>As a side effect, calling values() resets the HASH or ARRAY's internal iterator, see &lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;. (In particular, calling values() in void context resets the iterator with no other overhead. Apart from resetting the iterator, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt; . (We recommend that you use void context &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">副作用として、values（）を呼び出すと、HASHまたはARRAYの内部反復子がリセットされます。&lt;a href=&quot;each&quot;&gt;それぞれを&lt;/a&gt;参照してください。 （特に、values（）をvoidコンテキストで呼び出すと、他のオーバーヘッドなしでイテレーターがリセットされます。イテレーターをリセットする &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; 、リストコンテキストの値 @arrayはプレーン &lt;code&gt;@array&lt;/code&gt; と同じです（voidコンテキスト &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; を使用することをお勧めしますこのために、しかし取っていることを推論した &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; でそれを残してより多くのドキュメントを必要とするアウト。）</target>
        </trans-unit>
        <trans-unit id="e8e57a1c04bdc517b9206bb149b8d52cd1b60750" translate="yes" xml:space="preserve">
          <source>As a special case</source>
          <target state="translated">特殊なケースとして</target>
        </trans-unit>
        <trans-unit id="17ea6c6f4727b11c2b48648599d60dd30f72b5e8" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, the empty pattern given in &lt;a href=&quot;perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt; ) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; の特殊なケースとして、&lt;a href=&quot;perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;一致演算子&lt;/a&gt;構文（ &lt;code&gt;//&lt;/code&gt; ）で指定された空のパターンは、空の文字列と明確に一致します。これは、最後に成功した一致としての通常の解釈とは逆です。</target>
        </trans-unit>
        <trans-unit id="59db895ceb1feffbf61c972fbfef8ae7b61e3fff" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, the empty pattern given in &lt;a href=&quot;../perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt; ) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; の特殊なケースとして、&lt;a href=&quot;../perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;一致演算子&lt;/a&gt;構文（ &lt;code&gt;//&lt;/code&gt; ）で指定された空のパターンは、空の文字列と明確に一致します。これは、最後に成功した一致としての通常の解釈とは逆です。</target>
        </trans-unit>
        <trans-unit id="527a25823c5b741d3ca1303c6cacef3dfa61f467" translate="yes" xml:space="preserve">
          <source>As a special case if the overload returns the object itself then it will be used directly. An overloaded conversion returning the object is probably a bug, because you're likely to get something that looks like &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; .</source>
          <target state="translated">特別なケースとして、オーバーロードがオブジェクト自体を返す場合、それは直接使用されます。 &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; のようなものを取得する可能性が高いため、オブジェクトを返すオーバーロードされた変換はおそらくバグです。</target>
        </trans-unit>
        <trans-unit id="898fa8e40ea8bbaf82f7657e12c724a39a6b933a" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">特別なケースとして、読み取り/書き込みモードと3番目の引数が &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; である3つの引数のフォーム：</target>
        </trans-unit>
        <trans-unit id="bfe8944e96951a5268014155bb5ff3707aad862a" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">特別なケースとして、読み取り/書き込みモードと3番目の引数が &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; である3つの引数のフォーム：</target>
        </trans-unit>
        <trans-unit id="39d0f95cc62f9b7d251ca80f498d915dd0b1187f" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;\(@foo)&lt;/code&gt; returns a list of references to the contents of &lt;code&gt;@foo&lt;/code&gt; , not a reference to &lt;code&gt;@foo&lt;/code&gt; itself. Likewise for &lt;code&gt;%foo&lt;/code&gt; , except that the key references are to copies (since the keys are just strings rather than full-fledged scalars).</source>
          <target state="translated">特別な場合として、 &lt;code&gt;\(@foo)&lt;/code&gt; の内容への参照のリストを返し &lt;code&gt;@foo&lt;/code&gt; 、しないように参照 &lt;code&gt;@foo&lt;/code&gt; 自身を。キー参照がコピーへの参照であることを除いて、 &lt;code&gt;%foo&lt;/code&gt; と同様です（キーは本格的なスカラーではなく単なる文字列であるため）。</target>
        </trans-unit>
        <trans-unit id="9d3b4ecbd7d509c41643f820908fd45c356bb919" translate="yes" xml:space="preserve">
          <source>As a special case, if the test in the &lt;code&gt;for&lt;/code&gt; loop (or the corresponding &lt;code&gt;while&lt;/code&gt; loop) is empty, it is treated as true. That is, both</source>
          <target state="translated">特殊なケースとして、 &lt;code&gt;for&lt;/code&gt; ループ（または対応する &lt;code&gt;while&lt;/code&gt; ループ）のテストが空の場合、trueとして扱われます。つまり、両方</target>
        </trans-unit>
        <trans-unit id="07d1fa15ef1af04fe7ac16e1712ceb861430b28a" translate="yes" xml:space="preserve">
          <source>As a special case, if the value of this variable is space-separated, the tail might be used to disable the ornaments by setting the tail to be &lt;code&gt;o=0&lt;/code&gt; or &lt;code&gt;ornaments=0&lt;/code&gt; . The head should be as described above, say</source>
          <target state="translated">特殊なケースとして、この変数の値がスペースで区切られている場合、尾を &lt;code&gt;o=0&lt;/code&gt; または &lt;code&gt;ornaments=0&lt;/code&gt; に設定することにより、尾を使用して装飾を無効にすることができます。頭は上で説明したとおりでなければなりません、と言う</target>
        </trans-unit>
        <trans-unit id="0fde23ad411d5b9ebf1966fbf214f46640cb22f9" translate="yes" xml:space="preserve">
          <source>As a special case, if you specify the module name &lt;code&gt;Unicode&lt;/code&gt; , you'll get the version number of the Unicode Character Database bundled with the requested perl versions.</source>
          <target state="translated">特殊なケースとして、モジュール名 &lt;code&gt;Unicode&lt;/code&gt; を指定すると、要求されたperlバージョンにバンドルされているUnicode Character Databaseのバージョン番号が取得されます。</target>
        </trans-unit>
        <trans-unit id="03f58faea796a1077f97500a4e213c983487f04c" translate="yes" xml:space="preserve">
          <source>As a special case, when the accessor is called with a hash reference as the sole argument, this causes an assignment of the whole hash element. The object reference is returned.</source>
          <target state="translated">特殊なケースとして、ハッシュ参照を唯一の引数としてアクセサが呼ばれた場合、これはハッシュ要素全体の代入を引き起こします。オブジェクト参照が返されます。</target>
        </trans-unit>
        <trans-unit id="d80964d39654d27c73a60223b4ebc15d6e6b2f91" translate="yes" xml:space="preserve">
          <source>As a special case, when the accessor is called with an array reference as the sole argument, this causes an assignment of the whole array element. The object reference is returned.</source>
          <target state="translated">特殊なケースとして、配列参照を唯一の引数としてアクセサが呼ばれた場合、配列要素全体が代入されます。オブジェクト参照が返されます。</target>
        </trans-unit>
        <trans-unit id="261536d85ff532107bd0e6c855c28c78277c6b3c" translate="yes" xml:space="preserve">
          <source>As a special exception, when you slice a list (but not an array or a hash), if the list evaluates to empty, then taking a slice of that empty list will always yield the empty list in turn. Thus:</source>
          <target state="translated">特別な例外として、(配列やハッシュではなく)リストをスライスした場合、リストが空と評価された場合、その空のリストをスライスすると、常に空のリストが順番に返されます。したがって、次のようになります。</target>
        </trans-unit>
        <trans-unit id="267a52b216bf364239047183b439e3e80275f9ef" translate="yes" xml:space="preserve">
          <source>As a vendor, you may have a requirement to backport security fixes beyond our 3 year support commitment. We can provide limited support and advice to you as you do so and, where possible will try to apply those patches to the relevant -maint branches in git, though we may or may not choose to make numbered releases or &quot;official&quot; patches available. Contact us at &amp;lt;perl5-security-report@perl.org&amp;gt; to begin that process.</source>
          <target state="translated">ベンダーとして、3年間のサポート契約を超えてセキュリティ修正をバックポートする必要がある場合があります。番号付きのリリースや「公式」パッチを利用できるようにすることもしないこともできますが、可能な限り、これらのパッチをgitの関連する-maintブランチに適用しようとします。そのプロセスを開始するには、&amp;lt;perl5-security-report@perl.org&amp;gt;までご連絡ください。</target>
        </trans-unit>
        <trans-unit id="6b767e1ab5bdc22f58c69583808a39ce8aa5393a" translate="yes" xml:space="preserve">
          <source>As a volunteer organization, the commitments we make are heavily dependent on the goodwill and hard work of individuals who have no obligation to contribute to Perl.</source>
          <target state="translated">ボランティア組織として、私たちが行うコミットメントは、Perlに貢献する義務のない個人の善意と努力に大きく依存しています。</target>
        </trans-unit>
        <trans-unit id="b55a4625fdc844badd446c13482f0c20c8caa1b5" translate="yes" xml:space="preserve">
          <source>As above, but the destination node text of the link.</source>
          <target state="translated">上記と同様ですが、リンク先のノードのテキスト。</target>
        </trans-unit>
        <trans-unit id="07731660b460e18f03465884e08d802967534966" translate="yes" xml:space="preserve">
          <source>As all values evaluate to true, a simple &lt;code&gt;if&lt;/code&gt; test is good enough to determine whether an extension is present.</source>
          <target state="translated">すべての値がtrueと評価されるため、拡張が存在するかどうかを判断するには、単純な &lt;code&gt;if&lt;/code&gt; テストで十分です。</target>
        </trans-unit>
        <trans-unit id="049e8d249c3ad3a2a8b180055568baa12252b047" translate="yes" xml:space="preserve">
          <source>As alluded to earlier you can also declare inlined subs dynamically at BEGIN time if their body consists of a lexically-scoped scalar which has no other references. Only the first example here will be inlined:</source>
          <target state="translated">先ほども述べたように、インライン化されたサブジェクトのボディが他に参照を持たないスカラーから構成されている場合、BEGIN 時に動的にインライン化されたサブジェクトを宣言することもできます。ここでは、最初の例だけがインライン化されます。</target>
        </trans-unit>
        <trans-unit id="40622c1595c0e7b33c82f810ddadd26599013393" translate="yes" xml:space="preserve">
          <source>As alternatives to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; when used for control flow, Perl provides the &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators (see below). The short-circuit behavior is identical. The precedence of &lt;code&gt;&quot;and&quot;&lt;/code&gt; and &lt;code&gt;&quot;or&quot;&lt;/code&gt; is much lower, however, so that you can safely use them after a list operator without the need for parentheses:</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; および &lt;code&gt;||&lt;/code&gt; の代替として 制御フローに使用する場合、Perlは &lt;code&gt;and&lt;/code&gt; および &lt;code&gt;or&lt;/code&gt; 演算子を提供します（以下を参照）。短絡動作は同じです。ただし、 &lt;code&gt;&quot;and&quot;&lt;/code&gt; と &lt;code&gt;&quot;or&quot;&lt;/code&gt; の優先順位ははるかに低いため、括弧を必要とせずにリスト演算子の後に安全に使用できます。</target>
        </trans-unit>
        <trans-unit id="c44b3a4add0c470afd83290fbaea5d47d3bf3bcb" translate="yes" xml:space="preserve">
          <source>As always with Perl there is more than one way to do it. Below are a few examples of approaches to making common conversions between number representations. This is intended to be representational rather than exhaustive.</source>
          <target state="translated">Perlではいつものように、それを行う方法は一つだけではありません。以下に、数値表現間で共通の変換を行うためのアプローチの例をいくつか挙げます。これは網羅的なものではなく、代表的なものであることを意図しています。</target>
        </trans-unit>
        <trans-unit id="a27e8bc51d6a9b14b4e2235fdc7ebedf28d134bc" translate="yes" xml:space="preserve">
          <source>As always, if any of these are ever officially declared as bugs, they'll be fixed and removed.</source>
          <target state="translated">いつものように公式にバグだと宣言されたものがあれば修正されて削除されます。</target>
        </trans-unit>
        <trans-unit id="43d8cae7f79fc634e42b4fbb6869d40983003e1e" translate="yes" xml:space="preserve">
          <source>As always, setting up a server is little bit more involved than running a client. The model is that the server creates a special kind of socket that does nothing but listen on a particular port for incoming connections. It does this by calling the &lt;code&gt;IO::Socket::INET-&amp;gt;new()&lt;/code&gt; method with slightly different arguments than the client did.</source>
          <target state="translated">いつものように、サーバーの設定はクライアントの実行よりも少し複雑です。モデルは、サーバーが特別な種類のソケットを作成し、特定のポートで着信接続をリッスンするだけであるというものです。これは、クライアントとは少し異なる引数を指定して &lt;code&gt;IO::Socket::INET-&amp;gt;new()&lt;/code&gt; メソッドを呼び出すことによって行われます。</target>
        </trans-unit>
        <trans-unit id="90ed318055b1f6119d9ba187aa6944aea5c29dbe" translate="yes" xml:space="preserve">
          <source>As an added convenience, the Digest::SHA module offers routines to calculate keyed hashes using the HMAC-SHA-1/224/256/384/512 algorithms. These services exist in functional form only, and mimic the style and behavior of the</source>
          <target state="translated">追加の利便性として、Digest::SHAモジュールはHMAC-SHA-1/224/256/384/512アルゴリズムを使用して鍵付きハッシュを計算するルーチンを提供します。これらのサービスは、機能的な形でのみ存在しており</target>
        </trans-unit>
        <trans-unit id="d0e4684ebfef4659c7147a264548f0d1e61303df" translate="yes" xml:space="preserve">
          <source>As an aid in resetting colors, colored() takes a scalar as the first argument and any number of attribute strings as the second argument and returns the scalar wrapped in escape codes so that the attributes will be set as requested before the string and reset to normal after the string. Alternately, you can pass a reference to an array as the first argument, and then the contents of that array will be taken as attributes and color codes and the remainder of the arguments as text to colorize.</source>
          <target state="translated">色をリセットする際の補助として、colored()は第一引数にスカラを、第二引数に属性文字列を任意の数だけ受け取り、スカラをエスケープコードで包み込んだものを返します。あるいは、第一引数に配列への参照を渡して、その配列の内容をアトリビュートとカラーコードとして受け取り、残りの引数をテキストとして色付けすることもできます。</target>
        </trans-unit>
        <trans-unit id="9c1670ab0bb7042a354367f8f6979cab460d9b35" translate="yes" xml:space="preserve">
          <source>As an alternative to the above, you may prefer to throw exceptions using the Error module.</source>
          <target state="translated">上記の代わりに、Error モジュールを使用して例外を投げることもできます。</target>
        </trans-unit>
        <trans-unit id="782eb5f652231f0fff9e780cbf2fef47e3527def" translate="yes" xml:space="preserve">
          <source>As an alternative, overloaded constants (see &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;) provide a simple way to extend the functionality of the RE engine, by substituting one pattern for another.</source>
          <target state="translated">別の方法として、オーバーロードされた定数（&lt;a href=&quot;overload&quot;&gt;overloadを&lt;/a&gt;参照）は、あるパターンを別のパターンに置き換えることにより、REエンジンの機能を拡張する簡単な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="18772395363d0e88e55df307a43fbfe2be745eba" translate="yes" xml:space="preserve">
          <source>As an alternative, specify a number instead of list of letters (e.g., &lt;b&gt;-D14&lt;/b&gt; is equivalent to &lt;b&gt;-Dtls&lt;/b&gt;):</source>
          <target state="translated">別の方法として、文字のリストの代わりに数字を指定します（たとえば、&lt;b&gt;-D14&lt;/b&gt;は&lt;b&gt;-Dtls&lt;/b&gt;と同等&lt;b&gt;です&lt;/b&gt;）：</target>
        </trans-unit>
        <trans-unit id="8f4ba5d9ceee180216d44c33a248904b28bf93a4" translate="yes" xml:space="preserve">
          <source>As an alternative, to keep the case of the replacement word if it is longer than the original, you can use this code, by Jeff Pinyan:</source>
          <target state="translated">別の方法として、元の単語よりも長い場合に置換語の大文字小文字を区別しないようにするには、Jeff Pinyanによるこのコードを使用することができます。</target>
        </trans-unit>
        <trans-unit id="edc86b424441622df9f0c07df7eb59f80cab5da3" translate="yes" xml:space="preserve">
          <source>As an example of something that is caught under &lt;code&gt;&quot;strict'&lt;/code&gt; , but not otherwise, is the pattern</source>
          <target state="translated">&lt;code&gt;&quot;strict'&lt;/code&gt; でキャッチされたものの例として、それ以外の場合はパターンは</target>
        </trans-unit>
        <trans-unit id="52b1b17f0c5a778dad149ae64ff9d232a5d6120e" translate="yes" xml:space="preserve">
          <source>As an example of this case, this code prints the message &quot;Perl exited with active threads: 2 running and unjoined&quot;:</source>
          <target state="translated">この場合の例として、このコードは &quot;Perl exited with active threads.&quot;というメッセージを表示します。2つのスレッドが実行されていて、結合されていません。</target>
        </trans-unit>
        <trans-unit id="fd8cd6983452bdbcd828fbbb431f9c0eaf4c793d" translate="yes" xml:space="preserve">
          <source>As an example where a possessive quantifier is suitable we consider matching a quoted string, as it appears in several programming languages. The backslash is used as an escape character that indicates that the next character is to be taken literally, as another character for the string. Therefore, after the opening quote, we expect a (possibly empty) sequence of alternatives: either some character except an unescaped quote or backslash or an escaped character.</source>
          <target state="translated">所有的量詞が適している例として、いくつかのプログラミング言語で使用されている引用符で囲まれた文字列のマッチングを考えてみます。バックスラッシュはエスケープ文字として使用され、次の文字が文字列の別の文字として文字通りに解釈されることを示します。したがって、冒頭の引用符の後には、エスケープされていない引用符やバックスラッシュ以外の文字、またはエスケープされた文字のいずれかの選択肢が(おそらくは空の)連続であることが予想されます。</target>
        </trans-unit>
        <trans-unit id="82731324b346859b9bccf9603560116021199d53" translate="yes" xml:space="preserve">
          <source>As an example, when Perl sees &lt;code&gt;$x = &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(400)&lt;/code&gt; , it encodes the character in UTF-8 and stores it in $x. Then it is marked as character data, so, for instance, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt; . However, in the scope of the &lt;code&gt;bytes&lt;/code&gt; pragma, $x is treated as a series of bytes - the bytes that make up the UTF8 encoding - and &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt; :</source>
          <target state="translated">例として、Perlは &lt;code&gt;$x = &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(400)&lt;/code&gt; を検出すると、文字をUTF-8でエンコードし、$ xに格納します。その後、文字データとしてマークされるため、たとえば、 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; は &lt;code&gt;1&lt;/code&gt; を返します。ただし、 &lt;code&gt;bytes&lt;/code&gt; プラグマのスコープでは、$ xは一連のバイト（UTF8エンコーディングを構成するバイト）として扱われ、 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; は &lt;code&gt;2&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="c313609d4ce2bde8a8cf3d1a920bc018f88eebaa" translate="yes" xml:space="preserve">
          <source>As an interim measure, you may either change the #! line of your scripts to specifically refer to the old perl version, e.g. on Solaris 9 use #!/usr/perl5/5.00503/bin/perl to use the perl version that was the default for Solaris 8, or if you have a large number of scripts it may be more convenient to make the old version of perl the default on your system. You can do this by changing the appropriate symlinks under /usr/perl5 as follows (example for Solaris 9):</source>
          <target state="translated">暫定的な対策として、スクリプトの #! 行を変更して、古いバージョンの perl を具体的に参照するようにします。例えば、Solaris 9 では #!/usr/perl5/5.00503/bin/perl を使用して、Solaris 8 のデフォルトの perl バージョンを使用するようにします。これは、/usr/perl5 の下の適切なシンボリックリンクを以下のように変更することで行うことができます (Solaris 9 の場合の例)。</target>
        </trans-unit>
        <trans-unit id="373576f861e30b7c81e25bff74bee6e23c15298c" translate="yes" xml:space="preserve">
          <source>As an optimization, may not call the command shell specified in &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, @args)&lt;/code&gt; spawns an external process and immediately returns its process designator, without waiting for it to terminate. Return value may be used subsequently in &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;. Failure to &lt;code&gt;spawn()&lt;/code&gt; a subprocess is indicated by setting &lt;code&gt;$?&lt;/code&gt; to &lt;code&gt;&quot;255 &amp;lt;&amp;lt; 8&quot;&lt;/code&gt; . &lt;code&gt;$?&lt;/code&gt; is set in a way compatible with Unix (i.e. the exitstatus of the subprocess is obtained by &lt;code&gt;&quot;$?&lt;/code&gt; 8&quot;&amp;gt;&amp;gt;, as described in the documentation). (Win32)</source>
          <target state="translated">最適化として、 &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; 指定されたコマンドシェルを呼び出さない場合があります。 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, @args)&lt;/code&gt; は外部プロセスを生成し、プロセスの終了を待たずにすぐにそのプロセス指定子を返します。戻り値は、後で &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; で使用できます。サブプロセスの &lt;code&gt;spawn()&lt;/code&gt; の失敗は、 &lt;code&gt;$?&lt;/code&gt; &lt;code&gt;&quot;255 &amp;lt;&amp;lt; 8&quot;&lt;/code&gt; 。 &lt;code&gt;$?&lt;/code&gt; Unixと互換性のある方法で設定されます（つまり、ドキュメンテーションに記載されているように、サブプロセスの終了ステータスは &lt;code&gt;&quot;$?&lt;/code&gt; 8&quot; &amp;gt;&amp;gt; によって取得されます）。 （Win32）</target>
        </trans-unit>
        <trans-unit id="38474bdd192558dcfa688dfaf6e45817a6f595ea" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a</source>
          <target state="translated">別の特別な場合として、 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 、コマンドラインツールのデフォルトの動作をエミュレート&lt;b&gt;のawkを&lt;/b&gt;パターンのいずれかを省略またはAれるとき</target>
        </trans-unit>
        <trans-unit id="aab9f2eadc04a37e669ffc31217a1ec91df2a94d" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a</source>
          <target state="translated">別の特別な場合として、 &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 、コマンドラインツールのデフォルトの動作をエミュレート&lt;b&gt;のawkを&lt;/b&gt;パターンのいずれかを省略またはAれるとき</target>
        </trans-unit>
        <trans-unit id="46ab5c6135652ee2c4d494e00004b3edd1c35481" translate="yes" xml:space="preserve">
          <source>As another workaround for this problem, Perl 5.10.0 introduced &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , which are equivalent to &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; , &lt;b&gt;except&lt;/b&gt; that they are only guaranteed to be defined after a successful match that was executed with the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier. The use of these variables incurs no global performance penalty, unlike their punctuation char equivalents, however at the trade-off that you have to tell perl when you want to use them. As of Perl 5.20, these three variables are equivalent to &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; , and &lt;code&gt;/p&lt;/code&gt; is ignored.</source>
          <target state="translated">この問題の別の回避策として、Perlの5.10.0は導入 &lt;code&gt;${^PREMATCH}&lt;/code&gt; 、 &lt;code&gt;${^MATCH}&lt;/code&gt; と &lt;code&gt;${^POSTMATCH}&lt;/code&gt; と等価であり、 &lt;code&gt;$`&lt;/code&gt; 、 &lt;code&gt;$&amp;amp;&lt;/code&gt; や &lt;code&gt;$'&lt;/code&gt; 、&lt;b&gt;を除く&lt;/b&gt;それらはだけに保証されていることを &lt;code&gt;/p&lt;/code&gt; （保持）修飾子を使用して実行された一致が成功した後に定義されます。これらの変数を使用しても、同等の句読点文字とは異なり、グローバルパフォーマンスが低下することはありませんが、トレードオフで、使用するときにperlに通知する必要があります。Perl 5.20以降、これらの3つの変数は &lt;code&gt;$`&lt;/code&gt; 、 &lt;code&gt;$&amp;amp;&lt;/code&gt; および &lt;code&gt;$'&lt;/code&gt; 、および &lt;code&gt;/p&lt;/code&gt; と同等です。 無視されます。</target>
        </trans-unit>
        <trans-unit id="faf1880e6e4e5e1670571e23b070295ae744c1fc" translate="yes" xml:space="preserve">
          <source>As described &lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;above&lt;/a&gt;, Perl may call methods for operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in the course of implementing missing operations like &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; , and &lt;code&gt;&amp;amp;=&lt;/code&gt; . While these methods may detect this usage by testing the definedness of the third argument, they should in all cases avoid changing their operands. This is because Perl does not call the copy constructor before invoking these methods.</source>
          <target state="translated">説明したように&lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;上記&lt;/a&gt;、Perlのような演算子のための方法を呼び出すことができる &lt;code&gt;+&lt;/code&gt; をと &lt;code&gt;&amp;amp;&lt;/code&gt; ような欠落動作を実現する過程において &lt;code&gt;++&lt;/code&gt; 、 &lt;code&gt;+=&lt;/code&gt; 、および &lt;code&gt;&amp;amp;=&lt;/code&gt; 。これらのメソッドは、3番目の引数の定義をテストすることによってこの使用法を検出する可能性がありますが、すべての場合において、オペランドの変更を回避する必要があります。これは、Perlがこれらのメソッドを呼び出す前にコピーコンストラクターを呼び出さないためです。</target>
        </trans-unit>
        <trans-unit id="6ff132deadaac51720c9e117548f044618ad0a39" translate="yes" xml:space="preserve">
          <source>As discussed elsewhere, Perl has one foot (two hooves?) planted in each of two worlds: the old world of ASCII and single-byte locales, and the new world of Unicode, upgrading when necessary. If your legacy code does not explicitly use Unicode, no automatic switch-over to Unicode should happen.</source>
          <target state="translated">別の場所で議論されているように、Perl は 2 つの世界のそれぞれに片足 (2 本の蹄?)を置いています:ASCII とシングルバイトのロケールの古い世界と、Unicode の新しい世界です。古いコードが明示的に Unicode を使用していない場合、自動的に Unicode への切り替えは行われるべきではありません。</target>
        </trans-unit>
        <trans-unit id="3a28f6e945d7b1d8cd9440551fcd17f03dc59837" translate="yes" xml:space="preserve">
          <source>As explained above, an anonymous function with access to the lexical variables visible when that function was compiled, creates a closure. It retains access to those variables even though it doesn't get run until later, such as in a signal handler or a Tk callback.</source>
          <target state="translated">上で説明したように、その関数がコンパイルされたときに見える字句変数にアクセスできる匿名関数は、クロージャを作成します。シグナルハンドラや Tk コールバックのように、後になってから実行されなくても、これらの変数へのアクセスは保持されます。</target>
        </trans-unit>
        <trans-unit id="de6278f8e877d258b1f62760a70228a073ba24fd" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII Rules versus Unicode Rules&lt;/a&gt;, under ASCII rules, they are considered to be unassigned characters.</source>
          <target state="translated">&lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCIIルールとUnicodeルール&lt;/a&gt;で説明されているように、ASCIIルールでは、これらは割り当てられていない文字と見なされます。</target>
        </trans-unit>
        <trans-unit id="8ffaa22d40c8f644f2c59a68a07b28bdf08a1f8a" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#prop_invlist()&quot;&gt;prop_invlist()&lt;/a&gt;, whether a code point is in the list or not depends on if the index is even (in) or odd (not in). And as explained in &lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap()&lt;/a&gt;, the index is used with the returned parallel array to find the mapping.</source>
          <target state="translated">&lt;a href=&quot;#prop_invlist()&quot;&gt;prop_invlist（）&lt;/a&gt;で説明したように、コードポイントがリスト内にあるかどうかは、インデックスが偶数（in）か奇数（not in）かによって異なります。そして、&lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap（）&lt;/a&gt;で説明されているように、返された並列配列でインデックスを使用してマッピングを見つけます。</target>
        </trans-unit>
        <trans-unit id="c53e475afb32fdd8296f1c9a917ef2e75b376078" translate="yes" xml:space="preserve">
          <source>As for other operations, the subroutine implementing '=' is passed three arguments, though the last two are always &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;''&lt;/code&gt; .</source>
          <target state="translated">他の操作については、「=」を実装するサブルーチンに3つの引数が渡されますが、最後の2つは常に &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;''&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2f54bd3297d1b4b8911e3de6ffd9e1ee35795e3c" translate="yes" xml:space="preserve">
          <source>As if all those classes weren't enough, Perl also defines POSIX-style character classes. These have the form &lt;code&gt;[:name:]&lt;/code&gt;, with &lt;code&gt;name&lt;/code&gt; the name of the POSIX class. The POSIX classes are &lt;code&gt;alpha&lt;/code&gt; , &lt;code&gt;alnum&lt;/code&gt; , &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;cntrl&lt;/code&gt; , &lt;code&gt;digit&lt;/code&gt; , &lt;code&gt;graph&lt;/code&gt; , &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;punct&lt;/code&gt; , &lt;code&gt;space&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , and &lt;code&gt;xdigit&lt;/code&gt; , and two extensions, &lt;code&gt;word&lt;/code&gt; (a Perl extension to match &lt;code&gt;\w&lt;/code&gt; ), and &lt;code&gt;blank&lt;/code&gt; (a GNU extension). The &lt;code&gt;//a&lt;/code&gt; modifier restricts these to matching just in the ASCII range; otherwise they can match the same as their corresponding Perl Unicode classes: &lt;code&gt;[:upper:]&lt;/code&gt; is the same as &lt;code&gt;\p{IsUpper}&lt;/code&gt; , etc. (There are some exceptions and gotchas with this; see &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; for a full discussion.) The &lt;code&gt;[:digit:]&lt;/code&gt;, &lt;code&gt;[:word:]&lt;/code&gt;, and &lt;code&gt;[:space:]&lt;/code&gt; correspond to the familiar &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , and &lt;code&gt;\s&lt;/code&gt; character classes. To negate a POSIX class, put a &lt;code&gt;^&lt;/code&gt; in front of the name, so that, e.g., &lt;code&gt;[:^digit:]&lt;/code&gt; corresponds to &lt;code&gt;\D&lt;/code&gt; and, under Unicode, &lt;code&gt;\P{IsDigit}&lt;/code&gt; . The Unicode and POSIX character classes can be used just like &lt;code&gt;\d&lt;/code&gt; , with the exception that POSIX character classes can only be used inside of a character class:</source>
          <target state="translated">これらすべてのクラスでは不十分であるかのように、PerlはPOSIXスタイルの文字クラスも定義します。これらの形式は &lt;code&gt;[:name:]&lt;/code&gt; で、 &lt;code&gt;name&lt;/code&gt; はPOSIXクラスの名前です。 POSIXクラスは &lt;code&gt;alpha&lt;/code&gt; 、 &lt;code&gt;alnum&lt;/code&gt; 、 &lt;code&gt;ascii&lt;/code&gt; 、 &lt;code&gt;cntrl&lt;/code&gt; 、 &lt;code&gt;digit&lt;/code&gt; 、 &lt;code&gt;graph&lt;/code&gt; 、 &lt;code&gt;lower&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;punct&lt;/code&gt; 、 &lt;code&gt;space&lt;/code&gt; 、 &lt;code&gt;upper&lt;/code&gt; 、及び &lt;code&gt;xdigit&lt;/code&gt; 、及び2つの延長、 &lt;code&gt;word&lt;/code&gt; （Perl拡張一致するように &lt;code&gt;\w&lt;/code&gt; ）、および &lt;code&gt;blank&lt;/code&gt; （GNU拡張）。 &lt;code&gt;//a&lt;/code&gt; 修飾子は、これらをASCII範囲でのマッチングに制限します。そうでなければ彼らはそれらの対応するPerlのUnicodeのクラスと同じように一致させることができる： &lt;code&gt;[:upper:]&lt;/code&gt; と同じである &lt;code&gt;\p{IsUpper}&lt;/code&gt; 等（これにはいくつかの例外と落とし穴があり、参照&lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclassを&lt;/a&gt;完全な議論のために。） &lt;code&gt;[:digit:]&lt;/code&gt; 、 &lt;code&gt;[:word:]&lt;/code&gt; 、および &lt;code&gt;[:space:]&lt;/code&gt; は、おなじみの &lt;code&gt;\d&lt;/code&gt; 、 &lt;code&gt;\w&lt;/code&gt; 、および &lt;code&gt;\s&lt;/code&gt; 文字クラスに対応しています。 POSIXクラスを無効にするには、名前の前に &lt;code&gt;^&lt;/code&gt; を付けます。たとえば、 &lt;code&gt;[:^digit:]&lt;/code&gt; は &lt;code&gt;\D&lt;/code&gt; 対応し、Unicodeでは &lt;code&gt;\P{IsDigit}&lt;/code&gt; 。UnicodeおよびPOSIX文字クラスは &lt;code&gt;\d&lt;/code&gt; と同じように使用できますが、POSIX文字クラスは文字クラス内でのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="460ff6781c9a7b0d42e2f096c304dc01b5296e55" translate="yes" xml:space="preserve">
          <source>As implied above, the environment accessed through &lt;code&gt;%ENV&lt;/code&gt; is global, and the convention is that program specific environment variables are of the form &lt;code&gt;Program$Name&lt;/code&gt; . Each filesystem maintains a current directory, and the current filesystem's current directory is the &lt;b&gt;global&lt;/b&gt; current directory. Consequently, sociable programs don't change the current directory but rely on full pathnames, and programs (and Makefiles) cannot assume that they can spawn a child process which can change the current directory without affecting its parent (and everyone else for that matter).</source>
          <target state="translated">上記のように、 &lt;code&gt;%ENV&lt;/code&gt; を介してアクセスされる環境はグローバルであり、プログラム固有の環境変数の形式は &lt;code&gt;Program$Name&lt;/code&gt; です。各ファイルシステムは現在のディレクトリを維持し、現在のファイルシステムの現在のディレクトリは&lt;b&gt;グローバルな&lt;/b&gt;現在のディレクトリです。その結果、社交的なプログラムは現在のディレクトリを変更せず、完全パス名に依存します。プログラム（およびMakefile）は、親（およびその他すべての人）に影響を与えずに現在のディレクトリを変更できる子プロセスを生成できるとは想定できません。 。</target>
        </trans-unit>
        <trans-unit id="9cfe8ec9bce67c19def3a159ea6c0eb1d6dbe31c" translate="yes" xml:space="preserve">
          <source>As in some shells, you can enclose the variable name in braces to disambiguate it from following alphanumerics (and underscores). You must also do this when interpolating a variable into a string to separate the variable name from a following double-colon or an apostrophe, since these would be otherwise treated as a package separator:</source>
          <target state="translated">いくつかのシェルのように、変数名を中括弧で囲むことで、後続の英数字 (およびアンダースコア)から変数名を区別することができます。また、変数を文字列に補間する際に、ダブルコロンやアポストロフィから変数名を分離するためにも、このようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="f260d12b5b1b7a497f5733dde8f966ff0dea7a60" translate="yes" xml:space="preserve">
          <source>As it stands it predates version.pm but has the same goal: make version strings visible and comparable.</source>
          <target state="translated">現状では version.pm よりも先行していますが、同じ目標を持っています:バージョンの文字列を可視化して比較可能にすることです。</target>
        </trans-unit>
        <trans-unit id="e22bdaf7af0b55a0257fbf249cc6b2acfdfc9220" translate="yes" xml:space="preserve">
          <source>As its name suggests, if your code tripped a mandatory warning, you would get a warning whether you wanted it or not. For example, the code below would always produce an &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; warning about the &quot;2:&quot;.</source>
          <target state="translated">その名前が示すように、コードが必須の警告を発した場合、それが必要かどうかにかかわらず警告が表示されます。たとえば、次のコードは常に「2：」に関する &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; 警告を生成します。</target>
        </trans-unit>
        <trans-unit id="299f8da88c7d33c41fa9b9da7b25493959ed6b3c" translate="yes" xml:space="preserve">
          <source>As just mentioned, all variables are, by default, thread local. To use shared variables, you need to also load &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;:</source>
          <target state="translated">今述べたように、すべての変数はデフォルトでスレッドローカルです。シェア変数を使用するには、&lt;a href=&quot;threads/shared&quot;&gt;threads :: shared&lt;/a&gt;もロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="1b2545d2ff62a227583262bedb22954e6e8e3fc3" translate="yes" xml:space="preserve">
          <source>As locks are advisory, they do not prevent data access or modification by another thread that does not itself attempt to obtain a lock on the variable.</source>
          <target state="translated">ロックは勧告的なものなので、変数のロックを取得しようとしない別のスレッドによるデータアクセスや変更を防ぐことはできません。</target>
        </trans-unit>
        <trans-unit id="81ff74ffe73c98f024294d6b4b3ccdb104adb917" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt; ), &lt;b&gt;pod2man&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2man&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;b&gt;pod2man&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">処理されたすべてのドキュメントの結果が出力である限り、その出力にエラッタ（ &lt;code&gt;--errors=pod&lt;/code&gt; で生成された &lt;code&gt;POD ERRORS&lt;/code&gt; ERRORSセクション）が含まれていても、&lt;b&gt;pod2man&lt;/b&gt;はステータス0で終了します。処理中のドキュメントのいずれかが出力ドキュメント&lt;b&gt;。pod2man&lt;/b&gt;はステータス1で終了します。処理中のPODドキュメントに構文エラーがあり、エラー処理スタイルがデフォルトの &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; に設定されている場合、&lt;b&gt;pod2man&lt;/b&gt;は終了ステータス255でただちに中止されます。</target>
        </trans-unit>
        <trans-unit id="00a3a680bcee6a61521d2a5ef5058ff99a76856b" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt; ), &lt;b&gt;pod2text&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2text&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;b&gt;pod2text&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">処理されたすべてのドキュメントの結果が出力である限り、その出力にエラッタ（ &lt;code&gt;--errors=pod&lt;/code&gt; で生成された &lt;code&gt;POD ERRORS&lt;/code&gt; ERRORSセクション）が含まれていても、&lt;b&gt;pod2text&lt;/b&gt;はステータス0で終了します。処理中のドキュメントのいずれかが出力ドキュメント、&lt;b&gt;pod2text&lt;/b&gt;はステータス1で終了します。処理中のPODドキュメントに構文エラーがあり、エラー処理スタイルがデフォルトの &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; に設定されている場合、&lt;b&gt;pod2text&lt;/b&gt;は終了ステータス255でただちに中止されます。</target>
        </trans-unit>
        <trans-unit id="95c1aea5304f4de3806c6769617146a8ffc159e5" translate="yes" xml:space="preserve">
          <source>As long as the reference is never returned by any function within the module, no outside module can see the subroutine, because its name is not in any package's symbol table. Remember that it's not</source>
          <target state="translated">モジュール内のどの関数からも参照が返されない限り、外部のモジュールはそのサブルーチンを見ることができません。このサブルーチンの名前は</target>
        </trans-unit>
        <trans-unit id="958bb5f65d2f4962aaa4f5dd2b31857927db841a" translate="yes" xml:space="preserve">
          <source>As mentioned &lt;a href=&quot;#Mathemagic%2c-Mutators%2c-and-Copy-Constructors&quot;&gt;above&lt;/a&gt;, this operation is called when a mutator is applied to a reference that shares its object with some other reference. For example, if &lt;code&gt;$b&lt;/code&gt; is mathemagical, and &lt;code&gt;'++'&lt;/code&gt; is overloaded with &lt;code&gt;'incr'&lt;/code&gt; , and &lt;code&gt;'='&lt;/code&gt; is overloaded with &lt;code&gt;'clone'&lt;/code&gt; , then the code</source>
          <target state="translated">上記の&lt;a href=&quot;#Mathemagic%2c-Mutators%2c-and-Copy-Constructors&quot;&gt;ように&lt;/a&gt;、この操作は、他の参照とオブジェクトを共有する参照にミューテーターが適用されるときに呼び出されます。たとえば、 &lt;code&gt;$b&lt;/code&gt; が数学的なもので、 &lt;code&gt;'++'&lt;/code&gt; が &lt;code&gt;'incr'&lt;/code&gt; でオーバーロードされ、 &lt;code&gt;'='&lt;/code&gt; が &lt;code&gt;'clone'&lt;/code&gt; でオーバーロードされている場合、コード</target>
        </trans-unit>
        <trans-unit id="6db309618dd0587d20027a36c5759130977518d4" translate="yes" xml:space="preserve">
          <source>As mentioned above under &lt;a href=&quot;#ALIASES&quot;&gt;ALIASES&lt;/a&gt;, Unicode 6.1 defines extra names (synonyms or aliases) for some code points, most of which were already available as Perl extensions. All these are accepted by &lt;code&gt;\N{...}&lt;/code&gt; and the other functions in this module, but &lt;code&gt;viacode&lt;/code&gt; has to choose which one name to return for a given input code point, so it returns the &quot;best&quot; name. To understand how this works, it is helpful to know more about the Unicode name properties. All code points actually have only a single name, which (starting in Unicode 2.0) can never change once a character has been assigned to the code point. But mistakes have been made in assigning names, for example sometimes a clerical error was made during the publishing of the Standard which caused words to be misspelled, and there was no way to correct those. The Name_Alias property was eventually created to handle these situations. If a name was wrong, a corrected synonym would be published for it, using Name_Alias. &lt;code&gt;viacode&lt;/code&gt; will return that corrected synonym as the &quot;best&quot; name for a code point. (It is even possible, though it hasn't happened yet, that the correction itself will need to be corrected, and so another Name_Alias can be created for that code point; &lt;code&gt;viacode&lt;/code&gt; will return the most recent correction.)</source>
          <target state="translated">上記の&lt;a href=&quot;#ALIASES&quot;&gt;エイリアス&lt;/a&gt;で説明したように、Unicode 6.1は、いくつかのコードポイントに追加の名前（同義語またはエイリアス）を定義します。そのほとんどは、Perl拡張機能としてすでに利用可能でした。これらすべては、 &lt;code&gt;\N{...}&lt;/code&gt; およびこのモジュールの他の関数によって受け入れられますが、 &lt;code&gt;viacode&lt;/code&gt; 特定の入力コードポイントに対して返す名前を1つ選択する必要があるため、「最適な」名前を返します。これがどのように機能するかを理解するには、Unicode名のプロパティについて詳しく知ることが役立ちます。すべてのコードポイントには実際には単一の名前しかありません。コードポイントに文字が割り当てられると、名前は（Unicode 2.0以降）変更できません。しかし、名前の割り当てに誤りがありました。たとえば、規格の公開中に、単語のスペルミスを引き起こす事務的なエラーが発生したことがあり、それらを修正する方法がありませんでした。 Name_Aliasプロパティは、これらの状況を処理するために最終的に作成されました。名前が間違っている場合は、Name_Aliasを使用して、修正された同義語が発行されます。 &lt;code&gt;viacode&lt;/code&gt; その修正されたシノニムをコードポイントの「最適な」名前として返します。 （まだ発生していませんが、修正自体を修正する必要がある可能性もあります。そのため、そのコードポイントに対して別のName_Aliasを作成できます &lt;code&gt;viacode&lt;/code&gt; は最新の修正を返します。）</target>
        </trans-unit>
        <trans-unit id="aa5ef151af9bb6073935edbcfff85b0147b33678" translate="yes" xml:space="preserve">
          <source>As mentioned above, UTF-8 uses a variable number of bytes to store a character. Characters with values 0...127 are stored in one byte, just like good ol' ASCII. Character 128 is stored as &lt;code&gt;v194.128&lt;/code&gt; ; this continues up to character 191, which is &lt;code&gt;v194.191&lt;/code&gt; . Now we've run out of bits (191 is binary &lt;code&gt;10111111&lt;/code&gt; ) so we move on; character 192 is &lt;code&gt;v195.128&lt;/code&gt; . And so it goes on, moving to three bytes at character 2048. &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;Unicode Encodings in perlunicode&lt;/a&gt; has pictures of how this works.</source>
          <target state="translated">上記のように、UTF-8は可変数のバイトを使用して文字を格納します。値が0 ... 127の文字は、ASCIIのように1バイトで格納されます。文字128は &lt;code&gt;v194.128&lt;/code&gt; として格納されます。これは文字191、つまり &lt;code&gt;v194.191&lt;/code&gt; まで続きます。ビットが &lt;code&gt;10111111&lt;/code&gt; なったので（191はバイナリ10111111です）、次に進みます。文字192は &lt;code&gt;v195.128&lt;/code&gt; です。 2048 &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;文字目&lt;/a&gt;で3バイトに移動します。perlunicodeのUnicodeエンコーディングは、これがどのように機能するかを示しています。</target>
        </trans-unit>
        <trans-unit id="b80f86706a5e778489f2084a741a86389a8e67cd" translate="yes" xml:space="preserve">
          <source>As mentioned above, you can determine the context of the currently executing subroutine in Perl with</source>
          <target state="translated">上で述べたように、Perlで現在実行中のサブルーチンのコンテキストは</target>
        </trans-unit>
        <trans-unit id="00501a67a82ec0513abc29055abfbad02a55f669" translate="yes" xml:space="preserve">
          <source>As mentioned at the top of this document, if you are having problems with these example extensions, you might see if any of these help you.</source>
          <target state="translated">このドキュメントの一番上で述べたように、これらの拡張子の例で問題がある場合は、これらの拡張子のどれかがあなたの助けになるかどうかを見てみるといいでしょう。</target>
        </trans-unit>
        <trans-unit id="2746f2e141da00d82feca97a110b834cca59fd6d" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, Perl can store a number in any one of three formats, but most operators typically understand only one of those formats. When a numeric value is passed as an argument to such an operator, it will be converted to the format understood by the operator.</source>
          <target state="translated">前述したように、Perl は 3 つの形式のうちの任意の 1 つに数値を格納することができますが、ほとんどの演算子は通常、これらの形式のうちの 1 つしか理解できません。このような演算子の引数として数値が渡されると、その演算子が理解する形式に変換されます。</target>
        </trans-unit>
        <trans-unit id="77154bb24a38474664192f3ea13c3d83da99f57f" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, a &quot;callback&quot; key may be added to the &lt;code&gt;TAP::Parser&lt;/code&gt; constructor. If present, each callback corresponding to a given result type will be called with the result as the argument if the &lt;code&gt;run&lt;/code&gt; method is used. The callback is expected to be a subroutine reference (or anonymous subroutine) which is invoked with the parser result as its argument.</source>
          <target state="translated">前述のように、「コールバック」キーは &lt;code&gt;TAP::Parser&lt;/code&gt; コンストラクターに追加できます。存在する場合、 &lt;code&gt;run&lt;/code&gt; メソッドが使用されている場合、特定の結果タイプに対応する各コールバックは、結果を引数として呼び出されます。コールバックは、パーサーの結果を引数として呼び出されるサブルーチン参照（または無名サブルーチン）であることが期待されています。</target>
        </trans-unit>
        <trans-unit id="4ebe40c302b03d332e451ead97b5b34c4f2894b9" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, in the case of the default engines, the &lt;code&gt;pprivate&lt;/code&gt; will be a pointer to a regexp_internal structure which holds the compiled program and any additional data that is private to the regex engine implementation.</source>
          <target state="translated">前述のように、デフォルトエンジンの場合、 &lt;code&gt;pprivate&lt;/code&gt; は、コンパイルされたプログラムと、正規表現エンジンの実装にプライベートな追加データを保持するregexp_internal構造体へのポインターになります。</target>
        </trans-unit>
        <trans-unit id="05bef95fb25bb75da2eac006c647172d0c563725" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;, encodings are (in the current implementation at least) defined as objects. The mapping of encoding name to object is via the &lt;code&gt;%Encode::Encoding&lt;/code&gt; hash. Though you can directly manipulate this hash, it is strongly encouraged to use this base class module and add encode() and decode() methods.</source>
          <target state="translated">&lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;で述べたように、エンコーディングは（少なくとも現在の実装では）オブジェクトとして定義されます。オブジェクトへのエンコーディング名のマッピングは、 &lt;code&gt;%Encode::Encoding&lt;/code&gt; ハッシュを介して行われます。このハッシュを直接操作することもできますが、この基本クラスモジュールを使用して、encode（）およびdecode（）メソッドを追加することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="83fbfdaddc2272e65e0714e5d0f69ab35b42f974" translate="yes" xml:space="preserve">
          <source>As mentioned in the previous item, this still doesn't work when using socket I/O between Unix and Macintosh. You'll need to hard code your line terminators, in that case.</source>
          <target state="translated">前の項目で述べたように、UnixとMacintosh間でソケットI/Oを使用する場合、これはまだうまくいきません。その場合は、ラインターミネータをハードコーディングする必要があります。</target>
        </trans-unit>
        <trans-unit id="ed52abb82f45ac71a451aad1bb7530a654fe2ad3" translate="yes" xml:space="preserve">
          <source>As mentioned previously, dynamic loading isn't currently available nor is MakeMaker. Both are high-priority items.</source>
          <target state="translated">前述したように、ダイナミックローディングは現在のところ利用できませんし、MakeMaker も利用できません。どちらも優先度の高い項目です。</target>
        </trans-unit>
        <trans-unit id="9fbc47f4ab04b1b192086c459c88acf77887350f" translate="yes" xml:space="preserve">
          <source>As mentioned, the function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if no name is known for the code point. In Unicode the proper name for these is the empty string, which &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; stringifies to. (If you ask for a code point past the legal Unicode maximum of U+10FFFF that you haven't assigned an alias to, you get &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; plus a warning.)</source>
          <target state="translated">前述のように、コードポイントの名前が不明の場合、関数は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。Unicodeでは、これらの適切な名前は空の文字列で、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; によって文字列化されます。（エイリアスを割り当てていない、コードのポイントがUnicodeの法定最大U + 10FFFFを超えている場合、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; と警告が表示されます。）</target>
        </trans-unit>
        <trans-unit id="651eca43c6e2d73bc740fcae1016d17e36d82316" translate="yes" xml:space="preserve">
          <source>As most of the remaining expected output to the error stream will be created by &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;'s &lt;code&gt;diag&lt;/code&gt; function, &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; provides a convenience function &lt;code&gt;test_diag&lt;/code&gt; that you can use instead of &lt;code&gt;test_err&lt;/code&gt; .</source>
          <target state="translated">エラーストリームに残っている期待される出力のほとんどはによって作成されるように&lt;a href=&quot;../builder&quot;&gt;テスト:: Builderの&lt;/a&gt;の &lt;code&gt;diag&lt;/code&gt; 機能、&lt;a href=&quot;tester&quot;&gt;テスト::ビルダー:: Testerは&lt;/a&gt;便利な機能を提供し &lt;code&gt;test_diag&lt;/code&gt; あなたの代わりに使用できることを &lt;code&gt;test_err&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="a3938aef953ff6d9fa864efd013ef275f9aaeca4" translate="yes" xml:space="preserve">
          <source>As noted above, if the file does not already exist, then the append-mode open will create it for you. But if the file does already exist, its contents are safe from harm because you will be adding your new text past the end of the old text.</source>
          <target state="translated">上で述べたように、ファイルが既に存在しない場合は、append-mode openがファイルを作成します。しかし、ファイルが既に存在している場合、古いテキストの終わりを過ぎて新しいテキストを追加することになるので、その内容は害を受けることはありません。</target>
        </trans-unit>
        <trans-unit id="aa50c7a75f631655fc7d60c7b218e502c8aba3fb" translate="yes" xml:space="preserve">
          <source>As noted earlier in this document, the scalar sense of list assignment is the number of elements on the right-hand side of the assignment. The null list contains no elements, so when the password file is exhausted, the result is 0, not 2.</source>
          <target state="translated">このドキュメントで先に述べたように、リストの代入のスカラー感覚は、代入の右側にある要素の数です。ヌルリストには要素が含まれていないので、パスワードファイルが枯渇すると、結果は2ではなく0になります。</target>
        </trans-unit>
        <trans-unit id="c32dd8a34a2658e1d2e1869aeb4cec0307b6493f" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;#USING-LOCALES&quot;&gt;USING LOCALES&lt;/a&gt;, &lt;code&gt;cmp&lt;/code&gt; compares according to the current collation locale when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, but falls back to a char-by-char comparison for strings that the locale says are equal. You can use &lt;code&gt;POSIX::strcoll()&lt;/code&gt; if you don't want this fall-back:</source>
          <target state="translated">で述べたように&lt;a href=&quot;#USING-LOCALES&quot;&gt;ロケールを用い&lt;/a&gt;、 &lt;code&gt;cmp&lt;/code&gt; する際、現在の照合ロケールに従って比較 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 有効であるが、ロケールが等しいと言うことバック文字列の文字ごとの文字の比較に落ちます。このフォールバックが必要ない場合は、 &lt;code&gt;POSIX::strcoll()&lt;/code&gt; 使用できます。</target>
        </trans-unit>
        <trans-unit id="eda06429df1073940e96ea523060e042021aeec8" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;perlhack#TESTING&quot;&gt;TESTING in perlhack&lt;/a&gt;, when writing test scripts, the file</source>
          <target state="translated">&lt;a href=&quot;perlhack#TESTING&quot;&gt;perlhackのTESTINGで&lt;/a&gt;述べたように、テストスクリプトを書くとき、ファイル</target>
        </trans-unit>
        <trans-unit id="716cc3d3aff35fc6629ccc256677b64774af14df" translate="yes" xml:space="preserve">
          <source>As of 1.37_02 install() supports the use of a list of patterns to filter out files that shouldn't be installed. If $skip is omitted or undefined then install will try to read the list from INSTALL.SKIP in the CWD. This file is a list of regular expressions and is just like the MANIFEST.SKIP file used by &lt;a href=&quot;manifest&quot;&gt;ExtUtils::Manifest&lt;/a&gt;.</source>
          <target state="translated">1.37_02以降、install（）はパターンリストの使用をサポートし、インストールすべきでないファイルを除外します。$ skipが省略されているか未定義の場合、installはCWDのINSTALL.SKIPからリストを読み取ろうとします。このファイルは正規表現のリストであり、&lt;a href=&quot;manifest&quot;&gt;ExtUtils :: Manifestで&lt;/a&gt;使用されるMANIFEST.SKIPファイルと同じです。</target>
        </trans-unit>
        <trans-unit id="0f828a6d861469c7d75db52b836c69689c1760b7" translate="yes" xml:space="preserve">
          <source>As of 3.10, the internal data for all types of codes can be modified.</source>
          <target state="translated">3.10より、全種類のコードの内部データを変更できるようになりました。</target>
        </trans-unit>
        <trans-unit id="1d399ef50aa4f86fbc538d8e5d435b672ada57b9" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">5.14以降、これらがプラットフォームでサポートされていない場合でも、例外は発生しません。ただし、警告が有効になっている場合、サポートされていない変換フラグに対して &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 警告クラスの警告が発行されます。代わりに例外を好む場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="fd9213ca43980debccb984d13f9caaa2e79748be" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">5.14以降、これらがプラットフォームでサポートされていない場合でも、例外は発生しません。ただし、警告が有効になっている場合、サポートされていない変換フラグに対して &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 警告クラスの警告が発行されます。代わりに例外を好む場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="6791199e3f80fe4bbb43c0eaff9608d527ada74b" translate="yes" xml:space="preserve">
          <source>As of 5.14, that can also be written this way:</source>
          <target state="translated">5.14の時点では、このようにも書けます。</target>
        </trans-unit>
        <trans-unit id="b37d45aa3fafa285df8c8611054589c583244ea5" translate="yes" xml:space="preserve">
          <source>As of 5.19.9 setting &lt;code&gt;$/&lt;/code&gt; to any other form of reference will throw a fatal exception. This is in preparation for supporting new ways to set &lt;code&gt;$/&lt;/code&gt; in the future.</source>
          <target state="translated">5.19.9以降、 &lt;code&gt;$/&lt;/code&gt; を他の参照形式に設定すると、致命的な例外がスローされます。これは、設定するための新しい方法サポートするための準備である &lt;code&gt;$/&lt;/code&gt; 将来的には。</target>
        </trans-unit>
        <trans-unit id="5090edb4c78c4b281b3a889d093a1c4d0aac43d2" translate="yes" xml:space="preserve">
          <source>As of 5.8.1, long doubles are working if you use the Sun compilers (needed for additional math routines not included in libm).</source>
          <target state="translated">5.8.1 の時点では、Sun のコンパイラ (libm に含まれていない追加の数学ルーチンのために必要)を使用していれば、長いダブルスが動作します。</target>
        </trans-unit>
        <trans-unit id="f508ee41697726e1567be3f0dd308006b0a11bbd" translate="yes" xml:space="preserve">
          <source>As of 5.8.1, the &lt;b&gt;-C&lt;/b&gt; can be followed either by a number or a list of option letters. The letters, their numeric values, and effects are as follows; listing the letters is equal to summing the numbers.</source>
          <target state="translated">5.8.1以降、&lt;b&gt;-Cの&lt;/b&gt;後に数字またはオプション文字のリストを続けることができます。文字、数値、効果は以下の通りです。文字をリストすることは、数字を合計することと同じです。</target>
        </trans-unit>
        <trans-unit id="45cfda1b1b7f6423e5dd7ec6647effcbf0d30173" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as are the other directives. However they have both compile-time and run-time effects.</source>
          <target state="translated">5.9.5以降、他のディレクティブと同様に、ディレクティブ &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; を使用し、それに相当するものはレキシカルにスコープされます。ただし、それらにはコンパイル時と実行時の両方の効果があります。</target>
        </trans-unit>
        <trans-unit id="d51f5d10f6eede269e073b2d28e8411b4b049f81" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as the other directives are. However they have both compile-time and run-time effects.</source>
          <target state="translated">5.9.5以降、他のディレクティブと同様に、ディレクティブ &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; を使用し、それに相当するものはレキシカルにスコープされます。ただし、それらにはコンパイル時と実行時の両方の効果があります。</target>
        </trans-unit>
        <trans-unit id="8b5a3958e4abf52ef71b991a4f025f997262e7e8" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Encode&lt;/code&gt; 2.12, &lt;code&gt;CHECK&lt;/code&gt; can also be a code reference which takes the ordinal value of the unmapped character as an argument and returns octets that represent the fallback character. For instance:</source>
          <target state="translated">以下のように &lt;code&gt;Encode&lt;/code&gt; 2.12、 &lt;code&gt;CHECK&lt;/code&gt; はまた、代替文字を表す引数及び戻りオクテットとしてマッピングされていない文字の順序値をとるコード参照することができます。例えば：</target>
        </trans-unit>
        <trans-unit id="b411b3efc2bae2399e243c4103628c18af471dad" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Encode&lt;/code&gt; version 2.21, a new method &lt;code&gt;mime_name()&lt;/code&gt; is therefore added.</source>
          <target state="translated">以下のように &lt;code&gt;Encode&lt;/code&gt; バージョン2.21、新しいメソッド &lt;code&gt;mime_name()&lt;/code&gt; したがって、添加されます。</target>
        </trans-unit>
        <trans-unit id="703e152d6b7fb820f5c3dbc21f352bf9bc7a9e95" translate="yes" xml:space="preserve">
          <source>As of CPAN 1.9463, if you do not have permission to write the default perl library directories, CPAN's configuration process will ask you whether you want to bootstrap &amp;lt;local::lib&amp;gt;, which makes keeping a personal perl library directory easy.</source>
          <target state="translated">CPAN 1.9463以降、デフォルトのperlライブラリディレクトリを書き込む権限がない場合、CPANの設定プロセスで&amp;lt;local :: lib&amp;gt;をブートストラップするかどうかを尋ねられます。これにより、個人のperlライブラリディレクトリを簡単に維持できます。</target>
        </trans-unit>
        <trans-unit id="07aaeb2f2c75fecbde3c90f6c2e907a83c502842" translate="yes" xml:space="preserve">
          <source>As of Encode 1.87, the older form</source>
          <target state="translated">Encode 1.87では、古い形式の</target>
        </trans-unit>
        <trans-unit id="b09ae12c2db054fb655cbb26f548a82db4c390c0" translate="yes" xml:space="preserve">
          <source>As of July 2002 (the Perl release 5.8.0), the following platforms were able to build Perl from the standard source code distribution available at &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;</source>
          <target state="translated">2002年7月（Perlリリース5.8.0）の時点で、次のプラットフォームは、&lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http：&lt;/a&gt; //www.cpan.org/src/にある標準のソースコード配布からPerlをビルドできました。</target>
        </trans-unit>
        <trans-unit id="fcab0673d5c88e7554da234165f977684b228be3" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, the &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables may be used. These are only set if the &lt;code&gt;/p&lt;/code&gt; modifier is present. Consequently they do not penalize the rest of the program. In Perl 5.20, &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; are available whether the &lt;code&gt;/p&lt;/code&gt; has been used or not (the modifier is ignored), and &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; and &lt;code&gt;$&amp;amp;&lt;/code&gt; do not cause any speed difference.</source>
          <target state="translated">Perl 5.10以降では、 &lt;code&gt;${^PREMATCH}&lt;/code&gt; 、 &lt;code&gt;${^MATCH}&lt;/code&gt; および &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 変数を使用できます。これらは、 &lt;code&gt;/p&lt;/code&gt; 修飾子が存在する場合にのみ設定されます。その結果、彼らはプログラムの残りの部分にペナルティを課しません。 Perl 5.20では、 &lt;code&gt;${^PREMATCH}&lt;/code&gt; 、 &lt;code&gt;${^MATCH}&lt;/code&gt; 、および &lt;code&gt;${^POSTMATCH}&lt;/code&gt; は、 &lt;code&gt;/p&lt;/code&gt; が使用されているかどうかに関係なく（修飾子は無視されます）、 &lt;code&gt;$`&lt;/code&gt; 、 &lt;code&gt;$'&lt;/code&gt; 、および &lt;code&gt;$&amp;amp;&lt;/code&gt; は使用できません。速度の違いを引き起こします。</target>
        </trans-unit>
        <trans-unit id="eafa84154e8f8c3596803a7b5e3904a497adc460" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, this pragma is lexically scoped and takes effect at compile time. In earlier versions its effect was global and took effect at run-time; the documentation suggested using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; to change the behaviour:</source>
          <target state="translated">Perl 5.10以降、このプラグマはレキシカルにスコープが設定され、コンパイル時に有効になります。以前のバージョンでは、その効果はグローバルで、実行時に有効になりました。動作を変更するために &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; を使用することを提案するドキュメント：</target>
        </trans-unit>
        <trans-unit id="86d4d0145ccce27050aa6a59ab5275c8b3a0cdb0" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, you can match balanced text with regular expressions using recursive patterns. Before Perl 5.10, you had to resort to various tricks such as using Perl code in &lt;code&gt;(??{})&lt;/code&gt; sequences.</source>
          <target state="translated">Perl 5.10以降では、再帰パターンを使用して、バランスの取れたテキストを正規表現と照合できます。Perl 5.10より前は、 &lt;code&gt;(??{})&lt;/code&gt; シーケンスでPerlコードを使用するなど、さまざまなトリックに頼らなければなりませんでした。</target>
        </trans-unit>
        <trans-unit id="eea5149372feb11e1db38e07d50576f276a6c743" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, Perl supports several Python/PCRE-specific extensions to the regex syntax. While Perl programmers are encouraged to use the Perl-specific syntax, the following are also accepted:</source>
          <target state="translated">Perl 5.10.0では、PerlはいくつかのPython/PCRE固有の正規表現構文の拡張をサポートしています。PerlプログラマはPerl固有の構文を使用することが推奨されていますが、以下のものも受け入れられています。</target>
        </trans-unit>
        <trans-unit id="793e424fe5bef6967b0c0b6751f2a3b12bcf501f" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, as a form of purely syntactic sugar, you can stack file test operators, in a way that &lt;code&gt;-f -w -x $file&lt;/code&gt; is equivalent to &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; . (This is only fancy syntax: if you use the return value of &lt;code&gt;-f $file&lt;/code&gt; as an argument to another filetest operator, no special magic will happen.)</source>
          <target state="translated">Perl 5.10.0以降では、純粋な構文糖の形式として、 &lt;code&gt;-f -w -x $file&lt;/code&gt; が &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; と同等の方法でファイルテスト演算子をスタックできます。（これは空想的な構文です： &lt;code&gt;-f $file&lt;/code&gt; 戻り値を別のファイルテスト演算子の引数として使用する場合、特別な魔法は起こりません。）</target>
        </trans-unit>
        <trans-unit id="4eb7e07d934fae953d19f8161458d55420e41446" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, one can create custom regular expression engines. This is not for the faint of heart, as they have to plug in at the C level. See &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; for more details.</source>
          <target state="translated">Perl 5.10.0以降では、カスタム正規表現エンジンを作成できます。Cレベルでプラグインする必要があるので、気弱な人には向いていません。詳細については、&lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="0c7a09399a8f27b12757a6f71f279fa17b42fdfd" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, you can also use the &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers to force big- or little-endian byte-order. This is useful if you want to store signed integers or 64-bit integers, for example.</source>
          <target state="translated">Perl 5.10.0以降では、 &lt;code&gt;&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;lt;&lt;/code&gt; 修飾子を使用して、ビッグエンディアンまたはリトルエンディアンのバイト順を強制することもできます。これは、たとえば、符号付き整数または64ビット整数を格納する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="835734cf27f076a5a1e9340fb76782ceeb1a149b" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.1 there is a new interface for plugging and using method resolution orders other than the default (linear depth first search). The C3 method resolution order added in 5.10.0 has been re-implemented as a plugin, without changing its Perl-space interface.</source>
          <target state="translated">Perl 5.10.1 では、デフォルト(線形深さ第一探索)以外のメソッド解決順序をプラグインして使用するための新しいインターフェイスがあります。5.10.0 で追加された C3 メソッド解決命令は、Perl 空間のインターフェイスを変更することなく、プラグインとして再実装されています。</target>
        </trans-unit>
        <trans-unit id="4ca2607d4b8da91c9aab14d61ac0b65b288bfff7" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">Perl 5.12以降では、 &lt;code&gt;while&lt;/code&gt; ループで裸の &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; を使用でき、反復ごとに &lt;code&gt;$_&lt;/code&gt; が設定されます。</target>
        </trans-unit>
        <trans-unit id="7ef4b7baf6bbb1a8636644643a30ec84c9a4f514" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">Perl 5.12以降では、 &lt;code&gt;while&lt;/code&gt; ループで裸の &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; を使用でき、反復ごとに &lt;code&gt;$_&lt;/code&gt; が設定されます。</target>
        </trans-unit>
        <trans-unit id="9aad368f35112b0ebb60af7e4b6035d03ee10832" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12, deprecated features and modules warn the user as they're used. When a module is deprecated, it will also be made available on CPAN. Installing it from CPAN will silence deprecation warnings for that module.</source>
          <target state="translated">Perl 5.12では、非推奨となった機能やモジュールは、使用されるたびにユーザに警告を発します。モジュールが非推奨になると、CPANでも利用できるようになります。CPAN からインストールすることで、そのモジュールに対する非推奨の警告は表示されなくなります。</target>
        </trans-unit>
        <trans-unit id="7bc75da6cf8214f9a49a145ca7f1ff6dd1976a38" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 every hash has its own hash traversal order, and this order changes every time a new element is inserted into the hash. This functionality is provided by maintaining an unsigned integer mask (U32) which is xor'ed with the actual bucket id during a traversal of the hash buckets using keys(), values() or each().</source>
          <target state="translated">Perl 5.18 では、すべてのハッシュは独自のハッシュ探索順序を持っており、この順序はハッシュに新しい要素が挿入されるたびに変更されます。この機能は、key()、values()、または each()を用いてハッシュバケットを探索する際に、実際のバケット ID と xor された符号なし整数マスク (U32)を保持することで提供されます。</target>
        </trans-unit>
        <trans-unit id="a8b875400d906734f1b4f9f29eb27503d8a35f16" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">Perlの5.18のとして、あなたは裸使用することができ &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 中 &lt;code&gt;while&lt;/code&gt; 設定されますループ、 &lt;code&gt;$_&lt;/code&gt; 反復ごとに。</target>
        </trans-unit>
        <trans-unit id="211e0f721f82a57a3e303b9bd4a37e7c878adb86" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">Perlの5.18のとして、あなたは裸使用することができ &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 中 &lt;code&gt;while&lt;/code&gt; 設定されますループ、 &lt;code&gt;$_&lt;/code&gt; 反復ごとに。</target>
        </trans-unit>
        <trans-unit id="c33c32e4c4b133822c39af8f8540bc2360a9b3e1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.20, instead of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; you can use:</source>
          <target state="translated">Perl 5.20以降では &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; を使用する代わりにFATAL =&amp;gt; 'all'; あなたは使うことができます：</target>
        </trans-unit>
        <trans-unit id="c35a63f8082ff3fbb7b2bded313d23f6fdc3cfd9" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, there is an experimental variant of this loop that accepts a variable preceded by a backslash for VAR, in which case the items in the LIST must be references. The backslashed variable will become an alias to each referenced item in the LIST, which must be of the correct type. The variable needn't be a scalar in this case, and the backslash may be followed by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. To use this form, you must enable the &lt;code&gt;refaliasing&lt;/code&gt; feature via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; . (See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. See also &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Assigning to References in perlref&lt;/a&gt;.)</source>
          <target state="translated">Perl 5.22の時点で、VARのバックスラッシュが前に付いた変数を受け入れるこのループの実験的な変形があります。この場合、リスト内の項目は参照である必要があります。バックスラッシュ付きの変数は、リスト内の参照される各項目のエイリアスになります。これは、正しいタイプである必要があります。この場合、変数はスカラーである必要はなく、バックスラッシュの後に &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; を付けることができます。このフォームを使用するには、 &lt;code&gt;refaliasing&lt;/code&gt; featureを &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; てリエイリアス機能を有効にする必要があります。 （&lt;a href=&quot;feature&quot;&gt;機能&lt;/a&gt;&lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;を参照してください。perlrefの参照への割り当て&lt;/a&gt;も参照してください。）</target>
        </trans-unit>
        <trans-unit id="df42579e1cb5e3f110d0c1cf4c3bbc08eda67128" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, this buggy behavior, while preserved for backward compatibility, is detected and emits a deprecation warning. If you want the subroutine to be inlined (with no warning), make sure the variable is not used in a context where it could be modified aside from where it is declared.</source>
          <target state="translated">Perl 5.22では、このバギーな動作は下位互換性のために保存されていますが、検出されて非推奨の警告を発します。もしサブルーチンを警告なしでインライン化したい場合は、変数が宣言されている場所以外で変更される可能性のあるコンテキストで使用されていないことを確認してください。</target>
        </trans-unit>
        <trans-unit id="b18e8f64ae6fd8a43ee4372bec94f73e67d74058" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, you can also use &lt;code&gt;(&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;)x2&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . (You can also do &lt;code&gt;($x) x 2&lt;/code&gt; , which is less useful, because it assigns to the same variable twice, clobbering the first value assigned.)</source>
          <target state="translated">Perl 5.22以降では、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 、&lt;a href=&quot;functions/undef&quot;&gt;undefの&lt;/a&gt;代わりに &lt;code&gt;(&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;)x2&lt;/code&gt; を使用することもできます。（ &lt;code&gt;($x) x 2&lt;/code&gt; 実行することもできます。これは、同じ変数に2回割り当てられ、最初に割り当てられた値を破棄するため、あまり役に立ちません。）</target>
        </trans-unit>
        <trans-unit id="6f3aa7e1697ed4bbe63edb4cde5bc634c7d4943e" translate="yes" xml:space="preserve">
          <source>As of Perl 5.6, you can represent filehandles with scalar variables which you treat as any other scalar.</source>
          <target state="translated">Perl 5.6 では、ファイルハンドルをスカラ変数で表現することができます。</target>
        </trans-unit>
        <trans-unit id="90e7536680dcd18ada661ef157609a74a6cebee3" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0 after using this module you cannot use the implicit &lt;code&gt;$_&lt;/code&gt; or the special filehandle &lt;code&gt;_&lt;/code&gt; with stat() or lstat(), trying to do so leads into strange errors. The workaround is for &lt;code&gt;$_&lt;/code&gt; to be explicit</source>
          <target state="translated">Perl 5.8.0以降、このモジュールを使用した後は、暗黙の &lt;code&gt;$_&lt;/code&gt; または特別なファイルハンドル &lt;code&gt;_&lt;/code&gt; をstat（）またはlstat（）で使用できなくなります。そうしようとすると、奇妙なエラーが発生します。回避策は &lt;code&gt;$_&lt;/code&gt; を明示的にすることです</target>
        </trans-unit>
        <trans-unit id="5fd0a9a99a09c2a713ff60adbdf886450b68308c" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, the &quot;Full&quot; case-folding of</source>
          <target state="translated">Perl 5.8.0では、&quot;フル &quot;の大文字小文字の折り返しは</target>
        </trans-unit>
        <trans-unit id="444326d8d5a5982dc22e2a52147d982ac07eb8e8" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, you can use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; with multiple arguments. Just like the list forms of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;, no shell escapes happen.</source>
          <target state="translated">Perl 5.8.0以降では、複数の引数を指定して &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; を使用できます。 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; のリスト形式と同様に、シェルエスケープは発生しません。</target>
        </trans-unit>
        <trans-unit id="a68a3c591a49e26bfd6e1872f3f7a653d522ef71" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.1 the dynamic loading of libraries (DynaLoader, XSLoader) also seems to have become broken in in SunOS 4.x. Therefore the default is to build Perl statically.</source>
          <target state="translated">Perl 5.8.1以降、SunOS 4.xではライブラリ(DynaLoader,XSLoader)の動的ロード機能も壊れているようです。</target>
        </trans-unit>
        <trans-unit id="ef5cb6c37e267f59227533f0250c84c8718b7076" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.1, &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; also has the &lt;code&gt;utf8::is_utf8&lt;/code&gt; function.</source>
          <target state="translated">Perl 5.8.1以降、&lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;には &lt;code&gt;utf8::is_utf8&lt;/code&gt; 関数もあります。</target>
        </trans-unit>
        <trans-unit id="ab205322181f94cdf41d5eaaf572850bb63def33" translate="yes" xml:space="preserve">
          <source>As of Perl 5.9.5 there is a new interface for plugging and using regular expression engines other than the default one.</source>
          <target state="translated">Perl 5.9.5 では、デフォルトのもの以外の正規表現エンジンをプラグインしたり使用したりするための新しいインターフェイスが用意されています。</target>
        </trans-unit>
        <trans-unit id="02c3c3ae5c3a1698c2091dbb44ff1c48ff7a71dd" translate="yes" xml:space="preserve">
          <source>As of Perl Symbian port version 0.4.1 any part of Perl's standard regression test suite has not been run on a real Symbian device using the ported Perl, so innumerable bugs may lie in wait. Therefore there is absolutely no warranty.</source>
          <target state="translated">Perl Symbian 移植版バージョン 0.4.1 の時点では、Perl の標準的な回帰テストスイートのどの部分も、移植された Perl を使用して実際の Symbian デバイス上で実行されていないため、無数のバグが待ち受けているかもしれません。そのため、無数のバグが待ち受けているかもしれません。</target>
        </trans-unit>
        <trans-unit id="2a7301a461e47b0be61be125749323ecdfc5a92a" translate="yes" xml:space="preserve">
          <source>As of Perl v5.16.0, it is implemented by the &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; module. See &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; for more details on its behaviour.</source>
          <target state="translated">Perl v5.16.0以降では、&lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt;モジュールによって実装されます。参照してください&lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt;その動作の詳細については。</target>
        </trans-unit>
        <trans-unit id="9f7c19e511eae81348e03d06d3194e0d82d15184" translate="yes" xml:space="preserve">
          <source>As of R2.5 of USS for OS/390 and Version 2.3 of VM/ESA these Unix sub-systems do not support the &lt;code&gt;#!&lt;/code&gt; shebang trick for script invocation. Hence, on OS/390 and VM/ESA Perl scripts can be executed with a header similar to the following simple script:</source>
          <target state="translated">USS for OS / 390のR2.5およびVM / ESAのバージョン2.3以降、これらのUnixサブシステムは &lt;code&gt;#!&lt;/code&gt; をサポートしていません。スクリプト呼び出しのためのシバントリック。したがって、OS / 390およびVM / ESAのPerlスクリプトは、次の単純なスクリプトと同様のヘッダーを使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="4e29546f04e5cfe2122e46676161bb58e8a9f171" translate="yes" xml:space="preserve">
          <source>As of Unicode 6.0, this is always empty.</source>
          <target state="translated">Unicode 6.0 では、これは常に空です。</target>
        </trans-unit>
        <trans-unit id="6be62dadd6bbd6b8a9fe9bd5f460bd2ea3dfc014" translate="yes" xml:space="preserve">
          <source>As of VERSION 1.18 all IO::Socket objects have autoflush turned on by default. This was not the case with earlier releases.</source>
          <target state="translated">VERSION 1.18 では、すべての IO::Socket オブジェクトはデフォルトで自動フラッシュがオンになっています。これは以前のリリースではそうではありませんでした。</target>
        </trans-unit>
        <trans-unit id="9b18b6d1424b74e3d0360d9f0334585a766708d3" translate="yes" xml:space="preserve">
          <source>As of db-4.2.x it is no longer needed to do this by hand. Sleepycat has changed the configuration process to add +z on HP-UX automatically.</source>
          <target state="translated">db-4.2.xでは、この作業を手作業で行う必要がなくなりました。Sleepycatは、HP-UX上で自動的に+zを追加するように設定プロセスを変更しました。</target>
        </trans-unit>
        <trans-unit id="ddb5b154eee158ecabd0abbac4ff1eab5e92e45f" translate="yes" xml:space="preserve">
          <source>As of perl 5.14 it is possible to hook into the compile-time lexical scope mechanism using &lt;code&gt;Perl_blockhook_register&lt;/code&gt; . This is used like this:</source>
          <target state="translated">Perl 5.14以降では、 &lt;code&gt;Perl_blockhook_register&lt;/code&gt; を使用してコンパイル時の字句スコープメカニズムにフックすることが可能です。これは次のように使用されます：</target>
        </trans-unit>
        <trans-unit id="283446be77b5c5650a7aade52dfb5d3e56c4e299" translate="yes" xml:space="preserve">
          <source>As of perl 5.9.5 're' debug contains a number of utility functions that may be optionally exported into the caller's namespace. They are listed below.</source>
          <target state="translated">perl 5.9.5 以降、're' debug には、オプションで呼び出し元の名前空間にエクスポートできるユーティリティ関数が多数含まれています。それらを以下に示します。</target>
        </trans-unit>
        <trans-unit id="5916c6705e19aa4737c1eaecb1fdda26e7395e63" translate="yes" xml:space="preserve">
          <source>As of perl5.6, open() autovivifies file and directory handles as references if you pass it an uninitialized scalar variable. You can then pass these references just like any other scalar, and use them in the place of named handles.</source>
          <target state="translated">perl5.6では、初期化されていないスカラ変数を渡すと、 open()はファイルやディレクトリのハンドルを自動的に参照として認識します。そして、これらの参照を他のスカラと同じように渡して、名前付きハンドルの代わりに使うことができます。</target>
        </trans-unit>
        <trans-unit id="0d06e02fdc69f862d76b045e6be72fc487c78e0b" translate="yes" xml:space="preserve">
          <source>As of perl5.7.2 all tests pass under:</source>
          <target state="translated">perl5.7.2 の時点では、すべてのテストは以下の条件で合格しています。</target>
        </trans-unit>
        <trans-unit id="e7ebc726132cf88aa72c90598602d1b0ee48a664" translate="yes" xml:space="preserve">
          <source>As of perl5.8.1 there is at least one test still failing.</source>
          <target state="translated">perl5.8.1の時点では、少なくとも1つのテストがまだ失敗しています。</target>
        </trans-unit>
        <trans-unit id="1b82fd373dbd0883f99d276e806ca9d5f0a6e144" translate="yes" xml:space="preserve">
          <source>As of release 5 of Perl, assignment to &lt;code&gt;$[&lt;/code&gt; is treated as a compiler directive, and cannot influence the behavior of any other file. (That's why you can only assign compile-time constants to it.) Its use is highly discouraged.</source>
          <target state="translated">Perlのリリース5以降、 &lt;code&gt;$[&lt;/code&gt; への割り当てはコンパイラディレクティブとして扱われ、他のファイルの動作に影響を与えることはできません。（そのため、コンパイル時の定数のみを割り当てることができます。）その使用はお勧めしません。</target>
        </trans-unit>
        <trans-unit id="1e2bbc98f0506e501d121cbf3463e0bb77e718b4" translate="yes" xml:space="preserve">
          <source>As of release 5.003_01 perl is linked to multithreaded C RTL DLL. If perl itself is not compiled multithread-enabled, so will not be perl's malloc(). However, extensions may use multiple thread on their own risk.</source>
          <target state="translated">リリース5.003_01では、Perlはマルチスレッド化されたC RTL DLLにリンクされています。perl自体がマルチスレッド対応でコンパイルされていない場合は、perlのmalloc()は動作しません。ただし、拡張機能は自己責任でマルチスレッドを使用することがあります。</target>
        </trans-unit>
        <trans-unit id="5dbdb753a9581b45c8e16e8caa7ad1fc9cd73184" translate="yes" xml:space="preserve">
          <source>As of right now, this returns 2 if the path is absolute with a volume, 1 if it's absolute with no volume, 0 otherwise.</source>
          <target state="translated">現在のところ、これはパスがボリュームのある絶対パスであれば 2 を返し、ボリュームのない絶対パスであれば 1 を返し、そうでなければ 0 を返します。</target>
        </trans-unit>
        <trans-unit id="cedde28f0889c00006609cd1f4e0ab992b6b315c" translate="yes" xml:space="preserve">
          <source>As of the date of this document's last update, the following systems contain PA-RISC 2.0 chips:</source>
          <target state="translated">本ドキュメントの最終更新日現在、以下のシステムにはPA-RISC 2.0チップが搭載されています。</target>
        </trans-unit>
        <trans-unit id="361f300829fa013b44d60226e2c65866392ff21f" translate="yes" xml:space="preserve">
          <source>As of the date of this document, Perl is fully 64-bit compliant on HP-UX 11.00 and up for both cc- and gcc builds. If you are about to build a 64-bit perl with GNU gcc, please read the gcc section carefully.</source>
          <target state="translated">この文書の日付の時点で、Perl は HP-UX 11.00 以降では cc と gcc の両方のビルドで 64 ビットに完全に準拠しています。GNU gcc で 64 ビットの Perl をビルドしようとしている場合は、gcc のセクションを注意深く読んでください。</target>
        </trans-unit>
        <trans-unit id="6087654ae9665e2974920201f81ba084c4838564" translate="yes" xml:space="preserve">
          <source>As of the time this document was last revised, the following Perl functions were implemented in the VMS port of Perl (functions marked with * are discussed in more detail below):</source>
          <target state="translated">このドキュメントが最終改訂された時点で、PerlのVMSポートには以下のPerl関数が実装されています(※印の関数については、以下で詳しく説明します)。</target>
        </trans-unit>
        <trans-unit id="2f434753b82171852395258695f5260796bd3e54" translate="yes" xml:space="preserve">
          <source>As of v5.14, Perl distinguishes three subclasses of UTF‑8 warnings.</source>
          <target state="translated">v5.14では、PerlはUTF-8の警告を3つのサブクラスに区別しています。</target>
        </trans-unit>
        <trans-unit id="3687eac7ed0d3e9a3819b6d8b59ffbbce6f96ce7" translate="yes" xml:space="preserve">
          <source>As of v5.18.0, both keys and values stored in &lt;code&gt;%ENV&lt;/code&gt; are stringified.</source>
          <target state="translated">v5.18.0以降では、 &lt;code&gt;%ENV&lt;/code&gt; に格納されるキーと値の両方が文字列化されます。</target>
        </trans-unit>
        <trans-unit id="068ae70c04574cc37cc34db842b7ac8d0c145fb6" translate="yes" xml:space="preserve">
          <source>As of version 1.01 of the AutoSplit module it is possible to have multiple packages within a single file. Both of the following cases are supported:</source>
          <target state="translated">AutoSplitモジュールのバージョン1.01では、1つのファイル内に複数のパッケージを持つことができます。以下のケースの両方がサポートされています。</target>
        </trans-unit>
        <trans-unit id="4d09237d697a620472d98ca9564ba252e7440a3a" translate="yes" xml:space="preserve">
          <source>As of version 1.02 (provided with perl 5.12) the object provides &lt;code&gt;&quot;-X&quot;&lt;/code&gt; overloading, so you can call filetest operators (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and so on) on it. It also provides a &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method, called like</source>
          <target state="translated">バージョン1.02（perl 5.12に付属）では、オブジェクトは &lt;code&gt;&quot;-X&quot;&lt;/code&gt; オーバーロードを提供しているため、ファイルテスト演算子（ &lt;code&gt;-f&lt;/code&gt; 、 &lt;code&gt;-x&lt;/code&gt; など）を呼び出すことができます。 &lt;code&gt;-&amp;gt;cando&lt;/code&gt; メソッドも提供します。</target>
        </trans-unit>
        <trans-unit id="39c91a8aec6b3b91e09f6a8bd53c1515a32cc61b" translate="yes" xml:space="preserve">
          <source>As of version 1.04 (Perl 5.10), strict verifies that it is used as &quot;strict&quot; to avoid the dreaded Strict trap on case insensitive file systems.</source>
          <target state="translated">バージョン 1.04 (Perl 5.10)のように、strict は &quot;strict&quot; として使用されていることを検証し、大文字小文字を区別しないファイルシステム上の恐ろしい Strict トラップを回避します。</target>
        </trans-unit>
        <trans-unit id="5750d09d680a68ca093b8cb502caecf523fc46de" translate="yes" xml:space="preserve">
          <source>As of version 1.32 of this module, constants can be defined in packages other than the caller, by including the package name in the name of the constant:</source>
          <target state="translated">このモジュールのバージョン1.32では、定数の名前にパッケージ名を含めることで、呼び出し元以外のパッケージで定数を定義することができます。</target>
        </trans-unit>
        <trans-unit id="a9966baeb16dc71d9782450ad1960be303770497" translate="yes" xml:space="preserve">
          <source>As of version 1.47 the following additions were made to the install interface. Note that the new argument style and use of the %result hash is recommended.</source>
          <target state="translated">バージョン 1.47 では、インストール・インターフェースに以下の追加が行われました。新しい引数スタイルと %result ハッシュの使用が推奨されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e47319fd89f8639b4c6dc3d1dee645f4e3217716" translate="yes" xml:space="preserve">
          <source>As of version 2.12, &lt;code&gt;Encode&lt;/code&gt; supports coderef values for &lt;code&gt;CHECK&lt;/code&gt; ; see below.</source>
          <target state="translated">バージョン2.12以降、 &lt;code&gt;Encode&lt;/code&gt; は &lt;code&gt;CHECK&lt;/code&gt; の coderef値をサポートしています。下記参照。</target>
        </trans-unit>
        <trans-unit id="feaefe7da5a3f173789e3bc38d1cc052b48f0697" translate="yes" xml:space="preserve">
          <source>As of version 2.32 Getopt::Long provides auto-help, a quick and easy way to add the options --help and -? to your program, and handle them.</source>
          <target state="translated">バージョン 2.32 Getopt::Long では、自動ヘルプが提供されています。</target>
        </trans-unit>
        <trans-unit id="4961ac95a03fe72cd95305ebd10cd56767e6cd2e" translate="yes" xml:space="preserve">
          <source>As of version 5.00305, OS/2 perl binary distribution comes split into 11 components. Unfortunately, to enable configurable binary installation, the file paths in the zip files are not absolute, but relative to some directory.</source>
          <target state="translated">バージョン5.00305では、OS/2 perlのバイナリ配布は11のコンポーネントに分割されています。残念ながら、設定可能なバイナリのインストールを可能にするために、zipファイルのファイルパスは絶対パスではなく、どこかのディレクトリへの相対パスになっています。</target>
        </trans-unit>
        <trans-unit id="c5ef8d96f6d787f0f3cc3fb69a33144b75f432e6" translate="yes" xml:space="preserve">
          <source>As of version 5.12.0, perl has stopped using the underlying time library of the operating system it's running on and has its own implementation of those routines with a safe range of at least +/ 2**52 (about 142 million years).</source>
          <target state="translated">バージョン5.12.0では、perlは実行しているオペレーティングシステムの基礎となる時間ライブラリの使用をやめ、少なくとも+/-2**52(約1億4,200万年)の安全な範囲で、それらのルーチンの独自の実装を持っています。</target>
        </trans-unit>
        <trans-unit id="ede48005eab24777f4cf1c1c51404cc14a546bbe" translate="yes" xml:space="preserve">
          <source>As of writing (2010-09) only the</source>
          <target state="translated">執筆時点(2010-09)では</target>
        </trans-unit>
        <trans-unit id="53d68ae04ea90208ac09617d93481673c81dae0c" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;, in scalar context it should return the next line, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for no more data. In list context it should return all remaining lines, or an empty list for no more data. The strings returned should include the input record separator &lt;code&gt;$/&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;), unless it is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (which means &quot;slurp&quot; mode).</source>
          <target state="translated">あたりとして&lt;a href=&quot;functions/readline&quot;&gt;のreadline&lt;/a&gt;、スカラコンテキストでは、次の行を返す、または必要があります &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; をなし、より多くのデータのために。リストのコンテキストでは、残りのすべての行を返すか、データがない場合は空のリストを返します。返される文字列には、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （ &quot;slurp&quot;モードを意味する）でない限り、入力レコードセパレータ &lt;code&gt;$/&lt;/code&gt; （&lt;a href=&quot;perlvar&quot;&gt;perlvarを&lt;/a&gt;参照）を含める必要があります。</target>
        </trans-unit>
        <trans-unit id="35db6e6083bf8853a0d7a773700bfc53f4f3833e" translate="yes" xml:space="preserve">
          <source>As per get(), but returns a tied filehandle. Reading from this filehandle returns the requested message. The filehandle will return EOF at the end of the message and should not be reused.</source>
          <target state="translated">get()と同様ですが、紐付けられたファイルハンドルを返します。このファイルハンドルから読み込むと、要求されたメッセージが返されます。このファイルハンドルはメッセージの最後にEOFを返しますので、再利用してはいけません。</target>
        </trans-unit>
        <trans-unit id="f8d3cabb86865ec30b2f81b742c043bb4dfa0006" translate="yes" xml:space="preserve">
          <source>As perl does not use it, it is not well tested.</source>
          <target state="translated">perlは使っていないので、あまりテストされていません。</target>
        </trans-unit>
        <trans-unit id="04f2eace94f5ec9fb309f7ef275b1f53f5b18652" translate="yes" xml:space="preserve">
          <source>As pragmata are implemented as modules, like any other module, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; becomes</source>
          <target state="translated">プラグマは他のモジュールと同様にモジュールとして実装される &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; なる</target>
        </trans-unit>
        <trans-unit id="6ff69505257da499d009f94993a8c36d403bc517" translate="yes" xml:space="preserve">
          <source>As previously mentioned, the &quot;switch&quot; feature is considered highly experimental; it is subject to change with little notice. In particular, &lt;code&gt;when&lt;/code&gt; has tricky behaviours that are expected to change to become less tricky in the future. Do not rely upon its current (mis)implementation. Before Perl 5.18, &lt;code&gt;given&lt;/code&gt; also had tricky behaviours that you should still beware of if your code must run on older versions of Perl.</source>
          <target state="translated">前述のように、「スイッチ」機能は非常に実験的なものと見なされています。予告なく変更される場合があります。特に、将来的にトリッキーにならないように変化すると予想されるトリッキーな動作がある &lt;code&gt;when&lt;/code&gt; 。現在の（誤）実装に依存しないでください。 Perlの5.18の前に、 &lt;code&gt;given&lt;/code&gt; 、あなたのコードはPerlの古いバージョンの上で実行する必要がある場合、あなたはまだに注意すべきであるというトリッキーな行動を持っていました。</target>
        </trans-unit>
        <trans-unit id="d4ddd43c6028587c10020a05414bb6d70c1790ee" translate="yes" xml:space="preserve">
          <source>As previously noted, individual entries (as opposed to the whole hash) are settable. Perl only cares about Boolean true here, although the values used by</source>
          <target state="translated">前述のように、(ハッシュ全体ではなく)個々のエントリは設定可能です。Perlはここではブール値のtrueのみを気にしています。</target>
        </trans-unit>
        <trans-unit id="40863db850a5e2446412cc32d982d2e85c0c2a70" translate="yes" xml:space="preserve">
          <source>As setup, consider this (admittedly rather contrived) example of a tie; all it does is use a file to keep a log of the values assigned to a scalar.</source>
          <target state="translated">設定としては、タイの例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="d5e7901b05cd99e70f1eb4d22405e5ec5c43c73a" translate="yes" xml:space="preserve">
          <source>As shipped, the only command-line history supplied is a simplistic one that checks for leading exclamation points. However, if you install the Term::ReadKey and Term::ReadLine modules from CPAN (such as Term::ReadLine::Gnu, Term::ReadLine::Perl, ...) you will have full editing capabilities much like those GNU</source>
          <target state="translated">出荷時に提供されるコマンドライン履歴は、先頭の感嘆符がないかどうかをチェックする単純なものだけです。しかし、CPANからTerm::ReadKeyとTerm::ReadLineモジュール(Term::ReadLine::Gnu、Term::ReadLine::Perlなど)をインストールすると、これらのGNU</target>
        </trans-unit>
        <trans-unit id="3c7b29c9acaba84b5dfa9d94a08362e636c880e4" translate="yes" xml:space="preserve">
          <source>As shown above, Perl creates the backup file whether or not any output is actually changed. So this is just a fancy way to copy files:</source>
          <target state="translated">上記のように、Perl は出力が実際に変更されたかどうかに関わらず、バックアップファイルを作成します。つまり、これはファイルをコピーするための単なるファンシーな方法です。</target>
        </trans-unit>
        <trans-unit id="cf827d39576175b49dc1a1c39fee2ddfa72908f4" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">この例に示すように、 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; は「関数のように見える」ルールから除外されています。それに続く一対の括弧は、その引数を（必然的に）区切るものではありません。 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; と同等です。また、ほとんどの名前付き演算子とは異なり、これは代入と同じ優先順位を持っています。</target>
        </trans-unit>
        <trans-unit id="a246c967f8c44d960de455229b31b368ecdb7f4c" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">この例に示すように、 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; は「関数のように見える」ルールから除外されています。それに続く一対の括弧は、その引数を（必然的に）区切るものではありません。 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; と同等です。また、ほとんどの名前付き演算子とは異なり、これは代入と同じ優先順位を持っています。</target>
        </trans-unit>
        <trans-unit id="6d2e840402d6fc0f9fee1fa99ab3b3ed1f5042e9" translate="yes" xml:space="preserve">
          <source>As such, signals that would normally not be appropriate to use in the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; command (e.g., &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', $$)&lt;/code&gt; ) are okay to use with the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; method (again, as illustrated above).</source>
          <target state="translated">そのため、通常は &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; コマンドでの使用に適さないシグナル（たとえば、 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', $$)&lt;/code&gt; ）は、 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; メソッドで使用しても問題ありません（ここでも、上記のように）。 。</target>
        </trans-unit>
        <trans-unit id="a44ff5fd296684850a7eea8453ca8654e5ea2769" translate="yes" xml:space="preserve">
          <source>As system libraries (most notably glibc) are also triggering errors, valgrind allows to suppress such errors using suppression files. The default suppression file that comes with valgrind already catches a lot of them. Some additional suppressions are defined in</source>
          <target state="translated">システムライブラリ(特にglibc)もエラーを発生させるので,valgrindはサプレッションファイルを使ってそのようなエラーを抑制することができます.valgrindに付属しているデフォルトの抑制ファイルは,すでに多くのエラーを捕捉しています.いくつかのサプレッションは</target>
        </trans-unit>
        <trans-unit id="e1a99808d733ec0659b941748add22eaba940233" translate="yes" xml:space="preserve">
          <source>As that is multiple C statements it is quite common so see this idiom instead:</source>
          <target state="translated">これは複数のC文であるため、よくあることなので、代わりにこの慣用句を参照してください。</target>
        </trans-unit>
        <trans-unit id="ac882702a8c758004edc0489caa0c38829169f81" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;'IGNORE'&lt;/code&gt; hook is not supported by &lt;code&gt;__WARN__&lt;/code&gt; , you can disable warnings using the empty subroutine:</source>
          <target state="translated">&lt;code&gt;'IGNORE'&lt;/code&gt; フックがでサポートされていない &lt;code&gt;__WARN__&lt;/code&gt; 、あなたは空のサブルーチンを使用して警告を無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="481d1ba67f45c383e883a88846da2edc2a1775aa" translate="yes" xml:space="preserve">
          <source>As the Perl interpreter looks at signal flags only when it is about to execute a new opcode, a signal that arrives during a long-running opcode (e.g. a regular expression operation on a very large string) will not be seen until the current opcode completes.</source>
          <target state="translated">Perl インタプリタは、新しいオペコードを実行しようとしているときだけシグナルフラグを見るので、長い間実行されているオペコード(例えば、非常に大きな文字列に対する正規表現操作)の間に到着したシグナルは、現在のオペコードが完了するまで見ることができません。</target>
        </trans-unit>
        <trans-unit id="f849d9355eec2f51b5cef2814ee106c18c309122" translate="yes" xml:space="preserve">
          <source>As the PerlIO layer uses raw IO (bytes) internally, all this totally ignores things like the type of your filesystem (ASCII or EBCDIC).</source>
          <target state="translated">PerlIO レイヤーは内部的に raw IO (バイト)を使用しているので、ファイルシステムのタイプ (ASCII や EBCDIC)などは完全に無視されます。</target>
        </trans-unit>
        <trans-unit id="ef5f3ccf5711fff6ab130d18e6106225adf61f56" translate="yes" xml:space="preserve">
          <source>As the PerlIO layer uses raw IO internally, all this totally ignores the type of your filesystem (ASCII or EBCDIC) and the IO_CONVERSION environment variable. If you want to get the old behavior, that the BS2000 IO functions determine conversion depending on the filesystem PerlIO still is your friend. You use IO_CONVERSION as usual and tell Perl, that it should use the native IO layer:</source>
          <target state="translated">PerlIO レイヤーは内部的に raw IO を使用しているので、ファイルシステムのタイプ(ASCII または EBCDIC)と IO_CONVERSION 環境変数を完全に無視しています。BS2000 の IO 関数がファイルシステムに応じて変換を決定するという古い動作を得たい場合、PerlIO はまだあなたの友人です。いつものように IO_CONVERSION を使用して、Perl にネイティブ IO レイヤーを使用するように指示します。</target>
        </trans-unit>
        <trans-unit id="20b8fc20101f3d438a32270dc2621c0dd14971b3" translate="yes" xml:space="preserve">
          <source>As the comment says, this is not a good way to implement accessors. It's slow and too clever by far. However, you may see this as a way to provide accessors in older Perl code. See &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for recommendations on OO coding in Perl.</source>
          <target state="translated">コメントが言うように、これはアクセサを実装する良い方法ではありません。それは遅くて断然賢すぎる。ただし、これを古いPerlコードでアクセサーを提供する方法と見なす場合があります。PerlでのOOコーディングに関する推奨事項については、&lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4fca5f01eab824b22bb6b1905a8d483f37ad2ed6" translate="yes" xml:space="preserve">
          <source>As the example shows, if the second argument is an empty string, the category's locale is returned to the default specified by the corresponding environment variables. Generally, this results in a return to the default that was in force when Perl started up: changes to the environment made by the application after startup may or may not be noticed, depending on your system's C library.</source>
          <target state="translated">例に示すように、第二引数が空文字列の場合、カテゴリのロケールは対応する環境変数で指定されたデフォルトに戻されます。一般的に、これはPerlが起動したときのデフォルトに戻る結果となります。</target>
        </trans-unit>
        <trans-unit id="0a3da7dd18a3b2da7c7f36441b50e2eab858828a" translate="yes" xml:space="preserve">
          <source>As the final two examples above show, you can achieve portablity to non-ASCII platforms by using the &lt;code&gt;\N{...}&lt;/code&gt; form for the range endpoints. These indicate that the specified range is to be interpreted using Unicode values, so &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; means to match &lt;code&gt;\N{U+27}&lt;/code&gt; , &lt;code&gt;\N{U+28}&lt;/code&gt; , &lt;code&gt;\N{U+29}&lt;/code&gt; , ..., &lt;code&gt;\N{U+3D}&lt;/code&gt; , &lt;code&gt;\N{U+3E}&lt;/code&gt; , and &lt;code&gt;\N{U+3F}&lt;/code&gt; , whatever the native code point versions for those are. These are called &quot;Unicode&quot; ranges. If either end is of the &lt;code&gt;\N{...}&lt;/code&gt; form, the range is considered Unicode. A &lt;code&gt;regexp&lt;/code&gt; warning is raised under &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; if the other endpoint is specified non-portably:</source>
          <target state="translated">上記の最後の2つの例が示すように、範囲のエンドポイントに &lt;code&gt;\N{...}&lt;/code&gt; フォームを使用すると、非ASCIIプラットフォームへの移植性を実現できます。これらは、指定された範囲がUnicode値を使用して解釈されることを示しているため、 &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; は &lt;code&gt;\N{U+27}&lt;/code&gt; 、 &lt;code&gt;\N{U+28}&lt;/code&gt; と一致することを意味します、 &lt;code&gt;\N{U+29}&lt;/code&gt; 、...、 &lt;code&gt;\N{U+3D}&lt;/code&gt; 、 &lt;code&gt;\N{U+3E}&lt;/code&gt; 、および &lt;code&gt;\N{U+3F}&lt;/code&gt; 、それらのネイティブコードポイントバージョンが何であれ。これらは「Unicode」範囲と呼ばれます。どちらかの端が &lt;code&gt;\N{...}&lt;/code&gt; 形式の場合、範囲はUnicodeと見なされます。 &lt;code&gt;regexp&lt;/code&gt; 警告がで飼育され &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; 他のエンドポイントが移植できないように指定されている場合：</target>
        </trans-unit>
        <trans-unit id="17c70cf277254845a8ce88c971a047564a105d87" translate="yes" xml:space="preserve">
          <source>As the last character of a prototype, or just before a semicolon, a &lt;code&gt;@&lt;/code&gt; or a &lt;code&gt;%&lt;/code&gt; , you can use &lt;code&gt;_&lt;/code&gt; in place of &lt;code&gt;$&lt;/code&gt; : if this argument is not provided, &lt;code&gt;$_&lt;/code&gt; will be used instead.</source>
          <target state="translated">プロトタイプの最後の文字として、あるいは単にセミコロン、前に &lt;code&gt;@&lt;/code&gt; または &lt;code&gt;%&lt;/code&gt; は、使用することができます &lt;code&gt;_&lt;/code&gt; の代わりに &lt;code&gt;$&lt;/code&gt; ：この引数が提供されていない場合は、 &lt;code&gt;$_&lt;/code&gt; 代わりに使用されます。</target>
        </trans-unit>
        <trans-unit id="4b123b1845e08fc58170e4c4c4ab5952b56ae816" translate="yes" xml:space="preserve">
          <source>As the last example indicates, a handler may be set up to be (re)called in two or more phases. The phase name is passed as the handler's final argument.</source>
          <target state="translated">最後の例が示すように、ハンドラは2つ以上のフェーズで(再)呼ばれるように設定することができます。フェーズ名はハンドラの最終引数として渡されます。</target>
        </trans-unit>
        <trans-unit id="776d16ae4f440b015655f81050641c0ec6c3a0f2" translate="yes" xml:space="preserve">
          <source>As the parser reads the second and subsequent lines from the source stream, it feeds those lines through the &lt;code&gt;cpp&lt;/code&gt; source filter before processing them. The &lt;code&gt;cpp&lt;/code&gt; filter simply passes each line through the real C preprocessor. The output from the C preprocessor is then inserted back into the source stream by the filter.</source>
          <target state="translated">パーサーは2番目以降の行をソースストリームから読み取ると、それらの行を &lt;code&gt;cpp&lt;/code&gt; ソースフィルターに通してから処理します。 &lt;code&gt;cpp&lt;/code&gt; フィルタは、単に実際のCプリプロセッサを介して各ラインを通過します。Cプリプロセッサーからの出力は、フィルターによってソースストリームに挿入されます。</target>
        </trans-unit>
        <trans-unit id="b29477c3662cd388380e5f2f7edde392d4aa47d3" translate="yes" xml:space="preserve">
          <source>As the parser understands a Perl program, it builds up a tree of operations for the interpreter to perform during execution. The routines which construct and link together the various operations are to be found in</source>
          <target state="translated">パーサが Perl プログラムを理解すると、インタープリタが実行中に実行する操作のツリーを構築します。様々な操作を構築してリンクするルーチンは</target>
        </trans-unit>
        <trans-unit id="059620d29d96cd6f5eb8cd327a9137c1f47169b5" translate="yes" xml:space="preserve">
          <source>As there are various Make programs with incompatible syntax, which use operating system shells, again with incompatible syntax, it is important for users of this module to know which flavour of Make a Makefile has been written for so they'll use the correct one and won't have to face the possibly bewildering errors resulting from using the wrong one.</source>
          <target state="translated">互換性のない構文を持つ様々な Make プログラムが存在し、オペレーティングシステムシェルを使用していますが、これもまた互換性のない構文を持っています。</target>
        </trans-unit>
        <trans-unit id="036fd1e2507560ce47135587c83032ff17f1287e" translate="yes" xml:space="preserve">
          <source>As there is an overlap between the error numbers used by</source>
          <target state="translated">が使用しているエラー番号が重複しているため</target>
        </trans-unit>
        <trans-unit id="c2c40011ac031fbcf62ae0096c0f70fe3f04f6d4" translate="yes" xml:space="preserve">
          <source>As told above, Perl 5.6.1 was still good in AmigaOS, as was 5.7.2. After Perl 5.7.2 (change #11423, see the Changes file, and the file pod/perlhack.pod for how to get the individual changes) Perl dropped its internal support for vfork(), and that was very probably the step that broke AmigaOS (since the ixemul library has only vfork). The build finally fails when the ext/DynaLoader is being built, and PERL ends up as &quot;0&quot; in the produced Makefile, trying to run &quot;0&quot; does not quite work. Also, executing miniperl in backticks seems to generate nothing: very probably related to the (v)fork problems. &lt;b&gt;Fixing the breakage requires someone quite familiar with the ixemul library, and how one is supposed to run external commands in AmigaOS without fork().&lt;/b&gt;</source>
          <target state="translated">上記のように、Perl 5.6.1は5.7.2と同様、AmigaOSでも優れています。 Perl 5.7.2以降（変更＃11423、変更ファイル、および個々の変更を取得する方法についてはファイルpod / perlhack.podを参照）Perlはvfork（）の内部サポートを削除しました。 AmigaOS（ixemulライブラリにはvforkしかないため）。 ext / DynaLoaderのビルド中にビルドが最終的に失敗し、生成されたMakefileでPERLが「0」になるため、「0」を実行しようとしてもうまくいきません。また、バッククォートでminiperlを実行しても何も生成されないようです。おそらく（v）フォークの問題に関連していると考えられます。&lt;b&gt;破損を修正するには、ixemulライブラリに精通している人と、AmigaOSでfork（）を使用せずに外部コマンドを実行する方法を知っている人が必要です。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7df201bc839d821d3a7ec829e521380838b10cef" translate="yes" xml:space="preserve">
          <source>As usual, &lt;code&gt;PL_restartop&lt;/code&gt; is extracted from the &lt;code&gt;CxEVAL&lt;/code&gt; , and a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; done, which pops the C stack back to the docatch:</source>
          <target state="translated">通常通り、 &lt;code&gt;PL_restartop&lt;/code&gt; がから抽出され &lt;code&gt;CxEVAL&lt;/code&gt; 、及び &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; が行われ、docatchにCスタックバックをポップました。</target>
        </trans-unit>
        <trans-unit id="43f8dfff8ebd277fcb05688b6c5164a9ecb709ab" translate="yes" xml:space="preserve">
          <source>As usual, run</source>
          <target state="translated">いつものように走る</target>
        </trans-unit>
        <trans-unit id="6a12281792622fa54248b5b0512161ae986d73ec" translate="yes" xml:space="preserve">
          <source>As we have seen above, Principle 0 overrides the others. The regexp will be matched as early as possible, with the other principles determining how the regexp matches at that earliest character position.</source>
          <target state="translated">上で見たように、原則 0 が他の原則に優先します。正規表現は可能な限り早い段階でマッチし、他の原則はその最も早い文字位置での正規表現のマッチ方法を決定します。</target>
        </trans-unit>
        <trans-unit id="f24d0557480129d0bec98f1d07b3bc35225e11b2" translate="yes" xml:space="preserve">
          <source>As we mentioned before, Perl's built-in OO system is very minimal, but also quite flexible. Over the years, many people have developed systems which build on top of Perl's built-in system to provide more features and convenience.</source>
          <target state="translated">前に述べたように、Perl の組み込み OO システムは非常に最小限のものですが、非常に柔軟性に富んでいます。長年にわたり、多くの人がPerlの組み込みシステムの上に構築されたシステムを開発し、より多くの機能や利便性を提供してきました。</target>
        </trans-unit>
        <trans-unit id="09f78df2a986a05b74a05b4840bd77f0745f303d" translate="yes" xml:space="preserve">
          <source>As we mentioned before, roles provide an alternative to inheritance, but Perl does not have any built-in role support. If you choose to use Moose, it comes with a full-fledged role implementation. However, if you use one of our other recommended OO modules, you can still use roles with &lt;a href=&quot;http://search.cpan.org/perldoc/Role::Tiny&quot;&gt;Role::Tiny&lt;/a&gt;</source>
          <target state="translated">前に述べたように、ロールは継承の代わりを提供しますが、Perlにはロールサポートが組み込まれていません。Mooseの使用を選択した場合、Mooseには本格的なロール実装が付属しています。ただし、他の推奨されるOOモジュールのいずれかを使用している場合でも、&lt;a href=&quot;http://search.cpan.org/perldoc/Role::Tiny&quot;&gt;Role :: Tiny&lt;/a&gt;でロールを使用できます。</target>
        </trans-unit>
        <trans-unit id="6f8a13dd0293aebd2b1466f31d349be90b2e062e" translate="yes" xml:space="preserve">
          <source>As we mentioned earlier, Perl provides no special constructor syntax. This means that a class must implement its own constructor. A constructor is simply a class method that returns a reference to a new object.</source>
          <target state="translated">先に述べたように、Perlには特別なコンストラクタ構文はありません。つまり、クラスは独自のコンストラクタを実装しなければなりません。コンストラクタは、単に新しいオブジェクトへの参照を返すクラスメソッドです。</target>
        </trans-unit>
        <trans-unit id="34cb600e9a3f6e5e075e857de4110b1ef2b3324a" translate="yes" xml:space="preserve">
          <source>As we return an empty list, everything is fine.</source>
          <target state="translated">空のリストを返しているので、すべて問題ありません。</target>
        </trans-unit>
        <trans-unit id="1bc0081962e83c9753eb5550755ad42af088433e" translate="yes" xml:space="preserve">
          <source>As we said before, Perl's minimal OO system has led to a profusion of OO systems on CPAN. While you can still drop down to the bare metal and write your classes by hand, there's really no reason to do that with modern Perl.</source>
          <target state="translated">前にも言ったように、Perl の最小限の OO システムは、CPAN 上での OO システムの氾濫につながっています。素のままでクラスを手書きで書くこともできますが、現代のPerlではそうする理由がありません。</target>
        </trans-unit>
        <trans-unit id="7867c988c2c06b2c05fdddd86e23a3f47b3a2862" translate="yes" xml:space="preserve">
          <source>As we said earlier, most Perl objects are hashes, but an object can be an instance of any Perl data type (scalar, array, etc.). Turning a plain data structure into an object is done by &lt;b&gt;blessing&lt;/b&gt; that data structure using Perl's &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">前に述べたように、ほとんどのPerlオブジェクトはハッシュですが、オブジェクトは任意のPerlデータ型（スカラー、配列など）のインスタンスにすることができます。オブジェクトに無地のデータ構造を回しすることによって行われる&lt;b&gt;祝福&lt;/b&gt;のデータ構造は、Perlの使用していることを &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 機能を。</target>
        </trans-unit>
        <trans-unit id="504d4df94aa612d7624624e4944523fc3497d648" translate="yes" xml:space="preserve">
          <source>As we saw earlier, an object is simply a data structure that has been blessed into a class via the &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function. The &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function can take either one or two arguments:</source>
          <target state="translated">前に見たように、オブジェクトは単に &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 関数を介してクラスにblessされたデータ構造です。 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; の機能が1つまたは2つの引数を取ることができます。</target>
        </trans-unit>
        <trans-unit id="a1d3a4a5afeb3f9e63b11e0b6c656dbcfa8f18b8" translate="yes" xml:space="preserve">
          <source>As we've already shown, &lt;code&gt;call_sv&lt;/code&gt; can be used to invoke an anonymous subroutine. However, our example showed a Perl script invoking an XSUB to perform this operation. Let's see how it can be done inside our C code:</source>
          <target state="translated">すでに示したように、 &lt;code&gt;call_sv&lt;/code&gt; を使用して無名サブルーチンを呼び出すことができます。ただし、この例では、この操作を実行するためにXSUBを呼び出すPerlスクリプトを示しました。Cコード内でどのように実行できるかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="96d58f32e93788e5dbef34c03d0df80dbd089dab" translate="yes" xml:space="preserve">
          <source>As well as accessing Berkeley DB using a tied hash or array, it is also possible to make direct use of most of the API functions defined in the Berkeley DB documentation.</source>
          <target state="translated">紐付きハッシュや配列を使ってBerkeley DBにアクセスするだけでなく、Berkeley DBのドキュメントで定義されているほとんどのAPI関数を直接利用することも可能です。</target>
        </trans-unit>
        <trans-unit id="749b97b56149a492eb18a4cb65f04d306a596132" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the hash (like hv_clear()), this also frees any auxiliary data and storage associated with the hash.</source>
          <target state="translated">(hv_clear()のように)ハッシュのすべての要素を解放するだけでなく、ハッシュに関連する補助的なデータやストレージも解放します。</target>
        </trans-unit>
        <trans-unit id="2e0710bbe12c8de0ee3e47fce586245cf49652f2" translate="yes" xml:space="preserve">
          <source>As well as grouping, parentheses serve a second purpose. They can be used to capture the results of parts of the regexp match for later use. The results end up in &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; and so on.</source>
          <target state="translated">グループ化と同様に、括弧は2番目の目的を果たします。これらは、後で使用するために正規表現一致の一部の結果をキャプチャするために使用できます。結果は &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; などになります。</target>
        </trans-unit>
        <trans-unit id="7365f5053276b5ccb78d102d8d65d8a7cbb5a47c" translate="yes" xml:space="preserve">
          <source>As well as these two, there is another converter:</source>
          <target state="translated">この2つと同様に、もう1つのコンバーターがあります。</target>
        </trans-unit>
        <trans-unit id="5f09c013a494b22fb2c5704b9b33f8690cdb78ae" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairfirst&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">要素をリストするために &lt;code&gt;$_&lt;/code&gt; をエイリアスする &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; と同様に、 &lt;code&gt;pairfirst&lt;/code&gt; エイリアス &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; を指定されたリストの要素にエイリアスします。コードブロックによる変更は、呼び出し元に表示されます。</target>
        </trans-unit>
        <trans-unit id="6ccb264713980d688f5b35e3f78e5d8bcc1b34f2" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairgrep&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">同様に &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; のエイリアシング &lt;code&gt;$_&lt;/code&gt; リスト要素に &lt;code&gt;pairgrep&lt;/code&gt; エイリアス &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; 与えられたリストの要素に。コードブロックによる変更は、呼び出し元に表示されます。</target>
        </trans-unit>
        <trans-unit id="0e0ea04c8e6030abec75f8b13970784d2a0b7c8f" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairmap&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">同様に &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; エイリアシング &lt;code&gt;$_&lt;/code&gt; リスト要素に &lt;code&gt;pairmap&lt;/code&gt; エイリアス &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; 与えられたリストの要素に。コードブロックによる変更は、呼び出し元に表示されます。</target>
        </trans-unit>
        <trans-unit id="852273f60001fb5cfcfc3f59c366b8a418d217ac" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;gzerror()&lt;/code&gt; it returns an error number in numeric context and an error message in string context. Unlike &lt;code&gt;gzerror()&lt;/code&gt; though, the error message will correspond to the</source>
          <target state="translated">&lt;code&gt;gzerror()&lt;/code&gt; と同様に、数値コンテキストではエラー番号を返し、文字列コンテキストではエラーメッセージを返します。ただし、 &lt;code&gt;gzerror()&lt;/code&gt; とは異なり、エラーメッセージは</target>
        </trans-unit>
        <trans-unit id="89fce7a719c0828fb9010451c52ebed3b12f2d8d" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;mro::get_linear_isa&lt;/code&gt; above, &lt;code&gt;UNIVERSAL&lt;/code&gt; is special. &lt;code&gt;UNIVERSAL&lt;/code&gt; (and parents') isarev lists do not include every class in existence, even though all classes are effectively descendants for method inheritance purposes.</source>
          <target state="translated">同じように &lt;code&gt;mro::get_linear_isa&lt;/code&gt; 以上、 &lt;code&gt;UNIVERSAL&lt;/code&gt; は特別です。 &lt;code&gt;UNIVERSAL&lt;/code&gt; （および親の）isarevリストには、すべてのクラスがメソッド継承のために事実上子孫であるとしても、存在するすべてのクラスが含まれているわけではありません。</target>
        </trans-unit>
        <trans-unit id="1bfc8628cde1b50356023884cf039103db9706d2" translate="yes" xml:space="preserve">
          <source>As with G_SCALAR, this flag has 2 effects:</source>
          <target state="translated">G_SCALARと同様に、このフラグには2つの効果があります。</target>
        </trans-unit>
        <trans-unit id="56fcac1f27b0d72bf38ecab8e2bf923c1135ad6d" translate="yes" xml:space="preserve">
          <source>As with GetOptionsFromArray, a first argument hash reference now becomes the second argument.</source>
          <target state="translated">GetOptionsFromArrayと同様に、第1引数のハッシュ参照が第2引数になります。</target>
        </trans-unit>
        <trans-unit id="f5b2adb567968a40150b99a2b38e37687da34625" translate="yes" xml:space="preserve">
          <source>As with all &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; directives, defining a constant happens at compile time. Thus, it's probably not correct to put a constant declaration inside of a conditional statement (like &lt;code&gt;if ($foo)
{ &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant ... }&lt;/code&gt; ).</source>
          <target state="translated">すべての &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ディレクティブと同様に、定数の定義はコンパイル時に行われます。したがって、条件付きステートメント内に定数宣言を置くことはおそらく正しくありません（ &lt;code&gt;if ($foo) { &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant ... }&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a9e166bc9c2d17d86e12b7d5456a5dc29e6460a0" translate="yes" xml:space="preserve">
          <source>As with all compiler backend options, these must follow directly after the '-MO=Deparse', separated by a comma but not any white space.</source>
          <target state="translated">すべてのコンパイラバックエンドオプションと同様に、これらのオプションは '-MO=Deparse' の直後に続き、カンマで区切られていなければなりませんが、空白はありません。</target>
        </trans-unit>
        <trans-unit id="dec6818f5ac3b2a14f0cdaa20965c7cdeed80414" translate="yes" xml:space="preserve">
          <source>As with all standard commands, a single-character switch may be clustered with the following switch, if any.</source>
          <target state="translated">すべての標準コマンドと同様に、1文字のスイッチは、次のスイッチがあればクラスタ化することができます。</target>
        </trans-unit>
        <trans-unit id="3f95467f687ea8e2cde45cd2aae56d762c10d52a" translate="yes" xml:space="preserve">
          <source>As with all things in Perl,</source>
          <target state="translated">Perlのすべてのものと同様に。</target>
        </trans-unit>
        <trans-unit id="d4bf4ba0005710853f921b26431dc8a4fd4165e9" translate="yes" xml:space="preserve">
          <source>As with any advisory locking scheme, the protection only works if you systematically use &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_retrieve&lt;/code&gt; . If one side of your application uses &lt;code&gt;store&lt;/code&gt; whilst the other uses &lt;code&gt;lock_retrieve&lt;/code&gt; , you will get no protection at all.</source>
          <target state="translated">他の &lt;code&gt;lock_store&lt;/code&gt; ロックスキームと同様に、保護は、lock_storeおよび &lt;code&gt;lock_retrieve&lt;/code&gt; を体系的に使用する場合にのみ機能します。アプリケーションの一方が &lt;code&gt;store&lt;/code&gt; を使用し、もう一方が &lt;code&gt;lock_retrieve&lt;/code&gt; を使用する場合、保護はまったく得られません。</target>
        </trans-unit>
        <trans-unit id="dfdecc72a46325c982361e944a60a5cc48397fb3" translate="yes" xml:space="preserve">
          <source>As with constructors, Perl provides no special accessor declaration syntax, so classes must provide explicitly written accessor methods. There are two common types of accessors, read-only and read-write.</source>
          <target state="translated">コンストラクタと同様に、Perl は特別なアクセサ宣言構文を提供しないので、クラスは明示的に書かれたアクセサメソッドを提供しなければなりません。アクセサには、読み込み専用と書き込み専用の2つの共通のタイプがあります。</target>
        </trans-unit>
        <trans-unit id="5d06ccd4ce0505718d0adf18033c22a5ca1bc63e" translate="yes" xml:space="preserve">
          <source>As with many unix ports, this one depends on a few &quot;standard&quot; unix utilities which are not necessarily standard for QNX4.</source>
          <target state="translated">多くの unix ポートと同様に、このポートは、QNX4 の標準とは限らないいくつかの「標準的な」unix ユーティリティに依存しています。</target>
        </trans-unit>
        <trans-unit id="522d69b5bf4a752ac2eed134a3a3d90b973940bc" translate="yes" xml:space="preserve">
          <source>As with normal Perl arrays, a RECNO array can be accessed using negative indexes. The index -1 refers to the last element of the array, -2 the second last, and so on. Attempting to access an element before the start of the array will raise a fatal run-time error.</source>
          <target state="translated">通常のPerl配列と同様に、RECNO配列は負のインデックスを使用してアクセスすることができます。インデックス -1 は配列の最後の要素を参照し、-2 は最後の 2 番目の要素を参照します。配列の開始前の要素にアクセスしようとすると、致命的なランタイムエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="4f5b532a80f5e05a1cc6284ddbfce49edaec9bba" translate="yes" xml:space="preserve">
          <source>As with postfix array, postfix value slice dereferencing</source>
          <target state="translated">postfix 配列と同様に、postfix の値のスライスを参照します。</target>
        </trans-unit>
        <trans-unit id="5f2a0ee0b6d450a60b564dbded3394cc767489a2" translate="yes" xml:space="preserve">
          <source>As with subroutines, the type of value returned from a thread's entry point function may be determined by the thread's</source>
          <target state="translated">サブルーチンと同様に、スレッドのエントリポイント関数から返される値の型は、スレッドの</target>
        </trans-unit>
        <trans-unit id="b1cab3e1a5ac11251ae5d77c854023eac88d9ffb" translate="yes" xml:space="preserve">
          <source>As with the</source>
          <target state="translated">と同様に</target>
        </trans-unit>
        <trans-unit id="cd7300c50635cef829928b369e4af967b57015fd" translate="yes" xml:space="preserve">
          <source>As with the DB_HASH format, it is possible to provide a user defined Perl routine to perform the comparison of keys. By default, though, the keys are stored in lexical order.</source>
          <target state="translated">DB_HASH 形式と同様に、キーの比較を実行するためにユーザ定義の Perl ルーチンを提供することができます。しかし、デフォルトでは、キーは語彙順に格納されます。</target>
        </trans-unit>
        <trans-unit id="69ca9bf5a86e0011eab25710aa599ffe7224ff94" translate="yes" xml:space="preserve">
          <source>As with the append mode, when you open a file in write-only mode, you can now write to that filehandle using any of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">追加モードと同様に、ファイルを書き込み専用モードで開くと、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; のいずれかを使用して、そのファイルハンドルに書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="2a73b99d56aa400ec87ca02454010bfda953deea" translate="yes" xml:space="preserve">
          <source>As with the match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; operator, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; can use other delimiters, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt;, and even &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt;. If single quotes are used &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt;, then the regexp and replacement are treated as single-quoted strings and there are no variable substitutions. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; in list context returns the same thing as in scalar context, i.e., the number of matches.</source>
          <target state="translated">match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 演算子と同様に、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; などの他の区切り文字を使用できます!!! および &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt; 、さらには &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt; 。単一引用符が &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; で使用されている場合、正規表現と置換は単一引用符付きの文字列として扱われ、変数の置換はありません。リストコンテキスト &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; は、スカラーコンテキストと同じもの、つまり一致の数を返します。</target>
        </trans-unit>
        <trans-unit id="9cd8fd98a0003315162b3999969a156676702a25" translate="yes" xml:space="preserve">
          <source>As with the matching operator, the regexp quote can use different delimiters, e.g., &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr!!&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr{}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr~~&lt;/a&gt;&lt;/code&gt;. Apostrophes as delimiters (&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr''&lt;/a&gt;&lt;/code&gt;) inhibit any interpolation.</source>
          <target state="translated">一致する演算子と同様に、正規表現の引用符は &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr!!&lt;/a&gt;&lt;/code&gt; 異なる区切り文字を使用できます。、 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr{}&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr~~&lt;/a&gt;&lt;/code&gt; 。区切り文字としてのアポストロフィ（ &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr''&lt;/a&gt;&lt;/code&gt; ）は、補間を禁止します。</target>
        </trans-unit>
        <trans-unit id="e11bb01f2bd8c076a80300f6980985d85bb41c1a" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens. It may be appropriate to &quot;auto CLOSE&quot; when this occurs. See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.</source>
          <target state="translated">他のタイプのタイと同様に、このメソッドは &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; が発生したときに呼び出されます。これが発生した場合は、「自動クローズ」が適切な場合があります。以下&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;のuntie Gotchaを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4d1c8cd71dac7105bd6440effb2807ea501bbea1" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when the tied handle is about to be destroyed. This is useful for debugging and possibly cleaning up.</source>
          <target state="translated">他のタイプのタイと同様に、このメソッドはタイドハンドルが破棄されようとしているときに呼び出されます。これは、デバッグや場合によってはクリーンアップに便利です。</target>
        </trans-unit>
        <trans-unit id="c8628e08c07475c8f2b1e6b9f5f0e7ba611079bf" translate="yes" xml:space="preserve">
          <source>As with the return stack, it would be possible (and a small performance win) to pre-extend the return array before pushing data into it, since we know how many elements we will return:</source>
          <target state="translated">リターンスタックの場合と同様に、データを押し込む前にリターン配列を事前に拡張することが可能です (そして、小さなパフォーマンスの向上につながります)。</target>
        </trans-unit>
        <trans-unit id="3d4c99ea11e7c5fcd5dc736377914de3be4bac49" translate="yes" xml:space="preserve">
          <source>As with the shell, in Perl the &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; is used to open the file in read-only mode. If it succeeds, Perl allocates a brand new filehandle for you and fills in your previously undefined &lt;code&gt;$handle&lt;/code&gt; argument with a reference to that handle.</source>
          <target state="translated">シェルと同様に、Perlでは &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; を使用してファイルを読み取り専用モードで開きます。成功した場合、Perlは新しいファイルハンドルを割り当て、以前に未定義の &lt;code&gt;$handle&lt;/code&gt; 引数にそのハンドルへの参照を設定します。</target>
        </trans-unit>
        <trans-unit id="7fd1e1a58893cf268ad48b11d78449c12dc31c5c" translate="yes" xml:space="preserve">
          <source>As you can see 3 records have been successfully created with key &lt;code&gt;Wall&lt;/code&gt; - the only thing is, when they are retrieved from the database they</source>
          <target state="translated">ご覧のとおり、3つのレコードがキー &lt;code&gt;Wall&lt;/code&gt; で正常に作成されました。唯一のことは、データベースから取得されたときに、</target>
        </trans-unit>
        <trans-unit id="07a24c035647250238dd385e01e0859319d79ee5" translate="yes" xml:space="preserve">
          <source>As you can see both modules have a broadly similar structure. They both make use of the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module and both have an &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method. The difference between them is that the</source>
          <target state="translated">ご覧のとおり、両方のモジュールの構造はおおまかに似ています。どちらも &lt;code&gt;Filter::Util::Call&lt;/code&gt; モジュールを使用しており、どちらにも &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; メソッドがあります。それらの違いは、</target>
        </trans-unit>
        <trans-unit id="8f994dc63d7341f367ad1cc1ffc63c6ff1af1973" translate="yes" xml:space="preserve">
          <source>As you can see in the synopsis, based on your template, the arguments provided will be validated.</source>
          <target state="translated">概要を見ればわかるように、テンプレートに基づいて、提供された引数が検証されます。</target>
        </trans-unit>
        <trans-unit id="fc43df7357cab99ebecef48bb020a483deb5469e" translate="yes" xml:space="preserve">
          <source>As you can see,</source>
          <target state="translated">ご覧の通りです。</target>
        </trans-unit>
        <trans-unit id="ba5fcb84fa73471a91e0f59090740d9676a886a8" translate="yes" xml:space="preserve">
          <source>As you can see, a new stream has been created for reading the source from &lt;code&gt;Fred.pm&lt;/code&gt; . This stream will remain active until all of &lt;code&gt;Fred.pm&lt;/code&gt; has been parsed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; will still exist, but is inactive. Once the parser has finished reading Fred.pm, the source stream associated with it will be destroyed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; then becomes active again and the parser reads line 4 and subsequent lines from &lt;code&gt;cpp_test&lt;/code&gt; .</source>
          <target state="translated">ご覧のとおり、 &lt;code&gt;Fred.pm&lt;/code&gt; からソースを読み取るための新しいストリームが作成されています。このストリームは、 &lt;code&gt;Fred.pm&lt;/code&gt; がすべて解析されるまでアクティブのままです。 &lt;code&gt;cpp_test&lt;/code&gt; のソースストリームは引き続き存在しますが、非アクティブです。パーサーがFred.pmの読み取りを完了すると、それに関連付けられているソースストリームが破棄されます。その後、 &lt;code&gt;cpp_test&lt;/code&gt; のソースストリームが再びアクティブになり、パーサーが4行目以降を &lt;code&gt;cpp_test&lt;/code&gt; から読み取ります。</target>
        </trans-unit>
        <trans-unit id="413492c2aba459a109ff8cf8bd650d35b867bf30" translate="yes" xml:space="preserve">
          <source>As you can see, even though we parsed out a branch and a piece, it was ultimately only an atom. The final program shows us how things work. We have an &lt;code&gt;EXACT&lt;/code&gt; regop, followed by an &lt;code&gt;END&lt;/code&gt; regop. The number in parens indicates where the &lt;code&gt;regnext&lt;/code&gt; of the node goes. The &lt;code&gt;regnext&lt;/code&gt; of an &lt;code&gt;END&lt;/code&gt; regop is unused, as &lt;code&gt;END&lt;/code&gt; regops mean we have successfully matched. The number on the left indicates the position of the regop in the regnode array.</source>
          <target state="translated">ご覧のように、ブランチとピースを解析しましたが、最終的にはアトムにすぎませんでした。最後のプログラムは、物事がどのように機能するかを示しています。我々は持っている &lt;code&gt;EXACT&lt;/code&gt; 続いregop、 &lt;code&gt;END&lt;/code&gt; の regopを。括弧内の &lt;code&gt;regnext&lt;/code&gt; は、ノードのregnextがどこに行くかを示します。 &lt;code&gt;regnext&lt;/code&gt; の &lt;code&gt;END&lt;/code&gt; のようregopは、未使用である &lt;code&gt;END&lt;/code&gt; の regopsは、我々が正常に一致した意味します。左側の数字は、regnode配列内のレゴの位置を示します。</target>
        </trans-unit>
        <trans-unit id="a413e2eb7d932038f9ab1ac09695763b902b4d80" translate="yes" xml:space="preserve">
          <source>As you can see, it's getting a bit complicated. That's why sometimes is easier to take a temporary on your way through:</source>
          <target state="translated">ご覧のように、それは少し複雑になってきています。だからこそ、時々は一時的なものを取る方が簡単なのです。</target>
        </trans-unit>
        <trans-unit id="3fa1293b0c00ad3a76c1e01bf182a9e2122f9fdc" translate="yes" xml:space="preserve">
          <source>As you can see, the &quot;big end&quot; of the arrow touches the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, which is a nice way to remember that &lt;code&gt;&amp;gt;&lt;/code&gt; is the big-endian modifier. The same obviously works for &lt;code&gt;&amp;lt;&lt;/code&gt; , where the &quot;little end&quot; touches the code.</source>
          <target state="translated">ご覧のとおり、矢印の「ビッグエンド」が &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; に接触しています。これは、 &lt;code&gt;&amp;gt;&lt;/code&gt; がビッグエンディアン修飾子であることを覚えておくのに良い方法です。同じことが明らかに &lt;code&gt;&amp;lt;&lt;/code&gt; でも機能し、「小さな終わり」がコードに触れます。</target>
        </trans-unit>
        <trans-unit id="8d3da9040412695027bfa4b6fb728646046f3571" translate="yes" xml:space="preserve">
          <source>As you can see, the continuation bytes all begin with &lt;code&gt;&quot;10&quot;&lt;/code&gt; , and the leading bits of the start byte tell how many bytes there are in the encoded character.</source>
          <target state="translated">ご覧のとおり、継続バイトはすべて &lt;code&gt;&quot;10&quot;&lt;/code&gt; で始まり、開始バイトの先頭ビットによって、エンコードされた文字のバイト数がわかります。</target>
        </trans-unit>
        <trans-unit id="3abefb49e57cec4dd056d885964fc7e8cddbabc0" translate="yes" xml:space="preserve">
          <source>As you can see, we've stored the path and file data in the object itself. Remember, under the hood, this object is still just a hash. Later, we'll write accessors to manipulate this data.</source>
          <target state="translated">ご覧のように、パスとファイルのデータをオブジェクト自体に格納しています。このオブジェクトは単なるハッシュであることを覚えておいてください。後で、このデータを操作するためにアクセサを書きます。</target>
        </trans-unit>
        <trans-unit id="5a6344bf7b33dbff5320cfc2c10a629a29808655" translate="yes" xml:space="preserve">
          <source>As you can tell from a glance at &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;, the L&amp;lt;...&amp;gt; code is the most complex of the Pod formatting codes. The points below will hopefully clarify what it means and how processors should deal with it.</source>
          <target state="translated">&lt;a href=&quot;perlpod&quot;&gt;perlpodを&lt;/a&gt;見ればわかるように、L &amp;lt;...&amp;gt;コードは、Podのフォーマットコードの中で最も複雑です。以下のポイントは、それが何を意味し、どのようにプロセッサがそれに対処する必要があるかを明確にするでしょう。</target>
        </trans-unit>
        <trans-unit id="9261097e2916c2cc0f66dd44d4a942cdcbac0f6d" translate="yes" xml:space="preserve">
          <source>As you craft each patch you intend to submit to the Perl core, it's important to write a good commit message. This is especially important if your submission will consist of a series of commits.</source>
          <target state="translated">Perl コアに提出するパッチを作成する際には、良いコミットメッセージを書くことが重要です。これは、あなたの投稿が一連のコミットで構成されている場合には特に重要です。</target>
        </trans-unit>
        <trans-unit id="585d50527e778d78ffa867804e8d6039ce87d004" translate="yes" xml:space="preserve">
          <source>As you may have inferred from the above documentation and examples, &lt;code&gt;ok&lt;/code&gt; 's prototype is &lt;code&gt;($;$$)&lt;/code&gt; (and, incidentally, &lt;code&gt;skip&lt;/code&gt; 's is &lt;code&gt;($;$$$)&lt;/code&gt;). This means, for example, that you can do &lt;code&gt;ok @foo, @bar&lt;/code&gt; to compare the</source>
          <target state="translated">上記のドキュメントと例から推測できるように、 &lt;code&gt;ok&lt;/code&gt; のプロトタイプは &lt;code&gt;($;$$)&lt;/code&gt; です（そして、偶然に &lt;code&gt;skip&lt;/code&gt; は &lt;code&gt;($;$$$)&lt;/code&gt; です）。これは、たとえば、 &lt;code&gt;ok @foo, @bar&lt;/code&gt; を実行して、</target>
        </trans-unit>
        <trans-unit id="d3a79c79e4e5a9fafc42ddaaf88736c1e2cc7621" translate="yes" xml:space="preserve">
          <source>As you may have noticed, the name of the FETCH method (et al.) is the same for all accesses, even though the constructors differ in names (TIESCALAR vs TIEARRAY). While in theory you could have the same class servicing several tied types, in practice this becomes cumbersome, and it's easiest to keep them at simply one tie type per class.</source>
          <target state="translated">お気づきかもしれませんが、FETCHメソッド(など)の名前は、コンストラクタの名前が異なっていても(TIESCALAR vs TIEARRAY)、すべてのアクセスに対して同じです。理論的には、同じクラスで複数のタイ型を扱うことができますが、実際にはこれは面倒なので、1つのクラスに1つのタイ型だけにしておくのが一番簡単です。</target>
        </trans-unit>
        <trans-unit id="e80271d1fdc3feb0460f1e3a1704fc272e31f101" translate="yes" xml:space="preserve">
          <source>As you might know this calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function of &lt;code&gt;attributes&lt;/code&gt; at compile time with these parameters: 'attributes', the caller's package name, the reference to the code and 'method'.</source>
          <target state="translated">ご存知かもしれませんが、これはコンパイル時に &lt;code&gt;attributes&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 関数をこれらのパラメーターで呼び出します：「属性」、呼び出し元のパッケージ名、コードへの参照、および「メソッド」。</target>
        </trans-unit>
        <trans-unit id="0f14d6a62a3d5dfc412b082b83700a2aa2b31479" translate="yes" xml:space="preserve">
          <source>As you see from those examples, &lt;code&gt;STDOUT&lt;/code&gt; and &lt;code&gt;STDERR&lt;/code&gt; are output handles, and &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;ARGV&lt;/code&gt; are input handles. They are in all capital letters because they are reserved to Perl, much like the &lt;code&gt;@ARGV&lt;/code&gt; array and the &lt;code&gt;%ENV&lt;/code&gt; hash are. Their external associations were set up by your shell.</source>
          <target state="translated">これらの例からわかるように、 &lt;code&gt;STDOUT&lt;/code&gt; と &lt;code&gt;STDERR&lt;/code&gt; は出力ハンドルであり、 &lt;code&gt;STDIN&lt;/code&gt; と &lt;code&gt;ARGV&lt;/code&gt; は入力ハンドルです。 &lt;code&gt;@ARGV&lt;/code&gt; 配列や &lt;code&gt;%ENV&lt;/code&gt; ハッシュと同様に、Perlに予約されているため、すべて大文字です。それらの外部関連付けは、シェルによってセットアップされました。</target>
        </trans-unit>
        <trans-unit id="e27f616d9e27793d35d5e898cb0fead7ca633114" translate="yes" xml:space="preserve">
          <source>As you see, it's quite easy to become confused. While some small portion of the blame for this can be attributed to the reference-based implementation, it's really more due to a lack of existing documentation with examples designed for the beginner.</source>
          <target state="translated">ご覧のように、混乱するのは簡単です。この責任の一部はリファレンスベースの実装に起因していますが、実際には初心者のために設計された例を含む既存のドキュメントが不足していることに起因しています。</target>
        </trans-unit>
        <trans-unit id="512c5953fca52adf9fe503c69215e4eb2353e34b" translate="yes" xml:space="preserve">
          <source>As you see, it's remarkably similar to the Internet domain TCP server, so much so, in fact, that we've omitted several duplicate functions--spawn(), logmsg(), ctime(), and REAPER()--which are the same as in the other server.</source>
          <target state="translated">ご覧のように、これはインターネットドメインの TCP サーバと非常によく似ていますが、実際には、spawn()、logmsg()、ctime()、REAPER()といった重複した関数をいくつか省略しています。</target>
        </trans-unit>
        <trans-unit id="ea8178cd8e63a3e66a311fade3362af15d43aa5f" translate="yes" xml:space="preserve">
          <source>As you see, the name of the package is the name of the structure. Regular fields are just their own names. Plus the following accessor functions are provided for your convenience:</source>
          <target state="translated">ご覧の通り、パッケージ名は構造体の名前です。レギュラーフィールドはそれ自体の名前です。さらに、以下のアクセサ関数が用意されています。</target>
        </trans-unit>
        <trans-unit id="b457b60332a38dcdc3bc2fb765fda15f087f9402" translate="yes" xml:space="preserve">
          <source>As you see, there is one exception: in ASCII. That way you can assume Goal #1. And with &lt;code&gt;Encode&lt;/code&gt; , Goal #2 is assumed but you still have to be careful in the cases mentioned in the &lt;b&gt;CAVEAT&lt;/b&gt; paragraphs above.</source>
          <target state="translated">ご覧のとおり、1つの例外があります。ASCIIです。このようにして、目標1を想定できます。そして、 &lt;code&gt;Encode&lt;/code&gt; を使用すると、目標＃2が想定されますが、上記の&lt;b&gt;CAVEATの&lt;/b&gt;段落で言及されているケースには&lt;b&gt;引き続き&lt;/b&gt;注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="7cc089f777993943781491fc9a72f85a9a2f245b" translate="yes" xml:space="preserve">
          <source>As you see, this can be a bit tricky. It's important to realize that a regular expression is merely a set of assertions that gives a definition of success. There may be 0, 1, or several different ways that the definition might succeed against a particular string. And if there are multiple ways it might succeed, you need to understand backtracking to know which variety of success you will achieve.</source>
          <target state="translated">ご覧のように、これは少し厄介なことがあります。正規表現は成功の定義を与えるアサーションの集合に過ぎないことを理解することが重要です。定義が特定の文字列に対して成功する方法は0、1、またはいくつかあります。そして、成功する可能性のある複数の方法がある場合、どのような種類の成功が得られるかを知るために、バックトラッキングを理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="f1ce088efa2db68e2d881f71961d1904be5d37ad" translate="yes" xml:space="preserve">
          <source>As you would expect, this modifier causes, for example, &lt;code&gt;\D&lt;/code&gt; to mean the same thing as &lt;code&gt;[^0-9]&lt;/code&gt; ; in fact, all non-ASCII characters match &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , and &lt;code&gt;\W&lt;/code&gt; . &lt;code&gt;\b&lt;/code&gt; still means to match at the boundary between &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\W&lt;/code&gt; , using the &lt;code&gt;/a&lt;/code&gt; definitions of them (similarly for &lt;code&gt;\B&lt;/code&gt; ).</source>
          <target state="translated">ご想像のとおり、この修飾子は、たとえば、 &lt;code&gt;\D&lt;/code&gt; が &lt;code&gt;[^0-9]&lt;/code&gt; と同じことを意味します。実際、非ASCII文字はすべて &lt;code&gt;\D&lt;/code&gt; 、 &lt;code&gt;\S&lt;/code&gt; 、および &lt;code&gt;\W&lt;/code&gt; と一致します。 &lt;code&gt;\b&lt;/code&gt; は、それらの &lt;code&gt;/a&lt;/code&gt; 定義を使用して、 &lt;code&gt;\w&lt;/code&gt; と &lt;code&gt;\W&lt;/code&gt; 境界で一致することを意味します（ &lt;code&gt;\B&lt;/code&gt; と同様）。</target>
        </trans-unit>
        <trans-unit id="26154301b1350500c1d0c8c752bea63ea6529192" translate="yes" xml:space="preserve">
          <source>As you're writing an application, you decide as you go what messages you need to emit. Normally you'd go to write this:</source>
          <target state="translated">アプリケーションを書いているときに、どのようなメッセージを発する必要があるかを自分で決めていきます。通常、あなたはこれを書きに行きます。</target>
        </trans-unit>
        <trans-unit id="94a73ad4a31e87483d1616b8954f4b6c0ff428df" translate="yes" xml:space="preserve">
          <source>As you've seen, you can force &lt;code&gt;catdir()&lt;/code&gt; to create an absolute path by passing either an empty string or a path that begins with a volume name as the first argument. However, you are strongly encouraged not to do so, since this is done only for backward compatibility. Newer versions of File::Spec come with a method called &lt;code&gt;catpath()&lt;/code&gt; (see below), that is designed to offer a portable solution for the creation of absolute paths. It takes volume, directory and file portions and returns an entire path. While &lt;code&gt;catdir()&lt;/code&gt; is still suitable for the concatenation of</source>
          <target state="translated">&lt;code&gt;catdir()&lt;/code&gt; 、最初の引数として空の文字列またはボリューム名で始まるパスを渡すことにより、catdir（）に絶対パスを作成させることができます。ただし、これは下位互換性のためにのみ行われるため、そうしないことを強くお勧めします。 File :: Specの新しいバージョンには、絶対パスを作成するためのポータブルソリューションを提供するように設計された &lt;code&gt;catpath()&lt;/code&gt; （以下を参照）と呼ばれるメソッドが付属しています。ボリューム、ディレクトリ、ファイルの部分を取り、パス全体を返します。ながら &lt;code&gt;catdir()&lt;/code&gt; は依然としての連結に適しています</target>
        </trans-unit>
        <trans-unit id="a173e725607d0f98c78ebac0b31138d8d136aa84" translate="yes" xml:space="preserve">
          <source>Asia</source>
          <target state="translated">Asia</target>
        </trans-unit>
        <trans-unit id="f22fac8ac4e191689a82159394064af8e931487a" translate="yes" xml:space="preserve">
          <source>Aside from an experimental facility (see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt; below), Perl does not have named formal parameters. In practice all you do is assign to a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; list of these. Variables that aren't declared to be private are global variables. For gory details on creating private variables, see &lt;a href=&quot;#Private-Variables-via-my()&quot;&gt;Private Variables via my()&lt;/a&gt; and &lt;a href=&quot;#Temporary-Values-via-local()&quot;&gt;Temporary Values via local()&lt;/a&gt;. To create protected environments for a set of functions in a separate package (and probably a separate file), see &lt;a href=&quot;perlmod#Packages&quot;&gt;Packages in perlmod&lt;/a&gt;.</source>
          <target state="translated">実験的な機能（下記の&lt;a href=&quot;#Signatures&quot;&gt;署名を&lt;/a&gt;参照）を除いて、Perlには名前付きの仮パラメータがありません。実際には、これらの &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; リストに割り当てるだけです。プライベートであると宣言されていない変数はグローバル変数です。プライベート変数の作成に関する詳細については、「&lt;a href=&quot;#Private-Variables-via-my()&quot;&gt;my（）によるプライベート変数」&lt;/a&gt;および「&lt;a href=&quot;#Temporary-Values-via-local()&quot;&gt;local（）による一時値」を&lt;/a&gt;参照してください。一連の関数の保護された環境を別のパッケージ（おそらく別のファイル）に作成するには、「&lt;a href=&quot;perlmod#Packages&quot;&gt;perlmodのパッケージ」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0befd0a8afa8c19a870d175a4fdb840002143042" translate="yes" xml:space="preserve">
          <source>Ask it to create new Perl executable:</source>
          <target state="translated">新しいPerlの実行ファイルを作成するように指示します。</target>
        </trans-unit>
        <trans-unit id="06d5ff26b7db3df6b27e4da48afc0d8940af7b07" translate="yes" xml:space="preserve">
          <source>Ask the current maintainer to make you a co-maintainer or transfer the module to you.</source>
          <target state="translated">現在のメンテナにお願いして、あなたを共同メンテナにするか、モジュールをあなたに譲渡してもらいましょう。</target>
        </trans-unit>
        <trans-unit id="640918b79c5c24d060028d2fd27fecdba24558af" translate="yes" xml:space="preserve">
          <source>Ask the server for &quot;helpful information&quot; (that's what the RFC says) on the commands it accepts.</source>
          <target state="translated">サーバーが受け付けるコマンドについて、「役に立つ情報」(RFCではそう言っています)を聞いてみましょう。</target>
        </trans-unit>
        <trans-unit id="29957267ee0cac223134add5f2b52ea620705c23" translate="yes" xml:space="preserve">
          <source>Ask them for it. There are so many email providers available that it's unlikely the local system has any idea how to determine a user's email address.</source>
          <target state="translated">尋ねてみてください。利用できる電子メールプロバイダは非常に多く、ローカルシステムがユーザーの電子メールアドレスを決定する方法を知っているとは思えません。</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="00331b7ae6edef1dff40c7175d1e39fd7f33aa69" translate="yes" xml:space="preserve">
          <source>Assertions are conditions that have to be true; they don't actually match parts of the substring. There are six assertions that are written as backslash sequences.</source>
          <target state="translated">アサーションは真でなければならない条件であり、実際には部分文字列の一部とは一致しません。バックスラッシュ列として書かれたアサーションが6つあります。</target>
        </trans-unit>
        <trans-unit id="bc266cdcbb6ece4821fb3ad4912b26e12d68bda4" translate="yes" xml:space="preserve">
          <source>Assigning Magic</source>
          <target state="translated">マジックの割り当て</target>
        </trans-unit>
        <trans-unit id="5758c53717d47b26aecb2f1e95a4e608692a5e69" translate="yes" xml:space="preserve">
          <source>Assigning and Dereferencing Variables.</source>
          <target state="translated">変数の代入と参照の解除。</target>
        </trans-unit>
        <trans-unit id="d524a6069dcf850237db76c5b77de165e1b358ee" translate="yes" xml:space="preserve">
          <source>Assigning to References</source>
          <target state="translated">リファレンスへの割り当て</target>
        </trans-unit>
        <trans-unit id="c279a061dbc31dc7bee97d46022b90f62667a4ac" translate="yes" xml:space="preserve">
          <source>Assigning to a list of private variables to name your arguments:</source>
          <target state="translated">プライベート変数のリストに代入して、引数に名前を付けます。</target>
        </trans-unit>
        <trans-unit id="5095fe9fb68e9a62edc8c9686322a7856091bd87" translate="yes" xml:space="preserve">
          <source>Assigning to an entry in the hash will cause the time stamps of the file to be modified. If the file does not exist then it will be created. Assigning a single integer to a hash element will cause both the access and modification times to be changed to that value. Alternatively a reference to an array of two values can be passed. The first array element will be used to set the access time and the second element will be used to set the modification time.</source>
          <target state="translated">ハッシュのエントリに代入すると、ファイルのタイムスタンプが変更されます。ファイルが存在しない場合は、ファイルが作成されます。ハッシュ要素に単一の整数を代入すると、アクセス時間と修正時間の両方がその値に変更されます。あるいは、2つの値からなる配列への参照を渡すこともできます。最初の配列要素はアクセス時間を設定するために使用され、2番目の要素は修正時間を設定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="7ca1018fbacf1aa9c5974935df5ed892f5691b8b" translate="yes" xml:space="preserve">
          <source>Assigning to the special variable $[</source>
          <target state="translated">特別な変数に代入します。</target>
        </trans-unit>
        <trans-unit id="7bec00ae67953bf63f8b1b3f8ddf8f9255f79d82" translate="yes" xml:space="preserve">
          <source>Assignment Operators</source>
          <target state="translated">代入演算子</target>
        </trans-unit>
        <trans-unit id="91becff514df4bb52422a8c72ad2fa7e138a09c4" translate="yes" xml:space="preserve">
          <source>Assignment is a little bit special in that it uses its left argument to determine the context for the right argument. Assignment to a scalar evaluates the right-hand side in scalar context, while assignment to an array or hash evaluates the righthand side in list context. Assignment to a list (or slice, which is just a list anyway) also evaluates the right-hand side in list context.</source>
          <target state="translated">代入は、左引数を使って右引数のコンテキストを決定するという点で少し特殊です。スカラへの代入はスカラコンテキストで右辺を評価し、配列やハッシュへの代入はリストコンテキストで右辺を評価します。リスト(またはスライス、これはいずれにせよただのリストです)への代入も、リストコンテキストで右辺を評価します。</target>
        </trans-unit>
        <trans-unit id="eeb7b7ef33aeb4c3b9e41b0d3c8c37efe141de32" translate="yes" xml:space="preserve">
          <source>Assignment operators work as in C. That is,</source>
          <target state="translated">代入演算子はCと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="e44ee3c1149f2c21100b91bdf4ef60fbcf7575f3" translate="yes" xml:space="preserve">
          <source>Assignment to a typeglob performs an aliasing operation, i.e.,</source>
          <target state="translated">タイプグローブへの割り当ては、エイリアシング操作を行います。</target>
        </trans-unit>
        <trans-unit id="101d3fe15227197bfb043f8902c240196099b710" translate="yes" xml:space="preserve">
          <source>Assignment to references and non-references may be combined in lists and conditional ternary expressions, as long as the values on the right-hand side are the right type for each element on the left, though this may make for obfuscated code:</source>
          <target state="translated">リストや条件付き三項式では、右辺の値が左辺の各要素に対して正しい型である限り、参照と非参照の代入を組み合わせることができますが、これはコードを難読化する可能性があります。</target>
        </trans-unit>
        <trans-unit id="38be444e6e51033245feebeecd19c780a4190e4e" translate="yes" xml:space="preserve">
          <source>Associated with the matching variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... are the &lt;b&gt;backreferences&lt;/b&gt;&lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; , ... Backreferences are matching variables that can be used</source>
          <target state="translated">マッチング変数に関連付けられた &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; 、...ある&lt;b&gt;後方参照&lt;/b&gt; &lt;code&gt;\g1&lt;/code&gt; 、 &lt;code&gt;\g2&lt;/code&gt; 、...後方参照を使用できる変数にマッチしています</target>
        </trans-unit>
        <trans-unit id="6addecb62c84d829e48e459ba05882e03a175023" translate="yes" xml:space="preserve">
          <source>Assume &lt;b&gt;anything&lt;/b&gt; about structs (especially the ones you don't control, like the ones coming from the system headers)</source>
          <target state="translated">構造体（特に、システムヘッダーから取得したものなど、ユーザーが制御しないもの）について&lt;b&gt;何かを&lt;/b&gt;想定します。</target>
        </trans-unit>
        <trans-unit id="9e766ffb9a2f9804774162774bb465b7a888d65a" translate="yes" xml:space="preserve">
          <source>Assume each sentence ends with two spaces and try to preserve that spacing. Without this option, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space.</source>
          <target state="translated">各文は 2 つの空白で終わると仮定して、その間隔を維持しようとします。このオプションを指定しないと、非バーバティム段落の連続した空白はすべて1つのスペースに圧縮されます。</target>
        </trans-unit>
        <trans-unit id="eb29cb4a3a64a3e55d8f8b66fc5429f33cc90a54" translate="yes" xml:space="preserve">
          <source>Assume four classes, A,B,C &amp;amp; D.</source>
          <target state="translated">4つのクラスA、B、C、Dを想定します。</target>
        </trans-unit>
        <trans-unit id="900f642b83bb773e589683695c3e83ec1e64d87c" translate="yes" xml:space="preserve">
          <source>Assume nothing about numerical values (&lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;) of characters. Do not use explicit code point ranges (like &lt;code&gt;\xHH-\xHH)&lt;/code&gt; . However, starting in Perl v5.22, regular expression pattern bracketed character class ranges specified like &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/a&gt;&lt;/code&gt; are portable. You can portably use symbolic character classes like &lt;code&gt;[:print:]&lt;/code&gt;.</source>
          <target state="translated">文字の数値（ &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ）については何も想定していません。明示的なコードポイント範囲（ &lt;code&gt;\xHH-\xHH)&lt;/code&gt; は使用しないでください。ただし、Perl v5.22以降では、 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/a&gt;&lt;/code&gt; ように指定された正規表現パターンの括弧で囲まれた文字クラス範囲は移植可能です。 &lt;code&gt;[:print:]&lt;/code&gt; のようなシンボリック文字クラスを移植可能に使用できます。</target>
        </trans-unit>
        <trans-unit id="d225542d9c39b42f29197a0ce47f62fa7382a5c0" translate="yes" xml:space="preserve">
          <source>Assume that an integer cannot take less than 20 bytes of memory, a float cannot take less than 24 bytes, a string cannot take less than 32 bytes (all these examples assume 32-bit architectures, the result are quite a bit worse on 64-bit architectures). If a variable is accessed in two of three different ways (which require an integer, a float, or a string), the memory footprint may increase yet another 20 bytes. A sloppy malloc(3) implementation can inflate these numbers dramatically.</source>
          <target state="translated">整数は20バイト以下のメモリを取ることができず、floatは24バイト以下のメモリを取ることができず、文字列は32バイト以下のメモリを取ることができないと仮定します(これらの例はすべて32ビットアーキテクチャを想定していますが、結果は64ビットアーキテクチャではかなり悪いものになります)。変数が 3 つの異なる方法のうち 2 つの方法でアクセスされた場合 (整数、float、文字列を必要とする)、メモリフットプリントはさらに 20 バイト増加する可能性があります。ずさんな malloc(3)の実装は、これらの数値を劇的に増加させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="5cf62705d74f3464ae65764bb487f8249da94d46" translate="yes" xml:space="preserve">
          <source>Assume that the old DLL is named</source>
          <target state="translated">古い DLL の名前が</target>
        </trans-unit>
        <trans-unit id="2605c8584b04c7bf0a2b7cc3badf48edb3bf06d0" translate="yes" xml:space="preserve">
          <source>Assume that you are a seasoned porter, so are sure that all the necessary tools are already present on your system, and you know how to get the Perl source distribution. Untar it, change to the extract directory, and</source>
          <target state="translated">あなたが熟練したポーターであると仮定して、必要なツールがすべてシステム上にすでに存在していることを確認し、Perl のソース・ディストリビューションを入手する方法を知っているとします。それをアンターして、extract ディレクトリに移動して</target>
        </trans-unit>
        <trans-unit id="aa1c680a74a55225e27707c2ac5fffa720c70f93" translate="yes" xml:space="preserve">
          <source>Assume this TAP version for &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; instead of default TAP version 12.</source>
          <target state="translated">デフォルトのTAPバージョン12ではなく、&lt;a href=&quot;parser&quot;&gt;TAP :: Parserの&lt;/a&gt;このTAPバージョンを想定します。</target>
        </trans-unit>
        <trans-unit id="7fc8664d84c1446907ca24dadecd0bd664e1d82d" translate="yes" xml:space="preserve">
          <source>Assume very little about character sets.</source>
          <target state="translated">キャラクターセットについてはほとんど想定していません。</target>
        </trans-unit>
        <trans-unit id="2b3c42e666c3f46061cf3e08ae5f736db9c6b58e" translate="yes" xml:space="preserve">
          <source>Assumes that PL_op is the op that originally triggered the error, and that PL_comppad/PL_curpad points to the currently executing pad.</source>
          <target state="translated">PL_op が元々エラーを引き起こしたオペであり、PL_comppad/PL_curpad が現在実行中のパッドを指していると仮定します。</target>
        </trans-unit>
        <trans-unit id="85a92465c7801a7593ae125acb124d7a78d00d62" translate="yes" xml:space="preserve">
          <source>Assuming one can dereference any type of pointer for any type of data</source>
          <target state="translated">任意の型のデータに対して任意の型のポインタを参照解除できると仮定すると</target>
        </trans-unit>
        <trans-unit id="3eba801518ac20c3e71b66588e69e8412d142226" translate="yes" xml:space="preserve">
          <source>Assuming sizeof(int) == sizeof(long)</source>
          <target state="translated">sizeof(int)==sizeof(long)と仮定すると</target>
        </trans-unit>
        <trans-unit id="3b4336515b2aaf87ea7abdf5569d5fbbc17ae08d" translate="yes" xml:space="preserve">
          <source>Assuming that the &lt;code&gt;man&lt;/code&gt; -files were put on an appropriate location, this completes the installation of minimal Perl system. (The binary distribution contains also a lot of additional modules, and the documentation in INF format.)</source>
          <target state="translated">仮定すると、 &lt;code&gt;man&lt;/code&gt; -filesが適切な位置に置かれた、これは最小限のPerlシステムのインストールを完了します。（バイナリディストリビューションには、多くの追加モジュールとINF形式のドキュメントも含まれています。）</target>
        </trans-unit>
        <trans-unit id="1b3d48dcc2393b6165f22e974c8fe37cb11cfa92" translate="yes" xml:space="preserve">
          <source>Assuming that we have to match calendar dates which may be given in one of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write three suitable patterns where we use 'd', 'm' and 'y' respectively as the names of the groups capturing the pertaining components of a date. The matching operation combines the three patterns as alternatives:</source>
          <target state="translated">yyyy-mm-dd、mm/dd/yyy、dd.mm.yyyの3つの形式のいずれかで指定されたカレンダーの日付を一致させる必要があると仮定すると、日付に関連する構成要素をキャプチャするグループの名前として、それぞれ「d」、「m」、「y」を使用する3つの適切なパターンを記述することができます。マッチング演算では、これら3つのパターンを組み合わせて代替案を作成します。</target>
        </trans-unit>
        <trans-unit id="0518d034f096809ab863fb80241126fe45a3c2bb" translate="yes" xml:space="preserve">
          <source>Assuming that you don't care about IEEE notations like &quot;NaN&quot; or &quot;Infinity&quot;, you probably just want to use a regular expression:</source>
          <target state="translated">NaN」や「Infinity」のようなIEEE表記を気にしないと仮定すると、正規表現を使いたいだけなのかもしれません。</target>
        </trans-unit>
        <trans-unit id="c5c2ab31ddb2d4e68552f61633bf186e98613579" translate="yes" xml:space="preserve">
          <source>Assuming the character set is ASCIIish</source>
          <target state="translated">文字セットがASCIIっぽいと仮定して</target>
        </trans-unit>
        <trans-unit id="657e33b27d387873c824a6e9282e0d4e22ed782e" translate="yes" xml:space="preserve">
          <source>Assuming the character set is just ASCII</source>
          <target state="translated">文字セットをASCIIだけと仮定すると</target>
        </trans-unit>
        <trans-unit id="7e0c2159a115b592c79f24b1d84f43c005948de3" translate="yes" xml:space="preserve">
          <source>Assuming the contents of static memory pointed to by the return values of Perl wrappers for C library functions doesn't change. Many C library functions return pointers to static storage that can be overwritten by subsequent calls to the same or related functions. Perl has light-weight wrappers for some of these functions, and which don't make copies of the static memory. A good example is the interface to the environment variables that are in effect for the program. Perl has &lt;code&gt;PerlEnv_getenv&lt;/code&gt; to get values from the environment. But the return is a pointer to static memory in the C library. If you are using the value to immediately test for something, that's fine, but if you save the value and expect it to be unchanged by later processing, you would be wrong, but perhaps you wouldn't know it because different C library implementations behave differently, and the one on the platform you're testing on might work for your situation. But on some platforms, a subsequent call to &lt;code&gt;PerlEnv_getenv&lt;/code&gt; or related function WILL overwrite the memory that your first call points to. This has led to some hard-to-debug problems. Do a &lt;a href=&quot;perlapi#savepv&quot;&gt;savepv in perlapi&lt;/a&gt; to make a copy, thus avoiding these problems. You will have to free the copy when you're done to avoid memory leaks. If you don't have control over when it gets freed, you'll need to make the copy in a mortal scalar, like so:</source>
          <target state="translated">Cライブラリ関数のPerlラッパーの戻り値が指す静的メモリの内容は変化しないと仮定します。多くのCライブラリ関数は、同じまたは関連する関数への後続の呼び出しで上書きできる静的ストレージへのポインターを返します。 Perlには、これらの関数の一部用の軽量ラッパーがあり、静的メモリのコピーを作成しません。良い例は、プログラムに有効な環境変数へのインターフェースです。 Perlには &lt;code&gt;PerlEnv_getenv&lt;/code&gt; があります環境から値を取得します。ただし、戻り値はCライブラリの静的メモリへのポインタです。値を使用してすぐに何かをテストしている場合は問題ありませんが、値を保存し、後の処理で変更されないことが予想される場合は誤りですが、異なるCライブラリの実装が動作するため、おそらくそれを知らないでしょう。別の方法で、テストしているプラ​​ットフォーム上のものが状況に応じて機能する場合があります。ただし、一部のプラットフォームでは、 &lt;code&gt;PerlEnv_getenv&lt;/code&gt; または関連する関数への後続の呼び出しにより、最初の呼び出しが指すメモリが上書きされます。これにより、デバッグが困難な問題が発生しました。行い&lt;a href=&quot;perlapi#savepv&quot;&gt;はperlapiでsavepvを&lt;/a&gt;コピーを作成して、これらの問題を回避します。完了したら、メモリリークを回避するためにコピーを解放する必要があります。いつ解放されるかを制御できない場合は、次のように、致命的なスカラーでコピーを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="3368b5431ec704ea21f8185fe92770b3b042af71" translate="yes" xml:space="preserve">
          <source>Assuming the database from the previous example:</source>
          <target state="translated">先ほどの例のデータベースを想定しています。</target>
        </trans-unit>
        <trans-unit id="37f2465394b9cbdd91947c6e4e077a7d4b7dde8a" translate="yes" xml:space="preserve">
          <source>Assuming they are to behave analogously to Perl's &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; , overloaded implementations of these operators are required to mutate their operands.</source>
          <target state="translated">これらがPerlの &lt;code&gt;++&lt;/code&gt; および &lt;code&gt;--&lt;/code&gt; と同様に動作すると想定すると、これらの演算子のオーバーロードされた実装は、それらのオペランドを変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="23383c34471c75b25927cfad7162ad1979bea49b" translate="yes" xml:space="preserve">
          <source>Assuming you call your class Projname::L10N, create a class consisting minimally of:</source>
          <target state="translated">クラスProjname::L10Nを呼び出すと仮定して、最小で構成されるクラスを作成します。</target>
        </trans-unit>
        <trans-unit id="a8c3ccec4be1ea177d36a955790696ae747518f7" translate="yes" xml:space="preserve">
          <source>Assuming you have good test coverage, your tests should fail with missing dependencies informing the user more strongly that something is wrong. You can write a</source>
          <target state="translated">良いテストカバレッジを持っていると仮定すると、あなたのテストは依存関係が欠けている状態で失敗し、何かが間違っていることをより強くユーザに知らせるべきです。このような場合には</target>
        </trans-unit>
        <trans-unit id="562091b17215c5d2dabd5a6d27106f5a063623cd" translate="yes" xml:space="preserve">
          <source>Assuming you know you're dealing with a UTF-8 string, you can find out how long the first character in it is with the &lt;code&gt;UTF8SKIP&lt;/code&gt; macro:</source>
          <target state="translated">UTF-8文字列を扱っていることがわかっているとすると、 &lt;code&gt;UTF8SKIP&lt;/code&gt; マクロを使用して、その最初の文字の長さがどれくらいであるかを知ることができます。</target>
        </trans-unit>
        <trans-unit id="9da798a9d5da7f2f9d9ef9e1b52ebf21c8c17dc7" translate="yes" xml:space="preserve">
          <source>Assuming you're running under sufficient permissions, you should be able to set the system-wide date and time by running the &lt;code&gt;date(1)&lt;/code&gt; program. (There is no way to set the time and date on a per-process basis.) This mechanism will work for Unix, MS-DOS, Windows, and NT; the VMS equivalent is &lt;code&gt;set &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">十分な権限で実行している場合、 &lt;code&gt;date(1)&lt;/code&gt; プログラムを実行することにより、システム全体の日付と時刻を設定できるはずです。（プロセスごとに日時を設定する方法はありません。）このメカニズムは、Unix、MS-DOS、Windows、およびNTで機能します。VMSと同等の &lt;code&gt;set &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a50f834fa5c7b73ada293aca740d6156afc09752" translate="yes" xml:space="preserve">
          <source>Assuming your system supports such things, just send an appropriate signal to the process (see &lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;). It's common to first send a TERM signal, wait a little bit, and then send a KILL signal to finish it off.</source>
          <target state="translated">システムがそのようなことをサポートしていると仮定すると、適切なシグナルをプロセスに送信するだけです（&lt;a href=&quot;functions/kill&quot;&gt;killを&lt;/a&gt;参照）。最初にTERMシグナルを送信し、少し待ってから、KILLシグナルを送信して終了するのが一般的です。</target>
        </trans-unit>
        <trans-unit id="a34c6deba477e26d8810a3f5cd4114d33aa1e300" translate="yes" xml:space="preserve">
          <source>At 10:23, this function generates the 10th line of a data file; at 3:45 PM it generates the 15th line instead. By default, &lt;code&gt;Memoize&lt;/code&gt; will only see the $problem_type argument. To fix this, include the current hour in the normalizer:</source>
          <target state="translated">10:23に、この関数はデータファイルの10行目を生成します。午後3時45分に、代わりに15行目を生成します。デフォルトでは、 &lt;code&gt;Memoize&lt;/code&gt; は$ problem_type引数のみを参照します。これを修正するには、ノーマライザーに現在の時間を含めます。</target>
        </trans-unit>
        <trans-unit id="0d3035d43f34a8f68a2af535ff4afe837cc1bf23" translate="yes" xml:space="preserve">
          <source>At a given character position, the first alternative that allows the regex match to succeed will be the one that matches. Here, all the alternatives match at the first string position, so the first matches.</source>
          <target state="translated">与えられた文字位置では、正規表現のマッチを成功させる最初の選択肢がマッチします。ここでは、すべての選択肢が最初の文字列の位置でマッチするので、最初のものがマッチします。</target>
        </trans-unit>
        <trans-unit id="fa1efd2d4349c6ea79b9b9fc2089c111f8b1ca40" translate="yes" xml:space="preserve">
          <source>At any given time, exactly one of these modifiers is in effect. Their existence allows Perl to keep the originally compiled behavior of a regular expression, regardless of what rules are in effect when it is actually executed. And if it is interpolated into a larger regex, the original's rules continue to apply to it, and only it.</source>
          <target state="translated">いつでも、これらの修飾子のうち正確に 1 つが有効になっています。これらの修飾子の存在により、Perl は、実際に実行されたときにどのようなルールが有効であるかにかかわらず、正規表現の元々のコンパイルされた動作を維持することができます。そして、それがより大きな正規表現に補間された場合、元のルールが適用され続け、それだけに適用されます。</target>
        </trans-unit>
        <trans-unit id="7593f9fb00e51f006212d276b2834d5cb1e7bd4c" translate="yes" xml:space="preserve">
          <source>At any rate, the very use of &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; is questionable when it comes to unicode characters since you have to consider such things as character width (i.e. double-width for ideographs) and directions (i.e. BIDI for Arabic and Hebrew).</source>
          <target state="translated">いずれにしても、Unicode文字に関しては、文字の幅（表意文字の場合は倍幅）や方向（アラビア語とヘブライ語の場合はBIDI）などを考慮する必要があるため、 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 使用には疑問があります。</target>
        </trans-unit>
        <trans-unit id="40530b4cf9ab5b3f6391788f6f588ae031f72498" translate="yes" xml:space="preserve">
          <source>At deserialization time, you will be given back the same LIST, but all the extra references will be pointing into the deserialized structure.</source>
          <target state="translated">デシリアライズ時には、同じLISTが返されますが、余分な参照はすべてデシリアライズされた構造体を指しています。</target>
        </trans-unit>
        <trans-unit id="2359fa76d13a340de35eda7f896e38293fc5d5aa" translate="yes" xml:space="preserve">
          <source>At each stack level, the subroutine's name is displayed along with its parameters. For simple scalars, this is sufficient. For complex data types, such as objects and other references, this can simply display &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; .</source>
          <target state="translated">各スタックレベルでは、サブルーチンの名前がそのパラメーターとともに表示されます。単純なスカラーの場合、これで十分です。オブジェクトやその他の参照などの複雑なデータ型の場合、これは単に &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; を表示できます。</target>
        </trans-unit>
        <trans-unit id="396433f01b9bc30bd1dc987a608f2db8a7b54ded" translate="yes" xml:space="preserve">
          <source>At entry points to perl, such as &lt;code&gt;perl_parse()&lt;/code&gt; , &lt;code&gt;perl_run()&lt;/code&gt; and &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; each does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; , then enter a runops loop or whatever, and handle possible exception returns. For a 2 return, final cleanup is performed, such as popping stacks and calling &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; blocks. Amongst other things, this is how scope cleanup still occurs during an &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;perl_parse()&lt;/code&gt; 、 &lt;code&gt;perl_run()&lt;/code&gt; 、 &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; などのperlへのエントリポイントで、それぞれが &lt;code&gt;JMPENV_PUSH&lt;/code&gt; を実行し、runopsループなどを入力して、可能な例外の戻りを処理します。2リターンの場合、スタックのポップや &lt;code&gt;CHECK&lt;/code&gt; または &lt;code&gt;END&lt;/code&gt; ブロックの呼び出しなど、最終的なクリーンアップが実行されます。とりわけ、これは、 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 時にスコープのクリーンアップが依然として行われる方法です。</target>
        </trans-unit>
        <trans-unit id="3b52a6611c3d532a492a587178e19cf7d8fea481" translate="yes" xml:space="preserve">
          <source>At first glance, you'd think that it shouldn't print, because obviously the &lt;code&gt;ddd&lt;/code&gt; isn't going to match the target string. But look at this example:</source>
          <target state="translated">一見すると、 &lt;code&gt;ddd&lt;/code&gt; がターゲット文字列と一致しないのは明らかであるため、印刷すべきではないと思います。しかし、この例を見てください：</target>
        </trans-unit>
        <trans-unit id="a20d2e5d0ab73a1c97b3463749bc6385228a9028" translate="yes" xml:space="preserve">
          <source>At least for consistency with WinNT, you should keep the recommended value.</source>
          <target state="translated">少なくともWinNTとの整合性を保つためには、推奨値を守っておくべきです。</target>
        </trans-unit>
        <trans-unit id="27bd45d9389cf551091228f338420922ea6613d9" translate="yes" xml:space="preserve">
          <source>At least in Unix you may be able to get past this by increasing your process datasize limits: in csh/tcsh use &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;limit datasize n&lt;/code&gt; (where &lt;code&gt;n&lt;/code&gt; is the number of kilobytes) to check the current limits and change them, and in ksh/bash/zsh use &lt;code&gt;ulimit -a&lt;/code&gt; and &lt;code&gt;ulimit -d n&lt;/code&gt; , respectively.</source>
          <target state="translated">少なくともUnixでは、プロセスのデータサイズ制限を増やすことでこれを回避できる場合があります。csh/ tcshで &lt;code&gt;limit&lt;/code&gt; と &lt;code&gt;limit datasize n&lt;/code&gt; を制限（ &lt;code&gt;n&lt;/code&gt; はキロバイト数）して、現在の制限を確認して変更し、kshで変更します。 / bash / zshは、それぞれ &lt;code&gt;ulimit -a&lt;/code&gt; と &lt;code&gt;ulimit -d n&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="be275e2a07874324b642ea6224748e1cc7c92b91" translate="yes" xml:space="preserve">
          <source>At least it's backwards compatible in not doing much.</source>
          <target state="translated">少なくとも大したことをしていない点では下位互換だと思う。</target>
        </trans-unit>
        <trans-unit id="9e14e0bb06602e8d806ecd5603df3d1331d55d06" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; must have a goal (at least one of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; must be non-zero), and if both do, both have to be reached for a successful match. Also, if the fold of a character is multiple characters, all of them must be matched (see tr21 reference below for 'folding').</source>
          <target state="translated">&lt;code&gt;s1&lt;/code&gt; と &lt;code&gt;s2&lt;/code&gt; の少なくとも1つに目標があり（ &lt;code&gt;l1&lt;/code&gt; と &lt;code&gt;l2&lt;/code&gt; の少なくとも1つがゼロ以外である必要があります）、両方が目標を達成している場合は、両方に到達する必要があります。また、文字の折りたたみが複数の文字である場合は、それらすべてを一致させる必要があります（「折りたたみ」については、下のtr21参照を参照してください）。</target>
        </trans-unit>
        <trans-unit id="9972c1cfc00f54bc3d4bf6854c0d9453527f2493" translate="yes" xml:space="preserve">
          <source>At least the three builtin functions &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(...)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists(...)&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(...)&lt;/a&gt;&lt;/code&gt;. We might someday add more of these later if we think of them.</source>
          <target state="translated">少なくとも3つの組み込み関数 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(...)&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists(...)&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(...)&lt;/a&gt;&lt;/code&gt; 。考えてみればいつかもっと追加するかもしれません。</target>
        </trans-unit>
        <trans-unit id="dc8bf4c3c86adf3ceb8a466491ba399fbc2b4c86" translate="yes" xml:space="preserve">
          <source>At line number 4 is a helpful pointer, that tells you where you are now. To see more code, type 'v' again:</source>
          <target state="translated">4行目には、あなたが今どこにいるかを教えてくれる便利なポインタがあります。より多くのコードを見るには、もう一度 'v' と入力してください。</target>
        </trans-unit>
        <trans-unit id="3706bce960e08579e2a93b26085ef7458b3bba0d" translate="yes" xml:space="preserve">
          <source>At present that list is: weaken, isweak, dualvar, isvstring, set_prototype</source>
          <target state="translated">現時点でのリストは、weaken,isweak,dualvar,isvstring,set_prototypeです。</target>
        </trans-unit>
        <trans-unit id="a9a7ccc891020b1abe97ef7e238b5077a99ae99b" translate="yes" xml:space="preserve">
          <source>At present three compression methods are supported by IO::Compress::Zip, namely Store (no compression at all), Deflate, Bzip2 and LZMA.</source>
          <target state="translated">現在 IO::Compress::Zip でサポートされている圧縮方法は、Store (全く圧縮しない)、Deflate、Bzip2、LZMA の 3 つです。</target>
        </trans-unit>
        <trans-unit id="c6f3b56326d807044d12f7fa90b19c7ea2469f7b" translate="yes" xml:space="preserve">
          <source>At present, the first time you iterate over %ENV using &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, you will incur a time penalty as all logical names are read, in order to fully populate %ENV. Subsequent iterations will not reread logical names, so they won't be as slow, but they also won't reflect any changes to logical name tables caused by other programs.</source>
          <target state="translated">現在、 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; を使用して％ENVを初めて反復するとき、％ENVを完全に入力するために、すべての論理名が読み取られるため、時間のペナルティが発生します。後続の反復では論理名が再度読み取られないため、処理速度は遅くなりませんが、他のプログラムによる論理名テーブルへの変更は反映されません。</target>
        </trans-unit>
        <trans-unit id="25d8707372413087d65e69b61d9a6dc703b71cf2" translate="yes" xml:space="preserve">
          <source>At run time, each listed plugin is instantiated as a singleton object by running the equivalent of this pseudo code:</source>
          <target state="translated">実行時には、リストアップされた各プラグインは、この擬似コードと同等のものを実行することで、シングルトンオブジェクトとしてインスタンス化されます。</target>
        </trans-unit>
        <trans-unit id="0346a8b0d676351a6882db32e2f71fe2cd6612af" translate="yes" xml:space="preserve">
          <source>At run-time you can use:</source>
          <target state="translated">実行時には</target>
        </trans-unit>
        <trans-unit id="14c311a97bb302da658b5d5c146d94913481c6a7" translate="yes" xml:space="preserve">
          <source>At some moment the built may die, reporting a</source>
          <target state="translated">いつのまにかビルドされたものが死ぬかもしれません。</target>
        </trans-unit>
        <trans-unit id="8f94eca0c2d56d19683ad85c3b3f54fed0ab0893" translate="yes" xml:space="preserve">
          <source>At the 2008 QA Hackathon in Oslo, Perl module toolchain maintainers agrees to use the CPAN Meta format to communicate post-configuration requirements between toolchain components. These files,</source>
          <target state="translated">2008年にオスロで開催されたQAハッカソンでは、Perlモジュールのツールチェーンのメンテナが、ツールチェーンコンポーネント間で設定後の要件を通信するためにCPAN Metaフォーマットを使用することに同意しました。これらのファイル</target>
        </trans-unit>
        <trans-unit id="86950d72bad1114392fd499fea36a75e7faf16d6" translate="yes" xml:space="preserve">
          <source>At the cost of a slight header overhead, you may store to an already opened file descriptor using the &lt;code&gt;store_fd&lt;/code&gt; routine, and retrieve from a file via &lt;code&gt;fd_retrieve&lt;/code&gt; . Those names aren't imported by default, so you will have to do that explicitly if you need those routines. The file descriptor you supply must be already opened, for read if you're going to retrieve and for write if you wish to store.</source>
          <target state="translated">わずかなヘッダのオーバーヘッドのコストで、あなたが使用して、すでにオープンされたファイル記述子に格納することができる &lt;code&gt;store_fd&lt;/code&gt; のルーチンを、を介してファイルから取得 &lt;code&gt;fd_retrieve&lt;/code&gt; 。これらの名前はデフォルトではインポートされないため、これらのルーチンが必要な場合は明示的にインポートする必要があります。指定するファイル記述子は、取得する場合は読み取り用、保存する場合は書き込み用にすでに開いている必要があります。</target>
        </trans-unit>
        <trans-unit id="5655f269f9dae667811a30ef2f8f926fc9530ad6" translate="yes" xml:space="preserve">
          <source>At the end of</source>
          <target state="translated">の最後に</target>
        </trans-unit>
        <trans-unit id="9572ac86c1b1da5c7ab83dd35ce00912ee7e613d" translate="yes" xml:space="preserve">
          <source>At the end of all &lt;code&gt;when&lt;/code&gt; blocks, there is an implicit &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;. You can override that with an explicit &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; if you're interested in only the first match alone.</source>
          <target state="translated">すべての &lt;code&gt;when&lt;/code&gt; ブロックの最後に、暗黙の &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; があります。最初の一致のみに関心がある場合は、明示的な &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; オーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="ca6a702d6cdcdadecdbaeb43444eca515cc146c7" translate="yes" xml:space="preserve">
          <source>At the end of the parse, call &lt;code&gt;$parser-&amp;gt;root&lt;/code&gt; to get the tree's top node.</source>
          <target state="translated">解析の最後に &lt;code&gt;$parser-&amp;gt;root&lt;/code&gt; を呼び出して、ツリーの最上位ノードを取得します。</target>
        </trans-unit>
        <trans-unit id="07a9cc69765068861817ec41e4a7228bd113195b" translate="yes" xml:space="preserve">
          <source>At the lowest level, the macros new_SV() and del_SV() grab and free an SV head. (If debugging with -DD, del_SV() calls the function S_del_sv() to return the SV to the free list with error checking.) new_SV() calls more_sv() / sv_add_arena() to add an extra arena if the free list is empty. SVs in the free list have their SvTYPE field set to all ones.</source>
          <target state="translated">最下層では、マクロ new_SV()と del_SV()が SV のヘッドを取得して解放します。(-DD でデバッグしている場合、del_SV()は関数 S_del_sv()を呼び出して、エラーチェックを行いながら SV をフリーリストに戻します。)new_SV()は more_sv()/sv_add_arena()を呼び出して、フリーリストが空の場合に追加のアリーナを追加します。フリーリストの SV は、SvTYPE フィールドがすべての SV に設定されています。</target>
        </trans-unit>
        <trans-unit id="6089cbc08fb43732445842a261366b161cee7872" translate="yes" xml:space="preserve">
          <source>At the moment of writing, AIX supports two different native C compilers, for which you have to pay: &lt;b&gt;xlC&lt;/b&gt; and &lt;b&gt;vac&lt;/b&gt;. If you decide to use either of these two (which is quite a lot easier than using gcc), be sure to upgrade to the latest available patch level. Currently:</source>
          <target state="translated">執筆の時点で、AIXは2つの異なるネイティブCコンパイラーをサポートしており、それらを支払う必要があります：&lt;b&gt;xlC&lt;/b&gt;と&lt;b&gt;vac&lt;/b&gt;。これら2つのいずれかを使用する場合（これはgccを使用するよりもはるかに簡単です）、利用可能な最新のパッチレベルにアップグレードしてください。現在：</target>
        </trans-unit>
        <trans-unit id="af7b9b33fafaf83f9420acb89bb16618e9123d52" translate="yes" xml:space="preserve">
          <source>At the risk of stating the obvious, modules are intended to be modular. A Perl developer should be able to use modules to put together the building blocks of their application. However, it's important that the blocks are the right shape, and that the developer shouldn't have to use a big block when all they need is a small one.</source>
          <target state="translated">当たり前のことを述べる危険を冒して、モジュールはモジュールであることを意図しています。Perl の開発者は、モジュールを使ってアプリケーションの構成要素を組み立てることができるはずです。しかし、ブロックが正しい形であることが重要であり、開発者が必要とするのは小さなブロックだけなのに、大きなブロックを使う必要はありません。</target>
        </trans-unit>
        <trans-unit id="d2c548d72452435d78a5e713661472ad87fa3347" translate="yes" xml:space="preserve">
          <source>At the time of this writing (2009-03) there are three YAML implementations working: YAML, YAML::Syck, and YAML::XS. The latter two are faster but need a C compiler installed on your system. There may be more alternative YAML conforming modules. When I tried two other players, YAML::Tiny and YAML::Perl, they seemed not powerful enough to work with CPAN.pm. This may have changed in the meantime.</source>
          <target state="translated">この記事を書いている時点(2009-03)では、3つのYAML実装が動作しています。YAML,YAML::Syck,そしてYAML::XSです。後者の2つはより高速ですが、システムにCコンパイラをインストールする必要があります。他にもYAMLに準拠したモジュールがあるかもしれません。YAML::Tiny と YAML::Perl を試してみましたが、CPAN.pm で動作させるには十分な性能を持っていませんでした。これはその間に変更されたかもしれません。</target>
        </trans-unit>
        <trans-unit id="7ea634c02baa48b31e81ed3a00831f7dcbb2e678" translate="yes" xml:space="preserve">
          <source>At the time of this writing (June 2002), there is a known bug in the Tru64 libc printing of long doubles when not using &quot;e&quot; notation. The values are correct and usable, but you only get a limited number of digits displayed unless you force the issue by using &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;
&quot;%.33e&quot;,$num&lt;/code&gt; or the like. For Tru64 versions V5.0A through V5.1A, a patch is expected sometime after perl 5.8.0 is released. If your libc has not yet been patched, you'll get a warning from Configure when selecting long doubles.</source>
          <target state="translated">この記事の執筆時（2002年6月）には、 &quot;e&quot;表記を使用しない場合のロングダブルのTru64 libc印刷に既知のバグがあります。値は正確で使用可能ですが、 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; &quot;%.33e&quot;,$num&lt;/code&gt; などを使用して問題を強制しない限り、表示される桁数は限られています。Tru64バージョンV5.0AからV5.1Aの場合、perl 5.8.0のリリース後にパッチがリリースされる予定です。libcにパッチがまだ適用されていない場合、長いdoubleを選択すると、Configureから警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="1867a801fe6f9af5a7aceadb824f2be69014eb61" translate="yes" xml:space="preserve">
          <source>At the time of this writing, Perl 5.18.0 is considered to be well-hardened against algorithmic complexity attacks on its hash implementation. This is largely owed to the following measures mitigate attacks:</source>
          <target state="translated">この記事を書いている時点では、Perl 5.18.0 はそのハッシュ実装に対するアルゴリズムの複雑さに対する攻撃に対して十分に強化されていると考えられています。これは主に、以下のような攻撃を軽減するための対策によるものです。</target>
        </trans-unit>
        <trans-unit id="8a33c676d1f79e763827316ea86000a157f0da7a" translate="yes" xml:space="preserve">
          <source>At the time of very final cleanup, sv_free_arenas() is called from perl_destruct() to physically free all the arenas allocated since the start of the interpreter.</source>
          <target state="translated">最終的なクリーンアップの際に、Perl_destruct()から sv_free_arenas()が呼び出され、インタープリタの起動時から割り当てられたすべてのアリーナを物理的に解放します。</target>
        </trans-unit>
        <trans-unit id="4ad7685293e30733157e0b0115df9c2bbc818321" translate="yes" xml:space="preserve">
          <source>At the time that f is created, it can't capture the current &quot;a&quot; sub, since the anonymous subroutine hasn't been created yet. Conversely, the following won't give a warning since the anonymous subroutine has by now been created and is live:</source>
          <target state="translated">fが作成された時点では、匿名サブルーチンがまだ作成されていないので、現在の &quot;a &quot;サブをキャプチャすることはできません。逆に、匿名サブルーチンは今までに作成されて生きているので、次のような警告は出ません。</target>
        </trans-unit>
        <trans-unit id="c7f753fb79bacf696f44e6edc3ce403746b9d93b" translate="yes" xml:space="preserve">
          <source>At the time that f is created, it can't capture the current value of $a, since the anonymous subroutine hasn't been created yet. Conversely, the following won't give a warning since the anonymous subroutine has by now been created and is live:</source>
          <target state="translated">fが作成された時点では、匿名サブルーチンはまだ作成されていないので、$aの現在の値を捕捉することはできません。逆に、匿名サブルーチンは今までに作成されていて生きているので、次のような警告は出ません。</target>
        </trans-unit>
        <trans-unit id="9d72f28fef349b76a0adf7f5f7156e5e3f38d89f" translate="yes" xml:space="preserve">
          <source>At the time this document was last updated, Cygwin 1.7.16 was current.</source>
          <target state="translated">このドキュメントが最後に更新された時点では、Cygwin 1.7.16が最新のものでした。</target>
        </trans-unit>
        <trans-unit id="568132008f8ee29811084c20ba8f801b1aedb463" translate="yes" xml:space="preserve">
          <source>At the very least, this is useful to see what the SelfLoader thinks are stubs - in order to ensure future versions of the SelfStubber remain in step with the SelfLoader, the SelfStubber actually uses the SelfLoader to determine which stubs are needed.</source>
          <target state="translated">少なくとも、これはSelfLoaderが何をスタブだと考えているのかを確認するのに役立つ。</target>
        </trans-unit>
        <trans-unit id="4c88d3fd177dc36a169a0f390f88ed358e376c27" translate="yes" xml:space="preserve">
          <source>At the very minimum, any subclass will need to provide its own &lt;code&gt;new()&lt;/code&gt; and can store additional hash keys in the object. There are also some package globals that must be defined, e.g.:</source>
          <target state="translated">最低でも、サブクラスは独自の &lt;code&gt;new()&lt;/code&gt; を提供する必要があり、オブジェクトに追加のハッシュキーを格納できます。定義する必要があるいくつかのパッケージグローバルもあります。例：</target>
        </trans-unit>
        <trans-unit id="edcf8fa241edee8ba6be389a9320a43680a858f9" translate="yes" xml:space="preserve">
          <source>At this point, if you're using the</source>
          <target state="translated">この時点で、もしあなたが</target>
        </trans-unit>
        <trans-unit id="5a6511c6f50957ea6c619917499bccc60b76c492" translate="yes" xml:space="preserve">
          <source>At this point, we have all the basic regexp concepts covered, so let's give a more involved example of a regular expression. We will build a regexp that matches numbers.</source>
          <target state="translated">この時点で、基本的な正規表現の概念はすべてカバーしているので、より複雑な正規表現の例を挙げてみましょう。ここでは、数字にマッチする正規表現を作っていきます。</target>
        </trans-unit>
        <trans-unit id="370a5cf660692a42903691231af5dc8e0071bc25" translate="yes" xml:space="preserve">
          <source>At this point, xsubpp is doing very little work - the differences between Mytest.xs and Mytest.c are minimal.</source>
          <target state="translated">この時点では、xsubpp はほとんど仕事をしていません-Mytest.xs と Mytest.c の違いは最小限です。</target>
        </trans-unit>
        <trans-unit id="6e93ae94dda2105286d8d2c3c0189888d8aa45b7" translate="yes" xml:space="preserve">
          <source>At time of writing, &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; values are of two types: either the name of a Pod page like &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; (which might be a real Perl module or program in an @INC / PATH directory, or a .pod file in those places); or the name of a Unix man page, like &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; . In theory, &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; in ambiguous between a Pod page called &quot;chmod&quot;, or the Unix man page &quot;chmod&quot; (in whatever man-section). However, the presence of a string in parens, as in &quot;crontab(5)&quot;, is sufficient to signal that what is being discussed is not a Pod page, and so is presumably a Unix man page. The distinction is of no importance to many Pod processors, but some processors that render to hypertext formats may need to distinguish them in order to know how to render a given &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; code.</source>
          <target state="translated">執筆時点では、 &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; 値には2つのタイプがあります &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; ようなポッドページの名前（@INC / PATHディレクトリ内の実際のPerlモジュールまたはプログラムであるか、またはそれらの場所の.podファイル）;または &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; ようなUnix manページの名前。理論的には、 &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; は、「chmod」と呼ばれるポッドページ、またはUnixのマニュアルページ「chmod」（どのmanセクションでも）のあいまいです。ただし、「crontab（5）」のように、括弧内の文字列の存在は、議論されているものがPodページではなく、おそらくUnixのmanページであることを示すには十分です。区別は多くのポッドプロセッサにとって重要ではありません。しかし、ハイパーテキスト形式にレンダリングする一部のプロセッサは、特定のレンダリング方法を知るためにそれらを区別する必要がある場合があります &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; コード。</target>
        </trans-unit>
        <trans-unit id="d759da54d18d185bb5ccfc037b889a6ccc296532" translate="yes" xml:space="preserve">
          <source>Attach the shared memory segment identified by ID to the address space of the calling process. See &lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat&lt;/a&gt;.</source>
          <target state="translated">IDで識別される共有メモリセグメントを呼び出しプロセスのアドレス空間に接続します。&lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmatを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="225d31a7a030cd02427cb0b7456aa1f815b2914d" translate="yes" xml:space="preserve">
          <source>Attaching &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; to arrays is permissible but has no effect.</source>
          <target state="translated">&lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; を配列に接続することは許可されていますが、効果はありません。</target>
        </trans-unit>
        <trans-unit id="d423c0cfec188bd6ee98e700b49e9beb58a1ac55" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication.</source>
          <target state="translated">SASL認証を試みます。</target>
        </trans-unit>
        <trans-unit id="a57d83a2b0e335a567209ea75d9a6f7c18c72eb5" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication. Requires Authen::SASL module.</source>
          <target state="translated">SASL 認証を試みます。Authen::SASL モジュールが必要です。</target>
        </trans-unit>
        <trans-unit id="0bfa31d2d4671313bd0af54f4bb1d33e8b3d1352" translate="yes" xml:space="preserve">
          <source>Attempt to change directory to the directory given in &lt;code&gt;$dir&lt;/code&gt; . If &lt;code&gt;$dir&lt;/code&gt; is &lt;code&gt;&quot;..&quot;&lt;/code&gt; , the FTP &lt;code&gt;CDUP&lt;/code&gt; command is used to attempt to move up one directory. If no directory is given then an attempt is made to change the directory to the root directory.</source>
          <target state="translated">&lt;code&gt;$dir&lt;/code&gt; 指定されたディレクトリにディレクトリを変更しようとします。場合は &lt;code&gt;$dir&lt;/code&gt; ある &lt;code&gt;&quot;..&quot;&lt;/code&gt; 、FTP &lt;code&gt;CDUP&lt;/code&gt; のコマンドは、1つ上のディレクトリに移動しようとするために使用されます。ディレクトリが指定されていない場合は、ディレクトリをルートディレクトリに変更しようとします。</target>
        </trans-unit>
        <trans-unit id="f1a553fb01152c680db2f1ac04b66addb3e1a32b" translate="yes" xml:space="preserve">
          <source>Attempt to convert an absolute file specification to a relative specification.</source>
          <target state="translated">絶対ファイル指定を相対指定に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="c6a6104d31483a82798cc43a56c3040f5b0e5915" translate="yes" xml:space="preserve">
          <source>Attempt to destroy all objects not yet freed.</source>
          <target state="translated">まだ解放されていないすべてのオブジェクトを破壊しようとします。</target>
        </trans-unit>
        <trans-unit id="fe99a6ee8775c38ae61fdc7b8491eb15dc3ce181" translate="yes" xml:space="preserve">
          <source>Attempt to evaluate the current host's internet name and domain</source>
          <target state="translated">現在のホストのインターネット名とドメインの評価を試みる</target>
        </trans-unit>
        <trans-unit id="078cb982d4d92298b47355c08e74e2f224c181c7" translate="yes" xml:space="preserve">
          <source>Attempt to print summary information if run is interrupted by SIGINT (Ctrl-C).</source>
          <target state="translated">SIGINT(Ctrl-C)で実行が中断された場合、サマリー情報の印刷を試みます。</target>
        </trans-unit>
        <trans-unit id="b914600bb82ac0ae87b3e9ab97d2d1c2f3efb3a8" translate="yes" xml:space="preserve">
          <source>Attempt to produce color output.</source>
          <target state="translated">カラー出力を試みる。</target>
        </trans-unit>
        <trans-unit id="efb3613b13587fe1f93cf60bf899f24390374124" translate="yes" xml:space="preserve">
          <source>Attempt to read &lt;code&gt;$length&lt;/code&gt; bytes of uncompressed data into &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$length&lt;/code&gt; バイトの非圧縮データを &lt;code&gt;$buffer&lt;/code&gt; に読み取ろうとしました。</target>
        </trans-unit>
        <trans-unit id="5b92f951c7fd86ee7f7ec9db2ae7b702bd512a11" translate="yes" xml:space="preserve">
          <source>Attempting to inherit from yourself generates a warning.</source>
          <target state="translated">自分自身から継承しようとすると警告が発生します。</target>
        </trans-unit>
        <trans-unit id="940068c4484917346e58cd849ab63ab658a04374" translate="yes" xml:space="preserve">
          <source>Attempting to pack the special floating point values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity, also in negative, and not-a-number) into packed integer values (like &lt;code&gt;&quot;L&quot;&lt;/code&gt; ) is a fatal error. The reason for this is that there simply isn't any sensible mapping for these special values into integers.</source>
          <target state="translated">特殊な浮動小数点値 &lt;code&gt;Inf&lt;/code&gt; と &lt;code&gt;NaN&lt;/code&gt; （無限大、負で、非数）をパックされた整数値（ &lt;code&gt;&quot;L&quot;&lt;/code&gt; など）にパックしようとすると、致命的なエラーになります。これは、これらの特別な値から整数への適切なマッピングがないためです。</target>
        </trans-unit>
        <trans-unit id="6015d4f519177c33ba06ab08404701540b4f2048" translate="yes" xml:space="preserve">
          <source>Attempting to reopen a database without closing it.</source>
          <target state="translated">データベースを閉じずに再オープンしようとする。</target>
        </trans-unit>
        <trans-unit id="0bedf74043c203b86c1b5363d305f57a4b0c5fcb" translate="yes" xml:space="preserve">
          <source>Attempts several methods of getting the system hostname and then caches the result. It tries the first available of the C library's gethostname(), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; , uname(2), &lt;code&gt;&lt;a href=&quot;../functions/syscall&quot;&gt;syscall(SYS_gethostname)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;`hostname`&lt;/code&gt; , &lt;code&gt;`uname -n`&lt;/code&gt; , and the file</source>
          <target state="translated">システムのホスト名を取得するいくつかの方法を試み、その結果をキャッシュします。Cライブラリのgethostname（）、 &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; 、uname（2）、 &lt;code&gt;&lt;a href=&quot;../functions/syscall&quot;&gt;syscall(SYS_gethostname)&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;`hostname`&lt;/code&gt; 、 &lt;code&gt;`uname -n`&lt;/code&gt; 、およびファイルの最初に利用可能なものを試します</target>
        </trans-unit>
        <trans-unit id="f998d3cd38777ee213006cd15fb0e0f6d2ddc7f7" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like connect(2). Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">connect（2）と同様に、リモートソケットへの接続を試みます。成功した場合はtrue、それ以外の場合はfalseを返します。 NAMEは、ソケットに適したタイプのパックアドレスでなければなりません。 「&lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;ソケット：perlipcのクライアント/サーバー通信&lt;/a&gt;」の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="64769a075153327a39fd4f2723d3853f980fe471" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like connect(2). Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">connect（2）と同様に、リモートソケットへの接続を試みます。成功した場合はtrue、それ以外の場合はfalseを返します。 NAMEは、ソケットに適したタイプのパックアドレスでなければなりません。 「&lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;ソケット：perlipcのクライアント/サーバー通信&lt;/a&gt;」の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="4a0ddb935c0376b494edd76deb21d2e9aa4a1612" translate="yes" xml:space="preserve">
          <source>Attempts to convert in-place the octet sequence encoded as</source>
          <target state="translated">としてエンコードされたオクテット列のインプレース変換を試みます。</target>
        </trans-unit>
        <trans-unit id="bd9b4f39078d108026008c73a3d153cb14bae4bd" translate="yes" xml:space="preserve">
          <source>Attempts to convert the PV of an SV from characters to bytes. If the PV contains a character that cannot fit in a byte, this conversion will fail; in this case, either returns false or, if &lt;code&gt;fail_ok&lt;/code&gt; is not true, croaks.</source>
          <target state="translated">SVのPVを文字からバイトに変換しようとします。 PVにバイトに収まらない文字が含まれている場合、この変換は失敗します。この場合、falseを返すか、 &lt;code&gt;fail_ok&lt;/code&gt; がtrueでない場合はcroaksを返します。</target>
        </trans-unit>
        <trans-unit id="64d7ec66819a9007136707554fdc8dbbef9567aa" translate="yes" xml:space="preserve">
          <source>Attempts to determine if a given host is outside your firewall. Possible return values are.</source>
          <target state="translated">指定されたホストがファイアウォールの外にあるかどうかを判定します。返り値は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="015e99d4e0b5f5661a89b0c851595de01de6cc85" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH</source>
          <target state="translated">LENGTHの読み取りを試みます。</target>
        </trans-unit>
        <trans-unit id="623d8fbf82dc2fdc9694f6bbe91f1257bb25f69a" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using the read(2). It bypasses buffered IO, so mixing this with other kinds of reads, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; can cause confusion because the perlio or stdio layers usually buffers data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;code&gt;$!&lt;/code&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">read（2）を使用して、指定されたFILEHANDLEからデータのLENGTHバイトを変数SCALARに読み取ろうとします。バッファリングされたIOをバイパスするため、これを他の種類の読み取り、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; と混合すると、perlioまたはstdioレイヤーが通常データをバッファーするため、混乱が生じる可能性があります。実際に読み取られたバイト数、ファイルの終わりでは &lt;code&gt;0&lt;/code&gt; を返します。エラーが発生した場合はundefを返します（後者の場合は &lt;code&gt;$!&lt;/code&gt; も設定されます）。 SCALARは拡大または縮小され、実際に読み取られた最後のバイトは、読み取り後のスカラーの最後のバイトになります。</target>
        </trans-unit>
        <trans-unit id="321c64867646f812228d15e7d459f8fc1a5c1183" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using the read(2). It bypasses buffered IO, so mixing this with other kinds of reads, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; can cause confusion because the perlio or stdio layers usually buffers data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;code&gt;$!&lt;/code&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">read（2）を使用して、指定されたFILEHANDLEからデータのLENGTHバイトを変数SCALARに読み取ろうとします。バッファリングされたIOをバイパスするため、これを他の種類の読み取り、 &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; と混合すると、perlioまたはstdioレイヤーが通常データをバッファーするため、混乱が生じる可能性があります。実際に読み取られたバイト数、ファイルの終わりでは &lt;code&gt;0&lt;/code&gt; を返します。エラーが発生した場合はundefを返します（後者の場合は &lt;code&gt;$!&lt;/code&gt; も設定されます）。 SCALARは拡大または縮小され、実際に読み取られた最後のバイトは、読み取り後のスカラーの最後のバイトになります。</target>
        </trans-unit>
        <trans-unit id="056c7c4b49d09bfb10b608aa560ae7f329c94639" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using write(2). If LENGTH is not specified, writes whole SCALAR. It bypasses buffered IO, so mixing this with reads (other than &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion because the perlio and stdio layers usually buffer data. Returns the number of bytes actually written, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there was an error (in this case the errno variable &lt;code&gt;$!&lt;/code&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">write（2）を使用して、変数SCALARから指定されたFILEHANDLEにLENGTHバイトのデータを書き込もうとします。 LENGTHが指定されていない場合、SCALAR全体を書き込みます。バッファリングされたIOをバイパスするため、これを読み取り（ &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt; 以外）、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; と混合すると、perlioおよびstdioレイヤーが通常データをバッファーするため、混乱が生じる可能性があります。実際に書き込まれたバイト数を返します。エラーが発生した場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します（この場合、errno変数 &lt;code&gt;$!&lt;/code&gt; も設定されます）。 LENGTHがOFFSET後にSCALARで使用可能なデータよりも大きい場合、使用可能なデータだけが書き込まれます。</target>
        </trans-unit>
        <trans-unit id="bf935c85345c3169ffc0b395c956f17c45a9fe82" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using write(2). If LENGTH is not specified, writes whole SCALAR. It bypasses buffered IO, so mixing this with reads (other than &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion because the perlio and stdio layers usually buffer data. Returns the number of bytes actually written, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there was an error (in this case the errno variable &lt;code&gt;$!&lt;/code&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">write（2）を使用して、変数SCALARから指定されたFILEHANDLEにLENGTHバイトのデータを書き込もうとします。 LENGTHが指定されていない場合、SCALAR全体を書き込みます。バッファリングされたIOをバイパスするため、これを読み取り（ &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt; 以外）、 &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; と混合すると、perlioおよびstdioレイヤーが通常データをバッファーするため、混乱が生じる可能性があります。実際に書き込まれたバイト数を返します。エラーが発生した場合は &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します（この場合、errno変数 &lt;code&gt;$!&lt;/code&gt; も設定されます）。 LENGTHがOFFSET後にSCALARで使用可能なデータよりも大きい場合、使用可能なデータだけが書き込まれます。</target>
        </trans-unit>
        <trans-unit id="cf2ad2263d9deded93137fc6e93270ce22633fb0" translate="yes" xml:space="preserve">
          <source>Attempts word completion. Cannot be changed.</source>
          <target state="translated">単語の補完を試みます。変更はできません。</target>
        </trans-unit>
        <trans-unit id="402319da749127eab7373ce69945d35452ea82aa" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers</source>
          <target state="translated">Attribute::Handlers</target>
        </trans-unit>
        <trans-unit id="ab429cb97f17abf9bda7af427a4ab75a270a8eee" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers - Simpler definition of attribute handlers</source>
          <target state="translated">Attribute::Handlers-属性ハンドラのシンプルな定義</target>
        </trans-unit>
        <trans-unit id="1c8c525e5ee86dfc71e9832b4cad7c5124dad809" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers makes strenuous efforts to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt; ) to a usable form before passing it to the handler (but see &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;Non-interpretive attribute handlers&lt;/a&gt;). If those efforts succeed, the interpreted data is passed in an array reference; if they fail, the raw data is passed as a string. For example, all of these:</source>
          <target state="translated">Attribute :: Handlersは、データ引数（ &lt;code&gt;$_[4]&lt;/code&gt; ）をハンドラーに渡す前に、使用可能な形式に変換するように努力しています（ただし、&lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;非解釈属性ハンドラーを&lt;/a&gt;参照）。これらの取り組みが成功すると、解釈されたデータは配列参照で渡されます。失敗した場合、生データは文字列として渡されます。たとえば、次のすべて：</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="7096373d5156eb6bd0032a6f3f3f6f2306181c31" translate="yes" xml:space="preserve">
          <source>Attributes are often stored in the object itself. For example, if the object is an anonymous hash, we can store the attribute values in the hash using the attribute name as the key.</source>
          <target state="translated">属性はオブジェクト自体に格納されることが多いです。例えば、オブジェクトが匿名ハッシュであれば、属性名をキーにしてハッシュに属性値を格納することができます。</target>
        </trans-unit>
        <trans-unit id="1ec0e5f9458a3d0b7666b49e580f1e144a9409de" translate="yes" xml:space="preserve">
          <source>Attributes are typically defined as read-only or read-write. Read-only attributes can only be set when the object is first created, while read-write attributes can be altered at any time.</source>
          <target state="translated">属性は通常、リードオンリーまたはリードライトとして定義されます。読み取り専用属性はオブジェクトが最初に作成されたときにのみ設定でき、読み書き属性はいつでも変更できます。</target>
        </trans-unit>
        <trans-unit id="e7c79e72c9cbf686713260fcf1aae8a2f9a1a49e" translate="yes" xml:space="preserve">
          <source>Attributes as &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; interfaces</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; インターフェースとしての属性</target>
        </trans-unit>
        <trans-unit id="6e1c2a2200f4dc51bc987e61b1d0f256256aa8d5" translate="yes" xml:space="preserve">
          <source>Attributes as tie interfaces</source>
          <target state="translated">タイインターフェースとしての属性</target>
        </trans-unit>
        <trans-unit id="5d582f3d2d463609c927f60d4eb884597e89efea" translate="yes" xml:space="preserve">
          <source>Attributes make an excellent and intuitive interface through which to tie variables. For example:</source>
          <target state="translated">属性は、変数を結びつけるための優れた直感的なインターフェースを提供します。例えば</target>
        </trans-unit>
        <trans-unit id="508a5aa4d3d540c30ef29d403ada44bf44ff7142" translate="yes" xml:space="preserve">
          <source>Attributes, once set, last until they are unset (by printing the attribute &lt;code&gt;clear&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt;). Be careful to do this, or otherwise your attribute will last after your script is done running, and people get very annoyed at having their prompt and typing changed to weird colors.</source>
          <target state="translated">属性は、一度設定されると、それらが設定解除されるまで（属性 &lt;code&gt;clear&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; を出力して）持続します。これを行うように注意してください。そうしないと、スクリプトの実行が終了した後も属性が残り、人々はプロンプトと入力を奇妙な色に変更することに非常に悩まされます。</target>
        </trans-unit>
        <trans-unit id="1874e0336adde0a00ba3a60dae1dc775409600bd" translate="yes" xml:space="preserve">
          <source>Audrey Tang &amp;lt;cpan@audreyt.org&amp;gt;</source>
          <target state="translated">オードリー・タン&amp;lt;cpan@audreyt.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="21c24cd01488e77938199d2e43d1c1e07248317d" translate="yes" xml:space="preserve">
          <source>Authenticate with the server identifying as &lt;code&gt;USER&lt;/code&gt; with password &lt;code&gt;PASS&lt;/code&gt; . Similar to &lt;a href=&quot;#login&quot;&gt;login&lt;/a&gt;, but the password is not sent in clear text.</source>
          <target state="translated">パスワードが &lt;code&gt;PASS&lt;/code&gt; の &lt;code&gt;USER&lt;/code&gt; として識別されるサーバーで認証します。&lt;a href=&quot;#login&quot;&gt;login&lt;/a&gt;に似ていますが、パスワードはクリアテキストでは送信されません。</target>
        </trans-unit>
        <trans-unit id="507f24ee32e393058ec2717e7ff642ddf8b1dd65" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the original AUTHINFO USER / AUTHINFO PASS form, defined in RFC2980) using the supplied username and password. Please note that the password is sent in clear text to the server. This command should not be used with valuable passwords unless the connection to the server is somehow protected.</source>
          <target state="translated">指定されたユーザー名とパスワードを使用して、(RFC2980 で定義されているオリジナルの AUTHINFO USER/AUTHINFO PASS フォームを使用して)サーバーを認証します。パスワードはクリアテキストでサーバーに送信されることに注意してください。サーバーへの接続が何らかの方法で保護されていない限り、このコマンドは貴重なパスワードと一緒に使用すべきではありません。</target>
        </trans-unit>
        <trans-unit id="6f9130bcae1a2dee757ab825f2972f22149b8d0e" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the proposed NNTP V2 AUTHINFO SIMPLE form, defined and deprecated in RFC2980) using the supplied username and password. As with &lt;a href=&quot;#authinfo&quot;&gt;authinfo&lt;/a&gt; the password is sent in clear text.</source>
          <target state="translated">提供されたユーザー名とパスワードを使用して、サーバーに認証します（RFC2980で定義され、非推奨のNNTP V2 AUTHINFO SIMPLE形式を使用）&lt;a href=&quot;#authinfo&quot;&gt;authinfo&lt;/a&gt;と同様に、パスワードはクリアテキストで送信されます。</target>
        </trans-unit>
        <trans-unit id="561e59b47284192d792d6315e83a8df1bb4623e9" translate="yes" xml:space="preserve">
          <source>Authentication, Security, and Encryption</source>
          <target state="translated">認証、セキュリティ、暗号化</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="fd140dad60fa77aa1adfbcd64d1e9ea4bc89ff62" translate="yes" xml:space="preserve">
          <source>Author and Maintainer: The Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</source>
          <target state="translated">作者とメンテナー：Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e41e820954a6b297983a7b6986adfdc7c083ed60" translate="yes" xml:space="preserve">
          <source>Author and Modification History</source>
          <target state="translated">作者と改造履歴</target>
        </trans-unit>
        <trans-unit id="dc4e711f40af1fee4327bcbd34d91d11e1b38a81" translate="yes" xml:space="preserve">
          <source>Author of this software makes no claim whatsoever about suitability, reliability, edability, editability or usability of this product, and should not be kept liable for any damage resulting from the use of it. If you can use it, you are in luck, if not, I should not be kept responsible. Keep a handy copy of your backup tape at hand.</source>
          <target state="translated">本ソフトウェアの作者は、本製品の適合性、信頼性、編集性、編集性、使用性について何ら主張するものではなく、本製品を使用したことにより生じたいかなる損害についても責任を負うものではありません。あなたがそれを使用することができれば、あなたは幸運ですが、そうでない場合は、私は責任を負うべきではありません。手元にバックアップテープの便利なコピーを置いておきましょう。</target>
        </trans-unit>
        <trans-unit id="75a1f723a2c00ab3f9e540ebe5e3b630e531e2c3" translate="yes" xml:space="preserve">
          <source>Author: Mark Jason Dominus, Plover Systems (&lt;code&gt;mjd-perl-&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;+@plover.com&lt;/code&gt; )</source>
          <target state="translated">著者：Mark Jason Dominus、Plover Systems（ &lt;code&gt;mjd-perl-&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;+@plover.com&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="d2a52548bd0852b99153ddd79a1f550f70674c7d" translate="yes" xml:space="preserve">
          <source>Authors</source>
          <target state="translated">Authors</target>
        </trans-unit>
        <trans-unit id="4e4bc3d81e572248f45b55f87eb6a695cc5d7e17" translate="yes" xml:space="preserve">
          <source>Authors must not nest L&amp;lt;...&amp;gt; codes. For example, &quot;L&amp;lt;The L&amp;lt;Foo::Bar&amp;gt; man page&amp;gt;&quot; should be treated as an error.</source>
          <target state="translated">著者はL &amp;lt;...&amp;gt;コードをネストしてはなりません。たとえば、「L &amp;lt;The L &amp;lt;Foo :: Bar&amp;gt; man page&amp;gt;」はエラーとして扱われます。</target>
        </trans-unit>
        <trans-unit id="9a1f2888146e0b82120ccf28bf4584779813130b" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters are reminded that &quot;=over&quot; ... &quot;=back&quot; may map to several different constructs in your output format. For example, in converting Pod to (X)HTML, it can map to any of &amp;lt;ul&amp;gt;...&amp;lt;/ul&amp;gt;, &amp;lt;ol&amp;gt;...&amp;lt;/ol&amp;gt;, &amp;lt;dl&amp;gt;...&amp;lt;/dl&amp;gt;, or &amp;lt;blockquote&amp;gt;...&amp;lt;/blockquote&amp;gt;. Similarly, &quot;=item&quot; can map to &amp;lt;li&amp;gt; or &amp;lt;dt&amp;gt;.</source>
          <target state="translated">ポッドフォーマッタの作成者は、「= over」...「= back」が出力フォーマットのいくつかの異なる構成にマッピングされる可能性があることに注意してください。たとえば、ポッドを（X）HTMLに変換すると、&amp;lt;ul&amp;gt; ... &amp;lt;/ ul&amp;gt;、&amp;lt;ol&amp;gt; ... &amp;lt;/ ol&amp;gt;、&amp;lt;dl&amp;gt; ... &amp;lt;/ dl&amp;gt;のいずれかにマップできます、または&amp;lt;blockquote&amp;gt; ... &amp;lt;/ blockquote&amp;gt;。同様に、「= item」は&amp;lt;li&amp;gt;または&amp;lt;dt&amp;gt;にマップできます。</target>
        </trans-unit>
        <trans-unit id="80bad0a974c0d7ed8e69ae0a2451cf949509d806" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters should note that this construct:</source>
          <target state="translated">Podフォーマッタの著者は、この構成に注意すべきである。</target>
        </trans-unit>
        <trans-unit id="0772af8ca884a475bc6c000e8a2e7ecd3771d821" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters/processors should make every effort to avoid writing their own Pod parser. There are already several in CPAN, with a wide range of interface styles -- and one of them, Pod::Parser, comes with modern versions of Perl.</source>
          <target state="translated">Podフォーマッタ/プロセッサの作者は、独自のPodパーサを書かないように努力すべきです。CPANにはすでにいくつかのインターフェイススタイルを持つものがあり、そのうちの一つであるPod::Parserは最新版のPerlに付属しています。</target>
        </trans-unit>
        <trans-unit id="5f5a6b2c86d1c842fb78879cb9847a9b86de0e1d" translate="yes" xml:space="preserve">
          <source>Authors of formatter subclasses might find these methods useful to call on a parser object that you haven't started pulling tokens from yet:</source>
          <target state="translated">フォーマッタのサブクラスの作者は、まだトークンを取り出し始めていないパーサオブジェクトを呼び出すのに便利なメソッドを見つけられるかもしれません。</target>
        </trans-unit>
        <trans-unit id="ba749f31a8ceaa34419e1f1f52af7da1b1065181" translate="yes" xml:space="preserve">
          <source>Auto-decrement of the value in the SV, doing string to numeric conversion if necessary. Handles 'get' magic and operator overloading.</source>
          <target state="translated">必要に応じて文字列から数値への変換を行います。get' マジックと演算子のオーバーロードを処理します。</target>
        </trans-unit>
        <trans-unit id="cabef034701dc195b619657e11c47b3b4c7ed2cb" translate="yes" xml:space="preserve">
          <source>Auto-decrement of the value in the SV, doing string to numeric conversion if necessary. Handles operator overloading. Skips handling 'get' magic.</source>
          <target state="translated">必要に応じて文字列から数値への変換を行います。演算子のオーバーロードを扱う。get' マジックの処理をスキップします。</target>
        </trans-unit>
        <trans-unit id="f8df54de50b8630f73dd7c3210d2ed53c7051734" translate="yes" xml:space="preserve">
          <source>Auto-increment and Auto-decrement</source>
          <target state="translated">オートインクリメントとオートデクリメント</target>
        </trans-unit>
        <trans-unit id="9c2549c4f8e7b5156ddcd16c47fe624753b70037" translate="yes" xml:space="preserve">
          <source>Auto-increment of the value in the SV, doing string to numeric conversion if necessary. Handles 'get' magic and operator overloading.</source>
          <target state="translated">SV内の値をオートインクリメントし、必要に応じて文字列から数値への変換を行います。get' マジックと演算子のオーバーロードを処理します。</target>
        </trans-unit>
        <trans-unit id="11123412c221a7c2bf77f34ba93ea1498be1bd77" translate="yes" xml:space="preserve">
          <source>Auto-increment of the value in the SV, doing string to numeric conversion if necessary. Handles operator overloading. Skips handling 'get' magic.</source>
          <target state="translated">必要に応じて文字列から数値への変換を行います。演算子のオーバーロードを扱う。get' マジックの処理をスキップします。</target>
        </trans-unit>
        <trans-unit id="95b64723d9f40505396f5971cbc44d69372e59a7" translate="yes" xml:space="preserve">
          <source>Auto-upgrade</source>
          <target state="translated">Auto-upgrade</target>
        </trans-unit>
        <trans-unit id="57a4f42cae4d12771bda9f458a5b76498da8ce37" translate="yes" xml:space="preserve">
          <source>AutoLoader</source>
          <target state="translated">AutoLoader</target>
        </trans-unit>
        <trans-unit id="4bbd7ae289ef059e5890696f9cb149721a7b8e69" translate="yes" xml:space="preserve">
          <source>AutoLoader - load subroutines only on demand</source>
          <target state="translated">AutoLoader-要求に応じてサブルーチンのみをロードします。</target>
        </trans-unit>
        <trans-unit id="6851ab5ce9e022d9cc5797875048cf4a3f08af3e" translate="yes" xml:space="preserve">
          <source>AutoLoader may fail to find the autosplit files (or even find the wrong ones) in cases where &lt;code&gt;@INC&lt;/code&gt; contains relative paths, &lt;b&gt;and&lt;/b&gt; the program does &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">オートローダーは自動splitファイルを見つけることができない（あるいは間違ったものを見つける。）の場合であり &lt;code&gt;@INC&lt;/code&gt; には相対パスが含まれ、&lt;b&gt;そして&lt;/b&gt;プログラムはありません &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a635037412af6ace383fa21d0d50db8f0393e57" translate="yes" xml:space="preserve">
          <source>AutoLoaders prior to Perl 5.002 had a slightly different interface. Any old modules which use &lt;b&gt;AutoLoader&lt;/b&gt; should be changed to the new calling style. Typically this just means changing a require to a use, adding the explicit &lt;code&gt;'AUTOLOAD'&lt;/code&gt; import if needed, and removing &lt;b&gt;AutoLoader&lt;/b&gt; from &lt;code&gt;@ISA&lt;/code&gt; .</source>
          <target state="translated">Perl 5.002より前のAutoLoaderのインターフェースは少し異なりました。&lt;b&gt;AutoLoader&lt;/b&gt;を使用する古いモジュールは、新しい呼び出しスタイルに変更する必要があります。通常、これは単にrequireをuseに変更し、必要に応じて明示的な &lt;code&gt;'AUTOLOAD'&lt;/code&gt; インポートを追加し、&lt;b&gt;@ ISA&lt;/b&gt;から &lt;code&gt;@ISA&lt;/code&gt; を削除することを意味します。</target>
        </trans-unit>
        <trans-unit id="56be52307d7f516628d0435d04dbf15ef2be8e1c" translate="yes" xml:space="preserve">
          <source>AutoSplit</source>
          <target state="translated">AutoSplit</target>
        </trans-unit>
        <trans-unit id="141ac9ea73e406af3a95ffd453d7845aea91bee3" translate="yes" xml:space="preserve">
          <source>AutoSplit - split a package for autoloading</source>
          <target state="translated">AutoSplit-オートロードのためにパッケージを分割する</target>
        </trans-unit>
        <trans-unit id="68a652cb711d8eb8f8b2dadb0dc16bdffbba498d" translate="yes" xml:space="preserve">
          <source>Autocreating constants</source>
          <target state="translated">定数の自動作成</target>
        </trans-unit>
        <trans-unit id="52fe0335e51acfb62f3dfd3073b3227b5b8c4846" translate="yes" xml:space="preserve">
          <source>Autodeferring</source>
          <target state="translated">Autodeferring</target>
        </trans-unit>
        <trans-unit id="f3589c4e74b1463fb3c579cd588ce9598fdbe87e" translate="yes" xml:space="preserve">
          <source>Autodie uses a simple set of categories to group together similar built-ins. Requesting a category type (starting with a colon) will enable autodie for all built-ins beneath that category. For example, requesting &lt;code&gt;:file&lt;/code&gt; will enable autodie for &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Autodieは単純なカテゴリのセットを使用して、類似の組み込みをグループ化します。カテゴリタイプ（コロンで始まる）を要求すると、そのカテゴリの下にあるすべての組み込みの自動ダイが有効になります。たとえば、 &lt;code&gt;:file&lt;/code&gt; を要求すると、 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; の自動ダイが有効になります。</target>
        </trans-unit>
        <trans-unit id="f410fe9b046b8c8a478048e83efc2672d42d3c9c" translate="yes" xml:space="preserve">
          <source>Autodying &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; will generate an exception if &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns false with any other error.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; が他のエラーでfalseを返す場合、 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; の自動編集は例外を生成します。</target>
        </trans-unit>
        <trans-unit id="3fa81ba949fafdad4688aed6d9380f82976ca9d7" translate="yes" xml:space="preserve">
          <source>Autoloading</source>
          <target state="translated">Autoloading</target>
        </trans-unit>
        <trans-unit id="a71f8461a563c747e56f2cb5fb124e64328506d5" translate="yes" xml:space="preserve">
          <source>Autoloading and package lexicals</source>
          <target state="translated">オートロードとパッケージ語彙</target>
        </trans-unit>
        <trans-unit id="24023d5e4bccdad4a40c403d058e7c856f75ea71" translate="yes" xml:space="preserve">
          <source>Autoloading with XSUBs</source>
          <target state="translated">XSUBを使ったオートロード</target>
        </trans-unit>
        <trans-unit id="ea5735f59ad896a38c6b806f8d8b02abba9762e7" translate="yes" xml:space="preserve">
          <source>Automatic binary installation</source>
          <target state="translated">バイナリの自動インストール</target>
        </trans-unit>
        <trans-unit id="b890d9b67b4f885e928a5dbcadc3dec7cd34f3ad" translate="yes" xml:space="preserve">
          <source>Automatically generate XSUBs basing on function declarations in the header file. The package &lt;code&gt;C::Scan&lt;/code&gt; should be installed. If this option is specified, the name of the header file may look like &lt;code&gt;NAME1,NAME2&lt;/code&gt; . In this case NAME1 is used instead of the specified string, but XSUBs are emitted only for the declarations included from file NAME2.</source>
          <target state="translated">ヘッダーファイルの関数宣言に基づいてXSUBを自動的に生成します。パッケージ &lt;code&gt;C::Scan&lt;/code&gt; がインストールされているはずです。このオプションが指定されている場合、ヘッダーファイルの名前は &lt;code&gt;NAME1,NAME2&lt;/code&gt; ようになります。この場合、指定された文字列の代わりにNAME1が使用されますが、XSUBはファイルNAME2からインクルードされた宣言に対してのみ発行されます。</target>
        </trans-unit>
        <trans-unit id="974a6c8e46a4b4db1ad3a13139d3950f13a09a91" translate="yes" xml:space="preserve">
          <source>Automatically provide support for the &lt;b&gt;--help&lt;/b&gt; and &lt;b&gt;-?&lt;/b&gt; options if the application did not specify a handler for this option itself.</source>
          <target state="translated">&lt;b&gt;--help&lt;/b&gt;および&lt;b&gt;-？の&lt;/b&gt;サポートを自動的に提供し&lt;b&gt;ます &lt;/b&gt;アプリケーションがこのオプション自体のハンドラーを指定しなかった場合のオプション。</target>
        </trans-unit>
        <trans-unit id="909a15529b11dbad33480554d0c112bc56821029" translate="yes" xml:space="preserve">
          <source>Automatically provide support for the &lt;b&gt;--version&lt;/b&gt; option if the application did not specify a handler for this option itself.</source>
          <target state="translated">アプリケーションがこのオプション自体のハンドラーを指定しなかった場合、&lt;b&gt;-version&lt;/b&gt;オプションのサポートを自動的に提供します。</target>
        </trans-unit>
        <trans-unit id="859ddcc1d54c8f56f6fc79d681322ff6800ab918" translate="yes" xml:space="preserve">
          <source>Autoties are most commonly used in the module to which they actually tie, and need to export their attributes to any module that calls them. To facilitate this, Attribute::Handlers recognizes a special &quot;pseudo-class&quot; -- &lt;code&gt;__CALLER__&lt;/code&gt; , which may be specified as the qualifier of an attribute:</source>
          <target state="translated">オートタイは、実際に結び付けられているモジュールで最も一般的に使用され、それらを呼び出すすべてのモジュールに属性をエクスポートする必要があります。これを容易にするために、Attribute :: &lt;code&gt;__CALLER__&lt;/code&gt; は特別な「疑似クラス」-__CALLER__を認識します。これは属性の修飾子として指定できます。</target>
        </trans-unit>
        <trans-unit id="c275699a9fcc5b1df221a4afe6ee0192241a51b8" translate="yes" xml:space="preserve">
          <source>Available Plugins</source>
          <target state="translated">利用可能なプラグイン</target>
        </trans-unit>
        <trans-unit id="a1689bbab8d96444cb240ecc94b27e3bd6e1fa9d" translate="yes" xml:space="preserve">
          <source>Available Subroutines</source>
          <target state="translated">利用可能なサブルーチン</target>
        </trans-unit>
        <trans-unit id="f8f5117038c185bf68b0bd33b349f9405e133955" translate="yes" xml:space="preserve">
          <source>Available exports</source>
          <target state="translated">利用可能な輸出</target>
        </trans-unit>
        <trans-unit id="00239624abff2fe9a2fd406296f776638259fff8" translate="yes" xml:space="preserve">
          <source>Available in Perls 5.8.1 and later. If set to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; , the pre-Perl-5.8.0 signal behaviour (which is immediate but unsafe) is restored. If set to &lt;code&gt;safe&lt;/code&gt; , then safe (but deferred) signals are used. See &lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals) in perlipc&lt;/a&gt;.</source>
          <target state="translated">Perl 5.8.1以降で使用できます。 &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; に設定すると、Perl-5.8.0より前のシグナル動作（即時ですが安全ではありません）が復元されます。 &lt;code&gt;safe&lt;/code&gt; に設定すると、安全な（ただし遅延した）信号が使用されます。&lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;perlipcの遅延信号（安全な信号）を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="06d7ad8e1c503f30109967f01a5055e60c428ad2" translate="yes" xml:space="preserve">
          <source>Available in version 2.22 and above.</source>
          <target state="translated">バージョン2.22以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="ca47c0994a656fab74100d8043c17430984bfc08" translate="yes" xml:space="preserve">
          <source>Available in version 2.32 and above</source>
          <target state="translated">バージョン2.32以上で利用可能</target>
        </trans-unit>
        <trans-unit id="6a2ef8d70aa0a54d8ffae1859cac80b4b3ca0c60" translate="yes" xml:space="preserve">
          <source>Available in version 2.66 and above.</source>
          <target state="translated">バージョン2.66以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="46f1e6d4a99c839646d86f37c67e8ce5c790c2f7" translate="yes" xml:space="preserve">
          <source>Available in version 2.77 and above.</source>
          <target state="translated">バージョン2.77以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="1ee0ed3a84dce710c7a16f8db82978050c4d2850" translate="yes" xml:space="preserve">
          <source>Available in version 2.99 and above.</source>
          <target state="translated">バージョン2.99以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="d74a27e4b35b5f01b8ce5c3169c1b5a135f15fe4" translate="yes" xml:space="preserve">
          <source>Available in version 3.00 and above.</source>
          <target state="translated">バージョン3.00以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="eb07b303f6d617426c6371968300dfb4f3ae0614" translate="yes" xml:space="preserve">
          <source>Available in version 6.31 and above.</source>
          <target state="translated">バージョン6.31以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="e2eb2ee2a8a2421e0f16491afdee27929c55a640" translate="yes" xml:space="preserve">
          <source>Available in version 6.46 and above.</source>
          <target state="translated">バージョン6.46以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="7b80e477803719c627e591ee3d93e9c48ad902d2" translate="yes" xml:space="preserve">
          <source>Available in version 6.48 and above.</source>
          <target state="translated">バージョン6.48以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="aec275cec443caa644465799fc156b88fcadd8ce" translate="yes" xml:space="preserve">
          <source>Available in version 6.52 and above.</source>
          <target state="translated">バージョン6.52以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="4c5736820a885b4b84bf41953dc520dbc9201d97" translate="yes" xml:space="preserve">
          <source>Available in version 6.5503 and above.</source>
          <target state="translated">バージョン6.5503以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="608b36cf2b4b343801fc146cfc4244281c6223d0" translate="yes" xml:space="preserve">
          <source>Available in version 6.64 and above.</source>
          <target state="translated">バージョン6.64以上で利用可能。</target>
        </trans-unit>
        <trans-unit id="0d6ce3bbbc75b8e9071a24da666baed09d9b758d" translate="yes" xml:space="preserve">
          <source>Available on 64 bit OpenVMS 8.2 and later. (VMS)</source>
          <target state="translated">64ビットのOpenVMS 8.2以降で利用可能。(VMS)</target>
        </trans-unit>
        <trans-unit id="61cd670e85d7eb394067cdccaf9865a921e8dfe4" translate="yes" xml:space="preserve">
          <source>Available only for socket handles, and it does what the &lt;code&gt;ioctlsocket()&lt;/code&gt; call in the Winsock API does. (Win32)</source>
          <target state="translated">ソケットハンドルでのみ使用でき、Winsock APIの &lt;code&gt;ioctlsocket()&lt;/code&gt; 呼び出しと同じように機能します。（Win32）</target>
        </trans-unit>
        <trans-unit id="7ff7a29d7d279f81c65111e3969b0de8be5b1d10" translate="yes" xml:space="preserve">
          <source>Available only for socket handles. (RISC OS)</source>
          <target state="translated">ソケットハンドルのみに対応しています。(RISC OS)</target>
        </trans-unit>
        <trans-unit id="9f1e3ff1138fe80a24c7ddf73407362168941db0" translate="yes" xml:space="preserve">
          <source>Available only under threaded builds, this function allocates an entry in &lt;code&gt;PL_stashpad&lt;/code&gt; for the stash passed to it.</source>
          <target state="translated">スレッドビルドでのみ使用可能なこの関数は、渡されたstash に &lt;code&gt;PL_stashpad&lt;/code&gt; のエントリを割り当てます。</target>
        </trans-unit>
        <trans-unit id="e829311778d72727fd390df6d086e72d016b6e9b" translate="yes" xml:space="preserve">
          <source>Avoid /usr/ucb/cc.</source>
          <target state="translated">/usr/ucb/ccを避ける。</target>
        </trans-unit>
        <trans-unit id="20382d66f57ab5b9e0eec4292fa20991e9ee50cf" translate="yes" xml:space="preserve">
          <source>Avoid &lt;code&gt;$r-&amp;gt;Class::func()&lt;/code&gt; where using &lt;code&gt;@ISA=qw(... Class ...)&lt;/code&gt; and &lt;code&gt;$r-&amp;gt;func()&lt;/code&gt; would work.</source>
          <target state="translated">&lt;code&gt;@ISA=qw(... Class ...)&lt;/code&gt; &lt;code&gt;$r-&amp;gt;Class::func()&lt;/code&gt; を使用しないでください。@ ISA = qw（... Class ...）と &lt;code&gt;$r-&amp;gt;func()&lt;/code&gt; すると機能します。</target>
        </trans-unit>
        <trans-unit id="653557f5998e677614fe1c110b44a8530b1a3295" translate="yes" xml:space="preserve">
          <source>Avoid assignments in conditionals, but if they're unavoidable, use extra paren, e.g. &quot;if (a &amp;amp;&amp;amp; (b = c)) ...&quot;</source>
          <target state="translated">条件文での割り当ては避けますが、やむを得ない場合は、「if（a &amp;amp;&amp;amp;（b = c））...」のように余分な括弧を使用します。</target>
        </trans-unit>
        <trans-unit id="12cd7881c58cc2ba233002bb3f616c6a3c8332a8" translate="yes" xml:space="preserve">
          <source>Avoid barewords if you can, especially all lowercase ones. You can't tell by just looking at it whether a bareword is a function or a string. By using quotes on strings and parentheses on function calls, you won't ever get them confused.</source>
          <target state="translated">できればベアワード、特にすべての小文字は避けてください。裸語が関数なのか文字列なのかは見ただけではわかりません。文字列には引用符を使い、関数呼び出しには括弧を使うことで、文字列が混同されることはありません。</target>
        </trans-unit>
        <trans-unit id="a2c60caa765bc1191575d1eafdff1bfe2d3195d5" translate="yes" xml:space="preserve">
          <source>Avoid class name tests like: &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot; unless &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; $ref eq 'FOO'&lt;/code&gt; . Generally you can delete the &lt;code&gt;eq 'FOO'&lt;/code&gt; part with no harm at all. Let the objects look after themselves! Generally, avoid hard-wired class names as far as possible.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot; unless &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; $ref eq 'FOO'&lt;/code&gt; $ ref eq 'FOO'でない限り、&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot;のようなクラス名テストは避けてください。一般に、 &lt;code&gt;eq 'FOO'&lt;/code&gt; の部分を削除しても問題はありません。オブジェクトに自分自身の世話をさせましょう！一般に、ハードワイヤードなクラス名は可能な限り避けてください。</target>
        </trans-unit>
        <trans-unit id="98206b093bcf40d6e074eb698543fd4b6a25d539" translate="yes" xml:space="preserve">
          <source>Avoid keeping any state information in your packages. It makes it difficult for multiple other packages to use yours. Keep state information in objects.</source>
          <target state="translated">パッケージの中に州の情報を入れないようにしてください。複数の他のパッケージがあなたのパッケージを使うのが難しくなります。状態情報はオブジェクトの中に入れておきましょう。</target>
        </trans-unit>
        <trans-unit id="b40cce256d04ce45459ded87307f5f3e8ae2760b" translate="yes" xml:space="preserve">
          <source>Avoid libucb.</source>
          <target state="translated">libucbは避けてください。</target>
        </trans-unit>
        <trans-unit id="b3ba9403766f60fa8e210155287efa18e1a9e739" translate="yes" xml:space="preserve">
          <source>Avoid starting a new top-level hierarchy, especially if a suitable hierarchy already exists under which you could place your module.</source>
          <target state="translated">特に、モジュールを配置するのに適した階層が既に存在している場合は、新しいトップレベルの階層を開始しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="fd4b693367a701b3345901dbd6d82b5f0d6ce929" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt;) or `backticks` in a void context, that is, when you just throw away their return values. Those functions all have return values, so use them. Otherwise use a &lt;code&gt;foreach()&lt;/code&gt; loop or the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; function instead.</source>
          <target state="translated">voidコンテキストで、つまり戻り値を破棄するだけの場合は、 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; （または &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; ）または `backticks` を使用しないでください。これらの関数はすべて戻り値を持っているので、それらを使用してください。それ以外の場合は、代わりに &lt;code&gt;foreach()&lt;/code&gt; ループまたは &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 関数を使用します。</target>
        </trans-unit>
        <trans-unit id="342c7154cb2c0ee3ba1afbccab12770600c98259" translate="yes" xml:space="preserve">
          <source>Avoid using hardcoded test numbers whenever possible (the EXPECTED/GOT found in t/op/tie.t is much more maintainable, and gives better failure reports).</source>
          <target state="translated">可能な限り、ハードコード化されたテスト番号の使用は避けてください (t/op/tie.t にある EXPECTED/GOT の方が保守性が高く、より良い故障報告が得られます)。</target>
        </trans-unit>
        <trans-unit id="67de3787b457172bffd90b9f3faae7435e0dae2f" translate="yes" xml:space="preserve">
          <source>Avoid using qx// and system() unless you are testing for them. If you do use them, make sure that you cover _all_ perl platforms.</source>
          <target state="translated">qx//と system()は、それらのテストをしている場合を除いては使用しないでください。それらを使う場合は、_すべての_perlプラットフォームをカバーしていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="0e92b74d5a979c26e7eb18be8603b8359a1d07fd" translate="yes" xml:space="preserve">
          <source>Avoiding Pipe Deadlocks</source>
          <target state="translated">パイプデッドロックの回避</target>
        </trans-unit>
        <trans-unit id="6e3313e507db79bbbaea78fb241509ccc328aba1" translate="yes" xml:space="preserve">
          <source>Avoiding repetitions</source>
          <target state="translated">繰り返しを避ける</target>
        </trans-unit>
        <trans-unit id="3721e8be2f4b8bf2c63f63312cdfa53888d8430d" translate="yes" xml:space="preserve">
          <source>Awk Traps</source>
          <target state="translated">アックトラップ</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="bd2b125cd8de6e0701cdac6ee17fd331ce4a27c2" translate="yes" xml:space="preserve">
          <source>B - The Perl Compiler Backend</source>
          <target state="translated">B-Perl コンパイラのバックエンド</target>
        </trans-unit>
        <trans-unit id="b918b0aa2af36ef03dc69f56d877870ae5fd0aee" translate="yes" xml:space="preserve">
          <source>B-regex</source>
          <target state="translated">B-regex</target>
        </trans-unit>
        <trans-unit id="4995b54293f85c5bb7976c9e655accd8fbd573ea" translate="yes" xml:space="preserve">
          <source>B. UNPACK</source>
          <target state="translated">B.UNPACK</target>
        </trans-unit>
        <trans-unit id="52b9020e3a04e67bbf5d1e8e1b850a5ce003849b" translate="yes" xml:space="preserve">
          <source>B::AV Methods</source>
          <target state="translated">B::AV メソッド</target>
        </trans-unit>
        <trans-unit id="dc2dfb25dd4ed2146470cd57ee95edac91f0306b" translate="yes" xml:space="preserve">
          <source>B::BINOP Method</source>
          <target state="translated">B::BINOP メソッド</target>
        </trans-unit>
        <trans-unit id="d151bd0866d55b4bfc156b14f486f63bf8d29ea8" translate="yes" xml:space="preserve">
          <source>B::BM Methods</source>
          <target state="translated">B::BM メソッド</target>
        </trans-unit>
        <trans-unit id="9055e894e201b212c293a29798f1091ff6d20491" translate="yes" xml:space="preserve">
          <source>B::COP Methods</source>
          <target state="translated">B::COP メソッド</target>
        </trans-unit>
        <trans-unit id="ad1f22ba3c95252a59969a1a218e1111bb139542" translate="yes" xml:space="preserve">
          <source>B::CV Methods</source>
          <target state="translated">B::CV メソッド</target>
        </trans-unit>
        <trans-unit id="c5987daa2aa6d7fac584555a51956a3b445f0843" translate="yes" xml:space="preserve">
          <source>B::Concise</source>
          <target state="translated">B::Concise</target>
        </trans-unit>
        <trans-unit id="0e99aa1c3be052d8105291584d6f4ee6b16f397c" translate="yes" xml:space="preserve">
          <source>B::Concise - Walk Perl syntax tree, printing concise info about ops</source>
          <target state="translated">B::Concise-Perl のシンタックスツリーを歩き、ops に関する簡潔な情報を表示する</target>
        </trans-unit>
        <trans-unit id="d98d2c8e235d9494074cb2fd60569e8b9c12b5d6" translate="yes" xml:space="preserve">
          <source>B::Concise::reset_sequence()</source>
          <target state="translated">B::Concise::reset_sequence()</target>
        </trans-unit>
        <trans-unit id="553185e97d716b58f74fa982526081cbc642ddf4" translate="yes" xml:space="preserve">
          <source>B::Debug</source>
          <target state="translated">B::Debug</target>
        </trans-unit>
        <trans-unit id="7b2b543f6bc70176bf812e6ac813955a4e8d32ab" translate="yes" xml:space="preserve">
          <source>B::Debug - Walk Perl syntax tree, printing debug info about ops</source>
          <target state="translated">B::Debug-Perl のシンタックスツリーを歩き、OPS に関するデバッグ情報を表示する</target>
        </trans-unit>
        <trans-unit id="b2fba5e2c554e2a4492f4d6c8ba33e2e0b6a2475" translate="yes" xml:space="preserve">
          <source>B::Deparse</source>
          <target state="translated">B::Deparse</target>
        </trans-unit>
        <trans-unit id="45e0d250a6312bd5838511c6a45d0f47e7a90193" translate="yes" xml:space="preserve">
          <source>B::Deparse - Perl compiler backend to produce perl code</source>
          <target state="translated">B::Deparse-Perl コードを生成する Perl コンパイラバックエンド</target>
        </trans-unit>
        <trans-unit id="ef79da6fd85d8fa02ee778f0544d6ba33e8b3b18" translate="yes" xml:space="preserve">
          <source>B::Deparse can also be used on a sub-by-sub basis from other perl programs.</source>
          <target state="translated">B::Deparse は他の perl プログラムからサブバイサブで使用することもできます。</target>
        </trans-unit>
        <trans-unit id="187ec0fb4a4a04196e808c398a93708ba9275615" translate="yes" xml:space="preserve">
          <source>B::Deparse is a backend module for the Perl compiler that generates perl source code, based on the internal compiled structure that perl itself creates after parsing a program. The output of B::Deparse won't be exactly the same as the original source, since perl doesn't keep track of comments or whitespace, and there isn't a one-to-one correspondence between perl's syntactical constructions and their compiled form, but it will often be close. When you use the &lt;b&gt;-p&lt;/b&gt; option, the output also includes parentheses even when they are not required by precedence, which can make it easy to see if perl is parsing your expressions the way you intended.</source>
          <target state="translated">B :: Deparseは、perl自体がプログラムの解析後に作成する内部コンパイル済み構造に基づいて、perlソースコードを生成するPerlコンパイラのバックエンドモジュールです。 B :: Deparseの出力は、perlがコメントや空白を追跡せず、perlの構文構造とコンパイルされた構文の間に1対1の対応がないため、元のソースとまったく同じにはなりません形、しかしそれはしばしば近いでしょう。&lt;b&gt;-p&lt;/b&gt;オプションを使用すると、優先順位で必要ない場合でも出力に括弧が含まれるため、perlが意図したとおりに式を解析しているかどうかを簡単に確認できます。</target>
        </trans-unit>
        <trans-unit id="fc31dbbc2ee8c07aa355011d5f82b2d63c5b6c00" translate="yes" xml:space="preserve">
          <source>B::GV Methods</source>
          <target state="translated">B::GV メソッド</target>
        </trans-unit>
        <trans-unit id="f507161ede02e20a9575d2189eb0e0194566355a" translate="yes" xml:space="preserve">
          <source>B::HV Methods</source>
          <target state="translated">B::HV メソッド</target>
        </trans-unit>
        <trans-unit id="e300bd8b4c95a3624e2aa219bf974f0118cef860" translate="yes" xml:space="preserve">
          <source>B::IO Methods</source>
          <target state="translated">B::IO メソッド</target>
        </trans-unit>
        <trans-unit id="35a3e95640c426b65cf8d850194a4f17b3215f07" translate="yes" xml:space="preserve">
          <source>B::IO objects derive from IO objects and you will get more information from the IO object itself.</source>
          <target state="translated">B::IO オブジェクトは IO オブジェクトから派生しており、IO オブジェクト自体からより多くの情報を得ることができます。</target>
        </trans-unit>
        <trans-unit id="9329448ffaface57d41ef2b007c24eb18197a68b" translate="yes" xml:space="preserve">
          <source>B::IV Methods</source>
          <target state="translated">B::IV メソッド</target>
        </trans-unit>
        <trans-unit id="41ae1a755811beebf8ac2f49c8c1656753f2209c" translate="yes" xml:space="preserve">
          <source>B::IV, B::NV, B::RV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::BM (5.9.5 and earlier), B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO. These classes correspond in the obvious way to the underlying C structures of similar names. The inheritance hierarchy mimics the underlying C &quot;inheritance&quot;. For the 5.10.x branch, (</source>
          <target state="translated">B::IV、B::NV、B::RV、B::PV、B::PVIV、B::PVNV、B::PVMG、B::BM (5.9.5 以前)、B::PVLV、B::AV、B::HV、B::CV、B::GV、B::FM、B::IO。これらのクラスは、類似した名前の基礎となる C の構造体に明白な形で対応しています。継承階層は、基礎となる C の &quot;継承&quot; を模倣しています。5.10.x ブランチでは、(</target>
        </trans-unit>
        <trans-unit id="47e3586b1ed7a7d56d8afab1073b55905757ce29" translate="yes" xml:space="preserve">
          <source>B::LISTOP Method</source>
          <target state="translated">B::LISTOPメソッド</target>
        </trans-unit>
        <trans-unit id="04688acb0cbf70d25c11e0314b06463ce4bde512" translate="yes" xml:space="preserve">
          <source>B::LOGOP Method</source>
          <target state="translated">B::LOGOP メソッド</target>
        </trans-unit>
        <trans-unit id="7263ed2af022568be1b85d473eacf000486dd697" translate="yes" xml:space="preserve">
          <source>B::LOOP Methods</source>
          <target state="translated">B::LOOP メソッド</target>
        </trans-unit>
        <trans-unit id="83ceb8c6feb2e3fc2f3bf822a42dbcd07ff89ff2" translate="yes" xml:space="preserve">
          <source>B::MAGIC Methods</source>
          <target state="translated">B::マジックメソッド</target>
        </trans-unit>
        <trans-unit id="69a559c9b6f1bb1dde02c8b48310f4be42a91370" translate="yes" xml:space="preserve">
          <source>B::METHOP Methods (Since Perl 5.22)</source>
          <target state="translated">B::METHOP メソッド (Perl 5.22 以降)</target>
        </trans-unit>
        <trans-unit id="ce0314b7717adf8f5e71d17e31bd593c95324507" translate="yes" xml:space="preserve">
          <source>B::NV Methods</source>
          <target state="translated">B::NV メソッド</target>
        </trans-unit>
        <trans-unit id="c0b4baaa7ca50074884462d7620fd16447077eec" translate="yes" xml:space="preserve">
          <source>B::OP Methods</source>
          <target state="translated">B::OP メソッド</target>
        </trans-unit>
        <trans-unit id="5409024a3cb7db3e3ab0625fc65de3e420057bb4" translate="yes" xml:space="preserve">
          <source>B::PADLIST Methods</source>
          <target state="translated">B::PADLIST メソッド</target>
        </trans-unit>
        <trans-unit id="7aa1d371fde2d45d24f6903c528b83b6becc77cd" translate="yes" xml:space="preserve">
          <source>B::PADNAME Methods</source>
          <target state="translated">B::PADNAME メソッド</target>
        </trans-unit>
        <trans-unit id="f042ef0bca656a3a3db2a47dca50963fab567b10" translate="yes" xml:space="preserve">
          <source>B::PADNAMELIST Methods</source>
          <target state="translated">B::PADNAMELIST メソッド</target>
        </trans-unit>
        <trans-unit id="7fc794e6266342d3b9c5605f5dd3acf7f99c4eaf" translate="yes" xml:space="preserve">
          <source>B::PADOP Method</source>
          <target state="translated">B::PADOPメソッド</target>
        </trans-unit>
        <trans-unit id="3cfe6d3792643bf75e3768c357ceb15d1fcc2896" translate="yes" xml:space="preserve">
          <source>B::PMOP Methods</source>
          <target state="translated">B::PMOP メソッド</target>
        </trans-unit>
        <trans-unit id="935c8ee8b93bca030ffae3839fe2dd9b63ef8ee4" translate="yes" xml:space="preserve">
          <source>B::PV Methods</source>
          <target state="translated">B::PV メソッド</target>
        </trans-unit>
        <trans-unit id="2ae17602fe4096f70c3f88f15eb8e459f9c75ea9" translate="yes" xml:space="preserve">
          <source>B::PVLV Methods</source>
          <target state="translated">B::PVLV メソッド</target>
        </trans-unit>
        <trans-unit id="974a328507349d20edd58996d04366d5388a2f7c" translate="yes" xml:space="preserve">
          <source>B::PVMG Methods</source>
          <target state="translated">B::PVMG メソッド</target>
        </trans-unit>
        <trans-unit id="7210fef12d9bb7c60c3dee3ae3350db4f7b9f9ab" translate="yes" xml:space="preserve">
          <source>B::PVOP Method</source>
          <target state="translated">B::PVOP メソッド</target>
        </trans-unit>
        <trans-unit id="6455c3fb933990f5652e2d49c591cb379eb4bf8a" translate="yes" xml:space="preserve">
          <source>B::REGEXP Methods</source>
          <target state="translated">B::REGEXP メソッド</target>
        </trans-unit>
        <trans-unit id="5fb9902660751871b51829ac2f4124c1e0f71d1f" translate="yes" xml:space="preserve">
          <source>B::RV Methods</source>
          <target state="translated">B::RV メソッド</target>
        </trans-unit>
        <trans-unit id="1bc231286052c317542f678d841b72c83eca59c7" translate="yes" xml:space="preserve">
          <source>B::SV Methods</source>
          <target state="translated">B::SV メソッド</target>
        </trans-unit>
        <trans-unit id="ba72f1a9a3b75ef02445cdb3be5e5dfd9e626d0a" translate="yes" xml:space="preserve">
          <source>B::SVOP Methods</source>
          <target state="translated">B::SVOP メソッド</target>
        </trans-unit>
        <trans-unit id="6d49788efca655ce69693e7fc4afeb14e70c0677" translate="yes" xml:space="preserve">
          <source>B::Showlex</source>
          <target state="translated">B::Showlex</target>
        </trans-unit>
        <trans-unit id="950f98354a0be3d4d89c912c00828150ec365f96" translate="yes" xml:space="preserve">
          <source>B::Showlex - Show lexical variables used in functions or files</source>
          <target state="translated">B::Showlex-関数やファイルで使用される字句変数を表示する</target>
        </trans-unit>
        <trans-unit id="fdd28b59d6f44b83715e2f882acc2a2a5588e605" translate="yes" xml:space="preserve">
          <source>B::Terse</source>
          <target state="translated">B::Terse</target>
        </trans-unit>
        <trans-unit id="c493225f0157e4f61a98bb3974699f2af44cb46f" translate="yes" xml:space="preserve">
          <source>B::Terse - Walk Perl syntax tree, printing terse info about ops</source>
          <target state="translated">B::Terse-Perl の構文ツリーを歩き、ops についての簡潔な情報を表示する</target>
        </trans-unit>
        <trans-unit id="9f6685ca28bcfea09300907f0826a8f9a2c91850" translate="yes" xml:space="preserve">
          <source>B::UNOP Method</source>
          <target state="translated">B::UNOP メソッド</target>
        </trans-unit>
        <trans-unit id="69effd3b7e8802f540cc9b9e50328608e6736463" translate="yes" xml:space="preserve">
          <source>B::UNOP_AUX Methods (since 5.22)</source>
          <target state="translated">B::UNOP_AUX メソッド (5.22 以降)</target>
        </trans-unit>
        <trans-unit id="c85e7a03e5bbe49c04256621164986ed11cb37ba" translate="yes" xml:space="preserve">
          <source>B::Xref</source>
          <target state="translated">B::Xref</target>
        </trans-unit>
        <trans-unit id="651c8208adb3fd49f31423f94f8ac43c0733aa36" translate="yes" xml:space="preserve">
          <source>B::Xref - Generates cross reference reports for Perl programs</source>
          <target state="translated">B::Xref-Perl プログラムのクロスリファレンスレポートを生成する</target>
        </trans-unit>
        <trans-unit id="a61d2719382da67e2a1a2dbd76dd400accca9187" translate="yes" xml:space="preserve">
          <source>BACKWARD COMPATIBILITY AND DEPRECATION</source>
          <target state="translated">後方互換性と蔑視</target>
        </trans-unit>
        <trans-unit id="e5b45b4fc983ac2702f9e777eee2ac1b1e5f0f20" translate="yes" xml:space="preserve">
          <source>BACKWARDS COMPATIBILITY</source>
          <target state="translated">バックワード互換性</target>
        </trans-unit>
        <trans-unit id="bef6eec96c16ae54f978beec72807557ca3a9eaf" translate="yes" xml:space="preserve">
          <source>BASIC METHODS</source>
          <target state="translated">基本的な方法</target>
        </trans-unit>
        <trans-unit id="8cf5cb57c99d3bbd6c48033a11d198c341ee5329" translate="yes" xml:space="preserve">
          <source>BEFORE YOU START WRITING A MODULE</source>
          <target state="translated">モジュールを書き始める前に</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="ed0ab3055b45605d8d3bfeee9675e3115e25dd63" translate="yes" xml:space="preserve">
          <source>BEGIN, UNITCHECK, CHECK, INIT and END</source>
          <target state="translated">BEGIN、UNITCHECK、CHECK、INIT、END</target>
        </trans-unit>
        <trans-unit id="82587c5990d27962027bcd8f44009a394aa03c6d" translate="yes" xml:space="preserve">
          <source>BENCHMARKS</source>
          <target state="translated">BENCHMARKS</target>
        </trans-unit>
        <trans-unit id="3eb8dc2707d319cff39e903c8f9e907ffde6faaa" translate="yes" xml:space="preserve">
          <source>BEST PRACTICE</source>
          <target state="translated">ベストプラクティス</target>
        </trans-unit>
        <trans-unit id="d6b920160b07e6d8ef62aeb966afe0559c1c4da6" translate="yes" xml:space="preserve">
          <source>BINMODE</source>
          <target state="translated">BINMODE</target>
        </trans-unit>
        <trans-unit id="9afa89ba4b3340d7bc1c3e18c656cfc5abf6d9a7" translate="yes" xml:space="preserve">
          <source>BOOLEAN = less-&amp;gt;of( FEATURE )</source>
          <target state="translated">BOOLEAN = less-&amp;gt; of（FEATURE）</target>
        </trans-unit>
        <trans-unit id="247befebedd2ed6823933439f49eb30a07d09dca" translate="yes" xml:space="preserve">
          <source>BRACKET NOTATION</source>
          <target state="translated">ブラケット表記</target>
        </trans-unit>
        <trans-unit id="e7772b5b926c191f6bd98767963948f3ffc93baa" translate="yes" xml:space="preserve">
          <source>BS2000 POSIX doesn't support the shebang notation (&lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt; ), so you have to use the following lines instead:</source>
          <target state="translated">BS2000 POSIXはシバン表記（ &lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt; ）をサポートしていないため、代わりに次の行を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="664c8d2ddb2e4dc2ea085ed16d6df4504ec03ee2" translate="yes" xml:space="preserve">
          <source>BSD::Resource on Solaris</source>
          <target state="translated">BSD::Resource on Solaris</target>
        </trans-unit>
        <trans-unit id="df51adc50ecdca424b6145ec6164f8c39197a14c" translate="yes" xml:space="preserve">
          <source>BSD::Resource versions earlier than 1.09 do not compile on Solaris with perl 5.6.0 and higher, for the same reasons as Proc::ProcessTable. BSD::Resource versions starting from 1.09 have a workaround for the problem.</source>
          <target state="translated">BSD::Resource のバージョン 1.09 より前のバージョンは、Proc::ProcessTable と同じ理由で、perl 5.6.0 以降の Solaris 上ではコンパイルできません。1.09 以降の BSD::Resource バージョンでは、この問題を回避できるようになっています。</target>
        </trans-unit>
        <trans-unit id="d7fe8d7ec43bafda1404b3733deb73b25528fcbd" translate="yes" xml:space="preserve">
          <source>BSLOADLIBS</source>
          <target state="translated">BSLOADLIBS</target>
        </trans-unit>
        <trans-unit id="502dbddd3b35610af6911c0fbc9ca3be4bfe6d63" translate="yes" xml:space="preserve">
          <source>BTW. Beware too of pressure from managers who see you speed a program up by 50% of the runtime once, only to get a request one month later to do the same again (true story) - you'll just have to point out you're only human, even if you are a Perl programmer, and you'll see what you can do...</source>
          <target state="translated">ところで。一度だけプログラムを実行時間の50%高速化したのに、一ヶ月後にまた同じことをするように要求されるのを見て、マネージャーからの圧力にも注意してください(実話)-たとえPerlプログラマであっても、あなたが人間であることを指摘する必要があります。</target>
        </trans-unit>
        <trans-unit id="8b9146b4f38600ca0e41fb96135f743cfdb11eec" translate="yes" xml:space="preserve">
          <source>BUG REPORTING</source>
          <target state="translated">バグ報告</target>
        </trans-unit>
        <trans-unit id="664f572fef857b1dfc7d6e286d22026a2508e1e5" translate="yes" xml:space="preserve">
          <source>BUG REPORTS</source>
          <target state="translated">バグレポート</target>
        </trans-unit>
        <trans-unit id="5dda8c520f4fbfda1830a8a497556d722a3fd113" translate="yes" xml:space="preserve">
          <source>BUGS</source>
          <target state="translated">BUGS</target>
        </trans-unit>
        <trans-unit id="9f989473548a594a947b969757db7fc06ca6a262" translate="yes" xml:space="preserve">
          <source>BUGS AND CAVEATS</source>
          <target state="translated">バグとケイバット</target>
        </trans-unit>
        <trans-unit id="fe771929835192040a55c6b146d4bbdcf0038546" translate="yes" xml:space="preserve">
          <source>BUGS AND IRRITATIONS</source>
          <target state="translated">欠陥と苛立ち</target>
        </trans-unit>
        <trans-unit id="affef23bcfe821a649489c10e4d45ae3607b1ccb" translate="yes" xml:space="preserve">
          <source>BUGS AND LIMITATIONS</source>
          <target state="translated">不具合と制限</target>
        </trans-unit>
        <trans-unit id="118a34d613c11c790c196c946968113aa8bc32aa" translate="yes" xml:space="preserve">
          <source>BUGS AND PITFALLS</source>
          <target state="translated">不具合と欠点</target>
        </trans-unit>
        <trans-unit id="a16fd7f9de623a809defab1d94048e0eded9677b" translate="yes" xml:space="preserve">
          <source>BUGS AND WARNINGS</source>
          <target state="translated">不具合と警告</target>
        </trans-unit>
        <trans-unit id="2f8e6e225c82badf6f8a92aed6ef242d4dc4d03b" translate="yes" xml:space="preserve">
          <source>BUGS ON CYGWIN</source>
          <target state="translated">CYGWINのバグ</target>
        </trans-unit>
        <trans-unit id="11f69a17d772a3f0d39aa116f097397dc1dac971" translate="yes" xml:space="preserve">
          <source>BUGS and CAVEATS</source>
          <target state="translated">BUGSとCAVEATS</target>
        </trans-unit>
        <trans-unit id="ccf8d27dca59cf8914b7de42279bcf54b381c80d" translate="yes" xml:space="preserve">
          <source>BUGS is an email or url to post bug reports. For modules with UPSTREAM =&amp;gt; 'blead', use perl5-porters@perl.org. rt.cpan.org appears to automatically provide a URL for CPAN modules; any value given here overrides the default: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=&lt;/a&gt;$ModuleName</source>
          <target state="translated">バグは、バグレポートを投稿するための電子メールまたはURLです。UPSTREAM =&amp;gt; 'blead'のモジュールの場合、perl5-porters @ perl.orgを使用します。rt.cpan.orgは、CPANモジュールのURLを自動的に提供するようです。ここで指定した値はデフォルトを上書きします：&lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=&quot;&gt;http&lt;/a&gt; : //rt.cpan.org/Public/Dist/Display.html?Name= $ ModuleName</target>
        </trans-unit>
        <trans-unit id="4fa4a173033ffa9b27f16cd2d7b309c255617591" translate="yes" xml:space="preserve">
          <source>BUGS/CAVEATS/etc</source>
          <target state="translated">BUGS/CAVEATS/etc</target>
        </trans-unit>
        <trans-unit id="9b8dfdff736c5b1dbf956b89d8a9d4fd925dacd2" translate="yes" xml:space="preserve">
          <source>BUILD</source>
          <target state="translated">BUILD</target>
        </trans-unit>
        <trans-unit id="0e162e98df920882beaaa37c9fd3fd9860be2bff" translate="yes" xml:space="preserve">
          <source>BUILD AND INSTALL</source>
          <target state="translated">ビルドとインストール</target>
        </trans-unit>
        <trans-unit id="80ef3501d89bb441f42a9aac769a351966bde435" translate="yes" xml:space="preserve">
          <source>BUILD NEW EXTENSIONS</source>
          <target state="translated">新しい拡張機能を構築する</target>
        </trans-unit>
        <trans-unit id="a5d9fc029fc161e583884fa605ea5dd4bf5b0226" translate="yes" xml:space="preserve">
          <source>BUILDING AND INSTALLING MODULES ON DOS</source>
          <target state="translated">DOS でのモジュールの構築とインストール</target>
        </trans-unit>
        <trans-unit id="68c9d11aacf08e68cf9222616220471f55a4230e" translate="yes" xml:space="preserve">
          <source>BUILDING PERL FOR OPENVOS</source>
          <target state="translated">OPENVOSのためのPERLの構築</target>
        </trans-unit>
        <trans-unit id="b603dd0f789cea0b71cf17b9cadf6a885369ee6d" translate="yes" xml:space="preserve">
          <source>BUILDING PERL ON AMIGAOS</source>
          <target state="translated">アミガオスにペルを建てる</target>
        </trans-unit>
        <trans-unit id="d5bdc31108d4219c97e8c1b7e29e0629da746aa9" translate="yes" xml:space="preserve">
          <source>BUNDLES</source>
          <target state="translated">BUNDLES</target>
        </trans-unit>
        <trans-unit id="92b48cc3d13ac12b362038111cf08e5cf8b03696" translate="yes" xml:space="preserve">
          <source>Back before Perl had the XS system for connecting with C libraries, programmers used to get library constants by reading through the C header files. You may still see &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'syscall.ph'&lt;/code&gt; or similar around - the</source>
          <target state="translated">PerlがCライブラリに接続するためのXSシステムを持っていた以前は、プログラマーはCヘッダーファイルを読み取ってライブラリ定数を取得していました。まだ &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'syscall.ph'&lt;/code&gt; または同様のものが&lt;a href=&quot;functions/require&quot;&gt;必要と&lt;/a&gt;表示される場合があります -</target>
        </trans-unit>
        <trans-unit id="4a3e95e64a0aa298ba1dcd060974643f7be2839b" translate="yes" xml:space="preserve">
          <source>Back then, the range 0xD800-0xDFFF was not allocated. Let's split that range in half and use the first half to represent the &lt;code&gt;upper
half of a character&lt;/code&gt; and the second half to represent the &lt;code&gt;lower
half of a character&lt;/code&gt; . That way, you can represent 1024 * 1024 = 1048576 more characters. Now we can store character ranges up to \x{10ffff} even with 16-bit encodings. This pair of half-character is now called a</source>
          <target state="translated">当時、範囲0xD800-0xDFFFは割り当てられていませんでした。その範囲を半分に分割し、前半を使用し &lt;code&gt;upper half of a character&lt;/code&gt; を表し、後半を使用して文字の &lt;code&gt;lower half of a character&lt;/code&gt; を表します。これにより、1024 * 1024 = 1048576個の文字を表すことができます。これで、16ビットエンコーディングでも\ x {10ffff}までの文字範囲を保存できます。この半文字のペアは、現在、</target>
        </trans-unit>
        <trans-unit id="1f9a2a8bbfa8f04b97f0739e8cee87c19e9a7b1a" translate="yes" xml:space="preserve">
          <source>Back to converting data. If you have (or want) data in your system's native 8-bit encoding (e.g. Latin-1, EBCDIC, etc.), you can use pack/unpack to convert to/from Unicode.</source>
          <target state="translated">データの変換に戻ります。システムのネイティブの 8 ビットエンコーディング (Latin-1 や EBCDIC など)のデータを持っている (または持っていたい)場合、pack/unpack を使って Unicode に変換することができます。</target>
        </trans-unit>
        <trans-unit id="917eb438525299e66d70b4deb11770f40a27eeaa" translate="yes" xml:space="preserve">
          <source>Backend for building test libraries</source>
          <target state="translated">テストライブラリを構築するためのバックエンド</target>
        </trans-unit>
        <trans-unit id="60865a55d575470308929e5970d44edcbdb31366" translate="yes" xml:space="preserve">
          <source>Background Processes</source>
          <target state="translated">バックグラウンドプロセス</target>
        </trans-unit>
        <trans-unit id="777d367a0813af1945dd6a57f416558fa99c5a72" translate="yes" xml:space="preserve">
          <source>Background and PERL_IMPLICIT_CONTEXT</source>
          <target state="translated">背景とPERL_IMPLICIT_CONTEXT</target>
        </trans-unit>
        <trans-unit id="82139f465e7bfd51be69bcd2ba2252de65152f38" translate="yes" xml:space="preserve">
          <source>Background yourself like this:</source>
          <target state="translated">このように自分を背景にして</target>
        </trans-unit>
        <trans-unit id="1c7bd776caf410341796f267d0b5a33a3e4a0364" translate="yes" xml:space="preserve">
          <source>Backreference to a named capture group. Equivalent to &lt;code&gt;\g{NAME}&lt;/code&gt; .</source>
          <target state="translated">名前付きキャプチャグループへの後方参照。 &lt;code&gt;\g{NAME}&lt;/code&gt; 同等です。</target>
        </trans-unit>
        <trans-unit id="1b67830d6a194880657acd61864c65e3027fb02e" translate="yes" xml:space="preserve">
          <source>Backreferences</source>
          <target state="translated">Backreferences</target>
        </trans-unit>
        <trans-unit id="89d9017aad56d057f4819297fea6ec35a3d1c796" translate="yes" xml:space="preserve">
          <source>Backreferences in substitutions use &quot;$&quot; rather than &quot;\&quot;.</source>
          <target state="translated">置換の際の後方参照には、&quot;\&quot;ではなく&quot;$&quot;を使用します。</target>
        </trans-unit>
        <trans-unit id="c5cf510bfb36856574ecae34fa00822be8b9c589" translate="yes" xml:space="preserve">
          <source>Backslash Sequences</source>
          <target state="translated">バックスラッシュシーケンス</target>
        </trans-unit>
        <trans-unit id="db35629fab3798cdd79f1bf42fa413127bebc425" translate="yes" xml:space="preserve">
          <source>Backslash is used, as usual, to escape the next character.</source>
          <target state="translated">バックスラッシュは通常通り、次の文字をエスケープするために使用されます。</target>
        </trans-unit>
        <trans-unit id="046c786ef212957156a16429eb6f369b2064b79d" translate="yes" xml:space="preserve">
          <source>Backslash sequence character classes cannot form one of the endpoints of a range. Thus, you can't say:</source>
          <target state="translated">バックスラッシュシーケンス文字クラスは、範囲の終点の一つを形成することはできません。したがって、言うことはできません。</target>
        </trans-unit>
        <trans-unit id="9900e3acb0e0a2eba6b592f80668e5cc6828f6c1" translate="yes" xml:space="preserve">
          <source>Backslash sequences</source>
          <target state="translated">バックスラッシュシーケンス</target>
        </trans-unit>
        <trans-unit id="c61c0b16c1836e4070c1986f40a121b830a65cf5" translate="yes" xml:space="preserve">
          <source>Backslashed characters are either replaced with corresponding literal strings (as with &lt;code&gt;\{&lt;/code&gt;), or else they generate special nodes in the finite automaton (as with &lt;code&gt;\b&lt;/code&gt; ). Characters special to the RE engine (such as &lt;code&gt;|&lt;/code&gt;) generate corresponding nodes or groups of nodes. &lt;code&gt;(?#...)&lt;/code&gt; comments are ignored. All the rest is either converted to literal strings to match, or else is ignored (as is whitespace and &lt;code&gt;#&lt;/code&gt; -style comments if &lt;code&gt;/x&lt;/code&gt; is present).</source>
          <target state="translated">バックスラッシュ文字は、対応するリテラル文字列（ &lt;code&gt;\{&lt;/code&gt; ）に置き換えられるか、有限オートマトン（ &lt;code&gt;\b&lt;/code&gt; ）で特殊なノードを生成します。 REエンジンに特有の文字（ &lt;code&gt;|&lt;/code&gt; など）は、対応するノードまたはノードのグループを生成します。 &lt;code&gt;(?#...)&lt;/code&gt; コメントは無視されます。残りはすべて、一致するようにリテラル文字列に変換されるか、無視されます（ &lt;code&gt;/x&lt;/code&gt; が存在する場合の空白や &lt;code&gt;#&lt;/code&gt; スタイルのコメントと同様）。</target>
        </trans-unit>
        <trans-unit id="396b0c95d21c97a92647624c67163f81645740c9" translate="yes" xml:space="preserve">
          <source>Backslashed metacharacters in Perl are alphanumeric, such as &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; . Unlike some other regular expression languages, there are no backslashed symbols that aren't alphanumeric. So anything that looks like \\, \(, \), \[, \], \{, or \} is always interpreted as a literal character, not a metacharacter. This was once used in a common idiom to disable or quote the special meanings of regular expression metacharacters in a string that you want to use for a pattern. Simply quote all non-&quot;word&quot; characters:</source>
          <target state="translated">Perlのバックスラッシュ付きメタ文字は、 &lt;code&gt;\b&lt;/code&gt; 、 &lt;code&gt;\w&lt;/code&gt; 、 &lt;code&gt;\n&lt;/code&gt; などの英数字です。他の一部の正規表現言語とは異なり、英数字以外のバックスラッシュ記号はありません。したがって、\\、\（、\）、\ [、\]、\ {、\}のようなものは、常にメタ文字ではなくリテラル文字として解釈されます。これはかつて、パターンに使用したい文字列内の正規表現のメタ文字の特別な意味を無効にするか引用するために一般的なイディオムで使用されていました。「単語」以外のすべての文字を単に引用します。</target>
        </trans-unit>
        <trans-unit id="5ad3bd6856b2f78166ba432a9cdf4da8413a4090" translate="yes" xml:space="preserve">
          <source>Backslashes parentheses &lt;code&gt;()&lt;/code&gt; in command line arguments. Doesn't handle recursive Makefile &lt;code&gt;$(...)&lt;/code&gt; constructs, but handles simple ones.</source>
          <target state="translated">コマンドライン引数のバックスラッシュ括弧 &lt;code&gt;()&lt;/code&gt; 。再帰的なMakefile &lt;code&gt;$(...)&lt;/code&gt; 構成を処理しませんが、単純な構成を処理します。</target>
        </trans-unit>
        <trans-unit id="8ef1c0d1318e1460dedacce3731d309fc7ffbb8a" translate="yes" xml:space="preserve">
          <source>Backticks &lt;code&gt;``&lt;/code&gt; (see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="translated">バッククォート &lt;code&gt;``&lt;/code&gt; （参照&lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;はperlopにI / O演算子を&lt;/a&gt;リダイレクトまたはシェルのメタ文字が含まれているコマンドを使用）。</target>
        </trans-unit>
        <trans-unit id="6e2b605f65ba36a3d929c62881915b96a794f8f1" translate="yes" xml:space="preserve">
          <source>Backticks create a subprocess, and pass the enclosed string to it for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt; , any valid DCL command string may be specified.</source>
          <target state="translated">バッククォートはサブプロセスを作成し、囲まれた文字列をサブプロセスに渡して、DCLコマンドとして実行します。サブプロセスは &lt;code&gt;lib$spawn()&lt;/code&gt; を介して直接作成されるため、有効なDCLコマンド文字列を指定できます。</target>
        </trans-unit>
        <trans-unit id="34532d18ad2d0f70e2d7b957fabc96ee06bc62fe" translate="yes" xml:space="preserve">
          <source>Backtracking</source>
          <target state="translated">Backtracking</target>
        </trans-unit>
        <trans-unit id="6e522c194b60635ece31d387544d1195051e629c" translate="yes" xml:space="preserve">
          <source>Backtracking control verbs</source>
          <target state="translated">バックトラッキング制御動詞</target>
        </trans-unit>
        <trans-unit id="14496432005368ea983df3ea81b1252443b8ee8b" translate="yes" xml:space="preserve">
          <source>Backtracking during the relentless search for a match may be a waste of time, particularly when the match is bound to fail. Consider the simple pattern</source>
          <target state="translated">一致するものを執拗に探している間にバックトラッキングするのは時間の無駄かもしれませんが、特に一致したものが失敗することが予想される場合には、時間の無駄かもしれません。単純なパターンを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="0bce7971052281b2bb5edb4f3a21f79dd6904b31" translate="yes" xml:space="preserve">
          <source>Backtracking is more efficient than repeated tries with different regular expressions. If there are several regular expressions and a match with any of them is acceptable, then it is possible to combine them into a set of alternatives. If the individual expressions are input data, this can be done by programming a join operation. We'll exploit this idea in an improved version of the &lt;code&gt;simple_grep&lt;/code&gt; program: a program that matches multiple patterns:</source>
          <target state="translated">バックトラッキングは、異なる正規表現で繰り返し試行するよりも効率的です。いくつかの正規表現があり、それらのいずれかとの一致が許容できる場合は、それらを組み合わせて代替のセットにすることができます。個々の式が入力データである場合、これは結合操作をプログラミングすることで実行できます。 &lt;code&gt;simple_grep&lt;/code&gt; プログラムの改良版でこのアイデアを利用します：複数のパターンに一致するプログラム：</target>
        </trans-unit>
        <trans-unit id="fd4a1f65749d89056abcaeac3722a7b7a8fe75a1" translate="yes" xml:space="preserve">
          <source>Backward Compatibility</source>
          <target state="translated">下位互換性</target>
        </trans-unit>
        <trans-unit id="23a7808b48afc84b0dceb9136590ca7bfdbb9b77" translate="yes" xml:space="preserve">
          <source>Backward compatibility</source>
          <target state="translated">下位互換性</target>
        </trans-unit>
        <trans-unit id="ec09211f4889a2c8a77bac08067eb8783a4cd974" translate="yes" xml:space="preserve">
          <source>Backward compatible boilerplate</source>
          <target state="translated">下位互換性のあるボイラプレート</target>
        </trans-unit>
        <trans-unit id="8fd78925dba59eef91afba0cdabe923520e5ee69" translate="yes" xml:space="preserve">
          <source>Backwards compatibility</source>
          <target state="translated">下位互換性</target>
        </trans-unit>
        <trans-unit id="9cec2366e742bda57450610acf903181d2989bf8" translate="yes" xml:space="preserve">
          <source>Bad example:</source>
          <target state="translated">悪い例だ</target>
        </trans-unit>
        <trans-unit id="55cc23ba5301ba2564daa62213188ebb8c917e57" translate="yes" xml:space="preserve">
          <source>Bailout result token.</source>
          <target state="translated">ベイルアウト結果トークン。</target>
        </trans-unit>
        <trans-unit id="c9c7caaefe38d5bc0e42cffe87236c93a6e055ee" translate="yes" xml:space="preserve">
          <source>Bal&amp;aacute;zs Szab&amp;oacute; (dLux), dlux@kapu.hu</source>
          <target state="translated">Bal&amp;aacute;zsSzab&amp;oacute;（dLux）、dlux @ kapu.hu</target>
        </trans-unit>
        <trans-unit id="528dadc6eada08b37b8564a84bbd615fedfa3a6d" translate="yes" xml:space="preserve">
          <source>Bar.pm</source>
          <target state="translated">Bar.pm</target>
        </trans-unit>
        <trans-unit id="991cc000e0ed51287d06994419ec5b5150b2fbbf" translate="yes" xml:space="preserve">
          <source>Bar.xs</source>
          <target state="translated">Bar.xs</target>
        </trans-unit>
        <trans-unit id="4d1ae41c7e90ad9133f0cec4b012d051f81574f4" translate="yes" xml:space="preserve">
          <source>Barewords</source>
          <target state="translated">Barewords</target>
        </trans-unit>
        <trans-unit id="6be542a3a79d103a3744357ed20ec40db010c97c" translate="yes" xml:space="preserve">
          <source>Barewords are not covered by overloaded string constants.</source>
          <target state="translated">裸語は、オーバーロードされた文字列定数ではカバーされません。</target>
        </trans-unit>
        <trans-unit id="a58b8ede3c3c15995119146605014af774c7bcd7" translate="yes" xml:space="preserve">
          <source>Base Class for IO::Compress modules</source>
          <target state="translated">IO::Compress モジュールの基底クラス</target>
        </trans-unit>
        <trans-unit id="1aecc52f6145193c99cc41e745488c8d94f4db0b" translate="yes" xml:space="preserve">
          <source>Base Class for IO::Uncompress modules</source>
          <target state="translated">IO::Uncompress モジュールの基底クラス</target>
        </trans-unit>
        <trans-unit id="9410f6a2867439548603d6c52d5c59ef4562fa7b" translate="yes" xml:space="preserve">
          <source>Base Structures</source>
          <target state="translated">ベース構造</target>
        </trans-unit>
        <trans-unit id="082fae7b28f65e5cb911e0f3f3f15b07bb66cbb1" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied handles</source>
          <target state="translated">タイドハンドルの基本クラス定義</target>
        </trans-unit>
        <trans-unit id="007ee9121a8b9e57fcd866ceebd36b23a00f0fde" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied hashes</source>
          <target state="translated">タイドハッシュの基本クラス定義</target>
        </trans-unit>
        <trans-unit id="b6b455ad8f579493b53af2265bc184f2ba6c6cbb" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied scalars</source>
          <target state="translated">紐付きスカラの基底クラス定義</target>
        </trans-unit>
        <trans-unit id="9cae4a150d12d8ffc0b3fa77692959a6c4bfb799" translate="yes" xml:space="preserve">
          <source>Base class for ALL classes (blessed references)</source>
          <target state="translated">すべてのクラスの基底クラス (祝福された参照)</target>
        </trans-unit>
        <trans-unit id="35cd310da77bd29a53a2d4932d2eb92ae62a2b7e" translate="yes" xml:space="preserve">
          <source>Base class for CPAN shell extensions</source>
          <target state="translated">CPAN シェル拡張のための基底クラス</target>
        </trans-unit>
        <trans-unit id="c3e0f91a5e302404f6913115b1263f4db4575024" translate="yes" xml:space="preserve">
          <source>Base class for ExtUtils::Constant objects</source>
          <target state="translated">ExtUtils::Constant オブジェクトの基底クラス</target>
        </trans-unit>
        <trans-unit id="5ce69fa0ba6f632f7e9c5c2e2e7602e063a7c7a9" translate="yes" xml:space="preserve">
          <source>Base class for TAP source iterators</source>
          <target state="translated">TAPソースイテレータの基底クラス</target>
        </trans-unit>
        <trans-unit id="37eb343993cd16220ab0f185a716f5c376429394" translate="yes" xml:space="preserve">
          <source>Base class for TAP::Parser output objects</source>
          <target state="translated">TAP::Parser 出力オブジェクトの基底クラス</target>
        </trans-unit>
        <trans-unit id="b8befc5059605409ade42b4d099e397b207c906b" translate="yes" xml:space="preserve">
          <source>Base class for creating POD filters and translators</source>
          <target state="translated">POD フィルタおよびトランスレータを作成するための基底クラス</target>
        </trans-unit>
        <trans-unit id="78eefd2e412b4d4df740ff4fbfcce92bad174022" translate="yes" xml:space="preserve">
          <source>Base class for different TAP source handlers</source>
          <target state="translated">さまざまな TAP ソースハンドラのための基底クラス</target>
        </trans-unit>
        <trans-unit id="e4dfc8dbeda31aa613f1ab98bcf6af5cdb80223d" translate="yes" xml:space="preserve">
          <source>Base class for harness output delegates</source>
          <target state="translated">ハーネス出力デリゲートの基底クラス</target>
        </trans-unit>
        <trans-unit id="7a74e67740b1a1d00bee0be3088f31fbc10821ea" translate="yes" xml:space="preserve">
          <source>Base class for test modules</source>
          <target state="translated">テストモジュールの基底クラス</target>
        </trans-unit>
        <trans-unit id="78996d2c61d5e3e13d981dd6371495a7dc1b0695" translate="yes" xml:space="preserve">
          <source>Base class for tied arrays</source>
          <target state="translated">紐付き配列の基底クラス</target>
        </trans-unit>
        <trans-unit id="8811ba419e75aa7afad3c58a4392ff34e2f70b65" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to &lt;a href=&quot;tap/parser&quot;&gt;TAP::Parser&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;tap/parser&quot;&gt;TAP :: Parserに&lt;/a&gt;共通の機能を提供する基本クラス</target>
        </trans-unit>
        <trans-unit id="0808d28ca43c79c7220c0b66b8832ca8877ecfdc" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to all &lt;code&gt;TAP::*&lt;/code&gt; modules</source>
          <target state="translated">すべての &lt;code&gt;TAP::*&lt;/code&gt; モジュールに共通の機能を提供する基本クラス</target>
        </trans-unit>
        <trans-unit id="7a76be2c1588f2035fb74a3a61c2be909fdefa70" translate="yes" xml:space="preserve">
          <source>Base for Pod::Perldoc formatters</source>
          <target state="translated">Pod::Perldocのフォーマッタ用ベース</target>
        </trans-unit>
        <trans-unit id="2291e71c9ac6320d0a4640a773f789651e805f6a" translate="yes" xml:space="preserve">
          <source>Based on Stevan Little's &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class::C3&lt;/a&gt;</source>
          <target state="translated">Stevan Littleの&lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class :: C3に&lt;/a&gt;基づく</target>
        </trans-unit>
        <trans-unit id="560c120ffa51ce8d2dc3b95d35311dd465a3c278" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text::pod2text()&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;によって記述された&lt;b&gt;Pod :: Text :: pod2text（）の&lt;/b&gt;コードに基づく</target>
        </trans-unit>
        <trans-unit id="25b805dbff71baab76550b6af4db1656526ccb89" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text::pod2text(1)&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;によって記述された&lt;b&gt;Pod :: Text :: pod2text（1）の&lt;/b&gt;コードに基づく</target>
        </trans-unit>
        <trans-unit id="b781efd9c14a9bf17ea0a940b2c65ad0a21bc5c6" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;によって記述された&lt;b&gt;Pod :: Textの&lt;/b&gt;コードに基づく</target>
        </trans-unit>
        <trans-unit id="d91768d646bf2b1ba37683cf7ff89c9b306d5b4f" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;pod2text(1)&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;によって書かれた&lt;b&gt;pod2text（1）の&lt;/b&gt;コードに基づく</target>
        </trans-unit>
        <trans-unit id="e809a71bc55e573d735398064fa73868c841b25e" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;pod2text&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;によって書かれた&lt;b&gt;pod2textの&lt;/b&gt;コードに基づく</target>
        </trans-unit>
        <trans-unit id="23082a2ee1ef553f8b8e9cc56e439b97636f01bf" translate="yes" xml:space="preserve">
          <source>Based on code written by Shigio Yamaguchi.</source>
          <target state="translated">山口茂雄氏が書いたコードを元にしています。</target>
        </trans-unit>
        <trans-unit id="8e0d5bb83e47c2192346afc47fe774052eb51e39" translate="yes" xml:space="preserve">
          <source>Based on example that was initially added to MIME::QuotedPrint.pm for the 5.8.0 distribution of Perl.</source>
          <target state="translated">Perl の 5.8.0 ディストリビューション用に MIME::QuotedPrint.pm に最初に追加された例に基づいています。</target>
        </trans-unit>
        <trans-unit id="a800ab4559098c87aba7a8e90188704683d129b8" translate="yes" xml:space="preserve">
          <source>Based on ideas from Tim Bunce &amp;lt;&lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;gt; and</source>
          <target state="translated">Tim Bunce &amp;lt; &lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;gt;および</target>
        </trans-unit>
        <trans-unit id="ef4b57022699f0d3f5da98a8d57cddc66db361df" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;:perlio&lt;/code&gt; layer.</source>
          <target state="translated">&lt;code&gt;:perlio&lt;/code&gt; レイヤーに基づいています。</target>
        </trans-unit>
        <trans-unit id="6189eca4d6c06b60af97bb9ce0c1f1fc615c134d" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;ExtUtils::xsubpp&lt;/code&gt; code by Larry Wall and the Perl 5 Porters, which was released under the same license terms.</source>
          <target state="translated">同じライセンス条項に基づいてリリースされた、Larry WallとPerl 5 Portersによる &lt;code&gt;ExtUtils::xsubpp&lt;/code&gt; コードに基づいています。</target>
        </trans-unit>
        <trans-unit id="da8636da22477810e470724d83ddc721d3335da8" translate="yes" xml:space="preserve">
          <source>Based on the Glossary of</source>
          <target state="translated">の用語集に基づいて</target>
        </trans-unit>
        <trans-unit id="f28c9a8ac3d744f82801c7cfbb9de24801e7c563" translate="yes" xml:space="preserve">
          <source>Based on xsubpp code, written by Larry Wall.</source>
          <target state="translated">Larry Wallによって書かれたxsubppのコードをベースにしています。</target>
        </trans-unit>
        <trans-unit id="02905231fdcd4472df63f80b291fb153344c31cd" translate="yes" xml:space="preserve">
          <source>Basic BLOCKs</source>
          <target state="translated">基本的なBLOCK</target>
        </trans-unit>
        <trans-unit id="901e56ace2d31ac4485efe2aa588116787957443" translate="yes" xml:space="preserve">
          <source>Basic IO operations</source>
          <target state="translated">基本的なIO操作</target>
        </trans-unit>
        <trans-unit id="8422cb1795fcef709d3e089320f56308fec39046" translate="yes" xml:space="preserve">
          <source>Basic Multilingual Plane</source>
          <target state="translated">基本的な多言語の平面</target>
        </trans-unit>
        <trans-unit id="ccecd116866361404babdb87c039096fbb71e99c" translate="yes" xml:space="preserve">
          <source>Basic Structure</source>
          <target state="translated">基本構造</target>
        </trans-unit>
        <trans-unit id="39bbc4bee9f4a75c10797a6d328f733ea1124880" translate="yes" xml:space="preserve">
          <source>Basic Thread Support</source>
          <target state="translated">基本スレッドサポート</target>
        </trans-unit>
        <trans-unit id="17f89c170a632afd0c0b0383dacf728c05a89851" translate="yes" xml:space="preserve">
          <source>Basic Utilities for Programmers</source>
          <target state="translated">プログラマーのための基本的なユーティリティ</target>
        </trans-unit>
        <trans-unit id="148d2121cd077901af2d5cbf9aa363677304a06b" translate="yes" xml:space="preserve">
          <source>Basic commands:</source>
          <target state="translated">基本的なコマンドです。</target>
        </trans-unit>
        <trans-unit id="7308cb8418c068204c128968b5967fdf3606cc09" translate="yes" xml:space="preserve">
          <source>Basic methods</source>
          <target state="translated">基本的な方法</target>
        </trans-unit>
        <trans-unit id="874d9df75ebdafc19870b90059bb69c04cb1fce7" translate="yes" xml:space="preserve">
          <source>Basic read operation.</source>
          <target state="translated">基本的な読み取り操作を行います。</target>
        </trans-unit>
        <trans-unit id="c4901220ad10be08f037f204182ab7f0bb55ef8b" translate="yes" xml:space="preserve">
          <source>Basic semaphores</source>
          <target state="translated">基本的なセマフォ</target>
        </trans-unit>
        <trans-unit id="cf61d93532db2a473529a2856c70f230829513f8" translate="yes" xml:space="preserve">
          <source>Basic syntax overview</source>
          <target state="translated">基本構文の概要</target>
        </trans-unit>
        <trans-unit id="ce7944aa05e48b110f9c5b8903d70aed90358355" translate="yes" xml:space="preserve">
          <source>Basic utilities for writing tests.</source>
          <target state="translated">テストを書くための基本的なユーティリティ。</target>
        </trans-unit>
        <trans-unit id="62b9ac85afbcfa7bd7a8e867b1f51756e30ca7d7" translate="yes" xml:space="preserve">
          <source>Basic write operation.</source>
          <target state="translated">基本的な書き込み操作。</target>
        </trans-unit>
        <trans-unit id="04e2b1373d1c985716d261c139c35de4bc421d62" translate="yes" xml:space="preserve">
          <source>Basically, Intel and VAX CPUs are little-endian, while everybody else, including Motorola m68k/88k, PPC, Sparc, HP PA, Power, and Cray, are big-endian. Alpha and MIPS can be either: Digital/Compaq uses (well, used) them in little-endian mode, but SGI/Cray uses them in big-endian mode.</source>
          <target state="translated">基本的に、IntelとVAXのCPUはリトルエンディアンで、Motorola m68k/88k、PPC、Sparc、HP PA、Power、Crayなどの他のCPUはビッグエンディアンです。AlphaやMIPSはどちらでもいい。Digital/Compaq はリトルエンディアンモードで使用していますが、SGI/Cray はビッグエンディアンモードで使用しています。</target>
        </trans-unit>
        <trans-unit id="1f10fe5797c3d1f7733a7eb604c9de17cf9d91ac" translate="yes" xml:space="preserve">
          <source>Basically, you fetch individual results from the TAP. The six types, with examples of each, are as follows:</source>
          <target state="translated">基本的にはTAPから個別の結果を取得します。6つのタイプがあり、それぞれの例を挙げると以下のようになります。</target>
        </trans-unit>
        <trans-unit id="3764ce6b277261088796ef6723dbaafdda0e32f0" translate="yes" xml:space="preserve">
          <source>Be aware of two important points:</source>
          <target state="translated">重要な2つのポイントを意識しましょう。</target>
        </trans-unit>
        <trans-unit id="e4436a305cd04dc72f8078b037e6c2a662f1fa1d" translate="yes" xml:space="preserve">
          <source>Be aware that all filenames returned from File::Glob are tainted.</source>
          <target state="translated">File::Glob から返されるファイル名はすべて汚染されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="60f217633ac67f75e40713203caa69acc0ee5347" translate="yes" xml:space="preserve">
          <source>Be aware that setting &lt;code&gt;@DB::args&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;@DB::args&lt;/code&gt; 設定は</target>
        </trans-unit>
        <trans-unit id="667b9a553537bba23ef30dd15f8a2bf40c9a72d6" translate="yes" xml:space="preserve">
          <source>Be aware that the digest routines silently convert UTF-8 input into its equivalent byte sequence in the native encoding (cf. utf8::downgrade). This side effect influences only the way Perl stores the data internally, but otherwise leaves the actual value of the data intact.</source>
          <target state="translated">ダイジェストルーチンは、UTF-8入力をネイティブエンコーディングの等価なバイト列に無言で変換することに注意してください(utf8::downngrade参照)。この副作用は Perl が内部的にデータを保存する方法にのみ影響を与えますが、それ以外の場合はデータの実際の値をそのまま残します。</target>
        </trans-unit>
        <trans-unit id="167d28f752fc336f0724d4becf42fb8c17cf60ad" translate="yes" xml:space="preserve">
          <source>Be aware that the file's type/creator and resource fork will be lost, which is usually what you want in cross-platform archives.</source>
          <target state="translated">ファイルの type/creator と resource fork が失われることに注意してください。</target>
        </trans-unit>
        <trans-unit id="2a627d6aeb5bb9832269cd11d71094ebccabe8d0" translate="yes" xml:space="preserve">
          <source>Be aware that the main value of this module is its simplicity. Note that there are already more ambitious modules out there, such as &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Unit&quot;&gt;Test::Unit&lt;/a&gt;.</source>
          <target state="translated">このモジュールの主な価値はその単純さであることに注意してください。&lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt;や&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Unit&quot;&gt;Test :: Unit&lt;/a&gt;など、意欲的なモジュールがすでに存在していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="31de5d87ee0c0608b86806f39ac15e28011be167" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; had a chance to get the information. That means that &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; が情報を取得する前に、オプティマイザが呼び出しフレームを最適化していた可能性があることに注意してください。つまり、 &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;N &amp;gt; 1&lt;/code&gt; 場合、期待する呼び出しフレームに関する情報を返さない可能性があります。特に、 &lt;code&gt;@DB::args&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; が以前に呼び出されたときの情報が含まれている場合があります。</target>
        </trans-unit>
        <trans-unit id="956f008e111339a547685e28f223bd6fbcba83d9" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; had a chance to get the information. That means that &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; が情報を取得する前に、オプティマイザが呼び出しフレームを最適化していた可能性があることに注意してください。つまり、 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;N &amp;gt; 1&lt;/code&gt; 場合、期待する呼び出しフレームに関する情報を返さない可能性があります。特に、 &lt;code&gt;@DB::args&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; が以前に呼び出されたときの情報が含まれている場合があります。</target>
        </trans-unit>
        <trans-unit id="fd6d74606bcc17d1eb7f4b9d0cbb233b2fce04be" translate="yes" xml:space="preserve">
          <source>Be aware that the option to follow symbolic links can be dangerous. Depending on the structure of the directory tree (including symbolic links to directories) you might traverse a given (physical) directory more than once (only if &lt;code&gt;follow_fast&lt;/code&gt; is in effect). Furthermore, deleting or changing files in a symbolically linked directory might cause very unpleasant surprises, since you delete or change files in an unknown directory.</source>
          <target state="translated">シンボリックリンクをたどるオプションは危険な場合があることに注意してください。ディレクトリツリーの構造（ディレクトリへのシンボリックリンクを含む）によっては、特定の（物理）ディレクトリを複数回トラバースする場合があります（ &lt;code&gt;follow_fast&lt;/code&gt; が有効な場合のみ）。さらに、シンボリックリンクされたディレクトリのファイルを削除または変更すると、不明なディレクトリのファイルを削除または変更するため、非常に不愉快な驚きが生じる可能性があります。</target>
        </trans-unit>
        <trans-unit id="b81ba14d3ce3de8180275845ca38e42a572b2c9a" translate="yes" xml:space="preserve">
          <source>Be aware that these operations are full Unix forks, which means they may not be correctly implemented on all alien systems.</source>
          <target state="translated">これらの操作は完全な Unix のフォークであり、すべてのエイリアンシステムで正しく実装されているわけではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="6dac6d64c1feff1fddea48f799c315f06283805b" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source must be properly declared unless it is US-ASCII or Latin-1. POD input without an &lt;code&gt;=encoding&lt;/code&gt; command will be assumed to be in Latin-1, and if it's actually in UTF-8, the output will be double-encoded. See</source>
          <target state="translated">このオプションを使用する場合、US-ASCIIまたはLatin-1でない限り、PODソースの入力エンコーディングを適切に宣言する必要があることに注意してください。 &lt;code&gt;=encoding&lt;/code&gt; コマンドのないPOD入力はLatin-1であると想定され、実際にUTF-8である場合、出力は二重にエンコードされます。見る</target>
        </trans-unit>
        <trans-unit id="8e54fdab18656cd50e15f88c4bd2cd505cbcafa9" translate="yes" xml:space="preserve">
          <source>Be aware, moreover, that even among Unix-ish systems there are variations.</source>
          <target state="translated">さらに、Unix 系のシステムの中にもバリエーションがあることに注意してください。</target>
        </trans-unit>
        <trans-unit id="56eaa37568b649078a87e40ea7bc8697501ac281" translate="yes" xml:space="preserve">
          <source>Be careful about the syntax,</source>
          <target state="translated">構文には気をつけましょう。</target>
        </trans-unit>
        <trans-unit id="b3f347eeb5e9dd5ad6442952b1aeb5c318d4fa11" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; always returns true. See &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">画像を二重引用符で囲む場合は注意してください。 &lt;code&gt;@&lt;/code&gt; 文字は配列名の始まりを意味すると解釈される場合があります。 &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; は常にtrueを返します。他の例については&lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6906a7867a27a79ea2a227d91624d262e203f04e" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; always returns true. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">画像を二重引用符で囲む場合は注意してください。 &lt;code&gt;@&lt;/code&gt; 文字は配列名の始まりを意味すると解釈される場合があります。 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; は常にtrueを返します。他の例については&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a9293d7623c3a63a2528c6144b0e2f16fd9c21b7" translate="yes" xml:space="preserve">
          <source>Be careful in the tests you supply with your module or programs. Module code may be fully portable, but its tests might not be. This often happens when tests spawn off other processes or call external programs to aid in the testing, or when (as noted above) the tests assume certain things about the filesystem and paths. Be careful not to depend on a specific output style for errors, such as when checking &lt;code&gt;$!&lt;/code&gt; after a failed system call. Using &lt;code&gt;$!&lt;/code&gt; for anything else than displaying it as output is doubtful (though see the &lt;code&gt;Errno&lt;/code&gt; module for testing reasonably portably for error value). Some platforms expect a certain output format, and Perl on those platforms may have been adjusted accordingly. Most specifically, don't anchor a regex when testing an error value.</source>
          <target state="translated">モジュールまたはプログラムで提供するテストには注意してください。モジュールコードは完全に移植可能かもしれませんが、そのテストはそうではないかもしれません。これは、テストが他のプロセスを生成したり、外部プログラムを呼び出してテストを支援したり、（上記のように）テストがファイルシステムとパスについて特定のことを想定したりするときによく発生します。 &lt;code&gt;$!&lt;/code&gt; をチェックするときなど、エラーを特定の出力スタイルに依存しないように注意してください。システムコールが失敗した後。 &lt;code&gt;$!&lt;/code&gt; を使用する出力として表示する以外は何も疑わしいです（ただし、エラー値の移植性を合理的にテストするには、 &lt;code&gt;Errno&lt;/code&gt; モジュールを参照してください）。一部のプラットフォームは特定の出力形式を想定しており、それらのプラットフォームのPerlはそれに応じて調整されている可能性があります。最も具体的には、エラー値をテストするときに正規表現を固定しないでください。</target>
        </trans-unit>
        <trans-unit id="ae93e14e0d1be510a7665d0a55ac6aa4f668df14" translate="yes" xml:space="preserve">
          <source>Be careful to check that what you pass to chdir() is defined and not blank, else you might find yourself in your home directory.</source>
          <target state="translated">chdir()に渡すものが定義されていて、空白になっていないことを確認するように注意してください。</target>
        </trans-unit>
        <trans-unit id="c85ebb348de7431489e7e78b8e62158b4eaa9740" translate="yes" xml:space="preserve">
          <source>Be careful to check the return values from both open() and close(). If you're</source>
          <target state="translated">open()とclose()の両方からの戻り値を確認するように注意しましょう。もし、あなたが</target>
        </trans-unit>
        <trans-unit id="aee2df458bcc4bef02091d782f8436bc138473c7" translate="yes" xml:space="preserve">
          <source>Be careful to repeat this procedure every time you recompile an extension, unless you are sure the AFS installation directories are still valid.</source>
          <target state="translated">AFSのインストールディレクトリが有効であることを確認しない限り、拡張機能を再コンパイルするたびにこの手順を繰り返すように注意してください。</target>
        </trans-unit>
        <trans-unit id="fe76e94f1a35b852ed4a509f3683ff3f6a306181" translate="yes" xml:space="preserve">
          <source>Be careful when using the branch reset pattern in combination with named captures. Named captures are implemented as being aliases to numbered groups holding the captures, and that interferes with the implementation of the branch reset pattern. If you are using named captures in a branch reset pattern, it's best to use the same names, in the same order, in each of the alternations:</source>
          <target state="translated">ブランチリセットパターンを名前付きキャプチャと組み合わせて使用する場合は注意が必要です。名前付きキャプチャは、キャプチャを保持する番号付きグループへのエイリアスとして実装されており、ブランチリセットパターンの実装を妨害します。ブランチリセットパターンで名前付きキャプチャを使用する場合は、交互に同じ名前を同じ順番で使用するのがベストです。</target>
        </trans-unit>
        <trans-unit id="8f8df673aaa9f753cd8e9cf23c8cbbd3b2574c49" translate="yes" xml:space="preserve">
          <source>Be careful, though, to never combine text strings with binary strings. If you need text in a binary stream, encode your text strings first using the appropriate encoding, then join them with binary strings. See also: &quot;What if I don't encode?&quot;.</source>
          <target state="translated">ただし、テキスト文字列とバイナリ文字列を組み合わせないように注意してください。バイナリストリームのテキストが必要な場合は、まず適切なエンコーディングを使用してテキスト文字列をエンコードしてから、バイナリ文字列と結合します。こちらも参照してください。&quot;エンコードしない場合は?</target>
        </trans-unit>
        <trans-unit id="cef4ef62c32e58e84f80436ec819bfd5a7afa02c" translate="yes" xml:space="preserve">
          <source>Be careful: qx(), system(), and some modules for calling external commands do a fork(), then wait() for the result. Thus, your signal handler will be called. Because wait() was already called by system() or qx(), the wait() in the signal handler will see no more zombies and will therefore block.</source>
          <target state="translated">注意してください:qx()、system()、そして外部コマンドを呼び出すためのいくつかのモジュールは fork()を行い、その後、結果を待つための wait()を行います。そのため、シグナルハンドラが呼び出されます。wait()は system()や qx()によって既に呼び出されていたので、シグナルハンドラの wait()はそれ以上のゾンビを見ないので、ブロックされてしまいます。</target>
        </trans-unit>
        <trans-unit id="02350f9e1a884f10cacbddf6be8d623a44b68fcb" translate="yes" xml:space="preserve">
          <source>Be consistent with existing modules.</source>
          <target state="translated">既存のモジュールとの整合性をとる。</target>
        </trans-unit>
        <trans-unit id="8f9f60dfc3f60d9409a16936419f8f9c34030221" translate="yes" xml:space="preserve">
          <source>Be consistent.</source>
          <target state="translated">一貫していること。</target>
        </trans-unit>
        <trans-unit id="0657b8fedf171a48206a6318d37358a77e53c6fb" translate="yes" xml:space="preserve">
          <source>Be descriptive (i.e. accurately describes the purpose of the module).</source>
          <target state="translated">記述的であること(すなわち、モジュールの目的を正確に説明すること)。</target>
        </trans-unit>
        <trans-unit id="4866ce84e5913e3bbf14d1ef419eb24f1d72a52e" translate="yes" xml:space="preserve">
          <source>Be it &lt;code&gt;Compress::Zlib&lt;/code&gt; , &lt;code&gt;Apache::Request&lt;/code&gt; or any extension that has no mention of Unicode in the manpage, you need to make sure that the UTF8 flag is stripped off. Note that at the time of this writing (January 2012) the mentioned modules are not UTF-8-aware. Please check the documentation to verify if this is still true.</source>
          <target state="translated">それは &lt;code&gt;Compress::Zlib&lt;/code&gt; 、 &lt;code&gt;Apache::Request&lt;/code&gt; やマニュアルページにUnicodeの言及を持っていない任意の拡張子、あなたはUTF8フラグが剥ぎ取られていることを確認する必要があります。この記事の執筆時点（2012年1月）では、上記のモジュールはUTF-8に対応していません。これがまだ当てはまるかどうかを確認するには、ドキュメントを確認してください。</target>
        </trans-unit>
        <trans-unit id="fec8bd9db93426cc5f677cbbc44d58f990b4ce4f" translate="yes" xml:space="preserve">
          <source>Be nice.</source>
          <target state="translated">いい子にしてね</target>
        </trans-unit>
        <trans-unit id="455d700825e4b9a7601c1ce54b47786ce81ebe18" translate="yes" xml:space="preserve">
          <source>Be sure not to use a bareword as the name of a signal handler, lest you inadvertently call it.</source>
          <target state="translated">誤って信号ハンドラの名前として bareword を使用しないように注意してください。</target>
        </trans-unit>
        <trans-unit id="adcfe790c3214b8902aa2d9bdbc7f166d3aa2497" translate="yes" xml:space="preserve">
          <source>Be sure that your yacc installation is in place including any necessary parser template files. If you have not already done so then be sure to:</source>
          <target state="translated">必要なパーサーテンプレートファイルを含めて、yaccのインストールが適切に行われていることを確認してください。もしまだ行っていなければ、必ず行ってください。</target>
        </trans-unit>
        <trans-unit id="7a2fea634f3d3c3b87d0ddfbb5348eeeda046aad" translate="yes" xml:space="preserve">
          <source>Be sure to adequately comment your code. While commenting every line is unnecessary, anything that takes advantage of side effects of operators, that creates changes that will be felt outside of the function being patched, or that others may find confusing should be documented. If you are going to err, it is better to err on the side of adding too many comments than too few.</source>
          <target state="translated">コードには適切なコメントをつけてください。すべての行にコメントをつけることは不要ですが、演算子の副作用を利用したり、パッチを適用している関数の外で変化を感じたり、他の人が混乱するようなことがあれば、文書化しておくべきです。もしエラーを起こすのであれば、コメント数が少なすぎるよりも、多すぎるコメントを追加しない方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="df103353e12184ad2bab2c528d00c711c155c484" translate="yes" xml:space="preserve">
          <source>Be sure to include the &lt;b&gt;exact&lt;/b&gt; error messages, if any. &quot;Perl gave an error&quot; is not an exact error message.</source>
          <target state="translated">&lt;b&gt;正確な&lt;/b&gt;エラーメッセージがある場合は、必ず含めてください。「Perlがエラーを出しました」は正確なエラーメッセージではありません。</target>
        </trans-unit>
        <trans-unit id="b5cbd612657dfbf7a92d6606e16853c43b77addf" translate="yes" xml:space="preserve">
          <source>Be sure to read &lt;a href=&quot;#ENCODING&quot;&gt;ENCODING&lt;/a&gt; if your Pod contains non-ASCII characters.</source>
          <target state="translated">ポッドに非ASCII文字が含まれている場合は、必ず&lt;a href=&quot;#ENCODING&quot;&gt;エンコードを&lt;/a&gt;お読みください。</target>
        </trans-unit>
        <trans-unit id="2984603dd54138b13d352a1e3fd61b6408be6b9f" translate="yes" xml:space="preserve">
          <source>Be sure to read the instructions near the top of the makefiles carefully.</source>
          <target state="translated">makefileの上部近くにある説明書をよく読んでください。</target>
        </trans-unit>
        <trans-unit id="7f00ff2068b10342c9156aa44f6e62fb9656c3bb" translate="yes" xml:space="preserve">
          <source>Be sure to specify Perl version requirements both in Makefile.PL or Build.PL and with &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 5.6.1&lt;/code&gt; or similar. See the section on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; of &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for details.</source>
          <target state="translated">Makefile.PLまたはBuild.PL中との両方でPerlのバージョン要件を指定してください &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 5.6.1&lt;/code&gt; または類似。詳細は&lt;a href=&quot;functions/require&quot;&gt;requireの&lt;/a&gt; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; の&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;に関するセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="c733e8a30868a3838b1dfa41af03cf511ee097ca" translate="yes" xml:space="preserve">
          <source>Be sure to use a tar program compiled under Solaris (not SunOS 4.x) to extract the perl-5.x.x.tar.gz file. Do not use GNU tar compiled for SunOS4 on Solaris. (GNU tar compiled for Solaris should be fine.) When you run SunOS4 binaries on Solaris, the run-time system magically alters pathnames matching m#lib/locale# so that when tar tries to create lib/locale.pm, a file named lib/oldlocale.pm gets created instead. If you found this advice too late and used a SunOS4-compiled tar anyway, you must find the incorrectly renamed file and move it back to lib/locale.pm.</source>
          <target state="translated">ここでは必ず Solaris (SunOS 4.x ではない)でコンパイルされた tar プログラムを使用してください。SunOS4 用にコンパイルされた GNU tar を Solaris 上で使わないでください (Solaris 用にコンパイルされた GNU tar は問題ないはずです)。(Solaris 用にコンパイルされた GNU tar は問題ありません。)SunOS4 のバイナリを Solaris 上で実行すると、ランタイムシステムは m#lib/locale#にマッチするパス名を魔法のように変更し、tar が lib/locale.pm を作成しようとすると、代わりに lib/oldlocale.pm という名前のファイルが作成されるようにします。このアドバイスに気づくのが遅すぎて、SunOS4 でコンパイルされた tar を使っていた場合は、間違ってリネームされたファイルを見つけて、それを lib/locale.pm に戻さなければなりません。</target>
        </trans-unit>
        <trans-unit id="5d818ab86968387d2a89aaa4ecb39ab429064672" translate="yes" xml:space="preserve">
          <source>Be sure to use the libraries and modules shipped with the version being tested, not those that were already installed.</source>
          <target state="translated">すでにインストールされているライブラリやモジュールではなく、テストされるバージョンに同梱されているライブラリやモジュールを使用するようにしてください。</target>
        </trans-unit>
        <trans-unit id="e3d356b4e65052f33c752664cb97b29222d4870b" translate="yes" xml:space="preserve">
          <source>Be very careful with Perl operations that change the value of the variable. Appending something to the variable, for instance, might require reallocation of its storage, leaving you with a pointer into no-man's land.</source>
          <target state="translated">変数の値を変更するPerlの操作には十分注意してください。例えば、変数に何かを追加すると、ストレージの再割り当てが必要になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="a9df705eca9ff235f56efac76a8ae2aff600e09f" translate="yes" xml:space="preserve">
          <source>Be warned that neither creation nor deletion of files is guaranteed to be an atomic operation over NFS. That is, two processes might both successfully create or unlink the same file! Therefore O_EXCL isn't as exclusive as you might wish.</source>
          <target state="translated">ファイルの作成も削除も、NFS 上ではアトミックな操作であることが保証されていないことに注意してください。つまり、2 つのプロセスが同じファイルの作成やリンク解除に成功する可能性があるということです。そのため、O_EXCL は思ったほど排他的ではありません。</target>
        </trans-unit>
        <trans-unit id="7184ad30ab6a73d32aaec035835bc55ad15b3389" translate="yes" xml:space="preserve">
          <source>Be warned that some formatters cannot reliably render characters outside 32-126; and many are able to handle 32-126 and 160-255, but nothing above 255.</source>
          <target state="translated">フォーマッタの中には32-126以外の文字を確実にレンダリングできないものがあり、多くは32-126と160-255は扱えますが、255以上は扱えないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="8235118c9cdc1cd037bd4ff9c8b6234c4eceb334" translate="yes" xml:space="preserve">
          <source>Be warned that this feature is considered experimental, and may be changed without notice.</source>
          <target state="translated">この機能は実験的なものであり、予告なく変更されることがありますのでご注意ください。</target>
        </trans-unit>
        <trans-unit id="f60dd616afaa8860904852bce46c16c4c9385db0" translate="yes" xml:space="preserve">
          <source>Be warned, though, that unlike regular expressions, if the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; template doesn't match the incoming data, Perl will scream and die.</source>
          <target state="translated">ただし、正規表現とは異なり、 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; テンプレートが受信データと一致しない場合、Perlは悲鳴を上げて死ぬことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f34bea745032a10b52d62f12a9de185a88d00d76" translate="yes" xml:space="preserve">
          <source>Be warned: just as the C-preprocessor doesn't know C, the Debug filter doesn't know Perl. It can be fooled quite easily:</source>
          <target state="translated">注意:C プリプロセッサが C を知らないのと同様に、デバッグフィルタも Perl を知らないので注意してください。簡単に騙されてしまいます。</target>
        </trans-unit>
        <trans-unit id="29bff63d2a655090d41ce27755886c450bf1e989" translate="yes" xml:space="preserve">
          <source>BeOS is BeOS.</source>
          <target state="translated">BeOSはBeOSです。</target>
        </trans-unit>
        <trans-unit id="7127634cd20ce1300143c5a508c993ef4fdbd8f4" translate="yes" xml:space="preserve">
          <source>Because &quot;perlio.h&quot; is a thin layer (for efficiency) the semantics of these functions are somewhat dependent on the underlying implementation. Where these variations are understood they are noted below.</source>
          <target state="translated">perlio.h &quot;は(効率化のために)薄い層になっているため、これらの関数のセマンティクスは、基礎となる実装に多少依存します。これらの違いが理解できるところでは、以下に説明します。</target>
        </trans-unit>
        <trans-unit id="b63ce495f650d704c02d64d23b111efdfe40cd61" translate="yes" xml:space="preserve">
          <source>Because &lt;b&gt;perldoc&lt;/b&gt; does not run properly tainted, and is known to have security issues, when run as the superuser it will attempt to drop privileges by setting the effective and real IDs to nobody's or nouser's account, or -2 if unavailable. If it cannot relinquish its privileges, it will not run.</source>
          <target state="translated">ので&lt;b&gt;はperldocが&lt;/b&gt;適切に汚染を実行していない、およびセキュリティ上の問題を有することが知られているスーパーユーザーとして実行したとき、それは誰のかNOUSERの口座に効果的かつ現実のIDを設定することで、権限を削除しようと、あるいはだろう-2利用できない場合。特権を放棄できない場合は、実行されません。</target>
        </trans-unit>
        <trans-unit id="400d81a8582d02a7d364c167bb3655c111853cb4" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; trigger interpolation, you'll need to use something like &lt;code&gt;/\Quser\E\@\Qhost/&lt;/code&gt; to match them literally.</source>
          <target state="translated">ので &lt;code&gt;$&lt;/code&gt; または &lt;code&gt;@&lt;/code&gt; のようなトリガー補間、あなたが何かを使用する必要があります &lt;code&gt;/\Quser\E\@\Qhost/&lt;/code&gt; 文字通り、それらを一致させます。</target>
        </trans-unit>
        <trans-unit id="b667c475fa92312c7083687d2886a12150dc73b8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$sv&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when the &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; operator is applied to it, the transliteration won't actually execute and the program won't &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. This is different to how 5.8 and earlier versions behaved since the capture variables were READONLY variables then; now they'll just die when assigned to in the default engine.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 演算子を適用すると &lt;code&gt;$sv&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; であるため、文字変換は実際には実行されず、プログラムは &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ません。この場合、キャプチャ変数はREADONLY変数だったため、5.8以前のバージョンの動作とは異なります。これで、デフォルトのエンジンで割り当てられたときに、それらはただ死んでしまいます。</target>
        </trans-unit>
        <trans-unit id="5addc5234910932f591ed79ef1118cfac8717e21" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt; . The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt; s from the input list.</source>
          <target state="translated">いずれかのオペランドが &lt;code&gt;NaN&lt;/code&gt; （非数）の場合、 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返すため &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; ような比較関数でソートするときは、 &lt;code&gt;NaN&lt;/code&gt; を含む可能性のあるリストに注意してください。次の例では、という利点を取る &lt;code&gt;NaN != NaN&lt;/code&gt; どんな排除するため &lt;code&gt;NaN&lt;/code&gt; 入力リストから秒。</target>
        </trans-unit>
        <trans-unit id="dbfd747a0cfe35cb8ad11b2926956f99d4f77a54" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt; . The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt; s from the input list.</source>
          <target state="translated">いずれかのオペランドが &lt;code&gt;NaN&lt;/code&gt; （非数）の場合、 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返すため &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; ような比較関数でソートするときは、 &lt;code&gt;NaN&lt;/code&gt; を含む可能性のあるリストに注意してください。次の例では、という利点を取る &lt;code&gt;NaN != NaN&lt;/code&gt; どんな排除するため &lt;code&gt;NaN&lt;/code&gt; 入力リストから秒。</target>
        </trans-unit>
        <trans-unit id="89d0f8e67a21f5d12b3d2f9f3bbfa73cf7cb9115" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.&lt;/code&gt; is special in regular expressions, and can match any single character, the regex &lt;code&gt;P.&lt;/code&gt; here has matched the &amp;lt;Pl&amp;gt; in the original string.</source>
          <target state="translated">なぜなら &lt;code&gt;.&lt;/code&gt; 正規表現では特別であり、任意の1文字に一致できます &lt;code&gt;P.&lt;/code&gt; 正規表現Pは、元の文字列の&amp;lt;Pl&amp;gt;に一致しています。</target>
        </trans-unit>
        <trans-unit id="19a20b9f3a218df5a7c84d8e40e3cdca6928cac3" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.&lt;/code&gt; was in use as a directory separator and filenames could not be assumed to be unique after 10 characters, Acorn implemented the C compiler to strip the trailing &lt;code&gt;.c&lt;/code&gt;&lt;code&gt;.h&lt;/code&gt;&lt;code&gt;.s&lt;/code&gt; and &lt;code&gt;.o&lt;/code&gt; suffix from filenames specified in source code and store the respective files in subdirectories named after the suffix. Hence files are translated:</source>
          <target state="translated">なぜなら &lt;code&gt;.&lt;/code&gt; ディレクトリ区切り文字として使用されていて、ファイル名は10文字の後に一意であると想定できませんでした。AcornはCコンパイラを実装して、ソースコードで指定されたファイル名から末尾の &lt;code&gt;.c&lt;/code&gt; &lt;code&gt;.h&lt;/code&gt; &lt;code&gt;.s&lt;/code&gt; および &lt;code&gt;.o&lt;/code&gt; サフィックスを取り除き、それぞれのファイルを保存しましたサフィックスにちなんで名付けられたサブディレクトリ内。したがって、ファイルは翻訳されます。</target>
        </trans-unit>
        <trans-unit id="daf7ef166b9a7929b988f6a60b2c3afc2523b46d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; is a run-time operator, it gets executed each time through a loop. Consequently, it's more efficient to localize your variables outside the loop.</source>
          <target state="translated">ので &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 、実行時のオペレータである、それはループを通るたびに実行されます。したがって、ループの外で変数をローカライズする方が効率的です。</target>
        </trans-unit>
        <trans-unit id="2f69348654d069c347e7c5732088634fa13b4fd6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">ので &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 単項演算子であるあなたが誤っEXPRのために括弧付きのリストを使用している場合、スカラコンマ式のように、この振る舞いは、無効コンテキスト内のすべてのが、最後の要素を評価し、スカラーコンテキストで評価最後の要素を返します。これはめったにあなたが望むものではありません。</target>
        </trans-unit>
        <trans-unit id="f2af4d959eb62b1a9bf83d9e5254d41aa11be74b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; はコンパイル時に有効になるため、コンパイルされるコードの通常のフロー制御は考慮されません。特に、条件のfalseブランチ内に &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; を置いても、処理が妨げられることはありません。モジュールまたはプラグマを条件付きでのみロードする必要がある場合、これは&lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;プラグマを使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="4bb9a434db491939507421e019d5c81a08c7de9d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">ので &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 単項演算子であるあなたが誤っEXPRのために括弧付きのリストを使用している場合、スカラコンマ式のように、この振る舞いは、無効コンテキスト内のすべてのが、最後の要素を評価し、スカラーコンテキストで評価最後の要素を返します。これはめったにあなたが望むものではありません。</target>
        </trans-unit>
        <trans-unit id="c409d5f2e3bc5948e94957a82aeec5c28556f99d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; はコンパイル時に有効になるため、コンパイルされるコードの通常のフロー制御は考慮されません。特に、条件のfalseブランチ内に &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; を置いても、処理が妨げられることはありません。モジュールまたはプラグマを条件付きでのみロードする必要がある場合、これは&lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt;プラグマを使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="f7ea34c50bf47a71dd29a5e22af22a7376e9666b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;DESTROY&lt;/code&gt; methods can be called at any time, you should localize any global variables you might update in your &lt;code&gt;DESTROY&lt;/code&gt; . In particular, if you use &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; you should localize &lt;code&gt;$@&lt;/code&gt; , and if you use &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or backticks you should localize &lt;code&gt;$?&lt;/code&gt; .</source>
          <target state="translated">ので &lt;code&gt;DESTROY&lt;/code&gt; メソッドはいつでも呼び出すことができ、あなたはあなたに更新する可能性のあるグローバル変数ローカライズする必要があり &lt;code&gt;DESTROY&lt;/code&gt; を。特に、 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; を使用する場合は &lt;code&gt;$@&lt;/code&gt; をローカライズし、 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; またはバックティックを使用する場合は &lt;code&gt;$?&lt;/code&gt; をローカライズする必要があります。。</target>
        </trans-unit>
        <trans-unit id="1b1a7e8c9b3926d0057e1f91a59eec1bca6ac0fe" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PERL5LIB&lt;/code&gt; is often used during testing to add build directories to &lt;code&gt;@INC&lt;/code&gt; prove passes the names of any directories found in &lt;code&gt;PERL5LIB&lt;/code&gt; as -I switches. The net effect of this is that &lt;code&gt;PERL5LIB&lt;/code&gt; is honoured even when prove is run in taint mode.</source>
          <target state="translated">ので &lt;code&gt;PERL5LIB&lt;/code&gt; には、多くの場合に、ビルドディレクトリを追加するために、テスト中に使用されている &lt;code&gt;@INC&lt;/code&gt; で見つかった任意のディレクトリの名前渡し証明 &lt;code&gt;PERL5LIB&lt;/code&gt; -Iスイッチとしては。これの正味の効果は、proveが汚染モードで実行されている場合でも、 &lt;code&gt;PERL5LIB&lt;/code&gt; が受け入れられることです。</target>
        </trans-unit>
        <trans-unit id="8d8b86b2aa791fa81fa4a800514b6911cd4cea09" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PERL5LIB&lt;/code&gt; is often used during testing to add build directories to &lt;code&gt;@INC&lt;/code&gt;&lt;code&gt;Test::Harness&lt;/code&gt; passes the names of any directories found in &lt;code&gt;PERL5LIB&lt;/code&gt; as -I switches. The net effect of this is that &lt;code&gt;PERL5LIB&lt;/code&gt; is honoured even in taint mode.</source>
          <target state="translated">ので &lt;code&gt;PERL5LIB&lt;/code&gt; が、多くの場合に、ビルドディレクトリを追加するために、テスト中に使用されている &lt;code&gt;@INC&lt;/code&gt; &lt;code&gt;Test::Harness&lt;/code&gt; 任意のディレクトリの名前がで見つかっ渡し &lt;code&gt;PERL5LIB&lt;/code&gt; -Iスイッチとして。これの正味の効果は、汚染モードでも &lt;code&gt;PERL5LIB&lt;/code&gt; が尊重されることです。</target>
        </trans-unit>
        <trans-unit id="528ed40a74786c9daeb579970bad493df64c4a75" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PL_restartop&lt;/code&gt; is non-null, &lt;code&gt;run_body&lt;/code&gt; starts a new runops loop and execution continues.</source>
          <target state="translated">ので &lt;code&gt;PL_restartop&lt;/code&gt; が非nullで、 &lt;code&gt;run_body&lt;/code&gt; は新しいrunopsループを開始し、実行が継続されます。</target>
        </trans-unit>
        <trans-unit id="add12825d3665c5532bcf2a78d2469e31a8a7e9f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;STORABLE_attach&lt;/code&gt; is passed the class (rather than an object), it also returns the object directly, rather than modifying the passed object.</source>
          <target state="translated">&lt;code&gt;STORABLE_attach&lt;/code&gt; には（オブジェクトではなく）クラスが渡されるため、渡されたオブジェクトを変更するのではなく、オブジェクトを直接返します。</target>
        </trans-unit>
        <trans-unit id="308ec40cfa786d712d62a1e76733c4c3028b3e68" translate="yes" xml:space="preserve">
          <source>Because Acorns use ASCII with newlines (&lt;code&gt;\n&lt;/code&gt; ) in text files as &lt;code&gt;\012&lt;/code&gt; like Unix, and because Unix filename emulation is turned on by default, most simple scripts will probably work &quot;out of the box&quot;. The native filesystem is modular, and individual filesystems are free to be case-sensitive or insensitive, and are usually case-preserving. Some native filesystems have name length limits, which file and directory names are silently truncated to fit. Scripts should be aware that the standard filesystem currently has a name length limit of &lt;b&gt;10&lt;/b&gt; characters, with up to 77 items in a directory, but other filesystems may not impose such limitations.</source>
          <target state="translated">Acornsは、ASCIIをテキストファイル内の改行（ &lt;code&gt;\n&lt;/code&gt; ）とともにUNIXのような &lt;code&gt;\012&lt;/code&gt; として使用し、Unixファイル名エミュレーションはデフォルトでオンになっているため、ほとんどの単純なスクリプトは「そのまま」機能します。ネイティブファイルシステムはモジュール式であり、個々のファイルシステムは大文字と小文字を区別するか区別しないかは自由で、通常は大文字と小文字を区別します。一部のネイティブファイルシステムには名前の長さの制限があり、ファイル名とディレクトリ名は収まるように自動的に切り捨てられます。スクリプトは、標準のファイルシステムの名前の長さが&lt;b&gt;10&lt;/b&gt;文字に制限されており、ディレクトリ内に最大77個のアイテムがあることを認識しておく必要がありますが、他のファイルシステムではこのような制限を課さない場合があります。</target>
        </trans-unit>
        <trans-unit id="828cb90cec8613e5d83ab546b1c59479cecb4072" translate="yes" xml:space="preserve">
          <source>Because C has no builtin function for integer exponentiation, let's make Perl's ** operator available to it (this is less useful than it sounds, because Perl implements ** with C's</source>
          <target state="translated">C には整数の指数計算のための関数が組み込まれていないので、Perl の **演算子を利用できるようにしてみましょう(Perl は C の</target>
        </trans-unit>
        <trans-unit id="9459aa14a3cec514837284733b6c7f9c5dcb8910" translate="yes" xml:space="preserve">
          <source>Because Perl allows you to use barewords for package names and subroutine names, it sometimes interprets a bareword's meaning incorrectly. For example, the construct &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; can be interpreted as either &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; or &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; . In English, that second interpretation reads as &quot;call a subroutine named Class(), then call new() as a method on the return value of Class()&quot;. If there is a subroutine named &lt;code&gt;Class()&lt;/code&gt; in the current namespace, Perl will always interpret &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; as the second alternative: a call to &lt;code&gt;new()&lt;/code&gt; on the object returned by a call to &lt;code&gt;Class()&lt;/code&gt;</source>
          <target state="translated">Perlでは、パッケージ名とサブルーチン名にベアワードを使用できるため、ベアワードの意味が誤って解釈されることがあります。たとえば、 &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; は &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; または &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; として解釈できます。英語では、その2番目の解釈は「Class（）という名前のサブルーチンを呼び出してから、Class（）の戻り値のメソッドとしてnew（）を呼び出す」と解釈します。名前のサブルーチンがある場合は &lt;code&gt;Class()&lt;/code&gt; 現在の名前空間では、Perlは常に解釈する &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; 第二の代替として：への呼び出し &lt;code&gt;new()&lt;/code&gt; の呼び出しによって返されるオブジェクトの &lt;code&gt;Class()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aadc88ee4df674055a8e46229f25dab587fc29ec" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;../overload&quot;&gt;overload&lt;/a&gt; for details about that.</source>
          <target state="translated">Perlはキャッチされていない例外メッセージを表示する前に文字列化するため、例外オブジェクトに対する文字列化操作をオーバーロードする必要があるでしょう。詳細については、&lt;a href=&quot;../overload&quot;&gt;オーバーロード&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e1c5024f83c23d4c6dafd0e63d9f2e92824de07b" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; for details about that.</source>
          <target state="translated">Perlはキャッチされていない例外メッセージを表示する前に文字列化するため、例外オブジェクトに対する文字列化操作をオーバーロードする必要があるでしょう。詳細については、&lt;a href=&quot;overload&quot;&gt;オーバーロード&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2faaff7512cd20cbdff5d0e25efe8bfe139f7156" translate="yes" xml:space="preserve">
          <source>Because Perl uses doubles (or long doubles, if configured) internally for all numeric calculation, converting from double into float and thence to double again loses precision, so &lt;code&gt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&lt;/code&gt;) will not in general equal $foo.</source>
          <target state="translated">Perlはすべての数値計算に内部的にdouble（または構成されている場合はlong double）を使用するため、doubleからfloatに変換すると、再びdoubleに精度が失われるため、 &lt;code&gt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&lt;/code&gt; ）は一般に$ fooと同じです。</target>
        </trans-unit>
        <trans-unit id="398f8b38f72125ad882bed6f196a0775e260d2ad" translate="yes" xml:space="preserve">
          <source>Because UTF-8 is one of Perl's internal formats, you can often just skip the encoding or decoding step, and manipulate the UTF8 flag directly.</source>
          <target state="translated">UTF-8 は Perl の内部フォーマットの一つなので、エンコーディングやデコーディングのステップをスキップして、UTF8 フラグを直接操作することができます。</target>
        </trans-unit>
        <trans-unit id="6847617d71c84ec40d27c1365086ed8c20f1449c" translate="yes" xml:space="preserve">
          <source>Because UTF-EBCDIC is so similar to UTF-8, the differences are mostly hidden from you; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; (and NOT something like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utfebcdic&lt;/code&gt; ) declares the the script is in the platform's &quot;native&quot; 8-bit encoding of Unicode. (Similarly for the &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; layer.)</source>
          <target state="translated">UTF-EBCDICはUTF-8に非常に似ているため、その違いはほとんどユーザーには見えません。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; （および &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utfebcdic&lt;/code&gt; のようなものではない）は、スクリプトがプラットフォームの「ネイティブ」8ビットエンコーディングのUnicodeであることを宣言します。（ &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; レイヤーも同様です。）</target>
        </trans-unit>
        <trans-unit id="237849b1b007b545cf9244e10de8226da0ca3773" translate="yes" xml:space="preserve">
          <source>Because VMS's exit codes are much, much different than the rest of the universe, and perl does horrible mangling to them that gets in my way, it works like this on VMS.</source>
          <target state="translated">VMS の終了コードは他の宇宙のものとはかなり違っていて、Perl は私の邪魔になるようなひどいマングリングをしているので、VMS ではこのように動作しています。</target>
        </trans-unit>
        <trans-unit id="815d9b38e08d4ff6dad9bd30fba64b1ec6e8aeb8" translate="yes" xml:space="preserve">
          <source>Because XS modules require re-linking of the perl binary, you need both the perl binary distribution and the perl source distribution to build an XS extension module. In addition, you will have to have built your perl binary from the source distribution so that all of the components of the perl binary are available for the required link step.</source>
          <target state="translated">XSモジュールはperlバイナリの再リンクが必要なので、XS拡張モジュールを構築するには、perlバイナリとperlソースの両方が必要です。さらに、必要なリンクステップに必要な perl バイナリのすべてのコンポーネントが利用できるように、ソース・ディストリビューションから perl バイナリをビルドしておく必要があります。</target>
        </trans-unit>
        <trans-unit id="b57c6e3153bc9c89950406d1bdb5e4a01632a292" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; match doesn't reset the offset, the return from &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; won't change either in this case. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; 一致に失敗してもオフセットはリセットされないため、この場合も &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; からの戻り値は変わりません。&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;と&lt;a href=&quot;perlop&quot;&gt;perlopを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="aac46af0a65c30c1278fb04116da06849260131d" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;&lt;a href=&quot;m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; match doesn't reset the offset, the return from &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; won't change either in this case. See &lt;a href=&quot;../perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; 一致に失敗してもオフセットはリセットされないため、この場合も &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; からの戻り値は変わりません。&lt;a href=&quot;../perlre&quot;&gt;perlre&lt;/a&gt;と&lt;a href=&quot;../perlop&quot;&gt;perlopを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9eb2a05168485f04f9e352bc656013c7106c3b67" translate="yes" xml:space="preserve">
          <source>Because a list of potential candidates is returned, the &lt;code&gt;while&lt;/code&gt; loop tries each in turn until it finds one that succeeds both the socket() and connect() calls.</source>
          <target state="translated">潜在的な候補のリストが返されるので、 &lt;code&gt;while&lt;/code&gt; ループは、socket（）呼び出しとconnect（）呼び出しの両方に成功する候補が見つかるまで、順番に試行します。</target>
        </trans-unit>
        <trans-unit id="93bb95979fc3bb902bf7566626913de80d560dcc" translate="yes" xml:space="preserve">
          <source>Because a name correction may be added in future Unicode releases, the name that &lt;code&gt;viacode&lt;/code&gt; returns may change as a result. This is a rare event, but it does happen.</source>
          <target state="translated">名前の修正は将来のUnicodeリリースで追加される可能性があるため、 &lt;code&gt;viacode&lt;/code&gt; が返す名前は結果として変更される可能性があります。これはまれなイベントですが、発生します。</target>
        </trans-unit>
        <trans-unit id="284e0db6a72cf3c4c7c4890513562109eb2a9995" translate="yes" xml:space="preserve">
          <source>Because a period is a metacharacter, it needs to be escaped to match as an ordinary period. Because, for example, &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; are sets of characters, it is incorrect to think of &lt;code&gt;[^\d\w]&lt;/code&gt; as &lt;code&gt;[\D\W]&lt;/code&gt; ; in fact &lt;code&gt;[^\d\w]&lt;/code&gt; is the same as &lt;code&gt;[^\w]&lt;/code&gt;, which is the same as &lt;code&gt;[\W]&lt;/code&gt; . Think DeMorgan's laws.</source>
          <target state="translated">ピリオドはメタ文字であるため、通常のピリオドと一致するようにエスケープする必要があります。たとえば、 &lt;code&gt;\d&lt;/code&gt; と &lt;code&gt;\w&lt;/code&gt; は文字のセットであるため、 &lt;code&gt;[^\d\w]&lt;/code&gt; を &lt;code&gt;[\D\W]&lt;/code&gt; と考えるのは誤りです。実際、 &lt;code&gt;[^\d\w]&lt;/code&gt; は &lt;code&gt;[^\w]&lt;/code&gt; と同じで、 &lt;code&gt;[\W]&lt;/code&gt; と同じです。DeMorganの法則を考えてみてください。</target>
        </trans-unit>
        <trans-unit id="934c60da6f18a9def8d944b8bcb6ee8755c35fe6" translate="yes" xml:space="preserve">
          <source>Because access() does not invoke stat() (at least not in a way visible to Perl), &lt;b&gt;the stat result cache &quot;_&quot; is not set&lt;/b&gt;. This means that the outcome of the following two tests is different. The first has the stat bits of</source>
          <target state="translated">access（）はstat（）を呼び出さないため（少なくともPerlから見える方法で&lt;b&gt;は&lt;/b&gt;）、&lt;b&gt;統計結果キャッシュ &quot;_&quot;は設定されません&lt;/b&gt;。つまり、次の2つのテストの結果は異なります。1つ目の統計ビットは</target>
        </trans-unit>
        <trans-unit id="390a39256a176624bc85b17cecc4ce28e0fc7e67" translate="yes" xml:space="preserve">
          <source>Because assignment of a reference to a typeglob creates an alias, this can be used to create what is effectively a local function, or at least, a local alias.</source>
          <target state="translated">タイプグローブへの参照を代入するとエイリアスが作成されるので、これを使用して実質的にローカルな関数、あるいは少なくともローカルなエイリアスを作成することができます。</target>
        </trans-unit>
        <trans-unit id="0fe40d9c5df21e57c6ec455bae627177153c51cf" translate="yes" xml:space="preserve">
          <source>Because backticks do not affect standard error, use shell file descriptor syntax (assuming the shell supports this) if you care to address this. To capture a command's STDERR and STDOUT together:</source>
          <target state="translated">バックロックは標準エラーには影響しないので、これに対処したい場合は、シェルファイル記述子構文を使用してください(シェルがこれをサポートしていると仮定して)。コマンドのSTDERRとSTDOUTを一緒にキャプチャするには</target>
        </trans-unit>
        <trans-unit id="58a3a4b137a2ac3042f5ce6d5ed31ccf52919b18" translate="yes" xml:space="preserve">
          <source>Because both CRLF and LF end in LF, the input record separator can be set to LF and any CR stripped later. Better to write:</source>
          <target state="translated">CRLFもLFもLFで終わるので、入力レコードのセパレータをLFに設定して、後からCRを剥ぎ取ることができます。書いた方が良い。</target>
        </trans-unit>
        <trans-unit id="a49e08801e09e4ade1a0feed4948dfc00925efc8" translate="yes" xml:space="preserve">
          <source>Because curly brackets (braces) are used for several other things including BLOCKs, you may occasionally have to disambiguate braces at the beginning of a statement by putting a &lt;code&gt;+&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in front so that Perl realizes the opening brace isn't starting a BLOCK. The economy and mnemonic value of using curlies is deemed worth this occasional extra hassle.</source>
          <target state="translated">中かっこ（中かっこ）は、BLOCKを含む他のいくつかのものに使用されるため、ステートメントの先頭で &lt;code&gt;+&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; を前に置くことにより、中かっこを明確にする必要がある場合があります。。カーリーを使用することの経済的および記憶的価値は、この時折の余分な面倒の価値があると見なされます。</target>
        </trans-unit>
        <trans-unit id="b7b830bba46d3c56bd91aa88ed2e25a2ca316287" translate="yes" xml:space="preserve">
          <source>Because depending on a directory to just ensure it exists doesn't work too well (the modified time changes too often) dir_target() creates a .exists file in the created directory. It is this you should depend on. For portability purposes you should use the $(DIRFILESEP) macro rather than a '/' to separate the directory from the file.</source>
          <target state="translated">ディレクトリに依存して存在を確認するだけではあまりうまくいかないので(変更時刻が頻繁に変わるので)、dir_target()は作成されたディレクトリに.existsファイルを作成します。これに依存すべきです。移植性のためには、ディレクトリとファイルを分離するために'/'ではなく、$(DIRFILESEP)マクロを使うべきです。</target>
        </trans-unit>
        <trans-unit id="e43a24b825ab27b01432c41cd607e2f4d3328c51" translate="yes" xml:space="preserve">
          <source>Because each operand is evaluated in integer form, &lt;code&gt;2.18 .. 3.14&lt;/code&gt; will return two elements in list context.</source>
          <target state="translated">各オペランドは整数形式で評価されるため、 &lt;code&gt;2.18 .. 3.14&lt;/code&gt; はリストコンテキストで2つの要素を返します。</target>
        </trans-unit>
        <trans-unit id="d594331311925ecf9da3e16eb2cdc66b10c06327" translate="yes" xml:space="preserve">
          <source>Because even on non-Unix ports, Perl's glob function follows standard Unix globbing semantics. You'll need &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob(&quot;*&quot;)&lt;/a&gt;&lt;/code&gt; to get all (non-hidden) files. This makes glob() portable even to legacy systems. Your port may include proprietary globbing functions as well. Check its documentation for details.</source>
          <target state="translated">非Unixポートでも、Perlのglob関数は標準のUnixグロビングセマンティクスに従います。すべての（非表示でない）ファイルを取得するには、 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob(&quot;*&quot;)&lt;/a&gt;&lt;/code&gt; が必要です。これにより、glob（）はレガシーシステムにも移植可能になります。ポートには、独自のグロビング機能も含まれている場合があります。詳細については、ドキュメントを確認してください。</target>
        </trans-unit>
        <trans-unit id="2981f551145cc9ed169b464d8c0a095e7cf58a72" translate="yes" xml:space="preserve">
          <source>Because historically some operating systems silently chopped off kernel interpretation of the &lt;code&gt;#!&lt;/code&gt; line after 32 characters, some switches may be passed in on the command line, and some may not; you could even get a &quot;-&quot; without its letter, if you're not careful. You probably want to make sure that all your switches fall either before or after that 32-character boundary. Most switches don't actually care if they're processed redundantly, but getting a &quot;-&quot; instead of a complete switch could cause Perl to try to execute standard input instead of your program. And a partial &lt;b&gt;-I&lt;/b&gt; switch could also cause odd results.</source>
          <target state="translated">歴史的に一部のオペレーティングシステムは、 &lt;code&gt;#!&lt;/code&gt; カーネル解釈を黙って切り刻んだからです。32文字の後の行では、コマンドラインで渡されるスイッチと渡されないスイッチがあります。注意しないと、文字なしで &quot;-&quot;を受け取ることもできます。おそらく、すべてのスイッチがその32文字の境界の前または後のいずれかにあることを確認する必要があります。ほとんどのスイッチは、冗長に処理されているかどうかを実際には気にしませんが、完全なスイッチの代わりに「-」を取得すると、Perlがプログラムの代わりに標準入力を実行しようとする可能性があります。また、部分的な&lt;b&gt;-I&lt;/b&gt;スイッチも奇妙な結果を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="0e93d867e0e61a9f65c5551095616b09fa36af42" translate="yes" xml:space="preserve">
          <source>Because if _1 is one, you get &quot;1 document &lt;b&gt;were&lt;/b&gt; matched&quot;. An acceptable hack here is to do something like this:</source>
          <target state="translated">_1が1の場合、「1つのドキュメント&lt;b&gt;が&lt;/b&gt;一致した」という結果&lt;b&gt;が&lt;/b&gt;得られるためです。ここで許容できるハックは、次のようなことです。</target>
        </trans-unit>
        <trans-unit id="14e83724617636cdff52bc89c9135eb24a32b2c3" translate="yes" xml:space="preserve">
          <source>Because it is not possible to reliably tell UTF-8 from native 8 bit encodings, you need either a Byte Order Mark at the beginning of your source code, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; , to instruct perl.</source>
          <target state="translated">UTF-8をネイティブの8ビットエンコーディングから確実に区別することはできないため、ソースコードの先頭にバイトオーダーマークを付けるか、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用する&lt;/a&gt;必要があります。、perlに指示します。</target>
        </trans-unit>
        <trans-unit id="8c9a76f6de0976ec0aec1cbf80b933b451074248" translate="yes" xml:space="preserve">
          <source>Because it's a module, not an integral part of the interpreter, NEXT.pm has to guess where the surrounding call was found in the method look-up sequence. In the presence of diamond inheritance patterns it occasionally guesses wrong.</source>
          <target state="translated">これはモジュールであってインタプリタの不可欠な部分ではないので、NEXT.pm はメソッドのルックアップシーケンスの中で周囲の呼び出しがどこで見つかったかを推測しなければなりません。ダイアモンド継承パターンの存在下では、時折間違った推測をします。</target>
        </trans-unit>
        <trans-unit id="1b07afd521e75a07298e5e250bb27a3b27578dea" translate="yes" xml:space="preserve">
          <source>Because loading in the &lt;code&gt;IO::Handle&lt;/code&gt; class is an expensive operation, you should learn how to use the regular built-in variables.</source>
          <target state="translated">&lt;code&gt;IO::Handle&lt;/code&gt; クラスのロードは負荷の高い操作であるため、通常の組み込み変数の使用方法を学ぶ必要があります。</target>
        </trans-unit>
        <trans-unit id="fb1b328dbd0a94624aa3c89dafc392fc30581afd" translate="yes" xml:space="preserve">
          <source>Because many operating systems permit anyone with read access to the Perl program file to make a copy of it, patch the copy, and then execute the copy, the security-conscious Perl programmer should take care to invoke the installed copy of perl, not the copy referenced by &lt;code&gt;$^X&lt;/code&gt; . The following statements accomplish this goal, and produce a pathname that can be invoked as a command or referenced as a file.</source>
          <target state="translated">多くのオペレーティングシステムでは、Perlプログラムファイルへの読み取りアクセス権を持つすべてのユーザーがファイルのコピーを作成し、コピーにパッチを適用してから、コピーを実行できるため、セキュリティを意識したPerlプログラマは、インストールされているperlのコピーではなく、perlのインストールされたコピーを呼び出す必要があります。 &lt;code&gt;$^X&lt;/code&gt; によって参照されるコピー。次のステートメントは、この目的を達成し、コマンドとして呼び出したり、ファイルとして参照したりできるパス名を生成します。</target>
        </trans-unit>
        <trans-unit id="9fda5ef27e15d5bae07e31ec0802921ed805374c" translate="yes" xml:space="preserve">
          <source>Because native operating system filehandles are global and are currently allocated down from 255, with 0 being a reserved value, the Unix emulation library emulates Unix filehandles. Consequently, you can't rely on passing &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , or &lt;code&gt;STDERR&lt;/code&gt; to your children.</source>
          <target state="translated">ネイティブオペレーティングシステムのファイルハンドルはグローバルであり、現在255から割り当てられており、0は予約済みの値であるため、UnixエミュレーションライブラリはUnixファイルハンドルをエミュレートします。したがって、子供に &lt;code&gt;STDIN&lt;/code&gt; 、 &lt;code&gt;STDOUT&lt;/code&gt; 、または &lt;code&gt;STDERR&lt;/code&gt; を渡すことはできません。</target>
        </trans-unit>
        <trans-unit id="f5e62ec9329120e24ef0d8c20f22f5389de7c7e2" translate="yes" xml:space="preserve">
          <source>Because objects in Perl are implemented as references, it's possible to have circular references with objects as well. Imagine a TreeNode class where each node references its parent and child nodes. Any node with a parent will be part of a circular reference.</source>
          <target state="translated">Perl のオブジェクトは参照として実装されているため、オブジェクトでも循環参照を行うことができます。各ノードがその親ノードと子ノードを参照する TreeNode クラスを想像してみてください。親ノードを持つノードはすべて循環参照の一部になります。</target>
        </trans-unit>
        <trans-unit id="0bd5958f518c949c2219a905e834fb00df87ae4a" translate="yes" xml:space="preserve">
          <source>Because of DST changes, there are many time zones where the same local time occurs for two different GMT times on the same day. For example, in the &quot;Europe/Paris&quot; time zone, the local time of 2001-10-28 02:30:00 can represent either 2001-10-28 00:30:00 GMT, &lt;b&gt;or&lt;/b&gt; 2001-10-28 01:30:00 GMT.</source>
          <target state="translated">DSTが変更されているため、同じローカル時刻が同じ日の2つの異なるGMT時間で発生する多くのタイムゾーンがあります。たとえば、「ヨーロッパ/パリ」のタイムゾーンでは、2001-10-28 02:30:00の現地時間は2001-10-28 00:30:00 GMT &lt;b&gt;または&lt;/b&gt; 2001-10-28 01のいずれかを表すことができます。 30:00 GMT。</target>
        </trans-unit>
        <trans-unit id="65864a7a85dc93ea309cdec582c118e5dd979f14" translate="yes" xml:space="preserve">
          <source>Because of a bug in perl (#19213), at least in version 5.6.1, we have to hardcode the path separator for a require on Win32 to be &lt;code&gt;/&lt;/code&gt;, like on Unix rather than the Win32 &lt;code&gt;\&lt;/code&gt; . Otherwise perl will not read its own %INC accurately double load files if they are required again, or in the worst case, core dump.</source>
          <target state="translated">そのためのperlのバグ（＃19213）の、バージョン5.6.1で、少なくとも、私たちがするのWin32上で必要とするためにパス区切りをハードコーディングする必要が &lt;code&gt;/&lt;/code&gt; 、Unixのではなく、Win32の上のような &lt;code&gt;\&lt;/code&gt; 。そうしないと、perlは、再度必要になった場合、または最悪の場合はコアダンプの場合に、独自の％INCダブルロードファイルを正確に読み取りません。</target>
        </trans-unit>
        <trans-unit id="4f334a2266086aa81e3afdad8578b63a9a352bf3" translate="yes" xml:space="preserve">
          <source>Because of a lack of anything better, this module uses its own routines to pack and unpack ICMP packets. It would be better for a separate module to be written which understands all of the different kinds of ICMP packets.</source>
          <target state="translated">このモジュールでは、ICMPパケットのパックとアンパックに独自のルーチンを使用しています。ICMP パケットの種類をすべて理解できるような別のモジュールを書いた方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="c50ff3946dd738899f690c4bd5e562356a6223d1" translate="yes" xml:space="preserve">
          <source>Because of all these problems, starting in v5.22, Perl will raise a warning if a multi-byte (hence Unicode) code point is used when a single-byte locale is in effect. (Although it doesn't check for this if doing so would unreasonably slow execution down.)</source>
          <target state="translated">このような問題があったため、v5.22 以降、Perl はシングルバイトのロケールを使用しているときにマルチバイト (つまり Unicode)のコードポイントを使用すると警告を出すようになりました (ただし、そうすると実行速度が不当に遅くなるかどうかはチェックしていません)。(ただし、そうすると実行速度が不当に遅くなるかどうかはチェックしていません)。</target>
        </trans-unit>
        <trans-unit id="7eca024239d85bdb38cb09ea249ea5b41add05bc" translate="yes" xml:space="preserve">
          <source>Because of backward compatibility with legacy encodings, the &quot;a unique number for every character&quot; idea breaks down a bit: instead, there is &quot;at least one number for every character&quot;. The same character could be represented differently in several legacy encodings. The converse is not true: some code points do not have an assigned character. Firstly, there are unallocated code points within otherwise used blocks. Secondly, there are special Unicode control characters that do not represent true characters.</source>
          <target state="translated">レガシーエンコーディングとの下位互換性のため、「すべての文字に固有の番号」という考えは少し崩れています。同じ文字でも、複数のレガシーエンコーディングでは異なる表現になる可能性があります。逆もまた真ではありません:いくつかのコードポイントには割り当てられた文字がありません。第一に、 そうでなければ使われていないブ ロ ッ ク の中には、 割り当てられていない コ ー ド 点があ り ます。第二に、真のキ ャ ラ ク タ を表現 し ない特殊な Unicode 制御キ ャ ラ ク タ があ り ます。</target>
        </trans-unit>
        <trans-unit id="6c5cc2c32fa019382bf3152d3598a8ccd6be4473" translate="yes" xml:space="preserve">
          <source>Because of being able to omit the curlies for the simple case of &lt;code&gt;$$x&lt;/code&gt; , people often make the mistake of viewing the dereferencing symbols as proper operators, and wonder about their precedence. If they were, though, you could use parentheses instead of braces. That's not the case. Consider the difference below; case 0 is a short-hand version of case 1,</source>
          <target state="translated">&lt;code&gt;$$x&lt;/code&gt; 単純なケースでは中括弧を省略できるため、逆参照記号を適切な演算子として表示することを誤解し、それらの優先順位に疑問を感じることがよくあります。ただし、そうであれば、中括弧の代わりに括弧を使用できます。そうではありません。以下の違いを考慮してください。ケース0はケース1の簡略版です。</target>
        </trans-unit>
        <trans-unit id="e900a4e123821bf1949cbdd4fb9b5da407117914" translate="yes" xml:space="preserve">
          <source>Because of clock granularity, expiration times may occur up to one second sooner than you expect. For example, suppose you store a value with a lifetime of ten seconds, and you store it at 12:00:00.998 on a certain day. Memoize will look at the clock and see 12:00:00. Then 9.01 seconds later, at 12:00:10.008 you try to read it back. Memoize will look at the clock and see 12:00:10 and conclude that the value has expired. This will probably not occur if you have &lt;code&gt;Time::HiRes&lt;/code&gt; installed.</source>
          <target state="translated">クロックの細分性のため、有効期限は予想よりも最大1秒早く発生する場合があります。たとえば、ライフタイムが10秒の値を格納し、特定の日の12：00：00.998に格納するとします。 Memoizeは時計を見て、12：00：00を参照します。次に9.01秒後の12：00：10.008に、それを読み返そうとします。 Memoizeは時計を見て12:00:10を確認し、値が期限切れであると結論付けます。 &lt;code&gt;Time::HiRes&lt;/code&gt; インストールされている場合、これはおそらく発生しません。</target>
        </trans-unit>
        <trans-unit id="c6e7a0449744f95f7025dc0e8c4838b8d0860c99" translate="yes" xml:space="preserve">
          <source>Because of idiosyncrasies of OS/2 one cannot have all the eggs in the same basket (though EMX environment tries hard to overcome this limitations, so the situation may somehow improve). There are 4 executables for Perl provided by the distribution:</source>
          <target state="translated">OS/2 の特殊性のため、すべての卵を同じバスケットに入れることはできません (ただし、EMX 環境はこの制限を克服しようと努力していますので、状況は何とか改善されるかもしれません)。ディストリビューションで提供されている Perl の実行ファイルは 4 つあります。</target>
        </trans-unit>
        <trans-unit id="38b54108e9558724b240349ad9589f54bf027fa2" translate="yes" xml:space="preserve">
          <source>Because of its global effect, this setting should not be used inside modules or the like.</source>
          <target state="translated">グローバルな効果があるため、この設定はモジュールなどの内部では使用しないでください。</target>
        </trans-unit>
        <trans-unit id="cc4be6e39aa524fd29878685a03b1168c2bf5d9f" translate="yes" xml:space="preserve">
          <source>Because of our problems with the native yacc we used GNU bison to generate a pure (=reentrant) parser for perly.y. So our yacc is really the following script:</source>
          <target state="translated">ネイティブyaccの問題があったので、perly.y用の純粋な(=reentrant)パーサを生成するためにGNU bisonを使用しました。</target>
        </trans-unit>
        <trans-unit id="9835e5c9cd0a637bdd223f60f76a72232d5d4783" translate="yes" xml:space="preserve">
          <source>Because of the &quot;text&quot; mode translation, DOSish perls have limitations in using &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; on a file accessed in &quot;text&quot; mode. Stick to &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;-ing to locations you got from &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; (and no others), and you are usually free to use &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; even in &quot;text&quot; mode. Using &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; or other file operations may be non-portable. If you use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; on a file, however, you can usually &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; with arbitrary values safely.</source>
          <target state="translated">「テキスト」モードの変換のため、DOSish perlは「テキスト」モードでアクセスされたファイルで &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; アンド &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; を使用する際に制限があります。 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; から取得した場所（他の場所ではない）に &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; することに固執します。通常、「テキスト」モードでも &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; アンド &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 自由に使用できます。 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 、またはその他のファイル操作の使用は、移植できない場合があります。ただし、ファイルで &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; を使用すると、通常は任意の値を安全に &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; して &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; ことができます。</target>
        </trans-unit>
        <trans-unit id="86b041b8cdbf2e2a44b563d3f9086435ec867343" translate="yes" xml:space="preserve">
          <source>Because of the 16-bitness, UTF-16 is byte-order dependent. UTF-16 itself can be used for in-memory computations, but if storage or transfer is required either UTF-16BE (big-endian) or UTF-16LE (little-endian) encodings must be chosen.</source>
          <target state="translated">16 ビ ッ ト ネスのため、 UTF-16 はバ イ ト 順序に依存 し ます。UTF-16 自体は メ モ リ 内計算に使えますが、 保存ま たは転送が必要な場合は UTF-16BE (ビ ッ グエンデ ィ ア ン)か UTF-16LE (リトルエンデ ィ ア ン)エン コ ーデ ィ ン グ を選ぶ必要があ り ます。</target>
        </trans-unit>
        <trans-unit id="ddcee3f7b2710d631ab7d25c7c6ccf7f643a3fe9" translate="yes" xml:space="preserve">
          <source>Because of the algorithm used, ISO-8859 series and other single-byte encodings do not work well unless either one of ISO-8859 is the only one suspect (besides ascii and utf8).</source>
          <target state="translated">アルゴリズムが使われているため、ISO-8859シリーズなどのシングルバイトエンコーディングは、(asciiやutf8以外にも)ISO-8859のどちらか1つだけが疑われない限り、うまく動作しません。</target>
        </trans-unit>
        <trans-unit id="11b9a9053f80eaf386518a04692ab13e4782146b" translate="yes" xml:space="preserve">
          <source>Because of the unexpected behaviors associated with this modifier, you probably should only use it to maintain weird backward compatibilities.</source>
          <target state="translated">この修飾子に関連した予期せぬ動作があるため、奇妙な下位互換性を維持するためだけに使うべきでしょう。</target>
        </trans-unit>
        <trans-unit id="033d419ed47a31e5b1999d8b2e6265eaff662dc3" translate="yes" xml:space="preserve">
          <source>Because of their special use by sort(), the variables $a and $b are exempted from this check.</source>
          <target state="translated">sort()で特別に使用されるため、変数 $a と $b はこのチェックから除外されます。</target>
        </trans-unit>
        <trans-unit id="b4c8809b3046a08b3452bb5931521fe0616806ce" translate="yes" xml:space="preserve">
          <source>Because of this mechanism it is important that &lt;b&gt;AutoLoader&lt;/b&gt; is always &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;d and not &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d.</source>
          <target state="translated">このメカニズムのため、&lt;b&gt;オートローダー&lt;/b&gt;が常にdを &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; dを &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; としないことが重要です。</target>
        </trans-unit>
        <trans-unit id="cf9b61922d31b09cb33aab7bed1a50c499c2933e" translate="yes" xml:space="preserve">
          <source>Because of those two, the code paging approach used use in ucm-based Encoding SOMETIMES fails so this module was written.</source>
          <target state="translated">この2つのため、ucm-based Encoding SOMETIMESで使用されているコードページングアプローチは失敗するので、このモジュールが書かれました。</target>
        </trans-unit>
        <trans-unit id="4732978c8da8f3cf527ff9f22b157a0776b9721a" translate="yes" xml:space="preserve">
          <source>Because patterns are processed as double-quoted strings, the following also work:</source>
          <target state="translated">パターンは二重引用符で囲まれた文字列として処理されるため、以下のようにも動作します。</target>
        </trans-unit>
        <trans-unit id="e94cf9546dd5c84d3c599b01ef4e83754d69c340" translate="yes" xml:space="preserve">
          <source>Because perl needs to parse the script before applying this pragma, such encodings as Shift_JIS and Big-5 that may contain &lt;code&gt;'\'&lt;/code&gt; (BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt; ) in the second byte fail because the second byte may accidentally escape the quoting character that follows.</source>
          <target state="translated">perlはこのプラグマを適用する前にスクリプトを解析する必要があるため、2番目のバイトに続く引用文字を誤ってエスケープする可能性があるため、2番目のバイトに &lt;code&gt;'\'&lt;/code&gt; （ &lt;code&gt;\x5c&lt;/code&gt; ; \ x5c）を含む可能性があるShift_JISやBig-5などのエンコーディングは失敗します。</target>
        </trans-unit>
        <trans-unit id="00d20d737f3e8559e674f183083581c5bd074a26" translate="yes" xml:space="preserve">
          <source>Because pointer size does not necessarily equal integer size, use the follow macros to do it right.</source>
          <target state="translated">ポインタのサイズは必ずしも整数サイズとは限らないので、以下のマクロを使って正しく実行してください。</target>
        </trans-unit>
        <trans-unit id="1ab7d92c18b253929d90277eb1a2787d5ea83ae7" translate="yes" xml:space="preserve">
          <source>Because scripts differ in their directionality (Hebrew and Arabic are written right to left, for example) Unicode supplies a &lt;code&gt;Bidi_Class&lt;/code&gt; property. Some of the values this property can have are:</source>
          <target state="translated">スクリプトは方向性が異なるため（たとえば、ヘブライ語とアラビア語は右から左に書かれます）、Unicodeは &lt;code&gt;Bidi_Class&lt;/code&gt; プロパティを提供します。このプロパティが持つことができる値のいくつかは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5783acfed14f8a18cb2ce82232df112d8f4b39d0" translate="yes" xml:space="preserve">
          <source>Because taintedness is associated with each scalar value, some elements of an array or hash can be tainted and others not. The keys of a hash are &lt;b&gt;never&lt;/b&gt; tainted.</source>
          <target state="translated">汚染度は各スカラー値に関連付けられているため、配列またはハッシュの一部の要素は汚染され、その他の要素は汚染されません。ハッシュのキーは&lt;b&gt;決して&lt;/b&gt;汚染され&lt;b&gt;ません&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="43efff829e58f5a1345657268ce9125ae02a8e64" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;../functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;ed value will have the separator reattached when it is written back to the file. There is no way to create a file whose trailing record separator string is missing.</source>
          <target state="translated">それは、ファイルに書き戻されるときに、 &lt;code&gt;&lt;a href=&quot;../functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; 値にセパレーターが再接続されるためです。末尾のレコード区切り文字列が欠落しているファイルを作成する方法はありません。</target>
        </trans-unit>
        <trans-unit id="1a39cf872a3f7b6aa066ba9c7802115aead55d6e" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; at end of file or upon error, you will sometimes see it used this way:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 関数はファイルの終わりまたはエラー時に &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返すため、次のように使用されることがあります。</target>
        </trans-unit>
        <trans-unit id="2d7cdbb67a74f8d2c9c047551149590e9752d672" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement implies a &lt;code&gt;BEGIN&lt;/code&gt; block, the importing of semantics happens as soon as the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement is compiled, before the rest of the file is compiled. This is how it is able to function as a pragma mechanism, and also how modules are able to declare subroutines that are then visible as list or unary operators for the rest of the current file. This will not work if you use &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;. With &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; you can get into this problem:</source>
          <target state="translated">ので &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 文は意味 &lt;code&gt;BEGIN&lt;/code&gt; ブロックをすぐにとして、セマンティクスのインポートが起こるの &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ファイルの残りがコンパイルされる前に、文は、コンパイルされます。これは、プラグマメカニズムとして機能する方法と、現在のファイルの残りのリストまたは単項演算子として表示されるサブルーチンをモジュールが宣言する方法です。あなたが使用している場合、これは動作しません &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; の代わりに &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 。で &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; あなたはこの問題に入ることができます。</target>
        </trans-unit>
        <trans-unit id="af2ba8c1f36d75fd963bdb6706751e36d03bae43" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;here&lt;/code&gt; is before the &lt;code&gt;.*&lt;/code&gt; in the pattern, its position can be determined exactly. That's not true, however, for the &lt;code&gt;there&lt;/code&gt; ; it could appear at any point after where the anchored string appeared. Perl uses both for its optimisations, preferring the longer, or, if they are equal, the floating.</source>
          <target state="translated">&lt;code&gt;here&lt;/code&gt; はパターンの &lt;code&gt;.*&lt;/code&gt; 前にあるため、その位置を正確に決定できます。それはのために、しかし、真実ではないのです &lt;code&gt;there&lt;/code&gt; 。アンカー文字列が出現した後の任意の時点で出現する可能性があります。Perlは最適化に両方を使用し、長い方を好むか、等しい場合はフローティングを使用します。</target>
        </trans-unit>
        <trans-unit id="77f9c95f62f2ca8f51dfcabf085dd8aa40d54fc6" translate="yes" xml:space="preserve">
          <source>Because the assignment copies the values, this also has the effect of turning call-by-reference into call-by-value. Otherwise a function is free to do in-place modifications of &lt;code&gt;@_&lt;/code&gt; and change its caller's values.</source>
          <target state="translated">割り当ては値をコピーするため、参照による呼び出しを値による呼び出しに変換する効果もあります。それ以外の場合、関数は &lt;code&gt;@_&lt;/code&gt; のインプレース変更を自由に行い、呼び出し元の値を変更できます。</target>
        </trans-unit>
        <trans-unit id="6c5cdf7c11299fa442df7b9179d8baed60991f7f" translate="yes" xml:space="preserve">
          <source>Because the conversion happens in place, the data to be converted cannot be a string constant: it must be a scalar variable.</source>
          <target state="translated">変換はその場で行われるので、変換されるデータは文字列定数にすることはできません:それはスカラ変数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="9be0ebeeed384a0006842b7e5b00f870be61a55a" translate="yes" xml:space="preserve">
          <source>Because the current implementation uses the table and key sizes for the hashing algorithm, there is no means by which to dynamically change the value of any of the initialization parameters.</source>
          <target state="translated">現在の実装では、ハッシュアルゴリズムにテーブルとキーサイズを使用しているため、初期化パラメータの値を動的に変更する手段がありません。</target>
        </trans-unit>
        <trans-unit id="a16d069c72d0455b6bbcd09050d9c581b9a31d6b" translate="yes" xml:space="preserve">
          <source>Because the intent of this feature is primarily to let you define subroutines that work like built-in functions, here are prototypes for some other functions that parse almost exactly like the corresponding built-in.</source>
          <target state="translated">この機能の意図は、主に組み込み関数のように動作するサブルーチンを定義することにありますので、ここでは、対応する組み込み関数とほぼ同じようにパースする他の関数のプロトタイプをいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="286b10724045d4807f7e79831cdfb01b70d2bd21" translate="yes" xml:space="preserve">
          <source>Because the internal format is often UTF-8, these bugs are hard to spot, because UTF-8 is usually the encoding you wanted! But don't be lazy, and don't use the fact that Perl's internal format is UTF-8 to your advantage. Encode explicitly to avoid weird bugs, and to show to maintenance programmers that you thought this through.</source>
          <target state="translated">内部フォーマットが UTF-8 であることが多いので、これらのバグを発見するのは難しいでしょう。しかし、怠け者にならず、Perl の内部フォーマットが UTF-8 であるという事実を利用しないでください。奇妙なバグを避けるために明示的にエンコードしてください。</target>
        </trans-unit>
        <trans-unit id="2a9f9af112f672f597ba8d8590f5548d9330b12e" translate="yes" xml:space="preserve">
          <source>Because the mode contains both the file type and its permissions, you should mask off the file type portion and (s)printf using a &lt;code&gt;&quot;%o&quot;&lt;/code&gt; if you want to see the real permissions.</source>
          <target state="translated">モードにはファイルタイプとそのアクセス許可の両方が含まれているため、実際のアクセス許可を表示するには、ファイルタイプの部分と（s）printfを &lt;code&gt;&quot;%o&quot;&lt;/code&gt; を使用してマスクする必要があります。</target>
        </trans-unit>
        <trans-unit id="f2423ea47c406258a59791ed602061d34ce7d19b" translate="yes" xml:space="preserve">
          <source>Because the result of &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; has all metacharacters quoted, there is no way to insert a literal &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; inside a &lt;code&gt;\Q\E&lt;/code&gt; pair. If protected by &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; will be quoted to become &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; ; if not, it is interpreted as the start of an interpolated scalar.</source>
          <target state="translated">&lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; の結果にはすべてのメタ文字が引用されているため、 &lt;code&gt;\Q\E&lt;/code&gt; ペア内にリテラル &lt;code&gt;$&lt;/code&gt; または &lt;code&gt;@&lt;/code&gt; を挿入する方法はありません。 &lt;code&gt;\&lt;/code&gt; で保護されている場合、 &lt;code&gt;$&lt;/code&gt; は &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; になるように引用されます。そうでない場合は、補間されたスカラーの開始として解釈されます。</target>
        </trans-unit>
        <trans-unit id="d152f048af7d90769fe2fc306e54559a9ec00ef1" translate="yes" xml:space="preserve">
          <source>Because the smartmatch operator recurses on nested arrays, this will still report that &quot;red&quot; is in the array.</source>
          <target state="translated">スマートマッチ演算子は入れ子になった配列に対して再帰するので、この場合でも &quot;red &quot;が配列の中にあることが報告されます。</target>
        </trans-unit>
        <trans-unit id="2efc41902e93fe5cc4de4d763dfe32a371a96fe2" translate="yes" xml:space="preserve">
          <source>Because the standard failure message that &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; produces whenever a test fails will be a common occurrence in your test error output, and because it has changed between Test::Builder versions, rather than forcing you to call &lt;code&gt;test_err&lt;/code&gt; with the string all the time like so</source>
          <target state="translated">テストが失敗するたびに&lt;a href=&quot;../builder&quot;&gt;Test :: Builderが&lt;/a&gt;生成する標準の失敗メッセージは、テストエラー出力で一般的に発生し、すべての文字列で &lt;code&gt;test_err&lt;/code&gt; を呼び出すことを強制するのではなく、Test :: Builderバージョン間で変更されたためです。そのような時間</target>
        </trans-unit>
        <trans-unit id="4ad62b1bf690da795c5cc2f593aa204a22c3e54b" translate="yes" xml:space="preserve">
          <source>Because the target is reused, you must be careful when pushing multiple values on the stack. The following code will not do what you think:</source>
          <target state="translated">ターゲットは再利用されるので、スタックに複数の値をプッシュする場合は注意が必要です。以下のコードでは、思ったようなことができません。</target>
        </trans-unit>
        <trans-unit id="bdc28270d2ca87731131681df34d184cd0aea361" translate="yes" xml:space="preserve">
          <source>Because the transliteration table is built at compile time, neither the</source>
          <target state="translated">翻字テーブルはコンパイル時に構築されるので</target>
        </trans-unit>
        <trans-unit id="2e5bc19b54b9930fd5e2dcb3e6dfb795d20462ff" translate="yes" xml:space="preserve">
          <source>Because the value of &lt;code&gt;$Config{archname}&lt;/code&gt; may depend on the hardware architecture, it can vary more than the value of &lt;code&gt;$^O&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$Config{archname}&lt;/code&gt; の値はハードウェアアーキテクチャに依存する可能性があるため、 &lt;code&gt;$^O&lt;/code&gt; 値よりも変動する可能性があります。</target>
        </trans-unit>
        <trans-unit id="e90ed527002ad403540a55eb78d4c5ab847fcd41" translate="yes" xml:space="preserve">
          <source>Because the values line may contain arbitrary expressions (for at fields, not caret fields), you can farm out more sophisticated processing to other functions, like sprintf() or one of your own. For example:</source>
          <target state="translated">値の行には任意の式が含まれている可能性があるので (キャレットフィールドではなくアットフィールドに対して)、より洗練された処理を他の関数 (sprintf()や独自の関数のいずれか)に委託することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="d8bc8ec23c88de9efd45beeefb8be0639f500936" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">変数は &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; の直後に有効になるため、その名前の変数がすでにスコープ内にない限り、同じステートメント内でもパッケージ変数を再び参照できます。</target>
        </trans-unit>
        <trans-unit id="da44b03f12b50aea312686ca3a3d0b93a5cee3d2" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">変数は &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; の直後に有効になるため、その名前の変数がすでにスコープ内にない限り、同じステートメント内でもパッケージ変数を再び参照できます。</target>
        </trans-unit>
        <trans-unit id="1213676c8b2ebcfdeacd60c8eeb78e070a8906e8" translate="yes" xml:space="preserve">
          <source>Because there are more than three arguments to open(), forks the ps(1) command</source>
          <target state="translated">open()には 3 つ以上の引数があるので、ps(1)コマンドをフォーク。</target>
        </trans-unit>
        <trans-unit id="63c371b01d835f1b3e60dfea4284b4178cc48a57" translate="yes" xml:space="preserve">
          <source>Because there are people who have their precise expectations about who may install where in the @INC path and who uses which @INC array. In fine tuned environments &lt;code&gt;UNINST=1&lt;/code&gt; can cause damage.</source>
          <target state="translated">なぜなら、@ INCパスのどこに誰がインストールし、どの@INC配列を使用するかについて、正確な期待を持つ人がいるからです。微調整された環境では、 &lt;code&gt;UNINST=1&lt;/code&gt; は損傷を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="b691163394a932e3f6d352ebd6e7cd633110d322" translate="yes" xml:space="preserve">
          <source>Because these resource objects are considered to be owned by the entire process/system, and not the &quot;property&quot; of whatever is being serialized, no references underneath the object should be included in the serialized string. Thus, in any class that implements &lt;code&gt;STORABLE_attach&lt;/code&gt; , the &lt;code&gt;STORABLE_freeze&lt;/code&gt; method cannot return any references, and &lt;code&gt;Storable&lt;/code&gt; will throw an error if &lt;code&gt;STORABLE_freeze&lt;/code&gt; tries to return references.</source>
          <target state="translated">これらのリソースオブジェクトは、シリアル化されているものの「プロパティ」ではなく、プロセス/システム全体によって所有されていると見なされるため、オブジェクトの下の参照をシリアル化された文字列に含めないでください。したがって、 &lt;code&gt;STORABLE_attach&lt;/code&gt; を実装するクラスでは、 &lt;code&gt;STORABLE_freeze&lt;/code&gt; メソッドは参照を返すことができず、 &lt;code&gt;Storable&lt;/code&gt; が参照を &lt;code&gt;STORABLE_freeze&lt;/code&gt; うとすると、Storableはエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="e58a7f2a84e13b9fada5ed77ade53adda8ab6513" translate="yes" xml:space="preserve">
          <source>Because this command is in some senses new, a warning is issued if you appear to have accidentally entered a block instead. If that's what you mean to do, write it as with &lt;code&gt;;{ ... }&lt;/code&gt; or even &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { ... }&lt;/code&gt; .</source>
          <target state="translated">このコマンドはある意味で新しいため、誤ってブロックを入力したように見える場合は警告が発行されます。それはあなたがする何を意味するかだ場合は、のようにそれを書く &lt;code&gt;;{ ... }&lt;/code&gt; あるいは &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { ... }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efa88e36be50b169e959caa4254fea74155063be" translate="yes" xml:space="preserve">
          <source>Because this function uses mktemp(), it can suffer from race conditions.</source>
          <target state="translated">この関数は mktemp()を使用するため、競合状態に陥る可能性があります。</target>
        </trans-unit>
        <trans-unit id="2478181856508c1cc91e32c539a156e07c17eb63" translate="yes" xml:space="preserve">
          <source>Because this information is not stored within the perl executable itself it is possible (but unlikely) that the information does not relate to the actual perl binary which is being used to access it.</source>
          <target state="translated">この情報はPerl実行ファイル自体の中には保存されていないので、情報がアクセスに使用されている実際のPerlバイナリに関連していない可能性があります(可能性は低いですが)。</target>
        </trans-unit>
        <trans-unit id="ad52e097251691a48fd57b8bdbc852cffc9bb5f6" translate="yes" xml:space="preserve">
          <source>Because this is a wide-open interface, pragmas (compiler directives) are also implemented this way. Currently implemented pragmas are:</source>
          <target state="translated">これはオープンなインターフェイスなので、プラグマ(コンパイラディレクティブ)もこのように実装されています。現在実装されているプラグマは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="e8055a645160d58d1aa3758824d7f3046e3cd0a9" translate="yes" xml:space="preserve">
          <source>Because this operator produces an assignable result, using assignments without parentheses will get you in trouble. For example, this:</source>
          <target state="translated">この演算子は代入可能な結果を生成するので、括弧なしの代入を使用すると問題が発生します。例えば、これは</target>
        </trans-unit>
        <trans-unit id="cda353c8b2d143f02b4da6818d79c64f57fb0765" translate="yes" xml:space="preserve">
          <source>Because this promotes action at a distance, this counterintuitive behavior may be fixed in a future release.</source>
          <target state="translated">これは距離を置いて行動することを促進するため、この直観的でない動作は将来のリリースで修正される可能性があります。</target>
        </trans-unit>
        <trans-unit id="ece57b9cb9008cd6f8ed94726d6205b9428981dc" translate="yes" xml:space="preserve">
          <source>Because thread creation and thread joining may occur in different contexts, it may be desirable to state the context explicitly to the thread's entry point function. This may be done by calling &lt;code&gt;-&amp;gt;create()&lt;/code&gt; with a hash reference as the first argument:</source>
          <target state="translated">スレッドの作成と結合は異なるコンテキストで発生する可能性があるため、スレッドのエントリポイント関数にコンテキストを明示的に示すことが望ましい場合があります。これは、最初の引数としてハッシュ参照を指定して &lt;code&gt;-&amp;gt;create()&lt;/code&gt; を呼び出すことで実行できます。</target>
        </trans-unit>
        <trans-unit id="a311abdd84d17ec36b9f35316e74bcbefa1ccdb8" translate="yes" xml:space="preserve">
          <source>Because variable references always start with '$', '@', or '%', the &quot;reserved&quot; words aren't in fact reserved with respect to variable names. They</source>
          <target state="translated">変数参照は常に '$'、'@'、または '%' で始まるので、「予約済み」の単語は実際には変数名に関して予約されているわけではありません。予約されているのは</target>
        </trans-unit>
        <trans-unit id="0ac64477279b51b2f8ca41484de7b49285b3815c" translate="yes" xml:space="preserve">
          <source>Because we are now concerned with the return value from</source>
          <target state="translated">からの戻り値に注目しています。</target>
        </trans-unit>
        <trans-unit id="9befd612f9b4e3c124f9ec128a96394cb71cf6fb" translate="yes" xml:space="preserve">
          <source>Because we are using an SV to call</source>
          <target state="translated">を呼び出すためにSVを使用しているため</target>
        </trans-unit>
        <trans-unit id="ded04a0cee8ca9e46b88306d00153b5faa51a410" translate="yes" xml:space="preserve">
          <source>Because we created temporary values (by means of sv_2mortal() calls) we will have to tidy up the Perl stack and dispose of mortal SVs.</source>
          <target state="translated">(sv_2mortal()の呼び出しによって)一時的な値を作成したので、Perl のスタックを整理して、死亡した SV を処分しなければなりません。</target>
        </trans-unit>
        <trans-unit id="aa34046474e322c81f9b04585e1a1d3d975224ac" translate="yes" xml:space="preserve">
          <source>Because we specified G_DISCARD, it is not necessary to check the value returned from</source>
          <target state="translated">G_DISCARDを指定しているので</target>
        </trans-unit>
        <trans-unit id="941fe97debd1bfb6b702aacc07a44435ca4e56b7" translate="yes" xml:space="preserve">
          <source>Because when &lt;code&gt;autochomp&lt;/code&gt; is disabled, &lt;code&gt;$a[10]&lt;/code&gt; will read back as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (or whatever the record separator string is.)</source>
          <target state="translated">&lt;code&gt;autochomp&lt;/code&gt; が無効になっている場合、 &lt;code&gt;$a[10]&lt;/code&gt; は &lt;code&gt;&quot;\n&quot;&lt;/code&gt; （またはレコード区切り文字列が何であれ）として読み返されます。</target>
        </trans-unit>
        <trans-unit id="b0a17ee4f4c080e1c09fd835e1c924855560fcaf" translate="yes" xml:space="preserve">
          <source>Because you just moved the existing &lt;b&gt;stdout&lt;/b&gt; to somewhere else.</source>
          <target state="translated">既存の&lt;b&gt;標準出力&lt;/b&gt;を別の場所に移動しただけだからです。</target>
        </trans-unit>
        <trans-unit id="aa628e92b3c4d485e932ec48525c963ebb2f9c63" translate="yes" xml:space="preserve">
          <source>Because you're using something like this, which truncates the file</source>
          <target state="translated">というのも、このようにファイルを切り捨てるようなものを使っているからです。</target>
        </trans-unit>
        <trans-unit id="973ca6acb768a5dd6330a5eade0b5d4dbc53ee84" translate="yes" xml:space="preserve">
          <source>Before Perl 5.10.0 and 5.8.8, PERL5SHELL was not taint checked when running external commands. It is recommended that you explicitly set (or delete) &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; when running in taint mode under Windows.</source>
          <target state="translated">Perl 5.10.0および5.8.8より前のバージョンでは、外部コマンドの実行時にPERL5SHELLは汚染チェックされませんでした。Windowsで汚染モードで実行する場合は、 &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; を明示的に設定（または削除）することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="36d386f00504590e35abdcaf1bc115cbe7c02503" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the assignment to &lt;code&gt;$@&lt;/code&gt; occurred before restoration of localized variables, which means that for your code to run on older versions, a temporary is required if you want to mask some but not all errors:</source>
          <target state="translated">Perl 5.14 より前は、ローカライズされた変数を復元する前に &lt;code&gt;$@&lt;/code&gt; への割り当てが行われていました。つまり、古いバージョンでコードを実行するには、すべてではなく一部のエラーをマスクしたい場合に一時ファイルが必要です。</target>
        </trans-unit>
        <trans-unit id="512488ae279d498c1ee81f682f1f53229da4c6e2" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the relation between overloading and tie()ing was broken. Overloading was triggered or not based on the</source>
          <target state="translated">Perl 5.14 より前のバージョンでは、オーバーロードと tie()ing の関係が壊れていました。オーバーロードは</target>
        </trans-unit>
        <trans-unit id="b34cea36bce317a875588bd1ba293a621fd141d4" translate="yes" xml:space="preserve">
          <source>Before Perl 5.18, &lt;code&gt;given(EXPR)&lt;/code&gt; assigned the value of</source>
          <target state="translated">Perl 5.18より前では、 &lt;code&gt;given(EXPR)&lt;/code&gt; は次の値を割り当てました</target>
        </trans-unit>
        <trans-unit id="54445efd0dc2c1e8891bd0fe2ff854e28637df1f" translate="yes" xml:space="preserve">
          <source>Before Perl 5.6, you had to use the &lt;code&gt;*FH&lt;/code&gt; or &lt;code&gt;\*FH&lt;/code&gt; notations. These are &quot;typeglobs&quot;--see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;Typeglobs and Filehandles in perldata&lt;/a&gt; and especially &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;Pass by Reference in perlsub&lt;/a&gt; for more information.</source>
          <target state="translated">Perl 5.6以前は、 &lt;code&gt;*FH&lt;/code&gt; または &lt;code&gt;\*FH&lt;/code&gt; 表記を使用する必要がありました。これらは「&lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;タイプ&lt;/a&gt;グロブ」です。詳細については、perldataのタイプグロブとファイルハンドル、特に&lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;perlsubの参照渡しを参照し&lt;/a&gt;てください。</target>
        </trans-unit>
        <trans-unit id="2df4fb0a98f840a2555a3347deeff121cc142591" translate="yes" xml:space="preserve">
          <source>Before Perl 5.8.0, installing Perl code to deal with signals exposed you to danger from two things. First, few system library functions are re-entrant. If the signal interrupts while Perl is executing one function (like malloc(3) or printf(3)), and your signal handler then calls the same function again, you could get unpredictable behavior--often, a core dump. Second, Perl isn't itself re-entrant at the lowest levels. If the signal interrupts Perl while Perl is changing its own internal data structures, similarly unpredictable behavior may result.</source>
          <target state="translated">Perl 5.8.0以前では、シグナルを扱うためにPerlのコードをインストールすると、2つのことから危険にさらされていました。まず、いくつかのシステムライブラリ関数がリエントラントになっています。Perl がある関数(malloc(3)や printf(3)のような)を実行している間にシグナルが割り込み、シグナルハンドラが同じ関数を再び呼び出すと、予測不可能な動作をする可能性があり、しばしばコアダンプが発生します。第二に、Perl は最低レベルではそれ自体がリエントラントではありません。Perl が内部データ構造を変更している間にシグナルが Perl を割り込み、同様に予測不可能な動作をする可能性があります。</target>
        </trans-unit>
        <trans-unit id="870cc998eebf778ddd06bc7ed2f1805b37f31d55" translate="yes" xml:space="preserve">
          <source>Before Perl v5.8.0, the use of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; was used to declare that operations in the current block or file would be Unicode-aware. This model was found to be wrong, or at least clumsy: the &quot;Unicodeness&quot; is now carried with the data, instead of being attached to the operations. Starting with Perl v5.8.0, only one case remains where an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
utf8&lt;/code&gt; is needed: if your Perl script itself is encoded in UTF-8, you can use UTF-8 in your identifier names, and in string and regular expression literals, by saying &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; . This is not the default because scripts with legacy 8-bit data in them would break. See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="translated">Perl v5.8.0より前は、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; を使用して、現在のブロックまたはファイルでの操作がUnicode対応であることを宣言していました。このモデルは間違っているか、少なくとも不器用であることがわかりました。「Unicodeness」は、操作に添付されるのではなく、データとともに保持されるようになりました。 Perl v5.8.0以降、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 明示的に&lt;a href=&quot;functions/use&quot;&gt;使用する&lt;/a&gt;必要があるケースは1つだけ残っています。Perl スクリプト自体がUTF-8でエンコードされている場合、識別子名と文字列および正規表現リテラルでUTF-8を使用できます。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; と言ってください。レガシー8ビットデータが含まれているスクリプトは破損するため、これはデフォルトではありません。&lt;a href=&quot;utf8&quot;&gt;utf8を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="04e04ef0cf482846e31d6720b49ae41928208ea3" translate="yes" xml:space="preserve">
          <source>Before Unicode, most encodings used 8 bits (a single byte) to encode each character. Thus a character was a byte, and a byte was a character, and there could be only 256 or fewer possible characters. &quot;Byte Semantics&quot; in the title of this section refers to this behavior. There was no need to distinguish between &quot;Byte&quot; and &quot;Character&quot;.</source>
          <target state="translated">Unicode以前は、ほとんどのエンコーディングは各文字をエンコードするために8ビット(1バイト)を使用していました。したがって、1 文字は 1 バイトであり、1 バイトは 1 文字であり、可能な文字は 256 文字かそれ以下しかありませんでした。このセクションのタイトルにある &quot;Byte Semantics &quot;は、この動作を指しています。バイト」と「文字」を区別する必要はありませんでした。</target>
        </trans-unit>
        <trans-unit id="290d67ae3ee387c5e4e99c79148af4efc4e204f2" translate="yes" xml:space="preserve">
          <source>Before Unicode, when a character was a byte was a character, Perl knew only about the 128 characters defined by ASCII, code points 0 through 127 (except for under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ). That left the code points 128 to 255 as unassigned, and available for whatever use a program might want. The only semantics they have is their ordinal numbers, and that they are members of none of the non-negative character classes. None are considered to match &lt;code&gt;\w&lt;/code&gt; for example, but all match &lt;code&gt;\W&lt;/code&gt; .</source>
          <target state="translated">文字はバイトが文字であったときUnicodeの前に、PerlはASCIIのみによって定義された128個の文字を知っていた、コードポイント0〜127（下を除いて &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ）。これにより、コードポイント128〜255が割り当てられず、プログラムが必要とするあらゆる用途に使用できるようになりました。それらが持つ唯一のセマンティクスは序数であり、非負の文字クラスのメンバーではありません。たとえば、 &lt;code&gt;\w&lt;/code&gt; と一致するとは見なされませんが、すべて &lt;code&gt;\W&lt;/code&gt; 一致します。</target>
        </trans-unit>
        <trans-unit id="d690a12b540a565baadfa57c599d5a868691200d" translate="yes" xml:space="preserve">
          <source>Before any command has executed or if an unexpected error occurs &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return undef.</source>
          <target state="translated">コマンドが実行される前、または予期しないエラーが発生した場合、 &lt;code&gt;code()&lt;/code&gt; は &quot;421&quot;（一時的な接続障害 &lt;code&gt;message()&lt;/code&gt; を返し、message（）はundefを返します。</target>
        </trans-unit>
        <trans-unit id="752f8552c1f4e0b002a40cffe2d75752a7a074d6" translate="yes" xml:space="preserve">
          <source>Before anything else, you need a testing plan. This basically declares how many tests your script is going to run to protect against premature failure.</source>
          <target state="translated">何かをする前に、テスト計画が必要です。これは基本的に、早期の失敗を防ぐためにスクリプトを実行するテストの数を宣言するものです。</target>
        </trans-unit>
        <trans-unit id="4bb0c278106c5fac84e8a238d47e490b85a41fa5" translate="yes" xml:space="preserve">
          <source>Before installing the patches to the IBM C-compiler you need to know the level of patching for the Operating System. IBM's command 'oslevel' will show the base, but is not always complete (in this example oslevel shows 4.3.NULL, whereas the system might run most of 4.3.THREE):</source>
          <target state="translated">IBM C-コンパイラにパッチをインストールする前に、オペレーティングシステムのパッチのレベルを知る必要があります。IBM のコマンド 'oslevel' はベースを表示しますが、必ずしも完全ではありません (この例では oslevel は 4.3.NULL を表示していますが、システムは 4.3.THREE のほとんどを実行しているかもしれません)。</target>
        </trans-unit>
        <trans-unit id="b46ac14ab9ac97916ee87fb2735b65fa3bcb3084" translate="yes" xml:space="preserve">
          <source>Before perl5.6, you had to deal with various typeglob idioms which you may see in older code.</source>
          <target state="translated">perl5.6以前では、古いコードで見られるような様々なタイプグローブイディオムを扱う必要がありました。</target>
        </trans-unit>
        <trans-unit id="4d24253ab2fd2c805f0d6bcaca41ee8bd8627285" translate="yes" xml:space="preserve">
          <source>Before release 5 of Perl it was difficult to represent complex data structures, because all references had to be symbolic--and even then it was difficult to refer to a variable instead of a symbol table entry. Perl now not only makes it easier to use symbolic references to variables, but also lets you have &quot;hard&quot; references to any piece of data or code. Any scalar may hold a hard reference. Because arrays and hashes contain scalars, you can now easily build arrays of arrays, arrays of hashes, hashes of arrays, arrays of hashes of functions, and so on.</source>
          <target state="translated">Perl のリリース 5 以前は、複雑なデータ構造を表現することは困難でした。なぜなら、すべての参照はシンボリックでなければならなかったからです。Perlでは、変数へのシンボリック参照をより簡単に使えるようになっただけでなく、どんなデータやコードに対しても「ハード」参照を持つことができるようになりました。どんなスカラでもハード参照を保持することができます。配列やハッシュにはスカラが含まれているので、配列の配列、ハッシュの配列、配列のハッシュ、関数のハッシュの配列などを簡単に作ることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="ef266fb9e8f6dafd9b23077a1b88d8327a3a9667" translate="yes" xml:space="preserve">
          <source>Before submitting a bug, please make sure that the traditional method of building a Perl module package from a shell by following the installation instructions of that package still works in your environment.</source>
          <target state="translated">バグを提出する前に、シェルからPerlモジュールパッケージを構築する従来の方法が、そのパッケージのインストール手順に従っているかどうかを、あなたの環境で動作することを確認してください。</target>
        </trans-unit>
        <trans-unit id="852a62fb5185caad446c6f66da79350d77dac37e" translate="yes" xml:space="preserve">
          <source>Before terminating, the &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function must explicitly install the filter by calling &lt;code&gt;filter_add&lt;/code&gt; .</source>
          <target state="translated">終了する前に、 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 関数は &lt;code&gt;filter_add&lt;/code&gt; を呼び出してフィルターを明示的にインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="f512253f81c2fd706ba28a9ad84dc13dc48c3eb8" translate="yes" xml:space="preserve">
          <source>Before the Perl interpreter can execute a Perl script, it must first read it from a file into memory for parsing and compilation. If that script itself includes other scripts with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement, then each of those scripts will have to be read from their respective files as well.</source>
          <target state="translated">Perlインタプリタは、Perlスクリプトを実行する前に、まず解析してコンパイルするためにファイルからメモリに読み込む必要があります。そのスクリプト自体に、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ステートメントを含む他のスクリプトが含まれている場合、それらの各スクリプトは、それぞれのファイルからも読み取る必要があります。</target>
        </trans-unit>
        <trans-unit id="7056378ac690eaab80565ece696557496384c5bd" translate="yes" xml:space="preserve">
          <source>Before the introduction of Unicode support in Perl, The &lt;code&gt;eq&lt;/code&gt; operator just compared the strings represented by two scalars. Beginning with Perl 5.8, &lt;code&gt;eq&lt;/code&gt; compares two strings with simultaneous consideration of</source>
          <target state="translated">PerlでUnicodeサポートが導入される前は、 &lt;code&gt;eq&lt;/code&gt; 演算子は2つのスカラーで表される文字列を比較していました。Perl 5.8以降、 &lt;code&gt;eq&lt;/code&gt; は 2つの文字列を比較し、同時に</target>
        </trans-unit>
        <trans-unit id="07d7d02c48129829b963f0f9c3efb3625c646877" translate="yes" xml:space="preserve">
          <source>Before the introduction of lexical warnings, Perl had two classes of warnings: mandatory and optional.</source>
          <target state="translated">語彙的警告が導入される前は、Perl には必須とオプションの 2 つの警告がありました。</target>
        </trans-unit>
        <trans-unit id="759cf8f89c69b1e5d0ddf3e544f843b8c5c70ae3" translate="yes" xml:space="preserve">
          <source>Before we even start scraping out the code, there are a few things we'll want to do in advance.</source>
          <target state="translated">コードを掻き出す前に、事前にやっておきたいことがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="a2896a2a84e6fb1618d5a02150eb4f976c910264" translate="yes" xml:space="preserve">
          <source>Before we go any further, you'll want to know how to quit the debugger: use just the letter '&lt;b&gt;q&lt;/b&gt;', not the words 'quit' or 'exit':</source>
          <target state="translated">先に進む前に、デバッガを終了する方法を知っておく必要があります。「quit」や「exit」という単語ではなく、「&lt;b&gt;q&lt;/b&gt;」という文字だけを使用してください。</target>
        </trans-unit>
        <trans-unit id="8a4b62fae1d0e77e031397754824b30119b2b62a" translate="yes" xml:space="preserve">
          <source>Before writing XS, read the &lt;a href=&quot;#CAVEATS&quot;&gt;CAVEATS&lt;/a&gt; section below.</source>
          <target state="translated">XSを作成する前に、以下の「&lt;a href=&quot;#CAVEATS&quot;&gt;警告」&lt;/a&gt;セクションをお読みください。</target>
        </trans-unit>
        <trans-unit id="1b5bba6a088484e3f244c7ed2d3c63206cbf13d5" translate="yes" xml:space="preserve">
          <source>Before you consider posting a bug report, please consult, and possibly post a message to the discussion forum to see if what you've encountered is a known problem.</source>
          <target state="translated">バグ報告を投稿することを検討する前に、相談してみてください。</target>
        </trans-unit>
        <trans-unit id="528e582d94b55449ac3523f64dd0d0e5c7486531" translate="yes" xml:space="preserve">
          <source>Before you continue, note the sort order for variables. In general, we first list the variables in case-insensitive, almost-lexigraphical order (ignoring the &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt; preceding words, as in &lt;code&gt;${^UNICODE}&lt;/code&gt; or &lt;code&gt;$^T&lt;/code&gt; ), although &lt;code&gt;$_&lt;/code&gt; and &lt;code&gt;@_&lt;/code&gt; move up to the top of the pile. For variables with the same identifier, we list it in order of scalar, array, hash, and bareword.</source>
          <target state="translated">続行する前に、変数の並べ替え順序に注意してください。一般に、最初に変数を大文字と小文字を区別せず、字句順に並べます（ &lt;code&gt;${^UNICODE}&lt;/code&gt; や &lt;code&gt;$^T&lt;/code&gt; ように、 &lt;code&gt;{&lt;/code&gt; または &lt;code&gt;^&lt;/code&gt; の前の単語は無視します）。ただし、 &lt;code&gt;$_&lt;/code&gt; と &lt;code&gt;@_&lt;/code&gt; は上に移動します。パイルの。同じ識別子を持つ変数については、スカラー、配列、ハッシュ、ベアワードの順にリストします。</target>
        </trans-unit>
        <trans-unit id="29b11945139a380af16d5d49212f0306507606fb" translate="yes" xml:space="preserve">
          <source>Before you decide to merge two hashes, you have to decide what to do if both hashes contain keys that are the same and if you want to leave the original hashes as they were.</source>
          <target state="translated">2つのハッシュをマージする前に、両方のハッシュに同じキーが含まれている場合にどうするか、元のハッシュをそのままにしたい場合にどうするかを決めなければなりません。</target>
        </trans-unit>
        <trans-unit id="7b25edaa05329b202d8bbb719df130a305f9a0e7" translate="yes" xml:space="preserve">
          <source>Before you do anything else, you can help yourself by ensuring that you let Perl tell you about problem areas in your code. By turning on warnings and strictures, you can head off many problems before they get too big. You can find out more about these in &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">他のことをする前に、Perlにコード内の問題のある領域について通知させることで、自分自身を助けることができます。警告と制限をオンにすることで、多くの問題が大きくなる前に回避できます。これらの詳細については、&lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt;および&lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;で確認できます。</target>
        </trans-unit>
        <trans-unit id="054a146795bb49c5d92e2d968e739a1f63c7604c" translate="yes" xml:space="preserve">
          <source>Before you do that, first make sure the alias is nonexistent using &lt;code&gt;resolve_alias()&lt;/code&gt; , which returns the canonical name thereof. For example:</source>
          <target state="translated">その前に、まず &lt;code&gt;resolve_alias()&lt;/code&gt; を使用してエイリアスが存在しないことを確認します。これにより、その正規名が返されます。例えば：</target>
        </trans-unit>
        <trans-unit id="ea4eb9d8b93fbec8607b4df5d4d1083567318fe5" translate="yes" xml:space="preserve">
          <source>Before you launch yourself head first into the rest of this document, it would be a good idea to have read the following two documents--&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">このドキュメントの残りの部分に&lt;a href=&quot;perlxs&quot;&gt;進む前に&lt;/a&gt;、perlxsと&lt;a href=&quot;perlguts&quot;&gt;perlgutsの&lt;/a&gt; 2つのドキュメントを読んでおくことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="dde9d3bcf2359cbba92e26ac6718964bcaacd3c3" translate="yes" xml:space="preserve">
          <source>Before you panic, know that many people do use &lt;code&gt;Moose&lt;/code&gt; for command-line tools and other startup-sensitive code. We encourage you to try &lt;code&gt;Moose&lt;/code&gt; out first before worrying about startup speed.</source>
          <target state="translated">パニックになる前に、多くの人がコマンドラインツールやその他の起動に敏感なコードに &lt;code&gt;Moose&lt;/code&gt; を使用していることを知ってください。起動速度を気にする前に、まず &lt;code&gt;Moose&lt;/code&gt; を試してみることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2c445dd5994fd48a7f879efa85cd15aa5394f95f" translate="yes" xml:space="preserve">
          <source>Before you start</source>
          <target state="translated">始める前に</target>
        </trans-unit>
        <trans-unit id="fa35a8236ca3aecdca56f64d9f3832c8bf9e0996" translate="yes" xml:space="preserve">
          <source>Before you start, it's important to know a few things:</source>
          <target state="translated">始める前に、いくつかのことを知っておくことが大切です。</target>
        </trans-unit>
        <trans-unit id="85435e88ea012cea6ee5f0e38fd4d12329633e18" translate="yes" xml:space="preserve">
          <source>Before you start, you should glance through the README file found in the top-level directory to which the Perl distribution was extracted. Make sure you read and understand the terms under which this software is being distributed.</source>
          <target state="translated">始める前に、Perl の配布物が展開されたトップレベルのディレクトリにある README ファイルに目を通しておくべきです。このソフトウェアが配布されている条件を読み、理解していることを確認してください。</target>
        </trans-unit>
        <trans-unit id="82f236c12f0a7b2bfa05bcc6c77fce0d5554f74c" translate="yes" xml:space="preserve">
          <source>Before you start, you should glance through the README file found in the top-level directory where the Perl distribution was extracted. Make sure you read and understand the terms under which this software is being distributed.</source>
          <target state="translated">始める前に、Perl の配布物が展開されたトップレベルのディレクトリにある README ファイルに目を通しておくべきです。このソフトウェアが配布されている条件を読み、理解していることを確認してください。</target>
        </trans-unit>
        <trans-unit id="e6dc5aa054869bdc5776548930fba90056a049b5" translate="yes" xml:space="preserve">
          <source>Begin the retrieval of a file called &lt;code&gt;FILE&lt;/code&gt; from the remote server.</source>
          <target state="translated">リモートサーバーから &lt;code&gt;FILE&lt;/code&gt; というファイルの取得を開始します。</target>
        </trans-unit>
        <trans-unit id="d1bae729fa6ba19a84ae13329bfa79bbfaf77e9b" translate="yes" xml:space="preserve">
          <source>Beginner note: In example 2, above &lt;code&gt;$columns&lt;/code&gt; is imported into the local namespace, and set locally. In example 3, &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; is set in its own namespace without importing it.</source>
          <target state="translated">初心者向けメモ：例2では、​​上記の &lt;code&gt;$columns&lt;/code&gt; がローカルの名前空間にインポートされ、ローカルに設定されます。例3では、 &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; はインポートせずに独自のネームスペースに設定されています。</target>
        </trans-unit>
        <trans-unit id="8c50d29cf088569a469311ef83bf39d51d30a011" translate="yes" xml:space="preserve">
          <source>Beginners often think they want to have a variable contain the name of a variable.</source>
          <target state="translated">初心者の方は、変数に変数名を含ませたいと考えることが多いです。</target>
        </trans-unit>
        <trans-unit id="ddd5e0ea97f5ceda3171fdb3abe535bc421229c3" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.12, Perl accepts an ellipsis, &quot;&lt;code&gt;...&lt;/code&gt; &quot;, as a placeholder for code that you haven't implemented yet. This form of ellipsis, the unimplemented statement, should not be confused with the binary flip-flop &lt;code&gt;...&lt;/code&gt; operator. One is a statement and the other an operator. (Perl doesn't usually confuse them because usually Perl can tell whether it wants an operator or a statement, but see below for exceptions.)</source>
          <target state="translated">Perl 5.12から、Perlは省略記号「 &lt;code&gt;...&lt;/code&gt; 」を、まだ実装していないコードのプレースホルダーとして受け入れます。実装されていないステートメントであるこの形式の省略は、バイナリフリップフロップ &lt;code&gt;...&lt;/code&gt; 演算子と混同しないでください。1つはステートメントで、もう1つは演算子です。（通常、Perlは演算子とステートメントのどちらが必要かを判断できるため、Perlが混乱することはありませんが、例外については以下を参照してください。）</target>
        </trans-unit>
        <trans-unit id="82d48c3b20d2f80bac7595523990a9132ad0e311" translate="yes" xml:space="preserve">
          <source>Beginning in v5.20.0, a postfix syntax for using references is available. It behaves as described in &lt;a href=&quot;#Using-References&quot;&gt;Using References&lt;/a&gt;, but instead of a prefixed sigil, a postfixed sigil-and-star is used.</source>
          <target state="translated">v5.20.0以降では、参照を使用するためのPostfix構文が利用可能です。「&lt;a href=&quot;#Using-References&quot;&gt;参照の使用」で&lt;/a&gt;説明されているように動作しますが、接頭辞付きの印章の代わりに、接尾辞付きの印章と星印が使用されます。</target>
        </trans-unit>
        <trans-unit id="e4fd9d1748abdc28d0efb1f242a157236c1c9529" translate="yes" xml:space="preserve">
          <source>Beginning in v5.22.0, the referencing operator can be assigned to. It performs an aliasing operation, so that the variable name referenced on the left-hand side becomes an alias for the thing referenced on the right-hand side:</source>
          <target state="translated">v5.22.0 以降、参照演算子を割り当てることができます。これはエイリアス演算を行い、左側で参照されている変数名が右側で参照されているもののエイリアスになるようにします。</target>
        </trans-unit>
        <trans-unit id="54f7bcfa82e1deb0e3342e8510b04a376681f2a5" translate="yes" xml:space="preserve">
          <source>Beginning with HP-UX 11.00, programs compiled under HP-UX can take advantage of the LP64 programming environment (LP64 means Longs and Pointers are 64 bits wide), in which scalar variables will be able to hold numbers larger than 2^32 with complete precision. Perl has proven to be consistent and reliable in 64bit mode since 5.8.1 on all HP-UX 11.xx.</source>
          <target state="translated">HP-UX 11.00 以降、HP-UX でコンパイルされたプログラムは LP64 プログラミング環境(LP64 は Longs と Pointers が 64 ビット幅であることを意味します)を利用することができます。Perl は 5.8.1 以降、すべての HP-UX 11.xx で 64bit モードで一貫性と信頼性があることが証明されています。</target>
        </trans-unit>
        <trans-unit id="7f252bceac885ebc51d1278ef820d426befd060f" translate="yes" xml:space="preserve">
          <source>Beginning with HP-UX version 10.20, files larger than 2GB (2^31 bytes) may be created and manipulated. Three separate methods of doing this are available. Of these methods, the best method for Perl is to compile using the -Duselargefiles flag to Configure. This causes Perl to be compiled using structures and functions in which these are 64 bits wide, rather than 32 bits wide. (Note that this will only work with HP's ANSI C compiler. If you want to compile Perl using gcc, you will have to get a version of the compiler that supports 64-bit operations. See above for where to find it.)</source>
          <target state="translated">HP-UX バージョン 10.20 以降では、2GB (2^31 バイト)を超えるファイルを作成して操作することができます。これには3つの方法があります。これらの方法のうち、Perl にとっての最良の方法は、Configure に -Duselargefiles フラグを指定してコンパイルすることです。これにより、Perl は 32 ビット幅ではなく 64 ビット幅の構造体と関数を使ってコンパイルされます。(HPのANSI Cコンパイラでのみ動作することに注意してください。gccを使ってPerlをコンパイルしたい場合は、64ビット演算をサポートするコンパイラを入手する必要があります。それがどこにあるかは上記を参照してください。)</target>
        </trans-unit>
        <trans-unit id="7b1997a711dcb385772e62932a24b63be2ca5162" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.10.0, you can declare variables with the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword in place of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. For that to work, though, you must have enabled that feature beforehand, either by using the &lt;code&gt;feature&lt;/code&gt; pragma, or by using &lt;code&gt;-E&lt;/code&gt; on one-liners (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;). Beginning with Perl 5.16, the &lt;code&gt;CORE::state&lt;/code&gt; form does not require the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="translated">Perl 5.10.0以降では &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 代わりに &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; キーワードを使用して変数を宣言できます。ただし、これを機能させるには、 &lt;code&gt;feature&lt;/code&gt; プラグマを使用するか、ワンライナーで &lt;code&gt;-E&lt;/code&gt; を使用して（&lt;a href=&quot;feature&quot;&gt;featureを&lt;/a&gt;参照）、その機能を事前に有効にしておく必要があります。Perl 5.16から、 &lt;code&gt;CORE::state&lt;/code&gt; フォームは &lt;code&gt;feature&lt;/code&gt; プラグマを必要としません。</target>
        </trans-unit>
        <trans-unit id="fd848af5e7c989b28a26cc1aec55564025fc4af9" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.18, you can declare a private subroutine with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;. As with state variables, the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword is only available under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.010&lt;/code&gt; or higher.</source>
          <target state="translated">Perl 5.18以降では、プライベートサブルーチンを &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; で宣言できます。状態変数と同じように、 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; キーワードが下にのみ使用できます &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.010&lt;/code&gt; 以上です。</target>
        </trans-unit>
        <trans-unit id="2eca9f03e4044bf99d10838840f25a5c4ae464b9" translate="yes" xml:space="preserve">
          <source>Beginning with perl 5.10.0, you can also use &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables to have lexicals that are initialized only once (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;):</source>
          <target state="translated">perl 5.10.0以降では、 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 変数を使用して、1回だけ初期化されるレキシカルを使用することもできます（&lt;a href=&quot;feature&quot;&gt;機能を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="d269396692530a4c995cb59a2555fae5ff4dd172" translate="yes" xml:space="preserve">
          <source>Beginning with version 5.004, the following functions are also supported:</source>
          <target state="translated">バージョン5.004からは、以下の機能にも対応しています。</target>
        </trans-unit>
        <trans-unit id="34133685a790f2f2b5caab0cdf19417a300c4bef" translate="yes" xml:space="preserve">
          <source>Behaves like wait(2) on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">システムのwait（2）のように動作します。子プロセスが終了するのを待ち、死亡したプロセスのpidを返します。子プロセスがない場合は &lt;code&gt;-1&lt;/code&gt; を返します。ステータスは &lt;code&gt;$?&lt;/code&gt; で返されますか？および &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 。 &lt;code&gt;-1&lt;/code&gt; の戻り値は、&lt;a href=&quot;../perlipc&quot;&gt;perlipcで&lt;/a&gt;説明されているように、子プロセスが自動的に取得されることを意味する場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0f0c5491ce914759629c95815e914e921b25062e" translate="yes" xml:space="preserve">
          <source>Behaves like wait(2) on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">システムのwait（2）のように動作します。子プロセスが終了するのを待ち、死亡したプロセスのpidを返します。子プロセスがない場合は &lt;code&gt;-1&lt;/code&gt; を返します。ステータスは &lt;code&gt;$?&lt;/code&gt; で返されますか？および &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 。 &lt;code&gt;-1&lt;/code&gt; の戻り値は、&lt;a href=&quot;perlipc&quot;&gt;perlipcで&lt;/a&gt;説明されているように、子プロセスが自動的に取得されることを意味する場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0be599b479dc1a9d62fd33cd4b25ae6147cf1069" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">戻り値の型を除いて、&lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;と同じように動作します。 &lt;code&gt;OP *&lt;/code&gt; 戻り型が必要な場合にのみ使用してください。関数が実際に戻ることはありません。</target>
        </trans-unit>
        <trans-unit id="4c49c08082a231774a342ac5391eebbc26cb4596" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">戻り値の型を除いて、&lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt;と同じように動作します。 &lt;code&gt;OP *&lt;/code&gt; 戻り型が必要な場合にのみ使用してください。関数が実際に戻ることはありません。</target>
        </trans-unit>
        <trans-unit id="fbf9c5863d4bbe3bd2490f1ad8ab93b461cdea43" translate="yes" xml:space="preserve">
          <source>Behavior of other Perl features in forked pseudo-processes</source>
          <target state="translated">フォークされた疑似プロセスにおける他のPerl機能の挙動</target>
        </trans-unit>
        <trans-unit id="546fd299e317f0cfab072f158d53c6046d080ef9" translate="yes" xml:space="preserve">
          <source>Behavior of this function varies wildly depending on your system implementation. For example, it will usually not work across file system boundaries, even though the system</source>
          <target state="translated">この関数の動作は、システムの実装によって大きく異なります。例えば、ファイルシステムの境界を越えて動作することは通常ありません。</target>
        </trans-unit>
        <trans-unit id="6296c0acaf0c68b8a708c260d5e620e45c188c21" translate="yes" xml:space="preserve">
          <source>Behaviour since version 2.11</source>
          <target state="translated">バージョン2.11以降の動作</target>
        </trans-unit>
        <trans-unit id="fc99a03494d30ac32472278376507c26adfb39ce" translate="yes" xml:space="preserve">
          <source>Behind The Scenes</source>
          <target state="translated">舞台裏</target>
        </trans-unit>
        <trans-unit id="8e234f329fb33ee94403565f619b16d72bc67919" translate="yes" xml:space="preserve">
          <source>Behind the scenes the &lt;code&gt;globmap&lt;/code&gt; function does a combination of a file glob to match existing filenames followed by a substitute to create the new filenames.</source>
          <target state="translated">バックグラウンドで &lt;code&gt;globmap&lt;/code&gt; 関数は、既存のファイル名に一致するファイルグロブと、新しいファイル名を作成するための代替ファイルの組み合わせを実行します。</target>
        </trans-unit>
        <trans-unit id="4f88b0aecf2344cf177fb22c2c1e4809d60f491d" translate="yes" xml:space="preserve">
          <source>Being Perl-specific, this function has evolved along time. It can currently be called as follow:</source>
          <target state="translated">この関数は Perl 固有のものであり、時間の経過とともに進化してきました。現在は以下のように呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="0fc303a764ff6b60a94ad6969ea173a3382e1620" translate="yes" xml:space="preserve">
          <source>Being a mechanical process pl2pm is not bullet proof. The converted code will need careful checking, especially any package statements. Don't delete the original .pl file till the new .pm one works!</source>
          <target state="translated">機械的なプロセスである pl2pm は、防弾性があるわけではありません。変換されたコードは注意深くチェックする必要があります。新しい .pm が動くまで、元の .pl ファイルを削除しないでください!</target>
        </trans-unit>
        <trans-unit id="e98f301c8128b87a5492d5177997df433005bc22" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">たとえば、flock（）を使用したロックなど、ファイル記述子に依存している場合など、ファイルハンドルを節約することも（節約すること以外にも）便利です。 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; &lt;a href=&quot;functions/open&quot;&gt;開く&lt;/a&gt;だけの場合、ファイルハンドルAはBと同じファイル記述子を持たないため、flock（A）はflock（B）を実行せず、その逆も同様です。しかし、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; と、ファイルハンドルは同じ基本的なシステムファイル記述子を共有します。</target>
        </trans-unit>
        <trans-unit id="eb7d6ff0d012000fe6eccb3c989a4ceae1efb833" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">たとえば、flock（）を使用したロックなど、ファイル記述子に依存している場合など、ファイルハンドルを節約することも（節約すること以外にも）便利です。 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; &lt;a href=&quot;open&quot;&gt;開く&lt;/a&gt;だけの場合、ファイルハンドルAはBと同じファイル記述子を持たないため、flock（A）はflock（B）を実行せず、その逆も同様です。しかし、 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; と、ファイルハンドルは同じ基本的なシステムファイル記述子を共有します。</target>
        </trans-unit>
        <trans-unit id="1b8a9f965c18d647b7a7bff03b9e0c4a68361224" translate="yes" xml:space="preserve">
          <source>Bell sounds when word completion fails.</source>
          <target state="translated">単語補完に失敗するとベルが鳴ります。</target>
        </trans-unit>
        <trans-unit id="74d2e1c77a10412bd2a923bb84c1c65e97a50e55" translate="yes" xml:space="preserve">
          <source>Below are a few examples of globmaps</source>
          <target state="translated">以下に globmaps の例を示します。</target>
        </trans-unit>
        <trans-unit id="d6238547f660d516d0fdf40f8de1337807f2955e" translate="yes" xml:space="preserve">
          <source>Below is a</source>
          <target state="translated">以下は</target>
        </trans-unit>
        <trans-unit id="eab1a70d36b9d2b495b3781776947aeb4b2fc004" translate="yes" xml:space="preserve">
          <source>Below is a list of a few frameworks with comments which might help you in making a decision, depending on your specific requirements. Start by reading the docs, then ask questions on the relevant mailing list or IRC channel.</source>
          <target state="translated">以下は、あなたの特定の要件に応じて、あなたが決定する際に役立つかもしれないコメント付きのいくつかのフレームワークのリストです。まずドキュメントを読んでから、関連するメーリングリストや IRC チャンネルで質問をしてください。</target>
        </trans-unit>
        <trans-unit id="1f47cec9db1010fb960d67042b7e30d1824cca4b" translate="yes" xml:space="preserve">
          <source>Below is a list of the files in the Unicode data base that Perl doesn't currently use, along with very brief descriptions of their purposes. Some of the names of the files have been shortened from those that Unicode uses, in order to allow them to be distinguishable from similarly named files on file systems for which only the first 8 characters of a name are significant.</source>
          <target state="translated">以下に、Perl が現在使用していない Unicode データベース内のファイルのリストと、それらの目的についての非常に簡単な説明を示します。ファイル名のいくつかは、名前の最初の 8 文字だけが重要なファイルシステム上の同様の名前のファイルと区別できるように、Unicode が使用しているものから短縮されています。</target>
        </trans-unit>
        <trans-unit id="80905719173a37bfcc2cab267e8366cac44b82fa" translate="yes" xml:space="preserve">
          <source>Below is a list of the methods available.</source>
          <target state="translated">以下、利用できる方法の一覧です。</target>
        </trans-unit>
        <trans-unit id="a5ddbb5a4ded78a58dd050a0a7bd8f09a53b44f8" translate="yes" xml:space="preserve">
          <source>Below is a list of the valid options:</source>
          <target state="translated">以下、有効な選択肢の一覧です。</target>
        </trans-unit>
        <trans-unit id="f51c6d51b727cf7e1f4d3849980abd064bedf568" translate="yes" xml:space="preserve">
          <source>Below is a mapping of what utilities will be used in what order for what schemes, if available:</source>
          <target state="translated">以下は、利用可能な場合、どのようなスキームでどのようなユーティリティがどのような順序で使用されるかのマッピングです。</target>
        </trans-unit>
        <trans-unit id="beba98866f16c9dd2863b4a3ebd6b7ee815c3c45" translate="yes" xml:space="preserve">
          <source>Below is a possible implementation of a script to carry out the rename (error cases have been omitted)</source>
          <target state="translated">以下に、リネームを実行するスクリプトの実装例を示します(エラーの場合は省略しています)。</target>
        </trans-unit>
        <trans-unit id="58a01ebfbc11cd115ad51487cc4a5f70ba63da00" translate="yes" xml:space="preserve">
          <source>Below is a script which makes use of &lt;code&gt;gzreadline&lt;/code&gt; . It implements a very simple</source>
          <target state="translated">以下は &lt;code&gt;gzreadline&lt;/code&gt; を利用するスクリプトです。非常にシンプルな</target>
        </trans-unit>
        <trans-unit id="7ffed42afdfaf25df4c7e5e8645b31ce92ca54e6" translate="yes" xml:space="preserve">
          <source>Below is a simple &quot;rename&quot; script that uses &lt;code&gt;globmap&lt;/code&gt; to determine the source and destination filenames.</source>
          <target state="translated">以下は、 &lt;code&gt;globmap&lt;/code&gt; を使用してソースと宛先のファイル名を決定する単純な「名前変更」スクリプトです。</target>
        </trans-unit>
        <trans-unit id="1ec37797cdff4399757b58637d8bd54b7066dfec" translate="yes" xml:space="preserve">
          <source>Below is an example module that makes use of the macros.</source>
          <target state="translated">以下にマクロを利用したモジュールの例を示します。</target>
        </trans-unit>
        <trans-unit id="2be2899025a1fe4d200821c4ccbd79eabb3ab414" translate="yes" xml:space="preserve">
          <source>Below is an example program, &lt;code&gt;cpp_test&lt;/code&gt; , which makes use of this filter. Line numbers have been added to allow specific lines to be referenced easily.</source>
          <target state="translated">以下は、このフィルターを使用するサンプルプログラム &lt;code&gt;cpp_test&lt;/code&gt; です。特定の行を簡単に参照できるように、行番号が追加されました。</target>
        </trans-unit>
        <trans-unit id="4e2cc23005bf69f272f1f19d9851308543cafdff" translate="yes" xml:space="preserve">
          <source>Below is just one example, illustrating the control verb &lt;code&gt;(*FAIL)&lt;/code&gt; , which may be abbreviated as &lt;code&gt;(*F)&lt;/code&gt; . If this is inserted in a regexp it will cause it to fail, just as it would at some mismatch between the pattern and the string. Processing of the regexp continues as it would after any &quot;normal&quot; failure, so that, for instance, the next position in the string or another alternative will be tried. As failing to match doesn't preserve capture groups or produce results, it may be necessary to use this in combination with embedded code.</source>
          <target state="translated">以下は、制御動詞 &lt;code&gt;(*FAIL)&lt;/code&gt; を示す1つの例にすぎません。 &lt;code&gt;(*F)&lt;/code&gt; と省略できます。これが正規表現に挿入されると、パターンと文字列の間の不一致と同様に、失敗します。正規表現の処理は、「通常の」障害の後と同様に続行されるため、たとえば、文字列の次の位置または別の位置が試行されます。一致しない場合、キャプチャグループが保持されないか、結果が生成されないため、埋め込みコードと組み合わせて使用​​する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="994ae30ab39b91782977e3601a4b1c5958c55b6d" translate="yes" xml:space="preserve">
          <source>Below is the sample of what to do to reproduce the configuration on my machine. In</source>
          <target state="translated">以下は、私のマシンで設定を再現するために何をするかのサンプルです。での</target>
        </trans-unit>
        <trans-unit id="8d0833a6280a2357c9ec993c9c38bf06fc8a81e8" translate="yes" xml:space="preserve">
          <source>Below is typical code that shows how to use &lt;code&gt;LimitOutput&lt;/code&gt; .</source>
          <target state="translated">以下は、 &lt;code&gt;LimitOutput&lt;/code&gt; の使用方法を示す典型的なコードです。</target>
        </trans-unit>
        <trans-unit id="4f28ac791ee08fb184476e4de12d634a0a1d7498" translate="yes" xml:space="preserve">
          <source>Ben Tilly</source>
          <target state="translated">ベン・ティリー</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="9a552526ddac8fc37648130a16d1381a6f9ad6fb" translate="yes" xml:space="preserve">
          <source>Benchmark - benchmark running times of Perl code</source>
          <target state="translated">Benchmark-Perl コードの実行時間をベンチマークする</target>
        </trans-unit>
        <trans-unit id="c6133998f601e0eb9b2fbe0a853d3f9116d43ce3" translate="yes" xml:space="preserve">
          <source>Benchmark Object</source>
          <target state="translated">ベンチマークオブジェクト</target>
        </trans-unit>
        <trans-unit id="0ff60c3e395ce6dcfa9869e330a91fa3d0e1a335" translate="yes" xml:space="preserve">
          <source>Benchmark inherits from no other class, except of course from Exporter.</source>
          <target state="translated">Benchmarkは、Exporterはもちろんですが、他のクラスを継承していません。</target>
        </trans-unit>
        <trans-unit id="bf40ff62878fab85612abb7b1055df933f606399" translate="yes" xml:space="preserve">
          <source>Benchmark running times of Perl code</source>
          <target state="translated">Perl コードの実行時間のベンチマーク</target>
        </trans-unit>
        <trans-unit id="4b02607a2ea9a6953d07f941016201f155b468af" translate="yes" xml:space="preserve">
          <source>Benjamin Holzman contributed the tied variable support, Andrew Ford contributed the canonical order for hashes, and Gisle Aas fixed a few misunderstandings of mine regarding the perl internals, and optimized the emission of &quot;tags&quot; in the output streams by simply counting the objects instead of tagging them (leading to a binary incompatibility for the Storable image starting at version 0.6--older images are, of course, still properly understood). Murray Nesbitt made Storable thread-safe. Marc Lehmann added overloading and references to tied items support. Benjamin Holzman added a performance improvement for overloaded classes; thanks to Grant Street Group for footing the bill.</source>
          <target state="translated">Benjamin Holzman は tied 変数のサポートに貢献し、Andrew Ford はハッシュの正準順序に貢献し、Gisle Aas は perl の内部に関する私のいくつかの誤解を修正し、出力ストリームにおける「タグ」の放出を、タグを付ける代わりにオブジェクトを単純にカウントすることで最適化しました (バージョン 0.6 からの Storable イメージのバイナリ非互換性につながりますが、古いイメージはもちろんまだ適切に理解されています)。Murray Nesbitt は Storable をスレッドセーフにしました。Marc Lehmann は、オーバーロードと紐付きアイテムへの参照のサポートを追加しました。Benjamin Holzman は、オーバーロードされたクラスのパフォーマンスを改善しました。</target>
        </trans-unit>
        <trans-unit id="75fc540bc0a50aa81831bc474ec860350d0bca6e" translate="yes" xml:space="preserve">
          <source>Berkeley DB allows the creation of in-memory databases by using NULL (that is, a &lt;code&gt;(char *)0&lt;/code&gt; in C) in place of the filename. &lt;b&gt;DB_File&lt;/b&gt; uses &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of NULL to provide this functionality.</source>
          <target state="translated">Berkeley DBでは、ファイル名の代わりにNULL（つまり、Cの &lt;code&gt;(char *)0&lt;/code&gt; )を使用して、メモリ内データベースを作成できます。&lt;b&gt;DB_File&lt;/b&gt;は、この機能を提供するためにNULLではなく &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="9268b246582cb1f8cd7166d3bdd75afc5afe74a7" translate="yes" xml:space="preserve">
          <source>Berkeley DB is a C library which provides a consistent interface to a number of database formats. &lt;b&gt;DB_File&lt;/b&gt; provides an interface to all three of the database types currently supported by Berkeley DB.</source>
          <target state="translated">Berkeley DBは、多くのデータベース形式への一貫したインターフェースを提供するCライブラリです。&lt;b&gt;DB_File&lt;/b&gt;は、Berkeley DBで現在サポートされている3つのデータベースタイプすべてへのインターフェースを提供します。</target>
        </trans-unit>
        <trans-unit id="434964490ac8a77af87035de9e77b760d4b578ea" translate="yes" xml:space="preserve">
          <source>Berkeley DB uses the function dbopen() to open or create a database. Here is the C prototype for dbopen():</source>
          <target state="translated">Berkeley DBでは、データベースを開いたり作成したりするためにdbopen()という関数を使用します。ここに dbopen()の C プロトタイプがあります。</target>
        </trans-unit>
        <trans-unit id="cbcc04a4e53af70d968fb1854369b92c28068d53" translate="yes" xml:space="preserve">
          <source>BerkeleyDB is available for Cygwin.</source>
          <target state="translated">CygwinではBerkeleyDBが利用できます。</target>
        </trans-unit>
        <trans-unit id="994ccae3d03329e5f7c9f11ecf6157dc38d89408" translate="yes" xml:space="preserve">
          <source>Beside import() and AUTOLOAD() there are only a few other methods.</source>
          <target state="translated">import()と AUTOLOAD()の他には、いくつかのメソッドがあります。</target>
        </trans-unit>
        <trans-unit id="0cc3e4e79500c47fb5b02fd6bd36bb30830d4b93" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#decode&quot;&gt;decode&lt;/a&gt; and &lt;a href=&quot;#encode&quot;&gt;encode&lt;/a&gt;, other methods are available as well. For instance, &lt;code&gt;name()&lt;/code&gt; returns the canonical name of the encoding object.</source>
          <target state="translated">他に&lt;a href=&quot;#decode&quot;&gt;、デコード&lt;/a&gt;と&lt;a href=&quot;#encode&quot;&gt;エンコード&lt;/a&gt;、他の方法が同様に利用可能です。たとえば、 &lt;code&gt;name()&lt;/code&gt; は、エンコーディングオブジェクトの正規名を返します。</target>
        </trans-unit>
        <trans-unit id="a7e42697322af6c9745acd371b634a7d3de7f9ce" translate="yes" xml:space="preserve">
          <source>Besides checking existing XS code, the script can also be used to retrieve compatibility information for various API calls using the &lt;code&gt;--api-info&lt;/code&gt; command line switch. For example:</source>
          <target state="translated">スクリプトは、既存のXSコードをチェックするだけでなく、 &lt;code&gt;--api-info&lt;/code&gt; コマンドラインスイッチを使用して、さまざまなAPI呼び出しの互換性情報を取得するためにも使用できます。例えば：</target>
        </trans-unit>
        <trans-unit id="38c540b359fe4177c8733f2554f7c8aac1cf7755" translate="yes" xml:space="preserve">
          <source>Besides many other tests, it will test every locale it finds on your system to see if they conform to the POSIX standard. If any have errors, it will include a summary near the end of the output of which locales passed all its tests, and which failed, and why.</source>
          <target state="translated">他の多くのテストに加えて、システム上で見つけたすべてのロケールが POSIX 標準に準拠しているかどうかをテストします。エラーがあった場合は、出力の最後にどのロケールがすべてのテストに合格し、 どのロケールが失敗したのか、その理由をまとめて出力します。</target>
        </trans-unit>
        <trans-unit id="eaf1b9544c43d438f9e6f77acb1ab9f9247ce8b8" translate="yes" xml:space="preserve">
          <source>Besides putting the cross-compiler and the rest of the toolchain in your PATH, this will also provide the QNX_TARGET variable, which we will pass to Configure through -Dsysroot.</source>
          <target state="translated">クロスコンパイラとツールチェーンの残りの部分を PATH に配置するだけでなく、QNX_TARGET 変数も提供されます。</target>
        </trans-unit>
        <trans-unit id="8731a27dfb4cb7bb97f8e5e387722a8377af9b68" translate="yes" xml:space="preserve">
          <source>Besides saving these hashes as the hashref attributes &lt;code&gt;name2path&lt;/code&gt; and &lt;code&gt;path2name&lt;/code&gt; , calling this function also returns these hashrefs. In list context, the return value of &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; is the list &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; . In scalar context, the return value is &lt;code&gt;\%name2path&lt;/code&gt; . Or you can just call this in void context.</source>
          <target state="translated">これらのハッシュをhashref属性 &lt;code&gt;name2path&lt;/code&gt; および &lt;code&gt;path2name&lt;/code&gt; として保存するほかに、この関数を呼び出すと、これらのハッシュ参照も返されます。リストのコンテキストでは、 &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; の戻り値はリスト &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; です。スカラーコンテキストでは、戻り値は &lt;code&gt;\%name2path&lt;/code&gt; です。または、これをvoidコンテキストで呼び出すこともできます。</target>
        </trans-unit>
        <trans-unit id="d17cf41d34eb6f4b37b1b9cc872817585f3b1ca4" translate="yes" xml:space="preserve">
          <source>Besides the &lt;code&gt;$|&lt;/code&gt; special variable, you can use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to give your filehandle a &lt;code&gt;:unix&lt;/code&gt; layer, which is unbuffered:</source>
          <target state="translated">&lt;code&gt;$|&lt;/code&gt; 以外にも 特別な変数の場合、 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; を使用して、ファイルハンドルに &lt;code&gt;:unix&lt;/code&gt; レイヤーを与えることができます。</target>
        </trans-unit>
        <trans-unit id="c874def12573a04b6982ff2c45bf57742f038615" translate="yes" xml:space="preserve">
          <source>Besides the NBSP character discussed above, implementors are reminded of the existence of the other &quot;special&quot; character in Latin-1, the &quot;soft hyphen&quot; character, also known as &quot;discretionary hyphen&quot;, i.e. &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ). This character expresses an optional hyphenation point. That is, it normally renders as nothing, but may render as a &quot;-&quot; if a formatter breaks the word at that point. Pod formatters should, as appropriate, do one of the following: 1) render this with a code with the same meaning (e.g., &quot;\-&quot; in RTF), 2) pass it through in the expectation that the formatter understands this character as such, or 3) delete it.</source>
          <target state="translated">上記のNBSP文字に加えて、実装者はLatin-1に他の「特殊」文字、「ソフトハイフン」文字、つまり「任意ハイフン」としても知られている、つまり &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ）。この文字は、オプションのハイフネーションポイントを表します。つまり、通常は何もレンダリングされませんが、フォーマッターがその時点で単語を分割すると、「-」としてレンダリングされる可能性があります。ポッドフォーマッターは、必要に応じて、次のいずれかを実行する必要があります。1）これを同じ意味のコード（たとえば、RTFの「\-」）でレンダリングします。2）フォーマッターがこの文字を次のように理解することを期待してパススルーしますそのような、または3）それを削除します。</target>
        </trans-unit>
        <trans-unit id="383f64e6a803d40e90542694df252e926486880e" translate="yes" xml:space="preserve">
          <source>Besides the normal array index looping, &lt;code&gt;for&lt;/code&gt; can lend itself to many other interesting applications. Here's one that avoids the problem you get into if you explicitly test for end-of-file on an interactive file descriptor causing your program to appear to hang.</source>
          <target state="translated">通常の配列インデックスのループの他に、 &lt;code&gt;for&lt;/code&gt; は他の多くの興味深いアプリケーションに役立ちます。これは、対話型ファイル記述子でファイルの終わりを明示的にテストしてプログラムがハングしているように見える場合に発生する問題を回避するものです。</target>
        </trans-unit>
        <trans-unit id="b788aba9c107e5a4eaba0767ff3be57caf43c88d" translate="yes" xml:space="preserve">
          <source>Besides the obvious documents, source code can be instructive. Some pathological examples of the use of references can be found in the</source>
          <target state="translated">明白な文書以外にも、ソースコードは有益です。リファレンスの使用に関するいくつかの病的な例は</target>
        </trans-unit>
        <trans-unit id="3cd8fe6552552b50530c70ff871d9df229c4d203" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man also takes care of formatting func(), func(3), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; makes C++ look right, puts a little space between double underscores, makes ALLCAPS a teeny bit smaller in &lt;b&gt;troff&lt;/b&gt;, and escapes stuff that *roff treats as special so that you don't have to.</source>
          <target state="translated">明白なポッド変換の他に、Pod :: Manは、func（）、func（3）、および$ fooや@barなどの単純な変数参照のフォーマットも処理するため、コードエスケープを使用する必要はありません。ただし、 &lt;code&gt;$fred{'stuff'}&lt;/code&gt; などの複雑な式はエスケープする必要があります。また、ハイフンとして使用されていないダッシュをenダッシュに変換し、このように長いダッシュを適切なemダッシュに変換し、「ペアの引用符」を修正し、C ++を正しく見せるようにし、二重下線の間に少しスペースを入れ、ALLCAPSを作成します。&lt;b&gt;troff&lt;/b&gt;は少し小さく、* roffが特別なものとして扱うものをエスケープします。</target>
        </trans-unit>
        <trans-unit id="a063aa374e8d2e7cef3baa1877fd812efaeadbc4" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man, and therefore pod2man also takes care of formatting func(), func(n), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; and takes care of several other troff-specific tweaks. See &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; for complete information.</source>
          <target state="translated">明白なポッド変換に加えて、Pod :: Man、したがってpod2manは、func（）、func（n）、および$ fooや@barなどの単純な変数参照のフォーマットも処理するため、コードエスケープを使用する必要はありません。 ; ただし、 &lt;code&gt;$fred{'stuff'}&lt;/code&gt; などの複雑な式はエスケープする必要があります。また、ハイフンとして使用されていないダッシュをenダッシュに変換し、このように長いダッシュを適切なemダッシュに変換し、「ペアの引用符」を修正し、その他のいくつかのtroff固有の調整を処理します。詳細については、&lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2b7e5467e3e0ec9a6b2fff1ef3ee081c7b986017" translate="yes" xml:space="preserve">
          <source>Besides the well-known &quot;E&amp;lt;lt&amp;gt;&quot; and &quot;E&amp;lt;gt&amp;gt;&quot; codes for less-than and greater-than, Pod parsers must understand &quot;E&amp;lt;sol&amp;gt;&quot; for &quot;/&quot; (solidus, slash), and &quot;E&amp;lt;verbar&amp;gt;&quot; for &quot;|&quot; (vertical bar, pipe). Pod parsers should also understand &quot;E&amp;lt;lchevron&amp;gt;&quot; and &quot;E&amp;lt;rchevron&amp;gt;&quot; as legacy codes for characters 171 and 187, i.e., &quot;left-pointing double angle quotation mark&quot; = &quot;left pointing guillemet&quot; and &quot;right-pointing double angle quotation mark&quot; = &quot;right pointing guillemet&quot;. (These look like little &quot;&amp;lt;&amp;lt;&quot; and &quot;&amp;gt;&amp;gt;&quot;, and they are now preferably expressed with the HTML/XHTML codes &quot;E&amp;lt;laquo&amp;gt;&quot; and &quot;E&amp;lt;raquo&amp;gt;&quot;.)</source>
          <target state="translated">小なりと大なりのよく知られた「E &amp;lt;lt&amp;gt;」と「E &amp;lt;gt&amp;gt;」のコードに加えて、ポッドパーサーは「/」（固相線、スラッシュ）の「E &amp;lt;sol&amp;gt;」、および「 E &amp;lt;verbar&amp;gt; &quot;for&quot; | &quot; （垂直バー、パイプ）。ポッドパーサーは、「E &amp;lt;lchevron&amp;gt;」と「E &amp;lt;rchevron&amp;gt;」を文字171と187のレガシーコードとして理解する必要もあります。つまり、「左向きの二重角引用符」=「左向きのギレメット」と「右向きの二重」角度引用符 &quot;=&quot;右向きギレメット &quot;。 （これらは小さな「&amp;lt;&amp;lt;」と「&amp;gt;&amp;gt;」のように見えますが、HTML / XHTMLコード「E &amp;lt;laquo&amp;gt;」と「E &amp;lt;raquo&amp;gt;」で表現されることが望ましいです。）</target>
        </trans-unit>
        <trans-unit id="5b2158802b148a274c615dff49ad8ceaf2fe4a86" translate="yes" xml:space="preserve">
          <source>Besides these, all the Unicode character properties mentioned above (except for those marked as for internal use by Perl) are also accessible by &lt;a href=&quot;unicode/ucd#prop_invlist()&quot;&gt;prop_invlist() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">これらに加えて、上記のすべてのUnicode文字プロパティ（Perlによる内部使用としてマークされているものを除く）は&lt;a href=&quot;unicode/ucd#prop_invlist()&quot;&gt;、Unicode :: UCDのprop_invlist（）から&lt;/a&gt;もアクセスできます。</target>
        </trans-unit>
        <trans-unit id="708a3f784c168edb7cbbe1a181dbe5bffd40a3cc" translate="yes" xml:space="preserve">
          <source>Besides whole phrases meant for output, anything language-dependent should be put into the class Projname::L10N::en_us, whether as methods, or as lexicon entries -- this is discussed in the section &quot;Entries in Each Lexicon&quot;, above.</source>
          <target state="translated">出力のためのフレーズ全体の他に、言語に依存するものは、メソッドとしても、レキシコンのエントリとしても、クラスProjname::L10N::en_usに入れなければなりません --これは、上記の &quot;各レキシコンのエントリ &quot;のセクションで議論されています。</target>
        </trans-unit>
        <trans-unit id="cd7916b96afe381cf04fb2aeca341eed5cca3a69" translate="yes" xml:space="preserve">
          <source>Best practices for making a new module.</source>
          <target state="translated">新しいモジュールを作るためのベストプラクティス</target>
        </trans-unit>
        <trans-unit id="5f9760622e022594213ec306985fb05bd7325740" translate="yes" xml:space="preserve">
          <source>Between Mac OS X 10.3 &quot;Panther&quot; and 10.6 &quot;Snow Leopard&quot;, the 'Command Line Tools' bundle was called 'unix tools', and was usually supplied with Mac OS install DVDs.</source>
          <target state="translated">Mac OS X 10.3 &quot;Panther &quot;から10.6 &quot;Snow Leopard &quot;までの間、「コマンドラインツール」バンドルは「unix tools」と呼ばれ、通常はMac OSのインストールDVDに付属していました。</target>
        </trans-unit>
        <trans-unit id="6249e6fb239ee6aed11ccf460f154f4ff6f24738" translate="yes" xml:space="preserve">
          <source>Between the &lt;code&gt;%&lt;/code&gt; and the format letter, you may specify several additional attributes controlling the interpretation of the format. In order, these are:</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; とフォーマット文字の間に、フォーマットの解釈を制御するいくつかの追加属性を指定できます。順に、次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b8011f36b2088bc97398915695cf8abfb01b5b1d" translate="yes" xml:space="preserve">
          <source>Beware also of the order of more complicated expressions like:</source>
          <target state="translated">のような、より複雑な表現の順番にも注意してください。</target>
        </trans-unit>
        <trans-unit id="6c100dc724a3253ddc31a97cdb43e9fdb264b604" translate="yes" xml:space="preserve">
          <source>Beware of simple &quot;casting&quot; the entire expression, this would only convert the already computed result:</source>
          <target state="translated">式全体を単純に「キャスト」することに注意してください。</target>
        </trans-unit>
        <trans-unit id="c8bc77265aea976e7b646f3af43c05662f7e17da" translate="yes" xml:space="preserve">
          <source>Beware of:</source>
          <target state="translated">気をつけてください。</target>
        </trans-unit>
        <trans-unit id="6bac55531c21ad380bc95de89addf1faea92b643" translate="yes" xml:space="preserve">
          <source>Beware that if you put literal backslashes (those not inside interpolated variables) between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; , double-quotish backslash interpolation may lead to confusing results. If you</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; と &lt;code&gt;\E&lt;/code&gt; 間にリテラルのバックスラッシュ（補間変数の内部にないもの）を置くと、二重引用符のバックスラッシュの補間が結果を混乱させる可能性があることに注意してください。もし、あんたが</target>
        </trans-unit>
        <trans-unit id="6ca66f864461fdc36869edeb4abd6935993616b0" translate="yes" xml:space="preserve">
          <source>Beware that some command shells may place restrictions on the length of the command line. You must ensure your strings don't exceed this limit after any necessary interpolations. See the platform-specific release notes for more details about your particular environment.</source>
          <target state="translated">コマンドシェルによっては、コマンドラインの長さに制限がある場合があるので注意してください。必要な補間を行った後は、文字列がこの制限を超えないようにしなければなりません。特定の環境の詳細については、プラットフォーム固有のリリースノートを参照してください。</target>
        </trans-unit>
        <trans-unit id="1bd1204f447158c3ff1bfbe82d9a707a81d4fa56" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;#split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; とは異なり、 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; は最初の引数としてパターンを取りません。&lt;a href=&quot;#split&quot;&gt;分割を&lt;/a&gt;比較します。</target>
        </trans-unit>
        <trans-unit id="bc2144e8f71ac4bf9140995eea7dc924e6bdda59" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; とは異なり、 &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; は最初の引数としてパターンを取りません。&lt;a href=&quot;split&quot;&gt;分割を&lt;/a&gt;比較します。</target>
        </trans-unit>
        <trans-unit id="c39aa460c8cfb8c3295132732d48ee06e763b200" translate="yes" xml:space="preserve">
          <source>Beware: This feature is not fully implemented yet.</source>
          <target state="translated">ご注意ください。この機能はまだ完全には実装されていません。</target>
        </trans-unit>
        <trans-unit id="d3f2ff6e4b3a254c248f8c186f3f0868a1b1e7b1" translate="yes" xml:space="preserve">
          <source>Beware: This list is not complete.</source>
          <target state="translated">注意してください。このリストは完全ではありません。</target>
        </trans-unit>
        <trans-unit id="85c248dc6ba19bfc8397a2d612c997c46ad24985" translate="yes" xml:space="preserve">
          <source>Beware: after this function returns, &lt;code&gt;ptr&lt;/code&gt; and SvPVX_const(sv) may no longer refer to the same chunk of data.</source>
          <target state="translated">注意：この関数が戻った後、 &lt;code&gt;ptr&lt;/code&gt; とSvPVX_const（sv）は同じデータのチャンクを参照できなくなります。</target>
        </trans-unit>
        <trans-unit id="40ca4e03748bbc6d9d8fdf7c985dd464c29b4a02" translate="yes" xml:space="preserve">
          <source>Beyond Unicode code points</source>
          <target state="translated">Unicodeコードポイントを超えて</target>
        </trans-unit>
        <trans-unit id="8d2086dee2d46aa5a491374a05ac5325e10530d7" translate="yes" xml:space="preserve">
          <source>Beyond make test</source>
          <target state="translated">テストを作って下さい</target>
        </trans-unit>
        <trans-unit id="7071855c582934ec0ec68ba51cead15591289a64" translate="yes" xml:space="preserve">
          <source>Beyond that help, the urllist config parameter is yours. You can add and remove sites at will. You should find out which sites have the best up-to-dateness, bandwidth, reliability, etc. and are topologically close to you. Some people prefer fast downloads, others up-to-dateness, others reliability. You decide which to try in which order.</source>
          <target state="translated">そのヘルプを超えて、urllistの設定パラメータはあなたのものです。サイトの追加や削除は自由に行えます。どのサイトが最新性、帯域幅、信頼性などが最も優れていて、トポロジカルにあなたの近くにあるのかを見つけるべきです。高速ダウンロードを好む人もいれば、最新性を好む人もいれば、信頼性を好む人もいます。どの順番で試すかはあなたが決めてください。</target>
        </trans-unit>
        <trans-unit id="3f05839b089d755d215e2ff3af4aafe1ec68679d" translate="yes" xml:space="preserve">
          <source>Beyond that, the simplest debugger is the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function. Use it to look at values as you run your program:</source>
          <target state="translated">さらに、最も簡単なデバッガは &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 機能です。これを使用して、プログラムを実行しながら値を確認します。</target>
        </trans-unit>
        <trans-unit id="3981fa65dd4a5a67077c84cbcab0e6d7e62ef4b1" translate="yes" xml:space="preserve">
          <source>Beyond that, you have to consider several things and decide which is best for you.</source>
          <target state="translated">その先には、いくつかのことを考えて、どれが自分にとってベストなのかを決める必要があります。</target>
        </trans-unit>
        <trans-unit id="44d69eda49b459248ce90b6917e4f918be54d8d4" translate="yes" xml:space="preserve">
          <source>Beyond the normal measures described to make general Perl programs faster or smaller, a CGI program has additional issues. It may be run several times per second. Given that each time it runs it will need to be re-compiled and will often allocate a megabyte or more of system memory, this can be a killer. Compiling into C &lt;b&gt;isn't going to help you&lt;/b&gt; because the process start-up overhead is where the bottleneck is.</source>
          <target state="translated">一般的なPerlプログラムを高速化または小型化するために説明されている通常の対策に加えて、CGIプログラムには追加の問題があります。1秒間に数回実行される場合があります。実行するたびに再コンパイルする必要があり、メガバイト以上のシステムメモリが割り当てられることが多いため、これはキラーになる可能性があります。Cにコンパイルし&lt;b&gt;ても&lt;/b&gt;、プロセスの起動オーバーヘッドがボトルネックになるため、&lt;b&gt;役に立ちません&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="213d672c8ec1c5c132adb8f810eb6a5d6ae1c84f" translate="yes" xml:space="preserve">
          <source>Beyond the obvious problems that stem from giving special privileges to systems as flexible as scripts, on many versions of Unix, set-id scripts are inherently insecure right from the start. The problem is a race condition in the kernel. Between the time the kernel opens the file to see which interpreter to run and when the (now-set-id) interpreter turns around and reopens the file to interpret it, the file in question may have changed, especially if you have symbolic links on your system.</source>
          <target state="translated">スクリプトのように柔軟性のあるシステムに特別な権限を与えることに起因する明白な問題に加えて、多くのバージョンの Unix では、set-id スクリプトは最初から本質的に安全ではありません。問題はカーネル内の競合状態です。カーネルがどのインタプリタを実行するかを確認するためにファイルを開いてから、 (現在設定されている)インタプリタがそれを解釈するためにファイルを開き直すまでの間に、問題のファイルが変更されている可能性があります (特にシステム上にシンボリックリンクがある場合)。</target>
        </trans-unit>
        <trans-unit id="619d65e1ae1a2704aa306451ac2a75a0cde345a8" translate="yes" xml:space="preserve">
          <source>Bibliography</source>
          <target state="translated">Bibliography</target>
        </trans-unit>
        <trans-unit id="b4412d2ae1aa691608b316e9ad2227f4c8f05c5f" translate="yes" xml:space="preserve">
          <source>Bidirectional Communication with Another Process</source>
          <target state="translated">他プロセスとの双方向通信</target>
        </trans-unit>
        <trans-unit id="20453df9f611f7ce81199fe2171f3b15f7db6ba1" translate="yes" xml:space="preserve">
          <source>Bidirectional Communication with Yourself</source>
          <target state="translated">自分との双方向コミュニケーション</target>
        </trans-unit>
        <trans-unit id="aaec1a206ed8540735d6653165ead4690d690a5c" translate="yes" xml:space="preserve">
          <source>BigInt's bcmp() routine currently returns undef to signal that a NaN was involved in a comparison. However, the overload code turns that into either 1 or '' and thus operations like &lt;code&gt;NaN != NaN&lt;/code&gt; might return wrong values.</source>
          <target state="translated">BigIntのbcmp（）ルーチンは現在、undefを返し、NaNが比較に関与したことを通知します。ただし、オーバーロードコードはそれを1または ''のいずれかに変換するため、 &lt;code&gt;NaN != NaN&lt;/code&gt; ような操作は誤った値を返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="b68a65a4af953b7e6ff32f4e519ad10e0c7af47b" translate="yes" xml:space="preserve">
          <source>Bigger Numbers</source>
          <target state="translated">数字を大きくする</target>
        </trans-unit>
        <trans-unit id="98032da695f3e799620752e98882e414e0196f49" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!=&quot;&lt;/code&gt; returns true if the left argument is numerically not equal to the right argument.</source>
          <target state="translated">左側の引数が数値的に右側の引数と等しくない場合、バイナリ &lt;code&gt;&quot;!=&quot;&lt;/code&gt; はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="0806ad998452d5851f139bbe3f01d7066c39cefd" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; is just like &lt;code&gt;&quot;=~&quot;&lt;/code&gt; except the return value is negated in the logical sense.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;!~&quot;&lt;/code&gt; は、戻り値が論理的に否定されることを除いて、 &lt;code&gt;&quot;=~&quot;&lt;/code&gt; 〜&quot;と同じです。</target>
        </trans-unit>
        <trans-unit id="958b8a1169468f4a63917c7ca8496d2c631c8da0" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; with a non-destructive substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt;) or transliteration (&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt;) is a syntax error.</source>
          <target state="translated">非破壊的な置換（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; ）または音訳（ &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt; ）を含むバイナリ &lt;code&gt;&quot;!~&quot;&lt;/code&gt; は構文エラーです。</target>
        </trans-unit>
        <trans-unit id="f26c16627064dbaf94b2accf763da8c7ea571aa3" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;%&quot;&lt;/code&gt; is the modulo operator, which computes the division remainder of its first argument with respect to its second argument. Given integer operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; : If &lt;code&gt;$n&lt;/code&gt; is positive, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the largest multiple of &lt;code&gt;$n&lt;/code&gt; less than or equal to &lt;code&gt;$m&lt;/code&gt; . If &lt;code&gt;$n&lt;/code&gt; is negative, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the smallest multiple of &lt;code&gt;$n&lt;/code&gt; that is not less than &lt;code&gt;$m&lt;/code&gt; (that is, the result will be less than or equal to zero). If the operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; are floating point values and the absolute value of &lt;code&gt;$n&lt;/code&gt; (that is &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt;) is less than &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , only the integer portion of &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; will be used in the operation (Note: here &lt;code&gt;UV_MAX&lt;/code&gt; means the maximum of the unsigned integer type). If the absolute value of the right operand (&lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt;) is greater than or equal to &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; computes the floating-point remainder &lt;code&gt;$r&lt;/code&gt; in the equation &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; where &lt;code&gt;$i&lt;/code&gt; is a certain integer that makes &lt;code&gt;$r&lt;/code&gt; have the same sign as the right operand &lt;code&gt;$n&lt;/code&gt; (&lt;b&gt;not&lt;/b&gt; as the left operand &lt;code&gt;$m&lt;/code&gt; like C function &lt;code&gt;fmod()&lt;/code&gt; ) and the absolute value less than that of &lt;code&gt;$n&lt;/code&gt; . Note that when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; is in scope, &lt;code&gt;&quot;%&quot;&lt;/code&gt; gives you direct access to the modulo operator as implemented by your C compiler. This operator is not as well defined for negative operands, but it will execute faster.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;%&quot;&lt;/code&gt; は、2番目の引数に対する最初の引数の除算剰余を計算するモジュロ演算子です。整数オペランド所与 &lt;code&gt;$m&lt;/code&gt; および &lt;code&gt;$n&lt;/code&gt; ：場合 &lt;code&gt;$n&lt;/code&gt; 正である場合、 &lt;code&gt;$m % $n&lt;/code&gt; であり、 &lt;code&gt;$m&lt;/code&gt; マイナスの最大複数 &lt;code&gt;$n&lt;/code&gt; より小さいか等しい &lt;code&gt;$m&lt;/code&gt; 。場合 &lt;code&gt;$n&lt;/code&gt; 負で、その後で &lt;code&gt;$m % $n&lt;/code&gt; で &lt;code&gt;$m&lt;/code&gt; マイナスの最小複数 &lt;code&gt;$n&lt;/code&gt; 未満でない &lt;code&gt;$m&lt;/code&gt; （すなわち、結果未満またはゼロに等しいであろう）。オペランド &lt;code&gt;$m&lt;/code&gt; と &lt;code&gt;$n&lt;/code&gt; は浮動小数点値であり、 &lt;code&gt;$n&lt;/code&gt; 絶対値（つまり &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt; ）は &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; 未満です。 &lt;code&gt;$m&lt;/code&gt; と &lt;code&gt;$n&lt;/code&gt; 整数部分のみが操作で使用されます（注：ここで &lt;code&gt;UV_MAX&lt;/code&gt; は、符号なし整数型の最大値を意味します）。右のオペランドの絶対値（ &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt; ）が &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; 以上の場合、 &lt;code&gt;&quot;%&quot;&lt;/code&gt; は、式 &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; の浮動小数点剰余 &lt;code&gt;$r&lt;/code&gt; を計算します* $ N） &lt;code&gt;$i&lt;/code&gt; なる特定の整数であり、 &lt;code&gt;$r&lt;/code&gt; 右のオペランドと同じ符号を有しているが &lt;code&gt;$n&lt;/code&gt; （C関数 &lt;code&gt;fmod()&lt;/code&gt; のような左のオペランド &lt;code&gt;$m&lt;/code&gt; としてでは&lt;b&gt;なく&lt;/b&gt;）および &lt;code&gt;$n&lt;/code&gt; 絶対値より小さい絶対値。ときに注意 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 整数がスコープ内にある、 &lt;code&gt;&quot;%&quot;&lt;/code&gt; 、あなたのCコンパイラによって実装されるあなたのモジュロ演算子への直接アクセスを提供します。この演算子は負のオペランドに対しては十分に定義されていませんが、実行速度は速くなります。</target>
        </trans-unit>
        <trans-unit id="68ed9e30d3d6543dd0a9f75b291cbc79357b65a9" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; returns its operands ANDed together bit by bit. Although no warning is currently raised, the result is not well defined when this operation is performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;).</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; は、ビットごとにAND演算されたオペランドを返します。現在警告は出されていませんが、数値（&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;整数演算を&lt;/a&gt;参照）または&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;ビット文字列&lt;/a&gt;（ビットごとの文字列演算子を参照）ではないオペランドに対してこの演算を実行すると、結果は明確に定義されません。</target>
        </trans-unit>
        <trans-unit id="c0937405123294a033856c6fea7344af89470f86" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; performs a short-circuit logical AND operation. That is, if the left operand is false, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; は、短絡論理AND演算を実行します。つまり、左のオペランドがfalseの場合、右のオペランドは評価されません。スカラーまたはリストコンテキストは、評価された場合、右側のオペランドまで伝播します。</target>
        </trans-unit>
        <trans-unit id="1f3f00bc4d3f1107e73b1aeb90803d21d2f7f5a5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; returns true if the left argument is numerically greater than the right argument.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; は、左側の引数が右側の引数よりも数値的に大きい場合にtrueを返します。</target>
        </trans-unit>
        <trans-unit id="6a8e5f64ce960724d668657e4a1ad5261d933577" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; returns the value of its left argument shifted right by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;.)</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; は、右の引数で指定されたビット数だけ右にシフトされた左の引数の値を返します。引数は整数でなければなりません。（&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;整数演算&lt;/a&gt;も参照してください。）</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
