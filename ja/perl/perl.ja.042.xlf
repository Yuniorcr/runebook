<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="a87ba5fd11240d3846b6402630cc4fc5a1bb692a" translate="yes" xml:space="preserve">
          <source>The name of the remote file. For the local file name, the result of $ff-&amp;gt;output_file will be used.</source>
          <target state="translated">リモートファイルの名前。ローカルファイル名には、$ ff-&amp;gt; output_fileの結果が使用されます。</target>
        </trans-unit>
        <trans-unit id="54a547e6d045957f910163d7d9750610edbb9f85" translate="yes" xml:space="preserve">
          <source>The name of the test that will be displayed after the &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;not
ok&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;ok&lt;/code&gt; または &lt;code&gt;not ok&lt;/code&gt; 後に表示されるテストの名前。</target>
        </trans-unit>
        <trans-unit id="fed54953d3ed163e618a466d003f5bcd630ecc77" translate="yes" xml:space="preserve">
          <source>The name of the test. Usually a filename.</source>
          <target state="translated">テストの名前。通常はファイル名。</target>
        </trans-unit>
        <trans-unit id="bddd22d202ef6bbfb07440852aa85decd3f86741" translate="yes" xml:space="preserve">
          <source>The name of the variable the OP's targ refers to, if any, otherwise the letter t followed by the OP's targ in decimal.</source>
          <target state="translated">OPのtargが参照している変数の名前があればその名前、なければtの後に10進数でOPのtargが続く。</target>
        </trans-unit>
        <trans-unit id="57d8fd0b0612e473ba409ed332506df9547952e4" translate="yes" xml:space="preserve">
          <source>The name of this target is the name of the tarball generated by tardist. This target does the actual work of turning the distdir into a tarball.</source>
          <target state="translated">このターゲットの名前は tardist によって生成された tarball の名前です。このターゲットは distdir を tarball に変換する実際の作業を行います。</target>
        </trans-unit>
        <trans-unit id="7f384abee623b7aefa3eee77d6cf325a89576f28" translate="yes" xml:space="preserve">
          <source>The name of this target is the name of the zip file generated by zipdist. This target does the actual work of turning the distdir into a zip file.</source>
          <target state="translated">このターゲットの名前は、zipdist によって生成された zip ファイルの名前です。このターゲットは distdir を zip ファイルに変換する実際の作業を行います。</target>
        </trans-unit>
        <trans-unit id="40fffdd6d8d082596e0b6d7269c4fc2ab2372dd8" translate="yes" xml:space="preserve">
          <source>The name or URL, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if none. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the name (also sometimes called the page) is &quot;perlfunc&quot;. In &quot;L&amp;lt;/CAVEATS&amp;gt;&quot;, the name is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">名前またはURL 。存在しない場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。（たとえば、「L &amp;lt;Perl関数| perlfunc&amp;gt;」では、名前（ページとも呼ばれる）は「perlfunc」です。「L &amp;lt;/ CAVEATS&amp;gt;」では、名前は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; です。）</target>
        </trans-unit>
        <trans-unit id="032b79c8986bca0bbbc3c31a86f48e2e4e0d3085" translate="yes" xml:space="preserve">
          <source>The name returned is the &quot;best&quot; (defined below) official name or alias for the code point, if available; otherwise your custom alias for it, if defined; otherwise &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. This means that your alias will only be returned for code points that don't have an official Unicode name (nor alias) such as private use code points.</source>
          <target state="translated">返される名前は、コードポイントの「最適な」（以下で定義されている）公式名またはエイリアスです（使用可能な場合）。それ以外の場合は、カスタムエイリアス（定義されている場合）。それ以外の場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。これは、私用コードポイントなど、正式なUnicode名（またはエイリアス）を持たないコードポイントに対してのみエイリアスが返されることを意味します。</target>
        </trans-unit>
        <trans-unit id="45c859e03c561ae7900b19a5195289cf330fd686" translate="yes" xml:space="preserve">
          <source>The name specification contains the name of the option, optionally followed by a list of alternative names separated by vertical bar characters.</source>
          <target state="translated">名前指定には、 オプシ ョ ンの名前が含まれており、 それに続いて、 縦棒キ ャ ラ ク タ で区切られた代替名の一覧が必要にな り ます。</target>
        </trans-unit>
        <trans-unit id="74ea5f2153ac354bb676ac855da5204a1c4f0887" translate="yes" xml:space="preserve">
          <source>The name stored in the pad name struct. This returns NULL for a target slot.</source>
          <target state="translated">パッド名構造体に格納されている名前。これは、ターゲットスロットの場合はNULLを返します。</target>
        </trans-unit>
        <trans-unit id="7c9c5d421e8490b0fb44df42960273145ec017c2" translate="yes" xml:space="preserve">
          <source>The name that &lt;code&gt;gv_stash*v&lt;/code&gt; wants is the name of the package whose symbol table you want. The default package is called &lt;code&gt;main&lt;/code&gt; . If you have multiply nested packages, pass their names to &lt;code&gt;gv_stash*v&lt;/code&gt; , separated by &lt;code&gt;::&lt;/code&gt; as in the Perl language itself.</source>
          <target state="translated">名前 &lt;code&gt;gv_stash*v&lt;/code&gt; 望んでは、シンボルテーブル、あなたがしたいパッケージの名前です。デフォルトのパッケージは &lt;code&gt;main&lt;/code&gt; と呼ばれます。複数のネストされたパッケージがある場合は、Perl言語自体と同様に、 &lt;code&gt;::&lt;/code&gt; で区切って &lt;code&gt;gv_stash*v&lt;/code&gt; に名前を渡します。</target>
        </trans-unit>
        <trans-unit id="0ea1c9f71e1742c14f7e274aadd24083453f785c" translate="yes" xml:space="preserve">
          <source>The name used to execute the current copy of Perl, from C's &lt;code&gt;argv[0]&lt;/code&gt; or (where supported)</source>
          <target state="translated">Cの &lt;code&gt;argv[0]&lt;/code&gt; または（サポートされている場合）から、Perlの現在のコピーを実行するために使用される名前</target>
        </trans-unit>
        <trans-unit id="7d5e4108cb484849f5cc23fa9d5c378793d57fcf" translate="yes" xml:space="preserve">
          <source>The names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618e9ec6e6fd129b3719b6fed50188e89fd59442" translate="yes" xml:space="preserve">
          <source>The names are in the old-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">名前は古いスタイルです（古い&lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;スタイルと新しいスタイルのブロック名を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="07ca386df79309f7e041c206d3183ef66c0ddbc4" translate="yes" xml:space="preserve">
          <source>The names associated with pad entries.</source>
          <target state="translated">パッドエントリに関連付けられた名前。</target>
        </trans-unit>
        <trans-unit id="284af84a82eacc68e4acdb3ccfa2e6b8438eb902" translate="yes" xml:space="preserve">
          <source>The names have been chosen by analogy with &lt;a href=&quot;tie/scalar&quot;&gt;Tie::Scalar&lt;/a&gt; methods names with an additional &lt;b&gt;LENGTH&lt;/b&gt; callback for efficiency. However named capture variables are currently not tied internally but implemented via magic.</source>
          <target state="translated">名前は、効率のために追加の&lt;b&gt;LENGTH&lt;/b&gt;コールバックを備えた&lt;a href=&quot;tie/scalar&quot;&gt;Tie :: Scalar&lt;/a&gt;メソッド名との類比によって選択されています。ただし、名前付きキャプチャ変数は現在内部的に結び付けられておらず、マジックを介して実装されています。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6f2021e99e612abfa74ac94b1f6cbd3e729a273e" translate="yes" xml:space="preserve">
          <source>The names of any symbols that cannot be exported should be listed in the &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; array.</source>
          <target state="translated">エクスポートできないシンボルの名前は、 &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; 配列にリストする必要があります。</target>
        </trans-unit>
        <trans-unit id="ce28b5edeebefe670a07dac363032a7c7d1c8c78" translate="yes" xml:space="preserve">
          <source>The names of one or more patch files or other text attachments to be included with the report. Multiple files must be separated with commas.</source>
          <target state="translated">レポートに添付する1つまたは複数のパッチファイルまたはその他のテキスト添付ファイルの名前。複数のファイルはカンマで区切る必要があります。</target>
        </trans-unit>
        <trans-unit id="8f857c3b3defbce0780a8f039ec3e39d992aed2b" translate="yes" xml:space="preserve">
          <source>The names of the constants are grouped by length. Generate child subroutines for each group with this number or more names in.</source>
          <target state="translated">定数の名前は長さごとにグループ化されています。この数以上の名前が入ったグループごとに子サブルーチンを生成します。</target>
        </trans-unit>
        <trans-unit id="014e7ffcf388c955244e207841832a805e1b764b" translate="yes" xml:space="preserve">
          <source>The names of the fields can be obtained by calling &lt;code&gt;overview_fmt&lt;/code&gt; .</source>
          <target state="translated">フィールドの名前は、 &lt;code&gt;overview_fmt&lt;/code&gt; を呼び出すことで取得できます。</target>
        </trans-unit>
        <trans-unit id="e4fc313d5aefbc7e8f27ebb1be72375df1f65ec2" translate="yes" xml:space="preserve">
          <source>The names of the signals are the ones listed out by &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; on your system, or you can retrieve them using the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Signal&quot;&gt;IPC::Signal&lt;/a&gt;.</source>
          <target state="translated">シグナルの名前は、システムで &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; によってリストされたものです。または、CPANモジュール&lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Signal&quot;&gt;IPC :: Signal&lt;/a&gt;を使用してシグナルを取得できます。</target>
        </trans-unit>
        <trans-unit id="9e5a87a1d013fec4fa7021ebe1fad71eb5dada0f" translate="yes" xml:space="preserve">
          <source>The naming of encodings, both by the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; and by the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma allows for flexible names: &lt;code&gt;koi8-r&lt;/code&gt; and &lt;code&gt;KOI8R&lt;/code&gt; will both be understood.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; プラグマの両方によるエンコーディングの命名により、柔軟な名前が可能になります &lt;code&gt;koi8-r&lt;/code&gt; と &lt;code&gt;KOI8R&lt;/code&gt; の両方が理解されます。</target>
        </trans-unit>
        <trans-unit id="eb26ebee327534f7eadec1f76baa31ad090fef00" translate="yes" xml:space="preserve">
          <source>The native status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt; ) command, successful call to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt;, or from the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; operator. On POSIX-like systems this value can be decoded with the WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG and WIFCONTINUED functions provided by the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module.</source>
          <target state="translated">最後のパイプのクローズ、バックティック（ &lt;code&gt;``&lt;/code&gt; ）コマンド、 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; の正常な呼び出し、または &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; オペレーターから返されたネイティブのステータス。POSIXのようなシステムでは、この値は、&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;モジュールによって提供されるWIFEXITED、WEXITSTATUS、WIFSIGNALED、WTERMSIG、WIFSTOPPED、WSTOPSIG、およびWIFCONTINUED関数でデコードできます。</target>
        </trans-unit>
        <trans-unit id="2f679d50295d2d00d85ba280df81111988684878" translate="yes" xml:space="preserve">
          <source>The natural question: &quot;Why can't Perl compensate for the gaps?&quot; warrants an answer. One good reason is that C compilers might provide (non-ANSI) extensions permitting all sorts of fancy control over the way structures are aligned, even at the level of an individual structure field. And, if this were not enough, there is an insidious thing called &lt;code&gt;union&lt;/code&gt; where the amount of fill bytes cannot be derived from the alignment of the next item alone.</source>
          <target state="translated">自然な質問：「なぜPerlはギャップを補うことができないのですか？」答えを保証します。良い理由の1つは、Cコンパイラが（非ANSI）拡張を提供して、個々の構造体フィールドのレベルであっても、構造体の整列方法に関するあらゆる種類の高度な制御を可能にする可能性があることです。そして、これで十分でない場合は、 &lt;code&gt;union&lt;/code&gt; と呼ばれる油断のならない問題があり、次の項目の配置だけでは、フィルバイトの量を取得できません。</target>
        </trans-unit>
        <trans-unit id="73304f2bc3720cbdf5bbe3a347ce1a6a6606cb3e" translate="yes" xml:space="preserve">
          <source>The natural way to do this is to have a hash whose keys are country names. Associated with each country name key is a list of the cities in that country. Each time you read a line of input, split it into a country and a city, look up the list of cities already known to be in that country, and append the new city to the list. When you're done reading the input, iterate over the hash as usual, sorting each list of cities before you print it out.</source>
          <target state="translated">これを行うための自然な方法は、国名をキーとするハッシュを持つことです。それぞれの国名のキーには、その国の都市のリストが関連付けられています。入力の行を読むたびに、それを国と都市に分割し、その国にすでに存在することが知られている都市のリストを調べて、新しい都市をリストに追加します。入力を読み終えたら、いつものようにハッシュを反復処理し、印刷する前に各都市のリストをソートする。</target>
        </trans-unit>
        <trans-unit id="9ba13cfae515a220e252c3e1157af722de7da0aa" translate="yes" xml:space="preserve">
          <source>The negation is useful for defining (surprise!) negated classes.</source>
          <target state="translated">否定は、否定されたクラスを定義するのに便利です(驚き!)。</target>
        </trans-unit>
        <trans-unit id="db0ad6bd4816ce652496b94f2f1d7976b92ada0c" translate="yes" xml:space="preserve">
          <source>The negation of this macro, &lt;code&gt;OP_TYPE_ISNT&lt;/code&gt; is also available as well as &lt;code&gt;OP_TYPE_IS_NN&lt;/code&gt; and &lt;code&gt;OP_TYPE_ISNT_NN&lt;/code&gt; which elide the NULL pointer check.</source>
          <target state="translated">このマクロの否定である &lt;code&gt;OP_TYPE_ISNT&lt;/code&gt; は、NULLポインターチェックを &lt;code&gt;OP_TYPE_ISNT_NN&lt;/code&gt; する &lt;code&gt;OP_TYPE_IS_NN&lt;/code&gt; およびOP_TYPE_ISNT_NNと同様に使用できます。</target>
        </trans-unit>
        <trans-unit id="691f70fa29f72e49de97eccc12c05c1f840f1b46" translate="yes" xml:space="preserve">
          <source>The negation of this macro, &lt;code&gt;OP_TYPE_ISNT_AND_WASNT&lt;/code&gt; is also available as well as &lt;code&gt;OP_TYPE_IS_OR_WAS_NN&lt;/code&gt; and &lt;code&gt;OP_TYPE_ISNT_AND_WASNT_NN&lt;/code&gt; which elide the NULL pointer check.</source>
          <target state="translated">このマクロの否定である &lt;code&gt;OP_TYPE_ISNT_AND_WASNT&lt;/code&gt; は、NULLポインターチェックを &lt;code&gt;OP_TYPE_ISNT_AND_WASNT_NN&lt;/code&gt; する &lt;code&gt;OP_TYPE_IS_OR_WAS_NN&lt;/code&gt; およびOP_TYPE_ISNT_AND_WASNT_NNと同様に使用できます。</target>
        </trans-unit>
        <trans-unit id="a68f1f4d38ce035e2e238de529bbc7313afe802e" translate="yes" xml:space="preserve">
          <source>The new class is given a constructor method, &lt;code&gt;new&lt;/code&gt; , for creating struct objects.</source>
          <target state="translated">新しいクラスは、コンストラクタメソッド、与えられた &lt;code&gt;new&lt;/code&gt; 構造体オブジェクトを作成するために、。</target>
        </trans-unit>
        <trans-unit id="133a286ef1fa797920ffbacb6d543c092bbb9c81" translate="yes" xml:space="preserve">
          <source>The new compare function must be specified when you create the database.</source>
          <target state="translated">データベースを作成する際には、新しい比較関数を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="6ca5133e85084fb8ccd654bdee5f648c6a7925f9" translate="yes" xml:space="preserve">
          <source>The new interface to the USE_PERLIO implementation. The layers &quot;:crlf&quot; and &quot;:raw&quot; are only ones allowed for other implementations and those are silently ignored. (As of perl5.8 &quot;:raw&quot; is deprecated.) Use PerlIO_binmode() below for the portable case.</source>
          <target state="translated">USE_PERLIO 実装への新しいインターフェース。レイヤー &quot;:crlf&quot; と &quot;:raw&quot; は他の実装で許可されているものだけで、それらは静かに無視されます。(Perl5.8 では &quot;:raw&quot; は非推奨です。)ポータブルな場合は以下の PerlIO_binmode()を使用してください。</target>
        </trans-unit>
        <trans-unit id="ef605716ebbaada258955508adf61e07c343c95f" translate="yes" xml:space="preserve">
          <source>The new key is specified by</source>
          <target state="translated">新しいキーは</target>
        </trans-unit>
        <trans-unit id="853b1cad8315c050b3031642990285f3b3f61796" translate="yes" xml:space="preserve">
          <source>The new perlIO layer is used. NI-S' favorite.</source>
          <target state="translated">新しいperlIOレイヤーを使用しています。NI-Sのお気に入り。</target>
        </trans-unit>
        <trans-unit id="3f44fc740bd8115fd48ea2f3dccbe8d30383620f" translate="yes" xml:space="preserve">
          <source>The new routine will be called whenever a built-in function is called without a qualifying package:</source>
          <target state="translated">新しいルーチンは、組み込み関数が修飾パッケージなしで呼び出されるときに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="69fd8169a1c03a87b9cb7323668ea2985b78ca39" translate="yes" xml:space="preserve">
          <source>The new semantics are now only available with &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; . The old semantics are only available through &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; . Users are strongly encouraged to upgrade to at least 2.08 in order to avoid surprises.</source>
          <target state="translated">新しいセマンティクスは現在、 &lt;code&gt;make_path&lt;/code&gt; および &lt;code&gt;remove_tree&lt;/code&gt; でのみ使用できます。古いセマンティクスは、 &lt;code&gt;mkpath&lt;/code&gt; および &lt;code&gt;rmtree&lt;/code&gt; を介してのみ利用できます。予期しない事態を避けるために、ユーザーは2.08以上にアップグレードすることを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="dcb00043758d6e48f38e06be5dcd0156fe97d078" translate="yes" xml:space="preserve">
          <source>The new shiny result of either genuine new functionality or your arduous refactoring is now ready and correctly exported. So what could possibly go wrong?</source>
          <target state="translated">本物の新機能か、あなたの苦労したリファクタリングのどちらかの新しいピカピカの結果が準備され、正しくエクスポートされるようになりました。では、何が問題になるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="c231cf25130a94dd10bb860a955a6b6ad30c18f8" translate="yes" xml:space="preserve">
          <source>The new simpler way to call &lt;code&gt;XSLoader::load()&lt;/code&gt; with no arguments at all does not work on Perl 5.8.4 and 5.8.5.</source>
          <target state="translated">引数なしで &lt;code&gt;XSLoader::load()&lt;/code&gt; を呼び出す新しい簡単な方法は、Perl 5.8.4および5.8.5では機能しません。</target>
        </trans-unit>
        <trans-unit id="80d8983154af8008f3d7e48dfd488df835186d04" translate="yes" xml:space="preserve">
          <source>The new thread creation is line 20. We pass on to it a reference to the queue we've created, and the prime number we've found. In lines 21 through 24, we check to make sure that our new thread got created, and if not, we stop checking any remaining numbers in the queue.</source>
          <target state="translated">新しいスレッドの作成は20行目です。私たちはそれに、私たちが作成したキューへの参照と、私たちが見つけた素数を渡します。21 行目から 24 行目では、新しいスレッドが作成されたかどうかを確認し、作成されなかった場合は、キューに残っている素数の確認を中止します。</target>
        </trans-unit>
        <trans-unit id="9044c695c3da968e5a2ea15d51b8b1e2dbc7cbb0" translate="yes" xml:space="preserve">
          <source>The new() function searches for all the installed .packlists on the system, and stores their contents. The .packlists can be queried with the functions described below. Where it searches by default is determined by the settings found in &lt;code&gt;%Config::Config&lt;/code&gt; , and what the value is of the PERL5LIB environment variable.</source>
          <target state="translated">new（）関数は、システムにインストールされているすべての.packlistsを検索し、その内容を保存します。 .packlistsは、以下で説明する関数を使用して照会できます。デフォルトで検索する場所は、 &lt;code&gt;%Config::Config&lt;/code&gt; と、PERL5LIB環境変数の値によって決まります。</target>
        </trans-unit>
        <trans-unit id="5e76ad120503fe22fb2abd0288095a443b471d16" translate="yes" xml:space="preserve">
          <source>The newer style replaces these with underscores, like this:</source>
          <target state="translated">新しいスタイルでは、このようにアンダースコアに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="0249c11220739d961eab9d8efdfb827caa468595" translate="yes" xml:space="preserve">
          <source>The newly created subroutine takes ownership of a reference to the passed in SV.</source>
          <target state="translated">新しく作成されたサブルーチンは、渡された SV への参照を所有します。</target>
        </trans-unit>
        <trans-unit id="c36ff1fb86ca87ccc2385388c9e1be809de8496c" translate="yes" xml:space="preserve">
          <source>The next 8 bits contain the termination status of the program.</source>
          <target state="translated">次の 8 ビットには、プログラムの終了状態が格納されます。</target>
        </trans-unit>
        <trans-unit id="429ca09b18f928ad50edc605bbb88976cae30220" translate="yes" xml:space="preserve">
          <source>The next example demonstrates how one would place an explicit undef in the return value, should the need arise.</source>
          <target state="translated">次の例は、必要に応じて戻り値に明示的な undef をどのように配置するかを示しています。</target>
        </trans-unit>
        <trans-unit id="abdb50fe44b0e7ab1495a77ca76309d394c16e26" translate="yes" xml:space="preserve">
          <source>The next example show how to use the &lt;code&gt;LimitOutput&lt;/code&gt; option. Notice the use of two nested loops in this case. The outer loop reads the data from the input source - STDIN and the inner loop repeatedly calls &lt;code&gt;inflate&lt;/code&gt; until &lt;code&gt;$input&lt;/code&gt; is exhausted, we get an error, or the end of the stream is reached. One point worth remembering is by using the &lt;code&gt;LimitOutput&lt;/code&gt; option you also get &lt;code&gt;ConsumeInput&lt;/code&gt; set as well - this makes the code below much simpler.</source>
          <target state="translated">次の例は、 &lt;code&gt;LimitOutput&lt;/code&gt; オプションの使用方法を示しています。この場合、2つのネストされたループの使用に注意してください。外側のループは入力ソース-STDINからデータを読み取り、内側のループは &lt;code&gt;$input&lt;/code&gt; が使い果たされるか、エラーが発生するか、ストリームの終わりに達するまで、繰り返し &lt;code&gt;inflate&lt;/code&gt; を呼び出します。ワンポイントの価値を思い出すには、使用している &lt;code&gt;LimitOutput&lt;/code&gt; のあなたにも取得するオプションを &lt;code&gt;ConsumeInput&lt;/code&gt; の、これははるかに簡単な以下のコードを作る-などもセット。</target>
        </trans-unit>
        <trans-unit id="a73f1f7691d7497b711d0f4bac2e881b3c885873" translate="yes" xml:space="preserve">
          <source>The next example shows each input parameter evaluated late.</source>
          <target state="translated">次の例では、各入力パラメータの評価が遅れていることを示しています。</target>
        </trans-unit>
        <trans-unit id="def9f1245a38d3c5116ce761f9376e6f2078f597" translate="yes" xml:space="preserve">
          <source>The next examples will use the following C++ class.</source>
          <target state="translated">次の例では、以下のC++クラスを使用します。</target>
        </trans-unit>
        <trans-unit id="6c82e2eba4791c1303c10eb37d70a72bf59badcd" translate="yes" xml:space="preserve">
          <source>The next option deals with the charset (a.k.a. character set) your terminal supports. In general, CPAN is English speaking territory, so the charset does not matter much but some CPAN have names that are outside the ASCII range. If your terminal supports UTF-8, you should say no to the next question. If it expects ISO-8859-1 (also known as LATIN1) then you should say yes. If it supports neither, your answer does not matter because you will not be able to read the names of some authors anyway. If you answer no, names will be output in UTF-8.</source>
          <target state="translated">次のオプションは、ターミナルがサポートしている文字セット(別名文字セット)を扱います。一般的に、CPANは英語圏なので、文字コードはあまり重要ではありませんが、いくつかのCPANはASCIIの範囲外の名前を持っています。お使いの端末が UTF-8 をサポートしている場合、次の質問には「いいえ」と答えるべきです。ISO-8859-1 (LATIN1 としても知られています)を期待しているのであれば、「はい」と答えるべきです。どちらもサポートしていない場合、あなたの答えは重要ではありません。いいえと答えた場合、名前はUTF-8で出力されます。</target>
        </trans-unit>
        <trans-unit id="128477608ba084f3baead065e12f71790ccb5def" translate="yes" xml:space="preserve">
          <source>The next pointer for &lt;code&gt;BRANCH&lt;/code&gt; es is interesting in that it points at where execution should go if the branch fails. When executing, if the engine tries to traverse from a branch to a &lt;code&gt;regnext&lt;/code&gt; that isn't a branch then the engine will know that the entire set of branches has failed.</source>
          <target state="translated">&lt;code&gt;BRANCH&lt;/code&gt; es の次のポインタは、分岐が失敗した場合に実行がどこに進むべきかを指し示すという点で興味深いものです。実行時に、エンジンがブランチから &lt;code&gt;regnext&lt;/code&gt; ではないregnextにトラバースしようとすると、エンジンはブランチのセット全体が失敗したことを認識します。</target>
        </trans-unit>
        <trans-unit id="8b56244f1caeaf0b5b4e0b479de80d44c501b35d" translate="yes" xml:space="preserve">
          <source>The next step is interpolation in the text obtained, which is now delimiter-independent. There are multiple cases.</source>
          <target state="translated">次に得られたテキストの補間ですが、これはデリミタに依存しなくなりました。複数のケースがあります。</target>
        </trans-unit>
        <trans-unit id="99d612978700e6928f957643eba3d0d61622b6ed" translate="yes" xml:space="preserve">
          <source>The next step is to submit your patch to the Perl core ticket system via email.</source>
          <target state="translated">次のステップは、メールでPerlコアチケットシステムにパッチを提出することです。</target>
        </trans-unit>
        <trans-unit id="82a6f456a2c90d50e2abfb7f37ee6f9a4299445f" translate="yes" xml:space="preserve">
          <source>The next task is to break the problem down into smaller problems that are easily converted into a regexp.</source>
          <target state="translated">次の課題は、この問題を簡単に正規表現に変換できるような小さな問題に分解することです。</target>
        </trans-unit>
        <trans-unit id="c9e21bae9fb5eef63978dcfa71c7a0d3cb21ec24" translate="yes" xml:space="preserve">
          <source>The next time you wish to make a patch, you need to start from the latest perl in a pristine state. Check you don't have any local changes or added files in your perl check-out which you wish to keep, then run these commands:</source>
          <target state="translated">次にパッチを作成したい場合は、最新のperlを原始状態のままで起動する必要があります。保存しておきたいローカルの変更や追加されたファイルがPerlのチェックアウトに入っていないことを確認してから、以下のコマンドを実行してください。</target>
        </trans-unit>
        <trans-unit id="79f58ceb3f799f52310d0fb9160eed5d3d3eaba7" translate="yes" xml:space="preserve">
          <source>The nice part about todo tests, as opposed to simply commenting out a block of tests, is it's like having a programmatic todo list. You know how much work is left to be done, you're aware of what bugs there are, and you'll know immediately when they're fixed.</source>
          <target state="translated">Todo テストの良いところは、単にテストのブロックをコメントアウトするのとは対照的に、プログラムの Todo リストを持っているようなものです。どのくらいの作業が残っているのかがわかり、どのようなバグがあるのかがわかり、いつ修正されるのかがすぐにわかります。</target>
        </trans-unit>
        <trans-unit id="92737be37077b1e4ee6685cd7da7d12b0a775c27" translate="yes" xml:space="preserve">
          <source>The nmake that comes with Visual C++ will suffice for building. Visual C requires that certain things be set up in the console before Visual C will sucessfully run. To make a console box be able to run the C compiler, you will need to beforehand, run the &lt;code&gt;vcvars32.bat&lt;/code&gt; file to compile for x86-32 and for x86-64 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; or &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; . On a typical install of a Microsoft C compiler product, these batch files will already be in your &lt;code&gt;PATH&lt;/code&gt; environment variable so you may just type them without an absolute path into your console. If you need to find the absolute path to the batch file, it is usually found somewhere like C:\Program Files\Microsoft Visual Studio\VC98\Bin. With some newer Micrsoft C products (released after ~2004), the installer will put a shortcut in the start menu to launch a new console window with the console already set up for your target architecture (x86-32 or x86-64 or IA64). With the newer compilers, you may also use the older batch files if you choose so.</source>
          <target state="translated">ビルドには、Visual C ++に付属するnmakeで十分です。 Visual Cでは、Visual Cを正常に実行する前に、コンソールで特定の設定を行う必要があります。コンソールボックスでCコンパイラを実行できるようにするには、事前に &lt;code&gt;vcvars32.bat&lt;/code&gt; ファイルを実行してx86-32およびx86-64の &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; または &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; をコンパイルする必要があります。 Microsoft Cコンパイラ製品の通常のインストールでは、これらのバッチファイルはすでに &lt;code&gt;PATH&lt;/code&gt; にあります。環境変数を使用して、コンソールへの絶対パスなしで入力するだけです。バッチファイルへの絶対パスを見つける必要がある場合は、通常、C：\ Program Files \ Microsoft Visual Studio \ VC98 \ Binのような場所にあります。一部の新しいMicrsoft C製品（2004年以降にリリース）では、インストーラーはスタートメニューにショートカットを配置して、ターゲットアーキテクチャ（x86-32またはx86-64またはIA64）用にすでに設定されているコンソールで新しいコンソールウィンドウを起動します。新しいコンパイラでは、必要に応じて古いバッチファイルを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="d92d9609b16a9236c6b0750e878097cebaf141fa" translate="yes" xml:space="preserve">
          <source>The nmake that comes with the Platform SDK will suffice for building Perl. Make sure you are building within one of the &quot;Build Environment&quot; shells available after you install the Platform SDK from the Start Menu.</source>
          <target state="translated">Perl のビルドは、Platform SDK に付属の nmake で十分です。スタートメニューからPlatform SDKをインストールした後、&quot;Build Environment &quot;シェルのいずれかでビルドしていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="4cf437af831d898cd280f5f9fa16e3b19f38db9a" translate="yes" xml:space="preserve">
          <source>The node type, either &lt;code&gt;section&lt;/code&gt; or &lt;code&gt;item&lt;/code&gt; . As an unofficial type, there is also &lt;code&gt;hyperlink&lt;/code&gt; , derived from e.g. &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">ノードタイプ（ &lt;code&gt;section&lt;/code&gt; または &lt;code&gt;item&lt;/code&gt; 。非公式のタイプとして、たとえば &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; &lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt; &amp;gt;から派生した &lt;code&gt;hyperlink&lt;/code&gt; もあります。</target>
        </trans-unit>
        <trans-unit id="8827c5b69a11959983a358ee79f064e14c978f0c" translate="yes" xml:space="preserve">
          <source>The non-destructive modifier &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; causes the result of the substitution to be returned instead of modifying &lt;code&gt;$_&lt;/code&gt; (or whatever variable the substitute was bound to with &lt;code&gt;=~&lt;/code&gt; ):</source>
          <target state="translated">非破壊的な修飾子 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; と、 &lt;code&gt;$_&lt;/code&gt; （または &lt;code&gt;=~&lt;/code&gt; バインドされた変数）を変更する代わりに、置換の結果が返されます。</target>
        </trans-unit>
        <trans-unit id="d3e24c19053882dd3539c4f0f017c48b302d8630" translate="yes" xml:space="preserve">
          <source>The non-zero numeric</source>
          <target state="translated">ゼロ以外の数値</target>
        </trans-unit>
        <trans-unit id="ed0d308e2d36922ca367c5db784707665a50eda8" translate="yes" xml:space="preserve">
          <source>The normal Makefile.PL that h2xs generates doesn't know about the mylib directory. We need to tell it that there is a subdirectory and that we will be generating a library in it. Let's add the argument MYEXTLIB to the WriteMakefile call so that it looks like this:</source>
          <target state="translated">h2xs が生成する通常の Makefile.PL は mylib ディレクトリを知りません。サブディレクトリがあり,そこにライブラリを生成することを伝える必要があります.引数MYEXTLIBをWriteMakefile呼び出しに追加して,次のようにしてみましょう.</target>
        </trans-unit>
        <trans-unit id="b1469f4963ec233a67445e77b1dc5adf4ccf9ab7" translate="yes" xml:space="preserve">
          <source>The normal course of action is to call:</source>
          <target state="translated">普通に電話するのが普通です。</target>
        </trans-unit>
        <trans-unit id="ecf683f52c0f42f564cf7e0ed381f4bb97cc8438" translate="yes" xml:space="preserve">
          <source>The normal use of this class is like so:</source>
          <target state="translated">このクラスの通常の使い方はこんな感じです。</target>
        </trans-unit>
        <trans-unit id="1ac2010e9cf7828bd4211d3176636428b6a9a255" translate="yes" xml:space="preserve">
          <source>The normal way to run a Perl program is by making it directly executable, or else by passing the name of the source file as an argument on the command line. (An interactive Perl environment is also possible--see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; for details on how to do that.) Upon startup, Perl looks for your program in one of the following places:</source>
          <target state="translated">Perlプログラムを実行する通常の方法は、直接実行可能にするか、ソースファイルの名前をコマンドラインの引数として渡すことです。（対話型のPerl環境も可能です。その方法の詳細については、&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;を参照してください。）起動時に、Perlは次のいずれかの場所でプログラムを探します。</target>
        </trans-unit>
        <trans-unit id="46672cb58512b6dfcf1bfa852b6fb1012267b6a3" translate="yes" xml:space="preserve">
          <source>The notation still looks a little cumbersome, so there's one more abbreviation:</source>
          <target state="translated">表記がまだちょっと面倒くさそうなので、もう一つ略しておきます。</target>
        </trans-unit>
        <trans-unit id="faf2109c5b26dde1813deee78331f15408acfe4a" translate="yes" xml:space="preserve">
          <source>The notion that an empty &lt;b&gt;derived class&lt;/b&gt; should behave exactly like its &lt;b&gt;base class&lt;/b&gt;.</source>
          <target state="translated">空の&lt;b&gt;派生クラス&lt;/b&gt;は、&lt;b&gt;基本クラスと&lt;/b&gt;まったく同じように動作&lt;b&gt;する&lt;/b&gt;という概念。</target>
        </trans-unit>
        <trans-unit id="d26e84b13c8c8748080fe4085da63e6e9ef520f9" translate="yes" xml:space="preserve">
          <source>The notion that you can tell an &lt;b&gt;object&lt;/b&gt; to do something generic, and the object will interpret the command in different ways depending on its type. [&amp;lt; Greek &amp;pi;&amp;omicron;&amp;lambda;&amp;upsilon;- + &amp;mu;&amp;omicron;&amp;rho;ϕή, many forms.]</source>
          <target state="translated">&lt;b&gt;オブジェクト&lt;/b&gt;に一般的な&lt;b&gt;こと&lt;/b&gt;を行うように指示でき、オブジェクトはそのタイプに応じてさまざまな方法でコマンドを解釈するという概念。[&amp;lt;ギリシャ語&amp;pi;&amp;omicron;&amp;lambda;&amp;upsilon;-+ &amp;mu;&amp;omicron;&amp;rho;ϕή、多くの形。]</target>
        </trans-unit>
        <trans-unit id="ad272f88bed19c2e6cec366907b96e0baf112d7c" translate="yes" xml:space="preserve">
          <source>The notion that, with a complete set of simple tools that work well together, you can build almost anything you want. Which is fine if you&amp;rsquo;re assembling a tricycle, but if you&amp;rsquo;re building a defranishizing comboflux regurgalator, you really want your own machine shop in which to build special tools. Perl is sort of a machine shop.</source>
          <target state="translated">一緒に機能するシンプルなツールの完全なセットを使用して、ほぼすべてのものが構築できるという概念。三輪車を組み立てる場合はこれで問題ありませんが、逆説的なComboflux逆流防止装置を構築する場合は、特別なツールを構築する独自のマシンショップが本当に必要です。Perlは一種の機械工場です。</target>
        </trans-unit>
        <trans-unit id="d8cd6888cbc4c56537079a3ca6af05881fde2aca" translate="yes" xml:space="preserve">
          <source>The null filehandle &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is special: it can be used to emulate the behavior of &lt;b&gt;sed&lt;/b&gt; and &lt;b&gt;awk&lt;/b&gt;, and any other Unix filter program that takes a list of filenames, doing the same to each line of input from all of them. Input from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; comes either from standard input, or from each file listed on the command line. Here's how it works: the first time &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is evaluated, the &lt;code&gt;@ARGV&lt;/code&gt; array is checked, and if it is empty, &lt;code&gt;$ARGV[0]&lt;/code&gt; is set to &lt;code&gt;&quot;-&quot;&lt;/code&gt; , which when opened gives you standard input. The &lt;code&gt;@ARGV&lt;/code&gt; array is then processed as a list of filenames. The loop</source>
          <target state="translated">nullファイルハンドル &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; は特別です。これは、&lt;b&gt;sed&lt;/b&gt;および&lt;b&gt;awkの&lt;/b&gt;動作をエミュレートするために使用でき、ファイル名のリストを取得する他のすべてのUnixフィルタープログラムは、すべての入力の各行に対して同じことを行います。入力し &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; のいずれか、標準入力から、またはコマンドラインにリストされた各ファイルから来ています。動作方法は次のとおりです。 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; が初めて評価されるときに &lt;code&gt;@ARGV&lt;/code&gt; 配列がチェックされ、空の場合、 &lt;code&gt;$ARGV[0]&lt;/code&gt; が &lt;code&gt;&quot;-&quot;&lt;/code&gt; に設定されます。これにより、開いたときに標準入力が提供されます。 &lt;code&gt;@ARGV&lt;/code&gt; 配列は、その後、ファイル名のリストとして処理されます。ループ</target>
        </trans-unit>
        <trans-unit id="6d22af8d2b7cf7cf2c570f3f335ab2a750c99b68" translate="yes" xml:space="preserve">
          <source>The null list is represented by (). Interpolating it in a list has no effect. Thus ((),(),()) is equivalent to (). Similarly, interpolating an array with no elements is the same as if no array had been interpolated at that point.</source>
          <target state="translated">ヌルリストは()で表されます。これをリストで補間しても何の効果もありません。したがって、((),(),())は()と同等です。同様に,要素のない配列を補間することは,その時点で配列が補間されていないのと同じです.</target>
        </trans-unit>
        <trans-unit id="1797c45a73a5a87e1dcbfe3ceafa93cc5c4f9d01" translate="yes" xml:space="preserve">
          <source>The null loop times can be cached, the key being the number of rounds. The caching can be controlled using calls like these:</source>
          <target state="translated">ヌルループの回数をキャッシュすることができます。キャッシュは以下のような呼び出しで制御できます。</target>
        </trans-unit>
        <trans-unit id="c43d1fda274f03a112b4082e8056292b9c40d862" translate="yes" xml:space="preserve">
          <source>The number 0, the strings &lt;code&gt;'0'&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; , the empty list &lt;code&gt;()&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; are all false in a boolean context. All other values are true. Negation of a true value by &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; returns a special false value. When evaluated as a string it is treated as &lt;code&gt;&quot;&quot;&lt;/code&gt; , but as a number, it is treated as 0. Most Perl operators that return true or false behave this way.</source>
          <target state="translated">ブール値のコンテキストでは、数値0、文字列 &lt;code&gt;'0'&lt;/code&gt; および &lt;code&gt;&quot;&quot;&lt;/code&gt; 、空のリスト &lt;code&gt;()&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; はすべてfalseです。他のすべての値は真です。 &lt;code&gt;!&lt;/code&gt; による真の値の否定か &lt;code&gt;not&lt;/code&gt; 特殊な偽の値を返します。文字列として評価されると &lt;code&gt;&quot;&quot;&lt;/code&gt; として扱われますが、数値としては0として扱われます。trueまたはfalseを返すほとんどのPerl演算子はこのように動作します。</target>
        </trans-unit>
        <trans-unit id="692f2a5740e6be2f2f4c50b1195b7318b218c93b" translate="yes" xml:space="preserve">
          <source>The number after Perl (i.e. the 5 after Perl 5) is the major release of the perl interpreter as well as the version of the language. Each major version has significant differences that earlier versions cannot support.</source>
          <target state="translated">Perl の後の数字(つまり Perl 5 の後の 5)は、言語のバージョンと同様に perl インタプリタのメジャーリリースです。それぞれのメジャーバージョンには、それ以前のバージョンではサポートできない大きな違いがあります。</target>
        </trans-unit>
        <trans-unit id="3191b134cb3717b47b8c71b05a1d940752bad987" translate="yes" xml:space="preserve">
          <source>The number for the &quot;generation&quot; of the test run. The first generation is 1 (one) and subsequent generations are 2, 3, etc.</source>
          <target state="translated">テスト実行の「世代」を表す番号です。最初の世代は1(1)で、それ以降の世代は2、3などとなります。</target>
        </trans-unit>
        <trans-unit id="fa99ba7fda4b251af40087fa9ad0d33252bbd195" translate="yes" xml:space="preserve">
          <source>The number of concurrent jobs this formatter will handle.</source>
          <target state="translated">このフォーマッタが同時に処理するジョブの数。</target>
        </trans-unit>
        <trans-unit id="5d2ba45a48d3868e33de1ec7e956df019e81e42a" translate="yes" xml:space="preserve">
          <source>The number of elements in the array will be &lt;code&gt;fill + 1&lt;/code&gt; after av_fill() returns. If the array was previously shorter, then the additional elements appended are set to NULL. If the array was longer, then the excess elements are freed. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; is the same as &lt;code&gt;av_clear(av)&lt;/code&gt; .</source>
          <target state="translated">配列の要素数は、av_fill（）が返された後、 &lt;code&gt;fill + 1&lt;/code&gt; になります。以前に配列が短かった場合、追加された追加要素はNULLに設定されます。配列が長い場合、余分な要素は解放されます。 &lt;code&gt;av_fill(av, -1)&lt;/code&gt; は &lt;code&gt;av_clear(av)&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="b9161f7d8230483ece3123e0d04957cb7a945f72" translate="yes" xml:space="preserve">
          <source>The number of items in a hash can be obtained by doing:</source>
          <target state="translated">ハッシュに含まれる項目の数は、やることで取得できます。</target>
        </trans-unit>
        <trans-unit id="e4c9a33204f057eb951c01e0df7449caf0e7389f" translate="yes" xml:space="preserve">
          <source>The number of lines left on the page of the currently selected output channel.</source>
          <target state="translated">現在選択されている出力チャンネルのページに残された行数。</target>
        </trans-unit>
        <trans-unit id="8b661ef45c3e83256fc7a63d23f91b2343af29ac" translate="yes" xml:space="preserve">
          <source>The number of lines read previous to this one, plus 1. Perl keeps a separate line number for each source or input file it opens. The current source file&amp;rsquo;s line number is represented by &lt;code&gt;__LINE__&lt;/code&gt; . The current input line number (for the file that was most recently read via &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ) is represented by the &lt;code&gt;$.&lt;/code&gt; (&lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ) variable. Many error messages report both values, if available.</source>
          <target state="translated">これより前に読み取られた行数に1を加えた数。Perlは、オープンするソースまたは入力ファイルごとに個別の行番号を保持します。現在のソースファイルの行番号は &lt;code&gt;__LINE__&lt;/code&gt; で表されます。（ &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; を介して最後に読み取られたファイルの）現在の入力行番号は、 &lt;code&gt;$.&lt;/code&gt; 表されます。（ &lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ）変数。多くのエラーメッセージは、可能であれば両方の値を報告します。</target>
        </trans-unit>
        <trans-unit id="7adfc7b3eafb7c58d678ada0cc8dfa22b0798638" translate="yes" xml:space="preserve">
          <source>The number of seconds the program ran for before being terminated, or 0 if no timeout occurred.</source>
          <target state="translated">プログラムが終了する前に実行された秒数、タイムアウトが発生しなかった場合は0。</target>
        </trans-unit>
        <trans-unit id="701c3dee8ddb529dd17cdf0b20bfe4db85c06698" translate="yes" xml:space="preserve">
          <source>The number of spaces to indent regular text, and the default indentation for &lt;code&gt;=over&lt;/code&gt; blocks. Defaults to 4.</source>
          <target state="translated">通常のテキストをインデントするスペースの数、および &lt;code&gt;=over&lt;/code&gt; ブロックのデフォルトのインデント。デフォルトは4です。</target>
        </trans-unit>
        <trans-unit id="65eb3487d858db8bd02f6c81679897d6d005441b" translate="yes" xml:space="preserve">
          <source>The number of tests in your script. This means all ok() and skip() calls.</source>
          <target state="translated">スクリプト内のテストの数。これは、すべての ok()および skip()の呼び出しを意味します。</target>
        </trans-unit>
        <trans-unit id="c2e318858e274a3b2d56e4e8546a3453a590b339" translate="yes" xml:space="preserve">
          <source>The number of tests with TODO directives.</source>
          <target state="translated">TODOディレクティブを使ったテストの数。</target>
        </trans-unit>
        <trans-unit id="c43b06bec0238ed7c22fd0d6e38144c2bb8f0d70" translate="yes" xml:space="preserve">
          <source>The number of times the structure is referenced. When this falls to 0, the regexp is automatically freed by a call to pregfree. This should be set to 1 in each engine's &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; routine.</source>
          <target state="translated">構造が参照された回数。これが0になると、reggはpregfreeの呼び出しによって自動的に解放されます。これは、各エンジンの&lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt;ルーチンで1に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="c7aa069edb979af7f298ec7da8f6245a682e62f6" translate="yes" xml:space="preserve">
          <source>The number of times the test has failed.</source>
          <target state="translated">テストに失敗した回数です。</target>
        </trans-unit>
        <trans-unit id="f294a946b3a2f3d15985548e48a89b85b334300e" translate="yes" xml:space="preserve">
          <source>The number of times the test has passed.</source>
          <target state="translated">合格した回数です。</target>
        </trans-unit>
        <trans-unit id="6ecf3312d862847aadfe59c31f3bcfa85cc3016b" translate="yes" xml:space="preserve">
          <source>The numbering within each branch will be as normal, and any groups following this construct will be numbered as though the construct contained only one branch, that being the one with the most capture groups in it.</source>
          <target state="translated">各ブランチ内でのナンバリングは通常通りになり、この構成に続くグループは、構成が1つのブランチだけを含んでいるかのようにナンバリングされ、その中に最も多くのキャプチャグループが含まれています。</target>
        </trans-unit>
        <trans-unit id="d3f5b7856c836d8ae15bae5d2911f695737356ba" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigFloat. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">数値はオブジェクトとして保存され、その内部はいつでも、特に数学演算の間で変更される可能性があります。また、オブジェクトは Math::BigInt や Math::BigFloat のような異なるクラスに属しているかもしれません。通常のスカラーであっても、これらを混在させることは異常なことではなく、普通のことであり、期待されていることです。</target>
        </trans-unit>
        <trans-unit id="0d52076285e4f235f1d8532711b46d3578467720" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigInt::Lite. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">数値はオブジェクトとして保存され、その内部はいつでも、特に数学演算の間で変更される可能性があります。また、オブジェクトは Math::BigInt や Math::BigInt::Lite のように、異なるクラスに属しているかもしれません。通常のスカラーであっても、それらを混在させることは特別なことではなく、普通のことであり、期待されていることです。</target>
        </trans-unit>
        <trans-unit id="d62316f7524c3cde4e634f1fd21e7ac49fd46233" translate="yes" xml:space="preserve">
          <source>The numeric permissions mode to apply to each created directory (defaults to 0777), to be modified by the current &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;. If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="translated">作成された各ディレクトリに適用する数値権限モード（デフォルトは0777）。現在の &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; によって変更されます。ディレクトリが既に存在する（したがって、作成する必要がない）場合、アクセス許可は変更されません。</target>
        </trans-unit>
        <trans-unit id="41e019f9571f72909dc6712d8ba72dd87f1a9db6" translate="yes" xml:space="preserve">
          <source>The numeric value of the COP's hint flags, or an empty string if this is not a COP.</source>
          <target state="translated">COPのヒントフラグの数値、またはCOPでない場合は空文字列。</target>
        </trans-unit>
        <trans-unit id="419fea734cd75b36bfd625f906eafadf3594cbdf" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's flags.</source>
          <target state="translated">OPのフラグの数値。</target>
        </trans-unit>
        <trans-unit id="e13f8ed0a121e4b7f2050aa9d7bd9bd36bdb9772" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's private flags.</source>
          <target state="translated">OPのプライベートフラグの数値。</target>
        </trans-unit>
        <trans-unit id="afdb5b0bce9be5274063464faba90d66849c8cbe" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's targ.</source>
          <target state="translated">OPのタルグの数値。</target>
        </trans-unit>
        <trans-unit id="e4bd78ffa7c276231e5c09572ec79b0007d54b06" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's type, in decimal.</source>
          <target state="translated">OPの型の数値を10進数で表します。</target>
        </trans-unit>
        <trans-unit id="4a6a6fda3b81e72660dadfe40e0c6cbbf8b62d9b" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the reading end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">オブジェクトは &lt;code&gt;IO::Handle&lt;/code&gt; サブクラスに再度blessされ、パイプの読み取り端でハンドルになります。 &lt;code&gt;ARGS&lt;/code&gt; が指定されている場合、 &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; が呼び出され、 &lt;code&gt;ARGS&lt;/code&gt; がexecに渡されます。</target>
        </trans-unit>
        <trans-unit id="7b25df29627971e66202a04141c07ea01261d426" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the writing end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">オブジェクトは &lt;code&gt;IO::Handle&lt;/code&gt; サブクラスに再度blessされ、パイプの書き込み終了時にハンドルになります。 &lt;code&gt;ARGS&lt;/code&gt; が指定されている場合、 &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; が呼び出され、 &lt;code&gt;ARGS&lt;/code&gt; がexecに渡されます。</target>
        </trans-unit>
        <trans-unit id="40e63c161da60788dfbf25012eced379198e6461" translate="yes" xml:space="preserve">
          <source>The object or class on which a method is called is passed as one of the method's arguments, not as a separate &lt;code&gt;this&lt;/code&gt; value.</source>
          <target state="translated">メソッドが呼び出されるオブジェクトまたはクラスは、個別の &lt;code&gt;this&lt;/code&gt; 値としてではなく、メソッドの引数の1つとして渡されます。</target>
        </trans-unit>
        <trans-unit id="15b98c3fd23a1ef70ae8197a79094d62be1e4c5c" translate="yes" xml:space="preserve">
          <source>The object oriented interface to &lt;code&gt;Digest::MD5&lt;/code&gt; is described in this section. After a &lt;code&gt;Digest::MD5&lt;/code&gt; object has been created, you will add data to it and finally ask for the digest in a suitable format. A single object can be used to calculate multiple digests.</source>
          <target state="translated">このセクションでは、 &lt;code&gt;Digest::MD5&lt;/code&gt; へのオブジェクト指向インターフェースについて説明します。後 &lt;code&gt;Digest::MD5&lt;/code&gt; オブジェクトが作成されている、あなたはそれにデータを追加し、最終的に適切なフォーマットでダイジェストを要求します。単一のオブジェクトを使用して、複数のダイジェストを計算できます。</target>
        </trans-unit>
        <trans-unit id="e33be9a872157d87d04d9ab372ad71b851a50cce" translate="yes" xml:space="preserve">
          <source>The object registry is also used to repair a field hash after thread cloning. Here, the entire object registry is processed. For every reference found there, the field hashes it has used are visited and the entry is updated.</source>
          <target state="translated">オブジェクトレジストリは、スレッドクローニング後のフィールドハッシュを修復するためにも使用されます。ここでは、オブジェクトレジストリ全体が処理されます。そこで見つかったすべての参照について、それが使用したフィールドハッシュが訪問され、エントリが更新されます。</target>
        </trans-unit>
        <trans-unit id="90c880f65630ae33e5e929b9f5badc61ea20d016" translate="yes" xml:space="preserve">
          <source>The object registry keeps track of references that have been used as field hash keys. The keys are generated from the reference address like in a field hash (though the registry isn't a field hash). Each value is a weak copy of the original reference, stored in an &lt;code&gt;SV&lt;/code&gt; that is itself magical (&lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; again). The magical structure holds a list (another hash, really) of field hashes that the reference has been used with. When the weakref becomes stale, the magic is activated and uses the list to delete the reference from all field hashes it has been used with. After that, the entry is removed from the object registry itself. Implicitly, that frees the magic structure and the storage it has been using.</source>
          <target state="translated">オブジェクトレジストリは、フィールドハッシュキーとして使用された参照を追跡します。キーは、フィールドハッシュのように参照アドレスから生成されます（レジストリはフィールドハッシュではありません）。各値は元の参照の弱いコピーであり、それ自体が魔法の &lt;code&gt;SV&lt;/code&gt; に格納されます（再び &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; ）。魔法の構造は、参照が使用されたフィールドハッシュのリスト（実際には別のハッシュ）を保持します。 weakrefが古くなると、マジックがアクティブになり、リストを使用して、それが使用されたすべてのフィールドハッシュから参照を削除します。その後、エントリはオブジェクトレジストリ自体から削除されます。暗黙的に、それは魔法の構造とそれが使用していたストレージを解放します。</target>
        </trans-unit>
        <trans-unit id="d72391ab64988da73b0a894ff996ef426650aa27" translate="yes" xml:space="preserve">
          <source>The object returned by &lt;code&gt;builder()&lt;/code&gt; may change at runtime so you should call &lt;code&gt;builder()&lt;/code&gt; inside each function rather than store it in a global.</source>
          <target state="translated">&lt;code&gt;builder()&lt;/code&gt; によって返されるオブジェクトは実行時に変更される可能性があるため、グローバルに保存するのではなく、各関数内で &lt;code&gt;builder()&lt;/code&gt; を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="afec221431749f399e52c9677871688987dfbb46" translate="yes" xml:space="preserve">
          <source>The oct() function is commonly used when a string such as &lt;code&gt;644&lt;/code&gt; needs to be converted into a file mode, for example. Although Perl automatically converts strings into numbers as needed, this automatic conversion assumes base 10.</source>
          <target state="translated">oct（）関数は、たとえば &lt;code&gt;644&lt;/code&gt; などの文字列をファイルモードに変換する必要がある場合などによく使用されます。Perlは必要に応じて文字列を自動的に数値に変換しますが、この自動変換は基数10を想定しています。</target>
        </trans-unit>
        <trans-unit id="09c9c348da6207c41e75d17f6b539e26d9c4cd1f" translate="yes" xml:space="preserve">
          <source>The official (threaded) builds from HP, as they are shipped on the Application DVD/CD's are available on &lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&lt;/a&gt; for both PA-RISC and IPF (Itanium Processor Family). They are built with the HP ANSI-C compiler. Up till 5.8.8 that was done by ActiveState.</source>
          <target state="translated">アプリケーションDVD / CDで出​​荷されるHPの公式（スレッド）ビルドは、&lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http：//www.software.hp.com/portal/swdepot/displayProductInfo.do？&lt;/a&gt; productNumber = PERLで入手できます。両方のPA-RISCが対象です。およびIPF（Itanium Processor Family）。これらは、HP ANSI-Cコンパイラで構築されています。ActiveStateによって行われた5.8.8まで。</target>
        </trans-unit>
        <trans-unit id="122c2a7e4876853c52ff4c6bbc23491cac5b2166" translate="yes" xml:space="preserve">
          <source>The official forum for the development of perl is the perl5-porters mailing list, mentioned above, and its bugtracker at rt.perl.org. All participants in discussion there are expected to adhere to a standard of conduct.</source>
          <target state="translated">perl の開発のための公式フォーラムは、上述の perl5-porters メーリングリストと、rt.perl.org のバグトラッカーです。ここでの議論に参加するすべての人は、行動規範を守ることが期待されています。</target>
        </trans-unit>
        <trans-unit id="318a2a25e89f6df5d0fee0930895c69196eba39a" translate="yes" xml:space="preserve">
          <source>The official name of VMS as of this writing is OpenVMS.</source>
          <target state="translated">この記事を書いている時点でのVMSの正式名称はOpenVMSです。</target>
        </trans-unit>
        <trans-unit id="9e04119b1083995ffa8b809847e51388388f1606" translate="yes" xml:space="preserve">
          <source>The official web site for Berkeley DB is</source>
          <target state="translated">バークレーDBの公式サイトは</target>
        </trans-unit>
        <trans-unit id="065d987b91e5e5831e84ee6eb6792bbd1900fe0e" translate="yes" xml:space="preserve">
          <source>The old behaviour of immediate croaking can be re-instated by setting &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; to some &lt;code&gt;FALSE&lt;/code&gt; value.</source>
          <target state="translated">即時クローキングの古い動作は、 &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; を &lt;code&gt;FALSE&lt;/code&gt; 値に設定することで元に戻すことができます。</target>
        </trans-unit>
        <trans-unit id="5b386f850ac3d208fd4890f0e6e16aecfa5e9221" translate="yes" xml:space="preserve">
          <source>The old display format style, which can have values &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; or &lt;code&gt;&quot;polar&quot;&lt;/code&gt; , can be changed using the &lt;code&gt;&quot;style&quot;&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; または &lt;code&gt;&quot;polar&quot;&lt;/code&gt; の値を持つことができる古い表示形式スタイルは、 &lt;code&gt;&quot;style&quot;&lt;/code&gt; パラメータを使用して変更できます。</target>
        </trans-unit>
        <trans-unit id="e3404a80aca7096e4f7cc6df65a56468be124f24" translate="yes" xml:space="preserve">
          <source>The old form of gv_init_pvn(). It does not work with UTF8 strings, as it has no flags parameter. If the &lt;code&gt;multi&lt;/code&gt; parameter is set, the GV_ADDMULTI flag will be passed to gv_init_pvn().</source>
          <target state="translated">gv_init_pvn（）の古い形式。flagsパラメータがないため、UTF8文字列では機能しません。場合 &lt;code&gt;multi&lt;/code&gt; パラメータが設定されている、GV_ADDMULTIフラグ）（gv_init_pvnに渡されます。</target>
        </trans-unit>
        <trans-unit id="79188e84f37b880e4a772b5ff3206627de3b874e" translate="yes" xml:space="preserve">
          <source>The old home for the module tests, you shouldn't put anything new in here. There are still some bits and pieces hanging around in here that need to be moved. Perhaps you could move them? Thanks!</source>
          <target state="translated">モジュールテストのための古い家、あなたはここに新しいものを置くべきではありません。ここにはまだ移動させる必要のある断片が ぶら下がっています。おそらく、あなたはそれらを移動することができますか?ありがとう!</target>
        </trans-unit>
        <trans-unit id="37d530fbe2e5d190496e0bd800701dfa6c514e1c" translate="yes" xml:space="preserve">
          <source>The old package delimiter was a single quote, but double colon is now the preferred delimiter, in part because it's more readable to humans, and in part because it's more readable to &lt;b&gt;emacs&lt;/b&gt; macros. It also makes C++ programmers feel like they know what's going on--as opposed to using the single quote as separator, which was there to make Ada programmers feel like they knew what was going on. Because the old-fashioned syntax is still supported for backwards compatibility, if you try to use a string like &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; , you'll be accessing &lt;code&gt;$owner::s&lt;/code&gt; ; that is, the $s variable in package &lt;code&gt;owner&lt;/code&gt; , which is probably not what you meant. Use braces to disambiguate, as in &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; .</source>
          <target state="translated">古いパッケージ区切り文字は一重引用符でしたが、一部は人間が読みやすく、もう1つは&lt;b&gt;emacs&lt;/b&gt;マクロが読みやすいため、現在は二重コロンが優先区切り文字になっています。また、単一引用符を区切り文字として使用するのとは対照的に、C ++プログラマーは何が起こっているのかを理解できるようになります。これは、Adaプログラマーが何が起こっているのかを理解できるようにするためにありました。旧式の構文は下位互換性のために引き続きサポートされているため、 &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; ような文字列を使用しようとすると、 &lt;code&gt;$owner::s&lt;/code&gt; アクセスします。つまり、パッケージ &lt;code&gt;owner&lt;/code&gt; $ s変数です。これはおそらく意図したものではありません。 &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; ように、中括弧を使って曖昧さをなくします。</target>
        </trans-unit>
        <trans-unit id="e6c9fb581904d8c9128af585c935239bf8557de2" translate="yes" xml:space="preserve">
          <source>The older (and possibly obsolete) libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;</source>
          <target state="translated">古い（おそらく廃止された）ライブラリ&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt;、&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da753c735f79a0349646d5159490ba674b8d624f" translate="yes" xml:space="preserve">
          <source>The older libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod::SAX&lt;/a&gt;</source>
          <target state="translated">古いライブラリ&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt;、&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;、&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod :: SAX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="995ae7aa276ffe30824f52880be0efab53f1e92d" translate="yes" xml:space="preserve">
          <source>The one argument form of add_bits() takes a $bitstring of &quot;1&quot; and &quot;0&quot; chars as argument. It's a shorthand for &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;,
$bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; .</source>
          <target state="translated">add_bits（）の1つの引数形式は、引数として「1」と「0」の文字の$ bitstringを取ります。これは、 &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;, $bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; 省略形です。</target>
        </trans-unit>
        <trans-unit id="7fb0ed6067910ab4f7c54b4b88cf43df00178824" translate="yes" xml:space="preserve">
          <source>The one parameter calling convention also still works.</source>
          <target state="translated">1つのパラメータの呼び出し規則もまだ機能しています。</target>
        </trans-unit>
        <trans-unit id="80912f94b4001d6702c4a5ac8c13128730d9bdf7" translate="yes" xml:space="preserve">
          <source>The one user (apart from the superuser) who has absolute control over a &lt;b&gt;file&lt;/b&gt;. A file may also have a &lt;b&gt;group&lt;/b&gt; of users who may exercise joint ownership if the real owner permits it. See &lt;b&gt;permission bits&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;ファイルを&lt;/b&gt;完全に制御する1人のユーザー（スーパーユーザーを除く）。ファイルには、実際の所有者が許可した場合に共同所有権を行使できるユーザーの&lt;b&gt;グループ&lt;/b&gt;が含まれる場合もあります。&lt;b&gt;許可ビットを&lt;/b&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="bf794f433c5b5ee5b62cabad4f9e0efe662e76bb" translate="yes" xml:space="preserve">
          <source>The only absolutely mandatory method. Called when the layer is pushed onto the stack. The &lt;code&gt;mode&lt;/code&gt; argument may be NULL if this occurs post-open. The &lt;code&gt;arg&lt;/code&gt; will be non-&lt;code&gt;NULL&lt;/code&gt; if an argument string was passed. In most cases this should call &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; to convert &lt;code&gt;mode&lt;/code&gt; into the appropriate &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; flags in addition to any actions the layer itself takes. If a layer is not expecting an argument it need neither save the one passed to it, nor provide &lt;code&gt;Getarg()&lt;/code&gt; (it could perhaps &lt;code&gt;Perl_warn&lt;/code&gt; that the argument was un-expected).</source>
          <target state="translated">唯一必須の方法です。レイヤーがスタックにプッシュされたときに呼び出されます。 &lt;code&gt;mode&lt;/code&gt; このポスト開い発生した場合、引数がNULLかもしれません。 &lt;code&gt;arg&lt;/code&gt; は非なり &lt;code&gt;NULL&lt;/code&gt; 引数の文字列が渡された場合。ほとんどの場合、これは &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; を呼び出して、レイヤー自体が実行するアクションに加えて、 &lt;code&gt;mode&lt;/code&gt; を適切な &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; フラグに変換する必要があります。層が引数を期待していない場合、それはそれに渡されたものを保存する必要も、 &lt;code&gt;Getarg()&lt;/code&gt; を提供する必要もありません（おそらく引数が &lt;code&gt;Perl_warn&lt;/code&gt; しないことをPerl_warnする可能性があります）。</target>
        </trans-unit>
        <trans-unit id="8efd8a42e658c0f7e91c83e2d2d53f100f4033a8" translate="yes" xml:space="preserve">
          <source>The only differences are due to the fact that &lt;code&gt;string_vianame&lt;/code&gt; is run-time and &lt;code&gt;\N{}&lt;/code&gt; is compile time. You can't interpolate inside a &lt;code&gt;\N{}&lt;/code&gt; , (so &lt;code&gt;\N{$variable}&lt;/code&gt; doesn't work); and if the input name is unknown, &lt;code&gt;string_vianame&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of it being a syntax error.</source>
          <target state="translated">唯一の違いは、 &lt;code&gt;string_vianame&lt;/code&gt; がランタイムで、 &lt;code&gt;\N{}&lt;/code&gt; がコンパイル時間であるという事実によるものです。 &lt;code&gt;\N{}&lt;/code&gt; 内を補間することはできません（したがって、 &lt;code&gt;\N{$variable}&lt;/code&gt; は機能しません）。入力名が不明の場合、 &lt;code&gt;string_vianame&lt;/code&gt; は構文エラーではなく、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="341b8df1dab5c18fe08d27199395d7d12fe5908e" translate="yes" xml:space="preserve">
          <source>The only flag specified this time was G_SCALAR. That means that the &lt;code&gt;@_&lt;/code&gt; array will be created and that the value returned by</source>
          <target state="translated">今回指定された唯一のフラグはG_SCALARでした。つまり、 &lt;code&gt;@_&lt;/code&gt; 配列が作成され、返される値は</target>
        </trans-unit>
        <trans-unit id="1be9c07fcdeba873e922d933912b59d6dffd7f9b" translate="yes" xml:space="preserve">
          <source>The only interpolation is removal of &lt;code&gt;\&lt;/code&gt; from pairs of &lt;code&gt;\\&lt;/code&gt; . Therefore &lt;code&gt;&quot;-&quot;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; is treated literally as a hyphen and no character range is available. &lt;code&gt;\1&lt;/code&gt; in the replacement of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; does not work as &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">唯一の補間は、 &lt;code&gt;\\&lt;/code&gt; のペアから &lt;code&gt;\&lt;/code&gt; を削除することです。したがって、 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&quot;-&quot;&lt;/code&gt; は文字どおりハイフンとして扱われ、使用できる文字範囲はありません。 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; 置換における &lt;code&gt;\1&lt;/code&gt; は &lt;code&gt;$1&lt;/code&gt; として機能しません。</target>
        </trans-unit>
        <trans-unit id="12717cd3a47ff8f730f2ca2276f3a722ee0a85b7" translate="yes" xml:space="preserve">
          <source>The only issue left is to how to bootstrap</source>
          <target state="translated">唯一の問題は、どのようにブートストラップを行うかということです。</target>
        </trans-unit>
        <trans-unit id="77cda32153e2808e7ed17b43ef801a42c30a29bd" translate="yes" xml:space="preserve">
          <source>The only kind of simple statement is an expression evaluated for its side-effects. Every simple statement must be terminated with a semicolon, unless it is the final statement in a block, in which case the semicolon is optional. But put the semicolon in anyway if the block takes up more than one line, because you may eventually add another line. Note that there are operators like &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; that</source>
          <target state="translated">唯一の種類の単純なステートメントは、その副作用について評価される式です。ブロックの最後のステートメントである場合を除いて、すべての単純なステートメントはセミコロンで終了する必要があります。その場合、セミコロンはオプションです。ただし、ブロックが複数行を占める場合は、とにかくセミコロンを入れてください。最終的に別の行を追加する可能性があるためです。以下のような演算子があることに注意してください &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; 、と &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; その</target>
        </trans-unit>
        <trans-unit id="3f747c4ca5428591254eb88eeb68548667575b4e" translate="yes" xml:space="preserve">
          <source>The only legitimate use of this pragma is almost certainly just one per file, near the top, with file scope, as the file is likely going to only be written in one encoding. Further restrictions apply in Perls before v5.22 (see &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;Prior to Perl v5.22&lt;/a&gt;).</source>
          <target state="translated">このプラグマの唯一の合法的な使用法は、ファイルが1つのエンコーディングでのみ書き込まれる可能性が高いため、ほぼ確実に、ファイルスコープを使用して、ファイルごとに1つだけです。v5.22 &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;より前のPerlに&lt;/a&gt;は、さらに制限が適用されます（Perl以前のPerl v5.22を参照）。</target>
        </trans-unit>
        <trans-unit id="34c58516de1f8035b02dd5ba10465691170b3177" translate="yes" xml:space="preserve">
          <source>The only multi-byte (or wide character) locale that Perl is ever likely to support is UTF-8. This is due to the difficulty of implementation, the fact that high quality UTF-8 locales are now published for every area of the world (&lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt;), and that failing all that you can use the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module to translate to/from your locale. So, you'll have to do one of those things if you're using one of these locales, such as Big5 or Shift JIS. For UTF-8 locales, in Perls (pre v5.20) that don't have full UTF-8 locale support, they may work reasonably well (depending on your C library implementation) simply because both they and Perl store characters that take up multiple bytes the same way. However, some, if not most, C library implementations may not process the characters in the upper half of the Latin-1 range (128 - 255) properly under &lt;code&gt;LC_CTYPE&lt;/code&gt; . To see if a character is a particular type under a locale, Perl uses the functions like &lt;code&gt;isalnum()&lt;/code&gt; . Your C library may not work for UTF-8 locales with those functions, instead only working under the newer wide library functions like &lt;code&gt;iswalnum()&lt;/code&gt; , which Perl does not use. These multi-byte locales are treated like single-byte locales, and will have the restrictions described below. Starting in Perl v5.22 a warning message is raised when Perl detects a multi-byte locale that it doesn't fully support.</source>
          <target state="translated">Perlがサポートする可能性が高い唯一のマルチバイト（またはワイド文字）ロケールはUTF-8です。これは、実装の難しさ、高品質のUTF-8ロケールが世界中のすべての地域（&lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt;）で公開されていること、そしてあなたが失敗したことが原因です。&lt;a href=&quot;encode&quot;&gt;エンコード&lt;/a&gt;を使用できますロケールとの間で変換するモジュール。したがって、Big5やShift JISなど、これらのロケールのいずれかを使用している場合は、これらのいずれかを行う必要があります。 UTF-8ロケールの場合、完全なUTF-8ロケールをサポートしていないPerl（v5.20より前）では、CとPerlの両方が使用する文字を格納するだけなので、（Cライブラリの実装によっては）十分に機能する可能性があります。同じ方法で複数バイト。ただし、ほとんどではないにしても、一部のCライブラリの実装では、 &lt;code&gt;LC_CTYPE&lt;/code&gt; の下でLatin-1範囲の上半分（128〜255）の文字を適切に処理しない場合があります。ロケールで文字が特定のタイプかどうかを確認するために、Perlは &lt;code&gt;isalnum()&lt;/code&gt; のような関数を使用します。 Cライブラリは、これらの関数を含むUTF-8ロケールでは機能しない可能性があります。代わりに、次のような新しいワイドライブラリ関数でのみ機能します。 &lt;code&gt;iswalnum()&lt;/code&gt; 、Perlは使用しません。これらのマルチバイトロケールはシ​​ングルバイトロケールのように扱われ、以下に説明する制限があります。Perl v5.22以降では、Perlが完全にはサポートしていないマルチバイトロケールを検出すると、警告メッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="81ecbc2496d990405244fb5517f23afeb52e9228" translate="yes" xml:space="preserve">
          <source>The only non-character property that Perl currently supports is Named Sequences, in which a sequence of code points is given a name and generally treated as a single entity. (Perl supports these via the &lt;code&gt;\N{...}&lt;/code&gt; double-quotish construct, &lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames::string_vianame(name) in charnames&lt;/a&gt;, and &lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;namedseq() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Perlが現在サポートしている唯一の非文字プロパティは名前付きシーケンスです。この場合、コードポイントのシーケンスに名前が付けられ、通常は単一のエンティティとして扱われます。（Perlは、これらを &lt;code&gt;\N{...}&lt;/code&gt; 二重引用符構成、&lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames :: string_vianame（name）をcharnames&lt;/a&gt;で、&lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;namedseq（）をUnicode :: UCDでサポートします&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4392ba6f21132243d1d665e363dbf9f2d5cd7f44" translate="yes" xml:space="preserve">
          <source>The only non-single-byte locale Perl supports is (starting in v5.20) UTF-8. This means that code points above 255 are treated as Unicode no matter what locale is in effect (since UTF-8 implies Unicode).</source>
          <target state="translated">Perl がサポートしているシングルバイト以外のロケールは、(v5.20 以降では)UTF-8 のみです。つまり、255 以上のコードポイントは、どのロケールであっても Unicode として扱われます (UTF-8 は Unicode を意味するので)。</target>
        </trans-unit>
        <trans-unit id="9a67bc69297226e55a92fe7a2acd416579cf6146" translate="yes" xml:space="preserve">
          <source>The only objective benefit to using &lt;code&gt;DirHandle&lt;/code&gt; is that it avoids namespace pollution by creating globs to hold directory handles.</source>
          <target state="translated">&lt;code&gt;DirHandle&lt;/code&gt; を使用する唯一の客観的な利点は、ディレクトリハンドルを保持するグロブを作成することにより、ネームスペースの汚染を回避することです。</target>
        </trans-unit>
        <trans-unit id="29b92533d26d29124ecd17a1f17bcca141dd3115" translate="yes" xml:space="preserve">
          <source>The only other constraint is you must pre-declare how many tests you plan to run. This is in case something goes horribly wrong during the test and your test program aborts, or skips a test or whatever. You do this like so:</source>
          <target state="translated">他の唯一の制約は、実行する予定のテストの数を事前に宣言しなければならないことです。これは、テスト中に何かがひどくおかしくなり、テストプログラムが中断したり、テストをスキップしたりした場合に備えてのことです。このようにします。</target>
        </trans-unit>
        <trans-unit id="c629e4aca342ff5d679b1354d5badb624d786fd5" translate="yes" xml:space="preserve">
          <source>The only place where the warning is not raised when it might ought to have been is if optimizations cause the whole pattern match to not even be attempted. For example, Perl may figure out that for a string to match a certain regular expression pattern, the string has to contain the substring &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; . Before attempting the match, Perl may look for that substring, and if not found, immediately fail the match without actually trying it; so no warning gets generated even if the string contains an above-Unicode code point.</source>
          <target state="translated">本来あるべきときに警告が出されない唯一の場所は、最適化によってパターン全体の一致が試みられない場合です。たとえば、Perlは、文字列が特定の正規表現パターンに一致するためには、文字列に &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; というサブ文字列が含まれている必要があることを理解する場合があります。一致を試みる前に、Perlはその部分文字列を探し、見つからない場合は、実際に試行せずにすぐに一致に失敗します。そのため、文字列にUnicodeを超えるコードポイントが含まれていても、警告は生成されません。</target>
        </trans-unit>
        <trans-unit id="c7dc3eb2b3b66b20134df38443b06998c7b78e71" translate="yes" xml:space="preserve">
          <source>The only purpose of this step is to create the needed directories, and let you know the names of these directories. From the output you can see that the directory for the extension is</source>
          <target state="translated">このステップの唯一の目的は、必要なディレクトリを作成し、これらのディレクトリの名前を知らせることです。出力を見ると、拡張モジュールのディレクトリは</target>
        </trans-unit>
        <trans-unit id="8b743cce5d7490a9e24b6e3b1af9c9095cbf1cfd" translate="yes" xml:space="preserve">
          <source>The only required part is the first field, the name of a module (e.g. Foo::Bar, i.e.</source>
          <target state="translated">必須なのは最初のフィールド、モジュールの名前(例:Foo::Bar。</target>
        </trans-unit>
        <trans-unit id="a47d064470efbb85a4c64c4b51a76380fc85cda0" translate="yes" xml:space="preserve">
          <source>The only significant values for &lt;code&gt;flags&lt;/code&gt; are GV_SUPER and SVf_UTF8.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 重要な値はGV_SUPERとSVf_UTF8だけです。</target>
        </trans-unit>
        <trans-unit id="27c03514e890f7e1e455be24f92d8de38867990a" translate="yes" xml:space="preserve">
          <source>The only thing to note is that, in both the static and virtual methods, the method name is not passed via the stack--it is used as the first parameter to</source>
          <target state="translated">注意すべき点は、静的メソッドと仮想メソッドの両方において、メソッド名はスタック経由では渡されないということです。</target>
        </trans-unit>
        <trans-unit id="9a6d4c47eb4eb3548f61bca4b08d9e197f6e1287" translate="yes" xml:space="preserve">
          <source>The only thing you have to remember is that the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine</source>
          <target state="translated">覚えておく必要があるのは、 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; サブルーチン</target>
        </trans-unit>
        <trans-unit id="befc7f9200d677e41e635df70642f3120f18f3ee" translate="yes" xml:space="preserve">
          <source>The only things you need to declare in Perl are report formats and subroutines (and sometimes not even subroutines). A scalar variable holds the undefined value (&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) until it has been assigned a defined value, which is anything other than &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. When used as a number, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is treated as &lt;code&gt;0&lt;/code&gt; ; when used as a string, it is treated as the empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt; ; and when used as a reference that isn't being assigned to, it is treated as an error. If you enable warnings, you'll be notified of an uninitialized value whenever you treat &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as a string or a number. Well, usually. Boolean contexts, such as:</source>
          <target state="translated">Perlで宣言する必要があるのは、レポートのフォーマットとサブルーチン（場合によってはサブルーチンではない）だけです。スカラー変数は、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 以外の定義された値が割り当てられるまで、未定義の値（undef）を保持し &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。数値として使用すると、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;0&lt;/code&gt; として扱われます。文字列として使用すると、空の文字列 &lt;code&gt;&quot;&quot;&lt;/code&gt; として扱われます。割り当てられていない参照として使用すると、エラーとして扱われます。警告を有効にすると、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を文字列または数値として扱うときに、初期化されていない値が通知されます。まあ、通常。次のようなブールコンテキスト</target>
        </trans-unit>
        <trans-unit id="31db2a79cbb61c12ae686554ebaa8cf24c12eba8" translate="yes" xml:space="preserve">
          <source>The only times that you absolutely</source>
          <target state="translated">あなたが絶対に必要なのは</target>
        </trans-unit>
        <trans-unit id="cdb480d4e9cef712b05b3e3ca053bd2714b2800c" translate="yes" xml:space="preserve">
          <source>The only way to change this is to provide your own subroutine for &lt;code&gt;'|'&lt;/code&gt; .</source>
          <target state="translated">これを変更する唯一の方法は、 &lt;code&gt;'|'&lt;/code&gt; に独自のサブルーチンを提供することです 。</target>
        </trans-unit>
        <trans-unit id="c65da34730ca57e068ebb9d99972660fe1a63a25" translate="yes" xml:space="preserve">
          <source>The only way to override a lexical warnings setting is with the &lt;b&gt;-W&lt;/b&gt; or &lt;b&gt;-X&lt;/b&gt; command line flags.</source>
          <target state="translated">字句警告設定を上書きする唯一の方法は、&lt;b&gt;-W&lt;/b&gt;または&lt;b&gt;-X&lt;/b&gt;コマンドラインフラグを使用することです。</target>
        </trans-unit>
        <trans-unit id="cbd9c5131dd8145825db3c00e95fdf65545c95f3" translate="yes" xml:space="preserve">
          <source>The op tree is connected in two ways: you can imagine that there are two &quot;routes&quot; through it, two orders in which you can traverse the tree. First, parse order reflects how the parser understood the code, and secondly, execution order tells perl what order to perform the operations in.</source>
          <target state="translated">op ツリーは 2 つの方法で接続されています。第一に、解析順はパーサがどのようにコードを理解したかを反映し、第二に、実行順はどの順番で操作を実行するかをperlに伝えます。</target>
        </trans-unit>
        <trans-unit id="87587f650625db0a4ecb1818a87bdf007aa521f9" translate="yes" xml:space="preserve">
          <source>The op tree representing the code block is returned. This is always a real op, never a null pointer. It will normally be a &lt;code&gt;lineseq&lt;/code&gt; list, including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops. No ops to construct any kind of runtime scope are included by virtue of it being a block.</source>
          <target state="translated">コードブロックを表すopツリーが返されます。これは常に実際の操作であり、nullポインターではありません。これは通常、 &lt;code&gt;nextstate&lt;/code&gt; または同等の操作を含む &lt;code&gt;lineseq&lt;/code&gt; リストです。あらゆる種類のランタイムスコープを構築するための操作は、ブロックであるため含まれていません。</target>
        </trans-unit>
        <trans-unit id="0ada1b492ff1e32feecd23ad2e48d8b585f13df5" translate="yes" xml:space="preserve">
          <source>The op tree representing the expression is returned. If an optional expression is absent, a null pointer is returned, otherwise the pointer will be non-null.</source>
          <target state="translated">式を表すオペツリーが返されます。オプションの式が存在しない場合は null ポインタが返され、そうでない場合はポインタは non-null となります。</target>
        </trans-unit>
        <trans-unit id="b8ec717bc605b587bc78dee46e74bc74f77b59be" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be ops directly implementing the statement, suitable to pass to &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;. It will not normally include a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op (except for those embedded in a scope contained entirely within the statement).</source>
          <target state="translated">ステートメントを表すopツリーが返されます。ステートメントがnullの場合、たとえばそれが実際にサブルーチン定義（コンパイル時の副作用がある）である場合、これはnullポインタである可能性があります。nullでない場合、ステートメントを直接実装するopsとなり、&lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;に渡すのに適しています。通常、 &lt;code&gt;nextstate&lt;/code&gt; または同等のop は含まれません（ステートメント内に完全に含まれるスコープに埋め込まれたものを除く）。</target>
        </trans-unit>
        <trans-unit id="55a48ae410aca9d3fe9a16a19fa26233018ca671" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be the result of a &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt; call, normally including a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op.</source>
          <target state="translated">ステートメントを表すopツリーが返されます。ステートメントがnullの場合、たとえばそれが実際にサブルーチン定義（コンパイル時の副作用がある）である場合、これはnullポインタである可能性があります。nullでない場合は、通常、 &lt;code&gt;nextstate&lt;/code&gt; または同等のop を含む&lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;呼び出しの結果になります。</target>
        </trans-unit>
        <trans-unit id="80258368ca90132ffffe94b685646de5d3e0a9ff" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement sequence is returned. This may be a null pointer if the statements were all null, for example if there were no statements or if there were only subroutine definitions (which have compile-time side effects). If not null, it will be a &lt;code&gt;lineseq&lt;/code&gt; list, normally including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops.</source>
          <target state="translated">ステートメントシーケンスを表すopツリーが返されます。ステートメントがすべてnullの場合、たとえばステートメントがない場合、またはサブルーチン定義（コンパイル時の副作用がある）のみが存在する場合、これはnullポインターになる可能性があります。nullでない場合、通常は &lt;code&gt;nextstate&lt;/code&gt; または同等の操作を含む &lt;code&gt;lineseq&lt;/code&gt; リストになります。</target>
        </trans-unit>
        <trans-unit id="ee004e116194c04a5a9d3789b699d566539ba78d" translate="yes" xml:space="preserve">
          <source>The op-flags (ex &lt;b&gt;'sK/2'&lt;/b&gt;) are described in (&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;OP flags abbreviations&lt;/a&gt;).</source>
          <target state="translated">op-flags（ex &lt;b&gt;'sK / 2'&lt;/b&gt;）は（&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;OP flags abbreviations&lt;/a&gt;）で説明されています。</target>
        </trans-unit>
        <trans-unit id="8eec999d2cf9d026309d4e24a85ebd9a75290847" translate="yes" xml:space="preserve">
          <source>The open source license that Larry Wall created for Perl, maximizing Perl&amp;rsquo;s usefulness, availability, and modifiability. The current version is 2. (&lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt;).</source>
          <target state="translated">Larry WallがPerl用に作成したオープンソースライセンス。Perlの有用性、可用性、および変更可能性を最大化します。現在のバージョンは2です（&lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d076872f9624d7a17cf4c11c33523c71a8396f8e" translate="yes" xml:space="preserve">
          <source>The open2() function runs the given $cmd and connects $chld_out for reading and $chld_in for writing. It's what you think should work when you try</source>
          <target state="translated">open2()関数は与えられた$cmdを実行して、読み込みには$chld_out、書き込みには$chld_inを接続しています。を実行したときに動作するはずのものです。</target>
        </trans-unit>
        <trans-unit id="793bd01a6b2dc5e14b8e95bd14b22d7c8c213b3b" translate="yes" xml:space="preserve">
          <source>The operand of some types of regop is a literal string; for others, it is a regop leading into a sub-program. In particular, the operand of a &lt;code&gt;BRANCH&lt;/code&gt; node is the first regop of the branch.</source>
          <target state="translated">一部のタイプのregopのオペランドはリテラル文字列です。他の人にとっては、それはサブプログラムにつながるレゴです。特に、 &lt;code&gt;BRANCH&lt;/code&gt; ノードのオペランドは、ブランチの最初のレゴップです。</target>
        </trans-unit>
        <trans-unit id="cf8df21203ce7e715434391039cee96dd7ffc65d" translate="yes" xml:space="preserve">
          <source>The operating system, device drivers, C libraries, and Perl run-time system all conspire to let the programmer treat a single character (&lt;code&gt;\n&lt;/code&gt; ) as the line terminator, irrespective of external representation. On many operating systems, the native text file representation matches the internal representation, but on some platforms the external representation of &lt;code&gt;\n&lt;/code&gt; is made up of more than one character.</source>
          <target state="translated">オペレーティングシステム、デバイスドライバー、Cライブラリ、およびPerlランタイムシステムはすべて、外部表現に関係なく、プログラマーに単一の文字（ &lt;code&gt;\n&lt;/code&gt; ）を行末記号として処理させることを目的としています。多くのオペレーティングシステムでは、ネイティブテキストファイル表現は内部表現と一致しますが、一部のプラットフォームでは、 &lt;code&gt;\n&lt;/code&gt; 外部表現は複数の文字で構成されます。</target>
        </trans-unit>
        <trans-unit id="8c6975d92732aba7cc117877a890c8662a217abc" translate="yes" xml:space="preserve">
          <source>The operation of the &lt;code&gt;%ENV&lt;/code&gt; array depends on the translation of the logical name</source>
          <target state="translated">&lt;code&gt;%ENV&lt;/code&gt; 配列の操作は、論理名の変換に依存します</target>
        </trans-unit>
        <trans-unit id="1fcdc1a8281a2698369d4d0c5ac8331125832af5" translate="yes" xml:space="preserve">
          <source>The operation of the bval option warrants some discussion. Here is the definition of bval from the Berkeley DB 1.85 recno manual page:</source>
          <target state="translated">bval オプションの操作については、いくつかの議論が必要です。以下は、Berkeley DB 1.85 recno マニュアルページの bval の定義です。</target>
        </trans-unit>
        <trans-unit id="f8261c0231b653877a248b54abf80f0b93e9f204" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;archlibexp&lt;/code&gt; , &lt;code&gt;cccdlflags&lt;/code&gt; , &lt;code&gt;ccflags&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; , and &lt;code&gt;cc&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">このメソッドの操作は、 &lt;code&gt;Config.pm&lt;/code&gt; の &lt;code&gt;archlibexp&lt;/code&gt; 、 &lt;code&gt;cccdlflags&lt;/code&gt; 、 &lt;code&gt;ccflags&lt;/code&gt; 、 &lt;code&gt;optimize&lt;/code&gt; 、および &lt;code&gt;cc&lt;/code&gt; のエントリにも影響されます。</target>
        </trans-unit>
        <trans-unit id="1ea94336b097e013eb83f32bbba38514d8eaa887" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;lddlflags&lt;/code&gt; , &lt;code&gt;shrpenv&lt;/code&gt; , and &lt;code&gt;ld&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">このメソッドの操作は、 &lt;code&gt;Config.pm&lt;/code&gt; の &lt;code&gt;lddlflags&lt;/code&gt; 、 &lt;code&gt;shrpenv&lt;/code&gt; 、および &lt;code&gt;ld&lt;/code&gt; エントリにも影響されます。</target>
        </trans-unit>
        <trans-unit id="1cf8b3d14dd93250118a75dcead35353084d8d3c" translate="yes" xml:space="preserve">
          <source>The operations that are affected by locale are:</source>
          <target state="translated">ロケールの影響を受ける操作は</target>
        </trans-unit>
        <trans-unit id="4ea8be07a0890d457a63bbbdc0361b2f2a0630bf" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;not&lt;/code&gt; is not a valid key for &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; . However, if the operator &lt;code&gt;!&lt;/code&gt; is overloaded then the same implementation will be used for &lt;code&gt;not&lt;/code&gt; (since the two operators differ only in precedence).</source>
          <target state="translated">演算子 &lt;code&gt;not&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; を&lt;a href=&quot;functions/use&quot;&gt;使用する&lt;/a&gt;ための有効なキーではありません。ただし、演​​算子なら &lt;code&gt;!&lt;/code&gt; オーバーロードされている場合、同じ実装が使用され &lt;code&gt;not&lt;/code&gt; （2つの演算子は優先順位が異なるだけなので）。</target>
        </trans-unit>
        <trans-unit id="78cd830e88c435efad5c7c64c9421f0a7b44115d" translate="yes" xml:space="preserve">
          <source>The operator may be assigned to if both the 2nd and 3rd arguments are legal lvalues (meaning that you can assign to them):</source>
          <target state="translated">演算子は、第2引数と第3引数の両方が正規のl値であれば(代入できることを意味します)代入することができます。</target>
        </trans-unit>
        <trans-unit id="5904b513e41f7f0a3948a698bdf838835b48e7f3" translate="yes" xml:space="preserve">
          <source>The opname, as in &lt;b&gt;'add[t1]'&lt;/b&gt;, may be followed by op-specific information in parentheses or brackets (ex &lt;b&gt;'[t1]'&lt;/b&gt;).</source>
          <target state="translated">&lt;b&gt;'add [t1]'&lt;/b&gt;のようなopnameの後には、括弧または角括弧でop固有の情報を続けることができます（例：&lt;b&gt;'[t1]'&lt;/b&gt;）。</target>
        </trans-unit>
        <trans-unit id="18a01865affffe01d68458832d996fae1c28b752" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt;の反対。</target>
        </trans-unit>
        <trans-unit id="e8b12f229c6486073ad774a1dc49a9e1e9fe1afd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir()&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#catdir()&quot;&gt;catdir（）&lt;/a&gt;の反対です。</target>
        </trans-unit>
        <trans-unit id="cd5ab607bfc9b28a62d0ee095cfa34da1a0a1edd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;../spec#catdir&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../spec#catdir&quot;&gt;catdir（）&lt;/a&gt;の反対です。</target>
        </trans-unit>
        <trans-unit id="1ebefb2669972c85d8b9e00b79503067268d1b9d" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;catdir()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;catdir()&lt;/code&gt; の反対です。</target>
        </trans-unit>
        <trans-unit id="9058f904dc63789872dd9542a7b1316b89449f40" translate="yes" xml:space="preserve">
          <source>The opset and opset_to_ops functions can be used to convert from a list of operators to an opset and</source>
          <target state="translated">opset および opset_to_ops 関数を使用して、演算子のリストから opset および opset_to_ops に変換することができます。</target>
        </trans-unit>
        <trans-unit id="e0e7014b5567d7771bd0933f5acd1310aac22e0f" translate="yes" xml:space="preserve">
          <source>The optag name used must not be defined already (define_optag will croak if it is already defined). Optag names are global to the perl process and optag definitions cannot be altered or deleted once defined.</source>
          <target state="translated">使用するオプタグ名は、すでに定義されていてはいけません(define_optagはすでに定義されている場合には動作しません)。optag名はPerlプロセスのグローバルなものであり、一度定義されたoptagの定義を変更したり削除したりすることはできません。</target>
        </trans-unit>
        <trans-unit id="16ae99f8eb8c5eb6cf77bcb07b90faddacb6b646" translate="yes" xml:space="preserve">
          <source>The optimizer-specific information is used to avoid entering (a slow) regex engine on strings that will not definitely match. If the &lt;code&gt;isall&lt;/code&gt; flag is set, a call to the regex engine may be avoided even when the optimizer found an appropriate place for the match.</source>
          <target state="translated">オプティマイザ固有の情報は、完全に一致しない文字列で（低速の）正規表現エンジンに入らないようにするために使用されます。場合 &lt;code&gt;isall&lt;/code&gt; のフラグが設定されているオプティマイザは試合のために適切な場所を見つけた場合でも、正規表現エンジンへの呼び出しを回避することができます。</target>
        </trans-unit>
        <trans-unit id="c2bcebf69d65f38d819f2ef47d3870130b4b4a34" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and may be negated by prefixing it with &quot;no&quot; or &quot;no-&quot;. E.g. &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; will allow &lt;code&gt;--foo&lt;/code&gt; (a value of 1 will be assigned) as well as &lt;code&gt;--nofoo&lt;/code&gt; and &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; (a value of 0 will be assigned). If the option has aliases, this applies to the aliases as well.</source>
          <target state="translated">このオプションは引数を取らず、 &quot;no&quot;または &quot;no-&quot;を前に付けることで無効にすることができます。たとえば &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; 可能にする &lt;code&gt;--foo&lt;/code&gt; （1の値が割り当てられる）ならびに &lt;code&gt;--nofoo&lt;/code&gt; と &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; （0の値が割り当てられます）。オプションにエイリアスがある場合、これはエイリアスにも適用されます。</target>
        </trans-unit>
        <trans-unit id="05bc04ade0e6f0bfb276419b00c5f9d55f933117" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and will be incremented by 1 every time it appears on the command line. E.g. &lt;code&gt;&quot;more+&quot;&lt;/code&gt; , when used with &lt;code&gt;--more --more --more&lt;/code&gt;, will increment the value three times, resulting in a value of 3 (provided it was 0 or undefined at first).</source>
          <target state="translated">オプションは引数をとらず、コマンドラインに表示されるたびに1ずつ増加します。たとえば、 &lt;code&gt;&quot;more+&quot;&lt;/code&gt; を &lt;code&gt;--more --more --more&lt;/code&gt; と一緒に使用すると、値が3回インクリメントされ、値3になります（最初は0または未定義だった場合）。</target>
        </trans-unit>
        <trans-unit id="e6c73626524fd7b39cf23cb6ceb0594624a4560f" translate="yes" xml:space="preserve">
          <source>The option name as specified to the GetOptions() function is called the option</source>
          <target state="translated">GetOptions()関数に指定されたオプション名は、オプション</target>
        </trans-unit>
        <trans-unit id="28e883d6a03c91177fe93b06a907181312e7662a" translate="yes" xml:space="preserve">
          <source>The option names defined below are case insensitive and can be optionally prefixed by a '-'. So all of the following are valid</source>
          <target state="translated">以下に定義されているオプション名は大文字小文字を区別せず、オプションで '-' を接頭辞として付けることができます。したがって、以下のすべてが有効です。</target>
        </trans-unit>
        <trans-unit id="24d6abd722573e6cae42881df7cf4d56ac582b1b" translate="yes" xml:space="preserve">
          <source>The option requires an argument of the given type. Supported types are:</source>
          <target state="translated">このオプションは、指定された型の引数を必要とします。サポートされる型は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">オプションの</target>
        </trans-unit>
        <trans-unit id="3cb07c5a1f900e41d71b7af9007db9793c77a65e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;rules&lt;/code&gt; attribute provides direction on which tests should be run in parallel and which should be run sequentially. If no rule data structure is provided, a default data structure is used which makes every test eligible to be run in parallel:</source>
          <target state="translated">オプションの &lt;code&gt;rules&lt;/code&gt; 属性は、並行して実行するテストと順次実行するテストの方向を提供します。ルールデータ構造が提供されていない場合、デフォルトのデータ構造が使用され、すべてのテストを並行して実行できるようになります。</target>
        </trans-unit>
        <trans-unit id="0a173dcd400a0274b32b98f040a162b1b1782227" translate="yes" xml:space="preserve">
          <source>The optional arguments are considered as literal strings unless they start with &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt; , in which case they are interpreted as regular expressions (possibly negated).</source>
          <target state="translated">オプションの引数は、 &lt;code&gt;~&lt;/code&gt; または &lt;code&gt;!&lt;/code&gt; で始まらない限り、リテラル文字列と見なされます。、その場合、それらは正規表現として解釈されます（おそらく否定されます）。</target>
        </trans-unit>
        <trans-unit id="a213bd4ecadb16ed12c21fa427d78bb53fa09a37" translate="yes" xml:space="preserve">
          <source>The options listed above customize parts of the default header, but setting &lt;code&gt;html_header&lt;/code&gt; or &lt;code&gt;html_footer&lt;/code&gt; completely overrides the built-in header or footer. These may be useful if you want to use template tags instead of literal HTML headers and footers or are integrating converted POD pages in a larger website.</source>
          <target state="translated">上記のオプションはデフォルトのヘッダーの一部をカスタマイズしますが、 &lt;code&gt;html_header&lt;/code&gt; または &lt;code&gt;html_footer&lt;/code&gt; を設定すると、組み込みのヘッダーまたはフッターが完全に上書きされます。これらは、リテラルHTMLヘッダーおよびフッターの代わりにテンプレートタグを使用する場合、または変換されたPODページをより大きなWebサイトに統合する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="73d081dbc5fcc08b3b44f6576034c6838b070bec" translate="yes" xml:space="preserve">
          <source>The options to this argument is a list of either directories that are searched recursively, or files. (Usually you wouldn't specify files, but just dirs.) Or you can just specify an empty-list, as in $name2path; with the &lt;code&gt;inc&lt;/code&gt; option on, as it is by default.</source>
          <target state="translated">この引数のオプションは、再帰的に検索されるディレクトリまたはファイルのリストです。（通常、ファイルは指定せず、dirsのみを指定します。）または、$ name2pathのように、空のリストを指定することもできます。デフォルトでは、 &lt;code&gt;inc&lt;/code&gt; オプションをオンにします。</target>
        </trans-unit>
        <trans-unit id="f0865be52cedbd9c729cf95a5b09eba31832648b" translate="yes" xml:space="preserve">
          <source>The optree is shared between threads. This means there is a possibility that the optree will outlive the particular thread (and therefore the interpreter instance) that created it, so true Perl scalars cannot be stored in the optree. Instead a compact form is used, which can only store values that are integers (signed and unsigned), strings or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; - references and floating point values are stringified. If you need to store multiple values or complex structures, you should serialise them, for example with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;. The deletion of a hash key from &lt;code&gt;%^H&lt;/code&gt; is recorded, and as ever can be distinguished from the existence of a key with value &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">optreeはスレッド間で共有されます。これは、optreeがそれを作成した特定のスレッド（したがってインタープリターインスタンス）よりも長く存続する可能性があるため、真のPerlスカラーをoptreeに格納できないことを意味します。代わりにコンパクトな形式が使用され、整数（符号付きおよび符号なし）、文字列、または &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; の値のみを格納できます。参照と浮動小数点値は文字列化されます。複数の値または複雑な構造を格納する必要がある場合は、たとえば &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; を使用してそれらをシリアル化する必要があります。ハッシュキーの削除 &lt;code&gt;%^H&lt;/code&gt; 記録され、これまでのように値を持つキーの存在を区別することができる &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を持つ &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96c80c62d3615e8dcdce9b967100a640447d19ae" translate="yes" xml:space="preserve">
          <source>The order in which objects are destroyed during the global destruction before the program exits is unpredictable. This means that any objects contained by your object may already have been destroyed. You should check that a contained object is defined before calling a method on it:</source>
          <target state="translated">プログラムが終了する前のグローバル破壊の間にオブジェクトが破壊される順序は予測できません。つまり、あなたのオブジェクトに含まれるオブジェクトはすでに破壊されている可能性があります。含まれているオブジェクトが定義されているかどうかは、そのオブジェクトに対してメソッドを呼び出す前に確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="1362f44821baf70a0c53e26c223d4e933d506d90" translate="yes" xml:space="preserve">
          <source>The order in which this test was run for the given test suite result.</source>
          <target state="translated">与えられたテストスイートの結果に対して、このテストが実行された順番。</target>
        </trans-unit>
        <trans-unit id="49bfec1872d74cc3aa3b51bdca30781b5d81ee87" translate="yes" xml:space="preserve">
          <source>The order into which &lt;b&gt;characters&lt;/b&gt; sort. This is used by &lt;b&gt;string&lt;/b&gt; comparison routines to decide, for example, where in this glossary to put &amp;ldquo;collating sequence&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;文字が&lt;/b&gt;ソートされる順序。これは&lt;b&gt;文字列&lt;/b&gt;比較ルーチンで使用され、たとえば、この用語集のどこに「照合順序」を置くかを決定します。</target>
        </trans-unit>
        <trans-unit id="717cecbd54045d9533e4eb5b41c7c271d10ce913" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open2().</source>
          <target state="translated">引数の順番は open2()とは異なります。</target>
        </trans-unit>
        <trans-unit id="1338c98402171198f17cc3c818e89af7db3bfea3" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open3().</source>
          <target state="translated">引数の順番は open3()とは異なります。</target>
        </trans-unit>
        <trans-unit id="e57a83be29caa0cba0eac2c66aec01c8ecc059c8" translate="yes" xml:space="preserve">
          <source>The ordering is the same as for the regular expression which is the result of EXPR, or the pattern contained by capture group</source>
          <target state="translated">順番は、EXPRの結果である正規表現や、キャプチャグループに含まれるパターンと同じです。</target>
        </trans-unit>
        <trans-unit id="0f9c7f78b473deec8b2b7b3c5ae964aaebd4ae76" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;MD5&lt;/code&gt; interface was written by Neil Winton (&lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ).</source>
          <target state="translated">オリジナルの &lt;code&gt;MD5&lt;/code&gt; インターフェースはNeil Winton（ &lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ）によって書かれました。</target>
        </trans-unit>
        <trans-unit id="7eb97de2fdb41a38605a8a09e6520652a52c56e7" translate="yes" xml:space="preserve">
          <source>The original Dylan paper</source>
          <target state="translated">ディランの原紙</target>
        </trans-unit>
        <trans-unit id="af612d63faee2dc3856c86fd5cc671079598e557" translate="yes" xml:space="preserve">
          <source>The original Pod::Text contained code to do formatting via termcap sequences, although it wasn't turned on by default and it was problematic to get it to work at all. This rewrite doesn't even try to do that, but a subclass of it does. Look for &lt;a href=&quot;text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">元のPod :: Textには、termcapシーケンスを介してフォーマットを行うコードが含まれていましたが、デフォルトではオンになっておらず、まったく機能させるのに問題がありました。この書き直しはそれを実行しようとさえしませんが、そのサブクラスはそうしようとします。&lt;a href=&quot;text/termcap&quot;&gt;Pod :: Text :: Termcapを&lt;/a&gt;探します。</target>
        </trans-unit>
        <trans-unit id="07dd5b1a0e82d303f2b0b28746eab063467b6ba7" translate="yes" xml:space="preserve">
          <source>The original UTF-8 specification allowed up to 6 bytes, to allow encoding of numbers up to &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; . Perl continues to allow those, and has extended that up to 13 bytes to encode code points up to what can fit in a 64-bit word. However, Perl will warn if you output any of these as being non-portable; and under strict UTF-8 input protocols, they are forbidden.</source>
          <target state="translated">元のUTF-8仕様では最大6バイトが許可され、最大 &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; の数値のエンコードが可能でした。Perlはそれらを引き続き許可し、コードポイントを64ビットワードに収まる範囲までエンコードするように最大13バイトまで拡張しました。ただし、これらのいずれかを移植できないものとして出力すると、Perlは警告します。厳密なUTF-8入力プロトコルでは、これらは禁止されています。</target>
        </trans-unit>
        <trans-unit id="a0e54c9386e1df6efdb32bc51b43d382c1fa2bb3" translate="yes" xml:space="preserve">
          <source>The original culture of the pre-populist Internet and the deeply-held beliefs of Perl's author, Larry Wall, gave rise to the free and open distribution policy of Perl. Perl is supported by its users. The core, the standard Perl library, the optional modules, and the documentation you're reading now were all written by volunteers.</source>
          <target state="translated">ポピュリスト以前のインターネットの独自の文化と、Perlの作者であるラリー・ウォールの深い信念が、Perlの自由でオープンな配布ポリシーを生み出しました。Perlはユーザによってサポートされています。コア、標準のPerlライブラリ、オプションのモジュール、そして今読んでいるドキュメントはすべてボランティアによって書かれたものです。</target>
        </trans-unit>
        <trans-unit id="124cee86525fe9ae3fd7e1b40184ae6b8c5be548" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt;, which passes it the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; flag for backward-compatibility.</source>
          <target state="translated">後方互換性のために &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; フラグを渡す&lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt;の元の形式。</target>
        </trans-unit>
        <trans-unit id="03b164c5369f7a3512c3a8ff6e7ba584a97c85cb" translate="yes" xml:space="preserve">
          <source>The original format of CPAN Meta files was &lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML&lt;/a&gt; and the corresponding file was called</source>
          <target state="translated">CPANメタファイルの元の形式は&lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML&lt;/a&gt;で、対応するファイルが呼び出されました</target>
        </trans-unit>
        <trans-unit id="3411d71283c2f07e45c5a35c0fcbe60c51f6b9bb" translate="yes" xml:space="preserve">
          <source>The original purpose of source filters was to let you encrypt your program source to prevent casual piracy. This isn't all they can do, as you'll soon learn. But first, the basics.</source>
          <target state="translated">ソースフィルタの本来の目的は、プログラムのソースを暗号化して海賊版を防ぐことでした。すぐにわかるように、これだけではありません。しかし、まず基本的なことを説明します。</target>
        </trans-unit>
        <trans-unit id="a310ea971545c067e472063428469fc1fad9aa30" translate="yes" xml:space="preserve">
          <source>The original stack mark for the XSUB. See &lt;code&gt;dORIGMARK&lt;/code&gt; .</source>
          <target state="translated">XSUBの元のスタックマーク。 &lt;code&gt;dORIGMARK&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="d9fdbd5653ee6341eabe4730cc34935e3db7a992" translate="yes" xml:space="preserve">
          <source>The original style uses blanks and hyphens in the block names (except for &lt;code&gt;No_Block&lt;/code&gt; ), like so:</source>
          <target state="translated">元のスタイルでは、次のように、ブロック名に空白とハイフンを使用しています（ &lt;code&gt;No_Block&lt;/code&gt; を除く）。</target>
        </trans-unit>
        <trans-unit id="8dcbc33a95cd67473b45a522488fc8cc805a4f47" translate="yes" xml:space="preserve">
          <source>The original title was</source>
          <target state="translated">元のタイトルは</target>
        </trans-unit>
        <trans-unit id="7ea4b9a6cd75e55515170d81fe9ec6a923c1c00a" translate="yes" xml:space="preserve">
          <source>The original version of B::Terse was written by Malcolm Beattie, &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;. This wrapper was written by Stephen McCamant, &amp;lt;smcc@MIT.EDU&amp;gt;.</source>
          <target state="translated">B :: Terseのオリジナルバージョンは、Malcolm Beattie &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;によって作成されました。このラッパーは、Stephen McCamant &amp;lt;smcc@MIT.EDU&amp;gt;によって書かれました。</target>
        </trans-unit>
        <trans-unit id="ba66fcf36669927e93622e0a65ee5e2d5c9bffdb" translate="yes" xml:space="preserve">
          <source>The original version of PA-RISC, HP no longer sells any system with this chip.</source>
          <target state="translated">PA-RISCのオリジナル版、HPはこのチップを搭載したシステムを販売しなくなりました。</target>
        </trans-unit>
        <trans-unit id="0705420ac769cdd445f5fb673329007ec7bccb68" translate="yes" xml:space="preserve">
          <source>The original version of this article originally appeared in The Perl Journal #10, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and The Perl Journal. This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">この記事の原版は The Perl Journal #10 に掲載されたもので、著作権は 1998 The Perl Journal にあります。Jon Orwant と The Perl Journal の提供によるものです。この文書は Perl 自体と同じ条件で配布することができます。</target>
        </trans-unit>
        <trans-unit id="9009e0d18f1d5f332e2819aa4a5b08efaa84ba15" translate="yes" xml:space="preserve">
          <source>The original was written by Andy Dougherty</source>
          <target state="translated">原作はアンディ・ドハティ</target>
        </trans-unit>
        <trans-unit id="ac8cde9199e82022f2799533159dbf659a64016b" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;OA_*&lt;/code&gt; constants should not be used.</source>
          <target state="translated">その他の &lt;code&gt;OA_*&lt;/code&gt; 定数は使用しないでください。</target>
        </trans-unit>
        <trans-unit id="e99c9d2a05f195a52a6e3dccd804ac6a0edaa601" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; methods are meant to be called only once per &lt;code&gt;$parser&lt;/code&gt; object; but &lt;code&gt;parse_lines&lt;/code&gt; can be called as many times per &lt;code&gt;$parser&lt;/code&gt; object as you want, as long as the last call (and only the last call) ends with an &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">他の &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; 方法をごとに一度だけ呼ばれるように意図されている &lt;code&gt;$parser&lt;/code&gt; オブジェクト。ただし、最後の呼び出し（および最後の呼び出しのみ）が &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 値で終わる限り、 &lt;code&gt;parse_lines&lt;/code&gt; は &lt;code&gt;$parser&lt;/code&gt; オブジェクトごとに何度でも呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="f0806e4bd09cd5bd6dbaceaf9c0baff74d032490" translate="yes" xml:space="preserve">
          <source>The other arguments should look familiar if you know &lt;code&gt;STORABLE_freeze&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;STORABLE_freeze&lt;/code&gt; を知っている場合、他の引数はおなじみのはずです。</target>
        </trans-unit>
        <trans-unit id="407b63c5d1d6303ca3afdf08c491fa75e0221db1" translate="yes" xml:space="preserve">
          <source>The other big problem with &lt;code&gt;$^W&lt;/code&gt; is the way you can inadvertently change the warning setting in unexpected places in your code. For example, when the code below is run (without the &lt;b&gt;-w&lt;/b&gt; flag), the second call to &lt;code&gt;doit&lt;/code&gt; will trip a &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; warning, whereas the first will not.</source>
          <target state="translated">&lt;code&gt;$^W&lt;/code&gt; つの大きな問題は、コードの予期しない場所で警告設定を誤って変更してしまう可能性があることです。たとえば、次のコードが実行されると（&lt;b&gt;-w&lt;/b&gt;フラグなしで）、 &lt;code&gt;doit&lt;/code&gt; への2番目の呼び出しは、 &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; 警告をトリップしますが、最初の呼び出しはトリップしません。</target>
        </trans-unit>
        <trans-unit id="fc649a384c23c44b5ba2efe0b85df4a20e6ec321" translate="yes" xml:space="preserve">
          <source>The other cases require a little bit more convoluted procedures. Below I suppose that the current version of Perl is &lt;code&gt;5.8.2&lt;/code&gt; , so the executables are named accordingly.</source>
          <target state="translated">他のケースでは、もう少し複雑な手順が必要です。以下では、Perlの現在のバージョンは &lt;code&gt;5.8.2&lt;/code&gt; であるため、実行可能ファイルにはそれに応じた名前が付けられています。</target>
        </trans-unit>
        <trans-unit id="c457b75f143400140761950573f5b842848c756c" translate="yes" xml:space="preserve">
          <source>The other counterpart, in the column labelled &quot;Full-range Unicode&quot;, matches any appropriate characters in the full Unicode character set. For example, &lt;code&gt;\p{Alpha}&lt;/code&gt; matches not just the ASCII alphabetic characters, but any character in the entire Unicode character set considered alphabetic. An entry in the column labelled &quot;backslash sequence&quot; is a (short) equivalent.</source>
          <target state="translated">「フルレンジUnicode」というラベルの付いた列にあるもう一方は、完全なUnicode文字セットの適切な文字と一致します。たとえば、 &lt;code&gt;\p{Alpha}&lt;/code&gt; は、ASCIIアルファベット文字だけでなく、アルファベット文字と見なされるUnicode文字セット全体の任意の文字に一致します。「バックスラッシュシーケンス」というラベルの付いた列のエントリは、（短い）同等のものです。</target>
        </trans-unit>
        <trans-unit id="ece66aa413156fc84b73d204d2d9bbbf0fe1c18a" translate="yes" xml:space="preserve">
          <source>The other hack is to restore FP flags after a call to dlopen(). This helps against similar damage done by DLLs _DLLInitTerm() at runtime. Currently no way to switch these hacks off is provided.</source>
          <target state="translated">もう一つのハックは、dlopen()の呼び出し後にFPフラグを復元することです。これは DLL の _DLLInitTerm()が実行時に行う同様のダメージを防ぐのに役立ちます。現在のところ、これらのハックを無効にする方法は提供されていません。</target>
        </trans-unit>
        <trans-unit id="9303fbfd8a21fb685b416cbb44c3a447eed84853" translate="yes" xml:space="preserve">
          <source>The other is to install the module in a temporary location.</source>
          <target state="translated">もう一つは、モジュールを一時的に設置することです。</target>
        </trans-unit>
        <trans-unit id="7370aa653e76af4b47e0ca0cfb340c944499961e" translate="yes" xml:space="preserve">
          <source>The other modification made is that</source>
          <target state="translated">その他の修正点としては</target>
        </trans-unit>
        <trans-unit id="52e0e078ed7f59ceb7388f298d1ea1da0c3bdb08" translate="yes" xml:space="preserve">
          <source>The other reason why using a variable to hold the name of another variable is a bad idea is that the question often stems from a lack of understanding of Perl data structures, particularly hashes. By using symbolic references, you are just using the package's symbol-table hash (like &lt;code&gt;%main::&lt;/code&gt; ) instead of a user-defined hash. The solution is to use your own hash or a real reference instead.</source>
          <target state="translated">変数を使用して別の変数の名前を保持することの悪いもう1つの理由は、Perlのデータ構造（特にハッシュ）が理解されていないことが原因であることが多いためです。シンボリック参照を使用することにより、ユーザー定義のハッシュの代わりに、パッケージのシンボルテーブルハッシュ（ &lt;code&gt;%main::&lt;/code&gt; ）を使用しているだけです。解決策は、代わりに独自のハッシュまたは実際の参照を使用することです。</target>
        </trans-unit>
        <trans-unit id="5743b7f731fc10e9d1778f5bba7c58560baf6a5c" translate="yes" xml:space="preserve">
          <source>The other structure is pointed to by the &lt;code&gt;regexp&lt;/code&gt; struct's &lt;code&gt;pprivate&lt;/code&gt; and is in addition to &lt;code&gt;intflags&lt;/code&gt; in the same struct considered to be the property of the regex engine which compiled the regular expression;</source>
          <target state="translated">もう1つの構造は、 &lt;code&gt;regexp&lt;/code&gt; 構造体の &lt;code&gt;pprivate&lt;/code&gt; によって &lt;code&gt;intflags&lt;/code&gt; れ、同じ構造体のintflagsに加えて、正規表現をコンパイルしたregexエンジンのプロパティと見なされます。</target>
        </trans-unit>
        <trans-unit id="5b612d86c256526a7120d0f540436c62b7f8f79b" translate="yes" xml:space="preserve">
          <source>The other synchronization primitives described below can suffer from similar problems.</source>
          <target state="translated">以下に説明する他の同期化プリミティブは、同様の問題に苦しむことがある。</target>
        </trans-unit>
        <trans-unit id="a811a8ea9dab8327d772322e2e441ab82ca0e86f" translate="yes" xml:space="preserve">
          <source>The output field separator for the print operator. If defined, this value is printed between each of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">印刷オペレーターの出力フィールド区切り記号。定義されている場合、この値は各printの引数の間に出力されます。デフォルトは &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4e6a9347f20222b252ad3782a91c8dbdeaeb1ab5" translate="yes" xml:space="preserve">
          <source>The output file to print to. If the special names &quot;-&quot; or &quot;&amp;gt;&amp;amp;1&quot; or &quot;&amp;gt;&amp;amp;STDOUT&quot; are used then standard output is used. If &quot;&amp;gt;&amp;amp;2&quot; or &quot;&amp;gt;&amp;amp;STDERR&quot; is used then standard error is used.</source>
          <target state="translated">印刷先の出力ファイル。特殊な名前「-」、「&amp;gt;＆1」、「&amp;gt;＆STDOUT」を使用すると、標準出力が使用されます。&quot;&amp;gt;＆2&quot;または &quot;&amp;gt;＆STDERR&quot;を使用すると、標準エラーが使用されます。</target>
        </trans-unit>
        <trans-unit id="cf7f158841e06623182985de04b67d3455d986ee" translate="yes" xml:space="preserve">
          <source>The output files are placed in the hierarchy rooted at Perl's architecture dependent library directory. You can specify a different hierarchy with a &lt;b&gt;-d&lt;/b&gt; switch.</source>
          <target state="translated">出力ファイルは、Perlのアーキテクチャ依存ライブラリディレクトリをルートとする階層に配置されます。&lt;b&gt;-d&lt;/b&gt;スイッチで別の階層を指定できます。</target>
        </trans-unit>
        <trans-unit id="5d7376e07f79489cad7f31d1cda9c5ba04d798cb" translate="yes" xml:space="preserve">
          <source>The output format is governed by multiple options described under &lt;a href=&quot;#Configurable-Options&quot;&gt;Configurable Options&lt;/a&gt;.</source>
          <target state="translated">出力形式は、「&lt;a href=&quot;#Configurable-Options&quot;&gt;構成可能なオプション」で&lt;/a&gt;説明されている複数のオプションによって管理されます。</target>
        </trans-unit>
        <trans-unit id="99376109c851932f74197e279ea101a89b6befe6" translate="yes" xml:space="preserve">
          <source>The output format of a &lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt; is determined by an earlier format declaration (&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;), so whether or not the output is affected by locale is determined by if the &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; is within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , not whether the &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; is.</source>
          <target state="translated">&lt;a href=&quot;functions/write&quot;&gt;書き込み&lt;/a&gt;の出力形式は以前の形式宣言（&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;）によって決定されるため、出力がロケールの影響を受けるかどうかは、 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; かどうかではなく、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; スコープ内にあるかどうかによって決定されます。です。</target>
        </trans-unit>
        <trans-unit id="821335e2d4cef7b064fd271a1052ad49bb811014" translate="yes" xml:space="preserve">
          <source>The output from an XSUB which uses something like the T_PTRREF map, which doesn't bless the object, might look something like this:</source>
          <target state="translated">オブジェクトを祝福しないT_PTRREFマップのようなものを使うXSUBからの出力は、次のようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="0f57dea9a1d29f634f6f112b3d23937584062d88" translate="yes" xml:space="preserve">
          <source>The output from that will be</source>
          <target state="translated">そこからの出力は</target>
        </trans-unit>
        <trans-unit id="489ef92ce8f286ef5d6d82e8d178af124ae1bd61" translate="yes" xml:space="preserve">
          <source>The output is untainted. If you don't know what tainting is, don't worry about it.</source>
          <target state="translated">汚れていない状態で出力されます。染色がわからない方は気にしないでください。</target>
        </trans-unit>
        <trans-unit id="74b4c8cfc7182db2977001aba6ce4cd0c9c3eff4" translate="yes" xml:space="preserve">
          <source>The output line can be used as a template in a &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; call:</source>
          <target state="translated">出力行は、 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 呼び出しのテンプレートとして使用できます。</target>
        </trans-unit>
        <trans-unit id="628776c99f7feeea9f3047213f9a74832f55bae9" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;uname -a&lt;/code&gt; if available, otherwise the hostname. The whole thing is then lower-cased and slashes and single quotes are removed.</source>
          <target state="translated">使用可能な場合は &lt;code&gt;uname -a&lt;/code&gt; の出力、それ以外の場合はホスト名。次に、全体が小文字になり、スラッシュと単一引用符が削除されます。</target>
        </trans-unit>
        <trans-unit id="b50cc56cf670c43f6be20602b16c39970c70b1a0" translate="yes" xml:space="preserve">
          <source>The output record separator for the print operator. If defined, this value is printed after the last of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">印刷オペレーターの出力レコード分離文字。定義されている場合、この値は、printの最後の引数の後に印刷されます。デフォルトは &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8366e38dbe1255a05a31be8b8ca8cff24bae31ce" translate="yes" xml:space="preserve">
          <source>The output shows all of the groups. The outermost matches show up first and the nested matches show up later:</source>
          <target state="translated">出力はすべてのグループを表示します。一番外側のマッチが最初に表示され、入れ子になったマッチが後に表示されます。</target>
        </trans-unit>
        <trans-unit id="61a2ac718a159127bd64e67ec39c4e8e007d9514" translate="yes" xml:space="preserve">
          <source>The output shows that Perl found the two major groups:</source>
          <target state="translated">出力は、Perlが2つの主要なグループを見つけたことを示しています。</target>
        </trans-unit>
        <trans-unit id="eb272330b66e99a860c17d412be21e54b237263f" translate="yes" xml:space="preserve">
          <source>The output shows that while in the &lt;code&gt;OUTER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$outer&lt;/code&gt; . Inside the &lt;code&gt;INNER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$inner&lt;/code&gt; , but only until the end of the block (i.e. the dynamic scope). After the &lt;code&gt;INNER&lt;/code&gt; block completes, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; return to the values for the match against &lt;code&gt;$outer&lt;/code&gt; even though we have not made another match:</source>
          <target state="translated">出力は、 &lt;code&gt;OUTER&lt;/code&gt; ブロック内で &lt;code&gt;$1&lt;/code&gt; と &lt;code&gt;$2&lt;/code&gt; 値が &lt;code&gt;$outer&lt;/code&gt; 一致からのものであることを示しています。 &lt;code&gt;INNER&lt;/code&gt; ブロック内では、 &lt;code&gt;$1&lt;/code&gt; と &lt;code&gt;$2&lt;/code&gt; の値は$ &lt;code&gt;$inner&lt;/code&gt; との一致からのものですが、ブロックの終わり（つまり、動的スコープ）までしかありません。後 &lt;code&gt;INNER&lt;/code&gt; ブロック完了、の値が &lt;code&gt;$1&lt;/code&gt; と &lt;code&gt;$2&lt;/code&gt; 戦の値への復帰 &lt;code&gt;$outer&lt;/code&gt; 私たちは別の試合を行っていないにもかかわらず：</target>
        </trans-unit>
        <trans-unit id="43b62e463d3539b36d5bc54872fb60071ea829c7" translate="yes" xml:space="preserve">
          <source>The output shows the constant() subroutine we're testing being replaced with the value of the &lt;code&gt;DEBUG&lt;/code&gt; constant: zero. The line to be tested has been completely optimized away, and you can't get much more efficient than that.</source>
          <target state="translated">出力は、テストしているconstant（）サブルーチンが &lt;code&gt;DEBUG&lt;/code&gt; 定数の値であるゼロに置き換えられていることを示しています。テスト対象のラインは完全に最適化されており、それ以上の効率は得られません。</target>
        </trans-unit>
        <trans-unit id="223632d9e65a77def5c7f3d1e26472458213d8c9" translate="yes" xml:space="preserve">
          <source>The output string will be returned.</source>
          <target state="translated">出力文字列が返されます。</target>
        </trans-unit>
        <trans-unit id="5b1aa869d1f21ede1a6455013df56f91d9ec5d9c" translate="yes" xml:space="preserve">
          <source>The output strings for &lt;b&gt;Tputs&lt;/b&gt; are cached for counts of 1 for performance. &lt;b&gt;Tgoto&lt;/b&gt; and &lt;b&gt;Tpad&lt;/b&gt; do not cache. &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; is the raw termcap data and &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; is the cached version.</source>
          <target state="translated">&lt;b&gt;Tputs&lt;/b&gt;の出力文字列は、パフォーマンスのためにカウント1でキャッシュされます。&lt;b&gt;Tgoto&lt;/b&gt;と&lt;b&gt;Tpad&lt;/b&gt;はキャッシュしません。 &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; は生のtermcapデータで、 &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; self- &amp;gt; {xx}はキャッシュされたバージョンです。</target>
        </trans-unit>
        <trans-unit id="5e7202107b643ac3d564aacb4d094eef76b947a2" translate="yes" xml:space="preserve">
          <source>The output value, with its sign, must either be a positive value in the range 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the input arguments are objects representing the numbers 7 and 5, the method must either return an object representing the number 3 and a &quot;+&quot; sign, since (3*7) % 5 = 1 % 5, or an object representing the number 2 and &quot;-&quot; sign, since (-2*7) % 5 = 1 % 5.</source>
          <target state="translated">出力値は、1,2,...,OBJ2-1 の範囲内の正の値か、OBJ2 を差し引いた値のいずれかでなければなりません。例えば、入力引数が 7 と 5 を表すオブジェクトである場合、このメソッドは、(3*7)% 5=1 % 5 のため、数字 3 と &quot;+&quot; 記号を表すオブジェクトを返すか、(-2*7)% 5=1 % 5 のため、数字 2 と &quot;-&quot; 記号を表すオブジェクトを返すかのいずれかを返さなければなりません。</target>
        </trans-unit>
        <trans-unit id="1eef73c78f4ba8f7baa5a469f4fff0d89cabb26a" translate="yes" xml:space="preserve">
          <source>The output you'll get when the script is executed:</source>
          <target state="translated">スクリプトが実行されたときに得られる出力。</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">アウトプットです。</target>
        </trans-unit>
        <trans-unit id="0dc65b45e14d95f10af2c76613db8f6869035f53" translate="yes" xml:space="preserve">
          <source>The overall, or wallclock, time between when &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; was called, and when it terminates. The elapsed time includes both user and system times, and time spent waiting for other users and processes on the system. Inevitably, this is the most approximate of the measurements given.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; が呼び出されてから終了するまでの全体的な時間または壁時計の時間。経過時間には、ユーザー時間とシステム時間の両方、およびシステム上の他のユーザーとプロセスの待機に費やされた時間が含まれます。必然的に、これは与えられた測定値の最も近似的なものです。</target>
        </trans-unit>
        <trans-unit id="5407cf16873f519751b5a5a5e241e60dd7a6b88b" translate="yes" xml:space="preserve">
          <source>The pTHX_ symbol in the definition is a macro used by Perl under threading to provide an extra argument to the routine holding a pointer back to the interpreter that is executing the regexp. So under threading all routines get an extra argument.</source>
          <target state="translated">定義にある pTHX_シンボルは、Perl がスレッド処理中に使用するマクロで、正規表現を実行しているインタープリタへのポインタを保持しているルーチンに余分な引数を提供するためのものです。つまり、スレッディング中のすべてのルーチンは、余分な引数を取得します。</target>
        </trans-unit>
        <trans-unit id="f3fe23968698971d8ab162ac70a7f7b71df42802" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;A*&lt;/code&gt; gobbles up all remaining bytes, and &lt;code&gt;$prio&lt;/code&gt; remains undefined! Before we let disappointment dampen the morale: Perl's got the trump card to make this trick too, just a little further up the sleeve. Watch this:</source>
          <target state="translated">パックコード &lt;code&gt;A*&lt;/code&gt; 残りのすべてのバイトを &lt;code&gt;$prio&lt;/code&gt; 、$ prioは未定義のままです！私たちが失望する前に士気を落とす前に：Perlはこのトリックを作るための切り札も持っています。これを見て：</target>
        </trans-unit>
        <trans-unit id="7933b3c7848d20de1a22817261c68e6d7c53c8c0" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;w&lt;/code&gt; has been added to support a portable binary data encoding scheme that goes way beyond simple integers. (Details can be found at &lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt;, the Scarab project.) A BER (Binary Encoded Representation) compressed unsigned integer stores base 128 digits, most significant digit first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last. There is no size limit to BER encoding, but Perl won't go to extremes.</source>
          <target state="translated">パックコード &lt;code&gt;w&lt;/code&gt; は、単純な整数をはるかに超える移植可能なバイナリデータエンコード方式をサポートするために追加されました。 （詳細は&lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt;のScarabプロジェクトにあります。）BER（Binary Encoded Representation）圧縮された符号なし整数は、ベース128桁を格納し、最上位桁を最初に、できるだけ少ない桁数で格納します。最後を除いて、各バイトにビット8（上位ビット）が設定されます。 BERエンコードにサイズの制限はありませんが、Perlは極端には行きません。</target>
        </trans-unit>
        <trans-unit id="1cf9569df81623b7e7940e6c5aeacc511770e43a" translate="yes" xml:space="preserve">
          <source>The pack code for big-endian (high order byte at the lowest address) is &lt;code&gt;n&lt;/code&gt; for 16 bit and &lt;code&gt;N&lt;/code&gt; for 32 bit integers. You use these codes if you know that your data comes from a compliant architecture, but, surprisingly enough, you should also use these pack codes if you exchange binary data, across the network, with some system that you know next to nothing about. The simple reason is that this order has been chosen as the</source>
          <target state="translated">ビッグエンディアン（最下位アドレスの上位バイト）のパックコードは、16ビットの &lt;code&gt;n&lt;/code&gt; はn、32ビット整数の場合は &lt;code&gt;N&lt;/code&gt; です。これらのコードは、データが準拠したアーキテクチャからのものであることがわかっている場合に使用しますが、驚くべきことに、ネットワーク全体でバイナリデータを、ほとんど何も知らないシステムと交換する場合にも、これらのパックコードを使用する必要があります。単純な理由は、この順序が</target>
        </trans-unit>
        <trans-unit id="57fad0d4b36d335f1fb095e9863848e373754e9c" translate="yes" xml:space="preserve">
          <source>The pack code preceding &lt;code&gt;/&lt;/code&gt; may be anything that's fit to represent a number: All the numeric binary pack codes, and even text codes such as &lt;code&gt;A4&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; の前のパックコードは、数値を表すのに適したものであれば何でもかまいません。すべての数値バイナリパックコード、さらには &lt;code&gt;A4&lt;/code&gt; や &lt;code&gt;Z*&lt;/code&gt; などのテキストコードです。</target>
        </trans-unit>
        <trans-unit id="7172e02890f0d23e60cb06f72d229c969bc3f33e" translate="yes" xml:space="preserve">
          <source>The pack format &lt;code&gt;A&lt;/code&gt; means &quot;any character&quot;; if you're &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;ing and you've run out of things to pack, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; will fill the rest up with spaces.</source>
          <target state="translated">パック形式 &lt;code&gt;A&lt;/code&gt; は「任意の文字」を意味します。あなたがいる場合は &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; INGとあなたがパックするものがなくなってきた、 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; スペースで残りを埋めます。</target>
        </trans-unit>
        <trans-unit id="9582d05d51afa98d043db268f238bb511bec0a17" translate="yes" xml:space="preserve">
          <source>The package contains a session manager and a cache manager. The session manager keeps track of what has been fetched, built, and installed in the current session. The cache manager keeps track of the disk space occupied by the make processes and deletes excess space using a simple FIFO mechanism.</source>
          <target state="translated">本パッケージにはセッションマネージャとキャッシュマネージャが含まれます。セッションマネージャは、現在のセッションで何がフェッチされ、ビルドされ、インストールされたかを追跡します。キャッシュマネージャは make プロセスが占有するディスク領域を追跡し、シンプルな FIFO 機構を使って余分な領域を削除します。</target>
        </trans-unit>
        <trans-unit id="fdc4d85fb172b2eb58f10fb1bda38f21c477922a" translate="yes" xml:space="preserve">
          <source>The package name argument will typically be the name of the class into which the subroutine was declared, but it may also be the name of a derived class (since handlers are inherited).</source>
          <target state="translated">パッケージ名の引数には通常、サブルーチンが宣言されたクラスの名前を指定しますが、派生クラスの名前を指定することもできます(ハンドラは継承されるので)。</target>
        </trans-unit>
        <trans-unit id="91efffdbf8c7db0b4f5430206e2d6e6cd3563e8f" translate="yes" xml:space="preserve">
          <source>The package name uses the &lt;code&gt;DBM_Filter::&lt;/code&gt; prefix.</source>
          <target state="translated">パッケージ名は &lt;code&gt;DBM_Filter::&lt;/code&gt; プレフィックスを使用します。</target>
        </trans-unit>
        <trans-unit id="61ad7bd19c49da733338e6250d6950f088f8b981" translate="yes" xml:space="preserve">
          <source>The package representing the distribution. For example, &lt;code&gt;Test::More&lt;/code&gt; or &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . It will be used to derive information about the distribution such as the &lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt;, installation locations within the Perl library and where XS files will be looked for by default (see &lt;a href=&quot;#XS&quot;&gt;XS&lt;/a&gt;).</source>
          <target state="translated">ディストリビューションを表すパッケージ。たとえば、 &lt;code&gt;Test::More&lt;/code&gt; または &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; です。これは、&lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt;、Perlライブラリー内のインストール場所、デフォルトでXSファイルが検索される場所など、配布に関する情報を取得するために使用されます（&lt;a href=&quot;#XS&quot;&gt;XSを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="4576d414ced67927c5747f7cd9e683dea9105380" translate="yes" xml:space="preserve">
          <source>The package the qr// magic object is blessed into (as seen by &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;
qr//&lt;/code&gt; ). It is recommended that engines change this to their package name for identification regardless of if they implement methods on the object.</source>
          <target state="translated">qr //マジックオブジェクトがblessされたパッケージ（ &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; qr//&lt;/code&gt; 見られる）。エンジンは、オブジェクトにメソッドを実装しているかどうかに関係なく、識別のためにこれをパッケージ名に変更することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="73079d10e9cd577552c5b87cfb22afa1b7851691" translate="yes" xml:space="preserve">
          <source>The package this method returns should also have the internal &lt;code&gt;Regexp&lt;/code&gt; package in its &lt;code&gt;@ISA&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; should always be true regardless of what engine is being used.</source>
          <target state="translated">このメソッドが返すパッケージには、 &lt;code&gt;@ISA&lt;/code&gt; &lt;code&gt;Regexp&lt;/code&gt; に内部Regexpパッケージも含まれている必要があります。 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; は、使用されているエンジンに関係なく、常にtrueである必要があります。</target>
        </trans-unit>
        <trans-unit id="7b32ac926fcc794f5f7982e502e4686af4c595bf" translate="yes" xml:space="preserve">
          <source>The package variable &lt;code&gt;@EXPORT&lt;/code&gt; will determine which symbols will get exported when the caller simply says &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; - you will hardly ever want to put anything in there. &lt;code&gt;@EXPORT_OK&lt;/code&gt; , on the other hand, specifies which symbols you're willing to export. If you do want to export a bunch of symbols, use the &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; and define a standard export set - look at &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for more details.</source>
          <target state="translated">パッケージ変数 &lt;code&gt;@EXPORT&lt;/code&gt; は、呼び出し側が単に &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; と言ったときにどのシンボルがエクスポートされるかを決定します-そこに何も入れたくないでしょう。一方、 &lt;code&gt;@EXPORT_OK&lt;/code&gt; は、エクスポートするシンボルを指定します。 &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; シンボルをエクスポートする場合は、％EXPORT_TAGSを使用して標準のエクスポートセットを定義します。詳細については&lt;a href=&quot;exporter&quot;&gt;エクスポーター&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="650111e5202c538679780ce9ea893a905f97b0fc" translate="yes" xml:space="preserve">
          <source>The packages relating to various DBM-related implementations (</source>
          <target state="translated">DBM関連の各種実装に関連するパッケージ(</target>
        </trans-unit>
        <trans-unit id="c94813a5310ff08ec4ccbc37cd40783e0084e83e" translate="yes" xml:space="preserve">
          <source>The pad names in the PADNAMELIST have their PV holding the name of the variable. The COP_SEQ_RANGE_LOW and _HIGH fields form a range (low+1..high inclusive) of cop_seq numbers for which the name is valid. During compilation, these fields may hold the special value PERL_PADSEQ_INTRO to indicate various stages:</source>
          <target state="translated">PADNAMELIST のパッド名は、その変数の名前を保持する PV を持つ。COP_SEQ_RANGE_LOWフィールドと_HIGHフィールドは、名前が有効なCOP_SEQ番号の範囲(LOW+1~HIGHを含む)を形成します。コンパイル中、これらのフィールドは、様々な段階を示すために特別な値PERL_PADSEQ_INTROを保持することがあります。</target>
        </trans-unit>
        <trans-unit id="ad69ddb72e9f5b5565c26efc4eeac2130e2ed028" translate="yes" xml:space="preserve">
          <source>The padded $string is returned.</source>
          <target state="translated">パディングされた$stringが返されます。</target>
        </trans-unit>
        <trans-unit id="d3a360c727f09061a32c58fb443bedffc200fc64" translate="yes" xml:space="preserve">
          <source>The paper &quot;How to Break MD5 and Other Hash Functions&quot; by Xiaoyun Wang and Hongbo Yu.</source>
          <target state="translated">Xiaoyun Wang氏とHongbo Yu氏による論文「How to Break MD5 and Other Hash Functions」が掲載されています。</target>
        </trans-unit>
        <trans-unit id="6bcc7e86c6ab48d9801f437d7ce277bb0ef436bb" translate="yes" xml:space="preserve">
          <source>The paragraphs you give to &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; should not contain embedded newlines. &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; doesn't justify the lines (flush-right).</source>
          <target state="translated">&lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrapに&lt;/a&gt;与える段落には、改行が埋め込まれていてはいけません。&lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrapは行を揃え&lt;/a&gt;ません（右揃え）。</target>
        </trans-unit>
        <trans-unit id="0d3c20158693e8f7ad6ce14151f5e71a493b3128" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the compressed data. This parameter can take one of these forms.</source>
          <target state="translated">パラメータ &lt;code&gt;$output_filename_or_reference&lt;/code&gt; は、圧縮データの宛先を制御するために使用されます。このパラメーターは、次のいずれかの形式を取ることができます。</target>
        </trans-unit>
        <trans-unit id="2a2ee58982c19a9868c4499e7bd1b9d1531f2904" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the uncompressed data. This parameter can take one of these forms.</source>
          <target state="translated">パラメータ &lt;code&gt;$output_filename_or_reference&lt;/code&gt; は、非圧縮データの宛先を制御するために使用されます。このパラメーターは、次のいずれかの形式を取ることができます。</target>
        </trans-unit>
        <trans-unit id="4380851c25da81befd83447bad55f6f9f369b966" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$text&lt;/code&gt; is a string or block of text to be parsed for interior sequences; and the parameter &lt;code&gt;$line_num&lt;/code&gt; is the line number corresponding to the beginning of &lt;code&gt;$text&lt;/code&gt; .</source>
          <target state="translated">パラメータ &lt;code&gt;$text&lt;/code&gt; は、内部シーケンスについて解析される文字列またはテキストのブロックです。パラメータ &lt;code&gt;$line_num&lt;/code&gt; は、 &lt;code&gt;$text&lt;/code&gt; 先頭に対応する行番号です。</target>
        </trans-unit>
        <trans-unit id="175733e4967510eadb5d4ab18e962461101eaed6" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;extra_libs&lt;/code&gt; can be used to specify &lt;b&gt;additional&lt;/b&gt; paths to search for installed modules. For instance</source>
          <target state="translated">パラメータ &lt;code&gt;extra_libs&lt;/code&gt; を使用して、インストールされているモジュールを検索するための&lt;b&gt;追加の&lt;/b&gt;パスを指定できます。例えば</target>
        </trans-unit>
        <trans-unit id="76679b1c7056137b35154fa4603dcc56a2e17eed" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;type&lt;/code&gt; is an enumeration which specifies which of the 3 interface methods (DB_HASH, DB_BTREE or DB_RECNO) is to be used. Depending on which of these is actually chosen, the final parameter,</source>
          <target state="translated">パラメータ &lt;code&gt;type&lt;/code&gt; は、3つのインターフェイスメソッド（DB_HASH、DB_BTREE、またはDB_RECNO）のどれを使用するかを指定する列挙型です。これらのどれが実際に選択されるかに応じて、最後のパラメーターは、</target>
        </trans-unit>
        <trans-unit id="6df79d8edafef2b8d47fc8b433ceb1dac071556d" translate="yes" xml:space="preserve">
          <source>The parameter list to my() may be assigned to if desired, which allows you to initialize your variables. (If no initializer is given for a particular variable, it is created with the undefined value.) Commonly this is used to name input parameters to a subroutine. Examples:</source>
          <target state="translated">my()へのパラメータリストは、必要に応じて代入することができ、変数を初期化することができます。(特定の変数にイニシャライザが与えられていない場合は、未定義の値で作成されます)。一般的には、これはサブルーチンへの入力パラメータに名前を付けるために使用されます。例を示します。</target>
        </trans-unit>
        <trans-unit id="42306ba107d404a6932eda2f03148007a2382a8a" translate="yes" xml:space="preserve">
          <source>The parameter's default value will still be evaluated if the corresponding argument isn't supplied, even though the value won't be stored anywhere. This is in case evaluating it has important side effects. However, it will be evaluated in void context, so if it doesn't have side effects and is not trivial it will generate a warning if the &quot;void&quot; warning category is enabled. If a nameless optional parameter's default value is not important, it may be omitted just as the parameter's name was:</source>
          <target state="translated">パラメータのデフォルト値は、対応する引数が与えられていない場合には、値がどこにも保存されないにもかかわらず評価されます。これは、パラメータを評価することで重要な副作用がある場合のためです。しかし、これは void コンテキストで評価されるので、副作用がなく、些細なことではない場合は、&quot;void&quot; 警告カテゴリが有効になっている場合に警告が発生します。名前のないオプションパラメータのデフォルト値が重要でない場合は、パラメータの名前があったように省略されることがあります。</target>
        </trans-unit>
        <trans-unit id="59f23da7798f0b234972a256a92c78bcfb8c2aa3" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the compressed data.</source>
          <target state="translated">パラメータ &lt;code&gt;$input_filename_or_reference&lt;/code&gt; は、圧縮データのソースを定義するために使用されます。</target>
        </trans-unit>
        <trans-unit id="ed835ab2fa9d34eac4fd3a603940891a0a5eef62" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the uncompressed data.</source>
          <target state="translated">パラメータ &lt;code&gt;$input_filename_or_reference&lt;/code&gt; は、非圧縮データのソースを定義するために使用されます。</target>
        </trans-unit>
        <trans-unit id="2e0cab04bcd8cbbda8dd4d2c9ce2cf18535f80ac" translate="yes" xml:space="preserve">
          <source>The parameters it accepts are:</source>
          <target state="translated">それが受け入れるパラメータは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="a830abc7b9d4b876164e2805f5f239e46c825485" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; are added to the start of the perl search path. Saying</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; を&lt;a href=&quot;functions/use&quot;&gt;使用するため&lt;/a&gt;のパラメーターがperl検索パスの先頭に追加されます。言う</target>
        </trans-unit>
        <trans-unit id="ea253e51dc3b40387e985b7980c9898cef5a3467" translate="yes" xml:space="preserve">
          <source>The parentheses about &lt;code&gt;XSLoader::load()&lt;/code&gt; arguments are needed since we replaced &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, so the compiler does not know that a function &lt;code&gt;XSLoader::load()&lt;/code&gt; is present.</source>
          <target state="translated">およそ括弧 &lt;code&gt;XSLoader::load()&lt;/code&gt; 私たちは置き換えので、引数が必要な &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; によって &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; コンパイラが関数のことを知らないので、 &lt;code&gt;XSLoader::load()&lt;/code&gt; 存在しています。</target>
        </trans-unit>
        <trans-unit id="f992098d3a5a843dac6b8ae9c7b69d4a2fac46e8" translate="yes" xml:space="preserve">
          <source>The parse proceeds pretty much exactly as it does during the construction phase, except that most routines are short-circuited to change the size field &lt;code&gt;RExC_size&lt;/code&gt; and not do anything else.</source>
          <target state="translated">構文解析は、ほとんどのルーチンがサイズフィールド &lt;code&gt;RExC_size&lt;/code&gt; を変更するために短絡され、それ以外は何もしないことを除いて、構築フェーズ中とほぼ同じように進行します。</target>
        </trans-unit>
        <trans-unit id="93ac900e49339cc6ef6dea21ed4478644c93af89" translate="yes" xml:space="preserve">
          <source>The parser is nobly assisted by the lexer, which chunks up your input into tokens, and decides what type of thing each token is: a variable name, an operator, a bareword, a subroutine, a core function, and so on. The main point of entry to the lexer is &lt;code&gt;yylex&lt;/code&gt; , and that and its associated routines can be found in</source>
          <target state="translated">パーサーは、入力をトークンに分割し、各トークンのタイプを決定するレクサーによって、変数名、演算子、ベアワード、サブルーチン、コア関数などを支援します。レクサーへの入り口の主なポイントは &lt;code&gt;yylex&lt;/code&gt; であり、それとその関連ルーチンは次の場所にあります。</target>
        </trans-unit>
        <trans-unit id="c291c44225b529aa63eb30ed6a4d6cbe06294dcd" translate="yes" xml:space="preserve">
          <source>The parser then sees the following code:</source>
          <target state="translated">すると、パーサーは次のようなコードを表示します。</target>
        </trans-unit>
        <trans-unit id="09f50fcb4a70f717d3ac7b5f391fbd97a01ce899" translate="yes" xml:space="preserve">
          <source>The part of the address of a TCP or UDP socket that directs packets to the correct process after finding the right machine, something like the phone extension you give when you reach the company operator. Also the result of converting code to run on a different platform than originally intended, or the verb denoting this conversion.</source>
          <target state="translated">TCPまたはUDPソケットのアドレスの一部で、適切なマシンを見つけた後に正しいプロセスにパケットを送るためのものです。また、本来意図したものとは異なるプラットフォームで動作するようにコードを変換した結果、またはこの変換を表す動詞のこと。</target>
        </trans-unit>
        <trans-unit id="ae986ba9c61f4a263f7b3033ed66b7a9c47ca2ea" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use does not support the specified signal being used in a &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; call.</source>
          <target state="translated">使用しようとしているPerlの特定のコピーは、 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; 呼び出しで使用されている指定されたシグナルをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="24e4beb9cede37117dbc38642ef9d4cdf73ef0f4" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use was not built using the &lt;code&gt;useithreads&lt;/code&gt; configuration option.</source>
          <target state="translated">使用しようとしているPerlの特定のコピーは、 &lt;code&gt;useithreads&lt;/code&gt; 構成オプションを使用してビルドされていません。</target>
        </trans-unit>
        <trans-unit id="e133c3129f1a418b83b69fbe9affe042d494a52e" translate="yes" xml:space="preserve">
          <source>The particular macro you must use depends on which &lt;code&gt;sv_set*v&lt;/code&gt; routine you called first. This is because every &lt;code&gt;sv_set*v&lt;/code&gt; routine turns on only the bit for the particular type of data being set, and turns off all the rest.</source>
          <target state="translated">使用する必要がある特定のマクロは、最初に &lt;code&gt;sv_set*v&lt;/code&gt; ルーチンによって異なります。これは、すべての &lt;code&gt;sv_set*v&lt;/code&gt; ルーチンが、設定される特定のタイプのデータのビットのみをオンにし、残りのすべてをオフにするためです。</target>
        </trans-unit>
        <trans-unit id="1c24d584fffb94c2e195393379212bd0e772bba9" translate="yes" xml:space="preserve">
          <source>The passed-in property may be specified as any of the synonyms returned by &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt;.</source>
          <target state="translated">渡されたプロパティは、&lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases（）&lt;/a&gt;によって返される同義語のいずれかとして指定できます。</target>
        </trans-unit>
        <trans-unit id="515ad1971581ebeed29e0dfbff2e2ca6f9f34b5c" translate="yes" xml:space="preserve">
          <source>The patchlevel level of this package. The value of patchlevel comes from the</source>
          <target state="translated">このパッケージのパッチレベル。patchlevel の値は</target>
        </trans-unit>
        <trans-unit id="6c9c1991e5426882e512831205056ad8d0cb53e5" translate="yes" xml:space="preserve">
          <source>The path Perl takes through &lt;code&gt;@INC&lt;/code&gt; . By default, this is a double depth first search, once looking for defined methods and once for &lt;code&gt;AUTOLOAD&lt;/code&gt; . However, Perl lets you configure this with &lt;code&gt;mro&lt;/code&gt; .</source>
          <target state="translated">Perlが &lt;code&gt;@INC&lt;/code&gt; を通過するパス。デフォルトでは、これは2度の深さ優先検索であり、1回は定義されたメソッドを探し、もう1回は &lt;code&gt;AUTOLOAD&lt;/code&gt; を探します。ただし、Perlではこれを &lt;code&gt;mro&lt;/code&gt; で構成できます。</target>
        </trans-unit>
        <trans-unit id="97b7ffc6783961615c324915aaa3803b45441d58" translate="yes" xml:space="preserve">
          <source>The path from the uri, will be at least a single '/'.</source>
          <target state="translated">uriからのパスは、少なくとも1つの'/'になります。</target>
        </trans-unit>
        <trans-unit id="935a26d686af6b04ea7fea8358669d0caebc7249" translate="yes" xml:space="preserve">
          <source>The path of the file from which the history (assuming a usable Term::ReadLine backend) will be read on the debugger's startup, and to which it will be saved on shutdown (for persistence across sessions). Similar in concept to Bash's &lt;code&gt;.bash_history&lt;/code&gt; file.</source>
          <target state="translated">デバッガーの起動時に履歴（使用可能なTerm :: ReadLineバックエンドを想定）が読み込まれ、シャットダウン時に保存される（セッション間での永続化のため）ファイルのパス。概念的には、Bashの &lt;code&gt;.bash_history&lt;/code&gt; ファイルに似ています。</target>
        </trans-unit>
        <trans-unit id="3f73d1d0634237caab821e6e9c8fad9914a18a73" translate="yes" xml:space="preserve">
          <source>The path to the file is automatically converted to a Unix like equivalent for use in the archive, and, if on MacOS, the file's modification time is converted from the MacOS epoch to the Unix epoch. So tar archives created on MacOS with &lt;b&gt;Archive::Tar&lt;/b&gt; can be read both with</source>
          <target state="translated">ファイルへのパスは、アーカイブで使用するための同等のUnixに自動的に変換され、MacOSの場合、ファイルの変更時刻はMacOSエポックからUnixエポックに変換されます。したがって、MacOSで&lt;b&gt;Archive :: Tarを&lt;/b&gt;使用して作成されたtarアーカイブは、</target>
        </trans-unit>
        <trans-unit id="2ab24d7b050cb5882eec74eec0cbc6ea2a2768dd" translate="yes" xml:space="preserve">
          <source>The pathname of a POD file to syntax-check (defaults to standard input).</source>
          <target state="translated">構文チェックを行うPODファイルのパス名(デフォルトは標準入力)。</target>
        </trans-unit>
        <trans-unit id="3091661abc10e8b933048a63287800c8286b8cec" translate="yes" xml:space="preserve">
          <source>The pathname of a file containing pod documentation to be output in usage message format (defaults to standard input).</source>
          <target state="translated">使用法メッセージ形式で出力されるポッドドキュメントを含むファイルのパス名(デフォルトは標準入力)。</target>
        </trans-unit>
        <trans-unit id="5506a685c5fca482706d4108f11645e50bb17fd9" translate="yes" xml:space="preserve">
          <source>The pathname of a file from which to select sections of pod documentation (defaults to standard input).</source>
          <target state="translated">ポッド文書のセクションを選択するためのファイルのパス名(デフォルトは標準入力)。</target>
        </trans-unit>
        <trans-unit id="64067e36292a9c79bf92f0c4d392216daafe926d" translate="yes" xml:space="preserve">
          <source>The pattern begins with a class matching a subset of letters. Whenever this matches, a statement like &lt;code&gt;$count{'a'}++;&lt;/code&gt; is executed, incrementing the letter's counter. Then &lt;code&gt;(*FAIL)&lt;/code&gt; does what it says, and the regexp engine proceeds according to the book: as long as the end of the string hasn't been reached, the position is advanced before looking for another vowel. Thus, match or no match makes no difference, and the regexp engine proceeds until the entire string has been inspected. (It's remarkable that an alternative solution using something like</source>
          <target state="translated">パターンは、文字のサブセットに一致するクラスで始まります。これが一致するときはいつでも、 &lt;code&gt;$count{'a'}++;&lt;/code&gt; ようなステートメント。文字のカウンターをインクリメントして実行されます。次に &lt;code&gt;(*FAIL)&lt;/code&gt; はそれが言うことを実行し、正規表現エンジンは本に従って進みます。文字列の終わりに達していない限り、別の母音を探す前に位置が進められます。したがって、一致するか一致しないかの違いはありません。正規表現エンジンは、文字列全体が検査されるまで続行します。 （のようなものを使用した代替ソリューションが注目に値する</target>
        </trans-unit>
        <trans-unit id="194b10f85ac928e670426276285fc77367b6bf3e" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">パターンマッチングは成功し、 &lt;code&gt;$1&lt;/code&gt; が定義されていますが、「何も」にはマッチしませんでした。何にもマッチしなかったわけではありません。むしろ、たまたまゼロ文字である何かと一致しました。これはすべて非常に上で正直です。関数が未定義の値を返すとき、それはあなたに正直な答えを与えることができなかったことを認めています。だから、あなたがしようとしていることの完全性を疑うときだけ、 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; を使用すべきです。それ以外の場合は、 &lt;code&gt;0&lt;/code&gt; または &lt;code&gt;&quot;&quot;&lt;/code&gt; との単純な比較で十分です。</target>
        </trans-unit>
        <trans-unit id="6ccde9606e998bb56b83482fdb0ce2d1cd2b87e5" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">パターンマッチングは成功し、 &lt;code&gt;$1&lt;/code&gt; が定義されていますが、「何も」にはマッチしませんでした。何にもマッチしなかったわけではありません。むしろ、たまたまゼロ文字である何かと一致しました。これはすべて非常に上で正直です。関数が未定義の値を返すとき、それはあなたに正直な答えを与えることができなかったことを認めています。だから、あなたがしようとしていることの完全性を疑うときだけ、 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; を使用すべきです。それ以外の場合は、 &lt;code&gt;0&lt;/code&gt; または &lt;code&gt;&quot;&quot;&lt;/code&gt; との単純な比較で十分です。</target>
        </trans-unit>
        <trans-unit id="00e74cbb0f8570bc720cdf9f1dc73c5533c198b5" translate="yes" xml:space="preserve">
          <source>The pattern matching metacharacters &quot;(&quot;, &quot;)&quot;, and &quot;|&quot; do not have backslashes in front.</source>
          <target state="translated">パターンにマッチするメタキャラクタ「(&quot;,,&quot;)」「|」は、前にバックスラッシュがありません。</target>
        </trans-unit>
        <trans-unit id="8647f015f186197cabe9c1508a8d5b1dddf875e9" translate="yes" xml:space="preserve">
          <source>The pattern matching operations &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) when used without an &lt;code&gt;=~&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;=~&lt;/code&gt; 演算子なしで使用した場合のパターンマッチング操作 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; （別名 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="216352b3a9f025091614aa329a166fdb30a18a8e" translate="yes" xml:space="preserve">
          <source>The pattern modifiers:</source>
          <target state="translated">パターン修飾子です。</target>
        </trans-unit>
        <trans-unit id="a2c1a780666383b49402abd005e8fafffcab62b8" translate="yes" xml:space="preserve">
          <source>The pattern of macro calls is like this:</source>
          <target state="translated">マクロを呼び出すパターンはこんな感じです。</target>
        </trans-unit>
        <trans-unit id="3569af6a782c9884f9c5e89ba969f12fe42cf2da" translate="yes" xml:space="preserve">
          <source>The pattern really,</source>
          <target state="translated">本当にこのパターン。</target>
        </trans-unit>
        <trans-unit id="8a46001019582eae5c4e5728c4a3fb31cd3dbf38" translate="yes" xml:space="preserve">
          <source>The patterns used in Perl pattern matching evolved from those supplied in the Version 8 regex routines. (The routines are derived (distantly) from Henry Spencer's freely redistributable reimplementation of the V8 routines.) See &lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt;Version 8 Regular Expressions&lt;/a&gt; for details.</source>
          <target state="translated">Perlパターンマッチングで使用されるパターンは、バージョン8のregexルーチンで提供されるパターンから発展しました。（これらのルーチンは、V8ルーチンのHenry Spencerの自由に再配布可能な再実装から（離れて）派生しています。）詳細については、&lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt;バージョン8の正規表現&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="dac0ad9b1d3df00129661ed1e95ffc2c13f0c968" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate on ops throughout the subroutine's structure, rather than just at the top level, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_rpeepp&quot;&gt;PL_rpeepp&lt;/a&gt; hook.</source>
          <target state="translated">のぞき穴オプティマイザを完全に置き換えることはできません。むしろ、既存のオプティマイザをラップしてコードを追加します。これを行う基本的な方法は、「&lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;コンパイルパス3：perlgutsでののぞき穴の最適化」にあり&lt;/a&gt;ます。新しいコードが、最上位だけでなく、サブルーチンの構造全体でopsを操作する場合は、&lt;a href=&quot;#PL_rpeepp&quot;&gt;PL_rpeepp&lt;/a&gt;フックをラップする方が便利です。</target>
        </trans-unit>
        <trans-unit id="db43041726026c591925cfc25e5688f00dc4bbac" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate only on ops at a subroutine's top level, rather than throughout the structure, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_peepp&quot;&gt;PL_peepp&lt;/a&gt; hook.</source>
          <target state="translated">のぞき穴オプティマイザを完全に置き換えることはできません。むしろ、既存のオプティマイザをラップしてコードを追加します。これを行う基本的な方法は、「&lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;コンパイルパス3：perlgutsでののぞき穴の最適化」にあり&lt;/a&gt;ます。新しいコードが、構造全体ではなく、サブルーチンの最上位レベルの&lt;a href=&quot;#PL_peepp&quot;&gt;op&lt;/a&gt;でのみ動作するようにしたい場合は、PL_peeppフックをラップする方が便利です。</target>
        </trans-unit>
        <trans-unit id="ace3f1e6483238aa81eb601036e5dcd7d2b38b3a" translate="yes" xml:space="preserve">
          <source>The per-instance data are held in memory beyond the basic PerlIOl struct, by making a PerlIOl the first member of the layer's struct thus:</source>
          <target state="translated">このように、PerlIOlをレイヤの構造体の最初のメンバにすることで、基本的なPerlIOl構造体を超えてインスタンスあたりのデータがメモリに保持されます。</target>
        </trans-unit>
        <trans-unit id="467fb902a44226db21d27e75dc641b031d86cd72" translate="yes" xml:space="preserve">
          <source>The per-instance data for a particular handle.</source>
          <target state="translated">特定のハンドルのインスタンスごとのデータ。</target>
        </trans-unit>
        <trans-unit id="85e58f1f52dd9a0e84852e44b90f48bbed040fce" translate="yes" xml:space="preserve">
          <source>The per-record overhead will limit the maximum number of records you can access per file. Note that</source>
          <target state="translated">レコードごとのオーバーヘッドにより、ファイルごとにアクセスできるレコードの最大数が制限されます。以下のことに注意してください。</target>
        </trans-unit>
        <trans-unit id="874d7f7aa12fc5ea3bd61b16d41289fe642a630c" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot;</source>
          <target state="translated">ピリオド'.'は、&quot;\n &quot;以外の文字にマッチします。</target>
        </trans-unit>
        <trans-unit id="e038fd297e6c1d463ecc98d5fcaacd0e4180bccd" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot; (unless the modifier &lt;code&gt;//s&lt;/code&gt; is in effect, as explained below).</source>
          <target state="translated">期間 '。' 「\ n」以外の任意の文字に一致します（以下で説明するように、修飾子 &lt;code&gt;//s&lt;/code&gt; が有効でない限り）。</target>
        </trans-unit>
        <trans-unit id="50625043a5bdab5548c251e25233bc0e03a34159" translate="yes" xml:space="preserve">
          <source>The perl code in PerlIO.pm then attempts to locate a layer by doing</source>
          <target state="translated">PerlIO.pm の perl コードは、次のようにしてレイヤーを見つけようとします。</target>
        </trans-unit>
        <trans-unit id="16b7e5af7739f86fd0e9e79d11ca97ac5649e9b1" translate="yes" xml:space="preserve">
          <source>The perl core wraps &lt;code&gt;setjmp()&lt;/code&gt; etc in the macros &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and &lt;code&gt;JMPENV_JUMP&lt;/code&gt; . The basic rule of perl exceptions is that &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (in the absence of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;) perform a &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; , while &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; within &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; .</source>
          <target state="translated">perlコアは、マクロ &lt;code&gt;JMPENV_PUSH&lt;/code&gt; および &lt;code&gt;JMPENV_JUMP&lt;/code&gt; で &lt;code&gt;setjmp()&lt;/code&gt; などをラップします。Perlの例外の基本的なルールは、であり &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 、及び &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; （の非存在下で &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ）を行う &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; が、 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 内の &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; はない &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c474186075797ee40452934f04a51f573b827bb" translate="yes" xml:space="preserve">
          <source>The perl executable is obtained by linking</source>
          <target state="translated">perl実行ファイルは</target>
        </trans-unit>
        <trans-unit id="06ded168a76972d517d9136275d2690412f2929f" translate="yes" xml:space="preserve">
          <source>The perl message comes out with &quot;Perl&quot; in front. The &lt;code&gt;BEGIN&lt;/code&gt; block works at compile time so all of the compilation errors and warnings get the &quot;Perl:&quot; prefix too.</source>
          <target state="translated">perlメッセージの前に「Perl」が付いています。 &lt;code&gt;BEGIN&lt;/code&gt; コンパイルエラーと警告のすべてを取得するので、コンパイル時にブロックの動作を「Perlを：」プレフィックスを過ぎます。</target>
        </trans-unit>
        <trans-unit id="b63df2b573a7b7008051f6d3411e1d7de7dd31b6" translate="yes" xml:space="preserve">
          <source>The perl source is in a git repository. You can clone the repository with the following command:</source>
          <target state="translated">perlのソースはgitリポジトリにあります。以下のコマンドでリポジトリをクローンすることができます。</target>
        </trans-unit>
        <trans-unit id="327d340c9d37adf78ea3fa44d3b1c6e9e8b77c71" translate="yes" xml:space="preserve">
          <source>The perl tie function associates a variable with an object that implements the various GET, SET, etc methods. To perform the equivalent of the perl tie function from an XSUB, you must mimic this behaviour. The code below carries out the necessary steps -- firstly it creates a new hash, and then creates a second hash which it blesses into the class which will implement the tie methods. Lastly it ties the two hashes together, and returns a reference to the new tied hash. Note that the code below does NOT call the TIEHASH method in the MyTie class - see &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;Calling Perl Routines from within C Programs&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">perl tie関数は、さまざまなGET、SETなどのメソッドを実装するオブジェクトに変数を関連付けます。XSUBから同等のperl tie関数を実行するには、この動作を模倣する必要があります。以下のコードは必要な手順を実行します。最初に新しいハッシュを作成し、次に、tieメソッドを実装するクラスにblessする2番目のハッシュを作成します。最後に、2つのハッシュを結合し、結合された新しいハッシュへの参照を返します。以下のコードは、MyTieクラスのTIEHASHメソッドを呼び出さないことに注意してください。これを行う方法の詳細については、&lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;Cプログラム内からのPerlルーチンの呼び出し&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="123c31a7a632081aa07f5ab58c14ca27dc4643f2" translate="yes" xml:space="preserve">
          <source>The perl visible name of the XS subroutine generated which will return the constants. The default is &lt;code&gt;constant&lt;/code&gt; .</source>
          <target state="translated">定数を返す、生成されたXSサブルーチンのperl表示名。デフォルトは &lt;code&gt;constant&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="87baa838c319b67b0a259076dbfb27270de34c58" translate="yes" xml:space="preserve">
          <source>The perl-mvs@perl.org list is for discussion of porting issues as well as general usage issues for all EBCDIC Perls. Send a message body of &quot;subscribe perl-mvs&quot; to majordomo@perl.org.</source>
          <target state="translated">perl-mvs@perl.org リストは、すべての EBCDIC Perls の移植問題や一般的な使用法の問題について議論するためのものです。subscribe perl-mvs&quot; のメッセージ本文を majordomo@perl.org に送ってください。</target>
        </trans-unit>
        <trans-unit id="5ba3dea55a126a532be4f9eaeca0422de96d0827" translate="yes" xml:space="preserve">
          <source>The perl5-changes mailing list receives a copy of each patch that gets submitted to the maintenance and development branches of the perl repository. See &lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;http://lists.perl.org/list/perl5-changes.html&lt;/a&gt; for subscription and archive information.</source>
          <target state="translated">perl5-changesメーリングリストは、perlリポジトリのメンテナンスおよび開発ブランチに送信される各パッチのコピーを受け取ります。サブスクリプションおよびアーカイブ情報については、&lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;http：//lists.perl.org/list/perl5-changes.html&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9c029dc7e52d0d0d6369cc3ff0e62686a113c165" translate="yes" xml:space="preserve">
          <source>The perl5-porters (p5p) mailing list is where the Perl standard distribution is maintained and developed. The people who maintain Perl are also referred to as the &quot;Perl 5 Porters&quot;, &quot;p5p&quot; or just the &quot;porters&quot;.</source>
          <target state="translated">perl5-porters (p5p)メーリングリストは、Perl標準配布物のメンテナンスと開発を行っています。Perlを管理している人たちは、&quot;Perl 5 Porters&quot;、&quot;p5p&quot;、または単に &quot;porters &quot;とも呼ばれています。</target>
        </trans-unit>
        <trans-unit id="55339a112f571a65cc173aaae9b60118d4926fb7" translate="yes" xml:space="preserve">
          <source>The perlbug program will ask you a few questions about your email address and the patch you're submitting. Once you've answered them it will submit your patch via email.</source>
          <target state="translated">perlbug プログラムは、あなたのメールアドレスと提出するパッチについていくつかの質問をします。これらの質問に答えると、メールでパッチを提出します。</target>
        </trans-unit>
        <trans-unit id="a319a07f2540ad16252f1fe55565bcf46c56c4bb" translate="yes" xml:space="preserve">
          <source>The perldoc for utime also has an example that has the same effect as touch(1) on files that</source>
          <target state="translated">utime 用の perldoc にも、touch(1)と同じ効果を持つ例があります。</target>
        </trans-unit>
        <trans-unit id="ed575d398752b423e73c91acec2e13e6122dc7e1" translate="yes" xml:space="preserve">
          <source>The perlfaq comprises several documents that answer the most commonly asked questions about Perl and Perl programming. It's divided by topic into nine major sections outlined in this document.</source>
          <target state="translated">perlfaqは、PerlとPerlプログラミングに関する最も一般的な質問に答えるいくつかのドキュメントで構成されています。このドキュメントでは、トピックごとに9つの主要なセクションに分けられています。</target>
        </trans-unit>
        <trans-unit id="bf571460e6819407bba20acb1eb1771f32d393cd" translate="yes" xml:space="preserve">
          <source>The perlfaq is an evolving document. Read the latest version at &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;. It is also included in the standard Perl distribution.</source>
          <target state="translated">perlfaqは進化するドキュメントです。&lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/で&lt;/a&gt;最新バージョンをお読みください。また、標準のPerlディストリビューションにも含まれています。</target>
        </trans-unit>
        <trans-unit id="d8ba3c9bbcf37ca492d8ac656f9c49509454f36e" translate="yes" xml:space="preserve">
          <source>The perlpod spec for a Verbatim paragraph is &quot;It should be reproduced exactly...&quot;, which means that the whitespace you've used to indent your verbatim blocks will be preserved in the output. This can be annoying for outputs such as HTML, where that whitespace will remain in front of every line. It's an unfortunate case where syntax is turned into semantics.</source>
          <target state="translated">Verbatim段落のperlpodの仕様は「正確に再現されるべきである...」というもので、これは、Verbatimブロックのインデントに使用した空白が出力に保存されることを意味します。これは、HTML のような出力では、ホワイトスペースがすべての行の前に残ってしまうので、イライラすることがあります。これは、構文が意味論になってしまう不幸なケースです。</target>
        </trans-unit>
        <trans-unit id="d320cdc510ba6fe180a797e4852d051df0ce9e8c" translate="yes" xml:space="preserve">
          <source>The perlstyle manual supplied with Perl has many helpful points.</source>
          <target state="translated">Perlに付属のperlstyleのマニュアルには参考になる点がたくさんあります。</target>
        </trans-unit>
        <trans-unit id="f61630dfa6a2b75f5a9ee952e22583e2bdae4aef" translate="yes" xml:space="preserve">
          <source>The person whom the &lt;b&gt;operating system&lt;/b&gt; will let do almost anything. Typically your system administrator or someone pretending to be your system administrator. On Unix systems, the &lt;b&gt;root&lt;/b&gt; user. On Windows systems, usually the Administrator user.</source>
          <target state="translated">人&lt;b&gt;のオペレーティングシステムは、&lt;/b&gt;ほとんど何でもできるようになります。通常、システム管理者またはシステム管理者になりすました人物。Unixシステムでは、&lt;b&gt;root&lt;/b&gt;ユーザー。Windowsシステムでは、通常は管理者ユーザー。</target>
        </trans-unit>
        <trans-unit id="674e8f557a9263711bdd1bff3bb098f69b9e9b84" translate="yes" xml:space="preserve">
          <source>The pipeline model divides up a task into a series of steps, and passes the results of one step on to the thread processing the next. Each thread does one thing to each piece of data and passes the results to the next thread in line.</source>
          <target state="translated">パイプラインモデルは、タスクを一連のステップに分割し、1つのステップの結果を次の処理を行うスレッドに渡します。各スレッドはそれぞれのデータに対して一つの処理を行い、その結果を次のスレッドに渡します。</target>
        </trans-unit>
        <trans-unit id="e5963c8e8de82f4449d7ed9e1e51afdf5f459ee1" translate="yes" xml:space="preserve">
          <source>The pl2pm utility will get you started.</source>
          <target state="translated">pl2pmユーティリティを使えば、すぐに始められます。</target>
        </trans-unit>
        <trans-unit id="1d36c8a340c756f47102c1832b54cb16f13c0c7c" translate="yes" xml:space="preserve">
          <source>The plan (for example, '1..5'), must only come at the beginning or end of the TAP output.</source>
          <target state="translated">プラン(例えば、'1..5')は、TAP出力の最初か最後にのみ来なければなりません。</target>
        </trans-unit>
        <trans-unit id="4fc2d017a3ab4b5deac17556464426823c475059" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">関数のポイントは、 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 関数を「シード」して、プログラムを実行するたびに &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; が異なるシーケンスを生成できるようにすることです。 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; はパラメーターを指定して呼び出されると、シードに使用します。それ以外の場合は、（半）ランダムにシードを選択します。どちらの場合も、Perl 5.14以降、シードを返します。コードが機能することを通知するには</target>
        </trans-unit>
        <trans-unit id="2e1f3e31ba6a1b36a8c681657ab8caf017949b14" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">関数のポイントは、 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 関数を「シード」して、プログラムを実行するたびに &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; が異なるシーケンスを生成できるようにすることです。 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; はパラメーターを指定して呼び出されると、シードに使用します。それ以外の場合は、（半）ランダムにシードを選択します。どちらの場合も、Perl 5.14以降、シードを返します。コードが機能することを通知するには</target>
        </trans-unit>
        <trans-unit id="d8e49cca1375307d0cbb7648d543980bc0807cf4" translate="yes" xml:space="preserve">
          <source>The pointer is blessed into a class that is derived from the name of type of the pointer but with all '*' in the name replaced with 'Ptr'.</source>
          <target state="translated">ポインタは、ポインタの型名から派生したクラスに祝福されますが、名前の中のすべての'*'が'Ptr'に置き換えられています。</target>
        </trans-unit>
        <trans-unit id="549bcd1d7ae81c0474487c42c591f283db8f5fed" translate="yes" xml:space="preserve">
          <source>The pointer to the PV of the &lt;code&gt;dsv&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;dsv&lt;/code&gt; のPVへのポインタが返されます。</target>
        </trans-unit>
        <trans-unit id="7ab31953e34eba90fc36ab51df0189b64f65aae0" translate="yes" xml:space="preserve">
          <source>The points to note are</source>
          <target state="translated">注意点は</target>
        </trans-unit>
        <trans-unit id="c1fdc510fd28f743532d0f8810f2c036e2bf9b84" translate="yes" xml:space="preserve">
          <source>The polar notation (also known as the trigonometric representation) is much more handy for performing multiplications and divisions of complex numbers, whilst the cartesian notation is better suited for additions and subtractions. Real numbers are on the</source>
          <target state="translated">極表記(三角法表現としても知られています)は複素数の乗算や除算を行うのに便利ですが、直交表記は足し算や引き算に適しています。実数は</target>
        </trans-unit>
        <trans-unit id="b5ec1158a1165100647b29065f9f5443b0e8eb69" translate="yes" xml:space="preserve">
          <source>The polar style attempts to emphasize arguments like</source>
          <target state="translated">のような主張を強調しようとするのが極流です。</target>
        </trans-unit>
        <trans-unit id="9c2c870c4a68cedcedbfdb919f7afe57be993942" translate="yes" xml:space="preserve">
          <source>The port for Win32 was used as a reference.</source>
          <target state="translated">Win32用のポートを参考にしました。</target>
        </trans-unit>
        <trans-unit id="9181a3290f36ca81b3bb6720fe9893dc45df567f" translate="yes" xml:space="preserve">
          <source>The port of Perl to to Mac OS was officially removed as of Perl 5.12, though the last official production release of MacPerl corresponded to Perl 5.6. While Perl 5.10 included the port to Mac OS, ExtUtils::MakeMaker, a core part of Perl's module installation infrastructure officially dropped support for Mac OS in April 2004.</source>
          <target state="translated">Perl の Mac OS への移植は Perl 5.12 の時点で公式に削除されましたが、MacPerl の最後の公式なプロダクションリリースは Perl 5.6 に対応していました。Perl 5.10 には Mac OS への移植が含まれていましたが、Perl のモジュールインストールインフラストラクチャのコア部分である ExtUtils::MakeMaker は 2004 年 4 月に公式に Mac OS へのサポートを終了しました。</target>
        </trans-unit>
        <trans-unit id="f4180538d74696f5817f3f6feca9a1c65e2c02f2" translate="yes" xml:space="preserve">
          <source>The porters appreciate the time you spent helping to make Perl better. Thank you!</source>
          <target state="translated">移植者は、Perlをより良くするためにあなたが時間を割いてくれたことに感謝しています。ありがとうございます。</target>
        </trans-unit>
        <trans-unit id="54bd391c46a02c41cb9ecadecb266d6444c3a53a" translate="yes" xml:space="preserve">
          <source>The portion of the extension provided by the XS code may be connected to the rest of Perl in either of two ways. In the &lt;b&gt;static&lt;/b&gt; configuration, the object code for the extension is linked directly into</source>
          <target state="translated">XSコードによって提供される拡張機能の部分は、2つの方法のいずれかで残りのPerlに接続できます。で&lt;b&gt;静的&lt;/b&gt;構成、拡張のためのオブジェクト・コードは、に直接連結されています</target>
        </trans-unit>
        <trans-unit id="4c71fa06187e2cb76d45cf6769bdd2d2cbe65fe5" translate="yes" xml:space="preserve">
          <source>The position in the file of FILEHANDLE is left unchanged. You may want to call &lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;seek&lt;/a&gt; before writing to the file.</source>
          <target state="translated">FILEHANDLEのファイル内の位置は変更されません。ファイルに書き込む前に&lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;seek&lt;/a&gt;を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="efdfff91986b015ed9943f5eed1ac7ffd6711ca2" translate="yes" xml:space="preserve">
          <source>The possessive forms (new in Perl 5.10) prevent backtracking: what gets matched by a pattern with a possessive quantifier will not be backtracked into, even if that causes the whole match to fail.</source>
          <target state="translated">所有形 (Perl 5.10 の新機能)はバックトラッキングを防止します。所有形量詞を持つパターンにマッチしたものは、たとえマッチ全体が失敗したとしてもバックトラッキングされません。</target>
        </trans-unit>
        <trans-unit id="5eab19b8b748f65afb0049c25c884441fbae1bc8" translate="yes" xml:space="preserve">
          <source>The possible categories are: &lt;code&gt;:collate&lt;/code&gt; , &lt;code&gt;:ctype&lt;/code&gt; , &lt;code&gt;:messages&lt;/code&gt; , &lt;code&gt;:monetary&lt;/code&gt; , &lt;code&gt;:numeric&lt;/code&gt; , &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; , and the pseudo category &lt;code&gt;:characters&lt;/code&gt; (described below).</source>
          <target state="translated">可能なカテゴリは次のとおりです &lt;code&gt;:collate&lt;/code&gt; 、 &lt;code&gt;:ctype&lt;/code&gt; 、 &lt;code&gt;:messages&lt;/code&gt; 、 &lt;code&gt;:monetary&lt;/code&gt; 、 &lt;code&gt;:numeric&lt;/code&gt; 、 &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 、および擬似カテゴリ &lt;code&gt;:characters&lt;/code&gt; （後述）。</target>
        </trans-unit>
        <trans-unit id="d6655e8efe41a46d2438d144ed4d6129c437e80b" translate="yes" xml:space="preserve">
          <source>The possible values and flag bits of the MODE parameter are system-dependent; they are available via the standard module &lt;code&gt;Fcntl&lt;/code&gt; . See the documentation of your operating system's</source>
          <target state="translated">MODEパラメータの可能な値とフラグビットはシステムに依存します。これらは、標準モジュール &lt;code&gt;Fcntl&lt;/code&gt; を介して使用できます。オペレーティングシステムのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="f5b739ecc638266d58487c7c88c27f4bcc3311ca" translate="yes" xml:space="preserve">
          <source>The possibly inferred link-text; i.e., if there was no real link text, then this is the text that we'll infer in its place. (E.g., for &quot;L&amp;lt;Getopt::Std&amp;gt;&quot;, the inferred link text is &quot;Getopt::Std&quot;.)</source>
          <target state="translated">推定される可能性のあるリンクテキスト。つまり、実際のリンクテキストがない場合、これは、その場所で推測するテキストです。（たとえば、「L &amp;lt;Getopt :: Std&amp;gt;」の場合、推測されるリンクテキストは「Getopt :: Std」です。）</target>
        </trans-unit>
        <trans-unit id="4e5ec7c69ae0bd18f551874e75cc4c912902b3a0" translate="yes" xml:space="preserve">
          <source>The practice of saying, &amp;ldquo;If I had to do it all over, I&amp;rsquo;d do it differently,&amp;rdquo; and then actually going back and doing it all over differently. Mathematically speaking, it&amp;rsquo;s returning from an unsuccessful recursion on a tree of possibilities. Perl backtracks when it attempts to match patterns with a &lt;b&gt;regular expression&lt;/b&gt;, and its earlier attempts don&amp;rsquo;t pan out. See the section &amp;ldquo;The Little Engine That /Couldn(n&amp;rsquo;t)&amp;rdquo; in Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">「すべてをやり直す必要があるとしたら、私は別の方法でやる」と言って、実際に戻ってそれをすべて別の方法で行う習慣。数学的に言えば、それは可能性のツリーでの失敗した再帰から戻ってきています。Perlは、&lt;b&gt;正規表現を使用&lt;/b&gt;してパターンと一致させようとするとバックトラックし、以前の試みではうまくいきません。ラクダの第5章「パターンマッチング」の「The Little Engine That / Couldn（n't）」のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="03599d25f97c0e2d0192955c405d8519204aa81e" translate="yes" xml:space="preserve">
          <source>The practice of shifting an alphabet one or more characters for encipherment dates back thousands of years and was explicitly detailed by Gaius Julius Caesar in his &lt;b&gt;Gallic Wars&lt;/b&gt; text. A single alphabet shift is sometimes referred to as a rotation and the shift amount is given as a number $n after the string 'rot' or &quot;rot$n&quot;. Rot0 and rot26 would designate identity maps on the 26-letter English version of the Latin alphabet. Rot13 has the interesting property that alternate subsequent invocations are identity maps (thus rot13 is its own non-trivial inverse in the group of 26 alphabet rotations). Hence the following is a rot13 encoder and decoder that will work on ASCII and EBCDIC platforms:</source>
          <target state="translated">暗号化のために1文字以上のアルファベットをシフトする慣行は数千年前に遡り、Gaius Julius Caesarの&lt;b&gt;Gallic Warsの&lt;/b&gt;テキストで詳細に説明されています。 1つのアルファベットシフトはローテーションと呼ばれることもあり、シフト量は文字列 'rot'または &quot;rot $ n&quot;の後に数値$ nとして与えられます。 Rot0とrot26は、ラテン文字の26文字の英語バージョンのアイデンティティマップを指定します。 Rot13には、後続の代替呼び出しがアイデンティティマップであるという興味深い特性があります（したがって、rot13は26のアルファベット回転のグループの中でそれ自体が自明ではありません）。したがって、以下は、ASCIIおよびEBCDICプラットフォームで動作するrot13エンコーダおよびデコーダです。</target>
        </trans-unit>
        <trans-unit id="a4931fe0eefec05b185de502969d863746246773" translate="yes" xml:space="preserve">
          <source>The pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status instead of the default emulation of POSIX status described above. This pragma also disables the conversion of non-zero values to SS$_ABORT when setting &lt;code&gt;$?&lt;/code&gt; in an END block (but zero will still be converted to SS$_NORMAL).</source>
          <target state="translated">プラグマ &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; を使用して &lt;code&gt;$?&lt;/code&gt; 上記のPOSIXステータスのデフォルトのエミュレーションではなく、実際のVMS終了ステータスを反映します。このプラグマは、 &lt;code&gt;$?&lt;/code&gt; の設定時にゼロ以外の値のSS $ _ABORTへの変換も無効にします。ENDブロック内（ただし、ゼロは引き続きSS $ _NORMALに変換されます）。</target>
        </trans-unit>
        <trans-unit id="36ba59d998f30d35a2800e28be03d01cb711ce6c" translate="yes" xml:space="preserve">
          <source>The pragma was a per script, not a per block lexical. Only the last &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; mattered, and it affected &lt;b&gt;the whole script&lt;/b&gt;. However, the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; pragma was supported and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; could appear as many times as you want in a given script (though only the last was effective).</source>
          <target state="translated">プラグマはスクリプトごとであり、ブロックごとの語彙ではありませんでした。重要なのは、最後に &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; のみか &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; &lt;b&gt;、スクリプト全体&lt;/b&gt;に影響しまし&lt;b&gt;た&lt;/b&gt;。ただし、 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; プラグマはサポートされており、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; は特定のスクリプトで必要な回数だけ表示できます（ただし、最後のスクリプトのみが有効でした）。</target>
        </trans-unit>
        <trans-unit id="f8b4d970b42fbff322fe3d169272f393cc128f89" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; also might be of interest because they solve the autoupgrading/downgrading issue, at least partly.</source>
          <target state="translated">プラグマ&lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;、&lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt;、および&lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt;も、自動アップグレード/ダウングレードの問題を少なくとも部分的に解決するため、興味深いかもしれません。</target>
        </trans-unit>
        <trans-unit id="984c1d7b1bad11977f9a25ba621b51c787c8e6c4" translate="yes" xml:space="preserve">
          <source>The preamble added to each output file is rather verbose, and most of it is only necessary in the presence of non-ASCII characters. It would ideally be nice if all of those definitions were only output if needed, perhaps on the fly as the characters are used.</source>
          <target state="translated">各出力ファイルに追加されたプリアンブルはどちらかというと冗長で、そのほとんどは非ASCII文字の存在下でのみ必要とされるものです。理想的には、これらの定義のすべてが必要なときだけ出力され、おそらく文字が使われているときにその場で出力されるのがいいでしょう。</target>
        </trans-unit>
        <trans-unit id="45357f49e477501b84ee9e2077b2244c8a2bb54d" translate="yes" xml:space="preserve">
          <source>The preamble code for the class is as follows:</source>
          <target state="translated">クラスのプリアンブルコードは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b4c4542a57f99c1f10f3ac073718f1821e067ea0" translate="yes" xml:space="preserve">
          <source>The preference of the &lt;b&gt;regular expression&lt;/b&gt; engine to match the leftmost occurrence of a &lt;b&gt;pattern&lt;/b&gt;, then given a position at which a match will occur, the preference for the longest match (presuming the use of a &lt;b&gt;greedy&lt;/b&gt; quantifier). See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo; for</source>
          <target state="translated">嗜好の&lt;b&gt;正規表現&lt;/b&gt;の左端の発生と一致するようにエンジン&lt;b&gt;のパターンは&lt;/b&gt;、次に、一致が発生する位置、最長一致（の使用推定する嗜好所与&lt;b&gt;貪欲&lt;/b&gt;数量詞を）。ラクダの第5章「パターンマッチング」を参照してください。</target>
        </trans-unit>
        <trans-unit id="fb28a274f1049ea39bf5f7992f63f38b064b26ab" translate="yes" xml:space="preserve">
          <source>The preferred way to do this is to declare a plan when you &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; .</source>
          <target state="translated">これを行う好ましい方法は、 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; を&lt;a href=&quot;../functions/use&quot;&gt;使用する&lt;/a&gt;ときにプランを宣言することです。</target>
        </trans-unit>
        <trans-unit id="a070b02ec3ff7789ebf48e13bc147cc73129be84" translate="yes" xml:space="preserve">
          <source>The prefix specified by &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; will be used with a numeric suffix if the name for a value is undefined.</source>
          <target state="translated">&lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; 指定されたプレフィックスは、値の名前が未定義の場合、数値のサフィックスとともに使用されます。</target>
        </trans-unit>
        <trans-unit id="47b994ba12e424b0e632ed96c89a1498fbc470f8" translate="yes" xml:space="preserve">
          <source>The presence of the word &quot;FATAL&quot; in the category list will escalate warnings in those categories into fatal errors in that lexical scope.</source>
          <target state="translated">カテゴリリストに &quot;FATAL &quot;という単語があると、それらのカテゴリの警告は、その語彙範囲の致命的なエラーにエスカレートします。</target>
        </trans-unit>
        <trans-unit id="7069f5b0b1dc1568e108cd084477a400c3f8668e" translate="yes" xml:space="preserve">
          <source>The previous assignments are exactly equivalent to</source>
          <target state="translated">これまでの課題は、まさに</target>
        </trans-unit>
        <trans-unit id="8d4bba88bb17e91a3967206974b895243970981e" translate="yes" xml:space="preserve">
          <source>The previous example was not particularly useful. To make it more general purpose we will make use of the context data and allow any arbitrary</source>
          <target state="translated">前の例は特に有用ではありませんでした。これをより一般的なものにするために、コンテキストデータを利用し、任意の</target>
        </trans-unit>
        <trans-unit id="e9b3a0712244fd40d4ef0fb4f6b05e3de06f443f" translate="yes" xml:space="preserve">
          <source>The previous paragraph is applicable verbatim to tied hash access using the &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; functions as well.</source>
          <target state="translated">前の段落は、 &lt;code&gt;hv_store_ent&lt;/code&gt; 関数とhv_store_ent関数を使用した &lt;code&gt;hv_store&lt;/code&gt; ハッシュアクセスにそのまま適用できます。</target>
        </trans-unit>
        <trans-unit id="dd2b650563ddd2d2b6e29ef9f64d0b20b2f5e086" translate="yes" xml:space="preserve">
          <source>The previous section (introduced by a &lt;code&gt;=head&lt;/code&gt; command) does not contain any text. This usually indicates that something is missing. Note: A &lt;code&gt;=head1&lt;/code&gt; followed immediately by &lt;code&gt;=head2&lt;/code&gt; does not trigger this warning.</source>
          <target state="translated">前のセクション（ &lt;code&gt;=head&lt;/code&gt; コマンドで導入）にはテキストが含まれていません。これは通常、何かが欠落していることを示します。注： &lt;code&gt;=head1&lt;/code&gt; の直後に &lt;code&gt;=head2&lt;/code&gt; が続いても、この警告はトリガーされません。</target>
        </trans-unit>
        <trans-unit id="186c5466a670230e882670fbcd9b5aa0c0353eb4" translate="yes" xml:space="preserve">
          <source>The previous step created</source>
          <target state="translated">前のステップで作成した</target>
        </trans-unit>
        <trans-unit id="340b1d36d10dcf0bc3c98148a5a96864b33866c8" translate="yes" xml:space="preserve">
          <source>The primary cause of the 'dlopen: stub interception failed' message is that the LD_LIBRARY_PATH environment variable includes a directory which is a symlink to /usr/lib (such as /lib). See &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATH&lt;/a&gt; above.</source>
          <target state="translated">「dlopen：stub interception failed」メッセージの主な原因は、LD_LIBRARY_PATH環境変数に/ usr / lib（/ libなど）へのシンボリックリンクであるディレクトリが含まれていることです。上記の&lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATHを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6b0f3d276de0b395d904df1ee65d02fbb91e800c" translate="yes" xml:space="preserve">
          <source>The primary purpose of this module is to provide streaming write access to zip files and buffers. It is not a general-purpose file archiver. If that is what you want, check out &lt;code&gt;Archive::Zip&lt;/code&gt; .</source>
          <target state="translated">このモジュールの主な目的は、zipファイルとバッファへのストリーミング書き込みアクセスを提供することです。汎用のファイルアーカイバではありません。それが必要な場合は、 &lt;code&gt;Archive::Zip&lt;/code&gt; チェックしてください。</target>
        </trans-unit>
        <trans-unit id="0d840d1ff084fc0827d16e21e7b3094c84c9a7a3" translate="yes" xml:space="preserve">
          <source>The primary site for gzip is</source>
          <target state="translated">gzipの主要なサイトは</target>
        </trans-unit>
        <trans-unit id="76b9d6c85592a8675b44ceb172e5fcc460f2a10f" translate="yes" xml:space="preserve">
          <source>The primary site for the</source>
          <target state="translated">の主要なサイトです。</target>
        </trans-unit>
        <trans-unit id="dff39311adfb064fbb523d321b7e4b3dbea2499f" translate="yes" xml:space="preserve">
          <source>The primary site for the bzip2 program is</source>
          <target state="translated">bzip2 プログラムの主要なサイトは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="20a7ebabe8aa28f193ee803e7dabf5b8ae97c28d" translate="yes" xml:space="preserve">
          <source>The principal value of the arc tangent of y/x</source>
          <target state="translated">y/xの円弧正接の主値</target>
        </trans-unit>
        <trans-unit id="c3a6a975854cac68d0d2fce1f652f0011a15276f" translate="yes" xml:space="preserve">
          <source>The principle is that the number of objects found influences how an item is displayed. If the search finds one item, the result is displayed with the rather verbose method &lt;code&gt;as_string&lt;/code&gt; , but if more than one is found, each object is displayed with the terse method &lt;code&gt;as_glimpse&lt;/code&gt; .</source>
          <target state="translated">原則は、見つかったオブジェクトの数がアイテムの表示方法に影響を与えるということです。検索で1つのアイテムが見つかった場合、結果はかなり詳細なメソッド &lt;code&gt;as_string&lt;/code&gt; で表示されますが、複数のアイテムが見つかった場合、各オブジェクトは簡潔なメソッド &lt;code&gt;as_glimpse&lt;/code&gt; で表示されます。</target>
        </trans-unit>
        <trans-unit id="febd9a2b7b0ebfb667a62ab220755a864d89456a" translate="yes" xml:space="preserve">
          <source>The print() statement does not add field and record separators unless you set &lt;code&gt;$,&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt; . You can set $OFS and $ORS if you're using the English module.</source>
          <target state="translated">&lt;code&gt;$,&lt;/code&gt; と &lt;code&gt;$\&lt;/code&gt; を設定しない限り、print（）ステートメントはフィールドとレコードのセパレータを追加しません。英語モジュールを使用している場合は、$ OFSと$ ORSを設定できます。</target>
        </trans-unit>
        <trans-unit id="39cbd438adc424d857eb231b91cd98738e10a91c" translate="yes" xml:space="preserve">
          <source>The private data cache will take ownership of a reference to private_sv, much the same way that &lt;code&gt;hv_store()&lt;/code&gt; takes ownership of a reference to the value that you pass it.</source>
          <target state="translated">プライベートデータキャッシュは、 &lt;code&gt;hv_store()&lt;/code&gt; が渡す値への参照の所有権を取得するのとほぼ同じ方法で、private_sv への参照の所有権を取得します。</target>
        </trans-unit>
        <trans-unit id="7c29fbafe2b5b36ada501a03eca4a2fd699c674d" translate="yes" xml:space="preserve">
          <source>The private object hash keys like &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; may not be changed, but additional keys can be added, like &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; などのプライベートオブジェクトハッシュキーは変更できませんが、 &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; などの追加のキーを追加できます。</target>
        </trans-unit>
        <trans-unit id="9da35a7db7a9991be43f0a35bab375b2fa2f7661" translate="yes" xml:space="preserve">
          <source>The private variable is used to save the current locale state, so that the requisite matching call to &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt; can restore it.</source>
          <target state="translated">プライベート変数は、現在のロケールの状態を保存するために使用されます。これにより、&lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt;への一致する必要な呼び出しで復元できます。</target>
        </trans-unit>
        <trans-unit id="5290ff0dba8c2d4696fae469f418160732641247" translate="yes" xml:space="preserve">
          <source>The problem can be further examined in a roughly equivalent C program:</source>
          <target state="translated">この問題は、大まかにはC言語のプログラムでさらに検討することができます。</target>
        </trans-unit>
        <trans-unit id="13328591f6760dcc09259e6c0b9735e71fa4da38" translate="yes" xml:space="preserve">
          <source>The problem comes in when you take your numbers from something that Perl thinks is a string, such as a command line argument in &lt;code&gt;@ARGV&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;@ARGV&lt;/code&gt; のコマンドライン引数など、Perlが文字列であると考えるものから数値を取得すると、問題が発生します。</target>
        </trans-unit>
        <trans-unit id="cd8bb5622c99567256e6a98501e22410a2a7900d" translate="yes" xml:space="preserve">
          <source>The problem comes when you have, for instance, a string that isn't flagged as UTF-8, and contains a byte sequence that could be UTF-8 -- especially when combining non-UTF-8 and UTF-8 strings.</source>
          <target state="translated">問題は、例えば、UTF-8としてフラグが設定されていない文字列があり、UTF-8である可能性のあるバイト列を含んでいる場合に発生します --特に非UTF-8とUTF-8の文字列を組み合わせる場合。</target>
        </trans-unit>
        <trans-unit id="e918e6ad2cf12f5152c6540799f1ea5ccc7d457e" translate="yes" xml:space="preserve">
          <source>The problem exists because the anonymous subroutine being assigned to the &lt;code&gt;*Foo::foo&lt;/code&gt; glob will show up in the call stack as being called &lt;code&gt;__ANON__&lt;/code&gt; and not &lt;code&gt;foo&lt;/code&gt; as you might expect. Since &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; to find the name of the method it was called in, it will fail in this case.</source>
          <target state="translated">&lt;code&gt;*Foo::foo&lt;/code&gt; グロブに割り当てられている無名サブルーチンが、コールスタックに、期待どおり &lt;code&gt;foo&lt;/code&gt; ではなく &lt;code&gt;__ANON__&lt;/code&gt; として呼び出されるため、問題が発生します。ので &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 使用する &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 、それがで呼び出されたメソッドの名前を見つけるために、それはこの場合には失敗します。</target>
        </trans-unit>
        <trans-unit id="aea1a84a6e43b26958b1598b1f93e9a632b83a16" translate="yes" xml:space="preserve">
          <source>The problem here is that Uid_t might be not only not &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;-wide but it might also be unsigned, in which case large uids would be printed as negative values.</source>
          <target state="translated">ここでの問題は、Uid_tが &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 全体だけでなく、署名されていない可能性があることです。この場合、大きなuidは負の値として出力されます。</target>
        </trans-unit>
        <trans-unit id="56bc12834cd035d1009997925f3d7abe998a9788" translate="yes" xml:space="preserve">
          <source>The problem here is that both the group named &lt;code&gt;a&lt;/code&gt; and the group named &lt;code&gt;b&lt;/code&gt; are aliases for the group belonging to &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">ここでの問題は、という名前のグループの両方の点であるとという名前のグループ &lt;code&gt;b&lt;/code&gt; に属しているグループのエイリアスである &lt;code&gt;$1&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dda9a4d26fe1b0eb3aeffd7cffb748b622bb8f5f" translate="yes" xml:space="preserve">
          <source>The problem is that Perl has both compile-time and run-time warnings. To disable compile-time warnings you need to rewrite the code like this:</source>
          <target state="translated">問題は、Perlにはコンパイル時の警告と実行時の警告の両方があることです。コンパイル時の警告を無効にするには、次のようにコードを書き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="000d776ae8231195ffb025ac77c4f425f1c2ff6f" translate="yes" xml:space="preserve">
          <source>The problem is that both &lt;code&gt;rp&lt;/code&gt; and &lt;code&gt;dp&lt;/code&gt; are pointers to the same location in memory! In C, you'd have to remember to malloc() yourself some new memory. In Perl, you'll want to use the array constructor &lt;code&gt;[]&lt;/code&gt; or the hash constructor &lt;code&gt;{}&lt;/code&gt; instead. Here's the right way to do the preceding broken code fragments:</source>
          <target state="translated">問題は、 &lt;code&gt;rp&lt;/code&gt; と &lt;code&gt;dp&lt;/code&gt; の両方がメモリ内の同じ場所へのポインタであることです。 Cでは、新しいメモリを自分でmalloc（）することを覚えておく必要があります。 Perlでは、代わりに配列コンストラクター &lt;code&gt;[]&lt;/code&gt; またはハッシュコンストラクター &lt;code&gt;{}&lt;/code&gt; を使用します。上記の壊れたコードフラグメントを実行する正しい方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="44e0ee462b8e8a33d77de1117d49fdbd0c841da5" translate="yes" xml:space="preserve">
          <source>The problem is that grep builds a return list, regardless of the context. This means you're making Perl go to the trouble of building a list that you then just throw away. If the list is large, you waste both time and space. If your intent is to iterate over the list, then use a for loop for this purpose.</source>
          <target state="translated">問題は、grepはコンテキストに関係なくリターンリストを構築することです。これは、Perlにわざわざリストを構築して捨ててしまうことを意味します。リストが大きい場合は、時間とスペースの両方を無駄にしてしまいます。リストを反復処理することを目的としているのであれば、この目的のために for ループを使用してください。</target>
        </trans-unit>
        <trans-unit id="6df859dc8cac16c31baff14e80c7d840e1cb3153" translate="yes" xml:space="preserve">
          <source>The problem is that none of these examples are reliable: they depend on the command interpreter. Under Unix, the first two often work. Under DOS, it's entirely possible that neither works. If 4DOS was the command shell, you'd probably have better luck like this:</source>
          <target state="translated">問題は、これらの例はどれも信頼できるものではないということです。Unix では、最初の二つはよく動作します。DOS では、どちらも動作しない可能性があります。もし 4DOS がコマンドシェルだったら、このようにうまくいくかもしれません。</target>
        </trans-unit>
        <trans-unit id="95485cb814321ef14b952e45ddf9a35301af1a5e" translate="yes" xml:space="preserve">
          <source>The problem is that none of this is reliable: it depends on the command and it is entirely possible neither works. If</source>
          <target state="translated">問題は、これがどれも信頼できるものではないということです:これはコマンドに依存しており、どちらも動作しないことが完全にあり得ます。もし</target>
        </trans-unit>
        <trans-unit id="88377fbeaf8b4fab35329a7e374ea24a4795a7c5" translate="yes" xml:space="preserve">
          <source>The problem is that this code will always be parsed and executed, even when the debug level set in the logging configuration file is zero. Once the debug() subroutine has been entered, and the internal &lt;code&gt;$debug&lt;/code&gt; variable confirmed to be zero, for example, the message which has been sent in will be discarded and the program will continue. In the example given though, the &lt;code&gt;\%INC&lt;/code&gt; hash will already have been dumped, and the message string constructed, all of which work could be bypassed by a debug variable at the statement level, like this:</source>
          <target state="translated">問題は、ログ構成ファイルで設定されたデバッグレベルがゼロであっても、このコードが常に解析および実行されることです。たとえば、debug（）サブルーチンに入り、内部の &lt;code&gt;$debug&lt;/code&gt; 変数がゼロであることを確認すると、送信されたメッセージは破棄され、プログラムは続行します。ただし、与えられた例では、 &lt;code&gt;\%INC&lt;/code&gt; ハッシュはすでにダンプされており、メッセージ文字列が構築されています。これらの作業はすべて、次のようにステートメントレベルのデバッグ変数によってバイパスできます。</target>
        </trans-unit>
        <trans-unit id="73cae6ed898e3261e96216aa07490bc469dc51e8" translate="yes" xml:space="preserve">
          <source>The problem is that this code would</source>
          <target state="translated">問題は、このコードが</target>
        </trans-unit>
        <trans-unit id="e6af2011607132108daf874aceb7c74f8abf4357" translate="yes" xml:space="preserve">
          <source>The problem is that those double-quotes force stringification--coercing numbers and references into strings--even when you don't want them to be strings. Think of it this way: double-quote expansion is used to produce new strings. If you already have a string, why do you need more?</source>
          <target state="translated">問題は、それらの二重引用符は、文字列化を強制するということです。このように考えてみてください:二重引用符の展開は新しい文字列を生成するために使われます。すでに文字列を持っているなら、なぜそれ以上の文字列が必要なのでしょうか?</target>
        </trans-unit>
        <trans-unit id="d0f76e9ccc888898fb7c8d297bdf6217c3b3b765" translate="yes" xml:space="preserve">
          <source>The problem is that various structures visible via procfs use off_t, and if you compile with largefile support these change from 32 bits to 64 bits. Thus what you get back from procfs doesn't match up with the structures in perl, resulting in garbage. See proc(4) for further discussion.</source>
          <target state="translated">問題は、procfs を通じて表示される様々な構造体が off_t を使用していることで、ラージファイルをサポートしてコンパイルした場合、これらの構造体は 32 ビットから 64 ビットに変更されてしまいます。そのため、procfs から得られるものは perl の構造体とは一致せず、結果としてゴミとなってしまいます。さらなる議論は proc(4)を参照してください。</target>
        </trans-unit>
        <trans-unit id="fc4b1a9098877c5f0dfd053c053f3947a9421580" translate="yes" xml:space="preserve">
          <source>The problem is the nested indeterminate quantifiers. There are many different ways of partitioning a string of length n between the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; : one repetition with &lt;code&gt;b+&lt;/code&gt; of length n, two repetitions with the first &lt;code&gt;b+&lt;/code&gt; length k and the second with length n-k, m repetitions whose bits add up to length n, etc. In fact there are an exponential number of ways to partition a string as a function of its length. A regexp may get lucky and match early in the process, but if there is no match, Perl will try</source>
          <target state="translated">問題は、入れ子になった不定数量詞です。 &lt;code&gt;+&lt;/code&gt; と &lt;code&gt;*&lt;/code&gt; の間で長さnの文字列を分割する方法は数多くあります。長さnの &lt;code&gt;b+&lt;/code&gt; で1回繰り返し、最初の &lt;code&gt;b+&lt;/code&gt; 長さk で2回繰り返し、長さnkで2回繰り返し、ビットが長さnになるm回の繰り返しなど。実際には、文字列をその長さの関数として分割する方法は指数関数的に多数あります。正規表現は幸運になってプロセスの早い段階で一致する可能性がありますが、一致しない場合、Perlは</target>
        </trans-unit>
        <trans-unit id="57ef8306dabb66b8a3dd5849936f56c155cd391f" translate="yes" xml:space="preserve">
          <source>The problem is usually that the command interpreters on those systems have rather different ideas about quoting than the Unix shells under which the one-liners were created. On some systems, you may have to change single-quotes to double ones, which you must</source>
          <target state="translated">問題は通常、これらのシステムのコマンドインタプリタが、ワンライナーが作成されたUnixシェルとは、引用符についての考え方がかなり異なっていることです。システムによっては、シングルクォートをダブルクォートに変更しなければならない場合があります。</target>
        </trans-unit>
        <trans-unit id="5ee9f00b1299262770f29ccbf33382cfb01278a2" translate="yes" xml:space="preserve">
          <source>The problem with this is that buffering is really going to ruin your day. Even though your &lt;code&gt;Writer&lt;/code&gt; filehandle is auto-flushed so the process on the other end gets your data in a timely manner, you can't usually do anything to force that process to give its data to you in a similarly quick fashion. In this special case, we could actually so, because we gave</source>
          <target state="translated">これの問題は、バッファリングが本当にあなたの一日を台無しにしてしまうことです。あなたにもかかわらず &lt;code&gt;Writer&lt;/code&gt; もう一方の端のプロセスがタイムリーにあなたのデータを取得するように、ファイルハンドルを自動フラッシュされ、あなたは通常、同様に迅速な方法であなたにそのデータを提供するために、そのプロセスを強制的に何もすることはできません。この特別なケースでは、実際にそうすることができました。</target>
        </trans-unit>
        <trans-unit id="f6f3b81b70ac61e4574d6ebcd3e976b1d72049f0" translate="yes" xml:space="preserve">
          <source>The problems of garbage collection and thread safety are both addressed by the function &lt;code&gt;register()&lt;/code&gt; . It registers an object together with any number of hashes. Registry means that when the object dies, an entry in any of the hashes under the reference address of this object will be deleted. This guarantees garbage collection in these hashes. It also means that on thread cloning the object's entries in registered hashes will be replaced with updated entries whose key is the cloned object's reference address. Thus the object-data association becomes thread-safe.</source>
          <target state="translated">ガベージコレクションとスレッドセーフの問題は、どちらも関数 &lt;code&gt;register()&lt;/code&gt; によって対処されます。オブジェクトを任意の数のハッシュと一緒に登録します。レジストリは、オブジェクトが死ぬと、このオブジェクトの参照アドレスの下にあるハッシュのエントリが削除されることを意味します。これにより、これらのハッシュでのガベージコレクションが保証されます。また、スレッドの複製時に、登録されたハッシュのオブジェクトのエントリが、複製されたオブジェクトの参照アドレスをキーとする更新されたエントリに置き換えられることも意味します。したがって、オブジェクトとデータの関連付けはスレッドセーフになります。</target>
        </trans-unit>
        <trans-unit id="95e6fb31b348934a4b1c0d293aa560867eaa2c02" translate="yes" xml:space="preserve">
          <source>The process number of the Perl running this script. Though you</source>
          <target state="translated">このスクリプトを実行しているPerlのプロセス番号。このスクリプトを実行しているPerlのプロセス番号です。</target>
        </trans-unit>
        <trans-unit id="b93ffa0ee1718038fedc8009038c2d7f70371455" translate="yes" xml:space="preserve">
          <source>The process of converting a string to one of the four Unicode &lt;b&gt;casemaps&lt;/b&gt;; in Perl, it is implemented with the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">文字列を4つのUnicode &lt;b&gt;ケースマップの&lt;/b&gt; 1つに変換するプロセス。 Perlでは、これは &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; 関数で実装されます。</target>
        </trans-unit>
        <trans-unit id="2cf36cd26c284e1c84d9c66a1a4b1fbb69c4ead2" translate="yes" xml:space="preserve">
          <source>The process of determining what method should be used is called &lt;b&gt;method resolution&lt;/b&gt;. What Perl does is look at the object's class first (&lt;code&gt;File::MP3&lt;/code&gt; in this case). If that class defines the method, then that class's version of the method is called. If not, Perl looks at each parent class in turn. For &lt;code&gt;File::MP3&lt;/code&gt; , its only parent is &lt;code&gt;File&lt;/code&gt; . If &lt;code&gt;File::MP3&lt;/code&gt; does not define the method, but &lt;code&gt;File&lt;/code&gt; does, then Perl calls the method in &lt;code&gt;File&lt;/code&gt; .</source>
          <target state="translated">使用するメソッドを決定するプロセスは、&lt;b&gt;メソッド解決&lt;/b&gt;と呼ばれ&lt;b&gt;ます&lt;/b&gt;。Perlが行うことは、最初にオブジェクトのクラス（この場合は &lt;code&gt;File::MP3&lt;/code&gt; ）を調べることです。そのクラスがメソッドを定義している場合、そのクラスのメソッドのバージョンが呼び出されます。そうでない場合、Perlは各親クラスを順番に調べます。以下のために &lt;code&gt;File::MP3&lt;/code&gt; 、その唯一の親がある &lt;code&gt;File&lt;/code&gt; 。場合は &lt;code&gt;File::MP3&lt;/code&gt; メソッドを定義していませんが、 &lt;code&gt;File&lt;/code&gt; ない場合、Perlはでメソッドを呼び出し &lt;code&gt;File&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="080ae8ae51ff51ae8e5ac989879f84eb0a78985b" translate="yes" xml:space="preserve">
          <source>The process of gluing one cat&amp;rsquo;s nose to another cat&amp;rsquo;s tail. Also a similar operation on two &lt;b&gt;strings&lt;/b&gt;.</source>
          <target state="translated">1つの猫の鼻を別の猫の尻尾に接着するプロセス。2つの&lt;b&gt;文字列&lt;/b&gt;に対する同様の操作。</target>
        </trans-unit>
        <trans-unit id="908f91e0beaa0a05d55f4dc47581a39df63d9d61" translate="yes" xml:space="preserve">
          <source>The process of producing a &lt;b&gt;string&lt;/b&gt; representation of an abstract object.</source>
          <target state="translated">抽象オブジェクトの&lt;b&gt;文字列&lt;/b&gt;表現を生成するプロセス。</target>
        </trans-unit>
        <trans-unit id="3e1e79f73acf8d324572f017b3dffb010974336f" translate="yes" xml:space="preserve">
          <source>The process of trying one alternative, seeing if it matches, and moving on to the next alternative, while going back in the string from where the previous alternative was tried, if it doesn't, is called</source>
          <target state="translated">一つの代替案を試してみて、それが一致するかどうかを確認して、次の代替案に移って、もし一致しなければ、前の代替案が試されたところから文字列をさかのぼりながら、次の代替案に移るというプロセスは、以下のように呼ばれます。</target>
        </trans-unit>
        <trans-unit id="74fa9d2e4258275e6ce9c275f9e0e82d2661aeb2" translate="yes" xml:space="preserve">
          <source>The process of turning source code into a machine-usable form. See &lt;b&gt;compile phase&lt;/b&gt;.</source>
          <target state="translated">ソースコードをマシンで使用可能な形式に変換するプロセス。&lt;b&gt;コンパイルフェーズを&lt;/b&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cc5a52491b0f391cb1ad331e975b3decd008b51b" translate="yes" xml:space="preserve">
          <source>The program can be made to run by &quot;laundering&quot; the tainted value through a regular expression: the second example--which still ignores locale information--runs, creating the file named on its command line if it can.</source>
          <target state="translated">プログラムは、正規表現を使って汚染された値を &quot;ロンダリング &quot;することで実行させることができます。 2 番目の例では、ロケール情報を無視していますが、可能であればコマンドライン上に名前のついたファイルを作成して実行します。</target>
        </trans-unit>
        <trans-unit id="71e8e6b13bea2c8688fa8edfd4a4d7df9ffed609" translate="yes" xml:space="preserve">
          <source>The program crashes, &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;s, calls &lt;code&gt;closelog&lt;/code&gt; , the log is over.</source>
          <target state="translated">プログラムがクラッシュし、 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; sが、呼び出す &lt;code&gt;closelog&lt;/code&gt; ログは終わりました、。</target>
        </trans-unit>
        <trans-unit id="9f6e033c5ffe643ac5235dd0c4de96e8993b109b" translate="yes" xml:space="preserve">
          <source>The program h2xs is the starting point for creating extensions. In later examples we'll see how we can use h2xs to read header files and generate templates to connect to C routines.</source>
          <target state="translated">プログラム h2xs は,拡張機能を作成するための出発点となるものです.後の例では,ヘッダファイルを読み込んだり,Cルーチンに接続するためのテンプレートを生成したりするためにh2xsをどのように使うかを見ていきましょう.</target>
        </trans-unit>
        <trans-unit id="6480e775a128a11d00bdb33611f7cc04c69a6a31" translate="yes" xml:space="preserve">
          <source>The program has two pieces: Lines 2--7 read the input and build a data structure, and lines 8-13 analyze the data and print out the report. We're going to have a hash, &lt;code&gt;%table&lt;/code&gt; , whose keys are country names, and whose values are references to arrays of city names. The data structure will look like this:</source>
          <target state="translated">プログラムには2つの部分があります。2行目から7行目は入力を読み取ってデータ構造を構築し、8行目から13行目はデータを分析してレポートを印刷します。ハッシュ &lt;code&gt;%table&lt;/code&gt; を作成します。そのキーは国名で、その値は都市名の配列への参照です。データ構造は次のようになります。</target>
        </trans-unit>
        <trans-unit id="d46a6e0b6bbf3d5823709dce22271813109f1ce6" translate="yes" xml:space="preserve">
          <source>The program is represented by an array of &lt;code&gt;regnode&lt;/code&gt; structures, one or more of which represent a single regop of the program. Struct &lt;code&gt;regnode&lt;/code&gt; is the smallest struct needed, and has a field structure which is shared with all the other larger structures.</source>
          <target state="translated">プログラムは、 &lt;code&gt;regnode&lt;/code&gt; 構造の配列で表されます。その1つ以上がプログラムの単一のレゴを表します。構造体 &lt;code&gt;regnode&lt;/code&gt; は、必要な最小の構造体であり、他のすべての大きな構造体と共有されるフィールド構造を持っています。</target>
        </trans-unit>
        <trans-unit id="135fe1206adbfe007b6735c772853b1eaf66848e" translate="yes" xml:space="preserve">
          <source>The program must take care to ensure that this takes place</source>
          <target state="translated">プログラムは、これが確実に行われるように注意しなければなりません。</target>
        </trans-unit>
        <trans-unit id="c1da64105b623d7426e31c12654e36ae7053e949" translate="yes" xml:space="preserve">
          <source>The program took just over 17 wallclock seconds to run. Note the different values &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; outputs, it's important to always use the same one, and to not confuse what each one means.</source>
          <target state="translated">プログラムの実行には17壁時計秒強かかりました。 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 出力が異なることに注意してください。常に同じ値を使用し、それぞれの意味を混同しないようにすることが重要です。</target>
        </trans-unit>
        <trans-unit id="8912a00ba87d6cbf5df35a3207c6a72bfeb3c965" translate="yes" xml:space="preserve">
          <source>The program will halt</source>
          <target state="translated">プログラムは停止します</target>
        </trans-unit>
        <trans-unit id="267c6b23ea1ed3936b0ecbfc44abd9e2d8aa3502" translate="yes" xml:space="preserve">
          <source>The programming interface is easy to use: it's the same one found in CPAN's &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; module. So, if your applications currently use &lt;a href=&quot;md5&quot;&gt;Digest::MD5&lt;/a&gt; and you'd prefer the stronger security of SHA, it's a simple matter to convert them.</source>
          <target state="translated">プログラミングインターフェイスは使いやすく、CPANの&lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt;モジュールにあるものと同じです。したがって、アプリケーションで現在&lt;a href=&quot;md5&quot;&gt;Digest :: MD5&lt;/a&gt;を使用していて、SHAのより強力なセキュリティを希望する場合は、変換するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="d0f12348b1996ab0ae0eb3467409b46f3ff517e5" translate="yes" xml:space="preserve">
          <source>The programs and documentation in this dist are distributed in the hope that they will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</source>
          <target state="translated">この dist に含まれるプログラムとドキュメントは、それらが有用であることを願って配布されていますが、いかなる保証もなく、商品性や特定の目的への適合性についての暗黙の保証もありません。</target>
        </trans-unit>
        <trans-unit id="3b63891b0a81b9b51c173bac879417506124032c" translate="yes" xml:space="preserve">
          <source>The prompt of the cpan shell can contain the current command number for easier tracking of the session or be a plain string.</source>
          <target state="translated">cpan シェルのプロンプトには、セッションの追跡を容易にするために、現在のコマンド番号を含むこともできますし、プレーンな文字列にすることもできます。</target>
        </trans-unit>
        <trans-unit id="a9cf8b59c024e83e18267b0f8a6518d4ffcc35fc" translate="yes" xml:space="preserve">
          <source>The property of lowercase before uppercase letters in EBCDIC is even carried to the Latin 1 EBCDIC pages such as 0037 and 1047. An example would be that &quot;&amp;Euml;&quot; (&lt;code&gt;E WITH DIAERESIS&lt;/code&gt; , 203) comes before &quot;&amp;euml;&quot; (&lt;code&gt;e WITH DIAERESIS&lt;/code&gt; , 235) on an ASCII platform, but the latter (83) comes before the former (115) on an EBCDIC platform. (Astute readers will note that the uppercase version of &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; is simply &quot;SS&quot; and that the upper case versions of &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt; ) are not in the 0..255 range but are in Unicode, in a Unicode enabled Perl).</source>
          <target state="translated">EBCDICの大文字の前の小文字のプロパティは、0037や1047などのLatin 1 EBCDICページにも適用されます。たとえば、「&amp;Euml;」（ &lt;code&gt;E WITH DIAERESIS&lt;/code&gt; 、203）が「&amp;euml;」（ &lt;code&gt;e WITH DIAERESIS&lt;/code&gt; 、235 ）はASCIIプラットフォーム上ですが、後者（83）はEBCDICプラットフォーム上の前者（115）よりも前です。（賢い読者は、大文字のバージョンの &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; は単に &quot;SS&quot;であり、大文字のバージョンの &quot;&amp;yuml;&quot;（ &lt;code&gt;y WITH DIAERESIS&lt;/code&gt; ）および &quot;&amp;micro;&quot;（ &lt;code&gt;MICRO SIGN&lt;/code&gt; 記号）は、 0..255の範囲ですが、Unicodeです（Unicode対応のPerl）。</target>
        </trans-unit>
        <trans-unit id="09b7c3443c95713bb7f5c3a34ea900a666d3209c" translate="yes" xml:space="preserve">
          <source>The protocol (e.g. &lt;code&gt;IPPROTO_TCP&lt;/code&gt; )</source>
          <target state="translated">プロトコル（例： &lt;code&gt;IPPROTO_TCP&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="16c98cd2a0bd15be4f172d1ada9a2ed6c4ba31c3" translate="yes" xml:space="preserve">
          <source>The protocol also defines several standard &lt;b&gt;translations&lt;/b&gt; which the file can undergo during transfer. These are ASCII, EBCDIC, binary, and byte. ASCII is the default type, and indicates that the sender of files will translate the ends of lines to a standard representation which the receiver will then translate back into their local representation. EBCDIC indicates the file being transferred is in EBCDIC format. Binary (also known as image) format sends the data as a contiguous bit stream. Byte format transfers the data as bytes, the values of which remain the same regardless of differences in byte size between the two machines (in theory - in practice you should only use this if you really know what you're doing). This class does not support the EBCDIC or byte formats, and will default to binary instead if they are attempted.</source>
          <target state="translated">プロトコルはいくつかの標準&lt;b&gt;翻訳&lt;/b&gt;も定義しています&lt;b&gt;&lt;/b&gt;転送中にファイルが受ける可能性のあるもの。これらは、ASCII、EBCDIC、バイナリ、およびバイトです。 ASCIIがデフォルトのタイプであり、ファイルの送信者が行の終わりを標準表現に変換し、受信者が標準表現に変換してローカル表現に戻すことを示します。 EBCDICは、転送されるファイルがEBCDIC形式であることを示します。バイナリ（イメージとも呼ばれます）形式は、データを連続したビットストリームとして送信します。バイト形式はデータをバイトとして転送し、その値は2つのマシン間のバイトサイズの違いに関係なく同じままです（理論的には、実際にこれを使用するのは、自分が何をしているのか本当にわかっている場合のみです）。このクラスはEBCDICまたはバイト形式をサポートしていないため、試行された場合はデフォルトでバイナリに設定されます。</target>
        </trans-unit>
        <trans-unit id="3e54303b3641a865f35ca39d2a398386ca07567a" translate="yes" xml:space="preserve">
          <source>The prototype CV for a 'my' sub.</source>
          <target state="translated">俺の」サブのプロトタイプCV。</target>
        </trans-unit>
        <trans-unit id="11a1d81ab8f0f4c68c1c261efa58242791ed97cf" translate="yes" xml:space="preserve">
          <source>The prototype attribute, and any other attributes, come after the signature.</source>
          <target state="translated">プロトタイプ属性やその他の属性は、シグネチャの後に来ます。</target>
        </trans-unit>
        <trans-unit id="420268bbe69f10bd1b6ed7fa6d80a149e32d8a64" translate="yes" xml:space="preserve">
          <source>The prototype from the attribute is assigned to the sub immediately after the prototype from the sub, which means that if both are declared at the same time, the traditionally defined prototype is ignored. In other words, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; is indistinguishable from &lt;code&gt;sub foo(@){}&lt;/code&gt; .</source>
          <target state="translated">属性のプロトタイプは、サブのプロトタイプの直後にサブに割り当てられます。つまり、両方が同時に宣言された場合、従来定義されていたプロトタイプは無視されます。つまり、 &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; は &lt;code&gt;sub foo(@){}&lt;/code&gt; と区別できません。</target>
        </trans-unit>
        <trans-unit id="d6eb998a9749fabedff565e15bacf235434a61b2" translate="yes" xml:space="preserve">
          <source>The provided argument MUST be equal to the string for the validation to pass.</source>
          <target state="translated">与えられた引数は、通過するバリデーションのための文字列と等しくなければなりません(MUST)。</target>
        </trans-unit>
        <trans-unit id="113c257205a6110f9be3ea8173531d90a26a925b" translate="yes" xml:space="preserve">
          <source>The provided argument MUST equal one of the elements of the array ref for the validation to pass. An array ref can hold all the above values.</source>
          <target state="translated">与えられた引数は、検証を通過させるために配列 ref の要素のうちの 1 つと等しくなければなりません(MUST)。配列 ref は上記のすべての値を保持することができます。</target>
        </trans-unit>
        <trans-unit id="f0175fe813dc359c6d5d92da9a9b07e142152ec0" translate="yes" xml:space="preserve">
          <source>The provided argument MUST match the regular expression for the validation to pass.</source>
          <target state="translated">指定された引数は、通過するバリデーションの正規表現と一致しなければなりません(MUST)。</target>
        </trans-unit>
        <trans-unit id="7028c08ff6edd9122ed07f747d04ab21bb6b6da9" translate="yes" xml:space="preserve">
          <source>The provided subroutine MUST return true in order for the validation to pass and the argument accepted.</source>
          <target state="translated">提供されるサブルーチンは、検証が通過し、引数が受け入れられるようにするためには、trueを返さなければなりません(MUST)。</target>
        </trans-unit>
        <trans-unit id="93c41fbabb74d3c7cddc4b5e78899f8faa1b1f17" translate="yes" xml:space="preserve">
          <source>The pseudo-hash feature was an experimental feature introduced in earlier versions of Perl and removed in 5.10.0. A pseudo-hash is an array reference which can be accessed using named keys like a hash. You may run in to some code in the wild which uses it. See the &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma for more information.</source>
          <target state="translated">疑似ハッシュ機能は、以前のバージョンのPerlで導入された実験的な機能であり、5.10.0で削除されました。疑似ハッシュは、ハッシュのような名前付きキーを使用してアクセスできる配列参照です。あなたはそれを使う野生のコードに出くわすかもしれません。詳細については、&lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt;プラグマを参照してください。</target>
        </trans-unit>
        <trans-unit id="2c3bf5ebc790603d27cda992131fe6f16a627371" translate="yes" xml:space="preserve">
          <source>The public API must remain consistent, i.e. if a sub-class is overloading addition, the sub-class must use the same name, in this case badd(). The reason for this is that Math::BigInt is optimized to call the object methods directly.</source>
          <target state="translated">つまり、サブクラスが加算をオーバーロードしている場合、サブクラスは同じ名前、この場合は badd()を使用しなければなりません。これは Math::BigInt がオブジェクトメソッドを直接呼び出すように最適化されているためです。</target>
        </trans-unit>
        <trans-unit id="dc2995512c58b9b2e35d09bc546dc5a7fbc84663" translate="yes" xml:space="preserve">
          <source>The purpose of the macro &lt;code&gt;SPAGAIN&lt;/code&gt; is to refresh the local copy of the stack pointer. This is necessary because it is possible that the memory allocated to the Perl stack has been reallocated during the</source>
          <target state="translated">マクロ &lt;code&gt;SPAGAIN&lt;/code&gt; の目的は、スタックポインターのローカルコピーを更新することです。これは、Perlスタックに割り当てられたメモリが、</target>
        </trans-unit>
        <trans-unit id="b29cd6102fd964c85b9f311d0c28db3fab69123d" translate="yes" xml:space="preserve">
          <source>The purpose of the testing is twofold: one, to help developers fix any problems in their code that crop up because of lack of testing on other platforms; two, to provide users with information about whether a given module works on a given platform.</source>
          <target state="translated">1つは、他のプラットフォームでのテストが不足しているために発生したコードの問題を開発者が修正できるようにすること、もう1つは、特定のモジュールが特定のプラットフォームで動作するかどうかについての情報をユーザに提供することです。</target>
        </trans-unit>
        <trans-unit id="843821edac19011f1a6d1c830e78298f0013f7a5" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to show you how to call Perl subroutines directly from C, i.e., how to write</source>
          <target state="translated">このドキュメントの目的は、PerlのサブルーチンをCから直接呼び出す方法、つまり</target>
        </trans-unit>
        <trans-unit id="414e7fd5b34fea33393baf5db076f7ff8658e79f" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to provide a wide range of testing utilities. Various ways to say &quot;ok&quot; with better diagnostics, facilities to skip tests, test future features and compare complicated data structures. While you can do almost anything with a simple &lt;code&gt;ok()&lt;/code&gt; function, it doesn't provide good diagnostic output.</source>
          <target state="translated">このモジュールの目的は、幅広いテストユーティリティを提供することです。優れた診断機能、テストをスキップする機能、将来の機能をテストする機能、複雑なデータ構造を比較する機能で「大丈夫」と言うさまざまな方法。単純な &lt;code&gt;ok()&lt;/code&gt; 関数でほとんど何でも実行できますが、適切な診断出力は提供されません。</target>
        </trans-unit>
        <trans-unit id="9bfc8ef428f97c3f3e1176a68cf8e1112929bebf" translate="yes" xml:space="preserve">
          <source>The purpose, scope and target applications of your module</source>
          <target state="translated">モジュールの目的、範囲、ターゲットアプリケーション</target>
        </trans-unit>
        <trans-unit id="ddc9dd67da090624c445edfafa6830e5bccd4e64" translate="yes" xml:space="preserve">
          <source>The quality that makes you go to great effort to reduce overall energy expenditure. It makes you write labor-saving programs that other people will find useful, and then document what you wrote so you don&amp;rsquo;t have to answer so many questions about it. Hence, the first great virtue of a programmer. Also hence, this book. See also &lt;b&gt;impatience&lt;/b&gt; and &lt;b&gt;hubris&lt;/b&gt;.</source>
          <target state="translated">全体的なエネルギー消費を削減するために多大な努力を払わせる品質。他の人が役に立つと思う省力化プログラムを書いて、それからあなたが書いたものを文書化するので、それに関する多くの質問に答える必要はありません。したがって、プログラマーの最初の大きな美徳。また、したがって、この本。&lt;b&gt;焦り&lt;/b&gt;や&lt;b&gt;傲慢&lt;/b&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="52d7089e85ac35a7092bc58942f32bee7ca90b8d" translate="yes" xml:space="preserve">
          <source>The question of string equivalence turns somewhat complicated in Unicode: what do you mean by &quot;equal&quot;?</source>
          <target state="translated">文字列の等価性の問題は、ユニコードではやや複雑になります:「等価」とは何を意味するのでしょうか?</target>
        </trans-unit>
        <trans-unit id="f2a24b3b2648553142b8c5a0c4598996a73f792a" translate="yes" xml:space="preserve">
          <source>The question remains on when the SVs which are</source>
          <target state="translated">疑問が残るのは、いつになったら</target>
        </trans-unit>
        <trans-unit id="099c0ce39a19f948a86d0ea40fc49e8ea2b14385" translate="yes" xml:space="preserve">
          <source>The question, of course, is why would you do something like this? Why create a semaphore with a starting count that's not one, or why decrement or increment it by more than one? The answer is resource availability. Many resources that you want to manage access for can be safely used by more than one thread at once.</source>
          <target state="translated">もちろん問題は、なぜこのようなことをするのかということです。なぜ開始カウントが1ではないセマフォを作るのか、なぜそれを1以上デクリメントしたりインクリメントしたりするのか?答えはリソースの可用性です。アクセスを管理したいリソースの多くは、一度に複数のスレッドで安全に使用することができます。</target>
        </trans-unit>
        <trans-unit id="551d1aa8a1248eaf53c1cd9d606d72ab7488cd21" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty method only works well when you don't plan to leave the commented code in the source. If a Pod parser comes along, your multiline comment is going to show up in the Pod translation. A better way hides it from Pod parsers as well.</source>
          <target state="translated">この方法がうまく機能するのは、コメント付きのコードをソースに残す予定がない場合だけです。Podパーサーが現れた場合、あなたの複数行コメントがPod翻訳に表示されてしまいます。より良い方法は、Podパーサーからも隠すことができます。</target>
        </trans-unit>
        <trans-unit id="a41d7294035834639b17968992ffda16ae85e9a1" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty way to comment out more than one line of Perl is to surround those lines with Pod directives. You have to put these directives at the beginning of the line and somewhere where Perl expects a new statement (so not in the middle of statements like the &lt;code&gt;#&lt;/code&gt; comments). You end the comment with &lt;code&gt;=cut&lt;/code&gt; , ending the Pod section:</source>
          <target state="translated">Perlの複数の行をコメントアウトする手っ取り早い方法は、それらの行をPodディレクティブで囲むことです。これらのディレクティブは、行の先頭と、Perlが新しいステートメントを予期する場所（つまり、 &lt;code&gt;#&lt;/code&gt; コメントなどのステートメントの途中ではない場所）に配置する必要があります。コメントは &lt;code&gt;=cut&lt;/code&gt; で終了し、ポッドセクションを終了します。</target>
        </trans-unit>
        <trans-unit id="0c2f3594848e5558e5b1bcd7932b24c116883439" translate="yes" xml:space="preserve">
          <source>The quotient is always the greatest integer less than or equal to the real-valued quotient of the two operands, and the remainder (when it is non-zero) always has the same sign as the second operand; so, for example,</source>
          <target state="translated">商は常に2つのオペランドの実数商以下の最大の整数であり、余剰(それが0でない場合)は常に2番目のオペランドと同じ符号を持ちます。</target>
        </trans-unit>
        <trans-unit id="04db20aec07e3c7b83de9b23243f0bb2ef9f279e" translate="yes" xml:space="preserve">
          <source>The random characters are provided by File::Temp and ensure that each module's individual build directory is unique. This makes running CPAN.pm in concurrent processes simultaneously safe.</source>
          <target state="translated">ランダムな文字は File::Temp によって提供され、各モジュールの個別のビルドディレクトリが一意であることを保証します。これにより、CPAN.pm を同時並行プロセスで同時に実行することが安全になります。</target>
        </trans-unit>
        <trans-unit id="054e3d7058644b114207f253c83eb2c8a141a8e1" translate="yes" xml:space="preserve">
          <source>The range operator (in list context) makes use of the magical auto-increment algorithm if the operands are strings. You can say</source>
          <target state="translated">range演算子(リストコンテキスト)は、オペランドが文字列である場合、魔法のオートインクリメントアルゴリズムを使用します。以下のように言うことができます。</target>
        </trans-unit>
        <trans-unit id="4828534433b64aecd95537d37d705a006ad5851e" translate="yes" xml:space="preserve">
          <source>The range operator &lt;code&gt;..&lt;/code&gt; cannot be overloaded.</source>
          <target state="translated">範囲演算子 &lt;code&gt;..&lt;/code&gt; はオーバーロードできません。</target>
        </trans-unit>
        <trans-unit id="bc508fe7a659eeced29e856ebc7b8d62470c6bbb" translate="yes" xml:space="preserve">
          <source>The range operator also works on strings, using the magical auto-increment, see below.</source>
          <target state="translated">範囲演算子は文字列に対しても動作します。</target>
        </trans-unit>
        <trans-unit id="e7f8ca3eb25d07981f64e697003d81f247478aa9" translate="yes" xml:space="preserve">
          <source>The range operator is &quot;..&quot;, not comma. The comma operator works as in C.</source>
          <target state="translated">範囲演算子はカンマではなく「...」です。カンマ演算子はC言語と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="6b43593ef7e3f96c529ec6f6490c77d15e8ee949" translate="yes" xml:space="preserve">
          <source>The range operator is &lt;code&gt;...&lt;/code&gt; , rather than comma.</source>
          <target state="translated">範囲演算子は、コンマではなく &lt;code&gt;...&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="272be5d09f375bcf2f8787674ae6b79aa38f8abf" translate="yes" xml:space="preserve">
          <source>The rationale for requiring this is to not break older programs that rely on the way things worked before Unicode came along. Those older programs knew only about the ASCII character set, and so may not work properly for additional characters. When a string is encoded in UTF-8, Perl assumes that the program is prepared to deal with Unicode, but when the string isn't, Perl assumes that only ASCII is wanted, and so those characters that are not ASCII characters aren't recognized as to what they would be in Unicode. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; tells Perl to treat all characters as Unicode, whether the string is encoded in UTF-8 or not, thus avoiding the problem.</source>
          <target state="translated">これを要求する根拠は、Unicodeが登場する前に物事が機能する方法に依存する古いプログラムを壊さないことです。これらの古いプログラムはASCII文字セットのみを認識していたため、追加の文字に対しては正しく機能しない可能性があります。文字列がUTF-8でエンコードされている場合、PerlはプログラムがUnicodeを処理する準備ができていると想定しますが、文字列がエンコードされていない場合、PerlはASCIIのみが必要であると想定し、ASCII文字以外の文字は不要ですそれらがユニコードでどうなるかについて認識されました。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;すると、文字列がUTF-8でエンコードされているかどうかに関係なく、すべての文字をUnicodeとして扱うようにPerlに指示し、問題を回避します。</target>
        </trans-unit>
        <trans-unit id="62a00a9112198d60e9e6e148f4efbf8b5c8bde2f" translate="yes" xml:space="preserve">
          <source>The raw original L&amp;lt;...&amp;gt; content, before text is split on &quot;|&quot;, &quot;/&quot;, etc, and before E&amp;lt;...&amp;gt; codes are expanded.</source>
          <target state="translated">テキストが「|」、「/」などで分割される前、およびE &amp;lt;...&amp;gt;コードが展開される前の元の元のL &amp;lt;...&amp;gt;コンテンツ。</target>
        </trans-unit>
        <trans-unit id="16f6921cb27bb9d796f9843804daa8d9f88db314" translate="yes" xml:space="preserve">
          <source>The read-only magic variable &lt;code&gt;${^UNICODE}&lt;/code&gt; reflects the numeric value of this setting. This variable is set during Perl startup and is thereafter read-only. If you want runtime effects, use the three-arg open() (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;), the two-arg binmode() (see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;), and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;).</source>
          <target state="translated">読み取り専用のマジック変数 &lt;code&gt;${^UNICODE}&lt;/code&gt; は、この設定の数値を反映しています。この変数は、Perlの起動時に設定され、その後は読み取り専用になります。ランタイム効果が必要な場合は、3つの引数のopen（）（&lt;a href=&quot;functions/open&quot;&gt;openを&lt;/a&gt;参照）、2つの引数のbinmode（）（&lt;a href=&quot;functions/binmode&quot;&gt;binmodeを&lt;/a&gt;参照）、および &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; プラグマ（&lt;a href=&quot;open&quot;&gt;openを&lt;/a&gt;参照）を使用してください。</target>
        </trans-unit>
        <trans-unit id="8ac185b6e70958a0bc2daae47b4a77ca571d1fad" translate="yes" xml:space="preserve">
          <source>The real gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getgid()&lt;/code&gt; , and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt; , one of which may be the same as the first number.</source>
          <target state="translated">このプロセスの本当のgid。あなたは、同時に複数のグループでのサポートメンバーシップは、スペースを与えることをマシン上にある場合は、あなたがしているグループのリストを区切ります。最初の数はで返さ一つです &lt;code&gt;getgid()&lt;/code&gt; によると、それに続くもの &lt;code&gt;getgroups()&lt;/code&gt; 、5月の1最初の番号と同じである。</target>
        </trans-unit>
        <trans-unit id="c41410f8fa129356669d6ff84f5e22cd64e4d0cb" translate="yes" xml:space="preserve">
          <source>The real sequence number of the OP, as a regular number and not adjusted to be relative to the start of the real program. (This will generally be a fairly large number because all of &lt;b&gt;B::Concise&lt;/b&gt; is compiled before your program is).</source>
          <target state="translated">OPの実際のシーケンス番号。通常の番号であり、実際のプログラムの開始を基準にして調整されることはありません。（&lt;b&gt;B :: Concise&lt;/b&gt;はすべてプログラムの前にコンパイルされるため、これは通常かなり大きな数になります）。</target>
        </trans-unit>
        <trans-unit id="520aa3cfc6d3d06d2079bcf3cd80538cdc94136b" translate="yes" xml:space="preserve">
          <source>The real time timing is done using time(2) and the granularity is therefore only one second.</source>
          <target state="translated">リアルタイムのタイミングはtime(2)を使用して行われるため、粒度は1秒しかありません。</target>
        </trans-unit>
        <trans-unit id="000f9aa1d39e9791c956bd280884dcab10bddcf9" translate="yes" xml:space="preserve">
          <source>The real uid of this process. You can change both the real uid and the effective uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Since changes to &lt;code&gt;$&amp;lt;&lt;/code&gt; require a system call, check &lt;code&gt;$!&lt;/code&gt; after a change attempt to detect any possible errors.</source>
          <target state="translated">このプロセスの実際のuid。 &lt;code&gt;POSIX::setuid()&lt;/code&gt; を使用すると、実際のuidと有効なuidの両方を同時に変更できます。 &lt;code&gt;$&amp;lt;&lt;/code&gt; 変更にはシステムコールが必要なので、 &lt;code&gt;$!&lt;/code&gt; を確認してください。変更後、考えられるエラーを検出しようとしました。</target>
        </trans-unit>
        <trans-unit id="226998a781d1d6550060a07be6fe5dd8d2b4b4b4" translate="yes" xml:space="preserve">
          <source>The real work is done in the standard typemap.</source>
          <target state="translated">実際の作業は標準のタイプマップで行います。</target>
        </trans-unit>
        <trans-unit id="c08e193bbc2bcd92c562519697a3487f212bcddb" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;encode_language_tag&lt;/code&gt; exists is because different language tags may represent the same language; this is normally treatable with &lt;code&gt;same_language_tag&lt;/code&gt; , but consider this situation:</source>
          <target state="translated">&lt;code&gt;encode_language_tag&lt;/code&gt; が存在する理由は、異なる言語タグが同じ言語を表す可能性があるためです。これは通常、 &lt;code&gt;same_language_tag&lt;/code&gt; で処理できますが、次の状況を考慮してください。</target>
        </trans-unit>
        <trans-unit id="ca772eb153fd56cb7e89f09b86319ec24565520e" translate="yes" xml:space="preserve">
          <source>The reason I said &quot;in this instance&quot; is because that</source>
          <target state="translated">今回は」と言ったのは、それが</target>
        </trans-unit>
        <trans-unit id="739ee83789116c83fd6d7b4456cdd5e4f5143663" translate="yes" xml:space="preserve">
          <source>The reason for not checking the return value from print() is because of pipe buffering; physical writes are delayed. That won't blow up until the close, and it will blow up with a SIGPIPE. To catch it, you could use this:</source>
          <target state="translated">print()からの戻り値をチェックしない理由は、パイプバッファリングのためで、物理的な書き込みは遅延します。これではcloseまで吹っ飛ばされず、sigpipeで吹っ飛んでしまいます。それをキャッチするには、これを使うといいでしょう。</target>
        </trans-unit>
        <trans-unit id="b3e75d2f4213b8c35d2937b292cccac3d8a1e38d" translate="yes" xml:space="preserve">
          <source>The reason for this is that CPAN does not know the dependencies of all modules when it starts out. To decide about the additional items to install, it just uses data found in the META.yml file or the generated Makefile. An undetected missing piece breaks the process. But it may well be that your Bundle installs some prerequisite later than some depending item and thus your second try is able to resolve everything. Please note, CPAN.pm does not know the dependency tree in advance and cannot sort the queue of things to install in a topologically correct order. It resolves perfectly well &lt;b&gt;if&lt;/b&gt; all modules declare the prerequisites correctly with the PREREQ_PM attribute to MakeMaker or the &lt;code&gt;requires&lt;/code&gt; stanza of Module::Build. For bundles which fail and you need to install often, it is recommended to sort the Bundle definition file manually.</source>
          <target state="translated">これは、CPANが起動時にすべてのモジュールの依存関係を認識していないためです。インストールする追加のアイテムを決定するために、META.ymlファイルまたは生成されたMakefileにあるデータを使用します。検出されなかった欠落片はプロセスを中断します。しかし、バンドルがいくつかの依存アイテムよりも後にいくつかの前提条件をインストールするため、2回目の試行ですべてを解決できる可能性があります。 CPAN.pmは事前に依存関係ツリーを認識していないため、インストールするもののキューをトポロジ的に正しい順序で並べ替えることはできません。それは完璧に解決し&lt;b&gt;た場合&lt;/b&gt;、すべてのモジュールはMakeMakerのかにPREREQ_PM属性で正しく前提条件を宣言する &lt;code&gt;requires&lt;/code&gt; Module :: Buildのスタンザ。失敗して頻繁にインストールする必要があるバンドルの場合、バンドル定義ファイルを手動でソートすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5fa379384b7d494ede930080ac4d01947c2521a8" translate="yes" xml:space="preserve">
          <source>The reason for this unusability is that a fundamental assumption of Perl is that the characters it cares about for parsing and lexical analysis are the same whether or not the text is in UTF-8. For example, Perl expects the character &lt;code&gt;&quot;[&quot;&lt;/code&gt; to have the same representation, no matter if the string containing it (or program text) is UTF-8 encoded or not. To ensure this, Perl adapts UTF-EBCDIC to the particular code page so that all characters it expects to be UTF-8 invariant are in fact UTF-8 invariant. This means that text generated on a computer running one version of Perl's UTF-EBCDIC has to be translated to be intelligible to a computer running another.</source>
          <target state="translated">この使用不能の理由は、Perlの基本的な仮定が、テキストがUTF-8であるかどうかに関係なく、解析と字句解析に関係する文字が同じであることです。たとえば、Perlでは、文字 &lt;code&gt;&quot;[&quot;&lt;/code&gt; は、それを含む文字列（またはプログラムテキスト）がUTF-8でエンコードされているかどうかに関係なく、同じ表現であると想定しています。これを確実にするために、PerlはUTF-EBCDICを特定のコードページに適合させ、UTF-8不変であると予期されるすべての文字が実際にはUTF-8不変であるようにします。つまり、あるバージョンのPerlのUTF-EBCDICを実行しているコンピューターで生成されたテキストは、別のバージョンを実行しているコンピューターが理解できるように翻訳する必要があります。</target>
        </trans-unit>
        <trans-unit id="148e8f8b4033e043ed0349ade3e3972ed042dff2" translate="yes" xml:space="preserve">
          <source>The reason is that Encode::Guess guesses encoding by trial and error. It first splits $data into lines and tries to decode the line for each suspect. It keeps it going until all but one encoding is eliminated out of suspects list. ISO-8859 series is just too successful for most cases (because it fills almost all code points in \x00-\xff).</source>
          <target state="translated">その理由は、Encode::Guessが試行錯誤しながらエンコードを推測するからです。最初に $data を行に分割し、各容疑者についてその行をデコードしようとします。これを、1つのエンコーディングを除いたすべてのエンコーディングが容疑者リストから除外されるまで続けます。ISO-8859シリーズは、ほとんどの場合で成功しすぎている。</target>
        </trans-unit>
        <trans-unit id="94742df1b378e1ee0c32933e905c9b3866f15f37" translate="yes" xml:space="preserve">
          <source>The reason is that variable interpolation and code expressions together pose a security risk. The combination is dangerous because many programmers who write search engines often take user input and plug it directly into a regexp:</source>
          <target state="translated">変数補間とコード式を一緒にするとセキュリティ上のリスクがあるからです。検索エンジンを書くプログラマーの多くが、ユーザーの入力を取って直接正規表現に差し込むことが多いので、この組み合わせは危険です。</target>
        </trans-unit>
        <trans-unit id="c8fa70ef72504bbb3f7d6986506b4705b0ceb70a" translate="yes" xml:space="preserve">
          <source>The reason is that vendor encoding is usually a superset of national standard so it becomes too ambiguous for most cases.</source>
          <target state="translated">その理由は、ベンダエンコーディングは通常、国家標準のスーパーセットなので、ほとんどの場合、あまりにも曖昧になってしまうからです。</target>
        </trans-unit>
        <trans-unit id="fedf7056008fbc98297422a200d9b784c0b8db45" translate="yes" xml:space="preserve">
          <source>The reason that doesn't do what you want is because assigning a named array like that to a scalar is taking an array in scalar context, which means just counts the number of elements in @tmp.</source>
          <target state="translated">なぜそれが思うようにいかないかというと、このような名前付き配列をスカラに代入すると、スカラコンテキストで配列を取ることになり、@tmpの要素数をカウントしているだけになってしまうからです。</target>
        </trans-unit>
        <trans-unit id="550ff1bc08b0298c35cdd00d235a478cadb820d7" translate="yes" xml:space="preserve">
          <source>The reason that host $failed_ack_host did not receive a valid ACK. Useful to find out why when ack( $fail_ack_host ) returns a false value.</source>
          <target state="translated">ホスト $failed_ack_host が有効な ACK を受信しなかった理由。ack($fail_ack_host)が偽の値を返したときの理由を調べるのに便利です。</target>
        </trans-unit>
        <trans-unit id="251bb3c15e15e0ec21516300833b60efe1125c75" translate="yes" xml:space="preserve">
          <source>The reason this function has &quot;_strictly&quot; in its name is that when you're processing an Accept-Language list according to the RFCs, if you interpret the RFCs quite strictly, then you would use implicate_supers_strictly, but for normal use (i.e., common-sense use, as far as I'm concerned) you'd use implicate_supers.</source>
          <target state="translated">この関数の名前に&quot;_strictly &quot;が入っているのは、RFCに従ってAccept-Languageリストを処理しているときに、 RFCをかなり厳密に解釈すれば、implicate_supers_strictlyを使うことになりますが、 通常の使用(つまり、私の知る限りでは常識的な使用)ではimplicate_supersを使うことになるからです。</target>
        </trans-unit>
        <trans-unit id="e1005d9c83a9fa9fcbc88e4d2084838b8de52293" translate="yes" xml:space="preserve">
          <source>The reason this is necessary is that the area of the Perl stack which held them will very likely have been overwritten by something else by the time control returns from</source>
          <target state="translated">これが必要な理由は、それらを保持していた Perl スタックの領域が</target>
        </trans-unit>
        <trans-unit id="7f8610d66bd9a8ef9ccb75cedd8c737641eb770d" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because RFC 1951 content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">これがデフォルトの動作ではない理由は、RFC 1951 のコンテンツは解凍を試みることでしか検出できないからです。このプロセスはエラーが発生しやすく、誤検出を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="19bd78bd51bc1c56b13d7881beac1baa5b73fb31" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because lzma_alone content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">これがデフォルトの動作ではない理由は、lzma_alone コンテンツは解凍を試みることでしか検出できないからです。この処理はエラーが発生しやすく、誤検出を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="28f02f8a8e5a76ee5006992d613d3802d772737a" translate="yes" xml:space="preserve">
          <source>The reason this is wrong is that, by the time you come to use the pointer &lt;code&gt;rememberSub&lt;/code&gt; in &lt;code&gt;CallSavedSub1&lt;/code&gt; , it may or may not still refer to the Perl subroutine that was recorded in &lt;code&gt;SaveSub1&lt;/code&gt; . This is particularly true for these cases:</source>
          <target state="translated">これが間違っている理由は、 &lt;code&gt;CallSavedSub1&lt;/code&gt; でポインタ &lt;code&gt;rememberSub&lt;/code&gt; を使用するようになるまでに、SaveSub1に記録されたPerlサブルーチンをまだ参照しているかいないか &lt;code&gt;SaveSub1&lt;/code&gt; 。これは特に次の場合に当てはまります。</target>
        </trans-unit>
        <trans-unit id="1fc61e22be627df80a7651746e52decec2ded90a" translate="yes" xml:space="preserve">
          <source>The reasons for most important skipped tests are:</source>
          <target state="translated">最も重要なサボりの理由は</target>
        </trans-unit>
        <trans-unit id="cc1622b786a9a5b8c43f01f8734a1a12e356f528" translate="yes" xml:space="preserve">
          <source>The recognized bright background color attributes (colors 8 to 15) are:</source>
          <target state="translated">認識されている明るい背景色の属性(色8〜15)は</target>
        </trans-unit>
        <trans-unit id="6c5d4a5f4c9a09fda354809420b2cbe2f30c42f0" translate="yes" xml:space="preserve">
          <source>The recognized normal background color attributes (colors 0 to 7) are:</source>
          <target state="translated">認識される通常の背景色属性(色0~7)は、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="4a93814d53d2a583e73a218be86053c6699847f6" translate="yes" xml:space="preserve">
          <source>The recognized normal foreground color attributes (colors 0 to 7) are:</source>
          <target state="translated">認識される通常の前景色属性(色 0 から 7)は、以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="c8d8fb33b8f8ad299c896b38af940448a2194ca3" translate="yes" xml:space="preserve">
          <source>The recognized options to new() are as follows. All options take a single argument.</source>
          <target state="translated">new()で認識されるオプションは以下の通りです。すべてのオプションは単一の引数を取ります。</target>
        </trans-unit>
        <trans-unit id="1e562f76f9cdb0ef2aab453d2c38556cc6a6334d" translate="yes" xml:space="preserve">
          <source>The recommended compiler to use in Tru64 is the native C compiler. The native compiler produces much faster code (the speed difference is noticeable: several dozen percentages) and also more correct code: if you are considering using the GNU C compiler you should use at the very least the release of 2.95.3 since all older gcc releases are known to produce broken code when compiling Perl. One manifestation of this brokenness is the lib/sdbm test dumping core; another is many of the op/regexp and op/pat, or ext/Storable tests dumping core (the exact pattern of failures depending on the GCC release and optimization flags).</source>
          <target state="translated">Tru64 で使用することを推奨するコンパイラは、ネイティブ C コンパイラです。GNU C コンパイラを使用することを検討している場合は、少なくとも 2.95.3 のリリースを使用する必要があります。この問題の一つの現れは lib/sdbm テストダンプコアです。もう一つは op/regexp や op/pat、ext/Storable テストダンプコアです (失敗の正確なパターンは GCC リリースと最適化フラグに依存します)。</target>
        </trans-unit>
        <trans-unit id="a954751580ed0f6e74f6ae52a458e3decc2b6782" translate="yes" xml:space="preserve">
          <source>The recommended order of sections in Perl module documentation is:</source>
          <target state="translated">Perl モジュールのドキュメントのセクションの推奨順序は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="da2bd70489cefb603292ce8b5cfe4c6cae04aaf7" translate="yes" xml:space="preserve">
          <source>The recommended way to build Perl for the OS/400 PASE is to build the Perl 5 source code (release 5.8.1 or later) under AIX.</source>
          <target state="translated">OS/400 PASE用のPerlをビルドする推奨の方法は、Perl 5のソースコード(リリース5.8.1以降)をAIXの下でビルドすることです。</target>
        </trans-unit>
        <trans-unit id="e06b04ad5d41fce493c0b00ecf1ca37dfa5afcff" translate="yes" xml:space="preserve">
          <source>The red() and green() functions would be similar. To create these, we'll assign a closure to a typeglob of the name of the function we're trying to build.</source>
          <target state="translated">red()関数とgreen()関数も似たようなものでしょう。これらを作成するために、構築しようとしている関数の名前のタイプグローブにクロージャを代入します。</target>
        </trans-unit>
        <trans-unit id="1d461f380b420e2f92a59ecbfaa16c7256f214ff" translate="yes" xml:space="preserve">
          <source>The refcount of &lt;code&gt;sv&lt;/code&gt; would be decremented at the end of</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; のrefcountは、終了時に減少します</target>
        </trans-unit>
        <trans-unit id="aa0554de1d883a744516c47aa9649afa91c2844b" translate="yes" xml:space="preserve">
          <source>The reference count for each specified &lt;code&gt;SV*&lt;/code&gt; parameter is decremented.</source>
          <target state="translated">指定された各 &lt;code&gt;SV*&lt;/code&gt; パラメーターの参照カウントは減分されます。</target>
        </trans-unit>
        <trans-unit id="2beb795bee8f23385c682524158dfa3883714ef0" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name list.</source>
          <target state="translated">パッド名リストの参照カウント。</target>
        </trans-unit>
        <trans-unit id="ed87a4c5aaea6eeced4317ed59578fe0847b6b0f" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name.</source>
          <target state="translated">パッド名の参照カウント。</target>
        </trans-unit>
        <trans-unit id="0f3b4f395e70b832ec180500f62bfe30abfdf04c" translate="yes" xml:space="preserve">
          <source>The reference count of the padlist. Currently this is always 1.</source>
          <target state="translated">パッドリストの参照カウント。現在は常に1です。</target>
        </trans-unit>
        <trans-unit id="b9e9c4a001467c1b7e5e43bb821f471e292d9d31" translate="yes" xml:space="preserve">
          <source>The reference from &lt;code&gt;$foo&lt;/code&gt; to &lt;code&gt;$bar&lt;/code&gt; has been weakened. When the &lt;code&gt;$bar&lt;/code&gt; variable goes out of scope, it will be garbage-collected. The next time you look at the value of the &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; key, it will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$foo&lt;/code&gt; から &lt;code&gt;$bar&lt;/code&gt; への参照が弱められました。場合は &lt;code&gt;$bar&lt;/code&gt; 変数がスコープ外になる、それがガベージコレクトされます。次に &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; キーの値を見ると、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="3fc857a94806f2c57cbbf2e2dd2d2b88b08c2fe6" translate="yes" xml:space="preserve">
          <source>The reference is truly dumped and we can finally see what we're dealing with. Our quoting was perfectly valid but wrong for our purposes, with 'and jerry' being treated as 2 separate words rather than a phrase, thus throwing the evenly paired hash structure out of alignment.</source>
          <target state="translated">参照は本当に捨てられ、我々は最終的に何を扱っているのかを見ることができます。私たちの引用は完全に有効でしたが、私たちの目的のためには間違っていました。'and jerry'はフレーズではなく2つの別々の単語として扱われていたため、均等にペアになっていたハッシュ構造がずれてしまいました。</target>
        </trans-unit>
        <trans-unit id="4adfd6b1f7abb309b66c9315a05ff37197f3a0fe" translate="yes" xml:space="preserve">
          <source>The references you get from rule 2 are the same kind of references that you get from rule 1:</source>
          <target state="translated">ルール2で取得した参照は、ルール1で取得した参照と同じ種類のものです。</target>
        </trans-unit>
        <trans-unit id="168bedf74d17b291ff7d2c437f9134d9006e0ffe" translate="yes" xml:space="preserve">
          <source>The regexp has a single grouping which considers 4-letter combinations, then 3-letter combinations, etc., and uses &lt;code&gt;\g1&lt;/code&gt; to look for a repeat. Although &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;\g1&lt;/code&gt; represent the same thing, care should be taken to use matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... only</source>
          <target state="translated">正規表現には、4文字の組み合わせ、3文字の組み合わせなどを考慮した単一のグループがあり、 &lt;code&gt;\g1&lt;/code&gt; を使用して繰り返しを探します。が &lt;code&gt;$1&lt;/code&gt; と &lt;code&gt;\g1&lt;/code&gt; 同じものを表し、介護が一致した変数を使用するために取られるべきである &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; 、...のみ</target>
        </trans-unit>
        <trans-unit id="d1eb9cbcdcc85f0afd97e3812b595b9e1f6b3fd8" translate="yes" xml:space="preserve">
          <source>The regexp matches an open parenthesis, one or more copies of an alternation, and a close parenthesis. The alternation is two-way, with the first alternative &lt;code&gt;[^()]+&lt;/code&gt; matching a substring with no parentheses and the second alternative &lt;code&gt;\([^()]*\)&lt;/code&gt; matching a substring delimited by parentheses. The problem with this regexp is that it is pathological: it has nested indeterminate quantifiers of the form &lt;code&gt;(a+|b)+&lt;/code&gt;. We discussed in Part 1 how nested quantifiers like this could take an exponentially long time to execute if there was no match possible. To prevent the exponential blowup, we need to prevent useless backtracking at some point. This can be done by enclosing the inner quantifier as an independent subexpression:</source>
          <target state="translated">正規表現は、左括弧、代替の1つ以上のコピー、および右括弧と一致します。代替は双方向で、最初の選択肢 &lt;code&gt;[^()]+&lt;/code&gt; は括弧のない部分文字列に一致し、2番目の選択肢 &lt;code&gt;\([^()]*\)&lt;/code&gt; は括弧で区切られた部分文字列に一致します。この正規表現の問題は、それが病理学的であることです： &lt;code&gt;(a+|b)+&lt;/code&gt; 形式の不定数量詞がネストされています。パート1では、このようなネストされた量指定子が、一致するものがなかった場合、実行に指数関数的に長い時間がかかる可能性があることについて説明しました。指数関数的な爆発を防ぐために、ある時点で無駄なバックトラックを防ぐ必要があります。これは、内部の数量詞を独立した部分式として囲むことで実行できます。</target>
        </trans-unit>
        <trans-unit id="368bf455728e0cc079751b44e9fea4161849b273" translate="yes" xml:space="preserve">
          <source>The regexp structure contains all the data that perl needs to be aware of to properly work with the regular expression. It includes data about optimisations that perl can use to determine if the regex engine should really be used, and various other control info that is needed to properly execute patterns in various contexts such as is the pattern anchored in some way, or what flags were used during the compile, or whether the program contains special constructs that perl needs to be aware of.</source>
          <target state="translated">regexp構造体には、正規表現を適切に動作させるためにPerlが意識しなければならないすべてのデータが含まれています。これには、正規表現エンジンが本当に使用されるべきかどうかを判断するためにperlが使用できる最適化に関するデータや、パターンが何らかの方法で固定されているか、コンパイル時にどのようなフラグが使用されているか、プログラムにperlが注意しなければならない特別な構造が含まれているかなど、様々な文脈でパターンを適切に実行するために必要な様々な制御情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="c3c54f92228f6f05bcc0bda8517b5a88720264e3" translate="yes" xml:space="preserve">
          <source>The regexp without the &lt;code&gt;//x&lt;/code&gt; modifier is</source>
          <target state="translated">&lt;code&gt;//x&lt;/code&gt; 修飾子のない正規表現は</target>
        </trans-unit>
        <trans-unit id="cd0504e6dcc01ce1582fd08d19ab6d72b18efd43" translate="yes" xml:space="preserve">
          <source>The regops are defined in</source>
          <target state="translated">レゴップスは</target>
        </trans-unit>
        <trans-unit id="398b15f4cf9df5e68a324633c771b534053133cc" translate="yes" xml:space="preserve">
          <source>The regression tests for each operator live in</source>
          <target state="translated">各オペレータの回帰テストは</target>
        </trans-unit>
        <trans-unit id="1185c36b91985e4291f68ed8a08b57d301b0c6f7" translate="yes" xml:space="preserve">
          <source>The regular expression engine can be a weighty tool to wield. On long strings and complex patterns it can end up having to do a lot of work to find a match, and even more to decide that no match is possible. Consider a situation like the following pattern.</source>
          <target state="translated">正規表現エンジンは、重量感のあるツールになります。長い文字列や複雑なパターンでは、一致するものを見つけるために多くの作業をしなければならず、一致するものがないと判断するにはさらに多くの作業をしなければならないことがあります。次のパターンのような状況を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="550e74d9d02bffd01cf3b652c4e172b2d8cb3f39" translate="yes" xml:space="preserve">
          <source>The regular expression to execute.</source>
          <target state="translated">実行する正規表現。</target>
        </trans-unit>
        <trans-unit id="8c3b3408d3eb9771532acb10a043be225a8f7a49" translate="yes" xml:space="preserve">
          <source>The regular expression to match the balanced text uses two new (to Perl 5.10) regular expression features. These are covered in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and this example is a modified version of one in that documentation.</source>
          <target state="translated">バランスの取れたテキストに一致する正規表現は、2つの新しい（Perl 5.10への）正規表現機能を使用します。これらは&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;でカバーされており、この例はそのドキュメントの1つを変更したバージョンです。</target>
        </trans-unit>
        <trans-unit id="7b89c7165c60ab0797d1970f7d1380e29eaa0008" translate="yes" xml:space="preserve">
          <source>The related &lt;code&gt;base&lt;/code&gt; pragma will combine fields from base classes and any fields declared using the &lt;code&gt;fields&lt;/code&gt; pragma. This enables field inheritance to work properly. Inherited fields can be overridden but will generate a warning if warnings are enabled.</source>
          <target state="translated">関連する &lt;code&gt;base&lt;/code&gt; プラグマは、基本クラスのフィールドと、 &lt;code&gt;fields&lt;/code&gt; プラグマを使用して宣言されたフィールドを結合します。これにより、フィールドの継承が適切に機能します。継承されたフィールドはオーバーライドできますが、警告が有効になっている場合は警告が生成されます。</target>
        </trans-unit>
        <trans-unit id="31c9eb432cfde9dbb8b6575337f7f66a6d53cbda" translate="yes" xml:space="preserve">
          <source>The relevant snippet from &lt;code&gt;Perl_pp_regcomp&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;Perl_pp_regcomp&lt;/code&gt; からの関連スニペット：</target>
        </trans-unit>
        <trans-unit id="99cbb925914614f38c9cb5913b1dca990337342e" translate="yes" xml:space="preserve">
          <source>The remainder of the input string (i.e. the characters after the extracted string). On failure, the entire string is returned.</source>
          <target state="translated">入力文字列の残り(すなわち、抽出された文字列の後の文字)。失敗した場合は、文字列全体が返されます。</target>
        </trans-unit>
        <trans-unit id="efbd63ef88d15920cb0b989c9bf11dcb1d2eacf4" translate="yes" xml:space="preserve">
          <source>The remaining arguments list the files to be included in the tar file. These files must all exist. Any files which don't exist or can't be read are silently ignored.</source>
          <target state="translated">残りの引数は、tar ファイルに含めるファイルのリストです。これらのファイルはすべて存在しなければなりません。存在しないファイルや読み込めないファイルは無視されます。</target>
        </trans-unit>
        <trans-unit id="1833f6078478dddd497b7e7b088899346fc9339d" translate="yes" xml:space="preserve">
          <source>The remaining list-reduction functions are all specialisations of this generic idea.</source>
          <target state="translated">残りのリスト削減関数は、すべてこの一般的な考え方の特殊化です。</target>
        </trans-unit>
        <trans-unit id="5790bf8249cfb740e1105f12c204270f7d624a65" translate="yes" xml:space="preserve">
          <source>The remaining locale categories are not currently used by Perl itself. But again note that things Perl interacts with may use these, including extensions outside the standard Perl distribution, and by the operating system and its utilities. Note especially that the string value of &lt;code&gt;$!&lt;/code&gt; and the error messages given by external utilities may be changed by &lt;code&gt;LC_MESSAGES&lt;/code&gt; . If you want to have portable error codes, use &lt;code&gt;%!&lt;/code&gt; . See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;.</source>
          <target state="translated">残りのロケールカテゴリは、現在Perl自体では使用されていません。ただし、Perlと対話するものは、標準のPerlディストリビューション外の拡張機能や、オペレーティングシステムとそのユーティリティによってこれらを使用する場合があることに注意してください。特に &lt;code&gt;$!&lt;/code&gt; の文字列値に注意してください。そして、外部ユーティリティによって与えられるエラーメッセージは &lt;code&gt;LC_MESSAGES&lt;/code&gt; によって変更されるかもしれません。移植可能なエラーコードが必要な場合は、 &lt;code&gt;%!&lt;/code&gt; を使用してください。。&lt;a href=&quot;errno&quot;&gt;Errnoを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6f593d82b22de04a34fb6b00553893736966b088" translate="yes" xml:space="preserve">
          <source>The remaining three arguments to &lt;code&gt;autosplit&lt;/code&gt; govern other options to the autosplitter.</source>
          <target state="translated">&lt;code&gt;autosplit&lt;/code&gt; の残りの3つの引数は、autosplitterの他のオプションを管理します。</target>
        </trans-unit>
        <trans-unit id="359f225886acbac14791dc5bc2f8daf71a950d7f" translate="yes" xml:space="preserve">
          <source>The remaining transformations (e.g. hex -&amp;gt; oct, bin -&amp;gt; hex, etc.) are left as an exercise to the inclined reader.</source>
          <target state="translated">残りの変換（例：hex-&amp;gt; oct、bin-&amp;gt; hexなど）は、傾向のある読者への課題として残されています。</target>
        </trans-unit>
        <trans-unit id="24d565f51a3155e5d1586b0499680351e5378dc6" translate="yes" xml:space="preserve">
          <source>The repeat count for &lt;code&gt;u&lt;/code&gt; is interpreted as the maximal number of bytes to encode per line of output, with 0, 1 and 2 replaced by 45. The repeat count should not be more than 65.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; の繰り返し数は、出力の1行あたりにエンコードする最大バイト数として解釈され、0、1、2は45に置き換えられます。繰り返し数は65以下にする必要があります。</target>
        </trans-unit>
        <trans-unit id="f593cdc0477b84a5d137272da930d89fe6995081" translate="yes" xml:space="preserve">
          <source>The repertoire of characters that Perl can represent is a superset of those defined by the Unicode Consortium. On most platforms the ordinal values of a character as returned by &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; is the</source>
          <target state="translated">Perlが表現できる文字のレパートリーは、Unicodeコンソーシアムによって定義された文字のスーパーセットです。ほとんどのプラットフォームで返される文字の序数値に &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; であります</target>
        </trans-unit>
        <trans-unit id="2b90d7584bfb12af61e5f1ab0554e525a346ffd6" translate="yes" xml:space="preserve">
          <source>The report generated is in the following format:</source>
          <target state="translated">生成されたレポートは以下の形式です。</target>
        </trans-unit>
        <trans-unit id="c18cb003bcf6566604f8240405fff42c4ea43f6c" translate="yes" xml:space="preserve">
          <source>The report is then grouped by the &lt;b&gt;Package&lt;/b&gt; of each variable, subroutine or format with the special case &quot;(lexicals)&quot; meaning lexical variables. Each &lt;b&gt;object&lt;/b&gt; name (implicitly qualified by its containing &lt;b&gt;Package&lt;/b&gt;) includes its type character(s) at the beginning where possible. Lexical variables are easier to track and even included dereferencing information where possible.</source>
          <target state="translated">次に、レポートは、各変数、サブルーチン、またはフォーマットの&lt;b&gt;パッケージ&lt;/b&gt;ごとにグループ化され、特別なケース「（lexicals）」がレキシカル変数を意味します。各&lt;b&gt;オブジェクト&lt;/b&gt;名（含まれている&lt;b&gt;Package&lt;/b&gt;によって暗黙的に修飾されている）には、可能な場合、先頭にタイプ文字が含まれています。字句変数は追跡が簡単で、可能な場合は逆参照情報も含まれます。</target>
        </trans-unit>
        <trans-unit id="a2f4b71d3df1e22731185a4eb5f4e73af9bf14da" translate="yes" xml:space="preserve">
          <source>The report with</source>
          <target state="translated">とのレポートを掲載しています。</target>
        </trans-unit>
        <trans-unit id="32baff471ed8eb8f5ceead8f0fa06a41ab81b875" translate="yes" xml:space="preserve">
          <source>The request was judged to be small, so the possibility to trap it depends on the way perl was compiled. By default it is not trappable. However, if compiled for this, Perl may use the contents of &lt;code&gt;$^M&lt;/code&gt; as an emergency pool after die()ing with this message. In this case the error is trappable</source>
          <target state="translated">リクエストは小さいと判断されたため、それをトラップする可能性はperlのコンパイル方法によって異なります。デフォルトではトラップできません。ただし、このためにコンパイルされた場合、Perlは、このメッセージでdie（）した後、 &lt;code&gt;$^M&lt;/code&gt; 内容を緊急プールとして使用する場合があります。この場合、エラーはトラップ可能です</target>
        </trans-unit>
        <trans-unit id="e06f7be9330cffa7a55aee96bfbe8c1e1072f6a9" translate="yes" xml:space="preserve">
          <source>The requests do not necessarily go always all the way down to the operating system: that's where PerlIO buffering comes into play.</source>
          <target state="translated">リクエストは常にオペレーティングシステムにまで届くわけではありません。</target>
        </trans-unit>
        <trans-unit id="d362ada26ee954875bdcbdb4ef3110ff77e350ef" translate="yes" xml:space="preserve">
          <source>The require function will actually look for the &quot;</source>
          <target state="translated">require関数は実際に&quot;</target>
        </trans-unit>
        <trans-unit id="7925470de731575e163d706573142112baceaaab" translate="yes" xml:space="preserve">
          <source>The require function will look for the &quot;</source>
          <target state="translated">require関数は、&quot;</target>
        </trans-unit>
        <trans-unit id="a4dd4536ee0a716833e52164851f465f831c0d1d" translate="yes" xml:space="preserve">
          <source>The required arguments during &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; are the hash, the package, and the reference to the &lt;code&gt;FETCH&lt;/code&gt; ing function. The optional arguments are an arbitrary scalar $data, the reference to the &lt;code&gt;EXISTS&lt;/code&gt; function, and initial values of the hash and of the existence cache.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 中に必要な引数は、ハッシュ、パッケージ、および &lt;code&gt;FETCH&lt;/code&gt; ing関数への参照です。オプションの引数は、任意のスカラー$ data、 &lt;code&gt;EXISTS&lt;/code&gt; 関数への参照、およびハッシュと存在キャッシュの初期値です。</target>
        </trans-unit>
        <trans-unit id="37cc4a6beddbd481d62d1aa4fb0c7078c9745a11" translate="yes" xml:space="preserve">
          <source>The requires and build_requires dependency declarations</source>
          <target state="translated">require および build_requires 依存関係宣言</target>
        </trans-unit>
        <trans-unit id="68eca29cf3cefa1ee83b5c875c176fa92ac4b217" translate="yes" xml:space="preserve">
          <source>The rest is duplicate code from MM_Unix. Should move the linker code to its own method.</source>
          <target state="translated">残りはMM_Unixからの重複コードです。リンカのコードを独自のメソッドに移動する必要があります。</target>
        </trans-unit>
        <trans-unit id="5f0ee77d23f152cd1591836db1cbf485219544f6" translate="yes" xml:space="preserve">
          <source>The rest is for internal usage of this package. In particular, if TIEHASH is overwritten, it should call SUPER::TIEHASH.</source>
          <target state="translated">あとはこのパッケージの内部的な使い方です。特に、TIEHASHが上書きされた場合は、SUPER::TIEHASHを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="bf6a19c74f24c99c3610c0c4323af3d860d85c2f" translate="yes" xml:space="preserve">
          <source>The rest of the .pm file contains sample code for providing documentation for the extension.</source>
          <target state="translated">.pm ファイルの残りの部分には、拡張子のドキュメントを提供するためのサンプルコードが含まれています。</target>
        </trans-unit>
        <trans-unit id="6a0a96f4412d084abe1abbbb705cc005b4d7612f" translate="yes" xml:space="preserve">
          <source>The rest of the function description may be indented or left-adjusted. The following example shows a function with its body left-adjusted. Most examples in this document will indent the body for better readability.</source>
          <target state="translated">関数の説明の残りの部分は、インデントされていてもよいし、左寄せされていてもよい。以下の例は、ボディを左寄せにした関数を示しています。このドキュメントのほとんどの例では、読みやすくするためにボディをインデントしています。</target>
        </trans-unit>
        <trans-unit id="4748c8c8a6af67adc5b974371e823f12ce953a5d" translate="yes" xml:space="preserve">
          <source>The rest of this section may need updating, but we don't know what it should say. Please email comments to &lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;perlbug@perl.org&lt;/a&gt;.</source>
          <target state="translated">このセクションの残りの部分は更新が必要な場合がありますが、それが何を言うべきかわかりません。コメントは&lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;perlbug@perl.org&lt;/a&gt;までメールでお送りください。</target>
        </trans-unit>
        <trans-unit id="a3cb44cf97eef964df25c82472ad386e80122021" translate="yes" xml:space="preserve">
          <source>The restart was previously implemented using a &lt;code&gt;longjmp&lt;/code&gt; in &lt;code&gt;regatom()&lt;/code&gt; back to a &lt;code&gt;setjmp&lt;/code&gt; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , but this proved to be problematic as the latter is a large function containing many automatic variables, which interact badly with the emergent control flow of &lt;code&gt;setjmp&lt;/code&gt; .</source>
          <target state="translated">再起動は、以前に使用して実装した &lt;code&gt;longjmp&lt;/code&gt; の中 &lt;code&gt;regatom()&lt;/code&gt; へ戻る &lt;code&gt;setjmp&lt;/code&gt; 関数で &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; 、後者は多くの自動変数を含む大きな機能であるので、これは問題であることが証明された相互作用ひどくの緊急制御フローと &lt;code&gt;setjmp&lt;/code&gt; 関数。</target>
        </trans-unit>
        <trans-unit id="5e8310b48c79e713f14decd4088c7da40b8f8d5f" translate="yes" xml:space="preserve">
          <source>The restriction for the comparison operation is that even if, for example, &lt;code&gt;cmp&lt;/code&gt; should return a blessed reference, the autogenerated &lt;code&gt;lt&lt;/code&gt; function will produce only a standard logical value based on the numerical value of the result of &lt;code&gt;cmp&lt;/code&gt; . In particular, a working numeric conversion is needed in this case (possibly expressed in terms of other conversions).</source>
          <target state="translated">比較演算の制限は、たとえば、 &lt;code&gt;cmp&lt;/code&gt; がblessされた参照を返す必要がある場合でも、自動生成された &lt;code&gt;lt&lt;/code&gt; 関数は、 &lt;code&gt;cmp&lt;/code&gt; の結果の数値に基づく標準の論理値のみを生成するということです。特に、この場合は有効な数値変換が必要です（他の変換で表現されている可能性があります）。</target>
        </trans-unit>
        <trans-unit id="17095fb32ad5dc43587aca28eee99cc6fee8a6b5" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;$^R&lt;/code&gt; is automatically localized, so that it will behave properly in the presence of backtracking.</source>
          <target state="translated">結果の &lt;code&gt;$^R&lt;/code&gt; は自動的にローカライズされるため、バックトラックが存在する場合でも正しく動作します。</target>
        </trans-unit>
        <trans-unit id="917b4b2d464d47448ca46f205a594a1f2094a00d" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">結果 &lt;code&gt;Regexp&lt;/code&gt; は、引数が &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; から得られる正規表現であることを示しています。</target>
        </trans-unit>
        <trans-unit id="1beec82c5ad986daa3005ca6feae967035c22b78" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">結果 &lt;code&gt;Regexp&lt;/code&gt; は、引数が &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; から得られる正規表現であることを示しています。</target>
        </trans-unit>
        <trans-unit id="413c5704399ec4e320c4b4de62416c60414146e3" translate="yes" xml:space="preserve">
          <source>The result is returned as two arguments. If the modular multiplicative inverse does not exist, both arguments are undefined. Otherwise, the arguments are a number (object) and its sign (&quot;+&quot; or &quot;-&quot;).</source>
          <target state="translated">結果は2つの引数として返されます。モジュラー乗算逆数が存在しない場合、両方の引数は未定義です。そうでなければ、引数は数(オブジェクト)とその符号(&quot;+&quot;または&quot;-&quot;)です。</target>
        </trans-unit>
        <trans-unit id="e2176289afdf7f655c62c369888f79d214a9f024" translate="yes" xml:space="preserve">
          <source>The result is that the contents of line 17 of the file will be replaced with &quot;Cherry pie&quot;; a newline character will separate line 17 from line 18. This means that this code will do nothing:</source>
          <target state="translated">その結果、ファイルの17行目の内容が「チェリーパイ」に置き換わり、改行文字が17行目と18行目を区切ることになります。つまり、このコードは何もしないということです。</target>
        </trans-unit>
        <trans-unit id="f863b8e99992f5c2a779d9ed98aecf9cef5b7a84" translate="yes" xml:space="preserve">
          <source>The result is the Unicode character or character sequence given by</source>
          <target state="translated">で与えられた Unicode 文字または文字列が結果となります。</target>
        </trans-unit>
        <trans-unit id="17faf27e0d190c0297fec9a5baff8ccb279e91a8" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">結果は、中括弧内の16進数で指定された文字です。参照&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]を&lt;/a&gt;文字の詳細については下記。</target>
        </trans-unit>
        <trans-unit id="1743ff5152c2110b7544e70901f154f3b6b46b92" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number in the range 0x00 to 0xFF. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">結果は、0x00から0xFFの範囲の16進数で指定された文字です。参照&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]を&lt;/a&gt;文字の詳細については下記。</target>
        </trans-unit>
        <trans-unit id="6bbe820fb63fd799e4d92d37fd1768342fc0ad13" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the octal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">結果は、中括弧内の8進数で指定された文字です。参照&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]を&lt;/a&gt;文字の詳細については下記。</target>
        </trans-unit>
        <trans-unit id="b5d07b8bddc1c5dd823f98677754aff0c68b0c00" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the three-digit octal number in the range 000 to 777 (but best to not use above 077, see next paragraph). See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">結果は、000から777の範囲の3桁の8進数で指定された文字です（ただし、077を超えて使用しないことをお勧めします。次の段落を参照）。参照&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]を&lt;/a&gt;文字の詳細については下記。</target>
        </trans-unit>
        <trans-unit id="4d2ac189a7b892d497c3a957f821832172806b14" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;code&gt;xhdr&lt;/code&gt; except the is will be restricted to headers where the text of the header matches &lt;code&gt;PATTERN&lt;/code&gt;</source>
          <target state="translated">結果は &lt;code&gt;xhdr&lt;/code&gt; と同じですが、ヘッダーのテキストが &lt;code&gt;PATTERN&lt;/code&gt; に一致するヘッダーに制限されます。</target>
        </trans-unit>
        <trans-unit id="37186ac3e81998654b9034f359d33c97b138b201" translate="yes" xml:space="preserve">
          <source>The result may be used as a subpattern in a match:</source>
          <target state="translated">結果は、マッチのサブパターンとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="30a38c7996159062562ab2957a6c23713b7a1d86" translate="yes" xml:space="preserve">
          <source>The result of evaluation of the last successful &lt;code&gt;(?{ code })&lt;/code&gt; regular expression assertion (see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;). May be written to.</source>
          <target state="translated">最後に成功した &lt;code&gt;(?{ code })&lt;/code&gt; 正規表現アサーションの評価結果（&lt;a href=&quot;perlre&quot;&gt;perlreを&lt;/a&gt;参照）。書いてもよい。</target>
        </trans-unit>
        <trans-unit id="66611e861a602cfa60591a93b737577becd37f08" translate="yes" xml:space="preserve">
          <source>The result of great_circle_direction is in radians, zero indicating straight north, pi or -pi straight south, pi/2 straight west, and -pi/2 straight east.</source>
          <target state="translated">great_circle_directionの結果はラジアン単位で、0は北にまっすぐ、πまたは-πは南にまっすぐ、π/2は西にまっすぐ、-π/2は東にまっすぐであることを示します。</target>
        </trans-unit>
        <trans-unit id="f6846ed84b71cca2d8b5fb5477773187fbddddb3" translate="yes" xml:space="preserve">
          <source>The result of md5(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) will be exactly the same as the result of md5(&quot;abc&quot;).</source>
          <target state="translated">md5(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)の結果は、md5(&quot;abc&quot;)の結果と全く同じになります。</target>
        </trans-unit>
        <trans-unit id="641d055cafe1e1ee3cae38ce56b7935f5d3bc2b3" translate="yes" xml:space="preserve">
          <source>The result of overflowing the range of the integers is undefined because it is undefined also in C. In other words, using 32-bit integers, &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; is undefined. Shifting by a negative number of bits is also undefined.</source>
          <target state="translated">整数の範囲をオーバーフローした結果は、Cでも未定義であるため、未定義です。つまり、32ビット整数を使用すると、 &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; は未定義になります。負のビット数によるシフトも定義されていません。</target>
        </trans-unit>
        <trans-unit id="00de3247a1fa0dbaa5340672e75fce7f76fa569f" translate="yes" xml:space="preserve">
          <source>The result of this scenario is at best a database that doesn't contain what you expect. At worst the database will corrupt.</source>
          <target state="translated">このシナリオの結果は、良くても期待したものが含まれていないデータベースになってしまいます。最悪の場合、データベースは破損します。</target>
        </trans-unit>
        <trans-unit id="f6de57c3d8ec6b1611fc0077d370dda9fed1574d" translate="yes" xml:space="preserve">
          <source>The result returned will be one of the following:</source>
          <target state="translated">返される結果は以下のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="0b8a9a1357d52322f675cb2cb87488ac744f63b6" translate="yes" xml:space="preserve">
          <source>The result string containing interpolated material is tainted if a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; を含む &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; の&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;フォームが有効な場合、補間された素材を含む結果文字列が汚染されます。</target>
        </trans-unit>
        <trans-unit id="51fb17ca190a73d84710650cb1a592da2c670185" translate="yes" xml:space="preserve">
          <source>The result will be an array of 3 elements, each a reference to an array which will hold the handles that are ready for reading, writing and have exceptions respectively. Upon error an empty list is returned.</source>
          <target state="translated">結果は 3 つの要素からなる配列となり、それぞれが読み込み、書き込み、例外処理が可能なハンドルを保持する配列への参照となります。エラーが発生した場合は空のリストが返されます。</target>
        </trans-unit>
        <trans-unit id="a68ddca584ffd166b11e615f1b961f7dd364600e" translate="yes" xml:space="preserve">
          <source>The result will be up to be three times the number of layers: the first element will be a name, the second element the arguments (unspecified arguments will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), the third element the flags, the fourth element a name again, and so forth.</source>
          <target state="translated">結果は最大でレイヤー数の3倍になります。最初の要素は名前、2番目の要素は引数（未指定の引数は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; になります）、3番目の要素はフラグ、4番目の要素は再び名前、というようになります。前方へ。</target>
        </trans-unit>
        <trans-unit id="e6e0c7dba94f1684aba5f4cd6501d599a99358de" translate="yes" xml:space="preserve">
          <source>The resulting $subdir_cmd has no leading tab nor trailing newline. This makes it easier to embed in a make string. For example.</source>
          <target state="translated">結果として得られる $subdir_cmd には、先頭のタブも末尾の改行もありません。これにより、make文字列への埋め込みが容易になります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5f6fcb4f54789b9c880bc0144fb1cf2ebd3b3159" translate="yes" xml:space="preserve">
          <source>The resulting byte sequence is most convenient for checking the checksum. Don't slow your program down with a for loop adding the &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; values of this string's bytes - the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; code &lt;code&gt;%&lt;/code&gt; is the thing to use for computing the 8-bit sum of all bytes, which must be equal to zero:</source>
          <target state="translated">結果のバイトシーケンスは、チェックサムのチェックに最も便利です。この文字列のバイトの &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 値を追加するforループでプログラムの速度を落とさないでください。 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; コード &lt;code&gt;%&lt;/code&gt; は、すべてのバイトの8ビットの合計を計算するために使用するもので、ゼロに等しくなければなりません。</target>
        </trans-unit>
        <trans-unit id="421b5462923e8d16da2f8509620d57a56b898133" translate="yes" xml:space="preserve">
          <source>The resulting path is relative by default, i.e. the resulting path will have a leading colon.</source>
          <target state="translated">結果のパスはデフォルトでは相対パスになります。</target>
        </trans-unit>
        <trans-unit id="d4b19b5c805ca56f431cfbcdeba1af9f3a6200a3" translate="yes" xml:space="preserve">
          <source>The resulting program then looks like:</source>
          <target state="translated">その結果、できあがったプログラムは次のようになります。</target>
        </trans-unit>
        <trans-unit id="bd638c59c5752a7ccfc83a3bf825d1784299cda6" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath&quot;&gt;catpath&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">結果を&lt;a href=&quot;#catpath&quot;&gt;catpath&lt;/a&gt;に渡して、元のパスと同等の（通常は同じ）パスを取得できます。</target>
        </trans-unit>
        <trans-unit id="fbae74b52e9e1a2f4034868dc967236dfb097109" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath()&quot;&gt;catpath()&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">結果を&lt;a href=&quot;#catpath()&quot;&gt;catpath（）&lt;/a&gt;に渡して、元のパスと同等の（通常は同じ）パスを取得できます。</target>
        </trans-unit>
        <trans-unit id="9fd6f04fef4668c0fb9b5436580855adbbe256e9" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;code&gt;catpath()&lt;/code&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">結果を &lt;code&gt;catpath()&lt;/code&gt; に渡して、元のパスと同等の（通常は同じ）パスを取得できます。</target>
        </trans-unit>
        <trans-unit id="7b48baa73a171c70124bb46d586398a253fc305f" translate="yes" xml:space="preserve">
          <source>The results follow ASCII rules. Only the characters &lt;code&gt;A-Z&lt;/code&gt; change, to &lt;code&gt;a-z&lt;/code&gt; respectively.</source>
          <target state="translated">結果はASCII規則に従います。文字 &lt;code&gt;A-Z&lt;/code&gt; だけが &lt;code&gt;a-z&lt;/code&gt; 変わります。</target>
        </trans-unit>
        <trans-unit id="e6e1386230ca5a3e137558786aef0b9ef4ab7b59" translate="yes" xml:space="preserve">
          <source>The results of creating new symbol table entries directly or modifying any entries that are not already typeglobs are undefined and subject to change between releases of perl.</source>
          <target state="translated">新しいシンボルテーブルのエントリを直接作成したり、既にタイプグローブではないエントリを修正したりした結果は未定義であり、perlのリリース間で変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="7c1728e8e43393222dde9f78fe3123aaa1846fe7" translate="yes" xml:space="preserve">
          <source>The return from &lt;code&gt;VERSION&lt;/code&gt; will actually be the stringified version object using the package &lt;code&gt;$VERSION&lt;/code&gt; scalar, which is guaranteed to be equivalent but may not be precisely the contents of the &lt;code&gt;$VERSION&lt;/code&gt; scalar. If you want the actual contents of &lt;code&gt;$VERSION&lt;/code&gt; , use &lt;code&gt;$CLASS::VERSION&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;VERSION&lt;/code&gt; からの戻りは、実際にはパッケージ &lt;code&gt;$VERSION&lt;/code&gt; スカラーを使用した文字列化されたバージョンオブジェクトになります。これは、同等であることが保証されていますが、正確には &lt;code&gt;$VERSION&lt;/code&gt; スカラーの内容ではない場合があります。あなたは、実際の中身たい場合は &lt;code&gt;$VERSION&lt;/code&gt; 、使用 &lt;code&gt;$CLASS::VERSION&lt;/code&gt; 代わりに。</target>
        </trans-unit>
        <trans-unit id="94b2a16af23a66e19e44621474dc0fa990710d75" translate="yes" xml:space="preserve">
          <source>The return list of the generated Perl function consists of the C return value from the function (unless the XSUB is of &lt;code&gt;void&lt;/code&gt; return type or &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; was used) followed by all the &lt;code&gt;OUTLIST&lt;/code&gt; and &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters (in the order of appearance). On the return from the XSUB the &lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; Perl parameter will be modified to have the values written by the C function.</source>
          <target state="translated">生成されたPerl関数の戻りリストは、関数からのC戻り値（XSUBが &lt;code&gt;void&lt;/code&gt; 戻り型であるか &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; が使用された場合を除く）と、その後に続くすべての &lt;code&gt;OUTLIST&lt;/code&gt; および &lt;code&gt;IN_OUTLIST&lt;/code&gt; パラメーター（出現順に）で構成されます。XSUBからの戻り時に、 &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; Perlパラメータは、C関数によって書き込まれた値を持つように変更されます。</target>
        </trans-unit>
        <trans-unit id="a21da59cc5c1c0e700b109e9dda17411cbacb1df" translate="yes" xml:space="preserve">
          <source>The return true when the argument satisfies the condition. &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; , &lt;code&gt;-inf&lt;/code&gt; are not integers and are neither odd nor even.</source>
          <target state="translated">引数が条件を満たす場合はtrueを返します。 &lt;code&gt;NaN&lt;/code&gt; 、 &lt;code&gt;+inf&lt;/code&gt; 、 &lt;code&gt;-inf&lt;/code&gt; は整数ではなく、奇数でも偶数でもありません。</target>
        </trans-unit>
        <trans-unit id="b8bfaca788fa3c0ddbe45ea5ad9f0da16e79efb8" translate="yes" xml:space="preserve">
          <source>The return value (if defined) is a Perl object, of class &lt;code&gt;PerlIO::Layer&lt;/code&gt; which is created by the C code in</source>
          <target state="translated">戻り値（定義されている場合）は、Perlオブジェクトです。クラスは &lt;code&gt;PerlIO::Layer&lt;/code&gt; で、Cのコードによって作成されます。</target>
        </trans-unit>
        <trans-unit id="45642a1469744a5e7107d7873a8272d52cfce5d2" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">戻り値 &lt;code&gt;LVALUE&lt;/code&gt; は、変数ではない左辺値への参照を示します。これは、 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; などの関数呼び出しの参照から取得します。参照が&lt;a href=&quot;perldata#Version-Strings&quot;&gt;バージョン文字列を&lt;/a&gt;指している場合、 &lt;code&gt;VSTRING&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="68a59800451bff6b585d75aa0febce039f889432" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;../perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">戻り値 &lt;code&gt;LVALUE&lt;/code&gt; は、変数ではない左辺値への参照を示します。これは、 &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; などの関数呼び出しの参照から取得します。参照が&lt;a href=&quot;../perldata#Version-Strings&quot;&gt;バージョン文字列を&lt;/a&gt;指している場合、 &lt;code&gt;VSTRING&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="d1b1a3b59d37e5fda7fca51bd6d7cc822e1098fc" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed to get back an identical copy of the original reference structure. (Please do consider the security implications of eval'ing code from untrusted sources!)</source>
          <target state="translated">戻り値を &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 、元の参照構造の同一のコピーを取得できます。（信頼できないソースからのコードを評価することのセキュリティへの影響を考慮してください！）</target>
        </trans-unit>
        <trans-unit id="5ce36c299811e6d9af00c0cefc9c75e073456ac7" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; の戻り値は実装定義です。詳細については、atan2（3）のマンページを参照してください。</target>
        </trans-unit>
        <trans-unit id="769d902022de1a90d1cd24370f703e7b45d5dad4" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; の戻り値は実装定義です。詳細については、atan2（3）のマンページを参照してください。</target>
        </trans-unit>
        <trans-unit id="7fa7da95c4b58e8bb23e135f8795df5f9ac97aa0" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;true&lt;/code&gt; if this is a valid prototype, and &lt;code&gt;false&lt;/code&gt; if it is not, regardless of whether &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">戻り値は &lt;code&gt;true&lt;/code&gt; これは有効なプロトタイプであれば、そして &lt;code&gt;false&lt;/code&gt; それは関係なく、かどうかにされていない場合 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; した &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd97a8975a72082d0544ff1e498721e427862ae3" translate="yes" xml:space="preserve">
          <source>The return value is POSIX-like (shifted up by 8 bits), which only allows room for a made-up value derived from the severity bits of the native 32-bit condition code (unless overridden by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; ). If the native condition code is one that has a POSIX value encoded, the POSIX value will be decoded to extract the expected exit value. For more details see &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? in perlvms&lt;/a&gt;. (VMS)</source>
          <target state="translated">戻り値はPOSIXに似ており（8ビット上にシフトされます）、ネイティブの32ビット条件コードの重大度ビットから派生した構成値の余地しかありません（ &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用して&lt;/a&gt;オーバーライドしない限り）。ネイティブの条件コードがPOSIX値がエンコードされているコードである場合、POSIX値はデコードされ、予期される終了値が抽出されます。詳細は&lt;a href=&quot;perlvms#%24%3f&quot;&gt;$？を&lt;/a&gt;ご覧ください。perlvmsで。（VMS）</target>
        </trans-unit>
        <trans-unit id="43901da674d6737b62ebf11f4c04c938005307af" translate="yes" xml:space="preserve">
          <source>The return value is always a scalar, either a string or a number. For properties where there are synonyms for the values, the synonym returned by this function is the longest, most descriptive form, the one returned by &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; when called in a scalar context. Of course, you can call &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; on the result to get other synonyms.</source>
          <target state="translated">戻り値は常に文字列または数値のスカラーです。値の同義語があるプロパティの場合、この関数によって返される同義語は、最も長くて最も記述的な形式であり、スカラーコンテキストで呼び出されたときに&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;によって返される形式です。もちろん、結果に対して&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;を呼び出して、他の同義語を取得できます。</target>
        </trans-unit>
        <trans-unit id="01e2753bab1a4f25f52114a02dccb7b840c45d95" translate="yes" xml:space="preserve">
          <source>The return value is the $ctx object itself.</source>
          <target state="translated">戻り値は$ctxオブジェクトそのものです。</target>
        </trans-unit>
        <trans-unit id="52ee5d406f163544969cdcc538ef722336dcb763" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">戻り値は、 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 呼び出しによって返されるプログラムの終了ステータスです。実際の終了値を取得するには、右に8シフトします（以下を参照）。&lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;も参照してください。これは</target>
        </trans-unit>
        <trans-unit id="aadd087b1069c48b3ff2e37ed0925a6bb732b05e" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">戻り値は、 &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 呼び出しによって返されるプログラムの終了ステータスです。実際の終了値を取得するには、右に8シフトします（以下を参照）。&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;も参照してください。これは</target>
        </trans-unit>
        <trans-unit id="857262cdace40b471947bb6d3b761ee596eafe64" translate="yes" xml:space="preserve">
          <source>The return value is the updated object itself.</source>
          <target state="translated">戻り値は更新されたオブジェクトそのものです。</target>
        </trans-unit>
        <trans-unit id="7f93f7b8be78580a6fdb8b5153d679ad923050d6" translate="yes" xml:space="preserve">
          <source>The return value may be a list containing zero or more of an arrayref, an integer, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">戻り値は、0以上のarrayref、整数、または &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を含むリストです。</target>
        </trans-unit>
        <trans-unit id="36fd088c56b8f88cc2d2e8985a8fda08a71a63d3" translate="yes" xml:space="preserve">
          <source>The return value may be an arrayref of 1st to 4th weights as shown above. The return value may be an integer as the primary weight as shown below. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned, the default derived collation element will be used.</source>
          <target state="translated">上記のように、戻り値は1番目から4番目の重みのarrayrefになります。戻り値は、以下に示すように、主要な重みとして整数にすることができます。場合 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 返され、デフォルト派生照合要素が使用されます。</target>
        </trans-unit>
        <trans-unit id="9d5675dc8f958bc8634e0a1b5851a8577fc5c3bc" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; （および &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ）の戻り値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="03abb254ae6958b0d4d3e3d838f5570ae93832e6" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; （および &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ）の戻り値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="16085bf8175ff49a2dcc989db1bc66f5346f4ab0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;INLINED&lt;/code&gt; in this example will always be 54321, regardless of later modifications to $x. You can also put any arbitrary code inside the sub, at it will be executed immediately and its return value captured the same way.</source>
          <target state="translated">この例の &lt;code&gt;INLINED&lt;/code&gt; の戻り値は、後で$ xを変更しても、常に54321になります。サブルーチン内に任意のコードを配置することもできます。サブコードはすぐに実行され、戻り値も同じ方法でキャプチャされます。</target>
        </trans-unit>
        <trans-unit id="f23542316437f18c2dc0de0ad16ae0deb404671a" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;survey&lt;/code&gt; is two hashes:</source>
          <target state="translated">&lt;code&gt;survey&lt;/code&gt; の戻り値は2つのハッシュです。</target>
        </trans-unit>
        <trans-unit id="6c7d2d6bce6775764986b9434f93f3fd3d99f22b" translate="yes" xml:space="preserve">
          <source>The return value of Pod::Perldoc::GetOptsOO::getopts is true if no errors, otherwise it's false.</source>
          <target state="translated">Pod::Perldoc::GetOptsOO::getoptsの戻り値は、エラーがなければtrue、そうでなければfalseです。</target>
        </trans-unit>
        <trans-unit id="57cb77ff2698d7727be628530d185f8aa579f00d" translate="yes" xml:space="preserve">
          <source>The return value of tell() for the standard streams like the STDIN depends on the operating system: it may return -1 or something else. tell() on pipes, fifos, and sockets usually returns -1.</source>
          <target state="translated">STDIN のような標準ストリームの tell()の戻り値はオペレーティングシステムに依存します。</target>
        </trans-unit>
        <trans-unit id="972da9f747345510c81b2dc820fd0994a9799509" translate="yes" xml:space="preserve">
          <source>The return value will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise it can be dereferenced to get the original &lt;code&gt;SV*&lt;/code&gt; . Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL. Effectively a successful hv_store takes ownership of one reference to &lt;code&gt;val&lt;/code&gt; . This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, hv_store will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. hv_store is not implemented as a call to hv_store_ent, and does not create a temporary SV for the key, so if your key data is not already in SV form then use hv_store in preference to hv_store_ent.</source>
          <target state="translated">操作が失敗した場合、または値が実際にハッシュ内に格納される必要がない場合（結合ハッシュの場合など）、戻り値はNULLになります。それ以外の場合は、逆参照して元の &lt;code&gt;SV*&lt;/code&gt; を取得できます。呼び出し元は、呼び出しの前に &lt;code&gt;val&lt;/code&gt; の参照カウントを適切にインクリメントし、関数がNULLを返した場合はそれをデクリメントする責任があることに注意してください。事実上、成功したhv_storeは、 &lt;code&gt;val&lt;/code&gt; への1つの参照の所有権を取得します。通常、これが必要です。新しく作成されたSVの参照カウントは1であるため、すべてのコードがSVを作成してハッシュに格納する場合、hv_storeは新しいSVへの唯一の参照を所有し、コードはこれ以上何もする必要がありません。片付ける。 hv_storeはhv_store_entの呼び出しとして実装されておらず、キーの一時SVを作成しないため、キーデータがまだSV形式でない場合は、hv_store_entよりもhv_storeを使用してください。</target>
        </trans-unit>
        <trans-unit id="9bfc61e3c5920efd0c58d16c1ed44649d2d5bb7c" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error condition, followed by the hostname and service name.</source>
          <target state="translated">返り値はリストで、最初の値はエラー状態、ホスト名とサービス名が続きます。</target>
        </trans-unit>
        <trans-unit id="080fb2b25b92c9701522bdcbe08ea5301edb65d9" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error indication, followed by a list of address structures (if no error occurred).</source>
          <target state="translated">返り値はリストになります。最初の値はエラー表示で、その後にアドレス構造のリストが続きます(エラーが発生しなかった場合)。</target>
        </trans-unit>
        <trans-unit id="e58ba0106a37355ff008e5789a74611883b7e6cc" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains a reference to an array which contains the overview fields for that message.</source>
          <target state="translated">戻り値はハッシュへの参照となり、キーはメッセージ番号で、各値にはそのメッセージの概要フィールドを含む配列への参照が含まれます。</target>
        </trans-unit>
        <trans-unit id="c8d88b4235e896d1cdf2637f38fe289f36609de1" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains the text of the requested header for that message.</source>
          <target state="translated">戻り値はハッシュへの参照となり、キーはメッセージ番号で、各値にはそのメッセージの要求されたヘッダのテキストが含まれます。</target>
        </trans-unit>
        <trans-unit id="17d18fcb9f371a15bbc60a7727df47264e8d90a5" translate="yes" xml:space="preserve">
          <source>The return values are more &quot;cooked&quot; than the &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; ones. For example, the &lt;code&gt;&quot;uc&quot;&lt;/code&gt; property value is the actual string containing the full uppercase mapping of the input code point. You have to go to extra trouble with &lt;code&gt;charinfo&lt;/code&gt; to get this value from its &lt;code&gt;upper&lt;/code&gt; hash element when the full mapping differs from the simple one.</source>
          <target state="translated">戻り値は、&lt;a href=&quot;#charinfo()&quot;&gt;charinfo（）&lt;/a&gt;の戻り値よりも「クック」されています。たとえば、 &lt;code&gt;&quot;uc&quot;&lt;/code&gt; プロパティ値は、入力コードポイントの完全な大文字のマッピングを含む実際の文字列です。完全なマッピングが単純なマッピングと異なる場合は、 &lt;code&gt;charinfo&lt;/code&gt; で余分な問題を発生させて、その &lt;code&gt;upper&lt;/code&gt; ハッシュ要素からこの値を取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="3df12c311a5affa1878c7637ef497a0992643ca1" translate="yes" xml:space="preserve">
          <source>The returned object will only be valid as long as the underlying OPs and SVs continue to exist. Do not attempt to use the object after the underlying structures are freed.</source>
          <target state="translated">返されたオブジェクトは、基礎となる OP と SV が存在し続ける限り有効です。基礎となる構造体が解放された後にオブジェクトを使用しようとしないでください。</target>
        </trans-unit>
        <trans-unit id="afb88fca63fb7d940d0f8f78e07d1c80fa709c01" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;#values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">戻り値はハッシュ内の元のキーのコピーであるため、それらを変更しても元のハッシュには影響しません。&lt;a href=&quot;#values&quot;&gt;値を&lt;/a&gt;比較します。</target>
        </trans-unit>
        <trans-unit id="9d53dad6b674af04a6d84ac0aee48048c271fdde" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">戻り値はハッシュ内の元のキーのコピーであるため、それらを変更しても元のハッシュには影響しません。&lt;a href=&quot;values&quot;&gt;値を&lt;/a&gt;比較します。</target>
        </trans-unit>
        <trans-unit id="21a00c167788624d4ca90d4b617125a344dae47a" translate="yes" xml:space="preserve">
          <source>The returned values for the Perl extension properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt; are somewhat misleading. The values are either &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot;. All Unicode properties are bipartite, so you can actually use the &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot; in a Perl regular rexpression for these, like &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt;. But the Perl extensions aren't specified this way, only like &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ,</source>
          <target state="translated">&lt;code&gt;Any&lt;/code&gt; や &lt;code&gt;Greek&lt;/code&gt; などのPerl拡張プロパティの戻り値は、誤解を招く可能性があります。値は &lt;code&gt;&quot;Y&quot;&lt;/code&gt; または &lt;code&gt;&quot;N&lt;/code&gt; 」です。すべてのUnicodeプロパティは2つの部分からなるため、 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt; ように、Perlの正規表現で &lt;code&gt;&quot;Y&quot;&lt;/code&gt; または &lt;code&gt;&quot;N&lt;/code&gt; 」を実際に使用できます。ただし、Perl拡張機能は &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ようにのみ、この方法で指定されていません。</target>
        </trans-unit>
        <trans-unit id="f5eea968d1f523529d28fcd024fbb7e15c83c048" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; object.</source>
          <target state="translated">Perlインタープリターのリビジョン、バージョン、およびサブ&lt;a href=&quot;version&quot;&gt;バージョン&lt;/a&gt;。バージョンオブジェクトとして表されます。</target>
        </trans-unit>
        <trans-unit id="85e9edc5bb272a0ee91c10e7c6d3172fdb763afd" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a decimal of the form 5.XXXYYY, where XXX is the version / 1e3 and YYY is the subversion / 1e6. For example, Perl v5.10.1 would be &quot;5.010001&quot;.</source>
          <target state="translated">Perl インタプリタのリビジョン、バージョン、サブバージョンは、5.XXXXXYYYという形式の10進数で表され、XXXはバージョン/1e3、YYYはサブバージョン/1e6を表します。例えば、Perl v5.10.1は「5.010001」となります。</target>
        </trans-unit>
        <trans-unit id="66e488be2f8483df95b9f037ffeda3de74384599" translate="yes" xml:space="preserve">
          <source>The rewritten version of this module (vs. v0.01) is slower on certain operations, like &lt;code&gt;new()&lt;/code&gt; , &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;numify()&lt;/code&gt; . The reason are that it does now more work and handles much more cases. The time spent in these operations is usually gained in the other math operations so that code on the average should get (much) faster. If they don't, please contact the author.</source>
          <target state="translated">このモジュール（対v0.01）の書き換えバージョンは次のように、特定の操作上の遅い &lt;code&gt;new()&lt;/code&gt; 、 &lt;code&gt;bstr()&lt;/code&gt; と &lt;code&gt;numify()&lt;/code&gt; 。その理由は、より多くの作業を実行し、より多くのケースを処理するためです。これらの演算に費やされる時間は通常、他の数学演算で得られるため、平均してコードが（はるかに）速くなります。そうでない場合は、作者に連絡してください。</target>
        </trans-unit>
        <trans-unit id="23622f986ab9be80262d33005c6066bc0cc050da" translate="yes" xml:space="preserve">
          <source>The right column will also caution you if a property means something different than what might normally be expected.</source>
          <target state="translated">右側の列は、プロパティが通常想定されているものとは異なる意味を持つ場合にも注意を促します。</target>
        </trans-unit>
        <trans-unit id="ae21a75ed2b2f6ef4dbb92843a55ab639a296c6c" translate="yes" xml:space="preserve">
          <source>The right hand side, starting at line 5 is similar to what we've just seen: we have the &lt;code&gt;add&lt;/code&gt; op (&lt;code&gt;pp_add&lt;/code&gt; also in</source>
          <target state="translated">右側には、5行目から始まることは私達がちょうど見てきたものと似ています。我々は &lt;code&gt;add&lt;/code&gt; オペアンプ（ &lt;code&gt;pp_add&lt;/code&gt; でもします</target>
        </trans-unit>
        <trans-unit id="88e3fe5f1905fd5d0642f37b1a353b457c2b5b66" translate="yes" xml:space="preserve">
          <source>The right operand is not evaluated while the operator is in the &quot;false&quot; state, and the left operand is not evaluated while the operator is in the &quot;true&quot; state. The precedence is a little lower than || and &amp;amp;&amp;amp;. The value returned is either the empty string for false, or a sequence number (beginning with 1) for true. The sequence number is reset for each range encountered. The final sequence number in a range has the string &lt;code&gt;&quot;E0&quot;&lt;/code&gt; appended to it, which doesn't affect its numeric value, but gives you something to search for if you want to exclude the endpoint. You can exclude the beginning point by waiting for the sequence number to be greater than 1.</source>
          <target state="translated">演算子が「偽」の状態にある間、右側のオペランドは評価されません。演算子が「真」の状態にある間、左側のオペランドは評価されません。優先順位は||より少し低いです および&amp;amp;&amp;amp;。返される値は、falseの場合は空の文字列、trueの場合はシーケンス番号（1から始まる）のいずれかです。シーケンス番号は、検出された範囲ごとにリセットされます。範囲内の最後のシーケンス番号には、文字列 &lt;code&gt;&quot;E0&quot;&lt;/code&gt; 追加されます。これは、数値には影響しませんが、エンドポイントを除外する場合に検索するものを提供します。シーケンス番号が1より大きくなるのを待つことで、開始点を除外できます。</target>
        </trans-unit>
        <trans-unit id="712b7dd783ec62d03111b67512c4c71fb70fa066" translate="yes" xml:space="preserve">
          <source>The rightmost delimiter beginning the argument text to the interior sequence (should be &quot;&amp;gt;&quot;).</source>
          <target state="translated">引数のテキストから始まり、内部シーケンスへの右端の区切り文字（ &quot;&amp;gt;&quot;にする必要があります）。</target>
        </trans-unit>
        <trans-unit id="f1b13ab5c99b5028d035c2e34026b78f830a5ce1" translate="yes" xml:space="preserve">
          <source>The rmtree() function provide the legacy interface of remove_tree() with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to remove_tree().</source>
          <target state="translated">rmtree()関数は、渡された引数の解釈を変えてremove_tree()のレガシーインターフェースを提供する。この関数の動作と戻り値は、それ以外はremove_tree()と同じです。</target>
        </trans-unit>
        <trans-unit id="97d9690fe48f5ed9ac8be9b70513653d3ab42339" translate="yes" xml:space="preserve">
          <source>The rot13 example was a trivial example. Here's another demonstration that shows off a few more features.</source>
          <target state="translated">rot13の例は些細な例でした。ここでは、さらにいくつかの機能を示す別のデモを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="4a28f646da84403da9a05e371721d016d1168285" translate="yes" xml:space="preserve">
          <source>The rough perl equivalent is &lt;code&gt;$myarray[$idx]&lt;/code&gt; .</source>
          <target state="translated">おおよそのperl相当は &lt;code&gt;$myarray[$idx]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="07cb0ce6d373861ed9384fe1d2dba7e82ae7d7eb" translate="yes" xml:space="preserve">
          <source>The routine &lt;code&gt;regtail()&lt;/code&gt; is called by both &lt;code&gt;reg()&lt;/code&gt; and &lt;code&gt;regbranch()&lt;/code&gt; in order to &quot;set the tail pointer&quot; correctly. When executing and we get to the end of a branch, we need to go to the node following the grouping parens. When parsing, however, we don't know where the end will be until we get there, so when we do we must go back and update the offsets as appropriate. &lt;code&gt;regtail&lt;/code&gt; is used to make this easier.</source>
          <target state="translated">ルーチン &lt;code&gt;regtail()&lt;/code&gt; は、「テールポインタを正しく設定する」ために、 &lt;code&gt;reg()&lt;/code&gt; と &lt;code&gt;regbranch()&lt;/code&gt; の両方によって呼び出されます。実行してブランチの終わりに到達したら、グループ化括弧の次のノードに移動する必要があります。ただし、解析するときは、そこに到達するまではどこにあるのかわからないので、その場合は戻ってオフセットを適切に更新する必要があります。 &lt;code&gt;regtail&lt;/code&gt; は、これを簡単にするために使用されます。</target>
        </trans-unit>
        <trans-unit id="96fb8a6192d6d2137dae358308fab281f2803684" translate="yes" xml:space="preserve">
          <source>The routine indicated by &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is called when a fatal exception is about to be thrown. The error message is passed as the first argument. When a &lt;code&gt;__DIE__&lt;/code&gt; hook routine returns, the exception processing continues as it would have in the absence of the hook, unless the hook routine itself exits via a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; , a loop exit, or a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;__DIE__&lt;/code&gt; handler is explicitly disabled during the call, so that you can die from a &lt;code&gt;__DIE__&lt;/code&gt; handler. Similarly for &lt;code&gt;__WARN__&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 示されるルーチンは、致命的な例外がスローされようとしているときに呼び出されます。エラーメッセージは最初の引数として渡されます。場合 &lt;code&gt;__DIE__&lt;/code&gt; のフックはリターンフックルーチン自体を介して終了しない限り、それは、フックの非存在下でなければならないように、例外処理が継続 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; 、ループ終了、または &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;__DIE__&lt;/code&gt; のハンドラは、明示的に死ぬことができるように、通話中に無効になっている &lt;code&gt;__DIE__&lt;/code&gt; のハンドラ。同様に &lt;code&gt;__WARN__&lt;/code&gt; の場合。</target>
        </trans-unit>
        <trans-unit id="c23e498d9e0f7b9916602bb81bb457e05dc15d28" translate="yes" xml:space="preserve">
          <source>The routine most often used is &lt;code&gt;call_sv&lt;/code&gt; . The &lt;code&gt;SV*&lt;/code&gt; argument contains either the name of the Perl subroutine to be called, or a reference to the subroutine. The second argument consists of flags that control the context in which the subroutine is called, whether or not the subroutine is being passed arguments, how errors should be trapped, and how to treat return values.</source>
          <target state="translated">最も頻繁に使用されるルーチンは &lt;code&gt;call_sv&lt;/code&gt; です。 &lt;code&gt;SV*&lt;/code&gt; 引数は呼び出されるPerlサブルーチンの名前、またはサブルーチンへのリファレンスが含まれています。2番目の引数は、サブルーチンが呼び出されるコンテキスト、サブルーチンに引数が渡されるかどうか、エラーをトラップする方法、および戻り値の処理方法を制御するフラグで構成されます。</target>
        </trans-unit>
        <trans-unit id="02aa17c916dde6540e50fc69118a82269239b3fa" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;b&gt;false&lt;/b&gt; otherwise.</source>
          <target state="translated">それ以外の場合、ルーチンは&lt;b&gt;falseを&lt;/b&gt;返し&lt;b&gt;ます&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2a6f415596eaaeb6ae6674de29690a406129631d" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for I/O problems or other internal error, a true value otherwise. Serious errors are propagated as a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; exception.</source>
          <target state="translated">ルーチンは、I / Oの問題やその他の内部エラーの場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返し、それ以外の場合は真の値を返します。重大なエラーは次のように伝播され &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; の例外。</target>
        </trans-unit>
        <trans-unit id="30cd5a5724b0cdff1db0ded8bf4cad313b5d3163" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;reftype&lt;/code&gt; are exportable.</source>
          <target state="translated">ルーチン &lt;code&gt;get&lt;/code&gt; および &lt;code&gt;reftype&lt;/code&gt; はエクスポート可能です。</target>
        </trans-unit>
        <trans-unit id="7978092db3768ef7e6d213d57a05b4b46c4c1d11" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; exported by default. You must specify which ones you want to use.</source>
          <target state="translated">&lt;code&gt;make_path&lt;/code&gt; および &lt;code&gt;remove_tree&lt;/code&gt; ルーチンは、デフォルトで&lt;b&gt;は&lt;/b&gt;エクスポートされ&lt;b&gt;ません&lt;/b&gt;。使用するものを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="5f252df425e68241a153a06fc0e9c8513b5f1aa7" translate="yes" xml:space="preserve">
          <source>The routines are called in string comparison order of KEY.</source>
          <target state="translated">ルーチンはKEYの文字列比較の順番で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="258695837b0d342f488ae3724d49cf11d73778d9" translate="yes" xml:space="preserve">
          <source>The rule by which Digest::SHA handles a Unicode string is easy to state, but potentially confusing to grasp: the string is interpreted as a sequence of byte values, where each byte value is equal to the ordinal value (viz. code point) of its corresponding Unicode character. That way, the Unicode string 'abc' has exactly the same digest value as the ordinary string 'abc'.</source>
          <target state="translated">ダイジェスト::SHAがUnicode文字列を処理するルールは、述べるのは簡単ですが、把握するのは混乱を招く可能性があります。文字列はバイト値のシーケンスとして解釈され、各バイト値は対応するUnicode文字の序数値(コードポイント)と等しくなります。このようにして、Unicode 文字列 'abc' は、通常の文字列 'abc' と全く同じダイジェスト値を持っています。</target>
        </trans-unit>
        <trans-unit id="6b4e5af62f9d03a0b5c8d39854ce10f47d56d0b1" translate="yes" xml:space="preserve">
          <source>The rule must only have one top level key: either 'par' for &quot;parallel&quot; or 'seq' for &quot;sequence&quot;.</source>
          <target state="translated">ルールには、トップレベルのキーを1つだけ持っていなければなりません。</target>
        </trans-unit>
        <trans-unit id="2858e68dbb1d52d413ae8f5dae1d589d672ac788" translate="yes" xml:space="preserve">
          <source>The rule of thumb for portable code is: Do it all in portable Perl, or use a module (that may internally implement it with platform-specific code, but exposes a common interface).</source>
          <target state="translated">移植可能なコードの経験則は以下の通りです。移植可能な Perl ですべてを行うか、モジュール (内部的にはプラットフォーム固有のコードで実装されているかもしれませんが、共通のインターフェイスを公開しています)を使用してください。</target>
        </trans-unit>
        <trans-unit id="d771186d9f060b8e39d56f4b8de80fe1694de984" translate="yes" xml:space="preserve">
          <source>The rules data structure is documented more in the next section.</source>
          <target state="translated">ルールのデータ構造については、次のセクションで詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="b2b47541d9fe53d041ea0cd594a357e270362960" translate="yes" xml:space="preserve">
          <source>The rules determining what it is are quite simple: if the character following the backslash is an ASCII punctuation (non-word) character (that is, anything that is not a letter, digit, or underscore), then the backslash just takes away any special meaning of the character following it.</source>
          <target state="translated">バックスラッシュの後に続く文字がASCIIの句読点(非単語)文字(つまり、文字、数字、アンダースコアではないもの)である場合、バックスラッシュはそれに続く文字の特別な意味を奪うだけです。</target>
        </trans-unit>
        <trans-unit id="f747d6278f9a09b6ca106424547e7e55bc600835" translate="yes" xml:space="preserve">
          <source>The rules of conduct that, in the absence of other guidance, determine what should happen first. For example, in the absence of parentheses, you always do multiplication before addition.</source>
          <target state="translated">他の指針がない場合に、最初に何をすべきかを決める行動規則。例えば、カッコがない場合は、必ず足し算の前に掛け算をします。</target>
        </trans-unit>
        <trans-unit id="4ac2685482eb75c8db66c436a646aa6e3d97f9ed" translate="yes" xml:space="preserve">
          <source>The runtime component should have the name</source>
          <target state="translated">ランタイムコンポーネントの名前は</target>
        </trans-unit>
        <trans-unit id="763ace778385d85ae756e3844782d5cfee6e0e05" translate="yes" xml:space="preserve">
          <source>The same approach as a command line:</source>
          <target state="translated">コマンドラインと同じアプローチです。</target>
        </trans-unit>
        <trans-unit id="9976b6a81a6abb21b7cab5b632b4ad690c05665b" translate="yes" xml:space="preserve">
          <source>The same as for &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, but if a missing operator cannot be autogenerated then, instead of issuing an error message, Perl is allowed to revert to what it would have done for that operator if there had been no &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; の場合と同じですが、欠落している演算子を自動生成できない場合、エラーメッセージを発行する代わりに、Perlは、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; ディレクティブがなかった場合に、その演算子に対して行っていた動作に戻すことができます。</target>
        </trans-unit>
        <trans-unit id="286499ca118e6aee1159ad012e0d0c293bc05679" translate="yes" xml:space="preserve">
          <source>The same checksum can also be calculated in OO style:</source>
          <target state="translated">同じチェックサムをOOスタイルで計算することもできます。</target>
        </trans-unit>
        <trans-unit id="e7121397996c97368f3bf5006e5d7cf5183183f6" translate="yes" xml:space="preserve">
          <source>The same effect as the example above in a different way. The coderef takes the alias name as an argument and returns a canonical name on success or undef if not. Note the second argument is ignored if provided. Use this with even more caution than the regex version.</source>
          <target state="translated">上の例と同じ効果を別の方法で実現しています。coderefはエイリアス名を引数に取り、成功した場合は正規の名前を返し、そうでない場合はundefを返します。第二引数が与えられた場合は無視されることに注意してください。これは正規表現版よりもさらに注意して使用してください。</target>
        </trans-unit>
        <trans-unit id="e43451146d37e633afabe95e907553562bae7cb9" translate="yes" xml:space="preserve">
          <source>The same holds for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">サブルーチンを含む、または現在実行中の評価された文字列についても同じことが言えます。 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 文字列の$ filenameは &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; のようになります。</target>
        </trans-unit>
        <trans-unit id="a048bf53e27173e747513cb4000a6c6bd711ca9e" translate="yes" xml:space="preserve">
          <source>The same information is displayed at the end of the output from the command</source>
          <target state="translated">コマンドの出力の最後に同じ情報が表示されます。</target>
        </trans-unit>
        <trans-unit id="fe72bff5d187e52fa5d199f09887af6af2e32815" translate="yes" xml:space="preserve">
          <source>The same is not true of implementations of &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; : these are expected to modify their operand. An appropriate implementation of &lt;code&gt;--&lt;/code&gt; might look like</source>
          <target state="translated">同じことは &lt;code&gt;++&lt;/code&gt; と &lt;code&gt;--&lt;/code&gt; 実装には当てはまりません。これらはオペランドを変更することが期待されています。適切な実装 &lt;code&gt;--&lt;/code&gt; のようになります。</target>
        </trans-unit>
        <trans-unit id="b9889316caadba38254c295ba1f667d08e692e37" translate="yes" xml:space="preserve">
          <source>The same might happen to AIX 5.1 or other OS levels. As a side note, Perl cannot be built without bos.adt.syscalls and bos.adt.libm installed</source>
          <target state="translated">AIX 5.1や他のOSレベルでも同じことが起こるかもしれません。余談ですが、bos.adt.syscalls と bos.adt.libm がインストールされていないと Perl はビルドできません。</target>
        </trans-unit>
        <trans-unit id="2d3beec233d4767fecd283497936fe00947a8d1a" translate="yes" xml:space="preserve">
          <source>The same package name can be used more than once, allowing for non-contiguous code. This is useful if you have a stronger ordering principle than package names.</source>
          <target state="translated">同じパッケージ名を複数回使用することができ、連続しないコードも可能になります。これは、パッケージ名よりも強い順序原則を持っている場合に便利です。</target>
        </trans-unit>
        <trans-unit id="adf0ce12f9a7b11a4e4d148adc2353bc6022f25b" translate="yes" xml:space="preserve">
          <source>The same problems ensue if you enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; on non-ISO8859-1, non-UTF-8 locales (by using either the &lt;b&gt;-C&lt;/b&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable; see &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;). Things are read in as UTF-8, which would normally imply a Unicode interpretation, but the presence of a locale causes them to be interpreted in that locale instead. For example, a 0xD7 code point in the Unicode input, which should mean the multiplication sign, won't be interpreted by Perl that way under the Greek locale. This is not a problem</source>
          <target state="translated">標準ファイルハンドル、デフォルトの &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; レイヤー、および非ISO8859-1以外の &lt;code&gt;@ARGV&lt;/code&gt; の自動UTF-8化を有効にすると、同じ問題が発生します（&lt;b&gt;-C&lt;/b&gt;コマンドラインを使用して）スイッチまたは &lt;code&gt;PERL_UNICODE&lt;/code&gt; の環境変数;参照&lt;a href=&quot;perlrun&quot;&gt;perlrunを&lt;/a&gt;）。物はUTF-8として読み込まれますが、これは通常Unicode解釈を意味しますが、ロケールが存在すると、代わりにそのロケールで解釈されます。たとえば、Unicode入力の0xD7コードポイントは、乗算記号を意味するはずですが、ギリシャ語のロケールではPerlによってそのように解釈されません。これは問題ありません</target>
        </trans-unit>
        <trans-unit id="8104fdf41371cefa43c656a17bffde6b62386dd0" translate="yes" xml:space="preserve">
          <source>The same problems occur if you pass them Math::BigInt-&amp;gt;binf() objects. Since overloading these routines is not possible, this cannot be fixed from BigInt.</source>
          <target state="translated">Math :: BigInt-&amp;gt; binf（）オブジェクトを渡した場合も同じ問題が発生します。これらのルーチンのオーバーロードは不可能であるため、BigIntからこれを修正することはできません。</target>
        </trans-unit>
        <trans-unit id="70e999fed9c0e326d353539553d4a7555374fd82" translate="yes" xml:space="preserve">
          <source>The same template may generally also be used in unpack().</source>
          <target state="translated">一般的には、同じテンプレートを unpack()で使用することもできます。</target>
        </trans-unit>
        <trans-unit id="6b6c7f4b6ab698dbba6b63d74e5bcb57fa5d9973" translate="yes" xml:space="preserve">
          <source>The same tests are run both times, but more information is provided when running as &lt;code&gt;./perl harness&lt;/code&gt;.</source>
          <target state="translated">同じテストが両方の時間に実行されますが、. &lt;code&gt;./perl harness&lt;/code&gt; として実行すると、より多くの情報が提供されます。</target>
        </trans-unit>
        <trans-unit id="1f4add58be52aaba625e5f7ff33a20f204714d58" translate="yes" xml:space="preserve">
          <source>The sample program:</source>
          <target state="translated">サンプルプログラムです。</target>
        </trans-unit>
        <trans-unit id="f745bb5cbca08197cbed6d6403139abf437a8fa9" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value is stored in an SV instance called &lt;code&gt;PL_sv_undef&lt;/code&gt; .</source>
          <target state="translated">スカラー &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 値は、 &lt;code&gt;PL_sv_undef&lt;/code&gt; と呼ばれるSVインスタンスに格納されます。</target>
        </trans-unit>
        <trans-unit id="6e858b562140c68ce32ea23e2b6e666b2e82798f" translate="yes" xml:space="preserve">
          <source>The scalar/list context for the subroutine and for the right-hand side of assignment is determined as if the subroutine call is replaced by a scalar. For example, consider:</source>
          <target state="translated">サブルーチンの呼び出しと代入の右辺のスカラ/リストコンテキストは、サブルーチンの呼び出しがスカラに置き換えられたかのように決定されます。例えば、次のように考えてみてください。</target>
        </trans-unit>
        <trans-unit id="8a59c0bcb531b15ec7601a5c46eda41a994dbd08" translate="yes" xml:space="preserve">
          <source>The scheme above allows interpretation of a wide range of dates, particularly if 4-digit years are used.</source>
          <target state="translated">上記のスキームでは、特に4桁の年号を使用している場合には、幅広い日付の解釈が可能です。</target>
        </trans-unit>
        <trans-unit id="3fc0ce48ddfa00a9f249dd98501d09516efb57c0" translate="yes" xml:space="preserve">
          <source>The scheme from the uri (like 'file', 'http', etc)</source>
          <target state="translated">uriからのスキーム('file'、'http'など</target>
        </trans-unit>
        <trans-unit id="49277474cf2c3fa04e4e431396fc13bca0311697" translate="yes" xml:space="preserve">
          <source>The scope where &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; is used has escalated the &lt;code&gt;void&lt;/code&gt; warnings category into a fatal error, so the program terminates immediately when it encounters the warning.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; が使用されているスコープにより、 &lt;code&gt;void&lt;/code&gt; 警告カテゴリが致命的なエラーにエスカレートされたため、プログラムは警告に遭遇するとすぐに終了します。</target>
        </trans-unit>
        <trans-unit id="05dbbff48c1e514e522b4520f47f1f9d051aaac1" translate="yes" xml:space="preserve">
          <source>The script first verifies the function of the &lt;code&gt;Name&lt;/code&gt; class.</source>
          <target state="translated">スクリプトは最初に &lt;code&gt;Name&lt;/code&gt; クラスの機能を確認します。</target>
        </trans-unit>
        <trans-unit id="bab70c074a8060d72a4a917d75cb758f3fdbebe9" translate="yes" xml:space="preserve">
          <source>The script is available from &lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;https://gist.github.com/eqhmcow/5389877&lt;/a&gt;</source>
          <target state="translated">スクリプトは&lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;https://gist.github.com/eqhmcow/5389877&lt;/a&gt;から入手できます。</target>
        </trans-unit>
        <trans-unit id="bc3001b62b3120b5e625f2291ab08a912ad78b79" translate="yes" xml:space="preserve">
          <source>The search engine will initially match &lt;code&gt;\D*&lt;/code&gt; with &quot;ABC&quot;. Then it will try to match &lt;code&gt;(?!123)&lt;/code&gt; with &quot;123&quot;, which fails. But because a quantifier (&lt;code&gt;\D*&lt;/code&gt; ) has been used in the regular expression, the search engine can backtrack and retry the match differently in the hope of matching the complete regular expression.</source>
          <target state="translated">検索エンジンは最初に &lt;code&gt;\D*&lt;/code&gt; を &quot;ABC&quot;と照合します。次に、 &lt;code&gt;(?!123)&lt;/code&gt; を &quot;123&quot;と一致させようとしますが、失敗します。ただし、正規表現で数量詞（ &lt;code&gt;\D*&lt;/code&gt; ）が使用されているため、検索エンジンは完全な正規表現と一致することを期待して、バックトラックして別の方法で一致を再試行できます。</target>
        </trans-unit>
        <trans-unit id="4989338d675235ed7afc62322345e940a111f8d8" translate="yes" xml:space="preserve">
          <source>The second advantage is that embedded modifiers (except &lt;code&gt;//p&lt;/code&gt; , which modifies the entire regexp) only affect the regexp inside the group the embedded modifier is contained in. So grouping can be used to localize the modifier's effects:</source>
          <target state="translated">2番目の利点は、埋め込まれた修飾子（正規表現全体を変更する &lt;code&gt;//p&lt;/code&gt; を除く）は、埋め込まれた修飾子が含まれるグループ内の正規表現にのみ影響するということです。したがって、グループ化を使用して修飾子の効果をローカライズできます。</target>
        </trans-unit>
        <trans-unit id="e6b19a99a58715509197b4fd3bb055452f4e6bb8" translate="yes" xml:space="preserve">
          <source>The second and third arguments &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; specify how many of the specified type of data structure should be allocated. The argument &lt;code&gt;type&lt;/code&gt; is passed to &lt;code&gt;sizeof&lt;/code&gt; . The final argument to &lt;code&gt;Newxc&lt;/code&gt; , &lt;code&gt;cast&lt;/code&gt; , should be used if the &lt;code&gt;pointer&lt;/code&gt; argument is different from the &lt;code&gt;type&lt;/code&gt; argument.</source>
          <target state="translated">2番目と3番目の引数の &lt;code&gt;number&lt;/code&gt; と &lt;code&gt;type&lt;/code&gt; は、指定されたタイプのデータ構造の何個を割り当てる必要があるかを指定します。引数の &lt;code&gt;type&lt;/code&gt; は &lt;code&gt;sizeof&lt;/code&gt; に渡されます。 &lt;code&gt;Newxc&lt;/code&gt; の最後の引数である &lt;code&gt;cast&lt;/code&gt; は、 &lt;code&gt;pointer&lt;/code&gt; 引数が &lt;code&gt;type&lt;/code&gt; 引数と異なる場合に使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9372cc26ce11f225b78cb9001dded71987be37ab" translate="yes" xml:space="preserve">
          <source>The second argument ($eol) is the line-ending sequence to use. It is optional and defaults to &quot;\n&quot;. Every occurrence of &quot;\n&quot; is replaced with this string, and it is also used for additional &quot;soft line breaks&quot; to ensure that no line end up longer than 76 characters. Pass it as &quot;\015\012&quot; to produce data suitable for external consumption. The string &quot;\r\n&quot; produces the same result on many platforms, but not all.</source>
          <target state="translated">第二引数 ($eol)は、使用する改行シーケンスです。これはオプションで、デフォルトは &quot;\n&quot; です。&quot;\n&quot; のすべての出現はこの文字列に置き換えられ、76文字より長い行がないことを保証するための追加の &quot;ソフト改行&quot; にも使用されます。&quot;\015012 &quot;として渡して、外部消費に適したデータを生成する。文字列&quot;\rn &quot;は、多くのプラットフォームで同じ結果を生成するが、すべてではない。</target>
        </trans-unit>
        <trans-unit id="691db7e7ba5b2eef57391203c3fd8b3455b42a9c" translate="yes" xml:space="preserve">
          <source>The second argument can be a hash reference with options, which are identical to the arguments passed to &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">2番目の引数は、 &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; に渡される引数と同じであるオプション付きのハッシュ参照にすることができます。</target>
        </trans-unit>
        <trans-unit id="36e7dec2e6aed1723cd212b39460017f8772c38b" translate="yes" xml:space="preserve">
          <source>The second argument is a regular expression. It may be given as a regex reference (i.e. &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;) or (for better compatibility with older perls) as a string that looks like a regex (alternative delimiters are currently not supported):</source>
          <target state="translated">2番目の引数は正規表現です。正規表現の参照（つまり &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; ）または（古いperlとの互換性を高めるため）正規表現のように見える文字列として指定できます（代替の区切り文字は現在サポートされていません）。</target>
        </trans-unit>
        <trans-unit id="e9cd8da657568e7bbba17b34028b2178bd5abb57" translate="yes" xml:space="preserve">
          <source>The second argument is considered a regex if it is either a regex object or a string that looks like a regex. Regex objects are constructed with the qr// operator in recent versions of perl. A string is considered to look like a regex if its first and last characters are &quot;/&quot;, or if the first character is &quot;m&quot; and its second and last characters are both the same non-alphanumeric non-whitespace character. These regexp</source>
          <target state="translated">第二引数は、正規表現オブジェクトか正規表現のように見える文字列のいずれかであれば、正規表現とみなされます。正規表現オブジェクトは、perlの最近のバージョンではqr//演算子を使って構築されます。文字列は、最初と最後の文字が&quot;/&quot;であるか、最初の文字が &quot;m &quot;で、2番目と最後の文字が両方とも同じ英数字以外の非空白文字である場合、正規表現のように見えるとみなされます。これらの正規表現</target>
        </trans-unit>
        <trans-unit id="ffe3c605f37afcab4c8601d801b588d13a566637" translate="yes" xml:space="preserve">
          <source>The second argument is the other operand, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in the case of a unary operator.</source>
          <target state="translated">2番目の引数はもう一方のオペランド、または単項演算子の場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e99835175d57940dd272e3dc71fc2882ef5b0d66" translate="yes" xml:space="preserve">
          <source>The second argument is used to indicate compression. You can either compress using &lt;code&gt;gzip&lt;/code&gt; or &lt;code&gt;bzip2&lt;/code&gt; . If you pass a digit, it's assumed to be the &lt;code&gt;gzip&lt;/code&gt; compression level (between 1 and 9), but the use of constants is preferred:</source>
          <target state="translated">2番目の引数は、圧縮を示すために使用されます。 &lt;code&gt;gzip&lt;/code&gt; または &lt;code&gt;bzip2&lt;/code&gt; を使用して圧縮できます。数字を渡す場合は、 &lt;code&gt;gzip&lt;/code&gt; 圧縮レベル（1〜9）と見なされますが、定数を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a0c730e612ef3dd802df3a15f52c50f234217ccd" translate="yes" xml:space="preserve">
          <source>The second argument may be considered optional, but remains for backwards compatibility. Archive::Tar now looks at the file magic to determine what class should be used to open the file and will transparently Do The Right Thing.</source>
          <target state="translated">2 番目の引数はオプションとみなされるかもしれませんが、下位互換性のために残っています。Archive::Tar は、ファイルを開くためにどのクラスを使うべきかを決定するためにファイルマジックを見て、透過的に Do The Right Thing を実行するようになりました。</target>
        </trans-unit>
        <trans-unit id="fc50752077e3b12e3cd10f78b06bb8c9b8f956b4" translate="yes" xml:space="preserve">
          <source>The second argument points to an array containing &lt;code&gt;num&lt;/code&gt;&lt;code&gt;SV*&lt;/code&gt; 's. Once the AV has been created, the SVs can be destroyed, if so desired.</source>
          <target state="translated">2番目の引数は、 &lt;code&gt;num&lt;/code&gt; 個の &lt;code&gt;SV*&lt;/code&gt; を含む配列を指します。AVが作成されたら、必要に応じてSVを破棄できます。</target>
        </trans-unit>
        <trans-unit id="241df4a30fc4febc2cd9ef098abdb1cdbc871750" translate="yes" xml:space="preserve">
          <source>The second call to hex() will warn about a non-portable constant.</source>
          <target state="translated">hex()の二回目の呼び出しは、移植性のない定数について警告します。</target>
        </trans-unit>
        <trans-unit id="52f5fb6e434df4bf3ba2648b67634f2b93cdc1b5" translate="yes" xml:space="preserve">
          <source>The second call-back is optional if the call back is registered prior to the call to $term-&amp;gt;readline.</source>
          <target state="translated">$ term-&amp;gt; readlineを呼び出す前にコールバックが登録されている場合、2番目のコールバックはオプションです。</target>
        </trans-unit>
        <trans-unit id="104d457b0581ca75e5a33a6cc382aa3d75495d54" translate="yes" xml:space="preserve">
          <source>The second call-back registered is the call back for registration. The input filehandle (often STDIN, but not necessarily) will be passed in.</source>
          <target state="translated">2番目に登録されたコールバックは、登録のためのコールバックです。入力されたファイルハンドル(多くの場合はSTDINですが、必ずしもそうとは限りません)が渡されます。</target>
        </trans-unit>
        <trans-unit id="0d9c1d1eb4a7fe50e319b8d6cb4e544cda2638c9" translate="yes" xml:space="preserve">
          <source>The second column is the return type, the third column the name. Columns after that are the arguments. The first column is a set of flags:</source>
          <target state="translated">2番目のカラムは戻り値の種類、3番目のカラムは名前です。それ以降の列は引数です。最初のカラムはフラグのセットです。</target>
        </trans-unit>
        <trans-unit id="833ac465c5bc76260e3533a8f5293c1a6cc4e353" translate="yes" xml:space="preserve">
          <source>The second example in the synopsis does something equivalent to this:</source>
          <target state="translated">シノプシスの2つ目の例は、これに相当することをしています。</target>
        </trans-unit>
        <trans-unit id="f7f8f6797190b2ee94971db1ba0f6aeb4ac8dc06" translate="yes" xml:space="preserve">
          <source>The second example prints entries with names &lt;code&gt;foo&lt;/code&gt; , and also entries with names which ends on &lt;code&gt;bar&lt;/code&gt; , or are shorter than 5 chars.</source>
          <target state="translated">2番目の例は、名前が &lt;code&gt;foo&lt;/code&gt; のエントリと、名前が &lt;code&gt;bar&lt;/code&gt; で終わるか、5文字より短いエントリも出力します。</target>
        </trans-unit>
        <trans-unit id="6b7ec951497cf0073403b17626a675e036c31257" translate="yes" xml:space="preserve">
          <source>The second exit point tests if there is any data left in the input buffer, &lt;code&gt;$input&lt;/code&gt; - remember that the &lt;code&gt;ConsumeInput&lt;/code&gt; option is automatically enabled when &lt;code&gt;LimitOutput&lt;/code&gt; is used. When the input buffer has been exhausted, the outer loop can run again and overwrite a now empty &lt;code&gt;$input&lt;/code&gt; .</source>
          <target state="translated">2番目の出口点は、入力バッファー &lt;code&gt;$input&lt;/code&gt; データが残っているかどうかをテストします &lt;code&gt;LimitOutput&lt;/code&gt; を使用すると、 &lt;code&gt;ConsumeInput&lt;/code&gt; オプションが自動的に有効になることに注意してください。入力バッファが使い果たされると、外側のループが再度実行され、空になった &lt;code&gt;$input&lt;/code&gt; を上書きできます。</target>
        </trans-unit>
        <trans-unit id="1dba4d9ed358b9b1b26a10b82c95880d18ef1ec5" translate="yes" xml:space="preserve">
          <source>The second form allows the filter to hold state information using a closure, thus:</source>
          <target state="translated">第2の実施形態によれば、フィルタは、クロージャを用いて状態情報を保持することができるので、このようにして、状態情報を保持することができる。</target>
        </trans-unit>
        <trans-unit id="204d9fcc358796976a40cb62f3873844790ea690" translate="yes" xml:space="preserve">
          <source>The second form is strongly discouraged, because it breaks the ability of a subclass to reuse the parent's constructor, but you may still run across it in existing code.</source>
          <target state="translated">2 番目の形式は、サブクラスが親のコンストラクタを再利用する能力を壊すので、強くお勧めしません。</target>
        </trans-unit>
        <trans-unit id="0819d819ae212b8e1bcdb9b5bc6d671458a8958e" translate="yes" xml:space="preserve">
          <source>The second form limits or expands the output with shell globbing as in the following examples:</source>
          <target state="translated">2 番目の形式では、以下の例のようにシェル・グロビングを使用して出力を制限または拡張します。</target>
        </trans-unit>
        <trans-unit id="c407c89499b72c27a5a072472ddedf2b307bb4f0" translate="yes" xml:space="preserve">
          <source>The second form takes an ASCII string of &quot;0&quot; and &quot;1&quot; characters as its argument. It's equivalent to</source>
          <target state="translated">2番目の形式は、&quot;0 &quot;と &quot;1 &quot;のASCII文字列を引数に取ります。これは次のようなものです。</target>
        </trans-unit>
        <trans-unit id="653b770c920437547bfd253af4e36f98e0dbfce5" translate="yes" xml:space="preserve">
          <source>The second form, for convenience, simply calls the &lt;code&gt;new&lt;/code&gt; method on its arguments before dumping the object immediately.</source>
          <target state="translated">2番目の形式は、便宜上、オブジェクトをすぐにダンプする前に、引数で &lt;code&gt;new&lt;/code&gt; メソッドを呼び出すだけです。</target>
        </trans-unit>
        <trans-unit id="dc711c3d286876153bcbf61db541b42c9a9350fc" translate="yes" xml:space="preserve">
          <source>The second gives data on how many keys are at each depth in the chain, and gives an idea of how much work a fetch *hit* will take. The performance for an update or delete of an item in the hash is equivalent to this case.</source>
          <target state="translated">2つ目は、チェーンの各深さにどれだけのキーがあるかのデータを提供し、フェッチ*hit*にどれだけの作業が必要かのアイデアを提供します。ハッシュ内のアイテムの更新や削除のパフォーマンスは、この場合と同等です。</target>
        </trans-unit>
        <trans-unit id="5995436678b8ce31e572994a72a1c15e94c7f93e" translate="yes" xml:space="preserve">
          <source>The second is</source>
          <target state="translated">2つ目は</target>
        </trans-unit>
        <trans-unit id="3d4dc00d964c0b0076b393752a2dfc8106f40760" translate="yes" xml:space="preserve">
          <source>The second is a question mark &lt;code&gt;?&lt;/code&gt; to match any single character. The third specifies a specific set of characters.</source>
          <target state="translated">2番目は疑問符 &lt;code&gt;?&lt;/code&gt; 任意の1文字に一致します。3番目は、特定の文字セットを指定します。</target>
        </trans-unit>
        <trans-unit id="86badbc4e990f49a4a0e0309ce3e34af3acb8215" translate="yes" xml:space="preserve">
          <source>The second is, in short, more readable. In particular, it's obvious that the number of parameters you're feeding to that phrase (two) is the number of parameters that it</source>
          <target state="translated">2つ目は、要するに、より読みやすくなっています。特に、そのフレーズに与えているパラメータの数(2)は明らかに</target>
        </trans-unit>
        <trans-unit id="7d7dcadbcc9256c73e53e45ca4167a8f00171936" translate="yes" xml:space="preserve">
          <source>The second method both creates the AV and initially populates it with SVs:</source>
          <target state="translated">2つ目の方法は、両方ともAVを作成し、最初にSVを入れます。</target>
        </trans-unit>
        <trans-unit id="5a04571edd1042cba183eaac5eb081daffd5163c" translate="yes" xml:space="preserve">
          <source>The second method divides up the generated code into</source>
          <target state="translated">2 番目のメソッドは、生成されたコードを次のように分割します。</target>
        </trans-unit>
        <trans-unit id="30b5717864fa144252bae28ce0e68e9e2886c509" translate="yes" xml:space="preserve">
          <source>The second new display parameter is &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; , which can be set to true or false, the default being true. See the previous section for what this means.</source>
          <target state="translated">2番目の新しい表示パラメーターは &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; で、trueまたはfalseに設定できます。デフォルトはtrueです。これの意味については、前のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="105094491ac9a931737afcae5ec00cc67ecea83f" translate="yes" xml:space="preserve">
          <source>The second option is to explicitly instruct Configure to detect the newer Berkeley DB installation, by supplying the right directories with &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; and &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt;&lt;b&gt;and&lt;/b&gt; before running &quot;make test&quot; setting your LD_LIBRARY_PATH to</source>
          <target state="translated">2番目のオプションは、正しいディレクトリに &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; および &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt; &lt;b&gt;を指定し&lt;/b&gt;、LD_LIBRARY_PATHを &quot;make test&quot;に設定する前に、Configureに新しいBerkeley DBインストールを検出するように明示的に指示することです。</target>
        </trans-unit>
        <trans-unit id="b104d0289f2a63192d73ded4515b99bcffef5da9" translate="yes" xml:space="preserve">
          <source>The second parameter, &lt;code&gt;$mode&lt;/code&gt; , is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the &lt;code&gt;$mode&lt;/code&gt; parameter is similar to the mode parameter to the 'C' function &lt;code&gt;fopen&lt;/code&gt; , so &quot;rb&quot; is used to open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for appending (writing at the end of the file).</source>
          <target state="translated">2番目のパラメーター &lt;code&gt;$mode&lt;/code&gt; は、ファイルを読み取り用または書き込み用に開くかどうかを指定し、オプションで書き込み時の圧縮レベルと圧縮方法を指定するために使用されます。 &lt;code&gt;$mode&lt;/code&gt; パラメーターの形式は、'C'関数 &lt;code&gt;fopen&lt;/code&gt; のモードパラメーターに似ているため、「rb」を使用して読み取り用に開き、「wb」を書き込み用に、「ab」を追加して（末尾の書き込み）ファイル）。</target>
        </trans-unit>
        <trans-unit id="9eae2bfeb40a7aaf7114e7fd8256ee81caccdbd3" translate="yes" xml:space="preserve">
          <source>The second regexp doesn't match because &lt;code&gt;^&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the beginning of the string, but &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; has keeper starting in the middle. The third regexp does match, since the &lt;code&gt;$&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the end of the string.</source>
          <target state="translated">2番目の正規表現は一致しません。 &lt;code&gt;^&lt;/code&gt; により、 &lt;code&gt;keeper&lt;/code&gt; は文字列の先頭でのみ一致するように制約されますが、 &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; は途中でキーパーを開始します。 &lt;code&gt;$&lt;/code&gt; は &lt;code&gt;keeper&lt;/code&gt; が文字列の最後でのみ一致するように制約するため、3番目の正規表現は一致します。</target>
        </trans-unit>
        <trans-unit id="733da91fc44d8ab5e75ced78a6cc48a582c7d7b0" translate="yes" xml:space="preserve">
          <source>The second returned item and &lt;code&gt;$!&lt;/code&gt; can be used to check for valid input:</source>
          <target state="translated">2番目の返品アイテムと &lt;code&gt;$!&lt;/code&gt; 有効な入力を確認するために使用できます：</target>
        </trans-unit>
        <trans-unit id="2c1496bf9c5a01143ce96b1f9c010fe32e40f772" translate="yes" xml:space="preserve">
          <source>The second sentence is wrong. In actual fact bval will only default to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; when the openinfo parameter in dbopen is NULL. If a non-NULL openinfo parameter is used at all, the value that happens to be in bval will be used. That means you always have to specify bval when making use of any of the options in the openinfo parameter. This documentation error will be fixed in the next release of Berkeley DB.</source>
          <target state="translated">2番目の文は間違っています。実際には、bopenのデフォルトは、dbopenのopeninfoパラメータがNULLの場合にのみ &lt;code&gt;&quot;\n&quot;&lt;/code&gt; になります。 NULL以外のopeninfoパラメータを使用すると、たまたまbvalにある値が使用されます。つまり、openinfoパラメータのオプションを使用するときは、常にbvalを指定する必要があります。このドキュメントエラーは、Berkeley DBの次のリリースで修正される予定です。</target>
        </trans-unit>
        <trans-unit id="aaad1f57fe700f2a9b2dd58ec708684feaf8128f" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a lexical subroutine that has gone out of scope, for example,</source>
          <target state="translated">2つ目の状況は、例えば範囲外になってしまった語彙サブルーチンに eval がアクセスすることで発生します。</target>
        </trans-unit>
        <trans-unit id="9ade278ee614d31e9547b1781d35dc6ff90a8980" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a variable that has gone out of scope, for example,</source>
          <target state="translated">2つ目の状況は、evalがスコープ外になった変数にアクセスしている場合などに発生します。</target>
        </trans-unit>
        <trans-unit id="b47d8c8a23f4e0d763e99999d69c0c5eb0cb3a92" translate="yes" xml:space="preserve">
          <source>The second style of bundling lifts this restriction. It can be enabled with:</source>
          <target state="translated">2 番目のスタイルのバンドルは、この制限を解除します。で有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="ab8073e684e0f88cfe3fd5f9716b9c696bbef27e" translate="yes" xml:space="preserve">
          <source>The second value to be substituted in the output string (usually the row in cursor addressing capabilities)</source>
          <target state="translated">出力文字列で置換される2番目の値(通常はカーソルアドレッシング機能の行)</target>
        </trans-unit>
        <trans-unit id="72ec171fc6e9d8dd4e1917d8ba0d47a2f390d23d" translate="yes" xml:space="preserve">
          <source>The second, more efficient way is to use the following template for your Foo.xs:</source>
          <target state="translated">2つ目のより効率的な方法は、以下のテンプレートをFoo.xsに使用することです。</target>
        </trans-unit>
        <trans-unit id="ea8fa202ee5b9df3dfb7272625ecae21681f7d7d" translate="yes" xml:space="preserve">
          <source>The section (AKA &quot;item&quot; in older perlpods), or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if none. E.g., in &quot;L&amp;lt;Getopt::Std/DESCRIPTION&amp;gt;&quot;, &quot;DESCRIPTION&quot; is the section. (Note that this is not the same as a manpage section like the &quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the Pod sense means the part of the text that's introduced by the heading or item whose text is &quot;Foo&quot;.)</source>
          <target state="translated">セクション（古いperlpodでは「アイテム」とも呼ばれます）、または存在しない場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。たとえば、「L &amp;lt;Getopt :: Std / DESCRIPTION&amp;gt;」では、「DESCRIPTION」がセクションです。 （これは、「man 5 crontab」の「5」のようなマンページセクションと同じではないことに注意してください。ポッドの意味での「セクションFoo」は、「Foo」という見出しまたは項目によって導入されたテキストの部分を意味します」</target>
        </trans-unit>
        <trans-unit id="8d5faf936bbea0ef6b4af3b53c6607ced9b3cdea" translate="yes" xml:space="preserve">
          <source>The security aspect of temporary file creation is emphasized such that a filehandle and filename are returned together. This helps guarantee that a race condition can not occur where the temporary file is created by another process between checking for the existence of the file and its opening. Additional security levels are provided to check, for example, that the sticky bit is set on world writable directories. See &lt;a href=&quot;#safe_level&quot;&gt;safe_level&lt;/a&gt; for more information.</source>
          <target state="translated">一時ファイル作成のセキュリティ面は、ファイルハンドルとファイル名が一緒に返されるように強調されています。これにより、ファイルの存在を確認してからそのファイルを開くまでの間に別のプロセスによって一時ファイルが作成される場合に、競合状態が発生しないことが保証されます。たとえば、スティッキービットが誰でも書き込み可能なディレクトリに設定されていることを確認するために、追加のセキュリティレベルが提供されます。詳細については、&lt;a href=&quot;#safe_level&quot;&gt;safe_level&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="02ef1170c6c4276366f2c9602e48f300db3d9145" translate="yes" xml:space="preserve">
          <source>The seemingly equivalent construct in Perl, &lt;code&gt;$$aref[$i]&lt;/code&gt; first does the deref of $aref, making it take $aref as a reference to an array, and then dereference that, and finally tell you the</source>
          <target state="translated">Perlでは &lt;code&gt;$$aref[$i]&lt;/code&gt; は一見同等の構造であり、最初に$ arefのderefを実行し、$ arefを配列への参照として取得し、次にそれを逆参照して、最後に</target>
        </trans-unit>
        <trans-unit id="5d3a7adddb69f2204deb61bd662439aeebd384d4" translate="yes" xml:space="preserve">
          <source>The semantics of interval timers for multithreaded programs are system-specific, and some systems may support additional interval timers. For example, it is unspecified which thread gets the signals. See your &lt;code&gt;setitimer()&lt;/code&gt; documentation.</source>
          <target state="translated">マルチスレッドプログラムのインターバルタイマーのセマンティクスはシステム固有であり、システムによっては追加のインターバルタイマーをサポートする場合があります。たとえば、どのスレッドがシグナルを受け取るかは不定です。 &lt;code&gt;setitimer()&lt;/code&gt; のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="65ef3e0624e679879b7ce02cec7d6809073f165d" translate="yes" xml:space="preserve">
          <source>The sense of the match can be reversed by using &lt;code&gt;!~&lt;/code&gt; operator:</source>
          <target state="translated">&lt;code&gt;!~&lt;/code&gt; 演算子を使用して、一致の意味を逆にすることができます。</target>
        </trans-unit>
        <trans-unit id="571f2b8a003669439aca5df927f2bc3b59493e17" translate="yes" xml:space="preserve">
          <source>The sequence &lt;code&gt;\b&lt;/code&gt; is special inside a bracketed character class. While outside the character class, &lt;code&gt;\b&lt;/code&gt; is an assertion indicating a point that does not have either two word characters or two non-word characters on either side, inside a bracketed character class, &lt;code&gt;\b&lt;/code&gt; matches a backspace character.</source>
          <target state="translated">シーケンス &lt;code&gt;\b&lt;/code&gt; は、括弧で囲まれた文字クラス内では特別です。文字クラスの外側にある &lt;code&gt;\b&lt;/code&gt; は、両側に2つの単語文字または2つの非単語文字がないポイントを示すアサーションであり、角括弧で囲まれた文字クラス内では、 &lt;code&gt;\b&lt;/code&gt; はバックスペース文字と一致します。</target>
        </trans-unit>
        <trans-unit id="6b263532d25e62f98e230387976bd3e1a8c5cb59" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP's next OP.</source>
          <target state="translated">次のOPのシークエンスナンバーです。</target>
        </trans-unit>
        <trans-unit id="b45bacc53a5ed1f0afceaa4ff3006834edab117c" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP, or a hyphen if it doesn't have one.</source>
          <target state="translated">OPのシーケンス番号、またはハイフンがない場合はハイフン。</target>
        </trans-unit>
        <trans-unit id="4f0a83d5889e74bacf92e475321b6ad01721beb5" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP. Note that this is a sequence number generated by B::Concise.</source>
          <target state="translated">OPのシーケンス番号。これはB::Conciseによって生成されたシーケンス番号であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c10dc949f49eb3d32cdb0534e93e9f1fddb641e8" translate="yes" xml:space="preserve">
          <source>The sequences &lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; , and &lt;code&gt;\x&lt;/code&gt; are also special and have the same meanings as they do outside a bracketed character class.</source>
          <target state="translated">シーケンス &lt;code&gt;\a&lt;/code&gt; 、 &lt;code&gt;\c&lt;/code&gt; 、 &lt;code&gt;\e&lt;/code&gt; 、 &lt;code&gt;\f&lt;/code&gt; 、 &lt;code&gt;\n&lt;/code&gt; 、 &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; 、 &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt; 、 &lt;code&gt;\r&lt;/code&gt; 、 &lt;code&gt;\t&lt;/code&gt; 、および &lt;code&gt;\x&lt;/code&gt; も特殊であり、それらと同じ意味です大括弧で囲まれた文字クラスの外側で行います。</target>
        </trans-unit>
        <trans-unit id="0d53186f69243fe4e7fc81db07bccfc51f977e9e" translate="yes" xml:space="preserve">
          <source>The serializing hook, called on the object during serialization. It can be inherited, or defined in the class itself, like any other method.</source>
          <target state="translated">シリアライズ中にオブジェクト上で呼び出されるシリアライズフック。他のメソッドのように継承することもできますし、クラス自体で定義することもできます。</target>
        </trans-unit>
        <trans-unit id="4e9ebcecc7a860f145ea8f9108514a4fa8316dfb" translate="yes" xml:space="preserve">
          <source>The service name supplied to getaddrinfo() is not available for the socket type given in the $hints.</source>
          <target state="translated">getaddrinfo()に与えられたサービス名は、$hints で指定されたソケットタイプでは利用できません。</target>
        </trans-unit>
        <trans-unit id="ba23ccf9d34101355ab34a3727e24a0a0f7b250a" translate="yes" xml:space="preserve">
          <source>The services a piece of code promises to provide forever, in contrast to its &lt;b&gt;implementation&lt;/b&gt;, which it should feel free to change whenever it likes.</source>
          <target state="translated">コードの一部が提供するサービスは、その&lt;b&gt;実装&lt;/b&gt;とは対照的に、いつでも提供することが約束されています。</target>
        </trans-unit>
        <trans-unit id="32c78a4d560dbf4474d5f3b5cef5e0e631bdf4c5" translate="yes" xml:space="preserve">
          <source>The set is specified as a list of characters, or as a range of characters where the beginning and end of the range are separated by a minus (or dash) character, or as any combination of lists and ranges. The dash can also be included in the set as a character it if is the beginning or end of the set. This set is enclosed in square brackets. The close square bracket &lt;code&gt;]&lt;/code&gt; may be used in a set if it is the first character in the set.</source>
          <target state="translated">セットは、文字のリストとして、または範囲の先頭と末尾がマイナス（またはダッシュ）文字で区切られている文字の範囲として、またはリストと範囲の任意の組み合わせとして指定されます。ダッシュは、セットの先頭または末尾の場合、文字itとしてセットに含めることもできます。このセットは角括弧で囲まれています。右角括弧 &lt;code&gt;]&lt;/code&gt; がセットの最初の文字である場合は、セットで使用できます。</target>
        </trans-unit>
        <trans-unit id="271c11282a628a982454242ec29109ed2ea23f1d" translate="yes" xml:space="preserve">
          <source>The set of characters that are deemed whitespace are those that Unicode calls &quot;Pattern White Space&quot;, namely:</source>
          <target state="translated">ホワイトスペースとみなされる文字のセットは、ユニコードが「パターン・ホワイトスペース」と呼んでいる文字、すなわちホワイトスペースです。</target>
        </trans-unit>
        <trans-unit id="5e7d4549f7a90817f3e92cc9271f629864ca580a" translate="yes" xml:space="preserve">
          <source>The setlocale function</source>
          <target state="translated">setlocale関数</target>
        </trans-unit>
        <trans-unit id="6cd53441a7a72535c4ff8e055f31a3a3fc042379" translate="yes" xml:space="preserve">
          <source>The setting of subroutine attributes happens at compile time. Variable attributes in &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declarations are also applied at compile time. However, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables get their attributes applied at run-time. This means that you have to</source>
          <target state="translated">サブルーチン属性の設定は、コンパイル時に行われます。変数属性は &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 宣言はまた、コンパイル時に適用されます。ただし、 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 変数は実行時に属性が適用されます。これはあなたがしなければならないことを意味します</target>
        </trans-unit>
        <trans-unit id="ab1edc3ed4db36281da6290a4a02b6bb1d2f2a9a" translate="yes" xml:space="preserve">
          <source>The seven routines are:</source>
          <target state="translated">7つのルーティンがあります。</target>
        </trans-unit>
        <trans-unit id="7db711982141cfb12b9e3602192ccba86ac4d921" translate="yes" xml:space="preserve">
          <source>The sheet</source>
          <target state="translated">シート</target>
        </trans-unit>
        <trans-unit id="67100f7fba2fe91ac3115331e86988966a0f9ad9" translate="yes" xml:space="preserve">
          <source>The shell offers to run in</source>
          <target state="translated">シェルは</target>
        </trans-unit>
        <trans-unit id="d2a4c575dba49342e824220d900f0c783780f4b9" translate="yes" xml:space="preserve">
          <source>The shell's &lt;code&gt;test&lt;/code&gt; uses &quot;=&quot;, &quot;!=&quot;, &quot;&amp;lt;&quot; etc for string comparisons and &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot; etc for numeric comparisons. This is the reverse of Perl, which uses &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; for string comparisons, and &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; etc for numeric comparisons.</source>
          <target state="translated">シェルの &lt;code&gt;test&lt;/code&gt; は、文字列比較に「=」、「！=」、「&amp;lt;」などを使用し、数値比較に「-eq」、「-ne」、「-lt」などを使用します。これはPerlの逆であり、文字列比較には &lt;code&gt;eq&lt;/code&gt; 、 &lt;code&gt;ne&lt;/code&gt; 、 &lt;code&gt;lt&lt;/code&gt; を使用し、数値比較には &lt;code&gt;==&lt;/code&gt; 、 &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; などを使用します。</target>
        </trans-unit>
        <trans-unit id="fe36cec28443e99377776c6efc56682531e56f06" translate="yes" xml:space="preserve">
          <source>The short answer is that by default Perl compares equivalence (&lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; ) based only on code points of the characters. In the above case, the answer is no (because 0x00C1 != 0x0041). But sometimes, any CAPITAL LETTER A's should be considered equal, or even A's of any case.</source>
          <target state="translated">短い答えは、デフォルトではPerl は文字のコードポイントのみに基づいて等価（ &lt;code&gt;eq&lt;/code&gt; 、 &lt;code&gt;ne&lt;/code&gt; ）を比較するということです。上記の場合、答えはノーです（0x00C1！= 0x0041のため）。しかし、時々、大文字のAは等しいと見なされるべきです。</target>
        </trans-unit>
        <trans-unit id="b57501930c25501b20f82b569d1ea16761a497e6" translate="yes" xml:space="preserve">
          <source>The short answer is that by default, Perl compares strings (&lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; ) based only on the code points of the characters. In the above case, the answer is &quot;after&quot;, since &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; .</source>
          <target state="translated">短い答えは、デフォルトでは、Perl は文字のコードポイントのみに基づいて文字列（ &lt;code&gt;lt&lt;/code&gt; 、 &lt;code&gt;le&lt;/code&gt; 、 &lt;code&gt;cmp&lt;/code&gt; 、 &lt;code&gt;ge&lt;/code&gt; 、 &lt;code&gt;gt&lt;/code&gt; ）を比較するということです。上記の場合、 &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; なので、答えは「後」です。</target>
        </trans-unit>
        <trans-unit id="ace0e0cec639bb708cb2cf532e982971dd3748da" translate="yes" xml:space="preserve">
          <source>The short name of the general category of</source>
          <target state="translated">の一般的なカテゴリーの略称です。</target>
        </trans-unit>
        <trans-unit id="02c6ec10d109a1b719286e329258adf56d502cef" translate="yes" xml:space="preserve">
          <source>The short story</source>
          <target state="translated">短編小説</target>
        </trans-unit>
        <trans-unit id="eb4d2d85d25fb4d71e2225f2e7a3eb6515112128" translate="yes" xml:space="preserve">
          <source>The short story is that you should probably only use defined on scalars or functions, not on aggregates (arrays and hashes). See &lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; in the 5.004 release or later of Perl for more detail.</source>
          <target state="translated">要するに、おそらくスカラーまたは関数で定義されたもののみを使用し、集計（配列およびハッシュ）では使用しないでください。詳細については、Perlの5.004以降のリリースで&lt;a href=&quot;functions/defined&quot;&gt;定義さ&lt;/a&gt;れているを参照してください。</target>
        </trans-unit>
        <trans-unit id="be047f864fccecb4801e21c3ca26d33faa969dbf" translate="yes" xml:space="preserve">
          <source>The sign &lt;code&gt;/^[+-]$/&lt;/code&gt; is stored separately. The string 'NaN' is used to represent the result when input arguments are not numbers, as well as the result of dividing by zero.</source>
          <target state="translated">記号 &lt;code&gt;/^[+-]$/&lt;/code&gt; は個別に保存されます。文字列 'NaN'は、入力引数が数値ではない場合の結果と、ゼロで除算した結果を表すために使用されます。</target>
        </trans-unit>
        <trans-unit id="5d535efa9748a7b51984807c3b0e47062fc14e19" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf' and stored separately. You can access it with the sign() method.</source>
          <target state="translated">符号は '+'、'-'、'NaN'、'+inf'、'-inf' のいずれかで、別々に格納されます。sign()メソッドでアクセスできます。</target>
        </trans-unit>
        <trans-unit id="be8bba598ba0bfbad37b038eb92c99bbb5b687ac" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'.</source>
          <target state="translated">符号は、'+'、'-'、'NaN'、'+inf'または'-inf'のいずれかである。</target>
        </trans-unit>
        <trans-unit id="32ee9fc8e75a1189426734a34b70183ae0bf5e08" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'. You can access it with the sign() method.</source>
          <target state="translated">符号は '+'、'-'、'NaN'、'+inf' または '-inf' のいずれかです。sign()メソッドでアクセスできます。</target>
        </trans-unit>
        <trans-unit id="d68142e064ec1d6e704c7c13d44f8b02e77345ce" translate="yes" xml:space="preserve">
          <source>The signature is part of a subroutine's body. Normally the body of a subroutine is simply a braced block of code. When using a signature, the signature is a parenthesised list that goes immediately after the subroutine name. The signature declares lexical variables that are in scope for the block. When the subroutine is called, the signature takes control first. It populates the signature variables from the list of arguments that were passed. If the argument list doesn't meet the requirements of the signature, then it will throw an exception. When the signature processing is complete, control passes to the block.</source>
          <target state="translated">シグネチャはサブルーチンのボディの一部です。通常、サブルーチンの本文は単に中括弧で囲まれたコードブロックです。シグネチャを使用する場合、シグネチャはサブルーチン名の直後に括弧で囲まれたリストになります。シグネチャはブロックのスコープ内にある語彙変数を宣言します。サブルーチンが呼び出されると、シグネチャが最初に制御を行います。それは渡された引数のリストからシグネチャ変数を生成します。引数リストがシグネチャの要件を満たさない場合は、例外をスローします。シグネチャの処理が完了すると、制御はブロックに渡されます。</target>
        </trans-unit>
        <trans-unit id="2444d6c2a6baf7e1580c4abcb9b61735a0532f35" translate="yes" xml:space="preserve">
          <source>The significance of each of these will be explained in the rest of the tutorial, but for now, it is important only to know that a metacharacter can be matched by putting a backslash before it:</source>
          <target state="translated">それぞれの意味はチュートリアルの残りの部分で説明しますが、今のところ、メタ文字の前にバックスラッシュを付けることでメタ文字を一致させることができるということだけは知っておくことが重要です。</target>
        </trans-unit>
        <trans-unit id="d05188639d7fd13d368b039de9eab91f22380450" translate="yes" xml:space="preserve">
          <source>The similarly named property, &lt;code&gt;\p{Punct}&lt;/code&gt; , matches a somewhat different set in the ASCII range, namely &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; . That is, it is missing the nine characters &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; . This is because Unicode splits what POSIX considers to be punctuation into two categories, Punctuation and Symbols.</source>
          <target state="translated">同様に名前が付けられたプロパティ &lt;code&gt;\p{Punct}&lt;/code&gt; は、ASCII範囲のやや異なるセット、つまり &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; に一致します。つまり、9文字 &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; が欠落しているのは、POSIXが句読点と見なすものをUnicodeが2つのカテゴリ、句読点と記号に分割しているためです。</target>
        </trans-unit>
        <trans-unit id="a851643ae5a58ccc6f3ce68bfdab3a7ef68d1794" translate="yes" xml:space="preserve">
          <source>The simple rule is: Inheritance will not work when autoloading non-methods. The simple fix for old code is: In any module that used to depend on inheriting &lt;code&gt;AUTOLOAD&lt;/code&gt; for non-methods from a base class named &lt;code&gt;BaseClass&lt;/code&gt; , execute &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; during startup.</source>
          <target state="translated">単純なルールは次のとおりです。メソッド以外をオートロードする場合、継承は機能しません。古いコードの簡単な修正は次のとおりです &lt;code&gt;BaseClass&lt;/code&gt; という名前の基本クラスからの非メソッドの &lt;code&gt;AUTOLOAD&lt;/code&gt; の継承に依存していたモジュールでは、起動時に &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; 実行します。</target>
        </trans-unit>
        <trans-unit id="41d909120b343bfa9af89dc978321448d395292c" translate="yes" xml:space="preserve">
          <source>The simple stdio implementation creates the files</source>
          <target state="translated">シンプルなstdioの実装では</target>
        </trans-unit>
        <trans-unit id="f2a9e9b7a3c97685eea0b1595b9417bb605f6809" translate="yes" xml:space="preserve">
          <source>The simplest XSUBs consist of 3 parts: a description of the return value, the name of the XSUB routine and the names of its arguments, and a description of types or formats of the arguments.</source>
          <target state="translated">最も単純なXSUBは3つの部分から構成されています:戻り値の説明、XSUBルーチンの名前とその引数の名前、引数の型や形式の説明です。</target>
        </trans-unit>
        <trans-unit id="5cfe5e43e01ddc5838feef9195e0126bb74ada96" translate="yes" xml:space="preserve">
          <source>The simplest case is integers. These consist of a sequence of digits, with an optional sign in front. The digits we can represent with &lt;code&gt;\d+&lt;/code&gt; and the sign can be matched with &lt;code&gt;[+-]&lt;/code&gt; . Thus the integer regexp is</source>
          <target state="translated">最も単純なケースは整数です。これらは一連の数字で構成され、前にオプションの記号が付いています。 &lt;code&gt;\d+&lt;/code&gt; 表すことができる数字と符号は &lt;code&gt;[+-]&lt;/code&gt; と一致させることができます。したがって、整数正規表現は</target>
        </trans-unit>
        <trans-unit id="90f647a57152f0376dead3744742f9e10945d73a" translate="yes" xml:space="preserve">
          <source>The simplest method uses the &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. It can pad on the left or right with blanks and on the left with zeroes and it will not truncate the result. The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function can only pad strings on the right with blanks and it will truncate the result to a maximum length of &lt;code&gt;$pad_len&lt;/code&gt; .</source>
          <target state="translated">最も簡単な方法は、 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 関数を使用することです。左側または右側をブランクで埋め、左側をゼロで埋めることができ、結果を切り捨てません。 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 機能は、パッドの右側にブランクが文字列と、それは、最大長に結果が切り捨てられますすることができます &lt;code&gt;$pad_len&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc3e208a9819c2ed872df1040ec4eed39730cc50" translate="yes" xml:space="preserve">
          <source>The simplest regex is simply a word, or more generally, a string of characters. A regex consisting of a word matches any string that contains that word:</source>
          <target state="translated">最も単純な正規表現は、単に単語、またはより一般的には文字列です。単語からなる正規表現は、その単語を含む文字列にマッチします。</target>
        </trans-unit>
        <trans-unit id="e7349953e0f225a36578668e9ad5be25a2093d5b" translate="yes" xml:space="preserve">
          <source>The simplest regexp is simply a word, or more generally, a string of characters. A regexp consisting of a word matches any string that contains that word:</source>
          <target state="translated">最も単純な正規表現は、単に単語、あるいはより一般的には文字列です。単語からなる正規表現は、その単語を含む文字列にマッチします。</target>
        </trans-unit>
        <trans-unit id="f93ecdae42936826d9c1b25b5229a95d439104b0" translate="yes" xml:space="preserve">
          <source>The simplest style of bundling can be enabled with:</source>
          <target state="translated">最もシンプルなスタイルのバンドルを有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="7cd479644d912e323fa369ec3403c930944ff04b" translate="yes" xml:space="preserve">
          <source>The simplest two-level data structure to build in Perl is an array of arrays, sometimes casually called a list of lists. It's reasonably easy to understand, and almost everything that applies here will also be applicable later on with the fancier data structures.</source>
          <target state="translated">Perlで構築する最も単純な2レベルのデータ構造は、配列の配列であり、時にはリストのリストと呼ばれることもあります。理解するのは比較的簡単で、ここで適用されるほとんどすべてのことは、後になってより高度なデータ構造にも適用されるようになります。</target>
        </trans-unit>
        <trans-unit id="6e9b91e3cec9f10bb3ce35088b75f0be6c8e9b0d" translate="yes" xml:space="preserve">
          <source>The simplest type of op structure is &lt;code&gt;OP&lt;/code&gt; : this has no children. Unary operators, &lt;code&gt;UNOP&lt;/code&gt; s, have one child, and this is pointed to by the &lt;code&gt;op_first&lt;/code&gt; field. Binary operators (&lt;code&gt;BINOP&lt;/code&gt; s) have not only an &lt;code&gt;op_first&lt;/code&gt; field but also an &lt;code&gt;op_last&lt;/code&gt; field. The most complex type of op is a &lt;code&gt;LISTOP&lt;/code&gt; , which has any number of children. In this case, the first child is pointed to by &lt;code&gt;op_first&lt;/code&gt; and the last child by &lt;code&gt;op_last&lt;/code&gt; . The children in between can be found by iteratively following the &lt;code&gt;OpSIBLING&lt;/code&gt; pointer from the first child to the last (but see below).</source>
          <target state="translated">op構造の最も単純なタイプは &lt;code&gt;OP&lt;/code&gt; です。これには子がありません。単項演算子 &lt;code&gt;UNOP&lt;/code&gt; には子が1つあり、これは &lt;code&gt;op_first&lt;/code&gt; フィールドによってポイントされます。バイナリ演算子（ &lt;code&gt;BINOP&lt;/code&gt; S）だけでなく、持っている &lt;code&gt;op_first&lt;/code&gt; フィールドだけでなく、 &lt;code&gt;op_last&lt;/code&gt; フィールドを。 opの最も複雑なタイプは &lt;code&gt;LISTOP&lt;/code&gt; であり、子をいくつでも持つことができます。この場合、最初の子は &lt;code&gt;op_first&lt;/code&gt; によってポイントされ、最後の子は &lt;code&gt;op_last&lt;/code&gt; によってポイントされます。中間の子は、最初の子から最後の子まで &lt;code&gt;OpSIBLING&lt;/code&gt; ポインタを繰り返したどることによって見つけることができます（ただし、以下を参照）。</target>
        </trans-unit>
        <trans-unit id="2054b09e7b3505e051c925e118baa9402ac5d4ec" translate="yes" xml:space="preserve">
          <source>The simplest way to do this is:</source>
          <target state="translated">一番簡単な方法は</target>
        </trans-unit>
        <trans-unit id="388dab005124e81f16d269b4ee944aa3b8003908" translate="yes" xml:space="preserve">
          <source>The simplest way to use this library is to import the md5_hex() function (or one of its cousins):</source>
          <target state="translated">このライブラリを使用する最も単純な方法は、md5_hex()関数 (またはそのいとこ)をインポートすることです。</target>
        </trans-unit>
        <trans-unit id="5ecd63cfa076538859f9d50a754ce0ea42b734ec" translate="yes" xml:space="preserve">
          <source>The simplest, most straightforward way to create a thread is with &lt;code&gt;create()&lt;/code&gt; :</source>
          <target state="translated">スレッドを作成する最も簡単で最も簡単な方法は、 &lt;code&gt;create()&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="142891f6dfc36054413e16ddc5cd0b102274ac48" translate="yes" xml:space="preserve">
          <source>The single parameter &lt;code&gt;cb1&lt;/code&gt; is a pointer to a function, so you must have defined &lt;code&gt;cb1&lt;/code&gt; in your code, say something like this</source>
          <target state="translated">単一のパラメーター &lt;code&gt;cb1&lt;/code&gt; は関数へのポインターであるため、コードで &lt;code&gt;cb1&lt;/code&gt; を定義している必要があります。</target>
        </trans-unit>
        <trans-unit id="c390613e0b451f9ebc65ddd44ea3f2cbf88c23f5" translate="yes" xml:space="preserve">
          <source>The situation in which an &lt;b&gt;expression&lt;/b&gt; is expected by its surroundings (the code calling it) to return a list of values rather than a single value. Functions that want a</source>
          <target state="translated">&lt;b&gt;式&lt;/b&gt;がその周囲（それを呼び出すコード）によって単一の値ではなく値のリストを返すことが期待される状況。を必要とする関数</target>
        </trans-unit>
        <trans-unit id="d86701b02acab027c0d49bd429316b14b358d71d" translate="yes" xml:space="preserve">
          <source>The situation in which an &lt;b&gt;expression&lt;/b&gt; is expected by its surroundings (the code calling it) to return a single &lt;b&gt;value&lt;/b&gt; rather than a &lt;b&gt;list&lt;/b&gt; of values. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;list context&lt;/b&gt;. A scalar context sometimes imposes additional constraints on the return value&amp;mdash;see &lt;b&gt;string context&lt;/b&gt; and &lt;b&gt;numeric context&lt;/b&gt;. Sometimes we talk about a &lt;b&gt;Boolean context&lt;/b&gt; inside conditionals, but this imposes no additional constraints, since any scalar value, whether numeric or &lt;b&gt;string&lt;/b&gt;, is already true or false.</source>
          <target state="translated">&lt;b&gt;式&lt;/b&gt;がその周囲（それを呼び出すコード）によって、値の&lt;b&gt;リスト&lt;/b&gt;ではなく単一の&lt;b&gt;値&lt;/b&gt;を返すことが期待される状況。&lt;b&gt;context&lt;/b&gt;および&lt;b&gt;list context&lt;/b&gt;も参照してください。スカラーコンテキストは、戻り値に追加の制約を課すことがあり&lt;b&gt;ます&lt;/b&gt;。&lt;b&gt;文字列コンテキスト&lt;/b&gt;と&lt;b&gt;数値コンテキストを&lt;/b&gt;参照してください。時々、条件&lt;b&gt;文内のブールコンテキスト&lt;/b&gt;について話しますが、数値または&lt;b&gt;文字列&lt;/b&gt;に関係なく、スカラー値はすでにtrueまたはfalse であるため、これは追加の制約を課しません。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5bf519df1d56695e3fe7b5f2cac71014a6a10291" translate="yes" xml:space="preserve">
          <source>The situation in which an expression is expected by its surroundings (the code calling it) to return a &lt;b&gt;string&lt;/b&gt;. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;numeric context&lt;/b&gt;.</source>
          <target state="translated">式がその周囲（それを呼び出すコード）によって&lt;b&gt;string&lt;/b&gt;を返すことが期待される状況。&lt;b&gt;context&lt;/b&gt;と&lt;b&gt;numeric context&lt;/b&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="d5278b812a3307d0ee6951ce2678ae1eab81add9" translate="yes" xml:space="preserve">
          <source>The situation in which an expression is expected by its surroundings (the code calling it) to return a number. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;string context&lt;/b&gt;.</source>
          <target state="translated">式がその周囲（それを呼び出すコード）によって数値を返すことが期待される状況。&lt;b&gt;context&lt;/b&gt;および&lt;b&gt;string context&lt;/b&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="1778a01cc57bbb1bfba8f72e778c79445c3a36bf" translate="yes" xml:space="preserve">
          <source>The situation is even less clear for tools such as MakeMaker that can be used to install additional modules into non-standard places. For example, if a user intends to install a module into a private directory (perhaps by setting &lt;code&gt;PREFIX&lt;/code&gt; on the</source>
          <target state="translated">追加のモジュールを非標準の場所にインストールするために使用できるMakeMakerなどのツールについては、状況はさらに不明確です。たとえば、ユーザーがモジュールをプライベートディレクトリにインストールする場合（おそらく、 &lt;code&gt;PREFIX&lt;/code&gt; を</target>
        </trans-unit>
        <trans-unit id="9a9c38132104cf7801e22419b38670f4a24614fb" translate="yes" xml:space="preserve">
          <source>The situation where this is necessary, is presumably quite rare.</source>
          <target state="translated">これが必要とされる状況は、推定的にはかなり稀です。</target>
        </trans-unit>
        <trans-unit id="5a9a5af0a6298739507c5ced21852b79711a0a57" translate="yes" xml:space="preserve">
          <source>The situation with matching Unicode properties in regular expressions, the &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs, against these code points is not as clear cut, and how these are handled has changed as we've gained experience.</source>
          <target state="translated">これらのコードポイントに対する正規表現の &lt;code&gt;\p{}&lt;/code&gt; および &lt;code&gt;\P{}&lt;/code&gt; 構成体でのUnicodeプロパティの一致の状況はそれほど明確ではなく、これらがどのように処理されるかは、経験を積むにつれて変化しました。</target>
        </trans-unit>
        <trans-unit id="88e6088a9ab77ba2f6a1ec54ad364f7fffa87f43" translate="yes" xml:space="preserve">
          <source>The size of the file will be determined, and sent to the server automatically for normal files so that this method need only be called if you are transferring data from a socket, named pipe, or other stream not associated with a normal file.</source>
          <target state="translated">このメソッドは、通常のファイルに関連付けられていないソケット、名前付きパイプ、またはその他のストリームからデータを転送する場合にのみ呼び出される必要があるように、ファイルのサイズが決定され、通常のファイルの場合には自動的にサーバに送信されます。</target>
        </trans-unit>
        <trans-unit id="87d9309a72cdac9a52fd9593050f47fe997d18b5" translate="yes" xml:space="preserve">
          <source>The size of the per-instance data structure, e.g.:</source>
          <target state="translated">インスタンス単位のデータ構造のサイズ、例えば</target>
        </trans-unit>
        <trans-unit id="5877446a070972ed92cd79aed206f27b2111d714" translate="yes" xml:space="preserve">
          <source>The size of the pieces you&amp;rsquo;re dealing with, mentally speaking.</source>
          <target state="translated">精神的に言えば、あなたが扱っているピースのサイズ。</target>
        </trans-unit>
        <trans-unit id="1656b4f2fdda6835a902c9679ea0caaf9c6c13e1" translate="yes" xml:space="preserve">
          <source>The size specifier &lt;code&gt;V&lt;/code&gt; has no effect for Perl code, but is supported for compatibility with XS code. It means &quot;use the standard size for a Perl integer or floating-point number&quot;, which is the default.</source>
          <target state="translated">サイズ指定子 &lt;code&gt;V&lt;/code&gt; はPerlコードには影響しませんが、XSコードとの互換性のためにサポートされています。これは、デフォルトの「Perl整数または浮動小数点数の標準サイズを使用する」ことを意味します。</target>
        </trans-unit>
        <trans-unit id="0b86c8f6fcdbd6b3e5e7fca2359cdc4a25ce8c43" translate="yes" xml:space="preserve">
          <source>The skipped prefix (i.e. the characters before the extracted string). On failure, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">スキップされた接頭辞（つまり、抽出された文字列の前の文字）。失敗すると、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="cca8448b9d4d7f08ec6d38447f60e1a5ccb09b43" translate="yes" xml:space="preserve">
          <source>The slower but superior fixes are when you may be able to yourself fix the misconfiguration of your own environment variables. The mis(sing)configuration of the whole system's locales usually requires the help of your friendly system administrator.</source>
          <target state="translated">遅いが優れた修正は、あなた自身があなた自身の環境変数の誤設定を修正することができるかもしれないときです。システム全体のロケールの誤設定は、通常、親しみやすいシステム管理者の助けを必要とします。</target>
        </trans-unit>
        <trans-unit id="0fbe962e06d42462e7c0e18bd04f3db25354c94a" translate="yes" xml:space="preserve">
          <source>The smaller and more localized the change, the better. Similarly, a series of small patches is greatly preferred over a single large patch.</source>
          <target state="translated">変化はより小さく、より局所的であればあるほどよい。同様に、単一の大きなパッチよりも、一連の小さなパッチの方が非常に好まれます。</target>
        </trans-unit>
        <trans-unit id="f4b9fc3a5444ff6c99460c86f0eae40188849994" translate="yes" xml:space="preserve">
          <source>The smallest individual element of a string. Computers store characters as integers, but Perl lets you operate on them as text. The integer used to represent a particular character is called that character&amp;rsquo;s &lt;b&gt;codepoint&lt;/b&gt;.</source>
          <target state="translated">文字列の最小の個々の要素。コンピューターは文字を整数として格納しますが、Perlではそれらをテキストとして操作できます。特定の文字を表すために使用される整数は、その文字の&lt;b&gt;コードポイント&lt;/b&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="743692cb1b17807cb7e732ecae2c349fdebd6008" translate="yes" xml:space="preserve">
          <source>The smart match stops when it finds a match, so it doesn't have to try every expression.</source>
          <target state="translated">スマートマッチは一致するものが見つかった時点で停止するので、すべての式を試す必要はありません。</target>
        </trans-unit>
        <trans-unit id="936144db8d649469afd4d348dac4550c6a90cbd0" translate="yes" xml:space="preserve">
          <source>The smartmatch implicitly dereferences any non-blessed hash or array reference, so the &lt;code&gt;&lt;i&gt;HASH&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;&lt;i&gt;ARRAY&lt;/i&gt;&lt;/code&gt; entries apply in those cases. For blessed references, the &lt;code&gt;&lt;i&gt;Object&lt;/i&gt;&lt;/code&gt; entries apply. Smartmatches involving hashes only consider hash keys, never hash values.</source>
          <target state="translated">スマートマッチは、blessされていないハッシュまたは配列参照を暗黙的に逆参照するため、 &lt;code&gt;&lt;i&gt;HASH&lt;/i&gt;&lt;/code&gt; および &lt;code&gt;&lt;i&gt;ARRAY&lt;/i&gt;&lt;/code&gt; エントリはそれらの場合に適用されます。祝福された参照には、 &lt;code&gt;&lt;i&gt;Object&lt;/i&gt;&lt;/code&gt; エントリが適用されます。ハッシュを含むスマートマッチはハッシュキーのみを考慮し、ハッシュ値は考慮しません。</target>
        </trans-unit>
        <trans-unit id="d02f6728ba4dcd43d024dc500f10ccfe28692eeb" translate="yes" xml:space="preserve">
          <source>The smartmatch operator is most often used as the implicit operator of a &lt;code&gt;when&lt;/code&gt; clause. See the section on &quot;Switch Statements&quot; in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;.</source>
          <target state="translated">smartmatch演算子は、 &lt;code&gt;when&lt;/code&gt; 句の暗黙的な演算子として最もよく使用されます。&lt;a href=&quot;perlsyn&quot;&gt;perlsynの&lt;/a&gt;「Switchステートメント」のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="538eac64870e76a04cefadec7560ac9099d4a644" translate="yes" xml:space="preserve">
          <source>The socket tests may fail if the network is not configured. You have to make &quot;/hurd/pfinet&quot; the translator for &quot;/servers/socket/2&quot;, giving it the right arguments. Try &quot;/hurd/pfinet --help&quot; for more information.</source>
          <target state="translated">ネットワークが設定されていない場合、ソケットテストは失敗する可能性があります。hurd/pfinet &quot;を&quot;/servers/socket/2 &quot;のトランスレータにして、正しい引数を与えなければなりません。詳細は&quot;/hurd/pfinet --help &quot;を試してみてください。</target>
        </trans-unit>
        <trans-unit id="127dbba60bbfba8c121a95d45a5b1267637cec67" translate="yes" xml:space="preserve">
          <source>The socket type (e.g. &lt;code&gt;SOCK_STREAM&lt;/code&gt; )</source>
          <target state="translated">ソケットタイプ（例： &lt;code&gt;SOCK_STREAM&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="d10c516fba6283faccc420f0f1f0ddca597fd882" translate="yes" xml:space="preserve">
          <source>The sole purpose of this module is to enable colour highlighting from the command line.</source>
          <target state="translated">このモジュールの唯一の目的は、コマンドラインからカラーハイライトを有効にすることです。</target>
        </trans-unit>
        <trans-unit id="165006648b6cdcfa730ff63bd97b9430605a3ca6" translate="yes" xml:space="preserve">
          <source>The solution is to &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; out of the child directory to a place outside the directory tree to be removed.</source>
          <target state="translated">解決策は、子ディレクトリから、削除するディレクトリツリーの外の場所に &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; することです。</target>
        </trans-unit>
        <trans-unit id="8bd1e61d4eb0bbe0f75b3581782eef3e8dfaf4b4" translate="yes" xml:space="preserve">
          <source>The sort of characters we put into words. In Unicode, this is all letters including all ideographs and certain diacritics, letter numbers like Roman numerals, and various combining marks.</source>
          <target state="translated">私たちが言葉に入れる文字の種類。Unicodeでは、すべての表意文字や特定の記号、ローマ数字のような文字番号、さまざまな組み合わせ記号を含むすべての文字を指します。</target>
        </trans-unit>
        <trans-unit id="a1d44ffc9ae032aff54b02af9e8455f31b34d012" translate="yes" xml:space="preserve">
          <source>The sort order will cause differences between results obtained on ASCII platforms versus EBCDIC platforms. What follows are some suggestions on how to deal with these differences.</source>
          <target state="translated">ソート順によって、ASCIIプラットフォームとEBCDICプラットフォームで得られた結果に違いが生じます。以下に、これらの違いに対処するためのいくつかの提案を示します。</target>
        </trans-unit>
        <trans-unit id="89da5c4101906ac148b9121db995bfdaa11ef39f" translate="yes" xml:space="preserve">
          <source>The source buffer can either be a scalar or a scalar reference.</source>
          <target state="translated">ソースバッファはスカラかスカラ参照のどちらかになります。</target>
        </trans-unit>
        <trans-unit id="67687b08f8914b53b7f3846fac38e3b4363d7a5e" translate="yes" xml:space="preserve">
          <source>The source buffer, &lt;code&gt;$source&lt;/code&gt; , can either be a scalar or a scalar reference.</source>
          <target state="translated">ソースバッファー &lt;code&gt;$source&lt;/code&gt; は、スカラーまたはスカラー参照のいずれかです。</target>
        </trans-unit>
        <trans-unit id="1b7e9fa2ae5c5f428ffd5cfef77286b08b69792f" translate="yes" xml:space="preserve">
          <source>The source code for an extension usually resides in its own directory. At least three files are generally provided:</source>
          <target state="translated">通常、拡張機能のソースコードはそれ自身のディレクトリにあります。少なくとも3つのファイルが用意されているのが一般的です。</target>
        </trans-unit>
        <trans-unit id="1e4ee98da0c8794c248be818bce3b87507488dbe" translate="yes" xml:space="preserve">
          <source>The source code includes multiple hash algorithms to choose from. While we believe that the default perl hash is robust to attack, we have included the hash function Siphash as a fall-back option. At the time of release of Perl 5.18.0 Siphash is believed to be of cryptographic strength. This is not the default as it is much slower than the default hash.</source>
          <target state="translated">ソースコードには複数のハッシュアルゴリズムが含まれています。Perl のデフォルトのハッシュは攻撃に強いと信じていますが、フォールバックオプションとして Siphash というハッシュ関数が含まれています。Perl 5.18.0のリリース時点では、Siphashは暗号化の強度があると考えられています。デフォルトのハッシュよりもはるかに遅いので、これはデフォルトではありません。</target>
        </trans-unit>
        <trans-unit id="d0caf29be420bbd199849ea512093a83580509aa" translate="yes" xml:space="preserve">
          <source>The source code locations are supported &lt;b&gt;only&lt;/b&gt; if you have the Developer Tools installed. (BFD is &lt;b&gt;not&lt;/b&gt; needed.)</source>
          <target state="translated">ソースコードの場所は、開発者ツールがインストールされている場合に&lt;b&gt;のみ&lt;/b&gt;サポートされます。（BFDは必要あり&lt;b&gt;ません&lt;/b&gt;。）</target>
        </trans-unit>
        <trans-unit id="edb2a3de91b362ca2b61febe5041a5a32501556d" translate="yes" xml:space="preserve">
          <source>The source code repository for Test::More can be found at</source>
          <target state="translated">Test::More のソースコードリポジトリは以下にあります。</target>
        </trans-unit>
        <trans-unit id="449ffcdb319b9addd8fd6dc6fc9226340b95b72f" translate="yes" xml:space="preserve">
          <source>The source filter distribution includes two modules that simplify this task: &lt;code&gt;Filter::exec&lt;/code&gt; and &lt;code&gt;Filter::sh&lt;/code&gt; . Both allow you to run any external executable. Both use a coprocess to control the flow of data into and out of the external executable. (For details on coprocesses, see Stephens, W.R., &quot;Advanced Programming in the UNIX Environment.&quot; Addison-Wesley, ISBN 0-210-56317-7, pages 441-445.) The difference between them is that &lt;code&gt;Filter::exec&lt;/code&gt; spawns the external command directly, while &lt;code&gt;Filter::sh&lt;/code&gt; spawns a shell to execute the external command. (Unix uses the Bourne shell; NT uses the cmd shell.) Spawning a shell allows you to make use of the shell metacharacters and redirection facilities.</source>
          <target state="translated">ソースフィルターの配布には、このタスクを簡略化する2つのモジュール &lt;code&gt;Filter::exec&lt;/code&gt; および &lt;code&gt;Filter::sh&lt;/code&gt; ます。どちらでも、外部の実行可能ファイルを実行できます。どちらもコプロセスを使用して、外部実行可能ファイルへのデータの流れと外部実行可能ファイルからのデータの流れを制御します。 （コプロセスの詳細については、Stephens、WR、「UNIX環境での高度なプログラミング」を参照してください。Addison-Wesley、ISBN 0-210-56317-7、441-445ページ。）これらの違いは、 &lt;code&gt;Filter::exec&lt;/code&gt; が生成することです。 &lt;code&gt;Filter::sh&lt;/code&gt; が外部コマンドを直接実行する一方で、Filter :: shはシェルを生成して外部コマンドを実行します。 （UnixはBourneシェルを使用し、NTはcmdシェルを使用します。）シェルを生成すると、シェルのメタキャラクターとリダイレクト機能を利用できます。</target>
        </trans-unit>
        <trans-unit id="ea0efb50a1d96794619b6be6780ccfe01a3a3f70" translate="yes" xml:space="preserve">
          <source>The source has to be set before you can parse anything. The lowest-level way is to call &lt;code&gt;set_source&lt;/code&gt; :</source>
          <target state="translated">何かを解析する前に、ソースを設定する必要があります。最低レベルの方法は &lt;code&gt;set_source&lt;/code&gt; を呼び出すことです：</target>
        </trans-unit>
        <trans-unit id="30a7a830852a264986b70187999506a317874b7f" translate="yes" xml:space="preserve">
          <source>The source of ISO 3166-1 two-letter codes used by this module.</source>
          <target state="translated">このモジュールで使用されるISO 3166-1の2文字コードのソース。</target>
        </trans-unit>
        <trans-unit id="26888526042c45b79818c80cb5da539324a9402b" translate="yes" xml:space="preserve">
          <source>The source of the official ISO 3166-1 three-letter codes and three-digit codes.</source>
          <target state="translated">公式のISO3166-1の3文字コードと3桁コードのソースです。</target>
        </trans-unit>
        <trans-unit id="454a907e32531c807293e3735238b43baf267920" translate="yes" xml:space="preserve">
          <source>The special argument of &lt;code&gt;h h&lt;/code&gt; produces the entire help page, which is quite long.</source>
          <target state="translated">&lt;code&gt;h h&lt;/code&gt; の特別な引数は、かなり長いヘルプページ全体を生成します。</target>
        </trans-unit>
        <trans-unit id="c6f65c11625ca6f6efd4fce69ae54247f9d5fb65" translate="yes" xml:space="preserve">
          <source>The special bookkeeping Perl does to track the flow of external data through your program and disallow their use in system commands.</source>
          <target state="translated">Perl が行う特別なブックキーピングは、プログラムを介した外部データの流れを追跡し、システムコマンドでの使用を禁止するためのものです。</target>
        </trans-unit>
        <trans-unit id="fbeef28b2f2c3763e9cdd6d44783f63733b4347f" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that a contiguous set of characters can be written as a range. With ranges, the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt; . Some examples are</source>
          <target state="translated">特殊文字 &lt;code&gt;'-'&lt;/code&gt; は文字クラス内の範囲演算子として機能するため、連続した文字のセットを範囲として書き込むことができます。範囲を指定すると、扱いにくい &lt;code&gt;[0123456789]&lt;/code&gt; と &lt;code&gt;[abc...xyz]&lt;/code&gt; が厳密な &lt;code&gt;[0-9]&lt;/code&gt; と &lt;code&gt;[a-z]&lt;/code&gt; ます。いくつかの例は</target>
        </trans-unit>
        <trans-unit id="3a71b165b4e188832e186d5361505b47059b1afc" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt; :</source>
          <target state="translated">特殊文字 &lt;code&gt;'-'&lt;/code&gt; は文字クラス内で範囲演算子として機能するため、扱いにくい &lt;code&gt;[0123456789]&lt;/code&gt; と &lt;code&gt;[abc...xyz]&lt;/code&gt; は厳密な &lt;code&gt;[0-9]&lt;/code&gt; と &lt;code&gt;[a-z]&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="c1d9d9306fb9aa515c3bd892587a0587d3baf9f6" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;^&lt;/code&gt; in the first position of a character class denotes a</source>
          <target state="translated">文字クラスの最初の位置にある特殊文字 &lt;code&gt;^&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="8afc59f37c7b54c4d8a636841474cf58beb13e84" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;^&lt;/code&gt; in the first position of a character class denotes a &lt;b&gt;negated character class&lt;/b&gt;, which matches any character but those in the brackets. Both &lt;code&gt;[...]&lt;/code&gt; and &lt;code&gt;[^...]&lt;/code&gt; must match a character, or the match fails. Then</source>
          <target state="translated">文字クラスの最初の位置にある特殊文字 &lt;code&gt;^&lt;/code&gt; は、&lt;b&gt;否定され&lt;/b&gt;た文字クラスを示します。これは、括弧内の文字以外のすべての文字と一致します。 &lt;code&gt;[...]&lt;/code&gt; と &lt;code&gt;[^...]&lt;/code&gt; 両方が文字と一致する必要があります。一致しない場合、一致は失敗します。その後</target>
        </trans-unit>
        <trans-unit id="94d7fdb99f703e5dc3a7ffcb7bb005616b504881" translate="yes" xml:space="preserve">
          <source>The special filehandle that iterates over command-line filenames in &lt;code&gt;@ARGV&lt;/code&gt; . Usually written as the null filehandle in the angle operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . Note that currently &lt;code&gt;ARGV&lt;/code&gt; only has its magical effect within the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator; elsewhere it is just a plain filehandle corresponding to the last file opened by &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . In particular, passing &lt;code&gt;\*ARGV&lt;/code&gt; as a parameter to a function that expects a filehandle may not cause your function to automatically read the contents of all the files in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;@ARGV&lt;/code&gt; のコマンドラインファイル名を反復処理する特別なファイルハンドル。通常、角度演算子 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; の nullファイルハンドルとして書き込まれます。現在、 &lt;code&gt;ARGV&lt;/code&gt; は &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 演算子内でのみ魔法の効果を持っていることに注意してください。他の場所では、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; によって開かれた最後のファイルに対応する単なるファイルハンドルです。特に、 &lt;code&gt;\*ARGV&lt;/code&gt; をパラメーターとしてファイルハンドルが必要な関数に渡しても、関数が &lt;code&gt;@ARGV&lt;/code&gt; 内のすべてのファイルの内容を自動的に読み取るとは限りません。</target>
        </trans-unit>
        <trans-unit id="f805e5a7fa6e6a7379f92a69ce80440a9d42a7c7" translate="yes" xml:space="preserve">
          <source>The special filehandle that points to the currently open output file when doing edit-in-place processing with &lt;b&gt;-i&lt;/b&gt;. Useful when you have to do a lot of inserting and don't want to keep modifying &lt;code&gt;$_&lt;/code&gt; . See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for the &lt;b&gt;-i&lt;/b&gt; switch.</source>
          <target state="translated">&lt;b&gt;-iを使用&lt;/b&gt;してインプレース編集処理を行うときに現在開いている出力ファイルを指す特別なファイルハンドル。多くの挿入を行う必要があり、 &lt;code&gt;$_&lt;/code&gt; 変更し続けたくない場合に役立ちます。&lt;b&gt;-i&lt;/b&gt;スイッチについては&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;を参照してください。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="25d2e9e8733979d7b1492fbdd9a7cb623d57628f" translate="yes" xml:space="preserve">
          <source>The special literals __FILE__, __LINE__, and __PACKAGE__ represent the current filename, line number, and package name at that point in your program. __SUB__ gives a reference to the current subroutine. They may be used only as separate tokens; they will not be interpolated into strings. If there is no current package (due to an empty &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; directive), __PACKAGE__ is the undefined value. (But the empty &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; is no longer supported, as of version 5.10.) Outside of a subroutine, __SUB__ is the undefined value. __SUB__ is only available in 5.16 or higher, and only with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature &quot;current_sub&quot;&lt;/code&gt; declaration.</source>
          <target state="translated">特別なリテラル__FILE __、__ LINE__、および__PACKAGE__は、プログラムのその時点での現在のファイル名、行番号、およびパッケージ名を表します。 __SUB__は、現在のサブルーチンへの参照を提供します。それらは別個のトークンとしてのみ使用できます。それらは文字列に補間されません。現在のパッケージがない場合（空の &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; ディレクティブにより）、__ PACKAGE__は未定義の値です。 （ただし、空の &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; バージョン5.10以降、サポートされなくなりました。）サブルーチンの外では、__ SUB__は未定義の値です。 __SUB__は、5.16以降でのみ使用でき、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature &quot;current_sub&quot;&lt;/code&gt; 宣言でのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="6af0b63b67806c6dfb7b9ddb2d398096248ddab4" translate="yes" xml:space="preserve">
          <source>The special mark that tells the operating system it can run this program. There are actually three execute bits under Unix, and which bit gets used depends on whether you own the file singularly, collectively, or not at all.</source>
          <target state="translated">このプログラムを実行できることをオペレーティングシステムに伝える特別なマークです。Unix では実際には 3 つの実行ビットがあり、どのビットが使用されるかは、そのファイルを単独で所有しているのか、まとめて所有しているのか、あるいは全く所有していないのかによって異なります。</target>
        </trans-unit>
        <trans-unit id="6429c59caa249ed4d6719a4eab753f28d6cfd25d" translate="yes" xml:space="preserve">
          <source>The special methods &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::can&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;maybe::next::method&lt;/code&gt; are not available until this &lt;code&gt;mro&lt;/code&gt; module has been loaded via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">特別なメソッド &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::can&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;maybe::next::method&lt;/code&gt; は、この &lt;code&gt;mro&lt;/code&gt; モジュールが &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; によってロードされるまで使用できません。</target>
        </trans-unit>
        <trans-unit id="c41f3d15a857df9bc04fff7f6a7434b18442c584" translate="yes" xml:space="preserve">
          <source>The special quoting behavior ignores precedence, and hence may apply to</source>
          <target state="translated">特別な引用の動作は優先順位を無視します。</target>
        </trans-unit>
        <trans-unit id="79a2544429fe460799a8292535fcaefc5e4c6c60" translate="yes" xml:space="preserve">
          <source>The special string &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; is exempt from &lt;b&gt;-w&lt;/b&gt; complaints about improper numeric conversions.</source>
          <target state="translated">特別な文字列 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; は、不適切な数値変換に関する&lt;b&gt;-w&lt;/b&gt;クレームから免除されます。</target>
        </trans-unit>
        <trans-unit id="026f6dfd3d9c99c5a9bfd6afe8ee0f79daedf36d" translate="yes" xml:space="preserve">
          <source>The special symbol &lt;code&gt;__PACKAGE__&lt;/code&gt; contains the current package, but cannot (easily) be used to construct variable names.</source>
          <target state="translated">特別な記号 &lt;code&gt;__PACKAGE__&lt;/code&gt; には現在のパッケージが含まれていますが、変数名の作成には（簡単に）使用できません。</target>
        </trans-unit>
        <trans-unit id="8f36c55aa844c8a0dac4156e30712cffbcd8a9f0" translate="yes" xml:space="preserve">
          <source>The special two-argument form of Perl's open() function ignores trailing blanks in filenames and infers the mode from certain leading characters (or a trailing &quot;|&quot;). In older versions of Perl this was the only version of open() and so it is prevalent in old code and books.</source>
          <target state="translated">Perl の open()関数の特別な 2 引数形式は、ファイル名の末尾の空白を無視し、特定の先頭文字 (または末尾の &quot;|&quot; からモードを推測します)からモードを推測します。古いバージョンの Perl ではこれが唯一の open()のバージョンだったため、古いコードや書籍ではこれが普及しています。</target>
        </trans-unit>
        <trans-unit id="161a5a9075bb6b7595615ee16fc183085e48d829" translate="yes" xml:space="preserve">
          <source>The special value 00 will cause Perl to slurp files in paragraph mode. Any value 0400 or above will cause Perl to slurp files whole, but by convention the value 0777 is the one normally used for this purpose.</source>
          <target state="translated">特別な値 00 は、Perl が段落モードでファイルをスラスパ処理します。0400以上の値を指定すると、Perlはファイル全体をスラスパ処理しますが、慣習上、この目的のために通常使用されるのは値0777です。</target>
        </trans-unit>
        <trans-unit id="510ff7ba673af9c07da4bdf1546cce9f48d4aa9d" translate="yes" xml:space="preserve">
          <source>The special variable &lt;code&gt;$#array&lt;/code&gt; tells you the index of the last element of an array:</source>
          <target state="translated">特殊変数 &lt;code&gt;$#array&lt;/code&gt; は、配列の最後の要素のインデックスを示します。</target>
        </trans-unit>
        <trans-unit id="848d9f1e6794b744b742b40d6e30625dbd74dd9d" translate="yes" xml:space="preserve">
          <source>The special variables for formats are a subset of those for filehandles. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for more information about Perl's formats.</source>
          <target state="translated">フォーマットの特殊変数は、ファイルハンドルの特殊変数のサブセットです。Perlのフォーマットの詳細については、&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d50e7fd9df415ed27a91da10839b57126db4d317" translate="yes" xml:space="preserve">
          <source>The special verbosity level 99 requires to also specify the -sections parameter; then these sections are extracted and printed.</source>
          <target state="translated">特殊冗長度レベル99では、-sectionsパラメータも指定する必要があり、これらのセクションが抽出されて印刷されます。</target>
        </trans-unit>
        <trans-unit id="79d7da7f02ba1ece997a8e1f533d9c05c192eb59" translate="yes" xml:space="preserve">
          <source>The specific task here is to sort the 286,525 lines of this file by Response Code, Query, Browser, Referring Url, and lastly Date. One solution might be to use the following code, which iterates over the files given on the command-line.</source>
          <target state="translated">ここでの具体的なタスクは、このファイルの286,525行をレスポンスコード、クエリ、ブラウザ、参照先URL、そして最後に日付でソートすることです。一つの解決策は、コマンドラインで与えられたファイルを繰り返し処理する以下のコードを使用することかもしれません。</target>
        </trans-unit>
        <trans-unit id="61bf1ad08824c740b76048cd4f454fa0d05ebcf4" translate="yes" xml:space="preserve">
          <source>The specification which tar derives from; &lt;code&gt; &lt;a href=&quot;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&quot;&gt;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">tarの派生元の仕様。 &lt;code&gt; &lt;a href=&quot;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&quot;&gt;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5249ead0cea582438ce306dee2ff065c9121394e" translate="yes" xml:space="preserve">
          <source>The specified</source>
          <target state="translated">指定された</target>
        </trans-unit>
        <trans-unit id="0bbf6ce071adc9bbc621e13b2eb0c9adb5ed909d" translate="yes" xml:space="preserve">
          <source>The specified filtering subroutine is called every time a &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG&lt;/code&gt; is encountered, and passed all the source code following that call, up to either the next &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; (or whatever terminator you've set) or the end of the source file, whichever occurs first. By default, any &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;
BANG;&lt;/code&gt; call must appear by itself on a separate line, or it is ignored.</source>
          <target state="translated">指定されたフィルター処理サブルーチンは、 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG&lt;/code&gt; が検出されるたびに呼び出され、その呼び出しに続くすべてのソースコードを次 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; まですべて渡します。（または設定したターミネータ）またはソースファイルの最後のいずれか最初に発生した方。デフォルトでは &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; はありません。呼び出しは単独で別の行に表示される必要があります。そうでない場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="c52324d25d30fa15232ecb990b5648a4dcfeb28a" translate="yes" xml:space="preserve">
          <source>The split function</source>
          <target state="translated">スプリット機能</target>
        </trans-unit>
        <trans-unit id="ddfcdc05a5251df7fbf9a8a775f1e8025aac3f91" translate="yes" xml:space="preserve">
          <source>The split operator</source>
          <target state="translated">分割演算子</target>
        </trans-unit>
        <trans-unit id="62b2eb8876cf935a6917a946dbc16da0fe289ddf" translate="yes" xml:space="preserve">
          <source>The square brackets explicitly turn a list value into a scalar value, while parentheses do not. So when a parenthesized list is evaluated in a scalar context, the comma is treated like C's comma operator, which throws away the left argument, which is not what you want. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for more on this.</source>
          <target state="translated">角括弧は明示的にリスト値をスカラー値に変換しますが、括弧は変換しません。そのため、括弧で囲まれたリストがスカラーコンテキストで評価される場合、コンマはCのコンマ演算子のように扱われ、左の引数が破棄されますが、これは必要なことではありません。詳しくは&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="daa1d51a4ab5d5dc2b248180c01a452f38c9d08d" translate="yes" xml:space="preserve">
          <source>The square brackets make a reference to a new array with a</source>
          <target state="translated">角括弧は、新しい配列への参照として</target>
        </trans-unit>
        <trans-unit id="23fce1430ee4d5e6ff2eda3c170c6c5f5f7f9889" translate="yes" xml:space="preserve">
          <source>The stability of these extensions varies widely. Some have been part of the core language for many years. Others are experimental and may change without warning or be completely removed. Check the documentation on an individual feature to verify its current status.</source>
          <target state="translated">これらの拡張機能の安定性は大きく異なります。あるものは何年も前からコア言語の一部となっています。その他のものは実験的なもので、警告なしに変更されたり、完全に削除されたりする可能性があります。現在の状態を確認するには、個々の機能のドキュメントをチェックしてください。</target>
        </trans-unit>
        <trans-unit id="1fd7c6e1c540b52e642a959640d5271791317f81" translate="yes" xml:space="preserve">
          <source>The stack arguments are accessible through the &lt;code&gt;ST(n)&lt;/code&gt; macro, which returns the &lt;code&gt;n&lt;/code&gt; 'th stack argument. Argument 0 is the first argument passed in the Perl subroutine call. These arguments are &lt;code&gt;SV*&lt;/code&gt; , and can be used anywhere an &lt;code&gt;SV*&lt;/code&gt; is used.</source>
          <target state="translated">スタック引数には、 &lt;code&gt;n&lt;/code&gt; 番目のスタック引数を返す &lt;code&gt;ST(n)&lt;/code&gt; マクロを介してアクセスできます。引数0は、Perlサブルーチン呼び出しで渡される最初の引数です。これらの引数は &lt;code&gt;SV*&lt;/code&gt; であり、 &lt;code&gt;SV*&lt;/code&gt; が使用される場所であればどこでも使用できます。</target>
        </trans-unit>
        <trans-unit id="25a0b1ef2ef458b2d3cc833a6246a76631f78cfb" translate="yes" xml:space="preserve">
          <source>The stack size of currently extant threads cannot be changed, therefore, the following results in the above error:</source>
          <target state="translated">現在存在するスレッドのスタックサイズを変更することができないため、以下の結果、上記のエラーとなります。</target>
        </trans-unit>
        <trans-unit id="fc601a28bc12b4ada50e0942554017adba6dc50b" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;&lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; modules, along with the &lt;code&gt;bignum&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; , and &lt;code&gt;bigrat&lt;/code&gt; pragmas, provide variable-precision arithmetic and overloaded operators, although they're currently pretty slow. At the cost of some space and considerable speed, they avoid the normal pitfalls associated with limited-precision representations.</source>
          <target state="translated">標準の &lt;code&gt;&lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt; 、Math :: BigRat、および &lt;code&gt;&lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; モジュールは、 &lt;code&gt;bignum&lt;/code&gt; 、 &lt;code&gt;bigint&lt;/code&gt; 、および &lt;code&gt;bigrat&lt;/code&gt; プラグマとともに、可変精度の算術演算子とオーバーロードされた演算子を提供しますが、現在はかなり低速です。ある程度のスペースとかなりの速度を犠牲にして、制限された精度の表現に関連する通常の落とし穴を回避します。</target>
        </trans-unit>
        <trans-unit id="ebb34ffe368cd7aab86ce86e94cbaf4a640b2d39" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;IO::Select&lt;/code&gt; module provides a user-friendlier interface to &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="translated">標準の &lt;code&gt;IO::Select&lt;/code&gt; モジュールは、ユーザーが使いやすいインターフェイスで &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; を提供します。これは、ほとんどの場合、すべてのビットマスクが機能するためです。</target>
        </trans-unit>
        <trans-unit id="16315bade45df278e7f616f03ff95a3f0a8f22eb" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;IO::Select&lt;/code&gt; module provides a user-friendlier interface to &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="translated">標準の &lt;code&gt;IO::Select&lt;/code&gt; モジュールは、ユーザーが使いやすいインターフェイスで &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; を提供します。これは、ほとんどの場合、すべてのビットマスクが機能するためです。</target>
        </trans-unit>
        <trans-unit id="7c56d1d9eaa2950435f175be867488228983813f" translate="yes" xml:space="preserve">
          <source>The standard Perl 5 MRO would be (D, B, A, C). The result being that &lt;b&gt;A&lt;/b&gt; appears before &lt;b&gt;C&lt;/b&gt;, even though &lt;b&gt;C&lt;/b&gt; is the subclass of &lt;b&gt;A&lt;/b&gt;. The C3 MRO algorithm however, produces the following order: (D, B, C, A), which does not have this issue.</source>
          <target state="translated">標準のPerl 5 MROは（D、B、A、C）です。その結果、&lt;b&gt;C&lt;/b&gt;は&lt;b&gt;A&lt;/b&gt;のサブクラスですが、&lt;b&gt;A&lt;/b&gt;が&lt;b&gt;Cの&lt;/b&gt;前に表示されます。ただし、C3 MROアルゴリズムは次の順序を生成します：（D、B、C、A）、これにはこの問題はありません。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="65db7a2a2e4a32185cf7e73efd313530e97c3f64" translate="yes" xml:space="preserve">
          <source>The standard Pod::Parser method parse_from_filehandle() takes up to two arguments, the first being the file handle to read POD from and the second being the file handle to write the formatted output to. The first defaults to STDIN if not given, and the second defaults to STDOUT. The method parse_from_file() is almost identical, except that its two arguments are the input and output disk files instead. See &lt;a href=&quot;parser&quot;&gt;Pod::Parser&lt;/a&gt; for the specific details.</source>
          <target state="translated">標準のPod :: Parserメソッドparse_from_filehandle（）は最大2つの引数を受け取ります。最初の引数はPODを読み取るファイルハンドルで、2番目の引数はフォーマットされた出力を書き込むファイルハンドルです。指定しない場合、1番目のデフォルトはSTDINになり、2番目のデフォルトはSTDOUTになります。parse_from_file（）メソッドは、2つの引数が代わりに入力および出力ディスクファイルであることを除いて、ほとんど同じです。参照してください&lt;a href=&quot;parser&quot;&gt;ポッド:: Parserの&lt;/a&gt;特定の詳細については。</target>
        </trans-unit>
        <trans-unit id="d459c791ef0819fa116e56f83671629a780f70ae" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_file() takes one argument naming the POD file to read from. By default, the output is sent to &lt;code&gt;STDOUT&lt;/code&gt; , but this can be changed with the output_fh() method.</source>
          <target state="translated">標準のPod :: Simpleメソッドparse_file（）は、読み取り元のPODファイルに名前を付ける引数を1つ取ります。デフォルトでは、出力は &lt;code&gt;STDOUT&lt;/code&gt; に送信されますが、これはoutput_fh（）メソッドで変更できます。</target>
        </trans-unit>
        <trans-unit id="b669405b1331755a6517c831be989ebdf0920199" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_from_file() takes up to two arguments, the first being the input file to read POD from and the second being the file to write the formatted output to.</source>
          <target state="translated">標準のPod::Simpleメソッドparse_from_file()は最大2つの引数を取ります。</target>
        </trans-unit>
        <trans-unit id="c21871c0e5568494a7fbe46008b5f9b899656bd2" translate="yes" xml:space="preserve">
          <source>The standard Tie::RefHash module provides a convenient workaround to this.</source>
          <target state="translated">標準の Tie::RefHash モジュールは、これを回避する便利な方法を提供しています。</target>
        </trans-unit>
        <trans-unit id="66cc6332c8e3c57e5b8e7b4ce541f13735f1aa06" translate="yes" xml:space="preserve">
          <source>The standard Unicode properties listed below are documented in &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;; Perl_Decimal_Digit is documented in &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;prop_invmap() in Unicode::UCD&lt;/a&gt;. The other Perl extensions are in &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;Other Properties in perlunicode&lt;/a&gt;;</source>
          <target state="translated">下記の標準Unicodeプロパティは、&lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http：//www.unicode.org/reports/tr44/に&lt;/a&gt;記載されています。Perl_Decimal_Digitは&lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;、Unicode :: UCDのprop_invmap（）に記載されています&lt;/a&gt;。その他のPerl拡張機能は&lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;、perlunicodeのその他のプロパティにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="fdea898e7a6fa5187cc16e508d0249ddcaeda57c" translate="yes" xml:space="preserve">
          <source>The standard release of Perl (the one maintained by the Perl development team) is distributed only in source code form. You can find the latest releases at &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;.</source>
          <target state="translated">Perlの標準リリース（Perl開発チームによって保守されているもの）は、ソースコード形式でのみ配布されます。最新のリリースは&lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/にあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="026f8e314f5a0595f026a7356cc10536cfc51440" translate="yes" xml:space="preserve">
          <source>The standard sections of a manual page are:</source>
          <target state="translated">マニュアルページの標準的なセクションは</target>
        </trans-unit>
        <trans-unit id="ebe88b6db5cc5c12b5e1ae182a8ede9bae134d07" translate="yes" xml:space="preserve">
          <source>The standard typemap does not contain PerlIO * before perl 5.7, but it has the three stream variants. Using a PerlIO * directly is not backwards compatible unless you provide your own typemap.</source>
          <target state="translated">標準のタイプマップにはPerl5.7以前のPerlIO *は含まれていませんが、3つのストリームバリアントがあります。独自のタイプマップを提供しない限り、PerlIO *を直接使用することは下位互換性がありません。</target>
        </trans-unit>
        <trans-unit id="a4d40d48d96b939643d17277ad94dfc253906873" translate="yes" xml:space="preserve">
          <source>The standard typemap offers three variants of PerlIO *: &lt;code&gt;InputStream&lt;/code&gt; (T_IN), &lt;code&gt;InOutStream&lt;/code&gt; (T_INOUT) and &lt;code&gt;OutputStream&lt;/code&gt; (T_OUT). A bare &lt;code&gt;PerlIO *&lt;/code&gt; is considered a T_INOUT. If it matters in your code (see below for why it might) #define or typedef one of the specific names and use that as the argument or result type in your XS file.</source>
          <target state="translated">標準タイプマップは、PerlIO *の3つのバリアントを提供します： &lt;code&gt;InputStream&lt;/code&gt; （T_IN）、 &lt;code&gt;InOutStream&lt;/code&gt; （T_INOUT）、および &lt;code&gt;OutputStream&lt;/code&gt; （T_OUT）。裸の &lt;code&gt;PerlIO *&lt;/code&gt; はT_INOUTと見なされます。コードで重要な場合（その理由については以下を参照）、特定の名前の1つを#defineまたはtypedefし、それをXSファイルの引数または結果の型として使用します。</target>
        </trans-unit>
        <trans-unit id="3718e2c8d6baf1715fb8924869dc7062354846f5" translate="yes" xml:space="preserve">
          <source>The standard/default list of directories in which dl_findfile() will search for libraries etc. Directories are searched in order: $dl_library_path[0], [1], ... etc</source>
          <target state="translated">dl_findfile()がライブラリ等を検索するデ ィ レ ク ト リ の標準/デ フォルト リ ス ト リ ス ト 。ディレクトリは順に検索されます。ディレクトリは、 $dl_library_path[0],[1],...などの順に検索されます。</target>
        </trans-unit>
        <trans-unit id="81b82092af810ac11d0e71f19aeda4997801a33d" translate="yes" xml:space="preserve">
          <source>The stash associated with a typed lexical. This returns the %Foo:: hash for &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Foo $bar&lt;/code&gt; .</source>
          <target state="translated">型付きレキシカルに関連付けられたスタッシュ。これは、 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Foo $bar&lt;/code&gt; の％Foo ::ハッシュを返します。</target>
        </trans-unit>
        <trans-unit id="cc4f30ab95381b1c15dfe4d97fa8f832c168bf1d" translate="yes" xml:space="preserve">
          <source>The stash in which this &quot;our&quot; variable was declared.</source>
          <target state="translated">この &quot;私たちの &quot;変数が宣言されていた隠し場所。</target>
        </trans-unit>
        <trans-unit id="136e96ab03183ea4c3a7028af3545e7d9d5bc253" translate="yes" xml:space="preserve">
          <source>The stat() mode bits are probably right for most of the files and directories found on your system, because few people want to use the additional features offered by access(). But you may encounter surprises if your program runs on a system that uses ACLs, since the stat() information won't reflect the actual permissions.</source>
          <target state="translated">stat()モードのビットは、おそらくシステム上のほとんどのファイルやディレクトリに対しては正しいでしょう。しかし、あなたのプログラムが ACL を使用しているシステム上で実行されている場合、stat()の情報は実際のパーミッションを反映していないため、 驚くようなことに遭遇するかもしれません。</target>
        </trans-unit>
        <trans-unit id="e8e71255cf8fb3fde9520415463a7e71c11cd3c9" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;($gw_fh, 0, 1)&lt;/code&gt; doesn't change the current position, but it does clear the end-of-file condition on the handle, so that the next &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; makes Perl try again to read something.</source>
          <target state="translated">ステートメント &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;($gw_fh, 0, 1)&lt;/code&gt; は現在の位置を変更しませんが、ハンドルのファイルの終わり条件をクリアするため、次の &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; はPerlに何かの読み取りを再試行させます。</target>
        </trans-unit>
        <trans-unit id="707171be35bdd3b79efa241046dd3631507040a6" translate="yes" xml:space="preserve">
          <source>The status 2 indicates that at least one of the specified files does not contain</source>
          <target state="translated">ステータス2は、指定されたファイルのうち少なくとも1つが</target>
        </trans-unit>
        <trans-unit id="9251e77389b34b5c344d864eb779d11058b888c5" translate="yes" xml:space="preserve">
          <source>The status code returned from &lt;code&gt;inflate&lt;/code&gt; will only trigger termination of the main processing loop if it isn't &lt;code&gt;Z_OK&lt;/code&gt; . When &lt;code&gt;LimitOutput&lt;/code&gt; has not been used the &lt;code&gt;Z_OK&lt;/code&gt; status means that the end of the compressed data stream has been reached or there has been an error in uncompression.</source>
          <target state="translated">&lt;code&gt;inflate&lt;/code&gt; から返されたステータスコードは、それが &lt;code&gt;Z_OK&lt;/code&gt; でない場合にのみ、メイン処理ループの終了をトリガーします。 &lt;code&gt;LimitOutput&lt;/code&gt; が使用されていない場合、 &lt;code&gt;Z_OK&lt;/code&gt; ステータスは、圧縮されたデータストリームの最後に到達したか、圧縮解除でエラーが発生したことを意味します。</target>
        </trans-unit>
        <trans-unit id="2298239a448f47305c5dbab535dd02c58c7526e3" translate="yes" xml:space="preserve">
          <source>The status of the hushed flag also affects output of VMS error messages from compilation errors. Again, you still get the Perl error message (and the code in $STATUS)</source>
          <target state="translated">hushed フラグのステータスは、コンパイルエラーからの VMS エラーメッセージの出力にも影響します。ここでも、Perl のエラーメッセージ (と $STATUS のコード)が出力されます。</target>
        </trans-unit>
        <trans-unit id="4cb40ccf1b5efc1b553ba9f11bd2e4b83ffc7264" translate="yes" xml:space="preserve">
          <source>The status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt; ) command, successful call to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt;, or from the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; operator. This is just the 16-bit status word returned by the traditional Unix &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; system call (or else is made up to look like it). Thus, the exit value of the subprocess is really (&lt;code&gt;$?&amp;gt;&amp;gt;
8&lt;/code&gt; ), and &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; gives which signal, if any, the process died from, and &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; reports whether there was a core dump.</source>
          <target state="translated">最後のパイプのクローズ、バックティック（ &lt;code&gt;``&lt;/code&gt; ）コマンド、 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; への正常な呼び出し、または &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; オペレーターから返されたステータス。これは、従来のUnixの &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; システムコールによって返される16ビットのステータスワードにすぎません（または他の方法で構成されています）。したがって、サブプロセスの終了値は実際には（ &lt;code&gt;$?&amp;gt;&amp;gt; 8&lt;/code&gt; ）であり、 &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; は、プロセスが停止したシグナル（ある場合）と &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; は、コアダンプがあったかどうかを報告します。</target>
        </trans-unit>
        <trans-unit id="6450e7782a48b71f2dca0230b4493dd10ff37ce5" translate="yes" xml:space="preserve">
          <source>The status value that is returned by the user's &lt;code&gt;filter&lt;/code&gt; method or anonymous sub and the &lt;code&gt;filter_read&lt;/code&gt; and &lt;code&gt;read_exact&lt;/code&gt; functions take the same set of values, namely:</source>
          <target state="translated">ユーザーの &lt;code&gt;filter&lt;/code&gt; メソッドまたは無名サブルーチンによって返されるステータス値と、 &lt;code&gt;filter_read&lt;/code&gt; および &lt;code&gt;read_exact&lt;/code&gt; 関数は、同じ値のセットを取ります。</target>
        </trans-unit>
        <trans-unit id="3b8220a76d45ce112350b70ee4dbd73fc8b8bc74" translate="yes" xml:space="preserve">
          <source>The stdio(3C) manpage notes that for LP32 applications, only 255 files may be opened using fopen(), and only file descriptors 0 through 255 can be used in a stream. Since perl calls open() and then fdopen(3C) with the resulting file descriptor, perl is limited to 255 simultaneous open files, even if sysopen() is used. If this proves to be an insurmountable problem, you can compile perl as a LP64 application, see &lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;Building an LP64 perl&lt;/a&gt; for details. Note also that the default resource limit for open file descriptors on Solaris is 255, so you will have to modify your ulimit or rctl (Solaris 9 onwards) appropriately.</source>
          <target state="translated">stdio（3C）のマンページには、LP32アプリケーションの場合、fopen（）を使用して開くことができるファイルは255ファイルのみであり、ストリームで使用できるのはファイル記述子0〜255のみであると記載されています。 perlはopen（）を呼び出し、次にfdopen（3C）を呼び出して結果のファイル記述子を付けるため、sysopen（）が使用されている場合でも、perlは同時オープンファイルを255に制限します。これが解決できない問題であることが判明した場合は、perlをLP64アプリケーションとしてコンパイルできます。詳細については&lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;、LP64 perlのビルド&lt;/a&gt;を参照してください。また、Solarisでのオープンファイル記述子のデフォルトのリソース制限は255であるため、ulimitまたはrctl（Solaris 9以降）を適切に変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="00bff96ca21371570b04e3ba98b01671b01481ae" translate="yes" xml:space="preserve">
          <source>The store functions will &lt;code&gt;croak&lt;/code&gt; if they run into such references unless you set &lt;code&gt;$Storable::forgive_me&lt;/code&gt; to some &lt;code&gt;TRUE&lt;/code&gt; value. In that case, the fatal message is converted to a warning and some meaningless string is stored instead.</source>
          <target state="translated">店舗機能はします &lt;code&gt;croak&lt;/code&gt; し、彼らはあなたが設定されていない限り、このような言及に実行する場合、 &lt;code&gt;$Storable::forgive_me&lt;/code&gt; いくつかに &lt;code&gt;TRUE&lt;/code&gt; 値。その場合、致命的なメッセージは警告に変換され、代わりに意味のない文字列が保存されます。</target>
        </trans-unit>
        <trans-unit id="af1c1657bd0ce03b1ba6ae64acc2840b7f31bd40" translate="yes" xml:space="preserve">
          <source>The strend and patend pointers should point to the byte following the last character of each string.</source>
          <target state="translated">strend および patend ポインタは、各文字列の最後の文字に続くバイトを指すべきです。</target>
        </trans-unit>
        <trans-unit id="ccae9ac2ba65b56262ababed8ca5ba389eb0ed32" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt; . (Ths tells Perl to use the &lt;code&gt;NDBM_File&lt;/code&gt; package to perform the functions of the hash.)</source>
          <target state="translated">文字列 &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt; 。（これは、ハッシュの機能を実行するために &lt;code&gt;NDBM_File&lt;/code&gt; パッケージを使用するようにPerlに指示します。）</target>
        </trans-unit>
        <trans-unit id="c5c77c76e1fc3205395047a2345f8ef41459d3bb" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;$vec&lt;/code&gt; only takes up as many bits as it needs. For instance, if you had 16 entries in &lt;code&gt;@ints&lt;/code&gt; , &lt;code&gt;$vec&lt;/code&gt; only needs two bytes to store them (not counting the scalar variable overhead).</source>
          <target state="translated">文字列 &lt;code&gt;$vec&lt;/code&gt; は、必要なビットだけを使用します。たとえば、 &lt;code&gt;@ints&lt;/code&gt; に16個のエントリがある場合、 &lt;code&gt;$vec&lt;/code&gt; はそれらを格納するために2バイトしか必要としません（スカラー変数のオーバーヘッドはカウントしません）。</target>
        </trans-unit>
        <trans-unit id="ace981c506425cb8cbcfe9d653a843e517d5bdac" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;br&amp;ucirc;l&amp;eacute;e&lt;/code&gt; has six graphemes but up to eight codepoints. This counts by grapheme, not by codepoint:</source>
          <target state="translated">文字列 &lt;code&gt;br&amp;ucirc;l&amp;eacute;e&lt;/code&gt; には、6つの書記素がありますが、最大8つのコードポイントがあります。これは、コードポイントではなく書記素でカウントされます。</target>
        </trans-unit>
        <trans-unit id="e842cb2ff66d209b19263b7c79265ed68c6571d7" translate="yes" xml:space="preserve">
          <source>The string following whatever was matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK). Example:</source>
          <target state="translated">最後に成功したパターンマッチで一致したものに続く文字列 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 現在のBLOCKで囲まれたBLOCKまたはeval（）内に隠された一致はカウントされません）。例：</target>
        </trans-unit>
        <trans-unit id="64817d2b5e56c060bf38149d53adb10efe254293" translate="yes" xml:space="preserve">
          <source>The string for Tuesday, December 12, 1995.</source>
          <target state="translated">1995年12月12日(火)の紐。</target>
        </trans-unit>
        <trans-unit id="f9abb06eb1806839c0e5b7b9bda35c81b35ae824" translate="yes" xml:space="preserve">
          <source>The string index to a &lt;b&gt;hash&lt;/b&gt;, used to look up the &lt;b&gt;value&lt;/b&gt; associated with that key.</source>
          <target state="translated">&lt;b&gt;ハッシュ&lt;/b&gt;への文字列インデックス。そのキーに関連付けられた&lt;b&gt;値&lt;/b&gt;を検索するために使用されます。</target>
        </trans-unit>
        <trans-unit id="cdaff357d54d31b09acea6f6d18fd623eddeb9f1" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="translated">文字列は、TEMPLATEによって記述されたチャンクに分割されます。各チャンクは個別に値に変換されます。通常、文字列は &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; の結果であるか、文字列の文字は何らかのC構造を表します。</target>
        </trans-unit>
        <trans-unit id="1c49e7731d3dc172a2f14e1ee383fed675a44e84" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="translated">文字列は、TEMPLATEによって記述されたチャンクに分割されます。各チャンクは個別に値に変換されます。通常、文字列は &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; の結果であるか、文字列の文字は何らかのC構造を表します。</target>
        </trans-unit>
        <trans-unit id="188acb1539bbcc7515d5af86f1bf3d6e3f0bd9c0" translate="yes" xml:space="preserve">
          <source>The string matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK).</source>
          <target state="translated">最後に成功したパターンマッチで一致した文字列 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 現在のBLOCKで囲まれたBLOCKまたはeval（）内に隠されている一致はカウントされません）。</target>
        </trans-unit>
        <trans-unit id="3d206cfe2e19b0f3779f91c6d76bdde7d7e22deb" translate="yes" xml:space="preserve">
          <source>The string output (of floating point numbers) will be padded with zeros:</source>
          <target state="translated">(浮動小数点数の)文字列出力はゼロでパディングされます。</target>
        </trans-unit>
        <trans-unit id="baf7cbc523832c454565f07354dbdc53faf7a98a" translate="yes" xml:space="preserve">
          <source>The string output will always have leading and trailing zeros stripped and drop a plus sign. &lt;code&gt;bstr()&lt;/code&gt; will give you always the form with a decimal point, while &lt;code&gt;bsstr()&lt;/code&gt; (s for scientific) gives you the scientific notation.</source>
          <target state="translated">文字列出力では、常に先行ゼロと後続ゼロが取り除かれ、プラス記号がドロップされます。 &lt;code&gt;bstr()&lt;/code&gt; は常に小数点のある形式を提供し、 &lt;code&gt;bsstr()&lt;/code&gt; （科学の場合はs）は科学表記を提供します。</target>
        </trans-unit>
        <trans-unit id="fe7b97aace0009c030b7f9cefcb2ca042c7263c6" translate="yes" xml:space="preserve">
          <source>The string preceding whatever was matched by the last successful pattern match, not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK.</source>
          <target state="translated">最後に成功したパターンマッチで一致したものの前の文字列。現在のBLOCKで囲まれたBLOCKまたは &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 内に隠された一致はカウントされません。</target>
        </trans-unit>
        <trans-unit id="3d01fff15593695c94b4861cde9efd9b7494ec49" translate="yes" xml:space="preserve">
          <source>The string result of any operation that uses locale information is tainted, as it is possible for a locale to be untrustworthy. See &lt;a href=&quot;#SECURITY&quot;&gt;SECURITY&lt;/a&gt;.</source>
          <target state="translated">ロケールが信頼できない可能性があるため、ロケール情報を使用するすべての操作の文字列結果は汚染されます。&lt;a href=&quot;#SECURITY&quot;&gt;SECURITYを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="8fe36e2f9f506bb3c17ca908f63a229076cb522b" translate="yes" xml:space="preserve">
          <source>The string returned is not always in NFD/NFKD. Reordering may be required.</source>
          <target state="translated">返される文字列は、NFD/NFKDとは限りません。並び替えが必要な場合があります。</target>
        </trans-unit>
        <trans-unit id="0906d45502ea0bd7da882f8e89531d4e1f01bc75" translate="yes" xml:space="preserve">
          <source>The string that starts options. If a constant string is not sufficient, see &lt;code&gt;prefix_pattern&lt;/code&gt; .</source>
          <target state="translated">オプションを開始する文字列。定数文字列では不十分な場合は、 &lt;code&gt;prefix_pattern&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="fcff2e1cc42c11b32cad489cc398585a2adb0338" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by</source>
          <target state="translated">挿入される文字列は</target>
        </trans-unit>
        <trans-unit id="e41abf45c9431728dd7313f8c098905bb3fb1c5d" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by octets starting at</source>
          <target state="translated">挿入される文字列は</target>
        </trans-unit>
        <trans-unit id="afbb1230317b082fc0f64afe5f1a79c6e5661e9b" translate="yes" xml:space="preserve">
          <source>The string to be inserted is the string value of</source>
          <target state="translated">挿入する文字列は</target>
        </trans-unit>
        <trans-unit id="5a627ebdca058ca40f7afebaa0947770e3b19935" translate="yes" xml:space="preserve">
          <source>The string value of &lt;code&gt;$!&lt;/code&gt; is that returned by the CRTL's strerror() function, so it will include the VMS message for VMS-specific errors. The numeric value of &lt;code&gt;$!&lt;/code&gt; is the value of &lt;code&gt;errno&lt;/code&gt; , except if errno is EVMSERR, in which case &lt;code&gt;$!&lt;/code&gt; contains the value of vaxc$errno. Setting &lt;code&gt;$!&lt;/code&gt; always sets errno to the value specified. If this value is EVMSERR, it also sets vaxc$errno to 4 (NONAME-F-NOMSG), so that the string value of &lt;code&gt;$!&lt;/code&gt; won't reflect the VMS error message from before &lt;code&gt;$!&lt;/code&gt; was set.</source>
          <target state="translated">&lt;code&gt;$!&lt;/code&gt; の文字列値 これはCRTLのstrerror（）関数によって返されるものであるため、VMS固有のエラーのVMSメッセージが含まれます。 &lt;code&gt;$!&lt;/code&gt; の数値！ &lt;code&gt;errno&lt;/code&gt; の値です。ただし、errnoがEVMSERRの場合は例外 &lt;code&gt;$!&lt;/code&gt; この場合、$！vaxc $ errnoの値が含まれます。 &lt;code&gt;$!&lt;/code&gt; 設定しています！errnoを常に指定された値に設定します。この値がEVMSERRの場合、vaxc $ errnoも4（NONAME-F-NOMSG）に設定されるため、文字列値 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;$!&lt;/code&gt; 前からのVM​​Sエラーメッセージは反映されません！設定されました。</target>
        </trans-unit>
        <trans-unit id="ed1f52a4cdbc897685e0ae4db35f3139cd121ffc" translate="yes" xml:space="preserve">
          <source>The string value of the $data provided as argument is appended to the message we calculate the digest for. The return value is the $ctx object itself.</source>
          <target state="translated">引数として与えられた$dataの文字列の値が、ダイジェストを計算するメッセージに付加されます。戻り値は、$ctxオブジェクトそのものです。</target>
        </trans-unit>
        <trans-unit id="8d2353f63db6ded15b27f9ce53f46b40b4850e7c" translate="yes" xml:space="preserve">
          <source>The struct() function</source>
          <target state="translated">struct()関数</target>
        </trans-unit>
        <trans-unit id="2b18f7164a2da5acc0a078abefbfdb45f1b7ed1a" translate="yes" xml:space="preserve">
          <source>The structure of the tied() data is an array reference with elements</source>
          <target state="translated">tied()データの構造は、要素</target>
        </trans-unit>
        <trans-unit id="6772fe1a2535c049980c3763958a49b4c1d992f9" translate="yes" xml:space="preserve">
          <source>The stub package included with the perl distribution allows some additional methods:</source>
          <target state="translated">perl ディストリビューションに含まれるスタブパッケージでは、いくつかのメソッドを追加することができます。</target>
        </trans-unit>
        <trans-unit id="6bfcc48f6a94ab4b3e39e57492b7c1d6d2ad759d" translate="yes" xml:space="preserve">
          <source>The submitter address in &lt;code&gt;AUTH&lt;/code&gt; option is expected to be in a format as required by RFC 2554, in an RFC2821-quoted form and xtext-encoded, or &amp;lt;&amp;gt; .</source>
          <target state="translated">&lt;code&gt;AUTH&lt;/code&gt; オプションの送信者アドレスは、RFC 2554で要求されている形式、RFC2821で引用された形式、xtext-encoded、または&amp;lt;&amp;gt;であることが想定されています。</target>
        </trans-unit>
        <trans-unit id="4fb6dff8391b18be99fd9ebb7eb204cdfa56639a" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'='&lt;/code&gt; does not overload the Perl assignment operator: it is used only to allow mutators to work as described here. (See &lt;a href=&quot;#Assignments&quot;&gt;Assignments&lt;/a&gt; above.)</source>
          <target state="translated">&lt;code&gt;'='&lt;/code&gt; のサブルーチンは、Perlの代入演算子をオーバーロードしません。これは、ミューテーターがここで説明するように機能するためだけに使用されます。（上記の&lt;a href=&quot;#Assignments&quot;&gt;割り当てを&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="f6d2e2cf74b94dd2aff54191a4db818c472b013b" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'qr'&lt;/code&gt; is used wherever the object is interpolated into or used as a regexp, including when it appears on the RHS of a &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;'qr'&lt;/code&gt; のサブルーチンは、 &lt;code&gt;=~&lt;/code&gt; または &lt;code&gt;!~&lt;/code&gt; 演算子のRHSに現れるときを含め、オブジェクトが補間されるか正規表現として使用される場合に使用されます。</target>
        </trans-unit>
        <trans-unit id="64e556905a1003da7539606b5717985b47db5c9d" translate="yes" xml:space="preserve">
          <source>The subroutine for the assignment variant of an operator is required only to return the result of the operation. It is permitted to change the value of its operand (this is safe because Perl calls the copy constructor first), but this is optional since Perl assigns the returned value to the left-hand operand anyway.</source>
          <target state="translated">演算子の代入バリアントのサブルーチンは、演算結果を返すことだけが要求されます。オペランドの値を変更することは許されていますが(Perlは最初にコピーコンストラクタを呼び出すのでこれは安全です)、Perlはいずれにせよ返された値を左手のオペランドに代入するので、これはオプションです。</target>
        </trans-unit>
        <trans-unit id="bf76f7497b47b7fb391cbc985e75a2ec906b200f" translate="yes" xml:space="preserve">
          <source>The subroutine interface has the advantage over the constants interface in that only two subroutines are exported into your namespace, versus thirty-eight in the constants interface. On the flip side, the constants interface has the advantage of better compile time error checking, since misspelled names of colors or attributes in calls to color() and colored() won't be caught until runtime whereas misspelled names of constants will be caught at compile time. So, pollute your namespace with almost two dozen subroutines that you may not even use that often, or risk a silly bug by mistyping an attribute. Your choice, TMTOWTDI after all.</source>
          <target state="translated">サブルーチンインターフェースは定数インターフェースに比べて、名前空間にエクスポートされるサブルーチンが2つだけなのに対し、定数インターフェースでは38のサブルーチンがエクスポートされます。その一方で、定数インターフェイスにはコンパイル時のエラーチェックが容易になるという利点があります。そのため、それほど頻繁には使わないかもしれないサブルーチンで名前空間を汚したり、属性のスペルミスで愚かなバグを起こしたりする危険性があります。結局のところ、TMTOWTDIはあなたの選択です。</target>
        </trans-unit>
        <trans-unit id="914a52e2466ed981c0c31fa5a16b3a84e13235bf" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to five optional arguments:</source>
          <target state="translated">このサブルーチンは最大5つのオプションの引数を取ります。</target>
        </trans-unit>
        <trans-unit id="685ad04169c11394ad7ed60a2bfecf22cb675ffa" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to four optional arguments (the same set as &lt;code&gt;extract_tagged&lt;/code&gt; except for the string to be processed). It returns a reference to a subroutine which in turn takes a single argument (the text to be extracted from).</source>
          <target state="translated">サブルーチンは最大4つのオプションの引数を取ります（処理される文字列を除いて、 &lt;code&gt;extract_tagged&lt;/code&gt; と同じセット）。サブルーチンへの参照を返し、サブルーチンは単一の引数（テキストの抽出元）を取ります。</target>
        </trans-unit>
        <trans-unit id="8d893978d831c7b5b97d6abcf392307452f2c4dc" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to four optional arguments:</source>
          <target state="translated">このサブルーチンは最大4つのオプションの引数を取ります。</target>
        </trans-unit>
        <trans-unit id="7612ae6125d2980d42108a51846f43870c13a8ab" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to two optional arguments:</source>
          <target state="translated">このサブルーチンは最大2つのオプションの引数を取ります。</target>
        </trans-unit>
        <trans-unit id="3a75faaa2a2f313dd76bd18e70bc1892ae4231d3" translate="yes" xml:space="preserve">
          <source>The subroutines for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; , and &lt;code&gt;'bool'&lt;/code&gt; can return any arbitrary Perl value. If the corresponding operation for this value is overloaded too, the operation will be called again with this value.</source>
          <target state="translated">&lt;code&gt;'&quot;&quot;'&lt;/code&gt; 、 &lt;code&gt;'0+'&lt;/code&gt; 、および &lt;code&gt;'bool'&lt;/code&gt; のサブルーチンは、任意のPerl値を返すことができます。この値に対応する操作もオーバーロードされている場合、操作はこの値で再度呼び出されます。</target>
        </trans-unit>
        <trans-unit id="268a5bcbdfddf71f1babd661a5336aa5d10c3ae8" translate="yes" xml:space="preserve">
          <source>The subroutines must return a specially-formatted string, with one or more newline-separated lines. Each line must be one of the following:</source>
          <target state="translated">サブルーチンは、1行以上の改行で区切られた特殊な書式の文字列を返さなければなりません。各行は以下のいずれかでなければなりません。</target>
        </trans-unit>
        <trans-unit id="2ba07955562198fe0f02a6cf2bc902a4d38ec5bc" translate="yes" xml:space="preserve">
          <source>The subscript separator for multidimensional array emulation. If you refer to a hash element as</source>
          <target state="translated">多次元配列エミュレーションのための添え字区切り文字。ハッシュ要素を</target>
        </trans-unit>
        <trans-unit id="b5d318f376ec00a74018e4ca7dc7c929a2558708" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">置換演算子。&lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;perlopのRegexp引用型演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cdda388fa507341e8fbaf2711ecce13a77670278" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">置換演算子。&lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlopのRegexp引用型演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="43eed4ac710279951c5f21e178623c718cf97122" translate="yes" xml:space="preserve">
          <source>The substring to be extracted must appear at the current &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; location of the string's variable (or at index zero, if no &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; position is defined). In other words, the &lt;code&gt;extract_...&lt;/code&gt; subroutines</source>
          <target state="translated">抽出される部分文字列は、文字列の変数の現在の &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 位置（または、 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 位置が定義されていない場合はインデックス0）に出現する必要があります。つまり、 &lt;code&gt;extract_...&lt;/code&gt; サブルーチン</target>
        </trans-unit>
        <trans-unit id="631c84fac439176eea77875d9cd55aac6e34bef4" translate="yes" xml:space="preserve">
          <source>The subtle but sometimes brutal art of attempting to turn your possibly malformed program into a valid &lt;b&gt;syntax tree&lt;/b&gt;.</source>
          <target state="translated">おそらく不正な形式のプログラムを有効な&lt;b&gt;構文ツリー&lt;/b&gt;に変えようとする、微妙ですが時には残忍な技術です。</target>
        </trans-unit>
        <trans-unit id="69b5462de54900759de9c61920b693e4e317aaf5" translate="yes" xml:space="preserve">
          <source>The subversion level of this package. The value of subversion comes from the</source>
          <target state="translated">このパッケージのサブバージョンレベル。subversion の値は</target>
        </trans-unit>
        <trans-unit id="270d4886cf1a538b0addd0c2b282f59bb7645fa0" translate="yes" xml:space="preserve">
          <source>The superuser (&lt;code&gt;UID&lt;/code&gt; == 0). Also the top-level directory of the filesystem.</source>
          <target state="translated">スーパーユーザー（ &lt;code&gt;UID&lt;/code&gt; == 0）。また、ファイルシステムの最上位ディレクトリ。</target>
        </trans-unit>
        <trans-unit id="bb4d5743fc0dd23109f98c367b228edac660d539" translate="yes" xml:space="preserve">
          <source>The support of Unicode is new starting from Perl version v5.6, and more fully implemented in versions v5.8 and later. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">UnicodeのサポートはPerlバージョンv5.6から新しく追加され、バージョンv5.8以降ではさらに完全に実装されています。&lt;a href=&quot;perluniintro&quot;&gt;perluniintroを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a84c55afdf9f74f3a1d06dd4132c903afc0559c7" translate="yes" xml:space="preserve">
          <source>The supported platforms are Linux, and OS X (some *BSD might work at least partly, but they have not yet been tested).</source>
          <target state="translated">サポートされているプラットフォームは Linux と OS X です (一部の *BSD は少なくとも部分的には動作するかもしれませんが、まだテストされていません)。</target>
        </trans-unit>
        <trans-unit id="c6fbcb6100de3c481ef36f607630c6994106ebd8" translate="yes" xml:space="preserve">
          <source>The surprising part is that &lt;code&gt;--a&lt;/code&gt; sets option &lt;code&gt;a&lt;/code&gt; (due to auto completion), not &lt;code&gt;all&lt;/code&gt; .</source>
          <target state="translated">意外なのは、-- &lt;code&gt;--a&lt;/code&gt; がオプション &lt;code&gt;a&lt;/code&gt; （自動補完のため）を設定することです。 &lt;code&gt;all&lt;/code&gt; ではありません。</target>
        </trans-unit>
        <trans-unit id="033617fd53c9330532a1c3d67c45fd0449d158c6" translate="yes" xml:space="preserve">
          <source>The surroundings or environment. The context given by the surrounding code determines what kind of data a particular &lt;b&gt;expression&lt;/b&gt; is expected to return. The three primary contexts are &lt;b&gt;list context&lt;/b&gt;, &lt;b&gt;scalar&lt;/b&gt;, and &lt;b&gt;void context&lt;/b&gt;. Scalar context is sometimes subdivided into &lt;b&gt;Boolean context&lt;/b&gt;, &lt;b&gt;numeric context&lt;/b&gt;, &lt;b&gt;string context&lt;/b&gt;, and &lt;b&gt;void context&lt;/b&gt;. There&amp;rsquo;s also a &amp;ldquo;don&amp;rsquo;t care&amp;rdquo; context (which is dealt with in Camel chapter 2, &amp;ldquo;Bits and Pieces&amp;rdquo;, if you care).</source>
          <target state="translated">周囲または環境。周囲のコードによって与えられるコンテキストは、特定の&lt;b&gt;式&lt;/b&gt;が返すと予想されるデータの種類を決定します。 3つの主要なコンテキストは、&lt;b&gt;リストコンテキスト&lt;/b&gt;、&lt;b&gt;スカラー&lt;/b&gt;、および&lt;b&gt;voidコンテキスト&lt;/b&gt;です。スカラーコンテキストは、&lt;b&gt;ブールコンテキスト&lt;/b&gt;、&lt;b&gt;数値コンテキスト&lt;/b&gt;、&lt;b&gt;文字列コンテキスト&lt;/b&gt;、および&lt;b&gt;ボイドコンテキストに&lt;/b&gt;細分される場合があり&lt;b&gt;ます&lt;/b&gt;。 「ドントケア」のコンテキストもあります（キャメルの第2章「ビットとピース」で扱います）。</target>
        </trans-unit>
        <trans-unit id="ed80b515b4081009a4556929c3f21adbe337dfc8" translate="yes" xml:space="preserve">
          <source>The sv_magic function uses &lt;code&gt;how&lt;/code&gt; to determine which, if any, predefined &quot;Magic Virtual Table&quot; should be assigned to the &lt;code&gt;mg_virtual&lt;/code&gt; field. See the &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; section below. The &lt;code&gt;how&lt;/code&gt; argument is also stored in the &lt;code&gt;mg_type&lt;/code&gt; field. The value of &lt;code&gt;how&lt;/code&gt; should be chosen from the set of macros &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; found in</source>
          <target state="translated">sv_magic関数は、 &lt;code&gt;mg_virtual&lt;/code&gt; フィールドに割り当てる必要がある定義済みの「マジック仮想テーブル」がある場合は、それを決定する &lt;code&gt;how&lt;/code&gt; を使用します。以下の&lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt;セクションを参照してください。 &lt;code&gt;how&lt;/code&gt; 引数もに保存されている &lt;code&gt;mg_type&lt;/code&gt; のフィールド。 &lt;code&gt;how&lt;/code&gt; の値は、 &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; 場所にあるマクロPERL_MAGIC_fooのセットから選択する必要があります</target>
        </trans-unit>
        <trans-unit id="6d632295f69a2e258303de734a1930d293a5d47a" translate="yes" xml:space="preserve">
          <source>The switch statement is called &lt;code&gt;given/when&lt;/code&gt; and only available in perl 5.10 or newer. See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">switchステートメントは &lt;code&gt;given/when&lt;/code&gt; と呼ばれ、perl 5.10以降でのみ使用できます。&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;perlsynのSwitchステートメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="fd4512bd52c00d29ccebf2f597b2a43c4da8833a" translate="yes" xml:space="preserve">
          <source>The symbol between angle brackets indicates the op's type, for example; &amp;lt;2&amp;gt; is a BINOP, &amp;lt;@&amp;gt; a LISTOP, and &amp;lt;#&amp;gt; is a PADOP, which is used in threaded perls. (see &lt;a href=&quot;#OP-class-abbreviations&quot;&gt;OP class abbreviations&lt;/a&gt;).</source>
          <target state="translated">山カッコの間の記号は、たとえばopのタイプを示します。&amp;lt;2&amp;gt;はBINOP、&amp;lt;@&amp;gt;はLISTOP、&amp;lt;＃&amp;gt;はスレッド化されたperlで使用されるPADOPです。（&lt;a href=&quot;#OP-class-abbreviations&quot;&gt;OPクラスの省略形を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2fa8c942f2b2a058230427b77fde679fbccbc45f" translate="yes" xml:space="preserve">
          <source>The symbol table for a package happens to be stored in the hash of that name with two colons appended. The main symbol table's name is thus &lt;code&gt;%main::&lt;/code&gt; , or &lt;code&gt;%::&lt;/code&gt; for short. Likewise the symbol table for the nested package mentioned earlier is named &lt;code&gt;%OUTER::INNER::&lt;/code&gt; .</source>
          <target state="translated">パッケージのシンボルテーブルは、たまたまその名前のハッシュに2つのコロンが追加されて格納されます。したがって、メインシンボルテーブルの名前は &lt;code&gt;%main::&lt;/code&gt; 、または &lt;code&gt;%::&lt;/code&gt; です。同様に、前述のネストされたパッケージのシンボルテーブルの名前は &lt;code&gt;%OUTER::INNER::&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d4d8237c3f2b5d66316d69a0012fa0f4c23704f9" translate="yes" xml:space="preserve">
          <source>The symbol table is filled with names looking like line-noise.</source>
          <target state="translated">シンボルテーブルには、ラインノイズのような名前が並んでいます。</target>
        </trans-unit>
        <trans-unit id="c5234fa33c4424920b3b6f455994e7727a2634e0" translate="yes" xml:space="preserve">
          <source>The symbols, ZIP_CM_STORE, ZIP_CM_DEFLATE, ZIP_CM_BZIP2 and ZIP_CM_LZMA are used to select the compression method.</source>
          <target state="translated">圧縮方式の選択には、ZIP_CM_STORE、ZIP_CM_DEFLATE、ZIP_CM_BZIP2、ZIP_CM_LZMAという記号を使用します。</target>
        </trans-unit>
        <trans-unit id="0e5ab20507b2337eca95f7b51820364382691825" translate="yes" xml:space="preserve">
          <source>The syntactic position falling between a method call and its arguments when using the indirect object invocation syntax. (The slot is distinguished by the absence of a comma between it and the next argument.) &lt;code&gt;STDERR&lt;/code&gt; is in the indirect object slot here:</source>
          <target state="translated">間接オブジェクト呼び出し構文を使用するときの構文位置は、メソッド呼び出しとその引数の間にあります。（スロットは、次の引数との間にコンマがないことで区別されます。） &lt;code&gt;STDERR&lt;/code&gt; は、ここの間接オブジェクトスロットにあります。</target>
        </trans-unit>
        <trans-unit id="f8f8b505ce05315e1a17e36787d4eec3e6ea7c76" translate="yes" xml:space="preserve">
          <source>The syntax</source>
          <target state="translated">構文は</target>
        </trans-unit>
        <trans-unit id="b260d025f9cb3da5ac539f033e81a2ed933eaba6" translate="yes" xml:space="preserve">
          <source>The syntax and behavior is similar to a &lt;code&gt;SKIP: BLOCK&lt;/code&gt; except the tests will be marked as failing but todo. &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret them as passing.</source>
          <target state="translated">構文と動作は &lt;code&gt;SKIP: BLOCK&lt;/code&gt; と似ていますが、テストが失敗したがtodoとしてマークされる点が異なります。&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt;はそれらを合格と解釈します。</target>
        </trans-unit>
        <trans-unit id="47cc68a8f32c23223d1563cd08d4fd0cd4cd2e20" translate="yes" xml:space="preserve">
          <source>The syntax for &lt;code&gt;skip&lt;/code&gt; is about the only way it can be, but it's still quite confusing. Just start with the above examples and you'll be okay.</source>
          <target state="translated">&lt;code&gt;skip&lt;/code&gt; の構文は、それが可能な唯一の方法ですが、それでもかなり混乱します。上記の例から始めるだけで大​​丈夫です。</target>
        </trans-unit>
        <trans-unit id="ad53e9b382fc96ff2b2e55cab8f01b18f6934cd1" translate="yes" xml:space="preserve">
          <source>The syntax for an Input FileGlob is identical to &lt;code&gt;File::Glob&lt;/code&gt; , except for the following</source>
          <target state="translated">入力FileGlobの構文は、以下を除いて &lt;code&gt;File::Glob&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="d238d90126a97e645c3d07a616c57a948aa56c49" translate="yes" xml:space="preserve">
          <source>The syntax for encoding text strings to binary strings is as simple as decoding:</source>
          <target state="translated">テキスト文字列をバイナリ文字列にエンコードする構文は、デコードと同じくらい簡単です。</target>
        </trans-unit>
        <trans-unit id="0de2770d6e55eee81f76094997c8b0b61106fb04" translate="yes" xml:space="preserve">
          <source>The syntax:</source>
          <target state="translated">構文です。</target>
        </trans-unit>
        <trans-unit id="a6f851731919e85a8b6dbd2464120f7f6baa4b5b" translate="yes" xml:space="preserve">
          <source>The system being designed is large, or is likely to become large.</source>
          <target state="translated">設計されているシステムが大きい、または大きくなる可能性が高い。</target>
        </trans-unit>
        <trans-unit id="a8562e11d0057f4470ed7be8cd68c00d5386166f" translate="yes" xml:space="preserve">
          <source>The system copy routine may also be called directly under VMS and OS/2 as &lt;code&gt;File::Copy::syscopy&lt;/code&gt; (or under VMS as &lt;code&gt;File::Copy::rmscopy&lt;/code&gt; , which is the routine that does the actual work for syscopy).</source>
          <target state="translated">システムコピールーチンは、VMSおよびOS / 2で &lt;code&gt;File::Copy::syscopy&lt;/code&gt; （またはVMSで &lt;code&gt;File::Copy::rmscopy&lt;/code&gt; として直接呼び出すこともできます。これは、syscopyの実際の作業を行うルーチンです）。</target>
        </trans-unit>
        <trans-unit id="3b60dcb15de0e9f8fb8f2aec0c96f53a958b30c3" translate="yes" xml:space="preserve">
          <source>The system design is already object-oriented.</source>
          <target state="translated">システム設計はすでにオブジェクト指向です。</target>
        </trans-unit>
        <trans-unit id="f2d2b02a34c5f3a2771d92387a8965fe957ed399" translate="yes" xml:space="preserve">
          <source>The system ignores the first line and feeds the program to</source>
          <target state="translated">システムは最初の行を無視して、プログラムを</target>
        </trans-unit>
        <trans-unit id="f1eb32227e059ade5c92f6015a4dd65ea3a6bc28" translate="yes" xml:space="preserve">
          <source>The system time is the amount of time the kernel itself spent executing routines, or system calls, on behalf of this process user.</source>
          <target state="translated">システム時間は、カーネル自身がこのプロセスユーザに代わってルーチンやシステムコールを実行するのに費やした時間です。</target>
        </trans-unit>
        <trans-unit id="831ee4615baf52dd07f0a014bffa561cd6b8234d" translate="yes" xml:space="preserve">
          <source>The system time of the null loop might be slightly more than the system time of the loop with the actual code and therefore the difference might end up being &amp;lt; 0.</source>
          <target state="translated">nullループのシステム時間は、実際のコードを使用したループのシステム時間よりもわずかに長くなる可能性があるため、最終的に差が0未満になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="5880c4b2f3b12a5f35ec0374b9437ee3cf2ad712" translate="yes" xml:space="preserve">
          <source>The system's notion of time of day and calendar date is controlled in widely different ways. Don't assume the timezone is stored in &lt;code&gt;$ENV{TZ}&lt;/code&gt; , and even if it is, don't assume that you can control the timezone through that variable. Don't assume anything about the three-letter timezone abbreviations (for example that MST would be the Mountain Standard Time, it's been known to stand for Moscow Standard Time). If you need to use timezones, express them in some unambiguous format like the exact number of minutes offset from UTC, or the POSIX timezone format.</source>
          <target state="translated">システムの時刻とカレンダー日付の概念は、さまざまな方法で制御されます。タイムゾーンが &lt;code&gt;$ENV{TZ}&lt;/code&gt; に格納されていると想定しないでください。そうであっても、その変数を介してタイムゾーンを制御できると想定しないでください。 3文字のタイムゾーンの省略形については何も想定しないでください（たとえば、MSTは山岳部標準時であり、モスクワ標準時を表すことが知られています）。タイムゾーンを使用する必要がある場合は、UTCからの正確な分単位のオフセット数やPOSIXタイムゾーン形式など、明確な形式で表現してください。</target>
        </trans-unit>
        <trans-unit id="10bc5e79cfd3d40c28f5293903b887866aeb92ec" translate="yes" xml:space="preserve">
          <source>The table below has two columns. The left column contains the &lt;code&gt;\p{}&lt;/code&gt; constructs to look up, possibly preceded by the flags mentioned above; and the right column contains information about them, like a description, or synonyms. The table shows both the single and compound forms for each property that has them. If the left column is a short name for a property, the right column will give its longer, more descriptive name; and if the left column is the longest name, the right column will show any equivalent shortest name, in both single and compound forms if applicable.</source>
          <target state="translated">以下の表には2つの列があります。左側の列には、検索する &lt;code&gt;\p{}&lt;/code&gt; 構成が含まれています。前に、おそらく上記のフラグが付いています。右側の列には、説明や同義語など、それらに関する情報が含まれています。次の表は、それらを含む各プロパティの単一フォームと複合フォームの両方を示しています。左側の列がプロパティの短い名前である場合、右側の列には、より長く、よりわかりやすい名前が付けられます。左側の列が最も長い名前である場合、右側の列には、該当する場合、単一形式と複合形式の両方で、同等の最も短い名前が表示されます。</target>
        </trans-unit>
        <trans-unit id="1666e90a958abe062ff0c13eedc4273819f1aea6" translate="yes" xml:space="preserve">
          <source>The table file should locate in the</source>
          <target state="translated">テーブルファイルは</target>
        </trans-unit>
        <trans-unit id="b1154d069cc05928d8b59c50b5730e339b959183" translate="yes" xml:space="preserve">
          <source>The table of methods for all operations is cached in magic for the symbol table hash for the package. The cache is invalidated during processing of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; overload&lt;/code&gt; , new function definitions, and changes in @ISA.</source>
          <target state="translated">すべての操作のメソッドのテーブルは、パッケージのシンボルテーブルハッシュ用にマジックでキャッシュされます。キャッシュは、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; overload&lt;/code&gt; 、新しい関数定義、および@ISAでの変更の処理中に無効になります。</target>
        </trans-unit>
        <trans-unit id="b36cd501ad88aba2f3b3a0d1d67027c7a1e869d6" translate="yes" xml:space="preserve">
          <source>The table of smartmatches in &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;Smartmatch Operator in perlop&lt;/a&gt; is not identical to that proposed by the Perl 6 specification, mainly due to differences between Perl 6's and Perl 5's data models, but also because the Perl 6 spec has changed since Perl 5 rushed into early adoption.</source>
          <target state="translated">&lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;perlopのSmartmatch Operator&lt;/a&gt;のsmartmatchesのテーブルは、Perl 6とPerl 5のデータモデルの違いが主な理由で、Perl 6仕様で提案されたものと同じではありませんが、Perl 5が早期に採用されてからPerl 6仕様が変更されたためです。</target>
        </trans-unit>
        <trans-unit id="94ad06074e14c7f30c5f734701604346041b5cbc" translate="yes" xml:space="preserve">
          <source>The tangent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9125938896cf0c452742065869d161bf7df834a0" translate="yes" xml:space="preserve">
          <source>The tarball can be created as follows:</source>
          <target state="translated">タールボールは以下のように作成することができます。</target>
        </trans-unit>
        <trans-unit id="b87ef1c14b4fb669d5f4570a38dcf5e22aa3e1b3" translate="yes" xml:space="preserve">
          <source>The target is to make OS/2 one of the best supported platform for using/building/developing Perl and</source>
          <target state="translated">目標は、OS/2をPerlの使用/構築/開発のための最高のサポートプラットフォームにすることです。</target>
        </trans-unit>
        <trans-unit id="f704785556fc74856ecd269c550a540acda7d08d" translate="yes" xml:space="preserve">
          <source>The target of the OP, or nothing for a nulled OP.</source>
          <target state="translated">ヌルいOPにしてはOPの対象でも何でもない。</target>
        </trans-unit>
        <trans-unit id="d551cba509e623574e29a4be73bb109e3d69062b" translate="yes" xml:space="preserve">
          <source>The template can take a different set of rules per key that is used.</source>
          <target state="translated">テンプレートは、使用するキーごとに異なるルールのセットを取ることができます。</target>
        </trans-unit>
        <trans-unit id="56fadcfb4c1428b721edcda3a997763e93a92ef4" translate="yes" xml:space="preserve">
          <source>The template may be any filename with some number of X's appended to it, for example F. The trailing X's are replaced with unique alphanumeric combinations.</source>
          <target state="translated">テンプレートは、例えばFのようにいくつかの数個のXが付加されたファイル名であっても構いません。</target>
        </trans-unit>
        <trans-unit id="527fc2a5f793bc1d57c90fcfdd90ce2b38cfafb9" translate="yes" xml:space="preserve">
          <source>The term &quot;native&quot; does not mean quite as much when we talk about native integers, as it does when native floating point numbers are involved. The only implication of the term &quot;native&quot; on integers is that the limits for the maximal and the minimal supported true integral quantities are close to powers of 2. However, &quot;native&quot; floats have a most fundamental restriction: they may represent only those numbers which have a relatively &quot;short&quot; representation when converted to a binary fraction. For example, 0.9 cannot be represented by a native float, since the binary fraction for 0.9 is infinite:</source>
          <target state="translated">ネイティブ」という言葉は、ネイティブな整数について話すときにはあまり意味がありませんが、ネイティブな浮動小数点数が関係しているときにはあまり意味がありません。整数に対する「ネイティブ」という言葉の意味は、サポートされる真の積分量の最大値と最小値の限界が2の累乗に近いということだけです。 しかし、「ネイティブ」フロートには最も基本的な制限があります。それは、2進数に変換されたときに比較的「短い」表現を持つ数だけを表現できるということです。例えば、0.9の2進分数は無限大なので、0.9はネイティブフロートでは表現できません。</target>
        </trans-unit>
        <trans-unit id="60065770d703c59b1d8e19903d480a6c8c3d4ce7" translate="yes" xml:space="preserve">
          <source>The term &quot;railroad normal form&quot; is a bit esoteric, with &quot;syntax diagram/charts&quot;, or &quot;railroad diagram/charts&quot; being more common terms. Nevertheless it provides a useful mental image of a regex program: each node can be thought of as a unit of track, with a single entry and in most cases a single exit point (there are pieces of track that fork, but statistically not many), and the whole forms a layout with a single entry and single exit point. The matching process can be thought of as a car that moves along the track, with the particular route through the system being determined by the character read at each possible connector point. A car can fall off the track at any point but it may only proceed as long as it matches the track.</source>
          <target state="translated">鉄道の通常の形式」という用語は少し難解で、「構文図/チャート」や「鉄道の図/チャート」の方が一般的な用語です。各ノードは軌道の単位として考えることができ、ほとんどの場合、単一の入口と単一の出口を持ちます(分岐する軌道はありますが、統計的には多くはありません)。マッチングプロセスは、トラックに沿って移動する車両と考えることができ、システムを通る特定のルートは、各可能なコネクタポイントで読み取られた文字によって決定されます。車はどの時点でもトラックから落ちることができますが、トラックと一致している間だけ進むことができます。</target>
        </trans-unit>
        <trans-unit id="cb8cf5974b1ed2433ffc34db8b95199dcc132ecd" translate="yes" xml:space="preserve">
          <source>The term 'mathemagic' describes the overloaded implementation of mathematical operators. Mathemagical operations raise an issue. Consider the code:</source>
          <target state="translated">マテマジック」という用語は、数学演算子の過負荷な実装を説明しています。数学的演算子は問題を提起します。コードを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="eaeae7045f589906beb0ab8c4692ec54095f2a80" translate="yes" xml:space="preserve">
          <source>The term, &quot;Unicode bug&quot; has been applied to an inconsistency with the code points in the &lt;code&gt;Latin-1 Supplement&lt;/code&gt; block, that is, between 128 and 255. Without a locale specified, unlike all other characters or code points, these characters can have very different semantics depending on the rules in effect. (Characters whose code points are above 255 force Unicode rules; whereas the rules for ASCII characters are the same under both ASCII and Unicode rules.)</source>
          <target state="translated">「Unicodeバグ」という用語は、 &lt;code&gt;Latin-1 Supplement&lt;/code&gt; ブロックのコードポイントとの不整合、つまり128〜255に適用されています。ロケールを指定しないと、他のすべての文字やコードポイントとは異なり、これらの文字は有効な規則に応じて、非常に異なるセマンティクス。（コードポイントが255を超える文字はUnicodeルールを強制しますが、ASCII文字のルールはASCIIルールとUnicodeルールの両方で同じです。）</target>
        </trans-unit>
        <trans-unit id="694ad9d197b3bccc91651d679f02271b6dd9c6f8" translate="yes" xml:space="preserve">
          <source>The terminal output bit rate (often mistakenly called the baud rate) for this terminal - if not set a warning will be generated and it will be defaulted to 9600.</source>
          <target state="translated">このターミナルの出力ビットレート(ボーレートと誤って呼ばれることもあります)-設定されていない場合は警告が発生し、デフォルトは 9600 になります。</target>
        </trans-unit>
        <trans-unit id="45cdb3e3cad66807c8dfdf23c9cff4fc7bd36017" translate="yes" xml:space="preserve">
          <source>The terminal type whose termcap entry will be used - if not supplied it will default to $ENV{TERM}: if that is not set then &lt;b&gt;Tgetent&lt;/b&gt; will croak.</source>
          <target state="translated">termcapエントリが使用される端末タイプ-提供されない場合、デフォルトで$ ENV {TERM}になります。それが設定されていない場合、&lt;b&gt;Tgetent&lt;/b&gt;は&lt;b&gt;クロークし&lt;/b&gt;ます。</target>
        </trans-unit>
        <trans-unit id="a8d5f39cee7740c7c53d20d14cbf1ad8092c45e0" translate="yes" xml:space="preserve">
          <source>The terminating string may be either an identifier (a word), or some quoted text. An unquoted identifier works like double quotes. There may not be a space between the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and the identifier, unless the identifier is explicitly quoted. (If you put a space it will be treated as a null identifier, which is valid, and matches the first empty line.) The terminating string must appear by itself (unquoted and with no surrounding whitespace) on the terminating line.</source>
          <target state="translated">終了文字列は、識別子（単語）または引用符付きテキストのいずれかです。引用符で囲まれていない識別子は、二重引用符のように機能します。識別子が明示的に引用されていない限り、 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; と識別子の間にスペースがない場合があります。（スペースを入れると、それは有効なヌルIDとして扱われ、最初の空行と一致します。）終了ストリングは、終了行に単独で（引用符で囲まず、周囲に空白を入れずに）出現する必要があります。</target>
        </trans-unit>
        <trans-unit id="693f7bb103883c0a728e204ee6c0e2c1249be088" translate="yes" xml:space="preserve">
          <source>The terminator of runtime &lt;code&gt;(?{...})&lt;/code&gt; is found by temporarily switching control to the perl parser, which should stop at the point where the logically balancing terminating &lt;code&gt;}&lt;/code&gt; is found.</source>
          <target state="translated">ランタイムのターミネータ &lt;code&gt;(?{...})&lt;/code&gt; は、制御をperlパーサーに一時的に切り替えることによって検出されます。これは、論理的にバランスをとる終端 &lt;code&gt;}&lt;/code&gt; が見つかった時点で停止する必要があります。</target>
        </trans-unit>
        <trans-unit id="45074fa74bab84b7b8642e2f2cccf8a44bd5974b" translate="yes" xml:space="preserve">
          <source>The test</source>
          <target state="translated">テスト</target>
        </trans-unit>
        <trans-unit id="404700fb40de228f041c8b476423971728a238e9" translate="yes" xml:space="preserve">
          <source>The test harness leaves much to be desired. Patches welcome.</source>
          <target state="translated">ハーネスのテストは 望ましくない パッチを歓迎する</target>
        </trans-unit>
        <trans-unit id="a5f877c1b13f5bd28ecef34f68e2dcb7eb31de7b" translate="yes" xml:space="preserve">
          <source>The test name extensions. Defaults to &lt;code&gt;.t&lt;/code&gt;.</source>
          <target state="translated">テスト名の拡張子。デフォルトは &lt;code&gt;.t&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="18b17a09a74e93fa5e780df81bc80e5b90469686" translate="yes" xml:space="preserve">
          <source>The test suite is much better, but always needs improvement.</source>
          <target state="translated">テストスイートははるかに良くなっていますが、常に改善が必要です。</target>
        </trans-unit>
        <trans-unit id="710c520b5e701804e8b8991b8c559c8c70f62fc8" translate="yes" xml:space="preserve">
          <source>The test will exit with 255.</source>
          <target state="translated">テストは255で終了します。</target>
        </trans-unit>
        <trans-unit id="adc50b89ec0ba50b71ee74cf410505fc2fa0bc3e" translate="yes" xml:space="preserve">
          <source>The testing system is designed to be used by performing a three step process for each test you wish to test. This process starts with using &lt;code&gt;test_out&lt;/code&gt; and &lt;code&gt;test_err&lt;/code&gt; in advance to declare what the testsuite you are testing will output with &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; to stdout and stderr.</source>
          <target state="translated">テストシステムは、テストする各テストに対して3つのステッププロセスを実行することによって使用されるように設計されています。このプロセスは、事前に &lt;code&gt;test_out&lt;/code&gt; および &lt;code&gt;test_err&lt;/code&gt; を使用して、テストしているテストスイートが&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;でstdoutおよびstderrに出力する内容を宣言することから始まります。</target>
        </trans-unit>
        <trans-unit id="e7d3c8b5f530bcb2e21b05b385528e49c2684bd6" translate="yes" xml:space="preserve">
          <source>The tests</source>
          <target state="translated">テスト</target>
        </trans-unit>
        <trans-unit id="a22b8fe6a3e6e46d5dd177a5cb8828e7b0955e47" translate="yes" xml:space="preserve">
          <source>The tests &lt;code&gt;-b&lt;/code&gt; , &lt;code&gt;-B&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; , &lt;code&gt;-e&lt;/code&gt; , &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-S&lt;/code&gt; , &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; , and &lt;code&gt;-z&lt;/code&gt; work as advertised. The return values for &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; tell you whether you can actually access the file; this may not reflect the UIC-based file protections. Since real and effective UIC don't differ under VMS, &lt;code&gt;-O&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; are equivalent to &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; . Similarly, several other tests, including &lt;code&gt;-A&lt;/code&gt; , &lt;code&gt;-g&lt;/code&gt; , &lt;code&gt;-k&lt;/code&gt; , &lt;code&gt;-l&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; , and &lt;code&gt;-u&lt;/code&gt; , aren't particularly meaningful under VMS, and the values returned by these tests reflect whatever your CRTL &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; routine does to the equivalent bits in the st_mode field. Finally, &lt;code&gt;-d&lt;/code&gt; returns true if passed a device specification without an explicit directory (e.g. &lt;code&gt;DUA1:&lt;/code&gt; ), as well as if passed a directory.</source>
          <target state="translated">テスト &lt;code&gt;-b&lt;/code&gt; 、 &lt;code&gt;-B&lt;/code&gt; 、 &lt;code&gt;-c&lt;/code&gt; 、 &lt;code&gt;-C&lt;/code&gt; 、 &lt;code&gt;-d&lt;/code&gt; 、 &lt;code&gt;-e&lt;/code&gt; 、 &lt;code&gt;-f&lt;/code&gt; 、 &lt;code&gt;-o&lt;/code&gt; 、 &lt;code&gt;-M&lt;/code&gt; 、 &lt;code&gt;-s&lt;/code&gt; 、 &lt;code&gt;-S&lt;/code&gt; 、 &lt;code&gt;-t&lt;/code&gt; 、 &lt;code&gt;-T&lt;/code&gt; 、および &lt;code&gt;-z&lt;/code&gt; は、宣伝どおりに機能します。 &lt;code&gt;-r&lt;/code&gt; 、 &lt;code&gt;-w&lt;/code&gt; 、および &lt;code&gt;-x&lt;/code&gt; の戻り値は、実際にファイルにアクセスできるかどうかを示します。これは、UICベースのファイル保護を反映していない場合があります。実際の効果的なUICはVMSでも同じなので、 &lt;code&gt;-O&lt;/code&gt; 、 &lt;code&gt;-R&lt;/code&gt; 、 &lt;code&gt;-W&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;-o&lt;/code&gt; 、 &lt;code&gt;-r&lt;/code&gt; 、 &lt;code&gt;-w&lt;/code&gt; 、および &lt;code&gt;-x&lt;/code&gt; と同等です。同様に、 &lt;code&gt;-A&lt;/code&gt; 、 &lt;code&gt;-g&lt;/code&gt; 、 &lt;code&gt;-k&lt;/code&gt; 、 &lt;code&gt;-l&lt;/code&gt; 、 &lt;code&gt;-p&lt;/code&gt; 、および &lt;code&gt;-u&lt;/code&gt; を含む他のいくつかのテストは、VMSでは特に意味がなく、これらのテストによって返される値は、CRTL &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; ルーチンが行うことをすべて反映していますst_modeフィールドの同等のビットに。最後に、明示的なディレクトリ（ &lt;code&gt;DUA1:&lt;/code&gt; など）なしでデバイス仕様を渡した場合、およびディレクトリを渡した場合、 &lt;code&gt;-d&lt;/code&gt; はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="4fe750878672d4fb196503a672d7f5b98d0e668b" translate="yes" xml:space="preserve">
          <source>The text &quot;Object Attributes&quot; comprises the heading there. The text in these heading commands can use formatting codes, as seen here:</source>
          <target state="translated">オブジェクトの属性」というテキストが見出しを構成しています。これらの見出しコマンドのテキストは、ここで見られるように、フォーマットコードを使用することができます。</target>
        </trans-unit>
        <trans-unit id="422420f7789cdb6ab09e238f60941fefea41ab12" translate="yes" xml:space="preserve">
          <source>The text matched by the last bracket of the last successful search pattern. This is useful if you don't know which one of a set of alternative patterns matched. For example:</source>
          <target state="translated">最後に成功した検索パターンの最後の括弧でマッチしたテキスト。これは、一連の代替パターンの中でどれがマッチしたかわからない場合に便利です。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="8d5e558c4e38b1badcb4cca2c007e3208f52adfb" translate="yes" xml:space="preserve">
          <source>The text matched by the used group most-recently closed (i.e. the group with the rightmost closing parenthesis) of the last successful search pattern.</source>
          <target state="translated">最後に成功した検索パターンの最も最近閉じられたグループ(つまり、右端の括弧が閉じられたグループ)が使用したグループでマッチしたテキスト。</target>
        </trans-unit>
        <trans-unit id="c1c9727d8e424808f3451a4472d65a7ff102f563" translate="yes" xml:space="preserve">
          <source>The text of a message to print immediately prior to printing the program's usage message.</source>
          <target state="translated">プログラムの使用メッセージを印刷する直前に印刷するメッセージのテキスト。</target>
        </trans-unit>
        <trans-unit id="2808389282f74befb5070bb0b9545514e48a6905" translate="yes" xml:space="preserve">
          <source>The text of the Makefile is run through this method before writing to disk. It allows systems a chance to make portability fixes to the Makefile.</source>
          <target state="translated">Makefile のテキストは、ディスクに書き込む前にこの方法で実行されます。これにより、システムが Makefile に移植性のある修正を加えることができます。</target>
        </trans-unit>
        <trans-unit id="4abae05debe0661c57f27b361d90da4ccea7c4db" translate="yes" xml:space="preserve">
          <source>The text/binary issue is covered at length in the Cygwin documentation.</source>
          <target state="translated">テキスト/バイナリの問題は、Cygwinのドキュメントで詳しく説明されています。</target>
        </trans-unit>
        <trans-unit id="3155c02df4aea0a613a1c72b2a9ac5c7a7efff80" translate="yes" xml:space="preserve">
          <source>The thetas, phis, direction, and distance in the above are all in radians.</source>
          <target state="translated">上記のθ、Phis、方向、距離は全てラジアン単位である。</target>
        </trans-unit>
        <trans-unit id="b1d631fb3ea4c05afea84d61f3fa4b47ab2ddcf3" translate="yes" xml:space="preserve">
          <source>The thing you&amp;rsquo;re working on. Structures like &lt;code&gt;&lt;a href=&quot;functions/while&quot;&gt;while(&amp;lt;&amp;gt;)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , and &lt;code&gt;given&lt;/code&gt; set the topic for you by assigning to &lt;code&gt;$_&lt;/code&gt; , the default (</source>
          <target state="translated">あなたが取り組んでいること。 &lt;code&gt;&lt;a href=&quot;functions/while&quot;&gt;while(&amp;lt;&amp;gt;)&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;for&lt;/code&gt; 、 &lt;code&gt;foreach&lt;/code&gt; 、および &lt;code&gt;given&lt;/code&gt; set などの構造は、デフォルトの &lt;code&gt;$_&lt;/code&gt; に割り当てることでトピックを設定します（</target>
        </trans-unit>
        <trans-unit id="d7aa255f6bad43d19c5308997ee1af4d4b4ab78c" translate="yes" xml:space="preserve">
          <source>The third argument ($binmode) will select binary mode if passed as a TRUE value. In binary mode &quot;\n&quot; will be encoded in the same way as any other non-printable character. This ensures that a decoder will end up with exactly the same string whatever line ending sequence it uses. In general it is preferable to use the base64 encoding for binary data; see &lt;a href=&quot;base64&quot;&gt;MIME::Base64&lt;/a&gt;.</source>
          <target state="translated">3番目の引数（$ binmode）は、TRUE値として渡された場合にバイナリモードを選択します。バイナリモードでは、「\ n」は他の印刷できない文字と同じ方法でエンコードされます。これにより、デコーダーは、使用する行末シーケンスに関係なく、まったく同じ文字列で終了します。一般に、バイナリデータにはbase64エンコーディングを使用することをお勧めします。&lt;a href=&quot;base64&quot;&gt;MIME :: Base64を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="402137bf9c592f0ce8adeea3685dbc19201507dd" translate="yes" xml:space="preserve">
          <source>The third argument can be a hash reference with options. Note that all options are case-sensitive.</source>
          <target state="translated">3 番目の引数には、オプションを含むハッシュ参照を指定することができます。すべてのオプションは大文字と小文字を区別することに注意してください。</target>
        </trans-unit>
        <trans-unit id="d09df4868eb6859f97bcec11bc2fb80a75d17197" translate="yes" xml:space="preserve">
          <source>The third argument is an optional prefix. All files will be tucked away in the directory you specify as prefix. So if you have files 'a' and 'b' in your archive, and you specify 'foo' as prefix, they will be written to the archive as 'foo/a' and 'foo/b'.</source>
          <target state="translated">3番目の引数はオプションのprefixです。すべてのファイルは、プレフィックスとして指定したディレクトリに格納されます。つまり、アーカイブの中に 'a' と 'b' というファイルがあって、プレフィックスに 'foo' を指定した場合は、アーカイブには 'foo/a' と 'foo/b' という名前で書き込まれます。</target>
        </trans-unit>
        <trans-unit id="f4fe54f58bf6b8a68158e2a28b4c6c3ebee0bf58" translate="yes" xml:space="preserve">
          <source>The third argument is set to TRUE if (and only if) the two operands have been swapped. Perl may do this to ensure that the first argument (&lt;code&gt;$self&lt;/code&gt; ) is an object implementing the overloaded operation, in line with general object calling conventions. For example, if &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are &lt;code&gt;Number&lt;/code&gt; s:</source>
          <target state="translated">3番目の引数は、2つのオペランドが入れ替えられた場合（かつその場合のみ）にTRUEに設定されます。 Perlはこれを行って、最初の引数（ &lt;code&gt;$self&lt;/code&gt; ）が、一般的なオブジェクト呼び出し規約に従って、オーバーロードされた操作を実装するオブジェクトであることを確認します。たとえば、 &lt;code&gt;$x&lt;/code&gt; と &lt;code&gt;$y&lt;/code&gt; が &lt;code&gt;Number&lt;/code&gt; の場合：</target>
        </trans-unit>
        <trans-unit id="b6927ece55a1584561056753f900c2e3751385e3" translate="yes" xml:space="preserve">
          <source>The third form of character class you can use in Perl regular expressions is the bracketed character class. In its simplest form, it lists the characters that may be matched, surrounded by square brackets, like this: &lt;code&gt;[aeiou]&lt;/code&gt; . This matches one of &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; or &lt;code&gt;u&lt;/code&gt; . Like the other character classes, exactly one character is matched.* To match a longer string consisting of characters mentioned in the character class, follow the character class with a &lt;a href=&quot;perlre#Quantifiers&quot;&gt;quantifier&lt;/a&gt;. For instance, &lt;code&gt;[aeiou]+&lt;/code&gt; matches one or more lowercase English vowels.</source>
          <target state="translated">Perl正規表現で使用できる文字クラスの3番目の形式は、括弧で囲まれた文字クラスです。最も単純な形式では、 &lt;code&gt;[aeiou]&lt;/code&gt; のように、角括弧で囲まれた、一致する可能性のある文字がリストされます。これは &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;e&lt;/code&gt; 、 &lt;code&gt;i&lt;/code&gt; 、 &lt;code&gt;o&lt;/code&gt; 、 &lt;code&gt;u&lt;/code&gt; のいずれかに一致します。他の文字クラスと同様に、厳密に1文字が一致します。*文字クラスで言及されている文字で構成される長い文字列を一致させるには、文字クラスの後に&lt;a href=&quot;perlre#Quantifiers&quot;&gt;数量詞を付け&lt;/a&gt;ます。たとえば、 &lt;code&gt;[aeiou]+&lt;/code&gt; は、 1つ以上の小文字の英語の母音に一致します。</target>
        </trans-unit>
        <trans-unit id="98c965cda02550e370a5b37b87d94e4f8f16189d" translate="yes" xml:space="preserve">
          <source>The third option is to work around the problem by disabling the DB_File completely when build Perl by specifying -Ui_db to Configure, and then using the BerkeleyDB module from CPAN instead of DB_File. The BerkeleyDB works with Berkeley DB versions 2.* or greater.</source>
          <target state="translated">3つ目のオプションは、Perlのビルド時に-Ui_dbをConfigureに指定してDB_Fileを完全に無効にし、DB_Fileの代わりにCPANのBerkeleyDBモジュールを使用することで問題を回避する方法です。BerkeleyDBはBerkeley DBのバージョン2.*以上で動作します。</target>
        </trans-unit>
        <trans-unit id="06ac2659f5a86781c045ab0079857269ceabc456" translate="yes" xml:space="preserve">
          <source>The third parameter is an integer flag, which tells &lt;code&gt;rmscopy&lt;/code&gt; how to handle timestamps. If it is &amp;lt; 0, none of the input file's timestamps are propagated to the output file. If it is &amp;gt; 0, then it is interpreted as a bitmask: if bit 0 (the LSB) is set, then timestamps other than the revision date are propagated; if bit 1 is set, the revision date is propagated. If the third parameter to &lt;code&gt;rmscopy&lt;/code&gt; is 0, then it behaves much like the DCL COPY command: if the name or type of the output file was explicitly specified, then no timestamps are propagated, but if they were taken implicitly from the input filespec, then all timestamps other than the revision date are propagated. If this parameter is not supplied, it defaults to 0.</source>
          <target state="translated">3番目のパラメーターは整数フラグで、 &lt;code&gt;rmscopy&lt;/code&gt; にタイムスタンプの処理方法を指示します。 0未満の場合、入力ファイルのタイムスタンプは出力ファイルに伝播されません。 0より大きい場合は、ビットマスクとして解釈されます。ビット0（LSB）が設定されている場合、改訂日以外のタイムスタンプが伝達されます。ビット1が設定されている場合、改訂日が伝搬されます。 &lt;code&gt;rmscopy&lt;/code&gt; の3番目のパラメーターが0の場合、DCL COPYコマンドのように動作します。出力ファイルの名前またはタイプが明示的に指定されている場合、タイムスタンプは伝達されませんが、入力ファイル仕様から暗黙的に取得された場合、改訂日以外のすべてのタイムスタンプが伝達されます。このパラメーターを指定しない場合、デフォルトで0になります。</target>
        </trans-unit>
        <trans-unit id="65eff2bc7c7605d4f858e4809838a551a55b2c9c" translate="yes" xml:space="preserve">
          <source>The third parameter of &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; determines whether AUTOLOAD lookup is performed if the given method is not present: non-zero means yes, look for AUTOLOAD; zero means no, don't look for AUTOLOAD. Calling &lt;code&gt;gv_fetchmethod&lt;/code&gt; is equivalent to calling &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; with a non-zero &lt;code&gt;autoload&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; の3番目のパラメーターは、指定されたメソッドが存在しない場合にAUTOLOADルックアップが実行されるかどうかを決定します。ゼロ以外は、はい、AUTOLOADを探すことを意味します。ゼロは、いいえ、AUTOLOADを検索しないことを意味します。呼び出し &lt;code&gt;gv_fetchmethod&lt;/code&gt; は呼び出すことと同じです &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; をゼロ以外で &lt;code&gt;autoload&lt;/code&gt; パラメータ。</target>
        </trans-unit>
        <trans-unit id="04bad251a051beab258a1b64e282a2e8539b9769" translate="yes" xml:space="preserve">
          <source>The third, even more efficient way is to ape how it is done within the Perl guts:</source>
          <target state="translated">3つ目の、さらに効率的な方法は、Perlのガッツの中でどのように行われているかを真似ることです。</target>
        </trans-unit>
        <trans-unit id="79c45ac3b3a9de2cee8656fb9dfb3aeb3d0a968d" translate="yes" xml:space="preserve">
          <source>The threaded Perl build works also on AIX 5.1 but the IBM Perl build (Perl v5.6.0) is not threaded on AIX 5.1.</source>
          <target state="translated">スレッドされたPerlビルドはAIX 5.1でも動作しますが、IBMのPerlビルド(Perl v5.6.0)はAIX 5.1ではスレッド化されていません。</target>
        </trans-unit>
        <trans-unit id="5c1bbb696ed6ae965a0f7d9f707a450102369948" translate="yes" xml:space="preserve">
          <source>The three dotted bitwise assignment operators (&lt;code&gt;&amp;amp;.=&lt;/code&gt;&lt;code&gt;|.=&lt;/code&gt;&lt;code&gt;^.=&lt;/code&gt; ) are new in Perl 5.22 and experimental. See &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;.</source>
          <target state="translated">3つのドット付きビット単位の代入演算子（ &lt;code&gt;&amp;amp;.=&lt;/code&gt; &lt;code&gt;|.=&lt;/code&gt; &lt;code&gt;^.=&lt;/code&gt; ）は、Perl 5.22の新機能であり、実験的です。&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operatorsを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="608f375aebf252abe9239c4f7b8a529aa2fe8363" translate="yes" xml:space="preserve">
          <source>The three features of key hashes,</source>
          <target state="translated">キーハッシュの3つの特徴</target>
        </trans-unit>
        <trans-unit id="062af9abb2e5d348e479446852d7c0c45c4b3f85" translate="yes" xml:space="preserve">
          <source>The three invocations of the subroutine all operate in sync. The semaphore, though, makes sure that only one thread is accessing the global variable at once.</source>
          <target state="translated">サブルーチンの3つの呼び出しはすべて同期して動作します。しかし、セマフォは1つのスレッドだけが一度にグローバル変数にアクセスするようにしています。</target>
        </trans-unit>
        <trans-unit id="c211076f27a370be0b7366cd2b652219b05d68b1" translate="yes" xml:space="preserve">
          <source>The three predefined variables $DB_HASH, $DB_BTREE and $DB_RECNO are usually adequate for most applications. If you do need to create extra instances of these objects, constructors are available for each file type.</source>
          <target state="translated">3 つの定義済み変数 $DB_HASH、$DB_BTREE および $DB_RECNO は、通常、ほとんどのアプリケーションでは十分です。これらのオブジェクトのインスタンスを追加で作成する必要がある場合は、ファイルタイプごとにコンストラクタが用意されています。</target>
        </trans-unit>
        <trans-unit id="e9c27515a2acd2e5fb4a7aba2f69ec1143808efd" translate="yes" xml:space="preserve">
          <source>The three principal virtues of a programmer are Laziness, Impatience, and Hubris. See the Camel Book for why.</source>
          <target state="translated">プログラマーの三大美徳は「怠惰」「焦り」「傲慢」です。その理由については、キャメルブックを参照してください。</target>
        </trans-unit>
        <trans-unit id="8d0972bf14f371a7ca1ef1bcaa261257cc368602" translate="yes" xml:space="preserve">
          <source>The three variables, api_revision, api_version, and api_subversion, specify the version of the oldest perl binary compatible with the present perl. In a full version string such as</source>
          <target state="translated">api_revision、api_version、api_subversionの3つの変数で、現在のperlと互換性のある最も古いperlバイナリのバージョンを指定します。のようなフルバージョン文字列では</target>
        </trans-unit>
        <trans-unit id="5f7adaa1232b94661eb586ac3b6e3dfed3cf89b3" translate="yes" xml:space="preserve">
          <source>The three warnings functions, &lt;code&gt;warnings::warn&lt;/code&gt; , &lt;code&gt;warnings::warnif&lt;/code&gt; and &lt;code&gt;warnings::enabled&lt;/code&gt; can optionally take an object reference in place of a category name. In this case the functions will use the class name of the object as the warnings category.</source>
          <target state="translated">3つの警告関数、 &lt;code&gt;warnings::warn&lt;/code&gt; 、 &lt;code&gt;warnings::warnif&lt;/code&gt; 、および &lt;code&gt;warnings::enabled&lt;/code&gt; は、オプションで、カテゴリ名の代わりにオブジェクト参照を使用できます。この場合、関数はオブジェクトのクラス名を警告カテゴリとして使用します。</target>
        </trans-unit>
        <trans-unit id="330a38aeb545f580c0244d785039ed36ba36d545" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2fTicket%2fDisplay.html%3fid%3d121481&quot;&gt;[perl #121481]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2fTicket%2fDisplay.html%3fid%3d121481&quot;&gt;[perl＃121481]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="b68d73ad1b59ae384323f9df247206460ebd3566" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d116487&quot;&gt;[perl #116487]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d116487&quot;&gt;[perl＃116487]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="b8045076fdd60e6523f73b7c70511783c44a65e4" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119313&quot;&gt;[perl #119313]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119313&quot;&gt;[perl＃119313]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="1a16744b674df3a293c07c2c144ffeafe30d93a5" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119315&quot;&gt;[perl #119315]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119315&quot;&gt;[perl＃119315]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="ed1860908f3e196b681653f0d3c4015121aac114" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119317&quot;&gt;[perl #119317]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119317&quot;&gt;[perl＃119317]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="c89e9b1dbbb9968b38d0d3719212d5f4f930d48c" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119437&quot;&gt;[perl #119437]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119437&quot;&gt;[perl＃119437]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="4a1e967726ae4e6415ad56477887e8f2fd56977f" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119451&quot;&gt;[perl #119451]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119451&quot;&gt;[perl＃119451]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f14154eef095f6d5ad9ed12b7ee560090c8240df" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119453&quot;&gt;[perl #119453]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119453&quot;&gt;[perl＃119453]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="1140c9b87fc789061a9c67b7de5921f54ea0a0a7" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119455&quot;&gt;[perl #119455]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119455&quot;&gt;[perl＃119455]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f6f307da7b6aa442d7423ca357f21550160d4bb6" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d120085&quot;&gt;[perl #120085]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d120085&quot;&gt;[perl＃120085]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="2b73333a2d87bb4bdcdf8360f5d380f719aac7b6" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d122947&quot;&gt;[perl #122947]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d122947&quot;&gt;[perl＃122947]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="25b9d0a99bd226d2ae0ff1a2acdc8ae410a969ec" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123630&quot;&gt;[perl #123630]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123630&quot;&gt;[perl＃123630]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="0769a8451d93e389be7960f58724061e03726c33" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123707&quot;&gt;[perl #123707]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123707&quot;&gt;[perl＃123707]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="4152408e418529cff3fa9a89a90fa02a4c71e407" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%3a443%2frt3%2fTicket%2fDisplay.html%3fid%3d120162&quot;&gt;[perl #120162]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%3a443%2frt3%2fTicket%2fDisplay.html%3fid%3d120162&quot;&gt;[perl＃120162]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="896c7c2fe4064687353e3dfbb412d579a6d56aea" translate="yes" xml:space="preserve">
          <source>The tie() function binds a variable to a class (package) that will provide the implementation for access methods for that variable. Once this magic has been performed, accessing a tied variable automatically triggers method calls in the proper class. The complexity of the class is hidden behind magic methods calls. The method names are in ALL CAPS, which is a convention that Perl uses to indicate that they're called implicitly rather than explicitly--just like the BEGIN() and END() functions.</source>
          <target state="translated">tie()関数は、変数をクラス (パッケージ)にバインドし、その変数のアクセスメソッドの実装を提供します。このマジックが実行されると、結び付けられた変数にアクセスすると、自動的に適切なクラスのメソッド呼び出しがトリガーされます。クラスの複雑さは、魔法のメソッド呼び出しの背後に隠されています。これは Perl が明示的にではなく暗黙的に呼び出されることを示すために使用する慣習です。</target>
        </trans-unit>
        <trans-unit id="2ae79bd4ddb1c94445f10f56348d3008d5501006" translate="yes" xml:space="preserve">
          <source>The time at which the program began running, in seconds since the epoch (beginning of 1970). The values returned by the &lt;b&gt;-M&lt;/b&gt;, &lt;b&gt;-A&lt;/b&gt;, and &lt;b&gt;-C&lt;/b&gt; filetests are based on this value.</source>
          <target state="translated">エポック（1970年の初め）からの秒単位での、プログラムの実行が開始された時刻。&lt;b&gt;-M&lt;/b&gt;、&lt;b&gt;-A&lt;/b&gt;、および&lt;b&gt;-C&lt;/b&gt;ファイルテストによって返される値は、この値に基づいています。</target>
        </trans-unit>
        <trans-unit id="850e579e5bd369cd341c43e0bd12ab77ec41d87f" translate="yes" xml:space="preserve">
          <source>The time has been cut in half, which is a respectable speed improvement by any standard. Naturally, it is important to check the output is consistent with the first program run, this is where the Unix system &lt;code&gt;cksum&lt;/code&gt; utility comes in.</source>
          <target state="translated">時間は半分に短縮されました。これは、どの基準でもかなりの速度向上です。当然、出力が最初のプログラム実行と一致していることを確認することが重要です。これが、Unixシステムの &lt;code&gt;cksum&lt;/code&gt; ユーティリティの出番です。</target>
        </trans-unit>
        <trans-unit id="b516aafa3dbd5e537bbd8654d3807aa023edea27" translate="yes" xml:space="preserve">
          <source>The time it takes varies depending on how fast your machine is and how large your encoding is. Unless you are working on something big like euc-tw, it won't take too long.</source>
          <target state="translated">それがかかる時間は、あなたのマシンの速度やエンコーディングの大きさによって異なります。euc-tw のような大きなものでない限り、それほど時間はかかりません。</target>
        </trans-unit>
        <trans-unit id="e4a773ca459be08fb127884cfab114e154432eff" translate="yes" xml:space="preserve">
          <source>The time of the null loop (a loop with the same number of rounds but empty loop body) is subtracted from the time of the real loop.</source>
          <target state="translated">ヌルループ(ラウンド数は同じだがループ本体が空のループ)の時間は、実際のループの時間から減算されます。</target>
        </trans-unit>
        <trans-unit id="b6a2ce725119cbf8ac82ed9014cf15ca7bd90e68" translate="yes" xml:space="preserve">
          <source>The time returned also includes the process times of the terminated child processes for which wait() has been executed. This value is somewhat like the second value returned by the times() of core Perl, but not necessarily identical. Note that due to backward compatibility limitations the returned value may wrap around at about 2147 seconds or at about 36 minutes.</source>
          <target state="translated">返される時間には、 wait()が実行された終了した子プロセスのプロセス時間も含まれます。この値は、コアPerlのtimes()によって返される2番目の値に多少似ていますが、必ずしも同じではありません。下位互換性の制限により、返される値は約2147秒または約36分で折り返される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0d1626bdb98ca3cc408f22b06c2161e7fe233ac0" translate="yes" xml:space="preserve">
          <source>The time when Perl is actually doing what your code says to do, as opposed to the earlier period of time when it was trying to figure out whether what you said made any sense whatsoever, which is &lt;b&gt;compile time&lt;/b&gt;.</source>
          <target state="translated">Perlが実際にコードの実行内容を実行している&lt;b&gt;時間&lt;/b&gt;。これは、ユーザーの発言が意味を成しているかどうかを判断しようとした以前の期間、つまり&lt;b&gt;コンパイル時間&lt;/b&gt;とは対照的です。</target>
        </trans-unit>
        <trans-unit id="84f0e5475a9de884cf21f0b5087fb4edeef00da2" translate="yes" xml:space="preserve">
          <source>The time when Perl is trying to make sense of your code, as opposed to when it thinks it knows what your code means and is merely trying to do what it thinks your code says to do, which is &lt;b&gt;runtime&lt;/b&gt;.</source>
          <target state="translated">それはそれはどのようなあなたのコード手段を知っているし、単にそれはあなたのコードを考えて何をしようとしていると考えたときとは対照的に、Perlは、あなたのコードの意味を理解しようとしている時間がある、行うことを言います&lt;b&gt;ランタイム&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2e4f067abc3cb37a82d1ce3a350c4ed5ac55d47a" translate="yes" xml:space="preserve">
          <source>The timeout in the [PKG] can be specified as zero to effect a &quot;poll&quot;, but you shouldn't do that because a new IO::Select object will be created behind the scenes just to do the single poll. This is horrendously inefficient. Use rather true select() with a zero timeout on the handle, or non-blocking IO.</source>
          <target state="translated">PKG]のタイムアウトをゼロに指定して「ポーリング」を行うこともできますが、シングルポーリングを行うためだけに新しいIO::Selectオブジェクトが裏で作られてしまうのでやめたほうがいいです。これは恐ろしく非効率的です。ハンドルのタイムアウトがゼロの真の select()を使うか、ノンブロッキング IO を使ってください。</target>
        </trans-unit>
        <trans-unit id="538790731acb7259f937f6ff4a2bbf78b24054c5" translate="yes" xml:space="preserve">
          <source>The timeout may be a number of seconds relative to the current time (e.g., 5 seconds from when the call is made), or may be an absolute timeout in</source>
          <target state="translated">タイムアウトは、現在の時刻からの相対的な秒数(例えば、通話が行われたときから5秒)であってもよいし、絶対的なタイムアウトであってもよい。</target>
        </trans-unit>
        <trans-unit id="fd8fbd616a78a90070ef718270fee035f94b0bad" translate="yes" xml:space="preserve">
          <source>The timing is done using time(3) and times(3).</source>
          <target state="translated">時間(3)と時間(3)を使ってタイミングを取ります。</target>
        </trans-unit>
        <trans-unit id="bfc27e045cf8c436a59465851692c98d92afa4eb" translate="yes" xml:space="preserve">
          <source>The title of this section indicates the second problem you may run into sooner or later when you pack C structures. If the function you intend to call expects a, say, &lt;code&gt;void *&lt;/code&gt; value, you</source>
          <target state="translated">このセクションのタイトルは、C構造体をパックするときに遅かれ早かれ発生する可能性がある2番目の問題を示しています。呼び出す関数が、たとえば &lt;code&gt;void *&lt;/code&gt; 値を期待している場合、</target>
        </trans-unit>
        <trans-unit id="3aeea9af350571abf85e25c4751ee40203e9d46b" translate="yes" xml:space="preserve">
          <source>The top level documentation about Perl regular expressions is found in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">Perl正規表現に関する最上位のドキュメントは&lt;a href=&quot;perlre&quot;&gt;perlreにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="3205e679e2f0bb1ae1342389bae87dd20bedcfd5" translate="yes" xml:space="preserve">
          <source>The top node in the tree is &lt;code&gt;[ 'Document', \%attributes,
&lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;</source>
          <target state="translated">ツリーの最上位ノードは &lt;code&gt;[ 'Document', \%attributes, &lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37995bec6dd9b8643c48818f0b81e11787b543cc" translate="yes" xml:space="preserve">
          <source>The total elapsed times the test took to run, in seconds from the epoch..</source>
          <target state="translated">テストが実行されるまでにかかった総経過時間を、エポックから秒単位で表示しています。</target>
        </trans-unit>
        <trans-unit id="1c62e4162c4c89e197d0fdd84f0911b0a91d8950" translate="yes" xml:space="preserve">
          <source>The total number of comparisons is equal to the sum of the squares of the number of entries in each bucket. For a random hash of &lt;code&gt;&amp;lt;n&lt;/code&gt; &amp;gt; keys into &lt;code&gt;&amp;lt;k&lt;/code&gt; &amp;gt; buckets, the expected value is:</source>
          <target state="translated">比較の総数は、各バケットのエントリ数の二乗の合計に等しくなります。 &lt;code&gt;&amp;lt;n&lt;/code&gt; &amp;gt;キーの &lt;code&gt;&amp;lt;k&lt;/code&gt; &amp;gt;バケットへのランダムハッシュの場合、期待される値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d4c2502de58f3e2d86d4adebf37cdce84d5b9f9b" translate="yes" xml:space="preserve">
          <source>The total time it took for the test to run, in seconds. If &lt;code&gt;Time::HiRes&lt;/code&gt; is available, it will have finer granularity.</source>
          <target state="translated">テストの実行にかかった合計時間（秒単位）。場合 &lt;code&gt;Time::HiRes&lt;/code&gt; 利用可能である、それはより細かい粒度を持つことになります。</target>
        </trans-unit>
        <trans-unit id="1b3a565887dd69be936761de4d497f57b4dfa910" translate="yes" xml:space="preserve">
          <source>The tradeoff is that one needs to calculate the number of return values in advance (though overextending the stack will not typically hurt anything but memory consumption).</source>
          <target state="translated">そのトレードオフは、あらかじめ戻り値の数を計算しておく必要があるということです(ただし、スタックを拡張しすぎても、通常はメモリ消費以外には何の問題もありません)。</target>
        </trans-unit>
        <trans-unit id="02dc2cb0935e5c48d56deb5ed1a283c1991198d6" translate="yes" xml:space="preserve">
          <source>The traditional &quot;0&quot;, &quot;1&quot;, and &quot;2&quot; MODEs are implemented with different numeric values on some systems. The flags exported by &lt;code&gt;Fcntl&lt;/code&gt; (O_RDONLY, O_WRONLY, O_RDWR) should work everywhere though. (Mac OS, OS/390)</source>
          <target state="translated">従来の「0」、「1」、および「2」モードは、一部のシステムでは異なる数値で実装されています。 &lt;code&gt;Fcntl&lt;/code&gt; によってエクスポートされたフラグ（O_RDONLY、O_WRONLY、O_RDWR）は、どこでも機能するはずです。（Mac OS、OS / 390）</target>
        </trans-unit>
        <trans-unit id="edec44b15608ad1c090140c537934ec3a77ab750" translate="yes" xml:space="preserve">
          <source>The traditional one has it followed by a name enclosed in braces, meaning the character (or sequence of characters) given by that name. Thus &lt;code&gt;\N{ASTERISK}&lt;/code&gt; is another way of writing &lt;code&gt;*&lt;/code&gt; , valid in both double-quoted strings and regular expression patterns. In patterns, it doesn't have the meaning an unescaped &lt;code&gt;*&lt;/code&gt; does.</source>
          <target state="translated">従来のものは、中括弧で囲まれた名前が続き、その名前で与えられた文字（または文字のシーケンス）を意味します。したがって、 &lt;code&gt;\N{ASTERISK}&lt;/code&gt; は &lt;code&gt;*&lt;/code&gt; を記述するもう1つの方法であり、二重引用符で囲まれた文字列と正規表現パターンの両方で有効です。パターンでは、エスケープされていない &lt;code&gt;*&lt;/code&gt; のような意味はありません。</target>
        </trans-unit>
        <trans-unit id="cf50a6157f8b6c5d609d11261410355088e7eb85" translate="yes" xml:space="preserve">
          <source>The transitional compilation environment is obtained with the following compiler and linker flags:</source>
          <target state="translated">移行時のコンパイル環境は、以下のコンパイラフラグとリンカフラグで取得します。</target>
        </trans-unit>
        <trans-unit id="7383cd567e6253ea6210a9db604e2fa9e5e4632a" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">文字変換演算子。 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 同じ。&lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;perlopのQuote-Like演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e96d614d57d8ccc80741217a9adfc3a85457d070" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">文字変換演算子。 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 同じ。&lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;perlopのQuote-Like演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4178c59a00064af8220ead2c08c98e1676579390" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">文字変換演算子。 &lt;code&gt;&lt;a href=&quot;tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 同じ。&lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;perlopのQuote-Like演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ea9a92782ae9df97b0632f112e4b5544a1a9028b" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">文字変換演算子。 &lt;code&gt;&lt;a href=&quot;y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 同じ。&lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;perlopのQuote-Like演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="75ab4f7335b924ba00dcfa6684ad7ab9b56afe36" translate="yes" xml:space="preserve">
          <source>The trap and untrap methods are synonyms for deny and permit respectfully.</source>
          <target state="translated">トラップ法とアントラップ法は、敬意を持って否定し、許可することの同義語です。</target>
        </trans-unit>
        <trans-unit id="79edf12630cd230667f23adf7c1c02295b7aaf31" translate="yes" xml:space="preserve">
          <source>The treatment of more than one physical &lt;b&gt;line&lt;/b&gt; as a single logical line. &lt;b&gt;Makefile&lt;/b&gt; lines are continued by putting a backslash before the &lt;b&gt;newline&lt;/b&gt;. Mail headers, as defined by RFC 822, are continued by putting a space or tab</source>
          <target state="translated">複数の物理&lt;b&gt;回線&lt;/b&gt;を単一の論理回線として扱うこと。&lt;b&gt;Makefileの&lt;/b&gt;行は、&lt;b&gt;改行の&lt;/b&gt;前にバックスラッシュを置くことによって継続され&lt;b&gt;ます&lt;/b&gt;。 RFC 822で定義されているメールヘッダーは、スペースまたはタブを挿入することで続きます。</target>
        </trans-unit>
        <trans-unit id="416e0656b5d6eca80f77db061d8df87eef2d675e" translate="yes" xml:space="preserve">
          <source>The tree is created by the compiler while</source>
          <target state="translated">ツリーは</target>
        </trans-unit>
        <trans-unit id="751a409fc8b6dd72130af7dcf107013d6a066c03" translate="yes" xml:space="preserve">
          <source>The trick in this task is to find the directory. Before your script does anything else (such as a &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;), you can get the current working directory with the &lt;code&gt;Cwd&lt;/code&gt; module, which comes with Perl:</source>
          <target state="translated">このタスクの秘訣は、ディレクトリを見つけることです。スクリプトが他に何かを行う前に（ &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; など）、Perlに付属している &lt;code&gt;Cwd&lt;/code&gt; モジュールを使用して現在の作業ディレクトリを取得できます。</target>
        </trans-unit>
        <trans-unit id="f5f4f31af96f44cb48b6403e792709ecc6d53b8e" translate="yes" xml:space="preserve">
          <source>The trick is that if you read a &lt;code&gt;BOM&lt;/code&gt; , you will know the byte order, since if it was written on a big-endian platform, you will read the bytes &lt;code&gt;0xFE 0xFF&lt;/code&gt;, but if it was written on a little-endian platform, you will read the bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt;. (And if the originating platform was writing in ASCII platform UTF-8, you will read the bytes &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt;.)</source>
          <target state="translated">トリックは、 &lt;code&gt;BOM&lt;/code&gt; を読み取ると、バイトオーダーがわかるということです。ビッグエンディアンプラットフォームで書き込まれた場合、バイト &lt;code&gt;0xFE 0xFF&lt;/code&gt; を読み取りますが、リトルエンディアンプラットフォームで書き込まれた場合、バイト &lt;code&gt;0xFF 0xFE&lt;/code&gt; を読み取ります。（そして、元のプラットフォームがASCIIプラットフォームUTF-8で書き込んでいた場合、バイト &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt; を読み取ります。）</target>
        </trans-unit>
        <trans-unit id="98f1375fe9d48b636ba837bd6c5d9b3f6fb48c48" translate="yes" xml:space="preserve">
          <source>The trick is to give a special parameter to the Configure shell script when running it on AIX:</source>
          <target state="translated">コツは、AIX上でConfigureシェルスクリプトを実行する際に、特別なパラメータを与えることです。</target>
        </trans-unit>
        <trans-unit id="0a8f7f70cdf2316a2ca5d5174affe77306a16af9" translate="yes" xml:space="preserve">
          <source>The trick to this problem is avoiding accidental autovivification. If you want to check three keys deep, you might na&amp;iuml;vely try this:</source>
          <target state="translated">この問題の秘訣は、偶発的な自動活性化を回避することです。3つのキーを深くチェックしたい場合は、単純にこれを試してみてください。</target>
        </trans-unit>
        <trans-unit id="8f023c48c1c4fd330a5e021a4a36ff097b3f2c34" translate="yes" xml:space="preserve">
          <source>The tricky thing to remember is that the first parameter is true if you want to</source>
          <target state="translated">覚えておくと厄介なのは、最初のパラメータが真であれば</target>
        </trans-unit>
        <trans-unit id="0358acd687c89e6aeedb15fd79329af2ac79f19b" translate="yes" xml:space="preserve">
          <source>The trigonometric constant &lt;b&gt;pi&lt;/b&gt; and some of handy multiples of it are also defined.</source>
          <target state="translated">三角定数&lt;b&gt;pi&lt;/b&gt;とその便利な倍数のいくつかも定義されています。</target>
        </trans-unit>
        <trans-unit id="46116b5afa30e36e5dfcca4ac124810d45929096" translate="yes" xml:space="preserve">
          <source>The trust in item 2 is transitive. If A trusts B, and B trusts C, then A trusts C. So if you do not override &lt;code&gt;@ISA&lt;/code&gt; with &lt;code&gt;@CARP_NOT&lt;/code&gt; , then this trust relationship is identical to, &quot;inherits from&quot;.</source>
          <target state="translated">項目2の信頼は推移的です。AがBを信頼し、BがCを信頼する場合、AはCを信頼します。 &lt;code&gt;@CARP_NOT&lt;/code&gt; で &lt;code&gt;@ISA&lt;/code&gt; をオーバーライドしない場合、この信頼関係は「継承元」と同じです。</target>
        </trans-unit>
        <trans-unit id="761c5f5b8a8444418e2d9bdc4d8cca16ccc65180" translate="yes" xml:space="preserve">
          <source>The truth of the matter is that perl's regular expressions these days are much more complex than this kind of structure, but visualising it this way can help when trying to get your bearings, and it matches the current implementation pretty closely.</source>
          <target state="translated">実際のところ、最近のperlの正規表現はこの種の構造よりもずっと複雑ですが、このように可視化することは、自分の位置を把握しようとするときに役立ちますし、現在の実装とかなり密接に一致しています。</target>
        </trans-unit>
        <trans-unit id="df6a9452c74fa01c8c98846cb474f3c173568489" translate="yes" xml:space="preserve">
          <source>The tty driver is put into raw mode and restored using an operating system specific command, in UNIX-like environments &lt;code&gt;stty&lt;/code&gt; .</source>
          <target state="translated">ttyドライバーはrawモードになり、オペレーティングシステム固有のコマンドを使用して、UNIXのような環境 &lt;code&gt;stty&lt;/code&gt; で復元されます。</target>
        </trans-unit>
        <trans-unit id="99fb31ac14610942d5eec87bdc1a87d0b036e971" translate="yes" xml:space="preserve">
          <source>The tutorial started in the Llama continues in the Alpaca, which introduces the intermediate features of references, data structures, object-oriented programming, and modules:</source>
          <target state="translated">ラマで始まったチュートリアルはアルパカで続き、参照、データ構造、オブジェクト指向プログラミング、モジュールの中間的な機能を紹介しています。</target>
        </trans-unit>
        <trans-unit id="6ef070521ff5826ca5eb1f98285ab64a027e2793" translate="yes" xml:space="preserve">
          <source>The two additional lines request from perl to catch various common problems in your code. They check different things so you need both. A potential problem caught by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; will cause your code to stop immediately when it is encountered, while &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; will merely give a warning (like the command-line switch &lt;b&gt;-w&lt;/b&gt;) and let your code run. To read more about them check their respective manual pages at &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">追加の2行は、コード内のさまざまな一般的な問題をキャッチするためにperlに要求します。彼らは異なるものをチェックするので、両方が必要です。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; によって検出される潜在的な問題。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; を&lt;a href=&quot;functions/use&quot;&gt;使用している&lt;/a&gt;間、コードが検出されるとすぐに停止します。（コマンドラインスイッチ&lt;b&gt;-wの&lt;/b&gt;ような）警告を表示し、コードを実行させます。それらの詳細については、&lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt;および&lt;a href=&quot;warnings&quot;&gt;warningsにある&lt;/a&gt;それぞれのマニュアルページを確認してください。</target>
        </trans-unit>
        <trans-unit id="ba2dc4945c85043455423fb1b5a39f8aa3d6b28f" translate="yes" xml:space="preserve">
          <source>The two argument form of add_bits() will add the first $nbits bits from $data. For the last potentially partial byte only the high order &lt;code&gt;$nbits % 8&lt;/code&gt; bits are used. If $nbits is greater than &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($data) * 8&lt;/code&gt; , then this method would do the same as &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt; .</source>
          <target state="translated">add_bits（）の2つの引数形式は、$ dataから最初の$ nbitsビットを追加します。最後の部分バイトの可能性がある場合は、上位 &lt;code&gt;$nbits % 8&lt;/code&gt; ビットのみが使用されます。$ nbitsが &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($data) * 8&lt;/code&gt; より大きい場合、このメソッドは &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt; と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="edfc68f9b85a8c57ac6b419328c423790a72a43e" translate="yes" xml:space="preserve">
          <source>The two arrays &lt;code&gt;@ISA&lt;/code&gt; and &lt;code&gt;@EXPORT&lt;/code&gt; are very important. The &lt;code&gt;@ISA&lt;/code&gt; array contains a list of other packages in which to search for methods (or subroutines) that do not exist in the current package. This is usually only important for object-oriented extensions (which we will talk about much later), and so usually doesn't need to be modified.</source>
          <target state="translated">&lt;code&gt;@ISA&lt;/code&gt; と &lt;code&gt;@EXPORT&lt;/code&gt; の2つの配列は非常に重要です。 &lt;code&gt;@ISA&lt;/code&gt; の配列は、現在のパッケージには存在しないメソッド（またはサブルーチン）を検索するには他のパッケージのリストが含まれています。これは通常、オブジェクト指向の拡張機能（後で説明します）でのみ重要であるため、通常は変更する必要はありません。</target>
        </trans-unit>
        <trans-unit id="1bc049a18027fa1202df37bcfed013d26326a12f" translate="yes" xml:space="preserve">
          <source>The two control characters ^D and ^Z, and the tokens __END__ and __DATA__ may be used to indicate the logical end of the script before the actual end of file. Any following text is ignored.</source>
          <target state="translated">2 つの制御文字 ^D と ^Z、そしてトークン __END__と _DATA__は、ファイルの実際の終了前にスクリプトの論理的な終了を示すために使用することができます。以下のテキストは無視されます。</target>
        </trans-unit>
        <trans-unit id="34dcc268df0f1b7f78c17ae23e0cef09454c6cdc" translate="yes" xml:space="preserve">
          <source>The two entry points are &lt;code&gt;re_intuit_start()&lt;/code&gt; and &lt;code&gt;pregexec()&lt;/code&gt; . These routines have a somewhat incestuous relationship with overlap between their functions, and &lt;code&gt;pregexec()&lt;/code&gt; may even call &lt;code&gt;re_intuit_start()&lt;/code&gt; on its own. Nevertheless other parts of the perl source code may call into either, or both.</source>
          <target state="translated">2つのエントリポイントは &lt;code&gt;re_intuit_start()&lt;/code&gt; と &lt;code&gt;pregexec()&lt;/code&gt; です。これらのルーチンは、関数間のオーバーラップといくらか近親相姦の関係にあり、 &lt;code&gt;pregexec()&lt;/code&gt; はそれ &lt;code&gt;re_intuit_start()&lt;/code&gt; を呼び出すことさえできます。それにもかかわらず、perlソースコードの他の部分がどちらか、または両方を呼び出す場合があります。</target>
        </trans-unit>
        <trans-unit id="8d4c95b48b6a1668825ba4572ce44483ca77dc51" translate="yes" xml:space="preserve">
          <source>The two filenames can also be given separately in full as &lt;code&gt;$dirfile&lt;/code&gt; and &lt;code&gt;$pagfilename&lt;/code&gt; . This suits for two files without &quot;.dir&quot; and &quot;.pag&quot; extensions, perhaps for example two files from &lt;a href=&quot;file/temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="translated">2つのファイル名は、 &lt;code&gt;$dirfile&lt;/code&gt; および &lt;code&gt;$pagfilename&lt;/code&gt; として完全に個別に指定することもできます。これは、 &quot;。dir&quot;および &quot;.pag&quot;拡張子のない2つのファイル、たとえば&lt;a href=&quot;file/temp&quot;&gt;File :: Tempの&lt;/a&gt; 2つのファイルに適しています。</target>
        </trans-unit>
        <trans-unit id="2f1774e1f537dc56f588c1be426bca15556e7438" translate="yes" xml:space="preserve">
          <source>The two first forms are simply syntactic sugar which automatically load the right module on first use. The second form allow you to use algorithm names which contains letters which are not legal perl identifiers, e.g. &quot;SHA-1&quot;. If no implementation for the given algorithm can be found, then an exception is raised.</source>
          <target state="translated">最初の2つの形式は、最初の使用時に自動的に適切なモジュールをロードするための単純な構文上の糖質です。第二の形式では、例えば &quot;SHA-1&quot; のような、Perl の正当な識別子ではない文字を含むアルゴリズム名を使用することができます。与えられたアルゴリズムの実装が見つからない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="c95a4925ad583d0cdab2da763605ba8a5577a6cd" translate="yes" xml:space="preserve">
          <source>The two main uses for this are to switch back to using the package sub inside an inner scope:</source>
          <target state="translated">主な用途としては、インナースコープの中でパッケージサブを使うように切り替えることと、パッケージサブを使うように切り替えることの2つです。</target>
        </trans-unit>
        <trans-unit id="9fdb893929b74d583f916a04691865e61a0c8195" translate="yes" xml:space="preserve">
          <source>The two most common mistakes made in constructing something like an array of arrays is either accidentally counting the number of elements or else taking a reference to the same memory location repeatedly. Here's the case where you just get the count instead of a nested array:</source>
          <target state="translated">配列の配列のようなものを構築する際によくある2つの間違いは、誤って要素数をカウントしてしまうか、あるいは同じメモリ位置への参照を何度も取ってしまうことです。ここでは、入れ子になった配列の代わりにカウントを取得するだけの場合を示します。</target>
        </trans-unit>
        <trans-unit id="9ef613531270a3be0f714b7b0c6603ad457c5c67" translate="yes" xml:space="preserve">
          <source>The two primary use cases supported by &lt;a href=&quot;harness&quot;&gt;TAP::Harness&lt;/a&gt; for plugins are</source>
          <target state="translated">プラグインの&lt;a href=&quot;harness&quot;&gt;TAP :: Harness&lt;/a&gt;でサポートされる2つの主な使用例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="49899df9616cd2a3f123de74937bc969a55089e7" translate="yes" xml:space="preserve">
          <source>The two quickest fixes are either to render Perl silent about any locale inconsistencies or to run Perl under the default locale &quot;C&quot;.</source>
          <target state="translated">最も手っ取り早い修正方法は、ロケールの不整合についてPerlを沈黙させるか、デフォルトのロケール &quot;C &quot;でPerlを実行するかの2つです。</target>
        </trans-unit>
        <trans-unit id="1d29057aa8b200a921ab9b4c9f2a8fac7349c60a" translate="yes" xml:space="preserve">
          <source>The two sets of barcharts give stats and a visual indication of performance of the hash.</source>
          <target state="translated">2つのバーチャートのセットは、統計情報とハッシュのパフォーマンスを視覚的に表示します。</target>
        </trans-unit>
        <trans-unit id="ea356fe6678cb16635414403ae22dc70cf7c6eb2" translate="yes" xml:space="preserve">
          <source>The two statements:</source>
          <target state="translated">2つの発言。</target>
        </trans-unit>
        <trans-unit id="2e850f7b70f56596c655ae357f7738793fa85127" translate="yes" xml:space="preserve">
          <source>The type of the constant (</source>
          <target state="translated">定数の型(</target>
        </trans-unit>
        <trans-unit id="207d3c0594c531831415850568f05351cc4335f1" translate="yes" xml:space="preserve">
          <source>The type of the third parameter is arbitrary as far as the typemap is concerned. It just has to be in line with the declared variable.</source>
          <target state="translated">3番目のパラメータの型は、タイプマップに関する限り任意です。宣言された変数と一致している必要があります。</target>
        </trans-unit>
        <trans-unit id="3a8fb2c5d9024ab64dd8a1b418b0785f1b45c2d4" translate="yes" xml:space="preserve">
          <source>The type-to-match is whitewashed (except for commas, which have no whitespace before them, and multiple &lt;code&gt;*&lt;/code&gt; which have no whitespace between them).</source>
          <target state="translated">一致するタイプはホワイトウォッシュされます（コンマの前に空白がない、および複数の &lt;code&gt;*&lt;/code&gt; の間に空白がない）を除きます。</target>
        </trans-unit>
        <trans-unit id="065bb709681867146d38619409b0c4858958cd7d" translate="yes" xml:space="preserve">
          <source>The typemap checks that a scalar reference is passed from perl to XS.</source>
          <target state="translated">タイプマップはスカラ参照がperlからXSに渡されているかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="1aca61f72e9539e566a25a6f843796b117e0a616" translate="yes" xml:space="preserve">
          <source>The types are:</source>
          <target state="translated">タイプは</target>
        </trans-unit>
        <trans-unit id="b8218b5c6abbddadba7d9cdb24a7712b0e31ed41" translate="yes" xml:space="preserve">
          <source>The typical C compiler&amp;rsquo;s first pass, which processes lines beginning with &lt;code&gt;#&lt;/code&gt; for conditional compilation and macro definition, and does various manipulations of the program text based on the current definitions. Also known as</source>
          <target state="translated">条件付きコンパイルとマクロ定義のために &lt;code&gt;#&lt;/code&gt; で始まる行を処理し、現在の定義に基づいてプログラムテキストのさまざまな操作を行う、典型的なCコンパイラの最初のパス。としても知られている</target>
        </trans-unit>
        <trans-unit id="c3f6853138e86a46a65a1f12c8ebb77c9ad23c63" translate="yes" xml:space="preserve">
          <source>The typical approach uses the Perl debugger, described in the</source>
          <target state="translated">典型的なアプローチは</target>
        </trans-unit>
        <trans-unit id="8d039cb4fff50dcf102a20e5a834fd5dcb92db29" translate="yes" xml:space="preserve">
          <source>The typical input/output flow of a program is:</source>
          <target state="translated">プログラムの典型的な入出力の流れです。</target>
        </trans-unit>
        <trans-unit id="bb341dafe72dfd453b6e963169c19a0e3677ecc8" translate="yes" xml:space="preserve">
          <source>The typical interactions between pieces of data are best represented by operators.</source>
          <target state="translated">データの断片間の典型的な相互作用は、演算子で表現するのが最適です。</target>
        </trans-unit>
        <trans-unit id="37bcc82c39e22721104650473d90114a9246bb63" translate="yes" xml:space="preserve">
          <source>The typical usage case is for private modules or working copies of projects from remote repositories on the local disk.</source>
          <target state="translated">典型的な使用例は、プライベートモジュールやリモートリポジトリからローカルディスク上のプロジェクトの作業コピーです。</target>
        </trans-unit>
        <trans-unit id="a4e2f09da65ffeb5dd41665671b5f400f853e79b" translate="yes" xml:space="preserve">
          <source>The typical usage is from within a Makefile generated by &lt;a href=&quot;makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;. So under normal circumstances you won't have to deal with this module directly.</source>
          <target state="translated">典型的な使用法は、&lt;a href=&quot;makemaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt;によって生成されたMakefile内からです。したがって、通常の状況では、このモジュールを直接処理する必要はありません。</target>
        </trans-unit>
        <trans-unit id="b839dd64fd51c7239737d976be2aaf701494cef3" translate="yes" xml:space="preserve">
          <source>The typical way to use an &lt;code&gt;EVERY&lt;/code&gt; call is to wrap it in another base method, that all classes inherit. For example, to ensure that every destructor an object inherits is actually called (as opposed to just the left-most-depth-first-est one):</source>
          <target state="translated">&lt;code&gt;EVERY&lt;/code&gt; 呼び出しを使用する一般的な方法は、すべてのクラスが継承する別の基本メソッドでそれをラップすることです。たとえば、オブジェクトが継承するすべてのデストラクタが実際に呼び出されることを保証するには（左端の深度が最初のデストラクタとは対照的に）：</target>
        </trans-unit>
        <trans-unit id="d078360c456578fa6c56aaca3475f63295e459b1" translate="yes" xml:space="preserve">
          <source>The uncolor() function and support for ANSI_COLORS_DISABLED were added in Term::ANSIColor 1.04, included in Perl 5.8.0.</source>
          <target state="translated">Perl 5.8.0 に含まれる Term::ANSIColor 1.04 で uncolor()関数と ANSI_COLORS_DISABLED のサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="d2846292c4ece0df1cdbdb746e73838c0174b8ea" translate="yes" xml:space="preserve">
          <source>The underlying behaviour of &lt;code&gt;%+&lt;/code&gt; is provided by the &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;%+&lt;/code&gt; の基本的な動作は、&lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt;モジュールによって提供されます。</target>
        </trans-unit>
        <trans-unit id="cc10f153a716bc66afaf3456e02a5c9183a04515" translate="yes" xml:space="preserve">
          <source>The underlying parser object. This is useful if you need the full information for the test program.</source>
          <target state="translated">基礎となるパーサオブジェクトです。これは、テストプログラムの完全な情報が必要な場合に便利です。</target>
        </trans-unit>
        <trans-unit id="b7d8dde972f17bdda4b61ab86196bc96064679a1" translate="yes" xml:space="preserve">
          <source>The undump program was an ancient attempt to speed up Perl program by storing the already-compiled form to disk. This is no longer a viable option, as it only worked on a few architectures, and wasn't a good solution anyway.</source>
          <target state="translated">アンダンププログラムは、コンパイル済みのフォームをディスクに保存することで Perl プログラムを高速化しようとする昔からの試みでした。これは、いくつかのアーキテクチャでしか機能しなかったので、もはや実行可能なオプションではありませんし、いずれにしても良い解決策ではありませんでした。</target>
        </trans-unit>
        <trans-unit id="be8a46bbcbbd519aa2c58d3aea183c9d8f4c685d" translate="yes" xml:space="preserve">
          <source>The unfortunate similarity of this function's name to that of Perl's &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; operator is strictly coincidental. This function works from the left; &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; works from the right.</source>
          <target state="translated">この関数の名前とPerlの &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 演算子の名前の不幸な類似点は、まったくの偶然です。この機能は左から機能します。 &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; は右から動作します。</target>
        </trans-unit>
        <trans-unit id="ca3db9d0f0db6a082e0aea1f0a6be142ef87df51" translate="yes" xml:space="preserve">
          <source>The untie Gotcha</source>
          <target state="translated">The untie Gotcha</target>
        </trans-unit>
        <trans-unit id="12164923a1b041bdc762cdb62bbbc7fb759ea434" translate="yes" xml:space="preserve">
          <source>The untie() Gotcha</source>
          <target state="translated">untie()のガッチャ</target>
        </trans-unit>
        <trans-unit id="50d65961a427d2a64bc08d49e4d87b52f498e907" translate="yes" xml:space="preserve">
          <source>The uppercase variants (&lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\H&lt;/code&gt; , and &lt;code&gt;\V&lt;/code&gt; ) are character classes that match, respectively, any character that isn't a word character, digit, whitespace, horizontal whitespace, or vertical whitespace.</source>
          <target state="translated">大文字のバリアント（ &lt;code&gt;\W&lt;/code&gt; 、 &lt;code&gt;\D&lt;/code&gt; 、 &lt;code&gt;\S&lt;/code&gt; 、 &lt;code&gt;\H&lt;/code&gt; 、および &lt;code&gt;\V&lt;/code&gt; ）は、単語文字、数字、空白、水平空白、垂直空白以外の任意の文字にそれぞれ一致する文字クラスです。</target>
        </trans-unit>
        <trans-unit id="6a360f037634db2d1e1b847c01d4ff39f2e82c73" translate="yes" xml:space="preserve">
          <source>The uri you passed to the constructor</source>
          <target state="translated">コンストラクタに渡したURI</target>
        </trans-unit>
        <trans-unit id="7175c322baef80b04d65002673bad08dde1a5590" translate="yes" xml:space="preserve">
          <source>The urllist parameter has CD-ROM support</source>
          <target state="translated">urllist パラメータは CD-ROM をサポートしています。</target>
        </trans-unit>
        <trans-unit id="0e71ac825c7f966ddb9142eb457a1ad27b050118" translate="yes" xml:space="preserve">
          <source>The usage is for a canned filter is:</source>
          <target state="translated">使い方は、缶詰フィルターの場合です。</target>
        </trans-unit>
        <trans-unit id="826c70de8255c56bc69c42539c313e47e2f05832" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;//g&lt;/code&gt; is shown in the following example. Suppose we have a string that consists of words separated by spaces. If we know how many words there are in advance, we could extract the words using groupings:</source>
          <target state="translated">&lt;code&gt;//g&lt;/code&gt; の使用法を次の例に示します。スペースで区切られた単語で構成される文字列があるとします。単語の数が事前にわかっている場合は、グループ化を使用して単語を抽出できます。</target>
        </trans-unit>
        <trans-unit id="832a5d88d8f5443e11412058babdb54340f702ac" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;:void&lt;/code&gt; is discouraged, as it can result in exceptions not being thrown if you</source>
          <target state="translated">&lt;code&gt;:void&lt;/code&gt; の使用はお勧めしません。これは、</target>
        </trans-unit>
        <trans-unit id="0ce5a82961769245d2e039e505d826cd3e904ef4" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;:void&lt;/code&gt; with Fatal is discouraged.</source>
          <target state="translated">Fatal で &lt;code&gt;:void&lt;/code&gt; を使用することはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="dac4651068bc57e4e25c4b9a7bdd7a073791862a" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;=&amp;gt;&lt;/code&gt; above provides necessary quoting of &lt;code&gt;MODULE&lt;/code&gt; . If you don't use the fat comma (eg you don't have any ARGUMENTS), then you'll need to quote the MODULE.</source>
          <target state="translated">上記の &lt;code&gt;=&amp;gt;&lt;/code&gt; の使用は、 &lt;code&gt;MODULE&lt;/code&gt; の必要な引用を提供します。太いコンマを使用しない場合（たとえば、引数がない場合）、モジュールを引用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9b512e8508712c1167d958e6e4ad448ccc7e030f" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;\Q&lt;/code&gt; causes the &amp;lt;.&amp;gt; in the regex to be treated as a regular character, so that &lt;code&gt;P.&lt;/code&gt; matches a &lt;code&gt;P&lt;/code&gt; followed by a dot.</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; を使用すると、正規表現の&amp;lt;。&amp;gt;が通常の文字として扱われるため、 &lt;code&gt;P.&lt;/code&gt; は &lt;code&gt;P&lt;/code&gt; の後にドットが続くように一致します。</target>
        </trans-unit>
        <trans-unit id="514e40665c7756f02fb508e8f86f86167ddf537d" translate="yes" xml:space="preserve">
          <source>The use of a camel with the topic of Perl is a trademark of O'Reilly and Associates, Inc. Used with permission.</source>
          <target state="translated">Perlの話題のラクダの使用は、O'Reilly and Associates,Inc.の商標です。許可を得て使用しています。</target>
        </trans-unit>
        <trans-unit id="9cb45eca9a7939753b03a1360d763d098c0e7870" translate="yes" xml:space="preserve">
          <source>The use of all caps for constant names is merely a convention, although it is recommended in order to make constants stand out and to help avoid collisions with other barewords, keywords, and subroutine names. Constant names must begin with a letter or underscore. Names beginning with a double underscore are reserved. Some poor choices for names will generate warnings, if warnings are enabled at compile time.</source>
          <target state="translated">定数名にオールキャップを使用するのは単なる慣習に過ぎませんが、定数を目立たせ、他のベアワード、キーワード、サブルーチン名との衝突を避けるために推奨されています。定数名は文字かアンダースコアで始めなければなりません。ダブルアンダースコアで始まる名前は予約されています。コンパイル時に警告が有効になっている場合は、名前の選択に誤りがあると警告が発生します。</target>
        </trans-unit>
        <trans-unit id="58b862df75de13b5dcf2d9b0b606b5454f4112c1" translate="yes" xml:space="preserve">
          <source>The use of hash keys starting with a hyphen (&lt;code&gt;-name&lt;/code&gt; ) or entirely in upper case (&lt;code&gt;NAME&lt;/code&gt; ) is a relic of older versions of Perl in which ordinary lower case strings were not handled correctly by the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator. While some modules retain uppercase or hyphenated argument keys for historical reasons or as a matter of personal style, most new modules should use simple lower case keys. Whatever you choose, be consistent!</source>
          <target state="translated">ハイフン（ &lt;code&gt;-name&lt;/code&gt; ）で始まる、または完全に大文字（ &lt;code&gt;NAME&lt;/code&gt; ）で始まるハッシュキーの使用は、通常の小文字の文字列が &lt;code&gt;=&amp;gt;&lt;/code&gt; 演算子で正しく処理されなかった古いバージョンのPerlの遺物です。一部のモジュールは、歴史的な理由から、または個人的なスタイルの問題として、大文字またはハイフン付きの引数キーを保持しますが、ほとんどの新しいモジュールは、単純な小文字キーを使用する必要があります。何を選択しても、一貫性があります。</target>
        </trans-unit>
        <trans-unit id="0181fb947fb2e09fe7658e112ec2fe9418c5503f" translate="yes" xml:space="preserve">
          <source>The use of interpreter-based threads in perl is officially &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;.</source>
          <target state="translated">perlでインタプリタベースのスレッドを使用することは公式には&lt;a href=&quot;perlpolicy#discouraged&quot;&gt;推奨されていません&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af3aa24ab804ebe0a65aee4289caba48448e851d" translate="yes" xml:space="preserve">
          <source>The use of parentheses around a &lt;b&gt;subpattern&lt;/b&gt; in a &lt;b&gt;regular expression&lt;/b&gt; to store the matched &lt;b&gt;substring&lt;/b&gt; as a &lt;b&gt;backreference&lt;/b&gt;. (Captured strings are also returned as a list in &lt;b&gt;list context&lt;/b&gt;.) See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">一致した&lt;b&gt;部分文字列&lt;/b&gt;を&lt;b&gt;後方参照&lt;/b&gt;として保存するための、&lt;b&gt;正規表現&lt;/b&gt;内の&lt;b&gt;サブパターン&lt;/b&gt;の括弧の使用。（キャプチャされた文字列は、&lt;b&gt;リストコンテキストの&lt;/b&gt;リストとしても返され&lt;b&gt;ます&lt;/b&gt;。）Camelの第5章「パターンマッチング」を参照してください。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ceb3a7a104da1d4a198b733387677a08ee3ca395" translate="yes" xml:space="preserve">
          <source>The use of parenthesis can be used to capture parts of the input filename.</source>
          <target state="translated">括弧の使用は、入力ファイル名の一部をキャプチャするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="379fb1c054bbd3152f276aaca35f049867852f33" translate="yes" xml:space="preserve">
          <source>The use of the following functions is discouraged as they are not actually testing functions and produce no diagnostics to help figure out what went wrong. They were written before &lt;code&gt;is_deeply()&lt;/code&gt; existed because I couldn't figure out how to display a useful diff of two arbitrary data structures.</source>
          <target state="translated">以下の関数は、実際には関数をテストしておらず、何が問題であるかを理解するのに役立つ診断を生成しないため、使用しないことをお勧めします。 &lt;code&gt;is_deeply()&lt;/code&gt; が存在する前に作成されたのは、2つの任意のデータ構造の有用なdiffを表示する方法を理解できなかったためです。</target>
        </trans-unit>
        <trans-unit id="5b392cf4598b7c92d87fc443e5bf63773c90811b" translate="yes" xml:space="preserve">
          <source>The usenm option</source>
          <target state="translated">usenmオプション</target>
        </trans-unit>
        <trans-unit id="977cdd9dc7908139553c49b2609de1c2c08baff9" translate="yes" xml:space="preserve">
          <source>The user id owning the file</source>
          <target state="translated">ファイルを所有するユーザーID</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
