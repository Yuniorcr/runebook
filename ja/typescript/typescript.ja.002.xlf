<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="">
    <body>
      <group id="">
        <trans-unit id="464d90ddf01b4a7d7fb2059732ea18c0a56423b4" translate="yes" xml:space="preserve">
          <source>Extending Interfaces</source>
          <target state="translated">インターフェースの拡張</target>
        </trans-unit>
        <trans-unit id="70c729194ffb9f8bd9ec475f03a3057bb1e60a4e" translate="yes" xml:space="preserve">
          <source>Extending expressions</source>
          <target state="translated">式を拡張する</target>
        </trans-unit>
        <trans-unit id="a3843d37d93289eadbc1958c41f1c13c309bbf8e" translate="yes" xml:space="preserve">
          <source>Extract&amp;lt;T,U&amp;gt;</source>
          <target state="translated">Extract&amp;lt;T,U&amp;gt;</target>
        </trans-unit>
        <trans-unit id="515872ad64c38522409e00410e68ba6e32a29116" translate="yes" xml:space="preserve">
          <source>Extracts the type of the &lt;code&gt;this&lt;/code&gt; parameter of a function type, or &lt;code&gt;unknown&lt;/code&gt; if the function type has no &lt;code&gt;this&lt;/code&gt; parameter.</source>
          <target state="translated">関数タイプの &lt;code&gt;this&lt;/code&gt; パラメーターのタイプを抽出します。 関数タイプに &lt;code&gt;this&lt;/code&gt; パラメーターがない場合は &lt;code&gt;unknown&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5580687121fcfefa146981fb36d296bc3f0de348" translate="yes" xml:space="preserve">
          <source>Factories</source>
          <target state="translated">Factories</target>
        </trans-unit>
        <trans-unit id="bead528d19950f71ea30380d09df640a3d7210ca" translate="yes" xml:space="preserve">
          <source>Factory Functions</source>
          <target state="translated">工場機能</target>
        </trans-unit>
        <trans-unit id="4a32e2f9caf4e668d29618328e51a2647e2d967d" translate="yes" xml:space="preserve">
          <source>Faster &lt;code&gt;tsc --watch&lt;/code&gt;</source>
          <target state="translated">より高速な &lt;code&gt;tsc --watch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbdafc5050207465ed19f95ed57e21102e2c0067" translate="yes" xml:space="preserve">
          <source>Faster subsequent builds with the &lt;code&gt;--incremental&lt;/code&gt; flag</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; フラグを使用して、後続のビルドを高速化します</target>
        </trans-unit>
        <trans-unit id="a29227a71e68767de435c445f3ac1547081655fc" translate="yes" xml:space="preserve">
          <source>Feedback from our community, as well as our own experience, has shown us that leveraging the newest TypeScript features while also accommodating users on the older versions are difficult. TypeScript introduces a new feature called &lt;code&gt;typesVersions&lt;/code&gt; to help accommodate these scenarios.</source>
          <target state="translated">コミュニティのフィードバックと私たちの経験から、最新のTypeScript機能を利用すると同時に、古いユーザーにサービスを提供することは難しいことがわかっています。 TypeScriptには、これらのシナリオに対処する &lt;code&gt;typesVersions&lt;/code&gt; と呼ばれる新しい機能が導入されています。</target>
        </trans-unit>
        <trans-unit id="6748207b859ccfa7f82ac49d731d1b27113a3b98" translate="yes" xml:space="preserve">
          <source>File does not exist, move to the second substitution</source>
          <target state="translated">ファイルが存在しないため、2番目の置換に進みます</target>
        </trans-unit>
        <trans-unit id="0fe8300347a5d2fe3f7b4e21e6708ddf628f2eeb" translate="yes" xml:space="preserve">
          <source>File exists. Done.</source>
          <target state="translated">ファイルが存在しています。 それをやった</target>
        </trans-unit>
        <trans-unit id="1214946f7d95ef7612951c5654019274eb30d8ea" translate="yes" xml:space="preserve">
          <source>File path</source>
          <target state="translated">ファイルパス</target>
        </trans-unit>
        <trans-unit id="f1b26fa5a34d56fb3e3920fe7c3dc4952d2ae44c" translate="yes" xml:space="preserve">
          <source>Files in &lt;code&gt;src/views&lt;/code&gt; are user code for some UI controls. Files in &lt;code&gt;generated/templates&lt;/code&gt; are UI template binding code auto-generated by a template generator as part of the build. A build step will copy the files in &lt;code&gt;/src/views&lt;/code&gt; and &lt;code&gt;/generated/templates/views&lt;/code&gt; to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as &lt;code&gt;&quot;./template&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src/views&lt;/code&gt; ファイルは、一部のUIコントロールのユーザーコードです。 &lt;code&gt;generated/templates&lt;/code&gt; 内のファイルは、ビルドの一部としてテンプレートジェネレーターによって自動的に生成されるUIテンプレートバインディングコードです。 ビルドステップは、ファイルを &lt;code&gt;/src/views&lt;/code&gt; および &lt;code&gt;/generated/templates/views&lt;/code&gt; から出力内の同じディレクトリにコピーします。 実行時に、ビューはそのテンプレートがその隣にあることを期待できるため、相対名を &lt;code&gt;&quot;./template&quot;&lt;/code&gt; としてインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="944999053b7485f3f5c651758da5734b4f1b2630" translate="yes" xml:space="preserve">
          <source>Files included using &lt;code&gt;&quot;include&quot;&lt;/code&gt; can be filtered using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. However, files included explicitly using the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property are always included regardless of &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;. The &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property defaults to excluding the &lt;code&gt;node_modules&lt;/code&gt;, &lt;code&gt;bower_components&lt;/code&gt;, &lt;code&gt;jspm_packages&lt;/code&gt; and &lt;code&gt;&amp;lt;outDir&amp;gt;&lt;/code&gt; directories when not specified.</source>
          <target state="translated">&lt;code&gt;&quot;include&quot;&lt;/code&gt; を使用してインクルードされたファイルは、 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; プロパティを使用してフィルタリングできます。 ただし、 &lt;code&gt;&quot;files&quot;&lt;/code&gt; プロパティを使用して明示的に含まれる「files」は、 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 関係なく常に含まれます。 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; プロパティーは、指定されない場合、デフォルトで &lt;code&gt;node_modules&lt;/code&gt; 、 &lt;code&gt;bower_components&lt;/code&gt; 、 &lt;code&gt;jspm_packages&lt;/code&gt; および &lt;code&gt;&amp;lt;outDir&amp;gt;&lt;/code&gt; ディレクトリーになります。</target>
        </trans-unit>
        <trans-unit id="c86be6e064d368e35d514286147756e446d3864b" translate="yes" xml:space="preserve">
          <source>Files included using &lt;code&gt;&quot;include&quot;&lt;/code&gt; can be filtered using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. However, files included explicitly using the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property are always included regardless of &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;. The &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property defaults to excluding the &lt;code&gt;node_modules&lt;/code&gt;, &lt;code&gt;bower_components&lt;/code&gt;, and &lt;code&gt;jspm_packages&lt;/code&gt; directories when not specified.</source>
          <target state="translated">&lt;code&gt;&quot;include&quot;&lt;/code&gt; を使用してインクルードされたファイルは、 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; プロパティを使用してフィルタリングできます。 ただし、 &lt;code&gt;&quot;files&quot;&lt;/code&gt; プロパティを使用して明示的に含まれる「files」は、 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 関係なく常に含まれます。 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; プロパティー、デフォルトでは、 &lt;code&gt;node_modules&lt;/code&gt; 、 &lt;code&gt;bower_components&lt;/code&gt; 、および &lt;code&gt;jspm_packages&lt;/code&gt; ディレクトリーが指定されていない場合。</target>
        </trans-unit>
        <trans-unit id="a0de52ada9537ab464bb6d45e97f86eaaff6bac8" translate="yes" xml:space="preserve">
          <source>Final result</source>
          <target state="translated">最終結果</target>
        </trans-unit>
        <trans-unit id="c716a5f69a835c7b207ef913676c36b3f4cf7fe7" translate="yes" xml:space="preserve">
          <source>Finally, ES2015 introduced the &lt;code&gt;for..of&lt;/code&gt; statement as a means of iterating over an iterable. Similarly, the Async Iteration proposal introduces the &lt;code&gt;for..await..of&lt;/code&gt; statement to iterate over an async iterable:</source>
          <target state="translated">最後に、ES2015は繰り返し可能な &lt;code&gt;for..of&lt;/code&gt; を反復する手段としてfor..ofステートメントを導入しました。 同様に、非同期反復の提案では、 &lt;code&gt;for..await..of&lt;/code&gt; ステートメントを導入して、非同期の反復可能なオブジェクトを反復処理します。</target>
        </trans-unit>
        <trans-unit id="7d78a77f9353986a905d8c074f3df1efad103d2d" translate="yes" xml:space="preserve">
          <source>Finally, add &lt;code&gt;src/greet.ts&lt;/code&gt; to &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">最後に、 &lt;code&gt;src/greet.ts&lt;/code&gt; を &lt;code&gt;tsconfig.json&lt;/code&gt; に追加します 。</target>
        </trans-unit>
        <trans-unit id="48e51bf84514484baa2e7212c0375ccee83ffca6" translate="yes" xml:space="preserve">
          <source>Finally, if the compiler could not resolve the module, it will log an error. In this case, the error would be something like &lt;code&gt;error TS2307: Cannot find module 'moduleA'.&lt;/code&gt;</source>
          <target state="translated">最後に、コンパイラがモジュールを解決できない場合は、エラーを記録します。 この場合、エラーは &lt;code&gt;error TS2307: Cannot find module 'moduleA'.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c70f3dc4718552bbb66574b06291ac4442a2ee94" translate="yes" xml:space="preserve">
          <source>Finally, if your target is ES5 or ES3, you&amp;rsquo;ll also need to set the &lt;code&gt;--downlevelIterators&lt;/code&gt; flag.</source>
          <target state="translated">最後に、ターゲットがES5またはES3の場合、 &lt;code&gt;--downlevelIterators&lt;/code&gt; フラグも設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="625382271b526d5909aa39a000a69074afb94c9c" translate="yes" xml:space="preserve">
          <source>Finally, let&amp;rsquo;s extend the example one last time with classes. TypeScript supports new features in JavaScript, like support for class-based object-oriented programming.</source>
          <target state="translated">最後に、クラスを使用して例を拡張しましょう。 TypeScriptは、クラスベースのオブジェクト指向プログラミングのサポートを含む、新しいJavaScript機能をサポートします。</target>
        </trans-unit>
        <trans-unit id="c6b76794e34c66667cc7c06423ff09561a2db9b4" translate="yes" xml:space="preserve">
          <source>Finally, we could perform many different merges using &lt;code&gt;namespace&lt;/code&gt; declarations. This isn&amp;rsquo;t a particularly realistic example, but shows all sorts of interesting behavior:</source>
          <target state="translated">最後に、 &lt;code&gt;namespace&lt;/code&gt; 宣言を使用してさまざまなマージを実行できます。 これは特に現実的な例ではありませんが、あらゆる種類の興味深い動作を示しています。</target>
        </trans-unit>
        <trans-unit id="2a1cbf967f1f59d7ed905556a7ba174d0d91c432" translate="yes" xml:space="preserve">
          <source>Finally, we mix our mixins into the class implementation.</source>
          <target state="translated">最後に、ミックスインをクラス実装にミックスします。</target>
        </trans-unit>
        <trans-unit id="5d24682490796967f2d44a64ea932e79d1b2fb40" translate="yes" xml:space="preserve">
          <source>Finally, you can make index signatures &lt;code&gt;readonly&lt;/code&gt; in order to prevent assignment to their indices:</source>
          <target state="translated">最後に、インデックス署名を &lt;code&gt;readonly&lt;/code&gt; して、インデックスへの割り当てを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="36f4ab4ec74314f1c6473ad2b642469fa92db24a" translate="yes" xml:space="preserve">
          <source>Find all referenced projects</source>
          <target state="translated">すべての参照プロジェクトを検索</target>
        </trans-unit>
        <trans-unit id="f36d6416266be79de49dbd1cd5564e2c29d74695" translate="yes" xml:space="preserve">
          <source>Find and Install Declaration Files</source>
          <target state="translated">宣言ファイルを見つけてインストールする</target>
        </trans-unit>
        <trans-unit id="107a7b9e0a62d571bcbb1e3e04401f38fb4be3c9" translate="yes" xml:space="preserve">
          <source>Finished with that step? Great! You&amp;rsquo;ve successfully migrated a file from JavaScript to TypeScript!</source>
          <target state="translated">そのステップを完了しましたか？ 驚くばかり！ JavaScriptからTypeScriptにファイルを正常に移行しました！</target>
        </trans-unit>
        <trans-unit id="c8bb450db4ab929fdfadf7c4e435fbd8ded8de50" translate="yes" xml:space="preserve">
          <source>First ensure Webpack is installed.</source>
          <target state="translated">まず、Webpackがインストールされていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="3df868c33500281a256aa0f7044d7222e49fa905" translate="yes" xml:space="preserve">
          <source>First install Babelify and the Babel preset for ES2015. Like Uglify, Babelify mangles code, so we&amp;rsquo;ll need vinyl-buffer and gulp-sourcemaps. By default Babelify will only process files with extensions of &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.es&lt;/code&gt;, &lt;code&gt;.es6&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; so we need to add the &lt;code&gt;.ts&lt;/code&gt; extension as an option to Babelify.</source>
          <target state="translated">まず、ES2015用のBabelifyおよびBabelプリセットをインストールします。 Uglifyのように、Babelifyはコードをマングルします。 したがって、vinyl-bufferとgulp-sourcemapsが必要です。 デフォルトでは、Babelifyは拡張子が &lt;code&gt;.js&lt;/code&gt; 、 &lt;code&gt;.es&lt;/code&gt; 、 &lt;code&gt;.es6&lt;/code&gt; 、および &lt;code&gt;.jsx&lt;/code&gt; のファイルのみを処理するため、.tsにオプションとして.ts拡張子を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="735b0c16eaf95bad801406a590783a07bff54840" translate="yes" xml:space="preserve">
          <source>First install Uglify. Since the point of Uglify is to mangle your code, we also need to install vinyl-buffer and gulp-sourcemaps to keep sourcemaps working.</source>
          <target state="translated">最初にUglifyをインストールします。 Uglifyのポイントはコードを壊すことなので、vinyl-bufferとgulp-sourcemapsをインストールして、ソースマップを機能させる必要があります。</target>
        </trans-unit>
        <trans-unit id="89e20ebbee86fab209c76b802ba242b064d21b1b" translate="yes" xml:space="preserve">
          <source>First of all, they&amp;rsquo;re important because they allow TypeScript to type-check against other projects without re-checking the original source code. They&amp;rsquo;re also important because they allow TypeScript to interoperate with existing JavaScript libraries that weren&amp;rsquo;t built with TypeScript in mind. Finally, a benefit that is often underappreciated: both TypeScript &lt;em&gt;and&lt;/em&gt; JavaScript users can benefit from these files when using editors powered by TypeScript to get things like better auto-completion.</source>
          <target state="translated">まず、これらは重要です。TypeScriptは、元のソースコードを再確認することなく、他のプロジェクトで型チェックを実行できるためです。 また、TypeScriptは、TypeScriptを念頭に置いて構築されていない既存のJavaScriptライブラリと相互運用できるため、重要です。 最後に、多くの場合過小評価されている利点：TypeScript &lt;em&gt;と&lt;/em&gt; JavaScriptの両方のユーザーは、TypeScript拡張エディターを使用してより良い自動補完などを取得することで、これらのファイルの恩恵を受けます。</target>
        </trans-unit>
        <trans-unit id="8618e8a440e50c5a75000139af77b5f2c4300871" translate="yes" xml:space="preserve">
          <source>First some terminology</source>
          <target state="translated">最初のいくつかの用語</target>
        </trans-unit>
        <trans-unit id="99290d59716a55c82e8b063db8bf7f05e1a4b00b" translate="yes" xml:space="preserve">
          <source>First steps</source>
          <target state="translated">最初のステップ</target>
        </trans-unit>
        <trans-unit id="8336905fe9b50c35195d1e701772f27af4d34cab" translate="yes" xml:space="preserve">
          <source>First we declare the interfaces we will union. Each interface has a &lt;code&gt;kind&lt;/code&gt; property with a different string literal type. The &lt;code&gt;kind&lt;/code&gt; property is called the &lt;em&gt;discriminant&lt;/em&gt; or &lt;em&gt;tag&lt;/em&gt;. The other properties are specific to each interface. Notice that the interfaces are currently unrelated. Let&amp;rsquo;s put them into a union:</source>
          <target state="translated">最初に、結合するインターフェイスを宣言します。 各インターフェイスには、異なる文字列リテラルタイプの &lt;code&gt;kind&lt;/code&gt; プロパティがあります。 &lt;code&gt;kind&lt;/code&gt; プロパティは、 &lt;em&gt;判別式&lt;/em&gt;または&lt;em&gt;タグ&lt;/em&gt;と呼ばれます。 他のプロパティは各インターフェイスに固有です。 現在、インターフェイスは無関係です。 組合に加入させます。</target>
        </trans-unit>
        <trans-unit id="a34ce699f43cedcd3aa6a4d39d183ca5e70a6e0b" translate="yes" xml:space="preserve">
          <source>First we need to tell TypeScript how to build. Right click on &lt;code&gt;scripts&lt;/code&gt; and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;TypeScript Configuration File&lt;/strong&gt; and use the default name of &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">まず、TypeScriptにビルド方法を指示する必要があります。 &lt;code&gt;scripts&lt;/code&gt; を右クリックし、[ &lt;strong&gt;新しいアイテム&lt;/strong&gt; ]をクリックします。 次に、 &lt;strong&gt;TypeScript構成ファイル&lt;/strong&gt;を選択し、 &lt;code&gt;tsconfig.json&lt;/code&gt; のデフォルト名を使用します</target>
        </trans-unit>
        <trans-unit id="2dfb573ed967d8c6c17580ed779ecdccc14311ef" translate="yes" xml:space="preserve">
          <source>First, accessors require you to set the compiler to output ECMAScript 5 or higher. Downleveling to ECMAScript 3 is not supported. Second, accessors with a &lt;code&gt;get&lt;/code&gt; and no &lt;code&gt;set&lt;/code&gt; are automatically inferred to be &lt;code&gt;readonly&lt;/code&gt;. This is helpful when generating a &lt;code&gt;.d.ts&lt;/code&gt; file from your code, because users of your property can see that they can&amp;rsquo;t change it.</source>
          <target state="translated">まず、アクセサーを使用するには、ECMAScript 5以降を出力するようにコンパイラーを構成する必要があります。 ECMAScript 3へのダウンレベル化はサポートされていません。 次に、 &lt;code&gt;get&lt;/code&gt; が &lt;code&gt;set&lt;/code&gt; ていないアクセサーは、自動的に &lt;code&gt;readonly&lt;/code&gt; であると推測されます 。 これは、コードから &lt;code&gt;.d.ts&lt;/code&gt; ファイルを生成するときに役立ちます。 プロパティのユーザーは、変更できないことを知っています。</target>
        </trans-unit>
        <trans-unit id="2f1af0e65e7f250987a6b875f7a585e406660a62" translate="yes" xml:space="preserve">
          <source>First, given types &lt;code&gt;T'&lt;/code&gt; and &lt;code&gt;U'&lt;/code&gt; that are instantiations of &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; where all occurrences of type parameters are replaced with &lt;code&gt;any&lt;/code&gt;, if &lt;code&gt;T'&lt;/code&gt; is not assignable to &lt;code&gt;U'&lt;/code&gt;, the conditional type is resolved to &lt;code&gt;Y&lt;/code&gt;. Intuitively, if the most permissive instantiation of &lt;code&gt;T&lt;/code&gt; is not assignable to the most permissive instantiation of &lt;code&gt;U&lt;/code&gt;, we know that no instantiation will be and we can just resolve to &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">まず、型パラメーターのすべての出現が &lt;code&gt;any&lt;/code&gt; で置き換えられる &lt;code&gt;T&lt;/code&gt; および &lt;code&gt;U&lt;/code&gt; のインスタンス化である型 &lt;code&gt;T'&lt;/code&gt; および &lt;code&gt;U'&lt;/code&gt; が与えられ、 &lt;code&gt;T'&lt;/code&gt; が &lt;code&gt;U'&lt;/code&gt; に割り当て可能でない場合、条件付き型は &lt;code&gt;Y&lt;/code&gt; Youに解決されます。 直感的に、 &lt;code&gt;T&lt;/code&gt; の最も寛容なインスタンス化を &lt;code&gt;U&lt;/code&gt; の最も寛容なインスタンス化に割り当てることができない場合、インスタンス化は発生せず、 &lt;code&gt;Y&lt;/code&gt; に解決できます。</target>
        </trans-unit>
        <trans-unit id="e0f154b6d3560afc04e7423c292457f3d4c696d4" translate="yes" xml:space="preserve">
          <source>First, install &lt;a href=&quot;https://dotnet.microsoft.com/apps/aspnet&quot;&gt;ASP.NET Core&lt;/a&gt; if you need it. This quick-start guide requires Visual Studio 2015 or 2017.</source>
          <target state="translated">最初に、必要に応じて&lt;a href=&quot;https://dotnet.microsoft.com/apps/aspnet&quot;&gt;ASP.NET Coreを&lt;/a&gt;インストールします 。 このクイックスタートガイドには、Visual Studio 2015または2017が必要です。</target>
        </trans-unit>
        <trans-unit id="5fe122cf8e822627b9c191ebbd95f6c78e81f570" translate="yes" xml:space="preserve">
          <source>First, install browserify, &lt;a href=&quot;https://www.npmjs.com/package/tsify&quot;&gt;tsify&lt;/a&gt;, and vinyl-source-stream. tsify is a Browserify plugin that, like gulp-typescript, gives access to the TypeScript compiler. vinyl-source-stream lets us adapt the file output of Browserify back into a format that gulp understands called &lt;a href=&quot;https://github.com/gulpjs/vinyl&quot;&gt;vinyl&lt;/a&gt;.</source>
          <target state="translated">まず、browserify、 &lt;a href=&quot;https://www.npmjs.com/package/tsify&quot;&gt;tsify&lt;/a&gt; 、およびvinyl-source-streamをインストールします。 tsifyは、gulp-typescriptと同様に、TypeScriptコンパイラへのアクセスを提供するBrowserifyプラグインです。 vinyl-source-streamを使用すると、Browserifyのファイル出力をgulpが理解できる&lt;a href=&quot;https://github.com/gulpjs/vinyl&quot;&gt;ビニール&lt;/a&gt;形式に戻すことができます。</target>
        </trans-unit>
        <trans-unit id="51744cf60b9ea9e03623f5527d487a42b621f3c4" translate="yes" xml:space="preserve">
          <source>First, install the &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt; utility library:</source>
          <target state="translated">最初に、 &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt;ユーティリティライブラリをインストールします。</target>
        </trans-unit>
        <trans-unit id="f59152e91c742c2580784c2fb852897f78a3c5bd" translate="yes" xml:space="preserve">
          <source>First, the compiler will try to locate a file that represents the imported module. To do so the compiler follows one of two different strategies: &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; or &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt;. These strategies tell the compiler &lt;em&gt;where&lt;/em&gt; to look for &lt;code&gt;moduleA&lt;/code&gt;.</source>
          <target state="translated">最初に、コンパイラーはインポートされたモジュールを表すファイルを見つけようとします。 そのために、コンパイラは&lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt;または&lt;a href=&quot;#node&quot;&gt;Nodeの&lt;/a&gt; 2つの異なる戦略のいずれかに従います。 これらの戦略は、 &lt;code&gt;moduleA&lt;/code&gt; を探す&lt;em&gt;場所&lt;/em&gt;をコンパイラ&lt;em&gt;に&lt;/em&gt;伝えます。</target>
        </trans-unit>
        <trans-unit id="fee2aae2ee58d3140d673d1cb82204dd56b9f63b" translate="yes" xml:space="preserve">
          <source>First, we can use concatenated output using the &lt;code&gt;--outFile&lt;/code&gt; flag to compile all of the input files into a single JavaScript output file:</source>
          <target state="translated">まず、-- &lt;code&gt;--outFile&lt;/code&gt; フラグを使用して連結出力を使用し、すべての入力ファイルを単一のJavaScript出力ファイルにコンパイルできます。</target>
        </trans-unit>
        <trans-unit id="28d19122adb2247e67a766539293d7db8d64dd97" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll review the kinds of libraries TypeScript declaration files can represent. We&amp;rsquo;ll briefly show how each kind of library is &lt;em&gt;used&lt;/em&gt;, how it is &lt;em&gt;written&lt;/em&gt;, and list some example libraries from the real world.</source>
          <target state="translated">最初に、TypeScript宣言ファイルが表すことができるライブラリのタイプを識別します。 各タイプのライブラリがどのように&lt;em&gt;使用さ&lt;/em&gt;れ&lt;em&gt;説明&lt;/em&gt; &lt;em&gt;されて&lt;/em&gt;いるかを簡単に示し&lt;em&gt;、&lt;/em&gt;実際のサンプルライブラリをリストします。</target>
        </trans-unit>
        <trans-unit id="a7a574b0f49a4d1d52dcd069a74b5d55c404e3a8" translate="yes" xml:space="preserve">
          <source>First, you&amp;rsquo;ll need to enable some module system by setting TypeScript&amp;rsquo;s &lt;code&gt;module&lt;/code&gt; flag. Valid options are &lt;code&gt;commonjs&lt;/code&gt;, &lt;code&gt;amd&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, and &lt;code&gt;umd&lt;/code&gt;.</source>
          <target state="translated">まず、TypeScript &lt;code&gt;module&lt;/code&gt; フラグを設定して、いくつかのモジュールシステムを有効にする必要があります 。 有効なオプションは &lt;code&gt;commonjs&lt;/code&gt; 、 &lt;code&gt;amd&lt;/code&gt; 、 &lt;code&gt;system&lt;/code&gt; 、および &lt;code&gt;umd&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7d0c91cebd6414c6cadf4f9352001f643b829f0b" translate="yes" xml:space="preserve">
          <source>Fixed Length Tuples</source>
          <target state="translated">固定長タプル</target>
        </trans-unit>
        <trans-unit id="3ca7815b9ccb9b2f4adbee87c52250c1c035669b" translate="yes" xml:space="preserve">
          <source>Flag unused declarations with &lt;code&gt;--noUnusedParameters&lt;/code&gt; and &lt;code&gt;--noUnusedLocals&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--noUnusedParameters&lt;/code&gt; および &lt;code&gt;--noUnusedLocals&lt;/code&gt; を使用した未使用の宣言</target>
        </trans-unit>
        <trans-unit id="82a9583e4b01eda6ab596923bd11954f7465daf4" translate="yes" xml:space="preserve">
          <source>Following this logic, the compiler will attempt to resolve the two imports as such:</source>
          <target state="translated">このロジックに従って、コンパイラは次の2つのインポートを解決しようとします。</target>
        </trans-unit>
        <trans-unit id="26431a2529d203186f1196ee3c1e08f1f5a1e8c1" translate="yes" xml:space="preserve">
          <source>Following up on specifying the type of &lt;code&gt;this&lt;/code&gt; in a class or an interface, functions and methods can now declare the type of &lt;code&gt;this&lt;/code&gt; they expect.</source>
          <target state="translated">クラスまたはインターフェイスで &lt;code&gt;this&lt;/code&gt; タイプを指定すると、関数とメソッドは、 &lt;code&gt;this&lt;/code&gt; タイプを期待するように宣言できるようになりました。</target>
        </trans-unit>
        <trans-unit id="1c46fd3b2bfcf228c256745663f71fdbf4e9f242" translate="yes" xml:space="preserve">
          <source>Following up our example above, consider if &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; instead used a non-relative path and had the import &lt;code&gt;var x = require(&quot;moduleB&quot;);&lt;/code&gt;. Node would then try to resolve &lt;code&gt;moduleB&lt;/code&gt; to each of the locations until one worked.</source>
          <target state="translated">上記の例によると、 &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; 代わりに非相対パスを使用し、 &lt;code&gt;var x = require(&quot;moduleB&quot;);&lt;/code&gt; をインポートします。 ノードは、1つが機能するまで &lt;code&gt;moduleB&lt;/code&gt; を各場所に解決しようとします。</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="d651257c7219d6828652b8ed3ae590398f5b2d5c" translate="yes" xml:space="preserve">
          <source>For JavaScript library users, the &lt;a href=&quot;consumption&quot;&gt;Consumption&lt;/a&gt; section offers a few simple steps to locate and install corresponding declaration files.</source>
          <target state="translated">JavaScriptライブラリユーザーの場合、「 &lt;a href=&quot;consumption&quot;&gt;消費」&lt;/a&gt;セクションには、対応する宣言ファイルを見つけてインストールする簡単な手順がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="3f13871c6491a9fb503e0b3db6f8d157fced814c" translate="yes" xml:space="preserve">
          <source>For NPM users:</source>
          <target state="translated">NPMユーザーの場合：</target>
        </trans-unit>
        <trans-unit id="f29506c87493e2d6a8464c1671b709d1038182e2" translate="yes" xml:space="preserve">
          <source>For React, intrinsic elements are emitted as strings (&lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt;), whereas a component you&amp;rsquo;ve created is not (&lt;code&gt;React.createElement(MyComponent)&lt;/code&gt;).</source>
          <target state="translated">Reactの場合、組み込み要素は文字列（ &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt; ）として出力されますが、作成されたコンポーネントはそうではありません（ &lt;code&gt;React.createElement(MyComponent)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2bc6cffb51efec5345d518d22e0c722de0a63bbe" translate="yes" xml:space="preserve">
          <source>For VS 2013:</source>
          <target state="translated">VS 2013の場合：</target>
        </trans-unit>
        <trans-unit id="614775d6367bb72e6635063a6e9a003dfc10d404" translate="yes" xml:space="preserve">
          <source>For VS 2015:</source>
          <target state="translated">VS 2015の場合：</target>
        </trans-unit>
        <trans-unit id="fabf9dab407dafe6e4158a0fb10d99a963d13936" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;n in x&lt;/code&gt; expression, where &lt;code&gt;n&lt;/code&gt; is a string literal or string literal type and &lt;code&gt;x&lt;/code&gt; is a union type, the &amp;ldquo;true&amp;rdquo; branch narrows to types which have an optional or required property &lt;code&gt;n&lt;/code&gt;, and the &amp;ldquo;false&amp;rdquo; branch narrows to types which have an optional or missing property &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; は文字列リテラルまたは文字列リテラルタイプであり、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;n in x&lt;/code&gt; 式nのユニオンタイプnです 。「true」ブランチは、オプションまたは必須プロパティ &lt;code&gt;n&lt;/code&gt; を持つタイプに絞り込まれ、「false」ブランチは洗練されるオプションまたは欠落しているプロパティ &lt;code&gt;n&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="59f0e903aa4d967be8cee2ad438a3b8e7a692972" translate="yes" xml:space="preserve">
          <source>For creating &lt;code&gt;--incremental&lt;/code&gt; builds, users can leverage the &lt;code&gt;createIncrementalProgram&lt;/code&gt; and &lt;code&gt;createIncrementalCompilerHost&lt;/code&gt; APIs. Users can also re-hydrate old program instances from &lt;code&gt;.tsbuildinfo&lt;/code&gt; files generated by this API using the newly exposed &lt;code&gt;readBuilderProgram&lt;/code&gt; function, which is only meant to be used as for creating new programs (i.e. you can&amp;rsquo;t modify the returned instance - it&amp;rsquo;s only meant to be used for the &lt;code&gt;oldProgram&lt;/code&gt; parameter in other &lt;code&gt;create*Program&lt;/code&gt; functions).</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; ビルドを作成するために、ユーザーは &lt;code&gt;createIncrementalProgram&lt;/code&gt; および &lt;code&gt;createIncrementalCompilerHost&lt;/code&gt; APIを活用できます。 ユーザーは、新しく公開された &lt;code&gt;readBuilderProgram&lt;/code&gt; 関数を使用して、このAPIによって生成された.tsbuildinfoファイルから古いプログラムインスタンスを &lt;code&gt;.tsbuildinfo&lt;/code&gt; することもできます。 これは、新しいプログラムの作成のみに使用することを目的としています（つまり、返されたインスタンスは変更できません）。他の &lt;code&gt;create*Program&lt;/code&gt; 関数の &lt;code&gt;oldProgram&lt;/code&gt; パラメーターに使用します。</target>
        </trans-unit>
        <trans-unit id="13c650c5b2c3bf134743f81ee8a751c72f2c46d5" translate="yes" xml:space="preserve">
          <source>For declaration file authors who relay on built-in types, e.g. DOM APIs or built-in JS run-time constructors like &lt;code&gt;Symbol&lt;/code&gt; or &lt;code&gt;Iterable&lt;/code&gt;, triple-slash-reference lib directives are the recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.</source>
          <target state="translated">DOM APIなどの組み込み型および &lt;code&gt;Symbol&lt;/code&gt; や &lt;code&gt;Iterable&lt;/code&gt; などの組み込みJSランタイムコンストラクターを中継する宣言ファイルの作成者には、トリプルスラッシュリファレンスlibディレクティブが推奨されます。 以前は、これらの.d.tsファイルは、そのようなタイプの前方/重複宣言を追加する必要がありました。</target>
        </trans-unit>
        <trans-unit id="f730367034cc3e65c4c80c7cc48438917a47a1a4" translate="yes" xml:space="preserve">
          <source>For declaration file authors who rely on built-in types, e.g. DOM APIs or built-in JS run-time constructors like &lt;code&gt;Symbol&lt;/code&gt; or &lt;code&gt;Iterable&lt;/code&gt;, triple-slash-reference lib directives are recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.</source>
          <target state="translated">DOM APIなどの組み込み型や、 &lt;code&gt;Symbol&lt;/code&gt; や &lt;code&gt;Iterable&lt;/code&gt; などの組み込みJSランタイムコンストラクターに依存する宣言ファイルの作成者には、トリプルスラッシュリファレンスlibディレクティブが推奨されます。 以前は、これらの.d.tsファイルは、そのようなタイプの前方/重複宣言を追加する必要がありました。</target>
        </trans-unit>
        <trans-unit id="c7b31102ddf3ec0f8a01da2c2c2faaf0cec3c40b" translate="yes" xml:space="preserve">
          <source>For declaration files generated during compilation, the compiler will automatically add &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; for you; A &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; in a generated declaration file is added &lt;em&gt;if and only if&lt;/em&gt; the resulting file uses any declarations from the referenced package.</source>
          <target state="translated">コンパイル中に生成された宣言ファイルの場合、コンパイラは &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; 自動的に追加します。 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; は、結果のファイルが参照パッケージの宣言を使用する&lt;em&gt;場合&lt;/em&gt;に&lt;em&gt;のみ&lt;/em&gt; 、生成された宣言ファイルに追加されます。</target>
        </trans-unit>
        <trans-unit id="4710530ea547f1515550efbf2971f53cc2a8b738" translate="yes" xml:space="preserve">
          <source>For declaring a dependency on an &lt;code&gt;@types&lt;/code&gt; package in a &lt;code&gt;.ts&lt;/code&gt; file, use &lt;code&gt;--types&lt;/code&gt; on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt; instead. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;using &lt;code&gt;@types&lt;/code&gt;, &lt;code&gt;typeRoots&lt;/code&gt; and &lt;code&gt;types&lt;/code&gt; in &lt;code&gt;tsconfig.json&lt;/code&gt; files&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;.ts&lt;/code&gt; ファイルで &lt;code&gt;@types&lt;/code&gt; パッケージへの依存関係を宣言するには、代わりにコマンドラインまたは &lt;code&gt;--types&lt;/code&gt; を使用します。 詳細について&lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;は、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイル&lt;/a&gt;で &lt;code&gt;typeRoots&lt;/code&gt; &lt;code&gt;types&lt;/code&gt; 、typeRoots、およびtypesを使用するを参照してください。</target>
        </trans-unit>
        <trans-unit id="b927d147a48a1d8a678317e5dc270ab1fa0bd354" translate="yes" xml:space="preserve">
          <source>For example consider this project structure:</source>
          <target state="translated">たとえば、次のプロジェクト構造を考えます。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例えば、</target>
        </trans-unit>
        <trans-unit id="b84169ea004a1106235d82bc2a5c66557575c167" translate="yes" xml:space="preserve">
          <source>For example, adding &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; to one of the files in a compilation is equivalent to compiling with &lt;code&gt;--lib es2017.string&lt;/code&gt;.</source>
          <target state="translated">たとえば、コンパイルのファイルの1つに &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; を追加することは、-- lib es2017.stringを使用してコンパイルすることと同等 &lt;code&gt;--lib es2017.string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f435730a5bc00012d3042f3d1a8d4332e64f206" translate="yes" xml:space="preserve">
          <source>For example, an import statement like &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; in &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; would result in attempting the following locations for locating &lt;code&gt;&quot;./moduleB&quot;&lt;/code&gt;:</source>
          <target state="translated">たとえば、 &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; を実行すると、 &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; /root/src/moduleA.ts import {b}などのインポートステートメントが実行され、次の場所が &lt;code&gt;&quot;./moduleB&quot;&lt;/code&gt; を見つけようとします。</target>
        </trans-unit>
        <trans-unit id="4dfb27ce129bee760fed1ebcb688044df6ad992b" translate="yes" xml:space="preserve">
          <source>For example, given the decorator &lt;code&gt;@sealed&lt;/code&gt; we might write the &lt;code&gt;sealed&lt;/code&gt; function as follows:</source>
          <target state="translated">たとえば、デコレータ &lt;code&gt;@sealed&lt;/code&gt; を指定する@sealed、次のように &lt;code&gt;sealed&lt;/code&gt; 関数を作成できます。</target>
        </trans-unit>
        <trans-unit id="ba290a075f0c2045568e30b972340550a085db75" translate="yes" xml:space="preserve">
          <source>For example, including &lt;code&gt;/// &amp;lt;reference types=&quot;node&quot; /&amp;gt;&lt;/code&gt; in a declaration file declares that this file uses names declared in &lt;code&gt;@types/node/index.d.ts&lt;/code&gt;; and thus, this package needs to be included in the compilation along with the declaration file.</source>
          <target state="translated">たとえば、宣言ファイルに &lt;code&gt;/// &amp;lt;reference types=&quot;node&quot; /&amp;gt;&lt;/code&gt; を含めると、このファイルが &lt;code&gt;@types/node/index.d.ts&lt;/code&gt; 宣言された名前を使用することを宣言します。 したがって、このパッケージは、宣言ファイルとともにコンパイルに含める必要があります。</target>
        </trans-unit>
        <trans-unit id="7f2169f30439c664d4891dafe1197f03d77f4716" translate="yes" xml:space="preserve">
          <source>For example, it&amp;rsquo;s often very common to forget to &lt;code&gt;.then()&lt;/code&gt; or &lt;code&gt;await&lt;/code&gt; the contents of a &lt;code&gt;Promise&lt;/code&gt; before passing it to another function. TypeScript&amp;rsquo;s error messages are now specialized, and inform the user that perhaps they should consider using the &lt;code&gt;await&lt;/code&gt; keyword.</source>
          <target state="translated">たとえば、 &lt;code&gt;.then()&lt;/code&gt; を忘れたり、別の関数に渡す前にプロミスの内容を &lt;code&gt;await&lt;/code&gt; ことは非常に一般的です。 TypeScriptエラーメッセージは特殊化されており、 &lt;code&gt;await&lt;/code&gt; キーワードの使用を考慮する必要があることをユーザーに通知します。</target>
        </trans-unit>
        <trans-unit id="ffcedc1552ccfc47d112e6dad0906deb0847258a" translate="yes" xml:space="preserve">
          <source>For example, once you&amp;rsquo;ve &lt;code&gt;npm install&lt;/code&gt;-ed your type declarations, you can use imports and write</source>
          <target state="translated">たとえば、型宣言を &lt;code&gt;npm install&lt;/code&gt; -edした後、importを使用して次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="502a1d2b7504dbb10d71367198e70328d93e9cdc" translate="yes" xml:space="preserve">
          <source>For example, some libraries add new functions to &lt;code&gt;Array.prototype&lt;/code&gt; or &lt;code&gt;String.prototype&lt;/code&gt;.</source>
          <target state="translated">たとえば、一部のライブラリは &lt;code&gt;Array.prototype&lt;/code&gt; または &lt;code&gt;String.prototype&lt;/code&gt; に新しい関数を追加します。</target>
        </trans-unit>
        <trans-unit id="6eec7c26069b784720c61be112395d7efa3ccaf5" translate="yes" xml:space="preserve">
          <source>For example, the following extracts the return type of a function type:</source>
          <target state="translated">たとえば、次は関数型の戻り値の型を抽出します。</target>
        </trans-unit>
        <trans-unit id="a37862b00fe2100e1e8f8d8cb1ffd54013028ebd" translate="yes" xml:space="preserve">
          <source>For example, the following sample declares variables &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;, and initializes them to &lt;code&gt;getSomeObject().x&lt;/code&gt;, &lt;code&gt;getSomeObject().y&lt;/code&gt; and &lt;code&gt;getSomeObject().z&lt;/code&gt; respectively:</source>
          <target state="translated">たとえば、次のサンプルでは、​​変数 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;z&lt;/code&gt; を宣言し、 &lt;code&gt;getSomeObject().x&lt;/code&gt; しています。 X、 &lt;code&gt;getSomeObject().y&lt;/code&gt; 、および &lt;code&gt;getSomeObject().z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3bfab5d35b8a0425d2cd933627ba6f494f7b15e6" translate="yes" xml:space="preserve">
          <source>For example, we can add a static member to a class:</source>
          <target state="translated">たとえば、静的メンバーをクラスに追加できます。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば：</target>
        </trans-unit>
        <trans-unit id="49d355e75376d6e3edd30760b3a9dda119888e8c" translate="yes" xml:space="preserve">
          <source>For function components (formerly known as SFCs) use ES2015 default initializers:</source>
          <target state="translated">関数コンポーネント（以前はSFCとして知られていました）の場合、ES2015デフォルト初期化子を使用します。</target>
        </trans-unit>
        <trans-unit id="6be2baf6180fb6fd27b9800124346282c6fe8435" translate="yes" xml:space="preserve">
          <source>For function members, each function member of the same name is treated as describing an overload of the same function. Of note, too, is that in the case of interface &lt;code&gt;A&lt;/code&gt; merging with later interface &lt;code&gt;A&lt;/code&gt;, the second interface will have a higher precedence than the first.</source>
          <target state="translated">関数メンバーの場合、同じ名前の各関数メンバーは同じ関数オーバーロードを記述するものとして扱われます。 また、インターフェイス &lt;code&gt;A&lt;/code&gt; が後のインターフェイスAとマージする場合、2番目のインターフェイスが最初のインターフェイスよりも高い優先順位を持つことに注意してください。</target>
        </trans-unit>
        <trans-unit id="550510b2afc3402e9b75627c000d9fd8d68b9d48" translate="yes" xml:space="preserve">
          <source>For function types to correctly type check, the names of the parameters do not need to match. We could have, for example, written the above example like this:</source>
          <target state="translated">チェックを正しく入力するために、パラメーター名は関数タイプと一致する必要はありません。 たとえば、上の例は次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="6e49fcf610fb59d8414be6f760fd4d96f45600af" translate="yes" xml:space="preserve">
          <source>For generic types that do not have their type arguments specified, compatibility is checked by specifying &lt;code&gt;any&lt;/code&gt; in place of all unspecified type arguments. The resulting types are then checked for compatibility, just as in the non-generic case.</source>
          <target state="translated">型引数が指定されていないジェネリック型の場合、指定されていないすべての型引数の代わりに &lt;code&gt;any&lt;/code&gt; を指定することにより、互換性がチェックされます。 次に、珍しい場合と同様に、結果のタイプの互換性がチェックされます。</target>
        </trans-unit>
        <trans-unit id="5b3be90cb960b60b8143e001874d26a541dce254" translate="yes" xml:space="preserve">
          <source>For instance, &lt;code&gt;React.Component&lt;/code&gt; is defined to have two type parameters, &lt;code&gt;Props&lt;/code&gt; and &lt;code&gt;State&lt;/code&gt;. In a &lt;code&gt;.js&lt;/code&gt; file, there is no legal way to specify these in the extends clause. By default the type arguments will be &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">たとえば、 &lt;code&gt;React.Component&lt;/code&gt; は、 &lt;code&gt;Props&lt;/code&gt; と &lt;code&gt;State&lt;/code&gt; の 2つの型パラメーターを持つように定義されています。 &lt;code&gt;.js&lt;/code&gt; ファイルの場合、extends句でそれらを指定する正当な方法はありません。 デフォルトでは、type引数は &lt;code&gt;any&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ad0724dca69663ba4a457c62bb2dc6d54f13c7f2" translate="yes" xml:space="preserve">
          <source>For instance, an import to a module &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; would be translated at runtime to &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt;.</source>
          <target state="translated">たとえば、モジュール &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; へのインポートは、実行時に &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt; 変換されます。</target>
        </trans-unit>
        <trans-unit id="e127b9ec7aa54a885066eddbf73a9390682ef004" translate="yes" xml:space="preserve">
          <source>For instance, if you have something that&amp;rsquo;s typed as &lt;code&gt;Object&lt;/code&gt; you won&amp;rsquo;t be able to call methods like &lt;code&gt;toLowerCase()&lt;/code&gt; on it. Being more general usually means you can do less with a type, but &lt;code&gt;any&lt;/code&gt; is special in that it is the most general type while still allowing you to do anything with it. That means you can call it, construct it, access properties on it, etc. Keep in mind though, whenever you use &lt;code&gt;any&lt;/code&gt;, you lose out on most of the error checking and editor support that TypeScript gives you.</source>
          <target state="translated">たとえば、何かが &lt;code&gt;Object&lt;/code&gt; として入力された場合、そのオブジェクトの &lt;code&gt;toLowerCase()&lt;/code&gt; などのメソッドを呼び出すことはできません。 通常、より一般的であるということは、型でできることは少ないことを意味しますが、最も一般的な型で何でもできるという点で特別です。 つまり、呼び出し、構築、プロパティへのアクセスなどを行うことができます。 ただし、 &lt;code&gt;any&lt;/code&gt; を使用すると、TypeScriptによって提供されるエラーチェックとエディターサポートのほとんどが失われることに注意してください 。</target>
        </trans-unit>
        <trans-unit id="76f20136bdec4c8a094a4948f37f41bd9373cd0e" translate="yes" xml:space="preserve">
          <source>For instance, the following interfaces will merge together:</source>
          <target state="translated">たとえば、次のインターフェイスがマージされます。</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">例えば：</target>
        </trans-unit>
        <trans-unit id="cc15a1d1ae77d156b224c9eb01c61c6a21c1a488" translate="yes" xml:space="preserve">
          <source>For intrinsic elements, it is the type of the property on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;</source>
          <target state="translated">組み込み要素の場合、 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; のプロパティタイプ</target>
        </trans-unit>
        <trans-unit id="63e99ee6fde01714eebc90d83730b70795fea95a" translate="yes" xml:space="preserve">
          <source>For leveraging project references, a new &lt;code&gt;createSolutionBuilder&lt;/code&gt; function has been exposed, which returns an instance of the new type &lt;code&gt;SolutionBuilder&lt;/code&gt;.</source>
          <target state="translated">プロジェクト参照を利用するために、新しい &lt;code&gt;createSolutionBuilder&lt;/code&gt; 関数が公開されました。 新しい型 &lt;code&gt;SolutionBuilder&lt;/code&gt; のインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="d4f49775acc3a4322a0557d39b3d6b9d1f2d24cf" translate="yes" xml:space="preserve">
          <source>For more details on the change, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2983&quot;&gt;see the pull request here&lt;/a&gt;.</source>
          <target state="translated">変更の詳細については、 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2983&quot;&gt;このプルリクエストを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="43fc548897db905fa8c2333f2655e946bf2edbda" translate="yes" xml:space="preserve">
          <source>For more details on the implementation, see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29332&quot;&gt;the feature&amp;rsquo;s pull request&lt;/a&gt;.</source>
          <target state="translated">実装の詳細について&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29332&quot;&gt;は、機能のプルリクエストを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="c866e562806b98ab3450aefd85c82570ae3dbe52" translate="yes" xml:space="preserve">
          <source>For more details on these APIs, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31432&quot;&gt;see the original pull request&lt;/a&gt;.</source>
          <target state="translated">これらのAPIの詳細について&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31432&quot;&gt;は、元のプルリクエストを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="9db932b4f370cac7158608164dcc7323460cd641" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30552&quot;&gt;see the pull request on GitHub to add &lt;code&gt;Omit&lt;/code&gt;&lt;/a&gt;, as well as &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31134&quot;&gt;the change to use &lt;code&gt;Omit&lt;/code&gt; for object rest&lt;/a&gt;.</source>
          <target state="translated">詳細&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30552&quot;&gt;については&lt;/a&gt; 、GitHubプルリクエストを参照してOmitを追加し、残りのオブジェクトにOmitを使用するように変更してください 。</target>
        </trans-unit>
        <trans-unit id="fc45d221d48c167e7361605c82635e85e5e5877b" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30776/files&quot;&gt;see the pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30776/files&quot;&gt;GitHubプルリクエストをご覧ください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="273ca0c112dc6b1882314478ee8c1e6544170b8e" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/30646&quot;&gt;see the originating issue&lt;/a&gt;, as well as the pull requests that link back to it.</source>
          <target state="translated">詳細について&lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/30646&quot;&gt;は、元の問題&lt;/a&gt;とそれにリンクされているプルリクエストをご覧ください。</target>
        </trans-unit>
        <trans-unit id="990cc8daa552812b9673fb27d79710d0a0853e7a" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31801&quot;&gt;see the corresponding pull request&lt;/a&gt;.</source>
          <target state="translated">詳細について&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31801&quot;&gt;は、対応するプルリクエストを参照してください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="0320510c766022af54173463f58fd051469373de" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32584&quot;&gt;see the original PR on GitHub&lt;/a&gt;.</source>
          <target state="translated">詳細について&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32584&quot;&gt;は、GitHubの元のPRを&lt;/a&gt;参照してください 。</target>
        </trans-unit>
        <trans-unit id="1fe5d1addf9d0d4b733550ed18ffe6381b947a86" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29510&quot;&gt;check out the respective pull request&lt;/a&gt;.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29510&quot;&gt;各プルリクエストを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="65484dc7f4c4daea7c1d319eb8233395f4407267" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30215&quot;&gt;read more at the original change&lt;/a&gt;.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30215&quot;&gt;元の変更を参照してください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="563dc4e63b054412d2401fc516c6fac2d3df7317" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/30779&quot;&gt;see the original pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">詳細については&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/30779&quot;&gt;、GitHubで元のプルリクエストを確認&lt;/a&gt;できます 。</target>
        </trans-unit>
        <trans-unit id="01a8abf26dc21e0236d3ae01896624d8b626ea07" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32372&quot;&gt;check out the original pull request&lt;/a&gt;.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32372&quot;&gt;元のプルリクエストを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="d623177cf84777887441acfa37b705f15554d05f" translate="yes" xml:space="preserve">
          <source>For more details, you can see the pull requests to</source>
          <target state="translated">詳細については、プルリクエストをご覧ください。</target>
        </trans-unit>
        <trans-unit id="3e64e60d7e437a1ebcf2869771b212e3f2906370" translate="yes" xml:space="preserve">
          <source>For more discussion about modules and namespaces see &lt;a href=&quot;namespaces-and-modules&quot;&gt;Namespaces and Modules&lt;/a&gt;.</source>
          <target state="translated">モジュールと名前空間の詳細については、 &lt;a href=&quot;namespaces-and-modules&quot;&gt;名前空間とモジュールを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c362b5af66f291c8b84b625e56119e3fdeab25b4" translate="yes" xml:space="preserve">
          <source>For more information about module, please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2242&quot;&gt;ES6 module support spec&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2242&quot;&gt;モジュールの&lt;/a&gt;詳細については、 ES6モジュールサポート仕様を参照してください。</target>
        </trans-unit>
        <trans-unit id="570e8203155764ac5cbba766759ffb8d69bcac89" translate="yes" xml:space="preserve">
          <source>For more information on temporal dead zones, see relevant content on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;Mozilla Developer Network&lt;/a&gt;.</source>
          <target state="translated">一時的なデッドゾーンの詳細について&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;は&lt;/a&gt; 、Mozilla Developer Networkの関連コンテンツを参照してください。</target>
        </trans-unit>
        <trans-unit id="c6fb17b499b05834e5a93ed9076041c12b5a0a99" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx&quot;&gt;Async Functions&lt;/a&gt; blog post.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx&quot;&gt;Async Functionsの&lt;/a&gt;ブログ投稿を参照してください。</target>
        </trans-unit>
        <trans-unit id="e181d79ed93cb811ae26b48402f5381960e6dbda" translate="yes" xml:space="preserve">
          <source>For more information, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31166&quot;&gt;see the relevant pull request&lt;/a&gt;.</source>
          <target state="translated">詳細について&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31166&quot;&gt;は、関連するプルリクエストを&lt;/a&gt;参照してください 。</target>
        </trans-unit>
        <trans-unit id="b92828c4a7429aa0dedb168e31c48305dd400088" translate="yes" xml:space="preserve">
          <source>For more information, please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2249&quot;&gt;Decorators&lt;/a&gt; proposal.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2249&quot;&gt;デコレータの&lt;/a&gt;提案を参照してください。</target>
        </trans-unit>
        <trans-unit id="e5cfc8aafd6a1b42f41322e6dfe173a4a83dcba5" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html&quot;&gt;TypeScript spec&lt;/a&gt;.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html&quot;&gt;TypeScript仕様を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7b6d8db7682d13acc39e4cc45f1bdba1511a9906" translate="yes" xml:space="preserve">
          <source>For more information, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33050&quot;&gt;read up on the original pull request&lt;/a&gt;.</source>
          <target state="translated">詳細について&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33050&quot;&gt;は、元のプルリクエストを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="343ef5950853198d94dec424b2d3547e8d8f6fca" translate="yes" xml:space="preserve">
          <source>For more information, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33509&quot;&gt;take a look at the original pull request for these changes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33509&quot;&gt;これらの変更の&lt;/a&gt;詳細については、 元のプルリクエストをご覧ください。</target>
        </trans-unit>
        <trans-unit id="705c8bb533b7a415fffecd94e72c06081d3e2f68" translate="yes" xml:space="preserve">
          <source>For non-relative module imports, however, the compiler walks up the directory tree starting with the directory containing the importing file, trying to locate a matching definition file.</source>
          <target state="translated">ただし、非相対モジュールインポートの場合、コンパイラはインポートファイルを含むディレクトリからディレクトリツリーを走査し、一致する定義ファイルを見つけようとします。</target>
        </trans-unit>
        <trans-unit id="fe8f9cb290ffb799bb30074ff74b3c823de4c1a0" translate="yes" xml:space="preserve">
          <source>For one, TypeScript can now make inferences for the return type of a call. This can improve your experience and catch errors. Something that now works:</source>
          <target state="translated">まず、TypeScriptは呼び出しの戻り値の型を推測できるようになりました。 これにより、エクスペリエンスが向上し、エラーがキャッチされます。 現在何が機能していますか：</target>
        </trans-unit>
        <trans-unit id="8e2e83bc37a28c5942c02bb933ef427bb23983d8" translate="yes" xml:space="preserve">
          <source>For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we support much the same types as you would expect in JavaScript, with a convenient enumeration type thrown in to help things along.</source>
          <target state="translated">プログラムが有用であるためには、数値、文字列、構造、ブール値などの最も単純なデータ単位を処理できる必要があります。 TypeScriptはJavaScriptで期待されるほぼ同じ型をサポートしますが、便利な列挙型をサポートします。</target>
        </trans-unit>
        <trans-unit id="d3344c32461a0db1e0c782f128f60f424dfe694b" translate="yes" xml:space="preserve">
          <source>For seasoned authors interested in the underlying mechanics of how declaration files work, the &lt;a href=&quot;deep-dive&quot;&gt;Deep Dive&lt;/a&gt; section explains many advanced concepts in declaration writing, and shows how to leverage these concepts to create cleaner and more intuitive declaration files.</source>
          <target state="translated">宣言ファイルの仕組みの基本的なメカニズムに興味のある経験豊富な著者向けに、 &lt;a href=&quot;deep-dive&quot;&gt;Deep Dive&lt;/a&gt;セクションでは、宣言作成の高度な概念の多くについて説明し、これらの概念を活用してより簡潔で直感的にします。 宣言ファイルを作成する方法を示します。</target>
        </trans-unit>
        <trans-unit id="13f368b0d84c902186b48234f4040bb16257c671" translate="yes" xml:space="preserve">
          <source>For that reason, we have no immediate plans to provide downleveling support. On the bright side, Node 11 and newer versions of Chrome already support this feature, so you&amp;rsquo;ll be able to use BigInts there when targeting &lt;code&gt;esnext&lt;/code&gt;.</source>
          <target state="translated">そのため、ダウンレベルのサポートを提供する当面の計画はありません。 明るい面では、Chrome Node 11以降のバージョンはすでにこの機能をサポートしているため、esnextをターゲットにするときにBigIntsを使用できます。</target>
        </trans-unit>
        <trans-unit id="a1b0a9136ffac4466c13d6e276a81e02a3314c15" translate="yes" xml:space="preserve">
          <source>For the most part, type declaration packages should always have the same name as the package name on &lt;code&gt;npm&lt;/code&gt;, but prefixed with &lt;code&gt;@types/&lt;/code&gt;, but if you need, you can check out &lt;a href=&quot;https://aka.ms/types&quot;&gt;https://aka.ms/types&lt;/a&gt; to find the package for your favorite library.</source>
          <target state="translated">ほとんどの場合、型宣言パッケージは常に &lt;code&gt;npm&lt;/code&gt; のパッケージ名と同じ名前にする必要がありますが、プレフィックス &lt;code&gt;@types/&lt;/code&gt; が必要ですが、必要に応じて&lt;a href=&quot;https://aka.ms/types&quot;&gt;https://aka.ms/typesを&lt;/a&gt;確認してください。 。</target>
        </trans-unit>
        <trans-unit id="034fabf95397dd3d830d8bf8625f29b5fecddc83" translate="yes" xml:space="preserve">
          <source>For the purposes of this article, &amp;ldquo;declaration merging&amp;rdquo; means that the compiler merges two separate declarations declared with the same name into a single definition. This merged definition has the features of both of the original declarations. Any number of declarations can be merged; it&amp;rsquo;s not limited to just two declarations.</source>
          <target state="translated">この記事の目的上、「宣言のマージ」とは、コンパイラーが同じ名前で宣言された2つの別々の宣言を1つの定義にマージすることを意味します。 このマージされた定義には、両方の元の宣言の機能があります。 宣言はいくつでもマージできます。 2つの宣言だけに限定されません。</target>
        </trans-unit>
        <trans-unit id="14bbf380d646374ad4976a37ddd3a52586d0778f" translate="yes" xml:space="preserve">
          <source>For the purposes of writing a declaration file, you&amp;rsquo;ll write the same code whether the module being changed is a plain module or UMD module.</source>
          <target state="translated">変更するモジュールがプレーンモジュールかUMDモジュールかに関係なく、同じコードを記述して宣言ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="4aa3bad258aff42d4d06a5737732c3217bc98418" translate="yes" xml:space="preserve">
          <source>For this feature and simplified props, be sure to be use the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react&quot;&gt;latest version of react.d.ts&lt;/a&gt;.</source>
          <target state="translated">この機能と簡略化された小道具には必ずreact.d.tsの最新バージョンを使用して&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react&quot;&gt;ください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="a33482387ee5a013d484cb5ab80e458b7353dca7" translate="yes" xml:space="preserve">
          <source>For those unfamiliar, &lt;code&gt;setTimeout&lt;/code&gt; will try to execute a function after a certain number of milliseconds (though waiting for anything else to stop running).</source>
          <target state="translated">慣れていない人のために、 &lt;code&gt;setTimeout&lt;/code&gt; は特定のミリ秒後に関数を実行しようとします（ただし、他の何かが実行を停止するのを待ちます）。</target>
        </trans-unit>
        <trans-unit id="a2a4c15a4041ed86596a75791caa9f86b76bf038" translate="yes" xml:space="preserve">
          <source>For value-based elements, it is a bit more complex. It is determined by the type of a property on the &lt;em&gt;element instance type&lt;/em&gt; that was previously determined. Which property to use is determined by &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt;. It should be declared with a single property. The name of that property is then used. As of TypeScript 2.8, if &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; is not provided, the type of first parameter of the class element&amp;rsquo;s constructor or Function Component&amp;rsquo;s call will be used instead.</source>
          <target state="translated">値ベースの要素の場合、物事はもう少し複雑です。 これは、以前に決定された&lt;em&gt;要素インスタンスタイプ&lt;/em&gt; &lt;em&gt;の&lt;/em&gt;プロパティの&lt;em&gt;タイプ&lt;/em&gt;によって決定され&lt;em&gt;ます&lt;/em&gt; 。 &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; のプロパティは、 JSX.ElementAttributesPropertyによって決定されます。 単一のプロパティで宣言する必要があります。 プロパティの名前が使用されます。 TypeScript 2.8現在、 &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; が提供されていない場合、クラス要素のコンストラクターまたは関数コンポーネント呼び出しの最初のパラメーターのタイプが代わりに使用されます。</target>
        </trans-unit>
        <trans-unit id="cd4106b2c3bf5670711745c735fa13bc35a27218" translate="yes" xml:space="preserve">
          <source>From TypeScript 3.7 and onwards, you can use &lt;a href=&quot;release-notes/typescript-3-7#optional-chaining&quot;&gt;optional chaining&lt;/a&gt; to simplify working with nullable types.</source>
          <target state="translated">TypeScript 3.7以降では、 &lt;a href=&quot;release-notes/typescript-3-7#optional-chaining&quot;&gt;オプションのチェーン&lt;/a&gt;を使用して、null許容型の操作を簡素化できます。</target>
        </trans-unit>
        <trans-unit id="2c70347006d57179eb4e0296dfeec4d48fd56374" translate="yes" xml:space="preserve">
          <source>From a Global Library</source>
          <target state="translated">グローバルライブラリから</target>
        </trans-unit>
        <trans-unit id="7a9218b43b092d03a0883f8b7857dbb282cdf813" translate="yes" xml:space="preserve">
          <source>From a Module or UMD Library</source>
          <target state="translated">モジュールまたはUMDライブラリから</target>
        </trans-unit>
        <trans-unit id="3f9c703cb24035f076046daf82d5597961381bc0" translate="yes" xml:space="preserve">
          <source>From a PowerShell command window, run:</source>
          <target state="translated">PowerShellコマンドウィンドウから、次を実行します。</target>
        </trans-unit>
        <trans-unit id="108836dc86d3f675e6c3eef00af882d27efb9073" translate="yes" xml:space="preserve">
          <source>From there you&amp;rsquo;ll be able to use lodash in your TypeScript code with no fuss. This works for both modules and global code.</source>
          <target state="translated">そこから、TypeScriptコードで大騒ぎせずにlodashを使用できます。 これは、モジュールとグローバルコードの両方で機能します。</target>
        </trans-unit>
        <trans-unit id="50c9f7eb832e49ced6feaff6d4be4040d50a7444" translate="yes" xml:space="preserve">
          <source>From this point on, we&amp;rsquo;re going to assume that your directory is set up something like this:</source>
          <target state="translated">この時点から、ディレクトリが次のように設定されていると仮定します。</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="1177b1db377a31fa211c1c837c048902a33fbabc" translate="yes" xml:space="preserve">
          <source>Function Component</source>
          <target state="translated">機能部品</target>
        </trans-unit>
        <trans-unit id="14e60fa4031e0e6cd85f9e19b012d6dbfc7853ec" translate="yes" xml:space="preserve">
          <source>Function Component (FC)</source>
          <target state="translated">機能コンポーネント（FC）</target>
        </trans-unit>
        <trans-unit id="957953f67e0718500a80224139b161eb239e35fa" translate="yes" xml:space="preserve">
          <source>Function Components in React</source>
          <target state="translated">React関数コンポーネント</target>
        </trans-unit>
        <trans-unit id="37eaf4a6db3ea0747ab9364bd4d5e24895e0a544" translate="yes" xml:space="preserve">
          <source>Function Overloads</source>
          <target state="translated">関数のオーバーロード</target>
        </trans-unit>
        <trans-unit id="a258c02eba54e3e0953a40abe8602fb6e1a74ef6" translate="yes" xml:space="preserve">
          <source>Function Parameter Bivariance</source>
          <target state="translated">関数パラメーターのバイバリアンス</target>
        </trans-unit>
        <trans-unit id="c57d64280c18c54778c8d1947833e0036b6e26da" translate="yes" xml:space="preserve">
          <source>Function Truthy Checks</source>
          <target state="translated">関数の真実を確認する</target>
        </trans-unit>
        <trans-unit id="5b51ae5c386fcffd7ce1ff55e49610a2a8af3637" translate="yes" xml:space="preserve">
          <source>Function Types</source>
          <target state="translated">機能タイプ</target>
        </trans-unit>
        <trans-unit id="301ffb948f7d729015635b11db6553b40624b34f" translate="yes" xml:space="preserve">
          <source>Function declarations</source>
          <target state="translated">関数宣言</target>
        </trans-unit>
        <trans-unit id="c5db83a75bbeef08fa2e0b320c74460786ae66aa" translate="yes" xml:space="preserve">
          <source>Function parameters are checked one at a time, with the type in each corresponding parameter position checked against each other. If you do not want to specify types at all, TypeScript&amp;rsquo;s contextual typing can infer the argument types since the function value is assigned directly to a variable of type &lt;code&gt;SearchFunc&lt;/code&gt;. Here, also, the return type of our function expression is implied by the values it returns (here &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">関数パラメーターは一度に1つずつ検査され、対応する各パラメーター位置のタイプは相互に検査されます。 型をまったく指定したくない場合、関数値は &lt;code&gt;SearchFunc&lt;/code&gt; 型の変数に直接割り当てられるため、TypeScriptコンテキストタイピングは引数の型を推測できます。 繰り返しますが、関数式の戻り値の型は、それが返す値によって暗示されます（ここでは、 &lt;code&gt;false&lt;/code&gt; と &lt;code&gt;true&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="53ffe91c4f4d77a902ebdf074913f42349003bbc" translate="yes" xml:space="preserve">
          <source>Function parameters are optional by default</source>
          <target state="translated">関数パラメーターはデフォルトでオプションです</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="f3665432e1a6db576efaea1b6e2d8f839bcdcc98" translate="yes" xml:space="preserve">
          <source>Functions are the fundamental building block of any application in JavaScript. They&amp;rsquo;re how you build up layers of abstraction, mimicking classes, information hiding, and modules. In TypeScript, while there are classes, namespaces, and modules, functions still play the key role in describing how to &lt;em&gt;do&lt;/em&gt; things. TypeScript also adds some new capabilities to the standard JavaScript functions to make them easier to work with.</source>
          <target state="translated">関数は、JavaScriptアプリケーションの基本的な構成要素です。 それらは、抽象化、模倣クラス、情報隠蔽、およびモジュールの層を構築する方法です。 TypeScriptにはクラス、名前空間、およびモジュールがありますが、関数&lt;em&gt;は&lt;/em&gt;物事の&lt;em&gt;実行&lt;/em&gt;方法を説明する上で重要な役割を果たします。 また、TypeScriptは、標準のJavaScript関数にいくつかの新機能を追加して、操作しやすくしています。</target>
        </trans-unit>
        <trans-unit id="16cd3a7ed4cd7f04f6e352a9b0a671ae06c3867d" translate="yes" xml:space="preserve">
          <source>Functions with code paths that do not return a value in JS implicitly return &lt;code&gt;undefined&lt;/code&gt;. These can now be flagged by the compiler as implicit returns. The check is turned &lt;em&gt;off&lt;/em&gt; by default; use &lt;code&gt;--noImplicitReturns&lt;/code&gt; to turn it on.</source>
          <target state="translated">JSで値を返さないコードパスを持つ関数は、暗黙的に &lt;code&gt;undefined&lt;/code&gt; を返します。 これらは、コンパイラーによって暗黙的な戻りとしてフラグを立てられるようになりました。 デフォルトでは、チェックは&lt;em&gt;オフになってい&lt;/em&gt;ます。 &lt;code&gt;--noImplicitReturns&lt;/code&gt; の使用を返します--noImplicitReturns。</target>
        </trans-unit>
        <trans-unit id="ecfd08105c3b9ed934caafb326908c0acb570490" translate="yes" xml:space="preserve">
          <source>Functions with overloads</source>
          <target state="translated">オーバーロードのある関数</target>
        </trans-unit>
        <trans-unit id="4f257e8843abb1bab8a5b85a60f95a4c0139aa46" translate="yes" xml:space="preserve">
          <source>Functions: this</source>
          <target state="translated">機能：これ</target>
        </trans-unit>
        <trans-unit id="6089bda1a34a0c953770c8e3b78bec0ef08e1cc9" translate="yes" xml:space="preserve">
          <source>Furthermore, TypeScript also has the notion of &lt;em&gt;global&lt;/em&gt; augmentations of the form &lt;code&gt;declare global { }&lt;/code&gt;. This allows modules to augment global types such as &lt;code&gt;Array&lt;/code&gt; if necessary.</source>
          <target state="translated">さらに、TypeScriptには、 &lt;code&gt;declare global { }&lt;/code&gt; という形式の&lt;em&gt;グローバル&lt;/em&gt;拡張の概念があります。 これにより、モジュールは必要に応じて &lt;code&gt;Array&lt;/code&gt; などのグローバルタイプを拡張できます。</target>
        </trans-unit>
        <trans-unit id="4df80e4187f2b8baf6d47a6fdeef464676adeda2" translate="yes" xml:space="preserve">
          <source>Furthermore, in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, control flow based type analysis includes &lt;em&gt;definite assignment analysis&lt;/em&gt; for local variables of types that don&amp;rsquo;t permit the value &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">さらに、-- &lt;code&gt;--strictNullChecks&lt;/code&gt; モードでは、制御フローベースの型分析には、値 &lt;code&gt;undefined&lt;/code&gt; を許可しない型のローカル変数の&lt;em&gt;明示的な割り当て分析&lt;/em&gt;が含まれます。</target>
        </trans-unit>
        <trans-unit id="b94633d2f5a1028f484d02bb58c0c7929a0b9214" translate="yes" xml:space="preserve">
          <source>Furthermore, with the &lt;code&gt;keyof&lt;/code&gt; operator&amp;rsquo;s support for &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named keys, it is now possible to abstract over access to properties of objects that are indexed by numeric literals (such as numeric enum types) and unique symbols.</source>
          <target state="translated">さらに、 &lt;code&gt;keyof&lt;/code&gt; 演算子のキーおよび名前付きキーのサポートにより、数値リテラル（数値列挙など）および一意のシンボルによってインデックス付けされたオブジェクトのプロパティへの抽象化アクセスが可能になります。</target>
        </trans-unit>
        <trans-unit id="0c7eb0b3402889bd567c0d3af8902acae19e04ce" translate="yes" xml:space="preserve">
          <source>General Types</source>
          <target state="translated">一般的なタイプ</target>
        </trans-unit>
        <trans-unit id="b2fce69037144d8c17c57e4cd48ef47f73df98fb" translate="yes" xml:space="preserve">
          <source>Generated JS code:</source>
          <target state="translated">生成されたJSコード：</target>
        </trans-unit>
        <trans-unit id="819ddb970af7944124739b463d184873a1a7a985" translate="yes" xml:space="preserve">
          <source>Generates a cpu profile at the given path. Passing an existing directory name instead of a file path will cause a timestamp-named profile to be generated in that directory instead.</source>
          <target state="translated">指定されたパスでCPUプロファイルを生成します。 ファイルパスではなく既存のディレクトリ名を渡すと、そのディレクトリのタイムスタンプ名プロファイルが代わりに生成されます。</target>
        </trans-unit>
        <trans-unit id="2d8f07103db6977c68e0ada027ab65c5c23862d9" translate="yes" xml:space="preserve">
          <source>Generates a sourcemap for each corresponding &amp;lsquo;.d.ts&amp;rsquo; file.</source>
          <target state="translated">対応する「.d.ts」ファイルごとにソースマップを生成します。</target>
        </trans-unit>
        <trans-unit id="a2e42f3b65f8aeda6abb391f2b5c0feb9f71f346" translate="yes" xml:space="preserve">
          <source>Generates corresponding &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="translated">対応する &lt;code&gt;.d.ts&lt;/code&gt; ファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="285e568bc8b6f7ba3db03d758216b4279b6fb84a" translate="yes" xml:space="preserve">
          <source>Generates corresponding &lt;code&gt;.map&lt;/code&gt; file.</source>
          <target state="translated">対応する &lt;code&gt;.map&lt;/code&gt; ファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="0edb628a9542a14f813bd7de9f8386b56c8a58b5" translate="yes" xml:space="preserve">
          <source>Generates:</source>
          <target state="translated">Generates:</target>
        </trans-unit>
        <trans-unit id="a3e705cc61a19f33d7c9c030f107a70569966485" translate="yes" xml:space="preserve">
          <source>Generators</source>
          <target state="translated">Generators</target>
        </trans-unit>
        <trans-unit id="44da76948f45623de7d336c343233faa5d2b509e" translate="yes" xml:space="preserve">
          <source>Generators and Iteration for ES5/ES3</source>
          <target state="translated">ES5 / ES3ジェネレーターと反復</target>
        </trans-unit>
        <trans-unit id="052f4c16b4b91a827312bf3baa166ba53bfe5efa" translate="yes" xml:space="preserve">
          <source>Generic Classes</source>
          <target state="translated">ジェネリッククラス</target>
        </trans-unit>
        <trans-unit id="c1219cf49a0e939b3e16bf04e12e2eafc84ee7fd" translate="yes" xml:space="preserve">
          <source>Generic Constraints</source>
          <target state="translated">一般的な制約</target>
        </trans-unit>
        <trans-unit id="6e69a2fc2c745899f35839a75d651978ee056569" translate="yes" xml:space="preserve">
          <source>Generic Types</source>
          <target state="translated">ジェネリック型</target>
        </trans-unit>
        <trans-unit id="15d759be2080d6d18e338e98d07714f4c409146a" translate="yes" xml:space="preserve">
          <source>Generic object rest variables and parameters</source>
          <target state="translated">汎用オブジェクトの残りの変数とパラメーター</target>
        </trans-unit>
        <trans-unit id="1fdeebd1c396649ca4cc647737cc5d4a10b10b8f" translate="yes" xml:space="preserve">
          <source>Generic parameter defaults</source>
          <target state="translated">汎用パラメーターのデフォルト</target>
        </trans-unit>
        <trans-unit id="001622f41013d0601ab935e2183da475e787cfd4" translate="yes" xml:space="preserve">
          <source>Generic rest parameters</source>
          <target state="translated">一般的なブレークパラメーター</target>
        </trans-unit>
        <trans-unit id="ee51cfb54175ecd5fb6d2ccc67d80a3554912ff7" translate="yes" xml:space="preserve">
          <source>Generic rest parameters and corresponding inference of tuple types.</source>
          <target state="translated">汎用の残りのパラメーターと対応するタプル型推論。</target>
        </trans-unit>
        <trans-unit id="77980b7a1bd9bc29a811f3721a4ca0efc1244e89" translate="yes" xml:space="preserve">
          <source>Generic spread expressions in object literals</source>
          <target state="translated">オブジェクトリテラルの一般的なスプレッド式</target>
        </trans-unit>
        <trans-unit id="a62000d34890a9f512301dfa28ec7342f3e45eb8" translate="yes" xml:space="preserve">
          <source>Generic type aliases</source>
          <target state="translated">ジェネリック型エイリアス</target>
        </trans-unit>
        <trans-unit id="92dacb7528945ed9815a679921369b1471575a3f" translate="yes" xml:space="preserve">
          <source>Generic type arguments in JSX elements</source>
          <target state="translated">JSX要素のジェネリック型引数</target>
        </trans-unit>
        <trans-unit id="f865cd9dc0cd462591b83a2927cb41d99ab230cd" translate="yes" xml:space="preserve">
          <source>Generic type arguments in generic tagged templates</source>
          <target state="translated">汎用タグ付きテンプレートの汎用型引数</target>
        </trans-unit>
        <trans-unit id="80dadd86173d0ff3979257793d4e45beb238b6a2" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generics</target>
        </trans-unit>
        <trans-unit id="4d9ef11b75691cea9a6edfb497c3b9914c3b1021" translate="yes" xml:space="preserve">
          <source>Generics: Types</source>
          <target state="translated">ジェネリック：タイプ</target>
        </trans-unit>
        <trans-unit id="00a40ea9152c19baaaa2f05a471ec1e36c25f25b" translate="yes" xml:space="preserve">
          <source>Get started with a simple TypeScript app.</source>
          <target state="translated">シンプルなTypeScriptアプリを使い始めましょう。</target>
        </trans-unit>
        <trans-unit id="5ef75e8c40e485b27abd25b4a16247e142017634" translate="yes" xml:space="preserve">
          <source>Getting Declaration Files</source>
          <target state="translated">宣言ファイルを取得</target>
        </trans-unit>
        <trans-unit id="9ed37766bb349044c2259b48865fbf239e26a5e7" translate="yes" xml:space="preserve">
          <source>Getting Stricter Checks</source>
          <target state="translated">より厳密なチェックを取得する</target>
        </trans-unit>
        <trans-unit id="b7b2818d4eceb3a3c55e7b64b0c852e4d5109657" translate="yes" xml:space="preserve">
          <source>Getting around these checks is actually really simple. The easiest method is to just use a type assertion:</source>
          <target state="translated">これらのチェックを避けることは、実際には非常に簡単です。 最も簡単な方法は、型アサーションを使用することです。</target>
        </trans-unit>
        <trans-unit id="1ed2ad4b9d2d91f971b1ebd9e80d9238f9735423" translate="yes" xml:space="preserve">
          <source>Getting to ES6/ES2015 built-in API declarations were only limited to &lt;code&gt;target: ES6&lt;/code&gt;. Enter &lt;code&gt;--lib&lt;/code&gt;; with &lt;code&gt;--lib&lt;/code&gt; you can specify a list of built-in API declaration groups that you can chose to include in your project. For instance, if you expect your runtime to have support for &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Promise&lt;/code&gt; (e.g. most evergreen browsers today), just include &lt;code&gt;--lib es2015.collection,es2015.promise&lt;/code&gt;. Similarly you can exclude declarations you do not want to include in your project, e.g. DOM if you are working on a node project using &lt;code&gt;--lib es5,es6&lt;/code&gt;.</source>
          <target state="translated">ターゲット &lt;code&gt;target: ES6&lt;/code&gt; からES6 / ES2015組み込みAPI宣言、ターゲットES6のみに制限されています。 &lt;code&gt;--lib&lt;/code&gt; と入力します 。 &lt;code&gt;--lib&lt;/code&gt; 、プロジェクトに含めることを選択できる組み込みAPI宣言グループのリストを指定できます。 たとえば、ランタイムが &lt;code&gt;Map&lt;/code&gt; 、 &lt;code&gt;Set&lt;/code&gt; 、および &lt;code&gt;--lib es2015.collection,es2015.promise&lt;/code&gt; （今日のほとんどの常緑ブラウザ）のサポートを期待している場合、-- lib es2015.collection、es2015.promiseを含めるだけです。 同様に、たとえば &lt;code&gt;--lib es5,es6&lt;/code&gt; ように、プロジェクトに含めたくない宣言があるノードプロジェクトで作業している場合は、DOMを除外できます。</target>
        </trans-unit>
        <trans-unit id="ca2334233ff9d62586c90c8425d61ccf0156ad00" translate="yes" xml:space="preserve">
          <source>Getting type declarations in TypeScript 2.0 and above requires no tools apart from npm.</source>
          <target state="translated">TypeScript 2.0以降で型宣言を取得するには、npm以外のツールは必要ありません。</target>
        </trans-unit>
        <trans-unit id="0128ee2411d4cce5db2af199ae139a20b41fb10c" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;&amp;lt;Expr /&amp;gt;&lt;/code&gt;, the &lt;em&gt;element class type&lt;/em&gt; is the type of &lt;code&gt;Expr&lt;/code&gt;. So in the example above, if &lt;code&gt;MyComponent&lt;/code&gt; was an ES6 class the class type would be that class&amp;rsquo;s constructor and statics. If &lt;code&gt;MyComponent&lt;/code&gt; was a factory function, the class type would be that function.</source>
          <target state="translated">&lt;code&gt;&amp;lt;Expr /&amp;gt;&lt;/code&gt; が指定されている場合、 &lt;em&gt;要素クラスタイプ&lt;/em&gt;は &lt;code&gt;Expr&lt;/code&gt; タイプになります。 したがって、上記の例では、 &lt;code&gt;MyComponent&lt;/code&gt; がES6クラスである場合、クラスタイプはクラスのコンストラクターおよび静的クラスになります。 &lt;code&gt;MyComponent&lt;/code&gt; はファクトリ関数であり、クラスタイプはその関数になります。</target>
        </trans-unit>
        <trans-unit id="975e78d60e0d980036725e953131ac369a323b6f" translate="yes" xml:space="preserve">
          <source>Given a declaration of a class &lt;code&gt;Pet&lt;/code&gt; in a module file:</source>
          <target state="translated">モジュールファイル内のクラス &lt;code&gt;Pet&lt;/code&gt; の宣言がある場合：</target>
        </trans-unit>
        <trans-unit id="8083d6ae5a9d183ac1a96bad2a32806cb23140c9" translate="yes" xml:space="preserve">
          <source>Given a name &lt;code&gt;A&lt;/code&gt;, we might find up to three different meanings for &lt;code&gt;A&lt;/code&gt;: a type, a value or a namespace. How the name is interpreted depends on the context in which it is used. For example, in the declaration &lt;code&gt;let m: A.A = A;&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is used first as a namespace, then as a type name, then as a value. These meanings might end up referring to entirely different declarations!</source>
          <target state="translated">名前Aを指定すると、Aの最大3つの異なる意味、型、値、または名前空間を見つけることができます。名前の解釈方法は、使用するコンテキストによって異なります。 たとえば、宣言で &lt;code&gt;let m: A.A = A;&lt;/code&gt; ここで、 &lt;code&gt;A&lt;/code&gt; は最初にネームスペースとして、次にタイプ名として、次に値として使用されます。 これらの意味は、まったく異なる宣言を指します！</target>
        </trans-unit>
        <trans-unit id="a00264a5f3c6cd0479bb605da5bdecfcbf5f69bb" translate="yes" xml:space="preserve">
          <source>Given an expression &lt;code&gt;Base&lt;/code&gt; of a parametric type &lt;code&gt;T&lt;/code&gt; with a constraint &lt;code&gt;X&lt;/code&gt;, a mixin class &lt;code&gt;class C extends Base {...}&lt;/code&gt; is processed as if &lt;code&gt;Base&lt;/code&gt; had type &lt;code&gt;X&lt;/code&gt; and the resulting type is the intersection &lt;code&gt;typeof C &amp;amp; T&lt;/code&gt;. In other words, a mixin class is represented as an intersection between the mixin class constructor type and the parametric base class constructor type.</source>
          <target state="translated">制約 &lt;code&gt;X&lt;/code&gt; を持つパラメトリックタイプ &lt;code&gt;T&lt;/code&gt; の式 &lt;code&gt;Base&lt;/code&gt; が与えられると、ミックスインクラス &lt;code&gt;class C extends Base {...}&lt;/code&gt; 、 &lt;code&gt;Base&lt;/code&gt; をタイプ &lt;code&gt;X&lt;/code&gt; を持ち、結果のタイプを &lt;code&gt;typeof C &amp;amp; T&lt;/code&gt; 共通部分として扱いますつまり、ミックスインクラスは、ミックスインクラスコンストラクタータイプとパラメトリックベースクラスコンストラクタータイプの共通部分として表されます。</target>
        </trans-unit>
        <trans-unit id="f747221667578c67b9937edae87fe4b1bb4a08b1" translate="yes" xml:space="preserve">
          <source>Given an object type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;keyof X&lt;/code&gt; is resolved as follows:</source>
          <target state="translated">オブジェクト型 &lt;code&gt;X&lt;/code&gt; が与えられると、 &lt;code&gt;keyof X&lt;/code&gt; は次のように解決されます。</target>
        </trans-unit>
        <trans-unit id="fa581e6e08169205d8be1ad319fd8832a173be18" translate="yes" xml:space="preserve">
          <source>Given that we have two types of declarations with similar scoping semantics, it&amp;rsquo;s natural to find ourselves asking which one to use. Like most broad questions, the answer is: it depends.</source>
          <target state="translated">同様のスコープセマンティクスを持つ宣言には2つのタイプがあるため、どちらを使用するかを尋ねるのは自然なことです。 最も一般的な質問と同様に、答えは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="610048c0b076b1fb8790fd96c3fc109500ce0670" translate="yes" xml:space="preserve">
          <source>Given this project structure:</source>
          <target state="translated">このプロジェクト構造を検討してください。</target>
        </trans-unit>
        <trans-unit id="05ab21d96c8cc217d9d3bf8ed1a8cf0dc14dc590" translate="yes" xml:space="preserve">
          <source>Glob support in &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; グローブのサポート</target>
        </trans-unit>
        <trans-unit id="ee29cd5c1e941ea77b1bcc2b4464658a76d6b503" translate="yes" xml:space="preserve">
          <source>Glob support is here!! Glob support has been &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1927&quot;&gt;one of the most requested features&lt;/a&gt;.</source>
          <target state="translated">グローブのサポートについては、ここをクリックしてください!! グローブサポートは&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1927&quot;&gt;、最も要望の多い機能の&lt;/a&gt; 1つです 。</target>
        </trans-unit>
        <trans-unit id="26021db1ea30cf082e152c820806cb17b431aff1" translate="yes" xml:space="preserve">
          <source>Glob-like file patterns are supported two properties &lt;code&gt;&quot;include&quot;&lt;/code&gt; and &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;.</source>
          <target state="translated">グローブのようなファイルパターン &lt;code&gt;&quot;include&quot;&lt;/code&gt; 、 「include」と &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 2つのプロパティをサポートします。</target>
        </trans-unit>
        <trans-unit id="ae4f56ae4da16df74b3d2aeca8b4352281e7be45" translate="yes" xml:space="preserve">
          <source>Global Functions</source>
          <target state="translated">グローバル機能</target>
        </trans-unit>
        <trans-unit id="bb90b4e7b4f156d78c1c4607edb92deecea2726f" translate="yes" xml:space="preserve">
          <source>Global Libraries</source>
          <target state="translated">グローバル図書館</target>
        </trans-unit>
        <trans-unit id="086706851e81b0cda50c1ad12a71bbbe92f2b609" translate="yes" xml:space="preserve">
          <source>Global Library Template</source>
          <target state="translated">グローバルライブラリテンプレート</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes" xml:space="preserve">
          <source>Global Variables</source>
          <target state="translated">グローバル変数</target>
        </trans-unit>
        <trans-unit id="f939f94390f04e9a571e774b88f07fa51a7034c9" translate="yes" xml:space="preserve">
          <source>Global augmentation</source>
          <target state="translated">グローバル強化</target>
        </trans-unit>
        <trans-unit id="d9627061a8f161c085d6425d99b5bcd04461ec21" translate="yes" xml:space="preserve">
          <source>Global augmentations have the same behavior and limits as module augmentations.</source>
          <target state="translated">グローバル拡張には、モジュール拡張と同じ動作と制限があります。</target>
        </trans-unit>
        <trans-unit id="551b0be00de6f59a327fffe248fc43dd021a48e0" translate="yes" xml:space="preserve">
          <source>Global library code is usually extremely simple. A global &amp;ldquo;Hello, world&amp;rdquo; library might look like this:</source>
          <target state="translated">通常、グローバルライブラリコードは非常に単純です。 グローバルな「Hello、world」ライブラリは次のようになります。</target>
        </trans-unit>
        <trans-unit id="a2a3ce92a02e2b38f5f0131a3a2a15d9bd6e27fc" translate="yes" xml:space="preserve">
          <source>Global plugins are generally easy to identify from their documentation.</source>
          <target state="translated">通常、グローバルプラグインはドキュメントから簡単に識別できます。</target>
        </trans-unit>
        <trans-unit id="4f705c81915f4a397894296d2b81a9e9f219df5d" translate="yes" xml:space="preserve">
          <source>Global-modifying modules are generally easy to identify from their documentation. In general, they&amp;rsquo;re similar to global plugins, but need a &lt;code&gt;require&lt;/code&gt; call to activate their effects.</source>
          <target state="translated">一般に、グローバル変更モジュールはドキュメントから簡単に識別できます。 一般に、これらはグローバルプラグインに似ていますが、エフェクトを有効に &lt;code&gt;require&lt;/code&gt; は呼び出しが必要です 。</target>
        </trans-unit>
        <trans-unit id="24713d72fbb7ed9e4d613388f61f4edcd1171735" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;File&lt;/code&gt; &amp;gt; &lt;code&gt;Settings&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt;:</source>
          <target state="translated">[ &lt;code&gt;File&lt;/code&gt; &lt;code&gt;Settings&lt;/code&gt; &amp;gt; [設定]&amp;gt; [ &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; ]&amp;gt; [ &lt;code&gt;TypeScript&lt;/code&gt; ]に移動します。</target>
        </trans-unit>
        <trans-unit id="cb7da868a3e2b03846cee16319e4528c9916294a" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;Preferences&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt;:</source>
          <target state="translated">[ &lt;code&gt;Preferences&lt;/code&gt; &amp;gt; [ &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; ]&amp;gt; [ &lt;code&gt;TypeScript&lt;/code&gt; ]に移動します。</target>
        </trans-unit>
        <trans-unit id="c06ca0601da1369de3d0247e6e4f8b7bbe8e4bfd" translate="yes" xml:space="preserve">
          <source>Grunt</source>
          <target state="translated">Grunt</target>
        </trans-unit>
        <trans-unit id="b5e0b544d4f7e5ecf776c530d4637f9254bfad0b" translate="yes" xml:space="preserve">
          <source>Guidance</source>
          <target state="translated">Guidance</target>
        </trans-unit>
        <trans-unit id="6b06b3debeeac8b24443fbaf25e471200f47e47b" translate="yes" xml:space="preserve">
          <source>Guidance for structuring modules</source>
          <target state="translated">モジュールを構築するためのガイダンス</target>
        </trans-unit>
        <trans-unit id="5a6238801e2733bcdc7249e97a255df97e530fc4" translate="yes" xml:space="preserve">
          <source>Gulp</source>
          <target state="translated">Gulp</target>
        </trans-unit>
        <trans-unit id="79914411b3c89953fe030c6c8025f0574c41a8f8" translate="yes" xml:space="preserve">
          <source>Gulp: Add modules to the code</source>
          <target state="translated">Gulp：コードへのモジュールの追加</target>
        </trans-unit>
        <trans-unit id="21e98a38e254fad84f4a4bbd9e8fa3fea802a72c" translate="yes" xml:space="preserve">
          <source>Gulp: Babel</source>
          <target state="translated">ガルプ：バベル</target>
        </trans-unit>
        <trans-unit id="c3699841f2d588970283b562ce18c4a12378b39f" translate="yes" xml:space="preserve">
          <source>Gulp: Browserify</source>
          <target state="translated">Gulp：Browserify</target>
        </trans-unit>
        <trans-unit id="67718aa41c7c302d8015e6a1f55245492dfe7b5f" translate="yes" xml:space="preserve">
          <source>Gulp: Create a gulpfile.js</source>
          <target state="translated">Gulp：gulpfile.jsを作成します</target>
        </trans-unit>
        <trans-unit id="d5f376a8524ce9e40602f913685d1f14707f0f24" translate="yes" xml:space="preserve">
          <source>Gulp: Create a page</source>
          <target state="translated">Gulp：ページの作成</target>
        </trans-unit>
        <trans-unit id="26f1b5afe4ab8f7ba7d8e64daae6616d336e7b8d" translate="yes" xml:space="preserve">
          <source>Gulp: Initialize the project</source>
          <target state="translated">Gulp：プロジェクトの初期化</target>
        </trans-unit>
        <trans-unit id="89ec650baa395d7c6395a96eac5b8b07e6aefed3" translate="yes" xml:space="preserve">
          <source>Gulp: Install our dependencies</source>
          <target state="translated">Gulp：依存関係のインストール</target>
        </trans-unit>
        <trans-unit id="94ff547657bd3ea294e187a2a5b6c4e9da41ae2e" translate="yes" xml:space="preserve">
          <source>Gulp: Minimal project</source>
          <target state="translated">Gulp：最小限のプロジェクト</target>
        </trans-unit>
        <trans-unit id="5bf88642d6a4c72b1400115e631d3c1241d0a62f" translate="yes" xml:space="preserve">
          <source>Gulp: Test the resulting app</source>
          <target state="translated">Gulp：結果のアプリのテスト</target>
        </trans-unit>
        <trans-unit id="5c5e381120e6ca17177cab8dd1c9b114707b4f32" translate="yes" xml:space="preserve">
          <source>Gulp: Uglify</source>
          <target state="translated">Gulp：Uglify</target>
        </trans-unit>
        <trans-unit id="378ef94af067892dc3f571669da77f2d28b9d848" translate="yes" xml:space="preserve">
          <source>Gulp: Watchify</source>
          <target state="translated">Gulp：Watchify</target>
        </trans-unit>
        <trans-unit id="339b09b31f6400bfbd9df2cc056c03bbce7e1947" translate="yes" xml:space="preserve">
          <source>Gulp: Write a simple example</source>
          <target state="translated">Gulp：簡単な例を書く</target>
        </trans-unit>
        <trans-unit id="28e2147303cd82753a34e2e9e286d0181633c0c4" translate="yes" xml:space="preserve">
          <source>Had the function expression returned numbers or strings, the type checker would have made an error that indicates return type doesn&amp;rsquo;t match the return type described in the &lt;code&gt;SearchFunc&lt;/code&gt; interface.</source>
          <target state="translated">関数式が数値または文字列を返した場合、型チェッカーは、戻り値の型が &lt;code&gt;SearchFunc&lt;/code&gt; インターフェイスに記述された戻り値の型と一致しなかったことを示すエラーを作成しました。</target>
        </trans-unit>
        <trans-unit id="9a7699299b167b02f3b309a214e186f89e6ac90a" translate="yes" xml:space="preserve">
          <source>Hello World of Generics</source>
          <target state="translated">Hello World of Generics</target>
        </trans-unit>
        <trans-unit id="4868c6cfe667dc94ff39de6f11b3b8c2dde32455" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;asserts val is string&lt;/code&gt; ensures that after any call to &lt;code&gt;assertIsString&lt;/code&gt;, any variable passed in will be known to be a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">ここで &lt;code&gt;asserts val is string&lt;/code&gt; 、 valが &lt;code&gt;assertIsString&lt;/code&gt; という文字列であることをアサートし 、 assertIsStringを呼び出した後、渡された変数が &lt;code&gt;string&lt;/code&gt; であることを確認します 。</target>
        </trans-unit>
        <trans-unit id="217c263c0612cdb8818f0c2bb1cc2cee17136759" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;map.ts&lt;/code&gt; can declare that it will internally patch the &lt;code&gt;Observable&lt;/code&gt; type from &lt;code&gt;observable.ts&lt;/code&gt; and add the &lt;code&gt;map&lt;/code&gt; method to it.</source>
          <target state="translated">ここで、 &lt;code&gt;map.ts&lt;/code&gt; は、 observable.tsから &lt;code&gt;Observable&lt;/code&gt; 型に内部的にパッチを適用し、それに &lt;code&gt;map&lt;/code&gt; メソッドを追加することを宣言できます。</target>
        </trans-unit>
        <trans-unit id="b504fd8672cd71981cb916f0743aeadaf081b517" translate="yes" xml:space="preserve">
          <source>Here are some notable differences on how checking works in &lt;code&gt;.js&lt;/code&gt; files compared to &lt;code&gt;.ts&lt;/code&gt; files:</source>
          <target state="translated">&lt;code&gt;.ts&lt;/code&gt; は、.tsファイルと比較した &lt;code&gt;.js&lt;/code&gt; ファイル内のチェックの動作におけるいくつかの顕著な違いです。</target>
        </trans-unit>
        <trans-unit id="14fd63d436a290048d4c1831116810e1e69345e4" translate="yes" xml:space="preserve">
          <source>Here is a list of available API groups:</source>
          <target state="translated">使用可能なAPIグループのリストは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="83f91cc0372adb4b62657eb83b59506603d1d14b" translate="yes" xml:space="preserve">
          <source>Here is a list of well-known symbols:</source>
          <target state="translated">よく知られているシンボルのリストは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d7c6390605af8c73015b19f7184792241b88e764" translate="yes" xml:space="preserve">
          <source>Here is a simple test for the calculator using the exposed &lt;code&gt;test&lt;/code&gt; function.</source>
          <target state="translated">以下は、公開 &lt;code&gt;test&lt;/code&gt; 機能を使用した電卓の簡単なテストです。</target>
        </trans-unit>
        <trans-unit id="d867fe52f6b4323b3aa6d543dd0bd5c2bb91d3f0" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates this distinction:</source>
          <target state="translated">次の例は、この区別を示しています。</target>
        </trans-unit>
        <trans-unit id="9d689481e7c027a1b04a6cc241ceab676b7e9d0f" translate="yes" xml:space="preserve">
          <source>Here the syntax starts to get confusing. You can read &lt;code&gt;a: newName1&lt;/code&gt; as &amp;ldquo;&lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt;&amp;rdquo;. The direction is left-to-right, as if you had written:</source>
          <target state="translated">ここで、構文が混乱し始めます。 &lt;code&gt;a: newName1&lt;/code&gt; newName1は &quot; &lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt; &quot;として読み取ることができます。 あなたが書いたように、方向は左から右です：</target>
        </trans-unit>
        <trans-unit id="0e7c23e184f2a3fc2239ba7dd64a12dacf4b5975" translate="yes" xml:space="preserve">
          <source>Here we explicitly set &lt;code&gt;T&lt;/code&gt; to be &lt;code&gt;string&lt;/code&gt; as one of the arguments to the function call, denoted using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; around the arguments rather than &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">ここでは、関数呼び出しの引数の1つとして &lt;code&gt;T&lt;/code&gt; を明示的に設定し、 &lt;code&gt;()&lt;/code&gt; 代わりに引数の周りに &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; を使用します</target>
        </trans-unit>
        <trans-unit id="4a521f4f8c69adda61863ae271ec13a08aca0267" translate="yes" xml:space="preserve">
          <source>Here we need to create a variable to hold on to the neighbor-map so that we can initialize it. With TypeScript 1.5, we can let the compiler do the heavy lifting:</source>
          <target state="translated">次に、隣接マップを保持して初期化できるように変数を作成する必要があります。 TypeScript 1.5を使用すると、コンパイラの時間を節約できます。</target>
        </trans-unit>
        <trans-unit id="f454fc62879aec4c05c5b0553ae23ecb3678fbdb" translate="yes" xml:space="preserve">
          <source>Here we were able to copy over all the properties of &lt;code&gt;Person&lt;/code&gt; except for &lt;code&gt;location&lt;/code&gt; using the &lt;code&gt;Omit&lt;/code&gt; helper.</source>
          <target state="translated">ここで、 &lt;code&gt;Omit&lt;/code&gt; はOmitヘルパーを使用して、 &lt;code&gt;location&lt;/code&gt; を除く &lt;code&gt;Person&lt;/code&gt; のすべてのプロパティをコピーできます。</target>
        </trans-unit>
        <trans-unit id="1036409900634ac21f92613c301ba8e5286a4bef" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re going to create a &lt;code&gt;Student&lt;/code&gt; class with a constructor and a few public fields. Notice that classes and interfaces play well together, letting the programmer decide on the right level of abstraction.</source>
          <target state="translated">ここでは、コンストラクターといくつかのパブリックフィールドを持つ &lt;code&gt;Student&lt;/code&gt; クラスを作成します。 クラスとインターフェースはうまく機能し、プログラマは適切な抽象化レベルを決定できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="285b0ed2d436f147e6b99b312065319a3bd9b594" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re specifying a few things to TypeScript:</source>
          <target state="translated">ここでは、TypeScriptにいくつかのことを指定します。</target>
        </trans-unit>
        <trans-unit id="371971b4f21066fe668fdda84538194651b56819" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a revised example:</source>
          <target state="translated">変更例を以下に示します。</target>
        </trans-unit>
        <trans-unit id="ecace45a094904ef8f89699739d61e7f83e4e706" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a simple example of an unreachable code error:</source>
          <target state="translated">到達不能コードエラーの簡単な例を次に示します。</target>
        </trans-unit>
        <trans-unit id="33855c52e889ba154150d2b3670aeb240d95c340" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of this pattern:</source>
          <target state="translated">以下はこのパターンの例です。</target>
        </trans-unit>
        <trans-unit id="4e232701f3c0f0553f27b93d9845181d7b9b01bd" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how you would write and use this function in TypeScript, using the &lt;strong&gt;index type query&lt;/strong&gt; and &lt;strong&gt;indexed access&lt;/strong&gt; operators:</source>
          <target state="translated">&lt;strong&gt;インデックスタイプのクエリ&lt;/strong&gt;と&lt;strong&gt;インデックス付きアクセス&lt;/strong&gt;演算子を使用して、TypeScriptでこの関数を記述して使用する方法を次に示し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb902d04d0d6f8c7ca19c25536908ff73f061681" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s one more example, in which &lt;code&gt;T[P]&lt;/code&gt; is wrapped in a &lt;code&gt;Proxy&amp;lt;T&amp;gt;&lt;/code&gt; class:</source>
          <target state="translated">&lt;code&gt;T[P]&lt;/code&gt; が &lt;code&gt;Proxy&amp;lt;T&amp;gt;&lt;/code&gt; クラスにラップされている別の例を次に示します。</target>
        </trans-unit>
        <trans-unit id="c2ea446bd29277ad18a8bf4252379c5046cdf44d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;SomeType&lt;/code&gt; appears to originate in both the &lt;code&gt;import&lt;/code&gt; declaration and the local &lt;code&gt;interface&lt;/code&gt; declaration. Perhaps surprisingly, inside the module, &lt;code&gt;SomeType&lt;/code&gt; refers exclusively to the &lt;code&gt;import&lt;/code&gt;ed definition, and the local declaration &lt;code&gt;SomeType&lt;/code&gt; is only usable when imported from another file. This is very confusing and our review of the very small number of cases of code like this in the wild showed that developers usually thought something different was happening.</source>
          <target state="translated">ここで、 &lt;code&gt;SomeType&lt;/code&gt; は &lt;code&gt;import&lt;/code&gt; とローカルの両方の &lt;code&gt;interface&lt;/code&gt; 宣言から来ているようです。 おそらく驚くべきことに、モジュール内では、 &lt;code&gt;SomeType&lt;/code&gt; はインポートされた定義を &lt;code&gt;SomeType&lt;/code&gt; でのみ使用でき、ローカル宣言SomeTypeは別のファイルからインポートされた場合にのみ使用できます。 これは非常に紛らわしく、そのようなコードのごくわずかなケースのレビューでは、開発者は通常、何か別のことが起こっていると考えていたことが示されました。</target>
        </trans-unit>
        <trans-unit id="a3816a0ed94cd7ceadd9968bd7c237ebde8a5f88" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Up&lt;/code&gt; would have the value &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;Down&lt;/code&gt; would have &lt;code&gt;1&lt;/code&gt;, etc. This auto-incrementing behavior is useful for cases where we might not care about the member values themselves, but do care that each value is distinct from other values in the same enum.</source>
          <target state="translated">ここで、 &lt;code&gt;Up&lt;/code&gt; の値は &lt;code&gt;0&lt;/code&gt; 、 &lt;code&gt;Down&lt;/code&gt; の値は &lt;code&gt;1&lt;/code&gt; などです。 この自動インクリメントの動作は、メンバーの値自体を気にすることはありませんが、各値は同じ値の他の値とは異なることに注意してください。 列挙型。</target>
        </trans-unit>
        <trans-unit id="57a9abf556999c9646907cab4f7c7e1dc771a6d2" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;assertNever&lt;/code&gt; checks that &lt;code&gt;s&lt;/code&gt; is of type &lt;code&gt;never&lt;/code&gt; &amp;mdash; the type that&amp;rsquo;s left after all other cases have been removed. If you forget a case, then &lt;code&gt;s&lt;/code&gt; will have a real type and you will get a type error. This method requires you to define an extra function, but it&amp;rsquo;s much more obvious when you forget it.</source>
          <target state="translated">ここで、 &lt;code&gt;assertNever&lt;/code&gt; は &lt;code&gt;s&lt;/code&gt; のタイプが &lt;code&gt;never&lt;/code&gt; であることを検証します。 これは、他のすべてのケースが削除された後も残るタイプです。 大文字と小文字を忘れると、 &lt;code&gt;s&lt;/code&gt; は実際の型に設定され、型エラーが発生します。 この方法では、追加の関数を定義する必要がありますが、忘れるとさらに明確になります。</target>
        </trans-unit>
        <trans-unit id="d05882792ac23d4a8b28c31469c8bc7607445ef8" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;let Greeter&lt;/code&gt; is going to be assigned the constructor function. When we call &lt;code&gt;new&lt;/code&gt; and run this function, we get an instance of the class. The constructor function also contains all of the static members of the class. Another way to think of each class is that there is an &lt;em&gt;instance&lt;/em&gt; side and a &lt;em&gt;static&lt;/em&gt; side.</source>
          <target state="translated">ここで &lt;code&gt;let Greeter&lt;/code&gt; コンストラクター関数を割り当てます。 &lt;code&gt;new&lt;/code&gt; を呼び出してこの関数を実行すると、クラスのインスタンスが取得されます。 コンストラクター関数には、クラスのすべての静的メンバーも含まれます。 各クラスについて考えるもう1つの方法は、 &lt;em&gt;インスタンス&lt;/em&gt;側と&lt;em&gt;静的&lt;/em&gt;側があるということです。</target>
        </trans-unit>
        <trans-unit id="8dc42a1abbc3302381c653975f640c8b543442a7" translate="yes" xml:space="preserve">
          <source>Here, TypeScript will climb up &lt;code&gt;node_modules&lt;/code&gt; folders looking for a &lt;code&gt;@my-team/tsconfig-base&lt;/code&gt; package. For each of those packages, TypeScript will first check whether &lt;code&gt;package.json&lt;/code&gt; contains a &lt;code&gt;&quot;tsconfig&quot;&lt;/code&gt; field, and if it does, TypeScript will try to load a configuration file from that field. If neither exists, TypeScript will try to read from a &lt;code&gt;tsconfig.json&lt;/code&gt; at the root. This is similar to the lookup process for &lt;code&gt;.js&lt;/code&gt; files in packages that Node uses, and the &lt;code&gt;.d.ts&lt;/code&gt; lookup process that TypeScript already uses.</source>
          <target state="translated">ここで、TypeScriptは &lt;code&gt;node_modules&lt;/code&gt; フォルダーに移動し、 &lt;code&gt;@my-team/tsconfig-base&lt;/code&gt; パッケージを探します。 これらの各パッケージについて、TypeScriptは最初に &lt;code&gt;&quot;tsconfig&quot;&lt;/code&gt; &lt;code&gt;package.json&lt;/code&gt; に「tsconfig」フィールドを含み、その場合、TypeScriptはそのフィールドから構成ファイルをロードしようとします。 どちらも存在しない場合、TypeScriptはルート &lt;code&gt;tsconfig.json&lt;/code&gt; から読み取ろうとします。 これは、Nodeが使用するパッケージ内の &lt;code&gt;.js&lt;/code&gt; ファイルの検索プロセス、およびTypeScriptがすでに使用している &lt;code&gt;.d.ts&lt;/code&gt; 検索プロセスに似ています。</target>
        </trans-unit>
        <trans-unit id="3034e1d8a6bc8a9342b8171fa30badb5f8ee1757" translate="yes" xml:space="preserve">
          <source>Here, our package depends on the &lt;code&gt;browserify&lt;/code&gt; and &lt;code&gt;typescript&lt;/code&gt; packages. &lt;code&gt;browserify&lt;/code&gt; does not bundle its declaration files with its npm packages, so we needed to depend on &lt;code&gt;@types/browserify&lt;/code&gt; for its declarations. &lt;code&gt;typescript&lt;/code&gt;, on the other hand, packages its declaration files, so there was no need for any additional dependencies.</source>
          <target state="translated">ここで、パッケージは &lt;code&gt;browserify&lt;/code&gt; および &lt;code&gt;typescript&lt;/code&gt; パッケージに依存しています。 &lt;code&gt;browserify&lt;/code&gt; は宣言ファイルをnpmパッケージにバンドルしないため、宣言は &lt;code&gt;@types/browserify&lt;/code&gt; に依存する必要がありました 。 一方、 &lt;code&gt;typescript&lt;/code&gt; は宣言ファイルをパッケージ化するため、追加の依存関係は必要ありません。</target>
        </trans-unit>
        <trans-unit id="3cda7ef7ff2200b657be6b6273e0dac1be53b72f" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;pickCard&lt;/code&gt; function will return two different things based on what the user has passed in. If the users passes in an object that represents the deck, the function will pick the card. If the user picks the card, we tell them which card they&amp;rsquo;ve picked. But how do we describe this to the type system?</source>
          <target state="translated">ここで、 &lt;code&gt;pickCard&lt;/code&gt; 関数は、ユーザーが渡したものに基づいて2つの異なるものを返します。 ユーザーがデッキを表すオブジェクトを渡すと、関数はカードを選択します。 ユーザーがカードを選択した場合、選択したカードを伝えます。 しかし、型システムでこれをどのように記述しますか？</target>
        </trans-unit>
        <trans-unit id="e58fec9d06a5ad9c41dd9bdefb16a98bb9094511" translate="yes" xml:space="preserve">
          <source>Here, the Typescript type checker used the type of the &lt;code&gt;Window.onmousedown&lt;/code&gt; function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;type&lt;/a&gt; of the &lt;code&gt;mouseEvent&lt;/code&gt; parameter, which does contain a &lt;code&gt;button&lt;/code&gt; property, but not a &lt;code&gt;kangaroo&lt;/code&gt; property.</source>
          <target state="translated">ここでは、 &lt;code&gt;Window.onmousedown&lt;/code&gt; 型チェッカーはWindow.onmousedown関数の型を使用して、割り当ての右側の関数式の型を推測しました。 &lt;code&gt;mouseEvent&lt;/code&gt; 、mouseEventパラメーターの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;タイプを&lt;/a&gt;推測できます。 これには、 &lt;code&gt;button&lt;/code&gt; プロパティが含まれますが、 &lt;code&gt;kangaroo&lt;/code&gt; プロパティは含まれません。</target>
        </trans-unit>
        <trans-unit id="e4d6507505357d507200a72953f1d420dfbcafaf" translate="yes" xml:space="preserve">
          <source>Here, we forgot to call &lt;code&gt;isAdministrator&lt;/code&gt;, and the code incorrectly allows non-adminstrator users to edit the configuration!</source>
          <target state="translated">ここでは、 &lt;code&gt;isAdministrator&lt;/code&gt; を呼び出すのを忘れており、コードにより、管理者以外のユーザーが構成を編集することが誤って許可されています。</target>
        </trans-unit>
        <trans-unit id="30996a44efb8790cbea6f775764e2a95c008cc8a" translate="yes" xml:space="preserve">
          <source>Here, we have a function &lt;code&gt;readImage&lt;/code&gt; which reads an image in a non-blocking asynchronous way. In addition to &lt;code&gt;readImage&lt;/code&gt;, we&amp;rsquo;ve provided a convenience function on &lt;code&gt;readImage&lt;/code&gt; itself called &lt;code&gt;readImage.sync&lt;/code&gt;.</source>
          <target state="translated">これは、非ブロッキング非同期方式でイメージを読み取る関数 &lt;code&gt;readImage&lt;/code&gt; です。 &lt;code&gt;readImage&lt;/code&gt; にが追加され、readImage.syncというreadImage.sync自体の便利な関数が提供されました。</target>
        </trans-unit>
        <trans-unit id="4776f9836ab53c81a717b79d18761f412dcd4953" translate="yes" xml:space="preserve">
          <source>Here, we have two local variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s scope is limited to the body of &lt;code&gt;f&lt;/code&gt; while &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s scope is limited to the containing &lt;code&gt;if&lt;/code&gt; statement&amp;rsquo;s block.</source>
          <target state="translated">ここには、2つのローカル変数 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; があります。 &lt;code&gt;b&lt;/code&gt; のスコープは &lt;code&gt;f&lt;/code&gt; の本体に制限され、 bのスコープは包含 &lt;code&gt;if&lt;/code&gt; ステートメントのブロックに制限されます。</target>
        </trans-unit>
        <trans-unit id="48b66ea86a98afc6732087affea2266d22665ee9" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ll split our &lt;code&gt;Validation&lt;/code&gt; namespace across many files. Even though the files are separate, they can each contribute to the same namespace and can be consumed as if they were all defined in one place. Because there are dependencies between files, we&amp;rsquo;ll add reference tags to tell the compiler about the relationships between the files. Our test code is otherwise unchanged.</source>
          <target state="translated">ここでは、 &lt;code&gt;Validation&lt;/code&gt; 名前空間を多数のファイルに分割します。 ファイルが別々であっても、それぞれが同じ名前空間に寄与し、それらがすべて1か所で定義されているかのように使用できます。 ファイル間に依存関係があるため、参照タグを追加して、ファイル間の関係についてコンパイラーに伝えます。 テストコードの残りの部分は変更されていません。</target>
        </trans-unit>
        <trans-unit id="0be76e8a894cfa9a5cd3d9c31525aeb3396a52fc" translate="yes" xml:space="preserve">
          <source>Here, when we say &lt;code&gt;let greeter: Greeter&lt;/code&gt;, we&amp;rsquo;re using &lt;code&gt;Greeter&lt;/code&gt; as the type of instances of the class &lt;code&gt;Greeter&lt;/code&gt;. This is almost second nature to programmers from other object-oriented languages.</source>
          <target state="translated">ここで、 &lt;code&gt;let greeter: Greeter&lt;/code&gt; と言うとき、 &lt;code&gt;Greeter&lt;/code&gt; クラスのインスタンスのタイプとして &lt;code&gt;Greeter&lt;/code&gt; を使用します。 これは、他のオブジェクト指向言語のプログラマーにとってほぼ2番目の特性です。</target>
        </trans-unit>
        <trans-unit id="af2cc1b97022b7d58d48c283943b530d0c3a629b" translate="yes" xml:space="preserve">
          <source>Heterogeneous enums</source>
          <target state="translated">異種の列挙</target>
        </trans-unit>
        <trans-unit id="bcaf520cc3089e4cf8ad0800fc58fb622275eea2" translate="yes" xml:space="preserve">
          <source>Higher order type inference from generic constructors</source>
          <target state="translated">ジェネリックコンストラクターからの高次型推論</target>
        </trans-unit>
        <trans-unit id="f7dd4ac35eed5e4b0152fe5390ac0fc4fdadf710" translate="yes" xml:space="preserve">
          <source>Higher order type inference from generic functions</source>
          <target state="translated">汎用関数からの高次型推論</target>
        </trans-unit>
        <trans-unit id="173efd9dce0319d3f71e1aa5317de963557d2d4c" translate="yes" xml:space="preserve">
          <source>Hit &lt;code&gt;Install&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Install&lt;/code&gt; ヒット</target>
        </trans-unit>
        <trans-unit id="89d412a555ac9119a1cb2746b4a8a508c5b127a6" translate="yes" xml:space="preserve">
          <source>How Node.js resolves modules</source>
          <target state="translated">Node.jsがモジュールを解決する方法</target>
        </trans-unit>
        <trans-unit id="1a330f9df74d0d83d178ec1580eb2080a18f5765" translate="yes" xml:space="preserve">
          <source>How TypeScript resolves modules</source>
          <target state="translated">TypeScriptがモジュールを解決する方法</target>
        </trans-unit>
        <trans-unit id="aea32d84fa10a6814afacd1681bb1e9a0cfcb214" translate="yes" xml:space="preserve">
          <source>However, TypeScript takes the stance that there&amp;rsquo;s probably a bug in this code. Object literals get special treatment and undergo &lt;em&gt;excess property checking&lt;/em&gt; when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the &amp;ldquo;target type&amp;rdquo; doesn&amp;rsquo;t have, you&amp;rsquo;ll get an error:</source>
          <target state="translated">ただし、TypeScriptは、このコードはおそらくバグがあると考えています。 オブジェクトリテラルは、他の変数に割り当てられたとき、または引数として渡されたときに、特別な処理と&lt;em&gt;過剰なプロパティチェックの&lt;/em&gt;対象となります。 オブジェクトリテラルに「ターゲットタイプ」にないプロパティがある場合、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="2df3cad6545d1673cff30d2239dcbcac86f68714" translate="yes" xml:space="preserve">
          <source>However, TypeScript would instead transform the original code into this code:</source>
          <target state="translated">ただし、TypeScriptは元のコードを代わりに次のコードに変換します。</target>
        </trans-unit>
        <trans-unit id="d67a8b4fe7f16ad0a4a00091ab517503777587fe" translate="yes" xml:space="preserve">
          <source>However, a better approach might be to add a string index signature if you&amp;rsquo;re sure that the object can have some extra properties that are used in some special way. If &lt;code&gt;SquareConfig&lt;/code&gt; can have &lt;code&gt;color&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; properties with the above types, but could &lt;em&gt;also&lt;/em&gt; have any number of other properties, then we could define it like so:</source>
          <target state="translated">ただし、オブジェクトに特別な方法で使用される追加のプロパティがあることが確実な場合は、文字列インデックス署名を追加することをお勧めします。 &lt;code&gt;SquareConfig&lt;/code&gt; は、上記のタイプの &lt;code&gt;color&lt;/code&gt; と &lt;code&gt;width&lt;/code&gt; プロパティを持つことができますが、他のプロパティをいくつでも持つことができます。次に定義できます：</target>
        </trans-unit>
        <trans-unit id="ae34467865c8caaf898bf37d8295d39c36fa465b" translate="yes" xml:space="preserve">
          <source>However, a lot of the time, you might just want to import an existing module that may not have its own &lt;code&gt;.d.ts&lt;/code&gt; file. Previously this was an error. Starting with TypeScript 2.1 this is now much easier.</source>
          <target state="translated">ただし、多くの場合、独自の &lt;code&gt;.d.ts&lt;/code&gt; ファイルを持たない既存のモジュールをインポートできます。 以前はこれはエラーでした。 TypeScript 2.1以降では、これがはるかに簡単になりました。</target>
        </trans-unit>
        <trans-unit id="52fd9d1ab67ec13644f81aac04cb75b6dad506bf" translate="yes" xml:space="preserve">
          <source>However, combining the two naively would allow an error to sneak in. For example, taking our last example using &lt;code&gt;createSquare&lt;/code&gt;:</source>
          <target state="translated">ただし、これら2つを &lt;code&gt;createSquare&lt;/code&gt; と組み合わせると、エラーが発生する可能性があります。 たとえば、createSquareを使用した最後の例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="5fd6902ab8657b5adb4ddbc9ea60a37a54d752ab" translate="yes" xml:space="preserve">
          <source>However, having to define a function to figure out if a type is a primitive is kind of a pain. Luckily, you don&amp;rsquo;t need to abstract &lt;code&gt;typeof x === &quot;number&quot;&lt;/code&gt; into its own function because TypeScript will recognize it as a type guard on its own. That means we could just write these checks inline.</source>
          <target state="translated">ただし、型がプリミティブであるかどうかを判別する関数を定義することは、ちょっとした挑戦です。 幸いなことに、TypeScriptは自分自身を &lt;code&gt;typeof x === &quot;number&quot;&lt;/code&gt; として認識しているため、typeof x === &quot;number&quot;を独自の関数に抽象化する必要はありません。 これは、これらのチェックをインラインで記述できることを意味します。</target>
        </trans-unit>
        <trans-unit id="cb2ee9a73119ef2301052f4deb325a8b58f2559f" translate="yes" xml:space="preserve">
          <source>However, in the above example, both &lt;code&gt;FruitEater&lt;/code&gt;s and &lt;code&gt;ColorConsumer&lt;/code&gt;s should be able to take the string &lt;code&gt;&quot;orange&quot;&lt;/code&gt;, and return either a &lt;code&gt;number&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">ただし、上記の例では、 &lt;code&gt;FruitEater&lt;/code&gt; と &lt;code&gt;ColorConsumer&lt;/code&gt; の両方が文字列 &lt;code&gt;&quot;orange&quot;&lt;/code&gt; を受け入れ、 &lt;code&gt;number&lt;/code&gt; または &lt;code&gt;string&lt;/code&gt; を返すことができるはずです。</target>
        </trans-unit>
        <trans-unit id="6b3269ba44655740fda35e4a6cc5c78cee6e3c08" translate="yes" xml:space="preserve">
          <source>However, in the following example, no error will be reported because the fall-through case is empty:</source>
          <target state="translated">ただし、次の例では、フォールスルーケースが空であるため、エラーは報告されません。</target>
        </trans-unit>
        <trans-unit id="9b7d9dc4338c505863904ace315d827dbbcdc28f" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s not possible for a type alias to appear anywhere else on the right side of the declaration:</source>
          <target state="translated">ただし、型エイリアスは、宣言の右側のどこにも表示できません。</target>
        </trans-unit>
        <trans-unit id="261cdca866e8fca9691e1b837aea779937f4bb40" translate="yes" xml:space="preserve">
          <source>However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:</source>
          <target state="translated">ただし、制約タイプ変数をクリアし、代わりに条件タイプを指定することで、ほぼ同じ効果を実現できます。</target>
        </trans-unit>
        <trans-unit id="e03cd94fc4a5be72b1eb26d1ba79c9cc8372ade3" translate="yes" xml:space="preserve">
          <source>However, properties of different types are acceptable if the index signature is a union of the property types:</source>
          <target state="translated">ただし、インデックス署名がプロパティタイプの組み合わせである場合、異なるタイプのプロパティが受け入れられます。</target>
        </trans-unit>
        <trans-unit id="21bd5d4e23e02c99e9395288fd2b3c14719c2452" translate="yes" xml:space="preserve">
          <source>However, resolution for a &lt;a href=&quot;#relative-vs-non-relative-module-imports&quot;&gt;non-relative module name&lt;/a&gt; is performed differently. Node will look for your modules in special folders named &lt;code&gt;node_modules&lt;/code&gt;. A &lt;code&gt;node_modules&lt;/code&gt; folder can be on the same level as the current file, or higher up in the directory chain. Node will walk up the directory chain, looking through each &lt;code&gt;node_modules&lt;/code&gt; until it finds the module you tried to load.</source>
          <target state="translated">ただし、 &lt;a href=&quot;#relative-vs-non-relative-module-imports&quot;&gt;非相対モジュール名の解決&lt;/a&gt;方法は異なります。 &lt;code&gt;node_modules&lt;/code&gt; という名前の特別なフォルダー内のモジュールのノードnode_modules 。 &lt;code&gt;node_modules&lt;/code&gt; フォルダーは、現在のファイルと同じレベルまたはディレクトリチェーンの上にあります。 ノード &lt;code&gt;node_modules&lt;/code&gt; はディレクトリチェーンnode_modulesで、ロードしようとしたモジュールが見つかるまで各node_modulesを調べます。</target>
        </trans-unit>
        <trans-unit id="4066c0cf22c6617cd0e99b116883a9d0812e7a0a" translate="yes" xml:space="preserve">
          <source>However, there are two limitations to keep in mind:</source>
          <target state="translated">ただし、留意すべき2つの制限があります。</target>
        </trans-unit>
        <trans-unit id="1b475ae409f46bd0059bada064f2253dfa62d98f" translate="yes" xml:space="preserve">
          <source>However, this code will log &lt;code&gt;undefined&lt;/code&gt;, since &lt;code&gt;uiEvent&lt;/code&gt; has no property called &lt;code&gt;button&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;uiEvent&lt;/code&gt; には &lt;code&gt;button&lt;/code&gt; というプロパティがないため、このコードは &lt;code&gt;undefined&lt;/code&gt; を記録します。</target>
        </trans-unit>
        <trans-unit id="e528b8c265ab20d7ddf0074a5c552ac0aa502914" translate="yes" xml:space="preserve">
          <source>However, this is error prone - there is nothing stopping a user from accidentally misspelling one of the valid easing values:</source>
          <target state="translated">ただし、これはエラーが発生しやすく、ユーザーが有効なイージング値の1つを誤って間違えることを防ぐものは何もありません。</target>
        </trans-unit>
        <trans-unit id="47f0cbbb6af8b4a1e0b5d52577ef8a8ca00678b1" translate="yes" xml:space="preserve">
          <source>However, this was a bit overly strict for the original example. If you figure out the precise type of any possible value of &lt;code&gt;S&lt;/code&gt;, you can actually see that it matches the types in &lt;code&gt;T&lt;/code&gt; exactly.</source>
          <target state="translated">ただし、これは元の例では少し厳しすぎました。 &lt;code&gt;S&lt;/code&gt; の可能な値の正確なタイプは、実際に &lt;code&gt;T&lt;/code&gt; のタイプと正確に一致することを示しています。</target>
        </trans-unit>
        <trans-unit id="a82aa6652361ecc5084c82f581d35a4cecb03722" translate="yes" xml:space="preserve">
          <source>However, when comparing types that have &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; members, we treat these types differently. For two types to be considered compatible, if one of them has a &lt;code&gt;private&lt;/code&gt; member, then the other must have a &lt;code&gt;private&lt;/code&gt; member that originated in the same declaration. The same applies to &lt;code&gt;protected&lt;/code&gt; members.</source>
          <target state="translated">ただし、 &lt;code&gt;private&lt;/code&gt; および &lt;code&gt;protected&lt;/code&gt; メンバーとタイプを比較する場合、これらのタイプは異なる方法で処理されます。 2つの型が互換性があると見なされるには、一方に &lt;code&gt;private&lt;/code&gt; メンバーがある場合、他方には同じ宣言で作成された &lt;code&gt;private&lt;/code&gt; メンバーが必要です。 &lt;code&gt;protected&lt;/code&gt; れたメンバーについても同様です。</target>
        </trans-unit>
        <trans-unit id="e30d71bb57f4f77a84a108277b5b36c06cf3ebc6" translate="yes" xml:space="preserve">
          <source>However, when using the &lt;code&gt;--strictNullChecks&lt;/code&gt; flag, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are only assignable to &lt;code&gt;any&lt;/code&gt; and their respective types (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). This helps avoid &lt;em&gt;many&lt;/em&gt; common errors. In cases where you want to pass in either a &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the union type &lt;code&gt;string | null | undefined&lt;/code&gt;.</source>
          <target state="translated">ただし、-- &lt;code&gt;--strictNullChecks&lt;/code&gt; フラグを使用する場合 、 &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; はそれぞれのタイプにのみ割り当てることができます（ &lt;code&gt;undefined&lt;/code&gt; は &lt;code&gt;void&lt;/code&gt; に割り当てることもできます ）。 これにより、 &lt;em&gt;多くの&lt;/em&gt;一般的なエラーが回避されます。 &lt;code&gt;string&lt;/code&gt; または &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; を渡す場合は、ユニオン型 &lt;code&gt;string | null | undefined&lt;/code&gt; 使用できます| null | 未定義 | null | 未定義</target>
        </trans-unit>
        <trans-unit id="3a16fbd6d0aeace5fd6859531c3e68218d7a29dc" translate="yes" xml:space="preserve">
          <source>Hybrid Types</source>
          <target state="translated">ハイブリッドタイプ</target>
        </trans-unit>
        <trans-unit id="51fed45c4210870abf204ad077a177b04a015861" translate="yes" xml:space="preserve">
          <source>IIFEs as namespace declarations</source>
          <target state="translated">名前空間宣言としてのIIFE</target>
        </trans-unit>
        <trans-unit id="aacc04465943461c4401f154c73b82378a7e907a" translate="yes" xml:space="preserve">
          <source>Ideally, we may want &lt;code&gt;zoo&lt;/code&gt; to be inferred as an &lt;code&gt;Animal[]&lt;/code&gt;, but because there is no object that is strictly of type &lt;code&gt;Animal&lt;/code&gt; in the array, we make no inference about the array element type. To correct this, instead explicitly provide the type when no one type is a super type of all other candidates:</source>
          <target state="translated">理想的には、 &lt;code&gt;zoo&lt;/code&gt; を &lt;code&gt;Animal[]&lt;/code&gt; として推論したいかもしれませんが、配列には厳密には &lt;code&gt;Animal&lt;/code&gt; オブジェクトがないため、配列要素のタイプは推論しません。 これを修正するには、他のすべての候補のスーパータイプであるタイプがない場合、代わりにタイプを明示的に指定します。</target>
        </trans-unit>
        <trans-unit id="3fb44df7e96b3c06b0f62dc3d3bf658dd46e932c" translate="yes" xml:space="preserve">
          <source>Ideally, we&amp;rsquo;d just import the React module from within the browser, but most browsers still don&amp;rsquo;t quite support modules yet. Instead libraries have traditionally made themselves available using a single global variable like &lt;code&gt;jQuery&lt;/code&gt; or &lt;code&gt;_&lt;/code&gt;. This is called the &amp;ldquo;namespace pattern&amp;rdquo;, and webpack allows us to continue leveraging libraries written that way. With our entry for &lt;code&gt;&quot;react&quot;: &quot;React&quot;&lt;/code&gt;, webpack will work its magic to make any import of &lt;code&gt;&quot;react&quot;&lt;/code&gt; load from the &lt;code&gt;React&lt;/code&gt; variable.</source>
          <target state="translated">理想的には、ブラウザー内からReactモジュールをインポートするだけですが、ほとんどのブラウザーはまだモジュールをサポートしていません。 代わりに、ライブラリは伝統的に &lt;code&gt;jQuery&lt;/code&gt; や &lt;code&gt;_&lt;/code&gt; などの単一のグローバル変数を使用して利用可能にしました。 これは「名前空間パターン」と呼ばれ、webpackでは、そのように記述されたライブラリを引き続き活用できます。 &lt;code&gt;&quot;react&quot;: &quot;React&quot;&lt;/code&gt; エントリ：「React」を使用すると、webpackはマジックを使用して、 &lt;code&gt;React&lt;/code&gt; 変数から &lt;code&gt;&quot;react&quot;&lt;/code&gt; 負荷のインポートを作成します。</target>
        </trans-unit>
        <trans-unit id="7e95984082de67338b2c7ddbc538f64e016c8d48" translate="yes" xml:space="preserve">
          <source>Identifying Kinds of Libraries</source>
          <target state="translated">ライブラリタイプの特定</target>
        </trans-unit>
        <trans-unit id="e5eb14c632b87d0c6ad5e592a44a1a8fee7f0639" translate="yes" xml:space="preserve">
          <source>Identifying a Global Library from Code</source>
          <target state="translated">コードからグローバルライブラリを識別する</target>
        </trans-unit>
        <trans-unit id="a2ba79579e03b8f78ffd87dd47a547b41065fc1e" translate="yes" xml:space="preserve">
          <source>Identifying a Module Library from Code</source>
          <target state="translated">コードからモジュールライブラリを識別する</target>
        </trans-unit>
        <trans-unit id="96a39992ddd95916928039e6a01815883f0054ca" translate="yes" xml:space="preserve">
          <source>Identifying a UMD library</source>
          <target state="translated">UMDライブラリの識別</target>
        </trans-unit>
        <trans-unit id="88076b9c11713a1d1df3ba70daf4f6393c85d874" translate="yes" xml:space="preserve">
          <source>Identifying global plugins</source>
          <target state="translated">グローバルプラグインを特定する</target>
        </trans-unit>
        <trans-unit id="7d0b0dbee7bf8c6735a82b5f8993e432ee3b5ca1" translate="yes" xml:space="preserve">
          <source>Identifying global-modifying modules</source>
          <target state="translated">グローバル変更モジュールを特定する</target>
        </trans-unit>
        <trans-unit id="75c608e5e061dd97d023874171193ba0dedb0879" translate="yes" xml:space="preserve">
          <source>Identifying the structure of a library is the first step in writing its declaration file. We&amp;rsquo;ll give hints on how to identify structure both based on its &lt;em&gt;usage&lt;/em&gt; and its &lt;em&gt;code&lt;/em&gt;. Depending on the library&amp;rsquo;s documentation and organization, one might be easier than the other. We recommend using whichever is more comfortable to you.</source>
          <target state="translated">ライブラリの構造を識別することは、その宣言ファイルを作成する最初のステップです。 &lt;em&gt;使用法&lt;/em&gt;と&lt;em&gt;コードの&lt;/em&gt;両方に基づいて構造を識別する方法に関するヒントを&lt;em&gt;提供します&lt;/em&gt; 。 ライブラリのドキュメントと構成によっては、一方が他方よりも簡単な場合があります。 より快適なものを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="8bd1ece9a873c798fd3b2f187514a3f9ff53eeee" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;default&amp;rsquo; and &amp;lsquo;clean&amp;rsquo; tasks don&amp;rsquo;t show up, refresh the explorer:</source>
          <target state="translated">デフォルトタスクとクリーンタスクが表示されない場合は、Windowsエクスプローラーを更新します。</target>
        </trans-unit>
        <trans-unit id="b398aaa2e3e793e66c0386971a0fcc7d95fd4011" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TypeScriptToolsVersion&lt;/code&gt; is not specified, the latest compiler version installed on the machine will be used to build.</source>
          <target state="translated">&lt;code&gt;TypeScriptToolsVersion&lt;/code&gt; が指定されていない場合、マシンにインストールされている最新のコンパイラバージョンがビルドに使用されます。</target>
        </trans-unit>
        <trans-unit id="1a66bd888ae761260069cb56ba3782c6cb9f2948" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; contains a numeric index signature, &lt;code&gt;keyof X&lt;/code&gt; is a union of &lt;code&gt;number&lt;/code&gt; and the literal types representing string-like and symbol-like properties, otherwise</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; には数値インデックスシグネチャがあり、 &lt;code&gt;keyof X&lt;/code&gt; は数値の連結であり、リテラルタイプは文字列のようなプロパティとシンボルのようなプロパティを表します。</target>
        </trans-unit>
        <trans-unit id="6616ffdf1f61f5f170f5695d095b28464311066e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; contains a string index signature, &lt;code&gt;keyof X&lt;/code&gt; is a union of &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, and the literal types representing symbol-like properties, otherwise</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; には文字列インデックスシグネチャが含まれ、 &lt;code&gt;keyof X&lt;/code&gt; は &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;number&lt;/code&gt; 、symbolなどのプロパティを表すリテラルタイプの組み合わせです。</target>
        </trans-unit>
        <trans-unit id="2f946b4318e41dbe69a87cd5f88e67367fd6d44f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typeRoots&lt;/code&gt; is specified, &lt;em&gt;only&lt;/em&gt; packages under &lt;code&gt;typeRoots&lt;/code&gt; will be included. For example:</source>
          <target state="translated">&lt;code&gt;typeRoots&lt;/code&gt; が指定されている場合、 typeRootsの下のパッケージ&lt;em&gt;のみ&lt;/em&gt;が含まれます。 例えば：</target>
        </trans-unit>
        <trans-unit id="99b6d90008fb9649958f2be05e76b1dd9a5961c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, only packages listed will be included. For instance:</source>
          <target state="translated">&lt;code&gt;types&lt;/code&gt; が指定されている場合、リストされているパッケージのみが含まれます。 例えば：</target>
        </trans-unit>
        <trans-unit id="6fbac6cb9d3b7de97e789cbb5b4510b49f088657" translate="yes" xml:space="preserve">
          <source>If a decision ever comes down to &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt;, you should prefer &lt;code&gt;{}&lt;/code&gt;. While they are mostly the same, technically &lt;code&gt;{}&lt;/code&gt; is a more general type than &lt;code&gt;Object&lt;/code&gt; in certain esoteric cases.</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; および &lt;code&gt;{}&lt;/code&gt; で決定が行われる場合、{}を選択する必要があります。 これらはほとんど同じですが、技術的には &lt;code&gt;{}&lt;/code&gt; は特定の難解なケースでは &lt;code&gt;Object&lt;/code&gt; よりも一般的なタイプです。</target>
        </trans-unit>
        <trans-unit id="2ac2b4a6a24acc5fecb490e99fb16cab96cc3bf4" translate="yes" xml:space="preserve">
          <source>If a default type is specified and inference cannot choose a candidate, the default type is inferred.</source>
          <target state="translated">デフォルトのタイプが指定され、推論が候補を選択できない場合、デフォルトのタイプが推測されます。</target>
        </trans-unit>
        <trans-unit id="8fbc86845e0d24c360aaf1bfbc58393acef68624" translate="yes" xml:space="preserve">
          <source>If a segment of a glob pattern includes only &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;.*&lt;/code&gt;, then only files with supported extensions are included (e.g. &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and &lt;code&gt;.d.ts&lt;/code&gt; by default with &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; if &lt;code&gt;allowJs&lt;/code&gt; is set to true).</source>
          <target state="translated">globパターンセグメントに &lt;code&gt;*&lt;/code&gt; または &lt;code&gt;.*&lt;/code&gt; のみが含まれる場合、サポートされる拡張子を持つファイルのみが含まれます（たとえば、 &lt;code&gt;.tsx&lt;/code&gt; がtrueに設定されている場合、 &lt;code&gt;.js&lt;/code&gt; および &lt;code&gt;.jsx&lt;/code&gt; はデフォルトで &lt;code&gt;.ts&lt;/code&gt; 、.tsx、および.d.tsになります）。</target>
        </trans-unit>
        <trans-unit id="54daf0bb0e7d1bcc3df23442a6dc487446e709b6" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, or &lt;code&gt;in&lt;/code&gt; operator is nullable.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;=&lt;/code&gt; 、または &lt;code&gt;in&lt;/code&gt; 演算子のいずれかのオペランドはNULL可能です。</target>
        </trans-unit>
        <trans-unit id="ea5b35d5abd4cbfb9f096e8d991dcb47c08f66f4" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;+&lt;/code&gt; operator is nullable, and neither operand is of type &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 演算子のいずれかのオペランドはNULL可能であり、いずれのオペランド &lt;code&gt;any&lt;/code&gt; &lt;code&gt;string&lt;/code&gt; 型でもありません。</target>
        </trans-unit>
        <trans-unit id="d883272b1b0531d98de565e92423069ee2248d62" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, or &lt;code&gt;^&lt;/code&gt; operator is nullable.</source>
          <target state="translated">任意のオペランド &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;**&lt;/code&gt; 、 &lt;code&gt;/&lt;/code&gt; 、 &lt;code&gt;%&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 、&amp;gt;&amp;gt;&amp;gt;、 &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; または &lt;code&gt;^&lt;/code&gt; 演算子はNULLにすることができます。</target>
        </trans-unit>
        <trans-unit id="b999341c4d2107c29465088a4be729def05702d7" translate="yes" xml:space="preserve">
          <source>If environment variable &lt;code&gt;TSC_NONPOLLING_WATCHER&lt;/code&gt; is set to true, watches parent directory of files (just like &lt;code&gt;UseFsEventsOnParentDirectory&lt;/code&gt;). Otherwise watch files using &lt;code&gt;fs.watchFile&lt;/code&gt; with &lt;code&gt;250ms&lt;/code&gt; as the timeout for any file</source>
          <target state="translated">環境変数 &lt;code&gt;TSC_NONPOLLING_WATCHER&lt;/code&gt; がtrueに設定されている場合、ファイルの親ディレクトリを監視します（ &lt;code&gt;UseFsEventsOnParentDirectory&lt;/code&gt; など ）。 それ以外の場合は、 &lt;code&gt;fs.watchFile&lt;/code&gt; をファイルタイムアウトとして使用してファイルを監視します</target>
        </trans-unit>
        <trans-unit id="d23e16bdfbddee4b25eaec4b1d684282e726836a" translate="yes" xml:space="preserve">
          <source>If properties are never set in the class body, they are considered unknown. If your class has properties that are only read from, add and then annotate a declaration in the constructor with JSDoc to specify the type. You don&amp;rsquo;t even have to give a value if it will be initialised later:</source>
          <target state="translated">クラス本体にプロパティが設定されていない場合、それらは不明と見なされます。 クラスに読み取り専用プロパティがある場合は、コンストラクターに宣言を追加し、JSDocを使用して型を指定します。 後で初期化される場合、値を指定する必要さえありません。</target>
        </trans-unit>
        <trans-unit id="cf548e316f27cc773ad61fba2e4a76543f3bb1ce" translate="yes" xml:space="preserve">
          <source>If that didn&amp;rsquo;t work and if the module name is non-relative (and in the case of &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt;, it is), then the compiler will attempt to locate an &lt;a href=&quot;modules#ambient-modules&quot;&gt;ambient module declaration&lt;/a&gt;. We&amp;rsquo;ll cover non-relative imports next.</source>
          <target state="translated">それが機能せず、モジュール名が非相対（および &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; ）の場合、コンパイラは&lt;a href=&quot;modules#ambient-modules&quot;&gt;アンビエントモジュール宣言&lt;/a&gt;を見つけようとします。 次に、非相対インポートについて説明します。</target>
        </trans-unit>
        <trans-unit id="5fc6ba7853747447fab7e2b09e476e794d7eaf75" translate="yes" xml:space="preserve">
          <source>If that sounds too lax for you, you can tighten that behavior up. If, for instance, you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want TypeScript to compile to JavaScript in the face of errors, you can use the &lt;code&gt;noEmitOnError&lt;/code&gt; option. In that sense, TypeScript has a dial on its strictness, and you can turn that knob up as high as you want.</source>
          <target state="translated">緩すぎると思われる場合は、その動作を強化できます。 たとえば、エラーが発生したときにTypeScriptをJavaScriptにコンパイルしたく&lt;em&gt;ない&lt;/em&gt;場合は、 &lt;code&gt;noEmitOnError&lt;/code&gt; オプションを使用できます。 その意味で、TypeScriptには厳密なダイヤルがあり、必要に応じてノブを上げることができます。</target>
        </trans-unit>
        <trans-unit id="80562a30b2229fad8a6df690b031de0355afd589" translate="yes" xml:space="preserve">
          <source>If that&amp;rsquo;s the case, the files that you&amp;rsquo;ve written are going to be used as inputs to TypeScript, and you&amp;rsquo;ll run the outputs it produces. During our JS to TS migration, we&amp;rsquo;ll need to separate our input files to prevent TypeScript from overwriting them. If your output files need to reside in a specific directory, then that will be your output directory.</source>
          <target state="translated">その場合、作成されたファイルはTypeScriptへの入力として使用され、生成された出力を実行します。 JSからTSへの移行中に、TypeScriptが上書きしないように入力ファイルを分離する必要があります。 出力ファイルを特定のディレクトリに配置する必要がある場合、それが出力ディレクトリになります。</target>
        </trans-unit>
        <trans-unit id="2fcbcd9f558fa8a3faacb1b7e2f2cc6f3c7dd80a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; and &lt;code&gt;&quot;include&quot;&lt;/code&gt; are both left unspecified, the compiler defaults to including all TypeScript (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt;) files in the containing directory and subdirectories except those excluded using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. JS files (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt;) are also included if &lt;code&gt;allowJs&lt;/code&gt; is set to true.</source>
          <target state="translated">&lt;code&gt;&quot;files&quot;&lt;/code&gt; 「files」と &lt;code&gt;&quot;include&quot;&lt;/code&gt; 両方が指定されていない場合、コンパイラはデフォルトで、 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; プロパティIncludeを使用して除外されるファイルを除くすべてのTypeScript（ &lt;code&gt;.ts&lt;/code&gt; 、 &lt;code&gt;.tsx&lt;/code&gt; および.tsx）ファイルに含まれます。 &lt;code&gt;allowJs&lt;/code&gt; をtrueに設定すると、JSファイル（ &lt;code&gt;.js&lt;/code&gt; および &lt;code&gt;.jsx&lt;/code&gt; ）も含まれます。</target>
        </trans-unit>
        <trans-unit id="477c8cbe4706878c16fb156bd723ab8f217099e9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; and &lt;code&gt;&quot;include&quot;&lt;/code&gt; are both left unspecified, the compiler defaults to including all TypeScript (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt;) files in the containing directory and subdirectories except those excluded using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. JS files (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt;) are also included if &lt;code&gt;allowJs&lt;/code&gt; is set to true. If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; compiler option are excluded as long as &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property is not specified.</source>
          <target state="translated">&lt;code&gt;&quot;files&quot;&lt;/code&gt; 「files」と &lt;code&gt;&quot;include&quot;&lt;/code&gt; 両方が指定されていない場合、コンパイラはデフォルトで、 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; プロパティIncludeを使用して除外されるファイルを除くすべてのTypeScript（ &lt;code&gt;.ts&lt;/code&gt; 、 &lt;code&gt;.tsx&lt;/code&gt; および.tsx）ファイルに含まれます。 &lt;code&gt;allowJs&lt;/code&gt; をtrueに設定すると、JSファイル（ &lt;code&gt;.js&lt;/code&gt; および &lt;code&gt;.jsx&lt;/code&gt; ）も含まれます。 &lt;code&gt;&quot;files&quot;&lt;/code&gt; または &lt;code&gt;&quot;include&quot;&lt;/code&gt; プロパティーが指定されている場合、コンパイラーは代わりに、これら2つのプロパティーに含まれるファイルの結合を組み込みます。 &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; コンパイラオプションを使用して指定されたディレクトリ内のファイルは、 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; プロパティが指定されない限り除外されます。</target>
        </trans-unit>
        <trans-unit id="d6b124b086b760cf9eb1864e544665757f5217f3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; compiler option are always excluded unless explicitly included via the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property (even when the &amp;ldquo;&lt;code&gt;exclude&lt;/code&gt;&amp;rdquo; property is specified).</source>
          <target state="translated">&lt;code&gt;&quot;files&quot;&lt;/code&gt; または &lt;code&gt;&quot;include&quot;&lt;/code&gt; プロパティーが指定されている場合、コンパイラーは代わりに、これら2つのプロパティーに含まれるファイルの結合を組み込みます。 &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; コンパイラー・オプションを使用して指定されたディレクトリー内のファイルは、 &lt;code&gt;&quot;files&quot;&lt;/code&gt; プロパティーを介して明示的に組み込まれない限り、常に「 &lt;code&gt;exclude&lt;/code&gt; 」プロパティーが指定されていても除外されます。</target>
        </trans-unit>
        <trans-unit id="9fce1a983a1219926f1f38bab0bfb60ec3fd4b5c" translate="yes" xml:space="preserve">
          <source>If the accessor decorator returns a value, it will be used as the &lt;em&gt;Property Descriptor&lt;/em&gt; for the member.</source>
          <target state="translated">アクセサデコレータが値を返す場合、その値はメンバーの&lt;em&gt;プロパティ記述子&lt;/em&gt;として使用され&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="757bf2cd851a721420b759b576fc525ad4b2e255" translate="yes" xml:space="preserve">
          <source>If the class decorator returns a value, it will replace the class declaration with the provided constructor function.</source>
          <target state="translated">クラスデコレータが値を返す場合、クラス宣言を提供されたコンストラクタ関数に置き換えます。</target>
        </trans-unit>
        <trans-unit id="dcdc136ee9d606ac3aebb0a12ffa90330d056cbb" translate="yes" xml:space="preserve">
          <source>If the compiler flag &lt;code&gt;--noResolve&lt;/code&gt; is specified, triple-slash references are ignored; they neither result in adding new files, nor change the order of the files provided.</source>
          <target state="translated">コンパイラフラグ &lt;code&gt;--noResolve&lt;/code&gt; が指定されている場合、トリプルスラッシュ参照は無視されます。 新しいファイルは追加されないか、提供されたファイルの順序は変更されません。</target>
        </trans-unit>
        <trans-unit id="64760e36eb2b3cf9f6dce25e269af13108cbb2ff" translate="yes" xml:space="preserve">
          <source>If the method decorator returns a value, it will be used as the &lt;em&gt;Property Descriptor&lt;/em&gt; for the method.</source>
          <target state="translated">メソッドデコレータが値を返す場合、その値はメソッドの&lt;em&gt;プロパティ記述子&lt;/em&gt;として使用され&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5f107d97fba869cf2daf87a931e54a8895ed1bc" translate="yes" xml:space="preserve">
          <source>If the operand of a &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, or &lt;code&gt;--&lt;/code&gt; unary operator is nullable.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;~&lt;/code&gt; 、 &lt;code&gt;++&lt;/code&gt; 、または、単項演算子のオペランドがNULL可能の場合。</target>
        </trans-unit>
        <trans-unit id="a35de86d636b3f4498ca4f03ae3386c7c6c3cc94" translate="yes" xml:space="preserve">
          <source>If the referenced project produces an &lt;code&gt;outFile&lt;/code&gt;, the output file &lt;code&gt;.d.ts&lt;/code&gt; file&amp;rsquo;s declarations will be visible in this project</source>
          <target state="translated">参照プロジェクトが &lt;code&gt;outFile&lt;/code&gt; を生成する場合、出力ファイルの &lt;code&gt;.d.ts&lt;/code&gt; ファイルの宣言がこのプロジェクトに表示されます</target>
        </trans-unit>
        <trans-unit id="dd06f92d40ce76202d5611a64daad24f2a1feac2" translate="yes" xml:space="preserve">
          <source>If the right operand of an &lt;code&gt;instanceof&lt;/code&gt; operator is nullable.</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; 演算子の右側のオペランドはnullにできます。</target>
        </trans-unit>
        <trans-unit id="bb788c0916122fd9a75b33b92aa45518eb1b4e5a" translate="yes" xml:space="preserve">
          <source>If this function were not in a contextually typed position, the function&amp;rsquo;s argument would implicitly have type &lt;code&gt;any&lt;/code&gt;, and no error would be issued (unless you are using the &lt;code&gt;--noImplicitAny&lt;/code&gt; option):</source>
          <target state="translated">この関数が文脈的に型付けされた位置にない場合、関数の引数は暗黙的に &lt;code&gt;any&lt;/code&gt; 型であり、エラーは発行されません（ &lt;code&gt;--noImplicitAny&lt;/code&gt; --noImplicitAnyオプションを使用します）：</target>
        </trans-unit>
        <trans-unit id="d3ba6383ac88848a0ef4f846d3fe4de2bef1cab6" translate="yes" xml:space="preserve">
          <source>If we have a value that has a union type, we can only access members that are common to all types in the union.</source>
          <target state="translated">ユニオン型の値がある場合、ユニオン内のすべての型に共通のメンバーのみにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="a1d377830062aff369f8dab5df851e9080561624" translate="yes" xml:space="preserve">
          <source>If we want to customize how a decorator is applied to a declaration, we can write a decorator factory. A &lt;em&gt;Decorator Factory&lt;/em&gt; is simply a function that returns the expression that will be called by the decorator at runtime.</source>
          <target state="translated">デコレータを宣言に適用する方法をカスタマイズする場合は、デコレータファクトリを記述できます。 &lt;em&gt;デコレータファクトリ&lt;/em&gt;は、実行時にデコレータによって呼び出される式を返す単なる関数です。</target>
        </trans-unit>
        <trans-unit id="d0a73f363bdb39ad6e23dfd5f55548093ac466d2" translate="yes" xml:space="preserve">
          <source>If we wanted, we could leave off the initializers entirely:</source>
          <target state="translated">必要に応じて、イニシャライザを完全に省略することができます。</target>
        </trans-unit>
        <trans-unit id="83df15e4cf413e10be414506c047c7618a0d3d89" translate="yes" xml:space="preserve">
          <source>If we were to use &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factories&lt;/a&gt;, we can observe this evaluation order with the following example:</source>
          <target state="translated">&lt;a href=&quot;#decorator-factories&quot;&gt;デコレータファクトリ&lt;/a&gt;を使用する場合、次の例でこの評価順序を確認できます。</target>
        </trans-unit>
        <trans-unit id="89a7882773e333f0676bc25954729647144846fe" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;tsconfig.json&lt;/code&gt; file, TypeScript files that are not considered part of that context are not compiled.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを追加しても、そのコンテキストの一部と見なされないTypeScriptファイルはコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="4c6633882fd2cbc849cc78df7098cdbc11e0f7c9" translate="yes" xml:space="preserve">
          <source>If you are using a different build tool to build your project (e.g. gulp, grunt , etc.) and VS for the development and debugging experience, set &lt;code&gt;&amp;lt;TypeScriptCompileBlocked&amp;gt;true&amp;lt;/TypeScriptCompileBlocked&amp;gt;&lt;/code&gt; in your project. This should give you all the editing support, but not the build when you hit F5.</source>
          <target state="translated">別のビルドツールを使用してプロジェクト（gulp、gruntなど）とVSを開発およびデバッグエクスペリエンスのためにビルドする場合は、プロジェクトで &lt;code&gt;&amp;lt;TypeScriptCompileBlocked&amp;gt;true&amp;lt;/TypeScriptCompileBlocked&amp;gt;&lt;/code&gt; します。 これにより、すべての編集サポートが提供されますが、F5キーを押してもビルドは提供されません。</target>
        </trans-unit>
        <trans-unit id="5cd9012eef954c07679b23981cd46180ffa74948" translate="yes" xml:space="preserve">
          <source>If you check in any build outputs (&lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt;, &lt;code&gt;.d.ts.map&lt;/code&gt;, etc.), you may need to run a &lt;code&gt;--force&lt;/code&gt; build after certain source control operations depending on whether your source control tool preserves timestamps between the local copy and the remote copy.</source>
          <target state="translated">ビルド出力（ &lt;code&gt;.js&lt;/code&gt; 、 &lt;code&gt;.d.ts.map&lt;/code&gt; 、.d.ts.mapなど）をチェックインする場合、ソース管理ツールが保持するかどうかに応じて、特定のソース管理操作の後に &lt;code&gt;--force&lt;/code&gt; ビルドを実行しますローカルコピーとリモートコピーの間にタイムスタンプを付ける必要があります。</target>
        </trans-unit>
        <trans-unit id="6a349b11b7d0ef239663304628dfd9c61e8381c6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to take the time to write out declarations before using a new module, you can now just use a shorthand declaration to get started quickly.</source>
          <target state="translated">新しいモジュールを使用する前に宣言を書き出すことに時間を費やしたくない場合は、簡単な宣言ですぐに始めることができます。</target>
        </trans-unit>
        <trans-unit id="fae05d77b88c64d5e95a8ef1a5541f4907ad6f4f" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to take the time to write out declarations before using a new module, you can use a shorthand declaration to get started quickly.</source>
          <target state="translated">新しいモジュールを使用する前に宣言を書き出すのに時間をかけたくない場合は、速記宣言を使用してすぐに開始できます。</target>
        </trans-unit>
        <trans-unit id="b6d64531eb1511551180721cfd80f278a3113a79" translate="yes" xml:space="preserve">
          <source>If you ever have a value that TypeScript thinks is possibly &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt;, but you know better, you can use the postfix &lt;code&gt;!&lt;/code&gt; operator to tell it otherwise.</source>
          <target state="translated">TypeScriptが &lt;code&gt;null&lt;/code&gt; / &lt;code&gt;undefined&lt;/code&gt; である可能性があるとみなす値があるが、その値に精通している場合は、サフィックスを使用できます &lt;code&gt;!&lt;/code&gt; そうでないことを伝える演算子。</target>
        </trans-unit>
        <trans-unit id="3c329b002b75ec8975f18054725c2bf4040952e7" translate="yes" xml:space="preserve">
          <source>If you had the following Node/CommonJS code:</source>
          <target state="translated">次のNode / CommonJSコードがある場合：</target>
        </trans-unit>
        <trans-unit id="dc04d34dfcaac9afb16dfcca2506c06bccfa00d4" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;tests&lt;/code&gt; folder outside of your &lt;code&gt;src&lt;/code&gt; directory, you might have one &lt;code&gt;tsconfig.json&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt;, and one in &lt;code&gt;tests&lt;/code&gt; as well.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; ディレクトリの外側に &lt;code&gt;tests&lt;/code&gt; フォルダーがある場合、 srcに &lt;code&gt;tsconfig.json&lt;/code&gt; が1つ、 &lt;code&gt;tests&lt;/code&gt; に 1つある場合があります 。</target>
        </trans-unit>
        <trans-unit id="1c080c78e7a69573dae8c2024c9d66a13c40bf94" translate="yes" xml:space="preserve">
          <source>If you have a type with a number index signature, &lt;code&gt;keyof T&lt;/code&gt; will just be &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">数値インデックスシグネチャを持つ型がある場合、 &lt;code&gt;keyof T&lt;/code&gt; は単なる &lt;code&gt;number&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="bad1becd57096ef1e33ba9bd0ebbac35bc9622bd" translate="yes" xml:space="preserve">
          <source>If you have an msbuild project, you can enable build mode by adding</source>
          <target state="translated">msbuildプロジェクトがある場合、以下を追加してビルドモードを有効にできます。</target>
        </trans-unit>
        <trans-unit id="88dba7da91434766a3c79f38e44d7fef30aa351c" translate="yes" xml:space="preserve">
          <source>If you intended to test the function without calling it, you can correct the definition of it to include &lt;code&gt;undefined&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt;, or use &lt;code&gt;!!&lt;/code&gt; to write something like &lt;code&gt;if (!!user.isAdministrator)&lt;/code&gt; to indicate that the coercion is intentional.</source>
          <target state="translated">関数を呼び出さずにテストする場合は、定義を変更して &lt;code&gt;undefined&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; を含めるか、 &lt;code&gt;!!&lt;/code&gt; を使用できます。 &lt;code&gt;if (!!user.isAdministrator)&lt;/code&gt; ようなもので、強制が意図的であることを示します。</target>
        </trans-unit>
        <trans-unit id="ed97452c7f7269f74ea84e8195f99486afcc62bd" translate="yes" xml:space="preserve">
          <source>If you plan on using the stricter settings that are available, it&amp;rsquo;s best to turn them on now (see &lt;a href=&quot;#getting-stricter-checks&quot;&gt;Getting Stricter Checks&lt;/a&gt; below). For instance, if you never want TypeScript to silently infer &lt;code&gt;any&lt;/code&gt; for a type without you explicitly saying so, you can use &lt;code&gt;noImplicitAny&lt;/code&gt; before you start modifying your files. While it might feel somewhat overwhelming, the long-term gains become apparent much more quickly.</source>
          <target state="translated">より厳しい設定を使用する予定がある場合は、すぐに有効にすることを&lt;a href=&quot;#getting-stricter-checks&quot;&gt;お勧め&lt;/a&gt;します（以下の「より厳密なチェックの取得」を参照）。 たとえば、TypeScriptで明示的に指定せずに暗黙的な型推論を実行したくない場合は、ファイルの変更を開始する前に &lt;code&gt;noImplicitAny&lt;/code&gt; を使用できます。 圧倒的に聞こえるかもしれませんが、長期的な利点はより早く明らかになります。</target>
        </trans-unit>
        <trans-unit id="d704dd727aa16026d03295d60e4fd6bd0f450b47" translate="yes" xml:space="preserve">
          <source>If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have. In our &lt;code&gt;loggingIdentity&lt;/code&gt; example, we wanted to be able to access the &lt;code&gt;.length&lt;/code&gt; property of &lt;code&gt;arg&lt;/code&gt;, but the compiler could not prove that every type had a &lt;code&gt;.length&lt;/code&gt; property, so it warns us that we can&amp;rsquo;t make this assumption.</source>
          <target state="translated">前の例を思い出すと、一連のタイプの機能についてある程度の知識がある一連のタイプで機能する汎用関数を作成できます。 &lt;code&gt;loggingIdentity&lt;/code&gt; の例では、 &lt;code&gt;arg&lt;/code&gt; の &lt;code&gt;.length&lt;/code&gt; プロパティにアクセスできるようにしたかったのですが、コンパイラはすべての型に &lt;code&gt;.length&lt;/code&gt; プロパティがあることを証明できなかったため、この仮定を立てることができないと警告しました。 君は。</target>
        </trans-unit>
        <trans-unit id="f2f60b10d440544ea9c56ee6406205dc250ac35c" translate="yes" xml:space="preserve">
          <source>If you see tests for &lt;code&gt;typeof define&lt;/code&gt;, &lt;code&gt;typeof window&lt;/code&gt;, or &lt;code&gt;typeof module&lt;/code&gt; in the code of a library, especially at the top of the file, it&amp;rsquo;s almost always a UMD library.</source>
          <target state="translated">&lt;code&gt;typeof define&lt;/code&gt; 、 &lt;code&gt;typeof window&lt;/code&gt; 、または &lt;code&gt;typeof module&lt;/code&gt; テストがファイルの上部、特にライブラリ内のコードで表示される場合、ほとんどの場合UMDライブラリです。</target>
        </trans-unit>
        <trans-unit id="c25089b3bb720ad8bf4d7033bc03403e6d851984" translate="yes" xml:space="preserve">
          <source>If you started converting over to TypeScript imports, you&amp;rsquo;ll probably run into errors like &lt;code&gt;Cannot find module 'foo'.&lt;/code&gt;. The issue here is that you likely don&amp;rsquo;t have &lt;em&gt;declaration files&lt;/em&gt; to describe your library. Luckily this is pretty easy. If TypeScript complains about a package like &lt;code&gt;lodash&lt;/code&gt;, you can just write</source>
          <target state="translated">TypeScriptインポートへの変換を開始すると、おそらく &lt;code&gt;Cannot find module 'foo'.&lt;/code&gt; などのエラーが表示されます。 。 。 ここでの問題は、ライブラリを記述する&lt;em&gt;宣言ファイル&lt;/em&gt;がない場合がある&lt;em&gt;ことです&lt;/em&gt; 。 幸いなことに、これは非常に簡単です。 TypeScriptが &lt;code&gt;lodash&lt;/code&gt; のようなパッケージについて文句を言う場合、次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="b4fea75c265155bd6df0203787b647e915b7efa9" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;y&lt;/code&gt; in a way that the type parameter&amp;rsquo;s constraint doesn&amp;rsquo;t support, you&amp;rsquo;ll correctly get an error. In this case, the constraint of &lt;code&gt;T&lt;/code&gt; was (implicitly) &lt;code&gt;{}&lt;/code&gt;, so the last example will appropriately fail.</source>
          <target state="translated">typeパラメーターの制約でサポートされていない方法で &lt;code&gt;y&lt;/code&gt; を使用すると、エラーが正しく生成されるようになりました。 この場合、 &lt;code&gt;T&lt;/code&gt; の制約が（暗黙的に） &lt;code&gt;{}&lt;/code&gt; であったため、最後の例は適切に失敗します。</target>
        </trans-unit>
        <trans-unit id="e6bd2cecc096e05874940061ada8a05394b1dbd5" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d prefer to be explicit, you can also enforce the type of values that can be returned, yielded, and evaluated from &lt;code&gt;yield&lt;/code&gt; expressions using an explicit return type. Below, &lt;code&gt;next()&lt;/code&gt; can only be called with &lt;code&gt;boolean&lt;/code&gt;s, and depending on the value of &lt;code&gt;done&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is either a &lt;code&gt;string&lt;/code&gt; or a &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">明示的にしたい場合は、明示的な戻り値の型を使用して、 &lt;code&gt;yield&lt;/code&gt; 式から返され、生成され、評価される値の型を強制することもできます。 以下では、 &lt;code&gt;done&lt;/code&gt; の値に応じて、 &lt;code&gt;next()&lt;/code&gt; は &lt;code&gt;boolean&lt;/code&gt; でのみ呼び出すことができ &lt;code&gt;value&lt;/code&gt; 。値は &lt;code&gt;string&lt;/code&gt; またはvalueです。</target>
        </trans-unit>
        <trans-unit id="25c9ec1976e4df8a2ef8c0b469042e5f520617b9" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re converting a program from namespaces to modules, it can be easy to end up with a file that looks like this:</source>
          <target state="translated">プログラムを名前空間からモジュールに変換するとき、次のファイルを簡単に作成できます。</target>
        </trans-unit>
        <trans-unit id="513d665d33a30074384ac54ddb0be0edac2c6bbf" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re exporting multiple objects, put them all at top-level</source>
          <target state="translated">複数のオブジェクトをエクスポートする場合、それらをすべて最上位に配置します</target>
        </trans-unit>
        <trans-unit id="e6a9291b44ab09ee343d0c813d7995f1938982dd" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re looking to convert a React project, we recommend looking at the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide&quot;&gt;React Conversion Guide&lt;/a&gt; first.</source>
          <target state="translated">Reactプロジェクトを変換する場合、まずReact Conversion Guideを&lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide&quot;&gt;参照&lt;/a&gt;することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6b3d86758d6ba06b2c6d545d9e0ad1ace8a4b070" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re only exporting a single &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;function&lt;/code&gt;, use &lt;code&gt;export default&lt;/code&gt;</source>
          <target state="translated">単一の &lt;code&gt;class&lt;/code&gt; または &lt;code&gt;function&lt;/code&gt; のみをエクスポートする場合は、 &lt;code&gt;export default&lt;/code&gt; 使用します</target>
        </trans-unit>
        <trans-unit id="2f70d23b3b33808540611f0c15d2283c4e323059" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re reading this guide, you probably already roughly know what a type in TypeScript is. To be more explicit, though, a &lt;em&gt;type&lt;/em&gt; is introduced with:</source>
          <target state="translated">このガイドを読んでいるなら、おそらくTypeScriptの種類について多くを知っているでしょう。 ただし、明確にするために、次のように&lt;em&gt;型&lt;/em&gt;が導入されています。</target>
        </trans-unit>
        <trans-unit id="b934c40448796bd9edae2d68f2dcee6ad19754ce" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re starting a brand new project, take a look at the &lt;a href=&quot;https://create-react-app.dev/docs/adding-typescript&quot;&gt;React Quick Start guide&lt;/a&gt; first.</source>
          <target state="translated">新しいプロジェクトを開始し&lt;a href=&quot;https://create-react-app.dev/docs/adding-typescript&quot;&gt;たい&lt;/a&gt;場合は、React Quick Start Guideから始めてください。</target>
        </trans-unit>
        <trans-unit id="cff1c0146ace654a504313182db4a173a9b3388c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Gulp in some fashion, we have a tutorial on &lt;a href=&quot;gulp&quot;&gt;using Gulp&lt;/a&gt; with TypeScript, and integrating with common build tools like Browserify, Babelify, and Uglify. You can read more there.</source>
          <target state="translated">Gulpを何らかの方法で使用する場合、TypeScriptでGulpを使用し、Browserify、Babelify、Uglifyなどの一般的なビルドツールと統合するためのチュートリアルがあります。 そこにもっと読むことができます。</target>
        </trans-unit>
        <trans-unit id="cafdaaff5d59cc2c2f1205e3709213e65336f377" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a module option other than &lt;code&gt;commonjs&lt;/code&gt;, you&amp;rsquo;ll need to set your &lt;code&gt;moduleResolution&lt;/code&gt; option to &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;commonjs&lt;/code&gt; 以外のモジュールオプションを使用している場合は、 &lt;code&gt;moduleResolution&lt;/code&gt; オプションを &lt;code&gt;node&lt;/code&gt; に設定する必要があります 。</target>
        </trans-unit>
        <trans-unit id="0aafe02ccb06b6d197194a0b7f3d99641d791f0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing in plain JavaScript, it&amp;rsquo;s likely that you&amp;rsquo;re running your JavaScript directly, where your &lt;code&gt;.js&lt;/code&gt; files are in a &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;lib&lt;/code&gt;, or &lt;code&gt;dist&lt;/code&gt; directory, and then ran as desired.</source>
          <target state="translated">単純なJavaScriptで記述する場合、JavaScriptを直接実行できます。 この場合、 &lt;code&gt;.js&lt;/code&gt; ファイルは &lt;code&gt;src&lt;/code&gt; 、 &lt;code&gt;lib&lt;/code&gt; 、または &lt;code&gt;dist&lt;/code&gt; ディレクトリにあり、必要に応じて実行されます。</target>
        </trans-unit>
        <trans-unit id="fdfba1223ac1da9db70e78da0daf0187962aac1a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve read about &lt;code&gt;typeof&lt;/code&gt; type guards and are familiar with the &lt;code&gt;instanceof&lt;/code&gt; operator in JavaScript, you probably have some idea of what this section is about.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; typeguardについて読んだことがあり、JavaScript &lt;code&gt;instanceof&lt;/code&gt; 演算子に精通している場合は、このセクションが何であるかについておそらく考えているでしょう。</target>
        </trans-unit>
        <trans-unit id="ba89c0b592333fdedc6dea3af514c7a63cd66e0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve used JavaScript offhandedly, the next section might be a good way to refresh your memory. If you&amp;rsquo;re intimately familiar with all the quirks of &lt;code&gt;var&lt;/code&gt; declarations in JavaScript, you might find it easier to skip ahead.</source>
          <target state="translated">JavaScriptをオフハンドで使用している場合、次のセクションは記憶をリフレッシュする良い方法です。 JavaScript &lt;code&gt;var&lt;/code&gt; 宣言のすべての癖に慣れている場合は、最初にスキップする方が簡単な場合があります。</target>
        </trans-unit>
        <trans-unit id="7f637065274f76d0b1f9c68b24c257b06ecca8b9" translate="yes" xml:space="preserve">
          <source>If your functions are only able to handle string named property keys, use &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; in the declaration:</source>
          <target state="translated">関数がプロパティキーという名前の文字列のみを処理できる場合は、宣言で &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="d510aeb4b1e7484eea0e856138d74440b24ca0d1" translate="yes" xml:space="preserve">
          <source>If your functions are open to handling all property keys, then the changes should be done down-stream:</source>
          <target state="translated">関数がすべてのプロパティキーを処理できる場合は、下流で変更を加える必要があります。</target>
        </trans-unit>
        <trans-unit id="f902e411cb6ca33234031133f35364e8839ccd53" translate="yes" xml:space="preserve">
          <source>If your global library depends on a UMD module, use a &lt;code&gt;/// &amp;lt;reference types&lt;/code&gt; directive:</source>
          <target state="translated">グローバルライブラリがUMDモジュールに依存している場合は、 &lt;code&gt;/// &amp;lt;reference types&lt;/code&gt; ディレクティブを使用します。</target>
        </trans-unit>
        <trans-unit id="f7345e0903abc9ae4ad2adfd269b38c296742fa6" translate="yes" xml:space="preserve">
          <source>If your library depends on a global library, use a &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive:</source>
          <target state="translated">ライブラリがグローバルライブラリに依存している場合は、 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; ディレクティブを使用します。</target>
        </trans-unit>
        <trans-unit id="b2e55a3a3ef94d5068ad16150d23ae196cc87947" translate="yes" xml:space="preserve">
          <source>If your library depends on a module, use an &lt;code&gt;import&lt;/code&gt; statement:</source>
          <target state="translated">ライブラリがモジュールに依存している場合、 &lt;code&gt;import&lt;/code&gt; ステートメントを使用します。</target>
        </trans-unit>
        <trans-unit id="39f14e77085a3e6f94f80d3a5737a97256584f64" translate="yes" xml:space="preserve">
          <source>If your module is not callable or constructable, use the &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">モジュールがcallableまたは&lt;a href=&quot;templates/module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt;ではない場合、module.d.tsファイルを使用します。</target>
        </trans-unit>
        <trans-unit id="708b87e0f5ca75919f8732aead8eedddc9c8eae8" translate="yes" xml:space="preserve">
          <source>If your module or UMD library depends on a UMD library, use an &lt;code&gt;import&lt;/code&gt; statement:</source>
          <target state="translated">モジュールまたはUMDライブラリがUMDライブラリに依存している場合は、 &lt;code&gt;import&lt;/code&gt; ステートメントを使用します。</target>
        </trans-unit>
        <trans-unit id="b502ac0f72d569709af646c5ae02325abd8bb700" translate="yes" xml:space="preserve">
          <source>If your package has a main &lt;code&gt;.js&lt;/code&gt; file, you will need to indicate the main declaration file in your &lt;code&gt;package.json&lt;/code&gt; file as well. Set the &lt;code&gt;types&lt;/code&gt; property to point to your bundled declaration file. For example:</source>
          <target state="translated">パッケージにメインの &lt;code&gt;.js&lt;/code&gt; ファイルがある場合は、 &lt;code&gt;package.json&lt;/code&gt; ファイルでメインの宣言ファイルも指定する必要があります。 バンドルされている宣言ファイルを指すように、 &lt;code&gt;types&lt;/code&gt; プロパティを設定します。 例えば：</target>
        </trans-unit>
        <trans-unit id="8809cc04677d076884fe6edcda034b008be7ba2b" translate="yes" xml:space="preserve">
          <source>If your package is not written in TypeScript then the second is the preferred approach.</source>
          <target state="translated">パッケージがTypeScriptで記述されていない場合、2番目の方法をお勧めします。</target>
        </trans-unit>
        <trans-unit id="3a45948f03090d8097a2e93bad2b6d30f82543a2" translate="yes" xml:space="preserve">
          <source>If your package is written in TypeScript then the first approach is favored. Use the &lt;code&gt;--declaration&lt;/code&gt; flag to generate declaration files. This way, your declarations and JavaScript will always be in sync.</source>
          <target state="translated">パッケージがTypeScriptで記述されている場合、最初のアプローチが推奨されます。 &lt;code&gt;--declaration&lt;/code&gt; フラグは、宣言ファイルを生成します。 これにより、宣言とJavaScriptの同期が維持されます。</target>
        </trans-unit>
        <trans-unit id="490e3c77ca2e4322ada004a6ddfd9a7799557dcc" translate="yes" xml:space="preserve">
          <source>If your type definitions depend on another package:</source>
          <target state="translated">型定義が別のパッケージに依存する場合：</target>
        </trans-unit>
        <trans-unit id="f5dd23741ab01d47a9d58ca45645a4ccefbbd8f1" translate="yes" xml:space="preserve">
          <source>Implementing an interface</source>
          <target state="translated">インターフェイス実装</target>
        </trans-unit>
        <trans-unit id="0aba642bf4d637216b8d72e2f4ad7c9560d9798e" translate="yes" xml:space="preserve">
          <source>Implicit any errors</source>
          <target state="translated">暗黙のエラー</target>
        </trans-unit>
        <trans-unit id="7d52fc0e48ad6e0d6c8f5245ccb19f1dd538a022" translate="yes" xml:space="preserve">
          <source>Implicit index signatures</source>
          <target state="translated">暗黙的なインデックス署名</target>
        </trans-unit>
        <trans-unit id="c8c4c307ff84c0f8c706629a70179c01013c51e4" translate="yes" xml:space="preserve">
          <source>Implicit returns</source>
          <target state="translated">暗黙の戻り</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="ac42b7771deabcf8b9b301382d1ce7966a14ab50" translate="yes" xml:space="preserve">
          <source>Import a module for side-effects only</source>
          <target state="translated">副作用のみのモジュールをインポートする</target>
        </trans-unit>
        <trans-unit id="c5b568ec8548086b4de521e5d8033aec1c934aac" translate="yes" xml:space="preserve">
          <source>Import a single export from a module</source>
          <target state="translated">モジュールから単一のエクスポートをインポートする</target>
        </trans-unit>
        <trans-unit id="7830f060b13276e33e83c28a73aa77da5e486098" translate="yes" xml:space="preserve">
          <source>Import declarations, as well, can optionally use &lt;code&gt;as&lt;/code&gt; clauses to specify different local names for the imports. For example:</source>
          <target state="translated">インポート宣言では、オプションの &lt;code&gt;as&lt;/code&gt; 句を使用して、インポートに別のローカル名を指定することもできます。 例えば：</target>
        </trans-unit>
        <trans-unit id="9914e368d228c16ed67283b9e88ab7f396d147f6" translate="yes" xml:space="preserve">
          <source>Import emit helpers (e.g. &lt;code&gt;__extends&lt;/code&gt;, &lt;code&gt;__rest&lt;/code&gt;, etc..) from &lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt;から &lt;code&gt;__rest&lt;/code&gt; ヘルパー（ &lt;code&gt;__extends&lt;/code&gt; 、__ restなど）をインポートします。</target>
        </trans-unit>
        <trans-unit id="d44d2976c5175c70409be4c97c0352850c0e7940" translate="yes" xml:space="preserve">
          <source>Import the entire module into a single variable, and use it to access the module exports</source>
          <target state="translated">モジュール全体を単一の変数にインポートし、それを使用してモジュールのエクスポートにアクセスします</target>
        </trans-unit>
        <trans-unit id="f908ff98948cecb3646ddcfb8cfb7d6851889ec0" translate="yes" xml:space="preserve">
          <source>Import types</source>
          <target state="translated">インポートタイプ</target>
        </trans-unit>
        <trans-unit id="a60647122c766cfb16cfd3672d6ea4130dbed5fe" translate="yes" xml:space="preserve">
          <source>Importing from Modules</source>
          <target state="translated">モジュールからインポート</target>
        </trans-unit>
        <trans-unit id="f3c938e48f51fc9b9d8d6906d41005ba5ef033c7" translate="yes" xml:space="preserve">
          <source>Importing is just about as easy as exporting from a module. Importing an exported declaration is done through using one of the &lt;code&gt;import&lt;/code&gt; forms below:</source>
          <target state="translated">インポートは、モジュールからエクスポートするのと同じくらい簡単です。 エクスポートされた宣言のインポートは、次のインポートフォームのいずれかを使用して行われます。</target>
        </trans-unit>
        <trans-unit id="9f780bafb7678e0e4bc2ed60d39928e72d6363d4" translate="yes" xml:space="preserve">
          <source>Importing modules from a referenced project will instead load its &lt;em&gt;output&lt;/em&gt; declaration file (&lt;code&gt;.d.ts&lt;/code&gt;)</source>
          <target state="translated">参照プロジェクトからモジュールをインポートすると、代わりにその&lt;em&gt;出力&lt;/em&gt;宣言ファイル（ &lt;code&gt;.d.ts&lt;/code&gt; ）がロードされます</target>
        </trans-unit>
        <trans-unit id="1493dcf2543fd7025bb0dc28504a88da052081ce" translate="yes" xml:space="preserve">
          <source>Importing none-code resources using module loaders extension (e.g. &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt; or &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.html&quot;&gt;SystemJS&lt;/a&gt;) has not been easy before; previously an ambient module declaration had to be defined for each resource.</source>
          <target state="translated">モジュールローダー拡張機能（ &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt;やSystemJS &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.html&quot;&gt;など）&lt;/a&gt;を使用してコードなしでリソースをインポートすることは、これまでになく簡単になりました。 以前は、リソースごとにアンビエントモジュール宣言を定義する必要がありました。</target>
        </trans-unit>
        <trans-unit id="352d94d7b6ad5d2d2dd80449838c2cf319556903" translate="yes" xml:space="preserve">
          <source>Improved &lt;code&gt;any&lt;/code&gt; Inference</source>
          <target state="translated">推論を改善する</target>
        </trans-unit>
        <trans-unit id="400b56a2fe294d586033d28165229215531d4f5f" translate="yes" xml:space="preserve">
          <source>Improved &lt;code&gt;keyof&lt;/code&gt; with intersection types</source>
          <target state="translated">交差点タイプの改善された &lt;code&gt;keyof&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5db53c8c85f119e50fb4fddb0515ec92c8d14cae" translate="yes" xml:space="preserve">
          <source>Improved UX Around Promises</source>
          <target state="translated">Promiseを取り巻くUXの改善</target>
        </trans-unit>
        <trans-unit id="39095ed614c976a48a5edd3ac9559249a5bcafb9" translate="yes" xml:space="preserve">
          <source>Improved behavior for calling union types</source>
          <target state="translated">ユニオン型を呼び出すための改善された動作</target>
        </trans-unit>
        <trans-unit id="3aed2d7ad51f292dd55e2c452dc2f9d916f9f348" translate="yes" xml:space="preserve">
          <source>Improved checking for &lt;code&gt;for..in&lt;/code&gt; statements</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; ステートメントのチェックの改善</target>
        </trans-unit>
        <trans-unit id="c02cdcb0697c02f23de76b9402b3ffb5de18ea5a" translate="yes" xml:space="preserve">
          <source>Improved checking for destructuring object literal</source>
          <target state="translated">非構造化オブジェクトリテラルのチェックの改善</target>
        </trans-unit>
        <trans-unit id="55bbe6a04eaea70e8654bdf75776576f97a9d374" translate="yes" xml:space="preserve">
          <source>Improved control over mapped type modifiers</source>
          <target state="translated">マップされた型修飾子の制御の改善</target>
        </trans-unit>
        <trans-unit id="be88c1fb8d146d0b9d876f22a0754323c60b7258" translate="yes" xml:space="preserve">
          <source>Improved excess property checks in union types</source>
          <target state="translated">ユニオン型の過剰なプロパティチェックの改善</target>
        </trans-unit>
        <trans-unit id="f0d6c8d205edfb92cb01f19342a7ad56a1cfd004" translate="yes" xml:space="preserve">
          <source>Improved handling of structurally identical classes and &lt;code&gt;instanceof&lt;/code&gt; expressions</source>
          <target state="translated">構造的に同一のクラスと &lt;code&gt;instanceof&lt;/code&gt; 式の処理の改善</target>
        </trans-unit>
        <trans-unit id="79046527e77a08d10c738b0d3678766e68083dfb" translate="yes" xml:space="preserve">
          <source>Improved inference for generics</source>
          <target state="translated">汎用的な推論の改善</target>
        </trans-unit>
        <trans-unit id="9902b64afde9c77bb740ee885857e65ab81753ae" translate="yes" xml:space="preserve">
          <source>Improved support for &lt;code&gt;tsconfig.json&lt;/code&gt; in Visual Studio 2015</source>
          <target state="translated">Visual Studio 2015での &lt;code&gt;tsconfig.json&lt;/code&gt; のサポートの改善</target>
        </trans-unit>
        <trans-unit id="cc966416a9eb70b531ccdaadbbaafa22d9349454" translate="yes" xml:space="preserve">
          <source>Improved type inference for object literals</source>
          <target state="translated">オブジェクトリテラルの改善された型推論</target>
        </trans-unit>
        <trans-unit id="b87ca7b1554d820cbb558e72b3dc2dd9bb2048e0" translate="yes" xml:space="preserve">
          <source>Improved union/intersection type inference</source>
          <target state="translated">ユニオン/インターセクションタイプの推論の改善</target>
        </trans-unit>
        <trans-unit id="73d903d34db6a7a7623b02e31683adc136bd1806" translate="yes" xml:space="preserve">
          <source>Improvements for &lt;code&gt;ReadonlyArray&lt;/code&gt; and &lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target state="translated">&lt;code&gt;ReadonlyArray&lt;/code&gt; および &lt;code&gt;readonly&lt;/code&gt; タプル</target>
        </trans-unit>
        <trans-unit id="75cc15f25fc2ae5d077c25f2e3c6ed80c124c408" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;templates&quot;&gt;Templates&lt;/a&gt; you&amp;rsquo;ll find a number of declaration files that serve as a useful starting point when writing a new file. Refer to the documentation in &lt;a href=&quot;library-structures&quot;&gt;Library Structures&lt;/a&gt; to figure out which template file to use.</source>
          <target state="translated">&lt;a href=&quot;templates&quot;&gt;テンプレートに&lt;/a&gt;は、新しいファイルを作成するための便利な出発点として役立つ多くの宣言ファイルがあります。 &lt;a href=&quot;library-structures&quot;&gt;ライブラリ構造の&lt;/a&gt;ドキュメントを参照して、使用するテンプレートファイルを決定してください。</target>
        </trans-unit>
        <trans-unit id="053ea35eb45b9803ab97bdc192cb5d0db843884b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, a &lt;code&gt;?&lt;/code&gt; modifier automatically includes &lt;code&gt;undefined&lt;/code&gt; in the element type, similar to optional parameters.</source>
          <target state="translated">&lt;code&gt;--strictNullChecks&lt;/code&gt; モード、 &lt;code&gt;?&lt;/code&gt; 修飾子は、 &lt;code&gt;undefined&lt;/code&gt; 要素タイプとオプションのパラメーターを自動的に含めます。</target>
        </trans-unit>
        <trans-unit id="c75d3751acc8527d062926da04731cafe2436c23" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;getProperty&lt;/code&gt;, &lt;code&gt;o: T&lt;/code&gt; and &lt;code&gt;propertyName: K&lt;/code&gt;, so that means &lt;code&gt;o[propertyName]: T[K]&lt;/code&gt;. Once you return the &lt;code&gt;T[K]&lt;/code&gt; result, the compiler will instantiate the actual type of the key, so the return type of &lt;code&gt;getProperty&lt;/code&gt; will vary according to which property you request.</source>
          <target state="translated">&lt;code&gt;getProperty&lt;/code&gt; 、 &lt;code&gt;o: T&lt;/code&gt; および &lt;code&gt;propertyName: K&lt;/code&gt; は &lt;code&gt;o[propertyName]: T[K]&lt;/code&gt; 意味します。 &lt;code&gt;T[K]&lt;/code&gt; はT [K]の結果を返します。コンパイラはキーの実際の型をインスタンス化するため、 &lt;code&gt;getProperty&lt;/code&gt; の戻り型は要求するプロパティに依存します。</target>
        </trans-unit>
        <trans-unit id="cac8a395d23bb271c0a5b1d7324f422027c11b0c" translate="yes" xml:space="preserve">
          <source>In ES2015, constructors which return an object implicitly substitute the value of &lt;code&gt;this&lt;/code&gt; for any callers of &lt;code&gt;super()&lt;/code&gt;. As a result, it is necessary to capture any potential return value of &lt;code&gt;super()&lt;/code&gt; and replace it with &lt;code&gt;this&lt;/code&gt;. This change enables working with &lt;a href=&quot;https://w3c.github.io/webcomponents/spec/custom/#htmlelement-constructor&quot;&gt;Custom Elements&lt;/a&gt;, which takes advantage of this to initialize browser-allocated elements with user-written constructors.</source>
          <target state="translated">ES2015では、オブジェクトを返すコンストラクターが、 &lt;code&gt;this&lt;/code&gt; の値である &lt;code&gt;super()&lt;/code&gt; 呼び出し元を暗黙的に置き換えます。 その結果、 &lt;code&gt;super()&lt;/code&gt; は潜在的な戻り値をキャプチャし、 &lt;code&gt;this&lt;/code&gt; を置き換える必要があります 。 この変更により、 &lt;a href=&quot;https://w3c.github.io/webcomponents/spec/custom/#htmlelement-constructor&quot;&gt;カスタム要素&lt;/a&gt;を操作できます。 カスタム要素はこれを使用して、ユーザーが作成したコンストラクターでブラウザーに割り当てられた要素を初期化します。</target>
        </trans-unit>
        <trans-unit id="367fc6bebb59a7cbd1d7db58cf0d02857ed175b8" translate="yes" xml:space="preserve">
          <source>In ES6 module loaders, the top-level object (here imported as &lt;code&gt;exp&lt;/code&gt;) can only have properties; the top-level module object is &lt;em&gt;never&lt;/em&gt; callable. The most common solution here is to define a &lt;code&gt;default&lt;/code&gt; export for a callable/constructable object; some module loader shims will automatically detect this situation and replace the top-level object with the &lt;code&gt;default&lt;/code&gt; export.</source>
          <target state="translated">ES6モジュールローダーでは、最上位オブジェクト（ここでは &lt;code&gt;exp&lt;/code&gt; としてインポートされます）はプロパティのみを持つことができます。 トップレベルのモジュールオブジェクトは&lt;em&gt;決して&lt;/em&gt;呼び出し可能です。 ここで最も一般的な解決策は、呼び出し可能/構築可能なオブジェクトの &lt;code&gt;default&lt;/code&gt; エクスポートを定義することです 。 一部のモジュールローダーシムは、この状況を自動的に検出し、最上位オブジェクトを &lt;code&gt;default&lt;/code&gt; エクスポートに置き換えます 。</target>
        </trans-unit>
        <trans-unit id="f9178ac7270dcc05dceadc49b3f02c9dc7dcbddb" translate="yes" xml:space="preserve">
          <source>In Edge, press F12 and click the Debugger tab.</source>
          <target state="translated">Edgeで、F12を押して[デバッガー]タブをクリックします。</target>
        </trans-unit>
        <trans-unit id="54dc2fcbcb0f1f6b32f8968730c12d2717aff252" translate="yes" xml:space="preserve">
          <source>In JSDoc references</source>
          <target state="translated">JSDocリファレンスを使用</target>
        </trans-unit>
        <trans-unit id="6fdb267749a0a65e58ebbcd5a8e1c2849232fca7" translate="yes" xml:space="preserve">
          <source>In JavaScript it is fairly common to have APIs that expect property names as parameters, but so far it hasn&amp;rsquo;t been possible to express the type relationships that occur in those APIs.</source>
          <target state="translated">JavaScriptでは、プロパティ名をパラメーターとして期待するAPIを使用することはかなり一般的ですが、これらのAPIで発生する型の関係を表現することはできませんでした。</target>
        </trans-unit>
        <trans-unit id="9d68eb64db15f82423559857fcf4d5a5356cdcf0" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;code&gt;this&lt;/code&gt; is a variable that&amp;rsquo;s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This is notoriously confusing, especially when returning a function or passing a function as an argument.</source>
          <target state="translated">JavaScriptでは、 &lt;code&gt;this&lt;/code&gt; は関数が呼び出されたときに設定される変数です。 これは非常に強力で柔軟な機能ですが、関数が実行されているコンテキストを常に知る必要があります。 これは、特に関数を返したり、関数を引数として渡す場合に混乱が生じます。</target>
        </trans-unit>
        <trans-unit id="484bfab743be72776c5e3700ec9d551efe4c463b" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;code&gt;var&lt;/code&gt; declarations are &amp;ldquo;hoisted&amp;rdquo; to the top of their enclosing scope. This can result in confusing bugs:</source>
          <target state="translated">JavaScriptでは、 &lt;code&gt;var&lt;/code&gt; 宣言は囲みスコープの最上部に「上げられます」。 これは紛らわしいバグにつながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a721d5f467ada10610bec48c19e76c798ba0faad" translate="yes" xml:space="preserve">
          <source>In JavaScript, every parameter is optional, and users may leave them off as they see fit. When they do, their value is &lt;code&gt;undefined&lt;/code&gt;. We can get this functionality in TypeScript by adding a &lt;code&gt;?&lt;/code&gt; to the end of parameters we want to be optional. For example, let&amp;rsquo;s say we want the last name parameter from above to be optional:</source>
          <target state="translated">JavaScriptでは、すべてのパラメーターはオプションであり、ユーザーは必要に応じてパラメーターを省略できます。 その場合、それらの値は &lt;code&gt;undefined&lt;/code&gt; です。 TypeScriptでこの機能を取得するには、 &lt;code&gt;?&lt;/code&gt; 追加します。 。 パラメーターの最後までオプションにします。 たとえば、上記の姓のパラメータをオプションにしたいとします。</target>
        </trans-unit>
        <trans-unit id="cd949f14dcd3d1c680cfa42bdf9a32c9f564e9cb" translate="yes" xml:space="preserve">
          <source>In Node.js, most tasks are accomplished by loading one or more modules. We could define each module in its own &lt;code&gt;.d.ts&lt;/code&gt; file with top-level export declarations, but it&amp;rsquo;s more convenient to write them as one larger &lt;code&gt;.d.ts&lt;/code&gt; file. To do so, we use a construct similar to ambient namespaces, but we use the &lt;code&gt;module&lt;/code&gt; keyword and the quoted name of the module which will be available to a later import. For example:</source>
          <target state="translated">Node.jsでは、ほとんどのタスクは1つ以上のモジュールをロードすることで実行されます。 最上位のエクスポート宣言を使用して、各モジュールを独自の &lt;code&gt;.d.ts&lt;/code&gt; ファイルで定義できますが、1つの大きな &lt;code&gt;.d.ts&lt;/code&gt; ファイルとして記述する方が便利です。 そのためには、アンビエントネームスペースに類似した構造を使用し、モジュールキーワードとモジュールの引用符付きの名前を使用して、後で &lt;code&gt;module&lt;/code&gt; をインポートできるようにします。 例えば：</target>
        </trans-unit>
        <trans-unit id="9a8e105ae7200ecea675173edd80960ba967b794" translate="yes" xml:space="preserve">
          <source>In TypeScript 1.4, we added support for template strings for all targets, and tagged templates for just ES6. Thanks to some considerable work done by &lt;a href=&quot;https://github.com/ivogabe&quot;&gt;@ivogabe&lt;/a&gt;, we bridged the gap for for tagged templates in ES3 and ES5.</source>
          <target state="translated">TypeScript 1.4は、すべてのターゲットテンプレート文字列のサポートを追加し、ES6のみのタグ付きテンプレートを追加します。 @ivogabeによって行われた相当な作業の&lt;a href=&quot;https://github.com/ivogabe&quot;&gt;おかげ&lt;/a&gt;で、ES3とES5のタグ付きテンプレート間のギャップを埋めました。</target>
        </trans-unit>
        <trans-unit id="c136c2bbed32677bb7335ad748e3d5ef230b3921" translate="yes" xml:space="preserve">
          <source>In TypeScript 1.8 with the latest version of react.d.ts (see above), we&amp;rsquo;ve also greatly simplified the declaration of &lt;code&gt;props&lt;/code&gt; types.</source>
          <target state="translated">react.d.tsの最新バージョン（上記参照）を使用するTypeScript 1.8では、 &lt;code&gt;props&lt;/code&gt; 型の宣言も大幅に簡素化されました。</target>
        </trans-unit>
        <trans-unit id="51239dcf9cd000d42b9c40712065d5e3ac4e06b5" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.0, it has become significantly easier to consume declaration files, in acquiring, using, and finding them. This page details exactly how to do all three.</source>
          <target state="translated">TypeScript 2.0では、宣言ファイルを取得、使用、検索するときに、宣言ファイルを非常に簡単に使用できます。 このページでは、3つすべての実行方法について詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="280fed62c426cb333df0ac98e6eabc689470726c" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.3, TS introduced type checking of &lt;em&gt;children&lt;/em&gt;. &lt;em&gt;children&lt;/em&gt; is a special property in an &lt;em&gt;element attributes type&lt;/em&gt; where child &lt;em&gt;JSXExpression&lt;/em&gt;s are taken to be inserted into the attributes. Similar to how TS uses &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; to determine the name of &lt;em&gt;props&lt;/em&gt;, TS uses &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; to determine the name of &lt;em&gt;children&lt;/em&gt; within those props. &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; should be declared with a single property.</source>
          <target state="translated">TypeScript 2.3では、TSは&lt;em&gt;子供の&lt;/em&gt;型チェックを導入しました。 &lt;em&gt;children&lt;/em&gt;は、子&lt;em&gt;JSXExpression&lt;/em&gt;が&lt;em&gt;属性に&lt;/em&gt;挿入されるために取得される&lt;em&gt;要素属性タイプの&lt;/em&gt;特別なプロパティ&lt;em&gt;です&lt;/em&gt; 。 TSが &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; を使用して&lt;em&gt;小道具&lt;/em&gt;の名前を決定する方法と同様に、TSはJSX.ElementChildrenAttributeを使用してそれらの小道具内の&lt;em&gt;子&lt;/em&gt;の名前を決定します。 &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; は、単一のプロパティで宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="21bf9c2a83b6910226d6caf86b85a5fe927e4d3f" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.4, it&amp;rsquo;s now an error to assign anything to a weak type when there&amp;rsquo;s no overlap in properties. For example:</source>
          <target state="translated">TypeScript 2.4では、プロパティが重複していない場合、弱い型に何かを割り当てるとエラーになります。 例えば：</target>
        </trans-unit>
        <trans-unit id="0d04812c896e54873be22b5061fb98c356d962e4" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.4, the function on the right side implicitly &lt;em&gt;gains&lt;/em&gt; type parameters, and &lt;code&gt;y&lt;/code&gt; is inferred to have the type of that type-parameter.</source>
          <target state="translated">TypeScript 2.4では、右側の関数は暗黙的に型パラメーターを取得し、 &lt;code&gt;y&lt;/code&gt; はその型パラメーターの型を持つと推測されます。</target>
        </trans-unit>
        <trans-unit id="fcec71f6bd5ce7d77407d547d676e3be6ddf7295" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.6 and earlier, &lt;code&gt;[number, string, string]&lt;/code&gt; was considered a subtype of &lt;code&gt;[number, string]&lt;/code&gt;. This was motivated by TypeScript&amp;rsquo;s structural nature; the first and second elements of a &lt;code&gt;[number, string, string]&lt;/code&gt; are respectively subtypes of the first and second elements of &lt;code&gt;[number, string]&lt;/code&gt;. However, after examining real world usage of tuples, we noticed that most situations in which this was permitted was typically undesirable.</source>
          <target state="translated">TypeScript 2.6より前では、 &lt;code&gt;[number, string, string]&lt;/code&gt; は &lt;code&gt;[number, string]&lt;/code&gt; サブタイプと見なされていました。 これは、TypeScriptの構造的性質によって動機付けられました。 &lt;code&gt;[number, string]&lt;/code&gt; の最初と2番目の要素は、それぞれ[number、string]の最初と2番目の要素のサブタイプです。 ただし、タプルの実際の使用法を調べると、これが許可されるほとんどの状況は通常望ましくないことが示されています。</target>
        </trans-unit>
        <trans-unit id="649188580014293e883a71ef51c9fad716c1836d" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.7, tuples of different arities are no longer assignable to each other. Thanks to a pull request from &lt;a href=&quot;https://github.com/tycho01&quot;&gt;Tycho Grouwstra&lt;/a&gt;, tuple types now encode their arity into the type of their respective &lt;code&gt;length&lt;/code&gt; property. This is accomplished by leveraging numeric literal types, which now allow tuples to be distinct from tuples of different arities.</source>
          <target state="translated">TypeScript 2.7では、異なるアリティのタプルは互いに割り当てられなくなりました。 Tycho Grouwstraからのプルリクエストの&lt;a href=&quot;https://github.com/tycho01&quot;&gt;おかげで&lt;/a&gt; 、タプル型はアリティを &lt;code&gt;length&lt;/code&gt; プロパティ型にエンコードするようになりました。 これは、数値リテラル型を利用することで実現されます。これにより、タプルを異なるアリティのタプルと区別することができます。</target>
        </trans-unit>
        <trans-unit id="e924e834ba371b237a2fd89703ad1fd92c349cc6" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.1, mapped object types&lt;sup&gt;&lt;a href=&quot;#ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; over tuples and arrays now produce new tuples/arrays, rather than creating a new type where members like &lt;code&gt;push()&lt;/code&gt;, &lt;code&gt;pop()&lt;/code&gt;, and &lt;code&gt;length&lt;/code&gt; are converted. For example:</source>
          <target state="translated">TypeScript 3.1では、タプルと配列にマッピングされたオブジェクトタイプ&lt;sup&gt;&lt;a href=&quot;#ts-3-1-only-homomorphic&quot;&gt;[1]は&lt;/a&gt;&lt;/sup&gt; 、 &lt;code&gt;push()&lt;/code&gt; 、 &lt;code&gt;pop()&lt;/code&gt; 、および &lt;code&gt;length&lt;/code&gt; などのメンバーが変換される新しいタイプを作成する代わりに、新しいタプル/配列を作成します。</target>
        </trans-unit>
        <trans-unit id="39f9c3f02fd56ead96678ac1ba450ac3cd68bf5e" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.2, object literals now allow generic spread expressions which now produce intersection types, similar to the &lt;code&gt;Object.assign&lt;/code&gt; function and JSX literals. For example:</source>
          <target state="translated">TypeScript 3.2では、 &lt;code&gt;Object.assign&lt;/code&gt; 関数とJSXリテラルだけでなく、オブジェクトリテラルの共通部分タイプを生成する一般的なスプレッド式を使用できます。 例えば：</target>
        </trans-unit>
        <trans-unit id="2b164e3a6dff9d3898d7cd8f7babad021ca8339a" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, &lt;code&gt;--build&lt;/code&gt; mode&amp;rsquo;s &lt;code&gt;--watch&lt;/code&gt; flag &lt;em&gt;does&lt;/em&gt; leverage incremental file watching as well. That can mean signficantly faster builds under &lt;code&gt;--build --watch&lt;/code&gt;. In our testing, this functionality has resulted in &lt;strong&gt;a reduction of 50% to 75% in build times&lt;/strong&gt; of the original &lt;code&gt;--build --watch&lt;/code&gt; times. &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29161&quot;&gt;You can read more on the original pull request for the change&lt;/a&gt; to see specific numbers, but we believe most composite project users will see significant wins here.</source>
          <target state="translated">TypeScript 3.3では、-watchモードの--watchフラグも増分ファイル監視を利用します。 これは、 &lt;code&gt;--build --watch&lt;/code&gt; build --watch build --watchの下でビルドが大幅に高速化されることを意味します。 テストでは、この機能&lt;strong&gt;により&lt;/strong&gt; 、元の &lt;code&gt;--build --watch&lt;/code&gt; &lt;strong&gt;時間&lt;/strong&gt; &lt;strong&gt;から&lt;/strong&gt; &lt;strong&gt;ビルド&lt;/strong&gt; &lt;strong&gt;時間&lt;/strong&gt;が&lt;strong&gt;50％から75％に&lt;/strong&gt; &lt;strong&gt;短縮&lt;/strong&gt;されました。 元のプルリクエストの変更の詳細を読んで特定の数値を確認できますが、ほとんどの複合プロジェクトユーザーはここで大きな勝利を期待しています。</target>
        </trans-unit>
        <trans-unit id="0ff72425a74a94e8f866efe98b24a9a23e691d20" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, the parameters of these signatures are &lt;em&gt;intersected&lt;/em&gt; together to create a new signature.</source>
          <target state="translated">TypeScript 3.3では、これらの署名パラメーターは&lt;em&gt;交差&lt;/em&gt;して新しい署名を作成します。</target>
        </trans-unit>
        <trans-unit id="a91f7b680f1b740f03303f6aa85f432e9ad8efa8" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, this is no longer an error.</source>
          <target state="translated">TypeScript 3.3では、これはもはやエラーではありません。</target>
        </trans-unit>
        <trans-unit id="5341077b6a3de5130003da3230dc62974ee76806" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4 and earlier, certain excess properties were allowed in situations where they really shouldn&amp;rsquo;t have been. For instance, TypeScript 3.4 permitted the incorrect &lt;code&gt;name&lt;/code&gt; property in the object literal even though its types don&amp;rsquo;t match between &lt;code&gt;Point&lt;/code&gt; and &lt;code&gt;Label&lt;/code&gt;.</source>
          <target state="translated">TypeScript 3.4より前では、あるべきではない状況で特定の過剰なプロパティが許可されていました。 たとえば、Typeと3.4が &lt;code&gt;Point&lt;/code&gt; と &lt;code&gt;Label&lt;/code&gt; で一致していなくても、TypeScript 3.4はオブジェクトリテラルで不正な &lt;code&gt;name&lt;/code&gt; プロパティを許可していました。</target>
        </trans-unit>
        <trans-unit id="eb163ddc0e2f8f1dc49a15fee6ec555fb1d31fba" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4 and prior, the following example would fail:</source>
          <target state="translated">TypeScript 3.4以前では、次の例は失敗します。</target>
        </trans-unit>
        <trans-unit id="09356337029d3d047ed37351c9cbc0dd0318ec54" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4, the &lt;code&gt;readonly&lt;/code&gt; modifier in a mapped type will automatically convert array-like types to their corresponding &lt;code&gt;readonly&lt;/code&gt; counterparts.</source>
          <target state="translated">TypeScript 3.4では、マップされた型の &lt;code&gt;readonly&lt;/code&gt; 修飾子は、配列などの型を対応する &lt;code&gt;readonly&lt;/code&gt; 対応する型に自動的に変換します 。</target>
        </trans-unit>
        <trans-unit id="e962c6d8bea6e7e5e00083a65a632b1e6809958d" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4, we improved inference for when generic functions that return functions like so:</source>
          <target state="translated">TypeScript 3.4では、次のような関数を返す汎用関数の推論が改善されています。</target>
        </trans-unit>
        <trans-unit id="8398d8557226d4dcf61ef0d2d8e32afa0789a488" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, the type-checker at least verifies that all the provided properties belong to &lt;em&gt;some&lt;/em&gt; union member and have the appropriate type, meaning that the sample above correctly issues an error.</source>
          <target state="translated">TypeScript 3.5では、タイプチェッカーは少なくとも、提供されたすべてのプロパティが&lt;em&gt;何らかの&lt;/em&gt;ユニオンメンバーに属し、適切なタイプであることを検証します。 つまり、上記のサンプルはエラーを正しく発行します。</target>
        </trans-unit>
        <trans-unit id="6bd78304e8ab95ec78b59e840c5e6980b10bd2ff" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, when assigning to types with discriminant properties like in &lt;code&gt;T&lt;/code&gt;, the language actually &lt;em&gt;will&lt;/em&gt; go further and decompose types like &lt;code&gt;S&lt;/code&gt; into a union of every possible inhabitant type. In this case, since &lt;code&gt;boolean&lt;/code&gt; is a union of &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; will be viewed as a union of &lt;code&gt;{ done: false, value: number }&lt;/code&gt; and &lt;code&gt;{ done: true, value: number }&lt;/code&gt;.</source>
          <target state="translated">TypeScript 3.5では、 &lt;code&gt;T&lt;/code&gt; などの判別プロパティを持つ型に割り当てると、言語は実際にさらに進んで、 &lt;code&gt;S&lt;/code&gt; などの型をすべての可能な母型の和集合に分解します。 この場合、 &lt;code&gt;boolean&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; と &lt;code&gt;false&lt;/code&gt; の組み合わせであるため、 &lt;code&gt;S&lt;/code&gt; は &lt;code&gt;{ done: false, value: number }&lt;/code&gt; および &lt;code&gt;{ done: true, value: number }&lt;/code&gt; 組み合わせと見なされます 。</target>
        </trans-unit>
        <trans-unit id="d94a96c27cb9468cb91f9314627e1075ad63df4c" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, you can now reference UMD global declarations like</source>
          <target state="translated">TypeScript 3.5では、次のUMDグローバル宣言を参照できます。</target>
        </trans-unit>
        <trans-unit id="ebce4ccb31849685f27f521710646fdd135799f4" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.6, the checker now knows that the correct type for &lt;code&gt;curr.value&lt;/code&gt; should be &lt;code&gt;string&lt;/code&gt; in our first example, and will correctly error on our call to &lt;code&gt;next()&lt;/code&gt; in our last example. This is thanks to some changes in the &lt;code&gt;Iterator&lt;/code&gt; and &lt;code&gt;IteratorResult&lt;/code&gt; type declarations to include a few new type parameters, and to a new type that TypeScript uses to represent generators called the &lt;code&gt;Generator&lt;/code&gt; type.</source>
          <target state="translated">TypeScript 3.6では、チェッカーは最初の例で &lt;code&gt;curr.value&lt;/code&gt; の正しい型が &lt;code&gt;string&lt;/code&gt; であることを認識し、最後の例では &lt;code&gt;next()&lt;/code&gt; 呼び出しを正しく呼び出します。 これは、 &lt;code&gt;Iterator&lt;/code&gt; および &lt;code&gt;IteratorResult&lt;/code&gt; 型宣言が変更され、いくつかの新しい型パラメーターと、TypeScriptが &lt;code&gt;Generator&lt;/code&gt; 型と呼ばれるジェネレーターを表すために使用する新しい型が含まれるようになったためです 。</target>
        </trans-unit>
        <trans-unit id="0905562c8006d5cf59d0f711433ed32656adf580" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31231&quot;&gt;this is now correctly identified as a duplicate identifier error&lt;/a&gt;. The correct fix depends on the original intent of the author and should be addressed on a case-by-case basis. Usually, the naming conflict is unintentional and the best fix is to rename the imported type. If the intent was to augment the imported type, a proper module augmentation should be written instead.</source>
          <target state="translated">TypeScript 3.7では、 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31231&quot;&gt;これは重複識別子エラーとして正しく識別されるようになりました&lt;/a&gt; 。 正しい修正は作成者の元の意図に依存し、ケースバイケースで対処する必要があります。 通常、名前の競合は意図的ではなく、最善の解決策はインポートされたタイプの名前を変更することです。 インポートされたタイプを拡張することが目標である場合、代わりに適切なモジュール拡張を作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="3d966bc481353f4c45fe41960daf87445589baab" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, the compiler itself will take advantage of this feature so that generated &lt;code&gt;.d.ts&lt;/code&gt; files will also emit &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors.</source>
          <target state="translated">TypeScript 3.7では、コンパイラ自体がこの機能を使用し、生成された &lt;code&gt;.d.ts&lt;/code&gt; ファイルも &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; アクセサーを発行します。</target>
        </trans-unit>
        <trans-unit id="867e1064d30d0ee6d5ae66e30b7de9d7c76047ce" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, the compiler will take advantage of this feature so that &lt;code&gt;.d.ts&lt;/code&gt; files generated from &lt;code&gt;.js&lt;/code&gt; files can appropriately capture both the callability and constructability of a class-like function.</source>
          <target state="translated">TypeScript 3.7では、コンパイラはこの機能を利用して、 &lt;code&gt;.js&lt;/code&gt; ファイルから生成された.jsファイルがクラスのような関数の &lt;code&gt;.d.ts&lt;/code&gt; の両方を適切にキャプチャできるようにします。</target>
        </trans-unit>
        <trans-unit id="12c564a00c60c29478392ba0894da5e9c08182a8" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, this is identified as a likely error:</source>
          <target state="translated">TypeScript 3.7では、これは考えられるエラーとして識別されます。</target>
        </trans-unit>
        <trans-unit id="4164a94a4712ff430d4d9a46e1e26ed5ff082a55" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, when opening a project with dependencies, TypeScript will automatically use the source &lt;code&gt;.ts&lt;/code&gt;/&lt;code&gt;.tsx&lt;/code&gt; files instead. This means projects using project references will now see an improved editing experience where semantic operations are up-to-date and &amp;ldquo;just work&amp;rdquo;. You can disable this behavior with the compiler option &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt; which may be appropriate when working in very large projects where this change may impact editing performance.</source>
          <target state="translated">TypeScript 3.7では、依存関係を持つプロジェクトを開くと、TypeScriptは自動的にソース &lt;code&gt;.ts&lt;/code&gt; / &lt;code&gt;.tsx&lt;/code&gt; ファイルを代わりに使用します。 これは、プロジェクト参照を使用するプロジェクトは、最新の意味操作を使用して、より最新かつ「実用的な」編集エクスペリエンスを提供することを意味します。 この動作を無効にするには、コンパイラオプション &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt; を使用します。 このオプションは、この変更が編集パフォーマンスに影響を与える可能性がある非常に大きなプロジェクトで作業するのに適しています。</target>
        </trans-unit>
        <trans-unit id="38698da453e7ee13579d517a8684b98de7bc1513" translate="yes" xml:space="preserve">
          <source>In TypeScript or ES6, the &lt;code&gt;import&lt;/code&gt; keyword serves the same purpose:</source>
          <target state="translated">TypeScriptまたはES6では、 &lt;code&gt;import&lt;/code&gt; キーワードは同じ目的を果たします。</target>
        </trans-unit>
        <trans-unit id="82d214ccb1ea5cf33bc755b464edc62ce95d4e1d" translate="yes" xml:space="preserve">
          <source>In TypeScript, a declaration creates entities in at least one of three groups: namespace, type, or value. Namespace-creating declarations create a namespace, which contains names that are accessed using a dotted notation. Type-creating declarations do just that: they create a type that is visible with the declared shape and bound to the given name. Lastly, value-creating declarations create values that are visible in the output JavaScript.</source>
          <target state="translated">TypeScriptでは、宣言により、名前空間、タイプ、または値の3つのグループの少なくとも1つにエンティティが作成されます。 名前空間作成宣言は、ドット表記を使用してアクセスされる名前を含む名前空間を作成します。 型作成宣言はまさにそれを行います。 宣言された形状に表示され、指定された名前にバインドされるタイプを作成します。 最後に、値作成宣言により、出力JavaScriptに表示される値が作成されます。</target>
        </trans-unit>
        <trans-unit id="f59c1f1ad017a0e2538bcd6ec781579714841dc0" translate="yes" xml:space="preserve">
          <source>In TypeScript, both &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; actually have their own types named &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; respectively. Much like &lt;code&gt;void&lt;/code&gt;, they&amp;rsquo;re not extremely useful on their own:</source>
          <target state="translated">TypeScriptでは、 &lt;code&gt;undefined&lt;/code&gt; と &lt;code&gt;null&lt;/code&gt; の両方に、実際にはそれぞれ &lt;code&gt;undefined&lt;/code&gt; と &lt;code&gt;null&lt;/code&gt; という名前の独自の型があります 。 &lt;code&gt;void&lt;/code&gt; 、単独ではあまり有用ではありません。</target>
        </trans-unit>
        <trans-unit id="a1389ac175cd87f93511a411a3c43d05c85ede09" translate="yes" xml:space="preserve">
          <source>In TypeScript, every parameter is assumed to be required by the function. This doesn&amp;rsquo;t mean that it can&amp;rsquo;t be given &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, but rather, when the function is called, the compiler will check that the user has provided a value for each parameter. The compiler also assumes that these parameters are the only parameters that will be passed to the function. In short, the number of arguments given to a function has to match the number of parameters the function expects.</source>
          <target state="translated">TypeScriptは、関数にすべてのパラメーターが必要であると想定しています。 これは、 &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; を指定できないという意味ではありません。 代わりに、関数が呼び出されると、コンパイラはユーザーが各パラメーターの値を指定したことを確認します。 また、コンパイラーは、これらのパラメーターが関数に渡される唯一のパラメーターであると想定します。 要するに、関数に与えられる引数の数は、関数が期待するパラメーターの数と一致しなければなりません。</target>
        </trans-unit>
        <trans-unit id="a24475a2eada62cf03ff9dfea85139d779f1476f" translate="yes" xml:space="preserve">
          <source>In TypeScript, just as in ECMAScript 2015, any file containing a top-level &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; is considered a module. Conversely, a file without any top-level &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).</source>
          <target state="translated">TypeScriptでは、ECMAScript 2015と同様に、最上位の &lt;code&gt;import&lt;/code&gt; または &lt;code&gt;export&lt;/code&gt; を含むファイルはモジュールと見なされます。 逆に、最上位の &lt;code&gt;import&lt;/code&gt; または &lt;code&gt;export&lt;/code&gt; 宣言のないファイルは、その内容がグローバルスコープで（したがってモジュールでも）利用可能なスクリプトとして扱われます。</target>
        </trans-unit>
        <trans-unit id="1ed5374d91892c7ddbb0f4d810f43603226252a7" translate="yes" xml:space="preserve">
          <source>In TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation. For example, in this code</source>
          <target state="translated">TypeScriptには、明示的な型注釈がない場合に型情報を提供するために型推論が使用される場所がいくつかあります。 たとえば、このコードでは</target>
        </trans-unit>
        <trans-unit id="ee7d94eb215257ba5c8ab795047cbaba376a919d" translate="yes" xml:space="preserve">
          <source>In TypeScript, we can also set a value that a parameter will be assigned if the user does not provide one, or if the user passes &lt;code&gt;undefined&lt;/code&gt; in its place. These are called default-initialized parameters. Let&amp;rsquo;s take the previous example and default the last name to &lt;code&gt;&quot;Smith&quot;&lt;/code&gt;.</source>
          <target state="translated">TypeScriptでは、ユーザーがパラメーターを指定しない場合、またはユーザーが &lt;code&gt;undefined&lt;/code&gt; を渡す場合、パラメーターが割り当てられる値を設定することもできます。 これらは、デフォルトで初期化されるパラメーターと呼ばれます。 前の例を使用して、姓をデフォルトで &lt;code&gt;&quot;Smith&quot;&lt;/code&gt; にしましょう。</target>
        </trans-unit>
        <trans-unit id="9b2996a620036d35453f4c7abf1fb3f20ef36789" translate="yes" xml:space="preserve">
          <source>In TypeScript, we can use common object-oriented patterns. One of the most fundamental patterns in class-based programming is being able to extend existing classes to create new ones using inheritance.</source>
          <target state="translated">TypeScriptを使用すると、一般的なオブジェクト指向パターンを使用できます。 クラスベースのプログラミングの最も基本的なパターンの1つは、既存のクラスを拡張し、継承を使用して新しいクラスを作成する機能です。</target>
        </trans-unit>
        <trans-unit id="f733ba5e652ea7387ab081ac7b355a5f8b8f5005" translate="yes" xml:space="preserve">
          <source>In TypeScript, you can gather these arguments together into a variable:</source>
          <target state="translated">TypeScriptでは、これらの引数を変数にグループ化できます。</target>
        </trans-unit>
        <trans-unit id="55204c277d20a924ef143d3605b8feaf73f1f390" translate="yes" xml:space="preserve">
          <source>In TypeScript, you can model this with the &lt;code&gt;export =&lt;/code&gt; construct.</source>
          <target state="translated">TypeScriptでは、 &lt;code&gt;export =&lt;/code&gt; 構文を使用してこれをモデル化できます。</target>
        </trans-unit>
        <trans-unit id="82c14892013104e9e43fd9bdca12513d567a243f" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, Typescript understands the CommonJS module format. Assignments to &lt;code&gt;exports&lt;/code&gt; and &lt;code&gt;module.exports&lt;/code&gt; are recognized as export declarations. Similarly, &lt;code&gt;require&lt;/code&gt; function calls are recognized as module imports. For example:</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; ファイル、TypescriptはCommonJSモジュール形式を理解します。 &lt;code&gt;module.exports&lt;/code&gt; to &lt;code&gt;exports&lt;/code&gt; およびmodule.exportsは、輸出申告として認識されます。 同様に、 &lt;code&gt;require&lt;/code&gt; 関数呼び出しはモジュールのインポートとして認識されます。 例えば：</target>
        </trans-unit>
        <trans-unit id="b54a4161a63a1b96ee32a30fced932fa18ccb0eb" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, the compiler infers properties from property assignments inside the class body. The type of a property is the type given in the constructor, unless it&amp;rsquo;s not defined there, or the type in the constructor is undefined or null. In that case, the type is the union of the types of all the right-hand values in these assignments. Properties defined in the constructor are always assumed to exist, whereas ones defined just in methods, getters, or setters are considered optional.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; ファイルの場合、コンパイラはクラス本体のプロパティの割り当てからプロパティを推測します。 プロパティーのタイプは、そこで定義されているか、コンストラクターのタイプが未定義またはヌルでない限り、コンストラクターで指定されたタイプです。 その場合、型はこれらの割り当てのすべての右辺値の型の結合です。 コンストラクタで定義されたプロパティは常に存在すると想定されますが、メソッド、ゲッター、またはセッターでのみ定義されたプロパティはオプションと見なされます。</target>
        </trans-unit>
        <trans-unit id="b1aec57e38f0bba34cdcf5755b6607c4fa3eaad1" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, types can often be inferred just like in &lt;code&gt;.ts&lt;/code&gt; files. Likewise, when types can&amp;rsquo;t be inferred, they can be specified using JSDoc the same way that type annotations are used in a &lt;code&gt;.ts&lt;/code&gt; file. Just like Typescript, &lt;code&gt;--noImplicitAny&lt;/code&gt; will give you errors on the places that the compiler could not infer a type. (With the exception of open-ended object literals; see below for details.)</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; ファイルでは、多くの場合、 &lt;code&gt;.ts&lt;/code&gt; ファイルと同じように型を推測できます。 同様に、型を推測できない場合、JSDocを使用して、 &lt;code&gt;.ts&lt;/code&gt; ファイルで型注釈が使用されるのと同じ方法で型を指定できます。 &lt;code&gt;--noImplicitAny&lt;/code&gt; のように 、-noImplicitAnyは、コンパイラーが型を推測できなかったエラーを報告します。 （無制限のオブジェクトリテラルを除く。詳細は以下を参照してください。）</target>
        </trans-unit>
        <trans-unit id="499d42e07e1a5b7dd4bdd55bbff5c492132e6ecc" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.ts&lt;/code&gt; file, an object literal that initializes a variable declaration gives its type to the declaration. No new members can be added that were not specified in the original literal. This rule is relaxed in a &lt;code&gt;.js&lt;/code&gt; file; object literals have an open-ended type (an index signature) that allows adding and looking up properties that were not defined originally. For instance:</source>
          <target state="translated">&lt;code&gt;.ts&lt;/code&gt; ファイル。変数宣言を初期化するオブジェクトリテラルは、その型を宣言に渡します。 元のリテラルで指定されていない新しいメンバーを追加することはできません。 この規則は &lt;code&gt;.js&lt;/code&gt; ファイルで緩和されています。 オブジェクトリテラルには、最初に定義されていなかったプロパティを追加および取得できるオープンエンドタイプ（インデックス署名）があります。 例えば：</target>
        </trans-unit>
        <trans-unit id="faa28e2f1cd18a9e6940ea8f152a75b8bef80372" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;for...in&lt;/code&gt; statement for an object of a generic type &lt;code&gt;T&lt;/code&gt;, the inferred type of the iteration variable was previously &lt;code&gt;keyof T&lt;/code&gt; but is now &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt;. (In other words, the subset of &lt;code&gt;keyof T&lt;/code&gt; that includes only string-like values.)</source>
          <target state="translated">ジェネリック型 &lt;code&gt;T&lt;/code&gt; のオブジェクトの &lt;code&gt;for...in&lt;/code&gt; ステートメントでは、推論された反復変数の型は以前は &lt;code&gt;keyof T&lt;/code&gt; でしたが、現在は &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; です。 （つまり、文字列のような値のみを含む &lt;code&gt;keyof T&lt;/code&gt; のサブセットです。）</target>
        </trans-unit>
        <trans-unit id="94a6c7abfee16098b91b6afd7d77f2cffbbb0188" translate="yes" xml:space="preserve">
          <source>In a function expression or arrow function with no return type annotation, if the function has no &lt;code&gt;return&lt;/code&gt; statements, or only &lt;code&gt;return&lt;/code&gt; statements with expressions of type &lt;code&gt;never&lt;/code&gt;, and if the end point of the function is not reachable (as determined by control flow analysis), the inferred return type for the function is &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">関数が関数式または戻り値の注釈を持たない矢印関数であり、関数に &lt;code&gt;return&lt;/code&gt; ステートメントがない場合、または &lt;code&gt;never&lt;/code&gt; 型の式を持つ &lt;code&gt;return&lt;/code&gt; ステートメントのみがあり、関数の終点に到達できない場合（によって決定される制御フロー分析）。 ）、関数の推定戻り型は &lt;code&gt;never&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a98314a0bada662b45a18394f388ee15a3db9842" translate="yes" xml:space="preserve">
          <source>In a function with an explicit &lt;code&gt;never&lt;/code&gt; return type annotation, all &lt;code&gt;return&lt;/code&gt; statements (if any) must have expressions of type &lt;code&gt;never&lt;/code&gt; and the end point of the function must not be reachable.</source>
          <target state="translated">明示的なreturn &lt;code&gt;never&lt;/code&gt; 注釈を持つ関数の場合、すべての &lt;code&gt;return&lt;/code&gt; ステートメント（存在する場合）には値のない式が必要であり、関数の最後には到達できません。</target>
        </trans-unit>
        <trans-unit id="f21005b5571e17a92c2f4c810bdd49f11c28d379" translate="yes" xml:space="preserve">
          <source>In a mapped type &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt;, each string literal type in &lt;code&gt;K&lt;/code&gt; introduces a property with a string name, each numeric literal type in &lt;code&gt;K&lt;/code&gt; introduces a property with a numeric name, and each unique symbol type in &lt;code&gt;K&lt;/code&gt; introduces a property with a unique symbol name. Furthermore, if &lt;code&gt;K&lt;/code&gt; includes type &lt;code&gt;string&lt;/code&gt;, a string index signature is introduced, and if &lt;code&gt;K&lt;/code&gt; includes type &lt;code&gt;number&lt;/code&gt;, a numeric index signature is introduced.</source>
          <target state="translated">マップされたタイプ &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; では、Kの各文字列リテラルタイプは文字列名のプロパティを導入し、Kの各数値リテラルタイプは数値名のプロパティを導入し、KAの一意のシンボルタイプのそれぞれはプロパティを導入します一意のシンボル名。 さらに、 &lt;code&gt;K&lt;/code&gt; に型 &lt;code&gt;string&lt;/code&gt; が含まれる場合、文字列インデックス署名が導入され、 &lt;code&gt;K&lt;/code&gt; に型 &lt;code&gt;number&lt;/code&gt; が含まれる場合、数値インデックス署名が導入されます。</target>
        </trans-unit>
        <trans-unit id="c902ce3f09f34d229a3e2897a358abb3f93aff0a" translate="yes" xml:space="preserve">
          <source>In a sense, the definite assignment assertion operator is the dual of the non-null assertion operator (in which &lt;em&gt;expressions&lt;/em&gt; are post-fixed with a &lt;code&gt;!&lt;/code&gt;), which we could also have used in the example.</source>
          <target state="translated">ある意味では、明示的な割り当てアサーション演算子は、非nullアサーション演算子の二重であり（ &lt;em&gt;式&lt;/em&gt;は後置され &lt;code&gt;!&lt;/code&gt; ）、この例で使用できます。</target>
        </trans-unit>
        <trans-unit id="51dd880d34f252e0aeb77f1d88f4eba9a15ee3cc" translate="yes" xml:space="preserve">
          <source>In a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) we&amp;rsquo;re generic over (e.g. &lt;code&gt;Dictionary&amp;lt;string&amp;gt;&lt;/code&gt; rather than just &lt;code&gt;Dictionary&lt;/code&gt;). This makes the type parameter visible to all the other members of the interface.</source>
          <target state="translated">同様の例では、汎用パラメーターをインターフェイス全体のパラメーターに移動できます。 これにより、ジェネリック型（たとえば、 &lt;code&gt;Dictionary&amp;lt;string&amp;gt;&lt;/code&gt; ではなくDictionary &amp;lt;string&amp;gt;）を表示できます。 これにより、インターフェイスの他のすべてのメンバーにtypeパラメーターが表示されます。</target>
        </trans-unit>
        <trans-unit id="7aae1c23f28d25359f684353160aa338cdad63b7" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;AMD&lt;/code&gt; and &lt;code&gt;CommonJS&lt;/code&gt; module loaders, TypeScript now supports emitting modules &lt;code&gt;UMD&lt;/code&gt; (&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;Universal Module Definition&lt;/a&gt;) and &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;&lt;code&gt;System&lt;/code&gt;&lt;/a&gt; module formats.</source>
          <target state="translated">&lt;code&gt;AMD&lt;/code&gt; および &lt;code&gt;CommonJS&lt;/code&gt; モジュールローダーに加えて、TypeScriptはモジュール &lt;code&gt;UMD&lt;/code&gt; （ &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;ユニバーサルモジュール定義&lt;/a&gt; ）および&lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt; &lt;code&gt;System&lt;/code&gt; &lt;/a&gt;モジュールフォーマットの公開をサポートするようになりました。</target>
        </trans-unit>
        <trans-unit id="5006f44bee52625a6ab0a4a313b0d7e2fc88612c" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;Partial&lt;/code&gt;, Mapped Types can express many useful transformations on types:</source>
          <target state="translated">&lt;code&gt;Partial&lt;/code&gt; への部分的な追加、マップされたタイプは、タイプの多くの便利な変換を表すことができます。</target>
        </trans-unit>
        <trans-unit id="191adf935ed2ac18958fb4641280ef26e69e454d" translate="yes" xml:space="preserve">
          <source>In addition to compositional patterns like the above, this new inference on generic constructors means that functions that operate on class components in certain UI libraries like React can more correctly operate on generic class components.</source>
          <target state="translated">上記の構成パターンに加えて、ジェネリックコンストラクターに関するこの新しい推論は、Reactなど、特定のUIライブラリのクラスコンポーネントで動作する関数が、ジェネリッククラスコンポーネントでより正確に動作できることを意味します。</target>
        </trans-unit>
        <trans-unit id="1a90a08e2836eebeca011762ffd80aadcf5c05eb" translate="yes" xml:space="preserve">
          <source>In addition to creating an object with property names for members, numeric enums members also get a &lt;em&gt;reverse mapping&lt;/em&gt; from enum values to enum names. For example, in this example:</source>
          <target state="translated">メンバープロパティ名を使用してオブジェクトを作成することに加えて、数値列挙メンバー&lt;em&gt;は、&lt;/em&gt;列挙値から列挙名への&lt;em&gt;逆マッピング&lt;/em&gt;も取得します。 たとえば、この例では：</target>
        </trans-unit>
        <trans-unit id="9ed91b41f41b6bffe64ebf951bfee935b8c06725" translate="yes" xml:space="preserve">
          <source>In addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and namespaces.</source>
          <target state="translated">ジェネリックインターフェイスに加えて、ジェネリッククラスを作成することもできます。 汎用の列挙型と名前空間を作成できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d1e90cce3e41b4e86a90a13f73336c6deb38037e" translate="yes" xml:space="preserve">
          <source>In addition to the existing TypeScript support for decorating declarations with &lt;code&gt;export&lt;/code&gt;, module members can also be exported using separate export declarations, optionally specifying different names for exports using &lt;code&gt;as&lt;/code&gt; clauses.</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; での修飾宣言に対する既存のTypeScriptサポートへのエクスポートの追加、異なるエクスポート宣言を使用してモジュールメンバーをエクスポートすることもできます。オプションで &lt;code&gt;as&lt;/code&gt; 句を使用してエクスポートの異なる名前を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="5fc2368a23b5c630c12625ea45cc7ece18d41984" translate="yes" xml:space="preserve">
          <source>In addition to the pattern of inner classes, you may also be familiar with the JavaScript practice of creating a function and then extending the function further by adding properties onto the function. TypeScript uses declaration merging to build up definitions like this in a type-safe way.</source>
          <target state="translated">内部クラスパターンに加えて、関数を作成したり、関数にプロパティを追加して関数を拡張したりするJavaScriptの慣習に精通しているかもしれません。 TypeScriptは、宣言的マージを使用して、そのような定義をタイプセーフな方法で構築します。</target>
        </trans-unit>
        <trans-unit id="64dd39fbc1176fa7cb78d499e27b42f425e4f288" translate="yes" xml:space="preserve">
          <source>In addition to user-defined symbols, there are well-known built-in symbols. Built-in symbols are used to represent internal language behaviors.</source>
          <target state="translated">ユーザー定義のシンボルに加えて、よく知られた組み込みシンボルがあります。 組み込みシンボルは、内部言語の動作を表すために使用されます。</target>
        </trans-unit>
        <trans-unit id="af6dc8ce595252f91c362798795d00c0d72386ed" translate="yes" xml:space="preserve">
          <source>In addition, entities are &lt;em&gt;implicitly&lt;/em&gt; read-only in several situations:</source>
          <target state="translated">さらに、エンティティは状況によっては&lt;em&gt;暗黙的に&lt;/em&gt;読み取り専用になります。</target>
        </trans-unit>
        <trans-unit id="f13cadd149f177816bfcd1f47e7199c8a2dd824c" translate="yes" xml:space="preserve">
          <source>In all other cases enum member is considered computed.</source>
          <target state="translated">他のすべての場合、enumメンバーは計算済みと見なされます。</target>
        </trans-unit>
        <trans-unit id="afe27faa913e56241e9fef79caeefb4719b9d97b" translate="yes" xml:space="preserve">
          <source>In cases where the compiler can&amp;rsquo;t eliminate &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the type assertion operator to manually remove them. The syntax is postfix &lt;code&gt;!&lt;/code&gt;: &lt;code&gt;identifier!&lt;/code&gt; removes &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from the type of &lt;code&gt;identifier&lt;/code&gt;:</source>
          <target state="translated">コンパイラーが &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; を削除できない場合、型アサーション演算子を使用して手動で削除できます。 構文は後置 &lt;code&gt;!&lt;/code&gt; ： &lt;code&gt;identifier!&lt;/code&gt; 型 &lt;code&gt;identifier&lt;/code&gt; から &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; を削除します ：</target>
        </trans-unit>
        <trans-unit id="46e7cfaa389b12ae897eb1224615c0bd3a3a74e0" translate="yes" xml:space="preserve">
          <source>In earlier versions of TypeScript, we generalized mapped types to operate differently on array-like types. This meant that a mapped type like &lt;code&gt;Boxify&lt;/code&gt; could work on arrays and tuples alike.</source>
          <target state="translated">TypeScriptの以前のバージョンは、マップされた型を一般化し、配列などの型とは異なる動作をしました。 つまり、 &lt;code&gt;Boxify&lt;/code&gt; のようなBoxifyは、配列とタプルに対して同様に機能します。</target>
        </trans-unit>
        <trans-unit id="d3125ad49c86be35f677e4c8afe1f401c2f39f09" translate="yes" xml:space="preserve">
          <source>In exact terms, the &lt;code&gt;--strict&lt;/code&gt; option sets the &lt;em&gt;default&lt;/em&gt; value for the compiler options listed above. This means it is still possible to individually control the options. For example,</source>
          <target state="translated">厳密に言えば、--strict strictオプションは、上記のコンパイラオプションの&lt;em&gt;デフォルト&lt;/em&gt;値を設定します。 これは、オプションを個別に制御することが依然として可能であることを意味します。 例えば、</target>
        </trans-unit>
        <trans-unit id="f8bbd9b4c8e18d955c59e1b9bb4bd269b6054dc3" translate="yes" xml:space="preserve">
          <source>In extends clause</source>
          <target state="translated">extends節で</target>
        </trans-unit>
        <trans-unit id="317805e6e63ca60bc3ca9fd2d268f7e654b8cbb1" translate="yes" xml:space="preserve">
          <source>In function calls</source>
          <target state="translated">関数呼び出しで</target>
        </trans-unit>
        <trans-unit id="c33d3561ce65af4351cdeaf45173b07c0b043d0d" translate="yes" xml:space="preserve">
          <source>In general, not much is needed to transition a repo using relative modules. Simply place a &lt;code&gt;tsconfig.json&lt;/code&gt; file in each subdirectory of a given parent folder, and add &lt;code&gt;reference&lt;/code&gt;s to these config files to match the intended layering of the program. You will need to either set the &lt;code&gt;outDir&lt;/code&gt; to an explicit subfolder of the output folder, or set the &lt;code&gt;rootDir&lt;/code&gt; to the common root of all project folders.</source>
          <target state="translated">一般に、相対モジュールを使用してリポジトリを移行するために必要なことはあまりありません。 特定の親フォルダーの各サブディレクトリに &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを配置し、これらの構成ファイルに &lt;code&gt;reference&lt;/code&gt; を追加して、プログラムの目的の階層に一致させます。 &lt;code&gt;outDir&lt;/code&gt; を使用してoutDirを出力フォルダーの明示的なサブフォルダーに設定するか、 &lt;code&gt;rootDir&lt;/code&gt; をすべてのプロジェクトフォルダーの共通ルートに設定します。</target>
        </trans-unit>
        <trans-unit id="b1625c54a8a7392317454ab8180d6577f1b9ae1b" translate="yes" xml:space="preserve">
          <source>In instantiations of a distributive conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt;, references to &lt;code&gt;T&lt;/code&gt; within the conditional type are resolved to individual constituents of the union type (i.e. &lt;code&gt;T&lt;/code&gt; refers to the individual constituents &lt;em&gt;after&lt;/em&gt; the conditional type is distributed over the union type). Furthermore, references to &lt;code&gt;T&lt;/code&gt; within &lt;code&gt;X&lt;/code&gt; have an additional type parameter constraint &lt;code&gt;U&lt;/code&gt; (i.e. &lt;code&gt;T&lt;/code&gt; is considered assignable to &lt;code&gt;U&lt;/code&gt; within &lt;code&gt;X&lt;/code&gt;).</source>
          <target state="translated">分布条件タイプのインスタンス化では、 &lt;code&gt;T extends U ? X : Y&lt;/code&gt; X：Y X：Y、条件タイプの &lt;code&gt;T&lt;/code&gt; への参照は、ユニオンタイプの個々のコンポーネントに解決されます（つまり、 &lt;code&gt;T&lt;/code&gt; は、条件タイプがタイプに分配された&lt;em&gt;後の&lt;/em&gt;ユニオン個々のコンポーネント&lt;em&gt;である&lt;/em&gt;ことを意味します）。 さらに、 &lt;code&gt;X&lt;/code&gt; の &lt;code&gt;T&lt;/code&gt; への参照には、追加の型パラメーター制約 &lt;code&gt;U&lt;/code&gt; があります （つまり、 &lt;code&gt;T&lt;/code&gt; は &lt;code&gt;X&lt;/code&gt; の &lt;code&gt;U&lt;/code&gt; に割り当て可能であると見なされます）。</target>
        </trans-unit>
        <trans-unit id="ade42fc57c0936ec5b4a222b5c45022a1c4760c5" translate="yes" xml:space="preserve">
          <source>In languages like C# and Java, one of the main tools in the toolbox for creating reusable components is &lt;em&gt;generics&lt;/em&gt;, that is, being able to create a component that can work over a variety of types rather than a single one. This allows users to consume these components and use their own types.</source>
          <target state="translated">C＃やJavaなどの言語では、再利用可能なコンポーネントを作成するためのツールボックスの主要なツールの1つは&lt;em&gt;generics&lt;/em&gt;です。 これは、単一のコンポーネントではなく、さまざまなタイプで機能するコンポーネントを作成できることを意味します。 これにより、ユーザーはこれらのコンポーネントで独自のタイプを使用できます。</target>
        </trans-unit>
        <trans-unit id="5c5505a3474915f4cc4c566956af416ee322aa67" translate="yes" xml:space="preserve">
          <source>In most cases, enums are a perfectly valid solution. However sometimes requirements are tighter. To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it&amp;rsquo;s possible to use &lt;code&gt;const&lt;/code&gt; enums. Const enums are defined using the &lt;code&gt;const&lt;/code&gt; modifier on our enums:</source>
          <target state="translated">ほとんどの場合、列挙型は完全に有効なソリューションです。 ただし、要件が厳しい場合があります。 列挙値にアクセスする際に、余分な生成コードと追加の間接コストを支払うことを避けるために、 &lt;code&gt;const&lt;/code&gt; 列挙を使用できます。 &lt;code&gt;const&lt;/code&gt; enumは、enum const修飾子を使用して定義されます。</target>
        </trans-unit>
        <trans-unit id="9977fd8d646f7ee47ce74c49df2a1398accb087c" translate="yes" xml:space="preserve">
          <source>In most cases, type inference is straightforward. In the following sections, we&amp;rsquo;ll explore some of the nuances in how types are inferred.</source>
          <target state="translated">ほとんどの場合、型推論は簡単です。 次のセクションでは、型がどのように推論されるかに関するニュアンスを探ります。</target>
        </trans-unit>
        <trans-unit id="49e5eb0fe073a6b366d084def4b417b2dc17ba91" translate="yes" xml:space="preserve">
          <source>In nominally-typed languages like C# or Java, the equivalent code would be an error because the &lt;code&gt;Person&lt;/code&gt; class does not explicitly describe itself as being an implementer of the &lt;code&gt;Named&lt;/code&gt; interface.</source>
          <target state="translated">C＃やJavaなどの &lt;code&gt;Named&lt;/code&gt; 言語では、 &lt;code&gt;Person&lt;/code&gt; クラスはそれ自体を名前付きインターフェイスの実装者として明示的に記述しないため、同等のコードは失敗します。</target>
        </trans-unit>
        <trans-unit id="6cd6a1cda7b4b6dafff0249316846cd737bb057b" translate="yes" xml:space="preserve">
          <source>In older versions of TypeScript, type aliases couldn&amp;rsquo;t be extended or implemented from (nor could they extend/implement other types). As of version 2.7, type aliases can be extended by creating a new intersection type e.g. &lt;code&gt;type Cat = Animal &amp;amp; { purrs: true }&lt;/code&gt;.</source>
          <target state="translated">TypeScriptの古いバージョンでは、タイプエイリアスを拡張または実装できませんでした（他のタイプは拡張/実装できませんでした）。 バージョン2.7では、新しい交差タイプを作成することでタイプエイリアスを拡張できます（たとえば、 &lt;code&gt;type Cat = Animal &amp;amp; { purrs: true }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4485cefc41070d0508c8ae3601f889e0c3ca550d" translate="yes" xml:space="preserve">
          <source>In older versions, TypeScript would infer the empty object type (&lt;code&gt;{}&lt;/code&gt;) when inferring from other type variables like &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">古いバージョンでは、TypeScriptは &lt;code&gt;T&lt;/code&gt; や &lt;code&gt;U&lt;/code&gt; などの他の型変数から推測するときに空のオブジェクト型（ &lt;code&gt;{}&lt;/code&gt; ）を推測していました。</target>
        </trans-unit>
        <trans-unit id="3becc57b3af3b6f00aff1c308abe30fb09b363bc" translate="yes" xml:space="preserve">
          <source>In order for the compiler to pick the correct type check, it follows a similar process to the underlying JavaScript. It looks at the overload list and, proceeding with the first overload, attempts to call the function with the provided parameters. If it finds a match, it picks this overload as the correct overload. For this reason, it&amp;rsquo;s customary to order overloads from most specific to least specific.</source>
          <target state="translated">コンパイラは、基礎となるJavaScriptと同様のプロセスに従って、正しい型チェックを選択します。 オーバーロードリストを見て、最初のオーバーロードに進み、指定されたパラメーターを使用して関数を呼び出します。 一致が見つかった場合、このオーバーロードを正しいオーバーロードとして選択します。 このため、オーバーロードを最も具体的なものから最も具体的なものへと注文するのが慣例です。</target>
        </trans-unit>
        <trans-unit id="ec884edde65bedd374e2043ee3584a67f5dd3d21" translate="yes" xml:space="preserve">
          <source>In order to ensure that a function never potentially returned &lt;code&gt;undefined&lt;/code&gt; or effectively returned from all code paths, TypeScript needed some syntactic signal - either a &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;throw&lt;/code&gt; at the end of a function. So users found themselves &lt;code&gt;return&lt;/code&gt;-ing their failure functions.</source>
          <target state="translated">関数を &lt;code&gt;undefined&lt;/code&gt; たり、すべてのコードパスから効果的に返さないようにするには、TypeScriptに構文信号（関数の最後で &lt;code&gt;return&lt;/code&gt; または &lt;code&gt;throw&lt;/code&gt; が必要です。関数に戻ります。</target>
        </trans-unit>
        <trans-unit id="7a30e2c325b4e7b632ea33292d372bb91480fbed" translate="yes" xml:space="preserve">
          <source>In order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements. Given a JSX expression &lt;code&gt;&amp;lt;expr /&amp;gt;&lt;/code&gt;, &lt;code&gt;expr&lt;/code&gt; may either refer to something intrinsic to the environment (e.g. a &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;span&lt;/code&gt; in a DOM environment) or to a custom component that you&amp;rsquo;ve created. This is important for two reasons:</source>
          <target state="translated">JSXの型チェックを理解するには、最初に組み込み要素と値ベースの要素の違いを理解する必要があります。 JSX式 &lt;code&gt;&amp;lt;expr /&amp;gt;&lt;/code&gt; を指定すると 、 &lt;code&gt;expr&lt;/code&gt; は環境に固有の何か（DOM環境の &lt;code&gt;div&lt;/code&gt; や &lt;code&gt;span&lt;/code&gt; など）または作成するカスタムコンポーネントを参照する場合があります。 これは2つの理由で重要です。</target>
        </trans-unit>
        <trans-unit id="2c6b1f2bc59ac8b4cd64d29de8b2d3e100cb6d4f" translate="yes" xml:space="preserve">
          <source>In order to use JSX you must do two things.</source>
          <target state="translated">JSXを使用するには、2つのことを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="2425b2f241ed01dc603f0c439b76c219ccaf89d0" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;x&lt;/code&gt; must be &lt;code&gt;1&lt;/code&gt; when it gets compared to &lt;code&gt;2&lt;/code&gt;, meaning that the above check is making an invalid comparison.</source>
          <target state="translated">つまり、 &lt;code&gt;x&lt;/code&gt; を &lt;code&gt;2&lt;/code&gt; と比較する場合、 xは &lt;code&gt;1&lt;/code&gt; でなければなりません。 これは、上記のチェックが無効な比較を行っていることを意味します。</target>
        </trans-unit>
        <trans-unit id="7e1538e5dd442871789cc5ecc7783750fa78d9ea" translate="yes" xml:space="preserve">
          <source>In other words, TypeScript now catches the above bug, which may be a breaking change for some users, but will largely be helpful.</source>
          <target state="translated">つまり、TypeScriptは上記のバグをキャッチします。 これは一部のユーザーにとっては大きな変更になる可能性がありますが、非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="93e13237760bfc497efa3e019beaf296fba0f599" translate="yes" xml:space="preserve">
          <source>In other words, hitting go-to-definition on a declaration from a &lt;code&gt;.d.ts&lt;/code&gt; file generated with &lt;code&gt;--declarationMap&lt;/code&gt; will take you to the source file (&lt;code&gt;.ts&lt;/code&gt;) location where that declaration was defined, and not to the &lt;code&gt;.d.ts&lt;/code&gt;.</source>
          <target state="translated">つまり、 &lt;code&gt;--declarationMap&lt;/code&gt; によって生成された--declarationMapファイルからの宣言のgo-to-definitionと宣言は、 -declarationMapの代わりにソースファイル（ &lt;code&gt;.ts&lt;/code&gt; ）の場所に移動されます。 ts</target>
        </trans-unit>
        <trans-unit id="4c2ced57a304d01037d71bbb4f8dbc6d272f4c53" translate="yes" xml:space="preserve">
          <source>In other words, instead of producing the type</source>
          <target state="translated">つまり、タイプを作成する代わりに</target>
        </trans-unit>
        <trans-unit id="13c9723a82ddbb23b59c0ac5eb80038fe61fb8ae" translate="yes" xml:space="preserve">
          <source>In our example, we knew that all uses of &lt;code&gt;x&lt;/code&gt; would be initialized so it makes more sense to use definite assignment assertions than non-null assertions.</source>
          <target state="translated">この例では、 &lt;code&gt;x&lt;/code&gt; のすべての使用が初期化されるため、null以外のアサーションよりも明示的な割り当てアサーションを使用する方が理にかなっています。</target>
        </trans-unit>
        <trans-unit id="e09a40d13c5b9150cdb7cb04b404685efc24c2e1" translate="yes" xml:space="preserve">
          <source>In our examples, we&amp;rsquo;ve been able to freely access the members that we declared throughout our programs. If you&amp;rsquo;re familiar with classes in other languages, you may have noticed in the above examples we haven&amp;rsquo;t had to use the word &lt;code&gt;public&lt;/code&gt; to accomplish this; for instance, C# requires that each member be explicitly labeled &lt;code&gt;public&lt;/code&gt; to be visible. In TypeScript, each member is &lt;code&gt;public&lt;/code&gt; by default.</source>
          <target state="translated">この例では、プログラム全体で宣言されたメンバーに自由にアクセスできました。 他の言語のクラスに精通している場合、上記の例では、これを実現するために &lt;code&gt;public&lt;/code&gt; という単語を使用する必要がないことに気づいたかもしれません。 たとえば、C＃では、各メンバーを表示するには、明示的に &lt;code&gt;public&lt;/code&gt; というラベルを付ける必要があります。 TypeScriptでは、各メンバーはデフォルトで &lt;code&gt;public&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="077f32db3171bafea36c02345fca8439c23de1f0" translate="yes" xml:space="preserve">
          <source>In our first example using interfaces, TypeScript lets us pass &lt;code&gt;{ size: number; label: string; }&lt;/code&gt; to something that only expected a &lt;code&gt;{ label: string; }&lt;/code&gt;. We also just learned about optional properties, and how they&amp;rsquo;re useful when describing so-called &amp;ldquo;option bags&amp;rdquo;.</source>
          <target state="translated">インターフェイスを使用する最初の例では、TypeScript &lt;code&gt;{ size: number; label: string; }&lt;/code&gt; ラベル：文字列; } label：string;} &lt;code&gt;{ label: string; }&lt;/code&gt; } }また、オプションのプロパティといわゆる「オプションバッグ」を説明するときに、それらがどのように役立つかを学びました。</target>
        </trans-unit>
        <trans-unit id="b5509d814ae50a61b30f1663160809aaacc3c863" translate="yes" xml:space="preserve">
          <source>In our last example, we had to declare a readonly member &lt;code&gt;name&lt;/code&gt; and a constructor parameter &lt;code&gt;theName&lt;/code&gt; in the &lt;code&gt;Octopus&lt;/code&gt; class. This is needed in order to have the value of &lt;code&gt;theName&lt;/code&gt; accessible after the &lt;code&gt;Octopus&lt;/code&gt; constructor is executed. &lt;em&gt;Parameter properties&lt;/em&gt; let you create and initialize a member in one place. Here&amp;rsquo;s a further revision of the previous &lt;code&gt;Octopus&lt;/code&gt; class using a parameter property:</source>
          <target state="translated">最後の例では、 &lt;code&gt;Octopus&lt;/code&gt; クラス &lt;code&gt;theName&lt;/code&gt; が読み取り専用メンバー &lt;code&gt;name&lt;/code&gt; とコンストラクターパラメーターtheNameを宣言しています。 これは、 &lt;code&gt;Octopus&lt;/code&gt; コンストラクターの実行後に &lt;code&gt;theName&lt;/code&gt; の値にアクセスできるようにするために必要です。 &lt;em&gt;パラメータプロパティを&lt;/em&gt;使用すると、メンバーを1か所で作成および初期化できます。 以下は、パラメータープロパティを使用した以前の &lt;code&gt;Octopus&lt;/code&gt; クラスのさらなる改訂版です。</target>
        </trans-unit>
        <trans-unit id="a2a7cf3a706d3a1af3a4cb37abf72ef77d6e4707" translate="yes" xml:space="preserve">
          <source>In playing with the example, you may notice that the TypeScript compiler can figure out the type even if you only have types on one side of the equation:</source>
          <target state="translated">この例を試すと、方程式の片側に1つの型しかない場合でも、TypeScriptコンパイラが型を決定できることに気付くかもしれません。</target>
        </trans-unit>
        <trans-unit id="9c1b4684fb04512e6c7b40289668510482450dd8" translate="yes" xml:space="preserve">
          <source>In practical terms, strict null checking mode requires that all files in a compilation are null- and undefined-aware.</source>
          <target state="translated">実際、厳密なnullチェックモードでは、コンパイル中のすべてのファイルがnullで未定義である必要があります。</target>
        </trans-unit>
        <trans-unit id="6bafe310667e5e4e7564369b651bf5008fd49779" translate="yes" xml:space="preserve">
          <source>In pre-ES2015 targets, the most faithful emit for constructs like &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;of&lt;/code&gt; loops and array spreads can be a bit heavy. For this reason, TypeScript uses a simpler emit by default that only supports array types, and supports iterating on other types using the &lt;code&gt;--downlevelIteration&lt;/code&gt; flag. The looser default without &lt;code&gt;--downlevelIteration&lt;/code&gt; works fairly well; however, there were some common cases where the transformation of array spreads had observable differences. For example, the following array containing a spread</source>
          <target state="translated">ES2015より前のターゲットの場合、 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;of&lt;/code&gt; ループや配列スプレッドなどの構造の最も忠実な出力は少し重い場合があります。 このため、TypeScriptは単純な &lt;code&gt;--downlevelIteration&lt;/code&gt; を使用します。これは、デフォルトでは配列タイプのみをサポートし、-downlevelIterationフラグを使用して他のタイプの反復をサポートします。 &lt;code&gt;--downlevelIteration&lt;/code&gt; を使用しない場合の--downlevelIterationのデフォルトは、非常にうまく機能します。 ただし、配列スプレッドの変換に顕著な違いがある一般的なケースがいくつかありました。 たとえば、スプレッドを含む次の配列</target>
        </trans-unit>
        <trans-unit id="d8dc065deb2345b3fc2204f90ad4ee7eedf78bff" translate="yes" xml:space="preserve">
          <source>In previous sections, we created generic identity functions that worked over a range of types. In this section, we&amp;rsquo;ll explore the type of the functions themselves and how to create generic interfaces.</source>
          <target state="translated">前のセクションでは、さまざまなタイプで機能する汎用ID関数を作成しました。 このセクションでは、関数自体のタイプと汎用インターフェースの作成方法について説明します。</target>
        </trans-unit>
        <trans-unit id="f628a9f7456d28c2ae0af03d23563c657fc921e2" translate="yes" xml:space="preserve">
          <source>In previous versions of TypeScript, it was an error to merge classes and functions under any circumstances. Now, ambient classes and functions (classes/functions with the &lt;code&gt;declare&lt;/code&gt; modifier, or in &lt;code&gt;.d.ts&lt;/code&gt; files) can merge. This means that now you can write the following:</source>
          <target state="translated">TypeScriptの以前のバージョンでは、あらゆる状況下でクラスと関数をマージするとエラーになりました。 アンビエントクラスと関数（ &lt;code&gt;declare&lt;/code&gt; 修飾子を持つクラス/関数、または &lt;code&gt;.d.ts&lt;/code&gt; ファイル内）をマージできるようになりました。 つまり、次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="f22c95046aa4c7055bed172e8f2f4e6828c3f4e5" translate="yes" xml:space="preserve">
          <source>In previous versions of TypeScript, the language didn&amp;rsquo;t allow &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessors in ambient contexts (like in &lt;code&gt;declare&lt;/code&gt;-d classes, or in &lt;code&gt;.d.ts&lt;/code&gt; files in general). The rationale was that accessors weren&amp;rsquo;t distinct from properties as far as writing and reading to these properties; however, &lt;a href=&quot;https://github.com/tc39/proposal-class-fields/issues/248&quot;&gt;because ECMAScript&amp;rsquo;s class fields proposal may have differing behavior from in existing versions of TypeScript&lt;/a&gt;, we realized we needed a way to communicate this different behavior to provide appropriate errors in subclasses.</source>
          <target state="translated">TypeScriptの以前のバージョンでは、アンビエントコンテキスト（ &lt;code&gt;declare&lt;/code&gt; -dクラスや一般的な &lt;code&gt;.d.ts&lt;/code&gt; ファイルなど）で &lt;code&gt;get&lt;/code&gt; および &lt;code&gt;set&lt;/code&gt; アクセサーを許可していませんでした。 論理的根拠は、これらのプロパティの書き込みと読み取りに関する限り、アクセサはプロパティと区別されなかったことです。 ただし、 &lt;a href=&quot;https://github.com/tc39/proposal-class-fields/issues/248&quot;&gt;ECMAScriptクラスフィールドの提案&lt;/a&gt;はTypeScriptの既存のバージョンとは異なる動作をする可能性があるため、サブクラスには適切なエラーを提供するためにこの異なる動作を伝える方法が必要であることがわかりました。 だった。</target>
        </trans-unit>
        <trans-unit id="3cd7367e12bf3be0daca8711d8c00eca9148e271" translate="yes" xml:space="preserve">
          <source>In prior versions of TypeScript, unions of callable types could &lt;em&gt;only&lt;/em&gt; be invoked if they had identical parameter lists.</source>
          <target state="translated">TypeScriptの以前のバージョンでは、パラメーターリストが同じ場合に&lt;em&gt;のみ&lt;/em&gt; 、呼び出し可能な型のユニオンを呼び出すことができました。</target>
        </trans-unit>
        <trans-unit id="6c9fb325d7fa06659600b395394db2f6b03b95fa" translate="yes" xml:space="preserve">
          <source>In regular type checking mode the inferred type of &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;any&lt;/code&gt; because of widening, but in strict null checking mode the inferred type of &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; (and therefore, absent a type annotation, &lt;code&gt;null&lt;/code&gt; is the only possible value for &lt;code&gt;z&lt;/code&gt;).</source>
          <target state="translated">通常の型チェックモードでは、 &lt;code&gt;z&lt;/code&gt; の推定型は拡張によるものですが、厳密なnullチェックモードでは、 &lt;code&gt;z&lt;/code&gt; の推定型は &lt;code&gt;null&lt;/code&gt; です （したがって、型注釈がない場合、 &lt;code&gt;z&lt;/code&gt; が唯一の可能な値です）。</target>
        </trans-unit>
        <trans-unit id="7f54adc2fc21b0868ad3536236db9c436bfd98c6" translate="yes" xml:space="preserve">
          <source>In short using this general type, we can model React&amp;rsquo;s specific behavior for things like &lt;code&gt;defaultProps&lt;/code&gt; and, to some extent, &lt;code&gt;propTypes&lt;/code&gt;.</source>
          <target state="translated">つまり、この汎用タイプを使用して、 &lt;code&gt;defaultProps&lt;/code&gt; やある程度 &lt;code&gt;propTypes&lt;/code&gt; など、Reactの特定の動作をモデル化できます。</target>
        </trans-unit>
        <trans-unit id="3e40e3de53767b82c408d32adbf7faeb04be447e" translate="yes" xml:space="preserve">
          <source>In short, what this means is that you&amp;rsquo;ll be able to appropriately narrow down values from iterators when dealing with them directly.</source>
          <target state="translated">本質的に、これは、反復子から直接値を操作する場合、反復子から値を適切にフィルタリングできることを意味します。</target>
        </trans-unit>
        <trans-unit id="d6cb0b5b618417fb0993aeb5137486599cc6a685" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to only load a module under some conditions. In TypeScript, we can use the pattern shown below to implement this and other advanced loading scenarios to directly invoke the module loaders without losing type safety.</source>
          <target state="translated">場合によっては、特定の条件下でのみモジュールをロードできます。 TypeScriptを使用すると、以下に示すパターンを使用してこれらの他の高度なロードシナリオを実装し、型安全性を失うことなくモジュールローダーを直接呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="c99a1ed58829ceab5559116a15c7379e705e9cf2" translate="yes" xml:space="preserve">
          <source>In strict null checking mode the compiler requires every reference to a local variable of a type that doesn&amp;rsquo;t include &lt;code&gt;undefined&lt;/code&gt; to be preceded by an assignment to that variable in every possible preceding code path.</source>
          <target state="translated">厳密なnullチェックモードでは、コンパイラは、その変数へのすべての参照の前に、 &lt;code&gt;undefined&lt;/code&gt; を含まないタイプのローカル変数に割り当てるすべての先行コードパスを必要とします。</target>
        </trans-unit>
        <trans-unit id="90cda15a62a8aabc97010caa6808ab78ddacdf3d" translate="yes" xml:space="preserve">
          <source>In strict null checking mode, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values are &lt;em&gt;not&lt;/em&gt; in the domain of every type and are only assignable to themselves and &lt;code&gt;any&lt;/code&gt; (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). So, whereas &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T | undefined&lt;/code&gt; are considered synonymous in regular type checking mode (because &lt;code&gt;undefined&lt;/code&gt; is considered a subtype of any &lt;code&gt;T&lt;/code&gt;), they are different types in strict type checking mode, and only &lt;code&gt;T | undefined&lt;/code&gt; permits &lt;code&gt;undefined&lt;/code&gt; values. The same is true for the relationship of &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;T | null&lt;/code&gt;.</source>
          <target state="translated">厳密なnullチェックモードでは、 &lt;code&gt;null&lt;/code&gt; 値と &lt;code&gt;undefined&lt;/code&gt; 値はすべての種類のドメインに存在する&lt;em&gt;わけで&lt;/em&gt;は&lt;em&gt;なく&lt;/em&gt; 、自分自身と &lt;code&gt;any&lt;/code&gt; にのみ割り当てることができます （ &lt;code&gt;undefined&lt;/code&gt; は &lt;code&gt;void&lt;/code&gt; に割り当てることもできます ）。 したがって、 &lt;code&gt;T&lt;/code&gt; と &lt;code&gt;T | undefined&lt;/code&gt; undefined undefinedは通常の型チェックモードでは同義と見なされ（ &lt;code&gt;undefined&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; のサブタイプと見なされるため）、厳密な型チェックモードでは異なる型であり、 &lt;code&gt;T | undefined&lt;/code&gt; undefined undefinedは &lt;code&gt;undefined&lt;/code&gt; Allow値です。 &lt;code&gt;T&lt;/code&gt; と &lt;code&gt;T | null&lt;/code&gt; についても同じことが言えます。 null関係。 ヌル</target>
        </trans-unit>
        <trans-unit id="864d1a7dd1f8dd603a28df5bb3a63874ccc5a6ed" translate="yes" xml:space="preserve">
          <source>In strict null checking mode, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values are not in the domain of every type and are only assignable to themselves and &lt;code&gt;any&lt;/code&gt; (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">厳密なnullチェックモードでは、 &lt;code&gt;null&lt;/code&gt; 値と &lt;code&gt;undefined&lt;/code&gt; 値はすべてのタイプのドメインに存在するわけではなく、自分自身と &lt;code&gt;any&lt;/code&gt; にのみ割り当てることができます （ &lt;code&gt;undefined&lt;/code&gt; は &lt;code&gt;void&lt;/code&gt; に割り当てることもできます ）。</target>
        </trans-unit>
        <trans-unit id="1682f16f9b1d6f4b318f3d23665b6e6fd98e0061" translate="yes" xml:space="preserve">
          <source>In that example, we first checked whether &lt;code&gt;x&lt;/code&gt; was &lt;em&gt;not&lt;/em&gt;&lt;code&gt;E.Foo&lt;/code&gt;. If that check succeeds, then our &lt;code&gt;||&lt;/code&gt; will short-circuit, and the body of the &amp;lsquo;if&amp;rsquo; will run. However, if the check didn&amp;rsquo;t succeed, then &lt;code&gt;x&lt;/code&gt; can &lt;em&gt;only&lt;/em&gt; be &lt;code&gt;E.Foo&lt;/code&gt;, so it doesn&amp;rsquo;t make sense to see whether it&amp;rsquo;s equal to &lt;code&gt;E.Bar&lt;/code&gt;.</source>
          <target state="translated">その例では、最初に &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;E.Foo&lt;/code&gt; では &lt;em&gt;なかった&lt;/em&gt;かどうかを確認しました 。 チェックが成功した場合、 &lt;code&gt;||&lt;/code&gt; 「if」の本体を短くして実行します。 ただし、チェックが失敗した場合、 &lt;code&gt;x&lt;/code&gt; はE.Fooに&lt;em&gt;しか&lt;/em&gt;なれ&lt;em&gt;ない&lt;/em&gt;ため、 &lt;code&gt;E.Bar&lt;/code&gt; がE.Barと等しいかどうかをチェックしても意味があり&lt;em&gt;ませ&lt;/em&gt;ん。</target>
        </trans-unit>
        <trans-unit id="79540091a75f3fdf1fb7b3a682d8e9c3c45c75f2" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt; will work fine but &lt;code&gt;&amp;lt;bar /&amp;gt;&lt;/code&gt; will result in an error since it has not been specified on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;.</source>
          <target state="translated">上の例では、 &lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt; は &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; ですが、 &lt;code&gt;&amp;lt;bar /&amp;gt;&lt;/code&gt; はJSX.IntrinsicElementsで指定されていないためエラーになります。</target>
        </trans-unit>
        <trans-unit id="99596fbea2ab9226b233fd913b5eb437d1c67537" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;SelectableControl&lt;/code&gt; contains all of the members of &lt;code&gt;Control&lt;/code&gt;, including the private &lt;code&gt;state&lt;/code&gt; property. Since &lt;code&gt;state&lt;/code&gt; is a private member it is only possible for descendants of &lt;code&gt;Control&lt;/code&gt; to implement &lt;code&gt;SelectableControl&lt;/code&gt;. This is because only descendants of &lt;code&gt;Control&lt;/code&gt; will have a &lt;code&gt;state&lt;/code&gt; private member that originates in the same declaration, which is a requirement for private members to be compatible.</source>
          <target state="translated">上記の例では、 &lt;code&gt;SelectableControl&lt;/code&gt; には、プライベート &lt;code&gt;state&lt;/code&gt; プロパティを含む &lt;code&gt;Control&lt;/code&gt; のすべてのメンバーが含まれています。 &lt;code&gt;state&lt;/code&gt; はプライベートメンバーです &lt;code&gt;SelectableControl&lt;/code&gt; 子孫のみがSelectableControlを実装できます。 これは、 &lt;code&gt;Control&lt;/code&gt; 子孫だけが同じ宣言からの &lt;code&gt;state&lt;/code&gt; プライベートメンバーを持っているためです。 これは、プライベートメンバーが互換性を持つための要件です。</target>
        </trans-unit>
        <trans-unit id="6ed88f77aa26355727030898d3eda06664af6814" translate="yes" xml:space="preserve">
          <source>In the above example, all declarations of &lt;code&gt;x&lt;/code&gt; actually refer to the &lt;em&gt;same&lt;/em&gt;&lt;code&gt;x&lt;/code&gt;, and this is perfectly valid. This often ends up being a source of bugs. Thankfully, &lt;code&gt;let&lt;/code&gt; declarations are not as forgiving.</source>
          <target state="translated">上記の例では、 &lt;code&gt;x&lt;/code&gt; のすべての宣言は実際には&lt;em&gt;同じ&lt;/em&gt; xを参照していますが、これは完全に有効です。 これはしばしばバグを引き起こします。 ありがたいことに &lt;code&gt;let&lt;/code&gt; 宣言は許されません。</target>
        </trans-unit>
        <trans-unit id="b37f0e6648f951eed9141c60cd7cf7e3ccaa9494" translate="yes" xml:space="preserve">
          <source>In the above, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are compatible because their structures do not use the type argument in a differentiating way. Changing this example by adding a member to &lt;code&gt;Empty&amp;lt;T&amp;gt;&lt;/code&gt; shows how this works:</source>
          <target state="translated">上記では、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の構成は、type引数を別々に使用しないため、互換性があります。 &lt;code&gt;Empty&amp;lt;T&amp;gt;&lt;/code&gt; この例では、Empty &amp;lt;T&amp;gt;メンバーを追加して、これがどのように機能するかを確認します。</target>
        </trans-unit>
        <trans-unit id="bcf8f6881cecc6ec19e3b84c191f76d8a00ed9f0" translate="yes" xml:space="preserve">
          <source>In the above, if we truly meant for &lt;code&gt;baz&lt;/code&gt; to potentially be &lt;code&gt;undefined&lt;/code&gt;, we should have declared it with the type &lt;code&gt;boolean | undefined&lt;/code&gt;.</source>
          <target state="translated">上記で、 &lt;code&gt;baz&lt;/code&gt; が実際に &lt;code&gt;undefined&lt;/code&gt; の可能性を意味する場合、 &lt;code&gt;boolean | undefined&lt;/code&gt; を宣言する必要があります。 未定義 未定義</target>
        </trans-unit>
        <trans-unit id="ce3f57dfeaf54342e6e1919ab8d0e5f056d046b7" translate="yes" xml:space="preserve">
          <source>In the above, the variable &lt;code&gt;a&lt;/code&gt; has a conditional type that hasn&amp;rsquo;t yet chosen a branch. When another piece of code ends up calling &lt;code&gt;foo&lt;/code&gt;, it will substitute in &lt;code&gt;U&lt;/code&gt; with some other type, and TypeScript will re-evaluate the conditional type, deciding whether it can actually pick a branch.</source>
          <target state="translated">上記では、変数 &lt;code&gt;a&lt;/code&gt; には、ブランチをまだ選択していない条件タイプがあります。 別のコードが &lt;code&gt;foo&lt;/code&gt; を呼び出すと、 &lt;code&gt;U&lt;/code&gt; の別のタイプに置き換えられ、TypeScriptは条件付きタイプを再評価して、実際にブランチを選択できるかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="61a17b1c1f756acdcb3aa7db7732994bae993575" translate="yes" xml:space="preserve">
          <source>In the code below, we show how you can model mixins in TypeScript. After the code, we&amp;rsquo;ll break down how it works.</source>
          <target state="translated">次のコードは、TypeScriptでミックスインをモデル化する方法を示しています。 コードの後に​​、それがどのように機能するかを分析します。</target>
        </trans-unit>
        <trans-unit id="03d5f48ae796a4f0c523d1b9798d453b05171c1c" translate="yes" xml:space="preserve">
          <source>In the declaration of &lt;code&gt;f2&lt;/code&gt; above, type inference infers types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;[string, boolean]&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; respectively.</source>
          <target state="translated">上記の &lt;code&gt;f2&lt;/code&gt; 宣言では、型推論は、それぞれ &lt;code&gt;T&lt;/code&gt; 、 &lt;code&gt;U&lt;/code&gt; 、および &lt;code&gt;V&lt;/code&gt; の型 &lt;code&gt;number&lt;/code&gt; 、 &lt;code&gt;[string, boolean]&lt;/code&gt; 、および &lt;code&gt;void&lt;/code&gt; を推測します。</target>
        </trans-unit>
        <trans-unit id="95157007d65e1f4f235f4c91408fe5a0cb118ec2" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;methods&lt;/code&gt; object in the argument to &lt;code&gt;makeObject&lt;/code&gt; has a contextual type that includes &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; and therefore the type of &lt;code&gt;this&lt;/code&gt; in methods within the &lt;code&gt;methods&lt;/code&gt; object is &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt;. Notice how the type of the &lt;code&gt;methods&lt;/code&gt; property simultaneously is an inference target and a source for the &lt;code&gt;this&lt;/code&gt; type in methods.</source>
          <target state="translated">上記の例では、 &lt;code&gt;makeObject&lt;/code&gt; への引数の &lt;code&gt;methods&lt;/code&gt; オブジェクトのコンテキストタイプには &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; が含まれているため、 &lt;code&gt;methods&lt;/code&gt; オブジェクト内のメソッドの &lt;code&gt;this&lt;/code&gt; タイプは &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt; 。 &lt;code&gt;methods&lt;/code&gt; プロパティのタイプは、 &lt;code&gt;this&lt;/code&gt; タイプのメソッドの推論ターゲットおよびソースでもあることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6d5d9e4e961d95a62eff2086560d0f53e21c16be" translate="yes" xml:space="preserve">
          <source>In the example above, the parameters &lt;code&gt;fruit&lt;/code&gt; and &lt;code&gt;color&lt;/code&gt; are intersected together to a new parameter of type &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt;. &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; is really the same as &lt;code&gt;(&quot;apple&quot; | &quot;orange&quot;) &amp;amp; (&quot;red&quot; | &quot;orange&quot;)&lt;/code&gt; which is equivalent to &lt;code&gt;(&quot;apple&quot; &amp;amp; &quot;red&quot;) | (&quot;apple&quot; &amp;amp; &quot;orange&quot;) | (&quot;orange&quot; &amp;amp; &quot;red&quot;) | (&quot;orange&quot; &amp;amp; &quot;orange&quot;)&lt;/code&gt;. Each of those impossible intersections reduces to &lt;code&gt;never&lt;/code&gt;, and we&amp;rsquo;re left with &lt;code&gt;&quot;orange&quot; &amp;amp; &quot;orange&quot;&lt;/code&gt; which is just &lt;code&gt;&quot;orange&quot;&lt;/code&gt;.</source>
          <target state="translated">上記の例では、パラメータ &lt;code&gt;fruit&lt;/code&gt; と &lt;code&gt;color&lt;/code&gt; が交差して、タイプ &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; 新しいパラメータになります。 &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; は &lt;code&gt;(&quot;apple&quot; | &quot;orange&quot;) &amp;amp; (&quot;red&quot; | &quot;orange&quot;)&lt;/code&gt; と同じで、これは &lt;code&gt;(&quot;apple&quot; &amp;amp; &quot;red&quot;) | (&quot;apple&quot; &amp;amp; &quot;orange&quot;) | (&quot;orange&quot; &amp;amp; &quot;red&quot;) | (&quot;orange&quot; &amp;amp; &quot;orange&quot;)&lt;/code&gt; （「リンゴ」と「オレンジ」）| （「オレンジ」と「赤」）| （ &quot;オレンジ&quot;＆ &quot;オレンジ&quot;） | （「リンゴ」と「オレンジ」）| （「オレンジ」と「赤」）| （「オレンジ」および「オレンジ」）。 これらの不可能な交差点のそれぞれは &lt;code&gt;never&lt;/code&gt; 、 &lt;code&gt;&quot;orange&quot; &amp;amp; &quot;orange&quot;&lt;/code&gt; のみを残します。 これは単なる &lt;code&gt;&quot;orange&quot;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e74ceca454671112b40bc5e5f6a4f738b5ff4300" translate="yes" xml:space="preserve">
          <source>In the following example, each input element will be printed out one at a time with a 400ms delay:</source>
          <target state="translated">次の例では、各入力要素は400ミリ秒の遅延で一度に1つずつ出力されます。</target>
        </trans-unit>
        <trans-unit id="8c77483272b3e6dc467114f873247e6bedc0a970" translate="yes" xml:space="preserve">
          <source>In the last line we construct an instance of the &lt;code&gt;Greeter&lt;/code&gt; class using &lt;code&gt;new&lt;/code&gt;. This calls into the constructor we defined earlier, creating a new object with the &lt;code&gt;Greeter&lt;/code&gt; shape, and running the constructor to initialize it.</source>
          <target state="translated">最後の行は、 &lt;code&gt;new&lt;/code&gt; を使用して &lt;code&gt;Greeter&lt;/code&gt; クラスのインスタンスを構築します。 これは、以前に定義されたコンストラクターを呼び出し、 &lt;code&gt;Greeter&lt;/code&gt; シェイプで新しいオブジェクトを作成し、コンストラクターを実行して初期化します。</target>
        </trans-unit>
        <trans-unit id="00dda950efe1878e4784a73323a690e1209928a7" translate="yes" xml:space="preserve">
          <source>In the last window, select the &lt;strong&gt;Empty&lt;/strong&gt; template and press the &lt;em&gt;Create&lt;/em&gt; button</source>
          <target state="translated">最後のウィンドウで、 &lt;strong&gt;空の&lt;/strong&gt;テンプレートを選択し、 &lt;em&gt;作成&lt;/em&gt;ボタンを押します</target>
        </trans-unit>
        <trans-unit id="730482750c8e706f4fdc3f8ccd811c5e5dd87860" translate="yes" xml:space="preserve">
          <source>In the meantime, we can assign a conditional type to any other target type as long as each branch of the conditional is assignable to that target. So in our example above we were able to assign &lt;code&gt;U extends Foo ? string : number&lt;/code&gt; to &lt;code&gt;string | number&lt;/code&gt; since no matter what the conditional evaluates to, it&amp;rsquo;s known to be either &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">それまでの間、条件の各ブランチがターゲットに割り当てられている限り、条件タイプを他のターゲットタイプに割り当てることができます。 したがって、上記の例では、 &lt;code&gt;U extends Foo ? string : number&lt;/code&gt; を割り当てることができますか？ 文字列：数値 ？ 文字列： &lt;code&gt;string&lt;/code&gt; の評価対象に関係なく、数値はstringまたは &lt;code&gt;number&lt;/code&gt; であることがわかってい &lt;code&gt;string | number&lt;/code&gt; 数値条件式。</target>
        </trans-unit>
        <trans-unit id="4fa79973a1fa7675ac6793a6ef6bc0254a0e6be8" translate="yes" xml:space="preserve">
          <source>In the near future, we&amp;rsquo;re going to be refreshing the playground samples, adding JSX support, and polishing automatic type acquisition, meaning that you&amp;rsquo;ll be able to see the same experience on the playground as you&amp;rsquo;d get in your personal editor.</source>
          <target state="translated">近い将来、プレイグラウンドの例を更新し、JSXサポートを追加し、自動タイプキャプチャを改良します。 つまり、プレイグラウンドでパーソナルエディターを使用するのと同じ体験を見ることができます。 。</target>
        </trans-unit>
        <trans-unit id="b3d6d530b9dead34dd8c0b86ef1bb298c7054a3c" translate="yes" xml:space="preserve">
          <source>In the project root, &lt;code&gt;proj&lt;/code&gt;, create the file &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">プロジェクトルート &lt;code&gt;proj&lt;/code&gt; で、ファイル &lt;code&gt;tsconfig.json&lt;/code&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="709cd93c7870c32633ca0a9bee5820c6fc2cb1c9" translate="yes" xml:space="preserve">
          <source>In the project root, create the file &lt;code&gt;gulpfile.js&lt;/code&gt;:</source>
          <target state="translated">プロジェクトルートに &lt;code&gt;gulpfile.js&lt;/code&gt; ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="73b6e04bf922a9cb6a95afcfe0525fa94ba745bd" translate="yes" xml:space="preserve">
          <source>In the type of a module object, exported &lt;code&gt;const&lt;/code&gt; variables are considered read-only properties.</source>
          <target state="translated">モジュールオブジェクトタイプの場合、エクスポートされた &lt;code&gt;const&lt;/code&gt; 変数は読み取り専用プロパティと見なされます。</target>
        </trans-unit>
        <trans-unit id="755da82a78f6c2a7ac8e76c0724da8dab740a01c" translate="yes" xml:space="preserve">
          <source>In the type of an enum object, enum members are considered read-only properties.</source>
          <target state="translated">列挙オブジェクト型の場合、列挙メンバーは読み取り専用プロパティと見なされます。</target>
        </trans-unit>
        <trans-unit id="637246693f4b6e39ecb694cc209862482bcc6694" translate="yes" xml:space="preserve">
          <source>In these examples, the properties list is &lt;code&gt;keyof T&lt;/code&gt; and the resulting type is some variant of &lt;code&gt;T[P]&lt;/code&gt;. This is a good template for any general use of mapped types. That&amp;rsquo;s because this kind of transformation is &lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphism&quot;&gt;homomorphic&lt;/a&gt;, which means that the mapping applies only to properties of &lt;code&gt;T&lt;/code&gt; and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if &lt;code&gt;Person.name&lt;/code&gt; was readonly, &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; would be readonly and optional.</source>
          <target state="translated">これらの例では、プロパティリストは &lt;code&gt;keyof T&lt;/code&gt; であり、結果の型は &lt;code&gt;T[P]&lt;/code&gt; バリアントです。 これは、マップされたタイプの一般的な使用に適したテンプレートです。 これは、このタイプの変換が&lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphism&quot;&gt;準同型であるため&lt;/a&gt;です。 つまり、マッピングは &lt;code&gt;T&lt;/code&gt; のプロパティにのみ適用され、他のプロパティには適用されません。 コンパイラは、新しいプロパティ修飾子を追加する前に、既存のすべてのプロパティ修飾子をコピーできることを知っています。 たとえば、 &lt;code&gt;Person.name&lt;/code&gt; が読み取り専用の場合、 &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; は読み取り専用でオプションです。</target>
        </trans-unit>
        <trans-unit id="ed7a5a445e563d2e25cbaa994041bb2fd2483e73" translate="yes" xml:space="preserve">
          <source>In this above example, &lt;code&gt;g&lt;/code&gt; captured the variable &lt;code&gt;a&lt;/code&gt; declared in &lt;code&gt;f&lt;/code&gt;. At any point that &lt;code&gt;g&lt;/code&gt; gets called, the value of &lt;code&gt;a&lt;/code&gt; will be tied to the value of &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;f&lt;/code&gt;. Even if &lt;code&gt;g&lt;/code&gt; is called once &lt;code&gt;f&lt;/code&gt; is done running, it will be able to access and modify &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">上記の例では、 &lt;code&gt;g&lt;/code&gt; は &lt;code&gt;f&lt;/code&gt; で宣言された変数 &lt;code&gt;a&lt;/code&gt; をキャプチャしました。 &lt;code&gt;g&lt;/code&gt; が呼び出され、aの値は &lt;code&gt;f&lt;/code&gt; の &lt;code&gt;a&lt;/code&gt; の値に関連付けられます。 &lt;code&gt;f&lt;/code&gt; の実行が終了するとf &lt;code&gt;g&lt;/code&gt; が呼び出され、aにアクセスして変更できます。</target>
        </trans-unit>
        <trans-unit id="c8516f6347c523b45eca06136cb8874b9907d612" translate="yes" xml:space="preserve">
          <source>In this case, we need to use TypeScript to tell any of our callers about the ways &lt;code&gt;myCoolFunction&lt;/code&gt; can be called using function overloads.</source>
          <target state="translated">この場合、TypeScriptを使用して、関数のオーバーロードを使用してmyCoolFunctionを呼び出す方法を &lt;code&gt;myCoolFunction&lt;/code&gt; 呼び出し元に指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="e82ac6e4567b6044965f051115c0822a64abe344" translate="yes" xml:space="preserve">
          <source>In this example if &lt;code&gt;someValue&lt;/code&gt; isn&amp;rsquo;t equal to &lt;code&gt;42&lt;/code&gt;, then &lt;code&gt;assert&lt;/code&gt; will throw an &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;someValue&lt;/code&gt; が &lt;code&gt;42&lt;/code&gt; に等しくない場合、 &lt;code&gt;assert&lt;/code&gt; は &lt;code&gt;AssertionError&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="e08fcd6cf022585dcfea9733e021155ec20b4944" translate="yes" xml:space="preserve">
          <source>In this example the &lt;code&gt;b?&lt;/code&gt; indicates that &lt;code&gt;b&lt;/code&gt; is optional, so it may be &lt;code&gt;undefined&lt;/code&gt;. &lt;code&gt;keepWholeObject&lt;/code&gt; now has a variable for &lt;code&gt;wholeObject&lt;/code&gt; as well as the properties &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, even if &lt;code&gt;b&lt;/code&gt; is undefined.</source>
          <target state="translated">この例では、 &lt;code&gt;b?&lt;/code&gt; &lt;code&gt;b&lt;/code&gt; はオプションであるため &lt;code&gt;undefined&lt;/code&gt; です。 &lt;code&gt;keepWholeObject&lt;/code&gt; には、 &lt;code&gt;b&lt;/code&gt; が未定義の場合でも &lt;code&gt;a&lt;/code&gt; &lt;code&gt;wholeObject&lt;/code&gt; の変数とプロパティaおよびbがあります。</target>
        </trans-unit>
        <trans-unit id="0117e5cd2d6305504464fa64c2596948182a60ec" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;greeter1&lt;/code&gt; works similarly to before. We instantiate the &lt;code&gt;Greeter&lt;/code&gt; class, and use this object. This we have seen before.</source>
          <target state="translated">この例では、 &lt;code&gt;greeter1&lt;/code&gt; は以前と同じように機能します。 &lt;code&gt;Greeter&lt;/code&gt; クラスをインスタンス化し、このオブジェクトを使用します。 これは以前に見られました。</target>
        </trans-unit>
        <trans-unit id="dbc3444b1d43d45eab0b74e1029b727531c4431d" translate="yes" xml:space="preserve">
          <source>In this example, best common type has a set of four candidates: &lt;code&gt;Animal&lt;/code&gt;, &lt;code&gt;Rhino&lt;/code&gt;, &lt;code&gt;Elephant&lt;/code&gt;, and &lt;code&gt;Snake&lt;/code&gt;. Of these, &lt;code&gt;Animal&lt;/code&gt; can be chosen by the best common type algorithm.</source>
          <target state="translated">この例では、最も一般的なタイプは、 &lt;code&gt;Animal&lt;/code&gt; 、 &lt;code&gt;Rhino&lt;/code&gt; 、 &lt;code&gt;Elephant&lt;/code&gt; 、および &lt;code&gt;Snake&lt;/code&gt; の4つの候補のセットです。 これらのうち、最も一般的なタイプのアルゴリズムで &lt;code&gt;Animal&lt;/code&gt; を選択できます。</target>
        </trans-unit>
        <trans-unit id="bb24f11a568ad33b4fe399d85ff9d360b565ca4d" translate="yes" xml:space="preserve">
          <source>In this example, the first block creates the following name meanings:</source>
          <target state="translated">この例では、最初のブロックは次の名前の意味を作成します。</target>
        </trans-unit>
        <trans-unit id="6e7043ef257b3c1ba5ae99cc4588d236122d0645" translate="yes" xml:space="preserve">
          <source>In this example, there wasn&amp;rsquo;t a namespace &lt;code&gt;C&lt;/code&gt; until we wrote the &lt;code&gt;namespace&lt;/code&gt; declaration for it. The meaning &lt;code&gt;C&lt;/code&gt; as a namespace doesn&amp;rsquo;t conflict with the value or type meanings of &lt;code&gt;C&lt;/code&gt; created by the class.</source>
          <target state="translated">この例では、名前空間宣言が書き込まれるまで、名前 &lt;code&gt;namespace&lt;/code&gt; &lt;code&gt;C&lt;/code&gt; はありませんでした。 名前空間としての &lt;code&gt;C&lt;/code&gt; の意味は、C値またはクラスによって作成された型の意味と競合しません。</target>
        </trans-unit>
        <trans-unit id="07eb43c9c23afe5a52badab0f998515ac89c2d2c" translate="yes" xml:space="preserve">
          <source>In this example, we have an &lt;code&gt;Animal&lt;/code&gt; and a &lt;code&gt;Rhino&lt;/code&gt;, with &lt;code&gt;Rhino&lt;/code&gt; being a subclass of &lt;code&gt;Animal&lt;/code&gt;. We also have a new class &lt;code&gt;Employee&lt;/code&gt; that looks identical to &lt;code&gt;Animal&lt;/code&gt; in terms of shape. We create some instances of these classes and then try to assign them to each other to see what will happen. Because &lt;code&gt;Animal&lt;/code&gt; and &lt;code&gt;Rhino&lt;/code&gt; share the &lt;code&gt;private&lt;/code&gt; side of their shape from the same declaration of &lt;code&gt;private name: string&lt;/code&gt; in &lt;code&gt;Animal&lt;/code&gt;, they are compatible. However, this is not the case for &lt;code&gt;Employee&lt;/code&gt;. When we try to assign from an &lt;code&gt;Employee&lt;/code&gt; to &lt;code&gt;Animal&lt;/code&gt; we get an error that these types are not compatible. Even though &lt;code&gt;Employee&lt;/code&gt; also has a &lt;code&gt;private&lt;/code&gt; member called &lt;code&gt;name&lt;/code&gt;, it&amp;rsquo;s not the one we declared in &lt;code&gt;Animal&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;Animal&lt;/code&gt; と &lt;code&gt;Rhino&lt;/code&gt; があり、Rhinoは &lt;code&gt;Animal&lt;/code&gt; のサブクラスです。 また、 &lt;code&gt;Animal&lt;/code&gt; 形をした新しいクラス &lt;code&gt;Employee&lt;/code&gt; もあります。 これらのクラスのインスタンスをいくつか作成し、それらを相互に割り当てて、何が起こるかを確認します。 &lt;code&gt;Animal&lt;/code&gt; と &lt;code&gt;Rhino&lt;/code&gt; は、 &lt;code&gt;Animal&lt;/code&gt; の文字列からシェイプの &lt;code&gt;private&lt;/code&gt; サイドを共有しているため、互換性があります。これは、同じ &lt;code&gt;private name: string&lt;/code&gt; private nameです。 ただし、これは &lt;code&gt;Employee&lt;/code&gt; の場合ではありません。 &lt;code&gt;Employee&lt;/code&gt; から &lt;code&gt;Animal&lt;/code&gt; に割り当てようとする従業員には、これらのタイプに互換性がないというエラーが表示されます。 &lt;code&gt;Employee&lt;/code&gt; には、 &lt;code&gt;name&lt;/code&gt; という名前の &lt;code&gt;private&lt;/code&gt; メンバーもいますが、これは &lt;code&gt;Animal&lt;/code&gt; で宣言されたメンバーではありません。</target>
        </trans-unit>
        <trans-unit id="b1b93b10a4841edacda1facc2b60962e38ac6558" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ll move all validator-related entities into a namespace called &lt;code&gt;Validation&lt;/code&gt;. Because we want the interfaces and classes here to be visible outside the namespace, we preface them with &lt;code&gt;export&lt;/code&gt;. Conversely, the variables &lt;code&gt;lettersRegexp&lt;/code&gt; and &lt;code&gt;numberRegexp&lt;/code&gt; are implementation details, so they are left unexported and will not be visible to code outside the namespace. In the test code at the bottom of the file, we now need to qualify the names of the types when used outside the namespace, e.g. &lt;code&gt;Validation.LettersOnlyValidator&lt;/code&gt;.</source>
          <target state="translated">この例では、すべてのバリデータ関連のエンティティを &lt;code&gt;Validation&lt;/code&gt; 名前空間に移動します。 ここでは、名前空間の外部でインターフェイスとクラスを表示できるようにするため、 &lt;code&gt;export&lt;/code&gt; で開始します 。 逆に、変数 &lt;code&gt;lettersRegexp&lt;/code&gt; および &lt;code&gt;numberRegexp&lt;/code&gt; は実装の詳細であるため、エクスポートされずに残り、名前空間外のコードには表示されません。 &lt;code&gt;Validation.LettersOnlyValidator&lt;/code&gt; など、名前空間の外部で使用する場合、ファイルの下部にあるテストコードは型名を修飾する必要があります。</target>
        </trans-unit>
        <trans-unit id="21b24c391b92fb3d3163326a7abc4416dc6df6f4" translate="yes" xml:space="preserve">
          <source>In this generated code, an enum is compiled into an object that stores both forward (&lt;code&gt;name&lt;/code&gt; -&amp;gt; &lt;code&gt;value&lt;/code&gt;) and reverse (&lt;code&gt;value&lt;/code&gt; -&amp;gt; &lt;code&gt;name&lt;/code&gt;) mappings. References to other enum members are always emitted as property accesses and never inlined.</source>
          <target state="translated">この生成されたコードでは、enumは順方向（name-&amp;gt; &lt;code&gt;value&lt;/code&gt; ）と逆方向（value-&amp;gt; &lt;code&gt;name&lt;/code&gt; ）の両方のマッピングを格納するオブジェクトにコンパイルされます。 他の列挙型メンバーへの参照は常にプロパティアクセスとして発行され、インライン化されません。</target>
        </trans-unit>
        <trans-unit id="bdc69a132c77ea1870143e272db1728193078fad" translate="yes" xml:space="preserve">
          <source>In this guide, we&amp;rsquo;ll assume basic familiarity with the TypeScript language. If you haven&amp;rsquo;t already, you should read the &lt;a href=&quot;../basic-types&quot;&gt;TypeScript Handbook&lt;/a&gt; to familiarize yourself with basic concepts, especially types and namespaces.</source>
          <target state="translated">このガイドは、TypeScript言語の基本的な知識を前提としています。 まだお持ちでない場合は、 &lt;a href=&quot;../basic-types&quot;&gt;TypeScriptハンドブック&lt;/a&gt;を読んで、基本的な概念、特に型と名前空間を理解してください。</target>
        </trans-unit>
        <trans-unit id="344769647b81b7e0305ef0d99ae5fb65a087fe6f" translate="yes" xml:space="preserve">
          <source>In this mode, references to modules and packages (e.g. &lt;code&gt;import&lt;/code&gt;s and &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to. For a more concrete example, we&amp;rsquo;ll defer to &lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;the documentation on the Node.js website&lt;/a&gt;.</source>
          <target state="translated">このモードでは、モジュールおよびパッケージへの参照（たとえば、 &lt;code&gt;import&lt;/code&gt; および &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; ディレクティブ）は、シンボリックリンクファイルの場所ではなくパスに対して解決されます。 シンボリックリンクが解決されます。 より具体的な例について&lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;は、Node.js Webサイトのドキュメントを参照してください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="e80e58412d6afa0148bbe0431cb48a4186ad829b" translate="yes" xml:space="preserve">
          <source>In this section we&amp;rsquo;ll describe various common pitfalls in using namespaces and modules, and how to avoid them.</source>
          <target state="translated">このセクションでは、名前空間とモジュールを使用する際のさまざまな一般的な落とし穴と、それらを回避する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="1517fdb2153dd36963c7b932505762d1e99e7637" translate="yes" xml:space="preserve">
          <source>In this section, we will cover type inference in TypeScript. Namely, we&amp;rsquo;ll discuss where and how types are inferred.</source>
          <target state="translated">このセクションでは、TypeScript型の推論について説明します。 つまり、型が推測される場所と方法です。</target>
        </trans-unit>
        <trans-unit id="bf72d17da27b309b1e4973b2684904a5f12bc9b3" translate="yes" xml:space="preserve">
          <source>In this simple example, &lt;code&gt;Keys&lt;/code&gt; is a hard-coded list of property names and the property type is always &lt;code&gt;boolean&lt;/code&gt;, so this mapped type is equivalent to writing:</source>
          <target state="translated">この単純な例では、 &lt;code&gt;Keys&lt;/code&gt; はプロパティ名のハードコーディングされたリストであり、プロパティタイプは常に &lt;code&gt;boolean&lt;/code&gt; であるため、このマッピングされたタイプは次と同等です。</target>
        </trans-unit>
        <trans-unit id="7836cdb9242f8e5048b5c13b75f69d0839c138b0" translate="yes" xml:space="preserve">
          <source>In this version, we add a setter that checks the length of the &lt;code&gt;newName&lt;/code&gt; to make sure it&amp;rsquo;s compatible with the max-length of our backing database field. If it isn&amp;rsquo;t we throw an error notifying client code that something went wrong.</source>
          <target state="translated">このバージョンは、 &lt;code&gt;newName&lt;/code&gt; の長さをチェックして、バッキングデータベースフィールドの最大長と互換性があることを確認するセッターを追加します。 そうでない場合は、エラーが発生し、クライアントコードに何か問題が発生したことが通知されます。</target>
        </trans-unit>
        <trans-unit id="2de95615256a6fbbdcec9fe7db708d237a429e35" translate="yes" xml:space="preserve">
          <source>In this way, a generic type that has its type arguments specified acts just like a non-generic type.</source>
          <target state="translated">このように、型引数を持つジェネリック型は、非ジェネリック型のように動作します。</target>
        </trans-unit>
        <trans-unit id="6f1aae5fbefc53fbec291cb812ed1e6d471e127d" translate="yes" xml:space="preserve">
          <source>In traditional object-oriented code, we might abstract over the two types by creating a hierarchy of types. While this is much more explicit, it&amp;rsquo;s also a little bit overkill. One of the nice things about the original version of &lt;code&gt;padLeft&lt;/code&gt; was that we were able to just pass in primitives. That meant that usage was simple and concise. This new approach also wouldn&amp;rsquo;t help if we were just trying to use a function that already exists elsewhere.</source>
          <target state="translated">従来のオブジェクト指向コードでは、型階層を作成して2つの型を抽象化できました。 これははるかに明確ですが、少しやり過ぎです。 &lt;code&gt;padLeft&lt;/code&gt; の元のバージョンの素晴らしい点は、プリミティブを渡すことができたことです。 要するに、使い方はシンプルで簡潔でした。 また、この新しいアプローチは、すでに他の場所に存在する関数を使用しようとするのに役立ちません。</target>
        </trans-unit>
        <trans-unit id="3797c645e8a8c499cfcb7b4049e4893eece69214" translate="yes" xml:space="preserve">
          <source>In your editor, type the following JavaScript code in &lt;code&gt;greeter.ts&lt;/code&gt;:</source>
          <target state="translated">エディターで、次のJavaScriptコードを &lt;code&gt;greeter.ts&lt;/code&gt; に入力します。</target>
        </trans-unit>
        <trans-unit id="4dbe40d3f9dd76b0ebc598a2769c3f694b16d1ea" translate="yes" xml:space="preserve">
          <source>Include modules imported with &lt;code&gt;.json&lt;/code&gt; extension.</source>
          <target state="translated">&lt;code&gt;.json&lt;/code&gt; 拡張子でインポートされた.jsonモジュール。</target>
        </trans-unit>
        <trans-unit id="6898584222dc5329b65b711cc8ca941a2e824a68" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--allowJs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--allowJs&lt;/code&gt; を指定した &lt;code&gt;.js&lt;/code&gt; ファイル</target>
        </trans-unit>
        <trans-unit id="ab817f6003eff1222b8c915e012bd4827feb5c30" translate="yes" xml:space="preserve">
          <source>Including built-in type declarations with &lt;code&gt;--lib&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--lib&lt;/code&gt; を使用して組み込み型宣言を含める</target>
        </trans-unit>
        <trans-unit id="c320930067fba589bb3a1d6786d55f841bf144ab" translate="yes" xml:space="preserve">
          <source>Including declarations in your npm package</source>
          <target state="translated">npmパッケージに宣言を含める</target>
        </trans-unit>
        <trans-unit id="9bc53de5c2f8d2c282bf0578d8a05703182b23ad" translate="yes" xml:space="preserve">
          <source>Incremental file watching for composite projects in &lt;code&gt;--build --watch&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--build --watch&lt;/code&gt; 複合プロジェクトの増分ファイル監視</target>
        </trans-unit>
        <trans-unit id="5eccb92925bc3929eabb42f52bbdf91059031375" translate="yes" xml:space="preserve">
          <source>Index types</source>
          <target state="translated">インデックスの種類</target>
        </trans-unit>
        <trans-unit id="0b06669b4c136bdf3d1ec21cafd1d15df80fad00" translate="yes" xml:space="preserve">
          <source>Index types and index signatures</source>
          <target state="translated">索引タイプと索引署名</target>
        </trans-unit>
        <trans-unit id="aaf103e4bce1dd95f1b6e037cb4cf33238541524" translate="yes" xml:space="preserve">
          <source>Indexable Types</source>
          <target state="translated">インデックス可能なタイプ</target>
        </trans-unit>
        <trans-unit id="3260fe038f2a1e9f4a6bf5d1a731cf910deb01de" translate="yes" xml:space="preserve">
          <source>Inference from mapped types</source>
          <target state="translated">マッピングされた型からの推論</target>
        </trans-unit>
        <trans-unit id="72e097bb1e3bc0e862f9bef6c7816dfc1cfe0932" translate="yes" xml:space="preserve">
          <source>Inferring the types</source>
          <target state="translated">タイプを推測する</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="29c771a275b4fc168c6e9a9b4f16f9f866101cf5" translate="yes" xml:space="preserve">
          <source>Initialize the project</source>
          <target state="translated">プロジェクトを初期化する</target>
        </trans-unit>
        <trans-unit id="0223edbd4b306241485da6ea36e04c5f73dc76b6" translate="yes" xml:space="preserve">
          <source>Initializes a TypeScript project and creates a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">TypeScriptプロジェクトを初期化し、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="d40721226c9107841a5c9b9ca80d5a8dfbb2c0d8" translate="yes" xml:space="preserve">
          <source>Initializing an object with dynamic properties can be a bit of a burden. Take the following example:</source>
          <target state="translated">動的プロパティでオブジェクトを初期化するのは少し面倒です。 以下の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="48ea5eb348b8b2f027b76b2af44bc6ce31c449b9" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; section of the &lt;code&gt;package.json&lt;/code&gt; file, add &lt;em&gt;gulp&lt;/em&gt; and &lt;em&gt;del&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;package.json&lt;/code&gt; package.jsonファイルの &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; セクション、 gulpおよび&lt;em&gt;delを&lt;/em&gt;追加します</target>
        </trans-unit>
        <trans-unit id="fd6c3ebf7befca9f8208f86c76e4d4180303745c" translate="yes" xml:space="preserve">
          <source>Install</source>
          <target state="translated">Install</target>
        </trans-unit>
        <trans-unit id="e922164fa8e7b23fe5db7d0703923eff79dbef32" translate="yes" xml:space="preserve">
          <source>Install ASP.NET Core and TypeScript</source>
          <target state="translated">ASP.NET CoreとTypeScriptをインストールする</target>
        </trans-unit>
        <trans-unit id="1e48e8ef34685eb17d478c13cfd199caadcb3708" translate="yes" xml:space="preserve">
          <source>Install our dependencies</source>
          <target state="translated">依存関係をインストールする</target>
        </trans-unit>
        <trans-unit id="e371877bb54c12671888c28362c3b32432ec40a5" translate="yes" xml:space="preserve">
          <source>Installing TypeScript</source>
          <target state="translated">TypeScriptをインストールする</target>
        </trans-unit>
        <trans-unit id="98a0fba8620f4d80c37344d00d25fe24a9d88fbd" translate="yes" xml:space="preserve">
          <source>InstanceType&amp;lt;T&amp;gt;</source>
          <target state="translated">InstanceType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ef07ef5ff526694802527d041e5b29af71c04bd8" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;Object&lt;/code&gt;, use the non-primitive &lt;code&gt;object&lt;/code&gt; type (&lt;a href=&quot;../release-notes/typescript-2-2#object-type&quot;&gt;added in TypeScript 2.2&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; の代わりに非プリミティブ &lt;code&gt;object&lt;/code&gt; タイプ（ &lt;a href=&quot;../release-notes/typescript-2-2#object-type&quot;&gt;TypeScript 2.2で追加&lt;/a&gt; ）を使用します。</target>
        </trans-unit>
        <trans-unit id="ee6363c045a14fb760ecdd97fa1210a76455315e" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;any&lt;/code&gt;, we can use a &lt;em&gt;union type&lt;/em&gt; for the &lt;code&gt;padding&lt;/code&gt; parameter:</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; の代わりに、 &lt;code&gt;padding&lt;/code&gt; パラメータに&lt;em&gt;ユニオン型&lt;/em&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="d1fdeb6abb8961fb107ac368ef09e36ad9963ee3" translate="yes" xml:space="preserve">
          <source>Instead of a relatively useless type like &lt;code&gt;(x: {}) =&amp;gt; Box&amp;lt;{}[]&amp;gt;&lt;/code&gt;, which older versions of the language would infer, TypeScript 3.4&amp;rsquo;s inference allows &lt;code&gt;newFn&lt;/code&gt; to be generic. Its new type is &lt;code&gt;&amp;lt;T&amp;gt;(x: T) =&amp;gt; Box&amp;lt;T[]&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">古いバージョンの言語によって推論される &lt;code&gt;(x: {}) =&amp;gt; Box&amp;lt;{}[]&amp;gt;&lt;/code&gt; などの比較的役に立たないタイプの代わりに、 &lt;code&gt;newFn&lt;/code&gt; はTypeScript 3.4推論でジェネリックにすることができます。 新しいタイプは &lt;code&gt;&amp;lt;T&amp;gt;(x: T) =&amp;gt; Box&amp;lt;T[]&amp;gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f41af89aee0ce0aa8f256c662d27ad424fd39973" translate="yes" xml:space="preserve">
          <source>Instead of working with any and all types, we&amp;rsquo;d like to constrain this function to work with any and all types that also have the &lt;code&gt;.length&lt;/code&gt; property. As long as the type has this member, we&amp;rsquo;ll allow it, but it&amp;rsquo;s required to have at least this member. To do so, we must list our requirement as a constraint on what T can be.</source>
          <target state="translated">すべての型を処理する代わりに、この関数を制限して、 &lt;code&gt;.length&lt;/code&gt; プロパティも持つすべての型を処理するようにします。 タイプにこのメンバーがある限り許可されますが、少なくともこのメンバーが必要です。 そのためには、要件をTの制約としてリストする必要があります。</target>
        </trans-unit>
        <trans-unit id="9e88339b09438dc6ef45500af5364169862881c3" translate="yes" xml:space="preserve">
          <source>Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a &lt;em&gt;type variable&lt;/em&gt;, a special kind of variable that works on types rather than values.</source>
          <target state="translated">代わりに、返されるものを示すために使用できるように、引数のタイプをキャプチャする方法が必要です。 ここでは、 &lt;em&gt;型変数&lt;/em&gt;を使用し&lt;em&gt;ます&lt;/em&gt; 。これは、値ではなく型で機能する特別な種類の変数です。</target>
        </trans-unit>
        <trans-unit id="877c391d483e3da8842226931c49930770980487" translate="yes" xml:space="preserve">
          <source>Instead, we need to pass in values whose type has all the required properties:</source>
          <target state="translated">代わりに、そのタイプに必要なすべてのプロパティを持つ値を渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="01593ae1a34a1c7e14f63f2874056a43c2031680" translate="yes" xml:space="preserve">
          <source>Instead, you would need to work with the static side of the class directly. In this example, we define two interfaces, &lt;code&gt;ClockConstructor&lt;/code&gt; for the constructor and &lt;code&gt;ClockInterface&lt;/code&gt; for the instance methods. Then, for convenience, we define a constructor function &lt;code&gt;createClock&lt;/code&gt; that creates instances of the type that is passed to it:</source>
          <target state="translated">代わりに、クラスの静的な側で直接作業する必要があります。 この例では、コンストラクター &lt;code&gt;ClockConstructor&lt;/code&gt; とインスタンスメソッド &lt;code&gt;ClockInterface&lt;/code&gt; の 2つのインターフェースを定義しています。 次に、便宜上、渡された型のインスタンスを作成するコンストラクター関数 &lt;code&gt;createClock&lt;/code&gt; を定義します。</target>
        </trans-unit>
        <trans-unit id="e3192428f7f4fc6017fd4b426dc0b119b5a30e14" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools</source>
          <target state="translated">ビルドツールとの統合</target>
        </trans-unit>
        <trans-unit id="22212097f0e33b11964a53f929fec73cee63a40c" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Babel</source>
          <target state="translated">ビルドツールとの統合：Babel</target>
        </trans-unit>
        <trans-unit id="9dbaa1369f5ee20cc334fa494b2df4b92581aa4c" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Browserify</source>
          <target state="translated">ビルドツールとの統合：Browserify</target>
        </trans-unit>
        <trans-unit id="3ec7ffbef629ea76ad15ce276ed9ecdb2cc592e5" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Duo</source>
          <target state="translated">ビルドツールとの統合：Duo</target>
        </trans-unit>
        <trans-unit id="fbba0594dd61ce66de3d77f11bfcd50051321332" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Grunt</source>
          <target state="translated">ビルドツールとの統合：Grunt</target>
        </trans-unit>
        <trans-unit id="ffe5a64fcf1dd3fb7dd23d6ac3c6b86ef5e5925e" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Gulp</source>
          <target state="translated">ビルドツールとの統合：Gulp</target>
        </trans-unit>
        <trans-unit id="aa266b141c65598c72592d75b9246ecc79078e35" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Jspm</source>
          <target state="translated">ビルドツールとの統合：Jspm</target>
        </trans-unit>
        <trans-unit id="70482080c6efdc1c68f0832eaaf93423e1e5b273" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: MSBuild</source>
          <target state="translated">ビルドツールとの統合：MSBuild</target>
        </trans-unit>
        <trans-unit id="ab83f8abf8483dec13ed24ba6d2e9eb284f56ffa" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: NuGet</source>
          <target state="translated">ビルドツールとの統合：NuGet</target>
        </trans-unit>
        <trans-unit id="d40c6086bb9387a195dd8b229c344fef47424fa3" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Webpack</source>
          <target state="translated">ビルドツールとの統合：Webpack</target>
        </trans-unit>
        <trans-unit id="50c62dd2c72c526623cd3aa97cdf9e954ed24d3d" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA (Mac)</source>
          <target state="translated">IntelliJ IDEA（Mac）</target>
        </trans-unit>
        <trans-unit id="786f15960455f4c51ef85df82efd7a27a91dc1ba" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA (Windows)</source>
          <target state="translated">IntelliJ IDEA（Windows）</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="92daefb7ec0fc8b648c80aca28475265591e79ec" translate="yes" xml:space="preserve">
          <source>Interfaces Extending Classes</source>
          <target state="translated">クラスを拡張するインターフェース</target>
        </trans-unit>
        <trans-unit id="96e2b4ca11436e61acf1d8a96fcf247872f1b2ff" translate="yes" xml:space="preserve">
          <source>Interfaces are capable of describing the wide range of shapes that JavaScript objects can take. In addition to describing an object with properties, interfaces are also capable of describing function types.</source>
          <target state="translated">インターフェイスは、JavaScriptオブジェクトが取ることができるさまざまな形状を記述することができます。 プロパティを使用してオブジェクトを記述することに加えて、インターフェイスは関数タイプを記述することもできます。</target>
        </trans-unit>
        <trans-unit id="1182e7a77aad9fb1ced581374b610320fa4806c8" translate="yes" xml:space="preserve">
          <source>Interfaces describe the public side of the class, rather than both the public and private side. This prohibits you from using them to check that a class also has particular types for the private side of the class instance.</source>
          <target state="translated">インターフェイスは、パブリック側とプライベート側の両方ではなく、クラスのパブリック側を記述します。 これにより、クラスを使用して、クラスがクラスインスタンスのプライベート側にも特定の型を持つようにすることができなくなります。</target>
        </trans-unit>
        <trans-unit id="296b5977caa1cbec518b7e75c1da7e2fd0eaa696" translate="yes" xml:space="preserve">
          <source>Interfaces vs. Type Aliases</source>
          <target state="translated">インターフェイスと型エイリアス</target>
        </trans-unit>
        <trans-unit id="54fe00f4a20d8d06ce299185a910049d83b48bdd" translate="yes" xml:space="preserve">
          <source>Interfaces with optional properties are written similar to other interfaces, with each optional property denoted by a &lt;code&gt;?&lt;/code&gt; at the end of the property name in the declaration.</source>
          <target state="translated">オプションのプロパティを持つインターフェイスは、他のインターフェイスと同様に説明され、各オプションのプロパティが表示されます。 宣言内のプロパティ名の終わり。</target>
        </trans-unit>
        <trans-unit id="ef35fc41614978724e53f8c707770be7d1309ab3" translate="yes" xml:space="preserve">
          <source>Intersection Types</source>
          <target state="translated">交差点タイプ</target>
        </trans-unit>
        <trans-unit id="b87d8878892520ebb9edc358d8dd9e3d44011f0c" translate="yes" xml:space="preserve">
          <source>Intersection types</source>
          <target state="translated">交差点タイプ</target>
        </trans-unit>
        <trans-unit id="c8bf0e8c1ae3e60a82098f1409f6db85661db7a9" translate="yes" xml:space="preserve">
          <source>Intrinsic elements</source>
          <target state="translated">組み込み要素</target>
        </trans-unit>
        <trans-unit id="f97123626594d771751041a210b6256d26fd2930" translate="yes" xml:space="preserve">
          <source>Intrinsic elements are looked up on the special interface &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;. By default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked. However, if this interface &lt;em&gt;is&lt;/em&gt; present, then the name of the intrinsic element is looked up as a property on the &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; interface. For example:</source>
          <target state="translated">組み込み要素は、特別なインターフェース &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; で検索されます。 デフォルトでは、このインターフェースが指定されていない場合、何も実行されず、組み込み要素は型チェックされません。 ただし、このインターフェイス&lt;em&gt;が&lt;/em&gt;存在する場合、組み込み要素の名前は、JSX.IntrinsicElementsインターフェイスのプロパティとしてのJSX.IntrinsicElementsです。 例えば：</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="92a605a41a1bfb9eec6573b6d10084310be8afb9" translate="yes" xml:space="preserve">
          <source>Introduction: Deep Dive</source>
          <target state="translated">はじめに：ディープダイブ</target>
        </trans-unit>
        <trans-unit id="88ac7b281daf4911d47c89c86d34416225280141" translate="yes" xml:space="preserve">
          <source>Introduction: Find and Install Declaration Files</source>
          <target state="translated">はじめに：宣言ファイルの検索とインストール</target>
        </trans-unit>
        <trans-unit id="4f8abbfcfad58ab5902f7d7dad80570ab5c1e9de" translate="yes" xml:space="preserve">
          <source>Introduction: Library Structures</source>
          <target state="translated">はじめに：ライブラリ構造</target>
        </trans-unit>
        <trans-unit id="be4e2ac8a7225060bbaf50e88cd4c64bbb2b91e0" translate="yes" xml:space="preserve">
          <source>Introduction: Publish to npm</source>
          <target state="translated">はじめに：npmに公開する</target>
        </trans-unit>
        <trans-unit id="d9cf5daf5910fcc22fa06cac1c556299707a4e15" translate="yes" xml:space="preserve">
          <source>Introduction: Sections</source>
          <target state="translated">はじめに：セクション</target>
        </trans-unit>
        <trans-unit id="9da99d0d81d3d8dfe82f617de62c7c013f3809b6" translate="yes" xml:space="preserve">
          <source>Introduction: Templates</source>
          <target state="translated">はじめに：テンプレート</target>
        </trans-unit>
        <trans-unit id="4744b3b706d889422bd89021c824c3afa8c9a741" translate="yes" xml:space="preserve">
          <source>Introduction: “Do”s and “Don’t”s</source>
          <target state="translated">はじめに：「はい」と「いいえ」</target>
        </trans-unit>
        <trans-unit id="3e7c599bec18d30837143fafc667da7bae8fb3ce" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;tsc&lt;/code&gt; twice incurs more startup time overhead</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; を 2回押すと起動時間が長くなります</target>
        </trans-unit>
        <trans-unit id="580856a132ab9d88e4420d07722840d0bee558f0" translate="yes" xml:space="preserve">
          <source>Invoking the compiler with &lt;code&gt;--alwaysStrict&lt;/code&gt; causes:</source>
          <target state="translated">&lt;code&gt;--alwaysStrict&lt;/code&gt; を使用してコンパイラーを呼び出すと、次のことが発生します。</target>
        </trans-unit>
        <trans-unit id="2aa2b4b449585e3cac683fe9949dde17f0c4900d" translate="yes" xml:space="preserve">
          <source>Invoking the compiler with &lt;code&gt;--traceResolution&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--traceResolution&lt;/code&gt; でコンパイラを--traceResolutionで</target>
        </trans-unit>
        <trans-unit id="95f0156bbb4c60fc06035b7f6f73dc250490e988" translate="yes" xml:space="preserve">
          <source>It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports.)</source>
          <target state="translated">また、スクリプト内でのみグローバル変数として使用できます。 （スクリプトはインポートまたはエクスポートのないファイルです。）</target>
        </trans-unit>
        <trans-unit id="a4a4a00d6a8d5c101bf84b8d87236b25e876e72f" translate="yes" xml:space="preserve">
          <source>It can also be used to create simple namespaces:</source>
          <target state="translated">また、単純な名前空間を作成するためにも使用できます。</target>
        </trans-unit>
        <trans-unit id="4806c2a5b8c0aca238175b098dcd2585b109419d" translate="yes" xml:space="preserve">
          <source>It does not have an initializer and the preceding enum member was a &lt;em&gt;numeric&lt;/em&gt; constant. In this case the value of the current enum member will be the value of the preceding enum member plus one.</source>
          <target state="translated">初期化子はなく、以前の列挙メンバーは&lt;em&gt;数値&lt;/em&gt;定数でした。 この場合、現在の列挙メンバーの値は、前の列挙メンバーに1を加えたものです。</target>
        </trans-unit>
        <trans-unit id="ae3a8ea5fd61fc3c908eab11fa4a4f9073d77d83" translate="yes" xml:space="preserve">
          <source>It is a common pattern to return the current object (i.e. &lt;code&gt;this&lt;/code&gt;) from a method to create &lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;fluent-style APIs&lt;/a&gt;. For instance, consider the following &lt;code&gt;BasicCalculator&lt;/code&gt; module:</source>
          <target state="translated">合理化されたスタイルのAPIを作成するメソッドから現在のオブジェクト（つまり、 &lt;code&gt;this&lt;/code&gt; ）を返すのは一般的なパターンです。 たとえば、次の &lt;code&gt;BasicCalculator&lt;/code&gt; モジュールを考えます。</target>
        </trans-unit>
        <trans-unit id="62ffe9a036a8fbf5b41aec16bc2aa0caa4f8a019" translate="yes" xml:space="preserve">
          <source>It is a compile time error for constant enum expressions to be evaluated to &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Infinity&lt;/code&gt;.</source>
          <target state="translated">定数列挙型が &lt;code&gt;NaN&lt;/code&gt; または &lt;code&gt;Infinity&lt;/code&gt; に評価されると、コンパイル時エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="99b3cb57ca8b4b1d02c5836ced85b9301080e00f" translate="yes" xml:space="preserve">
          <source>It is also worth noting that, for Node.js applications, modules are the default and the recommended approach to structure your code.</source>
          <target state="translated">Node.jsアプリケーションの場合、モジュールがデフォルトであり、コードを構造化するための推奨されるアプローチであることも注目に値します。</target>
        </trans-unit>
        <trans-unit id="f083343eb50dcd945be59c0708845b66b4753dc5" translate="yes" xml:space="preserve">
          <source>It is an error to reference a file that does not exist. It is an error for a file to have a triple-slash reference to itself.</source>
          <target state="translated">存在しないファイルを参照すると、エラーが発生します。 ファイルがそれ自体への三重スラッシュ参照を持つのはエラーです。</target>
        </trans-unit>
        <trans-unit id="3f74a022e24576b8bca3c7e9007ad3819041ef57" translate="yes" xml:space="preserve">
          <source>It is important to note that it is an error to call a function with too many arguments.</source>
          <target state="translated">引数が多すぎる関数を呼び出すとエラーになることに注意してください。</target>
        </trans-unit>
        <trans-unit id="be67ce2203241cd9f4ea1e5b61ef39e52b2d569c" translate="yes" xml:space="preserve">
          <source>It is important to note that the compiler will &lt;em&gt;not&lt;/em&gt; perform any of these transformations; it just uses these pieces of information to guide the process of resolving a module import to its definition file.</source>
          <target state="translated">コンパイラ&lt;em&gt;は&lt;/em&gt;これらの変換を実行&lt;em&gt;しない&lt;/em&gt;ことに注意することが重要です。 この情報を使用して、モジュールのインポートを定義ファイルに解決するプロセスをガイドします。</target>
        </trans-unit>
        <trans-unit id="1efd3564ec8a22d45891c5ad072535fbd6663440" translate="yes" xml:space="preserve">
          <source>It is not possible to use &lt;code&gt;infer&lt;/code&gt; declarations in constraint clauses for regular type parameters:</source>
          <target state="translated">&lt;code&gt;infer&lt;/code&gt; 宣言は、通常の型パラメーター制約句では使用できません。</target>
        </trans-unit>
        <trans-unit id="78ecb7e98034ba8c6a31702e1802139e82a8abee" translate="yes" xml:space="preserve">
          <source>It is possible to define the type of a class component. However, to do so it is best to understand two new terms: the &lt;em&gt;element class type&lt;/em&gt; and the &lt;em&gt;element instance type&lt;/em&gt;.</source>
          <target state="translated">クラスコンポーネントのタイプを定義することは可能です。 ただし、そうするためには、 &lt;em&gt;要素クラス型&lt;/em&gt;と&lt;em&gt;要素インスタンス型&lt;/em&gt;という2つの新しい用語を理解することが最善です。</target>
        </trans-unit>
        <trans-unit id="3393d397de3e56585237bbbf12b74b296eb1e0ea" translate="yes" xml:space="preserve">
          <source>It is the first member in the enum and it has no initializer, in which case it&amp;rsquo;s assigned the value &lt;code&gt;0&lt;/code&gt;:</source>
          <target state="translated">これは列挙型の最初のメンバーであり、初期化子はありません。 その場合、値 &lt;code&gt;0&lt;/code&gt; が割り当てられます。</target>
        </trans-unit>
        <trans-unit id="1f0bcd520e9a01c5bb05819edfd82f1aa74077c5" translate="yes" xml:space="preserve">
          <source>It is worth noting that if the npm package already includes its declaration file as described in &lt;a href=&quot;publishing&quot;&gt;Publishing&lt;/a&gt;, downloading the corresponding &lt;code&gt;@types&lt;/code&gt; package is not needed.</source>
          <target state="translated">Publishingで説明されているように、npmパッケージに宣言ファイルが既に含まれている&lt;a href=&quot;publishing&quot;&gt;場合&lt;/a&gt; 、対応する &lt;code&gt;@types&lt;/code&gt; パッケージをダウンロードする必要はありません。</target>
        </trans-unit>
        <trans-unit id="cf377c6233f3ae5de354c35e343aab9bdd355017" translate="yes" xml:space="preserve">
          <source>It just so happens that TypeScript has something called a &lt;em&gt;type guard&lt;/em&gt;. A type guard is some expression that performs a runtime check that guarantees the type in some scope.</source>
          <target state="translated">TypeScriptには、 &lt;em&gt;タイプガード&lt;/em&gt;と呼ばれるものがあります。 タイプガードは、スコープ内のタイプを保証するランタイムチェックを実行する式です。</target>
        </trans-unit>
        <trans-unit id="63c224c58a227f7ca3d5c83c05a2c04331b2b180" translate="yes" xml:space="preserve">
          <source>It was possible for the implementation files to import the test files</source>
          <target state="translated">実装ファイルはテストファイルをインポートできます</target>
        </trans-unit>
        <trans-unit id="32c6f037d7103d04bf695eff504eb483c338105a" translate="yes" xml:space="preserve">
          <source>It wasn&amp;rsquo;t possible to build &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; at the same time without having &lt;code&gt;src&lt;/code&gt; appear in the output folder name, which you probably don&amp;rsquo;t want</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; とsrcは、出力フォルダー名に &lt;code&gt;src&lt;/code&gt; を表示せずに同時にビルドできませんでした。</target>
        </trans-unit>
        <trans-unit id="dae1101862749291ae4f393bc2ced9ae6e2e1e04" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also common to try to access a method before &lt;code&gt;await&lt;/code&gt;-ing or &lt;code&gt;.then()&lt;/code&gt;-ing a &lt;code&gt;Promise&lt;/code&gt;. This is another example, among many others, where we&amp;rsquo;re able to do better.</source>
          <target state="translated">多くの場合、.then（）または.then（）promiseの前にメソッドにアクセスしようとします。 これは、他の多くの例の中でも、より良くできる別の例です。</target>
        </trans-unit>
        <trans-unit id="cb42ff8fbd52b3c44d6730e6b6e080e1b24c9119" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also important to note that TypeScript doesn&amp;rsquo;t transform references to &lt;code&gt;globalThis&lt;/code&gt; when compiling to older versions of ECMAScript. As such, unless you&amp;rsquo;re targeting evergreen browsers (which already support &lt;code&gt;globalThis&lt;/code&gt;), you may want to &lt;a href=&quot;https://github.com/ljharb/globalThis&quot;&gt;use an appropriate polyfill&lt;/a&gt; instead.</source>
          <target state="translated">ECMAScriptの古いバージョンにコンパイルする場合、TypeScriptは &lt;code&gt;globalThis&lt;/code&gt; への参照を変換しないことに注意することも重要です 。 したがって、 &lt;code&gt;globalThis&lt;/code&gt; サポートしている常緑のブラウザをターゲットにしている&lt;a href=&quot;https://github.com/ljharb/globalThis&quot;&gt;場合を除き&lt;/a&gt; 、代わりに適切なポリフィルを使用できます。</target>
        </trans-unit>
        <trans-unit id="e464e560c1d455645701c6f4e6f1a57f254a2a8d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s always nice to be able to document your configuration! &lt;code&gt;tsconfig.json&lt;/code&gt; now accepts single and multi-line comments.</source>
          <target state="translated">構成を文書化できることは常に素晴らしいことです！ &lt;code&gt;tsconfig.json&lt;/code&gt; は、単一行および複数行のコメントを受け入れるようになりました。</target>
        </trans-unit>
        <trans-unit id="4bd81a3c45eee4646f38cdbd9c1c1ad1a29861b2" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s an error to destructure a tuple beyond the range of its elements:</source>
          <target state="translated">要素の範囲を超えてタプルを非構造化すると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="8a9920985b571f2cfef7325bc2d8544e7b54739d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important in this situation to not prepend at each reference, because you&amp;rsquo;ll end up with two copies of &lt;code&gt;A&lt;/code&gt; in the output of &lt;code&gt;D&lt;/code&gt; - this can lead to unexpected results.</source>
          <target state="translated">この状況では、各参照を追加しないことが重要です。 これは、Aの2つのコピーが &lt;code&gt;D&lt;/code&gt; の出力で作成されるためです。 これにより、予期しない結果が生じる可能性があります。</target>
        </trans-unit>
        <trans-unit id="97ea9b1bc3713a2cc3d96cf61a87c436f5f16077" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that awesome-typescript-loader will need to run before any other loader that deals with &lt;code&gt;.js&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; ファイルを処理する他のローダーの前にawesome-typescript-loaderを実行する必要があることに注意することが重要です。</target>
        </trans-unit>
        <trans-unit id="ad109c65e3188cac84e48f320d15d4fae5d7f0a7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not uncommon for an API to expect a specific set of strings for certain values. For instance, consider a UI library that can move elements across the screen while controlling the &lt;a href=&quot;https://en.wikipedia.org/wiki/Inbetweening&quot;&gt;&amp;ldquo;easing&amp;rdquo; of the animation.&lt;/a&gt;</source>
          <target state="translated">APIが特定の値に特定の文字列セットを期待することは珍しくありません。 たとえば、アニメーションの「緩和」を制御しながら、画面上の要素を移動できるUIライブラリを考えます。</target>
        </trans-unit>
        <trans-unit id="1423913ba24c08e5752678ce9b4d9c6bc28a43a2" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth pointing out that the type checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type.</source>
          <target state="translated">型チェッカーはこれらのプロパティを任意の順序にする必要はなく、インターフェイスに必要なプロパティが存在し、必要な型を持っていることのみを指摘する価値があります。</target>
        </trans-unit>
        <trans-unit id="4dd80eea3f6c51bf5b9c13a8a47609bd55b30e0e" translate="yes" xml:space="preserve">
          <source>Iterables</source>
          <target state="translated">Iterables</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="203e9155620464a525f901cb5421a31b901a89ef" translate="yes" xml:space="preserve">
          <source>Iterators &amp;amp; Generators</source>
          <target state="translated">イテレーターとジェネレーター</target>
        </trans-unit>
        <trans-unit id="99b5cd227ff34de634e9717a978834aba820bbe5" translate="yes" xml:space="preserve">
          <source>Iterators and Generators</source>
          <target state="translated">イテレーターとジェネレーター</target>
        </trans-unit>
        <trans-unit id="36347e6c81d6767cb3d6230d14c1fc3fd3e5b4ee" translate="yes" xml:space="preserve">
          <source>JQuery.d.ts</source>
          <target state="translated">JQuery.d.ts</target>
        </trans-unit>
        <trans-unit id="e3449392ff6bd7faf1750366c59ea9d2cae9f435" translate="yes" xml:space="preserve">
          <source>JSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax to express optionality. e.g.:</source>
          <target state="translated">JSDoc注釈付き関数は、この規則の対象外です。 オプションを表すには、JSDocオプションパラメーター構文を使用します。 例えば：</target>
        </trans-unit>
        <trans-unit id="a992571945b4a5c87d6bf56acece269e2c17f9ae" translate="yes" xml:space="preserve">
          <source>JSDoc annotations adorning a declaration will be used to set the type of that declaration. For example:</source>
          <target state="translated">宣言を修飾するJSDoc注釈は、宣言のタイプを設定するために使用されます。 例えば：</target>
        </trans-unit>
        <trans-unit id="56567b264de0a6e662152c49ade304ca30e42a64" translate="yes" xml:space="preserve">
          <source>JSDoc types are used for type information</source>
          <target state="translated">JSDocタイプはタイプ情報に使用されます</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="c9a7b3c3bca23e176771346061c84e126c239c19" translate="yes" xml:space="preserve">
          <source>JSX allows you to embed expressions between tags by surrounding the expressions with curly braces (&lt;code&gt;{ }&lt;/code&gt;).</source>
          <target state="translated">JSXでは、式を中括弧（ &lt;code&gt;{ }&lt;/code&gt; ）で囲むことにより、タグ間に式を埋め込むことができます。</target>
        </trans-unit>
        <trans-unit id="39068335c89e9baa8ee40bd585e128fbed44107c" translate="yes" xml:space="preserve">
          <source>JSX element names and properties are validated against the &lt;code&gt;JSX&lt;/code&gt; namespace. Please see the [[JSX]] wiki page for defining the &lt;code&gt;JSX&lt;/code&gt; namespace for your framework.</source>
          <target state="translated">JSXの要素名とプロパティは、 &lt;code&gt;JSX&lt;/code&gt; 名前空間に対して検証されます。 フレームワークの &lt;code&gt;JSX&lt;/code&gt; 名前空間の定義については、[[JSX]] wikiページをご覧ください。</target>
        </trans-unit>
        <trans-unit id="c00129d0a4abfd5ac94250f0271eb16efd1bd3c7" translate="yes" xml:space="preserve">
          <source>JSX elements now allow passing type arguments to generic components.</source>
          <target state="translated">JSX要素は、タイプ引数を汎用コンポーネントに渡すことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="18de8f2d2e7d3ab6aeff186b905d5c34cc12e52a" translate="yes" xml:space="preserve">
          <source>JSX is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, but the semantics of that transformation are implementation-specific. JSX came to popularity with the React library but has since seen other applications. TypeScript 1.6 supports embedding, type checking, and optionally compiling JSX directly into JavaScript.</source>
          <target state="translated">JSXは、埋め込み可能なXMLに似た構文です。 有効なJavaScriptに変換することを目的としていますが、変換のセマンティクスは実装固有です。 JSXはReactライブラリで人気を博しましたが、それ以来他のアプリケーションを見てきました。 TypeScript 1.6は、埋め込み、型チェック、およびオプションでJSXを直接JavaScriptにコンパイルすることをサポートしています。</target>
        </trans-unit>
        <trans-unit id="35be1251a23e865870550e0bb93b3a161d7ed6f9" translate="yes" xml:space="preserve">
          <source>JSX support</source>
          <target state="translated">JSXサポート</target>
        </trans-unit>
        <trans-unit id="96d35d103f80b8423a542d0896d9282bfecda177" translate="yes" xml:space="preserve">
          <source>JSX type checking is driven by definitions in a JSX namespace, for instance &lt;code&gt;JSX.Element&lt;/code&gt; for the type of a JSX element, and &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; for built-in elements. Before TypeScript 2.8 the &lt;code&gt;JSX&lt;/code&gt; namespace was expected to be in the global namespace, and thus only allowing one to be defined in a project. Starting with TypeScript 2.8 the &lt;code&gt;JSX&lt;/code&gt; namespace will be looked under the &lt;code&gt;jsxNamespace&lt;/code&gt; (e.g. &lt;code&gt;React&lt;/code&gt;) allowing for multiple jsx factories in one compilation. For backward compatibility the global &lt;code&gt;JSX&lt;/code&gt; namespace is used as a fallback if none was defined on the factory function. Combined with the per-file &lt;code&gt;@jsx&lt;/code&gt; pragma, each file can have a different JSX factory.</source>
          <target state="translated">JSXタイプのチェックは、JSX名前空間の定義、たとえばJSX要素タイプ &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; および組み込み要素 &lt;code&gt;JSX.Element&lt;/code&gt; によって駆動されます。 TypeScript 2.8より前は、 &lt;code&gt;JSX&lt;/code&gt; 名前空間はグローバル名前空間にあると想定されていたため、プロジェクトで定義できるのは1つだけです。 TypeScript 2.8以降では、 &lt;code&gt;JSX&lt;/code&gt; 名前空間は &lt;code&gt;jsxNamespace&lt;/code&gt; （ &lt;code&gt;React&lt;/code&gt; など ）の下に表示されるため、1回のコンパイルで複数のjsxファクトリーを使用できます。 後方互換性のために、ファクトリ関数で何も定義されていない場合、グローバル &lt;code&gt;JSX&lt;/code&gt; 名前空間がフォールバックとして使用されます。 &lt;code&gt;@jsx&lt;/code&gt; プラグマファイルを持つ@jsx、各ファイルには異なるJSXファクトリを含めることができます。</target>
        </trans-unit>
        <trans-unit id="5814b75aeb763bc1d09322412eaf957f2d26543e" translate="yes" xml:space="preserve">
          <source>JavaScript has a lot of different module syntaxes or conventions: the one in the ECMAScript standard, the one Node already supports (CommonJS), AMD, System.js, and more! For the most part, TypeScript would default to auto-importing using ECMAScript module syntax, which was often inappropriate in certain TypeScript projects with different compiler settings, or in Node projects with plain JavaScript and &lt;code&gt;require&lt;/code&gt; calls.</source>
          <target state="translated">JavaScriptには、ECMAScript標準モジュール、Nodeが既にサポートしている（CommonJS）、AMD、System.jsなど、さまざまなモジュール構文または規則があります！ ほとんどの場合、TypeScriptはデフォルトでECMAScriptモジュール構文を使用して自動的にインポートします。 これは、コンパイラ設定が異なる特定のTypeScriptプロジェクト、またはプレーンなJavaScriptを使用して呼び出しを &lt;code&gt;require&lt;/code&gt; とするNodeプロジェクトには不適切な場合があります。</target>
        </trans-unit>
        <trans-unit id="6de0d5c33105af7de987fd16c4c5f05a9230e4fc" translate="yes" xml:space="preserve">
          <source>JavaScript is inherently a very dynamic language. It&amp;rsquo;s not uncommon for a single JavaScript function to return different types of objects based on the shape of the arguments passed in.</source>
          <target state="translated">JavaScriptは、定義上、非常に動的な言語です。 1つのJavaScript関数が、渡された引数の形状に基づいて異なるタイプのオブジェクトを返すことは珍しくありません。</target>
        </trans-unit>
        <trans-unit id="7196497deb2208abcd944f2734a4a8cd07bbe990" translate="yes" xml:space="preserve">
          <source>Jspm</source>
          <target state="translated">Jspm</target>
        </trans-unit>
        <trans-unit id="a2fb0be4963908fbe076c5e18c4d463d46dfdc5e" translate="yes" xml:space="preserve">
          <source>Just as &amp;ldquo;exporting near the top-level&amp;rdquo; reduces friction on your module&amp;rsquo;s consumers, so does introducing a default export. If a module&amp;rsquo;s primary purpose is to house one specific export, then you should consider exporting it as a default export. This makes both importing and actually using the import a little easier. For example:</source>
          <target state="translated">「Export Near Top」は、デフォルトのエクスポートを導入し、モジュールの消費者の摩擦を減らします。 モジュールの主な目的が1つの特定のエクスポートに対応することである場合、エクスポートをデフォルトのエクスポートとして検討する必要があります。 これにより、インポートとインポートの使用が少し簡単になります。 例えば：</target>
        </trans-unit>
        <trans-unit id="d035ba479610b88ab3f44fd6721d6d5b47bab897" translate="yes" xml:space="preserve">
          <source>Just as in JavaScript, functions can refer to variables outside of the function body. When they do so, they&amp;rsquo;re said to &lt;em&gt;capture&lt;/em&gt; these variables. While understanding how this works (and the trade-offs when using this technique) is outside of the scope of this article, having a firm understanding how this mechanic works is an important piece of working with JavaScript and TypeScript.</source>
          <target state="translated">JavaScriptと同様に、関数は関数本体の外部の変数を参照できます。 次に、これらの変数を&lt;em&gt;キャプチャする&lt;/em&gt;ように指示されます。 これがどのように機能するか（およびこの手法を使用する場合のトレードオフ）を理解することはこの記事の範囲を超えていますが、このメカニズムがどのように機能するかを十分に理解することはJavaScriptとTypeScriptです 対処の重要な部分です</target>
        </trans-unit>
        <trans-unit id="e42c4ea3c8c69c9835a8ffa699912e1dc17b476c" translate="yes" xml:space="preserve">
          <source>Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it&amp;rsquo;s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can&amp;rsquo;t use the &lt;code&gt;outFile&lt;/code&gt; option while targeting &lt;code&gt;commonjs&lt;/code&gt; or &lt;code&gt;umd&lt;/code&gt;, but with TypeScript 1.8 and later, &lt;a href=&quot;release-notes/typescript-1-8#concatenate-amd-and-system-modules-with---outfile&quot;&gt;it&amp;rsquo;s possible&lt;/a&gt; to use &lt;code&gt;outFile&lt;/code&gt; when targeting &lt;code&gt;amd&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">JSファイルとモジュールの間に1対1の対応があるように、TypeScriptにはモジュールソースファイルと公開されたJSファイルの間に1対1の対応があります。 これの1つの効果は、ターゲットモジュールシステムによっては、複数のモジュールソースファイルを連結できないことです。 たとえば、 &lt;code&gt;commonjs&lt;/code&gt; または &lt;code&gt;umd&lt;/code&gt; を対象とする場合は &lt;code&gt;outFile&lt;/code&gt; オプションを使用できませんが、TypeScript 1.8以降で &lt;code&gt;amd&lt;/code&gt; または &lt;code&gt;system&lt;/code&gt; を対象とする場合は &lt;code&gt;outFile&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="f2ceed31b51e352f32e51cd21fbc2af5be43b412" translate="yes" xml:space="preserve">
          <source>Just as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type.</source>
          <target state="translated">インターフェイスと同様に、クラス自体にtypeパラメーターを設定して、クラスのすべてのプロパティが同じタイプで機能するようにすることができます。</target>
        </trans-unit>
        <trans-unit id="3d37f6d0d224175d9c14bf98baa6ad7248f29798" translate="yes" xml:space="preserve">
          <source>Just like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application.</source>
          <target state="translated">すべてのグローバル名前空間の汚染と同様に、特に大規模なアプリケーションでは、コンポーネントの依存関係を特定することは困難です。</target>
        </trans-unit>
        <trans-unit id="a2f08fadea784d51622be345d4e8e8eadd88d668" translate="yes" xml:space="preserve">
          <source>Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:</source>
          <target state="translated">インターフェイスと同様に、型エイリアスは汎用的です。 型パラメーターを追加し、エイリアス宣言の右側で使用します。</target>
        </trans-unit>
        <trans-unit id="025c330d74702a4acd5017db2925ef6790f2b67b" translate="yes" xml:space="preserve">
          <source>Just like namespaces, modules can contain both code and declarations. The main difference is that modules &lt;em&gt;declare&lt;/em&gt; their dependencies.</source>
          <target state="translated">名前空間と同様に、モジュールにはコードと宣言の両方を含めることができます。 主な違いは、モジュール&lt;em&gt;が&lt;/em&gt;依存関係を&lt;em&gt;宣言する&lt;/em&gt;ことです。</target>
        </trans-unit>
        <trans-unit id="40539a34306df46457893cadb44a5176185146b1" translate="yes" xml:space="preserve">
          <source>Just like strings, symbols can be used as keys for object properties.</source>
          <target state="translated">文字列と同様に、シンボルはオブジェクトプロパティのキーとして使用できます。</target>
        </trans-unit>
        <trans-unit id="accadaa2de1d9b54d08912507fc259d22f1d0931" translate="yes" xml:space="preserve">
          <source>Just run:</source>
          <target state="translated">ただ走れ：</target>
        </trans-unit>
        <trans-unit id="125f418dffdfd3ad4877030138769ad27527fedf" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; will be turned on along with other &lt;code&gt;--strict&lt;/code&gt; mode flags, which can impact your project. You can set the &lt;code&gt;strictPropertyInitialization&lt;/code&gt; setting to &lt;code&gt;false&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt;&amp;rsquo;s &lt;code&gt;compilerOptions&lt;/code&gt;, or &lt;code&gt;--strictPropertyInitialization false&lt;/code&gt; on the command line to turn off this checking.</source>
          <target state="translated">&lt;code&gt;--strictPropertyInitialization&lt;/code&gt; は他の &lt;code&gt;--strict&lt;/code&gt; モードフラグと一緒にオンになり、プロジェクトに影響する可能性があることに注意してください。 このチェックをオフにするには、 &lt;code&gt;strictPropertyInitialization&lt;/code&gt; 設定を &lt;code&gt;false&lt;/code&gt; に設定するか、コマンドラインで &lt;code&gt;--strictPropertyInitialization false&lt;/code&gt; を設定します 。</target>
        </trans-unit>
        <trans-unit id="0abfd4d342104dbd9ec0e7580639c9a4652da4fe" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;?.&lt;/code&gt; acts differently than those &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operations since &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; will act specially on &amp;ldquo;falsy&amp;rdquo; values (e.g. the empty string, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt;, and, well, &lt;code&gt;false&lt;/code&gt;), but this is an intentional feature of the construct. It doesn&amp;rsquo;t short-circuit on valid data like &lt;code&gt;0&lt;/code&gt; or empty strings.</source>
          <target state="translated">&lt;code&gt;?.&lt;/code&gt; 注意してください。 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; はこれらの &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 操作とは異なります。これは、&amp;amp;&amp;amp;が特別に「偽の」値に作用するためです（たとえば、空の文字列、 &lt;code&gt;0&lt;/code&gt; 、 &lt;code&gt;NaN&lt;/code&gt; 、およびwell、 &lt;code&gt;false&lt;/code&gt; ）。これは構造の意図的な機能です。 &lt;code&gt;0&lt;/code&gt; や空の文字列などの有効なデータは、短絡しません。</target>
        </trans-unit>
        <trans-unit id="e08badd7e94b5e92e8e60fc455f43139d018f482" translate="yes" xml:space="preserve">
          <source>Keep in mind that automatic inclusion is only important if you&amp;rsquo;re using files with global declarations (as opposed to files declared as modules). If you use an &lt;code&gt;import &quot;foo&quot;&lt;/code&gt; statement, for instance, TypeScript may still look through &lt;code&gt;node_modules&lt;/code&gt; &amp;amp; &lt;code&gt;node_modules/@types&lt;/code&gt; folders to find the &lt;code&gt;foo&lt;/code&gt; package.</source>
          <target state="translated">（モジュールとして宣言されたファイルではなく）グローバル宣言を持つファイルを使用している場合にのみ、自動インクルードが重要であることに注意してください。 たとえば、 &lt;code&gt;import &quot;foo&quot;&lt;/code&gt; ステートメントを使用する場合、TypeScriptは &lt;code&gt;node_modules&lt;/code&gt; および &lt;code&gt;node_modules/@types&lt;/code&gt; フォルダーを使用して &lt;code&gt;foo&lt;/code&gt; パッケージを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="268830906a0177b0c9a669ca7e3cb1faf3ef7c1b" translate="yes" xml:space="preserve">
          <source>Keep in mind that for simple code like above, you probably shouldn&amp;rsquo;t be trying to &amp;ldquo;get around&amp;rdquo; these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs. That means if you&amp;rsquo;re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it&amp;rsquo;s okay to pass an object with both a &lt;code&gt;color&lt;/code&gt; or &lt;code&gt;colour&lt;/code&gt; property to &lt;code&gt;createSquare&lt;/code&gt;, you should fix up the definition of &lt;code&gt;SquareConfig&lt;/code&gt; to reflect that.</source>
          <target state="translated">上記のような単純なコードの場合、これらのチェックを「バイパス」しないでください。 メソッドを持ち、状態を維持するより複雑なオブジェクトリテラルの場合、これらのテクニックを念頭に置く必要がありますが、過剰なプロパティエラーのほとんどは実際にはバグです。 これは、オプションバッグなどのプロパティチェックの問題が過剰に発生した場合、一部の型宣言を変更する必要があることを意味します。 この場合、 &lt;code&gt;color&lt;/code&gt; と &lt;code&gt;colour&lt;/code&gt; 両方のプロパティを持つオブジェクトを &lt;code&gt;createSquare&lt;/code&gt; に渡すのがcreateSquareである場合、それを反映するように &lt;code&gt;SquareConfig&lt;/code&gt; 定義を変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="f6bddc5a736f8d59d17afc0337ba7f62d7baf26b" translate="yes" xml:space="preserve">
          <source>Keep in mind that our support for async iterators relies on support for &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; to exist at runtime. You may need to polyfill &lt;code&gt;Symbol.asyncIterator&lt;/code&gt;, which for simple purposes can be as simple as: &lt;code&gt;(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for(&quot;Symbol.asyncIterator&quot;);&lt;/code&gt;</source>
          <target state="translated">非同期イテレータのサポートは、実行時に存在する &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; のサポートに依存することに注意してください。 &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; からSymbol.asyncIteratorからSymbol.asyncIteratorにできます。 これは単純な目的のために単純化できます：（ &lt;code&gt;(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for(&quot;Symbol.asyncIterator&quot;);&lt;/code&gt; Symbol.for（ &quot;Symbol.asyncIterator&quot;）; Symbol.for（ &quot;Symbol.asyncIterator&quot;）;</target>
        </trans-unit>
        <trans-unit id="f0ee6543e6ec698fd6b6185b09f38eac28c9b2e1" translate="yes" xml:space="preserve">
          <source>Keep in mind that string enum members &lt;em&gt;do not&lt;/em&gt; get a reverse mapping generated at all.</source>
          <target state="translated">文字列列挙型メンバー&lt;em&gt;は&lt;/em&gt; 、逆マッピングを生成&lt;em&gt;し&lt;/em&gt;ないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="629873668f1873eae0d44964937115d6002d3f50" translate="yes" xml:space="preserve">
          <source>Keep outdated console output in watch mode instead of clearing the screen</source>
          <target state="translated">画面をクリアするのではなく、監視モードで古いコンソール出力を保持する</target>
        </trans-unit>
        <trans-unit id="a22c16410dc4eafc94fbc317a11af2903d7b50a3" translate="yes" xml:space="preserve">
          <source>Key Concepts</source>
          <target state="translated">キーコンセプト</target>
        </trans-unit>
        <trans-unit id="eaf7e256a5a476287d569594d43c22027adc861c" translate="yes" xml:space="preserve">
          <source>Lastly, we create a helper function that will do the mixing for us. This will run through the properties of each of the mixins and copy them over to the target of the mixins, filling out the stand-in properties with their implementations.</source>
          <target state="translated">最後に、ミキシングを行うヘルパー関数を作成します。 これにより、各ミックスインのプロパティが実行され、それらがミックスインターゲットにコピーされ、実装に代わってプロパティが設定されます。</target>
        </trans-unit>
        <trans-unit id="0deb513412e10426cc0e13efd7af25f69b12a4e1" translate="yes" xml:space="preserve">
          <source>Lay out the project</source>
          <target state="translated">プロジェクトをレイアウトする</target>
        </trans-unit>
        <trans-unit id="0fd2852022c2c1345c56213c485ff5c6c7b31b62" translate="yes" xml:space="preserve">
          <source>Layout for compilations using &lt;code&gt;outFile&lt;/code&gt; is more flexible because relative paths don&amp;rsquo;t matter as much. One thing to keep in mind is that you&amp;rsquo;ll generally want to not use &lt;code&gt;prepend&lt;/code&gt; until the &amp;ldquo;last&amp;rdquo; project - this will improve build times and reduce the amount of I/O needed in any given build. The TypeScript repo itself is a good reference here - we have some &amp;ldquo;library&amp;rdquo; projects and some &amp;ldquo;endpoint&amp;rdquo; projects; &amp;ldquo;endpoint&amp;rdquo; projects are kept as small as possible and pull in only the libraries they need.</source>
          <target state="translated">相対パスはそれほど重要ではないため、 &lt;code&gt;outFile&lt;/code&gt; を使用したコンパイルのレイアウトはより柔軟です。 覚えておくべきことの1つは、一般に「最後の」プロジェクトまで &lt;code&gt;prepend&lt;/code&gt; を使用しないことです。 これにより、ビルド時間が短縮され、ビルドに必要なI / Oの量が削減されます。 ここでは、TypeScriptリポジトリ自体が役立ちます。 いくつかの「ライブラリ」プロジェクトと「エンドポイント」プロジェクトがあります。 「エンドポイント」プロジェクトは可能な限り小さく保たれ、必要なライブラリのみをキャプチャします。</target>
        </trans-unit>
        <trans-unit id="6bb28e55ee1d62a9d6d258deae5c6e572957f877" translate="yes" xml:space="preserve">
          <source>Learning how to use &lt;code&gt;this&lt;/code&gt; in JavaScript is something of a rite of passage. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use &lt;code&gt;this&lt;/code&gt; and how to spot when it&amp;rsquo;s not being used correctly. Fortunately, TypeScript lets you catch incorrect uses of &lt;code&gt;this&lt;/code&gt; with a couple of techniques. If you need to learn how &lt;code&gt;this&lt;/code&gt; works in JavaScript, though, first read Yehuda Katz&amp;rsquo;s &lt;a href=&quot;http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;Understanding JavaScript Function Invocation and &amp;ldquo;this&amp;rdquo;&lt;/a&gt;. Yehuda&amp;rsquo;s article explains the inner workings of &lt;code&gt;this&lt;/code&gt; very well, so we&amp;rsquo;ll just cover the basics here.</source>
          <target state="translated">JavaScriptで &lt;code&gt;this&lt;/code&gt; を使用する方法を学ぶことは、通過儀礼のようなものです。 TypeScriptはJavaScriptのスーパーセットであるため、TypeScript開発者は &lt;code&gt;this&lt;/code&gt; を使用する方法と、誤って使用された場合にそれを見つける方法を学ぶ必要もあります。 幸いなことに、TypeScriptを使用すると、 &lt;code&gt;this&lt;/code&gt; 誤用を検出するためのいくつかの手法を使用できます。 ただし、 &lt;a href=&quot;http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;JavaScript&lt;/a&gt;で &lt;code&gt;this&lt;/code&gt; がどのように機能するかを学習する必要がある場合は、まずYehuda KatzのJavaScript関数呼び出しの理解と「this」をお読みください。 Yehudaの記事は、内部の仕組みを非常によく説明しているため、ここでは基本だけを説明します。</target>
        </trans-unit>
        <trans-unit id="d19ec9c75f791d8e76b8abbb3fa24159df758f91" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add a couple of interfaces to our example above, &lt;code&gt;Card&lt;/code&gt; and &lt;code&gt;Deck&lt;/code&gt;, to make the types clearer and easier to reuse:</source>
          <target state="translated">上の例の &lt;code&gt;Card&lt;/code&gt; と &lt;code&gt;Deck&lt;/code&gt; にいくつかのインターフェイスを追加して、タイプをより明確にし、再利用しやすくします。</target>
        </trans-unit>
        <trans-unit id="0810e0790bb570bb542897e9f00f0ff27a268b73" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add types to our simple examples from earlier:</source>
          <target state="translated">上記の簡単な例に型を追加しましょう。</target>
        </trans-unit>
        <trans-unit id="2fbda1714e2bf191061f156921ed8a14ecb815d5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s convert a simple class to use &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;. First, let&amp;rsquo;s start with an example without getters and setters.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; と &lt;code&gt;set&lt;/code&gt; を使用するように単純なクラスを変換しましょう。 ゲッターとセッターのない例から始めましょう。</target>
        </trans-unit>
        <trans-unit id="71429700e5fe5c8713f8050f9d22fc5e71f408cf" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s develop our sample further. Here we use an interface that describes objects that have a firstName and lastName field. In TypeScript, two types are compatible if their internal structure is compatible. This allows us to implement an interface just by having the shape the interface requires, without an explicit &lt;code&gt;implements&lt;/code&gt; clause.</source>
          <target state="translated">さらにサンプルを開発しましょう。 ここでは、firstNameおよびlastNameフィールドを持つオブジェクトを記述するインターフェースを使用します。 TypeScriptでは、内部構造に互換性がある場合、2つの型が互換性があります。 これにより、明示的な &lt;code&gt;implements&lt;/code&gt; 句を使用せずに、必要な形状にするだけでインターフェイスを実装できます。</target>
        </trans-unit>
        <trans-unit id="65d0faf04337211735b15f8a5d34c2608e50c347" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get started by building a simple web application with TypeScript.</source>
          <target state="translated">TypeScriptを使用して簡単なWebアプリケーションを構築することから始めましょう。</target>
        </trans-unit>
        <trans-unit id="b1e0b8ac0a49ba6917defbab6438fe121a7b57d4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back and write the code for the version of &lt;code&gt;padLeft&lt;/code&gt; that uses union types. We could write it with type predicates as follows:</source>
          <target state="translated">ユニオン型を使用する &lt;code&gt;padLeft&lt;/code&gt; のバージョンのコードを書き直しましょう。 次のように、型述語で記述できます。</target>
        </trans-unit>
        <trans-unit id="a370033b626aeaa4b56b2ffa2c9b364f90cf9047" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a fairly normal program and see how project references can help us better organize it. Imagine you have a project with two modules, &lt;code&gt;converter&lt;/code&gt; and &lt;code&gt;units&lt;/code&gt;, and a corresponding test file for each:</source>
          <target state="translated">かなり普通のプログラムを見て、プロジェクト参照がそれを整理するのにどのように役立つかを見てみましょう。 &lt;code&gt;converter&lt;/code&gt; 2つのモジュールコンバーターと &lt;code&gt;units&lt;/code&gt; および対応するテストファイルを含むプロジェクトがあります。</target>
        </trans-unit>
        <trans-unit id="f36707930dcd360fc642c46ec4865e86294c552d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example to better see how this plays out in practice:</source>
          <target state="translated">これが実際にどのように機能するかをよりよく見るために例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="d172a231ad56188812168291eea6a5fd8742b6b4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example:</source>
          <target state="translated">例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="eeeed955a225d9a00620ccdff1e785a00b797db0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s modify the example a bit to show this difference:</source>
          <target state="translated">この違いを説明するために例を少し変更してみましょう。</target>
        </trans-unit>
        <trans-unit id="b02e9aea645d47e4e6bf161ee47aada331ae51db" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now add React and React-DOM, along with their declaration files, as dependencies to your &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="translated">ReactおよびReact-DOMとそれらの宣言ファイルを &lt;code&gt;package.json&lt;/code&gt; ファイルの依存関係として追加しましょう。</target>
        </trans-unit>
        <trans-unit id="83704a6507b28f550a9354f7a8254f0aa3c131e5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now look at a more complex example.</source>
          <target state="translated">次に、より複雑な例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="014bde7411db7919604626e4a814bd5fe5d15eef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that we&amp;rsquo;ve actually intended this function to work on arrays of &lt;code&gt;T&lt;/code&gt; rather than &lt;code&gt;T&lt;/code&gt; directly. Since we&amp;rsquo;re working with arrays, the &lt;code&gt;.length&lt;/code&gt; member should be available. We can describe this just like we would create arrays of other types:</source>
          <target state="translated">実際、この関数が &lt;code&gt;T&lt;/code&gt; ではなくTの配列で動作することを意図していたとしましょう。配列を使用しているため、 &lt;code&gt;.length&lt;/code&gt; メンバーが利用可能になります。 これは、他のタイプの配列を作成するのと同じように説明できます。</target>
        </trans-unit>
        <trans-unit id="0afa8a2c9e9ae086ac85d8e4851a50d094dc340f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we have a sample application that uses the &lt;code&gt;typescript&lt;/code&gt; module. &lt;code&gt;app.ts&lt;/code&gt; has an import like &lt;code&gt;import * as ts from &quot;typescript&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;typescript&lt;/code&gt; には、typescriptモジュールを使用するサンプルアプリケーションがあります。 &lt;code&gt;app.ts&lt;/code&gt; には、import type &lt;code&gt;import * as ts from &quot;typescript&quot;&lt;/code&gt; ようなimportがあります。</target>
        </trans-unit>
        <trans-unit id="b98ecb1cac8b86219be2530212acfb40004f6c82" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we wrote a module file &lt;code&gt;foo.d.ts&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;foo.d.ts&lt;/code&gt; モジュールファイルfoo.d.tsを作成しました。</target>
        </trans-unit>
        <trans-unit id="bf265138b3f25556fefa76ca3b0b12725b0f86b1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s scaffold this out:</source>
          <target state="translated">これを構築しましょう：</target>
        </trans-unit>
        <trans-unit id="aa591bb3c4e18fed63fab3f054ebcf47625b721d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this can be used.</source>
          <target state="translated">これがどのように使用できるかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="a2d4ab99ed2cfcd0bf4a97a7f9d646bc565fffa9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start out with a new directory. We&amp;rsquo;ll name it &lt;code&gt;proj&lt;/code&gt; for now, but you can change it to whatever you want.</source>
          <target state="translated">新しいディレクトリから始めましょう。 ここでは &lt;code&gt;proj&lt;/code&gt; という名前にしますが、必要に応じて変更できます。</target>
        </trans-unit>
        <trans-unit id="55bbd8a0f85bfbe95c8b7cb6332b5825ff504f0e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with the program we&amp;rsquo;ll be using as our example throughout this page. We&amp;rsquo;ve written a small set of simplistic string validators, as you might write to check a user&amp;rsquo;s input on a form in a webpage or check the format of an externally-provided data file.</source>
          <target state="translated">このページ全体で例として使用するプログラムから始めましょう。 Webページフォームでのユーザー入力を確認し、外部から提供されたデータファイルの形式を確認するために、簡単な文字列バリデーターの小さなセットを作成しました。</target>
        </trans-unit>
        <trans-unit id="bf10a2b8087f57e53feead64793d541595e6996c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at a simple class-based example:</source>
          <target state="translated">簡単なクラスベースの例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="3484d66cbe4a02744097aac7ef40e2f056cef65a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at an example:</source>
          <target state="translated">例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="b54485584eecf2901825f4b3995651a7e60470f5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at the simplest mapped type and its parts:</source>
          <target state="translated">最も単純なマッピングされた型とその部分を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="388956de0f4c78ed65b63c815c68a779d593b807" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a minute to consider what that means. &lt;code&gt;setTimeout&lt;/code&gt; will run a function after some number of milliseconds, &lt;em&gt;but only&lt;/em&gt; after the &lt;code&gt;for&lt;/code&gt; loop has stopped executing; By the time the &lt;code&gt;for&lt;/code&gt; loop has stopped executing, the value of &lt;code&gt;i&lt;/code&gt; is &lt;code&gt;10&lt;/code&gt;. So each time the given function gets called, it will print out &lt;code&gt;10&lt;/code&gt;!</source>
          <target state="translated">それが何を意味するのか考えてみましょう。 &lt;code&gt;setTimeout&lt;/code&gt; は、数ミリ秒後に関数を実行しますが、forループの実行が停止した後&lt;em&gt;のみ&lt;/em&gt;です。 &lt;code&gt;for&lt;/code&gt; ループ停止の実行の場合、 &lt;code&gt;i&lt;/code&gt; の値は &lt;code&gt;10&lt;/code&gt; です。 したがって、指定された関数が呼び出されるたびに、 &lt;code&gt;10&lt;/code&gt; が出力されます！</target>
        </trans-unit>
        <trans-unit id="309b7fe3def1ff082c552cb81229fe971bbfb8b9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take our &lt;code&gt;identity&lt;/code&gt; function from earlier:</source>
          <target state="translated">上記の &lt;code&gt;identity&lt;/code&gt; 関数を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="c819787bed8495ecea9cfe18f716371127e40d52" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a Hello World program. In &lt;code&gt;src&lt;/code&gt;, create the file &lt;code&gt;main.ts&lt;/code&gt;:</source>
          <target state="translated">Hello Worldプログラムを作成しましょう。 &lt;code&gt;src&lt;/code&gt; 、ファイル &lt;code&gt;main.ts&lt;/code&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="4f861095293696b450d02c85427a11313836cd45" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write our first TypeScript file using React. First, create a file named &lt;code&gt;Hello.tsx&lt;/code&gt; in &lt;code&gt;src/components&lt;/code&gt; and write the following:</source>
          <target state="translated">Reactを使用して最初のTypeScriptファイルを作成します。 まず、 &lt;code&gt;src/components&lt;/code&gt; &lt;code&gt;Hello.tsx&lt;/code&gt; という名前のファイルを作成し、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="166644bb8752dfdaa61026de73139cfde0a4a540" translate="yes" xml:space="preserve">
          <source>LettersOnlyValidator.ts</source>
          <target state="translated">LettersOnlyValidator.ts</target>
        </trans-unit>
        <trans-unit id="875c3c9135ee949f84870492409833fc57642b20" translate="yes" xml:space="preserve">
          <source>Libraries can also use &lt;code&gt;this&lt;/code&gt; parameters to declare how callbacks will be invoked.</source>
          <target state="translated">ライブラリは、 &lt;code&gt;this&lt;/code&gt; パラメーターを使用して、コールバックの呼び出し方法を宣言することもできます。</target>
        </trans-unit>
        <trans-unit id="7c8d68bdf290b3650035c5dab105050f96236c14" translate="yes" xml:space="preserve">
          <source>Library Structures</source>
          <target state="translated">ライブラリー構造</target>
        </trans-unit>
        <trans-unit id="4e958d206e87dee6202602f12cba1d07ddc64591" translate="yes" xml:space="preserve">
          <source>Library Structures: Consuming Dependencies</source>
          <target state="translated">ライブラリ構造：依存関係の消費</target>
        </trans-unit>
        <trans-unit id="b96d274e68825ffb1cf50ff3a8842c7507fb9c61" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on Global Libraries</source>
          <target state="translated">ライブラリ構造：グローバルライブラリへの依存</target>
        </trans-unit>
        <trans-unit id="c7d79eff0a64c91827b34425186a057bf7eefed6" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on Modules</source>
          <target state="translated">ライブラリ構造：モジュールへの依存</target>
        </trans-unit>
        <trans-unit id="0e5b4340018e06cc22410c43d8c05671e353f758" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on UMD libraries</source>
          <target state="translated">ライブラリ構造：UMDライブラリへの依存</target>
        </trans-unit>
        <trans-unit id="25679ea328e38a91aa99fd34521cab5334cfc5f6" translate="yes" xml:space="preserve">
          <source>Library Structures: Global Libraries</source>
          <target state="translated">ライブラリ構造：グローバルライブラリ</target>
        </trans-unit>
        <trans-unit id="583896dcdb93f9cebf804f97f952c1047d1b09e6" translate="yes" xml:space="preserve">
          <source>Library Structures: Global Plugin</source>
          <target state="translated">ライブラリ構造：グローバルプラグイン</target>
        </trans-unit>
        <trans-unit id="46852e3e51c98d1fbda888c84f0fd0b001bb9a75" translate="yes" xml:space="preserve">
          <source>Library Structures: Global-modifying Modules</source>
          <target state="translated">ライブラリ構造：グローバル変更モジュール</target>
        </trans-unit>
        <trans-unit id="38fb731884bc1a45c091fe53bb4f59beacc5c010" translate="yes" xml:space="preserve">
          <source>Library Structures: Identifying Kinds of Libraries</source>
          <target state="translated">ライブラリ構造：ライブラリタイプの識別</target>
        </trans-unit>
        <trans-unit id="dd13ad9cf324101c470f4a966d00d41d7ab63505" translate="yes" xml:space="preserve">
          <source>Library Structures: Library file layout</source>
          <target state="translated">ライブラリ構造：ライブラリファイルのレイアウト</target>
        </trans-unit>
        <trans-unit id="c83378208463304e24be07d77ddfa86166dca09e" translate="yes" xml:space="preserve">
          <source>Library Structures: Modular Libraries</source>
          <target state="translated">ライブラリ構造：モジュラーライブラリ</target>
        </trans-unit>
        <trans-unit id="1fe937767fb28d22ee73b66129f61b0fe7d8aa7e" translate="yes" xml:space="preserve">
          <source>Library Structures: Module Plugin or UMD Plugin</source>
          <target state="translated">ライブラリ構造：モジュールプラグインまたはUMDプラグイン</target>
        </trans-unit>
        <trans-unit id="4f845580b5f18381f6fa82c3be48352cc4e140d3" translate="yes" xml:space="preserve">
          <source>Library Structures: Preventing Name Conflicts</source>
          <target state="translated">ライブラリ構造：名前の競合の防止</target>
        </trans-unit>
        <trans-unit id="f1c767319c72858af7a6896ba4967b323b7a1717" translate="yes" xml:space="preserve">
          <source>Library Structures: The Impact of ES6 on Module Plugins</source>
          <target state="translated">ライブラリ構造：ES6モジュールプラグインへの影響</target>
        </trans-unit>
        <trans-unit id="c4c82656844e89a1600df1de5a6196522c148102" translate="yes" xml:space="preserve">
          <source>Library Structures: UMD</source>
          <target state="translated">ライブラリ構造：UMD</target>
        </trans-unit>
        <trans-unit id="b914f6929708a78f5ebc7f6182f8d6dadfdf5520" translate="yes" xml:space="preserve">
          <source>Library file layout</source>
          <target state="translated">ライブラリファイルのレイアウト</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apacheライセンス、バージョン2.0でライセンスされています。</target>
        </trans-unit>
        <trans-unit id="614020e4b48ba41cbc8feb6a827a9777cf491e2e" translate="yes" xml:space="preserve">
          <source>Like array destructuring, you can have assignment without declaration:</source>
          <target state="translated">配列の破壊と同様に、宣言なしで割り当てを行うことができます。</target>
        </trans-unit>
        <trans-unit id="8179c422e4946b3006e7ce0d9f1b27008179e0fd" translate="yes" xml:space="preserve">
          <source>Like classes, interfaces can extend each other. This allows you to copy the members of one interface into another, which gives you more flexibility in how you separate your interfaces into reusable components.</source>
          <target state="translated">クラスと同様に、インターフェースは互いに拡張できます。 これにより、あるインターフェイスのメンバーを別のインターフェイスにコピーでき、インターフェイスを再利用可能なコンポーネントに分離する方法の柔軟性が向上します。</target>
        </trans-unit>
        <trans-unit id="e100fe20d9c089d3990a58c235d7844235322341" translate="yes" xml:space="preserve">
          <source>Like other special JS checking behaviors, this behavior can be changed by specifying a JSDoc type for the variable. For example:</source>
          <target state="translated">他の特別なJSチェック動作と同様に、この動作は、変数にJSDocタイプを指定することで変更できます。 例えば：</target>
        </trans-unit>
        <trans-unit id="991d21c5bdd231b177d8dbce4a5a58935deb5866" translate="yes" xml:space="preserve">
          <source>Like we mentioned, it&amp;rsquo;s not unexpected to get error messages after conversion. The important thing is to actually go one by one through these and decide how to deal with the errors. Often these will be legitimate bugs, but sometimes you&amp;rsquo;ll have to explain what you&amp;rsquo;re trying to do a little better to TypeScript.</source>
          <target state="translated">前述のように、変換後にエラーメッセージが表示されることは予期されていません。 重要なことは、実際にそれらを1つずつ調べて、エラーの処理方法を決定することです。 多くの場合、これらは正当なバグですが、TypeScriptを少し改善しようとしていることを説明する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="ad22df7237ec893f071e3a632c74d36af489349a" translate="yes" xml:space="preserve">
          <source>Likewise, for the return type of a function:</source>
          <target state="translated">同様に、関数の戻り型の場合：</target>
        </trans-unit>
        <trans-unit id="bbb07555ce6ca44b59035a2a319034782de9f8d0" translate="yes" xml:space="preserve">
          <source>Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:</source>
          <target state="translated">同様に、反変位置にある同じタイプ変数の複数の候補は、交差タイプを推測します。</target>
        </trans-unit>
        <trans-unit id="5359c0166343c48f9f035c401a1a6fd47a5d3c30" translate="yes" xml:space="preserve">
          <source>List of</source>
          <target state="translated">のリスト</target>
        </trans-unit>
        <trans-unit id="465c88588b5cdd41299c2edcb1468c48ae202ec0" translate="yes" xml:space="preserve">
          <source>List of folders to include type definitions from. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots and &amp;ndash;types&lt;/a&gt; for more details.</source>
          <target state="translated">タイプ定義を含むフォルダーのリスト。 詳細&lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;については、@ types、-typeRoots、および-types&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6ced5dd028928de0448e70e83b68d98333283e39" translate="yes" xml:space="preserve">
          <source>List of library files to be included in the compilation.</source>
          <target state="translated">コンパイルに含めるライブラリファイルのリスト。</target>
        </trans-unit>
        <trans-unit id="bcb7afa9aa95b8c02629a8477085e1d618f28bc0" translate="yes" xml:space="preserve">
          <source>List of names of type definitions to include. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots and &amp;ndash;types&lt;/a&gt; for more details.</source>
          <target state="translated">含めるタイプ定義の名前のリスト。 詳細&lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;については、@ types、-typeRoots、および-types&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="653b9b02be1c90476a3ad618b040891655bf5f51" translate="yes" xml:space="preserve">
          <source>List of path mapping entries for module names to locations relative to the &lt;code&gt;baseUrl&lt;/code&gt;. See &lt;a href=&quot;module-resolution#path-mapping&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;baseUrl&lt;/code&gt; は、モジュール名パスのエントリをbaseUrlに相対的な場所にマッピングします。 詳細については、 &lt;a href=&quot;module-resolution#path-mapping&quot;&gt;モジュール解決のドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bb25bc49f0293214d4dc209e4fc9026643313119" translate="yes" xml:space="preserve">
          <source>Literal type widening can be controlled through explicit type annotations. Specifically, when an expression of a literal type is inferred for a const location without a type annotation, that &lt;code&gt;const&lt;/code&gt; variable gets a widening literal type inferred. But when a &lt;code&gt;const&lt;/code&gt; location has an explicit literal type annotation, the &lt;code&gt;const&lt;/code&gt; variable gets a non-widening literal type.</source>
          <target state="translated">リテラル型の拡張は、明示的な型注釈を通じて制御できます。 具体的には、リテラルタイプの式が、タイプアノテーションのないconstロケーションに対して推論される場合、 &lt;code&gt;const&lt;/code&gt; 変数は、推論されたリテラルタイプの拡張子を取得します。 ただし、 &lt;code&gt;const&lt;/code&gt; の場所に明示的なリテラルタイプの注釈がある場合、 &lt;code&gt;const&lt;/code&gt; 変数は非拡張リテラルタイプを取得します。</target>
        </trans-unit>
        <trans-unit id="e7a432de388d59eb0330d3d1bf7924a86dc9fda9" translate="yes" xml:space="preserve">
          <source>Loading of types from npm packages</source>
          <target state="translated">npmパッケージからタイプをロードする</target>
        </trans-unit>
        <trans-unit id="7e4fa40194fa1599fc6410e0f480c52786bb6b60" translate="yes" xml:space="preserve">
          <source>Local and Imported Type Declarations Now Conflict</source>
          <target state="translated">ローカルおよびインポートされた型宣言の競合</target>
        </trans-unit>
        <trans-unit id="dc901218db3c05e3ca7a85bfcded3b7a52e18ec2" translate="yes" xml:space="preserve">
          <source>Local class, interface, enum, and type alias declarations can now appear inside function declarations. Local types are block scoped, similar to variables declared with &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. For example:</source>
          <target state="translated">ローカルクラス、インターフェイス、列挙型、およびタイプエイリアスの宣言を関数宣言で使用できるようになりました。 ローカル型は、 &lt;code&gt;let&lt;/code&gt; および &lt;code&gt;const&lt;/code&gt; で宣言された変数に似たブロックスコープです。 例えば：</target>
        </trans-unit>
        <trans-unit id="d28868f17a046f8c9d0605670df6ffd291397586" translate="yes" xml:space="preserve">
          <source>Local type declarations</source>
          <target state="translated">ローカル型宣言</target>
        </trans-unit>
        <trans-unit id="25ce31967aab4a48e0accd8ada4e9c79a67d8e96" translate="yes" xml:space="preserve">
          <source>Local types may reference enclosing type parameters and local class and interfaces may themselves be generic. For example:</source>
          <target state="translated">ローカル型は、囲んでいる型パラメーターを参照でき、ローカルクラスとインターフェイス自体は汎用的な場合があります。 例えば：</target>
        </trans-unit>
        <trans-unit id="d54f7840dd15f9efca1a3c2a835dba90f27406bb" translate="yes" xml:space="preserve">
          <source>Localized diagnostics on the command line</source>
          <target state="translated">コマンドラインでのローカライズされた診断</target>
        </trans-unit>
        <trans-unit id="dbc698b0052336839927b67e68ee8b808258468a" translate="yes" xml:space="preserve">
          <source>Locally scoped JSX namespaces</source>
          <target state="translated">ローカルスコープのJSX名前空間</target>
        </trans-unit>
        <trans-unit id="f34ec36309212ab4f733a475011c562c23d0e729" translate="yes" xml:space="preserve">
          <source>Log.ts</source>
          <target state="translated">Log.ts</target>
        </trans-unit>
        <trans-unit id="57f54137157041b8ae56134eceada37f0aaf7daf" translate="yes" xml:space="preserve">
          <source>Look in the first localhost folder, then scripts/app.ts</source>
          <target state="translated">最初にlocalhostフォルダーを見てから、scripts / app.tsを見てください。</target>
        </trans-unit>
        <trans-unit id="8fdfcce162943820f24951cb2a2e053a7c7c3ec0" translate="yes" xml:space="preserve">
          <source>Look in your &lt;code&gt;C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets&lt;/code&gt; file. The authoritative mappings between MSBuild XML tags and &lt;code&gt;tsc&lt;/code&gt; compiler options live in there.</source>
          <target state="translated">&lt;code&gt;C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets&lt;/code&gt; ファイルを確認します。 MSBuild XMLタグと &lt;code&gt;tsc&lt;/code&gt; コンパイラオプションの間には信頼性の高いマッピングがあります。</target>
        </trans-unit>
        <trans-unit id="a6b0fb8ef6778ed02a7ae1ae513bbf8d954f0a94" translate="yes" xml:space="preserve">
          <source>MSBuild</source>
          <target state="translated">MSBuild</target>
        </trans-unit>
        <trans-unit id="2e00dde89c6a5b86d9cb21be7fbf224d7c22deec" translate="yes" xml:space="preserve">
          <source>MSBuild Property Name</source>
          <target state="translated">MSBuildプロパティ名</target>
        </trans-unit>
        <trans-unit id="528349fad89f8e558db9d5dd9f001d6ed4aceabc" translate="yes" xml:space="preserve">
          <source>Make sure that the modules work by running &lt;code&gt;gulp&lt;/code&gt; and then testing in Node:</source>
          <target state="translated">Nodeで &lt;code&gt;gulp&lt;/code&gt; とテストを実行して、モジュールが機能することを確認します。</target>
        </trans-unit>
        <trans-unit id="06adecb648f1663461f793b6ad17375e5c241d45" translate="yes" xml:space="preserve">
          <source>Make sure to revisit the &lt;a href=&quot;library-structures#consuming-dependencies&quot;&gt;Consuming dependencies&lt;/a&gt; section for more information.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;library-structures#consuming-dependencies&quot;&gt;依存&lt;/a&gt;消費セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="8dc73c8a520471a285c4dd9769e30a805d1f4ca3" translate="yes" xml:space="preserve">
          <source>Many JavaScript developers are intimately familiar with this behavior, but if you&amp;rsquo;re surprised, you&amp;rsquo;re certainly not alone. Most people expect the output to be</source>
          <target state="translated">多くのJavaScript開発者はこの動作に精通していますが、驚いたとしても、あなたは一人ではありません。 ほとんどの人が出力を持っています</target>
        </trans-unit>
        <trans-unit id="fe4a673619fce4477eac837da092bcc0b04ae5cf" translate="yes" xml:space="preserve">
          <source>Many bundlers have support for automatically splitting output bundles based on these &lt;code&gt;import&lt;/code&gt; expressions, so consider using this new feature with the &lt;code&gt;esnext&lt;/code&gt; module target.</source>
          <target state="translated">多くの &lt;code&gt;esnext&lt;/code&gt; は 、これらの &lt;code&gt;import&lt;/code&gt; 式に基づいて出力バンドルを自動的に分割するため、esnextモジュールターゲットでこの新しい機能を使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="584c646b07ca217d5f7c1b61637d077ae1a5e971" translate="yes" xml:space="preserve">
          <source>Many common mistakes in declaration files can be easily avoided. The &lt;a href=&quot;do-s-and-don-ts&quot;&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt; section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.</source>
          <target state="translated">宣言ファイルの多くの一般的な間違いは簡単に回避できます。 「To Do &lt;a href=&quot;do-s-and-don-ts&quot;&gt;」および&lt;/a&gt; 「Do n't Do」セクションでは、一般的なエラーを特定し、それらを検出して修正する方法を説明します。 よくある間違いを避けるために、誰もがこのセクションを読む必要があります。</target>
        </trans-unit>
        <trans-unit id="eb06e5cbf12cdc30df47507b636fcce479ba328c" translate="yes" xml:space="preserve">
          <source>Many popular Node.js libraries are in the module family, such as &lt;a href=&quot;http://expressjs.com/&quot;&gt;&lt;code&gt;express&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://gulpjs.com/&quot;&gt;&lt;code&gt;gulp&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://github.com/request/request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://expressjs.com/&quot;&gt; &lt;code&gt;express&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;http://gulpjs.com/&quot;&gt; &lt;code&gt;gulp&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;https://github.com/request/request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt;など、多くの一般的なNode.jsライブラリがモジュールファミリに含まれています。</target>
        </trans-unit>
        <trans-unit id="63a6f8dd928db9783606b9b55a4d1e30673d97c7" translate="yes" xml:space="preserve">
          <source>Many popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:</source>
          <target state="translated">Expressなどの多くの一般的なライブラリは、インポート時に呼び出すことができる関数として公開されています。 たとえば、一般的なExpressの使用法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c6113dbcfc0c046c2e863aac93003dd4c0388bee" translate="yes" xml:space="preserve">
          <source>Many times, we are faced with writing a declaration file when we only have examples of the underlying library to guide us. The &lt;a href=&quot;by-example&quot;&gt;By Example&lt;/a&gt; section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.</source>
          <target state="translated">多くの場合、基礎となるライブラリの例を示すだけで、宣言ファイルの作成に直面します。 &lt;a href=&quot;by-example&quot;&gt;By Example&lt;/a&gt;セクションは、多くの一般的なAPIパターンとそれらの宣言の書き方を示しています。 このガイドは、TypeScriptのすべての言語構成にまだ精通していないTypeScriptの初心者を対象としています。</target>
        </trans-unit>
        <trans-unit id="b39eaaa138d38f75f9ba15b0ecb54217b1f43d1d" translate="yes" xml:space="preserve">
          <source>Mapped Types</source>
          <target state="translated">マッピングされたタイプ</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes" xml:space="preserve">
          <source>Mapped types</source>
          <target state="translated">マッピングされたタイプ</target>
        </trans-unit>
        <trans-unit id="150ac025be99fedc0936df23f699d5432059212b" translate="yes" xml:space="preserve">
          <source>Mapped types are produced by taking a union of literal types, and computing a set of properties for a new object type. They&amp;rsquo;re like &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions&quot;&gt;list comprehensions in Python&lt;/a&gt;, but instead of producing new elements in a list, they produce new properties in a type.</source>
          <target state="translated">マップされた型は、リテラル型の和集合を取得し、新しいオブジェクト型のプロパティセットを計算することで作成されます。 &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions&quot;&gt;Pythonリスト内包表記に&lt;/a&gt;似ていますが、リストに新しい要素を作成する代わりに、タイプに新しいプロパティを作成します。</target>
        </trans-unit>
        <trans-unit id="347c61475a676c2faf7ddbe772ebae4b5d598063" translate="yes" xml:space="preserve">
          <source>Mapped types on tuples and arrays</source>
          <target state="translated">マップされたタイプのタプルと配列</target>
        </trans-unit>
        <trans-unit id="8e8a7963f001150e8ed8e3c1be77a5be18c61c35" translate="yes" xml:space="preserve">
          <source>Mapped types support adding a &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; modifier to a mapped property, but they did not provide support the ability to &lt;em&gt;remove&lt;/em&gt; modifiers. This matters in &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/12563&quot;&gt;&lt;em&gt;homomorphic mapped types&lt;/em&gt;&lt;/a&gt; which by default preserve the modifiers of the underlying type.</source>
          <target state="translated">マップされたタイプの場合、修飾子は &lt;code&gt;readonly&lt;/code&gt; または &lt;code&gt;?&lt;/code&gt; マップされたプロパティは&lt;em&gt;、&lt;/em&gt;修飾子を&lt;em&gt;削除する&lt;/em&gt;機能をサポートし&lt;em&gt;て&lt;/em&gt;いませんでした。 これは、デフォルトでベースタイプ修飾子を持つ&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/12563&quot;&gt;&lt;em&gt;準同型マッピング&lt;/em&gt;&lt;/a&gt;にとって重要です。</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes" xml:space="preserve">
          <source>Mappings</source>
          <target state="translated">Mappings</target>
        </trans-unit>
        <trans-unit id="76afa4572a785cbf8909d66ab1eaf36ef69ba191" translate="yes" xml:space="preserve">
          <source>Matching behavior</source>
          <target state="translated">マッチング操作</target>
        </trans-unit>
        <trans-unit id="d61fb1c71d97cf23364513b6c042480baf71317b" translate="yes" xml:space="preserve">
          <source>Maybe it was easy to spot out for some, but the inner &lt;code&gt;for&lt;/code&gt;-loop will accidentally overwrite the variable &lt;code&gt;i&lt;/code&gt; because &lt;code&gt;i&lt;/code&gt; refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.</source>
          <target state="translated">一部の人を見つけるのは簡単かもしれませんが、同じ関数スコープを持つ変数を参照するため、内部の &lt;code&gt;for&lt;/code&gt; ループが誤って変数 &lt;code&gt;i&lt;/code&gt; を上書きします。 経験豊富な開発者が知っているように、同様のタイプのバグはコードレビューをすり抜け、無限のフラストレーションを引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="d8e319d394c7e9ed6ef1448bbdf219ff4e98198e" translate="yes" xml:space="preserve">
          <source>Merging Interfaces</source>
          <target state="translated">インターフェイスのマージ</target>
        </trans-unit>
        <trans-unit id="87557ad474b3ea1cb7dc79b4a0a69cc3c542648b" translate="yes" xml:space="preserve">
          <source>Merging Namespaces</source>
          <target state="translated">名前空間のマージ</target>
        </trans-unit>
        <trans-unit id="d457feda7cc53bf9cc76dc59489863c6ef6d30dd" translate="yes" xml:space="preserve">
          <source>Merging Namespaces with Classes</source>
          <target state="translated">名前空間とクラスのマージ</target>
        </trans-unit>
        <trans-unit id="78529d067c66e125c411afd44c6c212aea17fa3a" translate="yes" xml:space="preserve">
          <source>Merging Namespaces with Classes, Functions, and Enums</source>
          <target state="translated">名前空間をクラス、関数、列挙型とマージする</target>
        </trans-unit>
        <trans-unit id="91bb6095ae597def81503d12e83651b39c84f4ab" translate="yes" xml:space="preserve">
          <source>Merging ambient class and interface declaration</source>
          <target state="translated">アンビエントクラスとインターフェイス宣言をマージする</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="f70c71c1b2246c59d442015fb609b0bf48d83d56" translate="yes" xml:space="preserve">
          <source>Method Decorators</source>
          <target state="translated">メソッドデコレータ</target>
        </trans-unit>
        <trans-unit id="9adde04ca5b9eac1941dd0c91655d283d19fa1d1" translate="yes" xml:space="preserve">
          <source>Methods within an abstract class that are marked as abstract do not contain an implementation and must be implemented in derived classes. Abstract methods share a similar syntax to interface methods. Both define the signature of a method without including a method body. However, abstract methods must include the &lt;code&gt;abstract&lt;/code&gt; keyword and may optionally include access modifiers.</source>
          <target state="translated">抽象とマークされた抽象クラスのメソッドには実装がなく、派生クラスで実装する必要があります。 抽象メソッドは、インターフェイスメソッドと同様の構文を共有します。 両方とも、メソッド本体を含めずにメソッドシグネチャを定義します。 ただし、抽象メソッドには &lt;code&gt;abstract&lt;/code&gt; キーワードを含める必要があり、オプションでアクセス修飾子を含めることができます。</target>
        </trans-unit>
        <trans-unit id="b6b88d2f7dec6e6507655392b41d6d66aa58943b" translate="yes" xml:space="preserve">
          <source>Microsoft.TypeScript.Compiler</source>
          <target state="translated">Microsoft.TypeScript.Compiler</target>
        </trans-unit>
        <trans-unit id="d6994e014929b9c9acadb4efcdd0d8898ec4998f" translate="yes" xml:space="preserve">
          <source>Microsoft.TypeScript.MSBuild</source>
          <target state="translated">Microsoft.TypeScript.MSBuild</target>
        </trans-unit>
        <trans-unit id="ecf39fd6186584cf8c46f851590e11d05b7c8704" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript</source>
          <target state="translated">JavaScriptからの移行</target>
        </trans-unit>
        <trans-unit id="006f2d2335563fb2900269f9b04adab236ac86ea" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Early Benefits</source>
          <target state="translated">JavaScriptからの移行：初期の利点</target>
        </trans-unit>
        <trans-unit id="1fed3c879f3bb26b579690b94983582cf0edda15" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Getting Stricter Checks</source>
          <target state="translated">JavaScriptからの移行：より厳密なチェックの取得</target>
        </trans-unit>
        <trans-unit id="1dc81892a9e5e97f6be65072af4047daf654e1d2" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Gulp</source>
          <target state="translated">JavaScriptからの移行：Gulp</target>
        </trans-unit>
        <trans-unit id="7e19d5d40009a708d8b21bd446a6de963f361896" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Integrating with Build Tools</source>
          <target state="translated">JavaScriptからの移行：ビルドツールとの統合</target>
        </trans-unit>
        <trans-unit id="4ff2a610f7fca46011040ebfbaebde73fe2d0b89" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Moving to TypeScript Files</source>
          <target state="translated">JavaScriptからの移行：TypeScriptファイルへの移行</target>
        </trans-unit>
        <trans-unit id="9b91d79ea65c179b3144057c1b47e944dbe888c8" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Setting up your Directories</source>
          <target state="translated">JavaScriptからの移行：ディレクトリ設定</target>
        </trans-unit>
        <trans-unit id="47148fd07a568fa2a38d4ed900235994bd81cea2" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Webpack</source>
          <target state="translated">JavaScriptからの移行：Webpack</target>
        </trans-unit>
        <trans-unit id="49c6b428dbb35a643f704a1239347e7235a4958b" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Weeding out Errors</source>
          <target state="translated">JavaScriptからの移行：エラーの除去</target>
        </trans-unit>
        <trans-unit id="8ec1b6d66f7377a566796d605d898d7ac205f685" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Writing a Configuration File</source>
          <target state="translated">JavaScriptからの移行：構成ファイルの作成</target>
        </trans-unit>
        <trans-unit id="df5cb9211be987b98b3cea69592169ee4806d416" translate="yes" xml:space="preserve">
          <source>Minimal project</source>
          <target state="translated">最小限のプロジェクト</target>
        </trans-unit>
        <trans-unit id="656fbec7e4c8bcab6e3951b1194d9d3fdebdb947" translate="yes" xml:space="preserve">
          <source>Mixin classes can constrain the types of classes they can mix into by specifying a construct signature return type in the constraint for the type parameter. For example, the following &lt;code&gt;WithLocation&lt;/code&gt; function implements a subclass factory that adds a &lt;code&gt;getLocation&lt;/code&gt; method to any class that satisfies the &lt;code&gt;Point&lt;/code&gt; interface (i.e. that has &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; properties of type &lt;code&gt;number&lt;/code&gt;).</source>
          <target state="translated">Mixinクラスは、typeパラメーターの制約でコンストラクトシグネチャの戻り値の型を指定することにより、混合できるクラスの型を制約できます。 たとえば、次の &lt;code&gt;WithLocation&lt;/code&gt; 関数は、 &lt;code&gt;Point&lt;/code&gt; インターフェイスを満たすクラスに &lt;code&gt;getLocation&lt;/code&gt; メソッドを追加する（つまり、型が &lt;code&gt;number&lt;/code&gt; の &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; プロパティを持つ）サブクラスファクトリを実装します。</target>
        </trans-unit>
        <trans-unit id="ed6542d9669951817ce6e0f5f573873a74bbcd94" translate="yes" xml:space="preserve">
          <source>Mixin sample</source>
          <target state="translated">ミックスインサンプル</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="a7b93d2128e820f861fc8dfccd9f5521e89ad21f" translate="yes" xml:space="preserve">
          <source>Mode</source>
          <target state="translated">Mode</target>
        </trans-unit>
        <trans-unit id="8686e36f3c455dfff0e15750343932a50c4f9345" translate="yes" xml:space="preserve">
          <source>Modular Libraries</source>
          <target state="translated">モジュラーライブラリ</target>
        </trans-unit>
        <trans-unit id="e87eeaf0b3370593816d7faa70993da2a4c34bdc" translate="yes" xml:space="preserve">
          <source>Modular libraries will typically have at least some of the following:</source>
          <target state="translated">モジュラーライブラリには通常、少なくとも次のいくつかが含まれています。</target>
        </trans-unit>
        <trans-unit id="679935999c06d0d64c305facc48d71ad3d62a359" translate="yes" xml:space="preserve">
          <source>Module Augmentation</source>
          <target state="translated">モジュールの強化</target>
        </trans-unit>
        <trans-unit id="288e4a8c6676ea4eb83392ffcf2395bf08c232ab" translate="yes" xml:space="preserve">
          <source>Module Resolution</source>
          <target state="translated">モジュール解像度</target>
        </trans-unit>
        <trans-unit id="e38eacd064c21c297854627bdac879933ce99fef" translate="yes" xml:space="preserve">
          <source>Module Resolution Strategies</source>
          <target state="translated">モジュールソリューション戦略</target>
        </trans-unit>
        <trans-unit id="4cd56198bb579b9f107f6cea74de7d094276eb7a" translate="yes" xml:space="preserve">
          <source>Module identifiers allow for &lt;code&gt;.js&lt;/code&gt; extension</source>
          <target state="translated">モジュール識別子は &lt;code&gt;.js&lt;/code&gt; 拡張子を許可します</target>
        </trans-unit>
        <trans-unit id="a00b56b003050bea7431d876a345583f047b820c" translate="yes" xml:space="preserve">
          <source>Module imports are resolved differently based on whether the module reference is relative or non-relative.</source>
          <target state="translated">モジュールのインポートは、モジュール参照が相対であるか非相対であるかに基づいて異なる方法で解決されます。</target>
        </trans-unit>
        <trans-unit id="79dbe4a4af0851fd89a5e09eccc010e3219dbe7b" translate="yes" xml:space="preserve">
          <source>Module loaders like SystemJS wrap CommonJS modules and expose then as a &lt;code&gt;default&lt;/code&gt; ES6 import. This makes it impossible to share the definition files between the SystemJS and CommonJS implementation of the module as the module shape looks different based on the loader.</source>
          <target state="translated">SystemJSなどのモジュールローダーは、CommonJSモジュールをラップし、 &lt;code&gt;default&lt;/code&gt; ES6インポートとして公開します 。 これにより、モジュールの形状がローダーごとに異なるように見えるため、モジュールのSystemJS実装とCommonJS実装間で定義ファイルを共有できなくなります。</target>
        </trans-unit>
        <trans-unit id="8706260383ba3213edb052d2ee2093acb606b380" translate="yes" xml:space="preserve">
          <source>Module resolution enhancements: BaseUrl, Path mapping, rootDirs and tracing</source>
          <target state="translated">拡張モジュール解決：BaseUrl、パスマッピング、rootDirsおよびトレース</target>
        </trans-unit>
        <trans-unit id="47f28156d69593c826cc9c4bbfcf281e3d6aa9d7" translate="yes" xml:space="preserve">
          <source>Module resolution kind is not specified, using &lt;strong&gt;&amp;lsquo;NodeJs&amp;rsquo;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;'NodeJs'&lt;/strong&gt;を使用してモジュール解決タイプが指定されてい&lt;strong&gt;ません&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="a30c7f6e8f418488e99ab172a19da443b4fdc2aa" translate="yes" xml:space="preserve">
          <source>Modules also have a dependency on a module loader (such as CommonJs/Require.js). For a small JS application this might not be optimal, but for larger applications, the cost comes with long term modularity and maintainability benefits. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.</source>
          <target state="translated">モジュールは、モジュールローダー（CommonJs / Require.jsなど）にも依存します。 小規模なJSアプリケーションの場合、これは最適ではないかもしれませんが、大規模なアプリケーションの場合、長期的なモジュール性と保守性の利点は犠牲になります。 モジュールは、コードの再利用性を高め、分離を強化し、バンドルのツールサポートを改善します。</target>
        </trans-unit>
        <trans-unit id="78a50e79f8142b8f5f0f90d0fa7d14efea7d1c2f" translate="yes" xml:space="preserve">
          <source>Modules are declarative; the relationships between modules are specified in terms of imports and exports at the file level.</source>
          <target state="translated">モジュールは宣言型です。 モジュール間の関係は、ファイルレベルのインポートとエクスポートの観点から指定されます。</target>
        </trans-unit>
        <trans-unit id="675dd99631ed01c0f9ec0b8b2aaed9ef0a2c4dfd" translate="yes" xml:space="preserve">
          <source>Modules are executed within their own scope, not in the global scope; this means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the &lt;a href=&quot;#export&quot;&gt;&lt;code&gt;export&lt;/code&gt; forms&lt;/a&gt;. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the &lt;a href=&quot;#import&quot;&gt;&lt;code&gt;import&lt;/code&gt; forms&lt;/a&gt;.</source>
          <target state="translated">モジュールは、グローバルスコープではなく、独自のスコープで実行されます。 つまり、モジュールで宣言された変数、関数、クラスなどは、いずれかの&lt;a href=&quot;#export&quot;&gt; &lt;code&gt;export&lt;/code&gt; フォーム&lt;/a&gt;を使用して明示的にエクスポートされない限り、モジュールの外部からは見えません。 逆に、異なるモジュールからエクスポートされた変数、関数、クラス、インターフェースなどを使用するには、いずれかの&lt;a href=&quot;#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; フォーム&lt;/a&gt;を使用してインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="cf0193704c9e50ad766367f6e68a7b531b34d65e" translate="yes" xml:space="preserve">
          <source>Modules are now emitted with a &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; prologue</source>
          <target state="translated">モジュールは &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; プロローグ</target>
        </trans-unit>
        <trans-unit id="e2a4a37826bb3f0f9a97d6eaca31fecba95d357a" translate="yes" xml:space="preserve">
          <source>Modules are parsed automatically in strict mode. The new flag is recommended for non-module code.</source>
          <target state="translated">モジュールは、strictモードで自動的に解析されます。 モジュール以外のコードには新しいフラグをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5b28d96858ba2eea0c5a37016b2613ff4945fbf0" translate="yes" xml:space="preserve">
          <source>Modules can import types declared in other modules. But non-module global scripts cannot access types declared in modules. Enter &lt;code&gt;import&lt;/code&gt; types.</source>
          <target state="translated">モジュールは、他のモジュールで宣言された型をインポートできます。 ただし、非モジュールのグローバルスクリプトは、モジュールで宣言された型にアクセスできません。 &lt;code&gt;import&lt;/code&gt; タイプを入力します。</target>
        </trans-unit>
        <trans-unit id="f37a7873a73994ccdd158807226796e74f617880" translate="yes" xml:space="preserve">
          <source>Modules import one another using a module loader. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. Well-known module loaders used in JavaScript are Node.js&amp;rsquo;s loader for &lt;a href=&quot;https://en.wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; modules and the &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; loader for &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/amd.html&quot;&gt;AMD&lt;/a&gt; modules in Web applications.</source>
          <target state="translated">モジュールは、モジュールローダーを使用して相互にインポートします。 実行時に、モジュールローダーはモジュールを実行する前にモジュールのすべての依存関係を見つけて実行します。 JavaScriptで使用される注目すべきモジュールローダーは、Node.js &lt;a href=&quot;https://en.wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;モジュールローダーとWebアプリケーション&lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/amd.html&quot;&gt;AMD&lt;/a&gt;モジュール用の&lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;ローダーです。</target>
        </trans-unit>
        <trans-unit id="f58764143073eae1cd29c9babec8bc1672b59332" translate="yes" xml:space="preserve">
          <source>Modules were always parsed in strict mode as per ES6, but for non-ES6 targets this was not respected in the generated code. Starting with TypeScript 1.8, emitted modules are always in strict mode. This shouldn&amp;rsquo;t have any visible changes in most code as TS considers most strict mode errors as errors at compile time, but it means that some things which used to silently fail at runtime in your TS code, like assigning to &lt;code&gt;NaN&lt;/code&gt;, will now loudly fail. You can reference the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDN Article&lt;/a&gt; on strict mode for a detailed list of the differences between strict mode and non-strict mode.</source>
          <target state="translated">モジュールは、ES6のように常に厳密モードで解析されましたが、ES6以外のターゲットの場合、生成されたコードでは考慮されませんでした。 TypeScript 1.8以降では、出力モジュールは常に厳密モードになっています。 TSはコンパイル時に最も重大なモードエラーをエラーと見なすため、ほとんどのコードに目に見える変更はありませんが、 &lt;code&gt;NaN&lt;/code&gt; への割り当てなど、実行時にサイレントに失敗するTSコードは大失敗します。 厳密モードと非厳密モードの違いの詳細なリストについては、厳密モード&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDNの記事を参照してください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="69245e47778546d5b4d8c60a97c075633036ce67" translate="yes" xml:space="preserve">
          <source>More Accurate Array Spread</source>
          <target state="translated">より正確なシーケンスの広がり</target>
        </trans-unit>
        <trans-unit id="867951121618b22e94ac0ddd378f75a352293d4f" translate="yes" xml:space="preserve">
          <source>More details about defining MSBuild compiler options: &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;Setting Compiler Options in MSBuild projects&lt;/a&gt;</source>
          <target state="translated">MSBuildコンパイラオプションの定義の詳細： &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuildプロジェクトでのコンパイラオプションの設定&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="341a196acd33aea44262f80c4074a8f29f17eab0" translate="yes" xml:space="preserve">
          <source>More details can be found at &lt;a href=&quot;http://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;Package Manager Dialog&lt;/a&gt; and &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;using nightly builds with NuGet&lt;/a&gt;</source>
          <target state="translated">詳細については、 &lt;a href=&quot;http://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;パッケージマネージャーダイアログ&lt;/a&gt;および&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;NuGetでのナイトリービルドの使用を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="53846a07e48104da9e41b5b1360721c3ad76cfc9" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm&quot;&gt;TypeScriptSamples/jspm&lt;/a&gt;</source>
          <target state="translated">詳細： &lt;a href=&quot;https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm&quot;&gt;TypeScriptSamples / jspm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f54abbf20043f5f79ba176f97dcafaab83a262d" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/TypeStrong/grunt-ts&quot;&gt;TypeStrong/grunt-ts&lt;/a&gt;</source>
          <target state="translated">詳細： &lt;a href=&quot;https://github.com/TypeStrong/grunt-ts&quot;&gt;TypeStrong / grunt-ts&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4be1d9cace5494e189a22e68f895ee7cf9cddcd" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/frankwallis/duo-typescript&quot;&gt;frankwallis/duo-typescript&lt;/a&gt;</source>
          <target state="translated">詳細： &lt;a href=&quot;https://github.com/frankwallis/duo-typescript&quot;&gt;frankwallis / duo-typescript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9288db5f93cb0d64c4598820b26040518ce475e5" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/ivogabe/gulp-typescript&quot;&gt;ivogabe/gulp-typescript&lt;/a&gt;</source>
          <target state="translated">詳細： &lt;a href=&quot;https://github.com/ivogabe/gulp-typescript&quot;&gt;ivogabe / gulp-typescript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c2859a3239620cafb1098f30753d17591c86749" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/smrq/tsify&quot;&gt;smrq/tsify&lt;/a&gt;</source>
          <target state="translated">詳細： &lt;a href=&quot;https://github.com/smrq/tsify&quot;&gt;smrq / tsify&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="383f0e0e882a4dc2683b66372e6aa52e3a75f04b" translate="yes" xml:space="preserve">
          <source>More examples</source>
          <target state="translated">その他の例</target>
        </trans-unit>
        <trans-unit id="d6f53e513aa21c7609698b66494f900516f1e524" translate="yes" xml:space="preserve">
          <source>More information is available at &lt;a href=&quot;https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions&quot;&gt;VSCode documentation&lt;/a&gt;.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions&quot;&gt;VSCodeのドキュメントを&lt;/a&gt;参照してください 。</target>
        </trans-unit>
        <trans-unit id="3ebf7c56cc3c7e6470d4e988436ec5ba45710c59" translate="yes" xml:space="preserve">
          <source>More information is available at the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation&quot;&gt;TypeScript Plugin for Sublime Text installation documentation&lt;/a&gt;.</source>
          <target state="translated">詳細について&lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation&quot;&gt;は、Sublime Text TypeScriptプラグインのインストールドキュメントを&lt;/a&gt;参照してください 。</target>
        </trans-unit>
        <trans-unit id="9f1fd24b8a3a7e494a8b827fe826c345c6c39fc7" translate="yes" xml:space="preserve">
          <source>More more details, you can &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining/&quot;&gt;read up on the proposal&lt;/a&gt; and &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33294&quot;&gt;view the original pull request&lt;/a&gt;.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining/&quot;&gt;提案&lt;/a&gt;を読んで、 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33294&quot;&gt;元のプルリクエスト&lt;/a&gt;を表示できます。</target>
        </trans-unit>
        <trans-unit id="2090b67c917ff081773b34229e30e6990c49b179" translate="yes" xml:space="preserve">
          <source>More plainly, that code snippet is the same as writing the following.</source>
          <target state="translated">より具体的には、コードスニペットは次と同じです。</target>
        </trans-unit>
        <trans-unit id="ba3ba120356f7dea7aa61a6e3ef6b6565d3edcce" translate="yes" xml:space="preserve">
          <source>Most popular libraries are now available as UMD packages. Examples include &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;, &lt;a href=&quot;https://lodash.com/&quot;&gt;lodash&lt;/a&gt;, and many more.</source>
          <target state="translated">最も人気のあるライブラリがUMDパッケージとして利用可能になりました。 例には、 &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; 、 &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt; 、 &lt;a href=&quot;https://lodash.com/&quot;&gt;lodash&lt;/a&gt;などが含まれます。</target>
        </trans-unit>
        <trans-unit id="638f05be2eca8814a76fc1ca76ad8fd857366420" translate="yes" xml:space="preserve">
          <source>Moving to TypeScript Files</source>
          <target state="translated">TypeScriptファイルに移動</target>
        </trans-unit>
        <trans-unit id="43621334a2a23b4d5d4b6053efcc9a2d2b0aab17" translate="yes" xml:space="preserve">
          <source>Much of the time when we talk about &amp;ldquo;singleton types&amp;rdquo;, we&amp;rsquo;re referring to both enum member types as well as numeric/string literal types, though many users will use &amp;ldquo;singleton types&amp;rdquo; and &amp;ldquo;literal types&amp;rdquo; interchangeably.</source>
          <target state="translated">多くのユーザーは「シングルトン」と「リテラル」を同じ方法で使用しますが、「シングルトン」について話すとき、多くの場合、enumメンバータイプと数値/文字列リテラルタイプの両方を参照します。</target>
        </trans-unit>
        <trans-unit id="17529a071acaf46e503733acf690f3a9c40c2a13" translate="yes" xml:space="preserve">
          <source>Multi-file namespaces</source>
          <target state="translated">マルチファイル名前空間</target>
        </trans-unit>
        <trans-unit id="6a46449eba494ccdd3d50009ef86e5514ea905cd" translate="yes" xml:space="preserve">
          <source>Multiple decorators can be applied to a declaration, as in the following examples:</source>
          <target state="translated">次の例のように、宣言に複数のデコレータを適用できます。</target>
        </trans-unit>
        <trans-unit id="c84cbd92065cb5c6f658fb4c2b736202ca88a094" translate="yes" xml:space="preserve">
          <source>Multiple fields</source>
          <target state="translated">複数のフィールド</target>
        </trans-unit>
        <trans-unit id="e64884c573469c4403ae3581451fc7bb26479d03" translate="yes" xml:space="preserve">
          <source>Multiple files that have the same &lt;code&gt;export namespace Foo {&lt;/code&gt; at top-level (don&amp;rsquo;t think that these are going to combine into one &lt;code&gt;Foo&lt;/code&gt;!)</source>
          <target state="translated">複数のファイル{同じ &lt;code&gt;export namespace Foo {&lt;/code&gt; 持つトップレベル{ （それらを1つのFooに結合しないでください！）</target>
        </trans-unit>
        <trans-unit id="c9a109a97c148517f646b23952e44c0d2099a11f" translate="yes" xml:space="preserve">
          <source>Multiple object literal type inferences for the same type parameter are similarly collapsed into a single normalized union type:</source>
          <target state="translated">同じ型パラメーターに対する複数のオブジェクトリテラル型の推論は、単一の正規化された共用体型に同様にグループ化されます。</target>
        </trans-unit>
        <trans-unit id="2e944fe6e675e7e28c8ee6b40790b0f75443bf77" translate="yes" xml:space="preserve">
          <source>MyClass.ts</source>
          <target state="translated">MyClass.ts</target>
        </trans-unit>
        <trans-unit id="9d75928f38872b5fba12d9e28028ca42f4f74a7f" translate="yes" xml:space="preserve">
          <source>MyFunc.ts</source>
          <target state="translated">MyFunc.ts</target>
        </trans-unit>
        <trans-unit id="6a6cd093331d4efd7bda9e1eec1f6de5f0b888e7" translate="yes" xml:space="preserve">
          <source>MyLargeModule.ts</source>
          <target state="translated">MyLargeModule.ts</target>
        </trans-unit>
        <trans-unit id="d4689856a3bbc2e7a56c851bfc734afc822d4050" translate="yes" xml:space="preserve">
          <source>MyTestPage.html (excerpt)</source>
          <target state="translated">MyTestPage.html（抜粋）</target>
        </trans-unit>
        <trans-unit id="5621ae759c74cfb2dde7856d9cb911d0824e1648" translate="yes" xml:space="preserve">
          <source>MyThings.ts</source>
          <target state="translated">MyThings.ts</target>
        </trans-unit>
        <trans-unit id="4e93c1eccd779026bfe9421435d57abbf755af58" translate="yes" xml:space="preserve">
          <source>NOTE A &lt;em&gt;Property Descriptor&lt;/em&gt; is not provided as an argument to a property decorator due to how property decorators are initialized in TypeScript. This is because there is currently no mechanism to describe an instance property when defining members of a prototype, and no way to observe or modify the initializer for a property. The return value is ignored too. As such, a property decorator can only be used to observe that a property of a specific name has been declared for a class.</source>
          <target state="translated">注TypeScriptでプロパティデコレータが初期化される方法のため、プロパティデコレータはプロパティデコレータの引数として提供されません。 これは、現在、プロトタイプメンバーを定義するときにインスタンスプロパティを記述するメカニズムがなく、プロパティ初期化子を監視または変更する方法がないためです。 戻り値も無視されます。 したがって、プロパティデコレータは、特定の名前のプロパティがクラスに対して宣言されていることを確認するためにのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="9845c4ce119ecd689f1dfdba7ee10411216b49e9" translate="yes" xml:space="preserve">
          <source>NOTE A parameter decorator can only be used to observe that a parameter has been declared on a method.</source>
          <target state="translated">注：パラメーターデコレーターは、パラメーターがメソッドで宣言されていることを確認するためにのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="8b79455e774377963b080298d153feef0d875163" translate="yes" xml:space="preserve">
          <source>NOTE Decorator metadata is an experimental feature and may introduce breaking changes in future releases.</source>
          <target state="translated">メモデコレータメタデータは実験的な機能であり、将来のリリースで重大な変更が導入される可能性があります。</target>
        </trans-unit>
        <trans-unit id="2285b393e7b504af0a81971d53ea0b3d317886cd" translate="yes" xml:space="preserve">
          <source>NOTE Decorators are an experimental feature that may change in future releases.</source>
          <target state="translated">メモデコレータは、将来のリリースで変更される可能性がある実験的な機能です。</target>
        </trans-unit>
        <trans-unit id="a60eb9bd0a4289a1fdb762b911bc6c4ca3667c6d" translate="yes" xml:space="preserve">
          <source>NOTE Should you choose to return a new constructor function, you must take care to maintain the original prototype. The logic that applies decorators at runtime will &lt;strong&gt;not&lt;/strong&gt; do this for you.</source>
          <target state="translated">注新しいコンストラクター関数を返すことを選択した場合、元のプロトタイプを保持するように注意する必要があります。 実行時にデコレータを適用するロジックはこれを行いません。</target>
        </trans-unit>
        <trans-unit id="60bdff9d3b04677acbffa7e2cc622c91f6a36bb2" translate="yes" xml:space="preserve">
          <source>NOTE The &lt;em&gt;Property Descriptor&lt;/em&gt; will be &lt;code&gt;undefined&lt;/code&gt; if your script target is less than &lt;code&gt;ES5&lt;/code&gt;.</source>
          <target state="translated">注スクリプトターゲットが &lt;code&gt;ES5&lt;/code&gt; 未満の場合、 &lt;em&gt;プロパティ記述子&lt;/em&gt;は &lt;code&gt;undefined&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="3819f97fdfb5b90ae474745720dbbf7bdc58c9e6" translate="yes" xml:space="preserve">
          <source>NOTE The return value is ignored if your script target is less than &lt;code&gt;ES5&lt;/code&gt;.</source>
          <target state="translated">注：スクリプトターゲットが &lt;code&gt;ES5&lt;/code&gt; より小さい場合、戻り値は無視されます。</target>
        </trans-unit>
        <trans-unit id="195da41da17e46986e65163a2bd1160b912d7429" translate="yes" xml:space="preserve">
          <source>NOTE This example requires the &lt;code&gt;reflect-metadata&lt;/code&gt; library. See &lt;a href=&quot;#metadata&quot;&gt;Metadata&lt;/a&gt; for more information about the &lt;code&gt;reflect-metadata&lt;/code&gt; library.</source>
          <target state="translated">注この例では、 &lt;code&gt;reflect-metadata&lt;/code&gt; ライブラリが必要です。 &lt;code&gt;reflect-metadata&lt;/code&gt; ライブラリの詳細については、 &lt;a href=&quot;#metadata&quot;&gt;メタデータ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a10f30aafff5360ca16967a3e15b058ca9402455" translate="yes" xml:space="preserve">
          <source>NOTE TypeScript disallows decorating both the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessor for a single member. Instead, all decorators for the member must be applied to the first accessor specified in document order. This is because decorators apply to a &lt;em&gt;Property Descriptor&lt;/em&gt;, which combines both the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessor, not each declaration separately.</source>
          <target state="translated">注TypeScriptは、単一のメンバーの &lt;code&gt;get&lt;/code&gt; および &lt;code&gt;set&lt;/code&gt; アクセサーの両方を修飾することはできません。 代わりに、メンバーのすべてのデコレーターは、ドキュメントの順序で指定された最初のアクセサーに適用する必要があります。 これは、各宣言を個別にではなく、 &lt;code&gt;get&lt;/code&gt; アクセサーと &lt;code&gt;set&lt;/code&gt; アクセサーの両方を組み合わせた&lt;em&gt;プロパティ記述子に&lt;/em&gt;デコレーターが適用されるためです。</target>
        </trans-unit>
        <trans-unit id="45308d86614845d7f3bb84b8a20942a74d48e6a9" translate="yes" xml:space="preserve">
          <source>NOTE You can see a more detailed example of a decorator factory in &lt;a href=&quot;#method-decorators&quot;&gt;Method Decorators&lt;/a&gt;, below.</source>
          <target state="translated">注以下の&lt;a href=&quot;#method-decorators&quot;&gt;メソッド&lt;/a&gt;デコレータで、デコレータファクトリのより詳細な例を見ることができます。</target>
        </trans-unit>
        <trans-unit id="77a213401e1d655ca6ce67ccac1b595b83f6a49a" translate="yes" xml:space="preserve">
          <source>NOTE You can see a more detailed example of a decorator in &lt;a href=&quot;#class-decorators&quot;&gt;Class Decorators&lt;/a&gt;, below.</source>
          <target state="translated">注以下の&lt;a href=&quot;#class-decorators&quot;&gt;クラス&lt;/a&gt;デコレータでデコレータのより詳細な例を見ることができます。</target>
        </trans-unit>
        <trans-unit id="3bfed306b0b8464442bdb1711257fd81e5104011" translate="yes" xml:space="preserve">
          <source>Name and location of the import</source>
          <target state="translated">インポート名と場所</target>
        </trans-unit>
        <trans-unit id="c4e900249c06ced551414f6dbfecd4345fbf0964" translate="yes" xml:space="preserve">
          <source>Name your files with a &lt;code&gt;.tsx&lt;/code&gt; extension</source>
          <target state="translated">ファイルに &lt;code&gt;.tsx&lt;/code&gt; 拡張子を付けて名前を付けます</target>
        </trans-unit>
        <trans-unit id="f1e1fdc0047ebce963af46e324aa0bb6cc3cd40b" translate="yes" xml:space="preserve">
          <source>Name your project and solution. After select the &lt;em&gt;Create&lt;/em&gt; button</source>
          <target state="translated">プロジェクトとソリューションに名前を付けます。 [ &lt;em&gt;作成&lt;/em&gt; ]ボタンを選択した後</target>
        </trans-unit>
        <trans-unit id="0449e1003dd0cdd92ab163e844540614258e8b38" translate="yes" xml:space="preserve">
          <source>Namespace</source>
          <target state="translated">Namespace</target>
        </trans-unit>
        <trans-unit id="62936894b0ebe54f16bb9d18daac6e4b06cda0b2" translate="yes" xml:space="preserve">
          <source>Namespaced Validators</source>
          <target state="translated">名前空間バリデーター</target>
        </trans-unit>
        <trans-unit id="be09a63bd1995e99cd22064cdc39a4bae464033d" translate="yes" xml:space="preserve">
          <source>Namespaces</source>
          <target state="translated">Namespaces</target>
        </trans-unit>
        <trans-unit id="6f67c77b8db69b7cbbe81780dca2a3cd93d34c20" translate="yes" xml:space="preserve">
          <source>Namespaces &amp;amp; Modules</source>
          <target state="translated">名前空間とモジュール</target>
        </trans-unit>
        <trans-unit id="9b1e65cb7124596d09d4502bbe02b71fb8a3d882" translate="yes" xml:space="preserve">
          <source>Namespaces and Modules</source>
          <target state="translated">名前空間とモジュール</target>
        </trans-unit>
        <trans-unit id="13339d851d51b5c81981062cf249473168c678ea" translate="yes" xml:space="preserve">
          <source>Namespaces are flexible enough to also merge with other types of declarations. To do so, the namespace declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types. TypeScript uses this capability to model some of the patterns in JavaScript as well as other programming languages.</source>
          <target state="translated">名前空間は、他の種類の宣言とマージできるほど柔軟です。 これを行うには、名前空間宣言をマージする宣言に従う必要があります。 結果の宣言には、両方の宣言タイプのプロパティがあります。 TypeScriptはこの機能を使用して、JavaScriptおよびその他のプログラミング言語のパターンの一部をモデル化します。</target>
        </trans-unit>
        <trans-unit id="0fd9b6444054278bf7680e4f8067f50258da5add" translate="yes" xml:space="preserve">
          <source>Namespaces are important to avoid naming collisions in the global scope. For example, you might have &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; and &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;ndash; two types with the same name, but a different namespace. This, however, is not an issue with modules. Within a module, there&amp;rsquo;s no plausible reason to have two objects with the same name. From the consumption side, the consumer of any given module gets to pick the name that they will use to refer to the module, so accidental naming conflicts are impossible.</source>
          <target state="translated">名前空間は、グローバルスコープでの名前の衝突を避けるために重要です。 たとえば、 &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; と &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;ndash;名前が同じで名前空間が異なる2つのタイプがあるとします。 ただし、これはモジュールの問題ではありません。 モジュール内では、同じ名前の2つのオブジェクトを使用するもっともらしい理由はありません。 コンシューマー側から、特定のモジュールのコンシューマーは、モジュールを参照するために使用する名前を選択するため、誤って名前が競合することはありません。</target>
        </trans-unit>
        <trans-unit id="5e4e7df3860290d042f9971740a7d47d81a9f02b" translate="yes" xml:space="preserve">
          <source>Namespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. They can span multiple files, and can be concatenated using &lt;code&gt;--outFile&lt;/code&gt;. Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags in your HTML page.</source>
          <target state="translated">ネームスペースは、グローバルネームスペース内のJavaScriptオブジェクトの単純な名前です。 これにより、名前空間が非常に単純になります。 複数のファイルにまたがることができ、-- &lt;code&gt;--outFile&lt;/code&gt; を使用して連結できます。 名前空間は、HTMLページにすべての依存関係を &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグとして含めることにより、Webアプリケーションコードを構造化するのに適した方法です。</target>
        </trans-unit>
        <trans-unit id="362b423baafd1e7b201b94eb4694146a945d2f27" translate="yes" xml:space="preserve">
          <source>Namespacing</source>
          <target state="translated">Namespacing</target>
        </trans-unit>
        <trans-unit id="166846adfb9918dc66f0055635e2541ff9496d41" translate="yes" xml:space="preserve">
          <source>Native ECMAScript 2015 modules SimpleModule.js</source>
          <target state="translated">ネイティブECMAScript 2015モジュールSimpleModule.js</target>
        </trans-unit>
        <trans-unit id="fe8c21145c9261ff78e4961a2b85ef9086d1cb41" translate="yes" xml:space="preserve">
          <source>Needless Namespacing</source>
          <target state="translated">不要な名前空間</target>
        </trans-unit>
        <trans-unit id="e41b56abbcfdf8901dfab715d721b400cec7b1fc" translate="yes" xml:space="preserve">
          <source>Neither module augmentations nor global augmentations can add new items to the top level scope - they can only &amp;ldquo;patch&amp;rdquo; existing declarations.</source>
          <target state="translated">モジュール拡張機能もグローバル拡張機能も、新しいアイテムをトップレベルのスコープに追加できません。既存の宣言にのみ「パッチ」を適用できます。</target>
        </trans-unit>
        <trans-unit id="e6bef57bae5c0e8838a79a353fc36602b74e1fc1" translate="yes" xml:space="preserve">
          <source>Nested and merged declarations</source>
          <target state="translated">ネストされた宣言とマージされた宣言</target>
        </trans-unit>
        <trans-unit id="4d4cd8fe398e6e096cb8030f584f4c402cf52fc5" translate="yes" xml:space="preserve">
          <source>Nesting works to any level now, and merges correctly across files. Previously neither was the case.</source>
          <target state="translated">ネストはどのレベルでも機能するようになり、ファイル間で正しくマージされます。 以前は、どちらもそうではありませんでした。</target>
        </trans-unit>
        <trans-unit id="80c3052d33ccdee15ffaaa110c5c39072495fe63" translate="yes" xml:space="preserve">
          <source>Never</source>
          <target state="translated">Never</target>
        </trans-unit>
        <trans-unit id="1acaa361d7e585d276debdfd60f55c71408418be" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--alwaysStrict&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;--alwaysStrict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ac644d9fe3dbb3ac2dccc6d1b53a6bed2b697fc" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--declarationDir&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;--declarationDir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="720d98b2f44f4640d6cfec4c055ef03a55e5d548" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--declarationMap&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;--declarationMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b89c753438c197bdc13cb6ed610b532eff5723f" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--downlevelIteration&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;--downlevelIteration&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a00d32452ace95eaef3db016e18a1198fbb4791b" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--emitDeclarationOnly&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;--emitDeclarationOnly&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8227c234e0daa0aaa18b885af7157a89a55e5b26" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--resolveJsonModule&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;--resolveJsonModule&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="805477b1e825abe5eda721395ad4816c0fd064db" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--skipLibCheck&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;--skipLibCheck&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fcbfed49c3a6bd382d5f91b01c13c2352408ca8e" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--strict&lt;/code&gt; master option</source>
          <target state="translated">新しい &lt;code&gt;--strict&lt;/code&gt; マスターオプション</target>
        </trans-unit>
        <trans-unit id="d911d8e68bbe08754a7470249f09d0d73ac4db62" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;.tsx&lt;/code&gt; file extension and &lt;code&gt;as&lt;/code&gt; operator</source>
          <target state="translated">新しい &lt;code&gt;.tsx&lt;/code&gt; ファイル拡張子と &lt;code&gt;as&lt;/code&gt; 演算子</target>
        </trans-unit>
        <trans-unit id="84261bdb966ed15a62fb8f6e8d19c7f9f2c38198" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;jsx: react-native&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;jsx: react-native&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1306ec7c0fb90964d3f3b400158133f1b7d16572" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;unknown&lt;/code&gt; top type</source>
          <target state="translated">新しい &lt;code&gt;unknown&lt;/code&gt; トップタイプ</target>
        </trans-unit>
        <trans-unit id="70bbb8ec99677d5bef2d3951d16be6268f24f3eb" translate="yes" xml:space="preserve">
          <source>New TypeScript Playground</source>
          <target state="translated">新しいTypeScriptプレイグラウンド</target>
        </trans-unit>
        <trans-unit id="6de3d5b36312b21832416e8730475cc96c42db45" translate="yes" xml:space="preserve">
          <source>New checks added to TypeScript are often off by default to avoid breaking existing projects. While avoiding breakage is a good thing, this strategy has the drawback of making it increasingly complex to choose the highest level of type safety, and doing so requires explicit opt-in action on every TypeScript release. With the &lt;code&gt;--strict&lt;/code&gt; option it becomes possible to choose maximum type safety with the understanding that additional errors might be reported by newer versions of the compiler as improved type checking features are added.</source>
          <target state="translated">TypeScriptに追加された新しいチェックは、既存のプロジェクトを壊さないようにデフォルトでオフになっていることがよくあります。 破損を回避することは良いことですが、この戦略には、TypeScriptの各リリースでの明示的なオプトインアクションが必要なため、最高レベルのタイプセーフティを選択することがますます複雑になっているという欠点があります。 &lt;code&gt;--strict&lt;/code&gt; オプションを使用すると、改善されたタイプチェック機能が追加されたときに、コンパイラの新しいバージョンによって追加のエラーが報告される可能性があることを理解しながら、最大限のタイプセーフティを選択できます。 君は。</target>
        </trans-unit>
        <trans-unit id="7ba10c954271506a3bcae23fd68b8232b3e4e8de" translate="yes" xml:space="preserve">
          <source>Next we have an example of how to override the constructor.</source>
          <target state="translated">以下は、コンストラクターをオーバーライドする方法の例です。</target>
        </trans-unit>
        <trans-unit id="b330ca07a7da236f37925657529d467d0a58f857" translate="yes" xml:space="preserve">
          <source>Next we will add a new folder and call it &lt;code&gt;scripts&lt;/code&gt;.</source>
          <target state="translated">次に、新しいフォルダーを追加して、それを &lt;code&gt;scripts&lt;/code&gt; と呼びます。</target>
        </trans-unit>
        <trans-unit id="b62c3108bc37dfcdf96234518498c091954b4711" translate="yes" xml:space="preserve">
          <source>Next, for each type variable introduced by an &lt;code&gt;infer&lt;/code&gt; (more later) declaration within &lt;code&gt;U&lt;/code&gt; collect a set of candidate types by inferring from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; (using the same inference algorithm as type inference for generic functions). For a given &lt;code&gt;infer&lt;/code&gt; type variable &lt;code&gt;V&lt;/code&gt;, if any candidates were inferred from co-variant positions, the type inferred for &lt;code&gt;V&lt;/code&gt; is a union of those candidates. Otherwise, if any candidates were inferred from contra-variant positions, the type inferred for &lt;code&gt;V&lt;/code&gt; is an intersection of those candidates. Otherwise, the type inferred for &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">次に、 &lt;code&gt;infer&lt;/code&gt; （後で）によって導入された各型変数について、 &lt;code&gt;U&lt;/code&gt; の宣言は、 &lt;code&gt;T&lt;/code&gt; からUに推論することにより、候補型のセット（ジェネリック関数の型推論と同じ推論アルゴリズムを使用）になります。 &lt;code&gt;V&lt;/code&gt; 、候補が共変位置から推定される場合、Vに対して推定される型はそれらの候補の和集合です。 それ以外の場合、候補が反変位置から推定される場合、 &lt;code&gt;V&lt;/code&gt; に対して推定される型はそれらの候補の共通部分です。 それ以外の場合、 &lt;code&gt;V&lt;/code&gt; の推定型は &lt;code&gt;never&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="149d602ff05c96e06423dc39ea5d234017f2a784" translate="yes" xml:space="preserve">
          <source>Next, if your version of Visual Studio does not already have the latest TypeScript, you can &lt;a href=&quot;https://www.typescriptlang.org/index.html#download-links&quot;&gt;install it&lt;/a&gt;.</source>
          <target state="translated">次に、Visual Studioバージョンに最新のTypeScriptがまだない場合は、 &lt;a href=&quot;https://www.typescriptlang.org/index.html#download-links&quot;&gt;インストール&lt;/a&gt;できます。</target>
        </trans-unit>
        <trans-unit id="074954ffe368a9f868383848acfd3ad865a34cf0" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s create an &lt;code&gt;index.tsx&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; with the following source:</source>
          <target state="translated">次に、次のソースを使用して、 &lt;code&gt;src&lt;/code&gt; に &lt;code&gt;index.tsx&lt;/code&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="56492bdb624437d084cf97ce29f5755c9355f32f" translate="yes" xml:space="preserve">
          <source>Next, we then use the class directly. Here we create a new variable called &lt;code&gt;greeterMaker&lt;/code&gt;. This variable will hold the class itself, or said another way its constructor function. Here we use &lt;code&gt;typeof Greeter&lt;/code&gt;, that is &amp;ldquo;give me the type of the &lt;code&gt;Greeter&lt;/code&gt; class itself&amp;rdquo; rather than the instance type. Or, more precisely, &amp;ldquo;give me the type of the symbol called &lt;code&gt;Greeter&lt;/code&gt;,&amp;rdquo; which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the &lt;code&gt;Greeter&lt;/code&gt; class. We show this by using &lt;code&gt;new&lt;/code&gt; on &lt;code&gt;greeterMaker&lt;/code&gt;, creating new instances of &lt;code&gt;Greeter&lt;/code&gt; and invoking them as before.</source>
          <target state="translated">次に、クラスを直接使用します。 次に、 &lt;code&gt;greeterMaker&lt;/code&gt; という新しい変数を作成します。 この変数は、クラス自体を保持するか、コンストラクター関数を保持します。 ここでは &lt;code&gt;typeof Greeter&lt;/code&gt; を使用します。 これはインスタンスタイプではありませんが、「 &lt;code&gt;Greeter&lt;/code&gt; クラス自体のタイプを指定してください」。 または、より正確には、「 &lt;code&gt;Greeter&lt;/code&gt; と呼ばれる記号の種類は何ですか？」 これは、コンストラクター関数のタイプです。 この型には、 &lt;code&gt;Greeter&lt;/code&gt; クラスのインスタンスを作成するコンストラクターと共に、Greeterのすべての静的メンバーが含まれます。 これを実証するには、 &lt;code&gt;greeterMaker&lt;/code&gt; で &lt;code&gt;new&lt;/code&gt; を使用し、 &lt;code&gt;Greeter&lt;/code&gt; の新しいインスタンスを作成して、以前のように呼び出します。</target>
        </trans-unit>
        <trans-unit id="48fd249b15120ba7e0e8c493ff3db4c13ad95d86" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll add development-time dependencies on the &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ts-loader&lt;/a&gt; and &lt;a href=&quot;https://www.npmjs.com/package/source-map-loader&quot;&gt;source-map-loader&lt;/a&gt;.</source>
          <target state="translated">次に、開発の依存関係&lt;a href=&quot;https://www.npmjs.com/package/source-map-loader&quot;&gt;を&lt;/a&gt; &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ts-loader&lt;/a&gt;およびsource-map-loaderに追加します。</target>
        </trans-unit>
        <trans-unit id="dc79aea4b8183b17aa2b08058010210e82ecc955" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create the class that will handle the combination of the two mixins. Let&amp;rsquo;s look at this in more detail to see how it does this:</source>
          <target state="translated">次に、2つのミックスインの組み合わせを処理するクラスを作成します。 これを詳しく見て、これがどのように行われるかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="3da6f66c39205de12c1b0ea85576f12a60c67429" translate="yes" xml:space="preserve">
          <source>Nightly Builds</source>
          <target state="translated">ナイトリービルド</target>
        </trans-unit>
        <trans-unit id="cb01bbc0b3a89a2f95960449dd66e5b7ab419b0c" translate="yes" xml:space="preserve">
          <source>Nightly Builds: Using NuGet with MSBuild</source>
          <target state="translated">ナイトリービルド：MSBuildでNuGetを使用する</target>
        </trans-unit>
        <trans-unit id="269472362c2cb3218dea4a230801c99606e84281" translate="yes" xml:space="preserve">
          <source>Nightly Builds: Using npm</source>
          <target state="translated">ナイトリービルド：npmの使用</target>
        </trans-unit>
        <trans-unit id="d29bc0fc428d8dd325a7aa22de797acf39705506" translate="yes" xml:space="preserve">
          <source>Nightly builds</source>
          <target state="translated">ナイトリービルド</target>
        </trans-unit>
        <trans-unit id="d7957143496bc3e4f3d8bec258d34ddbf9a66c00" translate="yes" xml:space="preserve">
          <source>No Implicit &lt;code&gt;any&lt;/code&gt;</source>
          <target state="translated">暗黙</target>
        </trans-unit>
        <trans-unit id="5a2211d43130f5295a9f394d970fa79e1787ca90" translate="yes" xml:space="preserve">
          <source>No Implicit &lt;code&gt;any&lt;/code&gt; for &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">これには暗黙的 &lt;code&gt;any&lt;/code&gt; はありません</target>
        </trans-unit>
        <trans-unit id="2b9fbfb21cfa0b34035ba18cef71091f735deb52" translate="yes" xml:space="preserve">
          <source>No type is a subtype of or assignable to &lt;code&gt;never&lt;/code&gt; (except &lt;code&gt;never&lt;/code&gt; itself).</source>
          <target state="translated">どのタイプもサブタイプでは &lt;code&gt;never&lt;/code&gt; 割り当てられません （割り当てられません ）。</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
        <trans-unit id="0dc5564786f44ffe5d739e06a70c0a346cb415f8" translate="yes" xml:space="preserve">
          <source>Non-function members of the interfaces should be unique. If they are not unique, they must be of the same type. The compiler will issue an error if the interfaces both declare a non-function member of the same name, but of different types.</source>
          <target state="translated">インターフェイスの非機能メンバーは一意でなければなりません。 一意でない場合は、同じタイプである必要があります。 両方のインターフェースが同じ名前で異なるタイプの非関数メンバーを宣言する場合、コンパイラーはエラーを発行します。</target>
        </trans-unit>
        <trans-unit id="1494b169c26da2fba5af5bb24c5a642f24c6c749" translate="yes" xml:space="preserve">
          <source>Non-generic spread expressions continue to be processed as before: Call and construct signatures are stripped, only non-method properties are preserved, and for properties with the same name, the type of the rightmost property is used. This contrasts with intersection types which concatenate call and construct signatures, preserve all properties, and intersect the types of properties with the same name. Thus, spreads of the same types may produce different results when they are created through instantiation of generic types:</source>
          <target state="translated">非汎用スプレッド式は、以前と同様に処理され続けます。 呼び出しと構成の署名は削除され、メソッド以外のプロパティのみが保持されます。 同じ名前のプロパティの場合、右端のプロパティのタイプが使用されます。 これは、署名を構築するために呼び出しを連結し、すべてのプロパティを保持し、同じ名前のプロパティのタイプを横断する交差タイプとは対照的です。 したがって、同じタイプのスプレッドは、ジェネリックタイプをインスタンス化して作成された場合、異なる結果を生成する場合があります。</target>
        </trans-unit>
        <trans-unit id="3f0cc9ae44503c7a979e12906895cd156851a3f6" translate="yes" xml:space="preserve">
          <source>Non-homomorphic types are essentially creating new properties, so they can&amp;rsquo;t copy property modifiers from anywhere.</source>
          <target state="translated">非ホモモーフは基本的に新しいプロパティを作成するため、どこからでもプロパティ修飾子をコピーできません。</target>
        </trans-unit>
        <trans-unit id="67964b3d04ccfc686f4aea422e7f8a00b96d652b" translate="yes" xml:space="preserve">
          <source>Non-null and non-undefined type guards</source>
          <target state="translated">非ヌルおよび未定義のタイプガード</target>
        </trans-unit>
        <trans-unit id="6dfb137ece21865c79297ea685dd84ed857ee8cd" translate="yes" xml:space="preserve">
          <source>Non-null and non-undefined type guards may use the &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;===&lt;/code&gt;, or &lt;code&gt;!==&lt;/code&gt; operator to compare to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, as in &lt;code&gt;x != null&lt;/code&gt; or &lt;code&gt;x === undefined&lt;/code&gt;. The effects on subject variable types accurately reflect JavaScript semantics (e.g. double-equals operators check for both values no matter which one is specified whereas triple-equals only checks for the specified value).</source>
          <target state="translated">非ヌルおよび未定義のタイプガードは &lt;code&gt;!=&lt;/code&gt; 、！ =、 &lt;code&gt;===&lt;/code&gt; 、または &lt;code&gt;!==&lt;/code&gt; 演算子を使用して、 &lt;code&gt;x != null&lt;/code&gt; または &lt;code&gt;x === undefined&lt;/code&gt; などの &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; と比較できます 。 サブジェクト変数の型への影響は、JavaScriptのセマンティクスを正確に反映します（たとえば、double equals演算子は、どちらが指定されているかに関係なく両方の値をチェックしますが、tripleはCheckのみに等しくなります）。</target>
        </trans-unit>
        <trans-unit id="1429182fce7f9a8560f2257cc03417f636cfd4e4" translate="yes" xml:space="preserve">
          <source>Non-null assertion operator</source>
          <target state="translated">NULL以外のアサーション演算子</target>
        </trans-unit>
        <trans-unit id="8c77d1fe01b3d6b896e59e7ad679a030f98eb254" translate="yes" xml:space="preserve">
          <source>Non-nullable types have no meaning and are treated just as their original type:</source>
          <target state="translated">null不可の型には意味がなく、元の型と同じように扱われます。</target>
        </trans-unit>
        <trans-unit id="eac50a4571700d4b796b3f2c2c60e4c14af40f6f" translate="yes" xml:space="preserve">
          <source>Non-unit types as union discriminants</source>
          <target state="translated">ユニオン判別型としての非ユニットタイプ</target>
        </trans-unit>
        <trans-unit id="80660f063a6440a3a7e05a18a3ba076eeaf007e6" translate="yes" xml:space="preserve">
          <source>NonNullable&amp;lt;T&amp;gt;</source>
          <target state="translated">NonNullable&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9e8dd4dc111ded7b2320e89d0f31eaa58c3daeae" translate="yes" xml:space="preserve">
          <source>Normally the compiler will attempt to resolve all module imports before it starts the compilation process. Every time it successfully resolves an &lt;code&gt;import&lt;/code&gt; to a file, the file is added to the set of files the compiler will process later on.</source>
          <target state="translated">通常、コンパイラーは、コンパイル処理を開始する前に、すべてのモジュールのインポートを解決しようとします。 ファイルへの &lt;code&gt;import&lt;/code&gt; が正常に解決されるたびに、コンパイラが後で処理するファイルのセットにファイルが追加されます。</target>
        </trans-unit>
        <trans-unit id="fa102d6a31f636b67a2c1043b2e52c1f1dd3e13e" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;tsc&lt;/code&gt; will produce outputs (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.d.ts&lt;/code&gt;) in the presence of syntax or type errors, unless &lt;code&gt;noEmitOnError&lt;/code&gt; is on. Doing this in an incremental build system would be very bad - if one of your out-of-date dependencies had a new error, you&amp;rsquo;d only see it &lt;em&gt;once&lt;/em&gt; because a subsequent build would skip building the now up-to-date project. For this reason, &lt;code&gt;tsc -b&lt;/code&gt; effectively acts as if &lt;code&gt;noEmitOnError&lt;/code&gt; is enabled for all projects.</source>
          <target state="translated">通常、 &lt;code&gt;tsc&lt;/code&gt; がオンでない限り、tscは構文エラーまたは型エラーの存在下で出力（ &lt;code&gt;.js&lt;/code&gt; および &lt;code&gt;.d.ts&lt;/code&gt; ）を生成します。 インクリメンタルビルドシステムでこれを行うのは非常に悪いことです。 古い依存関係の1つに新しいエラーがある場合、後続のビルドは最新のプロジェクトビルドをスキップし、 &lt;em&gt;一度&lt;/em&gt;だけ表示されます。 このため、すべてのプロジェクトでnoEmitOnErrorが有効になっているように、 &lt;code&gt;tsc -b&lt;/code&gt; &lt;code&gt;noEmitOnError&lt;/code&gt; を効果的に実行します。</target>
        </trans-unit>
        <trans-unit id="3d901c000076266c2726be52567eee3a9e906da5" translate="yes" xml:space="preserve">
          <source>Not all merges are allowed in TypeScript. Currently, classes can not merge with other classes or with variables. For information on mimicking class merging, see the &lt;a href=&quot;mixins&quot;&gt;Mixins in TypeScript&lt;/a&gt; section.</source>
          <target state="translated">TypeScriptですべてのマージが許可されているわけではありません。 現在、クラスを他のクラスまたは変数とマージすることはできません。 クラスのマージを模倣する方法については&lt;a href=&quot;mixins&quot;&gt;、TypeScript&lt;/a&gt;セクションのMixinsを参照してください。</target>
        </trans-unit>
        <trans-unit id="0fecf4145f603258529bada9dcd0bcbc05978112" translate="yes" xml:space="preserve">
          <source>Not all properties of an interface may be required. Some exist under certain conditions or may not be there at all. These optional properties are popular when creating patterns like &amp;ldquo;option bags&amp;rdquo; where you pass an object to a function that only has a couple of properties filled in.</source>
          <target state="translated">インターフェイスのすべてのプロパティが必要なわけではありません。 特定の条件下で存在するものもあれば、まったく存在しないものもあります。 これらのオプションのプロパティは、「オプションバッグ」などのパターンを作成するときによく使用されます。 このオプションバッグでは、いくつかのプロパティのみが入力されている関数にオブジェクトを渡します。</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="4738934001095b56c8ba017549da8753b92711d7" translate="yes" xml:space="preserve">
          <source>Note any tags which are not explicitly listed below (such as &lt;code&gt;@async&lt;/code&gt;) are not yet supported.</source>
          <target state="translated">以下に明示的にリストされていないタグ（ &lt;code&gt;@async&lt;/code&gt; など）はまだサポートされていません。</target>
        </trans-unit>
        <trans-unit id="034f4525d05999ff963000183c0ac076ec562336" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@enum&lt;/code&gt; is quite different from, and much simpler than, Typescript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt;. However, unlike Typescript&amp;rsquo;s enums, &lt;code&gt;@enum&lt;/code&gt; can have any type:</source>
          <target state="translated">&lt;code&gt;@enum&lt;/code&gt; は 、@ &lt;code&gt;enum&lt;/code&gt; はTypescript 列挙型とはまったく異なり、はるかに単純です。 ただし、 &lt;code&gt;@enum&lt;/code&gt; の列挙、@enumは任意の型を持つことができます。</target>
        </trans-unit>
        <trans-unit id="a50c9eb18039f11d764d2dd9c6139bfa5f2ed615" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@extends&lt;/code&gt; only works with classes. Currently, there is no way for a constructor function extend a class.</source>
          <target state="translated">&lt;code&gt;@extends&lt;/code&gt; はクラスでのみ機能することに注意してください。 現在、コンストラクター関数がクラスを拡張する方法はありません。</target>
        </trans-unit>
        <trans-unit id="8a0526a2b13316a828fc44ba4c43a0a7de6c3d55" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; are so useful, they are included in TypeScript&amp;rsquo;s standard library along with &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Record&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; および &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; は非常に便利で、 &lt;code&gt;Pick&lt;/code&gt; および &lt;code&gt;Record&lt;/code&gt; とともに標準のTypeScriptライブラリに含まれています。</target>
        </trans-unit>
        <trans-unit id="1258e6d6b1a495d8e56ed02d68cc95af53525487" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;y&lt;/code&gt; has an extra &lt;code&gt;location&lt;/code&gt; property, but this does not create an error. Only members of the target type (&lt;code&gt;Named&lt;/code&gt; in this case) are considered when checking for compatibility.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; には追加の &lt;code&gt;location&lt;/code&gt; プロパティがありますが、これはエラーを作成しないことに注意してください。 互換性をチェックする場合、ターゲットタイプのメンバー（この場合は &lt;code&gt;Named&lt;/code&gt; ）のみが考慮されます。</target>
        </trans-unit>
        <trans-unit id="52de29b3288a647d26453cfca4097defc33488b8" translate="yes" xml:space="preserve">
          <source>Note that TypeScript treats &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; differently in order to match JavaScript semantics. &lt;code&gt;string | null&lt;/code&gt; is a different type than &lt;code&gt;string | undefined&lt;/code&gt; and &lt;code&gt;string | undefined | null&lt;/code&gt;.</source>
          <target state="translated">TypeScriptは、JavaScriptセマンティクスと一致するように、 &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; を異なる方法で処理することに注意してください。 &lt;code&gt;string | null&lt;/code&gt; null nullは &lt;code&gt;string | undefined | null&lt;/code&gt; とは異なるタイプです| 未定義| null未定義および文字列| 未定義| null未定義| ヌル</target>
        </trans-unit>
        <trans-unit id="fad3fa5b17d28ad4ad1296cea04ea7aae98a3e8a" translate="yes" xml:space="preserve">
          <source>Note that as with &lt;code&gt;tsconfig.json&lt;/code&gt; / &lt;code&gt;-p&lt;/code&gt;, existing TypeScript project properties will not be respected - all settings should be managed using your tsconfig file.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; / &lt;code&gt;-p&lt;/code&gt; と同様に、既存のTypeScriptプロジェクトプロパティが尊重されないtsconfig.json。 すべての設定は、tsconfigファイルを使用して管理する必要があります。</target>
        </trans-unit>
        <trans-unit id="b588c9ab272861e6d668b1d11af54118f839ddd3" translate="yes" xml:space="preserve">
          <source>Note that global variables declared with &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; don&amp;rsquo;t show up on &lt;code&gt;globalThis&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; および &lt;code&gt;const&lt;/code&gt; で宣言されたグローバル変数は &lt;code&gt;globalThis&lt;/code&gt; には現れないことに注意してください 。</target>
        </trans-unit>
        <trans-unit id="f628326a2f77697a922d2fe82dda47c7b50dda0f" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;bar&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, our code will still hit an error accessing &lt;code&gt;baz&lt;/code&gt;. Likewise, if &lt;code&gt;baz&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, we&amp;rsquo;ll hit an error at the call site. &lt;code&gt;?.&lt;/code&gt; only checks for whether the value on the &lt;em&gt;left&lt;/em&gt; of it is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; - not any of the subsequent properties.</source>
          <target state="translated">&lt;code&gt;bar&lt;/code&gt; が &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; 場合、 &lt;code&gt;baz&lt;/code&gt; へのアクセス中にコードがエラーをヒットすることに注意してください。 同様に、 &lt;code&gt;baz&lt;/code&gt; が &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; の場合、呼び出しサイトでエラーが発生します。 &lt;code&gt;?.&lt;/code&gt; 次のプロパティではなく、 &lt;em&gt;左側&lt;/em&gt;の値が &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; であるかどうかのみをチェックします。</target>
        </trans-unit>
        <trans-unit id="9bc1e2dc91d339a1731d988771c4e0964ee425ef" translate="yes" xml:space="preserve">
          <source>Note that in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, when a homomorphic mapped type removes a &lt;code&gt;?&lt;/code&gt; modifier from a property in the underlying type it also removes &lt;code&gt;undefined&lt;/code&gt; from the type of that property:</source>
          <target state="translated">&lt;code&gt;--strictNullChecks&lt;/code&gt; モードでは、準同型が削除されることに注意してください。 基になる型のプロパティから修飾子を変更すると、プロパティ型から &lt;code&gt;undefined&lt;/code&gt; も削除されます。</target>
        </trans-unit>
        <trans-unit id="eea4e2c81bc66e020338b949c3e934f29a66e808" translate="yes" xml:space="preserve">
          <source>Note that in TypeScript 1.4, when accessing an element outside the set of known indices, a union type is used instead:</source>
          <target state="translated">TypeScript 1.4は、代わりに共用体型を使用して、既知のインデックスのセット外の要素にアクセスすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="739942391df257a53a10ec2f75e3c9725103c615" translate="yes" xml:space="preserve">
          <source>Note that in this example, we added a value to the &lt;em&gt;static&lt;/em&gt; side of &lt;code&gt;C&lt;/code&gt; (its constructor function). This is because we added a &lt;em&gt;value&lt;/em&gt;, and the container for all values is another value (types are contained by namespaces, and namespaces are contained by other namespaces).</source>
          <target state="translated">この例では、 &lt;code&gt;C&lt;/code&gt; の&lt;em&gt;静的&lt;/em&gt;側（コンストラクター関数）に値を追加していることに注意してください。 これは、値を追加し、すべての値のコンテナが別の値であるためです（タイプはネームスペースに含まれ、ネームスペースは他のネームスペースに含まれます）。</target>
        </trans-unit>
        <trans-unit id="d0af180e34bef9f30805628b530dfa3020972dea" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s possible to define many types in the global scope when writing a global declaration file. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.</source>
          <target state="translated">グローバル宣言ファイルを作成する場合、多くの型をグローバルスコープで定義できることに注意してください。 未解決の名前の競合が発生する可能性があるため、プロジェクトに多くの宣言ファイルがある場合、これを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="907347b9fd2f8faa12df54e188fdcc427177ea81" translate="yes" xml:space="preserve">
          <source>Note that parentheses are optional for union types.</source>
          <target state="translated">括弧はユニオン型ではオプションであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4fabbe755152dc7983d25e5f9f36d98457b37c5e" translate="yes" xml:space="preserve">
          <source>Note that partial overlap is still permitted as long as the property types are valid.</source>
          <target state="translated">プロパティタイプが有効である限り、部分的なオーバーラップは引き続き許可されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="cc68887371a320bc99d4047b11fa95c7b5bed915" translate="yes" xml:space="preserve">
          <source>Note that relative module imports are not impacted by setting the baseUrl, as they are always resolved relative to their importing files.</source>
          <target state="translated">相対モジュールのインポートはbaseUrl設定の影響を受けないことに注意してください。 これは、インポートされるファイルに対して常に解決されるためです。</target>
        </trans-unit>
        <trans-unit id="7f7166fe564b0ad642ff41fe82fc874132e2ab74" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&quot;typings&quot;&lt;/code&gt; field is synonymous with &lt;code&gt;&quot;types&quot;&lt;/code&gt;, and could be used as well.</source>
          <target state="translated">&lt;code&gt;&quot;typings&quot;&lt;/code&gt; フィールドは「types」と同義であり、同様に使用できます。</target>
        </trans-unit>
        <trans-unit id="4b2efe58a5ebfdb3d94ff74e3c4e2bfaf07628f5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;function pickCard(x): any&lt;/code&gt; piece is not part of the overload list, so it only has two overloads: one that takes an object and one that takes a number. Calling &lt;code&gt;pickCard&lt;/code&gt; with any other parameter types would cause an error.</source>
          <target state="translated">&lt;code&gt;function pickCard(x): any&lt;/code&gt; ピースはオーバーロードリストの一部ではありません。2つのオーバーロードのみがあり、1つはオブジェクトを受け取り、もう1つは番号を受け取ります。 他のパラメータタイプで &lt;code&gt;pickCard&lt;/code&gt; を呼び出すと、エラーが生成されます。</target>
        </trans-unit>
        <trans-unit id="d805d68393f371b58b5632620fd80bca6ffff116" translate="yes" xml:space="preserve">
          <source>Note that this collapsing should only occur when all overloads have the same return type.</source>
          <target state="translated">この折りたたみは、すべてのオーバーロードが同じ値を返す場合にのみ発生することに注意してください。</target>
        </trans-unit>
        <trans-unit id="067bba3132c520df5de825dbb6713533d577f153" translate="yes" xml:space="preserve">
          <source>Note that this does not imply tuples represent immutable arrays, but it is an implied convention.</source>
          <target state="translated">これは、タプルが不変配列を表すことを意味するものではなく、暗黙のルールであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="00c87ccc96ac44dfdeaad5b5ee7925bc2c9a2141" translate="yes" xml:space="preserve">
          <source>Note that this is a breaking change for some code. If you need to resort to the original behavior in which tuples only enforce a minimum length, you can use a similar declaration that does not explicitly define a &lt;code&gt;length&lt;/code&gt; property, falling back to &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">これは一部のコードの重大な変更であることに注意してください。 タプルが最小長のみを強制するという元の動作に依存する必要がある場合は、 &lt;code&gt;length&lt;/code&gt; プロパティを明示的に定義せずに &lt;code&gt;number&lt;/code&gt; フォールバックする同様の宣言を使用できます。</target>
        </trans-unit>
        <trans-unit id="2da7ac7b1000043c557ae42f5143ae70cebcc452" translate="yes" xml:space="preserve">
          <source>Note that this syntax describes a type rather than a member. If you want to add members, you can use an intersection type:</source>
          <target state="translated">この構文は、メンバーではなく型を記述することに注意してください。 メンバーを追加するときに、交差タイプを使用できます。</target>
        </trans-unit>
        <trans-unit id="24ee265701152c1f723e8f2dfcc2a5432fb8e8f0" translate="yes" xml:space="preserve">
          <source>Note that this unwrapping inference only works on homomorphic mapped types. If the mapped type is not homomorphic you&amp;rsquo;ll have to give an explicit type parameter to your unwrapping function.</source>
          <target state="translated">このアンラップ推論は準同型マッピングタイプでのみ機能することに注意してください。 マップされた型が準同型でない場合は、unwrap関数の明示的な型パラメーターを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="eead77930da9ed7756b7450464191e29579bb786" translate="yes" xml:space="preserve">
          <source>Note that we cannot add to type aliases (&lt;code&gt;type s = string;&lt;/code&gt;) using an interface.</source>
          <target state="translated">インターフェイスを使用して、タイプエイリアス（ &lt;code&gt;type s = string;&lt;/code&gt; ）に追加できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a04a128b4126a71144c52f15a922d0f362febded" translate="yes" xml:space="preserve">
          <source>Note that we currently only support discriminant properties of string literal types. We intend to later add support for boolean and numeric literal types.</source>
          <target state="translated">現在、文字列リテラル識別プロパティのみをサポートしていることに注意してください。 ブールおよび数値リテラルタイプのサポートは後で追加します。</target>
        </trans-unit>
        <trans-unit id="8866bd22d60ec16a512c3e18fc8883ee9088f218" translate="yes" xml:space="preserve">
          <source>Note that we didn&amp;rsquo;t make &lt;code&gt;b&lt;/code&gt; optional here because the return types of the signatures differ.</source>
          <target state="translated">署名の戻り値の型が異なるため、ここで &lt;code&gt;b&lt;/code&gt; はオプションではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="94ec1d6aab212f5e757f0e4659331e046f79564c" translate="yes" xml:space="preserve">
          <source>Note that when a tuple type is inferred from a sequence of parameters and later expanded into a parameter list, as is the case for &lt;code&gt;U&lt;/code&gt;, the original parameter names are used in the expansion (however, the names have no semantic meaning and are not otherwise observable).</source>
          <target state="translated">&lt;code&gt;U&lt;/code&gt; の場合のように、タプル型が一連のパラメーターから推測され、後でパラメーターリストに展開される場合、元のパラメーター名が展開で使用されることに注意してください（ただし、名前には意味のない意味があります）</target>
        </trans-unit>
        <trans-unit id="71b62ae2aa2aff8c7c71bbad8ff17968c2580e86" translate="yes" xml:space="preserve">
          <source>Note that when using these flags together, TypeScript doesn&amp;rsquo;t necessarily have to downlevel &lt;code&gt;.js&lt;/code&gt; files. If you simply want TypeScript to create &lt;code&gt;.d.ts&lt;/code&gt; files, you can use the &lt;code&gt;--emitDeclarationOnly&lt;/code&gt; compiler option.</source>
          <target state="translated">これらのフラグを一緒に使用する場合、TypeScriptは必ずしも &lt;code&gt;.js&lt;/code&gt; ファイルを必要としないことに注意してください。 TypeScriptで &lt;code&gt;--emitDeclarationOnly&lt;/code&gt; ファイルを作成する場合は、-emitDeclarationOnlyコンパイラオプションを使用できます。</target>
        </trans-unit>
        <trans-unit id="d88437440fe56ffd946a572ef7fc0f549aafede2" translate="yes" xml:space="preserve">
          <source>Note that while this example uses &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;function components&lt;/a&gt;, we could also make our example a little &lt;em&gt;classier&lt;/em&gt; as well.</source>
          <target state="translated">この例では&lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;機能的なコンポーネントを&lt;/a&gt;使用していますが、例をより&lt;em&gt;エレガントに&lt;/em&gt;することができます。</target>
        </trans-unit>
        <trans-unit id="f4126eba79591c06a88ec80a2218d901b6a7fced" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; targets latest supported</source>
          <target state="translated">注： &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; は、サポートされている最新バージョン用です</target>
        </trans-unit>
        <trans-unit id="00f6312a7e060d93f44452f049fdc1698e20c055" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; targets latest supported &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES proposed features&lt;/a&gt;.</source>
          <target state="translated">注： &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; は、サポートされている最新のES提案機能が含まれます。</target>
        </trans-unit>
        <trans-unit id="eff587a71ddbf90b7c884baa1aa1a82827ace5dd" translate="yes" xml:space="preserve">
          <source>Note: Avoid using &lt;code&gt;Object&lt;/code&gt; in favor of the non-primitive &lt;code&gt;object&lt;/code&gt; type as described in our &lt;a href=&quot;declaration-files/do-s-and-don-ts#general-types&quot;&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt; section.</source>
          <target state="translated">注：「 &lt;a href=&quot;declaration-files/do-s-and-don-ts#general-types&quot;&gt;Dos and Don'ts&lt;/a&gt; 」セクションで説明されているように、非プリミティブ &lt;code&gt;object&lt;/code&gt; タイプを優先して &lt;code&gt;Object&lt;/code&gt; を使用しないでください。</target>
        </trans-unit>
        <trans-unit id="c1444747b0861651e319b205e1c59d9ae374ba31" translate="yes" xml:space="preserve">
          <source>Note: Function Components were formerly known as Stateless Function Components (SFC). As Function Components can no longer be considered stateless in recent versions of react, the type &lt;code&gt;SFC&lt;/code&gt; and its alias &lt;code&gt;StatelessComponent&lt;/code&gt; were deprecated.</source>
          <target state="translated">注：関数コンポーネントは、以前はステートレス関数コンポーネント（SFC）として知られていました。 関数コンポーネントはステートレスと見なすことができないため、 &lt;code&gt;SFC&lt;/code&gt; タイプとそのエイリアス &lt;code&gt;StatelessComponent&lt;/code&gt; は、Reactの最近のバージョンで非推奨になりました。</target>
        </trans-unit>
        <trans-unit id="2167c13fca90fe94989b38585bc930d77ebf1308" translate="yes" xml:space="preserve">
          <source>Note: If &lt;code&gt;--lib&lt;/code&gt; is not specified a default list of libraries are injected. The default libraries injected are:</source>
          <target state="translated">注：-- &lt;code&gt;--lib&lt;/code&gt; が指定されていない場合、ライブラリのデフォルトリストが挿入されます。 挿入されるデフォルトのライブラリは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="284acafdfa85eadac42feff0fa8aca15b6a97293" translate="yes" xml:space="preserve">
          <source>Note: If an attribute name is not a valid JS identifier (like a &lt;code&gt;data-*&lt;/code&gt; attribute), it is not considered to be an error if it is not found in the element attributes type.</source>
          <target state="translated">注：属性名が有効なJS識別子（ &lt;code&gt;data-*&lt;/code&gt; 属性など）ではなく、要素の属性タイプで見つからない場合、エラーとは見なされません。</target>
        </trans-unit>
        <trans-unit id="e941b79a012efff59ecdd0cbaa4fcd9aa032b565" translate="yes" xml:space="preserve">
          <source>Note: Most changes do not require you to install a new version of the VS TypeScript plugin.</source>
          <target state="translated">注：ほとんどの変更では、VS TypeScriptプラグインの新しいバージョンをインストールする必要はありません。</target>
        </trans-unit>
        <trans-unit id="70970313d46e20ac27b9140a27eba7644c3d73af" translate="yes" xml:space="preserve">
          <source>Note: Previous syntax defining internal modules are still supported.</source>
          <target state="translated">注：内部モジュールを定義するための以前の構文は引き続きサポートされています。</target>
        </trans-unit>
        <trans-unit id="98d80fe98cbbdfa6ce68828aed81191aecaa3aa8" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;Exclude&lt;/code&gt; type is a proper implementation of the &lt;code&gt;Diff&lt;/code&gt; type suggested &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;here&lt;/a&gt;. We&amp;rsquo;ve used the name &lt;code&gt;Exclude&lt;/code&gt; to avoid breaking existing code that defines a &lt;code&gt;Diff&lt;/code&gt;, plus we feel that name better conveys the semantics of the type.</source>
          <target state="translated">注： &lt;code&gt;Exclude&lt;/code&gt; タイプは、 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;ここで&lt;/a&gt;提案されている &lt;code&gt;Diff&lt;/code&gt; タイプの適切な実装です 。 &lt;code&gt;Diff&lt;/code&gt; を定義する既存のコードを壊さないように &lt;code&gt;Exclude&lt;/code&gt; という名前を使用し、名前が型のセマンティクスをよりよく伝えていると感じています。</target>
        </trans-unit>
        <trans-unit id="3b301e8bc42764dd4dd4644d5e8e453ac7e989ae" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;Exclude&lt;/code&gt; type is a proper implementation of the &lt;code&gt;Diff&lt;/code&gt; type suggested &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;here&lt;/a&gt;. We&amp;rsquo;ve used the name &lt;code&gt;Exclude&lt;/code&gt; to avoid breaking existing code that defines a &lt;code&gt;Diff&lt;/code&gt;, plus we feel that name better conveys the semantics of the type. We did not include the &lt;code&gt;Omit&amp;lt;T, K&amp;gt;&lt;/code&gt; type because it is trivially written as &lt;code&gt;Pick&amp;lt;T, Exclude&amp;lt;keyof T, K&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">注： &lt;code&gt;Exclude&lt;/code&gt; タイプは、 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;ここで&lt;/a&gt;提案されている &lt;code&gt;Diff&lt;/code&gt; タイプの適切な実装です 。 &lt;code&gt;Diff&lt;/code&gt; を定義する既存のコードを壊さないように &lt;code&gt;Exclude&lt;/code&gt; という名前を使用し、名前が型のセマンティクスをよりよく伝えていると感じています。 &lt;code&gt;Omit&amp;lt;T, K&amp;gt;&lt;/code&gt; タイプは、 &lt;code&gt;Pick&amp;lt;T, Exclude&amp;lt;keyof T, K&amp;gt;&amp;gt;&lt;/code&gt; 簡単に説明されているため、含まれていません。</target>
        </trans-unit>
        <trans-unit id="890949cc49cb65675bbdc6a302bba418a9f75399" translate="yes" xml:space="preserve">
          <source>Note: The new behavior is added under a flag to avoid unwarranted breaks to existing code bases. &lt;strong&gt;We highly recommend applying it both to new and existing projects.&lt;/strong&gt; For existing projects, namespace imports (&lt;code&gt;import * as express from &quot;express&quot;; express();&lt;/code&gt;) will need to be converted to default imports (&lt;code&gt;import express from &quot;express&quot;; express();&lt;/code&gt;).</source>
          <target state="translated">注：フラグの下に新しい動作が追加され、既存のコードベースへの過度の中断を回避します。 &lt;strong&gt;新規プロジェクトと既存プロジェクトの両方に適用することを強くお勧めします。&lt;/strong&gt; 既存のプロジェクトの場合、名前空間のインポート（ &lt;code&gt;import * as express from &quot;express&quot;; express();&lt;/code&gt; ）をデフォルトのインポート（ &lt;code&gt;import express from &quot;express&quot;; express();&lt;/code&gt; ）に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="1ed11ffc3601c3d16f34bfee2955149b8374ad13" translate="yes" xml:space="preserve">
          <source>Note: This change brings a new emit helper, &lt;code&gt;__makeTemplateObject&lt;/code&gt;; if you are using &lt;code&gt;--importHelpers&lt;/code&gt; with &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt;, an updated to version 1.8 or later.</source>
          <target state="translated">注：この変更に伴い、新しい &lt;code&gt;__makeTemplateObject&lt;/code&gt; ヘルパー__makeTemplateObjectが追加されました。 &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt;で &lt;code&gt;--importHelpers&lt;/code&gt; を使用している場合、バージョン1.8以降に更新されます。</target>
        </trans-unit>
        <trans-unit id="f9c2b580006a52af1ed6b77bbd97ca85b4b1524b" translate="yes" xml:space="preserve">
          <source>Note: This type only works correctly if &lt;code&gt;--strictFunctionTypes&lt;/code&gt; is enabled. See &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/32964&quot;&gt;#32964&lt;/a&gt;.</source>
          <target state="translated">注：このタイプは、 &lt;code&gt;--strictFunctionTypes&lt;/code&gt; が有効な場合にのみ正しく機能します。 &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/32964&quot;&gt;＃32964を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="df7f583105fdd881893e583d6f13dbb72c16aa47" translate="yes" xml:space="preserve">
          <source>Note: You can also specify a catch-all string indexer on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; as follows:</source>
          <target state="translated">注：次のように、 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; でキャッチオール文字列インデクサーを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="86b84c8f5ebae0249a61b0e8be7e70f077917ea7" translate="yes" xml:space="preserve">
          <source>Note: You&amp;rsquo;ll need to configure your project to use the NuGet packages. Please see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet&quot;&gt;Configuring MSBuild projects to use NuGet&lt;/a&gt; for more information.</source>
          <target state="translated">注：NuGetパッケージを使用するには、プロジェクトを構成する必要があります。 詳細については&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet&quot;&gt;、&lt;/a&gt; NuGetを使用するためのMSBuildプロジェクトの構成を参照してください。</target>
        </trans-unit>
        <trans-unit id="428e262209f33a2ca2447240e01cc6cf696d81da" translate="yes" xml:space="preserve">
          <source>Note: first, we need to make sure our run-time has an ECMAScript-compliant &lt;code&gt;Promise&lt;/code&gt; available globally. That might involve grabbing &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;a polyfill&lt;/a&gt; for &lt;code&gt;Promise&lt;/code&gt;, or relying on one that you might have in the run-time that you&amp;rsquo;re targeting. We also need to make sure that TypeScript knows &lt;code&gt;Promise&lt;/code&gt; exists by setting your &lt;code&gt;lib&lt;/code&gt; flag to something like &lt;code&gt;&quot;dom&quot;, &quot;es2015&quot;&lt;/code&gt; or &lt;code&gt;&quot;dom&quot;, &quot;es2015.promise&quot;, &quot;es5&quot;&lt;/code&gt;</source>
          <target state="translated">注：最初に、ECMAScript準拠の &lt;code&gt;Promise&lt;/code&gt; を実行時にグローバルに利用可能にする必要があります。 これを行うには、promiseポリフィルを取得するか、ターゲットランタイムで持っているポリフィルに依存する&lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;必要があり&lt;/a&gt;ます。 また、 &lt;code&gt;lib&lt;/code&gt; フラグを &lt;code&gt;&quot;dom&quot;, &quot;es2015&quot;&lt;/code&gt; または &lt;code&gt;&quot;dom&quot;, &quot;es2015.promise&quot;, &quot;es5&quot;&lt;/code&gt; などに設定して、TypeScriptがpromiseの存在をチェックするようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="8ccce25f4f717ae800fc16f144d50c248273d87f" translate="yes" xml:space="preserve">
          <source>Note: if the declaration file you are searching for is not present, you can always contribute one back and help out the next developer looking for it. Please see the DefinitelyTyped &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt; for details.</source>
          <target state="translated">注：探している宣言ファイルが存在しない場合は、いつでも投稿でき、次の開発者がそれを探しているときに役立ちます。 詳細については、DefinitelyTyped &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;Submission Guidelinesページ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7e6e74755e762c4957a748b815736bf13786cbb4" translate="yes" xml:space="preserve">
          <source>Notice how we dropped &lt;code&gt;theName&lt;/code&gt; altogether and just use the shortened &lt;code&gt;readonly name: string&lt;/code&gt; parameter on the constructor to create and initialize the &lt;code&gt;name&lt;/code&gt; member. We&amp;rsquo;ve consolidated the declarations and assignment into one location.</source>
          <target state="translated">&lt;code&gt;theName&lt;/code&gt; を完全に削除し、コンストラクターで短縮された &lt;code&gt;readonly name: string&lt;/code&gt; パラメーターを使用して &lt;code&gt;name&lt;/code&gt; メンバーを作成および初期化します 。 宣言と割り当てを1か所にまとめました。</target>
        </trans-unit>
        <trans-unit id="6a85b01a3af32d42a46518c09152775637f852de" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;T&lt;/code&gt; has been propagated from &lt;code&gt;makeArray&lt;/code&gt; into the resulting type&amp;rsquo;s type parameter list. This means that genericity from &lt;code&gt;compose&lt;/code&gt;&amp;rsquo;s arguments has been preserved and our &lt;code&gt;makeBoxedArray&lt;/code&gt; sample will just work!</source>
          <target state="translated">&lt;code&gt;makeArray&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; は、makeArrayから結果型の型パラメーターリストに伝達されます。 これは、 &lt;code&gt;compose&lt;/code&gt; 引数の汎用性が保持され、 &lt;code&gt;makeBoxedArray&lt;/code&gt; サンプルが機能することを意味します！</target>
        </trans-unit>
        <trans-unit id="a26aafd348bc0fd9af2fe643fb8a471bed279231" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;T&lt;/code&gt; has the additional constraint &lt;code&gt;any[]&lt;/code&gt; within the true branch of &lt;code&gt;Boxed&amp;lt;T&amp;gt;&lt;/code&gt; and it is therefore possible to refer to the element type of the array as &lt;code&gt;T[number]&lt;/code&gt;. Also, notice how the conditional type is distributed over the union type in the last example.</source>
          <target state="translated">&lt;code&gt;T[number]&lt;/code&gt; は &lt;code&gt;Boxed&amp;lt;T&amp;gt;&lt;/code&gt; 真のブランチに追加の制約 &lt;code&gt;any[]&lt;/code&gt; があるため、配列の要素タイプをT [number]として参照できることに注意してください。 また、最後の例の条件タイプが共用体タイプにどのように分散されているかに注目してください。</target>
        </trans-unit>
        <trans-unit id="10af1f3e49765726e808fd41e23133e1c2a4e7ed" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;createCardPicker&lt;/code&gt; is a function that itself returns a function. If we tried to run the example, we would get an error instead of the expected alert box. This is because the &lt;code&gt;this&lt;/code&gt; being used in the function created by &lt;code&gt;createCardPicker&lt;/code&gt; will be set to &lt;code&gt;window&lt;/code&gt; instead of our &lt;code&gt;deck&lt;/code&gt; object. That&amp;rsquo;s because we call &lt;code&gt;cardPicker()&lt;/code&gt; on its own. A top-level non-method syntax call like this will use &lt;code&gt;window&lt;/code&gt; for &lt;code&gt;this&lt;/code&gt;. (Note: under strict mode, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; rather than &lt;code&gt;window&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;createCardPicker&lt;/code&gt; であるcreateCardPickerは、それ自体が関数を返す関数です。 この例を実行しようとすると、予想される警告ボックスの代わりにエラーが表示されます。 これは、 &lt;code&gt;createCardPicker&lt;/code&gt; によって作成された関数で使用されるこれが、 &lt;code&gt;deck&lt;/code&gt; オブジェクトではなく &lt;code&gt;window&lt;/code&gt; に設定されているためです。 &lt;code&gt;cardPicker()&lt;/code&gt; 独立して呼び出すためです。 このようなトップレベルの非メソッド構文呼び出しは、このために &lt;code&gt;window&lt;/code&gt; を使用します 。 （注：strictモードでは、 &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;undefined&lt;/code&gt; であり、 &lt;code&gt;window&lt;/code&gt; ではありません）。</target>
        </trans-unit>
        <trans-unit id="763a205d6a7b4e6716dbfe0467c7193103f61a5d" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;uglify&lt;/code&gt; itself has just one call &amp;mdash; the calls to &lt;code&gt;buffer&lt;/code&gt; and &lt;code&gt;sourcemaps&lt;/code&gt; exist to make sure sourcemaps keep working. These calls give us a separate sourcemap file instead of using inline sourcemaps like before. Now you can run Gulp and check that &lt;code&gt;bundle.js&lt;/code&gt; does get minified into an unreadable mess:</source>
          <target state="translated">&lt;code&gt;uglify&lt;/code&gt; 自体への呼び出しは1つだけであることに注意してください。 &lt;code&gt;buffer&lt;/code&gt; するソースマップとソースマップは、ソースマップを機能させるために存在します。 これらの呼び出しは、以前のようにインラインソースマップを使用する代わりに、個別のソースマップファイルを提供します。 &lt;code&gt;bundle.js&lt;/code&gt; を使用すると、bundle.jsを実行して、bundle.jsが読み取り不能な混乱に陥らないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="9840073ae62b539ce3e1ebbfd27d812a30288a78" translate="yes" xml:space="preserve">
          <source>Notice that Node.js jumped up a directory in steps (4) and (7).</source>
          <target state="translated">Node.jsは、手順（4）および（7）でディレクトリをジャンプしたことに注意してください。</target>
        </trans-unit>
        <trans-unit id="ab4bf996704c0896075b225907ab9de7984c49ba" translate="yes" xml:space="preserve">
          <source>Notice that TypeScript not only knows that &lt;code&gt;pet&lt;/code&gt; is a &lt;code&gt;Fish&lt;/code&gt; in the &lt;code&gt;if&lt;/code&gt; branch; it also knows that in the &lt;code&gt;else&lt;/code&gt; branch, you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; have a &lt;code&gt;Fish&lt;/code&gt;, so you must have a &lt;code&gt;Bird&lt;/code&gt;.</source>
          <target state="translated">TypeScriptは、 &lt;code&gt;pet&lt;/code&gt; が &lt;code&gt;if&lt;/code&gt; ブランチの &lt;code&gt;Fish&lt;/code&gt; であることを認識するだけではないことに注意してください。 また、 &lt;code&gt;else&lt;/code&gt; ブランチには &lt;code&gt;Fish&lt;/code&gt; がないため、 &lt;code&gt;Bird&lt;/code&gt; が必要であることがわかります。</target>
        </trans-unit>
        <trans-unit id="cb0aa408a6fabdf5fe7f3f24ac365f674b565f27" translate="yes" xml:space="preserve">
          <source>Notice that although there were errors, the &lt;code&gt;greeter.js&lt;/code&gt; file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.</source>
          <target state="translated">エラーがありましたが、 &lt;code&gt;greeter.js&lt;/code&gt; ファイルはまだ作成されていることに注意してください。 コードにエラーがある場合でも、TypeScriptを使用できます。 ただし、この場合、TypeScriptはコードが期待どおりに実行されない可能性があることを警告します。</target>
        </trans-unit>
        <trans-unit id="f262e26dd39e3b5a66a391868d3fb9f6d6e5738f" translate="yes" xml:space="preserve">
          <source>Notice that even though we used ES2015 module syntax, TypeScript emitted CommonJS modules that Node uses. We&amp;rsquo;ll stick with CommonJS for this tutorial, but you could set &lt;code&gt;module&lt;/code&gt; in the options object to change this.</source>
          <target state="translated">ES2015モジュールの構文を使用しているにもかかわらず、TypeScriptはNodeが使用するCommonJSモジュールを発行したことに注意してください。 このチュートリアルではCommonJSを使用し &lt;code&gt;module&lt;/code&gt; が、オプションオブジェクトでモジュールを設定することでこれを変更できます。</target>
        </trans-unit>
        <trans-unit id="6426330771f7083cfd35796802456c49f5b66b69" translate="yes" xml:space="preserve">
          <source>Notice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use &lt;code&gt;GenericIdentityFn&lt;/code&gt;, we now will also need to specify the corresponding type argument (here: &lt;code&gt;number&lt;/code&gt;), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.</source>
          <target state="translated">この例はわずかに変更されていることに注意してください。 ジェネリック関数を記述する代わりに、ジェネリック型の一部である非ジェネリック関数シグネチャがあります。 &lt;code&gt;GenericIdentityFn&lt;/code&gt; を使用してGenericIdentityFn、対応する型引数（ここでは &lt;code&gt;number&lt;/code&gt; ）も指定する必要があります。 これにより、基になるコールシグネチャが使用するものが効果的にロックされます。 型パラメーターを呼び出しシグネチャに直接配置するタイミングと、インターフェース自体に配置するタイミングを理解することは、型のどの側面が一般的であるかを説明するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="9bb1da98b82bb82ebbe555bd6d19c0a036a3fa15" translate="yes" xml:space="preserve">
          <source>Notice that the elements of each group maintains the same order, but the groups themselves are merged with later overload sets ordered first.</source>
          <target state="translated">各グループの要素は同じ順序を維持しますが、グループ自体は最初に順序付けされた後、オーバーロードされたセットとマージされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="765da565a7c17cfcf3312a5eda7111c42ee0f02e" translate="yes" xml:space="preserve">
          <source>Notice that we didn&amp;rsquo;t have to explicitly pass the type in the angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;); the compiler just looked at the value &lt;code&gt;&quot;myString&quot;&lt;/code&gt;, and set &lt;code&gt;T&lt;/code&gt; to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.</source>
          <target state="translated">型を山括弧（ &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ）で明示的に渡す必要がないことに注意してください。 コンパイラは値 &lt;code&gt;&quot;myString&quot;&lt;/code&gt; を参照し、 &lt;code&gt;T&lt;/code&gt; をそのタイプに設定しました。 型引数の推論は、コードを短くして読みやすくするのに役立つツールですが、より複雑な例で発生する可能性があるため、前の例のように、コンパイラが型の推論に失敗した場合、明示的に型引数を渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="e2786dc0fc7753238adaa3b182c5756666dbd537" translate="yes" xml:space="preserve">
          <source>Notice that we don&amp;rsquo;t use the &lt;code&gt;require&lt;/code&gt; keyword; instead we assign directly from the qualified name of the symbol we&amp;rsquo;re importing. This is similar to using &lt;code&gt;var&lt;/code&gt;, but also works on the type and namespace meanings of the imported symbol. Importantly, for values, &lt;code&gt;import&lt;/code&gt; is a distinct reference from the original symbol, so changes to an aliased &lt;code&gt;var&lt;/code&gt; will not be reflected in the original variable.</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; キーワードを使用しないことに注意してください。 代わりに、インポートするシンボルの修飾名から直接割り当てます。 これは &lt;code&gt;var&lt;/code&gt; の使用に似ていますが、インポートされたシンボルタイプとネームスペースの観点でも機能します。 重要なのは、値の場合、 &lt;code&gt;import&lt;/code&gt; は元のシンボルへの別個の参照であるため、エイリアス変数の変更は元の変数に反映されないことです。</target>
        </trans-unit>
        <trans-unit id="5474e3c4f0295fff5cf94b925d396e756aa6518e" translate="yes" xml:space="preserve">
          <source>Notice that we had to surround this statement with parentheses. JavaScript normally parses a &lt;code&gt;{&lt;/code&gt; as the start of block.</source>
          <target state="translated">このステートメントは括弧で囲む必要があることに注意してください。 JavaScriptは通常、 &lt;code&gt;{&lt;/code&gt; をブロックの開始として解析します。</target>
        </trans-unit>
        <trans-unit id="f3a80c95c92964743c3a7674b186fd203447952a" translate="yes" xml:space="preserve">
          <source>Notice that we had to use type assertions several times. It would be much better if once we performed the check, we could know the type of &lt;code&gt;pet&lt;/code&gt; within each branch.</source>
          <target state="translated">型アサーションは数回使用する必要があることに注意してください。 チェックを実行したら、各ブランチの &lt;code&gt;pet&lt;/code&gt; のタイプを知ることができれば、はるかに良いでしょう。</target>
        </trans-unit>
        <trans-unit id="f1d22a5b64c25dc62cca8b1fc9ad531fb98be848" translate="yes" xml:space="preserve">
          <source>Notice that we installed TypeScript as a development dependency. We could also have linked TypeScript to a global copy with &lt;code&gt;npm link typescript&lt;/code&gt;, but this is a less common scenario.</source>
          <target state="translated">TypeScriptは開発の依存関係としてインストールされていることに注意してください。 &lt;code&gt;npm link typescript&lt;/code&gt; を使用してTypeScriptをグローバルコピーにリンクすることもできますが、これはあまり一般的ではないシナリオです。</target>
        </trans-unit>
        <trans-unit id="e83cd308da6a35cefd1d54ccc96691cc920beea5" translate="yes" xml:space="preserve">
          <source>Notice that we specified &lt;code&gt;debug: true&lt;/code&gt; to Browserify. This causes tsify to emit source maps inside the bundled JavaScript file. Source maps let you debug your original TypeScript code in the browser instead of the bundled JavaScript. You can test that source maps are working by opening the debugger for your browser and putting a breakpoint inside &lt;code&gt;main.ts&lt;/code&gt;. When you refresh the page the breakpoint should pause the page and let you debug &lt;code&gt;greet.ts&lt;/code&gt;.</source>
          <target state="translated">Browserifyに対して &lt;code&gt;debug: true&lt;/code&gt; を指定したことに注意してください。 これにより、tsifyはバンドルされたJavaScriptファイルにソースマップを出力します。 ソースマップを使用すると、バンドルされたJavaScriptの代わりに、ブラウザーで元のTypeScriptコードをデバッグできます。 ブラウザデバッガーを開き、main.tsにブレークポイントを配置することにより、ソースマップが &lt;code&gt;main.ts&lt;/code&gt; であることをテストできます。 ページを更新すると、ブレークポイントはページを一時停止し、 &lt;code&gt;greet.ts&lt;/code&gt; をデバッグできるようにします。</target>
        </trans-unit>
        <trans-unit id="67d48d2666a5c7a992a5ba5ca0e49f58d31d4a07" translate="yes" xml:space="preserve">
          <source>Notice that we&amp;rsquo;re including files from within &lt;code&gt;node_modules&lt;/code&gt;. React and React-DOM&amp;rsquo;s npm packages include standalone &lt;code&gt;.js&lt;/code&gt; files that you can include in a web page, and we&amp;rsquo;re referencing them directly to get things moving faster. Feel free to copy these files to another directory, or alternatively, host them on a content delivery network (CDN). Facebook makes CDN-hosted versions of React available, and you can &lt;a href=&quot;http://facebook.github.io/react/downloads.html#development-vs.-production-builds&quot;&gt;read more about that here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;node_modules&lt;/code&gt; 内のファイルが含まれるnode_modules。 ReactおよびReact-DOM npmパッケージには、Webページに含めることができるスタンドアロンの &lt;code&gt;.js&lt;/code&gt; ファイルが含まれています。 これらは処理を高速化するために直接参照されます。 これらのファイルを別のディレクトリに自由にコピーするか、Content Delivery Network（CDN）でホストしてください。 Facebookは、ReactのCDNホストバージョンを利用可能にします。 &lt;a href=&quot;http://facebook.github.io/react/downloads.html#development-vs.-production-builds&quot;&gt;詳細はここをクリックしてください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="b09f5734b53cfac68ac359e515430d1247899638" translate="yes" xml:space="preserve">
          <source>Notice that while we can&amp;rsquo;t use &lt;code&gt;name&lt;/code&gt; from outside of &lt;code&gt;Person&lt;/code&gt;, we can still use it from within an instance method of &lt;code&gt;Employee&lt;/code&gt; because &lt;code&gt;Employee&lt;/code&gt; derives from &lt;code&gt;Person&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Person&lt;/code&gt; の外部から &lt;code&gt;name&lt;/code&gt; を使用することはできませんが、 &lt;code&gt;Employee&lt;/code&gt; は &lt;code&gt;Person&lt;/code&gt; から派生しているため、 &lt;code&gt;Employee&lt;/code&gt; インスタンスメソッド内から使用することができます。</target>
        </trans-unit>
        <trans-unit id="057539fc62c3a3433f309ba4576e4667a469ea4a" translate="yes" xml:space="preserve">
          <source>Notice the above needed no type annotations. The &lt;code&gt;const&lt;/code&gt; assertion allowed TypeScript to take the most specific type of the expression.</source>
          <target state="translated">上記では型注釈は必要ないことに注意してください。 &lt;code&gt;const&lt;/code&gt; アサーションにより、TypeScriptは最も具体的なタイプの式を取ることができました。</target>
        </trans-unit>
        <trans-unit id="f321483ba4f94eea3586e9078b133451c9b94b14" translate="yes" xml:space="preserve">
          <source>Notice the given argument to &lt;code&gt;createSquare&lt;/code&gt; is spelled &lt;em&gt;&lt;code&gt;colour&lt;/code&gt;&lt;/em&gt; instead of &lt;code&gt;color&lt;/code&gt;. In plain JavaScript, this sort of thing fails silently.</source>
          <target state="translated">&lt;code&gt;createSquare&lt;/code&gt; に指定された引数が&lt;em&gt; &lt;code&gt;colour&lt;/code&gt; &lt;/em&gt;ではなく&lt;em&gt;colorである&lt;/em&gt; createSquare。 単純なJavaScriptでは、この種のことは黙って失敗します。</target>
        </trans-unit>
        <trans-unit id="449041a6d7a9b6fc7d3b8e6410b5c6cd0fde878b" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;search&lt;/code&gt; is &lt;code&gt;{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }&lt;/code&gt;. Object spreading is more complex than array spreading. Like array spreading, it proceeds from left-to-right, but the result is still an object. This means that properties that come later in the spread object overwrite properties that come earlier. So if we modify the previous example to spread at the end:</source>
          <target state="translated">&lt;code&gt;search&lt;/code&gt; は &lt;code&gt;{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }&lt;/code&gt; です。 オブジェクトの拡散は、配列の拡散よりも複雑です。 配列スプレッドのように左から右に移動しますが、結果は依然としてオブジェクトです。 つまり、スプレッドオブジェクトの後半のプロパティは、スプレッドオブジェクトの前のプロパティをオーバーライドします。 したがって、前の例を変更し、最後まで拡張すると：</target>
        </trans-unit>
        <trans-unit id="db8e5588d2d1057026cfc4a79854c4482517ae14" translate="yes" xml:space="preserve">
          <source>Now TypeScript knows that &lt;code&gt;createCardPicker&lt;/code&gt; expects to be called on a &lt;code&gt;Deck&lt;/code&gt; object. That means that &lt;code&gt;this&lt;/code&gt; is of type &lt;code&gt;Deck&lt;/code&gt; now, not &lt;code&gt;any&lt;/code&gt;, so &lt;code&gt;--noImplicitThis&lt;/code&gt; will not cause any errors.</source>
          <target state="translated">&lt;code&gt;createCardPicker&lt;/code&gt; TypeScriptは、 &lt;code&gt;Deck&lt;/code&gt; オブジェクトでcreateCardPickerが呼び出されることを想定しています。 つまり、 &lt;code&gt;--noImplicitThis&lt;/code&gt; は &lt;code&gt;Deck&lt;/code&gt; タイプであり、いずれでもないため、エラーは発生しません。</target>
        </trans-unit>
        <trans-unit id="1bb4e738e148009f79ea8206746e9d01e2ac6c80" translate="yes" xml:space="preserve">
          <source>Now change &lt;code&gt;main.ts&lt;/code&gt; to update the page:</source>
          <target state="translated">次に、 &lt;code&gt;main.ts&lt;/code&gt; でページを更新します。</target>
        </trans-unit>
        <trans-unit id="19f45556bb4ffb06e428f0775fa838cee98426d1" translate="yes" xml:space="preserve">
          <source>Now change the code in &lt;code&gt;src/main.ts&lt;/code&gt; to import &lt;code&gt;sayHello&lt;/code&gt; from &lt;code&gt;greet.ts&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;src/main.ts&lt;/code&gt; から &lt;code&gt;sayHello&lt;/code&gt; をインポートするsrc / main.tsコード。</target>
        </trans-unit>
        <trans-unit id="bc972ac7f876ddb230eb09fff1d371c82cba09d1" translate="yes" xml:space="preserve">
          <source>Now change your gulpfile to the following:</source>
          <target state="translated">gulpfileを次のように変更します。</target>
        </trans-unit>
        <trans-unit id="d5e91337836080850365ec1adb6a6e22456b494f" translate="yes" xml:space="preserve">
          <source>Now if you annotate calling code with &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">呼び出しコードに注釈を付ける場合：</target>
        </trans-unit>
        <trans-unit id="ce21fbd716cb22501e3b77ae211a67a20a5b69a6" translate="yes" xml:space="preserve">
          <source>Now imports to &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; would be looked up in &lt;code&gt;./modules/moduleA&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; インポートします。 &lt;code&gt;./modules/moduleA&lt;/code&gt; を検索しました</target>
        </trans-unit>
        <trans-unit id="7bb24a6d01809ab25d994975acd19c2bdf7782ca" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at how return types are treated, using two functions that differ only by their return type:</source>
          <target state="translated">次に、戻り値の型のみが異なる2つの関数を使用して、戻り値の型がどのように処理されるかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="cfc81a9edf6b5df21e2f8d967d810f4429dddd90" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s move this project from Node to the browser. To do this, we&amp;rsquo;d like to bundle all our modules into one JavaScript file. Fortunately, that&amp;rsquo;s exactly what Browserify does. Even better, it lets us use the CommonJS module system used by Node, which is the default TypeScript emit. That means our TypeScript and Node setup will transfer to the browser basically unchanged.</source>
          <target state="translated">次に、このプロジェクトをNodeからブラウザーに移動します。 これを行うには、すべてのモジュールを1つのJavaScriptファイルにバンドルします。 幸いなことに、これはまさにBrowserifyが行うことです。 さらに良いことに、Nodeが使用するCommonJSモジュールシステムを使用できます。 これはデフォルトでTypeScriptに出力されます。 つまり、TypeScriptとNodeのセットアップは、基本的に変更されずにブラウザーに転送されます。</target>
        </trans-unit>
        <trans-unit id="f2ff6a3f3742717cb814ea8ff8b733c8987d4bca" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s use the discriminated union:</source>
          <target state="translated">次に、差別化された結合を使用しましょう。</target>
        </trans-unit>
        <trans-unit id="ff37331bf4adb180113ce3c6cbbb96618f575e44" translate="yes" xml:space="preserve">
          <source>Now open up &lt;code&gt;index.html&lt;/code&gt; in your favorite browser and everything should be ready to use! You should see a page that says &amp;ldquo;Hello from TypeScript and React!&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;index.html&lt;/code&gt; をお気に入りのブラウザでindex.htmlを開くと、すべてが使用可能になります。 「TypeScript and Reactからこんにちは！」というページが表示されます。</target>
        </trans-unit>
        <trans-unit id="b64ae89f2b2c42dc4bb6323281704d7232b3bc08" translate="yes" xml:space="preserve">
          <source>Now right-click on &lt;code&gt;gulpfile.js&lt;/code&gt; and click Task Runner Explorer.</source>
          <target state="translated">&lt;code&gt;gulpfile.js&lt;/code&gt; を右クリックして、Task Runner Explorerをクリックします。</target>
        </trans-unit>
        <trans-unit id="016beaf6be9be172cdeebc211faf5982d24125cf" translate="yes" xml:space="preserve">
          <source>Now that we are bundling our code with Browserify and tsify, we can add various features to our build with browserify plugins.</source>
          <target state="translated">Browserifyとtsifyにコードをバンドルしているため、browserifyプラグインを使用してビルドにさまざまな機能を追加できます。</target>
        </trans-unit>
        <trans-unit id="3572b0fda28e71add853bf4afaed6b354c007b3b" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve typed the function, let&amp;rsquo;s write the full type of the function out by looking at each piece of the function type.</source>
          <target state="translated">関数を入力したので、関数型の各部分を見て、関数の完全な型を書きましょう。</target>
        </trans-unit>
        <trans-unit id="2966203d51ca9197ed946ae5160c527e0fb03c59" translate="yes" xml:space="preserve">
          <source>Now that you have authored a declaration file following the steps of this guide, it is time to publish it to npm. There are two main ways you can publish your declaration files to npm:</source>
          <target state="translated">このガイドの手順に従って宣言ファイルを作成したので、それをnpmに公開します。 宣言ファイルをnpmに公開するには、主に2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="8c3e6c78d4bb8682924668ec470406f5a06e700d" translate="yes" xml:space="preserve">
          <source>Now that you know how to wrap the properties of a type, the next thing you&amp;rsquo;ll want to do is unwrap them. Fortunately, that&amp;rsquo;s pretty easy:</source>
          <target state="translated">型プロパティをラップする方法がわかったので、次に行うことはそれらのラップを解除することです。 幸いなことに、それは非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="586d73d271314d06733d1c62bea37895a7824b97" translate="yes" xml:space="preserve">
          <source>Now to extend this to add support for input with numbers in bases other than 10, let&amp;rsquo;s create &lt;code&gt;ProgrammerCalculator.ts&lt;/code&gt;</source>
          <target state="translated">次に、 &lt;code&gt;ProgrammerCalculator.ts&lt;/code&gt; を拡張して、10以外の基数の数値のサポートを追加します。</target>
        </trans-unit>
        <trans-unit id="54df9cc661a5983b5f51492bea457bb95cb0f212" translate="yes" xml:space="preserve">
          <source>Now type the following in &lt;code&gt;greeter.html&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;greeter.html&lt;/code&gt; のは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="0aedf42a298e6637bb4289e35235553f17c5d827" translate="yes" xml:space="preserve">
          <source>Now we can &lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt;&lt;code&gt;node.d.ts&lt;/code&gt; and then load the modules using &lt;code&gt;import url = require(&quot;url&quot;);&lt;/code&gt; or &lt;code&gt;import * as URL from &quot;url&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt; &lt;code&gt;node.d.ts&lt;/code&gt; はnode.d.tsを実行し、 &lt;code&gt;import url = require(&quot;url&quot;);&lt;/code&gt; を使用してモジュールをロードできます。 または &lt;code&gt;import * as URL from &quot;url&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2993564eab76d9b635f5473fb0c79d7180499112" translate="yes" xml:space="preserve">
          <source>Now we can start taking advantage of some of the new tools TypeScript offers. Add a &lt;code&gt;: string&lt;/code&gt; type annotation to the &amp;lsquo;person&amp;rsquo; function argument as shown here:</source>
          <target state="translated">TypeScriptが提供するいくつかの新しいツールを利用できるようになりました。 以下に示すように、「person」関数の引数にtype &lt;code&gt;: string&lt;/code&gt; 注釈を追加します。</target>
        </trans-unit>
        <trans-unit id="a9ba4be9a993e3629ea4a24cf3ff116ae3e0a325" translate="yes" xml:space="preserve">
          <source>Now we can use &lt;code&gt;npm install&lt;/code&gt; to install packages. First install &lt;code&gt;gulp-cli&lt;/code&gt; globally (if you use a Unix system, you may need to prefix the &lt;code&gt;npm install&lt;/code&gt; commands in this guide with &lt;code&gt;sudo&lt;/code&gt;).</source>
          <target state="translated">これで、 &lt;code&gt;npm install&lt;/code&gt; を使用してパッケージをインストールできます。 最初に、 &lt;code&gt;gulp-cli&lt;/code&gt; をグローバルに使用します（Unixシステムを使用している場合は、このガイドの &lt;code&gt;npm install&lt;/code&gt; コマンドを &lt;code&gt;sudo&lt;/code&gt; する必要がある場合があります）。</target>
        </trans-unit>
        <trans-unit id="a7d081445a246b0f99f5a3375693fd0bead88a94" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll turn this folder into an npm package.</source>
          <target state="translated">次に、このフォルダーをnpmパッケージに変換します。</target>
        </trans-unit>
        <trans-unit id="798f21b6ccc1b472b81074260cf839e73de6d419" translate="yes" xml:space="preserve">
          <source>Now when these &lt;code&gt;never&lt;/code&gt;-returning functions are called, TypeScript recognizes that they affect the control flow graph and accounts for them.</source>
          <target state="translated">これらのreturn &lt;code&gt;never&lt;/code&gt; 関数が呼び出されない場合、TypeScriptはそれらが制御フローグラフに影響することを認識し、それらを記述します。</target>
        </trans-unit>
        <trans-unit id="4fec837a26b514bcf683dcfc0bc3cc7b47c80376" translate="yes" xml:space="preserve">
          <source>Now when you run Gulp, it should start and stay running. Try changing the code for &lt;code&gt;showHello&lt;/code&gt; in &lt;code&gt;main.ts&lt;/code&gt; and saving it. You should see output that looks like this:</source>
          <target state="translated">これで、Gulpを実行すると、Gulpが起動して実行を継続するはずです。 &lt;code&gt;showHello&lt;/code&gt; showHelloコードを保存して保存します。 次のような出力が表示されます。</target>
        </trans-unit>
        <trans-unit id="5ab194637a92c49cdda73412d946249336784333" translate="yes" xml:space="preserve">
          <source>Now you can import things that match &lt;code&gt;&quot;*!text&quot;&lt;/code&gt; or &lt;code&gt;&quot;json!*&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;*!text&quot;&lt;/code&gt; または &lt;code&gt;&quot;json!*&quot;&lt;/code&gt; 一致をインポートできるようになりました。</target>
        </trans-unit>
        <trans-unit id="32b6a0eecd0bd91b730d6782f43f8351f9e8957b" translate="yes" xml:space="preserve">
          <source>NuGet</source>
          <target state="translated">NuGet</target>
        </trans-unit>
        <trans-unit id="3fd953c33b944413003ce7910b6fafa75556a775" translate="yes" xml:space="preserve">
          <source>Null and Undefined</source>
          <target state="translated">ヌルおよび未定義</target>
        </trans-unit>
        <trans-unit id="0ba35c721cc86f9e03aa8786b08aba75ab337b54" translate="yes" xml:space="preserve">
          <source>Null- and undefined-aware types</source>
          <target state="translated">ヌルおよび未定義の認識タイプ</target>
        </trans-unit>
        <trans-unit id="4235ec51572e6a2ff85027b7b1a8ce199c7cf8fd" translate="yes" xml:space="preserve">
          <source>Nullable types</source>
          <target state="translated">Nullableタイプ</target>
        </trans-unit>
        <trans-unit id="a75b78680034aa8db560e36a8c2208c5c33aa012" translate="yes" xml:space="preserve">
          <source>Nullable types only have meaning if &lt;code&gt;strictNullChecks&lt;/code&gt; is on:</source>
          <target state="translated">Nullable型は、 &lt;code&gt;strictNullChecks&lt;/code&gt; がオンになっている場合にのみ意味があります。</target>
        </trans-unit>
        <trans-unit id="961f4d441aaa81cdea02877b88e051c0d6fe0b64" translate="yes" xml:space="preserve">
          <source>Nullish Coalescing</source>
          <target state="translated">ヌル合体</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="c3e5f2be0a6baf4d94beda8d9cf3d891411658e7" translate="yes" xml:space="preserve">
          <source>Number-like properties of an object type are those declared using a numeric literal or computed property name of a numeric literal type.</source>
          <target state="translated">オブジェクト型の数などのプロパティは、数値リテラルまたは数値リテラル型の計算されたプロパティ名を使用して宣言されます。</target>
        </trans-unit>
        <trans-unit id="6be519964a1d39fca2eb603fe581121e0fee9182" translate="yes" xml:space="preserve">
          <source>Numeric Literal Types</source>
          <target state="translated">数値リテラル型</target>
        </trans-unit>
        <trans-unit id="87f1897cf6e443b573ef4632ce2ba3620162bbc7" translate="yes" xml:space="preserve">
          <source>Numeric enums</source>
          <target state="translated">数値列挙</target>
        </trans-unit>
        <trans-unit id="9587a80bbfa80632e8af306b43edbc1e13077c08" translate="yes" xml:space="preserve">
          <source>Numeric enums can be mixed in &lt;a href=&quot;#computed-and-constant-members&quot;&gt;computed and constant members (see below)&lt;/a&gt;. The short story is, enums without initializers either need to be first, or have to come after numeric enums initialized with numeric constants or other constant enum members. In other words, the following isn&amp;rsquo;t allowed:</source>
          <target state="translated">&lt;a href=&quot;#computed-and-constant-members&quot;&gt;計算メンバーと定数メンバーで&lt;/a&gt;列挙を混在させることができます（以下を参照）。 簡単に言えば、イニシャライザーのない列挙が最初に来るか、数値定数または他の定数列挙メンバーで初期化された数値列挙の後に来なければなりません。 つまり、次は許可されていません。</target>
        </trans-unit>
        <trans-unit id="830f0ed9d3be32844d496bfeb9d33c2f9dea7d6a" translate="yes" xml:space="preserve">
          <source>Numeric separators</source>
          <target state="translated">数値区切り記号</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="7a98263bb62cd83a74dc00c8238d597167506261" translate="yes" xml:space="preserve">
          <source>Object Spread and Rest</source>
          <target state="translated">オブジェクトの展開と静止</target>
        </trans-unit>
        <trans-unit id="a7dc9622d9872b2041ea4b92f628450cd8b88097" translate="yes" xml:space="preserve">
          <source>Object destructuring</source>
          <target state="translated">オブジェクトの破壊</target>
        </trans-unit>
        <trans-unit id="7cd3db8976f376a1f019b5d0fed0df37b11861ba" translate="yes" xml:space="preserve">
          <source>Object literals are open-ended</source>
          <target state="translated">無制限のオブジェクトリテラル</target>
        </trans-unit>
        <trans-unit id="b3c62e15831841090f5476450b68b035ffba0566" translate="yes" xml:space="preserve">
          <source>Object literals behave as if they have an index signature &lt;code&gt;[x:string]: any&lt;/code&gt; that allows them to be treated as open maps instead of closed objects.</source>
          <target state="translated">オブジェクトリテラルは、インデックスシグネチャ &lt;code&gt;[x:string]: any&lt;/code&gt; を持っているかのように動作します 。 オブジェクトリテラルは、閉じたオブジェクトではなく、開いたマップとして扱う必要があります。</target>
        </trans-unit>
        <trans-unit id="74365de67eba166395b7f2ad380a09c31367e923" translate="yes" xml:space="preserve">
          <source>Object rests are the dual of object spreads, in that they can extract any extra properties that don&amp;rsquo;t get picked up when destructuring an element:</source>
          <target state="translated">オブジェクトの残りは、要素の分解時に取得されない追加のプロパティを抽出できるという点で、オブジェクトの広がりの2倍です。</target>
        </trans-unit>
        <trans-unit id="5eeac8ca658c85a10aefd3ffe0bf35ef9f80485c" translate="yes" xml:space="preserve">
          <source>Object spread also has a couple of other surprising limits. First, it only includes an objects&amp;rsquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;own, enumerable properties&lt;/a&gt;. Basically, that means you lose methods when you spread instances of an object:</source>
          <target state="translated">オブジェクトの広がりには、他にも驚くべき制限がいくつかあります。 まず、オブジェクトに&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;固有の列挙可能なプロパティ&lt;/a&gt;のみが含まれています。 基本的に、それはオブジェクトのインスタンスを広げるとメソッドを失うことを意味します：</target>
        </trans-unit>
        <trans-unit id="132f0e2906b1a9d29d3142065e0490a0c7b00912" translate="yes" xml:space="preserve">
          <source>Objects with Properties</source>
          <target state="translated">プロパティを持つオブジェクト</target>
        </trans-unit>
        <trans-unit id="896953fcb00b0eb5b0ba4da3b193100a1b6c1094" translate="yes" xml:space="preserve">
          <source>Of course, any of these types can be declared using Typescript syntax in a single-line &lt;code&gt;@typedef&lt;/code&gt;:</source>
          <target state="translated">もちろん、これらの型はいずれも &lt;code&gt;@typedef&lt;/code&gt; の単一行でTypescript構文を使用して宣言できます。</target>
        </trans-unit>
        <trans-unit id="2a729d408f1e41978ee6a94cb932a7977199d3c0" translate="yes" xml:space="preserve">
          <source>Of course, since this is JavaScript, you can just ignore trailing elements you don&amp;rsquo;t care about:</source>
          <target state="translated">もちろん、これはJavaScriptなので、気にしない最後の要素は無視できます。</target>
        </trans-unit>
        <trans-unit id="b9ca67ed45e73556a1cbb12d34b79f3e95210af4" translate="yes" xml:space="preserve">
          <source>Of course, that might not feel right. If you open that file in an editor with TypeScript support (or if you run &lt;code&gt;tsc --pretty&lt;/code&gt;), you might see red squiggles on certain lines. You should think of these the same way you&amp;rsquo;d think of red squiggles in an editor like Microsoft Word. TypeScript will still translate your code, just like Word will still let you print your documents.</source>
          <target state="translated">もちろん、それは正しくないかもしれません。 TypeScriptサポートを使用してエディターでファイルを開く（または &lt;code&gt;tsc --pretty&lt;/code&gt; を実行する）と、特定の行に赤い波線が表示される場合があります。 これらは、Microsoft Wordなどのエディターの赤い波線と同じように考慮する必要があります。 TypeScriptはコードを変換して、Wordでドキュメントを印刷できるようにします。</target>
        </trans-unit>
        <trans-unit id="33b53cf1b820a2734ec0c25dc3f2c29570965d4b" translate="yes" xml:space="preserve">
          <source>Of note, only the parameters and the return type make up the function type. Captured variables are not reflected in the type. In effect, captured variables are part of the &amp;ldquo;hidden state&amp;rdquo; of any function and do not make up its API.</source>
          <target state="translated">パラメーターと戻り値の型のみが関数型を構成することに注意してください。 キャプチャされた変数はタイプに反映されません。 実際、キャプチャされた変数は関数の「隠された状態」の一部であり、APIを構成していません。</target>
        </trans-unit>
        <trans-unit id="4d23057a19f87b1d7a3f861f468248c8e5a5974a" translate="yes" xml:space="preserve">
          <source>Official TypeScript NuGet package</source>
          <target state="translated">公式TypeScript NuGetパッケージ</target>
        </trans-unit>
        <trans-unit id="a342b6bea0bb720b9577de62cca20c2743aa540e" translate="yes" xml:space="preserve">
          <source>Often a project has multiple output targets, e.g. &lt;code&gt;ES5&lt;/code&gt; and &lt;code&gt;ES2015&lt;/code&gt;, debug and production or &lt;code&gt;CommonJS&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt;; Just a few configuration options change between these two targets, and maintaining multiple &lt;code&gt;tsconfig.json&lt;/code&gt; files can be a hassle.</source>
          <target state="translated">多くの場合、プロジェクトには複数の出力ターゲットがあります。 たとえば、 &lt;code&gt;ES5&lt;/code&gt; と &lt;code&gt;ES2015&lt;/code&gt; 、デバッグと実稼働、または &lt;code&gt;CommonJS&lt;/code&gt; と &lt;code&gt;System&lt;/code&gt; です。 複数の &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを維持するのは面倒で、これらの2つのターゲット間で変更される構成オプションはわずかです。</target>
        </trans-unit>
        <trans-unit id="0d6fe7c72174392511bd9351eaea580b26d61ce5" translate="yes" xml:space="preserve">
          <source>Often in Node.js applications a &lt;code&gt;.json&lt;/code&gt; is needed. With TypeScript 2.9, &lt;code&gt;--resolveJsonModule&lt;/code&gt; allows for importing, extracting types from and generating &lt;code&gt;.json&lt;/code&gt; files.</source>
          <target state="translated">Node.jsアプリケーションには、多くの場合 &lt;code&gt;.json&lt;/code&gt; が必要です 。 TypeScript 2.9では、 &lt;code&gt;--resolveJsonModule&lt;/code&gt; は.jsonを使用して.jsonファイルをインポートし、タイプを抽出して生成できます。</target>
        </trans-unit>
        <trans-unit id="c504b6f49a2c17cd30c9562020e80d82bcb972da" translate="yes" xml:space="preserve">
          <source>Often modules extend other modules, and partially expose some of their features. A re-export does not import it locally, or introduce a local variable.</source>
          <target state="translated">多くの場合、モジュールは他のモジュールを拡張し、その機能の一部を公開します。 再エクスポートは、ローカルにインポートしたり、ローカル変数を導入したりしません。</target>
        </trans-unit>
        <trans-unit id="7ca1979392492f5b243f43458b409b3671c295fb" translate="yes" xml:space="preserve">
          <source>Often there are external source files in your project that may not be authored in TypeScript. Alternatively, you might be in the middle of converting a JS code base into TS, but still want to bundle all your JS code into a single file with the output of your new TS code.</source>
          <target state="translated">多くの場合、プロジェクトにはTypeScriptで作成されない外部ソースファイルがあります。 または、JSコードベースをTSに変換するときに、すべてのJSコードを新しいTSコードの出力を含む単一のファイルにバンドルすることができます。</target>
        </trans-unit>
        <trans-unit id="5dd8eb55cce46da17a5fd56794f37ca6d1bdbaaf" translate="yes" xml:space="preserve">
          <source>Often you will need to extend functionality on a module. A common JS pattern is to augment the original object with &lt;em&gt;extensions&lt;/em&gt;, similar to how JQuery extensions work. As we&amp;rsquo;ve mentioned before, modules do not &lt;em&gt;merge&lt;/em&gt; like global namespace objects would. The recommended solution is to &lt;em&gt;not&lt;/em&gt; mutate the original object, but rather export a new entity that provides the new functionality.</source>
          <target state="translated">多くの場合、モジュールの機能を拡張する必要があります。 一般的なJSパターンは、JQuery拡張機能の動作と同様に、元のオブジェクトに&lt;em&gt;拡張機能&lt;/em&gt; &lt;em&gt;を&lt;/em&gt;追加することです。 前述のように、モジュールはグローバル名前空間オブジェクトのように&lt;em&gt;マージさ&lt;/em&gt;れません。 推奨される解決策は、元のオブジェクト&lt;em&gt;を&lt;/em&gt;変更&lt;em&gt;せずに&lt;/em&gt;新しい機能を提供する新しいエンティティをエクスポートすることです。</target>
        </trans-unit>
        <trans-unit id="3cd64adc89519f486491a6325593966cd9fc3e61" translate="yes" xml:space="preserve">
          <source>Omit&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Omit&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="92df791023a2af27d1199c4ac1986b7a67686b3d" translate="yes" xml:space="preserve">
          <source>OmitThisParameter</source>
          <target state="translated">OmitThisParameter</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
