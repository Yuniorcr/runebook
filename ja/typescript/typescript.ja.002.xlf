<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="464d90ddf01b4a7d7fb2059732ea18c0a56423b4" translate="yes">
          <source>Extending Interfaces</source>
          <target>インタフェースの拡張</target>
        </trans-unit>
        <trans-unit id="70c729194ffb9f8bd9ec475f03a3057bb1e60a4e" translate="yes">
          <source>Extending expressions</source>
          <target>式の拡張</target>
        </trans-unit>
        <trans-unit id="f72cd5557bb3227370e4d01e242d8bff1f532a3f" translate="yes">
          <source>Extract&lt;T,U&gt;</source>
          <target state="translated">Extract&lt;T,U&gt;</target>
        </trans-unit>
        <trans-unit id="515872ad64c38522409e00410e68ba6e32a29116" translate="yes">
          <source>Extracts the type of the &lt;code&gt;this&lt;/code&gt; parameter of a function type, or &lt;code&gt;unknown&lt;/code&gt; if the function type has no &lt;code&gt;this&lt;/code&gt; parameter.</source>
          <target>関数型の&lt;code&gt;this&lt;/code&gt;パラメータの型を抽出します。関数型に&lt;code&gt;this&lt;/code&gt;パラメータがない場合は&lt;code&gt;unknown&lt;/code&gt;を抽出します。</target>
        </trans-unit>
        <trans-unit id="5580687121fcfefa146981fb36d296bc3f0de348" translate="yes">
          <source>Factories</source>
          <target>工場</target>
        </trans-unit>
        <trans-unit id="bead528d19950f71ea30380d09df640a3d7210ca" translate="yes">
          <source>Factory Functions</source>
          <target>ファクトリ関数</target>
        </trans-unit>
        <trans-unit id="4a32e2f9caf4e668d29618328e51a2647e2d967d" translate="yes">
          <source>Faster &lt;code&gt;tsc --watch&lt;/code&gt;</source>
          <target>より高速な&lt;code&gt;tsc--監視&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbdafc5050207465ed19f95ed57e21102e2c0067" translate="yes">
          <source>Faster subsequent builds with the &lt;code&gt;--incremental&lt;/code&gt; flag</source>
          <target>&lt;code&gt;--incremental&lt;/code&gt;フラグを使用した後続のビルドの高速化</target>
        </trans-unit>
        <trans-unit id="a29227a71e68767de435c445f3ac1547081655fc" translate="yes">
          <source>Feedback from our community, as well as our own experience, has shown us that leveraging the newest TypeScript features while also accommodating users on the older versions are difficult. TypeScript introduces a new feature called &lt;code&gt;typesVersions&lt;/code&gt; to help accommodate these scenarios.</source>
          <target>コミュニティからのフィードバックや私たち自身の経験から、最新のTypeScript機能を活用しながら、古いバージョンのユーザーに対応するのは難しいことがわかりました。 TypeScriptは&lt;code&gt;typesVersions&lt;/code&gt;と呼ばれる新しい機能を導入して、これらのシナリオに対応します。</target>
        </trans-unit>
        <trans-unit id="6748207b859ccfa7f82ac49d731d1b27113a3b98" translate="yes">
          <source>File does not exist, move to the second substitution</source>
          <target>ファイルが存在しません。2番目の置換に移動してください</target>
        </trans-unit>
        <trans-unit id="0fe8300347a5d2fe3f7b4e21e6708ddf628f2eeb" translate="yes">
          <source>File exists. Done.</source>
          <target>ファイルが存在します。 終わった。</target>
        </trans-unit>
        <trans-unit id="1214946f7d95ef7612951c5654019274eb30d8ea" translate="yes">
          <source>File path</source>
          <target>ファイルパス</target>
        </trans-unit>
        <trans-unit id="f1b26fa5a34d56fb3e3920fe7c3dc4952d2ae44c" translate="yes">
          <source>Files in &lt;code&gt;src/views&lt;/code&gt; are user code for some UI controls. Files in &lt;code&gt;generated/templates&lt;/code&gt; are UI template binding code auto-generated by a template generator as part of the build. A build step will copy the files in &lt;code&gt;/src/views&lt;/code&gt; and &lt;code&gt;/generated/templates/views&lt;/code&gt; to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as &lt;code&gt;"./template"&lt;/code&gt;.</source>
          <target>&lt;code&gt;src/views&lt;/code&gt;内のファイルは、一部のUIコントロールのユーザー・コードです。 &lt;code&gt;generated/templates&lt;/code&gt;内のファイルは、ビルドの一部としてテンプレートジェネレータによって自動生成されるUIテンプレートバインドコードです。 ビルド・ステップでは、&lt;code&gt;/src/views&lt;/code&gt;と&lt;code&gt;/generated/templates/views&lt;/code&gt;のファイルを出力の同じディレクトリーにコピーします。 実行時には、ビューはそのテンプレートがその横に存在することを期待できるため、相対名を使用して&lt;code&gt;"./template"&lt;/code&gt;としてインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="944999053b7485f3f5c651758da5734b4f1b2630" translate="yes">
          <source>Files included using &lt;code&gt;"include"&lt;/code&gt; can be filtered using the &lt;code&gt;"exclude"&lt;/code&gt; property. However, files included explicitly using the &lt;code&gt;"files"&lt;/code&gt; property are always included regardless of &lt;code&gt;"exclude"&lt;/code&gt;. The &lt;code&gt;"exclude"&lt;/code&gt; property defaults to excluding the &lt;code&gt;node_modules&lt;/code&gt;, &lt;code&gt;bower_components&lt;/code&gt;, &lt;code&gt;jspm_packages&lt;/code&gt; and &lt;code&gt;&amp;lt;outDir&amp;gt;&lt;/code&gt; directories when not specified.</source>
          <target>&lt;code&gt;"include"&lt;/code&gt;を使用してインクルードされたファイルは、&lt;code&gt;"exclude"&lt;/code&gt;プロパティを使用してフィルタリングできます。 ただし、&lt;code&gt;"files"&lt;/code&gt;プロパティを使用して明示的にインクルードされたファイルは、&lt;code&gt;"exclude"&lt;/code&gt;に関係なく常にインクルードされます。&lt;code&gt;"exclude"&lt;/code&gt;プロパティは、指定されていない場合、&lt;code&gt;node_modules&lt;/code&gt;、&lt;code&gt;bower_components&lt;/code&gt;、&lt;code&gt;ジスパム_packages&lt;/code&gt;、および&lt;code&gt;&amp;lt;outDir&amp;gt;&lt;/code&gt;ディレクトリをデフォルトで除外します。</target>
        </trans-unit>
        <trans-unit id="c86be6e064d368e35d514286147756e446d3864b" translate="yes">
          <source>Files included using &lt;code&gt;"include"&lt;/code&gt; can be filtered using the &lt;code&gt;"exclude"&lt;/code&gt; property. However, files included explicitly using the &lt;code&gt;"files"&lt;/code&gt; property are always included regardless of &lt;code&gt;"exclude"&lt;/code&gt;. The &lt;code&gt;"exclude"&lt;/code&gt; property defaults to excluding the &lt;code&gt;node_modules&lt;/code&gt;, &lt;code&gt;bower_components&lt;/code&gt;, and &lt;code&gt;jspm_packages&lt;/code&gt; directories when not specified.</source>
          <target>&lt;code&gt;"include"&lt;/code&gt;を使用してインクルードされたファイルは、&lt;code&gt;"exclude"&lt;/code&gt;プロパティを使用してフィルタリングできます。 ただし、&lt;code&gt;"files"&lt;/code&gt;プロパティを使用して明示的にインクルードされたファイルは、&lt;code&gt;"exclude"&lt;/code&gt;に関係なく常にインクルードされます。&lt;code&gt;"exclude"&lt;/code&gt;プロパティは、指定されていない場合、デフォルトで&lt;code&gt;node_modules&lt;/code&gt;、&lt;code&gt;bower_components&lt;/code&gt;、および&lt;code&gt;ジスパム_packages&lt;/code&gt;ディレクトリを除外します。</target>
        </trans-unit>
        <trans-unit id="a0de52ada9537ab464bb6d45e97f86eaaff6bac8" translate="yes">
          <source>Final result</source>
          <target>最終結果</target>
        </trans-unit>
        <trans-unit id="c716a5f69a835c7b207ef913676c36b3f4cf7fe7" translate="yes">
          <source>Finally, ES2015 introduced the &lt;code&gt;for..of&lt;/code&gt; statement as a means of iterating over an iterable. Similarly, the Async Iteration proposal introduces the &lt;code&gt;for..await..of&lt;/code&gt; statement to iterate over an async iterable:</source>
          <target>最後に、ES2015では、&lt;code&gt;for.of&lt;/code&gt;ステートメントを、iterableを反復する手段として導入しました。 同様に、Async Iterationの提案では、&lt;code&gt;for.await.of&lt;/code&gt;文を導入して、async iterableを繰り返します。</target>
        </trans-unit>
        <trans-unit id="7d78a77f9353986a905d8c074f3df1efad103d2d" translate="yes">
          <source>Finally, add &lt;code&gt;src/greet.ts&lt;/code&gt; to &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target>最後に、&lt;code&gt;src/greet.ts&lt;/code&gt;を&lt;code&gt;tsconfig.json&lt;/code&gt;に追加する。</target>
        </trans-unit>
        <trans-unit id="48e51bf84514484baa2e7212c0375ccee83ffca6" translate="yes">
          <source>Finally, if the compiler could not resolve the module, it will log an error. In this case, the error would be something like &lt;code&gt;error TS2307: Cannot find module 'moduleA'.&lt;/code&gt;</source>
          <target>最後に、コンパイラがモジュールを解決できなかった場合、エラーをログに記録します。 この場合、エラーは&lt;code&gt;error TS2307:Cannot find module'moduleA'&lt;/code&gt;のようになります。</target>
        </trans-unit>
        <trans-unit id="c70f3dc4718552bbb66574b06291ac4442a2ee94" translate="yes">
          <source>Finally, if your target is ES5 or ES3, you&amp;rsquo;ll also need to set the &lt;code&gt;--downlevelIterators&lt;/code&gt; flag.</source>
          <target>最後に、ターゲットがES5またはES3の場合は、&lt;code&gt;--downlevelIterators&lt;/code&gt;フラグも設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="625382271b526d5909aa39a000a69074afb94c9c" translate="yes">
          <source>Finally, let&amp;rsquo;s extend the example one last time with classes. TypeScript supports new features in JavaScript, like support for class-based object-oriented programming.</source>
          <target>最後に、&amp;rsquo;sが最後にクラスで例を拡張します。 TypeScriptは、クラスベースのオブジェクト指向プログラミングのサポートなど、JavaScriptの新機能をサポートする。</target>
        </trans-unit>
        <trans-unit id="c6b76794e34c66667cc7c06423ff09561a2db9b4" translate="yes">
          <source>Finally, we could perform many different merges using &lt;code&gt;namespace&lt;/code&gt; declarations. This isn&amp;rsquo;t a particularly realistic example, but shows all sorts of interesting behavior:</source>
          <target>最後に、&lt;code&gt;namespace&lt;/code&gt;宣言を使用して、さまざまなマージを実行できます。 これは特に現実的な例ではありませんが、さまざまな興味深い動作を示しています。</target>
        </trans-unit>
        <trans-unit id="2a1cbf967f1f59d7ed905556a7ba174d0d91c432" translate="yes">
          <source>Finally, we mix our mixins into the class implementation.</source>
          <target>最後に、クラス実装にミックスインを入れます。</target>
        </trans-unit>
        <trans-unit id="5d24682490796967f2d44a64ea932e79d1b2fb40" translate="yes">
          <source>Finally, you can make index signatures &lt;code&gt;readonly&lt;/code&gt; in order to prevent assignment to their indices:</source>
          <target>最後に、インデックスシグネチャを&lt;code&gt;readonly&lt;/code&gt;にして、インデックスへの割り当てを防止できます。</target>
        </trans-unit>
        <trans-unit id="36f4ab4ec74314f1c6473ad2b642469fa92db24a" translate="yes">
          <source>Find all referenced projects</source>
          <target>すべての参照プロジェクトを検索</target>
        </trans-unit>
        <trans-unit id="f36d6416266be79de49dbd1cd5564e2c29d74695" translate="yes">
          <source>Find and Install Declaration Files</source>
          <target>宣言ファイルの検索とインストール</target>
        </trans-unit>
        <trans-unit id="107a7b9e0a62d571bcbb1e3e04401f38fb4be3c9" translate="yes">
          <source>Finished with that step? Great! You&amp;rsquo;ve successfully migrated a file from JavaScript to TypeScript!</source>
          <target>それで終わり? すばらしい!ファイルをJavaScriptからTypeScriptに正常にマイグレートしました!</target>
        </trans-unit>
        <trans-unit id="c8bb450db4ab929fdfadf7c4e435fbd8ded8de50" translate="yes">
          <source>First ensure Webpack is installed.</source>
          <target>まず、Webpackがインストールされていることを確認します。</target>
        </trans-unit>
        <trans-unit id="3df868c33500281a256aa0f7044d7222e49fa905" translate="yes">
          <source>First install Babelify and the Babel preset for ES2015. Like Uglify, Babelify mangles code, so we&amp;rsquo;ll need vinyl-buffer and gulp-sourcemaps. By default Babelify will only process files with extensions of &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.es&lt;/code&gt;, &lt;code&gt;.es6&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; so we need to add the &lt;code&gt;.ts&lt;/code&gt; extension as an option to Babelify.</source>
          <target>まず、BabelifyとES2015のBabelプリセットをインストールします。 Uglifyのように、Babelifyはコードを解析するので、ビニールバッファとgulpソースマップが必要です。 デフォルトでは、Babelifyは&lt;code&gt;.js&lt;/code&gt;、&lt;code&gt;.es&lt;/code&gt;、&lt;code&gt;.es6&lt;/code&gt;、&lt;code&gt;.jsx&lt;/code&gt;の拡張子を持つファイルのみを処理するので、&lt;code&gt;.ts&lt;/code&gt;拡張子をBabelifyのオプションとして追加する必要がある。</target>
        </trans-unit>
        <trans-unit id="735b0c16eaf95bad801406a590783a07bff54840" translate="yes">
          <source>First install Uglify. Since the point of Uglify is to mangle your code, we also need to install vinyl-buffer and gulp-sourcemaps to keep sourcemaps working.</source>
          <target>まずUglifyをインストールします。 Uglifyの目的はコードを修正することなので、ソースマップを動作させるためには、ビニール・バッファーとglpソースマップもインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="89e20ebbee86fab209c76b802ba242b064d21b1b" translate="yes">
          <source>First of all, they&amp;rsquo;re important because they allow TypeScript to type-check against other projects without re-checking the original source code. They&amp;rsquo;re also important because they allow TypeScript to interoperate with existing JavaScript libraries that weren&amp;rsquo;t built with TypeScript in mind. Finally, a benefit that is often underappreciated: both TypeScript &lt;em&gt;and&lt;/em&gt; JavaScript users can benefit from these files when using editors powered by TypeScript to get things like better auto-completion.</source>
          <target>まず第一に、TypeScriptが元のソースコードを再チェックすることなく、他のプロジェクトに対して型チェックを行うことができるので、これらは重要です。 また、TypeScriptが、TypeScriptを念頭に置いて構築されていない既存のJavaScriptライブラリと相互運用できるようにする点も重要です。 最後に、TypeScript&lt;em&gt;と&lt;/em&gt;の両方のJavaScriptユーザが、TypeScriptで動くエディタを使って自動補完を改善するときに、これらのファイルから恩恵を受けることができます。</target>
        </trans-unit>
        <trans-unit id="8618e8a440e50c5a75000139af77b5f2c4300871" translate="yes">
          <source>First some terminology</source>
          <target>まず、いくつかの用語</target>
        </trans-unit>
        <trans-unit id="99290d59716a55c82e8b063db8bf7f05e1a4b00b" translate="yes">
          <source>First steps</source>
          <target>最初のステップ</target>
        </trans-unit>
        <trans-unit id="8336905fe9b50c35195d1e701772f27af4d34cab" translate="yes">
          <source>First we declare the interfaces we will union. Each interface has a &lt;code&gt;kind&lt;/code&gt; property with a different string literal type. The &lt;code&gt;kind&lt;/code&gt; property is called the &lt;em&gt;discriminant&lt;/em&gt; or &lt;em&gt;tag&lt;/em&gt;. The other properties are specific to each interface. Notice that the interfaces are currently unrelated. Let&amp;rsquo;s put them into a union:</source>
          <target>まず、結合するインタフェースを宣言します。 各インタフェースには、異なる文字列リテラル型を持つ&lt;code&gt;kind&lt;/code&gt;プロパティがあります。 &lt;code&gt;kind&lt;/code&gt;プロパティは、&lt;em&gt;判別&lt;/em&gt;または&lt;em&gt;タグ&lt;/em&gt;と呼ばれます。 その他のプロパティは、各インタフェースに固有です。 インタフェースは現在無関係であることに注意してください。 の和を作成:</target>
        </trans-unit>
        <trans-unit id="a34ce699f43cedcd3aa6a4d39d183ca5e70a6e0b" translate="yes">
          <source>First we need to tell TypeScript how to build. Right click on &lt;code&gt;scripts&lt;/code&gt; and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;TypeScript Configuration File&lt;/strong&gt; and use the default name of &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target>まず、TypeScriptにビルド方法を指示します。 &lt;code&gt;scripts&lt;/code&gt;を右クリックし、&lt;strong&gt;New Item&lt;/strong&gt;をクリックします。次に、&lt;strong&gt;TypeScript Configuration File&lt;/strong&gt;を選択し、&lt;code&gt;tsconfig.json&lt;/code&gt;というデフォルト名を使用します。</target>
        </trans-unit>
        <trans-unit id="2dfb573ed967d8c6c17580ed779ecdccc14311ef" translate="yes">
          <source>First, accessors require you to set the compiler to output ECMAScript 5 or higher. Downleveling to ECMAScript 3 is not supported. Second, accessors with a &lt;code&gt;get&lt;/code&gt; and no &lt;code&gt;set&lt;/code&gt; are automatically inferred to be &lt;code&gt;readonly&lt;/code&gt;. This is helpful when generating a &lt;code&gt;.d.ts&lt;/code&gt; file from your code, because users of your property can see that they can&amp;rsquo;t change it.</source>
          <target>まず、アクセサーはコンパイラーがECMAScript5以上を出力するように設定する必要があります。 DownlevelingからECMAScript3はサポートされていません。 第2に、&lt;code&gt;get&lt;/code&gt;を持ち、&lt;code&gt;set&lt;/code&gt;を持たないアクセサは、自動的に&lt;code&gt;readonly&lt;/code&gt;であると判断されます。これは、コードから&lt;code&gt;.d.ts&lt;/code&gt;ファイルを生成する場合に便利です。これは、プロパティのユーザーが変更できないことを確認できるためです。</target>
        </trans-unit>
        <trans-unit id="2f1af0e65e7f250987a6b875f7a585e406660a62" translate="yes">
          <source>First, given types &lt;code&gt;T'&lt;/code&gt; and &lt;code&gt;U'&lt;/code&gt; that are instantiations of &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; where all occurrences of type parameters are replaced with &lt;code&gt;any&lt;/code&gt;, if &lt;code&gt;T'&lt;/code&gt; is not assignable to &lt;code&gt;U'&lt;/code&gt;, the conditional type is resolved to &lt;code&gt;Y&lt;/code&gt;. Intuitively, if the most permissive instantiation of &lt;code&gt;T&lt;/code&gt; is not assignable to the most permissive instantiation of &lt;code&gt;U&lt;/code&gt;, we know that no instantiation will be and we can just resolve to &lt;code&gt;Y&lt;/code&gt;.</source>
          <target>まず、&lt;code&gt;T'&lt;/code&gt;と&lt;code&gt;U'&lt;/code&gt;をインスタンス化した型&lt;code&gt;T'&lt;/code&gt;と&lt;code&gt;U'&lt;/code&gt;が与えられ、型パラメータのすべてのオカレンスが&lt;code&gt;any&lt;/code&gt;で置き換えられる場合、&lt;code&gt;T'&lt;/code&gt;が&lt;code&gt;U'&lt;/code&gt;に割り当てられない場合、条件付き型は&lt;code&gt;Y&lt;/code&gt;に解決される。 直感的に、&lt;code&gt;T&lt;/code&gt;の最も許容的なインスタンス化が&lt;code&gt;U&lt;/code&gt;の最も許容的なインスタンス化に割り当てられない場合、インスタンス化は行われないことがわかっており、&lt;code&gt;Y&lt;/code&gt;に解決することができる。</target>
        </trans-unit>
        <trans-unit id="e0f154b6d3560afc04e7423c292457f3d4c696d4" translate="yes">
          <source>First, install &lt;a href="https://dotnet.microsoft.com/apps/aspnet"&gt;ASP.NET Core&lt;/a&gt; if you need it. This quick-start guide requires Visual Studio 2015 or 2017.</source>
          <target>まず、必要に応じて&lt;a href="https://dotnet.microsoft.com/apps/aspnet"&gt;ASP.NET Core&lt;/a&gt;をインストールします。 このクイックスタートガイドにはVisual Studio2015または2017が必要です。</target>
        </trans-unit>
        <trans-unit id="5fe122cf8e822627b9c191ebbd95f6c78e81f570" translate="yes">
          <source>First, install browserify, &lt;a href="https://www.npmjs.com/package/tsify"&gt;tsify&lt;/a&gt;, and vinyl-source-stream. tsify is a Browserify plugin that, like gulp-typescript, gives access to the TypeScript compiler. vinyl-source-stream lets us adapt the file output of Browserify back into a format that gulp understands called &lt;a href="https://github.com/gulpjs/vinyl"&gt;vinyl&lt;/a&gt;.</source>
          <target>まず、browserify、&lt;a href="https://www.npmjs.com/package/tsify"&gt;ツーフィ&lt;/a&gt;、ビニールソースストリームをインストールする。 ツーフィはBrowserifyプラグインで、glp typescriptと同じようにTypeScriptコンパイラにアクセスできる。 vinylソースストリームを使えば、Browserifyのファイル出力を&lt;a href="https://github.com/gulpjs/vinyl"&gt;vinyl&lt;/a&gt;と呼ばれるgumpが理解できるフォーマットに戻すことができます。</target>
        </trans-unit>
        <trans-unit id="51744cf60b9ea9e03623f5527d487a42b621f3c4" translate="yes">
          <source>First, install the &lt;a href="https://github.com/Microsoft/tslib"&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt; utility library:</source>
          <target>まず、&lt;a href="https://github.com/Microsoft/tslib"&gt;&lt;code&gt;ツリブ&lt;/code&gt;&lt;/a&gt;ユーティリティライブラリをインストールします。</target>
        </trans-unit>
        <trans-unit id="f59152e91c742c2580784c2fb852897f78a3c5bd" translate="yes">
          <source>First, the compiler will try to locate a file that represents the imported module. To do so the compiler follows one of two different strategies: &lt;a href="#classic"&gt;Classic&lt;/a&gt; or &lt;a href="#node"&gt;Node&lt;/a&gt;. These strategies tell the compiler &lt;em&gt;where&lt;/em&gt; to look for &lt;code&gt;moduleA&lt;/code&gt;.</source>
          <target>まず、コンパイラはインポートされたモジュールを表すファイルを検索します。 これを行うには、コンパイラは&lt;a href="#classic"&gt;Classic&lt;/a&gt;または&lt;a href="#node"&gt;Node&lt;/a&gt;の2つの方法のいずれかに従います。これらの方法では、&lt;code&gt;moduleA&lt;/code&gt;を探すようにコンパイラに指示します。</target>
        </trans-unit>
        <trans-unit id="fee2aae2ee58d3140d673d1cb82204dd56b9f63b" translate="yes">
          <source>First, we can use concatenated output using the &lt;code&gt;--outFile&lt;/code&gt; flag to compile all of the input files into a single JavaScript output file:</source>
          <target>まず、&lt;code&gt;--outFile&lt;/code&gt;フラグを使用して連結出力を使用し、すべての入力ファイルを1つのJavaScript出力ファイルにコンパイルします。</target>
        </trans-unit>
        <trans-unit id="28d19122adb2247e67a766539293d7db8d64dd97" translate="yes">
          <source>First, we&amp;rsquo;ll review the kinds of libraries TypeScript declaration files can represent. We&amp;rsquo;ll briefly show how each kind of library is &lt;em&gt;used&lt;/em&gt;, how it is &lt;em&gt;written&lt;/em&gt;, and list some example libraries from the real world.</source>
          <target>まず、TypeScript宣言ファイルで表現できるライブラリの種類を確認します。 ここでは、各ライブラリの&lt;em&gt;使用方法&lt;/em&gt;、ライブラリの&lt;em&gt;書き込み方法&lt;/em&gt;、および実際のライブラリの例を示します。</target>
        </trans-unit>
        <trans-unit id="a7a574b0f49a4d1d52dcd069a74b5d55c404e3a8" translate="yes">
          <source>First, you&amp;rsquo;ll need to enable some module system by setting TypeScript&amp;rsquo;s &lt;code&gt;module&lt;/code&gt; flag. Valid options are &lt;code&gt;commonjs&lt;/code&gt;, &lt;code&gt;amd&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, and &lt;code&gt;umd&lt;/code&gt;.</source>
          <target>まず、TypeScriptの&lt;code&gt;module&lt;/code&gt;フラグを設定して、モジュールシステムを有効にする必要があります。 有効なオプションは、&lt;code&gt;commonjs&lt;/code&gt;、&lt;code&gt;amd&lt;/code&gt;、&lt;code&gt;system&lt;/code&gt;、および&lt;code&gt;umd&lt;/code&gt;です。</target>
        </trans-unit>
        <trans-unit id="7d0c91cebd6414c6cadf4f9352001f643b829f0b" translate="yes">
          <source>Fixed Length Tuples</source>
          <target>固定長タプル</target>
        </trans-unit>
        <trans-unit id="3ca7815b9ccb9b2f4adbee87c52250c1c035669b" translate="yes">
          <source>Flag unused declarations with &lt;code&gt;--noUnusedParameters&lt;/code&gt; and &lt;code&gt;--noUnusedLocals&lt;/code&gt;</source>
          <target>&lt;code&gt;--noUnusedParameters&lt;/code&gt;と&lt;code&gt;--noUnusedLocals&lt;/code&gt;で未使用の宣言にフラグを付ける</target>
        </trans-unit>
        <trans-unit id="82a9583e4b01eda6ab596923bd11954f7465daf4" translate="yes">
          <source>Following this logic, the compiler will attempt to resolve the two imports as such:</source>
          <target>このロジックに従って、コンパイラは2つのインポートの解決を試みます。</target>
        </trans-unit>
        <trans-unit id="26431a2529d203186f1196ee3c1e08f1f5a1e8c1" translate="yes">
          <source>Following up on specifying the type of &lt;code&gt;this&lt;/code&gt; in a class or an interface, functions and methods can now declare the type of &lt;code&gt;this&lt;/code&gt; they expect.</source>
          <target>クラスまたはインタフェースで&lt;code&gt;this&lt;/code&gt;の型を指定した後、関数とメソッドは、期待する&lt;code&gt;this&lt;/code&gt;の型を宣言できるようになりました。</target>
        </trans-unit>
        <trans-unit id="1c46fd3b2bfcf228c256745663f71fdbf4e9f242" translate="yes">
          <source>Following up our example above, consider if &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; instead used a non-relative path and had the import &lt;code&gt;var x = require("moduleB");&lt;/code&gt;. Node would then try to resolve &lt;code&gt;moduleB&lt;/code&gt; to each of the locations until one worked.</source>
          <target>上記の例に続いて、&lt;code&gt;/root/src/moduleA.js&lt;/code&gt;が非相対パスを使用し、import&lt;code&gt;var x=require("moduleB");&lt;/code&gt;を持っているかどうかを考えてみてください。 次に、ノードは、&lt;code&gt;moduleB&lt;/code&gt;をそれぞれの場所に解決しようとします。</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes">
          <source>Footnotes</source>
          <target>脚注</target>
        </trans-unit>
        <trans-unit id="d651257c7219d6828652b8ed3ae590398f5b2d5c" translate="yes">
          <source>For JavaScript library users, the &lt;a href="consumption"&gt;Consumption&lt;/a&gt; section offers a few simple steps to locate and install corresponding declaration files.</source>
          <target>JavaScriptライブラリユーザの場合、&lt;a href="consumption"&gt;Consumption&lt;/a&gt;セクションでは、対応する宣言ファイルを見つけてインストールするための簡単な手順を示します。</target>
        </trans-unit>
        <trans-unit id="3f13871c6491a9fb503e0b3db6f8d157fced814c" translate="yes">
          <source>For NPM users:</source>
          <target>NPMユーザーの場合:</target>
        </trans-unit>
        <trans-unit id="f29506c87493e2d6a8464c1671b709d1038182e2" translate="yes">
          <source>For React, intrinsic elements are emitted as strings (&lt;code&gt;React.createElement("div")&lt;/code&gt;), whereas a component you&amp;rsquo;ve created is not (&lt;code&gt;React.createElement(MyComponent)&lt;/code&gt;).</source>
          <target>Reactの場合、組み込み要素は文字列として生成されます(&lt;code&gt;React.createElement("div")&lt;/code&gt;)が、作成したコンポーネントは生成されません(&lt;code&gt;React.createElement(MyComponent)&lt;/code&gt;)。</target>
        </trans-unit>
        <trans-unit id="2bc6cffb51efec5345d518d22e0c722de0a63bbe" translate="yes">
          <source>For VS 2013:</source>
          <target>VS2013の場合:</target>
        </trans-unit>
        <trans-unit id="614775d6367bb72e6635063a6e9a003dfc10d404" translate="yes">
          <source>For VS 2015:</source>
          <target>VS2015の場合:</target>
        </trans-unit>
        <trans-unit id="fabf9dab407dafe6e4158a0fb10d99a963d13936" translate="yes">
          <source>For a &lt;code&gt;n in x&lt;/code&gt; expression, where &lt;code&gt;n&lt;/code&gt; is a string literal or string literal type and &lt;code&gt;x&lt;/code&gt; is a union type, the &amp;ldquo;true&amp;rdquo; branch narrows to types which have an optional or required property &lt;code&gt;n&lt;/code&gt;, and the &amp;ldquo;false&amp;rdquo; branch narrows to types which have an optional or missing property &lt;code&gt;n&lt;/code&gt;.</source>
          <target>x&lt;/code&gt;式の&lt;code&gt;nの場合、&lt;code&gt;n&lt;/code&gt;は文字列リテラルまたは文字列リテラルタイプ、&lt;code&gt;x&lt;/code&gt;はユニオンタイプです。&amp;ldquo;true&amp;rdquo;分岐は、オプションまたは必須のプロパティ&lt;code&gt;n&lt;/code&gt;を持つタイプに限定され、&amp;ldquo;false&amp;rdquo;分岐は、オプションまたはプロパティ&lt;code&gt;n&lt;/code&gt;を持つタイプに限定されます。</target>
        </trans-unit>
        <trans-unit id="bd4a1795741dfb51c0f64c6c46aa294954e8a834" translate="yes">
          <source>For creating &lt;code&gt;--incremental&lt;/code&gt; builds, users can leverage the &lt;code&gt;createIncrementalProgram&lt;/code&gt; and &lt;code&gt;createIncrementalCompilerHost&lt;/code&gt; APIs. Users can also re-hydrate old program instances from &lt;code&gt;.tsbuildinfo&lt;/code&gt; files generated by this API using the newly exposed &lt;code&gt;readBuilderProgram&lt;/code&gt; function, which is only meant to be used as for creating new programs (i.e. you can&amp;acirc;&amp;euro;&amp;trade;t modify the returned instance - it&amp;acirc;&amp;euro;&amp;trade;s only meant to be used for the &lt;code&gt;oldProgram&lt;/code&gt; parameter in other &lt;code&gt;create*Program&lt;/code&gt; functions).</source>
          <target>&lt;code&gt;--インクリメンタル&lt;/code&gt;ビルドを作成するために、ユーザは&lt;code&gt;createIncrementalProgram&lt;/code&gt;および&lt;code&gt;createIncrementalCompilerHost&lt;/code&gt;APIを利用することができる。 ユーザは、このAPIによって生成された&lt;code&gt;.ツバイルドインフォ&lt;/code&gt;ファイルから、新しく公開された&lt;code&gt;readBuilderProgram&lt;/code&gt;関数を使用して古いプログラムインスタンスを再利用することもできます。これは、新しいプログラムを作成するためにのみ使用されることを意味します(つまり、&amp;acirc;&amp;euro;&amp;trade;t modify the returned instance-it&amp;acirc;&amp;euro;&amp;trade;s only intended to be used for the&lt;code&gt;oldProgram&lt;/code&gt;parameter in other&lt;code&gt;create*Program&lt;/code&gt;関数)。</target>
        </trans-unit>
        <trans-unit id="13c650c5b2c3bf134743f81ee8a751c72f2c46d5" translate="yes">
          <source>For declaration file authors who relay on built-in types, e.g. DOM APIs or built-in JS run-time constructors like &lt;code&gt;Symbol&lt;/code&gt; or &lt;code&gt;Iterable&lt;/code&gt;, triple-slash-reference lib directives are the recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.</source>
          <target>DOM APIや&lt;code&gt;Symbol&lt;/code&gt;や&lt;code&gt;Iterable&lt;/code&gt;などの組み込みJSランタイムコンストラクタなどの組み込み型を中継する宣言ファイル作成者には、トリプルスラッシュ参照ライブラリディレクティブを推奨します。 以前は、これらの.d.tsファイルには、このような型の宣言を転送/複製する必要がありました。</target>
        </trans-unit>
        <trans-unit id="f730367034cc3e65c4c80c7cc48438917a47a1a4" translate="yes">
          <source>For declaration file authors who rely on built-in types, e.g. DOM APIs or built-in JS run-time constructors like &lt;code&gt;Symbol&lt;/code&gt; or &lt;code&gt;Iterable&lt;/code&gt;, triple-slash-reference lib directives are recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.</source>
          <target>DOM APIや&lt;code&gt;Symbol&lt;/code&gt;や&lt;code&gt;Iterable&lt;/code&gt;のような組み込みJSランタイムコンストラクタなどの組み込み型に依存する宣言ファイル作成者には、トリプルスラッシュ参照ライブラリディレクティブを推奨します。 以前は、これらの.d.tsファイルには、このような型の宣言を転送/複製する必要がありました。</target>
        </trans-unit>
        <trans-unit id="c7b31102ddf3ec0f8a01da2c2c2faaf0cec3c40b" translate="yes">
          <source>For declaration files generated during compilation, the compiler will automatically add &lt;code&gt;/// &amp;lt;reference types="..." /&amp;gt;&lt;/code&gt; for you; A &lt;code&gt;/// &amp;lt;reference types="..." /&amp;gt;&lt;/code&gt; in a generated declaration file is added &lt;em&gt;if and only if&lt;/em&gt; the resulting file uses any declarations from the referenced package.</source>
          <target>コンパイル中に生成された宣言ファイルの場合、コンパイラは自動的に&lt;code&gt;///&amp;lt;reference types="."/&amp;gt;&lt;/code&gt;を追加します。 生成された宣言ファイル内の&lt;code&gt;///&amp;lt;reference types="."/&amp;gt;&lt;/code&gt;は、&lt;/em&gt;が参照されたパッケージの宣言を使用する場合にのみ&lt;em&gt;追加されます。</target>
        </trans-unit>
        <trans-unit id="4710530ea547f1515550efbf2971f53cc2a8b738" translate="yes">
          <source>For declaring a dependency on an &lt;code&gt;@types&lt;/code&gt; package in a &lt;code&gt;.ts&lt;/code&gt; file, use &lt;code&gt;--types&lt;/code&gt; on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt; instead. See &lt;a href="tsconfig-json#types-typeroots-and-types"&gt;using &lt;code&gt;@types&lt;/code&gt;, &lt;code&gt;typeRoots&lt;/code&gt; and &lt;code&gt;types&lt;/code&gt; in &lt;code&gt;tsconfig.json&lt;/code&gt; files&lt;/a&gt; for more details.</source>
          <target>&lt;code&gt;.ts&lt;/code&gt;ファイルの&lt;code&gt;@types&lt;/code&gt;パッケージへの依存性を宣言するには、コマンドラインまたは&lt;code&gt;tsconfig.json&lt;/code&gt;で&lt;code&gt;--types&lt;/code&gt;を使用します。 詳細は&lt;code&gt;tsconfig.json&lt;/code&gt;ファイル&lt;/a&gt;の&lt;a href="tsconfig json#typesティピリッツand types"&gt;using&lt;code&gt;@types&lt;/code&gt;,&lt;code&gt;typeRoots&lt;/code&gt;and&lt;code&gt;types&lt;/code&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b927d147a48a1d8a678317e5dc270ab1fa0bd354" translate="yes">
          <source>For example consider this project structure:</source>
          <target>たとえば、次のプロジェクト構造を考えてみます。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes">
          <source>For example,</source>
          <target>たとえば</target>
        </trans-unit>
        <trans-unit id="b84169ea004a1106235d82bc2a5c66557575c167" translate="yes">
          <source>For example, adding &lt;code&gt;/// &amp;lt;reference lib="es2017.string" /&amp;gt;&lt;/code&gt; to one of the files in a compilation is equivalent to compiling with &lt;code&gt;--lib es2017.string&lt;/code&gt;.</source>
          <target>たとえば、コンパイル時に&lt;code&gt;///&amp;lt;reference lib="es2017.string"/&amp;gt;&lt;/code&gt;をファイルの1つに追加することは、&lt;code&gt;--lib es2017.string&lt;/code&gt;でコンパイルすることと同じです。</target>
        </trans-unit>
        <trans-unit id="9f435730a5bc00012d3042f3d1a8d4332e64f206" translate="yes">
          <source>For example, an import statement like &lt;code&gt;import { b } from "./moduleB"&lt;/code&gt; in &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; would result in attempting the following locations for locating &lt;code&gt;"./moduleB"&lt;/code&gt;:</source>
          <target>たとえば、&lt;code&gt;/root/src/moduleA.ts&lt;/code&gt;の&lt;code&gt;import{b}from"./moduleB"&lt;/code&gt;のようなimport文は、&lt;code&gt;"./moduleB"&lt;/code&gt;を探すために次の場所を試行します。</target>
        </trans-unit>
        <trans-unit id="4dfb27ce129bee760fed1ebcb688044df6ad992b" translate="yes">
          <source>For example, given the decorator &lt;code&gt;@sealed&lt;/code&gt; we might write the &lt;code&gt;sealed&lt;/code&gt; function as follows:</source>
          <target>例えば、デコレータ&lt;code&gt;@sealed&lt;/code&gt;が与えられると、&lt;code&gt;sealed&lt;/code&gt;関数を以下のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="ba290a075f0c2045568e30b972340550a085db75" translate="yes">
          <source>For example, including &lt;code&gt;/// &amp;lt;reference types="node" /&amp;gt;&lt;/code&gt; in a declaration file declares that this file uses names declared in &lt;code&gt;@types/node/index.d.ts&lt;/code&gt;; and thus, this package needs to be included in the compilation along with the declaration file.</source>
          <target>たとえば、宣言ファイルに&lt;code&gt;////&amp;lt;reference types="node"/&amp;gt;&lt;/code&gt;を含めると、このファイルは&lt;code&gt;@types/node/index.d.ts&lt;/code&gt;で宣言された名前を使用することが宣言されます。したがって、このパッケージを宣言ファイルとともにコンパイルに含める必要があります。</target>
        </trans-unit>
        <trans-unit id="271ea1bb02deba3a812371e1a07bac3086bd5d52" translate="yes">
          <source>For example, it&amp;acirc;&amp;euro;&amp;trade;s often very common to forget to &lt;code&gt;.then()&lt;/code&gt; or &lt;code&gt;await&lt;/code&gt; the contents of a &lt;code&gt;Promise&lt;/code&gt; before passing it to another function. TypeScript&amp;acirc;&amp;euro;&amp;trade;s error messages are now specialized, and inform the user that perhaps they should consider using the &lt;code&gt;await&lt;/code&gt; keyword.</source>
          <target>たとえば、&lt;code&gt;Promise&lt;/code&gt;の内容を&lt;code&gt;.then()&lt;/code&gt;または&lt;code&gt;await&lt;/code&gt;してから別の関数に渡すのを忘れるのは、&amp;acirc;&amp;euro;&amp;trade;でよくあることです。 TypeScript&amp;acirc;&amp;euro;&amp;trade;のエラーメッセージが特殊化され、おそらく&lt;code&gt;await&lt;/code&gt;キーワードの使用を検討する必要があることをユーザに通知します。</target>
        </trans-unit>
        <trans-unit id="ffcedc1552ccfc47d112e6dad0906deb0847258a" translate="yes">
          <source>For example, once you&amp;rsquo;ve &lt;code&gt;npm install&lt;/code&gt;-ed your type declarations, you can use imports and write</source>
          <target>たとえば、タイプ宣言をインストールしたら、importとwriteを使用できます。</target>
        </trans-unit>
        <trans-unit id="502a1d2b7504dbb10d71367198e70328d93e9cdc" translate="yes">
          <source>For example, some libraries add new functions to &lt;code&gt;Array.prototype&lt;/code&gt; or &lt;code&gt;String.prototype&lt;/code&gt;.</source>
          <target>たとえば、&lt;code&gt;Array.prototype&lt;/code&gt;または&lt;code&gt;String.prototype&lt;/code&gt;に新しい関数を追加するライブラリがあります。</target>
        </trans-unit>
        <trans-unit id="6eec7c26069b784720c61be112395d7efa3ccaf5" translate="yes">
          <source>For example, the following extracts the return type of a function type:</source>
          <target>たとえば、次の例では、関数型の戻り値型を抽出します。</target>
        </trans-unit>
        <trans-unit id="a37862b00fe2100e1e8f8d8cb1ffd54013028ebd" translate="yes">
          <source>For example, the following sample declares variables &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;, and initializes them to &lt;code&gt;getSomeObject().x&lt;/code&gt;, &lt;code&gt;getSomeObject().y&lt;/code&gt; and &lt;code&gt;getSomeObject().z&lt;/code&gt; respectively:</source>
          <target>たとえば、次の例では、変数&lt;code&gt;x&lt;/code&gt;、&lt;code&gt;y&lt;/code&gt;、および&lt;code&gt;z&lt;/code&gt;を宣言し、それぞれ&lt;code&gt;getSomeObject().x&lt;/code&gt;、&lt;code&gt;getSomeObject().y&lt;/code&gt;、および&lt;code&gt;getSomeObject().z&lt;/code&gt;に初期化します。</target>
        </trans-unit>
        <trans-unit id="3bfab5d35b8a0425d2cd933627ba6f494f7b15e6" translate="yes">
          <source>For example, we can add a static member to a class:</source>
          <target>たとえば、クラスに静的メンバーを追加できます。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes">
          <source>For example:</source>
          <target>例:</target>
        </trans-unit>
        <trans-unit id="49d355e75376d6e3edd30760b3a9dda119888e8c" translate="yes">
          <source>For function components (formerly known as SFCs) use ES2015 default initializers:</source>
          <target>関数コンポーネント(以前はSFCと呼ばれていました)の場合、ES2015デフォルト初期化子を使用します。</target>
        </trans-unit>
        <trans-unit id="6be2baf6180fb6fd27b9800124346282c6fe8435" translate="yes">
          <source>For function members, each function member of the same name is treated as describing an overload of the same function. Of note, too, is that in the case of interface &lt;code&gt;A&lt;/code&gt; merging with later interface &lt;code&gt;A&lt;/code&gt;, the second interface will have a higher precedence than the first.</source>
          <target>関数メンバーの場合、同じ名前の各関数メンバーは、同じ関数のオーバーロードを記述するものとして扱われます。 また、インターフェイス&lt;code&gt;A&lt;/code&gt;が後のインターフェイス&lt;code&gt;A&lt;/code&gt;とマージする場合、2番目のインターフェイスの方が最初のインターフェイスよりも優先順位が高くなります。</target>
        </trans-unit>
        <trans-unit id="550510b2afc3402e9b75627c000d9fd8d68b9d48" translate="yes">
          <source>For function types to correctly type check, the names of the parameters do not need to match. We could have, for example, written the above example like this:</source>
          <target>関数型がチェックを正しく入力するためには、パラメータの名前を一致させる必要はありません。 たとえば、上記の例を次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="6e49fcf610fb59d8414be6f760fd4d96f45600af" translate="yes">
          <source>For generic types that do not have their type arguments specified, compatibility is checked by specifying &lt;code&gt;any&lt;/code&gt; in place of all unspecified type arguments. The resulting types are then checked for compatibility, just as in the non-generic case.</source>
          <target>型引数が指定されていない汎用型では、型引数が指定されていないすべての型引数の代わりに&lt;code&gt;any&lt;/code&gt;を指定することによって互換性がチェックされます。 次に、非ジェネリックの場合と同様に、結果の型の互換性がチェックされます。</target>
        </trans-unit>
        <trans-unit id="5b3be90cb960b60b8143e001874d26a541dce254" translate="yes">
          <source>For instance, &lt;code&gt;React.Component&lt;/code&gt; is defined to have two type parameters, &lt;code&gt;Props&lt;/code&gt; and &lt;code&gt;State&lt;/code&gt;. In a &lt;code&gt;.js&lt;/code&gt; file, there is no legal way to specify these in the extends clause. By default the type arguments will be &lt;code&gt;any&lt;/code&gt;:</source>
          <target>たとえば、&lt;code&gt;React.Component&lt;/code&gt;は、&lt;code&gt;Props&lt;/code&gt;と&lt;code&gt;State&lt;/code&gt;の2つのタイプパラメータを持つように定義されています。&lt;code&gt;.js&lt;/code&gt;ファイルでは、extends文節でこれらを指定する法的な方法はありません。 デフォルトでは、型引数は&lt;code&gt;any&lt;/code&gt;です。</target>
        </trans-unit>
        <trans-unit id="ad0724dca69663ba4a457c62bb2dc6d54f13c7f2" translate="yes">
          <source>For instance, an import to a module &lt;code&gt;"jquery"&lt;/code&gt; would be translated at runtime to &lt;code&gt;"node_modules/jquery/dist/jquery.slim.min.js"&lt;/code&gt;.</source>
          <target>たとえば、モジュール&lt;code&gt;"jquery"&lt;/code&gt;へのインポートは、実行時に&lt;code&gt;"node_modules/jquery/dist/jquery.slim.min.js"&lt;/code&gt;に変換される。</target>
        </trans-unit>
        <trans-unit id="e127b9ec7aa54a885066eddbf73a9390682ef004" translate="yes">
          <source>For instance, if you have something that&amp;rsquo;s typed as &lt;code&gt;Object&lt;/code&gt; you won&amp;rsquo;t be able to call methods like &lt;code&gt;toLowerCase()&lt;/code&gt; on it. Being more general usually means you can do less with a type, but &lt;code&gt;any&lt;/code&gt; is special in that it is the most general type while still allowing you to do anything with it. That means you can call it, construct it, access properties on it, etc. Keep in mind though, whenever you use &lt;code&gt;any&lt;/code&gt;, you lose out on most of the error checking and editor support that TypeScript gives you.</source>
          <target>たとえば、&amp;rsquo;が&lt;code&gt;Object&lt;/code&gt;とタイプしたものがある場合、&lt;code&gt;toLowerCase()&lt;/code&gt;のようなメソッドを呼び出せません。 より一般的であるということは、通常、型に対してより少ないことを意味しますが、&lt;code&gt;any&lt;/code&gt;は、それが最も一般的な型でありながら、それを使って何かを行うことができるという点で特別です。 &lt;code&gt;のいずれか&lt;/code&gt;を使うと、TypeScriptが提供するエラーチェックやエディタサポートのほとんどを失うことに注意してください。</target>
        </trans-unit>
        <trans-unit id="76f20136bdec4c8a094a4948f37f41bd9373cd0e" translate="yes">
          <source>For instance, the following interfaces will merge together:</source>
          <target>たとえば、次のインタフェースがマージされます。</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes">
          <source>For instance:</source>
          <target>例:</target>
        </trans-unit>
        <trans-unit id="cc15a1d1ae77d156b224c9eb01c61c6a21c1a488" translate="yes">
          <source>For intrinsic elements, it is the type of the property on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;</source>
          <target>組み込み要素の場合、&lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;のプロパティの型です。</target>
        </trans-unit>
        <trans-unit id="63e99ee6fde01714eebc90d83730b70795fea95a" translate="yes">
          <source>For leveraging project references, a new &lt;code&gt;createSolutionBuilder&lt;/code&gt; function has been exposed, which returns an instance of the new type &lt;code&gt;SolutionBuilder&lt;/code&gt;.</source>
          <target>プロジェクト参照を活用するために、新しい&lt;code&gt;createSolutionBuilder&lt;/code&gt;関数が公開され、新しい型&lt;code&gt;SolutionBuilder&lt;/code&gt;のインスタンスが返されました。</target>
        </trans-unit>
        <trans-unit id="d4f49775acc3a4322a0557d39b3d6b9d1f2d24cf" translate="yes">
          <source>For more details on the change, &lt;a href="https://github.com/Microsoft/TypeScript/issues/2983"&gt;see the pull request here&lt;/a&gt;.</source>
          <target>変更の詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/issues/2983"&gt;ここにあるプルリクエスト&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="43fc548897db905fa8c2333f2655e946bf2edbda" translate="yes">
          <source>For more details on the implementation, see &lt;a href="https://github.com/Microsoft/TypeScript/pull/29332"&gt;the feature&amp;rsquo;s pull request&lt;/a&gt;.</source>
          <target>実装の詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/pull/29332"&gt;機能のプルリクエスト&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c866e562806b98ab3450aefd85c82570ae3dbe52" translate="yes">
          <source>For more details on these APIs, you can &lt;a href="https://github.com/microsoft/TypeScript/pull/31432"&gt;see the original pull request&lt;/a&gt;.</source>
          <target>これらのAPIの詳細については、&lt;a href="https://github.com/microsoft/TypeScript/pull/31432"&gt;元のプル要求を参照&lt;/a&gt;してください。</target>
        </trans-unit>
        <trans-unit id="9db932b4f370cac7158608164dcc7323460cd641" translate="yes">
          <source>For more details, &lt;a href="https://github.com/Microsoft/TypeScript/pull/30552"&gt;see the pull request on GitHub to add &lt;code&gt;Omit&lt;/code&gt;&lt;/a&gt;, as well as &lt;a href="https://github.com/microsoft/TypeScript/pull/31134"&gt;the change to use &lt;code&gt;Omit&lt;/code&gt; for object rest&lt;/a&gt;.</source>
          <target>詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/pull/30552"&gt;GitHubのプルリクエストで&lt;code&gt;Omit&lt;/code&gt;&lt;/a&gt;を追加するとともに、&lt;a href="https://github.com/microsoft/TypeScript/pull/31134"&gt;オブジェクトの残りに&lt;code&gt;Omit&lt;/code&gt;を使用する変更&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="fc45d221d48c167e7361605c82635e85e5e5877b" translate="yes">
          <source>For more details, &lt;a href="https://github.com/Microsoft/TypeScript/pull/30776/files"&gt;see the pull request on GitHub&lt;/a&gt;.</source>
          <target>詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/pull/30776/files"&gt;GitHub&lt;/a&gt;のプルリクエストを参照してください。</target>
        </trans-unit>
        <trans-unit id="273ca0c112dc6b1882314478ee8c1e6544170b8e" translate="yes">
          <source>For more details, &lt;a href="https://github.com/microsoft/TypeScript/issues/30646"&gt;see the originating issue&lt;/a&gt;, as well as the pull requests that link back to it.</source>
          <target>詳細については、&lt;a href="https://github.com/microsoft/TypeScript/issues/30646"&gt;発生元の問題&lt;/a&gt;と、それにリンクするプル要求を参照してください。</target>
        </trans-unit>
        <trans-unit id="990cc8daa552812b9673fb27d79710d0a0853e7a" translate="yes">
          <source>For more details, &lt;a href="https://github.com/microsoft/TypeScript/pull/31801"&gt;see the corresponding pull request&lt;/a&gt;.</source>
          <target>詳細については、&lt;a href="https://github.com/microsoft/TypeScript/pull/31801"&gt;該当するプルリクエスト&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="0320510c766022af54173463f58fd051469373de" translate="yes">
          <source>For more details, &lt;a href="https://github.com/microsoft/TypeScript/pull/32584"&gt;see the original PR on GitHub&lt;/a&gt;.</source>
          <target>詳細については、&lt;a href="https://github.com/microsoft/TypeScript/pull/32584"&gt;GitHubのオリジナルPRを参照&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1fe5d1addf9d0d4b733550ed18ffe6381b947a86" translate="yes">
          <source>For more details, you can &lt;a href="https://github.com/Microsoft/TypeScript/pull/29510"&gt;check out the respective pull request&lt;/a&gt;.</source>
          <target>詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/pull/29510"&gt;それぞれのプルリクエストをチェックしてください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65484dc7f4c4daea7c1d319eb8233395f4407267" translate="yes">
          <source>For more details, you can &lt;a href="https://github.com/Microsoft/TypeScript/pull/30215"&gt;read more at the original change&lt;/a&gt;.</source>
          <target>詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/pull/30215"&gt;元の変更箇所を参照&lt;/a&gt;してください。</target>
        </trans-unit>
        <trans-unit id="563dc4e63b054412d2401fc516c6fac2d3df7317" translate="yes">
          <source>For more details, you can &lt;a href="https://github.com/microsoft/TypeScript/pull/30779"&gt;see the original pull request on GitHub&lt;/a&gt;.</source>
          <target>詳細については、&lt;a href="https://github.com/microsoft/TypeScript/pull/30779"&gt;GitHub&lt;/a&gt;でオリジナルのプルリクエストを参照してください。</target>
        </trans-unit>
        <trans-unit id="01a8abf26dc21e0236d3ae01896624d8b626ea07" translate="yes">
          <source>For more details, you can &lt;a href="https://github.com/microsoft/TypeScript/pull/32372"&gt;check out the original pull request&lt;/a&gt;.</source>
          <target>詳細については、&lt;a href="https://github.com/microsoft/TypeScript/pull/32372"&gt;オリジナルのプルリクエストをチェックしてください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d623177cf84777887441acfa37b705f15554d05f" translate="yes">
          <source>For more details, you can see the pull requests to</source>
          <target>詳細については、プル要求を参照してください。</target>
        </trans-unit>
        <trans-unit id="3e64e60d7e437a1ebcf2869771b212e3f2906370" translate="yes">
          <source>For more discussion about modules and namespaces see &lt;a href="namespaces-and-modules"&gt;Namespaces and Modules&lt;/a&gt;.</source>
          <target>モジュールと名前空間の詳細については、&lt;a href="namespaces and modules"&gt;Namespaces and Modules&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c362b5af66f291c8b84b625e56119e3fdeab25b4" translate="yes">
          <source>For more information about module, please see the &lt;a href="https://github.com/Microsoft/TypeScript/issues/2242"&gt;ES6 module support spec&lt;/a&gt;.</source>
          <target>モジュールの詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/issues/2242"&gt;ES6module support spec&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="570e8203155764ac5cbba766759ffb8d69bcac89" translate="yes">
          <source>For more information on temporal dead zones, see relevant content on the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let"&gt;Mozilla Developer Network&lt;/a&gt;.</source>
          <target>一時的なデッドゾーンの詳細については、&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let"&gt;Mozilla Developer Network&lt;/a&gt;の関連コンテンツを参照してください。</target>
        </trans-unit>
        <trans-unit id="c6fb17b499b05834e5a93ed9076041c12b5a0a99" translate="yes">
          <source>For more information see &lt;a href="http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx"&gt;Async Functions&lt;/a&gt; blog post.</source>
          <target>詳細については、&lt;a href="http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx"&gt;非同期関数&lt;/a&gt;のブログ投稿を参照してください。</target>
        </trans-unit>
        <trans-unit id="e181d79ed93cb811ae26b48402f5381960e6dbda" translate="yes">
          <source>For more information, &lt;a href="https://github.com/microsoft/TypeScript/pull/31166"&gt;see the relevant pull request&lt;/a&gt;.</source>
          <target>詳細については、&lt;a href="https://github.com/microsoft/TypeScript/pull/31166"&gt;該当するプルリクエスト&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b92828c4a7429aa0dedb168e31c48305dd400088" translate="yes">
          <source>For more information, please see the &lt;a href="https://github.com/Microsoft/TypeScript/issues/2249"&gt;Decorators&lt;/a&gt; proposal.</source>
          <target>詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/issues/2249"&gt;デコレータ&lt;/a&gt;提案書を参照してください。</target>
        </trans-unit>
        <trans-unit id="e5cfc8aafd6a1b42f41322e6dfe173a4a83dcba5" translate="yes">
          <source>For more information, see the &lt;a href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html"&gt;TypeScript spec&lt;/a&gt;.</source>
          <target>詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html"&gt;TypeScriptの仕様&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7b6d8db7682d13acc39e4cc45f1bdba1511a9906" translate="yes">
          <source>For more information, you can &lt;a href="https://github.com/microsoft/TypeScript/pull/33050"&gt;read up on the original pull request&lt;/a&gt;.</source>
          <target>詳細については、元のプル要求を&lt;a href="https://github.com/microsoft/TypeScript/pull/33050"&gt;読み上げる&lt;/a&gt;ことができます。</target>
        </trans-unit>
        <trans-unit id="343ef5950853198d94dec424b2d3547e8d8f6fca" translate="yes">
          <source>For more information, you can &lt;a href="https://github.com/microsoft/TypeScript/pull/33509"&gt;take a look at the original pull request for these changes&lt;/a&gt;.</source>
          <target>詳細については、&lt;a href="https://github.com/microsoft/TypeScript/pull/33509"&gt;これらの変更に対する元のプル要求を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="705c8bb533b7a415fffecd94e72c06081d3e2f68" translate="yes">
          <source>For non-relative module imports, however, the compiler walks up the directory tree starting with the directory containing the importing file, trying to locate a matching definition file.</source>
          <target>しかし、相対的でないモジュールインポートの場合、コンパイラはインポートファイルを含むディレクトリから始まるディレクトリツリーをたどり、一致する定義ファイルを探します。</target>
        </trans-unit>
        <trans-unit id="fe8f9cb290ffb799bb30074ff74b3c823de4c1a0" translate="yes">
          <source>For one, TypeScript can now make inferences for the return type of a call. This can improve your experience and catch errors. Something that now works:</source>
          <target>1つは、TypeScriptが呼び出しの戻り型を推論できるようになったことです。 これにより、操作性が向上し、エラーを検出できるようになります。 今ではうまくいっています</target>
        </trans-unit>
        <trans-unit id="8e2e83bc37a28c5942c02bb933ef427bb23983d8" translate="yes">
          <source>For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we support much the same types as you would expect in JavaScript, with a convenient enumeration type thrown in to help things along.</source>
          <target>プログラムが役に立つためには、数値、文字列、構造体、ブール値など、データの最も単純な単位を操作できる必要があります。 TypeScriptでは、JavaScriptとほぼ同じ型をサポートしており、便利な列挙型が組み込まれています。</target>
        </trans-unit>
        <trans-unit id="d3344c32461a0db1e0c782f128f60f424dfe694b" translate="yes">
          <source>For seasoned authors interested in the underlying mechanics of how declaration files work, the &lt;a href="deep-dive"&gt;Deep Dive&lt;/a&gt; section explains many advanced concepts in declaration writing, and shows how to leverage these concepts to create cleaner and more intuitive declaration files.</source>
          <target>&lt;a href="deep-dive"&gt;Deep Dive&lt;/a&gt;のセクションでは、宣言ファイルがどのように機能するかの基本的な仕組みに興味を持つ経験豊富な著者を対象に、宣言を書く上での多くの先進的な概念を説明し、これらの概念を活用してより簡潔で直感的な宣言ファイルを作成する方法を示します。</target>
        </trans-unit>
        <trans-unit id="13f368b0d84c902186b48234f4040bb16257c671" translate="yes">
          <source>For that reason, we have no immediate plans to provide downleveling support. On the bright side, Node 11 and newer versions of Chrome already support this feature, so you&amp;rsquo;ll be able to use BigInts there when targeting &lt;code&gt;esnext&lt;/code&gt;.</source>
          <target>そのため、ダウンラヴェリングでのサポートは当面予定していません。 明るい面では、Node11以降のバージョンのChromeはすでにこの機能をサポートしているので、&lt;code&gt;esnext&lt;/code&gt;をターゲットにするときにBigIntを使うことができる。</target>
        </trans-unit>
        <trans-unit id="a1b0a9136ffac4466c13d6e276a81e02a3314c15" translate="yes">
          <source>For the most part, type declaration packages should always have the same name as the package name on &lt;code&gt;npm&lt;/code&gt;, but prefixed with &lt;code&gt;@types/&lt;/code&gt;, but if you need, you can check out &lt;a href="https://aka.ms/types"&gt;https://aka.ms/types&lt;/a&gt; to find the package for your favorite library.</source>
          <target>ほとんどの場合、型宣言パッケージは常に&lt;code&gt;npm&lt;/code&gt;のパッケージ名と同じ名前である必要がありますが、&lt;code&gt;@types/&lt;/code&gt;というプレフィックスが付きますが、必要に応じて&lt;a href="https://aka.ms/types"&gt;https://aka.ms/types&lt;/a&gt;をチェックアウトして、好みのライブラリのパッケージを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="034fabf95397dd3d830d8bf8625f29b5fecddc83" translate="yes">
          <source>For the purposes of this article, &amp;ldquo;declaration merging&amp;rdquo; means that the compiler merges two separate declarations declared with the same name into a single definition. This merged definition has the features of both of the original declarations. Any number of declarations can be merged; it&amp;rsquo;s not limited to just two declarations.</source>
          <target>この記事では、&amp;ldquo;宣言のマージ&amp;rdquo;とは、コンパイラが同じ名前で宣言された2つの宣言を1つの定義にマージすることを意味します。 このマージされた定義には、両方の元の宣言の機能があります。 任意の数の宣言を結合できます。2つの宣言だけに制限されるわけではありません。</target>
        </trans-unit>
        <trans-unit id="14bbf380d646374ad4976a37ddd3a52586d0778f" translate="yes">
          <source>For the purposes of writing a declaration file, you&amp;rsquo;ll write the same code whether the module being changed is a plain module or UMD module.</source>
          <target>宣言ファイルを作成するには、変更するモジュールがプレーンモジュールかUMDモジュールかにかかわらず、同じコードを記述します。</target>
        </trans-unit>
        <trans-unit id="4aa3bad258aff42d4d06a5737732c3217bc98418" translate="yes">
          <source>For this feature and simplified props, be sure to be use the &lt;a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react"&gt;latest version of react.d.ts&lt;/a&gt;.</source>
          <target>この機能と単純化された小道具については、&lt;a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react"&gt;react.d.ts&lt;/a&gt;の最新バージョンを必ず使用してください。</target>
        </trans-unit>
        <trans-unit id="a33482387ee5a013d484cb5ab80e458b7353dca7" translate="yes">
          <source>For those unfamiliar, &lt;code&gt;setTimeout&lt;/code&gt; will try to execute a function after a certain number of milliseconds (though waiting for anything else to stop running).</source>
          <target>&lt;code&gt;setTimeout&lt;/code&gt;は、何ミリ秒後に関数を実行しようとします(ただし、他の関数の実行が停止するのを待ちます)。</target>
        </trans-unit>
        <trans-unit id="a2a4c15a4041ed86596a75791caa9f86b76bf038" translate="yes">
          <source>For value-based elements, it is a bit more complex. It is determined by the type of a property on the &lt;em&gt;element instance type&lt;/em&gt; that was previously determined. Which property to use is determined by &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt;. It should be declared with a single property. The name of that property is then used. As of TypeScript 2.8, if &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; is not provided, the type of first parameter of the class element&amp;rsquo;s constructor or Function Component&amp;rsquo;s call will be used instead.</source>
          <target>値ベースの要素の場合は、もう少し複雑です。 これは、前に決定された&lt;em&gt;要素インスタンスタイプ&lt;/em&gt;のプロパティのタイプによって決まります。 使用するプロパティは、&lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt;によって決定されます。単一のプロパティで宣言する必要があります。 そのプロパティの名前が使用されます。 TypeScript2.8の時点では、&lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt;が提供されていない場合、クラス要素のコンストラクタまたは関数コンポーネントの呼び出しの最初のパラメータの型が代わりに使用される。</target>
        </trans-unit>
        <trans-unit id="cd4106b2c3bf5670711745c735fa13bc35a27218" translate="yes">
          <source>From TypeScript 3.7 and onwards, you can use &lt;a href="release-notes/typescript-3-7#optional-chaining"&gt;optional chaining&lt;/a&gt; to simplify working with nullable types.</source>
          <target>TypeScript3.7以降では、&lt;a href="release-notes/typescript-3-7#optional chaining"&gt;optional chaining&lt;/a&gt;を使用して、ヌル可能な型の操作を簡単にすることができます。</target>
        </trans-unit>
        <trans-unit id="2c70347006d57179eb4e0296dfeec4d48fd56374" translate="yes">
          <source>From a Global Library</source>
          <target>グローバルライブラリから</target>
        </trans-unit>
        <trans-unit id="7a9218b43b092d03a0883f8b7857dbb282cdf813" translate="yes">
          <source>From a Module or UMD Library</source>
          <target>モジュールまたはUMDライブラリから</target>
        </trans-unit>
        <trans-unit id="3f9c703cb24035f076046daf82d5597961381bc0" translate="yes">
          <source>From a PowerShell command window, run:</source>
          <target>PowerShellコマンドウィンドウから、次のコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="108836dc86d3f675e6c3eef00af882d27efb9073" translate="yes">
          <source>From there you&amp;rsquo;ll be able to use lodash in your TypeScript code with no fuss. This works for both modules and global code.</source>
          <target>そこから、TypeScriptコードでlodashを使うことができます。 これは、モジュールとグローバルコードの両方で機能します。</target>
        </trans-unit>
        <trans-unit id="50c9f7eb832e49ced6feaff6d4be4040d50a7444" translate="yes">
          <source>From this point on, we&amp;rsquo;re going to assume that your directory is set up something like this:</source>
          <target>ここからは、ディレクトリが次のように設定されていると仮定します。</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes">
          <source>Function</source>
          <target>関数</target>
        </trans-unit>
        <trans-unit id="1177b1db377a31fa211c1c837c048902a33fbabc" translate="yes">
          <source>Function Component</source>
          <target>関数コンポーネント</target>
        </trans-unit>
        <trans-unit id="14e60fa4031e0e6cd85f9e19b012d6dbfc7853ec" translate="yes">
          <source>Function Component (FC)</source>
          <target>機能コンポーネント(FC)</target>
        </trans-unit>
        <trans-unit id="957953f67e0718500a80224139b161eb239e35fa" translate="yes">
          <source>Function Components in React</source>
          <target>Reactの関数コンポーネント</target>
        </trans-unit>
        <trans-unit id="37eaf4a6db3ea0747ab9364bd4d5e24895e0a544" translate="yes">
          <source>Function Overloads</source>
          <target>関数オーバーロード</target>
        </trans-unit>
        <trans-unit id="a258c02eba54e3e0953a40abe8602fb6e1a74ef6" translate="yes">
          <source>Function Parameter Bivariance</source>
          <target>関数パラメータBivariance</target>
        </trans-unit>
        <trans-unit id="c57d64280c18c54778c8d1947833e0036b6e26da" translate="yes">
          <source>Function Truthy Checks</source>
          <target>関数Truthyチェック</target>
        </trans-unit>
        <trans-unit id="5b51ae5c386fcffd7ce1ff55e49610a2a8af3637" translate="yes">
          <source>Function Types</source>
          <target>関数の型</target>
        </trans-unit>
        <trans-unit id="301ffb948f7d729015635b11db6553b40624b34f" translate="yes">
          <source>Function declarations</source>
          <target>関数宣言</target>
        </trans-unit>
        <trans-unit id="c5db83a75bbeef08fa2e0b320c74460786ae66aa" translate="yes">
          <source>Function parameters are checked one at a time, with the type in each corresponding parameter position checked against each other. If you do not want to specify types at all, TypeScript&amp;rsquo;s contextual typing can infer the argument types since the function value is assigned directly to a variable of type &lt;code&gt;SearchFunc&lt;/code&gt;. Here, also, the return type of our function expression is implied by the values it returns (here &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt;).</source>
          <target>関数パラメータは一度に1つずつチェックされ、対応する各パラメータ位置のタイプが相互にチェックされます。 型をまったく指定しない場合、関数値は&lt;code&gt;SearchFunc&lt;/code&gt;型の変数に直接代入されるため、TypeScript&amp;rsquo;のコンテキスト型を使用すると、引数の型を推測できます。また、関数式の戻り値の型は、戻り値(ここでは&lt;code&gt;false&lt;/code&gt;と&lt;code&gt;true&lt;/code&gt;)によって示されます。</target>
        </trans-unit>
        <trans-unit id="53ffe91c4f4d77a902ebdf074913f42349003bbc" translate="yes">
          <source>Function parameters are optional by default</source>
          <target>関数パラメータはデフォルトではオプションです。</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes">
          <source>Functions</source>
          <target>関数</target>
        </trans-unit>
        <trans-unit id="f3665432e1a6db576efaea1b6e2d8f839bcdcc98" translate="yes">
          <source>Functions are the fundamental building block of any application in JavaScript. They&amp;rsquo;re how you build up layers of abstraction, mimicking classes, information hiding, and modules. In TypeScript, while there are classes, namespaces, and modules, functions still play the key role in describing how to &lt;em&gt;do&lt;/em&gt; things. TypeScript also adds some new capabilities to the standard JavaScript functions to make them easier to work with.</source>
          <target>関数は、JavaScriptアプリケーションの基本的な構成要素です。 抽象化のレイヤを構築する方法、クラスを模倣する方法、情報を隠蔽する方法、そしてモジュールを構築する方法について説明します。 TypeScriptにはクラス、名前空間、モジュールがありますが、関数は&lt;em&gt;の&lt;/em&gt;方法を記述する上で重要な役割を果たします。 TypeScriptはまた、標準的なJavaScript関数にいくつかの新しい機能を追加して、それらを使いやすくしている。</target>
        </trans-unit>
        <trans-unit id="16cd3a7ed4cd7f04f6e352a9b0a671ae06c3867d" translate="yes">
          <source>Functions with code paths that do not return a value in JS implicitly return &lt;code&gt;undefined&lt;/code&gt;. These can now be flagged by the compiler as implicit returns. The check is turned &lt;em&gt;off&lt;/em&gt; by default; use &lt;code&gt;--noImplicitReturns&lt;/code&gt; to turn it on.</source>
          <target>JSで値を返さないコードパスを持つ関数は、暗黙的に&lt;code&gt;undefined&lt;/code&gt;を返します。コンパイラは、これらの関数に暗黙的なリターンとしてフラグを付けることができます。 チェックはデフォルトで&lt;em&gt;オフ&lt;/em&gt;になっています。オンにするには&lt;code&gt;--noImplicitReturns&lt;/code&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="ecfd08105c3b9ed934caafb326908c0acb570490" translate="yes">
          <source>Functions with overloads</source>
          <target>オーバーロードを持つ関数</target>
        </trans-unit>
        <trans-unit id="4f257e8843abb1bab8a5b85a60f95a4c0139aa46" translate="yes">
          <source>Functions: this</source>
          <target>関数:これ</target>
        </trans-unit>
        <trans-unit id="6089bda1a34a0c953770c8e3b78bec0ef08e1cc9" translate="yes">
          <source>Furthermore, TypeScript also has the notion of &lt;em&gt;global&lt;/em&gt; augmentations of the form &lt;code&gt;declare global { }&lt;/code&gt;. This allows modules to augment global types such as &lt;code&gt;Array&lt;/code&gt; if necessary.</source>
          <target>さらに、TypeScriptには、&lt;code&gt;declare global{}&lt;/code&gt;という形式を&lt;em&gt;global&lt;/em&gt;に拡張するという概念もあります。これにより、モジュールは必要に応じて&lt;code&gt;Array&lt;/code&gt;などのグローバル型を拡張できます。</target>
        </trans-unit>
        <trans-unit id="4df80e4187f2b8baf6d47a6fdeef464676adeda2" translate="yes">
          <source>Furthermore, in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, control flow based type analysis includes &lt;em&gt;definite assignment analysis&lt;/em&gt; for local variables of types that don&amp;rsquo;t permit the value &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target>さらに、&lt;code&gt;--strictNullChecks&lt;/code&gt;モードでは、制御フローベースの型分析には、値&lt;code&gt;undefined&lt;/code&gt;を許可しない型のローカル変数に対する&lt;em&gt;確定代入分析&lt;/em&gt;が含まれます。</target>
        </trans-unit>
        <trans-unit id="4555cf9391c55bd00cbf4478f57ad7eeaa920c72" translate="yes">
          <source>Furthermore, with the &lt;code&gt;keyof&lt;/code&gt; operator&amp;acirc;&amp;euro;&amp;trade;s support for &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named keys, it is now possible to abstract over access to properties of objects that are indexed by numeric literals (such as numeric enum types) and unique symbols.</source>
          <target>さらに、&lt;code&gt;keyof&lt;/code&gt;演算子&amp;acirc;&amp;euro;&amp;trade;の&lt;code&gt;number&lt;/code&gt;および&lt;code&gt;symbol&lt;/code&gt;名前付きキーのサポートにより、数値リテラル(数値列挙型など)および一意のシンボルによってインデックス付けされたオブジェクトのプロパティへのアクセスを抽象化できるようになりました。</target>
        </trans-unit>
        <trans-unit id="0c7eb0b3402889bd567c0d3af8902acae19e04ce" translate="yes">
          <source>General Types</source>
          <target>一般タイプ</target>
        </trans-unit>
        <trans-unit id="b2fce69037144d8c17c57e4cd48ef47f73df98fb" translate="yes">
          <source>Generated JS code:</source>
          <target>生成されたJSコード:</target>
        </trans-unit>
        <trans-unit id="819ddb970af7944124739b463d184873a1a7a985" translate="yes">
          <source>Generates a cpu profile at the given path. Passing an existing directory name instead of a file path will cause a timestamp-named profile to be generated in that directory instead.</source>
          <target>指定されたパスでCPUプロファイルを生成します。 ファイル・パスの代わりに既存のディレクトリ名を渡すと、代わりにprofileという名前のタイムスタンプがそのディレクトリに生成されます。</target>
        </trans-unit>
        <trans-unit id="2d8f07103db6977c68e0ada027ab65c5c23862d9" translate="yes">
          <source>Generates a sourcemap for each corresponding &amp;lsquo;.d.ts&amp;rsquo; file.</source>
          <target>対応する各&amp;lsquo;.d.ts&amp;rsquo;ファイルのソースマップを生成します。</target>
        </trans-unit>
        <trans-unit id="a2e42f3b65f8aeda6abb391f2b5c0feb9f71f346" translate="yes">
          <source>Generates corresponding &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target>対応する&lt;code&gt;.d.ts&lt;/code&gt;ファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="285e568bc8b6f7ba3db03d758216b4279b6fb84a" translate="yes">
          <source>Generates corresponding &lt;code&gt;.map&lt;/code&gt; file.</source>
          <target>対応する&lt;code&gt;.map&lt;/code&gt;ファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="0edb628a9542a14f813bd7de9f8386b56c8a58b5" translate="yes">
          <source>Generates:</source>
          <target>生成:</target>
        </trans-unit>
        <trans-unit id="a3e705cc61a19f33d7c9c030f107a70569966485" translate="yes">
          <source>Generators</source>
          <target>ジェネレータ</target>
        </trans-unit>
        <trans-unit id="44da76948f45623de7d336c343233faa5d2b509e" translate="yes">
          <source>Generators and Iteration for ES5/ES3</source>
          <target>ES5/ES3のジェネレータとイテレーション</target>
        </trans-unit>
        <trans-unit id="052f4c16b4b91a827312bf3baa166ba53bfe5efa" translate="yes">
          <source>Generic Classes</source>
          <target state="translated">ジェネリッククラス</target>
        </trans-unit>
        <trans-unit id="c1219cf49a0e939b3e16bf04e12e2eafc84ee7fd" translate="yes">
          <source>Generic Constraints</source>
          <target>一般制約</target>
        </trans-unit>
        <trans-unit id="6e69a2fc2c745899f35839a75d651978ee056569" translate="yes">
          <source>Generic Types</source>
          <target state="translated">ジェネリック型</target>
        </trans-unit>
        <trans-unit id="15d759be2080d6d18e338e98d07714f4c409146a" translate="yes">
          <source>Generic object rest variables and parameters</source>
          <target state="translated">ジェネリックオブジェクトのレスト変数とパラメータ</target>
        </trans-unit>
        <trans-unit id="1fdeebd1c396649ca4cc647737cc5d4a10b10b8f" translate="yes">
          <source>Generic parameter defaults</source>
          <target state="translated">ジェネリックパラメータのデフォルト</target>
        </trans-unit>
        <trans-unit id="001622f41013d0601ab935e2183da475e787cfd4" translate="yes">
          <source>Generic rest parameters</source>
          <target state="translated">ジェネリックなレストパラメータ</target>
        </trans-unit>
        <trans-unit id="ee51cfb54175ecd5fb6d2ccc67d80a3554912ff7" translate="yes">
          <source>Generic rest parameters and corresponding inference of tuple types.</source>
          <target state="translated">ジェネリックのrestパラメータとタプル型の対応する推論。</target>
        </trans-unit>
        <trans-unit id="77980b7a1bd9bc29a811f3721a4ca0efc1244e89" translate="yes">
          <source>Generic spread expressions in object literals</source>
          <target>オブジェクトリテラル内の一般的な展開式</target>
        </trans-unit>
        <trans-unit id="a62000d34890a9f512301dfa28ec7342f3e45eb8" translate="yes">
          <source>Generic type aliases</source>
          <target state="translated">ジェネリック型エイリアス</target>
        </trans-unit>
        <trans-unit id="92dacb7528945ed9815a679921369b1471575a3f" translate="yes">
          <source>Generic type arguments in JSX elements</source>
          <target state="translated">JSX要素のジェネリック型引数</target>
        </trans-unit>
        <trans-unit id="f865cd9dc0cd462591b83a2927cb41d99ab230cd" translate="yes">
          <source>Generic type arguments in generic tagged templates</source>
          <target state="translated">ジェネリックタグ付きテンプレートのジェネリック型引数</target>
        </trans-unit>
        <trans-unit id="80dadd86173d0ff3979257793d4e45beb238b6a2" translate="yes">
          <source>Generics</source>
          <target>ジェネリック</target>
        </trans-unit>
        <trans-unit id="4d9ef11b75691cea9a6edfb497c3b9914c3b1021" translate="yes">
          <source>Generics: Types</source>
          <target state="translated">ジェネリック型</target>
        </trans-unit>
        <trans-unit id="00a40ea9152c19baaaa2f05a471ec1e36c25f25b" translate="yes">
          <source>Get started with a simple TypeScript app.</source>
          <target>簡単なTypeScriptアプリから始めましょう。</target>
        </trans-unit>
        <trans-unit id="5ef75e8c40e485b27abd25b4a16247e142017634" translate="yes">
          <source>Getting Declaration Files</source>
          <target>宣言ファイルの取得</target>
        </trans-unit>
        <trans-unit id="9ed37766bb349044c2259b48865fbf239e26a5e7" translate="yes">
          <source>Getting Stricter Checks</source>
          <target>厳格なチェックの取得</target>
        </trans-unit>
        <trans-unit id="b7b2818d4eceb3a3c55e7b64b0c852e4d5109657" translate="yes">
          <source>Getting around these checks is actually really simple. The easiest method is to just use a type assertion:</source>
          <target>これらのチェックを回避することは、実際には非常に簡単です。 最も簡単な方法は、型アサーションを使うことです。</target>
        </trans-unit>
        <trans-unit id="1ed2ad4b9d2d91f971b1ebd9e80d9238f9735423" translate="yes">
          <source>Getting to ES6/ES2015 built-in API declarations were only limited to &lt;code&gt;target: ES6&lt;/code&gt;. Enter &lt;code&gt;--lib&lt;/code&gt;; with &lt;code&gt;--lib&lt;/code&gt; you can specify a list of built-in API declaration groups that you can chose to include in your project. For instance, if you expect your runtime to have support for &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Promise&lt;/code&gt; (e.g. most evergreen browsers today), just include &lt;code&gt;--lib es2015.collection,es2015.promise&lt;/code&gt;. Similarly you can exclude declarations you do not want to include in your project, e.g. DOM if you are working on a node project using &lt;code&gt;--lib es5,es6&lt;/code&gt;.</source>
          <target>ES6/ES2015組み込みAPI宣言の取得は、&lt;code&gt;target:ES6&lt;/code&gt;に限定されていました。&lt;code&gt;--lib&lt;/code&gt;と入力すると、プロジェクトに含めることができる組み込みAPI宣言グループのリストを指定できます。 例えば、ランタイムが&lt;code&gt;Map&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;、&lt;code&gt;Promise&lt;/code&gt;(例えば、今日のほとんどの常緑ブラウザ)をサポートすることを期待しているなら、&lt;code&gt;--lib es2015.collection,es2015.promise&lt;/code&gt;をインクルードするだけです。同様に、&lt;code&gt;--lib es5,es6&lt;/code&gt;を使ってノードプロジェクトで作業している場合は、DOMなど、プロジェクトにインクルードしたくない宣言を除外することができます。</target>
        </trans-unit>
        <trans-unit id="ca2334233ff9d62586c90c8425d61ccf0156ad00" translate="yes">
          <source>Getting type declarations in TypeScript 2.0 and above requires no tools apart from npm.</source>
          <target>TypeScript2.0以降で型宣言を取得するにはnpm以外のツールは必要ありません。</target>
        </trans-unit>
        <trans-unit id="0128ee2411d4cce5db2af199ae139a20b41fb10c" translate="yes">
          <source>Given &lt;code&gt;&amp;lt;Expr /&amp;gt;&lt;/code&gt;, the &lt;em&gt;element class type&lt;/em&gt; is the type of &lt;code&gt;Expr&lt;/code&gt;. So in the example above, if &lt;code&gt;MyComponent&lt;/code&gt; was an ES6 class the class type would be that class&amp;rsquo;s constructor and statics. If &lt;code&gt;MyComponent&lt;/code&gt; was a factory function, the class type would be that function.</source>
          <target>&lt;code&gt;&amp;lt;Expr/&amp;gt;&lt;/code&gt;を指定すると、&lt;em&gt;要素のクラス型&lt;/em&gt;は&lt;code&gt;Expr&lt;/code&gt;の型になります。したがって、上の例では、&lt;code&gt;MyComponent&lt;/code&gt;がES6クラスの場合、クラス型はそのクラスのコンストラクタと静的型になります。 &lt;code&gt;MyComponent&lt;/code&gt;がファクトリー関数の場合、クラス・タイプはその関数になります。</target>
        </trans-unit>
        <trans-unit id="975e78d60e0d980036725e953131ac369a323b6f" translate="yes">
          <source>Given a declaration of a class &lt;code&gt;Pet&lt;/code&gt; in a module file:</source>
          <target>モジュールファイルにクラス&lt;code&gt;Pet&lt;/code&gt;の宣言があるとします。</target>
        </trans-unit>
        <trans-unit id="8083d6ae5a9d183ac1a96bad2a32806cb23140c9" translate="yes">
          <source>Given a name &lt;code&gt;A&lt;/code&gt;, we might find up to three different meanings for &lt;code&gt;A&lt;/code&gt;: a type, a value or a namespace. How the name is interpreted depends on the context in which it is used. For example, in the declaration &lt;code&gt;let m: A.A = A;&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is used first as a namespace, then as a type name, then as a value. These meanings might end up referring to entirely different declarations!</source>
          <target>&lt;code&gt;A&lt;/code&gt;という名前が与えられると、&lt;code&gt;A&lt;/code&gt;に対して最大3つの異なる意味、つまり型、値、名前空間を見つけることができます。 名前がどのように解釈されるかは、その名前が使われている文脈に依存する。 例えば、宣言&lt;code&gt;では、&lt;code&gt;let m:A.A=A;&lt;/code&gt;,&lt;code&gt;A&lt;/code&gt;は、最初に名前空間として、次に型名として、次に値として使用されます。 これらの意味は、まったく異なる宣言を参照することになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="a00264a5f3c6cd0479bb605da5bdecfcbf5f69bb" translate="yes">
          <source>Given an expression &lt;code&gt;Base&lt;/code&gt; of a parametric type &lt;code&gt;T&lt;/code&gt; with a constraint &lt;code&gt;X&lt;/code&gt;, a mixin class &lt;code&gt;class C extends Base {...}&lt;/code&gt; is processed as if &lt;code&gt;Base&lt;/code&gt; had type &lt;code&gt;X&lt;/code&gt; and the resulting type is the intersection &lt;code&gt;typeof C &amp;amp; T&lt;/code&gt;. In other words, a mixin class is represented as an intersection between the mixin class constructor type and the parametric base class constructor type.</source>
          <target>制約&lt;code&gt;X&lt;/code&gt;を持つパラメトリック型&lt;code&gt;T&lt;/code&gt;の式&lt;code&gt;Base&lt;/code&gt;が与えられると、mixinクラス&lt;code&gt;クラスCはBase{.}&lt;/code&gt;を拡張し、&lt;code&gt;Base&lt;/code&gt;が&lt;code&gt;X&lt;/code&gt;型であるかのように処理され、結果の型はC&amp;amp;T&lt;/code&gt;の交差&lt;code&gt;型になります。つまり、mixinクラスは、mixinクラスのコンストラクタ型とパラメトリックベースクラスのコンストラクタ型の交差として表されます。</target>
        </trans-unit>
        <trans-unit id="f747221667578c67b9937edae87fe4b1bb4a08b1" translate="yes">
          <source>Given an object type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;keyof X&lt;/code&gt; is resolved as follows:</source>
          <target>オブジェクトタイプ&lt;code&gt;X&lt;/code&gt;が与えられると、&lt;code&gt;keyof X&lt;/code&gt;は次のように解決されます。</target>
        </trans-unit>
        <trans-unit id="fa581e6e08169205d8be1ad319fd8832a173be18" translate="yes">
          <source>Given that we have two types of declarations with similar scoping semantics, it&amp;rsquo;s natural to find ourselves asking which one to use. Like most broad questions, the answer is: it depends.</source>
          <target>同じようなスコーピングのセマンティクスを持つ2つのタイプの宣言があることを考えると、どちらを使用するかを自問自答するのは当然です。 一般的な質問と同様に、答えは以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="610048c0b076b1fb8790fd96c3fc109500ce0670" translate="yes">
          <source>Given this project structure:</source>
          <target>このプロジェクト構造では</target>
        </trans-unit>
        <trans-unit id="05ab21d96c8cc217d9d3bf8ed1a8cf0dc14dc590" translate="yes">
          <source>Glob support in &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target>&lt;code&gt;tsconfig.json&lt;/code&gt;でのglobサポート</target>
        </trans-unit>
        <trans-unit id="ee29cd5c1e941ea77b1bcc2b4464658a76d6b503" translate="yes">
          <source>Glob support is here!! Glob support has been &lt;a href="https://github.com/Microsoft/TypeScript/issues/1927"&gt;one of the most requested features&lt;/a&gt;.</source>
          <target>glob support is here!glob support has been one of most requested features&lt;a href="https://github.com/Microsoft/TypeScript/issues/1927"&gt;&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="26021db1ea30cf082e152c820806cb17b431aff1" translate="yes">
          <source>Glob-like file patterns are supported two properties &lt;code&gt;"include"&lt;/code&gt; and &lt;code&gt;"exclude"&lt;/code&gt;.</source>
          <target>glob形式のファイルパターンには、&lt;code&gt;"include"&lt;/code&gt;と&lt;code&gt;"exclude"&lt;/code&gt;の2つのプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="ae4f56ae4da16df74b3d2aeca8b4352281e7be45" translate="yes">
          <source>Global Functions</source>
          <target>グローバル関数</target>
        </trans-unit>
        <trans-unit id="bb90b4e7b4f156d78c1c4607edb92deecea2726f" translate="yes">
          <source>Global Libraries</source>
          <target>グローバルライブラリ</target>
        </trans-unit>
        <trans-unit id="086706851e81b0cda50c1ad12a71bbbe92f2b609" translate="yes">
          <source>Global Library Template</source>
          <target>グローバルライブラリテンプレート</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes">
          <source>Global Variables</source>
          <target>グローバル変数</target>
        </trans-unit>
        <trans-unit id="f939f94390f04e9a571e774b88f07fa51a7034c9" translate="yes">
          <source>Global augmentation</source>
          <target>グローバル拡張</target>
        </trans-unit>
        <trans-unit id="d9627061a8f161c085d6425d99b5bcd04461ec21" translate="yes">
          <source>Global augmentations have the same behavior and limits as module augmentations.</source>
          <target>大域的拡大はモジュール拡大と同じ振舞いと制限を持つ。</target>
        </trans-unit>
        <trans-unit id="551b0be00de6f59a327fffe248fc43dd021a48e0" translate="yes">
          <source>Global library code is usually extremely simple. A global &amp;ldquo;Hello, world&amp;rdquo; library might look like this:</source>
          <target>グローバルライブラリコードは通常、非常に単純です。 グローバル&amp;ldquo;Hello,world&amp;rdquo;ライブラリは次のようになります。</target>
        </trans-unit>
        <trans-unit id="a2a3ce92a02e2b38f5f0131a3a2a15d9bd6e27fc" translate="yes">
          <source>Global plugins are generally easy to identify from their documentation.</source>
          <target>グローバルプラグインは通常、ドキュメントから簡単に識別できます。</target>
        </trans-unit>
        <trans-unit id="4f705c81915f4a397894296d2b81a9e9f219df5d" translate="yes">
          <source>Global-modifying modules are generally easy to identify from their documentation. In general, they&amp;rsquo;re similar to global plugins, but need a &lt;code&gt;require&lt;/code&gt; call to activate their effects.</source>
          <target>グローバル修正モジュールは、通常、マニュアルから簡単に識別できます。 一般に、グローバルプラグインと似ていますが、効果を有効にするには&lt;code&gt;require&lt;/code&gt;呼び出しが必要です。</target>
        </trans-unit>
        <trans-unit id="24713d72fbb7ed9e4d613388f61f4edcd1171735" translate="yes">
          <source>Go to &lt;code&gt;File&lt;/code&gt; &amp;gt; &lt;code&gt;Settings&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt;:</source>
          <target>&lt;code&gt;File&lt;/code&gt;&amp;gt;&lt;code&gt;Settings&lt;/code&gt;&amp;gt;&lt;code&gt;Languages&amp;amp;Frameworks&lt;/code&gt;&amp;gt;&lt;code&gt;TypeScript&lt;/code&gt;に移動します。</target>
        </trans-unit>
        <trans-unit id="cb7da868a3e2b03846cee16319e4528c9916294a" translate="yes">
          <source>Go to &lt;code&gt;Preferences&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt;:</source>
          <target>&lt;code&gt;Preferences&lt;/code&gt;&amp;gt;&lt;code&gt;Languages&amp;amp;Frameworks&lt;/code&gt;&amp;gt;&lt;code&gt;TypeScript&lt;/code&gt;に移動します。</target>
        </trans-unit>
        <trans-unit id="c06ca0601da1369de3d0247e6e4f8b7bbe8e4bfd" translate="yes">
          <source>Grunt</source>
          <target state="translated">Grunt</target>
        </trans-unit>
        <trans-unit id="b5e0b544d4f7e5ecf776c530d4637f9254bfad0b" translate="yes">
          <source>Guidance</source>
          <target>ガイダンス</target>
        </trans-unit>
        <trans-unit id="6b06b3debeeac8b24443fbaf25e471200f47e47b" translate="yes">
          <source>Guidance for structuring modules</source>
          <target>モジュール構造のガイダンス</target>
        </trans-unit>
        <trans-unit id="5a6238801e2733bcdc7249e97a255df97e530fc4" translate="yes">
          <source>Gulp</source>
          <target>ガルプ</target>
        </trans-unit>
        <trans-unit id="79914411b3c89953fe030c6c8025f0574c41a8f8" translate="yes">
          <source>Gulp: Add modules to the code</source>
          <target>Gulp:コードにモジュールを追加する</target>
        </trans-unit>
        <trans-unit id="21e98a38e254fad84f4a4bbd9e8fa3fea802a72c" translate="yes">
          <source>Gulp: Babel</source>
          <target state="translated">Gulp: Babel</target>
        </trans-unit>
        <trans-unit id="c3699841f2d588970283b562ce18c4a12378b39f" translate="yes">
          <source>Gulp: Browserify</source>
          <target state="translated">Gulp: Browserify</target>
        </trans-unit>
        <trans-unit id="67718aa41c7c302d8015e6a1f55245492dfe7b5f" translate="yes">
          <source>Gulp: Create a gulpfile.js</source>
          <target state="translated">Gulp:gulpfile.jsを作成する</target>
        </trans-unit>
        <trans-unit id="d5f376a8524ce9e40602f913685d1f14707f0f24" translate="yes">
          <source>Gulp: Create a page</source>
          <target>Gulp:ページを作成する</target>
        </trans-unit>
        <trans-unit id="26f1b5afe4ab8f7ba7d8e64daae6616d336e7b8d" translate="yes">
          <source>Gulp: Initialize the project</source>
          <target>Gulp:プロジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="89ec650baa395d7c6395a96eac5b8b07e6aefed3" translate="yes">
          <source>Gulp: Install our dependencies</source>
          <target>Gulp:依存関係をインストールする</target>
        </trans-unit>
        <trans-unit id="94ff547657bd3ea294e187a2a5b6c4e9da41ae2e" translate="yes">
          <source>Gulp: Minimal project</source>
          <target>Gulp:最小プロジェクト</target>
        </trans-unit>
        <trans-unit id="5bf88642d6a4c72b1400115e631d3c1241d0a62f" translate="yes">
          <source>Gulp: Test the resulting app</source>
          <target>Gulp:結果のアプリをテストする</target>
        </trans-unit>
        <trans-unit id="5c5e381120e6ca17177cab8dd1c9b114707b4f32" translate="yes">
          <source>Gulp: Uglify</source>
          <target state="translated">Gulp: Uglify</target>
        </trans-unit>
        <trans-unit id="378ef94af067892dc3f571669da77f2d28b9d848" translate="yes">
          <source>Gulp: Watchify</source>
          <target state="translated">Gulp: Watchify</target>
        </trans-unit>
        <trans-unit id="339b09b31f6400bfbd9df2cc056c03bbce7e1947" translate="yes">
          <source>Gulp: Write a simple example</source>
          <target>Gulp:簡単な例を書く</target>
        </trans-unit>
        <trans-unit id="28e2147303cd82753a34e2e9e286d0181633c0c4" translate="yes">
          <source>Had the function expression returned numbers or strings, the type checker would have made an error that indicates return type doesn&amp;rsquo;t match the return type described in the &lt;code&gt;SearchFunc&lt;/code&gt; interface.</source>
          <target>関数式が数値または文字列を返した場合、型チェッカーは、&lt;code&gt;SearchFunc&lt;/code&gt;インタフェースに記述された戻り値の型と一致しない戻り値の型を示すエラーを返します。</target>
        </trans-unit>
        <trans-unit id="9a7699299b167b02f3b309a214e186f89e6ac90a" translate="yes">
          <source>Hello World of Generics</source>
          <target>ジェネリック医薬品の世界</target>
        </trans-unit>
        <trans-unit id="4868c6cfe667dc94ff39de6f11b3b8c2dde32455" translate="yes">
          <source>Here &lt;code&gt;asserts val is string&lt;/code&gt; ensures that after any call to &lt;code&gt;assertIsString&lt;/code&gt;, any variable passed in will be known to be a &lt;code&gt;string&lt;/code&gt;.</source>
          <target>ここで、&lt;code&gt;assert val is string&lt;/code&gt;は、&lt;code&gt;assertIsString&lt;/code&gt;を呼び出した後、渡された変数が&lt;code&gt;string&lt;/code&gt;であると認識されることを保証する。</target>
        </trans-unit>
        <trans-unit id="217c263c0612cdb8818f0c2bb1cc2cee17136759" translate="yes">
          <source>Here &lt;code&gt;map.ts&lt;/code&gt; can declare that it will internally patch the &lt;code&gt;Observable&lt;/code&gt; type from &lt;code&gt;observable.ts&lt;/code&gt; and add the &lt;code&gt;map&lt;/code&gt; method to it.</source>
          <target>ここで、&lt;code&gt;map.ts&lt;/code&gt;は、&lt;code&gt;observable.ts&lt;/code&gt;から&lt;code&gt;Observable&lt;/code&gt;型を内部的にパッチし、&lt;code&gt;map&lt;/code&gt;メソッドをそれに追加することを宣言できます。</target>
        </trans-unit>
        <trans-unit id="b504fd8672cd71981cb916f0743aeadaf081b517" translate="yes">
          <source>Here are some notable differences on how checking works in &lt;code&gt;.js&lt;/code&gt; files compared to &lt;code&gt;.ts&lt;/code&gt; files:</source>
          <target>次に、&lt;code&gt;.js&lt;/code&gt;ファイルと&lt;code&gt;.ts&lt;/code&gt;ファイルでのチェックの動作の違いをいくつか示します。</target>
        </trans-unit>
        <trans-unit id="14fd63d436a290048d4c1831116810e1e69345e4" translate="yes">
          <source>Here is a list of available API groups:</source>
          <target>使用可能なAPIグループのリストを次に示します。</target>
        </trans-unit>
        <trans-unit id="83f91cc0372adb4b62657eb83b59506603d1d14b" translate="yes">
          <source>Here is a list of well-known symbols:</source>
          <target>よく知られたシンボルのリストを次に示します。</target>
        </trans-unit>
        <trans-unit id="d7c6390605af8c73015b19f7184792241b88e764" translate="yes">
          <source>Here is a simple test for the calculator using the exposed &lt;code&gt;test&lt;/code&gt; function.</source>
          <target>公開された&lt;code&gt;test&lt;/code&gt;関数を使用した電卓の簡単なテストを次に示します。</target>
        </trans-unit>
        <trans-unit id="d867fe52f6b4323b3aa6d543dd0bd5c2bb91d3f0" translate="yes">
          <source>Here is an example that demonstrates this distinction:</source>
          <target>この違いを示す例を次に示します。</target>
        </trans-unit>
        <trans-unit id="9d689481e7c027a1b04a6cc241ceab676b7e9d0f" translate="yes">
          <source>Here the syntax starts to get confusing. You can read &lt;code&gt;a: newName1&lt;/code&gt; as &amp;ldquo;&lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt;&amp;rdquo;. The direction is left-to-right, as if you had written:</source>
          <target>ここで、構文が混乱し始めます。 &lt;code&gt;a:newName1&lt;/code&gt;は&amp;ldquo;&lt;code&gt;a&lt;/code&gt;は&lt;code&gt;newName1&lt;/code&gt;&amp;rdquo;と読むことができます。 方向は左から右です。</target>
        </trans-unit>
        <trans-unit id="0e7c23e184f2a3fc2239ba7dd64a12dacf4b5975" translate="yes">
          <source>Here we explicitly set &lt;code&gt;T&lt;/code&gt; to be &lt;code&gt;string&lt;/code&gt; as one of the arguments to the function call, denoted using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; around the arguments rather than &lt;code&gt;()&lt;/code&gt;.</source>
          <target>ここでは、関数呼び出しの引数の1つとして&lt;code&gt;T&lt;/code&gt;を明示的に&lt;code&gt;string&lt;/code&gt;に設定し、&lt;code&gt;()&lt;/code&gt;ではなく&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;を引数の周りに使用して示します。</target>
        </trans-unit>
        <trans-unit id="4a521f4f8c69adda61863ae271ec13a08aca0267" translate="yes">
          <source>Here we need to create a variable to hold on to the neighbor-map so that we can initialize it. With TypeScript 1.5, we can let the compiler do the heavy lifting:</source>
          <target>ここでは、近隣マップを初期化できるように、近隣マップに保持する変数を作成する必要があります。 TypeScript1.5では、コンパイラに重い処理をさせることができる。</target>
        </trans-unit>
        <trans-unit id="f454fc62879aec4c05c5b0553ae23ecb3678fbdb" translate="yes">
          <source>Here we were able to copy over all the properties of &lt;code&gt;Person&lt;/code&gt; except for &lt;code&gt;location&lt;/code&gt; using the &lt;code&gt;Omit&lt;/code&gt; helper.</source>
          <target>ここでは、&lt;code&gt;Omit&lt;/code&gt;ヘルパーを使用して、&lt;code&gt;場所&lt;/code&gt;を除く&lt;code&gt;Person&lt;/code&gt;のすべてのプロパティをコピーできました。</target>
        </trans-unit>
        <trans-unit id="1036409900634ac21f92613c301ba8e5286a4bef" translate="yes">
          <source>Here we&amp;rsquo;re going to create a &lt;code&gt;Student&lt;/code&gt; class with a constructor and a few public fields. Notice that classes and interfaces play well together, letting the programmer decide on the right level of abstraction.</source>
          <target>ここでは、コンストラクタといくつかのpublicフィールドを持つ&lt;code&gt;Student&lt;/code&gt;クラスを作成します。 クラスとインターフェースがうまく連携しているので、プログラマーは適切なレベルの抽象化を決定することができます。</target>
        </trans-unit>
        <trans-unit id="285b0ed2d436f147e6b99b312065319a3bd9b594" translate="yes">
          <source>Here we&amp;rsquo;re specifying a few things to TypeScript:</source>
          <target>ここでは、TypeScriptにいくつかの項目を指定します(&amp;R):</target>
        </trans-unit>
        <trans-unit id="371971b4f21066fe668fdda84538194651b56819" translate="yes">
          <source>Here&amp;rsquo;s a revised example:</source>
          <target>ここでは、変更された例を示します。</target>
        </trans-unit>
        <trans-unit id="ecace45a094904ef8f89699739d61e7f83e4e706" translate="yes">
          <source>Here&amp;rsquo;s a simple example of an unreachable code error:</source>
          <target>到達不能コードエラーの簡単な例を次に示します。</target>
        </trans-unit>
        <trans-unit id="33855c52e889ba154150d2b3670aeb240d95c340" translate="yes">
          <source>Here&amp;rsquo;s an example of this pattern:</source>
          <target>このパターンの例を次に示します。</target>
        </trans-unit>
        <trans-unit id="4e232701f3c0f0553f27b93d9845181d7b9b01bd" translate="yes">
          <source>Here&amp;rsquo;s how you would write and use this function in TypeScript, using the &lt;strong&gt;index type query&lt;/strong&gt; and &lt;strong&gt;indexed access&lt;/strong&gt; operators:</source>
          <target>次に、&lt;strong&gt;インデックス型クエリ&lt;/strong&gt;および&lt;strong&gt;インデックス付きアクセス&lt;/strong&gt;演算子を使用して、TypeScriptでこの関数を記述し、使用する方法を示します。</target>
        </trans-unit>
        <trans-unit id="fb902d04d0d6f8c7ca19c25536908ff73f061681" translate="yes">
          <source>Here&amp;rsquo;s one more example, in which &lt;code&gt;T[P]&lt;/code&gt; is wrapped in a &lt;code&gt;Proxy&amp;lt;T&amp;gt;&lt;/code&gt; class:</source>
          <target>&lt;code&gt;T[P]&lt;/code&gt;が&lt;code&gt;Proxy&amp;lt;T&amp;gt;&lt;/code&gt;クラスにラップされているもう1つの例を次に示します。</target>
        </trans-unit>
        <trans-unit id="c2ea446bd29277ad18a8bf4252379c5046cdf44d" translate="yes">
          <source>Here, &lt;code&gt;SomeType&lt;/code&gt; appears to originate in both the &lt;code&gt;import&lt;/code&gt; declaration and the local &lt;code&gt;interface&lt;/code&gt; declaration. Perhaps surprisingly, inside the module, &lt;code&gt;SomeType&lt;/code&gt; refers exclusively to the &lt;code&gt;import&lt;/code&gt;ed definition, and the local declaration &lt;code&gt;SomeType&lt;/code&gt; is only usable when imported from another file. This is very confusing and our review of the very small number of cases of code like this in the wild showed that developers usually thought something different was happening.</source>
          <target>ここで、&lt;code&gt;SomeType&lt;/code&gt;は、&lt;code&gt;import&lt;/code&gt;宣言とローカルの&lt;code&gt;interface&lt;/code&gt;宣言の両方に由来するように見える。 モジュール内部では、&lt;code&gt;SomeType&lt;/code&gt;は&lt;code&gt;import&lt;/code&gt;ed定義のみを参照し、ローカル宣言&lt;code&gt;SomeType&lt;/code&gt;は別のファイルからインポートされた場合にのみ使用できます。 これは非常に混乱しており、このようなコードのごく少数の事例を検証した結果、開発者は通常、何か別のことが起こっていると考えていることがわかりました。</target>
        </trans-unit>
        <trans-unit id="a3816a0ed94cd7ceadd9968bd7c237ebde8a5f88" translate="yes">
          <source>Here, &lt;code&gt;Up&lt;/code&gt; would have the value &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;Down&lt;/code&gt; would have &lt;code&gt;1&lt;/code&gt;, etc. This auto-incrementing behavior is useful for cases where we might not care about the member values themselves, but do care that each value is distinct from other values in the same enum.</source>
          <target>ここで、&lt;code&gt;Up&lt;/code&gt;の値は&lt;code&gt;0&lt;/code&gt;、&lt;code&gt;Down&lt;/code&gt;の値は&lt;code&gt;1&lt;/code&gt;などになります。この自動増分動作は、メンバ値自体は考慮しないが、各値が同じenum内の他の値と区別されるようにする場合に便利です。</target>
        </trans-unit>
        <trans-unit id="57a9abf556999c9646907cab4f7c7e1dc771a6d2" translate="yes">
          <source>Here, &lt;code&gt;assertNever&lt;/code&gt; checks that &lt;code&gt;s&lt;/code&gt; is of type &lt;code&gt;never&lt;/code&gt; &amp;mdash; the type that&amp;rsquo;s left after all other cases have been removed. If you forget a case, then &lt;code&gt;s&lt;/code&gt; will have a real type and you will get a type error. This method requires you to define an extra function, but it&amp;rsquo;s much more obvious when you forget it.</source>
          <target>ここで、&lt;code&gt;assertNever&lt;/code&gt;は、&lt;code&gt;の&lt;/code&gt;タイプが&lt;code&gt;never&lt;/code&gt;であること(他のすべてのケースが削除された後に&amp;rsquo;sによって残されたタイプ)をチェックします。 大文字と小文字を忘れた場合、&lt;code&gt;s&lt;/code&gt;は実数型になり、型エラーになります。 この方法を使用するには、追加の関数を定義する必要がありますが、関数を忘れた場合には、より明確になります。</target>
        </trans-unit>
        <trans-unit id="d05882792ac23d4a8b28c31469c8bc7607445ef8" translate="yes">
          <source>Here, &lt;code&gt;let Greeter&lt;/code&gt; is going to be assigned the constructor function. When we call &lt;code&gt;new&lt;/code&gt; and run this function, we get an instance of the class. The constructor function also contains all of the static members of the class. Another way to think of each class is that there is an &lt;em&gt;instance&lt;/em&gt; side and a &lt;em&gt;static&lt;/em&gt; side.</source>
          <target>ここで、&lt;code&gt;let Greeter&lt;/code&gt;にコンストラクタ関数を割り当てます。 &lt;code&gt;new&lt;/code&gt;を呼び出してこの関数を実行すると、クラスのインスタンスが取得されます。 コンストラクター関数には、クラスのすべての静的メンバーも含まれています。 各クラスを考えるもう1つの方法は、&lt;em&gt;インスタンス&lt;/em&gt;側と&lt;em&gt;静的&lt;/em&gt;側があるということです。</target>
        </trans-unit>
        <trans-unit id="8dc42a1abbc3302381c653975f640c8b543442a7" translate="yes">
          <source>Here, TypeScript will climb up &lt;code&gt;node_modules&lt;/code&gt; folders looking for a &lt;code&gt;@my-team/tsconfig-base&lt;/code&gt; package. For each of those packages, TypeScript will first check whether &lt;code&gt;package.json&lt;/code&gt; contains a &lt;code&gt;"tsconfig"&lt;/code&gt; field, and if it does, TypeScript will try to load a configuration file from that field. If neither exists, TypeScript will try to read from a &lt;code&gt;tsconfig.json&lt;/code&gt; at the root. This is similar to the lookup process for &lt;code&gt;.js&lt;/code&gt; files in packages that Node uses, and the &lt;code&gt;.d.ts&lt;/code&gt; lookup process that TypeScript already uses.</source>
          <target>ここで、TypeScriptは&lt;code&gt;node_modules&lt;/code&gt;フォルダを上昇させ、&lt;code&gt;@myteam/tsconfig base&lt;/code&gt;パッケージを探します。 これらの各パッケージについて、TypeScriptはまず&lt;code&gt;package.json&lt;/code&gt;に&lt;code&gt;"tsconfig"&lt;/code&gt;フィールドが含まれているかどうかをチェックし、含まれている場合、TypeScriptはそのフィールドから設定ファイルをロードしようとする。 どちらも存在しない場合、TypeScriptはルートの&lt;code&gt;tsconfig.json&lt;/code&gt;から読み込もうとする。 これは、Nodeが使用するパッケージの&lt;code&gt;.js&lt;/code&gt;ファイルのルックアッププロセス、およびTypeScriptがすでに使用している&lt;code&gt;.d.ts&lt;/code&gt;ルックアッププロセスに似ています。</target>
        </trans-unit>
        <trans-unit id="3034e1d8a6bc8a9342b8171fa30badb5f8ee1757" translate="yes">
          <source>Here, our package depends on the &lt;code&gt;browserify&lt;/code&gt; and &lt;code&gt;typescript&lt;/code&gt; packages. &lt;code&gt;browserify&lt;/code&gt; does not bundle its declaration files with its npm packages, so we needed to depend on &lt;code&gt;@types/browserify&lt;/code&gt; for its declarations. &lt;code&gt;typescript&lt;/code&gt;, on the other hand, packages its declaration files, so there was no need for any additional dependencies.</source>
          <target>このパッケージは、&lt;code&gt;browserify&lt;/code&gt;および&lt;code&gt;typescript&lt;/code&gt;パッケージに依存しています。 &lt;code&gt;browserify&lt;/code&gt;はその宣言ファイルをnpmパッケージにバンドルしていないので、その宣言は&lt;code&gt;@types/browserify&lt;/code&gt;に依存する必要がありました。 一方、&lt;code&gt;typescript&lt;/code&gt;は宣言ファイルをパッケージ化するため、追加の依存関係は必要ありません。</target>
        </trans-unit>
        <trans-unit id="3cda7ef7ff2200b657be6b6273e0dac1be53b72f" translate="yes">
          <source>Here, the &lt;code&gt;pickCard&lt;/code&gt; function will return two different things based on what the user has passed in. If the users passes in an object that represents the deck, the function will pick the card. If the user picks the card, we tell them which card they&amp;rsquo;ve picked. But how do we describe this to the type system?</source>
          <target>ここで、&lt;code&gt;pickCard&lt;/code&gt;関数は、ユーザが渡したものに基づいて2つの異なるものを返します。 ユーザがデッキを表すオブジェクトを渡すと、関数はカードを選択します。 ユーザがカードを選択すると、選択したカードを通知します。 しかし、これを型システムにどのように記述するか?</target>
        </trans-unit>
        <trans-unit id="e58fec9d06a5ad9c41dd9bdefb16a98bb9094511" translate="yes">
          <source>Here, the Typescript type checker used the type of the &lt;code&gt;Window.onmousedown&lt;/code&gt; function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent"&gt;type&lt;/a&gt; of the &lt;code&gt;mouseEvent&lt;/code&gt; parameter, which does contain a &lt;code&gt;button&lt;/code&gt; property, but not a &lt;code&gt;kangaroo&lt;/code&gt; property.</source>
          <target>ここで、Typescript型チェッカーは、&lt;code&gt;Window.onmousedown&lt;/code&gt;関数の型を使用して、代入の右側の関数式の型を推測しました。 そのとき、&lt;code&gt;mouseEvent&lt;/code&gt;パラメータの&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent"&gt;type&lt;/a&gt;を推測することができました。このパラメータには&lt;code&gt;button&lt;/code&gt;プロパティは含まれていますが、&lt;code&gt;kangaroo&lt;/code&gt;プロパティは含まれていません。</target>
        </trans-unit>
        <trans-unit id="e4d6507505357d507200a72953f1d420dfbcafaf" translate="yes">
          <source>Here, we forgot to call &lt;code&gt;isAdministrator&lt;/code&gt;, and the code incorrectly allows non-adminstrator users to edit the configuration!</source>
          <target>ここでは、&lt;code&gt;isAdministrator&lt;/code&gt;を呼び出すのを忘れていました。このコードでは、管理者以外のユーザーが設定を編集できます。</target>
        </trans-unit>
        <trans-unit id="30996a44efb8790cbea6f775764e2a95c008cc8a" translate="yes">
          <source>Here, we have a function &lt;code&gt;readImage&lt;/code&gt; which reads an image in a non-blocking asynchronous way. In addition to &lt;code&gt;readImage&lt;/code&gt;, we&amp;rsquo;ve provided a convenience function on &lt;code&gt;readImage&lt;/code&gt; itself called &lt;code&gt;readImage.sync&lt;/code&gt;.</source>
          <target>ここでは、ノンブロッキング非同期方式で画像を読み込む関数&lt;code&gt;readImage&lt;/code&gt;があります。 &lt;code&gt;readImage&lt;/code&gt;に加えて、&lt;code&gt;readImage.sync&lt;/code&gt;と呼ばれる&lt;code&gt;readImage&lt;/code&gt;自体に便利な関数を提供しました。</target>
        </trans-unit>
        <trans-unit id="4776f9836ab53c81a717b79d18761f412dcd4953" translate="yes">
          <source>Here, we have two local variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s scope is limited to the body of &lt;code&gt;f&lt;/code&gt; while &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s scope is limited to the containing &lt;code&gt;if&lt;/code&gt; statement&amp;rsquo;s block.</source>
          <target>ここでは、2つのローカル変数&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;があります。&lt;code&gt;a&lt;/code&gt;のスコープは&lt;code&gt;f&lt;/code&gt;の本体に制限され、&lt;code&gt;b&lt;/code&gt;&amp;rsquo;のスコープは&lt;code&gt;if&lt;/code&gt;文&amp;rsquo;のブロックを含む&lt;code&gt;if&lt;/code&gt;文に制限されます。</target>
        </trans-unit>
        <trans-unit id="48b66ea86a98afc6732087affea2266d22665ee9" translate="yes">
          <source>Here, we&amp;rsquo;ll split our &lt;code&gt;Validation&lt;/code&gt; namespace across many files. Even though the files are separate, they can each contribute to the same namespace and can be consumed as if they were all defined in one place. Because there are dependencies between files, we&amp;rsquo;ll add reference tags to tell the compiler about the relationships between the files. Our test code is otherwise unchanged.</source>
          <target>ここでは、&lt;code&gt;Validation&lt;/code&gt;名前空間を多数のファイルに分割します。 ファイルが別々であっても、それぞれが同じ名前空間に割り当てられ、すべてが1つの場所で定義されているかのように使用できます。 ファイル間には依存関係があるため、ファイル間の関係をコンパイラに通知する参照タグを追加します。 それ以外の点では、テスト・コードは変更されません。</target>
        </trans-unit>
        <trans-unit id="0be76e8a894cfa9a5cd3d9c31525aeb3396a52fc" translate="yes">
          <source>Here, when we say &lt;code&gt;let greeter: Greeter&lt;/code&gt;, we&amp;rsquo;re using &lt;code&gt;Greeter&lt;/code&gt; as the type of instances of the class &lt;code&gt;Greeter&lt;/code&gt;. This is almost second nature to programmers from other object-oriented languages.</source>
          <target>ここで&lt;code&gt;let greeter:Greeter&lt;/code&gt;と答えると、&lt;code&gt;Greeter&lt;/code&gt;クラスのインスタンスのタイプとして&lt;code&gt;Greeter&lt;/code&gt;を使用することになります。これは、他のオブジェクト指向言語のプログラマーにとっては、ほぼ2番目の性質です。</target>
        </trans-unit>
        <trans-unit id="af2cc1b97022b7d58d48c283943b530d0c3a629b" translate="yes">
          <source>Heterogeneous enums</source>
          <target>異種列挙</target>
        </trans-unit>
        <trans-unit id="bcaf520cc3089e4cf8ad0800fc58fb622275eea2" translate="yes">
          <source>Higher order type inference from generic constructors</source>
          <target>ジェネリックコンストラクタからの高次型推論</target>
        </trans-unit>
        <trans-unit id="f7dd4ac35eed5e4b0152fe5390ac0fc4fdadf710" translate="yes">
          <source>Higher order type inference from generic functions</source>
          <target>ジェネリック関数からの高次型推論</target>
        </trans-unit>
        <trans-unit id="173efd9dce0319d3f71e1aa5317de963557d2d4c" translate="yes">
          <source>Hit &lt;code&gt;Install&lt;/code&gt;</source>
          <target>[&lt;code&gt;Install&lt;/code&gt;]をクリックします。</target>
        </trans-unit>
        <trans-unit id="89d412a555ac9119a1cb2746b4a8a508c5b127a6" translate="yes">
          <source>How Node.js resolves modules</source>
          <target>Node.jsがモジュールを解決する方法</target>
        </trans-unit>
        <trans-unit id="1a330f9df74d0d83d178ec1580eb2080a18f5765" translate="yes">
          <source>How TypeScript resolves modules</source>
          <target>TypeScriptによるモジュールの解決方法</target>
        </trans-unit>
        <trans-unit id="aea32d84fa10a6814afacd1681bb1e9a0cfcb214" translate="yes">
          <source>However, TypeScript takes the stance that there&amp;rsquo;s probably a bug in this code. Object literals get special treatment and undergo &lt;em&gt;excess property checking&lt;/em&gt; when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the &amp;ldquo;target type&amp;rdquo; doesn&amp;rsquo;t have, you&amp;rsquo;ll get an error:</source>
          <target>しかし、TypeScriptはおそらくこのコードにバグがあるという立場をとっています。 オブジェクトリテラルは特別な扱いを受け、他の変数に代入するとき、または引数として渡すときに&lt;em&gt;余分なプロパティチェック&lt;/em&gt;を受けます。 オブジェクトリテラルに&amp;ldquo;ターゲットタイプ&amp;rdquo;にないプロパティがある場合、&amp;rsquo;はエラーを返します。</target>
        </trans-unit>
        <trans-unit id="2df3cad6545d1673cff30d2239dcbcac86f68714" translate="yes">
          <source>However, TypeScript would instead transform the original code into this code:</source>
          <target>ただし、TypeScriptは元のコードを次のコードに変換します。</target>
        </trans-unit>
        <trans-unit id="d67a8b4fe7f16ad0a4a00091ab517503777587fe" translate="yes">
          <source>However, a better approach might be to add a string index signature if you&amp;rsquo;re sure that the object can have some extra properties that are used in some special way. If &lt;code&gt;SquareConfig&lt;/code&gt; can have &lt;code&gt;color&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; properties with the above types, but could &lt;em&gt;also&lt;/em&gt; have any number of other properties, then we could define it like so:</source>
          <target>ただし、何らかの特別な方法で使用される追加のプロパティをオブジェクトが持つことができることを確認している場合は、文字列インデックスシグネチャを追加する方がよいでしょう。 &lt;code&gt;SquareConfig&lt;/code&gt;が上記の型の&lt;code&gt;color&lt;/code&gt;および&lt;code&gt;width&lt;/code&gt;プロパティを持つことができるが、&lt;em&gt;も&lt;/em&gt;任意の数の他のプロパティを持つことができる場合は、次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="ae34467865c8caaf898bf37d8295d39c36fa465b" translate="yes">
          <source>However, a lot of the time, you might just want to import an existing module that may not have its own &lt;code&gt;.d.ts&lt;/code&gt; file. Previously this was an error. Starting with TypeScript 2.1 this is now much easier.</source>
          <target>ただし、多くの場合は、独自の&lt;code&gt;.d.ts&lt;/code&gt;ファイルを持たない既存のモジュールをインポートするだけです。 これまではエラーでした。 TypeScript2.1から、これはずっと簡単になった。</target>
        </trans-unit>
        <trans-unit id="52fd9d1ab67ec13644f81aac04cb75b6dad506bf" translate="yes">
          <source>However, combining the two naively would allow an error to sneak in. For example, taking our last example using &lt;code&gt;createSquare&lt;/code&gt;:</source>
          <target>しかし、2つの単純な組み合わせでは、エラーが入り込む可能性があります。 たとえば、&lt;code&gt;createSquare&lt;/code&gt;を使用した最後の例を示します。</target>
        </trans-unit>
        <trans-unit id="5fd6902ab8657b5adb4ddbc9ea60a37a54d752ab" translate="yes">
          <source>However, having to define a function to figure out if a type is a primitive is kind of a pain. Luckily, you don&amp;rsquo;t need to abstract &lt;code&gt;typeof x === "number"&lt;/code&gt; into its own function because TypeScript will recognize it as a type guard on its own. That means we could just write these checks inline.</source>
          <target>しかし、型がプリミティブかどうかを判断する関数を定義しなければならないことは、ある種の苦痛です。 幸いなことに、&lt;code&gt;typeof x=="number"&lt;/code&gt;をTypeScriptが独自の型ガードとして認識するので、その関数に抽象化する必要はありません。 つまり、これらのチェックをインラインで書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="cb2ee9a73119ef2301052f4deb325a8b58f2559f" translate="yes">
          <source>However, in the above example, both &lt;code&gt;FruitEater&lt;/code&gt;s and &lt;code&gt;ColorConsumer&lt;/code&gt;s should be able to take the string &lt;code&gt;"orange"&lt;/code&gt;, and return either a &lt;code&gt;number&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;.</source>
          <target>ただし、上記の例では、&lt;code&gt;orange&lt;/code&gt;と&lt;code&gt;orange&lt;/code&gt;の両方が文字列&lt;code&gt;"ColorConsumer"&lt;/code&gt;を受け取り、&lt;code&gt;number&lt;/code&gt;または&lt;code&gt;string&lt;/code&gt;のいずれかを返す必要があります。FruitEater。</target>
        </trans-unit>
        <trans-unit id="6b3269ba44655740fda35e4a6cc5c78cee6e3c08" translate="yes">
          <source>However, in the following example, no error will be reported because the fall-through case is empty:</source>
          <target>ただし、次の例では、フォールスルーの場合が空であるため、エラーは報告されません。</target>
        </trans-unit>
        <trans-unit id="9b7d9dc4338c505863904ace315d827dbbcdc28f" translate="yes">
          <source>However, it&amp;rsquo;s not possible for a type alias to appear anywhere else on the right side of the declaration:</source>
          <target>ただし、タイプエイリアスを宣言の右側の他の場所に表示することはできません。</target>
        </trans-unit>
        <trans-unit id="261cdca866e8fca9691e1b837aea779937f4bb40" translate="yes">
          <source>However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:</source>
          <target>ただし、制約内の型変数を削除し、代わりに条件付き型を指定すると、ほとんど同じ効果が得られます。</target>
        </trans-unit>
        <trans-unit id="e03cd94fc4a5be72b1eb26d1ba79c9cc8372ade3" translate="yes">
          <source>However, properties of different types are acceptable if the index signature is a union of the property types:</source>
          <target>ただし、インデックスシグネチャがプロパティタイプの和集合である場合は、異なるタイプのプロパティを使用できます。</target>
        </trans-unit>
        <trans-unit id="21bd5d4e23e02c99e9395288fd2b3c14719c2452" translate="yes">
          <source>However, resolution for a &lt;a href="#relative-vs-non-relative-module-imports"&gt;non-relative module name&lt;/a&gt; is performed differently. Node will look for your modules in special folders named &lt;code&gt;node_modules&lt;/code&gt;. A &lt;code&gt;node_modules&lt;/code&gt; folder can be on the same level as the current file, or higher up in the directory chain. Node will walk up the directory chain, looking through each &lt;code&gt;node_modules&lt;/code&gt; until it finds the module you tried to load.</source>
          <target>ただし、&lt;a href="#relative vs non relative module imports"&gt;non-relative module name&lt;/a&gt;の解決方法は異なります。 ノードは、&lt;code&gt;node_modules&lt;/code&gt;という名前の特別なフォルダでモジュールを検索します。 &lt;code&gt;node_modules&lt;/code&gt;フォルダは、現在のファイルと同じレベル、またはディレクトリチェーンの上位に置くことができます。 ノードは、ロードしようとしたモジュールが見つかるまで、各&lt;code&gt;node_modules&lt;/code&gt;を検索しながら、ディレクトリチェーンをたどっていきます。</target>
        </trans-unit>
        <trans-unit id="4066c0cf22c6617cd0e99b116883a9d0812e7a0a" translate="yes">
          <source>However, there are two limitations to keep in mind:</source>
          <target>ただし、次の2つの制限に注意してください。</target>
        </trans-unit>
        <trans-unit id="1b475ae409f46bd0059bada064f2253dfa62d98f" translate="yes">
          <source>However, this code will log &lt;code&gt;undefined&lt;/code&gt;, since &lt;code&gt;uiEvent&lt;/code&gt; has no property called &lt;code&gt;button&lt;/code&gt;.</source>
          <target>ただし、&lt;code&gt;uiEvent&lt;/code&gt;には&lt;code&gt;button&lt;/code&gt;というプロパティがないため、このコードは&lt;code&gt;undefined&lt;/code&gt;を記録します。</target>
        </trans-unit>
        <trans-unit id="e528b8c265ab20d7ddf0074a5c552ac0aa502914" translate="yes">
          <source>However, this is error prone - there is nothing stopping a user from accidentally misspelling one of the valid easing values:</source>
          <target>ただし、これはエラーが発生しやすいため、ユーザーが有効なイージング値のいずれかを誤って入力するのを防ぐことはできません。</target>
        </trans-unit>
        <trans-unit id="47f0cbbb6af8b4a1e0b5d52577ef8a8ca00678b1" translate="yes">
          <source>However, this was a bit overly strict for the original example. If you figure out the precise type of any possible value of &lt;code&gt;S&lt;/code&gt;, you can actually see that it matches the types in &lt;code&gt;T&lt;/code&gt; exactly.</source>
          <target>しかし、これは元の例では少し厳しすぎました。 &lt;code&gt;S&lt;/code&gt;の値の正確な型を見つけると、&lt;code&gt;T&lt;/code&gt;の型と正確に一致することがわかります。</target>
        </trans-unit>
        <trans-unit id="a82aa6652361ecc5084c82f581d35a4cecb03722" translate="yes">
          <source>However, when comparing types that have &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; members, we treat these types differently. For two types to be considered compatible, if one of them has a &lt;code&gt;private&lt;/code&gt; member, then the other must have a &lt;code&gt;private&lt;/code&gt; member that originated in the same declaration. The same applies to &lt;code&gt;protected&lt;/code&gt; members.</source>
          <target>しかし、&lt;code&gt;private&lt;/code&gt;メンバと&lt;code&gt;protected&lt;/code&gt;メンバを持つ型を比較する場合、これらの型を異なる方法で扱います。 2つのタイプが互換性があると見なされるには、一方に&lt;code&gt;private&lt;/code&gt;メンバがある場合、もう一方に同じ宣言で生成された&lt;code&gt;private&lt;/code&gt;メンバが必要です。 &lt;code&gt;protected&lt;/code&gt;メンバについても同様です。</target>
        </trans-unit>
        <trans-unit id="e30d71bb57f4f77a84a108277b5b36c06cf3ebc6" translate="yes">
          <source>However, when using the &lt;code&gt;--strictNullChecks&lt;/code&gt; flag, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are only assignable to &lt;code&gt;any&lt;/code&gt; and their respective types (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). This helps avoid &lt;em&gt;many&lt;/em&gt; common errors. In cases where you want to pass in either a &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the union type &lt;code&gt;string | null | undefined&lt;/code&gt;.</source>
          <target>ただし、&lt;code&gt;--strictNullChecks&lt;/code&gt;フラグを使用する場合、&lt;code&gt;null&lt;/code&gt;と&lt;code&gt;undefined&lt;/code&gt;は、&lt;code&gt;任意の&lt;/code&gt;とそれぞれの型にのみ割り当て可能です(例外として、&lt;code&gt;undefined&lt;/code&gt;は&lt;code&gt;void&lt;/code&gt;にも割り当て可能です)。 これにより、&lt;em&gt;多くの&lt;/em&gt;一般的なエラーを回避できます。 &lt;code&gt;string&lt;/code&gt;、&lt;code&gt;null&lt;/code&gt;、または&lt;code&gt;undefined&lt;/code&gt;のいずれかを渡す場合は、ユニオン型&lt;code&gt;string null undefined&lt;/code&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="3a16fbd6d0aeace5fd6859531c3e68218d7a29dc" translate="yes">
          <source>Hybrid Types</source>
          <target>ハイブリッドタイプ</target>
        </trans-unit>
        <trans-unit id="51fed45c4210870abf204ad077a177b04a015861" translate="yes">
          <source>IIFEs as namespace declarations</source>
          <target>名前空間宣言としてのIIFEs</target>
        </trans-unit>
        <trans-unit id="aacc04465943461c4401f154c73b82378a7e907a" translate="yes">
          <source>Ideally, we may want &lt;code&gt;zoo&lt;/code&gt; to be inferred as an &lt;code&gt;Animal[]&lt;/code&gt;, but because there is no object that is strictly of type &lt;code&gt;Animal&lt;/code&gt; in the array, we make no inference about the array element type. To correct this, instead explicitly provide the type when no one type is a super type of all other candidates:</source>
          <target>理想的には、&lt;code&gt;zoo&lt;/code&gt;を&lt;code&gt;Animal[]&lt;/code&gt;として推論することができますが、配列の中に厳密に&lt;code&gt;Animal&lt;/code&gt;型のオブジェクトがないため、配列要素の型については推論しません。 これを修正するには、1つの型が他のすべての候補のスーパー型でない場合に型を明示的に指定します。</target>
        </trans-unit>
        <trans-unit id="3fb44df7e96b3c06b0f62dc3d3bf658dd46e932c" translate="yes">
          <source>Ideally, we&amp;rsquo;d just import the React module from within the browser, but most browsers still don&amp;rsquo;t quite support modules yet. Instead libraries have traditionally made themselves available using a single global variable like &lt;code&gt;jQuery&lt;/code&gt; or &lt;code&gt;_&lt;/code&gt;. This is called the &amp;ldquo;namespace pattern&amp;rdquo;, and webpack allows us to continue leveraging libraries written that way. With our entry for &lt;code&gt;"react": "React"&lt;/code&gt;, webpack will work its magic to make any import of &lt;code&gt;"react"&lt;/code&gt; load from the &lt;code&gt;React&lt;/code&gt; variable.</source>
          <target>理想的には、ブラウザ内からReactモジュールをインポートするだけですが、ほとんどのブラウザはまだモジュールを完全にサポートしていません。 代わりに、ライブラリは従来、&lt;code&gt;jQuery&lt;/code&gt;または&lt;code&gt;_&lt;/code&gt;のような単一のグローバル変数を使用して利用可能になっています。これは&amp;ldquo;namespace pattern&amp;rdquo;と呼ばれ、Webpackを使用すると、そのようにして作成されたライブラリを引き続き利用できます。 &lt;code&gt;"react":"React"&lt;/code&gt;のエントリを使用すると、Webpackは、&lt;code&gt;React&lt;/code&gt;変数から&lt;code&gt;"react"&lt;/code&gt;をインポートするためのマジックを行います。</target>
        </trans-unit>
        <trans-unit id="7e95984082de67338b2c7ddbc538f64e016c8d48" translate="yes">
          <source>Identifying Kinds of Libraries</source>
          <target>ライブラリの種類の識別</target>
        </trans-unit>
        <trans-unit id="e5eb14c632b87d0c6ad5e592a44a1a8fee7f0639" translate="yes">
          <source>Identifying a Global Library from Code</source>
          <target>コードからのグローバルライブラリの識別</target>
        </trans-unit>
        <trans-unit id="a2ba79579e03b8f78ffd87dd47a547b41065fc1e" translate="yes">
          <source>Identifying a Module Library from Code</source>
          <target>コードからのモジュールライブラリの識別</target>
        </trans-unit>
        <trans-unit id="96a39992ddd95916928039e6a01815883f0054ca" translate="yes">
          <source>Identifying a UMD library</source>
          <target>UMDライブラリーの識別</target>
        </trans-unit>
        <trans-unit id="88076b9c11713a1d1df3ba70daf4f6393c85d874" translate="yes">
          <source>Identifying global plugins</source>
          <target>グローバルプラグインの識別</target>
        </trans-unit>
        <trans-unit id="7d0b0dbee7bf8c6735a82b5f8993e432ee3b5ca1" translate="yes">
          <source>Identifying global-modifying modules</source>
          <target>グローバル修正モジュールの識別</target>
        </trans-unit>
        <trans-unit id="75c608e5e061dd97d023874171193ba0dedb0879" translate="yes">
          <source>Identifying the structure of a library is the first step in writing its declaration file. We&amp;rsquo;ll give hints on how to identify structure both based on its &lt;em&gt;usage&lt;/em&gt; and its &lt;em&gt;code&lt;/em&gt;. Depending on the library&amp;rsquo;s documentation and organization, one might be easier than the other. We recommend using whichever is more comfortable to you.</source>
          <target>ライブラリーの構造を識別することは、その宣言ファイルを作成する最初のステップです。 構造を識別する方法について、&lt;em&gt;使用方法&lt;/em&gt;と&lt;em&gt;コード&lt;/em&gt;の両方に基づいてヒントを示します。ライブラリのドキュメントと構成によっては、どちらかの方が簡単な場合があります。 お客様のお好みに合わせてお使いになることをおすすめします。</target>
        </trans-unit>
        <trans-unit id="8bd1ece9a873c798fd3b2f187514a3f9ff53eeee" translate="yes">
          <source>If &amp;lsquo;default&amp;rsquo; and &amp;lsquo;clean&amp;rsquo; tasks don&amp;rsquo;t show up, refresh the explorer:</source>
          <target>&amp;lsquo;default&amp;rsquo;and&amp;lsquo;clean&amp;rsquo;tasks don&amp;rsquo;が表示されない場合は、エクスプローラを更新します。</target>
        </trans-unit>
        <trans-unit id="b398aaa2e3e793e66c0386971a0fcc7d95fd4011" translate="yes">
          <source>If &lt;code&gt;TypeScriptToolsVersion&lt;/code&gt; is not specified, the latest compiler version installed on the machine will be used to build.</source>
          <target>&lt;code&gt;TypeScriptToolsVersion&lt;/code&gt;が指定されていない場合、マシンにインストールされている最新のコンパイラバージョンがビルドに使用されます。</target>
        </trans-unit>
        <trans-unit id="1a66bd888ae761260069cb56ba3782c6cb9f2948" translate="yes">
          <source>If &lt;code&gt;X&lt;/code&gt; contains a numeric index signature, &lt;code&gt;keyof X&lt;/code&gt; is a union of &lt;code&gt;number&lt;/code&gt; and the literal types representing string-like and symbol-like properties, otherwise</source>
          <target>&lt;code&gt;X&lt;/code&gt;に数値インデックスシグネチャが含まれている場合、&lt;code&gt;keyof X&lt;/code&gt;は&lt;code&gt;number&lt;/code&gt;と文字列型およびシンボル型のプロパティを表すリテラル型の結合です。それ以外の場合は</target>
        </trans-unit>
        <trans-unit id="6616ffdf1f61f5f170f5695d095b28464311066e" translate="yes">
          <source>If &lt;code&gt;X&lt;/code&gt; contains a string index signature, &lt;code&gt;keyof X&lt;/code&gt; is a union of &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, and the literal types representing symbol-like properties, otherwise</source>
          <target>&lt;code&gt;X&lt;/code&gt;に文字列インデックスシグネチャが含まれている場合、&lt;code&gt;keyof X&lt;/code&gt;は&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;number&lt;/code&gt;、およびシンボルのようなプロパティを表すリテラル型の和集合です。それ以外の場合は</target>
        </trans-unit>
        <trans-unit id="2f946b4318e41dbe69a87cd5f88e67367fd6d44f" translate="yes">
          <source>If &lt;code&gt;typeRoots&lt;/code&gt; is specified, &lt;em&gt;only&lt;/em&gt; packages under &lt;code&gt;typeRoots&lt;/code&gt; will be included. For example:</source>
          <target>&lt;code&gt;typeRoots&lt;/code&gt;が指定されている場合は、&lt;code&gt;typeRoots&lt;/code&gt;の下の&lt;em&gt;パッケージのみが含まれます。&lt;/em&gt;。 例:</target>
        </trans-unit>
        <trans-unit id="99b6d90008fb9649958f2be05e76b1dd9a5961c1" translate="yes">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, only packages listed will be included. For instance:</source>
          <target>&lt;code&gt;types&lt;/code&gt;が指定されている場合、リストされたパッケージのみが含まれます。 例:</target>
        </trans-unit>
        <trans-unit id="6fbac6cb9d3b7de97e789cbb5b4510b49f088657" translate="yes">
          <source>If a decision ever comes down to &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt;, you should prefer &lt;code&gt;{}&lt;/code&gt;. While they are mostly the same, technically &lt;code&gt;{}&lt;/code&gt; is a more general type than &lt;code&gt;Object&lt;/code&gt; in certain esoteric cases.</source>
          <target>決定が&lt;code&gt;Object&lt;/code&gt;と&lt;code&gt;{}&lt;/code&gt;になる場合は、&lt;code&gt;{}&lt;/code&gt;を選択する必要があります。ほとんどの場合は同じですが、厳密には&lt;code&gt;{}&lt;/code&gt;は&lt;code&gt;Object&lt;/code&gt;よりも一般的な型です。</target>
        </trans-unit>
        <trans-unit id="2ac2b4a6a24acc5fecb490e99fb16cab96cc3bf4" translate="yes">
          <source>If a default type is specified and inference cannot choose a candidate, the default type is inferred.</source>
          <target>デフォルトタイプが指定されていて、候補を選択できない場合、デフォルトタイプが推定されます。</target>
        </trans-unit>
        <trans-unit id="8fbc86845e0d24c360aaf1bfbc58393acef68624" translate="yes">
          <source>If a segment of a glob pattern includes only &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;.*&lt;/code&gt;, then only files with supported extensions are included (e.g. &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and &lt;code&gt;.d.ts&lt;/code&gt; by default with &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; if &lt;code&gt;allowJs&lt;/code&gt; is set to true).</source>
          <target>globパターンのセグメントに&lt;code&gt;*&lt;/code&gt;または&lt;code&gt;.*&lt;/code&gt;のみが含まれている場合、サポートされている拡張子を持つファイルのみが含まれます(たとえば、&lt;code&gt;.js&lt;/code&gt;および&lt;code&gt;.jsx&lt;/code&gt;がデフォルトで&lt;code&gt;.js&lt;/code&gt;および&lt;code&gt;.jsx&lt;/code&gt;(&lt;code&gt;allowJs&lt;/code&gt;がtrueに設定されている場合))。</target>
        </trans-unit>
        <trans-unit id="54daf0bb0e7d1bcc3df23442a6dc487446e709b6" translate="yes">
          <source>If either operand of a &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, or &lt;code&gt;in&lt;/code&gt; operator is nullable.</source>
          <target>&lt;/code&gt;演算子の&lt;code&gt;&amp;lt;&lt;/code&gt;,&lt;code&gt;&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;=&lt;/code&gt;,&lt;code&gt;&amp;gt;=&lt;/code&gt;,または&lt;code&gt;のいずれかのオペランドがNULL可能である場合。</target>
        </trans-unit>
        <trans-unit id="ea5b35d5abd4cbfb9f096e8d991dcb47c08f66f4" translate="yes">
          <source>If either operand of a &lt;code&gt;+&lt;/code&gt; operator is nullable, and neither operand is of type &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt;.</source>
          <target>&lt;code&gt;+&lt;/code&gt;演算子のいずれかのオペランドがNULL入力可能で、どちらのオペランドも&lt;code&gt;any&lt;/code&gt;または&lt;code&gt;string&lt;/code&gt;型ではない場合。</target>
        </trans-unit>
        <trans-unit id="d883272b1b0531d98de565e92423069ee2248d62" translate="yes">
          <source>If either operand of a &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, or &lt;code&gt;^&lt;/code&gt; operator is nullable.</source>
          <target>&lt;code&gt;-&lt;/code&gt;、&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;**&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt;、&lt;code&gt;%&lt;/code&gt;、&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;、&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;amp;&lt;/code&gt;、&lt;code&gt;&lt;/code&gt;、または&lt;code&gt;^&lt;/code&gt;演算子のいずれかのオペランドがNULL可能な場合。</target>
        </trans-unit>
        <trans-unit id="b999341c4d2107c29465088a4be729def05702d7" translate="yes">
          <source>If environment variable &lt;code&gt;TSC_NONPOLLING_WATCHER&lt;/code&gt; is set to true, watches parent directory of files (just like &lt;code&gt;UseFsEventsOnParentDirectory&lt;/code&gt;). Otherwise watch files using &lt;code&gt;fs.watchFile&lt;/code&gt; with &lt;code&gt;250ms&lt;/code&gt; as the timeout for any file</source>
          <target>環境変数&lt;code&gt;TSC_NONPOLLING_WATCHER&lt;/code&gt;がtrueに設定されている場合、はファイルの親ディレクトリを監視します(&lt;code&gt;UseFsEventsOnParentDirectory&lt;/code&gt;と同様)。 それ以外の場合は、&lt;code&gt;fs.watchFile&lt;/code&gt;を使用し、&lt;code&gt;250ms&lt;/code&gt;を任意のファイルのタイムアウトとしてファイルを監視します。</target>
        </trans-unit>
        <trans-unit id="d23e16bdfbddee4b25eaec4b1d684282e726836a" translate="yes">
          <source>If properties are never set in the class body, they are considered unknown. If your class has properties that are only read from, add and then annotate a declaration in the constructor with JSDoc to specify the type. You don&amp;rsquo;t even have to give a value if it will be initialised later:</source>
          <target>プロパティがクラス本体に設定されていない場合は、不明と見なされます。 クラスに読み取り専用のプロパティーがある場合は、JSDocを使用してコンストラクターの宣言を追加し、その宣言にアノテーションを付けて型を指定します。 後で初期化する場合は、値を指定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="cf548e316f27cc773ad61fba2e4a76543f3bb1ce" translate="yes">
          <source>If that didn&amp;rsquo;t work and if the module name is non-relative (and in the case of &lt;code&gt;"moduleA"&lt;/code&gt;, it is), then the compiler will attempt to locate an &lt;a href="modules#ambient-modules"&gt;ambient module declaration&lt;/a&gt;. We&amp;rsquo;ll cover non-relative imports next.</source>
          <target>モジュール名が相対的でない場合(&lt;code&gt;"moduleA"&lt;/code&gt;の場合)、コンパイラは&lt;a href="modules#ambient modules"&gt;ambient module宣言&lt;/a&gt;を見つけようとします。 次に、相対的でないインポートを対象にします。</target>
        </trans-unit>
        <trans-unit id="5fc6ba7853747447fab7e2b09e476e794d7eaf75" translate="yes">
          <source>If that sounds too lax for you, you can tighten that behavior up. If, for instance, you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want TypeScript to compile to JavaScript in the face of errors, you can use the &lt;code&gt;noEmitOnError&lt;/code&gt; option. In that sense, TypeScript has a dial on its strictness, and you can turn that knob up as high as you want.</source>
          <target>あまりにも気が緩すぎるようであれば、その動作を強化することができます。 たとえば、エラーが発生してもTypeScriptをJavaScriptにコンパイルしない場合は、&lt;code&gt;noEmitOnError&lt;/code&gt;オプションを使用できます。 その意味では、TypeScriptはその厳格さにダイヤルがあり、そのノブを好きなだけ高く上げることができる。</target>
        </trans-unit>
        <trans-unit id="80562a30b2229fad8a6df690b031de0355afd589" translate="yes">
          <source>If that&amp;rsquo;s the case, the files that you&amp;rsquo;ve written are going to be used as inputs to TypeScript, and you&amp;rsquo;ll run the outputs it produces. During our JS to TS migration, we&amp;rsquo;ll need to separate our input files to prevent TypeScript from overwriting them. If your output files need to reside in a specific directory, then that will be your output directory.</source>
          <target>その場合、作成したファイルはTypeScriptへの入力として使用され、作成した出力を実行します。 JSからTSへのマイグレーション中に、TypeScriptが上書きしないように、入力ファイルを分離する必要があります。 出力ファイルを特定のディレクトリに置く必要がある場合は、そのディレクトリが出力ディレクトリになります。</target>
        </trans-unit>
        <trans-unit id="2fcbcd9f558fa8a3faacb1b7e2f2cc6f3c7dd80a" translate="yes">
          <source>If the &lt;code&gt;"files"&lt;/code&gt; and &lt;code&gt;"include"&lt;/code&gt; are both left unspecified, the compiler defaults to including all TypeScript (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt;) files in the containing directory and subdirectories except those excluded using the &lt;code&gt;"exclude"&lt;/code&gt; property. JS files (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt;) are also included if &lt;code&gt;allowJs&lt;/code&gt; is set to true.</source>
          <target>&lt;code&gt;"files"&lt;/code&gt;と&lt;code&gt;include"&lt;/code&gt;が両方とも指定されていない場合、コンパイラはデフォルトで、&lt;code&gt;"exclude"&lt;/code&gt;プロパティを使用して除外されたものを除き、すべてのTypeScript(&lt;code&gt;.ts&lt;/code&gt;、&lt;code&gt;.d.ts&lt;/code&gt;、および&lt;code&gt;.tsx&lt;/code&gt;)ファイルを含むディレクトリとサブディレクトリに含めます。 &lt;code&gt;allowJs&lt;/code&gt;がtrueに設定されている場合、JSファイル(&lt;code&gt;.js&lt;/code&gt;および&lt;code&gt;.jsx&lt;/code&gt;)も含まれます。</target>
        </trans-unit>
        <trans-unit id="477c8cbe4706878c16fb156bd723ab8f217099e9" translate="yes">
          <source>If the &lt;code&gt;"files"&lt;/code&gt; and &lt;code&gt;"include"&lt;/code&gt; are both left unspecified, the compiler defaults to including all TypeScript (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt;) files in the containing directory and subdirectories except those excluded using the &lt;code&gt;"exclude"&lt;/code&gt; property. JS files (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt;) are also included if &lt;code&gt;allowJs&lt;/code&gt; is set to true. If the &lt;code&gt;"files"&lt;/code&gt; or &lt;code&gt;"include"&lt;/code&gt; properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the &lt;code&gt;"outDir"&lt;/code&gt; compiler option are excluded as long as &lt;code&gt;"exclude"&lt;/code&gt; property is not specified.</source>
          <target>&lt;code&gt;"files"&lt;/code&gt;と&lt;code&gt;include"&lt;/code&gt;が両方とも指定されていない場合、コンパイラはデフォルトで、&lt;code&gt;"exclude"&lt;/code&gt;プロパティを使用して除外されたものを除き、すべてのTypeScript(&lt;code&gt;.ts&lt;/code&gt;、&lt;code&gt;.d.ts&lt;/code&gt;、および&lt;code&gt;.tsx&lt;/code&gt;)ファイルを含むディレクトリとサブディレクトリに含めます。 &lt;code&gt;allowJs&lt;/code&gt;がtrueに設定されている場合、JSファイル(&lt;code&gt;.js&lt;/code&gt;および&lt;code&gt;.jsx&lt;/code&gt;)も含まれます。&lt;code&gt;"files"&lt;/code&gt;または&lt;code&gt;include"&lt;/code&gt;プロパティが指定されている場合、コンパイラは、これら2つのプロパティに含まれるファイルの結合を含みます。 &lt;code&gt;"exclude"&lt;/code&gt;プロパティが指定されていない限り、&lt;code&gt;"outDir"&lt;/code&gt;コンパイラオプションを使用して指定されたディレクトリ内のファイルは除外されます。</target>
        </trans-unit>
        <trans-unit id="d6b124b086b760cf9eb1864e544665757f5217f3" translate="yes">
          <source>If the &lt;code&gt;"files"&lt;/code&gt; or &lt;code&gt;"include"&lt;/code&gt; properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the &lt;code&gt;"outDir"&lt;/code&gt; compiler option are always excluded unless explicitly included via the &lt;code&gt;"files"&lt;/code&gt; property (even when the &amp;ldquo;&lt;code&gt;exclude&lt;/code&gt;&amp;rdquo; property is specified).</source>
          <target>&lt;code&gt;"files"&lt;/code&gt;または&lt;code&gt;"include"&lt;/code&gt;プロパティが指定された場合、コンパイラは、これら2つのプロパティに含まれるファイルの和集合を組み込みます。 &lt;code&gt;"outDir"&lt;/code&gt;コンパイラオプションを使用して指定されたディレクトリ内のファイルは、&lt;code&gt;"files"&lt;/code&gt;プロパティによって明示的にインクルードされない限り(&amp;ldquo;&lt;code&gt;exclude&lt;/code&gt;&amp;rdquo;プロパティが指定されている場合でも)、常に除外されます。</target>
        </trans-unit>
        <trans-unit id="9fce1a983a1219926f1f38bab0bfb60ec3fd4b5c" translate="yes">
          <source>If the accessor decorator returns a value, it will be used as the &lt;em&gt;Property Descriptor&lt;/em&gt; for the member.</source>
          <target>アクセサー修飾子が値を返す場合、そのメンバーの&lt;em&gt;プロパティ記述子&lt;/em&gt;として使用されます。</target>
        </trans-unit>
        <trans-unit id="757bf2cd851a721420b759b576fc525ad4b2e255" translate="yes">
          <source>If the class decorator returns a value, it will replace the class declaration with the provided constructor function.</source>
          <target>クラス・デコレータが値を返す場合、クラス宣言を提供されたコンストラクタ関数で置き換えます。</target>
        </trans-unit>
        <trans-unit id="dcdc136ee9d606ac3aebb0a12ffa90330d056cbb" translate="yes">
          <source>If the compiler flag &lt;code&gt;--noResolve&lt;/code&gt; is specified, triple-slash references are ignored; they neither result in adding new files, nor change the order of the files provided.</source>
          <target>コンパイラフラグ&lt;code&gt;--noResolve&lt;/code&gt;が指定されている場合、3つのスラッシュ参照は無視されます。3つのスラッシュ参照は、新しいファイルを追加したり、提供されたファイルの順序を変更したりすることはありません。</target>
        </trans-unit>
        <trans-unit id="64760e36eb2b3cf9f6dce25e269af13108cbb2ff" translate="yes">
          <source>If the method decorator returns a value, it will be used as the &lt;em&gt;Property Descriptor&lt;/em&gt; for the method.</source>
          <target>メソッド・デコレータが値を返す場合、メソッドの&lt;em&gt;プロパティ記述子&lt;/em&gt;として使用されます。</target>
        </trans-unit>
        <trans-unit id="c5f107d97fba869cf2daf87a931e54a8895ed1bc" translate="yes">
          <source>If the operand of a &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, or &lt;code&gt;--&lt;/code&gt; unary operator is nullable.</source>
          <target>&lt;code&gt;+&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;、&lt;code&gt;~&lt;/code&gt;、&lt;code&gt;+&lt;/code&gt;、または&lt;code&gt;--&lt;/code&gt;単項演算子のオペランドにNULLを使用できる場合。</target>
        </trans-unit>
        <trans-unit id="a35de86d636b3f4498ca4f03ae3386c7c6c3cc94" translate="yes">
          <source>If the referenced project produces an &lt;code&gt;outFile&lt;/code&gt;, the output file &lt;code&gt;.d.ts&lt;/code&gt; file&amp;rsquo;s declarations will be visible in this project</source>
          <target>参照先のプロジェクトが&lt;code&gt;outFile&lt;/code&gt;を生成する場合、出力ファイル&lt;code&gt;.d.ts&lt;/code&gt;ファイルの宣言がこのプロジェクトに表示されます。</target>
        </trans-unit>
        <trans-unit id="dd06f92d40ce76202d5611a64daad24f2a1feac2" translate="yes">
          <source>If the right operand of an &lt;code&gt;instanceof&lt;/code&gt; operator is nullable.</source>
          <target>&lt;code&gt;instanceof&lt;/code&gt;演算子の右オペランドがNULL可能である場合。</target>
        </trans-unit>
        <trans-unit id="bb788c0916122fd9a75b33b92aa45518eb1b4e5a" translate="yes">
          <source>If this function were not in a contextually typed position, the function&amp;rsquo;s argument would implicitly have type &lt;code&gt;any&lt;/code&gt;, and no error would be issued (unless you are using the &lt;code&gt;--noImplicitAny&lt;/code&gt; option):</source>
          <target>この関数が文脈上型付けされた位置にない場合、関数の引数は暗黙的に&lt;code&gt;any&lt;/code&gt;型を持ち、エラーは発行されません(&lt;code&gt;--noImplicitAny&lt;/code&gt;オプションを使用している場合を除く)。</target>
        </trans-unit>
        <trans-unit id="d3ba6383ac88848a0ef4f846d3fe4de2bef1cab6" translate="yes">
          <source>If we have a value that has a union type, we can only access members that are common to all types in the union.</source>
          <target>値に共用体タイプがある場合、共用体のすべてのタイプに共通のメンバーのみにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="a1d377830062aff369f8dab5df851e9080561624" translate="yes">
          <source>If we want to customize how a decorator is applied to a declaration, we can write a decorator factory. A &lt;em&gt;Decorator Factory&lt;/em&gt; is simply a function that returns the expression that will be called by the decorator at runtime.</source>
          <target>デコレータを宣言に適用する方法をカスタマイズしたい場合は、デコレータ・ファクトリーを作成します。 &lt;em&gt;Decorator Factory&lt;/em&gt;は、実行時にデコレータによって呼び出される式を返す関数です。</target>
        </trans-unit>
        <trans-unit id="d0a73f363bdb39ad6e23dfd5f55548093ac466d2" translate="yes">
          <source>If we wanted, we could leave off the initializers entirely:</source>
          <target>必要であれば、初期化子を完全に省くことができます。</target>
        </trans-unit>
        <trans-unit id="83df15e4cf413e10be414506c047c7618a0d3d89" translate="yes">
          <source>If we were to use &lt;a href="#decorator-factories"&gt;decorator factories&lt;/a&gt;, we can observe this evaluation order with the following example:</source>
          <target>&lt;a href="#decorator factories"&gt;decorator factories&lt;/a&gt;を使用する場合は、次の例でこの評価順序を確認できます。</target>
        </trans-unit>
        <trans-unit id="89a7882773e333f0676bc25954729647144846fe" translate="yes">
          <source>If you add a &lt;code&gt;tsconfig.json&lt;/code&gt; file, TypeScript files that are not considered part of that context are not compiled.</source>
          <target>&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルを追加すると、そのコンテキストの一部と見なされないTypeScriptファイルはコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="4c6633882fd2cbc849cc78df7098cdbc11e0f7c9" translate="yes">
          <source>If you are using a different build tool to build your project (e.g. gulp, grunt , etc.) and VS for the development and debugging experience, set &lt;code&gt;&amp;lt;TypeScriptCompileBlocked&amp;gt;true&amp;lt;/TypeScriptCompileBlocked&amp;gt;&lt;/code&gt; in your project. This should give you all the editing support, but not the build when you hit F5.</source>
          <target>別のビルドツールを使用してプロジェクトをビルドしている場合(例:gump、gruntなど)、開発とデバッグのためにVSを使用している場合は、プロジェクトに&lt;code&gt;&amp;lt;TypeScriptCompileBlocked&amp;gt;true&amp;lt;/TypeScriptCompileBlocked&amp;gt;&lt;/code&gt;を設定します。 これで編集のサポートはすべて得られますが、F5を押したときのビルドはできません。</target>
        </trans-unit>
        <trans-unit id="5cd9012eef954c07679b23981cd46180ffa74948" translate="yes">
          <source>If you check in any build outputs (&lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt;, &lt;code&gt;.d.ts.map&lt;/code&gt;, etc.), you may need to run a &lt;code&gt;--force&lt;/code&gt; build after certain source control operations depending on whether your source control tool preserves timestamps between the local copy and the remote copy.</source>
          <target>ビルド出力(&lt;code&gt;.js&lt;/code&gt;,&lt;code&gt;.d.ts&lt;/code&gt;,&lt;code&gt;.d.ts.map&lt;/code&gt;など)をチェックインする場合は、ソース制御ツールがローカルコピーとリモートコピーの間のタイムスタンプを保持するかどうかによって、特定のソース制御操作の後に&lt;code&gt;--force&lt;/code&gt;ビルドを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="6a349b11b7d0ef239663304628dfd9c61e8381c6" translate="yes">
          <source>If you don&amp;rsquo;t want to take the time to write out declarations before using a new module, you can now just use a shorthand declaration to get started quickly.</source>
          <target>新しいモジュールを使用する前に宣言を書き出す時間がない場合は、簡単な宣言を使用してすばやく開始できます。</target>
        </trans-unit>
        <trans-unit id="fae05d77b88c64d5e95a8ef1a5541f4907ad6f4f" translate="yes">
          <source>If you don&amp;rsquo;t want to take the time to write out declarations before using a new module, you can use a shorthand declaration to get started quickly.</source>
          <target>新しいモジュールを使用する前に宣言を書き出す時間がない場合は、簡単な宣言を使用してすばやく開始できます。</target>
        </trans-unit>
        <trans-unit id="b6d64531eb1511551180721cfd80f278a3113a79" translate="yes">
          <source>If you ever have a value that TypeScript thinks is possibly &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt;, but you know better, you can use the postfix &lt;code&gt;!&lt;/code&gt; operator to tell it otherwise.</source>
          <target>TypeScriptが&lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt;の可能性があると判断した値があるが、それよりもよくわかっている場合は、&lt;code&gt;!&lt;/code&gt;演算子を使用して、そうでないことを示すことができます。</target>
        </trans-unit>
        <trans-unit id="3c329b002b75ec8975f18054725c2bf4040952e7" translate="yes">
          <source>If you had the following Node/CommonJS code:</source>
          <target>次のNode/CommonJSコードがある場合:</target>
        </trans-unit>
        <trans-unit id="dc04d34dfcaac9afb16dfcca2506c06bccfa00d4" translate="yes">
          <source>If you have a &lt;code&gt;tests&lt;/code&gt; folder outside of your &lt;code&gt;src&lt;/code&gt; directory, you might have one &lt;code&gt;tsconfig.json&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt;, and one in &lt;code&gt;tests&lt;/code&gt; as well.</source>
          <target>&lt;code&gt;src&lt;/code&gt;ディレクトリ以外に&lt;code&gt;tests&lt;/code&gt;フォルダがある場合は、&lt;code&gt;src&lt;/code&gt;ディレクトリに&lt;code&gt;tsconfig.json&lt;/code&gt;が1つあり、&lt;code&gt;tests&lt;/code&gt;ディレクトリにも&lt;code&gt;tsconfig.json&lt;/code&gt;が1つある可能性があります。</target>
        </trans-unit>
        <trans-unit id="1c080c78e7a69573dae8c2024c9d66a13c40bf94" translate="yes">
          <source>If you have a type with a number index signature, &lt;code&gt;keyof T&lt;/code&gt; will just be &lt;code&gt;number&lt;/code&gt;.</source>
          <target>数値インデックスシグネチャを持つ型がある場合、&lt;code&gt;keyof T&lt;/code&gt;は&lt;code&gt;number&lt;/code&gt;だけになります。</target>
        </trans-unit>
        <trans-unit id="bad1becd57096ef1e33ba9bd0ebbac35bc9622bd" translate="yes">
          <source>If you have an msbuild project, you can enable build mode by adding</source>
          <target>msbuildプロジェクトがある場合は、次を追加してビルドモードを有効にできます。</target>
        </trans-unit>
        <trans-unit id="88dba7da91434766a3c79f38e44d7fef30aa351c" translate="yes">
          <source>If you intended to test the function without calling it, you can correct the definition of it to include &lt;code&gt;undefined&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt;, or use &lt;code&gt;!!&lt;/code&gt; to write something like &lt;code&gt;if (!!user.isAdministrator)&lt;/code&gt; to indicate that the coercion is intentional.</source>
          <target>関数を呼び出さずにテストする場合は、関数の定義を修正して&lt;code&gt;undefined&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt;を含めるか、&lt;code&gt;!&lt;/code&gt;を使用して強制が意図的であることを示す&lt;code&gt;if(!user.isAdministrator)&lt;/code&gt;のようなものを記述します。</target>
        </trans-unit>
        <trans-unit id="ed97452c7f7269f74ea84e8195f99486afcc62bd" translate="yes">
          <source>If you plan on using the stricter settings that are available, it&amp;rsquo;s best to turn them on now (see &lt;a href="#getting-stricter-checks"&gt;Getting Stricter Checks&lt;/a&gt; below). For instance, if you never want TypeScript to silently infer &lt;code&gt;any&lt;/code&gt; for a type without you explicitly saying so, you can use &lt;code&gt;noImplicitAny&lt;/code&gt; before you start modifying your files. While it might feel somewhat overwhelming, the long-term gains become apparent much more quickly.</source>
          <target>使用可能なより厳密な設定を使用する場合は、今すぐオンにすることをお勧めします(後述の&lt;a href="#getting stricted checks"&gt;Getting Stricted Checks&lt;/a&gt;を参照)。 たとえば、TypeScriptで型の&lt;code&gt;any&lt;/code&gt;を暗黙的に推測しないようにするには、ファイルの修正を始める前に&lt;code&gt;noImplicitAny&lt;/code&gt;を使用します。 やや圧倒的に感じるかもしれないが、長期的な利益ははるかに早く明らかになる。</target>
        </trans-unit>
        <trans-unit id="d704dd727aa16026d03295d60e4fd6bd0f450b47" translate="yes">
          <source>If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have. In our &lt;code&gt;loggingIdentity&lt;/code&gt; example, we wanted to be able to access the &lt;code&gt;.length&lt;/code&gt; property of &lt;code&gt;arg&lt;/code&gt;, but the compiler could not prove that every type had a &lt;code&gt;.length&lt;/code&gt; property, so it warns us that we can&amp;rsquo;t make this assumption.</source>
          <target>前の例を思い出した場合、型の集合が持つ機能についてある程度の知識がある場合には、型の集合に対して動作する汎用関数を作成する必要があるかもしれません。 &lt;code&gt;loggingIdentity&lt;/code&gt;の例では、&lt;code&gt;arg&lt;/code&gt;の&lt;code&gt;.length&lt;/code&gt;プロパティにアクセスできるようにしたかったのですが、コンパイラはすべての型に&lt;code&gt;.length&lt;/code&gt;プロパティがあることを証明できなかったため、この前提を適用できないことを警告しています。</target>
        </trans-unit>
        <trans-unit id="f2f60b10d440544ea9c56ee6406205dc250ac35c" translate="yes">
          <source>If you see tests for &lt;code&gt;typeof define&lt;/code&gt;, &lt;code&gt;typeof window&lt;/code&gt;, or &lt;code&gt;typeof module&lt;/code&gt; in the code of a library, especially at the top of the file, it&amp;rsquo;s almost always a UMD library.</source>
          <target>ライブラリのコード、特にファイルの先頭に&lt;code&gt;typeof define&lt;/code&gt;、&lt;code&gt;typeof window&lt;/code&gt;、または&lt;code&gt;typeof module&lt;/code&gt;のテストがある場合は、ほとんどの場合UMDライブラリです。</target>
        </trans-unit>
        <trans-unit id="c25089b3bb720ad8bf4d7033bc03403e6d851984" translate="yes">
          <source>If you started converting over to TypeScript imports, you&amp;rsquo;ll probably run into errors like &lt;code&gt;Cannot find module 'foo'.&lt;/code&gt;. The issue here is that you likely don&amp;rsquo;t have &lt;em&gt;declaration files&lt;/em&gt; to describe your library. Luckily this is pretty easy. If TypeScript complains about a package like &lt;code&gt;lodash&lt;/code&gt;, you can just write</source>
          <target>TypeScriptインポートへの変換を開始した場合、おそらく&lt;code&gt;Cannot find module'foo'.&lt;/code&gt;のようなエラーが発生します。ここでの問題は、ライブラリを記述する&lt;em&gt;宣言ファイル&lt;/em&gt;がない可能性が高いことです。 幸い、これはとても簡単です。 TypeScriptが&lt;code&gt;lodash&lt;/code&gt;のようなパッケージについて文句を言うなら、次のように書けばよい。</target>
        </trans-unit>
        <trans-unit id="b4fea75c265155bd6df0203787b647e915b7efa9" translate="yes">
          <source>If you use &lt;code&gt;y&lt;/code&gt; in a way that the type parameter&amp;rsquo;s constraint doesn&amp;rsquo;t support, you&amp;rsquo;ll correctly get an error. In this case, the constraint of &lt;code&gt;T&lt;/code&gt; was (implicitly) &lt;code&gt;{}&lt;/code&gt;, so the last example will appropriately fail.</source>
          <target>タイプパラメータの制約がサポートしていない方法で&lt;code&gt;y&lt;/code&gt;を使用すると、正しくエラーになります。 この場合、&lt;code&gt;T&lt;/code&gt;の制約は(暗黙的に)&lt;code&gt;{}&lt;/code&gt;であるため、最後の例は適切に失敗します。</target>
        </trans-unit>
        <trans-unit id="a6641ad041757e24a4e32a46b8524d850586ab79" translate="yes">
          <source>If you&amp;acirc;&amp;euro;&amp;trade;d prefer to be explicit, you can also enforce the type of values that can be returned, yielded, and evaluated from &lt;code&gt;yield&lt;/code&gt; expressions using an explicit return type. Below, &lt;code&gt;next()&lt;/code&gt; can only be called with &lt;code&gt;boolean&lt;/code&gt;s, and depending on the value of &lt;code&gt;done&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is either a &lt;code&gt;string&lt;/code&gt; or a &lt;code&gt;number&lt;/code&gt;.</source>
          <target>&amp;acirc;&amp;euro;&amp;trade;dが明示的であることを望む場合は、明示的な戻り型を使用して、&lt;code&gt;yield&lt;/code&gt;式から返され、産出され、評価される値の型を強制することもできます。 以下では、&lt;code&gt;next()&lt;/code&gt;は&lt;code&gt;boolean&lt;/code&gt;でのみ呼び出すことができ、&lt;code&gt;done&lt;/code&gt;の値に応じて、&lt;code&gt;value&lt;/code&gt;は&lt;code&gt;string&lt;/code&gt;か&lt;code&gt;number&lt;/code&gt;のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="25c9ec1976e4df8a2ef8c0b469042e5f520617b9" translate="yes">
          <source>If you&amp;rsquo;re converting a program from namespaces to modules, it can be easy to end up with a file that looks like this:</source>
          <target>プログラムを名前空間からモジュールに変換すると、次のようなファイルが作成されます。</target>
        </trans-unit>
        <trans-unit id="513d665d33a30074384ac54ddb0be0edac2c6bbf" translate="yes">
          <source>If you&amp;rsquo;re exporting multiple objects, put them all at top-level</source>
          <target>複数のオブジェクトを書き出す場合は、すべてのオブジェクトを最上位に配置</target>
        </trans-unit>
        <trans-unit id="e6a9291b44ab09ee343d0c813d7995f1938982dd" translate="yes">
          <source>If you&amp;rsquo;re looking to convert a React project, we recommend looking at the &lt;a href="https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide"&gt;React Conversion Guide&lt;/a&gt; first.</source>
          <target>Reactプロジェクトを変換する場合は、まず&lt;a href="https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide"&gt;React Conversion Guide&lt;/a&gt;を参照することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6b3d86758d6ba06b2c6d545d9e0ad1ace8a4b070" translate="yes">
          <source>If you&amp;rsquo;re only exporting a single &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;function&lt;/code&gt;, use &lt;code&gt;export default&lt;/code&gt;</source>
          <target>単一の&lt;code&gt;クラス&lt;/code&gt;または&lt;code&gt;関数&lt;/code&gt;のみをエクスポートする場合は、&lt;code&gt;export default&lt;/code&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="2f70d23b3b33808540611f0c15d2283c4e323059" translate="yes">
          <source>If you&amp;rsquo;re reading this guide, you probably already roughly know what a type in TypeScript is. To be more explicit, though, a &lt;em&gt;type&lt;/em&gt; is introduced with:</source>
          <target>このガイドを読んでいるなら、TypeScriptの型が何であるかをだいたい知っているでしょう。 より明確にするために、&lt;em&gt;type&lt;/em&gt;は次のように導入されています。</target>
        </trans-unit>
        <trans-unit id="b934c40448796bd9edae2d68f2dcee6ad19754ce" translate="yes">
          <source>If you&amp;rsquo;re starting a brand new project, take a look at the &lt;a href="https://create-react-app.dev/docs/adding-typescript"&gt;React Quick Start guide&lt;/a&gt; first.</source>
          <target>まったく新しいプロジェクトを開始する場合は、まず&lt;a href="https://create-react-app.dev/docs/adding-typescript"&gt;React Quick Startガイド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="cff1c0146ace654a504313182db4a173a9b3388c" translate="yes">
          <source>If you&amp;rsquo;re using Gulp in some fashion, we have a tutorial on &lt;a href="gulp"&gt;using Gulp&lt;/a&gt; with TypeScript, and integrating with common build tools like Browserify, Babelify, and Uglify. You can read more there.</source>
          <target>Gulpを何らかの方法で使用している場合は、&lt;a href="gulp"&gt;Gulp&lt;/a&gt;をTypeScriptで使用し、Browserify、Babelify、Uglifyなどの一般的なビルドツールと統合する方法についてのチュートリアルがあります。 詳細はこちら。</target>
        </trans-unit>
        <trans-unit id="cafdaaff5d59cc2c2f1205e3709213e65336f377" translate="yes">
          <source>If you&amp;rsquo;re using a module option other than &lt;code&gt;commonjs&lt;/code&gt;, you&amp;rsquo;ll need to set your &lt;code&gt;moduleResolution&lt;/code&gt; option to &lt;code&gt;node&lt;/code&gt;.</source>
          <target>&lt;code&gt;commonjs&lt;/code&gt;以外のモジュールオプションを使用している場合は、&lt;code&gt;moduleResolution&lt;/code&gt;オプションを&lt;code&gt;node&lt;/code&gt;に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="0aafe02ccb06b6d197194a0b7f3d99641d791f0b" translate="yes">
          <source>If you&amp;rsquo;re writing in plain JavaScript, it&amp;rsquo;s likely that you&amp;rsquo;re running your JavaScript directly, where your &lt;code&gt;.js&lt;/code&gt; files are in a &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;lib&lt;/code&gt;, or &lt;code&gt;dist&lt;/code&gt; directory, and then ran as desired.</source>
          <target>プレーンなJavaScriptで記述している場合は、&lt;code&gt;.js&lt;/code&gt;ファイルが&lt;code&gt;src&lt;/code&gt;、&lt;code&gt;lib&lt;/code&gt;、または&lt;code&gt;dist&lt;/code&gt;ディレクトリにあり、必要に応じて実行されているJavaScriptを直接実行している可能性があります。</target>
        </trans-unit>
        <trans-unit id="fdfba1223ac1da9db70e78da0daf0187962aac1a" translate="yes">
          <source>If you&amp;rsquo;ve read about &lt;code&gt;typeof&lt;/code&gt; type guards and are familiar with the &lt;code&gt;instanceof&lt;/code&gt; operator in JavaScript, you probably have some idea of what this section is about.</source>
          <target>&lt;code&gt;typeof&lt;/code&gt;型ガードについて読み、JavaScriptの&lt;code&gt;instanceof&lt;/code&gt;演算子に精通している場合は、このセクションの内容についてある程度理解していると思います。</target>
        </trans-unit>
        <trans-unit id="ba89c0b592333fdedc6dea3af514c7a63cd66e0b" translate="yes">
          <source>If you&amp;rsquo;ve used JavaScript offhandedly, the next section might be a good way to refresh your memory. If you&amp;rsquo;re intimately familiar with all the quirks of &lt;code&gt;var&lt;/code&gt; declarations in JavaScript, you might find it easier to skip ahead.</source>
          <target>JavaScriptを勝手に使用したことがある場合は、次のセクションを使用してメモリーをリフレッシュするとよいでしょう。 JavaScriptの&lt;code&gt;var&lt;/code&gt;宣言のすべての癖を熟知している場合は、先に進むのが簡単です。</target>
        </trans-unit>
        <trans-unit id="7f637065274f76d0b1f9c68b24c257b06ecca8b9" translate="yes">
          <source>If your functions are only able to handle string named property keys, use &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; in the declaration:</source>
          <target>関数がプロパティキーという名前の文字列のみを処理できる場合は、宣言で&lt;code&gt;Extract&amp;lt;keyof T,string&amp;gt;&lt;/code&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="d510aeb4b1e7484eea0e856138d74440b24ca0d1" translate="yes">
          <source>If your functions are open to handling all property keys, then the changes should be done down-stream:</source>
          <target>関数がすべてのプロパティキーを処理できるようになっている場合は、変更を下流で行う必要があります。</target>
        </trans-unit>
        <trans-unit id="f902e411cb6ca33234031133f35364e8839ccd53" translate="yes">
          <source>If your global library depends on a UMD module, use a &lt;code&gt;/// &amp;lt;reference types&lt;/code&gt; directive:</source>
          <target>グローバルライブラリがUMDモジュールに依存している場合は、&lt;code&gt;///&amp;lt;reference types&lt;/code&gt;ディレクティブを使用します。</target>
        </trans-unit>
        <trans-unit id="f7345e0903abc9ae4ad2adfd269b38c296742fa6" translate="yes">
          <source>If your library depends on a global library, use a &lt;code&gt;/// &amp;lt;reference types="..." /&amp;gt;&lt;/code&gt; directive:</source>
          <target>ライブラリがグローバルライブラリに依存している場合は、&lt;code&gt;///&amp;lt;reference types="."/&amp;gt;&lt;/code&gt;ディレクティブを使用します。</target>
        </trans-unit>
        <trans-unit id="b2e55a3a3ef94d5068ad16150d23ae196cc87947" translate="yes">
          <source>If your library depends on a module, use an &lt;code&gt;import&lt;/code&gt; statement:</source>
          <target>ライブラリがモジュールに依存している場合は、&lt;code&gt;import&lt;/code&gt;ステートメントを使用します。</target>
        </trans-unit>
        <trans-unit id="39f14e77085a3e6f94f80d3a5737a97256584f64" translate="yes">
          <source>If your module is not callable or constructable, use the &lt;a href="templates/module-d-ts"&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt; file.</source>
          <target>モジュールが呼び出し可能または構成可能でない場合は、&lt;a href="templates/module d ts"&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt;ファイルを使用します。</target>
        </trans-unit>
        <trans-unit id="708b87e0f5ca75919f8732aead8eedddc9c8eae8" translate="yes">
          <source>If your module or UMD library depends on a UMD library, use an &lt;code&gt;import&lt;/code&gt; statement:</source>
          <target>モジュールまたはUMDライブラリがUMDライブラリに依存している場合は、&lt;code&gt;import&lt;/code&gt;ステートメントを使用します。</target>
        </trans-unit>
        <trans-unit id="b502ac0f72d569709af646c5ae02325abd8bb700" translate="yes">
          <source>If your package has a main &lt;code&gt;.js&lt;/code&gt; file, you will need to indicate the main declaration file in your &lt;code&gt;package.json&lt;/code&gt; file as well. Set the &lt;code&gt;types&lt;/code&gt; property to point to your bundled declaration file. For example:</source>
          <target>パッケージにmain&lt;code&gt;.js&lt;/code&gt;ファイルがある場合は、&lt;code&gt;package.json&lt;/code&gt;ファイルにもmain宣言ファイルを指定する必要があります。 &lt;code&gt;types&lt;/code&gt;プロパティを、バンドルされた宣言ファイルを指すように設定します。 例:</target>
        </trans-unit>
        <trans-unit id="8809cc04677d076884fe6edcda034b008be7ba2b" translate="yes">
          <source>If your package is not written in TypeScript then the second is the preferred approach.</source>
          <target>パッケージがTypeScriptで書かれていない場合は、2番目の方法をお勧めします。</target>
        </trans-unit>
        <trans-unit id="3a45948f03090d8097a2e93bad2b6d30f82543a2" translate="yes">
          <source>If your package is written in TypeScript then the first approach is favored. Use the &lt;code&gt;--declaration&lt;/code&gt; flag to generate declaration files. This way, your declarations and JavaScript will always be in sync.</source>
          <target>パッケージがTypeScriptで書かれている場合は、最初の方法が適しています。 &lt;code&gt;--declaration&lt;/code&gt;フラグを使用して、宣言ファイルを生成します。 これにより、宣言とJavaScriptは常に同期します。</target>
        </trans-unit>
        <trans-unit id="490e3c77ca2e4322ada004a6ddfd9a7799557dcc" translate="yes">
          <source>If your type definitions depend on another package:</source>
          <target>タイプ定義が別のパッケージに依存している場合:</target>
        </trans-unit>
        <trans-unit id="f5dd23741ab01d47a9d58ca45645a4ccefbbd8f1" translate="yes">
          <source>Implementing an interface</source>
          <target>インタフェースの実装</target>
        </trans-unit>
        <trans-unit id="0aba642bf4d637216b8d72e2f4ad7c9560d9798e" translate="yes">
          <source>Implicit any errors</source>
          <target>すべてのエラーを暗黙にする</target>
        </trans-unit>
        <trans-unit id="7d52fc0e48ad6e0d6c8f5245ccb19f1dd538a022" translate="yes">
          <source>Implicit index signatures</source>
          <target>暗黙的なインデックスシグネチャ</target>
        </trans-unit>
        <trans-unit id="c8c4c307ff84c0f8c706629a70179c01013c51e4" translate="yes">
          <source>Implicit returns</source>
          <target>暗黙のリターン</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes">
          <source>Import</source>
          <target>インポート</target>
        </trans-unit>
        <trans-unit id="ac42b7771deabcf8b9b301382d1ce7966a14ab50" translate="yes">
          <source>Import a module for side-effects only</source>
          <target>副次作用のみのモジュールのインポート</target>
        </trans-unit>
        <trans-unit id="c5b568ec8548086b4de521e5d8033aec1c934aac" translate="yes">
          <source>Import a single export from a module</source>
          <target>モジュールからの単一エクスポートのインポート</target>
        </trans-unit>
        <trans-unit id="7830f060b13276e33e83c28a73aa77da5e486098" translate="yes">
          <source>Import declarations, as well, can optionally use &lt;code&gt;as&lt;/code&gt; clauses to specify different local names for the imports. For example:</source>
          <target>インポート宣言でも、オプションで&lt;code&gt;as&lt;/code&gt;句を使用して、インポートに異なるローカル名を指定できます。 例:</target>
        </trans-unit>
        <trans-unit id="9914e368d228c16ed67283b9e88ab7f396d147f6" translate="yes">
          <source>Import emit helpers (e.g. &lt;code&gt;__extends&lt;/code&gt;, &lt;code&gt;__rest&lt;/code&gt;, etc..) from &lt;a href="https://www.npmjs.com/package/tslib"&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt;</source>
          <target>&lt;a href="https://www.npmjs.com/package/tslib"&gt;&lt;code&gt;ツリブ&lt;/code&gt;&lt;/a&gt;からエミットヘルパー(&lt;code&gt;__extends&lt;/code&gt;、&lt;code&gt;_rest&lt;/code&gt;など)をインポートする</target>
        </trans-unit>
        <trans-unit id="d44d2976c5175c70409be4c97c0352850c0e7940" translate="yes">
          <source>Import the entire module into a single variable, and use it to access the module exports</source>
          <target>モジュール全体を1つの変数にインポートし、それを使用してモジュールのエクスポートにアクセスします。</target>
        </trans-unit>
        <trans-unit id="f908ff98948cecb3646ddcfb8cfb7d6851889ec0" translate="yes">
          <source>Import types</source>
          <target>インポートの種類</target>
        </trans-unit>
        <trans-unit id="a60647122c766cfb16cfd3672d6ea4130dbed5fe" translate="yes">
          <source>Importing from Modules</source>
          <target>モジュールからのインポート</target>
        </trans-unit>
        <trans-unit id="f3c938e48f51fc9b9d8d6906d41005ba5ef033c7" translate="yes">
          <source>Importing is just about as easy as exporting from a module. Importing an exported declaration is done through using one of the &lt;code&gt;import&lt;/code&gt; forms below:</source>
          <target>インポートは、モジュールからエクスポートするのと同じくらい簡単です。 エクスポートされた宣言をインポートするには、次の&lt;code&gt;import&lt;/code&gt;フォームのいずれかを使用します。</target>
        </trans-unit>
        <trans-unit id="9f780bafb7678e0e4bc2ed60d39928e72d6363d4" translate="yes">
          <source>Importing modules from a referenced project will instead load its &lt;em&gt;output&lt;/em&gt; declaration file (&lt;code&gt;.d.ts&lt;/code&gt;)</source>
          <target>参照先プロジェクトからモジュールをインポートすると、&lt;em&gt;出力&lt;/em&gt;宣言ファイル(&lt;code&gt;.d.ts&lt;/code&gt;)がロードされます。</target>
        </trans-unit>
        <trans-unit id="1493dcf2543fd7025bb0dc28504a88da052081ce" translate="yes">
          <source>Importing none-code resources using module loaders extension (e.g. &lt;a href="https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html"&gt;AMD&lt;/a&gt; or &lt;a href="https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.html"&gt;SystemJS&lt;/a&gt;) has not been easy before; previously an ambient module declaration had to be defined for each resource.</source>
          <target>モジュール・ローダー拡張機能(たとえば、&lt;a href="https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html"&gt;AMD&lt;/a&gt;または&lt;a href="https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.html"&gt;SystemJS&lt;/a&gt;)を使用してコード・リソースをインポートすることは以前は容易ではありませんでした。以前は、各リソースに対してアンビエント・モジュール宣言を定義する必要がありました。</target>
        </trans-unit>
        <trans-unit id="352d94d7b6ad5d2d2dd80449838c2cf319556903" translate="yes">
          <source>Improved &lt;code&gt;any&lt;/code&gt; Inference</source>
          <target>&lt;code&gt;any&lt;/code&gt;推論の改善</target>
        </trans-unit>
        <trans-unit id="400b56a2fe294d586033d28165229215531d4f5f" translate="yes">
          <source>Improved &lt;code&gt;keyof&lt;/code&gt; with intersection types</source>
          <target>交差点タイプでの&lt;code&gt;keyof&lt;/code&gt;の改善</target>
        </trans-unit>
        <trans-unit id="5db53c8c85f119e50fb4fddb0515ec92c8d14cae" translate="yes">
          <source>Improved UX Around Promises</source>
          <target>PromisesのUX改善</target>
        </trans-unit>
        <trans-unit id="39095ed614c976a48a5edd3ac9559249a5bcafb9" translate="yes">
          <source>Improved behavior for calling union types</source>
          <target>ユニオン型の呼び出し動作の改善</target>
        </trans-unit>
        <trans-unit id="3aed2d7ad51f292dd55e2c452dc2f9d916f9f348" translate="yes">
          <source>Improved checking for &lt;code&gt;for..in&lt;/code&gt; statements</source>
          <target>&lt;/code&gt;ステートメントの&lt;code&gt;のチェックが改善されました。</target>
        </trans-unit>
        <trans-unit id="c02cdcb0697c02f23de76b9402b3ffb5de18ea5a" translate="yes">
          <source>Improved checking for destructuring object literal</source>
          <target>オブジェクトリテラルの分解チェックの改善</target>
        </trans-unit>
        <trans-unit id="55bbe6a04eaea70e8654bdf75776576f97a9d374" translate="yes">
          <source>Improved control over mapped type modifiers</source>
          <target>マップされたタイプのモディファイヤに対するコントロールの改善</target>
        </trans-unit>
        <trans-unit id="be88c1fb8d146d0b9d876f22a0754323c60b7258" translate="yes">
          <source>Improved excess property checks in union types</source>
          <target>ユニオン型の超過プロパティチェックの改善</target>
        </trans-unit>
        <trans-unit id="f0d6c8d205edfb92cb01f19342a7ad56a1cfd004" translate="yes">
          <source>Improved handling of structurally identical classes and &lt;code&gt;instanceof&lt;/code&gt; expressions</source>
          <target>構造的に同一のクラスおよび&lt;code&gt;instanceof&lt;/code&gt;式の処理の改善</target>
        </trans-unit>
        <trans-unit id="79046527e77a08d10c738b0d3678766e68083dfb" translate="yes">
          <source>Improved inference for generics</source>
          <target>ジェネリックに対する推論の改善</target>
        </trans-unit>
        <trans-unit id="9902b64afde9c77bb740ee885857e65ab81753ae" translate="yes">
          <source>Improved support for &lt;code&gt;tsconfig.json&lt;/code&gt; in Visual Studio 2015</source>
          <target>Visual Studio2015での&lt;code&gt;tsconfig.json&lt;/code&gt;のサポートの改善</target>
        </trans-unit>
        <trans-unit id="cc966416a9eb70b531ccdaadbbaafa22d9349454" translate="yes">
          <source>Improved type inference for object literals</source>
          <target>オブジェクトリテラルの型推論の改善</target>
        </trans-unit>
        <trans-unit id="b87ca7b1554d820cbb558e72b3dc2dd9bb2048e0" translate="yes">
          <source>Improved union/intersection type inference</source>
          <target>ユニオン/交差点タイプの推定の改善</target>
        </trans-unit>
        <trans-unit id="73d903d34db6a7a7623b02e31683adc136bd1806" translate="yes">
          <source>Improvements for &lt;code&gt;ReadonlyArray&lt;/code&gt; and &lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target>&lt;code&gt;ReadonlyArray&lt;/code&gt;および&lt;code&gt;readonly&lt;/code&gt;タプルの改善</target>
        </trans-unit>
        <trans-unit id="75cc15f25fc2ae5d077c25f2e3c6ed80c124c408" translate="yes">
          <source>In &lt;a href="templates"&gt;Templates&lt;/a&gt; you&amp;rsquo;ll find a number of declaration files that serve as a useful starting point when writing a new file. Refer to the documentation in &lt;a href="library-structures"&gt;Library Structures&lt;/a&gt; to figure out which template file to use.</source>
          <target>[&lt;a href="templates"&gt;テンプレート&lt;/a&gt;]には、新しいファイルを作成するときの開始点として役立つ宣言ファイルがいくつかあります。 使用するテンプレートファイルについては、「&lt;a href="library structures"&gt;ライブラリ構造&lt;/a&gt;」のマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="053ea35eb45b9803ab97bdc192cb5d0db843884b" translate="yes">
          <source>In &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, a &lt;code&gt;?&lt;/code&gt; modifier automatically includes &lt;code&gt;undefined&lt;/code&gt; in the element type, similar to optional parameters.</source>
          <target>&lt;code&gt;--strictNullChecks&lt;/code&gt;モードでは、&lt;code&gt;?&lt;/code&gt;修飾子は、オプションのパラメータと同様に、自動的に&lt;code&gt;undefined&lt;/code&gt;を要素型に含めます。</target>
        </trans-unit>
        <trans-unit id="c75d3751acc8527d062926da04731cafe2436c23" translate="yes">
          <source>In &lt;code&gt;getProperty&lt;/code&gt;, &lt;code&gt;o: T&lt;/code&gt; and &lt;code&gt;propertyName: K&lt;/code&gt;, so that means &lt;code&gt;o[propertyName]: T[K]&lt;/code&gt;. Once you return the &lt;code&gt;T[K]&lt;/code&gt; result, the compiler will instantiate the actual type of the key, so the return type of &lt;code&gt;getProperty&lt;/code&gt; will vary according to which property you request.</source>
          <target>&lt;code&gt;getProperty&lt;/code&gt;,&lt;code&gt;o:T&lt;/code&gt;および&lt;code&gt;propertyName:K&lt;/code&gt;では、&lt;code&gt;o[propertyName]:T[K]&lt;/code&gt;を意味します。&lt;code&gt;T[K]&lt;/code&gt;の結果を返すと、コンパイラはキーの実際の型をインスタンス化するので、&lt;code&gt;getProperty&lt;/code&gt;の戻り値の型は、要求するプロパティによって異なります。</target>
        </trans-unit>
        <trans-unit id="cac8a395d23bb271c0a5b1d7324f422027c11b0c" translate="yes">
          <source>In ES2015, constructors which return an object implicitly substitute the value of &lt;code&gt;this&lt;/code&gt; for any callers of &lt;code&gt;super()&lt;/code&gt;. As a result, it is necessary to capture any potential return value of &lt;code&gt;super()&lt;/code&gt; and replace it with &lt;code&gt;this&lt;/code&gt;. This change enables working with &lt;a href="https://w3c.github.io/webcomponents/spec/custom/#htmlelement-constructor"&gt;Custom Elements&lt;/a&gt;, which takes advantage of this to initialize browser-allocated elements with user-written constructors.</source>
          <target>ES2015では、オブジェクトを返すコンストラクタが暗黙的に&lt;code&gt;this&lt;/code&gt;の値を&lt;code&gt;super()&lt;/code&gt;の呼び出し元に置き換えます。そのため、&lt;code&gt;super()&lt;/code&gt;の戻り値を取得して&lt;code&gt;this&lt;/code&gt;に置き換える必要があります。この変更により、&lt;a href="https://w3c.github.io/webcomponents/spec/custom/#htmlelement-constructor"&gt;Custom Elements&lt;/a&gt;を使用して、ブラウザに割り当てられた要素をユーザが作成したコンストラクタで初期化できます。</target>
        </trans-unit>
        <trans-unit id="367fc6bebb59a7cbd1d7db58cf0d02857ed175b8" translate="yes">
          <source>In ES6 module loaders, the top-level object (here imported as &lt;code&gt;exp&lt;/code&gt;) can only have properties; the top-level module object is &lt;em&gt;never&lt;/em&gt; callable. The most common solution here is to define a &lt;code&gt;default&lt;/code&gt; export for a callable/constructable object; some module loader shims will automatically detect this situation and replace the top-level object with the &lt;code&gt;default&lt;/code&gt; export.</source>
          <target>ES6モジュールローダーでは、最上位のオブジェクト(ここでは&lt;code&gt;exp&lt;/code&gt;としてインポートされています)はプロパティのみを持つことができます。最上位のモジュールオブジェクトは&lt;em&gt;呼び出し可能ではありません&lt;/em&gt;。 ここでの最も一般的なソリューションは、呼び出し可能/構築可能なオブジェクトの&lt;code&gt;default&lt;/code&gt;エクスポートを定義することです。一部のモジュールローダーshimは、この状況を自動的に検出し、最上位のオブジェクトを&lt;code&gt;default&lt;/code&gt;エクスポートで置き換えます。</target>
        </trans-unit>
        <trans-unit id="f9178ac7270dcc05dceadc49b3f02c9dc7dcbddb" translate="yes">
          <source>In Edge, press F12 and click the Debugger tab.</source>
          <target>EdgeでF12キーを押し、Debuggerタブをクリックします。</target>
        </trans-unit>
        <trans-unit id="54dc2fcbcb0f1f6b32f8968730c12d2717aff252" translate="yes">
          <source>In JSDoc references</source>
          <target>JSDocリファレンスに</target>
        </trans-unit>
        <trans-unit id="6fdb267749a0a65e58ebbcd5a8e1c2849232fca7" translate="yes">
          <source>In JavaScript it is fairly common to have APIs that expect property names as parameters, but so far it hasn&amp;rsquo;t been possible to express the type relationships that occur in those APIs.</source>
          <target>JavaScriptでは、プロパティ名をパラメータとして期待するAPIがあることはかなり一般的ですが、今のところ、これらのAPIで発生する型の関係を表現することはできません。</target>
        </trans-unit>
        <trans-unit id="9d68eb64db15f82423559857fcf4d5a5356cdcf0" translate="yes">
          <source>In JavaScript, &lt;code&gt;this&lt;/code&gt; is a variable that&amp;rsquo;s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This is notoriously confusing, especially when returning a function or passing a function as an argument.</source>
          <target>JavaScriptでは、&lt;code&gt;この&lt;/code&gt;は関数が呼び出されたときに設定される変数です。 これは非常に強力で柔軟な機能ですが、関数が実行されているコンテキストを常に知る必要があります。 これは、特に関数を返す場合や関数を引数として渡す場合には、非常に混乱します。</target>
        </trans-unit>
        <trans-unit id="484bfab743be72776c5e3700ec9d551efe4c463b" translate="yes">
          <source>In JavaScript, &lt;code&gt;var&lt;/code&gt; declarations are &amp;ldquo;hoisted&amp;rdquo; to the top of their enclosing scope. This can result in confusing bugs:</source>
          <target>JavaScriptでは、&lt;code&gt;var&lt;/code&gt;宣言は&amp;ldquo;ホイスト&amp;rdquo;を囲んでいるスコープの一番上に上げます。 これにより、次のような不具合が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="a721d5f467ada10610bec48c19e76c798ba0faad" translate="yes">
          <source>In JavaScript, every parameter is optional, and users may leave them off as they see fit. When they do, their value is &lt;code&gt;undefined&lt;/code&gt;. We can get this functionality in TypeScript by adding a &lt;code&gt;?&lt;/code&gt; to the end of parameters we want to be optional. For example, let&amp;rsquo;s say we want the last name parameter from above to be optional:</source>
          <target>JavaScriptでは、すべてのパラメーターはオプションであり、ユーザーが適切と判断した場合にはオフにしておくことができます。 その場合、その値は&lt;code&gt;undefined&lt;/code&gt;になります。この機能をTypeScriptで使用するには、パラメータの末尾に&lt;code&gt;?&lt;/code&gt;を追加してオプションにします。たとえば、上の姓のパラメータをオプションにします。</target>
        </trans-unit>
        <trans-unit id="cd949f14dcd3d1c680cfa42bdf9a32c9f564e9cb" translate="yes">
          <source>In Node.js, most tasks are accomplished by loading one or more modules. We could define each module in its own &lt;code&gt;.d.ts&lt;/code&gt; file with top-level export declarations, but it&amp;rsquo;s more convenient to write them as one larger &lt;code&gt;.d.ts&lt;/code&gt; file. To do so, we use a construct similar to ambient namespaces, but we use the &lt;code&gt;module&lt;/code&gt; keyword and the quoted name of the module which will be available to a later import. For example:</source>
          <target>Node.jsでは、ほとんどのタスクは1つ以上のモジュールをロードすることで実行されます。 各モジュールは、トップレベルのエクスポート宣言を持つ独自の&lt;code&gt;.d.ts&lt;/code&gt;ファイルに定義できますが、1つの大きな&lt;code&gt;.d.ts&lt;/code&gt;ファイルとして記述する方が便利です。 そのためには、アンビエント名前空間に似た構造体を使用しますが、&lt;code&gt;module&lt;/code&gt;キーワードと、後でインポートで使用できるモジュールの引用符付きの名前を使用します。 例:</target>
        </trans-unit>
        <trans-unit id="9a8e105ae7200ecea675173edd80960ba967b794" translate="yes">
          <source>In TypeScript 1.4, we added support for template strings for all targets, and tagged templates for just ES6. Thanks to some considerable work done by &lt;a href="https://github.com/ivogabe"&gt;@ivogabe&lt;/a&gt;, we bridged the gap for for tagged templates in ES3 and ES5.</source>
          <target>TypeScript1.4では、すべてのターゲットのテンプレート文字列のサポートと、ES6のみのタグ付きテンプレートのサポートを追加しました。 &lt;a href="https://github.com/ivogabe"&gt;@イボガベ&lt;/a&gt;によって行われたいくつかの重要な作業のおかげで、ES3とES5のタグ付きテンプレートのギャップを埋めました。</target>
        </trans-unit>
        <trans-unit id="c136c2bbed32677bb7335ad748e3d5ef230b3921" translate="yes">
          <source>In TypeScript 1.8 with the latest version of react.d.ts (see above), we&amp;rsquo;ve also greatly simplified the declaration of &lt;code&gt;props&lt;/code&gt; types.</source>
          <target>最新バージョンのreact.d.ts(上記を参照)を含むTypeScript1.8では、&lt;code&gt;props&lt;/code&gt;型の宣言も大幅に簡略化されました。</target>
        </trans-unit>
        <trans-unit id="51239dcf9cd000d42b9c40712065d5e3ac4e06b5" translate="yes">
          <source>In TypeScript 2.0, it has become significantly easier to consume declaration files, in acquiring, using, and finding them. This page details exactly how to do all three.</source>
          <target>TypeScript2.0では、宣言ファイルの取得、使用、検索が非常に簡単になりました。 このページでは、3つの方法について詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="280fed62c426cb333df0ac98e6eabc689470726c" translate="yes">
          <source>In TypeScript 2.3, TS introduced type checking of &lt;em&gt;children&lt;/em&gt;. &lt;em&gt;children&lt;/em&gt; is a special property in an &lt;em&gt;element attributes type&lt;/em&gt; where child &lt;em&gt;JSXExpression&lt;/em&gt;s are taken to be inserted into the attributes. Similar to how TS uses &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; to determine the name of &lt;em&gt;props&lt;/em&gt;, TS uses &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; to determine the name of &lt;em&gt;children&lt;/em&gt; within those props. &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; should be declared with a single property.</source>
          <target>TypeScript2.3では、TSは&lt;em&gt;子&lt;/em&gt;の型チェックを導入しました。 &lt;em&gt;children&lt;/em&gt;は、&lt;em&gt;要素属性タイプ&lt;/em&gt;の特殊なプロパティです。ここで、子&lt;em&gt;JSXExpression&lt;/em&gt;は属性に挿入されます。 TSが&lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt;を使用して&lt;em&gt;props&lt;/em&gt;の名前を判別する方法と同様に、TSは&lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt;を使用して&lt;em&gt;children&lt;/em&gt;の名前を判別します。 &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt;は、単一のプロパティで宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="21bf9c2a83b6910226d6caf86b85a5fe927e4d3f" translate="yes">
          <source>In TypeScript 2.4, it&amp;rsquo;s now an error to assign anything to a weak type when there&amp;rsquo;s no overlap in properties. For example:</source>
          <target>TypeScript2.4では、プロパティに重複がない場合に弱い型に何かを割り当てると&amp;rsquo;がエラーになります。 例:</target>
        </trans-unit>
        <trans-unit id="0d04812c896e54873be22b5061fb98c356d962e4" translate="yes">
          <source>In TypeScript 2.4, the function on the right side implicitly &lt;em&gt;gains&lt;/em&gt; type parameters, and &lt;code&gt;y&lt;/code&gt; is inferred to have the type of that type-parameter.</source>
          <target>TypeScript2.4では、右側の関数は暗黙的に&lt;em&gt;型パラメータを取得し、&lt;code&gt;y&lt;/code&gt;はその型パラメータの型を持つと推論される。</target>
        </trans-unit>
        <trans-unit id="fcec71f6bd5ce7d77407d547d676e3be6ddf7295" translate="yes">
          <source>In TypeScript 2.6 and earlier, &lt;code&gt;[number, string, string]&lt;/code&gt; was considered a subtype of &lt;code&gt;[number, string]&lt;/code&gt;. This was motivated by TypeScript&amp;rsquo;s structural nature; the first and second elements of a &lt;code&gt;[number, string, string]&lt;/code&gt; are respectively subtypes of the first and second elements of &lt;code&gt;[number, string]&lt;/code&gt;. However, after examining real world usage of tuples, we noticed that most situations in which this was permitted was typically undesirable.</source>
          <target>TypeScript2.6以前では、&lt;code&gt;[number,string,string]&lt;/code&gt;は&lt;code&gt;[number,string]&lt;/code&gt;のサブタイプと見なされていました。これは、TypeScriptの構造的な性質に基づいています。&lt;code&gt;[number,string,string]&lt;/code&gt;の最初の要素と2番目の要素は、それぞれ&lt;code&gt;[number,string]&lt;/code&gt;の最初の要素と2番目の要素のサブタイプです。しかし、タプルの実際の使用を調べた結果、ほとんどの場合、これが許される状況は望ましくないことがわかりました。</target>
        </trans-unit>
        <trans-unit id="649188580014293e883a71ef51c9fad716c1836d" translate="yes">
          <source>In TypeScript 2.7, tuples of different arities are no longer assignable to each other. Thanks to a pull request from &lt;a href="https://github.com/tycho01"&gt;Tycho Grouwstra&lt;/a&gt;, tuple types now encode their arity into the type of their respective &lt;code&gt;length&lt;/code&gt; property. This is accomplished by leveraging numeric literal types, which now allow tuples to be distinct from tuples of different arities.</source>
          <target>TypeScript2.7では、異なるパリティのタプルはもはや互いに割り当てできない。 &lt;a href="https://github.com/tycho01"&gt;Tycho Grouwstra&lt;/a&gt;からのプルリクエストのおかげで、タプル型はそれぞれの&lt;code&gt;length&lt;/code&gt;プロパティの型にそのアリティをエンコードする。 これは、数値リテラル型を利用することによって実現されます。数値リテラル型では、異なるパリティのタプルとは異なるタプルを使用できます。</target>
        </trans-unit>
        <trans-unit id="e924e834ba371b237a2fd89703ad1fd92c349cc6" translate="yes">
          <source>In TypeScript 3.1, mapped object types&lt;sup&gt;&lt;a href="#ts-3-1-only-homomorphic"&gt;[1]&lt;/a&gt;&lt;/sup&gt; over tuples and arrays now produce new tuples/arrays, rather than creating a new type where members like &lt;code&gt;push()&lt;/code&gt;, &lt;code&gt;pop()&lt;/code&gt;, and &lt;code&gt;length&lt;/code&gt; are converted. For example:</source>
          <target>TypeScript3.1では、&lt;code&gt;push()&lt;/code&gt;、&lt;code&gt;pop()&lt;/code&gt;、および&lt;code&gt;length&lt;/code&gt;のようなメンバが変換される新しい型を作成するのではなく、タプルと配列の上のマップされたオブジェクト型&lt;sup&gt;&lt;a href="#ts-3-1-only homomorphic"&gt;[1]&lt;/a&gt;&lt;/sup&gt;が新しいタプル/配列を生成するようになりました。 例:</target>
        </trans-unit>
        <trans-unit id="39f9c3f02fd56ead96678ac1ba450ac3cd68bf5e" translate="yes">
          <source>In TypeScript 3.2, object literals now allow generic spread expressions which now produce intersection types, similar to the &lt;code&gt;Object.assign&lt;/code&gt; function and JSX literals. For example:</source>
          <target>TypeScript3.2では、オブジェクトリテラルは、&lt;code&gt;Object.assign&lt;/code&gt;関数やJSXリテラルと同様に、交差型を生成する一般的な拡散式を可能にする。 例:</target>
        </trans-unit>
        <trans-unit id="2b164e3a6dff9d3898d7cd8f7babad021ca8339a" translate="yes">
          <source>In TypeScript 3.3, &lt;code&gt;--build&lt;/code&gt; mode&amp;rsquo;s &lt;code&gt;--watch&lt;/code&gt; flag &lt;em&gt;does&lt;/em&gt; leverage incremental file watching as well. That can mean signficantly faster builds under &lt;code&gt;--build --watch&lt;/code&gt;. In our testing, this functionality has resulted in &lt;strong&gt;a reduction of 50% to 75% in build times&lt;/strong&gt; of the original &lt;code&gt;--build --watch&lt;/code&gt; times. &lt;a href="https://github.com/Microsoft/TypeScript/pull/29161"&gt;You can read more on the original pull request for the change&lt;/a&gt; to see specific numbers, but we believe most composite project users will see significant wins here.</source>
          <target>TypeScript3.3では、&lt;code&gt;--build&lt;/code&gt;モード&amp;rsquo;s&lt;code&gt;--watch&lt;/code&gt;フラグ&lt;em&gt;&lt;/em&gt;もインクリメンタルなファイル監視を利用している。 これは、&lt;code&gt;--build--watch&lt;/code&gt;の下でのビルドが大幅に高速になることを意味します。このテストでは、この機能によって、元の&lt;code&gt;--build&lt;/code&gt;のビルド時間が&lt;strong&gt;50%から75%に短縮されました。 &lt;a href="https://github.com/Microsoft/TypeScript/pull/29161"&gt;変更のプルリクエストの詳細については、&lt;/a&gt;を参照してください。具体的な数値が表示されますが、ほとんどの複合プロジェクトユーザーは、ここで大きな成功を収めることができると思います。</target>
        </trans-unit>
        <trans-unit id="0ff72425a74a94e8f866efe98b24a9a23e691d20" translate="yes">
          <source>In TypeScript 3.3, the parameters of these signatures are &lt;em&gt;intersected&lt;/em&gt; together to create a new signature.</source>
          <target>TypeScript3.3では、これらのシグネチャのパラメータは、新しいシグネチャを作成するために&lt;em&gt;交差&lt;/em&gt;される。</target>
        </trans-unit>
        <trans-unit id="a91f7b680f1b740f03303f6aa85f432e9ad8efa8" translate="yes">
          <source>In TypeScript 3.3, this is no longer an error.</source>
          <target>TypeScript3.3では、これはもはやエラーではない。</target>
        </trans-unit>
        <trans-unit id="5341077b6a3de5130003da3230dc62974ee76806" translate="yes">
          <source>In TypeScript 3.4 and earlier, certain excess properties were allowed in situations where they really shouldn&amp;rsquo;t have been. For instance, TypeScript 3.4 permitted the incorrect &lt;code&gt;name&lt;/code&gt; property in the object literal even though its types don&amp;rsquo;t match between &lt;code&gt;Point&lt;/code&gt; and &lt;code&gt;Label&lt;/code&gt;.</source>
          <target>TypeScript3.4以前では、ある種の余分なプロパティは、それらが本当にあるべきでない状況で許されていました。 たとえば、TypeScript3.4では、&lt;code&gt;Point&lt;/code&gt;と&lt;code&gt;Label&lt;/code&gt;の型が一致しない場合でも、オブジェクトリテラル内に不正な&lt;code&gt;name&lt;/code&gt;プロパティを許可していました。</target>
        </trans-unit>
        <trans-unit id="eb163ddc0e2f8f1dc49a15fee6ec555fb1d31fba" translate="yes">
          <source>In TypeScript 3.4 and prior, the following example would fail:</source>
          <target>TypeScript3.4以前では、次の例は失敗します。</target>
        </trans-unit>
        <trans-unit id="09356337029d3d047ed37351c9cbc0dd0318ec54" translate="yes">
          <source>In TypeScript 3.4, the &lt;code&gt;readonly&lt;/code&gt; modifier in a mapped type will automatically convert array-like types to their corresponding &lt;code&gt;readonly&lt;/code&gt; counterparts.</source>
          <target>TypeScript3.4では、マップされた型の&lt;code&gt;readonly&lt;/code&gt;修飾子は、配列型を対応する&lt;code&gt;readonly&lt;/code&gt;に自動的に変換します。</target>
        </trans-unit>
        <trans-unit id="e962c6d8bea6e7e5e00083a65a632b1e6809958d" translate="yes">
          <source>In TypeScript 3.4, we improved inference for when generic functions that return functions like so:</source>
          <target>TypeScript3.4では、以下のような関数を返す汎用関数の推論を改善しました。</target>
        </trans-unit>
        <trans-unit id="8398d8557226d4dcf61ef0d2d8e32afa0789a488" translate="yes">
          <source>In TypeScript 3.5, the type-checker at least verifies that all the provided properties belong to &lt;em&gt;some&lt;/em&gt; union member and have the appropriate type, meaning that the sample above correctly issues an error.</source>
          <target>TypeScript3.5では、型チェッカーは少なくとも、提供されたすべてのプロパティが&lt;em&gt;一部&lt;/em&gt;の和集合メンバに属し、適切な型を持つことを検証します。つまり、上記のサンプルではエラーが正しく発行されます。</target>
        </trans-unit>
        <trans-unit id="6bd78304e8ab95ec78b59e840c5e6980b10bd2ff" translate="yes">
          <source>In TypeScript 3.5, when assigning to types with discriminant properties like in &lt;code&gt;T&lt;/code&gt;, the language actually &lt;em&gt;will&lt;/em&gt; go further and decompose types like &lt;code&gt;S&lt;/code&gt; into a union of every possible inhabitant type. In this case, since &lt;code&gt;boolean&lt;/code&gt; is a union of &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; will be viewed as a union of &lt;code&gt;{ done: false, value: number }&lt;/code&gt; and &lt;code&gt;{ done: true, value: number }&lt;/code&gt;.</source>
          <target>TypeScript3.5では、&lt;code&gt;T&lt;/code&gt;のような判別特性を持つ型に割り当てる場合、言語は実際に&lt;em&gt;さらに&lt;/em&gt;進み、&lt;code&gt;S&lt;/code&gt;のような型をすべての可能な居住者型の集合に分解する。 この場合、&lt;code&gt;boolean&lt;/code&gt;は&lt;code&gt;true&lt;/code&gt;と&lt;code&gt;false&lt;/code&gt;の和集合であるため、&lt;code&gt;S&lt;/code&gt;は&lt;code&gt;{done:false,value:number}&lt;/code&gt;と&lt;code&gt;{done:true,value:number}&lt;/code&gt;の和集合と見なされます。</target>
        </trans-unit>
        <trans-unit id="d94a96c27cb9468cb91f9314627e1075ad63df4c" translate="yes">
          <source>In TypeScript 3.5, you can now reference UMD global declarations like</source>
          <target>TypeScript3.5では、次のようにUMDグローバル宣言を参照できるようになりました。</target>
        </trans-unit>
        <trans-unit id="ebce4ccb31849685f27f521710646fdd135799f4" translate="yes">
          <source>In TypeScript 3.6, the checker now knows that the correct type for &lt;code&gt;curr.value&lt;/code&gt; should be &lt;code&gt;string&lt;/code&gt; in our first example, and will correctly error on our call to &lt;code&gt;next()&lt;/code&gt; in our last example. This is thanks to some changes in the &lt;code&gt;Iterator&lt;/code&gt; and &lt;code&gt;IteratorResult&lt;/code&gt; type declarations to include a few new type parameters, and to a new type that TypeScript uses to represent generators called the &lt;code&gt;Generator&lt;/code&gt; type.</source>
          <target>TypeScript3.6では、チェッカーは、最初の例で&lt;code&gt;curr.value&lt;/code&gt;の正しい型が&lt;code&gt;string&lt;/code&gt;であることを認識し、最後の例で&lt;code&gt;next()&lt;/code&gt;を呼び出すと正しくエラーが発生する。 これは、&lt;code&gt;Iterator&lt;/code&gt;と&lt;code&gt;IteratorResult&lt;/code&gt;型宣言がいくつかの新しい型パラメータを含むように変更されたことと、&lt;code&gt;Generator&lt;/code&gt;型と呼ばれるジェネレータを表すためにTypeScriptが使用する新しい型に変更されたことによるものです。</target>
        </trans-unit>
        <trans-unit id="0905562c8006d5cf59d0f711433ed32656adf580" translate="yes">
          <source>In TypeScript 3.7, &lt;a href="https://github.com/microsoft/TypeScript/pull/31231"&gt;this is now correctly identified as a duplicate identifier error&lt;/a&gt;. The correct fix depends on the original intent of the author and should be addressed on a case-by-case basis. Usually, the naming conflict is unintentional and the best fix is to rename the imported type. If the intent was to augment the imported type, a proper module augmentation should be written instead.</source>
          <target>TypeScript3.7では、&lt;a href="https://github.com/microsoft/TypeScript/pull/31231"&gt;これは識別子の重複エラーとして正しく識別されるようになりました&lt;/a&gt;。正しい修正方法は、作成者の当初の意図によって異なりますので、ケースバイケースで対処する必要があります。 通常、名前の競合は意図的なものではなく、インポートしたタイプの名前を変更することが最善の解決方法です。 インポートされた型を増強することを意図した場合は、代わりに適切なモジュール増強を記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="3d966bc481353f4c45fe41960daf87445589baab" translate="yes">
          <source>In TypeScript 3.7, the compiler itself will take advantage of this feature so that generated &lt;code&gt;.d.ts&lt;/code&gt; files will also emit &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors.</source>
          <target>TypeScript3.7では、コンパイラ自身がこの機能を利用して、生成された&lt;code&gt;.d.ts&lt;/code&gt;ファイルも&lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt;アクセサーを生成します。</target>
        </trans-unit>
        <trans-unit id="867e1064d30d0ee6d5ae66e30b7de9d7c76047ce" translate="yes">
          <source>In TypeScript 3.7, the compiler will take advantage of this feature so that &lt;code&gt;.d.ts&lt;/code&gt; files generated from &lt;code&gt;.js&lt;/code&gt; files can appropriately capture both the callability and constructability of a class-like function.</source>
          <target>TypeScript3.7では、コンパイラはこの機能を利用して、&lt;code&gt;.js&lt;/code&gt;ファイルから生成された&lt;code&gt;.d.ts&lt;/code&gt;ファイルが、クラスライクな関数の呼び出し可能性と構築可能性の両方を適切にキャプチャできるようにする。</target>
        </trans-unit>
        <trans-unit id="12c564a00c60c29478392ba0894da5e9c08182a8" translate="yes">
          <source>In TypeScript 3.7, this is identified as a likely error:</source>
          <target>TypeScript3.7では、これは可能性のあるエラーとして識別されます。</target>
        </trans-unit>
        <trans-unit id="4164a94a4712ff430d4d9a46e1e26ed5ff082a55" translate="yes">
          <source>In TypeScript 3.7, when opening a project with dependencies, TypeScript will automatically use the source &lt;code&gt;.ts&lt;/code&gt;/&lt;code&gt;.tsx&lt;/code&gt; files instead. This means projects using project references will now see an improved editing experience where semantic operations are up-to-date and &amp;ldquo;just work&amp;rdquo;. You can disable this behavior with the compiler option &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt; which may be appropriate when working in very large projects where this change may impact editing performance.</source>
          <target>TypeScript3.7では、依存関係を持つプロジェクトを開くと、TypeScriptは自動的にソースの&lt;code&gt;.ts&lt;/code&gt;/&lt;code&gt;.tsx&lt;/code&gt;ファイルを代わりに使用する。 つまり、プロジェクト参照を使用するプロジェクトでは、セマンティック操作が最新であり、&amp;ldquo;just work&amp;rdquo;という編集操作が改善されます。 この動作を無効にするには、コンパイラオプション&lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt;を使用します。これは、この変更が編集のパフォーマンスに影響を与える可能性がある非常に大規模なプロジェクトで作業する場合に適しています。</target>
        </trans-unit>
        <trans-unit id="38698da453e7ee13579d517a8684b98de7bc1513" translate="yes">
          <source>In TypeScript or ES6, the &lt;code&gt;import&lt;/code&gt; keyword serves the same purpose:</source>
          <target>TypeScriptまたはES6では、&lt;code&gt;import&lt;/code&gt;キーワードは同じ目的を果たします。</target>
        </trans-unit>
        <trans-unit id="82d214ccb1ea5cf33bc755b464edc62ce95d4e1d" translate="yes">
          <source>In TypeScript, a declaration creates entities in at least one of three groups: namespace, type, or value. Namespace-creating declarations create a namespace, which contains names that are accessed using a dotted notation. Type-creating declarations do just that: they create a type that is visible with the declared shape and bound to the given name. Lastly, value-creating declarations create values that are visible in the output JavaScript.</source>
          <target>TypeScriptでは、宣言によって、名前空間、型、または値の3つのグループのうち少なくとも1つにエンティティが作成されます。 名前空間作成宣言は、ドット表記を使用してアクセスされる名前を含む名前空間を作成します。 型を作成する宣言は、宣言された形状で可視であり、与えられた名前にバインドされる型を作成します。 最後に、値を作成する宣言によって、出力JavaScriptに表示される値が作成されます。</target>
        </trans-unit>
        <trans-unit id="f59c1f1ad017a0e2538bcd6ec781579714841dc0" translate="yes">
          <source>In TypeScript, both &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; actually have their own types named &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; respectively. Much like &lt;code&gt;void&lt;/code&gt;, they&amp;rsquo;re not extremely useful on their own:</source>
          <target>TypeScriptでは、&lt;code&gt;undefined&lt;/code&gt;と&lt;code&gt;null&lt;/code&gt;の両方に、それぞれ&lt;code&gt;undefined&lt;/code&gt;と&lt;code&gt;null&lt;/code&gt;という名前の独自の型があります。 &lt;code&gt;void&lt;/code&gt;と同じように、これらは単独ではあまり有用ではありません。</target>
        </trans-unit>
        <trans-unit id="a1389ac175cd87f93511a411a3c43d05c85ede09" translate="yes">
          <source>In TypeScript, every parameter is assumed to be required by the function. This doesn&amp;rsquo;t mean that it can&amp;rsquo;t be given &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, but rather, when the function is called, the compiler will check that the user has provided a value for each parameter. The compiler also assumes that these parameters are the only parameters that will be passed to the function. In short, the number of arguments given to a function has to match the number of parameters the function expects.</source>
          <target>TypeScriptでは、すべてのパラメータが関数に必要であると想定されています。 これは、&lt;code&gt;null&lt;/code&gt;または&lt;code&gt;undefined&lt;/code&gt;を与えられないことを意味するのではなく、関数が呼び出されると、コンパイラはユーザが各パラメータに値を提供したかどうかをチェックする。 コンパイラは、これらのパラメータが関数に渡される唯一のパラメータであることも前提としています。 つまり、関数に渡される引数の数は、関数が想定するパラメータの数と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="a24475a2eada62cf03ff9dfea85139d779f1476f" translate="yes">
          <source>In TypeScript, just as in ECMAScript 2015, any file containing a top-level &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; is considered a module. Conversely, a file without any top-level &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).</source>
          <target>TypeScriptでは、ECMAScript2015と同様に、最上位レベルの&lt;code&gt;import&lt;/code&gt;または&lt;code&gt;export&lt;/code&gt;を含むすべてのファイルがモジュールと見なされます。 逆に、最上位レベルの&lt;code&gt;import&lt;/code&gt;または&lt;code&gt;export&lt;/code&gt;宣言がないファイルは、その内容がグローバルスコープ(したがってモジュールにも)で使用可能なスクリプトとして扱われます。</target>
        </trans-unit>
        <trans-unit id="1ed5374d91892c7ddbb0f4d810f43603226252a7" translate="yes">
          <source>In TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation. For example, in this code</source>
          <target>TypeScriptには、明示的な型アノテーションがない場合に型推論を使って型情報を提供する場所がいくつかあります。 たとえば、このコードでは</target>
        </trans-unit>
        <trans-unit id="ee7d94eb215257ba5c8ab795047cbaba376a919d" translate="yes">
          <source>In TypeScript, we can also set a value that a parameter will be assigned if the user does not provide one, or if the user passes &lt;code&gt;undefined&lt;/code&gt; in its place. These are called default-initialized parameters. Let&amp;rsquo;s take the previous example and default the last name to &lt;code&gt;"Smith"&lt;/code&gt;.</source>
          <target>TypeScriptでは、ユーザがパラメータを提供しない場合、またはユーザがその代わりに&lt;code&gt;undefined&lt;/code&gt;を渡す場合に、パラメータが割り当てられる値を設定することもできます。 これらはデフォルト初期化パラメータと呼ばれます。 前の例を使用して、姓を&lt;code&gt;"Smith"&lt;/code&gt;にデフォルト設定します。</target>
        </trans-unit>
        <trans-unit id="9b2996a620036d35453f4c7abf1fb3f20ef36789" translate="yes">
          <source>In TypeScript, we can use common object-oriented patterns. One of the most fundamental patterns in class-based programming is being able to extend existing classes to create new ones using inheritance.</source>
          <target>TypeScriptでは、共通のオブジェクト指向パターンを使用できます。 クラス・ベースのプログラミングにおける最も基本的なパターンの1つは、既存のクラスを継承を使用して拡張し、新しいクラスを作成できることです。</target>
        </trans-unit>
        <trans-unit id="f733ba5e652ea7387ab081ac7b355a5f8b8f5005" translate="yes">
          <source>In TypeScript, you can gather these arguments together into a variable:</source>
          <target>TypeScriptでは、これらの引数を1つの変数にまとめることができます。</target>
        </trans-unit>
        <trans-unit id="55204c277d20a924ef143d3605b8feaf73f1f390" translate="yes">
          <source>In TypeScript, you can model this with the &lt;code&gt;export =&lt;/code&gt; construct.</source>
          <target>TypeScriptでは、これを&lt;code&gt;export=&lt;/code&gt;構文でモデル化できます。</target>
        </trans-unit>
        <trans-unit id="82c14892013104e9e43fd9bdca12513d567a243f" translate="yes">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, Typescript understands the CommonJS module format. Assignments to &lt;code&gt;exports&lt;/code&gt; and &lt;code&gt;module.exports&lt;/code&gt; are recognized as export declarations. Similarly, &lt;code&gt;require&lt;/code&gt; function calls are recognized as module imports. For example:</source>
          <target>&lt;code&gt;.js&lt;/code&gt;ファイルでは、TypescriptはCommonJSモジュール形式を理解する。 &lt;code&gt;exports&lt;/code&gt;および&lt;code&gt;module.exports&lt;/code&gt;への割り当ては、エクスポート宣言として認識されます。 同様に、&lt;code&gt;require&lt;/code&gt;関数呼び出しはモジュールインポートとして認識されます。 例:</target>
        </trans-unit>
        <trans-unit id="b54a4161a63a1b96ee32a30fced932fa18ccb0eb" translate="yes">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, the compiler infers properties from property assignments inside the class body. The type of a property is the type given in the constructor, unless it&amp;rsquo;s not defined there, or the type in the constructor is undefined or null. In that case, the type is the union of the types of all the right-hand values in these assignments. Properties defined in the constructor are always assumed to exist, whereas ones defined just in methods, getters, or setters are considered optional.</source>
          <target>&lt;code&gt;.js&lt;/code&gt;ファイルでは、コンパイラはクラス本体内のプロパティ割り当てからプロパティを推論する。 プロパティの型はコンストラクタで指定された型です。ただし、&amp;rsquo;sが定義されていない場合や、コンストラクタの型がundefinedまたはnullの場合は除きます。 この場合、typeは、これらの代入におけるすべての右側の値の型の和集合です。 コンストラクタで定義されたプロパティは常に存在すると見なされますが、メソッド、getter、またはsetterだけで定義されたプロパティはオプションと見なされます。</target>
        </trans-unit>
        <trans-unit id="b1aec57e38f0bba34cdcf5755b6607c4fa3eaad1" translate="yes">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, types can often be inferred just like in &lt;code&gt;.ts&lt;/code&gt; files. Likewise, when types can&amp;rsquo;t be inferred, they can be specified using JSDoc the same way that type annotations are used in a &lt;code&gt;.ts&lt;/code&gt; file. Just like Typescript, &lt;code&gt;--noImplicitAny&lt;/code&gt; will give you errors on the places that the compiler could not infer a type. (With the exception of open-ended object literals; see below for details.)</source>
          <target>&lt;code&gt;.js&lt;/code&gt;ファイルでは、&lt;code&gt;.ts&lt;/code&gt;ファイルと同様に型を推測できることが多い。 同様に、型を推測できない場合は、&lt;code&gt;.ts&lt;/code&gt;ファイルで型注釈を使用するのと同じ方法で、JSDocを使用して型を指定できます。 Typescriptと同じように、&lt;code&gt;--noImplicitAny&lt;/code&gt;はコンパイラが型を推論できなかった箇所にエラーを与える。 (オープンエンドのオブジェクトリテラルを除きます。詳細については、以下を参照してください)。</target>
        </trans-unit>
        <trans-unit id="499d42e07e1a5b7dd4bdd55bbff5c492132e6ecc" translate="yes">
          <source>In a &lt;code&gt;.ts&lt;/code&gt; file, an object literal that initializes a variable declaration gives its type to the declaration. No new members can be added that were not specified in the original literal. This rule is relaxed in a &lt;code&gt;.js&lt;/code&gt; file; object literals have an open-ended type (an index signature) that allows adding and looking up properties that were not defined originally. For instance:</source>
          <target>&lt;code&gt;.ts&lt;/code&gt;ファイルでは、変数宣言を初期化するオブジェクトリテラルが宣言に型を与えます。 元のリテラルに指定されていない新しいメンバは追加できません。 このルールは、&lt;code&gt;.js&lt;/code&gt;ファイルで緩和されています。オブジェクトリテラルには、最初に定義されていなかったプロパティを追加したり、検索したりできる開放型の型(インデックスシグネチャ)があります。 例:</target>
        </trans-unit>
        <trans-unit id="faa28e2f1cd18a9e6940ea8f152a75b8bef80372" translate="yes">
          <source>In a &lt;code&gt;for...in&lt;/code&gt; statement for an object of a generic type &lt;code&gt;T&lt;/code&gt;, the inferred type of the iteration variable was previously &lt;code&gt;keyof T&lt;/code&gt; but is now &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt;. (In other words, the subset of &lt;code&gt;keyof T&lt;/code&gt; that includes only string-like values.)</source>
          <target>汎用タイプ&lt;code&gt;T&lt;/code&gt;のオブジェクトの&lt;code&gt;for.in&lt;/code&gt;ステートメントでは、イテレーション変数の推定タイプは以前は&lt;code&gt;keyof T&lt;/code&gt;でしたが、現在は&lt;code&gt;Extract&amp;lt;keyof T,string&amp;gt;&lt;/code&gt;です(つまり、文字列のような値のみを含む&lt;code&gt;keyof T&lt;/code&gt;のサブセットです)。</target>
        </trans-unit>
        <trans-unit id="94a6c7abfee16098b91b6afd7d77f2cffbbb0188" translate="yes">
          <source>In a function expression or arrow function with no return type annotation, if the function has no &lt;code&gt;return&lt;/code&gt; statements, or only &lt;code&gt;return&lt;/code&gt; statements with expressions of type &lt;code&gt;never&lt;/code&gt;, and if the end point of the function is not reachable (as determined by control flow analysis), the inferred return type for the function is &lt;code&gt;never&lt;/code&gt;.</source>
          <target>戻り型注釈のない関数式または矢印関数では、関数に&lt;code&gt;return&lt;/code&gt;ステートメントがない場合、または&lt;code&gt;never&lt;/code&gt;型の式を持つ&lt;code&gt;return&lt;/code&gt;ステートメントのみがある場合、関数の終了点に到達できない場合(制御フロー分析によって判断)、その関数の推定戻り型は&lt;code&gt;never&lt;/code&gt;となります。</target>
        </trans-unit>
        <trans-unit id="a98314a0bada662b45a18394f388ee15a3db9842" translate="yes">
          <source>In a function with an explicit &lt;code&gt;never&lt;/code&gt; return type annotation, all &lt;code&gt;return&lt;/code&gt; statements (if any) must have expressions of type &lt;code&gt;never&lt;/code&gt; and the end point of the function must not be reachable.</source>
          <target>明示的な&lt;code&gt;never&lt;/code&gt;戻り型注釈を持つ関数では、すべての&lt;code&gt;return&lt;/code&gt;ステートメント(もしあれば)は、&lt;code&gt;never&lt;/code&gt;型の式を持たなければならず、関数の終了点に到達できてはなりません。</target>
        </trans-unit>
        <trans-unit id="f21005b5571e17a92c2f4c810bdd49f11c28d379" translate="yes">
          <source>In a mapped type &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt;, each string literal type in &lt;code&gt;K&lt;/code&gt; introduces a property with a string name, each numeric literal type in &lt;code&gt;K&lt;/code&gt; introduces a property with a numeric name, and each unique symbol type in &lt;code&gt;K&lt;/code&gt; introduces a property with a unique symbol name. Furthermore, if &lt;code&gt;K&lt;/code&gt; includes type &lt;code&gt;string&lt;/code&gt;, a string index signature is introduced, and if &lt;code&gt;K&lt;/code&gt; includes type &lt;code&gt;number&lt;/code&gt;, a numeric index signature is introduced.</source>
          <target>マップされた型&lt;code&gt;{[P in K]:XXX}&lt;/code&gt;では、&lt;code&gt;K&lt;/code&gt;の各文字列リテラル型は文字列名を持つプロパティを導入し、&lt;code&gt;K&lt;/code&gt;の各数値リテラル型は数値名を持つプロパティを導入し、&lt;code&gt;K&lt;/code&gt;の各一意のシンボル型は一意のシンボル名を持つプロパティを導入します。 さらに、&lt;code&gt;K&lt;/code&gt;が型&lt;code&gt;string&lt;/code&gt;を含む場合には、文字列索引署名が導入され、&lt;code&gt;K&lt;/code&gt;が型&lt;code&gt;number&lt;/code&gt;を含む場合には、数値索引署名が導入される。</target>
        </trans-unit>
        <trans-unit id="c902ce3f09f34d229a3e2897a358abb3f93aff0a" translate="yes">
          <source>In a sense, the definite assignment assertion operator is the dual of the non-null assertion operator (in which &lt;em&gt;expressions&lt;/em&gt; are post-fixed with a &lt;code&gt;!&lt;/code&gt;), which we could also have used in the example.</source>
          <target>ある意味では、確定代入アサーション演算子は非NULLのアサーション演算子(&lt;em&gt;式&lt;/em&gt;は&lt;code&gt;!&lt;/code&gt;で事後固定されています)の双対であり、この例でも使用できます。</target>
        </trans-unit>
        <trans-unit id="51dd880d34f252e0aeb77f1d88f4eba9a15ee3cc" translate="yes">
          <source>In a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) we&amp;rsquo;re generic over (e.g. &lt;code&gt;Dictionary&amp;lt;string&amp;gt;&lt;/code&gt; rather than just &lt;code&gt;Dictionary&lt;/code&gt;). This makes the type parameter visible to all the other members of the interface.</source>
          <target>同様の例では、ジェネリックパラメータをインタフェース全体のパラメータに移動することができます。 これにより、&lt;code&gt;Dictionary&lt;/code&gt;ではなく&lt;code&gt;Dictionary&amp;lt;string&amp;gt;&lt;/code&gt;など、どのタイプが一般的かを確認できます。 これにより、タイプパラメータがインタフェースの他のすべてのメンバに表示されます。</target>
        </trans-unit>
        <trans-unit id="7aae1c23f28d25359f684353160aa338cdad63b7" translate="yes">
          <source>In addition to &lt;code&gt;AMD&lt;/code&gt; and &lt;code&gt;CommonJS&lt;/code&gt; module loaders, TypeScript now supports emitting modules &lt;code&gt;UMD&lt;/code&gt; (&lt;a href="https://github.com/umdjs/umd"&gt;Universal Module Definition&lt;/a&gt;) and &lt;a href="https://github.com/systemjs/systemjs"&gt;&lt;code&gt;System&lt;/code&gt;&lt;/a&gt; module formats.</source>
          <target>&lt;code&gt;AMD&lt;/code&gt;および&lt;code&gt;CommonJS&lt;/code&gt;モジュールローダに加えて、TypeScriptはモジュール&lt;code&gt;UMD&lt;/code&gt;(&lt;a href="https://github.com/umdjs/umd"&gt;Universal Module Definition&lt;/a&gt;)および&lt;a href="https://github.com/systemjs/systemjs"&gt;&lt;code&gt;System&lt;/code&gt;&lt;/a&gt;モジュールフォーマットの発行をサポートするようになった。</target>
        </trans-unit>
        <trans-unit id="5006f44bee52625a6ab0a4a313b0d7e2fc88612c" translate="yes">
          <source>In addition to &lt;code&gt;Partial&lt;/code&gt;, Mapped Types can express many useful transformations on types:</source>
          <target>&lt;code&gt;Partial&lt;/code&gt;に加えて、Mapped Typesは型に関する多くの有用な変換を表現することができる。</target>
        </trans-unit>
        <trans-unit id="191adf935ed2ac18958fb4641280ef26e69e454d" translate="yes">
          <source>In addition to compositional patterns like the above, this new inference on generic constructors means that functions that operate on class components in certain UI libraries like React can more correctly operate on generic class components.</source>
          <target>上記のような構成的なパターンに加えて、この一般的なコンストラクターに関する新しい推論は、Reactのような特定のUIライブラリーのクラス・コンポーネントを操作する関数が、一般的なクラス・コンポーネントをより正確に操作できることを意味します。</target>
        </trans-unit>
        <trans-unit id="1a90a08e2836eebeca011762ffd80aadcf5c05eb" translate="yes">
          <source>In addition to creating an object with property names for members, numeric enums members also get a &lt;em&gt;reverse mapping&lt;/em&gt; from enum values to enum names. For example, in this example:</source>
          <target>メンバのプロパティ名を持つオブジェクトを作成するだけでなく、数値列挙メンバは列挙値から列挙名への&lt;em&gt;逆マッピング&lt;/em&gt;も取得します。 たとえば、次のようになります。</target>
        </trans-unit>
        <trans-unit id="9ed91b41f41b6bffe64ebf951bfee935b8c06725" translate="yes">
          <source>In addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and namespaces.</source>
          <target>汎用インターフェースに加えて、汎用クラスを作成することもできます。 一般的なenumと名前空間は作成できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d1e90cce3e41b4e86a90a13f73336c6deb38037e" translate="yes">
          <source>In addition to the existing TypeScript support for decorating declarations with &lt;code&gt;export&lt;/code&gt;, module members can also be exported using separate export declarations, optionally specifying different names for exports using &lt;code&gt;as&lt;/code&gt; clauses.</source>
          <target>&lt;code&gt;export&lt;/code&gt;で宣言を修飾するための既存のTypeScriptサポートに加えて、モジュールメンバは、&lt;code&gt;を&lt;/code&gt;節として使用するエクスポートのための異なる名前をオプションで指定して、別々のエクスポート宣言を使用してエクスポートすることもできる。</target>
        </trans-unit>
        <trans-unit id="5fc2368a23b5c630c12625ea45cc7ece18d41984" translate="yes">
          <source>In addition to the pattern of inner classes, you may also be familiar with the JavaScript practice of creating a function and then extending the function further by adding properties onto the function. TypeScript uses declaration merging to build up definitions like this in a type-safe way.</source>
          <target>内部クラスのパターンに加えて、関数を作成し、その関数にプロパティーを追加することによって関数をさらに拡張するJavaScriptの手法にも精通しているかもしれません。 TypeScriptは宣言マージを使用して、このような定義をタイプセーフな方法で構築します。</target>
        </trans-unit>
        <trans-unit id="64dd39fbc1176fa7cb78d499e27b42f425e4f288" translate="yes">
          <source>In addition to user-defined symbols, there are well-known built-in symbols. Built-in symbols are used to represent internal language behaviors.</source>
          <target>ユーザ定義シンボルに加えて、よく知られた組み込みシンボルがあります。 組み込みシンボルは、内部言語の動作を表すために使用されます。</target>
        </trans-unit>
        <trans-unit id="af6dc8ce595252f91c362798795d00c0d72386ed" translate="yes">
          <source>In addition, entities are &lt;em&gt;implicitly&lt;/em&gt; read-only in several situations:</source>
          <target>さらに、次のような状況では、エンティティは&lt;em&gt;暗黙的に&lt;/em&gt;読み取り専用になります。</target>
        </trans-unit>
        <trans-unit id="f13cadd149f177816bfcd1f47e7199c8a2dd824c" translate="yes">
          <source>In all other cases enum member is considered computed.</source>
          <target>それ以外の場合は、enumメンバが計算されたと見なされます。</target>
        </trans-unit>
        <trans-unit id="afe27faa913e56241e9fef79caeefb4719b9d97b" translate="yes">
          <source>In cases where the compiler can&amp;rsquo;t eliminate &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the type assertion operator to manually remove them. The syntax is postfix &lt;code&gt;!&lt;/code&gt;: &lt;code&gt;identifier!&lt;/code&gt; removes &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from the type of &lt;code&gt;identifier&lt;/code&gt;:</source>
          <target>コンパイラが&lt;code&gt;null&lt;/code&gt;または&lt;code&gt;undefined&lt;/code&gt;を削除できない場合は、タイプアサーション演算子を使用して手動で削除できます。 構文は、&lt;code&gt;!&lt;/code&gt;:&lt;code&gt;identifier!&lt;/code&gt;は、&lt;code&gt;identifier&lt;/code&gt;の型から&lt;code&gt;null&lt;/code&gt;と&lt;code&gt;undefined&lt;/code&gt;を削除します。</target>
        </trans-unit>
        <trans-unit id="46e7cfaa389b12ae897eb1224615c0bd3a3a74e0" translate="yes">
          <source>In earlier versions of TypeScript, we generalized mapped types to operate differently on array-like types. This meant that a mapped type like &lt;code&gt;Boxify&lt;/code&gt; could work on arrays and tuples alike.</source>
          <target>以前のバージョンのTypeScriptでは、配列型に対して異なる動作をするようにマップ型を一般化しました。 つまり、&lt;code&gt;Boxify&lt;/code&gt;のようなマップされた型は、配列とタプルで同じように動作することができます。</target>
        </trans-unit>
        <trans-unit id="d3125ad49c86be35f677e4c8afe1f401c2f39f09" translate="yes">
          <source>In exact terms, the &lt;code&gt;--strict&lt;/code&gt; option sets the &lt;em&gt;default&lt;/em&gt; value for the compiler options listed above. This means it is still possible to individually control the options. For example,</source>
          <target>正確には、&lt;code&gt;--strict&lt;/code&gt;オプションは、上記のコンパイラオプションの&lt;em&gt;default&lt;/em&gt;値を設定します。 つまり、オプションを個別に制御することも可能です。 たとえば</target>
        </trans-unit>
        <trans-unit id="f8bbd9b4c8e18d955c59e1b9bb4bd269b6054dc3" translate="yes">
          <source>In extends clause</source>
          <target>In extends文節</target>
        </trans-unit>
        <trans-unit id="317805e6e63ca60bc3ca9fd2d268f7e654b8cbb1" translate="yes">
          <source>In function calls</source>
          <target>関数呼び出しで</target>
        </trans-unit>
        <trans-unit id="c33d3561ce65af4351cdeaf45173b07c0b043d0d" translate="yes">
          <source>In general, not much is needed to transition a repo using relative modules. Simply place a &lt;code&gt;tsconfig.json&lt;/code&gt; file in each subdirectory of a given parent folder, and add &lt;code&gt;reference&lt;/code&gt;s to these config files to match the intended layering of the program. You will need to either set the &lt;code&gt;outDir&lt;/code&gt; to an explicit subfolder of the output folder, or set the &lt;code&gt;rootDir&lt;/code&gt; to the common root of all project folders.</source>
          <target>一般に、相対モジュールを使用してレポを移行するにはあまり必要ではない。 &lt;code&gt;tsconfig.json&lt;/code&gt;ファイルを、指定された親フォルダの各サブディレクトリに置き、&lt;code&gt;reference&lt;/code&gt;をこれらの設定ファイルに追加して、プログラムの意図された階層化に合わせます。 &lt;code&gt;outDir&lt;/code&gt;を出力フォルダの明示的なサブフォルダに設定するか、&lt;code&gt;rootDir&lt;/code&gt;をすべてのプロジェクトフォルダの共通ルートに設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="b1625c54a8a7392317454ab8180d6577f1b9ae1b" translate="yes">
          <source>In instantiations of a distributive conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt;, references to &lt;code&gt;T&lt;/code&gt; within the conditional type are resolved to individual constituents of the union type (i.e. &lt;code&gt;T&lt;/code&gt; refers to the individual constituents &lt;em&gt;after&lt;/em&gt; the conditional type is distributed over the union type). Furthermore, references to &lt;code&gt;T&lt;/code&gt; within &lt;code&gt;X&lt;/code&gt; have an additional type parameter constraint &lt;code&gt;U&lt;/code&gt; (i.e. &lt;code&gt;T&lt;/code&gt; is considered assignable to &lt;code&gt;U&lt;/code&gt; within &lt;code&gt;X&lt;/code&gt;).</source>
          <target>分散条件タイプ&lt;code&gt;T extends U?X:Y&lt;/code&gt;のインスタンス化では、条件タイプ内の&lt;code&gt;T&lt;/code&gt;への参照は、ユニオンタイプの個々の構成要素に解決されます(つまり、&lt;code&gt;T&lt;/code&gt;は、条件タイプがユニオンタイプに分散された&lt;/em&gt;後の個々の構成要素を参照します)。 さらに、&lt;code&gt;X&lt;/code&gt;内の&lt;code&gt;T&lt;/code&gt;への参照は、追加のタイプパラメータ制約&lt;code&gt;U&lt;/code&gt;を有する(すなわち、&lt;code&gt;T&lt;/code&gt;は、&lt;code&gt;X&lt;/code&gt;内の&lt;code&gt;U&lt;/code&gt;に割り当て可能であると考えられる)。</target>
        </trans-unit>
        <trans-unit id="ade42fc57c0936ec5b4a222b5c45022a1c4760c5" translate="yes">
          <source>In languages like C# and Java, one of the main tools in the toolbox for creating reusable components is &lt;em&gt;generics&lt;/em&gt;, that is, being able to create a component that can work over a variety of types rather than a single one. This allows users to consume these components and use their own types.</source>
          <target>C#やJavaなどの言語では、再利用可能なコンポーネントを作成するためのツールボックスの主要なツールの1つは、&lt;em&gt;generics&lt;/em&gt;です。つまり、単一のタイプではなく、さまざまなタイプで動作するコンポーネントを作成できるということです。 これにより、ユーザーはこれらのコンポーネントを使用し、独自のタイプを使用できます。</target>
        </trans-unit>
        <trans-unit id="5c5505a3474915f4cc4c566956af416ee322aa67" translate="yes">
          <source>In most cases, enums are a perfectly valid solution. However sometimes requirements are tighter. To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it&amp;rsquo;s possible to use &lt;code&gt;const&lt;/code&gt; enums. Const enums are defined using the &lt;code&gt;const&lt;/code&gt; modifier on our enums:</source>
          <target>ほとんどの場合、enumは完全に有効なソリューションです。 しかし、時には要求が厳しくなる。 列挙値にアクセスするときに、余分な生成されたコードと追加の間接費を支払うのを避けるために、&lt;code&gt;const&lt;/code&gt;enumを使用することができる。 const enumは、&lt;code&gt;const&lt;/code&gt;修飾子を使用して定義します。</target>
        </trans-unit>
        <trans-unit id="9977fd8d646f7ee47ce74c49df2a1398accb087c" translate="yes">
          <source>In most cases, type inference is straightforward. In the following sections, we&amp;rsquo;ll explore some of the nuances in how types are inferred.</source>
          <target>ほとんどの場合、型推論は単純です。 次のセクションでは、型を推論する方法の微妙な違いについて説明します。</target>
        </trans-unit>
        <trans-unit id="49e5eb0fe073a6b366d084def4b417b2dc17ba91" translate="yes">
          <source>In nominally-typed languages like C# or Java, the equivalent code would be an error because the &lt;code&gt;Person&lt;/code&gt; class does not explicitly describe itself as being an implementer of the &lt;code&gt;Named&lt;/code&gt; interface.</source>
          <target>C#やJavaのような名目上型付けされた言語では、&lt;code&gt;Person&lt;/code&gt;クラスが&lt;code&gt;Named&lt;/code&gt;インタフェースの実装者であることを明示的に記述していないので、同等のコードはエラーになります。</target>
        </trans-unit>
        <trans-unit id="6cd6a1cda7b4b6dafff0249316846cd737bb057b" translate="yes">
          <source>In older versions of TypeScript, type aliases couldn&amp;rsquo;t be extended or implemented from (nor could they extend/implement other types). As of version 2.7, type aliases can be extended by creating a new intersection type e.g. &lt;code&gt;type Cat = Animal &amp;amp; { purrs: true }&lt;/code&gt;.</source>
          <target>古いバージョンのTypeScriptでは、型エイリアスを拡張したり実装したりすることはできません(他の型を拡張/実装することもできません)。 バージョン2.7では、タイプエイリアスは新しい交差タイプを作成することによって拡張できます。たとえば、&lt;code&gt;type Cat=Animal&amp;amp;{purrs:true}&lt;/code&gt;などです。</target>
        </trans-unit>
        <trans-unit id="4485cefc41070d0508c8ae3601f889e0c3ca550d" translate="yes">
          <source>In older versions, TypeScript would infer the empty object type (&lt;code&gt;{}&lt;/code&gt;) when inferring from other type variables like &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target>古いバージョンでは、TypeScriptは、&lt;code&gt;T&lt;/code&gt;や&lt;code&gt;U&lt;/code&gt;のような他の型変数から推測するとき、空のオブジェクト型(&lt;code&gt;{}&lt;/code&gt;)を推測します。</target>
        </trans-unit>
        <trans-unit id="3becc57b3af3b6f00aff1c308abe30fb09b363bc" translate="yes">
          <source>In order for the compiler to pick the correct type check, it follows a similar process to the underlying JavaScript. It looks at the overload list and, proceeding with the first overload, attempts to call the function with the provided parameters. If it finds a match, it picks this overload as the correct overload. For this reason, it&amp;rsquo;s customary to order overloads from most specific to least specific.</source>
          <target>コンパイラーが正しい型チェックを選択するためには、基礎となるJavaScriptと同様のプロセスに従います。 この関数はオーバーロード・リストを調べ、最初のオーバーロードに続いて、指定されたパラメーターで関数を呼び出そうとします。 一致するものが見つかると、このオーバーロードを正しいオーバーロードとして選択します。 このため、通常は、オーバーロードを最も固有のものから最も固有でないものに順序付けます。</target>
        </trans-unit>
        <trans-unit id="ec884edde65bedd374e2043ee3584a67f5dd3d21" translate="yes">
          <source>In order to ensure that a function never potentially returned &lt;code&gt;undefined&lt;/code&gt; or effectively returned from all code paths, TypeScript needed some syntactic signal - either a &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;throw&lt;/code&gt; at the end of a function. So users found themselves &lt;code&gt;return&lt;/code&gt;-ing their failure functions.</source>
          <target>関数が&lt;code&gt;undefined&lt;/code&gt;を返さないようにしたり、すべてのコードパスから効果的に返されないようにするために、TypeScriptは何らかの構文的なシグナル-関数の終わりに&lt;code&gt;return&lt;/code&gt;か&lt;code&gt;throw&lt;/code&gt;のいずれか-を必要とした。 そのため、ユーザーは自分の失敗関数を&lt;code&gt;return&lt;/code&gt;することに気付きました。</target>
        </trans-unit>
        <trans-unit id="7a30e2c325b4e7b632ea33292d372bb91480fbed" translate="yes">
          <source>In order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements. Given a JSX expression &lt;code&gt;&amp;lt;expr /&amp;gt;&lt;/code&gt;, &lt;code&gt;expr&lt;/code&gt; may either refer to something intrinsic to the environment (e.g. a &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;span&lt;/code&gt; in a DOM environment) or to a custom component that you&amp;rsquo;ve created. This is important for two reasons:</source>
          <target>JSXで型チェックを理解するには、まず組み込み要素と値ベース要素の違いを理解する必要があります。 JSX式&lt;code&gt;&amp;lt;expr/&amp;gt;&lt;/code&gt;が与えられると、&lt;code&gt;expr&lt;/code&gt;は、環境(例えば、DOM環境の&lt;code&gt;div&lt;/code&gt;または&lt;code&gt;span&lt;/code&gt;)に固有の何か、またはあなたが作成したカスタムコンポーネントを参照することができます。 これは、次の2つの理由から重要です。</target>
        </trans-unit>
        <trans-unit id="2c6b1f2bc59ac8b4cd64d29de8b2d3e100cb6d4f" translate="yes">
          <source>In order to use JSX you must do two things.</source>
          <target>JSXを使用するには、次の2つのことを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="2425b2f241ed01dc603f0c439b76c219ccaf89d0" translate="yes">
          <source>In other words, &lt;code&gt;x&lt;/code&gt; must be &lt;code&gt;1&lt;/code&gt; when it gets compared to &lt;code&gt;2&lt;/code&gt;, meaning that the above check is making an invalid comparison.</source>
          <target>つまり、&lt;code&gt;x&lt;/code&gt;が&lt;code&gt;1&lt;/code&gt;と比較される場合、&lt;code&gt;x&lt;/code&gt;は&lt;code&gt;2&lt;/code&gt;である必要があります。これは、上記のチェックが無効な比較を行っていることを意味します。</target>
        </trans-unit>
        <trans-unit id="7e1538e5dd442871789cc5ecc7783750fa78d9ea" translate="yes">
          <source>In other words, TypeScript now catches the above bug, which may be a breaking change for some users, but will largely be helpful.</source>
          <target>言い換えれば、TypeScriptは上記のバグをキャッチするようになった。</target>
        </trans-unit>
        <trans-unit id="93e13237760bfc497efa3e019beaf296fba0f599" translate="yes">
          <source>In other words, hitting go-to-definition on a declaration from a &lt;code&gt;.d.ts&lt;/code&gt; file generated with &lt;code&gt;--declarationMap&lt;/code&gt; will take you to the source file (&lt;code&gt;.ts&lt;/code&gt;) location where that declaration was defined, and not to the &lt;code&gt;.d.ts&lt;/code&gt;.</source>
          <target>つまり、&lt;code&gt;--declarationMap&lt;/code&gt;で生成された&lt;code&gt;.d.ts&lt;/code&gt;ファイルの宣言のgo to definitionをクリックすると、&lt;code&gt;.d.ts&lt;/code&gt;ではなく、その宣言が定義されたソースファイル(&lt;code&gt;.ts&lt;/code&gt;)の場所に移動します。</target>
        </trans-unit>
        <trans-unit id="4c2ced57a304d01037d71bbb4f8dbc6d272f4c53" translate="yes">
          <source>In other words, instead of producing the type</source>
          <target>言い換えれば</target>
        </trans-unit>
        <trans-unit id="13c9723a82ddbb23b59c0ac5eb80038fe61fb8ae" translate="yes">
          <source>In our example, we knew that all uses of &lt;code&gt;x&lt;/code&gt; would be initialized so it makes more sense to use definite assignment assertions than non-null assertions.</source>
          <target>この例では、&lt;code&gt;x&lt;/code&gt;のすべての使用が初期化されるため、非ヌル・アサーションよりも確定代入アサーションを使用する方が理にかなっていることがわかっていました。</target>
        </trans-unit>
        <trans-unit id="e09a40d13c5b9150cdb7cb04b404685efc24c2e1" translate="yes">
          <source>In our examples, we&amp;rsquo;ve been able to freely access the members that we declared throughout our programs. If you&amp;rsquo;re familiar with classes in other languages, you may have noticed in the above examples we haven&amp;rsquo;t had to use the word &lt;code&gt;public&lt;/code&gt; to accomplish this; for instance, C# requires that each member be explicitly labeled &lt;code&gt;public&lt;/code&gt; to be visible. In TypeScript, each member is &lt;code&gt;public&lt;/code&gt; by default.</source>
          <target>この例では、プログラム全体を通じて宣言したメンバーに自由にアクセスできます。 他の言語のクラスに精通している場合は、上記の例で、&lt;code&gt;public&lt;/code&gt;という語を使用する必要がないことにお気付きかもしれません。たとえば、C#では、各メンバーが表示されるように&lt;code&gt;public&lt;/code&gt;というラベルを明示的に付ける必要があります。 TypeScriptでは、各メンバはデフォルトで&lt;code&gt;public&lt;/code&gt;です。</target>
        </trans-unit>
        <trans-unit id="077f32db3171bafea36c02345fca8439c23de1f0" translate="yes">
          <source>In our first example using interfaces, TypeScript lets us pass &lt;code&gt;{ size: number; label: string; }&lt;/code&gt; to something that only expected a &lt;code&gt;{ label: string; }&lt;/code&gt;. We also just learned about optional properties, and how they&amp;rsquo;re useful when describing so-called &amp;ldquo;option bags&amp;rdquo;.</source>
          <target>インターフェースを使用した最初の例では、TypeScriptによって&lt;code&gt;{size:number;label:string;}&lt;/code&gt;を、&lt;code&gt;{label:string;}&lt;/code&gt;だけが必要なものに渡すことができます。また、オプション・プロパティについても学習しました。これは、いわゆる&amp;ldquo;オプション・バッグ&amp;rdquo;を記述するときに、それらがどのように役立つかについても学びました。</target>
        </trans-unit>
        <trans-unit id="b5509d814ae50a61b30f1663160809aaacc3c863" translate="yes">
          <source>In our last example, we had to declare a readonly member &lt;code&gt;name&lt;/code&gt; and a constructor parameter &lt;code&gt;theName&lt;/code&gt; in the &lt;code&gt;Octopus&lt;/code&gt; class. This is needed in order to have the value of &lt;code&gt;theName&lt;/code&gt; accessible after the &lt;code&gt;Octopus&lt;/code&gt; constructor is executed. &lt;em&gt;Parameter properties&lt;/em&gt; let you create and initialize a member in one place. Here&amp;rsquo;s a further revision of the previous &lt;code&gt;Octopus&lt;/code&gt; class using a parameter property:</source>
          <target>最後の例では、&lt;code&gt;Octopus&lt;/code&gt;クラスで読み取り専用のメンバ&lt;code&gt;name&lt;/code&gt;とコンストラクタパラメータ&lt;code&gt;theName&lt;/code&gt;を宣言する必要がありました。 これは、&lt;code&gt;Octopus&lt;/code&gt;コンストラクタの実行後に&lt;code&gt;theName&lt;/code&gt;の値にアクセスできるようにするために必要です。 &lt;em&gt;パラメータ・プロパティ&lt;/em&gt;を使用すると、1つの場所でメンバーを作成および初期化できます。 ここでは、パラメータプロパティを使用した以前の&lt;code&gt;Octopus&lt;/code&gt;クラスのさらなるリビジョンを示します(&amp;r):</target>
        </trans-unit>
        <trans-unit id="a2a7cf3a706d3a1af3a4cb37abf72ef77d6e4707" translate="yes">
          <source>In playing with the example, you may notice that the TypeScript compiler can figure out the type even if you only have types on one side of the equation:</source>
          <target>この例では、数式の片側に型しかない場合でも、TypeScriptコンパイラが型を判断できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9c1b4684fb04512e6c7b40289668510482450dd8" translate="yes">
          <source>In practical terms, strict null checking mode requires that all files in a compilation are null- and undefined-aware.</source>
          <target>実際には、厳密なNULLチェックモードでは、コンパイル内のすべてのファイルがNULLおよび未定義を認識する必要があります。</target>
        </trans-unit>
        <trans-unit id="6bafe310667e5e4e7564369b651bf5008fd49779" translate="yes">
          <source>In pre-ES2015 targets, the most faithful emit for constructs like &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;of&lt;/code&gt; loops and array spreads can be a bit heavy. For this reason, TypeScript uses a simpler emit by default that only supports array types, and supports iterating on other types using the &lt;code&gt;--downlevelIteration&lt;/code&gt; flag. The looser default without &lt;code&gt;--downlevelIteration&lt;/code&gt; works fairly well; however, there were some common cases where the transformation of array spreads had observable differences. For example, the following array containing a spread</source>
          <target>ES2015以前のターゲットでは、&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt;/&lt;code&gt;of&lt;/code&gt;ループや配列スプレッドのような構造体に対して最も忠実な放出は、少し重くなる可能性があります。 このため、TypeScriptはデフォルトで配列型のみをサポートする単純なemitを使用し、&lt;code&gt;--downlevelIteration&lt;/code&gt;フラグを使用して他の型の繰り返しをサポートします。 &lt;code&gt;--downlevelIteration&lt;/code&gt;を使用しない緩やかなデフォルトはかなりうまく機能しますが、配列のスプレッドの変換に目に見える違いがある場合がありました。 たとえば、スプレッドを含む次の配列</target>
        </trans-unit>
        <trans-unit id="d8dc065deb2345b3fc2204f90ad4ee7eedf78bff" translate="yes">
          <source>In previous sections, we created generic identity functions that worked over a range of types. In this section, we&amp;rsquo;ll explore the type of the functions themselves and how to create generic interfaces.</source>
          <target>前のセクションでは、さまざまなタイプで動作する汎用的なID関数を作成しました。 このセクションでは、関数の種類と汎用インタフェースの作成方法について説明します。</target>
        </trans-unit>
        <trans-unit id="f628a9f7456d28c2ae0af03d23563c657fc921e2" translate="yes">
          <source>In previous versions of TypeScript, it was an error to merge classes and functions under any circumstances. Now, ambient classes and functions (classes/functions with the &lt;code&gt;declare&lt;/code&gt; modifier, or in &lt;code&gt;.d.ts&lt;/code&gt; files) can merge. This means that now you can write the following:</source>
          <target>以前のバージョンのTypeScriptでは、どのような状況でもクラスと関数をマージするのはエラーでした。 これで、アンビエントクラスと関数(&lt;code&gt;declare&lt;/code&gt;修飾子を持つクラス/関数、または&lt;code&gt;.d.ts&lt;/code&gt;ファイル内)をマージできるようになりました。 つまり、次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="fa68cb28ba2d8557a82094548a1972baaff4fc7a" translate="yes">
          <source>In previous versions of TypeScript, the language didn&amp;acirc;&amp;euro;&amp;trade;t allow &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessors in ambient contexts (like in &lt;code&gt;declare&lt;/code&gt;-d classes, or in &lt;code&gt;.d.ts&lt;/code&gt; files in general). The rationale was that accessors weren&amp;acirc;&amp;euro;&amp;trade;t distinct from properties as far as writing and reading to these properties; however, &lt;a href="https://github.com/tc39/proposal-class-fields/issues/248"&gt;because ECMAScript&amp;acirc;&amp;euro;&amp;trade;s class fields proposal may have differing behavior from in existing versions of TypeScript&lt;/a&gt;, we realized we needed a way to communicate this different behavior to provide appropriate errors in subclasses.</source>
          <target>以前のバージョンのTypeScriptでは、&lt;code&gt;get&lt;/code&gt;および&lt;code&gt;set&lt;/code&gt;アクセサは、&lt;code&gt;declare&lt;/code&gt;-dクラスや&lt;code&gt;.d.ts&lt;/code&gt;ファイル一般のように、&lt;code&gt;get&lt;/code&gt;および&lt;code&gt;set&lt;/code&gt;アクセサを許可していませんでした。 その理論的根拠は、アクセサーは、プロパティへの書き込みと読み取りに関する限り、プロパティとは区別されないということでした。しかし、&lt;a href="https://github.com/tc39/proposal-class-fields/issues/248"&gt;ECMAScript&amp;acirc;&amp;euro;&amp;trade;sクラスフィールドの提案は、既存のバージョンのTypeScript&lt;/a&gt;とは動作が異なる可能性があるため、サブクラスに適切なエラーを提供するために、この異なる動作を伝達する方法が必要であることに気付きました。</target>
        </trans-unit>
        <trans-unit id="3cd7367e12bf3be0daca8711d8c00eca9148e271" translate="yes">
          <source>In prior versions of TypeScript, unions of callable types could &lt;em&gt;only&lt;/em&gt; be invoked if they had identical parameter lists.</source>
          <target>以前のバージョンのTypeScriptでは、呼び出し可能な型の集合は、それらが同一のパラメータリストを持っている場合に&lt;em&gt;のみ&lt;/em&gt;呼び出すことができた。</target>
        </trans-unit>
        <trans-unit id="6c9fb325d7fa06659600b395394db2f6b03b95fa" translate="yes">
          <source>In regular type checking mode the inferred type of &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;any&lt;/code&gt; because of widening, but in strict null checking mode the inferred type of &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; (and therefore, absent a type annotation, &lt;code&gt;null&lt;/code&gt; is the only possible value for &lt;code&gt;z&lt;/code&gt;).</source>
          <target>通常の型チェックモードでは、&lt;code&gt;z&lt;/code&gt;の推論型は&lt;code&gt;any&lt;/code&gt;であるが、厳密なNULLチェックモードでは&lt;code&gt;z&lt;/code&gt;の推論型は&lt;code&gt;null&lt;/code&gt;である(したがって、型注釈がなければ、&lt;code&gt;null&lt;/code&gt;は&lt;code&gt;z&lt;/code&gt;に対して唯一可能な値である)。</target>
        </trans-unit>
        <trans-unit id="7f54adc2fc21b0868ad3536236db9c436bfd98c6" translate="yes">
          <source>In short using this general type, we can model React&amp;rsquo;s specific behavior for things like &lt;code&gt;defaultProps&lt;/code&gt; and, to some extent, &lt;code&gt;propTypes&lt;/code&gt;.</source>
          <target>簡単に言えば、この一般的なタイプを使用して、&lt;code&gt;defaultProps&lt;/code&gt;やある程度は&lt;code&gt;propTypes&lt;/code&gt;などのReact&amp;rsquo;の特定の動作をモデル化できます。</target>
        </trans-unit>
        <trans-unit id="d64e01fd4a15bfb08f19e69c56c367bb72f206dc" translate="yes">
          <source>In short, what this means is that you&amp;acirc;&amp;euro;&amp;trade;ll be able to appropriately narrow down values from iterators when dealing with them directly.</source>
          <target>つまり、&amp;acirc;&amp;euro;&amp;trade;では、反復子を直接扱うときに、値を適切に絞り込むことができます。</target>
        </trans-unit>
        <trans-unit id="d6cb0b5b618417fb0993aeb5137486599cc6a685" translate="yes">
          <source>In some cases, you may want to only load a module under some conditions. In TypeScript, we can use the pattern shown below to implement this and other advanced loading scenarios to directly invoke the module loaders without losing type safety.</source>
          <target>場合によっては、特定の条件下でのみモジュールをロードする必要があります。 TypeScriptでは、以下に示すパターンを使用して、このロード・シナリオやその他の高度なロード・シナリオを実装し、型の安全性を損なうことなくモジュール・ローダーを直接呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="c99a1ed58829ceab5559116a15c7379e705e9cf2" translate="yes">
          <source>In strict null checking mode the compiler requires every reference to a local variable of a type that doesn&amp;rsquo;t include &lt;code&gt;undefined&lt;/code&gt; to be preceded by an assignment to that variable in every possible preceding code path.</source>
          <target>完全なNULLチェックモードでは、コンパイラは、&lt;code&gt;undefined&lt;/code&gt;を含まないタイプのローカル変数へのすべての参照の前に、すべての可能な先行コードパスでその変数への代入があることを要求します。</target>
        </trans-unit>
        <trans-unit id="90cda15a62a8aabc97010caa6808ab78ddacdf3d" translate="yes">
          <source>In strict null checking mode, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values are &lt;em&gt;not&lt;/em&gt; in the domain of every type and are only assignable to themselves and &lt;code&gt;any&lt;/code&gt; (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). So, whereas &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T | undefined&lt;/code&gt; are considered synonymous in regular type checking mode (because &lt;code&gt;undefined&lt;/code&gt; is considered a subtype of any &lt;code&gt;T&lt;/code&gt;), they are different types in strict type checking mode, and only &lt;code&gt;T | undefined&lt;/code&gt; permits &lt;code&gt;undefined&lt;/code&gt; values. The same is true for the relationship of &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;T | null&lt;/code&gt;.</source>
          <target>厳密なNULLチェックモードでは、&lt;code&gt;null&lt;/code&gt;および&lt;code&gt;undefined&lt;/code&gt;値は、すべてのタイプのドメインでは&lt;em&gt;ではなく&lt;/em&gt;、&lt;code&gt;any&lt;/code&gt;のみに割り当てられます(例外として、&lt;code&gt;undefined&lt;/code&gt;は&lt;code&gt;void&lt;/code&gt;にも割り当てられます)。 したがって、&lt;code&gt;T&lt;/code&gt;と&lt;code&gt;T undefined&lt;/code&gt;は、通常の型チェックモードでは同義と見なされますが(&lt;code&gt;undefined&lt;/code&gt;は&lt;code&gt;T&lt;/code&gt;のサブタイプと見なされるため)、厳密な型チェックモードでは異なる型であり、&lt;code&gt;T undefined&lt;/code&gt;のみが&lt;code&gt;undefined&lt;/code&gt;値を許可します。 &lt;code&gt;T&lt;/code&gt;と&lt;code&gt;T null&lt;/code&gt;の関係も同様です。</target>
        </trans-unit>
        <trans-unit id="864d1a7dd1f8dd603a28df5bb3a63874ccc5a6ed" translate="yes">
          <source>In strict null checking mode, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values are not in the domain of every type and are only assignable to themselves and &lt;code&gt;any&lt;/code&gt; (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;).</source>
          <target>厳密なNULLチェックモードでは、&lt;code&gt;null&lt;/code&gt;および&lt;code&gt;undefined&lt;/code&gt;値は、すべての型のドメイン内にはなく、&lt;code&gt;any&lt;/code&gt;のみに割り当てられます(例外として、&lt;code&gt;undefined&lt;/code&gt;は&lt;code&gt;void&lt;/code&gt;にも割り当てられます)。</target>
        </trans-unit>
        <trans-unit id="1682f16f9b1d6f4b318f3d23665b6e6fd98e0061" translate="yes">
          <source>In that example, we first checked whether &lt;code&gt;x&lt;/code&gt; was &lt;em&gt;not&lt;/em&gt;&lt;code&gt;E.Foo&lt;/code&gt;. If that check succeeds, then our &lt;code&gt;||&lt;/code&gt; will short-circuit, and the body of the &amp;lsquo;if&amp;rsquo; will run. However, if the check didn&amp;rsquo;t succeed, then &lt;code&gt;x&lt;/code&gt; can &lt;em&gt;only&lt;/em&gt; be &lt;code&gt;E.Foo&lt;/code&gt;, so it doesn&amp;rsquo;t make sense to see whether it&amp;rsquo;s equal to &lt;code&gt;E.Bar&lt;/code&gt;.</source>
          <target>この例では、最初に&lt;code&gt;x&lt;/code&gt;が&lt;em&gt;not&lt;/em&gt;&lt;code&gt;E.Foo&lt;/code&gt;であるかどうかをチェックしました。このチェックに成功すると、&lt;code&gt;&lt;/code&gt;が短絡し、&amp;rsquo;が実行されると、&amp;lsquo;の本体が実行されます。 ただし、チェックが成功しなかった場合、&lt;code&gt;x&lt;/code&gt;は&lt;code&gt;E.Foo&lt;/code&gt;のみ&lt;em&gt;可能なので、&lt;code&gt;E.Bar&lt;/code&gt;と等しいかどうかを確認することは意味をなさない。</target>
        </trans-unit>
        <trans-unit id="79540091a75f3fdf1fb7b3a682d8e9c3c45c75f2" translate="yes">
          <source>In the above example, &lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt; will work fine but &lt;code&gt;&amp;lt;bar /&amp;gt;&lt;/code&gt; will result in an error since it has not been specified on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;.</source>
          <target>上記の例では、&lt;code&gt;&amp;lt;foo/&amp;gt;&lt;/code&gt;は正常に動作しますが、&lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;で指定されていないため、&lt;code&gt;&amp;lt;bar/&amp;gt;&lt;/code&gt;はエラーになります。</target>
        </trans-unit>
        <trans-unit id="99596fbea2ab9226b233fd913b5eb437d1c67537" translate="yes">
          <source>In the above example, &lt;code&gt;SelectableControl&lt;/code&gt; contains all of the members of &lt;code&gt;Control&lt;/code&gt;, including the private &lt;code&gt;state&lt;/code&gt; property. Since &lt;code&gt;state&lt;/code&gt; is a private member it is only possible for descendants of &lt;code&gt;Control&lt;/code&gt; to implement &lt;code&gt;SelectableControl&lt;/code&gt;. This is because only descendants of &lt;code&gt;Control&lt;/code&gt; will have a &lt;code&gt;state&lt;/code&gt; private member that originates in the same declaration, which is a requirement for private members to be compatible.</source>
          <target>上記の例では、&lt;code&gt;SelectableControl&lt;/code&gt;に、private&lt;code&gt;state&lt;/code&gt;プロパティを含む&lt;code&gt;Control&lt;/code&gt;のすべてのメンバが含まれています。 &lt;code&gt;state&lt;/code&gt;はプライベート・メンバーであるため、&lt;code&gt;Control&lt;/code&gt;の子孫のみが&lt;code&gt;SelectableControl&lt;/code&gt;を実装できます。これは、&lt;code&gt;Control&lt;/code&gt;の子孫のみが&lt;code&gt;state&lt;/code&gt;プライベート・メンバーを持つためです。これは、プライベート・メンバーが互換性を持つための要件です。</target>
        </trans-unit>
        <trans-unit id="6ed88f77aa26355727030898d3eda06664af6814" translate="yes">
          <source>In the above example, all declarations of &lt;code&gt;x&lt;/code&gt; actually refer to the &lt;em&gt;same&lt;/em&gt;&lt;code&gt;x&lt;/code&gt;, and this is perfectly valid. This often ends up being a source of bugs. Thankfully, &lt;code&gt;let&lt;/code&gt; declarations are not as forgiving.</source>
          <target>上記の例では、&lt;code&gt;x&lt;/code&gt;のすべての宣言が実際には&lt;em&gt;同じ&lt;/em&gt;&lt;code&gt;x&lt;/code&gt;を参照しており、これは完全に有効です。 これがバグの原因になることがよくあります。 ありがたいことに、&lt;code&gt;let&lt;/code&gt;宣言はそれほど寛容ではありません。</target>
        </trans-unit>
        <trans-unit id="b37f0e6648f951eed9141c60cd7cf7e3ccaa9494" translate="yes">
          <source>In the above, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are compatible because their structures do not use the type argument in a differentiating way. Changing this example by adding a member to &lt;code&gt;Empty&amp;lt;T&amp;gt;&lt;/code&gt; shows how this works:</source>
          <target>上の例では、&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;の構造体は型引数を区別して使用しないため、互換性があります。 この例を&lt;code&gt;Empty&amp;lt;T&amp;gt;&lt;/code&gt;にメンバを追加して変更すると、どのように動作するかが示されます。</target>
        </trans-unit>
        <trans-unit id="bcf8f6881cecc6ec19e3b84c191f76d8a00ed9f0" translate="yes">
          <source>In the above, if we truly meant for &lt;code&gt;baz&lt;/code&gt; to potentially be &lt;code&gt;undefined&lt;/code&gt;, we should have declared it with the type &lt;code&gt;boolean | undefined&lt;/code&gt;.</source>
          <target>上記の中で、&lt;code&gt;baz&lt;/code&gt;が&lt;code&gt;undefined&lt;/code&gt;である可能性を本当に意味するのであれば、&lt;code&gt;boolean undefined&lt;/code&gt;型で宣言すべきでした。</target>
        </trans-unit>
        <trans-unit id="ce3f57dfeaf54342e6e1919ab8d0e5f056d046b7" translate="yes">
          <source>In the above, the variable &lt;code&gt;a&lt;/code&gt; has a conditional type that hasn&amp;rsquo;t yet chosen a branch. When another piece of code ends up calling &lt;code&gt;foo&lt;/code&gt;, it will substitute in &lt;code&gt;U&lt;/code&gt; with some other type, and TypeScript will re-evaluate the conditional type, deciding whether it can actually pick a branch.</source>
          <target>上の例では、変数&lt;code&gt;a&lt;/code&gt;に、分岐をまだ選択していない条件タイプがあります。 別のコードが&lt;code&gt;foo&lt;/code&gt;を呼ぶことになると、&lt;code&gt;U&lt;/code&gt;を別の型に置き換え、TypeScriptは条件型を再評価して、実際に分岐を選択できるかどうかを判断する。</target>
        </trans-unit>
        <trans-unit id="61a17b1c1f756acdcb3aa7db7732994bae993575" translate="yes">
          <source>In the code below, we show how you can model mixins in TypeScript. After the code, we&amp;rsquo;ll break down how it works.</source>
          <target>次のコードでは、TypeScriptでミックスインをモデリングする方法を示します。 コードの後で、その動作を説明します。</target>
        </trans-unit>
        <trans-unit id="03d5f48ae796a4f0c523d1b9798d453b05171c1c" translate="yes">
          <source>In the declaration of &lt;code&gt;f2&lt;/code&gt; above, type inference infers types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;[string, boolean]&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; respectively.</source>
          <target>上記の&lt;code&gt;f2&lt;/code&gt;の宣言において、型推論は、それぞれ&lt;code&gt;T&lt;/code&gt;、&lt;code&gt;U&lt;/code&gt;、&lt;code&gt;V&lt;/code&gt;の&lt;code&gt;number&lt;/code&gt;、&lt;code&gt;[string,boolean]&lt;/code&gt;、&lt;code&gt;void&lt;/code&gt;を推論する。</target>
        </trans-unit>
        <trans-unit id="95157007d65e1f4f235f4c91408fe5a0cb118ec2" translate="yes">
          <source>In the example above, the &lt;code&gt;methods&lt;/code&gt; object in the argument to &lt;code&gt;makeObject&lt;/code&gt; has a contextual type that includes &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; and therefore the type of &lt;code&gt;this&lt;/code&gt; in methods within the &lt;code&gt;methods&lt;/code&gt; object is &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt;. Notice how the type of the &lt;code&gt;methods&lt;/code&gt; property simultaneously is an inference target and a source for the &lt;code&gt;this&lt;/code&gt; type in methods.</source>
          <target>上記の例では、&lt;code&gt;makeObject&lt;/code&gt;の引数にある&lt;code&gt;methods&lt;/code&gt;オブジェクトに、&lt;code&gt;ThisType&amp;lt;D&amp;amp;M&amp;gt;&lt;/code&gt;を含むコンテキストタイプがあるため、&lt;code&gt;methods&lt;/code&gt;オブジェクト内のメソッドの&lt;code&gt;this&lt;/code&gt;のタイプは、&lt;code&gt;{x:number,y:number}&amp;amp;{moveBy(dx:number,dy:number):number}&lt;/code&gt;になります。&lt;code&gt;methods&lt;/code&gt;プロパティのタイプが、同時に、&lt;this&lt;/code type&gt;のコードメソッドの推論のソースであることに注目してください。</target>
        </trans-unit>
        <trans-unit id="6d5d9e4e961d95a62eff2086560d0f53e21c16be" translate="yes">
          <source>In the example above, the parameters &lt;code&gt;fruit&lt;/code&gt; and &lt;code&gt;color&lt;/code&gt; are intersected together to a new parameter of type &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt;. &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; is really the same as &lt;code&gt;("apple" | "orange") &amp;amp; ("red" | "orange")&lt;/code&gt; which is equivalent to &lt;code&gt;("apple" &amp;amp; "red") | ("apple" &amp;amp; "orange") | ("orange" &amp;amp; "red") | ("orange" &amp;amp; "orange")&lt;/code&gt;. Each of those impossible intersections reduces to &lt;code&gt;never&lt;/code&gt;, and we&amp;rsquo;re left with &lt;code&gt;"orange" &amp;amp; "orange"&lt;/code&gt; which is just &lt;code&gt;"orange"&lt;/code&gt;.</source>
          <target>上の例では、&lt;code&gt;fruit&lt;/code&gt;パラメータと&lt;code&gt;color&lt;/code&gt;パラメータは、&lt;code&gt;Fruit&amp;amp;Color&lt;/code&gt;タイプの新しいパラメータと交差しています。&lt;code&gt;Fruit&amp;amp;Color&lt;/code&gt;は、&lt;code&gt;("apple""orange")&amp;amp;("red""orange")&lt;/code&gt;と実際には同じです。これは、&lt;code&gt;("apple"&amp;amp;"red")("orange"&amp;amp"&amp;amp;"red")("orange"&amp;amp";orange"code)&lt;/code&gt;とまったく同じです。これらの交差は、&lt;/rs&lt;/code&gt;です。</target>
        </trans-unit>
        <trans-unit id="e74ceca454671112b40bc5e5f6a4f738b5ff4300" translate="yes">
          <source>In the following example, each input element will be printed out one at a time with a 400ms delay:</source>
          <target>次の例では、各入力要素を400ミリ秒の遅延で1つずつ出力します。</target>
        </trans-unit>
        <trans-unit id="8c77483272b3e6dc467114f873247e6bedc0a970" translate="yes">
          <source>In the last line we construct an instance of the &lt;code&gt;Greeter&lt;/code&gt; class using &lt;code&gt;new&lt;/code&gt;. This calls into the constructor we defined earlier, creating a new object with the &lt;code&gt;Greeter&lt;/code&gt; shape, and running the constructor to initialize it.</source>
          <target>最後の行では、&lt;code&gt;new&lt;/code&gt;を使用して&lt;code&gt;Greeter&lt;/code&gt;クラスのインスタンスを構築します。これにより、前に定義したコンストラクタが呼び出され、&lt;code&gt;Greeter&lt;/code&gt;図形を使用して新しいオブジェクトが作成され、コンストラクタが実行されて初期化されます。</target>
        </trans-unit>
        <trans-unit id="00dda950efe1878e4784a73323a690e1209928a7" translate="yes">
          <source>In the last window, select the &lt;strong&gt;Empty&lt;/strong&gt; template and press the &lt;em&gt;Create&lt;/em&gt; button</source>
          <target>最後のウィンドウで、&lt;strong&gt;Empty&lt;/strong&gt;テンプレートを選択し、&lt;em&gt;Create&lt;/em&gt;ボタンを押します。</target>
        </trans-unit>
        <trans-unit id="730482750c8e706f4fdc3f8ccd811c5e5dd87860" translate="yes">
          <source>In the meantime, we can assign a conditional type to any other target type as long as each branch of the conditional is assignable to that target. So in our example above we were able to assign &lt;code&gt;U extends Foo ? string : number&lt;/code&gt; to &lt;code&gt;string | number&lt;/code&gt; since no matter what the conditional evaluates to, it&amp;rsquo;s known to be either &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;.</source>
          <target>その間、条件の各分岐がそのターゲットに割り当てられる限り、他の任意のターゲット型に条件付き型を割り当てることができます。 string:number&lt;/code&gt;から&lt;code&gt;string number&lt;/code&gt;。条件が何に評価されても、&lt;code&gt;string&lt;/code&gt;または&lt;code&gt;number&lt;/code&gt;であることがわかっているためです。</target>
        </trans-unit>
        <trans-unit id="0368f69a71e90b1a67f756648f8543862fbe5df7" translate="yes">
          <source>In the near future, we&amp;acirc;&amp;euro;&amp;trade;re going to be refreshing the playground samples, adding JSX support, and polishing automatic type acquisition, meaning that you&amp;acirc;&amp;euro;&amp;trade;ll be able to see the same experience on the playground as you&amp;acirc;&amp;euro;&amp;trade;d get in your personal editor.</source>
          <target>近い将来、私たちは&amp;acirc;&amp;euro;&amp;trade;で、遊び場のサンプルを更新し、JSXサポートを追加し、自動型取得を磨きます。これは、あなたが&amp;acirc;&amp;euro;&amp;trade;で、あなたが&amp;acirc;&amp;euro;&amp;trade;dと同じ経験を、あなたの個人エディターで得ることができることを意味します。</target>
        </trans-unit>
        <trans-unit id="b3d6d530b9dead34dd8c0b86ef1bb298c7054a3c" translate="yes">
          <source>In the project root, &lt;code&gt;proj&lt;/code&gt;, create the file &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target>プロジェクトルートの&lt;code&gt;proj&lt;/code&gt;に、&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="709cd93c7870c32633ca0a9bee5820c6fc2cb1c9" translate="yes">
          <source>In the project root, create the file &lt;code&gt;gulpfile.js&lt;/code&gt;:</source>
          <target>プロジェクトルートで、ファイル&lt;code&gt;ガルプフィル.js&lt;/code&gt;を作成します。</target>
        </trans-unit>
        <trans-unit id="73b6e04bf922a9cb6a95afcfe0525fa94ba745bd" translate="yes">
          <source>In the type of a module object, exported &lt;code&gt;const&lt;/code&gt; variables are considered read-only properties.</source>
          <target>モジュールオブジェクトのタイプでは、エクスポートされた&lt;code&gt;const&lt;/code&gt;変数は読み取り専用プロパティと見なされます。</target>
        </trans-unit>
        <trans-unit id="755da82a78f6c2a7ac8e76c0724da8dab740a01c" translate="yes">
          <source>In the type of an enum object, enum members are considered read-only properties.</source>
          <target>enumオブジェクトのタイプでは、enumメンバは読み取り専用プロパティと見なされます。</target>
        </trans-unit>
        <trans-unit id="637246693f4b6e39ecb694cc209862482bcc6694" translate="yes">
          <source>In these examples, the properties list is &lt;code&gt;keyof T&lt;/code&gt; and the resulting type is some variant of &lt;code&gt;T[P]&lt;/code&gt;. This is a good template for any general use of mapped types. That&amp;rsquo;s because this kind of transformation is &lt;a href="https://en.wikipedia.org/wiki/Homomorphism"&gt;homomorphic&lt;/a&gt;, which means that the mapping applies only to properties of &lt;code&gt;T&lt;/code&gt; and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if &lt;code&gt;Person.name&lt;/code&gt; was readonly, &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; would be readonly and optional.</source>
          <target>これらの例では、プロパティ・リストは&lt;code&gt;keyof T&lt;/code&gt;で、結果の型は&lt;code&gt;T[P]&lt;/code&gt;のバリアントです。これは、マップされた型の一般的な使用に適したテンプレートです。 この種の変換は&lt;a href="https://en.wikipedia.org/wiki/Homomorphism"&gt;準同型&lt;/a&gt;であるため、マッピングは&lt;code&gt;T&lt;/code&gt;のプロパティにのみ適用され、他には適用されない。 コンパイラは、新しいプロパティ変更子を追加する前に、既存のプロパティ変更子をすべてコピーできることを認識しています。 たとえば、&lt;code&gt;Person.name&lt;/code&gt;が読み取り専用の場合、&lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt;は読み取り専用でオプションになります。</target>
        </trans-unit>
        <trans-unit id="ed7a5a445e563d2e25cbaa994041bb2fd2483e73" translate="yes">
          <source>In this above example, &lt;code&gt;g&lt;/code&gt; captured the variable &lt;code&gt;a&lt;/code&gt; declared in &lt;code&gt;f&lt;/code&gt;. At any point that &lt;code&gt;g&lt;/code&gt; gets called, the value of &lt;code&gt;a&lt;/code&gt; will be tied to the value of &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;f&lt;/code&gt;. Even if &lt;code&gt;g&lt;/code&gt; is called once &lt;code&gt;f&lt;/code&gt; is done running, it will be able to access and modify &lt;code&gt;a&lt;/code&gt;.</source>
          <target>この例では、&lt;code&gt;g&lt;/code&gt;が&lt;code&gt;f&lt;/code&gt;で宣言された変数&lt;code&gt;a&lt;/code&gt;を取得しています。&lt;code&gt;g&lt;/code&gt;が呼び出された時点で、&lt;code&gt;a&lt;/code&gt;の値は&lt;code&gt;f&lt;/code&gt;の&lt;code&gt;a&lt;/code&gt;の値に関連付けられます。&lt;code&gt;g&lt;/code&gt;が&lt;code&gt;f&lt;/code&gt;の実行が終了した後に呼び出された場合でも、&lt;code&gt;a&lt;/code&gt;にアクセスして変更できます。</target>
        </trans-unit>
        <trans-unit id="c8516f6347c523b45eca06136cb8874b9907d612" translate="yes">
          <source>In this case, we need to use TypeScript to tell any of our callers about the ways &lt;code&gt;myCoolFunction&lt;/code&gt; can be called using function overloads.</source>
          <target>この場合、関数オーバーロードを使用して&lt;code&gt;myCoolFunction&lt;/code&gt;を呼び出す方法を呼び出し元に伝えるには、TypeScriptを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e82ac6e4567b6044965f051115c0822a64abe344" translate="yes">
          <source>In this example if &lt;code&gt;someValue&lt;/code&gt; isn&amp;rsquo;t equal to &lt;code&gt;42&lt;/code&gt;, then &lt;code&gt;assert&lt;/code&gt; will throw an &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target>この例では、&lt;code&gt;someValue&lt;/code&gt;が&lt;code&gt;42&lt;/code&gt;に等しくない場合、&lt;code&gt;assert&lt;/code&gt;は&lt;code&gt;AssertionError&lt;/code&gt;をスローします。</target>
        </trans-unit>
        <trans-unit id="e08fcd6cf022585dcfea9733e021155ec20b4944" translate="yes">
          <source>In this example the &lt;code&gt;b?&lt;/code&gt; indicates that &lt;code&gt;b&lt;/code&gt; is optional, so it may be &lt;code&gt;undefined&lt;/code&gt;. &lt;code&gt;keepWholeObject&lt;/code&gt; now has a variable for &lt;code&gt;wholeObject&lt;/code&gt; as well as the properties &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, even if &lt;code&gt;b&lt;/code&gt; is undefined.</source>
          <target>この例では、&lt;code&gt;b?&lt;/code&gt;は、&lt;code&gt;b&lt;/code&gt;がオプションであることを示しています。したがって、&lt;code&gt;undefined&lt;/code&gt;である可能性があります。&lt;code&gt;b&lt;/code&gt;が未定義の場合でも、&lt;code&gt;keepWholeObject&lt;/code&gt;には、&lt;code&gt;a&lt;/code&gt;および&lt;code&gt;b&lt;/code&gt;プロパティと同様に、&lt;code&gt;wholeObject&lt;/code&gt;の変数があります。</target>
        </trans-unit>
        <trans-unit id="0117e5cd2d6305504464fa64c2596948182a60ec" translate="yes">
          <source>In this example, &lt;code&gt;greeter1&lt;/code&gt; works similarly to before. We instantiate the &lt;code&gt;Greeter&lt;/code&gt; class, and use this object. This we have seen before.</source>
          <target>この例では、&lt;code&gt;greeter1&lt;/code&gt;は以前と同様に動作します。 &lt;code&gt;Greeter&lt;/code&gt;クラスをインスタンス化し、このオブジェクトを使用します。 これは以前にも見たことがある。</target>
        </trans-unit>
        <trans-unit id="dbc3444b1d43d45eab0b74e1029b727531c4431d" translate="yes">
          <source>In this example, best common type has a set of four candidates: &lt;code&gt;Animal&lt;/code&gt;, &lt;code&gt;Rhino&lt;/code&gt;, &lt;code&gt;Elephant&lt;/code&gt;, and &lt;code&gt;Snake&lt;/code&gt;. Of these, &lt;code&gt;Animal&lt;/code&gt; can be chosen by the best common type algorithm.</source>
          <target>この例では、&lt;code&gt;Animal&lt;/code&gt;、&lt;code&gt;Rhino&lt;/code&gt;、&lt;code&gt;Elephant&lt;/code&gt;、および&lt;code&gt;Snake&lt;/code&gt;の4つの候補があります。これらの中から、&lt;code&gt;Animal&lt;/code&gt;を最適な共通型アルゴリズムで選択できます。</target>
        </trans-unit>
        <trans-unit id="bb24f11a568ad33b4fe399d85ff9d360b565ca4d" translate="yes">
          <source>In this example, the first block creates the following name meanings:</source>
          <target>この例では、最初のブロックが次の名前の意味を作成します。</target>
        </trans-unit>
        <trans-unit id="6e7043ef257b3c1ba5ae99cc4588d236122d0645" translate="yes">
          <source>In this example, there wasn&amp;rsquo;t a namespace &lt;code&gt;C&lt;/code&gt; until we wrote the &lt;code&gt;namespace&lt;/code&gt; declaration for it. The meaning &lt;code&gt;C&lt;/code&gt; as a namespace doesn&amp;rsquo;t conflict with the value or type meanings of &lt;code&gt;C&lt;/code&gt; created by the class.</source>
          <target>この例では、&lt;code&gt;namespace&lt;/code&gt;宣言を記述するまで、名前空間&lt;code&gt;C&lt;/code&gt;はありませんでした。 名前空間としての&lt;code&gt;C&lt;/code&gt;の意味は、クラスによって作成された&lt;code&gt;C&lt;/code&gt;の値または型の意味と矛盾しない。</target>
        </trans-unit>
        <trans-unit id="07eb43c9c23afe5a52badab0f998515ac89c2d2c" translate="yes">
          <source>In this example, we have an &lt;code&gt;Animal&lt;/code&gt; and a &lt;code&gt;Rhino&lt;/code&gt;, with &lt;code&gt;Rhino&lt;/code&gt; being a subclass of &lt;code&gt;Animal&lt;/code&gt;. We also have a new class &lt;code&gt;Employee&lt;/code&gt; that looks identical to &lt;code&gt;Animal&lt;/code&gt; in terms of shape. We create some instances of these classes and then try to assign them to each other to see what will happen. Because &lt;code&gt;Animal&lt;/code&gt; and &lt;code&gt;Rhino&lt;/code&gt; share the &lt;code&gt;private&lt;/code&gt; side of their shape from the same declaration of &lt;code&gt;private name: string&lt;/code&gt; in &lt;code&gt;Animal&lt;/code&gt;, they are compatible. However, this is not the case for &lt;code&gt;Employee&lt;/code&gt;. When we try to assign from an &lt;code&gt;Employee&lt;/code&gt; to &lt;code&gt;Animal&lt;/code&gt; we get an error that these types are not compatible. Even though &lt;code&gt;Employee&lt;/code&gt; also has a &lt;code&gt;private&lt;/code&gt; member called &lt;code&gt;name&lt;/code&gt;, it&amp;rsquo;s not the one we declared in &lt;code&gt;Animal&lt;/code&gt;.</source>
          <target>この例では、&lt;code&gt;Animal&lt;/code&gt;と&lt;code&gt;Rhino&lt;/code&gt;があり、&lt;code&gt;Rhino&lt;/code&gt;は&lt;code&gt;Animal&lt;/code&gt;のサブクラスです。また、&lt;code&gt;Animal&lt;/code&gt;と形状が同じように見える新しいクラス&lt;code&gt;Employee&lt;/code&gt;もあります。 これらのクラスのインスタンスをいくつか作成し、それらを相互に割り当てて、何が起こるかを確認します。 &lt;code&gt;Animal&lt;/code&gt;と&lt;code&gt;Rhino&lt;/code&gt;は、&lt;code&gt;Animal&lt;/code&gt;の&lt;code&gt;private name:string&lt;/code&gt;の同じ宣言から、シェイプの&lt;code&gt;private&lt;/code&gt;側を共有するため、互換性があります。 ただし、&lt;code&gt;Employee&lt;/code&gt;はそうではありません。&lt;code&gt;Employee&lt;/code&gt;から&lt;code&gt;Animal&lt;/code&gt;に割り当てようとすると、これらのタイプに互換性がないというエラーが表示されます。 &lt;code&gt;Employee&lt;/code&gt;には&lt;code&gt;name&lt;/code&gt;という&lt;code&gt;private&lt;/code&gt;メンバもありますが、&lt;code&gt;Animal&lt;/code&gt;で宣言したメンバではありません。</target>
        </trans-unit>
        <trans-unit id="b1b93b10a4841edacda1facc2b60962e38ac6558" translate="yes">
          <source>In this example, we&amp;rsquo;ll move all validator-related entities into a namespace called &lt;code&gt;Validation&lt;/code&gt;. Because we want the interfaces and classes here to be visible outside the namespace, we preface them with &lt;code&gt;export&lt;/code&gt;. Conversely, the variables &lt;code&gt;lettersRegexp&lt;/code&gt; and &lt;code&gt;numberRegexp&lt;/code&gt; are implementation details, so they are left unexported and will not be visible to code outside the namespace. In the test code at the bottom of the file, we now need to qualify the names of the types when used outside the namespace, e.g. &lt;code&gt;Validation.LettersOnlyValidator&lt;/code&gt;.</source>
          <target>この例では、バリデータに関連するすべてのエンティティを&lt;code&gt;Validation&lt;/code&gt;という名前空間に移動します。ここでは、インタフェースとクラスを名前空間の外部に表示するため、&lt;code&gt;export&lt;/code&gt;で始めます。逆に、変数&lt;code&gt;lettersRegexp&lt;/code&gt;と&lt;code&gt;numberRegexp&lt;/code&gt;は実装の詳細であるため、エクスポートされないままになり、名前空間の外部のコードからは見えなくなります。 ファイルの一番下にあるテスト・コードでは、&lt;code&gt;Validation.LettersOnlyValidator&lt;/code&gt;のように、名前空間の外で使用する場合に型の名前を修飾する必要があります。</target>
        </trans-unit>
        <trans-unit id="21b24c391b92fb3d3163326a7abc4416dc6df6f4" translate="yes">
          <source>In this generated code, an enum is compiled into an object that stores both forward (&lt;code&gt;name&lt;/code&gt; -&amp;gt; &lt;code&gt;value&lt;/code&gt;) and reverse (&lt;code&gt;value&lt;/code&gt; -&amp;gt; &lt;code&gt;name&lt;/code&gt;) mappings. References to other enum members are always emitted as property accesses and never inlined.</source>
          <target>この生成されたコードでは、enumは、順方向(&lt;code&gt;name&lt;/code&gt;-&amp;gt;&lt;code&gt;value&lt;/code&gt;)および逆方向(&lt;code&gt;value&lt;/code&gt;-&amp;gt;&lt;code&gt;name&lt;/code&gt;)のマッピングを格納するオブジェクトにコンパイルされます。 他のenumメンバへの参照は、常にプロパティアクセスとして発行され、インライン化されることはありません。</target>
        </trans-unit>
        <trans-unit id="bdc69a132c77ea1870143e272db1728193078fad" translate="yes">
          <source>In this guide, we&amp;rsquo;ll assume basic familiarity with the TypeScript language. If you haven&amp;rsquo;t already, you should read the &lt;a href="../basic-types"&gt;TypeScript Handbook&lt;/a&gt; to familiarize yourself with basic concepts, especially types and namespaces.</source>
          <target>このガイドでは、TypeScript言語に関する基本的な知識を前提としています。 すでに使用していない場合は、&lt;a href="./basic types"&gt;TypeScript Handbook&lt;/a&gt;を参照して、基本的な概念、特に型と名前空間について理解してください。</target>
        </trans-unit>
        <trans-unit id="344769647b81b7e0305ef0d99ae5fb65a087fe6f" translate="yes">
          <source>In this mode, references to modules and packages (e.g. &lt;code&gt;import&lt;/code&gt;s and &lt;code&gt;/// &amp;lt;reference type="..." /&amp;gt;&lt;/code&gt; directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to. For a more concrete example, we&amp;rsquo;ll defer to &lt;a href="https://nodejs.org/api/cli.html#cli_preserve_symlinks"&gt;the documentation on the Node.js website&lt;/a&gt;.</source>
          <target>このモードでは、モジュールおよびパッケージへの参照(たとえば、&lt;code&gt;import&lt;/code&gt;sおよび&lt;code&gt;//&amp;lt;reference type="."/&amp;gt;&lt;/code&gt;ディレクティブ)は、シンボリックリンクが解決されるパスではなく、シンボリックリンクファイルの場所を基準にして解決されます。 より具体的な例として、&lt;a href="https://nodejs.org/api/cli.html#cli_preserve_symlinks"&gt;Node.jsのWebサイトのドキュメント&lt;/a&gt;に従うことにします。</target>
        </trans-unit>
        <trans-unit id="e80e58412d6afa0148bbe0431cb48a4186ad829b" translate="yes">
          <source>In this section we&amp;rsquo;ll describe various common pitfalls in using namespaces and modules, and how to avoid them.</source>
          <target>このセクションでは、名前空間とモジュールを使用する際の一般的な落とし穴とその回避方法について説明します。</target>
        </trans-unit>
        <trans-unit id="1517fdb2153dd36963c7b932505762d1e99e7637" translate="yes">
          <source>In this section, we will cover type inference in TypeScript. Namely, we&amp;rsquo;ll discuss where and how types are inferred.</source>
          <target>このセクションでは、TypeScriptで型推論を扱う。 つまり、型が推論される場所と方法について説明します。</target>
        </trans-unit>
        <trans-unit id="bf72d17da27b309b1e4973b2684904a5f12bc9b3" translate="yes">
          <source>In this simple example, &lt;code&gt;Keys&lt;/code&gt; is a hard-coded list of property names and the property type is always &lt;code&gt;boolean&lt;/code&gt;, so this mapped type is equivalent to writing:</source>
          <target>この単純な例では、&lt;code&gt;Keys&lt;/code&gt;はプロパティ名のハードコードされたリストであり、プロパティタイプは常に&lt;code&gt;boolean&lt;/code&gt;であるため、このマップされたタイプは次のように記述するのと同じです。</target>
        </trans-unit>
        <trans-unit id="7836cdb9242f8e5048b5c13b75f69d0839c138b0" translate="yes">
          <source>In this version, we add a setter that checks the length of the &lt;code&gt;newName&lt;/code&gt; to make sure it&amp;rsquo;s compatible with the max-length of our backing database field. If it isn&amp;rsquo;t we throw an error notifying client code that something went wrong.</source>
          <target>このバージョンでは、&lt;code&gt;newName&lt;/code&gt;の長さをチェックするsetterを追加して、それがバッキングデータベースフィールドのmax-lengthと互換性があることを確認します。 エラーが発生した場合は、クライアントコードに問題が発生したことを通知するエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="2de95615256a6fbbdcec9fe7db708d237a429e35" translate="yes">
          <source>In this way, a generic type that has its type arguments specified acts just like a non-generic type.</source>
          <target>このように、型引数が指定された総称型は、非総称型と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="6f1aae5fbefc53fbec291cb812ed1e6d471e127d" translate="yes">
          <source>In traditional object-oriented code, we might abstract over the two types by creating a hierarchy of types. While this is much more explicit, it&amp;rsquo;s also a little bit overkill. One of the nice things about the original version of &lt;code&gt;padLeft&lt;/code&gt; was that we were able to just pass in primitives. That meant that usage was simple and concise. This new approach also wouldn&amp;rsquo;t help if we were just trying to use a function that already exists elsewhere.</source>
          <target>従来のオブジェクト指向コードでは、型の階層を作成することによって2つの型を抽象化することができます。 これはずっと明確ですが、ちょっとやりすぎです。 &lt;code&gt;padLeft&lt;/code&gt;のオリジナルバージョンの良い点の1つは、プリミティブを渡すことができたことです。 つまり、使い方は簡単で簡潔だった。 この新しいアプローチは、他の場所にすでに存在する関数を使用しようとする場合にも役に立ちません。</target>
        </trans-unit>
        <trans-unit id="3797c645e8a8c499cfcb7b4049e4893eece69214" translate="yes">
          <source>In your editor, type the following JavaScript code in &lt;code&gt;greeter.ts&lt;/code&gt;:</source>
          <target>エディタで、&lt;code&gt;greeter.ts&lt;/code&gt;に次のJavaScriptコードを入力します。</target>
        </trans-unit>
        <trans-unit id="4dbe40d3f9dd76b0ebc598a2769c3f694b16d1ea" translate="yes">
          <source>Include modules imported with &lt;code&gt;.json&lt;/code&gt; extension.</source>
          <target>&lt;code&gt;.json&lt;/code&gt;拡張でインポートされたモジュールをインクルードする。</target>
        </trans-unit>
        <trans-unit id="6898584222dc5329b65b711cc8ca941a2e824a68" translate="yes">
          <source>Including &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--allowJs&lt;/code&gt;</source>
          <target>&lt;code&gt;.js&lt;/code&gt;ファイルを&lt;code&gt;--allowJs&lt;/code&gt;でインクルードする</target>
        </trans-unit>
        <trans-unit id="ab817f6003eff1222b8c915e012bd4827feb5c30" translate="yes">
          <source>Including built-in type declarations with &lt;code&gt;--lib&lt;/code&gt;</source>
          <target>&lt;code&gt;--lib&lt;/code&gt;を使用した組み込み型宣言の組み込み</target>
        </trans-unit>
        <trans-unit id="c320930067fba589bb3a1d6786d55f841bf144ab" translate="yes">
          <source>Including declarations in your npm package</source>
          <target>npmパッケージに宣言を含める</target>
        </trans-unit>
        <trans-unit id="9bc53de5c2f8d2c282bf0578d8a05703182b23ad" translate="yes">
          <source>Incremental file watching for composite projects in &lt;code&gt;--build --watch&lt;/code&gt;</source>
          <target>&lt;code&gt;--build--watch&lt;/code&gt;内の複合プロジェクトを監視する増分ファイル</target>
        </trans-unit>
        <trans-unit id="5eccb92925bc3929eabb42f52bbdf91059031375" translate="yes">
          <source>Index types</source>
          <target>インデックスの種類</target>
        </trans-unit>
        <trans-unit id="0b06669b4c136bdf3d1ec21cafd1d15df80fad00" translate="yes">
          <source>Index types and index signatures</source>
          <target>インデックスタイプとインデックスシグネチャ</target>
        </trans-unit>
        <trans-unit id="aaf103e4bce1dd95f1b6e037cb4cf33238541524" translate="yes">
          <source>Indexable Types</source>
          <target>索引可能タイプ</target>
        </trans-unit>
        <trans-unit id="3260fe038f2a1e9f4a6bf5d1a731cf910deb01de" translate="yes">
          <source>Inference from mapped types</source>
          <target>マップされた型からの推論</target>
        </trans-unit>
        <trans-unit id="72e097bb1e3bc0e862f9bef6c7816dfc1cfe0932" translate="yes">
          <source>Inferring the types</source>
          <target>タイプを推測する</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes">
          <source>Inheritance</source>
          <target>継承</target>
        </trans-unit>
        <trans-unit id="29c771a275b4fc168c6e9a9b4f16f9f866101cf5" translate="yes">
          <source>Initialize the project</source>
          <target>プロジェクトの初期化</target>
        </trans-unit>
        <trans-unit id="0223edbd4b306241485da6ea36e04c5f73dc76b6" translate="yes">
          <source>Initializes a TypeScript project and creates a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target>TypeScriptプロジェクトを初期化し、&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルを作成する。</target>
        </trans-unit>
        <trans-unit id="d40721226c9107841a5c9b9ca80d5a8dfbb2c0d8" translate="yes">
          <source>Initializing an object with dynamic properties can be a bit of a burden. Take the following example:</source>
          <target>動的プロパティを使用してオブジェクトを初期化することは、多少負担になります。 次に例を示します。</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes">
          <source>Input</source>
          <target>入力</target>
        </trans-unit>
        <trans-unit id="48ea5eb348b8b2f027b76b2af44bc6ce31c449b9" translate="yes">
          <source>Inside the &lt;code&gt;"devDependencies"&lt;/code&gt; section of the &lt;code&gt;package.json&lt;/code&gt; file, add &lt;em&gt;gulp&lt;/em&gt; and &lt;em&gt;del&lt;/em&gt;</source>
          <target>&lt;code&gt;package.json&lt;/code&gt;ファイルの&lt;code&gt;"devDependencies"&lt;/code&gt;セクション内に、&lt;em&gt;gulp&lt;/em&gt;と&lt;em&gt;del&lt;/em&gt;を追加します。</target>
        </trans-unit>
        <trans-unit id="fd6c3ebf7befca9f8208f86c76e4d4180303745c" translate="yes">
          <source>Install</source>
          <target>インストール</target>
        </trans-unit>
        <trans-unit id="e922164fa8e7b23fe5db7d0703923eff79dbef32" translate="yes">
          <source>Install ASP.NET Core and TypeScript</source>
          <target>ASP.NET CoreとTypeScriptのインストール</target>
        </trans-unit>
        <trans-unit id="1e48e8ef34685eb17d478c13cfd199caadcb3708" translate="yes">
          <source>Install our dependencies</source>
          <target>依存関係をインストールする</target>
        </trans-unit>
        <trans-unit id="e371877bb54c12671888c28362c3b32432ec40a5" translate="yes">
          <source>Installing TypeScript</source>
          <target>TypeScriptをインストールしています</target>
        </trans-unit>
        <trans-unit id="7e1b693036a58a03968a6e5334fb040acb6e66b4" translate="yes">
          <source>InstanceType&lt;T&gt;</source>
          <target state="translated">InstanceType&lt;T&gt;</target>
        </trans-unit>
        <trans-unit id="ef07ef5ff526694802527d041e5b29af71c04bd8" translate="yes">
          <source>Instead of &lt;code&gt;Object&lt;/code&gt;, use the non-primitive &lt;code&gt;object&lt;/code&gt; type (&lt;a href="../release-notes/typescript-2-2#object-type"&gt;added in TypeScript 2.2&lt;/a&gt;).</source>
          <target>&lt;code&gt;Object&lt;/code&gt;の代わりに、プリミティブでない&lt;code&gt;object&lt;/code&gt;型(&lt;a href="./release-notes/typescript-2-2#object-type"&gt;TypeScript2.2&lt;/a&gt;で追加)を使用します。</target>
        </trans-unit>
        <trans-unit id="ee6363c045a14fb760ecdd97fa1210a76455315e" translate="yes">
          <source>Instead of &lt;code&gt;any&lt;/code&gt;, we can use a &lt;em&gt;union type&lt;/em&gt; for the &lt;code&gt;padding&lt;/code&gt; parameter:</source>
          <target>&lt;code&gt;any&lt;/code&gt;の代わりに、&lt;code&gt;padding&lt;/code&gt;パラメータに&lt;em&gt;union type&lt;/em&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="d1fdeb6abb8961fb107ac368ef09e36ad9963ee3" translate="yes">
          <source>Instead of a relatively useless type like &lt;code&gt;(x: {}) =&amp;gt; Box&amp;lt;{}[]&amp;gt;&lt;/code&gt;, which older versions of the language would infer, TypeScript 3.4&amp;rsquo;s inference allows &lt;code&gt;newFn&lt;/code&gt; to be generic. Its new type is &lt;code&gt;&amp;lt;T&amp;gt;(x: T) =&amp;gt; Box&amp;lt;T[]&amp;gt;&lt;/code&gt;.</source>
          <target>&lt;code&gt;(x: {})=&amp;gt;Box&amp;lt;{}[]&amp;gt;&lt;/code&gt;のような比較的役に立たない型ではなく、TypeScript3.4&amp;rsquo;の推論は&lt;code&gt;newFn&lt;/code&gt;をジェネリックにすることを可能にします。新しい型は&lt;code&gt;&amp;lt;T&amp;gt;(x: T)=&amp;gt;Box&amp;lt;T[]&amp;gt;&lt;/code&gt;です。</target>
        </trans-unit>
        <trans-unit id="f41af89aee0ce0aa8f256c662d27ad424fd39973" translate="yes">
          <source>Instead of working with any and all types, we&amp;rsquo;d like to constrain this function to work with any and all types that also have the &lt;code&gt;.length&lt;/code&gt; property. As long as the type has this member, we&amp;rsquo;ll allow it, but it&amp;rsquo;s required to have at least this member. To do so, we must list our requirement as a constraint on what T can be.</source>
          <target>すべての型を処理する代わりに、&lt;code&gt;.length&lt;/code&gt;プロパティを持つすべての型を処理するように、この関数を制約します。 タイプにこのメンバがある限り、許可しますが、少なくともこのメンバが必要です。 そうするためには、Tが何になるかという制約として、私たちの要件を列挙しなければなりません。</target>
        </trans-unit>
        <trans-unit id="9e88339b09438dc6ef45500af5364169862881c3" translate="yes">
          <source>Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a &lt;em&gt;type variable&lt;/em&gt;, a special kind of variable that works on types rather than values.</source>
          <target>代わりに、何が返されるかを示すためにも使えるような方法で、引数の型を取得する方法が必要です。 ここでは、&lt;em&gt;type変数&lt;/em&gt;を使用します。これは、値ではなく型に対して動作する特殊な変数です。</target>
        </trans-unit>
        <trans-unit id="877c391d483e3da8842226931c49930770980487" translate="yes">
          <source>Instead, we need to pass in values whose type has all the required properties:</source>
          <target>代わりに、型に必要なすべてのプロパティーを持つ値を渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="01593ae1a34a1c7e14f63f2874056a43c2031680" translate="yes">
          <source>Instead, you would need to work with the static side of the class directly. In this example, we define two interfaces, &lt;code&gt;ClockConstructor&lt;/code&gt; for the constructor and &lt;code&gt;ClockInterface&lt;/code&gt; for the instance methods. Then, for convenience, we define a constructor function &lt;code&gt;createClock&lt;/code&gt; that creates instances of the type that is passed to it:</source>
          <target>代わりに、クラスの静的な側面を直接操作する必要があります。 この例では、コンストラクタに&lt;code&gt;ClockConstructor&lt;/code&gt;、インスタンスメソッドに&lt;code&gt;ClockInterface&lt;/code&gt;という2つのインタフェースを定義します。 次に、便宜上、渡される型のインスタンスを作成するコンストラクタ関数&lt;code&gt;createClock&lt;/code&gt;を定義します。</target>
        </trans-unit>
        <trans-unit id="e3192428f7f4fc6017fd4b426dc0b119b5a30e14" translate="yes">
          <source>Integrating with Build Tools</source>
          <target>構築ツールとの統合</target>
        </trans-unit>
        <trans-unit id="22212097f0e33b11964a53f929fec73cee63a40c" translate="yes">
          <source>Integrating with Build Tools: Babel</source>
          <target>ビルドツールとの統合:Babel</target>
        </trans-unit>
        <trans-unit id="9dbaa1369f5ee20cc334fa494b2df4b92581aa4c" translate="yes">
          <source>Integrating with Build Tools: Browserify</source>
          <target>ビルドツールとの統合:Browserify</target>
        </trans-unit>
        <trans-unit id="3ec7ffbef629ea76ad15ce276ed9ecdb2cc592e5" translate="yes">
          <source>Integrating with Build Tools: Duo</source>
          <target>ビルドツールとの統合:Duo</target>
        </trans-unit>
        <trans-unit id="fbba0594dd61ce66de3d77f11bfcd50051321332" translate="yes">
          <source>Integrating with Build Tools: Grunt</source>
          <target>ビルドツールとの統合:Grunt</target>
        </trans-unit>
        <trans-unit id="ffe5a64fcf1dd3fb7dd23d6ac3c6b86ef5e5925e" translate="yes">
          <source>Integrating with Build Tools: Gulp</source>
          <target>ビルドツールとの統合:Gump</target>
        </trans-unit>
        <trans-unit id="aa266b141c65598c72592d75b9246ecc79078e35" translate="yes">
          <source>Integrating with Build Tools: Jspm</source>
          <target>構築ツールとの統合:Jspm</target>
        </trans-unit>
        <trans-unit id="70482080c6efdc1c68f0832eaaf93423e1e5b273" translate="yes">
          <source>Integrating with Build Tools: MSBuild</source>
          <target>ビルドツールとの統合:MSBuild</target>
        </trans-unit>
        <trans-unit id="ab83f8abf8483dec13ed24ba6d2e9eb284f56ffa" translate="yes">
          <source>Integrating with Build Tools: NuGet</source>
          <target>ビルドツールとの統合:NuGet</target>
        </trans-unit>
        <trans-unit id="d40c6086bb9387a195dd8b229c344fef47424fa3" translate="yes">
          <source>Integrating with Build Tools: Webpack</source>
          <target>構築ツールとの統合:Webpack</target>
        </trans-unit>
        <trans-unit id="50c62dd2c72c526623cd3aa97cdf9e954ed24d3d" translate="yes">
          <source>IntelliJ IDEA (Mac)</source>
          <target>IntelliJ IDEA(Mac)</target>
        </trans-unit>
        <trans-unit id="786f15960455f4c51ef85df82efd7a27a91dc1ba" translate="yes">
          <source>IntelliJ IDEA (Windows)</source>
          <target>IntelliJ IDEA(Windows)</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes">
          <source>Interface</source>
          <target>インタフェース</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes">
          <source>Interfaces</source>
          <target>インタフェース</target>
        </trans-unit>
        <trans-unit id="92daefb7ec0fc8b648c80aca28475265591e79ec" translate="yes">
          <source>Interfaces Extending Classes</source>
          <target>クラスを拡張するインタフェース</target>
        </trans-unit>
        <trans-unit id="96e2b4ca11436e61acf1d8a96fcf247872f1b2ff" translate="yes">
          <source>Interfaces are capable of describing the wide range of shapes that JavaScript objects can take. In addition to describing an object with properties, interfaces are also capable of describing function types.</source>
          <target>インターフェースは、JavaScriptオブジェクトが取ることができる広範囲の形状を記述することができます。 インタフェースは、プロパティを持つオブジェクトを記述するだけでなく、関数型を記述することもできます。</target>
        </trans-unit>
        <trans-unit id="1182e7a77aad9fb1ced581374b610320fa4806c8" translate="yes">
          <source>Interfaces describe the public side of the class, rather than both the public and private side. This prohibits you from using them to check that a class also has particular types for the private side of the class instance.</source>
          <target>インターフェイスは、公開側と非公開側の両方ではなく、クラスの公開側を記述します。 これにより、クラスインスタンスのプライベート側にも特定の型があることをチェックするために、これらを使用することができなくなります。</target>
        </trans-unit>
        <trans-unit id="296b5977caa1cbec518b7e75c1da7e2fd0eaa696" translate="yes">
          <source>Interfaces vs. Type Aliases</source>
          <target>インタフェースとタイプの別名</target>
        </trans-unit>
        <trans-unit id="54fe00f4a20d8d06ce299185a910049d83b48bdd" translate="yes">
          <source>Interfaces with optional properties are written similar to other interfaces, with each optional property denoted by a &lt;code&gt;?&lt;/code&gt; at the end of the property name in the declaration.</source>
          <target>オプションプロパティを持つインタフェースは、他のインタフェースと同様に記述されます。各オプションプロパティは、宣言内のプロパティ名の末尾に&lt;code&gt;?&lt;/code&gt;で示されます。</target>
        </trans-unit>
        <trans-unit id="ef35fc41614978724e53f8c707770be7d1309ab3" translate="yes">
          <source>Intersection Types</source>
          <target state="translated">交差型</target>
        </trans-unit>
        <trans-unit id="b87d8878892520ebb9edc358d8dd9e3d44011f0c" translate="yes">
          <source>Intersection types</source>
          <target state="translated">交差型</target>
        </trans-unit>
        <trans-unit id="c8bf0e8c1ae3e60a82098f1409f6db85661db7a9" translate="yes">
          <source>Intrinsic elements</source>
          <target>固有の要素</target>
        </trans-unit>
        <trans-unit id="f97123626594d771751041a210b6256d26fd2930" translate="yes">
          <source>Intrinsic elements are looked up on the special interface &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;. By default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked. However, if this interface &lt;em&gt;is&lt;/em&gt; present, then the name of the intrinsic element is looked up as a property on the &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; interface. For example:</source>
          <target>組み込み要素は、特別なインタフェース&lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;で検索されます。デフォルトでは、このインタフェースが指定されていない場合、すべての項目が検索され、組み込み要素は型チェックされません。 ただし、このインターフェース&lt;em&gt;が存在する場合は、組み込み要素の名前が&lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;インターフェースのプロパティーとして検索されます。 例:</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes">
          <source>Introduction</source>
          <target>はじめに</target>
        </trans-unit>
        <trans-unit id="92a605a41a1bfb9eec6573b6d10084310be8afb9" translate="yes">
          <source>Introduction: Deep Dive</source>
          <target>はじめに:ディープ・ダイブ</target>
        </trans-unit>
        <trans-unit id="88ac7b281daf4911d47c89c86d34416225280141" translate="yes">
          <source>Introduction: Find and Install Declaration Files</source>
          <target>はじめに:宣言ファイルの検索とインストール</target>
        </trans-unit>
        <trans-unit id="4f8abbfcfad58ab5902f7d7dad80570ab5c1e9de" translate="yes">
          <source>Introduction: Library Structures</source>
          <target>はじめに:ライブラリ構造</target>
        </trans-unit>
        <trans-unit id="be4e2ac8a7225060bbaf50e88cd4c64bbb2b91e0" translate="yes">
          <source>Introduction: Publish to npm</source>
          <target>はじめに:npmにパブリッシュする</target>
        </trans-unit>
        <trans-unit id="d9cf5daf5910fcc22fa06cac1c556299707a4e15" translate="yes">
          <source>Introduction: Sections</source>
          <target>はじめに:断面</target>
        </trans-unit>
        <trans-unit id="9da99d0d81d3d8dfe82f617de62c7c013f3809b6" translate="yes">
          <source>Introduction: Templates</source>
          <target>はじめに:テンプレート</target>
        </trans-unit>
        <trans-unit id="4744b3b706d889422bd89021c824c3afa8c9a741" translate="yes">
          <source>Introduction: “Do”s and “Don’t”s</source>
          <target>はじめに:「する」と「しない」</target>
        </trans-unit>
        <trans-unit id="3e7c599bec18d30837143fafc667da7bae8fb3ce" translate="yes">
          <source>Invoking &lt;code&gt;tsc&lt;/code&gt; twice incurs more startup time overhead</source>
          <target>&lt;code&gt;tsc&lt;/code&gt;を2回呼び出すと、起動時間のオーバーヘッドが増加する</target>
        </trans-unit>
        <trans-unit id="580856a132ab9d88e4420d07722840d0bee558f0" translate="yes">
          <source>Invoking the compiler with &lt;code&gt;--alwaysStrict&lt;/code&gt; causes:</source>
          <target>&lt;code&gt;--alwaysStrict&lt;/code&gt;を指定してコンパイラを起動すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="2aa2b4b449585e3cac683fe9949dde17f0c4900d" translate="yes">
          <source>Invoking the compiler with &lt;code&gt;--traceResolution&lt;/code&gt;</source>
          <target>&lt;code&gt;--traceResolution&lt;/code&gt;でコンパイラを呼び出す</target>
        </trans-unit>
        <trans-unit id="95f0156bbb4c60fc06035b7f6f73dc250490e988" translate="yes">
          <source>It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports.)</source>
          <target>また、グローバル変数として使用することもできますが、スクリプト内でのみ使用できます(スクリプトとは、インポートやエクスポートを行わないファイルです)。</target>
        </trans-unit>
        <trans-unit id="a4a4a00d6a8d5c101bf84b8d87236b25e876e72f" translate="yes">
          <source>It can also be used to create simple namespaces:</source>
          <target>また、単純な名前空間を作成するためにも使用できます。</target>
        </trans-unit>
        <trans-unit id="4806c2a5b8c0aca238175b098dcd2585b109419d" translate="yes">
          <source>It does not have an initializer and the preceding enum member was a &lt;em&gt;numeric&lt;/em&gt; constant. In this case the value of the current enum member will be the value of the preceding enum member plus one.</source>
          <target>これには初期化子がなく、先行するenumメンバは&lt;em&gt;数値&lt;/em&gt;定数でした。 この場合、現在のenumメンバの値は、直前のenumメンバの値に1を加えた値になります。</target>
        </trans-unit>
        <trans-unit id="ae3a8ea5fd61fc3c908eab11fa4a4f9073d77d83" translate="yes">
          <source>It is a common pattern to return the current object (i.e. &lt;code&gt;this&lt;/code&gt;) from a method to create &lt;a href="https://en.wikipedia.org/wiki/Fluent_interface"&gt;fluent-style APIs&lt;/a&gt;. For instance, consider the following &lt;code&gt;BasicCalculator&lt;/code&gt; module:</source>
          <target>&lt;a href="https://en.wikipedia.org/wiki/Fluent_interface"&gt;流れるようなスタイルのAPI&lt;/a&gt;を作成するメソッドから現在のオブジェクト(つまり&lt;code&gt;this&lt;/code&gt;)を返すのは一般的なパターンです。たとえば、次の&lt;code&gt;BasicCalculator&lt;/code&gt;モジュールを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="62ffe9a036a8fbf5b41aec16bc2aa0caa4f8a019" translate="yes">
          <source>It is a compile time error for constant enum expressions to be evaluated to &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Infinity&lt;/code&gt;.</source>
          <target>&lt;code&gt;NaN&lt;/code&gt;または&lt;code&gt;Infinity&lt;/code&gt;と評価される定数enum式のコンパイル時エラーです。</target>
        </trans-unit>
        <trans-unit id="99b3cb57ca8b4b1d02c5836ced85b9301080e00f" translate="yes">
          <source>It is also worth noting that, for Node.js applications, modules are the default and the recommended approach to structure your code.</source>
          <target>また、Node.jsアプリケーションでは、モジュールがデフォルトであり、コードを構造化するために推奨されるアプローチであることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="f083343eb50dcd945be59c0708845b66b4753dc5" translate="yes">
          <source>It is an error to reference a file that does not exist. It is an error for a file to have a triple-slash reference to itself.</source>
          <target>存在しないファイルを参照するとエラーになります。 ファイルがそれ自身へのトリプルスラッシュ参照を持つことはエラーです。</target>
        </trans-unit>
        <trans-unit id="3f74a022e24576b8bca3c7e9007ad3819041ef57" translate="yes">
          <source>It is important to note that it is an error to call a function with too many arguments.</source>
          <target>引数が多すぎる関数を呼び出すとエラーになることに注意してください。</target>
        </trans-unit>
        <trans-unit id="be67ce2203241cd9f4ea1e5b61ef39e52b2d569c" translate="yes">
          <source>It is important to note that the compiler will &lt;em&gt;not&lt;/em&gt; perform any of these transformations; it just uses these pieces of information to guide the process of resolving a module import to its definition file.</source>
          <target>コンパイラは、これらの変換を実行&lt;em&gt;しない&lt;/em&gt;ことに注意してください。コンパイラは、これらの情報を使用して、定義ファイルへのモジュールインポートを解決するプロセスをガイドします。</target>
        </trans-unit>
        <trans-unit id="1efd3564ec8a22d45891c5ad072535fbd6663440" translate="yes">
          <source>It is not possible to use &lt;code&gt;infer&lt;/code&gt; declarations in constraint clauses for regular type parameters:</source>
          <target>&lt;code&gt;infer&lt;/code&gt;宣言は、通常の型パラメータの制約句では使用できません。</target>
        </trans-unit>
        <trans-unit id="78ecb7e98034ba8c6a31702e1802139e82a8abee" translate="yes">
          <source>It is possible to define the type of a class component. However, to do so it is best to understand two new terms: the &lt;em&gt;element class type&lt;/em&gt; and the &lt;em&gt;element instance type&lt;/em&gt;.</source>
          <target>クラスコンポーネントのタイプを定義できます。 ただし、これを行うには、&lt;em&gt;要素クラスタイプ&lt;/em&gt;と&lt;em&gt;要素インスタンスタイプ&lt;/em&gt;の2つの新しい用語を理解することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="3393d397de3e56585237bbbf12b74b296eb1e0ea" translate="yes">
          <source>It is the first member in the enum and it has no initializer, in which case it&amp;rsquo;s assigned the value &lt;code&gt;0&lt;/code&gt;:</source>
          <target>これは列挙の最初のメンバであり、初期化子はありません。この場合、値&lt;code&gt;0&lt;/code&gt;が割り当てられます。</target>
        </trans-unit>
        <trans-unit id="1f0bcd520e9a01c5bb05819edfd82f1aa74077c5" translate="yes">
          <source>It is worth noting that if the npm package already includes its declaration file as described in &lt;a href="publishing"&gt;Publishing&lt;/a&gt;, downloading the corresponding &lt;code&gt;@types&lt;/code&gt; package is not needed.</source>
          <target>npmパッケージに&lt;a href="publishing"&gt;Publishing&lt;/a&gt;で説明されている宣言ファイルがすでに含まれている場合は、対応する&lt;code&gt;@types&lt;/code&gt;パッケージをダウンロードする必要はありません。</target>
        </trans-unit>
        <trans-unit id="cf377c6233f3ae5de354c35e343aab9bdd355017" translate="yes">
          <source>It just so happens that TypeScript has something called a &lt;em&gt;type guard&lt;/em&gt;. A type guard is some expression that performs a runtime check that guarantees the type in some scope.</source>
          <target>TypeScriptには&lt;em&gt;型ガード&lt;/em&gt;と呼ばれるものがある。 型ガードは、あるスコープの型を保証するランタイムチェックを実行する式です。</target>
        </trans-unit>
        <trans-unit id="63c224c58a227f7ca3d5c83c05a2c04331b2b180" translate="yes">
          <source>It was possible for the implementation files to import the test files</source>
          <target>実装ファイルがテストファイルをインポートすることができました。</target>
        </trans-unit>
        <trans-unit id="32c6f037d7103d04bf695eff504eb483c338105a" translate="yes">
          <source>It wasn&amp;rsquo;t possible to build &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; at the same time without having &lt;code&gt;src&lt;/code&gt; appear in the output folder name, which you probably don&amp;rsquo;t want</source>
          <target>&lt;code&gt;src&lt;/code&gt;が出力フォルダ名に表示されないように&lt;code&gt;test&lt;/code&gt;と&lt;code&gt;src&lt;/code&gt;を同時にビルドすることはできません。</target>
        </trans-unit>
        <trans-unit id="667e1bb482a8431e06e6a8a12a1197178dbf9155" translate="yes">
          <source>It&amp;acirc;&amp;euro;&amp;trade;s also common to try to access a method before &lt;code&gt;await&lt;/code&gt;-ing or &lt;code&gt;.then()&lt;/code&gt;-ing a &lt;code&gt;Promise&lt;/code&gt;. This is another example, among many others, where we&amp;acirc;&amp;euro;&amp;trade;re able to do better.</source>
          <target>&lt;code&gt;await&lt;/code&gt;-ingまたは&lt;code&gt;.then()&lt;/code&gt;-ing a&lt;code&gt;Promise&lt;/code&gt;の前にメソッドにアクセスしようとするのも、&amp;acirc;&amp;euro;&amp;trade;ではよくあることです。</target>
        </trans-unit>
        <trans-unit id="cb42ff8fbd52b3c44d6730e6b6e080e1b24c9119" translate="yes">
          <source>It&amp;rsquo;s also important to note that TypeScript doesn&amp;rsquo;t transform references to &lt;code&gt;globalThis&lt;/code&gt; when compiling to older versions of ECMAScript. As such, unless you&amp;rsquo;re targeting evergreen browsers (which already support &lt;code&gt;globalThis&lt;/code&gt;), you may want to &lt;a href="https://github.com/ljharb/globalThis"&gt;use an appropriate polyfill&lt;/a&gt; instead.</source>
          <target>また、古いバージョンのECMAScriptにコンパイルする場合、TypeScriptは&lt;code&gt;globalThis&lt;/code&gt;への参照を変換しないことに注意することも重要です。 そのため、(すでに&lt;code&gt;globalThis&lt;/code&gt;をサポートしている)エバーグリーンブラウザをターゲットにしていない限り、代わりに&lt;a href="https://github.com/ljharb/globalThis"&gt;適切なpolyfill&lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="e464e560c1d455645701c6f4e6f1a57f254a2a8d" translate="yes">
          <source>It&amp;rsquo;s always nice to be able to document your configuration! &lt;code&gt;tsconfig.json&lt;/code&gt; now accepts single and multi-line comments.</source>
          <target>構成をドキュメント化できるのは、常に便利です。 &lt;code&gt;tsconfig.json&lt;/code&gt;が1行または複数行のコメントを受け付けるようになりました。</target>
        </trans-unit>
        <trans-unit id="4bd81a3c45eee4646f38cdbd9c1c1ad1a29861b2" translate="yes">
          <source>It&amp;rsquo;s an error to destructure a tuple beyond the range of its elements:</source>
          <target>要素の範囲を超えてタプルを分解するとエラーになります:</target>
        </trans-unit>
        <trans-unit id="8a9920985b571f2cfef7325bc2d8544e7b54739d" translate="yes">
          <source>It&amp;rsquo;s important in this situation to not prepend at each reference, because you&amp;rsquo;ll end up with two copies of &lt;code&gt;A&lt;/code&gt; in the output of &lt;code&gt;D&lt;/code&gt; - this can lead to unexpected results.</source>
          <target>この状況では、各参照の前に&lt;code&gt;D&lt;/code&gt;の出力に&lt;code&gt;A&lt;/code&gt;の2つのコピーが含まれることになるため、各参照の前に&lt;code&gt;A&lt;/code&gt;を置かないことが重要です。これにより、予期しない結果が生じる可能性があります。</target>
        </trans-unit>
        <trans-unit id="97ea9b1bc3713a2cc3d96cf61a87c436f5f16077" translate="yes">
          <source>It&amp;rsquo;s important to note that awesome-typescript-loader will need to run before any other loader that deals with &lt;code&gt;.js&lt;/code&gt; files.</source>
          <target>素晴らしいタイプスクリプトローダは、&lt;code&gt;.js&lt;/code&gt;ファイルを扱う他のローダよりも先に実行する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ad109c65e3188cac84e48f320d15d4fae5d7f0a7" translate="yes">
          <source>It&amp;rsquo;s not uncommon for an API to expect a specific set of strings for certain values. For instance, consider a UI library that can move elements across the screen while controlling the &lt;a href="https://en.wikipedia.org/wiki/Inbetweening"&gt;&amp;ldquo;easing&amp;rdquo; of the animation.&lt;/a&gt;</source>
          <target>APIが特定の値に対して特定の文字列セットを期待することは珍しくありません。 たとえば、アニメーションの&lt;a href="https://en.wikipedia.org/wiki/Inbetweening"&gt;&amp;ldquo;easing&amp;rdquo;を制御しながら、画面上で要素を移動できるUIライブラリを考えてみてください。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1423913ba24c08e5752678ce9b4d9c6bc28a43a2" translate="yes">
          <source>It&amp;rsquo;s worth pointing out that the type checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type.</source>
          <target>型チェッカーでは、これらのプロパティがどのような順序であっても必要なわけではなく、インタフェースで必要なプロパティが存在し、必要な型を持つことだけが必要であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4dd80eea3f6c51bf5b9c13a8a47609bd55b30e0e" translate="yes">
          <source>Iterables</source>
          <target>反復可能</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes">
          <source>Iterators</source>
          <target state="translated">イテレータ</target>
        </trans-unit>
        <trans-unit id="27c4c72f6052a50d8720102918686080913f5e1c" translate="yes">
          <source>Iterators &amp; Generators</source>
          <target>イテレータとジェネレータ</target>
        </trans-unit>
        <trans-unit id="99b5cd227ff34de634e9717a978834aba820bbe5" translate="yes">
          <source>Iterators and Generators</source>
          <target>イテレータとジェネレータ</target>
        </trans-unit>
        <trans-unit id="36347e6c81d6767cb3d6230d14c1fc3fd3e5b4ee" translate="yes">
          <source>JQuery.d.ts</source>
          <target state="translated">JQuery.d.ts</target>
        </trans-unit>
        <trans-unit id="e3449392ff6bd7faf1750366c59ea9d2cae9f435" translate="yes">
          <source>JSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax to express optionality. e.g.:</source>
          <target>JSDoc注釈付き関数は、このルールから除外されます。 オプション性を表すには、JSDocオプションパラメータ構文を使用します。 例:</target>
        </trans-unit>
        <trans-unit id="a992571945b4a5c87d6bf56acece269e2c17f9ae" translate="yes">
          <source>JSDoc annotations adorning a declaration will be used to set the type of that declaration. For example:</source>
          <target>宣言を修飾するJSDocアノテーションは、その宣言のタイプを設定するために使用されます。 例:</target>
        </trans-unit>
        <trans-unit id="56567b264de0a6e662152c49ade304ca30e42a64" translate="yes">
          <source>JSDoc types are used for type information</source>
          <target>JSDoc型は型情報に使用されます</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="c9a7b3c3bca23e176771346061c84e126c239c19" translate="yes">
          <source>JSX allows you to embed expressions between tags by surrounding the expressions with curly braces (&lt;code&gt;{ }&lt;/code&gt;).</source>
          <target>JSXでは、式を中括弧(&lt;code&gt;{}&lt;/code&gt;)で囲むことによって、式をタグの間に埋め込むことができます。</target>
        </trans-unit>
        <trans-unit id="39068335c89e9baa8ee40bd585e128fbed44107c" translate="yes">
          <source>JSX element names and properties are validated against the &lt;code&gt;JSX&lt;/code&gt; namespace. Please see the [[JSX]] wiki page for defining the &lt;code&gt;JSX&lt;/code&gt; namespace for your framework.</source>
          <target>JSX要素の名前とプロパティは、&lt;code&gt;JSX&lt;/code&gt;名前空間に対して検証されます。 フレームワークの&lt;code&gt;JSX&lt;/code&gt;名前空間を定義するには、[[JSX]]wikiページを参照してください。</target>
        </trans-unit>
        <trans-unit id="c00129d0a4abfd5ac94250f0271eb16efd1bd3c7" translate="yes">
          <source>JSX elements now allow passing type arguments to generic components.</source>
          <target>JSX要素で、型引数を汎用コンポーネントに渡すことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="18de8f2d2e7d3ab6aeff186b905d5c34cc12e52a" translate="yes">
          <source>JSX is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, but the semantics of that transformation are implementation-specific. JSX came to popularity with the React library but has since seen other applications. TypeScript 1.6 supports embedding, type checking, and optionally compiling JSX directly into JavaScript.</source>
          <target>JSXは組み込み可能なXML風の構文です。 有効なJavaScriptに変換されることを意図していますが、その変換のセマンティクスは実装固有です。 JSXはReactライブラリで人気を得たが、それ以来他のアプリケーションもある。 TypeScript1.6は、埋め込み、型チェック、そしてオプションでJSXを直接JavaScriptにコンパイルすることをサポートする。</target>
        </trans-unit>
        <trans-unit id="35be1251a23e865870550e0bb93b3a161d7ed6f9" translate="yes">
          <source>JSX support</source>
          <target>(JSXサポート)</target>
        </trans-unit>
        <trans-unit id="96d35d103f80b8423a542d0896d9282bfecda177" translate="yes">
          <source>JSX type checking is driven by definitions in a JSX namespace, for instance &lt;code&gt;JSX.Element&lt;/code&gt; for the type of a JSX element, and &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; for built-in elements. Before TypeScript 2.8 the &lt;code&gt;JSX&lt;/code&gt; namespace was expected to be in the global namespace, and thus only allowing one to be defined in a project. Starting with TypeScript 2.8 the &lt;code&gt;JSX&lt;/code&gt; namespace will be looked under the &lt;code&gt;jsxNamespace&lt;/code&gt; (e.g. &lt;code&gt;React&lt;/code&gt;) allowing for multiple jsx factories in one compilation. For backward compatibility the global &lt;code&gt;JSX&lt;/code&gt; namespace is used as a fallback if none was defined on the factory function. Combined with the per-file &lt;code&gt;@jsx&lt;/code&gt; pragma, each file can have a different JSX factory.</source>
          <target>JSX型チェックは、JSX名前空間の定義によって駆動されます。たとえば、JSX要素の型には&lt;code&gt;JSX.Element&lt;/code&gt;、組み込み要素には&lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;があります。 TypeScript2.8より前のバージョンでは、&lt;code&gt;JSX&lt;/code&gt;名前空間はグローバル名前空間にあることが期待されていたため、プロジェクトで定義できるのは1つだけでした。 TypeScript2.8以降、&lt;code&gt;JSX&lt;/code&gt;名前空間は、&lt;code&gt;jsxNamespace&lt;/code&gt;(例えば、&lt;code&gt;React&lt;/code&gt;)の下で検索され、1つのコンパイルで複数のjsxファクトリーが可能になる。 後方互換性のために、ファクトリ関数にグローバル&lt;code&gt;JSX&lt;/code&gt;名前空間が定義されていない場合は、フォールバックとして使用されます。 ファイル単位の&lt;code&gt;@jsx&lt;/code&gt;プラグマと組み合わせることで、各ファイルに異なるJSXファクトリーを持たせることができます。</target>
        </trans-unit>
        <trans-unit id="5814b75aeb763bc1d09322412eaf957f2d26543e" translate="yes">
          <source>JavaScript has a lot of different module syntaxes or conventions: the one in the ECMAScript standard, the one Node already supports (CommonJS), AMD, System.js, and more! For the most part, TypeScript would default to auto-importing using ECMAScript module syntax, which was often inappropriate in certain TypeScript projects with different compiler settings, or in Node projects with plain JavaScript and &lt;code&gt;require&lt;/code&gt; calls.</source>
          <target>JavaScriptには、ECMAScript標準のもの、Nodeがすでに(CommonJS)、AMD、System.jsなどをサポートしているものなど、さまざまなモジュール構文や規約があります。 ほとんどの場合、TypeScriptはデフォルトでECMAScriptモジュール構文を使用して自動インポートするようになっていたが、これは、異なるコンパイラ設定を持つ特定のTypeScriptプロジェクトや、単純なJavaScriptと&lt;code&gt;require&lt;/code&gt;呼び出しを持つノードプロジェクトではしばしば不適切であった。</target>
        </trans-unit>
        <trans-unit id="6de0d5c33105af7de987fd16c4c5f05a9230e4fc" translate="yes">
          <source>JavaScript is inherently a very dynamic language. It&amp;rsquo;s not uncommon for a single JavaScript function to return different types of objects based on the shape of the arguments passed in.</source>
          <target>JavaScriptは本質的に非常に動的な言語です。 1つのJavaScript関数が、渡された引数の形状に基づいて異なるタイプのオブジェクトを返すことは珍しくありません。</target>
        </trans-unit>
        <trans-unit id="7196497deb2208abcd944f2734a4a8cd07bbe990" translate="yes">
          <source>Jspm</source>
          <target>Jspm</target>
        </trans-unit>
        <trans-unit id="a2fb0be4963908fbe076c5e18c4d463d46dfdc5e" translate="yes">
          <source>Just as &amp;ldquo;exporting near the top-level&amp;rdquo; reduces friction on your module&amp;rsquo;s consumers, so does introducing a default export. If a module&amp;rsquo;s primary purpose is to house one specific export, then you should consider exporting it as a default export. This makes both importing and actually using the import a little easier. For example:</source>
          <target>最上位の&amp;rdquo;の近くにある&amp;ldquo;エクスポートがモジュールのコンシューマの摩擦を減らすのと同じように、デフォルトのエクスポートを導入します。 モジュールの主な目的が1つの特定の書き出しを格納することである場合は、既定の書き出しとして書き出すことを検討してください。 これにより、インポートとインポートの実際の使用が少し簡単になります。 例:</target>
        </trans-unit>
        <trans-unit id="d035ba479610b88ab3f44fd6721d6d5b47bab897" translate="yes">
          <source>Just as in JavaScript, functions can refer to variables outside of the function body. When they do so, they&amp;rsquo;re said to &lt;em&gt;capture&lt;/em&gt; these variables. While understanding how this works (and the trade-offs when using this technique) is outside of the scope of this article, having a firm understanding how this mechanic works is an important piece of working with JavaScript and TypeScript.</source>
          <target>JavaScriptと同様に、関数は関数本体の外部の変数を参照できます。 その場合、&lt;em&gt;はこれらの変数を&lt;/em&gt;取得するように指示されます。 この仕組み(そしてこの手法を使用する場合のトレードオフ)を理解することはこの記事の範囲外ですが、この仕組みがどのように機能するかを確実に理解することは、JavaScriptとTypeScriptを扱う上で重要です。</target>
        </trans-unit>
        <trans-unit id="e42c4ea3c8c69c9835a8ffa699912e1dc17b476c" translate="yes">
          <source>Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it&amp;rsquo;s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can&amp;rsquo;t use the &lt;code&gt;outFile&lt;/code&gt; option while targeting &lt;code&gt;commonjs&lt;/code&gt; or &lt;code&gt;umd&lt;/code&gt;, but with TypeScript 1.8 and later, &lt;a href="release-notes/typescript-1-8#concatenate-amd-and-system-modules-with---outfile"&gt;it&amp;rsquo;s possible&lt;/a&gt; to use &lt;code&gt;outFile&lt;/code&gt; when targeting &lt;code&gt;amd&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;.</source>
          <target>JSファイルとモジュールの間に1対1の対応があるのと同じように、TypeScriptはモジュールのソースファイルとそれらのJSファイルの間に1対1の対応がある。 この結果、ターゲットのモジュールシステムによっては、複数のモジュールソースファイルを連結できないことがあります。 たとえば、&lt;code&gt;commonjs&lt;/code&gt;または&lt;code&gt;umd&lt;/code&gt;をターゲットにしているときに&lt;code&gt;outFile&lt;/code&gt;オプションを使用することはできませんが、TypeScript1.8以降では、&lt;code&gt;amd&lt;/code&gt;または&lt;code&gt;system&lt;/code&gt;をターゲットにしているときに&lt;a href="release-notes/typescript-1-8#concatenate amd and system modules with outfile"&gt;を使用することが&lt;/a&gt;可能です。</target>
        </trans-unit>
        <trans-unit id="f2ceed31b51e352f32e51cd21fbc2af5be43b412" translate="yes">
          <source>Just as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type.</source>
          <target>インターフェースの場合と同様に、型パラメーターをクラス自体に置くことで、クラスのすべてのプロパティーが同じ型で動作することを確認できます。</target>
        </trans-unit>
        <trans-unit id="3d37f6d0d224175d9c14bf98baa6ad7248f29798" translate="yes">
          <source>Just like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application.</source>
          <target>すべてのグローバル・ネームスペースの汚染と同様に、特に大規模なアプリケーションでは、コンポーネントの依存関係を特定することが困難になる場合があります。</target>
        </trans-unit>
        <trans-unit id="a2f08fadea784d51622be345d4e8e8eadd88d668" translate="yes">
          <source>Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:</source>
          <target>インターフェースと同様に、型別名も汎用的にすることができます。型パラメータを追加して、別名宣言の右側で使用するだけです。</target>
        </trans-unit>
        <trans-unit id="025c330d74702a4acd5017db2925ef6790f2b67b" translate="yes">
          <source>Just like namespaces, modules can contain both code and declarations. The main difference is that modules &lt;em&gt;declare&lt;/em&gt; their dependencies.</source>
          <target>名前空間と同様に、モジュールにはコードと宣言の両方を含めることができます。 主な違いは、モジュール&lt;em&gt;が依存関係を宣言することです。</target>
        </trans-unit>
        <trans-unit id="40539a34306df46457893cadb44a5176185146b1" translate="yes">
          <source>Just like strings, symbols can be used as keys for object properties.</source>
          <target>文字列と同様に、シンボルはオブジェクトプロパティのキーとして使用できます。</target>
        </trans-unit>
        <trans-unit id="accadaa2de1d9b54d08912507fc259d22f1d0931" translate="yes">
          <source>Just run:</source>
          <target>実行してください:</target>
        </trans-unit>
        <trans-unit id="125f418dffdfd3ad4877030138769ad27527fedf" translate="yes">
          <source>Keep in mind that &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; will be turned on along with other &lt;code&gt;--strict&lt;/code&gt; mode flags, which can impact your project. You can set the &lt;code&gt;strictPropertyInitialization&lt;/code&gt; setting to &lt;code&gt;false&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt;&amp;rsquo;s &lt;code&gt;compilerOptions&lt;/code&gt;, or &lt;code&gt;--strictPropertyInitialization false&lt;/code&gt; on the command line to turn off this checking.</source>
          <target>&lt;code&gt;--strictPropertyInitialization&lt;/code&gt;は、他の&lt;code&gt;--strict&lt;/code&gt;モードフラグと共に有効になり、プロジェクトに影響を与える可能性があることに注意してください。 このチェックをオフにするには、&lt;code&gt;tsconfig.json&lt;/code&gt;&amp;rsquo;s&lt;code&gt;compilerOptions&lt;/code&gt;の&lt;code&gt;strictPropertyInitialization&lt;/code&gt;設定を&lt;code&gt;false&lt;/code&gt;にするか、コマンドラインで&lt;code&gt;--strictPropertyInitialization false&lt;/code&gt;に設定します。</target>
        </trans-unit>
        <trans-unit id="0abfd4d342104dbd9ec0e7580639c9a4652da4fe" translate="yes">
          <source>Keep in mind that &lt;code&gt;?.&lt;/code&gt; acts differently than those &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operations since &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; will act specially on &amp;ldquo;falsy&amp;rdquo; values (e.g. the empty string, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt;, and, well, &lt;code&gt;false&lt;/code&gt;), but this is an intentional feature of the construct. It doesn&amp;rsquo;t short-circuit on valid data like &lt;code&gt;0&lt;/code&gt; or empty strings.</source>
          <target>&lt;code&gt;.&lt;/code&gt;は、&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;が&amp;ldquo;ファルシ&amp;rdquo;の値(空の文字列、&lt;code&gt;0&lt;/code&gt;、&lt;code&gt;NaN&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;など)に対して特別に作用するため、&lt;code&gt;.&lt;/code&gt;は&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;操作とは異なる動作をすることに注意してください。ただし、これは意図的な構成の機能です。 &lt;code&gt;0&lt;/code&gt;や空の文字列のような有効なデータを短絡しません。</target>
        </trans-unit>
        <trans-unit id="e08badd7e94b5e92e8e60fc455f43139d018f482" translate="yes">
          <source>Keep in mind that automatic inclusion is only important if you&amp;rsquo;re using files with global declarations (as opposed to files declared as modules). If you use an &lt;code&gt;import "foo"&lt;/code&gt; statement, for instance, TypeScript may still look through &lt;code&gt;node_modules&lt;/code&gt; &amp;amp; &lt;code&gt;node_modules/@types&lt;/code&gt; folders to find the &lt;code&gt;foo&lt;/code&gt; package.</source>
          <target>自動包含は、(モジュールとして宣言されたファイルではなく)グローバル宣言を持つファイルを使用する場合にのみ重要であることに注意してください。 たとえば、&lt;code&gt;import"foo"&lt;/code&gt;ステートメントを使用する場合、TypeScriptは&lt;code&gt;node_modules&lt;/code&gt;&amp;amp;&lt;code&gt;node_modules/@types&lt;/code&gt;フォルダを調べて&lt;code&gt;foo&lt;/code&gt;パッケージを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="268830906a0177b0c9a669ca7e3cb1faf3ef7c1b" translate="yes">
          <source>Keep in mind that for simple code like above, you probably shouldn&amp;rsquo;t be trying to &amp;ldquo;get around&amp;rdquo; these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs. That means if you&amp;rsquo;re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it&amp;rsquo;s okay to pass an object with both a &lt;code&gt;color&lt;/code&gt; or &lt;code&gt;colour&lt;/code&gt; property to &lt;code&gt;createSquare&lt;/code&gt;, you should fix up the definition of &lt;code&gt;SquareConfig&lt;/code&gt; to reflect that.</source>
          <target>上記のような単純なコードでは、これらのチェックを&amp;ldquo;get around&amp;rdquo;しようとするべきではないことに注意してください。 メソッドと保持状態を持つ、より複雑なオブジェクトリテラルの場合、これらのテクニックを念頭に置く必要があるかもしれませんが、実際には、過剰なプロパティエラーの大部分はバグです。 つまり、オプションバッグのようなもので過剰なプロパティチェックの問題に遭遇した場合、型宣言のいくつかを修正する必要があるかもしれません。 この場合、&lt;code&gt;color&lt;/code&gt;プロパティと&lt;code&gt;color&lt;/code&gt;プロパティの両方を持つオブジェクトを&lt;code&gt;createSquare&lt;/code&gt;に渡せるのであれば、&lt;code&gt;SquareConfig&lt;/code&gt;の定義を修正してそれを反映する必要があります。</target>
        </trans-unit>
        <trans-unit id="f6bddc5a736f8d59d17afc0337ba7f62d7baf26b" translate="yes">
          <source>Keep in mind that our support for async iterators relies on support for &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; to exist at runtime. You may need to polyfill &lt;code&gt;Symbol.asyncIterator&lt;/code&gt;, which for simple purposes can be as simple as: &lt;code&gt;(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for("Symbol.asyncIterator");&lt;/code&gt;</source>
          <target>非同期イテレーターのサポートは、実行時に存在する&lt;code&gt;Symbol.asyncIterator&lt;/code&gt;のサポートに依存していることに注意してください。 &lt;code&gt;Symbol.asyncIterator&lt;/code&gt;をポリフィルする必要がある場合があります。これは、次のように簡単に行うことができます。&lt;code&gt;(Symbol as any).asyncIterator=Symbol.asyncIterator Symbol.for("Symbol.asyncIterator");&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0ee6543e6ec698fd6b6185b09f38eac28c9b2e1" translate="yes">
          <source>Keep in mind that string enum members &lt;em&gt;do not&lt;/em&gt; get a reverse mapping generated at all.</source>
          <target>文字列のenumメンバ&lt;em&gt;は、リバースマッピングをまったく生成しないことに注意してください。&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="629873668f1873eae0d44964937115d6002d3f50" translate="yes">
          <source>Keep outdated console output in watch mode instead of clearing the screen</source>
          <target>画面をクリアする代わりに、古いコンソール出力を監視モードにする</target>
        </trans-unit>
        <trans-unit id="a22c16410dc4eafc94fbc317a11af2903d7b50a3" translate="yes">
          <source>Key Concepts</source>
          <target>主な概念</target>
        </trans-unit>
        <trans-unit id="eaf7e256a5a476287d569594d43c22027adc861c" translate="yes">
          <source>Lastly, we create a helper function that will do the mixing for us. This will run through the properties of each of the mixins and copy them over to the target of the mixins, filling out the stand-in properties with their implementations.</source>
          <target>最後に、ミキシングを行うヘルパー関数を作成します。 これにより、各ミックスインのプロパティが処理され、ミックスインのターゲットにコピーされ、代替のプロパティが実装で埋められます。</target>
        </trans-unit>
        <trans-unit id="0deb513412e10426cc0e13efd7af25f69b12a4e1" translate="yes">
          <source>Lay out the project</source>
          <target>プロジェクトをレイアウトする</target>
        </trans-unit>
        <trans-unit id="0fd2852022c2c1345c56213c485ff5c6c7b31b62" translate="yes">
          <source>Layout for compilations using &lt;code&gt;outFile&lt;/code&gt; is more flexible because relative paths don&amp;rsquo;t matter as much. One thing to keep in mind is that you&amp;rsquo;ll generally want to not use &lt;code&gt;prepend&lt;/code&gt; until the &amp;ldquo;last&amp;rdquo; project - this will improve build times and reduce the amount of I/O needed in any given build. The TypeScript repo itself is a good reference here - we have some &amp;ldquo;library&amp;rdquo; projects and some &amp;ldquo;endpoint&amp;rdquo; projects; &amp;ldquo;endpoint&amp;rdquo; projects are kept as small as possible and pull in only the libraries they need.</source>
          <target>&lt;code&gt;outFile&lt;/code&gt;を使用するコンパイルのレイアウトは、相対パスがそれほど重要ではないため、より柔軟です。 注意する点は、&amp;rsquo;は通常、&amp;ldquo;last&amp;rdquo;プロジェクトまで&lt;code&gt;prepend&lt;/code&gt;を使用しないことです。これにより、ビルド時間が短縮され、ビルドに必要なI/Oの量が削減されます。 ここでは、TypeScriptリポジトリ自体を参照してください。いくつかの&amp;ldquo;library&amp;rdquo;プロジェクトといくつかの&amp;ldquo;endpoint&amp;rdquo;プロジェクトがあります。&amp;ldquo;endpoint&amp;rdquo;プロジェクトはできるだけ小さくして、必要なライブラリだけをプルします。</target>
        </trans-unit>
        <trans-unit id="6bb28e55ee1d62a9d6d258deae5c6e572957f877" translate="yes">
          <source>Learning how to use &lt;code&gt;this&lt;/code&gt; in JavaScript is something of a rite of passage. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use &lt;code&gt;this&lt;/code&gt; and how to spot when it&amp;rsquo;s not being used correctly. Fortunately, TypeScript lets you catch incorrect uses of &lt;code&gt;this&lt;/code&gt; with a couple of techniques. If you need to learn how &lt;code&gt;this&lt;/code&gt; works in JavaScript, though, first read Yehuda Katz&amp;rsquo;s &lt;a href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/"&gt;Understanding JavaScript Function Invocation and &amp;ldquo;this&amp;rdquo;&lt;/a&gt;. Yehuda&amp;rsquo;s article explains the inner workings of &lt;code&gt;this&lt;/code&gt; very well, so we&amp;rsquo;ll just cover the basics here.</source>
          <target>JavaScriptで&lt;code&gt;this&lt;/code&gt;を使う方法を学ぶのは通過儀礼のようなものです。 TypeScriptはJavaScriptのスーパーセットなので、TypeScript開発者は&lt;code&gt;この&lt;/code&gt;を使う方法と、それが正しく使われていない時を見つける方法も学ぶ必要がある。 幸いなことに、TypeScriptではいくつかのテクニックを使って、&lt;code&gt;this&lt;/code&gt;の不正な使い方をキャッチすることができます。 ただし、&lt;code&gt;this&lt;/code&gt;がJavaScriptでどのように動作するかを知る必要がある場合は、まずYehuda Katz&amp;rsquo;s&lt;a href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/"&gt;Understanding JavaScript Function Invocation and&amp;ldquo;this&amp;rdquo;&lt;/a&gt;を参照してください。 Yehuda&amp;rsquo;の記事では、&lt;code&gt;this&lt;/code&gt;の内部の仕組みを非常にうまく説明しているので、ここでは基本的なことだけを説明します。</target>
        </trans-unit>
        <trans-unit id="d19ec9c75f791d8e76b8abbb3fa24159df758f91" translate="yes">
          <source>Let&amp;rsquo;s add a couple of interfaces to our example above, &lt;code&gt;Card&lt;/code&gt; and &lt;code&gt;Deck&lt;/code&gt;, to make the types clearer and easier to reuse:</source>
          <target>上の例に&lt;code&gt;Card&lt;/code&gt;と&lt;code&gt;Deck&lt;/code&gt;という2つのインタフェースを追加して、タイプを明確にして再利用しやすくします。</target>
        </trans-unit>
        <trans-unit id="0810e0790bb570bb542897e9f00f0ff27a268b73" translate="yes">
          <source>Let&amp;rsquo;s add types to our simple examples from earlier:</source>
          <target>以前の簡単な例に型を追加する:</target>
        </trans-unit>
        <trans-unit id="2fbda1714e2bf191061f156921ed8a14ecb815d5" translate="yes">
          <source>Let&amp;rsquo;s convert a simple class to use &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;. First, let&amp;rsquo;s start with an example without getters and setters.</source>
          <target>簡単なクラスを&lt;code&gt;get&lt;/code&gt;と&lt;code&gt;set&lt;/code&gt;を使用するように変換します。まず、getterとsetterのない例から始めます。</target>
        </trans-unit>
        <trans-unit id="71429700e5fe5c8713f8050f9d22fc5e71f408cf" translate="yes">
          <source>Let&amp;rsquo;s develop our sample further. Here we use an interface that describes objects that have a firstName and lastName field. In TypeScript, two types are compatible if their internal structure is compatible. This allows us to implement an interface just by having the shape the interface requires, without an explicit &lt;code&gt;implements&lt;/code&gt; clause.</source>
          <target>サンプルをさらに開発してみましょう。 ここでは、firstNameフィールドとlastNameフィールドを持つオブジェクトを記述するインタフェースを使用します。 TypeScriptでは、内部構造に互換性がある場合、2つの型に互換性があります。 これにより、明示的な&lt;code&gt;implements&lt;/code&gt;節を持たずに、インターフェースが必要とする形状を持つだけでインターフェースを実装することができます。</target>
        </trans-unit>
        <trans-unit id="65d0faf04337211735b15f8a5d34c2608e50c347" translate="yes">
          <source>Let&amp;rsquo;s get started by building a simple web application with TypeScript.</source>
          <target>TypeScriptを使って簡単なWebアプリケーションを構築することから始めましょう。</target>
        </trans-unit>
        <trans-unit id="b1e0b8ac0a49ba6917defbab6438fe121a7b57d4" translate="yes">
          <source>Let&amp;rsquo;s go back and write the code for the version of &lt;code&gt;padLeft&lt;/code&gt; that uses union types. We could write it with type predicates as follows:</source>
          <target>ユニオン型を使用する&lt;code&gt;padLeft&lt;/code&gt;のバージョンのコードを作成します。 次のようにタイプ述部を使用して記述できます。</target>
        </trans-unit>
        <trans-unit id="a370033b626aeaa4b56b2ffa2c9b364f90cf9047" translate="yes">
          <source>Let&amp;rsquo;s look at a fairly normal program and see how project references can help us better organize it. Imagine you have a project with two modules, &lt;code&gt;converter&lt;/code&gt; and &lt;code&gt;units&lt;/code&gt;, and a corresponding test file for each:</source>
          <target>&amp;rsquo;sはごく普通のプログラムを見て、プロジェクトリファレンスがどのようにしてプログラムの編成に役立つかを見てみましょう。 &lt;code&gt;converter&lt;/code&gt;と&lt;code&gt;units&lt;/code&gt;の2つのモジュールを持つプロジェクトがあり、それぞれに対応するテストファイルがあるとします。</target>
        </trans-unit>
        <trans-unit id="f36707930dcd360fc642c46ec4865e86294c552d" translate="yes">
          <source>Let&amp;rsquo;s look at an example to better see how this plays out in practice:</source>
          <target>これが実際にどのように実行されるかを確認するために、の例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="d172a231ad56188812168291eea6a5fd8742b6b4" translate="yes">
          <source>Let&amp;rsquo;s look at an example:</source>
          <target>例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="eeeed955a225d9a00620ccdff1e785a00b797db0" translate="yes">
          <source>Let&amp;rsquo;s modify the example a bit to show this difference:</source>
          <target>この違いを表示するには、例を少し修正します。</target>
        </trans-unit>
        <trans-unit id="b02e9aea645d47e4e6bf161ee47aada331ae51db" translate="yes">
          <source>Let&amp;rsquo;s now add React and React-DOM, along with their declaration files, as dependencies to your &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target>&amp;rsquo;sは、ReactとReact DOMを宣言ファイルと共に&lt;code&gt;package.json&lt;/code&gt;ファイルへの依存関係として追加します。</target>
        </trans-unit>
        <trans-unit id="83704a6507b28f550a9354f7a8254f0aa3c131e5" translate="yes">
          <source>Let&amp;rsquo;s now look at a more complex example.</source>
          <target>では、さらに複雑な例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="014bde7411db7919604626e4a814bd5fe5d15eef" translate="yes">
          <source>Let&amp;rsquo;s say that we&amp;rsquo;ve actually intended this function to work on arrays of &lt;code&gt;T&lt;/code&gt; rather than &lt;code&gt;T&lt;/code&gt; directly. Since we&amp;rsquo;re working with arrays, the &lt;code&gt;.length&lt;/code&gt; member should be available. We can describe this just like we would create arrays of other types:</source>
          <target>この関数は、&lt;code&gt;T&lt;/code&gt;を直接処理するのではなく、&lt;code&gt;T&lt;/code&gt;の配列を処理することを意図したものであると言えます。 配列を操作しているので、&lt;code&gt;.length&lt;/code&gt;メンバが使用可能である必要があります。 これは、他の型の配列を作成する場合と同じように記述できます。</target>
        </trans-unit>
        <trans-unit id="0afa8a2c9e9ae086ac85d8e4851a50d094dc340f" translate="yes">
          <source>Let&amp;rsquo;s say we have a sample application that uses the &lt;code&gt;typescript&lt;/code&gt; module. &lt;code&gt;app.ts&lt;/code&gt; has an import like &lt;code&gt;import * as ts from "typescript"&lt;/code&gt;.</source>
          <target>&lt;code&gt;typescript&lt;/code&gt;モジュールを使用するサンプルアプリケーションがあるとします。 &lt;code&gt;app.ts&lt;/code&gt;には、&lt;code&gt;import*as ts from"typescript"&lt;/code&gt;のようなインポートがあります。</target>
        </trans-unit>
        <trans-unit id="b98ecb1cac8b86219be2530212acfb40004f6c82" translate="yes">
          <source>Let&amp;rsquo;s say we wrote a module file &lt;code&gt;foo.d.ts&lt;/code&gt;:</source>
          <target>モジュールファイル&lt;code&gt;foo.d.ts&lt;/code&gt;を作成したとします。</target>
        </trans-unit>
        <trans-unit id="bf265138b3f25556fefa76ca3b0b12725b0f86b1" translate="yes">
          <source>Let&amp;rsquo;s scaffold this out:</source>
          <target>の足場を外す:</target>
        </trans-unit>
        <trans-unit id="aa591bb3c4e18fed63fab3f054ebcf47625b721d" translate="yes">
          <source>Let&amp;rsquo;s see how this can be used.</source>
          <target>これをどのように使用できるかを確認します。</target>
        </trans-unit>
        <trans-unit id="a2d4ab99ed2cfcd0bf4a97a7f9d646bc565fffa9" translate="yes">
          <source>Let&amp;rsquo;s start out with a new directory. We&amp;rsquo;ll name it &lt;code&gt;proj&lt;/code&gt; for now, but you can change it to whatever you want.</source>
          <target>新しいディレクトリから開始します。 ここでは&lt;code&gt;proj&lt;/code&gt;という名前を付けますが、必要に応じて変更できます。</target>
        </trans-unit>
        <trans-unit id="55bbd8a0f85bfbe95c8b7cb6332b5825ff504f0e" translate="yes">
          <source>Let&amp;rsquo;s start with the program we&amp;rsquo;ll be using as our example throughout this page. We&amp;rsquo;ve written a small set of simplistic string validators, as you might write to check a user&amp;rsquo;s input on a form in a webpage or check the format of an externally-provided data file.</source>
          <target>このページで例として使用するプログラムから始めましょう。 Webページのフォームでユーザの入力をチェックしたり、外部から提供されたデータファイルの形式をチェックするために書くことができるように、簡単な文字列バリデータの小さなセットを書きました。</target>
        </trans-unit>
        <trans-unit id="bf10a2b8087f57e53feead64793d541595e6996c" translate="yes">
          <source>Let&amp;rsquo;s take a look at a simple class-based example:</source>
          <target>簡単なクラスベースの例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="3484d66cbe4a02744097aac7ef40e2f056cef65a" translate="yes">
          <source>Let&amp;rsquo;s take a look at an example:</source>
          <target>例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="b54485584eecf2901825f4b3995651a7e60470f5" translate="yes">
          <source>Let&amp;rsquo;s take a look at the simplest mapped type and its parts:</source>
          <target>マップされた最も単純なタイプとそのパーツを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="388956de0f4c78ed65b63c815c68a779d593b807" translate="yes">
          <source>Let&amp;rsquo;s take a minute to consider what that means. &lt;code&gt;setTimeout&lt;/code&gt; will run a function after some number of milliseconds, &lt;em&gt;but only&lt;/em&gt; after the &lt;code&gt;for&lt;/code&gt; loop has stopped executing; By the time the &lt;code&gt;for&lt;/code&gt; loop has stopped executing, the value of &lt;code&gt;i&lt;/code&gt; is &lt;code&gt;10&lt;/code&gt;. So each time the given function gets called, it will print out &lt;code&gt;10&lt;/code&gt;!</source>
          <target>&amp;rsquo;sは、その意味を少し考えてみましょう。 &lt;code&gt;setTimeout&lt;/code&gt;は、&lt;code&gt;for&lt;/code&gt;ループの実行が停止した後、&lt;em&gt;ではあるが&lt;/em&gt;のミリ秒後にのみ関数を実行する。 &lt;code&gt;for&lt;/code&gt;ループの実行が停止するまでに、&lt;code&gt;i&lt;/code&gt;の値は&lt;code&gt;10&lt;/code&gt;であるため、指定された関数が呼び出されるたびに&lt;code&gt;10&lt;/code&gt;が出力されます。</target>
        </trans-unit>
        <trans-unit id="309b7fe3def1ff082c552cb81229fe971bbfb8b9" translate="yes">
          <source>Let&amp;rsquo;s take our &lt;code&gt;identity&lt;/code&gt; function from earlier:</source>
          <target>以前の&lt;code&gt;identity&lt;/code&gt;関数を使用する:</target>
        </trans-unit>
        <trans-unit id="c819787bed8495ecea9cfe18f716371127e40d52" translate="yes">
          <source>Let&amp;rsquo;s write a Hello World program. In &lt;code&gt;src&lt;/code&gt;, create the file &lt;code&gt;main.ts&lt;/code&gt;:</source>
          <target>のHello Worldプログラムを作成します。 &lt;code&gt;src&lt;/code&gt;で、&lt;code&gt;main.ts&lt;/code&gt;ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="4f861095293696b450d02c85427a11313836cd45" translate="yes">
          <source>Let&amp;rsquo;s write our first TypeScript file using React. First, create a file named &lt;code&gt;Hello.tsx&lt;/code&gt; in &lt;code&gt;src/components&lt;/code&gt; and write the following:</source>
          <target>Reactを使って最初のTypeScriptファイルを作成します。 まず、&lt;code&gt;src/components&lt;/code&gt;内に&lt;code&gt;Hello.tsx&lt;/code&gt;という名前のファイルを作成し、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="166644bb8752dfdaa61026de73139cfde0a4a540" translate="yes">
          <source>LettersOnlyValidator.ts</source>
          <target>LettersOnlyValidator.ts</target>
        </trans-unit>
        <trans-unit id="875c3c9135ee949f84870492409833fc57642b20" translate="yes">
          <source>Libraries can also use &lt;code&gt;this&lt;/code&gt; parameters to declare how callbacks will be invoked.</source>
          <target>ライブラリは、&lt;code&gt;この&lt;/code&gt;パラメータを使用して、コールバックの呼び出し方法を宣言することもできます。</target>
        </trans-unit>
        <trans-unit id="7c8d68bdf290b3650035c5dab105050f96236c14" translate="yes">
          <source>Library Structures</source>
          <target>ライブラリ構造</target>
        </trans-unit>
        <trans-unit id="4e958d206e87dee6202602f12cba1d07ddc64591" translate="yes">
          <source>Library Structures: Consuming Dependencies</source>
          <target>ライブラリ構造: 依存関係の使用</target>
        </trans-unit>
        <trans-unit id="b96d274e68825ffb1cf50ff3a8842c7507fb9c61" translate="yes">
          <source>Library Structures: Dependencies on Global Libraries</source>
          <target>ライブラリ構造: グローバルライブラリへの依存関係</target>
        </trans-unit>
        <trans-unit id="c7d79eff0a64c91827b34425186a057bf7eefed6" translate="yes">
          <source>Library Structures: Dependencies on Modules</source>
          <target>ライブラリ構造: モジュールへの依存関係</target>
        </trans-unit>
        <trans-unit id="0e5b4340018e06cc22410c43d8c05671e353f758" translate="yes">
          <source>Library Structures: Dependencies on UMD libraries</source>
          <target>ライブラリ構造: UMDライブラリへの依存関係</target>
        </trans-unit>
        <trans-unit id="25679ea328e38a91aa99fd34521cab5334cfc5f6" translate="yes">
          <source>Library Structures: Global Libraries</source>
          <target>ライブラリ構造: グローバルライブラリ</target>
        </trans-unit>
        <trans-unit id="583896dcdb93f9cebf804f97f952c1047d1b09e6" translate="yes">
          <source>Library Structures: Global Plugin</source>
          <target>ライブラリ構造: グローバルプラグイン</target>
        </trans-unit>
        <trans-unit id="46852e3e51c98d1fbda888c84f0fd0b001bb9a75" translate="yes">
          <source>Library Structures: Global-modifying Modules</source>
          <target>ライブラリ構造: グローバル修正モジュール</target>
        </trans-unit>
        <trans-unit id="38fb731884bc1a45c091fe53bb4f59beacc5c010" translate="yes">
          <source>Library Structures: Identifying Kinds of Libraries</source>
          <target>ライブラリ構造: ライブラリの種類の識別</target>
        </trans-unit>
        <trans-unit id="dd13ad9cf324101c470f4a966d00d41d7ab63505" translate="yes">
          <source>Library Structures: Library file layout</source>
          <target>ライブラリ構造:ライブラリファイルレイアウト</target>
        </trans-unit>
        <trans-unit id="c83378208463304e24be07d77ddfa86166dca09e" translate="yes">
          <source>Library Structures: Modular Libraries</source>
          <target>ライブラリ構造:モジュールライブラリ</target>
        </trans-unit>
        <trans-unit id="1fe937767fb28d22ee73b66129f61b0fe7d8aa7e" translate="yes">
          <source>Library Structures: Module Plugin or UMD Plugin</source>
          <target>ライブラリ構造:モジュールプラグインまたはUMDプラグイン</target>
        </trans-unit>
        <trans-unit id="4f845580b5f18381f6fa82c3be48352cc4e140d3" translate="yes">
          <source>Library Structures: Preventing Name Conflicts</source>
          <target>ライブラリ構造: 名前の競合の防止</target>
        </trans-unit>
        <trans-unit id="f1c767319c72858af7a6896ba4967b323b7a1717" translate="yes">
          <source>Library Structures: The Impact of ES6 on Module Plugins</source>
          <target>ライブラリ構造: ES6がモジュールプラグインに与える影響</target>
        </trans-unit>
        <trans-unit id="c4c82656844e89a1600df1de5a6196522c148102" translate="yes">
          <source>Library Structures: UMD</source>
          <target>ライブラリ構造:UMD</target>
        </trans-unit>
        <trans-unit id="b914f6929708a78f5ebc7f6182f8d6dadfdf5520" translate="yes">
          <source>Library file layout</source>
          <target>ライブラリファイルのレイアウト</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target>Apacheライセンスバージョン2.0の下でライセンスされています。</target>
        </trans-unit>
        <trans-unit id="614020e4b48ba41cbc8feb6a827a9777cf491e2e" translate="yes">
          <source>Like array destructuring, you can have assignment without declaration:</source>
          <target>array destructuringと同様に、代入は宣言なしで行うことができます。</target>
        </trans-unit>
        <trans-unit id="8179c422e4946b3006e7ce0d9f1b27008179e0fd" translate="yes">
          <source>Like classes, interfaces can extend each other. This allows you to copy the members of one interface into another, which gives you more flexibility in how you separate your interfaces into reusable components.</source>
          <target>クラスと同様に、インタフェースは相互に拡張できます。 これにより、あるインタフェースのメンバーを別のインタフェースにコピーできるため、インタフェースを再利用可能なコンポーネントに分割する方法をより柔軟にすることができます。</target>
        </trans-unit>
        <trans-unit id="e100fe20d9c089d3990a58c235d7844235322341" translate="yes">
          <source>Like other special JS checking behaviors, this behavior can be changed by specifying a JSDoc type for the variable. For example:</source>
          <target>他の特殊なJSチェック動作と同様に、この動作は変数にJSDoc型を指定することで変更できます。 例:</target>
        </trans-unit>
        <trans-unit id="991d21c5bdd231b177d8dbce4a5a58935deb5866" translate="yes">
          <source>Like we mentioned, it&amp;rsquo;s not unexpected to get error messages after conversion. The important thing is to actually go one by one through these and decide how to deal with the errors. Often these will be legitimate bugs, but sometimes you&amp;rsquo;ll have to explain what you&amp;rsquo;re trying to do a little better to TypeScript.</source>
          <target>前述したように、変換後にエラーメッセージが表示されることもあります。 重要なのは、これらを一つ一つ実行して、エラーの処理方法を決めることです。 多くの場合、これらは正当なバグですが、時にはあなたがTypeScriptに対して何をしようとしているのかを説明する必要があります。</target>
        </trans-unit>
        <trans-unit id="ad22df7237ec893f071e3a632c74d36af489349a" translate="yes">
          <source>Likewise, for the return type of a function:</source>
          <target>同様に、関数の戻り値の型は次のようになります。</target>
        </trans-unit>
        <trans-unit id="bbb07555ce6ca44b59035a2a319034782de9f8d0" translate="yes">
          <source>Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:</source>
          <target>同様に、反バリアント位置にある同じタイプ変数の複数の候補によって、交差タイプが推定されます。</target>
        </trans-unit>
        <trans-unit id="5359c0166343c48f9f035c401a1a6fd47a5d3c30" translate="yes">
          <source>List of</source>
          <target>リスト</target>
        </trans-unit>
        <trans-unit id="465c88588b5cdd41299c2edcb1468c48ae202ec0" translate="yes">
          <source>List of folders to include type definitions from. See &lt;a href="tsconfig-json#types-typeroots-and-types"&gt;@types, &amp;ndash;typeRoots and &amp;ndash;types&lt;/a&gt; for more details.</source>
          <target>タイプ定義を含めるフォルダのリスト。 詳細については、&lt;a href="tsconfig json#typesティピリッツand types"&gt;@types,&amp;ndash;typeRootsと&amp;ndash;types&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6ced5dd028928de0448e70e83b68d98333283e39" translate="yes">
          <source>List of library files to be included in the compilation.</source>
          <target>コンパイルに含まれるライブラリファイルのリスト。</target>
        </trans-unit>
        <trans-unit id="bcb7afa9aa95b8c02629a8477085e1d618f28bc0" translate="yes">
          <source>List of names of type definitions to include. See &lt;a href="tsconfig-json#types-typeroots-and-types"&gt;@types, &amp;ndash;typeRoots and &amp;ndash;types&lt;/a&gt; for more details.</source>
          <target>含めるタイプ定義の名前のリスト。詳細については、&lt;a href="tsconfig json#typesティピリッツand types"&gt;@types,&amp;ndash;typeRoots and&amp;ndash;types&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="653b9b02be1c90476a3ad618b040891655bf5f51" translate="yes">
          <source>List of path mapping entries for module names to locations relative to the &lt;code&gt;baseUrl&lt;/code&gt;. See &lt;a href="module-resolution#path-mapping"&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target>&lt;code&gt;baseUrl&lt;/code&gt;に相対的な場所へのモジュール名のパスマッピングエントリの一覧。詳細については、&lt;a href="module resolution#path-mapping"&gt;モジュール解決のドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bb25bc49f0293214d4dc209e4fc9026643313119" translate="yes">
          <source>Literal type widening can be controlled through explicit type annotations. Specifically, when an expression of a literal type is inferred for a const location without a type annotation, that &lt;code&gt;const&lt;/code&gt; variable gets a widening literal type inferred. But when a &lt;code&gt;const&lt;/code&gt; location has an explicit literal type annotation, the &lt;code&gt;const&lt;/code&gt; variable gets a non-widening literal type.</source>
          <target>リテラル型の拡大は、明示的な型注釈によって制御できます。 具体的には、リテラル型の式が型注釈のないconst位置に対して推論される場合、&lt;code&gt;const&lt;/code&gt;変数は推論される拡張リテラル型を取得する。 しかし、&lt;code&gt;const&lt;/code&gt;位置に明示的なリテラル型注釈がある場合、&lt;code&gt;const&lt;/code&gt;変数は非拡張リテラル型を取得します。</target>
        </trans-unit>
        <trans-unit id="e7a432de388d59eb0330d3d1bf7924a86dc9fda9" translate="yes">
          <source>Loading of types from npm packages</source>
          <target>npmパッケージからのタイプのロード</target>
        </trans-unit>
        <trans-unit id="7e4fa40194fa1599fc6410e0f480c52786bb6b60" translate="yes">
          <source>Local and Imported Type Declarations Now Conflict</source>
          <target>ローカル型宣言とインポート型宣言が競合する</target>
        </trans-unit>
        <trans-unit id="dc901218db3c05e3ca7a85bfcded3b7a52e18ec2" translate="yes">
          <source>Local class, interface, enum, and type alias declarations can now appear inside function declarations. Local types are block scoped, similar to variables declared with &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. For example:</source>
          <target>ローカルクラス、インタフェース、列挙型、および型エイリアス宣言を関数宣言内に表示できるようになりました。 ローカル型はブロック範囲で、&lt;code&gt;let&lt;/code&gt;および&lt;code&gt;const&lt;/code&gt;で宣言された変数と同様です。例:</target>
        </trans-unit>
        <trans-unit id="d28868f17a046f8c9d0605670df6ffd291397586" translate="yes">
          <source>Local type declarations</source>
          <target>ローカル型宣言</target>
        </trans-unit>
        <trans-unit id="25ce31967aab4a48e0accd8ada4e9c79a67d8e96" translate="yes">
          <source>Local types may reference enclosing type parameters and local class and interfaces may themselves be generic. For example:</source>
          <target>ローカル型は、包含型パラメータとローカルクラスを参照し、インタフェースはそれ自体が汎用である場合があります。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="d54f7840dd15f9efca1a3c2a835dba90f27406bb" translate="yes">
          <source>Localized diagnostics on the command line</source>
          <target>コマンドラインのローカライズされた診断</target>
        </trans-unit>
        <trans-unit id="dbc698b0052336839927b67e68ee8b808258468a" translate="yes">
          <source>Locally scoped JSX namespaces</source>
          <target>ローカル・スコープのJSX名前空間</target>
        </trans-unit>
        <trans-unit id="f34ec36309212ab4f733a475011c562c23d0e729" translate="yes">
          <source>Log.ts</source>
          <target state="translated">Log.ts</target>
        </trans-unit>
        <trans-unit id="57f54137157041b8ae56134eceada37f0aaf7daf" translate="yes">
          <source>Look in the first localhost folder, then scripts/app.ts</source>
          <target>最初のlocalhostフォルダを探し、次にscripts/app.tsを探します。</target>
        </trans-unit>
        <trans-unit id="8fdfcce162943820f24951cb2a2e053a7c7c3ec0" translate="yes">
          <source>Look in your &lt;code&gt;C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets&lt;/code&gt; file. The authoritative mappings between MSBuild XML tags and &lt;code&gt;tsc&lt;/code&gt; compiler options live in there.</source>
          <target>&lt;code&gt;C:\Program Files(x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets&lt;/code&gt;ファイルを探します。 MSBuild XMLタグと&lt;code&gt;tsc&lt;/code&gt;コンパイラオプション間のオーソリテイティブなマッピングは、この中に存在する。</target>
        </trans-unit>
        <trans-unit id="a6b0fb8ef6778ed02a7ae1ae513bbf8d954f0a94" translate="yes">
          <source>MSBuild</source>
          <target state="translated">MSBuild</target>
        </trans-unit>
        <trans-unit id="2e00dde89c6a5b86d9cb21be7fbf224d7c22deec" translate="yes">
          <source>MSBuild Property Name</source>
          <target>MSBuildプロパティ名</target>
        </trans-unit>
        <trans-unit id="528349fad89f8e558db9d5dd9f001d6ed4aceabc" translate="yes">
          <source>Make sure that the modules work by running &lt;code&gt;gulp&lt;/code&gt; and then testing in Node:</source>
          <target>&lt;code&gt;glp&lt;/code&gt;を実行してモジュールが動作することを確認してから、Node:</target>
        </trans-unit>
        <trans-unit id="06adecb648f1663461f793b6ad17375e5c241d45" translate="yes">
          <source>Make sure to revisit the &lt;a href="library-structures#consuming-dependencies"&gt;Consuming dependencies&lt;/a&gt; section for more information.</source>
          <target>詳細については、&lt;a href="library structures#consuming dependencies"&gt;Consuming dependencies&lt;/a&gt;のセクションを再度参照してください。</target>
        </trans-unit>
        <trans-unit id="8dc73c8a520471a285c4dd9769e30a805d1f4ca3" translate="yes">
          <source>Many JavaScript developers are intimately familiar with this behavior, but if you&amp;rsquo;re surprised, you&amp;rsquo;re certainly not alone. Most people expect the output to be</source>
          <target>多くのJavaScript開発者はこの動作に精通していますが、もしあなたが驚いているのであれば、あなただけではありません。 ほとんどの人は</target>
        </trans-unit>
        <trans-unit id="fe4a673619fce4477eac837da092bcc0b04ae5cf" translate="yes">
          <source>Many bundlers have support for automatically splitting output bundles based on these &lt;code&gt;import&lt;/code&gt; expressions, so consider using this new feature with the &lt;code&gt;esnext&lt;/code&gt; module target.</source>
          <target>多くのバンドルは、これらの&lt;code&gt;import&lt;/code&gt;式に基づいて出力バンドルを自動的に分割する機能をサポートしています。そのため、&lt;code&gt;esnext&lt;/code&gt;モジュールターゲットでこの新機能を使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="584c646b07ca217d5f7c1b61637d077ae1a5e971" translate="yes">
          <source>Many common mistakes in declaration files can be easily avoided. The &lt;a href="do-s-and-don-ts"&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt; section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.</source>
          <target>宣言ファイルによくある間違いの多くは簡単に避けられます。 「&lt;a href="do s and don ts"&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt;」セクションでは、一般的なエラーを識別し、その検出方法と修正方法について説明します。 誰もがこのセクションを読んで、よくある間違いを避けるようにしてください。</target>
        </trans-unit>
        <trans-unit id="eb06e5cbf12cdc30df47507b636fcce479ba328c" translate="yes">
          <source>Many popular Node.js libraries are in the module family, such as &lt;a href="http://expressjs.com/"&gt;&lt;code&gt;express&lt;/code&gt;&lt;/a&gt;, &lt;a href="http://gulpjs.com/"&gt;&lt;code&gt;gulp&lt;/code&gt;&lt;/a&gt;, and &lt;a href="https://github.com/request/request"&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;.</source>
          <target>モジュールファミリには、&lt;a href="http://expressjs.com/"&gt;&lt;code&gt;express&lt;/code&gt;&lt;/a&gt;、&lt;a href="http://gulpjs.com/"&gt;&lt;code&gt;gulp&lt;/code&gt;&lt;/a&gt;、&lt;a href="https://github.com/request/request"&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;など、多くの一般的なNode.jsライブラリがあります。</target>
        </trans-unit>
        <trans-unit id="63a6f8dd928db9783606b9b55a4d1e30673d97c7" translate="yes">
          <source>Many popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:</source>
          <target>Expressなどの多くの一般的なライブラリは、インポート時に呼び出し可能な関数として公開されます。 たとえば、Expressの一般的な使用方法は次のようになります。</target>
        </trans-unit>
        <trans-unit id="c6113dbcfc0c046c2e863aac93003dd4c0388bee" translate="yes">
          <source>Many times, we are faced with writing a declaration file when we only have examples of the underlying library to guide us. The &lt;a href="by-example"&gt;By Example&lt;/a&gt; section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.</source>
          <target>多くの場合、基礎となるライブラリーの例しかないときには、宣言ファイルを作成する必要があります。 「&lt;a href="by-example"&gt;By Example&lt;/a&gt;」セクションには、多くの一般的なAPIパターンと、それぞれに宣言を記述する方法が示されています。 このガイドは、TypeScriptの初心者で、まだTypeScriptのすべての言語構造に精通していない人を対象としています。</target>
        </trans-unit>
        <trans-unit id="b39eaaa138d38f75f9ba15b0ecb54217b1f43d1d" translate="yes">
          <source>Mapped Types</source>
          <target>マップされたタイプ</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes">
          <source>Mapped types</source>
          <target>マップされたタイプ</target>
        </trans-unit>
        <trans-unit id="150ac025be99fedc0936df23f699d5432059212b" translate="yes">
          <source>Mapped types are produced by taking a union of literal types, and computing a set of properties for a new object type. They&amp;rsquo;re like &lt;a href="https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions"&gt;list comprehensions in Python&lt;/a&gt;, but instead of producing new elements in a list, they produce new properties in a type.</source>
          <target>マップされた型は、リテラル型の結合を取得し、新しいオブジェクト型のプロパティのセットを計算することによって生成されます。 &amp;rsquo;re like&lt;a href="https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions"&gt;list comprehations in Python&lt;/a&gt;ですが、リストに新しい要素を生成する代わりに、型に新しいプロパティを生成します。</target>
        </trans-unit>
        <trans-unit id="347c61475a676c2faf7ddbe772ebae4b5d598063" translate="yes">
          <source>Mapped types on tuples and arrays</source>
          <target>タプルと配列のマップされた型</target>
        </trans-unit>
        <trans-unit id="8e8a7963f001150e8ed8e3c1be77a5be18c61c35" translate="yes">
          <source>Mapped types support adding a &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; modifier to a mapped property, but they did not provide support the ability to &lt;em&gt;remove&lt;/em&gt; modifiers. This matters in &lt;a href="https://github.com/Microsoft/TypeScript/pull/12563"&gt;&lt;em&gt;homomorphic mapped types&lt;/em&gt;&lt;/a&gt; which by default preserve the modifiers of the underlying type.</source>
          <target>マップされた型は、マップされたプロパティへの&lt;code&gt;readonly&lt;/code&gt;または&lt;code&gt;?&lt;/code&gt;修飾子の追加をサポートしますが、&lt;em&gt;remove&lt;/em&gt;修飾子をサポートしていません。 これは、&lt;a href="https://github.com/Microsoft/TypeScript/pull/12563"&gt;&lt;em&gt;準同形写像型&lt;/em&gt;&lt;/a&gt;で重要であり、これはデフォルトで基底型の修飾子を保持する。</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes">
          <source>Mappings</source>
          <target>マッピング</target>
        </trans-unit>
        <trans-unit id="76afa4572a785cbf8909d66ab1eaf36ef69ba191" translate="yes">
          <source>Matching behavior</source>
          <target>一致動作</target>
        </trans-unit>
        <trans-unit id="d61fb1c71d97cf23364513b6c042480baf71317b" translate="yes">
          <source>Maybe it was easy to spot out for some, but the inner &lt;code&gt;for&lt;/code&gt;-loop will accidentally overwrite the variable &lt;code&gt;i&lt;/code&gt; because &lt;code&gt;i&lt;/code&gt; refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.</source>
          <target>&lt;code&gt;i&lt;/code&gt;が同じ関数スコープ変数を参照しているため、&lt;/code&gt;-ループの内側の&lt;code&gt;が変数&lt;code&gt;i&lt;/code&gt;を誤って上書きすることがあるかもしれません。 経験を積んだ開発者が今までに知っているように、似たような種類のバグがコード・レビューをすり抜けて、無限のフラストレーションの源になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="d8e319d394c7e9ed6ef1448bbdf219ff4e98198e" translate="yes">
          <source>Merging Interfaces</source>
          <target>インタフェースのマージ</target>
        </trans-unit>
        <trans-unit id="87557ad474b3ea1cb7dc79b4a0a69cc3c542648b" translate="yes">
          <source>Merging Namespaces</source>
          <target state="translated">名前空間のマージ</target>
        </trans-unit>
        <trans-unit id="d457feda7cc53bf9cc76dc59489863c6ef6d30dd" translate="yes">
          <source>Merging Namespaces with Classes</source>
          <target>名前空間とクラスのマージ</target>
        </trans-unit>
        <trans-unit id="78529d067c66e125c411afd44c6c212aea17fa3a" translate="yes">
          <source>Merging Namespaces with Classes, Functions, and Enums</source>
          <target>名前空間をクラス、関数、列挙型とマージする</target>
        </trans-unit>
        <trans-unit id="91bb6095ae597def81503d12e83651b39c84f4ab" translate="yes">
          <source>Merging ambient class and interface declaration</source>
          <target>アンビエントクラスとインタフェース宣言のマージ</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes">
          <source>Metadata</source>
          <target>メタデータ</target>
        </trans-unit>
        <trans-unit id="f70c71c1b2246c59d442015fb609b0bf48d83d56" translate="yes">
          <source>Method Decorators</source>
          <target>メソッド修飾子</target>
        </trans-unit>
        <trans-unit id="9adde04ca5b9eac1941dd0c91655d283d19fa1d1" translate="yes">
          <source>Methods within an abstract class that are marked as abstract do not contain an implementation and must be implemented in derived classes. Abstract methods share a similar syntax to interface methods. Both define the signature of a method without including a method body. However, abstract methods must include the &lt;code&gt;abstract&lt;/code&gt; keyword and may optionally include access modifiers.</source>
          <target>抽象とマークされた抽象クラス内のメソッドは実装を含まないため、派生クラスで実装する必要があります。 抽象メソッドは、インタフェースメソッドと同様の構文を共有します。 どちらもメソッド本体を含めずにメソッドのシグネチャを定義します。 ただし、抽象メソッドには&lt;code&gt;abstract&lt;/code&gt;キーワードを含める必要があり、オプションでアクセス修飾子を含めることもできます。</target>
        </trans-unit>
        <trans-unit id="b6b88d2f7dec6e6507655392b41d6d66aa58943b" translate="yes">
          <source>Microsoft.TypeScript.Compiler</source>
          <target>Microsoft.TypeScript.コンパイラ</target>
        </trans-unit>
        <trans-unit id="d6994e014929b9c9acadb4efcdd0d8898ec4998f" translate="yes">
          <source>Microsoft.TypeScript.MSBuild</source>
          <target>Microsoft.TypeScript.MSBuild</target>
        </trans-unit>
        <trans-unit id="ecf39fd6186584cf8c46f851590e11d05b7c8704" translate="yes">
          <source>Migrating from JavaScript</source>
          <target>JavaScriptからの移行</target>
        </trans-unit>
        <trans-unit id="006f2d2335563fb2900269f9b04adab236ac86ea" translate="yes">
          <source>Migrating from JavaScript: Early Benefits</source>
          <target>JavaScriptからの移行: 早期のメリット</target>
        </trans-unit>
        <trans-unit id="1fed3c879f3bb26b579690b94983582cf0edda15" translate="yes">
          <source>Migrating from JavaScript: Getting Stricter Checks</source>
          <target>JavaScriptからの移行:より厳密なチェック</target>
        </trans-unit>
        <trans-unit id="1dc81892a9e5e97f6be65072af4047daf654e1d2" translate="yes">
          <source>Migrating from JavaScript: Gulp</source>
          <target>JavaScriptからの移行: ガルプ</target>
        </trans-unit>
        <trans-unit id="7e19d5d40009a708d8b21bd446a6de963f361896" translate="yes">
          <source>Migrating from JavaScript: Integrating with Build Tools</source>
          <target>JavaScriptからの移行: 構築ツールとの統合</target>
        </trans-unit>
        <trans-unit id="4ff2a610f7fca46011040ebfbaebde73fe2d0b89" translate="yes">
          <source>Migrating from JavaScript: Moving to TypeScript Files</source>
          <target>JavaScriptからの移行: TypeScriptファイルへの移動</target>
        </trans-unit>
        <trans-unit id="9b91d79ea65c179b3144057c1b47e944dbe888c8" translate="yes">
          <source>Migrating from JavaScript: Setting up your Directories</source>
          <target>JavaScriptからの移行: ディレクトリの設定</target>
        </trans-unit>
        <trans-unit id="47148fd07a568fa2a38d4ed900235994bd81cea2" translate="yes">
          <source>Migrating from JavaScript: Webpack</source>
          <target>JavaScriptからの移行:Webpack</target>
        </trans-unit>
        <trans-unit id="49c6b428dbb35a643f704a1239347e7235a4958b" translate="yes">
          <source>Migrating from JavaScript: Weeding out Errors</source>
          <target>JavaScriptからの移行: エラーの除去</target>
        </trans-unit>
        <trans-unit id="8ec1b6d66f7377a566796d605d898d7ac205f685" translate="yes">
          <source>Migrating from JavaScript: Writing a Configuration File</source>
          <target>JavaScriptからの移行:構成ファイルの作成</target>
        </trans-unit>
        <trans-unit id="df5cb9211be987b98b3cea69592169ee4806d416" translate="yes">
          <source>Minimal project</source>
          <target>最小プロジェクト</target>
        </trans-unit>
        <trans-unit id="656fbec7e4c8bcab6e3951b1194d9d3fdebdb947" translate="yes">
          <source>Mixin classes can constrain the types of classes they can mix into by specifying a construct signature return type in the constraint for the type parameter. For example, the following &lt;code&gt;WithLocation&lt;/code&gt; function implements a subclass factory that adds a &lt;code&gt;getLocation&lt;/code&gt; method to any class that satisfies the &lt;code&gt;Point&lt;/code&gt; interface (i.e. that has &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; properties of type &lt;code&gt;number&lt;/code&gt;).</source>
          <target>Mixinクラスは、typeパラメータの制約に構文シグネチャの戻り値型を指定することによって、混合できるクラスの型を制約することができます。 たとえば、次の&lt;code&gt;WithLocation&lt;/code&gt;関数は、&lt;code&gt;Point&lt;/code&gt;インタフェースを満たすクラス(つまり、&lt;code&gt;x&lt;/code&gt;および&lt;code&gt;y&lt;/code&gt;プロパティが&lt;code&gt;number&lt;/code&gt;型)に&lt;code&gt;getLocation&lt;/code&gt;メソッドを追加するサブクラスファクトリを実装します。</target>
        </trans-unit>
        <trans-unit id="ed6542d9669951817ce6e0f5f573873a74bbcd94" translate="yes">
          <source>Mixin sample</source>
          <target>Mixinサンプル</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes">
          <source>Mixins</source>
          <target>ミックスイン</target>
        </trans-unit>
        <trans-unit id="a7b93d2128e820f861fc8dfccd9f5521e89ad21f" translate="yes">
          <source>Mode</source>
          <target>モード</target>
        </trans-unit>
        <trans-unit id="8686e36f3c455dfff0e15750343932a50c4f9345" translate="yes">
          <source>Modular Libraries</source>
          <target>モジュールライブラリ</target>
        </trans-unit>
        <trans-unit id="e87eeaf0b3370593816d7faa70993da2a4c34bdc" translate="yes">
          <source>Modular libraries will typically have at least some of the following:</source>
          <target>モジュラライブラリには、通常、次のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="679935999c06d0d64c305facc48d71ad3d62a359" translate="yes">
          <source>Module Augmentation</source>
          <target>モジュール増強</target>
        </trans-unit>
        <trans-unit id="288e4a8c6676ea4eb83392ffcf2395bf08c232ab" translate="yes">
          <source>Module Resolution</source>
          <target>モジュールの解像度</target>
        </trans-unit>
        <trans-unit id="e38eacd064c21c297854627bdac879933ce99fef" translate="yes">
          <source>Module Resolution Strategies</source>
          <target>モジュール解決方法</target>
        </trans-unit>
        <trans-unit id="4cd56198bb579b9f107f6cea74de7d094276eb7a" translate="yes">
          <source>Module identifiers allow for &lt;code&gt;.js&lt;/code&gt; extension</source>
          <target>モジュール識別子は&lt;code&gt;.js&lt;/code&gt;拡張を許可する</target>
        </trans-unit>
        <trans-unit id="a00b56b003050bea7431d876a345583f047b820c" translate="yes">
          <source>Module imports are resolved differently based on whether the module reference is relative or non-relative.</source>
          <target>モジュールインポートの解決方法は、モジュール参照が相対参照か非相対参照かによって異なります。</target>
        </trans-unit>
        <trans-unit id="79dbe4a4af0851fd89a5e09eccc010e3219dbe7b" translate="yes">
          <source>Module loaders like SystemJS wrap CommonJS modules and expose then as a &lt;code&gt;default&lt;/code&gt; ES6 import. This makes it impossible to share the definition files between the SystemJS and CommonJS implementation of the module as the module shape looks different based on the loader.</source>
          <target>SystemJSのようなモジュールローダはCommonJSモジュールをラップし、&lt;code&gt;default&lt;/code&gt;ES6インポートとして公開する。 このため、ローダによってモジュールの形状が異なるため、モジュールのSystemJS実装とCommonJS実装の間で定義ファイルを共有することができない。</target>
        </trans-unit>
        <trans-unit id="8706260383ba3213edb052d2ee2093acb606b380" translate="yes">
          <source>Module resolution enhancements: BaseUrl, Path mapping, rootDirs and tracing</source>
          <target>モジュール解像度の強化: BaseUrl、パスマッピング、rootDirs、トレース</target>
        </trans-unit>
        <trans-unit id="47f28156d69593c826cc9c4bbfcf281e3d6aa9d7" translate="yes">
          <source>Module resolution kind is not specified, using &lt;strong&gt;&amp;lsquo;NodeJs&amp;rsquo;&lt;/strong&gt;.</source>
          <target>モジュール解決の種類が指定されていません。&lt;strong&gt;&amp;lsquo;NodeJs&amp;rsquo;&lt;/strong&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes">
          <source>Modules</source>
          <target>モジュール</target>
        </trans-unit>
        <trans-unit id="a30c7f6e8f418488e99ab172a19da443b4fdc2aa" translate="yes">
          <source>Modules also have a dependency on a module loader (such as CommonJs/Require.js). For a small JS application this might not be optimal, but for larger applications, the cost comes with long term modularity and maintainability benefits. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.</source>
          <target>モジュールはモジュールローダ(CommonJs/Require.jsなど)にも依存する。 小規模なJSアプリケーションの場合、これは最適ではないかもしれませんが、大規模なアプリケーションの場合、コストは長期的なモジュール性と保守性の利点を伴います。 モジュールは、コードの再利用性の向上、分離の強化、バンドルのためのツールサポートの向上を提供します。</target>
        </trans-unit>
        <trans-unit id="78a50e79f8142b8f5f0f90d0fa7d14efea7d1c2f" translate="yes">
          <source>Modules are declarative; the relationships between modules are specified in terms of imports and exports at the file level.</source>
          <target>モジュールは宣言型です。モジュール間の関係は、ファイル・レベルでのインポートとエクスポートの観点から指定されます。</target>
        </trans-unit>
        <trans-unit id="675dd99631ed01c0f9ec0b8b2aaed9ef0a2c4dfd" translate="yes">
          <source>Modules are executed within their own scope, not in the global scope; this means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the &lt;a href="#export"&gt;&lt;code&gt;export&lt;/code&gt; forms&lt;/a&gt;. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the &lt;a href="#import"&gt;&lt;code&gt;import&lt;/code&gt; forms&lt;/a&gt;.</source>
          <target>モジュールは、グローバルスコープではなく、独自のスコープ内で実行されます。つまり、モジュール内で宣言された変数、関数、クラスなどは、&lt;a href="#export"&gt;&lt;code&gt;export&lt;/code&gt;フォーム&lt;/a&gt;のいずれかを使用して明示的にエクスポートされない限り、モジュールの外部に表示されません。 逆に、変数、関数、クラス、インタフェースなどを使用する場合。 別のモジュールからエクスポートする場合は、&lt;a href="#import"&gt;&lt;code&gt;import&lt;/code&gt;フォーム&lt;/a&gt;のいずれかを使用してインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="cf0193704c9e50ad766367f6e68a7b531b34d65e" translate="yes">
          <source>Modules are now emitted with a &lt;code&gt;"use strict";&lt;/code&gt; prologue</source>
          <target>モジュールは&lt;code&gt;"use strict";&lt;/code&gt;プロローグで出力されるようになりました。</target>
        </trans-unit>
        <trans-unit id="e2a4a37826bb3f0f9a97d6eaca31fecba95d357a" translate="yes">
          <source>Modules are parsed automatically in strict mode. The new flag is recommended for non-module code.</source>
          <target>モジュールはstrictモードで自動的に解析されます。 モジュールコード以外の場合は、新しいフラグを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5b28d96858ba2eea0c5a37016b2613ff4945fbf0" translate="yes">
          <source>Modules can import types declared in other modules. But non-module global scripts cannot access types declared in modules. Enter &lt;code&gt;import&lt;/code&gt; types.</source>
          <target>モジュールは、他のモジュールで宣言された型をインポートできます。 ただし、モジュール以外のグローバルスクリプトは、モジュールで宣言された型にアクセスできません。 &lt;code&gt;import&lt;/code&gt;のタイプを入力します。</target>
        </trans-unit>
        <trans-unit id="f37a7873a73994ccdd158807226796e74f617880" translate="yes">
          <source>Modules import one another using a module loader. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. Well-known module loaders used in JavaScript are Node.js&amp;rsquo;s loader for &lt;a href="https://en.wikipedia.org/wiki/CommonJS"&gt;CommonJS&lt;/a&gt; modules and the &lt;a href="http://requirejs.org/"&gt;RequireJS&lt;/a&gt; loader for &lt;a href="https://github.com/amdjs/amdjs-api/blob/master/amd.html"&gt;AMD&lt;/a&gt; modules in Web applications.</source>
          <target>モジュールは、モジュールローダーを使用して相互にインポートします。 実行時には、モジュール・ローダーは、モジュールを実行する前に、モジュールのすべての依存関係を検索して実行します。 JavaScriptでよく使用されるモジュールローダーには、&lt;a href="https://en.wikipedia.org/wiki/CommonJS"&gt;CommonJS&lt;/a&gt;モジュール用のNode.js&amp;rsquo;のローダーと、Webアプリケーションの&lt;a href="https://github.com/amdjs/amdjs-api/blob/master/amd.html"&gt;AMD&lt;/a&gt;モジュール用の&lt;a href="http://requirejs.org/"&gt;RequireJS&lt;/a&gt;ローダーがあります。</target>
        </trans-unit>
        <trans-unit id="f58764143073eae1cd29c9babec8bc1672b59332" translate="yes">
          <source>Modules were always parsed in strict mode as per ES6, but for non-ES6 targets this was not respected in the generated code. Starting with TypeScript 1.8, emitted modules are always in strict mode. This shouldn&amp;rsquo;t have any visible changes in most code as TS considers most strict mode errors as errors at compile time, but it means that some things which used to silently fail at runtime in your TS code, like assigning to &lt;code&gt;NaN&lt;/code&gt;, will now loudly fail. You can reference the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode"&gt;MDN Article&lt;/a&gt; on strict mode for a detailed list of the differences between strict mode and non-strict mode.</source>
          <target>モジュールは常にES6に従ってstrictモードで解析されていましたが、ES6以外のターゲットでは、生成されたコードでは考慮されていませんでした。 TypeScript1.8以降では、放出されるモジュールは常にstrictモードです。 これは、TSが最も厳格なモードエラーをコンパイル時のエラーとみなしているので、ほとんどのコードで目に見える変化を持たないことを意味していますが、&lt;code&gt;NaN&lt;/code&gt;への代入のように、TSコードの実行時に静かに失敗していたいくつかのことが、大きな意味で失敗することになります。 strictモードとnon-strictモードの違いについては、&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode"&gt;MDN Article&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="69245e47778546d5b4d8c60a97c075633036ce67" translate="yes">
          <source>More Accurate Array Spread</source>
          <target>より正確な配列分散</target>
        </trans-unit>
        <trans-unit id="867951121618b22e94ac0ddd378f75a352293d4f" translate="yes">
          <source>More details about defining MSBuild compiler options: &lt;a href="compiler-options-in-msbuild"&gt;Setting Compiler Options in MSBuild projects&lt;/a&gt;</source>
          <target>MSBuildコンパイラオプションの定義の詳細:&lt;a href="compiler options in msbuild"&gt;MSBuildプロジェクトでのコンパイラオプションの設定&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="341a196acd33aea44262f80c4074a8f29f17eab0" translate="yes">
          <source>More details can be found at &lt;a href="http://docs.nuget.org/Consume/Package-Manager-Dialog"&gt;Package Manager Dialog&lt;/a&gt; and &lt;a href="https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild"&gt;using nightly builds with NuGet&lt;/a&gt;</source>
          <target>詳細については、&lt;a href="http://docs.nuget.org/Consume/Package-Manager-Dialog"&gt;Package Manager Dialog&lt;/a&gt;および&lt;a href="https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild"&gt;nightly build with NuGet&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="53846a07e48104da9e41b5b1360721c3ad76cfc9" translate="yes">
          <source>More details: &lt;a href="https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm"&gt;TypeScriptSamples/jspm&lt;/a&gt;</source>
          <target>詳細:&lt;a href="https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm"&gt;TypeScriptSamples/ジスパム&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f54abbf20043f5f79ba176f97dcafaab83a262d" translate="yes">
          <source>More details: &lt;a href="https://github.com/TypeStrong/grunt-ts"&gt;TypeStrong/grunt-ts&lt;/a&gt;</source>
          <target>詳細:&lt;a href="https://github.com/TypeStrong/grunt-ts"&gt;TypeStrong/イサキ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4be1d9cace5494e189a22e68f895ee7cf9cddcd" translate="yes">
          <source>More details: &lt;a href="https://github.com/frankwallis/duo-typescript"&gt;frankwallis/duo-typescript&lt;/a&gt;</source>
          <target>詳細:&lt;a href="https://github.com/frankwallis/duo-typescript"&gt;フランクヴァリス/duo typescript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9288db5f93cb0d64c4598820b26040518ce475e5" translate="yes">
          <source>More details: &lt;a href="https://github.com/ivogabe/gulp-typescript"&gt;ivogabe/gulp-typescript&lt;/a&gt;</source>
          <target>詳細:&lt;a href="https://github.com/ivogabe/gulp-typescript"&gt;イボガベ/gulp typescript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c2859a3239620cafb1098f30753d17591c86749" translate="yes">
          <source>More details: &lt;a href="https://github.com/smrq/tsify"&gt;smrq/tsify&lt;/a&gt;</source>
          <target>詳細:&lt;a href="https://github.com/smrq/tsify"&gt;スミルク/ツーフィ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="383f0e0e882a4dc2683b66372e6aa52e3a75f04b" translate="yes">
          <source>More examples</source>
          <target>その他の例</target>
        </trans-unit>
        <trans-unit id="d6f53e513aa21c7609698b66494f900516f1e524" translate="yes">
          <source>More information is available at &lt;a href="https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions"&gt;VSCode documentation&lt;/a&gt;.</source>
          <target>詳細については、&lt;a href="https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions"&gt;VSCode documentation&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3ebf7c56cc3c7e6470d4e988436ec5ba45710c59" translate="yes">
          <source>More information is available at the &lt;a href="https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation"&gt;TypeScript Plugin for Sublime Text installation documentation&lt;/a&gt;.</source>
          <target>詳細については、&lt;a href="https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation"&gt;TypeScript Plugin for Sublime Textインストールマニュアル&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9f1fd24b8a3a7e494a8b827fe826c345c6c39fc7" translate="yes">
          <source>More more details, you can &lt;a href="https://github.com/tc39/proposal-optional-chaining/"&gt;read up on the proposal&lt;/a&gt; and &lt;a href="https://github.com/microsoft/TypeScript/pull/33294"&gt;view the original pull request&lt;/a&gt;.</source>
          <target>詳細については、提案書を&lt;a href="https://github.com/tc39/proposal-optional-chaining/"&gt;お読みになり&lt;/a&gt;、元のプル要求を&lt;a href="https://github.com/microsoft/TypeScript/pull/33294"&gt;参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2090b67c917ff081773b34229e30e6990c49b179" translate="yes">
          <source>More plainly, that code snippet is the same as writing the following.</source>
          <target>簡単に言えば、このコード・スニペットは次のコードを書くのと同じです。</target>
        </trans-unit>
        <trans-unit id="ba3ba120356f7dea7aa61a6e3ef6b6565d3edcce" translate="yes">
          <source>Most popular libraries are now available as UMD packages. Examples include &lt;a href="https://jquery.com/"&gt;jQuery&lt;/a&gt;, &lt;a href="http://momentjs.com/"&gt;Moment.js&lt;/a&gt;, &lt;a href="https://lodash.com/"&gt;lodash&lt;/a&gt;, and many more.</source>
          <target>現在、最も一般的なライブラリはUMDパッケージとして提供されています。 例としては、&lt;a href="https://jquery.com/"&gt;jQuery&lt;/a&gt;、&lt;a href="http://momentjs.com/"&gt;Moment.js&lt;/a&gt;、&lt;a href="https://lodash.com/"&gt;lodash&lt;/a&gt;などがある。</target>
        </trans-unit>
        <trans-unit id="638f05be2eca8814a76fc1ca76ad8fd857366420" translate="yes">
          <source>Moving to TypeScript Files</source>
          <target>TypeScriptファイルへの移動</target>
        </trans-unit>
        <trans-unit id="43621334a2a23b4d5d4b6053efcc9a2d2b0aab17" translate="yes">
          <source>Much of the time when we talk about &amp;ldquo;singleton types&amp;rdquo;, we&amp;rsquo;re referring to both enum member types as well as numeric/string literal types, though many users will use &amp;ldquo;singleton types&amp;rdquo; and &amp;ldquo;literal types&amp;rdquo; interchangeably.</source>
          <target>&amp;ldquo;singleton types&amp;rdquo;の説明では、&amp;rdquo;はenumメンバタイプと数値/文字列リテラルタイプの両方を指していますが、多くのユーザは&amp;ldquo;singleton types&amp;rdquo;と&amp;ldquo;literal types&amp;rdquo;を同じ意味で使用します。</target>
        </trans-unit>
        <trans-unit id="17529a071acaf46e503733acf690f3a9c40c2a13" translate="yes">
          <source>Multi-file namespaces</source>
          <target>複数ファイルのネームスペース</target>
        </trans-unit>
        <trans-unit id="6a46449eba494ccdd3d50009ef86e5514ea905cd" translate="yes">
          <source>Multiple decorators can be applied to a declaration, as in the following examples:</source>
          <target>次の例のように、複数のデコレータを宣言に適用できます。</target>
        </trans-unit>
        <trans-unit id="c84cbd92065cb5c6f658fb4c2b736202ca88a094" translate="yes">
          <source>Multiple fields</source>
          <target>複数のフィールド</target>
        </trans-unit>
        <trans-unit id="e64884c573469c4403ae3581451fc7bb26479d03" translate="yes">
          <source>Multiple files that have the same &lt;code&gt;export namespace Foo {&lt;/code&gt; at top-level (don&amp;rsquo;t think that these are going to combine into one &lt;code&gt;Foo&lt;/code&gt;!)</source>
          <target>最上位レベルで同じ&lt;code&gt;export名前空間Foo{&lt;/code&gt;を持つ複数のファイル(これらが1つの&lt;code&gt;Foo&lt;/code&gt;に結合されるとは考えていない)</target>
        </trans-unit>
        <trans-unit id="c9a109a97c148517f646b23952e44c0d2099a11f" translate="yes">
          <source>Multiple object literal type inferences for the same type parameter are similarly collapsed into a single normalized union type:</source>
          <target>同じ型パラメータに対する複数のオブジェクトリテラル型推論は、同様に単一の正規化されたユニオン型に集約されます。</target>
        </trans-unit>
        <trans-unit id="2e944fe6e675e7e28c8ee6b40790b0f75443bf77" translate="yes">
          <source>MyClass.ts</source>
          <target state="translated">MyClass.ts</target>
        </trans-unit>
        <trans-unit id="9d75928f38872b5fba12d9e28028ca42f4f74a7f" translate="yes">
          <source>MyFunc.ts</source>
          <target state="translated">MyFunc.ts</target>
        </trans-unit>
        <trans-unit id="6a6cd093331d4efd7bda9e1eec1f6de5f0b888e7" translate="yes">
          <source>MyLargeModule.ts</source>
          <target state="translated">MyLargeModule.ts</target>
        </trans-unit>
        <trans-unit id="d4689856a3bbc2e7a56c851bfc734afc822d4050" translate="yes">
          <source>MyTestPage.html (excerpt)</source>
          <target>MyTestPage.html(抜粋)</target>
        </trans-unit>
        <trans-unit id="5621ae759c74cfb2dde7856d9cb911d0824e1648" translate="yes">
          <source>MyThings.ts</source>
          <target state="translated">MyThings.ts</target>
        </trans-unit>
        <trans-unit id="4e93c1eccd779026bfe9421435d57abbf755af58" translate="yes">
          <source>NOTE A &lt;em&gt;Property Descriptor&lt;/em&gt; is not provided as an argument to a property decorator due to how property decorators are initialized in TypeScript. This is because there is currently no mechanism to describe an instance property when defining members of a prototype, and no way to observe or modify the initializer for a property. The return value is ignored too. As such, a property decorator can only be used to observe that a property of a specific name has been declared for a class.</source>
          <target>注意&lt;em&gt;プロパティ記述子&lt;/em&gt;は、プロパティデコレータがTypeScriptで初期化される方法のため、プロパティデコレータへの引数として提供されません。 これは、現在、プロトタイプのメンバを定義するときにインスタンスプロパティを記述するメカニズムがなく、プロパティの初期化子を観察または修正する方法がないためです。 戻り値も無視されます。 したがって、プロパティー・デコレータは、特定の名前のプロパティーがクラスに対して宣言されたことを観察するためにのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="9845c4ce119ecd689f1dfdba7ee10411216b49e9" translate="yes">
          <source>NOTE A parameter decorator can only be used to observe that a parameter has been declared on a method.</source>
          <target>注記パラメータデコレータは、パラメータがメソッドで宣言されたことを確認するためにのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="8b79455e774377963b080298d153feef0d875163" translate="yes">
          <source>NOTE Decorator metadata is an experimental feature and may introduce breaking changes in future releases.</source>
          <target>注デコレータのメタデータは試験的な機能であり、将来のリリースで変更が加えられる可能性があります。</target>
        </trans-unit>
        <trans-unit id="2285b393e7b504af0a81971d53ea0b3d317886cd" translate="yes">
          <source>NOTE Decorators are an experimental feature that may change in future releases.</source>
          <target>注デコレータは、将来のリリースで変更される可能性がある実験的な機能です。</target>
        </trans-unit>
        <trans-unit id="a60eb9bd0a4289a1fdb762b911bc6c4ca3667c6d" translate="yes">
          <source>NOTE Should you choose to return a new constructor function, you must take care to maintain the original prototype. The logic that applies decorators at runtime will &lt;strong&gt;not&lt;/strong&gt; do this for you.</source>
          <target>注記新しいコンストラクタ関数を返すことを選択した場合は、元のプロトタイプを維持するように注意する必要があります。 実行時にデコレータを適用するロジックは、これを&lt;strong&gt;しません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="60bdff9d3b04677acbffa7e2cc622c91f6a36bb2" translate="yes">
          <source>NOTE The &lt;em&gt;Property Descriptor&lt;/em&gt; will be &lt;code&gt;undefined&lt;/code&gt; if your script target is less than &lt;code&gt;ES5&lt;/code&gt;.</source>
          <target>注記スクリプトターゲットが&lt;code&gt;ES5&lt;/code&gt;より小さい場合、&lt;em&gt;プロパティ記述子&lt;/em&gt;は&lt;code&gt;undefined&lt;/code&gt;になります。</target>
        </trans-unit>
        <trans-unit id="3819f97fdfb5b90ae474745720dbbf7bdc58c9e6" translate="yes">
          <source>NOTE The return value is ignored if your script target is less than &lt;code&gt;ES5&lt;/code&gt;.</source>
          <target>注記スクリプトターゲットが&lt;code&gt;ES5&lt;/code&gt;より小さい場合、戻り値は無視されます。</target>
        </trans-unit>
        <trans-unit id="195da41da17e46986e65163a2bd1160b912d7429" translate="yes">
          <source>NOTE This example requires the &lt;code&gt;reflect-metadata&lt;/code&gt; library. See &lt;a href="#metadata"&gt;Metadata&lt;/a&gt; for more information about the &lt;code&gt;reflect-metadata&lt;/code&gt; library.</source>
          <target>注この例では、&lt;code&gt;reflect metadata&lt;/code&gt;ライブラリが必要です。&lt;code&gt;reflect metadata&lt;/code&gt;ライブラリの詳細については、&lt;a href="#metadata"&gt;Metadata&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a10f30aafff5360ca16967a3e15b058ca9402455" translate="yes">
          <source>NOTE TypeScript disallows decorating both the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessor for a single member. Instead, all decorators for the member must be applied to the first accessor specified in document order. This is because decorators apply to a &lt;em&gt;Property Descriptor&lt;/em&gt;, which combines both the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessor, not each declaration separately.</source>
          <target>注記TypeScriptでは、単一のメンバの&lt;code&gt;get&lt;/code&gt;アクセサと&lt;code&gt;set&lt;/code&gt;アクセサの両方を修飾することはできません。 代わりに、メンバーのすべての修飾子を、文書順に指定された最初のアクセサに適用する必要があります。 これは、デコレータが&lt;em&gt;プロパティ記述子&lt;/em&gt;に適用され、&lt;code&gt;get&lt;/code&gt;アクセサと&lt;code&gt;set&lt;/code&gt;アクセサの両方が結合され、各宣言が別々に適用されないためです。</target>
        </trans-unit>
        <trans-unit id="45308d86614845d7f3bb84b8a20942a74d48e6a9" translate="yes">
          <source>NOTE You can see a more detailed example of a decorator factory in &lt;a href="#method-decorators"&gt;Method Decorators&lt;/a&gt;, below.</source>
          <target>注:デコレータ・ファクトリの詳細な例については、以下の&lt;a href="#method decorators"&gt;Method Decorators&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="77a213401e1d655ca6ce67ccac1b595b83f6a49a" translate="yes">
          <source>NOTE You can see a more detailed example of a decorator in &lt;a href="#class-decorators"&gt;Class Decorators&lt;/a&gt;, below.</source>
          <target>注:デコレータの詳細な例については、以下の&lt;a href="#class decorators"&gt;Class Decorators&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3bfed306b0b8464442bdb1711257fd81e5104011" translate="yes">
          <source>Name and location of the import</source>
          <target>インポートの名前と場所</target>
        </trans-unit>
        <trans-unit id="c4e900249c06ced551414f6dbfecd4345fbf0964" translate="yes">
          <source>Name your files with a &lt;code&gt;.tsx&lt;/code&gt; extension</source>
          <target>ファイルに&lt;code&gt;.tsx&lt;/code&gt;拡張子を付けます。</target>
        </trans-unit>
        <trans-unit id="f1e1fdc0047ebce963af46e324aa0bb6cc3cd40b" translate="yes">
          <source>Name your project and solution. After select the &lt;em&gt;Create&lt;/em&gt; button</source>
          <target>プロジェクトとソリューションに名前を付けます。 [&lt;em&gt;作成&lt;/em&gt;]ボタンを選択した後</target>
        </trans-unit>
        <trans-unit id="0449e1003dd0cdd92ab163e844540614258e8b38" translate="yes">
          <source>Namespace</source>
          <target>名前空間</target>
        </trans-unit>
        <trans-unit id="62936894b0ebe54f16bb9d18daac6e4b06cda0b2" translate="yes">
          <source>Namespaced Validators</source>
          <target>名前空間バリデータ</target>
        </trans-unit>
        <trans-unit id="be09a63bd1995e99cd22064cdc39a4bae464033d" translate="yes">
          <source>Namespaces</source>
          <target>名前空間</target>
        </trans-unit>
        <trans-unit id="28155c3898eb0e0a7f3992151a91ad580f0a8bee" translate="yes">
          <source>Namespaces &amp; Modules</source>
          <target>名前空間とモジュール</target>
        </trans-unit>
        <trans-unit id="9b1e65cb7124596d09d4502bbe02b71fb8a3d882" translate="yes">
          <source>Namespaces and Modules</source>
          <target>名前空間とモジュール</target>
        </trans-unit>
        <trans-unit id="13339d851d51b5c81981062cf249473168c678ea" translate="yes">
          <source>Namespaces are flexible enough to also merge with other types of declarations. To do so, the namespace declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types. TypeScript uses this capability to model some of the patterns in JavaScript as well as other programming languages.</source>
          <target>名前空間は、他のタイプの宣言ともマージできるほど柔軟です。 そのためには、名前空間宣言はマージする宣言の後に続かなければなりません。 結果の宣言には、両方の宣言タイプのプロパティーがあります。 TypeScriptはこの機能を使って、JavaScriptや他のプログラミング言語のパターンの一部をモデル化します。</target>
        </trans-unit>
        <trans-unit id="0fd9b6444054278bf7680e4f8067f50258da5add" translate="yes">
          <source>Namespaces are important to avoid naming collisions in the global scope. For example, you might have &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; and &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;ndash; two types with the same name, but a different namespace. This, however, is not an issue with modules. Within a module, there&amp;rsquo;s no plausible reason to have two objects with the same name. From the consumption side, the consumer of any given module gets to pick the name that they will use to refer to the module, so accidental naming conflicts are impossible.</source>
          <target>名前空間は、グローバルスコープで名前の衝突を避けるために重要です。 たとえば、&lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt;と&lt;code&gt;My.Application.Order.AddForm&lt;/code&gt;&amp;ndash;2つのタイプがあり、名前は同じでも名前空間が異なる場合があります。 ただし、これはモジュールの問題ではありません。 モジュール内に、同じ名前の2つのオブジェクトを持つもっともらしい理由はありません。 消費側では、モジュールを参照するために使用する名前をモジュールのコンシューマが選択するため、名前の競合が発生することはありません。</target>
        </trans-unit>
        <trans-unit id="5e4e7df3860290d042f9971740a7d47d81a9f02b" translate="yes">
          <source>Namespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. They can span multiple files, and can be concatenated using &lt;code&gt;--outFile&lt;/code&gt;. Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags in your HTML page.</source>
          <target>名前空間は、グローバル名前空間では単にJavaScriptオブジェクトと呼ばれます。 これにより、名前空間は非常に単純な構造体として使用できるようになります。 名前空間は複数のファイルにまたがることができ、&lt;code&gt;--outFile&lt;/code&gt;を使用して連結することができます。名前空間は、HTMLページの&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;タグにすべての依存関係が含まれているWebアプリケーションでコードを構成するための優れた方法です。</target>
        </trans-unit>
        <trans-unit id="362b423baafd1e7b201b94eb4694146a945d2f27" translate="yes">
          <source>Namespacing</source>
          <target>名前の間隔</target>
        </trans-unit>
        <trans-unit id="166846adfb9918dc66f0055635e2541ff9496d41" translate="yes">
          <source>Native ECMAScript 2015 modules SimpleModule.js</source>
          <target>ネイティブECMAScript2015モジュールSimpleModule.js</target>
        </trans-unit>
        <trans-unit id="fe8c21145c9261ff78e4961a2b85ef9086d1cb41" translate="yes">
          <source>Needless Namespacing</source>
          <target>不要な名前間隔</target>
        </trans-unit>
        <trans-unit id="e41b56abbcfdf8901dfab715d721b400cec7b1fc" translate="yes">
          <source>Neither module augmentations nor global augmentations can add new items to the top level scope - they can only &amp;ldquo;patch&amp;rdquo; existing declarations.</source>
          <target>モジュールの拡大もグローバルな拡大も、新しい項目を最上位のスコープに追加することはできません。既存の宣言に&amp;ldquo;patch&amp;rdquo;しかできません。</target>
        </trans-unit>
        <trans-unit id="e6bef57bae5c0e8838a79a353fc36602b74e1fc1" translate="yes">
          <source>Nested and merged declarations</source>
          <target>ネスト宣言とマージ宣言</target>
        </trans-unit>
        <trans-unit id="4d4cd8fe398e6e096cb8030f584f4c402cf52fc5" translate="yes">
          <source>Nesting works to any level now, and merges correctly across files. Previously neither was the case.</source>
          <target>ネストはどのレベルでも動作し、ファイル間で正しくマージされます。 以前はどちらもそうだった。</target>
        </trans-unit>
        <trans-unit id="80c3052d33ccdee15ffaaa110c5c39072495fe63" translate="yes">
          <source>Never</source>
          <target state="translated">Never</target>
        </trans-unit>
        <trans-unit id="1acaa361d7e585d276debdfd60f55c71408418be" translate="yes">
          <source>New &lt;code&gt;--alwaysStrict&lt;/code&gt;</source>
          <target>New&lt;code&gt;--alwaysStrict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ac644d9fe3dbb3ac2dccc6d1b53a6bed2b697fc" translate="yes">
          <source>New &lt;code&gt;--declarationDir&lt;/code&gt;</source>
          <target>New&lt;code&gt;--declarationDir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="720d98b2f44f4640d6cfec4c055ef03a55e5d548" translate="yes">
          <source>New &lt;code&gt;--declarationMap&lt;/code&gt;</source>
          <target>New&lt;code&gt;--declarationMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b89c753438c197bdc13cb6ed610b532eff5723f" translate="yes">
          <source>New &lt;code&gt;--downlevelIteration&lt;/code&gt;</source>
          <target>New&lt;code&gt;--downlevelIteration&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a00d32452ace95eaef3db016e18a1198fbb4791b" translate="yes">
          <source>New &lt;code&gt;--emitDeclarationOnly&lt;/code&gt;</source>
          <target>New&lt;code&gt;--emitDeclarationOnly&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8227c234e0daa0aaa18b885af7157a89a55e5b26" translate="yes">
          <source>New &lt;code&gt;--resolveJsonModule&lt;/code&gt;</source>
          <target>New&lt;code&gt;--resolveJsonModule&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="805477b1e825abe5eda721395ad4816c0fd064db" translate="yes">
          <source>New &lt;code&gt;--skipLibCheck&lt;/code&gt;</source>
          <target>New&lt;code&gt;--skipLibCheck&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fcbfed49c3a6bd382d5f91b01c13c2352408ca8e" translate="yes">
          <source>New &lt;code&gt;--strict&lt;/code&gt; master option</source>
          <target>New&lt;code&gt;--strict&lt;/code&gt;masterオプション</target>
        </trans-unit>
        <trans-unit id="d911d8e68bbe08754a7470249f09d0d73ac4db62" translate="yes">
          <source>New &lt;code&gt;.tsx&lt;/code&gt; file extension and &lt;code&gt;as&lt;/code&gt; operator</source>
          <target>新しい&lt;code&gt;.tsx&lt;/code&gt;ファイル拡張子と&lt;code&gt;as&lt;/code&gt;演算子</target>
        </trans-unit>
        <trans-unit id="84261bdb966ed15a62fb8f6e8d19c7f9f2c38198" translate="yes">
          <source>New &lt;code&gt;jsx: react-native&lt;/code&gt;</source>
          <target>新しい&lt;code&gt;jsx:react-native&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1306ec7c0fb90964d3f3b400158133f1b7d16572" translate="yes">
          <source>New &lt;code&gt;unknown&lt;/code&gt; top type</source>
          <target>新しい&lt;code&gt;不明な&lt;/code&gt;トップタイプ</target>
        </trans-unit>
        <trans-unit id="70bbb8ec99677d5bef2d3951d16be6268f24f3eb" translate="yes">
          <source>New TypeScript Playground</source>
          <target>新しいTypeScriptプレイグラウンド</target>
        </trans-unit>
        <trans-unit id="6de3d5b36312b21832416e8730475cc96c42db45" translate="yes">
          <source>New checks added to TypeScript are often off by default to avoid breaking existing projects. While avoiding breakage is a good thing, this strategy has the drawback of making it increasingly complex to choose the highest level of type safety, and doing so requires explicit opt-in action on every TypeScript release. With the &lt;code&gt;--strict&lt;/code&gt; option it becomes possible to choose maximum type safety with the understanding that additional errors might be reported by newer versions of the compiler as improved type checking features are added.</source>
          <target>TypeScriptに追加された新しいチェックは、既存のプロジェクトを壊さないように、デフォルトでオフになっていることが多い。 破損を避けることは良いことですが、この戦略には、最高レベルの型安全性を選択することがますます複雑になるという欠点があり、そうするためには、すべてのTypeScriptリリースで明示的なオプトインアクションが必要です。 &lt;code&gt;--strict&lt;/code&gt;オプションを使用すると、改良された型チェック機能が追加されると、新しいバージョンのコンパイラによって追加のエラーが報告される可能性があることを理解した上で、最大の型安全性を選択することが可能になります。</target>
        </trans-unit>
        <trans-unit id="7ba10c954271506a3bcae23fd68b8232b3e4e8de" translate="yes">
          <source>Next we have an example of how to override the constructor.</source>
          <target>次に、コンストラクターをオーバーライドする方法の例を示します。</target>
        </trans-unit>
        <trans-unit id="b330ca07a7da236f37925657529d467d0a58f857" translate="yes">
          <source>Next we will add a new folder and call it &lt;code&gt;scripts&lt;/code&gt;.</source>
          <target>次に、新しいフォルダを追加し、それを&lt;code&gt;scripts&lt;/code&gt;と呼びます。</target>
        </trans-unit>
        <trans-unit id="b62c3108bc37dfcdf96234518498c091954b4711" translate="yes">
          <source>Next, for each type variable introduced by an &lt;code&gt;infer&lt;/code&gt; (more later) declaration within &lt;code&gt;U&lt;/code&gt; collect a set of candidate types by inferring from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; (using the same inference algorithm as type inference for generic functions). For a given &lt;code&gt;infer&lt;/code&gt; type variable &lt;code&gt;V&lt;/code&gt;, if any candidates were inferred from co-variant positions, the type inferred for &lt;code&gt;V&lt;/code&gt; is a union of those candidates. Otherwise, if any candidates were inferred from contra-variant positions, the type inferred for &lt;code&gt;V&lt;/code&gt; is an intersection of those candidates. Otherwise, the type inferred for &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;never&lt;/code&gt;.</source>
          <target>次に、&lt;code&gt;infer&lt;/code&gt;(後述する)宣言によって&lt;code&gt;U&lt;/code&gt;内に導入された型変数ごとに、&lt;code&gt;T&lt;/code&gt;から&lt;code&gt;U&lt;/code&gt;までを推論することによって候補型の集合を収集する(一般関数の型推論と同じ推論アルゴリズムを使用する)。 与えられた&lt;code&gt;infer&lt;/code&gt;型変数&lt;code&gt;V&lt;/code&gt;に対して、共変な位置から候補が推論された場合、&lt;code&gt;V&lt;/code&gt;に対して推論される型は、それらの候補の和集合である。 それ以外の場合、いずれかの候補が対異位置から推論された場合、&lt;code&gt;V&lt;/code&gt;に対して推論されるタイプは、それらの候補の交差である。 それ以外の場合、&lt;code&gt;V&lt;/code&gt;に対して推論される型は&lt;code&gt;never&lt;/code&gt;である。</target>
        </trans-unit>
        <trans-unit id="149d602ff05c96e06423dc39ea5d234017f2a784" translate="yes">
          <source>Next, if your version of Visual Studio does not already have the latest TypeScript, you can &lt;a href="https://www.typescriptlang.org/index.html#download-links"&gt;install it&lt;/a&gt;.</source>
          <target>次に、使用しているバージョンのVisual Studioに最新のTypeScriptがない場合は、&lt;a href="https://www.typescriptlang.org/index.html#download-links"&gt;インストール&lt;/a&gt;できます。</target>
        </trans-unit>
        <trans-unit id="074954ffe368a9f868383848acfd3ad865a34cf0" translate="yes">
          <source>Next, let&amp;rsquo;s create an &lt;code&gt;index.tsx&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; with the following source:</source>
          <target>次に、&lt;code&gt;src&lt;/code&gt;内に次のソースを持つ&lt;code&gt;index.tsx&lt;/code&gt;を作成します。</target>
        </trans-unit>
        <trans-unit id="56492bdb624437d084cf97ce29f5755c9355f32f" translate="yes">
          <source>Next, we then use the class directly. Here we create a new variable called &lt;code&gt;greeterMaker&lt;/code&gt;. This variable will hold the class itself, or said another way its constructor function. Here we use &lt;code&gt;typeof Greeter&lt;/code&gt;, that is &amp;ldquo;give me the type of the &lt;code&gt;Greeter&lt;/code&gt; class itself&amp;rdquo; rather than the instance type. Or, more precisely, &amp;ldquo;give me the type of the symbol called &lt;code&gt;Greeter&lt;/code&gt;,&amp;rdquo; which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the &lt;code&gt;Greeter&lt;/code&gt; class. We show this by using &lt;code&gt;new&lt;/code&gt; on &lt;code&gt;greeterMaker&lt;/code&gt;, creating new instances of &lt;code&gt;Greeter&lt;/code&gt; and invoking them as before.</source>
          <target>次に、クラスを直接使用します。 ここでは、&lt;code&gt;greeterMaker&lt;/code&gt;という名前の新しい変数を作成します。この変数は、クラス自体を保持するか、別の方法でコンストラクタ関数を保持します。 ここでは、&lt;code&gt;typeof Greeter&lt;/code&gt;を使用します。つまり、インスタンスタイプではなく、&lt;code&gt;Greeter&lt;/code&gt;クラス自体のタイプを指定してください。 または、より正確には、&lt;code&gt;Greeter&lt;/code&gt;というシンボルの型を指定してください。これは、コンストラクタ関数の型です。 この型には、Greeterのすべての静的メンバと、&lt;code&gt;Greeter&lt;/code&gt;クラスのインスタンスを作成するコンストラクタが含まれます。 これは、&lt;code&gt;greeterMaker&lt;/code&gt;上の&lt;code&gt;new&lt;/code&gt;を使用して、&lt;code&gt;Greeter&lt;/code&gt;の新しいインスタンスを作成し、以前と同じようにそれらを呼び出すことによって示します。</target>
        </trans-unit>
        <trans-unit id="48fd249b15120ba7e0e8c493ff3db4c13ad95d86" translate="yes">
          <source>Next, we&amp;rsquo;ll add development-time dependencies on the &lt;a href="https://www.npmjs.com/package/ts-loader"&gt;ts-loader&lt;/a&gt; and &lt;a href="https://www.npmjs.com/package/source-map-loader"&gt;source-map-loader&lt;/a&gt;.</source>
          <target>次に、&lt;a href="https://www.npmjs.com/package/ts-loader"&gt;ts loader&lt;/a&gt;と&lt;a href="https://www.npmjs.com/package/source-map-loader"&gt;source map loader&lt;/a&gt;に、開発時の依存関係を追加します。</target>
        </trans-unit>
        <trans-unit id="dc79aea4b8183b17aa2b08058010210e82ecc955" translate="yes">
          <source>Next, we&amp;rsquo;ll create the class that will handle the combination of the two mixins. Let&amp;rsquo;s look at this in more detail to see how it does this:</source>
          <target>次に、2つのミックスインの組み合わせを処理するクラスを作成します。 これがどのように行われるかを確認するには、を参照してください。</target>
        </trans-unit>
        <trans-unit id="3da6f66c39205de12c1b0ea85576f12a60c67429" translate="yes">
          <source>Nightly Builds</source>
          <target state="translated">ナイトリービルド</target>
        </trans-unit>
        <trans-unit id="cb01bbc0b3a89a2f95960449dd66e5b7ab419b0c" translate="yes">
          <source>Nightly Builds: Using NuGet with MSBuild</source>
          <target state="translated">ナイトリービルド: MSBuildでNuGetを使う</target>
        </trans-unit>
        <trans-unit id="269472362c2cb3218dea4a230801c99606e84281" translate="yes">
          <source>Nightly Builds: Using npm</source>
          <target state="translated">ナイトリービルド: npmの使用</target>
        </trans-unit>
        <trans-unit id="d29bc0fc428d8dd325a7aa22de797acf39705506" translate="yes">
          <source>Nightly builds</source>
          <target state="translated">ナイトリービルド</target>
        </trans-unit>
        <trans-unit id="d7957143496bc3e4f3d8bec258d34ddbf9a66c00" translate="yes">
          <source>No Implicit &lt;code&gt;any&lt;/code&gt;</source>
          <target>暗黙の&lt;code&gt;any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a2211d43130f5295a9f394d970fa79e1787ca90" translate="yes">
          <source>No Implicit &lt;code&gt;any&lt;/code&gt; for &lt;code&gt;this&lt;/code&gt;</source>
          <target>&lt;code&gt;this&lt;/code&gt;のための&lt;code&gt;&lt;/code&gt;はありません</target>
        </trans-unit>
        <trans-unit id="2b9fbfb21cfa0b34035ba18cef71091f735deb52" translate="yes">
          <source>No type is a subtype of or assignable to &lt;code&gt;never&lt;/code&gt; (except &lt;code&gt;never&lt;/code&gt; itself).</source>
          <target>タイプが&lt;code&gt;never&lt;/code&gt;のサブタイプまたは割り当て可能なタイプでない(&lt;code&gt;never&lt;/code&gt;自体を除く)。</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes">
          <source>Node</source>
          <target>節点</target>
        </trans-unit>
        <trans-unit id="0dc5564786f44ffe5d739e06a70c0a346cb415f8" translate="yes">
          <source>Non-function members of the interfaces should be unique. If they are not unique, they must be of the same type. The compiler will issue an error if the interfaces both declare a non-function member of the same name, but of different types.</source>
          <target>インタフェースの非関数メンバは一意である必要があります。 一意でない場合は、同じタイプでなければなりません。 両方のインタフェースが同じ名前で異なる型の非関数メンバを宣言した場合、コンパイラはエラーを発行します。</target>
        </trans-unit>
        <trans-unit id="1494b169c26da2fba5af5bb24c5a642f24c6c749" translate="yes">
          <source>Non-generic spread expressions continue to be processed as before: Call and construct signatures are stripped, only non-method properties are preserved, and for properties with the same name, the type of the rightmost property is used. This contrasts with intersection types which concatenate call and construct signatures, preserve all properties, and intersect the types of properties with the same name. Thus, spreads of the same types may produce different results when they are created through instantiation of generic types:</source>
          <target>非汎用の展開式は、以前と同様に処理されます。呼び出しと構成のシグネチャは削除され、メソッド以外のプロパティのみが保持されます。同じ名前のプロパティには、右端のプロパティの型が使用されます。 これは、呼び出しと構成のシグネチャを連結し、すべてのプロパティを保持し、同じ名前のプロパティのタイプを交差する交差タイプとは対照的です。 したがって、同じタイプのスプレッドは、ジェネリックタイプのインスタンス化によって作成されるときに異なる結果を生成する場合があります。</target>
        </trans-unit>
        <trans-unit id="3f0cc9ae44503c7a979e12906895cd156851a3f6" translate="yes">
          <source>Non-homomorphic types are essentially creating new properties, so they can&amp;rsquo;t copy property modifiers from anywhere.</source>
          <target>準同型でない型は、基本的に新しいプロパティを作成するので、プロパティ変更子をどこからでもコピーできません。</target>
        </trans-unit>
        <trans-unit id="67964b3d04ccfc686f4aea422e7f8a00b96d652b" translate="yes">
          <source>Non-null and non-undefined type guards</source>
          <target>非NULLおよび未定義のタイプガード</target>
        </trans-unit>
        <trans-unit id="6dfb137ece21865c79297ea685dd84ed857ee8cd" translate="yes">
          <source>Non-null and non-undefined type guards may use the &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;===&lt;/code&gt;, or &lt;code&gt;!==&lt;/code&gt; operator to compare to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, as in &lt;code&gt;x != null&lt;/code&gt; or &lt;code&gt;x === undefined&lt;/code&gt;. The effects on subject variable types accurately reflect JavaScript semantics (e.g. double-equals operators check for both values no matter which one is specified whereas triple-equals only checks for the specified value).</source>
          <target>NULLおよび未定義でない型ガードは、&lt;code&gt;==&lt;/code&gt;、&lt;code&gt;!=&lt;/code&gt;、&lt;code&gt;==&lt;/code&gt;、または&lt;code&gt;!=&lt;/code&gt;演算子を使用して、&lt;code&gt;x!=null&lt;/code&gt;または&lt;code&gt;x===undefined&lt;/code&gt;のように、&lt;code&gt;null&lt;/code&gt;または&lt;code&gt;undefined&lt;/code&gt;と比較することができます。サブジェクト変数型に対する影響は、JavaScriptのセマンティクスを正確に反映しています(たとえば、double equals演算子はどちらの値が指定されてもチェックしますが、triple equalsは指定された値のみチェックします)。</target>
        </trans-unit>
        <trans-unit id="1429182fce7f9a8560f2257cc03417f636cfd4e4" translate="yes">
          <source>Non-null assertion operator</source>
          <target>非NULLのアサーション演算子</target>
        </trans-unit>
        <trans-unit id="8c77d1fe01b3d6b896e59e7ad679a030f98eb254" translate="yes">
          <source>Non-nullable types have no meaning and are treated just as their original type:</source>
          <target>非null許容型は意味がなく、元の型と同じように扱われます。</target>
        </trans-unit>
        <trans-unit id="eac50a4571700d4b796b3f2c2c60e4c14af40f6f" translate="yes">
          <source>Non-unit types as union discriminants</source>
          <target>組合せ判別式としての非単位型</target>
        </trans-unit>
        <trans-unit id="cb9eb9903c23d3b663a6f7a65c04d581b25002fd" translate="yes">
          <source>NonNullable&lt;T&gt;</source>
          <target state="translated">NonNullable&lt;T&gt;</target>
        </trans-unit>
        <trans-unit id="9e8dd4dc111ded7b2320e89d0f31eaa58c3daeae" translate="yes">
          <source>Normally the compiler will attempt to resolve all module imports before it starts the compilation process. Every time it successfully resolves an &lt;code&gt;import&lt;/code&gt; to a file, the file is added to the set of files the compiler will process later on.</source>
          <target>通常、コンパイラはコンパイルプロセスを開始する前に、すべてのモジュールインポートの解決を試みます。 ファイルへの&lt;code&gt;import&lt;/code&gt;を正常に解決するたびに、ファイルはコンパイラが後で処理する一連のファイルに追加されます。</target>
        </trans-unit>
        <trans-unit id="fa102d6a31f636b67a2c1043b2e52c1f1dd3e13e" translate="yes">
          <source>Normally, &lt;code&gt;tsc&lt;/code&gt; will produce outputs (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.d.ts&lt;/code&gt;) in the presence of syntax or type errors, unless &lt;code&gt;noEmitOnError&lt;/code&gt; is on. Doing this in an incremental build system would be very bad - if one of your out-of-date dependencies had a new error, you&amp;rsquo;d only see it &lt;em&gt;once&lt;/em&gt; because a subsequent build would skip building the now up-to-date project. For this reason, &lt;code&gt;tsc -b&lt;/code&gt; effectively acts as if &lt;code&gt;noEmitOnError&lt;/code&gt; is enabled for all projects.</source>
          <target>通常、&lt;code&gt;tsc&lt;/code&gt;は、&lt;code&gt;noEmitOnError&lt;/code&gt;がオンでない限り、構文エラーまたは型エラーがある場合に出力(&lt;code&gt;.js&lt;/code&gt;および&lt;code&gt;.d.ts&lt;/code&gt;)を生成します。 インクリメンタルビルドシステムでこれを行うと、非常にまずいことになります。古い依存関係の1つに新しいエラーが発生した場合、後続のビルドでは現在最新のプロジェクトのビルドがスキップされるため、その依存関係は一度だけ表示されます。&lt;em&gt;&lt;/em&gt;。 このため、&lt;code&gt;tsc-b&lt;/code&gt;は、&lt;code&gt;noEmitOnError&lt;/code&gt;がすべてのプロジェクトで有効になっているかのように動作します。</target>
        </trans-unit>
        <trans-unit id="3d901c000076266c2726be52567eee3a9e906da5" translate="yes">
          <source>Not all merges are allowed in TypeScript. Currently, classes can not merge with other classes or with variables. For information on mimicking class merging, see the &lt;a href="mixins"&gt;Mixins in TypeScript&lt;/a&gt; section.</source>
          <target>すべての結合がTypeScriptで許可されているわけではありません。 現在、クラスを他のクラスや変数と結合することはできません。クラスの結合を模倣する方法については、「&lt;a href="mixins"&gt;Mixins in TypeScript&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="0fecf4145f603258529bada9dcd0bcbc05978112" translate="yes">
          <source>Not all properties of an interface may be required. Some exist under certain conditions or may not be there at all. These optional properties are popular when creating patterns like &amp;ldquo;option bags&amp;rdquo; where you pass an object to a function that only has a couple of properties filled in.</source>
          <target>インタフェースのすべてのプロパティが必要なわけではありません。 ある条件下で存在するものもあれば、まったく存在しないものもある。 これらのオプションプロパティは、&amp;ldquo;option bags&amp;rdquo;のようなパターンを作成するときによく使用されます。このパターンでは、2、3のプロパティのみが入力された関数にオブジェクトを渡します。</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes">
          <source>Note</source>
          <target>注</target>
        </trans-unit>
        <trans-unit id="4738934001095b56c8ba017549da8753b92711d7" translate="yes">
          <source>Note any tags which are not explicitly listed below (such as &lt;code&gt;@async&lt;/code&gt;) are not yet supported.</source>
          <target>以下に明示的にリストされていないタグ(&lt;code&gt;@async&lt;/code&gt;など)は、まだサポートされていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="034f4525d05999ff963000183c0ac076ec562336" translate="yes">
          <source>Note that &lt;code&gt;@enum&lt;/code&gt; is quite different from, and much simpler than, Typescript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt;. However, unlike Typescript&amp;rsquo;s enums, &lt;code&gt;@enum&lt;/code&gt; can have any type:</source>
          <target>&lt;code&gt;@enum&lt;/code&gt;は、Typescript&amp;rsquo;の&lt;code&gt;enum&lt;/code&gt;とはまったく異なり、はるかに単純です。ただし、Typescript&amp;rsquo;のenumsとは異なり、&lt;code&gt;@enum&lt;/code&gt;には任意の型を指定できます。</target>
        </trans-unit>
        <trans-unit id="a50c9eb18039f11d764d2dd9c6139bfa5f2ed615" translate="yes">
          <source>Note that &lt;code&gt;@extends&lt;/code&gt; only works with classes. Currently, there is no way for a constructor function extend a class.</source>
          <target>&lt;code&gt;@extends&lt;/code&gt;はクラスでのみ動作することに注意してください。 現在、コンストラクター関数でクラスを拡張する方法はありません。</target>
        </trans-unit>
        <trans-unit id="8a0526a2b13316a828fc44ba4c43a0a7de6c3d55" translate="yes">
          <source>Note that &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; are so useful, they are included in TypeScript&amp;rsquo;s standard library along with &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Record&lt;/code&gt;:</source>
          <target>&lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt;と&lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt;は非常に便利なので、&lt;code&gt;Pick&lt;/code&gt;と&lt;code&gt;Record&lt;/code&gt;とともにTypeScriptの標準ライブラリに含まれています。</target>
        </trans-unit>
        <trans-unit id="1258e6d6b1a495d8e56ed02d68cc95af53525487" translate="yes">
          <source>Note that &lt;code&gt;y&lt;/code&gt; has an extra &lt;code&gt;location&lt;/code&gt; property, but this does not create an error. Only members of the target type (&lt;code&gt;Named&lt;/code&gt; in this case) are considered when checking for compatibility.</source>
          <target>&lt;code&gt;y&lt;/code&gt;には、&lt;code&gt;location&lt;/code&gt;プロパティが追加されていますが、これによってエラーが発生することはありません。 互換性をチェックするときには、ターゲットタイプ(この場合は&lt;code&gt;Named&lt;/code&gt;)のメンバだけが考慮されます。</target>
        </trans-unit>
        <trans-unit id="52de29b3288a647d26453cfca4097defc33488b8" translate="yes">
          <source>Note that TypeScript treats &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; differently in order to match JavaScript semantics. &lt;code&gt;string | null&lt;/code&gt; is a different type than &lt;code&gt;string | undefined&lt;/code&gt; and &lt;code&gt;string | undefined | null&lt;/code&gt;.</source>
          <target>TypeScriptは、JavaScriptのセマンティクスと一致させるために、&lt;code&gt;null&lt;/code&gt;と&lt;code&gt;undefined&lt;/code&gt;を別々に扱うことに注意してください。 &lt;code&gt;string null&lt;/code&gt;は、&lt;code&gt;string undefined&lt;/code&gt;および&lt;code&gt;string undefined null&lt;/code&gt;とは異なる型です。</target>
        </trans-unit>
        <trans-unit id="fad3fa5b17d28ad4ad1296cea04ea7aae98a3e8a" translate="yes">
          <source>Note that as with &lt;code&gt;tsconfig.json&lt;/code&gt; / &lt;code&gt;-p&lt;/code&gt;, existing TypeScript project properties will not be respected - all settings should be managed using your tsconfig file.</source>
          <target>&lt;code&gt;tsconfig.json&lt;/code&gt;/&lt;code&gt;-p&lt;/code&gt;と同様に、既存のTypeScriptプロジェクトプロパティーは尊重されません。すべての設定は、tsconfigファイルを使用して管理する必要があります。</target>
        </trans-unit>
        <trans-unit id="b588c9ab272861e6d668b1d11af54118f839ddd3" translate="yes">
          <source>Note that global variables declared with &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; don&amp;rsquo;t show up on &lt;code&gt;globalThis&lt;/code&gt;.</source>
          <target>&lt;code&gt;const&lt;/code&gt;および&lt;code&gt;const&lt;/code&gt;で宣言されたグローバル変数は、&lt;code&gt;globalThis&lt;/code&gt;に表示されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f628326a2f77697a922d2fe82dda47c7b50dda0f" translate="yes">
          <source>Note that if &lt;code&gt;bar&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, our code will still hit an error accessing &lt;code&gt;baz&lt;/code&gt;. Likewise, if &lt;code&gt;baz&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, we&amp;rsquo;ll hit an error at the call site. &lt;code&gt;?.&lt;/code&gt; only checks for whether the value on the &lt;em&gt;left&lt;/em&gt; of it is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; - not any of the subsequent properties.</source>
          <target>&lt;code&gt;bar&lt;/code&gt;が&lt;code&gt;null&lt;/code&gt;または&lt;code&gt;undefined&lt;/code&gt;の場合は、&lt;code&gt;baz&lt;/code&gt;へのアクセス中にエラーが発生します。同様に、&lt;code&gt;baz&lt;/code&gt;が&lt;code&gt;null&lt;/code&gt;または&lt;code&gt;undefined&lt;/code&gt;の場合は、コールサイトでエラーが発生します。 &lt;code&gt;.&lt;/code&gt;は、その&lt;em&gt;左側の&lt;/em&gt;の値が&lt;code&gt;null&lt;/code&gt;であるか、&lt;code&gt;undefined&lt;/code&gt;であるかだけをチェックします。後続のプロパティはチェックしません。</target>
        </trans-unit>
        <trans-unit id="9bc1e2dc91d339a1731d988771c4e0964ee425ef" translate="yes">
          <source>Note that in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, when a homomorphic mapped type removes a &lt;code&gt;?&lt;/code&gt; modifier from a property in the underlying type it also removes &lt;code&gt;undefined&lt;/code&gt; from the type of that property:</source>
          <target>&lt;code&gt;--strictNullChecks&lt;/code&gt;モードでは、準同形写像型が基になる型のプロパティから&lt;code&gt;?&lt;/code&gt;修飾子を削除すると、そのプロパティの型から&lt;code&gt;undefined&lt;/code&gt;も削除されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="eea4e2c81bc66e020338b949c3e934f29a66e808" translate="yes">
          <source>Note that in TypeScript 1.4, when accessing an element outside the set of known indices, a union type is used instead:</source>
          <target>TypeScript1.4では、既知のインデックスの集合の外にある要素にアクセスする時、代わりにユニオン型が使われることに注意してください:</target>
        </trans-unit>
        <trans-unit id="739942391df257a53a10ec2f75e3c9725103c615" translate="yes">
          <source>Note that in this example, we added a value to the &lt;em&gt;static&lt;/em&gt; side of &lt;code&gt;C&lt;/code&gt; (its constructor function). This is because we added a &lt;em&gt;value&lt;/em&gt;, and the container for all values is another value (types are contained by namespaces, and namespaces are contained by other namespaces).</source>
          <target>この例では、&lt;code&gt;C&lt;/code&gt;(そのコンストラクター関数)の&lt;em&gt;static&lt;/em&gt;側に値を追加しています。 これは、&lt;em&gt;value&lt;/em&gt;を追加し、すべての値のコンテナが別の値であるためです(タイプは名前空間に含まれ、名前空間は他の名前空間に含まれます)。</target>
        </trans-unit>
        <trans-unit id="d0af180e34bef9f30805628b530dfa3020972dea" translate="yes">
          <source>Note that it&amp;rsquo;s possible to define many types in the global scope when writing a global declaration file. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.</source>
          <target>グローバル宣言ファイルを作成するときに、グローバルスコープに多くの型を定義できることに注意してください。 多くの宣言ファイルがプロジェクト内にある場合、解決できない名前の競合が発生する可能性があるので、これを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="907347b9fd2f8faa12df54e188fdcc427177ea81" translate="yes">
          <source>Note that parentheses are optional for union types.</source>
          <target>ユニオン型の場合、括弧はオプションです。</target>
        </trans-unit>
        <trans-unit id="4fabbe755152dc7983d25e5f9f36d98457b37c5e" translate="yes">
          <source>Note that partial overlap is still permitted as long as the property types are valid.</source>
          <target>プロパティタイプが有効である限り、部分的な重複は許可されます。</target>
        </trans-unit>
        <trans-unit id="cc68887371a320bc99d4047b11fa95c7b5bed915" translate="yes">
          <source>Note that relative module imports are not impacted by setting the baseUrl, as they are always resolved relative to their importing files.</source>
          <target>baseUrlを設定しても、相対的なモジュールのインポートは影響を受けないことに注意してください。これは、インポートするファイルに対して常に相対的に解決されるためです。</target>
        </trans-unit>
        <trans-unit id="7f7166fe564b0ad642ff41fe82fc874132e2ab74" translate="yes">
          <source>Note that the &lt;code&gt;"typings"&lt;/code&gt; field is synonymous with &lt;code&gt;"types"&lt;/code&gt;, and could be used as well.</source>
          <target>&lt;code&gt;"typings"&lt;/code&gt;フィールドは&lt;code&gt;"types"&lt;/code&gt;と同義であり、同様に使用できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4b2efe58a5ebfdb3d94ff74e3c4e2bfaf07628f5" translate="yes">
          <source>Note that the &lt;code&gt;function pickCard(x): any&lt;/code&gt; piece is not part of the overload list, so it only has two overloads: one that takes an object and one that takes a number. Calling &lt;code&gt;pickCard&lt;/code&gt; with any other parameter types would cause an error.</source>
          <target>&lt;code&gt;関数pickCard(x):any&lt;/code&gt;ピースはオーバーロードリストの一部ではないので、オブジェクトを取るものと数字を取るものの2つのオーバーロードしかないことに注意してください。 他のパラメータタイプで&lt;code&gt;pickCard&lt;/code&gt;を呼び出すと、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="d805d68393f371b58b5632620fd80bca6ffff116" translate="yes">
          <source>Note that this collapsing should only occur when all overloads have the same return type.</source>
          <target>この集約は、すべてのオーバーロードが同じリターンタイプを持つ場合にのみ発生することに注意してください。</target>
        </trans-unit>
        <trans-unit id="067bba3132c520df5de825dbb6713533d577f153" translate="yes">
          <source>Note that this does not imply tuples represent immutable arrays, but it is an implied convention.</source>
          <target>これはタプルが不変の配列を表すことを意味するのではなく、暗黙の規約であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="00c87ccc96ac44dfdeaad5b5ee7925bc2c9a2141" translate="yes">
          <source>Note that this is a breaking change for some code. If you need to resort to the original behavior in which tuples only enforce a minimum length, you can use a similar declaration that does not explicitly define a &lt;code&gt;length&lt;/code&gt; property, falling back to &lt;code&gt;number&lt;/code&gt;.</source>
          <target>一部のコードでは、これは重大な変更であることに注意してください。 タプルが最小長のみを強制するという元の動作に頼る必要がある場合は、&lt;code&gt;length&lt;/code&gt;プロパティを明示的に定義せずに、&lt;code&gt;number&lt;/code&gt;に戻る同様の宣言を使用できます。</target>
        </trans-unit>
        <trans-unit id="2da7ac7b1000043c557ae42f5143ae70cebcc452" translate="yes">
          <source>Note that this syntax describes a type rather than a member. If you want to add members, you can use an intersection type:</source>
          <target>この構文はメンバーではなく型を記述することに注意してください。 メンバーを追加する場合は、交差タイプを使用できます。</target>
        </trans-unit>
        <trans-unit id="24ee265701152c1f723e8f2dfcc2a5432fb8e8f0" translate="yes">
          <source>Note that this unwrapping inference only works on homomorphic mapped types. If the mapped type is not homomorphic you&amp;rsquo;ll have to give an explicit type parameter to your unwrapping function.</source>
          <target>このアンラッピング推論は準同形写像型に対してのみ作用することに注意。 マップされた型が準同型でない場合は、アンラップ関数に明示的な型パラメータを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="eead77930da9ed7756b7450464191e29579bb786" translate="yes">
          <source>Note that we cannot add to type aliases (&lt;code&gt;type s = string;&lt;/code&gt;) using an interface.</source>
          <target>インターフェースを使用して型別名(&lt;code&gt;type s=string;&lt;/code&gt;)に追加することはできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a04a128b4126a71144c52f15a922d0f362febded" translate="yes">
          <source>Note that we currently only support discriminant properties of string literal types. We intend to later add support for boolean and numeric literal types.</source>
          <target>現時点では、文字列リテラル型の識別特性のみをサポートしていることに注意してください。 後で、ブールおよび数値リテラル型のサポートを追加する予定です。</target>
        </trans-unit>
        <trans-unit id="8866bd22d60ec16a512c3e18fc8883ee9088f218" translate="yes">
          <source>Note that we didn&amp;rsquo;t make &lt;code&gt;b&lt;/code&gt; optional here because the return types of the signatures differ.</source>
          <target>ここでは&lt;code&gt;b&lt;/code&gt;をオプションにしていないことに注意してください。これは、シグネチャの戻り値の型が異なるためです。</target>
        </trans-unit>
        <trans-unit id="94ec1d6aab212f5e757f0e4659331e046f79564c" translate="yes">
          <source>Note that when a tuple type is inferred from a sequence of parameters and later expanded into a parameter list, as is the case for &lt;code&gt;U&lt;/code&gt;, the original parameter names are used in the expansion (however, the names have no semantic meaning and are not otherwise observable).</source>
          <target>&lt;code&gt;U&lt;/code&gt;の場合のように、一連のパラメータからタプル型が推論され、後でパラメータリストに展開される場合、元のパラメータ名が展開に使用されることに注意してください(ただし、これらの名前には意味的な意味はなく、他には見られません)。</target>
        </trans-unit>
        <trans-unit id="71b62ae2aa2aff8c7c71bbad8ff17968c2580e86" translate="yes">
          <source>Note that when using these flags together, TypeScript doesn&amp;rsquo;t necessarily have to downlevel &lt;code&gt;.js&lt;/code&gt; files. If you simply want TypeScript to create &lt;code&gt;.d.ts&lt;/code&gt; files, you can use the &lt;code&gt;--emitDeclarationOnly&lt;/code&gt; compiler option.</source>
          <target>これらのフラグを一緒に使用する場合、TypeScriptは&lt;code&gt;.js&lt;/code&gt;ファイルを必ずしも下位レベルにする必要はないことに注意してください。 TypeScriptで&lt;code&gt;.d.ts&lt;/code&gt;ファイルを作成するだけの場合は、&lt;code&gt;--emitDeclarationOnly&lt;/code&gt;コンパイラオプションを使用できます。</target>
        </trans-unit>
        <trans-unit id="d88437440fe56ffd946a572ef7fc0f549aafede2" translate="yes">
          <source>Note that while this example uses &lt;a href="https://reactjs.org/docs/components-and-props.html#functional-and-class-components"&gt;function components&lt;/a&gt;, we could also make our example a little &lt;em&gt;classier&lt;/em&gt; as well.</source>
          <target>この例では&lt;a href="https://reactjs.org/docs/components-and-props.html#functional-and-class-components"&gt;関数コンポーネント&lt;/a&gt;を使用していますが、&lt;em&gt;少しクラス&lt;/em&gt;にすることもできます。</target>
        </trans-unit>
        <trans-unit id="f4126eba79591c06a88ec80a2218d901b6a7fced" translate="yes">
          <source>Note: &lt;code&gt;"ESNext"&lt;/code&gt; targets latest supported</source>
          <target>注:&lt;code&gt;"ESNext"&lt;/code&gt;は、サポートされている最新のターゲットです。</target>
        </trans-unit>
        <trans-unit id="00f6312a7e060d93f44452f049fdc1698e20c055" translate="yes">
          <source>Note: &lt;code&gt;"ESNext"&lt;/code&gt; targets latest supported &lt;a href="https://github.com/tc39/proposals"&gt;ES proposed features&lt;/a&gt;.</source>
          <target>注:&lt;code&gt;"ESNext"&lt;/code&gt;は、サポートされている最新の&lt;a href="https://github.com/tc39/proposals"&gt;ES提案機能&lt;/a&gt;を対象としています。</target>
        </trans-unit>
        <trans-unit id="eff587a71ddbf90b7c884baa1aa1a82827ace5dd" translate="yes">
          <source>Note: Avoid using &lt;code&gt;Object&lt;/code&gt; in favor of the non-primitive &lt;code&gt;object&lt;/code&gt; type as described in our &lt;a href="declaration-files/do-s-and-don-ts#general-types"&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt; section.</source>
          <target>注意:&lt;a href="declaration files/do s and don ts#general types"&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt;セクションで説明しているように、&lt;code&gt;Object&lt;/code&gt;をプリミティブではない&lt;code&gt;object&lt;/code&gt;タイプに使用しないでください。</target>
        </trans-unit>
        <trans-unit id="c1444747b0861651e319b205e1c59d9ae374ba31" translate="yes">
          <source>Note: Function Components were formerly known as Stateless Function Components (SFC). As Function Components can no longer be considered stateless in recent versions of react, the type &lt;code&gt;SFC&lt;/code&gt; and its alias &lt;code&gt;StatelessComponent&lt;/code&gt; were deprecated.</source>
          <target>注:関数コンポーネントは、以前はステートレス関数コンポーネント(SFC)と呼ばれていました。 reactの最近のバージョンでは、関数コンポーネントはステートレスではないと見なされないため、型&lt;code&gt;SFC&lt;/code&gt;とそのエイリアス&lt;code&gt;StatelessComponent&lt;/code&gt;は廃止されました。</target>
        </trans-unit>
        <trans-unit id="2167c13fca90fe94989b38585bc930d77ebf1308" translate="yes">
          <source>Note: If &lt;code&gt;--lib&lt;/code&gt; is not specified a default list of libraries are injected. The default libraries injected are:</source>
          <target>注:&lt;code&gt;--lib&lt;/code&gt;が指定されていない場合、ライブラリのデフォルトリストが注入されます。 デフォルトのライブラリは以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="284acafdfa85eadac42feff0fa8aca15b6a97293" translate="yes">
          <source>Note: If an attribute name is not a valid JS identifier (like a &lt;code&gt;data-*&lt;/code&gt; attribute), it is not considered to be an error if it is not found in the element attributes type.</source>
          <target>注意:属性名が有効なJS識別子でない場合(&lt;code&gt;data-*&lt;/code&gt;属性のように)、要素属性タイプで見つからなければエラーとは見なされません。</target>
        </trans-unit>
        <trans-unit id="e941b79a012efff59ecdd0cbaa4fcd9aa032b565" translate="yes">
          <source>Note: Most changes do not require you to install a new version of the VS TypeScript plugin.</source>
          <target>注:ほとんどの変更では、VS TypeScriptプラグインの新しいバージョンをインストールする必要はありません。</target>
        </trans-unit>
        <trans-unit id="70970313d46e20ac27b9140a27eba7644c3d73af" translate="yes">
          <source>Note: Previous syntax defining internal modules are still supported.</source>
          <target>注:内部モジュールを定義する以前の構文は引き続きサポートされます。</target>
        </trans-unit>
        <trans-unit id="98d80fe98cbbdfa6ce68828aed81191aecaa3aa8" translate="yes">
          <source>Note: The &lt;code&gt;Exclude&lt;/code&gt; type is a proper implementation of the &lt;code&gt;Diff&lt;/code&gt; type suggested &lt;a href="https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458"&gt;here&lt;/a&gt;. We&amp;rsquo;ve used the name &lt;code&gt;Exclude&lt;/code&gt; to avoid breaking existing code that defines a &lt;code&gt;Diff&lt;/code&gt;, plus we feel that name better conveys the semantics of the type.</source>
          <target>注意:&lt;code&gt;Exclude&lt;/code&gt;タイプは、&lt;a href="https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458"&gt;ここ&lt;/a&gt;で推奨されている&lt;code&gt;Diff&lt;/code&gt;タイプの適切な実装です。 &lt;code&gt;Exclude&lt;/code&gt;という名前を使用して、&lt;code&gt;Diff&lt;/code&gt;を定義する既存のコードを壊さないようにしました。また、この名前の方が型のセマンティクスをうまく伝えると思います。</target>
        </trans-unit>
        <trans-unit id="3b301e8bc42764dd4dd4644d5e8e453ac7e989ae" translate="yes">
          <source>Note: The &lt;code&gt;Exclude&lt;/code&gt; type is a proper implementation of the &lt;code&gt;Diff&lt;/code&gt; type suggested &lt;a href="https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458"&gt;here&lt;/a&gt;. We&amp;rsquo;ve used the name &lt;code&gt;Exclude&lt;/code&gt; to avoid breaking existing code that defines a &lt;code&gt;Diff&lt;/code&gt;, plus we feel that name better conveys the semantics of the type. We did not include the &lt;code&gt;Omit&amp;lt;T, K&amp;gt;&lt;/code&gt; type because it is trivially written as &lt;code&gt;Pick&amp;lt;T, Exclude&amp;lt;keyof T, K&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target>注意:&lt;code&gt;Exclude&lt;/code&gt;タイプは、&lt;a href="https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458"&gt;ここ&lt;/a&gt;で推奨されている&lt;code&gt;Diff&lt;/code&gt;タイプの適切な実装です。 &lt;code&gt;Exclude&lt;/code&gt;という名前を使用して、&lt;code&gt;Diff&lt;/code&gt;を定義する既存のコードを壊さないようにしました。また、この名前の方が型のセマンティクスをうまく伝えると思います。 &lt;code&gt;Omit&amp;lt;T,K&amp;gt;&lt;/code&gt;タイプは、&lt;code&gt;Pick&amp;lt;T,Exclude&amp;lt;keyof T,K&amp;gt;&amp;gt;&lt;/code&gt;と簡単に記述されているため、ここでは含めていません。</target>
        </trans-unit>
        <trans-unit id="890949cc49cb65675bbdc6a302bba418a9f75399" translate="yes">
          <source>Note: The new behavior is added under a flag to avoid unwarranted breaks to existing code bases. &lt;strong&gt;We highly recommend applying it both to new and existing projects.&lt;/strong&gt; For existing projects, namespace imports (&lt;code&gt;import * as express from "express"; express();&lt;/code&gt;) will need to be converted to default imports (&lt;code&gt;import express from "express"; express();&lt;/code&gt;).</source>
          <target>注:新しい動作は、既存のコードベースへの不当なブレークを避けるためにフラグの下に追加されます。 &lt;strong&gt;新しいプロジェクトと既存のプロジェクトの両方に適用することを強くお勧めします。&lt;/strong&gt;既存のプロジェクトでは、名前空間のインポート(&lt;code&gt;import*as express from"express";express();&lt;/code&gt;)をデフォルトのインポート(&lt;code&gt;import express from";express();&lt;/code&gt;)に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="1ed11ffc3601c3d16f34bfee2955149b8374ad13" translate="yes">
          <source>Note: This change brings a new emit helper, &lt;code&gt;__makeTemplateObject&lt;/code&gt;; if you are using &lt;code&gt;--importHelpers&lt;/code&gt; with &lt;a href="https://github.com/Microsoft/tslib"&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt;, an updated to version 1.8 or later.</source>
          <target>注:この変更により、新しいエミットヘルパー&lt;code&gt;__makeTemplateObject&lt;/code&gt;が導入されます。&lt;code&gt;--importHelpers&lt;/code&gt;を&lt;a href="https://github.com/Microsoft/tslib"&gt;&lt;code&gt;ツリブ&lt;/code&gt;&lt;/a&gt;で使用している場合は、バージョン1.8以降に更新されます。</target>
        </trans-unit>
        <trans-unit id="f9c2b580006a52af1ed6b77bbd97ca85b4b1524b" translate="yes">
          <source>Note: This type only works correctly if &lt;code&gt;--strictFunctionTypes&lt;/code&gt; is enabled. See &lt;a href="https://github.com/microsoft/TypeScript/issues/32964"&gt;#32964&lt;/a&gt;.</source>
          <target>注意:このタイプは、&lt;code&gt;--strictFunctionTypes&lt;/code&gt;が有効な場合にのみ正しく動作します。&lt;a href="https://github.com/microsoft/TypeScript/issues/32964"&gt;#32964&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="df7f583105fdd881893e583d6f13dbb72c16aa47" translate="yes">
          <source>Note: You can also specify a catch-all string indexer on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; as follows:</source>
          <target>注意:次のように&lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;でキャッチオール文字列インデクサを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="86b84c8f5ebae0249a61b0e8be7e70f077917ea7" translate="yes">
          <source>Note: You&amp;rsquo;ll need to configure your project to use the NuGet packages. Please see &lt;a href="https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet"&gt;Configuring MSBuild projects to use NuGet&lt;/a&gt; for more information.</source>
          <target>注:NuGetパッケージを使用するようにプロジェクトを設定する必要があります。 詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet"&gt;Configuring MSBuild projects to use NuGet&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="428e262209f33a2ca2447240e01cc6cf696d81da" translate="yes">
          <source>Note: first, we need to make sure our run-time has an ECMAScript-compliant &lt;code&gt;Promise&lt;/code&gt; available globally. That might involve grabbing &lt;a href="https://github.com/stefanpenner/es6-promise"&gt;a polyfill&lt;/a&gt; for &lt;code&gt;Promise&lt;/code&gt;, or relying on one that you might have in the run-time that you&amp;rsquo;re targeting. We also need to make sure that TypeScript knows &lt;code&gt;Promise&lt;/code&gt; exists by setting your &lt;code&gt;lib&lt;/code&gt; flag to something like &lt;code&gt;"dom", "es2015"&lt;/code&gt; or &lt;code&gt;"dom", "es2015.promise", "es5"&lt;/code&gt;</source>
          <target>注意:まず、ランタイムがECMAScript準拠の&lt;code&gt;Promise&lt;/code&gt;をグローバルに利用できるようにする必要があります。 これには、&lt;code&gt;Promise&lt;/code&gt;のために&lt;a href="https://github.com/stefanpenner/es6-promise"&gt;ポリフィル&lt;/a&gt;を取得することや、ターゲットにするランタイムにあるポリフィルに依存することが含まれます。 また、&lt;code&gt;lib&lt;/code&gt;フラグを&lt;code&gt;"dom","es2015"&lt;/code&gt;または&lt;code&gt;"dom","es2015.promise","es5"&lt;/code&gt;のような値に設定して、TypeScriptが&lt;code&gt;Promise&lt;/code&gt;を認識していることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="8ccce25f4f717ae800fc16f144d50c248273d87f" translate="yes">
          <source>Note: if the declaration file you are searching for is not present, you can always contribute one back and help out the next developer looking for it. Please see the DefinitelyTyped &lt;a href="http://definitelytyped.org/guides/contributing.html"&gt;contribution guidelines page&lt;/a&gt; for details.</source>
          <target>注意:探している宣言ファイルが存在しない場合は、いつでもそのファイルを提供して、次にそれを探している開発者を助けることができます。 詳細については、DefinitelyTyped&lt;a href="http://definitelytyped.org/guides/contributing.html"&gt;contribution guidelines page&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7e6e74755e762c4957a748b815736bf13786cbb4" translate="yes">
          <source>Notice how we dropped &lt;code&gt;theName&lt;/code&gt; altogether and just use the shortened &lt;code&gt;readonly name: string&lt;/code&gt; parameter on the constructor to create and initialize the &lt;code&gt;name&lt;/code&gt; member. We&amp;rsquo;ve consolidated the declarations and assignment into one location.</source>
          <target>&lt;code&gt;theName&lt;/code&gt;を完全に削除し、コンストラクタで&lt;code&gt;readonly name:string&lt;/code&gt;パラメータを使用して&lt;code&gt;name&lt;/code&gt;メンバを作成し、初期化したことに注目してください。 宣言と割り当てを1つの場所にまとめました。</target>
        </trans-unit>
        <trans-unit id="6a85b01a3af32d42a46518c09152775637f852de" translate="yes">
          <source>Notice that &lt;code&gt;T&lt;/code&gt; has been propagated from &lt;code&gt;makeArray&lt;/code&gt; into the resulting type&amp;rsquo;s type parameter list. This means that genericity from &lt;code&gt;compose&lt;/code&gt;&amp;rsquo;s arguments has been preserved and our &lt;code&gt;makeBoxedArray&lt;/code&gt; sample will just work!</source>
          <target>&lt;code&gt;T&lt;/code&gt;が&lt;code&gt;makeArray&lt;/code&gt;から結果の型のパラメータリストに伝達されたことに注目してください。 これは、&lt;code&gt;compose&lt;/code&gt;&amp;rsquo;の引数の汎用性が保持され、&lt;code&gt;makeBoxedArray&lt;/code&gt;サンプルが正常に動作することを意味します。</target>
        </trans-unit>
        <trans-unit id="a26aafd348bc0fd9af2fe643fb8a471bed279231" translate="yes">
          <source>Notice that &lt;code&gt;T&lt;/code&gt; has the additional constraint &lt;code&gt;any[]&lt;/code&gt; within the true branch of &lt;code&gt;Boxed&amp;lt;T&amp;gt;&lt;/code&gt; and it is therefore possible to refer to the element type of the array as &lt;code&gt;T[number]&lt;/code&gt;. Also, notice how the conditional type is distributed over the union type in the last example.</source>
          <target>&lt;code&gt;T&lt;/code&gt;には、&lt;code&gt;Boxed&amp;lt;T&amp;gt;&lt;/code&gt;の真の分岐内に追加の制約&lt;code&gt;any[]&lt;/code&gt;があることに注意してください。したがって、配列の要素型を&lt;code&gt;T[number]&lt;/code&gt;と呼ぶことができます。また、最後の例では、条件型がユニオン型にどのように分散されているかにも注意してください。</target>
        </trans-unit>
        <trans-unit id="10af1f3e49765726e808fd41e23133e1c2a4e7ed" translate="yes">
          <source>Notice that &lt;code&gt;createCardPicker&lt;/code&gt; is a function that itself returns a function. If we tried to run the example, we would get an error instead of the expected alert box. This is because the &lt;code&gt;this&lt;/code&gt; being used in the function created by &lt;code&gt;createCardPicker&lt;/code&gt; will be set to &lt;code&gt;window&lt;/code&gt; instead of our &lt;code&gt;deck&lt;/code&gt; object. That&amp;rsquo;s because we call &lt;code&gt;cardPicker()&lt;/code&gt; on its own. A top-level non-method syntax call like this will use &lt;code&gt;window&lt;/code&gt; for &lt;code&gt;this&lt;/code&gt;. (Note: under strict mode, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; rather than &lt;code&gt;window&lt;/code&gt;).</source>
          <target>&lt;code&gt;createCardPicker&lt;/code&gt;は関数を返す関数であることに注意してください。 この例を実行しようとすると、予期した警告ボックスの代わりにエラーが表示されます。 これは、&lt;code&gt;deck&lt;/code&gt;オブジェクトではなく、&lt;code&gt;createCardPicker&lt;/code&gt;によって作成された関数で使用されている&lt;code&gt;this&lt;/code&gt;が&lt;code&gt;window&lt;/code&gt;に設定されるためです。 これは、&lt;code&gt;cardPicker()&lt;/code&gt;を単独で呼び出すためです。 メソッド以外のトップレベルの構文呼び出しでは、この&lt;/code&gt;に&lt;code&gt;window&lt;/code&gt;を使用します(注意:strictモードでは、この&lt;/code&gt;は&lt;code&gt;window&lt;/code&gt;ではなく&lt;code&gt;undefined&lt;/code&gt;になります)。</target>
        </trans-unit>
        <trans-unit id="763a205d6a7b4e6716dbfe0467c7193103f61a5d" translate="yes">
          <source>Notice that &lt;code&gt;uglify&lt;/code&gt; itself has just one call &amp;mdash; the calls to &lt;code&gt;buffer&lt;/code&gt; and &lt;code&gt;sourcemaps&lt;/code&gt; exist to make sure sourcemaps keep working. These calls give us a separate sourcemap file instead of using inline sourcemaps like before. Now you can run Gulp and check that &lt;code&gt;bundle.js&lt;/code&gt; does get minified into an unreadable mess:</source>
          <target>&lt;code&gt;uglify&lt;/code&gt;自体には1つの呼び出ししかないことに注意してください。&lt;code&gt;buffer&lt;/code&gt;および&lt;code&gt;sourcemaps&lt;/code&gt;への呼び出しは、ソースマップが動作し続けるようにするために存在します。 これらの呼び出しは、以前のようにインラインのソースマップを使用する代わりに、別のソースマップファイルを提供します。 これでGulpを実行して、&lt;code&gt;bundle.js&lt;/code&gt;が判読不能な混乱に陥っていないかチェックできる。</target>
        </trans-unit>
        <trans-unit id="9840073ae62b539ce3e1ebbfd27d812a30288a78" translate="yes">
          <source>Notice that Node.js jumped up a directory in steps (4) and (7).</source>
          <target>Node.jsがステップ(4)と(7)でディレクトリをジャンプしたことに注目してください。</target>
        </trans-unit>
        <trans-unit id="ab4bf996704c0896075b225907ab9de7984c49ba" translate="yes">
          <source>Notice that TypeScript not only knows that &lt;code&gt;pet&lt;/code&gt; is a &lt;code&gt;Fish&lt;/code&gt; in the &lt;code&gt;if&lt;/code&gt; branch; it also knows that in the &lt;code&gt;else&lt;/code&gt; branch, you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; have a &lt;code&gt;Fish&lt;/code&gt;, so you must have a &lt;code&gt;Bird&lt;/code&gt;.</source>
          <target>TypeScriptは、&lt;code&gt;pet&lt;/code&gt;が&lt;code&gt;if&lt;/code&gt;分岐の&lt;code&gt;Fish&lt;/code&gt;であることを認識するだけでなく、&lt;code&gt;else&lt;/code&gt;分岐の&lt;em&gt;don&amp;rsquo;t&lt;/em&gt;が&lt;code&gt;Fish&lt;/code&gt;を持っていることを認識するので、&lt;code&gt;Bird&lt;/code&gt;を持っている必要があります。</target>
        </trans-unit>
        <trans-unit id="cb0aa408a6fabdf5fe7f3f24ac365f674b565f27" translate="yes">
          <source>Notice that although there were errors, the &lt;code&gt;greeter.js&lt;/code&gt; file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.</source>
          <target>エラーはありましたが、&lt;code&gt;greeter.js&lt;/code&gt;ファイルはまだ作成されています。 コードにエラーがある場合でも、TypeScriptを使用できます。 しかし、この場合、TypeScriptはコードが期待どおりに実行されない可能性があることを警告します。</target>
        </trans-unit>
        <trans-unit id="f262e26dd39e3b5a66a391868d3fb9f6d6e5738f" translate="yes">
          <source>Notice that even though we used ES2015 module syntax, TypeScript emitted CommonJS modules that Node uses. We&amp;rsquo;ll stick with CommonJS for this tutorial, but you could set &lt;code&gt;module&lt;/code&gt; in the options object to change this.</source>
          <target>ここではES2015モジュール構文を使用しましたが、TypeScriptはNodeが使用するCommonJSモジュールを生成しました。 このチュートリアルではCommonJSを使用しますが、これを変更するにはオプションオブジェクトで&lt;code&gt;module&lt;/code&gt;を設定します。</target>
        </trans-unit>
        <trans-unit id="6426330771f7083cfd35796802456c49f5b66b69" translate="yes">
          <source>Notice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use &lt;code&gt;GenericIdentityFn&lt;/code&gt;, we now will also need to specify the corresponding type argument (here: &lt;code&gt;number&lt;/code&gt;), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.</source>
          <target>ここで示した例は、少し変わっています。 総称関数を記述する代わりに、総称型の一部である非総称関数シグネチャを使用します。 &lt;code&gt;GenericIdentityFn&lt;/code&gt;を使用する場合は、対応する型引数(ここでは&lt;code&gt;number&lt;/code&gt;)も指定する必要があります。これにより、基になる呼び出しシグネチャで使用されるものが事実上固定されます。 型パラメータをいつコールシグネチャに直接置くべきか、いつそれをインターフェース自体に置くべきかを理解することは、型のどの側面が一般的かを記述する上で有用である。</target>
        </trans-unit>
        <trans-unit id="9bb1da98b82bb82ebbe555bd6d19c0a036a3fa15" translate="yes">
          <source>Notice that the elements of each group maintains the same order, but the groups themselves are merged with later overload sets ordered first.</source>
          <target>各グループの要素は同じ順序を維持しますが、グループ自体は最初に順序付けされた後のオーバーロード・セットとマージされます。</target>
        </trans-unit>
        <trans-unit id="765da565a7c17cfcf3312a5eda7111c42ee0f02e" translate="yes">
          <source>Notice that we didn&amp;rsquo;t have to explicitly pass the type in the angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;); the compiler just looked at the value &lt;code&gt;"myString"&lt;/code&gt;, and set &lt;code&gt;T&lt;/code&gt; to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.</source>
          <target>山括弧(&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;)に型を明示的に渡す必要はありませんでした。コンパイラは値&lt;code&gt;"myString"&lt;/code&gt;を見て、&lt;code&gt;T&lt;/code&gt;をその型に設定します。 型引数の推論はコードを短くして読みやすくするのに役立つツールですが、より複雑な例のように、コンパイラが型の推論に失敗した場合には、前の例のように型引数を明示的に渡す必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e2786dc0fc7753238adaa3b182c5756666dbd537" translate="yes">
          <source>Notice that we don&amp;rsquo;t use the &lt;code&gt;require&lt;/code&gt; keyword; instead we assign directly from the qualified name of the symbol we&amp;rsquo;re importing. This is similar to using &lt;code&gt;var&lt;/code&gt;, but also works on the type and namespace meanings of the imported symbol. Importantly, for values, &lt;code&gt;import&lt;/code&gt; is a distinct reference from the original symbol, so changes to an aliased &lt;code&gt;var&lt;/code&gt; will not be reflected in the original variable.</source>
          <target>&lt;code&gt;require&lt;/code&gt;キーワードは使用せず、代わりにインポートするシンボルの修飾名から直接割り当てます。 これは&lt;code&gt;var&lt;/code&gt;の使用に似ていますが、インポートされたシンボルの型と名前空間の意味にも影響します。 重要なことは、値の場合、&lt;code&gt;import&lt;/code&gt;は元のシンボルとは別の参照であるため、エイリアスされた&lt;code&gt;var&lt;/code&gt;への変更は元の変数に反映されません。</target>
        </trans-unit>
        <trans-unit id="5474e3c4f0295fff5cf94b925d396e756aa6518e" translate="yes">
          <source>Notice that we had to surround this statement with parentheses. JavaScript normally parses a &lt;code&gt;{&lt;/code&gt; as the start of block.</source>
          <target>この文を括弧で囲む必要があることに注意してください。 JavaScriptは通常、ブロックの開始として&lt;code&gt;{&lt;/code&gt;を解析します。</target>
        </trans-unit>
        <trans-unit id="f3a80c95c92964743c3a7674b186fd203447952a" translate="yes">
          <source>Notice that we had to use type assertions several times. It would be much better if once we performed the check, we could know the type of &lt;code&gt;pet&lt;/code&gt; within each branch.</source>
          <target>型アサーションを何度も使用する必要があることに注意してください。 一度チェックをしたら、各ブランチ内の&lt;code&gt;pet&lt;/code&gt;のタイプがわかっていれば、さらによいでしょう。</target>
        </trans-unit>
        <trans-unit id="f1d22a5b64c25dc62cca8b1fc9ad531fb98be848" translate="yes">
          <source>Notice that we installed TypeScript as a development dependency. We could also have linked TypeScript to a global copy with &lt;code&gt;npm link typescript&lt;/code&gt;, but this is a less common scenario.</source>
          <target>開発依存関係としてTypeScriptをインストールしたことに注目してください。 &lt;code&gt;npm link typescript&lt;/code&gt;を使ってTypeScriptをグローバルコピーにリンクすることもできますが、これはあまり一般的ではありません。</target>
        </trans-unit>
        <trans-unit id="e83cd308da6a35cefd1d54ccc96691cc920beea5" translate="yes">
          <source>Notice that we specified &lt;code&gt;debug: true&lt;/code&gt; to Browserify. This causes tsify to emit source maps inside the bundled JavaScript file. Source maps let you debug your original TypeScript code in the browser instead of the bundled JavaScript. You can test that source maps are working by opening the debugger for your browser and putting a breakpoint inside &lt;code&gt;main.ts&lt;/code&gt;. When you refresh the page the breakpoint should pause the page and let you debug &lt;code&gt;greet.ts&lt;/code&gt;.</source>
          <target>&lt;code&gt;debug:true&lt;/code&gt;をBrowserifyに指定したことに注目してください。 これにより、ツーフィはバンドルされたJavaScriptファイル内にソースマップを生成します。 ソースマップでは、バンドルされたJavaScriptの代わりにブラウザでオリジナルのTypeScriptコードをデバッグできます。 ブラウザのデバッガを開き、&lt;code&gt;main.ts&lt;/code&gt;内にブレークポイントを置くと、ソースマップが動作していることをテストできます。ページを更新すると、ブレークポイントによってページが一時停止し、&lt;code&gt;greet.ts&lt;/code&gt;をデバッグできるようになります。</target>
        </trans-unit>
        <trans-unit id="67d48d2666a5c7a992a5ba5ca0e49f58d31d4a07" translate="yes">
          <source>Notice that we&amp;rsquo;re including files from within &lt;code&gt;node_modules&lt;/code&gt;. React and React-DOM&amp;rsquo;s npm packages include standalone &lt;code&gt;.js&lt;/code&gt; files that you can include in a web page, and we&amp;rsquo;re referencing them directly to get things moving faster. Feel free to copy these files to another directory, or alternatively, host them on a content delivery network (CDN). Facebook makes CDN-hosted versions of React available, and you can &lt;a href="http://facebook.github.io/react/downloads.html#development-vs.-production-builds"&gt;read more about that here&lt;/a&gt;.</source>
          <target>&lt;code&gt;node_modules&lt;/code&gt;内のファイルを含むことに注意してください。 React and React DOM&amp;rsquo;のnpmパッケージには、スタンドアロンの&lt;code&gt;.js&lt;/code&gt;ファイルが含まれています。これらのファイルをWebページに含めることができます。また、これらのファイルを直接参照して、処理を高速化できます。 これらのファイルは、別のディレクトリに自由にコピーできます。または、コンテンツ配信ネットワーク(CDN)でホストすることもできます。 FacebookはCDNでホストされるバージョンのReactを提供しており、その詳細については&lt;a href="http://facebook.github.io/react/downloads.html#development-vs.-production-builds"&gt;こちら&lt;/a&gt;で読むことができる。</target>
        </trans-unit>
        <trans-unit id="b09f5734b53cfac68ac359e515430d1247899638" translate="yes">
          <source>Notice that while we can&amp;rsquo;t use &lt;code&gt;name&lt;/code&gt; from outside of &lt;code&gt;Person&lt;/code&gt;, we can still use it from within an instance method of &lt;code&gt;Employee&lt;/code&gt; because &lt;code&gt;Employee&lt;/code&gt; derives from &lt;code&gt;Person&lt;/code&gt;.</source>
          <target>&lt;code&gt;Person&lt;/code&gt;の外部から&lt;code&gt;name&lt;/code&gt;を使用することはできませんが、&lt;code&gt;Employee&lt;/code&gt;は&lt;code&gt;Person&lt;/code&gt;から派生するため、&lt;code&gt;Employee&lt;/code&gt;のインスタンス・メソッド内から使用することはできます。</target>
        </trans-unit>
        <trans-unit id="057539fc62c3a3433f309ba4576e4667a469ea4a" translate="yes">
          <source>Notice the above needed no type annotations. The &lt;code&gt;const&lt;/code&gt; assertion allowed TypeScript to take the most specific type of the expression.</source>
          <target>上の例では、タイプ注釈は必要ありません。 &lt;code&gt;const&lt;/code&gt;アサーションによって、TypeScriptは式の最も具体的な型を取ることができた。</target>
        </trans-unit>
        <trans-unit id="f321483ba4f94eea3586e9078b133451c9b94b14" translate="yes">
          <source>Notice the given argument to &lt;code&gt;createSquare&lt;/code&gt; is spelled &lt;em&gt;&lt;code&gt;colour&lt;/code&gt;&lt;/em&gt; instead of &lt;code&gt;color&lt;/code&gt;. In plain JavaScript, this sort of thing fails silently.</source>
          <target>&lt;code&gt;createSquare&lt;/code&gt;に対する引数のスペルが、&lt;code&gt;color&lt;/code&gt;ではなく&lt;em&gt;&lt;code&gt;color&lt;/code&gt;&lt;/em&gt;であることに注意してください。単純なJavaScriptでは、この種の処理は自動的に失敗します。</target>
        </trans-unit>
        <trans-unit id="449041a6d7a9b6fc7d3b8e6410b5c6cd0fde878b" translate="yes">
          <source>Now &lt;code&gt;search&lt;/code&gt; is &lt;code&gt;{ food: "rich", price: "$$", ambiance: "noisy" }&lt;/code&gt;. Object spreading is more complex than array spreading. Like array spreading, it proceeds from left-to-right, but the result is still an object. This means that properties that come later in the spread object overwrite properties that come earlier. So if we modify the previous example to spread at the end:</source>
          <target>&lt;code&gt;search&lt;/code&gt;は&lt;code&gt;{food:"rich",price:"$$",ambance:"noisy"}&lt;/code&gt;です。オブジェクトの分散は配列の分散よりも複雑です。 配列の展開と同様に、左から右に処理を進めますが、結果はオブジェクトのままです。 つまり、スプレッドオブジェクトの後の方にあるプロパティは、前の方にあるプロパティを上書きします。 前の例を最後に展開するように修正すると</target>
        </trans-unit>
        <trans-unit id="db8e5588d2d1057026cfc4a79854c4482517ae14" translate="yes">
          <source>Now TypeScript knows that &lt;code&gt;createCardPicker&lt;/code&gt; expects to be called on a &lt;code&gt;Deck&lt;/code&gt; object. That means that &lt;code&gt;this&lt;/code&gt; is of type &lt;code&gt;Deck&lt;/code&gt; now, not &lt;code&gt;any&lt;/code&gt;, so &lt;code&gt;--noImplicitThis&lt;/code&gt; will not cause any errors.</source>
          <target>これでTypeScriptは、&lt;code&gt;createCardPicker&lt;/code&gt;が&lt;code&gt;Deck&lt;/code&gt;オブジェクトで呼び出されることを認識します。 つまり、&lt;code&gt;this&lt;/code&gt;は&lt;code&gt;deck&lt;/code&gt;型であり、&lt;code&gt;any&lt;/code&gt;ではないので、&lt;code&gt;-noImplicitThis&lt;/code&gt;はエラーを引き起こさない。</target>
        </trans-unit>
        <trans-unit id="1bb4e738e148009f79ea8206746e9d01e2ac6c80" translate="yes">
          <source>Now change &lt;code&gt;main.ts&lt;/code&gt; to update the page:</source>
          <target>&lt;code&gt;main.ts&lt;/code&gt;を変更してページを更新します。</target>
        </trans-unit>
        <trans-unit id="19f45556bb4ffb06e428f0775fa838cee98426d1" translate="yes">
          <source>Now change the code in &lt;code&gt;src/main.ts&lt;/code&gt; to import &lt;code&gt;sayHello&lt;/code&gt; from &lt;code&gt;greet.ts&lt;/code&gt;:</source>
          <target>&lt;code&gt;src/main.ts&lt;/code&gt;のコードを&lt;code&gt;greet.ts&lt;/code&gt;から&lt;code&gt;sayHello&lt;/code&gt;をインポートするように変更します。</target>
        </trans-unit>
        <trans-unit id="bc972ac7f876ddb230eb09fff1d371c82cba09d1" translate="yes">
          <source>Now change your gulpfile to the following:</source>
          <target>ガルプフィルを次のように変更します。</target>
        </trans-unit>
        <trans-unit id="d5e91337836080850365ec1adb6a6e22456b494f" translate="yes">
          <source>Now if you annotate calling code with &lt;code&gt;this&lt;/code&gt;:</source>
          <target>次に、&lt;code&gt;this&lt;/code&gt;で呼び出しコードに注釈を付けるとします。</target>
        </trans-unit>
        <trans-unit id="ce21fbd716cb22501e3b77ae211a67a20a5b69a6" translate="yes">
          <source>Now imports to &lt;code&gt;"moduleA"&lt;/code&gt; would be looked up in &lt;code&gt;./modules/moduleA&lt;/code&gt;</source>
          <target>&lt;code&gt;"moduleA"&lt;/code&gt;へのインポートは、&lt;code&gt;./modules/moduleA&lt;/code&gt;で検索されます。</target>
        </trans-unit>
        <trans-unit id="7bb24a6d01809ab25d994975acd19c2bdf7782ca" translate="yes">
          <source>Now let&amp;rsquo;s look at how return types are treated, using two functions that differ only by their return type:</source>
          <target>次に、戻り値の型だけが異なる2つの関数を使用して、戻り値の型がどのように扱われるかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="cfc81a9edf6b5df21e2f8d967d810f4429dddd90" translate="yes">
          <source>Now let&amp;rsquo;s move this project from Node to the browser. To do this, we&amp;rsquo;d like to bundle all our modules into one JavaScript file. Fortunately, that&amp;rsquo;s exactly what Browserify does. Even better, it lets us use the CommonJS module system used by Node, which is the default TypeScript emit. That means our TypeScript and Node setup will transfer to the browser basically unchanged.</source>
          <target>次に、このプロジェクトをノードからブラウザに移動します。 そのためには、すべてのモジュールを1つのJavaScriptファイルにバンドルします。 幸いなことに、これはまさにBrowserifyがやっていることだ。 さらに良いことに、Nodeで使われているCommonJSモジュールシステムを使うことができます。 つまり、TypeScriptとNodeの設定は基本的にそのままブラウザに転送される。</target>
        </trans-unit>
        <trans-unit id="f2ff6a3f3742717cb814ea8ff8b733c8987d4bca" translate="yes">
          <source>Now let&amp;rsquo;s use the discriminated union:</source>
          <target>次に、差別化された和集合を使用します:</target>
        </trans-unit>
        <trans-unit id="ff37331bf4adb180113ce3c6cbbb96618f575e44" translate="yes">
          <source>Now open up &lt;code&gt;index.html&lt;/code&gt; in your favorite browser and everything should be ready to use! You should see a page that says &amp;ldquo;Hello from TypeScript and React!&amp;rdquo;</source>
          <target>お気に入りのブラウザで&lt;code&gt;index.html&lt;/code&gt;を開くと、すべてが使えるようになります。 &amp;ldquo;Hello from TypeScript and React!&amp;rdquo;というページが表示されます。</target>
        </trans-unit>
        <trans-unit id="b64ae89f2b2c42dc4bb6323281704d7232b3bc08" translate="yes">
          <source>Now right-click on &lt;code&gt;gulpfile.js&lt;/code&gt; and click Task Runner Explorer.</source>
          <target>&lt;code&gt;ガルプフィル.js&lt;/code&gt;を右クリックし、Task Runner Explorerをクリックします。</target>
        </trans-unit>
        <trans-unit id="016beaf6be9be172cdeebc211faf5982d24125cf" translate="yes">
          <source>Now that we are bundling our code with Browserify and tsify, we can add various features to our build with browserify plugins.</source>
          <target>Browserifyとツーフィにコードをバンドルしたので、Browserifyプラグインでビルドにさまざまな機能を追加できます。</target>
        </trans-unit>
        <trans-unit id="3572b0fda28e71add853bf4afaed6b354c007b3b" translate="yes">
          <source>Now that we&amp;rsquo;ve typed the function, let&amp;rsquo;s write the full type of the function out by looking at each piece of the function type.</source>
          <target>関数を入力したので、関数の型の各部分を見て、関数の完全な型を書き出してみましょう。</target>
        </trans-unit>
        <trans-unit id="2966203d51ca9197ed946ae5160c527e0fb03c59" translate="yes">
          <source>Now that you have authored a declaration file following the steps of this guide, it is time to publish it to npm. There are two main ways you can publish your declaration files to npm:</source>
          <target>このガイドの手順に従って宣言ファイルを作成したので、今度はnpmに宣言ファイルを公開します。 npmに宣言ファイルを公開するには、主に次の2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="8c3e6c78d4bb8682924668ec470406f5a06e700d" translate="yes">
          <source>Now that you know how to wrap the properties of a type, the next thing you&amp;rsquo;ll want to do is unwrap them. Fortunately, that&amp;rsquo;s pretty easy:</source>
          <target>タイプのプロパティをラップする方法がわかったので、次にアンラップします。 幸い、これは非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="586d73d271314d06733d1c62bea37895a7824b97" translate="yes">
          <source>Now to extend this to add support for input with numbers in bases other than 10, let&amp;rsquo;s create &lt;code&gt;ProgrammerCalculator.ts&lt;/code&gt;</source>
          <target>これを拡張して、10以外の基数の数値の入力をサポートするには、の&lt;code&gt;ProgrammerCalculator.ts&lt;/code&gt;を作成します。</target>
        </trans-unit>
        <trans-unit id="54df9cc661a5983b5f51492bea457bb95cb0f212" translate="yes">
          <source>Now type the following in &lt;code&gt;greeter.html&lt;/code&gt;:</source>
          <target>&lt;code&gt;greeter.html&lt;/code&gt;に次のように入力します。</target>
        </trans-unit>
        <trans-unit id="0aedf42a298e6637bb4289e35235553f17c5d827" translate="yes">
          <source>Now we can &lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt;&lt;code&gt;node.d.ts&lt;/code&gt; and then load the modules using &lt;code&gt;import url = require("url");&lt;/code&gt; or &lt;code&gt;import * as URL from "url"&lt;/code&gt;.</source>
          <target>次に、&lt;code&gt;///&amp;lt;reference&amp;gt;&lt;/code&gt;&lt;code&gt;node.d.ts&lt;/code&gt;を使用してモジュールをロードします。&lt;code&gt;import url=require("url");&lt;/code&gt;または&lt;code&gt;import*as URL from"url"&lt;/code&gt;。</target>
        </trans-unit>
        <trans-unit id="2993564eab76d9b635f5473fb0c79d7180499112" translate="yes">
          <source>Now we can start taking advantage of some of the new tools TypeScript offers. Add a &lt;code&gt;: string&lt;/code&gt; type annotation to the &amp;lsquo;person&amp;rsquo; function argument as shown here:</source>
          <target>これで、TypeScriptが提供するいくつかの新しいツールを利用できるようになりました。 次に示すように、&lt;code&gt;:string&lt;/code&gt;型の注釈を&amp;lsquo;person&amp;rsquo;関数の引数に追加します。</target>
        </trans-unit>
        <trans-unit id="a9ba4be9a993e3629ea4a24cf3ff116ae3e0a325" translate="yes">
          <source>Now we can use &lt;code&gt;npm install&lt;/code&gt; to install packages. First install &lt;code&gt;gulp-cli&lt;/code&gt; globally (if you use a Unix system, you may need to prefix the &lt;code&gt;npm install&lt;/code&gt; commands in this guide with &lt;code&gt;sudo&lt;/code&gt;).</source>
          <target>&lt;code&gt;npm install&lt;/code&gt;を使ってパッケージをインストールすることができます。 最初に&lt;code&gt;glp cli&lt;/code&gt;をグローバルにインストールします(Unixシステムを使用している場合は、このガイドの&lt;code&gt;npm install&lt;/code&gt;コマンドの前に&lt;code&gt;sudo&lt;/code&gt;を付ける必要があります)。</target>
        </trans-unit>
        <trans-unit id="a7d081445a246b0f99f5a3375693fd0bead88a94" translate="yes">
          <source>Now we&amp;rsquo;ll turn this folder into an npm package.</source>
          <target>次に、このフォルダをnpmパッケージに変換します。</target>
        </trans-unit>
        <trans-unit id="798f21b6ccc1b472b81074260cf839e73de6d419" translate="yes">
          <source>Now when these &lt;code&gt;never&lt;/code&gt;-returning functions are called, TypeScript recognizes that they affect the control flow graph and accounts for them.</source>
          <target>これらの&lt;code&gt;never&lt;/code&gt;-returning関数が呼び出されると、TypeScriptはそれらが制御フローグラフに影響を与えることを認識し、それらを説明する。</target>
        </trans-unit>
        <trans-unit id="4fec837a26b514bcf683dcfc0bc3cc7b47c80376" translate="yes">
          <source>Now when you run Gulp, it should start and stay running. Try changing the code for &lt;code&gt;showHello&lt;/code&gt; in &lt;code&gt;main.ts&lt;/code&gt; and saving it. You should see output that looks like this:</source>
          <target>Gulpを実行すると、Gulpが起動して実行されたままになります。&lt;code&gt;main.ts&lt;/code&gt;の&lt;code&gt;showHello&lt;/code&gt;のコードを変更して保存してみてください。 次のような出力が表示されます。</target>
        </trans-unit>
        <trans-unit id="5ab194637a92c49cdda73412d946249336784333" translate="yes">
          <source>Now you can import things that match &lt;code&gt;"*!text"&lt;/code&gt; or &lt;code&gt;"json!*"&lt;/code&gt;.</source>
          <target>これで、&lt;code&gt;"*!text"&lt;/code&gt;または&lt;code&gt;"json!*"&lt;/code&gt;に一致するものをインポートできます。</target>
        </trans-unit>
        <trans-unit id="32b6a0eecd0bd91b730d6782f43f8351f9e8957b" translate="yes">
          <source>NuGet</source>
          <target state="translated">NuGet</target>
        </trans-unit>
        <trans-unit id="3fd953c33b944413003ce7910b6fafa75556a775" translate="yes">
          <source>Null and Undefined</source>
          <target>Nullおよび未定義</target>
        </trans-unit>
        <trans-unit id="0ba35c721cc86f9e03aa8786b08aba75ab337b54" translate="yes">
          <source>Null- and undefined-aware types</source>
          <target>NULLおよび未定義の対応型</target>
        </trans-unit>
        <trans-unit id="4235ec51572e6a2ff85027b7b1a8ce199c7cf8fd" translate="yes">
          <source>Nullable types</source>
          <target>NULL値を使用できる型</target>
        </trans-unit>
        <trans-unit id="a75b78680034aa8db560e36a8c2208c5c33aa012" translate="yes">
          <source>Nullable types only have meaning if &lt;code&gt;strictNullChecks&lt;/code&gt; is on:</source>
          <target>NULL値を使用できる型は、&lt;code&gt;strictNullChecks&lt;/code&gt;がオンの場合のみ意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="961f4d441aaa81cdea02877b88e051c0d6fe0b64" translate="yes">
          <source>Nullish Coalescing</source>
          <target>Nullish合体</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="c3e5f2be0a6baf4d94beda8d9cf3d891411658e7" translate="yes">
          <source>Number-like properties of an object type are those declared using a numeric literal or computed property name of a numeric literal type.</source>
          <target>オブジェクト型の数値に似たプロパティは、数値リテラル型の数値リテラルまたは計算されたプロパティ名を使用して宣言されたプロパティです。</target>
        </trans-unit>
        <trans-unit id="6be519964a1d39fca2eb603fe581121e0fee9182" translate="yes">
          <source>Numeric Literal Types</source>
          <target>数値リテラル型</target>
        </trans-unit>
        <trans-unit id="87f1897cf6e443b573ef4632ce2ba3620162bbc7" translate="yes">
          <source>Numeric enums</source>
          <target>数値列挙</target>
        </trans-unit>
        <trans-unit id="9587a80bbfa80632e8af306b43edbc1e13077c08" translate="yes">
          <source>Numeric enums can be mixed in &lt;a href="#computed-and-constant-members"&gt;computed and constant members (see below)&lt;/a&gt;. The short story is, enums without initializers either need to be first, or have to come after numeric enums initialized with numeric constants or other constant enum members. In other words, the following isn&amp;rsquo;t allowed:</source>
          <target>数値列挙は、&lt;a href="#computed and constant members"&gt;computedメンバーとconstantメンバー(下記参照)&lt;/a&gt;で混在させることができます。 簡単に言えば、初期化子を持たないenumは、最初にするか、数値定数または他の定数enumメンバで初期化された数値enumの後に来る必要があります。 つまり、次の項目は許可されません。</target>
        </trans-unit>
        <trans-unit id="830f0ed9d3be32844d496bfeb9d33c2f9dea7d6a" translate="yes">
          <source>Numeric separators</source>
          <target>数値区切り記号</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="7a98263bb62cd83a74dc00c8238d597167506261" translate="yes">
          <source>Object Spread and Rest</source>
          <target>オブジェクトのスプレッドとレスト</target>
        </trans-unit>
        <trans-unit id="a7dc9622d9872b2041ea4b92f628450cd8b88097" translate="yes">
          <source>Object destructuring</source>
          <target>オブジェクトの分解</target>
        </trans-unit>
        <trans-unit id="7cd3db8976f376a1f019b5d0fed0df37b11861ba" translate="yes">
          <source>Object literals are open-ended</source>
          <target>オブジェクトリテラルは開放型</target>
        </trans-unit>
        <trans-unit id="b3c62e15831841090f5476450b68b035ffba0566" translate="yes">
          <source>Object literals behave as if they have an index signature &lt;code&gt;[x:string]: any&lt;/code&gt; that allows them to be treated as open maps instead of closed objects.</source>
          <target>オブジェクトリテラルは、インデックスシグネチャ&lt;code&gt;[x:string]:any&lt;/code&gt;を持つかのように動作し、閉じたオブジェクトではなく開いたマップとして扱われます。</target>
        </trans-unit>
        <trans-unit id="74365de67eba166395b7f2ad380a09c31367e923" translate="yes">
          <source>Object rests are the dual of object spreads, in that they can extract any extra properties that don&amp;rsquo;t get picked up when destructuring an element:</source>
          <target>オブジェクトレストはオブジェクトスプレッドのデュアルであり、エレメントを分解するときに取り込まれない追加プロパティを抽出できます。</target>
        </trans-unit>
        <trans-unit id="5eeac8ca658c85a10aefd3ffe0bf35ef9f80485c" translate="yes">
          <source>Object spread also has a couple of other surprising limits. First, it only includes an objects&amp;rsquo; &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties"&gt;own, enumerable properties&lt;/a&gt;. Basically, that means you lose methods when you spread instances of an object:</source>
          <target>オブジェクト・スプレッドには、他にも驚くべき制限がいくつかあります。 第1に、オブジェクト&amp;rsquo;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties"&gt;自身の列挙可能なプロパティ&lt;/a&gt;だけが含まれます。 つまり、オブジェクトのインスタンスを拡散するとメソッドが失われます。</target>
        </trans-unit>
        <trans-unit id="132f0e2906b1a9d29d3142065e0490a0c7b00912" translate="yes">
          <source>Objects with Properties</source>
          <target>プロパティを持つオブジェクト</target>
        </trans-unit>
        <trans-unit id="896953fcb00b0eb5b0ba4da3b193100a1b6c1094" translate="yes">
          <source>Of course, any of these types can be declared using Typescript syntax in a single-line &lt;code&gt;@typedef&lt;/code&gt;:</source>
          <target>もちろん、これらの型はどれもTypescript構文を使って1行&lt;code&gt;@typedef&lt;/code&gt;で宣言できます。</target>
        </trans-unit>
        <trans-unit id="2a729d408f1e41978ee6a94cb932a7977199d3c0" translate="yes">
          <source>Of course, since this is JavaScript, you can just ignore trailing elements you don&amp;rsquo;t care about:</source>
          <target>もちろん、これはJavaScriptなので、気にする必要のない末尾の要素を無視することができます。</target>
        </trans-unit>
        <trans-unit id="b9ca67ed45e73556a1cbb12d34b79f3e95210af4" translate="yes">
          <source>Of course, that might not feel right. If you open that file in an editor with TypeScript support (or if you run &lt;code&gt;tsc --pretty&lt;/code&gt;), you might see red squiggles on certain lines. You should think of these the same way you&amp;rsquo;d think of red squiggles in an editor like Microsoft Word. TypeScript will still translate your code, just like Word will still let you print your documents.</source>
          <target>TypeScriptをサポートしているエディタでファイルを開くと(あるいは&lt;code&gt;tsc--pretty&lt;/code&gt;を実行すると)、特定の行に赤い波線が表示されることがあります。 Microsoft Wordのようなエディタでは、赤い波線のように見えます。 TypeScriptは、Wordで文書を印刷できるように、コードを翻訳します。</target>
        </trans-unit>
        <trans-unit id="33b53cf1b820a2734ec0c25dc3f2c29570965d4b" translate="yes">
          <source>Of note, only the parameters and the return type make up the function type. Captured variables are not reflected in the type. In effect, captured variables are part of the &amp;ldquo;hidden state&amp;rdquo; of any function and do not make up its API.</source>
          <target>関数型を構成するのは、パラメーターと戻り値の型だけです。 取得された変数は型に反映されません。 実際には、キャプチャされた変数は関数の&amp;ldquo;hidden state&amp;rdquo;の一部であり、そのAPIを構成しません。</target>
        </trans-unit>
        <trans-unit id="4d23057a19f87b1d7a3f861f468248c8e5a5974a" translate="yes">
          <source>Official TypeScript NuGet package</source>
          <target>公式TypeScript NuGetパッケージ</target>
        </trans-unit>
        <trans-unit id="a342b6bea0bb720b9577de62cca20c2743aa540e" translate="yes">
          <source>Often a project has multiple output targets, e.g. &lt;code&gt;ES5&lt;/code&gt; and &lt;code&gt;ES2015&lt;/code&gt;, debug and production or &lt;code&gt;CommonJS&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt;; Just a few configuration options change between these two targets, and maintaining multiple &lt;code&gt;tsconfig.json&lt;/code&gt; files can be a hassle.</source>
          <target>プロジェクトには、&lt;code&gt;ES5&lt;/code&gt;と&lt;code&gt;ES2015&lt;/code&gt;、デバッグと生成、または&lt;code&gt;CommonJS&lt;/code&gt;と&lt;code&gt;System&lt;/code&gt;など、複数の出力ターゲットがあることが多い。これら2つのターゲット間で変更される設定オプションはわずかであり、複数の&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルを維持するのは面倒である。</target>
        </trans-unit>
        <trans-unit id="0d6fe7c72174392511bd9351eaea580b26d61ce5" translate="yes">
          <source>Often in Node.js applications a &lt;code&gt;.json&lt;/code&gt; is needed. With TypeScript 2.9, &lt;code&gt;--resolveJsonModule&lt;/code&gt; allows for importing, extracting types from and generating &lt;code&gt;.json&lt;/code&gt; files.</source>
          <target>多くの場合、Node.jsアプリケーションでは&lt;code&gt;.json&lt;/code&gt;が必要です。 TypeScript2.9では、&lt;code&gt;--resolveJsonModule&lt;/code&gt;は&lt;code&gt;.json&lt;/code&gt;ファイルのインポート、型の抽出、生成を可能にする。</target>
        </trans-unit>
        <trans-unit id="c504b6f49a2c17cd30c9562020e80d82bcb972da" translate="yes">
          <source>Often modules extend other modules, and partially expose some of their features. A re-export does not import it locally, or introduce a local variable.</source>
          <target>多くの場合、モジュールは他のモジュールを拡張し、その機能の一部を公開します。 再エクスポートでは、再エクスポートをローカルにインポートしたり、ローカル変数を導入したりすることはありません。</target>
        </trans-unit>
        <trans-unit id="7ca1979392492f5b243f43458b409b3671c295fb" translate="yes">
          <source>Often there are external source files in your project that may not be authored in TypeScript. Alternatively, you might be in the middle of converting a JS code base into TS, but still want to bundle all your JS code into a single file with the output of your new TS code.</source>
          <target>多くの場合、TypeScriptで作成できない外部ソースファイルがプロジェクトにあります。 あるいは、JSコード・ベースをTSに変換する途中で、すべてのJSコードを新しいTSコードの出力と一緒に1つのファイルにバンドルしたい場合もあります。</target>
        </trans-unit>
        <trans-unit id="5dd8eb55cce46da17a5fd56794f37ca6d1bdbaaf" translate="yes">
          <source>Often you will need to extend functionality on a module. A common JS pattern is to augment the original object with &lt;em&gt;extensions&lt;/em&gt;, similar to how JQuery extensions work. As we&amp;rsquo;ve mentioned before, modules do not &lt;em&gt;merge&lt;/em&gt; like global namespace objects would. The recommended solution is to &lt;em&gt;not&lt;/em&gt; mutate the original object, but rather export a new entity that provides the new functionality.</source>
          <target>多くの場合、モジュールの機能を拡張する必要があります。 一般的なJSパターンは、元のオブジェクトを&lt;em&gt;拡張&lt;/em&gt;で補強することであり、これはjQuery拡張の仕組みと似ている。 前述したように、モジュールはグローバル名前空間オブジェクトとは&lt;em&gt;マージ&lt;/em&gt;しません。 推奨される解決策は、元のオブジェクトを&lt;em&gt;変更しないで&lt;/em&gt;、新しい機能を提供する新しいエンティティをエクスポートすることです。</target>
        </trans-unit>
        <trans-unit id="a6d080bfadce04e0f057f47e98252d55d314023f" translate="yes">
          <source>Omit&lt;T,K&gt;</source>
          <target state="translated">Omit&lt;T,K&gt;</target>
        </trans-unit>
        <trans-unit id="92df791023a2af27d1199c4ac1986b7a67686b3d" translate="yes">
          <source>OmitThisParameter</source>
          <target>OmitThisParameter</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
