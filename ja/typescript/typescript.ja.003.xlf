<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="a82c9a0a2eb97497a86656e3460a340f586d18ec" translate="yes" xml:space="preserve">
          <source>On a single line:</source>
          <target state="translated">単線で。</target>
        </trans-unit>
        <trans-unit id="82aef786e3f0d107d8d394b8c34887545af6ea56" translate="yes" xml:space="preserve">
          <source>On multiple lines:</source>
          <target state="translated">複数行で</target>
        </trans-unit>
        <trans-unit id="74944d3dcee80b1604d42865751a7ceaa698e35d" translate="yes" xml:space="preserve">
          <source>On the last line of the snippet you can see that even assigning the entire &lt;code&gt;ReadonlyArray&lt;/code&gt; back to a normal array is illegal. You can still override it with a type assertion, though:</source>
          <target state="translated">スニペットの最後の行で、ReadonlyArray全体を通常の配列に戻すことさえ違法であることがわかります。 ただし、型アサーションでそれをオーバーライドすることもできます。</target>
        </trans-unit>
        <trans-unit id="50c6272b337ca96a2387d10cc66c11dc4b62bb58" translate="yes" xml:space="preserve">
          <source>On the organization front, namespaces are handy for grouping together logically-related objects and types in the global scope. For example, in C#, you&amp;rsquo;re going to find all the collection types in System.Collections. By organizing our types into hierarchical namespaces, we provide a good &amp;ldquo;discovery&amp;rdquo; experience for users of those types. Modules, on the other hand, are already present in a file system, necessarily. We have to resolve them by path and filename, so there&amp;rsquo;s a logical organization scheme for us to use. We can have a /collections/generic/ folder with a list module in it.</source>
          <target state="translated">組織の面では、名前空間は、グローバルスコープ内の論理的に関連するオブジェクトとタイプをグループ化するのに便利です。 たとえば、C＃では、System.Collectionsですべてのコレクションタイプを検索します。 タイプを階層的な名前空間に整理することにより、それらのタイプのユーザーに優れた「発見」体験を提供します。 一方、モジュールはファイルシステムに必ず存在します。 これらをパスとファイル名で解決する必要があるため、使用する論理的な組織化スキームがあります。 リストモジュールを含む/ collections / generic /フォルダーを作成できます。</target>
        </trans-unit>
        <trans-unit id="b64cb02da6becca0ce8ee30f0556e39a4da2ddd8" translate="yes" xml:space="preserve">
          <source>On the other hand, if you can&amp;rsquo;t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.</source>
          <target state="translated">一方、インターフェイスで何らかの形を表現できず、ユニオン型またはタプル型を使用する必要がある場合、通常は型エイリアスを使用します。</target>
        </trans-unit>
        <trans-unit id="c26cd5caaa2a12259da3b89ce4e19ad33c03509f" translate="yes" xml:space="preserve">
          <source>On the other hand, methods like &lt;code&gt;forEach&lt;/code&gt; will now be callable, but under &lt;code&gt;noImplicitAny&lt;/code&gt; there may be some issues.</source>
          <target state="translated">一方、 &lt;code&gt;forEach&lt;/code&gt; のようなメソッドは呼び出し可能になりますが、 &lt;code&gt;noImplicitAny&lt;/code&gt; ではいくつかの問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="5e243af120900864262b36ccd9ddf3da385c8c6b" translate="yes" xml:space="preserve">
          <source>Once defined, we can use this function type interface like we would other interfaces. Here, we show how you can create a variable of a function type and assign it a function value of the same type.</source>
          <target state="translated">一度定義してしまえば、この関数型インターフェースを他のインターフェースと同じように使うことができます。ここでは、関数型の変数を作成し、同じ型の関数値を代入する方法を示します。</target>
        </trans-unit>
        <trans-unit id="92950c589178fe64abd972f4ad963eddae26cb96" translate="yes" xml:space="preserve">
          <source>Once the class type is established, the instance type is determined by the union of the return types of the class type&amp;rsquo;s construct or call signatures (whichever is present). So again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function.</source>
          <target state="translated">クラスタイプが確立されると、インスタンスタイプは、クラスタイプの構造体または呼び出しシグネチャ（存在する方）の戻り値のタイプの結合によって決定されます。 繰り返しますが、ES6クラスの場合、インスタンスタイプはそのクラスのインスタンスのタイプになり、ファクトリ関数の場合、関数から返される値のタイプになります。</target>
        </trans-unit>
        <trans-unit id="b659e74e17ccfc36ea3671d29e4bcfb99bcddcac" translate="yes" xml:space="preserve">
          <source>Once there are multiple files involved, we&amp;rsquo;ll need to make sure all of the compiled code gets loaded. There are two ways of doing this.</source>
          <target state="translated">複数のファイルが関係するようになったら、コンパイルされたコードがすべて読み込まれるようにする必要があります。 これを行うには2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="1344250aecff00dcfaf8dcd7ebd24a106e1cf310" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:</source>
          <target state="translated">ジェネリックID関数を作成したら、次の2つの方法のいずれかで呼び出すことができます。 最初の方法は、型引数を含むすべての引数を関数に渡すことです。</target>
        </trans-unit>
        <trans-unit id="1f601e0447efc6c6f5c004e85bc2178722596428" translate="yes" xml:space="preserve">
          <source>One advantage of this is that the callable constructor pattern can be easily expressed while also allowing namespaces to merge with these declarations (since &lt;code&gt;var&lt;/code&gt; declarations can&amp;rsquo;t merge with &lt;code&gt;namespace&lt;/code&gt;s).</source>
          <target state="translated">この利点の1つは、名前空間をこれらの宣言とマージできるようにしながら、呼び出し可能なコンストラクターパターンを簡単に表現できることです（ &lt;code&gt;var&lt;/code&gt; 宣言は &lt;code&gt;namespace&lt;/code&gt; マージできないため）。</target>
        </trans-unit>
        <trans-unit id="07140e34d3c9cf651017285b583d3f868d3d8fae" translate="yes" xml:space="preserve">
          <source>One common task is to take an existing type and make each of its properties entirely optional. Let&amp;rsquo;s say we have a &lt;code&gt;Person&lt;/code&gt;:</source>
          <target state="translated">一般的なタスクの1つは、既存のタイプを取得し、その各プロパティを完全にオプションにすることです。 &lt;code&gt;Person&lt;/code&gt; があるとしましょう：</target>
        </trans-unit>
        <trans-unit id="11091369cf849b83900d010b927727e1dc480d7a" translate="yes" xml:space="preserve">
          <source>One difference from the prior example is that each derived class that contains a constructor function &lt;em&gt;must&lt;/em&gt; call &lt;code&gt;super()&lt;/code&gt; which will execute the constructor of the base class. What&amp;rsquo;s more, before we &lt;em&gt;ever&lt;/em&gt; access a property on &lt;code&gt;this&lt;/code&gt; in a constructor body, we &lt;em&gt;have&lt;/em&gt; to call &lt;code&gt;super()&lt;/code&gt;. This is an important rule that TypeScript will enforce.</source>
          <target state="translated">前の例との違いの1つは、コンストラクター関数を含む各派生クラスが、基本クラスのコンストラクターを実行する &lt;code&gt;super()&lt;/code&gt; を呼び出す&lt;em&gt;必要&lt;/em&gt;があることです。 さらに、コンストラクター本体で &lt;code&gt;this&lt;/code&gt; のプロパティにアクセスする前に、 &lt;code&gt;super()&lt;/code&gt; を呼び出す&lt;em&gt;必要&lt;/em&gt;があります。 これは、TypeScriptが実施する重要なルールです。</target>
        </trans-unit>
        <trans-unit id="e676ef27b983655b305e7201bc44df325b250ac1" translate="yes" xml:space="preserve">
          <source>One difference is that interfaces create a new name that is used everywhere. Type aliases don&amp;rsquo;t create a new name &amp;mdash; for instance, error messages won&amp;rsquo;t use the alias name. In the code below, hovering over &lt;code&gt;interfaced&lt;/code&gt; in an editor will show that it returns an &lt;code&gt;Interface&lt;/code&gt;, but will show that &lt;code&gt;aliased&lt;/code&gt; returns object literal type.</source>
          <target state="translated">1つの違いは、インターフェースがどこでも使用される新しい名前を作成することです。 タイプエイリアスは新しい名前を作成しません。たとえば、エラーメッセージはエイリアス名を使用しません。 以下のコードでは、エディターで &lt;code&gt;interfaced&lt;/code&gt; 上にマウスを移動すると、 インターフェイスを返すことが示さ &lt;code&gt;aliased&lt;/code&gt; ますが、 エイリアスがオブジェクトリテラルタイプを返すことが示されます。</target>
        </trans-unit>
        <trans-unit id="4a3dab7aa9f91e5908fc981f84a1f4366d2c7377" translate="yes" xml:space="preserve">
          <source>One exception to this rule is specialized signatures. If a signature has a parameter whose type is a &lt;em&gt;single&lt;/em&gt; string literal type (e.g. not a union of string literals), then it will be bubbled toward the top of its merged overload list.</source>
          <target state="translated">この規則の1つの例外は、特殊な署名です。 シグニチャに&lt;em&gt;単一の&lt;/em&gt;文字列リテラル型（たとえば、文字列リテラルの結合ではない）の型を持つパラメータがある場合、マージされたオーバーロードリストの上部に向かってバブルされます。</target>
        </trans-unit>
        <trans-unit id="344276576132d21b818f4ba76034843580074fbf" translate="yes" xml:space="preserve">
          <source>One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since &lt;code&gt;squareOptions&lt;/code&gt; won&amp;rsquo;t undergo excess property checks, the compiler won&amp;rsquo;t give you an error.</source>
          <target state="translated">これらのチェックを回避する最後の方法は、少し驚くかもしれませんが、オブジェクトを別の変数に割り当てることです &lt;code&gt;squareOptions&lt;/code&gt; は過剰なプロパティチェックを受けないため、コンパイラはエラーを出しません。</target>
        </trans-unit>
        <trans-unit id="42cbeda6b484653b931fc5901c6ad7cbbe7d3da4" translate="yes" xml:space="preserve">
          <source>One great benefit of this is that you&amp;rsquo;ll see &lt;em&gt;way fewer&lt;/em&gt; implicit &lt;code&gt;any&lt;/code&gt; errors when running with &lt;code&gt;--noImplicitAny&lt;/code&gt;. Implicit &lt;code&gt;any&lt;/code&gt; errors are only reported when the compiler is unable to know the type of a variable without a type annotation.</source>
          <target state="translated">これの大きな利点の1つは、-- &lt;code&gt;--noImplicitAny&lt;/code&gt; して実行すると、暗黙的 &lt;code&gt;any&lt;/code&gt; エラーが大幅に&lt;em&gt;少なくなる&lt;/em&gt;ことです。 暗黙的 &lt;code&gt;any&lt;/code&gt; エラーは、コンパイラーが型注釈なしで変数の型を認識できない場合にのみ報告されます。</target>
        </trans-unit>
        <trans-unit id="0e93e8c643fb4e61579636fbf572b596e0286726" translate="yes" xml:space="preserve">
          <source>One important difference between ambient and non-ambient enums is that, in regular enums, members that don&amp;rsquo;t have an initializer will be considered constant if its preceding enum member is considered constant. In contrast, an ambient (and non-const) enum member that does not have initializer is &lt;em&gt;always&lt;/em&gt; considered computed.</source>
          <target state="translated">アンビエント列挙型と非アンビエント列挙型の重要な違いの1つは、通常の列挙型では、初期化子を持たないメンバーは、その前の列挙型メンバーが定数と見なされる場合、定数と見なされることです。 対照的に、初期化子を持たないアンビエント（および非定数）列挙型メンバーは、 &lt;em&gt;常に&lt;/em&gt;計算済みと見なされます。</target>
        </trans-unit>
        <trans-unit id="82aa3486d66599c6818535555fcde271410599f0" translate="yes" xml:space="preserve">
          <source>One of TypeScript&amp;rsquo;s core principles is that type checking focuses on the &lt;em&gt;shape&lt;/em&gt; that values have. This is sometimes called &amp;ldquo;duck typing&amp;rdquo; or &amp;ldquo;structural subtyping&amp;rdquo;. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.</source>
          <target state="translated">TypeScriptの中核となる原則の1つは、型チェックは値が持つ&lt;em&gt;形状に&lt;/em&gt;焦点を合わせるというものです。 これは「ダックタイピング」または「構造的サブタイピング」と呼ばれることもあります。 TypeScriptでは、インターフェイスはこれらの型に名前を付ける役割を果たし、プロジェクト内のコードとの契約だけでなく、コード内の契約を定義する強力な方法です。</target>
        </trans-unit>
        <trans-unit id="5aea8e823173035ff216b848c6b0d54b8b96fd4c" translate="yes" xml:space="preserve">
          <source>One of the most common uses of interfaces in languages like C# and Java, that of explicitly enforcing that a class meets a particular contract, is also possible in TypeScript.</source>
          <target state="translated">C#やJavaのような言語で最も一般的に使用されているインターフェースの1つである、クラスが特定の契約を満たすことを明示的に強制することは、TypeScriptでも可能です。</target>
        </trans-unit>
        <trans-unit id="bd4f8dfdb26e810e57f23fff74f292ac4a329c2e" translate="yes" xml:space="preserve">
          <source>One or more assignments to &lt;code&gt;window.someName&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window.someName&lt;/code&gt; への1つ以上の割り当て</target>
        </trans-unit>
        <trans-unit id="7eacbc50348f5b3ec9e3e6415d394dd711448525" translate="yes" xml:space="preserve">
          <source>One such example is an object that acts as both a function and an object, with additional properties:</source>
          <target state="translated">そのような例として、関数とオブジェクトの両方として動作し、追加のプロパティを持つオブジェクトがあります。</target>
        </trans-unit>
        <trans-unit id="10e4a65d9bb07088ca61418abc5f5490d598fa30" translate="yes" xml:space="preserve">
          <source>One thing to note is that &lt;code&gt;const&lt;/code&gt; assertions can only be applied immediately on simple literal expressions.</source>
          <target state="translated">注意すべきことは、 &lt;code&gt;const&lt;/code&gt; アサーションは単純なリテラル式にのみすぐに適用できることです。</target>
        </trans-unit>
        <trans-unit id="165c72846ed1b6318be8972010ccbd2b184d8eb7" translate="yes" xml:space="preserve">
          <source>OneTwoThree.ts</source>
          <target state="translated">OneTwoThree.ts</target>
        </trans-unit>
        <trans-unit id="e8b21c7e76c250574a2ed991e3f5c20b47bb2111" translate="yes" xml:space="preserve">
          <source>Only emit &amp;lsquo;.d.ts&amp;rsquo; declaration files.</source>
          <target state="translated">'.d.ts'宣言ファイルのみを出力します。</target>
        </trans-unit>
        <trans-unit id="9c4c4f095c25b9e726d79098915a46e4ea92ff63" translate="yes" xml:space="preserve">
          <source>Open &lt;code&gt;greeter.html&lt;/code&gt; in the browser to run your first simple TypeScript web application!</source>
          <target state="translated">ブラウザで &lt;code&gt;greeter.html&lt;/code&gt; を開いて、最初の単純なTypeScript Webアプリケーションを実行してください！</target>
        </trans-unit>
        <trans-unit id="e55b8e4dc396172c8a0dbddfe6ab0a7debd51fb3" translate="yes" xml:space="preserve">
          <source>Open &lt;strong&gt;Dependencies &amp;gt; Manage NuGet Packages &amp;gt; Browse.&lt;/strong&gt; Search and install &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; and &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;:</source>
          <target state="translated">[ &lt;strong&gt;依存関係]&amp;gt; [NuGetパッケージの管理]&amp;gt; [参照]を&lt;/strong&gt;開き&lt;strong&gt;ます。&lt;/strong&gt; &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; および &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; を検索してインストールします 。</target>
        </trans-unit>
        <trans-unit id="064cf8a9bba6348e155ce9b3a0d85c1b0a8dcab6" translate="yes" xml:space="preserve">
          <source>Open up your &lt;code&gt;Startup.cs&lt;/code&gt; file and edit your &lt;code&gt;Configure&lt;/code&gt; function to look like this:</source>
          <target state="translated">&lt;code&gt;Startup.cs&lt;/code&gt; ファイルを開き、 &lt;code&gt;Configure&lt;/code&gt; 関数を次のように編集します。</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="e623b1194b11521281fe95cf75df232d30616550" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;--outDir&lt;/code&gt; duplicates the input hierarchy in the output. The compiler computes the root of the input files as the longest common path of all input files; and then uses that to replicate all its substructure in the output.</source>
          <target state="translated">オプション &lt;code&gt;--outDir&lt;/code&gt; は、入力階層を出力に複製します。 コンパイラは、入力ファイルのルートを、すべての入力ファイルの最長共通パスとして計算します。 そして、それを使用して、出力内のすべての下位構造を複製します。</target>
        </trans-unit>
        <trans-unit id="02e5818137a6801351663f03a49db2886b267ce5" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;catch&lt;/code&gt; clause variables</source>
          <target state="translated">オプションの &lt;code&gt;catch&lt;/code&gt; 節変数</target>
        </trans-unit>
        <trans-unit id="e1a89356c2e4a69562083736c16549a15a67afd8" translate="yes" xml:space="preserve">
          <source>Optional Chaining</source>
          <target state="translated">オプションのチェイニング</target>
        </trans-unit>
        <trans-unit id="f7c6bcdff008088c9ae3335f40deda7169b35c83" translate="yes" xml:space="preserve">
          <source>Optional Module Loading and Other Advanced Loading Scenarios</source>
          <target state="translated">オプションのモジュールローディングとその他の高度なローディングシナリオ</target>
        </trans-unit>
        <trans-unit id="ccaa37d283bc30bfac0d5a680eadb38cfbad3c49" translate="yes" xml:space="preserve">
          <source>Optional Parameters and Rest Parameters</source>
          <target state="translated">オプションパラメータと残りのパラメータ</target>
        </trans-unit>
        <trans-unit id="b5c1d49a9a0ded62373bc3f019e8b6f2da7391b2" translate="yes" xml:space="preserve">
          <source>Optional Parameters in Callbacks</source>
          <target state="translated">コールバックのオプションパラメータ</target>
        </trans-unit>
        <trans-unit id="17315c7bb52dfa3c7be7c978a030acc2e38d91c1" translate="yes" xml:space="preserve">
          <source>Optional Properties</source>
          <target state="translated">オプションのプロパティ</target>
        </trans-unit>
        <trans-unit id="8daa3a8272df293fc9da3c3073a118094fb29854" translate="yes" xml:space="preserve">
          <source>Optional and Default Parameters</source>
          <target state="translated">オプションとデフォルトのパラメータ</target>
        </trans-unit>
        <trans-unit id="f4d845ae294ad2b99077aef2b25fd789eac70078" translate="yes" xml:space="preserve">
          <source>Optional chaining also includes two other operations. First there&amp;rsquo;s the &lt;em&gt;optional element access&lt;/em&gt; which acts similarly to optional property accesses, but allows us to access non-identifier properties (e.g. arbitrary strings, numbers, and symbols):</source>
          <target state="translated">オプションのチェーンには、他の2つの操作も含まれます。 最初に、 &lt;em&gt;オプションの&lt;/em&gt;プロパティアクセスと同様に機能する&lt;em&gt;オプションの要素アクセスが&lt;/em&gt;ありますが、識別子以外のプロパティ（たとえば、任意の文字列、数字、記号）にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="e5f644471c553673cd2548869c093cbfbd2425d1" translate="yes" xml:space="preserve">
          <source>Optional chaining is &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/16&quot;&gt;issue #16&lt;/a&gt; on our issue tracker. For context, there have been over 23,000 issues on the TypeScript issue tracker since then.</source>
          <target state="translated">オプションのチェーンは、課題トラッカーの&lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/16&quot;&gt;課題＃16&lt;/a&gt;です。 コンテキストについては、TypeScriptの問題追跡システムには23,000以上の問題があります。</target>
        </trans-unit>
        <trans-unit id="53581f6f206bad7094e8261bd030109f9d53f1b0" translate="yes" xml:space="preserve">
          <source>Optional class properties</source>
          <target state="translated">オプションのクラスプロパティ</target>
        </trans-unit>
        <trans-unit id="d957ddf6e5b65d75752d19d7a9dab595722e5998" translate="yes" xml:space="preserve">
          <source>Optional elements in tuple types</source>
          <target state="translated">タプル型のオプション要素</target>
        </trans-unit>
        <trans-unit id="d86b65de7272239d11bfd100dd6563cfd8eb06e5" translate="yes" xml:space="preserve">
          <source>Optional elements in tuple types.</source>
          <target state="translated">タプル型のオプション要素。</target>
        </trans-unit>
        <trans-unit id="05631f6c888f7c7fded4cab4a643205c9c4a8938" translate="yes" xml:space="preserve">
          <source>Optional parameters and properties</source>
          <target state="translated">オプションのパラメータとプロパティ</target>
        </trans-unit>
        <trans-unit id="a160146910ad98552a493b375e35d6abcb550597" translate="yes" xml:space="preserve">
          <source>Optional parameters and properties automatically have &lt;code&gt;undefined&lt;/code&gt; added to their types, even when their type annotations don&amp;rsquo;t specifically include &lt;code&gt;undefined&lt;/code&gt;. For example, the following two types are identical:</source>
          <target state="translated">タイプの注釈に &lt;code&gt;undefined&lt;/code&gt; が明確に含まれていない場合でも、オプションのパラメーターとプロパティには、タイプに &lt;code&gt;undefined&lt;/code&gt; が自動的に追加されます。 たとえば、次の2つのタイプは同一です。</target>
        </trans-unit>
        <trans-unit id="f00301f27003ef54c63e41fcdd1c3d98832e9617" translate="yes" xml:space="preserve">
          <source>Optional properties and methods can now be declared in classes, similar to what is already permitted in interfaces.</source>
          <target state="translated">オプションのプロパティとメソッドは、すでにインターフェイスで許可されているものと同様に、クラスで宣言できるようになりました。</target>
        </trans-unit>
        <trans-unit id="c20ef3af584d28ff7405e7586b97956e1fd873af" translate="yes" xml:space="preserve">
          <source>Optional: Open &lt;code&gt;greeter.ts&lt;/code&gt; in Visual Studio, or copy the code into the TypeScript playground. You can hover over identifiers to see their types. Notice that in some cases these types are inferred automatically for you. Re-type the last line, and see completion lists and parameter help based on the types of the DOM elements. Put your cursor on the reference to the greeter function, and hit F12 to go to its definition. Notice, too, that you can right-click on a symbol and use refactoring to rename it.</source>
          <target state="translated">オプション：Visual Studioで &lt;code&gt;greeter.ts&lt;/code&gt; を開くか、コードをTypeScriptプレイグラウンドにコピーします。 識別子にカーソルを合わせると、そのタイプを確認できます。 場合によっては、これらのタイプが自動的に推測されることに注意してください。 最後の行を再入力し、DOM要素のタイプに基づいて補完リストとパラメーターヘルプを表示します。 greeter関数への参照にカーソルを置き、F12を押してその定義に移動します。 また、シンボルを右クリックし、リファクタリングを使用して名前を変更できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="591ef5ad63bd713e79f598100ad5e204c2091ef1" translate="yes" xml:space="preserve">
          <source>Optionally, a module can wrap one or more modules and combine all their exports using &lt;code&gt;export * from &quot;module&quot;&lt;/code&gt; syntax.</source>
          <target state="translated">オプションで、モジュールは1つ以上のモジュールをラップし、 &lt;code&gt;export * from &quot;module&quot;&lt;/code&gt; 構文を使用してすべてのエクスポートを結合できます。</target>
        </trans-unit>
        <trans-unit id="81b391e677894347f3d7eaa5c625ce0c39681863" translate="yes" xml:space="preserve">
          <source>Or ignore trailing elements, or other elements:</source>
          <target state="translated">または、末尾の要素などは無視してください。</target>
        </trans-unit>
        <trans-unit id="107058d564aa8aab6bd22eaa786593d0b18cee3f" translate="yes" xml:space="preserve">
          <source>Or other elements:</source>
          <target state="translated">または他の要素。</target>
        </trans-unit>
        <trans-unit id="7896cec1b378bbc6409139052737322d415d7652" translate="yes" xml:space="preserve">
          <source>Or we might want a readonly version:</source>
          <target state="translated">もしくは読み切り版が欲しいかもしれません。</target>
        </trans-unit>
        <trans-unit id="6d64af183927ab37ad7e32252f098d1cc8ff662b" translate="yes" xml:space="preserve">
          <source>Or you can just use the unspecified &lt;code&gt;Function&lt;/code&gt; type:</source>
          <target state="translated">または、未指定の &lt;code&gt;Function&lt;/code&gt; タイプを使用できます。</target>
        </trans-unit>
        <trans-unit id="f1ea4c6e412df1aa6cd8260f35271c01fcb8e8a0" translate="yes" xml:space="preserve">
          <source>Or, even manually set all the values in the enum:</source>
          <target state="translated">あるいは、列挙されているすべての値を手動で設定することもできます。</target>
        </trans-unit>
        <trans-unit id="a7041e24ae17e49fcab38c7bb31f06d031308b3f" translate="yes" xml:space="preserve">
          <source>Or, we could describe the identity function using the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target state="translated">または、 &lt;code&gt;any&lt;/code&gt; タイプを使用して恒等関数を記述できます 。</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="bf83d365be04a72bc8a349cc7a86cd0845dccf80" translate="yes" xml:space="preserve">
          <source>Organizing Types</source>
          <target state="translated">整理の種類</target>
        </trans-unit>
        <trans-unit id="62510ab9b0c9768adbae646ef408d2a62b45617c" translate="yes" xml:space="preserve">
          <source>Other types from Closure also work:</source>
          <target state="translated">クロージャーの他のタイプも動作します。</target>
        </trans-unit>
        <trans-unit id="6c40d3319358591a02a91d9e7d4783872ba163d5" translate="yes" xml:space="preserve">
          <source>Other variants are allowed as well:</source>
          <target state="translated">他の亜種も同様に許可されています。</target>
        </trans-unit>
        <trans-unit id="b3fdc1e6ff5294bca808cf4bfb8838d0fec37709" translate="yes" xml:space="preserve">
          <source>Otherwise use &lt;code&gt;--keyofStringsOnly&lt;/code&gt; compiler option to disable the new behavior.</source>
          <target state="translated">それ以外の場合は、-- &lt;code&gt;--keyofStringsOnly&lt;/code&gt; コンパイラオプションを使用して、新しい動作を無効にします。</target>
        </trans-unit>
        <trans-unit id="7336f1cc92c408cb13dba362d46361683cd3d12c" translate="yes" xml:space="preserve">
          <source>Otherwise, the condition depends on one or more type variables and the conditional type is deferred.</source>
          <target state="translated">そうでなければ、条件は1つ以上の型変数に依存しており、条件型は延期されます。</target>
        </trans-unit>
        <trans-unit id="9fd652f329cdb87b5184f532624c12babcba184a" translate="yes" xml:space="preserve">
          <source>Otherwise, we assume that you&amp;rsquo;re already using &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; with &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">それ以外の場合は、すでに&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npmで&lt;/a&gt; &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;を使用していると仮定します。</target>
        </trans-unit>
        <trans-unit id="784cfa9d141a3fe82c06f16ad3a9456778056b89" translate="yes" xml:space="preserve">
          <source>Our First Interface</source>
          <target state="translated">最初のインターフェイス</target>
        </trans-unit>
        <trans-unit id="59c2ed6506b42cf80836ee63241f17d49a77bfd7" translate="yes" xml:space="preserve">
          <source>Our package exposes declarations from each of those, so any user of our &lt;code&gt;browserify-typescript-extension&lt;/code&gt; package needs to have these dependencies as well. For that reason, we used &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; and not &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt;, because otherwise our consumers would have needed to manually install those packages. If we had just written a command line application and not expected our package to be used as a library, we might have used &lt;code&gt;devDependencies&lt;/code&gt;.</source>
          <target state="translated">パッケージはそれらのそれぞれから宣言を公開するため、 &lt;code&gt;browserify-typescript-extension&lt;/code&gt; パッケージのユーザーはこれらの依存関係も持っている必要があります。 そのため、 &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; ではなく &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; を使用しました。そうしないと、コンシューマーがそれらのパッケージを手動でインストールする必要があったためです。 コマンドラインアプリケーションを作成したばかりで、パッケージがライブラリとして使用されることを想定していない場合は、 &lt;code&gt;devDependencies&lt;/code&gt; を使用した可能性があります。</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="914f3908b7a344c5f4fb4fdf698695b9d2d20039" translate="yes" xml:space="preserve">
          <source>Output File Extension</source>
          <target state="translated">出力ファイル拡張子</target>
        </trans-unit>
        <trans-unit id="b1a5505b0f802d6cf6a89204887e3eae4eb65f9a" translate="yes" xml:space="preserve">
          <source>Output directory for generated declaration files.</source>
          <target state="translated">生成された宣言ファイルの出力ディレクトリ。</target>
        </trans-unit>
        <trans-unit id="174bd26cf8c350d1ca94d82023ef88cff0353faa" translate="yes" xml:space="preserve">
          <source>Output generation</source>
          <target state="translated">出力生成</target>
        </trans-unit>
        <trans-unit id="564d5d5acb36c72c6328a222a0d5721ff6fd4eb9" translate="yes" xml:space="preserve">
          <source>Outside of &lt;code&gt;.tsx&lt;/code&gt; files, the angle bracket assertion syntax can also be used.</source>
          <target state="translated">&lt;code&gt;.tsx&lt;/code&gt; ファイルの外部では、山かっこアサーション構文も使用できます。</target>
        </trans-unit>
        <trans-unit id="fcc1811db5df29bd6fe9b10089bc778dd03521da" translate="yes" xml:space="preserve">
          <source>Overall Structure</source>
          <target state="translated">全体構造</target>
        </trans-unit>
        <trans-unit id="0774d17a127371d4945391cdeb1d6747883f0446" translate="yes" xml:space="preserve">
          <source>Overloaded Function</source>
          <target state="translated">オーバーロード機能</target>
        </trans-unit>
        <trans-unit id="b8ed2ea3bd4ec728b7aa2051fa7a407dc7fb10f0" translate="yes" xml:space="preserve">
          <source>Overloaded Functions</source>
          <target state="translated">過負荷機能</target>
        </trans-unit>
        <trans-unit id="ec5878dd8d899636943fffee6342d476f6713cb3" translate="yes" xml:space="preserve">
          <source>Overloads</source>
          <target state="translated">Overloads</target>
        </trans-unit>
        <trans-unit id="cc20e1a304c06340ae63ba26a34364808dafd65d" translate="yes" xml:space="preserve">
          <source>Overloads and Callbacks</source>
          <target state="translated">オーバーロードとコールバック</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="0577f98176563373436836dd571634165655bf7e" translate="yes" xml:space="preserve">
          <source>Packages under the &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt; organization are published automatically from &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; using the &lt;a href=&quot;https://github.com/Microsoft/types-publisher&quot;&gt;types-publisher tool&lt;/a&gt;. To get your declarations published as an @types package, please submit a pull request to &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;https://github.com/DefinitelyTyped/DefinitelyTyped&lt;/a&gt;. You can find more details in the &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;組織の下のパッケージは、 &lt;a href=&quot;https://github.com/Microsoft/types-publisher&quot;&gt;types-publisherツール&lt;/a&gt;を使用して&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;から自動的に公開されます 。 宣言を@typesパッケージとして公開するには、プルリクエストを&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;https://github.com/DefinitelyTyped/DefinitelyTypedに&lt;/a&gt;送信してください 。 詳細については、 &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;貢献ガイドラインのページをご覧ください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c05990a1953dff830b4e694fd34e78ad2c4e758" translate="yes" xml:space="preserve">
          <source>Packaging dependent declarations</source>
          <target state="translated">パッケージ化依存宣言</target>
        </trans-unit>
        <trans-unit id="f6dd7817ec1cd36abd644cfdc46d670053a1cd83" translate="yes" xml:space="preserve">
          <source>Parameter Decorators</source>
          <target state="translated">パラメータデコレーター</target>
        </trans-unit>
        <trans-unit id="2952d35fe7891ee81c4489bd1bb320a48758d659" translate="yes" xml:space="preserve">
          <source>Parameter properties</source>
          <target state="translated">パラメータのプロパティ</target>
        </trans-unit>
        <trans-unit id="23d76447f27a661de3ededbf433067f3b57aada4" translate="yes" xml:space="preserve">
          <source>Parameter properties are declared by prefixing a constructor parameter with an accessibility modifier or &lt;code&gt;readonly&lt;/code&gt;, or both. Using &lt;code&gt;private&lt;/code&gt; for a parameter property declares and initializes a private member; likewise, the same is done for &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, and &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="translated">パラメータープロパティは、コンストラクターパラメーターの前にアクセシビリティ修飾子または &lt;code&gt;readonly&lt;/code&gt; 、またはその両方を付加することで宣言されます 。 パラメータープロパティに &lt;code&gt;private&lt;/code&gt; を使用すると、privateメンバーが宣言および初期化されます。 同様に、 &lt;code&gt;public&lt;/code&gt; 、 &lt;code&gt;protected&lt;/code&gt; 、および &lt;code&gt;readonly&lt;/code&gt; についても同じことが行われます 。</target>
        </trans-unit>
        <trans-unit id="a5861a8dac7bb4d916bedc720f28896beb64d2da" translate="yes" xml:space="preserve">
          <source>Parameters declaration with names starting with &lt;code&gt;_&lt;/code&gt; are exempt from the unused parameter checking. e.g.:</source>
          <target state="translated">&lt;code&gt;_&lt;/code&gt; で始まる名前のパラメーター宣言は、未使用のパラメーター検査から除外されます。 例えば：</target>
        </trans-unit>
        <trans-unit id="1d5eb18b61aab05bdced59d235a80d553895747d" translate="yes" xml:space="preserve">
          <source>Parameters&amp;lt;T&amp;gt;</source>
          <target state="translated">Parameters&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="671f3fae2448bb236314a1b80701d38996bd864d" translate="yes" xml:space="preserve">
          <source>Parse in strict mode and emit &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; for each source file</source>
          <target state="translated">strictモードで解析し、各ソースファイルに対して &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; を発行します</target>
        </trans-unit>
        <trans-unit id="fb8f88af978dfcbfd9d18606d5785e56e50c08a4" translate="yes" xml:space="preserve">
          <source>ParseIntBasedZipCodeValidator.ts</source>
          <target state="translated">ParseIntBasedZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="81409c19eb37440fe5909d317bb07700285e2cd5" translate="yes" xml:space="preserve">
          <source>Parses all the code in strict mode.</source>
          <target state="translated">すべてのコードを strict モードで解析します。</target>
        </trans-unit>
        <trans-unit id="f6713be85ff8a869b13ef23f83e9e25ec5b50fe4" translate="yes" xml:space="preserve">
          <source>Part of the intent with composite projects (&lt;code&gt;tsconfig.json&lt;/code&gt;s with &lt;code&gt;composite&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;) is that references between different projects can be built incrementally. As such, composite projects will &lt;strong&gt;always&lt;/strong&gt; produce &lt;code&gt;.tsbuildinfo&lt;/code&gt; files.</source>
          <target state="translated">複合プロジェクト（ &lt;code&gt;composite&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; に設定された &lt;code&gt;tsconfig.json&lt;/code&gt; )の意図の一部は、異なるプロジェクト間の参照をインクリメンタルに構築できることです。 そのため、複合プロジェクトは&lt;strong&gt;常に&lt;/strong&gt; &lt;code&gt;.tsbuildinfo&lt;/code&gt; ファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="9baf9fd34f2159270424fe0e47e69d1f478939e6" translate="yes" xml:space="preserve">
          <source>Partial&amp;lt;T&amp;gt;</source>
          <target state="translated">Partial&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1acacf2ed7601dbe25241b7869667be2f4398d94" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; along with &lt;code&gt;--jsx react&lt;/code&gt; allows for using a different JSX factory from the default &lt;code&gt;React&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--jsx react&lt;/code&gt; とともに &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; を渡すと 、デフォルトの &lt;code&gt;React&lt;/code&gt; とは異なるJSXファクトリを使用できます。</target>
        </trans-unit>
        <trans-unit id="3b536ca4bd24891bd16797247b74cf70cb1d7af1" translate="yes" xml:space="preserve">
          <source>Path mapping</source>
          <target state="translated">パスマッピング</target>
        </trans-unit>
        <trans-unit id="08f69b52b9788ae6bcf8bfd7c8d5cd0f9c96b35d" translate="yes" xml:space="preserve">
          <source>Patterns that are known NOT to be supported</source>
          <target state="translated">サポートされていないことが知られているパターン</target>
        </trans-unit>
        <trans-unit id="3ba5e04e0fb30f6bbbfe6f30b3c6d01934f1ea14" translate="yes" xml:space="preserve">
          <source>Per-file JSX factories</source>
          <target state="translated">ファイル単位の JSX ファクトリ</target>
        </trans-unit>
        <trans-unit id="b69b8b40e240a5b2dde72c51f503be50a498cd27" translate="yes" xml:space="preserve">
          <source>Perform additional checks to ensure that separate compilation (such as with &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function&quot;&gt;&lt;code&gt;transpileModule&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript&quot;&gt;@babel/plugin-transform-typescript&lt;/a&gt;) would be safe.</source>
          <target state="translated">追加のチェックを実行して、個別のコンパイル（ &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function&quot;&gt; &lt;code&gt;transpileModule&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript&quot;&gt;@ babel / plugin-transform-typescriptなど&lt;/a&gt; ）が安全であることを確認します。</target>
        </trans-unit>
        <trans-unit id="f1dabf49a10166e79b1f29fd393e4de4f943c1fd" translate="yes" xml:space="preserve">
          <source>Performance Improvements</source>
          <target state="translated">パフォーマンスの向上</target>
        </trans-unit>
        <trans-unit id="967f5cced0c55dd5104813d8b961e3e82073447f" translate="yes" xml:space="preserve">
          <source>Pick&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Pick&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7dee95ba04b4d77fd014972959587737b540740a" translate="yes" xml:space="preserve">
          <source>Pitfalls of Namespaces and Modules</source>
          <target state="translated">名前空間とモジュールの落とし穴</target>
        </trans-unit>
        <trans-unit id="a68eb230823a2defe94e6d3f9718ef2ec069c259" translate="yes" xml:space="preserve">
          <source>Playground</source>
          <target state="translated">Playground</target>
        </trans-unit>
        <trans-unit id="120335d270554865b243af6b51ed8c05b0d29c22" translate="yes" xml:space="preserve">
          <source>Please note that the compiler does not include files that can be possible outputs; e.g. if the input includes &lt;code&gt;index.ts&lt;/code&gt;, then &lt;code&gt;index.d.ts&lt;/code&gt; and &lt;code&gt;index.js&lt;/code&gt; are excluded. In general, having files that differ only in extension next to each other is not recommended.</source>
          <target state="translated">コンパイラには、出力可能なファイルが含まれていないことに注意してください。 たとえば、入力に &lt;code&gt;index.ts&lt;/code&gt; が含まれる場合、 &lt;code&gt;index.d.ts&lt;/code&gt; および &lt;code&gt;index.js&lt;/code&gt; は除外されます。 一般に、拡張子のみが異なるファイルを隣り合わせにすることはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="4463cb7b6e22fa9c87c1b09f8e8ea07ce2c6475b" translate="yes" xml:space="preserve">
          <source>Please note that this comment only suppresses the error reporting, and we recommend you use this comments &lt;em&gt;very sparingly&lt;/em&gt;.</source>
          <target state="translated">このコメントはエラー報告のみを抑制するため、このコメントは&lt;em&gt;慎重に&lt;/em&gt;使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0468af199e7e628b9833d4c2499a87be9fef2421" translate="yes" xml:space="preserve">
          <source>Please note that this requires a native &lt;code&gt;Symbol.iterator&lt;/code&gt; or &lt;code&gt;Symbol.iterator&lt;/code&gt; shim at runtime for any non-array values.</source>
          <target state="translated">これには、配列以外の値に対して実行時にネイティブの &lt;code&gt;Symbol.iterator&lt;/code&gt; または &lt;code&gt;Symbol.iterator&lt;/code&gt; shimが必要であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="562837321f7a755d6cd24864fe1ca99abed6c53c" translate="yes" xml:space="preserve">
          <source>Please note that ts-loader is not the only loader for typescript.</source>
          <target state="translated">ts-loader は typescript 用の唯一のローダーではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="e4743356c30ff06ccc2c2b0526d63f34b220283d" translate="yes" xml:space="preserve">
          <source>Please notice that &lt;code&gt;&quot;paths&quot;&lt;/code&gt; are resolved relative to &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt;. When setting &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; to another value than &lt;code&gt;&quot;.&quot;&lt;/code&gt;, i.e. the directory of &lt;code&gt;tsconfig.json&lt;/code&gt;, the mappings must be changed accordingly. Say, you set &lt;code&gt;&quot;baseUrl&quot;: &quot;./src&quot;&lt;/code&gt; in the above example, then jquery should be mapped to &lt;code&gt;&quot;../node_modules/jquery/dist/jquery&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;paths&quot;&lt;/code&gt; は &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; に対して相対的に解決されることに注意してください。 &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; を &lt;code&gt;&quot;.&quot;&lt;/code&gt; 以外の値に設定する場合 、つまり &lt;code&gt;tsconfig.json&lt;/code&gt; のディレクトリ、それに応じてマッピングを変更する必要があります。 上記の例で &lt;code&gt;&quot;baseUrl&quot;: &quot;./src&quot;&lt;/code&gt; を設定すると、jqueryは &lt;code&gt;&quot;../node_modules/jquery/dist/jquery&quot;&lt;/code&gt; マッピングされるはずです。</target>
        </trans-unit>
        <trans-unit id="ead1b84f2b03206f8601dd6f8465bb1307c87f49" translate="yes" xml:space="preserve">
          <source>Polymorphic &lt;code&gt;this&lt;/code&gt; types</source>
          <target state="translated">多態的な &lt;code&gt;this&lt;/code&gt; 型</target>
        </trans-unit>
        <trans-unit id="b7ea292a6c4159dcd9f22585ce812663d7d16f67" translate="yes" xml:space="preserve">
          <source>Polymorphic this types</source>
          <target state="translated">多相的なこのタイプ</target>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes" xml:space="preserve">
          <source>Possible values are:</source>
          <target state="translated">可能な値は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="554e31701ddcf7160047ee9c5af3bc8fa8c6a72a" translate="yes" xml:space="preserve">
          <source>Postfix equals on a property type in an object literal type doesn&amp;rsquo;t specify an optional property:</source>
          <target state="translated">オブジェクトリテラルタイプのプロパティタイプのPostfix equalsは、オプションのプロパティを指定しません。</target>
        </trans-unit>
        <trans-unit id="ab664bc802e07259299c0ace87c0d6fb9adaa06b" translate="yes" xml:space="preserve">
          <source>Predefined conditional types</source>
          <target state="translated">定義済みの条件タイプ</target>
        </trans-unit>
        <trans-unit id="0ca66f1be438badc25b8b5752ef03c58e504484d" translate="yes" xml:space="preserve">
          <source>Prepending a project will include the project&amp;rsquo;s output above the output of the current project. This works for both &lt;code&gt;.js&lt;/code&gt; files and &lt;code&gt;.d.ts&lt;/code&gt; files, and source map files will also be emitted correctly.</source>
          <target state="translated">プロジェクトの先頭に追加すると、現在のプロジェクトの出力の上にプロジェクトの出力が含まれます。 これは &lt;code&gt;.js&lt;/code&gt; ファイルと &lt;code&gt;.d.ts&lt;/code&gt; ファイルの両方で機能し、ソースマップファイルも正しく出力されます。</target>
        </trans-unit>
        <trans-unit id="250b55e25eefbff70773c9389bd85b37a64c1d61" translate="yes" xml:space="preserve">
          <source>Preprocessing input files</source>
          <target state="translated">入力ファイルの前処理</target>
        </trans-unit>
        <trans-unit id="7cb4715a3e34715298728de107fabd8f250241bb" translate="yes" xml:space="preserve">
          <source>Prettier &lt;code&gt;--pretty&lt;/code&gt; output</source>
          <target state="translated">よりきれい &lt;code&gt;--pretty&lt;/code&gt; きれいな出力</target>
        </trans-unit>
        <trans-unit id="8875ea5f28b04a1dba3fc41f80791c76ff0b7712" translate="yes" xml:space="preserve">
          <source>Prettier error messages from &lt;code&gt;tsc&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; からのきれいなエラーメッセージ</target>
        </trans-unit>
        <trans-unit id="0b0889dea75b7bf162c4dd45848c6ca53d9ef522" translate="yes" xml:space="preserve">
          <source>Preventing Name Conflicts</source>
          <target state="translated">名前の衝突を防ぐ</target>
        </trans-unit>
        <trans-unit id="d3f367a0268c7a11de846832dd78b1be0177bcf5" translate="yes" xml:space="preserve">
          <source>Previously CommonJS/AMD/UMD modules were treated in the same way as ES6 modules, resulting in a couple of problems. Namely:</source>
          <target state="translated">以前のCommonJSAMDUMDモジュールはES6モジュールと同じように扱われていたため、いくつかの問題が発生していました。すなわち</target>
        </trans-unit>
        <trans-unit id="1d4fe4dbc591edaa8152b6ee157716dc7c7a69dd" translate="yes" xml:space="preserve">
          <source>Previously an error, now supported in TypeScript 1.8. &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; declarations within loops and captured in functions are now emitted to correctly match &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; freshness semantics.</source>
          <target state="translated">以前はエラーでしたが、TypeScript 1.8でサポートされるようになりました。 ループ内および関数でキャプチャされた &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; 宣言は、 &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; 鮮度のセマンティクスに正しく一致するように出力されるようになりました。</target>
        </trans-unit>
        <trans-unit id="d61f97a853643acc2132dd407bb52c28293cf6e2" translate="yes" xml:space="preserve">
          <source>Previously flagged as an invalid flag combination, &lt;code&gt;target: es5&lt;/code&gt; and &amp;lsquo;module: es6&amp;rsquo; is now supported. This should facilitate using ES2015-based tree shakers like &lt;a href=&quot;https://github.com/rollup/rollup&quot;&gt;rollup&lt;/a&gt;.</source>
          <target state="translated">以前は無効なフラグの組み合わせとしてフラグ設定されていましたが、 &lt;code&gt;target: es5&lt;/code&gt; および 'モジュール：es6'がサポートされるようになりました。 これにより、rollupなどのES2015ベースのツリーシェーカーの使用が容易になります。</target>
        </trans-unit>
        <trans-unit id="faa74f7ad7771f21799b2755f15db749aa0b46e9" translate="yes" xml:space="preserve">
          <source>Previously generators were only supported if the target is ES6/ES2015 or later. Moreover, constructs that operate on the Iterator protocol, e.g. &lt;code&gt;for..of&lt;/code&gt; were only supported if they operate on arrays for targets below ES6/ES2015.</source>
          <target state="translated">以前は、ターゲットがES6 / ES2015以降の場合にのみジェネレーターがサポートされていました。 さらに、 &lt;code&gt;for..of&lt;/code&gt; などのIteratorプロトコルで動作する構造は、ES6 / ES2015より下のターゲットのアレイで動作する場合にのみサポートされていました。</target>
        </trans-unit>
        <trans-unit id="8d6c2a15e3d095aa407d66625a136a8551aa98ed" translate="yes" xml:space="preserve">
          <source>Previously the type of a &lt;code&gt;for..in&lt;/code&gt; variable is inferred to &lt;code&gt;any&lt;/code&gt;; that allowed the compiler to ignore invalid uses within the &lt;code&gt;for..in&lt;/code&gt; body.</source>
          <target state="translated">以前は、 &lt;code&gt;for..in&lt;/code&gt; 変数の型はanyに推測され &lt;code&gt;any&lt;/code&gt; 。 これにより、コンパイラは &lt;code&gt;for..in&lt;/code&gt; 本体内の無効な使用を無視できました。</target>
        </trans-unit>
        <trans-unit id="ebaf09b657b780c25626ff17cb194ecb5fc7de40" translate="yes" xml:space="preserve">
          <source>Previously there were two options:</source>
          <target state="translated">以前は2つの選択肢がありました。</target>
        </trans-unit>
        <trans-unit id="23e202efb0fd224642346517ba263b85cbcde129" translate="yes" xml:space="preserve">
          <source>Previously type &lt;code&gt;{}&lt;/code&gt; was inferred for &lt;code&gt;obj&lt;/code&gt; and the second line subsequently caused an error because &lt;code&gt;obj&lt;/code&gt; would appear to have no properties. That obviously wasn&amp;rsquo;t ideal.</source>
          <target state="translated">以前は、 &lt;code&gt;obj&lt;/code&gt; に対してタイプ &lt;code&gt;{}&lt;/code&gt; が推測され、その後、 &lt;code&gt;obj&lt;/code&gt; にはプロパティがないように見えるため、2行目でエラーが発生しました。 それは明らかに理想的ではなかった。</target>
        </trans-unit>
        <trans-unit id="6904fbec6e39643bc5d34a20c1cf3e6eba117f94" translate="yes" xml:space="preserve">
          <source>Previously, a non-disciminated union wouldn&amp;rsquo;t have &lt;em&gt;any&lt;/em&gt; excess property checking done on its members, and as a result, the incorrectly typed &lt;code&gt;name&lt;/code&gt; property slipped by.</source>
          <target state="translated">以前は、非差別型のユニオンでは、そのメンバー&lt;em&gt;に対して&lt;/em&gt;過剰なプロパティチェックが行われず、その結果、誤って入力された &lt;code&gt;name&lt;/code&gt; プロパティがすり抜けていました。</target>
        </trans-unit>
        <trans-unit id="b72465fae7e40823511074b9719794d968033526" translate="yes" xml:space="preserve">
          <source>Previously, if TypeScript couldn&amp;rsquo;t figure out the type of a variable, it would choose the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">以前は、TypeScriptが変数の型を判別できなかった場合、 &lt;code&gt;any&lt;/code&gt; 型を選択していました。</target>
        </trans-unit>
        <trans-unit id="9db6c336a1faa6c435e85a6b4d2c798009098564" translate="yes" xml:space="preserve">
          <source>Previously, this structure was rather awkward to work with if you used a single tsconfig file:</source>
          <target state="translated">以前は、単一のtsconfigファイルを使用している場合、この構造は作業しづらいものでした。</target>
        </trans-unit>
        <trans-unit id="4ca4680280d5d8dfe7b7cb9edd9e85d1751a8dc5" translate="yes" xml:space="preserve">
          <source>Print help message.</source>
          <target state="translated">ヘルプメッセージを印刷します。</target>
        </trans-unit>
        <trans-unit id="ae5d509d63bcd9fdd20c4fe9f09a64383b22ba2a" translate="yes" xml:space="preserve">
          <source>Print names of files part of the compilation.</source>
          <target state="translated">コンパイルに含まれるファイル名を表示します。</target>
        </trans-unit>
        <trans-unit id="220c873ce1ef6bbe0f0ef43fc4cd6015a80b747a" translate="yes" xml:space="preserve">
          <source>Print names of generated files part of the compilation.</source>
          <target state="translated">コンパイルの一部として生成されたファイルの名前を表示します。</target>
        </trans-unit>
        <trans-unit id="e11fa3aee584489ac6535e0339f143acea43fb5c" translate="yes" xml:space="preserve">
          <source>Print the compiler&amp;rsquo;s version.</source>
          <target state="translated">コンパイラのバージョンを出力します。</target>
        </trans-unit>
        <trans-unit id="23bb025493ad52ae749fb36ab7d38c5792fcafeb" translate="yes" xml:space="preserve">
          <source>Prior to 3.3, building composite projects using &lt;code&gt;--build --watch&lt;/code&gt; actually didn&amp;rsquo;t use this incremental file watching infrastructure. An update in one project under &lt;code&gt;--build --watch&lt;/code&gt; mode would force a full build of that project, rather than determining which files within that project were affected.</source>
          <target state="translated">3.3より前では、 &lt;code&gt;--build --watch&lt;/code&gt; を使用して複合プロジェクトを構築する際、実際にはこの増分ファイル監視インフラストラクチャを使用していませんでした。 &lt;code&gt;--build --watch&lt;/code&gt; モードでの1つのプロジェクトの更新は、そのプロジェクト内のどのファイルが影響を受けたかを判断するのではなく、そのプロジェクトの完全ビルドを強制します。</target>
        </trans-unit>
        <trans-unit id="6a5128736476603248154c428e88c700f0590e6b" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 2.4, in the following example</source>
          <target state="translated">TypeScript 2.4以前では、以下の例では</target>
        </trans-unit>
        <trans-unit id="480d4967754d83dbb3e8d2828c5c21cd16621298" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 2.4, this example would succeed. When relating the types of &lt;code&gt;map&lt;/code&gt;, TypeScript would bidirectionally relate their parameters (i.e. the type of &lt;code&gt;f&lt;/code&gt;). When relating each &lt;code&gt;f&lt;/code&gt;, TypeScript would also bidirectionally relate the type of &lt;em&gt;those&lt;/em&gt; parameters.</source>
          <target state="translated">TypeScript 2.4より前では、この例は成功していました。 &lt;code&gt;map&lt;/code&gt; のタイプを関連付ける場合、TypeScriptはパラメーター（つまり &lt;code&gt;f&lt;/code&gt; のタイプ）を双方向に関連付けます。 各 &lt;code&gt;f&lt;/code&gt; を関連付ける場合、TypeScriptは&lt;em&gt;これらの&lt;/em&gt;パラメーターのタイプを双方向に関連付けます。</target>
        </trans-unit>
        <trans-unit id="d2ca142f68efb0104a146fa7d73e2068d50895f3" translate="yes" xml:space="preserve">
          <source>Private and Protected Constructors</source>
          <target state="translated">民間および保護された建設業者</target>
        </trans-unit>
        <trans-unit id="f4b81a5cab787b4701243c836cb9e4bed8b1e31d" translate="yes" xml:space="preserve">
          <source>Private and protected members in a class affect their compatibility. When an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class. Likewise, the same applies for an instance with a protected member. This allows a class to be assignment compatible with its super class, but &lt;em&gt;not&lt;/em&gt; with classes from a different inheritance hierarchy which otherwise have the same shape.</source>
          <target state="translated">クラス内のプライベートおよび保護されたメンバーは、それらの互換性に影響します。 クラスのインスタンスの互換性がチェックされるとき、ターゲットタイプにプライベートメンバーが含まれている場合、ソースタイプには同じクラスから派生したプライベートメンバーも含まれている必要があります。 同様に、保護されたメンバーを持つインスタンスにも同じことが当てはまります。 これにより、クラスはそのスーパークラスとの割り当て互換性を持つことが&lt;em&gt;でき&lt;/em&gt;ますが、そうでなければ同じ形状を持つ異なる継承階層からのクラスとは割り当て&lt;em&gt;られません&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="e91301edc2c04ca7b2fe236a0af7531759595434" translate="yes" xml:space="preserve">
          <source>Private and protected members in classes</source>
          <target state="translated">クラスのプライベートと保護されたメンバー</target>
        </trans-unit>
        <trans-unit id="15fd0634ed725b1581380519d93db35711d918e3" translate="yes" xml:space="preserve">
          <source>ProgrammerCalculator.ts</source>
          <target state="translated">ProgrammerCalculator.ts</target>
        </trans-unit>
        <trans-unit id="567585a6d21c8b924898dbfb1c1f5b51255b4838" translate="yes" xml:space="preserve">
          <source>Project Configuration</source>
          <target state="translated">プロジェクトの構成</target>
        </trans-unit>
        <trans-unit id="7793a73613168871bf96397b630c7423c4486ca5" translate="yes" xml:space="preserve">
          <source>Project References</source>
          <target state="translated">プロジェクトのリファレンス</target>
        </trans-unit>
        <trans-unit id="88f5397c06a7b7e37512d16b9ab11703488d260e" translate="yes" xml:space="preserve">
          <source>Project References: Build Mode for TypeScript</source>
          <target state="translated">プロジェクトのリファレンス。TypeScript のビルドモード</target>
        </trans-unit>
        <trans-unit id="754b3c7e71d4817f7d2fea3c257de1bdf3f58125" translate="yes" xml:space="preserve">
          <source>Project References: Caveats</source>
          <target state="translated">プロジェクトの参考文献。警告</target>
        </trans-unit>
        <trans-unit id="f6929baa8a0f682ca9e2d3784d0cff5d27cdab03" translate="yes" xml:space="preserve">
          <source>Project References: Caveats for Project References</source>
          <target state="translated">プロジェクトリファレンス。プロジェクトの参考文献に関する注意事項</target>
        </trans-unit>
        <trans-unit id="d0bd4d6b0aa124935089e5a1a6357f47ce88863d" translate="yes" xml:space="preserve">
          <source>Project References: MSBuild</source>
          <target state="translated">プロジェクトの参照先。MSBuild</target>
        </trans-unit>
        <trans-unit id="2d88f084a46bb059f7acb5d62832e90394777d3f" translate="yes" xml:space="preserve">
          <source>Project References: Overall Structure</source>
          <target state="translated">プロジェクトの参考資料。全体構造</target>
        </trans-unit>
        <trans-unit id="a0c2677e3090197b68e74d61303c68e7ddf04e66" translate="yes" xml:space="preserve">
          <source>Project References: Structuring for outFiles</source>
          <target state="translated">プロジェクトのリファレンス。outFilesの構造化</target>
        </trans-unit>
        <trans-unit id="810687c4e3229aa8caaccaa1985884772dfd3c9a" translate="yes" xml:space="preserve">
          <source>Project References: Structuring for relative modules</source>
          <target state="translated">プロジェクトのリファレンス。相対モジュールの構造化</target>
        </trans-unit>
        <trans-unit id="692d23787c48f3266c6f90679b8a1de2796d67f6" translate="yes" xml:space="preserve">
          <source>Project References: What is a Project Reference?</source>
          <target state="translated">プロジェクトリファレンス。プロジェクトリファレンスとは?</target>
        </trans-unit>
        <trans-unit id="394f18fdbb76c8acbdccddfc544deb4de35c052d" translate="yes" xml:space="preserve">
          <source>Project References: composite</source>
          <target state="translated">プロジェクトの参照先:複合材</target>
        </trans-unit>
        <trans-unit id="6d41bc9c0f6a331071fce870316ec281371a0d75" translate="yes" xml:space="preserve">
          <source>Project References: declarationMaps</source>
          <target state="translated">プロジェクトの参照先:declarationMaps</target>
        </trans-unit>
        <trans-unit id="908cd420bcb700a967b280f8a7dff581392527b2" translate="yes" xml:space="preserve">
          <source>Project References: prepend with outFile</source>
          <target state="translated">プロジェクトのリファレンス:outFileの前に</target>
        </trans-unit>
        <trans-unit id="64e335b1c5f861587f8782361a5af32ae20dcd21" translate="yes" xml:space="preserve">
          <source>Project References: tsc -b Commandline</source>
          <target state="translated">プロジェクトリファレンス:tsc -b コマンドライン</target>
        </trans-unit>
        <trans-unit id="fd7a6c05d7b3d7052f1c042cfc959322d90b11a4" translate="yes" xml:space="preserve">
          <source>Project references are a new feature in TypeScript 3.0 that allow you to structure your TypeScript programs into smaller pieces.</source>
          <target state="translated">プロジェクト参照は、TypeScript 3.0の新機能であり、TypeScriptプログラムをより小さなピースで構成することができます。</target>
        </trans-unit>
        <trans-unit id="4c6c967b1595e112d0adf09d5676eb35634edcb7" translate="yes" xml:space="preserve">
          <source>Project references can solve all of these problems and more.</source>
          <target state="translated">プロジェクトの参照は、これらの問題などをすべて解決することができます。</target>
        </trans-unit>
        <trans-unit id="1b126f1d1bec5fc383003c78a666ee84f0286aac" translate="yes" xml:space="preserve">
          <source>Project references have a few trade-offs you should be aware of.</source>
          <target state="translated">プロジェクトのリファレンスには、知っておくべきトレードオフがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="d846e8e5c61d018f2fdaece28ac3df9b54800862" translate="yes" xml:space="preserve">
          <source>Project support through &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; によるプロジェクトサポート</target>
        </trans-unit>
        <trans-unit id="3d66fcc6f48609ad7f0ccc3524762b07b0fb5050" translate="yes" xml:space="preserve">
          <source>Properties are inferred from assignments in class bodies</source>
          <target state="translated">プロパティは、クラス本体の代入から推測されます。</target>
        </trans-unit>
        <trans-unit id="33bbcb8beed2dadd8ed7e8a6d283214d6efdf708" translate="yes" xml:space="preserve">
          <source>Properties declarations on functions</source>
          <target state="translated">関数のプロパティ宣言</target>
        </trans-unit>
        <trans-unit id="2e110b7b4893d92d3e7aa88aa3a301b45ead4967" translate="yes" xml:space="preserve">
          <source>Properties in the object binding pattern that have no match in the object literal are required to have a default value in the object binding pattern and are automatically added to the object literal type.</source>
          <target state="translated">オブジェクトリテラルに一致しないオブジェクトバインディングパターンのプロパティは、オブジェクトバインディングパターンでデフォルト値を持つ必要があり、オブジェクトリテラル型に自動的に追加されます。</target>
        </trans-unit>
        <trans-unit id="c8c07940eda3231c047d293da9f37f7834dd40cb" translate="yes" xml:space="preserve">
          <source>Properties in the object literal that have no match in the object binding pattern are an error.</source>
          <target state="translated">オブジェクト・リテラル内のプロパティで、オブジェクト・バインディング・パターンに一致しないものはエラーです。</target>
        </trans-unit>
        <trans-unit id="f8cc4919fcb9285716ac09c9df472748a0cd6f09" translate="yes" xml:space="preserve">
          <source>Properties with default values in the object binding pattern become optional in the object literal.</source>
          <target state="translated">オブジェクト・バインディング・パターンのデフォルト値を持つプロパティは、オブジェクト・リテラルではオプションになります。</target>
        </trans-unit>
        <trans-unit id="3cbcb3278bdf5d0340f45b88be40ef4d53f50ba6" translate="yes" xml:space="preserve">
          <source>Property Decorators</source>
          <target state="translated">プロパティデコレーター</target>
        </trans-unit>
        <trans-unit id="ce5358cfe7c2a6843f2919f24e964b409bffae5b" translate="yes" xml:space="preserve">
          <source>Property assignments and non-generic spread expressions are merged to the greatest extent possible on either side of a generic spread expression. For example:</source>
          <target state="translated">プロパティの割り当てと非ジェネリックな広がり表現は、ジェネリックな広がり表現の両側で可能な限りマージされます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="832f7d76da1eb3d3ed83c2498cd0b5b699ea5efe" translate="yes" xml:space="preserve">
          <source>Property renaming</source>
          <target state="translated">プロパティの名称変更</target>
        </trans-unit>
        <trans-unit id="28531336563e1f3883b87d858af447e561471bd7" translate="yes" xml:space="preserve">
          <source>Protected</source>
          <target state="translated">Protected</target>
        </trans-unit>
        <trans-unit id="f0e692539cb524363ffe3c3313543515de8c4424" translate="yes" xml:space="preserve">
          <source>Prototype assignment</source>
          <target state="translated">プロトタイプの割り当て</target>
        </trans-unit>
        <trans-unit id="001b7307089ddcafb90fad2dff22ffc7a1e3c62c" translate="yes" xml:space="preserve">
          <source>Provide full support for iterables in &lt;code&gt;for..of&lt;/code&gt;, spread and destructuring when targeting ES5 or ES3.</source>
          <target state="translated">ES5またはES3を対象とする場合、 &lt;code&gt;for..of&lt;/code&gt; 、拡散、および構造化でイテラブルの完全なサポートを提供します。</target>
        </trans-unit>
        <trans-unit id="a1146ed26ee333eed6d3996e25afdde504ab9e9b" translate="yes" xml:space="preserve">
          <source>Public by default</source>
          <target state="translated">デフォルトではパブリック</target>
        </trans-unit>
        <trans-unit id="df1e7a58b300fcd2018db41d09e99c76f51ccd9c" translate="yes" xml:space="preserve">
          <source>Public, private, and protected modifiers</source>
          <target state="translated">パブリック、プライベート、保護された修飾子</target>
        </trans-unit>
        <trans-unit id="4aeb4ef1d8df7836057d41c034dc834be57b173f" translate="yes" xml:space="preserve">
          <source>Publish to &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@typesに&lt;/a&gt;公開する</target>
        </trans-unit>
        <trans-unit id="b1aa195e794b4f66b923622c595d29c04615285a" translate="yes" xml:space="preserve">
          <source>Publish to npm</source>
          <target state="translated">npmへの公開</target>
        </trans-unit>
        <trans-unit id="338b45a6751558a0e49cb2d757f64736adc58f12" translate="yes" xml:space="preserve">
          <source>Publishing</source>
          <target state="translated">Publishing</target>
        </trans-unit>
        <trans-unit id="be0e9506d0fd3f0204f58e0f5b06282be66a0f23" translate="yes" xml:space="preserve">
          <source>Publishing: Dependencies</source>
          <target state="translated">出版:依存関係</target>
        </trans-unit>
        <trans-unit id="ed87f3075dc9e52018557fb97c9010a8f00d2af8" translate="yes" xml:space="preserve">
          <source>Publishing: Publish to @types</source>
          <target state="translated">パブリッシング:@typesにパブリッシュ</target>
        </trans-unit>
        <trans-unit id="c25e21d552520e10e91602755603035ee2dc11de" translate="yes" xml:space="preserve">
          <source>Publishing: Red flags</source>
          <target state="translated">出版:レッドフラッグ</target>
        </trans-unit>
        <trans-unit id="322bb8d07bb59be9606da97b40f86a36058152ee" translate="yes" xml:space="preserve">
          <source>Put a breakpoint on the line with return.</source>
          <target state="translated">リターンでラインにブレークポイントを置く。</target>
        </trans-unit>
        <trans-unit id="a1b752d5b588559d3c1ab9de849d0678ef2991f1" translate="yes" xml:space="preserve">
          <source>Putting all of the above rules together in an example</source>
          <target state="translated">上記のルールをすべて例に挙げると</target>
        </trans-unit>
        <trans-unit id="c148aded3d47eba6bad059e92b2038d207b0a750" translate="yes" xml:space="preserve">
          <source>Putting it all together</source>
          <target state="translated">まとめてみると</target>
        </trans-unit>
        <trans-unit id="224762d86a9baf2c769b2d7a923fbcab59d453ee" translate="yes" xml:space="preserve">
          <source>Raise error on &lt;code&gt;this&lt;/code&gt; expressions with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">暗黙の &lt;code&gt;any&lt;/code&gt; タイプを使用して、 &lt;code&gt;this&lt;/code&gt; 式のエラーを発生させます 。</target>
        </trans-unit>
        <trans-unit id="36eec16ea1bf9722ff825e6c1dfe6c84e5ad8600" translate="yes" xml:space="preserve">
          <source>Raise error on expressions and declarations with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">暗黙の &lt;code&gt;any&lt;/code&gt; タイプを持つ式および宣言でエラーを発生させます 。</target>
        </trans-unit>
        <trans-unit id="374e9f700483653b29a58cc7f00cdaf51ae907b5" translate="yes" xml:space="preserve">
          <source>Rather than actually execute a build with the other input options and config files, show the final implied config file in the output.</source>
          <target state="translated">他の入力オプションとコンフィグファイルを使って実際にビルドを実行するのではなく、最終的なインプライドされたコンフィグファイルを出力に表示します。</target>
        </trans-unit>
        <trans-unit id="8b1872d78c17fd0391a92cf444a735ee5e6bae28" translate="yes" xml:space="preserve">
          <source>Re-compiling, you&amp;rsquo;ll now see an error:</source>
          <target state="translated">再コンパイルすると、エラーが表示されます。</target>
        </trans-unit>
        <trans-unit id="6c315f12f77496f53aa14fdb148faec85d5b7486" translate="yes" xml:space="preserve">
          <source>Re-declarations and Shadowing</source>
          <target state="translated">再宣言とシャドーイング</target>
        </trans-unit>
        <trans-unit id="fdc685fb106414cf637a1b38813a53d910b18ec9" translate="yes" xml:space="preserve">
          <source>Re-export to extend</source>
          <target state="translated">拡張するための再エクスポート</target>
        </trans-unit>
        <trans-unit id="648cfabc9a420f1e968be9f4f509254b2ab2cbc0" translate="yes" xml:space="preserve">
          <source>Re-exporting</source>
          <target state="translated">Re-exporting</target>
        </trans-unit>
        <trans-unit id="eda2bfe47f1cfbe6424bba7d3a76f901f6b42466" translate="yes" xml:space="preserve">
          <source>Re-exports</source>
          <target state="translated">Re-exports</target>
        </trans-unit>
        <trans-unit id="eb5bcada059371623621a43a8e7c9b5feeb2c5ef" translate="yes" xml:space="preserve">
          <source>Re-run &lt;code&gt;tsc greeter.ts&lt;/code&gt; and you&amp;rsquo;ll see the generated JavaScript is the same as the earlier code. Classes in TypeScript are just a shorthand for the same prototype-based OO that is frequently used in JavaScript.</source>
          <target state="translated">&lt;code&gt;tsc greeter.ts&lt;/code&gt; を再実行すると、生成されたJavaScriptが以前のコードと同じであることがわかります。 TypeScriptのクラスは、JavaScriptで頻繁に使用される同じプロトタイプベースのオブジェクト指向の短縮形です。</target>
        </trans-unit>
        <trans-unit id="0800d078d61e87e277eaae4d8414a88253e82cf4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack</source>
          <target state="translated">React＆Webpack</target>
        </trans-unit>
        <trans-unit id="c6ad73159db4fbc79a9e826240d2405491564ef3" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Add a TypeScript configuration file</source>
          <target state="translated">React＆Webpack：TypeScript構成ファイルを追加する</target>
        </trans-unit>
        <trans-unit id="328cdad5c6c6e56604b6063e3fdaca83a43aa289" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Create a webpack configuration file</source>
          <target state="translated">React＆Webpack：Webpack構成ファイルを作成する</target>
        </trans-unit>
        <trans-unit id="b99e8dd71da2d3b5ad0aa22f4c73bf525f613bf7" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Initialize the project</source>
          <target state="translated">React＆Webpack：プロジェクトを初期化する</target>
        </trans-unit>
        <trans-unit id="e79de56f4434ed0a6e8d586e225decedd4a4b91a" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Install our dependencies</source>
          <target state="translated">React＆Webpack：依存関係をインストールします</target>
        </trans-unit>
        <trans-unit id="a6f634b484a857760fd1fe0c0b8caa1f4ad1a7a4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Lay out the project</source>
          <target state="translated">React＆Webpack：プロジェクトをレイアウトする</target>
        </trans-unit>
        <trans-unit id="70d16f67e5b10f58dde0039090fa1f15716caaa4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Putting it all together</source>
          <target state="translated">React＆Webpack：すべてをまとめる</target>
        </trans-unit>
        <trans-unit id="c1326a95c630b81552ae15e8939b25927eca9f30" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Write some code</source>
          <target state="translated">React＆Webpack：いくつかのコードを書く</target>
        </trans-unit>
        <trans-unit id="58842bd13325c48a2698202bdb55d3b757360943" translate="yes" xml:space="preserve">
          <source>React integration</source>
          <target state="translated">リアクト統合</target>
        </trans-unit>
        <trans-unit id="3ce4f7210a5cf94a25154fce20154f3f93c9f258" translate="yes" xml:space="preserve">
          <source>React-native build pipeline expects all files to have a &lt;code&gt;.js&lt;/code&gt; extensions even if the file contains JSX syntax. The new &lt;code&gt;--jsx&lt;/code&gt; value &lt;code&gt;react-native&lt;/code&gt; will persevere the JSX syntax in the output file, but give it a &lt;code&gt;.js&lt;/code&gt; extension.</source>
          <target state="translated">React-nativeビルドパイプラインは、ファイルにJSX構文が含まれている場合でも、すべてのファイルに &lt;code&gt;.js&lt;/code&gt; 拡張子が付いていることを想定しています。 新しい &lt;code&gt;--jsx&lt;/code&gt; 値 &lt;code&gt;react-native&lt;/code&gt; は、出力ファイルのJSX構文を保持しますが、 &lt;code&gt;.js&lt;/code&gt; 拡張子を付けます。</target>
        </trans-unit>
        <trans-unit id="91699c24f2e0a9b9e92adecd16c0b3f7f436f6cb" translate="yes" xml:space="preserve">
          <source>Read in any files it understands in the &lt;code&gt;src&lt;/code&gt; directory (with &lt;code&gt;include&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; ディレクトリにある（ &lt;code&gt;include&lt;/code&gt; を使用して ）理解しているファイルを読み込みます。</target>
        </trans-unit>
        <trans-unit id="2a5eba8a5ad07b0a44f5a4a457fdc20c1b7dbf7f" translate="yes" xml:space="preserve">
          <source>Read-only properties and index signatures</source>
          <target state="translated">読み取り専用のプロパティとインデックス署名</target>
        </trans-unit>
        <trans-unit id="98f4c7227b38a0bf0e16a93bbf9b95c02d029667" translate="yes" xml:space="preserve">
          <source>Read-only properties may have initializers and may be assigned to in constructors within the same class declaration, but otherwise assignments to read-only properties are disallowed.</source>
          <target state="translated">読み取り専用プロパティはイニシャライザを持つことができ、同じクラス宣言内のコンストラクタに代入することができますが、それ以外の場合は読み取り専用プロパティへの代入は禁止されています。</target>
        </trans-unit>
        <trans-unit id="7386588f18988cfe9593c3202dc16be85d972e3f" translate="yes" xml:space="preserve">
          <source>Readonly modifier</source>
          <target state="translated">読み取り専用修飾子</target>
        </trans-unit>
        <trans-unit id="097c59114ca50eec3cf0a821be259c50e9b74d04" translate="yes" xml:space="preserve">
          <source>Readonly properties</source>
          <target state="translated">読み取り専用プロパティ</target>
        </trans-unit>
        <trans-unit id="6d74bc61c8b8b435782687890427a863cef761e7" translate="yes" xml:space="preserve">
          <source>Readonly&amp;lt;T&amp;gt;</source>
          <target state="translated">Readonly&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4699a4a521bfdbbfcae804201e013659f911e1a8" translate="yes" xml:space="preserve">
          <source>Ready? Take a look:</source>
          <target state="translated">準備はいいですか?見てみろ</target>
        </trans-unit>
        <trans-unit id="0cbc39f65d2c6c44eebf7ed41f07d520bd81bbe9" translate="yes" xml:space="preserve">
          <source>Real applications, however, look like &lt;code&gt;Readonly&lt;/code&gt; or &lt;code&gt;Partial&lt;/code&gt; above. They&amp;rsquo;re based on some existing type, and they transform the properties in some way. That&amp;rsquo;s where &lt;code&gt;keyof&lt;/code&gt; and indexed access types come in:</source>
          <target state="translated">ただし、実際のアプリケーションは、上記の &lt;code&gt;Readonly&lt;/code&gt; または &lt;code&gt;Partial&lt;/code&gt; のように見えます。 既存のタイプに基づいており、何らかの方法でプロパティを変換します。 それが &lt;code&gt;keyof&lt;/code&gt; およびインデックス付きアクセスタイプの出番です。</target>
        </trans-unit>
        <trans-unit id="f1d90148c2f9c29ea449489201d6864609117f05" translate="yes" xml:space="preserve">
          <source>Recall how to write a type assertion:</source>
          <target state="translated">型アサーションの書き方を思い出してください。</target>
        </trans-unit>
        <trans-unit id="c5d97500640d6a0752241e63626a067412fd2a00" translate="yes" xml:space="preserve">
          <source>Recall that Node.js looked for a file named &lt;code&gt;moduleB.js&lt;/code&gt;, then an applicable &lt;code&gt;package.json&lt;/code&gt;, and then for an &lt;code&gt;index.js&lt;/code&gt;.</source>
          <target state="translated">Node.jsは &lt;code&gt;moduleB.js&lt;/code&gt; という名前のファイル、次に該当する &lt;code&gt;package.json&lt;/code&gt; を 探し 、次に &lt;code&gt;index.js&lt;/code&gt; を探したことを思い出してください。</target>
        </trans-unit>
        <trans-unit id="af653faed29a78b35af6aadab7ff219a754ccd8b" translate="yes" xml:space="preserve">
          <source>Recall that with our earlier &lt;code&gt;setTimeout&lt;/code&gt; example, we ended up needing to use an IIFE to capture the state of a variable for every iteration of the &lt;code&gt;for&lt;/code&gt; loop. In effect, what we were doing was creating a new variable environment for our captured variables. That was a bit of a pain, but luckily, you&amp;rsquo;ll never have to do that again in TypeScript.</source>
          <target state="translated">以前の &lt;code&gt;setTimeout&lt;/code&gt; の例では、IIFEを使用して &lt;code&gt;for&lt;/code&gt; ループの反復ごとに変数の状態をキャプチャする必要があったことを思い出してください。 実際、私たちが行っていたのは、取得した変数用の新しい変数環境を作成することでした。 それは少し苦痛でしたが、幸いなことに、TypeScriptでこれを再度行う必要はありません。</target>
        </trans-unit>
        <trans-unit id="4faa65b556f68207d69cb14bcae4acb71980a036" translate="yes" xml:space="preserve">
          <source>Recommendations</source>
          <target state="translated">Recommendations</target>
        </trans-unit>
        <trans-unit id="5838e1d2256d8060aa1b3a66e780f5f99fa40b5e" translate="yes" xml:space="preserve">
          <source>Record&amp;lt;K,T&amp;gt;</source>
          <target state="translated">Record&amp;lt;K,T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4a41add58030e39fbaf51db74fe2dbb02e5e4ab1" translate="yes" xml:space="preserve">
          <source>Red Flags</source>
          <target state="translated">赤旗</target>
        </trans-unit>
        <trans-unit id="34d53f3ab50503026ac59429b75482fa11e6a5b9" translate="yes" xml:space="preserve">
          <source>Red flags</source>
          <target state="translated">赤旗</target>
        </trans-unit>
        <trans-unit id="9103e88842d8a8fd8fdef77a63d0bed96f6e7b8c" translate="yes" xml:space="preserve">
          <source>Redirect output structure to the directory.</source>
          <target state="translated">出力構造体をディレクトリにリダイレクトします。</target>
        </trans-unit>
        <trans-unit id="4712f8dca718bd28253a5790647646c3533841da" translate="yes" xml:space="preserve">
          <source>Referenced projects must have the new &lt;code&gt;composite&lt;/code&gt; setting enabled. This setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project. Enabling the &lt;code&gt;composite&lt;/code&gt; flag changes a few things:</source>
          <target state="translated">参照プロジェクトでは、新しい &lt;code&gt;composite&lt;/code&gt; 設定を有効にする必要があります。 この設定は、TypeScriptが参照プロジェクトの出力の場所を迅速に判断できるようにするために必要です。 &lt;code&gt;composite&lt;/code&gt; フラグを有効にすると、いくつかの変更が行われます。</target>
        </trans-unit>
        <trans-unit id="f716fe211e8cbfb1b5ac185fb3d6bbbbc2b34ab2" translate="yes" xml:space="preserve">
          <source>Referring to objects in the value space as types doesn&amp;rsquo;t work unless the object also creates a type, like a constructor function.</source>
          <target state="translated">値空間内のオブジェクトを型として参照することは、オブジェクトがコンストラクター関数などの型も作成しない限り機能しません。</target>
        </trans-unit>
        <trans-unit id="917df91e1730cb55ff8aba76f721651a6b54a840" translate="yes" xml:space="preserve">
          <source>Related</source>
          <target state="translated">Related</target>
        </trans-unit>
        <trans-unit id="0d61ba1d171892a4a7567647b72650543ee4275d" translate="yes" xml:space="preserve">
          <source>Relative paths are fairly straightforward. As an example, let&amp;rsquo;s consider a file located at &lt;code&gt;/root/src/moduleA.js&lt;/code&gt;, which contains the import &lt;code&gt;var x = require(&quot;./moduleB&quot;);&lt;/code&gt; Node.js resolves that import in the following order:</source>
          <target state="translated">相対パスはかなり簡単です。 例として、import &lt;code&gt;var x = require(&quot;./moduleB&quot;);&lt;/code&gt; を含む &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; にあるファイルを考えてみましょう。 Node.jsは、次の順序でインポートを解決します。</target>
        </trans-unit>
        <trans-unit id="227f526e9deba436f5046f9ae5ceb4b3a9053811" translate="yes" xml:space="preserve">
          <source>Relative vs. Non-relative module imports</source>
          <target state="translated">相対的なモジュールのインポートと非相対的なモジュールのインポート</target>
        </trans-unit>
        <trans-unit id="2ff253f328340904e6aa7b404e19bda3c645fe78" translate="yes" xml:space="preserve">
          <source>Relaxing declaration emit visiblity rules</source>
          <target state="translated">緩和宣言は可視性のルールを放出する</target>
        </trans-unit>
        <trans-unit id="1d3768a1e142e6e3ef4c29558ba7b7010322ddb0" translate="yes" xml:space="preserve">
          <source>Remember what we mentioned earlier about variable capturing? Every function expression we pass to &lt;code&gt;setTimeout&lt;/code&gt; actually refers to the same &lt;code&gt;i&lt;/code&gt; from the same scope.</source>
          <target state="translated">変数のキャプチャについて前に述べたことを覚えていますか？ &lt;code&gt;setTimeout&lt;/code&gt; に渡すすべての関数式は、実際には同じスコープの同じ &lt;code&gt;i&lt;/code&gt; を参照します。</target>
        </trans-unit>
        <trans-unit id="f11d0e5af8f40be276413a0572f57b6d8abf9e52" translate="yes" xml:space="preserve">
          <source>Remove all comments except copy-right header comments beginning with &lt;code&gt;/*!&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;/*!&lt;/code&gt; 始まるコピーライトヘッダーコメントを除くすべてのコメントを削除します。</target>
        </trans-unit>
        <trans-unit id="64f0b6609e1215f1c7351fcea7e64bd711ee68cd" translate="yes" xml:space="preserve">
          <source>Removes the &amp;lsquo;this&amp;rsquo; parameter from a function type.</source>
          <target state="translated">関数タイプから「this」パラメーターを削除します。</target>
        </trans-unit>
        <trans-unit id="458347c4b08c20b7988b89261e9a532ec566adc1" translate="yes" xml:space="preserve">
          <source>Replace the contents of the &lt;code&gt;tsconfig.json&lt;/code&gt; file with:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; ファイルの内容を次のものに置き換えます。</target>
        </trans-unit>
        <trans-unit id="bf9bdd295fb0df2de64ff2a20d94e74886937c45" translate="yes" xml:space="preserve">
          <source>Report an error when not all code paths in function return a value.</source>
          <target state="translated">関数内のすべてのコードパスが値を返すわけではない場合にエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="4bfcecd38bfeff6fffc3ecafa503fe73a31b3529" translate="yes" xml:space="preserve">
          <source>Report errors for fallthrough cases in switch statement.</source>
          <target state="translated">switch文のフォールスルーケースのエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="f8c20651b90e6cd8477684950f963b02e2099736" translate="yes" xml:space="preserve">
          <source>Report errors in &lt;code&gt;.js&lt;/code&gt; files. Use in conjunction with &lt;code&gt;--allowJs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; ファイルのエラーを報告します。 &lt;code&gt;--allowJs&lt;/code&gt; と組み合わせて使用​​します。</target>
        </trans-unit>
        <trans-unit id="c2375f497601629902de6816b8348dc646a011d3" translate="yes" xml:space="preserve">
          <source>Report errors on unused locals.</source>
          <target state="translated">未使用のローカルのエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="4e4da7a34ece0e23f3bacbbf60ec3ad07461c31d" translate="yes" xml:space="preserve">
          <source>Report errors on unused parameters.</source>
          <target state="translated">使用されていないパラメータのエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="d1c09f6c73919c0ebd1abbfd86f69d2cd3437aeb" translate="yes" xml:space="preserve">
          <source>Report module resolution log messages.</source>
          <target state="translated">モジュールの解決ログメッセージを報告します。</target>
        </trans-unit>
        <trans-unit id="99bc390ff55a2eb33efc222d7c8bb02d1504d6e7" translate="yes" xml:space="preserve">
          <source>Required type parameters must not follow optional type parameters.</source>
          <target state="translated">必須の型パラメータは、オプションの型パラメータの後に続いてはいけません。</target>
        </trans-unit>
        <trans-unit id="6b52890a8d8bb281f971e8b6c6fc68eebe6bbc98" translate="yes" xml:space="preserve">
          <source>Required&amp;lt;T&amp;gt;</source>
          <target state="translated">Required&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cdc1d535ad72977d21e2597085ca79e9eac4c98a" translate="yes" xml:space="preserve">
          <source>Required, optional, and default parameters all have one thing in common: they talk about one parameter at a time. Sometimes, you want to work with multiple parameters as a group, or you may not know how many parameters a function will ultimately take. In JavaScript, you can work with the arguments directly using the &lt;code&gt;arguments&lt;/code&gt; variable that is visible inside every function body.</source>
          <target state="translated">必須、オプション、およびデフォルトのパラメーターはすべて、1つの共通点があります。一度に1つのパラメーターについて話します。 グループとして複数のパラメーターを使用したい場合や、関数が最終的にいくつのパラメーターを取るか分からない場合があります。 JavaScriptでは、すべての関数本体の内部に表示される &lt;code&gt;arguments&lt;/code&gt; 変数を使用して、引数を直接操作できます。</target>
        </trans-unit>
        <trans-unit id="bb59a7085d1d1d9d3f072f5c7166cfdbf3c3fa4d" translate="yes" xml:space="preserve">
          <source>Resolve &lt;code&gt;keyof&lt;/code&gt; to string valued property names only (no numbers or symbols).</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; を文字列値のプロパティ名のみに解決します（数字や記号は不可）。</target>
        </trans-unit>
        <trans-unit id="3e884a460b4d82c0f0401e11f902d2d3991a0a50" translate="yes" xml:space="preserve">
          <source>Rest Parameters</source>
          <target state="translated">休息パラメータ</target>
        </trans-unit>
        <trans-unit id="beeb7a77ad3e842a8cb47b5d6131631a494608b1" translate="yes" xml:space="preserve">
          <source>Rest elements in tuple types</source>
          <target state="translated">タプル型のレスト要素</target>
        </trans-unit>
        <trans-unit id="50be0fe30fc10dc88af852c9cb7c36370f77be27" translate="yes" xml:space="preserve">
          <source>Rest elements in tuple types.</source>
          <target state="translated">タプル型のレスト要素。</target>
        </trans-unit>
        <trans-unit id="387816de015267e69071ea349b674f6e1d757b14" translate="yes" xml:space="preserve">
          <source>Rest parameters with tuple types</source>
          <target state="translated">タプル型を持つ残りのパラメータ</target>
        </trans-unit>
        <trans-unit id="191ff62bcfa7d34e1a815740c74afda07b8c1e33" translate="yes" xml:space="preserve">
          <source>Results in an output such as:</source>
          <target state="translated">のような出力になります。</target>
        </trans-unit>
        <trans-unit id="69fa7005e9e1a4d2f5ae93f2373b3b809a4f2af9" translate="yes" xml:space="preserve">
          <source>Results in the following generated code:</source>
          <target state="translated">結果として、以下のようなコードが生成されます。</target>
        </trans-unit>
        <trans-unit id="02d55b2baf2725bcbe0634735b4de01c005aa3e5" translate="yes" xml:space="preserve">
          <source>Results in:</source>
          <target state="translated">結果が出ています。</target>
        </trans-unit>
        <trans-unit id="642d8f2cc4c0bf44f7ec4417fc288bf230277121" translate="yes" xml:space="preserve">
          <source>Return Types of Callbacks</source>
          <target state="translated">コールバックの戻り値の種類</target>
        </trans-unit>
        <trans-unit id="d87cabec32902153d1d79b8b11bc188472a6cc03" translate="yes" xml:space="preserve">
          <source>Return types as inference targets</source>
          <target state="translated">推論対象としての戻り値の型</target>
        </trans-unit>
        <trans-unit id="af8759585cf2cfe7a7c8a45a7ecabdbfd11cd2db" translate="yes" xml:space="preserve">
          <source>ReturnType&amp;lt;T&amp;gt;</source>
          <target state="translated">ReturnType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="251cfcc8db7eb197ba54907567e2b369dc7b23af" translate="yes" xml:space="preserve">
          <source>Reusable Types (Interfaces)</source>
          <target state="translated">再利用可能なタイプ(インターフェース)</target>
        </trans-unit>
        <trans-unit id="d6640a4d11aa6f54309d2fb5c213135e2c58c777" translate="yes" xml:space="preserve">
          <source>Reusable Types (Type Aliases)</source>
          <target state="translated">再利用可能なタイプ(タイプエイリアス</target>
        </trans-unit>
        <trans-unit id="221e6da1276e8997b6b6f436b2f947172bae0726" translate="yes" xml:space="preserve">
          <source>Reverse mappings</source>
          <target state="translated">逆マッピング</target>
        </trans-unit>
        <trans-unit id="9a135d61c072a9901e22aab7a06796f5a0db008c" translate="yes" xml:space="preserve">
          <source>Right click on &lt;code&gt;scripts&lt;/code&gt; and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;TypeScript File&lt;/strong&gt; and name the file &lt;code&gt;app.ts&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;scripts&lt;/code&gt; を右クリックし、[ &lt;strong&gt;新しいアイテム&lt;/strong&gt; ]をクリックします。 次に、 &lt;strong&gt;TypeScript File&lt;/strong&gt;を選択し、ファイルに &lt;code&gt;app.ts&lt;/code&gt; という名前を付けます</target>
        </trans-unit>
        <trans-unit id="46718d1e29791accf85fa69e3063268fff2968e4" translate="yes" xml:space="preserve">
          <source>Right click on the &lt;code&gt;wwwroot&lt;/code&gt; folder (if you don&amp;rsquo;t see the folder try building the project) and add a New Item named &lt;code&gt;index.html&lt;/code&gt; inside. Use the following code for &lt;code&gt;index.html &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;wwwroot&lt;/code&gt; フォルダーを右クリックし（フォルダーが表示されない場合は、プロジェクトをビルドしてみてください）、内部に &lt;code&gt;index.html&lt;/code&gt; という名前の新しいアイテムを追加します。 &lt;code&gt;index.html &lt;/code&gt; には次のコードを使用します</target>
        </trans-unit>
        <trans-unit id="f52ba130a82d88fb66ffcaad9e4d91c2445da38b" translate="yes" xml:space="preserve">
          <source>Right click on the project and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;JavaScript File&lt;/strong&gt; and use the name of &lt;code&gt;gulpfile.js&lt;/code&gt;</source>
          <target state="translated">プロジェクトを右クリックして、 &lt;strong&gt;「新規アイテム」&lt;/strong&gt;をクリックします。 次に、 &lt;strong&gt;JavaScriptファイル&lt;/strong&gt;を選択し、 &lt;code&gt;gulpfile.js&lt;/code&gt; の名前を使用します</target>
        </trans-unit>
        <trans-unit id="7e501a41bf28a9903be39bc35a602a8ca106603f" translate="yes" xml:space="preserve">
          <source>Right-Click -&amp;gt; Manage NuGet Packages</source>
          <target state="translated">右クリック-&amp;gt; NuGetパッケージの管理</target>
        </trans-unit>
        <trans-unit id="c8a67c2b7fee671c0d27e33fbdf91828d8346fc3" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;tsc --init&lt;/code&gt; in a directory to create an initial &lt;code&gt;tsconfig.json&lt;/code&gt; in this directory with preset defaults. Optionally pass command line arguments along with &lt;code&gt;--init&lt;/code&gt; to be stored in your initial tsconfig.json on creation.</source>
          <target state="translated">ディレクトリで &lt;code&gt;tsc --init&lt;/code&gt; を実行して、このディレクトリにデフォルトの事前設定で初期 &lt;code&gt;tsconfig.json&lt;/code&gt; を作成します。 オプションで、コマンドライン引数を &lt;code&gt;--init&lt;/code&gt; とともに渡し、作成時に初期tsconfig.jsonに保存されます。</target>
        </trans-unit>
        <trans-unit id="7418ce51bc901e2c720b082e836bfd88f7024c62" translate="yes" xml:space="preserve">
          <source>Run the application and make sure that it works.</source>
          <target state="translated">アプリケーションを実行して、動作することを確認してください。</target>
        </trans-unit>
        <trans-unit id="7e0fc2451d2efaadd8b864a6b91ae00ff2dca3ac" translate="yes" xml:space="preserve">
          <source>Run the compiler in watch mode. Watch input files and trigger recompilation on changes. The implementation of watching files and directories can be configured using environment variable. See &lt;a href=&quot;configuring-watch&quot;&gt;configuring watch&lt;/a&gt; for more details.</source>
          <target state="translated">コンパイラを監視モードで実行します。 入力ファイルを監視し、変更時に再コンパイルをトリガーします。 監視ファイルとディレクトリの実装は、環境変数を使用して構成できます。 詳細については、 &lt;a href=&quot;configuring-watch&quot;&gt;時計の設定&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="541995e6de639764055cf456f41bfe89e00d49e7" translate="yes" xml:space="preserve">
          <source>Run the project</source>
          <target state="translated">プロジェクトの実行</target>
        </trans-unit>
        <trans-unit id="5ea024956a0df9ff6595fe749c1eb6c02cc2dc2f" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;tsc --build&lt;/code&gt; (&lt;code&gt;tsc -b&lt;/code&gt; for short) will do the following:</source>
          <target state="translated">&lt;code&gt;tsc --build&lt;/code&gt; （ &lt;code&gt;tsc -b&lt;/code&gt; ）を実行すると、次のことが行われます。</target>
        </trans-unit>
        <trans-unit id="88a02590b48e29c8ee3a28ec7ba7ee167b44c09c" translate="yes" xml:space="preserve">
          <source>Running your TypeScript web app</source>
          <target state="translated">TypeScript ウェブアプリを実行する</target>
        </trans-unit>
        <trans-unit id="e2a41db8c3523e88ee5980c0cbd2788f6889d1f9" translate="yes" xml:space="preserve">
          <source>Sample: Dynamic Module Loading in System.js</source>
          <target state="translated">サンプル。System.jsでの動的モジュールロード</target>
        </trans-unit>
        <trans-unit id="c66144bb0d8421e5d08ae6900d1c0163e2522d70" translate="yes" xml:space="preserve">
          <source>Sample: Dynamic Module Loading in require.js</source>
          <target state="translated">サンプル。require.jsでの動的モジュールロード</target>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="translated">Schema</target>
        </trans-unit>
        <trans-unit id="1e96c4caea76817edca1b37676caff140bf67580" translate="yes" xml:space="preserve">
          <source>Schema can be found at: &lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;http://json.schemastore.org/tsconfig&lt;/a&gt;</source>
          <target state="translated">スキーマは、 &lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;http&lt;/a&gt; ： //json.schemastore.org/tsconfigにあります。</target>
        </trans-unit>
        <trans-unit id="e0b92d418e654bbd5c2c48b78244ecce9fb91d09" translate="yes" xml:space="preserve">
          <source>Scoping rules</source>
          <target state="translated">スコーピングルール</target>
        </trans-unit>
        <trans-unit id="aa7841d9d246c3e95a5b8f479b5b2166bbcd3d3d" translate="yes" xml:space="preserve">
          <source>Search for &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; を検索します</target>
        </trans-unit>
        <trans-unit id="120e80cbcdda984e634ee6ea60b988e7bdcd424d" translate="yes" xml:space="preserve">
          <source>Search for &lt;strong&gt;.NET Core&lt;/strong&gt; in the project search bar</source>
          <target state="translated">プロジェクト検索バーで&lt;strong&gt;.NET Core&lt;/strong&gt;を検索します</target>
        </trans-unit>
        <trans-unit id="98cc363c0119e35d1c8070755fc4d4c2387aad71" translate="yes" xml:space="preserve">
          <source>Searching</source>
          <target state="translated">Searching</target>
        </trans-unit>
        <trans-unit id="f28a160d3aeb79cc4e72b1bcf1f1cea3eed98229" translate="yes" xml:space="preserve">
          <source>Second, compile your files using &lt;code&gt;--importHelpers&lt;/code&gt;:</source>
          <target state="translated">次に、-- &lt;code&gt;--importHelpers&lt;/code&gt; を使用してファイルをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="f8a01008852da0be0cb83fb18c9ca0f90e85ba52" translate="yes" xml:space="preserve">
          <source>Second, the Typescript compiler doesn&amp;rsquo;t allow spreads of type parameters from generic functions. That feature is expected in future versions of the language.</source>
          <target state="translated">第二に、Typescriptコンパイラはジェネリック関数からの型パラメーターの拡散を許可しません。 その機能は、言語の将来のバージョンで期待されています。</target>
        </trans-unit>
        <trans-unit id="f5628af6cbb5e50d058efc6cdab3cec58a0d83b9" translate="yes" xml:space="preserve">
          <source>Secondly, using class fields to specialize properties from base classes also won&amp;rsquo;t work.</source>
          <target state="translated">次に、クラスフィールドを使用して基本クラスのプロパティを特殊化することもできません。</target>
        </trans-unit>
        <trans-unit id="7ff5a6dafd806f6d95302657c480d07703b64604" translate="yes" xml:space="preserve">
          <source>Sections</source>
          <target state="translated">Sections</target>
        </trans-unit>
        <trans-unit id="834c69b9d98efc1c3cec6d026570d3df634c7666" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../project-references&quot;&gt;Project References handbook page&lt;/a&gt; for more documentation.</source>
          <target state="translated">その他のドキュメントについては、 &lt;a href=&quot;../project-references&quot;&gt;プロジェクトリファレンスハンドブックページ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="187875e55767d20df483d2fe4602ec06611fda25" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/module-resolution.html&quot;&gt;Module Resolution&lt;/a&gt; documentation for more details.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/module-resolution.html&quot;&gt;モジュール解決の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="62fc6fcffeeb4b12902ccd59524362dbcce28787" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1256&quot;&gt;issue #1256&lt;/a&gt; for more information.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1256&quot;&gt;問題＃1256&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4c1f9292006cbb6b615fc48854ee208dde437f57" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files&quot;&gt;Type checking JavaScript Files documentation&lt;/a&gt; for more details.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files&quot;&gt;JavaScriptファイルのドキュメントの型チェック&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="fc473e27d9a7d29475aee306accd60b759bc0b30" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;more details on ts-loader here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ts-loaderの詳細については、こちらをご覧ください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="b638ae7ad48e00c44c5cd48eb83e81ecbbf0a3c9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.json&lt;/a&gt; documentation for more details.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.jsonの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="73a908746ad2d70ca1399fea9bcf57e61da44b2f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/tsconfig.json&quot;&gt;tsconfig.json wiki page&lt;/a&gt; for more details.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/tsconfig.json&quot;&gt;tsconfig.json wikiページ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="077567d6271296de8ad4bd173bc8a26e4ff5d0f2" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; documentation for more information about modules. See the &lt;a href=&quot;namespaces&quot;&gt;Namespaces&lt;/a&gt; documentation for more information about namespaces.</source>
          <target state="translated">&lt;a href=&quot;modules&quot;&gt;モジュールの&lt;/a&gt;詳細については、 モジュールのドキュメントを参照してください。 ネームスペースの詳細については、ネームスペースのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="64f2c787a02cbb7afa18cb007db73ea2664f916b" translate="yes" xml:space="preserve">
          <source>See the [[JSX]] wiki page for more information on using JSX in TypeScript.</source>
          <target state="translated">TypeScriptでのJSXの使用方法については、[[JSX]]wikiページを参照してください。</target>
        </trans-unit>
        <trans-unit id="cba80f4302feeb955dc9a7f866e6030dfdf9aef8" translate="yes" xml:space="preserve">
          <source>Select &lt;strong&gt;ASP.NET Core Web Application&lt;/strong&gt; and press the &lt;em&gt;Next&lt;/em&gt; button</source>
          <target state="translated">&lt;strong&gt;ASP.NET Core Webアプリケーション&lt;/strong&gt;を選択し、[ &lt;em&gt;次へ&lt;/em&gt; ]ボタンを押します</target>
        </trans-unit>
        <trans-unit id="ed8feffbb3830d15b62b683a32f847857e90712a" translate="yes" xml:space="preserve">
          <source>Semicolon Formatter Option</source>
          <target state="translated">セミコロンフォーマッターオプション</target>
        </trans-unit>
        <trans-unit id="0f34f77f18943b88ab52ee5b7292da7cf41c6f44" translate="yes" xml:space="preserve">
          <source>Semicolon-Aware Code Edits</source>
          <target state="translated">セミコロンを意識したコード編集</target>
        </trans-unit>
        <trans-unit id="bcd9a6570954b6e91fefb181f3610d2793b5661b" translate="yes" xml:space="preserve">
          <source>Sequentially Added Properties</source>
          <target state="translated">順次追加されるプロパティ</target>
        </trans-unit>
        <trans-unit id="7f05ebe6c7a2fc5869cacffec6b784fde7b8f889" translate="yes" xml:space="preserve">
          <source>Set up the build</source>
          <target state="translated">ビルドの設定</target>
        </trans-unit>
        <trans-unit id="40f24e0504d1b14397453f62baee68453ad2fba2" translate="yes" xml:space="preserve">
          <source>Set up the server</source>
          <target state="translated">サーバーの設定</target>
        </trans-unit>
        <trans-unit id="c4f87dbe5e7d0d324c8530cef57ba653425df0e3" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;baseUrl&lt;/code&gt; informs the compiler where to find modules. All module imports with non-relative names are assumed to be relative to the &lt;code&gt;baseUrl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;baseUrl&lt;/code&gt; を設定すると、コンパイラにモジュールの検索場所が通知されます。 相対名ではないすべてのモジュールのインポートは、 &lt;code&gt;baseUrl&lt;/code&gt; に関連すると見なされます。</target>
        </trans-unit>
        <trans-unit id="51341becf9d4b848eec8afc734c39a0799738e80" translate="yes" xml:space="preserve">
          <source>Setting a top-level property &lt;code&gt;compileOnSave&lt;/code&gt; signals to the IDE to generate all files for a given tsconfig.json upon saving.</source>
          <target state="translated">最上位のプロパティ &lt;code&gt;compileOnSave&lt;/code&gt; を設定すると、保存時に特定のtsconfig.jsonのすべてのファイルを生成するようIDEに通知されます。</target>
        </trans-unit>
        <trans-unit id="53989c11f338fd824665321c75b617ecdf354fe7" translate="yes" xml:space="preserve">
          <source>Setting compiler options in &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuild projects&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuildプロジェクトでの&lt;/a&gt;コンパイラオプションの設定。</target>
        </trans-unit>
        <trans-unit id="90b8ab6e9c58f23f02ac47d035bce949bcd397b5" translate="yes" xml:space="preserve">
          <source>Setting compiler options in &lt;a href=&quot;tsconfig-json&quot;&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; files.</source>
          <target state="translated">&lt;a href=&quot;tsconfig-json&quot;&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; &lt;/a&gt;ファイルでコンパイラオプションを設定します。</target>
        </trans-unit>
        <trans-unit id="7a6795689bb9ea8c8cb6764f05c1f6f935ee04dc" translate="yes" xml:space="preserve">
          <source>Setting the new compiler flag &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; indicates that the module loader performs some kind of synthetic default import member creation not indicated in the imported .ts or .d.ts. The compiler will infer the existence of a &lt;code&gt;default&lt;/code&gt; export that has the shape of the entire module itself.</source>
          <target state="translated">新しいコンパイラフラグ &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; を設定すると、モジュールローダーが、インポートされた.tsまたは.d.tsに示されていないある種の合成デフォルトインポートメンバーの作成を実行することを示します。 コンパイラーは、モジュール全体の形をした &lt;code&gt;default&lt;/code&gt; エクスポートの存在を推測します 。</target>
        </trans-unit>
        <trans-unit id="2e71f746315f905d8f4bde8180b1dba0027a8422" translate="yes" xml:space="preserve">
          <source>Setting up your Directories</source>
          <target state="translated">ディレクトリの設定</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="ba3a6a9b6d048ac70a293087f03215c195461fd9" translate="yes" xml:space="preserve">
          <source>Shadowing should &lt;em&gt;usually&lt;/em&gt; be avoided in the interest of writing clearer code. While there are some scenarios where it may be fitting to take advantage of it, you should use your best judgement.</source>
          <target state="translated">シャドウイングは&lt;em&gt;通常&lt;/em&gt; 、より明確なコードを作成するために回避する必要があります。 それを利用するのにふさわしいかもしれないいくつかのシナリオがありますが、最善の判断を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="274d75123478b9323ff5c010c5717e0dad76caf9" translate="yes" xml:space="preserve">
          <source>Shorthand ambient module declarations</source>
          <target state="translated">省略可能なアンビエントモジュール宣言</target>
        </trans-unit>
        <trans-unit id="8f46f045bb2fdc1956a2f236cfedf0e1e227f9e8" translate="yes" xml:space="preserve">
          <source>Shorthand ambient modules</source>
          <target state="translated">短縮型アンビエントモジュール</target>
        </trans-unit>
        <trans-unit id="d63965efaf94e11d119af70827afc578c1c99dd9" translate="yes" xml:space="preserve">
          <source>Show diagnostic information.</source>
          <target state="translated">診断情報を表示します。</target>
        </trans-unit>
        <trans-unit id="ea62715d57491630afc7339cce6c9e3316b090c6" translate="yes" xml:space="preserve">
          <source>Show verbose diagnostic information</source>
          <target state="translated">冗長な診断情報を表示</target>
        </trans-unit>
        <trans-unit id="cd0e108f1f4412f32e9c055f41ef6dfdceb42a42" translate="yes" xml:space="preserve">
          <source>Similar to a &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive, which serves as a declaration of &lt;em&gt;dependency&lt;/em&gt;, a &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive declares a dependency on a package.</source>
          <target state="translated">&lt;em&gt;依存関係の&lt;/em&gt;宣言として機能する &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; ディレクティブと同様に、 /// &amp;lt;reference &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; ディレクティブはパッケージへの依存関係を宣言します。</target>
        </trans-unit>
        <trans-unit id="7ee4acd9eb753cecdb4b91f99daa97963b128504" translate="yes" xml:space="preserve">
          <source>Similar to array spread, spreading an object can be handy to get a shallow copy:</source>
          <target state="translated">配列のスプレッドと同様に、オブジェクトのスプレッドは浅いコピーを取得するのに便利です。</target>
        </trans-unit>
        <trans-unit id="d647d33af76ba25c85ee64e3adf6ff361ad569ea" translate="yes" xml:space="preserve">
          <source>Similar to union and intersection types, conditional types are not permitted to reference themselves recursively. For example the following is an error.</source>
          <target state="translated">ユニオン型やインターセクション型と同様に、条件付き型も再帰的に自分自身を参照することは許されていません。例えば、次のようなエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="ea6e185bb85cecc9661d326572fea7b76b1b1495" translate="yes" xml:space="preserve">
          <source>Similarly a default import (i.e. &lt;code&gt;import d from &quot;foo&quot;&lt;/code&gt;) for a CommonJS/AMD/UMD module as equivalent to &lt;code&gt;const d = require(&quot;foo&quot;).default&lt;/code&gt;.Most of the CommonJS/AMD/UMD modules available today do not have a &lt;code&gt;default&lt;/code&gt; export, making this import pattern practically unusable to import non-ES modules (i.e. CommonJS/AMD/UMD). For instance &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; or &lt;code&gt;import express from &quot;express&quot;&lt;/code&gt; are not allowed.</source>
          <target state="translated">同様に、 &lt;code&gt;const d = require(&quot;foo&quot;).default&lt;/code&gt; 同等のCommonJS / AMD / UMDモジュールのデフォルトインポート（つまり &lt;code&gt;import d from &quot;foo&quot;&lt;/code&gt; ）。現在利用可能なCommonJS / AMD / UMDモジュールのほとんどには &lt;code&gt;default&lt;/code&gt; エクスポート。このインポートパターンは、ES以外のモジュール（CommonJS / AMD / UMDなど）をインポートするのに実質的に使用できません。 たとえば &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; &lt;code&gt;import express from &quot;express&quot;&lt;/code&gt; たり、「express」からexpressをインポートしたりすることはできません。</target>
        </trans-unit>
        <trans-unit id="d85b3b71be4bb5105a2a383a357dfdd56066b345" translate="yes" xml:space="preserve">
          <source>Similarly to how we can use interfaces to describe function types, we can also describe types that we can &amp;ldquo;index into&amp;rdquo; like &lt;code&gt;a[10]&lt;/code&gt;, or &lt;code&gt;ageMap[&quot;daniel&quot;]&lt;/code&gt;. Indexable types have an &lt;em&gt;index signature&lt;/em&gt; that describes the types we can use to index into the object, along with the corresponding return types when indexing. Let&amp;rsquo;s take an example:</source>
          <target state="translated">インターフェイスを使用して関数型を記述する方法と同様に &lt;code&gt;a[10]&lt;/code&gt; や &lt;code&gt;ageMap[&quot;daniel&quot;]&lt;/code&gt; ように「インデックスを付ける 」ことができる型を記述することもできます。 インデックス付け可能な型には、オブジェクトにインデックスを付けるために使用できる型を記述する&lt;em&gt;インデックスシグネチャ&lt;/em&gt;があり、 &lt;em&gt;インデックス&lt;/em&gt;を作成するときに対応する戻り値の型があります。 例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="adb395172c71ccd54b1326d899f4d06456ede0c1" translate="yes" xml:space="preserve">
          <source>Similarly to interfaces, namespaces of the same name will also merge their members. Since namespaces create both a namespace and a value, we need to understand how both merge.</source>
          <target state="translated">インタフェースと同様に、同じ名前の名前空間もメンバをマージします。名前空間は名前空間と値の両方を作成するので、両方がどのようにマージされるかを理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="59a8554ef56814f4114354c3cfa0c5ed809a9eaa" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;--target ES2017&lt;/code&gt; will instruct the compiler not to transform ES2017-specific features like &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">同様に、-- &lt;code&gt;--target ES2017&lt;/code&gt; は、 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; などのES2017固有の機能を変換しないようコンパイラーに指示します。</target>
        </trans-unit>
        <trans-unit id="ebb6eff56def1e9c8faa2f831e045e194b4e3480" translate="yes" xml:space="preserve">
          <source>Similarly, a non-relative import will follow the Node.js resolution logic, first looking up a file, then looking up an applicable folder. So &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; in source file &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; would result in the following lookups:</source>
          <target state="translated">同様に、非相対インポートはNode.js解決ロジックに従い、最初にファイルを検索し、次に適切なフォルダーを検索します。 したがって、ソースファイル &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; の &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; すると、次の検索が行われます。</target>
        </trans-unit>
        <trans-unit id="8e9295d32c7a26ac7fc56081bcf2d7aa9d700307" translate="yes" xml:space="preserve">
          <source>Similarly, destructuring can be used in function parameter declarations:</source>
          <target state="translated">同様に、関数のパラメータ宣言でもデストラクチャリングを使用することができます。</target>
        </trans-unit>
        <trans-unit id="034cda522b7de683abd945b4a3cdbb3d70d9b104" translate="yes" xml:space="preserve">
          <source>Similarly, namespaces can be used to extend enums with static members:</source>
          <target state="translated">同様に、名前空間を使用して、静的メンバを持つ列挙型を拡張することができます。</target>
        </trans-unit>
        <trans-unit id="15a650d9a4ea0756304f469dcbad9a5ff7886ae3" translate="yes" xml:space="preserve">
          <source>Similarly, the global scope can be augmented from modules using a &lt;code&gt;declare global&lt;/code&gt; declarations:</source>
          <target state="translated">同様に、グローバルスコープは、 &lt;code&gt;declare global&lt;/code&gt; 宣言の宣言を使用してモジュールから拡張できます。</target>
        </trans-unit>
        <trans-unit id="44c459aed9d0d7b781bc8721c975f3ccca45175e" translate="yes" xml:space="preserve">
          <source>Similarly, try removing all the arguments to the greeter call. TypeScript will let you know that you have called this function with an unexpected number of parameters. In both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations you provide.</source>
          <target state="translated">同様に、グリーターの呼び出しの引数をすべて削除してみてください。TypeScript は、予期せぬ数のパラメータを使ってこの関数を呼び出したことを知らせてくれます。どちらの場合も、TypeScript はコードの構造と提供された型のアノテーションの両方に基づいて静的な解析を行うことができます。</target>
        </trans-unit>
        <trans-unit id="a96df9471d886c6a3944738c14a4e817cb32e52e" translate="yes" xml:space="preserve">
          <source>Similarly, you can merge several different objects. In the following example, &lt;code&gt;merged&lt;/code&gt; will have properties from &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt;.</source>
          <target state="translated">同様に、いくつかの異なるオブジェクトをマージできます。 次の例では、 &lt;code&gt;merged&lt;/code&gt; には &lt;code&gt;foo&lt;/code&gt; 、 &lt;code&gt;bar&lt;/code&gt; 、および &lt;code&gt;baz&lt;/code&gt; のプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="0e344fea73da74bac69381f07e6bac9722af29f9" translate="yes" xml:space="preserve">
          <source>Similarly, you could write a utility type like &lt;code&gt;Writable&lt;/code&gt; mapped type that strips away &lt;code&gt;readonly&lt;/code&gt;-ness, and that would convert &lt;code&gt;readonly&lt;/code&gt; array containers back to their mutable equivalents.</source>
          <target state="translated">同様に、 &lt;code&gt;readonly&lt;/code&gt; -nessを取り除き、 読み取り &lt;code&gt;readonly&lt;/code&gt; 配列コンテナーを同等の可変に戻す &lt;code&gt;Writable&lt;/code&gt; マップタイプなどのユーティリティタイプを作成できます 。</target>
        </trans-unit>
        <trans-unit id="8aacbc2fc90c4a9233935fa887158e588886b733" translate="yes" xml:space="preserve">
          <source>Simple Combinations: One name, multiple meanings</source>
          <target state="translated">シンプルな組み合わせ。一つの名前に複数の意味</target>
        </trans-unit>
        <trans-unit id="c15fa4b758d35cc97d9959bcc45edd294156d605" translate="yes" xml:space="preserve">
          <source>Simple Example</source>
          <target state="translated">簡単な例</target>
        </trans-unit>
        <trans-unit id="1c315460161fd9403852d4c74317febae46bf2d2" translate="yes" xml:space="preserve">
          <source>SimpleModule.ts</source>
          <target state="translated">SimpleModule.ts</target>
        </trans-unit>
        <trans-unit id="b2ce6f775436f49655c281cba1ff8bd7971a0459" translate="yes" xml:space="preserve">
          <source>Simplified &lt;code&gt;props&lt;/code&gt; type management in React</source>
          <target state="translated">Reactでの &lt;code&gt;props&lt;/code&gt; タイプ管理の簡素化</target>
        </trans-unit>
        <trans-unit id="e0d662efaa9ae2f635437fd38e1b30b750f5eb5c" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;keyof&lt;/code&gt; now reflects the presence of a numeric index signature by including type &lt;code&gt;number&lt;/code&gt; in the key type, mapped types such as &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; work correctly when applied to object types with numeric index signatures:</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; はキータイプにタイプ &lt;code&gt;number&lt;/code&gt; を含めることで数値インデックスシグニチャの存在を反映するようになったため、 &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; や &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; などのマップタイプは、数値インデックスシグニチャを持つオブジェクトタイプに適用すると正しく機能します。</target>
        </trans-unit>
        <trans-unit id="3d0a96b99fe271899593be449688b7fa5ea47eef" translate="yes" xml:space="preserve">
          <source>Since JavaScript automatically terminates the &lt;code&gt;return&lt;/code&gt; statement at the end of the line, the object literal becomes a block.</source>
          <target state="translated">JavaScriptは行末で &lt;code&gt;return&lt;/code&gt; ステートメントを自動的に終了するため、オブジェクトリテラルはブロックになります。</target>
        </trans-unit>
        <trans-unit id="cce35890852819c246c89e64575a83cc751e8c48" translate="yes" xml:space="preserve">
          <source>Since declarations in one file can affect type checking in other files, some errors may not be detected when &lt;code&gt;--skipLibCheck&lt;/code&gt; is specified. For example, if a non-declaration file augments a type declared in a declaration file, errors may result that are only reported when the declaration file is checked. However, in practice such situations are rare.</source>
          <target state="translated">1つのファイルの宣言は他のファイルの型チェックに影響を与える可能性があるため、 &lt;code&gt;--skipLibCheck&lt;/code&gt; が指定されている場合、一部のエラーが検出されないことがあります。 たとえば、非宣言ファイルが宣言ファイルで宣言された型を補強する場合、宣言ファイルがチェックされたときにのみ報告されるエラーが発生する場合があります。 ただし、実際にはそのような状況はまれです。</target>
        </trans-unit>
        <trans-unit id="91fd691cb7cba41ab5d488469fc7cd906ef14a39" translate="yes" xml:space="preserve">
          <source>Since nullable types are implemented with a union, you need to use a type guard to get rid of the &lt;code&gt;null&lt;/code&gt;. Fortunately, this is the same code you&amp;rsquo;d write in JavaScript:</source>
          <target state="translated">null許容型は共用体で実装されているため、型ガードを使用して &lt;code&gt;null&lt;/code&gt; を取り除く必要があります 。 幸いなことに、これはJavaScriptで記述するコードと同じです。</target>
        </trans-unit>
        <trans-unit id="d7d710dcc7a9a1a3a0ae270f066743ad193628a1" translate="yes" xml:space="preserve">
          <source>Since ranges have the potential to overlap, determining which redirect applies is order-specific. That means in the above example, even though both the &lt;code&gt;&amp;gt;=3.2&lt;/code&gt; and the &lt;code&gt;&amp;gt;=3.1&lt;/code&gt; matchers support TypeScript 3.2 and above, reversing the order could have different behavior, so the above sample would not be equivalent to the following.</source>
          <target state="translated">範囲は重複する可能性があるため、適用されるリダイレクトの決定は順序に固有です。 つまり、上記の例では、 &lt;code&gt;&amp;gt;=3.2&lt;/code&gt; マッチャーと &lt;code&gt;&amp;gt;=3.1&lt;/code&gt; マッチャーの両方がTypeScript 3.2以上をサポートしているにもかかわらず、順序を逆にすると異なる動作が発生する可能性があるため、上記のサンプルは次のサンプルと同等ではありません。</target>
        </trans-unit>
        <trans-unit id="4f878058a9de82078d9e40fb2687f87811aefbf7" translate="yes" xml:space="preserve">
          <source>Since the above syntax cannot be used in &lt;code&gt;.tsx&lt;/code&gt; files, an alternate type assertion operator should be used: &lt;code&gt;as&lt;/code&gt;. The example can easily be rewritten with the &lt;code&gt;as&lt;/code&gt; operator.</source>
          <target state="translated">上記の構文は &lt;code&gt;.tsx&lt;/code&gt; ファイルでは使用できないため、代替タイプアサーション演算子を使用する必要があります： &lt;code&gt;as&lt;/code&gt; 。 この例は、 &lt;code&gt;as&lt;/code&gt; 演算子を使用して簡単に書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="c94167207ee9c90316742f73b6eca79827716dff" translate="yes" xml:space="preserve">
          <source>Since the class uses &lt;code&gt;this&lt;/code&gt; types, you can extend it and the new class can use the old methods with no changes.</source>
          <target state="translated">クラスは &lt;code&gt;this&lt;/code&gt; 型を使用するため、拡張することができ、新しいクラスは変更せずに古いメソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="3f878409b3dc13d4ef49d4cf4543cf7848bae266" translate="yes" xml:space="preserve">
          <source>Since the stricter checks may uncover previously unreported errors, this is a breaking change in &lt;code&gt;--strict&lt;/code&gt; mode.</source>
          <target state="translated">より厳密なチェックは以前に報告されていないエラーを発見する可能性があるため、これは &lt;code&gt;--strict&lt;/code&gt; モードでの重大な変更です。</target>
        </trans-unit>
        <trans-unit id="21d47d51fa3ee1bdfdfae971aec4e563a10a3e93" translate="yes" xml:space="preserve">
          <source>Since there is no natural syntax for specifying generic type parameters in Javascript, an unspecified type parameter defaults to &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Javascriptでジェネリック型パラメーターを指定するための自然な構文はないため、未指定の型パラメーターはデフォルトで &lt;code&gt;any&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="b322b635e697fa374578b14cb6639ca067a1c956" translate="yes" xml:space="preserve">
          <source>Since there is no way to specify optionality on parameters in pre-ES2015 Javascript, all function parameters in &lt;code&gt;.js&lt;/code&gt; file are considered optional. Calls with fewer arguments than the declared number of parameters are allowed.</source>
          <target state="translated">ES2015以前のJavaScriptのパラメーターにオプションを指定する方法はないため、 &lt;code&gt;.js&lt;/code&gt; ファイルのすべての関数パラメーターはオプションと見なされます。 宣言されたパラメーターの数よりも少ない引数での呼び出しが許可されます。</target>
        </trans-unit>
        <trans-unit id="1bb189160ac70073ac7ebfc075b0fbe0a1f9844a" translate="yes" xml:space="preserve">
          <source>Since this is a breaking change, you may need to know about the workarounds which are the same as those for strict object literal checks:</source>
          <target state="translated">これはブレークする変更なので、厳密なオブジェクトリテラルチェックと同じ回避策を知っておく必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="0c990fd202f278ef0f0d7845a5a9243bf4d29dd3" translate="yes" xml:space="preserve">
          <source>Skip type checking of &lt;a href=&quot;triple-slash-directives#-reference-no-default-libtrue&quot;&gt;default library declaration files&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;triple-slash-directives#-reference-no-default-libtrue&quot;&gt;デフォルトのライブラリ宣言ファイルの&lt;/a&gt;型チェックをスキップします 。</target>
        </trans-unit>
        <trans-unit id="12501fd6f728bd1473ea7478cbc5c3dcd63db265" translate="yes" xml:space="preserve">
          <source>Skip type checking of all declaration files (&lt;code&gt;*.d.ts&lt;/code&gt;).</source>
          <target state="translated">すべての宣言ファイル（ &lt;code&gt;*.d.ts&lt;/code&gt; ）の型チェックをスキップします。</target>
        </trans-unit>
        <trans-unit id="65491f46fdafeaf0b665cd04a110e111c9391e5e" translate="yes" xml:space="preserve">
          <source>Smarter Auto-Import Syntax</source>
          <target state="translated">よりスマートな自動インポート構文</target>
        </trans-unit>
        <trans-unit id="bb1eae075750d4a174787dc1c2252c01719c35af" translate="yes" xml:space="preserve">
          <source>Smarter union type checking</source>
          <target state="translated">よりスマートなユニオンタイプのチェック</target>
        </trans-unit>
        <trans-unit id="679bf06653c38306e3510cb4091b394d4e625ab8" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve used &amp;ldquo;compatible&amp;rdquo;, which is not a term defined in the language spec. In TypeScript, there are two kinds of compatibility: subtype and assignment. These differ only in that assignment extends subtype compatibility with rules to allow assignment to and from &lt;code&gt;any&lt;/code&gt;, and to and from &lt;code&gt;enum&lt;/code&gt; with corresponding numeric values.</source>
          <target state="translated">これまでのところ、言語仕様で定義されている用語ではない「互換」を使用しました。 TypeScriptには、サブタイプと割り当てという2種類の互換性があります。 これらは、割り当てがルールとサブタイプの互換性を拡張し、 &lt;code&gt;any&lt;/code&gt; 、および &lt;code&gt;enum&lt;/code&gt; から、およびそれに対応する数値を持つenumへの割り当てを許可するという点でのみ異なります。</target>
        </trans-unit>
        <trans-unit id="67ef5716ef1d4255fdfc3266bf74a100eaaddc5f" translate="yes" xml:space="preserve">
          <source>So given the following input, the resulting &lt;code&gt;.js&lt;/code&gt; file will include an import to &lt;code&gt;tslib&lt;/code&gt; and use the &lt;code&gt;__assign&lt;/code&gt; helper from it instead of inlining it.</source>
          <target state="translated">したがって、次の入力が与えられると、結果の &lt;code&gt;.js&lt;/code&gt; ファイルには &lt;code&gt;tslib&lt;/code&gt; へのインポートが含まれ、インライン化する代わりに &lt;code&gt;__assign&lt;/code&gt; ヘルパーが使用されます。</target>
        </trans-unit>
        <trans-unit id="186ee8ceb588d6a258ee6dbb023a30a68c051a54" translate="yes" xml:space="preserve">
          <source>So in the above example, if we&amp;rsquo;re importing from &lt;code&gt;&quot;package-name&quot;&lt;/code&gt;, we&amp;rsquo;ll try to resolve from &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; (and other relevant paths) when running in TypeScript 3.1. If we import from &lt;code&gt;package-name/foo&lt;/code&gt;, we&amp;rsquo;ll try to look for &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; and &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt;.</source>
          <target state="translated">したがって、上記の例では、 &lt;code&gt;&quot;package-name&quot;&lt;/code&gt; からインポートする場合、 &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; （およびその他の関連するもの）から解決しようとします。パス）TypeScript 3.1で実行する場合。 &lt;code&gt;package-name/foo&lt;/code&gt; からインポートする場合、 &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; および &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt; を検索しようとします/ts3.1/foo/index.d.ts</target>
        </trans-unit>
        <trans-unit id="e0d35f3444ee195674f39dbd3f6a1e50ed4c2a4e" translate="yes" xml:space="preserve">
          <source>So to exclude a file from the compilation, you need to exclude it and &lt;strong&gt;all&lt;/strong&gt; files that have an &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive to it.</source>
          <target state="translated">したがって、コンパイルからファイルを除外するには、 &lt;strong&gt;その&lt;/strong&gt;ファイルと、 &lt;code&gt;import&lt;/code&gt; または &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; ディレクティブを持つ&lt;strong&gt;すべての&lt;/strong&gt;ファイルを除外する必要があります。</target>
        </trans-unit>
        <trans-unit id="e4bc2f7646ea9a289aefdb5e74620f8df8809b70" translate="yes" xml:space="preserve">
          <source>Some examples of functions returning &lt;code&gt;never&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; を返す関数の例：</target>
        </trans-unit>
        <trans-unit id="dd8e2e31e759369daed94a0bdfbe83bde2d68c4a" translate="yes" xml:space="preserve">
          <source>Some examples of use of functions returning &lt;code&gt;never&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; を返す関数の使用例：</target>
        </trans-unit>
        <trans-unit id="ac3ff6970ef7ae26b60be3c11566e4ffed69c47e" translate="yes" xml:space="preserve">
          <source>Some examples use the &lt;code&gt;reflect-metadata&lt;/code&gt; library which adds a polyfill for an &lt;a href=&quot;https://github.com/rbuckton/ReflectDecorators&quot;&gt;experimental metadata API&lt;/a&gt;. This library is not yet part of the ECMAScript (JavaScript) standard. However, once decorators are officially adopted as part of the ECMAScript standard these extensions will be proposed for adoption.</source>
          <target state="translated">いくつかの例では、 &lt;a href=&quot;https://github.com/rbuckton/ReflectDecorators&quot;&gt;実験メタデータAPIの&lt;/a&gt;ポリフィルを追加する &lt;code&gt;reflect-metadata&lt;/code&gt; ライブラリを使用してい ます 。 このライブラリはまだECMAScript（JavaScript）標準の一部ではありません。 ただし、ECMAScript標準の一部としてデコレータが公式に採用されると、これらの拡張機能の採用が提案されます。</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">いくつかの例を紹介します。</target>
        </trans-unit>
        <trans-unit id="7d3c07f60789aec8bf6b6718acaa48138f0167f9" translate="yes" xml:space="preserve">
          <source>Some kinds of declarations can be combined across multiple declarations. For example, &lt;code&gt;class C { }&lt;/code&gt; and &lt;code&gt;interface C { }&lt;/code&gt; can co-exist and both contribute properties to the &lt;code&gt;C&lt;/code&gt; types.</source>
          <target state="translated">いくつかの種類の宣言は、複数の宣言にわたって組み合わせることができます。 たとえば、 &lt;code&gt;class C { }&lt;/code&gt; と &lt;code&gt;interface C { }&lt;/code&gt; は共存でき、両方が &lt;code&gt;C&lt;/code&gt; 型にプロパティを提供します。</target>
        </trans-unit>
        <trans-unit id="7a1a6bb7e5995629cd2728c008f6bd029c77d013" translate="yes" xml:space="preserve">
          <source>Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; modules. These libraries can be accessed through either an import or a global variable. For example:</source>
          <target state="translated">一部のライブラリは、多くのモジュールローダーで使用するように設計されているか、モジュールをロードしない（グローバル変数）ように設計されています。 これらは&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;モジュールと呼ばれます。 これらのライブラリには、インポートまたはグローバル変数のいずれかを使用してアクセスできます。 例えば：</target>
        </trans-unit>
        <trans-unit id="2bd424c5780b5812c140ab0c2b98f3a8f43528b7" translate="yes" xml:space="preserve">
          <source>Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; or &lt;a href=&quot;http://isomorphic.net&quot;&gt;Isomorphic&lt;/a&gt; modules. These libraries can be accessed through either an import or a global variable.</source>
          <target state="translated">一部のライブラリは、多くのモジュールローダーで使用するように設計されているか、モジュールをロードしない（グローバル変数）ように設計されています。 これらは&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;または&lt;a href=&quot;http://isomorphic.net&quot;&gt;同形&lt;/a&gt;モジュールとして知られています。 これらのライブラリには、インポートまたはグローバル変数のいずれかを使用してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="6d579c1b603ba9bdb7b036601db29274335578ec" translate="yes" xml:space="preserve">
          <source>Some libraries only work in a module loader environment. For example, &lt;code&gt;express&lt;/code&gt; only works in Node.js and must be loaded using the CommonJS &lt;code&gt;require&lt;/code&gt; function.</source>
          <target state="translated">一部のライブラリは、モジュールローダー環境でのみ機能します。 たとえば、 &lt;code&gt;express&lt;/code&gt; はNode.jsでのみ機能し、CommonJS &lt;code&gt;require&lt;/code&gt; 関数を使用してロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="6e9585e6951e2664b628f35bed4a5c31cb046a11" translate="yes" xml:space="preserve">
          <source>Some module loaders such as &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt; and &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt; allow non-JavaScript content to be imported. These typically use a prefix or suffix to indicate the special loading semantics. Wildcard module declarations can be used to cover these cases.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt;や&lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt;などの一部のモジュールローダーでは、JavaScript以外のコンテンツをインポートできます。 これらは通常、接頭辞または接尾辞を使用して、特別な読み込みセマンティクスを示します。 これらのケースをカバーするために、ワイルドカードモジュール宣言を使用できます。</target>
        </trans-unit>
        <trans-unit id="57331e67e5143af4a00330fcd39cdc3c6aaaac4d" translate="yes" xml:space="preserve">
          <source>Some of the unique concepts in TypeScript describe the shape of JavaScript objects at the type level. One example that is especially unique to TypeScript is the concept of &amp;lsquo;declaration merging&amp;rsquo;. Understanding this concept will give you an advantage when working with existing JavaScript. It also opens the door to more advanced abstraction concepts.</source>
          <target state="translated">TypeScriptのユニークな概念のいくつかは、JavaScriptオブジェクトの形状をタイプレベルで記述しています。 TypeScriptに特にユニークな例の1つは、「宣言のマージ」の概念です。 この概念を理解すると、既存のJavaScriptを使用する際に利点が得られます。 また、より高度な抽象概念への扉を開きます。</target>
        </trans-unit>
        <trans-unit id="1e812a000ccfcbfb77656cc54a6fedc23b3ae782" translate="yes" xml:space="preserve">
          <source>Some people find it more aesthetically pleasing to create an object and add properties immediately after like so:</source>
          <target state="translated">このように、オブジェクトを作成してすぐにプロパティを追加した方が、より審美性が高いと感じる人もいます。</target>
        </trans-unit>
        <trans-unit id="61d584a25fe1d72715546564a21bd344b92d47a9" translate="yes" xml:space="preserve">
          <source>Some plugins add or modify top-level exports on existing modules. While this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible. Because TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this.</source>
          <target state="translated">一部のプラグインでは、既存のモジュールにトップレベルのエクスポートを追加したり、変更したりしています。これは CommonJS や他のローダーでは合法ですが、ES6 モジュールは不変とみなされており、このパターンは不可能です。TypeScript はローダに依存しないため、コンパイル時にこのポリシーが適用されることはありませんが、ES6 モジュールローダに移行しようとしている開発者は、この点に注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="f160ec637dc65ea96bb1d06f7025c1b36e3fe866" translate="yes" xml:space="preserve">
          <source>Some properties should only be modifiable when an object is first created. You can specify this by putting &lt;code&gt;readonly&lt;/code&gt; before the name of the property:</source>
          <target state="translated">一部のプロパティは、オブジェクトが最初に作成されたときにのみ変更可能にする必要があります。 プロパティの名前の前に &lt;code&gt;readonly&lt;/code&gt; を置くことでこれを指定できます：</target>
        </trans-unit>
        <trans-unit id="14f44373480b1e220dbd6f17d34a63ec1dd688dd" translate="yes" xml:space="preserve">
          <source>Some readers might do a double-take at this example. The variable &lt;code&gt;x&lt;/code&gt; was declared &lt;em&gt;within the &lt;code&gt;if&lt;/code&gt; block&lt;/em&gt;, and yet we were able to access it from outside that block. That&amp;rsquo;s because &lt;code&gt;var&lt;/code&gt; declarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we&amp;rsquo;ll go over later on - regardless of the containing block. Some people call this &lt;em&gt;&lt;code&gt;var&lt;/code&gt;-scoping&lt;/em&gt; or &lt;em&gt;function-scoping&lt;/em&gt;. Parameters are also function scoped.</source>
          <target state="translated">一部の読者は、この例でダブルテイクを行うかもしれません。 変数 &lt;code&gt;x&lt;/code&gt; は&lt;em&gt; &lt;code&gt;if&lt;/code&gt; ブロック内&lt;/em&gt;で宣言さ&lt;em&gt;れましたが、&lt;/em&gt;そのブロックの外部からアクセスできました。 それは、 &lt;code&gt;var&lt;/code&gt; 宣言は、包含ブロックに関係なく、包含関数、モジュール、名前空間、またはグローバルスコープ内のどこからでもアクセスできるためです。 これを&lt;em&gt; &lt;code&gt;var&lt;/code&gt; -scoping&lt;/em&gt;または&lt;em&gt;function-&lt;/em&gt; &lt;em&gt;scoping&lt;/em&gt;と呼ぶ人もい&lt;em&gt;ます&lt;/em&gt; 。 パラメータも関数スコープです。</target>
        </trans-unit>
        <trans-unit id="44fb74208e19d5dbb2c363c2964c86574d508b8b" translate="yes" xml:space="preserve">
          <source>Some teams have set up msbuild-based workflows wherein tsconfig files have the same &lt;em&gt;implicit&lt;/em&gt; graph ordering as the managed projects they are paired with. If your solution is like this, you can continue to use &lt;code&gt;msbuild&lt;/code&gt; with &lt;code&gt;tsc -p&lt;/code&gt; along with project references; these are fully interoperable.</source>
          <target state="translated">一部のチームは、msconfigベースのワークフローを設定しています。tsconfigファイルは、ペアになっている管理対象プロジェクトと同じ&lt;em&gt;暗黙的な&lt;/em&gt;グラフの順序を持​​っています。 ソリューションがこのような場合、プロジェクト参照と共に &lt;code&gt;tsc -p&lt;/code&gt; を使用して &lt;code&gt;msbuild&lt;/code&gt; を引き続き使用できます。 これらは完全に相互運用可能です。</target>
        </trans-unit>
        <trans-unit id="7941e42acfe32f9735cd477a7822e4200f3733d0" translate="yes" xml:space="preserve">
          <source>Something to note is that you can still &lt;em&gt;capture&lt;/em&gt; a block-scoped variable before it&amp;rsquo;s declared. The only catch is that it&amp;rsquo;s illegal to call that function before the declaration. If targeting ES2015, a modern runtime will throw an error; however, right now TypeScript is permissive and won&amp;rsquo;t report this as an error.</source>
          <target state="translated">注意すべき点は、宣言する前にブロックスコープの変数を&lt;em&gt;キャプチャ&lt;/em&gt;できることです。 唯一の問題は、宣言の前にその関数を呼び出すことは違法だということです。 ES2015を対象とする場合、最新のランタイムはエラーをスローします。 ただし、現在TypeScriptは許容範囲内であり、これをエラーとして報告しません。</target>
        </trans-unit>
        <trans-unit id="f134bb2233aae7cfa93968aca5ea244823125b9e" translate="yes" xml:space="preserve">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. For instance, an import to a module &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; would be translated at runtime to &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs documentation&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#paths&quot;&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target state="translated">モジュールが&lt;em&gt;baseUrlの&lt;/em&gt;下に直接配置されていない場合があります。 たとえば、モジュール &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; へのインポートは、実行時に &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt; 変換されます。 ローダーは、マッピング構成を使用して、実行時にモジュール名をファイルにマップします&lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;。RequireJsドキュメント&lt;/a&gt;と&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#paths&quot;&gt;SystemJSドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d6951e5cd812b979ec00d7377ad9486c476e4ffe" translate="yes" xml:space="preserve">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs documentation&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#map-config&quot;&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target state="translated">モジュールが&lt;em&gt;baseUrlの&lt;/em&gt;下に直接配置されていない場合があります。 ローダーは、マッピング構成を使用して、実行時にモジュール名をファイルにマップします&lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;。RequireJsドキュメント&lt;/a&gt;と&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#map-config&quot;&gt;SystemJSドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c2126d1615e0f1485e19b5a56e2155fedd9cc145" translate="yes" xml:space="preserve">
          <source>Sometimes the project sources from multiple directories at compile time are all combined to generate a single output directory. This can be viewed as a set of source directories create a &amp;ldquo;virtual&amp;rdquo; directory.</source>
          <target state="translated">コンパイル時に複数のディレクトリのプロジェクトソースがすべて結合されて、単一の出力ディレクトリが生成される場合があります。 これは、「仮想」ディレクトリを作成するソースディレクトリのセットとして表示できます。</target>
        </trans-unit>
        <trans-unit id="57ffb77d1046760098ea81054624979437671ba8" translate="yes" xml:space="preserve">
          <source>Sometimes this is not desirable, for instance inputs &lt;code&gt;FolderA\FolderB\1.ts&lt;/code&gt; and &lt;code&gt;FolderA\FolderB\2.ts&lt;/code&gt; would result in output structure mirroring &lt;code&gt;FolderA\FolderB\&lt;/code&gt;. Now if a new file &lt;code&gt;FolderA\3.ts&lt;/code&gt; is added to the input, the output structure will pop out to mirror &lt;code&gt;FolderA\&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;FolderA\FolderB\1.ts&lt;/code&gt; および &lt;code&gt;FolderA\FolderB\2.ts&lt;/code&gt; を入力すると、 FolderA \ FolderB \をミラーリングする出力構造になります。 新しいファイル &lt;code&gt;FolderA\3.ts&lt;/code&gt; が入力に追加された場合、出力構造がミラー &lt;code&gt;FolderA\&lt;/code&gt; ポップアウトされます。</target>
        </trans-unit>
        <trans-unit id="1373cee6ce1e5c912f9c7dad28055e7d5d1067f6" translate="yes" xml:space="preserve">
          <source>Sometimes you&amp;rsquo;ll end up in a situation where you&amp;rsquo;ll know more about a value than TypeScript does. Usually this will happen when you know the type of some entity could be more specific than its current type.</source>
          <target state="translated">場合によっては、TypeScriptよりも値について多くのことを知る状況になることがあります。 通常、これは、エンティティのタイプが現在のタイプよりも具体的であることがわかっている場合に発生します。</target>
        </trans-unit>
        <trans-unit id="55d18b2ee923c4bc6bb19412ab2b08a75f6ca271" translate="yes" xml:space="preserve">
          <source>Sometimes you&amp;rsquo;ll entirely overwrite the exports object. This is a common pattern people use to make their modules immediately callable like in this snippet:</source>
          <target state="translated">エクスポートオブジェクトを完全に上書きする場合があります。 これは、このスニペットのように、モジュールをすぐに呼び出し可能にするために使用する一般的なパターンです。</target>
        </trans-unit>
        <trans-unit id="d9ff7d39e693899b2fb01c2af7e0b9aad8efd43b" translate="yes" xml:space="preserve">
          <source>Specifically:</source>
          <target state="translated">Specifically:</target>
        </trans-unit>
        <trans-unit id="a641ebcd0020283fedd21072f7904f9b73d7b789" translate="yes" xml:space="preserve">
          <source>Specifies the location where debugger should locate TypeScript files instead of source locations. Use this flag if the sources will be located at run-time in a different location than that at design-time. The location specified will be embedded in the sourceMap to direct the debugger where the source files will be located.</source>
          <target state="translated">デバッガがソースの場所ではなく、TypeScript ファイルを配置する場所を指定します。実行時にデザイン時とは異なる場所にソースが配置される場合は、このフラグを使用します。指定された場所は sourceMap に埋め込まれ、デバッガにソースファイルが配置される場所を指示します。</target>
        </trans-unit>
        <trans-unit id="1c2da7a5fc698b5da97db9b13fe3154907aad09d" translate="yes" xml:space="preserve">
          <source>Specifies the location where debugger should locate map files instead of generated locations. Use this flag if the .map files will be located at run-time in a different location than the .js files. The location specified will be embedded in the sourceMap to direct the debugger where the map files will be located. This flag will not create the specified path and generate the map files in that location. Instead, create a post build step that moves the files to the specified path.</source>
          <target state="translated">デバッガーが生成された場所ではなく、マップファイルを配置する場所を指定します。.map ファイルが実行時に .js ファイルとは異なる場所に配置される場合は、このフラグを使用します。指定された場所は sourceMap に埋め込まれ、マップ ファイルが配置される場所をデバッガに指示します。このフラグは、指定されたパスを作成してその場所にマップファイルを生成することはありません。代わりに、指定したパスにファイルを移動させるポストビルドステップを作成します。</target>
        </trans-unit>
        <trans-unit id="794dd3dcf9665f5b582a96a912c3cb49b4c72f8a" translate="yes" xml:space="preserve">
          <source>Specifies the object invoked for &lt;code&gt;createElement&lt;/code&gt; and &lt;code&gt;__spread&lt;/code&gt; when targeting &lt;code&gt;&quot;react&quot;&lt;/code&gt; JSX emit.</source>
          <target state="translated">&lt;code&gt;&quot;react&quot;&lt;/code&gt; JSX放出をターゲットとするときに &lt;code&gt;createElement&lt;/code&gt; および &lt;code&gt;__spread&lt;/code&gt; に対して呼び出されるオブジェクトを指定します。</target>
        </trans-unit>
        <trans-unit id="87746b728ea4f460f7202426ccc6c557238e85b3" translate="yes" xml:space="preserve">
          <source>Specifies the root directory of input files. Only use to control the output directory structure with &lt;code&gt;--outDir&lt;/code&gt;.</source>
          <target state="translated">入力ファイルのルートディレクトリを指定します。 &lt;code&gt;--outDir&lt;/code&gt; で出力ディレクトリ構造を制御するためにのみ使用します。</target>
        </trans-unit>
        <trans-unit id="6f3b79249d834c08c2bb8f8527cca3825f4ecc15" translate="yes" xml:space="preserve">
          <source>Specify &lt;code&gt;&quot;types&quot;: []&lt;/code&gt; to disable automatic inclusion of &lt;code&gt;@types&lt;/code&gt; packages.</source>
          <target state="translated">&lt;code&gt;&quot;types&quot;: []&lt;/code&gt; を指定して、 &lt;code&gt;@types&lt;/code&gt; パッケージの自動組み込みを無効にします。</target>
        </trans-unit>
        <trans-unit id="04e339988f7084fdc3b9871407ec6d486b9796f2" translate="yes" xml:space="preserve">
          <source>Specify ECMAScript target version:</source>
          <target state="translated">ECMAScript のターゲットバージョンを指定します。</target>
        </trans-unit>
        <trans-unit id="22bae6477e590560d376f1ca2a920f0f7137f9ff" translate="yes" xml:space="preserve">
          <source>Specify module code generation: &lt;code&gt;&quot;None&quot;&lt;/code&gt;, &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt;, &lt;code&gt;&quot;AMD&quot;&lt;/code&gt;, &lt;code&gt;&quot;System&quot;&lt;/code&gt;, &lt;code&gt;&quot;UMD&quot;&lt;/code&gt;, &lt;code&gt;&quot;ES6&quot;&lt;/code&gt;, &lt;code&gt;&quot;ES2015&quot;&lt;/code&gt; or &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt;.</source>
          <target state="translated">モジュールコードの生成を指定します： &lt;code&gt;&quot;None&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;AMD&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;System&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;UMD&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;ES6&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;ES2015&quot;&lt;/code&gt; または &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f17fc5b5e06de09269af8bc9bf5322fe97b5fb06" translate="yes" xml:space="preserve">
          <source>Specify the JSX factory function to use when targeting react JSX emit, e.g. &lt;code&gt;React.createElement&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;React.createElement&lt;/code&gt; または &lt;code&gt;h&lt;/code&gt; など、react JSX放出をターゲットにするときに使用するJSXファクトリー関数を指定します。</target>
        </trans-unit>
        <trans-unit id="26252f00b41f16be2c212af5b97551e657c2f43c" translate="yes" xml:space="preserve">
          <source>Specify what file to store incremental build information in.</source>
          <target state="translated">インクリメンタルビルド情報を保存するファイルを指定します。</target>
        </trans-unit>
        <trans-unit id="5b0ffc462bd014144a57832b75b37bec6b627992" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;--outFile&lt;/code&gt; in conjunction with &lt;code&gt;--module amd&lt;/code&gt; or &lt;code&gt;--module system&lt;/code&gt; will concatenate all modules in the compilation into a single output file containing multiple module closures.</source>
          <target state="translated">&lt;code&gt;--module amd&lt;/code&gt; または &lt;code&gt;--module system&lt;/code&gt; と組み合わせて--outFileを指定すると、コンパイルのすべてのモジュールが複数のモジュールクロージャーを含む単一の出力ファイルに連結されます。</target>
        </trans-unit>
        <trans-unit id="ecac73aab16df45bc37442b177ade411f7d911ae" translate="yes" xml:space="preserve">
          <source>Specifying the type of &lt;code&gt;this&lt;/code&gt; for functions</source>
          <target state="translated">関数の &lt;code&gt;this&lt;/code&gt; タイプの指定</target>
        </trans-unit>
        <trans-unit id="076b62c1c3d09beab9691ee6f442faa2e62ef7a7" translate="yes" xml:space="preserve">
          <source>Speed improvements</source>
          <target state="translated">スピードの向上</target>
        </trans-unit>
        <trans-unit id="57c7cf9d2a0cafdf74f389b4d473eed903a50706" translate="yes" xml:space="preserve">
          <source>Splitting Across Files</source>
          <target state="translated">ファイル間の分割</target>
        </trans-unit>
        <trans-unit id="2bde101117a83786a9fe359d813c1badf4a6b2ee" translate="yes" xml:space="preserve">
          <source>Spread</source>
          <target state="translated">Spread</target>
        </trans-unit>
        <trans-unit id="e52ae13e940c439690285391dab1a0051b0c2e04" translate="yes" xml:space="preserve">
          <source>Spread expressions with tuple types</source>
          <target state="translated">タプル型を使った展開式</target>
        </trans-unit>
        <trans-unit id="d6ace75d8be9881329b05b54b6dc429938f458c6" translate="yes" xml:space="preserve">
          <source>Stable packages are available here:</source>
          <target state="translated">安定したパッケージはこちらでご用意しています。</target>
        </trans-unit>
        <trans-unit id="457a8825cdb8efe6f8ed3954625c3f151b370bc9" translate="yes" xml:space="preserve">
          <source>Starting TypeScript 2.9 errors are displayed under &lt;code&gt;--pretty&lt;/code&gt; by default if the output device is applicable for colorful text. TypeScript will check if the output steam has &lt;a href=&quot;https://nodejs.org/api/tty.html&quot;&gt;&lt;code&gt;isTty&lt;/code&gt;&lt;/a&gt; property set.</source>
          <target state="translated">TypeScript 2.9以降のエラーは、出力デバイスがカラフルなテキストに適用できる場合、デフォルトで &lt;code&gt;--pretty&lt;/code&gt; の下に表示されます。 TypeScriptは、出力&lt;a href=&quot;https://nodejs.org/api/tty.html&quot;&gt; &lt;code&gt;isTty&lt;/code&gt; &lt;/a&gt;プロパティが設定されているかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="e1bd71f28dac9f8b9839f2877d980ac89846a470" translate="yes" xml:space="preserve">
          <source>Starting from release 1.6 TypeScript compiler will use different set of rules to resolve module names when targeting &amp;lsquo;commonjs&amp;rsquo;. These &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2338&quot;&gt;rules&lt;/a&gt; attempted to model module lookup procedure used by Node. This effectively mean that node modules can include information about its typings and TypeScript compiler will be able to find it. User however can override module resolution rules picked by the compiler by using &lt;code&gt;--moduleResolution&lt;/code&gt; command line option. Possible values are:</source>
          <target state="translated">リリース1.6以降、TypeScriptコンパイラは、「commonjs」を対象とする場合に異なるルールセットを使用してモジュール名を解決します。 これらの&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2338&quot;&gt;ルール&lt;/a&gt;は、Nodeが使用するモジュール検索手順をモデル化しようとしました。 これは事実上、ノードモジュールがその型に関する情報を含むことができ、TypeScriptコンパイラがそれを見つけることができることを意味します。 ただし、ユーザーは &lt;code&gt;--moduleResolution&lt;/code&gt; コマンドラインオプションを使用して、コンパイラが選択したモジュール解決ルールをオーバーライドできます。 可能な値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e863c718db915f2f4b58c523e97d4f07d5237232" translate="yes" xml:space="preserve">
          <source>Starting out</source>
          <target state="translated">スタートアップ</target>
        </trans-unit>
        <trans-unit id="27ba7e115de3bfd5bf5dc01034bb164d0740a437" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, &lt;code&gt;symbol&lt;/code&gt; is a primitive data type, just like &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">ECMAScript 2015以降、 &lt;code&gt;symbol&lt;/code&gt; は、 &lt;code&gt;number&lt;/code&gt; や &lt;code&gt;string&lt;/code&gt; と同様にプリミティブデータ型です。</target>
        </trans-unit>
        <trans-unit id="f7d9af76ba0d605e072032df04742ab0cf02228b" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, JavaScript has a concept of modules. TypeScript shares this concept.</source>
          <target state="translated">ECMAScript 2015から、JavaScriptにはモジュールという概念があります。TypeScriptもこの概念を共有しています。</target>
        </trans-unit>
        <trans-unit id="afc8e56cf364b15c88268122ccbfe29a39ca7ca5" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism.</source>
          <target state="translated">ECMAScript 2015 以降、モジュールは言語のネイティブな部分であり、すべての準拠したエンジンの実装でサポートされるべきです。したがって、新しいプロジェクトでは、モジュールが推奨されるコード編成メカニズムとなります。</target>
        </trans-unit>
        <trans-unit id="51e38a40604a0a2de5e2d000abadb800295b34df" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 1.8, official NuGet packages are available for the Typescript Compiler (&lt;code&gt;tsc.exe&lt;/code&gt;) as well as the MSBuild integration (&lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; and &lt;code&gt;Microsoft.TypeScript.Tasks.dll&lt;/code&gt;).</source>
          <target state="translated">TypeScript 1.8以降、TypeScriptコンパイラ（ &lt;code&gt;tsc.exe&lt;/code&gt; ）およびMSBuild統合（ &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; および &lt;code&gt;Microsoft.TypeScript.Tasks.dll&lt;/code&gt; ）で公式のNuGetパッケージを使用できます。</target>
        </trans-unit>
        <trans-unit id="fe907641294d4a842173702363c42ee105d23f56" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 1.8:</source>
          <target state="translated">TypeScript 1.8からスタート。</target>
        </trans-unit>
        <trans-unit id="667eaed082674a988c7fa4d7c4bc04735599c26c" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 2.3, the default &lt;code&gt;tsconfig.json&lt;/code&gt; generated by &lt;code&gt;tsc --init&lt;/code&gt; includes a &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; setting in the &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; section. Thus, new projects started with &lt;code&gt;tsc --init&lt;/code&gt; will by default have the highest level of type safety enabled.</source>
          <target state="translated">TypeScript 2.3以降、 &lt;code&gt;tsconfig.json&lt;/code&gt; によって生成されるデフォルトのtsconfig.jsonには、 &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; セクションに &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; 設定が含まれています。 したがって、 &lt;code&gt;tsc --init&lt;/code&gt; で開始された新しいプロジェクトでは、デフォルトで最高レベルのタイプセーフが有効になります。</target>
        </trans-unit>
        <trans-unit id="3b2ba1ad0dec7805611669102a4687a54df4fb4a" translate="yes" xml:space="preserve">
          <source>Statements guaranteed to not be executed at run time are now correctly flagged as unreachable code errors. For instance, statements following unconditional &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt; statements are considered unreachable. Use &lt;code&gt;--allowUnreachableCode&lt;/code&gt; to disable unreachable code detection and reporting.</source>
          <target state="translated">実行時に実行されないことが保証されたステートメントは、到達不能コードエラーとして正しくフラグが付けられるようになりました。 たとえば、無条件の &lt;code&gt;return&lt;/code&gt; 、 &lt;code&gt;throw&lt;/code&gt; 、 &lt;code&gt;break&lt;/code&gt; または &lt;code&gt;continue&lt;/code&gt; ステートメントに続くステートメントは到達不能と見なされます。 &lt;code&gt;--allowUnreachableCode&lt;/code&gt; を使用して、到達不能コードの検出とレポートを無効にします。</target>
        </trans-unit>
        <trans-unit id="5dd52f62e1be6f918ab77a38268c4534241ce617" translate="yes" xml:space="preserve">
          <source>Static Properties</source>
          <target state="translated">静的なプロパティ</target>
        </trans-unit>
        <trans-unit id="8c4de2a053d6fce41e20676b11e60a8bda4be893" translate="yes" xml:space="preserve">
          <source>Static methods on an exported class have a similar problem - the class itself adds a layer of nesting. Unless it increases expressivity or intent in a clearly useful way, consider simply exporting a helper function.</source>
          <target state="translated">エクスポートされたクラスのスタティックメソッドにも同様の問題があります。明らかに有用な方法で表現力や意図を高めるのでなければ、単にヘルパー関数をエクスポートすることを検討してください。</target>
        </trans-unit>
        <trans-unit id="e056817fe3841123d274840f9970929fd1661955" translate="yes" xml:space="preserve">
          <source>StaticZipCodeValidator.ts</source>
          <target state="translated">StaticZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="876f3e0202ca40dedf2e5ab6577eba1ae637fb53" translate="yes" xml:space="preserve">
          <source>Strategies</source>
          <target state="translated">Strategies</target>
        </trans-unit>
        <trans-unit id="b24ced1a6bde1cad399359d1809b17476b8956ce" translate="yes" xml:space="preserve">
          <source>Strict &lt;code&gt;null&lt;/code&gt; &amp;amp; &lt;code&gt;undefined&lt;/code&gt; Checks</source>
          <target state="translated">厳密な &lt;code&gt;null&lt;/code&gt; および &lt;code&gt;undefined&lt;/code&gt; チェック</target>
        </trans-unit>
        <trans-unit id="ba990120d287758ccaffce7420f0d37783310854" translate="yes" xml:space="preserve">
          <source>Strict Class Initialization</source>
          <target state="translated">厳格なクラス初期化</target>
        </trans-unit>
        <trans-unit id="e8a4e48ac15ba59cbf4a0e834cf82e7a56d1dc79" translate="yes" xml:space="preserve">
          <source>Strict contravariance for callback parameters</source>
          <target state="translated">コールバックパラメータの厳密な矛盾</target>
        </trans-unit>
        <trans-unit id="8236c998ec2e20c7b6ba2fbd2308a5a59e458fff" translate="yes" xml:space="preserve">
          <source>Strict function types</source>
          <target state="translated">厳密な関数型</target>
        </trans-unit>
        <trans-unit id="503ce04e3c451abd56d5c6cc0eeb1f004a6a9b01" translate="yes" xml:space="preserve">
          <source>Stricter Generators</source>
          <target state="translated">厳格化されたジェネレーター</target>
        </trans-unit>
        <trans-unit id="ac111df4e339d358e1192621e12afb377c50ec08" translate="yes" xml:space="preserve">
          <source>Stricter Generics</source>
          <target state="translated">より厳格なジェネリック</target>
        </trans-unit>
        <trans-unit id="7c1c37e677884ed5162824f92bf4ac0323765899" translate="yes" xml:space="preserve">
          <source>Stricter checking for generic functions</source>
          <target state="translated">汎用関数のチェックを厳格化</target>
        </trans-unit>
        <trans-unit id="59d7c0445a12d3c38c6410a065795f30dedb9910" translate="yes" xml:space="preserve">
          <source>Stricter object literal assignment checks</source>
          <target state="translated">より厳格なオブジェクトリテラルの代入チェック</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="d38945e9d63e72217f1ff6e3be1ea79fbfff3091" translate="yes" xml:space="preserve">
          <source>String Enums</source>
          <target state="translated">文字列列列挙</target>
        </trans-unit>
        <trans-unit id="b9ee8e1a51d8d2f14d5767f34ddd3e68f008e59a" translate="yes" xml:space="preserve">
          <source>String Literal Types</source>
          <target state="translated">文字列リテラル型</target>
        </trans-unit>
        <trans-unit id="ffa12823a95532beb06727f353cfba4e754b5e99" translate="yes" xml:space="preserve">
          <source>String enums</source>
          <target state="translated">文字列列列挙</target>
        </trans-unit>
        <trans-unit id="135b4e07f53722d425681f40b44219a30c502379" translate="yes" xml:space="preserve">
          <source>String enums are a similar concept, but have some subtle &lt;a href=&quot;#enums-at-runtime&quot;&gt;runtime differences&lt;/a&gt; as documented below. In a string enum, each member has to be constant-initialized with a string literal, or with another string enum member.</source>
          <target state="translated">文字列列挙も同様の概念ですが、以下で説明するように、 &lt;a href=&quot;#enums-at-runtime&quot;&gt;実行時に&lt;/a&gt;わずかな違いがあります。 文字列列挙では、各メンバーは文字列リテラルまたは別の文字列列挙メンバーで定数で初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="97ca47845b6de917d6acef338327258499a5fa14" translate="yes" xml:space="preserve">
          <source>String literal types</source>
          <target state="translated">文字列リテラル型</target>
        </trans-unit>
        <trans-unit id="3094f1d45b3a85252ec82b4f2621aa324f1df082" translate="yes" xml:space="preserve">
          <source>String literal types allow you to specify the exact value a string must have. In practice string literal types combine nicely with union types, type guards, and type aliases. You can use these features together to get enum-like behavior with strings.</source>
          <target state="translated">文字列リテラル型では、文字列が持つべき値を正確に指定することができます。実際には、文字列リテラル型はユニオン型、型ガード、型エイリアスとうまく組み合わせます。これらの機能を併用することで、文字列で列挙型のような動作を得ることができます。</target>
        </trans-unit>
        <trans-unit id="b874e7e8ff440bab9b01a84543e1af14d5b4bb4b" translate="yes" xml:space="preserve">
          <source>String literal types can be used in the same way to distinguish overloads:</source>
          <target state="translated">文字列リテラル型は、オーバーロードを区別するために同じように使用することができます。</target>
        </trans-unit>
        <trans-unit id="46e91541a55f18468fd6b067383aaa97a9e64cd2" translate="yes" xml:space="preserve">
          <source>String, numeric and boolean literal types (e.g. &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt;) were previously inferred only in the presence of an explicit type annotation. Starting with TypeScript 2.1, literal types are &lt;em&gt;always&lt;/em&gt; inferred for &lt;code&gt;const&lt;/code&gt; variables and &lt;code&gt;readonly&lt;/code&gt; properties.</source>
          <target state="translated">文字列、数値、およびブールのリテラル型（例： &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 、 &lt;code&gt;1&lt;/code&gt; 、および &lt;code&gt;true&lt;/code&gt; ）は、以前は明示的な型注釈が存在する場合にのみ推測されていました。 TypeScript 2.1以降では、定数変数と &lt;code&gt;readonly&lt;/code&gt; プロパティのリテラル型が&lt;em&gt;常に&lt;/em&gt;推測されます。</target>
        </trans-unit>
        <trans-unit id="2d8fecbc84175a2cda5fcb984cf28bdb9e9fe54b" translate="yes" xml:space="preserve">
          <source>String-like properties of an object type are those declared using an identifier, a string literal, or a computed property name of a string literal type.</source>
          <target state="translated">オブジェクト型の文字列ライクなプロパティは、識別子、文字列リテラル、または文字列リテラル型の計算されたプロパティ名を使用して宣言されたものです。</target>
        </trans-unit>
        <trans-unit id="f44c134a9d7c63d1a602a14744e321854b363720" translate="yes" xml:space="preserve">
          <source>StringValidator.ts</source>
          <target state="translated">StringValidator.ts</target>
        </trans-unit>
        <trans-unit id="e9e5d94110d726b2fb48e7030cec7299992b6e0c" translate="yes" xml:space="preserve">
          <source>Structurally identical, but distinct, class types are now preserved in union types (instead of eliminating all but one).</source>
          <target state="translated">構造的には同じですが、異なるクラス型がユニオン型に保存されるようになりました (1つを除いてすべてを削除するのではなく)。</target>
        </trans-unit>
        <trans-unit id="f188cd9e1081421f05e7530e5be35f73639cddfb" translate="yes" xml:space="preserve">
          <source>Structuring for outFiles</source>
          <target state="translated">outFiles の構造化</target>
        </trans-unit>
        <trans-unit id="9790ea759cfc56e0057f75d2b47d5dd9230cb97d" translate="yes" xml:space="preserve">
          <source>Structuring for relative modules</source>
          <target state="translated">相対モジュールの構造化</target>
        </trans-unit>
        <trans-unit id="28a732981a8711b19d230aaecb27b43ddf871667" translate="yes" xml:space="preserve">
          <source>Structuring modules to give the exact API shape you want can be tricky. For example, we might want a module that can be invoked with or without &lt;code&gt;new&lt;/code&gt; to produce different types, has a variety of named types exposed in a hierarchy, and has some properties on the module object as well.</source>
          <target state="translated">必要なAPIの正確な形状を提供するためにモジュールを構築するのは難しい場合があります。 たとえば、異なるタイプを生成するために &lt;code&gt;new&lt;/code&gt; を使用して、または使用せずに呼び出すことができ、さまざまな名前付きタイプを階層で公開し、モジュールオブジェクトのプロパティも持つモジュールが必要な場合があります。</target>
        </trans-unit>
        <trans-unit id="426c20ffe12820a1c17c8b53aa917b10b06fc64e" translate="yes" xml:space="preserve">
          <source>Stylize errors and messages using color and context.</source>
          <target state="translated">色とコンテキストを使ってエラーやメッセージをスタイリングします。</target>
        </trans-unit>
        <trans-unit id="9ce6ba148fe8d9ab4a1efa44f043d11727e7f6ee" translate="yes" xml:space="preserve">
          <source>Sublime Text</source>
          <target state="translated">崇高なテキスト</target>
        </trans-unit>
        <trans-unit id="89f541951e4630b0519550eb0b55d466b60ae9d9" translate="yes" xml:space="preserve">
          <source>Subtype vs Assignment</source>
          <target state="translated">サブタイプと割り当て</target>
        </trans-unit>
        <trans-unit id="18532a66f85c71ab4aec069080bab114bcb593de" translate="yes" xml:space="preserve">
          <source>Support &amp;lsquo;target : es5&amp;rsquo; with &amp;lsquo;module: es6&amp;rsquo;</source>
          <target state="translated">「モジュール：es6」で「ターゲット：es5」をサポート</target>
        </trans-unit>
        <trans-unit id="cf4b3d9e87de6d08216090fd0a299f43489307ab" translate="yes" xml:space="preserve">
          <source>Support &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named properties with &lt;code&gt;keyof&lt;/code&gt; and mapped types</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; およびマップされたタイプを使用して 、名前付きプロパティをサポート</target>
        </trans-unit>
        <trans-unit id="6d6731f9d93089d17da6ccec6778d165fccc26c7" translate="yes" xml:space="preserve">
          <source>Support JSX in &lt;code&gt;.tsx&lt;/code&gt; files: &lt;code&gt;&quot;react&quot;&lt;/code&gt;, &lt;code&gt;&quot;preserve&quot;&lt;/code&gt;, &lt;code&gt;&quot;react-native&quot;&lt;/code&gt;. See &lt;a href=&quot;jsx&quot;&gt;JSX&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.tsx&lt;/code&gt; ファイルでJSXをサポート： &lt;code&gt;&quot;react&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;preserve&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;react-native&quot;&lt;/code&gt; 。 &lt;a href=&quot;jsx&quot;&gt;JSXを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="05b310d45d1a230630edd11c6875345ecb5c8f86" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;--target ES2016&lt;/code&gt;, &lt;code&gt;--target ES2017&lt;/code&gt; and &lt;code&gt;--target ESNext&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--target ES2016&lt;/code&gt; 、 &lt;code&gt;--target ES2017&lt;/code&gt; 、および &lt;code&gt;--target ESNext&lt;/code&gt; のサポート</target>
        </trans-unit>
        <trans-unit id="b1b4ca504fdd62c03cb94726f4bcaf5058e435b4" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;--target ES6&lt;/code&gt; with &lt;code&gt;--module&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--module&lt;/code&gt; を使用した &lt;code&gt;--target ES6&lt;/code&gt; のサポート</target>
        </trans-unit>
        <trans-unit id="34617739aff3f3e46b1e4ba3a7911e40d6c81ab3" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;UMD&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt; module output</source>
          <target state="translated">&lt;code&gt;UMD&lt;/code&gt; および &lt;code&gt;System&lt;/code&gt; モジュール出力のサポート</target>
        </trans-unit>
        <trans-unit id="28e272a817a6f695cb0b07fe3c763c51df093f79" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;default&lt;/code&gt; import interop with SystemJS</source>
          <target state="translated">SystemJSとの &lt;code&gt;default&lt;/code&gt; インポート相互運用のサポート</target>
        </trans-unit>
        <trans-unit id="d6916bf8e4e9fcc67b553b85f533341a04a63081" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;defaultProps&lt;/code&gt; in JSX</source>
          <target state="translated">JSXでの &lt;code&gt;defaultProps&lt;/code&gt; のサポート</target>
        </trans-unit>
        <trans-unit id="bddb6099cc8b06729d2beaa2fa82e1cb4963256d" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;import d from &quot;cjs&quot;&lt;/code&gt; from CommonJS modules with &lt;code&gt;--esModuleInterop&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;import d from &quot;cjs&quot;&lt;/code&gt; したCommonJSモジュールからの「cjs」からのインポートdのサポート</target>
        </trans-unit>
        <trans-unit id="2447881f3dbb81c3d00bf540954383e26e79f16a" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;import.meta&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;import.meta&lt;/code&gt; のサポート</target>
        </trans-unit>
        <trans-unit id="b85ac71ca924b44b00a2baf8d735c1f5146eae50" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;new.target&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; のサポート</target>
        </trans-unit>
        <trans-unit id="73d8dfa99384426433e9eb5bd0a25014a68b93dd" translate="yes" xml:space="preserve">
          <source>Support for Mix-in classes</source>
          <target state="translated">ミックスインクラスへの対応</target>
        </trans-unit>
        <trans-unit id="4cd188d2034c82b0cb13c97514a09e1296c575c1" translate="yes" xml:space="preserve">
          <source>Support for UMD module definitions</source>
          <target state="translated">UMDモジュール定義のサポート</target>
        </trans-unit>
        <trans-unit id="3f9527e099215a371571a39ed0291c0f01e1252f" translate="yes" xml:space="preserve">
          <source>Support for decorators when targeting ES3</source>
          <target state="translated">ES3をターゲットにした場合のデコレータのサポート</target>
        </trans-unit>
        <trans-unit id="773f4a6085e5e29b6090e773de66d818050ad310" translate="yes" xml:space="preserve">
          <source>Support for external helpers library (&lt;code&gt;tslib&lt;/code&gt;)</source>
          <target state="translated">外部ヘルパーライブラリー（ &lt;code&gt;tslib&lt;/code&gt; ）のサポート</target>
        </trans-unit>
        <trans-unit id="90086da7e4d9c7c72a78d492416302a2bce77eea" translate="yes" xml:space="preserve">
          <source>Support for plain JavaScript files (using &lt;code&gt;allowJS&lt;/code&gt; and optionally &lt;code&gt;checkJs&lt;/code&gt;)</source>
          <target state="translated">プレーンJavaScriptファイルのサポート（ &lt;code&gt;allowJS&lt;/code&gt; およびオプションで &lt;code&gt;checkJs&lt;/code&gt; を使用）</target>
        </trans-unit>
        <trans-unit id="db578fdb1495d83a80100aad5eef2fff1a254e97" translate="yes" xml:space="preserve">
          <source>Support for spread operator on JSX element children</source>
          <target state="translated">JSX要素の子要素でのスプレッド演算子のサポート</target>
        </trans-unit>
        <trans-unit id="2653012ad53a3216b4b35967a5d2774aa99160ca" translate="yes" xml:space="preserve">
          <source>Support output to IPC-driven files</source>
          <target state="translated">IPC駆動のファイルへの出力をサポート</target>
        </trans-unit>
        <trans-unit id="620a93c5c9f58f502218f8fc7b12158f1027565c" translate="yes" xml:space="preserve">
          <source>Supported JSDoc</source>
          <target state="translated">サポートされているJSDoc</target>
        </trans-unit>
        <trans-unit id="6ec78feed2dab45d29186124c86cf373749a2a02" translate="yes" xml:space="preserve">
          <source>Suppress &lt;code&gt;--noImplicitAny&lt;/code&gt; errors for indexing objects lacking index signatures. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362&quot;&gt;issue #1232&lt;/a&gt; for more details.</source>
          <target state="translated">インデックス署名のないオブジェクトのインデックス作成 &lt;code&gt;--noImplicitAny&lt;/code&gt; エラーを抑制します。 詳細については、 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362&quot;&gt;問題＃1232&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="338998f043c7ad5149421a96548321599b5d11bd" translate="yes" xml:space="preserve">
          <source>Suppress errors in .ts files using &amp;lsquo;// @ts-ignore&amp;rsquo; comments</source>
          <target state="translated">'// @ ts-ignore'コメントを使用して.tsファイルのエラーを抑制します</target>
        </trans-unit>
        <trans-unit id="8973ef81aed840ec50c9cd093b51f775080b1cf7" translate="yes" xml:space="preserve">
          <source>Suppress excess property checks for object literals.</source>
          <target state="translated">オブジェクトリテラルの過剰なプロパティチェックを抑制します。</target>
        </trans-unit>
        <trans-unit id="3585e72f4611a04509e6e0fc987893b8915a495f" translate="yes" xml:space="preserve">
          <source>Symbol-like properties of an object type are those declared using a computed property name of a unique symbol type.</source>
          <target state="translated">オブジェクト型のシンボルライクなプロパティは、ユニークなシンボル型の計算されたプロパティ名を使用して宣言されたものです。</target>
        </trans-unit>
        <trans-unit id="22ad664e9eb98b75a73333b2b2395fc4b52e6fc9" translate="yes" xml:space="preserve">
          <source>Symbols</source>
          <target state="translated">Symbols</target>
        </trans-unit>
        <trans-unit id="53fd75a5e5e2b34489476f4ecd50211e84205baf" translate="yes" xml:space="preserve">
          <source>Symbols are immutable, and unique.</source>
          <target state="translated">シンボルは不変であり、唯一無二のものです。</target>
        </trans-unit>
        <trans-unit id="0bed88fc8e0305dee9b7427dfb28c60dd6df7d7b" translate="yes" xml:space="preserve">
          <source>Symbols can also be combined with computed property declarations to declare object properties and class members.</source>
          <target state="translated">シンボルは、オブジェクトのプロパティやクラスのメンバを宣言するために、計算されたプロパティ宣言と組み合わせることもできます。</target>
        </trans-unit>
        <trans-unit id="7c6dc245d5de42731e89891927ee10ddf6d43590" translate="yes" xml:space="preserve">
          <source>Symbols: match</source>
          <target state="translated">シンボル:一致</target>
        </trans-unit>
        <trans-unit id="43536b93399f1c157500ef28d7217046b25bc3c7" translate="yes" xml:space="preserve">
          <source>Symbols: split</source>
          <target state="translated">シンボル:スプリット</target>
        </trans-unit>
        <trans-unit id="57405c7f4b3b71908ae936ac8bf9b21de6ae98b8" translate="yes" xml:space="preserve">
          <source>System SimpleModule.js</source>
          <target state="translated">システムSimpleModule.js</target>
        </trans-unit>
        <trans-unit id="058f3d3687346d631d12546d9aade907ff39e99c" translate="yes" xml:space="preserve">
          <source>System modules have this flag on by default.</source>
          <target state="translated">システムモジュールはデフォルトでこのフラグをオンにしています。</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">目次</target>
        </trans-unit>
        <trans-unit id="1a428989bd13dceabd89b698d9fa38eb8a0d175c" translate="yes" xml:space="preserve">
          <source>Table of contents</source>
          <target state="translated">目次</target>
        </trans-unit>
        <trans-unit id="f228b75e57f130e745a665c5ce1b42328c6dfd98" translate="yes" xml:space="preserve">
          <source>Tagged template strings in ES3/ES5</source>
          <target state="translated">タグ付きテンプレート文字列 in ES3ES5</target>
        </trans-unit>
        <trans-unit id="fab887d80b08c2be61de81a5b5b7c7f5fa4679ed" translate="yes" xml:space="preserve">
          <source>Tagged templates are a form of invocation introduced in ECMAScript 2015. Like call expressions, generic functions may be used in a tagged template and TypeScript will infer the type arguments utilized.</source>
          <target state="translated">タグ付きテンプレートは、ECMAScript 2015で導入された呼び出しの一形態です。呼び出し式と同様に、汎用関数はタグ付きテンプレートで使用することができ、TypeScriptは利用される型引数を推論します。</target>
        </trans-unit>
        <trans-unit id="2b4f32e1493a8fa164f90de2c9603dab9f3396aa" translate="yes" xml:space="preserve">
          <source>Tagged union types</source>
          <target state="translated">タグ付けされたユニオンタイプ</target>
        </trans-unit>
        <trans-unit id="ef15d77ea17c2fa0aa9a4dc5193a61bfca293a68" translate="yes" xml:space="preserve">
          <source>Take a quick second to guess what the output of the following snippet is:</source>
          <target state="translated">次のスニペットの出力が何であるかを推測してみてください。</target>
        </trans-unit>
        <trans-unit id="62ec74968326eeada16e680490be28b9d097cf14" translate="yes" xml:space="preserve">
          <source>Targeting ECMAScript 2015 and higher</source>
          <target state="translated">ECMAScript 2015以上が対象</target>
        </trans-unit>
        <trans-unit id="2bb2a353dcf3f98e351b8a5bd43ad7b5855fbf44" translate="yes" xml:space="preserve">
          <source>Targeting ES5 and ES3</source>
          <target state="translated">ES5とES3をターゲットに</target>
        </trans-unit>
        <trans-unit id="8ebc171caef41add998a541b54fac3e9f04d8a0f" translate="yes" xml:space="preserve">
          <source>Technically enums can be mixed with string and numeric members, but it&amp;rsquo;s not clear why you would ever want to do so:</source>
          <target state="translated">技術的には、enumは文字列および数値メンバーと混在させることができますが、なぜそうする必要があるのか​​は明確ではありません。</target>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="dc68610743d7021a571f80b8ceb084cbd65c3e6a" translate="yes" xml:space="preserve">
          <source>Template strings</source>
          <target state="translated">テンプレート文字列</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="c2e85441e7a65630aa9248ad72623a3bd8be6e63" translate="yes" xml:space="preserve">
          <source>Test the page by running gulp and then opening &lt;code&gt;dist/index.html&lt;/code&gt; in a browser. You should see &amp;ldquo;Hello from TypeScript&amp;rdquo; on the page.</source>
          <target state="translated">gulpを実行し、ブラウザーで &lt;code&gt;dist/index.html&lt;/code&gt; を開いてページをテストします。 ページに「TypeScriptからこんにちは」と表示されます。</target>
        </trans-unit>
        <trans-unit id="516512568426629f66efb194dad6577cd22670ee" translate="yes" xml:space="preserve">
          <source>Test the resulting app</source>
          <target state="translated">結果のアプリをテストする</target>
        </trans-unit>
        <trans-unit id="96936a34c6da56cc40a32168338d905fe8a635c6" translate="yes" xml:space="preserve">
          <source>Test.ts</source>
          <target state="translated">Test.ts</target>
        </trans-unit>
        <trans-unit id="13197620f3528b6ac6188ce141c50ce0cda7fc64" translate="yes" xml:space="preserve">
          <source>TestCalculator.ts</source>
          <target state="translated">TestCalculator.ts</target>
        </trans-unit>
        <trans-unit id="cfaf8455cd86f64e0270da345fff974aff74f2d4" translate="yes" xml:space="preserve">
          <source>TestProgrammerCalculator.ts</source>
          <target state="translated">TestProgrammerCalculator.ts</target>
        </trans-unit>
        <trans-unit id="aa824f1aa0454aaae79a599c4caec36b1aa0a833" translate="yes" xml:space="preserve">
          <source>Thanks to work done by &lt;a href=&quot;https://github.com/tinganho&quot;&gt;@tinganho&lt;/a&gt;, TypeScript 2.5 implements a new ECMAScript feature that allows users to omit the variable in &lt;code&gt;catch&lt;/code&gt; clauses. For example, when using &lt;code&gt;JSON.parse&lt;/code&gt; you may need to wrap calls to the function with a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;, but you may not end up using the &lt;code&gt;SyntaxError&lt;/code&gt; that gets thrown when input is erroneous.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tinganho&quot;&gt;@tinganho&lt;/a&gt;によって行われた作業のおかげで、TypeScript 2.5は、ユーザーが &lt;code&gt;catch&lt;/code&gt; 句で変数を省略できる新しいECMAScript機能を実装します。 たとえば、 &lt;code&gt;JSON.parse&lt;/code&gt; を使用する場合、関数の呼び出しを &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; でラップする必要がありますが、入力が間違っている場合にスローされる &lt;code&gt;SyntaxError&lt;/code&gt; を使用することはできません。</target>
        </trans-unit>
        <trans-unit id="e9dd082930f9a8388911a09a5116d64645cb5117" translate="yes" xml:space="preserve">
          <source>That &lt;code&gt;@types/&lt;/code&gt; prefix means that we also want to get the declaration files for React and React-DOM. Usually when you import a path like &lt;code&gt;&quot;react&quot;&lt;/code&gt;, it will look inside of the &lt;code&gt;react&lt;/code&gt; package itself; however, not all packages include declaration files, so TypeScript also looks in the &lt;code&gt;@types/react&lt;/code&gt; package as well. You&amp;rsquo;ll see that we won&amp;rsquo;t even have to think about this later on.</source>
          <target state="translated">&lt;code&gt;@types/&lt;/code&gt; プレフィックスは、ReactおよびReact-DOMの宣言ファイルも取得することを意味します。 通常、 &lt;code&gt;&quot;react&quot;&lt;/code&gt; ようなパスをインポートすると、 &lt;code&gt;react&lt;/code&gt; パッケージ自体の内部が見えます。 ただし、すべてのパッケージに宣言ファイルが含まれているわけではないため、TypeScriptは &lt;code&gt;@types/react&lt;/code&gt; パッケージも検索します。 後でこれについて考える必要さえないことがわかるでしょう。</target>
        </trans-unit>
        <trans-unit id="25b9871704aecadb7cf39ba9a43b9edb9f462ecd" translate="yes" xml:space="preserve">
          <source>That is, in the example:</source>
          <target state="translated">つまり、例の中では</target>
        </trans-unit>
        <trans-unit id="679400f47462964a9c86c95a36308380ba51cbe6" translate="yes" xml:space="preserve">
          <source>That last example isn&amp;rsquo;t actually type-safe.</source>
          <target state="translated">最後の例は、実際にはタイプセーフではありません。</target>
        </trans-unit>
        <trans-unit id="f3dd652958b97aac01bd3e5a584afa623f93a34e" translate="yes" xml:space="preserve">
          <source>That might result in dividing &lt;code&gt;undefined&lt;/code&gt;, which is why in &lt;code&gt;strictNullChecks&lt;/code&gt;, the following is an error.</source>
          <target state="translated">その結果、 &lt;code&gt;undefined&lt;/code&gt; が分割される可能性があるため、 &lt;code&gt;strictNullChecks&lt;/code&gt; では次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="47f396705024ea00097d673c1c7caf3642c168b2" translate="yes" xml:space="preserve">
          <source>That was &lt;code&gt;tsconfig.json&lt;/code&gt; automatic inclusion. That does not embed module resolution as discussed above. If the compiler identified a file as a target of a module import, it will be included in the compilation regardless if it was excluded in the previous steps.</source>
          <target state="translated">それは &lt;code&gt;tsconfig.json&lt;/code&gt; の自動インクルードでした。 上記で説明したように、モジュールの解決は組み込まれません。 コンパイラがファイルをモジュールインポートのターゲットとして識別した場合、前の手順で除外されたかどうかに関係なく、そのファイルはコンパイルに含まれます。</target>
        </trans-unit>
        <trans-unit id="fa532e4a22d2340a4675cbed4b144ee69c29ecb7" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s because &lt;code&gt;S&lt;/code&gt; isn&amp;rsquo;t assignable to &lt;code&gt;{ done: false, value: number }&lt;/code&gt; nor &lt;code&gt;{ done: true, value: number }&lt;/code&gt;. Why? Because the &lt;code&gt;done&lt;/code&gt; property in &lt;code&gt;S&lt;/code&gt; isn&amp;rsquo;t specific enough - it&amp;rsquo;s &lt;code&gt;boolean&lt;/code&gt; whereas each constituent of &lt;code&gt;T&lt;/code&gt; has a &lt;code&gt;done&lt;/code&gt; property that&amp;rsquo;s specifically &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. That&amp;rsquo;s what we meant by each constituent type being checked in isolation: TypeScript doesn&amp;rsquo;t just union each property together and see if &lt;code&gt;S&lt;/code&gt; is assignable to that. If it did, some bad code could get through like the following:</source>
          <target state="translated">これは、 &lt;code&gt;S&lt;/code&gt; が &lt;code&gt;{ done: false, value: number }&lt;/code&gt; や &lt;code&gt;{ done: true, value: number }&lt;/code&gt; 割り当てられないためです。 どうして？ &lt;code&gt;S&lt;/code&gt; の &lt;code&gt;done&lt;/code&gt; プロパティは十分に具体的ではないため、 &lt;code&gt;boolean&lt;/code&gt; あるのに対し、 &lt;code&gt;T&lt;/code&gt; の各構成要素には、特に &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; の &lt;code&gt;done&lt;/code&gt; プロパティがあります 。 それは、各構成要素の型が分離してチェックされることを意味します。TypeScriptは、各プロパティを結合し、 &lt;code&gt;S&lt;/code&gt; が割り当て可能かどうかを確認するだけではありません。 もしそうなら、いくつかの悪いコードは次のように通り抜けることができます：</target>
        </trans-unit>
        <trans-unit id="ae1a2d3d73ce13174294793215ee52d989a7c794" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s exactly what TypeScript 3.7 introduces. At the &amp;ldquo;top level&amp;rdquo; of a type alias, TypeScript will defer resolving type arguments to permit these patterns.</source>
          <target state="translated">それがまさにTypeScript 3.7で導入されたものです。 型エイリアスの「トップレベル」では、TypeScriptは型引数の解決を延期して、これらのパターンを許可します。</target>
        </trans-unit>
        <trans-unit id="4335f12ef785a4f02d33cbf4fd5c8f14a1000242" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s not to say that block-scoped variable can never be declared with a function-scoped variable. The block-scoped variable just needs to be declared within a distinctly different block.</source>
          <target state="translated">それは、ブロックスコープの変数を関数スコープの変数で宣言できないということではありません。 ブロックスコープ変数は、明確に異なるブロック内で宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="f54fb341f70cf02ca8c9aeedc3f161af36941bc9" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;short-circuiting&amp;rdquo; behavior that optional chains have is limited property accesses, calls, element accesses - it doesn&amp;rsquo;t expand any further out from these expressions. In other words,</source>
          <target state="translated">オプションのチェーンが持つ「短絡」動作は、プロパティへのアクセス、呼び出し、要素へのアクセスが制限されているため、これらの式からさらに拡張されることはありません。 言い換えると、</target>
        </trans-unit>
        <trans-unit id="279685a1fb5d36562f5b58508949f5e1e76e1bfb" translate="yes" xml:space="preserve">
          <source>The 1.1 compiler is typically around 4x faster than any previous release. See &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx&quot;&gt;this blog post for some impressive charts.&lt;/a&gt;</source>
          <target state="translated">通常、1.1コンパイラは、以前のリリースよりも約4倍高速です。 &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx&quot;&gt;印象的なチャート&lt;/a&gt;については、 このブログ投稿をご覧ください。</target>
        </trans-unit>
        <trans-unit id="bb3c43076a9f8e3e7ef5a2ac0f5c12ab3be00750" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;Async Iteration proposal&lt;/a&gt; introduces &amp;ldquo;Async Generators&amp;rdquo;, which are async functions that also can be used to yield partial computation results. Async Generators can also delegate calls via &lt;code&gt;yield*&lt;/code&gt; to either an iterable or async iterable:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;非同期反復の提案で&lt;/a&gt;は、「非同期ジェネレーター」を導入しています。これは、部分的な計算結果を生成するためにも使用できる非同期関数です。 非同期ジェネレーターは、 &lt;code&gt;yield*&lt;/code&gt; を介して反復可能または非同期反復可能のいずれかに呼び出しを委任することもできます。</target>
        </trans-unit>
        <trans-unit id="7f1ed30131b8220c2729612ebb193d0d769356ff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;library-structures&quot;&gt;Library Structures&lt;/a&gt; guide helps you understand common library formats and how to write a correct declaration file for each format. If you&amp;rsquo;re editing an existing file, you probably don&amp;rsquo;t need to read this section. Authors of new declaration files must read this section to properly understand how the format of the library influences the writing of the declaration file.</source>
          <target state="translated">&lt;a href=&quot;library-structures&quot;&gt;ライブラリ構造&lt;/a&gt;ガイドは、一般的なライブラリ形式と各形式の正しい宣言ファイルの書き方を理解するのに役立ちます。 既存のファイルを編集している場合、おそらくこのセクションを読む必要はありません。 新しい宣言ファイルの作成者は、このセクションを読んで、ライブラリの形式が宣言ファイルの作成にどのように影響するかを適切に理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="168fd27f48806216cef1b28e300e7429c8509f10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;publishing&quot;&gt;Publishing&lt;/a&gt; section explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages.</source>
          <target state="translated">&lt;a href=&quot;publishing&quot;&gt;発行&lt;/a&gt;セクションでは、宣言ファイルをnpmパッケージに発行する方法について説明し、依存パッケージを管理する方法を示します。</target>
        </trans-unit>
        <trans-unit id="ce97eb39054abf8cf82837da2071a640fc60351d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; property can be omitted, in which case the compiler&amp;rsquo;s defaults are used. See our full list of supported &lt;a href=&quot;compiler-options&quot;&gt;Compiler Options&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; プロパティは省略できます。この場合、コンパイラのデフォルトが使用されます。 サポートされている&lt;a href=&quot;compiler-options&quot;&gt;コンパイラオプションの&lt;/a&gt;完全なリストをご覧ください。</target>
        </trans-unit>
        <trans-unit id="8e8ffdb01927e70146bd53bb542f82c73b284a32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;files&quot;&lt;/code&gt; property takes a list of relative or absolute file paths. The &lt;code&gt;&quot;include&quot;&lt;/code&gt; and &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; properties take a list of glob-like file patterns. The supported glob wildcards are:</source>
          <target state="translated">&lt;code&gt;&quot;files&quot;&lt;/code&gt; プロパティは、相対または絶対ファイルパスのリストを取ります。 &lt;code&gt;&quot;include&quot;&lt;/code&gt; および &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; プロパティは、globに似たファイルパターンのリストを取ります。 サポートされているglobワイルドカードは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5722d93ed96ab9d91793fbf0f2e4a3ba0ddbc777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator adds &lt;code&gt;null&lt;/code&gt; and/or &lt;code&gt;undefined&lt;/code&gt; to the type of the right operand depending on which are present in the type of the left operand, and the &lt;code&gt;||&lt;/code&gt; operator removes both &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from the type of the left operand in the resulting union type.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 演算子は、左側のオペランドのタイプに存在するものに応じて、右側のオペランドのタイプに &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; を追加します。 演算子は、結果のユニオン型の左側のオペランドの型から &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; の両方を削除します 。</target>
        </trans-unit>
        <trans-unit id="b4b79995af952725664d6d796fdff7040cdc711f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; flag</source>
          <target state="translated">&lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; フラグ</target>
        </trans-unit>
        <trans-unit id="dbed519ddc1c4c5224ed0885756fb408460d0e55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--declaration&lt;/code&gt; flag in TypeScript allows us to generate &lt;code&gt;.d.ts&lt;/code&gt; files (declaration files) from TypeScript source files (i.e. &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files). These &lt;code&gt;.d.ts&lt;/code&gt; files are important for a couple of reasons.</source>
          <target state="translated">TypeScriptの &lt;code&gt;--declaration&lt;/code&gt; フラグを使用すると、TypeScriptソースファイル（つまり &lt;code&gt;.ts&lt;/code&gt; および &lt;code&gt;.tsx&lt;/code&gt; ファイル）から &lt;code&gt;.d.ts&lt;/code&gt; ファイル（宣言ファイル）を生成できます。 これらの &lt;code&gt;.d.ts&lt;/code&gt; ファイルは、いくつかの理由で重要です。</target>
        </trans-unit>
        <trans-unit id="a0fb7dd8edc5f347ffbf928efce80d73f62bde6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--noResolve&lt;/code&gt; compiler options instructs the compiler not to &amp;ldquo;add&amp;rdquo; any files to the compilation that were not passed on the command line. It will still try to resolve the module to files, but if the file is not specified, it will not be included.</source>
          <target state="translated">&lt;code&gt;--noResolve&lt;/code&gt; コンパイラオプションは、コマンドラインで渡されなかったファイルをコンパイルに「追加」しないようにコンパイラに指示します。 モジュールをファイルに解決しようとしますが、ファイルが指定されていない場合は含まれません。</target>
        </trans-unit>
        <trans-unit id="9d5dd988f9131b75e837bf6bf95d2078c1309d5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--preserveSymlinks&lt;/code&gt; compiler flag</source>
          <target state="translated">&lt;code&gt;--preserveSymlinks&lt;/code&gt; コンパイラフラグ</target>
        </trans-unit>
        <trans-unit id="d292c9d31d759812ffbe643f5735affa1b872f39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--project&lt;/code&gt; (&lt;code&gt;-p&lt;/code&gt;) flag can now take any file path</source>
          <target state="translated">&lt;code&gt;--project&lt;/code&gt; （ &lt;code&gt;-p&lt;/code&gt; ）フラグが任意のファイルパスを取ることができるようになりました</target>
        </trans-unit>
        <trans-unit id="a4255cfd03965e4b15ab5c96a185655e2dc5c33c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--project&lt;/code&gt; command line option originally could only take paths to a folder containing a &lt;code&gt;tsconfig.json&lt;/code&gt;. Given the different scenarios for build configurations, it made sense to allow &lt;code&gt;--project&lt;/code&gt; to point to any other compatible JSON file. For instance, a user might want to target ES2015 with CommonJS modules for Node 5, but ES5 with AMD modules for the browser. With this new work, users can easily manage two separate build targets using &lt;code&gt;tsc&lt;/code&gt; alone without having to perform hacky workarounds like placing &lt;code&gt;tsconfig.json&lt;/code&gt; files in separate directories.</source>
          <target state="translated">&lt;code&gt;--project&lt;/code&gt; コマンドラインオプションは、もともと &lt;code&gt;tsconfig.json&lt;/code&gt; を含むフォルダーへのパスしか取得できませんでした 。 ビルド構成のさまざまなシナリオを考えると、-- &lt;code&gt;--project&lt;/code&gt; が他の互換性のあるJSONファイルを指すことを許可するのは理にかなっています。 たとえば、ノード5にはCommonJSモジュールを使用してES2015をターゲットにしたいが、ブラウザにはAMDモジュールを使用したES5をターゲットにしたい場合があります。 この新しい作業により、ユーザーは、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを個別のディレクトリに配置するなどのハッキング回避策を実行することなく、 &lt;code&gt;tsc&lt;/code&gt; のみを使用して2つの個別のビルドターゲットを簡単に管理できます。</target>
        </trans-unit>
        <trans-unit id="b04bf272ea6b6bb26429cf5a5402059fbfa0a766" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--strictNullChecks&lt;/code&gt; flag fixes this: when you declare a variable, it doesn&amp;rsquo;t automatically include &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. You can include them explicitly using a union type:</source>
          <target state="translated">&lt;code&gt;--strictNullChecks&lt;/code&gt; フラグはこれを修正します。変数を宣言するときに、自動的に &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; が含まれることはありません。 ユニオン型を使用して明示的に含めることができます。</target>
        </trans-unit>
        <trans-unit id="396ee46179af469e8ce6ffe938facf87a8ca3308" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive is the most common of this group. It serves as a declaration of &lt;em&gt;dependency&lt;/em&gt; between files.</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; ディレクティブは、このグループで最も一般的です。 ファイル間の&lt;em&gt;依存関係の&lt;/em&gt;宣言として機能します。</target>
        </trans-unit>
        <trans-unit id="c5d5fa087679e905484eaa0544e66e00047a3587" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;??&lt;/code&gt; operator can replace uses of &lt;code&gt;||&lt;/code&gt; when trying to use a default value. For example, the following code snippet tries to fetch the volume that was last saved in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt;&lt;code&gt;localStorage&lt;/code&gt;&lt;/a&gt; (if it ever was); however, it has a bug because it uses &lt;code&gt;||&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;??&lt;/code&gt; 演算子は &lt;code&gt;||&lt;/code&gt; の使用を置き換えることができます デフォルト値を使用しようとしたとき。 たとえば、次のコードスニペットは、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt; &lt;code&gt;localStorage&lt;/code&gt; &lt;/a&gt;に最後に保存されたボリューム（ある場合）を取得しようとします。 ただし、 &lt;code&gt;||&lt;/code&gt; を使用するため、バグがあります。 。</target>
        </trans-unit>
        <trans-unit id="33ec4ccdd0a92f0fa626d1020e8655d8d52e57a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@enum&lt;/code&gt; tag allows you to create an object literal whose members are all of a specified type. Unlike most object literals in Javascript, it does not allow other members.</source>
          <target state="translated">&lt;code&gt;@enum&lt;/code&gt; タグを使用すると、メンバーがすべて指定された型であるオブジェクトリテラルを作成できます。 JavaScriptのほとんどのオブジェクトリテラルとは異なり、他のメンバーは許可されません。</target>
        </trans-unit>
        <trans-unit id="729d424ed3a9f5581bf724ec1a232c8c9d867325" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@enumerable(false)&lt;/code&gt; decorator here is a &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factory&lt;/a&gt;. When the &lt;code&gt;@enumerable(false)&lt;/code&gt; decorator is called, it modifies the &lt;code&gt;enumerable&lt;/code&gt; property of the property descriptor.</source>
          <target state="translated">ここの &lt;code&gt;@enumerable(false)&lt;/code&gt; デコレータは&lt;a href=&quot;#decorator-factories&quot;&gt;デコレータファクトリ&lt;/a&gt;です。 &lt;code&gt;@enumerable(false)&lt;/code&gt; デコレータが呼び出されると、プロパティ記述子の &lt;code&gt;enumerable&lt;/code&gt; プロパティが変更されます。</target>
        </trans-unit>
        <trans-unit id="2de9fb6766aab19221ef4c23a63fa9469054d5d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; decorator here is a &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factory&lt;/a&gt;. When &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; is called, it adds a metadata entry for the property using the &lt;code&gt;Reflect.metadata&lt;/code&gt; function from the &lt;code&gt;reflect-metadata&lt;/code&gt; library. When &lt;code&gt;getFormat&lt;/code&gt; is called, it reads the metadata value for the format.</source>
          <target state="translated">ここの &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; デコレータは、 &lt;a href=&quot;#decorator-factories&quot;&gt;デコレータファクトリ&lt;/a&gt;です。 &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; が呼び出されると、 &lt;code&gt;reflect-metadata&lt;/code&gt; ライブラリの &lt;code&gt;Reflect.metadata&lt;/code&gt; 関数を使用してプロパティのメタデータエントリが追加されます。 &lt;code&gt;getFormat&lt;/code&gt; が呼び出されると、フォーマットのメタデータ値を読み取ります。</target>
        </trans-unit>
        <trans-unit id="19665d13a52211c67417591d8dd41380ae77c57c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@required&lt;/code&gt; decorator adds a metadata entry that marks the parameter as required. The &lt;code&gt;@validate&lt;/code&gt; decorator then wraps the existing &lt;code&gt;greet&lt;/code&gt; method in a function that validates the arguments before invoking the original method.</source>
          <target state="translated">&lt;code&gt;@required&lt;/code&gt; デコレータは、パラメーターを必須としてマークするメタデータエントリを追加します。 &lt;code&gt;@validate&lt;/code&gt; デコレータは、元のメソッドを呼び出す前に引数を検証する関数で既存の &lt;code&gt;greet&lt;/code&gt; メソッドをラップします。</target>
        </trans-unit>
        <trans-unit id="9608e5840a63db8f977864c74884f8b6002ea58a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ConstructorParameters&amp;lt;T&amp;gt;&lt;/code&gt; type lets us extract all parameter types of a constructor function type. It produces a tuple type with all the parameter types (or the type &lt;code&gt;never&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is not a function).</source>
          <target state="translated">&lt;code&gt;ConstructorParameters&amp;lt;T&amp;gt;&lt;/code&gt; 型を使用すると、コンストラクター関数型のすべてのパラメーター型を抽出できます。 すべてのパラメーター型を含むタプル型を生成します（または &lt;code&gt;T&lt;/code&gt; が関数でない場合、型は生成されません）。</target>
        </trans-unit>
        <trans-unit id="e4d0252ee699e46769d5a622ff65ea37a30cb18c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; type now allows users to specify the yielded type, the returned type, and the type that &lt;code&gt;next&lt;/code&gt; can accept.</source>
          <target state="translated">&lt;code&gt;Iterator&lt;/code&gt; 型により、ユーザーは生成された型、返された型、および &lt;code&gt;next&lt;/code&gt; 受け入れることができる型を指定できます。</target>
        </trans-unit>
        <trans-unit id="7f41c5b21ee9dbf168d5ef4da903752f9e8d385c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Omit&lt;/code&gt; helper type</source>
          <target state="translated">&lt;code&gt;Omit&lt;/code&gt; ヘルパータイプ</target>
        </trans-unit>
        <trans-unit id="64a869fe08430ba63b8b26229df6154c69e8f8af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReadonlyArray&lt;/code&gt; type describes &lt;code&gt;Array&lt;/code&gt;s that can only be read from. Any variable with a reference to a &lt;code&gt;ReadonlyArray&lt;/code&gt; can&amp;rsquo;t add, remove, or replace any elements of the array.</source>
          <target state="translated">&lt;code&gt;ReadonlyArray&lt;/code&gt; 型は、読み取りのみが可能な &lt;code&gt;Array&lt;/code&gt; を記述します。 &lt;code&gt;ReadonlyArray&lt;/code&gt; への参照を持つ変数は、配列の要素を追加、削除、または置換できません。</target>
        </trans-unit>
        <trans-unit id="6368f607a56bb2c916a5b954c6dabe855ebf8589" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ThisType&amp;lt;T&amp;gt;&lt;/code&gt; marker interface is simply an empty interface declared in &lt;code&gt;lib.d.ts&lt;/code&gt;. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface.</source>
          <target state="translated">&lt;code&gt;ThisType&amp;lt;T&amp;gt;&lt;/code&gt; マーカーインターフェイスは、単に &lt;code&gt;lib.d.ts&lt;/code&gt; で宣言された空のインターフェイスです 。 オブジェクトリテラルのコンテキストタイプで認識される以外に、インターフェイスは空のインターフェイスのように動作します。</target>
        </trans-unit>
        <trans-unit id="eac98c87d76e62726c164fbe787eb6f8c34463c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amd-dependency&lt;/code&gt; directive can also have an optional &lt;code&gt;name&lt;/code&gt; property; this allows passing an optional name for an amd-dependency:</source>
          <target state="translated">&lt;code&gt;amd-dependency&lt;/code&gt; ディレクティブには、オプションの &lt;code&gt;name&lt;/code&gt; プロパティも含めることができます。 これにより、amd-dependencyにオプションの名前を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="5e27299aa8a8890f9cedcc0ab41fbf05f07fd29d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amd-module&lt;/code&gt; directive allows passing an optional module name to the compiler:</source>
          <target state="translated">&lt;code&gt;amd-module&lt;/code&gt; ディレクティブを使用すると、オプションのモジュール名をコンパイラーに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="a057b54c00069469116e2e7ce7d79e2e760309d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; type is a powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out of type checking during compilation. You might expect &lt;code&gt;Object&lt;/code&gt; to play a similar role, as it does in other languages. However, variables of type &lt;code&gt;Object&lt;/code&gt; only allow you to assign any value to them. You can&amp;rsquo;t call arbitrary methods on them, even ones that actually exist:</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; タイプは、既存のJavaScriptを使用する強力な方法であり、コンパイル中にタイプチェックを徐々にオプトインおよびオプトアウトできます。 他の言語と同じように、 &lt;code&gt;Object&lt;/code&gt; が同様の役割を果たすことを期待するかもしれません。 ただし、 &lt;code&gt;Object&lt;/code&gt; 型の変数では、値を割り当てることしかできません。 実際に存在するものであっても、それらに対して任意のメソッドを呼び出すことはできません。</target>
        </trans-unit>
        <trans-unit id="c0017d222210d0ddb4e497a93705b0979da8a1a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; type is also handy if you know some part of the type, but perhaps not all of it. For example, you may have an array but the array has a mix of different types:</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; タイプは、タイプの一部を知っている場合にも便利ですが、おそらくすべてではありません。 たとえば、配列はありますが、配列にはさまざまなタイプが混在しています。</target>
        </trans-unit>
        <trans-unit id="3e134f2fc8f2da81e48dedae85eec0c1c0994e99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 演算子</target>
        </trans-unit>
        <trans-unit id="a3c73e06a99fdb1de9fb8c344fa7c098a7a03b56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; operator is available in both &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files, and is identical in behavior to the angle-bracket type assertion style.</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 演算子は &lt;code&gt;.tsx&lt;/code&gt; ファイルと.tsxファイルの両方で使用でき、アングルブラケットタイプのアサーションスタイルと動作が同じです。</target>
        </trans-unit>
        <trans-unit id="a3a92cff5154e72c024dab414b5c117b995405f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exclude&lt;/code&gt; list does not support wilcards. It must simply be a list of files and/or directories.</source>
          <target state="translated">&lt;code&gt;exclude&lt;/code&gt; リストはウィルカードをサポートしていません。 単にファイルやディレクトリのリストでなければなりません。</target>
        </trans-unit>
        <trans-unit id="c3af89dee69149756441c4182df39cc8f0c3f4db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export =&lt;/code&gt; syntax specifies a single object that is exported from the module. This can be a class, interface, namespace, function, or enum.</source>
          <target state="translated">&lt;code&gt;export =&lt;/code&gt; 構文は、モジュールからエクスポートされる単一のオブジェクトを指定します。 これは、クラス、インターフェース、名前空間、関数、または列挙型にすることができます。</target>
        </trans-unit>
        <trans-unit id="17738861fda178b7ad88eea31d19aa3f7764605b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; clause of a class previously required a type reference to be specified. It now accepts an expression optionally followed by a type argument list. The type of the expression must be a constructor function type with at least one construct signature that has the same number of type parameters as the number of type arguments specified in the &lt;code&gt;extends&lt;/code&gt; clause. The return type of the matching construct signature(s) is the base type from which the class instance type inherits. Effectively, this allows both real classes and &amp;ldquo;class-like&amp;rdquo; expressions to be specified in the &lt;code&gt;extends&lt;/code&gt; clause.</source>
          <target state="translated">クラスの &lt;code&gt;extends&lt;/code&gt; 節では、以前に型参照を指定する必要がありました。 オプションで式引数リストが後に続く式を受け入れるようになりました。 式の型は、 &lt;code&gt;extends&lt;/code&gt; 句で指定された型引数の数と同じ数の型パラメーターを持つ少なくとも1つの構成シグネチャを持つコンストラクター関数型でなければなりません。 一致するコンストラクトシグネチャの戻り値の型は、クラスインスタンスの型が継承するベース型です。 事実上、これにより、実際のクラスと「クラスのような」式の両方を &lt;code&gt;extends&lt;/code&gt; 節で指定できます。</target>
        </trans-unit>
        <trans-unit id="ba2b01f6262a247dc48cefc8edd8183caa3b6800" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; is a top-level property in &lt;code&gt;tsconfig.json&lt;/code&gt; (alongside &lt;code&gt;compilerOptions&lt;/code&gt;, &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, and &lt;code&gt;exclude&lt;/code&gt;). &lt;code&gt;extends&lt;/code&gt;&amp;rsquo; value is a string containing a path to another configuration file to inherit from. The path may use Node.js style resolution.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; は、 &lt;code&gt;tsconfig.json&lt;/code&gt; の最上位プロパティです （ &lt;code&gt;compilerOptions&lt;/code&gt; 、 &lt;code&gt;files&lt;/code&gt; 、 &lt;code&gt;include&lt;/code&gt; 、 &lt;code&gt;exclude&lt;/code&gt; とともに）。 &lt;code&gt;extends&lt;/code&gt; '値は、継承する別の構成ファイルへのパスを含む文字列です。 パスはNode.jsスタイルの解像度を使用する場合があります。</target>
        </trans-unit>
        <trans-unit id="3017f557a2f328b58256e1eb412ef2360a4c4d18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for-await-of&lt;/code&gt; Statement</source>
          <target state="translated">&lt;code&gt;for-await-of&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="070a2aede6e683916dcd05d3af0a560d4036508a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for..await..of&lt;/code&gt; statement is only legal within an Async Function or Async Generator.</source>
          <target state="translated">&lt;code&gt;for..await..of&lt;/code&gt; ステートメントは、Async FunctionまたはAsync Generator内でのみ有効です。</target>
        </trans-unit>
        <trans-unit id="c1d7afbee8b4e917fda3b9d2fe2dbda01149f13f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getWidget&lt;/code&gt; function accepts a number and returns a Widget, or accepts a string and returns a Widget array.</source>
          <target state="translated">&lt;code&gt;getWidget&lt;/code&gt; 関数は、数値を受け入れてウィジェットを返すか、文字列を受け入れてウィジェット配列を返します。</target>
        </trans-unit>
        <trans-unit id="b90a2540458db7fb3aef294d8c4559c6aab9f51d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;greeter&lt;/code&gt; object can log to a file or display an alert. You can provide LogOptions to &lt;code&gt;.log(...)&lt;/code&gt; and alert options to &lt;code&gt;.alert(...)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;greeter&lt;/code&gt; オブジェクトは、ファイルにログを記録したり、アラートを表示したりできます。 LogOptionsを &lt;code&gt;.log(...)&lt;/code&gt; に 、アラートオプションを &lt;code&gt;.alert(...)&lt;/code&gt; に提供できます。</target>
        </trans-unit>
        <trans-unit id="21c39d544da86c80cc2e6b131693af3e027fdc76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in&lt;/code&gt; operator now acts as a narrowing expression for types.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 演算子は、型の絞り込み式として機能するようになりました。</target>
        </trans-unit>
        <trans-unit id="e1dd9f41eb7331354f03e6ddd8b1c9f2a64fbffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;length&lt;/code&gt; property of a tuple type with optional elements is a union of numeric literal types representing the possible lengths. For example, the type of the &lt;code&gt;length&lt;/code&gt; property in the tuple type &lt;code&gt;[number, string?, boolean?]&lt;/code&gt; is &lt;code&gt;1 | 2 | 3&lt;/code&gt;.</source>
          <target state="translated">オプションの要素を持つタプル型の &lt;code&gt;length&lt;/code&gt; プロパティは、可能な長さを表す数値リテラル型の結合です。 たとえば、タプルタイプ &lt;code&gt;[number, string?, boolean?]&lt;/code&gt; の &lt;code&gt;length&lt;/code&gt; プロパティのタイプは &lt;code&gt;1 | 2 | 3&lt;/code&gt; 2 | ３ 。</target>
        </trans-unit>
        <trans-unit id="b63b4343498819e73c1335f4802dd4ecef55b161" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="a9f3d4cb7613ec649d53f0d74013eb6fa4569ec9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type has the following characteristics:</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; タイプには次の特性があります。</target>
        </trans-unit>
        <trans-unit id="1e1a0ee3128b4be96a4b23dc31c8ff4663ecbf13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type is a subtype of, and assignable to, every type; however, &lt;em&gt;no&lt;/em&gt; type is a subtype of, or assignable to, &lt;code&gt;never&lt;/code&gt; (except &lt;code&gt;never&lt;/code&gt; itself). Even &lt;code&gt;any&lt;/code&gt; isn&amp;rsquo;t assignable to &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; タイプは、すべてのタイプのサブタイプであり、すべてのタイプに割り当て可能です。 ただし、 &lt;em&gt;決して&lt;/em&gt;タイプのサブタイプまたは割り当て可能なタイプはあり &lt;code&gt;never&lt;/code&gt; （それ自体を除く）。 &lt;code&gt;any&lt;/code&gt; でさえ &lt;code&gt;never&lt;/code&gt; に割り当てることはできません 。</target>
        </trans-unit>
        <trans-unit id="c32d1689d5690c0a84ea806da09f9080b457ae29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. For instance, &lt;code&gt;never&lt;/code&gt; is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns; Variables also acquire the type &lt;code&gt;never&lt;/code&gt; when narrowed by any type guards that can never be true.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; タイプは、発生しない値のタイプを表します。 たとえば、常に例外をスローする関数式または矢印関数式または戻り値の &lt;code&gt;never&lt;/code&gt; 式の戻り値の型は決してありません。 また、変数は、決して真にならないタイプガードによって絞り込まれたときに、 &lt;code&gt;never&lt;/code&gt; タイプを取得しません。</target>
        </trans-unit>
        <trans-unit id="415ee7bd886be7d1a3ff4410f75297e6f875a010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new.target&lt;/code&gt; meta-property is new syntax introduced in ES2015. When an instance of a constructor is created via &lt;code&gt;new&lt;/code&gt;, the value of &lt;code&gt;new.target&lt;/code&gt; is set to be a reference to the constructor function initially used to allocate the instance. If a function is called rather than constructed via &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;new.target&lt;/code&gt; is set to &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; メタプロパティは、ES2015で導入された新しい構文です。 &lt;code&gt;new&lt;/code&gt; を介してコンストラクターのインスタンスが作成されると、 &lt;code&gt;new.target&lt;/code&gt; の値は、インスタンスを割り当てるために最初に使用されるコンストラクター関数への参照になるように設定されます。 関数が &lt;code&gt;new&lt;/code&gt; を介して構築されるのではなく呼び出される場合、 &lt;code&gt;new.target&lt;/code&gt; は &lt;code&gt;undefined&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="19477c8f1cfa1e9c60356444eaaad7d0b42b9b97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; types are &lt;em&gt;not&lt;/em&gt; widened to &lt;code&gt;any&lt;/code&gt; in strict null checking mode.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; および &lt;code&gt;undefined&lt;/code&gt; 型は、厳密なnullチェックモードで&lt;em&gt;は&lt;/em&gt;拡張され&lt;em&gt;ません&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa34aa7759f5de219e7583fd1dd7f008d517869c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;null&lt;/code&gt; elimination is pretty obvious here, but you can use terser operators too:</source>
          <target state="translated">ここでは、 &lt;code&gt;null&lt;/code&gt; の除去はかなり明白ですが、terser演算子も使用できます。</target>
        </trans-unit>
        <trans-unit id="3b9cc299e7f4d8fe545c9d49c0fc120f67d07f88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; property of each reference can point to a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file, or to the config file itself (which may have any name).</source>
          <target state="translated">各参照の &lt;code&gt;path&lt;/code&gt; プロパティは、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを含むディレクトリ、または構成ファイル自体（任意の名前を持っている場合があります）を指すことができます。</target>
        </trans-unit>
        <trans-unit id="c5b3e36b4b2dc53fe86b3370909ee5fca3f8d695" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;preserve&lt;/code&gt; mode will keep JSX expressions as part of the output to be further consumed by another transform step. &lt;em&gt;Additionally the output will have a &lt;code&gt;.jsx&lt;/code&gt; file extension.&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;preserve&lt;/code&gt; モードでは、JSX式が出力の一部として保持され、別の変換ステップでさらに使用されます。 &lt;em&gt;さらに、出力には &lt;code&gt;.jsx&lt;/code&gt; ファイル拡張子が付きます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="854b44746f0abc418eff6be7c3fdd54bb19efc1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;protected&lt;/code&gt; modifier acts much like the &lt;code&gt;private&lt;/code&gt; modifier with the exception that members declared &lt;code&gt;protected&lt;/code&gt; can also be accessed within deriving classes. For example,</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; 修飾子は &lt;code&gt;private&lt;/code&gt; 修飾子とほとんど同じように機能しますが、 &lt;code&gt;protected&lt;/code&gt; と宣言されたメンバーは派生クラス内でもアクセスできます。 例えば、</target>
        </trans-unit>
        <trans-unit id="f60b5b9402d0bcc5b53cc9b4ebead84ff4399b9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react&lt;/code&gt; mode will emit &lt;code&gt;React.createElement&lt;/code&gt;, does not need to go through a JSX transformation before use, and the output will have a &lt;code&gt;.js&lt;/code&gt; file extension.</source>
          <target state="translated">&lt;code&gt;react&lt;/code&gt; モードは &lt;code&gt;React.createElement&lt;/code&gt; を出力し、使用する前にJSX変換を行う必要はなく、出力には &lt;code&gt;.js&lt;/code&gt; ファイル拡張子が付きます。</target>
        </trans-unit>
        <trans-unit id="731bfb54c9c710c3fddba0d525348937d618334a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; properties will appear with correct types on all components</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; および &lt;code&gt;key&lt;/code&gt; プロパティは、すべてのコンポーネントで正しいタイプで表示されます</target>
        </trans-unit>
        <trans-unit id="3ff4b0ed4771c56a90177b8d4ff4bd3f592871c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; property is correctly disallowed on instances of Stateless Function components</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; プロパティは、ステートレス関数コンポーネントのインスタンスで正しく許可されていません</target>
        </trans-unit>
        <trans-unit id="afd948bd24859b80dd2610380a6c20a8cd87a044" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rootDir&lt;/code&gt; setting, if not explicitly set, defaults to the directory containing the &lt;code&gt;tsconfig&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;rootDir&lt;/code&gt; 設定は、明示的に設定されていない場合、 &lt;code&gt;tsconfig&lt;/code&gt; ファイルを含むディレクトリがデフォルトになります</target>
        </trans-unit>
        <trans-unit id="45854eb3beba23a865f9cbaa14a544abf02a43ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; option (allowing users to switch out of &lt;code&gt;es5&lt;/code&gt; to &lt;code&gt;es3&lt;/code&gt;, &lt;code&gt;es2015&lt;/code&gt;, &lt;code&gt;esnext&lt;/code&gt;, etc.)</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; オプション（ユーザーが &lt;code&gt;es5&lt;/code&gt; から &lt;code&gt;es3&lt;/code&gt; 、 &lt;code&gt;es2015&lt;/code&gt; 、 &lt;code&gt;esnext&lt;/code&gt; などに切り替えることを許可します）</target>
        </trans-unit>
        <trans-unit id="13c27e388b6d0efef978313ee87f8dcb0b62e5dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; type is also useful with intersection types in describing libraries (e.g. Ember.js) that use mixin-style patterns to describe inheritance:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; タイプは、継承を記述するためにmixinスタイルのパターンを使用するライブラリ（Ember.jsなど）を記述する交差タイプでも役立ちます。</target>
        </trans-unit>
        <trans-unit id="6a29d4a5cece065318dd327e82552a8345a8bff7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useDefineForClassFields&lt;/code&gt; Flag and The &lt;code&gt;declare&lt;/code&gt; Property Modifier</source>
          <target state="translated">&lt;code&gt;useDefineForClassFields&lt;/code&gt; フラグと &lt;code&gt;declare&lt;/code&gt; プロパティ修飾子</target>
        </trans-unit>
        <trans-unit id="787315c92fdd75d5b219d459cc175e222f5c560e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Property Descriptor&lt;/em&gt; for the member.</source>
          <target state="translated">メンバーの&lt;em&gt;プロパティ記述子&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="7230f5ad07f661a74fc222478036dbea6b5acfa1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;nullish coalescing operator&lt;/em&gt; is another upcoming ECMAScript feature that goes hand-in-hand with optional chaining, and which our team has been involved with championing in TC39.</source>
          <target state="translated">&lt;em&gt;nullishの合体演算子&lt;/em&gt;は、ECMAScriptのもう1つの機能で、オプションのチェーンと連動しており、私たちのチームはTC39でのチャンピオンシップに関与しています。</target>
        </trans-unit>
        <trans-unit id="ffd20aedc2df50b541f11314e29e7f1054d730a5" translate="yes" xml:space="preserve">
          <source>The Async Iteration introduces an &lt;code&gt;AsyncIterator&lt;/code&gt;, which is similar to &lt;code&gt;Iterator&lt;/code&gt;. The difference lies in the fact that the &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;throw&lt;/code&gt; methods of an &lt;code&gt;AsyncIterator&lt;/code&gt; return a &lt;code&gt;Promise&lt;/code&gt; for the iteration result, rather than the result itself. This allows the caller to enlist in an asynchronous notification for the time at which the &lt;code&gt;AsyncIterator&lt;/code&gt; has advanced to the point of yielding a value. An &lt;code&gt;AsyncIterator&lt;/code&gt; has the following shape:</source>
          <target state="translated">Async Iterationは、 &lt;code&gt;Iterator&lt;/code&gt; に似た &lt;code&gt;AsyncIterator&lt;/code&gt; を導入します。 違いは、 &lt;code&gt;AsyncIterator&lt;/code&gt; の &lt;code&gt;next&lt;/code&gt; 、 &lt;code&gt;return&lt;/code&gt; 、および &lt;code&gt;throw&lt;/code&gt; メソッドが、結果自体ではなく、反復結果の &lt;code&gt;Promise&lt;/code&gt; を返すという事実にあります。 これにより、呼び出し元は、 &lt;code&gt;AsyncIterator&lt;/code&gt; が値を生成する時点まで進んだ時点で非同期通知に参加できます。 &lt;code&gt;AsyncIterator&lt;/code&gt; の形状は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="21db3b675c232e8c920fc5cc57777d2bb7e6f2db" translate="yes" xml:space="preserve">
          <source>The Examples</source>
          <target state="translated">例</target>
        </trans-unit>
        <trans-unit id="ae6a763c1fb39d689bcd8262575ee2c673da8154" translate="yes" xml:space="preserve">
          <source>The Impact of ES6 on Module Call Signatures</source>
          <target state="translated">ES6 のモジュールコールシグネチャへの影響</target>
        </trans-unit>
        <trans-unit id="4de6669622cba77a38976c0164e1dded39f35909" translate="yes" xml:space="preserve">
          <source>The Impact of ES6 on Module Plugins</source>
          <target state="translated">ES6のモジュールプラグインへの影響</target>
        </trans-unit>
        <trans-unit id="a90186b2913ce2a03f025ed1147a0c7a6b54234e" translate="yes" xml:space="preserve">
          <source>The Iterator protocol also defines the target of some of the ES2015 features like &lt;code&gt;for..of&lt;/code&gt; and spread operator and the array rest in destructuring assignmnets.</source>
          <target state="translated">Iteratorプロトコルは、 &lt;code&gt;for..of&lt;/code&gt; やspread演算子などのES2015機能の一部のターゲットも定義し、assignmnetsを破壊する際に配列が残ります。</target>
        </trans-unit>
        <trans-unit id="e2e893d7917d362f27f157a05f677c2dd16c5bb9" translate="yes" xml:space="preserve">
          <source>The JSX result type</source>
          <target state="translated">JSXの結果型</target>
        </trans-unit>
        <trans-unit id="c3dc7b38b486965f74bd526d650143ae6a37e3aa" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler has a set of additional flags to &lt;em&gt;inform&lt;/em&gt; the compiler of transformations that are expected to happen to the sources to generate the final output.</source>
          <target state="translated">TypeScriptコンパイラには、最終出力を生成するためにソースで発生すると予想される変換をコンパイラに&lt;em&gt;通知&lt;/em&gt;するための追加フラグのセットがあります。</target>
        </trans-unit>
        <trans-unit id="bb370c8d075071406b52f5ac647fa7c9d121cf5a" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler supports the declaration of such mappings using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property in &lt;code&gt;tsconfig.json&lt;/code&gt; files.</source>
          <target state="translated">TypeScriptコンパイラは、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルの &lt;code&gt;&quot;paths&quot;&lt;/code&gt; プロパティを使用して、このようなマッピングの宣言をサポートしています。</target>
        </trans-unit>
        <trans-unit id="099c380e43d8e6d4992539e165d15f16ea81d572" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler supports the declaration of such mappings using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property in &lt;code&gt;tsconfig.json&lt;/code&gt; files. Here is an example for how to specify the &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property for &lt;code&gt;jquery&lt;/code&gt;.</source>
          <target state="translated">TypeScriptコンパイラは、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルの &lt;code&gt;&quot;paths&quot;&lt;/code&gt; プロパティを使用して、このようなマッピングの宣言をサポートしています。 &lt;code&gt;jquery&lt;/code&gt; の &lt;code&gt;&quot;paths&quot;&lt;/code&gt; プロパティを指定する方法の例を次に示します。</target>
        </trans-unit>
        <trans-unit id="bdf835f0a2221bc2f82e0e151055988a09c9c5cd" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler will inject design-time type information using the &lt;code&gt;@Reflect.metadata&lt;/code&gt; decorator. You could consider it the equivalent of the following TypeScript:</source>
          <target state="translated">TypeScriptコンパイラーは、 &lt;code&gt;@Reflect.metadata&lt;/code&gt; デコレーターを使用して設計時の型情報を挿入します。 次のTypeScriptに相当すると考えることができます。</target>
        </trans-unit>
        <trans-unit id="7a2537884fb59ac700d2d4b7e0b4045bf44ae0d3" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler will transpile for..of arrays to idiomatic ES3/ES5 JavaScript when targeting those versions:</source>
          <target state="translated">TypeScript コンパイラは、これらのバージョンをターゲットにした場合、配列の for...of 配列をイディオマティックな ES3ES5 JavaScript にトランスパイルします。</target>
        </trans-unit>
        <trans-unit id="49b307cc503023513bc14bb0a27ac57aa8f44ce9" translate="yes" xml:space="preserve">
          <source>The TypeScript playground has received a much-needed refresh with handy new functionality! The new playground is largely a fork of &lt;a href=&quot;https://github.com/agentcooper&quot;&gt;Artem Tyurin&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;https://github.com/agentcooper/typescript-play&quot;&gt;TypeScript playground&lt;/a&gt; which community members have been using more and more. We owe Artem a big thanks for helping out here!</source>
          <target state="translated">TypeScriptプレイグラウンドは、便利な新機能を備えた非常に必要な更新を受けました！ 新しい遊び場は、主にコミュニティのメンバーがますます使用している&lt;a href=&quot;https://github.com/agentcooper&quot;&gt;Artem Tyurin&lt;/a&gt;の&lt;a href=&quot;https://github.com/agentcooper/typescript-play&quot;&gt;TypeScript遊び場&lt;/a&gt;の分岐点です。 ここで手伝ってくれたArtemに大いに感謝します！</target>
        </trans-unit>
        <trans-unit id="2d3804fe18093dd09b93d92b9795e81df41c7624" translate="yes" xml:space="preserve">
          <source>The TypeSript compiler emits a few helpers like &lt;code&gt;__extends&lt;/code&gt; when needed. The helpers are emitted in every file they are referenced in. If you want to consolidate all helpers in one place, or override the default behavior, use &lt;code&gt;--noEmitHelpers&lt;/code&gt; to instructs the compiler not to emit them.</source>
          <target state="translated">TypeSriptコンパイラは、必要なときに &lt;code&gt;__extends&lt;/code&gt; のようなヘルパーをいくつか出力します。 ヘルパーは、それらが参照されるすべてのファイルで &lt;code&gt;--noEmitHelpers&lt;/code&gt; れます。すべてのヘルパーを1か所に統合​​する場合、またはデフォルトの動作をオーバーライドする場合は、 -noEmitHelpersを使用してコンパイラに発行しないよう指示します。</target>
        </trans-unit>
        <trans-unit id="bae3a8ac10b29ef5dcadb732d1773d84824f8b64" translate="yes" xml:space="preserve">
          <source>The above code will result in an error since you cannot divide a string by a number. The output, when using the &lt;code&gt;preserve&lt;/code&gt; option, looks like:</source>
          <target state="translated">上記のコードでは、文字列を数値で除算できないため、エラーが発生します。 &lt;code&gt;preserve&lt;/code&gt; オプションを使用した場合の出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="973342201d3a8b874193050ad2e2e03771fa9182" translate="yes" xml:space="preserve">
          <source>The above workaround will work as long as you have a common property between &lt;code&gt;squareOptions&lt;/code&gt; and &lt;code&gt;SquareConfig&lt;/code&gt;. In this example, it was the property &lt;code&gt;width&lt;/code&gt;. It will however, fail if the variable does not have any common object property. For example:</source>
          <target state="translated">上記の回避策は、 &lt;code&gt;squareOptions&lt;/code&gt; と &lt;code&gt;SquareConfig&lt;/code&gt; の間に共通のプロパティがある限り機能します。 この例では、プロパティ &lt;code&gt;width&lt;/code&gt; でした。 ただし、変数に共通のオブジェクトプロパティがない場合は失敗します。 例えば：</target>
        </trans-unit>
        <trans-unit id="977799dc5b2c7efb8ce07ce9dda596f71ce6d8c4" translate="yes" xml:space="preserve">
          <source>The act of introducing a new name in a more nested scope is called &lt;em&gt;shadowing&lt;/em&gt;. It is a bit of a double-edged sword in that it can introduce certain bugs on its own in the event of accidental shadowing, while also preventing certain bugs. For instance, imagine we had written our earlier &lt;code&gt;sumMatrix&lt;/code&gt; function using &lt;code&gt;let&lt;/code&gt; variables.</source>
          <target state="translated">よりネストされたスコープに新しい名前を導入する行為は、 &lt;em&gt;シャドーイング&lt;/em&gt;と呼ばれます。 偶発的なシャドーイングが発生した場合に特定のバグを発生させ、特定のバグを防止できるという点で、両刃の剣です。 たとえば、 &lt;code&gt;let&lt;/code&gt; 変数を使用して以前の &lt;code&gt;sumMatrix&lt;/code&gt; 関数を作成したとします。</target>
        </trans-unit>
        <trans-unit id="464744a1885e10900c594d16946298c68c765f22" translate="yes" xml:space="preserve">
          <source>The advantage of optional properties is that you can describe these possibly available properties while still also preventing use of properties that are not part of the interface. For example, had we mistyped the name of the &lt;code&gt;color&lt;/code&gt; property in &lt;code&gt;createSquare&lt;/code&gt;, we would get an error message letting us know:</source>
          <target state="translated">オプションのプロパティの利点は、これらの利用可能なプロパティを記述できると同時に、インターフェイスの一部ではないプロパティの使用を防止できることです。 たとえば、 &lt;code&gt;createSquare&lt;/code&gt; で &lt;code&gt;color&lt;/code&gt; プロパティの名前を誤って入力した場合 、次のことを知らせるエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="d900af77a95ccc3991b5cce004f6567adc959fc3" translate="yes" xml:space="preserve">
          <source>The alternative was to instead rewrite the code so that the language could analyze it, but this isn&amp;rsquo;t convenient.</source>
          <target state="translated">代わりに、言語が分析できるようにコードを代わりに書き直すことでしたが、これは便利ではありません。</target>
        </trans-unit>
        <trans-unit id="d7545e67ed0bf67fd6d8743f1b478c94a21cbf7b" translate="yes" xml:space="preserve">
          <source>The answer is to supply multiple function types for the same function as a list of overloads. This list is what the compiler will use to resolve function calls. Let&amp;rsquo;s create a list of overloads that describe what our &lt;code&gt;pickCard&lt;/code&gt; accepts and what it returns.</source>
          <target state="translated">答えは、オーバーロードのリストとして同じ関数に複数の関数タイプを提供することです。 このリストは、関数呼び出しを解決するためにコンパイラが使用するものです。 &lt;code&gt;pickCard&lt;/code&gt; が受け入れるものと返すものを記述するオーバーロードのリストを作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="d87ac95450f1e8dcfc394fcd59a9e3ae182cfb79" translate="yes" xml:space="preserve">
          <source>The argument can be a file path to a valid JSON configuration file, or a directory path to a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">引数には、有効なJSON構成ファイルへのファイルパス、または &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを含むディレクトリへのディレクトリパスを指定できます。</target>
        </trans-unit>
        <trans-unit id="8f45e116d7cf081dd6a210ca6310037f2aa66724" translate="yes" xml:space="preserve">
          <source>The as operator</source>
          <target state="translated">as 演算子</target>
        </trans-unit>
        <trans-unit id="9c9fa406955dab922d6a11f631e81ab8facc3e92" translate="yes" xml:space="preserve">
          <source>The basic rule for TypeScript&amp;rsquo;s structural type system is that &lt;code&gt;x&lt;/code&gt; is compatible with &lt;code&gt;y&lt;/code&gt; if &lt;code&gt;y&lt;/code&gt; has at least the same members as &lt;code&gt;x&lt;/code&gt;. For example:</source>
          <target state="translated">TypeScriptの構造型システムの基本的なルールは、 &lt;code&gt;y&lt;/code&gt; が少なくとも &lt;code&gt;x&lt;/code&gt; と同じメンバーを持っている場合、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;y&lt;/code&gt; と互換性があるということです。 例えば：</target>
        </trans-unit>
        <trans-unit id="0570ba37489d38960ce7e63c3dda6e93bf075660" translate="yes" xml:space="preserve">
          <source>The caveat is that string-initialized enums can&amp;rsquo;t be reverse-mapped to get the original enum member name. In other words, you can&amp;rsquo;t write &lt;code&gt;Colors[&quot;RED&quot;]&lt;/code&gt; to get the string &lt;code&gt;&quot;Red&quot;&lt;/code&gt;.</source>
          <target state="translated">注意点は、文字列で初期化された列挙型を逆マッピングして元の列挙型メンバー名を取得できないことです。 つまり、文字列 &lt;code&gt;&quot;Red&quot;&lt;/code&gt; を取得するために &lt;code&gt;Colors[&quot;RED&quot;]&lt;/code&gt; を書くことはできません。</target>
        </trans-unit>
        <trans-unit id="658cc1f5d6e87940c9b68d75f7a3216b7965fa8f" translate="yes" xml:space="preserve">
          <source>The character set of the input files.</source>
          <target state="translated">入力ファイルの文字セット。</target>
        </trans-unit>
        <trans-unit id="0d767851eecc9dbc5567854c546874153b473aac" translate="yes" xml:space="preserve">
          <source>The classification can be further customized by changing the font and color settings for the &lt;code&gt;VB XML&lt;/code&gt; color and font settings through &lt;code&gt;Tools&lt;/code&gt;-&amp;gt;&lt;code&gt;Options&lt;/code&gt;-&amp;gt;&lt;code&gt;Environment&lt;/code&gt;-&amp;gt;&lt;code&gt;Fonts and Colors&lt;/code&gt; page.</source>
          <target state="translated">[ &lt;code&gt;Tools&lt;/code&gt; -&amp;gt; [ &lt;code&gt;Options&lt;/code&gt; -&amp;gt; [ &lt;code&gt;Environment&lt;/code&gt; -&amp;gt; [ &lt;code&gt;Fonts and Colors&lt;/code&gt; ページで &lt;code&gt;VB XML&lt;/code&gt; の色とフォント設定のフォントと色の設定を変更することにより、分類をさらにカスタマイズできます。</target>
        </trans-unit>
        <trans-unit id="9e4361985e949137fdbecccf199cbcbfd26cb095" translate="yes" xml:space="preserve">
          <source>The code sample starts with the two classes that will act as our mixins. You can see each one is focused on a particular activity or capability. We&amp;rsquo;ll later mix these together to form a new class from both capabilities.</source>
          <target state="translated">コードサンプルは、ミックスインとして機能する2つのクラスから始まります。 それぞれが特定のアクティビティまたは機能に焦点を合わせていることがわかります。 後でこれらを混合して、両方の機能から新しいクラスを形成します。</target>
        </trans-unit>
        <trans-unit id="44bfd585b7b25dece832164d759523816acacef3" translate="yes" xml:space="preserve">
          <source>The comment pragma version may be used like so (in TypeScript 2.8):</source>
          <target state="translated">コメントプラグマのバージョンは、このように使うことができます (TypeScript 2.8では)。</target>
        </trans-unit>
        <trans-unit id="94d8762ed85cb39d474ef4b32596ce47c7f9f61a" translate="yes" xml:space="preserve">
          <source>The compiler can usually figure out the type of &lt;code&gt;this&lt;/code&gt; when it has some context to work with. When it doesn&amp;rsquo;t, you can explicitly specify the type of &lt;code&gt;this&lt;/code&gt; with &lt;code&gt;@this&lt;/code&gt;:</source>
          <target state="translated">コンパイラは通常、動作するコンテキストがある場合に &lt;code&gt;this&lt;/code&gt; タイプを判別できます。 そうでない場合、 &lt;code&gt;@this&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; でthisの型を明示的に指定できます：</target>
        </trans-unit>
        <trans-unit id="6ce225c2cdfc4fbbd52bf1bec496704ad8d2e300" translate="yes" xml:space="preserve">
          <source>The compiler checks that &lt;code&gt;manufacturer&lt;/code&gt; and &lt;code&gt;model&lt;/code&gt; are actually properties on &lt;code&gt;Car&lt;/code&gt;. The example introduces a couple of new type operators. First is &lt;code&gt;keyof T&lt;/code&gt;, the &lt;strong&gt;index type query operator&lt;/strong&gt;. For any type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;keyof T&lt;/code&gt; is the union of known, public property names of &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target state="translated">コンパイラは、 &lt;code&gt;manufacturer&lt;/code&gt; と &lt;code&gt;model&lt;/code&gt; が実際に &lt;code&gt;Car&lt;/code&gt; のプロパティであることを確認します。 この例では、いくつかの新しいタイプの演算子を紹介しています。 最初は、 &lt;strong&gt;インデックスタイプのクエリ演算子&lt;/strong&gt; &lt;code&gt;keyof T&lt;/code&gt; です。 任意のタイプ &lt;code&gt;T&lt;/code&gt; について、 &lt;code&gt;keyof T&lt;/code&gt; はTの既知のパブリックプロパティ名の結合です。 例えば：</target>
        </trans-unit>
        <trans-unit id="b90080efac3089f68bf9198051529fb93927ad2d" translate="yes" xml:space="preserve">
          <source>The compiler checks that variables are definitely assigned by performing &lt;em&gt;control flow based type analysis&lt;/em&gt;. See later for further details on this topic.</source>
          <target state="translated">コンパイラーは、 &lt;em&gt;制御フローベースの型分析を&lt;/em&gt;実行することにより、変数が確実に割り当てられていることを確認します。 このトピックの詳細については、後で参照してください。</target>
        </trans-unit>
        <trans-unit id="709255e2bfcdfd8723f3b039260e513f6811cfd9" translate="yes" xml:space="preserve">
          <source>The compiler detects whether each module is used in the emitted JavaScript. If a module identifier is only ever used as part of a type annotations and never as an expression, then no &lt;code&gt;require&lt;/code&gt; call is emitted for that module. This elision of unused references is a good performance optimization, and also allows for optional loading of those modules.</source>
          <target state="translated">コンパイラーは、発行されたJavaScriptで各モジュールが使用されているかどうかを検出します。 モジュール識別子が型注釈の一部としてのみ使用され、式として使用されない &lt;code&gt;require&lt;/code&gt; 、そのモジュールのrequire呼び出しは発行されません。 この未使用の参照の削除は、パフォーマンスの最適化に優れており、これらのモジュールのオプションのロードも可能にします。</target>
        </trans-unit>
        <trans-unit id="2ee05054ac8f1f0d957bb3db6c7d04411ad1e817" translate="yes" xml:space="preserve">
          <source>The compiler infers constructor functions based on this-property assignments, but you can make checking stricter and suggestions better if you add a &lt;code&gt;@constructor&lt;/code&gt; tag:</source>
          <target state="translated">コンパイラは、このプロパティの割り当てに基づいてコンストラクター関数を推測しますが、 &lt;code&gt;@constructor&lt;/code&gt; タグを追加すると、チェックと提案をより厳密にすることができます。</target>
        </trans-unit>
        <trans-unit id="af8cada3d73e6f631af13e152a9d5e9310d04109" translate="yes" xml:space="preserve">
          <source>The compiler performs a preprocessing pass on input files to resolve all triple-slash reference directives. During this process, additional files are added to the compilation.</source>
          <target state="translated">コンパイラは入力ファイルの前処理パスを実行して、すべてのトリプルスラッシュ参照ディレクティブを解決します。この処理の間に、追加のファイルがコンパイルに追加されます。</target>
        </trans-unit>
        <trans-unit id="e0152e415fb0baecefa82a34c08f802b9d756e5b" translate="yes" xml:space="preserve">
          <source>The compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:</source>
          <target state="translated">コンパイラは、ファイル内に存在する参照タグに基づいて出力ファイルを自動的に並べ替えます。また、各ファイルを個別に指定することもできます。</target>
        </trans-unit>
        <trans-unit id="51e223694a5a5e5b0c431a15c4a8fae647f211ab" translate="yes" xml:space="preserve">
          <source>The compiler will generate a simple &lt;code&gt;for&lt;/code&gt; loop for a &lt;code&gt;for..of&lt;/code&gt; loop, for instance:</source>
          <target state="translated">コンパイラーは、 &lt;code&gt;for..of&lt;/code&gt; ループの単純な &lt;code&gt;for&lt;/code&gt; ループを生成します。たとえば、次のとおりです。</target>
        </trans-unit>
        <trans-unit id="6a0d000ecdfc1359aa72dab512a544de23b44f6d" translate="yes" xml:space="preserve">
          <source>The compiler will now resolve &lt;code&gt;import messages from './#{locale}/messages'&lt;/code&gt; to &lt;code&gt;import messages from './zh/messages'&lt;/code&gt; for tooling purposes, allowing development in a locale agnostic manner without compromising design time support.</source>
          <target state="translated">コンパイラーは、ツール目的で &lt;code&gt;import messages from './#{locale}/messages'&lt;/code&gt; 解決して './zh/messages'から &lt;code&gt;import messages from './zh/messages'&lt;/code&gt; をインポートし、設計時サポートを損なうことなくロケールにとらわれない方法で開発できるようにします。</target>
        </trans-unit>
        <trans-unit id="dededb8a14ae234f8b00237dd4d7d5520b09190d" translate="yes" xml:space="preserve">
          <source>The compiler will try to find a &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and then a &lt;code&gt;.d.ts&lt;/code&gt; with the appropriate path. If a specific file could not be found, then the compiler will look for an &lt;em&gt;ambient module declaration&lt;/em&gt;. Recall that these need to be declared in a &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="translated">コンパイラは、適切なパスを持つ &lt;code&gt;.ts&lt;/code&gt; 、 &lt;code&gt;.tsx&lt;/code&gt; 、そして.d.tsを見つけようとします。 特定のファイルが見つからなかった場合、コンパイラは&lt;em&gt;アンビエントモジュール宣言&lt;/em&gt;を探し&lt;em&gt;ます&lt;/em&gt; 。 これらは &lt;code&gt;.d.ts&lt;/code&gt; ファイルで宣言する必要があることを思い出してください。</target>
        </trans-unit>
        <trans-unit id="0ba06dc9850414ee8093ec4891b1423ed7c4b5a5" translate="yes" xml:space="preserve">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file.</source>
          <target state="translated">ベースファイルの設定が最初に読み込まれ、次に継承する設定ファイルの設定が上書きされます。</target>
        </trans-unit>
        <trans-unit id="c7417a4c25a8da7c3b9339e33fd087465dbdf022" translate="yes" xml:space="preserve">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file. If a circularity is encountered, we report an error.</source>
          <target state="translated">ベースファイルの設定が最初に読み込まれ、次に継承する設定ファイルの設定が上書きされます。サーキュラリティが発生した場合はエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="47cd6d852a954030c68d9ed9204072b9f5e61ecf" translate="yes" xml:space="preserve">
          <source>The constructor of a mixin class (if any) must have a single rest parameter of type &lt;code&gt;any[]&lt;/code&gt; and must use the spread operator to pass those parameters as arguments in a &lt;code&gt;super(...args)&lt;/code&gt; call.</source>
          <target state="translated">mixinクラスのコンストラクター（存在する場合）は、 &lt;code&gt;any[]&lt;/code&gt; 型の単一のrestパラメーターが必要であり、スプレッド演算子を使用して、これらのパラメーターを &lt;code&gt;super(...args)&lt;/code&gt; 呼び出しの引数として渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="c957312c57684bb0a68bd0033e5121474de252b4" translate="yes" xml:space="preserve">
          <source>The core idea of the pattern is that the &lt;code&gt;import id = require(&quot;...&quot;)&lt;/code&gt; statement gives us access to the types exposed by the module. The module loader is invoked (through &lt;code&gt;require&lt;/code&gt;) dynamically, as shown in the &lt;code&gt;if&lt;/code&gt; blocks below. This leverages the reference-elision optimization so that the module is only loaded when needed. For this pattern to work, it&amp;rsquo;s important that the symbol defined via an &lt;code&gt;import&lt;/code&gt; is only used in type positions (i.e. never in a position that would be emitted into the JavaScript).</source>
          <target state="translated">このパターンの核となる考え方は、 &lt;code&gt;import id = require(&quot;...&quot;)&lt;/code&gt; ステートメントがモジュールによって公開されている型へのアクセスを提供するということです。 次の &lt;code&gt;if&lt;/code&gt; ブロックに示すように、モジュールローダーは（ &lt;code&gt;require&lt;/code&gt; を介して）動的に呼び出されます。 これは、参照省略の最適化を活用して、必要なときにのみモジュールがロードされるようにします。 このパターンが機能するためには、 &lt;code&gt;import&lt;/code&gt; を介して定義されたシンボルがタイプ位置でのみ使用される（つまり、JavaScriptに出力される位置では使用されない）ことが重要です。</target>
        </trans-unit>
        <trans-unit id="d0b027c450a1f923c0be026c0dfd8a83c77d2420" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;tsconfig.json&lt;/code&gt; would look like:</source>
          <target state="translated">対応する &lt;code&gt;tsconfig.json&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="7eeeab936d5101dbe33556330a8a2f0e148d5a0c" translate="yes" xml:space="preserve">
          <source>The declaration merge of &lt;code&gt;Animals&lt;/code&gt; in this example:</source>
          <target state="translated">この例の &lt;code&gt;Animals&lt;/code&gt; の宣言マージ：</target>
        </trans-unit>
        <trans-unit id="760e4e7cc5e42234f3bffea21b8ceac9a6ae4124" translate="yes" xml:space="preserve">
          <source>The default behavior for the TypeScript compiler is to still emit .js files if there were type errors (for example, an attempt to assign a &lt;code&gt;string&lt;/code&gt; to a &lt;code&gt;number&lt;/code&gt;). This can be undesirable on build servers or other scenarios where only output from a &amp;ldquo;clean&amp;rdquo; build is desired. The new flag &lt;code&gt;noEmitOnError&lt;/code&gt; prevents the compiler from emitting .js code if there were any errors.</source>
          <target state="translated">TypeScriptコンパイラのデフォルトの動作では、タイプエラーが発生した場合でも.jsファイルを出力します（たとえば、 &lt;code&gt;string&lt;/code&gt; を &lt;code&gt;number&lt;/code&gt; に割り当てようとした場合 ）。 これは、ビルドサーバーまたは「クリーンな」ビルドからの出力のみが必要な他のシナリオでは望ましくない場合があります。 新しいフラグ &lt;code&gt;noEmitOnError&lt;/code&gt; は、エラーが発生した場合にコンパイラが.jsコードを発行するのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="ae976d467a2e0b5f5be1f916e987a9fd2c7d4327" translate="yes" xml:space="preserve">
          <source>The default-ed properties are inferred from the &lt;code&gt;defaultProps&lt;/code&gt; property type. If an explicit type annotation is added, e.g. &lt;code&gt;static defaultProps: Partial&amp;lt;Props&amp;gt;;&lt;/code&gt; the compiler will not be able to identify which properties have defaults (since the type of &lt;code&gt;defaultProps&lt;/code&gt; include all properties of &lt;code&gt;Props&lt;/code&gt;).</source>
          <target state="translated">デフォルトのプロパティは、 &lt;code&gt;defaultProps&lt;/code&gt; プロパティタイプから推測されます。 明示的な型注釈が追加された場合、たとえば、 &lt;code&gt;static defaultProps: Partial&amp;lt;Props&amp;gt;;&lt;/code&gt; コンパイラーは、どのプロパティーにデフォルトがあるかを識別できません（ &lt;code&gt;defaultProps&lt;/code&gt; のタイプには &lt;code&gt;Props&lt;/code&gt; のすべてのプロパティーが含まれるため）。</target>
        </trans-unit>
        <trans-unit id="d1317688dfc3d42fd33a72fadf087e54e0802397" translate="yes" xml:space="preserve">
          <source>The definite assignment assertion is a feature that allows a &lt;code&gt;!&lt;/code&gt; to be placed after instance property and variable declarations to relay to TypeScript that a variable is indeed assigned for all intents and purposes, even if TypeScript&amp;rsquo;s analyses cannot detect so.</source>
          <target state="translated">明確な割り当てアサーションは、 &lt;code&gt;!&lt;/code&gt; インスタンスプロパティと変数宣言の後に配置して、TypeScriptの分析で検出できない場合でも、変数が実際にすべての意図と目的に割り当てられていることをTypeScriptに伝えます。</target>
        </trans-unit>
        <trans-unit id="5951769f90ddf6ef86202b76f38e00c40c68074c" translate="yes" xml:space="preserve">
          <source>The distributive property of conditional types can conveniently be used to &lt;em&gt;filter&lt;/em&gt; union types:</source>
          <target state="translated">条件型の分散プロパティは、ユニオン型を&lt;em&gt;フィルタリング&lt;/em&gt;するために便利に使用できます。</target>
        </trans-unit>
        <trans-unit id="6701107cdd8245fa22b60649bbf93c094765f72c" translate="yes" xml:space="preserve">
          <source>The dual of this is &lt;em&gt;indexed access types&lt;/em&gt;, also called &lt;em&gt;lookup types&lt;/em&gt;. Syntactically, they look exactly like an element access, but are written as types:</source>
          <target state="translated">これの二重は、 &lt;em&gt;ルックアップタイプ&lt;/em&gt;とも呼ばれる&lt;em&gt;インデックス付きアクセス&lt;/em&gt; &lt;em&gt;タイプ&lt;/em&gt;です。 構文的には、要素アクセスとまったく同じように見えますが、型として記述されています。</target>
        </trans-unit>
        <trans-unit id="f96a7965741a28dd3d210266390299a4c235d519" translate="yes" xml:space="preserve">
          <source>The easiest way to remember whether to use &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; is to ask whether you&amp;rsquo;re using it on a variable or a property. Variables use &lt;code&gt;const&lt;/code&gt; whereas properties use &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; を使用するか &lt;code&gt;const&lt;/code&gt; を使用するかを覚える最も簡単な方法は、変数で使用するのか、プロパティで使用するのかを尋ねることです。 変数は &lt;code&gt;const&lt;/code&gt; を使用し &lt;code&gt;readonly&lt;/code&gt; 、プロパティはreadonlyを使用します 。</target>
        </trans-unit>
        <trans-unit id="77d40241cfaf8a84ae6745611b0a0b930c4e9b68" translate="yes" xml:space="preserve">
          <source>The easiest way to see how interfaces work is to start with a simple example:</source>
          <target state="translated">インターフェイスがどのように動作するかを理解する最も簡単な方法は、簡単な例から始めることです。</target>
        </trans-unit>
        <trans-unit id="36fb664df37642968e73b47232d19c28eafce856" translate="yes" xml:space="preserve">
          <source>The element attribute type is used to type check the attributes in the JSX. Optional and required properties are supported.</source>
          <target state="translated">要素属性型は、JSXの属性をタイプチェックするために使用されます。オプションのプロパティと必須のプロパティがサポートされています。</target>
        </trans-unit>
        <trans-unit id="f2cb300f34919973f86bda71fcf4a1681bebb7a8" translate="yes" xml:space="preserve">
          <source>The element instance type is interesting because it must be assignable to &lt;code&gt;JSX.ElementClass&lt;/code&gt; or it will result in an error. By default &lt;code&gt;JSX.ElementClass&lt;/code&gt; is &lt;code&gt;{}&lt;/code&gt;, but it can be augmented to limit the use of JSX to only those types that conform to the proper interface.</source>
          <target state="translated">エレメントインスタンスタイプは、 &lt;code&gt;JSX.ElementClass&lt;/code&gt; に割り当て可能である必要があります。そうでない場合、エラーになります。 デフォルトでは、 &lt;code&gt;JSX.ElementClass&lt;/code&gt; は &lt;code&gt;{}&lt;/code&gt; ですが、JSXの使用を適切なインターフェースに適合するタイプのみに制限するように拡張できます。</target>
        </trans-unit>
        <trans-unit id="0d4e3187b0c64f392d45e58c9337389c5cb0b1e1" translate="yes" xml:space="preserve">
          <source>The ellipsis is also used in the type of the function with rest parameters:</source>
          <target state="translated">楕円は、残りのパラメータを持つ関数の型でも使用されています。</target>
        </trans-unit>
        <trans-unit id="d715b5fd0797da50802172129520b9973d9f2c77" translate="yes" xml:space="preserve">
          <source>The enum member is initialized with a constant enum expression. A constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time. An expression is a constant enum expression if it is:</source>
          <target state="translated">enum メンバは定数 enum 式で初期化されます。constant enum式は、コンパイル時に完全に評価できるTypeScript式のサブセットです。式は、以下の場合には定数enum式となります。</target>
        </trans-unit>
        <trans-unit id="d313bf4ae6661330b1b3ab28e64f56b35e82367c" translate="yes" xml:space="preserve">
          <source>The exact factory function used by the &lt;code&gt;jsx: react&lt;/code&gt; compiler option is configurable. It may be set using either the &lt;code&gt;jsxFactory&lt;/code&gt; command line option, or an inline &lt;code&gt;@jsx&lt;/code&gt; comment pragma to set it on a per-file basis. For example, if you set &lt;code&gt;jsxFactory&lt;/code&gt; to &lt;code&gt;createElement&lt;/code&gt;, &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; will emit as &lt;code&gt;createElement(&quot;div&quot;)&lt;/code&gt; instead of &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;jsx: react&lt;/code&gt; コンパイラオプションで使用される正確なファクトリ関数は構成可能です。 &lt;code&gt;jsxFactory&lt;/code&gt; コマンドラインオプション、またはファイルごとに設定するインライン &lt;code&gt;@jsx&lt;/code&gt; コメントプラグマを使用して設定できます。 たとえば、 &lt;code&gt;jsxFactory&lt;/code&gt; を &lt;code&gt;createElement&lt;/code&gt; に設定すると 、 &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; は &lt;code&gt;createElement(&quot;div&quot;)&lt;/code&gt; ではなく &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="be983dcb009cbaef6ee420c2ca6026b157bd7e0a" translate="yes" xml:space="preserve">
          <source>The example also shows how to override methods in the base class with methods that are specialized for the subclass. Here both &lt;code&gt;Snake&lt;/code&gt; and &lt;code&gt;Horse&lt;/code&gt; create a &lt;code&gt;move&lt;/code&gt; method that overrides the &lt;code&gt;move&lt;/code&gt; from &lt;code&gt;Animal&lt;/code&gt;, giving it functionality specific to each class. Note that even though &lt;code&gt;tom&lt;/code&gt; is declared as an &lt;code&gt;Animal&lt;/code&gt;, since its value is a &lt;code&gt;Horse&lt;/code&gt;, calling &lt;code&gt;tom.move(34)&lt;/code&gt; will call the overriding method in &lt;code&gt;Horse&lt;/code&gt;:</source>
          <target state="translated">この例では、サブクラス専用のメソッドで基本クラスのメソッドをオーバーライドする方法も示しています。 ここでは、 &lt;code&gt;Snake&lt;/code&gt; と &lt;code&gt;Horse&lt;/code&gt; の両方が &lt;code&gt;Animal&lt;/code&gt; からの &lt;code&gt;move&lt;/code&gt; をオーバーライドする &lt;code&gt;move&lt;/code&gt; メソッドを作成し、各クラスに固有の機能を提供します。 &lt;code&gt;tom&lt;/code&gt; は &lt;code&gt;Animal&lt;/code&gt; として宣言されていますが、その値は &lt;code&gt;Horse&lt;/code&gt; であるため 、 &lt;code&gt;tom.move(34)&lt;/code&gt; を呼び出すと &lt;code&gt;Horse&lt;/code&gt; のオーバーライドメソッドが呼び出されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9309c4e757aa256b16a0bad58b5e33a98c76cbc2" translate="yes" xml:space="preserve">
          <source>The example uses a nested function here because the compiler can&amp;rsquo;t eliminate nulls inside a nested function (except immediately-invoked function expressions). That&amp;rsquo;s because it can&amp;rsquo;t track all calls to the nested function, especially if you return it from the outer function. Without knowing where the function is called, it can&amp;rsquo;t know what the type of &lt;code&gt;name&lt;/code&gt; will be at the time the body executes.</source>
          <target state="translated">この例では、コンパイラがネストされた関数内のnullを削除できないため、ネストされた関数を使用します（すぐに呼び出される関数式を除く）。 これは、ネストされた関数へのすべての呼び出しを追跡できないためです。特に、外部関数から呼び出しを返す場合はそうです。 関数がどこで呼び出されるかがわからなければ、ボディが実行されるときに &lt;code&gt;name&lt;/code&gt; のタイプがどうなるかを知ることはできません。</target>
        </trans-unit>
        <trans-unit id="2521d541b8280fcd0c447ab0918ebaaed9adf402" translate="yes" xml:space="preserve">
          <source>The expression for the accessor decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">アクセサデコレータの式は、実行時に関数として呼び出され、以下の3つの引数を持ちます。</target>
        </trans-unit>
        <trans-unit id="0b14168e95c9d9a01df3680215e98fc982e341d6" translate="yes" xml:space="preserve">
          <source>The expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument.</source>
          <target state="translated">クラスデコレータの式は、実行時に関数として呼び出され、デコレーションされたクラスのコンストラクタが唯一の引数となります。</target>
        </trans-unit>
        <trans-unit id="0d60ee880be94f69fdd4585e45c1d4d2352936ea" translate="yes" xml:space="preserve">
          <source>The expression for the method decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">メソッドデコレータの式は、実行時に関数として呼び出され、以下の3つの引数を持ちます。</target>
        </trans-unit>
        <trans-unit id="5086d420edcd773ac6d732072618188585203199" translate="yes" xml:space="preserve">
          <source>The expression for the parameter decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">パラメータデコレータの式は、実行時に関数として呼び出され、以下の3つの引数を持ちます。</target>
        </trans-unit>
        <trans-unit id="edae3f3dc86e86b9a64d098ac85c40b60e98ad47" translate="yes" xml:space="preserve">
          <source>The expression for the property decorator will be called as a function at runtime, with the following two arguments:</source>
          <target state="translated">プロパティデコレータの式は、実行時に関数として呼び出され、以下の2つの引数を持ちます。</target>
        </trans-unit>
        <trans-unit id="3e0ed5b6c650314a8da3d7c5c7c625309c2ba4c4" translate="yes" xml:space="preserve">
          <source>The expressions for each decorator are evaluated top-to-bottom.</source>
          <target state="translated">各デコレータの式は上から下に評価されます。</target>
        </trans-unit>
        <trans-unit id="60727c2e253818c6e1394797bce9983cbcfb14d2" translate="yes" xml:space="preserve">
          <source>The factory chosen will also affect where the &lt;code&gt;JSX&lt;/code&gt; namespace is looked up (for type checking information) before falling back to the global one. If the factory is defined as &lt;code&gt;React.createElement&lt;/code&gt; (the default), the compiler will check for &lt;code&gt;React.JSX&lt;/code&gt; before checking for a global &lt;code&gt;JSX&lt;/code&gt;. If the factory is defined as &lt;code&gt;h&lt;/code&gt;, it will check for &lt;code&gt;h.JSX&lt;/code&gt; before a global &lt;code&gt;JSX&lt;/code&gt;.</source>
          <target state="translated">選択されたファクトリは、グローバルタイプにフォールバックする前に &lt;code&gt;JSX&lt;/code&gt; ネームスペースが（タイプチェック情報のために）検索される場所にも影響します。 ファクトリが &lt;code&gt;React.createElement&lt;/code&gt; （デフォルト）として定義されている場合、コンパイラはグローバル &lt;code&gt;JSX&lt;/code&gt; をチェックする前に &lt;code&gt;React.JSX&lt;/code&gt; をチェックします。 ファクトリが &lt;code&gt;h&lt;/code&gt; として定義されている場合、グローバル &lt;code&gt;JSX&lt;/code&gt; の前に &lt;code&gt;h.JSX&lt;/code&gt; をチェックします。</target>
        </trans-unit>
        <trans-unit id="d8cbf6331553242a5f0e701d007b43692f6b7d55" translate="yes" xml:space="preserve">
          <source>The first assignment is now an error. Effectively, &lt;code&gt;T&lt;/code&gt; is contravariant in &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; because it is used only in function type parameter positions.</source>
          <target state="translated">最初の割り当てはエラーになりました。 事実上、 &lt;code&gt;T&lt;/code&gt; は関数型パラメーターの位置でのみ使用されるため、 &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; では反変です。</target>
        </trans-unit>
        <trans-unit id="f83cf7bff16c656834b3e301df968baf4cd1ffca" translate="yes" xml:space="preserve">
          <source>The first assignment is permitted in default type checking mode, but flagged as an error in strict function types mode. Intuitively, the default mode permits the assignment because it is &lt;em&gt;possibly&lt;/em&gt; sound, whereas strict function types mode makes it an error because it isn&amp;rsquo;t &lt;em&gt;provably&lt;/em&gt; sound. In either mode the third assignment is an error because it is &lt;em&gt;never&lt;/em&gt; sound.</source>
          <target state="translated">最初の割り当ては、デフォルトの型チェックモードでは許可されますが、厳密な関数型モードではエラーとしてフラグが付けられます。 直観的には、デフォルトモードはサウンドの&lt;em&gt;可能性&lt;/em&gt;が&lt;em&gt;ある&lt;/em&gt;ため割り当てを許可しますが、厳密な関数タイプモードはサウンドが&lt;em&gt;証明され&lt;/em&gt;ないためエラーになります。 どちらのモードでも、3番目の割り当ては&lt;em&gt;決して&lt;/em&gt;正しく&lt;em&gt;ない&lt;/em&gt;ためエラーです。</target>
        </trans-unit>
        <trans-unit id="86d2c2eef081b9efd8e081cbfc7a2eb73c95a9bf" translate="yes" xml:space="preserve">
          <source>The first is that enum members also become types as well! For example, we can say that certain members can &lt;em&gt;only&lt;/em&gt; have the value of an enum member:</source>
          <target state="translated">1つ目は、enumメンバーも型になることです！ たとえば、特定のメンバーは列挙メンバーの値&lt;em&gt;のみを&lt;/em&gt;持つことができると言うことができます。</target>
        </trans-unit>
        <trans-unit id="11b6104cea3d7fbf08969b5f72b6d05a84f6d569" translate="yes" xml:space="preserve">
          <source>The first line tells Visual Studio to run the task &amp;lsquo;default&amp;rsquo; after the build finishes. It will also run the &amp;lsquo;clean&amp;rsquo; task when you ask Visual Studio to clean the build.</source>
          <target state="translated">最初の行は、ビルドが完了した後にタスク「デフォルト」を実行するようにVisual Studioに指示します。 また、Visual Studioにビルドのクリーンアップを依頼すると、「クリーン」タスクが実行されます。</target>
        </trans-unit>
        <trans-unit id="f589b53519dab849472b770ba61a662532e94279" translate="yes" xml:space="preserve">
          <source>The first step to type checking attributes is to determine the &lt;em&gt;element attributes type&lt;/em&gt;. This is slightly different between intrinsic and value-based elements.</source>
          <target state="translated">属性を型チェックする最初のステップは、 &lt;em&gt;要素の属性型&lt;/em&gt;を決定すること&lt;em&gt;です&lt;/em&gt; 。 これは、組み込み要素と値ベースの要素でわずかに異なります。</target>
        </trans-unit>
        <trans-unit id="58af75a63079336d3af143e1407bc44a6c44b6ef" translate="yes" xml:space="preserve">
          <source>The first thing you may notice in the above is that instead of trying to extend &lt;code&gt;Disposable&lt;/code&gt; and &lt;code&gt;Activatable&lt;/code&gt; in &lt;code&gt;SmartObject&lt;/code&gt; class, we extend them in &lt;code&gt;SmartObject&lt;/code&gt; interface. &lt;code&gt;SmartObject&lt;/code&gt; interface will be mixed into the &lt;code&gt;SmartObject&lt;/code&gt; class due to the &lt;a href=&quot;declaration-merging&quot;&gt;declaration merging&lt;/a&gt;.</source>
          <target state="translated">上記で最初に気付くのは、 &lt;code&gt;SmartObject&lt;/code&gt; クラスで &lt;code&gt;Disposable&lt;/code&gt; およびActivatableを拡張する代わりに、 &lt;code&gt;SmartObject&lt;/code&gt; インターフェイスで拡張することです。 &lt;code&gt;SmartObject&lt;/code&gt; インターフェイスは、 &lt;a href=&quot;declaration-merging&quot;&gt;宣言のマージ&lt;/a&gt;により、 &lt;code&gt;SmartObject&lt;/code&gt; クラスに混在します。</target>
        </trans-unit>
        <trans-unit id="1598a89fa953ba70cfbbf99c377df16fd8ed251e" translate="yes" xml:space="preserve">
          <source>The first type of assertion signature models the way that Node&amp;rsquo;s &lt;code&gt;assert&lt;/code&gt; function works. It ensures that whatever condition is being checked must be true for the remainder of the containing scope.</source>
          <target state="translated">最初のタイプのアサーションシグネチャは、ノードのアサーション機能の動作方法をモデル化します。 これにより、チェック対象の条件が、包含スコープの残りの部分で真でなければなりません。</target>
        </trans-unit>
        <trans-unit id="e7ac3fa8432f39d89d10777015cb56ae8fd93747" translate="yes" xml:space="preserve">
          <source>The flexibility of &lt;code&gt;rootDirs&lt;/code&gt; is not limited to specifying a list of physical source directories that are logically merged. The supplied array may include any number of ad hoc, arbitrary directory names, regardless of whether they exist or not. This allows the compiler to capture sophisticated bundling and runtime features such as conditional inclusion and project specific loader plugins in a type safe way.</source>
          <target state="translated">&lt;code&gt;rootDirs&lt;/code&gt; の柔軟性は、論理的にマージされる物理ソースディレクトリのリストを指定することに限定されません。 指定された配列には、存在するかどうかに関係なく、任意の数のアドホックな任意のディレクトリ名を含めることができます。 これにより、コンパイラは、条件付きインクルードやプロジェクト固有のローダープラグインなどの洗練されたバンドルおよびランタイム機能を、タイプセーフな方法でキャプチャできます。</target>
        </trans-unit>
        <trans-unit id="6ba8cf088bc4a62237fb1f09825df1931ceb84e4" translate="yes" xml:space="preserve">
          <source>The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:</source>
          <target state="translated">以下の例では、共変数の位置にある同じ型変数の複数の候補が、どのようにして組合型を推論するかを示しています。</target>
        </trans-unit>
        <trans-unit id="aa5d6454fbf6bf730c8b327164f77ed6f69baf2e" translate="yes" xml:space="preserve">
          <source>The following is an example of a class decorator (&lt;code&gt;@sealed&lt;/code&gt;) applied to the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">以下は、 &lt;code&gt;Greeter&lt;/code&gt; クラスに適用されるクラスデコレータ（ &lt;code&gt;@sealed&lt;/code&gt; ）の例です。</target>
        </trans-unit>
        <trans-unit id="894306209d899f3f7794eaec540a57c394ffa6ed" translate="yes" xml:space="preserve">
          <source>The following is an example of a method decorator (&lt;code&gt;@enumerable&lt;/code&gt;) applied to a method on the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">以下は、 &lt;code&gt;Greeter&lt;/code&gt; クラスのメソッドに適用されるメソッドデコレータ（ &lt;code&gt;@enumerable&lt;/code&gt; ）の例です。</target>
        </trans-unit>
        <trans-unit id="56eb8bb77b4d8ce3acb0c50224bfb3b899067f94" translate="yes" xml:space="preserve">
          <source>The following is an example of a parameter decorator (&lt;code&gt;@required&lt;/code&gt;) applied to parameter of a member of the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">以下は、 &lt;code&gt;Greeter&lt;/code&gt; クラスのメンバーのパラメーターに適用されるパラメーターデコレーター（ &lt;code&gt;@required&lt;/code&gt; ）の例です。</target>
        </trans-unit>
        <trans-unit id="4c9599f42a20eb3b17874db9fbac592989bd9e8c" translate="yes" xml:space="preserve">
          <source>The following is an example of an accessor decorator (&lt;code&gt;@configurable&lt;/code&gt;) applied to a member of the &lt;code&gt;Point&lt;/code&gt; class:</source>
          <target state="translated">以下は、 &lt;code&gt;Point&lt;/code&gt; クラスのメンバーに適用されるアクセサデコレータ（ &lt;code&gt;@configurable&lt;/code&gt; ）の例です。</target>
        </trans-unit>
        <trans-unit id="f1290f593b907ee11da2a865c78e736129d049be" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;foo&lt;/code&gt; contains the number of widgets present.</source>
          <target state="translated">グローバル変数 &lt;code&gt;foo&lt;/code&gt; には、存在するウィジェットの数が含まれています。</target>
        </trans-unit>
        <trans-unit id="5cf5ea298d71b31d168d1d4cfd5dd7bf5304c883" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;myLib&lt;/code&gt; has a function &lt;code&gt;makeGreeting&lt;/code&gt; for creating greetings, and a property &lt;code&gt;numberOfGreetings&lt;/code&gt; indicating the number of greetings made so far.</source>
          <target state="translated">グローバル変数 &lt;code&gt;myLib&lt;/code&gt; には、挨拶を作成するための関数 &lt;code&gt;makeGreeting&lt;/code&gt; と、これまでに行われた挨拶の数を示すnumberOfGreetingsプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="fbf0d9abbae1382a841d6a20a7fd42f5f792dbfd" translate="yes" xml:space="preserve">
          <source>The guide is broken down into the following sections.</source>
          <target state="translated">ガイドは以下の項目に分かれています。</target>
        </trans-unit>
        <trans-unit id="152f8cc5510f46a1bacae33a53ef9b6ca874c1fb" translate="yes" xml:space="preserve">
          <source>The inference process is fairly straightforward here because &lt;code&gt;getDisplayName&lt;/code&gt; and &lt;code&gt;getLength&lt;/code&gt; use types that can easily be referenced. However, in TypeScript 3.3 and earlier, generic functions like &lt;code&gt;compose&lt;/code&gt; didn&amp;rsquo;t work so well when passed other generic functions.</source>
          <target state="translated">&lt;code&gt;getDisplayName&lt;/code&gt; と &lt;code&gt;getLength&lt;/code&gt; は簡単に参照できる型を使用するため、推論プロセスはここではかなり簡単です。 ただし、TypeScript 3.3以前では、 &lt;code&gt;compose&lt;/code&gt; などの汎用関数は、他の汎用関数を渡されたときにあまりうまく機能しませんでした。</target>
        </trans-unit>
        <trans-unit id="2bd1d13df309ad7c445be96538c356e69d82dd45" translate="yes" xml:space="preserve">
          <source>The inferred return type of a function may be a type declared locally within the function. It is not possible for callers of the function to reference such a local type, but it can of course be matched structurally. For example:</source>
          <target state="translated">関数の推測される戻り値の型は、関数内でローカルに宣言された型である可能性があります。関数の呼び出し元がこのようなローカル型を参照することはできませんが、もちろん構造的にマッチさせることはできます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="47a1b4c14a30afe92145ea5aeaecb13f79bfbd9a" translate="yes" xml:space="preserve">
          <source>The instance side of an ambient class declaration can be extended using an interface declaration The class constructor object is unmodified. For example:</source>
          <target state="translated">アンビエントクラス宣言のインスタンス側は、インターフェース宣言を使って拡張できます。 クラスのコンストラクタオブジェクトは変更されません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0e67711effae647619fb03057e9603bedb94bf60" translate="yes" xml:space="preserve">
          <source>The intent of any function that returns &lt;code&gt;never&lt;/code&gt; is that it never returns. It indicates that an exception was thrown, a halting error condition occurred, or that the program exited. For example, &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874&quot;&gt;&lt;code&gt;process.exit(...)&lt;/code&gt; in &lt;code&gt;@types/node&lt;/code&gt;&lt;/a&gt; is specified to return &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 戻らない関数の目的は、 決して戻らないことです。 例外がスローされたか、停止エラー条件が発生したか、またはプログラムが終了したことを示しています。 たとえば&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874&quot;&gt;、 &lt;code&gt;@types/node&lt;/code&gt; &lt;code&gt;process.exit(...)&lt;/code&gt; は、&lt;/a&gt; &lt;code&gt;never&lt;/code&gt; を返すように指定されています。</target>
        </trans-unit>
        <trans-unit id="8083efa15c72562212b03ec1e7d929e3b1bfe6f0" translate="yes" xml:space="preserve">
          <source>The interface &lt;code&gt;LabeledValue&lt;/code&gt; is a name we can now use to describe the requirement in the previous example. It still represents having a single property called &lt;code&gt;label&lt;/code&gt; that is of type &lt;code&gt;string&lt;/code&gt;. Notice we didn&amp;rsquo;t have to explicitly say that the object we pass to &lt;code&gt;printLabel&lt;/code&gt; implements this interface like we might have to in other languages. Here, it&amp;rsquo;s only the shape that matters. If the object we pass to the function meets the requirements listed, then it&amp;rsquo;s allowed.</source>
          <target state="translated">インターフェイス &lt;code&gt;LabeledValue&lt;/code&gt; は、前の例で要件を説明するために使用できる名前です。 &lt;code&gt;string&lt;/code&gt; 型の &lt;code&gt;label&lt;/code&gt; と呼ばれる単一のプロパティを持つことを表しています 。 &lt;code&gt;printLabel&lt;/code&gt; に渡すオブジェクトが、他の言語で必要になる可能性があるように、このインターフェイスを実装していることを明示的に言う必要がないことに注意してください。 ここで重要なのは形状だけです。 関数に渡すオブジェクトがリストされている要件を満たしている場合、許可されます。</target>
        </trans-unit>
        <trans-unit id="cd1c38f5000220665076a2e98824f2dbc1f3584b" translate="yes" xml:space="preserve">
          <source>The key difference is not in the syntax, but in the semantics, which we&amp;rsquo;ll now dive into.</source>
          <target state="translated">主な違いは構文にあるのではなく、セマンティクスにあるため、ここで詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="b1b9a12d68027688efebd6988d804e470eefcb75" translate="yes" xml:space="preserve">
          <source>The last element of a tuple type can be a rest element of the form &lt;code&gt;...X&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an array type. A rest element indicates that the tuple type is open-ended and may have zero or more additional elements of the array element type. For example, &lt;code&gt;[number, ...string[]]&lt;/code&gt; means tuples with a &lt;code&gt;number&lt;/code&gt; element followed by any number of &lt;code&gt;string&lt;/code&gt; elements.</source>
          <target state="translated">タプル型の最後の要素は、 &lt;code&gt;...X&lt;/code&gt; の形式の残りの要素にすることができます。ここで、 &lt;code&gt;X&lt;/code&gt; は配列型です。 残りの要素は、タプル型が無制限であり、配列要素型のゼロ個以上の追加要素がある場合があることを示します。 たとえば、 &lt;code&gt;[number, ...string[]]&lt;/code&gt; は、 &lt;code&gt;number&lt;/code&gt; 要素の後に任意の数の &lt;code&gt;string&lt;/code&gt; 要素が続くタプルを意味します。</target>
        </trans-unit>
        <trans-unit id="d4b0bc795023f6d40258c16a24c570ab3f6de281" translate="yes" xml:space="preserve">
          <source>The layout of your declaration files should mirror the layout of the library.</source>
          <target state="translated">宣言ファイルのレイアウトは、ライブラリのレイアウトを反映させてください。</target>
        </trans-unit>
        <trans-unit id="62c6720928ebff15b4528d428a66db79a0e91621" translate="yes" xml:space="preserve">
          <source>The library can then be used as an import within modules:</source>
          <target state="translated">このライブラリは、モジュール内のインポートとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="5c400cd4aab73c26b9cba5406e5bfac6b44dcde8" translate="yes" xml:space="preserve">
          <source>The list below outlines which constructs are currently supported when using JSDoc annotations to provide type information in JavaScript files.</source>
          <target state="translated">以下のリストは、JavaScriptファイルの型情報を提供するためにJSDocアノテーションを使用する際に、現在サポートされている構文の概要です。</target>
        </trans-unit>
        <trans-unit id="dfd2bc32d3b21a5f15921128bd3664a23c6123a7" translate="yes" xml:space="preserve">
          <source>The locale to use to show error messages, e.g. en-us.</source>
          <target state="translated">エラーメッセージを表示する際に使用するロケール。</target>
        </trans-unit>
        <trans-unit id="745d0c4fae6c29892a03fe80ac17ab71cddad006" translate="yes" xml:space="preserve">
          <source>The majority of this handbook uses &lt;code&gt;let&lt;/code&gt; declarations.</source>
          <target state="translated">このハンドブックの大部分は、 &lt;code&gt;let&lt;/code&gt; 宣言を使用しています。</target>
        </trans-unit>
        <trans-unit id="6da0134724ec18c2aa83421ac5856f5cd2ff92c3" translate="yes" xml:space="preserve">
          <source>The maximum dependency depth to search under node_modules and load JavaScript files. Only applicable with &lt;code&gt;--allowJs&lt;/code&gt;.</source>
          <target state="translated">node_modulesの下で検索してJavaScriptファイルをロードするための最大依存度。 &lt;code&gt;--allowJs&lt;/code&gt; でのみ適用できます。</target>
        </trans-unit>
        <trans-unit id="931a11093903bc4e1293ac6a3b67077bc77990a3" translate="yes" xml:space="preserve">
          <source>The meaning is usually the same, or a superset, of the meaning of the tag given at usejsdoc.org. The code below describes the differences and gives some example usage of each tag.</source>
          <target state="translated">その意味は通常、usejsdoc.orgで与えられたタグの意味と同じか、あるいはその上位のものです。以下のコードは違いを説明し、それぞれのタグの使用例を示しています。</target>
        </trans-unit>
        <trans-unit id="5ce56ea092f5ec509f61892542f58f563f4f1ba4" translate="yes" xml:space="preserve">
          <source>The module name is resolved the same way as module specifiers in &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;export&lt;/code&gt;. See &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; for more information. Then the declarations in an augmentation are merged as if they were declared in the same file as the original.</source>
          <target state="translated">モジュール名は、 &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;export&lt;/code&gt; モジュール指定子と同じ方法で解決されます。 詳細については、 &lt;a href=&quot;modules&quot;&gt;モジュール&lt;/a&gt;を参照してください。 次に、拡張の宣言は、元のファイルと同じファイルで宣言されているかのようにマージされます。</target>
        </trans-unit>
        <trans-unit id="07d6025a4d8631b7d86a3f44337b3b6ce6a9547d" translate="yes" xml:space="preserve">
          <source>The module support in Javascript is much more syntactically forgiving than Typescript&amp;rsquo;s module support. Most combinations of assignments and declarations are supported.</source>
          <target state="translated">Javascriptのモジュールサポートは、Typescriptのモジュールサポートよりもはるかに構文的に寛容です。 割り当てと宣言のほとんどの組み合わせがサポートされています。</target>
        </trans-unit>
        <trans-unit id="72abf6e26cd87e8f0de9628019db48b91ac42135" translate="yes" xml:space="preserve">
          <source>The most basic datatype is the simple true/false value, which JavaScript and TypeScript call a &lt;code&gt;boolean&lt;/code&gt; value.</source>
          <target state="translated">最も基本的なデータ型は、JavaScriptとTypeScriptが &lt;code&gt;boolean&lt;/code&gt; 値を呼び出す単純なtrue / false値です。</target>
        </trans-unit>
        <trans-unit id="79f9e1701395e49a979bcc38539774286a14204c" translate="yes" xml:space="preserve">
          <source>The most impactful outcome of this feature might a bit subtle: with TypeScript 3.7, users can write libraries in JSDoc annotated JavaScript and support TypeScript users.</source>
          <target state="translated">TypeScript 3.7では、JSDocの注釈付きJavaScriptにライブラリを書き込んだり、TypeScriptユーザーをサポートしたりすることができます。</target>
        </trans-unit>
        <trans-unit id="d479ce4d899b82dead8eec0f18d6751cfd1966b0" translate="yes" xml:space="preserve">
          <source>The motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:</source>
          <target state="translated">動機となる例は、コールバックを受け取り、(プログラマにとっては)予測可能だが(型システムにとっては)未知の数の引数を使ってコールバックを呼び出す関数の一般的なパターンです。</target>
        </trans-unit>
        <trans-unit id="a57329ec0396a0060bb3225032730f604a10bd46" translate="yes" xml:space="preserve">
          <source>The name of a module augmentation is resolved using the same set of rules as module specifiers in &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; declarations. The declarations in a module augmentation are merged with any existing declarations the same way they would if they were declared in the same file.</source>
          <target state="translated">モジュール拡張の名前は、 &lt;code&gt;import&lt;/code&gt; および &lt;code&gt;export&lt;/code&gt; 宣言のモジュール指定子と同じルールのセットを使用して解決されます。 モジュール拡張の宣言は、同じファイルで宣言された場合と同じ方法で、既存の宣言とマージされます。</target>
        </trans-unit>
        <trans-unit id="89f93191caae9470e60a7d3f09f4c2434d9bcb48" translate="yes" xml:space="preserve">
          <source>The name of the member.</source>
          <target state="translated">メンバーの名前です。</target>
        </trans-unit>
        <trans-unit id="bf6a2b3b69a6eaafe919135aca00082a2b3c554f" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;--showConfig&lt;/code&gt; flag</source>
          <target state="translated">新しい &lt;code&gt;--showConfig&lt;/code&gt; フラグ</target>
        </trans-unit>
        <trans-unit id="b915c8b00bd04df204cf54cb79ae4b4967b8188e" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;--strict&lt;/code&gt; compiler option represents the recommended setting of a number of type checking options. Specifically, specifying &lt;code&gt;--strict&lt;/code&gt; corresponds to specifying all of the following options (and may in the future include more options):</source>
          <target state="translated">新しい &lt;code&gt;--strict&lt;/code&gt; コンパイラオプションは、多くのタイプチェックオプションの推奨設定を表します。 具体的には、 &lt;code&gt;--strict&lt;/code&gt; を指定すると、次のすべてのオプションを指定することに対応します（将来さらにオプションが含まれる可能性があります）。</target>
        </trans-unit>
        <trans-unit id="46ab9ac92f2751e3448564e3b2bbebba0803af30" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;amd-dependency name&lt;/code&gt; property allows passing an optional name for an amd-dependency:</source>
          <target state="translated">新しい &lt;code&gt;amd-dependency name&lt;/code&gt; プロパティにより、amd-dependencyのオプション名を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="b0b30ce72a1fbb86ba7cb09b3d3773b6f87269d1" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;amd-module name&lt;/code&gt; tag allows passing an optional module name to the compiler:</source>
          <target state="translated">新しい &lt;code&gt;amd-module name&lt;/code&gt; タグにより、オプションのモジュール名をコンパイラーに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="00c1dd0b1d0ca34ff1579a9b55a20060afb63f62" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;protected&lt;/code&gt; modifier in classes works like it does in familiar languages like C++, C#, and Java. A &lt;code&gt;protected&lt;/code&gt; member of a class is visible only inside subclasses of the class in which it is declared:</source>
          <target state="translated">クラスの新しい &lt;code&gt;protected&lt;/code&gt; 修飾子は、C ++、C＃、Javaなどの使い慣れた言語でのように機能します。 クラスの &lt;code&gt;protected&lt;/code&gt; メンバーは、それが宣言されているクラスのサブクラス内でのみ表示されます。</target>
        </trans-unit>
        <trans-unit id="4be0bd15099c0de30a7f92de365d0546b8ad473c" translate="yes" xml:space="preserve">
          <source>The new ES6 keyword &lt;code&gt;let&lt;/code&gt;, now supported in TypeScript, declares a variable with more intuitive &amp;ldquo;block&amp;rdquo; semantics. A &lt;code&gt;let&lt;/code&gt; variable can only be referred to after its declaration, and is scoped to the syntactic block where it is defined:</source>
          <target state="translated">TypeScriptでサポート &lt;code&gt;let&lt;/code&gt; 新しいES6キーワードletは 、より直感的な「ブロック」セマンティクスで変数を宣言します。 &lt;code&gt;let&lt;/code&gt; 変数はその宣言の後でのみ参照でき、スコープが定義されている構文ブロックにスコープされます。</target>
        </trans-unit>
        <trans-unit id="631ad33334be4530d47703f4e1d29cda38f087ea" translate="yes" xml:space="preserve">
          <source>The new factory name will be used to call &lt;code&gt;createElement&lt;/code&gt; and &lt;code&gt;__spread&lt;/code&gt; functions.</source>
          <target state="translated">新しいファクトリー名は、 &lt;code&gt;createElement&lt;/code&gt; および &lt;code&gt;__spread&lt;/code&gt; 関数を呼び出すために使用されます。</target>
        </trans-unit>
        <trans-unit id="d61ddaaf04d8d0073ea020e3954c9d83ac5bd7ac" translate="yes" xml:space="preserve">
          <source>The new features are designed such that they can be used in both strict null checking mode and regular type checking mode. In particular, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; types are automatically erased from union types in regular type checking mode (because they are subtypes of all other types), and the &lt;code&gt;!&lt;/code&gt; non-null assertion expression operator is permitted but has no effect in regular type checking mode. Thus, declaration files that are updated to use null- and undefined-aware types can still be used in regular type checking mode for backwards compatibility.</source>
          <target state="translated">新しい機能は、厳密なNULLチェックモードと通常のタイプチェックモードの両方で使用できるように設計されています。 特に、通常の型チェックモードでは、 &lt;code&gt;null&lt;/code&gt; 型と &lt;code&gt;undefined&lt;/code&gt; 型はunion型から自動的に消去されます（他のすべての型のサブタイプであるため） &lt;code&gt;!&lt;/code&gt; null以外のアサーション式演算子は許可されていますが、通常の型チェックモードでは効果がありません。 したがって、nullおよび未定義に対応した型を使用するように更新された宣言ファイルは、下位互換性のために通常の型チェックモードで引き続き使用できます。</target>
        </trans-unit>
        <trans-unit id="b6846e96b454262c109940d0e55e3a4611d91414" translate="yes" xml:space="preserve">
          <source>The new implementation also brings performance enhancements to watching in tsserver. The watcher logic has been completely rewritten to respond faster to change events.</source>
          <target state="translated">新しい実装では、tsserver でのウォッチングにもパフォーマンスの向上がもたらされています。ウォッチャーのロジックが完全に書き換えられ、変更イベントに素早く反応するようになりました。</target>
        </trans-unit>
        <trans-unit id="5a00224be7961350e2a8ff419045fdd51b036e82" translate="yes" xml:space="preserve">
          <source>The new module &lt;code&gt;ProgrammerCalculator&lt;/code&gt; exports an API shape similar to that of the original &lt;code&gt;Calculator&lt;/code&gt; module, but does not augment any objects in the original module. Here is a test for our ProgrammerCalculator class:</source>
          <target state="translated">新しいモジュール &lt;code&gt;ProgrammerCalculator&lt;/code&gt; は、元の &lt;code&gt;Calculator&lt;/code&gt; モジュールと同様のAPIシェイプをエクスポートしますが、元のモジュールのオブジェクトを拡張しません。 ProgrammerCalculatorクラスのテストは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="2225a57adb33f21d4ebaaf566df0e99ffcf91683" translate="yes" xml:space="preserve">
          <source>The new playground now supports many new options including:</source>
          <target state="translated">新しい遊び場では、以下のような多くの新しいオプションをサポートするようになりました。</target>
        </trans-unit>
        <trans-unit id="68e11c2fb3a7db4e23da7d9de3e1a26ceae03748" translate="yes" xml:space="preserve">
          <source>The nightlies are available on &lt;a href=&quot;https://www.myget.org/gallery/typescript-preview&quot;&gt;www.myget.org&lt;/a&gt;.</source>
          <target state="translated">ナイトリーはwww.myget.orgで入手できます。</target>
        </trans-unit>
        <trans-unit id="eb8de4c955d33fe91a7e4cbce1b7361bd5b2b3a3" translate="yes" xml:space="preserve">
          <source>The nightly build currently does not include the full plugin setup, but we are working on publishing an installer on a nightly basis as well.</source>
          <target state="translated">現在のところ、毎晩のビルドには完全なプラグインのセットアップは含まれていませんが、インストーラーを毎晩のように公開する作業を行っています。</target>
        </trans-unit>
        <trans-unit id="cfcfc96df71a12a29b5ce210c72d3e03c563d868" translate="yes" xml:space="preserve">
          <source>The old behavior still remains the same if given a directory - the compiler will try to find a file in the directory named &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">ディレクトリを指定した場合、古い動作は同じままです。コンパイラは、 &lt;code&gt;tsconfig.json&lt;/code&gt; という名前のディレクトリ内のファイルを見つけようとします。</target>
        </trans-unit>
        <trans-unit id="8b20ba860bfef9c7687f7310f99a76fe76d3783b" translate="yes" xml:space="preserve">
          <source>The order of specifying spread operations determines what properties end up in the resulting object; properties in later spreads &amp;ldquo;win out&amp;rdquo; over previously created properties.</source>
          <target state="translated">展開操作を指定する順序によって、結果のオブジェクトにどのプロパティが含まれるかが決まります。 後でプロパティが以前に作成されたプロパティに「勝ち取り」ます。</target>
        </trans-unit>
        <trans-unit id="e7c876e1891bde60e537d27b5754b63af03257e0" translate="yes" xml:space="preserve">
          <source>The ordinal index of the parameter in the function&amp;rsquo;s parameter list.</source>
          <target state="translated">関数のパラメーターリスト内のパラメーターの序数インデックス。</target>
        </trans-unit>
        <trans-unit id="fb4cf9f813aa96ef2c61a94ad9fdf59d13dba821" translate="yes" xml:space="preserve">
          <source>The other change is that enum types themselves effectively become a &lt;em&gt;union&lt;/em&gt; of each enum member. While we haven&amp;rsquo;t discussed &lt;a href=&quot;advanced-types#union-types&quot;&gt;union types&lt;/a&gt; yet, all that you need to know is that with union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself. Because of that, TypeScript can catch silly bugs where we might be comparing values incorrectly. For example:</source>
          <target state="translated">もう1つの変更点は、列挙型自体が事実上各列挙型メンバーの&lt;em&gt;結合体&lt;/em&gt;になることです。 &lt;a href=&quot;advanced-types#union-types&quot;&gt;ユニオン型&lt;/a&gt;についてはまだ説明していませんが、ユニオン列挙型については、型システムが列挙型自体に存在する値の正確なセットを知っているという事実を活用できることだけを知っておく必要があります。 そのため、TypeScriptは、値を誤って比較している可能性のある愚かなバグをキャッチできます。 例えば：</target>
        </trans-unit>
        <trans-unit id="87a6d3fa93df1a7b5718c28d49fe2488fc9f01eb" translate="yes" xml:space="preserve">
          <source>The other new ES6 declaration type supported in TypeScript is &lt;code&gt;const&lt;/code&gt;. A &lt;code&gt;const&lt;/code&gt; variable may not be assigned to, and must be initialized where it is declared. This is useful for declarations where you don&amp;rsquo;t want to change the value after its initialization:</source>
          <target state="translated">TypeScriptでサポートされている他の新しいES6宣言型は &lt;code&gt;const&lt;/code&gt; です。 &lt;code&gt;const&lt;/code&gt; 変数は割り当てられない場合があり、宣言された場所で初期化する必要があります。 これは、初期化後に値を変更したくない宣言に役立ちます。</target>
        </trans-unit>
        <trans-unit id="e032670f94ed341d763142ae7b65b1fabd05bbb1" translate="yes" xml:space="preserve">
          <source>The other type of assertion signature doesn&amp;rsquo;t check for a condition, but instead tells TypeScript that a specific variable or property has a different type.</source>
          <target state="translated">他のタイプのアサーションシグネチャは条件をチェックしませんが、代わりに特定の変数またはプロパティが異なるタイプを持っていることをTypeScriptに伝えます。</target>
        </trans-unit>
        <trans-unit id="eda209051691c244644fa70c53c6b169301d940d" translate="yes" xml:space="preserve">
          <source>The popular library D3 defines its functionality in a global object called &lt;code&gt;d3&lt;/code&gt;. Because this library is loaded through a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag (instead of a module loader), its declaration uses namespaces to define its shape. For the TypeScript compiler to see this shape, we use an ambient namespace declaration. For example, we could begin writing it as follows:</source>
          <target state="translated">一般的なライブラリD3は、 &lt;code&gt;d3&lt;/code&gt; と呼ばれるグローバルオブジェクトでその機能を定義します。 このライブラリは（モジュールローダーではなく） &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグを介して読み込まれるため、その宣言では名前空間を使用して形状を定義します。 TypeScriptコンパイラーがこの形状を見るために、アンビエント名前空間宣言を使用します。 たとえば、次のように書き始めることができます。</target>
        </trans-unit>
        <trans-unit id="38c72ee7b721075b6b228593c6729fd98fa3d861" translate="yes" xml:space="preserve">
          <source>The preceding two types are equivalent to the Typescript types &lt;code&gt;{ [x: string]: number }&lt;/code&gt; and &lt;code&gt;{ [x: number]: any }&lt;/code&gt;. The compiler understands both syntaxes.</source>
          <target state="translated">前述の2つのタイプは、Typescriptタイプ &lt;code&gt;{ [x: string]: number }&lt;/code&gt; および &lt;code&gt;{ [x: number]: any }&lt;/code&gt; と同等です。 コンパイラは両方の構文を理解します。</target>
        </trans-unit>
        <trans-unit id="aa67059f742d5b7173801d752e91479969530cea" translate="yes" xml:space="preserve">
          <source>The presence of a &lt;code&gt;tsconfig.json&lt;/code&gt; file in a directory indicates that the directory is the root of a TypeScript project. The &lt;code&gt;tsconfig.json&lt;/code&gt; file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:</source>
          <target state="translated">ディレクトリに &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルが存在することは、そのディレクトリがTypeScriptプロジェクトのルートであることを示しています。 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルは、プロジェクトのコンパイルに必要なルートファイルとコンパイラオプションを指定します。 プロジェクトは、次のいずれかの方法でコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="088fad3bfe9085a4bf306d60f92061feba8a8ef7" translate="yes" xml:space="preserve">
          <source>The problem with &lt;code&gt;padLeft&lt;/code&gt; is that its &lt;code&gt;padding&lt;/code&gt; parameter is typed as &lt;code&gt;any&lt;/code&gt;. That means that we can call it with an argument that&amp;rsquo;s neither a &lt;code&gt;number&lt;/code&gt; nor a &lt;code&gt;string&lt;/code&gt;, but TypeScript will be okay with it.</source>
          <target state="translated">&lt;code&gt;padLeft&lt;/code&gt; の問題は、 &lt;code&gt;padding&lt;/code&gt; パラメータが &lt;code&gt;any&lt;/code&gt; として入力されることです。 つまり、 &lt;code&gt;number&lt;/code&gt; も &lt;code&gt;string&lt;/code&gt; でもない引数で呼び出すことができますが、TypeScriptでも問題ありません。</target>
        </trans-unit>
        <trans-unit id="1bb7381db8810d933065e806b992cda45878627e" translate="yes" xml:space="preserve">
          <source>The process of resolving these package names is similar to the process of resolving module names in an &lt;code&gt;import&lt;/code&gt; statement. An easy way to think of triple-slash-reference-types directives are as an &lt;code&gt;import&lt;/code&gt; for declaration packages.</source>
          <target state="translated">これらのパッケージ名を解決するプロセスは、 &lt;code&gt;import&lt;/code&gt; ステートメントのモジュール名を解決するプロセスに似ています。 triple-slash-reference-typesディレクティブを考える簡単な方法は、宣言パッケージの &lt;code&gt;import&lt;/code&gt; としてです。</target>
        </trans-unit>
        <trans-unit id="aafd5dd1f8eca4eda75bcd1718aa421a44d595dd" translate="yes" xml:space="preserve">
          <source>The process starts with a set of &lt;em&gt;root files&lt;/em&gt;; these are the file names specified on the command-line or in the &lt;code&gt;&quot;files&quot;&lt;/code&gt; list in the &lt;code&gt;tsconfig.json&lt;/code&gt; file. These root files are preprocessed in the same order they are specified. Before a file is added to the list, all triple-slash references in it are processed, and their targets included. Triple-slash references are resolved in a depth first manner, in the order they have been seen in the file.</source>
          <target state="translated">プロセスは、一連の&lt;em&gt;ルートファイル&lt;/em&gt;で始まり&lt;em&gt;ます&lt;/em&gt; 。 これらは、コマンドラインまたは &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルの &lt;code&gt;&quot;files&quot;&lt;/code&gt; リストで指定されたファイル名です。 これらのルートファイルは、指定された順序で前処理されます。 ファイルがリストに追加される前に、ファイル内のすべてのトリプルスラッシュ参照が処理され、それらのターゲットが含まれます。 トリプルスラッシュ参照は、ファイル内で確認された順に、深さ優先で解決されます。</target>
        </trans-unit>
        <trans-unit id="17ce755b0cdb23dc9be9ae1982b9a584f1e51772" translate="yes" xml:space="preserve">
          <source>The program should print &amp;ldquo;Hello from TypeScript!&amp;rdquo;.</source>
          <target state="translated">プログラムは「Hello from TypeScript！」と出力するはずです。</target>
        </trans-unit>
        <trans-unit id="fad1dae24f8de6bb5ace45589ded1976d7ba9b1d" translate="yes" xml:space="preserve">
          <source>The purpose of this guide is to teach you how to write a high-quality definition file. This guide is structured by showing documentation for some API, along with sample usage of that API, and explaining how to write the corresponding declaration.</source>
          <target state="translated">このガイドの目的は、高品質な定義ファイルの書き方を教えることです。このガイドは、あるAPIのドキュメントと、そのAPIの使用例を示し、対応する宣言の書き方を説明することで構成されています。</target>
        </trans-unit>
        <trans-unit id="0eccb935e6264e79e73c70e81e21a7c090643b4a" translate="yes" xml:space="preserve">
          <source>The reference tag here allows us to locate the declaration file that contains the declaration for the ambient module. This is how the &lt;code&gt;node.d.ts&lt;/code&gt; file that several of the TypeScript samples use is consumed.</source>
          <target state="translated">ここの参照タグにより、アンビエントモジュールの宣言を含む宣言ファイルを見つけることができます。 これは、いくつかのTypeScriptサンプルが使用する &lt;code&gt;node.d.ts&lt;/code&gt; ファイルの使用方法です。</target>
        </trans-unit>
        <trans-unit id="71056ddd9a7d7a3d2b766c4d6ec8f63ddc99ad7f" translate="yes" xml:space="preserve">
          <source>The rest of this section assumes &lt;code&gt;typescript@next&lt;/code&gt; is already installed.</source>
          <target state="translated">このセクションの残りの部分では、 &lt;code&gt;typescript@next&lt;/code&gt; が既にインストールされていることを前提としています。</target>
        </trans-unit>
        <trans-unit id="f21084484972497bb17b43e1dd1639f1309df4de" translate="yes" xml:space="preserve">
          <source>The result will be a file &lt;code&gt;greeter.js&lt;/code&gt; which contains the same JavaScript that you fed in. We&amp;rsquo;re up and running using TypeScript in our JavaScript app!</source>
          <target state="translated">結果は、 &lt;code&gt;greeter.js&lt;/code&gt; したものと同じJavaScriptを含むファイルgreeter.jsになります。JavaScriptアプリでTypeScriptを使用して実行しています。</target>
        </trans-unit>
        <trans-unit id="55cd4e9d5c07da56c2642a3c67f20fdea4efaf76" translate="yes" xml:space="preserve">
          <source>The resulting merged declaration of &lt;code&gt;Document&lt;/code&gt; will be the following:</source>
          <target state="translated">結果の &lt;code&gt;Document&lt;/code&gt; のマージされた宣言は次のようになります。</target>
        </trans-unit>
        <trans-unit id="5a7ebfe9ca74c5339d3d3f99e13edb4401f1c213" translate="yes" xml:space="preserve">
          <source>The resulting type of the property.</source>
          <target state="translated">プロパティの結果の型。</target>
        </trans-unit>
        <trans-unit id="fb503a1aeb68c9cb323a5ced50b16d97adf33167" translate="yes" xml:space="preserve">
          <source>The results are then called as functions from bottom-to-top.</source>
          <target state="translated">そして、その結果を下から上へ関数として呼び出します。</target>
        </trans-unit>
        <trans-unit id="b9eb08a8c7770e6b9f8872c6109a3df7ec5c1b48" translate="yes" xml:space="preserve">
          <source>The return value of the parameter decorator is ignored.</source>
          <target state="translated">パラメータデコレータの戻り値は無視されます。</target>
        </trans-unit>
        <trans-unit id="ec62e92022db3b095789b1a8bc611f9661c25a8c" translate="yes" xml:space="preserve">
          <source>The right side of the &lt;code&gt;instanceof&lt;/code&gt; needs to be a constructor function, and TypeScript will narrow down to:</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; の右側はコンストラクター関数である必要があり、TypeScriptは次のように絞り込みます。</target>
        </trans-unit>
        <trans-unit id="9bdcb387eac602c5c7979ebf6b526180243170a8" translate="yes" xml:space="preserve">
          <source>The same &lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;footnote&lt;/a&gt; applies to these modules.</source>
          <target state="translated">同じ&lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;脚注&lt;/a&gt;がこれらのモジュールに適用されます。</target>
        </trans-unit>
        <trans-unit id="f7fb9969f8be2dbbfcedab928e0115d7fa79657a" translate="yes" xml:space="preserve">
          <source>The same goes for &lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;ts-loader&lt;/a&gt;, another TypeScript loader for Webpack. You can read more about the differences between the two &lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Webpack用の別のTypeScriptローダーである&lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;ts-&lt;/a&gt; loaderについても同様です。 この2つの違いについては、 &lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;こちらをご覧ください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="00fc4820883d5fd03b19870a02ddabbb40e34c99" translate="yes" xml:space="preserve">
          <source>The same is true for optional properties:</source>
          <target state="translated">オプションのプロパティについても同様です。</target>
        </trans-unit>
        <trans-unit id="43f24dd384fa12ae0f07c7c778176cd12dddfc84" translate="yes" xml:space="preserve">
          <source>The same rule for assignment is used when checking function call arguments:</source>
          <target state="translated">関数呼び出しの引数をチェックする際には、代入と同じルールを使用します。</target>
        </trans-unit>
        <trans-unit id="addbe812d1672c5e4f322e5d5a3556adcb36610e" translate="yes" xml:space="preserve">
          <source>The same sort of tracking is now also done for empty arrays.</source>
          <target state="translated">空の配列に対しても同様のトラッキングが行われるようになりました。</target>
        </trans-unit>
        <trans-unit id="ccde6d73f9a8b313307d39b074524c1e2e182522" translate="yes" xml:space="preserve">
          <source>The same way that ordinary tuples are types that extend from &lt;code&gt;Array&lt;/code&gt; - a tuple with elements of type &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;, &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;, &amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; extends from &lt;code&gt;Array&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; \| ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; - &lt;code&gt;readonly&lt;/code&gt; tuples are types that extend from &lt;code&gt;ReadonlyArray&lt;/code&gt;. So a &lt;code&gt;readonly&lt;/code&gt; tuple with elements &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;, &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;, &amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; extends from &lt;code&gt;ReadonlyArray&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; | ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt;.</source>
          <target state="translated">通常のタプルが &lt;code&gt;Array&lt;/code&gt; から拡張されるタイプであるのと同じ方法-タイプ &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; 、 &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; 、&amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; 要素を持つタプルは &lt;code&gt;Array&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; \| ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; から拡張されます T &lt;sub&gt;2&lt;/sub&gt; \ | ... T &lt;sub&gt;n&lt;/sub&gt; &amp;gt; - &lt;code&gt;readonly&lt;/code&gt; タプルは、 &lt;code&gt;ReadonlyArray&lt;/code&gt; から拡張される型です。 したがって、要素 &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; 、 &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; 、&amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; 持つ &lt;code&gt;readonly&lt;/code&gt; タプルは、 &lt;code&gt;ReadonlyArray&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; | ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; から拡張されます。 T &lt;sub&gt;2&lt;/sub&gt; | ... T &lt;sub&gt;n&lt;/sub&gt; &amp;gt; 。</target>
        </trans-unit>
        <trans-unit id="739a9969f90dca0e3b9321fb87d6ba49413bb58c" translate="yes" xml:space="preserve">
          <source>The second assignment is an error, because &lt;code&gt;y&lt;/code&gt; has a required second parameter that &lt;code&gt;x&lt;/code&gt; does not have, so the assignment is disallowed.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; には &lt;code&gt;x&lt;/code&gt; にはない必須の2番目のパラメーターがあるため、2番目の割り当てはエラーになり、割り当ては許可されません。</target>
        </trans-unit>
        <trans-unit id="3f4a4a115d577adebcffab99f90c2599ff896791" translate="yes" xml:space="preserve">
          <source>The second block creates the following name meanings:</source>
          <target state="translated">2 番目のブロックは、以下の名前の意味を作成します。</target>
        </trans-unit>
        <trans-unit id="e0467e5b0666d2b81ecc53a34087b88185a9207e" translate="yes" xml:space="preserve">
          <source>The second method uses the &lt;code&gt;never&lt;/code&gt; type that the compiler uses to check for exhaustiveness:</source>
          <target state="translated">2番目の方法は、コンパイラが網羅性をチェックするために使用する &lt;code&gt;never&lt;/code&gt; 型を使用します。</target>
        </trans-unit>
        <trans-unit id="49820d40f361e464b077d6cf772f08f976135fd0" translate="yes" xml:space="preserve">
          <source>The second operator is &lt;code&gt;T[K]&lt;/code&gt;, the &lt;strong&gt;indexed access operator&lt;/strong&gt;. Here, the type syntax reflects the expression syntax. That means that &lt;code&gt;person['name']&lt;/code&gt; has the type &lt;code&gt;Person['name']&lt;/code&gt; &amp;mdash; which in our example is just &lt;code&gt;string&lt;/code&gt;. However, just like index type queries, you can use &lt;code&gt;T[K]&lt;/code&gt; in a generic context, which is where its real power comes to life. You just have to make sure that the type variable &lt;code&gt;K extends keyof T&lt;/code&gt;. Here&amp;rsquo;s another example with a function named &lt;code&gt;getProperty&lt;/code&gt;.</source>
          <target state="translated">2番目の演算子は、 &lt;strong&gt;インデックス付きアクセス演算子&lt;/strong&gt; &lt;code&gt;T[K]&lt;/code&gt; です。 ここで、型構文は式構文を反映しています。 つまり、 &lt;code&gt;person['name']&lt;/code&gt; の型は &lt;code&gt;Person['name']&lt;/code&gt; あり、この例では単なる &lt;code&gt;string&lt;/code&gt; です。 ただし、インデックスタイプのクエリと同様に、一般的なコンテキストで &lt;code&gt;T[K]&lt;/code&gt; 使用できます。これにより、その真の力が活かされます。 型変数 &lt;code&gt;K extends keyof T&lt;/code&gt; することを確認する必要があります。 &lt;code&gt;getProperty&lt;/code&gt; という名前の関数を使用した別の例を次に示します。</target>
        </trans-unit>
        <trans-unit id="d22435f751c04c05b24d63f2b79d13b3746e4a00" translate="yes" xml:space="preserve">
          <source>The second part is the return type. We make it clear which is the return type by using a fat arrow (&lt;code&gt;=&amp;gt;&lt;/code&gt;) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn&amp;rsquo;t return a value, you would use &lt;code&gt;void&lt;/code&gt; instead of leaving it off.</source>
          <target state="translated">2番目の部分は戻り値の型です。 パラメーターと戻り値の型の間に太い矢印（ &lt;code&gt;=&amp;gt;&lt;/code&gt; ）を使用して、戻り値の型であることが明確になります。 前述したように、これは関数タイプの必須部分です。したがって、関数が値を返さない場合は、値をそのままにする代わりに &lt;code&gt;void&lt;/code&gt; を使用します 。</target>
        </trans-unit>
        <trans-unit id="e07f825349d9c56d700585b88ad266691534c76a" translate="yes" xml:space="preserve">
          <source>The second reason is when a consumer uses the &amp;ldquo;strict null checking&amp;rdquo; feature of TypeScript. Because unspecified parameters appear as &lt;code&gt;undefined&lt;/code&gt; in JavaScript, it&amp;rsquo;s usually fine to pass an explicit &lt;code&gt;undefined&lt;/code&gt; to a function with optional arguments. This code, for example, should be OK under strict nulls:</source>
          <target state="translated">2番目の理由は、消費者がTypeScriptの「厳密なNULLチェック」機能を使用する場合です。 JavaScriptで &lt;code&gt;undefined&lt;/code&gt; 指定のパラメーターは未定義として表示されるため、通常、明示的な &lt;code&gt;undefined&lt;/code&gt; をオプションの引数を持つ関数に渡しても問題ありません 。 たとえば、次のコードは、厳密なNULLの下では問題ありません。</target>
        </trans-unit>
        <trans-unit id="3fd4b2e06d8d3d430b175e5ddeea0b896410301c" translate="yes" xml:space="preserve">
          <source>The second way is also perhaps the most common. Here we use &lt;em&gt;type argument inference&lt;/em&gt; &amp;ndash; that is, we want the compiler to set the value of &lt;code&gt;T&lt;/code&gt; for us automatically based on the type of the argument we pass in:</source>
          <target state="translated">2番目の方法もおそらく最も一般的です。 ここでは、 &lt;em&gt;型引数の推論&lt;/em&gt;を使用します。つまり、コンパイラーに、渡す引数の型に基づいて &lt;code&gt;T&lt;/code&gt; の値を自動的に設定させます。</target>
        </trans-unit>
        <trans-unit id="4736ec61bf8078d3ad2a342c635cb7fc5c10d088" translate="yes" xml:space="preserve">
          <source>The second way uses a generic array type, &lt;code&gt;Array&amp;lt;elemType&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">2番目の方法は、汎用配列タイプ &lt;code&gt;Array&amp;lt;elemType&amp;gt;&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="99b58ef085b8f5cfafe10b2f70b1c603ae679699" translate="yes" xml:space="preserve">
          <source>The simplest form of destructuring is array destructuring assignment:</source>
          <target state="translated">破壊の最も単純な形式は、配列破壊の代入です。</target>
        </trans-unit>
        <trans-unit id="81722fee1d2fb56b682b67ac28f4e353808fb7d3" translate="yes" xml:space="preserve">
          <source>The simplest, and perhaps most common, type of declaration merging is interface merging. At the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name.</source>
          <target state="translated">宣言のマージで最も単純で、おそらく最も一般的なタイプは、インターフェイスのマージです。最も基本的なレベルでは、両方の宣言のメンバを同じ名前の単一のインターフェイスに機械的に結合します。</target>
        </trans-unit>
        <trans-unit id="13408208368716d434a2faec6f70e98867378392" translate="yes" xml:space="preserve">
          <source>The snippet above is an example of type inference, explained later in the handbook.</source>
          <target state="translated">上のスニペットは、ハンドブックで後ほど説明する型推論の例です。</target>
        </trans-unit>
        <trans-unit id="f58e24702b78cd5b8941ef478b1489c1cd7b5d65" translate="yes" xml:space="preserve">
          <source>The spread operator also works:</source>
          <target state="translated">スプレッド演算子も効きます。</target>
        </trans-unit>
        <trans-unit id="306da80508d5bf827e829e72fb7591269adf0a66" translate="yes" xml:space="preserve">
          <source>The spread operator is the opposite of destructuring. It allows you to spread an array into another array, or an object into another object. For example:</source>
          <target state="translated">スプレッド演算子は、デストラクチャリングの反対語です。これにより、配列を別の配列に広げたり、オブジェクトを別のオブジェクトに広げたりすることができます。例えば、次のようになります。</target>
        </trans-unit>
        <trans-unit id="f885061b123a3fe063f3c9ed899b1d23df83d618" translate="yes" xml:space="preserve">
          <source>The strategy the compiler is following</source>
          <target state="translated">コンパイラは次のような戦略をとっています。</target>
        </trans-unit>
        <trans-unit id="c3d17817e55b210acd9bce6627aec4a4dd9620cb" translate="yes" xml:space="preserve">
          <source>The stricter checking applies to all function types, &lt;em&gt;except&lt;/em&gt; those originating in method or constructor declarations. Methods are excluded specifically to ensure generic classes and interfaces (such as &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;) continue to mostly relate covariantly.</source>
          <target state="translated">より厳密なチェックは、メソッドまたはコンストラクター宣言で発生するもの&lt;em&gt;を除く&lt;/em&gt; 、すべての関数タイプに適用されます。 メソッドは、汎用クラスとインターフェイス（ &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; ）がほぼ共変的に関連し続けることを保証するために、特に除外されます。</target>
        </trans-unit>
        <trans-unit id="9257c34b0251760de9cf13098d8b8dab286b41c2" translate="yes" xml:space="preserve">
          <source>The string literal union &lt;code&gt;Keys&lt;/code&gt;, which contains the names of properties to iterate over.</source>
          <target state="translated">反復するプロパティの名前を含む文字列リテラルunion &lt;code&gt;Keys&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="712aa4a776f92297417c2dad5e9739407277009b" translate="yes" xml:space="preserve">
          <source>The supported glob wildcards are:</source>
          <target state="translated">サポートされている glob ワイルドカードは以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="727e992e3d1e12337dc7c95d559ff4b4fccf59be" translate="yes" xml:space="preserve">
          <source>The syntax resembles the syntax for index signatures with a &lt;code&gt;for .. in&lt;/code&gt; inside. There are three parts:</source>
          <target state="translated">構文は、内部の &lt;code&gt;for .. in&lt;/code&gt; したインデックス署名の構文に似ています。 3つの部分があります。</target>
        </trans-unit>
        <trans-unit id="42212d0e88124e6c9e85e3c6d2679e2ebfc79e8e" translate="yes" xml:space="preserve">
          <source>The syntax should look familiar if you&amp;rsquo;ve used C# or Java before. We declare a new class &lt;code&gt;Greeter&lt;/code&gt;. This class has three members: a property called &lt;code&gt;greeting&lt;/code&gt;, a constructor, and a method &lt;code&gt;greet&lt;/code&gt;.</source>
          <target state="translated">以前にC＃またはJavaを使用したことがある場合、構文はおなじみのはずです。 新しいクラス &lt;code&gt;Greeter&lt;/code&gt; を宣言します。 このクラスには、 &lt;code&gt;greeting&lt;/code&gt; と呼ばれるプロパティ、コンストラクター、および &lt;code&gt;greet&lt;/code&gt; メソッドの3つのメンバーがあります。</target>
        </trans-unit>
        <trans-unit id="04a97906fd0b03483a7f8d7138ad2f0a923a35cf" translate="yes" xml:space="preserve">
          <source>The template file &lt;a href=&quot;templates/global-d-ts&quot;&gt;&lt;code&gt;global.d.ts&lt;/code&gt;&lt;/a&gt; defines an example library &lt;code&gt;myLib&lt;/code&gt;. Be sure to read the &lt;a href=&quot;#preventing-name-conflicts&quot;&gt;&amp;ldquo;Preventing Name Conflicts&amp;rdquo; footnote&lt;/a&gt;.</source>
          <target state="translated">テンプレートファイル&lt;a href=&quot;templates/global-d-ts&quot;&gt; &lt;code&gt;global.d.ts&lt;/code&gt; &lt;/a&gt;は、サンプルライブラリ &lt;code&gt;myLib&lt;/code&gt; を定義します。 &lt;a href=&quot;#preventing-name-conflicts&quot;&gt;「名前の競合を防ぐ」脚注を&lt;/a&gt;必ずお読みください。</target>
        </trans-unit>
        <trans-unit id="5291791ebba8241b8df5e64ba1807928b332ea67" translate="yes" xml:space="preserve">
          <source>The test files import the implementation files and do some testing:</source>
          <target state="translated">テストファイルは実装ファイルをインポートしてテストを行います。</target>
        </trans-unit>
        <trans-unit id="1d502ba678972d16c080f4276cf5add29d80b7a4" translate="yes" xml:space="preserve">
          <source>The three interfaces will merge to create a single declaration as so:</source>
          <target state="translated">3つのインターフェイスをマージして、このように1つの宣言を作成します。</target>
        </trans-unit>
        <trans-unit id="ace0f93a6c178ee20b3542e125ca7fdce8f70590" translate="yes" xml:space="preserve">
          <source>The top-level module here &lt;code&gt;Shapes&lt;/code&gt; wraps up &lt;code&gt;Triangle&lt;/code&gt; and &lt;code&gt;Square&lt;/code&gt; for no reason. This is confusing and annoying for consumers of your module:</source>
          <target state="translated">ここでの最上位モジュールは、 &lt;code&gt;Shapes&lt;/code&gt; が理由なく &lt;code&gt;Triangle&lt;/code&gt; と &lt;code&gt;Square&lt;/code&gt; をまとめたものです。 これはあなたのモジュールの消費者にとって混乱し、迷惑です：</target>
        </trans-unit>
        <trans-unit id="7b5e597f445939620e293134a759f62224c6c2bd" translate="yes" xml:space="preserve">
          <source>The two biggest changes are the following:</source>
          <target state="translated">大きく変わったのは以下の2点です。</target>
        </trans-unit>
        <trans-unit id="d3d5cbb8071ba1e4008349316f8601cde19debcd" translate="yes" xml:space="preserve">
          <source>The two options left more to be desired; bundling the helpers in every file was a pain point for customers trying to keep their package size small. And not including helpers, meant customers had to maintain their own helpers library.</source>
          <target state="translated">ヘルパーをすべてのファイルにバンドルすることは、パッケージサイズを小さくしようとしている顧客にとって苦痛でした。また、ヘルパーを含まないということは、顧客が独自のヘルパーライブラリを維持しなければならないことを意味していました。</target>
        </trans-unit>
        <trans-unit id="a8a8ad0b07b6aeac0ba2a5e2ec35773596d69e43" translate="yes" xml:space="preserve">
          <source>The two samples are equivalent. Using one over the other is mostly a choice of preference; however, when using TypeScript with JSX, only &lt;code&gt;as&lt;/code&gt;-style assertions are allowed.</source>
          <target state="translated">2つのサンプルは同等です。 どちらか一方を使用することは、主に好みの選択です。 ただし、TypeScriptをJSXで使用する場合は、スタイルアサーション &lt;code&gt;as&lt;/code&gt; のみ許可されます。</target>
        </trans-unit>
        <trans-unit id="9a2b71237e4b11c5e8ec290df36ff6e89dc1089c" translate="yes" xml:space="preserve">
          <source>The type above means when &lt;code&gt;T&lt;/code&gt; is assignable to &lt;code&gt;U&lt;/code&gt; the type is &lt;code&gt;X&lt;/code&gt;, otherwise the type is &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">上記のタイプは、 &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;U&lt;/code&gt; に割り当て可能な場合、タイプは &lt;code&gt;X&lt;/code&gt; であり 、そうでない場合、タイプは &lt;code&gt;Y&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c4716786bdfd77dd152da96b6dedb84b8495378a" translate="yes" xml:space="preserve">
          <source>The type checker checks the call to &lt;code&gt;printLabel&lt;/code&gt;. The &lt;code&gt;printLabel&lt;/code&gt; function has a single parameter that requires that the object passed in has a property called &lt;code&gt;label&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. Notice that our object actually has more properties than this, but the compiler only checks that &lt;em&gt;at least&lt;/em&gt; the ones required are present and match the types required. There are some cases where TypeScript isn&amp;rsquo;t as lenient, which we&amp;rsquo;ll cover in a bit.</source>
          <target state="translated">型チェッカーは &lt;code&gt;printLabel&lt;/code&gt; の呼び出しをチェックします。 &lt;code&gt;printLabel&lt;/code&gt; 関数には、渡されるオブジェクトに &lt;code&gt;string&lt;/code&gt; 型の &lt;code&gt;label&lt;/code&gt; というプロパティがあることを要求する単一のパラメーターがあります 。 オブジェクトには実際にはこれより多くのプロパティがありますが、コンパイラは&lt;em&gt;、少なくとも&lt;/em&gt;必要なものが存在し、必要なタイプと一致することのみをチェックすること&lt;em&gt;に&lt;/em&gt;注意してください。 TypeScriptがそれほど寛容ではない場合もありますが、これについては後で説明します。</target>
        </trans-unit>
        <trans-unit id="498dccd8aaeaa75874785e3ff175fe7c0758db81" translate="yes" xml:space="preserve">
          <source>The type checker previously considered &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; assignable to anything. Effectively, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; were valid values of &lt;em&gt;every&lt;/em&gt; type and it wasn&amp;rsquo;t possible to specifically exclude them (and therefore not possible to detect erroneous use of them).</source>
          <target state="translated">型チェッカーは、以前は &lt;code&gt;null&lt;/code&gt; であり、何に対しても &lt;code&gt;undefined&lt;/code&gt; と見なしていました。 事実上、 &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; は&lt;em&gt;すべての&lt;/em&gt;タイプの有効な値であり、それらを具体的に除外することはできませんでした（したがって、それらの誤った使用を検出することはできません）。</target>
        </trans-unit>
        <trans-unit id="86aac0e48da9aea5ed18bd94611504853bd15903" translate="yes" xml:space="preserve">
          <source>The type inferred for a &lt;code&gt;const&lt;/code&gt; variable or &lt;code&gt;readonly&lt;/code&gt; property without a type annotation is the type of the literal initializer. The type inferred for a &lt;code&gt;let&lt;/code&gt; variable, &lt;code&gt;var&lt;/code&gt; variable, parameter, or non-&lt;code&gt;readonly&lt;/code&gt; property with an initializer and no type annotation is the widened literal type of the initializer. Where the widened type for a string literal type is &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt; for numeric literal types, &lt;code&gt;boolean&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; and the containing enum for enum literal types.</source>
          <target state="translated">型注釈のない &lt;code&gt;const&lt;/code&gt; 変数または &lt;code&gt;readonly&lt;/code&gt; プロパティに対して推定される型は、リテラル初期化子の型です。 &lt;code&gt;let&lt;/code&gt; 変数、 &lt;code&gt;var&lt;/code&gt; 変数、パラメータ、または初期化子があり、型注釈がない非 &lt;code&gt;readonly&lt;/code&gt; プロパティに対して推定される型は、初期化子の拡張リテラル型です。 文字列リテラル型の拡張型は &lt;code&gt;string&lt;/code&gt; 、数値リテラル型の数値、 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; の &lt;code&gt;boolean&lt;/code&gt; 、およびenumリテラル型の包含enumです。</target>
        </trans-unit>
        <trans-unit id="22d8204ec0e93f58b5995cd3bb24de8809d04802" translate="yes" xml:space="preserve">
          <source>The type information provided works together with the tools to work with JavaScript at application scale. For more examples of what&amp;rsquo;s possible in TypeScript, see the Samples section of the website.</source>
          <target state="translated">提供される型情報は、アプリケーションスケールでJavaScriptを操作するツールと連携して機能します。 TypeScriptで可能なことのその他の例については、Webサイトの「サンプル」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="3d4d8d8ec6a0364ae5c047afca600acdad689a11" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;import.meta&lt;/code&gt; is the global &lt;code&gt;ImportMeta&lt;/code&gt; type which is defined in &lt;code&gt;lib.es5.d.ts&lt;/code&gt;. This interface is extremely limited. Adding well-known properties for Node or browsers requires interface merging and possibly a global augmentation depending on the context.</source>
          <target state="translated">&lt;code&gt;ImportMeta&lt;/code&gt; タイプは、 &lt;code&gt;lib.es5.d.ts&lt;/code&gt; で定義されているグローバルImportMetaタイプです 。 このインターフェースは非常に限られています。 ノードまたはブラウザの既知のプロパティを追加するには、インターフェイスのマージと、場合によってはコンテキストに応じたグローバルな拡張が必要です。</target>
        </trans-unit>
        <trans-unit id="d271ce4998727501be8284a249a40022d27f33d7" translate="yes" xml:space="preserve">
          <source>The type of a variable declared in a &lt;code&gt;for..in&lt;/code&gt; statement is implicitly &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; ステートメントで宣言された変数の型は暗黙的に &lt;code&gt;string&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5f07be8c188f5eaeef3ae763a9e934f23db56503" translate="yes" xml:space="preserve">
          <source>The type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:</source>
          <target state="translated">ジェネリック関数の型は非ジェネリック関数の型と同じで、関数宣言と同様に型パラメータが最初にリストアップされています。</target>
        </trans-unit>
        <trans-unit id="89b88412f516aaabf8ce78ad994c61d8ed26eb99" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;length&lt;/code&gt; property of a tuple type with a rest element is &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">残りの要素を持つタプル型の &lt;code&gt;length&lt;/code&gt; プロパティの型は &lt;code&gt;number&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="19df0d5bb97d9dc0679c13270f984f724378fbec" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;x&lt;/code&gt; variable is inferred to be &lt;code&gt;number&lt;/code&gt;. This kind of inference takes place when initializing variables and members, setting parameter default values, and determining function return types.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 変数の型は &lt;code&gt;number&lt;/code&gt; であると推測されます。 この種の推論は、変数とメンバーの初期化、パラメーターのデフォルト値の設定、および関数の戻り値の型の決定時に行われます。</target>
        </trans-unit>
        <trans-unit id="f6bd4bc2cdf6f5eae310eb7f350c21d93cc10ee9" translate="yes" xml:space="preserve">
          <source>The type parameter type of the &lt;code&gt;extends&lt;/code&gt; expression must be constrained to a mixin constructor type.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 式のtypeパラメーターtypeは、mixinコンストラクター型に制限する必要があります。</target>
        </trans-unit>
        <trans-unit id="52c2a6f88c2385c5622c47c84c950cacbd843901" translate="yes" xml:space="preserve">
          <source>The type system enforces that the source function&amp;rsquo;s return type be a subtype of the target type&amp;rsquo;s return type.</source>
          <target state="translated">型システムは、ソース関数の戻り値の型がターゲット型の戻り値の型のサブタイプであることを強制します。</target>
        </trans-unit>
        <trans-unit id="b936c977ae4cffd22334d0707270bc09672639e5" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;K&lt;/code&gt;, which gets bound to each property in turn.</source>
          <target state="translated">型変数 &lt;code&gt;K&lt;/code&gt; 。各変数に順番にバインドされます。</target>
        </trans-unit>
        <trans-unit id="7709afd63729fd84f9c850e499018e8fd56d1bb3" translate="yes" xml:space="preserve">
          <source>The types of the attributes being passed in the JSX element should be looked up differently. Intrinsic element attributes should be known &lt;em&gt;intrinsically&lt;/em&gt; whereas components will likely want to specify their own set of attributes.</source>
          <target state="translated">JSX要素で渡される属性のタイプは、別の方法で検索する必要があります。 固有の要素属性は&lt;em&gt;本質的&lt;/em&gt;に既知である必要がありますが、コンポーネントは独自の属性セットを指定する可能性があります。</target>
        </trans-unit>
        <trans-unit id="09675d7cd4f6ad417e59fbaf95c24d2d47c06712" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;TypeScriptToolsVersion&amp;gt;1.7&amp;lt;/TypeScriptToolsVersion&amp;gt;&lt;/code&gt; property in the project file identifies the compiler version to use to build (1.7 in this example). This allows a project to build against the same versions of the compiler on different machines.</source>
          <target state="translated">プロジェクトファイルの &lt;code&gt;&amp;lt;TypeScriptToolsVersion&amp;gt;1.7&amp;lt;/TypeScriptToolsVersion&amp;gt;&lt;/code&gt; プロパティの値は、ビルドに使用するコンパイラバージョンを識別します（この例では1.7）。 これにより、異なるマシン上の同じバージョンのコンパイラに対してプロジェクトをビルドできます。</target>
        </trans-unit>
        <trans-unit id="7e5b2230b8d43ad8c0d99ac55f3f3b2a5f049234" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;extends&lt;/code&gt; must be a string containing a path to another configuration file to inherit from.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; の値は、継承する別の構成ファイルへのパスを含む文字列である必要があります。</target>
        </trans-unit>
        <trans-unit id="23c080d1f546c832664165ecef0024de9c538ba4" translate="yes" xml:space="preserve">
          <source>The variables don&amp;rsquo;t necessarily need to both be block-scoped for TypeScript to tell us that there&amp;rsquo;s a problem.</source>
          <target state="translated">TypeScriptが問題があることを伝えるために、変数は必ずしも両方をブロックスコープにする必要はありません。</target>
        </trans-unit>
        <trans-unit id="0cd2fcb1497f2a79b74d282146de3e0947778826" translate="yes" xml:space="preserve">
          <source>The visibility rules for merged members is the same as described in the &amp;lsquo;Merging Namespaces&amp;rsquo; section, so we must export the &lt;code&gt;AlbumLabel&lt;/code&gt; class for the merged class to see it. The end result is a class managed inside of another class. You can also use namespaces to add more static members to an existing class.</source>
          <target state="translated">マージされたメンバーの可視性ルールは、「ネーム &lt;code&gt;AlbumLabel&lt;/code&gt; のマージ」セクションで説明したものと同じであるため、マージされたクラスのAlbumLabelクラスをエクスポートして表示する必要があります。 最終結果は、別のクラス内で管理されるクラスです。 名前空間を使用して、既存のクラスにさらに静的メンバーを追加することもできます。</target>
        </trans-unit>
        <trans-unit id="ea042e37fe3dfdb85a33f2ea55e58e9f6f78eed8" translate="yes" xml:space="preserve">
          <source>The watching of directory on platforms that don&amp;rsquo;t support recursive directory watching natively in node, is supported through recursively creating directory watcher for the child directories using different options selected by &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;. Note that on platforms that support native recursive directory watching (e.g windows) the value of this environment variable is ignored.</source>
          <target state="translated">ノードでネイティブに再帰ディレクトリ監視をサポートしていないプラットフォームでのディレクトリ監視は、 &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt; で選択されたさまざまなオプションを使用して、子ディレクトリのディレクトリ監視を再帰的に作成することでサポートされます 。 ネイティブな再帰ディレクトリ監視をサポートするプラットフォーム（Windowsなど）では、この環境変数の値は無視されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4068ca96cef50a182f0293c35312e884e5d6ce44" translate="yes" xml:space="preserve">
          <source>The way that TypeScript decides on whether a version of the compiler &amp;amp; language matches is by using Node&amp;rsquo;s &lt;a href=&quot;https://github.com/npm/node-semver#ranges&quot;&gt;semver ranges&lt;/a&gt;.</source>
          <target state="translated">TypeScriptがコンパイラと言語のバージョンが一致するかどうかを判断する方法は、Nodeの&lt;a href=&quot;https://github.com/npm/node-semver#ranges&quot;&gt;semver範囲&lt;/a&gt;を使用することです。</target>
        </trans-unit>
        <trans-unit id="d504e46325644ee193380b78759d039584245b76" translate="yes" xml:space="preserve">
          <source>The way that this works is that when using &lt;code&gt;allowJs&lt;/code&gt;, TypeScript has some best-effort analyses to understand common JavaScript patterns; however, the way that some patterns are expressed in JavaScript don&amp;rsquo;t necessarily look like their equivalents in TypeScript. When &lt;code&gt;declaration&lt;/code&gt; emit is turned on, TypeScript figures out the best way to transform JSDoc comments and CommonJS exports into valid type declarations and the like in the output &lt;code&gt;.d.ts&lt;/code&gt; files.</source>
          <target state="translated">これが機能する方法は、 &lt;code&gt;allowJs&lt;/code&gt; を使用する場合 、TypeScriptには一般的なJavaScriptパターンを理解するためのベストエフォート分析があります。 ただし、一部のパターンがJavaScriptで表現される方法は、TypeScriptの同等のパターンとは必ずしも一致しません。 &lt;code&gt;declaration&lt;/code&gt; 発行がオンになっている場合、TypeScriptは、JSDocコメントとCommonJSエクスポートを、出力 &lt;code&gt;.d.ts&lt;/code&gt; ファイルで有効な型宣言などに変換する最適な方法を見つけ出します。</target>
        </trans-unit>
        <trans-unit id="35913a132bcc3df8c56386f24253f0774dc172fa" translate="yes" xml:space="preserve">
          <source>Then consumed it:</source>
          <target state="translated">そして、それを消費した。</target>
        </trans-unit>
        <trans-unit id="47406e9f2861c5bd5131ac98ebd0257179f53e80" translate="yes" xml:space="preserve">
          <source>Then install &lt;code&gt;typescript&lt;/code&gt;, &lt;code&gt;gulp&lt;/code&gt; and &lt;code&gt;gulp-typescript&lt;/code&gt; in your project&amp;rsquo;s dev dependencies. &lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-typescript&lt;/a&gt; is a gulp plugin for Typescript.</source>
          <target state="translated">次に、プロジェクトの開発依存関係に &lt;code&gt;typescript&lt;/code&gt; 、 &lt;code&gt;gulp&lt;/code&gt; 、 &lt;code&gt;gulp-typescript&lt;/code&gt; をインストールします。 &lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-typescript&lt;/a&gt;はTypescriptのgulpプラグインです。</target>
        </trans-unit>
        <trans-unit id="642ddc2143630564f6b4e561a7568f47369559e5" translate="yes" xml:space="preserve">
          <source>Then the &lt;code&gt;food&lt;/code&gt; property in &lt;code&gt;defaults&lt;/code&gt; overwrites &lt;code&gt;food: &quot;rich&quot;&lt;/code&gt;, which is not what we want in this case.</source>
          <target state="translated">次に、 &lt;code&gt;defaults&lt;/code&gt; の &lt;code&gt;food&lt;/code&gt; プロパティは &lt;code&gt;food: &quot;rich&quot;&lt;/code&gt; 上書きしますが、これはこの場合に必要なものではありません。</target>
        </trans-unit>
        <trans-unit id="de093b53d785ff2bef7478f5b3a5ab97f6181f86" translate="yes" xml:space="preserve">
          <source>Then, given a type &lt;code&gt;T''&lt;/code&gt; that is an instantiation of &lt;code&gt;T&lt;/code&gt; where all &lt;code&gt;infer&lt;/code&gt; type variables are replaced with the types inferred in the previous step, if &lt;code&gt;T''&lt;/code&gt; is &lt;em&gt;definitely assignable&lt;/em&gt; to &lt;code&gt;U&lt;/code&gt;, the conditional type is resolved to &lt;code&gt;X&lt;/code&gt;. The definitely assignable relation is the same as the regular assignable relation, except that type variable constraints are not considered. Intuitively, when a type is definitely assignable to another type, we know that it will be assignable for &lt;em&gt;all instantiations&lt;/em&gt; of those types.</source>
          <target state="translated">次に、すべての &lt;code&gt;infer&lt;/code&gt; 型変数が前のステップで推論された型で置き換えられる &lt;code&gt;T&lt;/code&gt; のインスタンス化である型 &lt;code&gt;T''&lt;/code&gt; が与えられ、 &lt;code&gt;T''&lt;/code&gt; が &lt;code&gt;U&lt;/code&gt; に&lt;em&gt;確実に割り当て可能な&lt;/em&gt;場合、条件付き型は &lt;code&gt;X&lt;/code&gt; に解決されます。 確実に割り当て可能な関係は、型変数の制約が考慮されないことを除いて、通常の割り当て可能な関係と同じです。 直感的に、ある型が別の型に確実に割り当てられる場合、それらの型の&lt;em&gt;すべてのインスタンス化&lt;/em&gt;に割り当て可能であることがわかります。</target>
        </trans-unit>
        <trans-unit id="177fd68b346fbae5c87bdcc2142e9f97d5a264b8" translate="yes" xml:space="preserve">
          <source>Then, you need to remember to give a default for optional properties on the destructured property instead of the main initializer. Remember that &lt;code&gt;C&lt;/code&gt; was defined with &lt;code&gt;b&lt;/code&gt; optional:</source>
          <target state="translated">次に、メイン初期化子ではなく、非構造化プロパティのオプションプロパティにデフォルトを設定することを忘れないでください。 &lt;code&gt;C&lt;/code&gt; は &lt;code&gt;b&lt;/code&gt; オプションで定義されたことを思い出してください：</target>
        </trans-unit>
        <trans-unit id="b08559581092c2fc068a4a49c020c235194dda9a" translate="yes" xml:space="preserve">
          <source>There are also some flags specific to &lt;code&gt;tsc -b&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tsc -b&lt;/code&gt; に固有のフラグもいくつかあります。</target>
        </trans-unit>
        <trans-unit id="0d87487c8a7e09831fbc5025d0ad575e1d950bdf" translate="yes" xml:space="preserve">
          <source>There are basically three changes here, but they require you to refactor your code a bit.</source>
          <target state="translated">ここでは基本的に3つの変更点がありますが、コードを少しリファクタリングする必要があります。</target>
        </trans-unit>
        <trans-unit id="e6857c6b00d742af1ee133bd685d46d5cba15dc1" translate="yes" xml:space="preserve">
          <source>There are certain cases where TypeScript can&amp;rsquo;t figure out what certain types should be. To be as lenient as possible, it will decide to use the type &lt;code&gt;any&lt;/code&gt; in its place. While this is great for migration, using &lt;code&gt;any&lt;/code&gt; means that you&amp;rsquo;re not getting any type safety, and you won&amp;rsquo;t get the same tooling support you&amp;rsquo;d get elsewhere. You can tell TypeScript to flag these locations down and give an error with the &lt;code&gt;noImplicitAny&lt;/code&gt; option.</source>
          <target state="translated">特定の型がどうあるべきかをTypeScriptが判断できない場合があります。 可能な限り寛容にするために、代わりに &lt;code&gt;any&lt;/code&gt; タイプを使用することにします。 これは移行には適していますが、何らかの安全性が得られず、他の場所で得られるのと同じツールサポートが得られないことを意味します。 これらの場所にフラグを立てて、 &lt;code&gt;noImplicitAny&lt;/code&gt; オプションを使用してエラーを出すようにTypeScriptに指示できます。</target>
        </trans-unit>
        <trans-unit id="cf3ad7a163a01d342f3e2b293eed57c09a62514b" translate="yes" xml:space="preserve">
          <source>There are certain scenarios where properties can be initialized indirectly (perhaps by a helper method or dependency injection library), in which case you can use the new &lt;em&gt;definite assignment assertion modifiers&lt;/em&gt; for your properties (discussed below).</source>
          <target state="translated">プロパティを間接的に初期化できる特定のシナリオがあります（おそらくヘルパーメソッドまたは依存性注入ライブラリによって）。その場合、プロパティに新しい&lt;em&gt;明確な割り当てアサーション修飾子&lt;/em&gt;を使用できます（以下で説明します）。</target>
        </trans-unit>
        <trans-unit id="d8e46f31896dc086f90c6f67b6510c59fb5bf434" translate="yes" xml:space="preserve">
          <source>There are several kinds of dependencies your library might have. This section shows how to import them into the declaration file.</source>
          <target state="translated">ライブラリにはいくつかの種類の依存関係があります。このセクションでは、それらを宣言ファイルにインポートする方法を示します。</target>
        </trans-unit>
        <trans-unit id="f50947aa96622ea69cd6de3461bbbc3baf551e2b" translate="yes" xml:space="preserve">
          <source>There are three templates available for modules, &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;templates/module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;templates/module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;templates/module-class-d-ts&quot;&gt; &lt;code&gt;module-class.d.ts&lt;/code&gt; &lt;/a&gt; 、 module-class.d.ts 、 &lt;a href=&quot;templates/module-function-d-ts&quot;&gt; &lt;code&gt;module-function.d.ts&lt;/code&gt; の&lt;/a&gt; 3つのテンプレートがあります 。</target>
        </trans-unit>
        <trans-unit id="af6a54de55d95dc1fa9a970327164b2697b39938" translate="yes" xml:space="preserve">
          <source>There are two main ways to get the TypeScript tools:</source>
          <target state="translated">TypeScriptツールを取得する方法は主に2つあります。</target>
        </trans-unit>
        <trans-unit id="f51afbc91104b11fd815c5a998b7fab8086c5610" translate="yes" xml:space="preserve">
          <source>There are two packages:</source>
          <target state="translated">パッケージは2つあります。</target>
        </trans-unit>
        <trans-unit id="b8b3a9273fe6c950960b5b0a5f42744f3ece318c" translate="yes" xml:space="preserve">
          <source>There are two possible module resolution strategies: &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; and &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt;. You can use the &lt;code&gt;--moduleResolution&lt;/code&gt; flag to specify the module resolution strategy. If not specified, the default is &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; for &lt;code&gt;--module AMD | System | ES2015&lt;/code&gt; or &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; otherwise.</source>
          <target state="translated">&lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt;と&lt;a href=&quot;#classic&quot;&gt;Classicの&lt;/a&gt; 2つのモジュール解決戦略があります。 &lt;code&gt;--moduleResolution&lt;/code&gt; フラグを使用して、モジュール解決戦略を指定できます。 指定しない場合、デフォルトは &lt;code&gt;--module AMD | System | ES2015&lt;/code&gt; &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt;です。 システム| それ以外の場合はES2015または&lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d037836fd5889368e676cf82d021109751703c9" translate="yes" xml:space="preserve">
          <source>There are two types of supported index signatures: string and number. It is possible to support both types of indexers, but the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with a &lt;code&gt;number&lt;/code&gt;, JavaScript will actually convert that to a &lt;code&gt;string&lt;/code&gt; before indexing into an object. That means that indexing with &lt;code&gt;100&lt;/code&gt; (a &lt;code&gt;number&lt;/code&gt;) is the same thing as indexing with &lt;code&gt;&quot;100&quot;&lt;/code&gt; (a &lt;code&gt;string&lt;/code&gt;), so the two need to be consistent.</source>
          <target state="translated">サポートされているインデックス署名には、文字列と数値の2種類があります。 両方のタイプのインデクサーをサポートすることは可能ですが、数値インデクサーから返されるタイプは、文字列インデクサーから返されるタイプのサブタイプでなければなりません。 これは、 &lt;code&gt;number&lt;/code&gt; でインデックスを作成する場合、JavaScriptは実際にオブジェクトにインデックスを作成する前に &lt;code&gt;string&lt;/code&gt; に変換するためです。 つまり、 &lt;code&gt;100&lt;/code&gt; （ &lt;code&gt;number&lt;/code&gt; ）でのインデックス付けは、 &lt;code&gt;&quot;100&quot;&lt;/code&gt; （ &lt;code&gt;string&lt;/code&gt; ）でのインデックス付けと同じであるため、2つは一貫している必要があります。</target>
        </trans-unit>
        <trans-unit id="908cd031750feb81ec4d9c9d32a60c943d9995ba" translate="yes" xml:space="preserve">
          <source>There are two ways to define a value-based element:</source>
          <target state="translated">価値ベースの要素を定義するには、2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="26e25b640ababcffdfc4b06e185fa3e5e4e7f32b" translate="yes" xml:space="preserve">
          <source>There are two ways to do this. The first is to turn on &lt;code&gt;--strictNullChecks&lt;/code&gt; and specify a return type:</source>
          <target state="translated">これを行うには2つの方法があります。 最初の方法は、 &lt;code&gt;--strictNullChecks&lt;/code&gt; をオンにして、戻り値の型を指定することです。</target>
        </trans-unit>
        <trans-unit id="e7659fe4cc582ed4ad5cee6a5865f3aed8b3f631" translate="yes" xml:space="preserve">
          <source>There is a special subset of constant enum members that aren&amp;rsquo;t calculated: literal enum members. A literal enum member is a constant enum member with no initialized value, or with values that are initialized to</source>
          <target state="translated">計算されない定数列挙型メンバーの特別なサブセット、リテラル列挙型メンバーがあります。 リテラル列挙メンバーは、初期化された値がない、または初期化された値を持つ定数列挙メンバーです</target>
        </trans-unit>
        <trans-unit id="b3c75a37225472b5122690bb8c7852d356bbe63d" translate="yes" xml:space="preserve">
          <source>There is a well defined order to how decorators applied to various declarations inside of a class are applied:</source>
          <target state="translated">クラス内の様々な宣言に適用されるデコレータがどのように適用されるかについては、よく定義された順序があります。</target>
        </trans-unit>
        <trans-unit id="9b776dda290c6f5398f6b0885c60c8e056b32045" translate="yes" xml:space="preserve">
          <source>There is no template for &lt;code&gt;tsconfig.json&lt;/code&gt; in most project types.</source>
          <target state="translated">ほとんどのプロジェクトタイプには、 &lt;code&gt;tsconfig.json&lt;/code&gt; のテンプレートはありません。</target>
        </trans-unit>
        <trans-unit id="8504a07cb4ffd55d7fe6fdeea5cee63d290fd3d8" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a specific set of functions that &lt;code&gt;throw&lt;/code&gt; an error if something unexpected happened. They&amp;rsquo;re called &amp;ldquo;assertion&amp;rdquo; functions. As an example, Node.js has a dedicated function for this called &lt;code&gt;assert&lt;/code&gt;.</source>
          <target state="translated">予期しないことが発生した場合にエラーを &lt;code&gt;throw&lt;/code&gt; する特定の関数セットがあります。 これらは「アサーション」関数と呼ばれます。 例として、Node.jsには &lt;code&gt;assert&lt;/code&gt; という専用の関数があります。</target>
        </trans-unit>
        <trans-unit id="6ea7b067283b1800f3cf1697d8801fcd2967972e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also &lt;em&gt;optional call&lt;/em&gt;, which allows us to conditionally call expressions if they&amp;rsquo;re not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;オプションの呼び出し&lt;/em&gt;もあり&lt;em&gt;ます&lt;/em&gt; 。これにより、式が &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; でない場合に条件付きで式を呼び出すことができます 。</target>
        </trans-unit>
        <trans-unit id="45675102fd5d070224d9ebb4b617e2cd2622b44e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no built-in up-to-date checking, so you end up always running &lt;code&gt;tsc&lt;/code&gt; twice</source>
          <target state="translated">最新のチェックは組み込まれていないため、常に &lt;code&gt;tsc&lt;/code&gt; 2回実行することになります</target>
        </trans-unit>
        <trans-unit id="d45edf5a42ca019d0d64af47b3ea8fd1b0b8bcb9" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;.tsbuildinfo&lt;/code&gt; files can be safely deleted and don&amp;rsquo;t have any impact on our code at runtime - they&amp;rsquo;re purely used to make compilations faster. We can also name them anything that we want, and place them anywhere we want using the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target state="translated">これらの &lt;code&gt;.tsbuildinfo&lt;/code&gt; ファイルは安全に削除でき、実行時にコードに影響を与えることはありません-コンパイルを高速化するためだけに使用されます。 また、任意の名前を付けて、 &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; フラグを使用して任意の場所に配置することもできます。</target>
        </trans-unit>
        <trans-unit id="79dc017ea8ee6bb3f7c9fc491544134c877f20d3" translate="yes" xml:space="preserve">
          <source>These &lt;em&gt;&lt;code&gt;typeof&lt;/code&gt; type guards&lt;/em&gt; are recognized in two different forms: &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; and &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt;, where &lt;code&gt;&quot;typename&quot;&lt;/code&gt; must be &lt;code&gt;&quot;number&quot;&lt;/code&gt;, &lt;code&gt;&quot;string&quot;&lt;/code&gt;, &lt;code&gt;&quot;boolean&quot;&lt;/code&gt;, or &lt;code&gt;&quot;symbol&quot;&lt;/code&gt;. While TypeScript won&amp;rsquo;t stop you from comparing to other strings, the language won&amp;rsquo;t recognize those expressions as type guards.</source>
          <target state="translated">これらの&lt;em&gt; &lt;code&gt;typeof&lt;/code&gt; タイプガード&lt;/em&gt;は、2つの異なる形式で認識されます： &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; および &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt; 、ここで &lt;code&gt;&quot;typename&quot;&lt;/code&gt; は &lt;code&gt;&quot;number&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;string&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;boolean&quot;&lt;/code&gt; 、または &lt;code&gt;&quot;symbol&quot;&lt;/code&gt; TypeScriptが他の文字列との比較を妨げることはありませんが、言語はこれらの式をタイプガードとして認識しません。</target>
        </trans-unit>
        <trans-unit id="c89cac30c0863c54c7e154b255e1a2a8a10af609" translate="yes" xml:space="preserve">
          <source>These are seldom written explicitly, but they can be useful when narrowing issues and can catch bugs:</source>
          <target state="translated">これらは明示的に書かれることはほとんどありませんが、課題を絞るときに便利ですし、バグをキャッチすることもできます。</target>
        </trans-unit>
        <trans-unit id="dae12b77565aa4d0e3a64c99a87302ba66d61702" translate="yes" xml:space="preserve">
          <source>These assertion signatures are very similar to writing type predicate signatures:</source>
          <target state="translated">これらのアサーション署名は、型述語署名を書くのと非常に似ています。</target>
        </trans-unit>
        <trans-unit id="2868190107b9e856775b903db102ff1ea2bbe264" translate="yes" xml:space="preserve">
          <source>These could be imported as</source>
          <target state="translated">これらは、以下のようにインポートすることができます。</target>
        </trans-unit>
        <trans-unit id="580c6c93a64a3803a22f4ceb17224a9f774727aa" translate="yes" xml:space="preserve">
          <source>These examples are ordered in approximately increasing order of complexity.</source>
          <target state="translated">これらの例は、およそ複雑度の高い順に並べられています。</target>
        </trans-unit>
        <trans-unit id="51753d058d70c80473068ff593cd4ffa3d3364fb" translate="yes" xml:space="preserve">
          <source>These options also persist when sharing links to playground samples, allowing users to more reliably share examples without having to tell the recipient &amp;ldquo;oh, don&amp;rsquo;t forget to turn on the &lt;code&gt;noImplicitAny&lt;/code&gt; option!&amp;rdquo;.</source>
          <target state="translated">これらのオプションは、プレイグラウンドサンプルへのリンクを共有するときにも保持され、ユーザーは「ああ、 &lt;code&gt;noImplicitAny&lt;/code&gt; オプションをオンにすることを忘れないでください！」</target>
        </trans-unit>
        <trans-unit id="405bb1f92dbe539fc19f70e7ed40ea0eb0528ce7" translate="yes" xml:space="preserve">
          <source>These scoping rules can cause several types of mistakes. One problem they exacerbate is the fact that it is not an error to declare the same variable multiple times:</source>
          <target state="translated">これらのスコーピングルールは、いくつかのタイプのミスを引き起こす可能性があります。これらが悪化させる問題の一つは、同じ変数を複数回宣言することはエラーではないという事実です。</target>
        </trans-unit>
        <trans-unit id="5d8c7bb7c664a99b3f99538dd86cbd5a15a993cd" translate="yes" xml:space="preserve">
          <source>They also serve as a method to order the output when using &lt;code&gt;--out&lt;/code&gt; or &lt;code&gt;--outFile&lt;/code&gt;. Files are emitted to the output file location in the same order as the input after preprocessing pass.</source>
          <target state="translated">また、-- &lt;code&gt;--outFile&lt;/code&gt; または--outFileを使用するときに出力を順序付けるメソッドとして &lt;code&gt;--out&lt;/code&gt; ます。 ファイルは、前処理パスの後、入力と同じ順序で出力ファイルの場所に出力されます。</target>
        </trans-unit>
        <trans-unit id="a1ff8d1f085eb2bf495023df7ad3553e1c32cab7" translate="yes" xml:space="preserve">
          <source>They also support replacing the &lt;code&gt;exports&lt;/code&gt; object with a custom single object. Default exports are meant to act as a replacement for this behavior; however, the two are incompatible. TypeScript supports &lt;code&gt;export =&lt;/code&gt; to model the traditional CommonJS and AMD workflow.</source>
          <target state="translated">また、 &lt;code&gt;exports&lt;/code&gt; オブジェクトをカスタムの単一オブジェクトに置き換えることもサポートしています。 デフォルトのエクスポートは、この動作の代替として機能することを目的としています。 ただし、この2つには互換性がありません。 TypeScriptは &lt;code&gt;export =&lt;/code&gt; をサポートし、従来のCommonJSおよびAMDワークフローをモデル化します。</target>
        </trans-unit>
        <trans-unit id="7e47c0cafef6daabbdf34e9389714c2f70664891" translate="yes" xml:space="preserve">
          <source>They are like &lt;code&gt;let&lt;/code&gt; declarations but, as their name implies, their value cannot be changed once they are bound. In other words, they have the same scoping rules as &lt;code&gt;let&lt;/code&gt;, but you can&amp;rsquo;t re-assign to them.</source>
          <target state="translated">これらは &lt;code&gt;let&lt;/code&gt; 宣言のようなものですが、その名前が示すように、バインドされると値を変更できません。 つまり、それらは &lt;code&gt;let&lt;/code&gt; と同じスコープ規則を持っていますが、それらに再割り当てすることはできません。</target>
        </trans-unit>
        <trans-unit id="269cb00928fdbd9243a3c0e9855fdf73711ca39b" translate="yes" xml:space="preserve">
          <source>They will rarely have:</source>
          <target state="translated">彼らはほとんど持っていないでしょう。</target>
        </trans-unit>
        <trans-unit id="940ca9be4b3687b9409fbf0f5e6bf12d6da31f65" translate="yes" xml:space="preserve">
          <source>Things to look out for</source>
          <target state="translated">気をつけたいこと</target>
        </trans-unit>
        <trans-unit id="aba97e7fae57c949d932eff408211c64dbd34e1b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;package.json&lt;/code&gt; tells TypeScript to check whether the current version of TypeScript is running. If it&amp;rsquo;s 3.1 or later, it figures out the path you&amp;rsquo;ve imported relative to the package, and reads from the package&amp;rsquo;s &lt;code&gt;ts3.1&lt;/code&gt; folder. That&amp;rsquo;s what that &lt;code&gt;{ &quot;*&quot;: [&quot;ts3.1/*&quot;] }&lt;/code&gt; means - if you&amp;rsquo;re familiar with path mapping today, it works exactly like that.</source>
          <target state="translated">この &lt;code&gt;package.json&lt;/code&gt; は、TypeScriptに、現在のバージョンのTypeScriptが実行されているかどうかを確認するよう指示します。 3.1以降の場合、パッケージに関連してインポートしたパスを &lt;code&gt;ts3.1&lt;/code&gt; し、パッケージのts3.1フォルダーから読み取ります。 これが &lt;code&gt;{ &quot;*&quot;: [&quot;ts3.1/*&quot;] }&lt;/code&gt; 意味です。今日のパスマッピングに精通している場合は、まったく同じように機能します。</target>
        </trans-unit>
        <trans-unit id="9579349a7f6081ccc0cfa7ee1c3ba7cecdaeb554" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;tsconfig.json&lt;/code&gt; file will &lt;em&gt;only&lt;/em&gt; include &lt;code&gt;./node_modules/@types/node&lt;/code&gt;, &lt;code&gt;./node_modules/@types/lodash&lt;/code&gt; and &lt;code&gt;./node_modules/@types/express&lt;/code&gt;. Other packages under &lt;code&gt;node_modules/@types/*&lt;/code&gt; will not be included.</source>
          <target state="translated">この &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルには、. &lt;code&gt;./node_modules/@types/lodash&lt;/code&gt; / &lt;code&gt;./node_modules/@types/express&lt;/code&gt; types / node、 . /node_modules / @ &lt;code&gt;./node_modules/@types/node&lt;/code&gt; / lodashおよび./node_modules/@types/express &lt;em&gt;のみが&lt;/em&gt;含まれます。 &lt;code&gt;node_modules/@types/*&lt;/code&gt; 下の他のパッケージは含まれません。</target>
        </trans-unit>
        <trans-unit id="3d382992de7bc0c7358c5e70b64fbab9df6f3d2b" translate="yes" xml:space="preserve">
          <source>This adds the &lt;code&gt;copy-html&lt;/code&gt; task and adds it as a dependency of &lt;code&gt;default&lt;/code&gt;. That means any time &lt;code&gt;default&lt;/code&gt; is run, &lt;code&gt;copy-html&lt;/code&gt; has to run first. We&amp;rsquo;ve also changed &lt;code&gt;default&lt;/code&gt; to call Browserify with the tsify plugin instead of gulp-typescript. Conveniently, they both allow us to pass the same options object to the TypeScript compiler.</source>
          <target state="translated">これにより、 &lt;code&gt;copy-html&lt;/code&gt; タスクが追加され、 &lt;code&gt;default&lt;/code&gt; の依存関係として追加されます 。 つまり、 &lt;code&gt;default&lt;/code&gt; が実行されるたびに、 &lt;code&gt;copy-html&lt;/code&gt; を最初に実行する必要があります。 また、gulp-typescriptの代わりにtsifyプラグインでBrowserifyを呼び出すように &lt;code&gt;default&lt;/code&gt; を変更しました。 便利なことに、どちらも同じオプションオブジェクトをTypeScriptコンパイラに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="11d95bac2d09fc97059fde1a2be78410f1aaaa65" translate="yes" xml:space="preserve">
          <source>This also applies to numeric and string literals.</source>
          <target state="translated">これは、数値リテラルや文字列リテラルにも適用されます。</target>
        </trans-unit>
        <trans-unit id="adfedec845a057971771ae75a777e3b399a6fbc9" translate="yes" xml:space="preserve">
          <source>This also works in JSDoc comments to refer to types from other modules in &lt;code&gt;.js&lt;/code&gt;:</source>
          <target state="translated">これは、JSDocコメントでも機能し、 &lt;code&gt;.js&lt;/code&gt; の他のモジュールの型を参照します。</target>
        </trans-unit>
        <trans-unit id="a19ba44e9cf17a28dc6b2832d656e62612a977fa" translate="yes" xml:space="preserve">
          <source>This also works with classes:</source>
          <target state="translated">これはクラスでも通用します。</target>
        </trans-unit>
        <trans-unit id="7a7e8768f821cc2763fea56792bd65a0c49d075d" translate="yes" xml:space="preserve">
          <source>This asserts the variable &lt;code&gt;bar&lt;/code&gt; to have the type &lt;code&gt;foo&lt;/code&gt;. Since TypeScript also uses angle brackets for type assertions, combining it with JSX&amp;rsquo;s syntax would introduce certain parsing difficulties. As a result, TypeScript disallows angle bracket type assertions in &lt;code&gt;.tsx&lt;/code&gt; files.</source>
          <target state="translated">これは、変数 &lt;code&gt;bar&lt;/code&gt; のタイプが &lt;code&gt;foo&lt;/code&gt; であることを表明します。 TypeScriptも型アサーションに山括弧を使用しているため、JSXの構文と組み合わせることにより、特定の解析が困難になります。 その結果、TypeScriptは &lt;code&gt;.tsx&lt;/code&gt; ファイルでの山かっこ型のアサーションを許可しません。</target>
        </trans-unit>
        <trans-unit id="123d0f06d6b292d7403ffa347023235e01b1d1ba" translate="yes" xml:space="preserve">
          <source>This can be used to pipe output between commands as well.</source>
          <target state="translated">これは、コマンド間の出力をパイプするためにも使用できます。</target>
        </trans-unit>
        <trans-unit id="f4889f2abe4cb3d690ec344d9cb1060645946ee3" translate="yes" xml:space="preserve">
          <source>This can cause quite a bit of fallout for existing code that use inheritance. First of all, &lt;code&gt;set&lt;/code&gt; accessors from base classes won&amp;rsquo;t get triggered - they&amp;rsquo;ll be completely overwritten.</source>
          <target state="translated">これは、継承を使用する既存のコードにかなりのフォールアウトを引き起こす可能性があります。 まず、基本クラスの &lt;code&gt;set&lt;/code&gt; アクセサーはトリガーされません-それらは完全に上書きされます。</target>
        </trans-unit>
        <trans-unit id="2cf2abd7a18f1f7062668c3033dddcc6ad2c2d8e" translate="yes" xml:space="preserve">
          <source>This can even be used to enable &lt;code&gt;enum&lt;/code&gt;-like patterns in plain JavaScript code if you choose not to use TypeScript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt; construct.</source>
          <target state="translated">TypeScriptの &lt;code&gt;enum&lt;/code&gt; 構造を使用しない場合は、これを使用して、プレーンなJavaScriptコードで &lt;code&gt;enum&lt;/code&gt; のようなパターンを有効にすることもできます。</target>
        </trans-unit>
        <trans-unit id="13a6f89fe3172b6cbc2af9517a59da3931faf315" translate="yes" xml:space="preserve">
          <source>This can go beyond basic functions with &lt;code&gt;@param&lt;/code&gt; tags too, where the following example:</source>
          <target state="translated">これは、 &lt;code&gt;@param&lt;/code&gt; タグを使用した基本的な機能を超える場合もあります。次の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="40d488fa879599b4c63bd3bca5b46fe16933b383" translate="yes" xml:space="preserve">
          <source>This change entails a break in the behavior of extending built-in classes like &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc.. Please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-changes.html#extending-built-ins-like-error-array-and-map-may-no-longer-work&quot;&gt;extending built-ins breaking change documentation&lt;/a&gt; for more details.</source>
          <target state="translated">この変更により、 &lt;code&gt;Error&lt;/code&gt; 、 &lt;code&gt;Array&lt;/code&gt; 、 &lt;code&gt;Map&lt;/code&gt; などの組み込みクラスを拡張する動作が中断されます。詳細については、 &lt;a href=&quot;https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-changes.html#extending-built-ins-like-error-array-and-map-may-no-longer-work&quot;&gt;組み込み&lt;/a&gt;の拡張破壊ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="0a82b6976a332dfa14dda6dd898339b3d9c8f2c3" translate="yes" xml:space="preserve">
          <source>This check is a breaking change, but for that reason the checks are very conservative. This error is only issued in &lt;code&gt;if&lt;/code&gt; conditions, and it is not issued on optional properties, if &lt;code&gt;strictNullChecks&lt;/code&gt; is off, or if the function is later called within the body of the &lt;code&gt;if&lt;/code&gt;:</source>
          <target state="translated">このチェックは重大な変更ですが、そのため、チェックは非常に保守的です。 このエラーは &lt;code&gt;if&lt;/code&gt; 条件でのみ発行され、 &lt;code&gt;strictNullChecks&lt;/code&gt; がオフの場合、または関数がifの本体内で後で呼び出される場合、オプションのプロパティでは発行されません。</target>
        </trans-unit>
        <trans-unit id="776023497afd78ba896c5a8759ad07ba14168072" translate="yes" xml:space="preserve">
          <source>This comparison process proceeds recursively, exploring the type of each member and sub-member.</source>
          <target state="translated">この比較処理は、各メンバーとサブメンバーの種類を探りながら、再帰的に進行する。</target>
        </trans-unit>
        <trans-unit id="a70378c4e2e85fc0285bab20719f721947598d23" translate="yes" xml:space="preserve">
          <source>This config file will include &lt;em&gt;all&lt;/em&gt; packages under &lt;code&gt;./typings&lt;/code&gt;, and no packages from &lt;code&gt;./node_modules/@types&lt;/code&gt;.</source>
          <target state="translated">この構成ファイルには、. &lt;code&gt;./node_modules/@types&lt;/code&gt; 下の&lt;em&gt;すべての&lt;/em&gt;パッケージが含まれ、. /node_modules/@typesのパッケージは含まれません。</target>
        </trans-unit>
        <trans-unit id="3d8fdc1796e3b4fc005d6e6e0a36a51b7eee8ba1" translate="yes" xml:space="preserve">
          <source>This creates a &lt;code&gt;package.json&lt;/code&gt; file with default values.</source>
          <target state="translated">これにより、デフォルト値で &lt;code&gt;package.json&lt;/code&gt; ファイルが作成されます。</target>
        </trans-unit>
        <trans-unit id="2651ac880cf2ead1dcccdb902c01397e29e5f2d0" translate="yes" xml:space="preserve">
          <source>This creates new variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from &lt;code&gt;o.a&lt;/code&gt; and &lt;code&gt;o.b&lt;/code&gt;. Notice that you can skip &lt;code&gt;c&lt;/code&gt; if you don&amp;rsquo;t need it.</source>
          <target state="translated">これにより、 &lt;code&gt;o.a&lt;/code&gt; と &lt;code&gt;o.b&lt;/code&gt; から新しい変数 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; が作成されます。 必要ない場合は &lt;code&gt;c&lt;/code&gt; をスキップできることに注意してください。</target>
        </trans-unit>
        <trans-unit id="cbec995fccd02fc21b46f9fd4af298cd4d2053ad" translate="yes" xml:space="preserve">
          <source>This creates two new variables named &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. This is equivalent to using indexing, but is much more convenient:</source>
          <target state="translated">これにより、 &lt;code&gt;first&lt;/code&gt; および &lt;code&gt;second&lt;/code&gt; という名前の2つの新しい変数が作成されます。 これはインデックスを使用するのと同じですが、はるかに便利です。</target>
        </trans-unit>
        <trans-unit id="c3290579796b51867665bf805e46b6cb71dde74e" translate="yes" xml:space="preserve">
          <source>This directive allows a file to explicitly include an existing built-in &lt;em&gt;lib&lt;/em&gt; file.</source>
          <target state="translated">このディレクティブにより、ファイルに既存の組み込み&lt;em&gt;lib&lt;/em&gt;ファイルを明示的に含めることができます。</target>
        </trans-unit>
        <trans-unit id="1a906b1f2cf088a2c6bf34b58e9c21658e73cc20" translate="yes" xml:space="preserve">
          <source>This directive instructs the compiler to &lt;em&gt;not&lt;/em&gt; include the default library (i.e. &lt;code&gt;lib.d.ts&lt;/code&gt;) in the compilation. The impact here is similar to passing &lt;code&gt;--noLib&lt;/code&gt; on the command line.</source>
          <target state="translated">このディレクティブは、デフォルトのライブラリ（つまり &lt;code&gt;lib.d.ts&lt;/code&gt; ）をコンパイルに含め&lt;em&gt;ない&lt;/em&gt;ようにコンパイラーに指示します。 ここでの影響は、コマンドラインで &lt;code&gt;--noLib&lt;/code&gt; を渡すことに似ています。</target>
        </trans-unit>
        <trans-unit id="e85416c60d1e180f7e4e1a690b36612a078e4bd6" translate="yes" xml:space="preserve">
          <source>This directive marks a file as a &lt;em&gt;default library&lt;/em&gt;. You will see this comment at the top of &lt;code&gt;lib.d.ts&lt;/code&gt; and its different variants.</source>
          <target state="translated">このディレクティブは、ファイルを&lt;em&gt;デフォルトのライブラリ&lt;/em&gt;としてマークします。 このコメントは、 &lt;code&gt;lib.d.ts&lt;/code&gt; およびそのさまざまなバリアントの上部に表示されます。</target>
        </trans-unit>
        <trans-unit id="abd1b0ae2b28ffc07ff533b5aa3e34f0a7dbd996" translate="yes" xml:space="preserve">
          <source>This distinction is subtle and important &amp;ndash; here, &lt;code&gt;A.B&lt;/code&gt; is not necessarily a type or a value.</source>
          <target state="translated">この区別は微妙で重要です。ここでは、 &lt;code&gt;A.B&lt;/code&gt; は必ずしも型または値ではありません。</target>
        </trans-unit>
        <trans-unit id="1ff3a8b47ad881c651ae743e22e2477b1a56f987" translate="yes" xml:space="preserve">
          <source>This example covers a few other features we didn&amp;rsquo;t previously mention. Again, we see the &lt;code&gt;extends&lt;/code&gt; keywords used to create two new subclasses of &lt;code&gt;Animal&lt;/code&gt;: &lt;code&gt;Horse&lt;/code&gt; and &lt;code&gt;Snake&lt;/code&gt;.</source>
          <target state="translated">この例では、これまで言及しなかった他のいくつかの機能について説明します。 繰り返しますが、 &lt;code&gt;Animal&lt;/code&gt; の 2つの新しいサブクラス、 &lt;code&gt;Horse&lt;/code&gt; と &lt;code&gt;Snake&lt;/code&gt; を作成するために使用される &lt;code&gt;extends&lt;/code&gt; キーワードがあります。</target>
        </trans-unit>
        <trans-unit id="151213ee16168c64e5b83bc91d8ae73927961489" translate="yes" xml:space="preserve">
          <source>This example shows the most basic inheritance feature: classes inherit properties and methods from base classes. Here, &lt;code&gt;Dog&lt;/code&gt; is a &lt;em&gt;derived&lt;/em&gt; class that derives from the &lt;code&gt;Animal&lt;/code&gt;&lt;em&gt;base&lt;/em&gt; class using the &lt;code&gt;extends&lt;/code&gt; keyword. Derived classes are often called &lt;em&gt;subclasses&lt;/em&gt;, and base classes are often called &lt;em&gt;superclasses&lt;/em&gt;.</source>
          <target state="translated">この例は、最も基本的な継承機能を示しています。クラスは基本クラスからプロパティとメソッドを継承します。 ここで、 &lt;code&gt;Dog&lt;/code&gt; は &lt;code&gt;extends&lt;/code&gt; キーワードを使用して &lt;code&gt;Animal&lt;/code&gt; &lt;em&gt;基本&lt;/em&gt;クラスから&lt;em&gt;派生する派生&lt;/em&gt;クラスです。 派生クラスはしばしば&lt;em&gt;サブクラス&lt;/em&gt;と呼ばれ、基本クラスはしばしば&lt;em&gt;スーパークラス&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="80d233484614ac1a8184eec3cb1a1f5b233a8926" translate="yes" xml:space="preserve">
          <source>This feature can be extremely useful for bigger organizations, or projects with lots of distributed dependencies.</source>
          <target state="translated">この機能は、大規模な組織や、多くの分散依存関係を持つプロジェクトでは非常に便利です。</target>
        </trans-unit>
        <trans-unit id="145fabdb6e03da0d5218bdc18d27ee6b68f3aaae" translate="yes" xml:space="preserve">
          <source>This feature is currently supported in Visual Studio 2015 with TypeScript 1.8.4 and above, and &lt;a href=&quot;https://github.com/TypeStrong/atom-typescript#compile-on-save&quot;&gt;atom-typescript&lt;/a&gt; plugin.</source>
          <target state="translated">この機能は現在、Visual Studio 2015でTypeScript 1.8.4以降と&lt;a href=&quot;https://github.com/TypeStrong/atom-typescript#compile-on-save&quot;&gt;atom-typescript&lt;/a&gt;プラグインでサポートされています。</target>
        </trans-unit>
        <trans-unit id="e14bf01780560294d3e709ab1eca2529b0526ee5" translate="yes" xml:space="preserve">
          <source>This feature means that types that would otherwise be used just to hint immutability to the compiler can often be omitted.</source>
          <target state="translated">この機能は、そうでなければコンパイラに不変性をほのめかすためだけに使用されていた型を省略できることが多いことを意味します。</target>
        </trans-unit>
        <trans-unit id="e0a1a44534d41eb6308a076407d6c354572ba0dd" translate="yes" xml:space="preserve">
          <source>This feature was supported before TypeScript 2.1, but only when targeting ES6/ES2015. TypeScript 2.1 brings the capability to ES3 and ES5 run-times, meaning you&amp;rsquo;ll be free to take advantage of it no matter what environment you&amp;rsquo;re using.</source>
          <target state="translated">この機能は、TypeScript 2.1より前にサポートされていましたが、ES6 / ES2015をターゲットにしている場合のみです。 TypeScript 2.1は、ES3およびES5ランタイムに機能を提供します。つまり、使用している環境に関係なく、自由に活用できます。</target>
        </trans-unit>
        <trans-unit id="4256b8036fc24344e27e1a2d98579274cc10c2e9" translate="yes" xml:space="preserve">
          <source>This gives bothPlus the value &lt;code&gt;[0, 1, 2, 3, 4, 5]&lt;/code&gt;. Spreading creates a shallow copy of &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. They are not changed by the spread.</source>
          <target state="translated">これにより、bothPlusに値 &lt;code&gt;[0, 1, 2, 3, 4, 5]&lt;/code&gt; 0、1、2、3、4、5]が与えられます。 拡散により、 &lt;code&gt;first&lt;/code&gt; と &lt;code&gt;second&lt;/code&gt; の浅いコピーが作成されます。 スプレッドによって変更されることはありません。</target>
        </trans-unit>
        <trans-unit id="fe579196df9fee069d4bd852ac7c86cc2a13b998" translate="yes" xml:space="preserve">
          <source>This gives the user a way of describing inner classes.</source>
          <target state="translated">これにより、ユーザは内部クラスを記述する方法を得ることができます。</target>
        </trans-unit>
        <trans-unit id="386298615e90cceffaa57d2fad7dceaa3f784476" translate="yes" xml:space="preserve">
          <source>This guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.</source>
          <target state="translated">また、このガイダンスでは、宣言ファイルの利用者を壊すことなく、ライブラリをUMDに移行できるようにしています。</target>
        </trans-unit>
        <trans-unit id="c41bd8fce97e1f72ad86c3801d0c1855c4f2bfd0" translate="yes" xml:space="preserve">
          <source>This guide is designed to teach you how to write a high-quality TypeScript Declaration File.</source>
          <target state="translated">このガイドは、高品質なTypeScript宣言ファイルの書き方を教えることを目的としています。</target>
        </trans-unit>
        <trans-unit id="8afad13e48d5c317fc76b6fb0c7d091ef32c2108" translate="yes" xml:space="preserve">
          <source>This guide will teach you how to wire up TypeScript with &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;.</source>
          <target state="translated">このガイドでは、TypeScriptを&lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt;と&lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpackに関連付ける&lt;/a&gt;方法を説明します。</target>
        </trans-unit>
        <trans-unit id="bb134067e9aa9299c18b8ce51100d390f03f98ca" translate="yes" xml:space="preserve">
          <source>This happens often enough in JavaScript that TypeScript provides a way to create new types based on old types &amp;mdash; &lt;strong&gt;mapped types&lt;/strong&gt;. In a mapped type, the new type transforms each property in the old type in the same way. For example, you can make all properties of a type &lt;code&gt;readonly&lt;/code&gt; or optional. Here are a couple of examples:</source>
          <target state="translated">これはJavaScriptで十分に頻繁に発生するため、TypeScriptは古いタイプに基づいて新しいタイプ、つまり&lt;strong&gt;マップされたタイプ&lt;/strong&gt;を作成する方法を提供し&lt;strong&gt;ます&lt;/strong&gt; 。 マップされた型では、新しい型が古い型の各プロパティを同じ方法で変換します。 たとえば、タイプのすべてのプロパティを &lt;code&gt;readonly&lt;/code&gt; またはオプションにすることができます。 次に例を示します。</target>
        </trans-unit>
        <trans-unit id="a56075c1c437a8f7f7b75ea4c76282bd39cf7b1d" translate="yes" xml:space="preserve">
          <source>This has a very specific meaning: the &lt;code&gt;done&lt;/code&gt; callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the &lt;code&gt;elapsedTime&lt;/code&gt; parameter, but there&amp;rsquo;s no need to make the parameter optional to accomplish this &amp;ndash; it&amp;rsquo;s always legal to provide a callback that accepts fewer arguments.</source>
          <target state="translated">これには非常に具体的な意味があります： &lt;code&gt;done&lt;/code&gt; コールバックは、1つの引数で呼び出される場合と、2つの引数で呼び出される場合があります。 作成者は、おそらくコールバックは、 &lt;code&gt;elapsedTime&lt;/code&gt; パラメーターを気にしないかもしれないと言ったつもりですが、これを達成するためにパラメーターをオプションにする必要はありません-より少ない引数を受け入れるコールバックを提供することは常に合法です。</target>
        </trans-unit>
        <trans-unit id="d47bf0bc67be092f1cae46d5237f049154597b89" translate="yes" xml:space="preserve">
          <source>This has been one common source of duplicate definition errors. Multiple declaration files defining the same members on interfaces.</source>
          <target state="translated">これは、重複した定義エラーの共通の原因の一つとなっています。インターフェース上で同じメンバを定義している複数の宣言ファイル。</target>
        </trans-unit>
        <trans-unit id="008c0c2cfe2dcafe3f531baa951507b0d1d186a6" translate="yes" xml:space="preserve">
          <source>This has the same problems we mentioned above - we could easily have misspelled &lt;code&gt;getDistance&lt;/code&gt; and not gotten an error. For this reason, TypeScript has the &lt;code&gt;noImplicitThis&lt;/code&gt; option. When that option is set, TypeScript will issue an error when &lt;code&gt;this&lt;/code&gt; is used without an explicit (or inferred) type. The fix is to use a &lt;code&gt;this&lt;/code&gt;-parameter to give an explicit type in the interface or in the function itself:</source>
          <target state="translated">これには、上記で説明したのと同じ問題があります &lt;code&gt;getDistance&lt;/code&gt; スペルを簡単に間違えて、エラーを取得できない可能性があります。 このため、TypeScriptには &lt;code&gt;noImplicitThis&lt;/code&gt; オプションがあります。 このオプションが設定されている場合、明示的な（または推測された）タイプなしで使用すると、TypeScriptはエラーを発行します。 修正方法は、 &lt;code&gt;this&lt;/code&gt; パラメーターを使用して、インターフェイスまたは関数自体で明示的な型を指定することです。</target>
        </trans-unit>
        <trans-unit id="6ef37d4a82df716fb39c511922cd4fd9b3ab58c4" translate="yes" xml:space="preserve">
          <source>This is a breaking change; previously, the &lt;code&gt;keyof&lt;/code&gt; operator and mapped types only supported &lt;code&gt;string&lt;/code&gt; named properties. Code that assumed values typed with &lt;code&gt;keyof T&lt;/code&gt; were always &lt;code&gt;string&lt;/code&gt;s, will now be flagged as error.</source>
          <target state="translated">これは重大な変更です。 以前は、 &lt;code&gt;keyof&lt;/code&gt; 演算子とマップされた型は、プロパティという名前の &lt;code&gt;string&lt;/code&gt; のみをサポートしていました。 &lt;code&gt;keyof T&lt;/code&gt; で入力された値を想定したコードは常に &lt;code&gt;string&lt;/code&gt; であり 、エラーとしてフラグが付けられます。</target>
        </trans-unit>
        <trans-unit id="37550d8cfccd82b7f09cb9ee94a9e55bd690b1de" translate="yes" xml:space="preserve">
          <source>This is a pretty literal use of the &lt;code&gt;GenericNumber&lt;/code&gt; class, but you may have noticed that nothing is restricting it to only use the &lt;code&gt;number&lt;/code&gt; type. We could have instead used &lt;code&gt;string&lt;/code&gt; or even more complex objects.</source>
          <target state="translated">これは、 &lt;code&gt;GenericNumber&lt;/code&gt; クラスの文字通りの使用法ですが、 &lt;code&gt;number&lt;/code&gt; 型のみを使用するように制限しているものはないことに気付いているかもしれません。 代わりに、 &lt;code&gt;string&lt;/code&gt; またはさらに複雑なオブジェクトを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="0cbc708221291cf1aa363c4299a6de0178bc9f00" translate="yes" xml:space="preserve">
          <source>This is a reasonable restriction because any use of &lt;code&gt;Foo&lt;/code&gt; would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which&amp;hellip; well, hopefully you get the idea! In the end, there isn&amp;rsquo;t a type that makes sense in place of &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">これは合理的な制限です &lt;code&gt;Foo&lt;/code&gt; を使用する場合はFooに置き換える必要があり、 Fooに置き換える必要がある場合はFooに置き換える必要があります。 最後に、 &lt;code&gt;Foo&lt;/code&gt; の代わりに意味のある型はありません。</target>
        </trans-unit>
        <trans-unit id="b8060ed060d509f7038e676326653a9e51460e83" translate="yes" xml:space="preserve">
          <source>This is achieved by introducing two new types, &lt;code&gt;CallableFunction&lt;/code&gt; and &lt;code&gt;NewableFunction&lt;/code&gt;, in &lt;code&gt;lib.d.ts&lt;/code&gt;. These types contain specialized generic method declarations for &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; for regular functions and constructor functions, respectively. The declarations use generic rest parameters (see #24897) to capture and reflect parameter lists in a strongly typed manner. In &lt;code&gt;--strictBindCallApply&lt;/code&gt; mode these declarations are used in place of the (very permissive) declarations provided by type &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;NewableFunction&lt;/code&gt; に &lt;code&gt;CallableFunction&lt;/code&gt; とNewableFunctionの 2つの新しいタイプを導入することで達成されます。 これらの型には、 &lt;code&gt;bind&lt;/code&gt; 、 &lt;code&gt;call&lt;/code&gt; 、および通常の関数とコンストラクター関数にそれぞれ &lt;code&gt;apply&lt;/code&gt; ための特殊な汎用メソッド宣言が含まれています。 宣言では、汎用の残りのパラメーター（＃24897を参照）を使用して、厳密に型指定された方法でパラメーターリストをキャプチャおよび反映します。 &lt;code&gt;--strictBindCallApply&lt;/code&gt; モードでは、これらの宣言は &lt;code&gt;Function&lt;/code&gt; 型によって提供される（非常に寛容な）宣言の代わりに使用されます。</target>
        </trans-unit>
        <trans-unit id="6dbad74ad3287bbe68b69203c6f2782129725610" translate="yes" xml:space="preserve">
          <source>This is because when a class implements an interface, only the instance side of the class is checked. Since the constructor sits in the static side, it is not included in this check.</source>
          <target state="translated">これは、クラスがインターフェイスを実装したときに、そのクラスのインスタンス側だけをチェックするからです。コンストラクタは静的側にあるので、このチェックには含まれません。</target>
        </trans-unit>
        <trans-unit id="4b6c3dca4167679c5010d6f3fba2e9108213f5e9" translate="yes" xml:space="preserve">
          <source>This is called &amp;ldquo;contextual typing&amp;rdquo;, a form of type inference. This helps cut down on the amount of effort to keep your program typed.</source>
          <target state="translated">これは「コンテキストタイピング」と呼ばれ、型推論の一種です。 これにより、プログラムの入力を維持するための労力を削減できます。</target>
        </trans-unit>
        <trans-unit id="3aa66e1a6cbac680bebe3f7aa3dc555a813d0306" translate="yes" xml:space="preserve">
          <source>This is equivalent to declaring &lt;code&gt;sentence&lt;/code&gt; like so:</source>
          <target state="translated">これは、次のような &lt;code&gt;sentence&lt;/code&gt; を宣言することと同等です。</target>
        </trans-unit>
        <trans-unit id="b92657e6155d73fb913bca9c2a7e95110494bb4c" translate="yes" xml:space="preserve">
          <source>This is fairly &lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Recursive_data_type&amp;amp;oldid=913091335#in_type_synonyms&quot;&gt;consistent with how other languages treat type aliases&lt;/a&gt;, but it does give rise to some slightly surprising scenarios for how users leverage the feature. For example, in TypeScript 3.6 and prior, the following causes an error.</source>
          <target state="translated">これは&lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Recursive_data_type&amp;amp;oldid=913091335#in_type_synonyms&quot;&gt;、他の言語が型エイリアスを処理する方法&lt;/a&gt;とかなり一貫していますが 、ユーザーがこの機能をどのように活用するかについて、若干驚くべきシナリオが発生します。 たとえば、TypeScript 3.6以前では、次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="723f96f4f031c1015e42839d7f70baaf5dc4dd7e" translate="yes" xml:space="preserve">
          <source>This is legal as long as it does not create a conflict. A general rule of thumb is that values always conflict with other values of the same name unless they are declared as &lt;code&gt;namespace&lt;/code&gt;s, types will conflict if they are declared with a type alias declaration (&lt;code&gt;type s = string&lt;/code&gt;), and namespaces never conflict.</source>
          <target state="translated">これは、競合を引き起こさない限り合法です。 一般的な経験則として、値は &lt;code&gt;namespace&lt;/code&gt; sとして宣言されない限り、値は常に同じ名前の他の値と競合し、型エイリアス宣言（ &lt;code&gt;type s = string&lt;/code&gt; ）で宣言された場合は型が競合し、名前空間は競合しません。</target>
        </trans-unit>
        <trans-unit id="b261fafdaf58d005a713f2cde7159a578a335b74" translate="yes" xml:space="preserve">
          <source>This is no longer the case - TypeScript now infers &lt;code&gt;this&lt;/code&gt; to have a special type called &lt;code&gt;this&lt;/code&gt; whenever inside an instance method of a class. The &lt;code&gt;this&lt;/code&gt; type is written as so, and basically means &amp;ldquo;the type of the left side of the dot in a method call&amp;rdquo;.</source>
          <target state="translated">これはもはや当てはまりません。TypeScriptは、クラスのインスタンスメソッド内にあるときに、 &lt;code&gt;this&lt;/code&gt; と呼ばれる特別な型を持つように推論するようになりました。 &lt;code&gt;this&lt;/code&gt; 型はそのように書かれており、基本的には「メソッド呼び出しのドットの左側の型」を意味します。</target>
        </trans-unit>
        <trans-unit id="58590b20aaf8fc85de88a20890a72ce9479b5bd1" translate="yes" xml:space="preserve">
          <source>This is now the default for MSBuild projects; this allows MSBuild incremental build to work as expected, as outputs are only generated on clean builds.</source>
          <target state="translated">これはMSBuildプロジェクトのデフォルトとなりました。これにより、出力はクリーンビルド時にのみ生成されるため、MSBuildのインクリメンタルビルドが期待通りに動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="94d5f4a5616552cb256911b32b728b92d26e4819" translate="yes" xml:space="preserve">
          <source>This is only enabled if &lt;code&gt;--noImplicitAny&lt;/code&gt; is set.</source>
          <target state="translated">これは、 &lt;code&gt;--noImplicitAny&lt;/code&gt; が設定されている場合にのみ有効になります。</target>
        </trans-unit>
        <trans-unit id="d335ad9d283ed57e40045d0665963af63d3174d9" translate="yes" xml:space="preserve">
          <source>This is optimal for consumers. They can name your type whatever they want (&lt;code&gt;t&lt;/code&gt; in this case) and don&amp;rsquo;t have to do any excessive dotting to find your objects.</source>
          <target state="translated">これは消費者に最適です。 彼らはあなたが望むようにあなたのタイプに名前を付けることができ（この場合は &lt;code&gt;t&lt;/code&gt; ）、あなたのオブジェクトを見つけるために余分な点を打つ必要はありません。</target>
        </trans-unit>
        <trans-unit id="98bb0c78662d4345a34d8056d87df00bb4d5a674" translate="yes" xml:space="preserve">
          <source>This is still strictly more capable in TypeScript 3.3, and adding an explicit type annotation will work.</source>
          <target state="translated">これは、TypeScript 3.3ではまだ厳密には可能であり、明示的な型アノテーションを追加することで機能します。</target>
        </trans-unit>
        <trans-unit id="a079a3a6734c4cd08da0e17c421a695ab213a09a" translate="yes" xml:space="preserve">
          <source>This is strange because there is technically nothing wrong with any use users could always write what was effectively the same code by introducing an interface.</source>
          <target state="translated">技術的には何の問題もないのに、インターフェイスを導入することで、ユーザーはいつでも事実上同じコードを書くことができるのですから、これは不思議です。</target>
        </trans-unit>
        <trans-unit id="14f1b6e0e05e87d37ff1f7dd8b578b6eb45b8f85" translate="yes" xml:space="preserve">
          <source>This is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing &lt;code&gt;undefined&lt;/code&gt; in that position is equivalent for most functions.</source>
          <target state="translated">これは型システムの観点からは不健全ですが、実行時の観点からは、オプションのパラメーターの考え方は、その位置で &lt;code&gt;undefined&lt;/code&gt; を渡すことはほとんどの関数と同等であるため、一般的には適切ではありません</target>
        </trans-unit>
        <trans-unit id="f1a4eb58dc966cceb7143e20830932600b5ea02f" translate="yes" xml:space="preserve">
          <source>This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties. The subclasses don&amp;rsquo;t have to be related besides inheriting from the base class. For example:</source>
          <target state="translated">これは、大きな継承階層があるが、特定のプロパティを持つサブクラスのみでコードが機能するように指定する場合に役立ちます。 サブクラスは、基本クラスから継承する以外に関連する必要はありません。 例えば：</target>
        </trans-unit>
        <trans-unit id="fbc601dd0ab93d792728208f62b2497f50e502de" translate="yes" xml:space="preserve">
          <source>This kind of iterator is useful for iterating over synchronously available values, such as the elements of an Array or the keys of a Map. An object that supports iteration is said to be &amp;ldquo;iterable&amp;rdquo; if it has a &lt;code&gt;Symbol.iterator&lt;/code&gt; method that returns an &lt;code&gt;Iterator&lt;/code&gt; object.</source>
          <target state="translated">この種のイテレータは、配列の要素やマップのキーなど、同期的に使用可能な値を反復処理するのに役立ちます。 反復をサポートするオブジェクトは、 &lt;code&gt;Iterator&lt;/code&gt; オブジェクトを返す &lt;code&gt;Symbol.iterator&lt;/code&gt; メソッドがある場合、「反復可能」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="ee56cf9ba9542ce8a0312b6a94a0d6397c614c45" translate="yes" xml:space="preserve">
          <source>This may seem confusing, but it&amp;rsquo;s actually very convenient as long as we don&amp;rsquo;t excessively overload things. Let&amp;rsquo;s look at some useful aspects of this combining behavior.</source>
          <target state="translated">これは紛らわしいように思えるかもしれませんが、過度に負荷をかけない限り、実際には非常に便利です。 この結合動作のいくつかの有用な側面を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="242737969d68a63e3722770b6fdc0a0887aa17a9" translate="yes" xml:space="preserve">
          <source>This means that code like the following that was trying to represent JSON&amp;hellip;</source>
          <target state="translated">これは、JSONを表現しようとした次のようなコードを意味します&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="9e01eba045901bb9f42a3c7a52e17b1f10e058c3" translate="yes" xml:space="preserve">
          <source>This means that union types and &lt;code&gt;instanceof&lt;/code&gt; properly distinguish between structurally identical classes.</source>
          <target state="translated">これは、ユニオン型と &lt;code&gt;instanceof&lt;/code&gt; が構造的に同一のクラスを適切に区別することを意味します。</target>
        </trans-unit>
        <trans-unit id="944f762b99fb22d02c5865084d87d43b8946d4d0" translate="yes" xml:space="preserve">
          <source>This means that you can conditionally and lazily import other modules and libraries. For example, here&amp;rsquo;s an &lt;code&gt;async&lt;/code&gt; function that only imports a utility library when it&amp;rsquo;s needed:</source>
          <target state="translated">これは、他のモジュールとライブラリを条件付きで遅延インポートできることを意味します。 たとえば、ユーティリティライブラリが必要な場合にのみインポートする &lt;code&gt;async&lt;/code&gt; 関数を次に示します。</target>
        </trans-unit>
        <trans-unit id="aa9a3a7f47b92be453ff0b6c4375f9ba7afa10b1" translate="yes" xml:space="preserve">
          <source>This mode adds flexibility for mixing and matching the way 3rd party libraries, where globals that libraries declare can always be consumed, even from within modules.</source>
          <target state="translated">このモードでは、サードパーティ製のライブラリを混合してマッチングさせるための柔軟性が追加され、ライブラリが宣言したグローバルは、モジュール内からでも常に消費することができます。</target>
        </trans-unit>
        <trans-unit id="7f33b0a22b86a2f41c336d65267df2bb8cf5e332" translate="yes" xml:space="preserve">
          <source>This model of namespace merging is a helpful starting place, but we also need to understand what happens with non-exported members. Non-exported members are only visible in the original (un-merged) namespace. This means that after merging, merged members that came from other declarations cannot see non-exported members.</source>
          <target state="translated">この名前空間マージのモデルは出発点として役立ちますが、エクスポートされないメンバについても理解しておく必要があります。非輸出メンバは、元の (マージされていない)名前空間でのみ表示されます。これは、マージ後、他の宣言から来たマージされたメンバは、エクスポートされないメンバを見ることができないことを意味します。</target>
        </trans-unit>
        <trans-unit id="5dae3ac251886a93244e214f8a5ad7364681d1d0" translate="yes" xml:space="preserve">
          <source>This new behavior only kicks in when at most one type in the union has multiple overloads, and at most one type in the union has a generic signature. That means methods on &lt;code&gt;number[] | string[]&lt;/code&gt; like &lt;code&gt;map&lt;/code&gt; (which is generic) still won&amp;rsquo;t be callable.</source>
          <target state="translated">この新しい動作は、ユニオンの最大で1つのタイプに複数のオーバーロードがあり、ユニオンの最大で1つのタイプに汎用シグネチャがある場合にのみ有効です。 つまり、 &lt;code&gt;number[] | string[]&lt;/code&gt; &lt;code&gt;map&lt;/code&gt; （汎用）のようなstring []は、まだ呼び出し可能ではありません。</target>
        </trans-unit>
        <trans-unit id="5b0887b7c0dc11302a46adcaa14cce74855a6095" translate="yes" xml:space="preserve">
          <source>This new relaxation also lets us recursively reference type aliases in tuples as well. The following code which used to error is now valid TypeScript code.</source>
          <target state="translated">この新しい緩和により、タプル内の型のエイリアスも再帰的に参照できるようになりました。これまでエラーになっていた以下のコードは、有効な TypeScript コードになりました。</target>
        </trans-unit>
        <trans-unit id="73d275a1e3784849d22fea2ec009273ed158e2df" translate="yes" xml:space="preserve">
          <source>This odd-looking pattern is actually pretty common. The &lt;code&gt;i&lt;/code&gt; in the parameter list actually shadows the &lt;code&gt;i&lt;/code&gt; declared in the &lt;code&gt;for&lt;/code&gt; loop, but since we named them the same, we didn&amp;rsquo;t have to modify the loop body too much.</source>
          <target state="translated">この奇妙なパターンは実際にはかなり一般的です。 パラメータリストの &lt;code&gt;i&lt;/code&gt; は、実際には &lt;code&gt;for&lt;/code&gt; ループで宣言された &lt;code&gt;i&lt;/code&gt; をシャドウしますが、同じ名前を付けたため、ループの本体をあまり変更する必要はありませんでした。</target>
        </trans-unit>
        <trans-unit id="5c7ee90113f636f43404e4d744fd715593d575c9" translate="yes" xml:space="preserve">
          <source>This often opens up very elegant ways of writing code; however, there was a problem for classes that wanted to extend from &lt;code&gt;BasicCalculator&lt;/code&gt;. Imagine a user wanted to start writing a &lt;code&gt;ScientificCalculator&lt;/code&gt;:</source>
          <target state="translated">これにより、非常にエレガントなコード記述方法がしばしば開かれます。 ただし、 &lt;code&gt;BasicCalculator&lt;/code&gt; から拡張したいクラスには問題がありました。 ユーザーが &lt;code&gt;ScientificCalculator&lt;/code&gt; の作成を開始したいと想像してください。</target>
        </trans-unit>
        <trans-unit id="93d9ec6cf3f9136de052694a0e5be31bcf80b6f6" translate="yes" xml:space="preserve">
          <source>This only apply to types with an &lt;em&gt;explicit&lt;/em&gt; string index signature. It is still an error to access unknown properties on a type using &lt;code&gt;.&lt;/code&gt; notation.</source>
          <target state="translated">これは、 &lt;em&gt;明示的な&lt;/em&gt;文字列インデックス署名を持つ型にのみ適用されます。 を使用して型の不明なプロパティにアクセスすることは、依然としてエラー &lt;code&gt;.&lt;/code&gt; 表記法。</target>
        </trans-unit>
        <trans-unit id="ac04689bd985aaff5480421363910106fc5c181c" translate="yes" xml:space="preserve">
          <source>This option is similar to &lt;code&gt;UseFsEvents&lt;/code&gt; except on failing to create watch using &lt;code&gt;fs.watch&lt;/code&gt;, the fallback watching happens through dynamic polling queues (as explained in &lt;code&gt;DynamicPriorityPolling&lt;/code&gt;)</source>
          <target state="translated">このオプションは &lt;code&gt;UseFsEvents&lt;/code&gt; に似ていますが、 fs.watchを使用した監視の作成に失敗すると、動的監視キューを介してフォールバック監視が発生します（ &lt;code&gt;DynamicPriorityPolling&lt;/code&gt; で説明）</target>
        </trans-unit>
        <trans-unit id="0aae93fe007c809a7e2e36db92dc9e5b379de835" translate="yes" xml:space="preserve">
          <source>This option watches parent directory of the file with &lt;code&gt;fs.watch&lt;/code&gt; (using file system events) thus being low on CPU but can compromise accuracy.</source>
          <target state="translated">このオプションは &lt;code&gt;fs.watch&lt;/code&gt; （ファイルシステムイベントを使用）でファイルの親ディレクトリを監視するため、CPUの負荷は低くなりますが、精度が低下する可能性があります。</target>
        </trans-unit>
        <trans-unit id="87694e596c33f73edc99c67b8848fbcbde1e4c9c" translate="yes" xml:space="preserve">
          <source>This post outlines the various ways to organize your code using namespaces (previously &amp;ldquo;internal modules&amp;rdquo;) in TypeScript. As we alluded in our note about terminology, &amp;ldquo;internal modules&amp;rdquo; are now referred to as &amp;ldquo;namespaces&amp;rdquo;. Additionally, anywhere the &lt;code&gt;module&lt;/code&gt; keyword was used when declaring an internal module, the &lt;code&gt;namespace&lt;/code&gt; keyword can and should be used instead. This avoids confusing new users by overloading them with similarly named terms.</source>
          <target state="translated">この投稿では、TypeScriptの名前空間（以前の「内部モジュール」）を使用してコードを整理するさまざまな方法の概要を説明します。 用語に関するメモでほのめかしたように、「内部モジュール」は「名前空間」と呼ばれるようになりました。 さらに、内部モジュールを宣言するときに &lt;code&gt;module&lt;/code&gt; キーワードが使用された場所では、代わりに &lt;code&gt;namespace&lt;/code&gt; キーワードを使用できます 。 これにより、同様の名前の用語で新しいユーザーをオーバーロードすることにより、新しいユーザーの混乱を防ぎます。</target>
        </trans-unit>
        <trans-unit id="67e03678783967eef2733d80436705f614849f7f" translate="yes" xml:space="preserve">
          <source>This post outlines the various ways to organize your code using namespaces and modules in TypeScript. We&amp;rsquo;ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript.</source>
          <target state="translated">この投稿では、TypeScriptの名前空間とモジュールを使用してコードを整理するさまざまな方法の概要を説明します。 また、名前空間とモジュールの使用方法に関するいくつかの高度なトピックに目を通し、TypeScriptで使用する際の一般的な落とし穴に対処します。</target>
        </trans-unit>
        <trans-unit id="fd64220fbecc8854d60d2a4f4f20ca94bda2d4e7" translate="yes" xml:space="preserve">
          <source>This presents a simple entry point; e.g. in the TypeScript repo we simply run &lt;code&gt;tsc -b src&lt;/code&gt; to build all endpoints because we list all the subprojects in &lt;code&gt;src/tsconfig.json&lt;/code&gt;</source>
          <target state="translated">これは単純なエントリポイントを示します。 たとえば、TypeScriptリポジトリでは、 &lt;code&gt;src/tsconfig.json&lt;/code&gt; のすべてのサブプロジェクトをリストするため、単に &lt;code&gt;tsc -b src&lt;/code&gt; を実行してすべてのエンドポイントをビルドします。</target>
        </trans-unit>
        <trans-unit id="96c2c0f0e97743735b953a624ea594af85aaba20" translate="yes" xml:space="preserve">
          <source>This presents a very good opportunity for destructuring in the consuming code:</source>
          <target state="translated">これは、消費するコードを破壊するための非常に良い機会を提供します。</target>
        </trans-unit>
        <trans-unit id="90339bda9cc4062b63e151a5bde442af3f17fdf3" translate="yes" xml:space="preserve">
          <source>This quick start guide will teach you how to build TypeScript with &lt;a href=&quot;http://gulpjs.com&quot;&gt;gulp&lt;/a&gt; and then add &lt;a href=&quot;http://browserify.org&quot;&gt;Browserify&lt;/a&gt;, &lt;a href=&quot;http://lisperator.net/uglifyjs/&quot;&gt;uglify&lt;/a&gt;, or &lt;a href=&quot;https://github.com/substack/watchify&quot;&gt;Watchify&lt;/a&gt; to the gulp pipeline. This guide also shows how to add &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; functionality using &lt;a href=&quot;https://github.com/babel/babelify&quot;&gt;Babelify&lt;/a&gt;.</source>
          <target state="translated">このクイックスタートガイドでは、 &lt;a href=&quot;http://lisperator.net/uglifyjs/&quot;&gt;gulp&lt;/a&gt;を使用してTypeScriptをビルドし、 &lt;a href=&quot;http://browserify.org&quot;&gt;Browserify&lt;/a&gt; 、 uglify 、または&lt;a href=&quot;https://github.com/substack/watchify&quot;&gt;Watchify&lt;/a&gt;をgulpパイプラインに追加する方法を説明します。 このガイドでは、 &lt;a href=&quot;https://github.com/babel/babelify&quot;&gt;Babelify&lt;/a&gt;を使用して&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;機能を追加する方法も示します。</target>
        </trans-unit>
        <trans-unit id="4771bc2bab27a199d772c4ea0beb5b94f1557d90" translate="yes" xml:space="preserve">
          <source>This resolution strategy attempts to mimic the &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; module resolution mechanism at runtime. The full Node.js resolution algorithm is outlined in &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_all_together&quot;&gt;Node.js module documentation&lt;/a&gt;.</source>
          <target state="translated">この解決戦略は、実行時に&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;モジュール解決メカニズムを模倣しようとします。 Node.jsの完全な解決アルゴリズムは、 &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_all_together&quot;&gt;Node.jsモジュールのドキュメントで&lt;/a&gt;概説されています 。</target>
        </trans-unit>
        <trans-unit id="a4282404c916b4f4b5fe9e3d34bc8423764a9741" translate="yes" xml:space="preserve">
          <source>This results in the generated JS</source>
          <target state="translated">この結果、生成されたJS</target>
        </trans-unit>
        <trans-unit id="ef4b88dc9b6e4d599f0dfab38e9b347bbf2884ea" translate="yes" xml:space="preserve">
          <source>This section assumes some basic knowledge about modules. Please see the &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; documentation for more information.</source>
          <target state="translated">このセクションでは、モジュールに関するいくつかの基本的な知識を前提としています。 詳細については、 &lt;a href=&quot;modules&quot;&gt;モジュールの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="f9fb839c0cccd09c3b2a3d1ab1913df898747ff9" translate="yes" xml:space="preserve">
          <source>This should not be confused with the idea that the values they refer to are &lt;em&gt;immutable&lt;/em&gt;.</source>
          <target state="translated">これは、参照する値が&lt;em&gt;不変&lt;/em&gt;であるという考えと混同しないでください。</target>
        </trans-unit>
        <trans-unit id="a1f229269d84a6a8939b736e452446c28bdac1e5" translate="yes" xml:space="preserve">
          <source>This simple example shows how the names used during importing and exporting get translated into the module loading code.</source>
          <target state="translated">このシンプルな例では、インポートとエクスポートの際に使用される名前がどのようにモジュールの読み込みコードに変換されるかを示しています。</target>
        </trans-unit>
        <trans-unit id="c02e5a7acc21e96b7b427fe531770986b2a8029c" translate="yes" xml:space="preserve">
          <source>This tells the compiler for any module import that matches the pattern &lt;code&gt;&quot;*&quot;&lt;/code&gt; (i.e. all values), to look in two locations:</source>
          <target state="translated">これは、パターン &lt;code&gt;&quot;*&quot;&lt;/code&gt; （つまり、すべての値）に一致するモジュールインポートを2つの場所で検索するようコンパイラーに指示します。</target>
        </trans-unit>
        <trans-unit id="e28988a9e9ef50dbc6082fe7ec51c8e202185991" translate="yes" xml:space="preserve">
          <source>This treats the classes as interfaces, and only mixes the types behind Disposable and Activatable into the SmartObject type rather than the implementation. This means that we&amp;rsquo;ll have to provide the implementation in class. Except, that&amp;rsquo;s exactly what we want to avoid by using mixins.</source>
          <target state="translated">これにより、クラスがインターフェイスとして扱われ、DisposableおよびActivatableの背後にある型のみが、実装ではなくSmartObject型に混在します。 これは、クラスで実装を提供する必要があることを意味します。 例外として、それはまさにミックスインを使用することで回避したいものです。</target>
        </trans-unit>
        <trans-unit id="9a9277b80c882b7208b460979a9bd488c375c6cf" translate="yes" xml:space="preserve">
          <source>This used to be TypeScript&amp;rsquo;s default resolution strategy. Nowadays, this strategy is mainly present for backward compatibility.</source>
          <target state="translated">これはかつてTypeScriptのデフォルトの解決戦略でした。 現在、この戦略は主に下位互換性のために存在しています。</target>
        </trans-unit>
        <trans-unit id="93fddce73184becc8bb1dcac36b8151b2a00b289" translate="yes" xml:space="preserve">
          <source>This utility does not return a transformed type. Instead, it serves as a marker for a contextual &lt;code&gt;this&lt;/code&gt; type. Note that the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag must be enabled to use this utility.</source>
          <target state="translated">このユーティリティは、変換された型を返しません。 代わりに、コンテキストの &lt;code&gt;this&lt;/code&gt; タイプのマーカーとして機能します。 このユーティリティを使用するには、 &lt;code&gt;--noImplicitThis&lt;/code&gt; フラグを有効にする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="af2d32c38013b382c9d64510bcce20de81efb3be" translate="yes" xml:space="preserve">
          <source>This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;frozen object&lt;/a&gt;).</source>
          <target state="translated">このユーティリティは、実行時に失敗する割り当て式を表すのに役立ちます（つまり、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;フリーズしたオブジェクトの&lt;/a&gt;プロパティを再割り当てしようとする場合 ）。</target>
        </trans-unit>
        <trans-unit id="eaff2ada45477df0b05b97a2def6303701764e4e" translate="yes" xml:space="preserve">
          <source>This version of the loop will actually perform the summation correctly because the inner loop&amp;rsquo;s &lt;code&gt;i&lt;/code&gt; shadows &lt;code&gt;i&lt;/code&gt; from the outer loop.</source>
          <target state="translated">このバージョンのループは、内側のループの &lt;code&gt;i&lt;/code&gt; が外側のループからiをシャドウイングするため、実際に加算を正しく実行します。</target>
        </trans-unit>
        <trans-unit id="9381442c6d6f687b278f6b0753897426078289bf" translate="yes" xml:space="preserve">
          <source>This works because arrow functions use the outer &lt;code&gt;this&lt;/code&gt;, so you can always pass them to something that expects &lt;code&gt;this: void&lt;/code&gt;. The downside is that one arrow function is created per object of type Handler. Methods, on the other hand, are only created once and attached to Handler&amp;rsquo;s prototype. They are shared between all objects of type Handler.</source>
          <target state="translated">これが機能するのは、矢印関数が外部 &lt;code&gt;this&lt;/code&gt; を使用するため、これを期待するものに常に渡すことができるためです &lt;code&gt;this: void&lt;/code&gt; 欠点は、タイプHandlerのオブジェクトごとに1つの矢印関数が作成されることです。 一方、メソッドは一度だけ作成され、ハンドラのプロトタイプに添付されます。 これらは、タイプHandlerのすべてのオブジェクト間で共有されます。</target>
        </trans-unit>
        <trans-unit id="a855814a311b76c2385f1f8fa0122f8b7cb5fd05" translate="yes" xml:space="preserve">
          <source>This works fine in TypeScript too, but the compiler doesn&amp;rsquo;t know about &lt;code&gt;Observable.prototype.map&lt;/code&gt;. You can use module augmentation to tell the compiler about it:</source>
          <target state="translated">これはTypeScriptでも正常に機能しますが、コンパイラーは &lt;code&gt;Observable.prototype.map&lt;/code&gt; を認識しません。 モジュール拡張を使用して、コンパイラーにそれを伝えることができます。</target>
        </trans-unit>
        <trans-unit id="90afc95581c28b0ae5570b6d400541b7e8730c10" translate="yes" xml:space="preserve">
          <source>This works well enough, but we might imagine that &lt;code&gt;SomeType&lt;/code&gt; and &lt;code&gt;SomeVar&lt;/code&gt; were very closely related such that you&amp;rsquo;d like them to have the same name. We can use combining to present these two different objects (the value and the type) under the same name &lt;code&gt;Bar&lt;/code&gt;:</source>
          <target state="translated">これは十分に機能しますが、 &lt;code&gt;SomeType&lt;/code&gt; と &lt;code&gt;SomeVar&lt;/code&gt; は非常に密接に関連しているため、同じ名前にしたいと考えているかもしれません。 結合を使用して、これら2つの異なるオブジェクト（値とタイプ）を同じ名前 &lt;code&gt;Bar&lt;/code&gt; で表示できます。</target>
        </trans-unit>
        <trans-unit id="8fe51f943aa966ad44227ae1d5f6f6ffe2daa142" translate="yes" xml:space="preserve">
          <source>ThisParameterType</source>
          <target state="translated">ThisParameterType</target>
        </trans-unit>
        <trans-unit id="476185d9e02b1c2446403ce730e896811f7c5c6c" translate="yes" xml:space="preserve">
          <source>ThisType&amp;lt;T&amp;gt;</source>
          <target state="translated">ThisType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="141ee6a2eac7f3e80ad87c7204dbdc726776e142" translate="yes" xml:space="preserve">
          <source>Though not recommended practice, some modules set up some global state that can be used by other modules. These modules may not have any exports, or the consumer is not interested in any of their exports. To import these modules, use:</source>
          <target state="translated">推奨される実践ではありませんが、モジュールによっては、他のモジュールで使用できるグローバルな状態を設定しているものがあります。これらのモジュールはエクスポートを持っていないかもしれませんし、消費者がそのエクスポートに興味を持っていないかもしれません。これらのモジュールをインポートするには</target>
        </trans-unit>
        <trans-unit id="459af1bfbb68d7eb9e20b58d77f575123c077dc5" translate="yes" xml:space="preserve">
          <source>Thus, the following calls are equivalent:</source>
          <target state="translated">したがって、以下の呼び出しは等価です。</target>
        </trans-unit>
        <trans-unit id="c479684dc5713300c68d9b67d81ddc804c214909" translate="yes" xml:space="preserve">
          <source>To allow differentiation between returned values and yielded values, TypeScript 3.6 converts the &lt;code&gt;IteratorResult&lt;/code&gt; type to a discriminated union type:</source>
          <target state="translated">返された値と生成された値を区別できるように、TypeScript 3.6は &lt;code&gt;IteratorResult&lt;/code&gt; 型を識別された共用体型に変換します。</target>
        </trans-unit>
        <trans-unit id="b4b29c56482897c2bcedcd82df10d23478983ef9" translate="yes" xml:space="preserve">
          <source>To begin, just as in JavaScript, TypeScript functions can be created both as a named function or as an anonymous function. This allows you to choose the most appropriate approach for your application, whether you&amp;rsquo;re building a list of functions in an API or a one-off function to hand off to another function.</source>
          <target state="translated">JavaScriptの場合と同様に、TypeScript関数は名前付き関数または匿名関数として作成できます。 これにより、API内の関数のリストを作成する場合でも、別の関数に渡すための1回限りの関数を作成する場合でも、アプリケーションに最適なアプローチを選択できます。</target>
        </trans-unit>
        <trans-unit id="ed7d2301f55dd416668c23e26708f6625cc0b7df" translate="yes" xml:space="preserve">
          <source>To check if &lt;code&gt;x&lt;/code&gt; is assignable to &lt;code&gt;y&lt;/code&gt;, we first look at the parameter list. Each parameter in &lt;code&gt;x&lt;/code&gt; must have a corresponding parameter in &lt;code&gt;y&lt;/code&gt; with a compatible type. Note that the names of the parameters are not considered, only their types. In this case, every parameter of &lt;code&gt;x&lt;/code&gt; has a corresponding compatible parameter in &lt;code&gt;y&lt;/code&gt;, so the assignment is allowed.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; が &lt;code&gt;y&lt;/code&gt; に割り当て可能かどうかを確認するには、最初にパラメーターリストを確認します。 &lt;code&gt;x&lt;/code&gt; の各パラメーターには、互換性のあるタイプの対応する &lt;code&gt;y&lt;/code&gt; のパラメーターが必要です。 パラメーターの名前は考慮されず、タイプのみが考慮されることに注意してください。 この場合、 &lt;code&gt;x&lt;/code&gt; のすべてのパラメーターには &lt;code&gt;y&lt;/code&gt; に対応する互換性のあるパラメーターがあるため、割り当てが許可されます。</target>
        </trans-unit>
        <trans-unit id="5aa2d6b34ccb6e986760e69cce9eaf8d194e80e3" translate="yes" xml:space="preserve">
          <source>To check whether &lt;code&gt;y&lt;/code&gt; can be assigned to &lt;code&gt;x&lt;/code&gt;, the compiler checks each property of &lt;code&gt;x&lt;/code&gt; to find a corresponding compatible property in &lt;code&gt;y&lt;/code&gt;. In this case, &lt;code&gt;y&lt;/code&gt; must have a member called &lt;code&gt;name&lt;/code&gt; that is a string. It does, so the assignment is allowed.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; を &lt;code&gt;x&lt;/code&gt; に割り当てることができるかどうかを確認するために、コンパイラは &lt;code&gt;x&lt;/code&gt; の各プロパティをチェックして、 &lt;code&gt;y&lt;/code&gt; の対応する互換性のあるプロパティを見つけます。 この場合、 &lt;code&gt;y&lt;/code&gt; には文字列である &lt;code&gt;name&lt;/code&gt; というメンバーが必要です。 そのため、割り当てが許可されます。</target>
        </trans-unit>
        <trans-unit id="75b4fbb1127914ceb3d21cad503d3f7fc1d4e3ca" translate="yes" xml:space="preserve">
          <source>To compile, we must specify a module target on the command line. For Node.js, use &lt;code&gt;--module commonjs&lt;/code&gt;; for require.js, use &lt;code&gt;--module amd&lt;/code&gt;. For example:</source>
          <target state="translated">コンパイルするには、コマンドラインでモジュールターゲットを指定する必要があります。 Node.jsの場合、-- &lt;code&gt;--module commonjs&lt;/code&gt; 使用します。 require.jsの場合、-- &lt;code&gt;--module amd&lt;/code&gt; 使用します。 例えば：</target>
        </trans-unit>
        <trans-unit id="5c92181f23fdc218d3e5f2c8e5c093d3e88dd341" translate="yes" xml:space="preserve">
          <source>To correctly represent the types that can be passed in to a generator from calls to &lt;code&gt;next()&lt;/code&gt;, TypeScript 3.6 also infers certain uses of &lt;code&gt;yield&lt;/code&gt; within the body of a generator function.</source>
          <target state="translated">&lt;code&gt;next()&lt;/code&gt; の呼び出しからジェネレーターに渡すことができる型を正しく表現するために、TypeScript 3.6はジェネレーター関数の本体内で &lt;code&gt;yield&lt;/code&gt; の特定の使用も推測します。</target>
        </trans-unit>
        <trans-unit id="4a85275c6424e7d3a9f548f3f9d3fe8015b36051" translate="yes" xml:space="preserve">
          <source>To define a type guard, we simply need to define a function whose return type is a &lt;em&gt;type predicate&lt;/em&gt;:</source>
          <target state="translated">型ガードを定義するには、戻り値の型が&lt;em&gt;型述語で&lt;/em&gt;ある関数を定義するだけです。</target>
        </trans-unit>
        <trans-unit id="509608b5d7a3db1a99b623edfaa3336bb28d3b8d" translate="yes" xml:space="preserve">
          <source>To describe a function type with an interface, we give the interface a call signature. This is like a function declaration with only the parameter list and return type given. Each parameter in the parameter list requires both name and type.</source>
          <target state="translated">関数型をインターフェースで記述するために、インターフェースにコールシグネチャを与えます。これは、パラメータリストと戻り値の型だけを与えた関数宣言のようなものです。パラメータリストの各パラメータは、名前と型の両方を必要とします。</target>
        </trans-unit>
        <trans-unit id="c07e6015d0cdce1868d861847dbd57c18c3fb7ac" translate="yes" xml:space="preserve">
          <source>To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes.</source>
          <target state="translated">TypeScriptで書かれていないライブラリの形状を記述するには、ライブラリが公開しているAPIを宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="afcbeb02ce03509365825abf4caef8de00c49ba6" translate="yes" xml:space="preserve">
          <source>To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes. Because most JavaScript libraries expose only a few top-level objects, namespaces are a good way to represent them.</source>
          <target state="translated">TypeScriptで書かれていないライブラリの形を表現するには、そのライブラリが公開しているAPIを宣言する必要があります。ほとんどの JavaScript ライブラリが公開しているのは少数のトップレベルのオブジェクトだけなので、名前空間はそれらを表現するのに適した方法です。</target>
        </trans-unit>
        <trans-unit id="0300d21291d54245672afcd6c034804cd6d8f1af" translate="yes" xml:space="preserve">
          <source>To detect the issue around accessors, TypeScript 3.7 will now emit &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors in &lt;code&gt;.d.ts&lt;/code&gt; files so that in TypeScript can check for overridden accessors.</source>
          <target state="translated">アクセサに関する問題を検出するために、TypeScript 3.7は &lt;code&gt;.d.ts&lt;/code&gt; ファイルで &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; アクセサを発行し、TypeScriptでオーバーライドされたアクセサをチェックできるようになりました。</target>
        </trans-unit>
        <trans-unit id="0105ab9a65a074ef9c63d082566ad7bd09908a6d" translate="yes" xml:space="preserve">
          <source>To do so, we&amp;rsquo;ll create an interface that describes our constraint. Here, we&amp;rsquo;ll create an interface that has a single &lt;code&gt;.length&lt;/code&gt; property and then we&amp;rsquo;ll use this interface and the &lt;code&gt;extends&lt;/code&gt; keyword to denote our constraint:</source>
          <target state="translated">そのために、制約を記述するインターフェースを作成します。 ここでは、単一の &lt;code&gt;.length&lt;/code&gt; プロパティを持つインターフェイスを作成し、このインターフェイスと &lt;code&gt;extends&lt;/code&gt; キーワードを使用して制約を示します。</target>
        </trans-unit>
        <trans-unit id="a28ef11afcbe8d3d69c6a4bf7c61c5a049f90264" translate="yes" xml:space="preserve">
          <source>To do this, you&amp;rsquo;ll need to create a &lt;code&gt;tsconfig.json&lt;/code&gt; which contains a list of your input files as well as all your compilation settings. Simply create a new file in your project root named &lt;code&gt;tsconfig.json&lt;/code&gt; and fill it with the following contents:</source>
          <target state="translated">これを行うには、入力ファイルのリストとすべてのコンパイル設定を含む &lt;code&gt;tsconfig.json&lt;/code&gt; を作成する必要があります。 &lt;code&gt;tsconfig.json&lt;/code&gt; という名前のプロジェクトルートに新しいファイルを作成し、次の内容を入力します。</target>
        </trans-unit>
        <trans-unit id="6a7b875dfeed7fc61c9681ef2adf2ce3963acdd1" translate="yes" xml:space="preserve">
          <source>To enable experimental support for decorators, you must enable the &lt;code&gt;experimentalDecorators&lt;/code&gt; compiler option either on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">デコレータの実験的サポートを有効にするには、コマンドラインまたは &lt;code&gt;tsconfig.json&lt;/code&gt; で &lt;code&gt;experimentalDecorators&lt;/code&gt; コンパイラオプションを有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="e91510089a97db0cb9eadcf3ab17449eabecd456" translate="yes" xml:space="preserve">
          <source>To enable the recursive type alias patterns described above, the &lt;code&gt;typeArguments&lt;/code&gt; property has been removed from the &lt;code&gt;TypeReference&lt;/code&gt; interface. Users should instead use the &lt;code&gt;getTypeArguments&lt;/code&gt; function on &lt;code&gt;TypeChecker&lt;/code&gt; instances.</source>
          <target state="translated">上記の再帰型エイリアスパターンを有効にするため、 &lt;code&gt;typeArguments&lt;/code&gt; プロパティが &lt;code&gt;TypeReference&lt;/code&gt; インターフェイスから削除されました。 代わりに、 &lt;code&gt;TypeChecker&lt;/code&gt; インスタンスで &lt;code&gt;getTypeArguments&lt;/code&gt; 関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e2363be8e6c6cb5a067aea3d8f64f3d22b30a1c7" translate="yes" xml:space="preserve">
          <source>To enable treating symbols as unique literals a new type &lt;code&gt;unique symbol&lt;/code&gt; is available. &lt;code&gt;unique symbol&lt;/code&gt; is a subtype of &lt;code&gt;symbol&lt;/code&gt;, and are produced only from calling &lt;code&gt;Symbol()&lt;/code&gt; or &lt;code&gt;Symbol.for()&lt;/code&gt;, or from explicit type annotations. The new type is only allowed on &lt;code&gt;const&lt;/code&gt; declarations and &lt;code&gt;readonly static&lt;/code&gt; properties, and in order to reference a specific unique symbol, you&amp;rsquo;ll have to use the &lt;code&gt;typeof&lt;/code&gt; operator. Each reference to a &lt;code&gt;unique symbol&lt;/code&gt; implies a completely unique identity that&amp;rsquo;s tied to a given declaration.</source>
          <target state="translated">シンボルを一意のリテラルとして処理できるようにするために、新しいタイプの &lt;code&gt;unique symbol&lt;/code&gt; を使用できます。 &lt;code&gt;unique symbol&lt;/code&gt; はsymbolのサブタイプで &lt;code&gt;symbol&lt;/code&gt; 、 &lt;code&gt;Symbol()&lt;/code&gt; または &lt;code&gt;Symbol.for()&lt;/code&gt; の呼び出し、または明示的な型注釈からのみ生成されます。 新しい型は、 &lt;code&gt;const&lt;/code&gt; 宣言と &lt;code&gt;readonly static&lt;/code&gt; プロパティでのみ許可されます。特定の一意のシンボルを参照するには、 &lt;code&gt;typeof&lt;/code&gt; 演算子を使用する必要があります。 &lt;code&gt;unique symbol&lt;/code&gt; への各参照は、特定の宣言に関連付けられている完全に一意のIDを意味します。</target>
        </trans-unit>
        <trans-unit id="cbf37d6416e66ab0ef9074eb1300931277b42ac8" translate="yes" xml:space="preserve">
          <source>To get more specific, let&amp;rsquo;s build up some motivation and consider the following &lt;code&gt;compose&lt;/code&gt; function:</source>
          <target state="translated">より具体的にするために、モチベーションを高めて、次の &lt;code&gt;compose&lt;/code&gt; 機能を検討してみましょう。</target>
        </trans-unit>
        <trans-unit id="7dd85227b3548e65f6da723dba0b86e37aa0dbf7" translate="yes" xml:space="preserve">
          <source>To get the same code working, we&amp;rsquo;ll need to use a type assertion:</source>
          <target state="translated">同じコードを機能させるには、型アサーションを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="51bcd2ee5a6a2dcd5ba1a0638fe26fb80525ff92" translate="yes" xml:space="preserve">
          <source>To help mitigate the second issue, you can either add an explicit initializer or add a &lt;code&gt;declare&lt;/code&gt; modifier to indicate that a property should have no emit.</source>
          <target state="translated">2番目の問題を軽減するために、明示的な初期化子を追加するか、プロパティに出力がないことを示す &lt;code&gt;declare&lt;/code&gt; 修飾子を追加できます。</target>
        </trans-unit>
        <trans-unit id="13ac7bef7c1c7e11ef81979db1c2f2a81cf19fc2" translate="yes" xml:space="preserve">
          <source>To infer the type of &lt;code&gt;x&lt;/code&gt; in the example above, we must consider the type of each array element. Here we are given two choices for the type of the array: &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt;. The best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates.</source>
          <target state="translated">上記の例で &lt;code&gt;x&lt;/code&gt; の型を推測するには、各配列要素の型を考慮する必要があります。 ここでは、配列のタイプとして &lt;code&gt;number&lt;/code&gt; と &lt;code&gt;null&lt;/code&gt; の 2つの選択肢があります 。 最も一般的なタイプアルゴリズムは、各候補タイプを考慮し、他のすべての候補と互換性のあるタイプを選択します。</target>
        </trans-unit>
        <trans-unit id="2cf2e12d1445d0aadb96f230e547df7611323dbd" translate="yes" xml:space="preserve">
          <source>To learn more, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31116&quot;&gt;check out the original pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31116&quot;&gt;GitHubの元のプルリクエストを&lt;/a&gt;ご覧ください 。</target>
        </trans-unit>
        <trans-unit id="5f5f3e9b4e4a6af029b4267e885fa3ce255b1ecf" translate="yes" xml:space="preserve">
          <source>To maintain type safety, we can use the &lt;code&gt;typeof&lt;/code&gt; keyword. The &lt;code&gt;typeof&lt;/code&gt; keyword, when used in a type position, produces the type of a value, in this case the type of the module.</source>
          <target state="translated">型の安全性を維持するために、 &lt;code&gt;typeof&lt;/code&gt; キーワードを使用できます。 &lt;code&gt;typeof&lt;/code&gt; キーワードを型位置で使用すると、値の型（この場合はモジュールの型）が生成されます。</target>
        </trans-unit>
        <trans-unit id="625fea5502d41397c32546a9a0ea50c65ae835db" translate="yes" xml:space="preserve">
          <source>To merge the namespace value, at each declaration site, if a namespace already exists with the given name, it is further extended by taking the existing namespace and adding the exported members of the second namespace to the first.</source>
          <target state="translated">名前空間の値をマージするために、各宣言サイトで、指定された名前の名前空間がすでに存在する場合は、既存の名前空間を取り、最初の名前空間に2番目の名前空間のエクスポートされたメンバを追加することで、さらに拡張されます。</target>
        </trans-unit>
        <trans-unit id="e313e5ed420f9f03b21861d0bbd9027ef02d9b32" translate="yes" xml:space="preserve">
          <source>To merge the namespaces, type definitions from exported interfaces declared in each namespace are themselves merged, forming a single namespace with merged interface definitions inside.</source>
          <target state="translated">名前空間をマージするには、各名前空間で宣言されたエクスポートされたインタフェースの型定義をマージし、マージされたインタフェース定義を内部に持つ単一の名前空間を形成します。</target>
        </trans-unit>
        <trans-unit id="22cc216e31611ca78f1d455f6fccc99b2815b93a" translate="yes" xml:space="preserve">
          <source>To preserve existing functionality, we also add a simple getter that retrieves &lt;code&gt;fullName&lt;/code&gt; unmodified.</source>
          <target state="translated">既存の機能を保持するために、変更されていない &lt;code&gt;fullName&lt;/code&gt; を取得する単純なゲッターも追加します。</target>
        </trans-unit>
        <trans-unit id="f744a2110e26e2b8cb5b64d6c11b34abc0ac07e8" translate="yes" xml:space="preserve">
          <source>To prove to ourselves that our accessor is now checking the length of values, we can attempt to assign a name longer than 10 characters and verify that we get an error.</source>
          <target state="translated">アクセサが値の長さをチェックするようになったことを自分自身に証明するために、10文字よりも長い名前を代入してみて、エラーが出ることを確認することができます。</target>
        </trans-unit>
        <trans-unit id="d0b5bbb81ca0d263287358fac537a9ccf83a25cd" translate="yes" xml:space="preserve">
          <source>To quickly recap what these two approaches look like in JavaScript:</source>
          <target state="translated">この2つのアプローチがJavaScriptでどのようなものかを素早く復習するために。</target>
        </trans-unit>
        <trans-unit id="e294e29d961a6bb9b93ca330847244995e631e4c" translate="yes" xml:space="preserve">
          <source>To read up more about assertion signatures, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;check out the original pull request&lt;/a&gt;.</source>
          <target state="translated">アサーションシグネチャの詳細について&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;は、元のプルリクエストを&lt;/a&gt;ご覧ください 。</target>
        </trans-unit>
        <trans-unit id="5032cc8bd0b8d34fd39729d94585dfdc34772a96" translate="yes" xml:space="preserve">
          <source>To reiterate why you shouldn&amp;rsquo;t try to namespace your module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions. Because the module file itself is already a logical grouping, and its top-level name is defined by the code that imports it, it&amp;rsquo;s unnecessary to use an additional module layer for exported objects.</source>
          <target state="translated">モジュールのコンテンツを名前空間にしようとしない理由を繰り返すために、名前空間の一般的な考え方は、構造の論理的なグループ化を提供し、名前の衝突を防ぐことです。 モジュールファイル自体は既に論理グループであり、その最上位の名前はそれをインポートするコードによって定義されているため、エクスポートされたオブジェクトに追加のモジュールレイヤーを使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="8f051c1386e5d7793a46792a39ce291a486c3239" translate="yes" xml:space="preserve">
          <source>To specify this relationship to the compiler, use&lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt;. &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; specify a list of &lt;em&gt;roots&lt;/em&gt; whose contents are expected to merge at run-time. So following our example, the &lt;code&gt;tsconfig.json&lt;/code&gt; file should look like:</source>
          <target state="translated">この関係をコンパイラーに指定するには、 &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; 使用します。 &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; は、実行時に内容がマージされると予想される&lt;em&gt;ルートの&lt;/em&gt;リストを指定します。 この例に従って、 &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルは次のようになります。</target>
        </trans-unit>
        <trans-unit id="815547684a56e87f0f61f4eec10d3298c1894627" translate="yes" xml:space="preserve">
          <source>To start off, let&amp;rsquo;s do the &amp;ldquo;hello world&amp;rdquo; of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the &lt;code&gt;echo&lt;/code&gt; command.</source>
          <target state="translated">最初に、ジェネリックの「hello world」である恒等関数を実行してみましょう。 識別関数は、渡されたものをすべて返す関数です。これは、 &lt;code&gt;echo&lt;/code&gt; コマンドと同様の方法で考えることができます。</target>
        </trans-unit>
        <trans-unit id="e5b9fe870e7f5bf7070c8d8bb27856dc22fe14ff" translate="yes" xml:space="preserve">
          <source>To start, we&amp;rsquo;re going to structure our project in the following way:</source>
          <target state="translated">最初に、プロジェクトを次のように構成します。</target>
        </trans-unit>
        <trans-unit id="c6351bd2f28ea37dec03ce0f4f1566144d901482" translate="yes" xml:space="preserve">
          <source>To understand the full impact, read &lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;the section above on the &lt;code&gt;useDefineForClassFields&lt;/code&gt; flag&lt;/a&gt;.</source>
          <target state="translated">完全な影響を理解するには、 &lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;上記の &lt;code&gt;useDefineForClassFields&lt;/code&gt; フラグに関するセクションをお&lt;/a&gt;読みください。</target>
        </trans-unit>
        <trans-unit id="f47b632fb61682e3e1980ea8cfc2ca8c1262d2a4" translate="yes" xml:space="preserve">
          <source>To understand what steps the TS compiler will follow, it is important to shed some light on Node.js modules. Traditionally, imports in Node.js are performed by calling a function named &lt;code&gt;require&lt;/code&gt;. The behavior Node.js takes will differ depending on if &lt;code&gt;require&lt;/code&gt; is given a relative path or a non-relative path.</source>
          <target state="translated">TSコンパイラがどのステップに従うかを理解するには、Node.jsモジュールに光を当てることが重要です。 従来、Node.jsのインポートは &lt;code&gt;require&lt;/code&gt; という名前の関数を呼び出すことで実行されていました。 Node.jsの動作は、 &lt;code&gt;require&lt;/code&gt; に相対パスまたは非相対パスが指定されているかどうかによって異なります。</target>
        </trans-unit>
        <trans-unit id="dfa2ee0b72c86bc53820792311112500d3168498" translate="yes" xml:space="preserve">
          <source>To use JSX with React you should use the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;React typings&lt;/a&gt;. These typings define the &lt;code&gt;JSX&lt;/code&gt; namespace appropriately for use with React.</source>
          <target state="translated">ReactでJSXを使用するには、 &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;Reactのタイピング&lt;/a&gt;を使用する必要があります。 これらの型付けは、Reactで使用するために &lt;code&gt;JSX&lt;/code&gt; 名前空間を適切に定義します。</target>
        </trans-unit>
        <trans-unit id="4e99d36c2c814e6db91b56c7f1385a2856d73b4a" translate="yes" xml:space="preserve">
          <source>To use JSX-support with React you should use the &lt;a href=&quot;https://github.com/borisyankov/DefinitelyTyped/tree/master/react&quot;&gt;React typings&lt;/a&gt;. These typings define the &lt;code&gt;JSX&lt;/code&gt; namespace so that TypeScript can correctly check JSX expressions for React. For example:</source>
          <target state="translated">ReactでJSXサポートを使用するには、 &lt;a href=&quot;https://github.com/borisyankov/DefinitelyTyped/tree/master/react&quot;&gt;Reactのタイピング&lt;/a&gt;を使用する必要があります。 これらの型付けは、TypeScriptがReactのJSX式を正しくチェックできるように &lt;code&gt;JSX&lt;/code&gt; 名前空間を定義します。 例えば：</target>
        </trans-unit>
        <trans-unit id="8c8d5eec1e67cb76f8e5b9452d73b271fa703953" translate="yes" xml:space="preserve">
          <source>Today, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn&amp;rsquo;t actually UMD.</source>
          <target state="translated">現在、最も人気のあるグローバルにアクセス可能なライブラリは、実際にはUMDライブラリとして記述されています（以下を参照）。 UMDライブラリドキュメントは、グローバルライブラリドキュメントと区別するのが困難です。 グローバル宣言ファイルを作成する前に、ライブラリが実際にUMDでないことを確認してください。</target>
        </trans-unit>
        <trans-unit id="6fd792937ccf8cb9ce4609174a62036b37620b1a" translate="yes" xml:space="preserve">
          <source>Together (1) and (2) mean that we have to move our call to &lt;code&gt;browserify&lt;/code&gt; out of the &lt;code&gt;default&lt;/code&gt; task. And we have to give the function for &lt;code&gt;default&lt;/code&gt; a name since both Watchify and Gulp need to call it. Adding logging with (3) is optional but very useful for debugging your setup.</source>
          <target state="translated">（1）と（2）を &lt;code&gt;browserify&lt;/code&gt; すると、 browserifyへの呼び出しを &lt;code&gt;default&lt;/code&gt; タスクから移動する必要があります 。 また、WatchifyとGulpの両方が呼び出す必要があるため、 &lt;code&gt;default&lt;/code&gt; の関数に名前を付ける必要があります。 （3）によるロギングの追加はオプションですが、セットアップのデバッグに非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="90ffa057dee234ae14145ef7d88d4144f613ba98" translate="yes" xml:space="preserve">
          <source>Together with intersection types, we can make some pretty mind-bending types:</source>
          <target state="translated">交差点タイプと合わせて、かなり心を揺さぶるタイプを作ることができます。</target>
        </trans-unit>
        <trans-unit id="fc8a45a8bf9a321fc559be14ce628df7527276e1" translate="yes" xml:space="preserve">
          <source>Too many/too few arguments</source>
          <target state="translated">議論が多すぎて少なすぎて</target>
        </trans-unit>
        <trans-unit id="d9b3553c61db15698937a8831d5f65646814ea45" translate="yes" xml:space="preserve">
          <source>ToolsVersion</source>
          <target state="translated">ToolsVersion</target>
        </trans-unit>
        <trans-unit id="2fcfbecfc781cdc6c205a4af08b389fbe5757349" translate="yes" xml:space="preserve">
          <source>Top-level &lt;code&gt;var&lt;/code&gt; statements or &lt;code&gt;function&lt;/code&gt; declarations</source>
          <target state="translated">トップレベルの &lt;code&gt;var&lt;/code&gt; ステートメントまたは &lt;code&gt;function&lt;/code&gt; 宣言</target>
        </trans-unit>
        <trans-unit id="d190cc42b7745bd9ac9a35c4f9aea03a1b699465" translate="yes" xml:space="preserve">
          <source>Tracing module resolution</source>
          <target state="translated">トレースモジュールの解像度</target>
        </trans-unit>
        <trans-unit id="23fcdfe71b99cac9d947ed514f12d8af78487a21" translate="yes" xml:space="preserve">
          <source>Trade-offs of Modules</source>
          <target state="translated">モジュールのトレードオフ</target>
        </trans-unit>
        <trans-unit id="53010e4ab65eb0ff069216401ae1c2dcb7276af7" translate="yes" xml:space="preserve">
          <source>Traditional JavaScript uses functions and prototype-based inheritance to build up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes. Starting with ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers will be able to build their applications using this object-oriented class-based approach. In TypeScript, we allow developers to use these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.</source>
          <target state="translated">従来の JavaScript では、関数やプロトタイプベースの継承を使用して再利用可能なコンポーネントを構築していましたが、クラスが機能を継承し、そのクラスからオブジェクトが構築されるオブジェクト指向のアプローチに慣れているプログラマーにとっては、これは少し気まずいと感じるかもしれません。ECMAScript 2015(ECMAScript 6 としても知られている)から、JavaScript プログラマはこのオブジェクト指向のクラスベースのアプローチを使用してアプリケーションを構築できるようになります。TypeScriptでは、開発者がこれらの技術を今すぐに使用し、JavaScriptの次のバージョンを待つことなく、すべての主要なブラウザやプラットフォームで動作するJavaScriptにコンパイルできるようにしています。</target>
        </trans-unit>
        <trans-unit id="1539cd14df7b42b7daf67ab3a0fb1394a708ce8d" translate="yes" xml:space="preserve">
          <source>Trailing comma in function parameter and argument lists are now allowed. This is an implementation for a &lt;a href=&quot;https://jeffmo.github.io/es-trailing-function-commas/&quot;&gt;Stage-3 ECMAScript proposal&lt;/a&gt; that emits down to valid ES3/ES5/ES6.</source>
          <target state="translated">関数パラメーターおよび引数リストの末尾のコンマが許可されるようになりました。 これは、有効なES3 / ES5 / ES6に出力される&lt;a href=&quot;https://jeffmo.github.io/es-trailing-function-commas/&quot;&gt;Stage-3 ECMAScript提案の&lt;/a&gt;実装です。</target>
        </trans-unit>
        <trans-unit id="676e9d1917b5b40fea52df91ac4e9afc970551cb" translate="yes" xml:space="preserve">
          <source>Trailing commas in function parameter and argument lists</source>
          <target state="translated">関数のパラメータおよび引数リストの末尾にあるカンマ</target>
        </trans-unit>
        <trans-unit id="346f219fb82d976707a1e387e3becf3823d4827c" translate="yes" xml:space="preserve">
          <source>Translate newer JavaScript constructs down to an older version like ECMAScript 5 (using &lt;code&gt;target&lt;/code&gt;).</source>
          <target state="translated">新しいJavaScriptコンストラクトをECMAScript 5などの古いバージョンに変換します（ &lt;code&gt;target&lt;/code&gt; を使用）。</target>
        </trans-unit>
        <trans-unit id="86523d66f5bea3f709bea059e7608d702a785b4a" translate="yes" xml:space="preserve">
          <source>Triple-Slash Directives</source>
          <target state="translated">トリプルスラッシュディレクティブ</target>
        </trans-unit>
        <trans-unit id="98c8afb6c3de9dfeb15ccf98245b5224564946da" translate="yes" xml:space="preserve">
          <source>Triple-slash directives are &lt;strong&gt;only&lt;/strong&gt; valid at the top of their containing file. A triple-slash directive can only be preceded by single or multi-line comments, including other triple-slash directives. If they are encountered following a statement or a declaration they are treated as regular single-line comments, and hold no special meaning.</source>
          <target state="translated">トリプルスラッシュディレクティブは、含まれるファイルの先頭で&lt;strong&gt;のみ&lt;/strong&gt;有効です。 トリプルスラッシュディレクティブの前には、他のトリプルスラッシュディレクティブを含む単一行または複数行のコメントのみを指定できます。 ステートメントまたは宣言の後に出現する場合、それらは通常の単一行​​コメントとして扱われ、特別な意味は持ちません。</target>
        </trans-unit>
        <trans-unit id="694056eae93e31824a823939ec9db90fae068479" translate="yes" xml:space="preserve">
          <source>Triple-slash directives are single-line comments containing a single XML tag. The contents of the comment are used as compiler directives.</source>
          <target state="translated">トリプルスラッシュディレクティブは、1 つの XML タグを含む 1 行コメントです。コメントの内容はコンパイラディレクティブとして使用されます。</target>
        </trans-unit>
        <trans-unit id="3c8912f7f0f56aa84a0690a0f86c344e802e0ceb" translate="yes" xml:space="preserve">
          <source>Triple-slash references instruct the compiler to include additional files in the compilation process.</source>
          <target state="translated">トリプルスラッシュ参照は、コンパイルプロセスに追加ファイルを含めるようにコンパイラに指示します。</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="a78911125d5984a872d05a288f51fc96a8c5d183" translate="yes" xml:space="preserve">
          <source>Tuple destructuring</source>
          <target state="translated">タプル破壊</target>
        </trans-unit>
        <trans-unit id="5501f69a4f42fb8e135b4df10c2273778be704fd" translate="yes" xml:space="preserve">
          <source>Tuple types</source>
          <target state="translated">タプル型</target>
        </trans-unit>
        <trans-unit id="f4c8d119fb4e608da43d1f1658b2fb16039d3ae4" translate="yes" xml:space="preserve">
          <source>Tuple types allow you to express an array with a fixed number of elements whose types are known, but need not be the same. For example, you may want to represent a value as a pair of a &lt;code&gt;string&lt;/code&gt; and a &lt;code&gt;number&lt;/code&gt;:</source>
          <target state="translated">タプル型を使用すると、型はわかっているが同じである必要のない固定数の要素で配列を表現できます。 たとえば、値を &lt;code&gt;string&lt;/code&gt; と &lt;code&gt;number&lt;/code&gt; ペアとして表すことができます。</target>
        </trans-unit>
        <trans-unit id="b40c00912c71e3e2a5296ac9e1c04677483c24ca" translate="yes" xml:space="preserve">
          <source>Tuple types express an array where the type of certain elements is known, but need not be the same. For example, you may want to represent an array with a &lt;code&gt;string&lt;/code&gt; at position 0 and a &lt;code&gt;number&lt;/code&gt; at position 1:</source>
          <target state="translated">タプル型は、特定の要素の型がわかっている配列を表しますが、同じである必要はありません。 たとえば、位置0に &lt;code&gt;string&lt;/code&gt; あり、位置1に &lt;code&gt;number&lt;/code&gt; ある配列を表すことができます。</target>
        </trans-unit>
        <trans-unit id="3e80f8a540a40c8de1af1a3e84fbfd7f02d4e041" translate="yes" xml:space="preserve">
          <source>Tuple types now permit a &lt;code&gt;?&lt;/code&gt; postfix on element types to indicate that the element is optional:</source>
          <target state="translated">タプル型では、 &lt;code&gt;?&lt;/code&gt; 要素がオプションであることを示す要素タイプの接尾辞：</target>
        </trans-unit>
        <trans-unit id="670c49cda0efba0500f15dd982d4fa2aed2d3f11" translate="yes" xml:space="preserve">
          <source>Tuples in rest parameters and spread expressions</source>
          <target state="translated">残りのパラメータとスプレッド式のタプル</target>
        </trans-unit>
        <trans-unit id="20bb571234709f16dbeaea6bc15866de96b8321d" translate="yes" xml:space="preserve">
          <source>Tuples may be destructured like arrays; the destructuring variables get the types of the corresponding tuple elements:</source>
          <target state="translated">タプルは配列のように破壊することができます;破壊変数は対応するタプル要素の型を取得します。</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">チュートリアル</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="96e00fe98faa413635ba213d31572b56fb6e2bb5" translate="yes" xml:space="preserve">
          <source>Type Alias</source>
          <target state="translated">タイプエイリアス</target>
        </trans-unit>
        <trans-unit id="353ce315d4b89d72fbf39db84d79fda4b261f3b6" translate="yes" xml:space="preserve">
          <source>Type Aliases</source>
          <target state="translated">タイプエイリアス</target>
        </trans-unit>
        <trans-unit id="a6de4b535fedeaa8890bd890b60fe09f87b5f96a" translate="yes" xml:space="preserve">
          <source>Type Checking</source>
          <target state="translated">タイプチェック</target>
        </trans-unit>
        <trans-unit id="69fccbed8b512e180b2e56eec7bf36107d0fc4af" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files</source>
          <target state="translated">JavaScriptファイルをチェックするタイプ</target>
        </trans-unit>
        <trans-unit id="c9bb3cb2e0b8995f27923c9071e954a24b9a502b" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @enum</source>
          <target state="translated">JavaScriptファイルをチェックするタイプ。固有のファイル名</target>
        </trans-unit>
        <trans-unit id="e1907e29cdd514784f2fa3e5a5c0bdf2cc55da0a" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @this</source>
          <target state="translated">JavaScriptファイルをチェックするタイプ。この</target>
        </trans-unit>
        <trans-unit id="facd96a18391e3f3e7ddd9cef95660e1b7913914" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @type</source>
          <target state="translated">JavaScriptファイルをチェックするタイプ。タイプ</target>
        </trans-unit>
        <trans-unit id="9e95ef0e2279689ee3c96fd9dc0e3216f9ec17ae" translate="yes" xml:space="preserve">
          <source>Type Compatibility</source>
          <target state="translated">型の互換性</target>
        </trans-unit>
        <trans-unit id="e9dc1ea4bae0ebaf470542aca51daa44cdcc9111" translate="yes" xml:space="preserve">
          <source>Type Compatibility: Enums</source>
          <target state="translated">タイプの互換性。列挙型</target>
        </trans-unit>
        <trans-unit id="165b26b05bf5c16d49e5cf4d678908fdae6f68f4" translate="yes" xml:space="preserve">
          <source>Type Guards</source>
          <target state="translated">タイプガード</target>
        </trans-unit>
        <trans-unit id="400e9828133bab9e18749f6f036fd264029f1e6c" translate="yes" xml:space="preserve">
          <source>Type Guards and Differentiating Types</source>
          <target state="translated">タイプガードとタイプの違い</target>
        </trans-unit>
        <trans-unit id="79b8bfde654e6b575d1b453221740941f040398d" translate="yes" xml:space="preserve">
          <source>Type Inference</source>
          <target state="translated">型推論</target>
        </trans-unit>
        <trans-unit id="0e2e016dff9c3ffe6b4498005a639ca83394f86e" translate="yes" xml:space="preserve">
          <source>Type aliases are exactly the same as their original types; they are simply alternative names.</source>
          <target state="translated">型のエイリアスは元の型と全く同じです。</target>
        </trans-unit>
        <trans-unit id="04332612727d798a56e4c9adf1af2f0e95c39d60" translate="yes" xml:space="preserve">
          <source>Type aliases create a new name for a type. Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you&amp;rsquo;d otherwise have to write by hand.</source>
          <target state="translated">型エイリアスは、型の新しい名前を作成します。 型のエイリアスはインターフェイスに似ている場合がありますが、プリミティブ、ユニオン、タプル、および他の方法で手動で記述する必要がある他の型に名前を付けることができます。</target>
        </trans-unit>
        <trans-unit id="74b2b8803d08ed1d0626e3ffe8a2182c1309b352" translate="yes" xml:space="preserve">
          <source>Type aliases have always had a limitation in how they could be &amp;ldquo;recursively&amp;rdquo; referenced. The reason is that any use of a type alias needs to be able to substitute itself with whatever it aliases. In some cases, that&amp;rsquo;s not possible, so the compiler rejects certain recursive aliases like the following:</source>
          <target state="translated">型エイリアスには、常に「再帰的に」参照できる方法に制限があります。 その理由は、型エイリアスを使用する場合は、エイリアスを使用して自分自身を置換できる必要があるためです。 場合によってはそれが不可能なため、コンパイラは次のような特定の再帰的なエイリアスを拒否します。</target>
        </trans-unit>
        <trans-unit id="ee5f3de7938afc6193f57957cf627bbf0b440e19" translate="yes" xml:space="preserve">
          <source>Type annotations</source>
          <target state="translated">型のアノテーション</target>
        </trans-unit>
        <trans-unit id="771c581ff30572b5e74a273ca4a6cfa2c2dd00e9" translate="yes" xml:space="preserve">
          <source>Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable. In this case, we intend the greeter function to be called with a single string parameter. We can try changing the call greeter to pass an array instead:</source>
          <target state="translated">TypeScriptの型アノテーションは、関数や変数の意図する契約を記録するための軽量な方法です。この例では、greeter関数が単一の文字列パラメータで呼び出されることを意図しています。代わりに配列を渡すように greeter の呼び出しを変更してみましょう。</target>
        </trans-unit>
        <trans-unit id="4c0bd0a7f58c36c032f4bebd542b40c8d83ddd62" translate="yes" xml:space="preserve">
          <source>Type assertion/cast syntax in &lt;code&gt;checkJs&lt;/code&gt;/&lt;code&gt;@ts-check&lt;/code&gt; mode</source>
          <target state="translated">&lt;code&gt;checkJs&lt;/code&gt; / &lt;code&gt;@ts-check&lt;/code&gt; モードでアサーション/キャスト構文を入力します</target>
        </trans-unit>
        <trans-unit id="8207094f90fa241c769cf714f68957046cb3e948" translate="yes" xml:space="preserve">
          <source>Type assertions</source>
          <target state="translated">型のアサーション</target>
        </trans-unit>
        <trans-unit id="9d46ff18751ffb41bab6a1e95fa3947ce8fb07c0" translate="yes" xml:space="preserve">
          <source>Type assertions have two forms. One is the &amp;ldquo;angle-bracket&amp;rdquo; syntax:</source>
          <target state="translated">型アサーションには2つの形式があります。 1つは「山括弧」構文です。</target>
        </trans-unit>
        <trans-unit id="252726c38b1deeaec7381a04cf0566bc59bbe5ae" translate="yes" xml:space="preserve">
          <source>Type checking of the &lt;code&gt;instanceof&lt;/code&gt; operator is now based on whether the type of the left operand &lt;em&gt;derives from&lt;/em&gt; the type indicated by the right operand (as opposed to a structural subtype check).</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; 演算子の型チェックは、左オペランドの型が右オペランドで示される型&lt;em&gt;から派生&lt;/em&gt;するかどうかに基づいています （構造サブタイプチェックとは対照的）。</target>
        </trans-unit>
        <trans-unit id="3986b509fdf26a1e0d932541d6bf318fa2f131c4" translate="yes" xml:space="preserve">
          <source>Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with nominal typing. Consider the following code:</source>
          <target state="translated">TypeScript における型の互換性は、構造的なサブタイプに基づいています。構造的型付けとは、型のメンバのみに基づいて型を関連付ける方法です。これは名目型付けとは対照的です。次のコードを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="d40d6a67837031f0abaec956923830758108f84e" translate="yes" xml:space="preserve">
          <source>Type guards and type assertions</source>
          <target state="translated">タイプガードとタイプアサーション</target>
        </trans-unit>
        <trans-unit id="df0459267a3773c5f28373435d5ec35b5af11cce" translate="yes" xml:space="preserve">
          <source>Type guards for dotted names also work with user defined type guard functions and the &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt; operators and do not depend on the &lt;code&gt;--strictNullChecks&lt;/code&gt; compiler option.</source>
          <target state="translated">ドット表記名のタイプガードは、ユーザー定義のタイプガード関数、 &lt;code&gt;typeof&lt;/code&gt; および &lt;code&gt;instanceof&lt;/code&gt; 演算子とも機能し、 &lt;code&gt;--strictNullChecks&lt;/code&gt; コンパイラオプションに依存しません。</target>
        </trans-unit>
        <trans-unit id="df87981f3212072661057f255c1414c8249e617d" translate="yes" xml:space="preserve">
          <source>Type guards inferred from &lt;code&gt;in&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 演算子から推測されるタイプガード</target>
        </trans-unit>
        <trans-unit id="5c04d68c075d1cf49c5039cfaf5a91d9a3af3583" translate="yes" xml:space="preserve">
          <source>Type guards on the common property.</source>
          <target state="translated">共用地にタイプガードを設置。</target>
        </trans-unit>
        <trans-unit id="4a16ed7f934fd06b2eab4f404c014b3aa9ede6e0" translate="yes" xml:space="preserve">
          <source>Type guards previously only supported checking local variables and parameters. Type guards now support checking &amp;ldquo;dotted names&amp;rdquo; consisting of a variable or parameter name followed one or more property accesses.</source>
          <target state="translated">型ガードは、以前はローカル変数とパラメーターのチェックのみをサポートしていました。 タイプガードは、変数またはパラメーター名とそれに続く1つ以上のプロパティアクセスで構成される「ドット表記名」のチェックをサポートするようになりました。</target>
        </trans-unit>
        <trans-unit id="a6fec2d2cb8ea42fc5e8b24e33871a744a3803c5" translate="yes" xml:space="preserve">
          <source>Type in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly.</source>
          <target state="translated">ボックスに入力して、TypeScriptのコードでブレークポイントがヒットし、検査が正しく動作することを確認します。</target>
        </trans-unit>
        <trans-unit id="04a0aaa0033ce536b51805d3619fe260b178891e" translate="yes" xml:space="preserve">
          <source>Type inference also works in &amp;ldquo;the other direction&amp;rdquo; in some cases in TypeScript. This is known as &amp;ldquo;contextual typing&amp;rdquo;. Contextual typing occurs when the type of an expression is implied by its location. For example:</source>
          <target state="translated">型推論は、TypeScriptの場合によっては「他の方向」でも機能します。 これは「コンテキストタイピング」として知られています。 コンテキストタイピングは、式のタイプがその場所によって暗示されるときに発生します。 例えば：</target>
        </trans-unit>
        <trans-unit id="5b50efd50f8efbd22bb877ea81f90fae7f14657c" translate="yes" xml:space="preserve">
          <source>Type inference in conditional types</source>
          <target state="translated">条件付き型の型推論</target>
        </trans-unit>
        <trans-unit id="34f7e0851caaf9f6232cdc334af3947615acc7f1" translate="yes" xml:space="preserve">
          <source>Type parameter inference from contextual types</source>
          <target state="translated">コンテキスト型からの型パラメータ推論</target>
        </trans-unit>
        <trans-unit id="866c38bce26d304928239997fc8fd61be65a48c4" translate="yes" xml:space="preserve">
          <source>Type parameters as constraints</source>
          <target state="translated">制約としての型パラメータ</target>
        </trans-unit>
        <trans-unit id="83cb868a19ad904f84bd14cae43f07e0e83d2688" translate="yes" xml:space="preserve">
          <source>Type widening</source>
          <target state="translated">タイプワイド化</target>
        </trans-unit>
        <trans-unit id="3e24ac06d77df39af05bd30d658cb57a3337ea7e" translate="yes" xml:space="preserve">
          <source>Type-checking for &lt;code&gt;globalThis&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;globalThis&lt;/code&gt; の型チェック</target>
        </trans-unit>
        <trans-unit id="132ee1e5890623f8c51b5d7832771ea869685cc0" translate="yes" xml:space="preserve">
          <source>Type-checking speed-ups</source>
          <target state="translated">タイプチェックのスピードアップ</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="51f19890936977049a98344a575f9d1393582141" translate="yes" xml:space="preserve">
          <source>TypeScript 1.1</source>
          <target state="translated">TypeScript 1.1</target>
        </trans-unit>
        <trans-unit id="b1d54818952af192cd88b3450b54f2603e4f7e6b" translate="yes" xml:space="preserve">
          <source>TypeScript 1.3</source>
          <target state="translated">TypeScript 1.3</target>
        </trans-unit>
        <trans-unit id="4e048202597f480e0a0a50251a2d17601a97331c" translate="yes" xml:space="preserve">
          <source>TypeScript 1.4</source>
          <target state="translated">TypeScript 1.4</target>
        </trans-unit>
        <trans-unit id="f1963162918ae8e217f030a5c747f80a58b5003c" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5</source>
          <target state="translated">TypeScript 1.5</target>
        </trans-unit>
        <trans-unit id="f1a5005d913327706c332f5d05905d598d513f83" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 adds support to ES6 destructuring declarations and assignments.</source>
          <target state="translated">TypeScript 1.5 では、ES6 のデストラクチャリング宣言と代入のサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="335ed14095b748ea23e413ca55e75e72c5f81c2f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 adds support to ES6 for..of loops on arrays for ES3/ES5 as well as full support for Iterator interfaces when targeting ES6.</source>
          <target state="translated">TypeScript 1.5 では、ES3ES5 の配列上でのループのサポートに加え、ES6 をターゲットにした場合の Iterator インターフェイスのフルサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="147499580851a581c1ebc7b1eb35e61574c9455f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 supports ECMAScript 6 (ES6) modules. ES6 modules are effectively TypeScript external modules with a new syntax: ES6 modules are separately loaded source files that possibly import other modules and provide a number of externally accessible exports. ES6 modules feature several new export and import declarations. It is recommended that TypeScript libraries and applications be updated to use the new syntax, but this is not a requirement. The new ES6 module syntax coexists with TypeScript&amp;rsquo;s original internal and external module constructs and the constructs can be mixed and matched at will.</source>
          <target state="translated">TypeScript 1.5は、ECMAScript 6（ES6）モジュールをサポートしています。 ES6モジュールは、新しい構文を持つ事実上TypeScript外部モジュールです。ES6モジュールは、他のモジュールをインポートし、外部からアクセス可能な多数のエクスポートを提供する可能性のある、個別にロードされるソースファイルです。 ES6モジュールには、いくつかの新しいエクスポートおよびインポート宣言があります。 TypeScriptライブラリとアプリケーションを更新して新しい構文を使用することをお勧めしますが、これは要件ではありません。 新しいES6モジュールの構文は、TypeScriptの元の内部および外部モジュール構成と共存し、構成は自由に混合して一致させることができます。</target>
        </trans-unit>
        <trans-unit id="26a05cf740016ec03540fa113e60b6681f5d2b43" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6</source>
          <target state="translated">TypeScript 1.6</target>
        </trans-unit>
        <trans-unit id="257249ad75fda76652230e9b8ec23343f481d876" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds a new way to narrow a variable type inside an &lt;code&gt;if&lt;/code&gt; block, in addition to &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt;. A user-defined type guard functions is one with a return type annotation of the form &lt;code&gt;x is T&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is a declared parameter in the signature, and &lt;code&gt;T&lt;/code&gt; is any type. When a user-defined type guard function is invoked on a variable in an &lt;code&gt;if&lt;/code&gt; block, the type of the variable will be narrowed to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.6では、 &lt;code&gt;typeof&lt;/code&gt; および &lt;code&gt;instanceof&lt;/code&gt; に加えて、 &lt;code&gt;if&lt;/code&gt; ブロック内の変数の型を絞り込む新しい方法が追加されています 。 ユーザー定義のタイプガード関数は、 &lt;code&gt;x is T&lt;/code&gt; の形式の戻りタイプアノテーションを持つものです 。ここで、 &lt;code&gt;x&lt;/code&gt; は署名で宣言されたパラメーターであり、 &lt;code&gt;T&lt;/code&gt; は任意のタイプです。 &lt;code&gt;if&lt;/code&gt; ブロックの変数でユーザー定義のタイプガード関数が呼び出されると、変数のタイプは &lt;code&gt;T&lt;/code&gt; に絞り込まれます。</target>
        </trans-unit>
        <trans-unit id="1f559afb4f11f75baf94b34b6c1d2a9f3ffb7db7" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for &lt;code&gt;abstract&lt;/code&gt; keyword for classes and their methods. An abstract class is allowed to have methods with no implementation, and cannot be constructed.</source>
          <target state="translated">TypeScript 1.6は、クラスとそのメソッドの &lt;code&gt;abstract&lt;/code&gt; キーワードのサポートを追加します。 抽象クラスは、実装のないメソッドを持つことが許可されており、構築できません。</target>
        </trans-unit>
        <trans-unit id="b5e601692f8167fd347befb7fc0e15d90de2b5e2" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for ES6 class expressions. In a class expression, the class name is optional and, if specified, is only in scope in the class expression itself. This is similar to the optional name of a function expression. It is not possible to refer to the class instance type of a class expression outside the class expression, but the type can of course be matched structurally. For example:</source>
          <target state="translated">TypeScript 1.6 では、ES6 のクラス式のサポートが追加されました。クラス式では、クラス名はオプションであり、指定された場合には、クラス式自体のスコープ内にのみ存在します。これは関数式のオプション名と似ています。クラス式の外でクラス式のクラスインスタンス型を参照することはできませんが、もちろん型は構造的に一致させることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="d34db5c0571adb17d9dbb4e011e6ce7abf305442" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for classes extending arbitrary expression that computes a constructor function. This means that built-in types can now be extended in class declarations.</source>
          <target state="translated">TypeScript 1.6 では、コンストラクタ関数を計算する任意の式を拡張するクラスのサポートが追加されました。これは、組み込み型をクラス宣言で拡張できるようになったことを意味します。</target>
        </trans-unit>
        <trans-unit id="6dc2d923fb5094bd0e7c94f1ead891676ccf6b36" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for generators when targeting ES6.</source>
          <target state="translated">TypeScript 1.6では、ES6をターゲットにした場合のジェネレータのサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="c2708dce6a915f6b14074965fa09a0d65239987f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 enforces stricter object literal assignment checks for the purpose of catching excess or misspelled properties. Specifically, when a fresh object literal is assigned to a variable or passed as an argument for a non-empty target type, it is an error for the object literal to specify properties that don&amp;rsquo;t exist in the target type.</source>
          <target state="translated">TypeScript 1.6では、過剰なプロパティやスペルミスのあるプロパティをキャッチする目的で、より厳密なオブジェクトリテラル割り当てチェックを実施しています。 具体的には、新しいオブジェクトリテラルが変数に割り当てられるか、空でないターゲットタイプの引数として渡されると、オブジェクトリテラルがターゲットタイプに存在しないプロパティを指定することはエラーになります。</target>
        </trans-unit>
        <trans-unit id="75bb78b9b873fbe1d3340640c97864da1f68f446" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces a new &lt;code&gt;.tsx&lt;/code&gt; file extension. This extension does two things: it enables JSX inside of TypeScript files, and it makes the new &lt;code&gt;as&lt;/code&gt; operator the default way to cast (removing any ambiguity between JSX expressions and the TypeScript prefix cast operator). For example:</source>
          <target state="translated">TypeScript 1.6では、新しい &lt;code&gt;.tsx&lt;/code&gt; ファイル拡張子が導入されています。 この拡張は2つのことを行います。TypeScriptファイル内でJSXを有効にし、新しい &lt;code&gt;as&lt;/code&gt; 演算子をデフォルトのキャスト方法にします（JSX式とTypeScriptプレフィックスキャスト演算子のあいまいさを取り除きます）。 例えば：</target>
        </trans-unit>
        <trans-unit id="389c8891386ded2a5990a7399a0c8581f595589d" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces experimental support of &lt;code&gt;async&lt;/code&gt; functions when targeting ES6. Async functions are expected to invoke an asynchronous operation and await its result without blocking normal execution of the program. This accomplished through the use of an ES6-compatible &lt;code&gt;Promise&lt;/code&gt; implementation, and transposition of the function body into a compatible form to resume execution when the awaited asynchronous operation completes.</source>
          <target state="translated">TypeScript 1.6では、ES6を対象とした &lt;code&gt;async&lt;/code&gt; 機能の実験的サポートが導入されています。 非同期関数は、非同期操作を呼び出し、プログラムの通常の実行をブロックせずに結果を待機することが期待されています。 これは、ES6互換の &lt;code&gt;Promise&lt;/code&gt; 実装を使用し、関数本体を互換性のある形式に置き換えて、待機中の非同期操作が完了したときに実行を再開することで実現しました。</target>
        </trans-unit>
        <trans-unit id="6d3985068c5007795b0f129f437f0236376e44ee" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces intersection types, the logical complement of union types. A union type &lt;code&gt;A | B&lt;/code&gt; represents an entity that is either of type &lt;code&gt;A&lt;/code&gt; or type &lt;code&gt;B&lt;/code&gt;, whereas an intersection type &lt;code&gt;A &amp;amp; B&lt;/code&gt; represents an entity that is both of type &lt;code&gt;A&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; type &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.6では、ユニオン型の論理的な補完である交差型が導入されています。 ユニオンタイプ &lt;code&gt;A | B&lt;/code&gt; Bはタイプ &lt;code&gt;A&lt;/code&gt; またはタイプ &lt;code&gt;B&lt;/code&gt; のいずれかのエンティティを表し、交差タイプ &lt;code&gt;A &amp;amp; B&lt;/code&gt; はタイプ &lt;code&gt;A&lt;/code&gt; &lt;em&gt;と&lt;/em&gt;タイプ &lt;code&gt;B&lt;/code&gt; の両方のエンティティを表します。</target>
        </trans-unit>
        <trans-unit id="5adb28b0e2ffb9129f1f8e6e88f1a6d027c82cfd" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7</source>
          <target state="translated">TypeScript 1.7</target>
        </trans-unit>
        <trans-unit id="b8049d25161330d1dbcbb77bfa401335476ed317" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 adds &lt;code&gt;ES6&lt;/code&gt; to the list of options available for the &lt;code&gt;--module&lt;/code&gt; flag and allows you to specify the module output when targeting &lt;code&gt;ES6&lt;/code&gt;. This provides more flexibility to target exactly the features you want in specific runtimes.</source>
          <target state="translated">TypeScript 1.7は、 &lt;code&gt;ES6&lt;/code&gt; を &lt;code&gt;--module&lt;/code&gt; フラグで使用可能なオプションのリストに追加し、 ES6をターゲットにするときにモジュール出力を指定できるようにします。 これにより、特定のランタイムで必要な機能を正確に対象とする柔軟性が提供されます。</target>
        </trans-unit>
        <trans-unit id="372cae9853890909499623bfc1859384ca77ae13" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 makes checking of destructuring patterns with an object literal or array literal initializers less rigid and more intuitive.</source>
          <target state="translated">TypeScript 1.7 では、オブジェクトリテラルや配列リテラルのイニシャライザを使った破壊パターンのチェックが、より堅苦しくなく、より直感的に行えるようになりました。</target>
        </trans-unit>
        <trans-unit id="3a8e0881b9f6a916c5d699f8a8930f131e755c61" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 supports upcoming &lt;a href=&quot;https://github.com/rwaldron/exponentiation-operator&quot;&gt;ES7/ES2016 exponentiation operators&lt;/a&gt;: &lt;code&gt;**&lt;/code&gt; and &lt;code&gt;**=&lt;/code&gt;. The operators will be transformed in the output to ES3/ES5 using &lt;code&gt;Math.pow&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.7は、今後の&lt;a href=&quot;https://github.com/rwaldron/exponentiation-operator&quot;&gt;ES7 / ES2016べき乗演算子&lt;/a&gt; &lt;code&gt;**&lt;/code&gt; および &lt;code&gt;**=&lt;/code&gt; をサポートします。 演算子は、 &lt;code&gt;Math.pow&lt;/code&gt; を使用してES3 / ES5への出力で変換されます。</target>
        </trans-unit>
        <trans-unit id="90324bee80eec2d37872bcfe8ebd584d982ffa5e" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8</source>
          <target state="translated">TypeScript 1.8</target>
        </trans-unit>
        <trans-unit id="bf434e8d29bed8fa2f0c97832e4f7465ceae4e51" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 allows &lt;code&gt;tsconfig.json&lt;/code&gt; files in all project types. This includes ASP.NET v4 projects, &lt;em&gt;Console Application&lt;/em&gt;, and the &lt;em&gt;Html Application with TypeScript&lt;/em&gt; project types. Further, you are no longer limited to a single &lt;code&gt;tsconfig.json&lt;/code&gt; file but can add multiple, and each will be built as part of the project. This allows you to separate the configuration for different parts of your application without having to use multiple different projects.</source>
          <target state="translated">TypeScript 1.8では、すべてのプロジェクトタイプで &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルを使用できます。 これには、ASP.NET v4プロジェクト、 &lt;em&gt;コンソールアプリケーション&lt;/em&gt; 、および&lt;em&gt;TypeScript&lt;/em&gt;プロジェクトタイプの&lt;em&gt;Htmlアプリケーションが&lt;/em&gt;含まれます。 さらに、単一の &lt;code&gt;tsconfig.json&lt;/code&gt; ファイルに制限されることはなくなりましたが、複数追加することができ、それぞれがプロジェクトの一部としてビルドされます。 これにより、複数の異なるプロジェクトを使用せずに、アプリケーションのさまざまな部分の構成を分離できます。</target>
        </trans-unit>
        <trans-unit id="523ae0c6d720551553d08e322cbe5f48827a2f11" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 allows users to use the &lt;code&gt;--outFile&lt;/code&gt; argument with special file system entities like named pipes, devices, etc.</source>
          <target state="translated">TypeScript 1.8では、ユーザーは名前付きパイプ、デバイスなどの特別なファイルシステムエンティティで &lt;code&gt;--outFile&lt;/code&gt; 引数を使用できます。</target>
        </trans-unit>
        <trans-unit id="c4f9c3f076e54a2df1c744ed292a1d25e9395f14" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 extends &lt;a href=&quot;typescript-1.6#user-defined-type-guard-functions&quot;&gt;user-defined type guard functions&lt;/a&gt; to class and interface methods.</source>
          <target state="translated">TypeScript 1.8は、 &lt;a href=&quot;typescript-1.6#user-defined-type-guard-functions&quot;&gt;ユーザー定義のタイプガード機能&lt;/a&gt;をクラスおよびインターフェイスメソッドに拡張します 。</target>
        </trans-unit>
        <trans-unit id="c547a86975df477d786c26c38684de89346ada33" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 improves type inference involving source and target sides that are both union or intersection types. For example, when inferring from &lt;code&gt;string | string[]&lt;/code&gt; to &lt;code&gt;string | T&lt;/code&gt;, we reduce the types to &lt;code&gt;string[]&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt;, thus inferring &lt;code&gt;string[]&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.8は、両方がユニオンまたはインターセクション型であるソース側とターゲット側を含む型推論を改善します。 たとえば、 &lt;code&gt;string | string[]&lt;/code&gt; から推測する場合| string [] to &lt;code&gt;string | T&lt;/code&gt; T 、型を &lt;code&gt;string[]&lt;/code&gt; および &lt;code&gt;T&lt;/code&gt; に削減し、 Tの string []を推測し &lt;code&gt;string[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f21f8b70d4093a0a0b9a977e3f5e108e10ca93f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 introduces control flow analysis to help catch common errors that users tend to run into. Read on to get more details, and check out these errors in action:</source>
          <target state="translated">TypeScript 1.8 では、ユーザーが遭遇しがちな一般的なエラーを検出するためのコントロールフロー解析が導入されました。詳細はこちらを読んで、これらのエラーを実際に確認してください。</target>
        </trans-unit>
        <trans-unit id="316c73dc14076f7eaec6a1b058acbdbcd6b03a9b" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0</source>
          <target state="translated">タイプスクリプト2.0</target>
        </trans-unit>
        <trans-unit id="7ed2b43586705d3525a6d00f06348de23a60d9e8" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 adds a new &lt;code&gt;--skipLibCheck&lt;/code&gt; compiler option that causes type checking of declaration files (files with extension &lt;code&gt;.d.ts&lt;/code&gt;) to be skipped. When a program includes large declaration files, the compiler spends a lot of time type checking declarations that are already known to not contain errors, and compile times may be significantly shortened by skipping declaration file type checks.</source>
          <target state="translated">TypeScript 2.0には、宣言ファイル（拡張子 &lt;code&gt;.d.ts&lt;/code&gt; のファイル）の型チェックをスキップする新しい &lt;code&gt;--skipLibCheck&lt;/code&gt; コンパイラオプションが追加されています。 プログラムに大きな宣言ファイルが含まれる場合、コンパイラは、エラーを含まないことが既にわかっている宣言の型チェックに多くの時間を費やし、宣言ファイルの型チェックをスキップすることでコンパイル時間を大幅に短縮できます。</target>
        </trans-unit>
        <trans-unit id="5a7e5d59bd5cadb1929863b64869919254d9fa38" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 has two new flags to help you maintain a clean code base. &lt;code&gt;--noUnusedParameters&lt;/code&gt; flags any unused function or method parameters errors. &lt;code&gt;--noUnusedLocals&lt;/code&gt; flags any unused local (un-exported) declaration like variables, functions, classes, imports, etc&amp;hellip; Also, unused private members of a class would be flagged as errors under &lt;code&gt;--noUnusedLocals&lt;/code&gt;.</source>
          <target state="translated">TypeScript 2.0には、クリーンなコードベースを維持するのに役立つ2つの新しいフラグがあります。 &lt;code&gt;--noUnusedParameters&lt;/code&gt; は 、未使用の関数またはメソッドのパラメーターエラーにフラグを立てます。 &lt;code&gt;--noUnusedLocals&lt;/code&gt; は 、変数、関数、クラス、インポートなどの未使用のローカル（未エクスポート）宣言にフラグを立てます。また、クラスの未使用のプライベートメンバーは、 &lt;code&gt;--noUnusedLocals&lt;/code&gt; の下でエラーとしてフラグが付けられます。</target>
        </trans-unit>
        <trans-unit id="cc8a687464d96e2157a2c30deb24a3363ed46e0d" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 implements a control flow-based type analysis for local variables and parameters. Previously, the type analysis performed for type guards was limited to &lt;code&gt;if&lt;/code&gt; statements and &lt;code&gt;?:&lt;/code&gt; conditional expressions and didn&amp;rsquo;t include effects of assignments and control flow constructs such as &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;break&lt;/code&gt; statements. With TypeScript 2.0, the type checker analyses all possible flows of control in statements and expressions to produce the most specific type possible (the &lt;em&gt;narrowed type&lt;/em&gt;) at any given location for a local variable or parameter that is declared to have a union type.</source>
          <target state="translated">TypeScript 2.0は、ローカル変数とパラメーターの制御フローベースの型分析を実装しています。 以前は、タイプガードに対して実行されるタイプ分析は、 &lt;code&gt;if&lt;/code&gt; ステートメントと &lt;code&gt;?:&lt;/code&gt; 条件式に限定され、割り当てや &lt;code&gt;return&lt;/code&gt; ステートメントや &lt;code&gt;break&lt;/code&gt; ステートメントなどの制御フロー構造の影響は含まれていませんでした。 TypeScript 2.0では、型チェッカーはステートメントおよび式で可能なすべての制御フローを分析して、ユニオン型を持つと宣言されたローカル変数またはパラメーターの任意の場所で可能な限り最も具体的な型（ &lt;em&gt;絞り込み型&lt;/em&gt; ）を生成します。</target>
        </trans-unit>
        <trans-unit id="b991a7d51345ee804bcdb5d52051777fdcb20357" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 implements support for tagged (or discriminated) union types. Specifically, the TS compiler now support type guards that narrow union types based on tests of a discriminant property and furthermore extend that capability to &lt;code&gt;switch&lt;/code&gt; statements.</source>
          <target state="translated">TypeScript 2.0は、タグ付き（または差別化された）ユニオン型のサポートを実装しています。 具体的には、TSコンパイラは、判別プロパティのテストに基づいてユニオン型を絞り込み、さらにステートメントを &lt;code&gt;switch&lt;/code&gt; ためにその機能を拡張する型ガードをサポートするようになりました 。</target>
        </trans-unit>
        <trans-unit id="f541e32a97ad0b756a4e358c4745c3b45d62017f" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 introduces a new primitive type &lt;code&gt;never&lt;/code&gt;. The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. Specifically, &lt;code&gt;never&lt;/code&gt; is the return type for functions that never return and &lt;code&gt;never&lt;/code&gt; is the type of variables under type guards that are never true.</source>
          <target state="translated">TypeScript 2.0は、 &lt;code&gt;never&lt;/code&gt; 新しいプリミティブ型を導入しません 。 &lt;code&gt;never&lt;/code&gt; タイプは、発生しない値のタイプを表します。 具体的には、決して戻らない関数の戻りタイプは決してなく、決して真ではないタイプガード下の変数のタイプは決してありません。</target>
        </trans-unit>
        <trans-unit id="c6947ff29cc72002ee0d4fa4f9ecea90ea690c25" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 provides a set of additional module resolution knops to &lt;em&gt;inform&lt;/em&gt; the compiler where to find declarations for a given module.</source>
          <target state="translated">TypeScript 2.0は、特定のモジュールの宣言を見つける場所をコンパイラーに&lt;em&gt;通知&lt;/em&gt;するための追加のモジュール解決ノブのセットを提供します。</target>
        </trans-unit>
        <trans-unit id="3f3705d152a2f1f40c51f05e54dd28f6cc6cc047" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 relaxes this constraint and allows duplicate identifiers across blocks, as long as they have &lt;em&gt;identical&lt;/em&gt; types.</source>
          <target state="translated">TypeScript 2.0は、この制約を緩和し、ブロックの型が&lt;em&gt;同一である&lt;/em&gt;限り、ブロック全体で識別子を複製できるようにします。</target>
        </trans-unit>
        <trans-unit id="1a29a22cd01cb9654bf025f544accb002ba6f777" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 supports the use of the wildcard character (&lt;code&gt;*&lt;/code&gt;) to declare a &amp;ldquo;family&amp;rdquo; of module names; this way, a declaration is only required once for an extension, and not for every resource.</source>
          <target state="translated">TypeScript 2.0は、ワイルドカード文字（ &lt;code&gt;*&lt;/code&gt; ）の使用をサポートして、モジュール名の「ファミリ」を宣言します。 このように、宣言は拡張機能に対して1回だけ必要であり、すべてのリソースに対しては必要ありません。</target>
        </trans-unit>
        <trans-unit id="e87039bc208381c858aaf91b34ef9a99581764c4" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1</source>
          <target state="translated">TypeScript 2.1</target>
        </trans-unit>
        <trans-unit id="0eb31cb3569ffcba88f7cd6f2aa1426af6d2ca9f" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1 allows for including these files in your project once in a separate module, and the compiler will emit imports to them as needed.</source>
          <target state="translated">TypeScript 2.1 では、これらのファイルをプロジェクト内の別のモジュールに一度だけ含めることができ、コンパイラは必要に応じてこれらのファイルのインポートを行います。</target>
        </trans-unit>
        <trans-unit id="4d20c0e4270450dc5df5d6df69b86f9a3084c753" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1 brings support for &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;ESnext Spread and Rest&lt;/a&gt;.</source>
          <target state="translated">TypeScript 2.1は&lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;ESnext Spread and Rest&lt;/a&gt;をサポートします。</target>
        </trans-unit>
        <trans-unit id="1a2602f6bc15b060152681aebb2deae22d1b7344" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1 supports inheriting configuration using &lt;code&gt;extends&lt;/code&gt;, where:</source>
          <target state="translated">TypeScript 2.1は &lt;code&gt;extends&lt;/code&gt; を使用した構成の継承をサポートしています 。ここで、</target>
        </trans-unit>
        <trans-unit id="e46023b88cb014edcb72d5fe91dd5e9bb7df4962" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1 supports three new target values &lt;code&gt;--target ES2016&lt;/code&gt;, &lt;code&gt;--target ES2017&lt;/code&gt; and &lt;code&gt;--target ESNext&lt;/code&gt;.</source>
          <target state="translated">TypeScript 2.1は、3つの新しいターゲット値 &lt;code&gt;--target ES2016&lt;/code&gt; 、 &lt;code&gt;--target ES2017&lt;/code&gt; 、および &lt;code&gt;--target ESNext&lt;/code&gt; をサポートします。</target>
        </trans-unit>
        <trans-unit id="9b933ffe70d107fc6bfc7a208af67d2175dec62d" translate="yes" xml:space="preserve">
          <source>TypeScript 2.2</source>
          <target state="translated">TypeScript 2.2</target>
        </trans-unit>
        <trans-unit id="af11383d0a489a01508b14d16cfebecdac9851f5" translate="yes" xml:space="preserve">
          <source>TypeScript 2.2 adds support for the ECMAScript 2015 mixin class pattern (see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Mix-ins&quot;&gt;MDN Mixin description&lt;/a&gt; and &lt;a href=&quot;http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/&quot;&gt;&amp;ldquo;Real&amp;rdquo; Mixins with JavaScript Classes&lt;/a&gt; for more details) as well as rules for combining mixin construct signatures with regular construct signatures in intersection types.</source>
          <target state="translated">TypeScript 2.2は、ECMAScript 2015ミックスインクラスパターン（詳細については、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Mix-ins&quot;&gt;MDN&lt;/a&gt; &lt;a href=&quot;http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/&quot;&gt;ミックスインの&lt;/a&gt; 説明とJavaScriptクラスを使用した「実際の」ミックスインを参照）のサポートと、交差タイプでミックスインコンストラクトシグネチャを通常のコンストラクトシグネチャと組み合わせるルールを追加します。</target>
        </trans-unit>
        <trans-unit id="0a2dbbdfdaba8d57c906119c6fac6d8266bfac36" translate="yes" xml:space="preserve">
          <source>TypeScript 2.2 adds support for using spread on a JSX element children. Please see &lt;a href=&quot;https://github.com/facebook/jsx/issues/57&quot;&gt;facebook/jsx#57&lt;/a&gt; for more details.</source>
          <target state="translated">TypeScript 2.2では、JSX要素の子でSpreadを使用するためのサポートが追加されています。 詳細については、 &lt;a href=&quot;https://github.com/facebook/jsx/issues/57&quot;&gt;facebook / jsx＃57&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="4c48aa745cc516094ac80f0eaa3816fe06bddfbf" translate="yes" xml:space="preserve">
          <source>TypeScript 2.2 improves checking of nullable operands in expressions. Specifically, these are now flagged as errors:</source>
          <target state="translated">TypeScript 2.2 では、式中のヌル可能なオペランドのチェックが改善されました。具体的には、これらはエラーとしてフラグが立てられるようになりました。</target>
        </trans-unit>
        <trans-unit id="d38d07af3e985997222428fd513a69781f6cc8f7" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3</source>
          <target state="translated">TypeScript 2.3</target>
        </trans-unit>
        <trans-unit id="b61f4d2dcbfa7df846edf73961314986771cb44f" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3 adds full support for generators and the Iterator protocol for ES3 and ES5 targets with &lt;code&gt;--downlevelIteration&lt;/code&gt; flag.</source>
          <target state="translated">TypeScript 2.3では、ジェネレーターと、ES3およびES5ターゲットのIteratorプロトコルの完全サポートが &lt;code&gt;--downlevelIteration&lt;/code&gt; フラグとともに追加されます。</target>
        </trans-unit>
        <trans-unit id="c7db822200563cfa58805541c7f52f40509bd7eb" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3 adds support for declaring defaults for generic type parameters.</source>
          <target state="translated">TypeScript 2.3 では、一般的な型パラメータのデフォルト宣言のサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="576c3abf51df0a1e8501d6946731fd5b93e9a596" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3 adds support for the async iterators and generators as described by the current &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;TC39 proposal&lt;/a&gt;.</source>
          <target state="translated">TypeScript 2.3は、現在の&lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;TC39提案で&lt;/a&gt;説明されているように、非同期イテレーターとジェネレーターのサポートを追加します。</target>
        </trans-unit>
        <trans-unit id="f9905a786ea9066024ac4028d0fd104e321fa970" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3 and later support type-checking and reporting errors in &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--checkJs&lt;/code&gt;.</source>
          <target state="translated">TypeScript 2.3以降では、-- &lt;code&gt;--checkJs&lt;/code&gt; 使用して、 &lt;code&gt;.js&lt;/code&gt; ファイルのタイプチェックとレポートエラーをサポートしています 。</target>
        </trans-unit>
        <trans-unit id="a711e374d74b34d98e80b0011ffc309914ec3f56" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4</source>
          <target state="translated">TypeScript 2.4</target>
        </trans-unit>
        <trans-unit id="63121e1a86e22e0c3bb62dbea7a515bd9e567278" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4 introduces a few wonderful changes around the way generics are inferred.</source>
          <target state="translated">TypeScript 2.4では、ジェネリックの推論方法にいくつかの素晴らしい変更が加えられています。</target>
        </trans-unit>
        <trans-unit id="4047de971a7748310180f70bca2f83ce413444e5" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4 introduces the concept of &amp;ldquo;weak types&amp;rdquo;. Any type that contains nothing but a set of all-optional properties is considered to be &lt;em&gt;weak&lt;/em&gt;. For example, this &lt;code&gt;Options&lt;/code&gt; type is a weak type:</source>
          <target state="translated">TypeScript 2.4では、「弱い型」の概念が導入されています。 すべてがオプションのプロパティのセットのみを含むタイプはすべて&lt;em&gt;weak&lt;/em&gt;と見なされます。 たとえば、この &lt;code&gt;Options&lt;/code&gt; タイプは弱いタイプです。</target>
        </trans-unit>
        <trans-unit id="86b2369322c0e2cb12bd30f7af1523fb15f271df" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4 introduces tightens this up when relating two callback types. For example:</source>
          <target state="translated">TypeScript 2.4では、2つのコールバックタイプを関連付ける際にこれを強化しています。例えば</target>
        </trans-unit>
        <trans-unit id="76b70868a8ecce2623fa642627ea2865c40679ae" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4 now allows enum members to contain string initializers.</source>
          <target state="translated">TypeScript 2.4では、enumメンバに文字列イニシャライザを含めることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="c757b8632386bce7302d5253a3fe5a403ad48f5b" translate="yes" xml:space="preserve">
          <source>TypeScript 2.5</source>
          <target state="translated">タイプスクリプト2.5</target>
        </trans-unit>
        <trans-unit id="96d62a44f6ecea4f2d8ccb3d978b4697f85a8fe0" translate="yes" xml:space="preserve">
          <source>TypeScript 2.5 brings the &lt;code&gt;preserveSymlinks&lt;/code&gt; flag, which parallels the behavior of &lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;the &lt;code&gt;--preserve-symlinks&lt;/code&gt; flag in Node.js&lt;/a&gt;. This flag also exhibits the opposite behavior to Webpack&amp;rsquo;s &lt;code&gt;resolve.symlinks&lt;/code&gt; option (i.e. setting TypeScript&amp;rsquo;s &lt;code&gt;preserveSymlinks&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; parallels setting Webpack&amp;rsquo;s &lt;code&gt;resolve.symlinks&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, and vice-versa).</source>
          <target state="translated">TypeScript 2.5は、 &lt;code&gt;preserveSymlinks&lt;/code&gt; フラグをもたらします。これ&lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;は、Node.jsの &lt;code&gt;--preserve-symlinks&lt;/code&gt; フラグの&lt;/a&gt;動作に対応しています。 このフラグは、Webpackの &lt;code&gt;resolve.symlinks&lt;/code&gt; オプションとは逆の動作も示します（つまり、TypeScriptの &lt;code&gt;preserveSymlinks&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定し、Webpackの &lt;code&gt;resolve.symlinks&lt;/code&gt; を &lt;code&gt;false&lt;/code&gt; に設定する、またはその逆）。</target>
        </trans-unit>
        <trans-unit id="c8ad58c085604fcd7c2e1f3468a3e3e991a926ce" translate="yes" xml:space="preserve">
          <source>TypeScript 2.5 introduces the ability to &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/5158&quot;&gt;assert the type of expressions when using plain JavaScript in your projects&lt;/a&gt;. The syntax is an &lt;code&gt;/** @type {...} */&lt;/code&gt; annotation comment followed by a parenthesized expression whose type needs to be re-evaluated. For example:</source>
          <target state="translated">TypeScript 2.5では、 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/5158&quot;&gt;プロジェクトでプレーンJavaScriptを使用するときに式のタイプ&lt;/a&gt;をアサートする機能が導入されています 。 構文は、 &lt;code&gt;/** @type {...} */&lt;/code&gt; 注釈コメントの後に、型の再評価が必要な括弧で囲まれた式が続きます。 例えば：</target>
        </trans-unit>
        <trans-unit id="669d038e7cc1925c80d686495e192a922f14d7e5" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6</source>
          <target state="translated">TypeScript 2.6</target>
        </trans-unit>
        <trans-unit id="f05ad28a2eccdd4292c999695e9643dff88f04a9" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 adds revised implementation the &lt;code&gt;--noUnusedLocals&lt;/code&gt; and &lt;code&gt;--noUnusedParameters&lt;/code&gt;&lt;a href=&quot;../compiler-options&quot;&gt;compiler options&lt;/a&gt;. Declarations are only written to but never read from are now flagged as unused.</source>
          <target state="translated">TypeScript 2.6では、-- &lt;code&gt;--noUnusedLocals&lt;/code&gt; および &lt;code&gt;--noUnusedParameters&lt;/code&gt; &lt;a href=&quot;../compiler-options&quot;&gt;コンパイラオプションの&lt;/a&gt;修正された実装が追加されています 。 宣言は書き込まれるだけで、読み込まれることはなく、未使用のフラグが付けられます。</target>
        </trans-unit>
        <trans-unit id="b3d5a37c18c460f27ef01973c59f69c2b7e4b6db" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 also improves type inference involving contravariant positions:</source>
          <target state="translated">TypeScript 2.6では、対照的な位置を含む型推論も改善されています。</target>
        </trans-unit>
        <trans-unit id="597afbba7d51bc72adeb8bdd4361ee8ee1244087" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 brings a faster &lt;code&gt;--watch&lt;/code&gt; implementation. The new version optimizes code generation and checking for code bases using ES modules. Changes detected in a module file will result in &lt;em&gt;only&lt;/em&gt; regenerating the changed module, and files that depend on it, instead of the whole project. Projects with large number of files should reap the most benefit from this change.</source>
          <target state="translated">TypeScript 2.6は、より高速な &lt;code&gt;--watch&lt;/code&gt; 実装をもたらします。 新しいバージョンは、ESモジュールを使用してコード生成とコードベースのチェックを最適化します。 モジュールファイルで変更が検出されると、プロジェクト全体ではなく、変更されたモジュールとそれに依存するファイル&lt;em&gt;のみが&lt;/em&gt;再生成されます。 多数のファイルを含むプロジェクトは、この変更から最大の利益を得るはずです。</target>
        </trans-unit>
        <trans-unit id="bff2120308b7a70612c6347b0884825c125b9bb6" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 fixes the tagged string template emit to align better with the ECMAScript spec. As per the &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-gettemplateobject&quot;&gt;ECMAScript spec&lt;/a&gt;, every time a template tag is evaluated, the &lt;em&gt;same&lt;/em&gt; template strings object (the same &lt;code&gt;TemplateStringsArray&lt;/code&gt;) should be passed as the first argument. Before TypeScript 2.6, the generated output was a completely new template object each time. Though the string contents are the same, this emit affects libraries that use the identity of the string for cache invalidation purposes, e.g. &lt;a href=&quot;https://github.com/PolymerLabs/lit-html/issues/58&quot;&gt;lit-html&lt;/a&gt;.</source>
          <target state="translated">TypeScript 2.6では、タグ付き文字列テンプレートの出力が修正されて、ECMAScript仕様により適合します。 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-gettemplateobject&quot;&gt;ECMAScript仕様&lt;/a&gt;に従って、テンプレートタグが評価されるたびに、 &lt;em&gt;同じ&lt;/em&gt;テンプレート文字列オブジェクト（同じ &lt;code&gt;TemplateStringsArray&lt;/code&gt; ）が最初の引数として渡される必要があります。 TypeScript 2.6以前では、生成される出力は毎回完全に新しいテンプレートオブジェクトでした。 文字列の内容は同じですが、この出力は、キャッシュの無効化のために文字列のIDを使用するライブラリ、たとえば&lt;a href=&quot;https://github.com/PolymerLabs/lit-html/issues/58&quot;&gt;lit-htmlに&lt;/a&gt;影響します。</target>
        </trans-unit>
        <trans-unit id="3332e1f0228da76e93e5e699b31c42f80f487ec2" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 introduces a new strict checking flag, &lt;code&gt;--strictFunctionTypes&lt;/code&gt;. The &lt;code&gt;--strictFunctionTypes&lt;/code&gt; switch is part of the &lt;code&gt;--strict&lt;/code&gt; family of switches, meaning that it defaults to on in &lt;code&gt;--strict&lt;/code&gt; mode. You can opt-out by setting &lt;code&gt;--strictFunctionTypes false&lt;/code&gt; on your command line or in your tsconfig.json.</source>
          <target state="translated">TypeScript 2.6では、新しい厳密なチェックフラグ &lt;code&gt;--strictFunctionTypes&lt;/code&gt; が導入されています。 &lt;code&gt;--strictFunctionTypes&lt;/code&gt; スイッチは &lt;code&gt;--strict&lt;/code&gt; ファミリーのスイッチの一部です。つまり、 &lt;code&gt;--strict&lt;/code&gt; モードではデフォルトでonになります。 コマンドラインまたはtsconfig.jsonで &lt;code&gt;--strictFunctionTypes false&lt;/code&gt; に設定することでオプトアウトできます。</target>
        </trans-unit>
        <trans-unit id="50b83579cf141ddf3a24a6600e359e207807258a" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 npm package ships with localized versions of diagnostic messages for 13 languages. The localized messages are available when using &lt;code&gt;--locale&lt;/code&gt; flag on the command line.</source>
          <target state="translated">TypeScript 2.6 npmパッケージには、13言語のローカライズされたバージョンの診断メッセージが付属しています。 ローカライズされたメッセージは、コマンドラインで &lt;code&gt;--locale&lt;/code&gt; フラグを使用すると利用できます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
